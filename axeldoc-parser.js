"use strict";

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

module.exports = function () {
  "use strict";

  /*
   * Generated by PEG.js 0.9.0.
   *
   * http://pegjs.org/
   */

  function peg$subclass(child, parent) {
    function ctor() {
      this.constructor = child;
    }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
  }

  function peg$SyntaxError(message, expected, found, location) {
    this.message = message;
    this.expected = expected;
    this.found = found;
    this.location = location;
    this.name = "SyntaxError";

    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, peg$SyntaxError);
    }
  }

  peg$subclass(peg$SyntaxError, Error);

  function peg$parse(input) {
    var options = arguments.length > 1 ? arguments[1] : {},
        parser = this,
        peg$FAILED = {},
        peg$startRuleIndices = { Modules: 0 },
        peg$startRuleIndex = 0,
        peg$consts = [function (modules) {
      return modules.map(function (module) {
        return module[0];
      });
    }, "module", { type: "literal", value: "module", description: "\"module\"" }, "{", { type: "literal", value: "{", description: "\"{\"" }, "}", { type: "literal", value: "}", description: "\"}\"" }, function (name, stuff) {
      stuff = stuff.map(function (item) {
        return item[0];
      }).reduce(function (groups, group) {
        if (groups.hasOwnProperty(group.type) === false) {
          groups[group.type] = [];
        }
        groups[group.type].push(group);
        return groups;
      }, {});
      var module = { name: name };
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = Object.keys(stuff)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var type = _step.value;

          module[type] = stuff[type];
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return module;
    }, "@", { type: "literal", value: "@", description: "\"@\"" }, "function", { type: "literal", value: "function", description: "\"function\"" }, function (type, name, props) {
      props = group(props.map(function (prop) {
        return prop[0];
      }), function (prop) {
        if (prop.hasOwnProperty("type") === true) {
          return prop.type;
        }
        return "params";
      });
      if (props.hasOwnProperty("params") === true) {
        props.params = groupItems(props.params, function (param) {
          return param.name;
        }, function (param) {
          return param.value;
        });
      }
      return Object.assign({
        type: type,
        name: name
      }, props);
    }, "@args", { type: "literal", value: "@args", description: "\"@args\"" }, function (args) {
      return { type: "signature", args: args };
    }, function (args) {
      return args.map(function (arg) {
        return arg[0];
      });
    }, "@arg", { type: "literal", value: "@arg", description: "\"@arg\"" }, "*", { type: "literal", value: "*", description: "\"*\"" }, "[", { type: "literal", value: "[", description: "\"[\"" }, "]", { type: "literal", value: "]", description: "\"]\"" }, function (optional, name, type, desc) {
      type = type === null ? [] : type[2];
      desc = desc === null ? "" : desc[1];
      optional = optional !== null;
      return { name: name, type: type, desc: desc, optional: optional };
    }, /^[a-zA-Z]/, { type: "class", value: "[a-zA-Z]", description: "[a-zA-Z]" }, function (type, name, props) {
      return Object.assign({
        type: type,
        name: name
      }, props);
    }, "object", { type: "literal", value: "object", description: "\"object\"" }, function (name, params) {
      return {
        type: "object",
        name: name,
        params: params
      };
    }, function (details) {
      return group(details.map(function (detail) {
        return detail[0];
      }), function (detail) {
        return detail.type || "param";
      });
    }, /^[a-zA-Z_]/, { type: "class", value: "[a-zA-Z_]", description: "[a-zA-Z_]" }, function (type, name, params) {
      //params = params.map(param => param[0]);
      return {
        type: type,
        name: name,
        params: params
      };
    }, function (params) {
      params = params.map(function (param) {
        return param[0];
      });
      return groupItems(params, function (param) {
        return param.name;
      }, function (param) {
        return param.value || true;
      });
    }, function (name, value) {
      if (value !== null) {
        value = value[1];
      }
      return { name: name, value: value };
    }, function (words) {
      return words;
    }, ",", { type: "literal", value: ",", description: "\",\"" }, function (first, rest) {
      if (rest === null) {
        rest = [];
      } else {
        rest = rest[3];
      }
      return [first].concat(_toConsumableArray(rest));
    }, /^[a-zA-Z_.?0-9\/[\]\\!:;'"<>\/()=>$`,\-]/, { type: "class", value: "[a-zA-Z_.?0-9/\\[\\]\\\\!:;'\"<>/()=>$`,\\-]", description: "[a-zA-Z_.?0-9/\\[\\]\\\\!:;'\"<>/()=>$`,\\-]" }, { type: "other", description: "whitespace" }, /^[ \t\n\r]/, { type: "class", value: "[ \\t\\n\\r]", description: "[ \\t\\n\\r]" }],
        peg$bytecode = [peg$decode("%;1/^#$%;!/,#;1/#$+\")(\"'#&'#06*%;!/,#;1/#$+\")(\"'#&'#&/($8\": \"! )(\"'#&'#"), peg$decode("%;1/\xBC#2!\"\"6!7\"/\xAD$;1/\xA4$;0/\x9B$;1/\x92$2#\"\"6#7$/\x83$;1/z$$%;\".# &;&/,#;1/#$+\")(\"'#&'#0<*%;\".# &;&/,#;1/#$+\")(\"'#&'#&/8$2%\"\"6%7&/)$8):')\"%!)()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#"), peg$decode("%2(\"\"6(7)/\xC9#2*\"\"6*7+/\xBA$;1/\xB1$;0/\xA8$;1/\x9F$2#\"\"6#7$/\x90$;1/\x87$$%;\".) &;#.# &;+/,#;1/#$+\")(\"'#&'#0B*%;\".) &;#.# &;+/,#;1/#$+\")(\"'#&'#&/9$2%\"\"6%7&/*$8):,)#'%!)()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#"), peg$decode("%2-\"\"6-7./:#;1/1$;$/($8#:/#! )(#'#(\"'#&'#"), peg$decode("%2#\"\"6#7$/v#;1/m$$%;%/,#;1/#$+\")(\"'#&'#06*%;%/,#;1/#$+\")(\"'#&'#&/7$2%\"\"6%7&/($8$:0$!!)($'#(#'#(\"'#&'#"), peg$decode("%21\"\"6172/\xB1#23\"\"6374.\" &\"/\x9D$;1/\x94$;0/\x8B$%;1/J#25\"\"6576/;$;./2$27\"\"6778/#$+$)($'#(#'#(\"'#&'#.\" &\"/L$%;1/,#;-/#$+\")(\"'#&'#.\" &\"/+$8&:9&$$\"! )(&'#(%'#($'#(#'#(\"'#&'#"), peg$decode("%%$4:\"\"5!7;/,#0)*4:\"\"5!7;&&&#/\"!&,)/N#;1/E$;0/<$;1/3$;(/*$8%:<%#$\" )(%'#($'#(#'#(\"'#&'#"), peg$decode("%2=\"\"6=7>/}#;1/t$;0/k$;1/b$2#\"\"6#7$/S$;1/J$;)/A$;1/8$2%\"\"6%7&/)$8):?)\"&\")()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#"), peg$decode("%2#\"\"6#7$/\x8E#;1/\x85$$%;\".) &;).# &;+/,#;1/#$+\")(\"'#&'#0B*%;\".) &;).# &;+/,#;1/#$+\")(\"'#&'#&/7$2%\"\"6%7&/($8$:@$!!)($'#(#'#(\"'#&'#"), peg$decode("%2(\"\"6(7)/|#%$4A\"\"5!7B/,#0)*4A\"\"5!7B&&&#/\"!&,)/S$;1/J$;0.\" &\"/<$;1/3$;*/*$8&:C&#$\" )(&'#(%'#($'#(#'#(\"'#&'#"), peg$decode("%2#\"\"6#7$/v#;1/m$$%;+/,#;1/#$+\")(\"'#&'#06*%;+/,#;1/#$+\")(\"'#&'#&/7$2%\"\"6%7&/($8$:D$!!)($'#(#'#(\"'#&'#"), peg$decode("%2(\"\"6(7)/S#;0/J$%;1/,#;-/#$+\")(\"'#&'#.\" &\"/)$8#:E#\"! )(#'#(\"'#&'#"), peg$decode("%%2#\"\"6#7$/;#;-/2$2%\"\"6%7&/#$+#)(#'#(\"'#&'#/\"!&,).R &%%2#\"\"6#7$/;#;1/2$2%\"\"6%7&/#$+#)(#'#(\"'#&'#/\"!&,)"), peg$decode("%%%;//e#$%;1/2#;/.# &;,/#$+\")(\"'#&'#0<*%;1/2#;/.# &;,/#$+\")(\"'#&'#&/#$+\")(\"'#&'#/\"!&,)/' 8!:F!! )"), peg$decode("%;0/b#%;1/D#2G\"\"6G7H/5$;1/,$;./#$+$)($'#(#'#(\"'#&'#.\" &\"/)$8\":I\"\"! )(\"'#&'#"), peg$decode("%$4J\"\"5!7K/,#0)*4J\"\"5!7K&&&#/\"!&,)"), peg$decode("%$4A\"\"5!7B/,#0)*4A\"\"5!7B&&&#/\"!&,)"), peg$decode("<$4M\"\"5!7N0)*4M\"\"5!7N&=.\" 7L")],
        peg$currPos = 0,
        peg$savedPos = 0,
        peg$posDetailsCache = [{ line: 1, column: 1, seenCR: false }],
        peg$maxFailPos = 0,
        peg$maxFailExpected = [],
        peg$silentFails = 0,
        peg$result;

    if ("startRule" in options) {
      if (!(options.startRule in peg$startRuleIndices)) {
        throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
      }

      peg$startRuleIndex = peg$startRuleIndices[options.startRule];
    }

    function text() {
      return input.substring(peg$savedPos, peg$currPos);
    }

    function location() {
      return peg$computeLocation(peg$savedPos, peg$currPos);
    }

    function expected(description) {
      throw peg$buildException(null, [{ type: "other", description: description }], input.substring(peg$savedPos, peg$currPos), peg$computeLocation(peg$savedPos, peg$currPos));
    }

    function error(message) {
      throw peg$buildException(message, null, input.substring(peg$savedPos, peg$currPos), peg$computeLocation(peg$savedPos, peg$currPos));
    }

    function peg$computePosDetails(pos) {
      var details = peg$posDetailsCache[pos],
          p,
          ch;

      if (details) {
        return details;
      } else {
        p = pos - 1;
        while (!peg$posDetailsCache[p]) {
          p--;
        }

        details = peg$posDetailsCache[p];
        details = {
          line: details.line,
          column: details.column,
          seenCR: details.seenCR
        };

        while (p < pos) {
          ch = input.charAt(p);
          if (ch === "\n") {
            if (!details.seenCR) {
              details.line++;
            }
            details.column = 1;
            details.seenCR = false;
          } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
            details.line++;
            details.column = 1;
            details.seenCR = true;
          } else {
            details.column++;
            details.seenCR = false;
          }

          p++;
        }

        peg$posDetailsCache[pos] = details;
        return details;
      }
    }

    function peg$computeLocation(startPos, endPos) {
      var startPosDetails = peg$computePosDetails(startPos),
          endPosDetails = peg$computePosDetails(endPos);

      return {
        start: {
          offset: startPos,
          line: startPosDetails.line,
          column: startPosDetails.column
        },
        end: {
          offset: endPos,
          line: endPosDetails.line,
          column: endPosDetails.column
        }
      };
    }

    function peg$fail(expected) {
      if (peg$currPos < peg$maxFailPos) {
        return;
      }

      if (peg$currPos > peg$maxFailPos) {
        peg$maxFailPos = peg$currPos;
        peg$maxFailExpected = [];
      }

      peg$maxFailExpected.push(expected);
    }

    function peg$buildException(message, expected, found, location) {
      function cleanupExpected(expected) {
        var i = 1;

        expected.sort(function (a, b) {
          if (a.description < b.description) {
            return -1;
          } else if (a.description > b.description) {
            return 1;
          } else {
            return 0;
          }
        });

        while (i < expected.length) {
          if (expected[i - 1] === expected[i]) {
            expected.splice(i, 1);
          } else {
            i++;
          }
        }
      }

      function buildMessage(expected, found) {
        function stringEscape(s) {
          function hex(ch) {
            return ch.charCodeAt(0).toString(16).toUpperCase();
          }

          return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\x08/g, '\\b').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\f/g, '\\f').replace(/\r/g, '\\r').replace(/[\x00-\x07\x0B\x0E\x0F]/g, function (ch) {
            return '\\x0' + hex(ch);
          }).replace(/[\x10-\x1F\x80-\xFF]/g, function (ch) {
            return '\\x' + hex(ch);
          }).replace(/[\u0100-\u0FFF]/g, function (ch) {
            return "\\u0" + hex(ch);
          }).replace(/[\u1000-\uFFFF]/g, function (ch) {
            return "\\u" + hex(ch);
          });
        }

        var expectedDescs = new Array(expected.length),
            expectedDesc,
            foundDesc,
            i;

        for (i = 0; i < expected.length; i++) {
          expectedDescs[i] = expected[i].description;
        }

        expectedDesc = expected.length > 1 ? expectedDescs.slice(0, -1).join(", ") + " or " + expectedDescs[expected.length - 1] : expectedDescs[0];

        foundDesc = found ? "\"" + stringEscape(found) + "\"" : "end of input";

        return "Expected " + expectedDesc + " but " + foundDesc + " found.";
      }

      if (expected !== null) {
        cleanupExpected(expected);
      }

      return new peg$SyntaxError(message !== null ? message : buildMessage(expected, found), expected, found, location);
    }

    function peg$decode(s) {
      var bc = new Array(s.length),
          i;

      for (i = 0; i < s.length; i++) {
        bc[i] = s.charCodeAt(i) - 32;
      }

      return bc;
    }

    function peg$parseRule(index) {
      var bc = peg$bytecode[index],
          ip = 0,
          ips = [],
          end = bc.length,
          ends = [],
          stack = [],
          params,
          i;

      while (true) {
        while (ip < end) {
          switch (bc[ip]) {
            case 0:
              stack.push(peg$consts[bc[ip + 1]]);
              ip += 2;
              break;

            case 1:
              stack.push(void 0);
              ip++;
              break;

            case 2:
              stack.push(null);
              ip++;
              break;

            case 3:
              stack.push(peg$FAILED);
              ip++;
              break;

            case 4:
              stack.push([]);
              ip++;
              break;

            case 5:
              stack.push(peg$currPos);
              ip++;
              break;

            case 6:
              stack.pop();
              ip++;
              break;

            case 7:
              peg$currPos = stack.pop();
              ip++;
              break;

            case 8:
              stack.length -= bc[ip + 1];
              ip += 2;
              break;

            case 9:
              stack.splice(-2, 1);
              ip++;
              break;

            case 10:
              stack[stack.length - 2].push(stack.pop());
              ip++;
              break;

            case 11:
              stack.push(stack.splice(stack.length - bc[ip + 1], bc[ip + 1]));
              ip += 2;
              break;

            case 12:
              stack.push(input.substring(stack.pop(), peg$currPos));
              ip++;
              break;

            case 13:
              ends.push(end);
              ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);

              if (stack[stack.length - 1]) {
                end = ip + 3 + bc[ip + 1];
                ip += 3;
              } else {
                end = ip + 3 + bc[ip + 1] + bc[ip + 2];
                ip += 3 + bc[ip + 1];
              }

              break;

            case 14:
              ends.push(end);
              ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);

              if (stack[stack.length - 1] === peg$FAILED) {
                end = ip + 3 + bc[ip + 1];
                ip += 3;
              } else {
                end = ip + 3 + bc[ip + 1] + bc[ip + 2];
                ip += 3 + bc[ip + 1];
              }

              break;

            case 15:
              ends.push(end);
              ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);

              if (stack[stack.length - 1] !== peg$FAILED) {
                end = ip + 3 + bc[ip + 1];
                ip += 3;
              } else {
                end = ip + 3 + bc[ip + 1] + bc[ip + 2];
                ip += 3 + bc[ip + 1];
              }

              break;

            case 16:
              if (stack[stack.length - 1] !== peg$FAILED) {
                ends.push(end);
                ips.push(ip);

                end = ip + 2 + bc[ip + 1];
                ip += 2;
              } else {
                ip += 2 + bc[ip + 1];
              }

              break;

            case 17:
              ends.push(end);
              ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);

              if (input.length > peg$currPos) {
                end = ip + 3 + bc[ip + 1];
                ip += 3;
              } else {
                end = ip + 3 + bc[ip + 1] + bc[ip + 2];
                ip += 3 + bc[ip + 1];
              }

              break;

            case 18:
              ends.push(end);
              ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);

              if (input.substr(peg$currPos, peg$consts[bc[ip + 1]].length) === peg$consts[bc[ip + 1]]) {
                end = ip + 4 + bc[ip + 2];
                ip += 4;
              } else {
                end = ip + 4 + bc[ip + 2] + bc[ip + 3];
                ip += 4 + bc[ip + 2];
              }

              break;

            case 19:
              ends.push(end);
              ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);

              if (input.substr(peg$currPos, peg$consts[bc[ip + 1]].length).toLowerCase() === peg$consts[bc[ip + 1]]) {
                end = ip + 4 + bc[ip + 2];
                ip += 4;
              } else {
                end = ip + 4 + bc[ip + 2] + bc[ip + 3];
                ip += 4 + bc[ip + 2];
              }

              break;

            case 20:
              ends.push(end);
              ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);

              if (peg$consts[bc[ip + 1]].test(input.charAt(peg$currPos))) {
                end = ip + 4 + bc[ip + 2];
                ip += 4;
              } else {
                end = ip + 4 + bc[ip + 2] + bc[ip + 3];
                ip += 4 + bc[ip + 2];
              }

              break;

            case 21:
              stack.push(input.substr(peg$currPos, bc[ip + 1]));
              peg$currPos += bc[ip + 1];
              ip += 2;
              break;

            case 22:
              stack.push(peg$consts[bc[ip + 1]]);
              peg$currPos += peg$consts[bc[ip + 1]].length;
              ip += 2;
              break;

            case 23:
              stack.push(peg$FAILED);
              if (peg$silentFails === 0) {
                peg$fail(peg$consts[bc[ip + 1]]);
              }
              ip += 2;
              break;

            case 24:
              peg$savedPos = stack[stack.length - 1 - bc[ip + 1]];
              ip += 2;
              break;

            case 25:
              peg$savedPos = peg$currPos;
              ip++;
              break;

            case 26:
              params = bc.slice(ip + 4, ip + 4 + bc[ip + 3]);
              for (i = 0; i < bc[ip + 3]; i++) {
                params[i] = stack[stack.length - 1 - params[i]];
              }

              stack.splice(stack.length - bc[ip + 2], bc[ip + 2], peg$consts[bc[ip + 1]].apply(null, params));

              ip += 4 + bc[ip + 3];
              break;

            case 27:
              stack.push(peg$parseRule(bc[ip + 1]));
              ip += 2;
              break;

            case 28:
              peg$silentFails++;
              ip++;
              break;

            case 29:
              peg$silentFails--;
              ip++;
              break;

            default:
              throw new Error("Invalid opcode: " + bc[ip] + ".");
          }
        }

        if (ends.length > 0) {
          end = ends.pop();
          ip = ips.pop();
        } else {
          break;
        }
      }

      return stack[0];
    }

    var groupItems = function groupItems(items, keyFunction) {
      var valueFunction = arguments.length <= 2 || arguments[2] === undefined ? function (i) {
        return i;
      } : arguments[2];
      return items.reduce(function (groups, item) {
        var key = keyFunction(item);
        var value = valueFunction(item);
        var groupValue;

        if (groups.hasOwnProperty(key) === true) {
          groupValue = groups[key];
          if (Array.isArray(groupValue) === true) {
            groupValue.push(value);
          } else {
            groupValue = [groupValue, value];
          }
        } else {
          groupValue = value;
        }

        groups[key] = groupValue;
        return groups;
      }, {});
    };

    var group = function group(items, keyFunction) {
      var valueFunction = arguments.length <= 2 || arguments[2] === undefined ? function (i) {
        return i;
      } : arguments[2];
      return items.reduce(function (groups, item) {
        var key = keyFunction(item);
        var value = valueFunction(item);

        if (groups.hasOwnProperty(key) === false) {
          groups[key] = [];
        }

        groups[key].push(value);
        return groups;
      }, {});
    };

    peg$result = peg$parseRule(peg$startRuleIndex);

    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
      return peg$result;
    } else {
      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
        peg$fail({ type: "end", description: "end of input" });
      }

      throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
    }
  }

  return {
    SyntaxError: peg$SyntaxError,
    parse: peg$parse
  };
}();
