(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
module.exports = "/*\r\n Copyright (c) 2013 Gildas Lormeau. All rights reserved.\r\n\r\n Redistribution and use in source and binary forms, with or without\r\n modification, are permitted provided that the following conditions are met:\r\n\r\n 1. Redistributions of source code must retain the above copyright notice,\r\n this list of conditions and the following disclaimer.\r\n\r\n 2. Redistributions in binary form must reproduce the above copyright\r\n notice, this list of conditions and the following disclaimer in\r\n the documentation and/or other materials provided with the distribution.\r\n\r\n 3. The names of the authors may not be used to endorse or promote products\r\n derived from this software without specific prior written permission.\r\n\r\n THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,\r\n INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\r\n FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,\r\n INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,\r\n INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\r\n LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\r\n OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\r\n LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\r\n NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\r\n EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\n/*\r\n * This program is based on JZlib 1.0.2 ymnk, JCraft,Inc.\r\n * JZlib is based on zlib-1.1.3, so all credit should go authors\r\n * Jean-loup Gailly(jloup@gzip.org) and Mark Adler(madler@alumni.caltech.edu)\r\n * and contributors of zlib.\r\n */\r\n\r\n(function(global) {\r\n    \"use strict\";\r\n\r\n    // Global\r\n\r\n    var MAX_BITS = 15;\r\n    var D_CODES = 30;\r\n    var BL_CODES = 19;\r\n\r\n    var LENGTH_CODES = 29;\r\n    var LITERALS = 256;\r\n    var L_CODES = (LITERALS + 1 + LENGTH_CODES);\r\n    var HEAP_SIZE = (2 * L_CODES + 1);\r\n\r\n    var END_BLOCK = 256;\r\n\r\n    // Bit length codes must not exceed MAX_BL_BITS bits\r\n    var MAX_BL_BITS = 7;\r\n\r\n    // repeat previous bit length 3-6 times (2 bits of repeat count)\r\n    var REP_3_6 = 16;\r\n\r\n    // repeat a zero length 3-10 times (3 bits of repeat count)\r\n    var REPZ_3_10 = 17;\r\n\r\n    // repeat a zero length 11-138 times (7 bits of repeat count)\r\n    var REPZ_11_138 = 18;\r\n\r\n    // The lengths of the bit length codes are sent in order of decreasing\r\n    // probability, to avoid transmitting the lengths for unused bit\r\n    // length codes.\r\n\r\n    var Buf_size = 8 * 2;\r\n\r\n    // JZlib version : \"1.0.2\"\r\n    var Z_DEFAULT_COMPRESSION = -1;\r\n\r\n    // compression strategy\r\n    var Z_FILTERED = 1;\r\n    var Z_HUFFMAN_ONLY = 2;\r\n    var Z_DEFAULT_STRATEGY = 0;\r\n\r\n    var Z_NO_FLUSH = 0;\r\n    var Z_PARTIAL_FLUSH = 1;\r\n    var Z_FULL_FLUSH = 3;\r\n    var Z_FINISH = 4;\r\n\r\n    var Z_OK = 0;\r\n    var Z_STREAM_END = 1;\r\n    var Z_NEED_DICT = 2;\r\n    var Z_STREAM_ERROR = -2;\r\n    var Z_DATA_ERROR = -3;\r\n    var Z_BUF_ERROR = -5;\r\n\r\n    // Tree\r\n\r\n    // see definition of array dist_code below\r\n    var _dist_code = [ 0, 1, 2, 3, 4, 4, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\r\n            10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\r\n            12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\r\n            13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\r\n            14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\r\n            14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\r\n            15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 16, 17, 18, 18, 19, 19,\r\n            20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\r\n            24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,\r\n            26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,\r\n            27, 27, 27, 27, 27, 27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,\r\n            28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 29,\r\n            29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,\r\n            29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29 ];\r\n\r\n    function Tree() {\r\n        var that = this;\r\n\r\n        // dyn_tree; // the dynamic tree\r\n        // max_code; // largest code with non zero frequency\r\n        // stat_desc; // the corresponding static tree\r\n\r\n        // Compute the optimal bit lengths for a tree and update the total bit\r\n        // length\r\n        // for the current block.\r\n        // IN assertion: the fields freq and dad are set, heap[heap_max] and\r\n        // above are the tree nodes sorted by increasing frequency.\r\n        // OUT assertions: the field len is set to the optimal bit length, the\r\n        // array bl_count contains the frequencies for each bit length.\r\n        // The length opt_len is updated; static_len is also updated if stree is\r\n        // not null.\r\n        function gen_bitlen(s) {\r\n            var tree = that.dyn_tree;\r\n            var stree = that.stat_desc.static_tree;\r\n            var extra = that.stat_desc.extra_bits;\r\n            var base = that.stat_desc.extra_base;\r\n            var max_length = that.stat_desc.max_length;\r\n            var h; // heap index\r\n            var n, m; // iterate over the tree elements\r\n            var bits; // bit length\r\n            var xbits; // extra bits\r\n            var f; // frequency\r\n            var overflow = 0; // number of elements with bit length too large\r\n\r\n            for (bits = 0; bits <= MAX_BITS; bits++)\r\n                s.bl_count[bits] = 0;\r\n\r\n            // In a first pass, compute the optimal bit lengths (which may\r\n            // overflow in the case of the bit length tree).\r\n            tree[s.heap[s.heap_max] * 2 + 1] = 0; // root of the heap\r\n\r\n            for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {\r\n                n = s.heap[h];\r\n                bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;\r\n                if (bits > max_length) {\r\n                    bits = max_length;\r\n                    overflow++;\r\n                }\r\n                tree[n * 2 + 1] = bits;\r\n                // We overwrite tree[n*2+1] which is no longer needed\r\n\r\n                if (n > that.max_code)\r\n                    continue; // not a leaf node\r\n\r\n                s.bl_count[bits]++;\r\n                xbits = 0;\r\n                if (n >= base)\r\n                    xbits = extra[n - base];\r\n                f = tree[n * 2];\r\n                s.opt_len += f * (bits + xbits);\r\n                if (stree)\r\n                    s.static_len += f * (stree[n * 2 + 1] + xbits);\r\n            }\r\n            if (overflow === 0)\r\n                return;\r\n\r\n            // This happens for example on obj2 and pic of the Calgary corpus\r\n            // Find the first bit length which could increase:\r\n            do {\r\n                bits = max_length - 1;\r\n                while (s.bl_count[bits] === 0)\r\n                    bits--;\r\n                s.bl_count[bits]--; // move one leaf down the tree\r\n                s.bl_count[bits + 1] += 2; // move one overflow item as its brother\r\n                s.bl_count[max_length]--;\r\n                // The brother of the overflow item also moves one step up,\r\n                // but this does not affect bl_count[max_length]\r\n                overflow -= 2;\r\n            } while (overflow > 0);\r\n\r\n            for (bits = max_length; bits !== 0; bits--) {\r\n                n = s.bl_count[bits];\r\n                while (n !== 0) {\r\n                    m = s.heap[--h];\r\n                    if (m > that.max_code)\r\n                        continue;\r\n                    if (tree[m * 2 + 1] != bits) {\r\n                        s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];\r\n                        tree[m * 2 + 1] = bits;\r\n                    }\r\n                    n--;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Reverse the first len bits of a code, using straightforward code (a\r\n        // faster\r\n        // method would use a table)\r\n        // IN assertion: 1 <= len <= 15\r\n        function bi_reverse(code, // the value to invert\r\n        len // its bit length\r\n        ) {\r\n            var res = 0;\r\n            do {\r\n                res |= code & 1;\r\n                code >>>= 1;\r\n                res <<= 1;\r\n            } while (--len > 0);\r\n            return res >>> 1;\r\n        }\r\n\r\n        // Generate the codes for a given tree and bit counts (which need not be\r\n        // optimal).\r\n        // IN assertion: the array bl_count contains the bit length statistics for\r\n        // the given tree and the field len is set for all tree elements.\r\n        // OUT assertion: the field code is set for all tree elements of non\r\n        // zero code length.\r\n        function gen_codes(tree, // the tree to decorate\r\n        max_code, // largest code with non zero frequency\r\n        bl_count // number of codes at each bit length\r\n        ) {\r\n            var next_code = []; // next code value for each\r\n            // bit length\r\n            var code = 0; // running code value\r\n            var bits; // bit index\r\n            var n; // code index\r\n            var len;\r\n\r\n            // The distribution counts are first used to generate the code values\r\n            // without bit reversal.\r\n            for (bits = 1; bits <= MAX_BITS; bits++) {\r\n                next_code[bits] = code = ((code + bl_count[bits - 1]) << 1);\r\n            }\r\n\r\n            // Check that the bit counts in bl_count are consistent. The last code\r\n            // must be all ones.\r\n            // Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,\r\n            // \"inconsistent bit counts\");\r\n            // Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\r\n\r\n            for (n = 0; n <= max_code; n++) {\r\n                len = tree[n * 2 + 1];\r\n                if (len === 0)\r\n                    continue;\r\n                // Now reverse the bits\r\n                tree[n * 2] = bi_reverse(next_code[len]++, len);\r\n            }\r\n        }\r\n\r\n        // Construct one Huffman tree and assigns the code bit strings and lengths.\r\n        // Update the total bit length for the current block.\r\n        // IN assertion: the field freq is set for all tree elements.\r\n        // OUT assertions: the fields len and code are set to the optimal bit length\r\n        // and corresponding code. The length opt_len is updated; static_len is\r\n        // also updated if stree is not null. The field max_code is set.\r\n        that.build_tree = function(s) {\r\n            var tree = that.dyn_tree;\r\n            var stree = that.stat_desc.static_tree;\r\n            var elems = that.stat_desc.elems;\r\n            var n, m; // iterate over heap elements\r\n            var max_code = -1; // largest code with non zero frequency\r\n            var node; // new node being created\r\n\r\n            // Construct the initial heap, with least frequent element in\r\n            // heap[1]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\r\n            // heap[0] is not used.\r\n            s.heap_len = 0;\r\n            s.heap_max = HEAP_SIZE;\r\n\r\n            for (n = 0; n < elems; n++) {\r\n                if (tree[n * 2] !== 0) {\r\n                    s.heap[++s.heap_len] = max_code = n;\r\n                    s.depth[n] = 0;\r\n                } else {\r\n                    tree[n * 2 + 1] = 0;\r\n                }\r\n            }\r\n\r\n            // The pkzip format requires that at least one distance code exists,\r\n            // and that at least one bit should be sent even if there is only one\r\n            // possible code. So to avoid special checks later on we force at least\r\n            // two codes of non zero frequency.\r\n            while (s.heap_len < 2) {\r\n                node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;\r\n                tree[node * 2] = 1;\r\n                s.depth[node] = 0;\r\n                s.opt_len--;\r\n                if (stree)\r\n                    s.static_len -= stree[node * 2 + 1];\r\n                // node is 0 or 1 so it does not have extra bits\r\n            }\r\n            that.max_code = max_code;\r\n\r\n            // The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\r\n            // establish sub-heaps of increasing lengths:\r\n\r\n            for (n = Math.floor(s.heap_len / 2); n >= 1; n--)\r\n                s.pqdownheap(tree, n);\r\n\r\n            // Construct the Huffman tree by repeatedly combining the least two\r\n            // frequent nodes.\r\n\r\n            node = elems; // next internal node of the tree\r\n            do {\r\n                // n = node of least frequency\r\n                n = s.heap[1];\r\n                s.heap[1] = s.heap[s.heap_len--];\r\n                s.pqdownheap(tree, 1);\r\n                m = s.heap[1]; // m = node of next least frequency\r\n\r\n                s.heap[--s.heap_max] = n; // keep the nodes sorted by frequency\r\n                s.heap[--s.heap_max] = m;\r\n\r\n                // Create a new node father of n and m\r\n                tree[node * 2] = (tree[n * 2] + tree[m * 2]);\r\n                s.depth[node] = Math.max(s.depth[n], s.depth[m]) + 1;\r\n                tree[n * 2 + 1] = tree[m * 2 + 1] = node;\r\n\r\n                // and insert the new node in the heap\r\n                s.heap[1] = node++;\r\n                s.pqdownheap(tree, 1);\r\n            } while (s.heap_len >= 2);\r\n\r\n            s.heap[--s.heap_max] = s.heap[1];\r\n\r\n            // At this point, the fields freq and dad are set. We can now\r\n            // generate the bit lengths.\r\n\r\n            gen_bitlen(s);\r\n\r\n            // The field len is now set, we can generate the bit codes\r\n            gen_codes(tree, that.max_code, s.bl_count);\r\n        };\r\n\r\n    }\r\n\r\n    Tree._length_code = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16,\r\n            16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20,\r\n            20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\r\n            22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\r\n            24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,\r\n            25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,\r\n            26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 28 ];\r\n\r\n    Tree.base_length = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16, 20, 24, 28, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 0 ];\r\n\r\n    Tree.base_dist = [ 0, 1, 2, 3, 4, 6, 8, 12, 16, 24, 32, 48, 64, 96, 128, 192, 256, 384, 512, 768, 1024, 1536, 2048, 3072, 4096, 6144, 8192, 12288, 16384,\r\n            24576 ];\r\n\r\n    // Mapping from a distance to a distance code. dist is the distance - 1 and\r\n    // must not have side effects. _dist_code[256] and _dist_code[257] are never\r\n    // used.\r\n    Tree.d_code = function(dist) {\r\n        return ((dist) < 256 ? _dist_code[dist] : _dist_code[256 + ((dist) >>> 7)]);\r\n    };\r\n\r\n    // extra bits for each length code\r\n    Tree.extra_lbits = [ 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0 ];\r\n\r\n    // extra bits for each distance code\r\n    Tree.extra_dbits = [ 0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13 ];\r\n\r\n    // extra bits for each bit length code\r\n    Tree.extra_blbits = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7 ];\r\n\r\n    Tree.bl_order = [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];\r\n\r\n    // StaticTree\r\n\r\n    function StaticTree(static_tree, extra_bits, extra_base, elems, max_length) {\r\n        var that = this;\r\n        that.static_tree = static_tree;\r\n        that.extra_bits = extra_bits;\r\n        that.extra_base = extra_base;\r\n        that.elems = elems;\r\n        that.max_length = max_length;\r\n    }\r\n\r\n    StaticTree.static_ltree = [ 12, 8, 140, 8, 76, 8, 204, 8, 44, 8, 172, 8, 108, 8, 236, 8, 28, 8, 156, 8, 92, 8, 220, 8, 60, 8, 188, 8, 124, 8, 252, 8, 2, 8,\r\n            130, 8, 66, 8, 194, 8, 34, 8, 162, 8, 98, 8, 226, 8, 18, 8, 146, 8, 82, 8, 210, 8, 50, 8, 178, 8, 114, 8, 242, 8, 10, 8, 138, 8, 74, 8, 202, 8, 42,\r\n            8, 170, 8, 106, 8, 234, 8, 26, 8, 154, 8, 90, 8, 218, 8, 58, 8, 186, 8, 122, 8, 250, 8, 6, 8, 134, 8, 70, 8, 198, 8, 38, 8, 166, 8, 102, 8, 230, 8,\r\n            22, 8, 150, 8, 86, 8, 214, 8, 54, 8, 182, 8, 118, 8, 246, 8, 14, 8, 142, 8, 78, 8, 206, 8, 46, 8, 174, 8, 110, 8, 238, 8, 30, 8, 158, 8, 94, 8,\r\n            222, 8, 62, 8, 190, 8, 126, 8, 254, 8, 1, 8, 129, 8, 65, 8, 193, 8, 33, 8, 161, 8, 97, 8, 225, 8, 17, 8, 145, 8, 81, 8, 209, 8, 49, 8, 177, 8, 113,\r\n            8, 241, 8, 9, 8, 137, 8, 73, 8, 201, 8, 41, 8, 169, 8, 105, 8, 233, 8, 25, 8, 153, 8, 89, 8, 217, 8, 57, 8, 185, 8, 121, 8, 249, 8, 5, 8, 133, 8,\r\n            69, 8, 197, 8, 37, 8, 165, 8, 101, 8, 229, 8, 21, 8, 149, 8, 85, 8, 213, 8, 53, 8, 181, 8, 117, 8, 245, 8, 13, 8, 141, 8, 77, 8, 205, 8, 45, 8,\r\n            173, 8, 109, 8, 237, 8, 29, 8, 157, 8, 93, 8, 221, 8, 61, 8, 189, 8, 125, 8, 253, 8, 19, 9, 275, 9, 147, 9, 403, 9, 83, 9, 339, 9, 211, 9, 467, 9,\r\n            51, 9, 307, 9, 179, 9, 435, 9, 115, 9, 371, 9, 243, 9, 499, 9, 11, 9, 267, 9, 139, 9, 395, 9, 75, 9, 331, 9, 203, 9, 459, 9, 43, 9, 299, 9, 171, 9,\r\n            427, 9, 107, 9, 363, 9, 235, 9, 491, 9, 27, 9, 283, 9, 155, 9, 411, 9, 91, 9, 347, 9, 219, 9, 475, 9, 59, 9, 315, 9, 187, 9, 443, 9, 123, 9, 379,\r\n            9, 251, 9, 507, 9, 7, 9, 263, 9, 135, 9, 391, 9, 71, 9, 327, 9, 199, 9, 455, 9, 39, 9, 295, 9, 167, 9, 423, 9, 103, 9, 359, 9, 231, 9, 487, 9, 23,\r\n            9, 279, 9, 151, 9, 407, 9, 87, 9, 343, 9, 215, 9, 471, 9, 55, 9, 311, 9, 183, 9, 439, 9, 119, 9, 375, 9, 247, 9, 503, 9, 15, 9, 271, 9, 143, 9,\r\n            399, 9, 79, 9, 335, 9, 207, 9, 463, 9, 47, 9, 303, 9, 175, 9, 431, 9, 111, 9, 367, 9, 239, 9, 495, 9, 31, 9, 287, 9, 159, 9, 415, 9, 95, 9, 351, 9,\r\n            223, 9, 479, 9, 63, 9, 319, 9, 191, 9, 447, 9, 127, 9, 383, 9, 255, 9, 511, 9, 0, 7, 64, 7, 32, 7, 96, 7, 16, 7, 80, 7, 48, 7, 112, 7, 8, 7, 72, 7,\r\n            40, 7, 104, 7, 24, 7, 88, 7, 56, 7, 120, 7, 4, 7, 68, 7, 36, 7, 100, 7, 20, 7, 84, 7, 52, 7, 116, 7, 3, 8, 131, 8, 67, 8, 195, 8, 35, 8, 163, 8,\r\n            99, 8, 227, 8 ];\r\n\r\n    StaticTree.static_dtree = [ 0, 5, 16, 5, 8, 5, 24, 5, 4, 5, 20, 5, 12, 5, 28, 5, 2, 5, 18, 5, 10, 5, 26, 5, 6, 5, 22, 5, 14, 5, 30, 5, 1, 5, 17, 5, 9, 5,\r\n            25, 5, 5, 5, 21, 5, 13, 5, 29, 5, 3, 5, 19, 5, 11, 5, 27, 5, 7, 5, 23, 5 ];\r\n\r\n    StaticTree.static_l_desc = new StaticTree(StaticTree.static_ltree, Tree.extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);\r\n\r\n    StaticTree.static_d_desc = new StaticTree(StaticTree.static_dtree, Tree.extra_dbits, 0, D_CODES, MAX_BITS);\r\n\r\n    StaticTree.static_bl_desc = new StaticTree(null, Tree.extra_blbits, 0, BL_CODES, MAX_BL_BITS);\r\n\r\n    // Deflate\r\n\r\n    var MAX_MEM_LEVEL = 9;\r\n    var DEF_MEM_LEVEL = 8;\r\n\r\n    function Config(good_length, max_lazy, nice_length, max_chain, func) {\r\n        var that = this;\r\n        that.good_length = good_length;\r\n        that.max_lazy = max_lazy;\r\n        that.nice_length = nice_length;\r\n        that.max_chain = max_chain;\r\n        that.func = func;\r\n    }\r\n\r\n    var STORED = 0;\r\n    var FAST = 1;\r\n    var SLOW = 2;\r\n    var config_table = [ new Config(0, 0, 0, 0, STORED), new Config(4, 4, 8, 4, FAST), new Config(4, 5, 16, 8, FAST), new Config(4, 6, 32, 32, FAST),\r\n            new Config(4, 4, 16, 16, SLOW), new Config(8, 16, 32, 32, SLOW), new Config(8, 16, 128, 128, SLOW), new Config(8, 32, 128, 256, SLOW),\r\n            new Config(32, 128, 258, 1024, SLOW), new Config(32, 258, 258, 4096, SLOW) ];\r\n\r\n    var z_errmsg = [ \"need dictionary\", // Z_NEED_DICT\r\n    // 2\r\n    \"stream end\", // Z_STREAM_END 1\r\n    \"\", // Z_OK 0\r\n    \"\", // Z_ERRNO (-1)\r\n    \"stream error\", // Z_STREAM_ERROR (-2)\r\n    \"data error\", // Z_DATA_ERROR (-3)\r\n    \"\", // Z_MEM_ERROR (-4)\r\n    \"buffer error\", // Z_BUF_ERROR (-5)\r\n    \"\",// Z_VERSION_ERROR (-6)\r\n    \"\" ];\r\n\r\n    // block not completed, need more input or more output\r\n    var NeedMore = 0;\r\n\r\n    // block flush performed\r\n    var BlockDone = 1;\r\n\r\n    // finish started, need only more output at next deflate\r\n    var FinishStarted = 2;\r\n\r\n    // finish done, accept no more input or output\r\n    var FinishDone = 3;\r\n\r\n    // preset dictionary flag in zlib header\r\n    var PRESET_DICT = 0x20;\r\n\r\n    var INIT_STATE = 42;\r\n    var BUSY_STATE = 113;\r\n    var FINISH_STATE = 666;\r\n\r\n    // The deflate compression method\r\n    var Z_DEFLATED = 8;\r\n\r\n    var STORED_BLOCK = 0;\r\n    var STATIC_TREES = 1;\r\n    var DYN_TREES = 2;\r\n\r\n    var MIN_MATCH = 3;\r\n    var MAX_MATCH = 258;\r\n    var MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);\r\n\r\n    function smaller(tree, n, m, depth) {\r\n        var tn2 = tree[n * 2];\r\n        var tm2 = tree[m * 2];\r\n        return (tn2 < tm2 || (tn2 == tm2 && depth[n] <= depth[m]));\r\n    }\r\n\r\n    function Deflate() {\r\n\r\n        var that = this;\r\n        var strm; // pointer back to this zlib stream\r\n        var status; // as the name implies\r\n        // pending_buf; // output still pending\r\n        var pending_buf_size; // size of pending_buf\r\n        // pending_out; // next pending byte to output to the stream\r\n        // pending; // nb of bytes in the pending buffer\r\n        var method; // STORED (for zip only) or DEFLATED\r\n        var last_flush; // value of flush param for previous deflate call\r\n\r\n        var w_size; // LZ77 window size (32K by default)\r\n        var w_bits; // log2(w_size) (8..16)\r\n        var w_mask; // w_size - 1\r\n\r\n        var window;\r\n        // Sliding window. Input bytes are read into the second half of the window,\r\n        // and move to the first half later to keep a dictionary of at least wSize\r\n        // bytes. With this organization, matches are limited to a distance of\r\n        // wSize-MAX_MATCH bytes, but this ensures that IO is always\r\n        // performed with a length multiple of the block size. Also, it limits\r\n        // the window size to 64K, which is quite useful on MSDOS.\r\n        // To do: use the user input buffer as sliding window.\r\n\r\n        var window_size;\r\n        // Actual size of window: 2*wSize, except when the user input buffer\r\n        // is directly used as sliding window.\r\n\r\n        var prev;\r\n        // Link to older string with same hash index. To limit the size of this\r\n        // array to 64K, this link is maintained only for the last 32K strings.\r\n        // An index in this array is thus a window index modulo 32K.\r\n\r\n        var head; // Heads of the hash chains or NIL.\r\n\r\n        var ins_h; // hash index of string to be inserted\r\n        var hash_size; // number of elements in hash table\r\n        var hash_bits; // log2(hash_size)\r\n        var hash_mask; // hash_size-1\r\n\r\n        // Number of bits by which ins_h must be shifted at each input\r\n        // step. It must be such that after MIN_MATCH steps, the oldest\r\n        // byte no longer takes part in the hash key, that is:\r\n        // hash_shift * MIN_MATCH >= hash_bits\r\n        var hash_shift;\r\n\r\n        // Window position at the beginning of the current output block. Gets\r\n        // negative when the window is moved backwards.\r\n\r\n        var block_start;\r\n\r\n        var match_length; // length of best match\r\n        var prev_match; // previous match\r\n        var match_available; // set if previous match exists\r\n        var strstart; // start of string to insert\r\n        var match_start; // start of matching string\r\n        var lookahead; // number of valid bytes ahead in window\r\n\r\n        // Length of the best match at previous step. Matches not greater than this\r\n        // are discarded. This is used in the lazy match evaluation.\r\n        var prev_length;\r\n\r\n        // To speed up deflation, hash chains are never searched beyond this\r\n        // length. A higher limit improves compression ratio but degrades the speed.\r\n        var max_chain_length;\r\n\r\n        // Attempt to find a better match only when the current match is strictly\r\n        // smaller than this value. This mechanism is used only for compression\r\n        // levels >= 4.\r\n        var max_lazy_match;\r\n\r\n        // Insert new strings in the hash table only if the match length is not\r\n        // greater than this length. This saves time but degrades compression.\r\n        // max_insert_length is used only for compression levels <= 3.\r\n\r\n        var level; // compression level (1..9)\r\n        var strategy; // favor or force Huffman coding\r\n\r\n        // Use a faster search when the previous match is longer than this\r\n        var good_match;\r\n\r\n        // Stop searching when current match exceeds this\r\n        var nice_match;\r\n\r\n        var dyn_ltree; // literal and length tree\r\n        var dyn_dtree; // distance tree\r\n        var bl_tree; // Huffman tree for bit lengths\r\n\r\n        var l_desc = new Tree(); // desc for literal tree\r\n        var d_desc = new Tree(); // desc for distance tree\r\n        var bl_desc = new Tree(); // desc for bit length tree\r\n\r\n        // that.heap_len; // number of elements in the heap\r\n        // that.heap_max; // element of largest frequency\r\n        // The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.\r\n        // The same heap array is used to build all trees.\r\n\r\n        // Depth of each subtree used as tie breaker for trees of equal frequency\r\n        that.depth = [];\r\n\r\n        var l_buf; // index for literals or lengths */\r\n\r\n        // Size of match buffer for literals/lengths. There are 4 reasons for\r\n        // limiting lit_bufsize to 64K:\r\n        // - frequencies can be kept in 16 bit counters\r\n        // - if compression is not successful for the first block, all input\r\n        // data is still in the window so we can still emit a stored block even\r\n        // when input comes from standard input. (This can also be done for\r\n        // all blocks if lit_bufsize is not greater than 32K.)\r\n        // - if compression is not successful for a file smaller than 64K, we can\r\n        // even emit a stored file instead of a stored block (saving 5 bytes).\r\n        // This is applicable only for zip (not gzip or zlib).\r\n        // - creating new Huffman trees less frequently may not provide fast\r\n        // adaptation to changes in the input data statistics. (Take for\r\n        // example a binary file with poorly compressible code followed by\r\n        // a highly compressible string table.) Smaller buffer sizes give\r\n        // fast adaptation but have of course the overhead of transmitting\r\n        // trees more frequently.\r\n        // - I can't count above 4\r\n        var lit_bufsize;\r\n\r\n        var last_lit; // running index in l_buf\r\n\r\n        // Buffer for distances. To simplify the code, d_buf and l_buf have\r\n        // the same number of elements. To use different lengths, an extra flag\r\n        // array would be necessary.\r\n\r\n        var d_buf; // index of pendig_buf\r\n\r\n        // that.opt_len; // bit length of current block with optimal trees\r\n        // that.static_len; // bit length of current block with static trees\r\n        var matches; // number of string matches in current block\r\n        var last_eob_len; // bit length of EOB code for last block\r\n\r\n        // Output buffer. bits are inserted starting at the bottom (least\r\n        // significant bits).\r\n        var bi_buf;\r\n\r\n        // Number of valid bits in bi_buf. All bits above the last valid bit\r\n        // are always zero.\r\n        var bi_valid;\r\n\r\n        // number of codes at each bit length for an optimal tree\r\n        that.bl_count = [];\r\n\r\n        // heap used to build the Huffman trees\r\n        that.heap = [];\r\n\r\n        dyn_ltree = [];\r\n        dyn_dtree = [];\r\n        bl_tree = [];\r\n\r\n        function lm_init() {\r\n            var i;\r\n            window_size = 2 * w_size;\r\n\r\n            head[hash_size - 1] = 0;\r\n            for (i = 0; i < hash_size - 1; i++) {\r\n                head[i] = 0;\r\n            }\r\n\r\n            // Set the default configuration parameters:\r\n            max_lazy_match = config_table[level].max_lazy;\r\n            good_match = config_table[level].good_length;\r\n            nice_match = config_table[level].nice_length;\r\n            max_chain_length = config_table[level].max_chain;\r\n\r\n            strstart = 0;\r\n            block_start = 0;\r\n            lookahead = 0;\r\n            match_length = prev_length = MIN_MATCH - 1;\r\n            match_available = 0;\r\n            ins_h = 0;\r\n        }\r\n\r\n        function init_block() {\r\n            var i;\r\n            // Initialize the trees.\r\n            for (i = 0; i < L_CODES; i++)\r\n                dyn_ltree[i * 2] = 0;\r\n            for (i = 0; i < D_CODES; i++)\r\n                dyn_dtree[i * 2] = 0;\r\n            for (i = 0; i < BL_CODES; i++)\r\n                bl_tree[i * 2] = 0;\r\n\r\n            dyn_ltree[END_BLOCK * 2] = 1;\r\n            that.opt_len = that.static_len = 0;\r\n            last_lit = matches = 0;\r\n        }\r\n\r\n        // Initialize the tree data structures for a new zlib stream.\r\n        function tr_init() {\r\n\r\n            l_desc.dyn_tree = dyn_ltree;\r\n            l_desc.stat_desc = StaticTree.static_l_desc;\r\n\r\n            d_desc.dyn_tree = dyn_dtree;\r\n            d_desc.stat_desc = StaticTree.static_d_desc;\r\n\r\n            bl_desc.dyn_tree = bl_tree;\r\n            bl_desc.stat_desc = StaticTree.static_bl_desc;\r\n\r\n            bi_buf = 0;\r\n            bi_valid = 0;\r\n            last_eob_len = 8; // enough lookahead for inflate\r\n\r\n            // Initialize the first block of the first file:\r\n            init_block();\r\n        }\r\n\r\n        // Restore the heap property by moving down the tree starting at node k,\r\n        // exchanging a node with the smallest of its two sons if necessary,\r\n        // stopping\r\n        // when the heap property is re-established (each father smaller than its\r\n        // two sons).\r\n        that.pqdownheap = function(tree, // the tree to restore\r\n        k // node to move down\r\n        ) {\r\n            var heap = that.heap;\r\n            var v = heap[k];\r\n            var j = k << 1; // left son of k\r\n            while (j <= that.heap_len) {\r\n                // Set j to the smallest of the two sons:\r\n                if (j < that.heap_len && smaller(tree, heap[j + 1], heap[j], that.depth)) {\r\n                    j++;\r\n                }\r\n                // Exit if v is smaller than both sons\r\n                if (smaller(tree, v, heap[j], that.depth))\r\n                    break;\r\n\r\n                // Exchange v with the smallest son\r\n                heap[k] = heap[j];\r\n                k = j;\r\n                // And continue down the tree, setting j to the left son of k\r\n                j <<= 1;\r\n            }\r\n            heap[k] = v;\r\n        };\r\n\r\n        // Scan a literal or distance tree to determine the frequencies of the codes\r\n        // in the bit length tree.\r\n        function scan_tree(tree,// the tree to be scanned\r\n        max_code // and its largest code of non zero frequency\r\n        ) {\r\n            var n; // iterates over all tree elements\r\n            var prevlen = -1; // last emitted length\r\n            var curlen; // length of current code\r\n            var nextlen = tree[0 * 2 + 1]; // length of next code\r\n            var count = 0; // repeat count of the current code\r\n            var max_count = 7; // max repeat count\r\n            var min_count = 4; // min repeat count\r\n\r\n            if (nextlen === 0) {\r\n                max_count = 138;\r\n                min_count = 3;\r\n            }\r\n            tree[(max_code + 1) * 2 + 1] = 0xffff; // guard\r\n\r\n            for (n = 0; n <= max_code; n++) {\r\n                curlen = nextlen;\r\n                nextlen = tree[(n + 1) * 2 + 1];\r\n                if (++count < max_count && curlen == nextlen) {\r\n                    continue;\r\n                } else if (count < min_count) {\r\n                    bl_tree[curlen * 2] += count;\r\n                } else if (curlen !== 0) {\r\n                    if (curlen != prevlen)\r\n                        bl_tree[curlen * 2]++;\r\n                    bl_tree[REP_3_6 * 2]++;\r\n                } else if (count <= 10) {\r\n                    bl_tree[REPZ_3_10 * 2]++;\r\n                } else {\r\n                    bl_tree[REPZ_11_138 * 2]++;\r\n                }\r\n                count = 0;\r\n                prevlen = curlen;\r\n                if (nextlen === 0) {\r\n                    max_count = 138;\r\n                    min_count = 3;\r\n                } else if (curlen == nextlen) {\r\n                    max_count = 6;\r\n                    min_count = 3;\r\n                } else {\r\n                    max_count = 7;\r\n                    min_count = 4;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Construct the Huffman tree for the bit lengths and return the index in\r\n        // bl_order of the last bit length code to send.\r\n        function build_bl_tree() {\r\n            var max_blindex; // index of last bit length code of non zero freq\r\n\r\n            // Determine the bit length frequencies for literal and distance trees\r\n            scan_tree(dyn_ltree, l_desc.max_code);\r\n            scan_tree(dyn_dtree, d_desc.max_code);\r\n\r\n            // Build the bit length tree:\r\n            bl_desc.build_tree(that);\r\n            // opt_len now includes the length of the tree representations, except\r\n            // the lengths of the bit lengths codes and the 5+5+4 bits for the\r\n            // counts.\r\n\r\n            // Determine the number of bit length codes to send. The pkzip format\r\n            // requires that at least 4 bit length codes be sent. (appnote.txt says\r\n            // 3 but the actual value used is 4.)\r\n            for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {\r\n                if (bl_tree[Tree.bl_order[max_blindex] * 2 + 1] !== 0)\r\n                    break;\r\n            }\r\n            // Update opt_len to include the bit length tree and counts\r\n            that.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;\r\n\r\n            return max_blindex;\r\n        }\r\n\r\n        // Output a byte on the stream.\r\n        // IN assertion: there is enough room in pending_buf.\r\n        function put_byte(p) {\r\n            that.pending_buf[that.pending++] = p;\r\n        }\r\n\r\n        function put_short(w) {\r\n            put_byte(w & 0xff);\r\n            put_byte((w >>> 8) & 0xff);\r\n        }\r\n\r\n        function putShortMSB(b) {\r\n            put_byte((b >> 8) & 0xff);\r\n            put_byte((b & 0xff) & 0xff);\r\n        }\r\n\r\n        function send_bits(value, length) {\r\n            var val, len = length;\r\n            if (bi_valid > Buf_size - len) {\r\n                val = value;\r\n                // bi_buf |= (val << bi_valid);\r\n                bi_buf |= ((val << bi_valid) & 0xffff);\r\n                put_short(bi_buf);\r\n                bi_buf = val >>> (Buf_size - bi_valid);\r\n                bi_valid += len - Buf_size;\r\n            } else {\r\n                // bi_buf |= (value) << bi_valid;\r\n                bi_buf |= (((value) << bi_valid) & 0xffff);\r\n                bi_valid += len;\r\n            }\r\n        }\r\n\r\n        function send_code(c, tree) {\r\n            var c2 = c * 2;\r\n            send_bits(tree[c2] & 0xffff, tree[c2 + 1] & 0xffff);\r\n        }\r\n\r\n        // Send a literal or distance tree in compressed form, using the codes in\r\n        // bl_tree.\r\n        function send_tree(tree,// the tree to be sent\r\n        max_code // and its largest code of non zero frequency\r\n        ) {\r\n            var n; // iterates over all tree elements\r\n            var prevlen = -1; // last emitted length\r\n            var curlen; // length of current code\r\n            var nextlen = tree[0 * 2 + 1]; // length of next code\r\n            var count = 0; // repeat count of the current code\r\n            var max_count = 7; // max repeat count\r\n            var min_count = 4; // min repeat count\r\n\r\n            if (nextlen === 0) {\r\n                max_count = 138;\r\n                min_count = 3;\r\n            }\r\n\r\n            for (n = 0; n <= max_code; n++) {\r\n                curlen = nextlen;\r\n                nextlen = tree[(n + 1) * 2 + 1];\r\n                if (++count < max_count && curlen == nextlen) {\r\n                    continue;\r\n                } else if (count < min_count) {\r\n                    do {\r\n                        send_code(curlen, bl_tree);\r\n                    } while (--count !== 0);\r\n                } else if (curlen !== 0) {\r\n                    if (curlen != prevlen) {\r\n                        send_code(curlen, bl_tree);\r\n                        count--;\r\n                    }\r\n                    send_code(REP_3_6, bl_tree);\r\n                    send_bits(count - 3, 2);\r\n                } else if (count <= 10) {\r\n                    send_code(REPZ_3_10, bl_tree);\r\n                    send_bits(count - 3, 3);\r\n                } else {\r\n                    send_code(REPZ_11_138, bl_tree);\r\n                    send_bits(count - 11, 7);\r\n                }\r\n                count = 0;\r\n                prevlen = curlen;\r\n                if (nextlen === 0) {\r\n                    max_count = 138;\r\n                    min_count = 3;\r\n                } else if (curlen == nextlen) {\r\n                    max_count = 6;\r\n                    min_count = 3;\r\n                } else {\r\n                    max_count = 7;\r\n                    min_count = 4;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Send the header for a block using dynamic Huffman trees: the counts, the\r\n        // lengths of the bit length codes, the literal tree and the distance tree.\r\n        // IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\r\n        function send_all_trees(lcodes, dcodes, blcodes) {\r\n            var rank; // index in bl_order\r\n\r\n            send_bits(lcodes - 257, 5); // not +255 as stated in appnote.txt\r\n            send_bits(dcodes - 1, 5);\r\n            send_bits(blcodes - 4, 4); // not -3 as stated in appnote.txt\r\n            for (rank = 0; rank < blcodes; rank++) {\r\n                send_bits(bl_tree[Tree.bl_order[rank] * 2 + 1], 3);\r\n            }\r\n            send_tree(dyn_ltree, lcodes - 1); // literal tree\r\n            send_tree(dyn_dtree, dcodes - 1); // distance tree\r\n        }\r\n\r\n        // Flush the bit buffer, keeping at most 7 bits in it.\r\n        function bi_flush() {\r\n            if (bi_valid == 16) {\r\n                put_short(bi_buf);\r\n                bi_buf = 0;\r\n                bi_valid = 0;\r\n            } else if (bi_valid >= 8) {\r\n                put_byte(bi_buf & 0xff);\r\n                bi_buf >>>= 8;\r\n                bi_valid -= 8;\r\n            }\r\n        }\r\n\r\n        // Send one empty static block to give enough lookahead for inflate.\r\n        // This takes 10 bits, of which 7 may remain in the bit buffer.\r\n        // The current inflate code requires 9 bits of lookahead. If the\r\n        // last two codes for the previous block (real code plus EOB) were coded\r\n        // on 5 bits or less, inflate may have only 5+3 bits of lookahead to decode\r\n        // the last real code. In this case we send two empty static blocks instead\r\n        // of one. (There are no problems if the previous block is stored or fixed.)\r\n        // To simplify the code, we assume the worst case of last real code encoded\r\n        // on one bit only.\r\n        function _tr_align() {\r\n            send_bits(STATIC_TREES << 1, 3);\r\n            send_code(END_BLOCK, StaticTree.static_ltree);\r\n\r\n            bi_flush();\r\n\r\n            // Of the 10 bits for the empty block, we have already sent\r\n            // (10 - bi_valid) bits. The lookahead for the last real code (before\r\n            // the EOB of the previous block) was thus at least one plus the length\r\n            // of the EOB plus what we have just sent of the empty static block.\r\n            if (1 + last_eob_len + 10 - bi_valid < 9) {\r\n                send_bits(STATIC_TREES << 1, 3);\r\n                send_code(END_BLOCK, StaticTree.static_ltree);\r\n                bi_flush();\r\n            }\r\n            last_eob_len = 7;\r\n        }\r\n\r\n        // Save the match info and tally the frequency counts. Return true if\r\n        // the current block must be flushed.\r\n        function _tr_tally(dist, // distance of matched string\r\n        lc // match length-MIN_MATCH or unmatched char (if dist==0)\r\n        ) {\r\n            var out_length, in_length, dcode;\r\n            that.pending_buf[d_buf + last_lit * 2] = (dist >>> 8) & 0xff;\r\n            that.pending_buf[d_buf + last_lit * 2 + 1] = dist & 0xff;\r\n\r\n            that.pending_buf[l_buf + last_lit] = lc & 0xff;\r\n            last_lit++;\r\n\r\n            if (dist === 0) {\r\n                // lc is the unmatched char\r\n                dyn_ltree[lc * 2]++;\r\n            } else {\r\n                matches++;\r\n                // Here, lc is the match length - MIN_MATCH\r\n                dist--; // dist = match distance - 1\r\n                dyn_ltree[(Tree._length_code[lc] + LITERALS + 1) * 2]++;\r\n                dyn_dtree[Tree.d_code(dist) * 2]++;\r\n            }\r\n\r\n            if ((last_lit & 0x1fff) === 0 && level > 2) {\r\n                // Compute an upper bound for the compressed length\r\n                out_length = last_lit * 8;\r\n                in_length = strstart - block_start;\r\n                for (dcode = 0; dcode < D_CODES; dcode++) {\r\n                    out_length += dyn_dtree[dcode * 2] * (5 + Tree.extra_dbits[dcode]);\r\n                }\r\n                out_length >>>= 3;\r\n                if ((matches < Math.floor(last_lit / 2)) && out_length < Math.floor(in_length / 2))\r\n                    return true;\r\n            }\r\n\r\n            return (last_lit == lit_bufsize - 1);\r\n            // We avoid equality with lit_bufsize because of wraparound at 64K\r\n            // on 16 bit machines and because stored blocks are restricted to\r\n            // 64K-1 bytes.\r\n        }\r\n\r\n        // Send the block data compressed using the given Huffman trees\r\n        function compress_block(ltree, dtree) {\r\n            var dist; // distance of matched string\r\n            var lc; // match length or unmatched char (if dist === 0)\r\n            var lx = 0; // running index in l_buf\r\n            var code; // the code to send\r\n            var extra; // number of extra bits to send\r\n\r\n            if (last_lit !== 0) {\r\n                do {\r\n                    dist = ((that.pending_buf[d_buf + lx * 2] << 8) & 0xff00) | (that.pending_buf[d_buf + lx * 2 + 1] & 0xff);\r\n                    lc = (that.pending_buf[l_buf + lx]) & 0xff;\r\n                    lx++;\r\n\r\n                    if (dist === 0) {\r\n                        send_code(lc, ltree); // send a literal byte\r\n                    } else {\r\n                        // Here, lc is the match length - MIN_MATCH\r\n                        code = Tree._length_code[lc];\r\n\r\n                        send_code(code + LITERALS + 1, ltree); // send the length\r\n                        // code\r\n                        extra = Tree.extra_lbits[code];\r\n                        if (extra !== 0) {\r\n                            lc -= Tree.base_length[code];\r\n                            send_bits(lc, extra); // send the extra length bits\r\n                        }\r\n                        dist--; // dist is now the match distance - 1\r\n                        code = Tree.d_code(dist);\r\n\r\n                        send_code(code, dtree); // send the distance code\r\n                        extra = Tree.extra_dbits[code];\r\n                        if (extra !== 0) {\r\n                            dist -= Tree.base_dist[code];\r\n                            send_bits(dist, extra); // send the extra distance bits\r\n                        }\r\n                    } // literal or match pair ?\r\n\r\n                    // Check that the overlay between pending_buf and d_buf+l_buf is\r\n                    // ok:\r\n                } while (lx < last_lit);\r\n            }\r\n\r\n            send_code(END_BLOCK, ltree);\r\n            last_eob_len = ltree[END_BLOCK * 2 + 1];\r\n        }\r\n\r\n        // Flush the bit buffer and align the output on a byte boundary\r\n        function bi_windup() {\r\n            if (bi_valid > 8) {\r\n                put_short(bi_buf);\r\n            } else if (bi_valid > 0) {\r\n                put_byte(bi_buf & 0xff);\r\n            }\r\n            bi_buf = 0;\r\n            bi_valid = 0;\r\n        }\r\n\r\n        // Copy a stored block, storing first the length and its\r\n        // one's complement if requested.\r\n        function copy_block(buf, // the input data\r\n        len, // its length\r\n        header // true if block header must be written\r\n        ) {\r\n            bi_windup(); // align on byte boundary\r\n            last_eob_len = 8; // enough lookahead for inflate\r\n\r\n            if (header) {\r\n                put_short(len);\r\n                put_short(~len);\r\n            }\r\n\r\n            that.pending_buf.set(window.subarray(buf, buf + len), that.pending);\r\n            that.pending += len;\r\n        }\r\n\r\n        // Send a stored block\r\n        function _tr_stored_block(buf, // input block\r\n        stored_len, // length of input block\r\n        eof // true if this is the last block for a file\r\n        ) {\r\n            send_bits((STORED_BLOCK << 1) + (eof ? 1 : 0), 3); // send block type\r\n            copy_block(buf, stored_len, true); // with header\r\n        }\r\n\r\n        // Determine the best encoding for the current block: dynamic trees, static\r\n        // trees or store, and output the encoded block to the zip file.\r\n        function _tr_flush_block(buf, // input block, or NULL if too old\r\n        stored_len, // length of input block\r\n        eof // true if this is the last block for a file\r\n        ) {\r\n            var opt_lenb, static_lenb;// opt_len and static_len in bytes\r\n            var max_blindex = 0; // index of last bit length code of non zero freq\r\n\r\n            // Build the Huffman trees unless a stored block is forced\r\n            if (level > 0) {\r\n                // Construct the literal and distance trees\r\n                l_desc.build_tree(that);\r\n\r\n                d_desc.build_tree(that);\r\n\r\n                // At this point, opt_len and static_len are the total bit lengths\r\n                // of\r\n                // the compressed block data, excluding the tree representations.\r\n\r\n                // Build the bit length tree for the above two trees, and get the\r\n                // index\r\n                // in bl_order of the last bit length code to send.\r\n                max_blindex = build_bl_tree();\r\n\r\n                // Determine the best encoding. Compute first the block length in\r\n                // bytes\r\n                opt_lenb = (that.opt_len + 3 + 7) >>> 3;\r\n                static_lenb = (that.static_len + 3 + 7) >>> 3;\r\n\r\n                if (static_lenb <= opt_lenb)\r\n                    opt_lenb = static_lenb;\r\n            } else {\r\n                opt_lenb = static_lenb = stored_len + 5; // force a stored block\r\n            }\r\n\r\n            if ((stored_len + 4 <= opt_lenb) && buf != -1) {\r\n                // 4: two words for the lengths\r\n                // The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\r\n                // Otherwise we can't have processed more than WSIZE input bytes\r\n                // since\r\n                // the last block flush, because compression would have been\r\n                // successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\r\n                // transform a block into a stored block.\r\n                _tr_stored_block(buf, stored_len, eof);\r\n            } else if (static_lenb == opt_lenb) {\r\n                send_bits((STATIC_TREES << 1) + (eof ? 1 : 0), 3);\r\n                compress_block(StaticTree.static_ltree, StaticTree.static_dtree);\r\n            } else {\r\n                send_bits((DYN_TREES << 1) + (eof ? 1 : 0), 3);\r\n                send_all_trees(l_desc.max_code + 1, d_desc.max_code + 1, max_blindex + 1);\r\n                compress_block(dyn_ltree, dyn_dtree);\r\n            }\r\n\r\n            // The above check is made mod 2^32, for files larger than 512 MB\r\n            // and uLong implemented on 32 bits.\r\n\r\n            init_block();\r\n\r\n            if (eof) {\r\n                bi_windup();\r\n            }\r\n        }\r\n\r\n        function flush_block_only(eof) {\r\n            _tr_flush_block(block_start >= 0 ? block_start : -1, strstart - block_start, eof);\r\n            block_start = strstart;\r\n            strm.flush_pending();\r\n        }\r\n\r\n        // Fill the window when the lookahead becomes insufficient.\r\n        // Updates strstart and lookahead.\r\n        //\r\n        // IN assertion: lookahead < MIN_LOOKAHEAD\r\n        // OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\r\n        // At least one byte has been read, or avail_in === 0; reads are\r\n        // performed for at least two bytes (required for the zip translate_eol\r\n        // option -- not supported here).\r\n        function fill_window() {\r\n            var n, m;\r\n            var p;\r\n            var more; // Amount of free space at the end of the window.\r\n\r\n            do {\r\n                more = (window_size - lookahead - strstart);\r\n\r\n                // Deal with !@#$% 64K limit:\r\n                if (more === 0 && strstart === 0 && lookahead === 0) {\r\n                    more = w_size;\r\n                } else if (more == -1) {\r\n                    // Very unlikely, but possible on 16 bit machine if strstart ==\r\n                    // 0\r\n                    // and lookahead == 1 (input done one byte at time)\r\n                    more--;\r\n\r\n                    // If the window is almost full and there is insufficient\r\n                    // lookahead,\r\n                    // move the upper half to the lower one to make room in the\r\n                    // upper half.\r\n                } else if (strstart >= w_size + w_size - MIN_LOOKAHEAD) {\r\n                    window.set(window.subarray(w_size, w_size + w_size), 0);\r\n\r\n                    match_start -= w_size;\r\n                    strstart -= w_size; // we now have strstart >= MAX_DIST\r\n                    block_start -= w_size;\r\n\r\n                    // Slide the hash table (could be avoided with 32 bit values\r\n                    // at the expense of memory usage). We slide even when level ==\r\n                    // 0\r\n                    // to keep the hash table consistent if we switch back to level\r\n                    // > 0\r\n                    // later. (Using level 0 permanently is not an optimal usage of\r\n                    // zlib, so we don't care about this pathological case.)\r\n\r\n                    n = hash_size;\r\n                    p = n;\r\n                    do {\r\n                        m = (head[--p] & 0xffff);\r\n                        head[p] = (m >= w_size ? m - w_size : 0);\r\n                    } while (--n !== 0);\r\n\r\n                    n = w_size;\r\n                    p = n;\r\n                    do {\r\n                        m = (prev[--p] & 0xffff);\r\n                        prev[p] = (m >= w_size ? m - w_size : 0);\r\n                        // If n is not on any hash chain, prev[n] is garbage but\r\n                        // its value will never be used.\r\n                    } while (--n !== 0);\r\n                    more += w_size;\r\n                }\r\n\r\n                if (strm.avail_in === 0)\r\n                    return;\r\n\r\n                // If there was no sliding:\r\n                // strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\r\n                // more == window_size - lookahead - strstart\r\n                // => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\r\n                // => more >= window_size - 2*WSIZE + 2\r\n                // In the BIG_MEM or MMAP case (not yet supported),\r\n                // window_size == input_size + MIN_LOOKAHEAD &&\r\n                // strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\r\n                // Otherwise, window_size == 2*WSIZE so more >= 2.\r\n                // If there was sliding, more >= WSIZE. So in all cases, more >= 2.\r\n\r\n                n = strm.read_buf(window, strstart + lookahead, more);\r\n                lookahead += n;\r\n\r\n                // Initialize the hash value now that we have some input:\r\n                if (lookahead >= MIN_MATCH) {\r\n                    ins_h = window[strstart] & 0xff;\r\n                    ins_h = (((ins_h) << hash_shift) ^ (window[strstart + 1] & 0xff)) & hash_mask;\r\n                }\r\n                // If the whole input has less than MIN_MATCH bytes, ins_h is\r\n                // garbage,\r\n                // but this is not important since only literal bytes will be\r\n                // emitted.\r\n            } while (lookahead < MIN_LOOKAHEAD && strm.avail_in !== 0);\r\n        }\r\n\r\n        // Copy without compression as much as possible from the input stream,\r\n        // return\r\n        // the current block state.\r\n        // This function does not insert new strings in the dictionary since\r\n        // uncompressible data is probably not useful. This function is used\r\n        // only for the level=0 compression option.\r\n        // NOTE: this function should be optimized to avoid extra copying from\r\n        // window to pending_buf.\r\n        function deflate_stored(flush) {\r\n            // Stored blocks are limited to 0xffff bytes, pending_buf is limited\r\n            // to pending_buf_size, and each stored block has a 5 byte header:\r\n\r\n            var max_block_size = 0xffff;\r\n            var max_start;\r\n\r\n            if (max_block_size > pending_buf_size - 5) {\r\n                max_block_size = pending_buf_size - 5;\r\n            }\r\n\r\n            // Copy as much as possible from input to output:\r\n            while (true) {\r\n                // Fill the window as much as possible:\r\n                if (lookahead <= 1) {\r\n                    fill_window();\r\n                    if (lookahead === 0 && flush == Z_NO_FLUSH)\r\n                        return NeedMore;\r\n                    if (lookahead === 0)\r\n                        break; // flush the current block\r\n                }\r\n\r\n                strstart += lookahead;\r\n                lookahead = 0;\r\n\r\n                // Emit a stored block if pending_buf will be full:\r\n                max_start = block_start + max_block_size;\r\n                if (strstart === 0 || strstart >= max_start) {\r\n                    // strstart === 0 is possible when wraparound on 16-bit machine\r\n                    lookahead = (strstart - max_start);\r\n                    strstart = max_start;\r\n\r\n                    flush_block_only(false);\r\n                    if (strm.avail_out === 0)\r\n                        return NeedMore;\r\n\r\n                }\r\n\r\n                // Flush if we may have to slide, otherwise block_start may become\r\n                // negative and the data will be gone:\r\n                if (strstart - block_start >= w_size - MIN_LOOKAHEAD) {\r\n                    flush_block_only(false);\r\n                    if (strm.avail_out === 0)\r\n                        return NeedMore;\r\n                }\r\n            }\r\n\r\n            flush_block_only(flush == Z_FINISH);\r\n            if (strm.avail_out === 0)\r\n                return (flush == Z_FINISH) ? FinishStarted : NeedMore;\r\n\r\n            return flush == Z_FINISH ? FinishDone : BlockDone;\r\n        }\r\n\r\n        function longest_match(cur_match) {\r\n            var chain_length = max_chain_length; // max hash chain length\r\n            var scan = strstart; // current string\r\n            var match; // matched string\r\n            var len; // length of current match\r\n            var best_len = prev_length; // best match length so far\r\n            var limit = strstart > (w_size - MIN_LOOKAHEAD) ? strstart - (w_size - MIN_LOOKAHEAD) : 0;\r\n            var _nice_match = nice_match;\r\n\r\n            // Stop when cur_match becomes <= limit. To simplify the code,\r\n            // we prevent matches with the string of window index 0.\r\n\r\n            var wmask = w_mask;\r\n\r\n            var strend = strstart + MAX_MATCH;\r\n            var scan_end1 = window[scan + best_len - 1];\r\n            var scan_end = window[scan + best_len];\r\n\r\n            // The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of\r\n            // 16.\r\n            // It is easy to get rid of this optimization if necessary.\r\n\r\n            // Do not waste too much time if we already have a good match:\r\n            if (prev_length >= good_match) {\r\n                chain_length >>= 2;\r\n            }\r\n\r\n            // Do not look for matches beyond the end of the input. This is\r\n            // necessary\r\n            // to make deflate deterministic.\r\n            if (_nice_match > lookahead)\r\n                _nice_match = lookahead;\r\n\r\n            do {\r\n                match = cur_match;\r\n\r\n                // Skip to next match if the match length cannot increase\r\n                // or if the match length is less than 2:\r\n                if (window[match + best_len] != scan_end || window[match + best_len - 1] != scan_end1 || window[match] != window[scan]\r\n                        || window[++match] != window[scan + 1])\r\n                    continue;\r\n\r\n                // The check at best_len-1 can be removed because it will be made\r\n                // again later. (This heuristic is not always a win.)\r\n                // It is not necessary to compare scan[2] and match[2] since they\r\n                // are always equal when the other bytes match, given that\r\n                // the hash keys are equal and that HASH_BITS >= 8.\r\n                scan += 2;\r\n                match++;\r\n\r\n                // We check for insufficient lookahead only every 8th comparison;\r\n                // the 256th check will be made at strstart+258.\r\n                do {\r\n                } while (window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match]\r\n                        && window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match]\r\n                        && window[++scan] == window[++match] && window[++scan] == window[++match] && scan < strend);\r\n\r\n                len = MAX_MATCH - (strend - scan);\r\n                scan = strend - MAX_MATCH;\r\n\r\n                if (len > best_len) {\r\n                    match_start = cur_match;\r\n                    best_len = len;\r\n                    if (len >= _nice_match)\r\n                        break;\r\n                    scan_end1 = window[scan + best_len - 1];\r\n                    scan_end = window[scan + best_len];\r\n                }\r\n\r\n            } while ((cur_match = (prev[cur_match & wmask] & 0xffff)) > limit && --chain_length !== 0);\r\n\r\n            if (best_len <= lookahead)\r\n                return best_len;\r\n            return lookahead;\r\n        }\r\n\r\n        // Compress as much as possible from the input stream, return the current\r\n        // block state.\r\n        // This function does not perform lazy evaluation of matches and inserts\r\n        // new strings in the dictionary only for unmatched strings or for short\r\n        // matches. It is used only for the fast compression options.\r\n        function deflate_fast(flush) {\r\n            // short hash_head = 0; // head of the hash chain\r\n            var hash_head = 0; // head of the hash chain\r\n            var bflush; // set if current block must be flushed\r\n\r\n            while (true) {\r\n                // Make sure that we always have enough lookahead, except\r\n                // at the end of the input file. We need MAX_MATCH bytes\r\n                // for the next match, plus MIN_MATCH bytes to insert the\r\n                // string following the next match.\r\n                if (lookahead < MIN_LOOKAHEAD) {\r\n                    fill_window();\r\n                    if (lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {\r\n                        return NeedMore;\r\n                    }\r\n                    if (lookahead === 0)\r\n                        break; // flush the current block\r\n                }\r\n\r\n                // Insert the string window[strstart .. strstart+2] in the\r\n                // dictionary, and set hash_head to the head of the hash chain:\r\n                if (lookahead >= MIN_MATCH) {\r\n                    ins_h = (((ins_h) << hash_shift) ^ (window[(strstart) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;\r\n\r\n                    // prev[strstart&w_mask]=hash_head=head[ins_h];\r\n                    hash_head = (head[ins_h] & 0xffff);\r\n                    prev[strstart & w_mask] = head[ins_h];\r\n                    head[ins_h] = strstart;\r\n                }\r\n\r\n                // Find the longest match, discarding those <= prev_length.\r\n                // At this point we have always match_length < MIN_MATCH\r\n\r\n                if (hash_head !== 0 && ((strstart - hash_head) & 0xffff) <= w_size - MIN_LOOKAHEAD) {\r\n                    // To simplify the code, we prevent matches with the string\r\n                    // of window index 0 (in particular we have to avoid a match\r\n                    // of the string with itself at the start of the input file).\r\n                    if (strategy != Z_HUFFMAN_ONLY) {\r\n                        match_length = longest_match(hash_head);\r\n                    }\r\n                    // longest_match() sets match_start\r\n                }\r\n                if (match_length >= MIN_MATCH) {\r\n                    // check_match(strstart, match_start, match_length);\r\n\r\n                    bflush = _tr_tally(strstart - match_start, match_length - MIN_MATCH);\r\n\r\n                    lookahead -= match_length;\r\n\r\n                    // Insert new strings in the hash table only if the match length\r\n                    // is not too large. This saves time but degrades compression.\r\n                    if (match_length <= max_lazy_match && lookahead >= MIN_MATCH) {\r\n                        match_length--; // string at strstart already in hash table\r\n                        do {\r\n                            strstart++;\r\n\r\n                            ins_h = ((ins_h << hash_shift) ^ (window[(strstart) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;\r\n                            // prev[strstart&w_mask]=hash_head=head[ins_h];\r\n                            hash_head = (head[ins_h] & 0xffff);\r\n                            prev[strstart & w_mask] = head[ins_h];\r\n                            head[ins_h] = strstart;\r\n\r\n                            // strstart never exceeds WSIZE-MAX_MATCH, so there are\r\n                            // always MIN_MATCH bytes ahead.\r\n                        } while (--match_length !== 0);\r\n                        strstart++;\r\n                    } else {\r\n                        strstart += match_length;\r\n                        match_length = 0;\r\n                        ins_h = window[strstart] & 0xff;\r\n\r\n                        ins_h = (((ins_h) << hash_shift) ^ (window[strstart + 1] & 0xff)) & hash_mask;\r\n                        // If lookahead < MIN_MATCH, ins_h is garbage, but it does\r\n                        // not\r\n                        // matter since it will be recomputed at next deflate call.\r\n                    }\r\n                } else {\r\n                    // No match, output a literal byte\r\n\r\n                    bflush = _tr_tally(0, window[strstart] & 0xff);\r\n                    lookahead--;\r\n                    strstart++;\r\n                }\r\n                if (bflush) {\r\n\r\n                    flush_block_only(false);\r\n                    if (strm.avail_out === 0)\r\n                        return NeedMore;\r\n                }\r\n            }\r\n\r\n            flush_block_only(flush == Z_FINISH);\r\n            if (strm.avail_out === 0) {\r\n                if (flush == Z_FINISH)\r\n                    return FinishStarted;\r\n                else\r\n                    return NeedMore;\r\n            }\r\n            return flush == Z_FINISH ? FinishDone : BlockDone;\r\n        }\r\n\r\n        // Same as above, but achieves better compression. We use a lazy\r\n        // evaluation for matches: a match is finally adopted only if there is\r\n        // no better match at the next window position.\r\n        function deflate_slow(flush) {\r\n            // short hash_head = 0; // head of hash chain\r\n            var hash_head = 0; // head of hash chain\r\n            var bflush; // set if current block must be flushed\r\n            var max_insert;\r\n\r\n            // Process the input block.\r\n            while (true) {\r\n                // Make sure that we always have enough lookahead, except\r\n                // at the end of the input file. We need MAX_MATCH bytes\r\n                // for the next match, plus MIN_MATCH bytes to insert the\r\n                // string following the next match.\r\n\r\n                if (lookahead < MIN_LOOKAHEAD) {\r\n                    fill_window();\r\n                    if (lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {\r\n                        return NeedMore;\r\n                    }\r\n                    if (lookahead === 0)\r\n                        break; // flush the current block\r\n                }\r\n\r\n                // Insert the string window[strstart .. strstart+2] in the\r\n                // dictionary, and set hash_head to the head of the hash chain:\r\n\r\n                if (lookahead >= MIN_MATCH) {\r\n                    ins_h = (((ins_h) << hash_shift) ^ (window[(strstart) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;\r\n                    // prev[strstart&w_mask]=hash_head=head[ins_h];\r\n                    hash_head = (head[ins_h] & 0xffff);\r\n                    prev[strstart & w_mask] = head[ins_h];\r\n                    head[ins_h] = strstart;\r\n                }\r\n\r\n                // Find the longest match, discarding those <= prev_length.\r\n                prev_length = match_length;\r\n                prev_match = match_start;\r\n                match_length = MIN_MATCH - 1;\r\n\r\n                if (hash_head !== 0 && prev_length < max_lazy_match && ((strstart - hash_head) & 0xffff) <= w_size - MIN_LOOKAHEAD) {\r\n                    // To simplify the code, we prevent matches with the string\r\n                    // of window index 0 (in particular we have to avoid a match\r\n                    // of the string with itself at the start of the input file).\r\n\r\n                    if (strategy != Z_HUFFMAN_ONLY) {\r\n                        match_length = longest_match(hash_head);\r\n                    }\r\n                    // longest_match() sets match_start\r\n\r\n                    if (match_length <= 5 && (strategy == Z_FILTERED || (match_length == MIN_MATCH && strstart - match_start > 4096))) {\r\n\r\n                        // If prev_match is also MIN_MATCH, match_start is garbage\r\n                        // but we will ignore the current match anyway.\r\n                        match_length = MIN_MATCH - 1;\r\n                    }\r\n                }\r\n\r\n                // If there was a match at the previous step and the current\r\n                // match is not better, output the previous match:\r\n                if (prev_length >= MIN_MATCH && match_length <= prev_length) {\r\n                    max_insert = strstart + lookahead - MIN_MATCH;\r\n                    // Do not insert strings in hash table beyond this.\r\n\r\n                    // check_match(strstart-1, prev_match, prev_length);\r\n\r\n                    bflush = _tr_tally(strstart - 1 - prev_match, prev_length - MIN_MATCH);\r\n\r\n                    // Insert in hash table all strings up to the end of the match.\r\n                    // strstart-1 and strstart are already inserted. If there is not\r\n                    // enough lookahead, the last two strings are not inserted in\r\n                    // the hash table.\r\n                    lookahead -= prev_length - 1;\r\n                    prev_length -= 2;\r\n                    do {\r\n                        if (++strstart <= max_insert) {\r\n                            ins_h = (((ins_h) << hash_shift) ^ (window[(strstart) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;\r\n                            // prev[strstart&w_mask]=hash_head=head[ins_h];\r\n                            hash_head = (head[ins_h] & 0xffff);\r\n                            prev[strstart & w_mask] = head[ins_h];\r\n                            head[ins_h] = strstart;\r\n                        }\r\n                    } while (--prev_length !== 0);\r\n                    match_available = 0;\r\n                    match_length = MIN_MATCH - 1;\r\n                    strstart++;\r\n\r\n                    if (bflush) {\r\n                        flush_block_only(false);\r\n                        if (strm.avail_out === 0)\r\n                            return NeedMore;\r\n                    }\r\n                } else if (match_available !== 0) {\r\n\r\n                    // If there was no match at the previous position, output a\r\n                    // single literal. If there was a match but the current match\r\n                    // is longer, truncate the previous match to a single literal.\r\n\r\n                    bflush = _tr_tally(0, window[strstart - 1] & 0xff);\r\n\r\n                    if (bflush) {\r\n                        flush_block_only(false);\r\n                    }\r\n                    strstart++;\r\n                    lookahead--;\r\n                    if (strm.avail_out === 0)\r\n                        return NeedMore;\r\n                } else {\r\n                    // There is no previous match to compare with, wait for\r\n                    // the next step to decide.\r\n\r\n                    match_available = 1;\r\n                    strstart++;\r\n                    lookahead--;\r\n                }\r\n            }\r\n\r\n            if (match_available !== 0) {\r\n                bflush = _tr_tally(0, window[strstart - 1] & 0xff);\r\n                match_available = 0;\r\n            }\r\n            flush_block_only(flush == Z_FINISH);\r\n\r\n            if (strm.avail_out === 0) {\r\n                if (flush == Z_FINISH)\r\n                    return FinishStarted;\r\n                else\r\n                    return NeedMore;\r\n            }\r\n\r\n            return flush == Z_FINISH ? FinishDone : BlockDone;\r\n        }\r\n\r\n        function deflateReset(strm) {\r\n            strm.total_in = strm.total_out = 0;\r\n            strm.msg = null; //\r\n\r\n            that.pending = 0;\r\n            that.pending_out = 0;\r\n\r\n            status = BUSY_STATE;\r\n\r\n            last_flush = Z_NO_FLUSH;\r\n\r\n            tr_init();\r\n            lm_init();\r\n            return Z_OK;\r\n        }\r\n\r\n        that.deflateInit = function(strm, _level, bits, _method, memLevel, _strategy) {\r\n            if (!_method)\r\n                _method = Z_DEFLATED;\r\n            if (!memLevel)\r\n                memLevel = DEF_MEM_LEVEL;\r\n            if (!_strategy)\r\n                _strategy = Z_DEFAULT_STRATEGY;\r\n\r\n            // byte[] my_version=ZLIB_VERSION;\r\n\r\n            //\r\n            // if (!version || version[0] != my_version[0]\r\n            // || stream_size != sizeof(z_stream)) {\r\n            // return Z_VERSION_ERROR;\r\n            // }\r\n\r\n            strm.msg = null;\r\n\r\n            if (_level == Z_DEFAULT_COMPRESSION)\r\n                _level = 6;\r\n\r\n            if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || _method != Z_DEFLATED || bits < 9 || bits > 15 || _level < 0 || _level > 9 || _strategy < 0\r\n                    || _strategy > Z_HUFFMAN_ONLY) {\r\n                return Z_STREAM_ERROR;\r\n            }\r\n\r\n            strm.dstate = that;\r\n\r\n            w_bits = bits;\r\n            w_size = 1 << w_bits;\r\n            w_mask = w_size - 1;\r\n\r\n            hash_bits = memLevel + 7;\r\n            hash_size = 1 << hash_bits;\r\n            hash_mask = hash_size - 1;\r\n            hash_shift = Math.floor((hash_bits + MIN_MATCH - 1) / MIN_MATCH);\r\n\r\n            window = new Uint8Array(w_size * 2);\r\n            prev = [];\r\n            head = [];\r\n\r\n            lit_bufsize = 1 << (memLevel + 6); // 16K elements by default\r\n\r\n            // We overlay pending_buf and d_buf+l_buf. This works since the average\r\n            // output size for (length,distance) codes is <= 24 bits.\r\n            that.pending_buf = new Uint8Array(lit_bufsize * 4);\r\n            pending_buf_size = lit_bufsize * 4;\r\n\r\n            d_buf = Math.floor(lit_bufsize / 2);\r\n            l_buf = (1 + 2) * lit_bufsize;\r\n\r\n            level = _level;\r\n\r\n            strategy = _strategy;\r\n            method = _method & 0xff;\r\n\r\n            return deflateReset(strm);\r\n        };\r\n\r\n        that.deflateEnd = function() {\r\n            if (status != INIT_STATE && status != BUSY_STATE && status != FINISH_STATE) {\r\n                return Z_STREAM_ERROR;\r\n            }\r\n            // Deallocate in reverse order of allocations:\r\n            that.pending_buf = null;\r\n            head = null;\r\n            prev = null;\r\n            window = null;\r\n            // free\r\n            that.dstate = null;\r\n            return status == BUSY_STATE ? Z_DATA_ERROR : Z_OK;\r\n        };\r\n\r\n        that.deflateParams = function(strm, _level, _strategy) {\r\n            var err = Z_OK;\r\n\r\n            if (_level == Z_DEFAULT_COMPRESSION) {\r\n                _level = 6;\r\n            }\r\n            if (_level < 0 || _level > 9 || _strategy < 0 || _strategy > Z_HUFFMAN_ONLY) {\r\n                return Z_STREAM_ERROR;\r\n            }\r\n\r\n            if (config_table[level].func != config_table[_level].func && strm.total_in !== 0) {\r\n                // Flush the last buffer:\r\n                err = strm.deflate(Z_PARTIAL_FLUSH);\r\n            }\r\n\r\n            if (level != _level) {\r\n                level = _level;\r\n                max_lazy_match = config_table[level].max_lazy;\r\n                good_match = config_table[level].good_length;\r\n                nice_match = config_table[level].nice_length;\r\n                max_chain_length = config_table[level].max_chain;\r\n            }\r\n            strategy = _strategy;\r\n            return err;\r\n        };\r\n\r\n        that.deflateSetDictionary = function(strm, dictionary, dictLength) {\r\n            var length = dictLength;\r\n            var n, index = 0;\r\n\r\n            if (!dictionary || status != INIT_STATE)\r\n                return Z_STREAM_ERROR;\r\n\r\n            if (length < MIN_MATCH)\r\n                return Z_OK;\r\n            if (length > w_size - MIN_LOOKAHEAD) {\r\n                length = w_size - MIN_LOOKAHEAD;\r\n                index = dictLength - length; // use the tail of the dictionary\r\n            }\r\n            window.set(dictionary.subarray(index, index + length), 0);\r\n\r\n            strstart = length;\r\n            block_start = length;\r\n\r\n            // Insert all strings in the hash table (except for the last two bytes).\r\n            // s->lookahead stays null, so s->ins_h will be recomputed at the next\r\n            // call of fill_window.\r\n\r\n            ins_h = window[0] & 0xff;\r\n            ins_h = (((ins_h) << hash_shift) ^ (window[1] & 0xff)) & hash_mask;\r\n\r\n            for (n = 0; n <= length - MIN_MATCH; n++) {\r\n                ins_h = (((ins_h) << hash_shift) ^ (window[(n) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;\r\n                prev[n & w_mask] = head[ins_h];\r\n                head[ins_h] = n;\r\n            }\r\n            return Z_OK;\r\n        };\r\n\r\n        that.deflate = function(_strm, flush) {\r\n            var i, header, level_flags, old_flush, bstate;\r\n\r\n            if (flush > Z_FINISH || flush < 0) {\r\n                return Z_STREAM_ERROR;\r\n            }\r\n\r\n            if (!_strm.next_out || (!_strm.next_in && _strm.avail_in !== 0) || (status == FINISH_STATE && flush != Z_FINISH)) {\r\n                _strm.msg = z_errmsg[Z_NEED_DICT - (Z_STREAM_ERROR)];\r\n                return Z_STREAM_ERROR;\r\n            }\r\n            if (_strm.avail_out === 0) {\r\n                _strm.msg = z_errmsg[Z_NEED_DICT - (Z_BUF_ERROR)];\r\n                return Z_BUF_ERROR;\r\n            }\r\n\r\n            strm = _strm; // just in case\r\n            old_flush = last_flush;\r\n            last_flush = flush;\r\n\r\n            // Write the zlib header\r\n            if (status == INIT_STATE) {\r\n                header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;\r\n                level_flags = ((level - 1) & 0xff) >> 1;\r\n\r\n                if (level_flags > 3)\r\n                    level_flags = 3;\r\n                header |= (level_flags << 6);\r\n                if (strstart !== 0)\r\n                    header |= PRESET_DICT;\r\n                header += 31 - (header % 31);\r\n\r\n                status = BUSY_STATE;\r\n                putShortMSB(header);\r\n            }\r\n\r\n            // Flush as much pending output as possible\r\n            if (that.pending !== 0) {\r\n                strm.flush_pending();\r\n                if (strm.avail_out === 0) {\r\n                    // console.log(\" avail_out==0\");\r\n                    // Since avail_out is 0, deflate will be called again with\r\n                    // more output space, but possibly with both pending and\r\n                    // avail_in equal to zero. There won't be anything to do,\r\n                    // but this is not an error situation so make sure we\r\n                    // return OK instead of BUF_ERROR at next call of deflate:\r\n                    last_flush = -1;\r\n                    return Z_OK;\r\n                }\r\n\r\n                // Make sure there is something to do and avoid duplicate\r\n                // consecutive\r\n                // flushes. For repeated and useless calls with Z_FINISH, we keep\r\n                // returning Z_STREAM_END instead of Z_BUFF_ERROR.\r\n            } else if (strm.avail_in === 0 && flush <= old_flush && flush != Z_FINISH) {\r\n                strm.msg = z_errmsg[Z_NEED_DICT - (Z_BUF_ERROR)];\r\n                return Z_BUF_ERROR;\r\n            }\r\n\r\n            // User must not provide more input after the first FINISH:\r\n            if (status == FINISH_STATE && strm.avail_in !== 0) {\r\n                _strm.msg = z_errmsg[Z_NEED_DICT - (Z_BUF_ERROR)];\r\n                return Z_BUF_ERROR;\r\n            }\r\n\r\n            // Start a new block or continue the current one.\r\n            if (strm.avail_in !== 0 || lookahead !== 0 || (flush != Z_NO_FLUSH && status != FINISH_STATE)) {\r\n                bstate = -1;\r\n                switch (config_table[level].func) {\r\n                case STORED:\r\n                    bstate = deflate_stored(flush);\r\n                    break;\r\n                case FAST:\r\n                    bstate = deflate_fast(flush);\r\n                    break;\r\n                case SLOW:\r\n                    bstate = deflate_slow(flush);\r\n                    break;\r\n                default:\r\n                }\r\n\r\n                if (bstate == FinishStarted || bstate == FinishDone) {\r\n                    status = FINISH_STATE;\r\n                }\r\n                if (bstate == NeedMore || bstate == FinishStarted) {\r\n                    if (strm.avail_out === 0) {\r\n                        last_flush = -1; // avoid BUF_ERROR next call, see above\r\n                    }\r\n                    return Z_OK;\r\n                    // If flush != Z_NO_FLUSH && avail_out === 0, the next call\r\n                    // of deflate should use the same flush parameter to make sure\r\n                    // that the flush is complete. So we don't have to output an\r\n                    // empty block here, this will be done at next call. This also\r\n                    // ensures that for a very small output buffer, we emit at most\r\n                    // one empty block.\r\n                }\r\n\r\n                if (bstate == BlockDone) {\r\n                    if (flush == Z_PARTIAL_FLUSH) {\r\n                        _tr_align();\r\n                    } else { // FULL_FLUSH or SYNC_FLUSH\r\n                        _tr_stored_block(0, 0, false);\r\n                        // For a full flush, this empty block will be recognized\r\n                        // as a special marker by inflate_sync().\r\n                        if (flush == Z_FULL_FLUSH) {\r\n                            // state.head[s.hash_size-1]=0;\r\n                            for (i = 0; i < hash_size/*-1*/; i++)\r\n                                // forget history\r\n                                head[i] = 0;\r\n                        }\r\n                    }\r\n                    strm.flush_pending();\r\n                    if (strm.avail_out === 0) {\r\n                        last_flush = -1; // avoid BUF_ERROR at next call, see above\r\n                        return Z_OK;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (flush != Z_FINISH)\r\n                return Z_OK;\r\n            return Z_STREAM_END;\r\n        };\r\n    }\r\n\r\n    // ZStream\r\n\r\n    function ZStream() {\r\n        var that = this;\r\n        that.next_in_index = 0;\r\n        that.next_out_index = 0;\r\n        // that.next_in; // next input byte\r\n        that.avail_in = 0; // number of bytes available at next_in\r\n        that.total_in = 0; // total nb of input bytes read so far\r\n        // that.next_out; // next output byte should be put there\r\n        that.avail_out = 0; // remaining free space at next_out\r\n        that.total_out = 0; // total nb of bytes output so far\r\n        // that.msg;\r\n        // that.dstate;\r\n    }\r\n\r\n    ZStream.prototype = {\r\n        deflateInit : function(level, bits) {\r\n            var that = this;\r\n            that.dstate = new Deflate();\r\n            if (!bits)\r\n                bits = MAX_BITS;\r\n            return that.dstate.deflateInit(that, level, bits);\r\n        },\r\n\r\n        deflate : function(flush) {\r\n            var that = this;\r\n            if (!that.dstate) {\r\n                return Z_STREAM_ERROR;\r\n            }\r\n            return that.dstate.deflate(that, flush);\r\n        },\r\n\r\n        deflateEnd : function() {\r\n            var that = this;\r\n            if (!that.dstate)\r\n                return Z_STREAM_ERROR;\r\n            var ret = that.dstate.deflateEnd();\r\n            that.dstate = null;\r\n            return ret;\r\n        },\r\n\r\n        deflateParams : function(level, strategy) {\r\n            var that = this;\r\n            if (!that.dstate)\r\n                return Z_STREAM_ERROR;\r\n            return that.dstate.deflateParams(that, level, strategy);\r\n        },\r\n\r\n        deflateSetDictionary : function(dictionary, dictLength) {\r\n            var that = this;\r\n            if (!that.dstate)\r\n                return Z_STREAM_ERROR;\r\n            return that.dstate.deflateSetDictionary(that, dictionary, dictLength);\r\n        },\r\n\r\n        // Read a new buffer from the current input stream, update the\r\n        // total number of bytes read. All deflate() input goes through\r\n        // this function so some applications may wish to modify it to avoid\r\n        // allocating a large strm->next_in buffer and copying from it.\r\n        // (See also flush_pending()).\r\n        read_buf : function(buf, start, size) {\r\n            var that = this;\r\n            var len = that.avail_in;\r\n            if (len > size)\r\n                len = size;\r\n            if (len === 0)\r\n                return 0;\r\n            that.avail_in -= len;\r\n            buf.set(that.next_in.subarray(that.next_in_index, that.next_in_index + len), start);\r\n            that.next_in_index += len;\r\n            that.total_in += len;\r\n            return len;\r\n        },\r\n\r\n        // Flush as much pending output as possible. All deflate() output goes\r\n        // through this function so some applications may wish to modify it\r\n        // to avoid allocating a large strm->next_out buffer and copying into it.\r\n        // (See also read_buf()).\r\n        flush_pending : function() {\r\n            var that = this;\r\n            var len = that.dstate.pending;\r\n\r\n            if (len > that.avail_out)\r\n                len = that.avail_out;\r\n            if (len === 0)\r\n                return;\r\n\r\n            // if (that.dstate.pending_buf.length <= that.dstate.pending_out || that.next_out.length <= that.next_out_index\r\n            // || that.dstate.pending_buf.length < (that.dstate.pending_out + len) || that.next_out.length < (that.next_out_index +\r\n            // len)) {\r\n            // console.log(that.dstate.pending_buf.length + \", \" + that.dstate.pending_out + \", \" + that.next_out.length + \", \" +\r\n            // that.next_out_index + \", \" + len);\r\n            // console.log(\"avail_out=\" + that.avail_out);\r\n            // }\r\n\r\n            that.next_out.set(that.dstate.pending_buf.subarray(that.dstate.pending_out, that.dstate.pending_out + len), that.next_out_index);\r\n\r\n            that.next_out_index += len;\r\n            that.dstate.pending_out += len;\r\n            that.total_out += len;\r\n            that.avail_out -= len;\r\n            that.dstate.pending -= len;\r\n            if (that.dstate.pending === 0) {\r\n                that.dstate.pending_out = 0;\r\n            }\r\n        }\r\n    };\r\n\r\n    // Deflater\r\n\r\n    function Deflater(options) {\r\n        var that = this;\r\n        var z = new ZStream();\r\n        var bufsize = 512;\r\n        var flush = Z_NO_FLUSH;\r\n        var buf = new Uint8Array(bufsize);\r\n        var level = options ? options.level : Z_DEFAULT_COMPRESSION;\r\n        if (typeof level == \"undefined\")\r\n            level = Z_DEFAULT_COMPRESSION;\r\n        z.deflateInit(level);\r\n        z.next_out = buf;\r\n\r\n        that.append = function(data, onprogress) {\r\n            var err, buffers = [], lastIndex = 0, bufferIndex = 0, bufferSize = 0, array;\r\n            if (!data.length)\r\n                return;\r\n            z.next_in_index = 0;\r\n            z.next_in = data;\r\n            z.avail_in = data.length;\r\n            do {\r\n                z.next_out_index = 0;\r\n                z.avail_out = bufsize;\r\n                err = z.deflate(flush);\r\n                if (err != Z_OK)\r\n                    throw new Error(\"deflating: \" + z.msg);\r\n                if (z.next_out_index)\r\n                    if (z.next_out_index == bufsize)\r\n                        buffers.push(new Uint8Array(buf));\r\n                    else\r\n                        buffers.push(new Uint8Array(buf.subarray(0, z.next_out_index)));\r\n                bufferSize += z.next_out_index;\r\n                if (onprogress && z.next_in_index > 0 && z.next_in_index != lastIndex) {\r\n                    onprogress(z.next_in_index);\r\n                    lastIndex = z.next_in_index;\r\n                }\r\n            } while (z.avail_in > 0 || z.avail_out === 0);\r\n            array = new Uint8Array(bufferSize);\r\n            buffers.forEach(function(chunk) {\r\n                array.set(chunk, bufferIndex);\r\n                bufferIndex += chunk.length;\r\n            });\r\n            return array;\r\n        };\r\n        that.flush = function() {\r\n            var err, buffers = [], bufferIndex = 0, bufferSize = 0, array;\r\n            do {\r\n                z.next_out_index = 0;\r\n                z.avail_out = bufsize;\r\n                err = z.deflate(Z_FINISH);\r\n                if (err != Z_STREAM_END && err != Z_OK)\r\n                    throw new Error(\"deflating: \" + z.msg);\r\n                if (bufsize - z.avail_out > 0)\r\n                    buffers.push(new Uint8Array(buf.subarray(0, z.next_out_index)));\r\n                bufferSize += z.next_out_index;\r\n            } while (z.avail_in > 0 || z.avail_out === 0);\r\n            z.deflateEnd();\r\n            array = new Uint8Array(bufferSize);\r\n            buffers.forEach(function(chunk) {\r\n                array.set(chunk, bufferIndex);\r\n                bufferIndex += chunk.length;\r\n            });\r\n            return array;\r\n        };\r\n    }\r\n\r\n    // 'zip' may not be defined in z-worker and some tests\r\n    var env = global.zip || global;\r\n    env.Deflater = env._jzlib_Deflater = Deflater;\r\n})(this);";

},{}],2:[function(require,module,exports){
module.exports = "/*\r\n Copyright (c) 2013 Gildas Lormeau. All rights reserved.\r\n\r\n Redistribution and use in source and binary forms, with or without\r\n modification, are permitted provided that the following conditions are met:\r\n\r\n 1. Redistributions of source code must retain the above copyright notice,\r\n this list of conditions and the following disclaimer.\r\n\r\n 2. Redistributions in binary form must reproduce the above copyright\r\n notice, this list of conditions and the following disclaimer in\r\n the documentation and/or other materials provided with the distribution.\r\n\r\n 3. The names of the authors may not be used to endorse or promote products\r\n derived from this software without specific prior written permission.\r\n\r\n THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,\r\n INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\r\n FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,\r\n INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,\r\n INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\r\n LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\r\n OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\r\n LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\r\n NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\r\n EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\n/*\r\n * This program is based on JZlib 1.0.2 ymnk, JCraft,Inc.\r\n * JZlib is based on zlib-1.1.3, so all credit should go authors\r\n * Jean-loup Gailly(jloup@gzip.org) and Mark Adler(madler@alumni.caltech.edu)\r\n * and contributors of zlib.\r\n */\r\n\r\n(function(global) {\r\n    \"use strict\";\r\n\r\n    // Global\r\n    var MAX_BITS = 15;\r\n\r\n    var Z_OK = 0;\r\n    var Z_STREAM_END = 1;\r\n    var Z_NEED_DICT = 2;\r\n    var Z_STREAM_ERROR = -2;\r\n    var Z_DATA_ERROR = -3;\r\n    var Z_MEM_ERROR = -4;\r\n    var Z_BUF_ERROR = -5;\r\n\r\n    var inflate_mask = [ 0x00000000, 0x00000001, 0x00000003, 0x00000007, 0x0000000f, 0x0000001f, 0x0000003f, 0x0000007f, 0x000000ff, 0x000001ff, 0x000003ff,\r\n            0x000007ff, 0x00000fff, 0x00001fff, 0x00003fff, 0x00007fff, 0x0000ffff ];\r\n\r\n    var MANY = 1440;\r\n\r\n    // JZlib version : \"1.0.2\"\r\n    var Z_NO_FLUSH = 0;\r\n    var Z_FINISH = 4;\r\n\r\n    // InfTree\r\n    var fixed_bl = 9;\r\n    var fixed_bd = 5;\r\n\r\n    var fixed_tl = [ 96, 7, 256, 0, 8, 80, 0, 8, 16, 84, 8, 115, 82, 7, 31, 0, 8, 112, 0, 8, 48, 0, 9, 192, 80, 7, 10, 0, 8, 96, 0, 8, 32, 0, 9, 160, 0, 8, 0,\r\n            0, 8, 128, 0, 8, 64, 0, 9, 224, 80, 7, 6, 0, 8, 88, 0, 8, 24, 0, 9, 144, 83, 7, 59, 0, 8, 120, 0, 8, 56, 0, 9, 208, 81, 7, 17, 0, 8, 104, 0, 8, 40,\r\n            0, 9, 176, 0, 8, 8, 0, 8, 136, 0, 8, 72, 0, 9, 240, 80, 7, 4, 0, 8, 84, 0, 8, 20, 85, 8, 227, 83, 7, 43, 0, 8, 116, 0, 8, 52, 0, 9, 200, 81, 7, 13,\r\n            0, 8, 100, 0, 8, 36, 0, 9, 168, 0, 8, 4, 0, 8, 132, 0, 8, 68, 0, 9, 232, 80, 7, 8, 0, 8, 92, 0, 8, 28, 0, 9, 152, 84, 7, 83, 0, 8, 124, 0, 8, 60,\r\n            0, 9, 216, 82, 7, 23, 0, 8, 108, 0, 8, 44, 0, 9, 184, 0, 8, 12, 0, 8, 140, 0, 8, 76, 0, 9, 248, 80, 7, 3, 0, 8, 82, 0, 8, 18, 85, 8, 163, 83, 7,\r\n            35, 0, 8, 114, 0, 8, 50, 0, 9, 196, 81, 7, 11, 0, 8, 98, 0, 8, 34, 0, 9, 164, 0, 8, 2, 0, 8, 130, 0, 8, 66, 0, 9, 228, 80, 7, 7, 0, 8, 90, 0, 8,\r\n            26, 0, 9, 148, 84, 7, 67, 0, 8, 122, 0, 8, 58, 0, 9, 212, 82, 7, 19, 0, 8, 106, 0, 8, 42, 0, 9, 180, 0, 8, 10, 0, 8, 138, 0, 8, 74, 0, 9, 244, 80,\r\n            7, 5, 0, 8, 86, 0, 8, 22, 192, 8, 0, 83, 7, 51, 0, 8, 118, 0, 8, 54, 0, 9, 204, 81, 7, 15, 0, 8, 102, 0, 8, 38, 0, 9, 172, 0, 8, 6, 0, 8, 134, 0,\r\n            8, 70, 0, 9, 236, 80, 7, 9, 0, 8, 94, 0, 8, 30, 0, 9, 156, 84, 7, 99, 0, 8, 126, 0, 8, 62, 0, 9, 220, 82, 7, 27, 0, 8, 110, 0, 8, 46, 0, 9, 188, 0,\r\n            8, 14, 0, 8, 142, 0, 8, 78, 0, 9, 252, 96, 7, 256, 0, 8, 81, 0, 8, 17, 85, 8, 131, 82, 7, 31, 0, 8, 113, 0, 8, 49, 0, 9, 194, 80, 7, 10, 0, 8, 97,\r\n            0, 8, 33, 0, 9, 162, 0, 8, 1, 0, 8, 129, 0, 8, 65, 0, 9, 226, 80, 7, 6, 0, 8, 89, 0, 8, 25, 0, 9, 146, 83, 7, 59, 0, 8, 121, 0, 8, 57, 0, 9, 210,\r\n            81, 7, 17, 0, 8, 105, 0, 8, 41, 0, 9, 178, 0, 8, 9, 0, 8, 137, 0, 8, 73, 0, 9, 242, 80, 7, 4, 0, 8, 85, 0, 8, 21, 80, 8, 258, 83, 7, 43, 0, 8, 117,\r\n            0, 8, 53, 0, 9, 202, 81, 7, 13, 0, 8, 101, 0, 8, 37, 0, 9, 170, 0, 8, 5, 0, 8, 133, 0, 8, 69, 0, 9, 234, 80, 7, 8, 0, 8, 93, 0, 8, 29, 0, 9, 154,\r\n            84, 7, 83, 0, 8, 125, 0, 8, 61, 0, 9, 218, 82, 7, 23, 0, 8, 109, 0, 8, 45, 0, 9, 186, 0, 8, 13, 0, 8, 141, 0, 8, 77, 0, 9, 250, 80, 7, 3, 0, 8, 83,\r\n            0, 8, 19, 85, 8, 195, 83, 7, 35, 0, 8, 115, 0, 8, 51, 0, 9, 198, 81, 7, 11, 0, 8, 99, 0, 8, 35, 0, 9, 166, 0, 8, 3, 0, 8, 131, 0, 8, 67, 0, 9, 230,\r\n            80, 7, 7, 0, 8, 91, 0, 8, 27, 0, 9, 150, 84, 7, 67, 0, 8, 123, 0, 8, 59, 0, 9, 214, 82, 7, 19, 0, 8, 107, 0, 8, 43, 0, 9, 182, 0, 8, 11, 0, 8, 139,\r\n            0, 8, 75, 0, 9, 246, 80, 7, 5, 0, 8, 87, 0, 8, 23, 192, 8, 0, 83, 7, 51, 0, 8, 119, 0, 8, 55, 0, 9, 206, 81, 7, 15, 0, 8, 103, 0, 8, 39, 0, 9, 174,\r\n            0, 8, 7, 0, 8, 135, 0, 8, 71, 0, 9, 238, 80, 7, 9, 0, 8, 95, 0, 8, 31, 0, 9, 158, 84, 7, 99, 0, 8, 127, 0, 8, 63, 0, 9, 222, 82, 7, 27, 0, 8, 111,\r\n            0, 8, 47, 0, 9, 190, 0, 8, 15, 0, 8, 143, 0, 8, 79, 0, 9, 254, 96, 7, 256, 0, 8, 80, 0, 8, 16, 84, 8, 115, 82, 7, 31, 0, 8, 112, 0, 8, 48, 0, 9,\r\n            193, 80, 7, 10, 0, 8, 96, 0, 8, 32, 0, 9, 161, 0, 8, 0, 0, 8, 128, 0, 8, 64, 0, 9, 225, 80, 7, 6, 0, 8, 88, 0, 8, 24, 0, 9, 145, 83, 7, 59, 0, 8,\r\n            120, 0, 8, 56, 0, 9, 209, 81, 7, 17, 0, 8, 104, 0, 8, 40, 0, 9, 177, 0, 8, 8, 0, 8, 136, 0, 8, 72, 0, 9, 241, 80, 7, 4, 0, 8, 84, 0, 8, 20, 85, 8,\r\n            227, 83, 7, 43, 0, 8, 116, 0, 8, 52, 0, 9, 201, 81, 7, 13, 0, 8, 100, 0, 8, 36, 0, 9, 169, 0, 8, 4, 0, 8, 132, 0, 8, 68, 0, 9, 233, 80, 7, 8, 0, 8,\r\n            92, 0, 8, 28, 0, 9, 153, 84, 7, 83, 0, 8, 124, 0, 8, 60, 0, 9, 217, 82, 7, 23, 0, 8, 108, 0, 8, 44, 0, 9, 185, 0, 8, 12, 0, 8, 140, 0, 8, 76, 0, 9,\r\n            249, 80, 7, 3, 0, 8, 82, 0, 8, 18, 85, 8, 163, 83, 7, 35, 0, 8, 114, 0, 8, 50, 0, 9, 197, 81, 7, 11, 0, 8, 98, 0, 8, 34, 0, 9, 165, 0, 8, 2, 0, 8,\r\n            130, 0, 8, 66, 0, 9, 229, 80, 7, 7, 0, 8, 90, 0, 8, 26, 0, 9, 149, 84, 7, 67, 0, 8, 122, 0, 8, 58, 0, 9, 213, 82, 7, 19, 0, 8, 106, 0, 8, 42, 0, 9,\r\n            181, 0, 8, 10, 0, 8, 138, 0, 8, 74, 0, 9, 245, 80, 7, 5, 0, 8, 86, 0, 8, 22, 192, 8, 0, 83, 7, 51, 0, 8, 118, 0, 8, 54, 0, 9, 205, 81, 7, 15, 0, 8,\r\n            102, 0, 8, 38, 0, 9, 173, 0, 8, 6, 0, 8, 134, 0, 8, 70, 0, 9, 237, 80, 7, 9, 0, 8, 94, 0, 8, 30, 0, 9, 157, 84, 7, 99, 0, 8, 126, 0, 8, 62, 0, 9,\r\n            221, 82, 7, 27, 0, 8, 110, 0, 8, 46, 0, 9, 189, 0, 8, 14, 0, 8, 142, 0, 8, 78, 0, 9, 253, 96, 7, 256, 0, 8, 81, 0, 8, 17, 85, 8, 131, 82, 7, 31, 0,\r\n            8, 113, 0, 8, 49, 0, 9, 195, 80, 7, 10, 0, 8, 97, 0, 8, 33, 0, 9, 163, 0, 8, 1, 0, 8, 129, 0, 8, 65, 0, 9, 227, 80, 7, 6, 0, 8, 89, 0, 8, 25, 0, 9,\r\n            147, 83, 7, 59, 0, 8, 121, 0, 8, 57, 0, 9, 211, 81, 7, 17, 0, 8, 105, 0, 8, 41, 0, 9, 179, 0, 8, 9, 0, 8, 137, 0, 8, 73, 0, 9, 243, 80, 7, 4, 0, 8,\r\n            85, 0, 8, 21, 80, 8, 258, 83, 7, 43, 0, 8, 117, 0, 8, 53, 0, 9, 203, 81, 7, 13, 0, 8, 101, 0, 8, 37, 0, 9, 171, 0, 8, 5, 0, 8, 133, 0, 8, 69, 0, 9,\r\n            235, 80, 7, 8, 0, 8, 93, 0, 8, 29, 0, 9, 155, 84, 7, 83, 0, 8, 125, 0, 8, 61, 0, 9, 219, 82, 7, 23, 0, 8, 109, 0, 8, 45, 0, 9, 187, 0, 8, 13, 0, 8,\r\n            141, 0, 8, 77, 0, 9, 251, 80, 7, 3, 0, 8, 83, 0, 8, 19, 85, 8, 195, 83, 7, 35, 0, 8, 115, 0, 8, 51, 0, 9, 199, 81, 7, 11, 0, 8, 99, 0, 8, 35, 0, 9,\r\n            167, 0, 8, 3, 0, 8, 131, 0, 8, 67, 0, 9, 231, 80, 7, 7, 0, 8, 91, 0, 8, 27, 0, 9, 151, 84, 7, 67, 0, 8, 123, 0, 8, 59, 0, 9, 215, 82, 7, 19, 0, 8,\r\n            107, 0, 8, 43, 0, 9, 183, 0, 8, 11, 0, 8, 139, 0, 8, 75, 0, 9, 247, 80, 7, 5, 0, 8, 87, 0, 8, 23, 192, 8, 0, 83, 7, 51, 0, 8, 119, 0, 8, 55, 0, 9,\r\n            207, 81, 7, 15, 0, 8, 103, 0, 8, 39, 0, 9, 175, 0, 8, 7, 0, 8, 135, 0, 8, 71, 0, 9, 239, 80, 7, 9, 0, 8, 95, 0, 8, 31, 0, 9, 159, 84, 7, 99, 0, 8,\r\n            127, 0, 8, 63, 0, 9, 223, 82, 7, 27, 0, 8, 111, 0, 8, 47, 0, 9, 191, 0, 8, 15, 0, 8, 143, 0, 8, 79, 0, 9, 255 ];\r\n    var fixed_td = [ 80, 5, 1, 87, 5, 257, 83, 5, 17, 91, 5, 4097, 81, 5, 5, 89, 5, 1025, 85, 5, 65, 93, 5, 16385, 80, 5, 3, 88, 5, 513, 84, 5, 33, 92, 5,\r\n            8193, 82, 5, 9, 90, 5, 2049, 86, 5, 129, 192, 5, 24577, 80, 5, 2, 87, 5, 385, 83, 5, 25, 91, 5, 6145, 81, 5, 7, 89, 5, 1537, 85, 5, 97, 93, 5,\r\n            24577, 80, 5, 4, 88, 5, 769, 84, 5, 49, 92, 5, 12289, 82, 5, 13, 90, 5, 3073, 86, 5, 193, 192, 5, 24577 ];\r\n\r\n    // Tables for deflate from PKZIP's appnote.txt.\r\n    var cplens = [ // Copy lengths for literal codes 257..285\r\n    3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0 ];\r\n\r\n    // see note #13 above about 258\r\n    var cplext = [ // Extra bits for literal codes 257..285\r\n    0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 112, 112 // 112==invalid\r\n    ];\r\n\r\n    var cpdist = [ // Copy offsets for distance codes 0..29\r\n    1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577 ];\r\n\r\n    var cpdext = [ // Extra bits for distance codes\r\n    0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13 ];\r\n\r\n    // If BMAX needs to be larger than 16, then h and x[] should be uLong.\r\n    var BMAX = 15; // maximum bit length of any code\r\n\r\n    function InfTree() {\r\n        var that = this;\r\n\r\n        var hn; // hufts used in space\r\n        var v; // work area for huft_build\r\n        var c; // bit length count table\r\n        var r; // table entry for structure assignment\r\n        var u; // table stack\r\n        var x; // bit offsets, then code stack\r\n\r\n        function huft_build(b, // code lengths in bits (all assumed <=\r\n        // BMAX)\r\n        bindex, n, // number of codes (assumed <= 288)\r\n        s, // number of simple-valued codes (0..s-1)\r\n        d, // list of base values for non-simple codes\r\n        e, // list of extra bits for non-simple codes\r\n        t, // result: starting table\r\n        m, // maximum lookup bits, returns actual\r\n        hp,// space for trees\r\n        hn,// hufts used in space\r\n        v // working area: values in order of bit length\r\n        ) {\r\n            // Given a list of code lengths and a maximum table size, make a set of\r\n            // tables to decode that set of codes. Return Z_OK on success,\r\n            // Z_BUF_ERROR\r\n            // if the given code set is incomplete (the tables are still built in\r\n            // this\r\n            // case), Z_DATA_ERROR if the input is invalid (an over-subscribed set\r\n            // of\r\n            // lengths), or Z_MEM_ERROR if not enough memory.\r\n\r\n            var a; // counter for codes of length k\r\n            var f; // i repeats in table every f entries\r\n            var g; // maximum code length\r\n            var h; // table level\r\n            var i; // counter, current code\r\n            var j; // counter\r\n            var k; // number of bits in current code\r\n            var l; // bits per table (returned in m)\r\n            var mask; // (1 << w) - 1, to avoid cc -O bug on HP\r\n            var p; // pointer into c[], b[], or v[]\r\n            var q; // points to current table\r\n            var w; // bits before this table == (l * h)\r\n            var xp; // pointer into x\r\n            var y; // number of dummy codes added\r\n            var z; // number of entries in current table\r\n\r\n            // Generate counts for each bit length\r\n\r\n            p = 0;\r\n            i = n;\r\n            do {\r\n                c[b[bindex + p]]++;\r\n                p++;\r\n                i--; // assume all entries <= BMAX\r\n            } while (i !== 0);\r\n\r\n            if (c[0] == n) { // null input--all zero length codes\r\n                t[0] = -1;\r\n                m[0] = 0;\r\n                return Z_OK;\r\n            }\r\n\r\n            // Find minimum and maximum length, bound *m by those\r\n            l = m[0];\r\n            for (j = 1; j <= BMAX; j++)\r\n                if (c[j] !== 0)\r\n                    break;\r\n            k = j; // minimum code length\r\n            if (l < j) {\r\n                l = j;\r\n            }\r\n            for (i = BMAX; i !== 0; i--) {\r\n                if (c[i] !== 0)\r\n                    break;\r\n            }\r\n            g = i; // maximum code length\r\n            if (l > i) {\r\n                l = i;\r\n            }\r\n            m[0] = l;\r\n\r\n            // Adjust last length count to fill out codes, if needed\r\n            for (y = 1 << j; j < i; j++, y <<= 1) {\r\n                if ((y -= c[j]) < 0) {\r\n                    return Z_DATA_ERROR;\r\n                }\r\n            }\r\n            if ((y -= c[i]) < 0) {\r\n                return Z_DATA_ERROR;\r\n            }\r\n            c[i] += y;\r\n\r\n            // Generate starting offsets into the value table for each length\r\n            x[1] = j = 0;\r\n            p = 1;\r\n            xp = 2;\r\n            while (--i !== 0) { // note that i == g from above\r\n                x[xp] = (j += c[p]);\r\n                xp++;\r\n                p++;\r\n            }\r\n\r\n            // Make a table of values in order of bit lengths\r\n            i = 0;\r\n            p = 0;\r\n            do {\r\n                if ((j = b[bindex + p]) !== 0) {\r\n                    v[x[j]++] = i;\r\n                }\r\n                p++;\r\n            } while (++i < n);\r\n            n = x[g]; // set n to length of v\r\n\r\n            // Generate the Huffman codes and for each, make the table entries\r\n            x[0] = i = 0; // first Huffman code is zero\r\n            p = 0; // grab values in bit order\r\n            h = -1; // no tables yet--level -1\r\n            w = -l; // bits decoded == (l * h)\r\n            u[0] = 0; // just to keep compilers happy\r\n            q = 0; // ditto\r\n            z = 0; // ditto\r\n\r\n            // go through the bit lengths (k already is bits in shortest code)\r\n            for (; k <= g; k++) {\r\n                a = c[k];\r\n                while (a-- !== 0) {\r\n                    // here i is the Huffman code of length k bits for value *p\r\n                    // make tables up to required level\r\n                    while (k > w + l) {\r\n                        h++;\r\n                        w += l; // previous table always l bits\r\n                        // compute minimum size table less than or equal to l bits\r\n                        z = g - w;\r\n                        z = (z > l) ? l : z; // table size upper limit\r\n                        if ((f = 1 << (j = k - w)) > a + 1) { // try a k-w bit table\r\n                            // too few codes for\r\n                            // k-w bit table\r\n                            f -= a + 1; // deduct codes from patterns left\r\n                            xp = k;\r\n                            if (j < z) {\r\n                                while (++j < z) { // try smaller tables up to z bits\r\n                                    if ((f <<= 1) <= c[++xp])\r\n                                        break; // enough codes to use up j bits\r\n                                    f -= c[xp]; // else deduct codes from patterns\r\n                                }\r\n                            }\r\n                        }\r\n                        z = 1 << j; // table entries for j-bit table\r\n\r\n                        // allocate new table\r\n                        if (hn[0] + z > MANY) { // (note: doesn't matter for fixed)\r\n                            return Z_DATA_ERROR; // overflow of MANY\r\n                        }\r\n                        u[h] = q = /* hp+ */hn[0]; // DEBUG\r\n                        hn[0] += z;\r\n\r\n                        // connect to last table, if there is one\r\n                        if (h !== 0) {\r\n                            x[h] = i; // save pattern for backing up\r\n                            r[0] = /* (byte) */j; // bits in this table\r\n                            r[1] = /* (byte) */l; // bits to dump before this table\r\n                            j = i >>> (w - l);\r\n                            r[2] = /* (int) */(q - u[h - 1] - j); // offset to this table\r\n                            hp.set(r, (u[h - 1] + j) * 3);\r\n                            // to\r\n                            // last\r\n                            // table\r\n                        } else {\r\n                            t[0] = q; // first table is returned result\r\n                        }\r\n                    }\r\n\r\n                    // set up table entry in r\r\n                    r[1] = /* (byte) */(k - w);\r\n                    if (p >= n) {\r\n                        r[0] = 128 + 64; // out of values--invalid code\r\n                    } else if (v[p] < s) {\r\n                        r[0] = /* (byte) */(v[p] < 256 ? 0 : 32 + 64); // 256 is\r\n                        // end-of-block\r\n                        r[2] = v[p++]; // simple code is just the value\r\n                    } else {\r\n                        r[0] = /* (byte) */(e[v[p] - s] + 16 + 64); // non-simple--look\r\n                        // up in lists\r\n                        r[2] = d[v[p++] - s];\r\n                    }\r\n\r\n                    // fill code-like entries with r\r\n                    f = 1 << (k - w);\r\n                    for (j = i >>> w; j < z; j += f) {\r\n                        hp.set(r, (q + j) * 3);\r\n                    }\r\n\r\n                    // backwards increment the k-bit code i\r\n                    for (j = 1 << (k - 1); (i & j) !== 0; j >>>= 1) {\r\n                        i ^= j;\r\n                    }\r\n                    i ^= j;\r\n\r\n                    // backup over finished tables\r\n                    mask = (1 << w) - 1; // needed on HP, cc -O bug\r\n                    while ((i & mask) != x[h]) {\r\n                        h--; // don't need to update q\r\n                        w -= l;\r\n                        mask = (1 << w) - 1;\r\n                    }\r\n                }\r\n            }\r\n            // Return Z_BUF_ERROR if we were given an incomplete table\r\n            return y !== 0 && g != 1 ? Z_BUF_ERROR : Z_OK;\r\n        }\r\n\r\n        function initWorkArea(vsize) {\r\n            var i;\r\n            if (!hn) {\r\n                hn = []; // []; //new Array(1);\r\n                v = []; // new Array(vsize);\r\n                c = new Int32Array(BMAX + 1); // new Array(BMAX + 1);\r\n                r = []; // new Array(3);\r\n                u = new Int32Array(BMAX); // new Array(BMAX);\r\n                x = new Int32Array(BMAX + 1); // new Array(BMAX + 1);\r\n            }\r\n            if (v.length < vsize) {\r\n                v = []; // new Array(vsize);\r\n            }\r\n            for (i = 0; i < vsize; i++) {\r\n                v[i] = 0;\r\n            }\r\n            for (i = 0; i < BMAX + 1; i++) {\r\n                c[i] = 0;\r\n            }\r\n            for (i = 0; i < 3; i++) {\r\n                r[i] = 0;\r\n            }\r\n            // for(int i=0; i<BMAX; i++){u[i]=0;}\r\n            u.set(c.subarray(0, BMAX), 0);\r\n            // for(int i=0; i<BMAX+1; i++){x[i]=0;}\r\n            x.set(c.subarray(0, BMAX + 1), 0);\r\n        }\r\n\r\n        that.inflate_trees_bits = function(c, // 19 code lengths\r\n        bb, // bits tree desired/actual depth\r\n        tb, // bits tree result\r\n        hp, // space for trees\r\n        z // for messages\r\n        ) {\r\n            var result;\r\n            initWorkArea(19);\r\n            hn[0] = 0;\r\n            result = huft_build(c, 0, 19, 19, null, null, tb, bb, hp, hn, v);\r\n\r\n            if (result == Z_DATA_ERROR) {\r\n                z.msg = \"oversubscribed dynamic bit lengths tree\";\r\n            } else if (result == Z_BUF_ERROR || bb[0] === 0) {\r\n                z.msg = \"incomplete dynamic bit lengths tree\";\r\n                result = Z_DATA_ERROR;\r\n            }\r\n            return result;\r\n        };\r\n\r\n        that.inflate_trees_dynamic = function(nl, // number of literal/length codes\r\n        nd, // number of distance codes\r\n        c, // that many (total) code lengths\r\n        bl, // literal desired/actual bit depth\r\n        bd, // distance desired/actual bit depth\r\n        tl, // literal/length tree result\r\n        td, // distance tree result\r\n        hp, // space for trees\r\n        z // for messages\r\n        ) {\r\n            var result;\r\n\r\n            // build literal/length tree\r\n            initWorkArea(288);\r\n            hn[0] = 0;\r\n            result = huft_build(c, 0, nl, 257, cplens, cplext, tl, bl, hp, hn, v);\r\n            if (result != Z_OK || bl[0] === 0) {\r\n                if (result == Z_DATA_ERROR) {\r\n                    z.msg = \"oversubscribed literal/length tree\";\r\n                } else if (result != Z_MEM_ERROR) {\r\n                    z.msg = \"incomplete literal/length tree\";\r\n                    result = Z_DATA_ERROR;\r\n                }\r\n                return result;\r\n            }\r\n\r\n            // build distance tree\r\n            initWorkArea(288);\r\n            result = huft_build(c, nl, nd, 0, cpdist, cpdext, td, bd, hp, hn, v);\r\n\r\n            if (result != Z_OK || (bd[0] === 0 && nl > 257)) {\r\n                if (result == Z_DATA_ERROR) {\r\n                    z.msg = \"oversubscribed distance tree\";\r\n                } else if (result == Z_BUF_ERROR) {\r\n                    z.msg = \"incomplete distance tree\";\r\n                    result = Z_DATA_ERROR;\r\n                } else if (result != Z_MEM_ERROR) {\r\n                    z.msg = \"empty distance tree with lengths\";\r\n                    result = Z_DATA_ERROR;\r\n                }\r\n                return result;\r\n            }\r\n\r\n            return Z_OK;\r\n        };\r\n\r\n    }\r\n\r\n    InfTree.inflate_trees_fixed = function(bl, // literal desired/actual bit depth\r\n    bd, // distance desired/actual bit depth\r\n    tl,// literal/length tree result\r\n    td// distance tree result\r\n    ) {\r\n        bl[0] = fixed_bl;\r\n        bd[0] = fixed_bd;\r\n        tl[0] = fixed_tl;\r\n        td[0] = fixed_td;\r\n        return Z_OK;\r\n    };\r\n\r\n    // InfCodes\r\n\r\n    // waiting for \"i:\"=input,\r\n    // \"o:\"=output,\r\n    // \"x:\"=nothing\r\n    var START = 0; // x: set up for LEN\r\n    var LEN = 1; // i: get length/literal/eob next\r\n    var LENEXT = 2; // i: getting length extra (have base)\r\n    var DIST = 3; // i: get distance next\r\n    var DISTEXT = 4;// i: getting distance extra\r\n    var COPY = 5; // o: copying bytes in window, waiting\r\n    // for space\r\n    var LIT = 6; // o: got literal, waiting for output\r\n    // space\r\n    var WASH = 7; // o: got eob, possibly still output\r\n    // waiting\r\n    var END = 8; // x: got eob and all data flushed\r\n    var BADCODE = 9;// x: got error\r\n\r\n    function InfCodes() {\r\n        var that = this;\r\n\r\n        var mode; // current inflate_codes mode\r\n\r\n        // mode dependent information\r\n        var len = 0;\r\n\r\n        var tree; // pointer into tree\r\n        var tree_index = 0;\r\n        var need = 0; // bits needed\r\n\r\n        var lit = 0;\r\n\r\n        // if EXT or COPY, where and how much\r\n        var get = 0; // bits to get for extra\r\n        var dist = 0; // distance back to copy from\r\n\r\n        var lbits = 0; // ltree bits decoded per branch\r\n        var dbits = 0; // dtree bits decoder per branch\r\n        var ltree; // literal/length/eob tree\r\n        var ltree_index = 0; // literal/length/eob tree\r\n        var dtree; // distance tree\r\n        var dtree_index = 0; // distance tree\r\n\r\n        // Called with number of bytes left to write in window at least 258\r\n        // (the maximum string length) and number of input bytes available\r\n        // at least ten. The ten bytes are six bytes for the longest length/\r\n        // distance pair plus four bytes for overloading the bit buffer.\r\n\r\n        function inflate_fast(bl, bd, tl, tl_index, td, td_index, s, z) {\r\n            var t; // temporary pointer\r\n            var tp; // temporary pointer\r\n            var tp_index; // temporary pointer\r\n            var e; // extra bits or operation\r\n            var b; // bit buffer\r\n            var k; // bits in bit buffer\r\n            var p; // input data pointer\r\n            var n; // bytes available there\r\n            var q; // output window write pointer\r\n            var m; // bytes to end of window or read pointer\r\n            var ml; // mask for literal/length tree\r\n            var md; // mask for distance tree\r\n            var c; // bytes to copy\r\n            var d; // distance back to copy from\r\n            var r; // copy source pointer\r\n\r\n            var tp_index_t_3; // (tp_index+t)*3\r\n\r\n            // load input, output, bit values\r\n            p = z.next_in_index;\r\n            n = z.avail_in;\r\n            b = s.bitb;\r\n            k = s.bitk;\r\n            q = s.write;\r\n            m = q < s.read ? s.read - q - 1 : s.end - q;\r\n\r\n            // initialize masks\r\n            ml = inflate_mask[bl];\r\n            md = inflate_mask[bd];\r\n\r\n            // do until not enough input or output space for fast loop\r\n            do { // assume called with m >= 258 && n >= 10\r\n                // get literal/length code\r\n                while (k < (20)) { // max bits for literal/length code\r\n                    n--;\r\n                    b |= (z.read_byte(p++) & 0xff) << k;\r\n                    k += 8;\r\n                }\r\n\r\n                t = b & ml;\r\n                tp = tl;\r\n                tp_index = tl_index;\r\n                tp_index_t_3 = (tp_index + t) * 3;\r\n                if ((e = tp[tp_index_t_3]) === 0) {\r\n                    b >>= (tp[tp_index_t_3 + 1]);\r\n                    k -= (tp[tp_index_t_3 + 1]);\r\n\r\n                    s.window[q++] = /* (byte) */tp[tp_index_t_3 + 2];\r\n                    m--;\r\n                    continue;\r\n                }\r\n                do {\r\n\r\n                    b >>= (tp[tp_index_t_3 + 1]);\r\n                    k -= (tp[tp_index_t_3 + 1]);\r\n\r\n                    if ((e & 16) !== 0) {\r\n                        e &= 15;\r\n                        c = tp[tp_index_t_3 + 2] + (/* (int) */b & inflate_mask[e]);\r\n\r\n                        b >>= e;\r\n                        k -= e;\r\n\r\n                        // decode distance base of block to copy\r\n                        while (k < (15)) { // max bits for distance code\r\n                            n--;\r\n                            b |= (z.read_byte(p++) & 0xff) << k;\r\n                            k += 8;\r\n                        }\r\n\r\n                        t = b & md;\r\n                        tp = td;\r\n                        tp_index = td_index;\r\n                        tp_index_t_3 = (tp_index + t) * 3;\r\n                        e = tp[tp_index_t_3];\r\n\r\n                        do {\r\n\r\n                            b >>= (tp[tp_index_t_3 + 1]);\r\n                            k -= (tp[tp_index_t_3 + 1]);\r\n\r\n                            if ((e & 16) !== 0) {\r\n                                // get extra bits to add to distance base\r\n                                e &= 15;\r\n                                while (k < (e)) { // get extra bits (up to 13)\r\n                                    n--;\r\n                                    b |= (z.read_byte(p++) & 0xff) << k;\r\n                                    k += 8;\r\n                                }\r\n\r\n                                d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);\r\n\r\n                                b >>= (e);\r\n                                k -= (e);\r\n\r\n                                // do the copy\r\n                                m -= c;\r\n                                if (q >= d) { // offset before dest\r\n                                    // just copy\r\n                                    r = q - d;\r\n                                    if (q - r > 0 && 2 > (q - r)) {\r\n                                        s.window[q++] = s.window[r++]; // minimum\r\n                                        // count is\r\n                                        // three,\r\n                                        s.window[q++] = s.window[r++]; // so unroll\r\n                                        // loop a\r\n                                        // little\r\n                                        c -= 2;\r\n                                    } else {\r\n                                        s.window.set(s.window.subarray(r, r + 2), q);\r\n                                        q += 2;\r\n                                        r += 2;\r\n                                        c -= 2;\r\n                                    }\r\n                                } else { // else offset after destination\r\n                                    r = q - d;\r\n                                    do {\r\n                                        r += s.end; // force pointer in window\r\n                                    } while (r < 0); // covers invalid distances\r\n                                    e = s.end - r;\r\n                                    if (c > e) { // if source crosses,\r\n                                        c -= e; // wrapped copy\r\n                                        if (q - r > 0 && e > (q - r)) {\r\n                                            do {\r\n                                                s.window[q++] = s.window[r++];\r\n                                            } while (--e !== 0);\r\n                                        } else {\r\n                                            s.window.set(s.window.subarray(r, r + e), q);\r\n                                            q += e;\r\n                                            r += e;\r\n                                            e = 0;\r\n                                        }\r\n                                        r = 0; // copy rest from start of window\r\n                                    }\r\n\r\n                                }\r\n\r\n                                // copy all or what's left\r\n                                if (q - r > 0 && c > (q - r)) {\r\n                                    do {\r\n                                        s.window[q++] = s.window[r++];\r\n                                    } while (--c !== 0);\r\n                                } else {\r\n                                    s.window.set(s.window.subarray(r, r + c), q);\r\n                                    q += c;\r\n                                    r += c;\r\n                                    c = 0;\r\n                                }\r\n                                break;\r\n                            } else if ((e & 64) === 0) {\r\n                                t += tp[tp_index_t_3 + 2];\r\n                                t += (b & inflate_mask[e]);\r\n                                tp_index_t_3 = (tp_index + t) * 3;\r\n                                e = tp[tp_index_t_3];\r\n                            } else {\r\n                                z.msg = \"invalid distance code\";\r\n\r\n                                c = z.avail_in - n;\r\n                                c = (k >> 3) < c ? k >> 3 : c;\r\n                                n += c;\r\n                                p -= c;\r\n                                k -= c << 3;\r\n\r\n                                s.bitb = b;\r\n                                s.bitk = k;\r\n                                z.avail_in = n;\r\n                                z.total_in += p - z.next_in_index;\r\n                                z.next_in_index = p;\r\n                                s.write = q;\r\n\r\n                                return Z_DATA_ERROR;\r\n                            }\r\n                        } while (true);\r\n                        break;\r\n                    }\r\n\r\n                    if ((e & 64) === 0) {\r\n                        t += tp[tp_index_t_3 + 2];\r\n                        t += (b & inflate_mask[e]);\r\n                        tp_index_t_3 = (tp_index + t) * 3;\r\n                        if ((e = tp[tp_index_t_3]) === 0) {\r\n\r\n                            b >>= (tp[tp_index_t_3 + 1]);\r\n                            k -= (tp[tp_index_t_3 + 1]);\r\n\r\n                            s.window[q++] = /* (byte) */tp[tp_index_t_3 + 2];\r\n                            m--;\r\n                            break;\r\n                        }\r\n                    } else if ((e & 32) !== 0) {\r\n\r\n                        c = z.avail_in - n;\r\n                        c = (k >> 3) < c ? k >> 3 : c;\r\n                        n += c;\r\n                        p -= c;\r\n                        k -= c << 3;\r\n\r\n                        s.bitb = b;\r\n                        s.bitk = k;\r\n                        z.avail_in = n;\r\n                        z.total_in += p - z.next_in_index;\r\n                        z.next_in_index = p;\r\n                        s.write = q;\r\n\r\n                        return Z_STREAM_END;\r\n                    } else {\r\n                        z.msg = \"invalid literal/length code\";\r\n\r\n                        c = z.avail_in - n;\r\n                        c = (k >> 3) < c ? k >> 3 : c;\r\n                        n += c;\r\n                        p -= c;\r\n                        k -= c << 3;\r\n\r\n                        s.bitb = b;\r\n                        s.bitk = k;\r\n                        z.avail_in = n;\r\n                        z.total_in += p - z.next_in_index;\r\n                        z.next_in_index = p;\r\n                        s.write = q;\r\n\r\n                        return Z_DATA_ERROR;\r\n                    }\r\n                } while (true);\r\n            } while (m >= 258 && n >= 10);\r\n\r\n            // not enough input or output--restore pointers and return\r\n            c = z.avail_in - n;\r\n            c = (k >> 3) < c ? k >> 3 : c;\r\n            n += c;\r\n            p -= c;\r\n            k -= c << 3;\r\n\r\n            s.bitb = b;\r\n            s.bitk = k;\r\n            z.avail_in = n;\r\n            z.total_in += p - z.next_in_index;\r\n            z.next_in_index = p;\r\n            s.write = q;\r\n\r\n            return Z_OK;\r\n        }\r\n\r\n        that.init = function(bl, bd, tl, tl_index, td, td_index) {\r\n            mode = START;\r\n            lbits = /* (byte) */bl;\r\n            dbits = /* (byte) */bd;\r\n            ltree = tl;\r\n            ltree_index = tl_index;\r\n            dtree = td;\r\n            dtree_index = td_index;\r\n            tree = null;\r\n        };\r\n\r\n        that.proc = function(s, z, r) {\r\n            var j; // temporary storage\r\n            var tindex; // temporary pointer\r\n            var e; // extra bits or operation\r\n            var b = 0; // bit buffer\r\n            var k = 0; // bits in bit buffer\r\n            var p = 0; // input data pointer\r\n            var n; // bytes available there\r\n            var q; // output window write pointer\r\n            var m; // bytes to end of window or read pointer\r\n            var f; // pointer to copy strings from\r\n\r\n            // copy input/output information to locals (UPDATE macro restores)\r\n            p = z.next_in_index;\r\n            n = z.avail_in;\r\n            b = s.bitb;\r\n            k = s.bitk;\r\n            q = s.write;\r\n            m = q < s.read ? s.read - q - 1 : s.end - q;\r\n\r\n            // process input and output based on current state\r\n            while (true) {\r\n                switch (mode) {\r\n                // waiting for \"i:\"=input, \"o:\"=output, \"x:\"=nothing\r\n                case START: // x: set up for LEN\r\n                    if (m >= 258 && n >= 10) {\r\n\r\n                        s.bitb = b;\r\n                        s.bitk = k;\r\n                        z.avail_in = n;\r\n                        z.total_in += p - z.next_in_index;\r\n                        z.next_in_index = p;\r\n                        s.write = q;\r\n                        r = inflate_fast(lbits, dbits, ltree, ltree_index, dtree, dtree_index, s, z);\r\n\r\n                        p = z.next_in_index;\r\n                        n = z.avail_in;\r\n                        b = s.bitb;\r\n                        k = s.bitk;\r\n                        q = s.write;\r\n                        m = q < s.read ? s.read - q - 1 : s.end - q;\r\n\r\n                        if (r != Z_OK) {\r\n                            mode = r == Z_STREAM_END ? WASH : BADCODE;\r\n                            break;\r\n                        }\r\n                    }\r\n                    need = lbits;\r\n                    tree = ltree;\r\n                    tree_index = ltree_index;\r\n\r\n                    mode = LEN;\r\n                    /* falls through */\r\n                case LEN: // i: get length/literal/eob next\r\n                    j = need;\r\n\r\n                    while (k < (j)) {\r\n                        if (n !== 0)\r\n                            r = Z_OK;\r\n                        else {\r\n\r\n                            s.bitb = b;\r\n                            s.bitk = k;\r\n                            z.avail_in = n;\r\n                            z.total_in += p - z.next_in_index;\r\n                            z.next_in_index = p;\r\n                            s.write = q;\r\n                            return s.inflate_flush(z, r);\r\n                        }\r\n                        n--;\r\n                        b |= (z.read_byte(p++) & 0xff) << k;\r\n                        k += 8;\r\n                    }\r\n\r\n                    tindex = (tree_index + (b & inflate_mask[j])) * 3;\r\n\r\n                    b >>>= (tree[tindex + 1]);\r\n                    k -= (tree[tindex + 1]);\r\n\r\n                    e = tree[tindex];\r\n\r\n                    if (e === 0) { // literal\r\n                        lit = tree[tindex + 2];\r\n                        mode = LIT;\r\n                        break;\r\n                    }\r\n                    if ((e & 16) !== 0) { // length\r\n                        get = e & 15;\r\n                        len = tree[tindex + 2];\r\n                        mode = LENEXT;\r\n                        break;\r\n                    }\r\n                    if ((e & 64) === 0) { // next table\r\n                        need = e;\r\n                        tree_index = tindex / 3 + tree[tindex + 2];\r\n                        break;\r\n                    }\r\n                    if ((e & 32) !== 0) { // end of block\r\n                        mode = WASH;\r\n                        break;\r\n                    }\r\n                    mode = BADCODE; // invalid code\r\n                    z.msg = \"invalid literal/length code\";\r\n                    r = Z_DATA_ERROR;\r\n\r\n                    s.bitb = b;\r\n                    s.bitk = k;\r\n                    z.avail_in = n;\r\n                    z.total_in += p - z.next_in_index;\r\n                    z.next_in_index = p;\r\n                    s.write = q;\r\n                    return s.inflate_flush(z, r);\r\n\r\n                case LENEXT: // i: getting length extra (have base)\r\n                    j = get;\r\n\r\n                    while (k < (j)) {\r\n                        if (n !== 0)\r\n                            r = Z_OK;\r\n                        else {\r\n\r\n                            s.bitb = b;\r\n                            s.bitk = k;\r\n                            z.avail_in = n;\r\n                            z.total_in += p - z.next_in_index;\r\n                            z.next_in_index = p;\r\n                            s.write = q;\r\n                            return s.inflate_flush(z, r);\r\n                        }\r\n                        n--;\r\n                        b |= (z.read_byte(p++) & 0xff) << k;\r\n                        k += 8;\r\n                    }\r\n\r\n                    len += (b & inflate_mask[j]);\r\n\r\n                    b >>= j;\r\n                    k -= j;\r\n\r\n                    need = dbits;\r\n                    tree = dtree;\r\n                    tree_index = dtree_index;\r\n                    mode = DIST;\r\n                    /* falls through */\r\n                case DIST: // i: get distance next\r\n                    j = need;\r\n\r\n                    while (k < (j)) {\r\n                        if (n !== 0)\r\n                            r = Z_OK;\r\n                        else {\r\n\r\n                            s.bitb = b;\r\n                            s.bitk = k;\r\n                            z.avail_in = n;\r\n                            z.total_in += p - z.next_in_index;\r\n                            z.next_in_index = p;\r\n                            s.write = q;\r\n                            return s.inflate_flush(z, r);\r\n                        }\r\n                        n--;\r\n                        b |= (z.read_byte(p++) & 0xff) << k;\r\n                        k += 8;\r\n                    }\r\n\r\n                    tindex = (tree_index + (b & inflate_mask[j])) * 3;\r\n\r\n                    b >>= tree[tindex + 1];\r\n                    k -= tree[tindex + 1];\r\n\r\n                    e = (tree[tindex]);\r\n                    if ((e & 16) !== 0) { // distance\r\n                        get = e & 15;\r\n                        dist = tree[tindex + 2];\r\n                        mode = DISTEXT;\r\n                        break;\r\n                    }\r\n                    if ((e & 64) === 0) { // next table\r\n                        need = e;\r\n                        tree_index = tindex / 3 + tree[tindex + 2];\r\n                        break;\r\n                    }\r\n                    mode = BADCODE; // invalid code\r\n                    z.msg = \"invalid distance code\";\r\n                    r = Z_DATA_ERROR;\r\n\r\n                    s.bitb = b;\r\n                    s.bitk = k;\r\n                    z.avail_in = n;\r\n                    z.total_in += p - z.next_in_index;\r\n                    z.next_in_index = p;\r\n                    s.write = q;\r\n                    return s.inflate_flush(z, r);\r\n\r\n                case DISTEXT: // i: getting distance extra\r\n                    j = get;\r\n\r\n                    while (k < (j)) {\r\n                        if (n !== 0)\r\n                            r = Z_OK;\r\n                        else {\r\n\r\n                            s.bitb = b;\r\n                            s.bitk = k;\r\n                            z.avail_in = n;\r\n                            z.total_in += p - z.next_in_index;\r\n                            z.next_in_index = p;\r\n                            s.write = q;\r\n                            return s.inflate_flush(z, r);\r\n                        }\r\n                        n--;\r\n                        b |= (z.read_byte(p++) & 0xff) << k;\r\n                        k += 8;\r\n                    }\r\n\r\n                    dist += (b & inflate_mask[j]);\r\n\r\n                    b >>= j;\r\n                    k -= j;\r\n\r\n                    mode = COPY;\r\n                    /* falls through */\r\n                case COPY: // o: copying bytes in window, waiting for space\r\n                    f = q - dist;\r\n                    while (f < 0) { // modulo window size-\"while\" instead\r\n                        f += s.end; // of \"if\" handles invalid distances\r\n                    }\r\n                    while (len !== 0) {\r\n\r\n                        if (m === 0) {\r\n                            if (q == s.end && s.read !== 0) {\r\n                                q = 0;\r\n                                m = q < s.read ? s.read - q - 1 : s.end - q;\r\n                            }\r\n                            if (m === 0) {\r\n                                s.write = q;\r\n                                r = s.inflate_flush(z, r);\r\n                                q = s.write;\r\n                                m = q < s.read ? s.read - q - 1 : s.end - q;\r\n\r\n                                if (q == s.end && s.read !== 0) {\r\n                                    q = 0;\r\n                                    m = q < s.read ? s.read - q - 1 : s.end - q;\r\n                                }\r\n\r\n                                if (m === 0) {\r\n                                    s.bitb = b;\r\n                                    s.bitk = k;\r\n                                    z.avail_in = n;\r\n                                    z.total_in += p - z.next_in_index;\r\n                                    z.next_in_index = p;\r\n                                    s.write = q;\r\n                                    return s.inflate_flush(z, r);\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        s.window[q++] = s.window[f++];\r\n                        m--;\r\n\r\n                        if (f == s.end)\r\n                            f = 0;\r\n                        len--;\r\n                    }\r\n                    mode = START;\r\n                    break;\r\n                case LIT: // o: got literal, waiting for output space\r\n                    if (m === 0) {\r\n                        if (q == s.end && s.read !== 0) {\r\n                            q = 0;\r\n                            m = q < s.read ? s.read - q - 1 : s.end - q;\r\n                        }\r\n                        if (m === 0) {\r\n                            s.write = q;\r\n                            r = s.inflate_flush(z, r);\r\n                            q = s.write;\r\n                            m = q < s.read ? s.read - q - 1 : s.end - q;\r\n\r\n                            if (q == s.end && s.read !== 0) {\r\n                                q = 0;\r\n                                m = q < s.read ? s.read - q - 1 : s.end - q;\r\n                            }\r\n                            if (m === 0) {\r\n                                s.bitb = b;\r\n                                s.bitk = k;\r\n                                z.avail_in = n;\r\n                                z.total_in += p - z.next_in_index;\r\n                                z.next_in_index = p;\r\n                                s.write = q;\r\n                                return s.inflate_flush(z, r);\r\n                            }\r\n                        }\r\n                    }\r\n                    r = Z_OK;\r\n\r\n                    s.window[q++] = /* (byte) */lit;\r\n                    m--;\r\n\r\n                    mode = START;\r\n                    break;\r\n                case WASH: // o: got eob, possibly more output\r\n                    if (k > 7) { // return unused byte, if any\r\n                        k -= 8;\r\n                        n++;\r\n                        p--; // can always return one\r\n                    }\r\n\r\n                    s.write = q;\r\n                    r = s.inflate_flush(z, r);\r\n                    q = s.write;\r\n                    m = q < s.read ? s.read - q - 1 : s.end - q;\r\n\r\n                    if (s.read != s.write) {\r\n                        s.bitb = b;\r\n                        s.bitk = k;\r\n                        z.avail_in = n;\r\n                        z.total_in += p - z.next_in_index;\r\n                        z.next_in_index = p;\r\n                        s.write = q;\r\n                        return s.inflate_flush(z, r);\r\n                    }\r\n                    mode = END;\r\n                    /* falls through */\r\n                case END:\r\n                    r = Z_STREAM_END;\r\n                    s.bitb = b;\r\n                    s.bitk = k;\r\n                    z.avail_in = n;\r\n                    z.total_in += p - z.next_in_index;\r\n                    z.next_in_index = p;\r\n                    s.write = q;\r\n                    return s.inflate_flush(z, r);\r\n\r\n                case BADCODE: // x: got error\r\n\r\n                    r = Z_DATA_ERROR;\r\n\r\n                    s.bitb = b;\r\n                    s.bitk = k;\r\n                    z.avail_in = n;\r\n                    z.total_in += p - z.next_in_index;\r\n                    z.next_in_index = p;\r\n                    s.write = q;\r\n                    return s.inflate_flush(z, r);\r\n\r\n                default:\r\n                    r = Z_STREAM_ERROR;\r\n\r\n                    s.bitb = b;\r\n                    s.bitk = k;\r\n                    z.avail_in = n;\r\n                    z.total_in += p - z.next_in_index;\r\n                    z.next_in_index = p;\r\n                    s.write = q;\r\n                    return s.inflate_flush(z, r);\r\n                }\r\n            }\r\n        };\r\n\r\n        that.free = function() {\r\n            // ZFREE(z, c);\r\n        };\r\n\r\n    }\r\n\r\n    // InfBlocks\r\n\r\n    // Table for deflate from PKZIP's appnote.txt.\r\n    var border = [ // Order of the bit length code lengths\r\n    16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];\r\n\r\n    var TYPE = 0; // get type bits (3, including end bit)\r\n    var LENS = 1; // get lengths for stored\r\n    var STORED = 2;// processing stored block\r\n    var TABLE = 3; // get table lengths\r\n    var BTREE = 4; // get bit lengths tree for a dynamic\r\n    // block\r\n    var DTREE = 5; // get length, distance trees for a\r\n    // dynamic block\r\n    var CODES = 6; // processing fixed or dynamic block\r\n    var DRY = 7; // output remaining window bytes\r\n    var DONELOCKS = 8; // finished last block, done\r\n    var BADBLOCKS = 9; // ot a data error--stuck here\r\n\r\n    function InfBlocks(z, w) {\r\n        var that = this;\r\n\r\n        var mode = TYPE; // current inflate_block mode\r\n\r\n        var left = 0; // if STORED, bytes left to copy\r\n\r\n        var table = 0; // table lengths (14 bits)\r\n        var index = 0; // index into blens (or border)\r\n        var blens; // bit lengths of codes\r\n        var bb = [ 0 ]; // bit length tree depth\r\n        var tb = [ 0 ]; // bit length decoding tree\r\n\r\n        var codes = new InfCodes(); // if CODES, current state\r\n\r\n        var last = 0; // true if this block is the last block\r\n\r\n        var hufts = new Int32Array(MANY * 3); // single malloc for tree space\r\n        var check = 0; // check on output\r\n        var inftree = new InfTree();\r\n\r\n        that.bitk = 0; // bits in bit buffer\r\n        that.bitb = 0; // bit buffer\r\n        that.window = new Uint8Array(w); // sliding window\r\n        that.end = w; // one byte after sliding window\r\n        that.read = 0; // window read pointer\r\n        that.write = 0; // window write pointer\r\n\r\n        that.reset = function(z, c) {\r\n            if (c)\r\n                c[0] = check;\r\n            // if (mode == BTREE || mode == DTREE) {\r\n            // }\r\n            if (mode == CODES) {\r\n                codes.free(z);\r\n            }\r\n            mode = TYPE;\r\n            that.bitk = 0;\r\n            that.bitb = 0;\r\n            that.read = that.write = 0;\r\n        };\r\n\r\n        that.reset(z, null);\r\n\r\n        // copy as much as possible from the sliding window to the output area\r\n        that.inflate_flush = function(z, r) {\r\n            var n;\r\n            var p;\r\n            var q;\r\n\r\n            // local copies of source and destination pointers\r\n            p = z.next_out_index;\r\n            q = that.read;\r\n\r\n            // compute number of bytes to copy as far as end of window\r\n            n = /* (int) */((q <= that.write ? that.write : that.end) - q);\r\n            if (n > z.avail_out)\r\n                n = z.avail_out;\r\n            if (n !== 0 && r == Z_BUF_ERROR)\r\n                r = Z_OK;\r\n\r\n            // update counters\r\n            z.avail_out -= n;\r\n            z.total_out += n;\r\n\r\n            // copy as far as end of window\r\n            z.next_out.set(that.window.subarray(q, q + n), p);\r\n            p += n;\r\n            q += n;\r\n\r\n            // see if more to copy at beginning of window\r\n            if (q == that.end) {\r\n                // wrap pointers\r\n                q = 0;\r\n                if (that.write == that.end)\r\n                    that.write = 0;\r\n\r\n                // compute bytes to copy\r\n                n = that.write - q;\r\n                if (n > z.avail_out)\r\n                    n = z.avail_out;\r\n                if (n !== 0 && r == Z_BUF_ERROR)\r\n                    r = Z_OK;\r\n\r\n                // update counters\r\n                z.avail_out -= n;\r\n                z.total_out += n;\r\n\r\n                // copy\r\n                z.next_out.set(that.window.subarray(q, q + n), p);\r\n                p += n;\r\n                q += n;\r\n            }\r\n\r\n            // update pointers\r\n            z.next_out_index = p;\r\n            that.read = q;\r\n\r\n            // done\r\n            return r;\r\n        };\r\n\r\n        that.proc = function(z, r) {\r\n            var t; // temporary storage\r\n            var b; // bit buffer\r\n            var k; // bits in bit buffer\r\n            var p; // input data pointer\r\n            var n; // bytes available there\r\n            var q; // output window write pointer\r\n            var m; // bytes to end of window or read pointer\r\n\r\n            var i;\r\n\r\n            // copy input/output information to locals (UPDATE macro restores)\r\n            // {\r\n            p = z.next_in_index;\r\n            n = z.avail_in;\r\n            b = that.bitb;\r\n            k = that.bitk;\r\n            // }\r\n            // {\r\n            q = that.write;\r\n            m = /* (int) */(q < that.read ? that.read - q - 1 : that.end - q);\r\n            // }\r\n\r\n            // process input based on current state\r\n            // DEBUG dtree\r\n            while (true) {\r\n                switch (mode) {\r\n                case TYPE:\r\n\r\n                    while (k < (3)) {\r\n                        if (n !== 0) {\r\n                            r = Z_OK;\r\n                        } else {\r\n                            that.bitb = b;\r\n                            that.bitk = k;\r\n                            z.avail_in = n;\r\n                            z.total_in += p - z.next_in_index;\r\n                            z.next_in_index = p;\r\n                            that.write = q;\r\n                            return that.inflate_flush(z, r);\r\n                        }\r\n                        n--;\r\n                        b |= (z.read_byte(p++) & 0xff) << k;\r\n                        k += 8;\r\n                    }\r\n                    t = /* (int) */(b & 7);\r\n                    last = t & 1;\r\n\r\n                    switch (t >>> 1) {\r\n                    case 0: // stored\r\n                        // {\r\n                        b >>>= (3);\r\n                        k -= (3);\r\n                        // }\r\n                        t = k & 7; // go to byte boundary\r\n\r\n                        // {\r\n                        b >>>= (t);\r\n                        k -= (t);\r\n                        // }\r\n                        mode = LENS; // get length of stored block\r\n                        break;\r\n                    case 1: // fixed\r\n                        // {\r\n                        var bl = []; // new Array(1);\r\n                        var bd = []; // new Array(1);\r\n                        var tl = [ [] ]; // new Array(1);\r\n                        var td = [ [] ]; // new Array(1);\r\n\r\n                        InfTree.inflate_trees_fixed(bl, bd, tl, td);\r\n                        codes.init(bl[0], bd[0], tl[0], 0, td[0], 0);\r\n                        // }\r\n\r\n                        // {\r\n                        b >>>= (3);\r\n                        k -= (3);\r\n                        // }\r\n\r\n                        mode = CODES;\r\n                        break;\r\n                    case 2: // dynamic\r\n\r\n                        // {\r\n                        b >>>= (3);\r\n                        k -= (3);\r\n                        // }\r\n\r\n                        mode = TABLE;\r\n                        break;\r\n                    case 3: // illegal\r\n\r\n                        // {\r\n                        b >>>= (3);\r\n                        k -= (3);\r\n                        // }\r\n                        mode = BADBLOCKS;\r\n                        z.msg = \"invalid block type\";\r\n                        r = Z_DATA_ERROR;\r\n\r\n                        that.bitb = b;\r\n                        that.bitk = k;\r\n                        z.avail_in = n;\r\n                        z.total_in += p - z.next_in_index;\r\n                        z.next_in_index = p;\r\n                        that.write = q;\r\n                        return that.inflate_flush(z, r);\r\n                    }\r\n                    break;\r\n                case LENS:\r\n\r\n                    while (k < (32)) {\r\n                        if (n !== 0) {\r\n                            r = Z_OK;\r\n                        } else {\r\n                            that.bitb = b;\r\n                            that.bitk = k;\r\n                            z.avail_in = n;\r\n                            z.total_in += p - z.next_in_index;\r\n                            z.next_in_index = p;\r\n                            that.write = q;\r\n                            return that.inflate_flush(z, r);\r\n                        }\r\n                        n--;\r\n                        b |= (z.read_byte(p++) & 0xff) << k;\r\n                        k += 8;\r\n                    }\r\n\r\n                    if ((((~b) >>> 16) & 0xffff) != (b & 0xffff)) {\r\n                        mode = BADBLOCKS;\r\n                        z.msg = \"invalid stored block lengths\";\r\n                        r = Z_DATA_ERROR;\r\n\r\n                        that.bitb = b;\r\n                        that.bitk = k;\r\n                        z.avail_in = n;\r\n                        z.total_in += p - z.next_in_index;\r\n                        z.next_in_index = p;\r\n                        that.write = q;\r\n                        return that.inflate_flush(z, r);\r\n                    }\r\n                    left = (b & 0xffff);\r\n                    b = k = 0; // dump bits\r\n                    mode = left !== 0 ? STORED : (last !== 0 ? DRY : TYPE);\r\n                    break;\r\n                case STORED:\r\n                    if (n === 0) {\r\n                        that.bitb = b;\r\n                        that.bitk = k;\r\n                        z.avail_in = n;\r\n                        z.total_in += p - z.next_in_index;\r\n                        z.next_in_index = p;\r\n                        that.write = q;\r\n                        return that.inflate_flush(z, r);\r\n                    }\r\n\r\n                    if (m === 0) {\r\n                        if (q == that.end && that.read !== 0) {\r\n                            q = 0;\r\n                            m = /* (int) */(q < that.read ? that.read - q - 1 : that.end - q);\r\n                        }\r\n                        if (m === 0) {\r\n                            that.write = q;\r\n                            r = that.inflate_flush(z, r);\r\n                            q = that.write;\r\n                            m = /* (int) */(q < that.read ? that.read - q - 1 : that.end - q);\r\n                            if (q == that.end && that.read !== 0) {\r\n                                q = 0;\r\n                                m = /* (int) */(q < that.read ? that.read - q - 1 : that.end - q);\r\n                            }\r\n                            if (m === 0) {\r\n                                that.bitb = b;\r\n                                that.bitk = k;\r\n                                z.avail_in = n;\r\n                                z.total_in += p - z.next_in_index;\r\n                                z.next_in_index = p;\r\n                                that.write = q;\r\n                                return that.inflate_flush(z, r);\r\n                            }\r\n                        }\r\n                    }\r\n                    r = Z_OK;\r\n\r\n                    t = left;\r\n                    if (t > n)\r\n                        t = n;\r\n                    if (t > m)\r\n                        t = m;\r\n                    that.window.set(z.read_buf(p, t), q);\r\n                    p += t;\r\n                    n -= t;\r\n                    q += t;\r\n                    m -= t;\r\n                    if ((left -= t) !== 0)\r\n                        break;\r\n                    mode = last !== 0 ? DRY : TYPE;\r\n                    break;\r\n                case TABLE:\r\n\r\n                    while (k < (14)) {\r\n                        if (n !== 0) {\r\n                            r = Z_OK;\r\n                        } else {\r\n                            that.bitb = b;\r\n                            that.bitk = k;\r\n                            z.avail_in = n;\r\n                            z.total_in += p - z.next_in_index;\r\n                            z.next_in_index = p;\r\n                            that.write = q;\r\n                            return that.inflate_flush(z, r);\r\n                        }\r\n\r\n                        n--;\r\n                        b |= (z.read_byte(p++) & 0xff) << k;\r\n                        k += 8;\r\n                    }\r\n\r\n                    table = t = (b & 0x3fff);\r\n                    if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {\r\n                        mode = BADBLOCKS;\r\n                        z.msg = \"too many length or distance symbols\";\r\n                        r = Z_DATA_ERROR;\r\n\r\n                        that.bitb = b;\r\n                        that.bitk = k;\r\n                        z.avail_in = n;\r\n                        z.total_in += p - z.next_in_index;\r\n                        z.next_in_index = p;\r\n                        that.write = q;\r\n                        return that.inflate_flush(z, r);\r\n                    }\r\n                    t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);\r\n                    if (!blens || blens.length < t) {\r\n                        blens = []; // new Array(t);\r\n                    } else {\r\n                        for (i = 0; i < t; i++) {\r\n                            blens[i] = 0;\r\n                        }\r\n                    }\r\n\r\n                    // {\r\n                    b >>>= (14);\r\n                    k -= (14);\r\n                    // }\r\n\r\n                    index = 0;\r\n                    mode = BTREE;\r\n                    /* falls through */\r\n                case BTREE:\r\n                    while (index < 4 + (table >>> 10)) {\r\n                        while (k < (3)) {\r\n                            if (n !== 0) {\r\n                                r = Z_OK;\r\n                            } else {\r\n                                that.bitb = b;\r\n                                that.bitk = k;\r\n                                z.avail_in = n;\r\n                                z.total_in += p - z.next_in_index;\r\n                                z.next_in_index = p;\r\n                                that.write = q;\r\n                                return that.inflate_flush(z, r);\r\n                            }\r\n                            n--;\r\n                            b |= (z.read_byte(p++) & 0xff) << k;\r\n                            k += 8;\r\n                        }\r\n\r\n                        blens[border[index++]] = b & 7;\r\n\r\n                        // {\r\n                        b >>>= (3);\r\n                        k -= (3);\r\n                        // }\r\n                    }\r\n\r\n                    while (index < 19) {\r\n                        blens[border[index++]] = 0;\r\n                    }\r\n\r\n                    bb[0] = 7;\r\n                    t = inftree.inflate_trees_bits(blens, bb, tb, hufts, z);\r\n                    if (t != Z_OK) {\r\n                        r = t;\r\n                        if (r == Z_DATA_ERROR) {\r\n                            blens = null;\r\n                            mode = BADBLOCKS;\r\n                        }\r\n\r\n                        that.bitb = b;\r\n                        that.bitk = k;\r\n                        z.avail_in = n;\r\n                        z.total_in += p - z.next_in_index;\r\n                        z.next_in_index = p;\r\n                        that.write = q;\r\n                        return that.inflate_flush(z, r);\r\n                    }\r\n\r\n                    index = 0;\r\n                    mode = DTREE;\r\n                    /* falls through */\r\n                case DTREE:\r\n                    while (true) {\r\n                        t = table;\r\n                        if (index >= 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {\r\n                            break;\r\n                        }\r\n\r\n                        var j, c;\r\n\r\n                        t = bb[0];\r\n\r\n                        while (k < (t)) {\r\n                            if (n !== 0) {\r\n                                r = Z_OK;\r\n                            } else {\r\n                                that.bitb = b;\r\n                                that.bitk = k;\r\n                                z.avail_in = n;\r\n                                z.total_in += p - z.next_in_index;\r\n                                z.next_in_index = p;\r\n                                that.write = q;\r\n                                return that.inflate_flush(z, r);\r\n                            }\r\n                            n--;\r\n                            b |= (z.read_byte(p++) & 0xff) << k;\r\n                            k += 8;\r\n                        }\r\n\r\n                        // if (tb[0] == -1) {\r\n                        // System.err.println(\"null...\");\r\n                        // }\r\n\r\n                        t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];\r\n                        c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];\r\n\r\n                        if (c < 16) {\r\n                            b >>>= (t);\r\n                            k -= (t);\r\n                            blens[index++] = c;\r\n                        } else { // c == 16..18\r\n                            i = c == 18 ? 7 : c - 14;\r\n                            j = c == 18 ? 11 : 3;\r\n\r\n                            while (k < (t + i)) {\r\n                                if (n !== 0) {\r\n                                    r = Z_OK;\r\n                                } else {\r\n                                    that.bitb = b;\r\n                                    that.bitk = k;\r\n                                    z.avail_in = n;\r\n                                    z.total_in += p - z.next_in_index;\r\n                                    z.next_in_index = p;\r\n                                    that.write = q;\r\n                                    return that.inflate_flush(z, r);\r\n                                }\r\n                                n--;\r\n                                b |= (z.read_byte(p++) & 0xff) << k;\r\n                                k += 8;\r\n                            }\r\n\r\n                            b >>>= (t);\r\n                            k -= (t);\r\n\r\n                            j += (b & inflate_mask[i]);\r\n\r\n                            b >>>= (i);\r\n                            k -= (i);\r\n\r\n                            i = index;\r\n                            t = table;\r\n                            if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {\r\n                                blens = null;\r\n                                mode = BADBLOCKS;\r\n                                z.msg = \"invalid bit length repeat\";\r\n                                r = Z_DATA_ERROR;\r\n\r\n                                that.bitb = b;\r\n                                that.bitk = k;\r\n                                z.avail_in = n;\r\n                                z.total_in += p - z.next_in_index;\r\n                                z.next_in_index = p;\r\n                                that.write = q;\r\n                                return that.inflate_flush(z, r);\r\n                            }\r\n\r\n                            c = c == 16 ? blens[i - 1] : 0;\r\n                            do {\r\n                                blens[i++] = c;\r\n                            } while (--j !== 0);\r\n                            index = i;\r\n                        }\r\n                    }\r\n\r\n                    tb[0] = -1;\r\n                    // {\r\n                    var bl_ = []; // new Array(1);\r\n                    var bd_ = []; // new Array(1);\r\n                    var tl_ = []; // new Array(1);\r\n                    var td_ = []; // new Array(1);\r\n                    bl_[0] = 9; // must be <= 9 for lookahead assumptions\r\n                    bd_[0] = 6; // must be <= 9 for lookahead assumptions\r\n\r\n                    t = table;\r\n                    t = inftree.inflate_trees_dynamic(257 + (t & 0x1f), 1 + ((t >> 5) & 0x1f), blens, bl_, bd_, tl_, td_, hufts, z);\r\n\r\n                    if (t != Z_OK) {\r\n                        if (t == Z_DATA_ERROR) {\r\n                            blens = null;\r\n                            mode = BADBLOCKS;\r\n                        }\r\n                        r = t;\r\n\r\n                        that.bitb = b;\r\n                        that.bitk = k;\r\n                        z.avail_in = n;\r\n                        z.total_in += p - z.next_in_index;\r\n                        z.next_in_index = p;\r\n                        that.write = q;\r\n                        return that.inflate_flush(z, r);\r\n                    }\r\n                    codes.init(bl_[0], bd_[0], hufts, tl_[0], hufts, td_[0]);\r\n                    // }\r\n                    mode = CODES;\r\n                    /* falls through */\r\n                case CODES:\r\n                    that.bitb = b;\r\n                    that.bitk = k;\r\n                    z.avail_in = n;\r\n                    z.total_in += p - z.next_in_index;\r\n                    z.next_in_index = p;\r\n                    that.write = q;\r\n\r\n                    if ((r = codes.proc(that, z, r)) != Z_STREAM_END) {\r\n                        return that.inflate_flush(z, r);\r\n                    }\r\n                    r = Z_OK;\r\n                    codes.free(z);\r\n\r\n                    p = z.next_in_index;\r\n                    n = z.avail_in;\r\n                    b = that.bitb;\r\n                    k = that.bitk;\r\n                    q = that.write;\r\n                    m = /* (int) */(q < that.read ? that.read - q - 1 : that.end - q);\r\n\r\n                    if (last === 0) {\r\n                        mode = TYPE;\r\n                        break;\r\n                    }\r\n                    mode = DRY;\r\n                    /* falls through */\r\n                case DRY:\r\n                    that.write = q;\r\n                    r = that.inflate_flush(z, r);\r\n                    q = that.write;\r\n                    m = /* (int) */(q < that.read ? that.read - q - 1 : that.end - q);\r\n                    if (that.read != that.write) {\r\n                        that.bitb = b;\r\n                        that.bitk = k;\r\n                        z.avail_in = n;\r\n                        z.total_in += p - z.next_in_index;\r\n                        z.next_in_index = p;\r\n                        that.write = q;\r\n                        return that.inflate_flush(z, r);\r\n                    }\r\n                    mode = DONELOCKS;\r\n                    /* falls through */\r\n                case DONELOCKS:\r\n                    r = Z_STREAM_END;\r\n\r\n                    that.bitb = b;\r\n                    that.bitk = k;\r\n                    z.avail_in = n;\r\n                    z.total_in += p - z.next_in_index;\r\n                    z.next_in_index = p;\r\n                    that.write = q;\r\n                    return that.inflate_flush(z, r);\r\n                case BADBLOCKS:\r\n                    r = Z_DATA_ERROR;\r\n\r\n                    that.bitb = b;\r\n                    that.bitk = k;\r\n                    z.avail_in = n;\r\n                    z.total_in += p - z.next_in_index;\r\n                    z.next_in_index = p;\r\n                    that.write = q;\r\n                    return that.inflate_flush(z, r);\r\n\r\n                default:\r\n                    r = Z_STREAM_ERROR;\r\n\r\n                    that.bitb = b;\r\n                    that.bitk = k;\r\n                    z.avail_in = n;\r\n                    z.total_in += p - z.next_in_index;\r\n                    z.next_in_index = p;\r\n                    that.write = q;\r\n                    return that.inflate_flush(z, r);\r\n                }\r\n            }\r\n        };\r\n\r\n        that.free = function(z) {\r\n            that.reset(z, null);\r\n            that.window = null;\r\n            hufts = null;\r\n            // ZFREE(z, s);\r\n        };\r\n\r\n        that.set_dictionary = function(d, start, n) {\r\n            that.window.set(d.subarray(start, start + n), 0);\r\n            that.read = that.write = n;\r\n        };\r\n\r\n        // Returns true if inflate is currently at the end of a block generated\r\n        // by Z_SYNC_FLUSH or Z_FULL_FLUSH.\r\n        that.sync_point = function() {\r\n            return mode == LENS ? 1 : 0;\r\n        };\r\n\r\n    }\r\n\r\n    // Inflate\r\n\r\n    // preset dictionary flag in zlib header\r\n    var PRESET_DICT = 0x20;\r\n\r\n    var Z_DEFLATED = 8;\r\n\r\n    var METHOD = 0; // waiting for method byte\r\n    var FLAG = 1; // waiting for flag byte\r\n    var DICT4 = 2; // four dictionary check bytes to go\r\n    var DICT3 = 3; // three dictionary check bytes to go\r\n    var DICT2 = 4; // two dictionary check bytes to go\r\n    var DICT1 = 5; // one dictionary check byte to go\r\n    var DICT0 = 6; // waiting for inflateSetDictionary\r\n    var BLOCKS = 7; // decompressing blocks\r\n    var DONE = 12; // finished check, done\r\n    var BAD = 13; // got an error--stay here\r\n\r\n    var mark = [ 0, 0, 0xff, 0xff ];\r\n\r\n    function Inflate() {\r\n        var that = this;\r\n\r\n        that.mode = 0; // current inflate mode\r\n\r\n        // mode dependent information\r\n        that.method = 0; // if FLAGS, method byte\r\n\r\n        // if CHECK, check values to compare\r\n        that.was = [ 0 ]; // new Array(1); // computed check value\r\n        that.need = 0; // stream check value\r\n\r\n        // if BAD, inflateSync's marker bytes count\r\n        that.marker = 0;\r\n\r\n        // mode independent information\r\n        that.wbits = 0; // log2(window size) (8..15, defaults to 15)\r\n\r\n        // this.blocks; // current inflate_blocks state\r\n\r\n        function inflateReset(z) {\r\n            if (!z || !z.istate)\r\n                return Z_STREAM_ERROR;\r\n\r\n            z.total_in = z.total_out = 0;\r\n            z.msg = null;\r\n            z.istate.mode = BLOCKS;\r\n            z.istate.blocks.reset(z, null);\r\n            return Z_OK;\r\n        }\r\n\r\n        that.inflateEnd = function(z) {\r\n            if (that.blocks)\r\n                that.blocks.free(z);\r\n            that.blocks = null;\r\n            // ZFREE(z, z->state);\r\n            return Z_OK;\r\n        };\r\n\r\n        that.inflateInit = function(z, w) {\r\n            z.msg = null;\r\n            that.blocks = null;\r\n\r\n            // set window size\r\n            if (w < 8 || w > 15) {\r\n                that.inflateEnd(z);\r\n                return Z_STREAM_ERROR;\r\n            }\r\n            that.wbits = w;\r\n\r\n            z.istate.blocks = new InfBlocks(z, 1 << w);\r\n\r\n            // reset state\r\n            inflateReset(z);\r\n            return Z_OK;\r\n        };\r\n\r\n        that.inflate = function(z, f) {\r\n            var r;\r\n            var b;\r\n\r\n            if (!z || !z.istate || !z.next_in)\r\n                return Z_STREAM_ERROR;\r\n            f = f == Z_FINISH ? Z_BUF_ERROR : Z_OK;\r\n            r = Z_BUF_ERROR;\r\n            while (true) {\r\n                // System.out.println(\"mode: \"+z.istate.mode);\r\n                switch (z.istate.mode) {\r\n                case METHOD:\r\n\r\n                    if (z.avail_in === 0)\r\n                        return r;\r\n                    r = f;\r\n\r\n                    z.avail_in--;\r\n                    z.total_in++;\r\n                    if (((z.istate.method = z.read_byte(z.next_in_index++)) & 0xf) != Z_DEFLATED) {\r\n                        z.istate.mode = BAD;\r\n                        z.msg = \"unknown compression method\";\r\n                        z.istate.marker = 5; // can't try inflateSync\r\n                        break;\r\n                    }\r\n                    if ((z.istate.method >> 4) + 8 > z.istate.wbits) {\r\n                        z.istate.mode = BAD;\r\n                        z.msg = \"invalid window size\";\r\n                        z.istate.marker = 5; // can't try inflateSync\r\n                        break;\r\n                    }\r\n                    z.istate.mode = FLAG;\r\n                    /* falls through */\r\n                case FLAG:\r\n\r\n                    if (z.avail_in === 0)\r\n                        return r;\r\n                    r = f;\r\n\r\n                    z.avail_in--;\r\n                    z.total_in++;\r\n                    b = (z.read_byte(z.next_in_index++)) & 0xff;\r\n\r\n                    if ((((z.istate.method << 8) + b) % 31) !== 0) {\r\n                        z.istate.mode = BAD;\r\n                        z.msg = \"incorrect header check\";\r\n                        z.istate.marker = 5; // can't try inflateSync\r\n                        break;\r\n                    }\r\n\r\n                    if ((b & PRESET_DICT) === 0) {\r\n                        z.istate.mode = BLOCKS;\r\n                        break;\r\n                    }\r\n                    z.istate.mode = DICT4;\r\n                    /* falls through */\r\n                case DICT4:\r\n\r\n                    if (z.avail_in === 0)\r\n                        return r;\r\n                    r = f;\r\n\r\n                    z.avail_in--;\r\n                    z.total_in++;\r\n                    z.istate.need = ((z.read_byte(z.next_in_index++) & 0xff) << 24) & 0xff000000;\r\n                    z.istate.mode = DICT3;\r\n                    /* falls through */\r\n                case DICT3:\r\n\r\n                    if (z.avail_in === 0)\r\n                        return r;\r\n                    r = f;\r\n\r\n                    z.avail_in--;\r\n                    z.total_in++;\r\n                    z.istate.need += ((z.read_byte(z.next_in_index++) & 0xff) << 16) & 0xff0000;\r\n                    z.istate.mode = DICT2;\r\n                    /* falls through */\r\n                case DICT2:\r\n\r\n                    if (z.avail_in === 0)\r\n                        return r;\r\n                    r = f;\r\n\r\n                    z.avail_in--;\r\n                    z.total_in++;\r\n                    z.istate.need += ((z.read_byte(z.next_in_index++) & 0xff) << 8) & 0xff00;\r\n                    z.istate.mode = DICT1;\r\n                    /* falls through */\r\n                case DICT1:\r\n\r\n                    if (z.avail_in === 0)\r\n                        return r;\r\n                    r = f;\r\n\r\n                    z.avail_in--;\r\n                    z.total_in++;\r\n                    z.istate.need += (z.read_byte(z.next_in_index++) & 0xff);\r\n                    z.istate.mode = DICT0;\r\n                    return Z_NEED_DICT;\r\n                case DICT0:\r\n                    z.istate.mode = BAD;\r\n                    z.msg = \"need dictionary\";\r\n                    z.istate.marker = 0; // can try inflateSync\r\n                    return Z_STREAM_ERROR;\r\n                case BLOCKS:\r\n\r\n                    r = z.istate.blocks.proc(z, r);\r\n                    if (r == Z_DATA_ERROR) {\r\n                        z.istate.mode = BAD;\r\n                        z.istate.marker = 0; // can try inflateSync\r\n                        break;\r\n                    }\r\n                    if (r == Z_OK) {\r\n                        r = f;\r\n                    }\r\n                    if (r != Z_STREAM_END) {\r\n                        return r;\r\n                    }\r\n                    r = f;\r\n                    z.istate.blocks.reset(z, z.istate.was);\r\n                    z.istate.mode = DONE;\r\n                    /* falls through */\r\n                case DONE:\r\n                    return Z_STREAM_END;\r\n                case BAD:\r\n                    return Z_DATA_ERROR;\r\n                default:\r\n                    return Z_STREAM_ERROR;\r\n                }\r\n            }\r\n        };\r\n\r\n        that.inflateSetDictionary = function(z, dictionary, dictLength) {\r\n            var index = 0;\r\n            var length = dictLength;\r\n            if (!z || !z.istate || z.istate.mode != DICT0)\r\n                return Z_STREAM_ERROR;\r\n\r\n            if (length >= (1 << z.istate.wbits)) {\r\n                length = (1 << z.istate.wbits) - 1;\r\n                index = dictLength - length;\r\n            }\r\n            z.istate.blocks.set_dictionary(dictionary, index, length);\r\n            z.istate.mode = BLOCKS;\r\n            return Z_OK;\r\n        };\r\n\r\n        that.inflateSync = function(z) {\r\n            var n; // number of bytes to look at\r\n            var p; // pointer to bytes\r\n            var m; // number of marker bytes found in a row\r\n            var r, w; // temporaries to save total_in and total_out\r\n\r\n            // set up\r\n            if (!z || !z.istate)\r\n                return Z_STREAM_ERROR;\r\n            if (z.istate.mode != BAD) {\r\n                z.istate.mode = BAD;\r\n                z.istate.marker = 0;\r\n            }\r\n            if ((n = z.avail_in) === 0)\r\n                return Z_BUF_ERROR;\r\n            p = z.next_in_index;\r\n            m = z.istate.marker;\r\n\r\n            // search\r\n            while (n !== 0 && m < 4) {\r\n                if (z.read_byte(p) == mark[m]) {\r\n                    m++;\r\n                } else if (z.read_byte(p) !== 0) {\r\n                    m = 0;\r\n                } else {\r\n                    m = 4 - m;\r\n                }\r\n                p++;\r\n                n--;\r\n            }\r\n\r\n            // restore\r\n            z.total_in += p - z.next_in_index;\r\n            z.next_in_index = p;\r\n            z.avail_in = n;\r\n            z.istate.marker = m;\r\n\r\n            // return no joy or set up to restart on a new block\r\n            if (m != 4) {\r\n                return Z_DATA_ERROR;\r\n            }\r\n            r = z.total_in;\r\n            w = z.total_out;\r\n            inflateReset(z);\r\n            z.total_in = r;\r\n            z.total_out = w;\r\n            z.istate.mode = BLOCKS;\r\n            return Z_OK;\r\n        };\r\n\r\n        // Returns true if inflate is currently at the end of a block generated\r\n        // by Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP\r\n        // implementation to provide an additional safety check. PPP uses\r\n        // Z_SYNC_FLUSH\r\n        // but removes the length bytes of the resulting empty stored block. When\r\n        // decompressing, PPP checks that at the end of input packet, inflate is\r\n        // waiting for these length bytes.\r\n        that.inflateSyncPoint = function(z) {\r\n            if (!z || !z.istate || !z.istate.blocks)\r\n                return Z_STREAM_ERROR;\r\n            return z.istate.blocks.sync_point();\r\n        };\r\n    }\r\n\r\n    // ZStream\r\n\r\n    function ZStream() {\r\n    }\r\n\r\n    ZStream.prototype = {\r\n        inflateInit : function(bits) {\r\n            var that = this;\r\n            that.istate = new Inflate();\r\n            if (!bits)\r\n                bits = MAX_BITS;\r\n            return that.istate.inflateInit(that, bits);\r\n        },\r\n\r\n        inflate : function(f) {\r\n            var that = this;\r\n            if (!that.istate)\r\n                return Z_STREAM_ERROR;\r\n            return that.istate.inflate(that, f);\r\n        },\r\n\r\n        inflateEnd : function() {\r\n            var that = this;\r\n            if (!that.istate)\r\n                return Z_STREAM_ERROR;\r\n            var ret = that.istate.inflateEnd(that);\r\n            that.istate = null;\r\n            return ret;\r\n        },\r\n\r\n        inflateSync : function() {\r\n            var that = this;\r\n            if (!that.istate)\r\n                return Z_STREAM_ERROR;\r\n            return that.istate.inflateSync(that);\r\n        },\r\n        inflateSetDictionary : function(dictionary, dictLength) {\r\n            var that = this;\r\n            if (!that.istate)\r\n                return Z_STREAM_ERROR;\r\n            return that.istate.inflateSetDictionary(that, dictionary, dictLength);\r\n        },\r\n        read_byte : function(start) {\r\n            var that = this;\r\n            return that.next_in.subarray(start, start + 1)[0];\r\n        },\r\n        read_buf : function(start, size) {\r\n            var that = this;\r\n            return that.next_in.subarray(start, start + size);\r\n        }\r\n    };\r\n\r\n    // Inflater\r\n\r\n    function Inflater() {\r\n        var that = this;\r\n        var z = new ZStream();\r\n        var bufsize = 512;\r\n        var flush = Z_NO_FLUSH;\r\n        var buf = new Uint8Array(bufsize);\r\n        var nomoreinput = false;\r\n\r\n        z.inflateInit();\r\n        z.next_out = buf;\r\n\r\n        that.append = function(data, onprogress) {\r\n            var err, buffers = [], lastIndex = 0, bufferIndex = 0, bufferSize = 0, array;\r\n            if (data.length === 0)\r\n                return;\r\n            z.next_in_index = 0;\r\n            z.next_in = data;\r\n            z.avail_in = data.length;\r\n            do {\r\n                z.next_out_index = 0;\r\n                z.avail_out = bufsize;\r\n                if ((z.avail_in === 0) && (!nomoreinput)) { // if buffer is empty and more input is available, refill it\r\n                    z.next_in_index = 0;\r\n                    nomoreinput = true;\r\n                }\r\n                err = z.inflate(flush);\r\n                if (nomoreinput && (err === Z_BUF_ERROR)) {\r\n                    if (z.avail_in !== 0)\r\n                        throw new Error(\"inflating: bad input\");\r\n                } else if (err !== Z_OK && err !== Z_STREAM_END)\r\n                    throw new Error(\"inflating: \" + z.msg);\r\n                if ((nomoreinput || err === Z_STREAM_END) && (z.avail_in === data.length))\r\n                    throw new Error(\"inflating: bad input\");\r\n                if (z.next_out_index)\r\n                    if (z.next_out_index === bufsize)\r\n                        buffers.push(new Uint8Array(buf));\r\n                    else\r\n                        buffers.push(new Uint8Array(buf.subarray(0, z.next_out_index)));\r\n                bufferSize += z.next_out_index;\r\n                if (onprogress && z.next_in_index > 0 && z.next_in_index != lastIndex) {\r\n                    onprogress(z.next_in_index);\r\n                    lastIndex = z.next_in_index;\r\n                }\r\n            } while (z.avail_in > 0 || z.avail_out === 0);\r\n            array = new Uint8Array(bufferSize);\r\n            buffers.forEach(function(chunk) {\r\n                array.set(chunk, bufferIndex);\r\n                bufferIndex += chunk.length;\r\n            });\r\n            return array;\r\n        };\r\n        that.flush = function() {\r\n            z.inflateEnd();\r\n        };\r\n    }\r\n\r\n    // 'zip' may not be defined in z-worker and some tests\r\n    var env = global.zip || global;\r\n    env.Inflater = env._jzlib_Inflater = Inflater;\r\n})(this);";

},{}],3:[function(require,module,exports){
module.exports = "/* jshint worker:true */\r\n(function main(global) {\r\n    \"use strict\";\r\n\r\n    if (global.zWorkerInitialized)\r\n        throw new Error('z-worker.js should be run only once');\r\n    global.zWorkerInitialized = true;\r\n\r\n    addEventListener(\"message\", function(event) {\r\n        var message = event.data, type = message.type, sn = message.sn;\r\n        var handler = handlers[type];\r\n        if (handler) {\r\n            try {\r\n                handler(message);\r\n            } catch (e) {\r\n                onError(type, sn, e);\r\n            }\r\n        }\r\n        //for debug\r\n        //postMessage({type: 'echo', originalType: type, sn: sn});\r\n    });\r\n\r\n    var handlers = {\r\n        importScripts: doImportScripts,\r\n        newTask: newTask,\r\n        append: processData,\r\n        flush: processData,\r\n    };\r\n\r\n    // deflater/inflater tasks indexed by serial numbers\r\n    var tasks = {};\r\n\r\n    function doImportScripts(msg) {\r\n        if (msg.scripts && msg.scripts.length > 0)\r\n            importScripts.apply(undefined, msg.scripts);\r\n        postMessage({type: 'importScripts'});\r\n    }\r\n\r\n    function newTask(msg) {\r\n        var CodecClass = global[msg.codecClass];\r\n        var sn = msg.sn;\r\n        if (tasks[sn])\r\n            throw Error('duplicated sn');\r\n        tasks[sn] =  {\r\n            codec: new CodecClass(msg.options),\r\n            crcInput: msg.crcType === 'input',\r\n            crcOutput: msg.crcType === 'output',\r\n            crc: new Crc32(),\r\n        };\r\n        postMessage({type: 'newTask', sn: sn});\r\n    }\r\n\r\n    // performance may not be supported\r\n    var now = global.performance ? global.performance.now.bind(global.performance) : Date.now;\r\n\r\n    function processData(msg) {\r\n        var sn = msg.sn, type = msg.type, input = msg.data;\r\n        var task = tasks[sn];\r\n        // allow creating codec on first append\r\n        if (!task && msg.codecClass) {\r\n            newTask(msg);\r\n            task = tasks[sn];\r\n        }\r\n        var isAppend = type === 'append';\r\n        var start = now();\r\n        var output;\r\n        if (isAppend) {\r\n            try {\r\n                output = task.codec.append(input, function onprogress(loaded) {\r\n                    postMessage({type: 'progress', sn: sn, loaded: loaded});\r\n                });\r\n            } catch (e) {\r\n                delete tasks[sn];\r\n                throw e;\r\n            }\r\n        } else {\r\n            delete tasks[sn];\r\n            output = task.codec.flush();\r\n        }\r\n        var codecTime = now() - start;\r\n\r\n        start = now();\r\n        if (input && task.crcInput)\r\n            task.crc.append(input);\r\n        if (output && task.crcOutput)\r\n            task.crc.append(output);\r\n        var crcTime = now() - start;\r\n\r\n        var rmsg = {type: type, sn: sn, codecTime: codecTime, crcTime: crcTime};\r\n        var transferables = [];\r\n        if (output) {\r\n            rmsg.data = output;\r\n            transferables.push(output.buffer);\r\n        }\r\n        if (!isAppend && (task.crcInput || task.crcOutput))\r\n            rmsg.crc = task.crc.get();\r\n\r\n        // posting a message with transferables will fail on IE10\r\n        try {\r\n            postMessage(rmsg, transferables);\r\n        } catch(ex) {\r\n            postMessage(rmsg); // retry without transferables\r\n        }\r\n    }\r\n\r\n    function onError(type, sn, e) {\r\n        var msg = {\r\n            type: type,\r\n            sn: sn,\r\n            error: formatError(e)\r\n        };\r\n        postMessage(msg);\r\n    }\r\n\r\n    function formatError(e) {\r\n        return { message: e.message, stack: e.stack };\r\n    }\r\n\r\n    // Crc32 code copied from file zip.js\r\n    function Crc32() {\r\n        this.crc = -1;\r\n    }\r\n    Crc32.prototype.append = function append(data) {\r\n        var crc = this.crc | 0, table = this.table;\r\n        for (var offset = 0, len = data.length | 0; offset < len; offset++)\r\n            crc = (crc >>> 8) ^ table[(crc ^ data[offset]) & 0xFF];\r\n        this.crc = crc;\r\n    };\r\n    Crc32.prototype.get = function get() {\r\n        return ~this.crc;\r\n    };\r\n    Crc32.prototype.table = (function() {\r\n        var i, j, t, table = []; // Uint32Array is actually slower than []\r\n        for (i = 0; i < 256; i++) {\r\n            t = i;\r\n            for (j = 0; j < 8; j++)\r\n                if (t & 1)\r\n                    t = (t >>> 1) ^ 0xEDB88320;\r\n                else\r\n                    t = t >>> 1;\r\n            table[i] = t;\r\n        }\r\n        return table;\r\n    })();\r\n\r\n    // \"no-op\" codec\r\n    function NOOP() {}\r\n    global.NOOP = NOOP;\r\n    NOOP.prototype.append = function append(bytes, onprogress) {\r\n        return bytes;\r\n    };\r\n    NOOP.prototype.flush = function flush() {};\r\n})(this);";

},{}],4:[function(require,module,exports){
/*
 Copyright (c) 2013 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright
 notice, this list of conditions and the following disclaimer in
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

(function() {
	"use strict";

	var ERR_HTTP_RANGE = "HTTP Range not supported.";

	var Reader = zip.Reader;
	var Writer = zip.Writer;
	
	var ZipDirectoryEntry;

	var appendABViewSupported;
	try {
		appendABViewSupported = new Blob([ new DataView(new ArrayBuffer(0)) ]).size === 0;
	} catch (e) {
	}

	function HttpReader(url) {
		var that = this;

		function getData(callback, onerror) {
			var request;
			if (!that.data) {
				request = new XMLHttpRequest();
				request.addEventListener("load", function() {
					if (!that.size)
						that.size = Number(request.getResponseHeader("Content-Length"));
					that.data = new Uint8Array(request.response);
					callback();
				}, false);
				request.addEventListener("error", onerror, false);
				request.open("GET", url);
				request.responseType = "arraybuffer";
				request.send();
			} else
				callback();
		}

		function init(callback, onerror) {
			var request = new XMLHttpRequest();
			request.addEventListener("load", function() {
				that.size = Number(request.getResponseHeader("Content-Length"));
				callback();
			}, false);
			request.addEventListener("error", onerror, false);
			request.open("HEAD", url);
			request.send();
		}

		function readUint8Array(index, length, callback, onerror) {
			getData(function() {
				callback(new Uint8Array(that.data.subarray(index, index + length)));
			}, onerror);
		}

		that.size = 0;
		that.init = init;
		that.readUint8Array = readUint8Array;
	}
	HttpReader.prototype = new Reader();
	HttpReader.prototype.constructor = HttpReader;

	function HttpRangeReader(url) {
		var that = this;

		function init(callback, onerror) {
			var request = new XMLHttpRequest();
			request.addEventListener("load", function() {
				that.size = Number(request.getResponseHeader("Content-Length"));
				if (request.getResponseHeader("Accept-Ranges") == "bytes")
					callback();
				else
					onerror(ERR_HTTP_RANGE);
			}, false);
			request.addEventListener("error", onerror, false);
			request.open("HEAD", url);
			request.send();
		}

		function readArrayBuffer(index, length, callback, onerror) {
			var request = new XMLHttpRequest();
			request.open("GET", url);
			request.responseType = "arraybuffer";
			request.setRequestHeader("Range", "bytes=" + index + "-" + (index + length - 1));
			request.addEventListener("load", function() {
				callback(request.response);
			}, false);
			request.addEventListener("error", onerror, false);
			request.send();
		}

		function readUint8Array(index, length, callback, onerror) {
			readArrayBuffer(index, length, function(arraybuffer) {
				callback(new Uint8Array(arraybuffer));
			}, onerror);
		}

		that.size = 0;
		that.init = init;
		that.readUint8Array = readUint8Array;
	}
	HttpRangeReader.prototype = new Reader();
	HttpRangeReader.prototype.constructor = HttpRangeReader;

	function ArrayBufferReader(arrayBuffer) {
		var that = this;

		function init(callback, onerror) {
			that.size = arrayBuffer.byteLength;
			callback();
		}

		function readUint8Array(index, length, callback, onerror) {
			callback(new Uint8Array(arrayBuffer.slice(index, index + length)));
		}

		that.size = 0;
		that.init = init;
		that.readUint8Array = readUint8Array;
	}
	ArrayBufferReader.prototype = new Reader();
	ArrayBufferReader.prototype.constructor = ArrayBufferReader;

	function ArrayBufferWriter() {
		var array, that = this;

		function init(callback, onerror) {
			array = new Uint8Array();
			callback();
		}

		function writeUint8Array(arr, callback, onerror) {
			var tmpArray = new Uint8Array(array.length + arr.length);
			tmpArray.set(array);
			tmpArray.set(arr, array.length);
			array = tmpArray;
			callback();
		}

		function getData(callback) {
			callback(array.buffer);
		}

		that.init = init;
		that.writeUint8Array = writeUint8Array;
		that.getData = getData;
	}
	ArrayBufferWriter.prototype = new Writer();
	ArrayBufferWriter.prototype.constructor = ArrayBufferWriter;

	function FileWriter(fileEntry, contentType) {
		var writer, that = this;

		function init(callback, onerror) {
			fileEntry.createWriter(function(fileWriter) {
				writer = fileWriter;
				callback();
			}, onerror);
		}

		function writeUint8Array(array, callback, onerror) {
			var blob = new Blob([ appendABViewSupported ? array : array.buffer ], {
				type : contentType
			});
			writer.onwrite = function() {
				writer.onwrite = null;
				callback();
			};
			writer.onerror = onerror;
			writer.write(blob);
		}

		function getData(callback) {
			fileEntry.file(callback);
		}

		that.init = init;
		that.writeUint8Array = writeUint8Array;
		that.getData = getData;
	}
	FileWriter.prototype = new Writer();
	FileWriter.prototype.constructor = FileWriter;

	zip.FileWriter = FileWriter;
	zip.HttpReader = HttpReader;
	zip.HttpRangeReader = HttpRangeReader;
	zip.ArrayBufferReader = ArrayBufferReader;
	zip.ArrayBufferWriter = ArrayBufferWriter;

	if (zip.fs) {
		ZipDirectoryEntry = zip.fs.ZipDirectoryEntry;
		ZipDirectoryEntry.prototype.addHttpContent = function(name, URL, useRangeHeader) {
			function addChild(parent, name, params, directory) {
				if (parent.directory)
					return directory ? new ZipDirectoryEntry(parent.fs, name, params, parent) : new zip.fs.ZipFileEntry(parent.fs, name, params, parent);
				else
					throw "Parent entry is not a directory.";
			}

			return addChild(this, name, {
				data : URL,
				Reader : useRangeHeader ? HttpRangeReader : HttpReader
			});
		};
		ZipDirectoryEntry.prototype.importHttpContent = function(URL, useRangeHeader, onend, onerror) {
			this.importZip(useRangeHeader ? new HttpRangeReader(URL) : new HttpReader(URL), onend, onerror);
		};
		zip.fs.FS.prototype.importHttpContent = function(URL, useRangeHeader, onend, onerror) {
			this.entries = [];
			this.root = new ZipDirectoryEntry(this);
			this.root.importHttpContent(URL, useRangeHeader, onend, onerror);
		};
	}

})();

},{}],5:[function(require,module,exports){
/*
 Copyright (c) 2013 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright
 notice, this list of conditions and the following disclaimer in
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

(function(obj) {
	"use strict";

	var ERR_BAD_FORMAT = "File format is not recognized.";
	var ERR_CRC = "CRC failed.";
	var ERR_ENCRYPTED = "File contains encrypted entry.";
	var ERR_ZIP64 = "File is using Zip64 (4gb+ file size).";
	var ERR_READ = "Error while reading zip file.";
	var ERR_WRITE = "Error while writing zip file.";
	var ERR_WRITE_DATA = "Error while writing file data.";
	var ERR_READ_DATA = "Error while reading file data.";
	var ERR_DUPLICATED_NAME = "File already exists.";
	var CHUNK_SIZE = 512 * 1024;

	var TEXT_PLAIN = "text/plain";

	var appendABViewSupported;
	try {
		appendABViewSupported = new Blob([ new DataView(new ArrayBuffer(0)) ]).size === 0;
	} catch (e) {
	}

	function Crc32() {
		this.crc = -1;
	}
	Crc32.prototype.append = function append(data) {
		var crc = this.crc | 0, table = this.table;
		for (var offset = 0, len = data.length | 0; offset < len; offset++)
			crc = (crc >>> 8) ^ table[(crc ^ data[offset]) & 0xFF];
		this.crc = crc;
	};
	Crc32.prototype.get = function get() {
		return ~this.crc;
	};
	Crc32.prototype.table = (function() {
		var i, j, t, table = []; // Uint32Array is actually slower than []
		for (i = 0; i < 256; i++) {
			t = i;
			for (j = 0; j < 8; j++)
				if (t & 1)
					t = (t >>> 1) ^ 0xEDB88320;
				else
					t = t >>> 1;
			table[i] = t;
		}
		return table;
	})();

	// "no-op" codec
	function NOOP() {}
	NOOP.prototype.append = function append(bytes, onprogress) {
		return bytes;
	};
	NOOP.prototype.flush = function flush() {};

	function blobSlice(blob, index, length) {
		if (index < 0 || length < 0 || index + length > blob.size)
			throw new RangeError('offset:' + index + ', length:' + length + ', size:' + blob.size);
		if (blob.slice)
			return blob.slice(index, index + length);
		else if (blob.webkitSlice)
			return blob.webkitSlice(index, index + length);
		else if (blob.mozSlice)
			return blob.mozSlice(index, index + length);
		else if (blob.msSlice)
			return blob.msSlice(index, index + length);
	}

	function getDataHelper(byteLength, bytes) {
		var dataBuffer, dataArray;
		dataBuffer = new ArrayBuffer(byteLength);
		dataArray = new Uint8Array(dataBuffer);
		if (bytes)
			dataArray.set(bytes, 0);
		return {
			buffer : dataBuffer,
			array : dataArray,
			view : new DataView(dataBuffer)
		};
	}

	// Readers
	function Reader() {
	}

	function TextReader(text) {
		var that = this, blobReader;

		function init(callback, onerror) {
			var blob = new Blob([ text ], {
				type : TEXT_PLAIN
			});
			blobReader = new BlobReader(blob);
			blobReader.init(function() {
				that.size = blobReader.size;
				callback();
			}, onerror);
		}

		function readUint8Array(index, length, callback, onerror) {
			blobReader.readUint8Array(index, length, callback, onerror);
		}

		that.size = 0;
		that.init = init;
		that.readUint8Array = readUint8Array;
	}
	TextReader.prototype = new Reader();
	TextReader.prototype.constructor = TextReader;

	function Data64URIReader(dataURI) {
		var that = this, dataStart;

		function init(callback) {
			var dataEnd = dataURI.length;
			while (dataURI.charAt(dataEnd - 1) == "=")
				dataEnd--;
			dataStart = dataURI.indexOf(",") + 1;
			that.size = Math.floor((dataEnd - dataStart) * 0.75);
			callback();
		}

		function readUint8Array(index, length, callback) {
			var i, data = getDataHelper(length);
			var start = Math.floor(index / 3) * 4;
			var end = Math.ceil((index + length) / 3) * 4;
			var bytes = obj.atob(dataURI.substring(start + dataStart, end + dataStart));
			var delta = index - Math.floor(start / 4) * 3;
			for (i = delta; i < delta + length; i++)
				data.array[i - delta] = bytes.charCodeAt(i);
			callback(data.array);
		}

		that.size = 0;
		that.init = init;
		that.readUint8Array = readUint8Array;
	}
	Data64URIReader.prototype = new Reader();
	Data64URIReader.prototype.constructor = Data64URIReader;

	function BlobReader(blob) {
		var that = this;

		function init(callback) {
			that.size = blob.size;
			callback();
		}

		function readUint8Array(index, length, callback, onerror) {
			var reader = new FileReader();
			reader.onload = function(e) {
				callback(new Uint8Array(e.target.result));
			};
			reader.onerror = onerror;
			try {
				reader.readAsArrayBuffer(blobSlice(blob, index, length));
			} catch (e) {
				onerror(e);
			}
		}

		that.size = 0;
		that.init = init;
		that.readUint8Array = readUint8Array;
	}
	BlobReader.prototype = new Reader();
	BlobReader.prototype.constructor = BlobReader;

	// Writers

	function Writer() {
	}
	Writer.prototype.getData = function(callback) {
		callback(this.data);
	};

	function TextWriter(encoding) {
		var that = this, blob;

		function init(callback) {
			blob = new Blob([], {
				type : TEXT_PLAIN
			});
			callback();
		}

		function writeUint8Array(array, callback) {
			blob = new Blob([ blob, appendABViewSupported ? array : array.buffer ], {
				type : TEXT_PLAIN
			});
			callback();
		}

		function getData(callback, onerror) {
			var reader = new FileReader();
			reader.onload = function(e) {
				callback(e.target.result);
			};
			reader.onerror = onerror;
			reader.readAsText(blob, encoding);
		}

		that.init = init;
		that.writeUint8Array = writeUint8Array;
		that.getData = getData;
	}
	TextWriter.prototype = new Writer();
	TextWriter.prototype.constructor = TextWriter;

	function Data64URIWriter(contentType) {
		var that = this, data = "", pending = "";

		function init(callback) {
			data += "data:" + (contentType || "") + ";base64,";
			callback();
		}

		function writeUint8Array(array, callback) {
			var i, delta = pending.length, dataString = pending;
			pending = "";
			for (i = 0; i < (Math.floor((delta + array.length) / 3) * 3) - delta; i++)
				dataString += String.fromCharCode(array[i]);
			for (; i < array.length; i++)
				pending += String.fromCharCode(array[i]);
			if (dataString.length > 2)
				data += obj.btoa(dataString);
			else
				pending = dataString;
			callback();
		}

		function getData(callback) {
			callback(data + obj.btoa(pending));
		}

		that.init = init;
		that.writeUint8Array = writeUint8Array;
		that.getData = getData;
	}
	Data64URIWriter.prototype = new Writer();
	Data64URIWriter.prototype.constructor = Data64URIWriter;

	function BlobWriter(contentType) {
		var blob, that = this;

		function init(callback) {
			blob = new Blob([], {
				type : contentType
			});
			callback();
		}

		function writeUint8Array(array, callback) {
			blob = new Blob([ blob, appendABViewSupported ? array : array.buffer ], {
				type : contentType
			});
			callback();
		}

		function getData(callback) {
			callback(blob);
		}

		that.init = init;
		that.writeUint8Array = writeUint8Array;
		that.getData = getData;
	}
	BlobWriter.prototype = new Writer();
	BlobWriter.prototype.constructor = BlobWriter;

	/**
	 * inflate/deflate core functions
	 * @param worker {Worker} web worker for the task.
	 * @param initialMessage {Object} initial message to be sent to the worker. should contain
	 *   sn(serial number for distinguishing multiple tasks sent to the worker), and codecClass.
	 *   This function may add more properties before sending.
	 */
	function launchWorkerProcess(worker, initialMessage, reader, writer, offset, size, onprogress, onend, onreaderror, onwriteerror) {
		var chunkIndex = 0, index, outputSize, sn = initialMessage.sn, crc;

		function onflush() {
			worker.removeEventListener('message', onmessage, false);
			onend(outputSize, crc);
		}

		function onmessage(event) {
			var message = event.data, data = message.data, err = message.error;
			if (err) {
				err.toString = function () { return 'Error: ' + this.message; };
				onreaderror(err);
				return;
			}
			if (message.sn !== sn)
				return;
			if (typeof message.codecTime === 'number')
				worker.codecTime += message.codecTime; // should be before onflush()
			if (typeof message.crcTime === 'number')
				worker.crcTime += message.crcTime;

			switch (message.type) {
				case 'append':
					if (data) {
						outputSize += data.length;
						writer.writeUint8Array(data, function() {
							step();
						}, onwriteerror);
					} else
						step();
					break;
				case 'flush':
					crc = message.crc;
					if (data) {
						outputSize += data.length;
						writer.writeUint8Array(data, function() {
							onflush();
						}, onwriteerror);
					} else
						onflush();
					break;
				case 'progress':
					if (onprogress)
						onprogress(index + message.loaded, size);
					break;
				case 'importScripts': //no need to handle here
				case 'newTask':
				case 'echo':
					break;
				default:
					console.warn('zip.js:launchWorkerProcess: unknown message: ', message);
			}
		}

		function step() {
			index = chunkIndex * CHUNK_SIZE;
			// use `<=` instead of `<`, because `size` may be 0.
			if (index <= size) {
				reader.readUint8Array(offset + index, Math.min(CHUNK_SIZE, size - index), function(array) {
					if (onprogress)
						onprogress(index, size);
					var msg = index === 0 ? initialMessage : {sn : sn};
					msg.type = 'append';
					msg.data = array;

					// posting a message with transferables will fail on IE10
					try {
						worker.postMessage(msg, [array.buffer]);
					} catch(ex) {
						worker.postMessage(msg); // retry without transferables
					}
					chunkIndex++;
				}, onreaderror);
			} else {
				worker.postMessage({
					sn: sn,
					type: 'flush'
				});
			}
		}

		outputSize = 0;
		worker.addEventListener('message', onmessage, false);
		step();
	}

	function launchProcess(process, reader, writer, offset, size, crcType, onprogress, onend, onreaderror, onwriteerror) {
		var chunkIndex = 0, index, outputSize = 0,
			crcInput = crcType === 'input',
			crcOutput = crcType === 'output',
			crc = new Crc32();
		function step() {
			var outputData;
			index = chunkIndex * CHUNK_SIZE;
			if (index < size)
				reader.readUint8Array(offset + index, Math.min(CHUNK_SIZE, size - index), function(inputData) {
					var outputData;
					try {
						outputData = process.append(inputData, function(loaded) {
							if (onprogress)
								onprogress(index + loaded, size);
						});
					} catch (e) {
						onreaderror(e);
						return;
					}
					if (outputData) {
						outputSize += outputData.length;
						writer.writeUint8Array(outputData, function() {
							chunkIndex++;
							setTimeout(step, 1);
						}, onwriteerror);
						if (crcOutput)
							crc.append(outputData);
					} else {
						chunkIndex++;
						setTimeout(step, 1);
					}
					if (crcInput)
						crc.append(inputData);
					if (onprogress)
						onprogress(index, size);
				}, onreaderror);
			else {
				try {
					outputData = process.flush();
				} catch (e) {
					onreaderror(e);
					return;
				}
				if (outputData) {
					if (crcOutput)
						crc.append(outputData);
					outputSize += outputData.length;
					writer.writeUint8Array(outputData, function() {
						onend(outputSize, crc.get());
					}, onwriteerror);
				} else
					onend(outputSize, crc.get());
			}
		}

		step();
	}

	function inflate(worker, sn, reader, writer, offset, size, computeCrc32, onend, onprogress, onreaderror, onwriteerror) {
		var crcType = computeCrc32 ? 'output' : 'none';
		if (obj.zip.useWebWorkers) {
			var initialMessage = {
				sn: sn,
				codecClass: 'Inflater',
				crcType: crcType,
			};
			launchWorkerProcess(worker, initialMessage, reader, writer, offset, size, onprogress, onend, onreaderror, onwriteerror);
		} else
			launchProcess(new obj.zip.Inflater(), reader, writer, offset, size, crcType, onprogress, onend, onreaderror, onwriteerror);
	}

	function deflate(worker, sn, reader, writer, level, onend, onprogress, onreaderror, onwriteerror) {
		var crcType = 'input';
		if (obj.zip.useWebWorkers) {
			var initialMessage = {
				sn: sn,
				options: {level: level},
				codecClass: 'Deflater',
				crcType: crcType,
			};
			launchWorkerProcess(worker, initialMessage, reader, writer, 0, reader.size, onprogress, onend, onreaderror, onwriteerror);
		} else
			launchProcess(new obj.zip.Deflater(), reader, writer, 0, reader.size, crcType, onprogress, onend, onreaderror, onwriteerror);
	}

	function copy(worker, sn, reader, writer, offset, size, computeCrc32, onend, onprogress, onreaderror, onwriteerror) {
		var crcType = 'input';
		if (obj.zip.useWebWorkers && computeCrc32) {
			var initialMessage = {
				sn: sn,
				codecClass: 'NOOP',
				crcType: crcType,
			};
			launchWorkerProcess(worker, initialMessage, reader, writer, offset, size, onprogress, onend, onreaderror, onwriteerror);
		} else
			launchProcess(new NOOP(), reader, writer, offset, size, crcType, onprogress, onend, onreaderror, onwriteerror);
	}

	// ZipReader

	function decodeASCII(str) {
		var i, out = "", charCode, extendedASCII = [ '\u00C7', '\u00FC', '\u00E9', '\u00E2', '\u00E4', '\u00E0', '\u00E5', '\u00E7', '\u00EA', '\u00EB',
				'\u00E8', '\u00EF', '\u00EE', '\u00EC', '\u00C4', '\u00C5', '\u00C9', '\u00E6', '\u00C6', '\u00F4', '\u00F6', '\u00F2', '\u00FB', '\u00F9',
				'\u00FF', '\u00D6', '\u00DC', '\u00F8', '\u00A3', '\u00D8', '\u00D7', '\u0192', '\u00E1', '\u00ED', '\u00F3', '\u00FA', '\u00F1', '\u00D1',
				'\u00AA', '\u00BA', '\u00BF', '\u00AE', '\u00AC', '\u00BD', '\u00BC', '\u00A1', '\u00AB', '\u00BB', '_', '_', '_', '\u00A6', '\u00A6',
				'\u00C1', '\u00C2', '\u00C0', '\u00A9', '\u00A6', '\u00A6', '+', '+', '\u00A2', '\u00A5', '+', '+', '-', '-', '+', '-', '+', '\u00E3',
				'\u00C3', '+', '+', '-', '-', '\u00A6', '-', '+', '\u00A4', '\u00F0', '\u00D0', '\u00CA', '\u00CB', '\u00C8', 'i', '\u00CD', '\u00CE',
				'\u00CF', '+', '+', '_', '_', '\u00A6', '\u00CC', '_', '\u00D3', '\u00DF', '\u00D4', '\u00D2', '\u00F5', '\u00D5', '\u00B5', '\u00FE',
				'\u00DE', '\u00DA', '\u00DB', '\u00D9', '\u00FD', '\u00DD', '\u00AF', '\u00B4', '\u00AD', '\u00B1', '_', '\u00BE', '\u00B6', '\u00A7',
				'\u00F7', '\u00B8', '\u00B0', '\u00A8', '\u00B7', '\u00B9', '\u00B3', '\u00B2', '_', ' ' ];
		for (i = 0; i < str.length; i++) {
			charCode = str.charCodeAt(i) & 0xFF;
			if (charCode > 127)
				out += extendedASCII[charCode - 128];
			else
				out += String.fromCharCode(charCode);
		}
		return out;
	}

	function decodeUTF8(string) {
		return decodeURIComponent(escape(string));
	}

	function getString(bytes) {
		var i, str = "";
		for (i = 0; i < bytes.length; i++)
			str += String.fromCharCode(bytes[i]);
		return str;
	}

	function getDate(timeRaw) {
		var date = (timeRaw & 0xffff0000) >> 16, time = timeRaw & 0x0000ffff;
		try {
			return new Date(1980 + ((date & 0xFE00) >> 9), ((date & 0x01E0) >> 5) - 1, date & 0x001F, (time & 0xF800) >> 11, (time & 0x07E0) >> 5,
					(time & 0x001F) * 2, 0);
		} catch (e) {
		}
	}

	function readCommonHeader(entry, data, index, centralDirectory, onerror) {
		entry.version = data.view.getUint16(index, true);
		entry.bitFlag = data.view.getUint16(index + 2, true);
		entry.compressionMethod = data.view.getUint16(index + 4, true);
		entry.lastModDateRaw = data.view.getUint32(index + 6, true);
		entry.lastModDate = getDate(entry.lastModDateRaw);
		if ((entry.bitFlag & 0x01) === 0x01) {
			onerror(ERR_ENCRYPTED);
			return;
		}
		if (centralDirectory || (entry.bitFlag & 0x0008) != 0x0008) {
			entry.crc32 = data.view.getUint32(index + 10, true);
			entry.compressedSize = data.view.getUint32(index + 14, true);
			entry.uncompressedSize = data.view.getUint32(index + 18, true);
		}
		if (entry.compressedSize === 0xFFFFFFFF || entry.uncompressedSize === 0xFFFFFFFF) {
			onerror(ERR_ZIP64);
			return;
		}
		entry.filenameLength = data.view.getUint16(index + 22, true);
		entry.extraFieldLength = data.view.getUint16(index + 24, true);
	}

	function createZipReader(reader, callback, onerror) {
		var inflateSN = 0;

		function Entry() {
		}

		Entry.prototype.getData = function(writer, onend, onprogress, checkCrc32) {
			var that = this;

			function testCrc32(crc32) {
				var dataCrc32 = getDataHelper(4);
				dataCrc32.view.setUint32(0, crc32);
				return that.crc32 == dataCrc32.view.getUint32(0);
			}

			function getWriterData(uncompressedSize, crc32) {
				if (checkCrc32 && !testCrc32(crc32))
					onerror(ERR_CRC);
				else
					writer.getData(function(data) {
						onend(data);
					});
			}

			function onreaderror(err) {
				onerror(err || ERR_READ_DATA);
			}

			function onwriteerror(err) {
				onerror(err || ERR_WRITE_DATA);
			}

			reader.readUint8Array(that.offset, 30, function(bytes) {
				var data = getDataHelper(bytes.length, bytes), dataOffset;
				if (data.view.getUint32(0) != 0x504b0304) {
					onerror(ERR_BAD_FORMAT);
					return;
				}
				readCommonHeader(that, data, 4, false, onerror);
				dataOffset = that.offset + 30 + that.filenameLength + that.extraFieldLength;
				writer.init(function() {
					if (that.compressionMethod === 0)
						copy(that._worker, inflateSN++, reader, writer, dataOffset, that.compressedSize, checkCrc32, getWriterData, onprogress, onreaderror, onwriteerror);
					else
						inflate(that._worker, inflateSN++, reader, writer, dataOffset, that.compressedSize, checkCrc32, getWriterData, onprogress, onreaderror, onwriteerror);
				}, onwriteerror);
			}, onreaderror);
		};

		function seekEOCDR(eocdrCallback) {
			// "End of central directory record" is the last part of a zip archive, and is at least 22 bytes long.
			// Zip file comment is the last part of EOCDR and has max length of 64KB,
			// so we only have to search the last 64K + 22 bytes of a archive for EOCDR signature (0x06054b50).
			var EOCDR_MIN = 22;
			if (reader.size < EOCDR_MIN) {
				onerror(ERR_BAD_FORMAT);
				return;
			}
			var ZIP_COMMENT_MAX = 256 * 256, EOCDR_MAX = EOCDR_MIN + ZIP_COMMENT_MAX;

			// In most cases, the EOCDR is EOCDR_MIN bytes long
			doSeek(EOCDR_MIN, function() {
				// If not found, try within EOCDR_MAX bytes
				doSeek(Math.min(EOCDR_MAX, reader.size), function() {
					onerror(ERR_BAD_FORMAT);
				});
			});

			// seek last length bytes of file for EOCDR
			function doSeek(length, eocdrNotFoundCallback) {
				reader.readUint8Array(reader.size - length, length, function(bytes) {
					for (var i = bytes.length - EOCDR_MIN; i >= 0; i--) {
						if (bytes[i] === 0x50 && bytes[i + 1] === 0x4b && bytes[i + 2] === 0x05 && bytes[i + 3] === 0x06) {
							eocdrCallback(new DataView(bytes.buffer, i, EOCDR_MIN));
							return;
						}
					}
					eocdrNotFoundCallback();
				}, function() {
					onerror(ERR_READ);
				});
			}
		}

		var zipReader = {
			getEntries : function(callback) {
				var worker = this._worker;
				// look for End of central directory record
				seekEOCDR(function(dataView) {
					var datalength, fileslength;
					datalength = dataView.getUint32(16, true);
					fileslength = dataView.getUint16(8, true);
					if (datalength < 0 || datalength >= reader.size) {
						onerror(ERR_BAD_FORMAT);
						return;
					}
					reader.readUint8Array(datalength, reader.size - datalength, function(bytes) {
						var i, index = 0, entries = [], entry, filename, comment, data = getDataHelper(bytes.length, bytes);
						for (i = 0; i < fileslength; i++) {
							entry = new Entry();
							entry._worker = worker;
							if (data.view.getUint32(index) != 0x504b0102) {
								onerror(ERR_BAD_FORMAT);
								return;
							}
							readCommonHeader(entry, data, index + 6, true, onerror);
							entry.commentLength = data.view.getUint16(index + 32, true);
							entry.directory = ((data.view.getUint8(index + 38) & 0x10) == 0x10);
							entry.offset = data.view.getUint32(index + 42, true);
							filename = getString(data.array.subarray(index + 46, index + 46 + entry.filenameLength));
							entry.filename = ((entry.bitFlag & 0x0800) === 0x0800) ? decodeUTF8(filename) : decodeASCII(filename);
							if (!entry.directory && entry.filename.charAt(entry.filename.length - 1) == "/")
								entry.directory = true;
							comment = getString(data.array.subarray(index + 46 + entry.filenameLength + entry.extraFieldLength, index + 46
									+ entry.filenameLength + entry.extraFieldLength + entry.commentLength));
							entry.comment = ((entry.bitFlag & 0x0800) === 0x0800) ? decodeUTF8(comment) : decodeASCII(comment);
							entries.push(entry);
							index += 46 + entry.filenameLength + entry.extraFieldLength + entry.commentLength;
						}
						callback(entries);
					}, function() {
						onerror(ERR_READ);
					});
				});
			},
			close : function(callback) {
				if (this._worker) {
					this._worker.terminate();
					this._worker = null;
				}
				if (callback)
					callback();
			},
			_worker: null
		};

		if (!obj.zip.useWebWorkers)
			callback(zipReader);
		else {
			createWorker('inflater',
				function(worker) {
					zipReader._worker = worker;
					callback(zipReader);
				},
				function(err) {
					onerror(err);
				}
			);
		}
	}

	// ZipWriter

	function encodeUTF8(string) {
		return unescape(encodeURIComponent(string));
	}

	function getBytes(str) {
		var i, array = [];
		for (i = 0; i < str.length; i++)
			array.push(str.charCodeAt(i));
		return array;
	}

	function createZipWriter(writer, callback, onerror, dontDeflate) {
		var files = {}, filenames = [], datalength = 0;
		var deflateSN = 0;

		function onwriteerror(err) {
			onerror(err || ERR_WRITE);
		}

		function onreaderror(err) {
			onerror(err || ERR_READ_DATA);
		}

		var zipWriter = {
			add : function(name, reader, onend, onprogress, options) {
				var header, filename, date;
				var worker = this._worker;

				function writeHeader(callback) {
					var data;
					date = options.lastModDate || new Date();
					header = getDataHelper(26);
					files[name] = {
						headerArray : header.array,
						directory : options.directory,
						filename : filename,
						offset : datalength,
						comment : getBytes(encodeUTF8(options.comment || ""))
					};
					header.view.setUint32(0, 0x14000808);
					if (options.version)
						header.view.setUint8(0, options.version);
					if (!dontDeflate && options.level !== 0 && !options.directory)
						header.view.setUint16(4, 0x0800);
					header.view.setUint16(6, (((date.getHours() << 6) | date.getMinutes()) << 5) | date.getSeconds() / 2, true);
					header.view.setUint16(8, ((((date.getFullYear() - 1980) << 4) | (date.getMonth() + 1)) << 5) | date.getDate(), true);
					header.view.setUint16(22, filename.length, true);
					data = getDataHelper(30 + filename.length);
					data.view.setUint32(0, 0x504b0304);
					data.array.set(header.array, 4);
					data.array.set(filename, 30);
					datalength += data.array.length;
					writer.writeUint8Array(data.array, callback, onwriteerror);
				}

				function writeFooter(compressedLength, crc32) {
					var footer = getDataHelper(16);
					datalength += compressedLength || 0;
					footer.view.setUint32(0, 0x504b0708);
					if (typeof crc32 != "undefined") {
						header.view.setUint32(10, crc32, true);
						footer.view.setUint32(4, crc32, true);
					}
					if (reader) {
						footer.view.setUint32(8, compressedLength, true);
						header.view.setUint32(14, compressedLength, true);
						footer.view.setUint32(12, reader.size, true);
						header.view.setUint32(18, reader.size, true);
					}
					writer.writeUint8Array(footer.array, function() {
						datalength += 16;
						onend();
					}, onwriteerror);
				}

				function writeFile() {
					options = options || {};
					name = name.trim();
					if (options.directory && name.charAt(name.length - 1) != "/")
						name += "/";
					if (files.hasOwnProperty(name)) {
						onerror(ERR_DUPLICATED_NAME);
						return;
					}
					filename = getBytes(encodeUTF8(name));
					filenames.push(name);
					writeHeader(function() {
						if (reader)
							if (dontDeflate || options.level === 0)
								copy(worker, deflateSN++, reader, writer, 0, reader.size, true, writeFooter, onprogress, onreaderror, onwriteerror);
							else
								deflate(worker, deflateSN++, reader, writer, options.level, writeFooter, onprogress, onreaderror, onwriteerror);
						else
							writeFooter();
					}, onwriteerror);
				}

				if (reader)
					reader.init(writeFile, onreaderror);
				else
					writeFile();
			},
			close : function(callback) {
				if (this._worker) {
					this._worker.terminate();
					this._worker = null;
				}

				var data, length = 0, index = 0, indexFilename, file;
				for (indexFilename = 0; indexFilename < filenames.length; indexFilename++) {
					file = files[filenames[indexFilename]];
					length += 46 + file.filename.length + file.comment.length;
				}
				data = getDataHelper(length + 22);
				for (indexFilename = 0; indexFilename < filenames.length; indexFilename++) {
					file = files[filenames[indexFilename]];
					data.view.setUint32(index, 0x504b0102);
					data.view.setUint16(index + 4, 0x1400);
					data.array.set(file.headerArray, index + 6);
					data.view.setUint16(index + 32, file.comment.length, true);
					if (file.directory)
						data.view.setUint8(index + 38, 0x10);
					data.view.setUint32(index + 42, file.offset, true);
					data.array.set(file.filename, index + 46);
					data.array.set(file.comment, index + 46 + file.filename.length);
					index += 46 + file.filename.length + file.comment.length;
				}
				data.view.setUint32(index, 0x504b0506);
				data.view.setUint16(index + 8, filenames.length, true);
				data.view.setUint16(index + 10, filenames.length, true);
				data.view.setUint32(index + 12, length, true);
				data.view.setUint32(index + 16, datalength, true);
				writer.writeUint8Array(data.array, function() {
					writer.getData(callback);
				}, onwriteerror);
			},
			_worker: null
		};

		if (!obj.zip.useWebWorkers)
			callback(zipWriter);
		else {
			createWorker('deflater',
				function(worker) {
					zipWriter._worker = worker;
					callback(zipWriter);
				},
				function(err) {
					onerror(err);
				}
			);
		}
	}

	function resolveURLs(urls) {
		var a = document.createElement('a');
		return urls.map(function(url) {
			a.href = url;
			return a.href;
		});
	}

	var DEFAULT_WORKER_SCRIPTS = {
		deflater: ['z-worker.js', 'deflate.js'],
		inflater: ['z-worker.js', 'inflate.js']
	};
	function createWorker(type, callback, onerror) {
		if (obj.zip.workerScripts !== null && obj.zip.workerScriptsPath !== null) {
			onerror(new Error('Either zip.workerScripts or zip.workerScriptsPath may be set, not both.'));
			return;
		}
		var scripts;
		if (obj.zip.workerScripts) {
			scripts = obj.zip.workerScripts[type];
			if (!Array.isArray(scripts)) {
				onerror(new Error('zip.workerScripts.' + type + ' is not an array!'));
				return;
			}
			scripts = resolveURLs(scripts);
		} else {
			scripts = DEFAULT_WORKER_SCRIPTS[type].slice(0);
			scripts[0] = (obj.zip.workerScriptsPath || '') + scripts[0];
		}
		var worker = new Worker(scripts[0]);
		// record total consumed time by inflater/deflater/crc32 in this worker
		worker.codecTime = worker.crcTime = 0;
		worker.postMessage({ type: 'importScripts', scripts: scripts.slice(1) });
		worker.addEventListener('message', onmessage);
		function onmessage(ev) {
			var msg = ev.data;
			if (msg.error) {
				worker.terminate(); // should before onerror(), because onerror() may throw.
				onerror(msg.error);
				return;
			}
			if (msg.type === 'importScripts') {
				worker.removeEventListener('message', onmessage);
				worker.removeEventListener('error', errorHandler);
				callback(worker);
			}
		}
		// catch entry script loading error and other unhandled errors
		worker.addEventListener('error', errorHandler);
		function errorHandler(err) {
			worker.terminate();
			onerror(err);
		}
	}

	function onerror_default(error) {
		console.error(error);
	}
	obj.zip = {
		Reader : Reader,
		Writer : Writer,
		BlobReader : BlobReader,
		Data64URIReader : Data64URIReader,
		TextReader : TextReader,
		BlobWriter : BlobWriter,
		Data64URIWriter : Data64URIWriter,
		TextWriter : TextWriter,
		createReader : function(reader, callback, onerror) {
			onerror = onerror || onerror_default;

			reader.init(function() {
				createZipReader(reader, callback, onerror);
			}, onerror);
		},
		createWriter : function(writer, callback, onerror, dontDeflate) {
			onerror = onerror || onerror_default;
			dontDeflate = !!dontDeflate;

			writer.init(function() {
				createZipWriter(writer, callback, onerror, dontDeflate);
			}, onerror);
		},
		useWebWorkers : true,
		/**
		 * Directory containing the default worker scripts (z-worker.js, deflate.js, and inflate.js), relative to current base url.
		 * E.g.: zip.workerScripts = './';
		 */
		workerScriptsPath : null,
		/**
		 * Advanced option to control which scripts are loaded in the Web worker. If this option is specified, then workerScriptsPath must not be set.
		 * workerScripts.deflater/workerScripts.inflater should be arrays of urls to scripts for deflater/inflater, respectively.
		 * Scripts in the array are executed in order, and the first one should be z-worker.js, which is used to start the worker.
		 * All urls are relative to current base url.
		 * E.g.:
		 * zip.workerScripts = {
		 *   deflater: ['z-worker.js', 'deflate.js'],
		 *   inflater: ['z-worker.js', 'inflate.js']
		 * };
		 */
		workerScripts : null,
	};
	window.zip = obj.zip;

})(this);

},{}],6:[function(require,module,exports){
module.exports = "data:application/font-woff;base64,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u8LuSsJP+OywsMPCDgs7LOywsMPCDgs7LIIv+OyysMvCLgu7LOyyCL7gC77gV+FX4VfhV+FX4VfhV+FX4VfhV+FX4VfhV+FX4VfhV+HX4Nfg1+DX4Nfg1+DX4Nfg1+DX4Nfg1+DX4Nfg1+DX4Nfh1+HX4dfh1+HX4dfh1+HX4dfh1+HX4dfh1+E3eU+T9zR5T5P3NHlPk/c0eU+T9zTHvIfv0eR7tPgeLb5Hi+/R4nu0+B4t+C34Lfgt+C34Lfgt+C34Lfgt+C34bfht+G34bfht+G34bfht+G34bfht+G04bTgdOB04HTgdOB04HTgd3t/hvR3e2+XzXT7f5fNdPt/lc11+ry6f7/L9e/wePT7X43M9/l6Pf7ce/259/n6fv9fn9+vz79CH14fXH/O5f3mJ/xP/J55PPJ94PvF64u/E34m/E38n/k78nfg78Xfi78Tfib8TbyXeSryVeCvxVuKtxFuJtxJvJd5KvJV4K/FW4q3EW4m3Em8l3kq8lXgr8VbircRbibcSbyXeSryVeCvxVuKtxFuJtxJvJd5KvJV4K/FW4q3EW4m3Em8l3kq8lXgr8VbircRbibcSbyXeSryVeCvxVuKtxFuJtxJvJd5KvJV4K/FW4q3EW1mHX4ffgN+A34DfgN+A34DfgN+A34DfgN+A34DfgN+A34DfgN+E34TfhN+E34SPbxPfJr5NfJv4NvFt4tvEt4lvE98mvk18m/g28W3i28S3iW8T3ya+TXyb+DbxbeLbxLeJbxPfJr5NfJv4NvFt4tvEt4lvE98mvk18m/g28W224bfht+Hj4cTDiYcTDyceTjyceDjxcHbg4+PswMfLiZezA78DvwO/A78DvwsfjyceTzyeeDy78Lvw8Xri9cTr2YXfhd+Fj++zC78LH/9nD34PPj1IepA9+D34Pfg9+PQie/DpRtKN7MHvwe/BpyfZh9+H34dPZ5LOJJ1JOpN0JrlbkrsluVuS/uSY/nC3JHeLuFvE3SLuFnG3iLtFdEt0S9wt4m4Rd4vomeiZ6Jm4W8TdIvom7hZxt4i7RXRPdE90T3RPdE90T3RPdE90T3RPdE/cLeJuEXeLuFvE3SLuFnG3iLtF3C3ibhF3i7hbxN0i7hZxt4i7Rdwt4m4Rd4u4W8TdIu4WcbeIu0XcLeJuEXeLuFvE3SLuFnG3iLtF3C2i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/+rX/wHuf9d/AAAAAAAB//8AAnjaY2BgYGQAgjO2i86D6AvLjCdB6SkAS/0G9AA=";

},{}],7:[function(require,module,exports){
module.exports = "data:image/gif;base64,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";

},{}],8:[function(require,module,exports){
module.exports = "data:application/font-woff;base64,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";

},{}],9:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("babel-runtime/helpers/interop-require-default")["default"];

exports.__esModule = true;

var _libSourceV2StyleJs = require("lib-source/v2/style.js");

var _libSourceUiv2RippleJs = require("lib-source/uiv2/ripple.js");

var _libSourceUiv2RippleJs2 = _interopRequireDefault(_libSourceUiv2RippleJs);

var _libSourceUiv2IconJs = require('lib-source/uiv2/icon.js');

var _libSourceUiv2IconJs2 = _interopRequireDefault(_libSourceUiv2IconJs);

var _libSourceUiv2Touchable = require('lib-source/uiv2/Touchable');

var _libSourceUiv2Touchable2 = _interopRequireDefault(_libSourceUiv2Touchable);

var _libSourceUiv2Vars = require('lib-source/uiv2/vars');

var _libSourceUiv2Vars2 = _interopRequireDefault(_libSourceUiv2Vars);

var _libSourceV2Utils = require('lib-source/v2/utils');

_libSourceV2StyleJs.defineComponentStyle('button', 'core', {
    "wrapper": {
        position: 'relative',
        textAlign: 'center',
        margin: 4,
        overflow: 'hidden',
        zIndex: "+0",
        whiteSpace: 'pre',
        display: 'inline-block',
        backgroundColor: 'transparent',
        color: 'black',
        borderRadius: 3
    },
    "wrapper:focus": {
        outline: 'none'
    },
    "wrapper[disabled]": {
        backgroundColor: '#eaeaea',
        color: '#a0a0a0'
    },
    "text-wrapper": {
        display: 'table',
        width: '100%'
    },
    "text": {
        height: '100%',
        width: '100%',
        padding: 5,
        paddingLeft: 15,
        paddingRight: 15,
        textAlign: 'center',
        verticalAlign: 'middle',
        whiteSpace: 'pre',
        display: 'table-cell'
    },
    "wrapper > overlay": {
        position: 'absolute',
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        transition: 'background-color 500ms linear'
    },
    ".core-desktop overlay:hover": {
        backgroundColor: _libSourceUiv2Vars2["default"].hoverColor
    },
    "wrapper:active > overlay": {
        backgroundColor: _libSourceUiv2Vars2["default"].activeColor,
        transition: 'none'
    }
});

var Button = function Button(props) {
    var text = props.text;
    var _props$onTap = props.onTap;
    var onTap = _props$onTap === undefined ? function () {
        return console.warn("No onTap given to Button");
    } : _props$onTap;
    var _props$styleName = props.styleName;
    var styleName = _props$styleName === undefined ? "core" : _props$styleName;
    var _props$buttonColor = props.buttonColor;
    var buttonColor = _props$buttonColor === undefined ? null : _props$buttonColor;
    var _props$textColor = props.textColor;
    var textColor = _props$textColor === undefined ? null : _props$textColor;
    var flush = props.flush;
    var block = props.block;
    var fill = props.fill;
    var padding = props.padding;
    var disabled = props.disabled;
    var _props$iconName = props.iconName;
    var iconName = _props$iconName === undefined ? null : _props$iconName;
    var _props$iconSize = props.iconSize;
    var iconSize = _props$iconSize === undefined ? null : _props$iconSize;

    var wrapperName = "button-core-wrapper button-" + styleName + "-wrapper-custom";

    var wrapperStyle = { backgroundColor: buttonColor };
    var textWrapperStyle = {};
    var textStyle = { color: textColor };
    var rippleElement = undefined;
    var onTapHandler = undefined;

    if (disabled !== true) {
        // rippleElement = <Ripple />;
        onTapHandler = onTap;
    }
    if (block === true) {
        wrapperStyle.display = 'block';
    }
    if (fill === true) {
        flush = true;
        wrapperStyle.width = '100%';
        wrapperStyle.height = '100%';
        textWrapperStyle.height = '100%';
        textStyle.padding = 0;
    }
    if (flush === true) {
        wrapperStyle.margin = 0;
    }
    if (iconName !== null) {
        text = React.createElement(
            "span",
            null,
            React.createElement(_libSourceUiv2IconJs2["default"], { name: iconName, size: iconSize }),
            text
        );
    }

    return React.createElement(
        _libSourceUiv2Touchable2["default"],
        { component: "div", tabIndex: -1, className: wrapperName, onTap: onTapHandler, disabled: disabled, style: wrapperStyle },
        React.createElement(
            "div",
            { className: "button-core-text-wrapper", style: textWrapperStyle },
            React.createElement(
                "div",
                { className: "button-core-text", style: textStyle },
                text
            )
        ),
        React.createElement("div", { className: "button-core-overlay" }),
        rippleElement
    );
};
Button.componentName = 'button';

_libSourceV2StyleJs.defineCustomBase(Button, function (_ref) {
    var _ref$normal = _ref.normal;
    var normal = _ref$normal === undefined ? null : _ref$normal;
    var _ref$focus = _ref.focus;
    var focus = _ref$focus === undefined ? null : _ref$focus;
    var _ref$disabled = _ref.disabled;
    var disabled = _ref$disabled === undefined ? null : _ref$disabled;
    return _libSourceV2Utils.transferProps({
        ".button-core-wrapper/wrapper-custom": [normal, {
            textColor: 'color',
            color: 'backgroundColor',
            borderRadius: 'borderRadius',
            shadow: 'boxShadow'
        }
        // ['backgroundColor', 'color', 'borderRadius', 'boxShadow']
        ],
        ".button-core-wrapper/wrapper-custom:focus": [focus, {
            textColor: 'color',
            color: 'backgroundColor',
            borderRadius: 'borderRadius',
            shadow: 'boxShadow'
        }
        // ['backgroundColor', 'color', 'borderRadius', 'boxShadow']
        ],
        ".button-core-wrapper/wrapper-custom[disabled]": [disabled, {
            textColor: 'color',
            color: 'backgroundColor',
            borderRadius: 'borderRadius',
            shadow: 'boxShadow'
        }
        // ['backgroundColor', 'color', 'borderRadius', 'boxShadow']
        ]
    });
});

_libSourceV2StyleJs.defineStyleForComponent(Button, "cancel", {
    normal: {
        color: "#b5263e",
        textColor: 'white'
    }
});
_libSourceV2StyleJs.defineStyleForComponent(Button, "confirm", {
    normal: {
        color: "#30d5a7"
    }
});

exports["default"] = Button;
module.exports = exports["default"];

},{"babel-runtime/helpers/interop-require-default":61,"lib-source/uiv2/Touchable":24,"lib-source/uiv2/icon.js":27,"lib-source/uiv2/ripple.js":36,"lib-source/uiv2/vars":37,"lib-source/v2/style.js":43,"lib-source/v2/utils":44}],10:[function(require,module,exports){
"use strict";

var _inherits = require("babel-runtime/helpers/inherits")["default"];

var _classCallCheck = require("babel-runtime/helpers/class-call-check")["default"];

var _extends = require("babel-runtime/helpers/extends")["default"];

var _interopRequireDefault = require("babel-runtime/helpers/interop-require-default")["default"];

exports.__esModule = true;

var _libSourceV2Style = require("lib-source/v2/style");

var _libSourceUiv2Button = require("lib-source/uiv2/Button");

var _libSourceUiv2Button2 = _interopRequireDefault(_libSourceUiv2Button);

var _libSourceUiv2CenterContent = require('lib-source/uiv2/CenterContent');

var _libSourceUiv2CenterContent2 = _interopRequireDefault(_libSourceUiv2CenterContent);

var coolBlue = "#2FB1DF";
_libSourceV2Style.defineComponentStyle('calendar', 'core', {
    'day': {
        height: '100%',
        fontSize: 14,
        textAlign: 'center'
    },
    "day[data-inactive]": {
        color: 'lightgray',
        paddingTop: 4
    }
});
/*bgcolor textcolor all 3*/
// const Calendar = ({selectedDate}) =>

var Calendar = (function (_React$Component) {
    _inherits(Calendar, _React$Component);

    function Calendar(props) {
        var _this = this;

        _classCallCheck(this, Calendar);

        _React$Component.call(this, props);

        this.prevMonth = function () {
            var _state = _this.state;
            var month = _state.month;
            var year = _state.year;

            month -= 1;

            if (month === -1) {
                month = 11;
                year -= 1;
            }

            _this.setState({ month: month, year: year });
        };

        this.nextMonth = function () {
            var _state2 = _this.state;
            var month = _state2.month;
            var year = _state2.year;

            month += 1;

            if (month === 12) {
                month = 0;
                year += 1;
            }

            _this.setState({ month: month, year: year });
        };

        this.select = function (date) {
            var _props$onChange = _this.props.onChange;
            var onChange = _props$onChange === undefined ? function () {} : _props$onChange;

            // console.log(date.toString());
            onChange(date);
        };

        this.render = function () {
            var selectedDate = _this.props.selectedDate;
            var _state3 = _this.state;
            var month = _state3.month;
            var year = _state3.year;

            var baseDate = chrono({ month: month, year: year }).startOf('week');

            var current = chrono(selectedDate);

            return React.createElement(
                "div",
                { style: { color: 'black' } },
                React.createElement(
                    UI.Pinboard,
                    { height: 30 },
                    React.createElement("div", { pinInfo: { backgroundColor: coolBlue, top: 0, left: 0, bottom: 0, right: 0 } }),
                    React.createElement(_libSourceUiv2Button2["default"], { pinInfo: { top: 0, left: 0, height: '100%', width: 30 }, iconName: "ion-arrow-left-b", fill: true, flush: true, onTap: _this.prevMonth, textColor: "white" }),
                    React.createElement(
                        _libSourceUiv2CenterContent2["default"],
                        { pinInfo: { top: 0, left: 30, right: 30, bottom: 0, color: 'white' }, height: "100%" },
                        month + 1,
                        "/",
                        year
                    ),
                    React.createElement(_libSourceUiv2Button2["default"], { pinInfo: { top: 0, right: 0, height: '100%', width: 30 }, iconName: "ion-arrow-right-b", fill: true, flush: true, onTap: _this.nextMonth, textColor: "white" })
                ),
                React.createElement(
                    UI.Grid,
                    { colCount: 7, rowCount: 7, height: 195 },
                    ['s', 'm', 't', 'w', 't', 'f', 's'].map(function (letter) {
                        return React.createElement(
                            _libSourceUiv2CenterContent2["default"],
                            { key: letter },
                            letter.toUpperCase()
                        );
                    }),
                    factotum.range(42, function (n) {
                        var date = baseDate.shift(n, 'days');
                        var dateValue = selectedDate.set({ month: date.month, year: date.year, date: date.date });

                        if (date.month === month) {
                            var buttonStyle = {};

                            if (date.year === current.year && date.month === current.month && date.date === current.date) {
                                buttonStyle = {
                                    buttonColor: coolBlue,
                                    textColor: 'white'
                                };
                            }

                            return React.createElement(
                                "div",
                                { className: "calendar-core-day", key: n },
                                React.createElement(_libSourceUiv2Button2["default"], _extends({ text: date.date + 1, flush: true, fill: true, onTap: function () {
                                        return _this.select(dateValue);
                                    } }, buttonStyle))
                            );
                        } else {
                            return React.createElement(
                                "div",
                                { key: n, className: "calendar-core-day", "data-inactive": true },
                                date.date + 1
                            );
                        }
                    })
                )
            );
        };

        this.state = {
            month: props.selectedDate.month,
            year: props.selectedDate.year
        };
    }

    return Calendar;
})(React.Component);

Calendar.componentStyleName = 'calendar';

Calendar.valueProp = "selectedDate";
Calendar.valueFunction = function (date) {
    return date;
};
Calendar.defaultPropValue = function () {
    return chrono();
};

exports["default"] = Calendar;
module.exports = exports["default"];

},{"babel-runtime/helpers/class-call-check":58,"babel-runtime/helpers/extends":59,"babel-runtime/helpers/inherits":60,"babel-runtime/helpers/interop-require-default":61,"lib-source/uiv2/Button":9,"lib-source/uiv2/CenterContent":12,"lib-source/v2/style":43}],11:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _libSourceV2Style = require("lib-source/v2/style");

_libSourceV2Style.defineComponentStyle('card', 'core', {
    "container": {
        margin: 5,
        padding: 5,
        boxShadow: '1px 2px 2px rgba(120, 120, 120, 0.15)',
        border: '1px solid #e0e0e0',
        backgroundColor: 'white',
        borderRadius: 3
    },
    "title": {
        fontSize: 20,
        padding: 3,
        color: 'black'
    }
});
var Card = function Card(_ref) {
    var children = _ref.children;
    var _ref$title = _ref.title;
    var title = _ref$title === undefined ? null : _ref$title;

    var content = undefined;

    if (title === null) {
        content = children;
    } else {
        content = React.createElement(
            'div',
            null,
            React.createElement(
                'div',
                { className: 'card-core-title' },
                title
            ),
            children
        );
    }

    return React.createElement(
        'div',
        { className: 'card-core-container' },
        content
    );
};
Card.componentStyleName = 'card';

exports['default'] = Card;
module.exports = exports['default'];

},{"lib-source/v2/style":43}],12:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _libSourceV2Style = require("lib-source/v2/style");

_libSourceV2Style.defineComponentStyle('center-content', 'core', {
    'container': {
        display: 'table',
        whiteSpace: 'pre',
        textAlign: 'center',
        width: '100%'
    },
    'content': {
        display: 'table-cell',
        verticalAlign: 'middle',
        padding: 'auto'
    }
});
var CenterContent = function CenterContent(_ref) {
    var children = _ref.children;
    var width = _ref.width;
    var height = _ref.height;
    var _ref$className = _ref.className;
    var className = _ref$className === undefined ? "" : _ref$className;
    return React.createElement(
        'div',
        { className: 'center-content-core-container ' + className, style: { width: width, height: height } },
        React.createElement(
            'div',
            { className: 'center-content-core-content' },
            React.createElement(
                'div',
                { style: { margin: 'auto', display: 'inline-block' } },
                children
            )
        )
    );
};

exports['default'] = CenterContent;
module.exports = exports['default'];

},{"lib-source/v2/style":43}],13:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("babel-runtime/helpers/interop-require-default")["default"];

exports.__esModule = true;

var _libSourceV2Style = require("lib-source/v2/style");

var _libSourceUiv2CenterContent = require("lib-source/uiv2/CenterContent");

var _libSourceUiv2CenterContent2 = _interopRequireDefault(_libSourceUiv2CenterContent);

// import Ripple from "lib-source/uiv2/Ripple";

var _libSourceUiv2Icon = require("lib-source/uiv2/Icon");

var _libSourceUiv2Icon2 = _interopRequireDefault(_libSourceUiv2Icon);

var _libSourceUiv2Vars = require('lib-source/uiv2/vars');

var _libSourceUiv2Vars2 = _interopRequireDefault(_libSourceUiv2Vars);

var _libSourceV2Utils = require('lib-source/v2/utils');

_libSourceV2Style.defineComponentStyle('checkbox', 'core', {
    "container": {
        position: 'relative',
        transition: 'background-color 500ms linear',
        fontSize: 20,
        overflow: 'hidden'
    },
    "container:active": {
        backgroundColor: 'rgba(0, 0, 0, 0.075)',
        transition: 'none'
    },
    "icon": {
        position: 'absolute',
        top: 0,
        right: 0,
        bottom: 0,
        width: 30,
        color: 'black',
        fontSize: 24,
        transition: 'color 250ms linear'
    },
    "icon[data-checked='true']": {
        color: '#24b324'
    },
    "label": {
        padding: 3,
        paddingRight: 30,
        whiteSpace: 'pre',
        color: 'black'
    },
    "subtitle": {
        color: 'gray',
        fontSize: 14
    }
});
var ionOnIcon = "ion-android-checkbox";
var ionOffIcon = "ion-android-checkbox-outline-blank";

var Checkbox = function Checkbox(props) {
    var _props$checked = props.checked;
    var checked = _props$checked === undefined ? false : _props$checked;
    var _props$onIconName = props.onIconName;
    var onIconName = _props$onIconName === undefined ? ionOnIcon : _props$onIconName;
    var _props$offIconName = props.offIconName;
    var offIconName = _props$offIconName === undefined ? ionOffIcon : _props$offIconName;
    var label = props.label;
    var _props$subTitle = props.subTitle;
    var subTitle = _props$subTitle === undefined ? null : _props$subTitle;
    var _props$onChange = props.onChange;
    var onChange = _props$onChange === undefined ? function () {
        return console.warn("No onChange given to checkbox");
    } : _props$onChange;
    var _props$styleName = props.styleName;
    var styleName = _props$styleName === undefined ? "core" : _props$styleName;

    var iconName = checked === true ? onIconName : offIconName;
    var iconClassName = "checkbox-core-icon checkbox-" + styleName + "-icon-custom";
    var labelClassName = "checkbox-core-label checkbox-" + styleName + "-label-custom";
    var content = label;

    if (subTitle !== null) {
        var subtitleClassName = "checkbox-core-subtitle checkbox-" + styleName + "-subtitle-custom";
        content = React.createElement(
            "div",
            null,
            label,
            React.createElement(
                "div",
                { className: subtitleClassName },
                subTitle
            )
        );
    }

    return React.createElement(
        UI.Touchable,
        { component: "div", className: "checkbox-core-container", onTap: function () {
                return onChange(!checked);
            } },
        React.createElement(
            "div",
            { className: iconClassName, "data-checked": checked },
            React.createElement(
                _libSourceUiv2CenterContent2["default"],
                { height: "100%" },
                React.createElement(_libSourceUiv2Icon2["default"], { name: iconName })
            )
        ),
        React.createElement(
            "div",
            { className: labelClassName },
            content
        )
    );
};
Checkbox.componentName = "checkbox";

Checkbox.valueProp = "checked";
Checkbox.valueFunction = function (checked) {
    return checked;
};
Checkbox.defaultPropValue = false;

_libSourceV2Style.defineCustomBase(Checkbox, function (_ref) {
    var _ref$normal = _ref.normal;
    var normal = _ref$normal === undefined ? null : _ref$normal;
    var _ref$checked = _ref.checked;
    var checked = _ref$checked === undefined ? null : _ref$checked;
    var _ref$label = _ref.label;
    var label = _ref$label === undefined ? null : _ref$label;
    var _ref$subtitle = _ref.subtitle;
    var subtitle = _ref$subtitle === undefined ? null : _ref$subtitle;
    return _libSourceV2Utils.transferProps({
        ".checkbox-core-icon/icon-custom": [normal, { iconColor: 'color' }],
        ".checkbox-core-icon/icon-custom[data-checked='true']": [checked, { iconColor: 'color' }],
        ".checkbox-core-label/label-custom": [label, {
            textColor: 'color',
            color: 'backgroundColor'
        }],
        ".checkbox-core-subtitle/subtitle-custom": [subtitle, {
            textColor: 'color',
            color: 'backgroundColor'
        }]
    });
});

exports["default"] = Checkbox;
module.exports = exports["default"];
/*<Ripple />*/

},{"babel-runtime/helpers/interop-require-default":61,"lib-source/uiv2/CenterContent":12,"lib-source/uiv2/Icon":16,"lib-source/uiv2/vars":37,"lib-source/v2/style":43,"lib-source/v2/utils":44}],14:[function(require,module,exports){
"use strict";

var _inherits = require("babel-runtime/helpers/inherits")["default"];

var _classCallCheck = require("babel-runtime/helpers/class-call-check")["default"];

var _extends = require("babel-runtime/helpers/extends")["default"];

var _objectWithoutProperties = require("babel-runtime/helpers/object-without-properties")["default"];

var _regeneratorRuntime = require("babel-runtime/regenerator")["default"];

var _interopRequireDefault = require("babel-runtime/helpers/interop-require-default")["default"];

exports.__esModule = true;

var _libSourceV2Style = require("lib-source/v2/style");

var _libSourceUiv2Button = require("lib-source/uiv2/Button");

var _libSourceUiv2Button2 = _interopRequireDefault(_libSourceUiv2Button);

var _libSourceUiv2Icon = require("lib-source/uiv2/Icon");

var _libSourceUiv2Icon2 = _interopRequireDefault(_libSourceUiv2Icon);

var _libSourceUiv2Option = require("lib-source/uiv2/Option");

var _libSourceUiv2Option2 = _interopRequireDefault(_libSourceUiv2Option);

var _libSourceUiv2Touchable = require("lib-source/uiv2/Touchable");

var _libSourceUiv2Touchable2 = _interopRequireDefault(_libSourceUiv2Touchable);

_libSourceV2Style.defineComponentStyle('combobox', 'core', {
    'container': {
        border: '1px solid lightgray',
        borderRadius: 3,
        // padding: 3,
        position: 'relative',
        color: 'black',
        height: 30
    },
    "icon": {
        position: 'absolute',
        top: '50%',
        right: 10,
        transform: 'translateY(-50%)',
        pointerEvents: 'none'
    }
});

// const comboboxSelect = (index, value) => dialog.success([index, value]);

var Combobox = (function (_React$Component) {
    _inherits(Combobox, _React$Component);

    function Combobox(props) {
        var _this = this;

        _classCallCheck(this, Combobox);

        _React$Component.call(this, props);

        this.openOptions = function callee$2$0() {
            var _props, _props$title, title, _props$scrollToSelected, scrollToSelected, selectedIndex, children, response, _props2;

            return _regeneratorRuntime.async(function callee$2$0$(context$3$0) {
                while (1) switch (context$3$0.prev = context$3$0.next) {
                    case 0:
                        _props = this.props;
                        _props$title = _props.title;
                        title = _props$title === undefined ? "Combobox!" : _props$title;
                        _props$scrollToSelected = _props.scrollToSelected;
                        scrollToSelected = _props$scrollToSelected === undefined ? false : _props$scrollToSelected;
                        selectedIndex = _props.selectedIndex;
                        children = React.Children.toArray(this.props.children);
                        context$3$0.next = 9;
                        return _regeneratorRuntime.awrap(dialog.show({
                            title: title,
                            content: children.map(function (_ref, index) {
                                var _ref$props = _ref.props;
                                var _ref$props$value = _ref$props.value;
                                var value = _ref$props$value === undefined ? null : _ref$props$value;
                                var children = _ref$props.children;
                                var _ref$props$style = _ref$props.style;
                                var style = _ref$props$style === undefined ? null : _ref$props$style;
                                var _ref$props$className = _ref$props.className;
                                var className = _ref$props$className === undefined ? null : _ref$props$className;

                                var onTap = function onTap() {
                                    return dialog.hide(dialog.success([index, value]));
                                };
                                return React.createElement(
                                    "div",
                                    _extends({ style: style, className: className }, { key: index }),
                                    React.createElement(_libSourceUiv2Button2["default"], { text: children, block: true, flush: true, onTap: onTap })
                                );
                            }),
                            buttons: [{ text: "Cancel", cancels: true }],
                            setup: function setup(container) {
                                if (scrollToSelected === true && selectedIndex !== -1) {
                                    container.scrollTop = container.children[selectedIndex].offsetTop - container.offsetTop;
                                }
                            }
                        }));

                    case 9:
                        response = context$3$0.sent;

                        if (response.status === "success") {
                            (_props2 = this.props).onChange.apply(_props2, response.value);
                        }

                    case 11:
                    case "end":
                        return context$3$0.stop();
                }
            }, null, _this);
        };

        this.render = function () {
            var _props3 = _this.props;
            var selectedIndex = _props3.selectedIndex;
            var children = _props3.children;
            var height = _props3.height;

            var buttonProps = _objectWithoutProperties(_props3, ["selectedIndex", "children", "height"]);

            var flattenedChildren = React.Children.toArray(children);
            var currentChild = "Please select an option";

            if (selectedIndex !== -1) {
                currentChild = flattenedChildren[selectedIndex].props.children;
            }

            return React.createElement(
                "div",
                { className: "combobox-core-container", style: { height: height } },
                React.createElement(_libSourceUiv2Button2["default"], _extends({}, buttonProps, { text: currentChild, block: true, flush: true, fill: true, onTap: _this.openOptions })),
                React.createElement(
                    "div",
                    { className: "combobox-core-icon" },
                    React.createElement(_libSourceUiv2Icon2["default"], { name: "ion-arrow-down-b", size: 24 })
                )
            );
        };
    }

    return Combobox;
})(React.Component);

Combobox.valueProp = "selectedIndex";
Combobox.valueFunction = function (index, value) {
    return { index: index, value: value };
};
Combobox.defaultPropValue = 0;

exports["default"] = Combobox;
module.exports = exports["default"];

},{"babel-runtime/helpers/class-call-check":58,"babel-runtime/helpers/extends":59,"babel-runtime/helpers/inherits":60,"babel-runtime/helpers/interop-require-default":61,"babel-runtime/helpers/object-without-properties":62,"babel-runtime/regenerator":149,"lib-source/uiv2/Button":9,"lib-source/uiv2/Icon":16,"lib-source/uiv2/Option":19,"lib-source/uiv2/Touchable":24,"lib-source/v2/style":43}],15:[function(require,module,exports){
'use strict';

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _extends = require('babel-runtime/helpers/extends')['default'];

var _objectWithoutProperties = require('babel-runtime/helpers/object-without-properties')['default'];

var _Object$entries = require('babel-runtime/core-js/object/entries')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

exports.__esModule = true;

var _libSourceUiv2Button = require("lib-source/uiv2/Button");

var _libSourceUiv2Button2 = _interopRequireDefault(_libSourceUiv2Button);

var ItemContainer = (function (_React$Component) {
    _inherits(ItemContainer, _React$Component);

    function ItemContainer(props) {
        var _this = this;

        _classCallCheck(this, ItemContainer);

        _React$Component.call(this, props);

        this.change = function () {
            var _props = _this.props;
            var updateForm = _props.updateForm;
            var _props$childInfo = _props.childInfo;
            var valueFunction = _props$childInfo.valueFunction;
            var name = _props$childInfo.name;

            _this.setState({ value: arguments[0] });
            updateForm(name, valueFunction.apply(undefined, arguments));
        };

        this.render = function () {
            var _valueObj;

            var _props$childInfo2 = _this.props.childInfo;
            var Renderer = _props$childInfo2.Renderer;
            var valueProp = _props$childInfo2.valueProp;
            var children = _props$childInfo2.children;
            var props = _props$childInfo2.props;
            var value = _this.state.value;

            var valueObj = (_valueObj = {}, _valueObj[valueProp] = value, _valueObj);

            return React.createElement(
                'div',
                null,
                React.createElement(
                    Renderer,
                    _extends({}, props, { onChange: _this.change }, valueObj),
                    children
                )
            );
        };

        this.state = { value: props.childInfo.initialValue };
    }

    return ItemContainer;
})(React.Component);

var Form = (function (_React$Component2) {
    _inherits(Form, _React$Component2);

    function Form(props) {
        var _this2 = this;

        _classCallCheck(this, Form);

        _React$Component2.call(this, props);

        this.updateInternalState = function (name, value) {
            _this2.internalState[name] = value;
        };

        this.submit = function (evt) {
            evt.preventDefault();
            evt.stopPropagation();

            var _props$onSubmit = _this2.props.onSubmit;
            var onSubmit = _props$onSubmit === undefined ? function (state) {
                return console.log(state);
            } : _props$onSubmit;

            onSubmit(_this2.internalState);
        };

        this.render = function () {
            var Container = _this2.Container;
            var childList = _this2.childList;
            var containerProps = _this2.containerProps;
            var _props$submitText = _this2.props.submitText;
            var submitText = _props$submitText === undefined ? "Submit" : _props$submitText;

            return React.createElement(
                'form',
                { onSubmit: _this2.submit, ref: 'form' },
                React.createElement(
                    Container,
                    containerProps,
                    childList
                ),
                React.createElement(_libSourceUiv2Button2['default'], { text: submitText, onTap: _this2.submit, block: true })
            );
        };

        var _props$itemContainer = props.itemContainer;
        var itemContainer = _props$itemContainer === undefined ? 'div' : _props$itemContainer;
        var _props$layout = props.layout;
        var layout = _props$layout === undefined ? null : _props$layout;

        var children = React.Children.toArray(props.children);
        var ElemContainer = undefined;

        this.internalState = {};

        if (layout === null) {
            this.Container = 'div';
            ElemContainer = itemContainer;
        } else {
            this.Container = layout;
            ElemContainer = layout.FormContainer || function (_ref) {
                var children = _ref.children;
                return children;
            };
            this.containerProps = _Object$entries(props).reduce(function (props, _ref2) {
                var key = _ref2[0];
                var value = _ref2[1];

                if (key.startsWith('layout-') === true) {
                    props[key.substr(7)] = value;
                }
                return props;
            }, {});
        }

        this.childList = children.map(function (child, index) {
            var elemType = child.type.parentInfo !== undefined ? child.type.parentInfo : child.type;
            var initValue = child.props.defaultPropValue || elemType.defaultPropValue;
            var _child$props = child.props;
            var _child$props$formName = _child$props.formName;
            var formName = _child$props$formName === undefined ? index : _child$props$formName;
            var chidren = _child$props.chidren;

            var childProps = _objectWithoutProperties(_child$props, ['formName', 'chidren']);

            var childInfo = {
                Renderer: child.type,
                props: childProps,
                children: child.props.children,
                valueProp: elemType.valueProp,
                valueFunction: elemType.valueFunction,
                initialValue: typeof initValue === 'function' ? initValue() : initValue,
                name: formName
            };
            var containerProps = _Object$entries(childProps).reduce(function (props, _ref3) {
                var key = _ref3[0];
                var value = _ref3[1];

                if (key.startsWith('layout-') === true) {
                    props[key.substr(7)] = value;
                }
                return props;
            }, {});
            // console.log(child, child.type, child.type === Checkbox);
            _this2.internalState[childInfo.name] = childInfo.valueFunction(childInfo.initialValue);
            return React.createElement(
                ElemContainer,
                _extends({}, containerProps, { key: index }),
                React.createElement(ItemContainer, { childInfo: childInfo, updateForm: _this2.updateInternalState })
            );
        });
    }

    return Form;
})(React.Component);

exports['default'] = Form;
module.exports = exports['default'];

},{"babel-runtime/core-js/object/entries":51,"babel-runtime/helpers/class-call-check":58,"babel-runtime/helpers/extends":59,"babel-runtime/helpers/inherits":60,"babel-runtime/helpers/interop-require-default":61,"babel-runtime/helpers/object-without-properties":62,"lib-source/uiv2/Button":9}],16:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _libSourceV2StyleJs = require("lib-source/v2/style.js");

_libSourceV2StyleJs.defineComponentStyle('icon', 'core', {
    "content": {
        fontFamily: "Ionic",
        marginLeft: 2,
        marginRight: 2
    }
});
var Icon = function Icon(_ref) {
    var name = _ref.name;
    var _ref$styleName = _ref.styleName;
    var styleName = _ref$styleName === undefined ? 'core' : _ref$styleName;
    var size = _ref.size;
    return React.createElement(
        'span',
        { className: 'icon-' + styleName + '-content', style: { fontSize: size } },
        ionic[name]
    );
};

exports['default'] = Icon;
module.exports = exports['default'];

},{"lib-source/v2/style.js":43}],17:[function(require,module,exports){
'use strict';

exports.__esModule = true;
var Image = function Image(_ref) {
    var source = _ref.source;
    var _ref$width = _ref.width;
    var width = _ref$width === undefined ? '100%' : _ref$width;
    var _ref$height = _ref.height;
    var height = _ref$height === undefined ? null : _ref$height;
    var _ref$imageSize = _ref.imageSize;
    var imageSize = _ref$imageSize === undefined ? 'fit' : _ref$imageSize;
    var color = _ref.color;
    var _ref$block = _ref.block;
    var block = _ref$block === undefined ? false : _ref$block;

    if (height === null) {
        throw new Error("Need to give image height");
    }

    var style = {
        display: block === true ? "block" : "inline-block",
        backgroundRepeat: 'no-repeat',
        backgroundPosition: 'center center',
        backgroundImage: 'url("' + source + '")',
        position: 'relative',
        backgroundColor: color,
        width: width,
        height: height
    };

    switch (imageSize) {
        case 'fit':
            style.backgroundSize = 'contain';
            break;

        case 'clip':
            style.backgroundSize = 'cover';
            break;

        default:
            style.backgroundSize = imageSize;
    }

    return React.createElement('div', { style: style });
};

exports['default'] = Image;
module.exports = exports['default'];

},{}],18:[function(require,module,exports){
'use strict';

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _extends = require('babel-runtime/helpers/extends')['default'];

var _objectWithoutProperties = require('babel-runtime/helpers/object-without-properties')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

exports.__esModule = true;

var _libSourceV2Style = require("lib-source/v2/style");

var _libSourceUiv2InputRangeInput = require('lib-source/uiv2/input/RangeInput');

var _libSourceUiv2InputRangeInput2 = _interopRequireDefault(_libSourceUiv2InputRangeInput);

var _libSourceUiv2InputDateInput = require('lib-source/uiv2/input/DateInput');

var _libSourceUiv2InputDateInput2 = _interopRequireDefault(_libSourceUiv2InputDateInput);

var _libSourceUiv2InputTimeInput = require('lib-source/uiv2/input/TimeInput');

var _libSourceUiv2InputTimeInput2 = _interopRequireDefault(_libSourceUiv2InputTimeInput);

var _libSourceUiv2InputFileInput = require('lib-source/uiv2/input/FileInput');

var _libSourceUiv2InputFileInput2 = _interopRequireDefault(_libSourceUiv2InputFileInput);

var _libSourceUiv2CenterContent = require('lib-source/uiv2/CenterContent');

var _libSourceUiv2CenterContent2 = _interopRequireDefault(_libSourceUiv2CenterContent);

var _libSourceUiv2Icon = require('lib-source/uiv2/Icon');

var _libSourceUiv2Icon2 = _interopRequireDefault(_libSourceUiv2Icon);

var _libSourceUiv2Touchable = require('lib-source/uiv2/Touchable');

var _libSourceUiv2Touchable2 = _interopRequireDefault(_libSourceUiv2Touchable);

var coolBlue = "#2FB1DF";

_libSourceV2Style.defineComponentStyle('input', 'core', {
    "$body": {
        WebkitTapHighlightColor: 'rgba(0, 0, 0, 0)'
    },
    "wrapper": {
        position: 'relative',
        backgroundColor: 'white',
        height: 32,
        margin: 3
    },
    "field": {
        width: '100%',
        borderWidth: 0,
        borderBottom: '2px solid lightgray',
        WebkitBorderRadius: 0,
        WebkitAppearance: 'none',
        borderRadius: 0,
        backgroundColor: 'transparent',
        margin: 0,
        height: '100%',
        position: 'relative',
        zIndex: '+1'
    },
    "field:focus": {
        outline: 'none'
    },
    "icon": {
        position: 'absolute',
        top: 0,
        left: 0,
        bottom: 0,
        width: 30
    },
    "highlight-border": {
        position: 'absolute',
        bottom: 0,
        borderBottom: '2px solid ' + coolBlue,
        left: '50%',
        transform: 'translateX(-50%) scaleX(0)',
        width: '100%',
        zIndex: '+2'
    },
    "field:focus + highlight-border": {
        // width: '100%',
        WebkitTransition: '-webkit-transform 250ms linear',
        transition: 'transform 150ms linear',
        transform: 'translateX(-50%) scaleX(1)'
    },
    "label": {
        color: "black",
        fontSize: 16,
        padding: 3
    }
});

var InputWrapper = (function (_React$Component) {
    _inherits(InputWrapper, _React$Component);

    function InputWrapper(props) {
        var _this = this;

        _classCallCheck(this, InputWrapper);

        _React$Component.call(this, props);

        this.focus = function () {
            _this.refs.field.focus();
        };

        this.render = function () {
            var _props = _this.props;
            var _props$parser = _props.parser;
            var parser = _props$parser === undefined ? function (i) {
                return i;
            } : _props$parser;
            var _props$onChange = _props.onChange;
            var onChange = _props$onChange === undefined ? function () {} : _props$onChange;
            var _props$iconName = _props.iconName;
            var iconName = _props$iconName === undefined ? null : _props$iconName;
            var _props$style = _props.style;
            var style = _props$style === undefined ? {} : _props$style;
            var _props$borderRadius = _props.borderRadius;
            var borderRadius = _props$borderRadius === undefined ? null : _props$borderRadius;

            var props = _objectWithoutProperties(_props, ['parser', 'onChange', 'iconName', 'style', 'borderRadius']);

            var handler = function handler(evt) {
                // const raw = evt.target.value;
                onChange(parser(evt.target.value));
            };
            var realStyle = _extends({}, style);
            var borderStyle = {};
            var iconDisplay = null;

            if (iconName !== null) {
                iconDisplay = React.createElement(
                    _libSourceUiv2CenterContent2['default'],
                    { className: 'input-core-icon', height: '100%' },
                    React.createElement(_libSourceUiv2Icon2['default'], { name: iconName, size: 18 })
                );
                realStyle.paddingLeft = 30;
            }
            if (borderRadius !== null) {
                realStyle.borderRadius = borderRadius;
                borderStyle.borderRadius = borderRadius;
            }

            return React.createElement(
                'div',
                { className: 'input-core-wrapper' },
                React.createElement('input', _extends({}, props, { style: realStyle, onChange: handler, className: 'input-core-field', ref: 'field' })),
                React.createElement('div', { className: 'input-core-highlight-border', style: borderStyle }),
                iconDisplay
            );
        };
    }

    return InputWrapper;
})(React.Component);

var LabeledInput = (function (_React$Component2) {
    _inherits(LabeledInput, _React$Component2);

    function LabeledInput(props) {
        var _this2 = this;

        _classCallCheck(this, LabeledInput);

        _React$Component2.call(this, props);

        this.focus = function () {
            _this2.refs.wrapped.focus();
        };

        this.render = function () {
            var _props2 = _this2.props;
            var label = _props2.label;
            var _props2$Wrapper = _props2.Wrapper;
            var Wrapper = _props2$Wrapper === undefined ? InputWrapper : _props2$Wrapper;

            var props = _objectWithoutProperties(_props2, ['label', 'Wrapper']);

            return React.createElement(
                'div',
                { style: { position: 'relative' } },
                React.createElement(
                    _libSourceUiv2Touchable2['default'],
                    { component: 'div', className: 'input-core-label', onTap: function () {
                            return _this2.refs.wrapped.focus();
                        } },
                    label
                ),
                React.createElement(Wrapper, _extends({ ref: 'wrapped' }, props))
            );
        };
    }

    return LabeledInput;
})(React.Component);

var ValidatedInput = (function (_React$Component3) {
    _inherits(ValidatedInput, _React$Component3);

    function ValidatedInput(props) {
        var _this3 = this;

        _classCallCheck(this, ValidatedInput);

        _React$Component3.call(this, props);

        this.focus = function () {
            _this3.refs.input.focus();
        };

        this.render = function () {
            var _props3 = _this3.props;
            var validator = _props3.validator;
            var _props3$onChange = _props3.onChange;
            var onChange = _props3$onChange === undefined ? function () {} : _props3$onChange;

            var props = _objectWithoutProperties(_props3, ['validator', 'onChange']);

            var changeHandler = function changeHandler(value) {
                return onChange(value, validator(value));
            };
            return React.createElement(LabeledInput, _extends({}, props, { onChange: changeHandler }));
        };
    }

    return ValidatedInput;
})(React.Component);

var Input = {
    Text: function Text(props) {
        return React.createElement(LabeledInput, _extends({}, props, { type: 'text' }));
    },
    Password: function Password(props) {
        return React.createElement(LabeledInput, _extends({}, props, { type: 'password' }));
    },
    Search: function Search(props) {
        return React.createElement(LabeledInput, _extends({}, props, { type: 'search', iconName: 'ion-search' }));
    },
    Date: _libSourceUiv2InputDateInput2['default'],
    Range: _libSourceUiv2InputRangeInput2['default'],
    Time: _libSourceUiv2InputTimeInput2['default'],
    File: _libSourceUiv2InputFileInput2['default'],
    // Date: props => <DateInput {...props} />,
    // Range: props => <RangeInput {...props} />,
    // Time: props => <TimeInput {...props} />,
    // File: props => <FileInput {...props} />,
    URL: function URL(_ref) {
        var _ref$validator = _ref.validator;
        var validator = _ref$validator === undefined ? function (url) {
            return (/^(https?:\/\/)?(\w+(\.\w+)+|localhost)(\/[\w\#\-\%]+)*\/?$/.test(url)
            );
        } : _ref$validator;

        var props = _objectWithoutProperties(_ref, ['validator']);

        return React.createElement(ValidatedInput, _extends({ validator: validator }, props, { type: 'url' }));
    },
    Email: function Email(_ref2) {
        var _ref2$validator = _ref2.validator;
        var validator = _ref2$validator === undefined ? function (email) {
            return (/^([a-zA-Z]\w*)(\.([a-zA-Z]\w*))*\@([a-zA-Z]\w*)(\.([a-zA-Z]\w*))+$/.test(email)
            );
        } : _ref2$validator;

        var props = _objectWithoutProperties(_ref2, ['validator']);

        return React.createElement(ValidatedInput, _extends({ validator: validator }, props, { type: 'email' }));
    }
};

Input.Text.valueProp = 'value';
Input.Text.valueFunction = function (text) {
    return text;
};
Input.Text.defaultPropValue = "";

Input.Password.valueProp = 'value';
Input.Password.valueFunction = function (text) {
    return text;
};
Input.Password.defaultPropValue = "";

Input.Search.valueProp = 'value';
Input.Search.valueFunction = function (text) {
    return text;
};
Input.Search.defaultPropValue = "";

Input.URL.valueProp = 'value';
Input.URL.valueFunction = function (text, valid) {
    return { text: text, valid: valid };
};
Input.URL.defaultPropValue = "";

Input.Email.valueProp = 'value';
Input.Email.valueFunction = function (text, valid) {
    return { text: text, valid: valid };
};
Input.Email.defaultPropValue = "";

exports['default'] = Input;
module.exports = exports['default'];

},{"babel-runtime/helpers/class-call-check":58,"babel-runtime/helpers/extends":59,"babel-runtime/helpers/inherits":60,"babel-runtime/helpers/interop-require-default":61,"babel-runtime/helpers/object-without-properties":62,"lib-source/uiv2/CenterContent":12,"lib-source/uiv2/Icon":16,"lib-source/uiv2/Touchable":24,"lib-source/uiv2/input/DateInput":29,"lib-source/uiv2/input/FileInput":30,"lib-source/uiv2/input/RangeInput":31,"lib-source/uiv2/input/TimeInput":32,"lib-source/v2/style":43}],19:[function(require,module,exports){
"use strict";

exports.__esModule = true;
var Option = function Option() {
    throw new Error("Option is intended as a filler element and should not be rendered on its own");
};

exports["default"] = Option;
module.exports = exports["default"];

},{}],20:[function(require,module,exports){
"use strict";

var _inherits = require("babel-runtime/helpers/inherits")["default"];

var _classCallCheck = require("babel-runtime/helpers/class-call-check")["default"];

var _objectWithoutProperties = require("babel-runtime/helpers/object-without-properties")["default"];

var _extends = require("babel-runtime/helpers/extends")["default"];

var _Object$entries = require("babel-runtime/core-js/object/entries")["default"];

var _interopRequireDefault = require("babel-runtime/helpers/interop-require-default")["default"];

exports.__esModule = true;

var _libSourceV2Style = require("lib-source/v2/style");

var _libSourceUiv2CenterContent = require("lib-source/uiv2/CenterContent");

var _libSourceUiv2CenterContent2 = _interopRequireDefault(_libSourceUiv2CenterContent);

var _libSourceUiv2Touchable = require("lib-source/uiv2/Touchable");

var _libSourceUiv2Touchable2 = _interopRequireDefault(_libSourceUiv2Touchable);

var _libSourceUiv2Icon = require("lib-source/uiv2/Icon");

var _libSourceUiv2Icon2 = _interopRequireDefault(_libSourceUiv2Icon);

_libSourceV2Style.defineComponentStyle('radio', 'core', {
    "title": {
        fontSize: 22,
        padding: 3
    }
});
_libSourceV2Style.defineComponentStyle("radio-item", "core", {
    "default-item": {
        color: 'black',
        position: 'relative',
        paddingLeft: 30,
        transition: 'background-color 500ms linear'
    },
    // ".radio-item-container:active > default-item": {
    "default-item:active": {
        backgroundColor: 'rgba(0, 0, 0, 0.1)',
        transition: 'none'
    },
    "icon": {
        position: 'absolute',
        top: 0,
        left: 0,
        bottom: 0,
        width: 30
    }
});
var RadioItem = function RadioItem(_ref) {
    var checked = _ref.checked;
    var iconColor = _ref.iconColor;
    var children = _ref.children;
    var onTap = _ref.onTap;

    var iconName = "ion-android-radio-button-" + (checked === true ? 'on' : 'off');
    return React.createElement(
        _libSourceUiv2Touchable2["default"],
        { component: "div", onTap: onTap, className: "radio-item-core-default-item", "data-checked": checked },
        React.createElement(
            "div",
            { className: "radio-item-core-icon", "data-checked": checked },
            React.createElement(
                _libSourceUiv2CenterContent2["default"],
                { height: "100%" },
                React.createElement(_libSourceUiv2Icon2["default"], { size: 18, name: iconName })
            )
        ),
        children
    );
};

var Radio = (function (_React$Component) {
    _inherits(Radio, _React$Component);

    function Radio(props) {
        var _this = this;

        _classCallCheck(this, Radio);

        _React$Component.call(this, props);

        this.select = function (index, value) {
            if (index !== _this.props.selectedIndex) {
                _this.props.onChange(index, value);
            }
        };

        this.render = function () {
            var _props = _this.props;
            var _props$layout = _props.layout;
            var layout = _props$layout === undefined ? 'div' : _props$layout;
            var selectedIndex = _props.selectedIndex;
            var _props$onChange = _props.onChange;
            var onChange = _props$onChange === undefined ? function () {} : _props$onChange;
            var _props$styleName = _props.styleName;
            var styleName = _props$styleName === undefined ? 'core' : _props$styleName;
            var title = _props.title;

            var Container = layout;

            var _props2 = _this.props;
            var children = _props2.children;

            var layoutProps = _objectWithoutProperties(_props2, ["children"]);

            var Item = undefined;

            if (Container === 'div') {
                Item = RadioItem;
            } else {
                Item = Container.RadioItem;
            }

            children = React.Children.toArray(children);
            layoutProps = _Object$entries(layoutProps).reduce(function (newProps, _ref2) {
                var key = _ref2[0];
                var value = _ref2[1];

                if (key.startsWith("layout-") === true) {
                    newProps[key.slice(7)] = value;
                }
                return newProps;
            }, {});

            return React.createElement(
                "div",
                null,
                React.createElement(
                    "div",
                    { className: "radio-core-title" },
                    title
                ),
                React.createElement(
                    Container,
                    layoutProps,
                    children.map(function (child, index) {
                        var value = child.props.value;
                        return(
                            // <Touchable component="div" className="radio-item-container" key={index} onTap={() => this.select(index, value)}>
                            React.createElement(Item, _extends({ checked: selectedIndex === index }, child.props, { onTap: function () {
                                    return _this.select(index, value);
                                } }))
                            // {/*</Touchable>*/}

                        );
                    })
                )
            );
        };
    }

    return Radio;
})(React.Component);

Radio.valueProp = 'selectedIndex';
Radio.valueFunction = function (index, value) {
    return { index: index, value: value };
};
Radio.defaultPropValue = 0;

exports["default"] = Radio;
module.exports = exports["default"];

},{"babel-runtime/core-js/object/entries":51,"babel-runtime/helpers/class-call-check":58,"babel-runtime/helpers/extends":59,"babel-runtime/helpers/inherits":60,"babel-runtime/helpers/interop-require-default":61,"babel-runtime/helpers/object-without-properties":62,"lib-source/uiv2/CenterContent":12,"lib-source/uiv2/Icon":16,"lib-source/uiv2/Touchable":24,"lib-source/v2/style":43}],21:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("babel-runtime/helpers/interop-require-default")["default"];

exports.__esModule = true;

var _libSourceUiv2Image = require("lib-source/uiv2/Image");

var _libSourceUiv2Image2 = _interopRequireDefault(_libSourceUiv2Image);

var _libSourceDataUriLoadSpinnerGifSource = require("lib-source/data-uri/load-spinner.gif.source");

var _libSourceDataUriLoadSpinnerGifSource2 = _interopRequireDefault(_libSourceDataUriLoadSpinnerGifSource);

var Spinner = function Spinner(_ref) {
  var size = _ref.size;
  return React.createElement(_libSourceUiv2Image2["default"], { width: size, height: size, source: _libSourceDataUriLoadSpinnerGifSource2["default"] });
};

exports["default"] = Spinner;
module.exports = exports["default"];

},{"babel-runtime/helpers/interop-require-default":61,"lib-source/data-uri/load-spinner.gif.source":7,"lib-source/uiv2/Image":17}],22:[function(require,module,exports){
'use strict';

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

exports.__esModule = true;

var _libSourceV2Style = require("lib-source/v2/style");

var _libSourceUiv2InputRangeInput = require('lib-source/uiv2/input/RangeInput');

var _libSourceUiv2InputRangeInput2 = _interopRequireDefault(_libSourceUiv2InputRangeInput);

_libSourceV2Style.defineComponentStyle('time-selector', 'core', {
    "time-display": {
        textAlign: 'center',
        fontSize: 24,
        color: 'black'
    }
});

var TimeSelector = (function (_React$Component) {
    _inherits(TimeSelector, _React$Component);

    function TimeSelector(props) {
        var _this = this;

        _classCallCheck(this, TimeSelector);

        _React$Component.call(this, props);

        this.change = function (prop) {
            return function (newValue) {
                var _changed;

                var _props = _this.props;
                var value = _props.value;
                var _props$onChange = _props.onChange;
                var onChange = _props$onChange === undefined ? warningFunc("onChange not given to TimeSelector") : _props$onChange;

                var changed = (_changed = {}, _changed[prop] = newValue, _changed);

                onChange(value.set(changed));
            };
        };

        this.render = function () {
            var _props2 = _this.props;
            var _props2$value = _props2.value;
            var value = _props2$value === undefined ? null : _props2$value;
            var _props2$format = _props2.format;
            var format = _props2$format === undefined ? "{hour/12padded}:{minute/padded} {tod}" : _props2$format;

            if (value === null) {
                throw new Error("Must provide a value to TimeSelector");
            }
            var hours = value.hours;
            var minutes = value.minutes;

            return React.createElement(
                'div',
                null,
                React.createElement(
                    'div',
                    { className: 'time-selector-core-time-display' },
                    value.format(format)
                ),
                React.createElement(_libSourceUiv2InputRangeInput2['default'], { key: '0', value: hours, min: 0, max: 23, label: 'Hour', onChange: _this.change('hours'), showArrows: true }),
                React.createElement(_libSourceUiv2InputRangeInput2['default'], { key: '1', value: minutes, min: 0, max: 59, label: 'Minute', onChange: _this.change('minutes'), showArrows: true })
            );
        };
    }

    return TimeSelector;
})(React.Component);

exports['default'] = TimeSelector;
module.exports = exports['default'];

},{"babel-runtime/helpers/class-call-check":58,"babel-runtime/helpers/inherits":60,"babel-runtime/helpers/interop-require-default":61,"lib-source/uiv2/input/RangeInput":31,"lib-source/v2/style":43}],23:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _libSourceV2Style = require("lib-source/v2/style");

var _libSourceV2Utils = require('lib-source/v2/utils');

var animationTime = 100;
_libSourceV2Style.defineComponentStyle('toggle', 'core', {
    "container": {
        position: 'relative',
        transition: 'background-color 500ms linear',
        fontSize: 20,
        overflow: 'hidden'
    },
    "container:active": {
        backgroundColor: 'rgba(0, 0, 0, 0.075)',
        transition: 'none'
    },
    "toggle-container": {
        position: 'absolute',
        right: 13,
        width: 30,
        top: '50%',
        transform: "translateY(-50%)",
        height: 8,
        fontSize: 11,
        borderRadius: 15,
        backgroundColor: 'lightgray',
        lineHeight: '22px'
    },
    "toggle-container[data-on='true']": {
        backgroundColor: '#bed0bd'
    },
    "toggle": {
        WebkitTransition: 'background-color ' + animationTime + 'ms linear, -webkit-transform ' + animationTime + 'ms linear',
        transition: 'background-color ' + animationTime + 'ms linear, transform ' + animationTime + 'ms linear',
        position: 'absolute',
        left: -11,
        top: -7,
        height: 22,
        width: 22,
        borderRadius: 15,
        textAlign: 'center',
        border: '1px solid lightgray',
        boxShadow: '2px 2px 2px rgba(0, 0, 0, 0.15)'
    },
    "toggle[data-on='false']": {
        transform: 'translateX(0)',
        backgroundColor: 'white'
    },
    "toggle[data-on='true']": {
        transform: 'translateX(30px)',
        backgroundColor: '#24b324'
    },
    "label": {
        padding: 3,
        paddingRight: 70,
        whiteSpace: 'pre',
        color: 'black'
    },
    "subtitle": {
        color: 'gray',
        fontSize: 14
    }
});

var Toggle = function Toggle(props) {
    var _props$on = props.on;
    var on = _props$on === undefined ? false : _props$on;
    var label = props.label;
    var _props$subTitle = props.subTitle;
    var subTitle = _props$subTitle === undefined ? null : _props$subTitle;
    var _props$onChange = props.onChange;
    var onChange = _props$onChange === undefined ? function () {
        return console.warn("No onChange given to checkbox");
    } : _props$onChange;
    var _props$styleName = props.styleName;
    var styleName = _props$styleName === undefined ? 'core' : _props$styleName;

    var content = label;
    var toggleStyle = undefined;

    if (subTitle !== null) {
        content = React.createElement(
            'div',
            null,
            label,
            React.createElement(
                'div',
                { className: 'checkbox-core-subtitle' },
                subTitle
            )
        );
    }

    return React.createElement(
        UI.Touchable,
        { component: 'div', className: 'toggle-core-container', onTap: function () {
                return onChange(!on);
            } },
        React.createElement(
            'div',
            { className: 'toggle-core-label toggle-' + styleName + '-label-custom' },
            content
        ),
        React.createElement(
            'div',
            { className: 'toggle-core-toggle-container toggle-' + styleName + '-toggle-container-custom', 'data-on': on },
            React.createElement('div', { className: 'toggle-core-toggle toggle-' + styleName + '-toggle-custom', 'data-on': on })
        )
    );
};
Toggle.componentName = 'toggle';

_libSourceV2Style.defineCustomBase(Toggle, function (_ref) {
    var _ref$normal = _ref.normal;
    var normal = _ref$normal === undefined ? null : _ref$normal;
    var _ref$on = _ref.on;
    var on = _ref$on === undefined ? null : _ref$on;
    var _ref$label = _ref.label;
    var label = _ref$label === undefined ? null : _ref$label;
    var _ref$subtitle = _ref.subtitle;
    var subtitle = _ref$subtitle === undefined ? null : _ref$subtitle;
    return _libSourceV2Utils.transferProps({
        ".toggle-core-toggle-container/toggle-container-custom": [normal, { trackColor: 'backgroundColor' }],
        ".toggle-core-toggle-container/toggle-container-custom[data-on='true']": [on, { trackColor: 'backgroundColor' }],
        ".toggle-core-toggle/toggle-custom": [normal, { thumbColor: 'backgroundColor' }],
        ".toggle-core-toggle/toggle-custom[data-on='true']": [on, { thumbColor: 'backgroundColor' }],
        ".toggle-core-label/label-custom": [label, {
            textColor: 'color',
            color: 'backgroundColor'
        }],
        ".toggle-core-subtitle/subtitle-custom": [subtitle, {
            textColor: 'color',
            color: 'backgroundColor'
        }]
    });
});

exports['default'] = Toggle;
module.exports = exports['default'];
/*<Ripple />*/

},{"lib-source/v2/style":43,"lib-source/v2/utils":44}],24:[function(require,module,exports){
// import React from "react";
// import ReactDOM from "react-dom";

"use strict";

var _extends = require("babel-runtime/helpers/extends")["default"];

var _objectWithoutProperties = require("babel-runtime/helpers/object-without-properties")["default"];

exports.__esModule = true;
var forEach = Array.prototype.forEach;
var sqrt = Math.sqrt;

var Touchable = undefined;

Touchable = React.createClass({
    displayName: "Touchable",

    touchStart: function touchStart(evt) {
        var onTouchStart = this.props.onTouchStart;
        var _evt$changedTouches = evt.changedTouches;
        var touch = _evt$changedTouches[0];

        ReactDOM.findDOMNode(this).classList.add("cor-touch-active");
        if (onTouchStart !== undefined) {
            onTouchStart(evt);
        }

        this.info = {
            id: touch.identifier,
            x: touch.pageX,
            y: touch.pageY
        };
    },
    touchMove: function touchMove(evt) {
        var _context,
            _this = this;

        var onTouchMove = this.props.onTouchMove;

        if (onTouchMove !== undefined) {
            onTouchMove(evt);
        }

        (_context = evt.changedTouches, forEach).call(_context, function (touch) {
            if (touch.identifier !== _this.info.id) {
                return;
            }

            if (sqrt(Math.pow(touch.pageX - _this.info.x, 2) + Math.pow(touch.pageY - _this.info.y, 2)) > 25) {
                ReactDOM.findDOMNode(_this).classList.remove("cor-touch-active");
            }
        });
    },
    touchEnd: function touchEnd(evt) {
        var _context2,
            _this2 = this;

        var onTouchEnd = this.props.onTouchEnd;

        if (onTouchEnd !== undefined) {
            onTouchEnd(evt);
        }
        (_context2 = evt.changedTouches, forEach).call(_context2, function (touch) {
            if (touch.identifier !== _this2.info.id) {
                return;
            }

            ReactDOM.findDOMNode(_this2).classList.remove("cor-touch-active");
        });
        // this.props.onTouchEnd(evt);
    },
    getBoundingClientRect: function getBoundingClientRect() {
        return this.refs.node.getBoundingClientRect();
    },
    componentDidMount: function componentDidMount() {
        var _this3 = this;

        var node = this.refs.node;

        node.addEventListener('tap', function (evt) {
            var onTap = _this3.props.onTap;

            node.focus();
            if (onTap !== undefined) {
                onTap.call(_this3, evt);
            }
            // ::this.props.onTap(evt);
        });
        node.addEventListener('hold', function (evt) {
            var onHold = _this3.props.onHold;

            node.focus();
            if (onHold !== undefined) {
                onHold.call(_this3, evt);
            }
            // ::this.props.onHold(evt);
        });
    },
    render: function render() {
        var _props = this.props;
        var _props$component = _props.component;
        var component = _props$component === undefined ? null : _props$component;
        var children = _props.children;
        var onTap = _props.onTap;
        var onHold = _props.onHold;

        var props = _objectWithoutProperties(_props, ["component", "children", "onTap", "onHold"]);

        var Component = component;
        var componentProps = _extends({}, props, {
            onTouchStart: this.touchStart,
            onTouchMove: this.touchMove,
            onTouchEnd: this.touchEnd,
            onTouchCancel: this.touchEnd
        });

        if (Component === null) {
            throw new Error("Must pass a component into Touchable");
        }

        return React.createElement(
            Component,
            _extends({ ref: "node" }, componentProps),
            children
        );
    }
});

exports["default"] = Touchable;
module.exports = exports["default"];

},{"babel-runtime/helpers/extends":59,"babel-runtime/helpers/object-without-properties":62}],25:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("babel-runtime/helpers/interop-require-default")["default"];

exports.__esModule = true;

var _libSourceV2StyleJs = require("lib-source/v2/style.js");

var _libSourceUiv2RippleJs = require("lib-source/uiv2/ripple.js");

var _libSourceUiv2RippleJs2 = _interopRequireDefault(_libSourceUiv2RippleJs);

var _libSourceUiv2IconJs = require('lib-source/uiv2/icon.js');

var _libSourceUiv2IconJs2 = _interopRequireDefault(_libSourceUiv2IconJs);

var _libSourceUiv2Touchable = require('lib-source/uiv2/Touchable');

var _libSourceUiv2Touchable2 = _interopRequireDefault(_libSourceUiv2Touchable);

var _libSourceUiv2Vars = require('lib-source/uiv2/vars');

var _libSourceUiv2Vars2 = _interopRequireDefault(_libSourceUiv2Vars);

var _libSourceV2Utils = require('lib-source/v2/utils');

_libSourceV2StyleJs.defineComponentStyle('button', 'core', {
    "wrapper": {
        position: 'relative',
        textAlign: 'center',
        margin: 4,
        overflow: 'hidden',
        zIndex: "+0",
        whiteSpace: 'pre',
        display: 'inline-block',
        backgroundColor: 'transparent',
        color: 'black',
        borderRadius: 3
    },
    "wrapper:focus": {
        outline: 'none'
    },
    "wrapper[disabled]": {
        backgroundColor: '#eaeaea',
        color: '#a0a0a0'
    },
    "text-wrapper": {
        display: 'table',
        width: '100%'
    },
    "text": {
        height: '100%',
        width: '100%',
        padding: 5,
        paddingLeft: 15,
        paddingRight: 15,
        textAlign: 'center',
        verticalAlign: 'middle',
        whiteSpace: 'pre',
        display: 'table-cell'
    },
    "wrapper > overlay": {
        position: 'absolute',
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        transition: 'background-color 500ms linear'
    },
    ".core-desktop overlay:hover": {
        backgroundColor: _libSourceUiv2Vars2["default"].hoverColor
    },
    "wrapper:active > overlay": {
        backgroundColor: _libSourceUiv2Vars2["default"].activeColor,
        transition: 'none'
    }
});

var Button = function Button(props) {
    var text = props.text;
    var _props$onTap = props.onTap;
    var onTap = _props$onTap === undefined ? function () {
        return console.warn("No onTap given to Button");
    } : _props$onTap;
    var _props$styleName = props.styleName;
    var styleName = _props$styleName === undefined ? "core" : _props$styleName;
    var _props$buttonColor = props.buttonColor;
    var buttonColor = _props$buttonColor === undefined ? null : _props$buttonColor;
    var _props$textColor = props.textColor;
    var textColor = _props$textColor === undefined ? null : _props$textColor;
    var flush = props.flush;
    var block = props.block;
    var fill = props.fill;
    var padding = props.padding;
    var disabled = props.disabled;
    var _props$iconName = props.iconName;
    var iconName = _props$iconName === undefined ? null : _props$iconName;
    var _props$iconSize = props.iconSize;
    var iconSize = _props$iconSize === undefined ? null : _props$iconSize;

    var wrapperName = "button-core-wrapper button-" + styleName + "-wrapper-custom";

    var wrapperStyle = { backgroundColor: buttonColor };
    var textWrapperStyle = {};
    var textStyle = { color: textColor };
    var rippleElement = undefined;
    var onTapHandler = undefined;

    if (disabled !== true) {
        // rippleElement = <Ripple />;
        onTapHandler = onTap;
    }
    if (block === true) {
        wrapperStyle.display = 'block';
    }
    if (fill === true) {
        flush = true;
        wrapperStyle.width = '100%';
        wrapperStyle.height = '100%';
        textWrapperStyle.height = '100%';
        textStyle.padding = 0;
    }
    if (flush === true) {
        wrapperStyle.margin = 0;
    }
    if (iconName !== null) {
        text = React.createElement(
            "span",
            null,
            React.createElement(_libSourceUiv2IconJs2["default"], { name: iconName, size: iconSize }),
            text
        );
    }

    return React.createElement(
        _libSourceUiv2Touchable2["default"],
        { component: "div", tabIndex: -1, className: wrapperName, onTap: onTapHandler, disabled: disabled, style: wrapperStyle },
        React.createElement(
            "div",
            { className: "button-core-text-wrapper", style: textWrapperStyle },
            React.createElement(
                "div",
                { className: "button-core-text", style: textStyle },
                text
            )
        ),
        React.createElement("div", { className: "button-core-overlay" }),
        rippleElement
    );
};
Button.componentName = 'button';

_libSourceV2StyleJs.defineCustomBase(Button, function (_ref) {
    var _ref$normal = _ref.normal;
    var normal = _ref$normal === undefined ? null : _ref$normal;
    var _ref$focus = _ref.focus;
    var focus = _ref$focus === undefined ? null : _ref$focus;
    var _ref$disabled = _ref.disabled;
    var disabled = _ref$disabled === undefined ? null : _ref$disabled;
    return _libSourceV2Utils.transferProps({
        ".button-core-wrapper/wrapper-custom": [normal, {
            textColor: 'color',
            color: 'backgroundColor',
            borderRadius: 'borderRadius',
            shadow: 'boxShadow'
        }
        // ['backgroundColor', 'color', 'borderRadius', 'boxShadow']
        ],
        ".button-core-wrapper/wrapper-custom:focus": [focus, {
            textColor: 'color',
            color: 'backgroundColor',
            borderRadius: 'borderRadius',
            shadow: 'boxShadow'
        }
        // ['backgroundColor', 'color', 'borderRadius', 'boxShadow']
        ],
        ".button-core-wrapper/wrapper-custom[disabled]": [disabled, {
            textColor: 'color',
            color: 'backgroundColor',
            borderRadius: 'borderRadius',
            shadow: 'boxShadow'
        }
        // ['backgroundColor', 'color', 'borderRadius', 'boxShadow']
        ]
    });
});

_libSourceV2StyleJs.defineStyleForComponent(Button, "cancel", {
    normal: {
        color: "#b5263e",
        textColor: 'white'
    }
});
_libSourceV2StyleJs.defineStyleForComponent(Button, "confirm", {
    normal: {
        color: "#30d5a7"
    }
});

exports["default"] = Button;
module.exports = exports["default"];

},{"babel-runtime/helpers/interop-require-default":61,"lib-source/uiv2/Touchable":24,"lib-source/uiv2/icon.js":27,"lib-source/uiv2/ripple.js":36,"lib-source/uiv2/vars":37,"lib-source/v2/style.js":43,"lib-source/v2/utils":44}],26:[function(require,module,exports){
"use strict";

var _inherits = require("babel-runtime/helpers/inherits")["default"];

var _classCallCheck = require("babel-runtime/helpers/class-call-check")["default"];

var _regeneratorRuntime = require("babel-runtime/regenerator")["default"];

var _Promise = require("babel-runtime/core-js/promise")["default"];

var _interopRequireDefault = require("babel-runtime/helpers/interop-require-default")["default"];

exports.__esModule = true;

var _libSourceV2Style = require("lib-source/v2/style");

var _libSourceUiv2Button = require("lib-source/uiv2/Button");

var _libSourceUiv2Button2 = _interopRequireDefault(_libSourceUiv2Button);

var _libSourceUiv2Touchable = require("lib-source/uiv2/Touchable");

var _libSourceUiv2Touchable2 = _interopRequireDefault(_libSourceUiv2Touchable);

var _libSourceUiv2LayoutFlexbox = require("lib-source/uiv2/layout/Flexbox");

var _libSourceUiv2LayoutFlexbox2 = _interopRequireDefault(_libSourceUiv2LayoutFlexbox);

var animationTime = 250;
_libSourceV2Style.defineComponentStyle('dialog', 'core', {
    "overlay": {
        position: 'fixed',
        top: 0,
        left: 0,
        width: '100%',
        height: '100%',
        backgroundColor: 'rgba(0, 0, 0, 0.35)',
        zIndex: '+100',
        display: 'none',
        opacity: 0,
        transition: "opacity " + animationTime + "ms linear"
    },

    "window": {
        position: 'absolute',
        backgroundColor: 'white',
        boxShadow: '0px 0px 10px rgba(0, 0, 0, 0.6)',
        width: '75%',
        maxWidth: 480,
        padding: 0,
        overflow: 'hidden'
    },
    "window-top": {
        top: '15%',
        left: '50%',
        transform: 'translateX(-50%)'
    },
    "window-center": {
        top: '50%',
        left: '50%',
        transform: 'translate(-50%, -50%)'
    },

    "content": {
        maxHeight: '50vh',
        WebkitOverflowScrolling: 'touch',
        overflow: 'auto'
    },
    "buttons": {
        borderTop: '1px solid lightgray'
    },
    "title": {
        borderBottom: '1px solid lightgray',
        padding: '5 15',
        fontSize: 20,
        fontWeight: 900,
        color: 'black'
    }
});

var currentDialog = null;
window.dialog = {
    show: function show(options) {
        return currentDialog.show(options);
    },
    hide: function hide(value) {
        return currentDialog.hide(value);
    },
    success: function success(value) {
        return { value: value, status: 'success' };
    },
    cancel: function cancel(value) {
        return { value: value, status: 'canceled' };
    },
    invalid: function invalid() {
        var value = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
        var reason = arguments.length <= 1 || arguments[1] === undefined ? 'invalid' : arguments[1];

        return { value: value, reason: reason };
    }
};

var Dialog = (function (_React$Component) {
    _inherits(Dialog, _React$Component);

    function Dialog(props) {
        var _this2 = this;

        _classCallCheck(this, Dialog);

        _React$Component.call(this, props);

        this.show = function callee$2$0(displayProps) {
            var _displayProps$content, content, _displayProps$closable, closable, _displayProps$buttons, buttons, _displayProps$title, title, _displayProps$setup, setup;

            return _regeneratorRuntime.async(function callee$2$0$(context$3$0) {
                var _this = this;

                while (1) switch (context$3$0.prev = context$3$0.next) {
                    case 0:
                        if (!(this.animating === true || this.resolver !== null)) {
                            context$3$0.next = 2;
                            break;
                        }

                        return context$3$0.abrupt("return", dialog.invalid());

                    case 2:
                        document.body.style.overflow = 'hidden';
                        document.body.style.WebkitOverflowScrolling = 'auto';
                        this.animating = true;
                        this.resolver = new _Promise(function (resolve) {
                            _this.response = function (value) {
                                return resolve(value);
                            };
                        });

                        _displayProps$content = displayProps.content;
                        content = _displayProps$content === undefined ? null : _displayProps$content;
                        _displayProps$closable = displayProps.closable;
                        closable = _displayProps$closable === undefined ? true : _displayProps$closable;
                        _displayProps$buttons = displayProps.buttons;
                        buttons = _displayProps$buttons === undefined ? [{ text: 'ok' }] : _displayProps$buttons;
                        _displayProps$title = displayProps.title;
                        title = _displayProps$title === undefined ? null : _displayProps$title;
                        _displayProps$setup = displayProps.setup;
                        setup = _displayProps$setup === undefined ? null : _displayProps$setup;

                        this.setState({ display: 'block', content: content, buttons: buttons, closable: closable, title: title });
                        context$3$0.next = 19;
                        return _regeneratorRuntime.awrap(chrono.wait(50));

                    case 19:
                        this.refs.container.scrollTop = 0;
                        if (setup !== null) {
                            setup(this.refs.container);
                        }
                        this.setState({ opacity: 1 });
                        context$3$0.next = 24;
                        return _regeneratorRuntime.awrap(chrono.wait(animationTime));

                    case 24:
                        this.animating = false;
                        context$3$0.next = 27;
                        return _regeneratorRuntime.awrap(this.resolver);

                    case 27:
                        return context$3$0.abrupt("return", context$3$0.sent);

                    case 28:
                    case "end":
                        return context$3$0.stop();
                }
            }, null, _this2);
        };

        this.hide = function callee$2$0(value) {
            return _regeneratorRuntime.async(function callee$2$0$(context$3$0) {
                var _this3 = this;

                while (1) switch (context$3$0.prev = context$3$0.next) {
                    case 0:
                        if (!(this.animating === true || this.resolve === null)) {
                            context$3$0.next = 2;
                            break;
                        }

                        return context$3$0.abrupt("return");

                    case 2:
                        this.animating = true;
                        this.setState({ opacity: null });
                        context$3$0.next = 6;
                        return _regeneratorRuntime.awrap(chrono.wait(animationTime));

                    case 6:
                        this.setState({ display: null });
                        requestAnimationFrame(function () {
                            document.body.style.overflow = '';
                            document.body.style.WebkitOverflowScrolling = '';
                            _this3.response(value);
                            _this3.response = null;
                            _this3.resolver = null;
                        });
                        this.animating = false;

                    case 9:
                    case "end":
                        return context$3$0.stop();
                }
            }, null, _this2);
        };

        this.close = function () {
            if (_this2.state.closable === false) {
                return;
            }
            _this2.hide(dialog.cancel(null));
        };

        this.stopper = function (evt) {
            evt.stopPropagation();
        };

        this.stopScroll = function (evt) {
            // if (evt.cancelable === true) {
            //     evt.preventDefault();
            // }
            evt.stopPropagation();
        };

        this.componentDidMount = function () {
            currentDialog = _this2;
        };

        this.componentWillUnmount = function () {
            currentDialog = null;
        };

        this.render = function () {
            var _state = _this2.state;
            var display = _state.display;
            var opacity = _state.opacity;
            var pos = _state.pos;
            var content = _state.content;
            var buttons = _state.buttons;
            var title = _state.title;

            var buttonList = (buttons || []).map(function (_ref, index) {
                var text = _ref.text;
                var _ref$value = _ref.value;
                var value = _ref$value === undefined ? null : _ref$value;
                var _ref$cancels = _ref.cancels;
                var cancels = _ref$cancels === undefined ? false : _ref$cancels;

                // const valueFunc = (cancels === true) ? dialog.cancel : dialog.success;
                var onTap = function onTap() {
                    if (typeof value === 'function') {
                        value = value(_this2.refs.container);
                    }
                    var retValue = cancels === true ? dialog.cancel(value) : dialog.success(value);

                    _this2.hide(retValue);
                };
                return React.createElement(_libSourceUiv2Button2["default"], { text: text, key: index, onTap: onTap, block: true, flush: true });
            });
            var titleDisplay = null;

            if (title !== null) {
                titleDisplay = React.createElement(
                    "div",
                    { className: "dialog-core-title" },
                    title
                );
            }

            return React.createElement(
                _libSourceUiv2Touchable2["default"],
                { component: "div", onTap: _this2.close, onTouchMove: function (evt) {
                        return evt.preventDefault();
                    }, className: "dialog-core-overlay", style: { display: display, opacity: opacity } },
                React.createElement(
                    _libSourceUiv2Touchable2["default"],
                    { component: "div", className: "dialog-core-window dialog-core-window-" + pos, onTap: _this2.stopper, onTouchMove: _this2.stopScroll },
                    titleDisplay,
                    React.createElement(
                        "div",
                        { className: "dialog-core-content", ref: "container" },
                        content
                    ),
                    React.createElement(
                        "div",
                        { className: "dialog-core-buttons" },
                        React.createElement(
                            _libSourceUiv2LayoutFlexbox2["default"],
                            { className: "dialog-core-buttons", colCount: 3 },
                            buttonList
                        )
                    )
                )
            );
        };

        this.state = {
            display: null,
            opacity: null,
            name: null,
            pos: 'top',
            content: null,
            closable: !true,
            buttons: null,
            title: null
        };
        this.animating = false;
        this.resolver = null;
    }

    return Dialog;
})(React.Component);

exports["default"] = Dialog;
module.exports = exports["default"];

// console.log(this.animating, this.animating === true);
/*<Button text="demo" block onTap={() => this.hide('test')} />*/

},{"babel-runtime/core-js/promise":55,"babel-runtime/helpers/class-call-check":58,"babel-runtime/helpers/inherits":60,"babel-runtime/helpers/interop-require-default":61,"babel-runtime/regenerator":149,"lib-source/uiv2/Button":9,"lib-source/uiv2/Touchable":24,"lib-source/uiv2/layout/Flexbox":33,"lib-source/v2/style":43}],27:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _libSourceV2StyleJs = require("lib-source/v2/style.js");

_libSourceV2StyleJs.defineComponentStyle('icon', 'core', {
    "content": {
        fontFamily: "Ionic",
        marginLeft: 2,
        marginRight: 2
    }
});
var Icon = function Icon(_ref) {
    var name = _ref.name;
    var _ref$styleName = _ref.styleName;
    var styleName = _ref$styleName === undefined ? 'core' : _ref$styleName;
    var size = _ref.size;
    return React.createElement(
        'span',
        { className: 'icon-' + styleName + '-content', style: { fontSize: size } },
        ionic[name]
    );
};

exports['default'] = Icon;
module.exports = exports['default'];

},{"lib-source/v2/style.js":43}],28:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

exports.__esModule = true;

var _libSourceV2StyleJs = require("lib-source/v2/style.js");

// import Ripple from "lib-source/uiv2/ripple.js";

var _libSourceUiv2IconJs = require('lib-source/uiv2/icon.js');

var _libSourceUiv2IconJs2 = _interopRequireDefault(_libSourceUiv2IconJs);

_libSourceV2StyleJs.defineComponentStyle('icon-button', 'core', {
    "wrapper": {
        position: 'relative',
        textAlign: 'center',
        margin: 4,
        overflow: 'hidden',
        zIndex: "+0",
        backgroundColor: 'transparent',
        color: 'black',
        display: 'inline-block',
        borderRadius: '50%'
    }
});
var IconButton = function IconButton(props) {
    var _props$size = props.size;
    var size = _props$size === undefined ? 42 : _props$size;
    var name = props.name;
    var iconSize = props.iconSize;
    var _props$styleName = props.styleName;
    var styleName = _props$styleName === undefined ? 'core' : _props$styleName;

    var wrapperName = 'icon-button-' + styleName + '-wrapper';

    return React.createElement(
        UI.Touchable,
        { component: 'div', className: wrapperName, style: { width: size, height: size } },
        React.createElement(
            'div',
            { className: 'button-core-text-wrapper', style: { height: '100%' } },
            React.createElement(
                'div',
                { className: 'button-core-text', style: { padding: 0 } },
                React.createElement(_libSourceUiv2IconJs2['default'], { name: name, size: iconSize })
            )
        )
    );
};

exports['default'] = IconButton;
module.exports = exports['default'];

},{"babel-runtime/helpers/interop-require-default":61,"lib-source/uiv2/icon.js":27,"lib-source/v2/style.js":43}],29:[function(require,module,exports){
"use strict";

var _regeneratorRuntime = require("babel-runtime/regenerator")["default"];

var _interopRequireDefault = require("babel-runtime/helpers/interop-require-default")["default"];

exports.__esModule = true;

var _this = this;

var _libSourceV2Style = require("lib-source/v2/style");

var _libSourceUiv2Button = require("lib-source/uiv2/Button");

var _libSourceUiv2Button2 = _interopRequireDefault(_libSourceUiv2Button);

var _libSourceUiv2Calendar = require("lib-source/uiv2/Calendar");

var _libSourceUiv2Calendar2 = _interopRequireDefault(_libSourceUiv2Calendar);

var DateInput = function DateInput(_ref) {
    var _ref$value = _ref.value;
    var value = _ref$value === undefined ? chrono() : _ref$value;
    var _ref$format = _ref.format;
    var format = _ref$format === undefined ? "{month}/{day}/{year}" : _ref$format;
    var _ref$onChange = _ref.onChange;
    var onChange = _ref$onChange === undefined ? function () {} : _ref$onChange;
    var iconName = _ref.iconName;

    var changeDate = function changeDate() {
        var handler, result;
        return _regeneratorRuntime.async(function changeDate$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
                case 0:
                    handler = function handler(date) {
                        dialog.hide(dialog.success(date));
                    };

                    context$2$0.next = 3;
                    return _regeneratorRuntime.awrap(dialog.show({
                        content: React.createElement(_libSourceUiv2Calendar2["default"], { selectedDate: value, onChange: handler, key: Date.now() }),
                        buttons: [{ text: "Cancel" }]
                    }));

                case 3:
                    result = context$2$0.sent;
                    // title: "Select Date"

                    if (result.value !== null) {
                        onChange(result.value);
                    }

                case 5:
                case "end":
                    return context$2$0.stop();
            }
        }, null, _this);
    };
    return React.createElement(
        "div",
        { style: { height: 30 } },
        React.createElement(_libSourceUiv2Button2["default"], { text: value.format(format), onTap: changeDate, flush: true, fill: true, iconName: iconName })
    );
};

DateInput.valueProp = 'value';
DateInput.valueFunction = function (date) {
    return date;
};
DateInput.defaultPropValue = function () {
    return chrono();
};

exports["default"] = DateInput;
module.exports = exports["default"];

},{"babel-runtime/helpers/interop-require-default":61,"babel-runtime/regenerator":149,"lib-source/uiv2/Button":9,"lib-source/uiv2/Calendar":10,"lib-source/v2/style":43}],30:[function(require,module,exports){
"use strict";

var _inherits = require("babel-runtime/helpers/inherits")["default"];

var _classCallCheck = require("babel-runtime/helpers/class-call-check")["default"];

var _objectWithoutProperties = require("babel-runtime/helpers/object-without-properties")["default"];

var _extends = require("babel-runtime/helpers/extends")["default"];

var _Array$from = require("babel-runtime/core-js/array/from")["default"];

var _interopRequireDefault = require("babel-runtime/helpers/interop-require-default")["default"];

exports.__esModule = true;

var _libSourceV2Style = require("lib-source/v2/style");

var _libSourceUiv2Button = require('lib-source/uiv2/Button');

var _libSourceUiv2Button2 = _interopRequireDefault(_libSourceUiv2Button);

var FileInput = (function (_React$Component) {
    _inherits(FileInput, _React$Component);

    function FileInput(props) {
        var _this = this;

        _classCallCheck(this, FileInput);

        _React$Component.call(this, props);

        this.trigger = function () {
            _this.refs.file.click();
        };

        this.upload = function (evt) {
            _this.props.onChange(_Array$from(evt.target.files));
        };

        this.render = function () {
            var _props = _this.props;
            var value = _props.value;
            var _props$valueFormat = _props.valueFormat;
            var valueFormat = _props$valueFormat === undefined ? function (fileList) {
                return fileList[0].name;
            } : _props$valueFormat;
            var _props$nullText = _props.nullText;
            var nullText = _props$nullText === undefined ? "Select a file" : _props$nullText;

            var props = _objectWithoutProperties(_props, ["value", "valueFormat", "nullText"]);

            var buttonText = undefined;

            if (typeof value === 'string') {
                buttonText = value;
            }
            if (Array.isArray(value) === true) {
                buttonText = valueFormat(value);
            }

            if (value === null) {
                buttonText = nullText;
            }

            return React.createElement(
                "div",
                null,
                React.createElement("input", _extends({}, props, { type: "file", ref: "file", style: { display: 'none' }, value: "", onChange: _this.upload })),
                React.createElement(_libSourceUiv2Button2["default"], { text: buttonText, onTap: _this.trigger, block: true })
            );
        };
    }

    return FileInput;
})(React.Component);

FileInput.valueProp = "value";
FileInput.valueFunction = function (fileList) {
    return fileList;
};
FileInput.defaultPropValue = null;

exports["default"] = FileInput;
module.exports = exports["default"];

},{"babel-runtime/core-js/array/from":46,"babel-runtime/helpers/class-call-check":58,"babel-runtime/helpers/extends":59,"babel-runtime/helpers/inherits":60,"babel-runtime/helpers/interop-require-default":61,"babel-runtime/helpers/object-without-properties":62,"lib-source/uiv2/Button":9,"lib-source/v2/style":43}],31:[function(require,module,exports){
"use strict";

var _extends = require("babel-runtime/helpers/extends")["default"];

var _interopRequireDefault = require("babel-runtime/helpers/interop-require-default")["default"];

exports.__esModule = true;

var _libSourceV2Style = require("lib-source/v2/style");

var _libSourceUiv2Button = require('lib-source/uiv2/Button');

var _libSourceUiv2Button2 = _interopRequireDefault(_libSourceUiv2Button);

var coolBlue = "#2FB1DF";
var clampValue = function clampValue(value, min, max) {
    return Math.min(Math.max(value, min), max);
};
var thumbSize = {
    width: 24,
    height: 24
};
var trackBase = {
    position: 'absolute',
    left: 0,
    top: '50%',
    transform: 'translateY(-50%)',
    height: 4,
    borderRadius: 2
};
_libSourceV2Style.defineComponentStyle('range-input', 'core', {
    "wrapper": {
        height: 30,
        position: 'relative'
    },
    "focus-background": {
        position: 'absolute',
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        opacity: 0
    },
    "track-container": {
        position: 'absolute',
        top: 0,
        left: 12,
        right: 12,
        bottom: 0
    },
    "track-background": _extends({}, trackBase, {
        right: 0,
        backgroundColor: 'lightgray'
    }),
    "track": _extends({}, trackBase, {
        backgroundColor: coolBlue
    }),
    "track::after": _extends({}, thumbSize, {
        boxSizing: 'border-box',
        position: 'absolute',
        top: '50%',
        right: 0,
        transform: 'translate(50%, -50%)',
        backgroundColor: 'white',
        border: "3px solid " + coolBlue,
        borderRadius: '50%',
        content: "''"
    }),
    "arrow": {
        position: 'absolute',
        top: 0,
        bottom: 0,
        width: 30,
        color: 'black'
    },
    "wrapper > $input[type='range']": {
        WebkitAppearance: 'none',
        width: '100%',
        height: '100%',
        left: 0,
        right: 0,
        margin: 0,
        zIndex: '+10',
        position: 'absolute',
        opacity: 0
    },
    "wrapper > $input[type='range']::-webkit-slider-thumb": _extends({}, thumbSize, {
        borderRadius: '50%',
        WebkitAppearance: 'none',
        backgroundColor: 'green'
    }),
    "wrapper > $input[type='range']:focus + focus-background": {
        opacity: 1
    }
});
var RangeInput = function RangeInput(props) {
    var _props$min = props.min;
    var min = _props$min === undefined ? 0 : _props$min;
    var _props$max = props.max;
    var max = _props$max === undefined ? 10 : _props$max;
    var _props$step = props.step;
    var step = _props$step === undefined ? 1 : _props$step;
    var _props$onChange = props.onChange;
    var onChange = _props$onChange === undefined ? function () {} : _props$onChange;
    var _props$focusStyle = props.focusStyle;
    var focusStyle = _props$focusStyle === undefined ? null : _props$focusStyle;
    var label = props.label;
    var _props$showArrows = props.showArrows;
    var showArrows = _props$showArrows === undefined ? false : _props$showArrows;

    var range = max - min;
    var changeHandler = function changeHandler(evt) {
        // evt.target.focus();
        onChange(evt.target.value);
    };
    var _props$value = props.value;
    var value = _props$value === undefined ? null : _props$value;

    var adjusted = undefined;
    var inputOffset = null;
    var trackOffset = null;
    var arrows = null;

    if (value === null) {
        value = min;
    }

    adjusted = value - min;
    if (adjusted % step !== 0) {
        adjusted -= adjusted % step;
    }
    adjusted = clampValue(adjusted, min, max);

    if (showArrows === true) {
        var arrowChange = function arrowChange(adjust) {
            return function () {
                var newValue = value + adjust;
                newValue = Math.max(newValue, min);
                newValue = Math.min(newValue, max);
                if (value !== newValue) {
                    onChange(newValue);
                }
            };
        };
        inputOffset = { left: 30, width: 'calc(100% - 60px)' };
        trackOffset = { left: 42, right: 42 };
        arrows = [React.createElement(
            "div",
            { className: "range-input-core-arrow", style: { left: 0 }, key: 0 },
            React.createElement(_libSourceUiv2Button2["default"], { iconName: "ion-arrow-left-b", flush: true, fill: true, iconSize: 20, onTap: arrowChange(-1) })
        ), React.createElement(
            "div",
            { className: "range-input-core-arrow", style: { right: 0 }, key: 1 },
            React.createElement(_libSourceUiv2Button2["default"], { iconName: "ion-arrow-right-b", flush: true, fill: true, iconSize: 20, onTap: arrowChange(1) })
        )];
    }

    return React.createElement(
        "div",
        null,
        React.createElement(
            "div",
            { className: "input-core-label" },
            label
        ),
        React.createElement(
            "div",
            { className: "range-input-core-wrapper" },
            React.createElement("input", { type: "range", style: inputOffset, min: min, max: max, step: step, value: adjusted, onChange: changeHandler, onTouchStart: function (evt) {
                    return evt.target.focus();
                } }),
            React.createElement("div", { className: "range-input-core-focus-background", style: focusStyle }),
            React.createElement(
                "div",
                { className: "range-input-core-track-container", style: trackOffset },
                React.createElement("div", { className: "range-input-core-track-background" }),
                React.createElement("div", { className: "range-input-core-track", style: { width: adjusted / range * 100 + "%" } })
            ),
            arrows
        )
    );
};

RangeInput.valueProp = 'value';
RangeInput.valueFunction = function (n) {
    return n;
};
RangeInput.defaultPropValue = 0;

exports["default"] = RangeInput;
module.exports = exports["default"];

},{"babel-runtime/helpers/extends":59,"babel-runtime/helpers/interop-require-default":61,"lib-source/uiv2/Button":9,"lib-source/v2/style":43}],32:[function(require,module,exports){
'use strict';

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _objectWithoutProperties = require('babel-runtime/helpers/object-without-properties')['default'];

var _extends = require('babel-runtime/helpers/extends')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

exports.__esModule = true;

var _libSourceV2Style = require("lib-source/v2/style");

var _libSourceUiv2Button = require('lib-source/uiv2/Button');

var _libSourceUiv2Button2 = _interopRequireDefault(_libSourceUiv2Button);

var _libSourceUiv2TimeSelector = require('lib-source/uiv2/TimeSelector');

var _libSourceUiv2TimeSelector2 = _interopRequireDefault(_libSourceUiv2TimeSelector);

var _libSourceV2Shared = require("lib-source/v2/shared");

var TimeInput = (function (_React$Component) {
    _inherits(TimeInput, _React$Component);

    function TimeInput(props) {
        var _this = this;

        _classCallCheck(this, TimeInput);

        _React$Component.call(this, props);

        this.select = function callee$2$0() {
            var _props, _props$onChange, onChange, timeFormat, currentDate, result;

            return _regeneratorRuntime.async(function callee$2$0$(context$3$0) {
                while (1) switch (context$3$0.prev = context$3$0.next) {
                    case 0:
                        _props = this.props;
                        _props$onChange = _props.onChange;
                        onChange = _props$onChange === undefined ? warningFunc("onChange not given to TimeInput") : _props$onChange;
                        timeFormat = _props.timeFormat;
                        currentDate = _libSourceV2Shared.sharedReference(this.props.value);
                        context$3$0.next = 7;
                        return _regeneratorRuntime.awrap(dialog.show({
                            // content: <div style={{padding: 3}}><TimeSelector value={currentDate} onChange={date => currentDate = date} /></div>,
                            content: React.createElement(_libSourceV2Shared.SharedObjectDisplay, { key: Date.now(), reference: currentDate, component: _libSourceUiv2TimeSelector2['default'], valueProp: 'value', format: timeFormat }),
                            buttons: [{ text: "Cancel", cancels: true }, { text: "Set", value: function value() {
                                    return currentDate.value;
                                } }]
                        }));

                    case 7:
                        result = context$3$0.sent;

                        if (result.status === 'success') {
                            onChange(result.value);
                        }

                    case 9:
                    case 'end':
                        return context$3$0.stop();
                }
            }, null, _this);
        };

        this.render = function () {
            var _props2 = _this.props;
            var _props2$format = _props2.format;
            var format = _props2$format === undefined ? "{hour}:{minute/padded}" : _props2$format;
            var value = _props2.value;

            var buttonProps = _objectWithoutProperties(_props2, ['format', 'value']);

            return React.createElement(_libSourceUiv2Button2['default'], _extends({}, buttonProps, { text: value.format(format), onTap: _this.select, block: true }));
        };
    }

    return TimeInput;
})(React.Component);

TimeInput.valueProp = 'value';
TimeInput.valueFunction = function (date) {
    return date;
};
TimeInput.defaultPropValue = function () {
    return chrono();
};

exports['default'] = TimeInput;
module.exports = exports['default'];

},{"babel-runtime/helpers/class-call-check":58,"babel-runtime/helpers/extends":59,"babel-runtime/helpers/inherits":60,"babel-runtime/helpers/interop-require-default":61,"babel-runtime/helpers/object-without-properties":62,"babel-runtime/regenerator":149,"lib-source/uiv2/Button":9,"lib-source/uiv2/TimeSelector":22,"lib-source/v2/shared":42,"lib-source/v2/style":43}],33:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("babel-runtime/helpers/interop-require-default")["default"];

exports.__esModule = true;

var _libSourceV2Style = require("lib-source/v2/style");

var _libSourceUiv2Touchable = require("lib-source/uiv2/Touchable");

var _libSourceUiv2Touchable2 = _interopRequireDefault(_libSourceUiv2Touchable);

var coolBlue = "#2FB1DF";

_libSourceV2Style.defineComponentStyle('flexbox', 'core', {
    "container": {
        display: ['-webkit-flex', 'flex'],
        WebkitFlexWrap: 'wrap',
        flexWrap: 'wrap'
    }
});
// alignItems: 'center',
// justifyContent: 'center'
var Flexbox = function Flexbox(props) {
    var colCount = props.colCount;
    var _props$width = props.width;
    var width = _props$width === undefined ? '100%' : _props$width;
    var _props$padEnd = props.padEnd;
    var padEnd = _props$padEnd === undefined ? false : _props$padEnd;
    var _props$minItemWidth = props.minItemWidth;
    var minItemWidth = _props$minItemWidth === undefined ? null : _props$minItemWidth;
    var _props$maxItemWidth = props.maxItemWidth;
    var maxItemWidth = _props$maxItemWidth === undefined ? null : _props$maxItemWidth;
    var _props$align = props.align;
    var align = _props$align === undefined ? 'center' : _props$align;

    var flexWidth = 100 / colCount;
    var children = props.children;

    if (isNaN(flexWidth) === true || flexWidth <= 0) {
        throw new Error("Invalid width property for Flexbox");
    }

    children = React.Children.toArray(children);
    if (padEnd === true && minItemWidth === null && maxItemWidth === null) {
        var filler = new Array(colCount - children.length % colCount).fill(null).map(function () {
            return React.createElement("div", null);
        });
        children = [].concat(children, filler);
    }

    children = children.map(function (child, index) {
        return React.createElement(FlexboxItem, { key: index, width: flexWidth, content: child, minWidth: minItemWidth, maxWidth: maxItemWidth });
    });

    // console.trace();

    return React.createElement(
        "div",
        { style: { width: width, justifyContent: align, WebkitJustifyContent: align }, className: "flexbox-core-container" },
        children
    );
};
var FlexboxItem = function FlexboxItem(_ref) {
    var content = _ref.content;
    var width = _ref.width;
    var maxWidth = _ref.maxWidth;
    var minWidth = _ref.minWidth;

    var flexCSS = "1 0 " + width + "%";
    var itemStyle = {
        WebkitFlex: flexCSS,
        flex: flexCSS,
        maxWidth: maxWidth,
        minWidth: minWidth
    };

    return React.createElement(
        "div",
        { style: itemStyle },
        content
    );
};

_libSourceV2Style.defineComponentStyle("flexbox-radio", 'core', {
    'item': {
        transition: 'background-color 500ms linear'
    },
    "item:active": {
        backgroundColor: 'rgba(0, 0, 0, 0.1)',
        transition: 'none'
    },
    "item[data-checked='true']": {
        backgroundColor: coolBlue,
        color: 'white',
        transition: 'none'
    }
});
Flexbox.RadioItem = function (_ref2) {
    var children = _ref2.children;
    var checked = _ref2.checked;
    var onTap = _ref2.onTap;
    return React.createElement(
        _libSourceUiv2Touchable2["default"],
        { component: "div", className: "flexbox-radio-core-item", "data-checked": checked, onTap: onTap },
        children
    );
};

exports["default"] = Flexbox;
module.exports = exports["default"];

},{"babel-runtime/helpers/interop-require-default":61,"lib-source/uiv2/Touchable":24,"lib-source/v2/style":43}],34:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("babel-runtime/helpers/interop-require-default")["default"];

exports.__esModule = true;

var _libSourceV2Style = require("lib-source/v2/style");

var _libSourceUiv2Touchable = require("lib-source/uiv2/Touchable");

var _libSourceUiv2Touchable2 = _interopRequireDefault(_libSourceUiv2Touchable);

var coolBlue = "#2FB1DF";

_libSourceV2Style.defineComponentStyle('grid', 'core', {
    "item": {
        position: "absolute"
    }
});

var Grid = function Grid(_ref) {
    var children = _ref.children;
    var colCount = _ref.colCount;
    var rowCount = _ref.rowCount;
    var _ref$width = _ref.width;
    var width = _ref$width === undefined ? '100%' : _ref$width;
    var _ref$height = _ref.height;
    var height = _ref$height === undefined ? '100%' : _ref$height;

    if (height === null) {
        throw new Error("Height needs to be given to the grid");
    }
    var itemWidth = 100 / colCount;
    var itemHeight = 100 / rowCount;
    var gridStyle = {
        position: 'relative',
        overflow: 'hidden',
        width: width,
        height: height
    };

    children = React.Children.toArray(children);

    return React.createElement(
        "div",
        { style: gridStyle },
        children.map(function (child, index) {
            return React.createElement(GridItem, { key: index, width: itemWidth, height: itemHeight, x: index % colCount, y: Math.floor(index / colCount), content: child });
        })
    );
};
var GridItem = function GridItem(_ref2) {
    var width = _ref2.width;
    var height = _ref2.height;
    var x = _ref2.x;
    var y = _ref2.y;
    var content = _ref2.content;

    var style = {
        width: width + "%",
        height: height + "%",
        left: x * width + "%",
        top: y * height + "%"
    };

    return React.createElement(
        "div",
        { className: "grid-core-item", style: style },
        content
    );
};

_libSourceV2Style.defineComponentStyle("grid-radio", 'core', {
    'item': {
        width: '100%',
        height: '100%',
        transition: 'background-color 500ms linear'
    },
    "item:active": {
        backgroundColor: 'rgba(0, 0, 0, 0.1)',
        transition: 'none'
    },
    "item[data-checked='true']": {
        backgroundColor: coolBlue,
        color: 'white',
        transition: 'none'
    }
});
Grid.RadioItem = function (_ref3) {
    var children = _ref3.children;
    var checked = _ref3.checked;
    var onTap = _ref3.onTap;
    return React.createElement(
        _libSourceUiv2Touchable2["default"],
        { component: "div", className: "grid-radio-core-item", "data-checked": checked, onTap: onTap },
        children
    );
};

exports["default"] = Grid;
module.exports = exports["default"];

},{"babel-runtime/helpers/interop-require-default":61,"lib-source/uiv2/Touchable":24,"lib-source/v2/style":43}],35:[function(require,module,exports){
"use strict";

var _extends = require("babel-runtime/helpers/extends")["default"];

var _objectWithoutProperties = require("babel-runtime/helpers/object-without-properties")["default"];

var _interopRequireDefault = require("babel-runtime/helpers/interop-require-default")["default"];

exports.__esModule = true;

var _libSourceV2Style = require("lib-source/v2/style");

var _libSourceUiv2Touchable = require("lib-source/uiv2/Touchable");

var _libSourceUiv2Touchable2 = _interopRequireDefault(_libSourceUiv2Touchable);

var coolBlue = "#2FB1DF";

_libSourceV2Style.defineComponentStyle("pinboard", 'core', {
    'container': {
        position: 'relative'
    }
});
var Pinboard = function Pinboard(_ref) {
    var children = _ref.children;
    var _ref$width = _ref.width;
    var width = _ref$width === undefined ? '100%' : _ref$width;
    var _ref$height = _ref.height;
    var height = _ref$height === undefined ? '100%' : _ref$height;

    children = React.Children.toArray(children);

    children = children.map(function (child, index) {
        var _child$props = child.props;
        var pinInfo = _child$props.pinInfo;

        var props = _objectWithoutProperties(_child$props, ["pinInfo"]);

        // const {props: {pinInfo}} = child;
        var displayedChild = React.createElement(child.type, props);
        // child = React.clone
        // console.log(child.type);

        return React.createElement(
            "div",
            { key: index, style: _extends({}, pinInfo, { position: 'absolute' }) },
            displayedChild
        );
    });

    return React.createElement(
        "div",
        { style: { position: 'relative', width: width, height: height } },
        children
    );
};
_libSourceV2Style.defineComponentStyle("pinboard-radio", 'core', {
    'item': {
        width: '100%',
        height: '100%',
        transition: 'background-color 500ms linear'
    },
    "item:active": {
        backgroundColor: 'rgba(0, 0, 0, 0.1)',
        transition: 'none'
    },
    "item[data-checked='true']": {
        backgroundColor: coolBlue,
        color: 'white',
        transition: 'none'
    }
});
Pinboard.RadioItem = function (_ref2) {
    var children = _ref2.children;
    var checked = _ref2.checked;
    var onTap = _ref2.onTap;
    return React.createElement(
        _libSourceUiv2Touchable2["default"],
        { component: "div", className: "pinboard-radio-core-item", "data-checked": checked, onTap: onTap },
        children
    );
};

exports["default"] = Pinboard;
module.exports = exports["default"];

},{"babel-runtime/helpers/extends":59,"babel-runtime/helpers/interop-require-default":61,"babel-runtime/helpers/object-without-properties":62,"lib-source/uiv2/Touchable":24,"lib-source/v2/style":43}],36:[function(require,module,exports){
'use strict';

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

exports.__esModule = true;

var _libSourceV2StyleJs = require("lib-source/v2/style.js");

var animationDuration = 300;
_libSourceV2StyleJs.defineComponentStyle('ripple', 'core', {
    "wrapper": {
        position: 'absolute',
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        zIndex: '+5'
        // transform: 'translate3d(0, 0, 0)'
    },
    "dot": {
        position: 'absolute',
        transform: 'translate(-50%, -50%)',
        animation: 'ripple-core-animation-ripple-effect ' + animationDuration + 'ms linear',
        borderRadius: '50%',
        display: 'inline-block',
        width: '250%'
    },
    "dot:before": {
        paddingTop: '100%',
        content: '""',
        float: 'left'
    },
    "!ripple-effect": {
        "0%": {
            transform: 'translate(-50%, -50%) scale(0, 0)',
            // width: 0,
            backgroundColor: 'rgba(0, 0, 0, 0)'
        },
        "70%": {
            backgroundColor: 'rgba(0, 0, 0, 0.1)'
        },
        "100%": {
            transform: 'translate(-50%, -50%) scale(1, 1)',
            // width: '150%',
            backgroundColor: 'rgba(0, 0, 0, 0.0)'
        }
    }
});

var Ripple = (function (_React$Component) {
    _inherits(Ripple, _React$Component);

    function Ripple(props) {
        var _this = this;

        _classCallCheck(this, Ripple);

        _React$Component.call(this, props);

        this.touch = function (evt) {
            var position = evt.touch.position;

            var _refs$wrapper$getBoundingClientRect = _this.refs.wrapper.getBoundingClientRect();

            var top = _refs$wrapper$getBoundingClientRect.top;
            var left = _refs$wrapper$getBoundingClientRect.left;

            _this.triggerRipple(position.x - left, position.y - top);
        };

        this.triggerRipple = function (x, y) {
            if (x === undefined) x = null;
            var list = _this.state.list;

            if (x === null) {
                var _refs$wrapper$getBoundingClientRect2 = _this.refs.wrapper.getBoundingClientRect();

                var width = _refs$wrapper$getBoundingClientRect2.width;
                var height = _refs$wrapper$getBoundingClientRect2.height;

                x = width / 2;
                y = height / 2;
            }

            chrono.trigger(animationDuration, function () {
                if (_this.active === false) {
                    return;
                }
                _this.setState({
                    list: _this.state.list.slice(1)
                });
            });
            list = [].concat(list, [{ x: x, y: y, id: Date.now() }]);

            _this.setState({ list: list });
        };

        this.componentDidMount = function () {
            _this.active = true;
        };

        this.componentWillUnmount = function () {
            _this.active = false;
            // console.log('removing');
        };

        this.render = function () {
            var list = _this.state.list;

            return React.createElement(
                UI.Touchable,
                { component: 'div', className: 'ripple-core-wrapper', onTap: _this.touch, ref: 'wrapper' },
                list.map(function (_ref) {
                    var id = _ref.id;
                    var x = _ref.x;
                    var y = _ref.y;
                    return React.createElement('div', { key: id, style: { top: y, left: x }, className: 'ripple-core-dot' });
                })
            );
        };

        this.state = { list: [] };
    }

    return Ripple;
})(React.Component);

exports['default'] = Ripple;
module.exports = exports['default'];

},{"babel-runtime/helpers/class-call-check":58,"babel-runtime/helpers/inherits":60,"lib-source/v2/style.js":43}],37:[function(require,module,exports){
"use strict";

var _Object$freeze = require("babel-runtime/core-js/object/freeze")["default"];

exports.__esModule = true;
var rgb = function rgb(r, g, b) {
    return "rgba(" + r + ", " + g + ", " + b + ")";
};
var rgba = function rgba(r, g, b, a) {
    return "rgba(" + r + ", " + g + ", " + b + ", " + a + ")";
};

var hoverColor = rgba(0, 0, 0, 0.1);
var activeColor = rgba(0, 0, 0, 0.2);
var shadow = null;

exports["default"] = _Object$freeze({
    rgb: rgb, rgba: rgba,

    hoverColor: hoverColor,
    activeColor: activeColor,
    shadow: shadow
});
module.exports = exports["default"];

},{"babel-runtime/core-js/object/freeze":52}],38:[function(require,module,exports){
'use strict';

var _Object$freeze = require('babel-runtime/core-js/object/freeze')['default'];

exports.__esModule = true;
exports['default'] = _Object$freeze({
    mobile: typeof orientation !== 'undefined' || navigator.userAgent.indexOf("Mobile") !== -1,
    app: typeof cordova !== 'undefined'
});
module.exports = exports['default'];

},{"babel-runtime/core-js/object/freeze":52}],39:[function(require,module,exports){
"use strict";

var _Promise = require("babel-runtime/core-js/promise")["default"];

var _Object$entries = require("babel-runtime/core-js/object/entries")["default"];

var _getIterator = require("babel-runtime/core-js/get-iterator")["default"];

var _Object$defineProperties = require("babel-runtime/core-js/object/define-properties")["default"];

exports.__esModule = true;
var ajax = function ajax(url) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
    return new _Promise(function (resolve, reject) {
        var _options$headers = options.headers;
        var headers = _options$headers === undefined ? {} : _options$headers;
        var _options$timeout = options.timeout;
        var timeout = _options$timeout === undefined ? 0 : _options$timeout;
        var _options$type = options.type;
        var type = _options$type === undefined ? null : _options$type;
        var _options$onProgress = options.onProgress;
        var onProgress = _options$onProgress === undefined ? function () {} : _options$onProgress;
        var _options$token = options.token;
        var token = _options$token === undefined ? null : _options$token;

        var request = new XMLHttpRequest();
        var _options$post = options.post;
        var post = _options$post === undefined ? null : _options$post;

        var contentType = null;
        var method = undefined;

        if (token !== null && token.used === false) {
            token.bindTo(request);
        }

        if (post === null) {
            method = 'GET';
        } else {
            method = "POST";
            if (FormData.prototype.isPrototypeOf(post) === false) {
                debugger;
                post = JSON.stringify(post);
                contentType = "application/json";
            }
        }

        if (type !== null) {
            request.responseType = type;
        }

        request.addEventListener('load', function () {
            if (request.status === 0 || request.status >= 200 && request.status < 300) {
                resolve({
                    status: request.status,
                    statusText: request.statusText,
                    response: request.response,
                    request: request
                });
            } else {
                reject(request);
            }
        });
        request.addEventListener("error", reject);
        request.addEventListener("timeout", reject);
        request.addEventListener("abort", function () {
            return resolve(null);
        });
        request.addEventListener("progress", onProgress);

        try {
            request.open(method, url, true);
            request.timeout = timeout;
            for (var _iterator = _Object$entries(headers), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {
                var _ref;

                if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref = _iterator[_i++];
                } else {
                    _i = _iterator.next();
                    if (_i.done) break;
                    _ref = _i.value;
                }

                var header = _ref[0];
                var value = _ref[1];

                request.setRequestHeader(header, value);
            }
            request.setRequestHeader("Accept", "");
            request.setRequestHeader("Accept", "*/*");
            if (contentType !== null) {
                request.setRequestHeader("Content-Type", contentType);
            }
            request.send(post);
        } catch (error) {
            reject(error);
        }
    });
};
ajax.cancelToken = function () {
    var request = null;

    return _Object$defineProperties({
        cancel: function cancel() {
            if (request !== null) {
                request.abort();
            }
        },

        bindTo: function bindTo(req) {
            if (request === null) {
                request = req;
            }
        }
    }, {
        used: {
            get: function get() {
                return request !== null;
            },
            configurable: true,
            enumerable: true
        }
    });
};

exports["default"] = ajax;
module.exports = exports["default"];

},{"babel-runtime/core-js/get-iterator":47,"babel-runtime/core-js/object/define-properties":50,"babel-runtime/core-js/object/entries":51,"babel-runtime/core-js/promise":55}],40:[function(require,module,exports){
'use strict';

var _Object$defineProperties = require('babel-runtime/core-js/object/define-properties')['default'];

var _Object$entries = require('babel-runtime/core-js/object/entries')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _Promise = require('babel-runtime/core-js/promise')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

exports.__esModule = true;

var _xregexp = require("xregexp");

var _xregexp2 = _interopRequireDefault(_xregexp);

var chronoSpecial = {
    'yesterday': function yesterday(date) {
        date.setDate(date.getDate() - 1);
        return date;
    },
    '1 week ago': function weekAgo(date) {
        date.setDate(date.getDate() - 7);
        return date;
    }
};
var chronoUnitRegex = _xregexp2['default']("(?<offset>(\\+|\\-)\\d+) (?<unit>\\w+)");
var unitFunction = {
    millisecond: function millisecond(date, milliseconds) {
        date.setMilliseconds(date.getMilliseconds() + milliseconds);
        return date;
    },
    second: function second(date, seconds) {
        date.setSeconds(date.getSeconds() + seconds);
        return date;
    },
    minute: function minute(date, minutes) {
        date.setMinutes(date.getMinutes() + minutes);
        return date;
    },
    hour: function hour(date, hours) {
        date.setHours(date.getHours() + hours);
        return date;
    },
    day: function day(date, days) {
        date.setDate(date.getDate() + days);
        return date;
    },
    week: function week(date, weeks) {
        date.setDate(date.getDate() + weeks * 7);
        return date;
    },
    month: function month(date, months) {
        var expected = date.getMonth() + months;
        date.setMonth(expected);
        if (date.getMonth() !== expected) {
            date.setDate(0);
        }
        return date;
    },
    year: function year(date, years) {
        date.setFullYear(date.getFullYear() + years);
        return date;
    },
    decade: function decade(date, decades) {
        date.setFullYear(date.getFullYear() + decades * 10);
        return date;
    }
};
var _startOf = {
    second: function second(date) {
        date.setMilliseconds(0);
    },
    minute: function minute(date) {
        _startOf.second(date);
        date.setSeconds(0);
    },
    hour: function hour(date) {
        _startOf.minute(date);
        date.setMinutes(0);
    },
    day: function day(date) {
        _startOf.hour(date);
        date.setHours(0);
    },
    week: function week(date) {
        _startOf.day(date);
        date.setDate(date.getDate() - date.getDay());
    },
    month: function month(date) {
        _startOf.day(date);
        date.setDate(1);
    },
    year: function year(date) {
        _startOf.month(date);
        date.setMonth(0);
    }
};
var _endOf = {
    second: function second(date) {
        date.setMilliseconds(999);
    },
    minute: function minute(date) {
        _endOf.second(date);
        date.setSeconds(59);
    },
    hour: function hour(date) {
        _endOf.minute(date);
        date.setMinutes(59);
    },
    day: function day(date) {
        _endOf.hour(date);
        date.setHours(23);
    },
    week: function week(date) {
        _endOf.day(date);
        date.setDate(date.getDate() + (6 - date.getDay()));
    },
    month: function month(date) {
        _endOf.day(date);
        date.setMonth(date.getMonth() + 1);
        date.setDate(0);
    },
    year: function year(date) {
        _endOf.month(date);
        date.setMonth(11);
    }
};
var unitConversion = {
    'millisecond': 'millisecond',
    'milliseconds': 'millisecond',
    'ms': 'millisecond',

    'second': 'second',
    'seconds': 'second',
    's': 'second',

    'minute': 'minute',
    'minutes': 'minute',
    'min': 'minute',

    'hour': 'hour',
    'hours': 'hour',
    'hr': 'hour',

    'day': 'day',
    'days': 'day',
    'ni': 'day',
    'hi': 'day',
    '': 'day',

    'week': 'week',
    'weeks': 'week',
    'shuu': 'week',
    '': 'week',
    '': 'week',

    'month': 'month',
    'months': 'month',

    'year': 'year',
    'years': 'year',

    'decade': 'decade',
    'decades': 'decade'
};
var chronoInfo = {
    days: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
    months: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']
};
var chronoFormat = {
    ms: {
        base: function base(date) {
            return date.getMilliseconds();
        },
        padded: function padded(date) {
            return ('00' + date.getMilliseconds()).slice(-3);
        }
    },
    second: {
        base: function base(date) {
            return date.getSeconds();
        },
        padded: function padded(date) {
            return ('0' + date.getSeconds()).slice(-2);
        }
    },
    minute: {
        base: function base(date) {
            return date.getMinutes();
        },
        padded: function padded(date) {
            return ('0' + date.getMinutes()).slice(-2);
        }
    },
    hour: {
        base: function base(date) {
            return date.getHours();
        },
        padded: function padded(date) {
            return ('0' + date.getHours()).slice(-2);
        },
        "12": function _(date) {
            var hour = date.getHours() % 12;
            if (hour === 0) {
                return 12;
            }
            return hour;
        },
        "12padded": function padded(date) {
            return ('0' + chronoFormat.hour['12'](date)).slice(-2);
        }
    },
    weekday: {
        base: function base(date) {
            return date.getDay();
        },
        short: function short(date) {
            return chronoInfo.days[date.getDay()].slice(0, 3);
        },
        full: function full(date) {
            return chronoInfo.days[date.getDay()];
        }
    },
    date: {
        base: function base(date) {
            return date.getDate();
        },
        padded: function padded(date) {
            return ('0' + date.getDate()).slice(-2);
        }
    },
    month: {
        base: function base(date) {
            return date.getMonth() + 1;
        },
        short: function short(date) {
            return chronoInfo.months[date.getDate()].slice(0, 3);
        },
        full: function full(date) {
            return chronoInfo.months[date.getDate()];
        }
    },
    year: {
        base: function base(date) {
            return date.getFullYear() % 100;
        },
        full: function full(date) {
            return date.getFullYear();
        }
    },
    tod: {
        base: function base(date) {
            return date.getHours() < 12 === true ? "AM" : "PM";
        }
    }
};
chronoFormat.day = chronoFormat.date;
var chronoCheckUnit = function chronoCheckUnit(unit) {
    if (unitConversion.hasOwnProperty(unit) === false) {
        throw new Error('Unrecognized unit: ' + unit);
    }
};

/* -AxelDoc-
module global {
    @function chrono {
        @desc Creates a new instance of {chrono}.
        @args {
            @arg dateTime [Date]
                This is some long description of the thing
                {year, month} destructuring?
                [title]year[title]
        }
        @return chrono

        @function diff {
            @desc A function that will calculate the amount of time to add to the first argument in order to get the second argument.
            @args {
                @arg startDate [chrono] The date to start from.
                @arg targetDate [chrono] The date to get to.
            }
            @return object
        }
        @function now {
            @desc Returns the current date as a chrono object.
            @args {}
            @return chrono
        }
        @function parse {
            @desc Parses a date string and returns the chrono object represented by it.
            @args {
                @arg dateString [string] The string to parse.
            }
            @return chrono
        }
        @function parseMS {
            @desc Parses a date string generated by C# code and returns the chrono object represented by it.
            @args {
                @arg dateString [string] The string to parse.
            }
            @return chrono
        }
        @function trigger {
            @desc Fires a function after a specified time.
            @args {
                @arg delay [number] The number of milliseconds to wait.
                @arg func [function] The function to call.
            }
            @return chronoTrigger
        }
    }

    object chrono {
        @prop dateObject {
            @desc Gets a copy of the internal Date object.
            @type Date
        }

        @prop unixTimestamp {
            @desc Gets the unix timestamp of the chrono object.
            @type number
        }

        @prop milliseconds {
            @desc Gets the milliseconds of the chrono object.
            @type number
        }
        @prop seconds {
            @desc Gets the seconds of the chrono object.
            @type number
        }
        @prop minutes {
            @desc Gets the minutes of the chrono object.
            @type number
        }
        @prop hours {
            @desc Gets the hours of the chrono object.
            @type number
        }
        @prop weekday {
            @desc Gets the weekday of the chrono object.
            @type number
        }
        @prop date {
            @desc Gets the date of the chrono object. This number is adjusted to the range (0-30) unlike the normal Date object.
            @type number
        }
        @prop months {
            @desc Gets the months of the chrono object.
            @type number
        }
        @prop year {
            @desc Gets the year of the chrono object.
            @type number
        }

        @function shift {
            @desc Shifts the date forward or backward in time.
            @args {
                @arg offset [Number] The amount of time to shift the date.
                @arg unit [String] The units to shift by. Valid values are: 'second', 'minute', 'hour', 'day', 'week', 'month', 'year', 'decade'.
            }
            @args {
                @arg duration [object] An object that will shift the date.
            }
            @return chrono
        }
        @function startOf {
            @desc Moves the date to the start of the specified unit.
            @args {
                @arg unit [string] The unit to move to the start of. Valid values are: 'second', 'minute', 'hour', 'day', 'week', 'month', 'year'.
            }
            @return chrono
        }
        @function format {
            @desc Formats the chrono object using the specified string.
            @args {
                @arg format [string] The string describing the format the date should be put into.
            }
            @return string
        }
    }

    object chronoTrigger {
        @prop status {
            @desc The status of the trigger.
            @type string
        }

        @function cancel {
            @desc Cancels the trigger if it hasn't fired yet.
        }
    }
}
*/
var chrono = function chrono() {
    var arg = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];

    var internalDate = (function () {
        if (arg === null) {
            return new Date();
        }

        if (Date.prototype.isPrototypeOf(arg) === true || typeof arg === 'number') {
            return new Date(arg);
        }

        if (arg.__chrono === true) {
            return arg.dateObject;
        }

        if (typeof arg === 'string') {
            arg = arg.toLowerCase();
            if (chronoSpecial.hasOwnProperty(arg) === true) {
                return chronoSpecial[arg](new Date());
            }

            var match = _xregexp2['default'].exec(arg, chronoUnitRegex);
            if (match !== null) {
                var offset = match.offset;
                var unit = match.unit;

                chronoCheckUnit(unit);

                return unitFunction[unitConversion[unit]](new Date(), parseInt(offset));
            }

            return new Date(arg);
        }

        var _arg = arg;
        var _arg$year = _arg.year;
        var year = _arg$year === undefined ? 1970 : _arg$year;
        var _arg$month = _arg.month;
        var month = _arg$month === undefined ? 0 : _arg$month;
        var _arg$date = _arg.date;
        var date = _arg$date === undefined ? 0 : _arg$date;
        var _arg$hours = _arg.hours;
        var hours = _arg$hours === undefined ? 0 : _arg$hours;
        var _arg$minutes = _arg.minutes;
        var minutes = _arg$minutes === undefined ? 0 : _arg$minutes;
        var _arg$seconds = _arg.seconds;
        var seconds = _arg$seconds === undefined ? 0 : _arg$seconds;
        var _arg$milliseconds = _arg.milliseconds;
        var milliseconds = _arg$milliseconds === undefined ? 0 : _arg$milliseconds;

        return new Date(year, month, date + 1, hours, minutes, seconds, milliseconds);
    })();

    return _Object$defineProperties({
        __chrono: true,

        set: function set(props) {
            var _props$year = props.year;
            var year = _props$year === undefined ? internalDate.getFullYear() : _props$year;
            var _props$month = props.month;
            var month = _props$month === undefined ? internalDate.getMonth() : _props$month;
            var _props$date = props.date;
            var date = _props$date === undefined ? internalDate.getDate() - 1 : _props$date;
            var _props$hours = props.hours;
            var hours = _props$hours === undefined ? internalDate.getHours() : _props$hours;
            var _props$minutes = props.minutes;
            var minutes = _props$minutes === undefined ? internalDate.getMinutes() : _props$minutes;
            var _props$seconds = props.seconds;
            var seconds = _props$seconds === undefined ? internalDate.getSeconds() : _props$seconds;
            var _props$milliseconds = props.milliseconds;
            var milliseconds = _props$milliseconds === undefined ? internalDate.getMilliseconds() : _props$milliseconds;

            return chrono(new Date(year, month, date + 1, hours, minutes, seconds, milliseconds));
        },
        shift: function shift(offset, unit) {
            var newDate = undefined;
            newDate = new Date(internalDate);

            if (typeof offset === 'object') {
                // if (offset.hasOwnProperty('__chrono_duration') && offset.__chrono_duration === true) {
                //     offset = offset.asObject();

                for (var _iterator = _Object$entries(offset), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {
                    var _ref;

                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        _i = _iterator.next();
                        if (_i.done) break;
                        _ref = _i.value;
                    }

                    var _unit = _ref[0];
                    var value = _ref[1];

                    chronoCheckUnit(_unit);
                    newDate = unitFunction[unitConversion[_unit]](newDate, value);
                }

                return chrono(newDate);
            } else {
                if (typeof offset === 'string') {
                    var match = _xregexp2['default'].exec(offset, chronoUnitRegex);

                    offset = match.offset;
                    unit = match.unit;

                    chronoCheckUnit(unit);
                    offset = parseInt(offset);
                }

                return chrono(unitFunction[unitConversion[unit]](newDate, offset));
            }
        },
        startOf: function startOf(unit) {
            var adjustedDate = new Date(internalDate);

            _startOf[unit](adjustedDate);

            return chrono(adjustedDate);
        },
        endOf: function endOf(unit) {
            var adjustedDate = new Date(internalDate);

            _endOf[unit](adjustedDate);

            return chrono(adjustedDate);
        },
        format: function format() {
            var formatString = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];

            if (formatString === null) {
                return internalDate.toString();
            }

            if (formatString === 'utc') {
                return internalDate.toUTCString();
            }
            if (formatString === 'locale') {
                return internalDate.toLocaleString();
            }

            return formatString.replace(/\{(\w+)(\/(\w+))?\}/g, function (full, prop, skip) {
                var type = arguments.length <= 3 || arguments[3] === undefined ? 'base' : arguments[3];
                return chronoFormat[prop][type](internalDate);
            });
        },
        toString: function toString() {
            return internalDate.toString();
        },
        toJSON: function toJSON() {
            return internalDate.toJSON();
        }
    }, {
        dateObject: {
            get: function get() {
                return new Date(internalDate);
            },
            configurable: true,
            enumerable: true
        },
        unixTimestamp: {
            get: function get() {
                return internalDate.getTime();
            },
            configurable: true,
            enumerable: true
        },
        milliseconds: {
            get: function get() {
                return internalDate.getMilliseconds();
            },
            configurable: true,
            enumerable: true
        },
        seconds: {
            get: function get() {
                return internalDate.getSeconds();
            },
            configurable: true,
            enumerable: true
        },
        minutes: {
            get: function get() {
                return internalDate.getMinutes();
            },
            configurable: true,
            enumerable: true
        },
        hours: {
            get: function get() {
                return internalDate.getHours();
            },
            configurable: true,
            enumerable: true
        },
        weekday: {
            get: function get() {
                return internalDate.getDay();
            },
            configurable: true,
            enumerable: true
        },
        date: {
            get: function get() {
                return internalDate.getDate() - 1;
            },
            configurable: true,
            enumerable: true
        },
        month: {
            get: function get() {
                return internalDate.getMonth();
            },
            configurable: true,
            enumerable: true
        },
        year: {
            get: function get() {
                return internalDate.getFullYear();
            },
            configurable: true,
            enumerable: true
        }
    });
};
chrono.diff = function (first, second) {
    var internalDate = new Date(second.unixTimestamp - first.unixTimestamp);
    console.log(second.unixTimestamp - first.unixTimestamp);
    console.log(internalDate);

    return {
        milliseconds: internalDate.getMilliseconds(),
        seconds: internalDate.getSeconds(),
        minutes: internalDate.getMinutes(),
        hours: internalDate.getHours(),
        days: internalDate.getDate() - 1,
        months: internalDate.getMonth(),
        years: internalDate.getFullYear() - 1970
    };
};
chrono.now = function () {
    return chrono(Date.now());
};
chrono.parse = function (string) {
    return chrono(Date.parse(string));
};
chrono.parseMS = function (string) {
    return chrono(Date.parse(string.replace("T", " ")));
};
chrono.trigger = function (delay, func) {
    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        args[_key - 2] = arguments[_key];
    }

    var id = setTimeout(function () {
        status = 'fired';
        func.apply(undefined, args);
    }, delay);
    var status = undefined;

    status = 'waiting';

    return _Object$defineProperties({
        cancel: function cancel() {
            status = 'cancelled';
            clearTimeout(id);
        }
    }, {
        status: {
            get: function get() {
                return status;
            },
            configurable: true,
            enumerable: true
        }
    });
};
chrono.wait = function (wait) {
    return new _Promise(function (resolve) {
        return setTimeout(function () {
            return resolve(null);
        }, wait);
    });
};

exports['default'] = chrono;
module.exports = exports['default'];
// }

},{"babel-runtime/core-js/get-iterator":47,"babel-runtime/core-js/object/define-properties":50,"babel-runtime/core-js/object/entries":51,"babel-runtime/core-js/promise":55,"babel-runtime/helpers/interop-require-default":61,"xregexp":370}],41:[function(require,module,exports){
(function (Buffer){
'use strict';

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

exports.__esModule = true;

var _crypto = require("crypto");

var _crypto2 = _interopRequireDefault(_crypto);

var encrypt = undefined;
var decrypt = undefined;
var hash = undefined;

encrypt = function (str, key) {
    var _ref = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

    var _ref$iv = _ref.iv;
    var iv = _ref$iv === undefined ? null : _ref$iv;
    var _ref$algorithm = _ref.algorithm;
    var algorithm = _ref$algorithm === undefined ? 'aes256' : _ref$algorithm;
    var _ref$output = _ref.output;
    var output = _ref$output === undefined ? 'hex' : _ref$output;
    var _ref$input = _ref.input;
    var input = _ref$input === undefined ? 'utf8' : _ref$input;

    var encryptor = undefined;
    var result = undefined;

    key = new Buffer(key);

    if (iv === null) {
        encryptor = _crypto2['default'].createCipher(algorithm, key);
    } else {
        iv = new Buffer(iv);
        encryptor = _crypto2['default'].createCipher(algorithm, key, iv);
    }

    result = encryptor.update(str, input, output);
    result += encryptor.final(output);
    encryptor = null;
    str = null;
    key.fill(0);

    return result;
};

decrypt = function (str, key) {
    var _ref2 = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

    var _ref2$iv = _ref2.iv;
    var iv = _ref2$iv === undefined ? null : _ref2$iv;
    var _ref2$algorithm = _ref2.algorithm;
    var algorithm = _ref2$algorithm === undefined ? 'aes256' : _ref2$algorithm;
    var _ref2$input = _ref2.input;
    var input = _ref2$input === undefined ? 'hex' : _ref2$input;
    var _ref2$output = _ref2.output;
    var output = _ref2$output === undefined ? 'utf8' : _ref2$output;

    var decryptor = undefined;
    var result = undefined;

    key = new Buffer(key);

    if (iv === null) {
        decryptor = _crypto2['default'].createDecipher(algorithm, key);
    } else {
        iv = new Buffer(iv);
        decryptor = _crypto2['default'].createDecipher(algorithm, key, iv);
    }

    result = decryptor.update(str, input, output);
    result += decryptor.final(output);
    decryptor = null;
    str = null;
    key.fill(0);

    return result;
};

hash = function (str) {
    var algorithm = arguments.length <= 1 || arguments[1] === undefined ? 'sha512' : arguments[1];

    var hasher = undefined;

    hasher = _crypto2['default'].createHash(algorithm);
    hasher.update(str, 'utf8');
    str = null;

    return hasher.digest('hex');
};

exports['default'] = {
    encrypt: encrypt,
    decrypt: decrypt,
    hash: hash
};
module.exports = exports['default'];

}).call(this,require("buffer").Buffer)

},{"babel-runtime/helpers/interop-require-default":61,"buffer":152,"crypto":156}],42:[function(require,module,exports){
"use strict";

var _inherits = require("babel-runtime/helpers/inherits")["default"];

var _classCallCheck = require("babel-runtime/helpers/class-call-check")["default"];

var _objectWithoutProperties = require("babel-runtime/helpers/object-without-properties")["default"];

var _extends = require("babel-runtime/helpers/extends")["default"];

var _Object$defineProperties = require("babel-runtime/core-js/object/define-properties")["default"];

exports.__esModule = true;
var sharedReference = function sharedReference(value) {
    return _Object$defineProperties({
        set: function set(newValue) {
            value = newValue;
        }
    }, {
        value: {
            get: function get() {
                return value;
            },
            configurable: true,
            enumerable: true
        }
    });
};

var SharedObjectDisplay = (function (_React$Component) {
    _inherits(SharedObjectDisplay, _React$Component);

    function SharedObjectDisplay(props) {
        var _this = this;

        _classCallCheck(this, SharedObjectDisplay);

        _React$Component.call(this, props);

        this.update = function (value) {
            _this.props.reference.set(value);
            _this.setState({ value: value });
        };

        this.render = function () {
            var _ref;

            var _props = _this.props;
            var Component = _props.component;
            var reference = _props.reference;
            var valueProp = _props.valueProp;
            var containerStyle = _props.containerStyle;

            var props = _objectWithoutProperties(_props, ["component", "reference", "valueProp", "containerStyle"]);

            var value = _this.state.value;

            return React.createElement(
                "div",
                { style: containerStyle },
                React.createElement(Component, _extends({}, props, (_ref = {}, _ref[valueProp] = value, _ref), { onChange: _this.update }))
            );
        };

        this.state = { value: this.props.reference.value };
    }

    return SharedObjectDisplay;
})(React.Component);

exports.sharedReference = sharedReference;
exports.SharedObjectDisplay = SharedObjectDisplay;

},{"babel-runtime/core-js/object/define-properties":50,"babel-runtime/helpers/class-call-check":58,"babel-runtime/helpers/extends":59,"babel-runtime/helpers/inherits":60,"babel-runtime/helpers/object-without-properties":62}],43:[function(require,module,exports){
"use strict";

var _extends = require("babel-runtime/helpers/extends")["default"];

var _Set = require("babel-runtime/core-js/set")["default"];

var _Object$entries = require("babel-runtime/core-js/object/entries")["default"];

var _getIterator = require("babel-runtime/core-js/get-iterator")["default"];

var _Object$defineProperties = require("babel-runtime/core-js/object/define-properties")["default"];

exports.__esModule = true;
var cssNoMeasurement = new _Set(["animationIterationCount", "boxFlex", "boxFlexGroup", "boxOrdinalGroup", "columnCount", "fillOpacity", "flex", "flexGrow", "flexPositive", "flexShrink", "flexNegative", "flexOrder", "fontWeight", "lineClamp", "lineHeight", "opacity", "order", "orphans", "stopOpacity", "strokeDashoffset", "strokeOpacity", "strokeWidth", "tabSize", "widows", "zIndex", "zoom"]);
var cssPrefixNames = new _Set(['transform', 'box-shadow', 'transition', 'animation', 'animationDelay', 'animationDirection', 'animationDuration', 'animationFillMode', 'animationIterationCount', 'animationName', 'animationPlayState', 'animationTimingFunction']);
var cssPrefixes = ['-webkit-', '-moz-', '-ms-', '-o-', ''];

var getCSSValue = function getCSSValue(prop, value) {
    if (value === null) {
        return null;
    }
    if (typeof value === 'function') {
        value = value();
    }
    if (Array.isArray(value) === true) {
        return value.map(function (value) {
            return getCSSValue(prop, value)[0];
        });
    }
    if (typeof value === 'number' && cssNoMeasurement.has(prop) === false) {
        value += "px";
    }
    return [value];
};
var processSelector = function processSelector(componentName, styleName, selector) {
    var parts = selector.split(/\s+/);
    var realParts = parts.map(function (part) {
        part = part.replace(":active", ".cor-touch-active");
        return part.split('/').map(function (part) {
            switch (true) {
                case part.charAt(0) === "$":
                    return part.slice(1);
                case /^[a-z]/i.test(part) === true:
                    return "." + componentName + "-" + styleName + "-" + part;
                default:
                    return part;
            }
        }).join('');
    });
    return realParts.join(' ');
};
var processDef = function processDef(cssLines, selector, defs) {
    cssLines = [].concat(cssLines, [selector + " {"]);

    var _loop = function () {
        if (_isArray) {
            if (_i >= _iterator.length) return "break";
            _ref = _iterator[_i++];
        } else {
            _i = _iterator.next();
            if (_i.done) return "break";
            _ref = _i.value;
        }

        var cssProp = _ref[0];
        var cssValue = _ref[1];

        var value = getCSSValue(cssProp, cssValue);
        var prop = cssProp.replace(/[A-Z]/g, function (letter) {
            return '-' + letter.toLowerCase();
        });
        if (value !== null) {
            if (cssPrefixNames.has(cssProp) === true) {
                cssLines = [].concat(cssLines, cssPrefixes.map(function (prefix) {
                    return "\t" + prefix + prop + ": " + value[0] + ";";
                }));
            } else {
                cssLines = [].concat(cssLines, value.map(function (value) {
                    return "\t" + prop + ": " + value + ";";
                }));
            }
        }
    };

    for (var _iterator = _Object$entries(defs), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {
        var _ref;

        var _ret = _loop();

        if (_ret === "break") break;
    }
    cssLines = [].concat(cssLines, ["}"]);
    return cssLines;
    // cssLines.push("}");
};

var componentStyles = {};
var createProp = function createProp(object, propName, defaultValue) {
    if (object.hasOwnProperty(propName) === false) {
        object[propName] = defaultValue;
    }
    return object[propName];
};
var defineComponentStyle = function defineComponentStyle(component, styleName, styles) {
    return createProp(createProp(componentStyles, component, {}), styleName, styles);
};
var baseStyles = {};
var defineCustomBase = function defineCustomBase(component, baseFunc) {
    if (typeof component !== 'string') {
        component = component.componentName;
    }
    baseStyles[component] = baseFunc;
};
var propStyleName = function propStyleName(name) {
    return name.replace(/(^\w)|\-\w/g, function (s) {
        return s.slice(-1).toUpperCase();
    });
};
var defineStyleForComponent = function defineStyleForComponent(component, styleName, options) {
    var Component = component;
    var styleDef = baseStyles[component.componentName](options);
    var styledComponent = null;

    if (styleDef === null || styleDef === undefined || typeof styleDef !== 'object') {
        console.warn("Improper type returned from style function for " + component.componentName + ":" + styleName + ". Did you forget to return the constructed style?");
    } else {
        defineComponentStyle(component.componentName, styleName, styleDef);
    }

    styledComponent = function (props) {
        return React.createElement(Component, _extends({}, props, { styleName: styleName }));
    };
    styledComponent.parentInfo = component;
    component[propStyleName(styleName)] = styledComponent;
};

var createStyles = function createStyles() {
    var head = document.querySelector("head");

    //  Iterate over the components that have styles defined
    for (var _iterator2 = _Object$entries(componentStyles), _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _getIterator(_iterator2);;) {
        var _ref2;

        if (_isArray2) {
            if (_i2 >= _iterator2.length) break;
            _ref2 = _iterator2[_i2++];
        } else {
            _i2 = _iterator2.next();
            if (_i2.done) break;
            _ref2 = _i2.value;
        }

        var componentName = _ref2[0];
        var styles = _ref2[1];

        //  Iterate over the various named styles for the given component
        for (var _iterator3 = _Object$entries(styles), _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _getIterator(_iterator3);;) {
            var _ref3;

            if (_isArray3) {
                if (_i3 >= _iterator3.length) break;
                _ref3 = _iterator3[_i3++];
            } else {
                _i3 = _iterator3.next();
                if (_i3.done) break;
                _ref3 = _i3.value;
            }

            var styleName = _ref3[0];
            var styleDefs = _ref3[1];

            var cssLines = [];
            //  Grab all the individual groups of styles defined in the named style
            for (var _iterator4 = _Object$entries(styleDefs), _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _getIterator(_iterator4);;) {
                var _ref4;

                if (_isArray4) {
                    if (_i4 >= _iterator4.length) break;
                    _ref4 = _iterator4[_i4++];
                } else {
                    _i4 = _iterator4.next();
                    if (_i4.done) break;
                    _ref4 = _i4.value;
                }

                var descriptor = _ref4[0];
                var defs = _ref4[1];

                if (descriptor.startsWith("!") === true) {
                    //  Repeat an extra time with prefixed keyframes because ios < 9 is pretty awful
                    cssLines.push("@-webkit-keyframes " + componentName + "-" + styleName + "-animation-" + descriptor.slice(1) + " {");
                    for (var _iterator5 = _Object$entries(defs), _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _getIterator(_iterator5);;) {
                        var _ref5;

                        if (_isArray5) {
                            if (_i5 >= _iterator5.length) break;
                            _ref5 = _iterator5[_i5++];
                        } else {
                            _i5 = _iterator5.next();
                            if (_i5.done) break;
                            _ref5 = _i5.value;
                        }

                        var selector = _ref5[0];
                        var def = _ref5[1];

                        cssLines = processDef(cssLines, selector, def);
                    }
                    cssLines.push("}");

                    //  normal @keyframes css
                    cssLines.push("@keyframes " + componentName + "-" + styleName + "-animation-" + descriptor.slice(1) + " {");
                    for (var _iterator6 = _Object$entries(defs), _isArray6 = Array.isArray(_iterator6), _i6 = 0, _iterator6 = _isArray6 ? _iterator6 : _getIterator(_iterator6);;) {
                        var _ref6;

                        if (_isArray6) {
                            if (_i6 >= _iterator6.length) break;
                            _ref6 = _iterator6[_i6++];
                        } else {
                            _i6 = _iterator6.next();
                            if (_i6.done) break;
                            _ref6 = _i6.value;
                        }

                        var selector = _ref6[0];
                        var def = _ref6[1];

                        cssLines = processDef(cssLines, selector, def);
                    }
                    cssLines.push("}");
                } else {
                    var selector = processSelector(componentName, styleName, descriptor);
                    cssLines = processDef(cssLines, selector, defs);
                }
            }
            var styleTag = document.createElement("style");
            styleTag.setAttribute("type", "text/css");
            styleTag.setAttribute("data-name", componentName + "/" + styleName);
            styleTag.innerHTML = cssLines.join('\n');
            head.appendChild(styleTag);
        }
    }
};

var themeValues = undefined;
var Theme = _Object$defineProperties({
    define: function define(theme) {
        themeValues = theme;
    }
}, {
    variable: {
        get: function get() {
            return themeValues;
        },
        configurable: true,
        enumerable: true
    }
});

exports["default"] = {
    defineComponentStyle: defineComponentStyle,
    defineCustomBase: defineCustomBase,
    defineStyleForComponent: defineStyleForComponent,
    genFontCSS: function genFontCSS(name, dataURI) {
        return {
            fontFamily: "\"" + name + "\"",
            src: "url(\"" + dataURI + "\")",
            fontWeight: "normal",
            fontStyle: "normal"
        };
    },
    Theme: Theme,
    __setup: createStyles
};
module.exports = exports["default"];

},{"babel-runtime/core-js/get-iterator":47,"babel-runtime/core-js/object/define-properties":50,"babel-runtime/core-js/object/entries":51,"babel-runtime/core-js/set":56,"babel-runtime/helpers/extends":59}],44:[function(require,module,exports){
"use strict";

var _Object$entries = require("babel-runtime/core-js/object/entries")["default"];

var _getIterator = require("babel-runtime/core-js/get-iterator")["default"];

var _Object$keys = require("babel-runtime/core-js/object/keys")["default"];

exports.__esModule = true;
var warningFunc = function warningFunc(errorMessage) {
    return function () {
        return console.warn(errorMessage);
    };
};

exports["default"] = {
    warningFunc: warningFunc,
    transferProps: function transferProps(sources) {
        var dest = {};

        for (var _iterator = _Object$entries(sources), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {
            var _ref;

            if (_isArray) {
                if (_i >= _iterator.length) break;
                _ref = _iterator[_i++];
            } else {
                _i = _iterator.next();
                if (_i.done) break;
                _ref = _i.value;
            }

            var destName = _ref[0];
            var source = _ref[1];

            // debugger;
            var sourceObj = source[0];
            var props = source[1];

            var copy = {};

            if (sourceObj !== null) {
                for (var _iterator2 = _Object$entries(props), _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _getIterator(_iterator2);;) {
                    var _ref2;

                    if (_isArray2) {
                        if (_i2 >= _iterator2.length) break;
                        _ref2 = _iterator2[_i2++];
                    } else {
                        _i2 = _iterator2.next();
                        if (_i2.done) break;
                        _ref2 = _i2.value;
                    }

                    var sourceProp = _ref2[0];
                    var destProp = _ref2[1];

                    if (sourceObj[sourceProp] !== undefined) {
                        copy[destProp] = sourceObj[sourceProp];
                    }
                }

                if (_Object$keys(copy).length > 0) {
                    dest[destName] = copy;
                }
            }
        }

        return dest;
    }
};
module.exports = exports["default"];

},{"babel-runtime/core-js/get-iterator":47,"babel-runtime/core-js/object/entries":51,"babel-runtime/core-js/object/keys":53}],45:[function(require,module,exports){
"use strict";

var _Promise = require("babel-runtime/core-js/promise")["default"];

var _Object$defineProperties = require("babel-runtime/core-js/object/define-properties")["default"];

var _regeneratorRuntime = require("babel-runtime/regenerator")["default"];

var _getIterator = require("babel-runtime/core-js/get-iterator")["default"];

var _interopRequireDefault = require("babel-runtime/helpers/interop-require-default")["default"];

exports.__esModule = true;

var _this = this;

require("external/zip.js");

require("external/zip-ext.js");

var _externalDeflateJsSource = require("external/deflate.js.source");

var _externalDeflateJsSource2 = _interopRequireDefault(_externalDeflateJsSource);

var _externalInflateJsSource = require("external/inflate.js.source");

var _externalInflateJsSource2 = _interopRequireDefault(_externalInflateJsSource);

var _externalZWorkerJsSource = require("external/z-worker.js.source");

var _externalZWorkerJsSource2 = _interopRequireDefault(_externalZWorkerJsSource);

var createURL = function createURL(source) {
    var blob = new Blob([source], { type: "application/javascript" });
    return URL.createObjectURL(blob);
};

var workerURL = createURL(_externalZWorkerJsSource2["default"]);
var inflateURL = createURL(_externalInflateJsSource2["default"]);
var deflateURL = createURL(_externalDeflateJsSource2["default"]);

zip.workerScripts = {
    inflater: [workerURL, inflateURL],
    deflater: [workerURL, deflateURL]
};

var zipLib = zip;

window.zip = null;

var readEntry = function readEntry(entry, writer) {
    return new _Promise(function (resolve) {
        return entry.getData(writer, resolve);
    });
};
var zipEntry = function zipEntry(entry) {
    return _Object$defineProperties({
        readText: function readText() {
            return readEntry(entry, new zipLib.TextWriter());
        },
        readBlob: function readBlob() {
            return readEntry(entry, new zipLib.BlobWriter());
        }
    }, {
        entry: {
            get: function get() {
                return entry;
            },
            configurable: true,
            enumerable: true
        }
    });
};

var readArrayBuffer = function readArrayBuffer(buffer) {
    return new _Promise(function (resolve, reject) {
        zipLib.createReader(new zipLib.ArrayBufferReader(buffer), function (reader) {
            reader.getEntries(function (entries) {
                return resolve([entries, reader]);
            });
        });
    });
};
var _download = function _download(url, onProgress) {
    var buffer;
    return _regeneratorRuntime.async(function _download$(context$1$0) {
        while (1) switch (context$1$0.prev = context$1$0.next) {
            case 0:
                context$1$0.next = 2;
                return _regeneratorRuntime.awrap(factotum.ajax(url, { type: 'arraybuffer', onProgress: onProgress }));

            case 2:
                buffer = context$1$0.sent;
                context$1$0.next = 5;
                return _regeneratorRuntime.awrap(readArrayBuffer(buffer.response));

            case 5:
                return context$1$0.abrupt("return", context$1$0.sent);

            case 6:
            case "end":
                return context$1$0.stop();
        }
    }, null, _this);
};

var zipFile = function zipFile(_ref2) {
    var entries = _ref2[0];
    var reader = _ref2[1];

    var entrySort = function entrySort(first, second) {
        if (first.filename < second.filename) {
            return -1;
        }
        if (first.filename > second.filename) {
            return 1;
        }
        return 0;
    };
    var files = entries.sort(entrySort).reduce(function (collection, entry) {
        collection[entry.filename] = entry;
        return collection;
    }, {});
    entries = entries.sort(entrySort);

    return {
        getFile: function getFile(name) {
            if (files.hasOwnProperty(name) === true) {
                return zipEntry(files[name]);
            }
            return null;
        },
        getEntries: function getEntries() {
            return entries.map(zipEntry);
        },
        extractTo: function extractTo(dest) {
            var onProgress = arguments.length <= 1 || arguments[1] === undefined ? function () {} : arguments[1];

            var index, _iterator, _isArray, _i, _ref, entry, filename;

            return _regeneratorRuntime.async(function extractTo$(context$2$0) {
                while (1) switch (context$2$0.prev = context$2$0.next) {
                    case 0:
                        index = undefined;

                        index = 0;
                        _iterator = entries, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);

                    case 3:
                        if (!_isArray) {
                            context$2$0.next = 9;
                            break;
                        }

                        if (!(_i >= _iterator.length)) {
                            context$2$0.next = 6;
                            break;
                        }

                        return context$2$0.abrupt("break", 33);

                    case 6:
                        _ref = _iterator[_i++];
                        context$2$0.next = 13;
                        break;

                    case 9:
                        _i = _iterator.next();

                        if (!_i.done) {
                            context$2$0.next = 12;
                            break;
                        }

                        return context$2$0.abrupt("break", 33);

                    case 12:
                        _ref = _i.value;

                    case 13:
                        entry = _ref;
                        filename = entry.filename;

                        if (!(entry.directory === true)) {
                            context$2$0.next = 20;
                            break;
                        }

                        context$2$0.next = 18;
                        return _regeneratorRuntime.awrap(fs.dirCreate("" + dest + filename));

                    case 18:
                        context$2$0.next = 29;
                        break;

                    case 20:
                        context$2$0.t0 = _regeneratorRuntime;
                        context$2$0.t1 = fs;
                        context$2$0.t2 = "" + dest + filename;
                        context$2$0.next = 25;
                        return _regeneratorRuntime.awrap(zipEntry(entry).readBlob());

                    case 25:
                        context$2$0.t3 = context$2$0.sent;
                        context$2$0.t4 = context$2$0.t1.fileWrite.call(context$2$0.t1, context$2$0.t2, context$2$0.t3);
                        context$2$0.next = 29;
                        return context$2$0.t0.awrap.call(context$2$0.t0, context$2$0.t4);

                    case 29:
                        index += 1;
                        onProgress({
                            extracted: index,
                            total: entries.length,
                            currentFile: zipEntry(entry),
                            nextFile: index < entries.length ? zipEntry(entries[index]) : null
                        });

                    case 31:
                        context$2$0.next = 3;
                        break;

                    case 33:
                        return context$2$0.abrupt("return", true);

                    case 34:
                    case "end":
                        return context$2$0.stop();
                }
            }, null, this);
        },
        close: function close() {
            reader.close();
        }
    };
};

exports["default"] = {
    download: function download(url, onProgress) {
        var zipInfo;
        return _regeneratorRuntime.async(function download$(context$1$0) {
            while (1) switch (context$1$0.prev = context$1$0.next) {
                case 0:
                    context$1$0.next = 2;
                    return _regeneratorRuntime.awrap(_download(url, onProgress));

                case 2:
                    zipInfo = context$1$0.sent;
                    return context$1$0.abrupt("return", zipFile(zipInfo));

                case 4:
                case "end":
                    return context$1$0.stop();
            }
        }, null, this);
    }
};
module.exports = exports["default"];

},{"babel-runtime/core-js/get-iterator":47,"babel-runtime/core-js/object/define-properties":50,"babel-runtime/core-js/promise":55,"babel-runtime/helpers/interop-require-default":61,"babel-runtime/regenerator":149,"external/deflate.js.source":1,"external/inflate.js.source":2,"external/z-worker.js.source":3,"external/zip-ext.js":4,"external/zip.js":5}],46:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/array/from"), __esModule: true };
},{"core-js/library/fn/array/from":63}],47:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/get-iterator"), __esModule: true };
},{"core-js/library/fn/get-iterator":64}],48:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/assign"), __esModule: true };
},{"core-js/library/fn/object/assign":65}],49:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/create"), __esModule: true };
},{"core-js/library/fn/object/create":66}],50:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/define-properties"), __esModule: true };
},{"core-js/library/fn/object/define-properties":67}],51:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/entries"), __esModule: true };
},{"core-js/library/fn/object/entries":68}],52:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/freeze"), __esModule: true };
},{"core-js/library/fn/object/freeze":69}],53:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/keys"), __esModule: true };
},{"core-js/library/fn/object/keys":70}],54:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/set-prototype-of"), __esModule: true };
},{"core-js/library/fn/object/set-prototype-of":71}],55:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/promise"), __esModule: true };
},{"core-js/library/fn/promise":72}],56:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/set"), __esModule: true };
},{"core-js/library/fn/set":73}],57:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/symbol"), __esModule: true };
},{"core-js/library/fn/symbol":74}],58:[function(require,module,exports){
"use strict";

exports["default"] = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

exports.__esModule = true;
},{}],59:[function(require,module,exports){
"use strict";

var _Object$assign = require("babel-runtime/core-js/object/assign")["default"];

exports["default"] = _Object$assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

exports.__esModule = true;
},{"babel-runtime/core-js/object/assign":48}],60:[function(require,module,exports){
"use strict";

var _Object$create = require("babel-runtime/core-js/object/create")["default"];

var _Object$setPrototypeOf = require("babel-runtime/core-js/object/set-prototype-of")["default"];

exports["default"] = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = _Object$create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _Object$setPrototypeOf ? _Object$setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};

exports.__esModule = true;
},{"babel-runtime/core-js/object/create":49,"babel-runtime/core-js/object/set-prototype-of":54}],61:[function(require,module,exports){
"use strict";

exports["default"] = function (obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
};

exports.__esModule = true;
},{}],62:[function(require,module,exports){
"use strict";

exports["default"] = function (obj, keys) {
  var target = {};

  for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue;
    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
    target[i] = obj[i];
  }

  return target;
};

exports.__esModule = true;
},{}],63:[function(require,module,exports){
require('../../modules/es6.string.iterator');
require('../../modules/es6.array.from');
module.exports = require('../../modules/$.core').Array.from;
},{"../../modules/$.core":83,"../../modules/es6.array.from":135,"../../modules/es6.string.iterator":144}],64:[function(require,module,exports){
require('../modules/web.dom.iterable');
require('../modules/es6.string.iterator');
module.exports = require('../modules/core.get-iterator');
},{"../modules/core.get-iterator":134,"../modules/es6.string.iterator":144,"../modules/web.dom.iterable":148}],65:[function(require,module,exports){
require('../../modules/es6.object.assign');
module.exports = require('../../modules/$.core').Object.assign;
},{"../../modules/$.core":83,"../../modules/es6.object.assign":137}],66:[function(require,module,exports){
var $ = require('../../modules/$');
module.exports = function create(P, D){
  return $.create(P, D);
};
},{"../../modules/$":108}],67:[function(require,module,exports){
var $ = require('../../modules/$');
module.exports = function defineProperties(T, D){
  return $.setDescs(T, D);
};
},{"../../modules/$":108}],68:[function(require,module,exports){
require('../../modules/es7.object.entries');
module.exports = require('../../modules/$.core').Object.entries;
},{"../../modules/$.core":83,"../../modules/es7.object.entries":146}],69:[function(require,module,exports){
require('../../modules/es6.object.freeze');
module.exports = require('../../modules/$.core').Object.freeze;
},{"../../modules/$.core":83,"../../modules/es6.object.freeze":138}],70:[function(require,module,exports){
require('../../modules/es6.object.keys');
module.exports = require('../../modules/$.core').Object.keys;
},{"../../modules/$.core":83,"../../modules/es6.object.keys":139}],71:[function(require,module,exports){
require('../../modules/es6.object.set-prototype-of');
module.exports = require('../../modules/$.core').Object.setPrototypeOf;
},{"../../modules/$.core":83,"../../modules/es6.object.set-prototype-of":140}],72:[function(require,module,exports){
require('../modules/es6.object.to-string');
require('../modules/es6.string.iterator');
require('../modules/web.dom.iterable');
require('../modules/es6.promise');
module.exports = require('../modules/$.core').Promise;
},{"../modules/$.core":83,"../modules/es6.object.to-string":141,"../modules/es6.promise":142,"../modules/es6.string.iterator":144,"../modules/web.dom.iterable":148}],73:[function(require,module,exports){
require('../modules/es6.object.to-string');
require('../modules/es6.string.iterator');
require('../modules/web.dom.iterable');
require('../modules/es6.set');
require('../modules/es7.set.to-json');
module.exports = require('../modules/$.core').Set;
},{"../modules/$.core":83,"../modules/es6.object.to-string":141,"../modules/es6.set":143,"../modules/es6.string.iterator":144,"../modules/es7.set.to-json":147,"../modules/web.dom.iterable":148}],74:[function(require,module,exports){
require('../../modules/es6.symbol');
require('../../modules/es6.object.to-string');
module.exports = require('../../modules/$.core').Symbol;
},{"../../modules/$.core":83,"../../modules/es6.object.to-string":141,"../../modules/es6.symbol":145}],75:[function(require,module,exports){
module.exports = function(it){
  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
  return it;
};
},{}],76:[function(require,module,exports){
module.exports = function(){ /* empty */ };
},{}],77:[function(require,module,exports){
var isObject = require('./$.is-object');
module.exports = function(it){
  if(!isObject(it))throw TypeError(it + ' is not an object!');
  return it;
};
},{"./$.is-object":101}],78:[function(require,module,exports){
// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = require('./$.cof')
  , TAG = require('./$.wks')('toStringTag')
  // ES3 wrong here
  , ARG = cof(function(){ return arguments; }()) == 'Arguments';

module.exports = function(it){
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = (O = Object(it))[TAG]) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};
},{"./$.cof":79,"./$.wks":132}],79:[function(require,module,exports){
var toString = {}.toString;

module.exports = function(it){
  return toString.call(it).slice(8, -1);
};
},{}],80:[function(require,module,exports){
'use strict';
var $            = require('./$')
  , hide         = require('./$.hide')
  , redefineAll  = require('./$.redefine-all')
  , ctx          = require('./$.ctx')
  , strictNew    = require('./$.strict-new')
  , defined      = require('./$.defined')
  , forOf        = require('./$.for-of')
  , $iterDefine  = require('./$.iter-define')
  , step         = require('./$.iter-step')
  , ID           = require('./$.uid')('id')
  , $has         = require('./$.has')
  , isObject     = require('./$.is-object')
  , setSpecies   = require('./$.set-species')
  , DESCRIPTORS  = require('./$.descriptors')
  , isExtensible = Object.isExtensible || isObject
  , SIZE         = DESCRIPTORS ? '_s' : 'size'
  , id           = 0;

var fastKey = function(it, create){
  // return primitive with prefix
  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if(!$has(it, ID)){
    // can't set id to frozen object
    if(!isExtensible(it))return 'F';
    // not necessary to add id
    if(!create)return 'E';
    // add missing object id
    hide(it, ID, ++id);
  // return object id with prefix
  } return 'O' + it[ID];
};

var getEntry = function(that, key){
  // fast case
  var index = fastKey(key), entry;
  if(index !== 'F')return that._i[index];
  // frozen object case
  for(entry = that._f; entry; entry = entry.n){
    if(entry.k == key)return entry;
  }
};

module.exports = {
  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
    var C = wrapper(function(that, iterable){
      strictNew(that, C, NAME);
      that._i = $.create(null); // index
      that._f = undefined;      // first entry
      that._l = undefined;      // last entry
      that[SIZE] = 0;           // size
      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear(){
        for(var that = this, data = that._i, entry = that._f; entry; entry = entry.n){
          entry.r = true;
          if(entry.p)entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function(key){
        var that  = this
          , entry = getEntry(that, key);
        if(entry){
          var next = entry.n
            , prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if(prev)prev.n = next;
          if(next)next.p = prev;
          if(that._f == entry)that._f = next;
          if(that._l == entry)that._l = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /*, that = undefined */){
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3)
          , entry;
        while(entry = entry ? entry.n : this._f){
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while(entry && entry.r)entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key){
        return !!getEntry(this, key);
      }
    });
    if(DESCRIPTORS)$.setDesc(C.prototype, 'size', {
      get: function(){
        return defined(this[SIZE]);
      }
    });
    return C;
  },
  def: function(that, key, value){
    var entry = getEntry(that, key)
      , prev, index;
    // change existing entry
    if(entry){
      entry.v = value;
    // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that._l,             // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if(!that._f)that._f = entry;
      if(prev)prev.n = entry;
      that[SIZE]++;
      // add to index
      if(index !== 'F')that._i[index] = entry;
    } return that;
  },
  getEntry: getEntry,
  setStrong: function(C, NAME, IS_MAP){
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function(iterated, kind){
      this._t = iterated;  // target
      this._k = kind;      // kind
      this._l = undefined; // previous
    }, function(){
      var that  = this
        , kind  = that._k
        , entry = that._l;
      // revert to the last existing entry
      while(entry && entry.r)entry = entry.p;
      // get next entry
      if(!that._t || !(that._l = entry = entry ? entry.n : that._t._f)){
        // or finish the iteration
        that._t = undefined;
        return step(1);
      }
      // return step by kind
      if(kind == 'keys'  )return step(0, entry.k);
      if(kind == 'values')return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values' , !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(NAME);
  }
};
},{"./$":108,"./$.ctx":84,"./$.defined":85,"./$.descriptors":86,"./$.for-of":91,"./$.has":94,"./$.hide":95,"./$.is-object":101,"./$.iter-define":104,"./$.iter-step":106,"./$.redefine-all":116,"./$.set-species":120,"./$.strict-new":124,"./$.uid":131}],81:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var forOf   = require('./$.for-of')
  , classof = require('./$.classof');
module.exports = function(NAME){
  return function toJSON(){
    if(classof(this) != NAME)throw TypeError(NAME + "#toJSON isn't generic");
    var arr = [];
    forOf(this, false, arr.push, arr);
    return arr;
  };
};
},{"./$.classof":78,"./$.for-of":91}],82:[function(require,module,exports){
'use strict';
var $              = require('./$')
  , global         = require('./$.global')
  , $export        = require('./$.export')
  , fails          = require('./$.fails')
  , hide           = require('./$.hide')
  , redefineAll    = require('./$.redefine-all')
  , forOf          = require('./$.for-of')
  , strictNew      = require('./$.strict-new')
  , isObject       = require('./$.is-object')
  , setToStringTag = require('./$.set-to-string-tag')
  , DESCRIPTORS    = require('./$.descriptors');

module.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK){
  var Base  = global[NAME]
    , C     = Base
    , ADDER = IS_MAP ? 'set' : 'add'
    , proto = C && C.prototype
    , O     = {};
  if(!DESCRIPTORS || typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function(){
    new C().entries().next();
  }))){
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
  } else {
    C = wrapper(function(target, iterable){
      strictNew(target, C, NAME);
      target._c = new Base;
      if(iterable != undefined)forOf(iterable, IS_MAP, target[ADDER], target);
    });
    $.each.call('add,clear,delete,forEach,get,has,set,keys,values,entries'.split(','),function(KEY){
      var IS_ADDER = KEY == 'add' || KEY == 'set';
      if(KEY in proto && !(IS_WEAK && KEY == 'clear'))hide(C.prototype, KEY, function(a, b){
        if(!IS_ADDER && IS_WEAK && !isObject(a))return KEY == 'get' ? undefined : false;
        var result = this._c[KEY](a === 0 ? 0 : a, b);
        return IS_ADDER ? this : result;
      });
    });
    if('size' in proto)$.setDesc(C.prototype, 'size', {
      get: function(){
        return this._c.size;
      }
    });
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F, O);

  if(!IS_WEAK)common.setStrong(C, NAME, IS_MAP);

  return C;
};
},{"./$":108,"./$.descriptors":86,"./$.export":89,"./$.fails":90,"./$.for-of":91,"./$.global":93,"./$.hide":95,"./$.is-object":101,"./$.redefine-all":116,"./$.set-to-string-tag":121,"./$.strict-new":124}],83:[function(require,module,exports){
var core = module.exports = {version: '1.2.6'};
if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef
},{}],84:[function(require,module,exports){
// optional / simple context binding
var aFunction = require('./$.a-function');
module.exports = function(fn, that, length){
  aFunction(fn);
  if(that === undefined)return fn;
  switch(length){
    case 1: return function(a){
      return fn.call(that, a);
    };
    case 2: return function(a, b){
      return fn.call(that, a, b);
    };
    case 3: return function(a, b, c){
      return fn.call(that, a, b, c);
    };
  }
  return function(/* ...args */){
    return fn.apply(that, arguments);
  };
};
},{"./$.a-function":75}],85:[function(require,module,exports){
// 7.2.1 RequireObjectCoercible(argument)
module.exports = function(it){
  if(it == undefined)throw TypeError("Can't call method on  " + it);
  return it;
};
},{}],86:[function(require,module,exports){
// Thank's IE8 for his funny defineProperty
module.exports = !require('./$.fails')(function(){
  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
});
},{"./$.fails":90}],87:[function(require,module,exports){
var isObject = require('./$.is-object')
  , document = require('./$.global').document
  // in old IE typeof document.createElement is 'object'
  , is = isObject(document) && isObject(document.createElement);
module.exports = function(it){
  return is ? document.createElement(it) : {};
};
},{"./$.global":93,"./$.is-object":101}],88:[function(require,module,exports){
// all enumerable object keys, includes symbols
var $ = require('./$');
module.exports = function(it){
  var keys       = $.getKeys(it)
    , getSymbols = $.getSymbols;
  if(getSymbols){
    var symbols = getSymbols(it)
      , isEnum  = $.isEnum
      , i       = 0
      , key;
    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))keys.push(key);
  }
  return keys;
};
},{"./$":108}],89:[function(require,module,exports){
var global    = require('./$.global')
  , core      = require('./$.core')
  , ctx       = require('./$.ctx')
  , PROTOTYPE = 'prototype';

var $export = function(type, name, source){
  var IS_FORCED = type & $export.F
    , IS_GLOBAL = type & $export.G
    , IS_STATIC = type & $export.S
    , IS_PROTO  = type & $export.P
    , IS_BIND   = type & $export.B
    , IS_WRAP   = type & $export.W
    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]
    , key, own, out;
  if(IS_GLOBAL)source = name;
  for(key in source){
    // contains in native
    own = !IS_FORCED && target && key in target;
    if(own && key in exports)continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function(C){
      var F = function(param){
        return this instanceof C ? new C(param) : C(param);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    if(IS_PROTO)(exports[PROTOTYPE] || (exports[PROTOTYPE] = {}))[key] = out;
  }
};
// type bitmap
$export.F = 1;  // forced
$export.G = 2;  // global
$export.S = 4;  // static
$export.P = 8;  // proto
$export.B = 16; // bind
$export.W = 32; // wrap
module.exports = $export;
},{"./$.core":83,"./$.ctx":84,"./$.global":93}],90:[function(require,module,exports){
module.exports = function(exec){
  try {
    return !!exec();
  } catch(e){
    return true;
  }
};
},{}],91:[function(require,module,exports){
var ctx         = require('./$.ctx')
  , call        = require('./$.iter-call')
  , isArrayIter = require('./$.is-array-iter')
  , anObject    = require('./$.an-object')
  , toLength    = require('./$.to-length')
  , getIterFn   = require('./core.get-iterator-method');
module.exports = function(iterable, entries, fn, that){
  var iterFn = getIterFn(iterable)
    , f      = ctx(fn, that, entries ? 2 : 1)
    , index  = 0
    , length, step, iterator;
  if(typeof iterFn != 'function')throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if(isArrayIter(iterFn))for(length = toLength(iterable.length); length > index; index++){
    entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
  } else for(iterator = iterFn.call(iterable); !(step = iterator.next()).done; ){
    call(iterator, f, step.value, entries);
  }
};
},{"./$.an-object":77,"./$.ctx":84,"./$.is-array-iter":99,"./$.iter-call":102,"./$.to-length":129,"./core.get-iterator-method":133}],92:[function(require,module,exports){
// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = require('./$.to-iobject')
  , getNames  = require('./$').getNames
  , toString  = {}.toString;

var windowNames = typeof window == 'object' && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function(it){
  try {
    return getNames(it);
  } catch(e){
    return windowNames.slice();
  }
};

module.exports.get = function getOwnPropertyNames(it){
  if(windowNames && toString.call(it) == '[object Window]')return getWindowNames(it);
  return getNames(toIObject(it));
};
},{"./$":108,"./$.to-iobject":128}],93:[function(require,module,exports){
// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef
},{}],94:[function(require,module,exports){
var hasOwnProperty = {}.hasOwnProperty;
module.exports = function(it, key){
  return hasOwnProperty.call(it, key);
};
},{}],95:[function(require,module,exports){
var $          = require('./$')
  , createDesc = require('./$.property-desc');
module.exports = require('./$.descriptors') ? function(object, key, value){
  return $.setDesc(object, key, createDesc(1, value));
} : function(object, key, value){
  object[key] = value;
  return object;
};
},{"./$":108,"./$.descriptors":86,"./$.property-desc":115}],96:[function(require,module,exports){
module.exports = require('./$.global').document && document.documentElement;
},{"./$.global":93}],97:[function(require,module,exports){
// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function(fn, args, that){
  var un = that === undefined;
  switch(args.length){
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return              fn.apply(that, args);
};
},{}],98:[function(require,module,exports){
// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = require('./$.cof');
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
  return cof(it) == 'String' ? it.split('') : Object(it);
};
},{"./$.cof":79}],99:[function(require,module,exports){
// check on default Array iterator
var Iterators  = require('./$.iterators')
  , ITERATOR   = require('./$.wks')('iterator')
  , ArrayProto = Array.prototype;

module.exports = function(it){
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};
},{"./$.iterators":107,"./$.wks":132}],100:[function(require,module,exports){
// 7.2.2 IsArray(argument)
var cof = require('./$.cof');
module.exports = Array.isArray || function(arg){
  return cof(arg) == 'Array';
};
},{"./$.cof":79}],101:[function(require,module,exports){
module.exports = function(it){
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};
},{}],102:[function(require,module,exports){
// call something on iterator step with safe closing on error
var anObject = require('./$.an-object');
module.exports = function(iterator, fn, value, entries){
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch(e){
    var ret = iterator['return'];
    if(ret !== undefined)anObject(ret.call(iterator));
    throw e;
  }
};
},{"./$.an-object":77}],103:[function(require,module,exports){
'use strict';
var $              = require('./$')
  , descriptor     = require('./$.property-desc')
  , setToStringTag = require('./$.set-to-string-tag')
  , IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
require('./$.hide')(IteratorPrototype, require('./$.wks')('iterator'), function(){ return this; });

module.exports = function(Constructor, NAME, next){
  Constructor.prototype = $.create(IteratorPrototype, {next: descriptor(1, next)});
  setToStringTag(Constructor, NAME + ' Iterator');
};
},{"./$":108,"./$.hide":95,"./$.property-desc":115,"./$.set-to-string-tag":121,"./$.wks":132}],104:[function(require,module,exports){
'use strict';
var LIBRARY        = require('./$.library')
  , $export        = require('./$.export')
  , redefine       = require('./$.redefine')
  , hide           = require('./$.hide')
  , has            = require('./$.has')
  , Iterators      = require('./$.iterators')
  , $iterCreate    = require('./$.iter-create')
  , setToStringTag = require('./$.set-to-string-tag')
  , getProto       = require('./$').getProto
  , ITERATOR       = require('./$.wks')('iterator')
  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
  , FF_ITERATOR    = '@@iterator'
  , KEYS           = 'keys'
  , VALUES         = 'values';

var returnThis = function(){ return this; };

module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){
  $iterCreate(Constructor, NAME, next);
  var getMethod = function(kind){
    if(!BUGGY && kind in proto)return proto[kind];
    switch(kind){
      case KEYS: return function keys(){ return new Constructor(this, kind); };
      case VALUES: return function values(){ return new Constructor(this, kind); };
    } return function entries(){ return new Constructor(this, kind); };
  };
  var TAG        = NAME + ' Iterator'
    , DEF_VALUES = DEFAULT == VALUES
    , VALUES_BUG = false
    , proto      = Base.prototype
    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
    , $default   = $native || getMethod(DEFAULT)
    , methods, key;
  // Fix native
  if($native){
    var IteratorPrototype = getProto($default.call(new Base));
    // Set @@toStringTag to native iterators
    setToStringTag(IteratorPrototype, TAG, true);
    // FF fix
    if(!LIBRARY && has(proto, FF_ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);
    // fix Array#{values, @@iterator}.name in V8 / FF
    if(DEF_VALUES && $native.name !== VALUES){
      VALUES_BUG = true;
      $default = function values(){ return $native.call(this); };
    }
  }
  // Define iterator
  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG]  = returnThis;
  if(DEFAULT){
    methods = {
      values:  DEF_VALUES  ? $default : getMethod(VALUES),
      keys:    IS_SET      ? $default : getMethod(KEYS),
      entries: !DEF_VALUES ? $default : getMethod('entries')
    };
    if(FORCED)for(key in methods){
      if(!(key in proto))redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};
},{"./$":108,"./$.export":89,"./$.has":94,"./$.hide":95,"./$.iter-create":103,"./$.iterators":107,"./$.library":110,"./$.redefine":117,"./$.set-to-string-tag":121,"./$.wks":132}],105:[function(require,module,exports){
var ITERATOR     = require('./$.wks')('iterator')
  , SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function(){ SAFE_CLOSING = true; };
  Array.from(riter, function(){ throw 2; });
} catch(e){ /* empty */ }

module.exports = function(exec, skipClosing){
  if(!skipClosing && !SAFE_CLOSING)return false;
  var safe = false;
  try {
    var arr  = [7]
      , iter = arr[ITERATOR]();
    iter.next = function(){ safe = true; };
    arr[ITERATOR] = function(){ return iter; };
    exec(arr);
  } catch(e){ /* empty */ }
  return safe;
};
},{"./$.wks":132}],106:[function(require,module,exports){
module.exports = function(done, value){
  return {value: value, done: !!done};
};
},{}],107:[function(require,module,exports){
module.exports = {};
},{}],108:[function(require,module,exports){
var $Object = Object;
module.exports = {
  create:     $Object.create,
  getProto:   $Object.getPrototypeOf,
  isEnum:     {}.propertyIsEnumerable,
  getDesc:    $Object.getOwnPropertyDescriptor,
  setDesc:    $Object.defineProperty,
  setDescs:   $Object.defineProperties,
  getKeys:    $Object.keys,
  getNames:   $Object.getOwnPropertyNames,
  getSymbols: $Object.getOwnPropertySymbols,
  each:       [].forEach
};
},{}],109:[function(require,module,exports){
var $         = require('./$')
  , toIObject = require('./$.to-iobject');
module.exports = function(object, el){
  var O      = toIObject(object)
    , keys   = $.getKeys(O)
    , length = keys.length
    , index  = 0
    , key;
  while(length > index)if(O[key = keys[index++]] === el)return key;
};
},{"./$":108,"./$.to-iobject":128}],110:[function(require,module,exports){
module.exports = true;
},{}],111:[function(require,module,exports){
var global    = require('./$.global')
  , macrotask = require('./$.task').set
  , Observer  = global.MutationObserver || global.WebKitMutationObserver
  , process   = global.process
  , Promise   = global.Promise
  , isNode    = require('./$.cof')(process) == 'process'
  , head, last, notify;

var flush = function(){
  var parent, domain, fn;
  if(isNode && (parent = process.domain)){
    process.domain = null;
    parent.exit();
  }
  while(head){
    domain = head.domain;
    fn     = head.fn;
    if(domain)domain.enter();
    fn(); // <- currently we use it only for Promise - try / catch not required
    if(domain)domain.exit();
    head = head.next;
  } last = undefined;
  if(parent)parent.enter();
};

// Node.js
if(isNode){
  notify = function(){
    process.nextTick(flush);
  };
// browsers with MutationObserver
} else if(Observer){
  var toggle = 1
    , node   = document.createTextNode('');
  new Observer(flush).observe(node, {characterData: true}); // eslint-disable-line no-new
  notify = function(){
    node.data = toggle = -toggle;
  };
// environments with maybe non-completely correct, but existent Promise
} else if(Promise && Promise.resolve){
  notify = function(){
    Promise.resolve().then(flush);
  };
// for other environments - macrotask based on:
// - setImmediate
// - MessageChannel
// - window.postMessag
// - onreadystatechange
// - setTimeout
} else {
  notify = function(){
    // strange IE + webpack dev server bug - use .call(global)
    macrotask.call(global, flush);
  };
}

module.exports = function asap(fn){
  var task = {fn: fn, next: undefined, domain: isNode && process.domain};
  if(last)last.next = task;
  if(!head){
    head = task;
    notify();
  } last = task;
};
},{"./$.cof":79,"./$.global":93,"./$.task":126}],112:[function(require,module,exports){
// 19.1.2.1 Object.assign(target, source, ...)
var $        = require('./$')
  , toObject = require('./$.to-object')
  , IObject  = require('./$.iobject');

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = require('./$.fails')(function(){
  var a = Object.assign
    , A = {}
    , B = {}
    , S = Symbol()
    , K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function(k){ B[k] = k; });
  return a({}, A)[S] != 7 || Object.keys(a({}, B)).join('') != K;
}) ? function assign(target, source){ // eslint-disable-line no-unused-vars
  var T     = toObject(target)
    , $$    = arguments
    , $$len = $$.length
    , index = 1
    , getKeys    = $.getKeys
    , getSymbols = $.getSymbols
    , isEnum     = $.isEnum;
  while($$len > index){
    var S      = IObject($$[index++])
      , keys   = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)
      , length = keys.length
      , j      = 0
      , key;
    while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];
  }
  return T;
} : Object.assign;
},{"./$":108,"./$.fails":90,"./$.iobject":98,"./$.to-object":130}],113:[function(require,module,exports){
// most Object methods by ES6 should accept primitives
var $export = require('./$.export')
  , core    = require('./$.core')
  , fails   = require('./$.fails');
module.exports = function(KEY, exec){
  var fn  = (core.Object || {})[KEY] || Object[KEY]
    , exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);
};
},{"./$.core":83,"./$.export":89,"./$.fails":90}],114:[function(require,module,exports){
var $         = require('./$')
  , toIObject = require('./$.to-iobject')
  , isEnum    = $.isEnum;
module.exports = function(isEntries){
  return function(it){
    var O      = toIObject(it)
      , keys   = $.getKeys(O)
      , length = keys.length
      , i      = 0
      , result = []
      , key;
    while(length > i)if(isEnum.call(O, key = keys[i++])){
      result.push(isEntries ? [key, O[key]] : O[key]);
    } return result;
  };
};
},{"./$":108,"./$.to-iobject":128}],115:[function(require,module,exports){
module.exports = function(bitmap, value){
  return {
    enumerable  : !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable    : !(bitmap & 4),
    value       : value
  };
};
},{}],116:[function(require,module,exports){
var redefine = require('./$.redefine');
module.exports = function(target, src){
  for(var key in src)redefine(target, key, src[key]);
  return target;
};
},{"./$.redefine":117}],117:[function(require,module,exports){
module.exports = require('./$.hide');
},{"./$.hide":95}],118:[function(require,module,exports){
// 7.2.9 SameValue(x, y)
module.exports = Object.is || function is(x, y){
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};
},{}],119:[function(require,module,exports){
// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var getDesc  = require('./$').getDesc
  , isObject = require('./$.is-object')
  , anObject = require('./$.an-object');
var check = function(O, proto){
  anObject(O);
  if(!isObject(proto) && proto !== null)throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function(test, buggy, set){
      try {
        set = require('./$.ctx')(Function.call, getDesc(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch(e){ buggy = true; }
      return function setPrototypeOf(O, proto){
        check(O, proto);
        if(buggy)O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};
},{"./$":108,"./$.an-object":77,"./$.ctx":84,"./$.is-object":101}],120:[function(require,module,exports){
'use strict';
var core        = require('./$.core')
  , $           = require('./$')
  , DESCRIPTORS = require('./$.descriptors')
  , SPECIES     = require('./$.wks')('species');

module.exports = function(KEY){
  var C = core[KEY];
  if(DESCRIPTORS && C && !C[SPECIES])$.setDesc(C, SPECIES, {
    configurable: true,
    get: function(){ return this; }
  });
};
},{"./$":108,"./$.core":83,"./$.descriptors":86,"./$.wks":132}],121:[function(require,module,exports){
var def = require('./$').setDesc
  , has = require('./$.has')
  , TAG = require('./$.wks')('toStringTag');

module.exports = function(it, tag, stat){
  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});
};
},{"./$":108,"./$.has":94,"./$.wks":132}],122:[function(require,module,exports){
var global = require('./$.global')
  , SHARED = '__core-js_shared__'
  , store  = global[SHARED] || (global[SHARED] = {});
module.exports = function(key){
  return store[key] || (store[key] = {});
};
},{"./$.global":93}],123:[function(require,module,exports){
// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject  = require('./$.an-object')
  , aFunction = require('./$.a-function')
  , SPECIES   = require('./$.wks')('species');
module.exports = function(O, D){
  var C = anObject(O).constructor, S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};
},{"./$.a-function":75,"./$.an-object":77,"./$.wks":132}],124:[function(require,module,exports){
module.exports = function(it, Constructor, name){
  if(!(it instanceof Constructor))throw TypeError(name + ": use the 'new' operator!");
  return it;
};
},{}],125:[function(require,module,exports){
var toInteger = require('./$.to-integer')
  , defined   = require('./$.defined');
// true  -> String#at
// false -> String#codePointAt
module.exports = function(TO_STRING){
  return function(that, pos){
    var s = String(defined(that))
      , i = toInteger(pos)
      , l = s.length
      , a, b;
    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};
},{"./$.defined":85,"./$.to-integer":127}],126:[function(require,module,exports){
var ctx                = require('./$.ctx')
  , invoke             = require('./$.invoke')
  , html               = require('./$.html')
  , cel                = require('./$.dom-create')
  , global             = require('./$.global')
  , process            = global.process
  , setTask            = global.setImmediate
  , clearTask          = global.clearImmediate
  , MessageChannel     = global.MessageChannel
  , counter            = 0
  , queue              = {}
  , ONREADYSTATECHANGE = 'onreadystatechange'
  , defer, channel, port;
var run = function(){
  var id = +this;
  if(queue.hasOwnProperty(id)){
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listner = function(event){
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if(!setTask || !clearTask){
  setTask = function setImmediate(fn){
    var args = [], i = 1;
    while(arguments.length > i)args.push(arguments[i++]);
    queue[++counter] = function(){
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id){
    delete queue[id];
  };
  // Node.js 0.8-
  if(require('./$.cof')(process) == 'process'){
    defer = function(id){
      process.nextTick(ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if(MessageChannel){
    channel = new MessageChannel;
    port    = channel.port2;
    channel.port1.onmessage = listner;
    defer = ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if(global.addEventListener && typeof postMessage == 'function' && !global.importScripts){
    defer = function(id){
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listner, false);
  // IE8-
  } else if(ONREADYSTATECHANGE in cel('script')){
    defer = function(id){
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function(){
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function(id){
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set:   setTask,
  clear: clearTask
};
},{"./$.cof":79,"./$.ctx":84,"./$.dom-create":87,"./$.global":93,"./$.html":96,"./$.invoke":97}],127:[function(require,module,exports){
// 7.1.4 ToInteger
var ceil  = Math.ceil
  , floor = Math.floor;
module.exports = function(it){
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};
},{}],128:[function(require,module,exports){
// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = require('./$.iobject')
  , defined = require('./$.defined');
module.exports = function(it){
  return IObject(defined(it));
};
},{"./$.defined":85,"./$.iobject":98}],129:[function(require,module,exports){
// 7.1.15 ToLength
var toInteger = require('./$.to-integer')
  , min       = Math.min;
module.exports = function(it){
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};
},{"./$.to-integer":127}],130:[function(require,module,exports){
// 7.1.13 ToObject(argument)
var defined = require('./$.defined');
module.exports = function(it){
  return Object(defined(it));
};
},{"./$.defined":85}],131:[function(require,module,exports){
var id = 0
  , px = Math.random();
module.exports = function(key){
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};
},{}],132:[function(require,module,exports){
var store  = require('./$.shared')('wks')
  , uid    = require('./$.uid')
  , Symbol = require('./$.global').Symbol;
module.exports = function(name){
  return store[name] || (store[name] =
    Symbol && Symbol[name] || (Symbol || uid)('Symbol.' + name));
};
},{"./$.global":93,"./$.shared":122,"./$.uid":131}],133:[function(require,module,exports){
var classof   = require('./$.classof')
  , ITERATOR  = require('./$.wks')('iterator')
  , Iterators = require('./$.iterators');
module.exports = require('./$.core').getIteratorMethod = function(it){
  if(it != undefined)return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};
},{"./$.classof":78,"./$.core":83,"./$.iterators":107,"./$.wks":132}],134:[function(require,module,exports){
var anObject = require('./$.an-object')
  , get      = require('./core.get-iterator-method');
module.exports = require('./$.core').getIterator = function(it){
  var iterFn = get(it);
  if(typeof iterFn != 'function')throw TypeError(it + ' is not iterable!');
  return anObject(iterFn.call(it));
};
},{"./$.an-object":77,"./$.core":83,"./core.get-iterator-method":133}],135:[function(require,module,exports){
'use strict';
var ctx         = require('./$.ctx')
  , $export     = require('./$.export')
  , toObject    = require('./$.to-object')
  , call        = require('./$.iter-call')
  , isArrayIter = require('./$.is-array-iter')
  , toLength    = require('./$.to-length')
  , getIterFn   = require('./core.get-iterator-method');
$export($export.S + $export.F * !require('./$.iter-detect')(function(iter){ Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike/*, mapfn = undefined, thisArg = undefined*/){
    var O       = toObject(arrayLike)
      , C       = typeof this == 'function' ? this : Array
      , $$      = arguments
      , $$len   = $$.length
      , mapfn   = $$len > 1 ? $$[1] : undefined
      , mapping = mapfn !== undefined
      , index   = 0
      , iterFn  = getIterFn(O)
      , length, result, step, iterator;
    if(mapping)mapfn = ctx(mapfn, $$len > 2 ? $$[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if(iterFn != undefined && !(C == Array && isArrayIter(iterFn))){
      for(iterator = iterFn.call(O), result = new C; !(step = iterator.next()).done; index++){
        result[index] = mapping ? call(iterator, mapfn, [step.value, index], true) : step.value;
      }
    } else {
      length = toLength(O.length);
      for(result = new C(length); length > index; index++){
        result[index] = mapping ? mapfn(O[index], index) : O[index];
      }
    }
    result.length = index;
    return result;
  }
});

},{"./$.ctx":84,"./$.export":89,"./$.is-array-iter":99,"./$.iter-call":102,"./$.iter-detect":105,"./$.to-length":129,"./$.to-object":130,"./core.get-iterator-method":133}],136:[function(require,module,exports){
'use strict';
var addToUnscopables = require('./$.add-to-unscopables')
  , step             = require('./$.iter-step')
  , Iterators        = require('./$.iterators')
  , toIObject        = require('./$.to-iobject');

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = require('./$.iter-define')(Array, 'Array', function(iterated, kind){
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function(){
  var O     = this._t
    , kind  = this._k
    , index = this._i++;
  if(!O || index >= O.length){
    this._t = undefined;
    return step(1);
  }
  if(kind == 'keys'  )return step(0, index);
  if(kind == 'values')return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');
},{"./$.add-to-unscopables":76,"./$.iter-define":104,"./$.iter-step":106,"./$.iterators":107,"./$.to-iobject":128}],137:[function(require,module,exports){
// 19.1.3.1 Object.assign(target, source)
var $export = require('./$.export');

$export($export.S + $export.F, 'Object', {assign: require('./$.object-assign')});
},{"./$.export":89,"./$.object-assign":112}],138:[function(require,module,exports){
// 19.1.2.5 Object.freeze(O)
var isObject = require('./$.is-object');

require('./$.object-sap')('freeze', function($freeze){
  return function freeze(it){
    return $freeze && isObject(it) ? $freeze(it) : it;
  };
});
},{"./$.is-object":101,"./$.object-sap":113}],139:[function(require,module,exports){
// 19.1.2.14 Object.keys(O)
var toObject = require('./$.to-object');

require('./$.object-sap')('keys', function($keys){
  return function keys(it){
    return $keys(toObject(it));
  };
});
},{"./$.object-sap":113,"./$.to-object":130}],140:[function(require,module,exports){
// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = require('./$.export');
$export($export.S, 'Object', {setPrototypeOf: require('./$.set-proto').set});
},{"./$.export":89,"./$.set-proto":119}],141:[function(require,module,exports){

},{}],142:[function(require,module,exports){
'use strict';
var $          = require('./$')
  , LIBRARY    = require('./$.library')
  , global     = require('./$.global')
  , ctx        = require('./$.ctx')
  , classof    = require('./$.classof')
  , $export    = require('./$.export')
  , isObject   = require('./$.is-object')
  , anObject   = require('./$.an-object')
  , aFunction  = require('./$.a-function')
  , strictNew  = require('./$.strict-new')
  , forOf      = require('./$.for-of')
  , setProto   = require('./$.set-proto').set
  , same       = require('./$.same-value')
  , SPECIES    = require('./$.wks')('species')
  , speciesConstructor = require('./$.species-constructor')
  , asap       = require('./$.microtask')
  , PROMISE    = 'Promise'
  , process    = global.process
  , isNode     = classof(process) == 'process'
  , P          = global[PROMISE]
  , Wrapper;

var testResolve = function(sub){
  var test = new P(function(){});
  if(sub)test.constructor = Object;
  return P.resolve(test) === test;
};

var USE_NATIVE = function(){
  var works = false;
  function P2(x){
    var self = new P(x);
    setProto(self, P2.prototype);
    return self;
  }
  try {
    works = P && P.resolve && testResolve();
    setProto(P2, P);
    P2.prototype = $.create(P.prototype, {constructor: {value: P2}});
    // actual Firefox has broken subclass support, test that
    if(!(P2.resolve(5).then(function(){}) instanceof P2)){
      works = false;
    }
    // actual V8 bug, https://code.google.com/p/v8/issues/detail?id=4162
    if(works && require('./$.descriptors')){
      var thenableThenGotten = false;
      P.resolve($.setDesc({}, 'then', {
        get: function(){ thenableThenGotten = true; }
      }));
      works = thenableThenGotten;
    }
  } catch(e){ works = false; }
  return works;
}();

// helpers
var sameConstructor = function(a, b){
  // library wrapper special case
  if(LIBRARY && a === P && b === Wrapper)return true;
  return same(a, b);
};
var getConstructor = function(C){
  var S = anObject(C)[SPECIES];
  return S != undefined ? S : C;
};
var isThenable = function(it){
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var PromiseCapability = function(C){
  var resolve, reject;
  this.promise = new C(function($$resolve, $$reject){
    if(resolve !== undefined || reject !== undefined)throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject  = $$reject;
  });
  this.resolve = aFunction(resolve),
  this.reject  = aFunction(reject)
};
var perform = function(exec){
  try {
    exec();
  } catch(e){
    return {error: e};
  }
};
var notify = function(record, isReject){
  if(record.n)return;
  record.n = true;
  var chain = record.c;
  asap(function(){
    var value = record.v
      , ok    = record.s == 1
      , i     = 0;
    var run = function(reaction){
      var handler = ok ? reaction.ok : reaction.fail
        , resolve = reaction.resolve
        , reject  = reaction.reject
        , result, then;
      try {
        if(handler){
          if(!ok)record.h = true;
          result = handler === true ? value : handler(value);
          if(result === reaction.promise){
            reject(TypeError('Promise-chain cycle'));
          } else if(then = isThenable(result)){
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch(e){
        reject(e);
      }
    };
    while(chain.length > i)run(chain[i++]); // variable length - can't use forEach
    chain.length = 0;
    record.n = false;
    if(isReject)setTimeout(function(){
      var promise = record.p
        , handler, console;
      if(isUnhandled(promise)){
        if(isNode){
          process.emit('unhandledRejection', value, promise);
        } else if(handler = global.onunhandledrejection){
          handler({promise: promise, reason: value});
        } else if((console = global.console) && console.error){
          console.error('Unhandled promise rejection', value);
        }
      } record.a = undefined;
    }, 1);
  });
};
var isUnhandled = function(promise){
  var record = promise._d
    , chain  = record.a || record.c
    , i      = 0
    , reaction;
  if(record.h)return false;
  while(chain.length > i){
    reaction = chain[i++];
    if(reaction.fail || !isUnhandled(reaction.promise))return false;
  } return true;
};
var $reject = function(value){
  var record = this;
  if(record.d)return;
  record.d = true;
  record = record.r || record; // unwrap
  record.v = value;
  record.s = 2;
  record.a = record.c.slice();
  notify(record, true);
};
var $resolve = function(value){
  var record = this
    , then;
  if(record.d)return;
  record.d = true;
  record = record.r || record; // unwrap
  try {
    if(record.p === value)throw TypeError("Promise can't be resolved itself");
    if(then = isThenable(value)){
      asap(function(){
        var wrapper = {r: record, d: false}; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch(e){
          $reject.call(wrapper, e);
        }
      });
    } else {
      record.v = value;
      record.s = 1;
      notify(record, false);
    }
  } catch(e){
    $reject.call({r: record, d: false}, e); // wrap
  }
};

// constructor polyfill
if(!USE_NATIVE){
  // 25.4.3.1 Promise(executor)
  P = function Promise(executor){
    aFunction(executor);
    var record = this._d = {
      p: strictNew(this, P, PROMISE),         // <- promise
      c: [],                                  // <- awaiting reactions
      a: undefined,                           // <- checked in isUnhandled reactions
      s: 0,                                   // <- state
      d: false,                               // <- done
      v: undefined,                           // <- value
      h: false,                               // <- handled rejection
      n: false                                // <- notify
    };
    try {
      executor(ctx($resolve, record, 1), ctx($reject, record, 1));
    } catch(err){
      $reject.call(record, err);
    }
  };
  require('./$.redefine-all')(P.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected){
      var reaction = new PromiseCapability(speciesConstructor(this, P))
        , promise  = reaction.promise
        , record   = this._d;
      reaction.ok   = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      record.c.push(reaction);
      if(record.a)record.a.push(reaction);
      if(record.s)notify(record, false);
      return promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function(onRejected){
      return this.then(undefined, onRejected);
    }
  });
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, {Promise: P});
require('./$.set-to-string-tag')(P, PROMISE);
require('./$.set-species')(PROMISE);
Wrapper = require('./$.core')[PROMISE];

// statics
$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r){
    var capability = new PromiseCapability(this)
      , $$reject   = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (!USE_NATIVE || testResolve(true)), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x){
    // instanceof instead of internal slot check because we should fix it without replacement native Promise core
    if(x instanceof P && sameConstructor(x.constructor, this))return x;
    var capability = new PromiseCapability(this)
      , $$resolve  = capability.resolve;
    $$resolve(x);
    return capability.promise;
  }
});
$export($export.S + $export.F * !(USE_NATIVE && require('./$.iter-detect')(function(iter){
  P.all(iter)['catch'](function(){});
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable){
    var C          = getConstructor(this)
      , capability = new PromiseCapability(C)
      , resolve    = capability.resolve
      , reject     = capability.reject
      , values     = [];
    var abrupt = perform(function(){
      forOf(iterable, false, values.push, values);
      var remaining = values.length
        , results   = Array(remaining);
      if(remaining)$.each.call(values, function(promise, index){
        var alreadyCalled = false;
        C.resolve(promise).then(function(value){
          if(alreadyCalled)return;
          alreadyCalled = true;
          results[index] = value;
          --remaining || resolve(results);
        }, reject);
      });
      else resolve(results);
    });
    if(abrupt)reject(abrupt.error);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable){
    var C          = getConstructor(this)
      , capability = new PromiseCapability(C)
      , reject     = capability.reject;
    var abrupt = perform(function(){
      forOf(iterable, false, function(promise){
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if(abrupt)reject(abrupt.error);
    return capability.promise;
  }
});
},{"./$":108,"./$.a-function":75,"./$.an-object":77,"./$.classof":78,"./$.core":83,"./$.ctx":84,"./$.descriptors":86,"./$.export":89,"./$.for-of":91,"./$.global":93,"./$.is-object":101,"./$.iter-detect":105,"./$.library":110,"./$.microtask":111,"./$.redefine-all":116,"./$.same-value":118,"./$.set-proto":119,"./$.set-species":120,"./$.set-to-string-tag":121,"./$.species-constructor":123,"./$.strict-new":124,"./$.wks":132}],143:[function(require,module,exports){
'use strict';
var strong = require('./$.collection-strong');

// 23.2 Set Objects
require('./$.collection')('Set', function(get){
  return function Set(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value){
    return strong.def(this, value = value === 0 ? 0 : value, value);
  }
}, strong);
},{"./$.collection":82,"./$.collection-strong":80}],144:[function(require,module,exports){
'use strict';
var $at  = require('./$.string-at')(true);

// 21.1.3.27 String.prototype[@@iterator]()
require('./$.iter-define')(String, 'String', function(iterated){
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function(){
  var O     = this._t
    , index = this._i
    , point;
  if(index >= O.length)return {value: undefined, done: true};
  point = $at(O, index);
  this._i += point.length;
  return {value: point, done: false};
});
},{"./$.iter-define":104,"./$.string-at":125}],145:[function(require,module,exports){
'use strict';
// ECMAScript 6 symbols shim
var $              = require('./$')
  , global         = require('./$.global')
  , has            = require('./$.has')
  , DESCRIPTORS    = require('./$.descriptors')
  , $export        = require('./$.export')
  , redefine       = require('./$.redefine')
  , $fails         = require('./$.fails')
  , shared         = require('./$.shared')
  , setToStringTag = require('./$.set-to-string-tag')
  , uid            = require('./$.uid')
  , wks            = require('./$.wks')
  , keyOf          = require('./$.keyof')
  , $names         = require('./$.get-names')
  , enumKeys       = require('./$.enum-keys')
  , isArray        = require('./$.is-array')
  , anObject       = require('./$.an-object')
  , toIObject      = require('./$.to-iobject')
  , createDesc     = require('./$.property-desc')
  , getDesc        = $.getDesc
  , setDesc        = $.setDesc
  , _create        = $.create
  , getNames       = $names.get
  , $Symbol        = global.Symbol
  , $JSON          = global.JSON
  , _stringify     = $JSON && $JSON.stringify
  , setter         = false
  , HIDDEN         = wks('_hidden')
  , isEnum         = $.isEnum
  , SymbolRegistry = shared('symbol-registry')
  , AllSymbols     = shared('symbols')
  , useNative      = typeof $Symbol == 'function'
  , ObjectProto    = Object.prototype;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function(){
  return _create(setDesc({}, 'a', {
    get: function(){ return setDesc(this, 'a', {value: 7}).a; }
  })).a != 7;
}) ? function(it, key, D){
  var protoDesc = getDesc(ObjectProto, key);
  if(protoDesc)delete ObjectProto[key];
  setDesc(it, key, D);
  if(protoDesc && it !== ObjectProto)setDesc(ObjectProto, key, protoDesc);
} : setDesc;

var wrap = function(tag){
  var sym = AllSymbols[tag] = _create($Symbol.prototype);
  sym._k = tag;
  DESCRIPTORS && setter && setSymbolDesc(ObjectProto, tag, {
    configurable: true,
    set: function(value){
      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    }
  });
  return sym;
};

var isSymbol = function(it){
  return typeof it == 'symbol';
};

var $defineProperty = function defineProperty(it, key, D){
  if(D && has(AllSymbols, key)){
    if(!D.enumerable){
      if(!has(it, HIDDEN))setDesc(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
      D = _create(D, {enumerable: createDesc(0, false)});
    } return setSymbolDesc(it, key, D);
  } return setDesc(it, key, D);
};
var $defineProperties = function defineProperties(it, P){
  anObject(it);
  var keys = enumKeys(P = toIObject(P))
    , i    = 0
    , l = keys.length
    , key;
  while(l > i)$defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P){
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key){
  var E = isEnum.call(this, key);
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key]
    ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){
  var D = getDesc(it = toIObject(it), key);
  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it){
  var names  = getNames(toIObject(it))
    , result = []
    , i      = 0
    , key;
  while(names.length > i)if(!has(AllSymbols, key = names[i++]) && key != HIDDEN)result.push(key);
  return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it){
  var names  = getNames(toIObject(it))
    , result = []
    , i      = 0
    , key;
  while(names.length > i)if(has(AllSymbols, key = names[i++]))result.push(AllSymbols[key]);
  return result;
};
var $stringify = function stringify(it){
  if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined
  var args = [it]
    , i    = 1
    , $$   = arguments
    , replacer, $replacer;
  while($$.length > i)args.push($$[i++]);
  replacer = args[1];
  if(typeof replacer == 'function')$replacer = replacer;
  if($replacer || !isArray(replacer))replacer = function(key, value){
    if($replacer)value = $replacer.call(this, key, value);
    if(!isSymbol(value))return value;
  };
  args[1] = replacer;
  return _stringify.apply($JSON, args);
};
var buggyJSON = $fails(function(){
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
});

// 19.4.1.1 Symbol([description])
if(!useNative){
  $Symbol = function Symbol(){
    if(isSymbol(this))throw TypeError('Symbol is not a constructor');
    return wrap(uid(arguments.length > 0 ? arguments[0] : undefined));
  };
  redefine($Symbol.prototype, 'toString', function toString(){
    return this._k;
  });

  isSymbol = function(it){
    return it instanceof $Symbol;
  };

  $.create     = $create;
  $.isEnum     = $propertyIsEnumerable;
  $.getDesc    = $getOwnPropertyDescriptor;
  $.setDesc    = $defineProperty;
  $.setDescs   = $defineProperties;
  $.getNames   = $names.get = $getOwnPropertyNames;
  $.getSymbols = $getOwnPropertySymbols;

  if(DESCRIPTORS && !require('./$.library')){
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }
}

var symbolStatics = {
  // 19.4.2.1 Symbol.for(key)
  'for': function(key){
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(key){
    return keyOf(SymbolRegistry, key);
  },
  useSetter: function(){ setter = true; },
  useSimple: function(){ setter = false; }
};
// 19.4.2.2 Symbol.hasInstance
// 19.4.2.3 Symbol.isConcatSpreadable
// 19.4.2.4 Symbol.iterator
// 19.4.2.6 Symbol.match
// 19.4.2.8 Symbol.replace
// 19.4.2.9 Symbol.search
// 19.4.2.10 Symbol.species
// 19.4.2.11 Symbol.split
// 19.4.2.12 Symbol.toPrimitive
// 19.4.2.13 Symbol.toStringTag
// 19.4.2.14 Symbol.unscopables
$.each.call((
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,' +
  'species,split,toPrimitive,toStringTag,unscopables'
).split(','), function(it){
  var sym = wks(it);
  symbolStatics[it] = useNative ? sym : wrap(sym);
});

setter = true;

$export($export.G + $export.W, {Symbol: $Symbol});

$export($export.S, 'Symbol', symbolStatics);

$export($export.S + $export.F * !useNative, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!useNative || buggyJSON), 'JSON', {stringify: $stringify});

// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);
},{"./$":108,"./$.an-object":77,"./$.descriptors":86,"./$.enum-keys":88,"./$.export":89,"./$.fails":90,"./$.get-names":92,"./$.global":93,"./$.has":94,"./$.is-array":100,"./$.keyof":109,"./$.library":110,"./$.property-desc":115,"./$.redefine":117,"./$.set-to-string-tag":121,"./$.shared":122,"./$.to-iobject":128,"./$.uid":131,"./$.wks":132}],146:[function(require,module,exports){
// http://goo.gl/XkBrjD
var $export  = require('./$.export')
  , $entries = require('./$.object-to-array')(true);

$export($export.S, 'Object', {
  entries: function entries(it){
    return $entries(it);
  }
});
},{"./$.export":89,"./$.object-to-array":114}],147:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export  = require('./$.export');

$export($export.P, 'Set', {toJSON: require('./$.collection-to-json')('Set')});
},{"./$.collection-to-json":81,"./$.export":89}],148:[function(require,module,exports){
require('./es6.array.iterator');
var Iterators = require('./$.iterators');
Iterators.NodeList = Iterators.HTMLCollection = Iterators.Array;
},{"./$.iterators":107,"./es6.array.iterator":136}],149:[function(require,module,exports){
(function (global){
// This method of obtaining a reference to the global object needs to be
// kept identical to the way it is obtained in runtime.js
var g =
  typeof global === "object" ? global :
  typeof window === "object" ? window :
  typeof self === "object" ? self : this;

// Use `getOwnPropertyNames` because not all browsers support calling
// `hasOwnProperty` on the global `self` object in a worker. See #183.
var hadRuntime = g.regeneratorRuntime &&
  Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;

// Save the old regeneratorRuntime in case it needs to be restored later.
var oldRuntime = hadRuntime && g.regeneratorRuntime;

// Force reevalutation of runtime.js.
g.regeneratorRuntime = undefined;

module.exports = require("./runtime");

if (hadRuntime) {
  // Restore the original runtime.
  g.regeneratorRuntime = oldRuntime;
} else {
  // Remove the global property added by runtime.js.
  try {
    delete g.regeneratorRuntime;
  } catch(e) {
    g.regeneratorRuntime = undefined;
  }
}

module.exports = { "default": module.exports, __esModule: true };

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./runtime":150}],150:[function(require,module,exports){
(function (process,global){
/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */

"use strict";

var _Symbol = require("babel-runtime/core-js/symbol")["default"];

var _Object$create = require("babel-runtime/core-js/object/create")["default"];

var _Object$setPrototypeOf = require("babel-runtime/core-js/object/set-prototype-of")["default"];

var _Promise = require("babel-runtime/core-js/promise")["default"];

!(function (global) {
  "use strict";

  var hasOwn = Object.prototype.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof _Symbol === "function" ? _Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided, then outerFn.prototype instanceof Generator.
    var generator = _Object$create((outerFn || Generator).prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype;
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      prototype[method] = function (arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function (genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor ? ctor === GeneratorFunction ||
    // For the native GeneratorFunction constructor, the best we can
    // do is to check its .name property.
    (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
  };

  runtime.mark = function (genFun) {
    if (_Object$setPrototypeOf) {
      _Object$setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = _Object$create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `value instanceof AwaitArgument` to determine if the yielded value is
  // meant to be awaited. Some may consider the name of this method too
  // cutesy, but they are curmudgeons.
  runtime.awrap = function (arg) {
    return new AwaitArgument(arg);
  };

  function AwaitArgument(arg) {
    this.arg = arg;
  }

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value instanceof AwaitArgument) {
          return _Promise.resolve(value.arg).then(function (value) {
            invoke("next", value, resolve, reject);
          }, function (err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return _Promise.resolve(value).then(function (unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    if (typeof process === "object" && process.domain) {
      invoke = process.domain.bind(invoke);
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new _Promise(function (resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
      // If enqueue has been called before, then we want to wait until
      // all previous Promises have been resolved before calling invoke,
      // so that results are always delivered in the correct order. If
      // enqueue has not been called before, then it is important to
      // call invoke immediately, without waiting on a callback to fire,
      // so that the async generator function has the opportunity to do
      // any necessary setup in a predictable way. This predictability
      // is why the Promise constructor synchronously invokes its
      // executor callback, and why async functions synchronously
      // execute code before the first await. Since we implement simple
      // async functions in terms of async generators, it is especially
      // important to get this right, even though it requires care.
      previousPromise ? previousPromise.then(callInvokeWithMethodAndArg,
      // Avoid propagating failures to Promises returned by later
      // invocations of the iterator.
      callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function (innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList));

    return runtime.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
    : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          if (method === "return" || method === "throw" && delegate.iterator[method] === undefined) {
            // A return or throw (when the delegate iterator has no throw
            // method) always terminates the yield* loop.
            context.delegate = null;

            // If the delegate iterator has a return method, give it a
            // chance to clean up.
            var returnMethod = delegate.iterator["return"];
            if (returnMethod) {
              var record = tryCatch(returnMethod, delegate.iterator, arg);
              if (record.type === "throw") {
                // If the return method threw an exception, let that
                // exception prevail over the original return or throw.
                method = "throw";
                arg = record.arg;
                continue;
              }
            }

            if (method === "return") {
              // Continue with the outer return, now that the delegate
              // iterator has been terminated.
              continue;
            }
          }

          var record = tryCatch(delegate.iterator[method], delegate.iterator, arg);

          if (record.type === "throw") {
            context.delegate = null;

            // Like returning generator.throw(uncaught), but without the
            // overhead of an extra function call.
            method = "throw";
            arg = record.arg;
            continue;
          }

          // Delegate generator ran and handled its own exceptions so
          // regardless of what the method was, we continue as if it is
          // "next" with an undefined arg.
          method = "next";
          arg = undefined;

          var info = record.arg;
          if (info.done) {
            context[delegate.resultName] = info.value;
            context.next = delegate.nextLoc;
          } else {
            state = GenStateSuspendedYield;
            return info;
          }

          context.delegate = null;
        }

        if (method === "next") {
          if (state === GenStateSuspendedYield) {
            context.sent = arg;
          } else {
            context.sent = undefined;
          }
        } else if (method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw arg;
          }

          if (context.dispatchException(arg)) {
            // If the dispatched exception was caught by a catch block,
            // then let that catch block handle the exception normally.
            method = "next";
            arg = undefined;
          }
        } else if (method === "return") {
          context.abrupt("return", arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done ? GenStateCompleted : GenStateSuspendedYield;

          var info = {
            value: record.arg,
            done: context.done
          };

          if (record.arg === ContinueSentinel) {
            if (context.delegate && method === "next") {
              // Deliberately forget the last sent value so that we don't
              // accidentally pass it on to the delegate.
              arg = undefined;
            }
          } else {
            return info;
          }
        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(arg) call above.
          method = "throw";
          arg = record.arg;
        }
      }
    };
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[iteratorSymbol] = function () {
    return this;
  };

  Gp[toStringTagSymbol] = "Generator";

  Gp.toString = function () {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function (object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1,
            next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function reset(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      this.sent = undefined;
      this.done = false;
      this.delegate = null;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function stop() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function dispatchException(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;
        return !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }
          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function abrupt(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.next = finallyEntry.finallyLoc;
      } else {
        this.complete(record);
      }

      return ContinueSentinel;
    },

    complete: function complete(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" || record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = record.arg;
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }
    },

    finish: function finish(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function _catch(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function delegateYield(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      return ContinueSentinel;
    }
  };
})(
// Among the various tricks for obtaining a reference to the global
// object, this seems to be the most reliable technique that does not
// use indirect eval (which violates Content Security Policy).
typeof global === "object" ? global : typeof window === "object" ? window : typeof self === "object" ? self : undefined);
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"_process":352,"babel-runtime/core-js/object/create":49,"babel-runtime/core-js/object/set-prototype-of":54,"babel-runtime/core-js/promise":55,"babel-runtime/core-js/symbol":57}],151:[function(require,module,exports){
arguments[4][141][0].apply(exports,arguments)
},{"dup":141}],152:[function(require,module,exports){
(function (global){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('isarray')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192 // not used by this implementation

var rootParent = {}

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property
 *     on objects.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

function typedArraySupport () {
  function Bar () {}
  try {
    var arr = new Uint8Array(1)
    arr.foo = function () { return 42 }
    arr.constructor = Bar
    return arr.foo() === 42 && // typed array instances can be augmented
        arr.constructor === Bar && // constructor can be set
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (arg) {
  if (!(this instanceof Buffer)) {
    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.
    if (arguments.length > 1) return new Buffer(arg, arguments[1])
    return new Buffer(arg)
  }

  this.length = 0
  this.parent = undefined

  // Common case.
  if (typeof arg === 'number') {
    return fromNumber(this, arg)
  }

  // Slightly less common case.
  if (typeof arg === 'string') {
    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')
  }

  // Unusual.
  return fromObject(this, arg)
}

function fromNumber (that, length) {
  that = allocate(that, length < 0 ? 0 : checked(length) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < length; i++) {
      that[i] = 0
    }
  }
  return that
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'

  // Assumption: byteLength() return value is always < kMaxLength.
  var length = byteLength(string, encoding) | 0
  that = allocate(that, length)

  that.write(string, encoding)
  return that
}

function fromObject (that, object) {
  if (Buffer.isBuffer(object)) return fromBuffer(that, object)

  if (isArray(object)) return fromArray(that, object)

  if (object == null) {
    throw new TypeError('must start with number, buffer, array or string')
  }

  if (typeof ArrayBuffer !== 'undefined') {
    if (object.buffer instanceof ArrayBuffer) {
      return fromTypedArray(that, object)
    }
    if (object instanceof ArrayBuffer) {
      return fromArrayBuffer(that, object)
    }
  }

  if (object.length) return fromArrayLike(that, object)

  return fromJsonObject(that, object)
}

function fromBuffer (that, buffer) {
  var length = checked(buffer.length) | 0
  that = allocate(that, length)
  buffer.copy(that, 0, 0, length)
  return that
}

function fromArray (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

// Duplicate of fromArray() to keep fromArray() monomorphic.
function fromTypedArray (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  // Truncating the elements is probably not what people expect from typed
  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior
  // of the old Buffer constructor.
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array) {
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    array.byteLength
    that = Buffer._augment(new Uint8Array(array))
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromTypedArray(that, new Uint8Array(array))
  }
  return that
}

function fromArrayLike (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.
// Returns a zero-length buffer for inputs that don't conform to the spec.
function fromJsonObject (that, object) {
  var array
  var length = 0

  if (object.type === 'Buffer' && isArray(object.data)) {
    array = object.data
    length = checked(array.length) | 0
  }
  that = allocate(that, length)

  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
}

function allocate (that, length) {
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = Buffer._augment(new Uint8Array(length))
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that.length = length
    that._isBuffer = true
  }

  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1
  if (fromPool) that.parent = rootParent

  return that
}

function checked (length) {
  // Note: cannot use `length < kMaxLength` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (subject, encoding) {
  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)

  var buf = new Buffer(subject, encoding)
  delete buf.parent
  return buf
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  var i = 0
  var len = Math.min(x, y)
  while (i < len) {
    if (a[i] !== b[i]) break

    ++i
  }

  if (i !== len) {
    x = a[i]
    y = b[i]
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')

  if (list.length === 0) {
    return new Buffer(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; i++) {
      length += list[i].length
    }
  }

  var buf = new Buffer(length)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

function byteLength (string, encoding) {
  if (typeof string !== 'string') string = '' + string

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'binary':
      // Deprecated
      case 'raw':
      case 'raws':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

// pre-set for values that may exist in the future
Buffer.prototype.length = undefined
Buffer.prototype.parent = undefined

function slowToString (encoding, start, end) {
  var loweredCase = false

  start = start | 0
  end = end === undefined || end === Infinity ? this.length : end | 0

  if (!encoding) encoding = 'utf8'
  if (start < 0) start = 0
  if (end > this.length) end = this.length
  if (end <= start) return ''

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'binary':
        return binarySlice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return 0
  return Buffer.compare(this, b)
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset) {
  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff
  else if (byteOffset < -0x80000000) byteOffset = -0x80000000
  byteOffset >>= 0

  if (this.length === 0) return -1
  if (byteOffset >= this.length) return -1

  // Negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)

  if (typeof val === 'string') {
    if (val.length === 0) return -1 // special case: looking for empty string always fails
    return String.prototype.indexOf.call(this, val, byteOffset)
  }
  if (Buffer.isBuffer(val)) {
    return arrayIndexOf(this, val, byteOffset)
  }
  if (typeof val === 'number') {
    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
    }
    return arrayIndexOf(this, [ val ], byteOffset)
  }

  function arrayIndexOf (arr, val, byteOffset) {
    var foundIndex = -1
    for (var i = 0; byteOffset + i < arr.length; i++) {
      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex
      } else {
        foundIndex = -1
      }
    }
    return -1
  }

  throw new TypeError('val must be string, number or Buffer')
}

// `get` is deprecated
Buffer.prototype.get = function get (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` is deprecated
Buffer.prototype.set = function set (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) throw new Error('Invalid hex string')
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function binaryWrite (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    var swap = encoding
    encoding = offset
    offset = length | 0
    length = swap
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'binary':
        return binaryWrite(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function binarySlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
  }

  if (newBuf.length) newBuf.parent = this.parent || this

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('value is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = value < 0 ? 1 : 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = value < 0 ? 1 : 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (value > max || value < min) throw new RangeError('value is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('index out of range')
  if (offset < 0) throw new RangeError('index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; i--) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; i++) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    target._set(this.subarray(start, start + len), targetStart)
  }

  return len
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function fill (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (end < start) throw new RangeError('end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')
  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')

  var i
  if (typeof value === 'number') {
    for (i = start; i < end; i++) {
      this[i] = value
    }
  } else {
    var bytes = utf8ToBytes(value.toString())
    var len = bytes.length
    for (i = start; i < end; i++) {
      this[i] = bytes[i % len]
    }
  }

  return this
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function toArrayBuffer () {
  if (typeof Uint8Array !== 'undefined') {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1) {
        buf[i] = this[i]
      }
      return buf.buffer
    }
  } else {
    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function _augment (arr) {
  arr.constructor = Buffer
  arr._isBuffer = true

  // save reference to original Uint8Array set method before overwriting
  arr._set = arr.set

  // deprecated
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.equals = BP.equals
  arr.compare = BP.compare
  arr.indexOf = BP.indexOf
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUIntLE = BP.readUIntLE
  arr.readUIntBE = BP.readUIntBE
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readIntLE = BP.readIntLE
  arr.readIntBE = BP.readIntBE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUIntLE = BP.writeUIntLE
  arr.writeUIntBE = BP.writeUIntBE
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeIntLE = BP.writeIntLE
  arr.writeIntBE = BP.writeIntBE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; i++) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"base64-js":153,"ieee754":154,"isarray":155}],153:[function(require,module,exports){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)
	var PLUS_URL_SAFE = '-'.charCodeAt(0)
	var SLASH_URL_SAFE = '_'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS ||
		    code === PLUS_URL_SAFE)
			return 62 // '+'
		if (code === SLASH ||
		    code === SLASH_URL_SAFE)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

},{}],154:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],155:[function(require,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],156:[function(require,module,exports){
'use strict'

exports.randomBytes = exports.rng = exports.pseudoRandomBytes = exports.prng = require('randombytes')
exports.createHash = exports.Hash = require('create-hash')
exports.createHmac = exports.Hmac = require('create-hmac')

var hashes = ['sha1', 'sha224', 'sha256', 'sha384', 'sha512', 'md5', 'rmd160'].concat(Object.keys(require('browserify-sign/algos')))
exports.getHashes = function () {
  return hashes
}

var p = require('pbkdf2')
exports.pbkdf2 = p.pbkdf2
exports.pbkdf2Sync = p.pbkdf2Sync

var aes = require('browserify-cipher')
;[
  'Cipher',
  'createCipher',
  'Cipheriv',
  'createCipheriv',
  'Decipher',
  'createDecipher',
  'Decipheriv',
  'createDecipheriv',
  'getCiphers',
  'listCiphers'
].forEach(function (key) {
  exports[key] = aes[key]
})

var dh = require('diffie-hellman')
;[
  'DiffieHellmanGroup',
  'createDiffieHellmanGroup',
  'getDiffieHellman',
  'createDiffieHellman',
  'DiffieHellman'
].forEach(function (key) {
  exports[key] = dh[key]
})

var sign = require('browserify-sign')
;[
  'createSign',
  'Sign',
  'createVerify',
  'Verify'
].forEach(function (key) {
  exports[key] = sign[key]
})

exports.createECDH = require('create-ecdh')

var publicEncrypt = require('public-encrypt')

;[
  'publicEncrypt',
  'privateEncrypt',
  'publicDecrypt',
  'privateDecrypt'
].forEach(function (key) {
  exports[key] = publicEncrypt[key]
})

// the least I can do is make error messages for the rest of the node.js/crypto api.
;[
  'createCredentials'
].forEach(function (name) {
  exports[name] = function () {
    throw new Error([
      'sorry, ' + name + ' is not implemented yet',
      'we accept pull requests',
      'https://github.com/crypto-browserify/crypto-browserify'
    ].join('\n'))
  }
})

},{"browserify-cipher":157,"browserify-sign":187,"browserify-sign/algos":186,"create-ecdh":254,"create-hash":280,"create-hmac":293,"diffie-hellman":294,"pbkdf2":301,"public-encrypt":302,"randombytes":347}],157:[function(require,module,exports){
var ebtk = require('evp_bytestokey')
var aes = require('browserify-aes/browser')
var DES = require('browserify-des')
var desModes = require('browserify-des/modes')
var aesModes = require('browserify-aes/modes')
function createCipher (suite, password) {
  var keyLen, ivLen
  suite = suite.toLowerCase()
  if (aesModes[suite]) {
    keyLen = aesModes[suite].key
    ivLen = aesModes[suite].iv
  } else if (desModes[suite]) {
    keyLen = desModes[suite].key * 8
    ivLen = desModes[suite].iv
  } else {
    throw new TypeError('invalid suite type')
  }
  var keys = ebtk(password, false, keyLen, ivLen)
  return createCipheriv(suite, keys.key, keys.iv)
}
function createDecipher (suite, password) {
  var keyLen, ivLen
  suite = suite.toLowerCase()
  if (aesModes[suite]) {
    keyLen = aesModes[suite].key
    ivLen = aesModes[suite].iv
  } else if (desModes[suite]) {
    keyLen = desModes[suite].key * 8
    ivLen = desModes[suite].iv
  } else {
    throw new TypeError('invalid suite type')
  }
  var keys = ebtk(password, false, keyLen, ivLen)
  return createDecipheriv(suite, keys.key, keys.iv)
}

function createCipheriv (suite, key, iv) {
  suite = suite.toLowerCase()
  if (aesModes[suite]) {
    return aes.createCipheriv(suite, key, iv)
  } else if (desModes[suite]) {
    return new DES({
      key: key,
      iv: iv,
      mode: suite
    })
  } else {
    throw new TypeError('invalid suite type')
  }
}
function createDecipheriv (suite, key, iv) {
  suite = suite.toLowerCase()
  if (aesModes[suite]) {
    return aes.createDecipheriv(suite, key, iv)
  } else if (desModes[suite]) {
    return new DES({
      key: key,
      iv: iv,
      mode: suite,
      decrypt: true
    })
  } else {
    throw new TypeError('invalid suite type')
  }
}
exports.createCipher = exports.Cipher = createCipher
exports.createCipheriv = exports.Cipheriv = createCipheriv
exports.createDecipher = exports.Decipher = createDecipher
exports.createDecipheriv = exports.Decipheriv = createDecipheriv
function getCiphers () {
  return Object.keys(desModes).concat(aes.getCiphers())
}
exports.listCiphers = exports.getCiphers = getCiphers

},{"browserify-aes/browser":160,"browserify-aes/modes":164,"browserify-des":175,"browserify-des/modes":176,"evp_bytestokey":185}],158:[function(require,module,exports){
(function (Buffer){
// based on the aes implimentation in triple sec
// https://github.com/keybase/triplesec

// which is in turn based on the one from crypto-js
// https://code.google.com/p/crypto-js/

var uint_max = Math.pow(2, 32)
function fixup_uint32 (x) {
  var ret, x_pos
  ret = x > uint_max || x < 0 ? (x_pos = Math.abs(x) % uint_max, x < 0 ? uint_max - x_pos : x_pos) : x
  return ret
}
function scrub_vec (v) {
  for (var i = 0; i < v.length; v++) {
    v[i] = 0
  }
  return false
}

function Global () {
  this.SBOX = []
  this.INV_SBOX = []
  this.SUB_MIX = [[], [], [], []]
  this.INV_SUB_MIX = [[], [], [], []]
  this.init()
  this.RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36]
}

Global.prototype.init = function () {
  var d, i, sx, t, x, x2, x4, x8, xi, _i
  d = (function () {
    var _i, _results
    _results = []
    for (i = _i = 0; _i < 256; i = ++_i) {
      if (i < 128) {
        _results.push(i << 1)
      } else {
        _results.push((i << 1) ^ 0x11b)
      }
    }
    return _results
  })()
  x = 0
  xi = 0
  for (i = _i = 0; _i < 256; i = ++_i) {
    sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4)
    sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63
    this.SBOX[x] = sx
    this.INV_SBOX[sx] = x
    x2 = d[x]
    x4 = d[x2]
    x8 = d[x4]
    t = (d[sx] * 0x101) ^ (sx * 0x1010100)
    this.SUB_MIX[0][x] = (t << 24) | (t >>> 8)
    this.SUB_MIX[1][x] = (t << 16) | (t >>> 16)
    this.SUB_MIX[2][x] = (t << 8) | (t >>> 24)
    this.SUB_MIX[3][x] = t
    t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100)
    this.INV_SUB_MIX[0][sx] = (t << 24) | (t >>> 8)
    this.INV_SUB_MIX[1][sx] = (t << 16) | (t >>> 16)
    this.INV_SUB_MIX[2][sx] = (t << 8) | (t >>> 24)
    this.INV_SUB_MIX[3][sx] = t
    if (x === 0) {
      x = xi = 1
    } else {
      x = x2 ^ d[d[d[x8 ^ x2]]]
      xi ^= d[d[xi]]
    }
  }
  return true
}

var G = new Global()

AES.blockSize = 4 * 4

AES.prototype.blockSize = AES.blockSize

AES.keySize = 256 / 8

AES.prototype.keySize = AES.keySize

function bufferToArray (buf) {
  var len = buf.length / 4
  var out = new Array(len)
  var i = -1
  while (++i < len) {
    out[i] = buf.readUInt32BE(i * 4)
  }
  return out
}
function AES (key) {
  this._key = bufferToArray(key)
  this._doReset()
}

AES.prototype._doReset = function () {
  var invKsRow, keySize, keyWords, ksRow, ksRows, t
  keyWords = this._key
  keySize = keyWords.length
  this._nRounds = keySize + 6
  ksRows = (this._nRounds + 1) * 4
  this._keySchedule = []
  for (ksRow = 0; ksRow < ksRows; ksRow++) {
    this._keySchedule[ksRow] = ksRow < keySize ? keyWords[ksRow] : (t = this._keySchedule[ksRow - 1], (ksRow % keySize) === 0 ? (t = (t << 8) | (t >>> 24), t = (G.SBOX[t >>> 24] << 24) | (G.SBOX[(t >>> 16) & 0xff] << 16) | (G.SBOX[(t >>> 8) & 0xff] << 8) | G.SBOX[t & 0xff], t ^= G.RCON[(ksRow / keySize) | 0] << 24) : keySize > 6 && ksRow % keySize === 4 ? t = (G.SBOX[t >>> 24] << 24) | (G.SBOX[(t >>> 16) & 0xff] << 16) | (G.SBOX[(t >>> 8) & 0xff] << 8) | G.SBOX[t & 0xff] : void 0, this._keySchedule[ksRow - keySize] ^ t)
  }
  this._invKeySchedule = []
  for (invKsRow = 0; invKsRow < ksRows; invKsRow++) {
    ksRow = ksRows - invKsRow
    t = this._keySchedule[ksRow - (invKsRow % 4 ? 0 : 4)]
    this._invKeySchedule[invKsRow] = invKsRow < 4 || ksRow <= 4 ? t : G.INV_SUB_MIX[0][G.SBOX[t >>> 24]] ^ G.INV_SUB_MIX[1][G.SBOX[(t >>> 16) & 0xff]] ^ G.INV_SUB_MIX[2][G.SBOX[(t >>> 8) & 0xff]] ^ G.INV_SUB_MIX[3][G.SBOX[t & 0xff]]
  }
  return true
}

AES.prototype.encryptBlock = function (M) {
  M = bufferToArray(new Buffer(M))
  var out = this._doCryptBlock(M, this._keySchedule, G.SUB_MIX, G.SBOX)
  var buf = new Buffer(16)
  buf.writeUInt32BE(out[0], 0)
  buf.writeUInt32BE(out[1], 4)
  buf.writeUInt32BE(out[2], 8)
  buf.writeUInt32BE(out[3], 12)
  return buf
}

AES.prototype.decryptBlock = function (M) {
  M = bufferToArray(new Buffer(M))
  var temp = [M[3], M[1]]
  M[1] = temp[0]
  M[3] = temp[1]
  var out = this._doCryptBlock(M, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX)
  var buf = new Buffer(16)
  buf.writeUInt32BE(out[0], 0)
  buf.writeUInt32BE(out[3], 4)
  buf.writeUInt32BE(out[2], 8)
  buf.writeUInt32BE(out[1], 12)
  return buf
}

AES.prototype.scrub = function () {
  scrub_vec(this._keySchedule)
  scrub_vec(this._invKeySchedule)
  scrub_vec(this._key)
}

AES.prototype._doCryptBlock = function (M, keySchedule, SUB_MIX, SBOX) {
  var ksRow, s0, s1, s2, s3, t0, t1, t2, t3

  s0 = M[0] ^ keySchedule[0]
  s1 = M[1] ^ keySchedule[1]
  s2 = M[2] ^ keySchedule[2]
  s3 = M[3] ^ keySchedule[3]
  ksRow = 4
  for (var round = 1; round < this._nRounds; round++) {
    t0 = SUB_MIX[0][s0 >>> 24] ^ SUB_MIX[1][(s1 >>> 16) & 0xff] ^ SUB_MIX[2][(s2 >>> 8) & 0xff] ^ SUB_MIX[3][s3 & 0xff] ^ keySchedule[ksRow++]
    t1 = SUB_MIX[0][s1 >>> 24] ^ SUB_MIX[1][(s2 >>> 16) & 0xff] ^ SUB_MIX[2][(s3 >>> 8) & 0xff] ^ SUB_MIX[3][s0 & 0xff] ^ keySchedule[ksRow++]
    t2 = SUB_MIX[0][s2 >>> 24] ^ SUB_MIX[1][(s3 >>> 16) & 0xff] ^ SUB_MIX[2][(s0 >>> 8) & 0xff] ^ SUB_MIX[3][s1 & 0xff] ^ keySchedule[ksRow++]
    t3 = SUB_MIX[0][s3 >>> 24] ^ SUB_MIX[1][(s0 >>> 16) & 0xff] ^ SUB_MIX[2][(s1 >>> 8) & 0xff] ^ SUB_MIX[3][s2 & 0xff] ^ keySchedule[ksRow++]
    s0 = t0
    s1 = t1
    s2 = t2
    s3 = t3
  }
  t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++]
  t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++]
  t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++]
  t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++]
  return [
    fixup_uint32(t0),
    fixup_uint32(t1),
    fixup_uint32(t2),
    fixup_uint32(t3)
  ]
}

exports.AES = AES

}).call(this,require("buffer").Buffer)

},{"buffer":152}],159:[function(require,module,exports){
(function (Buffer){
var aes = require('./aes')
var Transform = require('cipher-base')
var inherits = require('inherits')
var GHASH = require('./ghash')
var xor = require('buffer-xor')
inherits(StreamCipher, Transform)
module.exports = StreamCipher

function StreamCipher (mode, key, iv, decrypt) {
  if (!(this instanceof StreamCipher)) {
    return new StreamCipher(mode, key, iv)
  }
  Transform.call(this)
  this._finID = Buffer.concat([iv, new Buffer([0, 0, 0, 1])])
  iv = Buffer.concat([iv, new Buffer([0, 0, 0, 2])])
  this._cipher = new aes.AES(key)
  this._prev = new Buffer(iv.length)
  this._cache = new Buffer('')
  this._secCache = new Buffer('')
  this._decrypt = decrypt
  this._alen = 0
  this._len = 0
  iv.copy(this._prev)
  this._mode = mode
  var h = new Buffer(4)
  h.fill(0)
  this._ghash = new GHASH(this._cipher.encryptBlock(h))
  this._authTag = null
  this._called = false
}
StreamCipher.prototype._update = function (chunk) {
  if (!this._called && this._alen) {
    var rump = 16 - (this._alen % 16)
    if (rump < 16) {
      rump = new Buffer(rump)
      rump.fill(0)
      this._ghash.update(rump)
    }
  }
  this._called = true
  var out = this._mode.encrypt(this, chunk)
  if (this._decrypt) {
    this._ghash.update(chunk)
  } else {
    this._ghash.update(out)
  }
  this._len += chunk.length
  return out
}
StreamCipher.prototype._final = function () {
  if (this._decrypt && !this._authTag) {
    throw new Error('Unsupported state or unable to authenticate data')
  }
  var tag = xor(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID))
  if (this._decrypt) {
    if (xorTest(tag, this._authTag)) {
      throw new Error('Unsupported state or unable to authenticate data')
    }
  } else {
    this._authTag = tag
  }
  this._cipher.scrub()
}
StreamCipher.prototype.getAuthTag = function getAuthTag () {
  if (!this._decrypt && Buffer.isBuffer(this._authTag)) {
    return this._authTag
  } else {
    throw new Error('Attempting to get auth tag in unsupported state')
  }
}
StreamCipher.prototype.setAuthTag = function setAuthTag (tag) {
  if (this._decrypt) {
    this._authTag = tag
  } else {
    throw new Error('Attempting to set auth tag in unsupported state')
  }
}
StreamCipher.prototype.setAAD = function setAAD (buf) {
  if (!this._called) {
    this._ghash.update(buf)
    this._alen += buf.length
  } else {
    throw new Error('Attempting to set AAD in unsupported state')
  }
}
function xorTest (a, b) {
  var out = 0
  if (a.length !== b.length) {
    out++
  }
  var len = Math.min(a.length, b.length)
  var i = -1
  while (++i < len) {
    out += (a[i] ^ b[i])
  }
  return out
}

}).call(this,require("buffer").Buffer)

},{"./aes":158,"./ghash":163,"buffer":152,"buffer-xor":172,"cipher-base":173,"inherits":349}],160:[function(require,module,exports){
var ciphers = require('./encrypter')
exports.createCipher = exports.Cipher = ciphers.createCipher
exports.createCipheriv = exports.Cipheriv = ciphers.createCipheriv
var deciphers = require('./decrypter')
exports.createDecipher = exports.Decipher = deciphers.createDecipher
exports.createDecipheriv = exports.Decipheriv = deciphers.createDecipheriv
var modes = require('./modes')
function getCiphers () {
  return Object.keys(modes)
}
exports.listCiphers = exports.getCiphers = getCiphers

},{"./decrypter":161,"./encrypter":162,"./modes":164}],161:[function(require,module,exports){
(function (Buffer){
var aes = require('./aes')
var Transform = require('cipher-base')
var inherits = require('inherits')
var modes = require('./modes')
var StreamCipher = require('./streamCipher')
var AuthCipher = require('./authCipher')
var ebtk = require('evp_bytestokey')

inherits(Decipher, Transform)
function Decipher (mode, key, iv) {
  if (!(this instanceof Decipher)) {
    return new Decipher(mode, key, iv)
  }
  Transform.call(this)
  this._cache = new Splitter()
  this._last = void 0
  this._cipher = new aes.AES(key)
  this._prev = new Buffer(iv.length)
  iv.copy(this._prev)
  this._mode = mode
  this._autopadding = true
}
Decipher.prototype._update = function (data) {
  this._cache.add(data)
  var chunk
  var thing
  var out = []
  while ((chunk = this._cache.get(this._autopadding))) {
    thing = this._mode.decrypt(this, chunk)
    out.push(thing)
  }
  return Buffer.concat(out)
}
Decipher.prototype._final = function () {
  var chunk = this._cache.flush()
  if (this._autopadding) {
    return unpad(this._mode.decrypt(this, chunk))
  } else if (chunk) {
    throw new Error('data not multiple of block length')
  }
}
Decipher.prototype.setAutoPadding = function (setTo) {
  this._autopadding = !!setTo
}
function Splitter () {
  if (!(this instanceof Splitter)) {
    return new Splitter()
  }
  this.cache = new Buffer('')
}
Splitter.prototype.add = function (data) {
  this.cache = Buffer.concat([this.cache, data])
}

Splitter.prototype.get = function (autoPadding) {
  var out
  if (autoPadding) {
    if (this.cache.length > 16) {
      out = this.cache.slice(0, 16)
      this.cache = this.cache.slice(16)
      return out
    }
  } else {
    if (this.cache.length >= 16) {
      out = this.cache.slice(0, 16)
      this.cache = this.cache.slice(16)
      return out
    }
  }
  return null
}
Splitter.prototype.flush = function () {
  if (this.cache.length) {
    return this.cache
  }
}
function unpad (last) {
  var padded = last[15]
  var i = -1
  while (++i < padded) {
    if (last[(i + (16 - padded))] !== padded) {
      throw new Error('unable to decrypt data')
    }
  }
  if (padded === 16) {
    return
  }
  return last.slice(0, 16 - padded)
}

var modelist = {
  ECB: require('./modes/ecb'),
  CBC: require('./modes/cbc'),
  CFB: require('./modes/cfb'),
  CFB8: require('./modes/cfb8'),
  CFB1: require('./modes/cfb1'),
  OFB: require('./modes/ofb'),
  CTR: require('./modes/ctr'),
  GCM: require('./modes/ctr')
}

function createDecipheriv (suite, password, iv) {
  var config = modes[suite.toLowerCase()]
  if (!config) {
    throw new TypeError('invalid suite type')
  }
  if (typeof iv === 'string') {
    iv = new Buffer(iv)
  }
  if (typeof password === 'string') {
    password = new Buffer(password)
  }
  if (password.length !== config.key / 8) {
    throw new TypeError('invalid key length ' + password.length)
  }
  if (iv.length !== config.iv) {
    throw new TypeError('invalid iv length ' + iv.length)
  }
  if (config.type === 'stream') {
    return new StreamCipher(modelist[config.mode], password, iv, true)
  } else if (config.type === 'auth') {
    return new AuthCipher(modelist[config.mode], password, iv, true)
  }
  return new Decipher(modelist[config.mode], password, iv)
}

function createDecipher (suite, password) {
  var config = modes[suite.toLowerCase()]
  if (!config) {
    throw new TypeError('invalid suite type')
  }
  var keys = ebtk(password, false, config.key, config.iv)
  return createDecipheriv(suite, keys.key, keys.iv)
}
exports.createDecipher = createDecipher
exports.createDecipheriv = createDecipheriv

}).call(this,require("buffer").Buffer)

},{"./aes":158,"./authCipher":159,"./modes":164,"./modes/cbc":165,"./modes/cfb":166,"./modes/cfb1":167,"./modes/cfb8":168,"./modes/ctr":169,"./modes/ecb":170,"./modes/ofb":171,"./streamCipher":174,"buffer":152,"cipher-base":173,"evp_bytestokey":185,"inherits":349}],162:[function(require,module,exports){
(function (Buffer){
var aes = require('./aes')
var Transform = require('cipher-base')
var inherits = require('inherits')
var modes = require('./modes')
var ebtk = require('evp_bytestokey')
var StreamCipher = require('./streamCipher')
var AuthCipher = require('./authCipher')
inherits(Cipher, Transform)
function Cipher (mode, key, iv) {
  if (!(this instanceof Cipher)) {
    return new Cipher(mode, key, iv)
  }
  Transform.call(this)
  this._cache = new Splitter()
  this._cipher = new aes.AES(key)
  this._prev = new Buffer(iv.length)
  iv.copy(this._prev)
  this._mode = mode
  this._autopadding = true
}
Cipher.prototype._update = function (data) {
  this._cache.add(data)
  var chunk
  var thing
  var out = []
  while ((chunk = this._cache.get())) {
    thing = this._mode.encrypt(this, chunk)
    out.push(thing)
  }
  return Buffer.concat(out)
}
Cipher.prototype._final = function () {
  var chunk = this._cache.flush()
  if (this._autopadding) {
    chunk = this._mode.encrypt(this, chunk)
    this._cipher.scrub()
    return chunk
  } else if (chunk.toString('hex') !== '10101010101010101010101010101010') {
    this._cipher.scrub()
    throw new Error('data not multiple of block length')
  }
}
Cipher.prototype.setAutoPadding = function (setTo) {
  this._autopadding = !!setTo
}

function Splitter () {
  if (!(this instanceof Splitter)) {
    return new Splitter()
  }
  this.cache = new Buffer('')
}
Splitter.prototype.add = function (data) {
  this.cache = Buffer.concat([this.cache, data])
}

Splitter.prototype.get = function () {
  if (this.cache.length > 15) {
    var out = this.cache.slice(0, 16)
    this.cache = this.cache.slice(16)
    return out
  }
  return null
}
Splitter.prototype.flush = function () {
  var len = 16 - this.cache.length
  var padBuff = new Buffer(len)

  var i = -1
  while (++i < len) {
    padBuff.writeUInt8(len, i)
  }
  var out = Buffer.concat([this.cache, padBuff])
  return out
}
var modelist = {
  ECB: require('./modes/ecb'),
  CBC: require('./modes/cbc'),
  CFB: require('./modes/cfb'),
  CFB8: require('./modes/cfb8'),
  CFB1: require('./modes/cfb1'),
  OFB: require('./modes/ofb'),
  CTR: require('./modes/ctr'),
  GCM: require('./modes/ctr')
}

function createCipheriv (suite, password, iv) {
  var config = modes[suite.toLowerCase()]
  if (!config) {
    throw new TypeError('invalid suite type')
  }
  if (typeof iv === 'string') {
    iv = new Buffer(iv)
  }
  if (typeof password === 'string') {
    password = new Buffer(password)
  }
  if (password.length !== config.key / 8) {
    throw new TypeError('invalid key length ' + password.length)
  }
  if (iv.length !== config.iv) {
    throw new TypeError('invalid iv length ' + iv.length)
  }
  if (config.type === 'stream') {
    return new StreamCipher(modelist[config.mode], password, iv)
  } else if (config.type === 'auth') {
    return new AuthCipher(modelist[config.mode], password, iv)
  }
  return new Cipher(modelist[config.mode], password, iv)
}
function createCipher (suite, password) {
  var config = modes[suite.toLowerCase()]
  if (!config) {
    throw new TypeError('invalid suite type')
  }
  var keys = ebtk(password, false, config.key, config.iv)
  return createCipheriv(suite, keys.key, keys.iv)
}

exports.createCipheriv = createCipheriv
exports.createCipher = createCipher

}).call(this,require("buffer").Buffer)

},{"./aes":158,"./authCipher":159,"./modes":164,"./modes/cbc":165,"./modes/cfb":166,"./modes/cfb1":167,"./modes/cfb8":168,"./modes/ctr":169,"./modes/ecb":170,"./modes/ofb":171,"./streamCipher":174,"buffer":152,"cipher-base":173,"evp_bytestokey":185,"inherits":349}],163:[function(require,module,exports){
(function (Buffer){
var zeros = new Buffer(16)
zeros.fill(0)
module.exports = GHASH
function GHASH (key) {
  this.h = key
  this.state = new Buffer(16)
  this.state.fill(0)
  this.cache = new Buffer('')
}
// from http://bitwiseshiftleft.github.io/sjcl/doc/symbols/src/core_gcm.js.html
// by Juho Vh-Herttua
GHASH.prototype.ghash = function (block) {
  var i = -1
  while (++i < block.length) {
    this.state[i] ^= block[i]
  }
  this._multiply()
}

GHASH.prototype._multiply = function () {
  var Vi = toArray(this.h)
  var Zi = [0, 0, 0, 0]
  var j, xi, lsb_Vi
  var i = -1
  while (++i < 128) {
    xi = (this.state[~~(i / 8)] & (1 << (7 - i % 8))) !== 0
    if (xi) {
      // Z_i+1 = Z_i ^ V_i
      Zi = xor(Zi, Vi)
    }

    // Store the value of LSB(V_i)
    lsb_Vi = (Vi[3] & 1) !== 0

    // V_i+1 = V_i >> 1
    for (j = 3; j > 0; j--) {
      Vi[j] = (Vi[j] >>> 1) | ((Vi[j - 1] & 1) << 31)
    }
    Vi[0] = Vi[0] >>> 1

    // If LSB(V_i) is 1, V_i+1 = (V_i >> 1) ^ R
    if (lsb_Vi) {
      Vi[0] = Vi[0] ^ (0xe1 << 24)
    }
  }
  this.state = fromArray(Zi)
}
GHASH.prototype.update = function (buf) {
  this.cache = Buffer.concat([this.cache, buf])
  var chunk
  while (this.cache.length >= 16) {
    chunk = this.cache.slice(0, 16)
    this.cache = this.cache.slice(16)
    this.ghash(chunk)
  }
}
GHASH.prototype.final = function (abl, bl) {
  if (this.cache.length) {
    this.ghash(Buffer.concat([this.cache, zeros], 16))
  }
  this.ghash(fromArray([
    0, abl,
    0, bl
  ]))
  return this.state
}

function toArray (buf) {
  return [
    buf.readUInt32BE(0),
    buf.readUInt32BE(4),
    buf.readUInt32BE(8),
    buf.readUInt32BE(12)
  ]
}
function fromArray (out) {
  out = out.map(fixup_uint32)
  var buf = new Buffer(16)
  buf.writeUInt32BE(out[0], 0)
  buf.writeUInt32BE(out[1], 4)
  buf.writeUInt32BE(out[2], 8)
  buf.writeUInt32BE(out[3], 12)
  return buf
}
var uint_max = Math.pow(2, 32)
function fixup_uint32 (x) {
  var ret, x_pos
  ret = x > uint_max || x < 0 ? (x_pos = Math.abs(x) % uint_max, x < 0 ? uint_max - x_pos : x_pos) : x
  return ret
}
function xor (a, b) {
  return [
    a[0] ^ b[0],
    a[1] ^ b[1],
    a[2] ^ b[2],
    a[3] ^ b[3]
  ]
}

}).call(this,require("buffer").Buffer)

},{"buffer":152}],164:[function(require,module,exports){
exports['aes-128-ecb'] = {
  cipher: 'AES',
  key: 128,
  iv: 0,
  mode: 'ECB',
  type: 'block'
}
exports['aes-192-ecb'] = {
  cipher: 'AES',
  key: 192,
  iv: 0,
  mode: 'ECB',
  type: 'block'
}
exports['aes-256-ecb'] = {
  cipher: 'AES',
  key: 256,
  iv: 0,
  mode: 'ECB',
  type: 'block'
}
exports['aes-128-cbc'] = {
  cipher: 'AES',
  key: 128,
  iv: 16,
  mode: 'CBC',
  type: 'block'
}
exports['aes-192-cbc'] = {
  cipher: 'AES',
  key: 192,
  iv: 16,
  mode: 'CBC',
  type: 'block'
}
exports['aes-256-cbc'] = {
  cipher: 'AES',
  key: 256,
  iv: 16,
  mode: 'CBC',
  type: 'block'
}
exports['aes128'] = exports['aes-128-cbc']
exports['aes192'] = exports['aes-192-cbc']
exports['aes256'] = exports['aes-256-cbc']
exports['aes-128-cfb'] = {
  cipher: 'AES',
  key: 128,
  iv: 16,
  mode: 'CFB',
  type: 'stream'
}
exports['aes-192-cfb'] = {
  cipher: 'AES',
  key: 192,
  iv: 16,
  mode: 'CFB',
  type: 'stream'
}
exports['aes-256-cfb'] = {
  cipher: 'AES',
  key: 256,
  iv: 16,
  mode: 'CFB',
  type: 'stream'
}
exports['aes-128-cfb8'] = {
  cipher: 'AES',
  key: 128,
  iv: 16,
  mode: 'CFB8',
  type: 'stream'
}
exports['aes-192-cfb8'] = {
  cipher: 'AES',
  key: 192,
  iv: 16,
  mode: 'CFB8',
  type: 'stream'
}
exports['aes-256-cfb8'] = {
  cipher: 'AES',
  key: 256,
  iv: 16,
  mode: 'CFB8',
  type: 'stream'
}
exports['aes-128-cfb1'] = {
  cipher: 'AES',
  key: 128,
  iv: 16,
  mode: 'CFB1',
  type: 'stream'
}
exports['aes-192-cfb1'] = {
  cipher: 'AES',
  key: 192,
  iv: 16,
  mode: 'CFB1',
  type: 'stream'
}
exports['aes-256-cfb1'] = {
  cipher: 'AES',
  key: 256,
  iv: 16,
  mode: 'CFB1',
  type: 'stream'
}
exports['aes-128-ofb'] = {
  cipher: 'AES',
  key: 128,
  iv: 16,
  mode: 'OFB',
  type: 'stream'
}
exports['aes-192-ofb'] = {
  cipher: 'AES',
  key: 192,
  iv: 16,
  mode: 'OFB',
  type: 'stream'
}
exports['aes-256-ofb'] = {
  cipher: 'AES',
  key: 256,
  iv: 16,
  mode: 'OFB',
  type: 'stream'
}
exports['aes-128-ctr'] = {
  cipher: 'AES',
  key: 128,
  iv: 16,
  mode: 'CTR',
  type: 'stream'
}
exports['aes-192-ctr'] = {
  cipher: 'AES',
  key: 192,
  iv: 16,
  mode: 'CTR',
  type: 'stream'
}
exports['aes-256-ctr'] = {
  cipher: 'AES',
  key: 256,
  iv: 16,
  mode: 'CTR',
  type: 'stream'
}
exports['aes-128-gcm'] = {
  cipher: 'AES',
  key: 128,
  iv: 12,
  mode: 'GCM',
  type: 'auth'
}
exports['aes-192-gcm'] = {
  cipher: 'AES',
  key: 192,
  iv: 12,
  mode: 'GCM',
  type: 'auth'
}
exports['aes-256-gcm'] = {
  cipher: 'AES',
  key: 256,
  iv: 12,
  mode: 'GCM',
  type: 'auth'
}

},{}],165:[function(require,module,exports){
var xor = require('buffer-xor')

exports.encrypt = function (self, block) {
  var data = xor(block, self._prev)

  self._prev = self._cipher.encryptBlock(data)
  return self._prev
}

exports.decrypt = function (self, block) {
  var pad = self._prev

  self._prev = block
  var out = self._cipher.decryptBlock(block)

  return xor(out, pad)
}

},{"buffer-xor":172}],166:[function(require,module,exports){
(function (Buffer){
var xor = require('buffer-xor')

exports.encrypt = function (self, data, decrypt) {
  var out = new Buffer('')
  var len

  while (data.length) {
    if (self._cache.length === 0) {
      self._cache = self._cipher.encryptBlock(self._prev)
      self._prev = new Buffer('')
    }

    if (self._cache.length <= data.length) {
      len = self._cache.length
      out = Buffer.concat([out, encryptStart(self, data.slice(0, len), decrypt)])
      data = data.slice(len)
    } else {
      out = Buffer.concat([out, encryptStart(self, data, decrypt)])
      break
    }
  }

  return out
}
function encryptStart (self, data, decrypt) {
  var len = data.length
  var out = xor(data, self._cache)
  self._cache = self._cache.slice(len)
  self._prev = Buffer.concat([self._prev, decrypt ? data : out])
  return out
}

}).call(this,require("buffer").Buffer)

},{"buffer":152,"buffer-xor":172}],167:[function(require,module,exports){
(function (Buffer){
function encryptByte (self, byteParam, decrypt) {
  var pad
  var i = -1
  var len = 8
  var out = 0
  var bit, value
  while (++i < len) {
    pad = self._cipher.encryptBlock(self._prev)
    bit = (byteParam & (1 << (7 - i))) ? 0x80 : 0
    value = pad[0] ^ bit
    out += ((value & 0x80) >> (i % 8))
    self._prev = shiftIn(self._prev, decrypt ? bit : value)
  }
  return out
}
exports.encrypt = function (self, chunk, decrypt) {
  var len = chunk.length
  var out = new Buffer(len)
  var i = -1
  while (++i < len) {
    out[i] = encryptByte(self, chunk[i], decrypt)
  }
  return out
}
function shiftIn (buffer, value) {
  var len = buffer.length
  var i = -1
  var out = new Buffer(buffer.length)
  buffer = Buffer.concat([buffer, new Buffer([value])])
  while (++i < len) {
    out[i] = buffer[i] << 1 | buffer[i + 1] >> (7)
  }
  return out
}

}).call(this,require("buffer").Buffer)

},{"buffer":152}],168:[function(require,module,exports){
(function (Buffer){
function encryptByte (self, byteParam, decrypt) {
  var pad = self._cipher.encryptBlock(self._prev)
  var out = pad[0] ^ byteParam
  self._prev = Buffer.concat([self._prev.slice(1), new Buffer([decrypt ? byteParam : out])])
  return out
}
exports.encrypt = function (self, chunk, decrypt) {
  var len = chunk.length
  var out = new Buffer(len)
  var i = -1
  while (++i < len) {
    out[i] = encryptByte(self, chunk[i], decrypt)
  }
  return out
}

}).call(this,require("buffer").Buffer)

},{"buffer":152}],169:[function(require,module,exports){
(function (Buffer){
var xor = require('buffer-xor')

function incr32 (iv) {
  var len = iv.length
  var item
  while (len--) {
    item = iv.readUInt8(len)
    if (item === 255) {
      iv.writeUInt8(0, len)
    } else {
      item++
      iv.writeUInt8(item, len)
      break
    }
  }
}

function getBlock (self) {
  var out = self._cipher.encryptBlock(self._prev)
  incr32(self._prev)
  return out
}

exports.encrypt = function (self, chunk) {
  while (self._cache.length < chunk.length) {
    self._cache = Buffer.concat([self._cache, getBlock(self)])
  }
  var pad = self._cache.slice(0, chunk.length)
  self._cache = self._cache.slice(chunk.length)
  return xor(chunk, pad)
}

}).call(this,require("buffer").Buffer)

},{"buffer":152,"buffer-xor":172}],170:[function(require,module,exports){
exports.encrypt = function (self, block) {
  return self._cipher.encryptBlock(block)
}
exports.decrypt = function (self, block) {
  return self._cipher.decryptBlock(block)
}

},{}],171:[function(require,module,exports){
(function (Buffer){
var xor = require('buffer-xor')

function getBlock (self) {
  self._prev = self._cipher.encryptBlock(self._prev)
  return self._prev
}

exports.encrypt = function (self, chunk) {
  while (self._cache.length < chunk.length) {
    self._cache = Buffer.concat([self._cache, getBlock(self)])
  }

  var pad = self._cache.slice(0, chunk.length)
  self._cache = self._cache.slice(chunk.length)
  return xor(chunk, pad)
}

}).call(this,require("buffer").Buffer)

},{"buffer":152,"buffer-xor":172}],172:[function(require,module,exports){
(function (Buffer){
module.exports = function xor (a, b) {
  var length = Math.min(a.length, b.length)
  var buffer = new Buffer(length)

  for (var i = 0; i < length; ++i) {
    buffer[i] = a[i] ^ b[i]
  }

  return buffer
}

}).call(this,require("buffer").Buffer)

},{"buffer":152}],173:[function(require,module,exports){
(function (Buffer){
var Transform = require('stream').Transform
var inherits = require('inherits')
var StringDecoder = require('string_decoder').StringDecoder
module.exports = CipherBase
inherits(CipherBase, Transform)
function CipherBase (hashMode) {
  Transform.call(this)
  this.hashMode = typeof hashMode === 'string'
  if (this.hashMode) {
    this[hashMode] = this._finalOrDigest
  } else {
    this.final = this._finalOrDigest
  }
  this._decoder = null
  this._encoding = null
}
CipherBase.prototype.update = function (data, inputEnc, outputEnc) {
  if (typeof data === 'string') {
    data = new Buffer(data, inputEnc)
  }
  var outData = this._update(data)
  if (this.hashMode) {
    return this
  }
  if (outputEnc) {
    outData = this._toString(outData, outputEnc)
  }
  return outData
}

CipherBase.prototype.setAutoPadding = function () {}

CipherBase.prototype.getAuthTag = function () {
  throw new Error('trying to get auth tag in unsupported state')
}

CipherBase.prototype.setAuthTag = function () {
  throw new Error('trying to set auth tag in unsupported state')
}

CipherBase.prototype.setAAD = function () {
  throw new Error('trying to set aad in unsupported state')
}

CipherBase.prototype._transform = function (data, _, next) {
  var err
  try {
    if (this.hashMode) {
      this._update(data)
    } else {
      this.push(this._update(data))
    }
  } catch (e) {
    err = e
  } finally {
    next(err)
  }
}
CipherBase.prototype._flush = function (done) {
  var err
  try {
    this.push(this._final())
  } catch (e) {
    err = e
  } finally {
    done(err)
  }
}
CipherBase.prototype._finalOrDigest = function (outputEnc) {
  var outData = this._final() || new Buffer('')
  if (outputEnc) {
    outData = this._toString(outData, outputEnc, true)
  }
  return outData
}

CipherBase.prototype._toString = function (value, enc, final) {
  if (!this._decoder) {
    this._decoder = new StringDecoder(enc)
    this._encoding = enc
  }
  if (this._encoding !== enc) {
    throw new Error('can\'t switch encodings')
  }
  var out = this._decoder.write(value)
  if (final) {
    out += this._decoder.end()
  }
  return out
}

}).call(this,require("buffer").Buffer)

},{"buffer":152,"inherits":349,"stream":366,"string_decoder":367}],174:[function(require,module,exports){
(function (Buffer){
var aes = require('./aes')
var Transform = require('cipher-base')
var inherits = require('inherits')

inherits(StreamCipher, Transform)
module.exports = StreamCipher
function StreamCipher (mode, key, iv, decrypt) {
  if (!(this instanceof StreamCipher)) {
    return new StreamCipher(mode, key, iv)
  }
  Transform.call(this)
  this._cipher = new aes.AES(key)
  this._prev = new Buffer(iv.length)
  this._cache = new Buffer('')
  this._secCache = new Buffer('')
  this._decrypt = decrypt
  iv.copy(this._prev)
  this._mode = mode
}
StreamCipher.prototype._update = function (chunk) {
  return this._mode.encrypt(this, chunk, this._decrypt)
}
StreamCipher.prototype._final = function () {
  this._cipher.scrub()
}

}).call(this,require("buffer").Buffer)

},{"./aes":158,"buffer":152,"cipher-base":173,"inherits":349}],175:[function(require,module,exports){
(function (Buffer){
var CipherBase = require('cipher-base')
var des = require('des.js')
var inherits = require('inherits')

var modes = {
  'des-ede3-cbc': des.CBC.instantiate(des.EDE),
  'des-ede3': des.EDE,
  'des-ede-cbc': des.CBC.instantiate(des.EDE),
  'des-ede': des.EDE,
  'des-cbc': des.CBC.instantiate(des.DES),
  'des-ecb': des.DES
}
modes.des = modes['des-cbc']
modes.des3 = modes['des-ede3-cbc']
module.exports = DES
inherits(DES, CipherBase)
function DES (opts) {
  CipherBase.call(this)
  var modeName = opts.mode.toLowerCase()
  var mode = modes[modeName]
  var type
  if (opts.decrypt) {
    type = 'decrypt'
  } else {
    type = 'encrypt'
  }
  var key = opts.key
  if (modeName === 'des-ede' || modeName === 'des-ede-cbc') {
    key = Buffer.concat([key, key.slice(0, 8)])
  }
  var iv = opts.iv
  this._des = mode.create({
    key: key,
    iv: iv,
    type: type
  })
}
DES.prototype._update = function (data) {
  return new Buffer(this._des.update(data))
}
DES.prototype._final = function () {
  return new Buffer(this._des.final())
}

}).call(this,require("buffer").Buffer)

},{"buffer":152,"cipher-base":177,"des.js":178,"inherits":349}],176:[function(require,module,exports){
exports['des-ecb'] = {
  key: 8,
  iv: 0
}
exports['des-cbc'] = exports.des = {
  key: 8,
  iv: 8
}
exports['des-ede3-cbc'] = exports.des3 = {
  key: 24,
  iv: 8
}
exports['des-ede3'] = {
  key: 24,
  iv: 0
}
exports['des-ede-cbc'] = {
  key: 16,
  iv: 8
}
exports['des-ede'] = {
  key: 16,
  iv: 0
}

},{}],177:[function(require,module,exports){
(function (Buffer){
var Transform = require('stream').Transform
var inherits = require('inherits')
var StringDecoder = require('string_decoder').StringDecoder
module.exports = CipherBase
inherits(CipherBase, Transform)
function CipherBase (hashMode) {
  Transform.call(this)
  this.hashMode = typeof hashMode === 'string'
  if (this.hashMode) {
    this[hashMode] = this._finalOrDigest
  } else {
    this.final = this._finalOrDigest
  }
  this._decoder = null
  this._encoding = null
}
CipherBase.prototype.update = function (data, inputEnc, outputEnc) {
  if (typeof data === 'string') {
    data = new Buffer(data, inputEnc)
  }
  var outData = this._update(data)
  if (this.hashMode) {
    return this
  }
  if (outputEnc) {
    outData = this._toString(outData, outputEnc)
  }
  return outData
}

CipherBase.prototype.setAutoPadding = function () {}

CipherBase.prototype.getAuthTag = function () {
  throw new Error('trying to get auth tag in unsupported state')
}

CipherBase.prototype.setAuthTag = function () {
  throw new Error('trying to set auth tag in unsupported state')
}

CipherBase.prototype.setAAD = function () {
  throw new Error('trying to set aad in unsupported state')
}

CipherBase.prototype._transform = function (data, _, next) {
  var err
  try {
    if (this.hashMode) {
      this._update(data)
    } else {
      this.push(this._update(data))
    }
  } catch (e) {
    err = e
  } finally {
    next(err)
  }
}
CipherBase.prototype._flush = function (done) {
  var err
  try {
    this.push(this._final())
  } catch (e) {
    err = e
  } finally {
    done(err)
  }
}
CipherBase.prototype._finalOrDigest = function (outputEnc) {
  var outData = this._final() || new Buffer('')
  if (outputEnc) {
    outData = this._toString(outData, outputEnc, true)
  }
  return outData
}

CipherBase.prototype._toString = function (value, enc, final) {
  if (!this._decoder) {
    this._decoder = new StringDecoder(enc)
    this._encoding = enc
  }
  if (this._encoding !== enc) {
    throw new Error('can\'t switch encodings')
  }
  var out = this._decoder.write(value)
  if (final) {
    out += this._decoder.end()
  }
  return out
}

}).call(this,require("buffer").Buffer)

},{"buffer":152,"inherits":349,"stream":366,"string_decoder":367}],178:[function(require,module,exports){
'use strict';

exports.utils = require('./des/utils');
exports.Cipher = require('./des/cipher');
exports.DES = require('./des/des');
exports.CBC = require('./des/cbc');
exports.EDE = require('./des/ede');

},{"./des/cbc":179,"./des/cipher":180,"./des/des":181,"./des/ede":182,"./des/utils":183}],179:[function(require,module,exports){
'use strict';

var assert = require('minimalistic-assert');
var inherits = require('inherits');

var proto = {};

function CBCState(iv) {
  assert.equal(iv.length, 8, 'Invalid IV length');

  this.iv = new Array(8);
  for (var i = 0; i < this.iv.length; i++)
    this.iv[i] = iv[i];
}

function instantiate(Base) {
  function CBC(options) {
    Base.call(this, options);
    this._cbcInit();
  }
  inherits(CBC, Base);

  var keys = Object.keys(proto);
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    CBC.prototype[key] = proto[key];
  }

  CBC.create = function create(options) {
    return new CBC(options);
  };

  return CBC;
}

exports.instantiate = instantiate;

proto._cbcInit = function _cbcInit() {
  var state = new CBCState(this.options.iv);
  this._cbcState = state;
};

proto._update = function _update(inp, inOff, out, outOff) {
  var state = this._cbcState;
  var superProto = this.constructor.super_.prototype;

  var iv = state.iv;
  if (this.type === 'encrypt') {
    for (var i = 0; i < this.blockSize; i++)
      iv[i] ^= inp[inOff + i];

    superProto._update.call(this, iv, 0, out, outOff);

    for (var i = 0; i < this.blockSize; i++)
      iv[i] = out[outOff + i];
  } else {
    superProto._update.call(this, inp, inOff, out, outOff);

    for (var i = 0; i < this.blockSize; i++)
      out[outOff + i] ^= iv[i];

    for (var i = 0; i < this.blockSize; i++)
      iv[i] = inp[inOff + i];
  }
};

},{"inherits":349,"minimalistic-assert":184}],180:[function(require,module,exports){
'use strict';

var assert = require('minimalistic-assert');

function Cipher(options) {
  this.options = options;

  this.type = this.options.type;
  this.blockSize = 8;
  this._init();

  this.buffer = new Array(this.blockSize);
  this.bufferOff = 0;
}
module.exports = Cipher;

Cipher.prototype._init = function _init() {
  // Might be overrided
};

Cipher.prototype.update = function update(data) {
  if (data.length === 0)
    return [];

  if (this.type === 'decrypt')
    return this._updateDecrypt(data);
  else
    return this._updateEncrypt(data);
};

Cipher.prototype._buffer = function _buffer(data, off) {
  // Append data to buffer
  var min = Math.min(this.buffer.length - this.bufferOff, data.length - off);
  for (var i = 0; i < min; i++)
    this.buffer[this.bufferOff + i] = data[off + i];
  this.bufferOff += min;

  // Shift next
  return min;
};

Cipher.prototype._flushBuffer = function _flushBuffer(out, off) {
  this._update(this.buffer, 0, out, off);
  this.bufferOff = 0;
  return this.blockSize;
};

Cipher.prototype._updateEncrypt = function _updateEncrypt(data) {
  var inputOff = 0;
  var outputOff = 0;

  var count = ((this.bufferOff + data.length) / this.blockSize) | 0;
  var out = new Array(count * this.blockSize);

  if (this.bufferOff !== 0) {
    inputOff += this._buffer(data, inputOff);

    if (this.bufferOff === this.buffer.length)
      outputOff += this._flushBuffer(out, outputOff);
  }

  // Write blocks
  var max = data.length - ((data.length - inputOff) % this.blockSize);
  for (; inputOff < max; inputOff += this.blockSize) {
    this._update(data, inputOff, out, outputOff);
    outputOff += this.blockSize;
  }

  // Queue rest
  for (; inputOff < data.length; inputOff++, this.bufferOff++)
    this.buffer[this.bufferOff] = data[inputOff];

  return out;
};

Cipher.prototype._updateDecrypt = function _updateDecrypt(data) {
  var inputOff = 0;
  var outputOff = 0;

  var count = Math.ceil((this.bufferOff + data.length) / this.blockSize) - 1;
  var out = new Array(count * this.blockSize);

  // TODO(indutny): optimize it, this is far from optimal
  for (; count > 0; count--) {
    inputOff += this._buffer(data, inputOff);
    outputOff += this._flushBuffer(out, outputOff);
  }

  // Buffer rest of the input
  inputOff += this._buffer(data, inputOff);

  return out;
};

Cipher.prototype.final = function final(buffer) {
  var first;
  if (buffer)
    first = this.update(buffer);

  var last;
  if (this.type === 'encrypt')
    last = this._finalEncrypt();
  else
    last = this._finalDecrypt();

  if (first)
    return first.concat(last);
  else
    return last;
};

Cipher.prototype._pad = function _pad(buffer, off) {
  if (off === 0)
    return false;

  while (off < buffer.length)
    buffer[off++] = 0;

  return true;
};

Cipher.prototype._finalEncrypt = function _finalEncrypt() {
  if (!this._pad(this.buffer, this.bufferOff))
    return [];

  var out = new Array(this.blockSize);
  this._update(this.buffer, 0, out, 0);
  return out;
};

Cipher.prototype._unpad = function _unpad(buffer) {
  return buffer;
};

Cipher.prototype._finalDecrypt = function _finalDecrypt() {
  assert.equal(this.bufferOff, this.blockSize, 'Not enough data to decrypt');
  var out = new Array(this.blockSize);
  this._flushBuffer(out, 0);

  return this._unpad(out);
};

},{"minimalistic-assert":184}],181:[function(require,module,exports){
'use strict';

var assert = require('minimalistic-assert');
var inherits = require('inherits');

var des = require('../des');
var utils = des.utils;
var Cipher = des.Cipher;

function DESState() {
  this.tmp = new Array(2);
  this.keys = null;
}

function DES(options) {
  Cipher.call(this, options);

  var state = new DESState();
  this._desState = state;

  this.deriveKeys(state, options.key);
}
inherits(DES, Cipher);
module.exports = DES;

DES.create = function create(options) {
  return new DES(options);
};

var shiftTable = [
  1, 1, 2, 2, 2, 2, 2, 2,
  1, 2, 2, 2, 2, 2, 2, 1
];

DES.prototype.deriveKeys = function deriveKeys(state, key) {
  state.keys = new Array(16 * 2);

  assert.equal(key.length, this.blockSize, 'Invalid key length');

  var kL = utils.readUInt32BE(key, 0);
  var kR = utils.readUInt32BE(key, 4);

  utils.pc1(kL, kR, state.tmp, 0);
  kL = state.tmp[0];
  kR = state.tmp[1];
  for (var i = 0; i < state.keys.length; i += 2) {
    var shift = shiftTable[i >>> 1];
    kL = utils.r28shl(kL, shift);
    kR = utils.r28shl(kR, shift);
    utils.pc2(kL, kR, state.keys, i);
  }
};

DES.prototype._update = function _update(inp, inOff, out, outOff) {
  var state = this._desState;

  var l = utils.readUInt32BE(inp, inOff);
  var r = utils.readUInt32BE(inp, inOff + 4);

  // Initial Permutation
  utils.ip(l, r, state.tmp, 0);
  l = state.tmp[0];
  r = state.tmp[1];

  if (this.type === 'encrypt')
    this._encrypt(state, l, r, state.tmp, 0);
  else
    this._decrypt(state, l, r, state.tmp, 0);

  l = state.tmp[0];
  r = state.tmp[1];

  utils.writeUInt32BE(out, l, outOff);
  utils.writeUInt32BE(out, r, outOff + 4);
};

DES.prototype._pad = function _pad(buffer, off) {
  var value = buffer.length - off;
  for (var i = off; i < buffer.length; i++)
    buffer[i] = value;

  return true;
};

DES.prototype._unpad = function _unpad(buffer) {
  var pad = buffer[buffer.length - 1];
  for (var i = buffer.length - pad; i < buffer.length; i++)
    assert.equal(buffer[i], pad);

  return buffer.slice(0, buffer.length - pad);
};

DES.prototype._encrypt = function _encrypt(state, lStart, rStart, out, off) {
  var l = lStart;
  var r = rStart;

  // Apply f() x16 times
  for (var i = 0; i < state.keys.length; i += 2) {
    var keyL = state.keys[i];
    var keyR = state.keys[i + 1];

    // f(r, k)
    utils.expand(r, state.tmp, 0);

    keyL ^= state.tmp[0];
    keyR ^= state.tmp[1];
    var s = utils.substitute(keyL, keyR);
    var f = utils.permute(s);

    var t = r;
    r = (l ^ f) >>> 0;
    l = t;
  }

  // Reverse Initial Permutation
  utils.rip(r, l, out, off);
};

DES.prototype._decrypt = function _decrypt(state, lStart, rStart, out, off) {
  var l = rStart;
  var r = lStart;

  // Apply f() x16 times
  for (var i = state.keys.length - 2; i >= 0; i -= 2) {
    var keyL = state.keys[i];
    var keyR = state.keys[i + 1];

    // f(r, k)
    utils.expand(l, state.tmp, 0);

    keyL ^= state.tmp[0];
    keyR ^= state.tmp[1];
    var s = utils.substitute(keyL, keyR);
    var f = utils.permute(s);

    var t = l;
    l = (r ^ f) >>> 0;
    r = t;
  }

  // Reverse Initial Permutation
  utils.rip(l, r, out, off);
};

},{"../des":178,"inherits":349,"minimalistic-assert":184}],182:[function(require,module,exports){
'use strict';

var assert = require('minimalistic-assert');
var inherits = require('inherits');

var des = require('../des');
var Cipher = des.Cipher;
var DES = des.DES;

function EDEState(type, key) {
  assert.equal(key.length, 24, 'Invalid key length');

  var k1 = key.slice(0, 8);
  var k2 = key.slice(8, 16);
  var k3 = key.slice(16, 24);

  if (type === 'encrypt') {
    this.ciphers = [
      DES.create({ type: 'encrypt', key: k1 }),
      DES.create({ type: 'decrypt', key: k2 }),
      DES.create({ type: 'encrypt', key: k3 })
    ];
  } else {
    this.ciphers = [
      DES.create({ type: 'decrypt', key: k3 }),
      DES.create({ type: 'encrypt', key: k2 }),
      DES.create({ type: 'decrypt', key: k1 })
    ];
  }
}

function EDE(options) {
  Cipher.call(this, options);

  var state = new EDEState(this.type, this.options.key);
  this._edeState = state;
}
inherits(EDE, Cipher);

module.exports = EDE;

EDE.create = function create(options) {
  return new EDE(options);
};

EDE.prototype._update = function _update(inp, inOff, out, outOff) {
  var state = this._edeState;

  state.ciphers[0]._update(inp, inOff, out, outOff);
  state.ciphers[1]._update(out, outOff, out, outOff);
  state.ciphers[2]._update(out, outOff, out, outOff);
};

EDE.prototype._pad = DES.prototype._pad;
EDE.prototype._unpad = DES.prototype._unpad;

},{"../des":178,"inherits":349,"minimalistic-assert":184}],183:[function(require,module,exports){
'use strict';

exports.readUInt32BE = function readUInt32BE(bytes, off) {
  var res =  (bytes[0 + off] << 24) |
             (bytes[1 + off] << 16) |
             (bytes[2 + off] << 8) |
             bytes[3 + off];
  return res >>> 0;
};

exports.writeUInt32BE = function writeUInt32BE(bytes, value, off) {
  bytes[0 + off] = value >>> 24;
  bytes[1 + off] = (value >>> 16) & 0xff;
  bytes[2 + off] = (value >>> 8) & 0xff;
  bytes[3 + off] = value & 0xff;
};

exports.ip = function ip(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  for (var i = 6; i >= 0; i -= 2) {
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inR >>> (j + i)) & 1;
    }
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inL >>> (j + i)) & 1;
    }
  }

  for (var i = 6; i >= 0; i -= 2) {
    for (var j = 1; j <= 25; j += 8) {
      outR <<= 1;
      outR |= (inR >>> (j + i)) & 1;
    }
    for (var j = 1; j <= 25; j += 8) {
      outR <<= 1;
      outR |= (inL >>> (j + i)) & 1;
    }
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.rip = function rip(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  for (var i = 0; i < 4; i++) {
    for (var j = 24; j >= 0; j -= 8) {
      outL <<= 1;
      outL |= (inR >>> (j + i)) & 1;
      outL <<= 1;
      outL |= (inL >>> (j + i)) & 1;
    }
  }
  for (var i = 4; i < 8; i++) {
    for (var j = 24; j >= 0; j -= 8) {
      outR <<= 1;
      outR |= (inR >>> (j + i)) & 1;
      outR <<= 1;
      outR |= (inL >>> (j + i)) & 1;
    }
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.pc1 = function pc1(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  // 7, 15, 23, 31, 39, 47, 55, 63
  // 6, 14, 22, 30, 39, 47, 55, 63
  // 5, 13, 21, 29, 39, 47, 55, 63
  // 4, 12, 20, 28
  for (var i = 7; i >= 5; i--) {
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inR >> (j + i)) & 1;
    }
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inL >> (j + i)) & 1;
    }
  }
  for (var j = 0; j <= 24; j += 8) {
    outL <<= 1;
    outL |= (inR >> (j + i)) & 1;
  }

  // 1, 9, 17, 25, 33, 41, 49, 57
  // 2, 10, 18, 26, 34, 42, 50, 58
  // 3, 11, 19, 27, 35, 43, 51, 59
  // 36, 44, 52, 60
  for (var i = 1; i <= 3; i++) {
    for (var j = 0; j <= 24; j += 8) {
      outR <<= 1;
      outR |= (inR >> (j + i)) & 1;
    }
    for (var j = 0; j <= 24; j += 8) {
      outR <<= 1;
      outR |= (inL >> (j + i)) & 1;
    }
  }
  for (var j = 0; j <= 24; j += 8) {
    outR <<= 1;
    outR |= (inL >> (j + i)) & 1;
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.r28shl = function r28shl(num, shift) {
  return ((num << shift) & 0xfffffff) | (num >>> (28 - shift));
};

var pc2table = [
  // inL => outL
  14, 11, 17, 4, 27, 23, 25, 0,
  13, 22, 7, 18, 5, 9, 16, 24,
  2, 20, 12, 21, 1, 8, 15, 26,

  // inR => outR
  15, 4, 25, 19, 9, 1, 26, 16,
  5, 11, 23, 8, 12, 7, 17, 0,
  22, 3, 10, 14, 6, 20, 27, 24
];

exports.pc2 = function pc2(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  var len = pc2table.length >>> 1;
  for (var i = 0; i < len; i++) {
    outL <<= 1;
    outL |= (inL >>> pc2table[i]) & 0x1;
  }
  for (var i = len; i < pc2table.length; i++) {
    outR <<= 1;
    outR |= (inR >>> pc2table[i]) & 0x1;
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.expand = function expand(r, out, off) {
  var outL = 0;
  var outR = 0;

  outL = ((r & 1) << 5) | (r >>> 27);
  for (var i = 23; i >= 15; i -= 4) {
    outL <<= 6;
    outL |= (r >>> i) & 0x3f;
  }
  for (var i = 11; i >= 3; i -= 4) {
    outR |= (r >>> i) & 0x3f;
    outR <<= 6;
  }
  outR |= ((r & 0x1f) << 1) | (r >>> 31);

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

var sTable = [
  14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1,
  3, 10, 10, 6, 6, 12, 12, 11, 5, 9, 9, 5, 0, 3, 7, 8,
  4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7,
  15, 5, 12, 11, 9, 3, 7, 14, 3, 10, 10, 0, 5, 6, 0, 13,

  15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14,
  9, 12, 7, 0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5,
  0, 13, 14, 8, 7, 10, 11, 1, 10, 3, 4, 15, 13, 4, 1, 2,
  5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14, 15, 9,

  10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5, 10,
  1, 2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1,
  13, 1, 6, 10, 4, 13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7,
  11, 4, 1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7, 12,

  7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6, 15, 9, 0, 10, 3,
  1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9,
  10, 3, 6, 15, 9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8,
  15, 9, 1, 4, 3, 5, 14, 11, 5, 12, 2, 7, 8, 2, 4, 14,

  2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1,
  8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14, 8, 9, 6,
  4, 11, 2, 8, 1, 12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13,
  15, 6, 9, 15, 12, 0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3,

  12, 10, 1, 15, 10, 4, 15, 2, 9, 7, 2, 12, 6, 9, 8, 5,
  0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11, 8,
  9, 4, 14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10,
  7, 11, 0, 14, 4, 1, 10, 7, 1, 6, 13, 0, 11, 8, 6, 13,

  4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1, 13, 10,
  3, 14, 12, 3, 9, 5, 7, 12, 5, 2, 10, 15, 6, 8, 1, 6,
  1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10, 14, 7,
  10, 9, 15, 5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12,

  13, 1, 2, 15, 8, 13, 4, 8, 6, 10, 15, 3, 11, 7, 1, 4,
  10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2,
  7, 2, 11, 1, 4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13,
  0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11
];

exports.substitute = function substitute(inL, inR) {
  var out = 0;
  for (var i = 0; i < 4; i++) {
    var b = (inL >>> (18 - i * 6)) & 0x3f;
    var sb = sTable[i * 0x40 + b];

    out <<= 4;
    out |= sb;
  }
  for (var i = 0; i < 4; i++) {
    var b = (inR >>> (18 - i * 6)) & 0x3f;
    var sb = sTable[4 * 0x40 + i * 0x40 + b];

    out <<= 4;
    out |= sb;
  }
  return out >>> 0;
};

var permuteTable = [
  16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22,
  30, 24, 8, 18, 0, 5, 29, 23, 13, 19, 2, 26, 10, 21, 28, 7
];

exports.permute = function permute(num) {
  var out = 0;
  for (var i = 0; i < permuteTable.length; i++) {
    out <<= 1;
    out |= (num >>> permuteTable[i]) & 0x1;
  }
  return out >>> 0;
};

exports.padSplit = function padSplit(num, size, group) {
  var str = num.toString(2);
  while (str.length < size)
    str = '0' + str;

  var out = [];
  for (var i = 0; i < size; i += group)
    out.push(str.slice(i, i + group));
  return out.join(' ');
};

},{}],184:[function(require,module,exports){
module.exports = assert;

function assert(val, msg) {
  if (!val)
    throw new Error(msg || 'Assertion failed');
}

assert.equal = function assertEqual(l, r, msg) {
  if (l != r)
    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));
};

},{}],185:[function(require,module,exports){
(function (Buffer){
var md5 = require('create-hash/md5')
module.exports = EVP_BytesToKey
function EVP_BytesToKey (password, salt, keyLen, ivLen) {
  if (!Buffer.isBuffer(password)) {
    password = new Buffer(password, 'binary')
  }
  if (salt && !Buffer.isBuffer(salt)) {
    salt = new Buffer(salt, 'binary')
  }
  keyLen = keyLen / 8
  ivLen = ivLen || 0
  var ki = 0
  var ii = 0
  var key = new Buffer(keyLen)
  var iv = new Buffer(ivLen)
  var addmd = 0
  var md_buf
  var i
  var bufs = []
  while (true) {
    if (addmd++ > 0) {
      bufs.push(md_buf)
    }
    bufs.push(password)
    if (salt) {
      bufs.push(salt)
    }
    md_buf = md5(Buffer.concat(bufs))
    bufs = []
    i = 0
    if (keyLen > 0) {
      while (true) {
        if (keyLen === 0) {
          break
        }
        if (i === md_buf.length) {
          break
        }
        key[ki++] = md_buf[i]
        keyLen--
        i++
      }
    }
    if (ivLen > 0 && i !== md_buf.length) {
      while (true) {
        if (ivLen === 0) {
          break
        }
        if (i === md_buf.length) {
          break
        }
        iv[ii++] = md_buf[i]
        ivLen--
        i++
      }
    }
    if (keyLen === 0 && ivLen === 0) {
      break
    }
  }
  for (i = 0; i < md_buf.length; i++) {
    md_buf[i] = 0
  }
  return {
    key: key,
    iv: iv
  }
}

}).call(this,require("buffer").Buffer)

},{"buffer":152,"create-hash/md5":282}],186:[function(require,module,exports){
(function (Buffer){
'use strict'
exports['RSA-SHA224'] = exports.sha224WithRSAEncryption = {
  sign: 'rsa',
  hash: 'sha224',
  id: new Buffer('302d300d06096086480165030402040500041c', 'hex')
}
exports['RSA-SHA256'] = exports.sha256WithRSAEncryption = {
  sign: 'rsa',
  hash: 'sha256',
  id: new Buffer('3031300d060960864801650304020105000420', 'hex')
}
exports['RSA-SHA384'] = exports.sha384WithRSAEncryption = {
  sign: 'rsa',
  hash: 'sha384',
  id: new Buffer('3041300d060960864801650304020205000430', 'hex')
}
exports['RSA-SHA512'] = exports.sha512WithRSAEncryption = {
  sign: 'rsa',
  hash: 'sha512',
  id: new Buffer('3051300d060960864801650304020305000440', 'hex')
}
exports['RSA-SHA1'] = {
  sign: 'rsa',
  hash: 'sha1',
  id: new Buffer('3021300906052b0e03021a05000414', 'hex')
}
exports['ecdsa-with-SHA1'] = {
  sign: 'ecdsa',
  hash: 'sha1',
  id: new Buffer('', 'hex')
}

exports.DSA = exports['DSA-SHA1'] = exports['DSA-SHA'] = {
  sign: 'dsa',
  hash: 'sha1',
  id: new Buffer('', 'hex')
}
exports['DSA-SHA224'] = exports['DSA-WITH-SHA224'] = {
  sign: 'dsa',
  hash: 'sha224',
  id: new Buffer('', 'hex')
}
exports['DSA-SHA256'] = exports['DSA-WITH-SHA256'] = {
  sign: 'dsa',
  hash: 'sha256',
  id: new Buffer('', 'hex')
}
exports['DSA-SHA384'] = exports['DSA-WITH-SHA384'] = {
  sign: 'dsa',
  hash: 'sha384',
  id: new Buffer('', 'hex')
}
exports['DSA-SHA512'] = exports['DSA-WITH-SHA512'] = {
  sign: 'dsa',
  hash: 'sha512',
  id: new Buffer('', 'hex')
}
exports['DSA-RIPEMD160'] = {
  sign: 'dsa',
  hash: 'rmd160',
  id: new Buffer('', 'hex')
}
exports['RSA-RIPEMD160'] = exports.ripemd160WithRSA = {
  sign: 'rsa',
  hash: 'rmd160',
  id: new Buffer('3021300906052b2403020105000414', 'hex')
}
exports['RSA-MD5'] = exports.md5WithRSAEncryption = {
  sign: 'rsa',
  hash: 'md5',
  id: new Buffer('3020300c06082a864886f70d020505000410', 'hex')
}

}).call(this,require("buffer").Buffer)

},{"buffer":152}],187:[function(require,module,exports){
(function (Buffer){
var _algos = require('./algos')
var createHash = require('create-hash')
var inherits = require('inherits')
var sign = require('./sign')
var stream = require('stream')
var verify = require('./verify')

var algos = {}
Object.keys(_algos).forEach(function (key) {
  algos[key] = algos[key.toLowerCase()] = _algos[key]
})

function Sign (algorithm) {
  stream.Writable.call(this)

  var data = algos[algorithm]
  if (!data) {
    throw new Error('Unknown message digest')
  }

  this._hashType = data.hash
  this._hash = createHash(data.hash)
  this._tag = data.id
  this._signType = data.sign
}
inherits(Sign, stream.Writable)

Sign.prototype._write = function _write (data, _, done) {
  this._hash.update(data)
  done()
}

Sign.prototype.update = function update (data, enc) {
  if (typeof data === 'string') {
    data = new Buffer(data, enc)
  }

  this._hash.update(data)
  return this
}

Sign.prototype.sign = function signMethod (key, enc) {
  this.end()
  var hash = this._hash.digest()
  var sig = sign(Buffer.concat([this._tag, hash]), key, this._hashType, this._signType)

  return enc ? sig.toString(enc) : sig
}

function Verify (algorithm) {
  stream.Writable.call(this)

  var data = algos[algorithm]
  if (!data) {
    throw new Error('Unknown message digest')
  }

  this._hash = createHash(data.hash)
  this._tag = data.id
  this._signType = data.sign
}
inherits(Verify, stream.Writable)

Verify.prototype._write = function _write (data, _, done) {
  this._hash.update(data)

  done()
}

Verify.prototype.update = function update (data, enc) {
  if (typeof data === 'string') {
    data = new Buffer(data, enc)
  }

  this._hash.update(data)
  return this
}

Verify.prototype.verify = function verifyMethod (key, sig, enc) {
  if (typeof sig === 'string') {
    sig = new Buffer(sig, enc)
  }

  this.end()
  var hash = this._hash.digest()

  return verify(sig, Buffer.concat([this._tag, hash]), key, this._signType)
}

function createSign (algorithm) {
  return new Sign(algorithm)
}

function createVerify (algorithm) {
  return new Verify(algorithm)
}

module.exports = {
  Sign: createSign,
  Verify: createVerify,
  createSign: createSign,
  createVerify: createVerify
}

}).call(this,require("buffer").Buffer)

},{"./algos":186,"./sign":252,"./verify":253,"buffer":152,"create-hash":280,"inherits":349,"stream":366}],188:[function(require,module,exports){
'use strict'
exports['1.3.132.0.10'] = 'secp256k1'

exports['1.3.132.0.33'] = 'p224'

exports['1.2.840.10045.3.1.1'] = 'p192'

exports['1.2.840.10045.3.1.7'] = 'p256'

exports['1.3.132.0.34'] = 'p384'

exports['1.3.132.0.35'] = 'p521'

},{}],189:[function(require,module,exports){
(function (module, exports) {

'use strict';

// Utils

function assert(val, msg) {
  if (!val)
    throw new Error(msg || 'Assertion failed');
}

// Could use `inherits` module, but don't want to move from single file
// architecture yet.
function inherits(ctor, superCtor) {
  ctor.super_ = superCtor;
  var TempCtor = function () {};
  TempCtor.prototype = superCtor.prototype;
  ctor.prototype = new TempCtor();
  ctor.prototype.constructor = ctor;
}

// BN

function BN(number, base, endian) {
  // May be `new BN(bn)` ?
  if (number !== null &&
      typeof number === 'object' &&
      Array.isArray(number.words)) {
    return number;
  }

  this.negative = 0;
  this.words = null;
  this.length = 0;

  // Reduction context
  this.red = null;

  if (number !== null) {
    if (base === 'le' || base === 'be') {
      endian = base;
      base = 10;
    }

    this._init(number || 0, base || 10, endian || 'be');
  }
}
if (typeof module === 'object')
  module.exports = BN;
else
  exports.BN = BN;

BN.BN = BN;
BN.wordSize = 26;

BN.max = function max(left, right) {
  if (left.cmp(right) > 0)
    return left;
  else
    return right;
};

BN.min = function min(left, right) {
  if (left.cmp(right) < 0)
    return left;
  else
    return right;
};

BN.prototype._init = function init(number, base, endian) {
  if (typeof number === 'number') {
    return this._initNumber(number, base, endian);
  } else if (typeof number === 'object') {
    return this._initArray(number, base, endian);
  }
  if (base === 'hex')
    base = 16;
  assert(base === (base | 0) && base >= 2 && base <= 36);

  number = number.toString().replace(/\s+/g, '');
  var start = 0;
  if (number[0] === '-')
    start++;

  if (base === 16)
    this._parseHex(number, start);
  else
    this._parseBase(number, base, start);

  if (number[0] === '-')
    this.negative = 1;

  this.strip();

  if (endian !== 'le')
    return;

  this._initArray(this.toArray(), base, endian);
};

BN.prototype._initNumber = function _initNumber(number, base, endian) {
  if (number < 0) {
    this.negative = 1;
    number = -number;
  }
  if (number < 0x4000000) {
    this.words = [ number & 0x3ffffff ];
    this.length = 1;
  } else if (number < 0x10000000000000) {
    this.words = [
      number & 0x3ffffff,
      (number / 0x4000000) & 0x3ffffff
    ];
    this.length = 2;
  } else {
    assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
    this.words = [
      number & 0x3ffffff,
      (number / 0x4000000) & 0x3ffffff,
      1
    ];
    this.length = 3;
  }

  if (endian !== 'le')
    return;

  // Reverse the bytes
  this._initArray(this.toArray(), base, endian);
};

BN.prototype._initArray = function _initArray(number, base, endian) {
  // Perhaps a Uint8Array
  assert(typeof number.length === 'number');
  if (number.length <= 0) {
    this.words = [ 0 ];
    this.length = 1;
    return this;
  }

  this.length = Math.ceil(number.length / 3);
  this.words = new Array(this.length);
  for (var i = 0; i < this.length; i++)
    this.words[i] = 0;

  var off = 0;
  if (endian === 'be') {
    for (var i = number.length - 1, j = 0; i >= 0; i -= 3) {
      var w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
      this.words[j] |= (w << off) & 0x3ffffff;
      this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
      off += 24;
      if (off >= 26) {
        off -= 26;
        j++;
      }
    }
  } else if (endian === 'le') {
    for (var i = 0, j = 0; i < number.length; i += 3) {
      var w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
      this.words[j] |= (w << off) & 0x3ffffff;
      this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
      off += 24;
      if (off >= 26) {
        off -= 26;
        j++;
      }
    }
  }
  return this.strip();
};

function parseHex(str, start, end) {
  var r = 0;
  var len = Math.min(str.length, end);
  for (var i = start; i < len; i++) {
    var c = str.charCodeAt(i) - 48;

    r <<= 4;

    // 'a' - 'f'
    if (c >= 49 && c <= 54)
      r |= c - 49 + 0xa;

    // 'A' - 'F'
    else if (c >= 17 && c <= 22)
      r |= c - 17 + 0xa;

    // '0' - '9'
    else
      r |= c & 0xf;
  }
  return r;
}

BN.prototype._parseHex = function _parseHex(number, start) {
  // Create possibly bigger array to ensure that it fits the number
  this.length = Math.ceil((number.length - start) / 6);
  this.words = new Array(this.length);
  for (var i = 0; i < this.length; i++)
    this.words[i] = 0;

  // Scan 24-bit chunks and add them to the number
  var off = 0;
  for (var i = number.length - 6, j = 0; i >= start; i -= 6) {
    var w = parseHex(number, i, i + 6);
    this.words[j] |= (w << off) & 0x3ffffff;
    this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
    off += 24;
    if (off >= 26) {
      off -= 26;
      j++;
    }
  }
  if (i + 6 !== start) {
    var w = parseHex(number, start, i + 6);
    this.words[j] |= (w << off) & 0x3ffffff;
    this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
  }
  this.strip();
};

function parseBase(str, start, end, mul) {
  var r = 0;
  var len = Math.min(str.length, end);
  for (var i = start; i < len; i++) {
    var c = str.charCodeAt(i) - 48;

    r *= mul;

    // 'a'
    if (c >= 49)
      r += c - 49 + 0xa;

    // 'A'
    else if (c >= 17)
      r += c - 17 + 0xa;

    // '0' - '9'
    else
      r += c;
  }
  return r;
}

BN.prototype._parseBase = function _parseBase(number, base, start) {
  // Initialize as zero
  this.words = [ 0 ];
  this.length = 1;

  // Find length of limb in base
  for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base)
    limbLen++;
  limbLen--;
  limbPow = (limbPow / base) | 0;

  var total = number.length - start;
  var mod = total % limbLen;
  var end = Math.min(total, total - mod) + start;

  var word = 0;
  for (var i = start; i < end; i += limbLen) {
    word = parseBase(number, i, i + limbLen, base);

    this.imuln(limbPow);
    if (this.words[0] + word < 0x4000000)
      this.words[0] += word;
    else
      this._iaddn(word);
  }

  if (mod !== 0) {
    var pow = 1;
    var word = parseBase(number, i, number.length, base);

    for (var i = 0; i < mod; i++)
      pow *= base;
    this.imuln(pow);
    if (this.words[0] + word < 0x4000000)
      this.words[0] += word;
    else
      this._iaddn(word);
  }
};

BN.prototype.copy = function copy(dest) {
  dest.words = new Array(this.length);
  for (var i = 0; i < this.length; i++)
    dest.words[i] = this.words[i];
  dest.length = this.length;
  dest.negative = this.negative;
  dest.red = this.red;
};

BN.prototype.clone = function clone() {
  var r = new BN(null);
  this.copy(r);
  return r;
};

// Remove leading `0` from `this`
BN.prototype.strip = function strip() {
  while (this.length > 1 && this.words[this.length - 1] === 0)
    this.length--;
  return this._normSign();
};

BN.prototype._normSign = function _normSign() {
  // -0 = 0
  if (this.length === 1 && this.words[0] === 0)
    this.negative = 0;
  return this;
};

BN.prototype.inspect = function inspect() {
  return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
};

/*

var zeros = [];
var groupSizes = [];
var groupBases = [];

var s = '';
var i = -1;
while (++i < BN.wordSize) {
  zeros[i] = s;
  s += '0';
}
groupSizes[0] = 0;
groupSizes[1] = 0;
groupBases[0] = 0;
groupBases[1] = 0;
var base = 2 - 1;
while (++base < 36 + 1) {
  var groupSize = 0;
  var groupBase = 1;
  while (groupBase < (1 << BN.wordSize) / base) {
    groupBase *= base;
    groupSize += 1;
  }
  groupSizes[base] = groupSize;
  groupBases[base] = groupBase;
}

*/

var zeros = [
  '',
  '0',
  '00',
  '000',
  '0000',
  '00000',
  '000000',
  '0000000',
  '00000000',
  '000000000',
  '0000000000',
  '00000000000',
  '000000000000',
  '0000000000000',
  '00000000000000',
  '000000000000000',
  '0000000000000000',
  '00000000000000000',
  '000000000000000000',
  '0000000000000000000',
  '00000000000000000000',
  '000000000000000000000',
  '0000000000000000000000',
  '00000000000000000000000',
  '000000000000000000000000',
  '0000000000000000000000000'
];

var groupSizes = [
  0, 0,
  25, 16, 12, 11, 10, 9, 8,
  8, 7, 7, 7, 7, 6, 6,
  6, 6, 6, 6, 6, 5, 5,
  5, 5, 5, 5, 5, 5, 5,
  5, 5, 5, 5, 5, 5, 5
];

var groupBases = [
  0, 0,
  33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
  43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
  16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
  6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
  24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
];

BN.prototype.toString = function toString(base, padding) {
  base = base || 10;
  var padding = padding | 0 || 1;
  if (base === 16 || base === 'hex') {
    var out = '';
    var off = 0;
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = this.words[i];
      var word = (((w << off) | carry) & 0xffffff).toString(16);
      carry = (w >>> (24 - off)) & 0xffffff;
      if (carry !== 0 || i !== this.length - 1)
        out = zeros[6 - word.length] + word + out;
      else
        out = word + out;
      off += 2;
      if (off >= 26) {
        off -= 26;
        i--;
      }
    }
    if (carry !== 0)
      out = carry.toString(16) + out;
    while (out.length % padding !== 0)
      out = '0' + out;
    if (this.negative !== 0)
      out = '-' + out;
    return out;
  } else if (base === (base | 0) && base >= 2 && base <= 36) {
    // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
    var groupSize = groupSizes[base];
    // var groupBase = Math.pow(base, groupSize);
    var groupBase = groupBases[base];
    var out = '';
    var c = this.clone();
    c.negative = 0;
    while (c.cmpn(0) !== 0) {
      var r = c.modn(groupBase).toString(base);
      c = c.idivn(groupBase);

      if (c.cmpn(0) !== 0)
        out = zeros[groupSize - r.length] + r + out;
      else
        out = r + out;
    }
    if (this.cmpn(0) === 0)
      out = '0' + out;
    while (out.length % padding !== 0)
      out = '0' + out;
    if (this.negative !== 0)
      out = '-' + out;
    return out;
  } else {
    assert(false, 'Base should be between 2 and 36');
  }
};

BN.prototype.toNumber = function toNumber() {
  assert(this.bitLength() <= 53, 'Number can only safely store up to 53 bits');
  return parseInt(this.toString(), 10);
};

BN.prototype.toJSON = function toJSON() {
  return this.toString(16);
};

BN.prototype.toArray = function toArray(endian, length) {
  var byteLength = this.byteLength();
  var reqLength = length || byteLength;
  assert(byteLength <= reqLength, 'byte array longer than desired length');

  this.strip();
  var littleEndian = endian === 'le';
  var res = new Array(reqLength);

  var q = this.clone();
  if (!littleEndian) {
    // Assume big-endian
    for (var i = 0; i < reqLength - byteLength; i++)
      res[i] = 0;
    for (i = 0; q.cmpn(0) !== 0; i++) {
      var b = q.andln(0xff);
      q.iushrn(8);

      res[reqLength - i - 1] = b;
    }
  } else {
    for (var i = 0; q.cmpn(0) !== 0; i++) {
      var b = q.andln(0xff);
      q.iushrn(8);

      res[i] = b;
    }
    for (; i < reqLength; i++)
      res[i] = 0;
  }

  return res;
};

if (Math.clz32) {
  BN.prototype._countBits = function _countBits(w) {
    return 32 - Math.clz32(w);
  };
} else {
  BN.prototype._countBits = function _countBits(w) {
    var t = w;
    var r = 0;
    if (t >= 0x1000) {
      r += 13;
      t >>>= 13;
    }
    if (t >= 0x40) {
      r += 7;
      t >>>= 7;
    }
    if (t >= 0x8) {
      r += 4;
      t >>>= 4;
    }
    if (t >= 0x02) {
      r += 2;
      t >>>= 2;
    }
    return r + t;
  };
}

BN.prototype._zeroBits = function _zeroBits(w) {
  // Short-cut
  if (w === 0)
    return 26;

  var t = w;
  var r = 0;
  if ((t & 0x1fff) === 0) {
    r += 13;
    t >>>= 13;
  }
  if ((t & 0x7f) === 0) {
    r += 7;
    t >>>= 7;
  }
  if ((t & 0xf) === 0) {
    r += 4;
    t >>>= 4;
  }
  if ((t & 0x3) === 0) {
    r += 2;
    t >>>= 2;
  }
  if ((t & 0x1) === 0)
    r++;
  return r;
};

// Return number of used bits in a BN
BN.prototype.bitLength = function bitLength() {
  var hi = 0;
  var w = this.words[this.length - 1];
  var hi = this._countBits(w);
  return (this.length - 1) * 26 + hi;
};

function toBitArray(num) {
  var w = new Array(num.bitLength());

  for (var bit = 0; bit < w.length; bit++) {
    var off = (bit / 26) | 0;
    var wbit = bit % 26;

    w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;
  }

  return w;
}

// Number of trailing zero bits
BN.prototype.zeroBits = function zeroBits() {
  if (this.cmpn(0) === 0)
    return 0;

  var r = 0;
  for (var i = 0; i < this.length; i++) {
    var b = this._zeroBits(this.words[i]);
    r += b;
    if (b !== 26)
      break;
  }
  return r;
};

BN.prototype.byteLength = function byteLength() {
  return Math.ceil(this.bitLength() / 8);
};

BN.prototype.isNeg = function isNeg() {
  return this.negative !== 0;
};

// Return negative clone of `this`
BN.prototype.neg = function neg() {
  if (this.cmpn(0) === 0)
    return this.clone();

  var r = this.clone();
  r.negative = this.negative ^ 1;
  return r;
};

BN.prototype.ineg = function ineg() {
  this.negative ^= 1;
  return this;
};

// Or `num` with `this` in-place
BN.prototype.iuor = function iuor(num) {
  while (this.length < num.length)
    this.words[this.length++] = 0;

  for (var i = 0; i < num.length; i++)
    this.words[i] = this.words[i] | num.words[i];

  return this.strip();
};

BN.prototype.ior = function ior(num) {
  assert((this.negative | num.negative) === 0);
  return this.iuor(num);
};


// Or `num` with `this`
BN.prototype.or = function or(num) {
  if (this.length > num.length)
    return this.clone().ior(num);
  else
    return num.clone().ior(this);
};

BN.prototype.uor = function uor(num) {
  if (this.length > num.length)
    return this.clone().iuor(num);
  else
    return num.clone().iuor(this);
};


// And `num` with `this` in-place
BN.prototype.iuand = function iuand(num) {
  // b = min-length(num, this)
  var b;
  if (this.length > num.length)
    b = num;
  else
    b = this;

  for (var i = 0; i < b.length; i++)
    this.words[i] = this.words[i] & num.words[i];

  this.length = b.length;

  return this.strip();
};

BN.prototype.iand = function iand(num) {
  assert((this.negative | num.negative) === 0);
  return this.iuand(num);
};


// And `num` with `this`
BN.prototype.and = function and(num) {
  if (this.length > num.length)
    return this.clone().iand(num);
  else
    return num.clone().iand(this);
};

BN.prototype.uand = function uand(num) {
  if (this.length > num.length)
    return this.clone().iuand(num);
  else
    return num.clone().iuand(this);
};


// Xor `num` with `this` in-place
BN.prototype.iuxor = function iuxor(num) {
  // a.length > b.length
  var a;
  var b;
  if (this.length > num.length) {
    a = this;
    b = num;
  } else {
    a = num;
    b = this;
  }

  for (var i = 0; i < b.length; i++)
    this.words[i] = a.words[i] ^ b.words[i];

  if (this !== a)
    for (; i < a.length; i++)
      this.words[i] = a.words[i];

  this.length = a.length;

  return this.strip();
};

BN.prototype.ixor = function ixor(num) {
  assert((this.negative | num.negative) === 0);
  return this.iuxor(num);
};


// Xor `num` with `this`
BN.prototype.xor = function xor(num) {
  if (this.length > num.length)
    return this.clone().ixor(num);
  else
    return num.clone().ixor(this);
};

BN.prototype.uxor = function uxor(num) {
  if (this.length > num.length)
    return this.clone().iuxor(num);
  else
    return num.clone().iuxor(this);
};


// Set `bit` of `this`
BN.prototype.setn = function setn(bit, val) {
  assert(typeof bit === 'number' && bit >= 0);

  var off = (bit / 26) | 0;
  var wbit = bit % 26;

  while (this.length <= off)
    this.words[this.length++] = 0;

  if (val)
    this.words[off] = this.words[off] | (1 << wbit);
  else
    this.words[off] = this.words[off] & ~(1 << wbit);

  return this.strip();
};


// Add `num` to `this` in-place
BN.prototype.iadd = function iadd(num) {
  // negative + positive
  if (this.negative !== 0 && num.negative === 0) {
    this.negative = 0;
    var r = this.isub(num);
    this.negative ^= 1;
    return this._normSign();

  // positive + negative
  } else if (this.negative === 0 && num.negative !== 0) {
    num.negative = 0;
    var r = this.isub(num);
    num.negative = 1;
    return r._normSign();
  }

  // a.length > b.length
  var a;
  var b;
  if (this.length > num.length) {
    a = this;
    b = num;
  } else {
    a = num;
    b = this;
  }

  var carry = 0;
  for (var i = 0; i < b.length; i++) {
    var r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
    this.words[i] = r & 0x3ffffff;
    carry = r >>> 26;
  }
  for (; carry !== 0 && i < a.length; i++) {
    var r = (a.words[i] | 0) + carry;
    this.words[i] = r & 0x3ffffff;
    carry = r >>> 26;
  }

  this.length = a.length;
  if (carry !== 0) {
    this.words[this.length] = carry;
    this.length++;
  // Copy the rest of the words
  } else if (a !== this) {
    for (; i < a.length; i++)
      this.words[i] = a.words[i];
  }

  return this;
};

// Add `num` to `this`
BN.prototype.add = function add(num) {
  if (num.negative !== 0 && this.negative === 0) {
    num.negative = 0;
    var res = this.sub(num);
    num.negative ^= 1;
    return res;
  } else if (num.negative === 0 && this.negative !== 0) {
    this.negative = 0;
    var res = num.sub(this);
    this.negative = 1;
    return res;
  }

  if (this.length > num.length)
    return this.clone().iadd(num);
  else
    return num.clone().iadd(this);
};

// Subtract `num` from `this` in-place
BN.prototype.isub = function isub(num) {
  // this - (-num) = this + num
  if (num.negative !== 0) {
    num.negative = 0;
    var r = this.iadd(num);
    num.negative = 1;
    return r._normSign();

  // -this - num = -(this + num)
  } else if (this.negative !== 0) {
    this.negative = 0;
    this.iadd(num);
    this.negative = 1;
    return this._normSign();
  }

  // At this point both numbers are positive
  var cmp = this.cmp(num);

  // Optimization - zeroify
  if (cmp === 0) {
    this.negative = 0;
    this.length = 1;
    this.words[0] = 0;
    return this;
  }

  // a > b
  var a;
  var b;
  if (cmp > 0) {
    a = this;
    b = num;
  } else {
    a = num;
    b = this;
  }

  var carry = 0;
  for (var i = 0; i < b.length; i++) {
    var r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
    carry = r >> 26;
    this.words[i] = r & 0x3ffffff;
  }
  for (; carry !== 0 && i < a.length; i++) {
    var r = (a.words[i] | 0) + carry;
    carry = r >> 26;
    this.words[i] = r & 0x3ffffff;
  }

  // Copy rest of the words
  if (carry === 0 && i < a.length && a !== this)
    for (; i < a.length; i++)
      this.words[i] = a.words[i];
  this.length = Math.max(this.length, i);

  if (a !== this)
    this.negative = 1;

  return this.strip();
};

// Subtract `num` from `this`
BN.prototype.sub = function sub(num) {
  return this.clone().isub(num);
};

/*
// NOTE: This could be potentionally used to generate loop-less multiplications
function _genCombMulTo(alen, blen) {
  var len = alen + blen - 1;
  var src = [
    'var a = self.words;',
    'var b = num.words;',
    'var o = out.words;',
    'var c = 0;',
    'var lo;',
    'var mid;',
    'var hi;'
  ];
  for (var i = 0; i < alen; i++) {
    src.push('var a' + i + ' = a[' + i + '] | 0;');
    src.push('var al' + i + ' = a' + i + ' & 0x1fff;');
    src.push('var ah' + i + ' = a' + i + ' >>> 13;');
  }
  for (var i = 0; i < blen; i++) {
    src.push('var b' + i + ' = b[' + i + '] | 0;');
    src.push('var bl' + i + ' = b' + i + ' & 0x1fff;');
    src.push('var bh' + i + ' = b' + i + ' >>> 13;');
  }
  src.push('');
  src.push('out.length = ' + len + ';');

  for (var k = 0; k < len; k++) {
    var minJ = Math.max(0, k - alen + 1);
    var maxJ = Math.min(k, blen - 1);

    src.push('\/* k = ' + k + ' *\/');
    src.push('var w' + k + ' = c;');
    src.push('c = 0;');
    for (var j = minJ; j <= maxJ; j++) {
      var i = k - j;

      src.push('lo = Math.imul(al' + i + ', bl' + j + ');');
      src.push('mid = Math.imul(al' + i + ', bh' + j + ');');
      src.push('mid = (mid + Math.imul(ah' + i + ', bl' + j + ')) | 0;');
      src.push('hi = Math.imul(ah' + i + ', bh' + j + ');');

      src.push('w' + k + ' = (w' + k + ' + lo) | 0;');
      src.push('w' + k + ' = (w' + k + ' + ((mid & 0x1fff) << 13)) | 0;');
      src.push('c = (c + hi) | 0;');
      src.push('c = (c + (mid >>> 13)) | 0;');
      src.push('c = (c + (w' + k + ' >>> 26)) | 0;');
      src.push('w' + k + ' &= 0x3ffffff;');
    }
  }
  // Store in separate step for better memory access
  for (var k = 0; k < len; k++)
    src.push('o[' + k + '] = w' + k + ';');
  src.push('if (c !== 0) {',
           '  o[' + k + '] = c;',
           '  out.length++;',
           '}',
           'return out;');

  return src.join('\n');
}
console.log(_genCombMulTo(10, 10));
*/

function smallMulTo(self, num, out) {
  out.negative = num.negative ^ self.negative;
  var len = (self.length + num.length) | 0;
  out.length = len;
  len = (len - 1) | 0;

  // Peel one iteration (compiler can't do it, because of code complexity)
  var a = self.words[0] | 0;
  var b = num.words[0] | 0;
  var r = a * b;

  var lo = r & 0x3ffffff;
  var carry = (r / 0x4000000) | 0;
  out.words[0] = lo;

  for (var k = 1; k < len; k++) {
    // Sum all words with the same `i + j = k` and accumulate `ncarry`,
    // note that ncarry could be >= 0x3ffffff
    var ncarry = carry >>> 26;
    var rword = carry & 0x3ffffff;
    var maxJ = Math.min(k, num.length - 1);
    for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
      var i = (k - j) | 0;
      var a = self.words[i] | 0;
      var b = num.words[j] | 0;
      var r = a * b;

      var lo = r & 0x3ffffff;
      ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
      lo = (lo + rword) | 0;
      rword = lo & 0x3ffffff;
      ncarry = (ncarry + (lo >>> 26)) | 0;
    }
    out.words[k] = rword | 0;
    carry = ncarry | 0;
  }
  if (carry !== 0) {
    out.words[k] = carry | 0;
  } else {
    out.length--;
  }

  return out.strip();
}

// TODO(indutny): it may be reasonable to omit it for users who don't need
// to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
// multiplication (like elliptic secp256k1).
var comb10MulTo = function comb10MulTo(self, num, out) {
  var a = self.words;
  var b = num.words;
  var o = out.words;
  var c = 0;
  var lo;
  var mid;
  var hi;
  var a0 = a[0] | 0;
  var al0 = a0 & 0x1fff;
  var ah0 = a0 >>> 13;
  var a1 = a[1] | 0;
  var al1 = a1 & 0x1fff;
  var ah1 = a1 >>> 13;
  var a2 = a[2] | 0;
  var al2 = a2 & 0x1fff;
  var ah2 = a2 >>> 13;
  var a3 = a[3] | 0;
  var al3 = a3 & 0x1fff;
  var ah3 = a3 >>> 13;
  var a4 = a[4] | 0;
  var al4 = a4 & 0x1fff;
  var ah4 = a4 >>> 13;
  var a5 = a[5] | 0;
  var al5 = a5 & 0x1fff;
  var ah5 = a5 >>> 13;
  var a6 = a[6] | 0;
  var al6 = a6 & 0x1fff;
  var ah6 = a6 >>> 13;
  var a7 = a[7] | 0;
  var al7 = a7 & 0x1fff;
  var ah7 = a7 >>> 13;
  var a8 = a[8] | 0;
  var al8 = a8 & 0x1fff;
  var ah8 = a8 >>> 13;
  var a9 = a[9] | 0;
  var al9 = a9 & 0x1fff;
  var ah9 = a9 >>> 13;
  var b0 = b[0] | 0;
  var bl0 = b0 & 0x1fff;
  var bh0 = b0 >>> 13;
  var b1 = b[1] | 0;
  var bl1 = b1 & 0x1fff;
  var bh1 = b1 >>> 13;
  var b2 = b[2] | 0;
  var bl2 = b2 & 0x1fff;
  var bh2 = b2 >>> 13;
  var b3 = b[3] | 0;
  var bl3 = b3 & 0x1fff;
  var bh3 = b3 >>> 13;
  var b4 = b[4] | 0;
  var bl4 = b4 & 0x1fff;
  var bh4 = b4 >>> 13;
  var b5 = b[5] | 0;
  var bl5 = b5 & 0x1fff;
  var bh5 = b5 >>> 13;
  var b6 = b[6] | 0;
  var bl6 = b6 & 0x1fff;
  var bh6 = b6 >>> 13;
  var b7 = b[7] | 0;
  var bl7 = b7 & 0x1fff;
  var bh7 = b7 >>> 13;
  var b8 = b[8] | 0;
  var bl8 = b8 & 0x1fff;
  var bh8 = b8 >>> 13;
  var b9 = b[9] | 0;
  var bl9 = b9 & 0x1fff;
  var bh9 = b9 >>> 13;

  out.length = 19;
  /* k = 0 */
  var w0 = c;
  c = 0;
  lo = Math.imul(al0, bl0);
  mid = Math.imul(al0, bh0);
  mid = (mid + Math.imul(ah0, bl0)) | 0;
  hi = Math.imul(ah0, bh0);
  w0 = (w0 + lo) | 0;
  w0 = (w0 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w0 >>> 26)) | 0;
  w0 &= 0x3ffffff;
  /* k = 1 */
  var w1 = c;
  c = 0;
  lo = Math.imul(al1, bl0);
  mid = Math.imul(al1, bh0);
  mid = (mid + Math.imul(ah1, bl0)) | 0;
  hi = Math.imul(ah1, bh0);
  w1 = (w1 + lo) | 0;
  w1 = (w1 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w1 >>> 26)) | 0;
  w1 &= 0x3ffffff;
  lo = Math.imul(al0, bl1);
  mid = Math.imul(al0, bh1);
  mid = (mid + Math.imul(ah0, bl1)) | 0;
  hi = Math.imul(ah0, bh1);
  w1 = (w1 + lo) | 0;
  w1 = (w1 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w1 >>> 26)) | 0;
  w1 &= 0x3ffffff;
  /* k = 2 */
  var w2 = c;
  c = 0;
  lo = Math.imul(al2, bl0);
  mid = Math.imul(al2, bh0);
  mid = (mid + Math.imul(ah2, bl0)) | 0;
  hi = Math.imul(ah2, bh0);
  w2 = (w2 + lo) | 0;
  w2 = (w2 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w2 >>> 26)) | 0;
  w2 &= 0x3ffffff;
  lo = Math.imul(al1, bl1);
  mid = Math.imul(al1, bh1);
  mid = (mid + Math.imul(ah1, bl1)) | 0;
  hi = Math.imul(ah1, bh1);
  w2 = (w2 + lo) | 0;
  w2 = (w2 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w2 >>> 26)) | 0;
  w2 &= 0x3ffffff;
  lo = Math.imul(al0, bl2);
  mid = Math.imul(al0, bh2);
  mid = (mid + Math.imul(ah0, bl2)) | 0;
  hi = Math.imul(ah0, bh2);
  w2 = (w2 + lo) | 0;
  w2 = (w2 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w2 >>> 26)) | 0;
  w2 &= 0x3ffffff;
  /* k = 3 */
  var w3 = c;
  c = 0;
  lo = Math.imul(al3, bl0);
  mid = Math.imul(al3, bh0);
  mid = (mid + Math.imul(ah3, bl0)) | 0;
  hi = Math.imul(ah3, bh0);
  w3 = (w3 + lo) | 0;
  w3 = (w3 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w3 >>> 26)) | 0;
  w3 &= 0x3ffffff;
  lo = Math.imul(al2, bl1);
  mid = Math.imul(al2, bh1);
  mid = (mid + Math.imul(ah2, bl1)) | 0;
  hi = Math.imul(ah2, bh1);
  w3 = (w3 + lo) | 0;
  w3 = (w3 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w3 >>> 26)) | 0;
  w3 &= 0x3ffffff;
  lo = Math.imul(al1, bl2);
  mid = Math.imul(al1, bh2);
  mid = (mid + Math.imul(ah1, bl2)) | 0;
  hi = Math.imul(ah1, bh2);
  w3 = (w3 + lo) | 0;
  w3 = (w3 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w3 >>> 26)) | 0;
  w3 &= 0x3ffffff;
  lo = Math.imul(al0, bl3);
  mid = Math.imul(al0, bh3);
  mid = (mid + Math.imul(ah0, bl3)) | 0;
  hi = Math.imul(ah0, bh3);
  w3 = (w3 + lo) | 0;
  w3 = (w3 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w3 >>> 26)) | 0;
  w3 &= 0x3ffffff;
  /* k = 4 */
  var w4 = c;
  c = 0;
  lo = Math.imul(al4, bl0);
  mid = Math.imul(al4, bh0);
  mid = (mid + Math.imul(ah4, bl0)) | 0;
  hi = Math.imul(ah4, bh0);
  w4 = (w4 + lo) | 0;
  w4 = (w4 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w4 >>> 26)) | 0;
  w4 &= 0x3ffffff;
  lo = Math.imul(al3, bl1);
  mid = Math.imul(al3, bh1);
  mid = (mid + Math.imul(ah3, bl1)) | 0;
  hi = Math.imul(ah3, bh1);
  w4 = (w4 + lo) | 0;
  w4 = (w4 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w4 >>> 26)) | 0;
  w4 &= 0x3ffffff;
  lo = Math.imul(al2, bl2);
  mid = Math.imul(al2, bh2);
  mid = (mid + Math.imul(ah2, bl2)) | 0;
  hi = Math.imul(ah2, bh2);
  w4 = (w4 + lo) | 0;
  w4 = (w4 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w4 >>> 26)) | 0;
  w4 &= 0x3ffffff;
  lo = Math.imul(al1, bl3);
  mid = Math.imul(al1, bh3);
  mid = (mid + Math.imul(ah1, bl3)) | 0;
  hi = Math.imul(ah1, bh3);
  w4 = (w4 + lo) | 0;
  w4 = (w4 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w4 >>> 26)) | 0;
  w4 &= 0x3ffffff;
  lo = Math.imul(al0, bl4);
  mid = Math.imul(al0, bh4);
  mid = (mid + Math.imul(ah0, bl4)) | 0;
  hi = Math.imul(ah0, bh4);
  w4 = (w4 + lo) | 0;
  w4 = (w4 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w4 >>> 26)) | 0;
  w4 &= 0x3ffffff;
  /* k = 5 */
  var w5 = c;
  c = 0;
  lo = Math.imul(al5, bl0);
  mid = Math.imul(al5, bh0);
  mid = (mid + Math.imul(ah5, bl0)) | 0;
  hi = Math.imul(ah5, bh0);
  w5 = (w5 + lo) | 0;
  w5 = (w5 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w5 >>> 26)) | 0;
  w5 &= 0x3ffffff;
  lo = Math.imul(al4, bl1);
  mid = Math.imul(al4, bh1);
  mid = (mid + Math.imul(ah4, bl1)) | 0;
  hi = Math.imul(ah4, bh1);
  w5 = (w5 + lo) | 0;
  w5 = (w5 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w5 >>> 26)) | 0;
  w5 &= 0x3ffffff;
  lo = Math.imul(al3, bl2);
  mid = Math.imul(al3, bh2);
  mid = (mid + Math.imul(ah3, bl2)) | 0;
  hi = Math.imul(ah3, bh2);
  w5 = (w5 + lo) | 0;
  w5 = (w5 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w5 >>> 26)) | 0;
  w5 &= 0x3ffffff;
  lo = Math.imul(al2, bl3);
  mid = Math.imul(al2, bh3);
  mid = (mid + Math.imul(ah2, bl3)) | 0;
  hi = Math.imul(ah2, bh3);
  w5 = (w5 + lo) | 0;
  w5 = (w5 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w5 >>> 26)) | 0;
  w5 &= 0x3ffffff;
  lo = Math.imul(al1, bl4);
  mid = Math.imul(al1, bh4);
  mid = (mid + Math.imul(ah1, bl4)) | 0;
  hi = Math.imul(ah1, bh4);
  w5 = (w5 + lo) | 0;
  w5 = (w5 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w5 >>> 26)) | 0;
  w5 &= 0x3ffffff;
  lo = Math.imul(al0, bl5);
  mid = Math.imul(al0, bh5);
  mid = (mid + Math.imul(ah0, bl5)) | 0;
  hi = Math.imul(ah0, bh5);
  w5 = (w5 + lo) | 0;
  w5 = (w5 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w5 >>> 26)) | 0;
  w5 &= 0x3ffffff;
  /* k = 6 */
  var w6 = c;
  c = 0;
  lo = Math.imul(al6, bl0);
  mid = Math.imul(al6, bh0);
  mid = (mid + Math.imul(ah6, bl0)) | 0;
  hi = Math.imul(ah6, bh0);
  w6 = (w6 + lo) | 0;
  w6 = (w6 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w6 >>> 26)) | 0;
  w6 &= 0x3ffffff;
  lo = Math.imul(al5, bl1);
  mid = Math.imul(al5, bh1);
  mid = (mid + Math.imul(ah5, bl1)) | 0;
  hi = Math.imul(ah5, bh1);
  w6 = (w6 + lo) | 0;
  w6 = (w6 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w6 >>> 26)) | 0;
  w6 &= 0x3ffffff;
  lo = Math.imul(al4, bl2);
  mid = Math.imul(al4, bh2);
  mid = (mid + Math.imul(ah4, bl2)) | 0;
  hi = Math.imul(ah4, bh2);
  w6 = (w6 + lo) | 0;
  w6 = (w6 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w6 >>> 26)) | 0;
  w6 &= 0x3ffffff;
  lo = Math.imul(al3, bl3);
  mid = Math.imul(al3, bh3);
  mid = (mid + Math.imul(ah3, bl3)) | 0;
  hi = Math.imul(ah3, bh3);
  w6 = (w6 + lo) | 0;
  w6 = (w6 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w6 >>> 26)) | 0;
  w6 &= 0x3ffffff;
  lo = Math.imul(al2, bl4);
  mid = Math.imul(al2, bh4);
  mid = (mid + Math.imul(ah2, bl4)) | 0;
  hi = Math.imul(ah2, bh4);
  w6 = (w6 + lo) | 0;
  w6 = (w6 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w6 >>> 26)) | 0;
  w6 &= 0x3ffffff;
  lo = Math.imul(al1, bl5);
  mid = Math.imul(al1, bh5);
  mid = (mid + Math.imul(ah1, bl5)) | 0;
  hi = Math.imul(ah1, bh5);
  w6 = (w6 + lo) | 0;
  w6 = (w6 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w6 >>> 26)) | 0;
  w6 &= 0x3ffffff;
  lo = Math.imul(al0, bl6);
  mid = Math.imul(al0, bh6);
  mid = (mid + Math.imul(ah0, bl6)) | 0;
  hi = Math.imul(ah0, bh6);
  w6 = (w6 + lo) | 0;
  w6 = (w6 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w6 >>> 26)) | 0;
  w6 &= 0x3ffffff;
  /* k = 7 */
  var w7 = c;
  c = 0;
  lo = Math.imul(al7, bl0);
  mid = Math.imul(al7, bh0);
  mid = (mid + Math.imul(ah7, bl0)) | 0;
  hi = Math.imul(ah7, bh0);
  w7 = (w7 + lo) | 0;
  w7 = (w7 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w7 >>> 26)) | 0;
  w7 &= 0x3ffffff;
  lo = Math.imul(al6, bl1);
  mid = Math.imul(al6, bh1);
  mid = (mid + Math.imul(ah6, bl1)) | 0;
  hi = Math.imul(ah6, bh1);
  w7 = (w7 + lo) | 0;
  w7 = (w7 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w7 >>> 26)) | 0;
  w7 &= 0x3ffffff;
  lo = Math.imul(al5, bl2);
  mid = Math.imul(al5, bh2);
  mid = (mid + Math.imul(ah5, bl2)) | 0;
  hi = Math.imul(ah5, bh2);
  w7 = (w7 + lo) | 0;
  w7 = (w7 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w7 >>> 26)) | 0;
  w7 &= 0x3ffffff;
  lo = Math.imul(al4, bl3);
  mid = Math.imul(al4, bh3);
  mid = (mid + Math.imul(ah4, bl3)) | 0;
  hi = Math.imul(ah4, bh3);
  w7 = (w7 + lo) | 0;
  w7 = (w7 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w7 >>> 26)) | 0;
  w7 &= 0x3ffffff;
  lo = Math.imul(al3, bl4);
  mid = Math.imul(al3, bh4);
  mid = (mid + Math.imul(ah3, bl4)) | 0;
  hi = Math.imul(ah3, bh4);
  w7 = (w7 + lo) | 0;
  w7 = (w7 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w7 >>> 26)) | 0;
  w7 &= 0x3ffffff;
  lo = Math.imul(al2, bl5);
  mid = Math.imul(al2, bh5);
  mid = (mid + Math.imul(ah2, bl5)) | 0;
  hi = Math.imul(ah2, bh5);
  w7 = (w7 + lo) | 0;
  w7 = (w7 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w7 >>> 26)) | 0;
  w7 &= 0x3ffffff;
  lo = Math.imul(al1, bl6);
  mid = Math.imul(al1, bh6);
  mid = (mid + Math.imul(ah1, bl6)) | 0;
  hi = Math.imul(ah1, bh6);
  w7 = (w7 + lo) | 0;
  w7 = (w7 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w7 >>> 26)) | 0;
  w7 &= 0x3ffffff;
  lo = Math.imul(al0, bl7);
  mid = Math.imul(al0, bh7);
  mid = (mid + Math.imul(ah0, bl7)) | 0;
  hi = Math.imul(ah0, bh7);
  w7 = (w7 + lo) | 0;
  w7 = (w7 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w7 >>> 26)) | 0;
  w7 &= 0x3ffffff;
  /* k = 8 */
  var w8 = c;
  c = 0;
  lo = Math.imul(al8, bl0);
  mid = Math.imul(al8, bh0);
  mid = (mid + Math.imul(ah8, bl0)) | 0;
  hi = Math.imul(ah8, bh0);
  w8 = (w8 + lo) | 0;
  w8 = (w8 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w8 >>> 26)) | 0;
  w8 &= 0x3ffffff;
  lo = Math.imul(al7, bl1);
  mid = Math.imul(al7, bh1);
  mid = (mid + Math.imul(ah7, bl1)) | 0;
  hi = Math.imul(ah7, bh1);
  w8 = (w8 + lo) | 0;
  w8 = (w8 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w8 >>> 26)) | 0;
  w8 &= 0x3ffffff;
  lo = Math.imul(al6, bl2);
  mid = Math.imul(al6, bh2);
  mid = (mid + Math.imul(ah6, bl2)) | 0;
  hi = Math.imul(ah6, bh2);
  w8 = (w8 + lo) | 0;
  w8 = (w8 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w8 >>> 26)) | 0;
  w8 &= 0x3ffffff;
  lo = Math.imul(al5, bl3);
  mid = Math.imul(al5, bh3);
  mid = (mid + Math.imul(ah5, bl3)) | 0;
  hi = Math.imul(ah5, bh3);
  w8 = (w8 + lo) | 0;
  w8 = (w8 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w8 >>> 26)) | 0;
  w8 &= 0x3ffffff;
  lo = Math.imul(al4, bl4);
  mid = Math.imul(al4, bh4);
  mid = (mid + Math.imul(ah4, bl4)) | 0;
  hi = Math.imul(ah4, bh4);
  w8 = (w8 + lo) | 0;
  w8 = (w8 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w8 >>> 26)) | 0;
  w8 &= 0x3ffffff;
  lo = Math.imul(al3, bl5);
  mid = Math.imul(al3, bh5);
  mid = (mid + Math.imul(ah3, bl5)) | 0;
  hi = Math.imul(ah3, bh5);
  w8 = (w8 + lo) | 0;
  w8 = (w8 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w8 >>> 26)) | 0;
  w8 &= 0x3ffffff;
  lo = Math.imul(al2, bl6);
  mid = Math.imul(al2, bh6);
  mid = (mid + Math.imul(ah2, bl6)) | 0;
  hi = Math.imul(ah2, bh6);
  w8 = (w8 + lo) | 0;
  w8 = (w8 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w8 >>> 26)) | 0;
  w8 &= 0x3ffffff;
  lo = Math.imul(al1, bl7);
  mid = Math.imul(al1, bh7);
  mid = (mid + Math.imul(ah1, bl7)) | 0;
  hi = Math.imul(ah1, bh7);
  w8 = (w8 + lo) | 0;
  w8 = (w8 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w8 >>> 26)) | 0;
  w8 &= 0x3ffffff;
  lo = Math.imul(al0, bl8);
  mid = Math.imul(al0, bh8);
  mid = (mid + Math.imul(ah0, bl8)) | 0;
  hi = Math.imul(ah0, bh8);
  w8 = (w8 + lo) | 0;
  w8 = (w8 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w8 >>> 26)) | 0;
  w8 &= 0x3ffffff;
  /* k = 9 */
  var w9 = c;
  c = 0;
  lo = Math.imul(al9, bl0);
  mid = Math.imul(al9, bh0);
  mid = (mid + Math.imul(ah9, bl0)) | 0;
  hi = Math.imul(ah9, bh0);
  w9 = (w9 + lo) | 0;
  w9 = (w9 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w9 >>> 26)) | 0;
  w9 &= 0x3ffffff;
  lo = Math.imul(al8, bl1);
  mid = Math.imul(al8, bh1);
  mid = (mid + Math.imul(ah8, bl1)) | 0;
  hi = Math.imul(ah8, bh1);
  w9 = (w9 + lo) | 0;
  w9 = (w9 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w9 >>> 26)) | 0;
  w9 &= 0x3ffffff;
  lo = Math.imul(al7, bl2);
  mid = Math.imul(al7, bh2);
  mid = (mid + Math.imul(ah7, bl2)) | 0;
  hi = Math.imul(ah7, bh2);
  w9 = (w9 + lo) | 0;
  w9 = (w9 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w9 >>> 26)) | 0;
  w9 &= 0x3ffffff;
  lo = Math.imul(al6, bl3);
  mid = Math.imul(al6, bh3);
  mid = (mid + Math.imul(ah6, bl3)) | 0;
  hi = Math.imul(ah6, bh3);
  w9 = (w9 + lo) | 0;
  w9 = (w9 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w9 >>> 26)) | 0;
  w9 &= 0x3ffffff;
  lo = Math.imul(al5, bl4);
  mid = Math.imul(al5, bh4);
  mid = (mid + Math.imul(ah5, bl4)) | 0;
  hi = Math.imul(ah5, bh4);
  w9 = (w9 + lo) | 0;
  w9 = (w9 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w9 >>> 26)) | 0;
  w9 &= 0x3ffffff;
  lo = Math.imul(al4, bl5);
  mid = Math.imul(al4, bh5);
  mid = (mid + Math.imul(ah4, bl5)) | 0;
  hi = Math.imul(ah4, bh5);
  w9 = (w9 + lo) | 0;
  w9 = (w9 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w9 >>> 26)) | 0;
  w9 &= 0x3ffffff;
  lo = Math.imul(al3, bl6);
  mid = Math.imul(al3, bh6);
  mid = (mid + Math.imul(ah3, bl6)) | 0;
  hi = Math.imul(ah3, bh6);
  w9 = (w9 + lo) | 0;
  w9 = (w9 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w9 >>> 26)) | 0;
  w9 &= 0x3ffffff;
  lo = Math.imul(al2, bl7);
  mid = Math.imul(al2, bh7);
  mid = (mid + Math.imul(ah2, bl7)) | 0;
  hi = Math.imul(ah2, bh7);
  w9 = (w9 + lo) | 0;
  w9 = (w9 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w9 >>> 26)) | 0;
  w9 &= 0x3ffffff;
  lo = Math.imul(al1, bl8);
  mid = Math.imul(al1, bh8);
  mid = (mid + Math.imul(ah1, bl8)) | 0;
  hi = Math.imul(ah1, bh8);
  w9 = (w9 + lo) | 0;
  w9 = (w9 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w9 >>> 26)) | 0;
  w9 &= 0x3ffffff;
  lo = Math.imul(al0, bl9);
  mid = Math.imul(al0, bh9);
  mid = (mid + Math.imul(ah0, bl9)) | 0;
  hi = Math.imul(ah0, bh9);
  w9 = (w9 + lo) | 0;
  w9 = (w9 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w9 >>> 26)) | 0;
  w9 &= 0x3ffffff;
  /* k = 10 */
  var w10 = c;
  c = 0;
  lo = Math.imul(al9, bl1);
  mid = Math.imul(al9, bh1);
  mid = (mid + Math.imul(ah9, bl1)) | 0;
  hi = Math.imul(ah9, bh1);
  w10 = (w10 + lo) | 0;
  w10 = (w10 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w10 >>> 26)) | 0;
  w10 &= 0x3ffffff;
  lo = Math.imul(al8, bl2);
  mid = Math.imul(al8, bh2);
  mid = (mid + Math.imul(ah8, bl2)) | 0;
  hi = Math.imul(ah8, bh2);
  w10 = (w10 + lo) | 0;
  w10 = (w10 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w10 >>> 26)) | 0;
  w10 &= 0x3ffffff;
  lo = Math.imul(al7, bl3);
  mid = Math.imul(al7, bh3);
  mid = (mid + Math.imul(ah7, bl3)) | 0;
  hi = Math.imul(ah7, bh3);
  w10 = (w10 + lo) | 0;
  w10 = (w10 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w10 >>> 26)) | 0;
  w10 &= 0x3ffffff;
  lo = Math.imul(al6, bl4);
  mid = Math.imul(al6, bh4);
  mid = (mid + Math.imul(ah6, bl4)) | 0;
  hi = Math.imul(ah6, bh4);
  w10 = (w10 + lo) | 0;
  w10 = (w10 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w10 >>> 26)) | 0;
  w10 &= 0x3ffffff;
  lo = Math.imul(al5, bl5);
  mid = Math.imul(al5, bh5);
  mid = (mid + Math.imul(ah5, bl5)) | 0;
  hi = Math.imul(ah5, bh5);
  w10 = (w10 + lo) | 0;
  w10 = (w10 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w10 >>> 26)) | 0;
  w10 &= 0x3ffffff;
  lo = Math.imul(al4, bl6);
  mid = Math.imul(al4, bh6);
  mid = (mid + Math.imul(ah4, bl6)) | 0;
  hi = Math.imul(ah4, bh6);
  w10 = (w10 + lo) | 0;
  w10 = (w10 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w10 >>> 26)) | 0;
  w10 &= 0x3ffffff;
  lo = Math.imul(al3, bl7);
  mid = Math.imul(al3, bh7);
  mid = (mid + Math.imul(ah3, bl7)) | 0;
  hi = Math.imul(ah3, bh7);
  w10 = (w10 + lo) | 0;
  w10 = (w10 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w10 >>> 26)) | 0;
  w10 &= 0x3ffffff;
  lo = Math.imul(al2, bl8);
  mid = Math.imul(al2, bh8);
  mid = (mid + Math.imul(ah2, bl8)) | 0;
  hi = Math.imul(ah2, bh8);
  w10 = (w10 + lo) | 0;
  w10 = (w10 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w10 >>> 26)) | 0;
  w10 &= 0x3ffffff;
  lo = Math.imul(al1, bl9);
  mid = Math.imul(al1, bh9);
  mid = (mid + Math.imul(ah1, bl9)) | 0;
  hi = Math.imul(ah1, bh9);
  w10 = (w10 + lo) | 0;
  w10 = (w10 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w10 >>> 26)) | 0;
  w10 &= 0x3ffffff;
  /* k = 11 */
  var w11 = c;
  c = 0;
  lo = Math.imul(al9, bl2);
  mid = Math.imul(al9, bh2);
  mid = (mid + Math.imul(ah9, bl2)) | 0;
  hi = Math.imul(ah9, bh2);
  w11 = (w11 + lo) | 0;
  w11 = (w11 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w11 >>> 26)) | 0;
  w11 &= 0x3ffffff;
  lo = Math.imul(al8, bl3);
  mid = Math.imul(al8, bh3);
  mid = (mid + Math.imul(ah8, bl3)) | 0;
  hi = Math.imul(ah8, bh3);
  w11 = (w11 + lo) | 0;
  w11 = (w11 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w11 >>> 26)) | 0;
  w11 &= 0x3ffffff;
  lo = Math.imul(al7, bl4);
  mid = Math.imul(al7, bh4);
  mid = (mid + Math.imul(ah7, bl4)) | 0;
  hi = Math.imul(ah7, bh4);
  w11 = (w11 + lo) | 0;
  w11 = (w11 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w11 >>> 26)) | 0;
  w11 &= 0x3ffffff;
  lo = Math.imul(al6, bl5);
  mid = Math.imul(al6, bh5);
  mid = (mid + Math.imul(ah6, bl5)) | 0;
  hi = Math.imul(ah6, bh5);
  w11 = (w11 + lo) | 0;
  w11 = (w11 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w11 >>> 26)) | 0;
  w11 &= 0x3ffffff;
  lo = Math.imul(al5, bl6);
  mid = Math.imul(al5, bh6);
  mid = (mid + Math.imul(ah5, bl6)) | 0;
  hi = Math.imul(ah5, bh6);
  w11 = (w11 + lo) | 0;
  w11 = (w11 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w11 >>> 26)) | 0;
  w11 &= 0x3ffffff;
  lo = Math.imul(al4, bl7);
  mid = Math.imul(al4, bh7);
  mid = (mid + Math.imul(ah4, bl7)) | 0;
  hi = Math.imul(ah4, bh7);
  w11 = (w11 + lo) | 0;
  w11 = (w11 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w11 >>> 26)) | 0;
  w11 &= 0x3ffffff;
  lo = Math.imul(al3, bl8);
  mid = Math.imul(al3, bh8);
  mid = (mid + Math.imul(ah3, bl8)) | 0;
  hi = Math.imul(ah3, bh8);
  w11 = (w11 + lo) | 0;
  w11 = (w11 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w11 >>> 26)) | 0;
  w11 &= 0x3ffffff;
  lo = Math.imul(al2, bl9);
  mid = Math.imul(al2, bh9);
  mid = (mid + Math.imul(ah2, bl9)) | 0;
  hi = Math.imul(ah2, bh9);
  w11 = (w11 + lo) | 0;
  w11 = (w11 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w11 >>> 26)) | 0;
  w11 &= 0x3ffffff;
  /* k = 12 */
  var w12 = c;
  c = 0;
  lo = Math.imul(al9, bl3);
  mid = Math.imul(al9, bh3);
  mid = (mid + Math.imul(ah9, bl3)) | 0;
  hi = Math.imul(ah9, bh3);
  w12 = (w12 + lo) | 0;
  w12 = (w12 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w12 >>> 26)) | 0;
  w12 &= 0x3ffffff;
  lo = Math.imul(al8, bl4);
  mid = Math.imul(al8, bh4);
  mid = (mid + Math.imul(ah8, bl4)) | 0;
  hi = Math.imul(ah8, bh4);
  w12 = (w12 + lo) | 0;
  w12 = (w12 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w12 >>> 26)) | 0;
  w12 &= 0x3ffffff;
  lo = Math.imul(al7, bl5);
  mid = Math.imul(al7, bh5);
  mid = (mid + Math.imul(ah7, bl5)) | 0;
  hi = Math.imul(ah7, bh5);
  w12 = (w12 + lo) | 0;
  w12 = (w12 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w12 >>> 26)) | 0;
  w12 &= 0x3ffffff;
  lo = Math.imul(al6, bl6);
  mid = Math.imul(al6, bh6);
  mid = (mid + Math.imul(ah6, bl6)) | 0;
  hi = Math.imul(ah6, bh6);
  w12 = (w12 + lo) | 0;
  w12 = (w12 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w12 >>> 26)) | 0;
  w12 &= 0x3ffffff;
  lo = Math.imul(al5, bl7);
  mid = Math.imul(al5, bh7);
  mid = (mid + Math.imul(ah5, bl7)) | 0;
  hi = Math.imul(ah5, bh7);
  w12 = (w12 + lo) | 0;
  w12 = (w12 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w12 >>> 26)) | 0;
  w12 &= 0x3ffffff;
  lo = Math.imul(al4, bl8);
  mid = Math.imul(al4, bh8);
  mid = (mid + Math.imul(ah4, bl8)) | 0;
  hi = Math.imul(ah4, bh8);
  w12 = (w12 + lo) | 0;
  w12 = (w12 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w12 >>> 26)) | 0;
  w12 &= 0x3ffffff;
  lo = Math.imul(al3, bl9);
  mid = Math.imul(al3, bh9);
  mid = (mid + Math.imul(ah3, bl9)) | 0;
  hi = Math.imul(ah3, bh9);
  w12 = (w12 + lo) | 0;
  w12 = (w12 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w12 >>> 26)) | 0;
  w12 &= 0x3ffffff;
  /* k = 13 */
  var w13 = c;
  c = 0;
  lo = Math.imul(al9, bl4);
  mid = Math.imul(al9, bh4);
  mid = (mid + Math.imul(ah9, bl4)) | 0;
  hi = Math.imul(ah9, bh4);
  w13 = (w13 + lo) | 0;
  w13 = (w13 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w13 >>> 26)) | 0;
  w13 &= 0x3ffffff;
  lo = Math.imul(al8, bl5);
  mid = Math.imul(al8, bh5);
  mid = (mid + Math.imul(ah8, bl5)) | 0;
  hi = Math.imul(ah8, bh5);
  w13 = (w13 + lo) | 0;
  w13 = (w13 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w13 >>> 26)) | 0;
  w13 &= 0x3ffffff;
  lo = Math.imul(al7, bl6);
  mid = Math.imul(al7, bh6);
  mid = (mid + Math.imul(ah7, bl6)) | 0;
  hi = Math.imul(ah7, bh6);
  w13 = (w13 + lo) | 0;
  w13 = (w13 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w13 >>> 26)) | 0;
  w13 &= 0x3ffffff;
  lo = Math.imul(al6, bl7);
  mid = Math.imul(al6, bh7);
  mid = (mid + Math.imul(ah6, bl7)) | 0;
  hi = Math.imul(ah6, bh7);
  w13 = (w13 + lo) | 0;
  w13 = (w13 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w13 >>> 26)) | 0;
  w13 &= 0x3ffffff;
  lo = Math.imul(al5, bl8);
  mid = Math.imul(al5, bh8);
  mid = (mid + Math.imul(ah5, bl8)) | 0;
  hi = Math.imul(ah5, bh8);
  w13 = (w13 + lo) | 0;
  w13 = (w13 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w13 >>> 26)) | 0;
  w13 &= 0x3ffffff;
  lo = Math.imul(al4, bl9);
  mid = Math.imul(al4, bh9);
  mid = (mid + Math.imul(ah4, bl9)) | 0;
  hi = Math.imul(ah4, bh9);
  w13 = (w13 + lo) | 0;
  w13 = (w13 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w13 >>> 26)) | 0;
  w13 &= 0x3ffffff;
  /* k = 14 */
  var w14 = c;
  c = 0;
  lo = Math.imul(al9, bl5);
  mid = Math.imul(al9, bh5);
  mid = (mid + Math.imul(ah9, bl5)) | 0;
  hi = Math.imul(ah9, bh5);
  w14 = (w14 + lo) | 0;
  w14 = (w14 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w14 >>> 26)) | 0;
  w14 &= 0x3ffffff;
  lo = Math.imul(al8, bl6);
  mid = Math.imul(al8, bh6);
  mid = (mid + Math.imul(ah8, bl6)) | 0;
  hi = Math.imul(ah8, bh6);
  w14 = (w14 + lo) | 0;
  w14 = (w14 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w14 >>> 26)) | 0;
  w14 &= 0x3ffffff;
  lo = Math.imul(al7, bl7);
  mid = Math.imul(al7, bh7);
  mid = (mid + Math.imul(ah7, bl7)) | 0;
  hi = Math.imul(ah7, bh7);
  w14 = (w14 + lo) | 0;
  w14 = (w14 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w14 >>> 26)) | 0;
  w14 &= 0x3ffffff;
  lo = Math.imul(al6, bl8);
  mid = Math.imul(al6, bh8);
  mid = (mid + Math.imul(ah6, bl8)) | 0;
  hi = Math.imul(ah6, bh8);
  w14 = (w14 + lo) | 0;
  w14 = (w14 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w14 >>> 26)) | 0;
  w14 &= 0x3ffffff;
  lo = Math.imul(al5, bl9);
  mid = Math.imul(al5, bh9);
  mid = (mid + Math.imul(ah5, bl9)) | 0;
  hi = Math.imul(ah5, bh9);
  w14 = (w14 + lo) | 0;
  w14 = (w14 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w14 >>> 26)) | 0;
  w14 &= 0x3ffffff;
  /* k = 15 */
  var w15 = c;
  c = 0;
  lo = Math.imul(al9, bl6);
  mid = Math.imul(al9, bh6);
  mid = (mid + Math.imul(ah9, bl6)) | 0;
  hi = Math.imul(ah9, bh6);
  w15 = (w15 + lo) | 0;
  w15 = (w15 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w15 >>> 26)) | 0;
  w15 &= 0x3ffffff;
  lo = Math.imul(al8, bl7);
  mid = Math.imul(al8, bh7);
  mid = (mid + Math.imul(ah8, bl7)) | 0;
  hi = Math.imul(ah8, bh7);
  w15 = (w15 + lo) | 0;
  w15 = (w15 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w15 >>> 26)) | 0;
  w15 &= 0x3ffffff;
  lo = Math.imul(al7, bl8);
  mid = Math.imul(al7, bh8);
  mid = (mid + Math.imul(ah7, bl8)) | 0;
  hi = Math.imul(ah7, bh8);
  w15 = (w15 + lo) | 0;
  w15 = (w15 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w15 >>> 26)) | 0;
  w15 &= 0x3ffffff;
  lo = Math.imul(al6, bl9);
  mid = Math.imul(al6, bh9);
  mid = (mid + Math.imul(ah6, bl9)) | 0;
  hi = Math.imul(ah6, bh9);
  w15 = (w15 + lo) | 0;
  w15 = (w15 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w15 >>> 26)) | 0;
  w15 &= 0x3ffffff;
  /* k = 16 */
  var w16 = c;
  c = 0;
  lo = Math.imul(al9, bl7);
  mid = Math.imul(al9, bh7);
  mid = (mid + Math.imul(ah9, bl7)) | 0;
  hi = Math.imul(ah9, bh7);
  w16 = (w16 + lo) | 0;
  w16 = (w16 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w16 >>> 26)) | 0;
  w16 &= 0x3ffffff;
  lo = Math.imul(al8, bl8);
  mid = Math.imul(al8, bh8);
  mid = (mid + Math.imul(ah8, bl8)) | 0;
  hi = Math.imul(ah8, bh8);
  w16 = (w16 + lo) | 0;
  w16 = (w16 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w16 >>> 26)) | 0;
  w16 &= 0x3ffffff;
  lo = Math.imul(al7, bl9);
  mid = Math.imul(al7, bh9);
  mid = (mid + Math.imul(ah7, bl9)) | 0;
  hi = Math.imul(ah7, bh9);
  w16 = (w16 + lo) | 0;
  w16 = (w16 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w16 >>> 26)) | 0;
  w16 &= 0x3ffffff;
  /* k = 17 */
  var w17 = c;
  c = 0;
  lo = Math.imul(al9, bl8);
  mid = Math.imul(al9, bh8);
  mid = (mid + Math.imul(ah9, bl8)) | 0;
  hi = Math.imul(ah9, bh8);
  w17 = (w17 + lo) | 0;
  w17 = (w17 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w17 >>> 26)) | 0;
  w17 &= 0x3ffffff;
  lo = Math.imul(al8, bl9);
  mid = Math.imul(al8, bh9);
  mid = (mid + Math.imul(ah8, bl9)) | 0;
  hi = Math.imul(ah8, bh9);
  w17 = (w17 + lo) | 0;
  w17 = (w17 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w17 >>> 26)) | 0;
  w17 &= 0x3ffffff;
  /* k = 18 */
  var w18 = c;
  c = 0;
  lo = Math.imul(al9, bl9);
  mid = Math.imul(al9, bh9);
  mid = (mid + Math.imul(ah9, bl9)) | 0;
  hi = Math.imul(ah9, bh9);
  w18 = (w18 + lo) | 0;
  w18 = (w18 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w18 >>> 26)) | 0;
  w18 &= 0x3ffffff;
  o[0] = w0;
  o[1] = w1;
  o[2] = w2;
  o[3] = w3;
  o[4] = w4;
  o[5] = w5;
  o[6] = w6;
  o[7] = w7;
  o[8] = w8;
  o[9] = w9;
  o[10] = w10;
  o[11] = w11;
  o[12] = w12;
  o[13] = w13;
  o[14] = w14;
  o[15] = w15;
  o[16] = w16;
  o[17] = w17;
  o[18] = w18;
  if (c !== 0) {
    o[19] = c;
    out.length++;
  }
  return out;
};

// Polyfill comb
if (!Math.imul)
  comb10MulTo = smallMulTo;

function bigMulTo(self, num, out) {
  out.negative = num.negative ^ self.negative;
  out.length = self.length + num.length;

  var carry = 0;
  var hncarry = 0;
  for (var k = 0; k < out.length - 1; k++) {
    // Sum all words with the same `i + j = k` and accumulate `ncarry`,
    // note that ncarry could be >= 0x3ffffff
    var ncarry = hncarry;
    hncarry = 0;
    var rword = carry & 0x3ffffff;
    var maxJ = Math.min(k, num.length - 1);
    for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
      var i = k - j;
      var a = self.words[i] | 0;
      var b = num.words[j] | 0;
      var r = a * b;

      var lo = r & 0x3ffffff;
      ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
      lo = (lo + rword) | 0;
      rword = lo & 0x3ffffff;
      ncarry = (ncarry + (lo >>> 26)) | 0;

      hncarry += ncarry >>> 26;
      ncarry &= 0x3ffffff;
    }
    out.words[k] = rword;
    carry = ncarry;
    ncarry = hncarry;
  }
  if (carry !== 0) {
    out.words[k] = carry;
  } else {
    out.length--;
  }

  return out.strip();
}

function jumboMulTo(self, num, out) {
  var fftm = new FFTM();
  return fftm.mulp(self, num, out);
}

BN.prototype.mulTo = function mulTo(num, out) {
  var res;
  var len = this.length + num.length;
  if (this.length === 10 && num.length === 10)
    res = comb10MulTo(this, num, out);
  else if (len < 63)
    res = smallMulTo(this, num, out);
  else if (len < 1024)
    res = bigMulTo(this, num, out);
  else
    res = jumboMulTo(this, num, out);
  return res;
};

// Cooley-Tukey algorithm for FFT
// slightly revisited to rely on looping instead of recursion

function FFTM(x, y) {
  this.x = x;
  this.y = y;
}

FFTM.prototype.makeRBT = function makeRBT(N) {
  var t = new Array(N);
  var l = BN.prototype._countBits(N) - 1;
  for (var i = 0; i < N; i++) {
    t[i] = this.revBin(i, l, N);
  }

  return t;
};

// Returns binary-reversed representation of `x`
FFTM.prototype.revBin = function revBin(x, l, N) {
  if (x === 0 || x === N - 1)
    return x;

  var rb = 0;
  for (var i = 0; i < l; i++) {
    rb |= (x & 1) << (l - i - 1);
    x >>= 1;
  }

  return rb;
};

// Performs "tweedling" phase, therefore 'emulating'
// behaviour of the recursive algorithm
FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
  for (var i = 0; i < N; i++) {
    rtws[i] = rws[rbt[i]];
    itws[i] = iws[rbt[i]];
  }
};

FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
  this.permute(rbt, rws, iws, rtws, itws, N);

  for (var s = 1; s < N; s <<= 1) {
    var l = s << 1;

    var rtwdf = Math.cos(2 * Math.PI / l);
    var itwdf = Math.sin(2 * Math.PI / l);

    for (var p = 0; p < N; p += l) {
      var rtwdf_ = rtwdf;
      var itwdf_ = itwdf;

      for (var j = 0; j < s; j++) {
        var re = rtws[p + j];
        var ie = itws[p + j];

        var ro = rtws[p + j + s];
        var io = itws[p + j + s];

        var rx = rtwdf_ * ro - itwdf_ * io;

        io = rtwdf_ * io + itwdf_ * ro;
        ro = rx;

        rtws[p + j] = re + ro;
        itws[p + j] = ie + io;

        rtws[p + j + s] = re - ro;
        itws[p + j + s] = ie - io;

        /* jshint maxdepth : false */
        if (j !== l) {
          rx = rtwdf * rtwdf_ - itwdf * itwdf_;

          itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
          rtwdf_ = rx;
        }
      }
    }
  }
};

FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
  var N = Math.max(m, n) | 1;
  var odd = N & 1;
  var i = 0;
  for (N = N / 2 | 0; N; N = N >>> 1) {
    i++;
  }

  return 1 << i + 1 + odd;
};

FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
  if (N <= 1)
    return;

  for (var i = 0; i < N / 2; i++) {
    var t = rws[i];

    rws[i] = rws[N - i - 1];
    rws[N - i - 1] = t;

    t = iws[i];

    iws[i] = -iws[N - i - 1];
    iws[N - i - 1] = -t;
  }
};

FFTM.prototype.normalize13b = function normalize13b(ws, N) {
  var carry = 0;
  for (var i = 0; i < N / 2; i++) {
    var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
            Math.round(ws[2 * i] / N) +
            carry;

    ws[i] = w & 0x3ffffff;

    if (w < 0x4000000) {
      carry = 0;
    } else {
      carry = w / 0x4000000 | 0;
    }
  }

  return ws;
};

FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
  var carry = 0;
  for (var i = 0; i < len; i++) {
    var carry = carry + (ws[i] | 0);

    rws[2 * i]     = carry & 0x1fff; carry = carry >>> 13;
    rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
  }

  // Pad with zeroes
  for (var i = 2 * len; i < N; ++i)
    rws[i] = 0;

  assert(carry === 0);
  assert((carry & ~0x1fff) === 0);
};

FFTM.prototype.stub = function stub(N) {
  var ph = new Array(N);
  for (var i = 0; i < N; i++)
    ph[i] = 0;

  return ph;
};

FFTM.prototype.mulp = function mulp(x, y, out) {
  var N = 2 * this.guessLen13b(x.length, y.length);

  var rbt = this.makeRBT(N);

  var _ = this.stub(N);

  var rws   = new Array(N);
  var rwst  = new Array(N);
  var iwst  = new Array(N);

  var nrws  = new Array(N);
  var nrwst = new Array(N);
  var niwst = new Array(N);

  var rmws = out.words;
  rmws.length = N;

  this.convert13b(x.words, x.length, rws, N);
  this.convert13b(y.words, y.length, nrws, N);

  this.transform(rws, _, rwst, iwst, N, rbt);
  this.transform(nrws, _, nrwst, niwst, N, rbt);

  for (var i = 0; i < N; i++) {
    var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
    iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
    rwst[i] = rx;
  }

  this.conjugate(rwst, iwst, N);

  this.transform(rwst, iwst, rmws, _, N, rbt);

  this.conjugate(rmws, _, N);

  this.normalize13b(rmws, N);

  out.negative = x.negative ^ y.negative;
  out.length = x.length + y.length;
  return out.strip();
};

// Multiply `this` by `num`
BN.prototype.mul = function mul(num) {
  var out = new BN(null);
  out.words = new Array(this.length + num.length);
  return this.mulTo(num, out);
};

// Multiply employing FFT
BN.prototype.mulf = function mulf(num) {
  var out = new BN(null);
  out.words = new Array(this.length + num.length);
  return jumboMulTo(this, num, out);
};

// In-place Multiplication
BN.prototype.imul = function imul(num) {
  return this.clone().mulTo(num, this);
};

BN.prototype.imuln = function imuln(num) {
  assert(typeof num === 'number');

  // Carry
  var carry = 0;
  for (var i = 0; i < this.length; i++) {
    var w = (this.words[i] | 0) * num;
    var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
    carry >>= 26;
    carry += (w / 0x4000000) | 0;
    // NOTE: lo is 27bit maximum
    carry += lo >>> 26;
    this.words[i] = lo & 0x3ffffff;
  }

  if (carry !== 0) {
    this.words[i] = carry;
    this.length++;
  }

  return this;
};

BN.prototype.muln = function muln(num) {
  return this.clone().imuln(num);
};

// `this` * `this`
BN.prototype.sqr = function sqr() {
  return this.mul(this);
};

// `this` * `this` in-place
BN.prototype.isqr = function isqr() {
  return this.imul(this.clone());
};

// Math.pow(`this`, `num`)
BN.prototype.pow = function pow(num) {
  var w = toBitArray(num);
  if (w.length === 0)
    return new BN(1);

  // Skip leading zeroes
  var res = this;
  for (var i = 0; i < w.length; i++, res = res.sqr())
    if (w[i] !== 0)
      break;

  if (++i < w.length) {
    for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
      if (w[i] === 0)
        continue;
      res = res.mul(q);
    }
  }

  return res;
};

// Shift-left in-place
BN.prototype.iushln = function iushln(bits) {
  assert(typeof bits === 'number' && bits >= 0);
  var r = bits % 26;
  var s = (bits - r) / 26;
  var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);

  if (r !== 0) {
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var newCarry = this.words[i] & carryMask;
      var c = ((this.words[i] | 0) - newCarry) << r;
      this.words[i] = c | carry;
      carry = newCarry >>> (26 - r);
    }
    if (carry) {
      this.words[i] = carry;
      this.length++;
    }
  }

  if (s !== 0) {
    for (var i = this.length - 1; i >= 0; i--)
      this.words[i + s] = this.words[i];
    for (var i = 0; i < s; i++)
      this.words[i] = 0;
    this.length += s;
  }

  return this.strip();
};

BN.prototype.ishln = function ishln(bits) {
  // TODO(indutny): implement me
  assert(this.negative === 0);
  return this.iushln(bits);
};

// Shift-right in-place
// NOTE: `hint` is a lowest bit before trailing zeroes
// NOTE: if `extended` is present - it will be filled with destroyed bits
BN.prototype.iushrn = function iushrn(bits, hint, extended) {
  assert(typeof bits === 'number' && bits >= 0);
  var h;
  if (hint)
    h = (hint - (hint % 26)) / 26;
  else
    h = 0;

  var r = bits % 26;
  var s = Math.min((bits - r) / 26, this.length);
  var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
  var maskedWords = extended;

  h -= s;
  h = Math.max(0, h);

  // Extended mode, copy masked part
  if (maskedWords) {
    for (var i = 0; i < s; i++)
      maskedWords.words[i] = this.words[i];
    maskedWords.length = s;
  }

  if (s === 0) {
    // No-op, we should not move anything at all
  } else if (this.length > s) {
    this.length -= s;
    for (var i = 0; i < this.length; i++)
      this.words[i] = this.words[i + s];
  } else {
    this.words[0] = 0;
    this.length = 1;
  }

  var carry = 0;
  for (var i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
    var word = this.words[i] | 0;
    this.words[i] = (carry << (26 - r)) | (word >>> r);
    carry = word & mask;
  }

  // Push carried bits as a mask
  if (maskedWords && carry !== 0)
    maskedWords.words[maskedWords.length++] = carry;

  if (this.length === 0) {
    this.words[0] = 0;
    this.length = 1;
  }

  return this.strip();
};

BN.prototype.ishrn = function ishrn(bits, hint, extended) {
  // TODO(indutny): implement me
  assert(this.negative === 0);
  return this.iushrn(bits, hint, extended);
};

// Shift-left
BN.prototype.shln = function shln(bits) {
  return this.clone().ishln(bits);
};

BN.prototype.ushln = function ushln(bits) {
  return this.clone().iushln(bits);
};

// Shift-right
BN.prototype.shrn = function shrn(bits) {
  return this.clone().ishrn(bits);
};

BN.prototype.ushrn = function ushrn(bits) {
  return this.clone().iushrn(bits);
};

// Test if n bit is set
BN.prototype.testn = function testn(bit) {
  assert(typeof bit === 'number' && bit >= 0);
  var r = bit % 26;
  var s = (bit - r) / 26;
  var q = 1 << r;

  // Fast case: bit is much higher than all existing words
  if (this.length <= s) {
    return false;
  }

  // Check bit and return
  var w = this.words[s];

  return !!(w & q);
};

// Return only lowers bits of number (in-place)
BN.prototype.imaskn = function imaskn(bits) {
  assert(typeof bits === 'number' && bits >= 0);
  var r = bits % 26;
  var s = (bits - r) / 26;

  assert(this.negative === 0, 'imaskn works only with positive numbers');

  if (r !== 0)
    s++;
  this.length = Math.min(s, this.length);

  if (r !== 0) {
    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    this.words[this.length - 1] &= mask;
  }

  return this.strip();
};

// Return only lowers bits of number
BN.prototype.maskn = function maskn(bits) {
  return this.clone().imaskn(bits);
};

// Add plain number `num` to `this`
BN.prototype.iaddn = function iaddn(num) {
  assert(typeof num === 'number');
  if (num < 0)
    return this.isubn(-num);

  // Possible sign change
  if (this.negative !== 0) {
    if (this.length === 1 && (this.words[0] | 0) < num) {
      this.words[0] = num - (this.words[0] | 0);
      this.negative = 0;
      return this;
    }

    this.negative = 0;
    this.isubn(num);
    this.negative = 1;
    return this;
  }

  // Add without checks
  return this._iaddn(num);
};

BN.prototype._iaddn = function _iaddn(num) {
  this.words[0] += num;

  // Carry
  for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
    this.words[i] -= 0x4000000;
    if (i === this.length - 1)
      this.words[i + 1] = 1;
    else
      this.words[i + 1]++;
  }
  this.length = Math.max(this.length, i + 1);

  return this;
};

// Subtract plain number `num` from `this`
BN.prototype.isubn = function isubn(num) {
  assert(typeof num === 'number');
  if (num < 0)
    return this.iaddn(-num);

  if (this.negative !== 0) {
    this.negative = 0;
    this.iaddn(num);
    this.negative = 1;
    return this;
  }

  this.words[0] -= num;

  if (this.length === 1 && this.words[0] < 0) {
    this.words[0] = -this.words[0];
    this.negative = 1;
  } else {
    // Carry
    for (var i = 0; i < this.length && this.words[i] < 0; i++) {
      this.words[i] += 0x4000000;
      this.words[i + 1] -= 1;
    }
  }

  return this.strip();
};

BN.prototype.addn = function addn(num) {
  return this.clone().iaddn(num);
};

BN.prototype.subn = function subn(num) {
  return this.clone().isubn(num);
};

BN.prototype.iabs = function iabs() {
  this.negative = 0;

  return this;
};

BN.prototype.abs = function abs() {
  return this.clone().iabs();
};

BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
  // Bigger storage is needed
  var len = num.length + shift;
  var i;
  if (this.words.length < len) {
    var t = new Array(len);
    for (var i = 0; i < this.length; i++)
      t[i] = this.words[i];
    this.words = t;
  } else {
    i = this.length;
  }

  // Zeroify rest
  this.length = Math.max(this.length, len);
  for (; i < this.length; i++)
    this.words[i] = 0;

  var carry = 0;
  for (var i = 0; i < num.length; i++) {
    var w = (this.words[i + shift] | 0) + carry;
    var right = (num.words[i] | 0) * mul;
    w -= right & 0x3ffffff;
    carry = (w >> 26) - ((right / 0x4000000) | 0);
    this.words[i + shift] = w & 0x3ffffff;
  }
  for (; i < this.length - shift; i++) {
    var w = (this.words[i + shift] | 0) + carry;
    carry = w >> 26;
    this.words[i + shift] = w & 0x3ffffff;
  }

  if (carry === 0)
    return this.strip();

  // Subtraction overflow
  assert(carry === -1);
  carry = 0;
  for (var i = 0; i < this.length; i++) {
    var w = -(this.words[i] | 0) + carry;
    carry = w >> 26;
    this.words[i] = w & 0x3ffffff;
  }
  this.negative = 1;

  return this.strip();
};

BN.prototype._wordDiv = function _wordDiv(num, mode) {
  var shift = this.length - num.length;

  var a = this.clone();
  var b = num;

  // Normalize
  var bhi = b.words[b.length - 1] | 0;
  var bhiBits = this._countBits(bhi);
  shift = 26 - bhiBits;
  if (shift !== 0) {
    b = b.ushln(shift);
    a.iushln(shift);
    bhi = b.words[b.length - 1] | 0;
  }

  // Initialize quotient
  var m = a.length - b.length;
  var q;

  if (mode !== 'mod') {
    q = new BN(null);
    q.length = m + 1;
    q.words = new Array(q.length);
    for (var i = 0; i < q.length; i++)
      q.words[i] = 0;
  }

  var diff = a.clone()._ishlnsubmul(b, 1, m);
  if (diff.negative === 0) {
    a = diff;
    if (q)
      q.words[m] = 1;
  }

  for (var j = m - 1; j >= 0; j--) {
    var qj = (a.words[b.length + j] | 0) * 0x4000000 +
             (a.words[b.length + j - 1] | 0);

    // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
    // (0x7ffffff)
    qj = Math.min((qj / bhi) | 0, 0x3ffffff);

    a._ishlnsubmul(b, qj, j);
    while (a.negative !== 0) {
      qj--;
      a.negative = 0;
      a._ishlnsubmul(b, 1, j);
      if (a.cmpn(0) !== 0)
        a.negative ^= 1;
    }
    if (q)
      q.words[j] = qj;
  }
  if (q)
    q.strip();
  a.strip();

  // Denormalize
  if (mode !== 'div' && shift !== 0)
    a.iushrn(shift);
  return { div: q ? q : null, mod: a };
};

BN.prototype.divmod = function divmod(num, mode, positive) {
  assert(num.cmpn(0) !== 0);

  if (this.negative !== 0 && num.negative === 0) {
    var res = this.neg().divmod(num, mode);
    var div;
    var mod;
    if (mode !== 'mod')
      div = res.div.neg();
    if (mode !== 'div') {
      mod = res.mod.neg();
      if (positive && mod.neg)
        mod = mod.add(num);
    }
    return {
      div: div,
      mod: mod
    };
  } else if (this.negative === 0 && num.negative !== 0) {
    var res = this.divmod(num.neg(), mode);
    var div;
    if (mode !== 'mod')
      div = res.div.neg();
    return { div: div, mod: res.mod };
  } else if ((this.negative & num.negative) !== 0) {
    var res = this.neg().divmod(num.neg(), mode);
    var mod;
    if (mode !== 'div') {
      mod = res.mod.neg();
      if (positive && mod.neg)
        mod = mod.isub(num);
    }
    return {
      div: res.div,
      mod: mod
    };
  }

  // Both numbers are positive at this point

  // Strip both numbers to approximate shift value
  if (num.length > this.length || this.cmp(num) < 0)
    return { div: new BN(0), mod: this };

  // Very short reduction
  if (num.length === 1) {
    if (mode === 'div')
      return { div: this.divn(num.words[0]), mod: null };
    else if (mode === 'mod')
      return { div: null, mod: new BN(this.modn(num.words[0])) };
    return {
      div: this.divn(num.words[0]),
      mod: new BN(this.modn(num.words[0]))
    };
  }

  return this._wordDiv(num, mode);
};

// Find `this` / `num`
BN.prototype.div = function div(num) {
  return this.divmod(num, 'div', false).div;
};

// Find `this` % `num`
BN.prototype.mod = function mod(num) {
  return this.divmod(num, 'mod', false).mod;
};

BN.prototype.umod = function umod(num) {
  return this.divmod(num, 'mod', true).mod;
};

// Find Round(`this` / `num`)
BN.prototype.divRound = function divRound(num) {
  var dm = this.divmod(num);

  // Fast case - exact division
  if (dm.mod.cmpn(0) === 0)
    return dm.div;

  var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

  var half = num.ushrn(1);
  var r2 = num.andln(1);
  var cmp = mod.cmp(half);

  // Round down
  if (cmp < 0 || r2 === 1 && cmp === 0)
    return dm.div;

  // Round up
  return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
};

BN.prototype.modn = function modn(num) {
  assert(num <= 0x3ffffff);
  var p = (1 << 26) % num;

  var acc = 0;
  for (var i = this.length - 1; i >= 0; i--)
    acc = (p * acc + (this.words[i] | 0)) % num;

  return acc;
};

// In-place division by number
BN.prototype.idivn = function idivn(num) {
  assert(num <= 0x3ffffff);

  var carry = 0;
  for (var i = this.length - 1; i >= 0; i--) {
    var w = (this.words[i] | 0) + carry * 0x4000000;
    this.words[i] = (w / num) | 0;
    carry = w % num;
  }

  return this.strip();
};

BN.prototype.divn = function divn(num) {
  return this.clone().idivn(num);
};

BN.prototype.egcd = function egcd(p) {
  assert(p.negative === 0);
  assert(p.cmpn(0) !== 0);

  var x = this;
  var y = p.clone();

  if (x.negative !== 0)
    x = x.umod(p);
  else
    x = x.clone();

  // A * x + B * y = x
  var A = new BN(1);
  var B = new BN(0);

  // C * x + D * y = y
  var C = new BN(0);
  var D = new BN(1);

  var g = 0;

  while (x.isEven() && y.isEven()) {
    x.iushrn(1);
    y.iushrn(1);
    ++g;
  }

  var yp = y.clone();
  var xp = x.clone();

  while (x.cmpn(0) !== 0) {
    while (x.isEven()) {
      x.iushrn(1);
      if (A.isEven() && B.isEven()) {
        A.iushrn(1);
        B.iushrn(1);
      } else {
        A.iadd(yp).iushrn(1);
        B.isub(xp).iushrn(1);
      }
    }

    while (y.isEven()) {
      y.iushrn(1);
      if (C.isEven() && D.isEven()) {
        C.iushrn(1);
        D.iushrn(1);
      } else {
        C.iadd(yp).iushrn(1);
        D.isub(xp).iushrn(1);
      }
    }

    if (x.cmp(y) >= 0) {
      x.isub(y);
      A.isub(C);
      B.isub(D);
    } else {
      y.isub(x);
      C.isub(A);
      D.isub(B);
    }
  }

  return {
    a: C,
    b: D,
    gcd: y.iushln(g)
  };
};

// This is reduced incarnation of the binary EEA
// above, designated to invert members of the
// _prime_ fields F(p) at a maximal speed
BN.prototype._invmp = function _invmp(p) {
  assert(p.negative === 0);
  assert(p.cmpn(0) !== 0);

  var a = this;
  var b = p.clone();

  if (a.negative !== 0)
    a = a.umod(p);
  else
    a = a.clone();

  var x1 = new BN(1);
  var x2 = new BN(0);

  var delta = b.clone();

  while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
    while (a.isEven()) {
      a.iushrn(1);
      if (x1.isEven())
        x1.iushrn(1);
      else
        x1.iadd(delta).iushrn(1);
    }
    while (b.isEven()) {
      b.iushrn(1);
      if (x2.isEven())
        x2.iushrn(1);
      else
        x2.iadd(delta).iushrn(1);
    }
    if (a.cmp(b) >= 0) {
      a.isub(b);
      x1.isub(x2);
    } else {
      b.isub(a);
      x2.isub(x1);
    }
  }

  var res;
  if (a.cmpn(1) === 0)
    res = x1;
  else
    res = x2;

  if (res.cmpn(0) < 0)
    res.iadd(p);

  return res;
};

BN.prototype.gcd = function gcd(num) {
  if (this.cmpn(0) === 0)
    return num.clone();
  if (num.cmpn(0) === 0)
    return this.clone();

  var a = this.clone();
  var b = num.clone();
  a.negative = 0;
  b.negative = 0;

  // Remove common factor of two
  for (var shift = 0; a.isEven() && b.isEven(); shift++) {
    a.iushrn(1);
    b.iushrn(1);
  }

  do {
    while (a.isEven())
      a.iushrn(1);
    while (b.isEven())
      b.iushrn(1);

    var r = a.cmp(b);
    if (r < 0) {
      // Swap `a` and `b` to make `a` always bigger than `b`
      var t = a;
      a = b;
      b = t;
    } else if (r === 0 || b.cmpn(1) === 0) {
      break;
    }

    a.isub(b);
  } while (true);

  return b.iushln(shift);
};

// Invert number in the field F(num)
BN.prototype.invm = function invm(num) {
  return this.egcd(num).a.umod(num);
};

BN.prototype.isEven = function isEven() {
  return (this.words[0] & 1) === 0;
};

BN.prototype.isOdd = function isOdd() {
  return (this.words[0] & 1) === 1;
};

// And first word and num
BN.prototype.andln = function andln(num) {
  return this.words[0] & num;
};

// Increment at the bit position in-line
BN.prototype.bincn = function bincn(bit) {
  assert(typeof bit === 'number');
  var r = bit % 26;
  var s = (bit - r) / 26;
  var q = 1 << r;

  // Fast case: bit is much higher than all existing words
  if (this.length <= s) {
    for (var i = this.length; i < s + 1; i++)
      this.words[i] = 0;
    this.words[s] |= q;
    this.length = s + 1;
    return this;
  }

  // Add bit and propagate, if needed
  var carry = q;
  for (var i = s; carry !== 0 && i < this.length; i++) {
    var w = this.words[i] | 0;
    w += carry;
    carry = w >>> 26;
    w &= 0x3ffffff;
    this.words[i] = w;
  }
  if (carry !== 0) {
    this.words[i] = carry;
    this.length++;
  }
  return this;
};

BN.prototype.isZero = function isZero() {
  return this.length === 1 && this.words[0] === 0;
};

BN.prototype.cmpn = function cmpn(num) {
  var negative = num < 0;

  if (this.negative !== 0 && !negative)
    return -1;
  else if (this.negative === 0 && negative)
    return 1;

  this.strip();

  var res;
  if (this.length > 1) {
    res = 1;
  } else {
    if (negative)
      num = -num;
    assert(num <= 0x3ffffff, 'Number is too big');

    var w = this.words[0] | 0;
    res = w === num ? 0 : w < num ? -1 : 1;
  }
  if (this.negative !== 0)
    res = -res;
  return res;
};

// Compare two numbers and return:
// 1 - if `this` > `num`
// 0 - if `this` == `num`
// -1 - if `this` < `num`
BN.prototype.cmp = function cmp(num) {
  if (this.negative !== 0 && num.negative === 0)
    return -1;
  else if (this.negative === 0 && num.negative !== 0)
    return 1;

  var res = this.ucmp(num);
  if (this.negative !== 0)
    return -res;
  else
    return res;
};

// Unsigned comparison
BN.prototype.ucmp = function ucmp(num) {
  // At this point both numbers have the same sign
  if (this.length > num.length)
    return 1;
  else if (this.length < num.length)
    return -1;

  var res = 0;
  for (var i = this.length - 1; i >= 0; i--) {
    var a = this.words[i] | 0;
    var b = num.words[i] | 0;

    if (a === b)
      continue;
    if (a < b)
      res = -1;
    else if (a > b)
      res = 1;
    break;
  }
  return res;
};

//
// A reduce context, could be using montgomery or something better, depending
// on the `m` itself.
//
BN.red = function red(num) {
  return new Red(num);
};

BN.prototype.toRed = function toRed(ctx) {
  assert(!this.red, 'Already a number in reduction context');
  assert(this.negative === 0, 'red works only with positives');
  return ctx.convertTo(this)._forceRed(ctx);
};

BN.prototype.fromRed = function fromRed() {
  assert(this.red, 'fromRed works only with numbers in reduction context');
  return this.red.convertFrom(this);
};

BN.prototype._forceRed = function _forceRed(ctx) {
  this.red = ctx;
  return this;
};

BN.prototype.forceRed = function forceRed(ctx) {
  assert(!this.red, 'Already a number in reduction context');
  return this._forceRed(ctx);
};

BN.prototype.redAdd = function redAdd(num) {
  assert(this.red, 'redAdd works only with red numbers');
  return this.red.add(this, num);
};

BN.prototype.redIAdd = function redIAdd(num) {
  assert(this.red, 'redIAdd works only with red numbers');
  return this.red.iadd(this, num);
};

BN.prototype.redSub = function redSub(num) {
  assert(this.red, 'redSub works only with red numbers');
  return this.red.sub(this, num);
};

BN.prototype.redISub = function redISub(num) {
  assert(this.red, 'redISub works only with red numbers');
  return this.red.isub(this, num);
};

BN.prototype.redShl = function redShl(num) {
  assert(this.red, 'redShl works only with red numbers');
  return this.red.ushl(this, num);
};

BN.prototype.redMul = function redMul(num) {
  assert(this.red, 'redMul works only with red numbers');
  this.red._verify2(this, num);
  return this.red.mul(this, num);
};

BN.prototype.redIMul = function redIMul(num) {
  assert(this.red, 'redMul works only with red numbers');
  this.red._verify2(this, num);
  return this.red.imul(this, num);
};

BN.prototype.redSqr = function redSqr() {
  assert(this.red, 'redSqr works only with red numbers');
  this.red._verify1(this);
  return this.red.sqr(this);
};

BN.prototype.redISqr = function redISqr() {
  assert(this.red, 'redISqr works only with red numbers');
  this.red._verify1(this);
  return this.red.isqr(this);
};

// Square root over p
BN.prototype.redSqrt = function redSqrt() {
  assert(this.red, 'redSqrt works only with red numbers');
  this.red._verify1(this);
  return this.red.sqrt(this);
};

BN.prototype.redInvm = function redInvm() {
  assert(this.red, 'redInvm works only with red numbers');
  this.red._verify1(this);
  return this.red.invm(this);
};

// Return negative clone of `this` % `red modulo`
BN.prototype.redNeg = function redNeg() {
  assert(this.red, 'redNeg works only with red numbers');
  this.red._verify1(this);
  return this.red.neg(this);
};

BN.prototype.redPow = function redPow(num) {
  assert(this.red && !num.red, 'redPow(normalNum)');
  this.red._verify1(this);
  return this.red.pow(this, num);
};

// Prime numbers with efficient reduction
var primes = {
  k256: null,
  p224: null,
  p192: null,
  p25519: null
};

// Pseudo-Mersenne prime
function MPrime(name, p) {
  // P = 2 ^ N - K
  this.name = name;
  this.p = new BN(p, 16);
  this.n = this.p.bitLength();
  this.k = new BN(1).iushln(this.n).isub(this.p);

  this.tmp = this._tmp();
}

MPrime.prototype._tmp = function _tmp() {
  var tmp = new BN(null);
  tmp.words = new Array(Math.ceil(this.n / 13));
  return tmp;
};

MPrime.prototype.ireduce = function ireduce(num) {
  // Assumes that `num` is less than `P^2`
  // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
  var r = num;
  var rlen;

  do {
    this.split(r, this.tmp);
    r = this.imulK(r);
    r = r.iadd(this.tmp);
    rlen = r.bitLength();
  } while (rlen > this.n);

  var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
  if (cmp === 0) {
    r.words[0] = 0;
    r.length = 1;
  } else if (cmp > 0) {
    r.isub(this.p);
  } else {
    r.strip();
  }

  return r;
};

MPrime.prototype.split = function split(input, out) {
  input.iushrn(this.n, 0, out);
};

MPrime.prototype.imulK = function imulK(num) {
  return num.imul(this.k);
};

function K256() {
  MPrime.call(
    this,
    'k256',
    'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
}
inherits(K256, MPrime);

K256.prototype.split = function split(input, output) {
  // 256 = 9 * 26 + 22
  var mask = 0x3fffff;

  var outLen = Math.min(input.length, 9);
  for (var i = 0; i < outLen; i++)
    output.words[i] = input.words[i];
  output.length = outLen;

  if (input.length <= 9) {
    input.words[0] = 0;
    input.length = 1;
    return;
  }

  // Shift by 9 limbs
  var prev = input.words[9];
  output.words[output.length++] = prev & mask;

  for (var i = 10; i < input.length; i++) {
    var next = input.words[i] | 0;
    input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
    prev = next;
  }
  input.words[i - 10] = prev >>> 22;
  input.length -= 9;
};

K256.prototype.imulK = function imulK(num) {
  // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
  num.words[num.length] = 0;
  num.words[num.length + 1] = 0;
  num.length += 2;

  // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
  var hi;
  var lo = 0;
  for (var i = 0; i < num.length; i++) {
    var w = num.words[i] | 0;
    hi = w * 0x40;
    lo += w * 0x3d1;
    hi += (lo / 0x4000000) | 0;
    lo &= 0x3ffffff;

    num.words[i] = lo;

    lo = hi;
  }

  // Fast length reduction
  if (num.words[num.length - 1] === 0) {
    num.length--;
    if (num.words[num.length - 1] === 0)
      num.length--;
  }
  return num;
};

function P224() {
  MPrime.call(
    this,
    'p224',
    'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
}
inherits(P224, MPrime);

function P192() {
  MPrime.call(
    this,
    'p192',
    'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
}
inherits(P192, MPrime);

function P25519() {
  // 2 ^ 255 - 19
  MPrime.call(
    this,
    '25519',
    '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
}
inherits(P25519, MPrime);

P25519.prototype.imulK = function imulK(num) {
  // K = 0x13
  var carry = 0;
  for (var i = 0; i < num.length; i++) {
    var hi = (num.words[i] | 0) * 0x13 + carry;
    var lo = hi & 0x3ffffff;
    hi >>>= 26;

    num.words[i] = lo;
    carry = hi;
  }
  if (carry !== 0)
    num.words[num.length++] = carry;
  return num;
};

// Exported mostly for testing purposes, use plain name instead
BN._prime = function prime(name) {
  // Cached version of prime
  if (primes[name])
    return primes[name];

  var prime;
  if (name === 'k256')
    prime = new K256();
  else if (name === 'p224')
    prime = new P224();
  else if (name === 'p192')
    prime = new P192();
  else if (name === 'p25519')
    prime = new P25519();
  else
    throw new Error('Unknown prime ' + name);
  primes[name] = prime;

  return prime;
};

//
// Base reduction engine
//
function Red(m) {
  if (typeof m === 'string') {
    var prime = BN._prime(m);
    this.m = prime.p;
    this.prime = prime;
  } else {
    this.m = m;
    this.prime = null;
  }
}

Red.prototype._verify1 = function _verify1(a) {
  assert(a.negative === 0, 'red works only with positives');
  assert(a.red, 'red works only with red numbers');
};

Red.prototype._verify2 = function _verify2(a, b) {
  assert((a.negative | b.negative) === 0, 'red works only with positives');
  assert(a.red && a.red === b.red,
         'red works only with red numbers');
};

Red.prototype.imod = function imod(a) {
  if (this.prime)
    return this.prime.ireduce(a)._forceRed(this);
  return a.umod(this.m)._forceRed(this);
};

Red.prototype.neg = function neg(a) {
  var r = a.clone();
  r.negative ^= 1;
  return r.iadd(this.m)._forceRed(this);
};

Red.prototype.add = function add(a, b) {
  this._verify2(a, b);

  var res = a.add(b);
  if (res.cmp(this.m) >= 0)
    res.isub(this.m);
  return res._forceRed(this);
};

Red.prototype.iadd = function iadd(a, b) {
  this._verify2(a, b);

  var res = a.iadd(b);
  if (res.cmp(this.m) >= 0)
    res.isub(this.m);
  return res;
};

Red.prototype.sub = function sub(a, b) {
  this._verify2(a, b);

  var res = a.sub(b);
  if (res.cmpn(0) < 0)
    res.iadd(this.m);
  return res._forceRed(this);
};

Red.prototype.isub = function isub(a, b) {
  this._verify2(a, b);

  var res = a.isub(b);
  if (res.cmpn(0) < 0)
    res.iadd(this.m);
  return res;
};

Red.prototype.shl = function shl(a, num) {
  this._verify1(a);
  return this.imod(a.ushln(num));
};

Red.prototype.imul = function imul(a, b) {
  this._verify2(a, b);
  return this.imod(a.imul(b));
};

Red.prototype.mul = function mul(a, b) {
  this._verify2(a, b);
  return this.imod(a.mul(b));
};

Red.prototype.isqr = function isqr(a) {
  return this.imul(a, a);
};

Red.prototype.sqr = function sqr(a) {
  return this.mul(a, a);
};

Red.prototype.sqrt = function sqrt(a) {
  if (a.cmpn(0) === 0)
    return a.clone();

  var mod3 = this.m.andln(3);
  assert(mod3 % 2 === 1);

  // Fast case
  if (mod3 === 3) {
    var pow = this.m.add(new BN(1)).iushrn(2);
    var r = this.pow(a, pow);
    return r;
  }

  // Tonelli-Shanks algorithm (Totally unoptimized and slow)
  //
  // Find Q and S, that Q * 2 ^ S = (P - 1)
  var q = this.m.subn(1);
  var s = 0;
  while (q.cmpn(0) !== 0 && q.andln(1) === 0) {
    s++;
    q.iushrn(1);
  }
  assert(q.cmpn(0) !== 0);

  var one = new BN(1).toRed(this);
  var nOne = one.redNeg();

  // Find quadratic non-residue
  // NOTE: Max is such because of generalized Riemann hypothesis.
  var lpow = this.m.subn(1).iushrn(1);
  var z = this.m.bitLength();
  z = new BN(2 * z * z).toRed(this);
  while (this.pow(z, lpow).cmp(nOne) !== 0)
    z.redIAdd(nOne);

  var c = this.pow(z, q);
  var r = this.pow(a, q.addn(1).iushrn(1));
  var t = this.pow(a, q);
  var m = s;
  while (t.cmp(one) !== 0) {
    var tmp = t;
    for (var i = 0; tmp.cmp(one) !== 0; i++)
      tmp = tmp.redSqr();
    assert(i < m);
    var b = this.pow(c, new BN(1).iushln(m - i - 1));

    r = r.redMul(b);
    c = b.redSqr();
    t = t.redMul(c);
    m = i;
  }

  return r;
};

Red.prototype.invm = function invm(a) {
  var inv = a._invmp(this.m);
  if (inv.negative !== 0) {
    inv.negative = 0;
    return this.imod(inv).redNeg();
  } else {
    return this.imod(inv);
  }
};

Red.prototype.pow = function pow(a, num) {
  if (num.cmpn(0) === 0)
    return new BN(1);
  if (num.cmpn(1) === 0)
    return a.clone();

  var windowSize = 4;
  var wnd = new Array(1 << windowSize);
  wnd[0] = new BN(1).toRed(this);
  wnd[1] = a;
  for (var i = 2; i < wnd.length; i++)
    wnd[i] = this.mul(wnd[i - 1], a);

  var res = wnd[0];
  var current = 0;
  var currentLen = 0;
  var start = num.bitLength() % 26;
  if (start === 0)
    start = 26;
  for (var i = num.length - 1; i >= 0; i--) {
    var word = num.words[i];
    for (var j = start - 1; j >= 0; j--) {
      var bit = (word >> j) & 1;
      if (res !== wnd[0])
        res = this.sqr(res);
      if (bit === 0 && current === 0) {
        currentLen = 0;
        continue;
      }

      current <<= 1;
      current |= bit;
      currentLen++;
      if (currentLen !== windowSize && (i !== 0 || j !== 0))
        continue;

      res = this.mul(res, wnd[current]);
      currentLen = 0;
      current = 0;
    }
    start = 26;
  }

  return res;
};

Red.prototype.convertTo = function convertTo(num) {
  var r = num.umod(this.m);
  if (r === num)
    return r.clone();
  else
    return r;
};

Red.prototype.convertFrom = function convertFrom(num) {
  var res = num.clone();
  res.red = null;
  return res;
};

//
// Montgomery method engine
//

BN.mont = function mont(num) {
  return new Mont(num);
};

function Mont(m) {
  Red.call(this, m);

  this.shift = this.m.bitLength();
  if (this.shift % 26 !== 0)
    this.shift += 26 - (this.shift % 26);
  this.r = new BN(1).iushln(this.shift);
  this.r2 = this.imod(this.r.sqr());
  this.rinv = this.r._invmp(this.m);

  this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
  this.minv = this.minv.umod(this.r);
  this.minv = this.r.sub(this.minv);
}
inherits(Mont, Red);

Mont.prototype.convertTo = function convertTo(num) {
  return this.imod(num.ushln(this.shift));
};

Mont.prototype.convertFrom = function convertFrom(num) {
  var r = this.imod(num.mul(this.rinv));
  r.red = null;
  return r;
};

Mont.prototype.imul = function imul(a, b) {
  if (a.cmpn(0) === 0 || b.cmpn(0) === 0) {
    a.words[0] = 0;
    a.length = 1;
    return a;
  }

  var t = a.imul(b);
  var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
  var u = t.isub(c).iushrn(this.shift);
  var res = u;
  if (u.cmp(this.m) >= 0)
    res = u.isub(this.m);
  else if (u.cmpn(0) < 0)
    res = u.iadd(this.m);

  return res._forceRed(this);
};

Mont.prototype.mul = function mul(a, b) {
  if (a.cmpn(0) === 0 || b.cmpn(0) === 0)
    return new BN(0)._forceRed(this);

  var t = a.mul(b);
  var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
  var u = t.isub(c).iushrn(this.shift);
  var res = u;
  if (u.cmp(this.m) >= 0)
    res = u.isub(this.m);
  else if (u.cmpn(0) < 0)
    res = u.iadd(this.m);

  return res._forceRed(this);
};

Mont.prototype.invm = function invm(a) {
  // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
  var res = this.imod(a._invmp(this.m).mul(this.r2));
  return res._forceRed(this);
};

})(typeof module === 'undefined' || module, this);

},{}],190:[function(require,module,exports){
(function (Buffer){
var bn = require('bn.js');
var randomBytes = require('randombytes');
module.exports = crt;
function blind(priv) {
  var r = getr(priv);
  var blinder = r.toRed(bn.mont(priv.modulus))
  .redPow(new bn(priv.publicExponent)).fromRed();
  return {
    blinder: blinder,
    unblinder:r.invm(priv.modulus)
  };
}
function crt(msg, priv) {
  var blinds = blind(priv);
  var len = priv.modulus.byteLength();
  var mod = bn.mont(priv.modulus);
  var blinded = new bn(msg).mul(blinds.blinder).umod(priv.modulus);
  var c1 = blinded.toRed(bn.mont(priv.prime1));
  var c2 = blinded.toRed(bn.mont(priv.prime2));
  var qinv = priv.coefficient;
  var p = priv.prime1;
  var q = priv.prime2;
  var m1 = c1.redPow(priv.exponent1);
  var m2 = c2.redPow(priv.exponent2);
  m1 = m1.fromRed();
  m2 = m2.fromRed();
  var h = m1.isub(m2).imul(qinv).umod(p);
  h.imul(q);
  m2.iadd(h);
  return new Buffer(m2.imul(blinds.unblinder).umod(priv.modulus).toArray(false, len));
}
crt.getr = getr;
function getr(priv) {
  var len = priv.modulus.byteLength();
  var r = new bn(randomBytes(len));
  while (r.cmp(priv.modulus) >=  0 || !r.umod(priv.prime1) || !r.umod(priv.prime2)) {
    r = new bn(randomBytes(len));
  }
  return r;
}

}).call(this,require("buffer").Buffer)

},{"bn.js":189,"buffer":152,"randombytes":347}],191:[function(require,module,exports){
'use strict';

var elliptic = exports;

elliptic.version = require('../package.json').version;
elliptic.utils = require('./elliptic/utils');
elliptic.rand = require('brorand');
elliptic.hmacDRBG = require('./elliptic/hmac-drbg');
elliptic.curve = require('./elliptic/curve');
elliptic.curves = require('./elliptic/curves');

// Protocols
elliptic.ec = require('./elliptic/ec');
elliptic.eddsa = require('./elliptic/eddsa');

},{"../package.json":214,"./elliptic/curve":194,"./elliptic/curves":197,"./elliptic/ec":198,"./elliptic/eddsa":201,"./elliptic/hmac-drbg":204,"./elliptic/utils":206,"brorand":207}],192:[function(require,module,exports){
'use strict';

var bn = require('bn.js');
var elliptic = require('../../elliptic');
var utils = elliptic.utils;
var getNAF = utils.getNAF;
var getJSF = utils.getJSF;
var assert = utils.assert;

function BaseCurve(type, conf) {
  this.type = type;
  this.p = new bn(conf.p, 16);

  // Use Montgomery, when there is no fast reduction for the prime
  this.red = conf.prime ? bn.red(conf.prime) : bn.mont(this.p);

  // Useful for many curves
  this.zero = new bn(0).toRed(this.red);
  this.one = new bn(1).toRed(this.red);
  this.two = new bn(2).toRed(this.red);

  // Curve configuration, optional
  this.n = conf.n && new bn(conf.n, 16);
  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);

  // Temporary arrays
  this._wnafT1 = new Array(4);
  this._wnafT2 = new Array(4);
  this._wnafT3 = new Array(4);
  this._wnafT4 = new Array(4);
}
module.exports = BaseCurve;

BaseCurve.prototype.point = function point() {
  throw new Error('Not implemented');
};

BaseCurve.prototype.validate = function validate() {
  throw new Error('Not implemented');
};

BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
  assert(p.precomputed);
  var doubles = p._getDoubles();

  var naf = getNAF(k, 1);
  var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);
  I /= 3;

  // Translate into more windowed form
  var repr = [];
  for (var j = 0; j < naf.length; j += doubles.step) {
    var nafW = 0;
    for (var k = j + doubles.step - 1; k >= j; k--)
      nafW = (nafW << 1) + naf[k];
    repr.push(nafW);
  }

  var a = this.jpoint(null, null, null);
  var b = this.jpoint(null, null, null);
  for (var i = I; i > 0; i--) {
    for (var j = 0; j < repr.length; j++) {
      var nafW = repr[j];
      if (nafW === i)
        b = b.mixedAdd(doubles.points[j]);
      else if (nafW === -i)
        b = b.mixedAdd(doubles.points[j].neg());
    }
    a = a.add(b);
  }
  return a.toP();
};

BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
  var w = 4;

  // Precompute window
  var nafPoints = p._getNAFPoints(w);
  w = nafPoints.wnd;
  var wnd = nafPoints.points;

  // Get NAF form
  var naf = getNAF(k, w);

  // Add `this`*(N+1) for every w-NAF index
  var acc = this.jpoint(null, null, null);
  for (var i = naf.length - 1; i >= 0; i--) {
    // Count zeroes
    for (var k = 0; i >= 0 && naf[i] === 0; i--)
      k++;
    if (i >= 0)
      k++;
    acc = acc.dblp(k);

    if (i < 0)
      break;
    var z = naf[i];
    assert(z !== 0);
    if (p.type === 'affine') {
      // J +- P
      if (z > 0)
        acc = acc.mixedAdd(wnd[(z - 1) >> 1]);
      else
        acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());
    } else {
      // J +- J
      if (z > 0)
        acc = acc.add(wnd[(z - 1) >> 1]);
      else
        acc = acc.add(wnd[(-z - 1) >> 1].neg());
    }
  }
  return p.type === 'affine' ? acc.toP() : acc;
};

BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,
                                                       points,
                                                       coeffs,
                                                       len) {
  var wndWidth = this._wnafT1;
  var wnd = this._wnafT2;
  var naf = this._wnafT3;

  // Fill all arrays
  var max = 0;
  for (var i = 0; i < len; i++) {
    var p = points[i];
    var nafPoints = p._getNAFPoints(defW);
    wndWidth[i] = nafPoints.wnd;
    wnd[i] = nafPoints.points;
  }

  // Comb small window NAFs
  for (var i = len - 1; i >= 1; i -= 2) {
    var a = i - 1;
    var b = i;
    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
      naf[a] = getNAF(coeffs[a], wndWidth[a]);
      naf[b] = getNAF(coeffs[b], wndWidth[b]);
      max = Math.max(naf[a].length, max);
      max = Math.max(naf[b].length, max);
      continue;
    }

    var comb = [
      points[a], /* 1 */
      null, /* 3 */
      null, /* 5 */
      points[b] /* 7 */
    ];

    // Try to avoid Projective points, if possible
    if (points[a].y.cmp(points[b].y) === 0) {
      comb[1] = points[a].add(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].add(points[b].neg());
    } else {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    }

    var index = [
      -3, /* -1 -1 */
      -1, /* -1 0 */
      -5, /* -1 1 */
      -7, /* 0 -1 */
      0, /* 0 0 */
      7, /* 0 1 */
      5, /* 1 -1 */
      1, /* 1 0 */
      3  /* 1 1 */
    ];

    var jsf = getJSF(coeffs[a], coeffs[b]);
    max = Math.max(jsf[0].length, max);
    naf[a] = new Array(max);
    naf[b] = new Array(max);
    for (var j = 0; j < max; j++) {
      var ja = jsf[0][j] | 0;
      var jb = jsf[1][j] | 0;

      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
      naf[b][j] = 0;
      wnd[a] = comb;
    }
  }

  var acc = this.jpoint(null, null, null);
  var tmp = this._wnafT4;
  for (var i = max; i >= 0; i--) {
    var k = 0;

    while (i >= 0) {
      var zero = true;
      for (var j = 0; j < len; j++) {
        tmp[j] = naf[j][i] | 0;
        if (tmp[j] !== 0)
          zero = false;
      }
      if (!zero)
        break;
      k++;
      i--;
    }
    if (i >= 0)
      k++;
    acc = acc.dblp(k);
    if (i < 0)
      break;

    for (var j = 0; j < len; j++) {
      var z = tmp[j];
      var p;
      if (z === 0)
        continue;
      else if (z > 0)
        p = wnd[j][(z - 1) >> 1];
      else if (z < 0)
        p = wnd[j][(-z - 1) >> 1].neg();

      if (p.type === 'affine')
        acc = acc.mixedAdd(p);
      else
        acc = acc.add(p);
    }
  }
  // Zeroify references
  for (var i = 0; i < len; i++)
    wnd[i] = null;
  return acc.toP();
};

function BasePoint(curve, type) {
  this.curve = curve;
  this.type = type;
  this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;

BasePoint.prototype.eq = function eq(/*other*/) {
  throw new Error('Not implemented');
};

BasePoint.prototype.validate = function validate() {
  return this.curve.validate(this);
};

BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  bytes = utils.toArray(bytes, enc);

  var len = this.p.byteLength();
  if (bytes[0] === 0x04 && bytes.length - 1 === 2 * len) {
    return this.point(bytes.slice(1, 1 + len),
                      bytes.slice(1 + len, 1 + 2 * len));
  } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&
              bytes.length - 1 === len) {
    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);
  }
  throw new Error('Unknown point format');
};

BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
  return this.encode(enc, true);
};

BasePoint.prototype._encode = function _encode(compact) {
  var len = this.curve.p.byteLength();
  var x = this.getX().toArray('be', len);

  if (compact)
    return [ this.getY().isEven() ? 0x02 : 0x03 ].concat(x);

  return [ 0x04 ].concat(x, this.getY().toArray('be', len)) ;
};

BasePoint.prototype.encode = function encode(enc, compact) {
  return utils.encode(this._encode(compact), enc);
};

BasePoint.prototype.precompute = function precompute(power) {
  if (this.precomputed)
    return this;

  var precomputed = {
    doubles: null,
    naf: null,
    beta: null
  };
  precomputed.naf = this._getNAFPoints(8);
  precomputed.doubles = this._getDoubles(4, power);
  precomputed.beta = this._getBeta();
  this.precomputed = precomputed;

  return this;
};

BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
  if (!this.precomputed)
    return false;

  var doubles = this.precomputed.doubles;
  if (!doubles)
    return false;

  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
};

BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;

  var doubles = [ this ];
  var acc = this;
  for (var i = 0; i < power; i += step) {
    for (var j = 0; j < step; j++)
      acc = acc.dbl();
    doubles.push(acc);
  }
  return {
    step: step,
    points: doubles
  };
};

BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;

  var res = [ this ];
  var max = (1 << wnd) - 1;
  var dbl = max === 1 ? null : this.dbl();
  for (var i = 1; i < max; i++)
    res[i] = res[i - 1].add(dbl);
  return {
    wnd: wnd,
    points: res
  };
};

BasePoint.prototype._getBeta = function _getBeta() {
  return null;
};

BasePoint.prototype.dblp = function dblp(k) {
  var r = this;
  for (var i = 0; i < k; i++)
    r = r.dbl();
  return r;
};

},{"../../elliptic":191,"bn.js":189}],193:[function(require,module,exports){
'use strict';

var curve = require('../curve');
var elliptic = require('../../elliptic');
var bn = require('bn.js');
var inherits = require('inherits');
var Base = curve.base;

var assert = elliptic.utils.assert;

function EdwardsCurve(conf) {
  // NOTE: Important as we are creating point in Base.call()
  this.twisted = (conf.a | 0) !== 1;
  this.mOneA = this.twisted && (conf.a | 0) === -1;
  this.extended = this.mOneA;

  Base.call(this, 'edwards', conf);

  this.a = new bn(conf.a, 16).umod(this.red.m);
  this.a = this.a.toRed(this.red);
  this.c = new bn(conf.c, 16).toRed(this.red);
  this.c2 = this.c.redSqr();
  this.d = new bn(conf.d, 16).toRed(this.red);
  this.dd = this.d.redAdd(this.d);

  assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
  this.oneC = (conf.c | 0) === 1;
}
inherits(EdwardsCurve, Base);
module.exports = EdwardsCurve;

EdwardsCurve.prototype._mulA = function _mulA(num) {
  if (this.mOneA)
    return num.redNeg();
  else
    return this.a.redMul(num);
};

EdwardsCurve.prototype._mulC = function _mulC(num) {
  if (this.oneC)
    return num;
  else
    return this.c.redMul(num);
};

// Just for compatibility with Short curve
EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
  return this.point(x, y, z, t);
};

EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new bn(x, 16);
  if (!x.red)
    x = x.toRed(this.red);

  var x2 = x.redSqr();
  var rhs = this.c2.redSub(this.a.redMul(x2));
  var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));

  var y = rhs.redMul(lhs.redInvm()).redSqrt();
  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();

  return this.point(x, y);
};

EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
  y = new bn(y, 16);
  if (!y.red)
    y = y.toRed(this.red);

  // x^2 = (y^2 - 1) / (d y^2 + 1)
  var y2 = y.redSqr();
  var lhs = y2.redSub(this.one);
  var rhs = y2.redMul(this.d).redAdd(this.one);
  var x2 = lhs.redMul(rhs.redInvm());

  if (x2.cmp(this.zero) === 0) {
    if (odd)
      throw new Error('invalid point');
    else
      return this.point(this.zero, y);
  }

  var x = x2.redSqrt();
  if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  if (x.isOdd() !== odd)
    x = x.redNeg();

  return this.point(x, y);
};

EdwardsCurve.prototype.validate = function validate(point) {
  if (point.isInfinity())
    return true;

  // Curve: A * X^2 + Y^2 = C^2 * (1 + D * X^2 * Y^2)
  point.normalize();

  var x2 = point.x.redSqr();
  var y2 = point.y.redSqr();
  var lhs = x2.redMul(this.a).redAdd(y2);
  var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));

  return lhs.cmp(rhs) === 0;
};

function Point(curve, x, y, z, t) {
  Base.BasePoint.call(this, curve, 'projective');
  if (x === null && y === null && z === null) {
    this.x = this.curve.zero;
    this.y = this.curve.one;
    this.z = this.curve.one;
    this.t = this.curve.zero;
    this.zOne = true;
  } else {
    this.x = new bn(x, 16);
    this.y = new bn(y, 16);
    this.z = z ? new bn(z, 16) : this.curve.one;
    this.t = t && new bn(t, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
    if (this.t && !this.t.red)
      this.t = this.t.toRed(this.curve.red);
    this.zOne = this.z === this.curve.one;

    // Use extended coordinates
    if (this.curve.extended && !this.t) {
      this.t = this.x.redMul(this.y);
      if (!this.zOne)
        this.t = this.t.redMul(this.z.redInvm());
    }
  }
}
inherits(Point, Base.BasePoint);

EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
  return Point.fromJSON(this, obj);
};

EdwardsCurve.prototype.point = function point(x, y, z, t) {
  return new Point(this, x, y, z, t);
};

Point.fromJSON = function fromJSON(curve, obj) {
  return new Point(curve, obj[0], obj[1], obj[2]);
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' y: ' + this.y.fromRed().toString(16, 2) +
      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.x.cmpn(0) === 0 &&
         this.y.cmp(this.z) === 0;
};

Point.prototype._extDbl = function _extDbl() {
  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
  //     #doubling-dbl-2008-hwcd
  // 4M + 4S

  // A = X1^2
  var a = this.x.redSqr();
  // B = Y1^2
  var b = this.y.redSqr();
  // C = 2 * Z1^2
  var c = this.z.redSqr();
  c = c.redIAdd(c);
  // D = a * A
  var d = this.curve._mulA(a);
  // E = (X1 + Y1)^2 - A - B
  var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
  // G = D + B
  var g = d.redAdd(b);
  // F = G - C
  var f = g.redSub(c);
  // H = D - B
  var h = d.redSub(b);
  // X3 = E * F
  var nx = e.redMul(f);
  // Y3 = G * H
  var ny = g.redMul(h);
  // T3 = E * H
  var nt = e.redMul(h);
  // Z3 = F * G
  var nz = f.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};

Point.prototype._projDbl = function _projDbl() {
  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
  //     #doubling-dbl-2008-bbjlp
  //     #doubling-dbl-2007-bl
  // and others
  // Generally 3M + 4S or 2M + 4S

  // B = (X1 + Y1)^2
  var b = this.x.redAdd(this.y).redSqr();
  // C = X1^2
  var c = this.x.redSqr();
  // D = Y1^2
  var d = this.y.redSqr();

  var nx;
  var ny;
  var nz;
  if (this.curve.twisted) {
    // E = a * C
    var e = this.curve._mulA(c);
    // F = E + D
    var f = e.redAdd(d);
    if (this.zOne) {
      // X3 = (B - C - D) * (F - 2)
      nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
      // Y3 = F * (E - D)
      ny = f.redMul(e.redSub(d));
      // Z3 = F^2 - 2 * F
      nz = f.redSqr().redSub(f).redSub(f);
    } else {
      // H = Z1^2
      var h = this.z.redSqr();
      // J = F - 2 * H
      var j = f.redSub(h).redISub(h);
      // X3 = (B-C-D)*J
      nx = b.redSub(c).redISub(d).redMul(j);
      // Y3 = F * (E - D)
      ny = f.redMul(e.redSub(d));
      // Z3 = F * J
      nz = f.redMul(j);
    }
  } else {
    // E = C + D
    var e = c.redAdd(d);
    // H = (c * Z1)^2
    var h = this.curve._mulC(this.c.redMul(this.z)).redSqr();
    // J = E - 2 * H
    var j = e.redSub(h).redSub(h);
    // X3 = c * (B - E) * J
    nx = this.curve._mulC(b.redISub(e)).redMul(j);
    // Y3 = c * E * (C - D)
    ny = this.curve._mulC(e).redMul(c.redISub(d));
    // Z3 = E * J
    nz = e.redMul(j);
  }
  return this.curve.point(nx, ny, nz);
};

Point.prototype.dbl = function dbl() {
  if (this.isInfinity())
    return this;

  // Double in extended coordinates
  if (this.curve.extended)
    return this._extDbl();
  else
    return this._projDbl();
};

Point.prototype._extAdd = function _extAdd(p) {
  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
  //     #addition-add-2008-hwcd-3
  // 8M

  // A = (Y1 - X1) * (Y2 - X2)
  var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
  // B = (Y1 + X1) * (Y2 + X2)
  var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
  // C = T1 * k * T2
  var c = this.t.redMul(this.curve.dd).redMul(p.t);
  // D = Z1 * 2 * Z2
  var d = this.z.redMul(p.z.redAdd(p.z));
  // E = B - A
  var e = b.redSub(a);
  // F = D - C
  var f = d.redSub(c);
  // G = D + C
  var g = d.redAdd(c);
  // H = B + A
  var h = b.redAdd(a);
  // X3 = E * F
  var nx = e.redMul(f);
  // Y3 = G * H
  var ny = g.redMul(h);
  // T3 = E * H
  var nt = e.redMul(h);
  // Z3 = F * G
  var nz = f.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};

Point.prototype._projAdd = function _projAdd(p) {
  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
  //     #addition-add-2008-bbjlp
  //     #addition-add-2007-bl
  // 10M + 1S

  // A = Z1 * Z2
  var a = this.z.redMul(p.z);
  // B = A^2
  var b = a.redSqr();
  // C = X1 * X2
  var c = this.x.redMul(p.x);
  // D = Y1 * Y2
  var d = this.y.redMul(p.y);
  // E = d * C * D
  var e = this.curve.d.redMul(c).redMul(d);
  // F = B - E
  var f = b.redSub(e);
  // G = B + E
  var g = b.redAdd(e);
  // X3 = A * F * ((X1 + Y1) * (X2 + Y2) - C - D)
  var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
  var nx = a.redMul(f).redMul(tmp);
  var ny;
  var nz;
  if (this.curve.twisted) {
    // Y3 = A * G * (D - a * C)
    ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
    // Z3 = F * G
    nz = f.redMul(g);
  } else {
    // Y3 = A * G * (D - C)
    ny = a.redMul(g).redMul(d.redSub(c));
    // Z3 = c * F * G
    nz = this.curve._mulC(f).redMul(g);
  }
  return this.curve.point(nx, ny, nz);
};

Point.prototype.add = function add(p) {
  if (this.isInfinity())
    return p;
  if (p.isInfinity())
    return this;

  if (this.curve.extended)
    return this._extAdd(p);
  else
    return this._projAdd(p);
};

Point.prototype.mul = function mul(k) {
  if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else
    return this.curve._wnafMul(this, k);
};

Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2);
};

Point.prototype.normalize = function normalize() {
  if (this.zOne)
    return this;

  // Normalize coordinates
  var zi = this.z.redInvm();
  this.x = this.x.redMul(zi);
  this.y = this.y.redMul(zi);
  if (this.t)
    this.t = this.t.redMul(zi);
  this.z = this.curve.one;
  this.zOne = true;
  return this;
};

Point.prototype.neg = function neg() {
  return this.curve.point(this.x.redNeg(),
                          this.y,
                          this.z,
                          this.t && this.t.redNeg());
};

Point.prototype.getX = function getX() {
  this.normalize();
  return this.x.fromRed();
};

Point.prototype.getY = function getY() {
  this.normalize();
  return this.y.fromRed();
};

Point.prototype.eq = function eq(other) {
  return this === other ||
         this.getX().cmp(other.getX()) === 0 &&
         this.getY().cmp(other.getY()) === 0;
};

// Compatibility with BaseCurve
Point.prototype.toP = Point.prototype.normalize;
Point.prototype.mixedAdd = Point.prototype.add;

},{"../../elliptic":191,"../curve":194,"bn.js":189,"inherits":349}],194:[function(require,module,exports){
'use strict';

var curve = exports;

curve.base = require('./base');
curve.short = require('./short');
curve.mont = require('./mont');
curve.edwards = require('./edwards');

},{"./base":192,"./edwards":193,"./mont":195,"./short":196}],195:[function(require,module,exports){
'use strict';

var curve = require('../curve');
var bn = require('bn.js');
var inherits = require('inherits');
var Base = curve.base;

var elliptic = require('../../elliptic');
var utils = elliptic.utils;

function MontCurve(conf) {
  Base.call(this, 'mont', conf);

  this.a = new bn(conf.a, 16).toRed(this.red);
  this.b = new bn(conf.b, 16).toRed(this.red);
  this.i4 = new bn(4).toRed(this.red).redInvm();
  this.two = new bn(2).toRed(this.red);
  this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}
inherits(MontCurve, Base);
module.exports = MontCurve;

MontCurve.prototype.validate = function validate(point) {
  var x = point.normalize().x;
  var x2 = x.redSqr();
  var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
  var y = rhs.redSqrt();

  return y.redSqr().cmp(rhs) === 0;
};

function Point(curve, x, z) {
  Base.BasePoint.call(this, curve, 'projective');
  if (x === null && z === null) {
    this.x = this.curve.one;
    this.z = this.curve.zero;
  } else {
    this.x = new bn(x, 16);
    this.z = new bn(z, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
  }
}
inherits(Point, Base.BasePoint);

MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  return this.point(utils.toArray(bytes, enc), 1);
};

MontCurve.prototype.point = function point(x, z) {
  return new Point(this, x, z);
};

MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
  return Point.fromJSON(this, obj);
};

Point.prototype.precompute = function precompute() {
  // No-op
};

Point.prototype._encode = function _encode() {
  return this.getX().toArray('be', this.curve.p.byteLength());
};

Point.fromJSON = function fromJSON(curve, obj) {
  return new Point(curve, obj[0], obj[1] || curve.one);
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};

Point.prototype.dbl = function dbl() {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#doubling-dbl-1987-m-3
  // 2M + 2S + 4A

  // A = X1 + Z1
  var a = this.x.redAdd(this.z);
  // AA = A^2
  var aa = a.redSqr();
  // B = X1 - Z1
  var b = this.x.redSub(this.z);
  // BB = B^2
  var bb = b.redSqr();
  // C = AA - BB
  var c = aa.redSub(bb);
  // X3 = AA * BB
  var nx = aa.redMul(bb);
  // Z3 = C * (BB + A24 * C)
  var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
  return this.curve.point(nx, nz);
};

Point.prototype.add = function add() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.diffAdd = function diffAdd(p, diff) {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#diffadd-dadd-1987-m-3
  // 4M + 2S + 6A

  // A = X2 + Z2
  var a = this.x.redAdd(this.z);
  // B = X2 - Z2
  var b = this.x.redSub(this.z);
  // C = X3 + Z3
  var c = p.x.redAdd(p.z);
  // D = X3 - Z3
  var d = p.x.redSub(p.z);
  // DA = D * A
  var da = d.redMul(a);
  // CB = C * B
  var cb = c.redMul(b);
  // X5 = Z1 * (DA + CB)^2
  var nx = diff.z.redMul(da.redAdd(cb).redSqr());
  // Z5 = X1 * (DA - CB)^2
  var nz = diff.x.redMul(da.redISub(cb).redSqr());
  return this.curve.point(nx, nz);
};

Point.prototype.mul = function mul(k) {
  var t = k.clone();
  var a = this; // (N / 2) * Q + Q
  var b = this.curve.point(null, null); // (N / 2) * Q
  var c = this; // Q

  for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
    bits.push(t.andln(1));

  for (var i = bits.length - 1; i >= 0; i--) {
    if (bits[i] === 0) {
      // N * Q + Q = ((N / 2) * Q + Q)) + (N / 2) * Q
      a = a.diffAdd(b, c);
      // N * Q = 2 * ((N / 2) * Q + Q))
      b = b.dbl();
    } else {
      // N * Q = ((N / 2) * Q + Q) + ((N / 2) * Q)
      b = a.diffAdd(b, c);
      // N * Q + Q = 2 * ((N / 2) * Q + Q)
      a = a.dbl();
    }
  }
  return b;
};

Point.prototype.mulAdd = function mulAdd() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.eq = function eq(other) {
  return this.getX().cmp(other.getX()) === 0;
};

Point.prototype.normalize = function normalize() {
  this.x = this.x.redMul(this.z.redInvm());
  this.z = this.curve.one;
  return this;
};

Point.prototype.getX = function getX() {
  // Normalize coordinates
  this.normalize();

  return this.x.fromRed();
};

},{"../../elliptic":191,"../curve":194,"bn.js":189,"inherits":349}],196:[function(require,module,exports){
'use strict';

var curve = require('../curve');
var elliptic = require('../../elliptic');
var bn = require('bn.js');
var inherits = require('inherits');
var Base = curve.base;

var assert = elliptic.utils.assert;

function ShortCurve(conf) {
  Base.call(this, 'short', conf);

  this.a = new bn(conf.a, 16).toRed(this.red);
  this.b = new bn(conf.b, 16).toRed(this.red);
  this.tinv = this.two.redInvm();

  this.zeroA = this.a.fromRed().cmpn(0) === 0;
  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;

  // If the curve is endomorphic, precalculate beta and lambda
  this.endo = this._getEndomorphism(conf);
  this._endoWnafT1 = new Array(4);
  this._endoWnafT2 = new Array(4);
}
inherits(ShortCurve, Base);
module.exports = ShortCurve;

ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
  // No efficient endomorphism
  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
    return;

  // Compute beta and lambda, that lambda * P = (beta * Px; Py)
  var beta;
  var lambda;
  if (conf.beta) {
    beta = new bn(conf.beta, 16).toRed(this.red);
  } else {
    var betas = this._getEndoRoots(this.p);
    // Choose the smallest beta
    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
    beta = beta.toRed(this.red);
  }
  if (conf.lambda) {
    lambda = new bn(conf.lambda, 16);
  } else {
    // Choose the lambda that is matching selected beta
    var lambdas = this._getEndoRoots(this.n);
    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
      lambda = lambdas[0];
    } else {
      lambda = lambdas[1];
      assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
    }
  }

  // Get basis vectors, used for balanced length-two representation
  var basis;
  if (conf.basis) {
    basis = conf.basis.map(function(vec) {
      return {
        a: new bn(vec.a, 16),
        b: new bn(vec.b, 16)
      };
    });
  } else {
    basis = this._getEndoBasis(lambda);
  }

  return {
    beta: beta,
    lambda: lambda,
    basis: basis
  };
};

ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
  // Find roots of for x^2 + x + 1 in F
  // Root = (-1 +- Sqrt(-3)) / 2
  //
  var red = num === this.p ? this.red : bn.mont(num);
  var tinv = new bn(2).toRed(red).redInvm();
  var ntinv = tinv.redNeg();

  var s = new bn(3).toRed(red).redNeg().redSqrt().redMul(tinv);

  var l1 = ntinv.redAdd(s).fromRed();
  var l2 = ntinv.redSub(s).fromRed();
  return [ l1, l2 ];
};

ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
  // aprxSqrt >= sqrt(this.n)
  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));

  // 3.74
  // Run EGCD, until r(L + 1) < aprxSqrt
  var u = lambda;
  var v = this.n.clone();
  var x1 = new bn(1);
  var y1 = new bn(0);
  var x2 = new bn(0);
  var y2 = new bn(1);

  // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)
  var a0;
  var b0;
  // First vector
  var a1;
  var b1;
  // Second vector
  var a2;
  var b2;

  var prevR;
  var i = 0;
  var r;
  var x;
  while (u.cmpn(0) !== 0) {
    var q = v.div(u);
    r = v.sub(q.mul(u));
    x = x2.sub(q.mul(x1));
    var y = y2.sub(q.mul(y1));

    if (!a1 && r.cmp(aprxSqrt) < 0) {
      a0 = prevR.neg();
      b0 = x1;
      a1 = r.neg();
      b1 = x;
    } else if (a1 && ++i === 2) {
      break;
    }
    prevR = r;

    v = u;
    u = r;
    x2 = x1;
    x1 = x;
    y2 = y1;
    y1 = y;
  }
  a2 = r.neg();
  b2 = x;

  var len1 = a1.sqr().add(b1.sqr());
  var len2 = a2.sqr().add(b2.sqr());
  if (len2.cmp(len1) >= 0) {
    a2 = a0;
    b2 = b0;
  }

  // Normalize signs
  if (a1.negative) {
    a1 = a1.neg();
    b1 = b1.neg();
  }
  if (a2.negative) {
    a2 = a2.neg();
    b2 = b2.neg();
  }

  return [
    { a: a1, b: b1 },
    { a: a2, b: b2 }
  ];
};

ShortCurve.prototype._endoSplit = function _endoSplit(k) {
  var basis = this.endo.basis;
  var v1 = basis[0];
  var v2 = basis[1];

  var c1 = v2.b.mul(k).divRound(this.n);
  var c2 = v1.b.neg().mul(k).divRound(this.n);

  var p1 = c1.mul(v1.a);
  var p2 = c2.mul(v2.a);
  var q1 = c1.mul(v1.b);
  var q2 = c2.mul(v2.b);

  // Calculate answer
  var k1 = k.sub(p1).sub(p2);
  var k2 = q1.add(q2).neg();
  return { k1: k1, k2: k2 };
};

ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new bn(x, 16);
  if (!x.red)
    x = x.toRed(this.red);

  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
  var y = y2.redSqrt();

  // XXX Is there any way to tell if the number is odd without converting it
  // to non-red form?
  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();

  return this.point(x, y);
};

ShortCurve.prototype.validate = function validate(point) {
  if (point.inf)
    return true;

  var x = point.x;
  var y = point.y;

  var ax = this.a.redMul(x);
  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
  return y.redSqr().redISub(rhs).cmpn(0) === 0;
};

ShortCurve.prototype._endoWnafMulAdd =
    function _endoWnafMulAdd(points, coeffs) {
  var npoints = this._endoWnafT1;
  var ncoeffs = this._endoWnafT2;
  for (var i = 0; i < points.length; i++) {
    var split = this._endoSplit(coeffs[i]);
    var p = points[i];
    var beta = p._getBeta();

    if (split.k1.negative) {
      split.k1.ineg();
      p = p.neg(true);
    }
    if (split.k2.negative) {
      split.k2.ineg();
      beta = beta.neg(true);
    }

    npoints[i * 2] = p;
    npoints[i * 2 + 1] = beta;
    ncoeffs[i * 2] = split.k1;
    ncoeffs[i * 2 + 1] = split.k2;
  }
  var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2);

  // Clean-up references to points and coefficients
  for (var j = 0; j < i * 2; j++) {
    npoints[j] = null;
    ncoeffs[j] = null;
  }
  return res;
};

function Point(curve, x, y, isRed) {
  Base.BasePoint.call(this, curve, 'affine');
  if (x === null && y === null) {
    this.x = null;
    this.y = null;
    this.inf = true;
  } else {
    this.x = new bn(x, 16);
    this.y = new bn(y, 16);
    // Force redgomery representation when loading from JSON
    if (isRed) {
      this.x.forceRed(this.curve.red);
      this.y.forceRed(this.curve.red);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    this.inf = false;
  }
}
inherits(Point, Base.BasePoint);

ShortCurve.prototype.point = function point(x, y, isRed) {
  return new Point(this, x, y, isRed);
};

ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
  return Point.fromJSON(this, obj, red);
};

Point.prototype._getBeta = function _getBeta() {
  if (!this.curve.endo)
    return;

  var pre = this.precomputed;
  if (pre && pre.beta)
    return pre.beta;

  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
  if (pre) {
    var curve = this.curve;
    var endoMul = function(p) {
      return curve.point(p.x.redMul(curve.endo.beta), p.y);
    };
    pre.beta = beta;
    beta.precomputed = {
      beta: null,
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(endoMul)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(endoMul)
      }
    };
  }
  return beta;
};

Point.prototype.toJSON = function toJSON() {
  if (!this.precomputed)
    return [ this.x, this.y ];

  return [ this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  } ];
};

Point.fromJSON = function fromJSON(curve, obj, red) {
  if (typeof obj === 'string')
    obj = JSON.parse(obj);
  var res = curve.point(obj[0], obj[1], red);
  if (!obj[2])
    return res;

  function obj2point(obj) {
    return curve.point(obj[0], obj[1], red);
  }

  var pre = obj[2];
  res.precomputed = {
    beta: null,
    doubles: pre.doubles && {
      step: pre.doubles.step,
      points: [ res ].concat(pre.doubles.points.map(obj2point))
    },
    naf: pre.naf && {
      wnd: pre.naf.wnd,
      points: [ res ].concat(pre.naf.points.map(obj2point))
    }
  };
  return res;
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' y: ' + this.y.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  return this.inf;
};

Point.prototype.add = function add(p) {
  // O + P = P
  if (this.inf)
    return p;

  // P + O = P
  if (p.inf)
    return this;

  // P + P = 2P
  if (this.eq(p))
    return this.dbl();

  // P + (-P) = O
  if (this.neg().eq(p))
    return this.curve.point(null, null);

  // P + Q = O
  if (this.x.cmp(p.x) === 0)
    return this.curve.point(null, null);

  var c = this.y.redSub(p.y);
  if (c.cmpn(0) !== 0)
    c = c.redMul(this.x.redSub(p.x).redInvm());
  var nx = c.redSqr().redISub(this.x).redISub(p.x);
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point.prototype.dbl = function dbl() {
  if (this.inf)
    return this;

  // 2P = O
  var ys1 = this.y.redAdd(this.y);
  if (ys1.cmpn(0) === 0)
    return this.curve.point(null, null);

  var a = this.curve.a;

  var x2 = this.x.redSqr();
  var dyinv = ys1.redInvm();
  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);

  var nx = c.redSqr().redISub(this.x.redAdd(this.x));
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point.prototype.getX = function getX() {
  return this.x.fromRed();
};

Point.prototype.getY = function getY() {
  return this.y.fromRed();
};

Point.prototype.mul = function mul(k) {
  k = new bn(k, 16);

  if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else if (this.curve.endo)
    return this.curve._endoWnafMulAdd([ this ], [ k ]);
  else
    return this.curve._wnafMul(this, k);
};

Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
  var points = [ this, p2 ];
  var coeffs = [ k1, k2 ];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2);
};

Point.prototype.eq = function eq(p) {
  return this === p ||
         this.inf === p.inf &&
             (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
};

Point.prototype.neg = function neg(_precompute) {
  if (this.inf)
    return this;

  var res = this.curve.point(this.x, this.y.redNeg());
  if (_precompute && this.precomputed) {
    var pre = this.precomputed;
    var negate = function(p) {
      return p.neg();
    };
    res.precomputed = {
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(negate)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(negate)
      }
    };
  }
  return res;
};

Point.prototype.toJ = function toJ() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);

  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
  return res;
};

function JPoint(curve, x, y, z) {
  Base.BasePoint.call(this, curve, 'jacobian');
  if (x === null && y === null && z === null) {
    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = new bn(0);
  } else {
    this.x = new bn(x, 16);
    this.y = new bn(y, 16);
    this.z = new bn(z, 16);
  }
  if (!this.x.red)
    this.x = this.x.toRed(this.curve.red);
  if (!this.y.red)
    this.y = this.y.toRed(this.curve.red);
  if (!this.z.red)
    this.z = this.z.toRed(this.curve.red);

  this.zOne = this.z === this.curve.one;
}
inherits(JPoint, Base.BasePoint);

ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
  return new JPoint(this, x, y, z);
};

JPoint.prototype.toP = function toP() {
  if (this.isInfinity())
    return this.curve.point(null, null);

  var zinv = this.z.redInvm();
  var zinv2 = zinv.redSqr();
  var ax = this.x.redMul(zinv2);
  var ay = this.y.redMul(zinv2).redMul(zinv);

  return this.curve.point(ax, ay);
};

JPoint.prototype.neg = function neg() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};

JPoint.prototype.add = function add(p) {
  // O + P = P
  if (this.isInfinity())
    return p;

  // P + O = P
  if (p.isInfinity())
    return this;

  // 12M + 4S + 7A
  var pz2 = p.z.redSqr();
  var z2 = this.z.redSqr();
  var u1 = this.x.redMul(pz2);
  var u2 = p.x.redMul(z2);
  var s1 = this.y.redMul(pz2.redMul(p.z));
  var s2 = p.y.redMul(z2.redMul(this.z));

  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(p.z).redMul(h);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mixedAdd = function mixedAdd(p) {
  // O + P = P
  if (this.isInfinity())
    return p.toJ();

  // P + O = P
  if (p.isInfinity())
    return this;

  // 8M + 3S + 7A
  var z2 = this.z.redSqr();
  var u1 = this.x;
  var u2 = p.x.redMul(z2);
  var s1 = this.y;
  var s2 = p.y.redMul(z2).redMul(this.z);

  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(h);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.dblp = function dblp(pow) {
  if (pow === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!pow)
    return this.dbl();

  if (this.curve.zeroA || this.curve.threeA) {
    var r = this;
    for (var i = 0; i < pow; i++)
      r = r.dbl();
    return r;
  }

  // 1M + 2S + 1A + N * (4S + 5M + 8A)
  // N = 1 => 6M + 6S + 9A
  var a = this.curve.a;
  var tinv = this.curve.tinv;

  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();

  // Reuse results
  var jyd = jy.redAdd(jy);
  for (var i = 0; i < pow; i++) {
    var jx2 = jx.redSqr();
    var jyd2 = jyd.redSqr();
    var jyd4 = jyd2.redSqr();
    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

    var t1 = jx.redMul(jyd2);
    var nx = c.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var dny = c.redMul(t2);
    dny = dny.redIAdd(dny).redISub(jyd4);
    var nz = jyd.redMul(jz);
    if (i + 1 < pow)
      jz4 = jz4.redMul(jyd4);

    jx = nx;
    jz = nz;
    jyd = dny;
  }

  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
};

JPoint.prototype.dbl = function dbl() {
  if (this.isInfinity())
    return this;

  if (this.curve.zeroA)
    return this._zeroDbl();
  else if (this.curve.threeA)
    return this._threeDbl();
  else
    return this._dbl();
};

JPoint.prototype._zeroDbl = function _zeroDbl() {
  var nx;
  var ny;
  var nz;
  // Z = 1
  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 14A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a; a = 0
    var m = xx.redAdd(xx).redIAdd(xx);
    // T = M ^ 2 - 2*S
    var t = m.redSqr().redISub(s).redISub(s);

    // 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);

    // X3 = T
    nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2*Y1
    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-dbl-2009-l
    // 2M + 5S + 13A

    // A = X1^2
    var a = this.x.redSqr();
    // B = Y1^2
    var b = this.y.redSqr();
    // C = B^2
    var c = b.redSqr();
    // D = 2 * ((X1 + B)^2 - A - C)
    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
    d = d.redIAdd(d);
    // E = 3 * A
    var e = a.redAdd(a).redIAdd(a);
    // F = E^2
    var f = e.redSqr();

    // 8 * C
    var c8 = c.redIAdd(c);
    c8 = c8.redIAdd(c8);
    c8 = c8.redIAdd(c8);

    // X3 = F - 2 * D
    nx = f.redISub(d).redISub(d);
    // Y3 = E * (D - X3) - 8 * C
    ny = e.redMul(d.redISub(nx)).redISub(c8);
    // Z3 = 2 * Y1 * Z1
    nz = this.y.redMul(this.z);
    nz = nz.redIAdd(nz);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._threeDbl = function _threeDbl() {
  var nx;
  var ny;
  var nz;
  // Z = 1
  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 15A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a
    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
    // T = M^2 - 2 * S
    var t = m.redSqr().redISub(s).redISub(s);
    // X3 = T
    nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2 * Y1
    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b
    // 3M + 5S

    // delta = Z1^2
    var delta = this.z.redSqr();
    // gamma = Y1^2
    var gamma = this.y.redSqr();
    // beta = X1 * gamma
    var beta = this.x.redMul(gamma);
    // alpha = 3 * (X1 - delta) * (X1 + delta)
    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
    alpha = alpha.redAdd(alpha).redIAdd(alpha);
    // X3 = alpha^2 - 8 * beta
    var beta4 = beta.redIAdd(beta);
    beta4 = beta4.redIAdd(beta4);
    var beta8 = beta4.redAdd(beta4);
    nx = alpha.redSqr().redISub(beta8);
    // Z3 = (Y1 + Z1)^2 - gamma - delta
    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2
    var ggamma8 = gamma.redSqr();
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._dbl = function _dbl() {
  var a = this.curve.a;

  // 4M + 6S + 10A
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();

  var jx2 = jx.redSqr();
  var jy2 = jy.redSqr();

  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

  var jxd4 = jx.redAdd(jx);
  jxd4 = jxd4.redIAdd(jxd4);
  var t1 = jxd4.redMul(jy2);
  var nx = c.redSqr().redISub(t1.redAdd(t1));
  var t2 = t1.redISub(nx);

  var jyd8 = jy2.redSqr();
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  var ny = c.redMul(t2).redISub(jyd8);
  var nz = jy.redAdd(jy).redMul(jz);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.trpl = function trpl() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);

  // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl
  // 5M + 10S + ...

  // XX = X1^2
  var xx = this.x.redSqr();
  // YY = Y1^2
  var yy = this.y.redSqr();
  // ZZ = Z1^2
  var zz = this.z.redSqr();
  // YYYY = YY^2
  var yyyy = yy.redSqr();
  // M = 3 * XX + a * ZZ2; a = 0
  var m = xx.redAdd(xx).redIAdd(xx);
  // MM = M^2
  var mm = m.redSqr();
  // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM
  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
  e = e.redIAdd(e);
  e = e.redAdd(e).redIAdd(e);
  e = e.redISub(mm);
  // EE = E^2
  var ee = e.redSqr();
  // T = 16*YYYY
  var t = yyyy.redIAdd(yyyy);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  // U = (M + E)^2 - MM - EE - T
  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
  // X3 = 4 * (X1 * EE - 4 * YY * U)
  var yyu4 = yy.redMul(u);
  yyu4 = yyu4.redIAdd(yyu4);
  yyu4 = yyu4.redIAdd(yyu4);
  var nx = this.x.redMul(ee).redISub(yyu4);
  nx = nx.redIAdd(nx);
  nx = nx.redIAdd(nx);
  // Y3 = 8 * Y1 * (U * (T - U) - E * EE)
  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  // Z3 = (Z1 + E)^2 - ZZ - EE
  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mul = function mul(k, kbase) {
  k = new bn(k, kbase);

  return this.curve._wnafMul(this, k);
};

JPoint.prototype.eq = function eq(p) {
  if (p.type === 'affine')
    return this.eq(p.toJ());

  if (this === p)
    return true;

  // x1 * z2^2 == x2 * z1^2
  var z2 = this.z.redSqr();
  var pz2 = p.z.redSqr();
  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
    return false;

  // y1 * z2^3 == y2 * z1^3
  var z3 = z2.redMul(this.z);
  var pz3 = pz2.redMul(p.z);
  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
};

JPoint.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC JPoint Infinity>';
  return '<EC JPoint x: ' + this.x.toString(16, 2) +
      ' y: ' + this.y.toString(16, 2) +
      ' z: ' + this.z.toString(16, 2) + '>';
};

JPoint.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};

},{"../../elliptic":191,"../curve":194,"bn.js":189,"inherits":349}],197:[function(require,module,exports){
'use strict';

var curves = exports;

var hash = require('hash.js');
var elliptic = require('../elliptic');

var assert = elliptic.utils.assert;

function PresetCurve(options) {
  if (options.type === 'short')
    this.curve = new elliptic.curve.short(options);
  else if (options.type === 'edwards')
    this.curve = new elliptic.curve.edwards(options);
  else
    this.curve = new elliptic.curve.mont(options);
  this.g = this.curve.g;
  this.n = this.curve.n;
  this.hash = options.hash;

  assert(this.g.validate(), 'Invalid curve');
  assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');
}
curves.PresetCurve = PresetCurve;

function defineCurve(name, options) {
  Object.defineProperty(curves, name, {
    configurable: true,
    enumerable: true,
    get: function() {
      var curve = new PresetCurve(options);
      Object.defineProperty(curves, name, {
        configurable: true,
        enumerable: true,
        value: curve
      });
      return curve;
    }
  });
}

defineCurve('p192', {
  type: 'short',
  prime: 'p192',
  p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',
  b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',
  n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',
  hash: hash.sha256,
  gRed: false,
  g: [
    '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',
    '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811'
  ]
});

defineCurve('p224', {
  type: 'short',
  prime: 'p224',
  p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',
  b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',
  n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',
  hash: hash.sha256,
  gRed: false,
  g: [
    'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',
    'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34'
  ]
});

defineCurve('p256', {
  type: 'short',
  prime: null,
  p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',
  a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',
  b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',
  n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',
  hash: hash.sha256,
  gRed: false,
  g: [
    '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',
    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5'
  ]
});

defineCurve('p384', {
  type: 'short',
  prime: null,
  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'fffffffe ffffffff 00000000 00000000 ffffffff',
  a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'fffffffe ffffffff 00000000 00000000 fffffffc',
  b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' +
     '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',
  n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' +
     'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',
  hash: hash.sha384,
  gRed: false,
  g: [
    'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' +
    '5502f25d bf55296c 3a545e38 72760ab7',
    '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' +
    '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f'
  ]
});

defineCurve('p521', {
  type: 'short',
  prime: null,
  p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff',
  a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff fffffffc',
  b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' +
     '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' +
     '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',
  n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' +
     'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',
  hash: hash.sha512,
  gRed: false,
  g: [
    '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' +
    '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' +
    'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',
    '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' +
    '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' +
    '3fad0761 353c7086 a272c240 88be9476 9fd16650'
  ]
});

defineCurve('curve25519', {
  type: 'mont',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '76d06',
  b: '0',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: hash.sha256,
  gRed: false,
  g: [
    '9'
  ]
});

defineCurve('ed25519', {
  type: 'edwards',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '-1',
  c: '1',
  // -121665 * (121666^(-1)) (mod P)
  d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: hash.sha256,
  gRed: false,
  g: [
    '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',

    // 4/5
    '6666666666666666666666666666666666666666666666666666666666666658'
  ]
});

var pre;
try {
  pre = require('./precomputed/secp256k1');
} catch (e) {
  pre = undefined;
}

defineCurve('secp256k1', {
  type: 'short',
  prime: 'k256',
  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',
  a: '0',
  b: '7',
  n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',
  h: '1',
  hash: hash.sha256,

  // Precomputed endomorphism
  beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',
  lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',
  basis: [
    {
      a: '3086d221a7d46bcde86c90e49284eb15',
      b: '-e4437ed6010e88286f547fa90abfe4c3'
    },
    {
      a: '114ca50f7a8e2f3f657c1108d9d44cfd8',
      b: '3086d221a7d46bcde86c90e49284eb15'
    }
  ],

  gRed: false,
  g: [
    '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',
    '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
    pre
  ]
});

},{"../elliptic":191,"./precomputed/secp256k1":205,"hash.js":208}],198:[function(require,module,exports){
'use strict';

var bn = require('bn.js');
var elliptic = require('../../elliptic');
var utils = elliptic.utils;
var assert = utils.assert;

var KeyPair = require('./key');
var Signature = require('./signature');

function EC(options) {
  if (!(this instanceof EC))
    return new EC(options);

  // Shortcut `elliptic.ec(curve-name)`
  if (typeof options === 'string') {
    assert(elliptic.curves.hasOwnProperty(options), 'Unknown curve ' + options);

    options = elliptic.curves[options];
  }

  // Shortcut for `elliptic.ec(elliptic.curves.curveName)`
  if (options instanceof elliptic.curves.PresetCurve)
    options = { curve: options };

  this.curve = options.curve.curve;
  this.n = this.curve.n;
  this.nh = this.n.ushrn(1);
  this.g = this.curve.g;

  // Point on curve
  this.g = options.curve.g;
  this.g.precompute(options.curve.n.bitLength() + 1);

  // Hash for function for DRBG
  this.hash = options.hash || options.curve.hash;
}
module.exports = EC;

EC.prototype.keyPair = function keyPair(options) {
  return new KeyPair(this, options);
};

EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
  return KeyPair.fromPrivate(this, priv, enc);
};

EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
  return KeyPair.fromPublic(this, pub, enc);
};

EC.prototype.genKeyPair = function genKeyPair(options) {
  if (!options)
    options = {};

  // Instantiate Hmac_DRBG
  var drbg = new elliptic.hmacDRBG({
    hash: this.hash,
    pers: options.pers,
    entropy: options.entropy || elliptic.rand(this.hash.hmacStrength),
    nonce: this.n.toArray()
  });

  var bytes = this.n.byteLength();
  var ns2 = this.n.sub(new bn(2));
  do {
    var priv = new bn(drbg.generate(bytes));
    if (priv.cmp(ns2) > 0)
      continue;

    priv.iaddn(1);
    return this.keyFromPrivate(priv);
  } while (true);
};

EC.prototype._truncateToN = function truncateToN(msg, truncOnly) {
  var delta = msg.byteLength() * 8 - this.n.bitLength();
  if (delta > 0)
    msg = msg.ushrn(delta);
  if (!truncOnly && msg.cmp(this.n) >= 0)
    return msg.sub(this.n);
  else
    return msg;
};

EC.prototype.sign = function sign(msg, key, enc, options) {
  if (typeof enc === 'object') {
    options = enc;
    enc = null;
  }
  if (!options)
    options = {};

  key = this.keyFromPrivate(key, enc);
  msg = this._truncateToN(new bn(msg, 16));

  // Zero-extend key to provide enough entropy
  var bytes = this.n.byteLength();
  var bkey = key.getPrivate().toArray();
  for (var i = bkey.length; i < bytes; i++)
    bkey.unshift(0);

  // Zero-extend nonce to have the same byte size as N
  var nonce = msg.toArray();
  for (var i = nonce.length; i < bytes; i++)
    nonce.unshift(0);

  // Instantiate Hmac_DRBG
  var drbg = new elliptic.hmacDRBG({
    hash: this.hash,
    entropy: bkey,
    nonce: nonce
  });

  // Number of bytes to generate
  var ns1 = this.n.sub(new bn(1));
  do {
    var k = new bn(drbg.generate(this.n.byteLength()));
    k = this._truncateToN(k, true);
    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
      continue;

    var kp = this.g.mul(k);
    if (kp.isInfinity())
      continue;

    var kpX = kp.getX();
    var r = kpX.umod(this.n);
    if (r.cmpn(0) === 0)
      continue;

    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
    s = s.umod(this.n);
    if (s.cmpn(0) === 0)
      continue;

    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |
                        (kpX.cmp(r) !== 0 ? 2 : 0);

    // Use complement of `s`, if it is > `n / 2`
    if (options.canonical && s.cmp(this.nh) > 0) {
      s = this.n.sub(s);
      recoveryParam ^= 1;
    }

    return new Signature({ r: r, s: s, recoveryParam: recoveryParam });
  } while (true);
};

EC.prototype.verify = function verify(msg, signature, key, enc) {
  msg = this._truncateToN(new bn(msg, 16));
  key = this.keyFromPublic(key, enc);
  signature = new Signature(signature, 'hex');

  // Perform primitive values validation
  var r = signature.r;
  var s = signature.s;
  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
    return false;
  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
    return false;

  // Validate signature
  var sinv = s.invm(this.n);
  var u1 = sinv.mul(msg).umod(this.n);
  var u2 = sinv.mul(r).umod(this.n);

  var p = this.g.mulAdd(u1, key.getPublic(), u2);
  if (p.isInfinity())
    return false;

  return p.getX().umod(this.n).cmp(r) === 0;
};

EC.prototype.recoverPubKey = function(msg, signature, j, enc) {
  assert((3 & j) === j, 'The recovery param is more than two bits');
  signature = new Signature(signature, enc);

  var n = this.n;
  var e = new bn(msg);
  var r = signature.r;
  var s = signature.s;

  // A set LSB signifies that the y-coordinate is odd
  var isYOdd = j & 1;
  var isSecondKey = j >> 1;
  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
    throw new Error('Unable to find sencond key candinate');

  // 1.1. Let x = r + jn.
  if (isSecondKey)
    r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
  else
    r = this.curve.pointFromX(r, isYOdd);

  var eNeg = n.sub(e);

  // 1.6.1 Compute Q = r^-1 (sR -  eG)
  //               Q = r^-1 (sR + -eG)
  var rInv = signature.r.invm(n);
  return r.mul(s).add(this.g.mul(eNeg)).mul(rInv);
};

EC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
  signature = new Signature(signature, enc);
  if (signature.recoveryParam !== null)
    return signature.recoveryParam;

  for (var i = 0; i < 4; i++) {
    var Qprime = this.recoverPubKey(e, signature, i);

    if (Qprime.eq(Q))
      return i;
  }
  throw new Error('Unable to find valid recovery factor');
};

},{"../../elliptic":191,"./key":199,"./signature":200,"bn.js":189}],199:[function(require,module,exports){
'use strict';

var bn = require('bn.js');

function KeyPair(ec, options) {
  this.ec = ec;
  this.priv = null;
  this.pub = null;

  // KeyPair(ec, { priv: ..., pub: ... })
  if (options.priv)
    this._importPrivate(options.priv, options.privEnc);
  if (options.pub)
    this._importPublic(options.pub, options.pubEnc);
}
module.exports = KeyPair;

KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
  if (pub instanceof KeyPair)
    return pub;

  return new KeyPair(ec, {
    pub: pub,
    pubEnc: enc
  });
};

KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
  if (priv instanceof KeyPair)
    return priv;

  return new KeyPair(ec, {
    priv: priv,
    privEnc: enc
  });
};

KeyPair.prototype.validate = function validate() {
  var pub = this.getPublic();

  if (pub.isInfinity())
    return { result: false, reason: 'Invalid public key' };
  if (!pub.validate())
    return { result: false, reason: 'Public key is not a point' };
  if (!pub.mul(this.ec.curve.n).isInfinity())
    return { result: false, reason: 'Public key * N != O' };

  return { result: true, reason: null };
};

KeyPair.prototype.getPublic = function getPublic(compact, enc) {
  // compact is optional argument
  if (typeof compact === 'string') {
    enc = compact;
    compact = null;
  }

  if (!this.pub)
    this.pub = this.ec.g.mul(this.priv);

  if (!enc)
    return this.pub;

  return this.pub.encode(enc, compact);
};

KeyPair.prototype.getPrivate = function getPrivate(enc) {
  if (enc === 'hex')
    return this.priv.toString(16, 2);
  else
    return this.priv;
};

KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
  this.priv = new bn(key, enc || 16);

  // Ensure that the priv won't be bigger than n, otherwise we may fail
  // in fixed multiplication method
  this.priv = this.priv.umod(this.ec.curve.n);
};

KeyPair.prototype._importPublic = function _importPublic(key, enc) {
  if (key.x || key.y) {
    this.pub = this.ec.curve.point(key.x, key.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(key, enc);
};

// ECDH
KeyPair.prototype.derive = function derive(pub) {
  return pub.mul(this.priv).getX();
};

// ECDSA
KeyPair.prototype.sign = function sign(msg, enc, options) {
  return this.ec.sign(msg, this, enc, options);
};

KeyPair.prototype.verify = function verify(msg, signature) {
  return this.ec.verify(msg, signature, this);
};

KeyPair.prototype.inspect = function inspect() {
  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +
         ' pub: ' + (this.pub && this.pub.inspect()) + ' >';
};

},{"bn.js":189}],200:[function(require,module,exports){
'use strict';

var bn = require('bn.js');

var elliptic = require('../../elliptic');
var utils = elliptic.utils;
var assert = utils.assert;

function Signature(options, enc) {
  if (options instanceof Signature)
    return options;

  if (this._importDER(options, enc))
    return;

  assert(options.r && options.s, 'Signature without r or s');
  this.r = new bn(options.r, 16);
  this.s = new bn(options.s, 16);
  if (options.recoveryParam !== null)
    this.recoveryParam = options.recoveryParam;
  else
    this.recoveryParam = null;
}
module.exports = Signature;

function Position() {
  this.place = 0;
}

function getLength(buf, p) {
  var initial = buf[p.place++];
  if (!(initial & 0x80)) {
    return initial;
  }
  var octetLen = initial & 0xf;
  var val = 0;
  for (var i = 0, off = p.place; i < octetLen; i++, off++) {
    val <<= 8;
    val |= buf[off];
  }
  p.place = off;
  return val;
}

function rmPadding(buf) {
  var i = 0;
  var len = buf.length - 1;
  while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {
    i++;
  }
  if (i === 0) {
    return buf;
  }
  return buf.slice(i);
}

Signature.prototype._importDER = function _importDER(data, enc) {
  data = utils.toArray(data, enc);
  var p = new Position();
  if (data[p.place++] !== 0x30) {
    return false;
  }
  var len = getLength(data, p);
  if ((len + p.place) !== data.length) {
    return false;
  }
  if (data[p.place++] !== 0x02) {
    return false;
  }
  var rlen = getLength(data, p);
  var r = data.slice(p.place, rlen + p.place);
  p.place += rlen;
  if (data[p.place++] !== 0x02) {
    return false;
  }
  var slen = getLength(data, p);
  if (data.length !== slen + p.place) {
    return false;
  }
  var s = data.slice(p.place, slen + p.place);
  if (r[0] === 0 && (r[1] & 0x80)) {
    r = r.slice(1);
  }
  if (s[0] === 0 && (s[1] & 0x80)) {
    s = s.slice(1);
  }

  this.r = new bn(r);
  this.s = new bn(s);
  this.recoveryParam = null;

  return true;
};

function constructLength(arr, len) {
  if (len < 0x80) {
    arr.push(len);
    return;
  }
  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
  arr.push(octets | 0x80);
  while (--octets) {
    arr.push((len >>> (octets << 3)) & 0xff);
  }
  arr.push(len);
}

Signature.prototype.toDER = function toDER(enc) {
  var r = this.r.toArray();
  var s = this.s.toArray();

  // Pad values
  if (r[0] & 0x80)
    r = [ 0 ].concat(r);
  // Pad values
  if (s[0] & 0x80)
    s = [ 0 ].concat(s);

  r = rmPadding(r);
  s = rmPadding(s);

  while (!s[0] && !(s[1] & 0x80)) {
    s = s.slice(1);
  }
  var arr = [ 0x02 ];
  constructLength(arr, r.length);
  arr = arr.concat(r);
  arr.push(0x02);
  constructLength(arr, s.length);
  var backHalf = arr.concat(s);
  var res = [ 0x30 ];
  constructLength(res, backHalf.length);
  res = res.concat(backHalf);
  return utils.encode(res, enc);
};

},{"../../elliptic":191,"bn.js":189}],201:[function(require,module,exports){
'use strict';

var hash = require('hash.js');
var elliptic = require('../../elliptic');
var utils = elliptic.utils;
var assert = utils.assert;
var parseBytes = utils.parseBytes;
var KeyPair = require('./key');
var Signature = require('./signature');

function EDDSA(curve) {
  assert(curve === 'ed25519', 'only tested with ed25519 so far');

  if (!(this instanceof EDDSA))
    return new EDDSA(curve);

  var curve = elliptic.curves[curve].curve;
  this.curve = curve;
  this.g = curve.g;
  this.g.precompute(curve.n.bitLength() + 1);

  this.pointClass = curve.point().constructor;
  this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
  this.hash = hash.sha512;
}

module.exports = EDDSA;

/**
* @param {Array|String} message - message bytes
* @param {Array|String|KeyPair} secret - secret bytes or a keypair
* @returns {Signature} - signature
*/
EDDSA.prototype.sign = function sign(message, secret) {
  message = parseBytes(message);
  var key = this.keyFromSecret(secret);
  var r = this.hashInt(key.messagePrefix(), message);
  var R = this.g.mul(r);
  var Rencoded = this.encodePoint(R);
  var s_ = this.hashInt(Rencoded, key.pubBytes(), message)
               .mul(key.priv());
  var S = r.add(s_).umod(this.curve.n);
  return this.makeSignature({ R: R, S: S, Rencoded: Rencoded });
};

/**
* @param {Array} message - message bytes
* @param {Array|String|Signature} sig - sig bytes
* @param {Array|String|Point|KeyPair} pub - public key
* @returns {Boolean} - true if public key matches sig of message
*/
EDDSA.prototype.verify = function verify(message, sig, pub) {
  message = parseBytes(message);
  sig = this.makeSignature(sig);
  var key = this.keyFromPublic(pub);
  var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
  var SG = this.g.mul(sig.S());
  var RplusAh = sig.R().add(key.pub().mul(h));
  return RplusAh.eq(SG);
};

EDDSA.prototype.hashInt = function hashInt() {
  var hash = this.hash();
  for (var i = 0; i < arguments.length; i++)
    hash.update(arguments[i]);
  return utils.intFromLE(hash.digest()).umod(this.curve.n);
};

EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
  return KeyPair.fromPublic(this, pub);
};

EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
  return KeyPair.fromSecret(this, secret);
};

EDDSA.prototype.makeSignature = function makeSignature(sig) {
  if (sig instanceof Signature)
    return sig;
  return new Signature(this, sig);
};

/**
* * https://tools.ietf.org/html/draft-josefsson-eddsa-ed25519-03#section-5.2
*
* EDDSA defines methods for encoding and decoding points and integers. These are
* helper convenience methods, that pass along to utility functions implied
* parameters.
*
*/
EDDSA.prototype.encodePoint = function encodePoint(point) {
  var enc = point.getY().toArray('le', this.encodingLength);
  enc[this.encodingLength - 1] |= point.getX().isOdd() ? 0x80 : 0;
  return enc;
};

EDDSA.prototype.decodePoint = function decodePoint(bytes) {
  bytes = utils.parseBytes(bytes);

  var lastIx = bytes.length - 1;
  var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~0x80);
  var xIsOdd = (bytes[lastIx] & 0x80) !== 0;

  var y = utils.intFromLE(normed);
  return this.curve.pointFromY(y, xIsOdd);
};

EDDSA.prototype.encodeInt = function encodeInt(num) {
  return num.toArray('le', this.encodingLength);
};

EDDSA.prototype.decodeInt = function decodeInt(bytes) {
  return utils.intFromLE(bytes);
};

EDDSA.prototype.isPoint = function isPoint(val) {
  return val instanceof this.pointClass;
};

},{"../../elliptic":191,"./key":202,"./signature":203,"hash.js":208}],202:[function(require,module,exports){
'use strict';

var elliptic = require('../../elliptic');
var utils = elliptic.utils;
var assert = utils.assert;
var parseBytes = utils.parseBytes;
var cachedProperty = utils.cachedProperty;

/**
* @param {EDDSA} eddsa - instance
* @param {Object} params - public/private key parameters
*
* @param {Array<Byte>} [params.secret] - secret seed bytes
* @param {Point} [params.pub] - public key point (aka `A` in eddsa terms)
* @param {Array<Byte>} [params.pub] - public key point encoded as bytes
*
*/
function KeyPair(eddsa, params) {
  this.eddsa = eddsa;
  this._secret = parseBytes(params.secret);
  if (eddsa.isPoint(params.pub))
    this._pub = params.pub;
  else
    this._pubBytes = parseBytes(params.pub);
}

KeyPair.fromPublic = function fromPublic(eddsa, pub) {
  if (pub instanceof KeyPair)
    return pub;
  return new KeyPair(eddsa, { pub: pub });
};

KeyPair.fromSecret = function fromSecret(eddsa, secret) {
  if (secret instanceof KeyPair)
    return secret;
  return new KeyPair(eddsa, { secret: secret });
};

KeyPair.prototype.secret = function secret() {
  return this._secret;
};

cachedProperty(KeyPair, function pubBytes() {
  return this.eddsa.encodePoint(this.pub());
});

cachedProperty(KeyPair, function pub() {
  if (this._pubBytes)
    return this.eddsa.decodePoint(this._pubBytes);
  return this.eddsa.g.mul(this.priv());
});

cachedProperty(KeyPair, function privBytes() {
  var eddsa = this.eddsa;
  var hash = this.hash();
  var lastIx = eddsa.encodingLength - 1;

  var a = hash.slice(0, eddsa.encodingLength);
  a[0] &= 248;
  a[lastIx] &= 127;
  a[lastIx] |= 64;

  return a;
});

cachedProperty(KeyPair, function priv() {
  return this.eddsa.decodeInt(this.privBytes());
});

cachedProperty(KeyPair, function hash() {
  return this.eddsa.hash().update(this.secret()).digest();
});

cachedProperty(KeyPair, function messagePrefix() {
  return this.hash().slice(this.eddsa.encodingLength);
});

KeyPair.prototype.sign = function sign(message) {
  assert(this._secret, 'KeyPair can only verify');
  return this.eddsa.sign(message, this);
};

KeyPair.prototype.verify = function verify(message, sig) {
  return this.eddsa.verify(message, sig, this);
};

KeyPair.prototype.getSecret = function getSecret(enc) {
  assert(this._secret, 'KeyPair is public only');
  return utils.encode(this.secret(), enc);
};

KeyPair.prototype.getPublic = function getPublic(enc) {
  return utils.encode(this.pubBytes(), enc);
};

module.exports = KeyPair;

},{"../../elliptic":191}],203:[function(require,module,exports){
'use strict';

var bn = require('bn.js');
var elliptic = require('../../elliptic');
var utils = elliptic.utils;
var assert = utils.assert;
var cachedProperty = utils.cachedProperty;
var parseBytes = utils.parseBytes;

/**
* @param {EDDSA} eddsa - eddsa instance
* @param {Array<Bytes>|Object} sig -
* @param {Array<Bytes>|Point} [sig.R] - R point as Point or bytes
* @param {Array<Bytes>|bn} [sig.S] - S scalar as bn or bytes
* @param {Array<Bytes>} [sig.Rencoded] - R point encoded
* @param {Array<Bytes>} [sig.Sencoded] - S scalar encoded
*/
function Signature(eddsa, sig) {
  this.eddsa = eddsa;

  if (typeof sig !== 'object')
    sig = parseBytes(sig);

  if (Array.isArray(sig)) {
    sig = {
      R: sig.slice(0, eddsa.encodingLength),
      S: sig.slice(eddsa.encodingLength)
    };
  }

  assert(sig.R && sig.S, 'Signature without R or S');

  if (eddsa.isPoint(sig.R))
    this._R = sig.R;
  if (sig.S instanceof bn)
    this._S = sig.S;

  this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
  this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
}

cachedProperty(Signature, function S() {
  return this.eddsa.decodeInt(this.Sencoded());
});

cachedProperty(Signature, function R() {
  return this.eddsa.decodePoint(this.Rencoded());
});

cachedProperty(Signature, function Rencoded() {
  return this.eddsa.encodePoint(this.R());
});

cachedProperty(Signature, function Sencoded() {
  return this.eddsa.encodeInt(this.S());
});

Signature.prototype.toBytes = function toBytes() {
  return this.Rencoded().concat(this.Sencoded());
};

Signature.prototype.toHex = function toHex() {
  return utils.encode(this.toBytes(), 'hex').toUpperCase();
};

module.exports = Signature;

},{"../../elliptic":191,"bn.js":189}],204:[function(require,module,exports){
'use strict';

var hash = require('hash.js');
var elliptic = require('../elliptic');
var utils = elliptic.utils;
var assert = utils.assert;

function HmacDRBG(options) {
  if (!(this instanceof HmacDRBG))
    return new HmacDRBG(options);
  this.hash = options.hash;
  this.predResist = !!options.predResist;

  this.outLen = this.hash.outSize;
  this.minEntropy = options.minEntropy || this.hash.hmacStrength;

  this.reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;

  var entropy = utils.toArray(options.entropy, options.entropyEnc);
  var nonce = utils.toArray(options.nonce, options.nonceEnc);
  var pers = utils.toArray(options.pers, options.persEnc);
  assert(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');
  this._init(entropy, nonce, pers);
}
module.exports = HmacDRBG;

HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
  var seed = entropy.concat(nonce).concat(pers);

  this.K = new Array(this.outLen / 8);
  this.V = new Array(this.outLen / 8);
  for (var i = 0; i < this.V.length; i++) {
    this.K[i] = 0x00;
    this.V[i] = 0x01;
  }

  this._update(seed);
  this.reseed = 1;
  this.reseedInterval = 0x1000000000000;  // 2^48
};

HmacDRBG.prototype._hmac = function hmac() {
  return new hash.hmac(this.hash, this.K);
};

HmacDRBG.prototype._update = function update(seed) {
  var kmac = this._hmac()
                 .update(this.V)
                 .update([ 0x00 ]);
  if (seed)
    kmac = kmac.update(seed);
  this.K = kmac.digest();
  this.V = this._hmac().update(this.V).digest();
  if (!seed)
    return;

  this.K = this._hmac()
               .update(this.V)
               .update([ 0x01 ])
               .update(seed)
               .digest();
  this.V = this._hmac().update(this.V).digest();
};

HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
  // Optional entropy enc
  if (typeof entropyEnc !== 'string') {
    addEnc = add;
    add = entropyEnc;
    entropyEnc = null;
  }

  entropy = utils.toBuffer(entropy, entropyEnc);
  add = utils.toBuffer(add, addEnc);

  assert(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');

  this._update(entropy.concat(add || []));
  this.reseed = 1;
};

HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
  if (this.reseed > this.reseedInterval)
    throw new Error('Reseed is required');

  // Optional encoding
  if (typeof enc !== 'string') {
    addEnc = add;
    add = enc;
    enc = null;
  }

  // Optional additional data
  if (add) {
    add = utils.toArray(add, addEnc);
    this._update(add);
  }

  var temp = [];
  while (temp.length < len) {
    this.V = this._hmac().update(this.V).digest();
    temp = temp.concat(this.V);
  }

  var res = temp.slice(0, len);
  this._update(add);
  this.reseed++;
  return utils.encode(res, enc);
};

},{"../elliptic":191,"hash.js":208}],205:[function(require,module,exports){
module.exports = {
  doubles: {
    step: 4,
    points: [
      [
        'e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a',
        'f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821'
      ],
      [
        '8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508',
        '11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf'
      ],
      [
        '175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739',
        'd3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695'
      ],
      [
        '363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640',
        '4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9'
      ],
      [
        '8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c',
        '4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36'
      ],
      [
        '723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda',
        '96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f'
      ],
      [
        'eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa',
        '5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999'
      ],
      [
        '100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0',
        'cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09'
      ],
      [
        'e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d',
        '9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d'
      ],
      [
        'feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d',
        'e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088'
      ],
      [
        'da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1',
        '9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d'
      ],
      [
        '53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0',
        '5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8'
      ],
      [
        '8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047',
        '10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a'
      ],
      [
        '385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862',
        '283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453'
      ],
      [
        '6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7',
        '7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160'
      ],
      [
        '3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd',
        '56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0'
      ],
      [
        '85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83',
        '7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6'
      ],
      [
        '948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a',
        '53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589'
      ],
      [
        '6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8',
        'bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17'
      ],
      [
        'e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d',
        '4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda'
      ],
      [
        'e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725',
        '7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd'
      ],
      [
        '213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754',
        '4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2'
      ],
      [
        '4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c',
        '17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6'
      ],
      [
        'fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6',
        '6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f'
      ],
      [
        '76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39',
        'c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01'
      ],
      [
        'c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891',
        '893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3'
      ],
      [
        'd895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b',
        'febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f'
      ],
      [
        'b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03',
        '2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7'
      ],
      [
        'e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d',
        'eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78'
      ],
      [
        'a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070',
        '7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1'
      ],
      [
        '90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4',
        'e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150'
      ],
      [
        '8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da',
        '662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82'
      ],
      [
        'e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11',
        '1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc'
      ],
      [
        '8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e',
        'efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b'
      ],
      [
        'e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41',
        '2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51'
      ],
      [
        'b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef',
        '67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45'
      ],
      [
        'd68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8',
        'db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120'
      ],
      [
        '324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d',
        '648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84'
      ],
      [
        '4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96',
        '35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d'
      ],
      [
        '9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd',
        'ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d'
      ],
      [
        '6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5',
        '9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8'
      ],
      [
        'a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266',
        '40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8'
      ],
      [
        '7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71',
        '34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac'
      ],
      [
        '928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac',
        'c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f'
      ],
      [
        '85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751',
        '1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962'
      ],
      [
        'ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e',
        '493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907'
      ],
      [
        '827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241',
        'c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec'
      ],
      [
        'eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3',
        'be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d'
      ],
      [
        'e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f',
        '4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414'
      ],
      [
        '1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19',
        'aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd'
      ],
      [
        '146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be',
        'b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0'
      ],
      [
        'fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9',
        '6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811'
      ],
      [
        'da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2',
        '8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1'
      ],
      [
        'a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13',
        '7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c'
      ],
      [
        '174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c',
        'ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73'
      ],
      [
        '959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba',
        '2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd'
      ],
      [
        'd2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151',
        'e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405'
      ],
      [
        '64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073',
        'd99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589'
      ],
      [
        '8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458',
        '38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e'
      ],
      [
        '13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b',
        '69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27'
      ],
      [
        'bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366',
        'd3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1'
      ],
      [
        '8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa',
        '40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482'
      ],
      [
        '8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0',
        '620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945'
      ],
      [
        'dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787',
        '7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573'
      ],
      [
        'f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e',
        'ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82'
      ]
    ]
  },
  naf: {
    wnd: 7,
    points: [
      [
        'f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9',
        '388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672'
      ],
      [
        '2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4',
        'd8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6'
      ],
      [
        '5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc',
        '6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da'
      ],
      [
        'acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe',
        'cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37'
      ],
      [
        '774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb',
        'd984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b'
      ],
      [
        'f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8',
        'ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81'
      ],
      [
        'd7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e',
        '581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58'
      ],
      [
        'defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34',
        '4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77'
      ],
      [
        '2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c',
        '85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a'
      ],
      [
        '352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5',
        '321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c'
      ],
      [
        '2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f',
        '2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67'
      ],
      [
        '9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714',
        '73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402'
      ],
      [
        'daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729',
        'a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55'
      ],
      [
        'c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db',
        '2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482'
      ],
      [
        '6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4',
        'e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82'
      ],
      [
        '1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5',
        'b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396'
      ],
      [
        '605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479',
        '2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49'
      ],
      [
        '62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d',
        '80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf'
      ],
      [
        '80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f',
        '1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a'
      ],
      [
        '7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb',
        'd0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7'
      ],
      [
        'd528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9',
        'eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933'
      ],
      [
        '49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963',
        '758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a'
      ],
      [
        '77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74',
        '958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6'
      ],
      [
        'f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530',
        'e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37'
      ],
      [
        '463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b',
        '5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e'
      ],
      [
        'f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247',
        'cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6'
      ],
      [
        'caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1',
        'cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476'
      ],
      [
        '2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120',
        '4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40'
      ],
      [
        '7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435',
        '91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61'
      ],
      [
        '754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18',
        '673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683'
      ],
      [
        'e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8',
        '59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5'
      ],
      [
        '186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb',
        '3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b'
      ],
      [
        'df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f',
        '55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417'
      ],
      [
        '5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143',
        'efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868'
      ],
      [
        '290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba',
        'e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a'
      ],
      [
        'af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45',
        'f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6'
      ],
      [
        '766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a',
        '744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996'
      ],
      [
        '59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e',
        'c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e'
      ],
      [
        'f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8',
        'e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d'
      ],
      [
        '7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c',
        '30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2'
      ],
      [
        '948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519',
        'e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e'
      ],
      [
        '7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab',
        '100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437'
      ],
      [
        '3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca',
        'ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311'
      ],
      [
        'd3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf',
        '8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4'
      ],
      [
        '1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610',
        '68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575'
      ],
      [
        '733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4',
        'f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d'
      ],
      [
        '15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c',
        'd56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d'
      ],
      [
        'a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940',
        'edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629'
      ],
      [
        'e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980',
        'a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06'
      ],
      [
        '311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3',
        '66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374'
      ],
      [
        '34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf',
        '9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee'
      ],
      [
        'f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63',
        '4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1'
      ],
      [
        'd7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448',
        'fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b'
      ],
      [
        '32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf',
        '5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661'
      ],
      [
        '7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5',
        '8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6'
      ],
      [
        'ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6',
        '8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e'
      ],
      [
        '16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5',
        '5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d'
      ],
      [
        'eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99',
        'f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc'
      ],
      [
        '78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51',
        'f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4'
      ],
      [
        '494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5',
        '42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c'
      ],
      [
        'a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5',
        '204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b'
      ],
      [
        'c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997',
        '4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913'
      ],
      [
        '841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881',
        '73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154'
      ],
      [
        '5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5',
        '39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865'
      ],
      [
        '36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66',
        'd2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc'
      ],
      [
        '336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726',
        'ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224'
      ],
      [
        '8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede',
        '6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e'
      ],
      [
        '1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94',
        '60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6'
      ],
      [
        '85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31',
        '3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511'
      ],
      [
        '29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51',
        'b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b'
      ],
      [
        'a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252',
        'ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2'
      ],
      [
        '4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5',
        'cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c'
      ],
      [
        'd24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b',
        '6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3'
      ],
      [
        'ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4',
        '322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d'
      ],
      [
        'af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f',
        '6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700'
      ],
      [
        'e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889',
        '2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4'
      ],
      [
        '591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246',
        'b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196'
      ],
      [
        '11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984',
        '998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4'
      ],
      [
        '3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a',
        'b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257'
      ],
      [
        'cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030',
        'bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13'
      ],
      [
        'c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197',
        '6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096'
      ],
      [
        'c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593',
        'c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38'
      ],
      [
        'a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef',
        '21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f'
      ],
      [
        '347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38',
        '60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448'
      ],
      [
        'da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a',
        '49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a'
      ],
      [
        'c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111',
        '5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4'
      ],
      [
        '4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502',
        '7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437'
      ],
      [
        '3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea',
        'be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7'
      ],
      [
        'cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26',
        '8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d'
      ],
      [
        'b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986',
        '39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a'
      ],
      [
        'd4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e',
        '62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54'
      ],
      [
        '48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4',
        '25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77'
      ],
      [
        'dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda',
        'ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517'
      ],
      [
        '6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859',
        'cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10'
      ],
      [
        'e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f',
        'f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125'
      ],
      [
        'eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c',
        '6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e'
      ],
      [
        '13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942',
        'fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1'
      ],
      [
        'ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a',
        '1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2'
      ],
      [
        'b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80',
        '5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423'
      ],
      [
        'ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d',
        '438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8'
      ],
      [
        '8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1',
        'cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758'
      ],
      [
        '52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63',
        'c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375'
      ],
      [
        'e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352',
        '6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d'
      ],
      [
        '7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193',
        'ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec'
      ],
      [
        '5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00',
        '9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0'
      ],
      [
        '32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58',
        'ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c'
      ],
      [
        'e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7',
        'd3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4'
      ],
      [
        '8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8',
        'c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f'
      ],
      [
        '4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e',
        '67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649'
      ],
      [
        '3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d',
        'cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826'
      ],
      [
        '674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b',
        '299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5'
      ],
      [
        'd32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f',
        'f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87'
      ],
      [
        '30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6',
        '462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b'
      ],
      [
        'be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297',
        '62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc'
      ],
      [
        '93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a',
        '7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c'
      ],
      [
        'b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c',
        'ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f'
      ],
      [
        'd5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52',
        '4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a'
      ],
      [
        'd3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb',
        'bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46'
      ],
      [
        '463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065',
        'bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f'
      ],
      [
        '7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917',
        '603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03'
      ],
      [
        '74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9',
        'cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08'
      ],
      [
        '30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3',
        '553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8'
      ],
      [
        '9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57',
        '712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373'
      ],
      [
        '176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66',
        'ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3'
      ],
      [
        '75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8',
        '9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8'
      ],
      [
        '809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721',
        '9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1'
      ],
      [
        '1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180',
        '4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9'
      ]
    ]
  }
};

},{}],206:[function(require,module,exports){
'use strict';

var utils = exports;
var bn = require('bn.js');

utils.assert = function assert(val, msg) {
  if (!val)
    throw new Error(msg || 'Assertion failed');
};

function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg !== 'string') {
    for (var i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
    return res;
  }
  if (!enc) {
    for (var i = 0; i < msg.length; i++) {
      var c = msg.charCodeAt(i);
      var hi = c >> 8;
      var lo = c & 0xff;
      if (hi)
        res.push(hi, lo);
      else
        res.push(lo);
    }
  } else if (enc === 'hex') {
    msg = msg.replace(/[^a-z0-9]+/ig, '');
    if (msg.length % 2 !== 0)
      msg = '0' + msg;
    for (var i = 0; i < msg.length; i += 2)
      res.push(parseInt(msg[i] + msg[i + 1], 16));
  }
  return res;
}
utils.toArray = toArray;

function zero2(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
utils.zero2 = zero2;

function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
utils.toHex = toHex;

utils.encode = function encode(arr, enc) {
  if (enc === 'hex')
    return toHex(arr);
  else
    return arr;
};

// Represent num in a w-NAF form
function getNAF(num, w) {
  var naf = [];
  var ws = 1 << (w + 1);
  var k = num.clone();
  while (k.cmpn(1) >= 0) {
    var z;
    if (k.isOdd()) {
      var mod = k.andln(ws - 1);
      if (mod > (ws >> 1) - 1)
        z = (ws >> 1) - mod;
      else
        z = mod;
      k.isubn(z);
    } else {
      z = 0;
    }
    naf.push(z);

    // Optimization, shift by word if possible
    var shift = (k.cmpn(0) !== 0 && k.andln(ws - 1) === 0) ? (w + 1) : 1;
    for (var i = 1; i < shift; i++)
      naf.push(0);
    k.iushrn(shift);
  }

  return naf;
}
utils.getNAF = getNAF;

// Represent k1, k2 in a Joint Sparse Form
function getJSF(k1, k2) {
  var jsf = [
    [],
    []
  ];

  k1 = k1.clone();
  k2 = k2.clone();
  var d1 = 0;
  var d2 = 0;
  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {

    // First phase
    var m14 = (k1.andln(3) + d1) & 3;
    var m24 = (k2.andln(3) + d2) & 3;
    if (m14 === 3)
      m14 = -1;
    if (m24 === 3)
      m24 = -1;
    var u1;
    if ((m14 & 1) === 0) {
      u1 = 0;
    } else {
      var m8 = (k1.andln(7) + d1) & 7;
      if ((m8 === 3 || m8 === 5) && m24 === 2)
        u1 = -m14;
      else
        u1 = m14;
    }
    jsf[0].push(u1);

    var u2;
    if ((m24 & 1) === 0) {
      u2 = 0;
    } else {
      var m8 = (k2.andln(7) + d2) & 7;
      if ((m8 === 3 || m8 === 5) && m14 === 2)
        u2 = -m24;
      else
        u2 = m24;
    }
    jsf[1].push(u2);

    // Second phase
    if (2 * d1 === u1 + 1)
      d1 = 1 - d1;
    if (2 * d2 === u2 + 1)
      d2 = 1 - d2;
    k1.iushrn(1);
    k2.iushrn(1);
  }

  return jsf;
}
utils.getJSF = getJSF;

function cachedProperty(obj, computer) {
  var name = computer.name;
  var key = '_' + name;
  obj.prototype[name] = function cachedProperty() {
    return this[key] !== undefined ? this[key] :
           this[key] = computer.call(this);
  };
}
utils.cachedProperty = cachedProperty;

function parseBytes(bytes) {
  return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') :
                                     bytes;
}
utils.parseBytes = parseBytes;

function intFromLE(bytes) {
  return new bn(bytes, 'hex', 'le');
}
utils.intFromLE = intFromLE;


},{"bn.js":189}],207:[function(require,module,exports){
var r;

module.exports = function rand(len) {
  if (!r)
    r = new Rand(null);

  return r.generate(len);
};

function Rand(rand) {
  this.rand = rand;
}
module.exports.Rand = Rand;

Rand.prototype.generate = function generate(len) {
  return this._rand(len);
};

if (typeof window === 'object') {
  if (window.crypto && window.crypto.getRandomValues) {
    // Modern browsers
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      window.crypto.getRandomValues(arr);
      return arr;
    };
  } else if (window.msCrypto && window.msCrypto.getRandomValues) {
    // IE
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      window.msCrypto.getRandomValues(arr);
      return arr;
    };
  } else {
    // Old junk
    Rand.prototype._rand = function() {
      throw new Error('Not implemented yet');
    };
  }
} else {
  // Node.js or Web worker
  try {
    var crypto = require('cry' + 'pto');

    Rand.prototype._rand = function _rand(n) {
      return crypto.randomBytes(n);
    };
  } catch (e) {
    // Emulate crypto API using randy
    Rand.prototype._rand = function _rand(n) {
      var res = new Uint8Array(n);
      for (var i = 0; i < res.length; i++)
        res[i] = this.rand.getByte();
      return res;
    };
  }
}

},{}],208:[function(require,module,exports){
var hash = exports;

hash.utils = require('./hash/utils');
hash.common = require('./hash/common');
hash.sha = require('./hash/sha');
hash.ripemd = require('./hash/ripemd');
hash.hmac = require('./hash/hmac');

// Proxy hash functions to the main object
hash.sha1 = hash.sha.sha1;
hash.sha256 = hash.sha.sha256;
hash.sha224 = hash.sha.sha224;
hash.sha384 = hash.sha.sha384;
hash.sha512 = hash.sha.sha512;
hash.ripemd160 = hash.ripemd.ripemd160;

},{"./hash/common":209,"./hash/hmac":210,"./hash/ripemd":211,"./hash/sha":212,"./hash/utils":213}],209:[function(require,module,exports){
var hash = require('../hash');
var utils = hash.utils;
var assert = utils.assert;

function BlockHash() {
  this.pending = null;
  this.pendingTotal = 0;
  this.blockSize = this.constructor.blockSize;
  this.outSize = this.constructor.outSize;
  this.hmacStrength = this.constructor.hmacStrength;
  this.padLength = this.constructor.padLength / 8;
  this.endian = 'big';

  this._delta8 = this.blockSize / 8;
  this._delta32 = this.blockSize / 32;
}
exports.BlockHash = BlockHash;

BlockHash.prototype.update = function update(msg, enc) {
  // Convert message to array, pad it, and join into 32bit blocks
  msg = utils.toArray(msg, enc);
  if (!this.pending)
    this.pending = msg;
  else
    this.pending = this.pending.concat(msg);
  this.pendingTotal += msg.length;

  // Enough data, try updating
  if (this.pending.length >= this._delta8) {
    msg = this.pending;

    // Process pending data in blocks
    var r = msg.length % this._delta8;
    this.pending = msg.slice(msg.length - r, msg.length);
    if (this.pending.length === 0)
      this.pending = null;

    msg = utils.join32(msg, 0, msg.length - r, this.endian);
    for (var i = 0; i < msg.length; i += this._delta32)
      this._update(msg, i, i + this._delta32);
  }

  return this;
};

BlockHash.prototype.digest = function digest(enc) {
  this.update(this._pad());
  assert(this.pending === null);

  return this._digest(enc);
};

BlockHash.prototype._pad = function pad() {
  var len = this.pendingTotal;
  var bytes = this._delta8;
  var k = bytes - ((len + this.padLength) % bytes);
  var res = new Array(k + this.padLength);
  res[0] = 0x80;
  for (var i = 1; i < k; i++)
    res[i] = 0;

  // Append length
  len <<= 3;
  if (this.endian === 'big') {
    for (var t = 8; t < this.padLength; t++)
      res[i++] = 0;

    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = len & 0xff;
  } else {
    res[i++] = len & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;

    for (var t = 8; t < this.padLength; t++)
      res[i++] = 0;
  }

  return res;
};

},{"../hash":208}],210:[function(require,module,exports){
var hmac = exports;

var hash = require('../hash');
var utils = hash.utils;
var assert = utils.assert;

function Hmac(hash, key, enc) {
  if (!(this instanceof Hmac))
    return new Hmac(hash, key, enc);
  this.Hash = hash;
  this.blockSize = hash.blockSize / 8;
  this.outSize = hash.outSize / 8;
  this.inner = null;
  this.outer = null;

  this._init(utils.toArray(key, enc));
}
module.exports = Hmac;

Hmac.prototype._init = function init(key) {
  // Shorten key, if needed
  if (key.length > this.blockSize)
    key = new this.Hash().update(key).digest();
  assert(key.length <= this.blockSize);

  // Add padding to key
  for (var i = key.length; i < this.blockSize; i++)
    key.push(0);

  for (var i = 0; i < key.length; i++)
    key[i] ^= 0x36;
  this.inner = new this.Hash().update(key);

  // 0x36 ^ 0x5c = 0x6a
  for (var i = 0; i < key.length; i++)
    key[i] ^= 0x6a;
  this.outer = new this.Hash().update(key);
};

Hmac.prototype.update = function update(msg, enc) {
  this.inner.update(msg, enc);
  return this;
};

Hmac.prototype.digest = function digest(enc) {
  this.outer.update(this.inner.digest());
  return this.outer.digest(enc);
};

},{"../hash":208}],211:[function(require,module,exports){
var hash = require('../hash');
var utils = hash.utils;

var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_3 = utils.sum32_3;
var sum32_4 = utils.sum32_4;
var BlockHash = hash.common.BlockHash;

function RIPEMD160() {
  if (!(this instanceof RIPEMD160))
    return new RIPEMD160();

  BlockHash.call(this);

  this.h = [ 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0 ];
  this.endian = 'little';
}
utils.inherits(RIPEMD160, BlockHash);
exports.ripemd160 = RIPEMD160;

RIPEMD160.blockSize = 512;
RIPEMD160.outSize = 160;
RIPEMD160.hmacStrength = 192;
RIPEMD160.padLength = 64;

RIPEMD160.prototype._update = function update(msg, start) {
  var A = this.h[0];
  var B = this.h[1];
  var C = this.h[2];
  var D = this.h[3];
  var E = this.h[4];
  var Ah = A;
  var Bh = B;
  var Ch = C;
  var Dh = D;
  var Eh = E;
  for (var j = 0; j < 80; j++) {
    var T = sum32(
      rotl32(
        sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)),
        s[j]),
      E);
    A = E;
    E = D;
    D = rotl32(C, 10);
    C = B;
    B = T;
    T = sum32(
      rotl32(
        sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),
        sh[j]),
      Eh);
    Ah = Eh;
    Eh = Dh;
    Dh = rotl32(Ch, 10);
    Ch = Bh;
    Bh = T;
  }
  T = sum32_3(this.h[1], C, Dh);
  this.h[1] = sum32_3(this.h[2], D, Eh);
  this.h[2] = sum32_3(this.h[3], E, Ah);
  this.h[3] = sum32_3(this.h[4], A, Bh);
  this.h[4] = sum32_3(this.h[0], B, Ch);
  this.h[0] = T;
};

RIPEMD160.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'little');
  else
    return utils.split32(this.h, 'little');
};

function f(j, x, y, z) {
  if (j <= 15)
    return x ^ y ^ z;
  else if (j <= 31)
    return (x & y) | ((~x) & z);
  else if (j <= 47)
    return (x | (~y)) ^ z;
  else if (j <= 63)
    return (x & z) | (y & (~z));
  else
    return x ^ (y | (~z));
}

function K(j) {
  if (j <= 15)
    return 0x00000000;
  else if (j <= 31)
    return 0x5a827999;
  else if (j <= 47)
    return 0x6ed9eba1;
  else if (j <= 63)
    return 0x8f1bbcdc;
  else
    return 0xa953fd4e;
}

function Kh(j) {
  if (j <= 15)
    return 0x50a28be6;
  else if (j <= 31)
    return 0x5c4dd124;
  else if (j <= 47)
    return 0x6d703ef3;
  else if (j <= 63)
    return 0x7a6d76e9;
  else
    return 0x00000000;
}

var r = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
];

var rh = [
  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
];

var s = [
  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
];

var sh = [
  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
];

},{"../hash":208}],212:[function(require,module,exports){
var hash = require('../hash');
var utils = hash.utils;
var assert = utils.assert;

var rotr32 = utils.rotr32;
var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_4 = utils.sum32_4;
var sum32_5 = utils.sum32_5;
var rotr64_hi = utils.rotr64_hi;
var rotr64_lo = utils.rotr64_lo;
var shr64_hi = utils.shr64_hi;
var shr64_lo = utils.shr64_lo;
var sum64 = utils.sum64;
var sum64_hi = utils.sum64_hi;
var sum64_lo = utils.sum64_lo;
var sum64_4_hi = utils.sum64_4_hi;
var sum64_4_lo = utils.sum64_4_lo;
var sum64_5_hi = utils.sum64_5_hi;
var sum64_5_lo = utils.sum64_5_lo;
var BlockHash = hash.common.BlockHash;

var sha256_K = [
  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
  0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
  0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
  0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
  0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
  0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
  0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
  0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
  0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
];

var sha512_K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
];

var sha1_K = [
  0x5A827999, 0x6ED9EBA1,
  0x8F1BBCDC, 0xCA62C1D6
];

function SHA256() {
  if (!(this instanceof SHA256))
    return new SHA256();

  BlockHash.call(this);
  this.h = [ 0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
             0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19 ];
  this.k = sha256_K;
  this.W = new Array(64);
}
utils.inherits(SHA256, BlockHash);
exports.sha256 = SHA256;

SHA256.blockSize = 512;
SHA256.outSize = 256;
SHA256.hmacStrength = 192;
SHA256.padLength = 64;

SHA256.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];
  for (; i < W.length; i++)
    W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];
  var f = this.h[5];
  var g = this.h[6];
  var h = this.h[7];

  assert(this.k.length === W.length);
  for (var i = 0; i < W.length; i++) {
    var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
    var T2 = sum32(s0_256(a), maj32(a, b, c));
    h = g;
    g = f;
    f = e;
    e = sum32(d, T1);
    d = c;
    c = b;
    b = a;
    a = sum32(T1, T2);
  }

  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
  this.h[5] = sum32(this.h[5], f);
  this.h[6] = sum32(this.h[6], g);
  this.h[7] = sum32(this.h[7], h);
};

SHA256.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};

function SHA224() {
  if (!(this instanceof SHA224))
    return new SHA224();

  SHA256.call(this);
  this.h = [ 0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
             0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4 ];
}
utils.inherits(SHA224, SHA256);
exports.sha224 = SHA224;

SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;

SHA224.prototype._digest = function digest(enc) {
  // Just truncate output
  if (enc === 'hex')
    return utils.toHex32(this.h.slice(0, 7), 'big');
  else
    return utils.split32(this.h.slice(0, 7), 'big');
};

function SHA512() {
  if (!(this instanceof SHA512))
    return new SHA512();

  BlockHash.call(this);
  this.h = [ 0x6a09e667, 0xf3bcc908,
             0xbb67ae85, 0x84caa73b,
             0x3c6ef372, 0xfe94f82b,
             0xa54ff53a, 0x5f1d36f1,
             0x510e527f, 0xade682d1,
             0x9b05688c, 0x2b3e6c1f,
             0x1f83d9ab, 0xfb41bd6b,
             0x5be0cd19, 0x137e2179 ];
  this.k = sha512_K;
  this.W = new Array(160);
}
utils.inherits(SHA512, BlockHash);
exports.sha512 = SHA512;

SHA512.blockSize = 1024;
SHA512.outSize = 512;
SHA512.hmacStrength = 192;
SHA512.padLength = 128;

SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
  var W = this.W;

  // 32 x 32bit words
  for (var i = 0; i < 32; i++)
    W[i] = msg[start + i];
  for (; i < W.length; i += 2) {
    var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);  // i - 2
    var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
    var c1_hi = W[i - 14];  // i - 7
    var c1_lo = W[i - 13];
    var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);  // i - 15
    var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
    var c3_hi = W[i - 32];  // i - 16
    var c3_lo = W[i - 31];

    W[i] = sum64_4_hi(c0_hi, c0_lo,
                      c1_hi, c1_lo,
                      c2_hi, c2_lo,
                      c3_hi, c3_lo);
    W[i + 1] = sum64_4_lo(c0_hi, c0_lo,
                          c1_hi, c1_lo,
                          c2_hi, c2_lo,
                          c3_hi, c3_lo);
  }
};

SHA512.prototype._update = function _update(msg, start) {
  this._prepareBlock(msg, start);

  var W = this.W;

  var ah = this.h[0];
  var al = this.h[1];
  var bh = this.h[2];
  var bl = this.h[3];
  var ch = this.h[4];
  var cl = this.h[5];
  var dh = this.h[6];
  var dl = this.h[7];
  var eh = this.h[8];
  var el = this.h[9];
  var fh = this.h[10];
  var fl = this.h[11];
  var gh = this.h[12];
  var gl = this.h[13];
  var hh = this.h[14];
  var hl = this.h[15];

  assert(this.k.length === W.length);
  for (var i = 0; i < W.length; i += 2) {
    var c0_hi = hh;
    var c0_lo = hl;
    var c1_hi = s1_512_hi(eh, el);
    var c1_lo = s1_512_lo(eh, el);
    var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
    var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
    var c3_hi = this.k[i];
    var c3_lo = this.k[i + 1];
    var c4_hi = W[i];
    var c4_lo = W[i + 1];

    var T1_hi = sum64_5_hi(c0_hi, c0_lo,
                           c1_hi, c1_lo,
                           c2_hi, c2_lo,
                           c3_hi, c3_lo,
                           c4_hi, c4_lo);
    var T1_lo = sum64_5_lo(c0_hi, c0_lo,
                           c1_hi, c1_lo,
                           c2_hi, c2_lo,
                           c3_hi, c3_lo,
                           c4_hi, c4_lo);

    var c0_hi = s0_512_hi(ah, al);
    var c0_lo = s0_512_lo(ah, al);
    var c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
    var c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);

    var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
    var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);

    hh = gh;
    hl = gl;

    gh = fh;
    gl = fl;

    fh = eh;
    fl = el;

    eh = sum64_hi(dh, dl, T1_hi, T1_lo);
    el = sum64_lo(dl, dl, T1_hi, T1_lo);

    dh = ch;
    dl = cl;

    ch = bh;
    cl = bl;

    bh = ah;
    bl = al;

    ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
    al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
  }

  sum64(this.h, 0, ah, al);
  sum64(this.h, 2, bh, bl);
  sum64(this.h, 4, ch, cl);
  sum64(this.h, 6, dh, dl);
  sum64(this.h, 8, eh, el);
  sum64(this.h, 10, fh, fl);
  sum64(this.h, 12, gh, gl);
  sum64(this.h, 14, hh, hl);
};

SHA512.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};

function SHA384() {
  if (!(this instanceof SHA384))
    return new SHA384();

  SHA512.call(this);
  this.h = [ 0xcbbb9d5d, 0xc1059ed8,
             0x629a292a, 0x367cd507,
             0x9159015a, 0x3070dd17,
             0x152fecd8, 0xf70e5939,
             0x67332667, 0xffc00b31,
             0x8eb44a87, 0x68581511,
             0xdb0c2e0d, 0x64f98fa7,
             0x47b5481d, 0xbefa4fa4 ];
}
utils.inherits(SHA384, SHA512);
exports.sha384 = SHA384;

SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;

SHA384.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h.slice(0, 12), 'big');
  else
    return utils.split32(this.h.slice(0, 12), 'big');
};

function SHA1() {
  if (!(this instanceof SHA1))
    return new SHA1();

  BlockHash.call(this);
  this.h = [ 0x67452301, 0xefcdab89, 0x98badcfe,
             0x10325476, 0xc3d2e1f0 ];
  this.W = new Array(80);
}

utils.inherits(SHA1, BlockHash);
exports.sha1 = SHA1;

SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;

SHA1.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];

  for(; i < W.length; i++)
    W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];

  for (var i = 0; i < W.length; i++) {
    var s = ~~(i / 20);
    var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
    e = d;
    d = c;
    c = rotl32(b, 30);
    b = a;
    a = t;
  }

  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
};

SHA1.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};

function ch32(x, y, z) {
  return (x & y) ^ ((~x) & z);
}

function maj32(x, y, z) {
  return (x & y) ^ (x & z) ^ (y & z);
}

function p32(x, y, z) {
  return x ^ y ^ z;
}

function s0_256(x) {
  return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
}

function s1_256(x) {
  return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
}

function g0_256(x) {
  return rotr32(x, 7) ^ rotr32(x, 18) ^ (x >>> 3);
}

function g1_256(x) {
  return rotr32(x, 17) ^ rotr32(x, 19) ^ (x >>> 10);
}

function ft_1(s, x, y, z) {
  if (s === 0)
    return ch32(x, y, z);
  if (s === 1 || s === 3)
    return p32(x, y, z);
  if (s === 2)
    return maj32(x, y, z);
}

function ch64_hi(xh, xl, yh, yl, zh, zl) {
  var r = (xh & yh) ^ ((~xh) & zh);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function ch64_lo(xh, xl, yh, yl, zh, zl) {
  var r = (xl & yl) ^ ((~xl) & zl);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function maj64_hi(xh, xl, yh, yl, zh, zl) {
  var r = (xh & yh) ^ (xh & zh) ^ (yh & zh);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function maj64_lo(xh, xl, yh, yl, zh, zl) {
  var r = (xl & yl) ^ (xl & zl) ^ (yl & zl);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 28);
  var c1_hi = rotr64_hi(xl, xh, 2);  // 34
  var c2_hi = rotr64_hi(xl, xh, 7);  // 39

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 28);
  var c1_lo = rotr64_lo(xl, xh, 2);  // 34
  var c2_lo = rotr64_lo(xl, xh, 7);  // 39

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 14);
  var c1_hi = rotr64_hi(xh, xl, 18);
  var c2_hi = rotr64_hi(xl, xh, 9);  // 41

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 14);
  var c1_lo = rotr64_lo(xh, xl, 18);
  var c2_lo = rotr64_lo(xl, xh, 9);  // 41

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 1);
  var c1_hi = rotr64_hi(xh, xl, 8);
  var c2_hi = shr64_hi(xh, xl, 7);

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 1);
  var c1_lo = rotr64_lo(xh, xl, 8);
  var c2_lo = shr64_lo(xh, xl, 7);

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 19);
  var c1_hi = rotr64_hi(xl, xh, 29);  // 61
  var c2_hi = shr64_hi(xh, xl, 6);

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 19);
  var c1_lo = rotr64_lo(xl, xh, 29);  // 61
  var c2_lo = shr64_lo(xh, xl, 6);

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

},{"../hash":208}],213:[function(require,module,exports){
var utils = exports;
var inherits = require('inherits');

function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg === 'string') {
    if (!enc) {
      for (var i = 0; i < msg.length; i++) {
        var c = msg.charCodeAt(i);
        var hi = c >> 8;
        var lo = c & 0xff;
        if (hi)
          res.push(hi, lo);
        else
          res.push(lo);
      }
    } else if (enc === 'hex') {
      msg = msg.replace(/[^a-z0-9]+/ig, '');
      if (msg.length % 2 !== 0)
        msg = '0' + msg;
      for (var i = 0; i < msg.length; i += 2)
        res.push(parseInt(msg[i] + msg[i + 1], 16));
    }
  } else {
    for (var i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
  }
  return res;
}
utils.toArray = toArray;

function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
utils.toHex = toHex;

function htonl(w) {
  var res = (w >>> 24) |
            ((w >>> 8) & 0xff00) |
            ((w << 8) & 0xff0000) |
            ((w & 0xff) << 24);
  return res >>> 0;
}
utils.htonl = htonl;

function toHex32(msg, endian) {
  var res = '';
  for (var i = 0; i < msg.length; i++) {
    var w = msg[i];
    if (endian === 'little')
      w = htonl(w);
    res += zero8(w.toString(16));
  }
  return res;
}
utils.toHex32 = toHex32;

function zero2(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
utils.zero2 = zero2;

function zero8(word) {
  if (word.length === 7)
    return '0' + word;
  else if (word.length === 6)
    return '00' + word;
  else if (word.length === 5)
    return '000' + word;
  else if (word.length === 4)
    return '0000' + word;
  else if (word.length === 3)
    return '00000' + word;
  else if (word.length === 2)
    return '000000' + word;
  else if (word.length === 1)
    return '0000000' + word;
  else
    return word;
}
utils.zero8 = zero8;

function join32(msg, start, end, endian) {
  var len = end - start;
  assert(len % 4 === 0);
  var res = new Array(len / 4);
  for (var i = 0, k = start; i < res.length; i++, k += 4) {
    var w;
    if (endian === 'big')
      w = (msg[k] << 24) | (msg[k + 1] << 16) | (msg[k + 2] << 8) | msg[k + 3];
    else
      w = (msg[k + 3] << 24) | (msg[k + 2] << 16) | (msg[k + 1] << 8) | msg[k];
    res[i] = w >>> 0;
  }
  return res;
}
utils.join32 = join32;

function split32(msg, endian) {
  var res = new Array(msg.length * 4);
  for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
    var m = msg[i];
    if (endian === 'big') {
      res[k] = m >>> 24;
      res[k + 1] = (m >>> 16) & 0xff;
      res[k + 2] = (m >>> 8) & 0xff;
      res[k + 3] = m & 0xff;
    } else {
      res[k + 3] = m >>> 24;
      res[k + 2] = (m >>> 16) & 0xff;
      res[k + 1] = (m >>> 8) & 0xff;
      res[k] = m & 0xff;
    }
  }
  return res;
}
utils.split32 = split32;

function rotr32(w, b) {
  return (w >>> b) | (w << (32 - b));
}
utils.rotr32 = rotr32;

function rotl32(w, b) {
  return (w << b) | (w >>> (32 - b));
}
utils.rotl32 = rotl32;

function sum32(a, b) {
  return (a + b) >>> 0;
}
utils.sum32 = sum32;

function sum32_3(a, b, c) {
  return (a + b + c) >>> 0;
}
utils.sum32_3 = sum32_3;

function sum32_4(a, b, c, d) {
  return (a + b + c + d) >>> 0;
}
utils.sum32_4 = sum32_4;

function sum32_5(a, b, c, d, e) {
  return (a + b + c + d + e) >>> 0;
}
utils.sum32_5 = sum32_5;

function assert(cond, msg) {
  if (!cond)
    throw new Error(msg || 'Assertion failed');
}
utils.assert = assert;

utils.inherits = inherits;

function sum64(buf, pos, ah, al) {
  var bh = buf[pos];
  var bl = buf[pos + 1];

  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  buf[pos] = hi >>> 0;
  buf[pos + 1] = lo;
}
exports.sum64 = sum64;

function sum64_hi(ah, al, bh, bl) {
  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  return hi >>> 0;
};
exports.sum64_hi = sum64_hi;

function sum64_lo(ah, al, bh, bl) {
  var lo = al + bl;
  return lo >>> 0;
};
exports.sum64_lo = sum64_lo;

function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;

  var hi = ah + bh + ch + dh + carry;
  return hi >>> 0;
};
exports.sum64_4_hi = sum64_4_hi;

function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
  var lo = al + bl + cl + dl;
  return lo >>> 0;
};
exports.sum64_4_lo = sum64_4_lo;

function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;
  lo = (lo + el) >>> 0;
  carry += lo < el ? 1 : 0;

  var hi = ah + bh + ch + dh + eh + carry;
  return hi >>> 0;
};
exports.sum64_5_hi = sum64_5_hi;

function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var lo = al + bl + cl + dl + el;

  return lo >>> 0;
};
exports.sum64_5_lo = sum64_5_lo;

function rotr64_hi(ah, al, num) {
  var r = (al << (32 - num)) | (ah >>> num);
  return r >>> 0;
};
exports.rotr64_hi = rotr64_hi;

function rotr64_lo(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
};
exports.rotr64_lo = rotr64_lo;

function shr64_hi(ah, al, num) {
  return ah >>> num;
};
exports.shr64_hi = shr64_hi;

function shr64_lo(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
};
exports.shr64_lo = shr64_lo;

},{"inherits":349}],214:[function(require,module,exports){
module.exports={
  "name": "elliptic",
  "version": "6.0.2",
  "description": "EC cryptography",
  "main": "lib/elliptic.js",
  "files": [
    "lib"
  ],
  "scripts": {
    "test": "make lint && istanbul test _mocha --reporter=spec test/*-test.js",
    "coveralls": "cat ./coverage/lcov.info | coveralls"
  },
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/indutny/elliptic.git"
  },
  "keywords": [
    "EC",
    "Elliptic",
    "curve",
    "Cryptography"
  ],
  "author": {
    "name": "Fedor Indutny",
    "email": "fedor@indutny.com"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/indutny/elliptic/issues"
  },
  "homepage": "https://github.com/indutny/elliptic",
  "devDependencies": {
    "browserify": "^3.44.2",
    "coveralls": "^2.11.3",
    "istanbul": "^0.3.17",
    "jscs": "^1.11.3",
    "jshint": "^2.6.0",
    "mocha": "^2.1.0",
    "uglify-js": "^2.4.13"
  },
  "dependencies": {
    "bn.js": "^4.0.0",
    "brorand": "^1.0.1",
    "hash.js": "^1.0.0",
    "inherits": "^2.0.1"
  },
  "gitHead": "330106da186712d228d79bc71ae8e7e68565fa9d",
  "_id": "elliptic@6.0.2",
  "_shasum": "219b96cd92aa9885d91d31c1fd42eaa5eb4483a9",
  "_from": "elliptic@>=6.0.0 <7.0.0",
  "_npmVersion": "3.3.6",
  "_nodeVersion": "5.0.0",
  "_npmUser": {
    "name": "indutny",
    "email": "fedor@indutny.com"
  },
  "dist": {
    "shasum": "219b96cd92aa9885d91d31c1fd42eaa5eb4483a9",
    "tarball": "http://registry.npmjs.org/elliptic/-/elliptic-6.0.2.tgz"
  },
  "maintainers": [
    {
      "name": "indutny",
      "email": "fedor@indutny.com"
    }
  ],
  "directories": {},
  "_resolved": "https://registry.npmjs.org/elliptic/-/elliptic-6.0.2.tgz",
  "readme": "ERROR: No README data found!"
}

},{}],215:[function(require,module,exports){
module.exports={"2.16.840.1.101.3.4.1.1": "aes-128-ecb",
"2.16.840.1.101.3.4.1.2": "aes-128-cbc",
"2.16.840.1.101.3.4.1.3": "aes-128-ofb",
"2.16.840.1.101.3.4.1.4": "aes-128-cfb",
"2.16.840.1.101.3.4.1.21": "aes-192-ecb",
"2.16.840.1.101.3.4.1.22": "aes-192-cbc",
"2.16.840.1.101.3.4.1.23": "aes-192-ofb",
"2.16.840.1.101.3.4.1.24": "aes-192-cfb",
"2.16.840.1.101.3.4.1.41": "aes-256-ecb",
"2.16.840.1.101.3.4.1.42": "aes-256-cbc",
"2.16.840.1.101.3.4.1.43": "aes-256-ofb",
"2.16.840.1.101.3.4.1.44": "aes-256-cfb"
}
},{}],216:[function(require,module,exports){
// from https://github.com/indutny/self-signed/blob/gh-pages/lib/asn1.js
// Fedor, you are amazing.

var asn1 = require('asn1.js')

var RSAPrivateKey = asn1.define('RSAPrivateKey', function () {
  this.seq().obj(
    this.key('version').int(),
    this.key('modulus').int(),
    this.key('publicExponent').int(),
    this.key('privateExponent').int(),
    this.key('prime1').int(),
    this.key('prime2').int(),
    this.key('exponent1').int(),
    this.key('exponent2').int(),
    this.key('coefficient').int()
  )
})
exports.RSAPrivateKey = RSAPrivateKey

var RSAPublicKey = asn1.define('RSAPublicKey', function () {
  this.seq().obj(
    this.key('modulus').int(),
    this.key('publicExponent').int()
  )
})
exports.RSAPublicKey = RSAPublicKey

var PublicKey = asn1.define('SubjectPublicKeyInfo', function () {
  this.seq().obj(
    this.key('algorithm').use(AlgorithmIdentifier),
    this.key('subjectPublicKey').bitstr()
  )
})
exports.PublicKey = PublicKey

var AlgorithmIdentifier = asn1.define('AlgorithmIdentifier', function () {
  this.seq().obj(
    this.key('algorithm').objid(),
    this.key('none').null_().optional(),
    this.key('curve').objid().optional(),
    this.key('params').seq().obj(
      this.key('p').int(),
      this.key('q').int(),
      this.key('g').int()
    ).optional()
  )
})

var PrivateKeyInfo = asn1.define('PrivateKeyInfo', function () {
  this.seq().obj(
    this.key('version').int(),
    this.key('algorithm').use(AlgorithmIdentifier),
    this.key('subjectPrivateKey').octstr()
  )
})
exports.PrivateKey = PrivateKeyInfo
var EncryptedPrivateKeyInfo = asn1.define('EncryptedPrivateKeyInfo', function () {
  this.seq().obj(
    this.key('algorithm').seq().obj(
      this.key('id').objid(),
      this.key('decrypt').seq().obj(
        this.key('kde').seq().obj(
          this.key('id').objid(),
          this.key('kdeparams').seq().obj(
            this.key('salt').octstr(),
            this.key('iters').int()
          )
        ),
        this.key('cipher').seq().obj(
          this.key('algo').objid(),
          this.key('iv').octstr()
        )
      )
    ),
    this.key('subjectPrivateKey').octstr()
  )
})

exports.EncryptedPrivateKey = EncryptedPrivateKeyInfo

var DSAPrivateKey = asn1.define('DSAPrivateKey', function () {
  this.seq().obj(
    this.key('version').int(),
    this.key('p').int(),
    this.key('q').int(),
    this.key('g').int(),
    this.key('pub_key').int(),
    this.key('priv_key').int()
  )
})
exports.DSAPrivateKey = DSAPrivateKey

exports.DSAparam = asn1.define('DSAparam', function () {
  this.int()
})
var ECPrivateKey = asn1.define('ECPrivateKey', function () {
  this.seq().obj(
    this.key('version').int(),
    this.key('privateKey').octstr(),
    this.key('parameters').optional().explicit(0).use(ECParameters),
    this.key('publicKey').optional().explicit(1).bitstr()
  )
})
exports.ECPrivateKey = ECPrivateKey
var ECParameters = asn1.define('ECParameters', function () {
  this.choice({
    namedCurve: this.objid()
  })
})

exports.signature = asn1.define('signature', function () {
  this.seq().obj(
    this.key('r').int(),
    this.key('s').int()
  )
})

},{"asn1.js":219}],217:[function(require,module,exports){
(function (Buffer){
// adapted from https://github.com/apatil/pemstrip
var findProc = /Proc-Type: 4,ENCRYPTED\r?\nDEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)\r?\n\r?\n([0-9A-z\n\r\+\/\=]+)\r?\n/m
var startRegex = /^-----BEGIN (.*) KEY-----\r?\n/m
var fullRegex = /^-----BEGIN (.*) KEY-----\r?\n([0-9A-z\n\r\+\/\=]+)\r?\n-----END \1 KEY-----$/m
var evp = require('evp_bytestokey')
var ciphers = require('browserify-aes')
module.exports = function (okey, password) {
  var key = okey.toString()
  var match = key.match(findProc)
  var decrypted
  if (!match) {
    var match2 = key.match(fullRegex)
    decrypted = new Buffer(match2[2].replace(/\r?\n/g, ''), 'base64')
  } else {
    var suite = 'aes' + match[1]
    var iv = new Buffer(match[2], 'hex')
    var cipherText = new Buffer(match[3].replace(/\r?\n/g, ''), 'base64')
    var cipherKey = evp(password, iv.slice(0, 8), parseInt(match[1], 10)).key
    var out = []
    var cipher = ciphers.createDecipheriv(suite, cipherKey, iv)
    out.push(cipher.update(cipherText))
    out.push(cipher.final())
    decrypted = Buffer.concat(out)
  }
  var tag = key.match(startRegex)[1] + ' KEY'
  return {
    tag: tag,
    data: decrypted
  }
}

}).call(this,require("buffer").Buffer)

},{"browserify-aes":236,"buffer":152,"evp_bytestokey":251}],218:[function(require,module,exports){
(function (Buffer){
var asn1 = require('./asn1')
var aesid = require('./aesid.json')
var fixProc = require('./fixProc')
var ciphers = require('browserify-aes')
var compat = require('pbkdf2')
module.exports = parseKeys

function parseKeys (buffer) {
  var password
  if (typeof buffer === 'object' && !Buffer.isBuffer(buffer)) {
    password = buffer.passphrase
    buffer = buffer.key
  }
  if (typeof buffer === 'string') {
    buffer = new Buffer(buffer)
  }

  var stripped = fixProc(buffer, password)

  var type = stripped.tag
  var data = stripped.data
  var subtype, ndata
  switch (type) {
    case 'PUBLIC KEY':
      ndata = asn1.PublicKey.decode(data, 'der')
      subtype = ndata.algorithm.algorithm.join('.')
      switch (subtype) {
        case '1.2.840.113549.1.1.1':
          return asn1.RSAPublicKey.decode(ndata.subjectPublicKey.data, 'der')
        case '1.2.840.10045.2.1':
          ndata.subjectPrivateKey = ndata.subjectPublicKey
          return {
            type: 'ec',
            data: ndata
          }
        case '1.2.840.10040.4.1':
          ndata.algorithm.params.pub_key = asn1.DSAparam.decode(ndata.subjectPublicKey.data, 'der')
          return {
            type: 'dsa',
            data: ndata.algorithm.params
          }
        default: throw new Error('unknown key id ' + subtype)
      }
      throw new Error('unknown key type ' + type)
    case 'ENCRYPTED PRIVATE KEY':
      data = asn1.EncryptedPrivateKey.decode(data, 'der')
      data = decrypt(data, password)
      // falls through
    case 'PRIVATE KEY':
      ndata = asn1.PrivateKey.decode(data, 'der')
      subtype = ndata.algorithm.algorithm.join('.')
      switch (subtype) {
        case '1.2.840.113549.1.1.1':
          return asn1.RSAPrivateKey.decode(ndata.subjectPrivateKey, 'der')
        case '1.2.840.10045.2.1':
          return {
            curve: ndata.algorithm.curve,
            privateKey: asn1.ECPrivateKey.decode(ndata.subjectPrivateKey, 'der').privateKey
          }
        case '1.2.840.10040.4.1':
          ndata.algorithm.params.priv_key = asn1.DSAparam.decode(ndata.subjectPrivateKey, 'der')
          return {
            type: 'dsa',
            params: ndata.algorithm.params
          }
        default: throw new Error('unknown key id ' + subtype)
      }
      throw new Error('unknown key type ' + type)
    case 'RSA PUBLIC KEY':
      return asn1.RSAPublicKey.decode(data, 'der')
    case 'RSA PRIVATE KEY':
      return asn1.RSAPrivateKey.decode(data, 'der')
    case 'DSA PRIVATE KEY':
      return {
        type: 'dsa',
        params: asn1.DSAPrivateKey.decode(data, 'der')
      }
    case 'EC PRIVATE KEY':
      data = asn1.ECPrivateKey.decode(data, 'der')
      return {
        curve: data.parameters.value,
        privateKey: data.privateKey
      }
    default: throw new Error('unknown key type ' + type)
  }
}
parseKeys.signature = asn1.signature
function decrypt (data, password) {
  var salt = data.algorithm.decrypt.kde.kdeparams.salt
  var iters = parseInt(data.algorithm.decrypt.kde.kdeparams.iters.toString(), 10)
  var algo = aesid[data.algorithm.decrypt.cipher.algo.join('.')]
  var iv = data.algorithm.decrypt.cipher.iv
  var cipherText = data.subjectPrivateKey
  var keylen = parseInt(algo.split('-')[1], 10) / 8
  var key = compat.pbkdf2Sync(password, salt, iters, keylen)
  var cipher = ciphers.createDecipheriv(algo, key, iv)
  var out = []
  out.push(cipher.update(cipherText))
  out.push(cipher.final())
  return Buffer.concat(out)
}

}).call(this,require("buffer").Buffer)

},{"./aesid.json":215,"./asn1":216,"./fixProc":217,"browserify-aes":236,"buffer":152,"pbkdf2":301}],219:[function(require,module,exports){
var asn1 = exports;

asn1.bignum = require('bn.js');

asn1.define = require('./asn1/api').define;
asn1.base = require('./asn1/base');
asn1.constants = require('./asn1/constants');
asn1.decoders = require('./asn1/decoders');
asn1.encoders = require('./asn1/encoders');

},{"./asn1/api":220,"./asn1/base":222,"./asn1/constants":226,"./asn1/decoders":228,"./asn1/encoders":231,"bn.js":189}],220:[function(require,module,exports){
var asn1 = require('../asn1');
var inherits = require('inherits');

var api = exports;

api.define = function define(name, body) {
  return new Entity(name, body);
};

function Entity(name, body) {
  this.name = name;
  this.body = body;

  this.decoders = {};
  this.encoders = {};
};

Entity.prototype._createNamed = function createNamed(base) {
  var named;
  try {
    named = require('vm').runInThisContext(
      '(function ' + this.name + '(entity) {\n' +
      '  this._initNamed(entity);\n' +
      '})'
    );
  } catch (e) {
    named = function (entity) {
      this._initNamed(entity);
    };
  }
  inherits(named, base);
  named.prototype._initNamed = function initnamed(entity) {
    base.call(this, entity);
  };

  return new named(this);
};

Entity.prototype._getDecoder = function _getDecoder(enc) {
  // Lazily create decoder
  if (!this.decoders.hasOwnProperty(enc))
    this.decoders[enc] = this._createNamed(asn1.decoders[enc]);
  return this.decoders[enc];
};

Entity.prototype.decode = function decode(data, enc, options) {
  return this._getDecoder(enc).decode(data, options);
};

Entity.prototype._getEncoder = function _getEncoder(enc) {
  // Lazily create encoder
  if (!this.encoders.hasOwnProperty(enc))
    this.encoders[enc] = this._createNamed(asn1.encoders[enc]);
  return this.encoders[enc];
};

Entity.prototype.encode = function encode(data, enc, /* internal */ reporter) {
  return this._getEncoder(enc).encode(data, reporter);
};

},{"../asn1":219,"inherits":349,"vm":368}],221:[function(require,module,exports){
var inherits = require('inherits');
var Reporter = require('../base').Reporter;
var Buffer = require('buffer').Buffer;

function DecoderBuffer(base, options) {
  Reporter.call(this, options);
  if (!Buffer.isBuffer(base)) {
    this.error('Input not Buffer');
    return;
  }

  this.base = base;
  this.offset = 0;
  this.length = base.length;
}
inherits(DecoderBuffer, Reporter);
exports.DecoderBuffer = DecoderBuffer;

DecoderBuffer.prototype.save = function save() {
  return { offset: this.offset, reporter: Reporter.prototype.save.call(this) };
};

DecoderBuffer.prototype.restore = function restore(save) {
  // Return skipped data
  var res = new DecoderBuffer(this.base);
  res.offset = save.offset;
  res.length = this.offset;

  this.offset = save.offset;
  Reporter.prototype.restore.call(this, save.reporter);

  return res;
};

DecoderBuffer.prototype.isEmpty = function isEmpty() {
  return this.offset === this.length;
};

DecoderBuffer.prototype.readUInt8 = function readUInt8(fail) {
  if (this.offset + 1 <= this.length)
    return this.base.readUInt8(this.offset++, true);
  else
    return this.error(fail || 'DecoderBuffer overrun');
}

DecoderBuffer.prototype.skip = function skip(bytes, fail) {
  if (!(this.offset + bytes <= this.length))
    return this.error(fail || 'DecoderBuffer overrun');

  var res = new DecoderBuffer(this.base);

  // Share reporter state
  res._reporterState = this._reporterState;

  res.offset = this.offset;
  res.length = this.offset + bytes;
  this.offset += bytes;
  return res;
}

DecoderBuffer.prototype.raw = function raw(save) {
  return this.base.slice(save ? save.offset : this.offset, this.length);
}

function EncoderBuffer(value, reporter) {
  if (Array.isArray(value)) {
    this.length = 0;
    this.value = value.map(function(item) {
      if (!(item instanceof EncoderBuffer))
        item = new EncoderBuffer(item, reporter);
      this.length += item.length;
      return item;
    }, this);
  } else if (typeof value === 'number') {
    if (!(0 <= value && value <= 0xff))
      return reporter.error('non-byte EncoderBuffer value');
    this.value = value;
    this.length = 1;
  } else if (typeof value === 'string') {
    this.value = value;
    this.length = Buffer.byteLength(value);
  } else if (Buffer.isBuffer(value)) {
    this.value = value;
    this.length = value.length;
  } else {
    return reporter.error('Unsupported type: ' + typeof value);
  }
}
exports.EncoderBuffer = EncoderBuffer;

EncoderBuffer.prototype.join = function join(out, offset) {
  if (!out)
    out = new Buffer(this.length);
  if (!offset)
    offset = 0;

  if (this.length === 0)
    return out;

  if (Array.isArray(this.value)) {
    this.value.forEach(function(item) {
      item.join(out, offset);
      offset += item.length;
    });
  } else {
    if (typeof this.value === 'number')
      out[offset] = this.value;
    else if (typeof this.value === 'string')
      out.write(this.value, offset);
    else if (Buffer.isBuffer(this.value))
      this.value.copy(out, offset);
    offset += this.length;
  }

  return out;
};

},{"../base":222,"buffer":152,"inherits":349}],222:[function(require,module,exports){
var base = exports;

base.Reporter = require('./reporter').Reporter;
base.DecoderBuffer = require('./buffer').DecoderBuffer;
base.EncoderBuffer = require('./buffer').EncoderBuffer;
base.Node = require('./node');

},{"./buffer":221,"./node":223,"./reporter":224}],223:[function(require,module,exports){
var Reporter = require('../base').Reporter;
var EncoderBuffer = require('../base').EncoderBuffer;
var assert = require('minimalistic-assert');

// Supported tags
var tags = [
  'seq', 'seqof', 'set', 'setof', 'octstr', 'bitstr', 'objid', 'bool',
  'gentime', 'utctime', 'null_', 'enum', 'int', 'ia5str', 'utf8str', 'bmpstr',
  'numstr', 'printstr'
];

// Public methods list
var methods = [
  'key', 'obj', 'use', 'optional', 'explicit', 'implicit', 'def', 'choice',
  'any'
].concat(tags);

// Overrided methods list
var overrided = [
  '_peekTag', '_decodeTag', '_use',
  '_decodeStr', '_decodeObjid', '_decodeTime',
  '_decodeNull', '_decodeInt', '_decodeBool', '_decodeList',

  '_encodeComposite', '_encodeStr', '_encodeObjid', '_encodeTime',
  '_encodeNull', '_encodeInt', '_encodeBool'
];

function Node(enc, parent) {
  var state = {};
  this._baseState = state;

  state.enc = enc;

  state.parent = parent || null;
  state.children = null;

  // State
  state.tag = null;
  state.args = null;
  state.reverseArgs = null;
  state.choice = null;
  state.optional = false;
  state.any = false;
  state.obj = false;
  state.use = null;
  state.useDecoder = null;
  state.key = null;
  state['default'] = null;
  state.explicit = null;
  state.implicit = null;

  // Should create new instance on each method
  if (!state.parent) {
    state.children = [];
    this._wrap();
  }
}
module.exports = Node;

var stateProps = [
  'enc', 'parent', 'children', 'tag', 'args', 'reverseArgs', 'choice',
  'optional', 'any', 'obj', 'use', 'alteredUse', 'key', 'default', 'explicit',
  'implicit'
];

Node.prototype.clone = function clone() {
  var state = this._baseState;
  var cstate = {};
  stateProps.forEach(function(prop) {
    cstate[prop] = state[prop];
  });
  var res = new this.constructor(cstate.parent);
  res._baseState = cstate;
  return res;
};

Node.prototype._wrap = function wrap() {
  var state = this._baseState;
  methods.forEach(function(method) {
    this[method] = function _wrappedMethod() {
      var clone = new this.constructor(this);
      state.children.push(clone);
      return clone[method].apply(clone, arguments);
    };
  }, this);
};

Node.prototype._init = function init(body) {
  var state = this._baseState;

  assert(state.parent === null);
  body.call(this);

  // Filter children
  state.children = state.children.filter(function(child) {
    return child._baseState.parent === this;
  }, this);
  assert.equal(state.children.length, 1, 'Root node can have only one child');
};

Node.prototype._useArgs = function useArgs(args) {
  var state = this._baseState;

  // Filter children and args
  var children = args.filter(function(arg) {
    return arg instanceof this.constructor;
  }, this);
  args = args.filter(function(arg) {
    return !(arg instanceof this.constructor);
  }, this);

  if (children.length !== 0) {
    assert(state.children === null);
    state.children = children;

    // Replace parent to maintain backward link
    children.forEach(function(child) {
      child._baseState.parent = this;
    }, this);
  }
  if (args.length !== 0) {
    assert(state.args === null);
    state.args = args;
    state.reverseArgs = args.map(function(arg) {
      if (typeof arg !== 'object' || arg.constructor !== Object)
        return arg;

      var res = {};
      Object.keys(arg).forEach(function(key) {
        if (key == (key | 0))
          key |= 0;
        var value = arg[key];
        res[value] = key;
      });
      return res;
    });
  }
};

//
// Overrided methods
//

overrided.forEach(function(method) {
  Node.prototype[method] = function _overrided() {
    var state = this._baseState;
    throw new Error(method + ' not implemented for encoding: ' + state.enc);
  };
});

//
// Public methods
//

tags.forEach(function(tag) {
  Node.prototype[tag] = function _tagMethod() {
    var state = this._baseState;
    var args = Array.prototype.slice.call(arguments);

    assert(state.tag === null);
    state.tag = tag;

    this._useArgs(args);

    return this;
  };
});

Node.prototype.use = function use(item) {
  var state = this._baseState;

  assert(state.use === null);
  state.use = item;

  return this;
};

Node.prototype.optional = function optional() {
  var state = this._baseState;

  state.optional = true;

  return this;
};

Node.prototype.def = function def(val) {
  var state = this._baseState;

  assert(state['default'] === null);
  state['default'] = val;
  state.optional = true;

  return this;
};

Node.prototype.explicit = function explicit(num) {
  var state = this._baseState;

  assert(state.explicit === null && state.implicit === null);
  state.explicit = num;

  return this;
};

Node.prototype.implicit = function implicit(num) {
  var state = this._baseState;

  assert(state.explicit === null && state.implicit === null);
  state.implicit = num;

  return this;
};

Node.prototype.obj = function obj() {
  var state = this._baseState;
  var args = Array.prototype.slice.call(arguments);

  state.obj = true;

  if (args.length !== 0)
    this._useArgs(args);

  return this;
};

Node.prototype.key = function key(newKey) {
  var state = this._baseState;

  assert(state.key === null);
  state.key = newKey;

  return this;
};

Node.prototype.any = function any() {
  var state = this._baseState;

  state.any = true;

  return this;
};

Node.prototype.choice = function choice(obj) {
  var state = this._baseState;

  assert(state.choice === null);
  state.choice = obj;
  this._useArgs(Object.keys(obj).map(function(key) {
    return obj[key];
  }));

  return this;
};

//
// Decoding
//

Node.prototype._decode = function decode(input) {
  var state = this._baseState;

  // Decode root node
  if (state.parent === null)
    return input.wrapResult(state.children[0]._decode(input));

  var result = state['default'];
  var present = true;

  var prevKey;
  if (state.key !== null)
    prevKey = input.enterKey(state.key);

  // Check if tag is there
  if (state.optional) {
    var tag = null;
    if (state.explicit !== null)
      tag = state.explicit;
    else if (state.implicit !== null)
      tag = state.implicit;
    else if (state.tag !== null)
      tag = state.tag;

    if (tag === null && !state.any) {
      // Trial and Error
      var save = input.save();
      try {
        if (state.choice === null)
          this._decodeGeneric(state.tag, input);
        else
          this._decodeChoice(input);
        present = true;
      } catch (e) {
        present = false;
      }
      input.restore(save);
    } else {
      present = this._peekTag(input, tag, state.any);

      if (input.isError(present))
        return present;
    }
  }

  // Push object on stack
  var prevObj;
  if (state.obj && present)
    prevObj = input.enterObject();

  if (present) {
    // Unwrap explicit values
    if (state.explicit !== null) {
      var explicit = this._decodeTag(input, state.explicit);
      if (input.isError(explicit))
        return explicit;
      input = explicit;
    }

    // Unwrap implicit and normal values
    if (state.use === null && state.choice === null) {
      if (state.any)
        var save = input.save();
      var body = this._decodeTag(
        input,
        state.implicit !== null ? state.implicit : state.tag,
        state.any
      );
      if (input.isError(body))
        return body;

      if (state.any)
        result = input.raw(save);
      else
        input = body;
    }

    // Select proper method for tag
    if (state.any)
      result = result;
    else if (state.choice === null)
      result = this._decodeGeneric(state.tag, input);
    else
      result = this._decodeChoice(input);

    if (input.isError(result))
      return result;

    // Decode children
    if (!state.any && state.choice === null && state.children !== null) {
      var fail = state.children.some(function decodeChildren(child) {
        // NOTE: We are ignoring errors here, to let parser continue with other
        // parts of encoded data
        child._decode(input);
      });
      if (fail)
        return err;
    }
  }

  // Pop object
  if (state.obj && present)
    result = input.leaveObject(prevObj);

  // Set key
  if (state.key !== null && (result !== null || present === true))
    input.leaveKey(prevKey, state.key, result);

  return result;
};

Node.prototype._decodeGeneric = function decodeGeneric(tag, input) {
  var state = this._baseState;

  if (tag === 'seq' || tag === 'set')
    return null;
  if (tag === 'seqof' || tag === 'setof')
    return this._decodeList(input, tag, state.args[0]);
  else if (tag === 'octstr' || tag === 'bitstr')
    return this._decodeStr(input, tag);
  else if (tag === 'ia5str' || tag === 'utf8str' || tag === 'bmpstr')
    return this._decodeStr(input, tag);
  else if (tag === 'numstr' || tag === 'printstr')
    return this._decodeStr(input, tag);
  else if (tag === 'objid' && state.args)
    return this._decodeObjid(input, state.args[0], state.args[1]);
  else if (tag === 'objid')
    return this._decodeObjid(input, null, null);
  else if (tag === 'gentime' || tag === 'utctime')
    return this._decodeTime(input, tag);
  else if (tag === 'null_')
    return this._decodeNull(input);
  else if (tag === 'bool')
    return this._decodeBool(input);
  else if (tag === 'int' || tag === 'enum')
    return this._decodeInt(input, state.args && state.args[0]);
  else if (state.use !== null)
    return this._getUse(state.use, input._reporterState.obj)._decode(input);
  else
    return input.error('unknown tag: ' + tag);

  return null;
};

Node.prototype._getUse = function _getUse(entity, obj) {

  var state = this._baseState;
  // Create altered use decoder if implicit is set
  state.useDecoder = this._use(entity, obj);
  assert(state.useDecoder._baseState.parent === null);
  state.useDecoder = state.useDecoder._baseState.children[0];
  if (state.implicit !== state.useDecoder._baseState.implicit) {
    state.useDecoder = state.useDecoder.clone();
    state.useDecoder._baseState.implicit = state.implicit;
  }
  return state.useDecoder;
};

Node.prototype._decodeChoice = function decodeChoice(input) {
  var state = this._baseState;
  var result = null;
  var match = false;

  Object.keys(state.choice).some(function(key) {
    var save = input.save();
    var node = state.choice[key];
    try {
      var value = node._decode(input);
      if (input.isError(value))
        return false;

      result = { type: key, value: value };
      match = true;
    } catch (e) {
      input.restore(save);
      return false;
    }
    return true;
  }, this);

  if (!match)
    return input.error('Choice not matched');

  return result;
};

//
// Encoding
//

Node.prototype._createEncoderBuffer = function createEncoderBuffer(data) {
  return new EncoderBuffer(data, this.reporter);
};

Node.prototype._encode = function encode(data, reporter, parent) {
  var state = this._baseState;
  if (state['default'] !== null && state['default'] === data)
    return;

  var result = this._encodeValue(data, reporter, parent);
  if (result === undefined)
    return;

  if (this._skipDefault(result, reporter, parent))
    return;

  return result;
};

Node.prototype._encodeValue = function encode(data, reporter, parent) {
  var state = this._baseState;

  // Decode root node
  if (state.parent === null)
    return state.children[0]._encode(data, reporter || new Reporter());

  var result = null;
  var present = true;

  // Set reporter to share it with a child class
  this.reporter = reporter;

  // Check if data is there
  if (state.optional && data === undefined) {
    if (state['default'] !== null)
      data = state['default']
    else
      return;
  }

  // For error reporting
  var prevKey;

  // Encode children first
  var content = null;
  var primitive = false;
  if (state.any) {
    // Anything that was given is translated to buffer
    result = this._createEncoderBuffer(data);
  } else if (state.choice) {
    result = this._encodeChoice(data, reporter);
  } else if (state.children) {
    content = state.children.map(function(child) {
      if (child._baseState.tag === 'null_')
        return child._encode(null, reporter, data);

      if (child._baseState.key === null)
        return reporter.error('Child should have a key');
      var prevKey = reporter.enterKey(child._baseState.key);

      if (typeof data !== 'object')
        return reporter.error('Child expected, but input is not object');

      var res = child._encode(data[child._baseState.key], reporter, data);
      reporter.leaveKey(prevKey);

      return res;
    }, this).filter(function(child) {
      return child;
    });

    content = this._createEncoderBuffer(content);
  } else {
    if (state.tag === 'seqof' || state.tag === 'setof') {
      // TODO(indutny): this should be thrown on DSL level
      if (!(state.args && state.args.length === 1))
        return reporter.error('Too many args for : ' + state.tag);

      if (!Array.isArray(data))
        return reporter.error('seqof/setof, but data is not Array');

      var child = this.clone();
      child._baseState.implicit = null;
      content = this._createEncoderBuffer(data.map(function(item) {
        var state = this._baseState;

        return this._getUse(state.args[0], data)._encode(item, reporter);
      }, child));
    } else if (state.use !== null) {
      result = this._getUse(state.use, parent)._encode(data, reporter);
    } else {
      content = this._encodePrimitive(state.tag, data);
      primitive = true;
    }
  }

  // Encode data itself
  var result;
  if (!state.any && state.choice === null) {
    var tag = state.implicit !== null ? state.implicit : state.tag;
    var cls = state.implicit === null ? 'universal' : 'context';

    if (tag === null) {
      if (state.use === null)
        reporter.error('Tag could be ommited only for .use()');
    } else {
      if (state.use === null)
        result = this._encodeComposite(tag, primitive, cls, content);
    }
  }

  // Wrap in explicit
  if (state.explicit !== null)
    result = this._encodeComposite(state.explicit, false, 'context', result);

  return result;
};

Node.prototype._encodeChoice = function encodeChoice(data, reporter) {
  var state = this._baseState;

  var node = state.choice[data.type];
  if (!node) {
    assert(
        false,
        data.type + ' not found in ' +
            JSON.stringify(Object.keys(state.choice)));
  }
  return node._encode(data.value, reporter);
};

Node.prototype._encodePrimitive = function encodePrimitive(tag, data) {
  var state = this._baseState;

  if (tag === 'octstr' || tag === 'bitstr' || tag === 'ia5str')
    return this._encodeStr(data, tag);
  else if (tag === 'utf8str' || tag === 'bmpstr')
    return this._encodeStr(data, tag);
  else if (tag === 'numstr' || tag === 'printstr')
    return this._encodeStr(data, tag);
  else if (tag === 'objid' && state.args)
    return this._encodeObjid(data, state.reverseArgs[0], state.args[1]);
  else if (tag === 'objid')
    return this._encodeObjid(data, null, null);
  else if (tag === 'gentime' || tag === 'utctime')
    return this._encodeTime(data, tag);
  else if (tag === 'null_')
    return this._encodeNull();
  else if (tag === 'int' || tag === 'enum')
    return this._encodeInt(data, state.args && state.reverseArgs[0]);
  else if (tag === 'bool')
    return this._encodeBool(data);
  else
    throw new Error('Unsupported tag: ' + tag);
};

Node.prototype._isNumstr = function isNumstr(str) {
  return /^[0-9 ]*$/.test(str);
};

Node.prototype._isPrintstr = function isPrintstr(str) {
  return /^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(str);
};
},{"../base":222,"minimalistic-assert":233}],224:[function(require,module,exports){
var inherits = require('inherits');

function Reporter(options) {
  this._reporterState = {
    obj: null,
    path: [],
    options: options || {},
    errors: []
  };
}
exports.Reporter = Reporter;

Reporter.prototype.isError = function isError(obj) {
  return obj instanceof ReporterError;
};

Reporter.prototype.save = function save() {
  var state = this._reporterState;

  return { obj: state.obj, pathLen: state.path.length };
};

Reporter.prototype.restore = function restore(data) {
  var state = this._reporterState;

  state.obj = data.obj;
  state.path = state.path.slice(0, data.pathLen);
};

Reporter.prototype.enterKey = function enterKey(key) {
  return this._reporterState.path.push(key);
};

Reporter.prototype.leaveKey = function leaveKey(index, key, value) {
  var state = this._reporterState;

  state.path = state.path.slice(0, index - 1);
  if (state.obj !== null)
    state.obj[key] = value;
};

Reporter.prototype.enterObject = function enterObject() {
  var state = this._reporterState;

  var prev = state.obj;
  state.obj = {};
  return prev;
};

Reporter.prototype.leaveObject = function leaveObject(prev) {
  var state = this._reporterState;

  var now = state.obj;
  state.obj = prev;
  return now;
};

Reporter.prototype.error = function error(msg) {
  var err;
  var state = this._reporterState;

  var inherited = msg instanceof ReporterError;
  if (inherited) {
    err = msg;
  } else {
    err = new ReporterError(state.path.map(function(elem) {
      return '[' + JSON.stringify(elem) + ']';
    }).join(''), msg.message || msg, msg.stack);
  }

  if (!state.options.partial)
    throw err;

  if (!inherited)
    state.errors.push(err);

  return err;
};

Reporter.prototype.wrapResult = function wrapResult(result) {
  var state = this._reporterState;
  if (!state.options.partial)
    return result;

  return {
    result: this.isError(result) ? null : result,
    errors: state.errors
  };
};

function ReporterError(path, msg) {
  this.path = path;
  this.rethrow(msg);
};
inherits(ReporterError, Error);

ReporterError.prototype.rethrow = function rethrow(msg) {
  this.message = msg + ' at: ' + (this.path || '(shallow)');
  Error.captureStackTrace(this, ReporterError);

  return this;
};

},{"inherits":349}],225:[function(require,module,exports){
var constants = require('../constants');

exports.tagClass = {
  0: 'universal',
  1: 'application',
  2: 'context',
  3: 'private'
};
exports.tagClassByName = constants._reverse(exports.tagClass);

exports.tag = {
  0x00: 'end',
  0x01: 'bool',
  0x02: 'int',
  0x03: 'bitstr',
  0x04: 'octstr',
  0x05: 'null_',
  0x06: 'objid',
  0x07: 'objDesc',
  0x08: 'external',
  0x09: 'real',
  0x0a: 'enum',
  0x0b: 'embed',
  0x0c: 'utf8str',
  0x0d: 'relativeOid',
  0x10: 'seq',
  0x11: 'set',
  0x12: 'numstr',
  0x13: 'printstr',
  0x14: 't61str',
  0x15: 'videostr',
  0x16: 'ia5str',
  0x17: 'utctime',
  0x18: 'gentime',
  0x19: 'graphstr',
  0x1a: 'iso646str',
  0x1b: 'genstr',
  0x1c: 'unistr',
  0x1d: 'charstr',
  0x1e: 'bmpstr'
};
exports.tagByName = constants._reverse(exports.tag);

},{"../constants":226}],226:[function(require,module,exports){
var constants = exports;

// Helper
constants._reverse = function reverse(map) {
  var res = {};

  Object.keys(map).forEach(function(key) {
    // Convert key to integer if it is stringified
    if ((key | 0) == key)
      key = key | 0;

    var value = map[key];
    res[value] = key;
  });

  return res;
};

constants.der = require('./der');

},{"./der":225}],227:[function(require,module,exports){
var inherits = require('inherits');

var asn1 = require('../../asn1');
var base = asn1.base;
var bignum = asn1.bignum;

// Import DER constants
var der = asn1.constants.der;

function DERDecoder(entity) {
  this.enc = 'der';
  this.name = entity.name;
  this.entity = entity;

  // Construct base tree
  this.tree = new DERNode();
  this.tree._init(entity.body);
};
module.exports = DERDecoder;

DERDecoder.prototype.decode = function decode(data, options) {
  if (!(data instanceof base.DecoderBuffer))
    data = new base.DecoderBuffer(data, options);

  return this.tree._decode(data, options);
};

// Tree methods

function DERNode(parent) {
  base.Node.call(this, 'der', parent);
}
inherits(DERNode, base.Node);

DERNode.prototype._peekTag = function peekTag(buffer, tag, any) {
  if (buffer.isEmpty())
    return false;

  var state = buffer.save();
  var decodedTag = derDecodeTag(buffer, 'Failed to peek tag: "' + tag + '"');
  if (buffer.isError(decodedTag))
    return decodedTag;

  buffer.restore(state);

  return decodedTag.tag === tag || decodedTag.tagStr === tag || any;
};

DERNode.prototype._decodeTag = function decodeTag(buffer, tag, any) {
  var decodedTag = derDecodeTag(buffer,
                                'Failed to decode tag of "' + tag + '"');
  if (buffer.isError(decodedTag))
    return decodedTag;

  var len = derDecodeLen(buffer,
                         decodedTag.primitive,
                         'Failed to get length of "' + tag + '"');

  // Failure
  if (buffer.isError(len))
    return len;

  if (!any &&
      decodedTag.tag !== tag &&
      decodedTag.tagStr !== tag &&
      decodedTag.tagStr + 'of' !== tag) {
    return buffer.error('Failed to match tag: "' + tag + '"');
  }

  if (decodedTag.primitive || len !== null)
    return buffer.skip(len, 'Failed to match body of: "' + tag + '"');

  // Indefinite length... find END tag
  var state = buffer.save();
  var res = this._skipUntilEnd(
      buffer,
      'Failed to skip indefinite length body: "' + this.tag + '"');
  if (buffer.isError(res))
    return res;

  len = buffer.offset - state.offset;
  buffer.restore(state);
  return buffer.skip(len, 'Failed to match body of: "' + tag + '"');
};

DERNode.prototype._skipUntilEnd = function skipUntilEnd(buffer, fail) {
  while (true) {
    var tag = derDecodeTag(buffer, fail);
    if (buffer.isError(tag))
      return tag;
    var len = derDecodeLen(buffer, tag.primitive, fail);
    if (buffer.isError(len))
      return len;

    var res;
    if (tag.primitive || len !== null)
      res = buffer.skip(len)
    else
      res = this._skipUntilEnd(buffer, fail);

    // Failure
    if (buffer.isError(res))
      return res;

    if (tag.tagStr === 'end')
      break;
  }
};

DERNode.prototype._decodeList = function decodeList(buffer, tag, decoder) {
  var result = [];
  while (!buffer.isEmpty()) {
    var possibleEnd = this._peekTag(buffer, 'end');
    if (buffer.isError(possibleEnd))
      return possibleEnd;

    var res = decoder.decode(buffer, 'der');
    if (buffer.isError(res) && possibleEnd)
      break;
    result.push(res);
  }
  return result;
};

DERNode.prototype._decodeStr = function decodeStr(buffer, tag) {
  if (tag === 'octstr') {
    return buffer.raw();
  } else if (tag === 'bitstr') {
    var unused = buffer.readUInt8();
    if (buffer.isError(unused))
      return unused;

    return { unused: unused, data: buffer.raw() };
  } else if (tag === 'ia5str' || tag === 'utf8str') {
    return buffer.raw().toString();
  } else if(tag === 'numstr') {
    var numstr = buffer.raw().toString('ascii');
    if (!this._isNumstr(numstr)) {
      return buffer.error('Decoding of string type: ' +
                          'numstr unsupported characters');
    }

    return numstr;
  } else if (tag === 'printstr') {
    var printstr = buffer.raw().toString('ascii');
    if (!this._isPrintstr(printstr)) {
      return buffer.error('Decoding of string type: ' +
                          'printstr unsupported characters');
    }

    return printstr;
  } else if(tag === 'bmpstr') {
    var raw = buffer.raw();
    if (raw.length % 2 === 1)
      return buffer.error('Decoding of string type: bmpstr length mismatch');

    var str = '';
    for (var i = 0; i < raw.length / 2; i++) {
      str += String.fromCharCode(raw.readUInt16BE(i * 2));
    }
    return str;
  } else {
    return buffer.error('Decoding of string type: ' + tag + ' unsupported');
  }
};

DERNode.prototype._decodeObjid = function decodeObjid(buffer, values, relative) {
  var identifiers = [];
  var ident = 0;
  while (!buffer.isEmpty()) {
    var subident = buffer.readUInt8();
    ident <<= 7;
    ident |= subident & 0x7f;
    if ((subident & 0x80) === 0) {
      identifiers.push(ident);
      ident = 0;
    }
  }
  if (subident & 0x80)
    identifiers.push(ident);

  var first = (identifiers[0] / 40) | 0;
  var second = identifiers[0] % 40;

  if (relative)
    result = identifiers;
  else
    result = [first, second].concat(identifiers.slice(1));

  if (values)
    result = values[result.join(' ')];

  return result;
};

DERNode.prototype._decodeTime = function decodeTime(buffer, tag) {
  var str = buffer.raw().toString();
  if (tag === 'gentime') {
    var year = str.slice(0, 4) | 0;
    var mon = str.slice(4, 6) | 0;
    var day = str.slice(6, 8) | 0;
    var hour = str.slice(8, 10) | 0;
    var min = str.slice(10, 12) | 0;
    var sec = str.slice(12, 14) | 0;
  } else if (tag === 'utctime') {
    var year = str.slice(0, 2) | 0;
    var mon = str.slice(2, 4) | 0;
    var day = str.slice(4, 6) | 0;
    var hour = str.slice(6, 8) | 0;
    var min = str.slice(8, 10) | 0;
    var sec = str.slice(10, 12) | 0;
    if (year < 70)
      year = 2000 + year;
    else
      year = 1900 + year;
  } else {
    return buffer.error('Decoding ' + tag + ' time is not supported yet');
  }

  return Date.UTC(year, mon - 1, day, hour, min, sec, 0);
};

DERNode.prototype._decodeNull = function decodeNull(buffer) {
  return null;
};

DERNode.prototype._decodeBool = function decodeBool(buffer) {
  var res = buffer.readUInt8();
  if (buffer.isError(res))
    return res;
  else
    return res !== 0;
};

DERNode.prototype._decodeInt = function decodeInt(buffer, values) {
  // Bigint, return as it is (assume big endian)
  var raw = buffer.raw();
  var res = new bignum(raw);

  if (values)
    res = values[res.toString(10)] || res;

  return res;
};

DERNode.prototype._use = function use(entity, obj) {
  if (typeof entity === 'function')
    entity = entity(obj);
  return entity._getDecoder('der').tree;
};

// Utility methods

function derDecodeTag(buf, fail) {
  var tag = buf.readUInt8(fail);
  if (buf.isError(tag))
    return tag;

  var cls = der.tagClass[tag >> 6];
  var primitive = (tag & 0x20) === 0;

  // Multi-octet tag - load
  if ((tag & 0x1f) === 0x1f) {
    var oct = tag;
    tag = 0;
    while ((oct & 0x80) === 0x80) {
      oct = buf.readUInt8(fail);
      if (buf.isError(oct))
        return oct;

      tag <<= 7;
      tag |= oct & 0x7f;
    }
  } else {
    tag &= 0x1f;
  }
  var tagStr = der.tag[tag];

  return {
    cls: cls,
    primitive: primitive,
    tag: tag,
    tagStr: tagStr
  };
}

function derDecodeLen(buf, primitive, fail) {
  var len = buf.readUInt8(fail);
  if (buf.isError(len))
    return len;

  // Indefinite form
  if (!primitive && len === 0x80)
    return null;

  // Definite form
  if ((len & 0x80) === 0) {
    // Short form
    return len;
  }

  // Long form
  var num = len & 0x7f;
  if (num >= 4)
    return buf.error('length octect is too long');

  len = 0;
  for (var i = 0; i < num; i++) {
    len <<= 8;
    var j = buf.readUInt8(fail);
    if (buf.isError(j))
      return j;
    len |= j;
  }

  return len;
}

},{"../../asn1":219,"inherits":349}],228:[function(require,module,exports){
var decoders = exports;

decoders.der = require('./der');
decoders.pem = require('./pem');

},{"./der":227,"./pem":229}],229:[function(require,module,exports){
var inherits = require('inherits');
var Buffer = require('buffer').Buffer;

var asn1 = require('../../asn1');
var DERDecoder = require('./der');

function PEMDecoder(entity) {
  DERDecoder.call(this, entity);
  this.enc = 'pem';
};
inherits(PEMDecoder, DERDecoder);
module.exports = PEMDecoder;

PEMDecoder.prototype.decode = function decode(data, options) {
  var lines = data.toString().split(/[\r\n]+/g);

  var label = options.label.toUpperCase();

  var re = /^-----(BEGIN|END) ([^-]+)-----$/;
  var start = -1;
  var end = -1;
  for (var i = 0; i < lines.length; i++) {
    var match = lines[i].match(re);
    if (match === null)
      continue;

    if (match[2] !== label)
      continue;

    if (start === -1) {
      if (match[1] !== 'BEGIN')
        break;
      start = i;
    } else {
      if (match[1] !== 'END')
        break;
      end = i;
      break;
    }
  }
  if (start === -1 || end === -1)
    throw new Error('PEM section not found for: ' + label);

  var base64 = lines.slice(start + 1, end).join('');
  // Remove excessive symbols
  base64.replace(/[^a-z0-9\+\/=]+/gi, '');

  var input = new Buffer(base64, 'base64');
  return DERDecoder.prototype.decode.call(this, input, options);
};

},{"../../asn1":219,"./der":227,"buffer":152,"inherits":349}],230:[function(require,module,exports){
var inherits = require('inherits');
var Buffer = require('buffer').Buffer;

var asn1 = require('../../asn1');
var base = asn1.base;
var bignum = asn1.bignum;

// Import DER constants
var der = asn1.constants.der;

function DEREncoder(entity) {
  this.enc = 'der';
  this.name = entity.name;
  this.entity = entity;

  // Construct base tree
  this.tree = new DERNode();
  this.tree._init(entity.body);
};
module.exports = DEREncoder;

DEREncoder.prototype.encode = function encode(data, reporter) {
  return this.tree._encode(data, reporter).join();
};

// Tree methods

function DERNode(parent) {
  base.Node.call(this, 'der', parent);
}
inherits(DERNode, base.Node);

DERNode.prototype._encodeComposite = function encodeComposite(tag,
                                                              primitive,
                                                              cls,
                                                              content) {
  var encodedTag = encodeTag(tag, primitive, cls, this.reporter);

  // Short form
  if (content.length < 0x80) {
    var header = new Buffer(2);
    header[0] = encodedTag;
    header[1] = content.length;
    return this._createEncoderBuffer([ header, content ]);
  }

  // Long form
  // Count octets required to store length
  var lenOctets = 1;
  for (var i = content.length; i >= 0x100; i >>= 8)
    lenOctets++;

  var header = new Buffer(1 + 1 + lenOctets);
  header[0] = encodedTag;
  header[1] = 0x80 | lenOctets;

  for (var i = 1 + lenOctets, j = content.length; j > 0; i--, j >>= 8)
    header[i] = j & 0xff;

  return this._createEncoderBuffer([ header, content ]);
};

DERNode.prototype._encodeStr = function encodeStr(str, tag) {
  if (tag === 'octstr') {
    return this._createEncoderBuffer(str);
  } else if (tag === 'bitstr') {
    return this._createEncoderBuffer([ str.unused | 0, str.data ]);
  } else if (tag === 'ia5str' || tag === 'utf8str') {
    return this._createEncoderBuffer(str);
  } else if (tag === 'bmpstr') {
    var buf = new Buffer(str.length * 2);
    for (var i = 0; i < str.length; i++) {
      buf.writeUInt16BE(str.charCodeAt(i), i * 2);
    }
    return this._createEncoderBuffer(buf);
  } else if (tag === 'numstr') {
    if (!this._isNumstr(str)) {
      return this.reporter.error('Encoding of string type: numstr supports ' +
                                 'only digits and space');
    }

    return this._createEncoderBuffer(str);
  } else if (tag === 'printstr') {
    if (!this._isPrintstr(str)) {
      return this.reporter.error('Encoding of string type: printstr supports ' +
                                 'only latin upper and lower case letters, ' +
                                 'digits, space, apostrophe, left and rigth ' +
                                 'parenthesis, plus sign, comma, hyphen, ' +
                                 'dot, slash, colon, equal sign, ' +
                                 'question mark');
    }

    return this._createEncoderBuffer(str);
  } else {
    return this.reporter.error('Encoding of string type: ' + tag +
                               ' unsupported');
  }
};

DERNode.prototype._encodeObjid = function encodeObjid(id, values, relative) {
  if (typeof id === 'string') {
    if (!values)
      return this.reporter.error('string objid given, but no values map found');
    if (!values.hasOwnProperty(id))
      return this.reporter.error('objid not found in values map');
    id = values[id].split(/[\s\.]+/g);
    for (var i = 0; i < id.length; i++)
      id[i] |= 0;
  } else if (Array.isArray(id)) {
    id = id.slice();
    for (var i = 0; i < id.length; i++)
      id[i] |= 0;
  }

  if (!Array.isArray(id)) {
    return this.reporter.error('objid() should be either array or string, ' +
                               'got: ' + JSON.stringify(id));
  }

  if (!relative) {
    if (id[1] >= 40)
      return this.reporter.error('Second objid identifier OOB');
    id.splice(0, 2, id[0] * 40 + id[1]);
  }

  // Count number of octets
  var size = 0;
  for (var i = 0; i < id.length; i++) {
    var ident = id[i];
    for (size++; ident >= 0x80; ident >>= 7)
      size++;
  }

  var objid = new Buffer(size);
  var offset = objid.length - 1;
  for (var i = id.length - 1; i >= 0; i--) {
    var ident = id[i];
    objid[offset--] = ident & 0x7f;
    while ((ident >>= 7) > 0)
      objid[offset--] = 0x80 | (ident & 0x7f);
  }

  return this._createEncoderBuffer(objid);
};

function two(num) {
  if (num < 10)
    return '0' + num;
  else
    return num;
}

DERNode.prototype._encodeTime = function encodeTime(time, tag) {
  var str;
  var date = new Date(time);

  if (tag === 'gentime') {
    str = [
      two(date.getFullYear()),
      two(date.getUTCMonth() + 1),
      two(date.getUTCDate()),
      two(date.getUTCHours()),
      two(date.getUTCMinutes()),
      two(date.getUTCSeconds()),
      'Z'
    ].join('');
  } else if (tag === 'utctime') {
    str = [
      two(date.getFullYear() % 100),
      two(date.getUTCMonth() + 1),
      two(date.getUTCDate()),
      two(date.getUTCHours()),
      two(date.getUTCMinutes()),
      two(date.getUTCSeconds()),
      'Z'
    ].join('');
  } else {
    this.reporter.error('Encoding ' + tag + ' time is not supported yet');
  }

  return this._encodeStr(str, 'octstr');
};

DERNode.prototype._encodeNull = function encodeNull() {
  return this._createEncoderBuffer('');
};

DERNode.prototype._encodeInt = function encodeInt(num, values) {
  if (typeof num === 'string') {
    if (!values)
      return this.reporter.error('String int or enum given, but no values map');
    if (!values.hasOwnProperty(num)) {
      return this.reporter.error('Values map doesn\'t contain: ' +
                                 JSON.stringify(num));
    }
    num = values[num];
  }

  // Bignum, assume big endian
  if (typeof num !== 'number' && !Buffer.isBuffer(num)) {
    var numArray = num.toArray();
    if (!num.sign && numArray[0] & 0x80) {
      numArray.unshift(0);
    }
    num = new Buffer(numArray);
  }

  if (Buffer.isBuffer(num)) {
    var size = num.length;
    if (num.length === 0)
      size++;

    var out = new Buffer(size);
    num.copy(out);
    if (num.length === 0)
      out[0] = 0
    return this._createEncoderBuffer(out);
  }

  if (num < 0x80)
    return this._createEncoderBuffer(num);

  if (num < 0x100)
    return this._createEncoderBuffer([0, num]);

  var size = 1;
  for (var i = num; i >= 0x100; i >>= 8)
    size++;

  var out = new Array(size);
  for (var i = out.length - 1; i >= 0; i--) {
    out[i] = num & 0xff;
    num >>= 8;
  }
  if(out[0] & 0x80) {
    out.unshift(0);
  }

  return this._createEncoderBuffer(new Buffer(out));
};

DERNode.prototype._encodeBool = function encodeBool(value) {
  return this._createEncoderBuffer(value ? 0xff : 0);
};

DERNode.prototype._use = function use(entity, obj) {
  if (typeof entity === 'function')
    entity = entity(obj);
  return entity._getEncoder('der').tree;
};

DERNode.prototype._skipDefault = function skipDefault(dataBuffer, reporter, parent) {
  var state = this._baseState;
  var i;
  if (state['default'] === null)
    return false;

  var data = dataBuffer.join();
  if (state.defaultBuffer === undefined)
    state.defaultBuffer = this._encodeValue(state['default'], reporter, parent).join();

  if (data.length !== state.defaultBuffer.length)
    return false;

  for (i=0; i < data.length; i++)
    if (data[i] !== state.defaultBuffer[i])
      return false;

  return true;
};

// Utility methods

function encodeTag(tag, primitive, cls, reporter) {
  var res;

  if (tag === 'seqof')
    tag = 'seq';
  else if (tag === 'setof')
    tag = 'set';

  if (der.tagByName.hasOwnProperty(tag))
    res = der.tagByName[tag];
  else if (typeof tag === 'number' && (tag | 0) === tag)
    res = tag;
  else
    return reporter.error('Unknown tag: ' + tag);

  if (res >= 0x1f)
    return reporter.error('Multi-octet tag encoding unsupported');

  if (!primitive)
    res |= 0x20;

  res |= (der.tagClassByName[cls || 'universal'] << 6);

  return res;
}

},{"../../asn1":219,"buffer":152,"inherits":349}],231:[function(require,module,exports){
var encoders = exports;

encoders.der = require('./der');
encoders.pem = require('./pem');

},{"./der":230,"./pem":232}],232:[function(require,module,exports){
var inherits = require('inherits');
var Buffer = require('buffer').Buffer;

var asn1 = require('../../asn1');
var DEREncoder = require('./der');

function PEMEncoder(entity) {
  DEREncoder.call(this, entity);
  this.enc = 'pem';
};
inherits(PEMEncoder, DEREncoder);
module.exports = PEMEncoder;

PEMEncoder.prototype.encode = function encode(data, options) {
  var buf = DEREncoder.prototype.encode.call(this, data);

  var p = buf.toString('base64');
  var out = [ '-----BEGIN ' + options.label + '-----' ];
  for (var i = 0; i < p.length; i += 64)
    out.push(p.slice(i, i + 64));
  out.push('-----END ' + options.label + '-----');
  return out.join('\n');
};

},{"../../asn1":219,"./der":230,"buffer":152,"inherits":349}],233:[function(require,module,exports){
arguments[4][184][0].apply(exports,arguments)
},{"dup":184}],234:[function(require,module,exports){
(function (Buffer){
// based on the aes implimentation in triple sec
// https://github.com/keybase/triplesec

// which is in turn based on the one from crypto-js
// https://code.google.com/p/crypto-js/

var uint_max = Math.pow(2, 32)
function fixup_uint32 (x) {
  var ret, x_pos
  ret = x > uint_max || x < 0 ? (x_pos = Math.abs(x) % uint_max, x < 0 ? uint_max - x_pos : x_pos) : x
  return ret
}
function scrub_vec (v) {
  for (var i = 0; i < v.length; v++) {
    v[i] = 0
  }
  return false
}

function Global () {
  this.SBOX = []
  this.INV_SBOX = []
  this.SUB_MIX = [[], [], [], []]
  this.INV_SUB_MIX = [[], [], [], []]
  this.init()
  this.RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36]
}

Global.prototype.init = function () {
  var d, i, sx, t, x, x2, x4, x8, xi, _i
  d = (function () {
    var _i, _results
    _results = []
    for (i = _i = 0; _i < 256; i = ++_i) {
      if (i < 128) {
        _results.push(i << 1)
      } else {
        _results.push((i << 1) ^ 0x11b)
      }
    }
    return _results
  })()
  x = 0
  xi = 0
  for (i = _i = 0; _i < 256; i = ++_i) {
    sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4)
    sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63
    this.SBOX[x] = sx
    this.INV_SBOX[sx] = x
    x2 = d[x]
    x4 = d[x2]
    x8 = d[x4]
    t = (d[sx] * 0x101) ^ (sx * 0x1010100)
    this.SUB_MIX[0][x] = (t << 24) | (t >>> 8)
    this.SUB_MIX[1][x] = (t << 16) | (t >>> 16)
    this.SUB_MIX[2][x] = (t << 8) | (t >>> 24)
    this.SUB_MIX[3][x] = t
    t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100)
    this.INV_SUB_MIX[0][sx] = (t << 24) | (t >>> 8)
    this.INV_SUB_MIX[1][sx] = (t << 16) | (t >>> 16)
    this.INV_SUB_MIX[2][sx] = (t << 8) | (t >>> 24)
    this.INV_SUB_MIX[3][sx] = t
    if (x === 0) {
      x = xi = 1
    } else {
      x = x2 ^ d[d[d[x8 ^ x2]]]
      xi ^= d[d[xi]]
    }
  }
  return true
}

var G = new Global()

AES.blockSize = 4 * 4

AES.prototype.blockSize = AES.blockSize

AES.keySize = 256 / 8

AES.prototype.keySize = AES.keySize

function bufferToArray (buf) {
  var len = buf.length / 4
  var out = new Array(len)
  var i = -1
  while (++i < len) {
    out[i] = buf.readUInt32BE(i * 4)
  }
  return out
}
function AES (key) {
  this._key = bufferToArray(key)
  this._doReset()
}

AES.prototype._doReset = function () {
  var invKsRow, keySize, keyWords, ksRow, ksRows, t
  keyWords = this._key
  keySize = keyWords.length
  this._nRounds = keySize + 6
  ksRows = (this._nRounds + 1) * 4
  this._keySchedule = []
  for (ksRow = 0; ksRow < ksRows; ksRow++) {
    this._keySchedule[ksRow] = ksRow < keySize ? keyWords[ksRow] : (t = this._keySchedule[ksRow - 1], (ksRow % keySize) === 0 ? (t = (t << 8) | (t >>> 24), t = (G.SBOX[t >>> 24] << 24) | (G.SBOX[(t >>> 16) & 0xff] << 16) | (G.SBOX[(t >>> 8) & 0xff] << 8) | G.SBOX[t & 0xff], t ^= G.RCON[(ksRow / keySize) | 0] << 24) : keySize > 6 && ksRow % keySize === 4 ? t = (G.SBOX[t >>> 24] << 24) | (G.SBOX[(t >>> 16) & 0xff] << 16) | (G.SBOX[(t >>> 8) & 0xff] << 8) | G.SBOX[t & 0xff] : void 0, this._keySchedule[ksRow - keySize] ^ t)
  }
  this._invKeySchedule = []
  for (invKsRow = 0; invKsRow < ksRows; invKsRow++) {
    ksRow = ksRows - invKsRow
    t = this._keySchedule[ksRow - (invKsRow % 4 ? 0 : 4)]
    this._invKeySchedule[invKsRow] = invKsRow < 4 || ksRow <= 4 ? t : G.INV_SUB_MIX[0][G.SBOX[t >>> 24]] ^ G.INV_SUB_MIX[1][G.SBOX[(t >>> 16) & 0xff]] ^ G.INV_SUB_MIX[2][G.SBOX[(t >>> 8) & 0xff]] ^ G.INV_SUB_MIX[3][G.SBOX[t & 0xff]]
  }
  return true
}

AES.prototype.encryptBlock = function (M) {
  M = bufferToArray(new Buffer(M))
  var out = this._doCryptBlock(M, this._keySchedule, G.SUB_MIX, G.SBOX)
  var buf = new Buffer(16)
  buf.writeUInt32BE(out[0], 0)
  buf.writeUInt32BE(out[1], 4)
  buf.writeUInt32BE(out[2], 8)
  buf.writeUInt32BE(out[3], 12)
  return buf
}

AES.prototype.decryptBlock = function (M) {
  M = bufferToArray(new Buffer(M))
  var temp = [M[3], M[1]]
  M[1] = temp[0]
  M[3] = temp[1]
  var out = this._doCryptBlock(M, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX)
  var buf = new Buffer(16)
  buf.writeUInt32BE(out[0], 0)
  buf.writeUInt32BE(out[3], 4)
  buf.writeUInt32BE(out[2], 8)
  buf.writeUInt32BE(out[1], 12)
  return buf
}

AES.prototype.scrub = function () {
  scrub_vec(this._keySchedule)
  scrub_vec(this._invKeySchedule)
  scrub_vec(this._key)
}

AES.prototype._doCryptBlock = function (M, keySchedule, SUB_MIX, SBOX) {
  var ksRow, s0, s1, s2, s3, t0, t1, t2, t3

  s0 = M[0] ^ keySchedule[0]
  s1 = M[1] ^ keySchedule[1]
  s2 = M[2] ^ keySchedule[2]
  s3 = M[3] ^ keySchedule[3]
  ksRow = 4
  for (var round = 1; round < this._nRounds; round++) {
    t0 = SUB_MIX[0][s0 >>> 24] ^ SUB_MIX[1][(s1 >>> 16) & 0xff] ^ SUB_MIX[2][(s2 >>> 8) & 0xff] ^ SUB_MIX[3][s3 & 0xff] ^ keySchedule[ksRow++]
    t1 = SUB_MIX[0][s1 >>> 24] ^ SUB_MIX[1][(s2 >>> 16) & 0xff] ^ SUB_MIX[2][(s3 >>> 8) & 0xff] ^ SUB_MIX[3][s0 & 0xff] ^ keySchedule[ksRow++]
    t2 = SUB_MIX[0][s2 >>> 24] ^ SUB_MIX[1][(s3 >>> 16) & 0xff] ^ SUB_MIX[2][(s0 >>> 8) & 0xff] ^ SUB_MIX[3][s1 & 0xff] ^ keySchedule[ksRow++]
    t3 = SUB_MIX[0][s3 >>> 24] ^ SUB_MIX[1][(s0 >>> 16) & 0xff] ^ SUB_MIX[2][(s1 >>> 8) & 0xff] ^ SUB_MIX[3][s2 & 0xff] ^ keySchedule[ksRow++]
    s0 = t0
    s1 = t1
    s2 = t2
    s3 = t3
  }
  t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++]
  t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++]
  t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++]
  t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++]
  return [
    fixup_uint32(t0),
    fixup_uint32(t1),
    fixup_uint32(t2),
    fixup_uint32(t3)
  ]
}

exports.AES = AES

}).call(this,require("buffer").Buffer)

},{"buffer":152}],235:[function(require,module,exports){
(function (Buffer){
var aes = require('./aes')
var Transform = require('cipher-base')
var inherits = require('inherits')
var GHASH = require('./ghash')
var xor = require('buffer-xor')
inherits(StreamCipher, Transform)
module.exports = StreamCipher

function StreamCipher (mode, key, iv, decrypt) {
  if (!(this instanceof StreamCipher)) {
    return new StreamCipher(mode, key, iv)
  }
  Transform.call(this)
  this._finID = Buffer.concat([iv, new Buffer([0, 0, 0, 1])])
  iv = Buffer.concat([iv, new Buffer([0, 0, 0, 2])])
  this._cipher = new aes.AES(key)
  this._prev = new Buffer(iv.length)
  this._cache = new Buffer('')
  this._secCache = new Buffer('')
  this._decrypt = decrypt
  this._alen = 0
  this._len = 0
  iv.copy(this._prev)
  this._mode = mode
  var h = new Buffer(4)
  h.fill(0)
  this._ghash = new GHASH(this._cipher.encryptBlock(h))
  this._authTag = null
  this._called = false
}
StreamCipher.prototype._update = function (chunk) {
  if (!this._called && this._alen) {
    var rump = 16 - (this._alen % 16)
    if (rump < 16) {
      rump = new Buffer(rump)
      rump.fill(0)
      this._ghash.update(rump)
    }
  }
  this._called = true
  var out = this._mode.encrypt(this, chunk)
  if (this._decrypt) {
    this._ghash.update(chunk)
  } else {
    this._ghash.update(out)
  }
  this._len += chunk.length
  return out
}
StreamCipher.prototype._final = function () {
  if (this._decrypt && !this._authTag) {
    throw new Error('Unsupported state or unable to authenticate data')
  }
  var tag = xor(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID))
  if (this._decrypt) {
    if (xorTest(tag, this._authTag)) {
      throw new Error('Unsupported state or unable to authenticate data')
    }
  } else {
    this._authTag = tag
  }
  this._cipher.scrub()
}
StreamCipher.prototype.getAuthTag = function getAuthTag () {
  if (!this._decrypt && Buffer.isBuffer(this._authTag)) {
    return this._authTag
  } else {
    throw new Error('Attempting to get auth tag in unsupported state')
  }
}
StreamCipher.prototype.setAuthTag = function setAuthTag (tag) {
  if (this._decrypt) {
    this._authTag = tag
  } else {
    throw new Error('Attempting to set auth tag in unsupported state')
  }
}
StreamCipher.prototype.setAAD = function setAAD (buf) {
  if (!this._called) {
    this._ghash.update(buf)
    this._alen += buf.length
  } else {
    throw new Error('Attempting to set AAD in unsupported state')
  }
}
function xorTest (a, b) {
  var out = 0
  if (a.length !== b.length) {
    out++
  }
  var len = Math.min(a.length, b.length)
  var i = -1
  while (++i < len) {
    out += (a[i] ^ b[i])
  }
  return out
}

}).call(this,require("buffer").Buffer)

},{"./aes":234,"./ghash":239,"buffer":152,"buffer-xor":248,"cipher-base":249,"inherits":349}],236:[function(require,module,exports){
arguments[4][160][0].apply(exports,arguments)
},{"./decrypter":237,"./encrypter":238,"./modes":240,"dup":160}],237:[function(require,module,exports){
(function (Buffer){
var aes = require('./aes')
var Transform = require('cipher-base')
var inherits = require('inherits')
var modes = require('./modes')
var StreamCipher = require('./streamCipher')
var AuthCipher = require('./authCipher')
var ebtk = require('evp_bytestokey')

inherits(Decipher, Transform)
function Decipher (mode, key, iv) {
  if (!(this instanceof Decipher)) {
    return new Decipher(mode, key, iv)
  }
  Transform.call(this)
  this._cache = new Splitter()
  this._last = void 0
  this._cipher = new aes.AES(key)
  this._prev = new Buffer(iv.length)
  iv.copy(this._prev)
  this._mode = mode
  this._autopadding = true
}
Decipher.prototype._update = function (data) {
  this._cache.add(data)
  var chunk
  var thing
  var out = []
  while ((chunk = this._cache.get(this._autopadding))) {
    thing = this._mode.decrypt(this, chunk)
    out.push(thing)
  }
  return Buffer.concat(out)
}
Decipher.prototype._final = function () {
  var chunk = this._cache.flush()
  if (this._autopadding) {
    return unpad(this._mode.decrypt(this, chunk))
  } else if (chunk) {
    throw new Error('data not multiple of block length')
  }
}
Decipher.prototype.setAutoPadding = function (setTo) {
  this._autopadding = !!setTo
}
function Splitter () {
  if (!(this instanceof Splitter)) {
    return new Splitter()
  }
  this.cache = new Buffer('')
}
Splitter.prototype.add = function (data) {
  this.cache = Buffer.concat([this.cache, data])
}

Splitter.prototype.get = function (autoPadding) {
  var out
  if (autoPadding) {
    if (this.cache.length > 16) {
      out = this.cache.slice(0, 16)
      this.cache = this.cache.slice(16)
      return out
    }
  } else {
    if (this.cache.length >= 16) {
      out = this.cache.slice(0, 16)
      this.cache = this.cache.slice(16)
      return out
    }
  }
  return null
}
Splitter.prototype.flush = function () {
  if (this.cache.length) {
    return this.cache
  }
}
function unpad (last) {
  var padded = last[15]
  var i = -1
  while (++i < padded) {
    if (last[(i + (16 - padded))] !== padded) {
      throw new Error('unable to decrypt data')
    }
  }
  if (padded === 16) {
    return
  }
  return last.slice(0, 16 - padded)
}

var modelist = {
  ECB: require('./modes/ecb'),
  CBC: require('./modes/cbc'),
  CFB: require('./modes/cfb'),
  CFB8: require('./modes/cfb8'),
  CFB1: require('./modes/cfb1'),
  OFB: require('./modes/ofb'),
  CTR: require('./modes/ctr'),
  GCM: require('./modes/ctr')
}

function createDecipheriv (suite, password, iv) {
  var config = modes[suite.toLowerCase()]
  if (!config) {
    throw new TypeError('invalid suite type')
  }
  if (typeof iv === 'string') {
    iv = new Buffer(iv)
  }
  if (typeof password === 'string') {
    password = new Buffer(password)
  }
  if (password.length !== config.key / 8) {
    throw new TypeError('invalid key length ' + password.length)
  }
  if (iv.length !== config.iv) {
    throw new TypeError('invalid iv length ' + iv.length)
  }
  if (config.type === 'stream') {
    return new StreamCipher(modelist[config.mode], password, iv, true)
  } else if (config.type === 'auth') {
    return new AuthCipher(modelist[config.mode], password, iv, true)
  }
  return new Decipher(modelist[config.mode], password, iv)
}

function createDecipher (suite, password) {
  var config = modes[suite.toLowerCase()]
  if (!config) {
    throw new TypeError('invalid suite type')
  }
  var keys = ebtk(password, false, config.key, config.iv)
  return createDecipheriv(suite, keys.key, keys.iv)
}
exports.createDecipher = createDecipher
exports.createDecipheriv = createDecipheriv

}).call(this,require("buffer").Buffer)

},{"./aes":234,"./authCipher":235,"./modes":240,"./modes/cbc":241,"./modes/cfb":242,"./modes/cfb1":243,"./modes/cfb8":244,"./modes/ctr":245,"./modes/ecb":246,"./modes/ofb":247,"./streamCipher":250,"buffer":152,"cipher-base":249,"evp_bytestokey":251,"inherits":349}],238:[function(require,module,exports){
(function (Buffer){
var aes = require('./aes')
var Transform = require('cipher-base')
var inherits = require('inherits')
var modes = require('./modes')
var ebtk = require('evp_bytestokey')
var StreamCipher = require('./streamCipher')
var AuthCipher = require('./authCipher')
inherits(Cipher, Transform)
function Cipher (mode, key, iv) {
  if (!(this instanceof Cipher)) {
    return new Cipher(mode, key, iv)
  }
  Transform.call(this)
  this._cache = new Splitter()
  this._cipher = new aes.AES(key)
  this._prev = new Buffer(iv.length)
  iv.copy(this._prev)
  this._mode = mode
  this._autopadding = true
}
Cipher.prototype._update = function (data) {
  this._cache.add(data)
  var chunk
  var thing
  var out = []
  while ((chunk = this._cache.get())) {
    thing = this._mode.encrypt(this, chunk)
    out.push(thing)
  }
  return Buffer.concat(out)
}
Cipher.prototype._final = function () {
  var chunk = this._cache.flush()
  if (this._autopadding) {
    chunk = this._mode.encrypt(this, chunk)
    this._cipher.scrub()
    return chunk
  } else if (chunk.toString('hex') !== '10101010101010101010101010101010') {
    this._cipher.scrub()
    throw new Error('data not multiple of block length')
  }
}
Cipher.prototype.setAutoPadding = function (setTo) {
  this._autopadding = !!setTo
}

function Splitter () {
  if (!(this instanceof Splitter)) {
    return new Splitter()
  }
  this.cache = new Buffer('')
}
Splitter.prototype.add = function (data) {
  this.cache = Buffer.concat([this.cache, data])
}

Splitter.prototype.get = function () {
  if (this.cache.length > 15) {
    var out = this.cache.slice(0, 16)
    this.cache = this.cache.slice(16)
    return out
  }
  return null
}
Splitter.prototype.flush = function () {
  var len = 16 - this.cache.length
  var padBuff = new Buffer(len)

  var i = -1
  while (++i < len) {
    padBuff.writeUInt8(len, i)
  }
  var out = Buffer.concat([this.cache, padBuff])
  return out
}
var modelist = {
  ECB: require('./modes/ecb'),
  CBC: require('./modes/cbc'),
  CFB: require('./modes/cfb'),
  CFB8: require('./modes/cfb8'),
  CFB1: require('./modes/cfb1'),
  OFB: require('./modes/ofb'),
  CTR: require('./modes/ctr'),
  GCM: require('./modes/ctr')
}

function createCipheriv (suite, password, iv) {
  var config = modes[suite.toLowerCase()]
  if (!config) {
    throw new TypeError('invalid suite type')
  }
  if (typeof iv === 'string') {
    iv = new Buffer(iv)
  }
  if (typeof password === 'string') {
    password = new Buffer(password)
  }
  if (password.length !== config.key / 8) {
    throw new TypeError('invalid key length ' + password.length)
  }
  if (iv.length !== config.iv) {
    throw new TypeError('invalid iv length ' + iv.length)
  }
  if (config.type === 'stream') {
    return new StreamCipher(modelist[config.mode], password, iv)
  } else if (config.type === 'auth') {
    return new AuthCipher(modelist[config.mode], password, iv)
  }
  return new Cipher(modelist[config.mode], password, iv)
}
function createCipher (suite, password) {
  var config = modes[suite.toLowerCase()]
  if (!config) {
    throw new TypeError('invalid suite type')
  }
  var keys = ebtk(password, false, config.key, config.iv)
  return createCipheriv(suite, keys.key, keys.iv)
}

exports.createCipheriv = createCipheriv
exports.createCipher = createCipher

}).call(this,require("buffer").Buffer)

},{"./aes":234,"./authCipher":235,"./modes":240,"./modes/cbc":241,"./modes/cfb":242,"./modes/cfb1":243,"./modes/cfb8":244,"./modes/ctr":245,"./modes/ecb":246,"./modes/ofb":247,"./streamCipher":250,"buffer":152,"cipher-base":249,"evp_bytestokey":251,"inherits":349}],239:[function(require,module,exports){
(function (Buffer){
var zeros = new Buffer(16)
zeros.fill(0)
module.exports = GHASH
function GHASH (key) {
  this.h = key
  this.state = new Buffer(16)
  this.state.fill(0)
  this.cache = new Buffer('')
}
// from http://bitwiseshiftleft.github.io/sjcl/doc/symbols/src/core_gcm.js.html
// by Juho Vh-Herttua
GHASH.prototype.ghash = function (block) {
  var i = -1
  while (++i < block.length) {
    this.state[i] ^= block[i]
  }
  this._multiply()
}

GHASH.prototype._multiply = function () {
  var Vi = toArray(this.h)
  var Zi = [0, 0, 0, 0]
  var j, xi, lsb_Vi
  var i = -1
  while (++i < 128) {
    xi = (this.state[~~(i / 8)] & (1 << (7 - i % 8))) !== 0
    if (xi) {
      // Z_i+1 = Z_i ^ V_i
      Zi = xor(Zi, Vi)
    }

    // Store the value of LSB(V_i)
    lsb_Vi = (Vi[3] & 1) !== 0

    // V_i+1 = V_i >> 1
    for (j = 3; j > 0; j--) {
      Vi[j] = (Vi[j] >>> 1) | ((Vi[j - 1] & 1) << 31)
    }
    Vi[0] = Vi[0] >>> 1

    // If LSB(V_i) is 1, V_i+1 = (V_i >> 1) ^ R
    if (lsb_Vi) {
      Vi[0] = Vi[0] ^ (0xe1 << 24)
    }
  }
  this.state = fromArray(Zi)
}
GHASH.prototype.update = function (buf) {
  this.cache = Buffer.concat([this.cache, buf])
  var chunk
  while (this.cache.length >= 16) {
    chunk = this.cache.slice(0, 16)
    this.cache = this.cache.slice(16)
    this.ghash(chunk)
  }
}
GHASH.prototype.final = function (abl, bl) {
  if (this.cache.length) {
    this.ghash(Buffer.concat([this.cache, zeros], 16))
  }
  this.ghash(fromArray([
    0, abl,
    0, bl
  ]))
  return this.state
}

function toArray (buf) {
  return [
    buf.readUInt32BE(0),
    buf.readUInt32BE(4),
    buf.readUInt32BE(8),
    buf.readUInt32BE(12)
  ]
}
function fromArray (out) {
  out = out.map(fixup_uint32)
  var buf = new Buffer(16)
  buf.writeUInt32BE(out[0], 0)
  buf.writeUInt32BE(out[1], 4)
  buf.writeUInt32BE(out[2], 8)
  buf.writeUInt32BE(out[3], 12)
  return buf
}
var uint_max = Math.pow(2, 32)
function fixup_uint32 (x) {
  var ret, x_pos
  ret = x > uint_max || x < 0 ? (x_pos = Math.abs(x) % uint_max, x < 0 ? uint_max - x_pos : x_pos) : x
  return ret
}
function xor (a, b) {
  return [
    a[0] ^ b[0],
    a[1] ^ b[1],
    a[2] ^ b[2],
    a[3] ^ b[3]
  ]
}

}).call(this,require("buffer").Buffer)

},{"buffer":152}],240:[function(require,module,exports){
arguments[4][164][0].apply(exports,arguments)
},{"dup":164}],241:[function(require,module,exports){
arguments[4][165][0].apply(exports,arguments)
},{"buffer-xor":248,"dup":165}],242:[function(require,module,exports){
(function (Buffer){
var xor = require('buffer-xor')

exports.encrypt = function (self, data, decrypt) {
  var out = new Buffer('')
  var len

  while (data.length) {
    if (self._cache.length === 0) {
      self._cache = self._cipher.encryptBlock(self._prev)
      self._prev = new Buffer('')
    }

    if (self._cache.length <= data.length) {
      len = self._cache.length
      out = Buffer.concat([out, encryptStart(self, data.slice(0, len), decrypt)])
      data = data.slice(len)
    } else {
      out = Buffer.concat([out, encryptStart(self, data, decrypt)])
      break
    }
  }

  return out
}
function encryptStart (self, data, decrypt) {
  var len = data.length
  var out = xor(data, self._cache)
  self._cache = self._cache.slice(len)
  self._prev = Buffer.concat([self._prev, decrypt ? data : out])
  return out
}

}).call(this,require("buffer").Buffer)

},{"buffer":152,"buffer-xor":248}],243:[function(require,module,exports){
(function (Buffer){
function encryptByte (self, byteParam, decrypt) {
  var pad
  var i = -1
  var len = 8
  var out = 0
  var bit, value
  while (++i < len) {
    pad = self._cipher.encryptBlock(self._prev)
    bit = (byteParam & (1 << (7 - i))) ? 0x80 : 0
    value = pad[0] ^ bit
    out += ((value & 0x80) >> (i % 8))
    self._prev = shiftIn(self._prev, decrypt ? bit : value)
  }
  return out
}
exports.encrypt = function (self, chunk, decrypt) {
  var len = chunk.length
  var out = new Buffer(len)
  var i = -1
  while (++i < len) {
    out[i] = encryptByte(self, chunk[i], decrypt)
  }
  return out
}
function shiftIn (buffer, value) {
  var len = buffer.length
  var i = -1
  var out = new Buffer(buffer.length)
  buffer = Buffer.concat([buffer, new Buffer([value])])
  while (++i < len) {
    out[i] = buffer[i] << 1 | buffer[i + 1] >> (7)
  }
  return out
}

}).call(this,require("buffer").Buffer)

},{"buffer":152}],244:[function(require,module,exports){
(function (Buffer){
function encryptByte (self, byteParam, decrypt) {
  var pad = self._cipher.encryptBlock(self._prev)
  var out = pad[0] ^ byteParam
  self._prev = Buffer.concat([self._prev.slice(1), new Buffer([decrypt ? byteParam : out])])
  return out
}
exports.encrypt = function (self, chunk, decrypt) {
  var len = chunk.length
  var out = new Buffer(len)
  var i = -1
  while (++i < len) {
    out[i] = encryptByte(self, chunk[i], decrypt)
  }
  return out
}

}).call(this,require("buffer").Buffer)

},{"buffer":152}],245:[function(require,module,exports){
(function (Buffer){
var xor = require('buffer-xor')

function incr32 (iv) {
  var len = iv.length
  var item
  while (len--) {
    item = iv.readUInt8(len)
    if (item === 255) {
      iv.writeUInt8(0, len)
    } else {
      item++
      iv.writeUInt8(item, len)
      break
    }
  }
}

function getBlock (self) {
  var out = self._cipher.encryptBlock(self._prev)
  incr32(self._prev)
  return out
}

exports.encrypt = function (self, chunk) {
  while (self._cache.length < chunk.length) {
    self._cache = Buffer.concat([self._cache, getBlock(self)])
  }
  var pad = self._cache.slice(0, chunk.length)
  self._cache = self._cache.slice(chunk.length)
  return xor(chunk, pad)
}

}).call(this,require("buffer").Buffer)

},{"buffer":152,"buffer-xor":248}],246:[function(require,module,exports){
arguments[4][170][0].apply(exports,arguments)
},{"dup":170}],247:[function(require,module,exports){
(function (Buffer){
var xor = require('buffer-xor')

function getBlock (self) {
  self._prev = self._cipher.encryptBlock(self._prev)
  return self._prev
}

exports.encrypt = function (self, chunk) {
  while (self._cache.length < chunk.length) {
    self._cache = Buffer.concat([self._cache, getBlock(self)])
  }

  var pad = self._cache.slice(0, chunk.length)
  self._cache = self._cache.slice(chunk.length)
  return xor(chunk, pad)
}

}).call(this,require("buffer").Buffer)

},{"buffer":152,"buffer-xor":248}],248:[function(require,module,exports){
(function (Buffer){
module.exports = function xor (a, b) {
  var length = Math.min(a.length, b.length)
  var buffer = new Buffer(length)

  for (var i = 0; i < length; ++i) {
    buffer[i] = a[i] ^ b[i]
  }

  return buffer
}

}).call(this,require("buffer").Buffer)

},{"buffer":152}],249:[function(require,module,exports){
(function (Buffer){
var Transform = require('stream').Transform
var inherits = require('inherits')
var StringDecoder = require('string_decoder').StringDecoder
module.exports = CipherBase
inherits(CipherBase, Transform)
function CipherBase (hashMode) {
  Transform.call(this)
  this.hashMode = typeof hashMode === 'string'
  if (this.hashMode) {
    this[hashMode] = this._finalOrDigest
  } else {
    this.final = this._finalOrDigest
  }
  this._decoder = null
  this._encoding = null
}
CipherBase.prototype.update = function (data, inputEnc, outputEnc) {
  if (typeof data === 'string') {
    data = new Buffer(data, inputEnc)
  }
  var outData = this._update(data)
  if (this.hashMode) {
    return this
  }
  if (outputEnc) {
    outData = this._toString(outData, outputEnc)
  }
  return outData
}

CipherBase.prototype.setAutoPadding = function () {}

CipherBase.prototype.getAuthTag = function () {
  throw new Error('trying to get auth tag in unsupported state')
}

CipherBase.prototype.setAuthTag = function () {
  throw new Error('trying to set auth tag in unsupported state')
}

CipherBase.prototype.setAAD = function () {
  throw new Error('trying to set aad in unsupported state')
}

CipherBase.prototype._transform = function (data, _, next) {
  var err
  try {
    if (this.hashMode) {
      this._update(data)
    } else {
      this.push(this._update(data))
    }
  } catch (e) {
    err = e
  } finally {
    next(err)
  }
}
CipherBase.prototype._flush = function (done) {
  var err
  try {
    this.push(this._final())
  } catch (e) {
    err = e
  } finally {
    done(err)
  }
}
CipherBase.prototype._finalOrDigest = function (outputEnc) {
  var outData = this._final() || new Buffer('')
  if (outputEnc) {
    outData = this._toString(outData, outputEnc, true)
  }
  return outData
}

CipherBase.prototype._toString = function (value, enc, final) {
  if (!this._decoder) {
    this._decoder = new StringDecoder(enc)
    this._encoding = enc
  }
  if (this._encoding !== enc) {
    throw new Error('can\'t switch encodings')
  }
  var out = this._decoder.write(value)
  if (final) {
    out += this._decoder.end()
  }
  return out
}

}).call(this,require("buffer").Buffer)

},{"buffer":152,"inherits":349,"stream":366,"string_decoder":367}],250:[function(require,module,exports){
(function (Buffer){
var aes = require('./aes')
var Transform = require('cipher-base')
var inherits = require('inherits')

inherits(StreamCipher, Transform)
module.exports = StreamCipher
function StreamCipher (mode, key, iv, decrypt) {
  if (!(this instanceof StreamCipher)) {
    return new StreamCipher(mode, key, iv)
  }
  Transform.call(this)
  this._cipher = new aes.AES(key)
  this._prev = new Buffer(iv.length)
  this._cache = new Buffer('')
  this._secCache = new Buffer('')
  this._decrypt = decrypt
  iv.copy(this._prev)
  this._mode = mode
}
StreamCipher.prototype._update = function (chunk) {
  return this._mode.encrypt(this, chunk, this._decrypt)
}
StreamCipher.prototype._final = function () {
  this._cipher.scrub()
}

}).call(this,require("buffer").Buffer)

},{"./aes":234,"buffer":152,"cipher-base":249,"inherits":349}],251:[function(require,module,exports){
(function (Buffer){
var md5 = require('create-hash/md5')
module.exports = EVP_BytesToKey
function EVP_BytesToKey (password, salt, keyLen, ivLen) {
  if (!Buffer.isBuffer(password)) {
    password = new Buffer(password, 'binary')
  }
  if (salt && !Buffer.isBuffer(salt)) {
    salt = new Buffer(salt, 'binary')
  }
  keyLen = keyLen / 8
  ivLen = ivLen || 0
  var ki = 0
  var ii = 0
  var key = new Buffer(keyLen)
  var iv = new Buffer(ivLen)
  var addmd = 0
  var md_buf
  var i
  var bufs = []
  while (true) {
    if (addmd++ > 0) {
      bufs.push(md_buf)
    }
    bufs.push(password)
    if (salt) {
      bufs.push(salt)
    }
    md_buf = md5(Buffer.concat(bufs))
    bufs = []
    i = 0
    if (keyLen > 0) {
      while (true) {
        if (keyLen === 0) {
          break
        }
        if (i === md_buf.length) {
          break
        }
        key[ki++] = md_buf[i]
        keyLen--
        i++
      }
    }
    if (ivLen > 0 && i !== md_buf.length) {
      while (true) {
        if (ivLen === 0) {
          break
        }
        if (i === md_buf.length) {
          break
        }
        iv[ii++] = md_buf[i]
        ivLen--
        i++
      }
    }
    if (keyLen === 0 && ivLen === 0) {
      break
    }
  }
  for (i = 0; i < md_buf.length; i++) {
    md_buf[i] = 0
  }
  return {
    key: key,
    iv: iv
  }
}

}).call(this,require("buffer").Buffer)

},{"buffer":152,"create-hash/md5":282}],252:[function(require,module,exports){
(function (Buffer){
// much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js
var createHmac = require('create-hmac')
var crt = require('browserify-rsa')
var curves = require('./curves')
var elliptic = require('elliptic')
var parseKeys = require('parse-asn1')

var BN = require('bn.js')
var EC = elliptic.ec

function sign (hash, key, hashType, signType) {
  var priv = parseKeys(key)
  if (priv.curve) {
    if (signType !== 'ecdsa') throw new Error('wrong private key type')

    return ecSign(hash, priv)
  } else if (priv.type === 'dsa') {
    if (signType !== 'dsa') {
      throw new Error('wrong private key type')
    }
    return dsaSign(hash, priv, hashType)
  } else {
    if (signType !== 'rsa') throw new Error('wrong private key type')
  }

  var len = priv.modulus.byteLength()
  var pad = [ 0, 1 ]
  while (hash.length + pad.length + 1 < len) {
    pad.push(0xff)
  }
  pad.push(0x00)
  var i = -1
  while (++i < hash.length) {
    pad.push(hash[i])
  }

  var out = crt(pad, priv)
  return out
}

function ecSign (hash, priv) {
  var curveId = curves[priv.curve.join('.')]
  if (!curveId) throw new Error('unknown curve ' + priv.curve.join('.'))

  var curve = new EC(curveId)
  var key = curve.genKeyPair()

  key._importPrivate(priv.privateKey)
  var out = key.sign(hash)

  return new Buffer(out.toDER())
}

function dsaSign (hash, priv, algo) {
  var x = priv.params.priv_key
  var p = priv.params.p
  var q = priv.params.q
  var g = priv.params.g
  var r = new BN(0)
  var k
  var H = bits2int(hash, q).mod(q)
  var s = false
  var kv = getKey(x, q, hash, algo)
  while (s === false) {
    k = makeKey(q, kv, algo)
    r = makeR(g, k, p, q)
    s = k.invm(q).imul(H.add(x.mul(r))).mod(q)
    if (!s.cmpn(0)) {
      s = false
      r = new BN(0)
    }
  }
  return toDER(r, s)
}

function toDER (r, s) {
  r = r.toArray()
  s = s.toArray()

  // Pad values
  if (r[0] & 0x80) {
    r = [ 0 ].concat(r)
  }
  // Pad values
  if (s[0] & 0x80) {
    s = [0].concat(s)
  }

  var total = r.length + s.length + 4
  var res = [ 0x30, total, 0x02, r.length ]
  res = res.concat(r, [ 0x02, s.length ], s)
  return new Buffer(res)
}

function getKey (x, q, hash, algo) {
  x = new Buffer(x.toArray())
  if (x.length < q.byteLength()) {
    var zeros = new Buffer(q.byteLength() - x.length)
    zeros.fill(0)
    x = Buffer.concat([zeros, x])
  }
  var hlen = hash.length
  var hbits = bits2octets(hash, q)
  var v = new Buffer(hlen)
  v.fill(1)
  var k = new Buffer(hlen)
  k.fill(0)
  k = createHmac(algo, k)
    .update(v)
    .update(new Buffer([0]))
    .update(x)
    .update(hbits)
    .digest()
  v = createHmac(algo, k)
    .update(v)
    .digest()
  k = createHmac(algo, k)
    .update(v)
    .update(new Buffer([1]))
    .update(x)
    .update(hbits)
    .digest()
  v = createHmac(algo, k)
    .update(v)
    .digest()
  return {
    k: k,
    v: v
  }
}

function bits2int (obits, q) {
  var bits = new BN(obits)
  var shift = (obits.length << 3) - q.bitLength()
  if (shift > 0) {
    bits.ishrn(shift)
  }
  return bits
}

function bits2octets (bits, q) {
  bits = bits2int(bits, q)
  bits = bits.mod(q)
  var out = new Buffer(bits.toArray())
  if (out.length < q.byteLength()) {
    var zeros = new Buffer(q.byteLength() - out.length)
    zeros.fill(0)
    out = Buffer.concat([zeros, out])
  }
  return out
}

function makeKey (q, kv, algo) {
  var t, k

  do {
    t = new Buffer('')

    while (t.length * 8 < q.bitLength()) {
      kv.v = createHmac(algo, kv.k)
        .update(kv.v)
        .digest()
      t = Buffer.concat([t, kv.v])
    }

    k = bits2int(t, q)
    kv.k = createHmac(algo, kv.k)
      .update(kv.v)
      .update(new Buffer([0]))
      .digest()
    kv.v = createHmac(algo, kv.k)
      .update(kv.v)
      .digest()
  } while (k.cmp(q) !== -1)

  return k
}

function makeR (g, k, p, q) {
  return g.toRed(BN.mont(p)).redPow(k).fromRed().mod(q)
}

module.exports = sign
module.exports.getKey = getKey
module.exports.makeKey = makeKey

}).call(this,require("buffer").Buffer)

},{"./curves":188,"bn.js":189,"browserify-rsa":190,"buffer":152,"create-hmac":293,"elliptic":191,"parse-asn1":218}],253:[function(require,module,exports){
(function (Buffer){
// much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js
var curves = require('./curves')
var elliptic = require('elliptic')
var parseKeys = require('parse-asn1')

var BN = require('bn.js')
var EC = elliptic.ec

function verify (sig, hash, key, signType) {
  var pub = parseKeys(key)
  if (pub.type === 'ec') {
    if (signType !== 'ecdsa') {
      throw new Error('wrong public key type')
    }
    return ecVerify(sig, hash, pub)
  } else if (pub.type === 'dsa') {
    if (signType !== 'dsa') {
      throw new Error('wrong public key type')
    }
    return dsaVerify(sig, hash, pub)
  } else {
    if (signType !== 'rsa') {
      throw new Error('wrong public key type')
    }
  }
  var len = pub.modulus.byteLength()
  var pad = [ 1 ]
  var padNum = 0
  while (hash.length + pad.length + 2 < len) {
    pad.push(0xff)
    padNum++
  }
  pad.push(0x00)
  var i = -1
  while (++i < hash.length) {
    pad.push(hash[i])
  }
  pad = new Buffer(pad)
  var red = BN.mont(pub.modulus)
  sig = new BN(sig).toRed(red)

  sig = sig.redPow(new BN(pub.publicExponent))

  sig = new Buffer(sig.fromRed().toArray())
  var out = 0
  if (padNum < 8) {
    out = 1
  }
  len = Math.min(sig.length, pad.length)
  if (sig.length !== pad.length) {
    out = 1
  }

  i = -1
  while (++i < len) {
    out |= (sig[i] ^ pad[i])
  }
  return out === 0
}

function ecVerify (sig, hash, pub) {
  var curveId = curves[pub.data.algorithm.curve.join('.')]
  if (!curveId) throw new Error('unknown curve ' + pub.data.algorithm.curve.join('.'))

  var curve = new EC(curveId)
  var pubkey = pub.data.subjectPrivateKey.data

  return curve.verify(hash, sig, pubkey)
}

function dsaVerify (sig, hash, pub) {
  var p = pub.data.p
  var q = pub.data.q
  var g = pub.data.g
  var y = pub.data.pub_key
  var unpacked = parseKeys.signature.decode(sig, 'der')
  var s = unpacked.s
  var r = unpacked.r
  checkValue(s, q)
  checkValue(r, q)
  var montp = BN.mont(p)
  var w = s.invm(q)
  var v = g.toRed(montp)
    .redPow(new BN(hash).mul(w).mod(q))
    .fromRed()
    .mul(
      y.toRed(montp)
        .redPow(r.mul(w).mod(q))
        .fromRed()
  ).mod(p).mod(q)
  return !v.cmp(r)
}

function checkValue (b, q) {
  if (b.cmpn(0) <= 0) {
    throw new Error('invalid sig')
  }
  if (b.cmp(q) >= q) {
    throw new Error('invalid sig')
  }
}

module.exports = verify

}).call(this,require("buffer").Buffer)

},{"./curves":188,"bn.js":189,"buffer":152,"elliptic":191,"parse-asn1":218}],254:[function(require,module,exports){
(function (Buffer){
var elliptic = require('elliptic');
var BN = require('bn.js');

module.exports = function createECDH(curve) {
	return new ECDH(curve);
};

var aliases = {
	secp256k1: {
		name: 'secp256k1',
		byteLength: 32
	},
	secp224r1: {
		name: 'p224',
		byteLength: 28
	},
	prime256v1: {
		name: 'p256',
		byteLength: 32
	},
	prime192v1: {
		name: 'p192',
		byteLength: 24
	},
	ed25519: {
		name: 'ed25519',
		byteLength: 32
	},
	secp384r1: {
		name: 'p384',
		byteLength: 48
	},
	secp521r1: {
		name: 'p521',
		byteLength: 66
	}
};

aliases.p224 = aliases.secp224r1;
aliases.p256 = aliases.secp256r1 = aliases.prime256v1;
aliases.p192 = aliases.secp192r1 = aliases.prime192v1;
aliases.p384 = aliases.secp384r1;
aliases.p521 = aliases.secp521r1;

function ECDH(curve) {
	this.curveType = aliases[curve];
	if (!this.curveType ) {
		this.curveType = {
			name: curve
		};
	}
	this.curve = new elliptic.ec(this.curveType.name);
	this.keys = void 0;
}

ECDH.prototype.generateKeys = function (enc, format) {
	this.keys = this.curve.genKeyPair();
	return this.getPublicKey(enc, format);
};

ECDH.prototype.computeSecret = function (other, inenc, enc) {
	inenc = inenc || 'utf8';
	if (!Buffer.isBuffer(other)) {
		other = new Buffer(other, inenc);
	}
	var otherPub = this.curve.keyFromPublic(other).getPublic();
	var out = otherPub.mul(this.keys.getPrivate()).getX();
	return formatReturnValue(out, enc, this.curveType.byteLength);
};

ECDH.prototype.getPublicKey = function (enc, format) {
	var key = this.keys.getPublic(format === 'compressed', true);
	if (format === 'hybrid') {
		if (key[key.length - 1] % 2) {
			key[0] = 7;
		} else {
			key [0] = 6;
		}
	}
	return formatReturnValue(key, enc);
};

ECDH.prototype.getPrivateKey = function (enc) {
	return formatReturnValue(this.keys.getPrivate(), enc);
};

ECDH.prototype.setPublicKey = function (pub, enc) {
	enc = enc || 'utf8';
	if (!Buffer.isBuffer(pub)) {
		pub = new Buffer(pub, enc);
	}
	this.keys._importPublic(pub);
	return this;
};

ECDH.prototype.setPrivateKey = function (priv, enc) {
	enc = enc || 'utf8';
	if (!Buffer.isBuffer(priv)) {
		priv = new Buffer(priv, enc);
	}
	var _priv = new BN(priv);
	_priv = _priv.toString(16);
	this.keys._importPrivate(_priv);
	return this;
};

function formatReturnValue(bn, enc, len) {
	if (!Array.isArray(bn)) {
		bn = bn.toArray();
	}
	var buf = new Buffer(bn);
	if (len && buf.length < len) {
		var zeros = new Buffer(len - buf.length);
		zeros.fill(0);
		buf = Buffer.concat([zeros, buf]);
	}
	if (!enc) {
		return buf;
	} else {
		return buf.toString(enc);
	}
}

}).call(this,require("buffer").Buffer)

},{"bn.js":255,"buffer":152,"elliptic":256}],255:[function(require,module,exports){
arguments[4][189][0].apply(exports,arguments)
},{"dup":189}],256:[function(require,module,exports){
arguments[4][191][0].apply(exports,arguments)
},{"../package.json":279,"./elliptic/curve":259,"./elliptic/curves":262,"./elliptic/ec":263,"./elliptic/eddsa":266,"./elliptic/hmac-drbg":269,"./elliptic/utils":271,"brorand":272,"dup":191}],257:[function(require,module,exports){
arguments[4][192][0].apply(exports,arguments)
},{"../../elliptic":256,"bn.js":255,"dup":192}],258:[function(require,module,exports){
arguments[4][193][0].apply(exports,arguments)
},{"../../elliptic":256,"../curve":259,"bn.js":255,"dup":193,"inherits":349}],259:[function(require,module,exports){
arguments[4][194][0].apply(exports,arguments)
},{"./base":257,"./edwards":258,"./mont":260,"./short":261,"dup":194}],260:[function(require,module,exports){
arguments[4][195][0].apply(exports,arguments)
},{"../../elliptic":256,"../curve":259,"bn.js":255,"dup":195,"inherits":349}],261:[function(require,module,exports){
arguments[4][196][0].apply(exports,arguments)
},{"../../elliptic":256,"../curve":259,"bn.js":255,"dup":196,"inherits":349}],262:[function(require,module,exports){
arguments[4][197][0].apply(exports,arguments)
},{"../elliptic":256,"./precomputed/secp256k1":270,"dup":197,"hash.js":273}],263:[function(require,module,exports){
arguments[4][198][0].apply(exports,arguments)
},{"../../elliptic":256,"./key":264,"./signature":265,"bn.js":255,"dup":198}],264:[function(require,module,exports){
arguments[4][199][0].apply(exports,arguments)
},{"bn.js":255,"dup":199}],265:[function(require,module,exports){
arguments[4][200][0].apply(exports,arguments)
},{"../../elliptic":256,"bn.js":255,"dup":200}],266:[function(require,module,exports){
arguments[4][201][0].apply(exports,arguments)
},{"../../elliptic":256,"./key":267,"./signature":268,"dup":201,"hash.js":273}],267:[function(require,module,exports){
arguments[4][202][0].apply(exports,arguments)
},{"../../elliptic":256,"dup":202}],268:[function(require,module,exports){
arguments[4][203][0].apply(exports,arguments)
},{"../../elliptic":256,"bn.js":255,"dup":203}],269:[function(require,module,exports){
arguments[4][204][0].apply(exports,arguments)
},{"../elliptic":256,"dup":204,"hash.js":273}],270:[function(require,module,exports){
arguments[4][205][0].apply(exports,arguments)
},{"dup":205}],271:[function(require,module,exports){
arguments[4][206][0].apply(exports,arguments)
},{"bn.js":255,"dup":206}],272:[function(require,module,exports){
arguments[4][207][0].apply(exports,arguments)
},{"dup":207}],273:[function(require,module,exports){
arguments[4][208][0].apply(exports,arguments)
},{"./hash/common":274,"./hash/hmac":275,"./hash/ripemd":276,"./hash/sha":277,"./hash/utils":278,"dup":208}],274:[function(require,module,exports){
arguments[4][209][0].apply(exports,arguments)
},{"../hash":273,"dup":209}],275:[function(require,module,exports){
arguments[4][210][0].apply(exports,arguments)
},{"../hash":273,"dup":210}],276:[function(require,module,exports){
arguments[4][211][0].apply(exports,arguments)
},{"../hash":273,"dup":211}],277:[function(require,module,exports){
arguments[4][212][0].apply(exports,arguments)
},{"../hash":273,"dup":212}],278:[function(require,module,exports){
arguments[4][213][0].apply(exports,arguments)
},{"dup":213,"inherits":349}],279:[function(require,module,exports){
arguments[4][214][0].apply(exports,arguments)
},{"dup":214}],280:[function(require,module,exports){
(function (Buffer){
'use strict';
var inherits = require('inherits')
var md5 = require('./md5')
var rmd160 = require('ripemd160')
var sha = require('sha.js')

var Base = require('cipher-base')

function HashNoConstructor(hash) {
  Base.call(this, 'digest')

  this._hash = hash
  this.buffers = []
}

inherits(HashNoConstructor, Base)

HashNoConstructor.prototype._update = function (data) {
  this.buffers.push(data)
}

HashNoConstructor.prototype._final = function () {
  var buf = Buffer.concat(this.buffers)
  var r = this._hash(buf)
  this.buffers = null

  return r
}

function Hash(hash) {
  Base.call(this, 'digest')

  this._hash = hash
}

inherits(Hash, Base)

Hash.prototype._update = function (data) {
  this._hash.update(data)
}

Hash.prototype._final = function () {
  return this._hash.digest()
}

module.exports = function createHash (alg) {
  alg = alg.toLowerCase()
  if ('md5' === alg) return new HashNoConstructor(md5)
  if ('rmd160' === alg || 'ripemd160' === alg) return new HashNoConstructor(rmd160)

  return new Hash(sha(alg))
}

}).call(this,require("buffer").Buffer)

},{"./md5":282,"buffer":152,"cipher-base":283,"inherits":349,"ripemd160":284,"sha.js":286}],281:[function(require,module,exports){
(function (Buffer){
'use strict';
var intSize = 4;
var zeroBuffer = new Buffer(intSize); zeroBuffer.fill(0);
var chrsz = 8;

function toArray(buf, bigEndian) {
  if ((buf.length % intSize) !== 0) {
    var len = buf.length + (intSize - (buf.length % intSize));
    buf = Buffer.concat([buf, zeroBuffer], len);
  }

  var arr = [];
  var fn = bigEndian ? buf.readInt32BE : buf.readInt32LE;
  for (var i = 0; i < buf.length; i += intSize) {
    arr.push(fn.call(buf, i));
  }
  return arr;
}

function toBuffer(arr, size, bigEndian) {
  var buf = new Buffer(size);
  var fn = bigEndian ? buf.writeInt32BE : buf.writeInt32LE;
  for (var i = 0; i < arr.length; i++) {
    fn.call(buf, arr[i], i * 4, true);
  }
  return buf;
}

function hash(buf, fn, hashSize, bigEndian) {
  if (!Buffer.isBuffer(buf)) buf = new Buffer(buf);
  var arr = fn(toArray(buf, bigEndian), buf.length * chrsz);
  return toBuffer(arr, hashSize, bigEndian);
}
exports.hash = hash;
}).call(this,require("buffer").Buffer)

},{"buffer":152}],282:[function(require,module,exports){
'use strict';
/*
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */

var helpers = require('./helpers');

/*
 * Calculate the MD5 of an array of little-endian words, and a bit length
 */
function core_md5(x, len)
{
  /* append padding */
  x[len >> 5] |= 0x80 << ((len) % 32);
  x[(((len + 64) >>> 9) << 4) + 14] = len;

  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;

  for(var i = 0; i < x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;

    a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);
    d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);
    c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);
    b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);
    a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);
    d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);
    c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);
    b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);
    a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);
    d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);
    c = md5_ff(c, d, a, b, x[i+10], 17, -42063);
    b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);
    a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);
    d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);
    c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);
    b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);

    a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);
    d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);
    c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);
    b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);
    a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);
    d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);
    c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);
    b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);
    a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);
    d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);
    c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);
    b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);
    a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);
    d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);
    c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);
    b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);

    a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);
    d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);
    c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);
    b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);
    a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);
    d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);
    c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);
    b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);
    a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);
    d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);
    c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);
    b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);
    a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);
    d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);
    c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);
    b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);

    a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);
    d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);
    c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);
    b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);
    a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);
    d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);
    c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);
    b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);
    a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);
    d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);
    c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);
    b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);
    a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);
    d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);
    c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);
    b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
  }
  return Array(a, b, c, d);

}

/*
 * These functions implement the four basic operations the algorithm uses.
 */
function md5_cmn(q, a, b, x, s, t)
{
  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);
}
function md5_ff(a, b, c, d, x, s, t)
{
  return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
}
function md5_gg(a, b, c, d, x, s, t)
{
  return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
}
function md5_hh(a, b, c, d, x, s, t)
{
  return md5_cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5_ii(a, b, c, d, x, s, t)
{
  return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function bit_rol(num, cnt)
{
  return (num << cnt) | (num >>> (32 - cnt));
}

module.exports = function md5(buf) {
  return helpers.hash(buf, core_md5, 16);
};
},{"./helpers":281}],283:[function(require,module,exports){
(function (Buffer){
var Transform = require('stream').Transform
var inherits = require('inherits')
var StringDecoder = require('string_decoder').StringDecoder
module.exports = CipherBase
inherits(CipherBase, Transform)
function CipherBase (hashMode) {
  Transform.call(this)
  this.hashMode = typeof hashMode === 'string'
  if (this.hashMode) {
    this[hashMode] = this._finalOrDigest
  } else {
    this.final = this._finalOrDigest
  }
  this._decoder = null
  this._encoding = null
}
CipherBase.prototype.update = function (data, inputEnc, outputEnc) {
  if (typeof data === 'string') {
    data = new Buffer(data, inputEnc)
  }
  var outData = this._update(data)
  if (this.hashMode) {
    return this
  }
  if (outputEnc) {
    outData = this._toString(outData, outputEnc)
  }
  return outData
}

CipherBase.prototype.setAutoPadding = function () {}

CipherBase.prototype.getAuthTag = function () {
  throw new Error('trying to get auth tag in unsupported state')
}

CipherBase.prototype.setAuthTag = function () {
  throw new Error('trying to set auth tag in unsupported state')
}

CipherBase.prototype.setAAD = function () {
  throw new Error('trying to set aad in unsupported state')
}

CipherBase.prototype._transform = function (data, _, next) {
  var err
  try {
    if (this.hashMode) {
      this._update(data)
    } else {
      this.push(this._update(data))
    }
  } catch (e) {
    err = e
  } finally {
    next(err)
  }
}
CipherBase.prototype._flush = function (done) {
  var err
  try {
    this.push(this._final())
  } catch (e) {
    err = e
  } finally {
    done(err)
  }
}
CipherBase.prototype._finalOrDigest = function (outputEnc) {
  var outData = this._final() || new Buffer('')
  if (outputEnc) {
    outData = this._toString(outData, outputEnc, true)
  }
  return outData
}

CipherBase.prototype._toString = function (value, enc, final) {
  if (!this._decoder) {
    this._decoder = new StringDecoder(enc)
    this._encoding = enc
  }
  if (this._encoding !== enc) {
    throw new Error('can\'t switch encodings')
  }
  var out = this._decoder.write(value)
  if (final) {
    out += this._decoder.end()
  }
  return out
}

}).call(this,require("buffer").Buffer)

},{"buffer":152,"inherits":349,"stream":366,"string_decoder":367}],284:[function(require,module,exports){
(function (Buffer){
/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
/** @preserve
(c) 2012 by Cdric Mesnil. All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// constants table
var zl = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
]

var zr = [
  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
]

var sl = [
  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
]

var sr = [
  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
]

var hl = [0x00000000, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xA953FD4E]
var hr = [0x50A28BE6, 0x5C4DD124, 0x6D703EF3, 0x7A6D76E9, 0x00000000]

function bytesToWords (bytes) {
  var words = []
  for (var i = 0, b = 0; i < bytes.length; i++, b += 8) {
    words[b >>> 5] |= bytes[i] << (24 - b % 32)
  }
  return words
}

function wordsToBytes (words) {
  var bytes = []
  for (var b = 0; b < words.length * 32; b += 8) {
    bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF)
  }
  return bytes
}

function processBlock (H, M, offset) {
  // swap endian
  for (var i = 0; i < 16; i++) {
    var offset_i = offset + i
    var M_offset_i = M[offset_i]

    // Swap
    M[offset_i] = (
      (((M_offset_i << 8) | (M_offset_i >>> 24)) & 0x00ff00ff) |
      (((M_offset_i << 24) | (M_offset_i >>> 8)) & 0xff00ff00)
    )
  }

  // Working variables
  var al, bl, cl, dl, el
  var ar, br, cr, dr, er

  ar = al = H[0]
  br = bl = H[1]
  cr = cl = H[2]
  dr = dl = H[3]
  er = el = H[4]

  // computation
  var t
  for (i = 0; i < 80; i += 1) {
    t = (al + M[offset + zl[i]]) | 0
    if (i < 16) {
      t += f1(bl, cl, dl) + hl[0]
    } else if (i < 32) {
      t += f2(bl, cl, dl) + hl[1]
    } else if (i < 48) {
      t += f3(bl, cl, dl) + hl[2]
    } else if (i < 64) {
      t += f4(bl, cl, dl) + hl[3]
    } else {// if (i<80) {
      t += f5(bl, cl, dl) + hl[4]
    }
    t = t | 0
    t = rotl(t, sl[i])
    t = (t + el) | 0
    al = el
    el = dl
    dl = rotl(cl, 10)
    cl = bl
    bl = t

    t = (ar + M[offset + zr[i]]) | 0
    if (i < 16) {
      t += f5(br, cr, dr) + hr[0]
    } else if (i < 32) {
      t += f4(br, cr, dr) + hr[1]
    } else if (i < 48) {
      t += f3(br, cr, dr) + hr[2]
    } else if (i < 64) {
      t += f2(br, cr, dr) + hr[3]
    } else {// if (i<80) {
      t += f1(br, cr, dr) + hr[4]
    }

    t = t | 0
    t = rotl(t, sr[i])
    t = (t + er) | 0
    ar = er
    er = dr
    dr = rotl(cr, 10)
    cr = br
    br = t
  }

  // intermediate hash value
  t = (H[1] + cl + dr) | 0
  H[1] = (H[2] + dl + er) | 0
  H[2] = (H[3] + el + ar) | 0
  H[3] = (H[4] + al + br) | 0
  H[4] = (H[0] + bl + cr) | 0
  H[0] = t
}

function f1 (x, y, z) {
  return ((x) ^ (y) ^ (z))
}

function f2 (x, y, z) {
  return (((x) & (y)) | ((~x) & (z)))
}

function f3 (x, y, z) {
  return (((x) | (~(y))) ^ (z))
}

function f4 (x, y, z) {
  return (((x) & (z)) | ((y) & (~(z))))
}

function f5 (x, y, z) {
  return ((x) ^ ((y) | (~(z))))
}

function rotl (x, n) {
  return (x << n) | (x >>> (32 - n))
}

function ripemd160 (message) {
  var H = [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0]

  if (typeof message === 'string') {
    message = new Buffer(message, 'utf8')
  }

  var m = bytesToWords(message)

  var nBitsLeft = message.length * 8
  var nBitsTotal = message.length * 8

  // Add padding
  m[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32)
  m[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
    (((nBitsTotal << 8) | (nBitsTotal >>> 24)) & 0x00ff00ff) |
    (((nBitsTotal << 24) | (nBitsTotal >>> 8)) & 0xff00ff00)
  )

  for (var i = 0; i < m.length; i += 16) {
    processBlock(H, m, i)
  }

  // swap endian
  for (i = 0; i < 5; i++) {
    // shortcut
    var H_i = H[i]

    // Swap
    H[i] = (((H_i << 8) | (H_i >>> 24)) & 0x00ff00ff) |
      (((H_i << 24) | (H_i >>> 8)) & 0xff00ff00)
  }

  var digestbytes = wordsToBytes(H)
  return new Buffer(digestbytes)
}

module.exports = ripemd160

}).call(this,require("buffer").Buffer)

},{"buffer":152}],285:[function(require,module,exports){
(function (Buffer){
// prototype class for hash functions
function Hash (blockSize, finalSize) {
  this._block = new Buffer(blockSize)
  this._finalSize = finalSize
  this._blockSize = blockSize
  this._len = 0
  this._s = 0
}

Hash.prototype.update = function (data, enc) {
  if (typeof data === 'string') {
    enc = enc || 'utf8'
    data = new Buffer(data, enc)
  }

  var l = this._len += data.length
  var s = this._s || 0
  var f = 0
  var buffer = this._block

  while (s < l) {
    var t = Math.min(data.length, f + this._blockSize - (s % this._blockSize))
    var ch = (t - f)

    for (var i = 0; i < ch; i++) {
      buffer[(s % this._blockSize) + i] = data[i + f]
    }

    s += ch
    f += ch

    if ((s % this._blockSize) === 0) {
      this._update(buffer)
    }
  }
  this._s = s

  return this
}

Hash.prototype.digest = function (enc) {
  // Suppose the length of the message M, in bits, is l
  var l = this._len * 8

  // Append the bit 1 to the end of the message
  this._block[this._len % this._blockSize] = 0x80

  // and then k zero bits, where k is the smallest non-negative solution to the equation (l + 1 + k) === finalSize mod blockSize
  this._block.fill(0, this._len % this._blockSize + 1)

  if (l % (this._blockSize * 8) >= this._finalSize * 8) {
    this._update(this._block)
    this._block.fill(0)
  }

  // to this append the block which is equal to the number l written in binary
  // TODO: handle case where l is > Math.pow(2, 29)
  this._block.writeInt32BE(l, this._blockSize - 4)

  var hash = this._update(this._block) || this._hash()

  return enc ? hash.toString(enc) : hash
}

Hash.prototype._update = function () {
  throw new Error('_update must be implemented by subclass')
}

module.exports = Hash

}).call(this,require("buffer").Buffer)

},{"buffer":152}],286:[function(require,module,exports){
var exports = module.exports = function SHA (algorithm) {
  algorithm = algorithm.toLowerCase()

  var Algorithm = exports[algorithm]
  if (!Algorithm) throw new Error(algorithm + ' is not supported (we accept pull requests)')

  return new Algorithm()
}

exports.sha = require('./sha')
exports.sha1 = require('./sha1')
exports.sha224 = require('./sha224')
exports.sha256 = require('./sha256')
exports.sha384 = require('./sha384')
exports.sha512 = require('./sha512')

},{"./sha":287,"./sha1":288,"./sha224":289,"./sha256":290,"./sha384":291,"./sha512":292}],287:[function(require,module,exports){
(function (Buffer){
/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-0, as defined
 * in FIPS PUB 180-1
 * This source code is derived from sha1.js of the same repository.
 * The difference between SHA-0 and SHA-1 is just a bitwise rotate left
 * operation was added.
 */

var inherits = require('inherits')
var Hash = require('./hash')

var W = new Array(80)

function Sha () {
  this.init()
  this._w = W

  Hash.call(this, 64, 56)
}

inherits(Sha, Hash)

Sha.prototype.init = function () {
  this._a = 0x67452301 | 0
  this._b = 0xefcdab89 | 0
  this._c = 0x98badcfe | 0
  this._d = 0x10325476 | 0
  this._e = 0xc3d2e1f0 | 0

  return this
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function rol (num, cnt) {
  return (num << cnt) | (num >>> (32 - cnt))
}

Sha.prototype._update = function (M) {
  var W = this._w

  var a = this._a
  var b = this._b
  var c = this._c
  var d = this._d
  var e = this._e

  var j = 0
  var k

  /*
   * SHA-1 has a bitwise rotate left operation. But, SHA is not
   * function calcW() { return rol(W[j - 3] ^ W[j -  8] ^ W[j - 14] ^ W[j - 16], 1) }
   */
  function calcW () { return W[j - 3] ^ W[j - 8] ^ W[j - 14] ^ W[j - 16] }
  function loop (w, f) {
    W[j] = w

    var t = rol(a, 5) + f + e + w + k

    e = d
    d = c
    c = rol(b, 30)
    b = a
    a = t
    j++
  }

  k = 1518500249
  while (j < 16) loop(M.readInt32BE(j * 4), (b & c) | ((~b) & d))
  while (j < 20) loop(calcW(), (b & c) | ((~b) & d))
  k = 1859775393
  while (j < 40) loop(calcW(), b ^ c ^ d)
  k = -1894007588
  while (j < 60) loop(calcW(), (b & c) | (b & d) | (c & d))
  k = -899497514
  while (j < 80) loop(calcW(), b ^ c ^ d)

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
}

Sha.prototype._hash = function () {
  var H = new Buffer(20)

  H.writeInt32BE(this._a | 0, 0)
  H.writeInt32BE(this._b | 0, 4)
  H.writeInt32BE(this._c | 0, 8)
  H.writeInt32BE(this._d | 0, 12)
  H.writeInt32BE(this._e | 0, 16)

  return H
}

module.exports = Sha


}).call(this,require("buffer").Buffer)

},{"./hash":285,"buffer":152,"inherits":349}],288:[function(require,module,exports){
(function (Buffer){
/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

var inherits = require('inherits')
var Hash = require('./hash')

var W = new Array(80)

function Sha1 () {
  this.init()
  this._w = W

  Hash.call(this, 64, 56)
}

inherits(Sha1, Hash)

Sha1.prototype.init = function () {
  this._a = 0x67452301 | 0
  this._b = 0xefcdab89 | 0
  this._c = 0x98badcfe | 0
  this._d = 0x10325476 | 0
  this._e = 0xc3d2e1f0 | 0

  return this
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function rol (num, cnt) {
  return (num << cnt) | (num >>> (32 - cnt))
}

Sha1.prototype._update = function (M) {
  var W = this._w

  var a = this._a
  var b = this._b
  var c = this._c
  var d = this._d
  var e = this._e

  var j = 0
  var k

  function calcW () { return rol(W[j - 3] ^ W[j - 8] ^ W[j - 14] ^ W[j - 16], 1) }
  function loop (w, f) {
    W[j] = w

    var t = rol(a, 5) + f + e + w + k

    e = d
    d = c
    c = rol(b, 30)
    b = a
    a = t
    j++
  }

  k = 1518500249
  while (j < 16) loop(M.readInt32BE(j * 4), (b & c) | ((~b) & d))
  while (j < 20) loop(calcW(), (b & c) | ((~b) & d))
  k = 1859775393
  while (j < 40) loop(calcW(), b ^ c ^ d)
  k = -1894007588
  while (j < 60) loop(calcW(), (b & c) | (b & d) | (c & d))
  k = -899497514
  while (j < 80) loop(calcW(), b ^ c ^ d)

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
}

Sha1.prototype._hash = function () {
  var H = new Buffer(20)

  H.writeInt32BE(this._a | 0, 0)
  H.writeInt32BE(this._b | 0, 4)
  H.writeInt32BE(this._c | 0, 8)
  H.writeInt32BE(this._d | 0, 12)
  H.writeInt32BE(this._e | 0, 16)

  return H
}

module.exports = Sha1

}).call(this,require("buffer").Buffer)

},{"./hash":285,"buffer":152,"inherits":349}],289:[function(require,module,exports){
(function (Buffer){
/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = require('inherits')
var Sha256 = require('./sha256')
var Hash = require('./hash')

var W = new Array(64)

function Sha224 () {
  this.init()

  this._w = W // new Array(64)

  Hash.call(this, 64, 56)
}

inherits(Sha224, Sha256)

Sha224.prototype.init = function () {
  this._a = 0xc1059ed8 | 0
  this._b = 0x367cd507 | 0
  this._c = 0x3070dd17 | 0
  this._d = 0xf70e5939 | 0
  this._e = 0xffc00b31 | 0
  this._f = 0x68581511 | 0
  this._g = 0x64f98fa7 | 0
  this._h = 0xbefa4fa4 | 0

  return this
}

Sha224.prototype._hash = function () {
  var H = new Buffer(28)

  H.writeInt32BE(this._a, 0)
  H.writeInt32BE(this._b, 4)
  H.writeInt32BE(this._c, 8)
  H.writeInt32BE(this._d, 12)
  H.writeInt32BE(this._e, 16)
  H.writeInt32BE(this._f, 20)
  H.writeInt32BE(this._g, 24)

  return H
}

module.exports = Sha224

}).call(this,require("buffer").Buffer)

},{"./hash":285,"./sha256":290,"buffer":152,"inherits":349}],290:[function(require,module,exports){
(function (Buffer){
/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = require('inherits')
var Hash = require('./hash')

var K = [
  0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
  0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
  0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
  0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
  0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
  0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
  0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
  0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
  0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
  0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
  0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
  0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
  0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
  0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
  0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
  0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
]

var W = new Array(64)

function Sha256 () {
  this.init()

  this._w = W // new Array(64)

  Hash.call(this, 64, 56)
}

inherits(Sha256, Hash)

Sha256.prototype.init = function () {
  this._a = 0x6a09e667 | 0
  this._b = 0xbb67ae85 | 0
  this._c = 0x3c6ef372 | 0
  this._d = 0xa54ff53a | 0
  this._e = 0x510e527f | 0
  this._f = 0x9b05688c | 0
  this._g = 0x1f83d9ab | 0
  this._h = 0x5be0cd19 | 0

  return this
}

function Ch (x, y, z) {
  return z ^ (x & (y ^ z))
}

function Maj (x, y, z) {
  return (x & y) | (z & (x | y))
}

function Sigma0 (x) {
  return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10)
}

function Sigma1 (x) {
  return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7)
}

function Gamma0 (x) {
  return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ (x >>> 3)
}

function Gamma1 (x) {
  return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ (x >>> 10)
}

Sha256.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0
  var f = this._f | 0
  var g = this._g | 0
  var h = this._h | 0

  var j = 0

  function calcW () { return Gamma1(W[j - 2]) + W[j - 7] + Gamma0(W[j - 15]) + W[j - 16] }
  function loop (w) {
    W[j] = w

    var T1 = h + Sigma1(e) + Ch(e, f, g) + K[j] + w
    var T2 = Sigma0(a) + Maj(a, b, c)

    h = g
    g = f
    f = e
    e = d + T1
    d = c
    c = b
    b = a
    a = T1 + T2

    j++
  }

  while (j < 16) loop(M.readInt32BE(j * 4))
  while (j < 64) loop(calcW())

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
  this._f = (f + this._f) | 0
  this._g = (g + this._g) | 0
  this._h = (h + this._h) | 0
}

Sha256.prototype._hash = function () {
  var H = new Buffer(32)

  H.writeInt32BE(this._a, 0)
  H.writeInt32BE(this._b, 4)
  H.writeInt32BE(this._c, 8)
  H.writeInt32BE(this._d, 12)
  H.writeInt32BE(this._e, 16)
  H.writeInt32BE(this._f, 20)
  H.writeInt32BE(this._g, 24)
  H.writeInt32BE(this._h, 28)

  return H
}

module.exports = Sha256

}).call(this,require("buffer").Buffer)

},{"./hash":285,"buffer":152,"inherits":349}],291:[function(require,module,exports){
(function (Buffer){
var inherits = require('inherits')
var SHA512 = require('./sha512')
var Hash = require('./hash')

var W = new Array(160)

function Sha384 () {
  this.init()
  this._w = W

  Hash.call(this, 128, 112)
}

inherits(Sha384, SHA512)

Sha384.prototype.init = function () {
  this._a = 0xcbbb9d5d | 0
  this._b = 0x629a292a | 0
  this._c = 0x9159015a | 0
  this._d = 0x152fecd8 | 0
  this._e = 0x67332667 | 0
  this._f = 0x8eb44a87 | 0
  this._g = 0xdb0c2e0d | 0
  this._h = 0x47b5481d | 0

  this._al = 0xc1059ed8 | 0
  this._bl = 0x367cd507 | 0
  this._cl = 0x3070dd17 | 0
  this._dl = 0xf70e5939 | 0
  this._el = 0xffc00b31 | 0
  this._fl = 0x68581511 | 0
  this._gl = 0x64f98fa7 | 0
  this._hl = 0xbefa4fa4 | 0

  return this
}

Sha384.prototype._hash = function () {
  var H = new Buffer(48)

  function writeInt64BE (h, l, offset) {
    H.writeInt32BE(h, offset)
    H.writeInt32BE(l, offset + 4)
  }

  writeInt64BE(this._a, this._al, 0)
  writeInt64BE(this._b, this._bl, 8)
  writeInt64BE(this._c, this._cl, 16)
  writeInt64BE(this._d, this._dl, 24)
  writeInt64BE(this._e, this._el, 32)
  writeInt64BE(this._f, this._fl, 40)

  return H
}

module.exports = Sha384

}).call(this,require("buffer").Buffer)

},{"./hash":285,"./sha512":292,"buffer":152,"inherits":349}],292:[function(require,module,exports){
(function (Buffer){
var inherits = require('inherits')
var Hash = require('./hash')

var K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
]

var W = new Array(160)

function Sha512 () {
  this.init()
  this._w = W

  Hash.call(this, 128, 112)
}

inherits(Sha512, Hash)

Sha512.prototype.init = function () {
  this._a = 0x6a09e667 | 0
  this._b = 0xbb67ae85 | 0
  this._c = 0x3c6ef372 | 0
  this._d = 0xa54ff53a | 0
  this._e = 0x510e527f | 0
  this._f = 0x9b05688c | 0
  this._g = 0x1f83d9ab | 0
  this._h = 0x5be0cd19 | 0

  this._al = 0xf3bcc908 | 0
  this._bl = 0x84caa73b | 0
  this._cl = 0xfe94f82b | 0
  this._dl = 0x5f1d36f1 | 0
  this._el = 0xade682d1 | 0
  this._fl = 0x2b3e6c1f | 0
  this._gl = 0xfb41bd6b | 0
  this._hl = 0x137e2179 | 0

  return this
}

function Ch (x, y, z) {
  return z ^ (x & (y ^ z))
}

function Maj (x, y, z) {
  return (x & y) | (z & (x | y))
}

function Sigma0 (x, xl) {
  return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25)
}

function Sigma1 (x, xl) {
  return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23)
}

function Gamma0 (x, xl) {
  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7)
}

function Gamma0l (x, xl) {
  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25)
}

function Gamma1 (x, xl) {
  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6)
}

function Gamma1l (x, xl) {
  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26)
}

Sha512.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0
  var f = this._f | 0
  var g = this._g | 0
  var h = this._h | 0

  var al = this._al | 0
  var bl = this._bl | 0
  var cl = this._cl | 0
  var dl = this._dl | 0
  var el = this._el | 0
  var fl = this._fl | 0
  var gl = this._gl | 0
  var hl = this._hl | 0

  var i = 0
  var j = 0
  var Wi, Wil
  function calcW () {
    var x = W[j - 15 * 2]
    var xl = W[j - 15 * 2 + 1]
    var gamma0 = Gamma0(x, xl)
    var gamma0l = Gamma0l(xl, x)

    x = W[j - 2 * 2]
    xl = W[j - 2 * 2 + 1]
    var gamma1 = Gamma1(x, xl)
    var gamma1l = Gamma1l(xl, x)

    // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
    var Wi7 = W[j - 7 * 2]
    var Wi7l = W[j - 7 * 2 + 1]

    var Wi16 = W[j - 16 * 2]
    var Wi16l = W[j - 16 * 2 + 1]

    Wil = gamma0l + Wi7l
    Wi = gamma0 + Wi7 + ((Wil >>> 0) < (gamma0l >>> 0) ? 1 : 0)
    Wil = Wil + gamma1l
    Wi = Wi + gamma1 + ((Wil >>> 0) < (gamma1l >>> 0) ? 1 : 0)
    Wil = Wil + Wi16l
    Wi = Wi + Wi16 + ((Wil >>> 0) < (Wi16l >>> 0) ? 1 : 0)
  }

  function loop () {
    W[j] = Wi
    W[j + 1] = Wil

    var maj = Maj(a, b, c)
    var majl = Maj(al, bl, cl)

    var sigma0h = Sigma0(a, al)
    var sigma0l = Sigma0(al, a)
    var sigma1h = Sigma1(e, el)
    var sigma1l = Sigma1(el, e)

    // t1 = h + sigma1 + ch + K[i] + W[i]
    var Ki = K[j]
    var Kil = K[j + 1]

    var ch = Ch(e, f, g)
    var chl = Ch(el, fl, gl)

    var t1l = hl + sigma1l
    var t1 = h + sigma1h + ((t1l >>> 0) < (hl >>> 0) ? 1 : 0)
    t1l = t1l + chl
    t1 = t1 + ch + ((t1l >>> 0) < (chl >>> 0) ? 1 : 0)
    t1l = t1l + Kil
    t1 = t1 + Ki + ((t1l >>> 0) < (Kil >>> 0) ? 1 : 0)
    t1l = t1l + Wil
    t1 = t1 + Wi + ((t1l >>> 0) < (Wil >>> 0) ? 1 : 0)

    // t2 = sigma0 + maj
    var t2l = sigma0l + majl
    var t2 = sigma0h + maj + ((t2l >>> 0) < (sigma0l >>> 0) ? 1 : 0)

    h = g
    hl = gl
    g = f
    gl = fl
    f = e
    fl = el
    el = (dl + t1l) | 0
    e = (d + t1 + ((el >>> 0) < (dl >>> 0) ? 1 : 0)) | 0
    d = c
    dl = cl
    c = b
    cl = bl
    b = a
    bl = al
    al = (t1l + t2l) | 0
    a = (t1 + t2 + ((al >>> 0) < (t1l >>> 0) ? 1 : 0)) | 0

    i++
    j += 2
  }

  while (i < 16) {
    Wi = M.readInt32BE(j * 4)
    Wil = M.readInt32BE(j * 4 + 4)

    loop()
  }

  while (i < 80) {
    calcW()
    loop()
  }

  this._al = (this._al + al) | 0
  this._bl = (this._bl + bl) | 0
  this._cl = (this._cl + cl) | 0
  this._dl = (this._dl + dl) | 0
  this._el = (this._el + el) | 0
  this._fl = (this._fl + fl) | 0
  this._gl = (this._gl + gl) | 0
  this._hl = (this._hl + hl) | 0

  this._a = (this._a + a + ((this._al >>> 0) < (al >>> 0) ? 1 : 0)) | 0
  this._b = (this._b + b + ((this._bl >>> 0) < (bl >>> 0) ? 1 : 0)) | 0
  this._c = (this._c + c + ((this._cl >>> 0) < (cl >>> 0) ? 1 : 0)) | 0
  this._d = (this._d + d + ((this._dl >>> 0) < (dl >>> 0) ? 1 : 0)) | 0
  this._e = (this._e + e + ((this._el >>> 0) < (el >>> 0) ? 1 : 0)) | 0
  this._f = (this._f + f + ((this._fl >>> 0) < (fl >>> 0) ? 1 : 0)) | 0
  this._g = (this._g + g + ((this._gl >>> 0) < (gl >>> 0) ? 1 : 0)) | 0
  this._h = (this._h + h + ((this._hl >>> 0) < (hl >>> 0) ? 1 : 0)) | 0
}

Sha512.prototype._hash = function () {
  var H = new Buffer(64)

  function writeInt64BE (h, l, offset) {
    H.writeInt32BE(h, offset)
    H.writeInt32BE(l, offset + 4)
  }

  writeInt64BE(this._a, this._al, 0)
  writeInt64BE(this._b, this._bl, 8)
  writeInt64BE(this._c, this._cl, 16)
  writeInt64BE(this._d, this._dl, 24)
  writeInt64BE(this._e, this._el, 32)
  writeInt64BE(this._f, this._fl, 40)
  writeInt64BE(this._g, this._gl, 48)
  writeInt64BE(this._h, this._hl, 56)

  return H
}

module.exports = Sha512

}).call(this,require("buffer").Buffer)

},{"./hash":285,"buffer":152,"inherits":349}],293:[function(require,module,exports){
(function (Buffer){
'use strict';
var createHash = require('create-hash/browser');
var inherits = require('inherits')

var Transform = require('stream').Transform

var ZEROS = new Buffer(128)
ZEROS.fill(0)

function Hmac(alg, key) {
  Transform.call(this)
  alg = alg.toLowerCase()
  if (typeof key === 'string') {
    key = new Buffer(key)
  }

  var blocksize = (alg === 'sha512' || alg === 'sha384') ? 128 : 64

  this._alg = alg
  this._key = key

  if (key.length > blocksize) {
    key = createHash(alg).update(key).digest()

  } else if (key.length < blocksize) {
    key = Buffer.concat([key, ZEROS], blocksize)
  }

  var ipad = this._ipad = new Buffer(blocksize)
  var opad = this._opad = new Buffer(blocksize)

  for (var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36
    opad[i] = key[i] ^ 0x5C
  }

  this._hash = createHash(alg).update(ipad)
}

inherits(Hmac, Transform)

Hmac.prototype.update = function (data, enc) {
  this._hash.update(data, enc)

  return this
}

Hmac.prototype._transform = function (data, _, next) {
  this._hash.update(data)

  next()
}

Hmac.prototype._flush = function (next) {
  this.push(this.digest())

  next()
}

Hmac.prototype.digest = function (enc) {
  var h = this._hash.digest()

  return createHash(this._alg).update(this._opad).update(h).digest(enc)
}

module.exports = function createHmac(alg, key) {
  return new Hmac(alg, key)
}

}).call(this,require("buffer").Buffer)

},{"buffer":152,"create-hash/browser":280,"inherits":349,"stream":366}],294:[function(require,module,exports){
(function (Buffer){
var generatePrime = require('./lib/generatePrime');
var primes = require('./lib/primes');

var DH = require('./lib/dh');

function getDiffieHellman(mod) {
  var prime = new Buffer(primes[mod].prime, 'hex');
  var gen = new Buffer(primes[mod].gen, 'hex');

  return new DH(prime, gen);
}

function createDiffieHellman(prime, enc, generator, genc) {
  if (Buffer.isBuffer(enc) || (typeof enc === 'string' && ['hex', 'binary', 'base64'].indexOf(enc) === -1)) {
    genc = generator;
    generator = enc;
    enc = undefined;
  }

  enc = enc || 'binary';
  genc = genc || 'binary';
  generator = generator || new Buffer([2]);

  if (!Buffer.isBuffer(generator)) {
    generator = new Buffer(generator, genc);
  }

  if (typeof prime === 'number') {
    return new DH(generatePrime(prime, generator), generator, true);
  }

  if (!Buffer.isBuffer(prime)) {
    prime = new Buffer(prime, enc);
  }

  return new DH(prime, generator, true);
}

exports.DiffieHellmanGroup = exports.createDiffieHellmanGroup = exports.getDiffieHellman = getDiffieHellman;
exports.createDiffieHellman = exports.DiffieHellman = createDiffieHellman;

}).call(this,require("buffer").Buffer)

},{"./lib/dh":295,"./lib/generatePrime":296,"./lib/primes":297,"buffer":152}],295:[function(require,module,exports){
(function (Buffer){
var BN = require('bn.js');
var MillerRabin = require('miller-rabin');
var millerRabin = new MillerRabin();
var TWENTYFOUR = new BN(24);
var ELEVEN = new BN(11);
var TEN = new BN(10);
var THREE = new BN(3);
var SEVEN = new BN(7);
var primes = require('./generatePrime');
var randomBytes = require('randombytes');
module.exports = DH;

function setPublicKey(pub, enc) {
  enc = enc || 'utf8';
  if (!Buffer.isBuffer(pub)) {
    pub = new Buffer(pub, enc);
  }
  this._pub = new BN(pub);
  return this;
}

function setPrivateKey(priv, enc) {
  enc = enc || 'utf8';
  if (!Buffer.isBuffer(priv)) {
    priv = new Buffer(priv, enc);
  }
  this._priv = new BN(priv);
  return this;
}

var primeCache = {};
function checkPrime(prime, generator) {
  var gen = generator.toString('hex');
  var hex = [gen, prime.toString(16)].join('_');
  if (hex in primeCache) {
    return primeCache[hex];
  }
  var error = 0;

  if (prime.isEven() ||
    !primes.simpleSieve ||
    !primes.fermatTest(prime) ||
    !millerRabin.test(prime)) {
    //not a prime so +1
    error += 1;

    if (gen === '02' || gen === '05') {
      // we'd be able to check the generator
      // it would fail so +8
      error += 8;
    } else {
      //we wouldn't be able to test the generator
      // so +4
      error += 4;
    }
    primeCache[hex] = error;
    return error;
  }
  if (!millerRabin.test(prime.shrn(1))) {
    //not a safe prime
    error += 2;
  }
  var rem;
  switch (gen) {
    case '02':
      if (prime.mod(TWENTYFOUR).cmp(ELEVEN)) {
        // unsuidable generator
        error += 8;
      }
      break;
    case '05':
      rem = prime.mod(TEN);
      if (rem.cmp(THREE) && rem.cmp(SEVEN)) {
        // prime mod 10 needs to equal 3 or 7
        error += 8;
      }
      break;
    default:
      error += 4;
  }
  primeCache[hex] = error;
  return error;
}

function DH(prime, generator, malleable) {
  this.setGenerator(generator);
  this.__prime = new BN(prime);
  this._prime = BN.mont(this.__prime);
  this._primeLen = prime.length;
  this._pub = undefined;
  this._priv = undefined;
  this._primeCode = undefined;
  if (malleable) {
    this.setPublicKey = setPublicKey;
    this.setPrivateKey = setPrivateKey;
  } else {
    this._primeCode = 8;
  }
}
Object.defineProperty(DH.prototype, 'verifyError', {
  enumerable: true,
  get: function () {
    if (typeof this._primeCode !== 'number') {
      this._primeCode = checkPrime(this.__prime, this.__gen);
    }
    return this._primeCode;
  }
});
DH.prototype.generateKeys = function () {
  if (!this._priv) {
    this._priv = new BN(randomBytes(this._primeLen));
  }
  this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed();
  return this.getPublicKey();
};

DH.prototype.computeSecret = function (other) {
  other = new BN(other);
  other = other.toRed(this._prime);
  var secret = other.redPow(this._priv).fromRed();
  var out = new Buffer(secret.toArray());
  var prime = this.getPrime();
  if (out.length < prime.length) {
    var front = new Buffer(prime.length - out.length);
    front.fill(0);
    out = Buffer.concat([front, out]);
  }
  return out;
};

DH.prototype.getPublicKey = function getPublicKey(enc) {
  return formatReturnValue(this._pub, enc);
};

DH.prototype.getPrivateKey = function getPrivateKey(enc) {
  return formatReturnValue(this._priv, enc);
};

DH.prototype.getPrime = function (enc) {
  return formatReturnValue(this.__prime, enc);
};

DH.prototype.getGenerator = function (enc) {
  return formatReturnValue(this._gen, enc);
};

DH.prototype.setGenerator = function (gen, enc) {
  enc = enc || 'utf8';
  if (!Buffer.isBuffer(gen)) {
    gen = new Buffer(gen, enc);
  }
  this.__gen = gen;
  this._gen = new BN(gen);
  return this;
};

function formatReturnValue(bn, enc) {
  var buf = new Buffer(bn.toArray());
  if (!enc) {
    return buf;
  } else {
    return buf.toString(enc);
  }
}

}).call(this,require("buffer").Buffer)

},{"./generatePrime":296,"bn.js":298,"buffer":152,"miller-rabin":299,"randombytes":347}],296:[function(require,module,exports){
var randomBytes = require('randombytes');
module.exports = findPrime;
findPrime.simpleSieve = simpleSieve;
findPrime.fermatTest = fermatTest;
var BN = require('bn.js');
var TWENTYFOUR = new BN(24);
var MillerRabin = require('miller-rabin');
var millerRabin = new MillerRabin();
var ONE = new BN(1);
var TWO = new BN(2);
var FIVE = new BN(5);
var SIXTEEN = new BN(16);
var EIGHT = new BN(8);
var TEN = new BN(10);
var THREE = new BN(3);
var SEVEN = new BN(7);
var ELEVEN = new BN(11);
var FOUR = new BN(4);
var TWELVE = new BN(12);
var primes = null;

function _getPrimes() {
  if (primes !== null)
    return primes;

  var limit = 0x100000;
  var res = [];
  res[0] = 2;
  for (var i = 1, k = 3; k < limit; k += 2) {
    var sqrt = Math.ceil(Math.sqrt(k));
    for (var j = 0; j < i && res[j] <= sqrt; j++)
      if (k % res[j] === 0)
        break;

    if (i !== j && res[j] <= sqrt)
      continue;

    res[i++] = k;
  }
  primes = res;
  return res;
}

function simpleSieve(p) {
  var primes = _getPrimes();

  for (var i = 0; i < primes.length; i++)
    if (p.modn(primes[i]) === 0) {
      if (p.cmpn(primes[i]) === 0) {
        return true;
      } else {
        return false;
      }
    }

  return true;
}

function fermatTest(p) {
  var red = BN.mont(p);
  return TWO.toRed(red).redPow(p.subn(1)).fromRed().cmpn(1) === 0;
}

function findPrime(bits, gen) {
  if (bits < 16) {
    // this is what openssl does
    if (gen === 2 || gen === 5) {
      return new BN([0x8c, 0x7b]);
    } else {
      return new BN([0x8c, 0x27]);
    }
  }
  gen = new BN(gen);

  var num, n2;

  while (true) {
    num = new BN(randomBytes(Math.ceil(bits / 8)));
    while (num.bitLength() > bits) {
      num.ishrn(1);
    }
    if (num.isEven()) {
      num.iadd(ONE);
    }
    if (!num.testn(1)) {
      num.iadd(TWO);
    }
    if (!gen.cmp(TWO)) {
      while (num.mod(TWENTYFOUR).cmp(ELEVEN)) {
        num.iadd(FOUR);
      }
    } else if (!gen.cmp(FIVE)) {
      while (num.mod(TEN).cmp(THREE)) {
        num.iadd(FOUR);
      }
    }
    n2 = num.shrn(1);
    if (simpleSieve(n2) && simpleSieve(num) &&
      fermatTest(n2) && fermatTest(num) &&
      millerRabin.test(n2) && millerRabin.test(num)) {
      return num;
    }
  }

}

},{"bn.js":298,"miller-rabin":299,"randombytes":347}],297:[function(require,module,exports){
module.exports={
    "modp1": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
    },
    "modp2": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
    },
    "modp5": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
    },
    "modp14": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
    },
    "modp15": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
    },
    "modp16": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
    },
    "modp17": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
    },
    "modp18": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
    }
}
},{}],298:[function(require,module,exports){
arguments[4][189][0].apply(exports,arguments)
},{"dup":189}],299:[function(require,module,exports){
var bn = require('bn.js');
var brorand = require('brorand');

function MillerRabin(rand) {
  this.rand = rand || new brorand.Rand();
}
module.exports = MillerRabin;

MillerRabin.create = function create(rand) {
  return new MillerRabin(rand);
};

MillerRabin.prototype._rand = function _rand(n) {
  var len = n.bitLength();
  var buf = this.rand.generate(Math.ceil(len / 8));

  // Set low bits
  buf[0] |= 3;

  // Mask high bits
  var mask = len & 0x7;
  if (mask !== 0)
    buf[buf.length - 1] >>= 7 - mask;

  return new bn(buf);
}

MillerRabin.prototype.test = function test(n, k, cb) {
  var len = n.bitLength();
  var red = bn.mont(n);
  var rone = new bn(1).toRed(red);

  if (!k)
    k = Math.max(1, (len / 48) | 0);

  // Find d and s, (n - 1) = (2 ^ s) * d;
  var n1 = n.subn(1);
  var n2 = n1.subn(1);
  for (var s = 0; !n1.testn(s); s++) {}
  var d = n.shrn(s);

  var rn1 = n1.toRed(red);

  var prime = true;
  for (; k > 0; k--) {
    var a = this._rand(n2);
    if (cb)
      cb(a);

    var x = a.toRed(red).redPow(d);
    if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
      continue;

    for (var i = 1; i < s; i++) {
      x = x.redSqr();

      if (x.cmp(rone) === 0)
        return false;
      if (x.cmp(rn1) === 0)
        break;
    }

    if (i === s)
      return false;
  }

  return prime;
};

MillerRabin.prototype.getDivisor = function getDivisor(n, k) {
  var len = n.bitLength();
  var red = bn.mont(n);
  var rone = new bn(1).toRed(red);

  if (!k)
    k = Math.max(1, (len / 48) | 0);

  // Find d and s, (n - 1) = (2 ^ s) * d;
  var n1 = n.subn(1);
  var n2 = n1.subn(1);
  for (var s = 0; !n1.testn(s); s++) {}
  var d = n.shrn(s);

  var rn1 = n1.toRed(red);

  for (; k > 0; k--) {
    var a = this._rand(n2);

    var g = n.gcd(a);
    if (g.cmpn(1) !== 0)
      return g;

    var x = a.toRed(red).redPow(d);
    if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
      continue;

    for (var i = 1; i < s; i++) {
      x = x.redSqr();

      if (x.cmp(rone) === 0)
        return x.fromRed().subn(1).gcd(n);
      if (x.cmp(rn1) === 0)
        break;
    }

    if (i === s) {
      x = x.redSqr();
      return x.fromRed().subn(1).gcd(n);
    }
  }

  return false;
};

},{"bn.js":298,"brorand":300}],300:[function(require,module,exports){
arguments[4][207][0].apply(exports,arguments)
},{"dup":207}],301:[function(require,module,exports){
(function (Buffer){
var createHmac = require('create-hmac')
var MAX_ALLOC = Math.pow(2, 30) - 1 // default in iojs

exports.pbkdf2 = pbkdf2
function pbkdf2 (password, salt, iterations, keylen, digest, callback) {
  if (typeof digest === 'function') {
    callback = digest
    digest = undefined
  }

  if (typeof callback !== 'function') {
    throw new Error('No callback provided to pbkdf2')
  }

  var result = pbkdf2Sync(password, salt, iterations, keylen, digest)
  setTimeout(function () {
    callback(undefined, result)
  })
}

exports.pbkdf2Sync = pbkdf2Sync
function pbkdf2Sync (password, salt, iterations, keylen, digest) {
  if (typeof iterations !== 'number') {
    throw new TypeError('Iterations not a number')
  }

  if (iterations < 0) {
    throw new TypeError('Bad iterations')
  }

  if (typeof keylen !== 'number') {
    throw new TypeError('Key length not a number')
  }

  if (keylen < 0 || keylen > MAX_ALLOC) {
    throw new TypeError('Bad key length')
  }

  digest = digest || 'sha1'

  if (!Buffer.isBuffer(password)) password = new Buffer(password, 'binary')
  if (!Buffer.isBuffer(salt)) salt = new Buffer(salt, 'binary')

  var hLen
  var l = 1
  var DK = new Buffer(keylen)
  var block1 = new Buffer(salt.length + 4)
  salt.copy(block1, 0, 0, salt.length)

  var r
  var T

  for (var i = 1; i <= l; i++) {
    block1.writeUInt32BE(i, salt.length)
    var U = createHmac(digest, password).update(block1).digest()

    if (!hLen) {
      hLen = U.length
      T = new Buffer(hLen)
      l = Math.ceil(keylen / hLen)
      r = keylen - (l - 1) * hLen
    }

    U.copy(T, 0, 0, hLen)

    for (var j = 1; j < iterations; j++) {
      U = createHmac(digest, password).update(U).digest()

      for (var k = 0; k < hLen; k++) {
        T[k] ^= U[k]
      }
    }

    var destPos = (i - 1) * hLen
    var len = (i === l ? r : hLen)
    T.copy(DK, destPos, 0, len)
  }

  return DK
}

}).call(this,require("buffer").Buffer)

},{"buffer":152,"create-hmac":293}],302:[function(require,module,exports){
exports.publicEncrypt = require('./publicEncrypt');
exports.privateDecrypt = require('./privateDecrypt');

exports.privateEncrypt = function privateEncrypt(key, buf) {
  return exports.publicEncrypt(key, buf, true);
};

exports.publicDecrypt = function publicDecrypt(key, buf) {
  return exports.privateDecrypt(key, buf, true);
};
},{"./privateDecrypt":343,"./publicEncrypt":344}],303:[function(require,module,exports){
(function (Buffer){
var createHash = require('create-hash');
module.exports = function (seed, len) {
  var t = new Buffer('');
  var  i = 0, c;
  while (t.length < len) {
    c = i2ops(i++);
    t = Buffer.concat([t, createHash('sha1').update(seed).update(c).digest()]);
  }
  return t.slice(0, len);
};

function i2ops(c) {
  var out = new Buffer(4);
  out.writeUInt32BE(c,0);
  return out;
}
}).call(this,require("buffer").Buffer)

},{"buffer":152,"create-hash":280}],304:[function(require,module,exports){
arguments[4][189][0].apply(exports,arguments)
},{"dup":189}],305:[function(require,module,exports){
(function (Buffer){
var bn = require('bn.js');
var randomBytes = require('randombytes');
module.exports = crt;
function blind(priv) {
  var r = getr(priv);
  var blinder = r.toRed(bn.mont(priv.modulus))
  .redPow(new bn(priv.publicExponent)).fromRed();
  return {
    blinder: blinder,
    unblinder:r.invm(priv.modulus)
  };
}
function crt(msg, priv) {
  var blinds = blind(priv);
  var len = priv.modulus.byteLength();
  var mod = bn.mont(priv.modulus);
  var blinded = new bn(msg).mul(blinds.blinder).umod(priv.modulus);
  var c1 = blinded.toRed(bn.mont(priv.prime1));
  var c2 = blinded.toRed(bn.mont(priv.prime2));
  var qinv = priv.coefficient;
  var p = priv.prime1;
  var q = priv.prime2;
  var m1 = c1.redPow(priv.exponent1);
  var m2 = c2.redPow(priv.exponent2);
  m1 = m1.fromRed();
  m2 = m2.fromRed();
  var h = m1.isub(m2).imul(qinv).umod(p);
  h.imul(q);
  m2.iadd(h);
  return new Buffer(m2.imul(blinds.unblinder).umod(priv.modulus).toArray(false, len));
}
crt.getr = getr;
function getr(priv) {
  var len = priv.modulus.byteLength();
  var r = new bn(randomBytes(len));
  while (r.cmp(priv.modulus) >=  0 || !r.umod(priv.prime1) || !r.umod(priv.prime2)) {
    r = new bn(randomBytes(len));
  }
  return r;
}

}).call(this,require("buffer").Buffer)

},{"bn.js":304,"buffer":152,"randombytes":347}],306:[function(require,module,exports){
arguments[4][215][0].apply(exports,arguments)
},{"dup":215}],307:[function(require,module,exports){
arguments[4][216][0].apply(exports,arguments)
},{"asn1.js":310,"dup":216}],308:[function(require,module,exports){
(function (Buffer){
// adapted from https://github.com/apatil/pemstrip
var findProc = /Proc-Type: 4,ENCRYPTED\r?\nDEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)\r?\n\r?\n([0-9A-z\n\r\+\/\=]+)\r?\n/m
var startRegex = /^-----BEGIN (.*) KEY-----\r?\n/m
var fullRegex = /^-----BEGIN (.*) KEY-----\r?\n([0-9A-z\n\r\+\/\=]+)\r?\n-----END \1 KEY-----$/m
var evp = require('evp_bytestokey')
var ciphers = require('browserify-aes')
module.exports = function (okey, password) {
  var key = okey.toString()
  var match = key.match(findProc)
  var decrypted
  if (!match) {
    var match2 = key.match(fullRegex)
    decrypted = new Buffer(match2[2].replace(/\r?\n/g, ''), 'base64')
  } else {
    var suite = 'aes' + match[1]
    var iv = new Buffer(match[2], 'hex')
    var cipherText = new Buffer(match[3].replace(/\r?\n/g, ''), 'base64')
    var cipherKey = evp(password, iv.slice(0, 8), parseInt(match[1], 10)).key
    var out = []
    var cipher = ciphers.createDecipheriv(suite, cipherKey, iv)
    out.push(cipher.update(cipherText))
    out.push(cipher.final())
    decrypted = Buffer.concat(out)
  }
  var tag = key.match(startRegex)[1] + ' KEY'
  return {
    tag: tag,
    data: decrypted
  }
}

}).call(this,require("buffer").Buffer)

},{"browserify-aes":327,"buffer":152,"evp_bytestokey":342}],309:[function(require,module,exports){
(function (Buffer){
var asn1 = require('./asn1')
var aesid = require('./aesid.json')
var fixProc = require('./fixProc')
var ciphers = require('browserify-aes')
var compat = require('pbkdf2')
module.exports = parseKeys

function parseKeys (buffer) {
  var password
  if (typeof buffer === 'object' && !Buffer.isBuffer(buffer)) {
    password = buffer.passphrase
    buffer = buffer.key
  }
  if (typeof buffer === 'string') {
    buffer = new Buffer(buffer)
  }

  var stripped = fixProc(buffer, password)

  var type = stripped.tag
  var data = stripped.data
  var subtype, ndata
  switch (type) {
    case 'PUBLIC KEY':
      ndata = asn1.PublicKey.decode(data, 'der')
      subtype = ndata.algorithm.algorithm.join('.')
      switch (subtype) {
        case '1.2.840.113549.1.1.1':
          return asn1.RSAPublicKey.decode(ndata.subjectPublicKey.data, 'der')
        case '1.2.840.10045.2.1':
          ndata.subjectPrivateKey = ndata.subjectPublicKey
          return {
            type: 'ec',
            data: ndata
          }
        case '1.2.840.10040.4.1':
          ndata.algorithm.params.pub_key = asn1.DSAparam.decode(ndata.subjectPublicKey.data, 'der')
          return {
            type: 'dsa',
            data: ndata.algorithm.params
          }
        default: throw new Error('unknown key id ' + subtype)
      }
      throw new Error('unknown key type ' + type)
    case 'ENCRYPTED PRIVATE KEY':
      data = asn1.EncryptedPrivateKey.decode(data, 'der')
      data = decrypt(data, password)
      // falls through
    case 'PRIVATE KEY':
      ndata = asn1.PrivateKey.decode(data, 'der')
      subtype = ndata.algorithm.algorithm.join('.')
      switch (subtype) {
        case '1.2.840.113549.1.1.1':
          return asn1.RSAPrivateKey.decode(ndata.subjectPrivateKey, 'der')
        case '1.2.840.10045.2.1':
          return {
            curve: ndata.algorithm.curve,
            privateKey: asn1.ECPrivateKey.decode(ndata.subjectPrivateKey, 'der').privateKey
          }
        case '1.2.840.10040.4.1':
          ndata.algorithm.params.priv_key = asn1.DSAparam.decode(ndata.subjectPrivateKey, 'der')
          return {
            type: 'dsa',
            params: ndata.algorithm.params
          }
        default: throw new Error('unknown key id ' + subtype)
      }
      throw new Error('unknown key type ' + type)
    case 'RSA PUBLIC KEY':
      return asn1.RSAPublicKey.decode(data, 'der')
    case 'RSA PRIVATE KEY':
      return asn1.RSAPrivateKey.decode(data, 'der')
    case 'DSA PRIVATE KEY':
      return {
        type: 'dsa',
        params: asn1.DSAPrivateKey.decode(data, 'der')
      }
    case 'EC PRIVATE KEY':
      data = asn1.ECPrivateKey.decode(data, 'der')
      return {
        curve: data.parameters.value,
        privateKey: data.privateKey
      }
    default: throw new Error('unknown key type ' + type)
  }
}
parseKeys.signature = asn1.signature
function decrypt (data, password) {
  var salt = data.algorithm.decrypt.kde.kdeparams.salt
  var iters = parseInt(data.algorithm.decrypt.kde.kdeparams.iters.toString(), 10)
  var algo = aesid[data.algorithm.decrypt.cipher.algo.join('.')]
  var iv = data.algorithm.decrypt.cipher.iv
  var cipherText = data.subjectPrivateKey
  var keylen = parseInt(algo.split('-')[1], 10) / 8
  var key = compat.pbkdf2Sync(password, salt, iters, keylen)
  var cipher = ciphers.createDecipheriv(algo, key, iv)
  var out = []
  out.push(cipher.update(cipherText))
  out.push(cipher.final())
  return Buffer.concat(out)
}

}).call(this,require("buffer").Buffer)

},{"./aesid.json":306,"./asn1":307,"./fixProc":308,"browserify-aes":327,"buffer":152,"pbkdf2":301}],310:[function(require,module,exports){
arguments[4][219][0].apply(exports,arguments)
},{"./asn1/api":311,"./asn1/base":313,"./asn1/constants":317,"./asn1/decoders":319,"./asn1/encoders":322,"bn.js":304,"dup":219}],311:[function(require,module,exports){
arguments[4][220][0].apply(exports,arguments)
},{"../asn1":310,"dup":220,"inherits":349,"vm":368}],312:[function(require,module,exports){
arguments[4][221][0].apply(exports,arguments)
},{"../base":313,"buffer":152,"dup":221,"inherits":349}],313:[function(require,module,exports){
arguments[4][222][0].apply(exports,arguments)
},{"./buffer":312,"./node":314,"./reporter":315,"dup":222}],314:[function(require,module,exports){
arguments[4][223][0].apply(exports,arguments)
},{"../base":313,"dup":223,"minimalistic-assert":324}],315:[function(require,module,exports){
arguments[4][224][0].apply(exports,arguments)
},{"dup":224,"inherits":349}],316:[function(require,module,exports){
arguments[4][225][0].apply(exports,arguments)
},{"../constants":317,"dup":225}],317:[function(require,module,exports){
arguments[4][226][0].apply(exports,arguments)
},{"./der":316,"dup":226}],318:[function(require,module,exports){
arguments[4][227][0].apply(exports,arguments)
},{"../../asn1":310,"dup":227,"inherits":349}],319:[function(require,module,exports){
arguments[4][228][0].apply(exports,arguments)
},{"./der":318,"./pem":320,"dup":228}],320:[function(require,module,exports){
arguments[4][229][0].apply(exports,arguments)
},{"../../asn1":310,"./der":318,"buffer":152,"dup":229,"inherits":349}],321:[function(require,module,exports){
arguments[4][230][0].apply(exports,arguments)
},{"../../asn1":310,"buffer":152,"dup":230,"inherits":349}],322:[function(require,module,exports){
arguments[4][231][0].apply(exports,arguments)
},{"./der":321,"./pem":323,"dup":231}],323:[function(require,module,exports){
arguments[4][232][0].apply(exports,arguments)
},{"../../asn1":310,"./der":321,"buffer":152,"dup":232,"inherits":349}],324:[function(require,module,exports){
arguments[4][184][0].apply(exports,arguments)
},{"dup":184}],325:[function(require,module,exports){
(function (Buffer){
// based on the aes implimentation in triple sec
// https://github.com/keybase/triplesec

// which is in turn based on the one from crypto-js
// https://code.google.com/p/crypto-js/

var uint_max = Math.pow(2, 32)
function fixup_uint32 (x) {
  var ret, x_pos
  ret = x > uint_max || x < 0 ? (x_pos = Math.abs(x) % uint_max, x < 0 ? uint_max - x_pos : x_pos) : x
  return ret
}
function scrub_vec (v) {
  for (var i = 0; i < v.length; v++) {
    v[i] = 0
  }
  return false
}

function Global () {
  this.SBOX = []
  this.INV_SBOX = []
  this.SUB_MIX = [[], [], [], []]
  this.INV_SUB_MIX = [[], [], [], []]
  this.init()
  this.RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36]
}

Global.prototype.init = function () {
  var d, i, sx, t, x, x2, x4, x8, xi, _i
  d = (function () {
    var _i, _results
    _results = []
    for (i = _i = 0; _i < 256; i = ++_i) {
      if (i < 128) {
        _results.push(i << 1)
      } else {
        _results.push((i << 1) ^ 0x11b)
      }
    }
    return _results
  })()
  x = 0
  xi = 0
  for (i = _i = 0; _i < 256; i = ++_i) {
    sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4)
    sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63
    this.SBOX[x] = sx
    this.INV_SBOX[sx] = x
    x2 = d[x]
    x4 = d[x2]
    x8 = d[x4]
    t = (d[sx] * 0x101) ^ (sx * 0x1010100)
    this.SUB_MIX[0][x] = (t << 24) | (t >>> 8)
    this.SUB_MIX[1][x] = (t << 16) | (t >>> 16)
    this.SUB_MIX[2][x] = (t << 8) | (t >>> 24)
    this.SUB_MIX[3][x] = t
    t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100)
    this.INV_SUB_MIX[0][sx] = (t << 24) | (t >>> 8)
    this.INV_SUB_MIX[1][sx] = (t << 16) | (t >>> 16)
    this.INV_SUB_MIX[2][sx] = (t << 8) | (t >>> 24)
    this.INV_SUB_MIX[3][sx] = t
    if (x === 0) {
      x = xi = 1
    } else {
      x = x2 ^ d[d[d[x8 ^ x2]]]
      xi ^= d[d[xi]]
    }
  }
  return true
}

var G = new Global()

AES.blockSize = 4 * 4

AES.prototype.blockSize = AES.blockSize

AES.keySize = 256 / 8

AES.prototype.keySize = AES.keySize

function bufferToArray (buf) {
  var len = buf.length / 4
  var out = new Array(len)
  var i = -1
  while (++i < len) {
    out[i] = buf.readUInt32BE(i * 4)
  }
  return out
}
function AES (key) {
  this._key = bufferToArray(key)
  this._doReset()
}

AES.prototype._doReset = function () {
  var invKsRow, keySize, keyWords, ksRow, ksRows, t
  keyWords = this._key
  keySize = keyWords.length
  this._nRounds = keySize + 6
  ksRows = (this._nRounds + 1) * 4
  this._keySchedule = []
  for (ksRow = 0; ksRow < ksRows; ksRow++) {
    this._keySchedule[ksRow] = ksRow < keySize ? keyWords[ksRow] : (t = this._keySchedule[ksRow - 1], (ksRow % keySize) === 0 ? (t = (t << 8) | (t >>> 24), t = (G.SBOX[t >>> 24] << 24) | (G.SBOX[(t >>> 16) & 0xff] << 16) | (G.SBOX[(t >>> 8) & 0xff] << 8) | G.SBOX[t & 0xff], t ^= G.RCON[(ksRow / keySize) | 0] << 24) : keySize > 6 && ksRow % keySize === 4 ? t = (G.SBOX[t >>> 24] << 24) | (G.SBOX[(t >>> 16) & 0xff] << 16) | (G.SBOX[(t >>> 8) & 0xff] << 8) | G.SBOX[t & 0xff] : void 0, this._keySchedule[ksRow - keySize] ^ t)
  }
  this._invKeySchedule = []
  for (invKsRow = 0; invKsRow < ksRows; invKsRow++) {
    ksRow = ksRows - invKsRow
    t = this._keySchedule[ksRow - (invKsRow % 4 ? 0 : 4)]
    this._invKeySchedule[invKsRow] = invKsRow < 4 || ksRow <= 4 ? t : G.INV_SUB_MIX[0][G.SBOX[t >>> 24]] ^ G.INV_SUB_MIX[1][G.SBOX[(t >>> 16) & 0xff]] ^ G.INV_SUB_MIX[2][G.SBOX[(t >>> 8) & 0xff]] ^ G.INV_SUB_MIX[3][G.SBOX[t & 0xff]]
  }
  return true
}

AES.prototype.encryptBlock = function (M) {
  M = bufferToArray(new Buffer(M))
  var out = this._doCryptBlock(M, this._keySchedule, G.SUB_MIX, G.SBOX)
  var buf = new Buffer(16)
  buf.writeUInt32BE(out[0], 0)
  buf.writeUInt32BE(out[1], 4)
  buf.writeUInt32BE(out[2], 8)
  buf.writeUInt32BE(out[3], 12)
  return buf
}

AES.prototype.decryptBlock = function (M) {
  M = bufferToArray(new Buffer(M))
  var temp = [M[3], M[1]]
  M[1] = temp[0]
  M[3] = temp[1]
  var out = this._doCryptBlock(M, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX)
  var buf = new Buffer(16)
  buf.writeUInt32BE(out[0], 0)
  buf.writeUInt32BE(out[3], 4)
  buf.writeUInt32BE(out[2], 8)
  buf.writeUInt32BE(out[1], 12)
  return buf
}

AES.prototype.scrub = function () {
  scrub_vec(this._keySchedule)
  scrub_vec(this._invKeySchedule)
  scrub_vec(this._key)
}

AES.prototype._doCryptBlock = function (M, keySchedule, SUB_MIX, SBOX) {
  var ksRow, s0, s1, s2, s3, t0, t1, t2, t3

  s0 = M[0] ^ keySchedule[0]
  s1 = M[1] ^ keySchedule[1]
  s2 = M[2] ^ keySchedule[2]
  s3 = M[3] ^ keySchedule[3]
  ksRow = 4
  for (var round = 1; round < this._nRounds; round++) {
    t0 = SUB_MIX[0][s0 >>> 24] ^ SUB_MIX[1][(s1 >>> 16) & 0xff] ^ SUB_MIX[2][(s2 >>> 8) & 0xff] ^ SUB_MIX[3][s3 & 0xff] ^ keySchedule[ksRow++]
    t1 = SUB_MIX[0][s1 >>> 24] ^ SUB_MIX[1][(s2 >>> 16) & 0xff] ^ SUB_MIX[2][(s3 >>> 8) & 0xff] ^ SUB_MIX[3][s0 & 0xff] ^ keySchedule[ksRow++]
    t2 = SUB_MIX[0][s2 >>> 24] ^ SUB_MIX[1][(s3 >>> 16) & 0xff] ^ SUB_MIX[2][(s0 >>> 8) & 0xff] ^ SUB_MIX[3][s1 & 0xff] ^ keySchedule[ksRow++]
    t3 = SUB_MIX[0][s3 >>> 24] ^ SUB_MIX[1][(s0 >>> 16) & 0xff] ^ SUB_MIX[2][(s1 >>> 8) & 0xff] ^ SUB_MIX[3][s2 & 0xff] ^ keySchedule[ksRow++]
    s0 = t0
    s1 = t1
    s2 = t2
    s3 = t3
  }
  t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++]
  t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++]
  t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++]
  t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++]
  return [
    fixup_uint32(t0),
    fixup_uint32(t1),
    fixup_uint32(t2),
    fixup_uint32(t3)
  ]
}

exports.AES = AES

}).call(this,require("buffer").Buffer)

},{"buffer":152}],326:[function(require,module,exports){
(function (Buffer){
var aes = require('./aes')
var Transform = require('cipher-base')
var inherits = require('inherits')
var GHASH = require('./ghash')
var xor = require('buffer-xor')
inherits(StreamCipher, Transform)
module.exports = StreamCipher

function StreamCipher (mode, key, iv, decrypt) {
  if (!(this instanceof StreamCipher)) {
    return new StreamCipher(mode, key, iv)
  }
  Transform.call(this)
  this._finID = Buffer.concat([iv, new Buffer([0, 0, 0, 1])])
  iv = Buffer.concat([iv, new Buffer([0, 0, 0, 2])])
  this._cipher = new aes.AES(key)
  this._prev = new Buffer(iv.length)
  this._cache = new Buffer('')
  this._secCache = new Buffer('')
  this._decrypt = decrypt
  this._alen = 0
  this._len = 0
  iv.copy(this._prev)
  this._mode = mode
  var h = new Buffer(4)
  h.fill(0)
  this._ghash = new GHASH(this._cipher.encryptBlock(h))
  this._authTag = null
  this._called = false
}
StreamCipher.prototype._update = function (chunk) {
  if (!this._called && this._alen) {
    var rump = 16 - (this._alen % 16)
    if (rump < 16) {
      rump = new Buffer(rump)
      rump.fill(0)
      this._ghash.update(rump)
    }
  }
  this._called = true
  var out = this._mode.encrypt(this, chunk)
  if (this._decrypt) {
    this._ghash.update(chunk)
  } else {
    this._ghash.update(out)
  }
  this._len += chunk.length
  return out
}
StreamCipher.prototype._final = function () {
  if (this._decrypt && !this._authTag) {
    throw new Error('Unsupported state or unable to authenticate data')
  }
  var tag = xor(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID))
  if (this._decrypt) {
    if (xorTest(tag, this._authTag)) {
      throw new Error('Unsupported state or unable to authenticate data')
    }
  } else {
    this._authTag = tag
  }
  this._cipher.scrub()
}
StreamCipher.prototype.getAuthTag = function getAuthTag () {
  if (!this._decrypt && Buffer.isBuffer(this._authTag)) {
    return this._authTag
  } else {
    throw new Error('Attempting to get auth tag in unsupported state')
  }
}
StreamCipher.prototype.setAuthTag = function setAuthTag (tag) {
  if (this._decrypt) {
    this._authTag = tag
  } else {
    throw new Error('Attempting to set auth tag in unsupported state')
  }
}
StreamCipher.prototype.setAAD = function setAAD (buf) {
  if (!this._called) {
    this._ghash.update(buf)
    this._alen += buf.length
  } else {
    throw new Error('Attempting to set AAD in unsupported state')
  }
}
function xorTest (a, b) {
  var out = 0
  if (a.length !== b.length) {
    out++
  }
  var len = Math.min(a.length, b.length)
  var i = -1
  while (++i < len) {
    out += (a[i] ^ b[i])
  }
  return out
}

}).call(this,require("buffer").Buffer)

},{"./aes":325,"./ghash":330,"buffer":152,"buffer-xor":339,"cipher-base":340,"inherits":349}],327:[function(require,module,exports){
arguments[4][160][0].apply(exports,arguments)
},{"./decrypter":328,"./encrypter":329,"./modes":331,"dup":160}],328:[function(require,module,exports){
(function (Buffer){
var aes = require('./aes')
var Transform = require('cipher-base')
var inherits = require('inherits')
var modes = require('./modes')
var StreamCipher = require('./streamCipher')
var AuthCipher = require('./authCipher')
var ebtk = require('evp_bytestokey')

inherits(Decipher, Transform)
function Decipher (mode, key, iv) {
  if (!(this instanceof Decipher)) {
    return new Decipher(mode, key, iv)
  }
  Transform.call(this)
  this._cache = new Splitter()
  this._last = void 0
  this._cipher = new aes.AES(key)
  this._prev = new Buffer(iv.length)
  iv.copy(this._prev)
  this._mode = mode
  this._autopadding = true
}
Decipher.prototype._update = function (data) {
  this._cache.add(data)
  var chunk
  var thing
  var out = []
  while ((chunk = this._cache.get(this._autopadding))) {
    thing = this._mode.decrypt(this, chunk)
    out.push(thing)
  }
  return Buffer.concat(out)
}
Decipher.prototype._final = function () {
  var chunk = this._cache.flush()
  if (this._autopadding) {
    return unpad(this._mode.decrypt(this, chunk))
  } else if (chunk) {
    throw new Error('data not multiple of block length')
  }
}
Decipher.prototype.setAutoPadding = function (setTo) {
  this._autopadding = !!setTo
}
function Splitter () {
  if (!(this instanceof Splitter)) {
    return new Splitter()
  }
  this.cache = new Buffer('')
}
Splitter.prototype.add = function (data) {
  this.cache = Buffer.concat([this.cache, data])
}

Splitter.prototype.get = function (autoPadding) {
  var out
  if (autoPadding) {
    if (this.cache.length > 16) {
      out = this.cache.slice(0, 16)
      this.cache = this.cache.slice(16)
      return out
    }
  } else {
    if (this.cache.length >= 16) {
      out = this.cache.slice(0, 16)
      this.cache = this.cache.slice(16)
      return out
    }
  }
  return null
}
Splitter.prototype.flush = function () {
  if (this.cache.length) {
    return this.cache
  }
}
function unpad (last) {
  var padded = last[15]
  var i = -1
  while (++i < padded) {
    if (last[(i + (16 - padded))] !== padded) {
      throw new Error('unable to decrypt data')
    }
  }
  if (padded === 16) {
    return
  }
  return last.slice(0, 16 - padded)
}

var modelist = {
  ECB: require('./modes/ecb'),
  CBC: require('./modes/cbc'),
  CFB: require('./modes/cfb'),
  CFB8: require('./modes/cfb8'),
  CFB1: require('./modes/cfb1'),
  OFB: require('./modes/ofb'),
  CTR: require('./modes/ctr'),
  GCM: require('./modes/ctr')
}

function createDecipheriv (suite, password, iv) {
  var config = modes[suite.toLowerCase()]
  if (!config) {
    throw new TypeError('invalid suite type')
  }
  if (typeof iv === 'string') {
    iv = new Buffer(iv)
  }
  if (typeof password === 'string') {
    password = new Buffer(password)
  }
  if (password.length !== config.key / 8) {
    throw new TypeError('invalid key length ' + password.length)
  }
  if (iv.length !== config.iv) {
    throw new TypeError('invalid iv length ' + iv.length)
  }
  if (config.type === 'stream') {
    return new StreamCipher(modelist[config.mode], password, iv, true)
  } else if (config.type === 'auth') {
    return new AuthCipher(modelist[config.mode], password, iv, true)
  }
  return new Decipher(modelist[config.mode], password, iv)
}

function createDecipher (suite, password) {
  var config = modes[suite.toLowerCase()]
  if (!config) {
    throw new TypeError('invalid suite type')
  }
  var keys = ebtk(password, false, config.key, config.iv)
  return createDecipheriv(suite, keys.key, keys.iv)
}
exports.createDecipher = createDecipher
exports.createDecipheriv = createDecipheriv

}).call(this,require("buffer").Buffer)

},{"./aes":325,"./authCipher":326,"./modes":331,"./modes/cbc":332,"./modes/cfb":333,"./modes/cfb1":334,"./modes/cfb8":335,"./modes/ctr":336,"./modes/ecb":337,"./modes/ofb":338,"./streamCipher":341,"buffer":152,"cipher-base":340,"evp_bytestokey":342,"inherits":349}],329:[function(require,module,exports){
(function (Buffer){
var aes = require('./aes')
var Transform = require('cipher-base')
var inherits = require('inherits')
var modes = require('./modes')
var ebtk = require('evp_bytestokey')
var StreamCipher = require('./streamCipher')
var AuthCipher = require('./authCipher')
inherits(Cipher, Transform)
function Cipher (mode, key, iv) {
  if (!(this instanceof Cipher)) {
    return new Cipher(mode, key, iv)
  }
  Transform.call(this)
  this._cache = new Splitter()
  this._cipher = new aes.AES(key)
  this._prev = new Buffer(iv.length)
  iv.copy(this._prev)
  this._mode = mode
  this._autopadding = true
}
Cipher.prototype._update = function (data) {
  this._cache.add(data)
  var chunk
  var thing
  var out = []
  while ((chunk = this._cache.get())) {
    thing = this._mode.encrypt(this, chunk)
    out.push(thing)
  }
  return Buffer.concat(out)
}
Cipher.prototype._final = function () {
  var chunk = this._cache.flush()
  if (this._autopadding) {
    chunk = this._mode.encrypt(this, chunk)
    this._cipher.scrub()
    return chunk
  } else if (chunk.toString('hex') !== '10101010101010101010101010101010') {
    this._cipher.scrub()
    throw new Error('data not multiple of block length')
  }
}
Cipher.prototype.setAutoPadding = function (setTo) {
  this._autopadding = !!setTo
}

function Splitter () {
  if (!(this instanceof Splitter)) {
    return new Splitter()
  }
  this.cache = new Buffer('')
}
Splitter.prototype.add = function (data) {
  this.cache = Buffer.concat([this.cache, data])
}

Splitter.prototype.get = function () {
  if (this.cache.length > 15) {
    var out = this.cache.slice(0, 16)
    this.cache = this.cache.slice(16)
    return out
  }
  return null
}
Splitter.prototype.flush = function () {
  var len = 16 - this.cache.length
  var padBuff = new Buffer(len)

  var i = -1
  while (++i < len) {
    padBuff.writeUInt8(len, i)
  }
  var out = Buffer.concat([this.cache, padBuff])
  return out
}
var modelist = {
  ECB: require('./modes/ecb'),
  CBC: require('./modes/cbc'),
  CFB: require('./modes/cfb'),
  CFB8: require('./modes/cfb8'),
  CFB1: require('./modes/cfb1'),
  OFB: require('./modes/ofb'),
  CTR: require('./modes/ctr'),
  GCM: require('./modes/ctr')
}

function createCipheriv (suite, password, iv) {
  var config = modes[suite.toLowerCase()]
  if (!config) {
    throw new TypeError('invalid suite type')
  }
  if (typeof iv === 'string') {
    iv = new Buffer(iv)
  }
  if (typeof password === 'string') {
    password = new Buffer(password)
  }
  if (password.length !== config.key / 8) {
    throw new TypeError('invalid key length ' + password.length)
  }
  if (iv.length !== config.iv) {
    throw new TypeError('invalid iv length ' + iv.length)
  }
  if (config.type === 'stream') {
    return new StreamCipher(modelist[config.mode], password, iv)
  } else if (config.type === 'auth') {
    return new AuthCipher(modelist[config.mode], password, iv)
  }
  return new Cipher(modelist[config.mode], password, iv)
}
function createCipher (suite, password) {
  var config = modes[suite.toLowerCase()]
  if (!config) {
    throw new TypeError('invalid suite type')
  }
  var keys = ebtk(password, false, config.key, config.iv)
  return createCipheriv(suite, keys.key, keys.iv)
}

exports.createCipheriv = createCipheriv
exports.createCipher = createCipher

}).call(this,require("buffer").Buffer)

},{"./aes":325,"./authCipher":326,"./modes":331,"./modes/cbc":332,"./modes/cfb":333,"./modes/cfb1":334,"./modes/cfb8":335,"./modes/ctr":336,"./modes/ecb":337,"./modes/ofb":338,"./streamCipher":341,"buffer":152,"cipher-base":340,"evp_bytestokey":342,"inherits":349}],330:[function(require,module,exports){
(function (Buffer){
var zeros = new Buffer(16)
zeros.fill(0)
module.exports = GHASH
function GHASH (key) {
  this.h = key
  this.state = new Buffer(16)
  this.state.fill(0)
  this.cache = new Buffer('')
}
// from http://bitwiseshiftleft.github.io/sjcl/doc/symbols/src/core_gcm.js.html
// by Juho Vh-Herttua
GHASH.prototype.ghash = function (block) {
  var i = -1
  while (++i < block.length) {
    this.state[i] ^= block[i]
  }
  this._multiply()
}

GHASH.prototype._multiply = function () {
  var Vi = toArray(this.h)
  var Zi = [0, 0, 0, 0]
  var j, xi, lsb_Vi
  var i = -1
  while (++i < 128) {
    xi = (this.state[~~(i / 8)] & (1 << (7 - i % 8))) !== 0
    if (xi) {
      // Z_i+1 = Z_i ^ V_i
      Zi = xor(Zi, Vi)
    }

    // Store the value of LSB(V_i)
    lsb_Vi = (Vi[3] & 1) !== 0

    // V_i+1 = V_i >> 1
    for (j = 3; j > 0; j--) {
      Vi[j] = (Vi[j] >>> 1) | ((Vi[j - 1] & 1) << 31)
    }
    Vi[0] = Vi[0] >>> 1

    // If LSB(V_i) is 1, V_i+1 = (V_i >> 1) ^ R
    if (lsb_Vi) {
      Vi[0] = Vi[0] ^ (0xe1 << 24)
    }
  }
  this.state = fromArray(Zi)
}
GHASH.prototype.update = function (buf) {
  this.cache = Buffer.concat([this.cache, buf])
  var chunk
  while (this.cache.length >= 16) {
    chunk = this.cache.slice(0, 16)
    this.cache = this.cache.slice(16)
    this.ghash(chunk)
  }
}
GHASH.prototype.final = function (abl, bl) {
  if (this.cache.length) {
    this.ghash(Buffer.concat([this.cache, zeros], 16))
  }
  this.ghash(fromArray([
    0, abl,
    0, bl
  ]))
  return this.state
}

function toArray (buf) {
  return [
    buf.readUInt32BE(0),
    buf.readUInt32BE(4),
    buf.readUInt32BE(8),
    buf.readUInt32BE(12)
  ]
}
function fromArray (out) {
  out = out.map(fixup_uint32)
  var buf = new Buffer(16)
  buf.writeUInt32BE(out[0], 0)
  buf.writeUInt32BE(out[1], 4)
  buf.writeUInt32BE(out[2], 8)
  buf.writeUInt32BE(out[3], 12)
  return buf
}
var uint_max = Math.pow(2, 32)
function fixup_uint32 (x) {
  var ret, x_pos
  ret = x > uint_max || x < 0 ? (x_pos = Math.abs(x) % uint_max, x < 0 ? uint_max - x_pos : x_pos) : x
  return ret
}
function xor (a, b) {
  return [
    a[0] ^ b[0],
    a[1] ^ b[1],
    a[2] ^ b[2],
    a[3] ^ b[3]
  ]
}

}).call(this,require("buffer").Buffer)

},{"buffer":152}],331:[function(require,module,exports){
arguments[4][164][0].apply(exports,arguments)
},{"dup":164}],332:[function(require,module,exports){
arguments[4][165][0].apply(exports,arguments)
},{"buffer-xor":339,"dup":165}],333:[function(require,module,exports){
(function (Buffer){
var xor = require('buffer-xor')

exports.encrypt = function (self, data, decrypt) {
  var out = new Buffer('')
  var len

  while (data.length) {
    if (self._cache.length === 0) {
      self._cache = self._cipher.encryptBlock(self._prev)
      self._prev = new Buffer('')
    }

    if (self._cache.length <= data.length) {
      len = self._cache.length
      out = Buffer.concat([out, encryptStart(self, data.slice(0, len), decrypt)])
      data = data.slice(len)
    } else {
      out = Buffer.concat([out, encryptStart(self, data, decrypt)])
      break
    }
  }

  return out
}
function encryptStart (self, data, decrypt) {
  var len = data.length
  var out = xor(data, self._cache)
  self._cache = self._cache.slice(len)
  self._prev = Buffer.concat([self._prev, decrypt ? data : out])
  return out
}

}).call(this,require("buffer").Buffer)

},{"buffer":152,"buffer-xor":339}],334:[function(require,module,exports){
(function (Buffer){
function encryptByte (self, byteParam, decrypt) {
  var pad
  var i = -1
  var len = 8
  var out = 0
  var bit, value
  while (++i < len) {
    pad = self._cipher.encryptBlock(self._prev)
    bit = (byteParam & (1 << (7 - i))) ? 0x80 : 0
    value = pad[0] ^ bit
    out += ((value & 0x80) >> (i % 8))
    self._prev = shiftIn(self._prev, decrypt ? bit : value)
  }
  return out
}
exports.encrypt = function (self, chunk, decrypt) {
  var len = chunk.length
  var out = new Buffer(len)
  var i = -1
  while (++i < len) {
    out[i] = encryptByte(self, chunk[i], decrypt)
  }
  return out
}
function shiftIn (buffer, value) {
  var len = buffer.length
  var i = -1
  var out = new Buffer(buffer.length)
  buffer = Buffer.concat([buffer, new Buffer([value])])
  while (++i < len) {
    out[i] = buffer[i] << 1 | buffer[i + 1] >> (7)
  }
  return out
}

}).call(this,require("buffer").Buffer)

},{"buffer":152}],335:[function(require,module,exports){
(function (Buffer){
function encryptByte (self, byteParam, decrypt) {
  var pad = self._cipher.encryptBlock(self._prev)
  var out = pad[0] ^ byteParam
  self._prev = Buffer.concat([self._prev.slice(1), new Buffer([decrypt ? byteParam : out])])
  return out
}
exports.encrypt = function (self, chunk, decrypt) {
  var len = chunk.length
  var out = new Buffer(len)
  var i = -1
  while (++i < len) {
    out[i] = encryptByte(self, chunk[i], decrypt)
  }
  return out
}

}).call(this,require("buffer").Buffer)

},{"buffer":152}],336:[function(require,module,exports){
(function (Buffer){
var xor = require('buffer-xor')

function incr32 (iv) {
  var len = iv.length
  var item
  while (len--) {
    item = iv.readUInt8(len)
    if (item === 255) {
      iv.writeUInt8(0, len)
    } else {
      item++
      iv.writeUInt8(item, len)
      break
    }
  }
}

function getBlock (self) {
  var out = self._cipher.encryptBlock(self._prev)
  incr32(self._prev)
  return out
}

exports.encrypt = function (self, chunk) {
  while (self._cache.length < chunk.length) {
    self._cache = Buffer.concat([self._cache, getBlock(self)])
  }
  var pad = self._cache.slice(0, chunk.length)
  self._cache = self._cache.slice(chunk.length)
  return xor(chunk, pad)
}

}).call(this,require("buffer").Buffer)

},{"buffer":152,"buffer-xor":339}],337:[function(require,module,exports){
arguments[4][170][0].apply(exports,arguments)
},{"dup":170}],338:[function(require,module,exports){
(function (Buffer){
var xor = require('buffer-xor')

function getBlock (self) {
  self._prev = self._cipher.encryptBlock(self._prev)
  return self._prev
}

exports.encrypt = function (self, chunk) {
  while (self._cache.length < chunk.length) {
    self._cache = Buffer.concat([self._cache, getBlock(self)])
  }

  var pad = self._cache.slice(0, chunk.length)
  self._cache = self._cache.slice(chunk.length)
  return xor(chunk, pad)
}

}).call(this,require("buffer").Buffer)

},{"buffer":152,"buffer-xor":339}],339:[function(require,module,exports){
(function (Buffer){
module.exports = function xor (a, b) {
  var length = Math.min(a.length, b.length)
  var buffer = new Buffer(length)

  for (var i = 0; i < length; ++i) {
    buffer[i] = a[i] ^ b[i]
  }

  return buffer
}

}).call(this,require("buffer").Buffer)

},{"buffer":152}],340:[function(require,module,exports){
(function (Buffer){
var Transform = require('stream').Transform
var inherits = require('inherits')
var StringDecoder = require('string_decoder').StringDecoder
module.exports = CipherBase
inherits(CipherBase, Transform)
function CipherBase (hashMode) {
  Transform.call(this)
  this.hashMode = typeof hashMode === 'string'
  if (this.hashMode) {
    this[hashMode] = this._finalOrDigest
  } else {
    this.final = this._finalOrDigest
  }
  this._decoder = null
  this._encoding = null
}
CipherBase.prototype.update = function (data, inputEnc, outputEnc) {
  if (typeof data === 'string') {
    data = new Buffer(data, inputEnc)
  }
  var outData = this._update(data)
  if (this.hashMode) {
    return this
  }
  if (outputEnc) {
    outData = this._toString(outData, outputEnc)
  }
  return outData
}

CipherBase.prototype.setAutoPadding = function () {}

CipherBase.prototype.getAuthTag = function () {
  throw new Error('trying to get auth tag in unsupported state')
}

CipherBase.prototype.setAuthTag = function () {
  throw new Error('trying to set auth tag in unsupported state')
}

CipherBase.prototype.setAAD = function () {
  throw new Error('trying to set aad in unsupported state')
}

CipherBase.prototype._transform = function (data, _, next) {
  var err
  try {
    if (this.hashMode) {
      this._update(data)
    } else {
      this.push(this._update(data))
    }
  } catch (e) {
    err = e
  } finally {
    next(err)
  }
}
CipherBase.prototype._flush = function (done) {
  var err
  try {
    this.push(this._final())
  } catch (e) {
    err = e
  } finally {
    done(err)
  }
}
CipherBase.prototype._finalOrDigest = function (outputEnc) {
  var outData = this._final() || new Buffer('')
  if (outputEnc) {
    outData = this._toString(outData, outputEnc, true)
  }
  return outData
}

CipherBase.prototype._toString = function (value, enc, final) {
  if (!this._decoder) {
    this._decoder = new StringDecoder(enc)
    this._encoding = enc
  }
  if (this._encoding !== enc) {
    throw new Error('can\'t switch encodings')
  }
  var out = this._decoder.write(value)
  if (final) {
    out += this._decoder.end()
  }
  return out
}

}).call(this,require("buffer").Buffer)

},{"buffer":152,"inherits":349,"stream":366,"string_decoder":367}],341:[function(require,module,exports){
(function (Buffer){
var aes = require('./aes')
var Transform = require('cipher-base')
var inherits = require('inherits')

inherits(StreamCipher, Transform)
module.exports = StreamCipher
function StreamCipher (mode, key, iv, decrypt) {
  if (!(this instanceof StreamCipher)) {
    return new StreamCipher(mode, key, iv)
  }
  Transform.call(this)
  this._cipher = new aes.AES(key)
  this._prev = new Buffer(iv.length)
  this._cache = new Buffer('')
  this._secCache = new Buffer('')
  this._decrypt = decrypt
  iv.copy(this._prev)
  this._mode = mode
}
StreamCipher.prototype._update = function (chunk) {
  return this._mode.encrypt(this, chunk, this._decrypt)
}
StreamCipher.prototype._final = function () {
  this._cipher.scrub()
}

}).call(this,require("buffer").Buffer)

},{"./aes":325,"buffer":152,"cipher-base":340,"inherits":349}],342:[function(require,module,exports){
(function (Buffer){
var md5 = require('create-hash/md5')
module.exports = EVP_BytesToKey
function EVP_BytesToKey (password, salt, keyLen, ivLen) {
  if (!Buffer.isBuffer(password)) {
    password = new Buffer(password, 'binary')
  }
  if (salt && !Buffer.isBuffer(salt)) {
    salt = new Buffer(salt, 'binary')
  }
  keyLen = keyLen / 8
  ivLen = ivLen || 0
  var ki = 0
  var ii = 0
  var key = new Buffer(keyLen)
  var iv = new Buffer(ivLen)
  var addmd = 0
  var md_buf
  var i
  var bufs = []
  while (true) {
    if (addmd++ > 0) {
      bufs.push(md_buf)
    }
    bufs.push(password)
    if (salt) {
      bufs.push(salt)
    }
    md_buf = md5(Buffer.concat(bufs))
    bufs = []
    i = 0
    if (keyLen > 0) {
      while (true) {
        if (keyLen === 0) {
          break
        }
        if (i === md_buf.length) {
          break
        }
        key[ki++] = md_buf[i]
        keyLen--
        i++
      }
    }
    if (ivLen > 0 && i !== md_buf.length) {
      while (true) {
        if (ivLen === 0) {
          break
        }
        if (i === md_buf.length) {
          break
        }
        iv[ii++] = md_buf[i]
        ivLen--
        i++
      }
    }
    if (keyLen === 0 && ivLen === 0) {
      break
    }
  }
  for (i = 0; i < md_buf.length; i++) {
    md_buf[i] = 0
  }
  return {
    key: key,
    iv: iv
  }
}

}).call(this,require("buffer").Buffer)

},{"buffer":152,"create-hash/md5":282}],343:[function(require,module,exports){
(function (Buffer){
var parseKeys = require('parse-asn1');
var mgf = require('./mgf');
var xor = require('./xor');
var bn = require('bn.js');
var crt = require('browserify-rsa');
var createHash = require('create-hash');
var withPublic = require('./withPublic');
module.exports = function privateDecrypt(private_key, enc, reverse) {
  var padding;
  if (private_key.padding) {
    padding = private_key.padding;
  } else if (reverse) {
    padding = 1;
  } else {
    padding = 4;
  }
  
  var key = parseKeys(private_key);
  var k = key.modulus.byteLength();
  if (enc.length > k || new bn(enc).cmp(key.modulus) >= 0) {
    throw new Error('decryption error');
  }
  var msg;
  if (reverse) {
    msg = withPublic(new bn(enc), key);
  } else {
    msg = crt(enc, key);
  }
  var zBuffer = new Buffer(k - msg.length);
  zBuffer.fill(0);
  msg = Buffer.concat([zBuffer, msg], k);
  if (padding === 4) {
    return oaep(key, msg);
  } else if (padding === 1) {
    return pkcs1(key, msg, reverse);
  } else if (padding === 3) {
    return msg;
  } else {
    throw new Error('unknown padding');
  }
};

function oaep(key, msg){
  var n = key.modulus;
  var k = key.modulus.byteLength();
  var mLen = msg.length;
  var iHash = createHash('sha1').update(new Buffer('')).digest();
  var hLen = iHash.length;
  var hLen2 = 2 * hLen;
  if (msg[0] !== 0) {
    throw new Error('decryption error');
  }
  var maskedSeed = msg.slice(1, hLen + 1);
  var maskedDb =  msg.slice(hLen + 1);
  var seed = xor(maskedSeed, mgf(maskedDb, hLen));
  var db = xor(maskedDb, mgf(seed, k - hLen - 1));
  if (compare(iHash, db.slice(0, hLen))) {
    throw new Error('decryption error');
  }
  var i = hLen;
  while (db[i] === 0) {
    i++;
  }
  if (db[i++] !== 1) {
    throw new Error('decryption error');
  }
  return db.slice(i);
}

function pkcs1(key, msg, reverse){
  var p1 = msg.slice(0, 2);
  var i = 2;
  var status = 0;
  while (msg[i++] !== 0) {
    if (i >= msg.length) {
      status++;
      break;
    }
  }
  var ps = msg.slice(2, i - 1);
  var p2 = msg.slice(i - 1, i);

  if ((p1.toString('hex') !== '0002' && !reverse) || (p1.toString('hex') !== '0001' && reverse)){
    status++;
  }
  if (ps.length < 8) {
    status++;
  }
  if (status) {
    throw new Error('decryption error');
  }
  return  msg.slice(i);
}
function compare(a, b){
  a = new Buffer(a);
  b = new Buffer(b);
  var dif = 0;
  var len = a.length;
  if (a.length !== b.length) {
    dif++;
    len = Math.min(a.length, b.length);
  }
  var i = -1;
  while (++i < len) {
    dif += (a[i] ^ b[i]);
  }
  return dif;
}
}).call(this,require("buffer").Buffer)

},{"./mgf":303,"./withPublic":345,"./xor":346,"bn.js":304,"browserify-rsa":305,"buffer":152,"create-hash":280,"parse-asn1":309}],344:[function(require,module,exports){
(function (Buffer){
var parseKeys = require('parse-asn1');
var randomBytes = require('randombytes');
var createHash = require('create-hash');
var mgf = require('./mgf');
var xor = require('./xor');
var bn = require('bn.js');
var withPublic = require('./withPublic');
var crt = require('browserify-rsa');

var constants = {
  RSA_PKCS1_OAEP_PADDING: 4,
  RSA_PKCS1_PADDIN: 1,
  RSA_NO_PADDING: 3
};

module.exports = function publicEncrypt(public_key, msg, reverse) {
  var padding;
  if (public_key.padding) {
    padding = public_key.padding;
  } else if (reverse) {
    padding = 1;
  } else {
    padding = 4;
  }
  var key = parseKeys(public_key);
  var paddedMsg;
  if (padding === 4) {
    paddedMsg = oaep(key, msg);
  } else if (padding === 1) {
    paddedMsg = pkcs1(key, msg, reverse);
  } else if (padding === 3) {
    paddedMsg = new bn(msg);
    if (paddedMsg.cmp(key.modulus) >= 0) {
      throw new Error('data too long for modulus');
    }
  } else {
    throw new Error('unknown padding');
  }
  if (reverse) {
    return crt(paddedMsg, key);
  } else {
    return withPublic(paddedMsg, key);
  }
};

function oaep(key, msg){
  var k = key.modulus.byteLength();
  var mLen = msg.length;
  var iHash = createHash('sha1').update(new Buffer('')).digest();
  var hLen = iHash.length;
  var hLen2 = 2 * hLen;
  if (mLen > k - hLen2 - 2) {
    throw new Error('message too long');
  }
  var ps = new Buffer(k - mLen - hLen2 - 2);
  ps.fill(0);
  var dblen = k - hLen - 1;
  var seed = randomBytes(hLen);
  var maskedDb = xor(Buffer.concat([iHash, ps, new Buffer([1]), msg], dblen), mgf(seed, dblen));
  var maskedSeed = xor(seed, mgf(maskedDb, hLen));
  return new bn(Buffer.concat([new Buffer([0]), maskedSeed, maskedDb], k));
}
function pkcs1(key, msg, reverse){
  var mLen = msg.length;
  var k = key.modulus.byteLength();
  if (mLen > k - 11) {
    throw new Error('message too long');
  }
  var ps;
  if (reverse) {
    ps = new Buffer(k - mLen - 3);
    ps.fill(0xff);
  } else {
    ps = nonZero(k - mLen - 3);
  }
  return new bn(Buffer.concat([new Buffer([0, reverse?1:2]), ps, new Buffer([0]), msg], k));
}
function nonZero(len, crypto) {
  var out = new Buffer(len);
  var i = 0;
  var cache = randomBytes(len*2);
  var cur = 0;
  var num;
  while (i < len) {
    if (cur === cache.length) {
      cache = randomBytes(len*2);
      cur = 0;
    }
    num = cache[cur++];
    if (num) {
      out[i++] = num;
    }
  }
  return out;
}
}).call(this,require("buffer").Buffer)

},{"./mgf":303,"./withPublic":345,"./xor":346,"bn.js":304,"browserify-rsa":305,"buffer":152,"create-hash":280,"parse-asn1":309,"randombytes":347}],345:[function(require,module,exports){
(function (Buffer){
var bn = require('bn.js');
function withPublic(paddedMsg, key) {
  return new Buffer(paddedMsg
    .toRed(bn.mont(key.modulus))
    .redPow(new bn(key.publicExponent))
    .fromRed()
    .toArray());
}

module.exports = withPublic;
}).call(this,require("buffer").Buffer)

},{"bn.js":304,"buffer":152}],346:[function(require,module,exports){
module.exports = function xor(a, b) {
  var len = a.length;
  var i = -1;
  while (++i < len) {
    a[i] ^= b[i];
  }
  return a
};
},{}],347:[function(require,module,exports){
(function (process,global,Buffer){
'use strict';

var crypto = global.crypto || global.msCrypto
if(crypto && crypto.getRandomValues) {
  module.exports = randomBytes;
} else {
  module.exports = oldBrowser;
}
function randomBytes(size, cb) {
  var bytes = new Buffer(size); //in browserify, this is an extended Uint8Array
    /* This will not work in older browsers.
     * See https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues
     */

  crypto.getRandomValues(bytes);
  if (typeof cb === 'function') {
    return process.nextTick(function () {
      cb(null, bytes);
    });
  }
  return bytes;
}
function oldBrowser() {
  throw new Error(
      'secure random number generation not supported by this browser\n'+
      'use chrome, FireFox or Internet Explorer 11'
    )
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)

},{"_process":352,"buffer":152}],348:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],349:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],350:[function(require,module,exports){
/**
 * Determine if an object is Buffer
 *
 * Author:   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * License:  MIT
 *
 * `npm install is-buffer`
 */

module.exports = function (obj) {
  return !!(obj != null &&
    (obj._isBuffer || // For Safari 5-7 (missing Object.prototype.constructor)
      (obj.constructor &&
      typeof obj.constructor.isBuffer === 'function' &&
      obj.constructor.isBuffer(obj))
    ))
}

},{}],351:[function(require,module,exports){
module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

},{}],352:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],353:[function(require,module,exports){
module.exports = require("./lib/_stream_duplex.js")

},{"./lib/_stream_duplex.js":354}],354:[function(require,module,exports){
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) keys.push(key);
  return keys;
}
/*</replacement>*/


module.exports = Duplex;

/*<replacement>*/
var processNextTick = require('process-nextick-args');
/*</replacement>*/



/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

var keys = objectKeys(Writable.prototype);
for (var v = 0; v < keys.length; v++) {
  var method = keys[v];
  if (!Duplex.prototype[method])
    Duplex.prototype[method] = Writable.prototype[method];
}

function Duplex(options) {
  if (!(this instanceof Duplex))
    return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false)
    this.readable = false;

  if (options && options.writable === false)
    this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false)
    this.allowHalfOpen = false;

  this.once('end', onend);
}

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended)
    return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  processNextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

function forEach (xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

},{"./_stream_readable":356,"./_stream_writable":358,"core-util-is":359,"inherits":349,"process-nextick-args":360}],355:[function(require,module,exports){
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough))
    return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function(chunk, encoding, cb) {
  cb(null, chunk);
};

},{"./_stream_transform":357,"core-util-is":359,"inherits":349}],356:[function(require,module,exports){
(function (process){
'use strict';

module.exports = Readable;

/*<replacement>*/
var processNextTick = require('process-nextick-args');
/*</replacement>*/


/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/


/*<replacement>*/
var Buffer = require('buffer').Buffer;
/*</replacement>*/

Readable.ReadableState = ReadableState;

var EE = require('events');

/*<replacement>*/
var EElistenerCount = function(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/



/*<replacement>*/
var Stream;
(function (){try{
  Stream = require('st' + 'ream');
}catch(_){}finally{
  if (!Stream)
    Stream = require('events').EventEmitter;
}}())
/*</replacement>*/

var Buffer = require('buffer').Buffer;

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/



/*<replacement>*/
var debugUtil = require('util');
var debug;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var StringDecoder;

util.inherits(Readable, Stream);

var Duplex;
function ReadableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex)
    this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.buffer = [];
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // when piping, we only care about 'readable' events that happen
  // after read()ing all the bytes and not getting any pushback.
  this.ranOut = false;

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder)
      StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

var Duplex;
function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  if (!(this instanceof Readable))
    return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options && typeof options.read === 'function')
    this._read = options.read;

  Stream.call(this);
}

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function(chunk, encoding) {
  var state = this._readableState;

  if (!state.objectMode && typeof chunk === 'string') {
    encoding = encoding || state.defaultEncoding;
    if (encoding !== state.encoding) {
      chunk = new Buffer(chunk, encoding);
      encoding = '';
    }
  }

  return readableAddChunk(this, state, chunk, encoding, false);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function(chunk) {
  var state = this._readableState;
  return readableAddChunk(this, state, chunk, '', true);
};

Readable.prototype.isPaused = function() {
  return this._readableState.flowing === false;
};

function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er) {
    stream.emit('error', er);
  } else if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e = new Error('stream.push() after EOF');
      stream.emit('error', e);
    } else if (state.endEmitted && addToFront) {
      var e = new Error('stream.unshift() after end event');
      stream.emit('error', e);
    } else {
      if (state.decoder && !addToFront && !encoding)
        chunk = state.decoder.write(chunk);

      if (!addToFront)
        state.reading = false;

      // if we want the data now, just emit it.
      if (state.flowing && state.length === 0 && !state.sync) {
        stream.emit('data', chunk);
        stream.read(0);
      } else {
        // update the buffer info.
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);

        if (state.needReadable)
          emitReadable(stream);
      }

      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }

  return needMoreData(state);
}


// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended &&
         (state.needReadable ||
          state.length < state.highWaterMark ||
          state.length === 0);
}

// backwards compatibility.
Readable.prototype.setEncoding = function(enc) {
  if (!StringDecoder)
    StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

function howMuchToRead(n, state) {
  if (state.length === 0 && state.ended)
    return 0;

  if (state.objectMode)
    return n === 0 ? 0 : 1;

  if (n === null || isNaN(n)) {
    // only flow one buffer at a time
    if (state.flowing && state.buffer.length)
      return state.buffer[0].length;
    else
      return state.length;
  }

  if (n <= 0)
    return 0;

  // If we're asking for more than the target buffer level,
  // then raise the water mark.  Bump up to the next highest
  // power of 2, to prevent increasing it excessively in tiny
  // amounts.
  if (n > state.highWaterMark)
    state.highWaterMark = computeNewHighWaterMark(n);

  // don't have that much.  return null, unless we've ended.
  if (n > state.length) {
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    } else {
      return state.length;
    }
  }

  return n;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function(n) {
  debug('read', n);
  var state = this._readableState;
  var nOrig = n;

  if (typeof n !== 'number' || n > 0)
    state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 &&
      state.needReadable &&
      (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended)
      endReadable(this);
    else
      emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0)
      endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  }

  if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0)
      state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
  }

  // If _read pushed data synchronously, then `reading` will be false,
  // and we need to re-evaluate how much data we can return to the user.
  if (doRead && !state.reading)
    n = howMuchToRead(nOrig, state);

  var ret;
  if (n > 0)
    ret = fromList(n, state);
  else
    ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  }

  state.length -= n;

  // If we have nothing in the buffer, then we want to know
  // as soon as we *do* get something into the buffer.
  if (state.length === 0 && !state.ended)
    state.needReadable = true;

  // If we tried to read() past the EOF, then emit end on the next tick.
  if (nOrig !== n && state.ended && state.length === 0)
    endReadable(this);

  if (ret !== null)
    this.emit('data', ret);

  return ret;
};

function chunkInvalid(state, chunk) {
  var er = null;
  if (!(Buffer.isBuffer(chunk)) &&
      typeof chunk !== 'string' &&
      chunk !== null &&
      chunk !== undefined &&
      !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}


function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync)
      processNextTick(emitReadable_, stream);
    else
      emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}


// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    processNextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended &&
         state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;
    else
      len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function(n) {
  this.emit('error', new Error('not implemented'));
};

Readable.prototype.pipe = function(dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
              dest !== process.stdout &&
              dest !== process.stderr;

  var endFn = doEnd ? onend : cleanup;
  if (state.endEmitted)
    processNextTick(endFn);
  else
    src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable) {
    debug('onunpipe');
    if (readable === src) {
      cleanup();
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', cleanup);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain &&
        (!dest._writableState || dest._writableState.needDrain))
      ondrain();
  }

  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    if (false === ret) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      if (state.pipesCount === 1 &&
          state.pipes[0] === dest &&
          src.listenerCount('data') === 1 &&
          !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0)
      dest.emit('error', er);
  }
  // This is a brutally ugly hack to make sure that our error handler
  // is attached before any userland ones.  NEVER DO THIS.
  if (!dest._events || !dest._events.error)
    dest.on('error', onerror);
  else if (isArray(dest._events.error))
    dest._events.error.unshift(onerror);
  else
    dest._events.error = [onerror, dest._events.error];


  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain)
      state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}


Readable.prototype.unpipe = function(dest) {
  var state = this._readableState;

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0)
    return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes)
      return this;

    if (!dest)
      dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest)
      dest.emit('unpipe', this);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++)
      dests[i].emit('unpipe', this);
    return this;
  }

  // try to find the right one.
  var i = indexOf(state.pipes, dest);
  if (i === -1)
    return this;

  state.pipes.splice(i, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1)
    state.pipes = state.pipes[0];

  dest.emit('unpipe', this);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function(ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  // If listening to data, and it has not explicitly been paused,
  // then call resume to start the flow of data on the next tick.
  if (ev === 'data' && false !== this._readableState.flowing) {
    this.resume();
  }

  if (ev === 'readable' && this.readable) {
    var state = this._readableState;
    if (!state.readableListening) {
      state.readableListening = true;
      state.emittedReadable = false;
      state.needReadable = true;
      if (!state.reading) {
        processNextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this, state);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function() {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    processNextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading)
    stream.read(0);
}

Readable.prototype.pause = function() {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  if (state.flowing) {
    do {
      var chunk = stream.read();
    } while (null !== chunk && state.flowing);
  }
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function(stream) {
  var state = this._readableState;
  var paused = false;

  var self = this;
  stream.on('end', function() {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length)
        self.push(chunk);
    }

    self.push(null);
  });

  stream.on('data', function(chunk) {
    debug('wrapped data');
    if (state.decoder)
      chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined))
      return;
    else if (!state.objectMode && (!chunk || !chunk.length))
      return;

    var ret = self.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function(method) { return function() {
        return stream[method].apply(stream, arguments);
      }; }(i);
    }
  }

  // proxy certain important events.
  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
  forEach(events, function(ev) {
    stream.on(ev, self.emit.bind(self, ev));
  });

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  self._read = function(n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return self;
};


// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
function fromList(n, state) {
  var list = state.buffer;
  var length = state.length;
  var stringMode = !!state.decoder;
  var objectMode = !!state.objectMode;
  var ret;

  // nothing in the list, definitely empty.
  if (list.length === 0)
    return null;

  if (length === 0)
    ret = null;
  else if (objectMode)
    ret = list.shift();
  else if (!n || n >= length) {
    // read it all, truncate the array.
    if (stringMode)
      ret = list.join('');
    else if (list.length === 1)
      ret = list[0];
    else
      ret = Buffer.concat(list, length);
    list.length = 0;
  } else {
    // read just some of it.
    if (n < list[0].length) {
      // just take a part of the first list item.
      // slice is the same for buffers and strings.
      var buf = list[0];
      ret = buf.slice(0, n);
      list[0] = buf.slice(n);
    } else if (n === list[0].length) {
      // first list is a perfect match
      ret = list.shift();
    } else {
      // complex case.
      // we have enough to cover it, but it spans past the first buffer.
      if (stringMode)
        ret = '';
      else
        ret = new Buffer(n);

      var c = 0;
      for (var i = 0, l = list.length; i < l && c < n; i++) {
        var buf = list[0];
        var cpy = Math.min(n - c, buf.length);

        if (stringMode)
          ret += buf.slice(0, cpy);
        else
          buf.copy(ret, c, 0, cpy);

        if (cpy < buf.length)
          list[0] = buf.slice(cpy);
        else
          list.shift();

        c += cpy;
      }
    }
  }

  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0)
    throw new Error('endReadable called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    processNextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function forEach (xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

function indexOf (xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}

}).call(this,require('_process'))

},{"./_stream_duplex":354,"_process":352,"buffer":152,"core-util-is":359,"events":348,"inherits":349,"isarray":351,"process-nextick-args":360,"string_decoder/":367,"util":151}],357:[function(require,module,exports){
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);


function TransformState(stream) {
  this.afterTransform = function(er, data) {
    return afterTransform(stream, er, data);
  };

  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
}

function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb)
    return stream.emit('error', new Error('no writecb in Transform class'));

  ts.writechunk = null;
  ts.writecb = null;

  if (data !== null && data !== undefined)
    stream.push(data);

  if (cb)
    cb(er);

  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}


function Transform(options) {
  if (!(this instanceof Transform))
    return new Transform(options);

  Duplex.call(this, options);

  this._transformState = new TransformState(this);

  // when the writable side finishes, then flush out anything remaining.
  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function')
      this._transform = options.transform;

    if (typeof options.flush === 'function')
      this._flush = options.flush;
  }

  this.once('prefinish', function() {
    if (typeof this._flush === 'function')
      this._flush(function(er) {
        done(stream, er);
      });
    else
      done(stream);
  });
}

Transform.prototype.push = function(chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function(chunk, encoding, cb) {
  throw new Error('not implemented');
};

Transform.prototype._write = function(chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform ||
        rs.needReadable ||
        rs.length < rs.highWaterMark)
      this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function(n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};


function done(stream, er) {
  if (er)
    return stream.emit('error', er);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  var ws = stream._writableState;
  var ts = stream._transformState;

  if (ws.length)
    throw new Error('calling transform done when ws.length != 0');

  if (ts.transforming)
    throw new Error('calling transform done when still transforming');

  return stream.push(null);
}

},{"./_stream_duplex":354,"core-util-is":359,"inherits":349}],358:[function(require,module,exports){
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

'use strict';

module.exports = Writable;

/*<replacement>*/
var processNextTick = require('process-nextick-args');
/*</replacement>*/


/*<replacement>*/
var Buffer = require('buffer').Buffer;
/*</replacement>*/

Writable.WritableState = WritableState;


/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/


/*<replacement>*/
var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/



/*<replacement>*/
var Stream;
(function (){try{
  Stream = require('st' + 'ream');
}catch(_){}finally{
  if (!Stream)
    Stream = require('events').EventEmitter;
}}())
/*</replacement>*/

var Buffer = require('buffer').Buffer;

util.inherits(Writable, Stream);

function nop() {}

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

var Duplex;
function WritableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex)
    this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function(er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;
}

WritableState.prototype.getBuffer = function writableStateGetBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function (){try {
Object.defineProperty(WritableState.prototype, 'buffer', {
  get: internalUtil.deprecate(function() {
    return this.getBuffer();
  }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' +
     'instead.')
});
}catch(_){}}());


var Duplex;
function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, though they're not
  // instanceof Writable, they're instanceof Readable.
  if (!(this instanceof Writable) && !(this instanceof Duplex))
    return new Writable(options);

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function')
      this._write = options.write;

    if (typeof options.writev === 'function')
      this._writev = options.writev;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function() {
  this.emit('error', new Error('Cannot pipe. Not readable.'));
};


function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  processNextTick(cb, er);
}

// If we get something that is not a buffer, string, null, or undefined,
// and we're not in objectMode, then that's an error.
// Otherwise stream chunks are all considered to be of length=1, and the
// watermarks determine how many objects to keep in the buffer, rather than
// how many bytes or characters.
function validChunk(stream, state, chunk, cb) {
  var valid = true;

  if (!(Buffer.isBuffer(chunk)) &&
      typeof chunk !== 'string' &&
      chunk !== null &&
      chunk !== undefined &&
      !state.objectMode) {
    var er = new TypeError('Invalid non-string/buffer chunk');
    stream.emit('error', er);
    processNextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function(chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (Buffer.isBuffer(chunk))
    encoding = 'buffer';
  else if (!encoding)
    encoding = state.defaultEncoding;

  if (typeof cb !== 'function')
    cb = nop;

  if (state.ended)
    writeAfterEnd(this, cb);
  else if (validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function() {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function() {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing &&
        !state.corked &&
        !state.finished &&
        !state.bufferProcessing &&
        state.bufferedRequest)
      clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string')
    encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64',
'ucs2', 'ucs-2','utf16le', 'utf-16le', 'raw']
.indexOf((encoding + '').toLowerCase()) > -1))
    throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode &&
      state.decodeStrings !== false &&
      typeof chunk === 'string') {
    chunk = new Buffer(chunk, encoding);
  }
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, chunk, encoding, cb) {
  chunk = decodeChunk(state, chunk, encoding);

  if (Buffer.isBuffer(chunk))
    encoding = 'buffer';
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret)
    state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev)
    stream._writev(chunk, state.onwrite);
  else
    stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;
  if (sync)
    processNextTick(cb, er);
  else
    cb(er);

  stream._writableState.errorEmitted = true;
  stream.emit('error', er);
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er)
    onwriteError(stream, state, sync, er, cb);
  else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished &&
        !state.corked &&
        !state.bufferProcessing &&
        state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      processNextTick(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished)
    onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}


// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var buffer = [];
    var cbs = [];
    while (entry) {
      cbs.push(entry.callback);
      buffer.push(entry);
      entry = entry.next;
    }

    // count the one we are adding, as well.
    // TODO(isaacs) clean this up
    state.pendingcb++;
    state.lastBufferedRequest = null;
    doWrite(stream, state, true, state.length, buffer, '', function(err) {
      for (var i = 0; i < cbs.length; i++) {
        state.pendingcb--;
        cbs[i](err);
      }
    });

    // Clear buffer
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null)
      state.lastBufferedRequest = null;
  }
  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function(chunk, encoding, cb) {
  cb(new Error('not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function(chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined)
    this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished)
    endWritable(this, state, cb);
};


function needFinish(state) {
  return (state.ending &&
          state.length === 0 &&
          state.bufferedRequest === null &&
          !state.finished &&
          !state.writing);
}

function prefinish(stream, state) {
  if (!state.prefinished) {
    state.prefinished = true;
    stream.emit('prefinish');
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    if (state.pendingcb === 0) {
      prefinish(stream, state);
      state.finished = true;
      stream.emit('finish');
    } else {
      prefinish(stream, state);
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished)
      processNextTick(cb);
    else
      stream.once('finish', cb);
  }
  state.ended = true;
}

},{"./_stream_duplex":354,"buffer":152,"core-util-is":359,"events":348,"inherits":349,"process-nextick-args":360,"util-deprecate":361}],359:[function(require,module,exports){
(function (Buffer){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

}).call(this,{"isBuffer":require("../../../../insert-module-globals/node_modules/is-buffer/index.js")})

},{"../../../../insert-module-globals/node_modules/is-buffer/index.js":350}],360:[function(require,module,exports){
(function (process){
'use strict';

if (!process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = nextTick;
} else {
  module.exports = process.nextTick;
}

function nextTick(fn) {
  var args = new Array(arguments.length - 1);
  var i = 0;
  while (i < args.length) {
    args[i++] = arguments[i];
  }
  process.nextTick(function afterTick() {
    fn.apply(null, args);
  });
}

}).call(this,require('_process'))

},{"_process":352}],361:[function(require,module,exports){
(function (global){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],362:[function(require,module,exports){
module.exports = require("./lib/_stream_passthrough.js")

},{"./lib/_stream_passthrough.js":355}],363:[function(require,module,exports){
var Stream = (function (){
  try {
    return require('st' + 'ream'); // hack to fix a circular dependency issue when used with browserify
  } catch(_){}
}());
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = Stream || exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

},{"./lib/_stream_duplex.js":354,"./lib/_stream_passthrough.js":355,"./lib/_stream_readable.js":356,"./lib/_stream_transform.js":357,"./lib/_stream_writable.js":358}],364:[function(require,module,exports){
module.exports = require("./lib/_stream_transform.js")

},{"./lib/_stream_transform.js":357}],365:[function(require,module,exports){
module.exports = require("./lib/_stream_writable.js")

},{"./lib/_stream_writable.js":358}],366:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('readable-stream/readable.js');
Stream.Writable = require('readable-stream/writable.js');
Stream.Duplex = require('readable-stream/duplex.js');
Stream.Transform = require('readable-stream/transform.js');
Stream.PassThrough = require('readable-stream/passthrough.js');

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":348,"inherits":349,"readable-stream/duplex.js":353,"readable-stream/passthrough.js":362,"readable-stream/readable.js":363,"readable-stream/transform.js":364,"readable-stream/writable.js":365}],367:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var Buffer = require('buffer').Buffer;

var isBufferEncoding = Buffer.isEncoding
  || function(encoding) {
       switch (encoding && encoding.toLowerCase()) {
         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
         default: return false;
       }
     }


function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error('Unknown encoding: ' + encoding);
  }
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters. CESU-8 is handled as part of the UTF-8 encoding.
//
// @TODO Handling all encodings inside a single object makes it very difficult
// to reason about this code, so it should be split up in the future.
// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
// points as used by CESU-8.
var StringDecoder = exports.StringDecoder = function(encoding) {
  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
  assertEncoding(encoding);
  switch (this.encoding) {
    case 'utf8':
      // CESU-8 represents each of Surrogate Pair by 3-bytes
      this.surrogateSize = 3;
      break;
    case 'ucs2':
    case 'utf16le':
      // UTF-16 represents each of Surrogate Pair by 2-bytes
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case 'base64':
      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }

  // Enough space to store all bytes of a single character. UTF-8 needs 4
  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
  this.charBuffer = new Buffer(6);
  // Number of bytes received for the current incomplete multi-byte character.
  this.charReceived = 0;
  // Number of bytes expected for the current incomplete multi-byte character.
  this.charLength = 0;
};


// write decodes the given buffer and returns it as JS string that is
// guaranteed to not contain any partial multi-byte characters. Any partial
// character found at the end of the buffer is buffered up, and will be
// returned when calling write again with the remaining bytes.
//
// Note: Converting a Buffer containing an orphan surrogate to a String
// currently works, but converting a String to a Buffer (via `new Buffer`, or
// Buffer#write) will replace incomplete surrogates with the unicode
// replacement character. See https://codereview.chromium.org/121173009/ .
StringDecoder.prototype.write = function(buffer) {
  var charStr = '';
  // if our last write ended with an incomplete multibyte character
  while (this.charLength) {
    // determine how many remaining bytes this buffer has to offer for this char
    var available = (buffer.length >= this.charLength - this.charReceived) ?
        this.charLength - this.charReceived :
        buffer.length;

    // add the new bytes to the char buffer
    buffer.copy(this.charBuffer, this.charReceived, 0, available);
    this.charReceived += available;

    if (this.charReceived < this.charLength) {
      // still not enough chars in this buffer? wait for more ...
      return '';
    }

    // remove bytes belonging to the current character from the buffer
    buffer = buffer.slice(available, buffer.length);

    // get the character that was split
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      this.charLength += this.surrogateSize;
      charStr = '';
      continue;
    }
    this.charReceived = this.charLength = 0;

    // if there are no more bytes in this buffer, just emit our char
    if (buffer.length === 0) {
      return charStr;
    }
    break;
  }

  // determine and set charLength / charReceived
  this.detectIncompleteChar(buffer);

  var end = buffer.length;
  if (this.charLength) {
    // buffer the incomplete character bytes we got
    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
    end -= this.charReceived;
  }

  charStr += buffer.toString(this.encoding, 0, end);

  var end = charStr.length - 1;
  var charCode = charStr.charCodeAt(end);
  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    buffer.copy(this.charBuffer, 0, 0, size);
    return charStr.substring(0, end);
  }

  // or just emit the charStr
  return charStr;
};

// detectIncompleteChar determines if there is an incomplete UTF-8 character at
// the end of the given buffer. If so, it sets this.charLength to the byte
// length that character, and sets this.charReceived to the number of bytes
// that are available for this character.
StringDecoder.prototype.detectIncompleteChar = function(buffer) {
  // determine how many bytes we have to check at the end of this buffer
  var i = (buffer.length >= 3) ? 3 : buffer.length;

  // Figure out if one of the last i bytes of our buffer announces an
  // incomplete char.
  for (; i > 0; i--) {
    var c = buffer[buffer.length - i];

    // See http://en.wikipedia.org/wiki/UTF-8#Description

    // 110XXXXX
    if (i == 1 && c >> 5 == 0x06) {
      this.charLength = 2;
      break;
    }

    // 1110XXXX
    if (i <= 2 && c >> 4 == 0x0E) {
      this.charLength = 3;
      break;
    }

    // 11110XXX
    if (i <= 3 && c >> 3 == 0x1E) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = i;
};

StringDecoder.prototype.end = function(buffer) {
  var res = '';
  if (buffer && buffer.length)
    res = this.write(buffer);

  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }

  return res;
};

function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}

function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}

function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}

},{"buffer":152}],368:[function(require,module,exports){
var indexOf = require('indexof');

var Object_keys = function (obj) {
    if (Object.keys) return Object.keys(obj)
    else {
        var res = [];
        for (var key in obj) res.push(key)
        return res;
    }
};

var forEach = function (xs, fn) {
    if (xs.forEach) return xs.forEach(fn)
    else for (var i = 0; i < xs.length; i++) {
        fn(xs[i], i, xs);
    }
};

var defineProp = (function() {
    try {
        Object.defineProperty({}, '_', {});
        return function(obj, name, value) {
            Object.defineProperty(obj, name, {
                writable: true,
                enumerable: false,
                configurable: true,
                value: value
            })
        };
    } catch(e) {
        return function(obj, name, value) {
            obj[name] = value;
        };
    }
}());

var globals = ['Array', 'Boolean', 'Date', 'Error', 'EvalError', 'Function',
'Infinity', 'JSON', 'Math', 'NaN', 'Number', 'Object', 'RangeError',
'ReferenceError', 'RegExp', 'String', 'SyntaxError', 'TypeError', 'URIError',
'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'escape',
'eval', 'isFinite', 'isNaN', 'parseFloat', 'parseInt', 'undefined', 'unescape'];

function Context() {}
Context.prototype = {};

var Script = exports.Script = function NodeScript (code) {
    if (!(this instanceof Script)) return new Script(code);
    this.code = code;
};

Script.prototype.runInContext = function (context) {
    if (!(context instanceof Context)) {
        throw new TypeError("needs a 'context' argument.");
    }
    
    var iframe = document.createElement('iframe');
    if (!iframe.style) iframe.style = {};
    iframe.style.display = 'none';
    
    document.body.appendChild(iframe);
    
    var win = iframe.contentWindow;
    var wEval = win.eval, wExecScript = win.execScript;

    if (!wEval && wExecScript) {
        // win.eval() magically appears when this is called in IE:
        wExecScript.call(win, 'null');
        wEval = win.eval;
    }
    
    forEach(Object_keys(context), function (key) {
        win[key] = context[key];
    });
    forEach(globals, function (key) {
        if (context[key]) {
            win[key] = context[key];
        }
    });
    
    var winKeys = Object_keys(win);

    var res = wEval.call(win, this.code);
    
    forEach(Object_keys(win), function (key) {
        // Avoid copying circular objects like `top` and `window` by only
        // updating existing context properties or new properties in the `win`
        // that was only introduced after the eval.
        if (key in context || indexOf(winKeys, key) === -1) {
            context[key] = win[key];
        }
    });

    forEach(globals, function (key) {
        if (!(key in context)) {
            defineProp(context, key, win[key]);
        }
    });
    
    document.body.removeChild(iframe);
    
    return res;
};

Script.prototype.runInThisContext = function () {
    return eval(this.code); // maybe...
};

Script.prototype.runInNewContext = function (context) {
    var ctx = Script.createContext(context);
    var res = this.runInContext(ctx);

    forEach(Object_keys(ctx), function (key) {
        context[key] = ctx[key];
    });

    return res;
};

forEach(Object_keys(Script.prototype), function (name) {
    exports[name] = Script[name] = function (code) {
        var s = Script(code);
        return s[name].apply(s, [].slice.call(arguments, 1));
    };
});

exports.createScript = function (code) {
    return exports.Script(code);
};

exports.createContext = Script.createContext = function (context) {
    var copy = new Context();
    if(typeof context === 'object') {
        forEach(Object_keys(context), function (key) {
            copy[key] = context[key];
        });
    }
    return copy;
};

},{"indexof":369}],369:[function(require,module,exports){

var indexOf = [].indexOf;

module.exports = function(arr, obj){
  if (indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};
},{}],370:[function(require,module,exports){
/*!
 * XRegExp-All 3.0.0
 * <http://xregexp.com/>
 * Steven Levithan (c) 2012-2015 MIT License
 */

// Module systems magic dance. Don't use strict mode for this function, so it can assign to global.
;(function(root, definition) {
    var self;

    // RequireJS
    if (typeof define === 'function') {
        define(definition);
    // CommonJS
    } else if (typeof exports === 'object') {
        self = definition();
        // Use Node.js's `module.exports`. This supports both `require('xregexp')` and
        // `require('xregexp').XRegExp`
        (typeof module === 'object' ? (module.exports = self) : exports).XRegExp = self;
    // <script>
    } else {
        // Create global
        root.XRegExp = definition();
    }
}(this, function() {

/*!
 * XRegExp 3.0.0
 * <http://xregexp.com/>
 * Steven Levithan (c) 2007-2015 MIT License
 */

/**
 * XRegExp provides augmented, extensible regular expressions. You get additional regex syntax and
 * flags, beyond what browsers support natively. XRegExp is also a regex utility belt with tools to
 * make your client-side grepping simpler and more powerful, while freeing you from related
 * cross-browser inconsistencies.
 */
var XRegExp = (function(undefined) {
    'use strict';

/* ==============================
 * Private variables
 * ============================== */

    var // Internal reference to the `XRegExp` object
        self,
        // Property name used for extended regex instance data
        REGEX_DATA = 'xregexp',
        // Optional features that can be installed and uninstalled
        features = {
            astral: false,
            natives: false
        },
        // Native methods to use and restore ('native' is an ES3 reserved keyword)
        nativ = {
            exec: RegExp.prototype.exec,
            test: RegExp.prototype.test,
            match: String.prototype.match,
            replace: String.prototype.replace,
            split: String.prototype.split
        },
        // Storage for fixed/extended native methods
        fixed = {},
        // Storage for regexes cached by `XRegExp.cache`
        regexCache = {},
        // Storage for pattern details cached by the `XRegExp` constructor
        patternCache = {},
        // Storage for regex syntax tokens added internally or by `XRegExp.addToken`
        tokens = [],
        // Token scopes
        defaultScope = 'default',
        classScope = 'class',
        // Regexes that match native regex syntax, including octals
        nativeTokens = {
            // Any native multicharacter token in default scope, or any single character
            'default': /\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9]\d*|x[\dA-Fa-f]{2}|u(?:[\dA-Fa-f]{4}|{[\dA-Fa-f]+})|c[A-Za-z]|[\s\S])|\(\?[:=!]|[?*+]\?|{\d+(?:,\d*)?}\??|[\s\S]/,
            // Any native multicharacter token in character class scope, or any single character
            'class': /\\(?:[0-3][0-7]{0,2}|[4-7][0-7]?|x[\dA-Fa-f]{2}|u(?:[\dA-Fa-f]{4}|{[\dA-Fa-f]+})|c[A-Za-z]|[\s\S])|[\s\S]/
        },
        // Any backreference or dollar-prefixed character in replacement strings
        replacementToken = /\$(?:{([\w$]+)}|(\d\d?|[\s\S]))/g,
        // Check for correct `exec` handling of nonparticipating capturing groups
        correctExecNpcg = nativ.exec.call(/()??/, '')[1] === undefined,
        // Check for ES6 `u` flag support
        hasNativeU = (function() {
            var isSupported = true;
            try {
                new RegExp('', 'u');
            } catch (exception) {
                isSupported = false;
            }
            return isSupported;
        }()),
        // Check for ES6 `y` flag support
        hasNativeY = (function() {
            var isSupported = true;
            try {
                new RegExp('', 'y');
            } catch (exception) {
                isSupported = false;
            }
            return isSupported;
        }()),
        // Check for ES6 `flags` prop support
        hasFlagsProp = /a/.flags !== undefined,
        // Tracker for known flags, including addon flags
        registeredFlags = {
            g: true,
            i: true,
            m: true,
            u: hasNativeU,
            y: hasNativeY
        },
        // Shortcut to `Object.prototype.toString`
        toString = {}.toString,
        // Shortcut to `XRegExp.addToken`
        add;

/* ==============================
 * Private functions
 * ============================== */

/**
 * Attaches extended data and `XRegExp.prototype` properties to a regex object.
 *
 * @private
 * @param {RegExp} regex Regex to augment.
 * @param {Array} captureNames Array with capture names, or `null`.
 * @param {String} xSource XRegExp pattern used to generate `regex`, or `null` if N/A.
 * @param {String} xFlags XRegExp flags used to generate `regex`, or `null` if N/A.
 * @param {Boolean} [isInternalOnly=false] Whether the regex will be used only for internal
 *   operations, and never exposed to users. For internal-only regexes, we can improve perf by
 *   skipping some operations like attaching `XRegExp.prototype` properties.
 * @returns {RegExp} Augmented regex.
 */
    function augment(regex, captureNames, xSource, xFlags, isInternalOnly) {
        var p;

        regex[REGEX_DATA] = {
            captureNames: captureNames
        };

        if (isInternalOnly) {
            return regex;
        }

        // Can't auto-inherit these since the XRegExp constructor returns a nonprimitive value
        if (regex.__proto__) {
            regex.__proto__ = self.prototype;
        } else {
            for (p in self.prototype) {
                // A `self.prototype.hasOwnProperty(p)` check wouldn't be worth it here, since this
                // is performance sensitive, and enumerable `Object.prototype` or `RegExp.prototype`
                // extensions exist on `regex.prototype` anyway
                regex[p] = self.prototype[p];
            }
        }

        regex[REGEX_DATA].source = xSource;
        // Emulate the ES6 `flags` prop by ensuring flags are in alphabetical order
        regex[REGEX_DATA].flags = xFlags ? xFlags.split('').sort().join('') : xFlags;

        return regex;
    }

/**
 * Removes any duplicate characters from the provided string.
 *
 * @private
 * @param {String} str String to remove duplicate characters from.
 * @returns {String} String with any duplicate characters removed.
 */
    function clipDuplicates(str) {
        return nativ.replace.call(str, /([\s\S])(?=[\s\S]*\1)/g, '');
    }

/**
 * Copies a regex object while preserving extended data and augmenting with `XRegExp.prototype`
 * properties. The copy has a fresh `lastIndex` property (set to zero). Allows adding and removing
 * flags g and y while copying the regex.
 *
 * @private
 * @param {RegExp} regex Regex to copy.
 * @param {Object} [options] Options object with optional properties:
 *   <li>`addG` {Boolean} Add flag g while copying the regex.
 *   <li>`addY` {Boolean} Add flag y while copying the regex.
 *   <li>`removeG` {Boolean} Remove flag g while copying the regex.
 *   <li>`removeY` {Boolean} Remove flag y while copying the regex.
 *   <li>`isInternalOnly` {Boolean} Whether the copied regex will be used only for internal
 *     operations, and never exposed to users. For internal-only regexes, we can improve perf by
 *     skipping some operations like attaching `XRegExp.prototype` properties.
 * @returns {RegExp} Copy of the provided regex, possibly with modified flags.
 */
    function copyRegex(regex, options) {
        if (!self.isRegExp(regex)) {
            throw new TypeError('Type RegExp expected');
        }

        var xData = regex[REGEX_DATA] || {},
            flags = getNativeFlags(regex),
            flagsToAdd = '',
            flagsToRemove = '',
            xregexpSource = null,
            xregexpFlags = null;

        options = options || {};

        if (options.removeG) {flagsToRemove += 'g';}
        if (options.removeY) {flagsToRemove += 'y';}
        if (flagsToRemove) {
            flags = nativ.replace.call(flags, new RegExp('[' + flagsToRemove + ']+', 'g'), '');
        }

        if (options.addG) {flagsToAdd += 'g';}
        if (options.addY) {flagsToAdd += 'y';}
        if (flagsToAdd) {
            flags = clipDuplicates(flags + flagsToAdd);
        }

        if (!options.isInternalOnly) {
            if (xData.source !== undefined) {
                xregexpSource = xData.source;
            }
            // null or undefined; don't want to add to `flags` if the previous value was null, since
            // that indicates we're not tracking original precompilation flags
            if (xData.flags != null) {
                // Flags are only added for non-internal regexes by `XRegExp.globalize`. Flags are
                // never removed for non-internal regexes, so don't need to handle it
                xregexpFlags = flagsToAdd ? clipDuplicates(xData.flags + flagsToAdd) : xData.flags;
            }
        }

        // Augment with `XRegExp.prototype` properties, but use the native `RegExp` constructor to
        // avoid searching for special tokens. That would be wrong for regexes constructed by
        // `RegExp`, and unnecessary for regexes constructed by `XRegExp` because the regex has
        // already undergone the translation to native regex syntax
        regex = augment(
            new RegExp(regex.source, flags),
            hasNamedCapture(regex) ? xData.captureNames.slice(0) : null,
            xregexpSource,
            xregexpFlags,
            options.isInternalOnly
        );

        return regex;
    }

/**
 * Converts hexadecimal to decimal.
 *
 * @private
 * @param {String} hex
 * @returns {Number}
 */
    function dec(hex) {
        return parseInt(hex, 16);
    }

/**
 * Returns native `RegExp` flags used by a regex object.
 *
 * @private
 * @param {RegExp} regex Regex to check.
 * @returns {String} Native flags in use.
 */
    function getNativeFlags(regex) {
        return hasFlagsProp ?
            regex.flags :
            // Explicitly using `RegExp.prototype.toString` (rather than e.g. `String` or
            // concatenation with an empty string) allows this to continue working predictably when
            // `XRegExp.proptotype.toString` is overriden
            nativ.exec.call(/\/([a-z]*)$/i, RegExp.prototype.toString.call(regex))[1];
    }

/**
 * Determines whether a regex has extended instance data used to track capture names.
 *
 * @private
 * @param {RegExp} regex Regex to check.
 * @returns {Boolean} Whether the regex uses named capture.
 */
    function hasNamedCapture(regex) {
        return !!(regex[REGEX_DATA] && regex[REGEX_DATA].captureNames);
    }

/**
 * Converts decimal to hexadecimal.
 *
 * @private
 * @param {Number|String} dec
 * @returns {String}
 */
    function hex(dec) {
        return parseInt(dec, 10).toString(16);
    }

/**
 * Returns the first index at which a given value can be found in an array.
 *
 * @private
 * @param {Array} array Array to search.
 * @param {*} value Value to locate in the array.
 * @returns {Number} Zero-based index at which the item is found, or -1.
 */
    function indexOf(array, value) {
        var len = array.length, i;

        for (i = 0; i < len; ++i) {
            if (array[i] === value) {
                return i;
            }
        }

        return -1;
    }

/**
 * Determines whether a value is of the specified type, by resolving its internal [[Class]].
 *
 * @private
 * @param {*} value Object to check.
 * @param {String} type Type to check for, in TitleCase.
 * @returns {Boolean} Whether the object matches the type.
 */
    function isType(value, type) {
        return toString.call(value) === '[object ' + type + ']';
    }

/**
 * Checks whether the next nonignorable token after the specified position is a quantifier.
 *
 * @private
 * @param {String} pattern Pattern to search within.
 * @param {Number} pos Index in `pattern` to search at.
 * @param {String} flags Flags used by the pattern.
 * @returns {Boolean} Whether the next token is a quantifier.
 */
    function isQuantifierNext(pattern, pos, flags) {
        return nativ.test.call(
            flags.indexOf('x') > -1 ?
                // Ignore any leading whitespace, line comments, and inline comments
                /^(?:\s+|#.*|\(\?#[^)]*\))*(?:[?*+]|{\d+(?:,\d*)?})/ :
                // Ignore any leading inline comments
                /^(?:\(\?#[^)]*\))*(?:[?*+]|{\d+(?:,\d*)?})/,
            pattern.slice(pos)
        );
    }

/**
 * Pads the provided string with as many leading zeros as needed to get to length 4. Used to produce
 * fixed-length hexadecimal values.
 *
 * @private
 * @param {String} str
 * @returns {String}
 */
    function pad4(str) {
        while (str.length < 4) {
            str = '0' + str;
        }
        return str;
    }

/**
 * Checks for flag-related errors, and strips/applies flags in a leading mode modifier. Offloads
 * the flag preparation logic from the `XRegExp` constructor.
 *
 * @private
 * @param {String} pattern Regex pattern, possibly with a leading mode modifier.
 * @param {String} flags Any combination of flags.
 * @returns {Object} Object with properties `pattern` and `flags`.
 */
    function prepareFlags(pattern, flags) {
        var i;

        // Recent browsers throw on duplicate flags, so copy this behavior for nonnative flags
        if (clipDuplicates(flags) !== flags) {
            throw new SyntaxError('Invalid duplicate regex flag ' + flags);
        }

        // Strip and apply a leading mode modifier with any combination of flags except g or y
        pattern = nativ.replace.call(pattern, /^\(\?([\w$]+)\)/, function($0, $1) {
            if (nativ.test.call(/[gy]/, $1)) {
                throw new SyntaxError('Cannot use flag g or y in mode modifier ' + $0);
            }
            // Allow duplicate flags within the mode modifier
            flags = clipDuplicates(flags + $1);
            return '';
        });

        // Throw on unknown native or nonnative flags
        for (i = 0; i < flags.length; ++i) {
            if (!registeredFlags[flags.charAt(i)]) {
                throw new SyntaxError('Unknown regex flag ' + flags.charAt(i));
            }
        }

        return {
            pattern: pattern,
            flags: flags
        };
    }

/**
 * Prepares an options object from the given value.
 *
 * @private
 * @param {String|Object} value Value to convert to an options object.
 * @returns {Object} Options object.
 */
    function prepareOptions(value) {
        var options = {};

        if (isType(value, 'String')) {
            self.forEach(value, /[^\s,]+/, function(match) {
                options[match] = true;
            });

            return options;
        }

        return value;
    }

/**
 * Registers a flag so it doesn't throw an 'unknown flag' error.
 *
 * @private
 * @param {String} flag Single-character flag to register.
 */
    function registerFlag(flag) {
        if (!/^[\w$]$/.test(flag)) {
            throw new Error('Flag must be a single character A-Za-z0-9_$');
        }

        registeredFlags[flag] = true;
    }

/**
 * Runs built-in and custom regex syntax tokens in reverse insertion order at the specified
 * position, until a match is found.
 *
 * @private
 * @param {String} pattern Original pattern from which an XRegExp object is being built.
 * @param {String} flags Flags being used to construct the regex.
 * @param {Number} pos Position to search for tokens within `pattern`.
 * @param {Number} scope Regex scope to apply: 'default' or 'class'.
 * @param {Object} context Context object to use for token handler functions.
 * @returns {Object} Object with properties `matchLength`, `output`, and `reparse`; or `null`.
 */
    function runTokens(pattern, flags, pos, scope, context) {
        var i = tokens.length,
            leadChar = pattern.charAt(pos),
            result = null,
            match,
            t;

        // Run in reverse insertion order
        while (i--) {
            t = tokens[i];
            if (
                (t.leadChar && t.leadChar !== leadChar) ||
                (t.scope !== scope && t.scope !== 'all') ||
                (t.flag && flags.indexOf(t.flag) === -1)
            ) {
                continue;
            }

            match = self.exec(pattern, t.regex, pos, 'sticky');
            if (match) {
                result = {
                    matchLength: match[0].length,
                    output: t.handler.call(context, match, scope, flags),
                    reparse: t.reparse
                };
                // Finished with token tests
                break;
            }
        }

        return result;
    }

/**
 * Enables or disables implicit astral mode opt-in. When enabled, flag A is automatically added to
 * all new regexes created by XRegExp. This causes an error to be thrown when creating regexes if
 * the Unicode Base addon is not available, since flag A is registered by that addon.
 *
 * @private
 * @param {Boolean} on `true` to enable; `false` to disable.
 */
    function setAstral(on) {
        features.astral = on;
    }

/**
 * Enables or disables native method overrides.
 *
 * @private
 * @param {Boolean} on `true` to enable; `false` to disable.
 */
    function setNatives(on) {
        RegExp.prototype.exec = (on ? fixed : nativ).exec;
        RegExp.prototype.test = (on ? fixed : nativ).test;
        String.prototype.match = (on ? fixed : nativ).match;
        String.prototype.replace = (on ? fixed : nativ).replace;
        String.prototype.split = (on ? fixed : nativ).split;

        features.natives = on;
    }

/**
 * Returns the object, or throws an error if it is `null` or `undefined`. This is used to follow
 * the ES5 abstract operation `ToObject`.
 *
 * @private
 * @param {*} value Object to check and return.
 * @returns {*} The provided object.
 */
    function toObject(value) {
        // null or undefined
        if (value == null) {
            throw new TypeError('Cannot convert null or undefined to object');
        }

        return value;
    }

/* ==============================
 * Constructor
 * ============================== */

/**
 * Creates an extended regular expression object for matching text with a pattern. Differs from a
 * native regular expression in that additional syntax and flags are supported. The returned object
 * is in fact a native `RegExp` and works with all native methods.
 *
 * @class XRegExp
 * @constructor
 * @param {String|RegExp} pattern Regex pattern string, or an existing regex object to copy.
 * @param {String} [flags] Any combination of flags.
 *   Native flags:
 *     <li>`g` - global
 *     <li>`i` - ignore case
 *     <li>`m` - multiline anchors
 *     <li>`u` - unicode (ES6)
 *     <li>`y` - sticky (Firefox 3+, ES6)
 *   Additional XRegExp flags:
 *     <li>`n` - explicit capture
 *     <li>`s` - dot matches all (aka singleline)
 *     <li>`x` - free-spacing and line comments (aka extended)
 *     <li>`A` - astral (requires the Unicode Base addon)
 *   Flags cannot be provided when constructing one `RegExp` from another.
 * @returns {RegExp} Extended regular expression object.
 * @example
 *
 * // With named capture and flag x
 * XRegExp('(?<year>  [0-9]{4} ) -?  # year  \n\
 *          (?<month> [0-9]{2} ) -?  # month \n\
 *          (?<day>   [0-9]{2} )     # day   ', 'x');
 *
 * // Providing a regex object copies it. Native regexes are recompiled using native (not XRegExp)
 * // syntax. Copies maintain extended data, are augmented with `XRegExp.prototype` properties, and
 * // have fresh `lastIndex` properties (set to zero).
 * XRegExp(/regex/);
 */
    self = function(pattern, flags) {
        var context = {
                hasNamedCapture: false,
                captureNames: []
            },
            scope = defaultScope,
            output = '',
            pos = 0,
            result,
            token,
            generated,
            appliedPattern,
            appliedFlags;

        if (self.isRegExp(pattern)) {
            if (flags !== undefined) {
                throw new TypeError('Cannot supply flags when copying a RegExp');
            }
            return copyRegex(pattern);
        }

        // Copy the argument behavior of `RegExp`
        pattern = pattern === undefined ? '' : String(pattern);
        flags = flags === undefined ? '' : String(flags);

        if (self.isInstalled('astral') && flags.indexOf('A') === -1) {
            // This causes an error to be thrown if the Unicode Base addon is not available
            flags += 'A';
        }

        if (!patternCache[pattern]) {
            patternCache[pattern] = {};
        }

        if (!patternCache[pattern][flags]) {
            // Check for flag-related errors, and strip/apply flags in a leading mode modifier
            result = prepareFlags(pattern, flags);
            appliedPattern = result.pattern;
            appliedFlags = result.flags;

            // Use XRegExp's tokens to translate the pattern to a native regex pattern.
            // `appliedPattern.length` may change on each iteration if tokens use `reparse`
            while (pos < appliedPattern.length) {
                do {
                    // Check for custom tokens at the current position
                    result = runTokens(appliedPattern, appliedFlags, pos, scope, context);
                    // If the matched token used the `reparse` option, splice its output into the
                    // pattern before running tokens again at the same position
                    if (result && result.reparse) {
                        appliedPattern = appliedPattern.slice(0, pos) +
                            result.output +
                            appliedPattern.slice(pos + result.matchLength);
                    }
                } while (result && result.reparse);

                if (result) {
                    output += result.output;
                    pos += (result.matchLength || 1);
                } else {
                    // Get the native token at the current position
                    token = self.exec(appliedPattern, nativeTokens[scope], pos, 'sticky')[0];
                    output += token;
                    pos += token.length;
                    if (token === '[' && scope === defaultScope) {
                        scope = classScope;
                    } else if (token === ']' && scope === classScope) {
                        scope = defaultScope;
                    }
                }
            }

            patternCache[pattern][flags] = {
                // Cleanup token cruft: repeated `(?:)(?:)` and leading/trailing `(?:)`
                pattern: nativ.replace.call(output, /\(\?:\)(?=\(\?:\))|^\(\?:\)|\(\?:\)$/g, ''),
                // Strip all but native flags
                flags: nativ.replace.call(appliedFlags, /[^gimuy]+/g, ''),
                // `context.captureNames` has an item for each capturing group, even if unnamed
                captures: context.hasNamedCapture ? context.captureNames : null
            };
        }

        generated = patternCache[pattern][flags];
        return augment(
            new RegExp(generated.pattern, generated.flags),
            generated.captures,
            pattern,
            flags
        );
    };

// Add `RegExp.prototype` to the prototype chain
    self.prototype = new RegExp();

/* ==============================
 * Public properties
 * ============================== */

/**
 * The XRegExp version number.
 *
 * @static
 * @memberOf XRegExp
 * @type String
 */
    self.version = '3.0.0';

/* ==============================
 * Public methods
 * ============================== */

/**
 * Extends XRegExp syntax and allows custom flags. This is used internally and can be used to
 * create XRegExp addons. If more than one token can match the same string, the last added wins.
 *
 * @memberOf XRegExp
 * @param {RegExp} regex Regex object that matches the new token.
 * @param {Function} handler Function that returns a new pattern string (using native regex syntax)
 *   to replace the matched token within all future XRegExp regexes. Has access to persistent
 *   properties of the regex being built, through `this`. Invoked with three arguments:
 *   <li>The match array, with named backreference properties.
 *   <li>The regex scope where the match was found: 'default' or 'class'.
 *   <li>The flags used by the regex, including any flags in a leading mode modifier.
 *   The handler function becomes part of the XRegExp construction process, so be careful not to
 *   construct XRegExps within the function or you will trigger infinite recursion.
 * @param {Object} [options] Options object with optional properties:
 *   <li>`scope` {String} Scope where the token applies: 'default', 'class', or 'all'.
 *   <li>`flag` {String} Single-character flag that triggers the token. This also registers the
 *     flag, which prevents XRegExp from throwing an 'unknown flag' error when the flag is used.
 *   <li>`optionalFlags` {String} Any custom flags checked for within the token `handler` that are
 *     not required to trigger the token. This registers the flags, to prevent XRegExp from
 *     throwing an 'unknown flag' error when any of the flags are used.
 *   <li>`reparse` {Boolean} Whether the `handler` function's output should not be treated as
 *     final, and instead be reparseable by other tokens (including the current token). Allows
 *     token chaining or deferring.
 *   <li>`leadChar` {String} Single character that occurs at the beginning of any successful match
 *     of the token (not always applicable). This doesn't change the behavior of the token unless
 *     you provide an erroneous value. However, providing it can increase the token's performance.
 * @example
 *
 * // Basic usage: Add \a for the ALERT control code
 * XRegExp.addToken(
 *   /\\a/,
 *   function() {return '\\x07';},
 *   {scope: 'all'}
 * );
 * XRegExp('\\a[\\a-\\n]+').test('\x07\n\x07'); // -> true
 *
 * // Add the U (ungreedy) flag from PCRE and RE2, which reverses greedy and lazy quantifiers
 * XRegExp.addToken(
 *   /([?*+]|{\d+(?:,\d*)?})(\??)/,
 *   function(match) {return match[1] + (match[2] ? '' : '?');},
 *   {flag: 'U'}
 * );
 * XRegExp('a+', 'U').exec('aaa')[0]; // -> 'a'
 * XRegExp('a+?', 'U').exec('aaa')[0]; // -> 'aaa'
 */
    self.addToken = function(regex, handler, options) {
        options = options || {};
        var optionalFlags = options.optionalFlags, i;

        if (options.flag) {
            registerFlag(options.flag);
        }

        if (optionalFlags) {
            optionalFlags = nativ.split.call(optionalFlags, '');
            for (i = 0; i < optionalFlags.length; ++i) {
                registerFlag(optionalFlags[i]);
            }
        }

        // Add to the private list of syntax tokens
        tokens.push({
            regex: copyRegex(regex, {
                addG: true,
                addY: hasNativeY,
                isInternalOnly: true
            }),
            handler: handler,
            scope: options.scope || defaultScope,
            flag: options.flag,
            reparse: options.reparse,
            leadChar: options.leadChar
        });

        // Reset the pattern cache used by the `XRegExp` constructor, since the same pattern and
        // flags might now produce different results
        self.cache.flush('patterns');
    };

/**
 * Caches and returns the result of calling `XRegExp(pattern, flags)`. On any subsequent call with
 * the same pattern and flag combination, the cached copy of the regex is returned.
 *
 * @memberOf XRegExp
 * @param {String} pattern Regex pattern string.
 * @param {String} [flags] Any combination of XRegExp flags.
 * @returns {RegExp} Cached XRegExp object.
 * @example
 *
 * while (match = XRegExp.cache('.', 'gs').exec(str)) {
 *   // The regex is compiled once only
 * }
 */
    self.cache = function(pattern, flags) {
        if (!regexCache[pattern]) {
            regexCache[pattern] = {};
        }
        return regexCache[pattern][flags] || (
            regexCache[pattern][flags] = self(pattern, flags)
        );
    };

// Intentionally undocumented
    self.cache.flush = function(cacheName) {
        if (cacheName === 'patterns') {
            // Flush the pattern cache used by the `XRegExp` constructor
            patternCache = {};
        } else {
            // Flush the regex cache populated by `XRegExp.cache`
            regexCache = {};
        }
    };

/**
 * Escapes any regular expression metacharacters, for use when matching literal strings. The result
 * can safely be used at any point within a regex that uses any flags.
 *
 * @memberOf XRegExp
 * @param {String} str String to escape.
 * @returns {String} String with regex metacharacters escaped.
 * @example
 *
 * XRegExp.escape('Escaped? <.>');
 * // -> 'Escaped\?\ <\.>'
 */
    self.escape = function(str) {
        return nativ.replace.call(toObject(str), /[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
    };

/**
 * Executes a regex search in a specified string. Returns a match array or `null`. If the provided
 * regex uses named capture, named backreference properties are included on the match array.
 * Optional `pos` and `sticky` arguments specify the search start position, and whether the match
 * must start at the specified position only. The `lastIndex` property of the provided regex is not
 * used, but is updated for compatibility. Also fixes browser bugs compared to the native
 * `RegExp.prototype.exec` and can be used reliably cross-browser.
 *
 * @memberOf XRegExp
 * @param {String} str String to search.
 * @param {RegExp} regex Regex to search with.
 * @param {Number} [pos=0] Zero-based index at which to start the search.
 * @param {Boolean|String} [sticky=false] Whether the match must start at the specified position
 *   only. The string `'sticky'` is accepted as an alternative to `true`.
 * @returns {Array} Match array with named backreference properties, or `null`.
 * @example
 *
 * // Basic use, with named backreference
 * var match = XRegExp.exec('U+2620', XRegExp('U\\+(?<hex>[0-9A-F]{4})'));
 * match.hex; // -> '2620'
 *
 * // With pos and sticky, in a loop
 * var pos = 2, result = [], match;
 * while (match = XRegExp.exec('<1><2><3><4>5<6>', /<(\d)>/, pos, 'sticky')) {
 *   result.push(match[1]);
 *   pos = match.index + match[0].length;
 * }
 * // result -> ['2', '3', '4']
 */
    self.exec = function(str, regex, pos, sticky) {
        var cacheKey = 'g',
            addY = false,
            match,
            r2;

        addY = hasNativeY && !!(sticky || (regex.sticky && sticky !== false));
        if (addY) {
            cacheKey += 'y';
        }

        regex[REGEX_DATA] = regex[REGEX_DATA] || {};

        // Shares cached copies with `XRegExp.match`/`replace`
        r2 = regex[REGEX_DATA][cacheKey] || (
            regex[REGEX_DATA][cacheKey] = copyRegex(regex, {
                addG: true,
                addY: addY,
                removeY: sticky === false,
                isInternalOnly: true
            })
        );

        r2.lastIndex = pos = pos || 0;

        // Fixed `exec` required for `lastIndex` fix, named backreferences, etc.
        match = fixed.exec.call(r2, str);

        if (sticky && match && match.index !== pos) {
            match = null;
        }

        if (regex.global) {
            regex.lastIndex = match ? r2.lastIndex : 0;
        }

        return match;
    };

/**
 * Executes a provided function once per regex match.
 *
 * @memberOf XRegExp
 * @param {String} str String to search.
 * @param {RegExp} regex Regex to search with.
 * @param {Function} callback Function to execute for each match. Invoked with four arguments:
 *   <li>The match array, with named backreference properties.
 *   <li>The zero-based match index.
 *   <li>The string being traversed.
 *   <li>The regex object being used to traverse the string.
 * @example
 *
 * // Extracts every other digit from a string
 * XRegExp.forEach('1a2345', /\d/, function(match, i) {
 *   if (i % 2) this.push(+match[0]);
 * }, []);
 * // -> [2, 4]
 */
    self.forEach = function(str, regex, callback) {
        var pos = 0,
            i = -1,
            match;

        while ((match = self.exec(str, regex, pos))) {
            // Because `regex` is provided to `callback`, the function could use the deprecated/
            // nonstandard `RegExp.prototype.compile` to mutate the regex. However, since
            // `XRegExp.exec` doesn't use `lastIndex` to set the search position, this can't lead
            // to an infinite loop, at least. Actually, because of the way `XRegExp.exec` caches
            // globalized versions of regexes, mutating the regex will not have any effect on the
            // iteration or matched strings, which is a nice side effect that brings extra safety
            callback(match, ++i, str, regex);

            pos = match.index + (match[0].length || 1);
        }
    };

/**
 * Copies a regex object and adds flag `g`. The copy maintains extended data, is augmented with
 * `XRegExp.prototype` properties, and has a fresh `lastIndex` property (set to zero). Native
 * regexes are not recompiled using XRegExp syntax.
 *
 * @memberOf XRegExp
 * @param {RegExp} regex Regex to globalize.
 * @returns {RegExp} Copy of the provided regex with flag `g` added.
 * @example
 *
 * var globalCopy = XRegExp.globalize(/regex/);
 * globalCopy.global; // -> true
 */
    self.globalize = function(regex) {
        return copyRegex(regex, {addG: true});
    };

/**
 * Installs optional features according to the specified options. Can be undone using
 * {@link #XRegExp.uninstall}.
 *
 * @memberOf XRegExp
 * @param {Object|String} options Options object or string.
 * @example
 *
 * // With an options object
 * XRegExp.install({
 *   // Enables support for astral code points in Unicode addons (implicitly sets flag A)
 *   astral: true,
 *
 *   // Overrides native regex methods with fixed/extended versions that support named
 *   // backreferences and fix numerous cross-browser bugs
 *   natives: true
 * });
 *
 * // With an options string
 * XRegExp.install('astral natives');
 */
    self.install = function(options) {
        options = prepareOptions(options);

        if (!features.astral && options.astral) {
            setAstral(true);
        }

        if (!features.natives && options.natives) {
            setNatives(true);
        }
    };

/**
 * Checks whether an individual optional feature is installed.
 *
 * @memberOf XRegExp
 * @param {String} feature Name of the feature to check. One of:
 *   <li>`natives`
 *   <li>`astral`
 * @returns {Boolean} Whether the feature is installed.
 * @example
 *
 * XRegExp.isInstalled('natives');
 */
    self.isInstalled = function(feature) {
        return !!(features[feature]);
    };

/**
 * Returns `true` if an object is a regex; `false` if it isn't. This works correctly for regexes
 * created in another frame, when `instanceof` and `constructor` checks would fail.
 *
 * @memberOf XRegExp
 * @param {*} value Object to check.
 * @returns {Boolean} Whether the object is a `RegExp` object.
 * @example
 *
 * XRegExp.isRegExp('string'); // -> false
 * XRegExp.isRegExp(/regex/i); // -> true
 * XRegExp.isRegExp(RegExp('^', 'm')); // -> true
 * XRegExp.isRegExp(XRegExp('(?s).')); // -> true
 */
    self.isRegExp = function(value) {
        return toString.call(value) === '[object RegExp]';
        //return isType(value, 'RegExp');
    };

/**
 * Returns the first matched string, or in global mode, an array containing all matched strings.
 * This is essentially a more convenient re-implementation of `String.prototype.match` that gives
 * the result types you actually want (string instead of `exec`-style array in match-first mode,
 * and an empty array instead of `null` when no matches are found in match-all mode). It also lets
 * you override flag g and ignore `lastIndex`, and fixes browser bugs.
 *
 * @memberOf XRegExp
 * @param {String} str String to search.
 * @param {RegExp} regex Regex to search with.
 * @param {String} [scope='one'] Use 'one' to return the first match as a string. Use 'all' to
 *   return an array of all matched strings. If not explicitly specified and `regex` uses flag g,
 *   `scope` is 'all'.
 * @returns {String|Array} In match-first mode: First match as a string, or `null`. In match-all
 *   mode: Array of all matched strings, or an empty array.
 * @example
 *
 * // Match first
 * XRegExp.match('abc', /\w/); // -> 'a'
 * XRegExp.match('abc', /\w/g, 'one'); // -> 'a'
 * XRegExp.match('abc', /x/g, 'one'); // -> null
 *
 * // Match all
 * XRegExp.match('abc', /\w/g); // -> ['a', 'b', 'c']
 * XRegExp.match('abc', /\w/, 'all'); // -> ['a', 'b', 'c']
 * XRegExp.match('abc', /x/, 'all'); // -> []
 */
    self.match = function(str, regex, scope) {
        var global = (regex.global && scope !== 'one') || scope === 'all',
            cacheKey = ((global ? 'g' : '') + (regex.sticky ? 'y' : '')) || 'noGY',
            result,
            r2;

        regex[REGEX_DATA] = regex[REGEX_DATA] || {};

        // Shares cached copies with `XRegExp.exec`/`replace`
        r2 = regex[REGEX_DATA][cacheKey] || (
            regex[REGEX_DATA][cacheKey] = copyRegex(regex, {
                addG: !!global,
                addY: !!regex.sticky,
                removeG: scope === 'one',
                isInternalOnly: true
            })
        );

        result = nativ.match.call(toObject(str), r2);

        if (regex.global) {
            regex.lastIndex = (
                (scope === 'one' && result) ?
                    // Can't use `r2.lastIndex` since `r2` is nonglobal in this case
                    (result.index + result[0].length) : 0
            );
        }

        return global ? (result || []) : (result && result[0]);
    };

/**
 * Retrieves the matches from searching a string using a chain of regexes that successively search
 * within previous matches. The provided `chain` array can contain regexes and objects with `regex`
 * and `backref` properties. When a backreference is specified, the named or numbered backreference
 * is passed forward to the next regex or returned.
 *
 * @memberOf XRegExp
 * @param {String} str String to search.
 * @param {Array} chain Regexes that each search for matches within preceding results.
 * @returns {Array} Matches by the last regex in the chain, or an empty array.
 * @example
 *
 * // Basic usage; matches numbers within <b> tags
 * XRegExp.matchChain('1 <b>2</b> 3 <b>4 a 56</b>', [
 *   XRegExp('(?is)<b>.*?</b>'),
 *   /\d+/
 * ]);
 * // -> ['2', '4', '56']
 *
 * // Passing forward and returning specific backreferences
 * html = '<a href="http://xregexp.com/api/">XRegExp</a>\
 *         <a href="http://www.google.com/">Google</a>';
 * XRegExp.matchChain(html, [
 *   {regex: /<a href="([^"]+)">/i, backref: 1},
 *   {regex: XRegExp('(?i)^https?://(?<domain>[^/?#]+)'), backref: 'domain'}
 * ]);
 * // -> ['xregexp.com', 'www.google.com']
 */
    self.matchChain = function(str, chain) {
        return (function recurseChain(values, level) {
            var item = chain[level].regex ? chain[level] : {regex: chain[level]},
                matches = [],
                addMatch = function(match) {
                    if (item.backref) {
                        /* Safari 4.0.5 (but not 5.0.5+) inappropriately uses sparse arrays to hold
                         * the `undefined`s for backreferences to nonparticipating capturing
                         * groups. In such cases, a `hasOwnProperty` or `in` check on its own would
                         * inappropriately throw the exception, so also check if the backreference
                         * is a number that is within the bounds of the array.
                         */
                        if (!(match.hasOwnProperty(item.backref) || +item.backref < match.length)) {
                            throw new ReferenceError('Backreference to undefined group: ' + item.backref);
                        }

                        matches.push(match[item.backref] || '');
                    } else {
                        matches.push(match[0]);
                    }
                },
                i;

            for (i = 0; i < values.length; ++i) {
                self.forEach(values[i], item.regex, addMatch);
            }

            return ((level === chain.length - 1) || !matches.length) ?
                matches :
                recurseChain(matches, level + 1);
        }([str], 0));
    };

/**
 * Returns a new string with one or all matches of a pattern replaced. The pattern can be a string
 * or regex, and the replacement can be a string or a function to be called for each match. To
 * perform a global search and replace, use the optional `scope` argument or include flag g if using
 * a regex. Replacement strings can use `${n}` for named and numbered backreferences. Replacement
 * functions can use named backreferences via `arguments[0].name`. Also fixes browser bugs compared
 * to the native `String.prototype.replace` and can be used reliably cross-browser.
 *
 * @memberOf XRegExp
 * @param {String} str String to search.
 * @param {RegExp|String} search Search pattern to be replaced.
 * @param {String|Function} replacement Replacement string or a function invoked to create it.
 *   Replacement strings can include special replacement syntax:
 *     <li>$$ - Inserts a literal $ character.
 *     <li>$&, $0 - Inserts the matched substring.
 *     <li>$` - Inserts the string that precedes the matched substring (left context).
 *     <li>$' - Inserts the string that follows the matched substring (right context).
 *     <li>$n, $nn - Where n/nn are digits referencing an existent capturing group, inserts
 *       backreference n/nn.
 *     <li>${n} - Where n is a name or any number of digits that reference an existent capturing
 *       group, inserts backreference n.
 *   Replacement functions are invoked with three or more arguments:
 *     <li>The matched substring (corresponds to $& above). Named backreferences are accessible as
 *       properties of this first argument.
 *     <li>0..n arguments, one for each backreference (corresponding to $1, $2, etc. above).
 *     <li>The zero-based index of the match within the total search string.
 *     <li>The total string being searched.
 * @param {String} [scope='one'] Use 'one' to replace the first match only, or 'all'. If not
 *   explicitly specified and using a regex with flag g, `scope` is 'all'.
 * @returns {String} New string with one or all matches replaced.
 * @example
 *
 * // Regex search, using named backreferences in replacement string
 * var name = XRegExp('(?<first>\\w+) (?<last>\\w+)');
 * XRegExp.replace('John Smith', name, '${last}, ${first}');
 * // -> 'Smith, John'
 *
 * // Regex search, using named backreferences in replacement function
 * XRegExp.replace('John Smith', name, function(match) {
 *   return match.last + ', ' + match.first;
 * });
 * // -> 'Smith, John'
 *
 * // String search, with replace-all
 * XRegExp.replace('RegExp builds RegExps', 'RegExp', 'XRegExp', 'all');
 * // -> 'XRegExp builds XRegExps'
 */
    self.replace = function(str, search, replacement, scope) {
        var isRegex = self.isRegExp(search),
            global = (search.global && scope !== 'one') || scope === 'all',
            cacheKey = ((global ? 'g' : '') + (search.sticky ? 'y' : '')) || 'noGY',
            s2 = search,
            result;

        if (isRegex) {
            search[REGEX_DATA] = search[REGEX_DATA] || {};

            // Shares cached copies with `XRegExp.exec`/`match`. Since a copy is used, `search`'s
            // `lastIndex` isn't updated *during* replacement iterations
            s2 = search[REGEX_DATA][cacheKey] || (
                search[REGEX_DATA][cacheKey] = copyRegex(search, {
                    addG: !!global,
                    addY: !!search.sticky,
                    removeG: scope === 'one',
                    isInternalOnly: true
                })
            );
        } else if (global) {
            s2 = new RegExp(self.escape(String(search)), 'g');
        }

        // Fixed `replace` required for named backreferences, etc.
        result = fixed.replace.call(toObject(str), s2, replacement);

        if (isRegex && search.global) {
            // Fixes IE, Safari bug (last tested IE 9, Safari 5.1)
            search.lastIndex = 0;
        }

        return result;
    };

/**
 * Performs batch processing of string replacements. Used like {@link #XRegExp.replace}, but
 * accepts an array of replacement details. Later replacements operate on the output of earlier
 * replacements. Replacement details are accepted as an array with a regex or string to search for,
 * the replacement string or function, and an optional scope of 'one' or 'all'. Uses the XRegExp
 * replacement text syntax, which supports named backreference properties via `${name}`.
 *
 * @memberOf XRegExp
 * @param {String} str String to search.
 * @param {Array} replacements Array of replacement detail arrays.
 * @returns {String} New string with all replacements.
 * @example
 *
 * str = XRegExp.replaceEach(str, [
 *   [XRegExp('(?<name>a)'), 'z${name}'],
 *   [/b/gi, 'y'],
 *   [/c/g, 'x', 'one'], // scope 'one' overrides /g
 *   [/d/, 'w', 'all'],  // scope 'all' overrides lack of /g
 *   ['e', 'v', 'all'],  // scope 'all' allows replace-all for strings
 *   [/f/g, function($0) {
 *     return $0.toUpperCase();
 *   }]
 * ]);
 */
    self.replaceEach = function(str, replacements) {
        var i, r;

        for (i = 0; i < replacements.length; ++i) {
            r = replacements[i];
            str = self.replace(str, r[0], r[1], r[2]);
        }

        return str;
    };

/**
 * Splits a string into an array of strings using a regex or string separator. Matches of the
 * separator are not included in the result array. However, if `separator` is a regex that contains
 * capturing groups, backreferences are spliced into the result each time `separator` is matched.
 * Fixes browser bugs compared to the native `String.prototype.split` and can be used reliably
 * cross-browser.
 *
 * @memberOf XRegExp
 * @param {String} str String to split.
 * @param {RegExp|String} separator Regex or string to use for separating the string.
 * @param {Number} [limit] Maximum number of items to include in the result array.
 * @returns {Array} Array of substrings.
 * @example
 *
 * // Basic use
 * XRegExp.split('a b c', ' ');
 * // -> ['a', 'b', 'c']
 *
 * // With limit
 * XRegExp.split('a b c', ' ', 2);
 * // -> ['a', 'b']
 *
 * // Backreferences in result array
 * XRegExp.split('..word1..', /([a-z]+)(\d+)/i);
 * // -> ['..', 'word', '1', '..']
 */
    self.split = function(str, separator, limit) {
        return fixed.split.call(toObject(str), separator, limit);
    };

/**
 * Executes a regex search in a specified string. Returns `true` or `false`. Optional `pos` and
 * `sticky` arguments specify the search start position, and whether the match must start at the
 * specified position only. The `lastIndex` property of the provided regex is not used, but is
 * updated for compatibility. Also fixes browser bugs compared to the native
 * `RegExp.prototype.test` and can be used reliably cross-browser.
 *
 * @memberOf XRegExp
 * @param {String} str String to search.
 * @param {RegExp} regex Regex to search with.
 * @param {Number} [pos=0] Zero-based index at which to start the search.
 * @param {Boolean|String} [sticky=false] Whether the match must start at the specified position
 *   only. The string `'sticky'` is accepted as an alternative to `true`.
 * @returns {Boolean} Whether the regex matched the provided value.
 * @example
 *
 * // Basic use
 * XRegExp.test('abc', /c/); // -> true
 *
 * // With pos and sticky
 * XRegExp.test('abc', /c/, 0, 'sticky'); // -> false
 */
    self.test = function(str, regex, pos, sticky) {
        // Do this the easy way :-)
        return !!self.exec(str, regex, pos, sticky);
    };

/**
 * Uninstalls optional features according to the specified options. All optional features start out
 * uninstalled, so this is used to undo the actions of {@link #XRegExp.install}.
 *
 * @memberOf XRegExp
 * @param {Object|String} options Options object or string.
 * @example
 *
 * // With an options object
 * XRegExp.uninstall({
 *   // Disables support for astral code points in Unicode addons
 *   astral: true,
 *
 *   // Restores native regex methods
 *   natives: true
 * });
 *
 * // With an options string
 * XRegExp.uninstall('astral natives');
 */
    self.uninstall = function(options) {
        options = prepareOptions(options);

        if (features.astral && options.astral) {
            setAstral(false);
        }

        if (features.natives && options.natives) {
            setNatives(false);
        }
    };

/**
 * Returns an XRegExp object that is the union of the given patterns. Patterns can be provided as
 * regex objects or strings. Metacharacters are escaped in patterns provided as strings.
 * Backreferences in provided regex objects are automatically renumbered to work correctly within
 * the larger combined pattern. Native flags used by provided regexes are ignored in favor of the
 * `flags` argument.
 *
 * @memberOf XRegExp
 * @param {Array} patterns Regexes and strings to combine.
 * @param {String} [flags] Any combination of XRegExp flags.
 * @returns {RegExp} Union of the provided regexes and strings.
 * @example
 *
 * XRegExp.union(['a+b*c', /(dogs)\1/, /(cats)\1/], 'i');
 * // -> /a\+b\*c|(dogs)\1|(cats)\2/i
 */
    self.union = function(patterns, flags) {
        var parts = /(\()(?!\?)|\\([1-9]\d*)|\\[\s\S]|\[(?:[^\\\]]|\\[\s\S])*]/g,
            output = [],
            numCaptures = 0,
            numPriorCaptures,
            captureNames,
            pattern,
            rewrite = function(match, paren, backref) {
                var name = captureNames[numCaptures - numPriorCaptures];

                // Capturing group
                if (paren) {
                    ++numCaptures;
                    // If the current capture has a name, preserve the name
                    if (name) {
                        return '(?<' + name + '>';
                    }
                // Backreference
                } else if (backref) {
                    // Rewrite the backreference
                    return '\\' + (+backref + numPriorCaptures);
                }

                return match;
            },
            i;

        if (!(isType(patterns, 'Array') && patterns.length)) {
            throw new TypeError('Must provide a nonempty array of patterns to merge');
        }

        for (i = 0; i < patterns.length; ++i) {
            pattern = patterns[i];

            if (self.isRegExp(pattern)) {
                numPriorCaptures = numCaptures;
                captureNames = (pattern[REGEX_DATA] && pattern[REGEX_DATA].captureNames) || [];

                // Rewrite backreferences. Passing to XRegExp dies on octals and ensures patterns
                // are independently valid; helps keep this simple. Named captures are put back
                output.push(nativ.replace.call(self(pattern.source).source, parts, rewrite));
            } else {
                output.push(self.escape(pattern));
            }
        }

        return self(output.join('|'), flags);
    };

/* ==============================
 * Fixed/extended native methods
 * ============================== */

/**
 * Adds named capture support (with backreferences returned as `result.name`), and fixes browser
 * bugs in the native `RegExp.prototype.exec`. Calling `XRegExp.install('natives')` uses this to
 * override the native method. Use via `XRegExp.exec` without overriding natives.
 *
 * @private
 * @param {String} str String to search.
 * @returns {Array} Match array with named backreference properties, or `null`.
 */
    fixed.exec = function(str) {
        var origLastIndex = this.lastIndex,
            match = nativ.exec.apply(this, arguments),
            name,
            r2,
            i;

        if (match) {
            // Fix browsers whose `exec` methods don't return `undefined` for nonparticipating
            // capturing groups. This fixes IE 5.5-8, but not IE 9's quirks mode or emulation of
            // older IEs. IE 9 in standards mode follows the spec
            if (!correctExecNpcg && match.length > 1 && indexOf(match, '') > -1) {
                r2 = copyRegex(this, {
                    removeG: true,
                    isInternalOnly: true
                });
                // Using `str.slice(match.index)` rather than `match[0]` in case lookahead allowed
                // matching due to characters outside the match
                nativ.replace.call(String(str).slice(match.index), r2, function() {
                    var len = arguments.length, i;
                    // Skip index 0 and the last 2
                    for (i = 1; i < len - 2; ++i) {
                        if (arguments[i] === undefined) {
                            match[i] = undefined;
                        }
                    }
                });
            }

            // Attach named capture properties
            if (this[REGEX_DATA] && this[REGEX_DATA].captureNames) {
                // Skip index 0
                for (i = 1; i < match.length; ++i) {
                    name = this[REGEX_DATA].captureNames[i - 1];
                    if (name) {
                        match[name] = match[i];
                    }
                }
            }

            // Fix browsers that increment `lastIndex` after zero-length matches
            if (this.global && !match[0].length && (this.lastIndex > match.index)) {
                this.lastIndex = match.index;
            }
        }

        if (!this.global) {
            // Fixes IE, Opera bug (last tested IE 9, Opera 11.6)
            this.lastIndex = origLastIndex;
        }

        return match;
    };

/**
 * Fixes browser bugs in the native `RegExp.prototype.test`. Calling `XRegExp.install('natives')`
 * uses this to override the native method.
 *
 * @private
 * @param {String} str String to search.
 * @returns {Boolean} Whether the regex matched the provided value.
 */
    fixed.test = function(str) {
        // Do this the easy way :-)
        return !!fixed.exec.call(this, str);
    };

/**
 * Adds named capture support (with backreferences returned as `result.name`), and fixes browser
 * bugs in the native `String.prototype.match`. Calling `XRegExp.install('natives')` uses this to
 * override the native method.
 *
 * @private
 * @param {RegExp|*} regex Regex to search with. If not a regex object, it is passed to `RegExp`.
 * @returns {Array} If `regex` uses flag g, an array of match strings or `null`. Without flag g,
 *   the result of calling `regex.exec(this)`.
 */
    fixed.match = function(regex) {
        var result;

        if (!self.isRegExp(regex)) {
            // Use the native `RegExp` rather than `XRegExp`
            regex = new RegExp(regex);
        } else if (regex.global) {
            result = nativ.match.apply(this, arguments);
            // Fixes IE bug
            regex.lastIndex = 0;

            return result;
        }

        return fixed.exec.call(regex, toObject(this));
    };

/**
 * Adds support for `${n}` tokens for named and numbered backreferences in replacement text, and
 * provides named backreferences to replacement functions as `arguments[0].name`. Also fixes browser
 * bugs in replacement text syntax when performing a replacement using a nonregex search value, and
 * the value of a replacement regex's `lastIndex` property during replacement iterations and upon
 * completion. Calling `XRegExp.install('natives')` uses this to override the native method. Note
 * that this doesn't support SpiderMonkey's proprietary third (`flags`) argument. Use via
 * `XRegExp.replace` without overriding natives.
 *
 * @private
 * @param {RegExp|String} search Search pattern to be replaced.
 * @param {String|Function} replacement Replacement string or a function invoked to create it.
 * @returns {String} New string with one or all matches replaced.
 */
    fixed.replace = function(search, replacement) {
        var isRegex = self.isRegExp(search),
            origLastIndex,
            captureNames,
            result;

        if (isRegex) {
            if (search[REGEX_DATA]) {
                captureNames = search[REGEX_DATA].captureNames;
            }
            // Only needed if `search` is nonglobal
            origLastIndex = search.lastIndex;
        } else {
            search += ''; // Type-convert
        }

        // Don't use `typeof`; some older browsers return 'function' for regex objects
        if (isType(replacement, 'Function')) {
            // Stringifying `this` fixes a bug in IE < 9 where the last argument in replacement
            // functions isn't type-converted to a string
            result = nativ.replace.call(String(this), search, function() {
                var args = arguments, i;
                if (captureNames) {
                    // Change the `arguments[0]` string primitive to a `String` object that can
                    // store properties. This really does need to use `String` as a constructor
                    args[0] = new String(args[0]);
                    // Store named backreferences on the first argument
                    for (i = 0; i < captureNames.length; ++i) {
                        if (captureNames[i]) {
                            args[0][captureNames[i]] = args[i + 1];
                        }
                    }
                }
                // Update `lastIndex` before calling `replacement`. Fixes IE, Chrome, Firefox,
                // Safari bug (last tested IE 9, Chrome 17, Firefox 11, Safari 5.1)
                if (isRegex && search.global) {
                    search.lastIndex = args[args.length - 2] + args[0].length;
                }
                // ES6 specs the context for replacement functions as `undefined`
                return replacement.apply(undefined, args);
            });
        } else {
            // Ensure that the last value of `args` will be a string when given nonstring `this`,
            // while still throwing on null or undefined context
            result = nativ.replace.call(this == null ? this : String(this), search, function() {
                // Keep this function's `arguments` available through closure
                var args = arguments;
                return nativ.replace.call(String(replacement), replacementToken, function($0, $1, $2) {
                    var n;
                    // Named or numbered backreference with curly braces
                    if ($1) {
                        // XRegExp behavior for `${n}`:
                        // 1. Backreference to numbered capture, if `n` is an integer. Use `0` for
                        //    for the entire match. Any number of leading zeros may be used.
                        // 2. Backreference to named capture `n`, if it exists and is not an
                        //    integer overridden by numbered capture. In practice, this does not
                        //    overlap with numbered capture since XRegExp does not allow named
                        //    capture to use a bare integer as the name.
                        // 3. If the name or number does not refer to an existing capturing group,
                        //    it's an error.
                        n = +$1; // Type-convert; drop leading zeros
                        if (n <= args.length - 3) {
                            return args[n] || '';
                        }
                        // Groups with the same name is an error, else would need `lastIndexOf`
                        n = captureNames ? indexOf(captureNames, $1) : -1;
                        if (n < 0) {
                            throw new SyntaxError('Backreference to undefined group ' + $0);
                        }
                        return args[n + 1] || '';
                    }
                    // Else, special variable or numbered backreference without curly braces
                    if ($2 === '$') { // $$
                        return '$';
                    }
                    if ($2 === '&' || +$2 === 0) { // $&, $0 (not followed by 1-9), $00
                        return args[0];
                    }
                    if ($2 === '`') { // $` (left context)
                        return args[args.length - 1].slice(0, args[args.length - 2]);
                    }
                    if ($2 === "'") { // $' (right context)
                        return args[args.length - 1].slice(args[args.length - 2] + args[0].length);
                    }
                    // Else, numbered backreference without curly braces
                    $2 = +$2; // Type-convert; drop leading zero
                    // XRegExp behavior for `$n` and `$nn`:
                    // - Backrefs end after 1 or 2 digits. Use `${..}` for more digits.
                    // - `$1` is an error if no capturing groups.
                    // - `$10` is an error if less than 10 capturing groups. Use `${1}0` instead.
                    // - `$01` is `$1` if at least one capturing group, else it's an error.
                    // - `$0` (not followed by 1-9) and `$00` are the entire match.
                    // Native behavior, for comparison:
                    // - Backrefs end after 1 or 2 digits. Cannot reference capturing group 100+.
                    // - `$1` is a literal `$1` if no capturing groups.
                    // - `$10` is `$1` followed by a literal `0` if less than 10 capturing groups.
                    // - `$01` is `$1` if at least one capturing group, else it's a literal `$01`.
                    // - `$0` is a literal `$0`.
                    if (!isNaN($2)) {
                        if ($2 > args.length - 3) {
                            throw new SyntaxError('Backreference to undefined group ' + $0);
                        }
                        return args[$2] || '';
                    }
                    // `$` followed by an unsupported char is an error, unlike native JS
                    throw new SyntaxError('Invalid token ' + $0);
                });
            });
        }

        if (isRegex) {
            if (search.global) {
                // Fixes IE, Safari bug (last tested IE 9, Safari 5.1)
                search.lastIndex = 0;
            } else {
                // Fixes IE, Opera bug (last tested IE 9, Opera 11.6)
                search.lastIndex = origLastIndex;
            }
        }

        return result;
    };

/**
 * Fixes browser bugs in the native `String.prototype.split`. Calling `XRegExp.install('natives')`
 * uses this to override the native method. Use via `XRegExp.split` without overriding natives.
 *
 * @private
 * @param {RegExp|String} separator Regex or string to use for separating the string.
 * @param {Number} [limit] Maximum number of items to include in the result array.
 * @returns {Array} Array of substrings.
 */
    fixed.split = function(separator, limit) {
        if (!self.isRegExp(separator)) {
            // Browsers handle nonregex split correctly, so use the faster native method
            return nativ.split.apply(this, arguments);
        }

        var str = String(this),
            output = [],
            origLastIndex = separator.lastIndex,
            lastLastIndex = 0,
            lastLength;

        // Values for `limit`, per the spec:
        // If undefined: pow(2,32) - 1
        // If 0, Infinity, or NaN: 0
        // If positive number: limit = floor(limit); if (limit >= pow(2,32)) limit -= pow(2,32);
        // If negative number: pow(2,32) - floor(abs(limit))
        // If other: Type-convert, then use the above rules
        // This line fails in very strange ways for some values of `limit` in Opera 10.5-10.63,
        // unless Opera Dragonfly is open (go figure). It works in at least Opera 9.5-10.1 and 11+
        limit = (limit === undefined ? -1 : limit) >>> 0;

        self.forEach(str, separator, function(match) {
            // This condition is not the same as `if (match[0].length)`
            if ((match.index + match[0].length) > lastLastIndex) {
                output.push(str.slice(lastLastIndex, match.index));
                if (match.length > 1 && match.index < str.length) {
                    Array.prototype.push.apply(output, match.slice(1));
                }
                lastLength = match[0].length;
                lastLastIndex = match.index + lastLength;
            }
        });

        if (lastLastIndex === str.length) {
            if (!nativ.test.call(separator, '') || lastLength) {
                output.push('');
            }
        } else {
            output.push(str.slice(lastLastIndex));
        }

        separator.lastIndex = origLastIndex;
        return output.length > limit ? output.slice(0, limit) : output;
    };

/* ==============================
 * Built-in syntax/flag tokens
 * ============================== */

    add = self.addToken;

/*
 * Letter escapes that natively match literal characters: `\a`, `\A`, etc. These should be
 * SyntaxErrors but are allowed in web reality. XRegExp makes them errors for cross-browser
 * consistency and to reserve their syntax, but lets them be superseded by addons.
 */
    add(
        /\\([ABCE-RTUVXYZaeg-mopqyz]|c(?![A-Za-z])|u(?![\dA-Fa-f]{4}|{[\dA-Fa-f]+})|x(?![\dA-Fa-f]{2}))/,
        function(match, scope) {
            // \B is allowed in default scope only
            if (match[1] === 'B' && scope === defaultScope) {
                return match[0];
            }
            throw new SyntaxError('Invalid escape ' + match[0]);
        },
        {
            scope: 'all',
            leadChar: '\\'
        }
    );

/*
 * Unicode code point escape with curly braces: `\u{N..}`. `N..` is any one or more digit
 * hexadecimal number from 0-10FFFF, and can include leading zeros. Requires the native ES6 `u` flag
 * to support code points greater than U+FFFF. Avoids converting code points above U+FFFF to
 * surrogate pairs (which could be done without flag `u`), since that could lead to broken behavior
 * if you follow a `\u{N..}` token that references a code point above U+FFFF with a quantifier, or
 * if you use the same in a character class.
 */
    add(
        /\\u{([\dA-Fa-f]+)}/,
        function(match, scope, flags) {
            var code = dec(match[1]);
            if (code > 0x10FFFF) {
                throw new SyntaxError('Invalid Unicode code point ' + match[0]);
            }
            if (code <= 0xFFFF) {
                // Converting to \uNNNN avoids needing to escape the literal character and keep it
                // separate from preceding tokens
                return '\\u' + pad4(hex(code));
            }
            // If `code` is between 0xFFFF and 0x10FFFF, require and defer to native handling
            if (hasNativeU && flags.indexOf('u') > -1) {
                return match[0];
            }
            throw new SyntaxError('Cannot use Unicode code point above \\u{FFFF} without flag u');
        },
        {
            scope: 'all',
            leadChar: '\\'
        }
    );

/*
 * Empty character class: `[]` or `[^]`. This fixes a critical cross-browser syntax inconsistency.
 * Unless this is standardized (per the ES spec), regex syntax can't be accurately parsed because
 * character class endings can't be determined.
 */
    add(
        /\[(\^?)]/,
        function(match) {
            // For cross-browser compatibility with ES3, convert [] to \b\B and [^] to [\s\S].
            // (?!) should work like \b\B, but is unreliable in some versions of Firefox
            return match[1] ? '[\\s\\S]' : '\\b\\B';
        },
        {leadChar: '['}
    );

/*
 * Comment pattern: `(?# )`. Inline comments are an alternative to the line comments allowed in
 * free-spacing mode (flag x).
 */
    add(
        /\(\?#[^)]*\)/,
        function(match, scope, flags) {
            // Keep tokens separated unless the following token is a quantifier
            return isQuantifierNext(match.input, match.index + match[0].length, flags) ?
                '' : '(?:)';
        },
        {leadChar: '('}
    );

/*
 * Whitespace and line comments, in free-spacing mode (aka extended mode, flag x) only.
 */
    add(
        /\s+|#.*/,
        function(match, scope, flags) {
            // Keep tokens separated unless the following token is a quantifier
            return isQuantifierNext(match.input, match.index + match[0].length, flags) ?
                '' : '(?:)';
        },
        {flag: 'x'}
    );

/*
 * Dot, in dotall mode (aka singleline mode, flag s) only.
 */
    add(
        /\./,
        function() {
            return '[\\s\\S]';
        },
        {
            flag: 's',
            leadChar: '.'
        }
    );

/*
 * Named backreference: `\k<name>`. Backreference names can use the characters A-Z, a-z, 0-9, _,
 * and $ only. Also allows numbered backreferences as `\k<n>`.
 */
    add(
        /\\k<([\w$]+)>/,
        function(match) {
            // Groups with the same name is an error, else would need `lastIndexOf`
            var index = isNaN(match[1]) ? (indexOf(this.captureNames, match[1]) + 1) : +match[1],
                endIndex = match.index + match[0].length;
            if (!index || index > this.captureNames.length) {
                throw new SyntaxError('Backreference to undefined group ' + match[0]);
            }
            // Keep backreferences separate from subsequent literal numbers
            return '\\' + index + (
                endIndex === match.input.length || isNaN(match.input.charAt(endIndex)) ?
                    '' : '(?:)'
            );
        },
        {leadChar: '\\'}
    );

/*
 * Numbered backreference or octal, plus any following digits: `\0`, `\11`, etc. Octals except `\0`
 * not followed by 0-9 and backreferences to unopened capture groups throw an error. Other matches
 * are returned unaltered. IE < 9 doesn't support backreferences above `\99` in regex syntax.
 */
    add(
        /\\(\d+)/,
        function(match, scope) {
            if (
                !(
                    scope === defaultScope &&
                    /^[1-9]/.test(match[1]) &&
                    +match[1] <= this.captureNames.length
                ) &&
                match[1] !== '0'
            ) {
                throw new SyntaxError('Cannot use octal escape or backreference to undefined group ' +
                    match[0]);
            }
            return match[0];
        },
        {
            scope: 'all',
            leadChar: '\\'
        }
    );

/*
 * Named capturing group; match the opening delimiter only: `(?<name>`. Capture names can use the
 * characters A-Z, a-z, 0-9, _, and $ only. Names can't be integers. Supports Python-style
 * `(?P<name>` as an alternate syntax to avoid issues in some older versions of Opera which natively
 * supported the Python-style syntax. Otherwise, XRegExp might treat numbered backreferences to
 * Python-style named capture as octals.
 */
    add(
        /\(\?P?<([\w$]+)>/,
        function(match) {
            // Disallow bare integers as names because named backreferences are added to match
            // arrays and therefore numeric properties may lead to incorrect lookups
            if (!isNaN(match[1])) {
                throw new SyntaxError('Cannot use integer as capture name ' + match[0]);
            }
            if (match[1] === 'length' || match[1] === '__proto__') {
                throw new SyntaxError('Cannot use reserved word as capture name ' + match[0]);
            }
            if (indexOf(this.captureNames, match[1]) > -1) {
                throw new SyntaxError('Cannot use same name for multiple groups ' + match[0]);
            }
            this.captureNames.push(match[1]);
            this.hasNamedCapture = true;
            return '(';
        },
        {leadChar: '('}
    );

/*
 * Capturing group; match the opening parenthesis only. Required for support of named capturing
 * groups. Also adds explicit capture mode (flag n).
 */
    add(
        /\((?!\?)/,
        function(match, scope, flags) {
            if (flags.indexOf('n') > -1) {
                return '(?:';
            }
            this.captureNames.push(null);
            return '(';
        },
        {
            optionalFlags: 'n',
            leadChar: '('
        }
    );

/* ==============================
 * Expose XRegExp
 * ============================== */

    return self;

}());

/*!
 * XRegExp.build 3.0.0
 * <http://xregexp.com/>
 * Steven Levithan (c) 2012-2015 MIT License
 * Inspired by Lea Verou's RegExp.create <http://lea.verou.me/>
 */

(function(XRegExp) {
    'use strict';

    var REGEX_DATA = 'xregexp',
        subParts = /(\()(?!\?)|\\([1-9]\d*)|\\[\s\S]|\[(?:[^\\\]]|\\[\s\S])*]/g,
        parts = XRegExp.union([/\({{([\w$]+)}}\)|{{([\w$]+)}}/, subParts], 'g');

/**
 * Strips a leading `^` and trailing unescaped `$`, if both are present.
 *
 * @private
 * @param {String} pattern Pattern to process.
 * @returns {String} Pattern with edge anchors removed.
 */
    function deanchor(pattern) {
        var leadingAnchor = /^\^/,
            trailingAnchor = /\$$/;

        // Ensure that the trailing `$` isn't escaped
        if (leadingAnchor.test(pattern) && trailingAnchor.test(pattern.replace(/\\[\s\S]/g, ''))) {
            return pattern.replace(leadingAnchor, '').replace(trailingAnchor, '');
        }

        return pattern;
    }

/**
 * Converts the provided value to an XRegExp. Native RegExp flags are not preserved.
 *
 * @private
 * @param {String|RegExp} value Value to convert.
 * @returns {RegExp} XRegExp object with XRegExp syntax applied.
 */
    function asXRegExp(value) {
        return XRegExp.isRegExp(value) ?
            (value[REGEX_DATA] && value[REGEX_DATA].captureNames ?
                // Don't recompile, to preserve capture names
                value :
                // Recompile as XRegExp
                XRegExp(value.source)
            ) :
            // Compile string as XRegExp
            XRegExp(value);
    }

/**
 * Builds regexes using named subpatterns, for readability and pattern reuse. Backreferences in the
 * outer pattern and provided subpatterns are automatically renumbered to work correctly. Native
 * flags used by provided subpatterns are ignored in favor of the `flags` argument.
 *
 * @memberOf XRegExp
 * @param {String} pattern XRegExp pattern using `{{name}}` for embedded subpatterns. Allows
 *   `({{name}})` as shorthand for `(?<name>{{name}})`. Patterns cannot be embedded within
 *   character classes.
 * @param {Object} subs Lookup object for named subpatterns. Values can be strings or regexes. A
 *   leading `^` and trailing unescaped `$` are stripped from subpatterns, if both are present.
 * @param {String} [flags] Any combination of XRegExp flags.
 * @returns {RegExp} Regex with interpolated subpatterns.
 * @example
 *
 * var time = XRegExp.build('(?x)^ {{hours}} ({{minutes}}) $', {
 *   hours: XRegExp.build('{{h12}} : | {{h24}}', {
 *     h12: /1[0-2]|0?[1-9]/,
 *     h24: /2[0-3]|[01][0-9]/
 *   }, 'x'),
 *   minutes: /^[0-5][0-9]$/
 * });
 * time.test('10:59'); // -> true
 * XRegExp.exec('10:59', time).minutes; // -> '59'
 */
    XRegExp.build = function(pattern, subs, flags) {
        var inlineFlags = /^\(\?([\w$]+)\)/.exec(pattern),
            data = {},
            numCaps = 0, // 'Caps' is short for captures
            numPriorCaps,
            numOuterCaps = 0,
            outerCapsMap = [0],
            outerCapNames,
            sub,
            p;

        // Add flags within a leading mode modifier to the overall pattern's flags
        if (inlineFlags) {
            flags = flags || '';
            inlineFlags[1].replace(/./g, function(flag) {
                // Don't add duplicates
                flags += (flags.indexOf(flag) > -1 ? '' : flag);
            });
        }

        for (p in subs) {
            if (subs.hasOwnProperty(p)) {
                // Passing to XRegExp enables extended syntax and ensures independent validity,
                // lest an unescaped `(`, `)`, `[`, or trailing `\` breaks the `(?:)` wrapper. For
                // subpatterns provided as native regexes, it dies on octals and adds the property
                // used to hold extended regex instance data, for simplicity
                sub = asXRegExp(subs[p]);
                data[p] = {
                    // Deanchoring allows embedding independently useful anchored regexes. If you
                    // really need to keep your anchors, double them (i.e., `^^...$$`)
                    pattern: deanchor(sub.source),
                    names: sub[REGEX_DATA].captureNames || []
                };
            }
        }

        // Passing to XRegExp dies on octals and ensures the outer pattern is independently valid;
        // helps keep this simple. Named captures will be put back
        pattern = asXRegExp(pattern);
        outerCapNames = pattern[REGEX_DATA].captureNames || [];
        pattern = pattern.source.replace(parts, function($0, $1, $2, $3, $4) {
            var subName = $1 || $2, capName, intro;
            // Named subpattern
            if (subName) {
                if (!data.hasOwnProperty(subName)) {
                    throw new ReferenceError('Undefined property ' + $0);
                }
                // Named subpattern was wrapped in a capturing group
                if ($1) {
                    capName = outerCapNames[numOuterCaps];
                    outerCapsMap[++numOuterCaps] = ++numCaps;
                    // If it's a named group, preserve the name. Otherwise, use the subpattern name
                    // as the capture name
                    intro = '(?<' + (capName || subName) + '>';
                } else {
                    intro = '(?:';
                }
                numPriorCaps = numCaps;
                return intro + data[subName].pattern.replace(subParts, function(match, paren, backref) {
                    // Capturing group
                    if (paren) {
                        capName = data[subName].names[numCaps - numPriorCaps];
                        ++numCaps;
                        // If the current capture has a name, preserve the name
                        if (capName) {
                            return '(?<' + capName + '>';
                        }
                    // Backreference
                    } else if (backref) {
                        // Rewrite the backreference
                        return '\\' + (+backref + numPriorCaps);
                    }
                    return match;
                }) + ')';
            }
            // Capturing group
            if ($3) {
                capName = outerCapNames[numOuterCaps];
                outerCapsMap[++numOuterCaps] = ++numCaps;
                // If the current capture has a name, preserve the name
                if (capName) {
                    return '(?<' + capName + '>';
                }
            // Backreference
            } else if ($4) {
                // Rewrite the backreference
                return '\\' + outerCapsMap[+$4];
            }
            return $0;
        });

        return XRegExp(pattern, flags);
    };

}(XRegExp));

/*!
 * XRegExp.matchRecursive 3.0.0
 * <http://xregexp.com/>
 * Steven Levithan (c) 2009-2015 MIT License
 */

(function(XRegExp) {
    'use strict';

/**
 * Returns a match detail object composed of the provided values.
 *
 * @private
 */
    function row(name, value, start, end) {
        return {
            name: name,
            value: value,
            start: start,
            end: end
        };
    }

/**
 * Returns an array of match strings between outermost left and right delimiters, or an array of
 * objects with detailed match parts and position data. An error is thrown if delimiters are
 * unbalanced within the data.
 *
 * @memberOf XRegExp
 * @param {String} str String to search.
 * @param {String} left Left delimiter as an XRegExp pattern.
 * @param {String} right Right delimiter as an XRegExp pattern.
 * @param {String} [flags] Any native or XRegExp flags, used for the left and right delimiters.
 * @param {Object} [options] Lets you specify `valueNames` and `escapeChar` options.
 * @returns {Array} Array of matches, or an empty array.
 * @example
 *
 * // Basic usage
 * var str = '(t((e))s)t()(ing)';
 * XRegExp.matchRecursive(str, '\\(', '\\)', 'g');
 * // -> ['t((e))s', '', 'ing']
 *
 * // Extended information mode with valueNames
 * str = 'Here is <div> <div>an</div></div> example';
 * XRegExp.matchRecursive(str, '<div\\s*>', '</div>', 'gi', {
 *   valueNames: ['between', 'left', 'match', 'right']
 * });
 * // -> [
 * // {name: 'between', value: 'Here is ',       start: 0,  end: 8},
 * // {name: 'left',    value: '<div>',          start: 8,  end: 13},
 * // {name: 'match',   value: ' <div>an</div>', start: 13, end: 27},
 * // {name: 'right',   value: '</div>',         start: 27, end: 33},
 * // {name: 'between', value: ' example',       start: 33, end: 41}
 * // ]
 *
 * // Omitting unneeded parts with null valueNames, and using escapeChar
 * str = '...{1}\\{{function(x,y){return y+x;}}';
 * XRegExp.matchRecursive(str, '{', '}', 'g', {
 *   valueNames: ['literal', null, 'value', null],
 *   escapeChar: '\\'
 * });
 * // -> [
 * // {name: 'literal', value: '...', start: 0, end: 3},
 * // {name: 'value',   value: '1',   start: 4, end: 5},
 * // {name: 'literal', value: '\\{', start: 6, end: 8},
 * // {name: 'value',   value: 'function(x,y){return y+x;}', start: 9, end: 35}
 * // ]
 *
 * // Sticky mode via flag y
 * str = '<1><<<2>>><3>4<5>';
 * XRegExp.matchRecursive(str, '<', '>', 'gy');
 * // -> ['1', '<<2>>', '3']
 */
    XRegExp.matchRecursive = function(str, left, right, flags, options) {
        flags = flags || '';
        options = options || {};
        var global = flags.indexOf('g') > -1,
            sticky = flags.indexOf('y') > -1,
            // Flag `y` is controlled internally
            basicFlags = flags.replace(/y/g, ''),
            escapeChar = options.escapeChar,
            vN = options.valueNames,
            output = [],
            openTokens = 0,
            delimStart = 0,
            delimEnd = 0,
            lastOuterEnd = 0,
            outerStart,
            innerStart,
            leftMatch,
            rightMatch,
            esc;
        left = XRegExp(left, basicFlags);
        right = XRegExp(right, basicFlags);

        if (escapeChar) {
            if (escapeChar.length > 1) {
                throw new Error('Cannot use more than one escape character');
            }
            escapeChar = XRegExp.escape(escapeChar);
            // Using `XRegExp.union` safely rewrites backreferences in `left` and `right`
            esc = new RegExp(
                '(?:' + escapeChar + '[\\S\\s]|(?:(?!' +
                    XRegExp.union([left, right]).source +
                    ')[^' + escapeChar + '])+)+',
                // Flags `gy` not needed here
                flags.replace(/[^imu]+/g, '')
            );
        }

        while (true) {
            // If using an escape character, advance to the delimiter's next starting position,
            // skipping any escaped characters in between
            if (escapeChar) {
                delimEnd += (XRegExp.exec(str, esc, delimEnd, 'sticky') || [''])[0].length;
            }
            leftMatch = XRegExp.exec(str, left, delimEnd);
            rightMatch = XRegExp.exec(str, right, delimEnd);
            // Keep the leftmost match only
            if (leftMatch && rightMatch) {
                if (leftMatch.index <= rightMatch.index) {
                    rightMatch = null;
                } else {
                    leftMatch = null;
                }
            }
            // Paths (LM: leftMatch, RM: rightMatch, OT: openTokens):
            // LM | RM | OT | Result
            // 1  | 0  | 1  | loop
            // 1  | 0  | 0  | loop
            // 0  | 1  | 1  | loop
            // 0  | 1  | 0  | throw
            // 0  | 0  | 1  | throw
            // 0  | 0  | 0  | break
            // The paths above don't include the sticky mode special case. The loop ends after the
            // first completed match if not `global`.
            if (leftMatch || rightMatch) {
                delimStart = (leftMatch || rightMatch).index;
                delimEnd = delimStart + (leftMatch || rightMatch)[0].length;
            } else if (!openTokens) {
                break;
            }
            if (sticky && !openTokens && delimStart > lastOuterEnd) {
                break;
            }
            if (leftMatch) {
                if (!openTokens) {
                    outerStart = delimStart;
                    innerStart = delimEnd;
                }
                ++openTokens;
            } else if (rightMatch && openTokens) {
                if (!--openTokens) {
                    if (vN) {
                        if (vN[0] && outerStart > lastOuterEnd) {
                            output.push(row(vN[0], str.slice(lastOuterEnd, outerStart), lastOuterEnd, outerStart));
                        }
                        if (vN[1]) {
                            output.push(row(vN[1], str.slice(outerStart, innerStart), outerStart, innerStart));
                        }
                        if (vN[2]) {
                            output.push(row(vN[2], str.slice(innerStart, delimStart), innerStart, delimStart));
                        }
                        if (vN[3]) {
                            output.push(row(vN[3], str.slice(delimStart, delimEnd), delimStart, delimEnd));
                        }
                    } else {
                        output.push(str.slice(innerStart, delimStart));
                    }
                    lastOuterEnd = delimEnd;
                    if (!global) {
                        break;
                    }
                }
            } else {
                throw new Error('Unbalanced delimiter found in string');
            }
            // If the delimiter matched an empty string, avoid an infinite loop
            if (delimStart === delimEnd) {
                ++delimEnd;
            }
        }

        if (global && !sticky && vN && vN[0] && str.length > lastOuterEnd) {
            output.push(row(vN[0], str.slice(lastOuterEnd), lastOuterEnd, str.length));
        }

        return output;
    };

}(XRegExp));

/*!
 * XRegExp Unicode Base 3.0.0
 * <http://xregexp.com/>
 * Steven Levithan (c) 2008-2015 MIT License
 */

/**
 * Adds base support for Unicode matching:
 * - Adds syntax `\p{..}` for matching Unicode tokens. Tokens can be inverted using `\P{..}` or
 *   `\p{^..}`. Token names ignore case, spaces, hyphens, and underscores. You can omit the brackets
 *   for token names that are a single letter (e.g. `\pL` or `PL`).
 * - Adds flag A (astral), which enables 21-bit Unicode support.
 * - Adds the `XRegExp.addUnicodeData` method used by other addons to provide character data.
 *
 * Unicode Base relies on externally provided Unicode character data. Official addons are available
 * to provide data for Unicode categories, scripts, blocks, and properties.
 *
 * @requires XRegExp
 */
(function(XRegExp) {
    'use strict';

// Storage for Unicode data
    var unicode = {};

/* ==============================
 * Private functions
 * ============================== */

// Generates a token lookup name: lowercase, with hyphens, spaces, and underscores removed
    function normalize(name) {
        return name.replace(/[- _]+/g, '').toLowerCase();
    }

// Adds leading zeros if shorter than four characters
    function pad4(str) {
        while (str.length < 4) {
            str = '0' + str;
        }
        return str;
    }

// Converts a hexadecimal number to decimal
    function dec(hex) {
        return parseInt(hex, 16);
    }

// Converts a decimal number to hexadecimal
    function hex(dec) {
        return parseInt(dec, 10).toString(16);
    }

// Gets the decimal code of a literal code unit, \xHH, \uHHHH, or a backslash-escaped literal
    function charCode(chr) {
        var esc = /^\\[xu](.+)/.exec(chr);
        return esc ?
            dec(esc[1]) :
            chr.charCodeAt(chr.charAt(0) === '\\' ? 1 : 0);
    }

// Inverts a list of ordered BMP characters and ranges
    function invertBmp(range) {
        var output = '',
            lastEnd = -1,
            start;
        XRegExp.forEach(range, /(\\x..|\\u....|\\?[\s\S])(?:-(\\x..|\\u....|\\?[\s\S]))?/, function(m) {
            start = charCode(m[1]);
            if (start > (lastEnd + 1)) {
                output += '\\u' + pad4(hex(lastEnd + 1));
                if (start > (lastEnd + 2)) {
                    output += '-\\u' + pad4(hex(start - 1));
                }
            }
            lastEnd = charCode(m[2] || m[1]);
        });
        if (lastEnd < 0xFFFF) {
            output += '\\u' + pad4(hex(lastEnd + 1));
            if (lastEnd < 0xFFFE) {
                output += '-\\uFFFF';
            }
        }
        return output;
    }

// Generates an inverted BMP range on first use
    function cacheInvertedBmp(slug) {
        var prop = 'b!';
        return unicode[slug][prop] || (
            unicode[slug][prop] = invertBmp(unicode[slug].bmp)
        );
    }

// Combines and optionally negates BMP and astral data
    function buildAstral(slug, isNegated) {
        var item = unicode[slug],
            combined = '';
        if (item.bmp && !item.isBmpLast) {
            combined = '[' + item.bmp + ']' + (item.astral ? '|' : '');
        }
        if (item.astral) {
            combined += item.astral;
        }
        if (item.isBmpLast && item.bmp) {
            combined += (item.astral ? '|' : '') + '[' + item.bmp + ']';
        }
        // Astral Unicode tokens always match a code point, never a code unit
        return isNegated ?
            '(?:(?!' + combined + ')(?:[\uD800-\uDBFF][\uDC00-\uDFFF]|[\0-\uFFFF]))' :
            '(?:' + combined + ')';
    }

// Builds a complete astral pattern on first use
    function cacheAstral(slug, isNegated) {
        var prop = isNegated ? 'a!' : 'a=';
        return unicode[slug][prop] || (
            unicode[slug][prop] = buildAstral(slug, isNegated)
        );
    }

/* ==============================
 * Core functionality
 * ============================== */

/*
 * Add Unicode token syntax: \p{..}, \P{..}, \p{^..}. Also add astral mode (flag A).
 */
    XRegExp.addToken(
        // Use `*` instead of `+` to avoid capturing `^` as the token name in `\p{^}`
        /\\([pP])(?:{(\^?)([^}]*)}|([A-Za-z]))/,
        function(match, scope, flags) {
            var ERR_DOUBLE_NEG = 'Invalid double negation ',
                ERR_UNKNOWN_NAME = 'Unknown Unicode token ',
                ERR_UNKNOWN_REF = 'Unicode token missing data ',
                ERR_ASTRAL_ONLY = 'Astral mode required for Unicode token ',
                ERR_ASTRAL_IN_CLASS = 'Astral mode does not support Unicode tokens within character classes',
                // Negated via \P{..} or \p{^..}
                isNegated = match[1] === 'P' || !!match[2],
                // Switch from BMP (0-FFFF) to astral (0-10FFFF) mode via flag A
                isAstralMode = flags.indexOf('A') > -1,
                // Token lookup name. Check `[4]` first to avoid passing `undefined` via `\p{}`
                slug = normalize(match[4] || match[3]),
                // Token data object
                item = unicode[slug];

            if (match[1] === 'P' && match[2]) {
                throw new SyntaxError(ERR_DOUBLE_NEG + match[0]);
            }
            if (!unicode.hasOwnProperty(slug)) {
                throw new SyntaxError(ERR_UNKNOWN_NAME + match[0]);
            }

            // Switch to the negated form of the referenced Unicode token
            if (item.inverseOf) {
                slug = normalize(item.inverseOf);
                if (!unicode.hasOwnProperty(slug)) {
                    throw new ReferenceError(ERR_UNKNOWN_REF + match[0] + ' -> ' + item.inverseOf);
                }
                item = unicode[slug];
                isNegated = !isNegated;
            }

            if (!(item.bmp || isAstralMode)) {
                throw new SyntaxError(ERR_ASTRAL_ONLY + match[0]);
            }
            if (isAstralMode) {
                if (scope === 'class') {
                    throw new SyntaxError(ERR_ASTRAL_IN_CLASS);
                }

                return cacheAstral(slug, isNegated);
            }

            return scope === 'class' ?
                (isNegated ? cacheInvertedBmp(slug) : item.bmp) :
                (isNegated ? '[^' : '[') + item.bmp + ']';
        },
        {
            scope: 'all',
            optionalFlags: 'A',
            leadChar: '\\'
        }
    );

/**
 * Adds to the list of Unicode tokens that XRegExp regexes can match via `\p` or `\P`.
 *
 * @memberOf XRegExp
 * @param {Array} data Objects with named character ranges. Each object may have properties `name`,
 *   `alias`, `isBmpLast`, `inverseOf`, `bmp`, and `astral`. All but `name` are optional, although
 *   one of `bmp` or `astral` is required (unless `inverseOf` is set). If `astral` is absent, the
 *   `bmp` data is used for BMP and astral modes. If `bmp` is absent, the name errors in BMP mode
 *   but works in astral mode. If both `bmp` and `astral` are provided, the `bmp` data only is used
 *   in BMP mode, and the combination of `bmp` and `astral` data is used in astral mode.
 *   `isBmpLast` is needed when a token matches orphan high surrogates *and* uses surrogate pairs
 *   to match astral code points. The `bmp` and `astral` data should be a combination of literal
 *   characters and `\xHH` or `\uHHHH` escape sequences, with hyphens to create ranges. Any regex
 *   metacharacters in the data should be escaped, apart from range-creating hyphens. The `astral`
 *   data can additionally use character classes and alternation, and should use surrogate pairs to
 *   represent astral code points. `inverseOf` can be used to avoid duplicating character data if a
 *   Unicode token is defined as the exact inverse of another token.
 * @example
 *
 * // Basic use
 * XRegExp.addUnicodeData([{
 *   name: 'XDigit',
 *   alias: 'Hexadecimal',
 *   bmp: '0-9A-Fa-f'
 * }]);
 * XRegExp('\\p{XDigit}:\\p{Hexadecimal}+').test('0:3D'); // -> true
 */
    XRegExp.addUnicodeData = function(data) {
        var ERR_NO_NAME = 'Unicode token requires name',
            ERR_NO_DATA = 'Unicode token has no character data ',
            item,
            i;

        for (i = 0; i < data.length; ++i) {
            item = data[i];
            if (!item.name) {
                throw new Error(ERR_NO_NAME);
            }
            if (!(item.inverseOf || item.bmp || item.astral)) {
                throw new Error(ERR_NO_DATA + item.name);
            }
            unicode[normalize(item.name)] = item;
            if (item.alias) {
                unicode[normalize(item.alias)] = item;
            }
        }

        // Reset the pattern cache used by the `XRegExp` constructor, since the same pattern and
        // flags might now produce different results
        XRegExp.cache.flush('patterns');
    };

}(XRegExp));

/*!
 * XRegExp Unicode Blocks 3.0.0
 * <http://xregexp.com/>
 * Steven Levithan (c) 2010-2015 MIT License
 * Unicode data provided by Mathias Bynens <http://mathiasbynens.be/>
 */

/**
 * Adds support for all Unicode blocks. Block names use the prefix 'In'. E.g., `\p{InBasicLatin}`.
 * Token names are case insensitive, and any spaces, hyphens, and underscores are ignored.
 *
 * Uses Unicode 8.0.0.
 *
 * @requires XRegExp, Unicode Base
 */
(function(XRegExp) {
    'use strict';

    if (!XRegExp.addUnicodeData) {
        throw new ReferenceError('Unicode Base must be loaded before Unicode Blocks');
    }

    XRegExp.addUnicodeData([
        {
            name: 'InAegean_Numbers',
            astral: '\uD800[\uDD00-\uDD3F]'
        },
        {
            name: 'InAhom',
            astral: '\uD805[\uDF00-\uDF3F]'
        },
        {
            name: 'InAlchemical_Symbols',
            astral: '\uD83D[\uDF00-\uDF7F]'
        },
        {
            name: 'InAlphabetic_Presentation_Forms',
            bmp: '\uFB00-\uFB4F'
        },
        {
            name: 'InAnatolian_Hieroglyphs',
            astral: '\uD811[\uDC00-\uDE7F]'
        },
        {
            name: 'InAncient_Greek_Musical_Notation',
            astral: '\uD834[\uDE00-\uDE4F]'
        },
        {
            name: 'InAncient_Greek_Numbers',
            astral: '\uD800[\uDD40-\uDD8F]'
        },
        {
            name: 'InAncient_Symbols',
            astral: '\uD800[\uDD90-\uDDCF]'
        },
        {
            name: 'InArabic',
            bmp: '\u0600-\u06FF'
        },
        {
            name: 'InArabic_Extended_A',
            bmp: '\u08A0-\u08FF'
        },
        {
            name: 'InArabic_Mathematical_Alphabetic_Symbols',
            astral: '\uD83B[\uDE00-\uDEFF]'
        },
        {
            name: 'InArabic_Presentation_Forms_A',
            bmp: '\uFB50-\uFDFF'
        },
        {
            name: 'InArabic_Presentation_Forms_B',
            bmp: '\uFE70-\uFEFF'
        },
        {
            name: 'InArabic_Supplement',
            bmp: '\u0750-\u077F'
        },
        {
            name: 'InArmenian',
            bmp: '\u0530-\u058F'
        },
        {
            name: 'InArrows',
            bmp: '\u2190-\u21FF'
        },
        {
            name: 'InAvestan',
            astral: '\uD802[\uDF00-\uDF3F]'
        },
        {
            name: 'InBalinese',
            bmp: '\u1B00-\u1B7F'
        },
        {
            name: 'InBamum',
            bmp: '\uA6A0-\uA6FF'
        },
        {
            name: 'InBamum_Supplement',
            astral: '\uD81A[\uDC00-\uDE3F]'
        },
        {
            name: 'InBasic_Latin',
            bmp: '\0-\x7F'
        },
        {
            name: 'InBassa_Vah',
            astral: '\uD81A[\uDED0-\uDEFF]'
        },
        {
            name: 'InBatak',
            bmp: '\u1BC0-\u1BFF'
        },
        {
            name: 'InBengali',
            bmp: '\u0980-\u09FF'
        },
        {
            name: 'InBlock_Elements',
            bmp: '\u2580-\u259F'
        },
        {
            name: 'InBopomofo',
            bmp: '\u3100-\u312F'
        },
        {
            name: 'InBopomofo_Extended',
            bmp: '\u31A0-\u31BF'
        },
        {
            name: 'InBox_Drawing',
            bmp: '\u2500-\u257F'
        },
        {
            name: 'InBrahmi',
            astral: '\uD804[\uDC00-\uDC7F]'
        },
        {
            name: 'InBraille_Patterns',
            bmp: '\u2800-\u28FF'
        },
        {
            name: 'InBuginese',
            bmp: '\u1A00-\u1A1F'
        },
        {
            name: 'InBuhid',
            bmp: '\u1740-\u175F'
        },
        {
            name: 'InByzantine_Musical_Symbols',
            astral: '\uD834[\uDC00-\uDCFF]'
        },
        {
            name: 'InCJK_Compatibility',
            bmp: '\u3300-\u33FF'
        },
        {
            name: 'InCJK_Compatibility_Forms',
            bmp: '\uFE30-\uFE4F'
        },
        {
            name: 'InCJK_Compatibility_Ideographs',
            bmp: '\uF900-\uFAFF'
        },
        {
            name: 'InCJK_Compatibility_Ideographs_Supplement',
            astral: '\uD87E[\uDC00-\uDE1F]'
        },
        {
            name: 'InCJK_Radicals_Supplement',
            bmp: '\u2E80-\u2EFF'
        },
        {
            name: 'InCJK_Strokes',
            bmp: '\u31C0-\u31EF'
        },
        {
            name: 'InCJK_Symbols_and_Punctuation',
            bmp: '\u3000-\u303F'
        },
        {
            name: 'InCJK_Unified_Ideographs',
            bmp: '\u4E00-\u9FFF'
        },
        {
            name: 'InCJK_Unified_Ideographs_Extension_A',
            bmp: '\u3400-\u4DBF'
        },
        {
            name: 'InCJK_Unified_Ideographs_Extension_B',
            astral: '[\uD840-\uD868][\uDC00-\uDFFF]|\uD869[\uDC00-\uDEDF]'
        },
        {
            name: 'InCJK_Unified_Ideographs_Extension_C',
            astral: '\uD86D[\uDC00-\uDF3F]|[\uD86A-\uD86C][\uDC00-\uDFFF]|\uD869[\uDF00-\uDFFF]'
        },
        {
            name: 'InCJK_Unified_Ideographs_Extension_D',
            astral: '\uD86D[\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1F]'
        },
        {
            name: 'InCJK_Unified_Ideographs_Extension_E',
            astral: '[\uD86F-\uD872][\uDC00-\uDFFF]|\uD873[\uDC00-\uDEAF]|\uD86E[\uDC20-\uDFFF]'
        },
        {
            name: 'InCarian',
            astral: '\uD800[\uDEA0-\uDEDF]'
        },
        {
            name: 'InCaucasian_Albanian',
            astral: '\uD801[\uDD30-\uDD6F]'
        },
        {
            name: 'InChakma',
            astral: '\uD804[\uDD00-\uDD4F]'
        },
        {
            name: 'InCham',
            bmp: '\uAA00-\uAA5F'
        },
        {
            name: 'InCherokee',
            bmp: '\u13A0-\u13FF'
        },
        {
            name: 'InCherokee_Supplement',
            bmp: '\uAB70-\uABBF'
        },
        {
            name: 'InCombining_Diacritical_Marks',
            bmp: '\u0300-\u036F'
        },
        {
            name: 'InCombining_Diacritical_Marks_Extended',
            bmp: '\u1AB0-\u1AFF'
        },
        {
            name: 'InCombining_Diacritical_Marks_Supplement',
            bmp: '\u1DC0-\u1DFF'
        },
        {
            name: 'InCombining_Diacritical_Marks_for_Symbols',
            bmp: '\u20D0-\u20FF'
        },
        {
            name: 'InCombining_Half_Marks',
            bmp: '\uFE20-\uFE2F'
        },
        {
            name: 'InCommon_Indic_Number_Forms',
            bmp: '\uA830-\uA83F'
        },
        {
            name: 'InControl_Pictures',
            bmp: '\u2400-\u243F'
        },
        {
            name: 'InCoptic',
            bmp: '\u2C80-\u2CFF'
        },
        {
            name: 'InCoptic_Epact_Numbers',
            astral: '\uD800[\uDEE0-\uDEFF]'
        },
        {
            name: 'InCounting_Rod_Numerals',
            astral: '\uD834[\uDF60-\uDF7F]'
        },
        {
            name: 'InCuneiform',
            astral: '\uD808[\uDC00-\uDFFF]'
        },
        {
            name: 'InCuneiform_Numbers_and_Punctuation',
            astral: '\uD809[\uDC00-\uDC7F]'
        },
        {
            name: 'InCurrency_Symbols',
            bmp: '\u20A0-\u20CF'
        },
        {
            name: 'InCypriot_Syllabary',
            astral: '\uD802[\uDC00-\uDC3F]'
        },
        {
            name: 'InCyrillic',
            bmp: '\u0400-\u04FF'
        },
        {
            name: 'InCyrillic_Extended_A',
            bmp: '\u2DE0-\u2DFF'
        },
        {
            name: 'InCyrillic_Extended_B',
            bmp: '\uA640-\uA69F'
        },
        {
            name: 'InCyrillic_Supplement',
            bmp: '\u0500-\u052F'
        },
        {
            name: 'InDeseret',
            astral: '\uD801[\uDC00-\uDC4F]'
        },
        {
            name: 'InDevanagari',
            bmp: '\u0900-\u097F'
        },
        {
            name: 'InDevanagari_Extended',
            bmp: '\uA8E0-\uA8FF'
        },
        {
            name: 'InDingbats',
            bmp: '\u2700-\u27BF'
        },
        {
            name: 'InDomino_Tiles',
            astral: '\uD83C[\uDC30-\uDC9F]'
        },
        {
            name: 'InDuployan',
            astral: '\uD82F[\uDC00-\uDC9F]'
        },
        {
            name: 'InEarly_Dynastic_Cuneiform',
            astral: '\uD809[\uDC80-\uDD4F]'
        },
        {
            name: 'InEgyptian_Hieroglyphs',
            astral: '\uD80C[\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2F]'
        },
        {
            name: 'InElbasan',
            astral: '\uD801[\uDD00-\uDD2F]'
        },
        {
            name: 'InEmoticons',
            astral: '\uD83D[\uDE00-\uDE4F]'
        },
        {
            name: 'InEnclosed_Alphanumeric_Supplement',
            astral: '\uD83C[\uDD00-\uDDFF]'
        },
        {
            name: 'InEnclosed_Alphanumerics',
            bmp: '\u2460-\u24FF'
        },
        {
            name: 'InEnclosed_CJK_Letters_and_Months',
            bmp: '\u3200-\u32FF'
        },
        {
            name: 'InEnclosed_Ideographic_Supplement',
            astral: '\uD83C[\uDE00-\uDEFF]'
        },
        {
            name: 'InEthiopic',
            bmp: '\u1200-\u137F'
        },
        {
            name: 'InEthiopic_Extended',
            bmp: '\u2D80-\u2DDF'
        },
        {
            name: 'InEthiopic_Extended_A',
            bmp: '\uAB00-\uAB2F'
        },
        {
            name: 'InEthiopic_Supplement',
            bmp: '\u1380-\u139F'
        },
        {
            name: 'InGeneral_Punctuation',
            bmp: '\u2000-\u206F'
        },
        {
            name: 'InGeometric_Shapes',
            bmp: '\u25A0-\u25FF'
        },
        {
            name: 'InGeometric_Shapes_Extended',
            astral: '\uD83D[\uDF80-\uDFFF]'
        },
        {
            name: 'InGeorgian',
            bmp: '\u10A0-\u10FF'
        },
        {
            name: 'InGeorgian_Supplement',
            bmp: '\u2D00-\u2D2F'
        },
        {
            name: 'InGlagolitic',
            bmp: '\u2C00-\u2C5F'
        },
        {
            name: 'InGothic',
            astral: '\uD800[\uDF30-\uDF4F]'
        },
        {
            name: 'InGrantha',
            astral: '\uD804[\uDF00-\uDF7F]'
        },
        {
            name: 'InGreek_Extended',
            bmp: '\u1F00-\u1FFF'
        },
        {
            name: 'InGreek_and_Coptic',
            bmp: '\u0370-\u03FF'
        },
        {
            name: 'InGujarati',
            bmp: '\u0A80-\u0AFF'
        },
        {
            name: 'InGurmukhi',
            bmp: '\u0A00-\u0A7F'
        },
        {
            name: 'InHalfwidth_and_Fullwidth_Forms',
            bmp: '\uFF00-\uFFEF'
        },
        {
            name: 'InHangul_Compatibility_Jamo',
            bmp: '\u3130-\u318F'
        },
        {
            name: 'InHangul_Jamo',
            bmp: '\u1100-\u11FF'
        },
        {
            name: 'InHangul_Jamo_Extended_A',
            bmp: '\uA960-\uA97F'
        },
        {
            name: 'InHangul_Jamo_Extended_B',
            bmp: '\uD7B0-\uD7FF'
        },
        {
            name: 'InHangul_Syllables',
            bmp: '\uAC00-\uD7AF'
        },
        {
            name: 'InHanunoo',
            bmp: '\u1720-\u173F'
        },
        {
            name: 'InHatran',
            astral: '\uD802[\uDCE0-\uDCFF]'
        },
        {
            name: 'InHebrew',
            bmp: '\u0590-\u05FF'
        },
        {
            name: 'InHigh_Private_Use_Surrogates',
            bmp: '\uDB80-\uDBFF'
        },
        {
            name: 'InHigh_Surrogates',
            bmp: '\uD800-\uDB7F'
        },
        {
            name: 'InHiragana',
            bmp: '\u3040-\u309F'
        },
        {
            name: 'InIPA_Extensions',
            bmp: '\u0250-\u02AF'
        },
        {
            name: 'InIdeographic_Description_Characters',
            bmp: '\u2FF0-\u2FFF'
        },
        {
            name: 'InImperial_Aramaic',
            astral: '\uD802[\uDC40-\uDC5F]'
        },
        {
            name: 'InInscriptional_Pahlavi',
            astral: '\uD802[\uDF60-\uDF7F]'
        },
        {
            name: 'InInscriptional_Parthian',
            astral: '\uD802[\uDF40-\uDF5F]'
        },
        {
            name: 'InJavanese',
            bmp: '\uA980-\uA9DF'
        },
        {
            name: 'InKaithi',
            astral: '\uD804[\uDC80-\uDCCF]'
        },
        {
            name: 'InKana_Supplement',
            astral: '\uD82C[\uDC00-\uDCFF]'
        },
        {
            name: 'InKanbun',
            bmp: '\u3190-\u319F'
        },
        {
            name: 'InKangxi_Radicals',
            bmp: '\u2F00-\u2FDF'
        },
        {
            name: 'InKannada',
            bmp: '\u0C80-\u0CFF'
        },
        {
            name: 'InKatakana',
            bmp: '\u30A0-\u30FF'
        },
        {
            name: 'InKatakana_Phonetic_Extensions',
            bmp: '\u31F0-\u31FF'
        },
        {
            name: 'InKayah_Li',
            bmp: '\uA900-\uA92F'
        },
        {
            name: 'InKharoshthi',
            astral: '\uD802[\uDE00-\uDE5F]'
        },
        {
            name: 'InKhmer',
            bmp: '\u1780-\u17FF'
        },
        {
            name: 'InKhmer_Symbols',
            bmp: '\u19E0-\u19FF'
        },
        {
            name: 'InKhojki',
            astral: '\uD804[\uDE00-\uDE4F]'
        },
        {
            name: 'InKhudawadi',
            astral: '\uD804[\uDEB0-\uDEFF]'
        },
        {
            name: 'InLao',
            bmp: '\u0E80-\u0EFF'
        },
        {
            name: 'InLatin_Extended_Additional',
            bmp: '\u1E00-\u1EFF'
        },
        {
            name: 'InLatin_Extended_A',
            bmp: '\u0100-\u017F'
        },
        {
            name: 'InLatin_Extended_B',
            bmp: '\u0180-\u024F'
        },
        {
            name: 'InLatin_Extended_C',
            bmp: '\u2C60-\u2C7F'
        },
        {
            name: 'InLatin_Extended_D',
            bmp: '\uA720-\uA7FF'
        },
        {
            name: 'InLatin_Extended_E',
            bmp: '\uAB30-\uAB6F'
        },
        {
            name: 'InLatin_1_Supplement',
            bmp: '\x80-\xFF'
        },
        {
            name: 'InLepcha',
            bmp: '\u1C00-\u1C4F'
        },
        {
            name: 'InLetterlike_Symbols',
            bmp: '\u2100-\u214F'
        },
        {
            name: 'InLimbu',
            bmp: '\u1900-\u194F'
        },
        {
            name: 'InLinear_A',
            astral: '\uD801[\uDE00-\uDF7F]'
        },
        {
            name: 'InLinear_B_Ideograms',
            astral: '\uD800[\uDC80-\uDCFF]'
        },
        {
            name: 'InLinear_B_Syllabary',
            astral: '\uD800[\uDC00-\uDC7F]'
        },
        {
            name: 'InLisu',
            bmp: '\uA4D0-\uA4FF'
        },
        {
            name: 'InLow_Surrogates',
            bmp: '\uDC00-\uDFFF'
        },
        {
            name: 'InLycian',
            astral: '\uD800[\uDE80-\uDE9F]'
        },
        {
            name: 'InLydian',
            astral: '\uD802[\uDD20-\uDD3F]'
        },
        {
            name: 'InMahajani',
            astral: '\uD804[\uDD50-\uDD7F]'
        },
        {
            name: 'InMahjong_Tiles',
            astral: '\uD83C[\uDC00-\uDC2F]'
        },
        {
            name: 'InMalayalam',
            bmp: '\u0D00-\u0D7F'
        },
        {
            name: 'InMandaic',
            bmp: '\u0840-\u085F'
        },
        {
            name: 'InManichaean',
            astral: '\uD802[\uDEC0-\uDEFF]'
        },
        {
            name: 'InMathematical_Alphanumeric_Symbols',
            astral: '\uD835[\uDC00-\uDFFF]'
        },
        {
            name: 'InMathematical_Operators',
            bmp: '\u2200-\u22FF'
        },
        {
            name: 'InMeetei_Mayek',
            bmp: '\uABC0-\uABFF'
        },
        {
            name: 'InMeetei_Mayek_Extensions',
            bmp: '\uAAE0-\uAAFF'
        },
        {
            name: 'InMende_Kikakui',
            astral: '\uD83A[\uDC00-\uDCDF]'
        },
        {
            name: 'InMeroitic_Cursive',
            astral: '\uD802[\uDDA0-\uDDFF]'
        },
        {
            name: 'InMeroitic_Hieroglyphs',
            astral: '\uD802[\uDD80-\uDD9F]'
        },
        {
            name: 'InMiao',
            astral: '\uD81B[\uDF00-\uDF9F]'
        },
        {
            name: 'InMiscellaneous_Mathematical_Symbols_A',
            bmp: '\u27C0-\u27EF'
        },
        {
            name: 'InMiscellaneous_Mathematical_Symbols_B',
            bmp: '\u2980-\u29FF'
        },
        {
            name: 'InMiscellaneous_Symbols',
            bmp: '\u2600-\u26FF'
        },
        {
            name: 'InMiscellaneous_Symbols_and_Arrows',
            bmp: '\u2B00-\u2BFF'
        },
        {
            name: 'InMiscellaneous_Symbols_and_Pictographs',
            astral: '\uD83D[\uDC00-\uDDFF]|\uD83C[\uDF00-\uDFFF]'
        },
        {
            name: 'InMiscellaneous_Technical',
            bmp: '\u2300-\u23FF'
        },
        {
            name: 'InModi',
            astral: '\uD805[\uDE00-\uDE5F]'
        },
        {
            name: 'InModifier_Tone_Letters',
            bmp: '\uA700-\uA71F'
        },
        {
            name: 'InMongolian',
            bmp: '\u1800-\u18AF'
        },
        {
            name: 'InMro',
            astral: '\uD81A[\uDE40-\uDE6F]'
        },
        {
            name: 'InMultani',
            astral: '\uD804[\uDE80-\uDEAF]'
        },
        {
            name: 'InMusical_Symbols',
            astral: '\uD834[\uDD00-\uDDFF]'
        },
        {
            name: 'InMyanmar',
            bmp: '\u1000-\u109F'
        },
        {
            name: 'InMyanmar_Extended_A',
            bmp: '\uAA60-\uAA7F'
        },
        {
            name: 'InMyanmar_Extended_B',
            bmp: '\uA9E0-\uA9FF'
        },
        {
            name: 'InNKo',
            bmp: '\u07C0-\u07FF'
        },
        {
            name: 'InNabataean',
            astral: '\uD802[\uDC80-\uDCAF]'
        },
        {
            name: 'InNew_Tai_Lue',
            bmp: '\u1980-\u19DF'
        },
        {
            name: 'InNumber_Forms',
            bmp: '\u2150-\u218F'
        },
        {
            name: 'InOgham',
            bmp: '\u1680-\u169F'
        },
        {
            name: 'InOl_Chiki',
            bmp: '\u1C50-\u1C7F'
        },
        {
            name: 'InOld_Hungarian',
            astral: '\uD803[\uDC80-\uDCFF]'
        },
        {
            name: 'InOld_Italic',
            astral: '\uD800[\uDF00-\uDF2F]'
        },
        {
            name: 'InOld_North_Arabian',
            astral: '\uD802[\uDE80-\uDE9F]'
        },
        {
            name: 'InOld_Permic',
            astral: '\uD800[\uDF50-\uDF7F]'
        },
        {
            name: 'InOld_Persian',
            astral: '\uD800[\uDFA0-\uDFDF]'
        },
        {
            name: 'InOld_South_Arabian',
            astral: '\uD802[\uDE60-\uDE7F]'
        },
        {
            name: 'InOld_Turkic',
            astral: '\uD803[\uDC00-\uDC4F]'
        },
        {
            name: 'InOptical_Character_Recognition',
            bmp: '\u2440-\u245F'
        },
        {
            name: 'InOriya',
            bmp: '\u0B00-\u0B7F'
        },
        {
            name: 'InOrnamental_Dingbats',
            astral: '\uD83D[\uDE50-\uDE7F]'
        },
        {
            name: 'InOsmanya',
            astral: '\uD801[\uDC80-\uDCAF]'
        },
        {
            name: 'InPahawh_Hmong',
            astral: '\uD81A[\uDF00-\uDF8F]'
        },
        {
            name: 'InPalmyrene',
            astral: '\uD802[\uDC60-\uDC7F]'
        },
        {
            name: 'InPau_Cin_Hau',
            astral: '\uD806[\uDEC0-\uDEFF]'
        },
        {
            name: 'InPhags_pa',
            bmp: '\uA840-\uA87F'
        },
        {
            name: 'InPhaistos_Disc',
            astral: '\uD800[\uDDD0-\uDDFF]'
        },
        {
            name: 'InPhoenician',
            astral: '\uD802[\uDD00-\uDD1F]'
        },
        {
            name: 'InPhonetic_Extensions',
            bmp: '\u1D00-\u1D7F'
        },
        {
            name: 'InPhonetic_Extensions_Supplement',
            bmp: '\u1D80-\u1DBF'
        },
        {
            name: 'InPlaying_Cards',
            astral: '\uD83C[\uDCA0-\uDCFF]'
        },
        {
            name: 'InPrivate_Use_Area',
            bmp: '\uE000-\uF8FF'
        },
        {
            name: 'InPsalter_Pahlavi',
            astral: '\uD802[\uDF80-\uDFAF]'
        },
        {
            name: 'InRejang',
            bmp: '\uA930-\uA95F'
        },
        {
            name: 'InRumi_Numeral_Symbols',
            astral: '\uD803[\uDE60-\uDE7F]'
        },
        {
            name: 'InRunic',
            bmp: '\u16A0-\u16FF'
        },
        {
            name: 'InSamaritan',
            bmp: '\u0800-\u083F'
        },
        {
            name: 'InSaurashtra',
            bmp: '\uA880-\uA8DF'
        },
        {
            name: 'InSharada',
            astral: '\uD804[\uDD80-\uDDDF]'
        },
        {
            name: 'InShavian',
            astral: '\uD801[\uDC50-\uDC7F]'
        },
        {
            name: 'InShorthand_Format_Controls',
            astral: '\uD82F[\uDCA0-\uDCAF]'
        },
        {
            name: 'InSiddham',
            astral: '\uD805[\uDD80-\uDDFF]'
        },
        {
            name: 'InSinhala',
            bmp: '\u0D80-\u0DFF'
        },
        {
            name: 'InSinhala_Archaic_Numbers',
            astral: '\uD804[\uDDE0-\uDDFF]'
        },
        {
            name: 'InSmall_Form_Variants',
            bmp: '\uFE50-\uFE6F'
        },
        {
            name: 'InSora_Sompeng',
            astral: '\uD804[\uDCD0-\uDCFF]'
        },
        {
            name: 'InSpacing_Modifier_Letters',
            bmp: '\u02B0-\u02FF'
        },
        {
            name: 'InSpecials',
            bmp: '\uFFF0-\uFFFF'
        },
        {
            name: 'InSundanese',
            bmp: '\u1B80-\u1BBF'
        },
        {
            name: 'InSundanese_Supplement',
            bmp: '\u1CC0-\u1CCF'
        },
        {
            name: 'InSuperscripts_and_Subscripts',
            bmp: '\u2070-\u209F'
        },
        {
            name: 'InSupplemental_Arrows_A',
            bmp: '\u27F0-\u27FF'
        },
        {
            name: 'InSupplemental_Arrows_B',
            bmp: '\u2900-\u297F'
        },
        {
            name: 'InSupplemental_Arrows_C',
            astral: '\uD83E[\uDC00-\uDCFF]'
        },
        {
            name: 'InSupplemental_Mathematical_Operators',
            bmp: '\u2A00-\u2AFF'
        },
        {
            name: 'InSupplemental_Punctuation',
            bmp: '\u2E00-\u2E7F'
        },
        {
            name: 'InSupplemental_Symbols_and_Pictographs',
            astral: '\uD83E[\uDD00-\uDDFF]'
        },
        {
            name: 'InSupplementary_Private_Use_Area_A',
            astral: '[\uDB80-\uDBBF][\uDC00-\uDFFF]'
        },
        {
            name: 'InSupplementary_Private_Use_Area_B',
            astral: '[\uDBC0-\uDBFF][\uDC00-\uDFFF]'
        },
        {
            name: 'InSutton_SignWriting',
            astral: '\uD836[\uDC00-\uDEAF]'
        },
        {
            name: 'InSyloti_Nagri',
            bmp: '\uA800-\uA82F'
        },
        {
            name: 'InSyriac',
            bmp: '\u0700-\u074F'
        },
        {
            name: 'InTagalog',
            bmp: '\u1700-\u171F'
        },
        {
            name: 'InTagbanwa',
            bmp: '\u1760-\u177F'
        },
        {
            name: 'InTags',
            astral: '\uDB40[\uDC00-\uDC7F]'
        },
        {
            name: 'InTai_Le',
            bmp: '\u1950-\u197F'
        },
        {
            name: 'InTai_Tham',
            bmp: '\u1A20-\u1AAF'
        },
        {
            name: 'InTai_Viet',
            bmp: '\uAA80-\uAADF'
        },
        {
            name: 'InTai_Xuan_Jing_Symbols',
            astral: '\uD834[\uDF00-\uDF5F]'
        },
        {
            name: 'InTakri',
            astral: '\uD805[\uDE80-\uDECF]'
        },
        {
            name: 'InTamil',
            bmp: '\u0B80-\u0BFF'
        },
        {
            name: 'InTelugu',
            bmp: '\u0C00-\u0C7F'
        },
        {
            name: 'InThaana',
            bmp: '\u0780-\u07BF'
        },
        {
            name: 'InThai',
            bmp: '\u0E00-\u0E7F'
        },
        {
            name: 'InTibetan',
            bmp: '\u0F00-\u0FFF'
        },
        {
            name: 'InTifinagh',
            bmp: '\u2D30-\u2D7F'
        },
        {
            name: 'InTirhuta',
            astral: '\uD805[\uDC80-\uDCDF]'
        },
        {
            name: 'InTransport_and_Map_Symbols',
            astral: '\uD83D[\uDE80-\uDEFF]'
        },
        {
            name: 'InUgaritic',
            astral: '\uD800[\uDF80-\uDF9F]'
        },
        {
            name: 'InUnified_Canadian_Aboriginal_Syllabics',
            bmp: '\u1400-\u167F'
        },
        {
            name: 'InUnified_Canadian_Aboriginal_Syllabics_Extended',
            bmp: '\u18B0-\u18FF'
        },
        {
            name: 'InVai',
            bmp: '\uA500-\uA63F'
        },
        {
            name: 'InVariation_Selectors',
            bmp: '\uFE00-\uFE0F'
        },
        {
            name: 'InVariation_Selectors_Supplement',
            astral: '\uDB40[\uDD00-\uDDEF]'
        },
        {
            name: 'InVedic_Extensions',
            bmp: '\u1CD0-\u1CFF'
        },
        {
            name: 'InVertical_Forms',
            bmp: '\uFE10-\uFE1F'
        },
        {
            name: 'InWarang_Citi',
            astral: '\uD806[\uDCA0-\uDCFF]'
        },
        {
            name: 'InYi_Radicals',
            bmp: '\uA490-\uA4CF'
        },
        {
            name: 'InYi_Syllables',
            bmp: '\uA000-\uA48F'
        },
        {
            name: 'InYijing_Hexagram_Symbols',
            bmp: '\u4DC0-\u4DFF'
        }
    ]);

}(XRegExp));

/*!
 * XRegExp Unicode Categories 3.0.0
 * <http://xregexp.com/>
 * Steven Levithan (c) 2010-2015 MIT License
 * Unicode data provided by Mathias Bynens <http://mathiasbynens.be/>
 */

/**
 * Adds support for Unicode's general categories. E.g., `\p{Lu}` or `\p{Uppercase Letter}`. See
 * category descriptions in UAX #44 <http://unicode.org/reports/tr44/#GC_Values_Table>. Token names
 * are case insensitive, and any spaces, hyphens, and underscores are ignored.
 *
 * Uses Unicode 8.0.0.
 *
 * @requires XRegExp, Unicode Base
 */
(function(XRegExp) {
    'use strict';

    if (!XRegExp.addUnicodeData) {
        throw new ReferenceError('Unicode Base must be loaded before Unicode Categories');
    }

    XRegExp.addUnicodeData([
        {
            name: 'C',
            alias: 'Other',
            isBmpLast: true,
            bmp: '\0-\x1F\x7F-\x9F\xAD\u0378\u0379\u0380-\u0383\u038B\u038D\u03A2\u0530\u0557\u0558\u0560\u0588\u058B\u058C\u0590\u05C8-\u05CF\u05EB-\u05EF\u05F5-\u0605\u061C\u061D\u06DD\u070E\u070F\u074B\u074C\u07B2-\u07BF\u07FB-\u07FF\u082E\u082F\u083F\u085C\u085D\u085F-\u089F\u08B5-\u08E2\u0984\u098D\u098E\u0991\u0992\u09A9\u09B1\u09B3-\u09B5\u09BA\u09BB\u09C5\u09C6\u09C9\u09CA\u09CF-\u09D6\u09D8-\u09DB\u09DE\u09E4\u09E5\u09FC-\u0A00\u0A04\u0A0B-\u0A0E\u0A11\u0A12\u0A29\u0A31\u0A34\u0A37\u0A3A\u0A3B\u0A3D\u0A43-\u0A46\u0A49\u0A4A\u0A4E-\u0A50\u0A52-\u0A58\u0A5D\u0A5F-\u0A65\u0A76-\u0A80\u0A84\u0A8E\u0A92\u0AA9\u0AB1\u0AB4\u0ABA\u0ABB\u0AC6\u0ACA\u0ACE\u0ACF\u0AD1-\u0ADF\u0AE4\u0AE5\u0AF2-\u0AF8\u0AFA-\u0B00\u0B04\u0B0D\u0B0E\u0B11\u0B12\u0B29\u0B31\u0B34\u0B3A\u0B3B\u0B45\u0B46\u0B49\u0B4A\u0B4E-\u0B55\u0B58-\u0B5B\u0B5E\u0B64\u0B65\u0B78-\u0B81\u0B84\u0B8B-\u0B8D\u0B91\u0B96-\u0B98\u0B9B\u0B9D\u0BA0-\u0BA2\u0BA5-\u0BA7\u0BAB-\u0BAD\u0BBA-\u0BBD\u0BC3-\u0BC5\u0BC9\u0BCE\u0BCF\u0BD1-\u0BD6\u0BD8-\u0BE5\u0BFB-\u0BFF\u0C04\u0C0D\u0C11\u0C29\u0C3A-\u0C3C\u0C45\u0C49\u0C4E-\u0C54\u0C57\u0C5B-\u0C5F\u0C64\u0C65\u0C70-\u0C77\u0C80\u0C84\u0C8D\u0C91\u0CA9\u0CB4\u0CBA\u0CBB\u0CC5\u0CC9\u0CCE-\u0CD4\u0CD7-\u0CDD\u0CDF\u0CE4\u0CE5\u0CF0\u0CF3-\u0D00\u0D04\u0D0D\u0D11\u0D3B\u0D3C\u0D45\u0D49\u0D4F-\u0D56\u0D58-\u0D5E\u0D64\u0D65\u0D76-\u0D78\u0D80\u0D81\u0D84\u0D97-\u0D99\u0DB2\u0DBC\u0DBE\u0DBF\u0DC7-\u0DC9\u0DCB-\u0DCE\u0DD5\u0DD7\u0DE0-\u0DE5\u0DF0\u0DF1\u0DF5-\u0E00\u0E3B-\u0E3E\u0E5C-\u0E80\u0E83\u0E85\u0E86\u0E89\u0E8B\u0E8C\u0E8E-\u0E93\u0E98\u0EA0\u0EA4\u0EA6\u0EA8\u0EA9\u0EAC\u0EBA\u0EBE\u0EBF\u0EC5\u0EC7\u0ECE\u0ECF\u0EDA\u0EDB\u0EE0-\u0EFF\u0F48\u0F6D-\u0F70\u0F98\u0FBD\u0FCD\u0FDB-\u0FFF\u10C6\u10C8-\u10CC\u10CE\u10CF\u1249\u124E\u124F\u1257\u1259\u125E\u125F\u1289\u128E\u128F\u12B1\u12B6\u12B7\u12BF\u12C1\u12C6\u12C7\u12D7\u1311\u1316\u1317\u135B\u135C\u137D-\u137F\u139A-\u139F\u13F6\u13F7\u13FE\u13FF\u169D-\u169F\u16F9-\u16FF\u170D\u1715-\u171F\u1737-\u173F\u1754-\u175F\u176D\u1771\u1774-\u177F\u17DE\u17DF\u17EA-\u17EF\u17FA-\u17FF\u180E\u180F\u181A-\u181F\u1878-\u187F\u18AB-\u18AF\u18F6-\u18FF\u191F\u192C-\u192F\u193C-\u193F\u1941-\u1943\u196E\u196F\u1975-\u197F\u19AC-\u19AF\u19CA-\u19CF\u19DB-\u19DD\u1A1C\u1A1D\u1A5F\u1A7D\u1A7E\u1A8A-\u1A8F\u1A9A-\u1A9F\u1AAE\u1AAF\u1ABF-\u1AFF\u1B4C-\u1B4F\u1B7D-\u1B7F\u1BF4-\u1BFB\u1C38-\u1C3A\u1C4A-\u1C4C\u1C80-\u1CBF\u1CC8-\u1CCF\u1CF7\u1CFA-\u1CFF\u1DF6-\u1DFB\u1F16\u1F17\u1F1E\u1F1F\u1F46\u1F47\u1F4E\u1F4F\u1F58\u1F5A\u1F5C\u1F5E\u1F7E\u1F7F\u1FB5\u1FC5\u1FD4\u1FD5\u1FDC\u1FF0\u1FF1\u1FF5\u1FFF\u200B-\u200F\u202A-\u202E\u2060-\u206F\u2072\u2073\u208F\u209D-\u209F\u20BF-\u20CF\u20F1-\u20FF\u218C-\u218F\u23FB-\u23FF\u2427-\u243F\u244B-\u245F\u2B74\u2B75\u2B96\u2B97\u2BBA-\u2BBC\u2BC9\u2BD2-\u2BEB\u2BF0-\u2BFF\u2C2F\u2C5F\u2CF4-\u2CF8\u2D26\u2D28-\u2D2C\u2D2E\u2D2F\u2D68-\u2D6E\u2D71-\u2D7E\u2D97-\u2D9F\u2DA7\u2DAF\u2DB7\u2DBF\u2DC7\u2DCF\u2DD7\u2DDF\u2E43-\u2E7F\u2E9A\u2EF4-\u2EFF\u2FD6-\u2FEF\u2FFC-\u2FFF\u3040\u3097\u3098\u3100-\u3104\u312E-\u3130\u318F\u31BB-\u31BF\u31E4-\u31EF\u321F\u32FF\u4DB6-\u4DBF\u9FD6-\u9FFF\uA48D-\uA48F\uA4C7-\uA4CF\uA62C-\uA63F\uA6F8-\uA6FF\uA7AE\uA7AF\uA7B8-\uA7F6\uA82C-\uA82F\uA83A-\uA83F\uA878-\uA87F\uA8C5-\uA8CD\uA8DA-\uA8DF\uA8FE\uA8FF\uA954-\uA95E\uA97D-\uA97F\uA9CE\uA9DA-\uA9DD\uA9FF\uAA37-\uAA3F\uAA4E\uAA4F\uAA5A\uAA5B\uAAC3-\uAADA\uAAF7-\uAB00\uAB07\uAB08\uAB0F\uAB10\uAB17-\uAB1F\uAB27\uAB2F\uAB66-\uAB6F\uABEE\uABEF\uABFA-\uABFF\uD7A4-\uD7AF\uD7C7-\uD7CA\uD7FC-\uF8FF\uFA6E\uFA6F\uFADA-\uFAFF\uFB07-\uFB12\uFB18-\uFB1C\uFB37\uFB3D\uFB3F\uFB42\uFB45\uFBC2-\uFBD2\uFD40-\uFD4F\uFD90\uFD91\uFDC8-\uFDEF\uFDFE\uFDFF\uFE1A-\uFE1F\uFE53\uFE67\uFE6C-\uFE6F\uFE75\uFEFD-\uFF00\uFFBF-\uFFC1\uFFC8\uFFC9\uFFD0\uFFD1\uFFD8\uFFD9\uFFDD-\uFFDF\uFFE7\uFFEF-\uFFFB\uFFFE\uFFFF',
            astral: '\uD834[\uDCF6-\uDCFF\uDD27\uDD28\uDD73-\uDD7A\uDDE9-\uDDFF\uDE46-\uDEFF\uDF57-\uDF5F\uDF72-\uDFFF]|\uD836[\uDE8C-\uDE9A\uDEA0\uDEB0-\uDFFF]|\uD83C[\uDC2C-\uDC2F\uDC94-\uDC9F\uDCAF\uDCB0\uDCC0\uDCD0\uDCF6-\uDCFF\uDD0D-\uDD0F\uDD2F\uDD6C-\uDD6F\uDD9B-\uDDE5\uDE03-\uDE0F\uDE3B-\uDE3F\uDE49-\uDE4F\uDE52-\uDEFF]|\uD81A[\uDE39-\uDE3F\uDE5F\uDE6A-\uDE6D\uDE70-\uDECF\uDEEE\uDEEF\uDEF6-\uDEFF\uDF46-\uDF4F\uDF5A\uDF62\uDF78-\uDF7C\uDF90-\uDFFF]|\uD809[\uDC6F\uDC75-\uDC7F\uDD44-\uDFFF]|\uD81B[\uDC00-\uDEFF\uDF45-\uDF4F\uDF7F-\uDF8E\uDFA0-\uDFFF]|\uD86E[\uDC1E\uDC1F]|\uD83D[\uDD7A\uDDA4\uDED1-\uDEDF\uDEED-\uDEEF\uDEF4-\uDEFF\uDF74-\uDF7F\uDFD5-\uDFFF]|\uD801[\uDC9E\uDC9F\uDCAA-\uDCFF\uDD28-\uDD2F\uDD64-\uDD6E\uDD70-\uDDFF\uDF37-\uDF3F\uDF56-\uDF5F\uDF68-\uDFFF]|\uD800[\uDC0C\uDC27\uDC3B\uDC3E\uDC4E\uDC4F\uDC5E-\uDC7F\uDCFB-\uDCFF\uDD03-\uDD06\uDD34-\uDD36\uDD8D-\uDD8F\uDD9C-\uDD9F\uDDA1-\uDDCF\uDDFE-\uDE7F\uDE9D-\uDE9F\uDED1-\uDEDF\uDEFC-\uDEFF\uDF24-\uDF2F\uDF4B-\uDF4F\uDF7B-\uDF7F\uDF9E\uDFC4-\uDFC7\uDFD6-\uDFFF]|\uD869[\uDED7-\uDEFF]|\uD83B[\uDC00-\uDDFF\uDE04\uDE20\uDE23\uDE25\uDE26\uDE28\uDE33\uDE38\uDE3A\uDE3C-\uDE41\uDE43-\uDE46\uDE48\uDE4A\uDE4C\uDE50\uDE53\uDE55\uDE56\uDE58\uDE5A\uDE5C\uDE5E\uDE60\uDE63\uDE65\uDE66\uDE6B\uDE73\uDE78\uDE7D\uDE7F\uDE8A\uDE9C-\uDEA0\uDEA4\uDEAA\uDEBC-\uDEEF\uDEF2-\uDFFF]|\uD87E[\uDE1E-\uDFFF]|\uDB40[\uDC00-\uDCFF\uDDF0-\uDFFF]|\uD804[\uDC4E-\uDC51\uDC70-\uDC7E\uDCBD\uDCC2-\uDCCF\uDCE9-\uDCEF\uDCFA-\uDCFF\uDD35\uDD44-\uDD4F\uDD77-\uDD7F\uDDCE\uDDCF\uDDE0\uDDF5-\uDDFF\uDE12\uDE3E-\uDE7F\uDE87\uDE89\uDE8E\uDE9E\uDEAA-\uDEAF\uDEEB-\uDEEF\uDEFA-\uDEFF\uDF04\uDF0D\uDF0E\uDF11\uDF12\uDF29\uDF31\uDF34\uDF3A\uDF3B\uDF45\uDF46\uDF49\uDF4A\uDF4E\uDF4F\uDF51-\uDF56\uDF58-\uDF5C\uDF64\uDF65\uDF6D-\uDF6F\uDF75-\uDFFF]|\uD83A[\uDCC5\uDCC6\uDCD7-\uDFFF]|\uD80D[\uDC2F-\uDFFF]|\uD86D[\uDF35-\uDF3F]|[\uD807\uD80A\uD80B\uD80E-\uD810\uD812-\uD819\uD81C-\uD82B\uD82D\uD82E\uD830-\uD833\uD837-\uD839\uD83F\uD874-\uD87D\uD87F-\uDB3F\uDB41-\uDBFF][\uDC00-\uDFFF]|\uD806[\uDC00-\uDC9F\uDCF3-\uDCFE\uDD00-\uDEBF\uDEF9-\uDFFF]|\uD803[\uDC49-\uDC7F\uDCB3-\uDCBF\uDCF3-\uDCF9\uDD00-\uDE5F\uDE7F-\uDFFF]|\uD835[\uDC55\uDC9D\uDCA0\uDCA1\uDCA3\uDCA4\uDCA7\uDCA8\uDCAD\uDCBA\uDCBC\uDCC4\uDD06\uDD0B\uDD0C\uDD15\uDD1D\uDD3A\uDD3F\uDD45\uDD47-\uDD49\uDD51\uDEA6\uDEA7\uDFCC\uDFCD]|\uD805[\uDC00-\uDC7F\uDCC8-\uDCCF\uDCDA-\uDD7F\uDDB6\uDDB7\uDDDE-\uDDFF\uDE45-\uDE4F\uDE5A-\uDE7F\uDEB8-\uDEBF\uDECA-\uDEFF\uDF1A-\uDF1C\uDF2C-\uDF2F\uDF40-\uDFFF]|\uD802[\uDC06\uDC07\uDC09\uDC36\uDC39-\uDC3B\uDC3D\uDC3E\uDC56\uDC9F-\uDCA6\uDCB0-\uDCDF\uDCF3\uDCF6-\uDCFA\uDD1C-\uDD1E\uDD3A-\uDD3E\uDD40-\uDD7F\uDDB8-\uDDBB\uDDD0\uDDD1\uDE04\uDE07-\uDE0B\uDE14\uDE18\uDE34-\uDE37\uDE3B-\uDE3E\uDE48-\uDE4F\uDE59-\uDE5F\uDEA0-\uDEBF\uDEE7-\uDEEA\uDEF7-\uDEFF\uDF36-\uDF38\uDF56\uDF57\uDF73-\uDF77\uDF92-\uDF98\uDF9D-\uDFA8\uDFB0-\uDFFF]|\uD808[\uDF9A-\uDFFF]|\uD82F[\uDC6B-\uDC6F\uDC7D-\uDC7F\uDC89-\uDC8F\uDC9A\uDC9B\uDCA0-\uDFFF]|\uD82C[\uDC02-\uDFFF]|\uD811[\uDE47-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE-\uDD0F\uDD19-\uDD7F\uDD85-\uDDBF\uDDC1-\uDFFF]|\uD873[\uDEA2-\uDFFF]'
        },
        {
            name: 'Cc',
            alias: 'Control',
            bmp: '\0-\x1F\x7F-\x9F'
        },
        {
            name: 'Cf',
            alias: 'Format',
            bmp: '\xAD\u0600-\u0605\u061C\u06DD\u070F\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB',
            astral: '\uDB40[\uDC01\uDC20-\uDC7F]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uD804\uDCBD'
        },
        {
            name: 'Cn',
            alias: 'Unassigned',
            bmp: '\u0378\u0379\u0380-\u0383\u038B\u038D\u03A2\u0530\u0557\u0558\u0560\u0588\u058B\u058C\u0590\u05C8-\u05CF\u05EB-\u05EF\u05F5-\u05FF\u061D\u070E\u074B\u074C\u07B2-\u07BF\u07FB-\u07FF\u082E\u082F\u083F\u085C\u085D\u085F-\u089F\u08B5-\u08E2\u0984\u098D\u098E\u0991\u0992\u09A9\u09B1\u09B3-\u09B5\u09BA\u09BB\u09C5\u09C6\u09C9\u09CA\u09CF-\u09D6\u09D8-\u09DB\u09DE\u09E4\u09E5\u09FC-\u0A00\u0A04\u0A0B-\u0A0E\u0A11\u0A12\u0A29\u0A31\u0A34\u0A37\u0A3A\u0A3B\u0A3D\u0A43-\u0A46\u0A49\u0A4A\u0A4E-\u0A50\u0A52-\u0A58\u0A5D\u0A5F-\u0A65\u0A76-\u0A80\u0A84\u0A8E\u0A92\u0AA9\u0AB1\u0AB4\u0ABA\u0ABB\u0AC6\u0ACA\u0ACE\u0ACF\u0AD1-\u0ADF\u0AE4\u0AE5\u0AF2-\u0AF8\u0AFA-\u0B00\u0B04\u0B0D\u0B0E\u0B11\u0B12\u0B29\u0B31\u0B34\u0B3A\u0B3B\u0B45\u0B46\u0B49\u0B4A\u0B4E-\u0B55\u0B58-\u0B5B\u0B5E\u0B64\u0B65\u0B78-\u0B81\u0B84\u0B8B-\u0B8D\u0B91\u0B96-\u0B98\u0B9B\u0B9D\u0BA0-\u0BA2\u0BA5-\u0BA7\u0BAB-\u0BAD\u0BBA-\u0BBD\u0BC3-\u0BC5\u0BC9\u0BCE\u0BCF\u0BD1-\u0BD6\u0BD8-\u0BE5\u0BFB-\u0BFF\u0C04\u0C0D\u0C11\u0C29\u0C3A-\u0C3C\u0C45\u0C49\u0C4E-\u0C54\u0C57\u0C5B-\u0C5F\u0C64\u0C65\u0C70-\u0C77\u0C80\u0C84\u0C8D\u0C91\u0CA9\u0CB4\u0CBA\u0CBB\u0CC5\u0CC9\u0CCE-\u0CD4\u0CD7-\u0CDD\u0CDF\u0CE4\u0CE5\u0CF0\u0CF3-\u0D00\u0D04\u0D0D\u0D11\u0D3B\u0D3C\u0D45\u0D49\u0D4F-\u0D56\u0D58-\u0D5E\u0D64\u0D65\u0D76-\u0D78\u0D80\u0D81\u0D84\u0D97-\u0D99\u0DB2\u0DBC\u0DBE\u0DBF\u0DC7-\u0DC9\u0DCB-\u0DCE\u0DD5\u0DD7\u0DE0-\u0DE5\u0DF0\u0DF1\u0DF5-\u0E00\u0E3B-\u0E3E\u0E5C-\u0E80\u0E83\u0E85\u0E86\u0E89\u0E8B\u0E8C\u0E8E-\u0E93\u0E98\u0EA0\u0EA4\u0EA6\u0EA8\u0EA9\u0EAC\u0EBA\u0EBE\u0EBF\u0EC5\u0EC7\u0ECE\u0ECF\u0EDA\u0EDB\u0EE0-\u0EFF\u0F48\u0F6D-\u0F70\u0F98\u0FBD\u0FCD\u0FDB-\u0FFF\u10C6\u10C8-\u10CC\u10CE\u10CF\u1249\u124E\u124F\u1257\u1259\u125E\u125F\u1289\u128E\u128F\u12B1\u12B6\u12B7\u12BF\u12C1\u12C6\u12C7\u12D7\u1311\u1316\u1317\u135B\u135C\u137D-\u137F\u139A-\u139F\u13F6\u13F7\u13FE\u13FF\u169D-\u169F\u16F9-\u16FF\u170D\u1715-\u171F\u1737-\u173F\u1754-\u175F\u176D\u1771\u1774-\u177F\u17DE\u17DF\u17EA-\u17EF\u17FA-\u17FF\u180F\u181A-\u181F\u1878-\u187F\u18AB-\u18AF\u18F6-\u18FF\u191F\u192C-\u192F\u193C-\u193F\u1941-\u1943\u196E\u196F\u1975-\u197F\u19AC-\u19AF\u19CA-\u19CF\u19DB-\u19DD\u1A1C\u1A1D\u1A5F\u1A7D\u1A7E\u1A8A-\u1A8F\u1A9A-\u1A9F\u1AAE\u1AAF\u1ABF-\u1AFF\u1B4C-\u1B4F\u1B7D-\u1B7F\u1BF4-\u1BFB\u1C38-\u1C3A\u1C4A-\u1C4C\u1C80-\u1CBF\u1CC8-\u1CCF\u1CF7\u1CFA-\u1CFF\u1DF6-\u1DFB\u1F16\u1F17\u1F1E\u1F1F\u1F46\u1F47\u1F4E\u1F4F\u1F58\u1F5A\u1F5C\u1F5E\u1F7E\u1F7F\u1FB5\u1FC5\u1FD4\u1FD5\u1FDC\u1FF0\u1FF1\u1FF5\u1FFF\u2065\u2072\u2073\u208F\u209D-\u209F\u20BF-\u20CF\u20F1-\u20FF\u218C-\u218F\u23FB-\u23FF\u2427-\u243F\u244B-\u245F\u2B74\u2B75\u2B96\u2B97\u2BBA-\u2BBC\u2BC9\u2BD2-\u2BEB\u2BF0-\u2BFF\u2C2F\u2C5F\u2CF4-\u2CF8\u2D26\u2D28-\u2D2C\u2D2E\u2D2F\u2D68-\u2D6E\u2D71-\u2D7E\u2D97-\u2D9F\u2DA7\u2DAF\u2DB7\u2DBF\u2DC7\u2DCF\u2DD7\u2DDF\u2E43-\u2E7F\u2E9A\u2EF4-\u2EFF\u2FD6-\u2FEF\u2FFC-\u2FFF\u3040\u3097\u3098\u3100-\u3104\u312E-\u3130\u318F\u31BB-\u31BF\u31E4-\u31EF\u321F\u32FF\u4DB6-\u4DBF\u9FD6-\u9FFF\uA48D-\uA48F\uA4C7-\uA4CF\uA62C-\uA63F\uA6F8-\uA6FF\uA7AE\uA7AF\uA7B8-\uA7F6\uA82C-\uA82F\uA83A-\uA83F\uA878-\uA87F\uA8C5-\uA8CD\uA8DA-\uA8DF\uA8FE\uA8FF\uA954-\uA95E\uA97D-\uA97F\uA9CE\uA9DA-\uA9DD\uA9FF\uAA37-\uAA3F\uAA4E\uAA4F\uAA5A\uAA5B\uAAC3-\uAADA\uAAF7-\uAB00\uAB07\uAB08\uAB0F\uAB10\uAB17-\uAB1F\uAB27\uAB2F\uAB66-\uAB6F\uABEE\uABEF\uABFA-\uABFF\uD7A4-\uD7AF\uD7C7-\uD7CA\uD7FC-\uD7FF\uFA6E\uFA6F\uFADA-\uFAFF\uFB07-\uFB12\uFB18-\uFB1C\uFB37\uFB3D\uFB3F\uFB42\uFB45\uFBC2-\uFBD2\uFD40-\uFD4F\uFD90\uFD91\uFDC8-\uFDEF\uFDFE\uFDFF\uFE1A-\uFE1F\uFE53\uFE67\uFE6C-\uFE6F\uFE75\uFEFD\uFEFE\uFF00\uFFBF-\uFFC1\uFFC8\uFFC9\uFFD0\uFFD1\uFFD8\uFFD9\uFFDD-\uFFDF\uFFE7\uFFEF-\uFFF8\uFFFE\uFFFF',
            astral: '\uDB40[\uDC00\uDC02-\uDC1F\uDC80-\uDCFF\uDDF0-\uDFFF]|\uD834[\uDCF6-\uDCFF\uDD27\uDD28\uDDE9-\uDDFF\uDE46-\uDEFF\uDF57-\uDF5F\uDF72-\uDFFF]|\uD83C[\uDC2C-\uDC2F\uDC94-\uDC9F\uDCAF\uDCB0\uDCC0\uDCD0\uDCF6-\uDCFF\uDD0D-\uDD0F\uDD2F\uDD6C-\uDD6F\uDD9B-\uDDE5\uDE03-\uDE0F\uDE3B-\uDE3F\uDE49-\uDE4F\uDE52-\uDEFF]|\uD81A[\uDE39-\uDE3F\uDE5F\uDE6A-\uDE6D\uDE70-\uDECF\uDEEE\uDEEF\uDEF6-\uDEFF\uDF46-\uDF4F\uDF5A\uDF62\uDF78-\uDF7C\uDF90-\uDFFF]|\uD809[\uDC6F\uDC75-\uDC7F\uDD44-\uDFFF]|\uD81B[\uDC00-\uDEFF\uDF45-\uDF4F\uDF7F-\uDF8E\uDFA0-\uDFFF]|\uD86E[\uDC1E\uDC1F]|\uD83D[\uDD7A\uDDA4\uDED1-\uDEDF\uDEED-\uDEEF\uDEF4-\uDEFF\uDF74-\uDF7F\uDFD5-\uDFFF]|\uD801[\uDC9E\uDC9F\uDCAA-\uDCFF\uDD28-\uDD2F\uDD64-\uDD6E\uDD70-\uDDFF\uDF37-\uDF3F\uDF56-\uDF5F\uDF68-\uDFFF]|\uD800[\uDC0C\uDC27\uDC3B\uDC3E\uDC4E\uDC4F\uDC5E-\uDC7F\uDCFB-\uDCFF\uDD03-\uDD06\uDD34-\uDD36\uDD8D-\uDD8F\uDD9C-\uDD9F\uDDA1-\uDDCF\uDDFE-\uDE7F\uDE9D-\uDE9F\uDED1-\uDEDF\uDEFC-\uDEFF\uDF24-\uDF2F\uDF4B-\uDF4F\uDF7B-\uDF7F\uDF9E\uDFC4-\uDFC7\uDFD6-\uDFFF]|\uD869[\uDED7-\uDEFF]|\uD83B[\uDC00-\uDDFF\uDE04\uDE20\uDE23\uDE25\uDE26\uDE28\uDE33\uDE38\uDE3A\uDE3C-\uDE41\uDE43-\uDE46\uDE48\uDE4A\uDE4C\uDE50\uDE53\uDE55\uDE56\uDE58\uDE5A\uDE5C\uDE5E\uDE60\uDE63\uDE65\uDE66\uDE6B\uDE73\uDE78\uDE7D\uDE7F\uDE8A\uDE9C-\uDEA0\uDEA4\uDEAA\uDEBC-\uDEEF\uDEF2-\uDFFF]|[\uDBBF\uDBFF][\uDFFE\uDFFF]|\uD87E[\uDE1E-\uDFFF]|\uD82F[\uDC6B-\uDC6F\uDC7D-\uDC7F\uDC89-\uDC8F\uDC9A\uDC9B\uDCA4-\uDFFF]|\uD83A[\uDCC5\uDCC6\uDCD7-\uDFFF]|\uD80D[\uDC2F-\uDFFF]|\uD86D[\uDF35-\uDF3F]|[\uD807\uD80A\uD80B\uD80E-\uD810\uD812-\uD819\uD81C-\uD82B\uD82D\uD82E\uD830-\uD833\uD837-\uD839\uD83F\uD874-\uD87D\uD87F-\uDB3F\uDB41-\uDB7F][\uDC00-\uDFFF]|\uD806[\uDC00-\uDC9F\uDCF3-\uDCFE\uDD00-\uDEBF\uDEF9-\uDFFF]|\uD803[\uDC49-\uDC7F\uDCB3-\uDCBF\uDCF3-\uDCF9\uDD00-\uDE5F\uDE7F-\uDFFF]|\uD835[\uDC55\uDC9D\uDCA0\uDCA1\uDCA3\uDCA4\uDCA7\uDCA8\uDCAD\uDCBA\uDCBC\uDCC4\uDD06\uDD0B\uDD0C\uDD15\uDD1D\uDD3A\uDD3F\uDD45\uDD47-\uDD49\uDD51\uDEA6\uDEA7\uDFCC\uDFCD]|\uD836[\uDE8C-\uDE9A\uDEA0\uDEB0-\uDFFF]|\uD805[\uDC00-\uDC7F\uDCC8-\uDCCF\uDCDA-\uDD7F\uDDB6\uDDB7\uDDDE-\uDDFF\uDE45-\uDE4F\uDE5A-\uDE7F\uDEB8-\uDEBF\uDECA-\uDEFF\uDF1A-\uDF1C\uDF2C-\uDF2F\uDF40-\uDFFF]|\uD802[\uDC06\uDC07\uDC09\uDC36\uDC39-\uDC3B\uDC3D\uDC3E\uDC56\uDC9F-\uDCA6\uDCB0-\uDCDF\uDCF3\uDCF6-\uDCFA\uDD1C-\uDD1E\uDD3A-\uDD3E\uDD40-\uDD7F\uDDB8-\uDDBB\uDDD0\uDDD1\uDE04\uDE07-\uDE0B\uDE14\uDE18\uDE34-\uDE37\uDE3B-\uDE3E\uDE48-\uDE4F\uDE59-\uDE5F\uDEA0-\uDEBF\uDEE7-\uDEEA\uDEF7-\uDEFF\uDF36-\uDF38\uDF56\uDF57\uDF73-\uDF77\uDF92-\uDF98\uDF9D-\uDFA8\uDFB0-\uDFFF]|\uD808[\uDF9A-\uDFFF]|\uD804[\uDC4E-\uDC51\uDC70-\uDC7E\uDCC2-\uDCCF\uDCE9-\uDCEF\uDCFA-\uDCFF\uDD35\uDD44-\uDD4F\uDD77-\uDD7F\uDDCE\uDDCF\uDDE0\uDDF5-\uDDFF\uDE12\uDE3E-\uDE7F\uDE87\uDE89\uDE8E\uDE9E\uDEAA-\uDEAF\uDEEB-\uDEEF\uDEFA-\uDEFF\uDF04\uDF0D\uDF0E\uDF11\uDF12\uDF29\uDF31\uDF34\uDF3A\uDF3B\uDF45\uDF46\uDF49\uDF4A\uDF4E\uDF4F\uDF51-\uDF56\uDF58-\uDF5C\uDF64\uDF65\uDF6D-\uDF6F\uDF75-\uDFFF]|\uD82C[\uDC02-\uDFFF]|\uD811[\uDE47-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE-\uDD0F\uDD19-\uDD7F\uDD85-\uDDBF\uDDC1-\uDFFF]|\uD873[\uDEA2-\uDFFF]'
        },
        {
            name: 'Co',
            alias: 'Private_Use',
            bmp: '\uE000-\uF8FF',
            astral: '[\uDB80-\uDBBE\uDBC0-\uDBFE][\uDC00-\uDFFF]|[\uDBBF\uDBFF][\uDC00-\uDFFD]'
        },
        {
            name: 'Cs',
            alias: 'Surrogate',
            bmp: '\uD800-\uDFFF'
        },
        {
            name: 'L',
            alias: 'Letter',
            bmp: 'A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC',
            astral: '\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD83A[\uDC00-\uDCC4]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD80D[\uDC00-\uDC2E]|\uD87E[\uDC00-\uDE1D]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD809[\uDC80-\uDD43]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD808[\uDC00-\uDF99]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD811[\uDC00-\uDE46]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD82C[\uDC00\uDC01]|\uD873[\uDC00-\uDEA1]'
        },
        {
            name: 'Ll',
            alias: 'Lowercase_Letter',
            bmp: 'a-z\xB5\xDF-\xF6\xF8-\xFF\u0101\u0103\u0105\u0107\u0109\u010B\u010D\u010F\u0111\u0113\u0115\u0117\u0119\u011B\u011D\u011F\u0121\u0123\u0125\u0127\u0129\u012B\u012D\u012F\u0131\u0133\u0135\u0137\u0138\u013A\u013C\u013E\u0140\u0142\u0144\u0146\u0148\u0149\u014B\u014D\u014F\u0151\u0153\u0155\u0157\u0159\u015B\u015D\u015F\u0161\u0163\u0165\u0167\u0169\u016B\u016D\u016F\u0171\u0173\u0175\u0177\u017A\u017C\u017E-\u0180\u0183\u0185\u0188\u018C\u018D\u0192\u0195\u0199-\u019B\u019E\u01A1\u01A3\u01A5\u01A8\u01AA\u01AB\u01AD\u01B0\u01B4\u01B6\u01B9\u01BA\u01BD-\u01BF\u01C6\u01C9\u01CC\u01CE\u01D0\u01D2\u01D4\u01D6\u01D8\u01DA\u01DC\u01DD\u01DF\u01E1\u01E3\u01E5\u01E7\u01E9\u01EB\u01ED\u01EF\u01F0\u01F3\u01F5\u01F9\u01FB\u01FD\u01FF\u0201\u0203\u0205\u0207\u0209\u020B\u020D\u020F\u0211\u0213\u0215\u0217\u0219\u021B\u021D\u021F\u0221\u0223\u0225\u0227\u0229\u022B\u022D\u022F\u0231\u0233-\u0239\u023C\u023F\u0240\u0242\u0247\u0249\u024B\u024D\u024F-\u0293\u0295-\u02AF\u0371\u0373\u0377\u037B-\u037D\u0390\u03AC-\u03CE\u03D0\u03D1\u03D5-\u03D7\u03D9\u03DB\u03DD\u03DF\u03E1\u03E3\u03E5\u03E7\u03E9\u03EB\u03ED\u03EF-\u03F3\u03F5\u03F8\u03FB\u03FC\u0430-\u045F\u0461\u0463\u0465\u0467\u0469\u046B\u046D\u046F\u0471\u0473\u0475\u0477\u0479\u047B\u047D\u047F\u0481\u048B\u048D\u048F\u0491\u0493\u0495\u0497\u0499\u049B\u049D\u049F\u04A1\u04A3\u04A5\u04A7\u04A9\u04AB\u04AD\u04AF\u04B1\u04B3\u04B5\u04B7\u04B9\u04BB\u04BD\u04BF\u04C2\u04C4\u04C6\u04C8\u04CA\u04CC\u04CE\u04CF\u04D1\u04D3\u04D5\u04D7\u04D9\u04DB\u04DD\u04DF\u04E1\u04E3\u04E5\u04E7\u04E9\u04EB\u04ED\u04EF\u04F1\u04F3\u04F5\u04F7\u04F9\u04FB\u04FD\u04FF\u0501\u0503\u0505\u0507\u0509\u050B\u050D\u050F\u0511\u0513\u0515\u0517\u0519\u051B\u051D\u051F\u0521\u0523\u0525\u0527\u0529\u052B\u052D\u052F\u0561-\u0587\u13F8-\u13FD\u1D00-\u1D2B\u1D6B-\u1D77\u1D79-\u1D9A\u1E01\u1E03\u1E05\u1E07\u1E09\u1E0B\u1E0D\u1E0F\u1E11\u1E13\u1E15\u1E17\u1E19\u1E1B\u1E1D\u1E1F\u1E21\u1E23\u1E25\u1E27\u1E29\u1E2B\u1E2D\u1E2F\u1E31\u1E33\u1E35\u1E37\u1E39\u1E3B\u1E3D\u1E3F\u1E41\u1E43\u1E45\u1E47\u1E49\u1E4B\u1E4D\u1E4F\u1E51\u1E53\u1E55\u1E57\u1E59\u1E5B\u1E5D\u1E5F\u1E61\u1E63\u1E65\u1E67\u1E69\u1E6B\u1E6D\u1E6F\u1E71\u1E73\u1E75\u1E77\u1E79\u1E7B\u1E7D\u1E7F\u1E81\u1E83\u1E85\u1E87\u1E89\u1E8B\u1E8D\u1E8F\u1E91\u1E93\u1E95-\u1E9D\u1E9F\u1EA1\u1EA3\u1EA5\u1EA7\u1EA9\u1EAB\u1EAD\u1EAF\u1EB1\u1EB3\u1EB5\u1EB7\u1EB9\u1EBB\u1EBD\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7\u1EC9\u1ECB\u1ECD\u1ECF\u1ED1\u1ED3\u1ED5\u1ED7\u1ED9\u1EDB\u1EDD\u1EDF\u1EE1\u1EE3\u1EE5\u1EE7\u1EE9\u1EEB\u1EED\u1EEF\u1EF1\u1EF3\u1EF5\u1EF7\u1EF9\u1EFB\u1EFD\u1EFF-\u1F07\u1F10-\u1F15\u1F20-\u1F27\u1F30-\u1F37\u1F40-\u1F45\u1F50-\u1F57\u1F60-\u1F67\u1F70-\u1F7D\u1F80-\u1F87\u1F90-\u1F97\u1FA0-\u1FA7\u1FB0-\u1FB4\u1FB6\u1FB7\u1FBE\u1FC2-\u1FC4\u1FC6\u1FC7\u1FD0-\u1FD3\u1FD6\u1FD7\u1FE0-\u1FE7\u1FF2-\u1FF4\u1FF6\u1FF7\u210A\u210E\u210F\u2113\u212F\u2134\u2139\u213C\u213D\u2146-\u2149\u214E\u2184\u2C30-\u2C5E\u2C61\u2C65\u2C66\u2C68\u2C6A\u2C6C\u2C71\u2C73\u2C74\u2C76-\u2C7B\u2C81\u2C83\u2C85\u2C87\u2C89\u2C8B\u2C8D\u2C8F\u2C91\u2C93\u2C95\u2C97\u2C99\u2C9B\u2C9D\u2C9F\u2CA1\u2CA3\u2CA5\u2CA7\u2CA9\u2CAB\u2CAD\u2CAF\u2CB1\u2CB3\u2CB5\u2CB7\u2CB9\u2CBB\u2CBD\u2CBF\u2CC1\u2CC3\u2CC5\u2CC7\u2CC9\u2CCB\u2CCD\u2CCF\u2CD1\u2CD3\u2CD5\u2CD7\u2CD9\u2CDB\u2CDD\u2CDF\u2CE1\u2CE3\u2CE4\u2CEC\u2CEE\u2CF3\u2D00-\u2D25\u2D27\u2D2D\uA641\uA643\uA645\uA647\uA649\uA64B\uA64D\uA64F\uA651\uA653\uA655\uA657\uA659\uA65B\uA65D\uA65F\uA661\uA663\uA665\uA667\uA669\uA66B\uA66D\uA681\uA683\uA685\uA687\uA689\uA68B\uA68D\uA68F\uA691\uA693\uA695\uA697\uA699\uA69B\uA723\uA725\uA727\uA729\uA72B\uA72D\uA72F-\uA731\uA733\uA735\uA737\uA739\uA73B\uA73D\uA73F\uA741\uA743\uA745\uA747\uA749\uA74B\uA74D\uA74F\uA751\uA753\uA755\uA757\uA759\uA75B\uA75D\uA75F\uA761\uA763\uA765\uA767\uA769\uA76B\uA76D\uA76F\uA771-\uA778\uA77A\uA77C\uA77F\uA781\uA783\uA785\uA787\uA78C\uA78E\uA791\uA793-\uA795\uA797\uA799\uA79B\uA79D\uA79F\uA7A1\uA7A3\uA7A5\uA7A7\uA7A9\uA7B5\uA7B7\uA7FA\uAB30-\uAB5A\uAB60-\uAB65\uAB70-\uABBF\uFB00-\uFB06\uFB13-\uFB17\uFF41-\uFF5A',
            astral: '\uD803[\uDCC0-\uDCF2]|\uD835[\uDC1A-\uDC33\uDC4E-\uDC54\uDC56-\uDC67\uDC82-\uDC9B\uDCB6-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDCEA-\uDD03\uDD1E-\uDD37\uDD52-\uDD6B\uDD86-\uDD9F\uDDBA-\uDDD3\uDDEE-\uDE07\uDE22-\uDE3B\uDE56-\uDE6F\uDE8A-\uDEA5\uDEC2-\uDEDA\uDEDC-\uDEE1\uDEFC-\uDF14\uDF16-\uDF1B\uDF36-\uDF4E\uDF50-\uDF55\uDF70-\uDF88\uDF8A-\uDF8F\uDFAA-\uDFC2\uDFC4-\uDFC9\uDFCB]|\uD801[\uDC28-\uDC4F]|\uD806[\uDCC0-\uDCDF]'
        },
        {
            name: 'Lm',
            alias: 'Modifier_Letter',
            bmp: '\u02B0-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0374\u037A\u0559\u0640\u06E5\u06E6\u07F4\u07F5\u07FA\u081A\u0824\u0828\u0971\u0E46\u0EC6\u10FC\u17D7\u1843\u1AA7\u1C78-\u1C7D\u1D2C-\u1D6A\u1D78\u1D9B-\u1DBF\u2071\u207F\u2090-\u209C\u2C7C\u2C7D\u2D6F\u2E2F\u3005\u3031-\u3035\u303B\u309D\u309E\u30FC-\u30FE\uA015\uA4F8-\uA4FD\uA60C\uA67F\uA69C\uA69D\uA717-\uA71F\uA770\uA788\uA7F8\uA7F9\uA9CF\uA9E6\uAA70\uAADD\uAAF3\uAAF4\uAB5C-\uAB5F\uFF70\uFF9E\uFF9F',
            astral: '\uD81A[\uDF40-\uDF43]|\uD81B[\uDF93-\uDF9F]'
        },
        {
            name: 'Lo',
            alias: 'Other_Letter',
            bmp: '\xAA\xBA\u01BB\u01C0-\u01C3\u0294\u05D0-\u05EA\u05F0-\u05F2\u0620-\u063F\u0641-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u0800-\u0815\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0972-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E45\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10D0-\u10FA\u10FD-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17DC\u1820-\u1842\u1844-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C77\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u2135-\u2138\u2D30-\u2D67\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3006\u303C\u3041-\u3096\u309F\u30A1-\u30FA\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA014\uA016-\uA48C\uA4D0-\uA4F7\uA500-\uA60B\uA610-\uA61F\uA62A\uA62B\uA66E\uA6A0-\uA6E5\uA78F\uA7F7\uA7FB-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9E0-\uA9E4\uA9E7-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA6F\uAA71-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB\uAADC\uAAE0-\uAAEA\uAAF2\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF66-\uFF6F\uFF71-\uFF9D\uFFA0-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC',
            astral: '\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD83A[\uDC00-\uDCC4]|\uD803[\uDC00-\uDC48]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD80D[\uDC00-\uDC2E]|\uD87E[\uDC00-\uDE1D]|\uD81B[\uDF00-\uDF44\uDF50]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCFF\uDEC0-\uDEF8]|\uD809[\uDC80-\uDD43]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD808[\uDC00-\uDF99]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF63-\uDF77\uDF7D-\uDF8F]|\uD801[\uDC50-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD811[\uDC00-\uDE46]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD82C[\uDC00\uDC01]|\uD873[\uDC00-\uDEA1]'
        },
        {
            name: 'Lt',
            alias: 'Titlecase_Letter',
            bmp: '\u01C5\u01C8\u01CB\u01F2\u1F88-\u1F8F\u1F98-\u1F9F\u1FA8-\u1FAF\u1FBC\u1FCC\u1FFC'
        },
        {
            name: 'Lu',
            alias: 'Uppercase_Letter',
            bmp: 'A-Z\xC0-\xD6\xD8-\xDE\u0100\u0102\u0104\u0106\u0108\u010A\u010C\u010E\u0110\u0112\u0114\u0116\u0118\u011A\u011C\u011E\u0120\u0122\u0124\u0126\u0128\u012A\u012C\u012E\u0130\u0132\u0134\u0136\u0139\u013B\u013D\u013F\u0141\u0143\u0145\u0147\u014A\u014C\u014E\u0150\u0152\u0154\u0156\u0158\u015A\u015C\u015E\u0160\u0162\u0164\u0166\u0168\u016A\u016C\u016E\u0170\u0172\u0174\u0176\u0178\u0179\u017B\u017D\u0181\u0182\u0184\u0186\u0187\u0189-\u018B\u018E-\u0191\u0193\u0194\u0196-\u0198\u019C\u019D\u019F\u01A0\u01A2\u01A4\u01A6\u01A7\u01A9\u01AC\u01AE\u01AF\u01B1-\u01B3\u01B5\u01B7\u01B8\u01BC\u01C4\u01C7\u01CA\u01CD\u01CF\u01D1\u01D3\u01D5\u01D7\u01D9\u01DB\u01DE\u01E0\u01E2\u01E4\u01E6\u01E8\u01EA\u01EC\u01EE\u01F1\u01F4\u01F6-\u01F8\u01FA\u01FC\u01FE\u0200\u0202\u0204\u0206\u0208\u020A\u020C\u020E\u0210\u0212\u0214\u0216\u0218\u021A\u021C\u021E\u0220\u0222\u0224\u0226\u0228\u022A\u022C\u022E\u0230\u0232\u023A\u023B\u023D\u023E\u0241\u0243-\u0246\u0248\u024A\u024C\u024E\u0370\u0372\u0376\u037F\u0386\u0388-\u038A\u038C\u038E\u038F\u0391-\u03A1\u03A3-\u03AB\u03CF\u03D2-\u03D4\u03D8\u03DA\u03DC\u03DE\u03E0\u03E2\u03E4\u03E6\u03E8\u03EA\u03EC\u03EE\u03F4\u03F7\u03F9\u03FA\u03FD-\u042F\u0460\u0462\u0464\u0466\u0468\u046A\u046C\u046E\u0470\u0472\u0474\u0476\u0478\u047A\u047C\u047E\u0480\u048A\u048C\u048E\u0490\u0492\u0494\u0496\u0498\u049A\u049C\u049E\u04A0\u04A2\u04A4\u04A6\u04A8\u04AA\u04AC\u04AE\u04B0\u04B2\u04B4\u04B6\u04B8\u04BA\u04BC\u04BE\u04C0\u04C1\u04C3\u04C5\u04C7\u04C9\u04CB\u04CD\u04D0\u04D2\u04D4\u04D6\u04D8\u04DA\u04DC\u04DE\u04E0\u04E2\u04E4\u04E6\u04E8\u04EA\u04EC\u04EE\u04F0\u04F2\u04F4\u04F6\u04F8\u04FA\u04FC\u04FE\u0500\u0502\u0504\u0506\u0508\u050A\u050C\u050E\u0510\u0512\u0514\u0516\u0518\u051A\u051C\u051E\u0520\u0522\u0524\u0526\u0528\u052A\u052C\u052E\u0531-\u0556\u10A0-\u10C5\u10C7\u10CD\u13A0-\u13F5\u1E00\u1E02\u1E04\u1E06\u1E08\u1E0A\u1E0C\u1E0E\u1E10\u1E12\u1E14\u1E16\u1E18\u1E1A\u1E1C\u1E1E\u1E20\u1E22\u1E24\u1E26\u1E28\u1E2A\u1E2C\u1E2E\u1E30\u1E32\u1E34\u1E36\u1E38\u1E3A\u1E3C\u1E3E\u1E40\u1E42\u1E44\u1E46\u1E48\u1E4A\u1E4C\u1E4E\u1E50\u1E52\u1E54\u1E56\u1E58\u1E5A\u1E5C\u1E5E\u1E60\u1E62\u1E64\u1E66\u1E68\u1E6A\u1E6C\u1E6E\u1E70\u1E72\u1E74\u1E76\u1E78\u1E7A\u1E7C\u1E7E\u1E80\u1E82\u1E84\u1E86\u1E88\u1E8A\u1E8C\u1E8E\u1E90\u1E92\u1E94\u1E9E\u1EA0\u1EA2\u1EA4\u1EA6\u1EA8\u1EAA\u1EAC\u1EAE\u1EB0\u1EB2\u1EB4\u1EB6\u1EB8\u1EBA\u1EBC\u1EBE\u1EC0\u1EC2\u1EC4\u1EC6\u1EC8\u1ECA\u1ECC\u1ECE\u1ED0\u1ED2\u1ED4\u1ED6\u1ED8\u1EDA\u1EDC\u1EDE\u1EE0\u1EE2\u1EE4\u1EE6\u1EE8\u1EEA\u1EEC\u1EEE\u1EF0\u1EF2\u1EF4\u1EF6\u1EF8\u1EFA\u1EFC\u1EFE\u1F08-\u1F0F\u1F18-\u1F1D\u1F28-\u1F2F\u1F38-\u1F3F\u1F48-\u1F4D\u1F59\u1F5B\u1F5D\u1F5F\u1F68-\u1F6F\u1FB8-\u1FBB\u1FC8-\u1FCB\u1FD8-\u1FDB\u1FE8-\u1FEC\u1FF8-\u1FFB\u2102\u2107\u210B-\u210D\u2110-\u2112\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u2130-\u2133\u213E\u213F\u2145\u2183\u2C00-\u2C2E\u2C60\u2C62-\u2C64\u2C67\u2C69\u2C6B\u2C6D-\u2C70\u2C72\u2C75\u2C7E-\u2C80\u2C82\u2C84\u2C86\u2C88\u2C8A\u2C8C\u2C8E\u2C90\u2C92\u2C94\u2C96\u2C98\u2C9A\u2C9C\u2C9E\u2CA0\u2CA2\u2CA4\u2CA6\u2CA8\u2CAA\u2CAC\u2CAE\u2CB0\u2CB2\u2CB4\u2CB6\u2CB8\u2CBA\u2CBC\u2CBE\u2CC0\u2CC2\u2CC4\u2CC6\u2CC8\u2CCA\u2CCC\u2CCE\u2CD0\u2CD2\u2CD4\u2CD6\u2CD8\u2CDA\u2CDC\u2CDE\u2CE0\u2CE2\u2CEB\u2CED\u2CF2\uA640\uA642\uA644\uA646\uA648\uA64A\uA64C\uA64E\uA650\uA652\uA654\uA656\uA658\uA65A\uA65C\uA65E\uA660\uA662\uA664\uA666\uA668\uA66A\uA66C\uA680\uA682\uA684\uA686\uA688\uA68A\uA68C\uA68E\uA690\uA692\uA694\uA696\uA698\uA69A\uA722\uA724\uA726\uA728\uA72A\uA72C\uA72E\uA732\uA734\uA736\uA738\uA73A\uA73C\uA73E\uA740\uA742\uA744\uA746\uA748\uA74A\uA74C\uA74E\uA750\uA752\uA754\uA756\uA758\uA75A\uA75C\uA75E\uA760\uA762\uA764\uA766\uA768\uA76A\uA76C\uA76E\uA779\uA77B\uA77D\uA77E\uA780\uA782\uA784\uA786\uA78B\uA78D\uA790\uA792\uA796\uA798\uA79A\uA79C\uA79E\uA7A0\uA7A2\uA7A4\uA7A6\uA7A8\uA7AA-\uA7AD\uA7B0-\uA7B4\uA7B6\uFF21-\uFF3A',
            astral: '\uD806[\uDCA0-\uDCBF]|\uD803[\uDC80-\uDCB2]|\uD801[\uDC00-\uDC27]|\uD835[\uDC00-\uDC19\uDC34-\uDC4D\uDC68-\uDC81\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB5\uDCD0-\uDCE9\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD38\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD6C-\uDD85\uDDA0-\uDDB9\uDDD4-\uDDED\uDE08-\uDE21\uDE3C-\uDE55\uDE70-\uDE89\uDEA8-\uDEC0\uDEE2-\uDEFA\uDF1C-\uDF34\uDF56-\uDF6E\uDF90-\uDFA8\uDFCA]'
        },
        {
            name: 'M',
            alias: 'Mark',
            bmp: '\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D01-\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u192B\u1930-\u193B\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFC-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F',
            astral: '\uD805[\uDCB0-\uDCC3\uDDAF-\uDDB5\uDDB8-\uDDC0\uDDDC\uDDDD\uDE30-\uDE40\uDEAB-\uDEB7\uDF1D-\uDF2B]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD804[\uDC00-\uDC02\uDC38-\uDC46\uDC7F-\uDC82\uDCB0-\uDCBA\uDD00-\uDD02\uDD27-\uDD34\uDD73\uDD80-\uDD82\uDDB3-\uDDC0\uDDCA-\uDDCC\uDE2C-\uDE37\uDEDF-\uDEEA\uDF00-\uDF03\uDF3C\uDF3E-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD81B[\uDF51-\uDF7E\uDF8F-\uDF92]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD82F[\uDC9D\uDC9E]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD83A[\uDCD0-\uDCD6]|\uDB40[\uDD00-\uDDEF]'
        },
        {
            name: 'Mc',
            alias: 'Spacing_Mark',
            bmp: '\u0903\u093B\u093E-\u0940\u0949-\u094C\u094E\u094F\u0982\u0983\u09BE-\u09C0\u09C7\u09C8\u09CB\u09CC\u09D7\u0A03\u0A3E-\u0A40\u0A83\u0ABE-\u0AC0\u0AC9\u0ACB\u0ACC\u0B02\u0B03\u0B3E\u0B40\u0B47\u0B48\u0B4B\u0B4C\u0B57\u0BBE\u0BBF\u0BC1\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0BD7\u0C01-\u0C03\u0C41-\u0C44\u0C82\u0C83\u0CBE\u0CC0-\u0CC4\u0CC7\u0CC8\u0CCA\u0CCB\u0CD5\u0CD6\u0D02\u0D03\u0D3E-\u0D40\u0D46-\u0D48\u0D4A-\u0D4C\u0D57\u0D82\u0D83\u0DCF-\u0DD1\u0DD8-\u0DDF\u0DF2\u0DF3\u0F3E\u0F3F\u0F7F\u102B\u102C\u1031\u1038\u103B\u103C\u1056\u1057\u1062-\u1064\u1067-\u106D\u1083\u1084\u1087-\u108C\u108F\u109A-\u109C\u17B6\u17BE-\u17C5\u17C7\u17C8\u1923-\u1926\u1929-\u192B\u1930\u1931\u1933-\u1938\u1A19\u1A1A\u1A55\u1A57\u1A61\u1A63\u1A64\u1A6D-\u1A72\u1B04\u1B35\u1B3B\u1B3D-\u1B41\u1B43\u1B44\u1B82\u1BA1\u1BA6\u1BA7\u1BAA\u1BE7\u1BEA-\u1BEC\u1BEE\u1BF2\u1BF3\u1C24-\u1C2B\u1C34\u1C35\u1CE1\u1CF2\u1CF3\u302E\u302F\uA823\uA824\uA827\uA880\uA881\uA8B4-\uA8C3\uA952\uA953\uA983\uA9B4\uA9B5\uA9BA\uA9BB\uA9BD-\uA9C0\uAA2F\uAA30\uAA33\uAA34\uAA4D\uAA7B\uAA7D\uAAEB\uAAEE\uAAEF\uAAF5\uABE3\uABE4\uABE6\uABE7\uABE9\uABEA\uABEC',
            astral: '\uD834[\uDD65\uDD66\uDD6D-\uDD72]|\uD804[\uDC00\uDC02\uDC82\uDCB0-\uDCB2\uDCB7\uDCB8\uDD2C\uDD82\uDDB3-\uDDB5\uDDBF\uDDC0\uDE2C-\uDE2E\uDE32\uDE33\uDE35\uDEE0-\uDEE2\uDF02\uDF03\uDF3E\uDF3F\uDF41-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63]|\uD805[\uDCB0-\uDCB2\uDCB9\uDCBB-\uDCBE\uDCC1\uDDAF-\uDDB1\uDDB8-\uDDBB\uDDBE\uDE30-\uDE32\uDE3B\uDE3C\uDE3E\uDEAC\uDEAE\uDEAF\uDEB6\uDF20\uDF21\uDF26]|\uD81B[\uDF51-\uDF7E]'
        },
        {
            name: 'Me',
            alias: 'Enclosing_Mark',
            bmp: '\u0488\u0489\u1ABE\u20DD-\u20E0\u20E2-\u20E4\uA670-\uA672'
        },
        {
            name: 'Mn',
            alias: 'Nonspacing_Mark',
            bmp: '\u0300-\u036F\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0C00\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC6\u0CCC\u0CCD\u0CE2\u0CE3\u0D01\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ABD\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFC-\u1DFF\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u3099\u309A\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F',
            astral: '\uD805[\uDCB3-\uDCB8\uDCBA\uDCBF\uDCC0\uDCC2\uDCC3\uDDB2-\uDDB5\uDDBC\uDDBD\uDDBF\uDDC0\uDDDC\uDDDD\uDE33-\uDE3A\uDE3D\uDE3F\uDE40\uDEAB\uDEAD\uDEB0-\uDEB5\uDEB7\uDF1D-\uDF1F\uDF22-\uDF25\uDF27-\uDF2B]|\uD834[\uDD67-\uDD69\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF8F-\uDF92]|\uD82F[\uDC9D\uDC9E]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD804[\uDC01\uDC38-\uDC46\uDC7F-\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDD00-\uDD02\uDD27-\uDD2B\uDD2D-\uDD34\uDD73\uDD80\uDD81\uDDB6-\uDDBE\uDDCA-\uDDCC\uDE2F-\uDE31\uDE34\uDE36\uDE37\uDEDF\uDEE3-\uDEEA\uDF00\uDF01\uDF3C\uDF40\uDF66-\uDF6C\uDF70-\uDF74]|\uD83A[\uDCD0-\uDCD6]|\uDB40[\uDD00-\uDDEF]'
        },
        {
            name: 'N',
            alias: 'Number',
            bmp: '0-9\xB2\xB3\xB9\xBC-\xBE\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u09F4-\u09F9\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0B72-\u0B77\u0BE6-\u0BF2\u0C66-\u0C6F\u0C78-\u0C7E\u0CE6-\u0CEF\u0D66-\u0D75\u0DE6-\u0DEF\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F33\u1040-\u1049\u1090-\u1099\u1369-\u137C\u16EE-\u16F0\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1946-\u194F\u19D0-\u19DA\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\u2070\u2074-\u2079\u2080-\u2089\u2150-\u2182\u2185-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2CFD\u3007\u3021-\u3029\u3038-\u303A\u3192-\u3195\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\uA620-\uA629\uA6E6-\uA6EF\uA830-\uA835\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uA9F0-\uA9F9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19',
            astral: '\uD800[\uDD07-\uDD33\uDD40-\uDD78\uDD8A\uDD8B\uDEE1-\uDEFB\uDF20-\uDF23\uDF41\uDF4A\uDFD1-\uDFD5]|\uD801[\uDCA0-\uDCA9]|\uD803[\uDCFA-\uDCFF\uDE60-\uDE7E]|\uD835[\uDFCE-\uDFFF]|\uD83A[\uDCC7-\uDCCF]|\uD81A[\uDE60-\uDE69\uDF50-\uDF59\uDF5B-\uDF61]|\uD806[\uDCE0-\uDCF2]|\uD804[\uDC52-\uDC6F\uDCF0-\uDCF9\uDD36-\uDD3F\uDDD0-\uDDD9\uDDE1-\uDDF4\uDEF0-\uDEF9]|\uD834[\uDF60-\uDF71]|\uD83C[\uDD00-\uDD0C]|\uD809[\uDC00-\uDC6E]|\uD802[\uDC58-\uDC5F\uDC79-\uDC7F\uDCA7-\uDCAF\uDCFB-\uDCFF\uDD16-\uDD1B\uDDBC\uDDBD\uDDC0-\uDDCF\uDDD2-\uDDFF\uDE40-\uDE47\uDE7D\uDE7E\uDE9D-\uDE9F\uDEEB-\uDEEF\uDF58-\uDF5F\uDF78-\uDF7F\uDFA9-\uDFAF]|\uD805[\uDCD0-\uDCD9\uDE50-\uDE59\uDEC0-\uDEC9\uDF30-\uDF3B]'
        },
        {
            name: 'Nd',
            alias: 'Decimal_Number',
            bmp: '0-9\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0BE6-\u0BEF\u0C66-\u0C6F\u0CE6-\u0CEF\u0D66-\u0D6F\u0DE6-\u0DEF\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F29\u1040-\u1049\u1090-\u1099\u17E0-\u17E9\u1810-\u1819\u1946-\u194F\u19D0-\u19D9\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\uA620-\uA629\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uA9F0-\uA9F9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19',
            astral: '\uD801[\uDCA0-\uDCA9]|\uD835[\uDFCE-\uDFFF]|\uD805[\uDCD0-\uDCD9\uDE50-\uDE59\uDEC0-\uDEC9\uDF30-\uDF39]|\uD806[\uDCE0-\uDCE9]|\uD804[\uDC66-\uDC6F\uDCF0-\uDCF9\uDD36-\uDD3F\uDDD0-\uDDD9\uDEF0-\uDEF9]|\uD81A[\uDE60-\uDE69\uDF50-\uDF59]'
        },
        {
            name: 'Nl',
            alias: 'Letter_Number',
            bmp: '\u16EE-\u16F0\u2160-\u2182\u2185-\u2188\u3007\u3021-\u3029\u3038-\u303A\uA6E6-\uA6EF',
            astral: '\uD809[\uDC00-\uDC6E]|\uD800[\uDD40-\uDD74\uDF41\uDF4A\uDFD1-\uDFD5]'
        },
        {
            name: 'No',
            alias: 'Other_Number',
            bmp: '\xB2\xB3\xB9\xBC-\xBE\u09F4-\u09F9\u0B72-\u0B77\u0BF0-\u0BF2\u0C78-\u0C7E\u0D70-\u0D75\u0F2A-\u0F33\u1369-\u137C\u17F0-\u17F9\u19DA\u2070\u2074-\u2079\u2080-\u2089\u2150-\u215F\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2CFD\u3192-\u3195\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\uA830-\uA835',
            astral: '\uD804[\uDC52-\uDC65\uDDE1-\uDDF4]|\uD803[\uDCFA-\uDCFF\uDE60-\uDE7E]|\uD83C[\uDD00-\uDD0C]|\uD806[\uDCEA-\uDCF2]|\uD83A[\uDCC7-\uDCCF]|\uD802[\uDC58-\uDC5F\uDC79-\uDC7F\uDCA7-\uDCAF\uDCFB-\uDCFF\uDD16-\uDD1B\uDDBC\uDDBD\uDDC0-\uDDCF\uDDD2-\uDDFF\uDE40-\uDE47\uDE7D\uDE7E\uDE9D-\uDE9F\uDEEB-\uDEEF\uDF58-\uDF5F\uDF78-\uDF7F\uDFA9-\uDFAF]|\uD805[\uDF3A\uDF3B]|\uD81A[\uDF5B-\uDF61]|\uD834[\uDF60-\uDF71]|\uD800[\uDD07-\uDD33\uDD75-\uDD78\uDD8A\uDD8B\uDEE1-\uDEFB\uDF20-\uDF23]'
        },
        {
            name: 'P',
            alias: 'Punctuation',
            bmp: '\x21-\x23\x25-\\x2A\x2C-\x2F\x3A\x3B\\x3F\x40\\x5B-\\x5D\x5F\\x7B\x7D\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E42\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65',
            astral: '\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD809[\uDC70-\uDC74]|\uD805[\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDF3C-\uDF3E]|\uD836[\uDE87-\uDE8B]|\uD801\uDD6F|\uD82F\uDC9F|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC9\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]'
        },
        {
            name: 'Pc',
            alias: 'Connector_Punctuation',
            bmp: '\x5F\u203F\u2040\u2054\uFE33\uFE34\uFE4D-\uFE4F\uFF3F'
        },
        {
            name: 'Pd',
            alias: 'Dash_Punctuation',
            bmp: '\\x2D\u058A\u05BE\u1400\u1806\u2010-\u2015\u2E17\u2E1A\u2E3A\u2E3B\u2E40\u301C\u3030\u30A0\uFE31\uFE32\uFE58\uFE63\uFF0D'
        },
        {
            name: 'Pe',
            alias: 'Close_Punctuation',
            bmp: '\\x29\\x5D\x7D\u0F3B\u0F3D\u169C\u2046\u207E\u208E\u2309\u230B\u232A\u2769\u276B\u276D\u276F\u2771\u2773\u2775\u27C6\u27E7\u27E9\u27EB\u27ED\u27EF\u2984\u2986\u2988\u298A\u298C\u298E\u2990\u2992\u2994\u2996\u2998\u29D9\u29DB\u29FD\u2E23\u2E25\u2E27\u2E29\u3009\u300B\u300D\u300F\u3011\u3015\u3017\u3019\u301B\u301E\u301F\uFD3E\uFE18\uFE36\uFE38\uFE3A\uFE3C\uFE3E\uFE40\uFE42\uFE44\uFE48\uFE5A\uFE5C\uFE5E\uFF09\uFF3D\uFF5D\uFF60\uFF63'
        },
        {
            name: 'Pf',
            alias: 'Final_Punctuation',
            bmp: '\xBB\u2019\u201D\u203A\u2E03\u2E05\u2E0A\u2E0D\u2E1D\u2E21'
        },
        {
            name: 'Pi',
            alias: 'Initial_Punctuation',
            bmp: '\xAB\u2018\u201B\u201C\u201F\u2039\u2E02\u2E04\u2E09\u2E0C\u2E1C\u2E20'
        },
        {
            name: 'Po',
            alias: 'Other_Punctuation',
            bmp: '\x21-\x23\x25-\x27\\x2A\x2C\\x2E\x2F\x3A\x3B\\x3F\x40\\x5C\xA1\xA7\xB6\xB7\xBF\u037E\u0387\u055A-\u055F\u0589\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u166D\u166E\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u1805\u1807-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2016\u2017\u2020-\u2027\u2030-\u2038\u203B-\u203E\u2041-\u2043\u2047-\u2051\u2053\u2055-\u205E\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00\u2E01\u2E06-\u2E08\u2E0B\u2E0E-\u2E16\u2E18\u2E19\u2E1B\u2E1E\u2E1F\u2E2A-\u2E2E\u2E30-\u2E39\u2E3C-\u2E3F\u2E41\u3001-\u3003\u303D\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFE10-\uFE16\uFE19\uFE30\uFE45\uFE46\uFE49-\uFE4C\uFE50-\uFE52\uFE54-\uFE57\uFE5F-\uFE61\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF07\uFF0A\uFF0C\uFF0E\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3C\uFF61\uFF64\uFF65',
            astral: '\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD809[\uDC70-\uDC74]|\uD805[\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDF3C-\uDF3E]|\uD836[\uDE87-\uDE8B]|\uD801\uDD6F|\uD82F\uDC9F|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC9\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]'
        },
        {
            name: 'Ps',
            alias: 'Open_Punctuation',
            bmp: '\\x28\\x5B\\x7B\u0F3A\u0F3C\u169B\u201A\u201E\u2045\u207D\u208D\u2308\u230A\u2329\u2768\u276A\u276C\u276E\u2770\u2772\u2774\u27C5\u27E6\u27E8\u27EA\u27EC\u27EE\u2983\u2985\u2987\u2989\u298B\u298D\u298F\u2991\u2993\u2995\u2997\u29D8\u29DA\u29FC\u2E22\u2E24\u2E26\u2E28\u2E42\u3008\u300A\u300C\u300E\u3010\u3014\u3016\u3018\u301A\u301D\uFD3F\uFE17\uFE35\uFE37\uFE39\uFE3B\uFE3D\uFE3F\uFE41\uFE43\uFE47\uFE59\uFE5B\uFE5D\uFF08\uFF3B\uFF5B\uFF5F\uFF62'
        },
        {
            name: 'S',
            alias: 'Symbol',
            bmp: '\\x24\\x2B\x3C-\x3E\\x5E\x60\\x7C\x7E\xA2-\xA6\xA8\xA9\xAC\xAE-\xB1\xB4\xB8\xD7\xF7\u02C2-\u02C5\u02D2-\u02DF\u02E5-\u02EB\u02ED\u02EF-\u02FF\u0375\u0384\u0385\u03F6\u0482\u058D-\u058F\u0606-\u0608\u060B\u060E\u060F\u06DE\u06E9\u06FD\u06FE\u07F6\u09F2\u09F3\u09FA\u09FB\u0AF1\u0B70\u0BF3-\u0BFA\u0C7F\u0D79\u0E3F\u0F01-\u0F03\u0F13\u0F15-\u0F17\u0F1A-\u0F1F\u0F34\u0F36\u0F38\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE\u0FCF\u0FD5-\u0FD8\u109E\u109F\u1390-\u1399\u17DB\u1940\u19DE-\u19FF\u1B61-\u1B6A\u1B74-\u1B7C\u1FBD\u1FBF-\u1FC1\u1FCD-\u1FCF\u1FDD-\u1FDF\u1FED-\u1FEF\u1FFD\u1FFE\u2044\u2052\u207A-\u207C\u208A-\u208C\u20A0-\u20BE\u2100\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u2140-\u2144\u214A-\u214D\u214F\u218A\u218B\u2190-\u2307\u230C-\u2328\u232B-\u23FA\u2400-\u2426\u2440-\u244A\u249C-\u24E9\u2500-\u2767\u2794-\u27C4\u27C7-\u27E5\u27F0-\u2982\u2999-\u29D7\u29DC-\u29FB\u29FE-\u2B73\u2B76-\u2B95\u2B98-\u2BB9\u2BBD-\u2BC8\u2BCA-\u2BD1\u2BEC-\u2BEF\u2CE5-\u2CEA\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFB\u3004\u3012\u3013\u3020\u3036\u3037\u303E\u303F\u309B\u309C\u3190\u3191\u3196-\u319F\u31C0-\u31E3\u3200-\u321E\u322A-\u3247\u3250\u3260-\u327F\u328A-\u32B0\u32C0-\u32FE\u3300-\u33FF\u4DC0-\u4DFF\uA490-\uA4C6\uA700-\uA716\uA720\uA721\uA789\uA78A\uA828-\uA82B\uA836-\uA839\uAA77-\uAA79\uAB5B\uFB29\uFBB2-\uFBC1\uFDFC\uFDFD\uFE62\uFE64-\uFE66\uFE69\uFF04\uFF0B\uFF1C-\uFF1E\uFF3E\uFF40\uFF5C\uFF5E\uFFE0-\uFFE6\uFFE8-\uFFEE\uFFFC\uFFFD',
            astral: '\uD83E[\uDC00-\uDC0B\uDC10-\uDC47\uDC50-\uDC59\uDC60-\uDC87\uDC90-\uDCAD\uDD10-\uDD18\uDD80-\uDD84\uDDC0]|\uD83C[\uDC00-\uDC2B\uDC30-\uDC93\uDCA0-\uDCAE\uDCB1-\uDCBF\uDCC1-\uDCCF\uDCD1-\uDCF5\uDD10-\uDD2E\uDD30-\uDD6B\uDD70-\uDD9A\uDDE6-\uDE02\uDE10-\uDE3A\uDE40-\uDE48\uDE50\uDE51\uDF00-\uDFFF]|\uD83D[\uDC00-\uDD79\uDD7B-\uDDA3\uDDA5-\uDED0\uDEE0-\uDEEC\uDEF0-\uDEF3\uDF00-\uDF73\uDF80-\uDFD4]|\uD835[\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3]|\uD800[\uDD37-\uDD3F\uDD79-\uDD89\uDD8C\uDD90-\uDD9B\uDDA0\uDDD0-\uDDFC]|\uD82F\uDC9C|\uD805\uDF3F|\uD802[\uDC77\uDC78\uDEC8]|\uD81A[\uDF3C-\uDF3F\uDF45]|\uD836[\uDC00-\uDDFF\uDE37-\uDE3A\uDE6D-\uDE74\uDE76-\uDE83\uDE85\uDE86]|\uD834[\uDC00-\uDCF5\uDD00-\uDD26\uDD29-\uDD64\uDD6A-\uDD6C\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDDE8\uDE00-\uDE41\uDE45\uDF00-\uDF56]|\uD83B[\uDEF0\uDEF1]'
        },
        {
            name: 'Sc',
            alias: 'Currency_Symbol',
            bmp: '\\x24\xA2-\xA5\u058F\u060B\u09F2\u09F3\u09FB\u0AF1\u0BF9\u0E3F\u17DB\u20A0-\u20BE\uA838\uFDFC\uFE69\uFF04\uFFE0\uFFE1\uFFE5\uFFE6'
        },
        {
            name: 'Sk',
            alias: 'Modifier_Symbol',
            bmp: '\\x5E\x60\xA8\xAF\xB4\xB8\u02C2-\u02C5\u02D2-\u02DF\u02E5-\u02EB\u02ED\u02EF-\u02FF\u0375\u0384\u0385\u1FBD\u1FBF-\u1FC1\u1FCD-\u1FCF\u1FDD-\u1FDF\u1FED-\u1FEF\u1FFD\u1FFE\u309B\u309C\uA700-\uA716\uA720\uA721\uA789\uA78A\uAB5B\uFBB2-\uFBC1\uFF3E\uFF40\uFFE3',
            astral: '\uD83C[\uDFFB-\uDFFF]'
        },
        {
            name: 'Sm',
            alias: 'Math_Symbol',
            bmp: '\\x2B\x3C-\x3E\\x7C\x7E\xAC\xB1\xD7\xF7\u03F6\u0606-\u0608\u2044\u2052\u207A-\u207C\u208A-\u208C\u2118\u2140-\u2144\u214B\u2190-\u2194\u219A\u219B\u21A0\u21A3\u21A6\u21AE\u21CE\u21CF\u21D2\u21D4\u21F4-\u22FF\u2320\u2321\u237C\u239B-\u23B3\u23DC-\u23E1\u25B7\u25C1\u25F8-\u25FF\u266F\u27C0-\u27C4\u27C7-\u27E5\u27F0-\u27FF\u2900-\u2982\u2999-\u29D7\u29DC-\u29FB\u29FE-\u2AFF\u2B30-\u2B44\u2B47-\u2B4C\uFB29\uFE62\uFE64-\uFE66\uFF0B\uFF1C-\uFF1E\uFF5C\uFF5E\uFFE2\uFFE9-\uFFEC',
            astral: '\uD83B[\uDEF0\uDEF1]|\uD835[\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3]'
        },
        {
            name: 'So',
            alias: 'Other_Symbol',
            bmp: '\xA6\xA9\xAE\xB0\u0482\u058D\u058E\u060E\u060F\u06DE\u06E9\u06FD\u06FE\u07F6\u09FA\u0B70\u0BF3-\u0BF8\u0BFA\u0C7F\u0D79\u0F01-\u0F03\u0F13\u0F15-\u0F17\u0F1A-\u0F1F\u0F34\u0F36\u0F38\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE\u0FCF\u0FD5-\u0FD8\u109E\u109F\u1390-\u1399\u1940\u19DE-\u19FF\u1B61-\u1B6A\u1B74-\u1B7C\u2100\u2101\u2103-\u2106\u2108\u2109\u2114\u2116\u2117\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u214A\u214C\u214D\u214F\u218A\u218B\u2195-\u2199\u219C-\u219F\u21A1\u21A2\u21A4\u21A5\u21A7-\u21AD\u21AF-\u21CD\u21D0\u21D1\u21D3\u21D5-\u21F3\u2300-\u2307\u230C-\u231F\u2322-\u2328\u232B-\u237B\u237D-\u239A\u23B4-\u23DB\u23E2-\u23FA\u2400-\u2426\u2440-\u244A\u249C-\u24E9\u2500-\u25B6\u25B8-\u25C0\u25C2-\u25F7\u2600-\u266E\u2670-\u2767\u2794-\u27BF\u2800-\u28FF\u2B00-\u2B2F\u2B45\u2B46\u2B4D-\u2B73\u2B76-\u2B95\u2B98-\u2BB9\u2BBD-\u2BC8\u2BCA-\u2BD1\u2BEC-\u2BEF\u2CE5-\u2CEA\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFB\u3004\u3012\u3013\u3020\u3036\u3037\u303E\u303F\u3190\u3191\u3196-\u319F\u31C0-\u31E3\u3200-\u321E\u322A-\u3247\u3250\u3260-\u327F\u328A-\u32B0\u32C0-\u32FE\u3300-\u33FF\u4DC0-\u4DFF\uA490-\uA4C6\uA828-\uA82B\uA836\uA837\uA839\uAA77-\uAA79\uFDFD\uFFE4\uFFE8\uFFED\uFFEE\uFFFC\uFFFD',
            astral: '\uD83E[\uDC00-\uDC0B\uDC10-\uDC47\uDC50-\uDC59\uDC60-\uDC87\uDC90-\uDCAD\uDD10-\uDD18\uDD80-\uDD84\uDDC0]|\uD83D[\uDC00-\uDD79\uDD7B-\uDDA3\uDDA5-\uDED0\uDEE0-\uDEEC\uDEF0-\uDEF3\uDF00-\uDF73\uDF80-\uDFD4]|\uD83C[\uDC00-\uDC2B\uDC30-\uDC93\uDCA0-\uDCAE\uDCB1-\uDCBF\uDCC1-\uDCCF\uDCD1-\uDCF5\uDD10-\uDD2E\uDD30-\uDD6B\uDD70-\uDD9A\uDDE6-\uDE02\uDE10-\uDE3A\uDE40-\uDE48\uDE50\uDE51\uDF00-\uDFFA]|\uD800[\uDD37-\uDD3F\uDD79-\uDD89\uDD8C\uDD90-\uDD9B\uDDA0\uDDD0-\uDDFC]|\uD82F\uDC9C|\uD805\uDF3F|\uD802[\uDC77\uDC78\uDEC8]|\uD81A[\uDF3C-\uDF3F\uDF45]|\uD836[\uDC00-\uDDFF\uDE37-\uDE3A\uDE6D-\uDE74\uDE76-\uDE83\uDE85\uDE86]|\uD834[\uDC00-\uDCF5\uDD00-\uDD26\uDD29-\uDD64\uDD6A-\uDD6C\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDDE8\uDE00-\uDE41\uDE45\uDF00-\uDF56]'
        },
        {
            name: 'Z',
            alias: 'Separator',
            bmp: '\x20\xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000'
        },
        {
            name: 'Zl',
            alias: 'Line_Separator',
            bmp: '\u2028'
        },
        {
            name: 'Zp',
            alias: 'Paragraph_Separator',
            bmp: '\u2029'
        },
        {
            name: 'Zs',
            alias: 'Space_Separator',
            bmp: '\x20\xA0\u1680\u2000-\u200A\u202F\u205F\u3000'
        }
    ]);

}(XRegExp));

/*!
 * XRegExp Unicode Properties 3.0.0
 * <http://xregexp.com/>
 * Steven Levithan (c) 2012-2015 MIT License
 * Unicode data provided by Mathias Bynens <http://mathiasbynens.be/>
 */

/**
 * Adds properties to meet the UTS #18 Level 1 RL1.2 requirements for Unicode regex support. See
 * <http://unicode.org/reports/tr18/#RL1.2>. Following are definitions of these properties from UAX
 * #44 <http://unicode.org/reports/tr44/>:
 *
 * - Alphabetic
 *   Characters with the Alphabetic property. Generated from: Lowercase + Uppercase + Lt + Lm + Lo +
 *   Nl + Other_Alphabetic.
 *
 * - Default_Ignorable_Code_Point
 *   For programmatic determination of default ignorable code points. New characters that should be
 *   ignored in rendering (unless explicitly supported) will be assigned in these ranges, permitting
 *   programs to correctly handle the default rendering of such characters when not otherwise
 *   supported.
 *
 * - Lowercase
 *   Characters with the Lowercase property. Generated from: Ll + Other_Lowercase.
 *
 * - Noncharacter_Code_Point
 *   Code points permanently reserved for internal use.
 *
 * - Uppercase
 *   Characters with the Uppercase property. Generated from: Lu + Other_Uppercase.
 *
 * - White_Space
 *   Spaces, separator characters and other control characters which should be treated by
 *   programming languages as "white space" for the purpose of parsing elements.
 *
 * The properties ASCII, Any, and Assigned are also included but are not defined in UAX #44. UTS #18
 * RL1.2 additionally requires support for Unicode scripts and general categories. These are
 * included in XRegExp's Unicode Categories and Unicode Scripts addons.
 *
 * Token names are case insensitive, and any spaces, hyphens, and underscores are ignored.
 *
 * Uses Unicode 8.0.0.
 *
 * @requires XRegExp, Unicode Base
 */
(function(XRegExp) {
    'use strict';

    if (!XRegExp.addUnicodeData) {
        throw new ReferenceError('Unicode Base must be loaded before Unicode Properties');
    }

    var unicodeData = [
        {
            name: 'ASCII',
            bmp: '\0-\x7F'
        },
        {
            name: 'Alphabetic',
            bmp: 'A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0345\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05B0-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0657\u0659-\u065F\u066E-\u06D3\u06D5-\u06DC\u06E1-\u06E8\u06ED-\u06EF\u06FA-\u06FC\u06FF\u0710-\u073F\u074D-\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0817\u081A-\u082C\u0840-\u0858\u08A0-\u08B4\u08E3-\u08E9\u08F0-\u093B\u093D-\u094C\u094E-\u0950\u0955-\u0963\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD-\u09C4\u09C7\u09C8\u09CB\u09CC\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09F0\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3E-\u0A42\u0A47\u0A48\u0A4B\u0A4C\u0A51\u0A59-\u0A5C\u0A5E\u0A70-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD-\u0AC5\u0AC7-\u0AC9\u0ACB\u0ACC\u0AD0\u0AE0-\u0AE3\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D-\u0B44\u0B47\u0B48\u0B4B\u0B4C\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0BD0\u0BD7\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4C\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCC\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4C\u0D4E\u0D57\u0D5F-\u0D63\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E46\u0E4D\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0ECD\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F71-\u0F81\u0F88-\u0F97\u0F99-\u0FBC\u1000-\u1036\u1038\u103B-\u103F\u1050-\u1062\u1065-\u1068\u106E-\u1086\u108E\u109C\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1713\u1720-\u1733\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17B3\u17B6-\u17C8\u17D7\u17DC\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u1938\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A1B\u1A20-\u1A5E\u1A61-\u1A74\u1AA7\u1B00-\u1B33\u1B35-\u1B43\u1B45-\u1B4B\u1B80-\u1BA9\u1BAC-\u1BAF\u1BBA-\u1BE5\u1BE7-\u1BF1\u1C00-\u1C35\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1D00-\u1DBF\u1DE7-\u1DF4\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u24B6-\u24E9\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA674-\uA67B\uA67F-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA827\uA840-\uA873\uA880-\uA8C3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA92A\uA930-\uA952\uA960-\uA97C\uA980-\uA9B2\uA9B4-\uA9BF\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA60-\uAA76\uAA7A\uAA7E-\uAABE\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF5\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC',
            astral: '\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD804[\uDC00-\uDC45\uDC82-\uDCB8\uDCD0-\uDCE8\uDD00-\uDD32\uDD50-\uDD72\uDD76\uDD80-\uDDBF\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE34\uDE37\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEE8\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D-\uDF44\uDF47\uDF48\uDF4B\uDF4C\uDF50\uDF57\uDF5D-\uDF63]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD83A[\uDC00-\uDCC4]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF36\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD83C[\uDD30-\uDD49\uDD50-\uDD69\uDD70-\uDD89]|\uD80D[\uDC00-\uDC2E]|\uD87E[\uDC00-\uDE1D]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9E]|\uD808[\uDC00-\uDF99]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD805[\uDC80-\uDCC1\uDCC4\uDCC5\uDCC7\uDD80-\uDDB5\uDDB8-\uDDBE\uDDD8-\uDDDD\uDE00-\uDE3E\uDE40\uDE44\uDE80-\uDEB5\uDF00-\uDF19\uDF1D-\uDF2A]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD811[\uDC00-\uDE46]|\uD82C[\uDC00\uDC01]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF93-\uDF9F]|\uD873[\uDC00-\uDEA1]'
        },
        {
            name: 'Any',
            isBmpLast: true,
            bmp: '\0-\uFFFF',
            astral: '[\uD800-\uDBFF][\uDC00-\uDFFF]'
        },
        {
            name: 'Default_Ignorable_Code_Point',
            bmp: '\xAD\u034F\u061C\u115F\u1160\u17B4\u17B5\u180B-\u180E\u200B-\u200F\u202A-\u202E\u2060-\u206F\u3164\uFE00-\uFE0F\uFEFF\uFFA0\uFFF0-\uFFF8',
            astral: '[\uDB40-\uDB43][\uDC00-\uDFFF]|\uD834[\uDD73-\uDD7A]|\uD82F[\uDCA0-\uDCA3]'
        },
        {
            name: 'Lowercase',
            bmp: 'a-z\xAA\xB5\xBA\xDF-\xF6\xF8-\xFF\u0101\u0103\u0105\u0107\u0109\u010B\u010D\u010F\u0111\u0113\u0115\u0117\u0119\u011B\u011D\u011F\u0121\u0123\u0125\u0127\u0129\u012B\u012D\u012F\u0131\u0133\u0135\u0137\u0138\u013A\u013C\u013E\u0140\u0142\u0144\u0146\u0148\u0149\u014B\u014D\u014F\u0151\u0153\u0155\u0157\u0159\u015B\u015D\u015F\u0161\u0163\u0165\u0167\u0169\u016B\u016D\u016F\u0171\u0173\u0175\u0177\u017A\u017C\u017E-\u0180\u0183\u0185\u0188\u018C\u018D\u0192\u0195\u0199-\u019B\u019E\u01A1\u01A3\u01A5\u01A8\u01AA\u01AB\u01AD\u01B0\u01B4\u01B6\u01B9\u01BA\u01BD-\u01BF\u01C6\u01C9\u01CC\u01CE\u01D0\u01D2\u01D4\u01D6\u01D8\u01DA\u01DC\u01DD\u01DF\u01E1\u01E3\u01E5\u01E7\u01E9\u01EB\u01ED\u01EF\u01F0\u01F3\u01F5\u01F9\u01FB\u01FD\u01FF\u0201\u0203\u0205\u0207\u0209\u020B\u020D\u020F\u0211\u0213\u0215\u0217\u0219\u021B\u021D\u021F\u0221\u0223\u0225\u0227\u0229\u022B\u022D\u022F\u0231\u0233-\u0239\u023C\u023F\u0240\u0242\u0247\u0249\u024B\u024D\u024F-\u0293\u0295-\u02B8\u02C0\u02C1\u02E0-\u02E4\u0345\u0371\u0373\u0377\u037A-\u037D\u0390\u03AC-\u03CE\u03D0\u03D1\u03D5-\u03D7\u03D9\u03DB\u03DD\u03DF\u03E1\u03E3\u03E5\u03E7\u03E9\u03EB\u03ED\u03EF-\u03F3\u03F5\u03F8\u03FB\u03FC\u0430-\u045F\u0461\u0463\u0465\u0467\u0469\u046B\u046D\u046F\u0471\u0473\u0475\u0477\u0479\u047B\u047D\u047F\u0481\u048B\u048D\u048F\u0491\u0493\u0495\u0497\u0499\u049B\u049D\u049F\u04A1\u04A3\u04A5\u04A7\u04A9\u04AB\u04AD\u04AF\u04B1\u04B3\u04B5\u04B7\u04B9\u04BB\u04BD\u04BF\u04C2\u04C4\u04C6\u04C8\u04CA\u04CC\u04CE\u04CF\u04D1\u04D3\u04D5\u04D7\u04D9\u04DB\u04DD\u04DF\u04E1\u04E3\u04E5\u04E7\u04E9\u04EB\u04ED\u04EF\u04F1\u04F3\u04F5\u04F7\u04F9\u04FB\u04FD\u04FF\u0501\u0503\u0505\u0507\u0509\u050B\u050D\u050F\u0511\u0513\u0515\u0517\u0519\u051B\u051D\u051F\u0521\u0523\u0525\u0527\u0529\u052B\u052D\u052F\u0561-\u0587\u13F8-\u13FD\u1D00-\u1DBF\u1E01\u1E03\u1E05\u1E07\u1E09\u1E0B\u1E0D\u1E0F\u1E11\u1E13\u1E15\u1E17\u1E19\u1E1B\u1E1D\u1E1F\u1E21\u1E23\u1E25\u1E27\u1E29\u1E2B\u1E2D\u1E2F\u1E31\u1E33\u1E35\u1E37\u1E39\u1E3B\u1E3D\u1E3F\u1E41\u1E43\u1E45\u1E47\u1E49\u1E4B\u1E4D\u1E4F\u1E51\u1E53\u1E55\u1E57\u1E59\u1E5B\u1E5D\u1E5F\u1E61\u1E63\u1E65\u1E67\u1E69\u1E6B\u1E6D\u1E6F\u1E71\u1E73\u1E75\u1E77\u1E79\u1E7B\u1E7D\u1E7F\u1E81\u1E83\u1E85\u1E87\u1E89\u1E8B\u1E8D\u1E8F\u1E91\u1E93\u1E95-\u1E9D\u1E9F\u1EA1\u1EA3\u1EA5\u1EA7\u1EA9\u1EAB\u1EAD\u1EAF\u1EB1\u1EB3\u1EB5\u1EB7\u1EB9\u1EBB\u1EBD\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7\u1EC9\u1ECB\u1ECD\u1ECF\u1ED1\u1ED3\u1ED5\u1ED7\u1ED9\u1EDB\u1EDD\u1EDF\u1EE1\u1EE3\u1EE5\u1EE7\u1EE9\u1EEB\u1EED\u1EEF\u1EF1\u1EF3\u1EF5\u1EF7\u1EF9\u1EFB\u1EFD\u1EFF-\u1F07\u1F10-\u1F15\u1F20-\u1F27\u1F30-\u1F37\u1F40-\u1F45\u1F50-\u1F57\u1F60-\u1F67\u1F70-\u1F7D\u1F80-\u1F87\u1F90-\u1F97\u1FA0-\u1FA7\u1FB0-\u1FB4\u1FB6\u1FB7\u1FBE\u1FC2-\u1FC4\u1FC6\u1FC7\u1FD0-\u1FD3\u1FD6\u1FD7\u1FE0-\u1FE7\u1FF2-\u1FF4\u1FF6\u1FF7\u2071\u207F\u2090-\u209C\u210A\u210E\u210F\u2113\u212F\u2134\u2139\u213C\u213D\u2146-\u2149\u214E\u2170-\u217F\u2184\u24D0-\u24E9\u2C30-\u2C5E\u2C61\u2C65\u2C66\u2C68\u2C6A\u2C6C\u2C71\u2C73\u2C74\u2C76-\u2C7D\u2C81\u2C83\u2C85\u2C87\u2C89\u2C8B\u2C8D\u2C8F\u2C91\u2C93\u2C95\u2C97\u2C99\u2C9B\u2C9D\u2C9F\u2CA1\u2CA3\u2CA5\u2CA7\u2CA9\u2CAB\u2CAD\u2CAF\u2CB1\u2CB3\u2CB5\u2CB7\u2CB9\u2CBB\u2CBD\u2CBF\u2CC1\u2CC3\u2CC5\u2CC7\u2CC9\u2CCB\u2CCD\u2CCF\u2CD1\u2CD3\u2CD5\u2CD7\u2CD9\u2CDB\u2CDD\u2CDF\u2CE1\u2CE3\u2CE4\u2CEC\u2CEE\u2CF3\u2D00-\u2D25\u2D27\u2D2D\uA641\uA643\uA645\uA647\uA649\uA64B\uA64D\uA64F\uA651\uA653\uA655\uA657\uA659\uA65B\uA65D\uA65F\uA661\uA663\uA665\uA667\uA669\uA66B\uA66D\uA681\uA683\uA685\uA687\uA689\uA68B\uA68D\uA68F\uA691\uA693\uA695\uA697\uA699\uA69B-\uA69D\uA723\uA725\uA727\uA729\uA72B\uA72D\uA72F-\uA731\uA733\uA735\uA737\uA739\uA73B\uA73D\uA73F\uA741\uA743\uA745\uA747\uA749\uA74B\uA74D\uA74F\uA751\uA753\uA755\uA757\uA759\uA75B\uA75D\uA75F\uA761\uA763\uA765\uA767\uA769\uA76B\uA76D\uA76F-\uA778\uA77A\uA77C\uA77F\uA781\uA783\uA785\uA787\uA78C\uA78E\uA791\uA793-\uA795\uA797\uA799\uA79B\uA79D\uA79F\uA7A1\uA7A3\uA7A5\uA7A7\uA7A9\uA7B5\uA7B7\uA7F8-\uA7FA\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABBF\uFB00-\uFB06\uFB13-\uFB17\uFF41-\uFF5A',
            astral: '\uD803[\uDCC0-\uDCF2]|\uD835[\uDC1A-\uDC33\uDC4E-\uDC54\uDC56-\uDC67\uDC82-\uDC9B\uDCB6-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDCEA-\uDD03\uDD1E-\uDD37\uDD52-\uDD6B\uDD86-\uDD9F\uDDBA-\uDDD3\uDDEE-\uDE07\uDE22-\uDE3B\uDE56-\uDE6F\uDE8A-\uDEA5\uDEC2-\uDEDA\uDEDC-\uDEE1\uDEFC-\uDF14\uDF16-\uDF1B\uDF36-\uDF4E\uDF50-\uDF55\uDF70-\uDF88\uDF8A-\uDF8F\uDFAA-\uDFC2\uDFC4-\uDFC9\uDFCB]|\uD801[\uDC28-\uDC4F]|\uD806[\uDCC0-\uDCDF]'
        },
        {
            name: 'Noncharacter_Code_Point',
            bmp: '\uFDD0-\uFDEF\uFFFE\uFFFF',
            astral: '[\uDB3F\uDB7F\uDBBF\uDBFF\uD83F\uD87F\uD8BF\uDAFF\uD97F\uD9BF\uD9FF\uDA3F\uD8FF\uDABF\uDA7F\uD93F][\uDFFE\uDFFF]'
        },
        {
            name: 'Uppercase',
            bmp: 'A-Z\xC0-\xD6\xD8-\xDE\u0100\u0102\u0104\u0106\u0108\u010A\u010C\u010E\u0110\u0112\u0114\u0116\u0118\u011A\u011C\u011E\u0120\u0122\u0124\u0126\u0128\u012A\u012C\u012E\u0130\u0132\u0134\u0136\u0139\u013B\u013D\u013F\u0141\u0143\u0145\u0147\u014A\u014C\u014E\u0150\u0152\u0154\u0156\u0158\u015A\u015C\u015E\u0160\u0162\u0164\u0166\u0168\u016A\u016C\u016E\u0170\u0172\u0174\u0176\u0178\u0179\u017B\u017D\u0181\u0182\u0184\u0186\u0187\u0189-\u018B\u018E-\u0191\u0193\u0194\u0196-\u0198\u019C\u019D\u019F\u01A0\u01A2\u01A4\u01A6\u01A7\u01A9\u01AC\u01AE\u01AF\u01B1-\u01B3\u01B5\u01B7\u01B8\u01BC\u01C4\u01C7\u01CA\u01CD\u01CF\u01D1\u01D3\u01D5\u01D7\u01D9\u01DB\u01DE\u01E0\u01E2\u01E4\u01E6\u01E8\u01EA\u01EC\u01EE\u01F1\u01F4\u01F6-\u01F8\u01FA\u01FC\u01FE\u0200\u0202\u0204\u0206\u0208\u020A\u020C\u020E\u0210\u0212\u0214\u0216\u0218\u021A\u021C\u021E\u0220\u0222\u0224\u0226\u0228\u022A\u022C\u022E\u0230\u0232\u023A\u023B\u023D\u023E\u0241\u0243-\u0246\u0248\u024A\u024C\u024E\u0370\u0372\u0376\u037F\u0386\u0388-\u038A\u038C\u038E\u038F\u0391-\u03A1\u03A3-\u03AB\u03CF\u03D2-\u03D4\u03D8\u03DA\u03DC\u03DE\u03E0\u03E2\u03E4\u03E6\u03E8\u03EA\u03EC\u03EE\u03F4\u03F7\u03F9\u03FA\u03FD-\u042F\u0460\u0462\u0464\u0466\u0468\u046A\u046C\u046E\u0470\u0472\u0474\u0476\u0478\u047A\u047C\u047E\u0480\u048A\u048C\u048E\u0490\u0492\u0494\u0496\u0498\u049A\u049C\u049E\u04A0\u04A2\u04A4\u04A6\u04A8\u04AA\u04AC\u04AE\u04B0\u04B2\u04B4\u04B6\u04B8\u04BA\u04BC\u04BE\u04C0\u04C1\u04C3\u04C5\u04C7\u04C9\u04CB\u04CD\u04D0\u04D2\u04D4\u04D6\u04D8\u04DA\u04DC\u04DE\u04E0\u04E2\u04E4\u04E6\u04E8\u04EA\u04EC\u04EE\u04F0\u04F2\u04F4\u04F6\u04F8\u04FA\u04FC\u04FE\u0500\u0502\u0504\u0506\u0508\u050A\u050C\u050E\u0510\u0512\u0514\u0516\u0518\u051A\u051C\u051E\u0520\u0522\u0524\u0526\u0528\u052A\u052C\u052E\u0531-\u0556\u10A0-\u10C5\u10C7\u10CD\u13A0-\u13F5\u1E00\u1E02\u1E04\u1E06\u1E08\u1E0A\u1E0C\u1E0E\u1E10\u1E12\u1E14\u1E16\u1E18\u1E1A\u1E1C\u1E1E\u1E20\u1E22\u1E24\u1E26\u1E28\u1E2A\u1E2C\u1E2E\u1E30\u1E32\u1E34\u1E36\u1E38\u1E3A\u1E3C\u1E3E\u1E40\u1E42\u1E44\u1E46\u1E48\u1E4A\u1E4C\u1E4E\u1E50\u1E52\u1E54\u1E56\u1E58\u1E5A\u1E5C\u1E5E\u1E60\u1E62\u1E64\u1E66\u1E68\u1E6A\u1E6C\u1E6E\u1E70\u1E72\u1E74\u1E76\u1E78\u1E7A\u1E7C\u1E7E\u1E80\u1E82\u1E84\u1E86\u1E88\u1E8A\u1E8C\u1E8E\u1E90\u1E92\u1E94\u1E9E\u1EA0\u1EA2\u1EA4\u1EA6\u1EA8\u1EAA\u1EAC\u1EAE\u1EB0\u1EB2\u1EB4\u1EB6\u1EB8\u1EBA\u1EBC\u1EBE\u1EC0\u1EC2\u1EC4\u1EC6\u1EC8\u1ECA\u1ECC\u1ECE\u1ED0\u1ED2\u1ED4\u1ED6\u1ED8\u1EDA\u1EDC\u1EDE\u1EE0\u1EE2\u1EE4\u1EE6\u1EE8\u1EEA\u1EEC\u1EEE\u1EF0\u1EF2\u1EF4\u1EF6\u1EF8\u1EFA\u1EFC\u1EFE\u1F08-\u1F0F\u1F18-\u1F1D\u1F28-\u1F2F\u1F38-\u1F3F\u1F48-\u1F4D\u1F59\u1F5B\u1F5D\u1F5F\u1F68-\u1F6F\u1FB8-\u1FBB\u1FC8-\u1FCB\u1FD8-\u1FDB\u1FE8-\u1FEC\u1FF8-\u1FFB\u2102\u2107\u210B-\u210D\u2110-\u2112\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u2130-\u2133\u213E\u213F\u2145\u2160-\u216F\u2183\u24B6-\u24CF\u2C00-\u2C2E\u2C60\u2C62-\u2C64\u2C67\u2C69\u2C6B\u2C6D-\u2C70\u2C72\u2C75\u2C7E-\u2C80\u2C82\u2C84\u2C86\u2C88\u2C8A\u2C8C\u2C8E\u2C90\u2C92\u2C94\u2C96\u2C98\u2C9A\u2C9C\u2C9E\u2CA0\u2CA2\u2CA4\u2CA6\u2CA8\u2CAA\u2CAC\u2CAE\u2CB0\u2CB2\u2CB4\u2CB6\u2CB8\u2CBA\u2CBC\u2CBE\u2CC0\u2CC2\u2CC4\u2CC6\u2CC8\u2CCA\u2CCC\u2CCE\u2CD0\u2CD2\u2CD4\u2CD6\u2CD8\u2CDA\u2CDC\u2CDE\u2CE0\u2CE2\u2CEB\u2CED\u2CF2\uA640\uA642\uA644\uA646\uA648\uA64A\uA64C\uA64E\uA650\uA652\uA654\uA656\uA658\uA65A\uA65C\uA65E\uA660\uA662\uA664\uA666\uA668\uA66A\uA66C\uA680\uA682\uA684\uA686\uA688\uA68A\uA68C\uA68E\uA690\uA692\uA694\uA696\uA698\uA69A\uA722\uA724\uA726\uA728\uA72A\uA72C\uA72E\uA732\uA734\uA736\uA738\uA73A\uA73C\uA73E\uA740\uA742\uA744\uA746\uA748\uA74A\uA74C\uA74E\uA750\uA752\uA754\uA756\uA758\uA75A\uA75C\uA75E\uA760\uA762\uA764\uA766\uA768\uA76A\uA76C\uA76E\uA779\uA77B\uA77D\uA77E\uA780\uA782\uA784\uA786\uA78B\uA78D\uA790\uA792\uA796\uA798\uA79A\uA79C\uA79E\uA7A0\uA7A2\uA7A4\uA7A6\uA7A8\uA7AA-\uA7AD\uA7B0-\uA7B4\uA7B6\uFF21-\uFF3A',
            astral: '\uD806[\uDCA0-\uDCBF]|\uD803[\uDC80-\uDCB2]|\uD835[\uDC00-\uDC19\uDC34-\uDC4D\uDC68-\uDC81\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB5\uDCD0-\uDCE9\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD38\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD6C-\uDD85\uDDA0-\uDDB9\uDDD4-\uDDED\uDE08-\uDE21\uDE3C-\uDE55\uDE70-\uDE89\uDEA8-\uDEC0\uDEE2-\uDEFA\uDF1C-\uDF34\uDF56-\uDF6E\uDF90-\uDFA8\uDFCA]|\uD801[\uDC00-\uDC27]|\uD83C[\uDD30-\uDD49\uDD50-\uDD69\uDD70-\uDD89]'
        },
        {
            name: 'White_Space',
            bmp: '\x09-\x0D\x20\x85\xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000'
        }
    ];

    // Add non-generated data
    unicodeData.push({
        name: 'Assigned',
        // Since this is defined as the inverse of Unicode category Cn (Unassigned), the Unicode
        // Categories addon is required to use this property
        inverseOf: 'Cn'
    });

    XRegExp.addUnicodeData(unicodeData);

}(XRegExp));

/*!
 * XRegExp Unicode Scripts 3.0.0
 * <http://xregexp.com/>
 * Steven Levithan (c) 2010-2015 MIT License
 * Unicode data provided by Mathias Bynens <http://mathiasbynens.be/>
 */

/**
 * Adds support for all Unicode scripts. E.g., `\p{Latin}`. Token names are case insensitive, and
 * any spaces, hyphens, and underscores are ignored.
 *
 * Uses Unicode 8.0.0.
 *
 * @requires XRegExp, Unicode Base
 */
(function(XRegExp) {
    'use strict';

    if (!XRegExp.addUnicodeData) {
        throw new ReferenceError('Unicode Base must be loaded before Unicode Scripts');
    }

    XRegExp.addUnicodeData([
        {
            name: 'Ahom',
            astral: '\uD805[\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF3F]'
        },
        {
            name: 'Anatolian_Hieroglyphs',
            astral: '\uD811[\uDC00-\uDE46]'
        },
        {
            name: 'Arabic',
            bmp: '\u0600-\u0604\u0606-\u060B\u060D-\u061A\u061E\u0620-\u063F\u0641-\u064A\u0656-\u066F\u0671-\u06DC\u06DE-\u06FF\u0750-\u077F\u08A0-\u08B4\u08E3-\u08FF\uFB50-\uFBC1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFD\uFE70-\uFE74\uFE76-\uFEFC',
            astral: '\uD803[\uDE60-\uDE7E]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB\uDEF0\uDEF1]'
        },
        {
            name: 'Armenian',
            bmp: '\u0531-\u0556\u0559-\u055F\u0561-\u0587\u058A\u058D-\u058F\uFB13-\uFB17'
        },
        {
            name: 'Avestan',
            astral: '\uD802[\uDF00-\uDF35\uDF39-\uDF3F]'
        },
        {
            name: 'Balinese',
            bmp: '\u1B00-\u1B4B\u1B50-\u1B7C'
        },
        {
            name: 'Bamum',
            bmp: '\uA6A0-\uA6F7',
            astral: '\uD81A[\uDC00-\uDE38]'
        },
        {
            name: 'Bassa_Vah',
            astral: '\uD81A[\uDED0-\uDEED\uDEF0-\uDEF5]'
        },
        {
            name: 'Batak',
            bmp: '\u1BC0-\u1BF3\u1BFC-\u1BFF'
        },
        {
            name: 'Bengali',
            bmp: '\u0980-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09FB'
        },
        {
            name: 'Bopomofo',
            bmp: '\u02EA\u02EB\u3105-\u312D\u31A0-\u31BA'
        },
        {
            name: 'Brahmi',
            astral: '\uD804[\uDC00-\uDC4D\uDC52-\uDC6F\uDC7F]'
        },
        {
            name: 'Braille',
            bmp: '\u2800-\u28FF'
        },
        {
            name: 'Buginese',
            bmp: '\u1A00-\u1A1B\u1A1E\u1A1F'
        },
        {
            name: 'Buhid',
            bmp: '\u1740-\u1753'
        },
        {
            name: 'Canadian_Aboriginal',
            bmp: '\u1400-\u167F\u18B0-\u18F5'
        },
        {
            name: 'Carian',
            astral: '\uD800[\uDEA0-\uDED0]'
        },
        {
            name: 'Caucasian_Albanian',
            astral: '\uD801[\uDD30-\uDD63\uDD6F]'
        },
        {
            name: 'Chakma',
            astral: '\uD804[\uDD00-\uDD34\uDD36-\uDD43]'
        },
        {
            name: 'Cham',
            bmp: '\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA5C-\uAA5F'
        },
        {
            name: 'Cherokee',
            bmp: '\u13A0-\u13F5\u13F8-\u13FD\uAB70-\uABBF'
        },
        {
            name: 'Common',
            bmp: '\0-\x40\\x5B-\x60\\x7B-\xA9\xAB-\xB9\xBB-\xBF\xD7\xF7\u02B9-\u02DF\u02E5-\u02E9\u02EC-\u02FF\u0374\u037E\u0385\u0387\u0589\u0605\u060C\u061B\u061C\u061F\u0640\u06DD\u0964\u0965\u0E3F\u0FD5-\u0FD8\u10FB\u16EB-\u16ED\u1735\u1736\u1802\u1803\u1805\u1CD3\u1CE1\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u2000-\u200B\u200E-\u2064\u2066-\u2070\u2074-\u207E\u2080-\u208E\u20A0-\u20BE\u2100-\u2125\u2127-\u2129\u212C-\u2131\u2133-\u214D\u214F-\u215F\u2189-\u218B\u2190-\u23FA\u2400-\u2426\u2440-\u244A\u2460-\u27FF\u2900-\u2B73\u2B76-\u2B95\u2B98-\u2BB9\u2BBD-\u2BC8\u2BCA-\u2BD1\u2BEC-\u2BEF\u2E00-\u2E42\u2FF0-\u2FFB\u3000-\u3004\u3006\u3008-\u3020\u3030-\u3037\u303C-\u303F\u309B\u309C\u30A0\u30FB\u30FC\u3190-\u319F\u31C0-\u31E3\u3220-\u325F\u327F-\u32CF\u3358-\u33FF\u4DC0-\u4DFF\uA700-\uA721\uA788-\uA78A\uA830-\uA839\uA92E\uA9CF\uAB5B\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE66\uFE68-\uFE6B\uFEFF\uFF01-\uFF20\uFF3B-\uFF40\uFF5B-\uFF65\uFF70\uFF9E\uFF9F\uFFE0-\uFFE6\uFFE8-\uFFEE\uFFF9-\uFFFD',
            astral: '\uD83E[\uDC00-\uDC0B\uDC10-\uDC47\uDC50-\uDC59\uDC60-\uDC87\uDC90-\uDCAD\uDD10-\uDD18\uDD80-\uDD84\uDDC0]|\uD82F[\uDCA0-\uDCA3]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDFCB\uDFCE-\uDFFF]|\uDB40[\uDC01\uDC20-\uDC7F]|\uD83D[\uDC00-\uDD79\uDD7B-\uDDA3\uDDA5-\uDED0\uDEE0-\uDEEC\uDEF0-\uDEF3\uDF00-\uDF73\uDF80-\uDFD4]|\uD800[\uDD00-\uDD02\uDD07-\uDD33\uDD37-\uDD3F\uDD90-\uDD9B\uDDD0-\uDDFC\uDEE1-\uDEFB]|\uD834[\uDC00-\uDCF5\uDD00-\uDD26\uDD29-\uDD66\uDD6A-\uDD7A\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDDE8\uDF00-\uDF56\uDF60-\uDF71]|\uD83C[\uDC00-\uDC2B\uDC30-\uDC93\uDCA0-\uDCAE\uDCB1-\uDCBF\uDCC1-\uDCCF\uDCD1-\uDCF5\uDD00-\uDD0C\uDD10-\uDD2E\uDD30-\uDD6B\uDD70-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE10-\uDE3A\uDE40-\uDE48\uDE50\uDE51\uDF00-\uDFFF]'
        },
        {
            name: 'Coptic',
            bmp: '\u03E2-\u03EF\u2C80-\u2CF3\u2CF9-\u2CFF'
        },
        {
            name: 'Cuneiform',
            astral: '\uD809[\uDC00-\uDC6E\uDC70-\uDC74\uDC80-\uDD43]|\uD808[\uDC00-\uDF99]'
        },
        {
            name: 'Cypriot',
            astral: '\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F]'
        },
        {
            name: 'Cyrillic',
            bmp: '\u0400-\u0484\u0487-\u052F\u1D2B\u1D78\u2DE0-\u2DFF\uA640-\uA69F\uFE2E\uFE2F'
        },
        {
            name: 'Deseret',
            astral: '\uD801[\uDC00-\uDC4F]'
        },
        {
            name: 'Devanagari',
            bmp: '\u0900-\u0950\u0953-\u0963\u0966-\u097F\uA8E0-\uA8FD'
        },
        {
            name: 'Duployan',
            astral: '\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9C-\uDC9F]'
        },
        {
            name: 'Egyptian_Hieroglyphs',
            astral: '\uD80C[\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]'
        },
        {
            name: 'Elbasan',
            astral: '\uD801[\uDD00-\uDD27]'
        },
        {
            name: 'Ethiopic',
            bmp: '\u1200-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u137C\u1380-\u1399\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E'
        },
        {
            name: 'Georgian',
            bmp: '\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u10FF\u2D00-\u2D25\u2D27\u2D2D'
        },
        {
            name: 'Glagolitic',
            bmp: '\u2C00-\u2C2E\u2C30-\u2C5E'
        },
        {
            name: 'Gothic',
            astral: '\uD800[\uDF30-\uDF4A]'
        },
        {
            name: 'Grantha',
            astral: '\uD804[\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]'
        },
        {
            name: 'Greek',
            bmp: '\u0370-\u0373\u0375-\u0377\u037A-\u037D\u037F\u0384\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03E1\u03F0-\u03FF\u1D26-\u1D2A\u1D5D-\u1D61\u1D66-\u1D6A\u1DBF\u1F00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FC4\u1FC6-\u1FD3\u1FD6-\u1FDB\u1FDD-\u1FEF\u1FF2-\u1FF4\u1FF6-\u1FFE\u2126\uAB65',
            astral: '\uD800[\uDD40-\uDD8C\uDDA0]|\uD834[\uDE00-\uDE45]'
        },
        {
            name: 'Gujarati',
            bmp: '\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AF1\u0AF9'
        },
        {
            name: 'Gurmukhi',
            bmp: '\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75'
        },
        {
            name: 'Han',
            bmp: '\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u3005\u3007\u3021-\u3029\u3038-\u303B\u3400-\u4DB5\u4E00-\u9FD5\uF900-\uFA6D\uFA70-\uFAD9',
            astral: '\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|[\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD87E[\uDC00-\uDE1D]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD873[\uDC00-\uDEA1]'
        },
        {
            name: 'Hangul',
            bmp: '\u1100-\u11FF\u302E\u302F\u3131-\u318E\u3200-\u321E\u3260-\u327E\uA960-\uA97C\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uFFA0-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC'
        },
        {
            name: 'Hanunoo',
            bmp: '\u1720-\u1734'
        },
        {
            name: 'Hatran',
            astral: '\uD802[\uDCE0-\uDCF2\uDCF4\uDCF5\uDCFB-\uDCFF]'
        },
        {
            name: 'Hebrew',
            bmp: '\u0591-\u05C7\u05D0-\u05EA\u05F0-\u05F4\uFB1D-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFB4F'
        },
        {
            name: 'Hiragana',
            bmp: '\u3041-\u3096\u309D-\u309F',
            astral: '\uD82C\uDC01|\uD83C\uDE00'
        },
        {
            name: 'Imperial_Aramaic',
            astral: '\uD802[\uDC40-\uDC55\uDC57-\uDC5F]'
        },
        {
            name: 'Inherited',
            bmp: '\u0300-\u036F\u0485\u0486\u064B-\u0655\u0670\u0951\u0952\u1AB0-\u1ABE\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFC-\u1DFF\u200C\u200D\u20D0-\u20F0\u302A-\u302D\u3099\u309A\uFE00-\uFE0F\uFE20-\uFE2D',
            astral: '\uD834[\uDD67-\uDD69\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD]|\uD800[\uDDFD\uDEE0]|\uDB40[\uDD00-\uDDEF]'
        },
        {
            name: 'Inscriptional_Pahlavi',
            astral: '\uD802[\uDF60-\uDF72\uDF78-\uDF7F]'
        },
        {
            name: 'Inscriptional_Parthian',
            astral: '\uD802[\uDF40-\uDF55\uDF58-\uDF5F]'
        },
        {
            name: 'Javanese',
            bmp: '\uA980-\uA9CD\uA9D0-\uA9D9\uA9DE\uA9DF'
        },
        {
            name: 'Kaithi',
            astral: '\uD804[\uDC80-\uDCC1]'
        },
        {
            name: 'Kannada',
            bmp: '\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2'
        },
        {
            name: 'Katakana',
            bmp: '\u30A1-\u30FA\u30FD-\u30FF\u31F0-\u31FF\u32D0-\u32FE\u3300-\u3357\uFF66-\uFF6F\uFF71-\uFF9D',
            astral: '\uD82C\uDC00'
        },
        {
            name: 'Kayah_Li',
            bmp: '\uA900-\uA92D\uA92F'
        },
        {
            name: 'Kharoshthi',
            astral: '\uD802[\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F-\uDE47\uDE50-\uDE58]'
        },
        {
            name: 'Khmer',
            bmp: '\u1780-\u17DD\u17E0-\u17E9\u17F0-\u17F9\u19E0-\u19FF'
        },
        {
            name: 'Khojki',
            astral: '\uD804[\uDE00-\uDE11\uDE13-\uDE3D]'
        },
        {
            name: 'Khudawadi',
            astral: '\uD804[\uDEB0-\uDEEA\uDEF0-\uDEF9]'
        },
        {
            name: 'Lao',
            bmp: '\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF'
        },
        {
            name: 'Latin',
            bmp: 'A-Za-z\xAA\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02B8\u02E0-\u02E4\u1D00-\u1D25\u1D2C-\u1D5C\u1D62-\u1D65\u1D6B-\u1D77\u1D79-\u1DBE\u1E00-\u1EFF\u2071\u207F\u2090-\u209C\u212A\u212B\u2132\u214E\u2160-\u2188\u2C60-\u2C7F\uA722-\uA787\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA7FF\uAB30-\uAB5A\uAB5C-\uAB64\uFB00-\uFB06\uFF21-\uFF3A\uFF41-\uFF5A'
        },
        {
            name: 'Lepcha',
            bmp: '\u1C00-\u1C37\u1C3B-\u1C49\u1C4D-\u1C4F'
        },
        {
            name: 'Limbu',
            bmp: '\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1940\u1944-\u194F'
        },
        {
            name: 'Linear_A',
            astral: '\uD801[\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]'
        },
        {
            name: 'Linear_B',
            astral: '\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA]'
        },
        {
            name: 'Lisu',
            bmp: '\uA4D0-\uA4FF'
        },
        {
            name: 'Lycian',
            astral: '\uD800[\uDE80-\uDE9C]'
        },
        {
            name: 'Lydian',
            astral: '\uD802[\uDD20-\uDD39\uDD3F]'
        },
        {
            name: 'Mahajani',
            astral: '\uD804[\uDD50-\uDD76]'
        },
        {
            name: 'Malayalam',
            bmp: '\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D5F-\u0D63\u0D66-\u0D75\u0D79-\u0D7F'
        },
        {
            name: 'Mandaic',
            bmp: '\u0840-\u085B\u085E'
        },
        {
            name: 'Manichaean',
            astral: '\uD802[\uDEC0-\uDEE6\uDEEB-\uDEF6]'
        },
        {
            name: 'Meetei_Mayek',
            bmp: '\uAAE0-\uAAF6\uABC0-\uABED\uABF0-\uABF9'
        },
        {
            name: 'Mende_Kikakui',
            astral: '\uD83A[\uDC00-\uDCC4\uDCC7-\uDCD6]'
        },
        {
            name: 'Meroitic_Cursive',
            astral: '\uD802[\uDDA0-\uDDB7\uDDBC-\uDDCF\uDDD2-\uDDFF]'
        },
        {
            name: 'Meroitic_Hieroglyphs',
            astral: '\uD802[\uDD80-\uDD9F]'
        },
        {
            name: 'Miao',
            astral: '\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]'
        },
        {
            name: 'Modi',
            astral: '\uD805[\uDE00-\uDE44\uDE50-\uDE59]'
        },
        {
            name: 'Mongolian',
            bmp: '\u1800\u1801\u1804\u1806-\u180E\u1810-\u1819\u1820-\u1877\u1880-\u18AA'
        },
        {
            name: 'Mro',
            astral: '\uD81A[\uDE40-\uDE5E\uDE60-\uDE69\uDE6E\uDE6F]'
        },
        {
            name: 'Multani',
            astral: '\uD804[\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA9]'
        },
        {
            name: 'Myanmar',
            bmp: '\u1000-\u109F\uA9E0-\uA9FE\uAA60-\uAA7F'
        },
        {
            name: 'Nabataean',
            astral: '\uD802[\uDC80-\uDC9E\uDCA7-\uDCAF]'
        },
        {
            name: 'New_Tai_Lue',
            bmp: '\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u19DE\u19DF'
        },
        {
            name: 'Nko',
            bmp: '\u07C0-\u07FA'
        },
        {
            name: 'Ogham',
            bmp: '\u1680-\u169C'
        },
        {
            name: 'Ol_Chiki',
            bmp: '\u1C50-\u1C7F'
        },
        {
            name: 'Old_Hungarian',
            astral: '\uD803[\uDC80-\uDCB2\uDCC0-\uDCF2\uDCFA-\uDCFF]'
        },
        {
            name: 'Old_Italic',
            astral: '\uD800[\uDF00-\uDF23]'
        },
        {
            name: 'Old_North_Arabian',
            astral: '\uD802[\uDE80-\uDE9F]'
        },
        {
            name: 'Old_Permic',
            astral: '\uD800[\uDF50-\uDF7A]'
        },
        {
            name: 'Old_Persian',
            astral: '\uD800[\uDFA0-\uDFC3\uDFC8-\uDFD5]'
        },
        {
            name: 'Old_South_Arabian',
            astral: '\uD802[\uDE60-\uDE7F]'
        },
        {
            name: 'Old_Turkic',
            astral: '\uD803[\uDC00-\uDC48]'
        },
        {
            name: 'Oriya',
            bmp: '\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B77'
        },
        {
            name: 'Osmanya',
            astral: '\uD801[\uDC80-\uDC9D\uDCA0-\uDCA9]'
        },
        {
            name: 'Pahawh_Hmong',
            astral: '\uD81A[\uDF00-\uDF45\uDF50-\uDF59\uDF5B-\uDF61\uDF63-\uDF77\uDF7D-\uDF8F]'
        },
        {
            name: 'Palmyrene',
            astral: '\uD802[\uDC60-\uDC7F]'
        },
        {
            name: 'Pau_Cin_Hau',
            astral: '\uD806[\uDEC0-\uDEF8]'
        },
        {
            name: 'Phags_Pa',
            bmp: '\uA840-\uA877'
        },
        {
            name: 'Phoenician',
            astral: '\uD802[\uDD00-\uDD1B\uDD1F]'
        },
        {
            name: 'Psalter_Pahlavi',
            astral: '\uD802[\uDF80-\uDF91\uDF99-\uDF9C\uDFA9-\uDFAF]'
        },
        {
            name: 'Rejang',
            bmp: '\uA930-\uA953\uA95F'
        },
        {
            name: 'Runic',
            bmp: '\u16A0-\u16EA\u16EE-\u16F8'
        },
        {
            name: 'Samaritan',
            bmp: '\u0800-\u082D\u0830-\u083E'
        },
        {
            name: 'Saurashtra',
            bmp: '\uA880-\uA8C4\uA8CE-\uA8D9'
        },
        {
            name: 'Sharada',
            astral: '\uD804[\uDD80-\uDDCD\uDDD0-\uDDDF]'
        },
        {
            name: 'Shavian',
            astral: '\uD801[\uDC50-\uDC7F]'
        },
        {
            name: 'Siddham',
            astral: '\uD805[\uDD80-\uDDB5\uDDB8-\uDDDD]'
        },
        {
            name: 'SignWriting',
            astral: '\uD836[\uDC00-\uDE8B\uDE9B-\uDE9F\uDEA1-\uDEAF]'
        },
        {
            name: 'Sinhala',
            bmp: '\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2-\u0DF4',
            astral: '\uD804[\uDDE1-\uDDF4]'
        },
        {
            name: 'Sora_Sompeng',
            astral: '\uD804[\uDCD0-\uDCE8\uDCF0-\uDCF9]'
        },
        {
            name: 'Sundanese',
            bmp: '\u1B80-\u1BBF\u1CC0-\u1CC7'
        },
        {
            name: 'Syloti_Nagri',
            bmp: '\uA800-\uA82B'
        },
        {
            name: 'Syriac',
            bmp: '\u0700-\u070D\u070F-\u074A\u074D-\u074F'
        },
        {
            name: 'Tagalog',
            bmp: '\u1700-\u170C\u170E-\u1714'
        },
        {
            name: 'Tagbanwa',
            bmp: '\u1760-\u176C\u176E-\u1770\u1772\u1773'
        },
        {
            name: 'Tai_Le',
            bmp: '\u1950-\u196D\u1970-\u1974'
        },
        {
            name: 'Tai_Tham',
            bmp: '\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA0-\u1AAD'
        },
        {
            name: 'Tai_Viet',
            bmp: '\uAA80-\uAAC2\uAADB-\uAADF'
        },
        {
            name: 'Takri',
            astral: '\uD805[\uDE80-\uDEB7\uDEC0-\uDEC9]'
        },
        {
            name: 'Tamil',
            bmp: '\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BFA'
        },
        {
            name: 'Telugu',
            bmp: '\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C78-\u0C7F'
        },
        {
            name: 'Thaana',
            bmp: '\u0780-\u07B1'
        },
        {
            name: 'Thai',
            bmp: '\u0E01-\u0E3A\u0E40-\u0E5B'
        },
        {
            name: 'Tibetan',
            bmp: '\u0F00-\u0F47\u0F49-\u0F6C\u0F71-\u0F97\u0F99-\u0FBC\u0FBE-\u0FCC\u0FCE-\u0FD4\u0FD9\u0FDA'
        },
        {
            name: 'Tifinagh',
            bmp: '\u2D30-\u2D67\u2D6F\u2D70\u2D7F'
        },
        {
            name: 'Tirhuta',
            astral: '\uD805[\uDC80-\uDCC7\uDCD0-\uDCD9]'
        },
        {
            name: 'Ugaritic',
            astral: '\uD800[\uDF80-\uDF9D\uDF9F]'
        },
        {
            name: 'Vai',
            bmp: '\uA500-\uA62B'
        },
        {
            name: 'Warang_Citi',
            astral: '\uD806[\uDCA0-\uDCF2\uDCFF]'
        },
        {
            name: 'Yi',
            bmp: '\uA000-\uA48C\uA490-\uA4C6'
        }
    ]);

}(XRegExp));

return XRegExp;

}));


},{}],371:[function(require,module,exports){
// import "babel-polyfill";
//
// import {XRegExp} from "xregexp";
// import PubSub from "pubsub-js";
// import React from "react";
// import ReactDOM from "react-dom";
// import CSSTransition from "react-addons-css-transition-group";
// import * as ReactRouter from "react-router";
// import {createHashHistory} from "history";

// import "lib-source/v2/gesture";
"use strict";

var _extends = require("babel-runtime/helpers/extends")["default"];

var _inherits = require("babel-runtime/helpers/inherits")["default"];

var _classCallCheck = require("babel-runtime/helpers/class-call-check")["default"];

var _regeneratorRuntime = require("babel-runtime/regenerator")["default"];

var _Array$from = require("babel-runtime/core-js/array/from")["default"];

var _interopRequireDefault = require("babel-runtime/helpers/interop-require-default")["default"];

var _this3 = this;

var _libSourceV2Chrono = require("lib-source/v2/chrono");

var _libSourceV2Chrono2 = _interopRequireDefault(_libSourceV2Chrono);

var _libSourceV2Ajax = require("lib-source/v2/ajax");

var _libSourceV2Ajax2 = _interopRequireDefault(_libSourceV2Ajax);

var _libSourceUiv2Icon = require('lib-source/uiv2/icon');

var _libSourceUiv2Icon2 = _interopRequireDefault(_libSourceUiv2Icon);

var _libSourceUiv2Ripple = require('lib-source/uiv2/ripple');

var _libSourceUiv2Ripple2 = _interopRequireDefault(_libSourceUiv2Ripple);

var _libSourceUiv2Button = require('lib-source/uiv2/button');

var _libSourceUiv2Button2 = _interopRequireDefault(_libSourceUiv2Button);

var _libSourceUiv2Iconbutton = require('lib-source/uiv2/iconbutton');

var _libSourceUiv2Iconbutton2 = _interopRequireDefault(_libSourceUiv2Iconbutton);

var _libSourceUiv2Card = require('lib-source/uiv2/Card');

var _libSourceUiv2Card2 = _interopRequireDefault(_libSourceUiv2Card);

var _libSourceUiv2Image = require('lib-source/uiv2/Image');

var _libSourceUiv2Image2 = _interopRequireDefault(_libSourceUiv2Image);

var _libSourceUiv2CenterContent = require('lib-source/uiv2/CenterContent');

var _libSourceUiv2CenterContent2 = _interopRequireDefault(_libSourceUiv2CenterContent);

var _libSourceUiv2Checkbox = require('lib-source/uiv2/Checkbox');

var _libSourceUiv2Checkbox2 = _interopRequireDefault(_libSourceUiv2Checkbox);

var _libSourceUiv2Toggle = require('lib-source/uiv2/Toggle');

var _libSourceUiv2Toggle2 = _interopRequireDefault(_libSourceUiv2Toggle);

var _libSourceUiv2Touchable = require('lib-source/uiv2/Touchable');

var _libSourceUiv2Touchable2 = _interopRequireDefault(_libSourceUiv2Touchable);

var _libSourceUiv2Combobox = require('lib-source/uiv2/Combobox');

var _libSourceUiv2Combobox2 = _interopRequireDefault(_libSourceUiv2Combobox);

var _libSourceUiv2Option = require('lib-source/uiv2/Option');

var _libSourceUiv2Option2 = _interopRequireDefault(_libSourceUiv2Option);

var _libSourceUiv2Spinner = require('lib-source/uiv2/Spinner');

var _libSourceUiv2Spinner2 = _interopRequireDefault(_libSourceUiv2Spinner);

var _libSourceUiv2Radio = require('lib-source/uiv2/Radio');

var _libSourceUiv2Radio2 = _interopRequireDefault(_libSourceUiv2Radio);

var _libSourceUiv2Calendar = require('lib-source/uiv2/Calendar');

var _libSourceUiv2Calendar2 = _interopRequireDefault(_libSourceUiv2Calendar);

var _libSourceUiv2Input = require('lib-source/uiv2/Input');

var _libSourceUiv2Input2 = _interopRequireDefault(_libSourceUiv2Input);

var _libSourceUiv2LayoutFlexbox = require('lib-source/uiv2/layout/Flexbox');

var _libSourceUiv2LayoutFlexbox2 = _interopRequireDefault(_libSourceUiv2LayoutFlexbox);

var _libSourceUiv2LayoutGrid = require('lib-source/uiv2/layout/Grid');

var _libSourceUiv2LayoutGrid2 = _interopRequireDefault(_libSourceUiv2LayoutGrid);

var _libSourceUiv2LayoutPinboard = require('lib-source/uiv2/layout/Pinboard');

var _libSourceUiv2LayoutPinboard2 = _interopRequireDefault(_libSourceUiv2LayoutPinboard);

var _libSourceUiv2Form = require('lib-source/uiv2/Form');

var _libSourceUiv2Form2 = _interopRequireDefault(_libSourceUiv2Form);

var _libSourceUiv2Dialog = require("lib-source/uiv2/dialog");

var _libSourceUiv2Dialog2 = _interopRequireDefault(_libSourceUiv2Dialog);

var _libSourceV2Style = require("lib-source/v2/style");

var _libSourceV2Utils = require("lib-source/v2/utils");

var _libSourceV2Shared = require("lib-source/v2/shared");

var _libSourceV2Crypto = require('lib-source/v2/crypto');

var _libSourceV2Crypto2 = _interopRequireDefault(_libSourceV2Crypto);

var _libSourceV2Zip = require('lib-source/v2/zip');

var _libSourceV2Zip2 = _interopRequireDefault(_libSourceV2Zip);

var _libSourceV2Environment = require('lib-source/v2/Environment');

var _libSourceV2Environment2 = _interopRequireDefault(_libSourceV2Environment);

var _libSourceDataUriRobotoLightWoffSource = require("lib-source/data-uri/roboto-light.woff.source");

var _libSourceDataUriRobotoLightWoffSource2 = _interopRequireDefault(_libSourceDataUriRobotoLightWoffSource);

var _libSourceDataUriIoniconsWoffSource = require("lib-source/data-uri/ionicons.woff.source");

var _libSourceDataUriIoniconsWoffSource2 = _interopRequireDefault(_libSourceDataUriIoniconsWoffSource);

window.chrono = _libSourceV2Chrono2["default"];

var range = _regeneratorRuntime.mark(function range(args) {
    var _args$start, start, _args$end, end, _args$count, count, _args$step, step, _args$map, map;

    return _regeneratorRuntime.wrap(function range$(context$1$0) {
        while (1) switch (context$1$0.prev = context$1$0.next) {
            case 0:
                _args$start = args.start;
                start = _args$start === undefined ? 0 : _args$start;
                _args$end = args.end;
                end = _args$end === undefined ? null : _args$end;
                _args$count = args.count;
                count = _args$count === undefined ? null : _args$count;
                _args$step = args.step;
                step = _args$step === undefined ? 1 : _args$step;
                _args$map = args.map;
                map = _args$map === undefined ? function (i) {
                    return i;
                } : _args$map;

                if (!(end === null)) {
                    context$1$0.next = 14;
                    break;
                }

                if (!(count === null)) {
                    context$1$0.next = 13;
                    break;
                }

                throw new Error("Must give the size of the range");

            case 13:
                end = start + count;

            case 14:
                if (!true) {
                    context$1$0.next = 22;
                    break;
                }

                if (!(start >= end)) {
                    context$1$0.next = 17;
                    break;
                }

                return context$1$0.abrupt("break", 22);

            case 17:
                context$1$0.next = 19;
                return map(start);

            case 19:
                start += step;
                context$1$0.next = 14;
                break;

            case 22:
            case "end":
                return context$1$0.stop();
        }
    }, range, this);
});

window.frange = _regeneratorRuntime.mark(function callee$0$0(count) {
    var map = arguments.length <= 1 || arguments[1] === undefined ? function (i) {
        return i;
    } : arguments[1];
    var current;
    return _regeneratorRuntime.wrap(function callee$0$0$(context$1$0) {
        while (1) switch (context$1$0.prev = context$1$0.next) {
            case 0:
                current = 0;

            case 1:
                if (!true) {
                    context$1$0.next = 9;
                    break;
                }

                if (!(current === count)) {
                    context$1$0.next = 4;
                    break;
                }

                return context$1$0.abrupt("break", 9);

            case 4:
                context$1$0.next = 6;
                return map(current);

            case 6:
                current += 1;
                context$1$0.next = 1;
                break;

            case 9:
            case "end":
                return context$1$0.stop();
        }
    }, callee$0$0, this);
});
window.arange = function (count, map) {
    return _Array$from(frange(count, map));
};

var _ReactRouter = ReactRouter;
var Route = _ReactRouter.Route;

var coolBlue = "#2FB1DF";

Theme.define({
    app: {
        backgroundColor: 'white',
        textColor: '#747474'
    },
    button: {
        hoverColor: 'rgba(0, 0, 0, 0.11)',
        activeColor: 'rgba(0, 0, 0, 0.2)',
        raised: {
            color: coolBlue,
            textColor: 'white'
        }
    },
    card: {
        backgroundColor: 'white'
    },
    progressbar: {
        backgroundColor: '#B3CEED',
        color: '#3B8AF3'
    },
    radio: {
        grid: {
            selectedColor: coolBlue
        }
    },
    rangeInput: {
        track: {
            color: coolBlue
        }
    },
    "switch": {
        track: {
            color: coolBlue
        }
    },
    title: {
        backgroundColor: coolBlue,
        textColor: 'white'
    },
    userInput: {
        activeColor: '#2FB1DF',
        textColor: 'black'
    }
});

var ScreenTransition = React.createClass({
    displayName: "ScreenTransition",

    render: function render() {
        return React.createElement(
            "div",
            { style: { position: 'absolute', width: '100%', height: '100%' } },
            this.props.children
        );
    }
});

Style.__rawCSS("test", {
    selector: ".test-enter",
    rules: {
        'transition': 'left 250ms ease-out',
        left: '100%'
    }
}, {
    selector: ".test-enter.test-enter-active",
    rules: {
        left: 0
    }
}, {
    selector: ".test-leave",
    rules: {
        'transition': 'left 250ms ease-out',
        left: 0
    }
}, {
    selector: ".test-leave.test-leave-active",
    rules: {
        left: '-100%'
    }
}, {
    selector: ".test-appear",
    rules: {
        'transition': 'top 250ms ease-out',
        top: '100%'
    }
}, {
    selector: ".test-appear.test-appear-active",
    rules: {
        top: 0
    }
});

var Wrapper = React.createClass({
    displayName: "Wrapper",

    render: function render() {
        return React.createElement(
            CSSTransition,
            { component: "div", transitionName: "test", transitionEnterTimeout: 250, transitionLeaveTimeout: 250 },
            React.createElement(
                ScreenTransition,
                { key: Date.now() },
                this.props.children
            )
        );
    }
});

// window.benchmark = (iterations, first, second) => {
//     const r = [];
//     for (const testNum of range({count: 30})) {
//         let a = performance.now();
//         for (let i = 0; i < iterations; i += 1) {
//             first(i);
//         }
//         a = performance.now() - a;
//
//         let b = performance.now();
//         for (let i = 0; i < iterations; i += 1) {
//             second(i);
//         }
//         b = performance.now() - b;
//         r.push([a.toFixed(3), b.toFixed(3)]);
//     }
//     return r;
// };
//
// const checkProp = (obj, prop, value) => obj.hasOwnProperty(prop) === true && obj[prop] === value;
// const x = {a: 10, b: 12};
//
// const res = benchmark(1e6, (i) => (i % 2 === 0) ? i >> 1 : 0, (i) => (i % 2 === 0) ? i / 2 : 0);
// console.log(res.map(i => i.join('\t')).join('\n'));

/*
const url = "http://vignette1.wikia.nocookie.net/bayonetta/images/e/e3/Cereza_Bayonetta_2_render.png/revision/latest?cb=20140615210025";
*/
var url = "http://assets1.ignimgs.com/thumbs/userUploaded/2014/10/12/Bayonetta2_1280-1413142451100.jpg";

/*
defineStyleForComponent(
    Button,
    'special',
    {
    }
);
...
<Button.Special />
*/

_libSourceV2Style.defineStyleForComponent(_libSourceUiv2Checkbox2["default"], 'awesome', {
    normal: {
        iconColor: 'cyan'
    },
    checked: {
        iconColor: 'blue'
    }
});
_libSourceV2Style.defineStyleForComponent(_libSourceUiv2Toggle2["default"], 'awesome', {
    on: {
        thumbColor: 'blue',
        trackColor: 'cyan'
    }
});

if (_libSourceV2Environment2["default"].app === false) {
    _libSourceV2Style.defineComponentStyle('global', 'elite', {
        "$*": {
            boxSizing: 'border-box'
        },
        "$html": {
            width: '100%',
            height: '100%'
        },
        "$body": {
            fontFamily: "Roboto",
            padding: 0,
            margin: 0,
            width: '100%',
            height: '100%',
            backgroundColor: '#eee'
        },
        "$html, $body": {
            WebkitOverflowScrolling: 'touch'
        }
    });
} else {
    _libSourceV2Style.defineComponentStyle('global', 'elite', {
        "$*": {
            boxSizing: 'border-box'
        },
        "$body": {
            fontFamily: "Roboto",
            backgroundColor: '#eee'
        },
        "$html, $body": {
            padding: 0,
            margin: 0,
            width: '100%',
            height: '100%',
            overflow: 'hidden'
        }
    });
}

_libSourceV2Style.defineComponentStyle('app', 'core', {});
_libSourceV2Style.defineComponentStyle('roboto', 'font', { "$@font-face": _libSourceV2Style.genFontCSS("Roboto", _libSourceDataUriRobotoLightWoffSource2["default"]) });
_libSourceV2Style.defineComponentStyle('ionic', 'font', { "$@font-face": _libSourceV2Style.genFontCSS("Ionic", _libSourceDataUriIoniconsWoffSource2["default"]) });

var titleHeight = 40;
var titleCommonStyle = {
    top: 0,
    left: 0,
    right: 0,
    height: titleHeight,
    backgroundColor: coolBlue,
    zIndex: '+10',
    boxShadow: '0px 4px 4px rgba(0, 0, 0, 0.4)',
    color: 'white',
    fontSize: 20
};
_libSourceV2Style.defineComponentStyle('app-screen', 'core', {
    "content": {
        position: 'absolute',
        top: titleHeight,
        bottom: 0,
        left: 0,
        right: 0,
        overflow: 'auto'
    },
    "title": _extends({
        position: 'absolute'
    }, titleCommonStyle)
});
_libSourceV2Style.defineComponentStyle('web-screen', 'core', {
    "content": {
        marginTop: titleHeight
    },
    "title": _extends({
        position: 'fixed'
    }, titleCommonStyle)
});

var titleClassName = _libSourceV2Environment2["default"].app === true ? "app-screen-core-title" : "web-screen-core-title";
var contentClassName = _libSourceV2Environment2["default"].app === true ? "app-screen-core-content" : "web-screen-core-content";

var Screen = (function (_React$Component) {
    _inherits(Screen, _React$Component);

    function Screen(props) {
        var _this = this;

        _classCallCheck(this, Screen);

        _React$Component.call(this, props);

        this.render = function () {

            return React.createElement(
                "div",
                null,
                React.createElement(
                    "div",
                    { className: contentClassName },
                    _this.props.children
                ),
                React.createElement(
                    "div",
                    { className: titleClassName },
                    React.createElement(
                        _libSourceUiv2CenterContent2["default"],
                        { height: "100%" },
                        _this.props.title
                    )
                ),
                React.createElement(_libSourceUiv2Dialog2["default"], null)
            );
        };
    }

    return Screen;
})(React.Component);

var Main = React.createClass({
    displayName: "Main",

    demo: function demo() {
        return _regeneratorRuntime.async(function demo$(context$1$0) {
            while (1) switch (context$1$0.prev = context$1$0.next) {
                case 0:
                    context$1$0.next = 2;
                    return _regeneratorRuntime.awrap(Dialog.confirm("Really?"));

                case 2:
                    context$1$0.t0 = context$1$0.sent;

                    if (!(context$1$0.t0 === true)) {
                        context$1$0.next = 5;
                        break;
                    }

                    console.log("Nope!");

                case 5:
                case "end":
                    return context$1$0.stop();
            }
        }, null, this);
    },
    getInitialState: function getInitialState() {
        return {
            checked: false,
            on: false,
            disabled: false,
            button: {
                image: false
            },
            index: -1,
            text: "",
            password: "",
            value: null,
            date: _libSourceV2Chrono2["default"](),
            rangeValue: 100
        };
    },
    render: function render() {
        var _this2 = this;

        var disabled = this.state.disabled;

        var textHandler = function textHandler(text, value) {
            // console.log('value', value);
            _this2.setState({ text: text, value: value });
        };

        return React.createElement(
            Screen,
            { title: "Test", backText: "test", width: 600, onBack: this.demo },
            React.createElement(_libSourceUiv2Input2["default"].Text, null),
            React.createElement(_libSourceUiv2Input2["default"].Date, null),
            React.createElement(
                _libSourceUiv2Combobox2["default"],
                { selectedIndex: 0 },
                arange(30, function (n) {
                    return React.createElement(
                        _libSourceUiv2Option2["default"],
                        null,
                        n
                    );
                })
            ),
            arange(60, function (n) {
                return React.createElement(
                    "div",
                    null,
                    n
                );
            })
        );
    }
});

// App.start(
//     <Route component={Wrapper}>
//         <Route path="/" component={Main} />
//         <Route path="/test" component={Main} />
//     </Route>
// );
window.qsel = function () {
    return document.querySelector.apply(document, arguments);
};
_libSourceV2Style.__setup();
(function callee$0$0() {
    return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
        while (1) switch (context$1$0.prev = context$1$0.next) {
            case 0:
                context$1$0.next = 2;
                return _regeneratorRuntime.awrap(deviceReady);

            case 2:
                ReactDOM.render(React.createElement(Main, null), qsel("#app-container"));

            case 3:
            case "end":
                return context$1$0.stop();
        }
    }, null, _this3);
})();

// const token = ajax.cancelToken();
// (async () => {
//     console.log(await ajax("http://axel669.net/echo/index2.php", {post: [1, 2, 3, 4], token}));
// })();
// chrono.trigger(2000, token.cancel);

// const isPow2 = n => (n & -n) === n;
// window.collatz = n => (n % 2 === 0) ? n / 2 : 3 * n + 1;
// window.check = start => {
//     while (true) {
//         if (start === 1) {
//             break;
//         }
//         console.log(start);
//         start = collatz(start);
//     }
// };
//
// const f = n => (n & -n);
// for (const i of frange(100)) {
//     console.log(i, f(i));
// }
/*<Image source={url} height={150} color="cyan" />*/ /*<Toggle.Awesome on={this.state.on} onChange={on => this.setState({on})} label={"Test"} subTitle="more text?" />*/ /*<Button text={<span>{disabled ? <Spinner size={20} /> : null}Button Text</span>} disabled={disabled} onTap={() => this.setState({disabled: true})} />*/ /*<Icon name="ion-calendar" size={20} />*/ /*<Radio selectedIndex={this.state.index} onChange={index => this.setState({index})} title="Test">
                                                                                                                                                                                                                                                                                                                                                                                 {Array.from(range({
                                                                                                                                                                                                                                                                                                                                                                                     count: 10,
                                                                                                                                                                                                                                                                                                                                                                                     map: n => <Option value={n ** n}>{n}</Option>
                                                                                                                                                                                                                                                                                                                                                                                 }))}
                                                                                                                                                                                                                                                                                                                                                                                 <Option><Image source={url} height={30} /></Option>
                                                                                                                                                                                                                                                                                                                                                                              </Radio>*/ /*<Button text="Test" />*/ /*<div style={{width: '75%', maxWidth: 480}}>
                                                                                                                                                                                                                                                                                                                                                                                                                       <Calendar selectedDate={new Date()} />
                                                                                                                                                                                                                                                                                                                                                                                                                    </div>*/ /*<Input.Date onChange={date => this.setState({date})} date={this.state.date} label="My Birthday?" iconName="ion-calendar" format={"Expiration Date: {month}/{day}/{year}"} />*/ /*<Button text="Wat" onTap={() => dialog.show({content: <Calendar selectedDate={new Date()} onDateSelected={cblog} />, title: "Select Date", buttons: [{text: "Cancel"}]})} />*/ /*<input type="datetime" />*/ /*<input type="time" onChange={evt => cblog(evt.target.value)} ref="test" />*/ /*<TimeInput />*/ /*<Card>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 <RangeInput value={this.state.rangeValue} max={255} onChange={rangeValue => this.setState({rangeValue})} />
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 <input type="range" value={this.state.rangeValue} max={255} onChange={evt => this.setState({rangeValue: evt.target.value})} />
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              </Card>*/ /*<Input.URL label="URL" value={this.state.text} onChange={(text, valid) => {console.log(text, valid); this.setState({text});}} />
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <Input.Email label="Email" value={this.state.text} onChange={(text, valid) => {console.log(text, valid); this.setState({text});}} />
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <Input.Password label="Password" value={this.state.password} onChange={password => this.setState({password})} />
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <Input.Range value={this.state.rangeValue} max={255} onChange={rangeValue => this.setState({rangeValue})} />
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <FileInput text="Test" onChange={files => console.log(files)} multiple />*/ /*<TimeSelector value={this.state.date} onChange={date => this.setState({date})} />*/ /*<Input.Time value={this.state.date} onChange={date => this.setState({date})} />
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          <Input.Date value={this.state.date} onChange={date => this.setState({date})} />*/ /*<Input.File onChange={cblog} text="Select File" />*/ /*<Flexbox colCount={3} padEnd maxItemWidth={100} align="space-around">
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      {arange(11, n => <Button text={n} block flush />)}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   </Flexbox>*/ /*<Grid colCount={3} rowCount={4}>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   {arange(11, n => <Button text={n} flush fill />)}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                </Grid>*/ /*<Pinboard height={200}>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             {arange(12,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 n => {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     const angle = (n / 6) * Math.PI;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     const x = Math.cos(angle) * 70 + 145;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     const y = Math.sin(angle) * 70 + 85;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     const pos = {top: y, left: x, width: 30, height: 30};
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       return <div pinInfo={pos} style={{width: '100%', height: '100%', backgroundColor: 'cyan'}}>{n}</div>;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             )}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          </Pinboard>*/ /*<Input.Search iconName="ion-search" placeholder="Search Stuffs" />*/ /*<Checkbox.Awesome checked={this.state.checked} onChange={checked => this.setState({checked})} label={"Test"} subTitle="more text?" />*/ /*<Button text="Normal" />
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         <Button text="Disabled" disabled />
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         <Button.Cancel text="Cancel" />
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         <Button.Confirm text="Confirm" />
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         <Input.Range value={this.state.rangeValue} max={255} onChange={rangeValue => this.setState({rangeValue})} />*/ /*<Form label="Form">*/ /*<Radio layout={Pinboard} layout-height={200}>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   {arange(12,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       n => {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           const angle = (n / 6) * Math.PI;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           const x = Math.cos(angle) * 70 + 145;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           const y = Math.sin(angle) * 70 + 85;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           const pos = {top: y, left: x, width: 30, height: 30};
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             return <div pinInfo={pos} style={{width: '100%', height: '100%'}}>{n}</div>;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   )}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                </Radio>*/ /*<Radio title="Test">
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              {Array.from(range({
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  count: 10,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  map: n => <Option value={n ** n}>{n}</Option>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              }))}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              <Option><Image source={url} height={30} /></Option>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           </Radio>*/ /*<Input.Text formName="Text" placeholder="Text" />
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      <Input.Password formName="Password" placeholder="Password" />
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      <Input.Search formName="Search" placeholder="Search" />
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      <Input.URL formName="URL" placeholder="URL" />
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      <Input.Email formName="Email" placeholder="Email" />
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       <Input.Date formName="date" />
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      <Input.Time formName="time" />
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      <Input.File formName="file" multiple valueFormat={list => `Files Selected: ${list.length}`} />
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      <Input.Range formName="range" min={0} max={255} />*/ /*</Form>*/ /*<div style={{position: 'absolute', bottom: 0, height: 50, width: 50, backgroundColor: 'cyan'}} />*/ /*<Input.File*/ /*<Card>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <Pinboard height={50}>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <Icon name="ion-happy" size={40} pinInfo={{top: 0, left: 10, width: 40, height: 50}} />
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <div pinInfo={{top: 0, left: 55}}>User Name Thing?</div>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <div pinInfo={{top: 30, left: 55, fontSize: 11}}>User information about positiond and stuff</div>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <div pinInfo={{top: 5, left: 5, width: 10, height: 10, backgroundColor: 'cyan'}} />
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                </Pinboard>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             </Card>*/

},{"babel-runtime/core-js/array/from":46,"babel-runtime/helpers/class-call-check":58,"babel-runtime/helpers/extends":59,"babel-runtime/helpers/inherits":60,"babel-runtime/helpers/interop-require-default":61,"babel-runtime/regenerator":149,"lib-source/data-uri/ionicons.woff.source":6,"lib-source/data-uri/roboto-light.woff.source":8,"lib-source/uiv2/Calendar":10,"lib-source/uiv2/Card":11,"lib-source/uiv2/CenterContent":12,"lib-source/uiv2/Checkbox":13,"lib-source/uiv2/Combobox":14,"lib-source/uiv2/Form":15,"lib-source/uiv2/Image":17,"lib-source/uiv2/Input":18,"lib-source/uiv2/Option":19,"lib-source/uiv2/Radio":20,"lib-source/uiv2/Spinner":21,"lib-source/uiv2/Toggle":23,"lib-source/uiv2/Touchable":24,"lib-source/uiv2/button":25,"lib-source/uiv2/dialog":26,"lib-source/uiv2/icon":27,"lib-source/uiv2/iconbutton":28,"lib-source/uiv2/layout/Flexbox":33,"lib-source/uiv2/layout/Grid":34,"lib-source/uiv2/layout/Pinboard":35,"lib-source/uiv2/ripple":36,"lib-source/v2/Environment":38,"lib-source/v2/ajax":39,"lib-source/v2/chrono":40,"lib-source/v2/crypto":41,"lib-source/v2/shared":42,"lib-source/v2/style":43,"lib-source/v2/utils":44,"lib-source/v2/zip":45}]},{},[371])
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJleHRlcm5hbC9kZWZsYXRlLmpzLnNvdXJjZSIsImV4dGVybmFsL2luZmxhdGUuanMuc291cmNlIiwiZXh0ZXJuYWwvei13b3JrZXIuanMuc291cmNlIiwiZXh0ZXJuYWwvemlwLWV4dC5qcyIsImV4dGVybmFsL3ppcC5qcyIsImxpYi1zb3VyY2UvZGF0YS11cmkvaW9uaWNvbnMud29mZi5zb3VyY2UiLCJsaWItc291cmNlL2RhdGEtdXJpL2xvYWQtc3Bpbm5lci5naWYuc291cmNlIiwibGliLXNvdXJjZS9kYXRhLXVyaS9yb2JvdG8tbGlnaHQud29mZi5zb3VyY2UiLCJDOi9Vc2Vycy9BeGVsMS9Eb2N1bWVudHMvcHJvZ3JhbW1pbmcvZ2l0aHViL0NvcmludGhpYW4vbGliLXNvdXJjZS91aXYyL0J1dHRvbi5qcyIsIkM6L1VzZXJzL0F4ZWwxL0RvY3VtZW50cy9wcm9ncmFtbWluZy9naXRodWIvQ29yaW50aGlhbi9saWItc291cmNlL3VpdjIvQ2FsZW5kYXIuanMiLCJDOi9Vc2Vycy9BeGVsMS9Eb2N1bWVudHMvcHJvZ3JhbW1pbmcvZ2l0aHViL0NvcmludGhpYW4vbGliLXNvdXJjZS91aXYyL0NhcmQuanMiLCJDOi9Vc2Vycy9BeGVsMS9Eb2N1bWVudHMvcHJvZ3JhbW1pbmcvZ2l0aHViL0NvcmludGhpYW4vbGliLXNvdXJjZS91aXYyL0NlbnRlckNvbnRlbnQuanMiLCJDOi9Vc2Vycy9BeGVsMS9Eb2N1bWVudHMvcHJvZ3JhbW1pbmcvZ2l0aHViL0NvcmludGhpYW4vbGliLXNvdXJjZS91aXYyL0NoZWNrYm94LmpzIiwiQzovVXNlcnMvQXhlbDEvRG9jdW1lbnRzL3Byb2dyYW1taW5nL2dpdGh1Yi9Db3JpbnRoaWFuL2xpYi1zb3VyY2UvdWl2Mi9Db21ib2JveC5qcyIsIkM6L1VzZXJzL0F4ZWwxL0RvY3VtZW50cy9wcm9ncmFtbWluZy9naXRodWIvQ29yaW50aGlhbi9saWItc291cmNlL3VpdjIvRm9ybS5qcyIsIkM6L1VzZXJzL0F4ZWwxL0RvY3VtZW50cy9wcm9ncmFtbWluZy9naXRodWIvQ29yaW50aGlhbi9saWItc291cmNlL3VpdjIvSWNvbi5qcyIsIkM6L1VzZXJzL0F4ZWwxL0RvY3VtZW50cy9wcm9ncmFtbWluZy9naXRodWIvQ29yaW50aGlhbi9saWItc291cmNlL3VpdjIvSW1hZ2UuanMiLCJDOi9Vc2Vycy9BeGVsMS9Eb2N1bWVudHMvcHJvZ3JhbW1pbmcvZ2l0aHViL0NvcmludGhpYW4vbGliLXNvdXJjZS91aXYyL0lucHV0LmpzIiwiQzovVXNlcnMvQXhlbDEvRG9jdW1lbnRzL3Byb2dyYW1taW5nL2dpdGh1Yi9Db3JpbnRoaWFuL2xpYi1zb3VyY2UvdWl2Mi9PcHRpb24uanMiLCJDOi9Vc2Vycy9BeGVsMS9Eb2N1bWVudHMvcHJvZ3JhbW1pbmcvZ2l0aHViL0NvcmludGhpYW4vbGliLXNvdXJjZS91aXYyL1JhZGlvLmpzIiwiQzovVXNlcnMvQXhlbDEvRG9jdW1lbnRzL3Byb2dyYW1taW5nL2dpdGh1Yi9Db3JpbnRoaWFuL2xpYi1zb3VyY2UvdWl2Mi9TcGlubmVyLmpzIiwiQzovVXNlcnMvQXhlbDEvRG9jdW1lbnRzL3Byb2dyYW1taW5nL2dpdGh1Yi9Db3JpbnRoaWFuL2xpYi1zb3VyY2UvdWl2Mi9UaW1lU2VsZWN0b3IuanMiLCJDOi9Vc2Vycy9BeGVsMS9Eb2N1bWVudHMvcHJvZ3JhbW1pbmcvZ2l0aHViL0NvcmludGhpYW4vbGliLXNvdXJjZS91aXYyL1RvZ2dsZS5qcyIsIkM6L1VzZXJzL0F4ZWwxL0RvY3VtZW50cy9wcm9ncmFtbWluZy9naXRodWIvQ29yaW50aGlhbi9saWItc291cmNlL3VpdjIvVG91Y2hhYmxlLmpzIiwiQzovVXNlcnMvQXhlbDEvRG9jdW1lbnRzL3Byb2dyYW1taW5nL2dpdGh1Yi9Db3JpbnRoaWFuL2xpYi1zb3VyY2UvdWl2Mi9idXR0b24uanMiLCJDOi9Vc2Vycy9BeGVsMS9Eb2N1bWVudHMvcHJvZ3JhbW1pbmcvZ2l0aHViL0NvcmludGhpYW4vbGliLXNvdXJjZS91aXYyL2RpYWxvZy5qcyIsIkM6L1VzZXJzL0F4ZWwxL0RvY3VtZW50cy9wcm9ncmFtbWluZy9naXRodWIvQ29yaW50aGlhbi9saWItc291cmNlL3VpdjIvaWNvbi5qcyIsIkM6L1VzZXJzL0F4ZWwxL0RvY3VtZW50cy9wcm9ncmFtbWluZy9naXRodWIvQ29yaW50aGlhbi9saWItc291cmNlL3VpdjIvaWNvbmJ1dHRvbi5qcyIsIkM6L1VzZXJzL0F4ZWwxL0RvY3VtZW50cy9wcm9ncmFtbWluZy9naXRodWIvQ29yaW50aGlhbi9saWItc291cmNlL3VpdjIvaW5wdXQvRGF0ZUlucHV0LmpzIiwiQzovVXNlcnMvQXhlbDEvRG9jdW1lbnRzL3Byb2dyYW1taW5nL2dpdGh1Yi9Db3JpbnRoaWFuL2xpYi1zb3VyY2UvdWl2Mi9pbnB1dC9GaWxlSW5wdXQuanMiLCJDOi9Vc2Vycy9BeGVsMS9Eb2N1bWVudHMvcHJvZ3JhbW1pbmcvZ2l0aHViL0NvcmludGhpYW4vbGliLXNvdXJjZS91aXYyL2lucHV0L1JhbmdlSW5wdXQuanMiLCJDOi9Vc2Vycy9BeGVsMS9Eb2N1bWVudHMvcHJvZ3JhbW1pbmcvZ2l0aHViL0NvcmludGhpYW4vbGliLXNvdXJjZS91aXYyL2lucHV0L1RpbWVJbnB1dC5qcyIsIkM6L1VzZXJzL0F4ZWwxL0RvY3VtZW50cy9wcm9ncmFtbWluZy9naXRodWIvQ29yaW50aGlhbi9saWItc291cmNlL3VpdjIvbGF5b3V0L0ZsZXhib3guanMiLCJDOi9Vc2Vycy9BeGVsMS9Eb2N1bWVudHMvcHJvZ3JhbW1pbmcvZ2l0aHViL0NvcmludGhpYW4vbGliLXNvdXJjZS91aXYyL2xheW91dC9HcmlkLmpzIiwiQzovVXNlcnMvQXhlbDEvRG9jdW1lbnRzL3Byb2dyYW1taW5nL2dpdGh1Yi9Db3JpbnRoaWFuL2xpYi1zb3VyY2UvdWl2Mi9sYXlvdXQvUGluYm9hcmQuanMiLCJDOi9Vc2Vycy9BeGVsMS9Eb2N1bWVudHMvcHJvZ3JhbW1pbmcvZ2l0aHViL0NvcmludGhpYW4vbGliLXNvdXJjZS91aXYyL3JpcHBsZS5qcyIsIkM6L1VzZXJzL0F4ZWwxL0RvY3VtZW50cy9wcm9ncmFtbWluZy9naXRodWIvQ29yaW50aGlhbi9saWItc291cmNlL3VpdjIvdmFycy5qcyIsIkM6L1VzZXJzL0F4ZWwxL0RvY3VtZW50cy9wcm9ncmFtbWluZy9naXRodWIvQ29yaW50aGlhbi9saWItc291cmNlL3YyL0Vudmlyb25tZW50LmpzIiwiQzovVXNlcnMvQXhlbDEvRG9jdW1lbnRzL3Byb2dyYW1taW5nL2dpdGh1Yi9Db3JpbnRoaWFuL2xpYi1zb3VyY2UvdjIvYWpheC5qcyIsIkM6L1VzZXJzL0F4ZWwxL0RvY3VtZW50cy9wcm9ncmFtbWluZy9naXRodWIvQ29yaW50aGlhbi9saWItc291cmNlL3YyL2Nocm9uby5qcyIsIkM6L1VzZXJzL0F4ZWwxL0RvY3VtZW50cy9wcm9ncmFtbWluZy9naXRodWIvQ29yaW50aGlhbi9saWItc291cmNlL3YyL2NyeXB0by5qcyIsIkM6L1VzZXJzL0F4ZWwxL0RvY3VtZW50cy9wcm9ncmFtbWluZy9naXRodWIvQ29yaW50aGlhbi9saWItc291cmNlL3YyL3NoYXJlZC5qcyIsIkM6L1VzZXJzL0F4ZWwxL0RvY3VtZW50cy9wcm9ncmFtbWluZy9naXRodWIvQ29yaW50aGlhbi9saWItc291cmNlL3YyL3N0eWxlLmpzIiwiQzovVXNlcnMvQXhlbDEvRG9jdW1lbnRzL3Byb2dyYW1taW5nL2dpdGh1Yi9Db3JpbnRoaWFuL2xpYi1zb3VyY2UvdjIvdXRpbHMuanMiLCJDOi9Vc2Vycy9BeGVsMS9Eb2N1bWVudHMvcHJvZ3JhbW1pbmcvZ2l0aHViL0NvcmludGhpYW4vbGliLXNvdXJjZS92Mi96aXAuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL2FycmF5L2Zyb20uanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL2dldC1pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2Fzc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2NyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2RlZmluZS1wcm9wZXJ0aWVzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZW50cmllcy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2ZyZWV6ZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2tleXMuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9zZXQtcHJvdG90eXBlLW9mLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9wcm9taXNlLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9zZXQuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL3N5bWJvbC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3MtY2FsbC1jaGVjay5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvZXh0ZW5kcy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHMuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL2ludGVyb3AtcmVxdWlyZS1kZWZhdWx0LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvaGVscGVycy9vYmplY3Qtd2l0aG91dC1wcm9wZXJ0aWVzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9hcnJheS9mcm9tLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9nZXQtaXRlcmF0b3IuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9hc3NpZ24uanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9jcmVhdGUuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9kZWZpbmUtcHJvcGVydGllcy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2VudHJpZXMuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9mcmVlemUuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vcHJvbWlzZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vc2V0LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5hLWZ1bmN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuYWRkLXRvLXVuc2NvcGFibGVzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuYW4tb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuY2xhc3NvZi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmNvZi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmNvbGxlY3Rpb24tc3Ryb25nLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuY29sbGVjdGlvbi10by1qc29uLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuY29sbGVjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmNvcmUuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5jdHguanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5kZWZpbmVkLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuZGVzY3JpcHRvcnMuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5kb20tY3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuZW51bS1rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuZXhwb3J0LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuZmFpbHMuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5mb3Itb2YuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5nZXQtbmFtZXMuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5nbG9iYWwuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5oYXMuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5oaWRlLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuaHRtbC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmludm9rZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmlvYmplY3QuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5pcy1hcnJheS1pdGVyLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuaXMtYXJyYXkuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5pcy1vYmplY3QuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5pdGVyLWNhbGwuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5pdGVyLWNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLml0ZXItZGVmaW5lLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuaXRlci1kZXRlY3QuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5pdGVyLXN0ZXAuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5pdGVyYXRvcnMuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmtleW9mLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQubGlicmFyeS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLm1pY3JvdGFzay5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLm9iamVjdC1hc3NpZ24uanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5vYmplY3Qtc2FwLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQub2JqZWN0LXRvLWFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQucHJvcGVydHktZGVzYy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLnJlZGVmaW5lLWFsbC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLnJlZGVmaW5lLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuc2FtZS12YWx1ZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLnNldC1wcm90by5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLnNldC1zcGVjaWVzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuc2V0LXRvLXN0cmluZy10YWcuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5zaGFyZWQuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5zcGVjaWVzLWNvbnN0cnVjdG9yLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuc3RyaWN0LW5ldy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLnN0cmluZy1hdC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLnRhc2suanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC50by1pbnRlZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQudG8taW9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLnRvLWxlbmd0aC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLnRvLW9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLnVpZC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLndrcy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3IuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LmFycmF5LmZyb20uanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LmFycmF5Lml0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuYXNzaWduLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuZnJlZXplLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3Qua2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LnNldC1wcm90b3R5cGUtb2YuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LnByb21pc2UuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LnNldC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5zeW1ib2wuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3Lm9iamVjdC5lbnRyaWVzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5zZXQudG8tanNvbi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvcmVnZW5lcmF0b3IvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9yZWdlbmVyYXRvci9ydW50aW1lLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9saWIvYjY0LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvbm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktY2lwaGVyL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktY2lwaGVyL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWFlcy9hZXMuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktY2lwaGVyL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWFlcy9hdXRoQ2lwaGVyLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWNpcGhlci9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1hZXMvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1jaXBoZXIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktYWVzL2RlY3J5cHRlci5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1jaXBoZXIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktYWVzL2VuY3J5cHRlci5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1jaXBoZXIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktYWVzL2doYXNoLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWNpcGhlci9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1hZXMvbW9kZXMuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktY2lwaGVyL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWFlcy9tb2Rlcy9jYmMuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktY2lwaGVyL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWFlcy9tb2Rlcy9jZmIuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktY2lwaGVyL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWFlcy9tb2Rlcy9jZmIxLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWNpcGhlci9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1hZXMvbW9kZXMvY2ZiOC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1jaXBoZXIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktYWVzL21vZGVzL2N0ci5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1jaXBoZXIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktYWVzL21vZGVzL2VjYi5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1jaXBoZXIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktYWVzL21vZGVzL29mYi5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1jaXBoZXIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktYWVzL25vZGVfbW9kdWxlcy9idWZmZXIteG9yL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWNpcGhlci9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1hZXMvbm9kZV9tb2R1bGVzL2NpcGhlci1iYXNlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWNpcGhlci9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1hZXMvc3RyZWFtQ2lwaGVyLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWNpcGhlci9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1kZXMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktY2lwaGVyL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWRlcy9tb2Rlcy5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1jaXBoZXIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktZGVzL25vZGVfbW9kdWxlcy9jaXBoZXItYmFzZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1jaXBoZXIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktZGVzL25vZGVfbW9kdWxlcy9kZXMuanMvbGliL2Rlcy5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1jaXBoZXIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktZGVzL25vZGVfbW9kdWxlcy9kZXMuanMvbGliL2Rlcy9jYmMuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktY2lwaGVyL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWRlcy9ub2RlX21vZHVsZXMvZGVzLmpzL2xpYi9kZXMvY2lwaGVyLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWNpcGhlci9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1kZXMvbm9kZV9tb2R1bGVzL2Rlcy5qcy9saWIvZGVzL2Rlcy5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1jaXBoZXIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktZGVzL25vZGVfbW9kdWxlcy9kZXMuanMvbGliL2Rlcy9lZGUuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktY2lwaGVyL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWRlcy9ub2RlX21vZHVsZXMvZGVzLmpzL2xpYi9kZXMvdXRpbHMuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktY2lwaGVyL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWRlcy9ub2RlX21vZHVsZXMvZGVzLmpzL25vZGVfbW9kdWxlcy9taW5pbWFsaXN0aWMtYXNzZXJ0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWNpcGhlci9ub2RlX21vZHVsZXMvZXZwX2J5dGVzdG9rZXkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktc2lnbi9hbGdvcy5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktc2lnbi9jdXJ2ZXMuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktc2lnbi9ub2RlX21vZHVsZXMvYm4uanMvbGliL2JuLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktcnNhL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vbm9kZV9tb2R1bGVzL2VsbGlwdGljL2xpYi9lbGxpcHRpYy5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL25vZGVfbW9kdWxlcy9lbGxpcHRpYy9saWIvZWxsaXB0aWMvY3VydmUvYmFzZS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL25vZGVfbW9kdWxlcy9lbGxpcHRpYy9saWIvZWxsaXB0aWMvY3VydmUvZWR3YXJkcy5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL25vZGVfbW9kdWxlcy9lbGxpcHRpYy9saWIvZWxsaXB0aWMvY3VydmUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktc2lnbi9ub2RlX21vZHVsZXMvZWxsaXB0aWMvbGliL2VsbGlwdGljL2N1cnZlL21vbnQuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktc2lnbi9ub2RlX21vZHVsZXMvZWxsaXB0aWMvbGliL2VsbGlwdGljL2N1cnZlL3Nob3J0LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vbm9kZV9tb2R1bGVzL2VsbGlwdGljL2xpYi9lbGxpcHRpYy9jdXJ2ZXMuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktc2lnbi9ub2RlX21vZHVsZXMvZWxsaXB0aWMvbGliL2VsbGlwdGljL2VjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vbm9kZV9tb2R1bGVzL2VsbGlwdGljL2xpYi9lbGxpcHRpYy9lYy9rZXkuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktc2lnbi9ub2RlX21vZHVsZXMvZWxsaXB0aWMvbGliL2VsbGlwdGljL2VjL3NpZ25hdHVyZS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL25vZGVfbW9kdWxlcy9lbGxpcHRpYy9saWIvZWxsaXB0aWMvZWRkc2EvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktc2lnbi9ub2RlX21vZHVsZXMvZWxsaXB0aWMvbGliL2VsbGlwdGljL2VkZHNhL2tleS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL25vZGVfbW9kdWxlcy9lbGxpcHRpYy9saWIvZWxsaXB0aWMvZWRkc2Evc2lnbmF0dXJlLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vbm9kZV9tb2R1bGVzL2VsbGlwdGljL2xpYi9lbGxpcHRpYy9obWFjLWRyYmcuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktc2lnbi9ub2RlX21vZHVsZXMvZWxsaXB0aWMvbGliL2VsbGlwdGljL3ByZWNvbXB1dGVkL3NlY3AyNTZrMS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL25vZGVfbW9kdWxlcy9lbGxpcHRpYy9saWIvZWxsaXB0aWMvdXRpbHMuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktc2lnbi9ub2RlX21vZHVsZXMvZWxsaXB0aWMvbm9kZV9tb2R1bGVzL2Jyb3JhbmQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktc2lnbi9ub2RlX21vZHVsZXMvZWxsaXB0aWMvbm9kZV9tb2R1bGVzL2hhc2guanMvbGliL2hhc2guanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktc2lnbi9ub2RlX21vZHVsZXMvZWxsaXB0aWMvbm9kZV9tb2R1bGVzL2hhc2guanMvbGliL2hhc2gvY29tbW9uLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vbm9kZV9tb2R1bGVzL2VsbGlwdGljL25vZGVfbW9kdWxlcy9oYXNoLmpzL2xpYi9oYXNoL2htYWMuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktc2lnbi9ub2RlX21vZHVsZXMvZWxsaXB0aWMvbm9kZV9tb2R1bGVzL2hhc2guanMvbGliL2hhc2gvcmlwZW1kLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vbm9kZV9tb2R1bGVzL2VsbGlwdGljL25vZGVfbW9kdWxlcy9oYXNoLmpzL2xpYi9oYXNoL3NoYS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL25vZGVfbW9kdWxlcy9lbGxpcHRpYy9ub2RlX21vZHVsZXMvaGFzaC5qcy9saWIvaGFzaC91dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL25vZGVfbW9kdWxlcy9lbGxpcHRpYy9wYWNrYWdlLmpzb24iLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktc2lnbi9ub2RlX21vZHVsZXMvcGFyc2UtYXNuMS9hZXNpZC5qc29uIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vbm9kZV9tb2R1bGVzL3BhcnNlLWFzbjEvYXNuMS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL25vZGVfbW9kdWxlcy9wYXJzZS1hc24xL2ZpeFByb2MuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktc2lnbi9ub2RlX21vZHVsZXMvcGFyc2UtYXNuMS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL25vZGVfbW9kdWxlcy9wYXJzZS1hc24xL25vZGVfbW9kdWxlcy9hc24xLmpzL2xpYi9hc24xLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vbm9kZV9tb2R1bGVzL3BhcnNlLWFzbjEvbm9kZV9tb2R1bGVzL2FzbjEuanMvbGliL2FzbjEvYXBpLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vbm9kZV9tb2R1bGVzL3BhcnNlLWFzbjEvbm9kZV9tb2R1bGVzL2FzbjEuanMvbGliL2FzbjEvYmFzZS9idWZmZXIuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktc2lnbi9ub2RlX21vZHVsZXMvcGFyc2UtYXNuMS9ub2RlX21vZHVsZXMvYXNuMS5qcy9saWIvYXNuMS9iYXNlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vbm9kZV9tb2R1bGVzL3BhcnNlLWFzbjEvbm9kZV9tb2R1bGVzL2FzbjEuanMvbGliL2FzbjEvYmFzZS9ub2RlLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vbm9kZV9tb2R1bGVzL3BhcnNlLWFzbjEvbm9kZV9tb2R1bGVzL2FzbjEuanMvbGliL2FzbjEvYmFzZS9yZXBvcnRlci5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL25vZGVfbW9kdWxlcy9wYXJzZS1hc24xL25vZGVfbW9kdWxlcy9hc24xLmpzL2xpYi9hc24xL2NvbnN0YW50cy9kZXIuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktc2lnbi9ub2RlX21vZHVsZXMvcGFyc2UtYXNuMS9ub2RlX21vZHVsZXMvYXNuMS5qcy9saWIvYXNuMS9jb25zdGFudHMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktc2lnbi9ub2RlX21vZHVsZXMvcGFyc2UtYXNuMS9ub2RlX21vZHVsZXMvYXNuMS5qcy9saWIvYXNuMS9kZWNvZGVycy9kZXIuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktc2lnbi9ub2RlX21vZHVsZXMvcGFyc2UtYXNuMS9ub2RlX21vZHVsZXMvYXNuMS5qcy9saWIvYXNuMS9kZWNvZGVycy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL25vZGVfbW9kdWxlcy9wYXJzZS1hc24xL25vZGVfbW9kdWxlcy9hc24xLmpzL2xpYi9hc24xL2RlY29kZXJzL3BlbS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL25vZGVfbW9kdWxlcy9wYXJzZS1hc24xL25vZGVfbW9kdWxlcy9hc24xLmpzL2xpYi9hc24xL2VuY29kZXJzL2Rlci5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL25vZGVfbW9kdWxlcy9wYXJzZS1hc24xL25vZGVfbW9kdWxlcy9hc24xLmpzL2xpYi9hc24xL2VuY29kZXJzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vbm9kZV9tb2R1bGVzL3BhcnNlLWFzbjEvbm9kZV9tb2R1bGVzL2FzbjEuanMvbGliL2FzbjEvZW5jb2RlcnMvcGVtLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vbm9kZV9tb2R1bGVzL3BhcnNlLWFzbjEvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktYWVzL2Flcy5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL25vZGVfbW9kdWxlcy9wYXJzZS1hc24xL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWFlcy9hdXRoQ2lwaGVyLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vbm9kZV9tb2R1bGVzL3BhcnNlLWFzbjEvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktYWVzL2RlY3J5cHRlci5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL25vZGVfbW9kdWxlcy9wYXJzZS1hc24xL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWFlcy9lbmNyeXB0ZXIuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktc2lnbi9ub2RlX21vZHVsZXMvcGFyc2UtYXNuMS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1hZXMvZ2hhc2guanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktc2lnbi9ub2RlX21vZHVsZXMvcGFyc2UtYXNuMS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1hZXMvbW9kZXMvY2ZiLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vbm9kZV9tb2R1bGVzL3BhcnNlLWFzbjEvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktYWVzL21vZGVzL2NmYjEuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktc2lnbi9ub2RlX21vZHVsZXMvcGFyc2UtYXNuMS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1hZXMvbW9kZXMvY2ZiOC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL25vZGVfbW9kdWxlcy9wYXJzZS1hc24xL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWFlcy9tb2Rlcy9jdHIuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktc2lnbi9ub2RlX21vZHVsZXMvcGFyc2UtYXNuMS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1hZXMvbW9kZXMvb2ZiLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vbm9kZV9tb2R1bGVzL3BhcnNlLWFzbjEvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktYWVzL25vZGVfbW9kdWxlcy9idWZmZXIteG9yL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vbm9kZV9tb2R1bGVzL3BhcnNlLWFzbjEvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktYWVzL25vZGVfbW9kdWxlcy9jaXBoZXItYmFzZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL25vZGVfbW9kdWxlcy9wYXJzZS1hc24xL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWFlcy9zdHJlYW1DaXBoZXIuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktc2lnbi9ub2RlX21vZHVsZXMvcGFyc2UtYXNuMS9ub2RlX21vZHVsZXMvZXZwX2J5dGVzdG9rZXkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktc2lnbi9zaWduLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vdmVyaWZ5LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcmVhdGUtZWNkaC9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcmVhdGUtaGFzaC9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcmVhdGUtaGFzaC9oZWxwZXJzLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcmVhdGUtaGFzaC9tZDUuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyZWF0ZS1oYXNoL25vZGVfbW9kdWxlcy9jaXBoZXItYmFzZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3JlYXRlLWhhc2gvbm9kZV9tb2R1bGVzL3JpcGVtZDE2MC9saWIvcmlwZW1kMTYwLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcmVhdGUtaGFzaC9ub2RlX21vZHVsZXMvc2hhLmpzL2hhc2guanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyZWF0ZS1oYXNoL25vZGVfbW9kdWxlcy9zaGEuanMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyZWF0ZS1oYXNoL25vZGVfbW9kdWxlcy9zaGEuanMvc2hhLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcmVhdGUtaGFzaC9ub2RlX21vZHVsZXMvc2hhLmpzL3NoYTEuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyZWF0ZS1oYXNoL25vZGVfbW9kdWxlcy9zaGEuanMvc2hhMjI0LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcmVhdGUtaGFzaC9ub2RlX21vZHVsZXMvc2hhLmpzL3NoYTI1Ni5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3JlYXRlLWhhc2gvbm9kZV9tb2R1bGVzL3NoYS5qcy9zaGEzODQuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyZWF0ZS1oYXNoL25vZGVfbW9kdWxlcy9zaGEuanMvc2hhNTEyLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcmVhdGUtaG1hYy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9kaWZmaWUtaGVsbG1hbi9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9kaWZmaWUtaGVsbG1hbi9saWIvZGguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2RpZmZpZS1oZWxsbWFuL2xpYi9nZW5lcmF0ZVByaW1lLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9kaWZmaWUtaGVsbG1hbi9saWIvcHJpbWVzLmpzb24iLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2RpZmZpZS1oZWxsbWFuL25vZGVfbW9kdWxlcy9taWxsZXItcmFiaW4vbGliL21yLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wYmtkZjIvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHVibGljLWVuY3J5cHQvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHVibGljLWVuY3J5cHQvbWdmLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wdWJsaWMtZW5jcnlwdC9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1yc2EvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3B1YmxpYy1lbmNyeXB0L25vZGVfbW9kdWxlcy9wYXJzZS1hc24xL2ZpeFByb2MuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3B1YmxpYy1lbmNyeXB0L25vZGVfbW9kdWxlcy9wYXJzZS1hc24xL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wdWJsaWMtZW5jcnlwdC9ub2RlX21vZHVsZXMvcGFyc2UtYXNuMS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1hZXMvYWVzLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wdWJsaWMtZW5jcnlwdC9ub2RlX21vZHVsZXMvcGFyc2UtYXNuMS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1hZXMvYXV0aENpcGhlci5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHVibGljLWVuY3J5cHQvbm9kZV9tb2R1bGVzL3BhcnNlLWFzbjEvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktYWVzL2RlY3J5cHRlci5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHVibGljLWVuY3J5cHQvbm9kZV9tb2R1bGVzL3BhcnNlLWFzbjEvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktYWVzL2VuY3J5cHRlci5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHVibGljLWVuY3J5cHQvbm9kZV9tb2R1bGVzL3BhcnNlLWFzbjEvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktYWVzL2doYXNoLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wdWJsaWMtZW5jcnlwdC9ub2RlX21vZHVsZXMvcGFyc2UtYXNuMS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1hZXMvbW9kZXMvY2ZiLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wdWJsaWMtZW5jcnlwdC9ub2RlX21vZHVsZXMvcGFyc2UtYXNuMS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1hZXMvbW9kZXMvY2ZiMS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHVibGljLWVuY3J5cHQvbm9kZV9tb2R1bGVzL3BhcnNlLWFzbjEvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktYWVzL21vZGVzL2NmYjguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3B1YmxpYy1lbmNyeXB0L25vZGVfbW9kdWxlcy9wYXJzZS1hc24xL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWFlcy9tb2Rlcy9jdHIuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3B1YmxpYy1lbmNyeXB0L25vZGVfbW9kdWxlcy9wYXJzZS1hc24xL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWFlcy9tb2Rlcy9vZmIuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3B1YmxpYy1lbmNyeXB0L25vZGVfbW9kdWxlcy9wYXJzZS1hc24xL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWFlcy9ub2RlX21vZHVsZXMvYnVmZmVyLXhvci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHVibGljLWVuY3J5cHQvbm9kZV9tb2R1bGVzL3BhcnNlLWFzbjEvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktYWVzL25vZGVfbW9kdWxlcy9jaXBoZXItYmFzZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHVibGljLWVuY3J5cHQvbm9kZV9tb2R1bGVzL3BhcnNlLWFzbjEvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktYWVzL3N0cmVhbUNpcGhlci5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHVibGljLWVuY3J5cHQvbm9kZV9tb2R1bGVzL3BhcnNlLWFzbjEvbm9kZV9tb2R1bGVzL2V2cF9ieXRlc3Rva2V5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wdWJsaWMtZW5jcnlwdC9wcml2YXRlRGVjcnlwdC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHVibGljLWVuY3J5cHQvcHVibGljRW5jcnlwdC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHVibGljLWVuY3J5cHQvd2l0aFB1YmxpYy5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHVibGljLWVuY3J5cHQveG9yLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yYW5kb21ieXRlcy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9pbnNlcnQtbW9kdWxlLWdsb2JhbHMvbm9kZV9tb2R1bGVzL2lzLWJ1ZmZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vZHVwbGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9kdXBsZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV93cml0YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbm9kZV9tb2R1bGVzL2NvcmUtdXRpbC1pcy9saWIvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbm9kZV9tb2R1bGVzL3Byb2Nlc3MtbmV4dGljay1hcmdzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9ub2RlX21vZHVsZXMvdXRpbC1kZXByZWNhdGUvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vcGFzc3Rocm91Z2guanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS90cmFuc2Zvcm0uanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3dyaXRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3N0cmluZ19kZWNvZGVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3ZtLWJyb3dzZXJpZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvdm0tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvaW5kZXhvZi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy94cmVnZXhwL3hyZWdleHAtYWxsLmpzIiwiQzovVXNlcnMvQXhlbDEvRG9jdW1lbnRzL3Byb2dyYW1taW5nL2dpdGh1Yi9Db3JpbnRoaWFuL3Rlc3QuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBOztBQ0RBO0FBQ0E7O0FDREE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbFBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTs7QUNEQTtBQUNBOztBQ0RBO0FBQ0E7O0FDREE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTs7QUNGQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7O0FDRkE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaFNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBOzs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3RvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDeGdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2pMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDakdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN4SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN6SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzFGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMxRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaFFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3ZHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2p4SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdFpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMzRCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNXdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0tBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDckhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNyR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbG1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3VEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNqTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ2pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3hJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQ2xHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDMUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3pMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3ZHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMxSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMzSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDMUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2xOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNwR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDaEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzdJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMxUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNwS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNqSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDaEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3JHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNqTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ2pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3hJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQ2xHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDMUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzNHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzlGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0ZBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQy84QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNqaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMzR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbkVBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTs7QUNEQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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d0JBQVMsQ0FBQztxQkFBVTtpQkFBQSxDQUFDO2FBQy9CO1lBQ1YsTUFBTSxDQUFDLEVBQUUsRUFBRSxVQUFBLENBQUM7dUJBQUk7OztvQkFBTSxDQUFDO2lCQUFPO2FBQUEsQ0FBQztTQW9HM0IsQ0FDWDtLQUNMO0NBQ0osQ0FBQyxDQUFDOzs7Ozs7OztBQVFILE1BQU0sQ0FBQyxJQUFJLEdBQUc7V0FBYSxRQUFRLENBQUMsYUFBYSxNQUFBLENBQXRCLFFBQVEsWUFBdUI7Q0FBQSxDQUFDO0FBQzNELDJCQUFjLENBQUM7QUFDZixDQUFDOzs7OztpREFDUyxXQUFXOzs7QUFDakIsd0JBQVEsQ0FBQyxNQUFNLENBQ1gsb0JBQUMsSUFBSSxPQUFHLEVBQ1IsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQ3pCLENBQUM7Ozs7Ozs7RUFDTCxFQUFHLENBQUMiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwibW9kdWxlLmV4cG9ydHMgPSBcIi8qXFxyXFxuIENvcHlyaWdodCAoYykgMjAxMyBHaWxkYXMgTG9ybWVhdS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cXHJcXG5cXHJcXG4gUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XFxyXFxuIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxcclxcblxcclxcbiAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXFxyXFxuIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXFxyXFxuXFxyXFxuIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XFxyXFxuIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpblxcclxcbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cXHJcXG5cXHJcXG4gMy4gVGhlIG5hbWVzIG9mIHRoZSBhdXRob3JzIG1heSBub3QgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHNcXHJcXG4gZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXFxyXFxuXFxyXFxuIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgYGBBUyBJUycnIEFORCBBTlkgRVhQUkVTU0VEIE9SIElNUExJRUQgV0FSUkFOVElFUyxcXHJcXG4gSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORFxcclxcbiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgSkNSQUZULFxcclxcbiBJTkMuIE9SIEFOWSBDT05UUklCVVRPUlMgVE8gVEhJUyBTT0ZUV0FSRSBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULFxcclxcbiBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UXFxyXFxuIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLFxcclxcbiBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GXFxyXFxuIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HXFxyXFxuIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSxcXHJcXG4gRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cXHJcXG4gKi9cXHJcXG5cXHJcXG4vKlxcclxcbiAqIFRoaXMgcHJvZ3JhbSBpcyBiYXNlZCBvbiBKWmxpYiAxLjAuMiB5bW5rLCBKQ3JhZnQsSW5jLlxcclxcbiAqIEpabGliIGlzIGJhc2VkIG9uIHpsaWItMS4xLjMsIHNvIGFsbCBjcmVkaXQgc2hvdWxkIGdvIGF1dGhvcnNcXHJcXG4gKiBKZWFuLWxvdXAgR2FpbGx5KGpsb3VwQGd6aXAub3JnKSBhbmQgTWFyayBBZGxlcihtYWRsZXJAYWx1bW5pLmNhbHRlY2guZWR1KVxcclxcbiAqIGFuZCBjb250cmlidXRvcnMgb2YgemxpYi5cXHJcXG4gKi9cXHJcXG5cXHJcXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XFxyXFxuICAgIFxcXCJ1c2Ugc3RyaWN0XFxcIjtcXHJcXG5cXHJcXG4gICAgLy8gR2xvYmFsXFxyXFxuXFxyXFxuICAgIHZhciBNQVhfQklUUyA9IDE1O1xcclxcbiAgICB2YXIgRF9DT0RFUyA9IDMwO1xcclxcbiAgICB2YXIgQkxfQ09ERVMgPSAxOTtcXHJcXG5cXHJcXG4gICAgdmFyIExFTkdUSF9DT0RFUyA9IDI5O1xcclxcbiAgICB2YXIgTElURVJBTFMgPSAyNTY7XFxyXFxuICAgIHZhciBMX0NPREVTID0gKExJVEVSQUxTICsgMSArIExFTkdUSF9DT0RFUyk7XFxyXFxuICAgIHZhciBIRUFQX1NJWkUgPSAoMiAqIExfQ09ERVMgKyAxKTtcXHJcXG5cXHJcXG4gICAgdmFyIEVORF9CTE9DSyA9IDI1NjtcXHJcXG5cXHJcXG4gICAgLy8gQml0IGxlbmd0aCBjb2RlcyBtdXN0IG5vdCBleGNlZWQgTUFYX0JMX0JJVFMgYml0c1xcclxcbiAgICB2YXIgTUFYX0JMX0JJVFMgPSA3O1xcclxcblxcclxcbiAgICAvLyByZXBlYXQgcHJldmlvdXMgYml0IGxlbmd0aCAzLTYgdGltZXMgKDIgYml0cyBvZiByZXBlYXQgY291bnQpXFxyXFxuICAgIHZhciBSRVBfM182ID0gMTY7XFxyXFxuXFxyXFxuICAgIC8vIHJlcGVhdCBhIHplcm8gbGVuZ3RoIDMtMTAgdGltZXMgKDMgYml0cyBvZiByZXBlYXQgY291bnQpXFxyXFxuICAgIHZhciBSRVBaXzNfMTAgPSAxNztcXHJcXG5cXHJcXG4gICAgLy8gcmVwZWF0IGEgemVybyBsZW5ndGggMTEtMTM4IHRpbWVzICg3IGJpdHMgb2YgcmVwZWF0IGNvdW50KVxcclxcbiAgICB2YXIgUkVQWl8xMV8xMzggPSAxODtcXHJcXG5cXHJcXG4gICAgLy8gVGhlIGxlbmd0aHMgb2YgdGhlIGJpdCBsZW5ndGggY29kZXMgYXJlIHNlbnQgaW4gb3JkZXIgb2YgZGVjcmVhc2luZ1xcclxcbiAgICAvLyBwcm9iYWJpbGl0eSwgdG8gYXZvaWQgdHJhbnNtaXR0aW5nIHRoZSBsZW5ndGhzIGZvciB1bnVzZWQgYml0XFxyXFxuICAgIC8vIGxlbmd0aCBjb2Rlcy5cXHJcXG5cXHJcXG4gICAgdmFyIEJ1Zl9zaXplID0gOCAqIDI7XFxyXFxuXFxyXFxuICAgIC8vIEpabGliIHZlcnNpb24gOiBcXFwiMS4wLjJcXFwiXFxyXFxuICAgIHZhciBaX0RFRkFVTFRfQ09NUFJFU1NJT04gPSAtMTtcXHJcXG5cXHJcXG4gICAgLy8gY29tcHJlc3Npb24gc3RyYXRlZ3lcXHJcXG4gICAgdmFyIFpfRklMVEVSRUQgPSAxO1xcclxcbiAgICB2YXIgWl9IVUZGTUFOX09OTFkgPSAyO1xcclxcbiAgICB2YXIgWl9ERUZBVUxUX1NUUkFURUdZID0gMDtcXHJcXG5cXHJcXG4gICAgdmFyIFpfTk9fRkxVU0ggPSAwO1xcclxcbiAgICB2YXIgWl9QQVJUSUFMX0ZMVVNIID0gMTtcXHJcXG4gICAgdmFyIFpfRlVMTF9GTFVTSCA9IDM7XFxyXFxuICAgIHZhciBaX0ZJTklTSCA9IDQ7XFxyXFxuXFxyXFxuICAgIHZhciBaX09LID0gMDtcXHJcXG4gICAgdmFyIFpfU1RSRUFNX0VORCA9IDE7XFxyXFxuICAgIHZhciBaX05FRURfRElDVCA9IDI7XFxyXFxuICAgIHZhciBaX1NUUkVBTV9FUlJPUiA9IC0yO1xcclxcbiAgICB2YXIgWl9EQVRBX0VSUk9SID0gLTM7XFxyXFxuICAgIHZhciBaX0JVRl9FUlJPUiA9IC01O1xcclxcblxcclxcbiAgICAvLyBUcmVlXFxyXFxuXFxyXFxuICAgIC8vIHNlZSBkZWZpbml0aW9uIG9mIGFycmF5IGRpc3RfY29kZSBiZWxvd1xcclxcbiAgICB2YXIgX2Rpc3RfY29kZSA9IFsgMCwgMSwgMiwgMywgNCwgNCwgNSwgNSwgNiwgNiwgNiwgNiwgNywgNywgNywgNywgOCwgOCwgOCwgOCwgOCwgOCwgOCwgOCwgOSwgOSwgOSwgOSwgOSwgOSwgOSwgOSwgMTAsIDEwLCAxMCwgMTAsIDEwLCAxMCwgMTAsIDEwLCAxMCwgMTAsXFxyXFxuICAgICAgICAgICAgMTAsIDEwLCAxMCwgMTAsIDEwLCAxMCwgMTEsIDExLCAxMSwgMTEsIDExLCAxMSwgMTEsIDExLCAxMSwgMTEsIDExLCAxMSwgMTEsIDExLCAxMSwgMTEsIDEyLCAxMiwgMTIsIDEyLCAxMiwgMTIsIDEyLCAxMiwgMTIsIDEyLCAxMiwgMTIsIDEyLCAxMiwgMTIsXFxyXFxuICAgICAgICAgICAgMTIsIDEyLCAxMiwgMTIsIDEyLCAxMiwgMTIsIDEyLCAxMiwgMTIsIDEyLCAxMiwgMTIsIDEyLCAxMiwgMTIsIDEyLCAxMywgMTMsIDEzLCAxMywgMTMsIDEzLCAxMywgMTMsIDEzLCAxMywgMTMsIDEzLCAxMywgMTMsIDEzLCAxMywgMTMsIDEzLCAxMywgMTMsXFxyXFxuICAgICAgICAgICAgMTMsIDEzLCAxMywgMTMsIDEzLCAxMywgMTMsIDEzLCAxMywgMTMsIDEzLCAxMywgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsXFxyXFxuICAgICAgICAgICAgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsXFxyXFxuICAgICAgICAgICAgMTQsIDE0LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsXFxyXFxuICAgICAgICAgICAgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAwLCAwLCAxNiwgMTcsIDE4LCAxOCwgMTksIDE5LFxcclxcbiAgICAgICAgICAgIDIwLCAyMCwgMjAsIDIwLCAyMSwgMjEsIDIxLCAyMSwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LFxcclxcbiAgICAgICAgICAgIDI0LCAyNCwgMjQsIDI1LCAyNSwgMjUsIDI1LCAyNSwgMjUsIDI1LCAyNSwgMjUsIDI1LCAyNSwgMjUsIDI1LCAyNSwgMjUsIDI1LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LFxcclxcbiAgICAgICAgICAgIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LFxcclxcbiAgICAgICAgICAgIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LFxcclxcbiAgICAgICAgICAgIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI5LFxcclxcbiAgICAgICAgICAgIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LFxcclxcbiAgICAgICAgICAgIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSBdO1xcclxcblxcclxcbiAgICBmdW5jdGlvbiBUcmVlKCkge1xcclxcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xcclxcblxcclxcbiAgICAgICAgLy8gZHluX3RyZWU7IC8vIHRoZSBkeW5hbWljIHRyZWVcXHJcXG4gICAgICAgIC8vIG1heF9jb2RlOyAvLyBsYXJnZXN0IGNvZGUgd2l0aCBub24gemVybyBmcmVxdWVuY3lcXHJcXG4gICAgICAgIC8vIHN0YXRfZGVzYzsgLy8gdGhlIGNvcnJlc3BvbmRpbmcgc3RhdGljIHRyZWVcXHJcXG5cXHJcXG4gICAgICAgIC8vIENvbXB1dGUgdGhlIG9wdGltYWwgYml0IGxlbmd0aHMgZm9yIGEgdHJlZSBhbmQgdXBkYXRlIHRoZSB0b3RhbCBiaXRcXHJcXG4gICAgICAgIC8vIGxlbmd0aFxcclxcbiAgICAgICAgLy8gZm9yIHRoZSBjdXJyZW50IGJsb2NrLlxcclxcbiAgICAgICAgLy8gSU4gYXNzZXJ0aW9uOiB0aGUgZmllbGRzIGZyZXEgYW5kIGRhZCBhcmUgc2V0LCBoZWFwW2hlYXBfbWF4XSBhbmRcXHJcXG4gICAgICAgIC8vIGFib3ZlIGFyZSB0aGUgdHJlZSBub2RlcyBzb3J0ZWQgYnkgaW5jcmVhc2luZyBmcmVxdWVuY3kuXFxyXFxuICAgICAgICAvLyBPVVQgYXNzZXJ0aW9uczogdGhlIGZpZWxkIGxlbiBpcyBzZXQgdG8gdGhlIG9wdGltYWwgYml0IGxlbmd0aCwgdGhlXFxyXFxuICAgICAgICAvLyBhcnJheSBibF9jb3VudCBjb250YWlucyB0aGUgZnJlcXVlbmNpZXMgZm9yIGVhY2ggYml0IGxlbmd0aC5cXHJcXG4gICAgICAgIC8vIFRoZSBsZW5ndGggb3B0X2xlbiBpcyB1cGRhdGVkOyBzdGF0aWNfbGVuIGlzIGFsc28gdXBkYXRlZCBpZiBzdHJlZSBpc1xcclxcbiAgICAgICAgLy8gbm90IG51bGwuXFxyXFxuICAgICAgICBmdW5jdGlvbiBnZW5fYml0bGVuKHMpIHtcXHJcXG4gICAgICAgICAgICB2YXIgdHJlZSA9IHRoYXQuZHluX3RyZWU7XFxyXFxuICAgICAgICAgICAgdmFyIHN0cmVlID0gdGhhdC5zdGF0X2Rlc2Muc3RhdGljX3RyZWU7XFxyXFxuICAgICAgICAgICAgdmFyIGV4dHJhID0gdGhhdC5zdGF0X2Rlc2MuZXh0cmFfYml0cztcXHJcXG4gICAgICAgICAgICB2YXIgYmFzZSA9IHRoYXQuc3RhdF9kZXNjLmV4dHJhX2Jhc2U7XFxyXFxuICAgICAgICAgICAgdmFyIG1heF9sZW5ndGggPSB0aGF0LnN0YXRfZGVzYy5tYXhfbGVuZ3RoO1xcclxcbiAgICAgICAgICAgIHZhciBoOyAvLyBoZWFwIGluZGV4XFxyXFxuICAgICAgICAgICAgdmFyIG4sIG07IC8vIGl0ZXJhdGUgb3ZlciB0aGUgdHJlZSBlbGVtZW50c1xcclxcbiAgICAgICAgICAgIHZhciBiaXRzOyAvLyBiaXQgbGVuZ3RoXFxyXFxuICAgICAgICAgICAgdmFyIHhiaXRzOyAvLyBleHRyYSBiaXRzXFxyXFxuICAgICAgICAgICAgdmFyIGY7IC8vIGZyZXF1ZW5jeVxcclxcbiAgICAgICAgICAgIHZhciBvdmVyZmxvdyA9IDA7IC8vIG51bWJlciBvZiBlbGVtZW50cyB3aXRoIGJpdCBsZW5ndGggdG9vIGxhcmdlXFxyXFxuXFxyXFxuICAgICAgICAgICAgZm9yIChiaXRzID0gMDsgYml0cyA8PSBNQVhfQklUUzsgYml0cysrKVxcclxcbiAgICAgICAgICAgICAgICBzLmJsX2NvdW50W2JpdHNdID0gMDtcXHJcXG5cXHJcXG4gICAgICAgICAgICAvLyBJbiBhIGZpcnN0IHBhc3MsIGNvbXB1dGUgdGhlIG9wdGltYWwgYml0IGxlbmd0aHMgKHdoaWNoIG1heVxcclxcbiAgICAgICAgICAgIC8vIG92ZXJmbG93IGluIHRoZSBjYXNlIG9mIHRoZSBiaXQgbGVuZ3RoIHRyZWUpLlxcclxcbiAgICAgICAgICAgIHRyZWVbcy5oZWFwW3MuaGVhcF9tYXhdICogMiArIDFdID0gMDsgLy8gcm9vdCBvZiB0aGUgaGVhcFxcclxcblxcclxcbiAgICAgICAgICAgIGZvciAoaCA9IHMuaGVhcF9tYXggKyAxOyBoIDwgSEVBUF9TSVpFOyBoKyspIHtcXHJcXG4gICAgICAgICAgICAgICAgbiA9IHMuaGVhcFtoXTtcXHJcXG4gICAgICAgICAgICAgICAgYml0cyA9IHRyZWVbdHJlZVtuICogMiArIDFdICogMiArIDFdICsgMTtcXHJcXG4gICAgICAgICAgICAgICAgaWYgKGJpdHMgPiBtYXhfbGVuZ3RoKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICBiaXRzID0gbWF4X2xlbmd0aDtcXHJcXG4gICAgICAgICAgICAgICAgICAgIG92ZXJmbG93Kys7XFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgdHJlZVtuICogMiArIDFdID0gYml0cztcXHJcXG4gICAgICAgICAgICAgICAgLy8gV2Ugb3ZlcndyaXRlIHRyZWVbbioyKzFdIHdoaWNoIGlzIG5vIGxvbmdlciBuZWVkZWRcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgaWYgKG4gPiB0aGF0Lm1heF9jb2RlKVxcclxcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7IC8vIG5vdCBhIGxlYWYgbm9kZVxcclxcblxcclxcbiAgICAgICAgICAgICAgICBzLmJsX2NvdW50W2JpdHNdKys7XFxyXFxuICAgICAgICAgICAgICAgIHhiaXRzID0gMDtcXHJcXG4gICAgICAgICAgICAgICAgaWYgKG4gPj0gYmFzZSlcXHJcXG4gICAgICAgICAgICAgICAgICAgIHhiaXRzID0gZXh0cmFbbiAtIGJhc2VdO1xcclxcbiAgICAgICAgICAgICAgICBmID0gdHJlZVtuICogMl07XFxyXFxuICAgICAgICAgICAgICAgIHMub3B0X2xlbiArPSBmICogKGJpdHMgKyB4Yml0cyk7XFxyXFxuICAgICAgICAgICAgICAgIGlmIChzdHJlZSlcXHJcXG4gICAgICAgICAgICAgICAgICAgIHMuc3RhdGljX2xlbiArPSBmICogKHN0cmVlW24gKiAyICsgMV0gKyB4Yml0cyk7XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIGlmIChvdmVyZmxvdyA9PT0gMClcXHJcXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xcclxcblxcclxcbiAgICAgICAgICAgIC8vIFRoaXMgaGFwcGVucyBmb3IgZXhhbXBsZSBvbiBvYmoyIGFuZCBwaWMgb2YgdGhlIENhbGdhcnkgY29ycHVzXFxyXFxuICAgICAgICAgICAgLy8gRmluZCB0aGUgZmlyc3QgYml0IGxlbmd0aCB3aGljaCBjb3VsZCBpbmNyZWFzZTpcXHJcXG4gICAgICAgICAgICBkbyB7XFxyXFxuICAgICAgICAgICAgICAgIGJpdHMgPSBtYXhfbGVuZ3RoIC0gMTtcXHJcXG4gICAgICAgICAgICAgICAgd2hpbGUgKHMuYmxfY291bnRbYml0c10gPT09IDApXFxyXFxuICAgICAgICAgICAgICAgICAgICBiaXRzLS07XFxyXFxuICAgICAgICAgICAgICAgIHMuYmxfY291bnRbYml0c10tLTsgLy8gbW92ZSBvbmUgbGVhZiBkb3duIHRoZSB0cmVlXFxyXFxuICAgICAgICAgICAgICAgIHMuYmxfY291bnRbYml0cyArIDFdICs9IDI7IC8vIG1vdmUgb25lIG92ZXJmbG93IGl0ZW0gYXMgaXRzIGJyb3RoZXJcXHJcXG4gICAgICAgICAgICAgICAgcy5ibF9jb3VudFttYXhfbGVuZ3RoXS0tO1xcclxcbiAgICAgICAgICAgICAgICAvLyBUaGUgYnJvdGhlciBvZiB0aGUgb3ZlcmZsb3cgaXRlbSBhbHNvIG1vdmVzIG9uZSBzdGVwIHVwLFxcclxcbiAgICAgICAgICAgICAgICAvLyBidXQgdGhpcyBkb2VzIG5vdCBhZmZlY3QgYmxfY291bnRbbWF4X2xlbmd0aF1cXHJcXG4gICAgICAgICAgICAgICAgb3ZlcmZsb3cgLT0gMjtcXHJcXG4gICAgICAgICAgICB9IHdoaWxlIChvdmVyZmxvdyA+IDApO1xcclxcblxcclxcbiAgICAgICAgICAgIGZvciAoYml0cyA9IG1heF9sZW5ndGg7IGJpdHMgIT09IDA7IGJpdHMtLSkge1xcclxcbiAgICAgICAgICAgICAgICBuID0gcy5ibF9jb3VudFtiaXRzXTtcXHJcXG4gICAgICAgICAgICAgICAgd2hpbGUgKG4gIT09IDApIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIG0gPSBzLmhlYXBbLS1oXTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGlmIChtID4gdGhhdC5tYXhfY29kZSlcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGlmICh0cmVlW20gKiAyICsgMV0gIT0gYml0cykge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHMub3B0X2xlbiArPSAoYml0cyAtIHRyZWVbbSAqIDIgKyAxXSkgKiB0cmVlW20gKiAyXTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmVlW20gKiAyICsgMV0gPSBiaXRzO1xcclxcbiAgICAgICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICAgICAgbi0tO1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgLy8gUmV2ZXJzZSB0aGUgZmlyc3QgbGVuIGJpdHMgb2YgYSBjb2RlLCB1c2luZyBzdHJhaWdodGZvcndhcmQgY29kZSAoYVxcclxcbiAgICAgICAgLy8gZmFzdGVyXFxyXFxuICAgICAgICAvLyBtZXRob2Qgd291bGQgdXNlIGEgdGFibGUpXFxyXFxuICAgICAgICAvLyBJTiBhc3NlcnRpb246IDEgPD0gbGVuIDw9IDE1XFxyXFxuICAgICAgICBmdW5jdGlvbiBiaV9yZXZlcnNlKGNvZGUsIC8vIHRoZSB2YWx1ZSB0byBpbnZlcnRcXHJcXG4gICAgICAgIGxlbiAvLyBpdHMgYml0IGxlbmd0aFxcclxcbiAgICAgICAgKSB7XFxyXFxuICAgICAgICAgICAgdmFyIHJlcyA9IDA7XFxyXFxuICAgICAgICAgICAgZG8ge1xcclxcbiAgICAgICAgICAgICAgICByZXMgfD0gY29kZSAmIDE7XFxyXFxuICAgICAgICAgICAgICAgIGNvZGUgPj4+PSAxO1xcclxcbiAgICAgICAgICAgICAgICByZXMgPDw9IDE7XFxyXFxuICAgICAgICAgICAgfSB3aGlsZSAoLS1sZW4gPiAwKTtcXHJcXG4gICAgICAgICAgICByZXR1cm4gcmVzID4+PiAxO1xcclxcbiAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgLy8gR2VuZXJhdGUgdGhlIGNvZGVzIGZvciBhIGdpdmVuIHRyZWUgYW5kIGJpdCBjb3VudHMgKHdoaWNoIG5lZWQgbm90IGJlXFxyXFxuICAgICAgICAvLyBvcHRpbWFsKS5cXHJcXG4gICAgICAgIC8vIElOIGFzc2VydGlvbjogdGhlIGFycmF5IGJsX2NvdW50IGNvbnRhaW5zIHRoZSBiaXQgbGVuZ3RoIHN0YXRpc3RpY3MgZm9yXFxyXFxuICAgICAgICAvLyB0aGUgZ2l2ZW4gdHJlZSBhbmQgdGhlIGZpZWxkIGxlbiBpcyBzZXQgZm9yIGFsbCB0cmVlIGVsZW1lbnRzLlxcclxcbiAgICAgICAgLy8gT1VUIGFzc2VydGlvbjogdGhlIGZpZWxkIGNvZGUgaXMgc2V0IGZvciBhbGwgdHJlZSBlbGVtZW50cyBvZiBub25cXHJcXG4gICAgICAgIC8vIHplcm8gY29kZSBsZW5ndGguXFxyXFxuICAgICAgICBmdW5jdGlvbiBnZW5fY29kZXModHJlZSwgLy8gdGhlIHRyZWUgdG8gZGVjb3JhdGVcXHJcXG4gICAgICAgIG1heF9jb2RlLCAvLyBsYXJnZXN0IGNvZGUgd2l0aCBub24gemVybyBmcmVxdWVuY3lcXHJcXG4gICAgICAgIGJsX2NvdW50IC8vIG51bWJlciBvZiBjb2RlcyBhdCBlYWNoIGJpdCBsZW5ndGhcXHJcXG4gICAgICAgICkge1xcclxcbiAgICAgICAgICAgIHZhciBuZXh0X2NvZGUgPSBbXTsgLy8gbmV4dCBjb2RlIHZhbHVlIGZvciBlYWNoXFxyXFxuICAgICAgICAgICAgLy8gYml0IGxlbmd0aFxcclxcbiAgICAgICAgICAgIHZhciBjb2RlID0gMDsgLy8gcnVubmluZyBjb2RlIHZhbHVlXFxyXFxuICAgICAgICAgICAgdmFyIGJpdHM7IC8vIGJpdCBpbmRleFxcclxcbiAgICAgICAgICAgIHZhciBuOyAvLyBjb2RlIGluZGV4XFxyXFxuICAgICAgICAgICAgdmFyIGxlbjtcXHJcXG5cXHJcXG4gICAgICAgICAgICAvLyBUaGUgZGlzdHJpYnV0aW9uIGNvdW50cyBhcmUgZmlyc3QgdXNlZCB0byBnZW5lcmF0ZSB0aGUgY29kZSB2YWx1ZXNcXHJcXG4gICAgICAgICAgICAvLyB3aXRob3V0IGJpdCByZXZlcnNhbC5cXHJcXG4gICAgICAgICAgICBmb3IgKGJpdHMgPSAxOyBiaXRzIDw9IE1BWF9CSVRTOyBiaXRzKyspIHtcXHJcXG4gICAgICAgICAgICAgICAgbmV4dF9jb2RlW2JpdHNdID0gY29kZSA9ICgoY29kZSArIGJsX2NvdW50W2JpdHMgLSAxXSkgPDwgMSk7XFxyXFxuICAgICAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgICAgIC8vIENoZWNrIHRoYXQgdGhlIGJpdCBjb3VudHMgaW4gYmxfY291bnQgYXJlIGNvbnNpc3RlbnQuIFRoZSBsYXN0IGNvZGVcXHJcXG4gICAgICAgICAgICAvLyBtdXN0IGJlIGFsbCBvbmVzLlxcclxcbiAgICAgICAgICAgIC8vIEFzc2VydCAoY29kZSArIGJsX2NvdW50W01BWF9CSVRTXS0xID09ICgxPDxNQVhfQklUUyktMSxcXHJcXG4gICAgICAgICAgICAvLyBcXFwiaW5jb25zaXN0ZW50IGJpdCBjb3VudHNcXFwiKTtcXHJcXG4gICAgICAgICAgICAvLyBUcmFjZXYoKHN0ZGVycixcXFwiXFxcXG5nZW5fY29kZXM6IG1heF9jb2RlICVkIFxcXCIsIG1heF9jb2RlKSk7XFxyXFxuXFxyXFxuICAgICAgICAgICAgZm9yIChuID0gMDsgbiA8PSBtYXhfY29kZTsgbisrKSB7XFxyXFxuICAgICAgICAgICAgICAgIGxlbiA9IHRyZWVbbiAqIDIgKyAxXTtcXHJcXG4gICAgICAgICAgICAgICAgaWYgKGxlbiA9PT0gMClcXHJcXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcclxcbiAgICAgICAgICAgICAgICAvLyBOb3cgcmV2ZXJzZSB0aGUgYml0c1xcclxcbiAgICAgICAgICAgICAgICB0cmVlW24gKiAyXSA9IGJpX3JldmVyc2UobmV4dF9jb2RlW2xlbl0rKywgbGVuKTtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAvLyBDb25zdHJ1Y3Qgb25lIEh1ZmZtYW4gdHJlZSBhbmQgYXNzaWducyB0aGUgY29kZSBiaXQgc3RyaW5ncyBhbmQgbGVuZ3Rocy5cXHJcXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgdG90YWwgYml0IGxlbmd0aCBmb3IgdGhlIGN1cnJlbnQgYmxvY2suXFxyXFxuICAgICAgICAvLyBJTiBhc3NlcnRpb246IHRoZSBmaWVsZCBmcmVxIGlzIHNldCBmb3IgYWxsIHRyZWUgZWxlbWVudHMuXFxyXFxuICAgICAgICAvLyBPVVQgYXNzZXJ0aW9uczogdGhlIGZpZWxkcyBsZW4gYW5kIGNvZGUgYXJlIHNldCB0byB0aGUgb3B0aW1hbCBiaXQgbGVuZ3RoXFxyXFxuICAgICAgICAvLyBhbmQgY29ycmVzcG9uZGluZyBjb2RlLiBUaGUgbGVuZ3RoIG9wdF9sZW4gaXMgdXBkYXRlZDsgc3RhdGljX2xlbiBpc1xcclxcbiAgICAgICAgLy8gYWxzbyB1cGRhdGVkIGlmIHN0cmVlIGlzIG5vdCBudWxsLiBUaGUgZmllbGQgbWF4X2NvZGUgaXMgc2V0LlxcclxcbiAgICAgICAgdGhhdC5idWlsZF90cmVlID0gZnVuY3Rpb24ocykge1xcclxcbiAgICAgICAgICAgIHZhciB0cmVlID0gdGhhdC5keW5fdHJlZTtcXHJcXG4gICAgICAgICAgICB2YXIgc3RyZWUgPSB0aGF0LnN0YXRfZGVzYy5zdGF0aWNfdHJlZTtcXHJcXG4gICAgICAgICAgICB2YXIgZWxlbXMgPSB0aGF0LnN0YXRfZGVzYy5lbGVtcztcXHJcXG4gICAgICAgICAgICB2YXIgbiwgbTsgLy8gaXRlcmF0ZSBvdmVyIGhlYXAgZWxlbWVudHNcXHJcXG4gICAgICAgICAgICB2YXIgbWF4X2NvZGUgPSAtMTsgLy8gbGFyZ2VzdCBjb2RlIHdpdGggbm9uIHplcm8gZnJlcXVlbmN5XFxyXFxuICAgICAgICAgICAgdmFyIG5vZGU7IC8vIG5ldyBub2RlIGJlaW5nIGNyZWF0ZWRcXHJcXG5cXHJcXG4gICAgICAgICAgICAvLyBDb25zdHJ1Y3QgdGhlIGluaXRpYWwgaGVhcCwgd2l0aCBsZWFzdCBmcmVxdWVudCBlbGVtZW50IGluXFxyXFxuICAgICAgICAgICAgLy8gaGVhcFsxXS4gVGhlIHNvbnMgb2YgaGVhcFtuXSBhcmUgaGVhcFsyKm5dIGFuZCBoZWFwWzIqbisxXS5cXHJcXG4gICAgICAgICAgICAvLyBoZWFwWzBdIGlzIG5vdCB1c2VkLlxcclxcbiAgICAgICAgICAgIHMuaGVhcF9sZW4gPSAwO1xcclxcbiAgICAgICAgICAgIHMuaGVhcF9tYXggPSBIRUFQX1NJWkU7XFxyXFxuXFxyXFxuICAgICAgICAgICAgZm9yIChuID0gMDsgbiA8IGVsZW1zOyBuKyspIHtcXHJcXG4gICAgICAgICAgICAgICAgaWYgKHRyZWVbbiAqIDJdICE9PSAwKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICBzLmhlYXBbKytzLmhlYXBfbGVuXSA9IG1heF9jb2RlID0gbjtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHMuZGVwdGhbbl0gPSAwO1xcclxcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgICAgICAgICAgICAgdHJlZVtuICogMiArIDFdID0gMDtcXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICAvLyBUaGUgcGt6aXAgZm9ybWF0IHJlcXVpcmVzIHRoYXQgYXQgbGVhc3Qgb25lIGRpc3RhbmNlIGNvZGUgZXhpc3RzLFxcclxcbiAgICAgICAgICAgIC8vIGFuZCB0aGF0IGF0IGxlYXN0IG9uZSBiaXQgc2hvdWxkIGJlIHNlbnQgZXZlbiBpZiB0aGVyZSBpcyBvbmx5IG9uZVxcclxcbiAgICAgICAgICAgIC8vIHBvc3NpYmxlIGNvZGUuIFNvIHRvIGF2b2lkIHNwZWNpYWwgY2hlY2tzIGxhdGVyIG9uIHdlIGZvcmNlIGF0IGxlYXN0XFxyXFxuICAgICAgICAgICAgLy8gdHdvIGNvZGVzIG9mIG5vbiB6ZXJvIGZyZXF1ZW5jeS5cXHJcXG4gICAgICAgICAgICB3aGlsZSAocy5oZWFwX2xlbiA8IDIpIHtcXHJcXG4gICAgICAgICAgICAgICAgbm9kZSA9IHMuaGVhcFsrK3MuaGVhcF9sZW5dID0gbWF4X2NvZGUgPCAyID8gKyttYXhfY29kZSA6IDA7XFxyXFxuICAgICAgICAgICAgICAgIHRyZWVbbm9kZSAqIDJdID0gMTtcXHJcXG4gICAgICAgICAgICAgICAgcy5kZXB0aFtub2RlXSA9IDA7XFxyXFxuICAgICAgICAgICAgICAgIHMub3B0X2xlbi0tO1xcclxcbiAgICAgICAgICAgICAgICBpZiAoc3RyZWUpXFxyXFxuICAgICAgICAgICAgICAgICAgICBzLnN0YXRpY19sZW4gLT0gc3RyZWVbbm9kZSAqIDIgKyAxXTtcXHJcXG4gICAgICAgICAgICAgICAgLy8gbm9kZSBpcyAwIG9yIDEgc28gaXQgZG9lcyBub3QgaGF2ZSBleHRyYSBiaXRzXFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIHRoYXQubWF4X2NvZGUgPSBtYXhfY29kZTtcXHJcXG5cXHJcXG4gICAgICAgICAgICAvLyBUaGUgZWxlbWVudHMgaGVhcFtoZWFwX2xlbi8yKzEgLi4gaGVhcF9sZW5dIGFyZSBsZWF2ZXMgb2YgdGhlIHRyZWUsXFxyXFxuICAgICAgICAgICAgLy8gZXN0YWJsaXNoIHN1Yi1oZWFwcyBvZiBpbmNyZWFzaW5nIGxlbmd0aHM6XFxyXFxuXFxyXFxuICAgICAgICAgICAgZm9yIChuID0gTWF0aC5mbG9vcihzLmhlYXBfbGVuIC8gMik7IG4gPj0gMTsgbi0tKVxcclxcbiAgICAgICAgICAgICAgICBzLnBxZG93bmhlYXAodHJlZSwgbik7XFxyXFxuXFxyXFxuICAgICAgICAgICAgLy8gQ29uc3RydWN0IHRoZSBIdWZmbWFuIHRyZWUgYnkgcmVwZWF0ZWRseSBjb21iaW5pbmcgdGhlIGxlYXN0IHR3b1xcclxcbiAgICAgICAgICAgIC8vIGZyZXF1ZW50IG5vZGVzLlxcclxcblxcclxcbiAgICAgICAgICAgIG5vZGUgPSBlbGVtczsgLy8gbmV4dCBpbnRlcm5hbCBub2RlIG9mIHRoZSB0cmVlXFxyXFxuICAgICAgICAgICAgZG8ge1xcclxcbiAgICAgICAgICAgICAgICAvLyBuID0gbm9kZSBvZiBsZWFzdCBmcmVxdWVuY3lcXHJcXG4gICAgICAgICAgICAgICAgbiA9IHMuaGVhcFsxXTtcXHJcXG4gICAgICAgICAgICAgICAgcy5oZWFwWzFdID0gcy5oZWFwW3MuaGVhcF9sZW4tLV07XFxyXFxuICAgICAgICAgICAgICAgIHMucHFkb3duaGVhcCh0cmVlLCAxKTtcXHJcXG4gICAgICAgICAgICAgICAgbSA9IHMuaGVhcFsxXTsgLy8gbSA9IG5vZGUgb2YgbmV4dCBsZWFzdCBmcmVxdWVuY3lcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgcy5oZWFwWy0tcy5oZWFwX21heF0gPSBuOyAvLyBrZWVwIHRoZSBub2RlcyBzb3J0ZWQgYnkgZnJlcXVlbmN5XFxyXFxuICAgICAgICAgICAgICAgIHMuaGVhcFstLXMuaGVhcF9tYXhdID0gbTtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IG5vZGUgZmF0aGVyIG9mIG4gYW5kIG1cXHJcXG4gICAgICAgICAgICAgICAgdHJlZVtub2RlICogMl0gPSAodHJlZVtuICogMl0gKyB0cmVlW20gKiAyXSk7XFxyXFxuICAgICAgICAgICAgICAgIHMuZGVwdGhbbm9kZV0gPSBNYXRoLm1heChzLmRlcHRoW25dLCBzLmRlcHRoW21dKSArIDE7XFxyXFxuICAgICAgICAgICAgICAgIHRyZWVbbiAqIDIgKyAxXSA9IHRyZWVbbSAqIDIgKyAxXSA9IG5vZGU7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgIC8vIGFuZCBpbnNlcnQgdGhlIG5ldyBub2RlIGluIHRoZSBoZWFwXFxyXFxuICAgICAgICAgICAgICAgIHMuaGVhcFsxXSA9IG5vZGUrKztcXHJcXG4gICAgICAgICAgICAgICAgcy5wcWRvd25oZWFwKHRyZWUsIDEpO1xcclxcbiAgICAgICAgICAgIH0gd2hpbGUgKHMuaGVhcF9sZW4gPj0gMik7XFxyXFxuXFxyXFxuICAgICAgICAgICAgcy5oZWFwWy0tcy5oZWFwX21heF0gPSBzLmhlYXBbMV07XFxyXFxuXFxyXFxuICAgICAgICAgICAgLy8gQXQgdGhpcyBwb2ludCwgdGhlIGZpZWxkcyBmcmVxIGFuZCBkYWQgYXJlIHNldC4gV2UgY2FuIG5vd1xcclxcbiAgICAgICAgICAgIC8vIGdlbmVyYXRlIHRoZSBiaXQgbGVuZ3Rocy5cXHJcXG5cXHJcXG4gICAgICAgICAgICBnZW5fYml0bGVuKHMpO1xcclxcblxcclxcbiAgICAgICAgICAgIC8vIFRoZSBmaWVsZCBsZW4gaXMgbm93IHNldCwgd2UgY2FuIGdlbmVyYXRlIHRoZSBiaXQgY29kZXNcXHJcXG4gICAgICAgICAgICBnZW5fY29kZXModHJlZSwgdGhhdC5tYXhfY29kZSwgcy5ibF9jb3VudCk7XFxyXFxuICAgICAgICB9O1xcclxcblxcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgIFRyZWUuX2xlbmd0aF9jb2RlID0gWyAwLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA4LCA5LCA5LCAxMCwgMTAsIDExLCAxMSwgMTIsIDEyLCAxMiwgMTIsIDEzLCAxMywgMTMsIDEzLCAxNCwgMTQsIDE0LCAxNCwgMTUsIDE1LCAxNSwgMTUsIDE2LCAxNiwgMTYsIDE2LFxcclxcbiAgICAgICAgICAgIDE2LCAxNiwgMTYsIDE2LCAxNywgMTcsIDE3LCAxNywgMTcsIDE3LCAxNywgMTcsIDE4LCAxOCwgMTgsIDE4LCAxOCwgMTgsIDE4LCAxOCwgMTksIDE5LCAxOSwgMTksIDE5LCAxOSwgMTksIDE5LCAyMCwgMjAsIDIwLCAyMCwgMjAsIDIwLCAyMCwgMjAsIDIwLFxcclxcbiAgICAgICAgICAgIDIwLCAyMCwgMjAsIDIwLCAyMCwgMjAsIDIwLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLFxcclxcbiAgICAgICAgICAgIDIyLCAyMiwgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LFxcclxcbiAgICAgICAgICAgIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNSwgMjUsIDI1LCAyNSwgMjUsIDI1LCAyNSwgMjUsIDI1LCAyNSwgMjUsIDI1LCAyNSwgMjUsIDI1LCAyNSwgMjUsIDI1LCAyNSwgMjUsIDI1LCAyNSwgMjUsIDI1LFxcclxcbiAgICAgICAgICAgIDI1LCAyNSwgMjUsIDI1LCAyNSwgMjUsIDI1LCAyNSwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LFxcclxcbiAgICAgICAgICAgIDI2LCAyNiwgMjYsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyOCBdO1xcclxcblxcclxcbiAgICBUcmVlLmJhc2VfbGVuZ3RoID0gWyAwLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCAxMCwgMTIsIDE0LCAxNiwgMjAsIDI0LCAyOCwgMzIsIDQwLCA0OCwgNTYsIDY0LCA4MCwgOTYsIDExMiwgMTI4LCAxNjAsIDE5MiwgMjI0LCAwIF07XFxyXFxuXFxyXFxuICAgIFRyZWUuYmFzZV9kaXN0ID0gWyAwLCAxLCAyLCAzLCA0LCA2LCA4LCAxMiwgMTYsIDI0LCAzMiwgNDgsIDY0LCA5NiwgMTI4LCAxOTIsIDI1NiwgMzg0LCA1MTIsIDc2OCwgMTAyNCwgMTUzNiwgMjA0OCwgMzA3MiwgNDA5NiwgNjE0NCwgODE5MiwgMTIyODgsIDE2Mzg0LFxcclxcbiAgICAgICAgICAgIDI0NTc2IF07XFxyXFxuXFxyXFxuICAgIC8vIE1hcHBpbmcgZnJvbSBhIGRpc3RhbmNlIHRvIGEgZGlzdGFuY2UgY29kZS4gZGlzdCBpcyB0aGUgZGlzdGFuY2UgLSAxIGFuZFxcclxcbiAgICAvLyBtdXN0IG5vdCBoYXZlIHNpZGUgZWZmZWN0cy4gX2Rpc3RfY29kZVsyNTZdIGFuZCBfZGlzdF9jb2RlWzI1N10gYXJlIG5ldmVyXFxyXFxuICAgIC8vIHVzZWQuXFxyXFxuICAgIFRyZWUuZF9jb2RlID0gZnVuY3Rpb24oZGlzdCkge1xcclxcbiAgICAgICAgcmV0dXJuICgoZGlzdCkgPCAyNTYgPyBfZGlzdF9jb2RlW2Rpc3RdIDogX2Rpc3RfY29kZVsyNTYgKyAoKGRpc3QpID4+PiA3KV0pO1xcclxcbiAgICB9O1xcclxcblxcclxcbiAgICAvLyBleHRyYSBiaXRzIGZvciBlYWNoIGxlbmd0aCBjb2RlXFxyXFxuICAgIFRyZWUuZXh0cmFfbGJpdHMgPSBbIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDEsIDEsIDEsIDEsIDIsIDIsIDIsIDIsIDMsIDMsIDMsIDMsIDQsIDQsIDQsIDQsIDUsIDUsIDUsIDUsIDAgXTtcXHJcXG5cXHJcXG4gICAgLy8gZXh0cmEgYml0cyBmb3IgZWFjaCBkaXN0YW5jZSBjb2RlXFxyXFxuICAgIFRyZWUuZXh0cmFfZGJpdHMgPSBbIDAsIDAsIDAsIDAsIDEsIDEsIDIsIDIsIDMsIDMsIDQsIDQsIDUsIDUsIDYsIDYsIDcsIDcsIDgsIDgsIDksIDksIDEwLCAxMCwgMTEsIDExLCAxMiwgMTIsIDEzLCAxMyBdO1xcclxcblxcclxcbiAgICAvLyBleHRyYSBiaXRzIGZvciBlYWNoIGJpdCBsZW5ndGggY29kZVxcclxcbiAgICBUcmVlLmV4dHJhX2JsYml0cyA9IFsgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMiwgMywgNyBdO1xcclxcblxcclxcbiAgICBUcmVlLmJsX29yZGVyID0gWyAxNiwgMTcsIDE4LCAwLCA4LCA3LCA5LCA2LCAxMCwgNSwgMTEsIDQsIDEyLCAzLCAxMywgMiwgMTQsIDEsIDE1IF07XFxyXFxuXFxyXFxuICAgIC8vIFN0YXRpY1RyZWVcXHJcXG5cXHJcXG4gICAgZnVuY3Rpb24gU3RhdGljVHJlZShzdGF0aWNfdHJlZSwgZXh0cmFfYml0cywgZXh0cmFfYmFzZSwgZWxlbXMsIG1heF9sZW5ndGgpIHtcXHJcXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcXHJcXG4gICAgICAgIHRoYXQuc3RhdGljX3RyZWUgPSBzdGF0aWNfdHJlZTtcXHJcXG4gICAgICAgIHRoYXQuZXh0cmFfYml0cyA9IGV4dHJhX2JpdHM7XFxyXFxuICAgICAgICB0aGF0LmV4dHJhX2Jhc2UgPSBleHRyYV9iYXNlO1xcclxcbiAgICAgICAgdGhhdC5lbGVtcyA9IGVsZW1zO1xcclxcbiAgICAgICAgdGhhdC5tYXhfbGVuZ3RoID0gbWF4X2xlbmd0aDtcXHJcXG4gICAgfVxcclxcblxcclxcbiAgICBTdGF0aWNUcmVlLnN0YXRpY19sdHJlZSA9IFsgMTIsIDgsIDE0MCwgOCwgNzYsIDgsIDIwNCwgOCwgNDQsIDgsIDE3MiwgOCwgMTA4LCA4LCAyMzYsIDgsIDI4LCA4LCAxNTYsIDgsIDkyLCA4LCAyMjAsIDgsIDYwLCA4LCAxODgsIDgsIDEyNCwgOCwgMjUyLCA4LCAyLCA4LFxcclxcbiAgICAgICAgICAgIDEzMCwgOCwgNjYsIDgsIDE5NCwgOCwgMzQsIDgsIDE2MiwgOCwgOTgsIDgsIDIyNiwgOCwgMTgsIDgsIDE0NiwgOCwgODIsIDgsIDIxMCwgOCwgNTAsIDgsIDE3OCwgOCwgMTE0LCA4LCAyNDIsIDgsIDEwLCA4LCAxMzgsIDgsIDc0LCA4LCAyMDIsIDgsIDQyLFxcclxcbiAgICAgICAgICAgIDgsIDE3MCwgOCwgMTA2LCA4LCAyMzQsIDgsIDI2LCA4LCAxNTQsIDgsIDkwLCA4LCAyMTgsIDgsIDU4LCA4LCAxODYsIDgsIDEyMiwgOCwgMjUwLCA4LCA2LCA4LCAxMzQsIDgsIDcwLCA4LCAxOTgsIDgsIDM4LCA4LCAxNjYsIDgsIDEwMiwgOCwgMjMwLCA4LFxcclxcbiAgICAgICAgICAgIDIyLCA4LCAxNTAsIDgsIDg2LCA4LCAyMTQsIDgsIDU0LCA4LCAxODIsIDgsIDExOCwgOCwgMjQ2LCA4LCAxNCwgOCwgMTQyLCA4LCA3OCwgOCwgMjA2LCA4LCA0NiwgOCwgMTc0LCA4LCAxMTAsIDgsIDIzOCwgOCwgMzAsIDgsIDE1OCwgOCwgOTQsIDgsXFxyXFxuICAgICAgICAgICAgMjIyLCA4LCA2MiwgOCwgMTkwLCA4LCAxMjYsIDgsIDI1NCwgOCwgMSwgOCwgMTI5LCA4LCA2NSwgOCwgMTkzLCA4LCAzMywgOCwgMTYxLCA4LCA5NywgOCwgMjI1LCA4LCAxNywgOCwgMTQ1LCA4LCA4MSwgOCwgMjA5LCA4LCA0OSwgOCwgMTc3LCA4LCAxMTMsXFxyXFxuICAgICAgICAgICAgOCwgMjQxLCA4LCA5LCA4LCAxMzcsIDgsIDczLCA4LCAyMDEsIDgsIDQxLCA4LCAxNjksIDgsIDEwNSwgOCwgMjMzLCA4LCAyNSwgOCwgMTUzLCA4LCA4OSwgOCwgMjE3LCA4LCA1NywgOCwgMTg1LCA4LCAxMjEsIDgsIDI0OSwgOCwgNSwgOCwgMTMzLCA4LFxcclxcbiAgICAgICAgICAgIDY5LCA4LCAxOTcsIDgsIDM3LCA4LCAxNjUsIDgsIDEwMSwgOCwgMjI5LCA4LCAyMSwgOCwgMTQ5LCA4LCA4NSwgOCwgMjEzLCA4LCA1MywgOCwgMTgxLCA4LCAxMTcsIDgsIDI0NSwgOCwgMTMsIDgsIDE0MSwgOCwgNzcsIDgsIDIwNSwgOCwgNDUsIDgsXFxyXFxuICAgICAgICAgICAgMTczLCA4LCAxMDksIDgsIDIzNywgOCwgMjksIDgsIDE1NywgOCwgOTMsIDgsIDIyMSwgOCwgNjEsIDgsIDE4OSwgOCwgMTI1LCA4LCAyNTMsIDgsIDE5LCA5LCAyNzUsIDksIDE0NywgOSwgNDAzLCA5LCA4MywgOSwgMzM5LCA5LCAyMTEsIDksIDQ2NywgOSxcXHJcXG4gICAgICAgICAgICA1MSwgOSwgMzA3LCA5LCAxNzksIDksIDQzNSwgOSwgMTE1LCA5LCAzNzEsIDksIDI0MywgOSwgNDk5LCA5LCAxMSwgOSwgMjY3LCA5LCAxMzksIDksIDM5NSwgOSwgNzUsIDksIDMzMSwgOSwgMjAzLCA5LCA0NTksIDksIDQzLCA5LCAyOTksIDksIDE3MSwgOSxcXHJcXG4gICAgICAgICAgICA0MjcsIDksIDEwNywgOSwgMzYzLCA5LCAyMzUsIDksIDQ5MSwgOSwgMjcsIDksIDI4MywgOSwgMTU1LCA5LCA0MTEsIDksIDkxLCA5LCAzNDcsIDksIDIxOSwgOSwgNDc1LCA5LCA1OSwgOSwgMzE1LCA5LCAxODcsIDksIDQ0MywgOSwgMTIzLCA5LCAzNzksXFxyXFxuICAgICAgICAgICAgOSwgMjUxLCA5LCA1MDcsIDksIDcsIDksIDI2MywgOSwgMTM1LCA5LCAzOTEsIDksIDcxLCA5LCAzMjcsIDksIDE5OSwgOSwgNDU1LCA5LCAzOSwgOSwgMjk1LCA5LCAxNjcsIDksIDQyMywgOSwgMTAzLCA5LCAzNTksIDksIDIzMSwgOSwgNDg3LCA5LCAyMyxcXHJcXG4gICAgICAgICAgICA5LCAyNzksIDksIDE1MSwgOSwgNDA3LCA5LCA4NywgOSwgMzQzLCA5LCAyMTUsIDksIDQ3MSwgOSwgNTUsIDksIDMxMSwgOSwgMTgzLCA5LCA0MzksIDksIDExOSwgOSwgMzc1LCA5LCAyNDcsIDksIDUwMywgOSwgMTUsIDksIDI3MSwgOSwgMTQzLCA5LFxcclxcbiAgICAgICAgICAgIDM5OSwgOSwgNzksIDksIDMzNSwgOSwgMjA3LCA5LCA0NjMsIDksIDQ3LCA5LCAzMDMsIDksIDE3NSwgOSwgNDMxLCA5LCAxMTEsIDksIDM2NywgOSwgMjM5LCA5LCA0OTUsIDksIDMxLCA5LCAyODcsIDksIDE1OSwgOSwgNDE1LCA5LCA5NSwgOSwgMzUxLCA5LFxcclxcbiAgICAgICAgICAgIDIyMywgOSwgNDc5LCA5LCA2MywgOSwgMzE5LCA5LCAxOTEsIDksIDQ0NywgOSwgMTI3LCA5LCAzODMsIDksIDI1NSwgOSwgNTExLCA5LCAwLCA3LCA2NCwgNywgMzIsIDcsIDk2LCA3LCAxNiwgNywgODAsIDcsIDQ4LCA3LCAxMTIsIDcsIDgsIDcsIDcyLCA3LFxcclxcbiAgICAgICAgICAgIDQwLCA3LCAxMDQsIDcsIDI0LCA3LCA4OCwgNywgNTYsIDcsIDEyMCwgNywgNCwgNywgNjgsIDcsIDM2LCA3LCAxMDAsIDcsIDIwLCA3LCA4NCwgNywgNTIsIDcsIDExNiwgNywgMywgOCwgMTMxLCA4LCA2NywgOCwgMTk1LCA4LCAzNSwgOCwgMTYzLCA4LFxcclxcbiAgICAgICAgICAgIDk5LCA4LCAyMjcsIDggXTtcXHJcXG5cXHJcXG4gICAgU3RhdGljVHJlZS5zdGF0aWNfZHRyZWUgPSBbIDAsIDUsIDE2LCA1LCA4LCA1LCAyNCwgNSwgNCwgNSwgMjAsIDUsIDEyLCA1LCAyOCwgNSwgMiwgNSwgMTgsIDUsIDEwLCA1LCAyNiwgNSwgNiwgNSwgMjIsIDUsIDE0LCA1LCAzMCwgNSwgMSwgNSwgMTcsIDUsIDksIDUsXFxyXFxuICAgICAgICAgICAgMjUsIDUsIDUsIDUsIDIxLCA1LCAxMywgNSwgMjksIDUsIDMsIDUsIDE5LCA1LCAxMSwgNSwgMjcsIDUsIDcsIDUsIDIzLCA1IF07XFxyXFxuXFxyXFxuICAgIFN0YXRpY1RyZWUuc3RhdGljX2xfZGVzYyA9IG5ldyBTdGF0aWNUcmVlKFN0YXRpY1RyZWUuc3RhdGljX2x0cmVlLCBUcmVlLmV4dHJhX2xiaXRzLCBMSVRFUkFMUyArIDEsIExfQ09ERVMsIE1BWF9CSVRTKTtcXHJcXG5cXHJcXG4gICAgU3RhdGljVHJlZS5zdGF0aWNfZF9kZXNjID0gbmV3IFN0YXRpY1RyZWUoU3RhdGljVHJlZS5zdGF0aWNfZHRyZWUsIFRyZWUuZXh0cmFfZGJpdHMsIDAsIERfQ09ERVMsIE1BWF9CSVRTKTtcXHJcXG5cXHJcXG4gICAgU3RhdGljVHJlZS5zdGF0aWNfYmxfZGVzYyA9IG5ldyBTdGF0aWNUcmVlKG51bGwsIFRyZWUuZXh0cmFfYmxiaXRzLCAwLCBCTF9DT0RFUywgTUFYX0JMX0JJVFMpO1xcclxcblxcclxcbiAgICAvLyBEZWZsYXRlXFxyXFxuXFxyXFxuICAgIHZhciBNQVhfTUVNX0xFVkVMID0gOTtcXHJcXG4gICAgdmFyIERFRl9NRU1fTEVWRUwgPSA4O1xcclxcblxcclxcbiAgICBmdW5jdGlvbiBDb25maWcoZ29vZF9sZW5ndGgsIG1heF9sYXp5LCBuaWNlX2xlbmd0aCwgbWF4X2NoYWluLCBmdW5jKSB7XFxyXFxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XFxyXFxuICAgICAgICB0aGF0Lmdvb2RfbGVuZ3RoID0gZ29vZF9sZW5ndGg7XFxyXFxuICAgICAgICB0aGF0Lm1heF9sYXp5ID0gbWF4X2xhenk7XFxyXFxuICAgICAgICB0aGF0Lm5pY2VfbGVuZ3RoID0gbmljZV9sZW5ndGg7XFxyXFxuICAgICAgICB0aGF0Lm1heF9jaGFpbiA9IG1heF9jaGFpbjtcXHJcXG4gICAgICAgIHRoYXQuZnVuYyA9IGZ1bmM7XFxyXFxuICAgIH1cXHJcXG5cXHJcXG4gICAgdmFyIFNUT1JFRCA9IDA7XFxyXFxuICAgIHZhciBGQVNUID0gMTtcXHJcXG4gICAgdmFyIFNMT1cgPSAyO1xcclxcbiAgICB2YXIgY29uZmlnX3RhYmxlID0gWyBuZXcgQ29uZmlnKDAsIDAsIDAsIDAsIFNUT1JFRCksIG5ldyBDb25maWcoNCwgNCwgOCwgNCwgRkFTVCksIG5ldyBDb25maWcoNCwgNSwgMTYsIDgsIEZBU1QpLCBuZXcgQ29uZmlnKDQsIDYsIDMyLCAzMiwgRkFTVCksXFxyXFxuICAgICAgICAgICAgbmV3IENvbmZpZyg0LCA0LCAxNiwgMTYsIFNMT1cpLCBuZXcgQ29uZmlnKDgsIDE2LCAzMiwgMzIsIFNMT1cpLCBuZXcgQ29uZmlnKDgsIDE2LCAxMjgsIDEyOCwgU0xPVyksIG5ldyBDb25maWcoOCwgMzIsIDEyOCwgMjU2LCBTTE9XKSxcXHJcXG4gICAgICAgICAgICBuZXcgQ29uZmlnKDMyLCAxMjgsIDI1OCwgMTAyNCwgU0xPVyksIG5ldyBDb25maWcoMzIsIDI1OCwgMjU4LCA0MDk2LCBTTE9XKSBdO1xcclxcblxcclxcbiAgICB2YXIgel9lcnJtc2cgPSBbIFxcXCJuZWVkIGRpY3Rpb25hcnlcXFwiLCAvLyBaX05FRURfRElDVFxcclxcbiAgICAvLyAyXFxyXFxuICAgIFxcXCJzdHJlYW0gZW5kXFxcIiwgLy8gWl9TVFJFQU1fRU5EIDFcXHJcXG4gICAgXFxcIlxcXCIsIC8vIFpfT0sgMFxcclxcbiAgICBcXFwiXFxcIiwgLy8gWl9FUlJOTyAoLTEpXFxyXFxuICAgIFxcXCJzdHJlYW0gZXJyb3JcXFwiLCAvLyBaX1NUUkVBTV9FUlJPUiAoLTIpXFxyXFxuICAgIFxcXCJkYXRhIGVycm9yXFxcIiwgLy8gWl9EQVRBX0VSUk9SICgtMylcXHJcXG4gICAgXFxcIlxcXCIsIC8vIFpfTUVNX0VSUk9SICgtNClcXHJcXG4gICAgXFxcImJ1ZmZlciBlcnJvclxcXCIsIC8vIFpfQlVGX0VSUk9SICgtNSlcXHJcXG4gICAgXFxcIlxcXCIsLy8gWl9WRVJTSU9OX0VSUk9SICgtNilcXHJcXG4gICAgXFxcIlxcXCIgXTtcXHJcXG5cXHJcXG4gICAgLy8gYmxvY2sgbm90IGNvbXBsZXRlZCwgbmVlZCBtb3JlIGlucHV0IG9yIG1vcmUgb3V0cHV0XFxyXFxuICAgIHZhciBOZWVkTW9yZSA9IDA7XFxyXFxuXFxyXFxuICAgIC8vIGJsb2NrIGZsdXNoIHBlcmZvcm1lZFxcclxcbiAgICB2YXIgQmxvY2tEb25lID0gMTtcXHJcXG5cXHJcXG4gICAgLy8gZmluaXNoIHN0YXJ0ZWQsIG5lZWQgb25seSBtb3JlIG91dHB1dCBhdCBuZXh0IGRlZmxhdGVcXHJcXG4gICAgdmFyIEZpbmlzaFN0YXJ0ZWQgPSAyO1xcclxcblxcclxcbiAgICAvLyBmaW5pc2ggZG9uZSwgYWNjZXB0IG5vIG1vcmUgaW5wdXQgb3Igb3V0cHV0XFxyXFxuICAgIHZhciBGaW5pc2hEb25lID0gMztcXHJcXG5cXHJcXG4gICAgLy8gcHJlc2V0IGRpY3Rpb25hcnkgZmxhZyBpbiB6bGliIGhlYWRlclxcclxcbiAgICB2YXIgUFJFU0VUX0RJQ1QgPSAweDIwO1xcclxcblxcclxcbiAgICB2YXIgSU5JVF9TVEFURSA9IDQyO1xcclxcbiAgICB2YXIgQlVTWV9TVEFURSA9IDExMztcXHJcXG4gICAgdmFyIEZJTklTSF9TVEFURSA9IDY2NjtcXHJcXG5cXHJcXG4gICAgLy8gVGhlIGRlZmxhdGUgY29tcHJlc3Npb24gbWV0aG9kXFxyXFxuICAgIHZhciBaX0RFRkxBVEVEID0gODtcXHJcXG5cXHJcXG4gICAgdmFyIFNUT1JFRF9CTE9DSyA9IDA7XFxyXFxuICAgIHZhciBTVEFUSUNfVFJFRVMgPSAxO1xcclxcbiAgICB2YXIgRFlOX1RSRUVTID0gMjtcXHJcXG5cXHJcXG4gICAgdmFyIE1JTl9NQVRDSCA9IDM7XFxyXFxuICAgIHZhciBNQVhfTUFUQ0ggPSAyNTg7XFxyXFxuICAgIHZhciBNSU5fTE9PS0FIRUFEID0gKE1BWF9NQVRDSCArIE1JTl9NQVRDSCArIDEpO1xcclxcblxcclxcbiAgICBmdW5jdGlvbiBzbWFsbGVyKHRyZWUsIG4sIG0sIGRlcHRoKSB7XFxyXFxuICAgICAgICB2YXIgdG4yID0gdHJlZVtuICogMl07XFxyXFxuICAgICAgICB2YXIgdG0yID0gdHJlZVttICogMl07XFxyXFxuICAgICAgICByZXR1cm4gKHRuMiA8IHRtMiB8fCAodG4yID09IHRtMiAmJiBkZXB0aFtuXSA8PSBkZXB0aFttXSkpO1xcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgIGZ1bmN0aW9uIERlZmxhdGUoKSB7XFxyXFxuXFxyXFxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XFxyXFxuICAgICAgICB2YXIgc3RybTsgLy8gcG9pbnRlciBiYWNrIHRvIHRoaXMgemxpYiBzdHJlYW1cXHJcXG4gICAgICAgIHZhciBzdGF0dXM7IC8vIGFzIHRoZSBuYW1lIGltcGxpZXNcXHJcXG4gICAgICAgIC8vIHBlbmRpbmdfYnVmOyAvLyBvdXRwdXQgc3RpbGwgcGVuZGluZ1xcclxcbiAgICAgICAgdmFyIHBlbmRpbmdfYnVmX3NpemU7IC8vIHNpemUgb2YgcGVuZGluZ19idWZcXHJcXG4gICAgICAgIC8vIHBlbmRpbmdfb3V0OyAvLyBuZXh0IHBlbmRpbmcgYnl0ZSB0byBvdXRwdXQgdG8gdGhlIHN0cmVhbVxcclxcbiAgICAgICAgLy8gcGVuZGluZzsgLy8gbmIgb2YgYnl0ZXMgaW4gdGhlIHBlbmRpbmcgYnVmZmVyXFxyXFxuICAgICAgICB2YXIgbWV0aG9kOyAvLyBTVE9SRUQgKGZvciB6aXAgb25seSkgb3IgREVGTEFURURcXHJcXG4gICAgICAgIHZhciBsYXN0X2ZsdXNoOyAvLyB2YWx1ZSBvZiBmbHVzaCBwYXJhbSBmb3IgcHJldmlvdXMgZGVmbGF0ZSBjYWxsXFxyXFxuXFxyXFxuICAgICAgICB2YXIgd19zaXplOyAvLyBMWjc3IHdpbmRvdyBzaXplICgzMksgYnkgZGVmYXVsdClcXHJcXG4gICAgICAgIHZhciB3X2JpdHM7IC8vIGxvZzIod19zaXplKSAoOC4uMTYpXFxyXFxuICAgICAgICB2YXIgd19tYXNrOyAvLyB3X3NpemUgLSAxXFxyXFxuXFxyXFxuICAgICAgICB2YXIgd2luZG93O1xcclxcbiAgICAgICAgLy8gU2xpZGluZyB3aW5kb3cuIElucHV0IGJ5dGVzIGFyZSByZWFkIGludG8gdGhlIHNlY29uZCBoYWxmIG9mIHRoZSB3aW5kb3csXFxyXFxuICAgICAgICAvLyBhbmQgbW92ZSB0byB0aGUgZmlyc3QgaGFsZiBsYXRlciB0byBrZWVwIGEgZGljdGlvbmFyeSBvZiBhdCBsZWFzdCB3U2l6ZVxcclxcbiAgICAgICAgLy8gYnl0ZXMuIFdpdGggdGhpcyBvcmdhbml6YXRpb24sIG1hdGNoZXMgYXJlIGxpbWl0ZWQgdG8gYSBkaXN0YW5jZSBvZlxcclxcbiAgICAgICAgLy8gd1NpemUtTUFYX01BVENIIGJ5dGVzLCBidXQgdGhpcyBlbnN1cmVzIHRoYXQgSU8gaXMgYWx3YXlzXFxyXFxuICAgICAgICAvLyBwZXJmb3JtZWQgd2l0aCBhIGxlbmd0aCBtdWx0aXBsZSBvZiB0aGUgYmxvY2sgc2l6ZS4gQWxzbywgaXQgbGltaXRzXFxyXFxuICAgICAgICAvLyB0aGUgd2luZG93IHNpemUgdG8gNjRLLCB3aGljaCBpcyBxdWl0ZSB1c2VmdWwgb24gTVNET1MuXFxyXFxuICAgICAgICAvLyBUbyBkbzogdXNlIHRoZSB1c2VyIGlucHV0IGJ1ZmZlciBhcyBzbGlkaW5nIHdpbmRvdy5cXHJcXG5cXHJcXG4gICAgICAgIHZhciB3aW5kb3dfc2l6ZTtcXHJcXG4gICAgICAgIC8vIEFjdHVhbCBzaXplIG9mIHdpbmRvdzogMip3U2l6ZSwgZXhjZXB0IHdoZW4gdGhlIHVzZXIgaW5wdXQgYnVmZmVyXFxyXFxuICAgICAgICAvLyBpcyBkaXJlY3RseSB1c2VkIGFzIHNsaWRpbmcgd2luZG93LlxcclxcblxcclxcbiAgICAgICAgdmFyIHByZXY7XFxyXFxuICAgICAgICAvLyBMaW5rIHRvIG9sZGVyIHN0cmluZyB3aXRoIHNhbWUgaGFzaCBpbmRleC4gVG8gbGltaXQgdGhlIHNpemUgb2YgdGhpc1xcclxcbiAgICAgICAgLy8gYXJyYXkgdG8gNjRLLCB0aGlzIGxpbmsgaXMgbWFpbnRhaW5lZCBvbmx5IGZvciB0aGUgbGFzdCAzMksgc3RyaW5ncy5cXHJcXG4gICAgICAgIC8vIEFuIGluZGV4IGluIHRoaXMgYXJyYXkgaXMgdGh1cyBhIHdpbmRvdyBpbmRleCBtb2R1bG8gMzJLLlxcclxcblxcclxcbiAgICAgICAgdmFyIGhlYWQ7IC8vIEhlYWRzIG9mIHRoZSBoYXNoIGNoYWlucyBvciBOSUwuXFxyXFxuXFxyXFxuICAgICAgICB2YXIgaW5zX2g7IC8vIGhhc2ggaW5kZXggb2Ygc3RyaW5nIHRvIGJlIGluc2VydGVkXFxyXFxuICAgICAgICB2YXIgaGFzaF9zaXplOyAvLyBudW1iZXIgb2YgZWxlbWVudHMgaW4gaGFzaCB0YWJsZVxcclxcbiAgICAgICAgdmFyIGhhc2hfYml0czsgLy8gbG9nMihoYXNoX3NpemUpXFxyXFxuICAgICAgICB2YXIgaGFzaF9tYXNrOyAvLyBoYXNoX3NpemUtMVxcclxcblxcclxcbiAgICAgICAgLy8gTnVtYmVyIG9mIGJpdHMgYnkgd2hpY2ggaW5zX2ggbXVzdCBiZSBzaGlmdGVkIGF0IGVhY2ggaW5wdXRcXHJcXG4gICAgICAgIC8vIHN0ZXAuIEl0IG11c3QgYmUgc3VjaCB0aGF0IGFmdGVyIE1JTl9NQVRDSCBzdGVwcywgdGhlIG9sZGVzdFxcclxcbiAgICAgICAgLy8gYnl0ZSBubyBsb25nZXIgdGFrZXMgcGFydCBpbiB0aGUgaGFzaCBrZXksIHRoYXQgaXM6XFxyXFxuICAgICAgICAvLyBoYXNoX3NoaWZ0ICogTUlOX01BVENIID49IGhhc2hfYml0c1xcclxcbiAgICAgICAgdmFyIGhhc2hfc2hpZnQ7XFxyXFxuXFxyXFxuICAgICAgICAvLyBXaW5kb3cgcG9zaXRpb24gYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgY3VycmVudCBvdXRwdXQgYmxvY2suIEdldHNcXHJcXG4gICAgICAgIC8vIG5lZ2F0aXZlIHdoZW4gdGhlIHdpbmRvdyBpcyBtb3ZlZCBiYWNrd2FyZHMuXFxyXFxuXFxyXFxuICAgICAgICB2YXIgYmxvY2tfc3RhcnQ7XFxyXFxuXFxyXFxuICAgICAgICB2YXIgbWF0Y2hfbGVuZ3RoOyAvLyBsZW5ndGggb2YgYmVzdCBtYXRjaFxcclxcbiAgICAgICAgdmFyIHByZXZfbWF0Y2g7IC8vIHByZXZpb3VzIG1hdGNoXFxyXFxuICAgICAgICB2YXIgbWF0Y2hfYXZhaWxhYmxlOyAvLyBzZXQgaWYgcHJldmlvdXMgbWF0Y2ggZXhpc3RzXFxyXFxuICAgICAgICB2YXIgc3Ryc3RhcnQ7IC8vIHN0YXJ0IG9mIHN0cmluZyB0byBpbnNlcnRcXHJcXG4gICAgICAgIHZhciBtYXRjaF9zdGFydDsgLy8gc3RhcnQgb2YgbWF0Y2hpbmcgc3RyaW5nXFxyXFxuICAgICAgICB2YXIgbG9va2FoZWFkOyAvLyBudW1iZXIgb2YgdmFsaWQgYnl0ZXMgYWhlYWQgaW4gd2luZG93XFxyXFxuXFxyXFxuICAgICAgICAvLyBMZW5ndGggb2YgdGhlIGJlc3QgbWF0Y2ggYXQgcHJldmlvdXMgc3RlcC4gTWF0Y2hlcyBub3QgZ3JlYXRlciB0aGFuIHRoaXNcXHJcXG4gICAgICAgIC8vIGFyZSBkaXNjYXJkZWQuIFRoaXMgaXMgdXNlZCBpbiB0aGUgbGF6eSBtYXRjaCBldmFsdWF0aW9uLlxcclxcbiAgICAgICAgdmFyIHByZXZfbGVuZ3RoO1xcclxcblxcclxcbiAgICAgICAgLy8gVG8gc3BlZWQgdXAgZGVmbGF0aW9uLCBoYXNoIGNoYWlucyBhcmUgbmV2ZXIgc2VhcmNoZWQgYmV5b25kIHRoaXNcXHJcXG4gICAgICAgIC8vIGxlbmd0aC4gQSBoaWdoZXIgbGltaXQgaW1wcm92ZXMgY29tcHJlc3Npb24gcmF0aW8gYnV0IGRlZ3JhZGVzIHRoZSBzcGVlZC5cXHJcXG4gICAgICAgIHZhciBtYXhfY2hhaW5fbGVuZ3RoO1xcclxcblxcclxcbiAgICAgICAgLy8gQXR0ZW1wdCB0byBmaW5kIGEgYmV0dGVyIG1hdGNoIG9ubHkgd2hlbiB0aGUgY3VycmVudCBtYXRjaCBpcyBzdHJpY3RseVxcclxcbiAgICAgICAgLy8gc21hbGxlciB0aGFuIHRoaXMgdmFsdWUuIFRoaXMgbWVjaGFuaXNtIGlzIHVzZWQgb25seSBmb3IgY29tcHJlc3Npb25cXHJcXG4gICAgICAgIC8vIGxldmVscyA+PSA0LlxcclxcbiAgICAgICAgdmFyIG1heF9sYXp5X21hdGNoO1xcclxcblxcclxcbiAgICAgICAgLy8gSW5zZXJ0IG5ldyBzdHJpbmdzIGluIHRoZSBoYXNoIHRhYmxlIG9ubHkgaWYgdGhlIG1hdGNoIGxlbmd0aCBpcyBub3RcXHJcXG4gICAgICAgIC8vIGdyZWF0ZXIgdGhhbiB0aGlzIGxlbmd0aC4gVGhpcyBzYXZlcyB0aW1lIGJ1dCBkZWdyYWRlcyBjb21wcmVzc2lvbi5cXHJcXG4gICAgICAgIC8vIG1heF9pbnNlcnRfbGVuZ3RoIGlzIHVzZWQgb25seSBmb3IgY29tcHJlc3Npb24gbGV2ZWxzIDw9IDMuXFxyXFxuXFxyXFxuICAgICAgICB2YXIgbGV2ZWw7IC8vIGNvbXByZXNzaW9uIGxldmVsICgxLi45KVxcclxcbiAgICAgICAgdmFyIHN0cmF0ZWd5OyAvLyBmYXZvciBvciBmb3JjZSBIdWZmbWFuIGNvZGluZ1xcclxcblxcclxcbiAgICAgICAgLy8gVXNlIGEgZmFzdGVyIHNlYXJjaCB3aGVuIHRoZSBwcmV2aW91cyBtYXRjaCBpcyBsb25nZXIgdGhhbiB0aGlzXFxyXFxuICAgICAgICB2YXIgZ29vZF9tYXRjaDtcXHJcXG5cXHJcXG4gICAgICAgIC8vIFN0b3Agc2VhcmNoaW5nIHdoZW4gY3VycmVudCBtYXRjaCBleGNlZWRzIHRoaXNcXHJcXG4gICAgICAgIHZhciBuaWNlX21hdGNoO1xcclxcblxcclxcbiAgICAgICAgdmFyIGR5bl9sdHJlZTsgLy8gbGl0ZXJhbCBhbmQgbGVuZ3RoIHRyZWVcXHJcXG4gICAgICAgIHZhciBkeW5fZHRyZWU7IC8vIGRpc3RhbmNlIHRyZWVcXHJcXG4gICAgICAgIHZhciBibF90cmVlOyAvLyBIdWZmbWFuIHRyZWUgZm9yIGJpdCBsZW5ndGhzXFxyXFxuXFxyXFxuICAgICAgICB2YXIgbF9kZXNjID0gbmV3IFRyZWUoKTsgLy8gZGVzYyBmb3IgbGl0ZXJhbCB0cmVlXFxyXFxuICAgICAgICB2YXIgZF9kZXNjID0gbmV3IFRyZWUoKTsgLy8gZGVzYyBmb3IgZGlzdGFuY2UgdHJlZVxcclxcbiAgICAgICAgdmFyIGJsX2Rlc2MgPSBuZXcgVHJlZSgpOyAvLyBkZXNjIGZvciBiaXQgbGVuZ3RoIHRyZWVcXHJcXG5cXHJcXG4gICAgICAgIC8vIHRoYXQuaGVhcF9sZW47IC8vIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgaGVhcFxcclxcbiAgICAgICAgLy8gdGhhdC5oZWFwX21heDsgLy8gZWxlbWVudCBvZiBsYXJnZXN0IGZyZXF1ZW5jeVxcclxcbiAgICAgICAgLy8gVGhlIHNvbnMgb2YgaGVhcFtuXSBhcmUgaGVhcFsyKm5dIGFuZCBoZWFwWzIqbisxXS4gaGVhcFswXSBpcyBub3QgdXNlZC5cXHJcXG4gICAgICAgIC8vIFRoZSBzYW1lIGhlYXAgYXJyYXkgaXMgdXNlZCB0byBidWlsZCBhbGwgdHJlZXMuXFxyXFxuXFxyXFxuICAgICAgICAvLyBEZXB0aCBvZiBlYWNoIHN1YnRyZWUgdXNlZCBhcyB0aWUgYnJlYWtlciBmb3IgdHJlZXMgb2YgZXF1YWwgZnJlcXVlbmN5XFxyXFxuICAgICAgICB0aGF0LmRlcHRoID0gW107XFxyXFxuXFxyXFxuICAgICAgICB2YXIgbF9idWY7IC8vIGluZGV4IGZvciBsaXRlcmFscyBvciBsZW5ndGhzICovXFxyXFxuXFxyXFxuICAgICAgICAvLyBTaXplIG9mIG1hdGNoIGJ1ZmZlciBmb3IgbGl0ZXJhbHMvbGVuZ3Rocy4gVGhlcmUgYXJlIDQgcmVhc29ucyBmb3JcXHJcXG4gICAgICAgIC8vIGxpbWl0aW5nIGxpdF9idWZzaXplIHRvIDY0SzpcXHJcXG4gICAgICAgIC8vIC0gZnJlcXVlbmNpZXMgY2FuIGJlIGtlcHQgaW4gMTYgYml0IGNvdW50ZXJzXFxyXFxuICAgICAgICAvLyAtIGlmIGNvbXByZXNzaW9uIGlzIG5vdCBzdWNjZXNzZnVsIGZvciB0aGUgZmlyc3QgYmxvY2ssIGFsbCBpbnB1dFxcclxcbiAgICAgICAgLy8gZGF0YSBpcyBzdGlsbCBpbiB0aGUgd2luZG93IHNvIHdlIGNhbiBzdGlsbCBlbWl0IGEgc3RvcmVkIGJsb2NrIGV2ZW5cXHJcXG4gICAgICAgIC8vIHdoZW4gaW5wdXQgY29tZXMgZnJvbSBzdGFuZGFyZCBpbnB1dC4gKFRoaXMgY2FuIGFsc28gYmUgZG9uZSBmb3JcXHJcXG4gICAgICAgIC8vIGFsbCBibG9ja3MgaWYgbGl0X2J1ZnNpemUgaXMgbm90IGdyZWF0ZXIgdGhhbiAzMksuKVxcclxcbiAgICAgICAgLy8gLSBpZiBjb21wcmVzc2lvbiBpcyBub3Qgc3VjY2Vzc2Z1bCBmb3IgYSBmaWxlIHNtYWxsZXIgdGhhbiA2NEssIHdlIGNhblxcclxcbiAgICAgICAgLy8gZXZlbiBlbWl0IGEgc3RvcmVkIGZpbGUgaW5zdGVhZCBvZiBhIHN0b3JlZCBibG9jayAoc2F2aW5nIDUgYnl0ZXMpLlxcclxcbiAgICAgICAgLy8gVGhpcyBpcyBhcHBsaWNhYmxlIG9ubHkgZm9yIHppcCAobm90IGd6aXAgb3IgemxpYikuXFxyXFxuICAgICAgICAvLyAtIGNyZWF0aW5nIG5ldyBIdWZmbWFuIHRyZWVzIGxlc3MgZnJlcXVlbnRseSBtYXkgbm90IHByb3ZpZGUgZmFzdFxcclxcbiAgICAgICAgLy8gYWRhcHRhdGlvbiB0byBjaGFuZ2VzIGluIHRoZSBpbnB1dCBkYXRhIHN0YXRpc3RpY3MuIChUYWtlIGZvclxcclxcbiAgICAgICAgLy8gZXhhbXBsZSBhIGJpbmFyeSBmaWxlIHdpdGggcG9vcmx5IGNvbXByZXNzaWJsZSBjb2RlIGZvbGxvd2VkIGJ5XFxyXFxuICAgICAgICAvLyBhIGhpZ2hseSBjb21wcmVzc2libGUgc3RyaW5nIHRhYmxlLikgU21hbGxlciBidWZmZXIgc2l6ZXMgZ2l2ZVxcclxcbiAgICAgICAgLy8gZmFzdCBhZGFwdGF0aW9uIGJ1dCBoYXZlIG9mIGNvdXJzZSB0aGUgb3ZlcmhlYWQgb2YgdHJhbnNtaXR0aW5nXFxyXFxuICAgICAgICAvLyB0cmVlcyBtb3JlIGZyZXF1ZW50bHkuXFxyXFxuICAgICAgICAvLyAtIEkgY2FuJ3QgY291bnQgYWJvdmUgNFxcclxcbiAgICAgICAgdmFyIGxpdF9idWZzaXplO1xcclxcblxcclxcbiAgICAgICAgdmFyIGxhc3RfbGl0OyAvLyBydW5uaW5nIGluZGV4IGluIGxfYnVmXFxyXFxuXFxyXFxuICAgICAgICAvLyBCdWZmZXIgZm9yIGRpc3RhbmNlcy4gVG8gc2ltcGxpZnkgdGhlIGNvZGUsIGRfYnVmIGFuZCBsX2J1ZiBoYXZlXFxyXFxuICAgICAgICAvLyB0aGUgc2FtZSBudW1iZXIgb2YgZWxlbWVudHMuIFRvIHVzZSBkaWZmZXJlbnQgbGVuZ3RocywgYW4gZXh0cmEgZmxhZ1xcclxcbiAgICAgICAgLy8gYXJyYXkgd291bGQgYmUgbmVjZXNzYXJ5LlxcclxcblxcclxcbiAgICAgICAgdmFyIGRfYnVmOyAvLyBpbmRleCBvZiBwZW5kaWdfYnVmXFxyXFxuXFxyXFxuICAgICAgICAvLyB0aGF0Lm9wdF9sZW47IC8vIGJpdCBsZW5ndGggb2YgY3VycmVudCBibG9jayB3aXRoIG9wdGltYWwgdHJlZXNcXHJcXG4gICAgICAgIC8vIHRoYXQuc3RhdGljX2xlbjsgLy8gYml0IGxlbmd0aCBvZiBjdXJyZW50IGJsb2NrIHdpdGggc3RhdGljIHRyZWVzXFxyXFxuICAgICAgICB2YXIgbWF0Y2hlczsgLy8gbnVtYmVyIG9mIHN0cmluZyBtYXRjaGVzIGluIGN1cnJlbnQgYmxvY2tcXHJcXG4gICAgICAgIHZhciBsYXN0X2VvYl9sZW47IC8vIGJpdCBsZW5ndGggb2YgRU9CIGNvZGUgZm9yIGxhc3QgYmxvY2tcXHJcXG5cXHJcXG4gICAgICAgIC8vIE91dHB1dCBidWZmZXIuIGJpdHMgYXJlIGluc2VydGVkIHN0YXJ0aW5nIGF0IHRoZSBib3R0b20gKGxlYXN0XFxyXFxuICAgICAgICAvLyBzaWduaWZpY2FudCBiaXRzKS5cXHJcXG4gICAgICAgIHZhciBiaV9idWY7XFxyXFxuXFxyXFxuICAgICAgICAvLyBOdW1iZXIgb2YgdmFsaWQgYml0cyBpbiBiaV9idWYuIEFsbCBiaXRzIGFib3ZlIHRoZSBsYXN0IHZhbGlkIGJpdFxcclxcbiAgICAgICAgLy8gYXJlIGFsd2F5cyB6ZXJvLlxcclxcbiAgICAgICAgdmFyIGJpX3ZhbGlkO1xcclxcblxcclxcbiAgICAgICAgLy8gbnVtYmVyIG9mIGNvZGVzIGF0IGVhY2ggYml0IGxlbmd0aCBmb3IgYW4gb3B0aW1hbCB0cmVlXFxyXFxuICAgICAgICB0aGF0LmJsX2NvdW50ID0gW107XFxyXFxuXFxyXFxuICAgICAgICAvLyBoZWFwIHVzZWQgdG8gYnVpbGQgdGhlIEh1ZmZtYW4gdHJlZXNcXHJcXG4gICAgICAgIHRoYXQuaGVhcCA9IFtdO1xcclxcblxcclxcbiAgICAgICAgZHluX2x0cmVlID0gW107XFxyXFxuICAgICAgICBkeW5fZHRyZWUgPSBbXTtcXHJcXG4gICAgICAgIGJsX3RyZWUgPSBbXTtcXHJcXG5cXHJcXG4gICAgICAgIGZ1bmN0aW9uIGxtX2luaXQoKSB7XFxyXFxuICAgICAgICAgICAgdmFyIGk7XFxyXFxuICAgICAgICAgICAgd2luZG93X3NpemUgPSAyICogd19zaXplO1xcclxcblxcclxcbiAgICAgICAgICAgIGhlYWRbaGFzaF9zaXplIC0gMV0gPSAwO1xcclxcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBoYXNoX3NpemUgLSAxOyBpKyspIHtcXHJcXG4gICAgICAgICAgICAgICAgaGVhZFtpXSA9IDA7XFxyXFxuICAgICAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgICAgIC8vIFNldCB0aGUgZGVmYXVsdCBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnM6XFxyXFxuICAgICAgICAgICAgbWF4X2xhenlfbWF0Y2ggPSBjb25maWdfdGFibGVbbGV2ZWxdLm1heF9sYXp5O1xcclxcbiAgICAgICAgICAgIGdvb2RfbWF0Y2ggPSBjb25maWdfdGFibGVbbGV2ZWxdLmdvb2RfbGVuZ3RoO1xcclxcbiAgICAgICAgICAgIG5pY2VfbWF0Y2ggPSBjb25maWdfdGFibGVbbGV2ZWxdLm5pY2VfbGVuZ3RoO1xcclxcbiAgICAgICAgICAgIG1heF9jaGFpbl9sZW5ndGggPSBjb25maWdfdGFibGVbbGV2ZWxdLm1heF9jaGFpbjtcXHJcXG5cXHJcXG4gICAgICAgICAgICBzdHJzdGFydCA9IDA7XFxyXFxuICAgICAgICAgICAgYmxvY2tfc3RhcnQgPSAwO1xcclxcbiAgICAgICAgICAgIGxvb2thaGVhZCA9IDA7XFxyXFxuICAgICAgICAgICAgbWF0Y2hfbGVuZ3RoID0gcHJldl9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xcclxcbiAgICAgICAgICAgIG1hdGNoX2F2YWlsYWJsZSA9IDA7XFxyXFxuICAgICAgICAgICAgaW5zX2ggPSAwO1xcclxcbiAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgZnVuY3Rpb24gaW5pdF9ibG9jaygpIHtcXHJcXG4gICAgICAgICAgICB2YXIgaTtcXHJcXG4gICAgICAgICAgICAvLyBJbml0aWFsaXplIHRoZSB0cmVlcy5cXHJcXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgTF9DT0RFUzsgaSsrKVxcclxcbiAgICAgICAgICAgICAgICBkeW5fbHRyZWVbaSAqIDJdID0gMDtcXHJcXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgRF9DT0RFUzsgaSsrKVxcclxcbiAgICAgICAgICAgICAgICBkeW5fZHRyZWVbaSAqIDJdID0gMDtcXHJcXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgQkxfQ09ERVM7IGkrKylcXHJcXG4gICAgICAgICAgICAgICAgYmxfdHJlZVtpICogMl0gPSAwO1xcclxcblxcclxcbiAgICAgICAgICAgIGR5bl9sdHJlZVtFTkRfQkxPQ0sgKiAyXSA9IDE7XFxyXFxuICAgICAgICAgICAgdGhhdC5vcHRfbGVuID0gdGhhdC5zdGF0aWNfbGVuID0gMDtcXHJcXG4gICAgICAgICAgICBsYXN0X2xpdCA9IG1hdGNoZXMgPSAwO1xcclxcbiAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgdHJlZSBkYXRhIHN0cnVjdHVyZXMgZm9yIGEgbmV3IHpsaWIgc3RyZWFtLlxcclxcbiAgICAgICAgZnVuY3Rpb24gdHJfaW5pdCgpIHtcXHJcXG5cXHJcXG4gICAgICAgICAgICBsX2Rlc2MuZHluX3RyZWUgPSBkeW5fbHRyZWU7XFxyXFxuICAgICAgICAgICAgbF9kZXNjLnN0YXRfZGVzYyA9IFN0YXRpY1RyZWUuc3RhdGljX2xfZGVzYztcXHJcXG5cXHJcXG4gICAgICAgICAgICBkX2Rlc2MuZHluX3RyZWUgPSBkeW5fZHRyZWU7XFxyXFxuICAgICAgICAgICAgZF9kZXNjLnN0YXRfZGVzYyA9IFN0YXRpY1RyZWUuc3RhdGljX2RfZGVzYztcXHJcXG5cXHJcXG4gICAgICAgICAgICBibF9kZXNjLmR5bl90cmVlID0gYmxfdHJlZTtcXHJcXG4gICAgICAgICAgICBibF9kZXNjLnN0YXRfZGVzYyA9IFN0YXRpY1RyZWUuc3RhdGljX2JsX2Rlc2M7XFxyXFxuXFxyXFxuICAgICAgICAgICAgYmlfYnVmID0gMDtcXHJcXG4gICAgICAgICAgICBiaV92YWxpZCA9IDA7XFxyXFxuICAgICAgICAgICAgbGFzdF9lb2JfbGVuID0gODsgLy8gZW5vdWdoIGxvb2thaGVhZCBmb3IgaW5mbGF0ZVxcclxcblxcclxcbiAgICAgICAgICAgIC8vIEluaXRpYWxpemUgdGhlIGZpcnN0IGJsb2NrIG9mIHRoZSBmaXJzdCBmaWxlOlxcclxcbiAgICAgICAgICAgIGluaXRfYmxvY2soKTtcXHJcXG4gICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgIC8vIFJlc3RvcmUgdGhlIGhlYXAgcHJvcGVydHkgYnkgbW92aW5nIGRvd24gdGhlIHRyZWUgc3RhcnRpbmcgYXQgbm9kZSBrLFxcclxcbiAgICAgICAgLy8gZXhjaGFuZ2luZyBhIG5vZGUgd2l0aCB0aGUgc21hbGxlc3Qgb2YgaXRzIHR3byBzb25zIGlmIG5lY2Vzc2FyeSxcXHJcXG4gICAgICAgIC8vIHN0b3BwaW5nXFxyXFxuICAgICAgICAvLyB3aGVuIHRoZSBoZWFwIHByb3BlcnR5IGlzIHJlLWVzdGFibGlzaGVkIChlYWNoIGZhdGhlciBzbWFsbGVyIHRoYW4gaXRzXFxyXFxuICAgICAgICAvLyB0d28gc29ucykuXFxyXFxuICAgICAgICB0aGF0LnBxZG93bmhlYXAgPSBmdW5jdGlvbih0cmVlLCAvLyB0aGUgdHJlZSB0byByZXN0b3JlXFxyXFxuICAgICAgICBrIC8vIG5vZGUgdG8gbW92ZSBkb3duXFxyXFxuICAgICAgICApIHtcXHJcXG4gICAgICAgICAgICB2YXIgaGVhcCA9IHRoYXQuaGVhcDtcXHJcXG4gICAgICAgICAgICB2YXIgdiA9IGhlYXBba107XFxyXFxuICAgICAgICAgICAgdmFyIGogPSBrIDw8IDE7IC8vIGxlZnQgc29uIG9mIGtcXHJcXG4gICAgICAgICAgICB3aGlsZSAoaiA8PSB0aGF0LmhlYXBfbGVuKSB7XFxyXFxuICAgICAgICAgICAgICAgIC8vIFNldCBqIHRvIHRoZSBzbWFsbGVzdCBvZiB0aGUgdHdvIHNvbnM6XFxyXFxuICAgICAgICAgICAgICAgIGlmIChqIDwgdGhhdC5oZWFwX2xlbiAmJiBzbWFsbGVyKHRyZWUsIGhlYXBbaiArIDFdLCBoZWFwW2pdLCB0aGF0LmRlcHRoKSkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgaisrO1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgIC8vIEV4aXQgaWYgdiBpcyBzbWFsbGVyIHRoYW4gYm90aCBzb25zXFxyXFxuICAgICAgICAgICAgICAgIGlmIChzbWFsbGVyKHRyZWUsIHYsIGhlYXBbal0sIHRoYXQuZGVwdGgpKVxcclxcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgIC8vIEV4Y2hhbmdlIHYgd2l0aCB0aGUgc21hbGxlc3Qgc29uXFxyXFxuICAgICAgICAgICAgICAgIGhlYXBba10gPSBoZWFwW2pdO1xcclxcbiAgICAgICAgICAgICAgICBrID0gajtcXHJcXG4gICAgICAgICAgICAgICAgLy8gQW5kIGNvbnRpbnVlIGRvd24gdGhlIHRyZWUsIHNldHRpbmcgaiB0byB0aGUgbGVmdCBzb24gb2Yga1xcclxcbiAgICAgICAgICAgICAgICBqIDw8PSAxO1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICBoZWFwW2tdID0gdjtcXHJcXG4gICAgICAgIH07XFxyXFxuXFxyXFxuICAgICAgICAvLyBTY2FuIGEgbGl0ZXJhbCBvciBkaXN0YW5jZSB0cmVlIHRvIGRldGVybWluZSB0aGUgZnJlcXVlbmNpZXMgb2YgdGhlIGNvZGVzXFxyXFxuICAgICAgICAvLyBpbiB0aGUgYml0IGxlbmd0aCB0cmVlLlxcclxcbiAgICAgICAgZnVuY3Rpb24gc2Nhbl90cmVlKHRyZWUsLy8gdGhlIHRyZWUgdG8gYmUgc2Nhbm5lZFxcclxcbiAgICAgICAgbWF4X2NvZGUgLy8gYW5kIGl0cyBsYXJnZXN0IGNvZGUgb2Ygbm9uIHplcm8gZnJlcXVlbmN5XFxyXFxuICAgICAgICApIHtcXHJcXG4gICAgICAgICAgICB2YXIgbjsgLy8gaXRlcmF0ZXMgb3ZlciBhbGwgdHJlZSBlbGVtZW50c1xcclxcbiAgICAgICAgICAgIHZhciBwcmV2bGVuID0gLTE7IC8vIGxhc3QgZW1pdHRlZCBsZW5ndGhcXHJcXG4gICAgICAgICAgICB2YXIgY3VybGVuOyAvLyBsZW5ndGggb2YgY3VycmVudCBjb2RlXFxyXFxuICAgICAgICAgICAgdmFyIG5leHRsZW4gPSB0cmVlWzAgKiAyICsgMV07IC8vIGxlbmd0aCBvZiBuZXh0IGNvZGVcXHJcXG4gICAgICAgICAgICB2YXIgY291bnQgPSAwOyAvLyByZXBlYXQgY291bnQgb2YgdGhlIGN1cnJlbnQgY29kZVxcclxcbiAgICAgICAgICAgIHZhciBtYXhfY291bnQgPSA3OyAvLyBtYXggcmVwZWF0IGNvdW50XFxyXFxuICAgICAgICAgICAgdmFyIG1pbl9jb3VudCA9IDQ7IC8vIG1pbiByZXBlYXQgY291bnRcXHJcXG5cXHJcXG4gICAgICAgICAgICBpZiAobmV4dGxlbiA9PT0gMCkge1xcclxcbiAgICAgICAgICAgICAgICBtYXhfY291bnQgPSAxMzg7XFxyXFxuICAgICAgICAgICAgICAgIG1pbl9jb3VudCA9IDM7XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIHRyZWVbKG1heF9jb2RlICsgMSkgKiAyICsgMV0gPSAweGZmZmY7IC8vIGd1YXJkXFxyXFxuXFxyXFxuICAgICAgICAgICAgZm9yIChuID0gMDsgbiA8PSBtYXhfY29kZTsgbisrKSB7XFxyXFxuICAgICAgICAgICAgICAgIGN1cmxlbiA9IG5leHRsZW47XFxyXFxuICAgICAgICAgICAgICAgIG5leHRsZW4gPSB0cmVlWyhuICsgMSkgKiAyICsgMV07XFxyXFxuICAgICAgICAgICAgICAgIGlmICgrK2NvdW50IDwgbWF4X2NvdW50ICYmIGN1cmxlbiA9PSBuZXh0bGVuKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcXHJcXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb3VudCA8IG1pbl9jb3VudCkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgYmxfdHJlZVtjdXJsZW4gKiAyXSArPSBjb3VudDtcXHJcXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJsZW4gIT09IDApIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJsZW4gIT0gcHJldmxlbilcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBibF90cmVlW2N1cmxlbiAqIDJdKys7XFxyXFxuICAgICAgICAgICAgICAgICAgICBibF90cmVlW1JFUF8zXzYgKiAyXSsrO1xcclxcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvdW50IDw9IDEwKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICBibF90cmVlW1JFUFpfM18xMCAqIDJdKys7XFxyXFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICBibF90cmVlW1JFUFpfMTFfMTM4ICogMl0rKztcXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICBjb3VudCA9IDA7XFxyXFxuICAgICAgICAgICAgICAgIHByZXZsZW4gPSBjdXJsZW47XFxyXFxuICAgICAgICAgICAgICAgIGlmIChuZXh0bGVuID09PSAwKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICBtYXhfY291bnQgPSAxMzg7XFxyXFxuICAgICAgICAgICAgICAgICAgICBtaW5fY291bnQgPSAzO1xcclxcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGN1cmxlbiA9PSBuZXh0bGVuKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICBtYXhfY291bnQgPSA2O1xcclxcbiAgICAgICAgICAgICAgICAgICAgbWluX2NvdW50ID0gMztcXHJcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIG1heF9jb3VudCA9IDc7XFxyXFxuICAgICAgICAgICAgICAgICAgICBtaW5fY291bnQgPSA0O1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgLy8gQ29uc3RydWN0IHRoZSBIdWZmbWFuIHRyZWUgZm9yIHRoZSBiaXQgbGVuZ3RocyBhbmQgcmV0dXJuIHRoZSBpbmRleCBpblxcclxcbiAgICAgICAgLy8gYmxfb3JkZXIgb2YgdGhlIGxhc3QgYml0IGxlbmd0aCBjb2RlIHRvIHNlbmQuXFxyXFxuICAgICAgICBmdW5jdGlvbiBidWlsZF9ibF90cmVlKCkge1xcclxcbiAgICAgICAgICAgIHZhciBtYXhfYmxpbmRleDsgLy8gaW5kZXggb2YgbGFzdCBiaXQgbGVuZ3RoIGNvZGUgb2Ygbm9uIHplcm8gZnJlcVxcclxcblxcclxcbiAgICAgICAgICAgIC8vIERldGVybWluZSB0aGUgYml0IGxlbmd0aCBmcmVxdWVuY2llcyBmb3IgbGl0ZXJhbCBhbmQgZGlzdGFuY2UgdHJlZXNcXHJcXG4gICAgICAgICAgICBzY2FuX3RyZWUoZHluX2x0cmVlLCBsX2Rlc2MubWF4X2NvZGUpO1xcclxcbiAgICAgICAgICAgIHNjYW5fdHJlZShkeW5fZHRyZWUsIGRfZGVzYy5tYXhfY29kZSk7XFxyXFxuXFxyXFxuICAgICAgICAgICAgLy8gQnVpbGQgdGhlIGJpdCBsZW5ndGggdHJlZTpcXHJcXG4gICAgICAgICAgICBibF9kZXNjLmJ1aWxkX3RyZWUodGhhdCk7XFxyXFxuICAgICAgICAgICAgLy8gb3B0X2xlbiBub3cgaW5jbHVkZXMgdGhlIGxlbmd0aCBvZiB0aGUgdHJlZSByZXByZXNlbnRhdGlvbnMsIGV4Y2VwdFxcclxcbiAgICAgICAgICAgIC8vIHRoZSBsZW5ndGhzIG9mIHRoZSBiaXQgbGVuZ3RocyBjb2RlcyBhbmQgdGhlIDUrNSs0IGJpdHMgZm9yIHRoZVxcclxcbiAgICAgICAgICAgIC8vIGNvdW50cy5cXHJcXG5cXHJcXG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIG51bWJlciBvZiBiaXQgbGVuZ3RoIGNvZGVzIHRvIHNlbmQuIFRoZSBwa3ppcCBmb3JtYXRcXHJcXG4gICAgICAgICAgICAvLyByZXF1aXJlcyB0aGF0IGF0IGxlYXN0IDQgYml0IGxlbmd0aCBjb2RlcyBiZSBzZW50LiAoYXBwbm90ZS50eHQgc2F5c1xcclxcbiAgICAgICAgICAgIC8vIDMgYnV0IHRoZSBhY3R1YWwgdmFsdWUgdXNlZCBpcyA0LilcXHJcXG4gICAgICAgICAgICBmb3IgKG1heF9ibGluZGV4ID0gQkxfQ09ERVMgLSAxOyBtYXhfYmxpbmRleCA+PSAzOyBtYXhfYmxpbmRleC0tKSB7XFxyXFxuICAgICAgICAgICAgICAgIGlmIChibF90cmVlW1RyZWUuYmxfb3JkZXJbbWF4X2JsaW5kZXhdICogMiArIDFdICE9PSAwKVxcclxcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBvcHRfbGVuIHRvIGluY2x1ZGUgdGhlIGJpdCBsZW5ndGggdHJlZSBhbmQgY291bnRzXFxyXFxuICAgICAgICAgICAgdGhhdC5vcHRfbGVuICs9IDMgKiAobWF4X2JsaW5kZXggKyAxKSArIDUgKyA1ICsgNDtcXHJcXG5cXHJcXG4gICAgICAgICAgICByZXR1cm4gbWF4X2JsaW5kZXg7XFxyXFxuICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAvLyBPdXRwdXQgYSBieXRlIG9uIHRoZSBzdHJlYW0uXFxyXFxuICAgICAgICAvLyBJTiBhc3NlcnRpb246IHRoZXJlIGlzIGVub3VnaCByb29tIGluIHBlbmRpbmdfYnVmLlxcclxcbiAgICAgICAgZnVuY3Rpb24gcHV0X2J5dGUocCkge1xcclxcbiAgICAgICAgICAgIHRoYXQucGVuZGluZ19idWZbdGhhdC5wZW5kaW5nKytdID0gcDtcXHJcXG4gICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgIGZ1bmN0aW9uIHB1dF9zaG9ydCh3KSB7XFxyXFxuICAgICAgICAgICAgcHV0X2J5dGUodyAmIDB4ZmYpO1xcclxcbiAgICAgICAgICAgIHB1dF9ieXRlKCh3ID4+PiA4KSAmIDB4ZmYpO1xcclxcbiAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgZnVuY3Rpb24gcHV0U2hvcnRNU0IoYikge1xcclxcbiAgICAgICAgICAgIHB1dF9ieXRlKChiID4+IDgpICYgMHhmZik7XFxyXFxuICAgICAgICAgICAgcHV0X2J5dGUoKGIgJiAweGZmKSAmIDB4ZmYpO1xcclxcbiAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgZnVuY3Rpb24gc2VuZF9iaXRzKHZhbHVlLCBsZW5ndGgpIHtcXHJcXG4gICAgICAgICAgICB2YXIgdmFsLCBsZW4gPSBsZW5ndGg7XFxyXFxuICAgICAgICAgICAgaWYgKGJpX3ZhbGlkID4gQnVmX3NpemUgLSBsZW4pIHtcXHJcXG4gICAgICAgICAgICAgICAgdmFsID0gdmFsdWU7XFxyXFxuICAgICAgICAgICAgICAgIC8vIGJpX2J1ZiB8PSAodmFsIDw8IGJpX3ZhbGlkKTtcXHJcXG4gICAgICAgICAgICAgICAgYmlfYnVmIHw9ICgodmFsIDw8IGJpX3ZhbGlkKSAmIDB4ZmZmZik7XFxyXFxuICAgICAgICAgICAgICAgIHB1dF9zaG9ydChiaV9idWYpO1xcclxcbiAgICAgICAgICAgICAgICBiaV9idWYgPSB2YWwgPj4+IChCdWZfc2l6ZSAtIGJpX3ZhbGlkKTtcXHJcXG4gICAgICAgICAgICAgICAgYmlfdmFsaWQgKz0gbGVuIC0gQnVmX3NpemU7XFxyXFxuICAgICAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgICAgICAgLy8gYmlfYnVmIHw9ICh2YWx1ZSkgPDwgYmlfdmFsaWQ7XFxyXFxuICAgICAgICAgICAgICAgIGJpX2J1ZiB8PSAoKCh2YWx1ZSkgPDwgYmlfdmFsaWQpICYgMHhmZmZmKTtcXHJcXG4gICAgICAgICAgICAgICAgYmlfdmFsaWQgKz0gbGVuO1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgIGZ1bmN0aW9uIHNlbmRfY29kZShjLCB0cmVlKSB7XFxyXFxuICAgICAgICAgICAgdmFyIGMyID0gYyAqIDI7XFxyXFxuICAgICAgICAgICAgc2VuZF9iaXRzKHRyZWVbYzJdICYgMHhmZmZmLCB0cmVlW2MyICsgMV0gJiAweGZmZmYpO1xcclxcbiAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgLy8gU2VuZCBhIGxpdGVyYWwgb3IgZGlzdGFuY2UgdHJlZSBpbiBjb21wcmVzc2VkIGZvcm0sIHVzaW5nIHRoZSBjb2RlcyBpblxcclxcbiAgICAgICAgLy8gYmxfdHJlZS5cXHJcXG4gICAgICAgIGZ1bmN0aW9uIHNlbmRfdHJlZSh0cmVlLC8vIHRoZSB0cmVlIHRvIGJlIHNlbnRcXHJcXG4gICAgICAgIG1heF9jb2RlIC8vIGFuZCBpdHMgbGFyZ2VzdCBjb2RlIG9mIG5vbiB6ZXJvIGZyZXF1ZW5jeVxcclxcbiAgICAgICAgKSB7XFxyXFxuICAgICAgICAgICAgdmFyIG47IC8vIGl0ZXJhdGVzIG92ZXIgYWxsIHRyZWUgZWxlbWVudHNcXHJcXG4gICAgICAgICAgICB2YXIgcHJldmxlbiA9IC0xOyAvLyBsYXN0IGVtaXR0ZWQgbGVuZ3RoXFxyXFxuICAgICAgICAgICAgdmFyIGN1cmxlbjsgLy8gbGVuZ3RoIG9mIGN1cnJlbnQgY29kZVxcclxcbiAgICAgICAgICAgIHZhciBuZXh0bGVuID0gdHJlZVswICogMiArIDFdOyAvLyBsZW5ndGggb2YgbmV4dCBjb2RlXFxyXFxuICAgICAgICAgICAgdmFyIGNvdW50ID0gMDsgLy8gcmVwZWF0IGNvdW50IG9mIHRoZSBjdXJyZW50IGNvZGVcXHJcXG4gICAgICAgICAgICB2YXIgbWF4X2NvdW50ID0gNzsgLy8gbWF4IHJlcGVhdCBjb3VudFxcclxcbiAgICAgICAgICAgIHZhciBtaW5fY291bnQgPSA0OyAvLyBtaW4gcmVwZWF0IGNvdW50XFxyXFxuXFxyXFxuICAgICAgICAgICAgaWYgKG5leHRsZW4gPT09IDApIHtcXHJcXG4gICAgICAgICAgICAgICAgbWF4X2NvdW50ID0gMTM4O1xcclxcbiAgICAgICAgICAgICAgICBtaW5fY291bnQgPSAzO1xcclxcbiAgICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICBmb3IgKG4gPSAwOyBuIDw9IG1heF9jb2RlOyBuKyspIHtcXHJcXG4gICAgICAgICAgICAgICAgY3VybGVuID0gbmV4dGxlbjtcXHJcXG4gICAgICAgICAgICAgICAgbmV4dGxlbiA9IHRyZWVbKG4gKyAxKSAqIDIgKyAxXTtcXHJcXG4gICAgICAgICAgICAgICAgaWYgKCsrY291bnQgPCBtYXhfY291bnQgJiYgY3VybGVuID09IG5leHRsZW4pIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcclxcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvdW50IDwgbWluX2NvdW50KSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICBkbyB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VuZF9jb2RlKGN1cmxlbiwgYmxfdHJlZSk7XFxyXFxuICAgICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLWNvdW50ICE9PSAwKTtcXHJcXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJsZW4gIT09IDApIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJsZW4gIT0gcHJldmxlbikge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbmRfY29kZShjdXJsZW4sIGJsX3RyZWUpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50LS07XFxyXFxuICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgICAgICBzZW5kX2NvZGUoUkVQXzNfNiwgYmxfdHJlZSk7XFxyXFxuICAgICAgICAgICAgICAgICAgICBzZW5kX2JpdHMoY291bnQgLSAzLCAyKTtcXHJcXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb3VudCA8PSAxMCkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgc2VuZF9jb2RlKFJFUFpfM18xMCwgYmxfdHJlZSk7XFxyXFxuICAgICAgICAgICAgICAgICAgICBzZW5kX2JpdHMoY291bnQgLSAzLCAzKTtcXHJcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHNlbmRfY29kZShSRVBaXzExXzEzOCwgYmxfdHJlZSk7XFxyXFxuICAgICAgICAgICAgICAgICAgICBzZW5kX2JpdHMoY291bnQgLSAxMSwgNyk7XFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgY291bnQgPSAwO1xcclxcbiAgICAgICAgICAgICAgICBwcmV2bGVuID0gY3VybGVuO1xcclxcbiAgICAgICAgICAgICAgICBpZiAobmV4dGxlbiA9PT0gMCkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgbWF4X2NvdW50ID0gMTM4O1xcclxcbiAgICAgICAgICAgICAgICAgICAgbWluX2NvdW50ID0gMztcXHJcXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJsZW4gPT0gbmV4dGxlbikge1xcclxcbiAgICAgICAgICAgICAgICAgICAgbWF4X2NvdW50ID0gNjtcXHJcXG4gICAgICAgICAgICAgICAgICAgIG1pbl9jb3VudCA9IDM7XFxyXFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICBtYXhfY291bnQgPSA3O1xcclxcbiAgICAgICAgICAgICAgICAgICAgbWluX2NvdW50ID0gNDtcXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgIC8vIFNlbmQgdGhlIGhlYWRlciBmb3IgYSBibG9jayB1c2luZyBkeW5hbWljIEh1ZmZtYW4gdHJlZXM6IHRoZSBjb3VudHMsIHRoZVxcclxcbiAgICAgICAgLy8gbGVuZ3RocyBvZiB0aGUgYml0IGxlbmd0aCBjb2RlcywgdGhlIGxpdGVyYWwgdHJlZSBhbmQgdGhlIGRpc3RhbmNlIHRyZWUuXFxyXFxuICAgICAgICAvLyBJTiBhc3NlcnRpb246IGxjb2RlcyA+PSAyNTcsIGRjb2RlcyA+PSAxLCBibGNvZGVzID49IDQuXFxyXFxuICAgICAgICBmdW5jdGlvbiBzZW5kX2FsbF90cmVlcyhsY29kZXMsIGRjb2RlcywgYmxjb2Rlcykge1xcclxcbiAgICAgICAgICAgIHZhciByYW5rOyAvLyBpbmRleCBpbiBibF9vcmRlclxcclxcblxcclxcbiAgICAgICAgICAgIHNlbmRfYml0cyhsY29kZXMgLSAyNTcsIDUpOyAvLyBub3QgKzI1NSBhcyBzdGF0ZWQgaW4gYXBwbm90ZS50eHRcXHJcXG4gICAgICAgICAgICBzZW5kX2JpdHMoZGNvZGVzIC0gMSwgNSk7XFxyXFxuICAgICAgICAgICAgc2VuZF9iaXRzKGJsY29kZXMgLSA0LCA0KTsgLy8gbm90IC0zIGFzIHN0YXRlZCBpbiBhcHBub3RlLnR4dFxcclxcbiAgICAgICAgICAgIGZvciAocmFuayA9IDA7IHJhbmsgPCBibGNvZGVzOyByYW5rKyspIHtcXHJcXG4gICAgICAgICAgICAgICAgc2VuZF9iaXRzKGJsX3RyZWVbVHJlZS5ibF9vcmRlcltyYW5rXSAqIDIgKyAxXSwgMyk7XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIHNlbmRfdHJlZShkeW5fbHRyZWUsIGxjb2RlcyAtIDEpOyAvLyBsaXRlcmFsIHRyZWVcXHJcXG4gICAgICAgICAgICBzZW5kX3RyZWUoZHluX2R0cmVlLCBkY29kZXMgLSAxKTsgLy8gZGlzdGFuY2UgdHJlZVxcclxcbiAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgLy8gRmx1c2ggdGhlIGJpdCBidWZmZXIsIGtlZXBpbmcgYXQgbW9zdCA3IGJpdHMgaW4gaXQuXFxyXFxuICAgICAgICBmdW5jdGlvbiBiaV9mbHVzaCgpIHtcXHJcXG4gICAgICAgICAgICBpZiAoYmlfdmFsaWQgPT0gMTYpIHtcXHJcXG4gICAgICAgICAgICAgICAgcHV0X3Nob3J0KGJpX2J1Zik7XFxyXFxuICAgICAgICAgICAgICAgIGJpX2J1ZiA9IDA7XFxyXFxuICAgICAgICAgICAgICAgIGJpX3ZhbGlkID0gMDtcXHJcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGJpX3ZhbGlkID49IDgpIHtcXHJcXG4gICAgICAgICAgICAgICAgcHV0X2J5dGUoYmlfYnVmICYgMHhmZik7XFxyXFxuICAgICAgICAgICAgICAgIGJpX2J1ZiA+Pj49IDg7XFxyXFxuICAgICAgICAgICAgICAgIGJpX3ZhbGlkIC09IDg7XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgLy8gU2VuZCBvbmUgZW1wdHkgc3RhdGljIGJsb2NrIHRvIGdpdmUgZW5vdWdoIGxvb2thaGVhZCBmb3IgaW5mbGF0ZS5cXHJcXG4gICAgICAgIC8vIFRoaXMgdGFrZXMgMTAgYml0cywgb2Ygd2hpY2ggNyBtYXkgcmVtYWluIGluIHRoZSBiaXQgYnVmZmVyLlxcclxcbiAgICAgICAgLy8gVGhlIGN1cnJlbnQgaW5mbGF0ZSBjb2RlIHJlcXVpcmVzIDkgYml0cyBvZiBsb29rYWhlYWQuIElmIHRoZVxcclxcbiAgICAgICAgLy8gbGFzdCB0d28gY29kZXMgZm9yIHRoZSBwcmV2aW91cyBibG9jayAocmVhbCBjb2RlIHBsdXMgRU9CKSB3ZXJlIGNvZGVkXFxyXFxuICAgICAgICAvLyBvbiA1IGJpdHMgb3IgbGVzcywgaW5mbGF0ZSBtYXkgaGF2ZSBvbmx5IDUrMyBiaXRzIG9mIGxvb2thaGVhZCB0byBkZWNvZGVcXHJcXG4gICAgICAgIC8vIHRoZSBsYXN0IHJlYWwgY29kZS4gSW4gdGhpcyBjYXNlIHdlIHNlbmQgdHdvIGVtcHR5IHN0YXRpYyBibG9ja3MgaW5zdGVhZFxcclxcbiAgICAgICAgLy8gb2Ygb25lLiAoVGhlcmUgYXJlIG5vIHByb2JsZW1zIGlmIHRoZSBwcmV2aW91cyBibG9jayBpcyBzdG9yZWQgb3IgZml4ZWQuKVxcclxcbiAgICAgICAgLy8gVG8gc2ltcGxpZnkgdGhlIGNvZGUsIHdlIGFzc3VtZSB0aGUgd29yc3QgY2FzZSBvZiBsYXN0IHJlYWwgY29kZSBlbmNvZGVkXFxyXFxuICAgICAgICAvLyBvbiBvbmUgYml0IG9ubHkuXFxyXFxuICAgICAgICBmdW5jdGlvbiBfdHJfYWxpZ24oKSB7XFxyXFxuICAgICAgICAgICAgc2VuZF9iaXRzKFNUQVRJQ19UUkVFUyA8PCAxLCAzKTtcXHJcXG4gICAgICAgICAgICBzZW5kX2NvZGUoRU5EX0JMT0NLLCBTdGF0aWNUcmVlLnN0YXRpY19sdHJlZSk7XFxyXFxuXFxyXFxuICAgICAgICAgICAgYmlfZmx1c2goKTtcXHJcXG5cXHJcXG4gICAgICAgICAgICAvLyBPZiB0aGUgMTAgYml0cyBmb3IgdGhlIGVtcHR5IGJsb2NrLCB3ZSBoYXZlIGFscmVhZHkgc2VudFxcclxcbiAgICAgICAgICAgIC8vICgxMCAtIGJpX3ZhbGlkKSBiaXRzLiBUaGUgbG9va2FoZWFkIGZvciB0aGUgbGFzdCByZWFsIGNvZGUgKGJlZm9yZVxcclxcbiAgICAgICAgICAgIC8vIHRoZSBFT0Igb2YgdGhlIHByZXZpb3VzIGJsb2NrKSB3YXMgdGh1cyBhdCBsZWFzdCBvbmUgcGx1cyB0aGUgbGVuZ3RoXFxyXFxuICAgICAgICAgICAgLy8gb2YgdGhlIEVPQiBwbHVzIHdoYXQgd2UgaGF2ZSBqdXN0IHNlbnQgb2YgdGhlIGVtcHR5IHN0YXRpYyBibG9jay5cXHJcXG4gICAgICAgICAgICBpZiAoMSArIGxhc3RfZW9iX2xlbiArIDEwIC0gYmlfdmFsaWQgPCA5KSB7XFxyXFxuICAgICAgICAgICAgICAgIHNlbmRfYml0cyhTVEFUSUNfVFJFRVMgPDwgMSwgMyk7XFxyXFxuICAgICAgICAgICAgICAgIHNlbmRfY29kZShFTkRfQkxPQ0ssIFN0YXRpY1RyZWUuc3RhdGljX2x0cmVlKTtcXHJcXG4gICAgICAgICAgICAgICAgYmlfZmx1c2goKTtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgbGFzdF9lb2JfbGVuID0gNztcXHJcXG4gICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgIC8vIFNhdmUgdGhlIG1hdGNoIGluZm8gYW5kIHRhbGx5IHRoZSBmcmVxdWVuY3kgY291bnRzLiBSZXR1cm4gdHJ1ZSBpZlxcclxcbiAgICAgICAgLy8gdGhlIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkLlxcclxcbiAgICAgICAgZnVuY3Rpb24gX3RyX3RhbGx5KGRpc3QsIC8vIGRpc3RhbmNlIG9mIG1hdGNoZWQgc3RyaW5nXFxyXFxuICAgICAgICBsYyAvLyBtYXRjaCBsZW5ndGgtTUlOX01BVENIIG9yIHVubWF0Y2hlZCBjaGFyIChpZiBkaXN0PT0wKVxcclxcbiAgICAgICAgKSB7XFxyXFxuICAgICAgICAgICAgdmFyIG91dF9sZW5ndGgsIGluX2xlbmd0aCwgZGNvZGU7XFxyXFxuICAgICAgICAgICAgdGhhdC5wZW5kaW5nX2J1ZltkX2J1ZiArIGxhc3RfbGl0ICogMl0gPSAoZGlzdCA+Pj4gOCkgJiAweGZmO1xcclxcbiAgICAgICAgICAgIHRoYXQucGVuZGluZ19idWZbZF9idWYgKyBsYXN0X2xpdCAqIDIgKyAxXSA9IGRpc3QgJiAweGZmO1xcclxcblxcclxcbiAgICAgICAgICAgIHRoYXQucGVuZGluZ19idWZbbF9idWYgKyBsYXN0X2xpdF0gPSBsYyAmIDB4ZmY7XFxyXFxuICAgICAgICAgICAgbGFzdF9saXQrKztcXHJcXG5cXHJcXG4gICAgICAgICAgICBpZiAoZGlzdCA9PT0gMCkge1xcclxcbiAgICAgICAgICAgICAgICAvLyBsYyBpcyB0aGUgdW5tYXRjaGVkIGNoYXJcXHJcXG4gICAgICAgICAgICAgICAgZHluX2x0cmVlW2xjICogMl0rKztcXHJcXG4gICAgICAgICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgICAgICAgICBtYXRjaGVzKys7XFxyXFxuICAgICAgICAgICAgICAgIC8vIEhlcmUsIGxjIGlzIHRoZSBtYXRjaCBsZW5ndGggLSBNSU5fTUFUQ0hcXHJcXG4gICAgICAgICAgICAgICAgZGlzdC0tOyAvLyBkaXN0ID0gbWF0Y2ggZGlzdGFuY2UgLSAxXFxyXFxuICAgICAgICAgICAgICAgIGR5bl9sdHJlZVsoVHJlZS5fbGVuZ3RoX2NvZGVbbGNdICsgTElURVJBTFMgKyAxKSAqIDJdKys7XFxyXFxuICAgICAgICAgICAgICAgIGR5bl9kdHJlZVtUcmVlLmRfY29kZShkaXN0KSAqIDJdKys7XFxyXFxuICAgICAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgICAgIGlmICgobGFzdF9saXQgJiAweDFmZmYpID09PSAwICYmIGxldmVsID4gMikge1xcclxcbiAgICAgICAgICAgICAgICAvLyBDb21wdXRlIGFuIHVwcGVyIGJvdW5kIGZvciB0aGUgY29tcHJlc3NlZCBsZW5ndGhcXHJcXG4gICAgICAgICAgICAgICAgb3V0X2xlbmd0aCA9IGxhc3RfbGl0ICogODtcXHJcXG4gICAgICAgICAgICAgICAgaW5fbGVuZ3RoID0gc3Ryc3RhcnQgLSBibG9ja19zdGFydDtcXHJcXG4gICAgICAgICAgICAgICAgZm9yIChkY29kZSA9IDA7IGRjb2RlIDwgRF9DT0RFUzsgZGNvZGUrKykge1xcclxcbiAgICAgICAgICAgICAgICAgICAgb3V0X2xlbmd0aCArPSBkeW5fZHRyZWVbZGNvZGUgKiAyXSAqICg1ICsgVHJlZS5leHRyYV9kYml0c1tkY29kZV0pO1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgIG91dF9sZW5ndGggPj4+PSAzO1xcclxcbiAgICAgICAgICAgICAgICBpZiAoKG1hdGNoZXMgPCBNYXRoLmZsb29yKGxhc3RfbGl0IC8gMikpICYmIG91dF9sZW5ndGggPCBNYXRoLmZsb29yKGluX2xlbmd0aCAvIDIpKVxcclxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XFxyXFxuICAgICAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgICAgIHJldHVybiAobGFzdF9saXQgPT0gbGl0X2J1ZnNpemUgLSAxKTtcXHJcXG4gICAgICAgICAgICAvLyBXZSBhdm9pZCBlcXVhbGl0eSB3aXRoIGxpdF9idWZzaXplIGJlY2F1c2Ugb2Ygd3JhcGFyb3VuZCBhdCA2NEtcXHJcXG4gICAgICAgICAgICAvLyBvbiAxNiBiaXQgbWFjaGluZXMgYW5kIGJlY2F1c2Ugc3RvcmVkIGJsb2NrcyBhcmUgcmVzdHJpY3RlZCB0b1xcclxcbiAgICAgICAgICAgIC8vIDY0Sy0xIGJ5dGVzLlxcclxcbiAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgLy8gU2VuZCB0aGUgYmxvY2sgZGF0YSBjb21wcmVzc2VkIHVzaW5nIHRoZSBnaXZlbiBIdWZmbWFuIHRyZWVzXFxyXFxuICAgICAgICBmdW5jdGlvbiBjb21wcmVzc19ibG9jayhsdHJlZSwgZHRyZWUpIHtcXHJcXG4gICAgICAgICAgICB2YXIgZGlzdDsgLy8gZGlzdGFuY2Ugb2YgbWF0Y2hlZCBzdHJpbmdcXHJcXG4gICAgICAgICAgICB2YXIgbGM7IC8vIG1hdGNoIGxlbmd0aCBvciB1bm1hdGNoZWQgY2hhciAoaWYgZGlzdCA9PT0gMClcXHJcXG4gICAgICAgICAgICB2YXIgbHggPSAwOyAvLyBydW5uaW5nIGluZGV4IGluIGxfYnVmXFxyXFxuICAgICAgICAgICAgdmFyIGNvZGU7IC8vIHRoZSBjb2RlIHRvIHNlbmRcXHJcXG4gICAgICAgICAgICB2YXIgZXh0cmE7IC8vIG51bWJlciBvZiBleHRyYSBiaXRzIHRvIHNlbmRcXHJcXG5cXHJcXG4gICAgICAgICAgICBpZiAobGFzdF9saXQgIT09IDApIHtcXHJcXG4gICAgICAgICAgICAgICAgZG8ge1xcclxcbiAgICAgICAgICAgICAgICAgICAgZGlzdCA9ICgodGhhdC5wZW5kaW5nX2J1ZltkX2J1ZiArIGx4ICogMl0gPDwgOCkgJiAweGZmMDApIHwgKHRoYXQucGVuZGluZ19idWZbZF9idWYgKyBseCAqIDIgKyAxXSAmIDB4ZmYpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgbGMgPSAodGhhdC5wZW5kaW5nX2J1ZltsX2J1ZiArIGx4XSkgJiAweGZmO1xcclxcbiAgICAgICAgICAgICAgICAgICAgbHgrKztcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgIGlmIChkaXN0ID09PSAwKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VuZF9jb2RlKGxjLCBsdHJlZSk7IC8vIHNlbmQgYSBsaXRlcmFsIGJ5dGVcXHJcXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGVyZSwgbGMgaXMgdGhlIG1hdGNoIGxlbmd0aCAtIE1JTl9NQVRDSFxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUgPSBUcmVlLl9sZW5ndGhfY29kZVtsY107XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VuZF9jb2RlKGNvZGUgKyBMSVRFUkFMUyArIDEsIGx0cmVlKTsgLy8gc2VuZCB0aGUgbGVuZ3RoXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29kZVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhID0gVHJlZS5leHRyYV9sYml0c1tjb2RlXTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXh0cmEgIT09IDApIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGMgLT0gVHJlZS5iYXNlX2xlbmd0aFtjb2RlXTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VuZF9iaXRzKGxjLCBleHRyYSk7IC8vIHNlbmQgdGhlIGV4dHJhIGxlbmd0aCBiaXRzXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3QtLTsgLy8gZGlzdCBpcyBub3cgdGhlIG1hdGNoIGRpc3RhbmNlIC0gMVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUgPSBUcmVlLmRfY29kZShkaXN0KTtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBzZW5kX2NvZGUoY29kZSwgZHRyZWUpOyAvLyBzZW5kIHRoZSBkaXN0YW5jZSBjb2RlXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmEgPSBUcmVlLmV4dHJhX2RiaXRzW2NvZGVdO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHRyYSAhPT0gMCkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXN0IC09IFRyZWUuYmFzZV9kaXN0W2NvZGVdO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZW5kX2JpdHMoZGlzdCwgZXh0cmEpOyAvLyBzZW5kIHRoZSBleHRyYSBkaXN0YW5jZSBiaXRzXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICAgICAgfSAvLyBsaXRlcmFsIG9yIG1hdGNoIHBhaXIgP1xcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgdGhhdCB0aGUgb3ZlcmxheSBiZXR3ZWVuIHBlbmRpbmdfYnVmIGFuZCBkX2J1ZitsX2J1ZiBpc1xcclxcbiAgICAgICAgICAgICAgICAgICAgLy8gb2s6XFxyXFxuICAgICAgICAgICAgICAgIH0gd2hpbGUgKGx4IDwgbGFzdF9saXQpO1xcclxcbiAgICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICBzZW5kX2NvZGUoRU5EX0JMT0NLLCBsdHJlZSk7XFxyXFxuICAgICAgICAgICAgbGFzdF9lb2JfbGVuID0gbHRyZWVbRU5EX0JMT0NLICogMiArIDFdO1xcclxcbiAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgLy8gRmx1c2ggdGhlIGJpdCBidWZmZXIgYW5kIGFsaWduIHRoZSBvdXRwdXQgb24gYSBieXRlIGJvdW5kYXJ5XFxyXFxuICAgICAgICBmdW5jdGlvbiBiaV93aW5kdXAoKSB7XFxyXFxuICAgICAgICAgICAgaWYgKGJpX3ZhbGlkID4gOCkge1xcclxcbiAgICAgICAgICAgICAgICBwdXRfc2hvcnQoYmlfYnVmKTtcXHJcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGJpX3ZhbGlkID4gMCkge1xcclxcbiAgICAgICAgICAgICAgICBwdXRfYnl0ZShiaV9idWYgJiAweGZmKTtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgYmlfYnVmID0gMDtcXHJcXG4gICAgICAgICAgICBiaV92YWxpZCA9IDA7XFxyXFxuICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAvLyBDb3B5IGEgc3RvcmVkIGJsb2NrLCBzdG9yaW5nIGZpcnN0IHRoZSBsZW5ndGggYW5kIGl0c1xcclxcbiAgICAgICAgLy8gb25lJ3MgY29tcGxlbWVudCBpZiByZXF1ZXN0ZWQuXFxyXFxuICAgICAgICBmdW5jdGlvbiBjb3B5X2Jsb2NrKGJ1ZiwgLy8gdGhlIGlucHV0IGRhdGFcXHJcXG4gICAgICAgIGxlbiwgLy8gaXRzIGxlbmd0aFxcclxcbiAgICAgICAgaGVhZGVyIC8vIHRydWUgaWYgYmxvY2sgaGVhZGVyIG11c3QgYmUgd3JpdHRlblxcclxcbiAgICAgICAgKSB7XFxyXFxuICAgICAgICAgICAgYmlfd2luZHVwKCk7IC8vIGFsaWduIG9uIGJ5dGUgYm91bmRhcnlcXHJcXG4gICAgICAgICAgICBsYXN0X2VvYl9sZW4gPSA4OyAvLyBlbm91Z2ggbG9va2FoZWFkIGZvciBpbmZsYXRlXFxyXFxuXFxyXFxuICAgICAgICAgICAgaWYgKGhlYWRlcikge1xcclxcbiAgICAgICAgICAgICAgICBwdXRfc2hvcnQobGVuKTtcXHJcXG4gICAgICAgICAgICAgICAgcHV0X3Nob3J0KH5sZW4pO1xcclxcbiAgICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICB0aGF0LnBlbmRpbmdfYnVmLnNldCh3aW5kb3cuc3ViYXJyYXkoYnVmLCBidWYgKyBsZW4pLCB0aGF0LnBlbmRpbmcpO1xcclxcbiAgICAgICAgICAgIHRoYXQucGVuZGluZyArPSBsZW47XFxyXFxuICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAvLyBTZW5kIGEgc3RvcmVkIGJsb2NrXFxyXFxuICAgICAgICBmdW5jdGlvbiBfdHJfc3RvcmVkX2Jsb2NrKGJ1ZiwgLy8gaW5wdXQgYmxvY2tcXHJcXG4gICAgICAgIHN0b3JlZF9sZW4sIC8vIGxlbmd0aCBvZiBpbnB1dCBibG9ja1xcclxcbiAgICAgICAgZW9mIC8vIHRydWUgaWYgdGhpcyBpcyB0aGUgbGFzdCBibG9jayBmb3IgYSBmaWxlXFxyXFxuICAgICAgICApIHtcXHJcXG4gICAgICAgICAgICBzZW5kX2JpdHMoKFNUT1JFRF9CTE9DSyA8PCAxKSArIChlb2YgPyAxIDogMCksIDMpOyAvLyBzZW5kIGJsb2NrIHR5cGVcXHJcXG4gICAgICAgICAgICBjb3B5X2Jsb2NrKGJ1Ziwgc3RvcmVkX2xlbiwgdHJ1ZSk7IC8vIHdpdGggaGVhZGVyXFxyXFxuICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIGJlc3QgZW5jb2RpbmcgZm9yIHRoZSBjdXJyZW50IGJsb2NrOiBkeW5hbWljIHRyZWVzLCBzdGF0aWNcXHJcXG4gICAgICAgIC8vIHRyZWVzIG9yIHN0b3JlLCBhbmQgb3V0cHV0IHRoZSBlbmNvZGVkIGJsb2NrIHRvIHRoZSB6aXAgZmlsZS5cXHJcXG4gICAgICAgIGZ1bmN0aW9uIF90cl9mbHVzaF9ibG9jayhidWYsIC8vIGlucHV0IGJsb2NrLCBvciBOVUxMIGlmIHRvbyBvbGRcXHJcXG4gICAgICAgIHN0b3JlZF9sZW4sIC8vIGxlbmd0aCBvZiBpbnB1dCBibG9ja1xcclxcbiAgICAgICAgZW9mIC8vIHRydWUgaWYgdGhpcyBpcyB0aGUgbGFzdCBibG9jayBmb3IgYSBmaWxlXFxyXFxuICAgICAgICApIHtcXHJcXG4gICAgICAgICAgICB2YXIgb3B0X2xlbmIsIHN0YXRpY19sZW5iOy8vIG9wdF9sZW4gYW5kIHN0YXRpY19sZW4gaW4gYnl0ZXNcXHJcXG4gICAgICAgICAgICB2YXIgbWF4X2JsaW5kZXggPSAwOyAvLyBpbmRleCBvZiBsYXN0IGJpdCBsZW5ndGggY29kZSBvZiBub24gemVybyBmcmVxXFxyXFxuXFxyXFxuICAgICAgICAgICAgLy8gQnVpbGQgdGhlIEh1ZmZtYW4gdHJlZXMgdW5sZXNzIGEgc3RvcmVkIGJsb2NrIGlzIGZvcmNlZFxcclxcbiAgICAgICAgICAgIGlmIChsZXZlbCA+IDApIHtcXHJcXG4gICAgICAgICAgICAgICAgLy8gQ29uc3RydWN0IHRoZSBsaXRlcmFsIGFuZCBkaXN0YW5jZSB0cmVlc1xcclxcbiAgICAgICAgICAgICAgICBsX2Rlc2MuYnVpbGRfdHJlZSh0aGF0KTtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgZF9kZXNjLmJ1aWxkX3RyZWUodGhhdCk7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgIC8vIEF0IHRoaXMgcG9pbnQsIG9wdF9sZW4gYW5kIHN0YXRpY19sZW4gYXJlIHRoZSB0b3RhbCBiaXQgbGVuZ3Roc1xcclxcbiAgICAgICAgICAgICAgICAvLyBvZlxcclxcbiAgICAgICAgICAgICAgICAvLyB0aGUgY29tcHJlc3NlZCBibG9jayBkYXRhLCBleGNsdWRpbmcgdGhlIHRyZWUgcmVwcmVzZW50YXRpb25zLlxcclxcblxcclxcbiAgICAgICAgICAgICAgICAvLyBCdWlsZCB0aGUgYml0IGxlbmd0aCB0cmVlIGZvciB0aGUgYWJvdmUgdHdvIHRyZWVzLCBhbmQgZ2V0IHRoZVxcclxcbiAgICAgICAgICAgICAgICAvLyBpbmRleFxcclxcbiAgICAgICAgICAgICAgICAvLyBpbiBibF9vcmRlciBvZiB0aGUgbGFzdCBiaXQgbGVuZ3RoIGNvZGUgdG8gc2VuZC5cXHJcXG4gICAgICAgICAgICAgICAgbWF4X2JsaW5kZXggPSBidWlsZF9ibF90cmVlKCk7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgIC8vIERldGVybWluZSB0aGUgYmVzdCBlbmNvZGluZy4gQ29tcHV0ZSBmaXJzdCB0aGUgYmxvY2sgbGVuZ3RoIGluXFxyXFxuICAgICAgICAgICAgICAgIC8vIGJ5dGVzXFxyXFxuICAgICAgICAgICAgICAgIG9wdF9sZW5iID0gKHRoYXQub3B0X2xlbiArIDMgKyA3KSA+Pj4gMztcXHJcXG4gICAgICAgICAgICAgICAgc3RhdGljX2xlbmIgPSAodGhhdC5zdGF0aWNfbGVuICsgMyArIDcpID4+PiAzO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGljX2xlbmIgPD0gb3B0X2xlbmIpXFxyXFxuICAgICAgICAgICAgICAgICAgICBvcHRfbGVuYiA9IHN0YXRpY19sZW5iO1xcclxcbiAgICAgICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgICAgICAgIG9wdF9sZW5iID0gc3RhdGljX2xlbmIgPSBzdG9yZWRfbGVuICsgNTsgLy8gZm9yY2UgYSBzdG9yZWQgYmxvY2tcXHJcXG4gICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgaWYgKChzdG9yZWRfbGVuICsgNCA8PSBvcHRfbGVuYikgJiYgYnVmICE9IC0xKSB7XFxyXFxuICAgICAgICAgICAgICAgIC8vIDQ6IHR3byB3b3JkcyBmb3IgdGhlIGxlbmd0aHNcXHJcXG4gICAgICAgICAgICAgICAgLy8gVGhlIHRlc3QgYnVmICE9IE5VTEwgaXMgb25seSBuZWNlc3NhcnkgaWYgTElUX0JVRlNJWkUgPiBXU0laRS5cXHJcXG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIHdlIGNhbid0IGhhdmUgcHJvY2Vzc2VkIG1vcmUgdGhhbiBXU0laRSBpbnB1dCBieXRlc1xcclxcbiAgICAgICAgICAgICAgICAvLyBzaW5jZVxcclxcbiAgICAgICAgICAgICAgICAvLyB0aGUgbGFzdCBibG9jayBmbHVzaCwgYmVjYXVzZSBjb21wcmVzc2lvbiB3b3VsZCBoYXZlIGJlZW5cXHJcXG4gICAgICAgICAgICAgICAgLy8gc3VjY2Vzc2Z1bC4gSWYgTElUX0JVRlNJWkUgPD0gV1NJWkUsIGl0IGlzIG5ldmVyIHRvbyBsYXRlIHRvXFxyXFxuICAgICAgICAgICAgICAgIC8vIHRyYW5zZm9ybSBhIGJsb2NrIGludG8gYSBzdG9yZWQgYmxvY2suXFxyXFxuICAgICAgICAgICAgICAgIF90cl9zdG9yZWRfYmxvY2soYnVmLCBzdG9yZWRfbGVuLCBlb2YpO1xcclxcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdGljX2xlbmIgPT0gb3B0X2xlbmIpIHtcXHJcXG4gICAgICAgICAgICAgICAgc2VuZF9iaXRzKChTVEFUSUNfVFJFRVMgPDwgMSkgKyAoZW9mID8gMSA6IDApLCAzKTtcXHJcXG4gICAgICAgICAgICAgICAgY29tcHJlc3NfYmxvY2soU3RhdGljVHJlZS5zdGF0aWNfbHRyZWUsIFN0YXRpY1RyZWUuc3RhdGljX2R0cmVlKTtcXHJcXG4gICAgICAgICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgICAgICAgICBzZW5kX2JpdHMoKERZTl9UUkVFUyA8PCAxKSArIChlb2YgPyAxIDogMCksIDMpO1xcclxcbiAgICAgICAgICAgICAgICBzZW5kX2FsbF90cmVlcyhsX2Rlc2MubWF4X2NvZGUgKyAxLCBkX2Rlc2MubWF4X2NvZGUgKyAxLCBtYXhfYmxpbmRleCArIDEpO1xcclxcbiAgICAgICAgICAgICAgICBjb21wcmVzc19ibG9jayhkeW5fbHRyZWUsIGR5bl9kdHJlZSk7XFxyXFxuICAgICAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgICAgIC8vIFRoZSBhYm92ZSBjaGVjayBpcyBtYWRlIG1vZCAyXjMyLCBmb3IgZmlsZXMgbGFyZ2VyIHRoYW4gNTEyIE1CXFxyXFxuICAgICAgICAgICAgLy8gYW5kIHVMb25nIGltcGxlbWVudGVkIG9uIDMyIGJpdHMuXFxyXFxuXFxyXFxuICAgICAgICAgICAgaW5pdF9ibG9jaygpO1xcclxcblxcclxcbiAgICAgICAgICAgIGlmIChlb2YpIHtcXHJcXG4gICAgICAgICAgICAgICAgYmlfd2luZHVwKCk7XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgZnVuY3Rpb24gZmx1c2hfYmxvY2tfb25seShlb2YpIHtcXHJcXG4gICAgICAgICAgICBfdHJfZmx1c2hfYmxvY2soYmxvY2tfc3RhcnQgPj0gMCA/IGJsb2NrX3N0YXJ0IDogLTEsIHN0cnN0YXJ0IC0gYmxvY2tfc3RhcnQsIGVvZik7XFxyXFxuICAgICAgICAgICAgYmxvY2tfc3RhcnQgPSBzdHJzdGFydDtcXHJcXG4gICAgICAgICAgICBzdHJtLmZsdXNoX3BlbmRpbmcoKTtcXHJcXG4gICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgIC8vIEZpbGwgdGhlIHdpbmRvdyB3aGVuIHRoZSBsb29rYWhlYWQgYmVjb21lcyBpbnN1ZmZpY2llbnQuXFxyXFxuICAgICAgICAvLyBVcGRhdGVzIHN0cnN0YXJ0IGFuZCBsb29rYWhlYWQuXFxyXFxuICAgICAgICAvL1xcclxcbiAgICAgICAgLy8gSU4gYXNzZXJ0aW9uOiBsb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEXFxyXFxuICAgICAgICAvLyBPVVQgYXNzZXJ0aW9uczogc3Ryc3RhcnQgPD0gd2luZG93X3NpemUtTUlOX0xPT0tBSEVBRFxcclxcbiAgICAgICAgLy8gQXQgbGVhc3Qgb25lIGJ5dGUgaGFzIGJlZW4gcmVhZCwgb3IgYXZhaWxfaW4gPT09IDA7IHJlYWRzIGFyZVxcclxcbiAgICAgICAgLy8gcGVyZm9ybWVkIGZvciBhdCBsZWFzdCB0d28gYnl0ZXMgKHJlcXVpcmVkIGZvciB0aGUgemlwIHRyYW5zbGF0ZV9lb2xcXHJcXG4gICAgICAgIC8vIG9wdGlvbiAtLSBub3Qgc3VwcG9ydGVkIGhlcmUpLlxcclxcbiAgICAgICAgZnVuY3Rpb24gZmlsbF93aW5kb3coKSB7XFxyXFxuICAgICAgICAgICAgdmFyIG4sIG07XFxyXFxuICAgICAgICAgICAgdmFyIHA7XFxyXFxuICAgICAgICAgICAgdmFyIG1vcmU7IC8vIEFtb3VudCBvZiBmcmVlIHNwYWNlIGF0IHRoZSBlbmQgb2YgdGhlIHdpbmRvdy5cXHJcXG5cXHJcXG4gICAgICAgICAgICBkbyB7XFxyXFxuICAgICAgICAgICAgICAgIG1vcmUgPSAod2luZG93X3NpemUgLSBsb29rYWhlYWQgLSBzdHJzdGFydCk7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgIC8vIERlYWwgd2l0aCAhQCMkJSA2NEsgbGltaXQ6XFxyXFxuICAgICAgICAgICAgICAgIGlmIChtb3JlID09PSAwICYmIHN0cnN0YXJ0ID09PSAwICYmIGxvb2thaGVhZCA9PT0gMCkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgbW9yZSA9IHdfc2l6ZTtcXHJcXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtb3JlID09IC0xKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAvLyBWZXJ5IHVubGlrZWx5LCBidXQgcG9zc2libGUgb24gMTYgYml0IG1hY2hpbmUgaWYgc3Ryc3RhcnQgPT1cXHJcXG4gICAgICAgICAgICAgICAgICAgIC8vIDBcXHJcXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCBsb29rYWhlYWQgPT0gMSAoaW5wdXQgZG9uZSBvbmUgYnl0ZSBhdCB0aW1lKVxcclxcbiAgICAgICAgICAgICAgICAgICAgbW9yZS0tO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHdpbmRvdyBpcyBhbG1vc3QgZnVsbCBhbmQgdGhlcmUgaXMgaW5zdWZmaWNpZW50XFxyXFxuICAgICAgICAgICAgICAgICAgICAvLyBsb29rYWhlYWQsXFxyXFxuICAgICAgICAgICAgICAgICAgICAvLyBtb3ZlIHRoZSB1cHBlciBoYWxmIHRvIHRoZSBsb3dlciBvbmUgdG8gbWFrZSByb29tIGluIHRoZVxcclxcbiAgICAgICAgICAgICAgICAgICAgLy8gdXBwZXIgaGFsZi5cXHJcXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdHJzdGFydCA+PSB3X3NpemUgKyB3X3NpemUgLSBNSU5fTE9PS0FIRUFEKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuc2V0KHdpbmRvdy5zdWJhcnJheSh3X3NpemUsIHdfc2l6ZSArIHdfc2l6ZSksIDApO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hfc3RhcnQgLT0gd19zaXplO1xcclxcbiAgICAgICAgICAgICAgICAgICAgc3Ryc3RhcnQgLT0gd19zaXplOyAvLyB3ZSBub3cgaGF2ZSBzdHJzdGFydCA+PSBNQVhfRElTVFxcclxcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tfc3RhcnQgLT0gd19zaXplO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgLy8gU2xpZGUgdGhlIGhhc2ggdGFibGUgKGNvdWxkIGJlIGF2b2lkZWQgd2l0aCAzMiBiaXQgdmFsdWVzXFxyXFxuICAgICAgICAgICAgICAgICAgICAvLyBhdCB0aGUgZXhwZW5zZSBvZiBtZW1vcnkgdXNhZ2UpLiBXZSBzbGlkZSBldmVuIHdoZW4gbGV2ZWwgPT1cXHJcXG4gICAgICAgICAgICAgICAgICAgIC8vIDBcXHJcXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIGtlZXAgdGhlIGhhc2ggdGFibGUgY29uc2lzdGVudCBpZiB3ZSBzd2l0Y2ggYmFjayB0byBsZXZlbFxcclxcbiAgICAgICAgICAgICAgICAgICAgLy8gPiAwXFxyXFxuICAgICAgICAgICAgICAgICAgICAvLyBsYXRlci4gKFVzaW5nIGxldmVsIDAgcGVybWFuZW50bHkgaXMgbm90IGFuIG9wdGltYWwgdXNhZ2Ugb2ZcXHJcXG4gICAgICAgICAgICAgICAgICAgIC8vIHpsaWIsIHNvIHdlIGRvbid0IGNhcmUgYWJvdXQgdGhpcyBwYXRob2xvZ2ljYWwgY2FzZS4pXFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICBuID0gaGFzaF9zaXplO1xcclxcbiAgICAgICAgICAgICAgICAgICAgcCA9IG47XFxyXFxuICAgICAgICAgICAgICAgICAgICBkbyB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgbSA9IChoZWFkWy0tcF0gJiAweGZmZmYpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRbcF0gPSAobSA+PSB3X3NpemUgPyBtIC0gd19zaXplIDogMCk7XFxyXFxuICAgICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW4gIT09IDApO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgbiA9IHdfc2l6ZTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHAgPSBuO1xcclxcbiAgICAgICAgICAgICAgICAgICAgZG8ge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIG0gPSAocHJldlstLXBdICYgMHhmZmZmKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2W3BdID0gKG0gPj0gd19zaXplID8gbSAtIHdfc2l6ZSA6IDApO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIG4gaXMgbm90IG9uIGFueSBoYXNoIGNoYWluLCBwcmV2W25dIGlzIGdhcmJhZ2UgYnV0XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXRzIHZhbHVlIHdpbGwgbmV2ZXIgYmUgdXNlZC5cXHJcXG4gICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tbiAhPT0gMCk7XFxyXFxuICAgICAgICAgICAgICAgICAgICBtb3JlICs9IHdfc2l6ZTtcXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgICAgICAgICBpZiAoc3RybS5hdmFpbF9pbiA9PT0gMClcXHJcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgd2FzIG5vIHNsaWRpbmc6XFxyXFxuICAgICAgICAgICAgICAgIC8vIHN0cnN0YXJ0IDw9IFdTSVpFK01BWF9ESVNULTEgJiYgbG9va2FoZWFkIDw9IE1JTl9MT09LQUhFQUQgLSAxICYmXFxyXFxuICAgICAgICAgICAgICAgIC8vIG1vcmUgPT0gd2luZG93X3NpemUgLSBsb29rYWhlYWQgLSBzdHJzdGFydFxcclxcbiAgICAgICAgICAgICAgICAvLyA9PiBtb3JlID49IHdpbmRvd19zaXplIC0gKE1JTl9MT09LQUhFQUQtMSArIFdTSVpFICsgTUFYX0RJU1QtMSlcXHJcXG4gICAgICAgICAgICAgICAgLy8gPT4gbW9yZSA+PSB3aW5kb3dfc2l6ZSAtIDIqV1NJWkUgKyAyXFxyXFxuICAgICAgICAgICAgICAgIC8vIEluIHRoZSBCSUdfTUVNIG9yIE1NQVAgY2FzZSAobm90IHlldCBzdXBwb3J0ZWQpLFxcclxcbiAgICAgICAgICAgICAgICAvLyB3aW5kb3dfc2l6ZSA9PSBpbnB1dF9zaXplICsgTUlOX0xPT0tBSEVBRCAmJlxcclxcbiAgICAgICAgICAgICAgICAvLyBzdHJzdGFydCArIHMtPmxvb2thaGVhZCA8PSBpbnB1dF9zaXplID0+IG1vcmUgPj0gTUlOX0xPT0tBSEVBRC5cXHJcXG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCB3aW5kb3dfc2l6ZSA9PSAyKldTSVpFIHNvIG1vcmUgPj0gMi5cXHJcXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgd2FzIHNsaWRpbmcsIG1vcmUgPj0gV1NJWkUuIFNvIGluIGFsbCBjYXNlcywgbW9yZSA+PSAyLlxcclxcblxcclxcbiAgICAgICAgICAgICAgICBuID0gc3RybS5yZWFkX2J1Zih3aW5kb3csIHN0cnN0YXJ0ICsgbG9va2FoZWFkLCBtb3JlKTtcXHJcXG4gICAgICAgICAgICAgICAgbG9va2FoZWFkICs9IG47XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgIC8vIEluaXRpYWxpemUgdGhlIGhhc2ggdmFsdWUgbm93IHRoYXQgd2UgaGF2ZSBzb21lIGlucHV0OlxcclxcbiAgICAgICAgICAgICAgICBpZiAobG9va2FoZWFkID49IE1JTl9NQVRDSCkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgaW5zX2ggPSB3aW5kb3dbc3Ryc3RhcnRdICYgMHhmZjtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGluc19oID0gKCgoaW5zX2gpIDw8IGhhc2hfc2hpZnQpIF4gKHdpbmRvd1tzdHJzdGFydCArIDFdICYgMHhmZikpICYgaGFzaF9tYXNrO1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSB3aG9sZSBpbnB1dCBoYXMgbGVzcyB0aGFuIE1JTl9NQVRDSCBieXRlcywgaW5zX2ggaXNcXHJcXG4gICAgICAgICAgICAgICAgLy8gZ2FyYmFnZSxcXHJcXG4gICAgICAgICAgICAgICAgLy8gYnV0IHRoaXMgaXMgbm90IGltcG9ydGFudCBzaW5jZSBvbmx5IGxpdGVyYWwgYnl0ZXMgd2lsbCBiZVxcclxcbiAgICAgICAgICAgICAgICAvLyBlbWl0dGVkLlxcclxcbiAgICAgICAgICAgIH0gd2hpbGUgKGxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQgJiYgc3RybS5hdmFpbF9pbiAhPT0gMCk7XFxyXFxuICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAvLyBDb3B5IHdpdGhvdXQgY29tcHJlc3Npb24gYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIHRoZSBpbnB1dCBzdHJlYW0sXFxyXFxuICAgICAgICAvLyByZXR1cm5cXHJcXG4gICAgICAgIC8vIHRoZSBjdXJyZW50IGJsb2NrIHN0YXRlLlxcclxcbiAgICAgICAgLy8gVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBpbnNlcnQgbmV3IHN0cmluZ3MgaW4gdGhlIGRpY3Rpb25hcnkgc2luY2VcXHJcXG4gICAgICAgIC8vIHVuY29tcHJlc3NpYmxlIGRhdGEgaXMgcHJvYmFibHkgbm90IHVzZWZ1bC4gVGhpcyBmdW5jdGlvbiBpcyB1c2VkXFxyXFxuICAgICAgICAvLyBvbmx5IGZvciB0aGUgbGV2ZWw9MCBjb21wcmVzc2lvbiBvcHRpb24uXFxyXFxuICAgICAgICAvLyBOT1RFOiB0aGlzIGZ1bmN0aW9uIHNob3VsZCBiZSBvcHRpbWl6ZWQgdG8gYXZvaWQgZXh0cmEgY29weWluZyBmcm9tXFxyXFxuICAgICAgICAvLyB3aW5kb3cgdG8gcGVuZGluZ19idWYuXFxyXFxuICAgICAgICBmdW5jdGlvbiBkZWZsYXRlX3N0b3JlZChmbHVzaCkge1xcclxcbiAgICAgICAgICAgIC8vIFN0b3JlZCBibG9ja3MgYXJlIGxpbWl0ZWQgdG8gMHhmZmZmIGJ5dGVzLCBwZW5kaW5nX2J1ZiBpcyBsaW1pdGVkXFxyXFxuICAgICAgICAgICAgLy8gdG8gcGVuZGluZ19idWZfc2l6ZSwgYW5kIGVhY2ggc3RvcmVkIGJsb2NrIGhhcyBhIDUgYnl0ZSBoZWFkZXI6XFxyXFxuXFxyXFxuICAgICAgICAgICAgdmFyIG1heF9ibG9ja19zaXplID0gMHhmZmZmO1xcclxcbiAgICAgICAgICAgIHZhciBtYXhfc3RhcnQ7XFxyXFxuXFxyXFxuICAgICAgICAgICAgaWYgKG1heF9ibG9ja19zaXplID4gcGVuZGluZ19idWZfc2l6ZSAtIDUpIHtcXHJcXG4gICAgICAgICAgICAgICAgbWF4X2Jsb2NrX3NpemUgPSBwZW5kaW5nX2J1Zl9zaXplIC0gNTtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgLy8gQ29weSBhcyBtdWNoIGFzIHBvc3NpYmxlIGZyb20gaW5wdXQgdG8gb3V0cHV0OlxcclxcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XFxyXFxuICAgICAgICAgICAgICAgIC8vIEZpbGwgdGhlIHdpbmRvdyBhcyBtdWNoIGFzIHBvc3NpYmxlOlxcclxcbiAgICAgICAgICAgICAgICBpZiAobG9va2FoZWFkIDw9IDEpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGZpbGxfd2luZG93KCk7XFxyXFxuICAgICAgICAgICAgICAgICAgICBpZiAobG9va2FoZWFkID09PSAwICYmIGZsdXNoID09IFpfTk9fRkxVU0gpXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE5lZWRNb3JlO1xcclxcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvb2thaGVhZCA9PT0gMClcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2tcXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgICAgICAgICBzdHJzdGFydCArPSBsb29rYWhlYWQ7XFxyXFxuICAgICAgICAgICAgICAgIGxvb2thaGVhZCA9IDA7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgIC8vIEVtaXQgYSBzdG9yZWQgYmxvY2sgaWYgcGVuZGluZ19idWYgd2lsbCBiZSBmdWxsOlxcclxcbiAgICAgICAgICAgICAgICBtYXhfc3RhcnQgPSBibG9ja19zdGFydCArIG1heF9ibG9ja19zaXplO1xcclxcbiAgICAgICAgICAgICAgICBpZiAoc3Ryc3RhcnQgPT09IDAgfHwgc3Ryc3RhcnQgPj0gbWF4X3N0YXJ0KSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAvLyBzdHJzdGFydCA9PT0gMCBpcyBwb3NzaWJsZSB3aGVuIHdyYXBhcm91bmQgb24gMTYtYml0IG1hY2hpbmVcXHJcXG4gICAgICAgICAgICAgICAgICAgIGxvb2thaGVhZCA9IChzdHJzdGFydCAtIG1heF9zdGFydCk7XFxyXFxuICAgICAgICAgICAgICAgICAgICBzdHJzdGFydCA9IG1heF9zdGFydDtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgIGZsdXNoX2Jsb2NrX29ubHkoZmFsc2UpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBOZWVkTW9yZTtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgICAgICAgICAvLyBGbHVzaCBpZiB3ZSBtYXkgaGF2ZSB0byBzbGlkZSwgb3RoZXJ3aXNlIGJsb2NrX3N0YXJ0IG1heSBiZWNvbWVcXHJcXG4gICAgICAgICAgICAgICAgLy8gbmVnYXRpdmUgYW5kIHRoZSBkYXRhIHdpbGwgYmUgZ29uZTpcXHJcXG4gICAgICAgICAgICAgICAgaWYgKHN0cnN0YXJ0IC0gYmxvY2tfc3RhcnQgPj0gd19zaXplIC0gTUlOX0xPT0tBSEVBRCkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgZmx1c2hfYmxvY2tfb25seShmYWxzZSk7XFxyXFxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE5lZWRNb3JlO1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgICAgIGZsdXNoX2Jsb2NrX29ubHkoZmx1c2ggPT0gWl9GSU5JU0gpO1xcclxcbiAgICAgICAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMClcXHJcXG4gICAgICAgICAgICAgICAgcmV0dXJuIChmbHVzaCA9PSBaX0ZJTklTSCkgPyBGaW5pc2hTdGFydGVkIDogTmVlZE1vcmU7XFxyXFxuXFxyXFxuICAgICAgICAgICAgcmV0dXJuIGZsdXNoID09IFpfRklOSVNIID8gRmluaXNoRG9uZSA6IEJsb2NrRG9uZTtcXHJcXG4gICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgIGZ1bmN0aW9uIGxvbmdlc3RfbWF0Y2goY3VyX21hdGNoKSB7XFxyXFxuICAgICAgICAgICAgdmFyIGNoYWluX2xlbmd0aCA9IG1heF9jaGFpbl9sZW5ndGg7IC8vIG1heCBoYXNoIGNoYWluIGxlbmd0aFxcclxcbiAgICAgICAgICAgIHZhciBzY2FuID0gc3Ryc3RhcnQ7IC8vIGN1cnJlbnQgc3RyaW5nXFxyXFxuICAgICAgICAgICAgdmFyIG1hdGNoOyAvLyBtYXRjaGVkIHN0cmluZ1xcclxcbiAgICAgICAgICAgIHZhciBsZW47IC8vIGxlbmd0aCBvZiBjdXJyZW50IG1hdGNoXFxyXFxuICAgICAgICAgICAgdmFyIGJlc3RfbGVuID0gcHJldl9sZW5ndGg7IC8vIGJlc3QgbWF0Y2ggbGVuZ3RoIHNvIGZhclxcclxcbiAgICAgICAgICAgIHZhciBsaW1pdCA9IHN0cnN0YXJ0ID4gKHdfc2l6ZSAtIE1JTl9MT09LQUhFQUQpID8gc3Ryc3RhcnQgLSAod19zaXplIC0gTUlOX0xPT0tBSEVBRCkgOiAwO1xcclxcbiAgICAgICAgICAgIHZhciBfbmljZV9tYXRjaCA9IG5pY2VfbWF0Y2g7XFxyXFxuXFxyXFxuICAgICAgICAgICAgLy8gU3RvcCB3aGVuIGN1cl9tYXRjaCBiZWNvbWVzIDw9IGxpbWl0LiBUbyBzaW1wbGlmeSB0aGUgY29kZSxcXHJcXG4gICAgICAgICAgICAvLyB3ZSBwcmV2ZW50IG1hdGNoZXMgd2l0aCB0aGUgc3RyaW5nIG9mIHdpbmRvdyBpbmRleCAwLlxcclxcblxcclxcbiAgICAgICAgICAgIHZhciB3bWFzayA9IHdfbWFzaztcXHJcXG5cXHJcXG4gICAgICAgICAgICB2YXIgc3RyZW5kID0gc3Ryc3RhcnQgKyBNQVhfTUFUQ0g7XFxyXFxuICAgICAgICAgICAgdmFyIHNjYW5fZW5kMSA9IHdpbmRvd1tzY2FuICsgYmVzdF9sZW4gLSAxXTtcXHJcXG4gICAgICAgICAgICB2YXIgc2Nhbl9lbmQgPSB3aW5kb3dbc2NhbiArIGJlc3RfbGVuXTtcXHJcXG5cXHJcXG4gICAgICAgICAgICAvLyBUaGUgY29kZSBpcyBvcHRpbWl6ZWQgZm9yIEhBU0hfQklUUyA+PSA4IGFuZCBNQVhfTUFUQ0gtMiBtdWx0aXBsZSBvZlxcclxcbiAgICAgICAgICAgIC8vIDE2LlxcclxcbiAgICAgICAgICAgIC8vIEl0IGlzIGVhc3kgdG8gZ2V0IHJpZCBvZiB0aGlzIG9wdGltaXphdGlvbiBpZiBuZWNlc3NhcnkuXFxyXFxuXFxyXFxuICAgICAgICAgICAgLy8gRG8gbm90IHdhc3RlIHRvbyBtdWNoIHRpbWUgaWYgd2UgYWxyZWFkeSBoYXZlIGEgZ29vZCBtYXRjaDpcXHJcXG4gICAgICAgICAgICBpZiAocHJldl9sZW5ndGggPj0gZ29vZF9tYXRjaCkge1xcclxcbiAgICAgICAgICAgICAgICBjaGFpbl9sZW5ndGggPj49IDI7XFxyXFxuICAgICAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgICAgIC8vIERvIG5vdCBsb29rIGZvciBtYXRjaGVzIGJleW9uZCB0aGUgZW5kIG9mIHRoZSBpbnB1dC4gVGhpcyBpc1xcclxcbiAgICAgICAgICAgIC8vIG5lY2Vzc2FyeVxcclxcbiAgICAgICAgICAgIC8vIHRvIG1ha2UgZGVmbGF0ZSBkZXRlcm1pbmlzdGljLlxcclxcbiAgICAgICAgICAgIGlmIChfbmljZV9tYXRjaCA+IGxvb2thaGVhZClcXHJcXG4gICAgICAgICAgICAgICAgX25pY2VfbWF0Y2ggPSBsb29rYWhlYWQ7XFxyXFxuXFxyXFxuICAgICAgICAgICAgZG8ge1xcclxcbiAgICAgICAgICAgICAgICBtYXRjaCA9IGN1cl9tYXRjaDtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgLy8gU2tpcCB0byBuZXh0IG1hdGNoIGlmIHRoZSBtYXRjaCBsZW5ndGggY2Fubm90IGluY3JlYXNlXFxyXFxuICAgICAgICAgICAgICAgIC8vIG9yIGlmIHRoZSBtYXRjaCBsZW5ndGggaXMgbGVzcyB0aGFuIDI6XFxyXFxuICAgICAgICAgICAgICAgIGlmICh3aW5kb3dbbWF0Y2ggKyBiZXN0X2xlbl0gIT0gc2Nhbl9lbmQgfHwgd2luZG93W21hdGNoICsgYmVzdF9sZW4gLSAxXSAhPSBzY2FuX2VuZDEgfHwgd2luZG93W21hdGNoXSAhPSB3aW5kb3dbc2Nhbl1cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB8fCB3aW5kb3dbKyttYXRjaF0gIT0gd2luZG93W3NjYW4gKyAxXSlcXHJcXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICAvLyBUaGUgY2hlY2sgYXQgYmVzdF9sZW4tMSBjYW4gYmUgcmVtb3ZlZCBiZWNhdXNlIGl0IHdpbGwgYmUgbWFkZVxcclxcbiAgICAgICAgICAgICAgICAvLyBhZ2FpbiBsYXRlci4gKFRoaXMgaGV1cmlzdGljIGlzIG5vdCBhbHdheXMgYSB3aW4uKVxcclxcbiAgICAgICAgICAgICAgICAvLyBJdCBpcyBub3QgbmVjZXNzYXJ5IHRvIGNvbXBhcmUgc2NhblsyXSBhbmQgbWF0Y2hbMl0gc2luY2UgdGhleVxcclxcbiAgICAgICAgICAgICAgICAvLyBhcmUgYWx3YXlzIGVxdWFsIHdoZW4gdGhlIG90aGVyIGJ5dGVzIG1hdGNoLCBnaXZlbiB0aGF0XFxyXFxuICAgICAgICAgICAgICAgIC8vIHRoZSBoYXNoIGtleXMgYXJlIGVxdWFsIGFuZCB0aGF0IEhBU0hfQklUUyA+PSA4LlxcclxcbiAgICAgICAgICAgICAgICBzY2FuICs9IDI7XFxyXFxuICAgICAgICAgICAgICAgIG1hdGNoKys7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgIC8vIFdlIGNoZWNrIGZvciBpbnN1ZmZpY2llbnQgbG9va2FoZWFkIG9ubHkgZXZlcnkgOHRoIGNvbXBhcmlzb247XFxyXFxuICAgICAgICAgICAgICAgIC8vIHRoZSAyNTZ0aCBjaGVjayB3aWxsIGJlIG1hZGUgYXQgc3Ryc3RhcnQrMjU4LlxcclxcbiAgICAgICAgICAgICAgICBkbyB7XFxyXFxuICAgICAgICAgICAgICAgIH0gd2hpbGUgKHdpbmRvd1srK3NjYW5dID09IHdpbmRvd1srK21hdGNoXSAmJiB3aW5kb3dbKytzY2FuXSA9PSB3aW5kb3dbKyttYXRjaF0gJiYgd2luZG93Wysrc2Nhbl0gPT0gd2luZG93WysrbWF0Y2hdXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgd2luZG93Wysrc2Nhbl0gPT0gd2luZG93WysrbWF0Y2hdICYmIHdpbmRvd1srK3NjYW5dID09IHdpbmRvd1srK21hdGNoXSAmJiB3aW5kb3dbKytzY2FuXSA9PSB3aW5kb3dbKyttYXRjaF1cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiB3aW5kb3dbKytzY2FuXSA9PSB3aW5kb3dbKyttYXRjaF0gJiYgd2luZG93Wysrc2Nhbl0gPT0gd2luZG93WysrbWF0Y2hdICYmIHNjYW4gPCBzdHJlbmQpO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICBsZW4gPSBNQVhfTUFUQ0ggLSAoc3RyZW5kIC0gc2Nhbik7XFxyXFxuICAgICAgICAgICAgICAgIHNjYW4gPSBzdHJlbmQgLSBNQVhfTUFUQ0g7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgIGlmIChsZW4gPiBiZXN0X2xlbikge1xcclxcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hfc3RhcnQgPSBjdXJfbWF0Y2g7XFxyXFxuICAgICAgICAgICAgICAgICAgICBiZXN0X2xlbiA9IGxlbjtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGlmIChsZW4gPj0gX25pY2VfbWF0Y2gpXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxyXFxuICAgICAgICAgICAgICAgICAgICBzY2FuX2VuZDEgPSB3aW5kb3dbc2NhbiArIGJlc3RfbGVuIC0gMV07XFxyXFxuICAgICAgICAgICAgICAgICAgICBzY2FuX2VuZCA9IHdpbmRvd1tzY2FuICsgYmVzdF9sZW5dO1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgfSB3aGlsZSAoKGN1cl9tYXRjaCA9IChwcmV2W2N1cl9tYXRjaCAmIHdtYXNrXSAmIDB4ZmZmZikpID4gbGltaXQgJiYgLS1jaGFpbl9sZW5ndGggIT09IDApO1xcclxcblxcclxcbiAgICAgICAgICAgIGlmIChiZXN0X2xlbiA8PSBsb29rYWhlYWQpXFxyXFxuICAgICAgICAgICAgICAgIHJldHVybiBiZXN0X2xlbjtcXHJcXG4gICAgICAgICAgICByZXR1cm4gbG9va2FoZWFkO1xcclxcbiAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgLy8gQ29tcHJlc3MgYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIHRoZSBpbnB1dCBzdHJlYW0sIHJldHVybiB0aGUgY3VycmVudFxcclxcbiAgICAgICAgLy8gYmxvY2sgc3RhdGUuXFxyXFxuICAgICAgICAvLyBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IHBlcmZvcm0gbGF6eSBldmFsdWF0aW9uIG9mIG1hdGNoZXMgYW5kIGluc2VydHNcXHJcXG4gICAgICAgIC8vIG5ldyBzdHJpbmdzIGluIHRoZSBkaWN0aW9uYXJ5IG9ubHkgZm9yIHVubWF0Y2hlZCBzdHJpbmdzIG9yIGZvciBzaG9ydFxcclxcbiAgICAgICAgLy8gbWF0Y2hlcy4gSXQgaXMgdXNlZCBvbmx5IGZvciB0aGUgZmFzdCBjb21wcmVzc2lvbiBvcHRpb25zLlxcclxcbiAgICAgICAgZnVuY3Rpb24gZGVmbGF0ZV9mYXN0KGZsdXNoKSB7XFxyXFxuICAgICAgICAgICAgLy8gc2hvcnQgaGFzaF9oZWFkID0gMDsgLy8gaGVhZCBvZiB0aGUgaGFzaCBjaGFpblxcclxcbiAgICAgICAgICAgIHZhciBoYXNoX2hlYWQgPSAwOyAvLyBoZWFkIG9mIHRoZSBoYXNoIGNoYWluXFxyXFxuICAgICAgICAgICAgdmFyIGJmbHVzaDsgLy8gc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkXFxyXFxuXFxyXFxuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcXHJcXG4gICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgd2UgYWx3YXlzIGhhdmUgZW5vdWdoIGxvb2thaGVhZCwgZXhjZXB0XFxyXFxuICAgICAgICAgICAgICAgIC8vIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0IGZpbGUuIFdlIG5lZWQgTUFYX01BVENIIGJ5dGVzXFxyXFxuICAgICAgICAgICAgICAgIC8vIGZvciB0aGUgbmV4dCBtYXRjaCwgcGx1cyBNSU5fTUFUQ0ggYnl0ZXMgdG8gaW5zZXJ0IHRoZVxcclxcbiAgICAgICAgICAgICAgICAvLyBzdHJpbmcgZm9sbG93aW5nIHRoZSBuZXh0IG1hdGNoLlxcclxcbiAgICAgICAgICAgICAgICBpZiAobG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgZmlsbF93aW5kb3coKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGlmIChsb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEICYmIGZsdXNoID09IFpfTk9fRkxVU0gpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTmVlZE1vcmU7XFxyXFxuICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgICAgICBpZiAobG9va2FoZWFkID09PSAwKVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBmbHVzaCB0aGUgY3VycmVudCBibG9ja1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgIC8vIEluc2VydCB0aGUgc3RyaW5nIHdpbmRvd1tzdHJzdGFydCAuLiBzdHJzdGFydCsyXSBpbiB0aGVcXHJcXG4gICAgICAgICAgICAgICAgLy8gZGljdGlvbmFyeSwgYW5kIHNldCBoYXNoX2hlYWQgdG8gdGhlIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW46XFxyXFxuICAgICAgICAgICAgICAgIGlmIChsb29rYWhlYWQgPj0gTUlOX01BVENIKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICBpbnNfaCA9ICgoKGluc19oKSA8PCBoYXNoX3NoaWZ0KSBeICh3aW5kb3dbKHN0cnN0YXJ0KSArIChNSU5fTUFUQ0ggLSAxKV0gJiAweGZmKSkgJiBoYXNoX21hc2s7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICAvLyBwcmV2W3N0cnN0YXJ0JndfbWFza109aGFzaF9oZWFkPWhlYWRbaW5zX2hdO1xcclxcbiAgICAgICAgICAgICAgICAgICAgaGFzaF9oZWFkID0gKGhlYWRbaW5zX2hdICYgMHhmZmZmKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHByZXZbc3Ryc3RhcnQgJiB3X21hc2tdID0gaGVhZFtpbnNfaF07XFxyXFxuICAgICAgICAgICAgICAgICAgICBoZWFkW2luc19oXSA9IHN0cnN0YXJ0O1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgIC8vIEZpbmQgdGhlIGxvbmdlc3QgbWF0Y2gsIGRpc2NhcmRpbmcgdGhvc2UgPD0gcHJldl9sZW5ndGguXFxyXFxuICAgICAgICAgICAgICAgIC8vIEF0IHRoaXMgcG9pbnQgd2UgaGF2ZSBhbHdheXMgbWF0Y2hfbGVuZ3RoIDwgTUlOX01BVENIXFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgIGlmIChoYXNoX2hlYWQgIT09IDAgJiYgKChzdHJzdGFydCAtIGhhc2hfaGVhZCkgJiAweGZmZmYpIDw9IHdfc2l6ZSAtIE1JTl9MT09LQUhFQUQpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIC8vIFRvIHNpbXBsaWZ5IHRoZSBjb2RlLCB3ZSBwcmV2ZW50IG1hdGNoZXMgd2l0aCB0aGUgc3RyaW5nXFxyXFxuICAgICAgICAgICAgICAgICAgICAvLyBvZiB3aW5kb3cgaW5kZXggMCAoaW4gcGFydGljdWxhciB3ZSBoYXZlIHRvIGF2b2lkIGEgbWF0Y2hcXHJcXG4gICAgICAgICAgICAgICAgICAgIC8vIG9mIHRoZSBzdHJpbmcgd2l0aCBpdHNlbGYgYXQgdGhlIHN0YXJ0IG9mIHRoZSBpbnB1dCBmaWxlKS5cXHJcXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHJhdGVneSAhPSBaX0hVRkZNQU5fT05MWSkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoX2xlbmd0aCA9IGxvbmdlc3RfbWF0Y2goaGFzaF9oZWFkKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgICAgIC8vIGxvbmdlc3RfbWF0Y2goKSBzZXRzIG1hdGNoX3N0YXJ0XFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoX2xlbmd0aCA+PSBNSU5fTUFUQ0gpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrX21hdGNoKHN0cnN0YXJ0LCBtYXRjaF9zdGFydCwgbWF0Y2hfbGVuZ3RoKTtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgIGJmbHVzaCA9IF90cl90YWxseShzdHJzdGFydCAtIG1hdGNoX3N0YXJ0LCBtYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gpO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgbG9va2FoZWFkIC09IG1hdGNoX2xlbmd0aDtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgIC8vIEluc2VydCBuZXcgc3RyaW5ncyBpbiB0aGUgaGFzaCB0YWJsZSBvbmx5IGlmIHRoZSBtYXRjaCBsZW5ndGhcXHJcXG4gICAgICAgICAgICAgICAgICAgIC8vIGlzIG5vdCB0b28gbGFyZ2UuIFRoaXMgc2F2ZXMgdGltZSBidXQgZGVncmFkZXMgY29tcHJlc3Npb24uXFxyXFxuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hfbGVuZ3RoIDw9IG1heF9sYXp5X21hdGNoICYmIGxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaF9sZW5ndGgtLTsgLy8gc3RyaW5nIGF0IHN0cnN0YXJ0IGFscmVhZHkgaW4gaGFzaCB0YWJsZVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Ryc3RhcnQrKztcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zX2ggPSAoKGluc19oIDw8IGhhc2hfc2hpZnQpIF4gKHdpbmRvd1soc3Ryc3RhcnQpICsgKE1JTl9NQVRDSCAtIDEpXSAmIDB4ZmYpKSAmIGhhc2hfbWFzaztcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJldltzdHJzdGFydCZ3X21hc2tdPWhhc2hfaGVhZD1oZWFkW2luc19oXTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzaF9oZWFkID0gKGhlYWRbaW5zX2hdICYgMHhmZmZmKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldltzdHJzdGFydCAmIHdfbWFza10gPSBoZWFkW2luc19oXTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZFtpbnNfaF0gPSBzdHJzdGFydDtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3Ryc3RhcnQgbmV2ZXIgZXhjZWVkcyBXU0laRS1NQVhfTUFUQ0gsIHNvIHRoZXJlIGFyZVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbHdheXMgTUlOX01BVENIIGJ5dGVzIGFoZWFkLlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tbWF0Y2hfbGVuZ3RoICE9PSAwKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJzdGFydCsrO1xcclxcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJzdGFydCArPSBtYXRjaF9sZW5ndGg7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hfbGVuZ3RoID0gMDtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnNfaCA9IHdpbmRvd1tzdHJzdGFydF0gJiAweGZmO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc19oID0gKCgoaW5zX2gpIDw8IGhhc2hfc2hpZnQpIF4gKHdpbmRvd1tzdHJzdGFydCArIDFdICYgMHhmZikpICYgaGFzaF9tYXNrO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGxvb2thaGVhZCA8IE1JTl9NQVRDSCwgaW5zX2ggaXMgZ2FyYmFnZSwgYnV0IGl0IGRvZXNcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBub3RcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtYXR0ZXIgc2luY2UgaXQgd2lsbCBiZSByZWNvbXB1dGVkIGF0IG5leHQgZGVmbGF0ZSBjYWxsLlxcclxcbiAgICAgICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgICAgICAgICAgICAgLy8gTm8gbWF0Y2gsIG91dHB1dCBhIGxpdGVyYWwgYnl0ZVxcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgYmZsdXNoID0gX3RyX3RhbGx5KDAsIHdpbmRvd1tzdHJzdGFydF0gJiAweGZmKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGxvb2thaGVhZC0tO1xcclxcbiAgICAgICAgICAgICAgICAgICAgc3Ryc3RhcnQrKztcXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICBpZiAoYmZsdXNoKSB7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICBmbHVzaF9ibG9ja19vbmx5KGZhbHNlKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMClcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTmVlZE1vcmU7XFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgZmx1c2hfYmxvY2tfb25seShmbHVzaCA9PSBaX0ZJTklTSCk7XFxyXFxuICAgICAgICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XFxyXFxuICAgICAgICAgICAgICAgIGlmIChmbHVzaCA9PSBaX0ZJTklTSClcXHJcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBGaW5pc2hTdGFydGVkO1xcclxcbiAgICAgICAgICAgICAgICBlbHNlXFxyXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTmVlZE1vcmU7XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIHJldHVybiBmbHVzaCA9PSBaX0ZJTklTSCA/IEZpbmlzaERvbmUgOiBCbG9ja0RvbmU7XFxyXFxuICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAvLyBTYW1lIGFzIGFib3ZlLCBidXQgYWNoaWV2ZXMgYmV0dGVyIGNvbXByZXNzaW9uLiBXZSB1c2UgYSBsYXp5XFxyXFxuICAgICAgICAvLyBldmFsdWF0aW9uIGZvciBtYXRjaGVzOiBhIG1hdGNoIGlzIGZpbmFsbHkgYWRvcHRlZCBvbmx5IGlmIHRoZXJlIGlzXFxyXFxuICAgICAgICAvLyBubyBiZXR0ZXIgbWF0Y2ggYXQgdGhlIG5leHQgd2luZG93IHBvc2l0aW9uLlxcclxcbiAgICAgICAgZnVuY3Rpb24gZGVmbGF0ZV9zbG93KGZsdXNoKSB7XFxyXFxuICAgICAgICAgICAgLy8gc2hvcnQgaGFzaF9oZWFkID0gMDsgLy8gaGVhZCBvZiBoYXNoIGNoYWluXFxyXFxuICAgICAgICAgICAgdmFyIGhhc2hfaGVhZCA9IDA7IC8vIGhlYWQgb2YgaGFzaCBjaGFpblxcclxcbiAgICAgICAgICAgIHZhciBiZmx1c2g7IC8vIHNldCBpZiBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZFxcclxcbiAgICAgICAgICAgIHZhciBtYXhfaW5zZXJ0O1xcclxcblxcclxcbiAgICAgICAgICAgIC8vIFByb2Nlc3MgdGhlIGlucHV0IGJsb2NrLlxcclxcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XFxyXFxuICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHdlIGFsd2F5cyBoYXZlIGVub3VnaCBsb29rYWhlYWQsIGV4Y2VwdFxcclxcbiAgICAgICAgICAgICAgICAvLyBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dCBmaWxlLiBXZSBuZWVkIE1BWF9NQVRDSCBieXRlc1xcclxcbiAgICAgICAgICAgICAgICAvLyBmb3IgdGhlIG5leHQgbWF0Y2gsIHBsdXMgTUlOX01BVENIIGJ5dGVzIHRvIGluc2VydCB0aGVcXHJcXG4gICAgICAgICAgICAgICAgLy8gc3RyaW5nIGZvbGxvd2luZyB0aGUgbmV4dCBtYXRjaC5cXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgaWYgKGxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGZpbGxfd2luZG93KCk7XFxyXFxuICAgICAgICAgICAgICAgICAgICBpZiAobG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCAmJiBmbHVzaCA9PSBaX05PX0ZMVVNIKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE5lZWRNb3JlO1xcclxcbiAgICAgICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvb2thaGVhZCA9PT0gMClcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2tcXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgICAgICAgICAvLyBJbnNlcnQgdGhlIHN0cmluZyB3aW5kb3dbc3Ryc3RhcnQgLi4gc3Ryc3RhcnQrMl0gaW4gdGhlXFxyXFxuICAgICAgICAgICAgICAgIC8vIGRpY3Rpb25hcnksIGFuZCBzZXQgaGFzaF9oZWFkIHRvIHRoZSBoZWFkIG9mIHRoZSBoYXNoIGNoYWluOlxcclxcblxcclxcbiAgICAgICAgICAgICAgICBpZiAobG9va2FoZWFkID49IE1JTl9NQVRDSCkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgaW5zX2ggPSAoKChpbnNfaCkgPDwgaGFzaF9zaGlmdCkgXiAod2luZG93WyhzdHJzdGFydCkgKyAoTUlOX01BVENIIC0gMSldICYgMHhmZikpICYgaGFzaF9tYXNrO1xcclxcbiAgICAgICAgICAgICAgICAgICAgLy8gcHJldltzdHJzdGFydCZ3X21hc2tdPWhhc2hfaGVhZD1oZWFkW2luc19oXTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGhhc2hfaGVhZCA9IChoZWFkW2luc19oXSAmIDB4ZmZmZik7XFxyXFxuICAgICAgICAgICAgICAgICAgICBwcmV2W3N0cnN0YXJ0ICYgd19tYXNrXSA9IGhlYWRbaW5zX2hdO1xcclxcbiAgICAgICAgICAgICAgICAgICAgaGVhZFtpbnNfaF0gPSBzdHJzdGFydDtcXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgICAgICAgICAvLyBGaW5kIHRoZSBsb25nZXN0IG1hdGNoLCBkaXNjYXJkaW5nIHRob3NlIDw9IHByZXZfbGVuZ3RoLlxcclxcbiAgICAgICAgICAgICAgICBwcmV2X2xlbmd0aCA9IG1hdGNoX2xlbmd0aDtcXHJcXG4gICAgICAgICAgICAgICAgcHJldl9tYXRjaCA9IG1hdGNoX3N0YXJ0O1xcclxcbiAgICAgICAgICAgICAgICBtYXRjaF9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICBpZiAoaGFzaF9oZWFkICE9PSAwICYmIHByZXZfbGVuZ3RoIDwgbWF4X2xhenlfbWF0Y2ggJiYgKChzdHJzdGFydCAtIGhhc2hfaGVhZCkgJiAweGZmZmYpIDw9IHdfc2l6ZSAtIE1JTl9MT09LQUhFQUQpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIC8vIFRvIHNpbXBsaWZ5IHRoZSBjb2RlLCB3ZSBwcmV2ZW50IG1hdGNoZXMgd2l0aCB0aGUgc3RyaW5nXFxyXFxuICAgICAgICAgICAgICAgICAgICAvLyBvZiB3aW5kb3cgaW5kZXggMCAoaW4gcGFydGljdWxhciB3ZSBoYXZlIHRvIGF2b2lkIGEgbWF0Y2hcXHJcXG4gICAgICAgICAgICAgICAgICAgIC8vIG9mIHRoZSBzdHJpbmcgd2l0aCBpdHNlbGYgYXQgdGhlIHN0YXJ0IG9mIHRoZSBpbnB1dCBmaWxlKS5cXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHJhdGVneSAhPSBaX0hVRkZNQU5fT05MWSkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoX2xlbmd0aCA9IGxvbmdlc3RfbWF0Y2goaGFzaF9oZWFkKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgICAgIC8vIGxvbmdlc3RfbWF0Y2goKSBzZXRzIG1hdGNoX3N0YXJ0XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hfbGVuZ3RoIDw9IDUgJiYgKHN0cmF0ZWd5ID09IFpfRklMVEVSRUQgfHwgKG1hdGNoX2xlbmd0aCA9PSBNSU5fTUFUQ0ggJiYgc3Ryc3RhcnQgLSBtYXRjaF9zdGFydCA+IDQwOTYpKSkge1xcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHByZXZfbWF0Y2ggaXMgYWxzbyBNSU5fTUFUQ0gsIG1hdGNoX3N0YXJ0IGlzIGdhcmJhZ2VcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBidXQgd2Ugd2lsbCBpZ25vcmUgdGhlIGN1cnJlbnQgbWF0Y2ggYW55d2F5LlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoX2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XFxyXFxuICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgd2FzIGEgbWF0Y2ggYXQgdGhlIHByZXZpb3VzIHN0ZXAgYW5kIHRoZSBjdXJyZW50XFxyXFxuICAgICAgICAgICAgICAgIC8vIG1hdGNoIGlzIG5vdCBiZXR0ZXIsIG91dHB1dCB0aGUgcHJldmlvdXMgbWF0Y2g6XFxyXFxuICAgICAgICAgICAgICAgIGlmIChwcmV2X2xlbmd0aCA+PSBNSU5fTUFUQ0ggJiYgbWF0Y2hfbGVuZ3RoIDw9IHByZXZfbGVuZ3RoKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICBtYXhfaW5zZXJ0ID0gc3Ryc3RhcnQgKyBsb29rYWhlYWQgLSBNSU5fTUFUQ0g7XFxyXFxuICAgICAgICAgICAgICAgICAgICAvLyBEbyBub3QgaW5zZXJ0IHN0cmluZ3MgaW4gaGFzaCB0YWJsZSBiZXlvbmQgdGhpcy5cXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrX21hdGNoKHN0cnN0YXJ0LTEsIHByZXZfbWF0Y2gsIHByZXZfbGVuZ3RoKTtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgIGJmbHVzaCA9IF90cl90YWxseShzdHJzdGFydCAtIDEgLSBwcmV2X21hdGNoLCBwcmV2X2xlbmd0aCAtIE1JTl9NQVRDSCk7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICAvLyBJbnNlcnQgaW4gaGFzaCB0YWJsZSBhbGwgc3RyaW5ncyB1cCB0byB0aGUgZW5kIG9mIHRoZSBtYXRjaC5cXHJcXG4gICAgICAgICAgICAgICAgICAgIC8vIHN0cnN0YXJ0LTEgYW5kIHN0cnN0YXJ0IGFyZSBhbHJlYWR5IGluc2VydGVkLiBJZiB0aGVyZSBpcyBub3RcXHJcXG4gICAgICAgICAgICAgICAgICAgIC8vIGVub3VnaCBsb29rYWhlYWQsIHRoZSBsYXN0IHR3byBzdHJpbmdzIGFyZSBub3QgaW5zZXJ0ZWQgaW5cXHJcXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBoYXNoIHRhYmxlLlxcclxcbiAgICAgICAgICAgICAgICAgICAgbG9va2FoZWFkIC09IHByZXZfbGVuZ3RoIC0gMTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHByZXZfbGVuZ3RoIC09IDI7XFxyXFxuICAgICAgICAgICAgICAgICAgICBkbyB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCsrc3Ryc3RhcnQgPD0gbWF4X2luc2VydCkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnNfaCA9ICgoKGluc19oKSA8PCBoYXNoX3NoaWZ0KSBeICh3aW5kb3dbKHN0cnN0YXJ0KSArIChNSU5fTUFUQ0ggLSAxKV0gJiAweGZmKSkgJiBoYXNoX21hc2s7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByZXZbc3Ryc3RhcnQmd19tYXNrXT1oYXNoX2hlYWQ9aGVhZFtpbnNfaF07XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc2hfaGVhZCA9IChoZWFkW2luc19oXSAmIDB4ZmZmZik7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZbc3Ryc3RhcnQgJiB3X21hc2tdID0gaGVhZFtpbnNfaF07XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRbaW5zX2hdID0gc3Ryc3RhcnQ7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1wcmV2X2xlbmd0aCAhPT0gMCk7XFxyXFxuICAgICAgICAgICAgICAgICAgICBtYXRjaF9hdmFpbGFibGUgPSAwO1xcclxcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHN0cnN0YXJ0Kys7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICBpZiAoYmZsdXNoKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgZmx1c2hfYmxvY2tfb25seShmYWxzZSk7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTmVlZE1vcmU7XFxyXFxuICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobWF0Y2hfYXZhaWxhYmxlICE9PSAwKSB7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSB3YXMgbm8gbWF0Y2ggYXQgdGhlIHByZXZpb3VzIHBvc2l0aW9uLCBvdXRwdXQgYVxcclxcbiAgICAgICAgICAgICAgICAgICAgLy8gc2luZ2xlIGxpdGVyYWwuIElmIHRoZXJlIHdhcyBhIG1hdGNoIGJ1dCB0aGUgY3VycmVudCBtYXRjaFxcclxcbiAgICAgICAgICAgICAgICAgICAgLy8gaXMgbG9uZ2VyLCB0cnVuY2F0ZSB0aGUgcHJldmlvdXMgbWF0Y2ggdG8gYSBzaW5nbGUgbGl0ZXJhbC5cXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgIGJmbHVzaCA9IF90cl90YWxseSgwLCB3aW5kb3dbc3Ryc3RhcnQgLSAxXSAmIDB4ZmYpO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJmbHVzaCkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsdXNoX2Jsb2NrX29ubHkoZmFsc2UpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICAgICAgc3Ryc3RhcnQrKztcXHJcXG4gICAgICAgICAgICAgICAgICAgIGxvb2thaGVhZC0tO1xcclxcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBOZWVkTW9yZTtcXHJcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZXJlIGlzIG5vIHByZXZpb3VzIG1hdGNoIHRvIGNvbXBhcmUgd2l0aCwgd2FpdCBmb3JcXHJcXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBuZXh0IHN0ZXAgdG8gZGVjaWRlLlxcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hfYXZhaWxhYmxlID0gMTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHN0cnN0YXJ0Kys7XFxyXFxuICAgICAgICAgICAgICAgICAgICBsb29rYWhlYWQtLTtcXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICBpZiAobWF0Y2hfYXZhaWxhYmxlICE9PSAwKSB7XFxyXFxuICAgICAgICAgICAgICAgIGJmbHVzaCA9IF90cl90YWxseSgwLCB3aW5kb3dbc3Ryc3RhcnQgLSAxXSAmIDB4ZmYpO1xcclxcbiAgICAgICAgICAgICAgICBtYXRjaF9hdmFpbGFibGUgPSAwO1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICBmbHVzaF9ibG9ja19vbmx5KGZsdXNoID09IFpfRklOSVNIKTtcXHJcXG5cXHJcXG4gICAgICAgICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcXHJcXG4gICAgICAgICAgICAgICAgaWYgKGZsdXNoID09IFpfRklOSVNIKVxcclxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEZpbmlzaFN0YXJ0ZWQ7XFxyXFxuICAgICAgICAgICAgICAgIGVsc2VcXHJcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBOZWVkTW9yZTtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgcmV0dXJuIGZsdXNoID09IFpfRklOSVNIID8gRmluaXNoRG9uZSA6IEJsb2NrRG9uZTtcXHJcXG4gICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgIGZ1bmN0aW9uIGRlZmxhdGVSZXNldChzdHJtKSB7XFxyXFxuICAgICAgICAgICAgc3RybS50b3RhbF9pbiA9IHN0cm0udG90YWxfb3V0ID0gMDtcXHJcXG4gICAgICAgICAgICBzdHJtLm1zZyA9IG51bGw7IC8vXFxyXFxuXFxyXFxuICAgICAgICAgICAgdGhhdC5wZW5kaW5nID0gMDtcXHJcXG4gICAgICAgICAgICB0aGF0LnBlbmRpbmdfb3V0ID0gMDtcXHJcXG5cXHJcXG4gICAgICAgICAgICBzdGF0dXMgPSBCVVNZX1NUQVRFO1xcclxcblxcclxcbiAgICAgICAgICAgIGxhc3RfZmx1c2ggPSBaX05PX0ZMVVNIO1xcclxcblxcclxcbiAgICAgICAgICAgIHRyX2luaXQoKTtcXHJcXG4gICAgICAgICAgICBsbV9pbml0KCk7XFxyXFxuICAgICAgICAgICAgcmV0dXJuIFpfT0s7XFxyXFxuICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICB0aGF0LmRlZmxhdGVJbml0ID0gZnVuY3Rpb24oc3RybSwgX2xldmVsLCBiaXRzLCBfbWV0aG9kLCBtZW1MZXZlbCwgX3N0cmF0ZWd5KSB7XFxyXFxuICAgICAgICAgICAgaWYgKCFfbWV0aG9kKVxcclxcbiAgICAgICAgICAgICAgICBfbWV0aG9kID0gWl9ERUZMQVRFRDtcXHJcXG4gICAgICAgICAgICBpZiAoIW1lbUxldmVsKVxcclxcbiAgICAgICAgICAgICAgICBtZW1MZXZlbCA9IERFRl9NRU1fTEVWRUw7XFxyXFxuICAgICAgICAgICAgaWYgKCFfc3RyYXRlZ3kpXFxyXFxuICAgICAgICAgICAgICAgIF9zdHJhdGVneSA9IFpfREVGQVVMVF9TVFJBVEVHWTtcXHJcXG5cXHJcXG4gICAgICAgICAgICAvLyBieXRlW10gbXlfdmVyc2lvbj1aTElCX1ZFUlNJT047XFxyXFxuXFxyXFxuICAgICAgICAgICAgLy9cXHJcXG4gICAgICAgICAgICAvLyBpZiAoIXZlcnNpb24gfHwgdmVyc2lvblswXSAhPSBteV92ZXJzaW9uWzBdXFxyXFxuICAgICAgICAgICAgLy8gfHwgc3RyZWFtX3NpemUgIT0gc2l6ZW9mKHpfc3RyZWFtKSkge1xcclxcbiAgICAgICAgICAgIC8vIHJldHVybiBaX1ZFUlNJT05fRVJST1I7XFxyXFxuICAgICAgICAgICAgLy8gfVxcclxcblxcclxcbiAgICAgICAgICAgIHN0cm0ubXNnID0gbnVsbDtcXHJcXG5cXHJcXG4gICAgICAgICAgICBpZiAoX2xldmVsID09IFpfREVGQVVMVF9DT01QUkVTU0lPTilcXHJcXG4gICAgICAgICAgICAgICAgX2xldmVsID0gNjtcXHJcXG5cXHJcXG4gICAgICAgICAgICBpZiAobWVtTGV2ZWwgPCAxIHx8IG1lbUxldmVsID4gTUFYX01FTV9MRVZFTCB8fCBfbWV0aG9kICE9IFpfREVGTEFURUQgfHwgYml0cyA8IDkgfHwgYml0cyA+IDE1IHx8IF9sZXZlbCA8IDAgfHwgX2xldmVsID4gOSB8fCBfc3RyYXRlZ3kgPCAwXFxyXFxuICAgICAgICAgICAgICAgICAgICB8fCBfc3RyYXRlZ3kgPiBaX0hVRkZNQU5fT05MWSkge1xcclxcbiAgICAgICAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XFxyXFxuICAgICAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgICAgIHN0cm0uZHN0YXRlID0gdGhhdDtcXHJcXG5cXHJcXG4gICAgICAgICAgICB3X2JpdHMgPSBiaXRzO1xcclxcbiAgICAgICAgICAgIHdfc2l6ZSA9IDEgPDwgd19iaXRzO1xcclxcbiAgICAgICAgICAgIHdfbWFzayA9IHdfc2l6ZSAtIDE7XFxyXFxuXFxyXFxuICAgICAgICAgICAgaGFzaF9iaXRzID0gbWVtTGV2ZWwgKyA3O1xcclxcbiAgICAgICAgICAgIGhhc2hfc2l6ZSA9IDEgPDwgaGFzaF9iaXRzO1xcclxcbiAgICAgICAgICAgIGhhc2hfbWFzayA9IGhhc2hfc2l6ZSAtIDE7XFxyXFxuICAgICAgICAgICAgaGFzaF9zaGlmdCA9IE1hdGguZmxvb3IoKGhhc2hfYml0cyArIE1JTl9NQVRDSCAtIDEpIC8gTUlOX01BVENIKTtcXHJcXG5cXHJcXG4gICAgICAgICAgICB3aW5kb3cgPSBuZXcgVWludDhBcnJheSh3X3NpemUgKiAyKTtcXHJcXG4gICAgICAgICAgICBwcmV2ID0gW107XFxyXFxuICAgICAgICAgICAgaGVhZCA9IFtdO1xcclxcblxcclxcbiAgICAgICAgICAgIGxpdF9idWZzaXplID0gMSA8PCAobWVtTGV2ZWwgKyA2KTsgLy8gMTZLIGVsZW1lbnRzIGJ5IGRlZmF1bHRcXHJcXG5cXHJcXG4gICAgICAgICAgICAvLyBXZSBvdmVybGF5IHBlbmRpbmdfYnVmIGFuZCBkX2J1ZitsX2J1Zi4gVGhpcyB3b3JrcyBzaW5jZSB0aGUgYXZlcmFnZVxcclxcbiAgICAgICAgICAgIC8vIG91dHB1dCBzaXplIGZvciAobGVuZ3RoLGRpc3RhbmNlKSBjb2RlcyBpcyA8PSAyNCBiaXRzLlxcclxcbiAgICAgICAgICAgIHRoYXQucGVuZGluZ19idWYgPSBuZXcgVWludDhBcnJheShsaXRfYnVmc2l6ZSAqIDQpO1xcclxcbiAgICAgICAgICAgIHBlbmRpbmdfYnVmX3NpemUgPSBsaXRfYnVmc2l6ZSAqIDQ7XFxyXFxuXFxyXFxuICAgICAgICAgICAgZF9idWYgPSBNYXRoLmZsb29yKGxpdF9idWZzaXplIC8gMik7XFxyXFxuICAgICAgICAgICAgbF9idWYgPSAoMSArIDIpICogbGl0X2J1ZnNpemU7XFxyXFxuXFxyXFxuICAgICAgICAgICAgbGV2ZWwgPSBfbGV2ZWw7XFxyXFxuXFxyXFxuICAgICAgICAgICAgc3RyYXRlZ3kgPSBfc3RyYXRlZ3k7XFxyXFxuICAgICAgICAgICAgbWV0aG9kID0gX21ldGhvZCAmIDB4ZmY7XFxyXFxuXFxyXFxuICAgICAgICAgICAgcmV0dXJuIGRlZmxhdGVSZXNldChzdHJtKTtcXHJcXG4gICAgICAgIH07XFxyXFxuXFxyXFxuICAgICAgICB0aGF0LmRlZmxhdGVFbmQgPSBmdW5jdGlvbigpIHtcXHJcXG4gICAgICAgICAgICBpZiAoc3RhdHVzICE9IElOSVRfU1RBVEUgJiYgc3RhdHVzICE9IEJVU1lfU1RBVEUgJiYgc3RhdHVzICE9IEZJTklTSF9TVEFURSkge1xcclxcbiAgICAgICAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIC8vIERlYWxsb2NhdGUgaW4gcmV2ZXJzZSBvcmRlciBvZiBhbGxvY2F0aW9uczpcXHJcXG4gICAgICAgICAgICB0aGF0LnBlbmRpbmdfYnVmID0gbnVsbDtcXHJcXG4gICAgICAgICAgICBoZWFkID0gbnVsbDtcXHJcXG4gICAgICAgICAgICBwcmV2ID0gbnVsbDtcXHJcXG4gICAgICAgICAgICB3aW5kb3cgPSBudWxsO1xcclxcbiAgICAgICAgICAgIC8vIGZyZWVcXHJcXG4gICAgICAgICAgICB0aGF0LmRzdGF0ZSA9IG51bGw7XFxyXFxuICAgICAgICAgICAgcmV0dXJuIHN0YXR1cyA9PSBCVVNZX1NUQVRFID8gWl9EQVRBX0VSUk9SIDogWl9PSztcXHJcXG4gICAgICAgIH07XFxyXFxuXFxyXFxuICAgICAgICB0aGF0LmRlZmxhdGVQYXJhbXMgPSBmdW5jdGlvbihzdHJtLCBfbGV2ZWwsIF9zdHJhdGVneSkge1xcclxcbiAgICAgICAgICAgIHZhciBlcnIgPSBaX09LO1xcclxcblxcclxcbiAgICAgICAgICAgIGlmIChfbGV2ZWwgPT0gWl9ERUZBVUxUX0NPTVBSRVNTSU9OKSB7XFxyXFxuICAgICAgICAgICAgICAgIF9sZXZlbCA9IDY7XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIGlmIChfbGV2ZWwgPCAwIHx8IF9sZXZlbCA+IDkgfHwgX3N0cmF0ZWd5IDwgMCB8fCBfc3RyYXRlZ3kgPiBaX0hVRkZNQU5fT05MWSkge1xcclxcbiAgICAgICAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XFxyXFxuICAgICAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgICAgIGlmIChjb25maWdfdGFibGVbbGV2ZWxdLmZ1bmMgIT0gY29uZmlnX3RhYmxlW19sZXZlbF0uZnVuYyAmJiBzdHJtLnRvdGFsX2luICE9PSAwKSB7XFxyXFxuICAgICAgICAgICAgICAgIC8vIEZsdXNoIHRoZSBsYXN0IGJ1ZmZlcjpcXHJcXG4gICAgICAgICAgICAgICAgZXJyID0gc3RybS5kZWZsYXRlKFpfUEFSVElBTF9GTFVTSCk7XFxyXFxuICAgICAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgICAgIGlmIChsZXZlbCAhPSBfbGV2ZWwpIHtcXHJcXG4gICAgICAgICAgICAgICAgbGV2ZWwgPSBfbGV2ZWw7XFxyXFxuICAgICAgICAgICAgICAgIG1heF9sYXp5X21hdGNoID0gY29uZmlnX3RhYmxlW2xldmVsXS5tYXhfbGF6eTtcXHJcXG4gICAgICAgICAgICAgICAgZ29vZF9tYXRjaCA9IGNvbmZpZ190YWJsZVtsZXZlbF0uZ29vZF9sZW5ndGg7XFxyXFxuICAgICAgICAgICAgICAgIG5pY2VfbWF0Y2ggPSBjb25maWdfdGFibGVbbGV2ZWxdLm5pY2VfbGVuZ3RoO1xcclxcbiAgICAgICAgICAgICAgICBtYXhfY2hhaW5fbGVuZ3RoID0gY29uZmlnX3RhYmxlW2xldmVsXS5tYXhfY2hhaW47XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIHN0cmF0ZWd5ID0gX3N0cmF0ZWd5O1xcclxcbiAgICAgICAgICAgIHJldHVybiBlcnI7XFxyXFxuICAgICAgICB9O1xcclxcblxcclxcbiAgICAgICAgdGhhdC5kZWZsYXRlU2V0RGljdGlvbmFyeSA9IGZ1bmN0aW9uKHN0cm0sIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgpIHtcXHJcXG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gZGljdExlbmd0aDtcXHJcXG4gICAgICAgICAgICB2YXIgbiwgaW5kZXggPSAwO1xcclxcblxcclxcbiAgICAgICAgICAgIGlmICghZGljdGlvbmFyeSB8fCBzdGF0dXMgIT0gSU5JVF9TVEFURSlcXHJcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xcclxcblxcclxcbiAgICAgICAgICAgIGlmIChsZW5ndGggPCBNSU5fTUFUQ0gpXFxyXFxuICAgICAgICAgICAgICAgIHJldHVybiBaX09LO1xcclxcbiAgICAgICAgICAgIGlmIChsZW5ndGggPiB3X3NpemUgLSBNSU5fTE9PS0FIRUFEKSB7XFxyXFxuICAgICAgICAgICAgICAgIGxlbmd0aCA9IHdfc2l6ZSAtIE1JTl9MT09LQUhFQUQ7XFxyXFxuICAgICAgICAgICAgICAgIGluZGV4ID0gZGljdExlbmd0aCAtIGxlbmd0aDsgLy8gdXNlIHRoZSB0YWlsIG9mIHRoZSBkaWN0aW9uYXJ5XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIHdpbmRvdy5zZXQoZGljdGlvbmFyeS5zdWJhcnJheShpbmRleCwgaW5kZXggKyBsZW5ndGgpLCAwKTtcXHJcXG5cXHJcXG4gICAgICAgICAgICBzdHJzdGFydCA9IGxlbmd0aDtcXHJcXG4gICAgICAgICAgICBibG9ja19zdGFydCA9IGxlbmd0aDtcXHJcXG5cXHJcXG4gICAgICAgICAgICAvLyBJbnNlcnQgYWxsIHN0cmluZ3MgaW4gdGhlIGhhc2ggdGFibGUgKGV4Y2VwdCBmb3IgdGhlIGxhc3QgdHdvIGJ5dGVzKS5cXHJcXG4gICAgICAgICAgICAvLyBzLT5sb29rYWhlYWQgc3RheXMgbnVsbCwgc28gcy0+aW5zX2ggd2lsbCBiZSByZWNvbXB1dGVkIGF0IHRoZSBuZXh0XFxyXFxuICAgICAgICAgICAgLy8gY2FsbCBvZiBmaWxsX3dpbmRvdy5cXHJcXG5cXHJcXG4gICAgICAgICAgICBpbnNfaCA9IHdpbmRvd1swXSAmIDB4ZmY7XFxyXFxuICAgICAgICAgICAgaW5zX2ggPSAoKChpbnNfaCkgPDwgaGFzaF9zaGlmdCkgXiAod2luZG93WzFdICYgMHhmZikpICYgaGFzaF9tYXNrO1xcclxcblxcclxcbiAgICAgICAgICAgIGZvciAobiA9IDA7IG4gPD0gbGVuZ3RoIC0gTUlOX01BVENIOyBuKyspIHtcXHJcXG4gICAgICAgICAgICAgICAgaW5zX2ggPSAoKChpbnNfaCkgPDwgaGFzaF9zaGlmdCkgXiAod2luZG93WyhuKSArIChNSU5fTUFUQ0ggLSAxKV0gJiAweGZmKSkgJiBoYXNoX21hc2s7XFxyXFxuICAgICAgICAgICAgICAgIHByZXZbbiAmIHdfbWFza10gPSBoZWFkW2luc19oXTtcXHJcXG4gICAgICAgICAgICAgICAgaGVhZFtpbnNfaF0gPSBuO1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICByZXR1cm4gWl9PSztcXHJcXG4gICAgICAgIH07XFxyXFxuXFxyXFxuICAgICAgICB0aGF0LmRlZmxhdGUgPSBmdW5jdGlvbihfc3RybSwgZmx1c2gpIHtcXHJcXG4gICAgICAgICAgICB2YXIgaSwgaGVhZGVyLCBsZXZlbF9mbGFncywgb2xkX2ZsdXNoLCBic3RhdGU7XFxyXFxuXFxyXFxuICAgICAgICAgICAgaWYgKGZsdXNoID4gWl9GSU5JU0ggfHwgZmx1c2ggPCAwKSB7XFxyXFxuICAgICAgICAgICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgaWYgKCFfc3RybS5uZXh0X291dCB8fCAoIV9zdHJtLm5leHRfaW4gJiYgX3N0cm0uYXZhaWxfaW4gIT09IDApIHx8IChzdGF0dXMgPT0gRklOSVNIX1NUQVRFICYmIGZsdXNoICE9IFpfRklOSVNIKSkge1xcclxcbiAgICAgICAgICAgICAgICBfc3RybS5tc2cgPSB6X2Vycm1zZ1taX05FRURfRElDVCAtIChaX1NUUkVBTV9FUlJPUildO1xcclxcbiAgICAgICAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIGlmIChfc3RybS5hdmFpbF9vdXQgPT09IDApIHtcXHJcXG4gICAgICAgICAgICAgICAgX3N0cm0ubXNnID0gel9lcnJtc2dbWl9ORUVEX0RJQ1QgLSAoWl9CVUZfRVJST1IpXTtcXHJcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFpfQlVGX0VSUk9SO1xcclxcbiAgICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICBzdHJtID0gX3N0cm07IC8vIGp1c3QgaW4gY2FzZVxcclxcbiAgICAgICAgICAgIG9sZF9mbHVzaCA9IGxhc3RfZmx1c2g7XFxyXFxuICAgICAgICAgICAgbGFzdF9mbHVzaCA9IGZsdXNoO1xcclxcblxcclxcbiAgICAgICAgICAgIC8vIFdyaXRlIHRoZSB6bGliIGhlYWRlclxcclxcbiAgICAgICAgICAgIGlmIChzdGF0dXMgPT0gSU5JVF9TVEFURSkge1xcclxcbiAgICAgICAgICAgICAgICBoZWFkZXIgPSAoWl9ERUZMQVRFRCArICgod19iaXRzIC0gOCkgPDwgNCkpIDw8IDg7XFxyXFxuICAgICAgICAgICAgICAgIGxldmVsX2ZsYWdzID0gKChsZXZlbCAtIDEpICYgMHhmZikgPj4gMTtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgaWYgKGxldmVsX2ZsYWdzID4gMylcXHJcXG4gICAgICAgICAgICAgICAgICAgIGxldmVsX2ZsYWdzID0gMztcXHJcXG4gICAgICAgICAgICAgICAgaGVhZGVyIHw9IChsZXZlbF9mbGFncyA8PCA2KTtcXHJcXG4gICAgICAgICAgICAgICAgaWYgKHN0cnN0YXJ0ICE9PSAwKVxcclxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyIHw9IFBSRVNFVF9ESUNUO1xcclxcbiAgICAgICAgICAgICAgICBoZWFkZXIgKz0gMzEgLSAoaGVhZGVyICUgMzEpO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICBzdGF0dXMgPSBCVVNZX1NUQVRFO1xcclxcbiAgICAgICAgICAgICAgICBwdXRTaG9ydE1TQihoZWFkZXIpO1xcclxcbiAgICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICAvLyBGbHVzaCBhcyBtdWNoIHBlbmRpbmcgb3V0cHV0IGFzIHBvc3NpYmxlXFxyXFxuICAgICAgICAgICAgaWYgKHRoYXQucGVuZGluZyAhPT0gMCkge1xcclxcbiAgICAgICAgICAgICAgICBzdHJtLmZsdXNoX3BlbmRpbmcoKTtcXHJcXG4gICAgICAgICAgICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcXFwiIGF2YWlsX291dD09MFxcXCIpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgLy8gU2luY2UgYXZhaWxfb3V0IGlzIDAsIGRlZmxhdGUgd2lsbCBiZSBjYWxsZWQgYWdhaW4gd2l0aFxcclxcbiAgICAgICAgICAgICAgICAgICAgLy8gbW9yZSBvdXRwdXQgc3BhY2UsIGJ1dCBwb3NzaWJseSB3aXRoIGJvdGggcGVuZGluZyBhbmRcXHJcXG4gICAgICAgICAgICAgICAgICAgIC8vIGF2YWlsX2luIGVxdWFsIHRvIHplcm8uIFRoZXJlIHdvbid0IGJlIGFueXRoaW5nIHRvIGRvLFxcclxcbiAgICAgICAgICAgICAgICAgICAgLy8gYnV0IHRoaXMgaXMgbm90IGFuIGVycm9yIHNpdHVhdGlvbiBzbyBtYWtlIHN1cmUgd2VcXHJcXG4gICAgICAgICAgICAgICAgICAgIC8vIHJldHVybiBPSyBpbnN0ZWFkIG9mIEJVRl9FUlJPUiBhdCBuZXh0IGNhbGwgb2YgZGVmbGF0ZTpcXHJcXG4gICAgICAgICAgICAgICAgICAgIGxhc3RfZmx1c2ggPSAtMTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBaX09LO1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGVyZSBpcyBzb21ldGhpbmcgdG8gZG8gYW5kIGF2b2lkIGR1cGxpY2F0ZVxcclxcbiAgICAgICAgICAgICAgICAvLyBjb25zZWN1dGl2ZVxcclxcbiAgICAgICAgICAgICAgICAvLyBmbHVzaGVzLiBGb3IgcmVwZWF0ZWQgYW5kIHVzZWxlc3MgY2FsbHMgd2l0aCBaX0ZJTklTSCwgd2Uga2VlcFxcclxcbiAgICAgICAgICAgICAgICAvLyByZXR1cm5pbmcgWl9TVFJFQU1fRU5EIGluc3RlYWQgb2YgWl9CVUZGX0VSUk9SLlxcclxcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RybS5hdmFpbF9pbiA9PT0gMCAmJiBmbHVzaCA8PSBvbGRfZmx1c2ggJiYgZmx1c2ggIT0gWl9GSU5JU0gpIHtcXHJcXG4gICAgICAgICAgICAgICAgc3RybS5tc2cgPSB6X2Vycm1zZ1taX05FRURfRElDVCAtIChaX0JVRl9FUlJPUildO1xcclxcbiAgICAgICAgICAgICAgICByZXR1cm4gWl9CVUZfRVJST1I7XFxyXFxuICAgICAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgICAgIC8vIFVzZXIgbXVzdCBub3QgcHJvdmlkZSBtb3JlIGlucHV0IGFmdGVyIHRoZSBmaXJzdCBGSU5JU0g6XFxyXFxuICAgICAgICAgICAgaWYgKHN0YXR1cyA9PSBGSU5JU0hfU1RBVEUgJiYgc3RybS5hdmFpbF9pbiAhPT0gMCkge1xcclxcbiAgICAgICAgICAgICAgICBfc3RybS5tc2cgPSB6X2Vycm1zZ1taX05FRURfRElDVCAtIChaX0JVRl9FUlJPUildO1xcclxcbiAgICAgICAgICAgICAgICByZXR1cm4gWl9CVUZfRVJST1I7XFxyXFxuICAgICAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgICAgIC8vIFN0YXJ0IGEgbmV3IGJsb2NrIG9yIGNvbnRpbnVlIHRoZSBjdXJyZW50IG9uZS5cXHJcXG4gICAgICAgICAgICBpZiAoc3RybS5hdmFpbF9pbiAhPT0gMCB8fCBsb29rYWhlYWQgIT09IDAgfHwgKGZsdXNoICE9IFpfTk9fRkxVU0ggJiYgc3RhdHVzICE9IEZJTklTSF9TVEFURSkpIHtcXHJcXG4gICAgICAgICAgICAgICAgYnN0YXRlID0gLTE7XFxyXFxuICAgICAgICAgICAgICAgIHN3aXRjaCAoY29uZmlnX3RhYmxlW2xldmVsXS5mdW5jKSB7XFxyXFxuICAgICAgICAgICAgICAgIGNhc2UgU1RPUkVEOlxcclxcbiAgICAgICAgICAgICAgICAgICAgYnN0YXRlID0gZGVmbGF0ZV9zdG9yZWQoZmx1c2gpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxyXFxuICAgICAgICAgICAgICAgIGNhc2UgRkFTVDpcXHJcXG4gICAgICAgICAgICAgICAgICAgIGJzdGF0ZSA9IGRlZmxhdGVfZmFzdChmbHVzaCk7XFxyXFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcXHJcXG4gICAgICAgICAgICAgICAgY2FzZSBTTE9XOlxcclxcbiAgICAgICAgICAgICAgICAgICAgYnN0YXRlID0gZGVmbGF0ZV9zbG93KGZsdXNoKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcclxcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgIGlmIChic3RhdGUgPT0gRmluaXNoU3RhcnRlZCB8fCBic3RhdGUgPT0gRmluaXNoRG9uZSkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzID0gRklOSVNIX1NUQVRFO1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgIGlmIChic3RhdGUgPT0gTmVlZE1vcmUgfHwgYnN0YXRlID09IEZpbmlzaFN0YXJ0ZWQpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RfZmx1c2ggPSAtMTsgLy8gYXZvaWQgQlVGX0VSUk9SIG5leHQgY2FsbCwgc2VlIGFib3ZlXFxyXFxuICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWl9PSztcXHJcXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGZsdXNoICE9IFpfTk9fRkxVU0ggJiYgYXZhaWxfb3V0ID09PSAwLCB0aGUgbmV4dCBjYWxsXFxyXFxuICAgICAgICAgICAgICAgICAgICAvLyBvZiBkZWZsYXRlIHNob3VsZCB1c2UgdGhlIHNhbWUgZmx1c2ggcGFyYW1ldGVyIHRvIG1ha2Ugc3VyZVxcclxcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhhdCB0aGUgZmx1c2ggaXMgY29tcGxldGUuIFNvIHdlIGRvbid0IGhhdmUgdG8gb3V0cHV0IGFuXFxyXFxuICAgICAgICAgICAgICAgICAgICAvLyBlbXB0eSBibG9jayBoZXJlLCB0aGlzIHdpbGwgYmUgZG9uZSBhdCBuZXh0IGNhbGwuIFRoaXMgYWxzb1xcclxcbiAgICAgICAgICAgICAgICAgICAgLy8gZW5zdXJlcyB0aGF0IGZvciBhIHZlcnkgc21hbGwgb3V0cHV0IGJ1ZmZlciwgd2UgZW1pdCBhdCBtb3N0XFxyXFxuICAgICAgICAgICAgICAgICAgICAvLyBvbmUgZW1wdHkgYmxvY2suXFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgaWYgKGJzdGF0ZSA9PSBCbG9ja0RvbmUpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGlmIChmbHVzaCA9PSBaX1BBUlRJQUxfRkxVU0gpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBfdHJfYWxpZ24oKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8vIEZVTExfRkxVU0ggb3IgU1lOQ19GTFVTSFxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIF90cl9zdG9yZWRfYmxvY2soMCwgMCwgZmFsc2UpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZvciBhIGZ1bGwgZmx1c2gsIHRoaXMgZW1wdHkgYmxvY2sgd2lsbCBiZSByZWNvZ25pemVkXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXMgYSBzcGVjaWFsIG1hcmtlciBieSBpbmZsYXRlX3N5bmMoKS5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmx1c2ggPT0gWl9GVUxMX0ZMVVNIKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0YXRlLmhlYWRbcy5oYXNoX3NpemUtMV09MDtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGhhc2hfc2l6ZS8qLTEqLzsgaSsrKVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm9yZ2V0IGhpc3RvcnlcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRbaV0gPSAwO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgICAgIHN0cm0uZmx1c2hfcGVuZGluZygpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdF9mbHVzaCA9IC0xOyAvLyBhdm9pZCBCVUZfRVJST1IgYXQgbmV4dCBjYWxsLCBzZWUgYWJvdmVcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWl9PSztcXHJcXG4gICAgICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICBpZiAoZmx1c2ggIT0gWl9GSU5JU0gpXFxyXFxuICAgICAgICAgICAgICAgIHJldHVybiBaX09LO1xcclxcbiAgICAgICAgICAgIHJldHVybiBaX1NUUkVBTV9FTkQ7XFxyXFxuICAgICAgICB9O1xcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgIC8vIFpTdHJlYW1cXHJcXG5cXHJcXG4gICAgZnVuY3Rpb24gWlN0cmVhbSgpIHtcXHJcXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcXHJcXG4gICAgICAgIHRoYXQubmV4dF9pbl9pbmRleCA9IDA7XFxyXFxuICAgICAgICB0aGF0Lm5leHRfb3V0X2luZGV4ID0gMDtcXHJcXG4gICAgICAgIC8vIHRoYXQubmV4dF9pbjsgLy8gbmV4dCBpbnB1dCBieXRlXFxyXFxuICAgICAgICB0aGF0LmF2YWlsX2luID0gMDsgLy8gbnVtYmVyIG9mIGJ5dGVzIGF2YWlsYWJsZSBhdCBuZXh0X2luXFxyXFxuICAgICAgICB0aGF0LnRvdGFsX2luID0gMDsgLy8gdG90YWwgbmIgb2YgaW5wdXQgYnl0ZXMgcmVhZCBzbyBmYXJcXHJcXG4gICAgICAgIC8vIHRoYXQubmV4dF9vdXQ7IC8vIG5leHQgb3V0cHV0IGJ5dGUgc2hvdWxkIGJlIHB1dCB0aGVyZVxcclxcbiAgICAgICAgdGhhdC5hdmFpbF9vdXQgPSAwOyAvLyByZW1haW5pbmcgZnJlZSBzcGFjZSBhdCBuZXh0X291dFxcclxcbiAgICAgICAgdGhhdC50b3RhbF9vdXQgPSAwOyAvLyB0b3RhbCBuYiBvZiBieXRlcyBvdXRwdXQgc28gZmFyXFxyXFxuICAgICAgICAvLyB0aGF0Lm1zZztcXHJcXG4gICAgICAgIC8vIHRoYXQuZHN0YXRlO1xcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgIFpTdHJlYW0ucHJvdG90eXBlID0ge1xcclxcbiAgICAgICAgZGVmbGF0ZUluaXQgOiBmdW5jdGlvbihsZXZlbCwgYml0cykge1xcclxcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcXHJcXG4gICAgICAgICAgICB0aGF0LmRzdGF0ZSA9IG5ldyBEZWZsYXRlKCk7XFxyXFxuICAgICAgICAgICAgaWYgKCFiaXRzKVxcclxcbiAgICAgICAgICAgICAgICBiaXRzID0gTUFYX0JJVFM7XFxyXFxuICAgICAgICAgICAgcmV0dXJuIHRoYXQuZHN0YXRlLmRlZmxhdGVJbml0KHRoYXQsIGxldmVsLCBiaXRzKTtcXHJcXG4gICAgICAgIH0sXFxyXFxuXFxyXFxuICAgICAgICBkZWZsYXRlIDogZnVuY3Rpb24oZmx1c2gpIHtcXHJcXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XFxyXFxuICAgICAgICAgICAgaWYgKCF0aGF0LmRzdGF0ZSkge1xcclxcbiAgICAgICAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIHJldHVybiB0aGF0LmRzdGF0ZS5kZWZsYXRlKHRoYXQsIGZsdXNoKTtcXHJcXG4gICAgICAgIH0sXFxyXFxuXFxyXFxuICAgICAgICBkZWZsYXRlRW5kIDogZnVuY3Rpb24oKSB7XFxyXFxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xcclxcbiAgICAgICAgICAgIGlmICghdGhhdC5kc3RhdGUpXFxyXFxuICAgICAgICAgICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcXHJcXG4gICAgICAgICAgICB2YXIgcmV0ID0gdGhhdC5kc3RhdGUuZGVmbGF0ZUVuZCgpO1xcclxcbiAgICAgICAgICAgIHRoYXQuZHN0YXRlID0gbnVsbDtcXHJcXG4gICAgICAgICAgICByZXR1cm4gcmV0O1xcclxcbiAgICAgICAgfSxcXHJcXG5cXHJcXG4gICAgICAgIGRlZmxhdGVQYXJhbXMgOiBmdW5jdGlvbihsZXZlbCwgc3RyYXRlZ3kpIHtcXHJcXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XFxyXFxuICAgICAgICAgICAgaWYgKCF0aGF0LmRzdGF0ZSlcXHJcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xcclxcbiAgICAgICAgICAgIHJldHVybiB0aGF0LmRzdGF0ZS5kZWZsYXRlUGFyYW1zKHRoYXQsIGxldmVsLCBzdHJhdGVneSk7XFxyXFxuICAgICAgICB9LFxcclxcblxcclxcbiAgICAgICAgZGVmbGF0ZVNldERpY3Rpb25hcnkgOiBmdW5jdGlvbihkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoKSB7XFxyXFxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xcclxcbiAgICAgICAgICAgIGlmICghdGhhdC5kc3RhdGUpXFxyXFxuICAgICAgICAgICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcXHJcXG4gICAgICAgICAgICByZXR1cm4gdGhhdC5kc3RhdGUuZGVmbGF0ZVNldERpY3Rpb25hcnkodGhhdCwgZGljdGlvbmFyeSwgZGljdExlbmd0aCk7XFxyXFxuICAgICAgICB9LFxcclxcblxcclxcbiAgICAgICAgLy8gUmVhZCBhIG5ldyBidWZmZXIgZnJvbSB0aGUgY3VycmVudCBpbnB1dCBzdHJlYW0sIHVwZGF0ZSB0aGVcXHJcXG4gICAgICAgIC8vIHRvdGFsIG51bWJlciBvZiBieXRlcyByZWFkLiBBbGwgZGVmbGF0ZSgpIGlucHV0IGdvZXMgdGhyb3VnaFxcclxcbiAgICAgICAgLy8gdGhpcyBmdW5jdGlvbiBzbyBzb21lIGFwcGxpY2F0aW9ucyBtYXkgd2lzaCB0byBtb2RpZnkgaXQgdG8gYXZvaWRcXHJcXG4gICAgICAgIC8vIGFsbG9jYXRpbmcgYSBsYXJnZSBzdHJtLT5uZXh0X2luIGJ1ZmZlciBhbmQgY29weWluZyBmcm9tIGl0LlxcclxcbiAgICAgICAgLy8gKFNlZSBhbHNvIGZsdXNoX3BlbmRpbmcoKSkuXFxyXFxuICAgICAgICByZWFkX2J1ZiA6IGZ1bmN0aW9uKGJ1Ziwgc3RhcnQsIHNpemUpIHtcXHJcXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XFxyXFxuICAgICAgICAgICAgdmFyIGxlbiA9IHRoYXQuYXZhaWxfaW47XFxyXFxuICAgICAgICAgICAgaWYgKGxlbiA+IHNpemUpXFxyXFxuICAgICAgICAgICAgICAgIGxlbiA9IHNpemU7XFxyXFxuICAgICAgICAgICAgaWYgKGxlbiA9PT0gMClcXHJcXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XFxyXFxuICAgICAgICAgICAgdGhhdC5hdmFpbF9pbiAtPSBsZW47XFxyXFxuICAgICAgICAgICAgYnVmLnNldCh0aGF0Lm5leHRfaW4uc3ViYXJyYXkodGhhdC5uZXh0X2luX2luZGV4LCB0aGF0Lm5leHRfaW5faW5kZXggKyBsZW4pLCBzdGFydCk7XFxyXFxuICAgICAgICAgICAgdGhhdC5uZXh0X2luX2luZGV4ICs9IGxlbjtcXHJcXG4gICAgICAgICAgICB0aGF0LnRvdGFsX2luICs9IGxlbjtcXHJcXG4gICAgICAgICAgICByZXR1cm4gbGVuO1xcclxcbiAgICAgICAgfSxcXHJcXG5cXHJcXG4gICAgICAgIC8vIEZsdXNoIGFzIG11Y2ggcGVuZGluZyBvdXRwdXQgYXMgcG9zc2libGUuIEFsbCBkZWZsYXRlKCkgb3V0cHV0IGdvZXNcXHJcXG4gICAgICAgIC8vIHRocm91Z2ggdGhpcyBmdW5jdGlvbiBzbyBzb21lIGFwcGxpY2F0aW9ucyBtYXkgd2lzaCB0byBtb2RpZnkgaXRcXHJcXG4gICAgICAgIC8vIHRvIGF2b2lkIGFsbG9jYXRpbmcgYSBsYXJnZSBzdHJtLT5uZXh0X291dCBidWZmZXIgYW5kIGNvcHlpbmcgaW50byBpdC5cXHJcXG4gICAgICAgIC8vIChTZWUgYWxzbyByZWFkX2J1ZigpKS5cXHJcXG4gICAgICAgIGZsdXNoX3BlbmRpbmcgOiBmdW5jdGlvbigpIHtcXHJcXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XFxyXFxuICAgICAgICAgICAgdmFyIGxlbiA9IHRoYXQuZHN0YXRlLnBlbmRpbmc7XFxyXFxuXFxyXFxuICAgICAgICAgICAgaWYgKGxlbiA+IHRoYXQuYXZhaWxfb3V0KVxcclxcbiAgICAgICAgICAgICAgICBsZW4gPSB0aGF0LmF2YWlsX291dDtcXHJcXG4gICAgICAgICAgICBpZiAobGVuID09PSAwKVxcclxcbiAgICAgICAgICAgICAgICByZXR1cm47XFxyXFxuXFxyXFxuICAgICAgICAgICAgLy8gaWYgKHRoYXQuZHN0YXRlLnBlbmRpbmdfYnVmLmxlbmd0aCA8PSB0aGF0LmRzdGF0ZS5wZW5kaW5nX291dCB8fCB0aGF0Lm5leHRfb3V0Lmxlbmd0aCA8PSB0aGF0Lm5leHRfb3V0X2luZGV4XFxyXFxuICAgICAgICAgICAgLy8gfHwgdGhhdC5kc3RhdGUucGVuZGluZ19idWYubGVuZ3RoIDwgKHRoYXQuZHN0YXRlLnBlbmRpbmdfb3V0ICsgbGVuKSB8fCB0aGF0Lm5leHRfb3V0Lmxlbmd0aCA8ICh0aGF0Lm5leHRfb3V0X2luZGV4ICtcXHJcXG4gICAgICAgICAgICAvLyBsZW4pKSB7XFxyXFxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2codGhhdC5kc3RhdGUucGVuZGluZ19idWYubGVuZ3RoICsgXFxcIiwgXFxcIiArIHRoYXQuZHN0YXRlLnBlbmRpbmdfb3V0ICsgXFxcIiwgXFxcIiArIHRoYXQubmV4dF9vdXQubGVuZ3RoICsgXFxcIiwgXFxcIiArXFxyXFxuICAgICAgICAgICAgLy8gdGhhdC5uZXh0X291dF9pbmRleCArIFxcXCIsIFxcXCIgKyBsZW4pO1xcclxcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFxcXCJhdmFpbF9vdXQ9XFxcIiArIHRoYXQuYXZhaWxfb3V0KTtcXHJcXG4gICAgICAgICAgICAvLyB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgdGhhdC5uZXh0X291dC5zZXQodGhhdC5kc3RhdGUucGVuZGluZ19idWYuc3ViYXJyYXkodGhhdC5kc3RhdGUucGVuZGluZ19vdXQsIHRoYXQuZHN0YXRlLnBlbmRpbmdfb3V0ICsgbGVuKSwgdGhhdC5uZXh0X291dF9pbmRleCk7XFxyXFxuXFxyXFxuICAgICAgICAgICAgdGhhdC5uZXh0X291dF9pbmRleCArPSBsZW47XFxyXFxuICAgICAgICAgICAgdGhhdC5kc3RhdGUucGVuZGluZ19vdXQgKz0gbGVuO1xcclxcbiAgICAgICAgICAgIHRoYXQudG90YWxfb3V0ICs9IGxlbjtcXHJcXG4gICAgICAgICAgICB0aGF0LmF2YWlsX291dCAtPSBsZW47XFxyXFxuICAgICAgICAgICAgdGhhdC5kc3RhdGUucGVuZGluZyAtPSBsZW47XFxyXFxuICAgICAgICAgICAgaWYgKHRoYXQuZHN0YXRlLnBlbmRpbmcgPT09IDApIHtcXHJcXG4gICAgICAgICAgICAgICAgdGhhdC5kc3RhdGUucGVuZGluZ19vdXQgPSAwO1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH1cXHJcXG4gICAgfTtcXHJcXG5cXHJcXG4gICAgLy8gRGVmbGF0ZXJcXHJcXG5cXHJcXG4gICAgZnVuY3Rpb24gRGVmbGF0ZXIob3B0aW9ucykge1xcclxcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xcclxcbiAgICAgICAgdmFyIHogPSBuZXcgWlN0cmVhbSgpO1xcclxcbiAgICAgICAgdmFyIGJ1ZnNpemUgPSA1MTI7XFxyXFxuICAgICAgICB2YXIgZmx1c2ggPSBaX05PX0ZMVVNIO1xcclxcbiAgICAgICAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGJ1ZnNpemUpO1xcclxcbiAgICAgICAgdmFyIGxldmVsID0gb3B0aW9ucyA/IG9wdGlvbnMubGV2ZWwgOiBaX0RFRkFVTFRfQ09NUFJFU1NJT047XFxyXFxuICAgICAgICBpZiAodHlwZW9mIGxldmVsID09IFxcXCJ1bmRlZmluZWRcXFwiKVxcclxcbiAgICAgICAgICAgIGxldmVsID0gWl9ERUZBVUxUX0NPTVBSRVNTSU9OO1xcclxcbiAgICAgICAgei5kZWZsYXRlSW5pdChsZXZlbCk7XFxyXFxuICAgICAgICB6Lm5leHRfb3V0ID0gYnVmO1xcclxcblxcclxcbiAgICAgICAgdGhhdC5hcHBlbmQgPSBmdW5jdGlvbihkYXRhLCBvbnByb2dyZXNzKSB7XFxyXFxuICAgICAgICAgICAgdmFyIGVyciwgYnVmZmVycyA9IFtdLCBsYXN0SW5kZXggPSAwLCBidWZmZXJJbmRleCA9IDAsIGJ1ZmZlclNpemUgPSAwLCBhcnJheTtcXHJcXG4gICAgICAgICAgICBpZiAoIWRhdGEubGVuZ3RoKVxcclxcbiAgICAgICAgICAgICAgICByZXR1cm47XFxyXFxuICAgICAgICAgICAgei5uZXh0X2luX2luZGV4ID0gMDtcXHJcXG4gICAgICAgICAgICB6Lm5leHRfaW4gPSBkYXRhO1xcclxcbiAgICAgICAgICAgIHouYXZhaWxfaW4gPSBkYXRhLmxlbmd0aDtcXHJcXG4gICAgICAgICAgICBkbyB7XFxyXFxuICAgICAgICAgICAgICAgIHoubmV4dF9vdXRfaW5kZXggPSAwO1xcclxcbiAgICAgICAgICAgICAgICB6LmF2YWlsX291dCA9IGJ1ZnNpemU7XFxyXFxuICAgICAgICAgICAgICAgIGVyciA9IHouZGVmbGF0ZShmbHVzaCk7XFxyXFxuICAgICAgICAgICAgICAgIGlmIChlcnIgIT0gWl9PSylcXHJcXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcXFwiZGVmbGF0aW5nOiBcXFwiICsgei5tc2cpO1xcclxcbiAgICAgICAgICAgICAgICBpZiAoei5uZXh0X291dF9pbmRleClcXHJcXG4gICAgICAgICAgICAgICAgICAgIGlmICh6Lm5leHRfb3V0X2luZGV4ID09IGJ1ZnNpemUpXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVycy5wdXNoKG5ldyBVaW50OEFycmF5KGJ1ZikpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlcnMucHVzaChuZXcgVWludDhBcnJheShidWYuc3ViYXJyYXkoMCwgei5uZXh0X291dF9pbmRleCkpKTtcXHJcXG4gICAgICAgICAgICAgICAgYnVmZmVyU2l6ZSArPSB6Lm5leHRfb3V0X2luZGV4O1xcclxcbiAgICAgICAgICAgICAgICBpZiAob25wcm9ncmVzcyAmJiB6Lm5leHRfaW5faW5kZXggPiAwICYmIHoubmV4dF9pbl9pbmRleCAhPSBsYXN0SW5kZXgpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIG9ucHJvZ3Jlc3Moei5uZXh0X2luX2luZGV4KTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGxhc3RJbmRleCA9IHoubmV4dF9pbl9pbmRleDtcXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIH0gd2hpbGUgKHouYXZhaWxfaW4gPiAwIHx8IHouYXZhaWxfb3V0ID09PSAwKTtcXHJcXG4gICAgICAgICAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlclNpemUpO1xcclxcbiAgICAgICAgICAgIGJ1ZmZlcnMuZm9yRWFjaChmdW5jdGlvbihjaHVuaykge1xcclxcbiAgICAgICAgICAgICAgICBhcnJheS5zZXQoY2h1bmssIGJ1ZmZlckluZGV4KTtcXHJcXG4gICAgICAgICAgICAgICAgYnVmZmVySW5kZXggKz0gY2h1bmsubGVuZ3RoO1xcclxcbiAgICAgICAgICAgIH0pO1xcclxcbiAgICAgICAgICAgIHJldHVybiBhcnJheTtcXHJcXG4gICAgICAgIH07XFxyXFxuICAgICAgICB0aGF0LmZsdXNoID0gZnVuY3Rpb24oKSB7XFxyXFxuICAgICAgICAgICAgdmFyIGVyciwgYnVmZmVycyA9IFtdLCBidWZmZXJJbmRleCA9IDAsIGJ1ZmZlclNpemUgPSAwLCBhcnJheTtcXHJcXG4gICAgICAgICAgICBkbyB7XFxyXFxuICAgICAgICAgICAgICAgIHoubmV4dF9vdXRfaW5kZXggPSAwO1xcclxcbiAgICAgICAgICAgICAgICB6LmF2YWlsX291dCA9IGJ1ZnNpemU7XFxyXFxuICAgICAgICAgICAgICAgIGVyciA9IHouZGVmbGF0ZShaX0ZJTklTSCk7XFxyXFxuICAgICAgICAgICAgICAgIGlmIChlcnIgIT0gWl9TVFJFQU1fRU5EICYmIGVyciAhPSBaX09LKVxcclxcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxcXCJkZWZsYXRpbmc6IFxcXCIgKyB6Lm1zZyk7XFxyXFxuICAgICAgICAgICAgICAgIGlmIChidWZzaXplIC0gei5hdmFpbF9vdXQgPiAwKVxcclxcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVycy5wdXNoKG5ldyBVaW50OEFycmF5KGJ1Zi5zdWJhcnJheSgwLCB6Lm5leHRfb3V0X2luZGV4KSkpO1xcclxcbiAgICAgICAgICAgICAgICBidWZmZXJTaXplICs9IHoubmV4dF9vdXRfaW5kZXg7XFxyXFxuICAgICAgICAgICAgfSB3aGlsZSAoei5hdmFpbF9pbiA+IDAgfHwgei5hdmFpbF9vdXQgPT09IDApO1xcclxcbiAgICAgICAgICAgIHouZGVmbGF0ZUVuZCgpO1xcclxcbiAgICAgICAgICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyU2l6ZSk7XFxyXFxuICAgICAgICAgICAgYnVmZmVycy5mb3JFYWNoKGZ1bmN0aW9uKGNodW5rKSB7XFxyXFxuICAgICAgICAgICAgICAgIGFycmF5LnNldChjaHVuaywgYnVmZmVySW5kZXgpO1xcclxcbiAgICAgICAgICAgICAgICBidWZmZXJJbmRleCArPSBjaHVuay5sZW5ndGg7XFxyXFxuICAgICAgICAgICAgfSk7XFxyXFxuICAgICAgICAgICAgcmV0dXJuIGFycmF5O1xcclxcbiAgICAgICAgfTtcXHJcXG4gICAgfVxcclxcblxcclxcbiAgICAvLyAnemlwJyBtYXkgbm90IGJlIGRlZmluZWQgaW4gei13b3JrZXIgYW5kIHNvbWUgdGVzdHNcXHJcXG4gICAgdmFyIGVudiA9IGdsb2JhbC56aXAgfHwgZ2xvYmFsO1xcclxcbiAgICBlbnYuRGVmbGF0ZXIgPSBlbnYuX2p6bGliX0RlZmxhdGVyID0gRGVmbGF0ZXI7XFxyXFxufSkodGhpcyk7XCI7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFwiLypcXHJcXG4gQ29weXJpZ2h0IChjKSAyMDEzIEdpbGRhcyBMb3JtZWF1LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxcclxcblxcclxcbiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcXHJcXG4gbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XFxyXFxuXFxyXFxuIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcXHJcXG4gdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cXHJcXG5cXHJcXG4gMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcXHJcXG4gbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluXFxyXFxuIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxcclxcblxcclxcbiAzLiBUaGUgbmFtZXMgb2YgdGhlIGF1dGhvcnMgbWF5IG5vdCBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0c1xcclxcbiBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cXHJcXG5cXHJcXG4gVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBgYEFTIElTJycgQU5EIEFOWSBFWFBSRVNTRUQgT1IgSU1QTElFRCBXQVJSQU5USUVTLFxcclxcbiBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EXFxyXFxuIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBKQ1JBRlQsXFxyXFxuIElOQy4gT1IgQU5ZIENPTlRSSUJVVE9SUyBUTyBUSElTIFNPRlRXQVJFIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsXFxyXFxuIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1RcXHJcXG4gTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsXFxyXFxuIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0ZcXHJcXG4gTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkdcXHJcXG4gTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLFxcclxcbiBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxcclxcbiAqL1xcclxcblxcclxcbi8qXFxyXFxuICogVGhpcyBwcm9ncmFtIGlzIGJhc2VkIG9uIEpabGliIDEuMC4yIHltbmssIEpDcmFmdCxJbmMuXFxyXFxuICogSlpsaWIgaXMgYmFzZWQgb24gemxpYi0xLjEuMywgc28gYWxsIGNyZWRpdCBzaG91bGQgZ28gYXV0aG9yc1xcclxcbiAqIEplYW4tbG91cCBHYWlsbHkoamxvdXBAZ3ppcC5vcmcpIGFuZCBNYXJrIEFkbGVyKG1hZGxlckBhbHVtbmkuY2FsdGVjaC5lZHUpXFxyXFxuICogYW5kIGNvbnRyaWJ1dG9ycyBvZiB6bGliLlxcclxcbiAqL1xcclxcblxcclxcbihmdW5jdGlvbihnbG9iYWwpIHtcXHJcXG4gICAgXFxcInVzZSBzdHJpY3RcXFwiO1xcclxcblxcclxcbiAgICAvLyBHbG9iYWxcXHJcXG4gICAgdmFyIE1BWF9CSVRTID0gMTU7XFxyXFxuXFxyXFxuICAgIHZhciBaX09LID0gMDtcXHJcXG4gICAgdmFyIFpfU1RSRUFNX0VORCA9IDE7XFxyXFxuICAgIHZhciBaX05FRURfRElDVCA9IDI7XFxyXFxuICAgIHZhciBaX1NUUkVBTV9FUlJPUiA9IC0yO1xcclxcbiAgICB2YXIgWl9EQVRBX0VSUk9SID0gLTM7XFxyXFxuICAgIHZhciBaX01FTV9FUlJPUiA9IC00O1xcclxcbiAgICB2YXIgWl9CVUZfRVJST1IgPSAtNTtcXHJcXG5cXHJcXG4gICAgdmFyIGluZmxhdGVfbWFzayA9IFsgMHgwMDAwMDAwMCwgMHgwMDAwMDAwMSwgMHgwMDAwMDAwMywgMHgwMDAwMDAwNywgMHgwMDAwMDAwZiwgMHgwMDAwMDAxZiwgMHgwMDAwMDAzZiwgMHgwMDAwMDA3ZiwgMHgwMDAwMDBmZiwgMHgwMDAwMDFmZiwgMHgwMDAwMDNmZixcXHJcXG4gICAgICAgICAgICAweDAwMDAwN2ZmLCAweDAwMDAwZmZmLCAweDAwMDAxZmZmLCAweDAwMDAzZmZmLCAweDAwMDA3ZmZmLCAweDAwMDBmZmZmIF07XFxyXFxuXFxyXFxuICAgIHZhciBNQU5ZID0gMTQ0MDtcXHJcXG5cXHJcXG4gICAgLy8gSlpsaWIgdmVyc2lvbiA6IFxcXCIxLjAuMlxcXCJcXHJcXG4gICAgdmFyIFpfTk9fRkxVU0ggPSAwO1xcclxcbiAgICB2YXIgWl9GSU5JU0ggPSA0O1xcclxcblxcclxcbiAgICAvLyBJbmZUcmVlXFxyXFxuICAgIHZhciBmaXhlZF9ibCA9IDk7XFxyXFxuICAgIHZhciBmaXhlZF9iZCA9IDU7XFxyXFxuXFxyXFxuICAgIHZhciBmaXhlZF90bCA9IFsgOTYsIDcsIDI1NiwgMCwgOCwgODAsIDAsIDgsIDE2LCA4NCwgOCwgMTE1LCA4MiwgNywgMzEsIDAsIDgsIDExMiwgMCwgOCwgNDgsIDAsIDksIDE5MiwgODAsIDcsIDEwLCAwLCA4LCA5NiwgMCwgOCwgMzIsIDAsIDksIDE2MCwgMCwgOCwgMCxcXHJcXG4gICAgICAgICAgICAwLCA4LCAxMjgsIDAsIDgsIDY0LCAwLCA5LCAyMjQsIDgwLCA3LCA2LCAwLCA4LCA4OCwgMCwgOCwgMjQsIDAsIDksIDE0NCwgODMsIDcsIDU5LCAwLCA4LCAxMjAsIDAsIDgsIDU2LCAwLCA5LCAyMDgsIDgxLCA3LCAxNywgMCwgOCwgMTA0LCAwLCA4LCA0MCxcXHJcXG4gICAgICAgICAgICAwLCA5LCAxNzYsIDAsIDgsIDgsIDAsIDgsIDEzNiwgMCwgOCwgNzIsIDAsIDksIDI0MCwgODAsIDcsIDQsIDAsIDgsIDg0LCAwLCA4LCAyMCwgODUsIDgsIDIyNywgODMsIDcsIDQzLCAwLCA4LCAxMTYsIDAsIDgsIDUyLCAwLCA5LCAyMDAsIDgxLCA3LCAxMyxcXHJcXG4gICAgICAgICAgICAwLCA4LCAxMDAsIDAsIDgsIDM2LCAwLCA5LCAxNjgsIDAsIDgsIDQsIDAsIDgsIDEzMiwgMCwgOCwgNjgsIDAsIDksIDIzMiwgODAsIDcsIDgsIDAsIDgsIDkyLCAwLCA4LCAyOCwgMCwgOSwgMTUyLCA4NCwgNywgODMsIDAsIDgsIDEyNCwgMCwgOCwgNjAsXFxyXFxuICAgICAgICAgICAgMCwgOSwgMjE2LCA4MiwgNywgMjMsIDAsIDgsIDEwOCwgMCwgOCwgNDQsIDAsIDksIDE4NCwgMCwgOCwgMTIsIDAsIDgsIDE0MCwgMCwgOCwgNzYsIDAsIDksIDI0OCwgODAsIDcsIDMsIDAsIDgsIDgyLCAwLCA4LCAxOCwgODUsIDgsIDE2MywgODMsIDcsXFxyXFxuICAgICAgICAgICAgMzUsIDAsIDgsIDExNCwgMCwgOCwgNTAsIDAsIDksIDE5NiwgODEsIDcsIDExLCAwLCA4LCA5OCwgMCwgOCwgMzQsIDAsIDksIDE2NCwgMCwgOCwgMiwgMCwgOCwgMTMwLCAwLCA4LCA2NiwgMCwgOSwgMjI4LCA4MCwgNywgNywgMCwgOCwgOTAsIDAsIDgsXFxyXFxuICAgICAgICAgICAgMjYsIDAsIDksIDE0OCwgODQsIDcsIDY3LCAwLCA4LCAxMjIsIDAsIDgsIDU4LCAwLCA5LCAyMTIsIDgyLCA3LCAxOSwgMCwgOCwgMTA2LCAwLCA4LCA0MiwgMCwgOSwgMTgwLCAwLCA4LCAxMCwgMCwgOCwgMTM4LCAwLCA4LCA3NCwgMCwgOSwgMjQ0LCA4MCxcXHJcXG4gICAgICAgICAgICA3LCA1LCAwLCA4LCA4NiwgMCwgOCwgMjIsIDE5MiwgOCwgMCwgODMsIDcsIDUxLCAwLCA4LCAxMTgsIDAsIDgsIDU0LCAwLCA5LCAyMDQsIDgxLCA3LCAxNSwgMCwgOCwgMTAyLCAwLCA4LCAzOCwgMCwgOSwgMTcyLCAwLCA4LCA2LCAwLCA4LCAxMzQsIDAsXFxyXFxuICAgICAgICAgICAgOCwgNzAsIDAsIDksIDIzNiwgODAsIDcsIDksIDAsIDgsIDk0LCAwLCA4LCAzMCwgMCwgOSwgMTU2LCA4NCwgNywgOTksIDAsIDgsIDEyNiwgMCwgOCwgNjIsIDAsIDksIDIyMCwgODIsIDcsIDI3LCAwLCA4LCAxMTAsIDAsIDgsIDQ2LCAwLCA5LCAxODgsIDAsXFxyXFxuICAgICAgICAgICAgOCwgMTQsIDAsIDgsIDE0MiwgMCwgOCwgNzgsIDAsIDksIDI1MiwgOTYsIDcsIDI1NiwgMCwgOCwgODEsIDAsIDgsIDE3LCA4NSwgOCwgMTMxLCA4MiwgNywgMzEsIDAsIDgsIDExMywgMCwgOCwgNDksIDAsIDksIDE5NCwgODAsIDcsIDEwLCAwLCA4LCA5NyxcXHJcXG4gICAgICAgICAgICAwLCA4LCAzMywgMCwgOSwgMTYyLCAwLCA4LCAxLCAwLCA4LCAxMjksIDAsIDgsIDY1LCAwLCA5LCAyMjYsIDgwLCA3LCA2LCAwLCA4LCA4OSwgMCwgOCwgMjUsIDAsIDksIDE0NiwgODMsIDcsIDU5LCAwLCA4LCAxMjEsIDAsIDgsIDU3LCAwLCA5LCAyMTAsXFxyXFxuICAgICAgICAgICAgODEsIDcsIDE3LCAwLCA4LCAxMDUsIDAsIDgsIDQxLCAwLCA5LCAxNzgsIDAsIDgsIDksIDAsIDgsIDEzNywgMCwgOCwgNzMsIDAsIDksIDI0MiwgODAsIDcsIDQsIDAsIDgsIDg1LCAwLCA4LCAyMSwgODAsIDgsIDI1OCwgODMsIDcsIDQzLCAwLCA4LCAxMTcsXFxyXFxuICAgICAgICAgICAgMCwgOCwgNTMsIDAsIDksIDIwMiwgODEsIDcsIDEzLCAwLCA4LCAxMDEsIDAsIDgsIDM3LCAwLCA5LCAxNzAsIDAsIDgsIDUsIDAsIDgsIDEzMywgMCwgOCwgNjksIDAsIDksIDIzNCwgODAsIDcsIDgsIDAsIDgsIDkzLCAwLCA4LCAyOSwgMCwgOSwgMTU0LFxcclxcbiAgICAgICAgICAgIDg0LCA3LCA4MywgMCwgOCwgMTI1LCAwLCA4LCA2MSwgMCwgOSwgMjE4LCA4MiwgNywgMjMsIDAsIDgsIDEwOSwgMCwgOCwgNDUsIDAsIDksIDE4NiwgMCwgOCwgMTMsIDAsIDgsIDE0MSwgMCwgOCwgNzcsIDAsIDksIDI1MCwgODAsIDcsIDMsIDAsIDgsIDgzLFxcclxcbiAgICAgICAgICAgIDAsIDgsIDE5LCA4NSwgOCwgMTk1LCA4MywgNywgMzUsIDAsIDgsIDExNSwgMCwgOCwgNTEsIDAsIDksIDE5OCwgODEsIDcsIDExLCAwLCA4LCA5OSwgMCwgOCwgMzUsIDAsIDksIDE2NiwgMCwgOCwgMywgMCwgOCwgMTMxLCAwLCA4LCA2NywgMCwgOSwgMjMwLFxcclxcbiAgICAgICAgICAgIDgwLCA3LCA3LCAwLCA4LCA5MSwgMCwgOCwgMjcsIDAsIDksIDE1MCwgODQsIDcsIDY3LCAwLCA4LCAxMjMsIDAsIDgsIDU5LCAwLCA5LCAyMTQsIDgyLCA3LCAxOSwgMCwgOCwgMTA3LCAwLCA4LCA0MywgMCwgOSwgMTgyLCAwLCA4LCAxMSwgMCwgOCwgMTM5LFxcclxcbiAgICAgICAgICAgIDAsIDgsIDc1LCAwLCA5LCAyNDYsIDgwLCA3LCA1LCAwLCA4LCA4NywgMCwgOCwgMjMsIDE5MiwgOCwgMCwgODMsIDcsIDUxLCAwLCA4LCAxMTksIDAsIDgsIDU1LCAwLCA5LCAyMDYsIDgxLCA3LCAxNSwgMCwgOCwgMTAzLCAwLCA4LCAzOSwgMCwgOSwgMTc0LFxcclxcbiAgICAgICAgICAgIDAsIDgsIDcsIDAsIDgsIDEzNSwgMCwgOCwgNzEsIDAsIDksIDIzOCwgODAsIDcsIDksIDAsIDgsIDk1LCAwLCA4LCAzMSwgMCwgOSwgMTU4LCA4NCwgNywgOTksIDAsIDgsIDEyNywgMCwgOCwgNjMsIDAsIDksIDIyMiwgODIsIDcsIDI3LCAwLCA4LCAxMTEsXFxyXFxuICAgICAgICAgICAgMCwgOCwgNDcsIDAsIDksIDE5MCwgMCwgOCwgMTUsIDAsIDgsIDE0MywgMCwgOCwgNzksIDAsIDksIDI1NCwgOTYsIDcsIDI1NiwgMCwgOCwgODAsIDAsIDgsIDE2LCA4NCwgOCwgMTE1LCA4MiwgNywgMzEsIDAsIDgsIDExMiwgMCwgOCwgNDgsIDAsIDksXFxyXFxuICAgICAgICAgICAgMTkzLCA4MCwgNywgMTAsIDAsIDgsIDk2LCAwLCA4LCAzMiwgMCwgOSwgMTYxLCAwLCA4LCAwLCAwLCA4LCAxMjgsIDAsIDgsIDY0LCAwLCA5LCAyMjUsIDgwLCA3LCA2LCAwLCA4LCA4OCwgMCwgOCwgMjQsIDAsIDksIDE0NSwgODMsIDcsIDU5LCAwLCA4LFxcclxcbiAgICAgICAgICAgIDEyMCwgMCwgOCwgNTYsIDAsIDksIDIwOSwgODEsIDcsIDE3LCAwLCA4LCAxMDQsIDAsIDgsIDQwLCAwLCA5LCAxNzcsIDAsIDgsIDgsIDAsIDgsIDEzNiwgMCwgOCwgNzIsIDAsIDksIDI0MSwgODAsIDcsIDQsIDAsIDgsIDg0LCAwLCA4LCAyMCwgODUsIDgsXFxyXFxuICAgICAgICAgICAgMjI3LCA4MywgNywgNDMsIDAsIDgsIDExNiwgMCwgOCwgNTIsIDAsIDksIDIwMSwgODEsIDcsIDEzLCAwLCA4LCAxMDAsIDAsIDgsIDM2LCAwLCA5LCAxNjksIDAsIDgsIDQsIDAsIDgsIDEzMiwgMCwgOCwgNjgsIDAsIDksIDIzMywgODAsIDcsIDgsIDAsIDgsXFxyXFxuICAgICAgICAgICAgOTIsIDAsIDgsIDI4LCAwLCA5LCAxNTMsIDg0LCA3LCA4MywgMCwgOCwgMTI0LCAwLCA4LCA2MCwgMCwgOSwgMjE3LCA4MiwgNywgMjMsIDAsIDgsIDEwOCwgMCwgOCwgNDQsIDAsIDksIDE4NSwgMCwgOCwgMTIsIDAsIDgsIDE0MCwgMCwgOCwgNzYsIDAsIDksXFxyXFxuICAgICAgICAgICAgMjQ5LCA4MCwgNywgMywgMCwgOCwgODIsIDAsIDgsIDE4LCA4NSwgOCwgMTYzLCA4MywgNywgMzUsIDAsIDgsIDExNCwgMCwgOCwgNTAsIDAsIDksIDE5NywgODEsIDcsIDExLCAwLCA4LCA5OCwgMCwgOCwgMzQsIDAsIDksIDE2NSwgMCwgOCwgMiwgMCwgOCxcXHJcXG4gICAgICAgICAgICAxMzAsIDAsIDgsIDY2LCAwLCA5LCAyMjksIDgwLCA3LCA3LCAwLCA4LCA5MCwgMCwgOCwgMjYsIDAsIDksIDE0OSwgODQsIDcsIDY3LCAwLCA4LCAxMjIsIDAsIDgsIDU4LCAwLCA5LCAyMTMsIDgyLCA3LCAxOSwgMCwgOCwgMTA2LCAwLCA4LCA0MiwgMCwgOSxcXHJcXG4gICAgICAgICAgICAxODEsIDAsIDgsIDEwLCAwLCA4LCAxMzgsIDAsIDgsIDc0LCAwLCA5LCAyNDUsIDgwLCA3LCA1LCAwLCA4LCA4NiwgMCwgOCwgMjIsIDE5MiwgOCwgMCwgODMsIDcsIDUxLCAwLCA4LCAxMTgsIDAsIDgsIDU0LCAwLCA5LCAyMDUsIDgxLCA3LCAxNSwgMCwgOCxcXHJcXG4gICAgICAgICAgICAxMDIsIDAsIDgsIDM4LCAwLCA5LCAxNzMsIDAsIDgsIDYsIDAsIDgsIDEzNCwgMCwgOCwgNzAsIDAsIDksIDIzNywgODAsIDcsIDksIDAsIDgsIDk0LCAwLCA4LCAzMCwgMCwgOSwgMTU3LCA4NCwgNywgOTksIDAsIDgsIDEyNiwgMCwgOCwgNjIsIDAsIDksXFxyXFxuICAgICAgICAgICAgMjIxLCA4MiwgNywgMjcsIDAsIDgsIDExMCwgMCwgOCwgNDYsIDAsIDksIDE4OSwgMCwgOCwgMTQsIDAsIDgsIDE0MiwgMCwgOCwgNzgsIDAsIDksIDI1MywgOTYsIDcsIDI1NiwgMCwgOCwgODEsIDAsIDgsIDE3LCA4NSwgOCwgMTMxLCA4MiwgNywgMzEsIDAsXFxyXFxuICAgICAgICAgICAgOCwgMTEzLCAwLCA4LCA0OSwgMCwgOSwgMTk1LCA4MCwgNywgMTAsIDAsIDgsIDk3LCAwLCA4LCAzMywgMCwgOSwgMTYzLCAwLCA4LCAxLCAwLCA4LCAxMjksIDAsIDgsIDY1LCAwLCA5LCAyMjcsIDgwLCA3LCA2LCAwLCA4LCA4OSwgMCwgOCwgMjUsIDAsIDksXFxyXFxuICAgICAgICAgICAgMTQ3LCA4MywgNywgNTksIDAsIDgsIDEyMSwgMCwgOCwgNTcsIDAsIDksIDIxMSwgODEsIDcsIDE3LCAwLCA4LCAxMDUsIDAsIDgsIDQxLCAwLCA5LCAxNzksIDAsIDgsIDksIDAsIDgsIDEzNywgMCwgOCwgNzMsIDAsIDksIDI0MywgODAsIDcsIDQsIDAsIDgsXFxyXFxuICAgICAgICAgICAgODUsIDAsIDgsIDIxLCA4MCwgOCwgMjU4LCA4MywgNywgNDMsIDAsIDgsIDExNywgMCwgOCwgNTMsIDAsIDksIDIwMywgODEsIDcsIDEzLCAwLCA4LCAxMDEsIDAsIDgsIDM3LCAwLCA5LCAxNzEsIDAsIDgsIDUsIDAsIDgsIDEzMywgMCwgOCwgNjksIDAsIDksXFxyXFxuICAgICAgICAgICAgMjM1LCA4MCwgNywgOCwgMCwgOCwgOTMsIDAsIDgsIDI5LCAwLCA5LCAxNTUsIDg0LCA3LCA4MywgMCwgOCwgMTI1LCAwLCA4LCA2MSwgMCwgOSwgMjE5LCA4MiwgNywgMjMsIDAsIDgsIDEwOSwgMCwgOCwgNDUsIDAsIDksIDE4NywgMCwgOCwgMTMsIDAsIDgsXFxyXFxuICAgICAgICAgICAgMTQxLCAwLCA4LCA3NywgMCwgOSwgMjUxLCA4MCwgNywgMywgMCwgOCwgODMsIDAsIDgsIDE5LCA4NSwgOCwgMTk1LCA4MywgNywgMzUsIDAsIDgsIDExNSwgMCwgOCwgNTEsIDAsIDksIDE5OSwgODEsIDcsIDExLCAwLCA4LCA5OSwgMCwgOCwgMzUsIDAsIDksXFxyXFxuICAgICAgICAgICAgMTY3LCAwLCA4LCAzLCAwLCA4LCAxMzEsIDAsIDgsIDY3LCAwLCA5LCAyMzEsIDgwLCA3LCA3LCAwLCA4LCA5MSwgMCwgOCwgMjcsIDAsIDksIDE1MSwgODQsIDcsIDY3LCAwLCA4LCAxMjMsIDAsIDgsIDU5LCAwLCA5LCAyMTUsIDgyLCA3LCAxOSwgMCwgOCxcXHJcXG4gICAgICAgICAgICAxMDcsIDAsIDgsIDQzLCAwLCA5LCAxODMsIDAsIDgsIDExLCAwLCA4LCAxMzksIDAsIDgsIDc1LCAwLCA5LCAyNDcsIDgwLCA3LCA1LCAwLCA4LCA4NywgMCwgOCwgMjMsIDE5MiwgOCwgMCwgODMsIDcsIDUxLCAwLCA4LCAxMTksIDAsIDgsIDU1LCAwLCA5LFxcclxcbiAgICAgICAgICAgIDIwNywgODEsIDcsIDE1LCAwLCA4LCAxMDMsIDAsIDgsIDM5LCAwLCA5LCAxNzUsIDAsIDgsIDcsIDAsIDgsIDEzNSwgMCwgOCwgNzEsIDAsIDksIDIzOSwgODAsIDcsIDksIDAsIDgsIDk1LCAwLCA4LCAzMSwgMCwgOSwgMTU5LCA4NCwgNywgOTksIDAsIDgsXFxyXFxuICAgICAgICAgICAgMTI3LCAwLCA4LCA2MywgMCwgOSwgMjIzLCA4MiwgNywgMjcsIDAsIDgsIDExMSwgMCwgOCwgNDcsIDAsIDksIDE5MSwgMCwgOCwgMTUsIDAsIDgsIDE0MywgMCwgOCwgNzksIDAsIDksIDI1NSBdO1xcclxcbiAgICB2YXIgZml4ZWRfdGQgPSBbIDgwLCA1LCAxLCA4NywgNSwgMjU3LCA4MywgNSwgMTcsIDkxLCA1LCA0MDk3LCA4MSwgNSwgNSwgODksIDUsIDEwMjUsIDg1LCA1LCA2NSwgOTMsIDUsIDE2Mzg1LCA4MCwgNSwgMywgODgsIDUsIDUxMywgODQsIDUsIDMzLCA5MiwgNSxcXHJcXG4gICAgICAgICAgICA4MTkzLCA4MiwgNSwgOSwgOTAsIDUsIDIwNDksIDg2LCA1LCAxMjksIDE5MiwgNSwgMjQ1NzcsIDgwLCA1LCAyLCA4NywgNSwgMzg1LCA4MywgNSwgMjUsIDkxLCA1LCA2MTQ1LCA4MSwgNSwgNywgODksIDUsIDE1MzcsIDg1LCA1LCA5NywgOTMsIDUsXFxyXFxuICAgICAgICAgICAgMjQ1NzcsIDgwLCA1LCA0LCA4OCwgNSwgNzY5LCA4NCwgNSwgNDksIDkyLCA1LCAxMjI4OSwgODIsIDUsIDEzLCA5MCwgNSwgMzA3MywgODYsIDUsIDE5MywgMTkyLCA1LCAyNDU3NyBdO1xcclxcblxcclxcbiAgICAvLyBUYWJsZXMgZm9yIGRlZmxhdGUgZnJvbSBQS1pJUCdzIGFwcG5vdGUudHh0LlxcclxcbiAgICB2YXIgY3BsZW5zID0gWyAvLyBDb3B5IGxlbmd0aHMgZm9yIGxpdGVyYWwgY29kZXMgMjU3Li4yODVcXHJcXG4gICAgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMywgMTUsIDE3LCAxOSwgMjMsIDI3LCAzMSwgMzUsIDQzLCA1MSwgNTksIDY3LCA4MywgOTksIDExNSwgMTMxLCAxNjMsIDE5NSwgMjI3LCAyNTgsIDAsIDAgXTtcXHJcXG5cXHJcXG4gICAgLy8gc2VlIG5vdGUgIzEzIGFib3ZlIGFib3V0IDI1OFxcclxcbiAgICB2YXIgY3BsZXh0ID0gWyAvLyBFeHRyYSBiaXRzIGZvciBsaXRlcmFsIGNvZGVzIDI1Ny4uMjg1XFxyXFxuICAgIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDEsIDEsIDEsIDEsIDIsIDIsIDIsIDIsIDMsIDMsIDMsIDMsIDQsIDQsIDQsIDQsIDUsIDUsIDUsIDUsIDAsIDExMiwgMTEyIC8vIDExMj09aW52YWxpZFxcclxcbiAgICBdO1xcclxcblxcclxcbiAgICB2YXIgY3BkaXN0ID0gWyAvLyBDb3B5IG9mZnNldHMgZm9yIGRpc3RhbmNlIGNvZGVzIDAuLjI5XFxyXFxuICAgIDEsIDIsIDMsIDQsIDUsIDcsIDksIDEzLCAxNywgMjUsIDMzLCA0OSwgNjUsIDk3LCAxMjksIDE5MywgMjU3LCAzODUsIDUxMywgNzY5LCAxMDI1LCAxNTM3LCAyMDQ5LCAzMDczLCA0MDk3LCA2MTQ1LCA4MTkzLCAxMjI4OSwgMTYzODUsIDI0NTc3IF07XFxyXFxuXFxyXFxuICAgIHZhciBjcGRleHQgPSBbIC8vIEV4dHJhIGJpdHMgZm9yIGRpc3RhbmNlIGNvZGVzXFxyXFxuICAgIDAsIDAsIDAsIDAsIDEsIDEsIDIsIDIsIDMsIDMsIDQsIDQsIDUsIDUsIDYsIDYsIDcsIDcsIDgsIDgsIDksIDksIDEwLCAxMCwgMTEsIDExLCAxMiwgMTIsIDEzLCAxMyBdO1xcclxcblxcclxcbiAgICAvLyBJZiBCTUFYIG5lZWRzIHRvIGJlIGxhcmdlciB0aGFuIDE2LCB0aGVuIGggYW5kIHhbXSBzaG91bGQgYmUgdUxvbmcuXFxyXFxuICAgIHZhciBCTUFYID0gMTU7IC8vIG1heGltdW0gYml0IGxlbmd0aCBvZiBhbnkgY29kZVxcclxcblxcclxcbiAgICBmdW5jdGlvbiBJbmZUcmVlKCkge1xcclxcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xcclxcblxcclxcbiAgICAgICAgdmFyIGhuOyAvLyBodWZ0cyB1c2VkIGluIHNwYWNlXFxyXFxuICAgICAgICB2YXIgdjsgLy8gd29yayBhcmVhIGZvciBodWZ0X2J1aWxkXFxyXFxuICAgICAgICB2YXIgYzsgLy8gYml0IGxlbmd0aCBjb3VudCB0YWJsZVxcclxcbiAgICAgICAgdmFyIHI7IC8vIHRhYmxlIGVudHJ5IGZvciBzdHJ1Y3R1cmUgYXNzaWdubWVudFxcclxcbiAgICAgICAgdmFyIHU7IC8vIHRhYmxlIHN0YWNrXFxyXFxuICAgICAgICB2YXIgeDsgLy8gYml0IG9mZnNldHMsIHRoZW4gY29kZSBzdGFja1xcclxcblxcclxcbiAgICAgICAgZnVuY3Rpb24gaHVmdF9idWlsZChiLCAvLyBjb2RlIGxlbmd0aHMgaW4gYml0cyAoYWxsIGFzc3VtZWQgPD1cXHJcXG4gICAgICAgIC8vIEJNQVgpXFxyXFxuICAgICAgICBiaW5kZXgsIG4sIC8vIG51bWJlciBvZiBjb2RlcyAoYXNzdW1lZCA8PSAyODgpXFxyXFxuICAgICAgICBzLCAvLyBudW1iZXIgb2Ygc2ltcGxlLXZhbHVlZCBjb2RlcyAoMC4ucy0xKVxcclxcbiAgICAgICAgZCwgLy8gbGlzdCBvZiBiYXNlIHZhbHVlcyBmb3Igbm9uLXNpbXBsZSBjb2Rlc1xcclxcbiAgICAgICAgZSwgLy8gbGlzdCBvZiBleHRyYSBiaXRzIGZvciBub24tc2ltcGxlIGNvZGVzXFxyXFxuICAgICAgICB0LCAvLyByZXN1bHQ6IHN0YXJ0aW5nIHRhYmxlXFxyXFxuICAgICAgICBtLCAvLyBtYXhpbXVtIGxvb2t1cCBiaXRzLCByZXR1cm5zIGFjdHVhbFxcclxcbiAgICAgICAgaHAsLy8gc3BhY2UgZm9yIHRyZWVzXFxyXFxuICAgICAgICBobiwvLyBodWZ0cyB1c2VkIGluIHNwYWNlXFxyXFxuICAgICAgICB2IC8vIHdvcmtpbmcgYXJlYTogdmFsdWVzIGluIG9yZGVyIG9mIGJpdCBsZW5ndGhcXHJcXG4gICAgICAgICkge1xcclxcbiAgICAgICAgICAgIC8vIEdpdmVuIGEgbGlzdCBvZiBjb2RlIGxlbmd0aHMgYW5kIGEgbWF4aW11bSB0YWJsZSBzaXplLCBtYWtlIGEgc2V0IG9mXFxyXFxuICAgICAgICAgICAgLy8gdGFibGVzIHRvIGRlY29kZSB0aGF0IHNldCBvZiBjb2Rlcy4gUmV0dXJuIFpfT0sgb24gc3VjY2VzcyxcXHJcXG4gICAgICAgICAgICAvLyBaX0JVRl9FUlJPUlxcclxcbiAgICAgICAgICAgIC8vIGlmIHRoZSBnaXZlbiBjb2RlIHNldCBpcyBpbmNvbXBsZXRlICh0aGUgdGFibGVzIGFyZSBzdGlsbCBidWlsdCBpblxcclxcbiAgICAgICAgICAgIC8vIHRoaXNcXHJcXG4gICAgICAgICAgICAvLyBjYXNlKSwgWl9EQVRBX0VSUk9SIGlmIHRoZSBpbnB1dCBpcyBpbnZhbGlkIChhbiBvdmVyLXN1YnNjcmliZWQgc2V0XFxyXFxuICAgICAgICAgICAgLy8gb2ZcXHJcXG4gICAgICAgICAgICAvLyBsZW5ndGhzKSwgb3IgWl9NRU1fRVJST1IgaWYgbm90IGVub3VnaCBtZW1vcnkuXFxyXFxuXFxyXFxuICAgICAgICAgICAgdmFyIGE7IC8vIGNvdW50ZXIgZm9yIGNvZGVzIG9mIGxlbmd0aCBrXFxyXFxuICAgICAgICAgICAgdmFyIGY7IC8vIGkgcmVwZWF0cyBpbiB0YWJsZSBldmVyeSBmIGVudHJpZXNcXHJcXG4gICAgICAgICAgICB2YXIgZzsgLy8gbWF4aW11bSBjb2RlIGxlbmd0aFxcclxcbiAgICAgICAgICAgIHZhciBoOyAvLyB0YWJsZSBsZXZlbFxcclxcbiAgICAgICAgICAgIHZhciBpOyAvLyBjb3VudGVyLCBjdXJyZW50IGNvZGVcXHJcXG4gICAgICAgICAgICB2YXIgajsgLy8gY291bnRlclxcclxcbiAgICAgICAgICAgIHZhciBrOyAvLyBudW1iZXIgb2YgYml0cyBpbiBjdXJyZW50IGNvZGVcXHJcXG4gICAgICAgICAgICB2YXIgbDsgLy8gYml0cyBwZXIgdGFibGUgKHJldHVybmVkIGluIG0pXFxyXFxuICAgICAgICAgICAgdmFyIG1hc2s7IC8vICgxIDw8IHcpIC0gMSwgdG8gYXZvaWQgY2MgLU8gYnVnIG9uIEhQXFxyXFxuICAgICAgICAgICAgdmFyIHA7IC8vIHBvaW50ZXIgaW50byBjW10sIGJbXSwgb3IgdltdXFxyXFxuICAgICAgICAgICAgdmFyIHE7IC8vIHBvaW50cyB0byBjdXJyZW50IHRhYmxlXFxyXFxuICAgICAgICAgICAgdmFyIHc7IC8vIGJpdHMgYmVmb3JlIHRoaXMgdGFibGUgPT0gKGwgKiBoKVxcclxcbiAgICAgICAgICAgIHZhciB4cDsgLy8gcG9pbnRlciBpbnRvIHhcXHJcXG4gICAgICAgICAgICB2YXIgeTsgLy8gbnVtYmVyIG9mIGR1bW15IGNvZGVzIGFkZGVkXFxyXFxuICAgICAgICAgICAgdmFyIHo7IC8vIG51bWJlciBvZiBlbnRyaWVzIGluIGN1cnJlbnQgdGFibGVcXHJcXG5cXHJcXG4gICAgICAgICAgICAvLyBHZW5lcmF0ZSBjb3VudHMgZm9yIGVhY2ggYml0IGxlbmd0aFxcclxcblxcclxcbiAgICAgICAgICAgIHAgPSAwO1xcclxcbiAgICAgICAgICAgIGkgPSBuO1xcclxcbiAgICAgICAgICAgIGRvIHtcXHJcXG4gICAgICAgICAgICAgICAgY1tiW2JpbmRleCArIHBdXSsrO1xcclxcbiAgICAgICAgICAgICAgICBwKys7XFxyXFxuICAgICAgICAgICAgICAgIGktLTsgLy8gYXNzdW1lIGFsbCBlbnRyaWVzIDw9IEJNQVhcXHJcXG4gICAgICAgICAgICB9IHdoaWxlIChpICE9PSAwKTtcXHJcXG5cXHJcXG4gICAgICAgICAgICBpZiAoY1swXSA9PSBuKSB7IC8vIG51bGwgaW5wdXQtLWFsbCB6ZXJvIGxlbmd0aCBjb2Rlc1xcclxcbiAgICAgICAgICAgICAgICB0WzBdID0gLTE7XFxyXFxuICAgICAgICAgICAgICAgIG1bMF0gPSAwO1xcclxcbiAgICAgICAgICAgICAgICByZXR1cm4gWl9PSztcXHJcXG4gICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgLy8gRmluZCBtaW5pbXVtIGFuZCBtYXhpbXVtIGxlbmd0aCwgYm91bmQgKm0gYnkgdGhvc2VcXHJcXG4gICAgICAgICAgICBsID0gbVswXTtcXHJcXG4gICAgICAgICAgICBmb3IgKGogPSAxOyBqIDw9IEJNQVg7IGorKylcXHJcXG4gICAgICAgICAgICAgICAgaWYgKGNbal0gIT09IDApXFxyXFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcXHJcXG4gICAgICAgICAgICBrID0gajsgLy8gbWluaW11bSBjb2RlIGxlbmd0aFxcclxcbiAgICAgICAgICAgIGlmIChsIDwgaikge1xcclxcbiAgICAgICAgICAgICAgICBsID0gajtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgZm9yIChpID0gQk1BWDsgaSAhPT0gMDsgaS0tKSB7XFxyXFxuICAgICAgICAgICAgICAgIGlmIChjW2ldICE9PSAwKVxcclxcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIGcgPSBpOyAvLyBtYXhpbXVtIGNvZGUgbGVuZ3RoXFxyXFxuICAgICAgICAgICAgaWYgKGwgPiBpKSB7XFxyXFxuICAgICAgICAgICAgICAgIGwgPSBpO1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICBtWzBdID0gbDtcXHJcXG5cXHJcXG4gICAgICAgICAgICAvLyBBZGp1c3QgbGFzdCBsZW5ndGggY291bnQgdG8gZmlsbCBvdXQgY29kZXMsIGlmIG5lZWRlZFxcclxcbiAgICAgICAgICAgIGZvciAoeSA9IDEgPDwgajsgaiA8IGk7IGorKywgeSA8PD0gMSkge1xcclxcbiAgICAgICAgICAgICAgICBpZiAoKHkgLT0gY1tqXSkgPCAwKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWl9EQVRBX0VSUk9SO1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIGlmICgoeSAtPSBjW2ldKSA8IDApIHtcXHJcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFpfREFUQV9FUlJPUjtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgY1tpXSArPSB5O1xcclxcblxcclxcbiAgICAgICAgICAgIC8vIEdlbmVyYXRlIHN0YXJ0aW5nIG9mZnNldHMgaW50byB0aGUgdmFsdWUgdGFibGUgZm9yIGVhY2ggbGVuZ3RoXFxyXFxuICAgICAgICAgICAgeFsxXSA9IGogPSAwO1xcclxcbiAgICAgICAgICAgIHAgPSAxO1xcclxcbiAgICAgICAgICAgIHhwID0gMjtcXHJcXG4gICAgICAgICAgICB3aGlsZSAoLS1pICE9PSAwKSB7IC8vIG5vdGUgdGhhdCBpID09IGcgZnJvbSBhYm92ZVxcclxcbiAgICAgICAgICAgICAgICB4W3hwXSA9IChqICs9IGNbcF0pO1xcclxcbiAgICAgICAgICAgICAgICB4cCsrO1xcclxcbiAgICAgICAgICAgICAgICBwKys7XFxyXFxuICAgICAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgICAgIC8vIE1ha2UgYSB0YWJsZSBvZiB2YWx1ZXMgaW4gb3JkZXIgb2YgYml0IGxlbmd0aHNcXHJcXG4gICAgICAgICAgICBpID0gMDtcXHJcXG4gICAgICAgICAgICBwID0gMDtcXHJcXG4gICAgICAgICAgICBkbyB7XFxyXFxuICAgICAgICAgICAgICAgIGlmICgoaiA9IGJbYmluZGV4ICsgcF0pICE9PSAwKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICB2W3hbal0rK10gPSBpO1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgIHArKztcXHJcXG4gICAgICAgICAgICB9IHdoaWxlICgrK2kgPCBuKTtcXHJcXG4gICAgICAgICAgICBuID0geFtnXTsgLy8gc2V0IG4gdG8gbGVuZ3RoIG9mIHZcXHJcXG5cXHJcXG4gICAgICAgICAgICAvLyBHZW5lcmF0ZSB0aGUgSHVmZm1hbiBjb2RlcyBhbmQgZm9yIGVhY2gsIG1ha2UgdGhlIHRhYmxlIGVudHJpZXNcXHJcXG4gICAgICAgICAgICB4WzBdID0gaSA9IDA7IC8vIGZpcnN0IEh1ZmZtYW4gY29kZSBpcyB6ZXJvXFxyXFxuICAgICAgICAgICAgcCA9IDA7IC8vIGdyYWIgdmFsdWVzIGluIGJpdCBvcmRlclxcclxcbiAgICAgICAgICAgIGggPSAtMTsgLy8gbm8gdGFibGVzIHlldC0tbGV2ZWwgLTFcXHJcXG4gICAgICAgICAgICB3ID0gLWw7IC8vIGJpdHMgZGVjb2RlZCA9PSAobCAqIGgpXFxyXFxuICAgICAgICAgICAgdVswXSA9IDA7IC8vIGp1c3QgdG8ga2VlcCBjb21waWxlcnMgaGFwcHlcXHJcXG4gICAgICAgICAgICBxID0gMDsgLy8gZGl0dG9cXHJcXG4gICAgICAgICAgICB6ID0gMDsgLy8gZGl0dG9cXHJcXG5cXHJcXG4gICAgICAgICAgICAvLyBnbyB0aHJvdWdoIHRoZSBiaXQgbGVuZ3RocyAoayBhbHJlYWR5IGlzIGJpdHMgaW4gc2hvcnRlc3QgY29kZSlcXHJcXG4gICAgICAgICAgICBmb3IgKDsgayA8PSBnOyBrKyspIHtcXHJcXG4gICAgICAgICAgICAgICAgYSA9IGNba107XFxyXFxuICAgICAgICAgICAgICAgIHdoaWxlIChhLS0gIT09IDApIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIC8vIGhlcmUgaSBpcyB0aGUgSHVmZm1hbiBjb2RlIG9mIGxlbmd0aCBrIGJpdHMgZm9yIHZhbHVlICpwXFxyXFxuICAgICAgICAgICAgICAgICAgICAvLyBtYWtlIHRhYmxlcyB1cCB0byByZXF1aXJlZCBsZXZlbFxcclxcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGsgPiB3ICsgbCkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGgrKztcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB3ICs9IGw7IC8vIHByZXZpb3VzIHRhYmxlIGFsd2F5cyBsIGJpdHNcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb21wdXRlIG1pbmltdW0gc2l6ZSB0YWJsZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gbCBiaXRzXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgeiA9IGcgLSB3O1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHogPSAoeiA+IGwpID8gbCA6IHo7IC8vIHRhYmxlIHNpemUgdXBwZXIgbGltaXRcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGYgPSAxIDw8IChqID0gayAtIHcpKSA+IGEgKyAxKSB7IC8vIHRyeSBhIGstdyBiaXQgdGFibGVcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG9vIGZldyBjb2RlcyBmb3JcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gay13IGJpdCB0YWJsZVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmIC09IGEgKyAxOyAvLyBkZWR1Y3QgY29kZXMgZnJvbSBwYXR0ZXJucyBsZWZ0XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhwID0gaztcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGogPCB6KSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKytqIDwgeikgeyAvLyB0cnkgc21hbGxlciB0YWJsZXMgdXAgdG8geiBiaXRzXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChmIDw8PSAxKSA8PSBjWysreHBdKVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gZW5vdWdoIGNvZGVzIHRvIHVzZSB1cCBqIGJpdHNcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmIC09IGNbeHBdOyAvLyBlbHNlIGRlZHVjdCBjb2RlcyBmcm9tIHBhdHRlcm5zXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgeiA9IDEgPDwgajsgLy8gdGFibGUgZW50cmllcyBmb3Igai1iaXQgdGFibGVcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbGxvY2F0ZSBuZXcgdGFibGVcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaG5bMF0gKyB6ID4gTUFOWSkgeyAvLyAobm90ZTogZG9lc24ndCBtYXR0ZXIgZm9yIGZpeGVkKVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWl9EQVRBX0VSUk9SOyAvLyBvdmVyZmxvdyBvZiBNQU5ZXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVbaF0gPSBxID0gLyogaHArICovaG5bMF07IC8vIERFQlVHXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgaG5bMF0gKz0gejtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25uZWN0IHRvIGxhc3QgdGFibGUsIGlmIHRoZXJlIGlzIG9uZVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoICE9PSAwKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhbaF0gPSBpOyAvLyBzYXZlIHBhdHRlcm4gZm9yIGJhY2tpbmcgdXBcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgclswXSA9IC8qIChieXRlKSAqL2o7IC8vIGJpdHMgaW4gdGhpcyB0YWJsZVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByWzFdID0gLyogKGJ5dGUpICovbDsgLy8gYml0cyB0byBkdW1wIGJlZm9yZSB0aGlzIHRhYmxlXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGogPSBpID4+PiAodyAtIGwpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByWzJdID0gLyogKGludCkgKi8ocSAtIHVbaCAtIDFdIC0gaik7IC8vIG9mZnNldCB0byB0aGlzIHRhYmxlXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhwLnNldChyLCAodVtoIC0gMV0gKyBqKSAqIDMpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0b1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBsYXN0XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRhYmxlXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdFswXSA9IHE7IC8vIGZpcnN0IHRhYmxlIGlzIHJldHVybmVkIHJlc3VsdFxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgIC8vIHNldCB1cCB0YWJsZSBlbnRyeSBpbiByXFxyXFxuICAgICAgICAgICAgICAgICAgICByWzFdID0gLyogKGJ5dGUpICovKGsgLSB3KTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGlmIChwID49IG4pIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICByWzBdID0gMTI4ICsgNjQ7IC8vIG91dCBvZiB2YWx1ZXMtLWludmFsaWQgY29kZVxcclxcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2W3BdIDwgcykge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJbMF0gPSAvKiAoYnl0ZSkgKi8odltwXSA8IDI1NiA/IDAgOiAzMiArIDY0KTsgLy8gMjU2IGlzXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZW5kLW9mLWJsb2NrXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgclsyXSA9IHZbcCsrXTsgLy8gc2ltcGxlIGNvZGUgaXMganVzdCB0aGUgdmFsdWVcXHJcXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgclswXSA9IC8qIChieXRlKSAqLyhlW3ZbcF0gLSBzXSArIDE2ICsgNjQpOyAvLyBub24tc2ltcGxlLS1sb29rXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXAgaW4gbGlzdHNcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICByWzJdID0gZFt2W3ArK10gLSBzXTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgIC8vIGZpbGwgY29kZS1saWtlIGVudHJpZXMgd2l0aCByXFxyXFxuICAgICAgICAgICAgICAgICAgICBmID0gMSA8PCAoayAtIHcpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gaSA+Pj4gdzsgaiA8IHo7IGogKz0gZikge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhwLnNldChyLCAocSArIGopICogMyk7XFxyXFxuICAgICAgICAgICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICAvLyBiYWNrd2FyZHMgaW5jcmVtZW50IHRoZSBrLWJpdCBjb2RlIGlcXHJcXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDEgPDwgKGsgLSAxKTsgKGkgJiBqKSAhPT0gMDsgaiA+Pj49IDEpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBpIF49IGo7XFxyXFxuICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgICAgICBpIF49IGo7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICAvLyBiYWNrdXAgb3ZlciBmaW5pc2hlZCB0YWJsZXNcXHJcXG4gICAgICAgICAgICAgICAgICAgIG1hc2sgPSAoMSA8PCB3KSAtIDE7IC8vIG5lZWRlZCBvbiBIUCwgY2MgLU8gYnVnXFxyXFxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKGkgJiBtYXNrKSAhPSB4W2hdKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgaC0tOyAvLyBkb24ndCBuZWVkIHRvIHVwZGF0ZSBxXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgdyAtPSBsO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hc2sgPSAoMSA8PCB3KSAtIDE7XFxyXFxuICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgLy8gUmV0dXJuIFpfQlVGX0VSUk9SIGlmIHdlIHdlcmUgZ2l2ZW4gYW4gaW5jb21wbGV0ZSB0YWJsZVxcclxcbiAgICAgICAgICAgIHJldHVybiB5ICE9PSAwICYmIGcgIT0gMSA/IFpfQlVGX0VSUk9SIDogWl9PSztcXHJcXG4gICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgIGZ1bmN0aW9uIGluaXRXb3JrQXJlYSh2c2l6ZSkge1xcclxcbiAgICAgICAgICAgIHZhciBpO1xcclxcbiAgICAgICAgICAgIGlmICghaG4pIHtcXHJcXG4gICAgICAgICAgICAgICAgaG4gPSBbXTsgLy8gW107IC8vbmV3IEFycmF5KDEpO1xcclxcbiAgICAgICAgICAgICAgICB2ID0gW107IC8vIG5ldyBBcnJheSh2c2l6ZSk7XFxyXFxuICAgICAgICAgICAgICAgIGMgPSBuZXcgSW50MzJBcnJheShCTUFYICsgMSk7IC8vIG5ldyBBcnJheShCTUFYICsgMSk7XFxyXFxuICAgICAgICAgICAgICAgIHIgPSBbXTsgLy8gbmV3IEFycmF5KDMpO1xcclxcbiAgICAgICAgICAgICAgICB1ID0gbmV3IEludDMyQXJyYXkoQk1BWCk7IC8vIG5ldyBBcnJheShCTUFYKTtcXHJcXG4gICAgICAgICAgICAgICAgeCA9IG5ldyBJbnQzMkFycmF5KEJNQVggKyAxKTsgLy8gbmV3IEFycmF5KEJNQVggKyAxKTtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgaWYgKHYubGVuZ3RoIDwgdnNpemUpIHtcXHJcXG4gICAgICAgICAgICAgICAgdiA9IFtdOyAvLyBuZXcgQXJyYXkodnNpemUpO1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdnNpemU7IGkrKykge1xcclxcbiAgICAgICAgICAgICAgICB2W2ldID0gMDtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IEJNQVggKyAxOyBpKyspIHtcXHJcXG4gICAgICAgICAgICAgICAgY1tpXSA9IDA7XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCAzOyBpKyspIHtcXHJcXG4gICAgICAgICAgICAgICAgcltpXSA9IDA7XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIC8vIGZvcihpbnQgaT0wOyBpPEJNQVg7IGkrKyl7dVtpXT0wO31cXHJcXG4gICAgICAgICAgICB1LnNldChjLnN1YmFycmF5KDAsIEJNQVgpLCAwKTtcXHJcXG4gICAgICAgICAgICAvLyBmb3IoaW50IGk9MDsgaTxCTUFYKzE7IGkrKyl7eFtpXT0wO31cXHJcXG4gICAgICAgICAgICB4LnNldChjLnN1YmFycmF5KDAsIEJNQVggKyAxKSwgMCk7XFxyXFxuICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICB0aGF0LmluZmxhdGVfdHJlZXNfYml0cyA9IGZ1bmN0aW9uKGMsIC8vIDE5IGNvZGUgbGVuZ3Roc1xcclxcbiAgICAgICAgYmIsIC8vIGJpdHMgdHJlZSBkZXNpcmVkL2FjdHVhbCBkZXB0aFxcclxcbiAgICAgICAgdGIsIC8vIGJpdHMgdHJlZSByZXN1bHRcXHJcXG4gICAgICAgIGhwLCAvLyBzcGFjZSBmb3IgdHJlZXNcXHJcXG4gICAgICAgIHogLy8gZm9yIG1lc3NhZ2VzXFxyXFxuICAgICAgICApIHtcXHJcXG4gICAgICAgICAgICB2YXIgcmVzdWx0O1xcclxcbiAgICAgICAgICAgIGluaXRXb3JrQXJlYSgxOSk7XFxyXFxuICAgICAgICAgICAgaG5bMF0gPSAwO1xcclxcbiAgICAgICAgICAgIHJlc3VsdCA9IGh1ZnRfYnVpbGQoYywgMCwgMTksIDE5LCBudWxsLCBudWxsLCB0YiwgYmIsIGhwLCBobiwgdik7XFxyXFxuXFxyXFxuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PSBaX0RBVEFfRVJST1IpIHtcXHJcXG4gICAgICAgICAgICAgICAgei5tc2cgPSBcXFwib3ZlcnN1YnNjcmliZWQgZHluYW1pYyBiaXQgbGVuZ3RocyB0cmVlXFxcIjtcXHJcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdCA9PSBaX0JVRl9FUlJPUiB8fCBiYlswXSA9PT0gMCkge1xcclxcbiAgICAgICAgICAgICAgICB6Lm1zZyA9IFxcXCJpbmNvbXBsZXRlIGR5bmFtaWMgYml0IGxlbmd0aHMgdHJlZVxcXCI7XFxyXFxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFpfREFUQV9FUlJPUjtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcXHJcXG4gICAgICAgIH07XFxyXFxuXFxyXFxuICAgICAgICB0aGF0LmluZmxhdGVfdHJlZXNfZHluYW1pYyA9IGZ1bmN0aW9uKG5sLCAvLyBudW1iZXIgb2YgbGl0ZXJhbC9sZW5ndGggY29kZXNcXHJcXG4gICAgICAgIG5kLCAvLyBudW1iZXIgb2YgZGlzdGFuY2UgY29kZXNcXHJcXG4gICAgICAgIGMsIC8vIHRoYXQgbWFueSAodG90YWwpIGNvZGUgbGVuZ3Roc1xcclxcbiAgICAgICAgYmwsIC8vIGxpdGVyYWwgZGVzaXJlZC9hY3R1YWwgYml0IGRlcHRoXFxyXFxuICAgICAgICBiZCwgLy8gZGlzdGFuY2UgZGVzaXJlZC9hY3R1YWwgYml0IGRlcHRoXFxyXFxuICAgICAgICB0bCwgLy8gbGl0ZXJhbC9sZW5ndGggdHJlZSByZXN1bHRcXHJcXG4gICAgICAgIHRkLCAvLyBkaXN0YW5jZSB0cmVlIHJlc3VsdFxcclxcbiAgICAgICAgaHAsIC8vIHNwYWNlIGZvciB0cmVlc1xcclxcbiAgICAgICAgeiAvLyBmb3IgbWVzc2FnZXNcXHJcXG4gICAgICAgICkge1xcclxcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XFxyXFxuXFxyXFxuICAgICAgICAgICAgLy8gYnVpbGQgbGl0ZXJhbC9sZW5ndGggdHJlZVxcclxcbiAgICAgICAgICAgIGluaXRXb3JrQXJlYSgyODgpO1xcclxcbiAgICAgICAgICAgIGhuWzBdID0gMDtcXHJcXG4gICAgICAgICAgICByZXN1bHQgPSBodWZ0X2J1aWxkKGMsIDAsIG5sLCAyNTcsIGNwbGVucywgY3BsZXh0LCB0bCwgYmwsIGhwLCBobiwgdik7XFxyXFxuICAgICAgICAgICAgaWYgKHJlc3VsdCAhPSBaX09LIHx8IGJsWzBdID09PSAwKSB7XFxyXFxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPT0gWl9EQVRBX0VSUk9SKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICB6Lm1zZyA9IFxcXCJvdmVyc3Vic2NyaWJlZCBsaXRlcmFsL2xlbmd0aCB0cmVlXFxcIjtcXHJcXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChyZXN1bHQgIT0gWl9NRU1fRVJST1IpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHoubXNnID0gXFxcImluY29tcGxldGUgbGl0ZXJhbC9sZW5ndGggdHJlZVxcXCI7XFxyXFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBaX0RBVEFfRVJST1I7XFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgLy8gYnVpbGQgZGlzdGFuY2UgdHJlZVxcclxcbiAgICAgICAgICAgIGluaXRXb3JrQXJlYSgyODgpO1xcclxcbiAgICAgICAgICAgIHJlc3VsdCA9IGh1ZnRfYnVpbGQoYywgbmwsIG5kLCAwLCBjcGRpc3QsIGNwZGV4dCwgdGQsIGJkLCBocCwgaG4sIHYpO1xcclxcblxcclxcbiAgICAgICAgICAgIGlmIChyZXN1bHQgIT0gWl9PSyB8fCAoYmRbMF0gPT09IDAgJiYgbmwgPiAyNTcpKSB7XFxyXFxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPT0gWl9EQVRBX0VSUk9SKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICB6Lm1zZyA9IFxcXCJvdmVyc3Vic2NyaWJlZCBkaXN0YW5jZSB0cmVlXFxcIjtcXHJcXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChyZXN1bHQgPT0gWl9CVUZfRVJST1IpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHoubXNnID0gXFxcImluY29tcGxldGUgZGlzdGFuY2UgdHJlZVxcXCI7XFxyXFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBaX0RBVEFfRVJST1I7XFxyXFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzdWx0ICE9IFpfTUVNX0VSUk9SKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICB6Lm1zZyA9IFxcXCJlbXB0eSBkaXN0YW5jZSB0cmVlIHdpdGggbGVuZ3Roc1xcXCI7XFxyXFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBaX0RBVEFfRVJST1I7XFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgcmV0dXJuIFpfT0s7XFxyXFxuICAgICAgICB9O1xcclxcblxcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgIEluZlRyZWUuaW5mbGF0ZV90cmVlc19maXhlZCA9IGZ1bmN0aW9uKGJsLCAvLyBsaXRlcmFsIGRlc2lyZWQvYWN0dWFsIGJpdCBkZXB0aFxcclxcbiAgICBiZCwgLy8gZGlzdGFuY2UgZGVzaXJlZC9hY3R1YWwgYml0IGRlcHRoXFxyXFxuICAgIHRsLC8vIGxpdGVyYWwvbGVuZ3RoIHRyZWUgcmVzdWx0XFxyXFxuICAgIHRkLy8gZGlzdGFuY2UgdHJlZSByZXN1bHRcXHJcXG4gICAgKSB7XFxyXFxuICAgICAgICBibFswXSA9IGZpeGVkX2JsO1xcclxcbiAgICAgICAgYmRbMF0gPSBmaXhlZF9iZDtcXHJcXG4gICAgICAgIHRsWzBdID0gZml4ZWRfdGw7XFxyXFxuICAgICAgICB0ZFswXSA9IGZpeGVkX3RkO1xcclxcbiAgICAgICAgcmV0dXJuIFpfT0s7XFxyXFxuICAgIH07XFxyXFxuXFxyXFxuICAgIC8vIEluZkNvZGVzXFxyXFxuXFxyXFxuICAgIC8vIHdhaXRpbmcgZm9yIFxcXCJpOlxcXCI9aW5wdXQsXFxyXFxuICAgIC8vIFxcXCJvOlxcXCI9b3V0cHV0LFxcclxcbiAgICAvLyBcXFwieDpcXFwiPW5vdGhpbmdcXHJcXG4gICAgdmFyIFNUQVJUID0gMDsgLy8geDogc2V0IHVwIGZvciBMRU5cXHJcXG4gICAgdmFyIExFTiA9IDE7IC8vIGk6IGdldCBsZW5ndGgvbGl0ZXJhbC9lb2IgbmV4dFxcclxcbiAgICB2YXIgTEVORVhUID0gMjsgLy8gaTogZ2V0dGluZyBsZW5ndGggZXh0cmEgKGhhdmUgYmFzZSlcXHJcXG4gICAgdmFyIERJU1QgPSAzOyAvLyBpOiBnZXQgZGlzdGFuY2UgbmV4dFxcclxcbiAgICB2YXIgRElTVEVYVCA9IDQ7Ly8gaTogZ2V0dGluZyBkaXN0YW5jZSBleHRyYVxcclxcbiAgICB2YXIgQ09QWSA9IDU7IC8vIG86IGNvcHlpbmcgYnl0ZXMgaW4gd2luZG93LCB3YWl0aW5nXFxyXFxuICAgIC8vIGZvciBzcGFjZVxcclxcbiAgICB2YXIgTElUID0gNjsgLy8gbzogZ290IGxpdGVyYWwsIHdhaXRpbmcgZm9yIG91dHB1dFxcclxcbiAgICAvLyBzcGFjZVxcclxcbiAgICB2YXIgV0FTSCA9IDc7IC8vIG86IGdvdCBlb2IsIHBvc3NpYmx5IHN0aWxsIG91dHB1dFxcclxcbiAgICAvLyB3YWl0aW5nXFxyXFxuICAgIHZhciBFTkQgPSA4OyAvLyB4OiBnb3QgZW9iIGFuZCBhbGwgZGF0YSBmbHVzaGVkXFxyXFxuICAgIHZhciBCQURDT0RFID0gOTsvLyB4OiBnb3QgZXJyb3JcXHJcXG5cXHJcXG4gICAgZnVuY3Rpb24gSW5mQ29kZXMoKSB7XFxyXFxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XFxyXFxuXFxyXFxuICAgICAgICB2YXIgbW9kZTsgLy8gY3VycmVudCBpbmZsYXRlX2NvZGVzIG1vZGVcXHJcXG5cXHJcXG4gICAgICAgIC8vIG1vZGUgZGVwZW5kZW50IGluZm9ybWF0aW9uXFxyXFxuICAgICAgICB2YXIgbGVuID0gMDtcXHJcXG5cXHJcXG4gICAgICAgIHZhciB0cmVlOyAvLyBwb2ludGVyIGludG8gdHJlZVxcclxcbiAgICAgICAgdmFyIHRyZWVfaW5kZXggPSAwO1xcclxcbiAgICAgICAgdmFyIG5lZWQgPSAwOyAvLyBiaXRzIG5lZWRlZFxcclxcblxcclxcbiAgICAgICAgdmFyIGxpdCA9IDA7XFxyXFxuXFxyXFxuICAgICAgICAvLyBpZiBFWFQgb3IgQ09QWSwgd2hlcmUgYW5kIGhvdyBtdWNoXFxyXFxuICAgICAgICB2YXIgZ2V0ID0gMDsgLy8gYml0cyB0byBnZXQgZm9yIGV4dHJhXFxyXFxuICAgICAgICB2YXIgZGlzdCA9IDA7IC8vIGRpc3RhbmNlIGJhY2sgdG8gY29weSBmcm9tXFxyXFxuXFxyXFxuICAgICAgICB2YXIgbGJpdHMgPSAwOyAvLyBsdHJlZSBiaXRzIGRlY29kZWQgcGVyIGJyYW5jaFxcclxcbiAgICAgICAgdmFyIGRiaXRzID0gMDsgLy8gZHRyZWUgYml0cyBkZWNvZGVyIHBlciBicmFuY2hcXHJcXG4gICAgICAgIHZhciBsdHJlZTsgLy8gbGl0ZXJhbC9sZW5ndGgvZW9iIHRyZWVcXHJcXG4gICAgICAgIHZhciBsdHJlZV9pbmRleCA9IDA7IC8vIGxpdGVyYWwvbGVuZ3RoL2VvYiB0cmVlXFxyXFxuICAgICAgICB2YXIgZHRyZWU7IC8vIGRpc3RhbmNlIHRyZWVcXHJcXG4gICAgICAgIHZhciBkdHJlZV9pbmRleCA9IDA7IC8vIGRpc3RhbmNlIHRyZWVcXHJcXG5cXHJcXG4gICAgICAgIC8vIENhbGxlZCB3aXRoIG51bWJlciBvZiBieXRlcyBsZWZ0IHRvIHdyaXRlIGluIHdpbmRvdyBhdCBsZWFzdCAyNThcXHJcXG4gICAgICAgIC8vICh0aGUgbWF4aW11bSBzdHJpbmcgbGVuZ3RoKSBhbmQgbnVtYmVyIG9mIGlucHV0IGJ5dGVzIGF2YWlsYWJsZVxcclxcbiAgICAgICAgLy8gYXQgbGVhc3QgdGVuLiBUaGUgdGVuIGJ5dGVzIGFyZSBzaXggYnl0ZXMgZm9yIHRoZSBsb25nZXN0IGxlbmd0aC9cXHJcXG4gICAgICAgIC8vIGRpc3RhbmNlIHBhaXIgcGx1cyBmb3VyIGJ5dGVzIGZvciBvdmVybG9hZGluZyB0aGUgYml0IGJ1ZmZlci5cXHJcXG5cXHJcXG4gICAgICAgIGZ1bmN0aW9uIGluZmxhdGVfZmFzdChibCwgYmQsIHRsLCB0bF9pbmRleCwgdGQsIHRkX2luZGV4LCBzLCB6KSB7XFxyXFxuICAgICAgICAgICAgdmFyIHQ7IC8vIHRlbXBvcmFyeSBwb2ludGVyXFxyXFxuICAgICAgICAgICAgdmFyIHRwOyAvLyB0ZW1wb3JhcnkgcG9pbnRlclxcclxcbiAgICAgICAgICAgIHZhciB0cF9pbmRleDsgLy8gdGVtcG9yYXJ5IHBvaW50ZXJcXHJcXG4gICAgICAgICAgICB2YXIgZTsgLy8gZXh0cmEgYml0cyBvciBvcGVyYXRpb25cXHJcXG4gICAgICAgICAgICB2YXIgYjsgLy8gYml0IGJ1ZmZlclxcclxcbiAgICAgICAgICAgIHZhciBrOyAvLyBiaXRzIGluIGJpdCBidWZmZXJcXHJcXG4gICAgICAgICAgICB2YXIgcDsgLy8gaW5wdXQgZGF0YSBwb2ludGVyXFxyXFxuICAgICAgICAgICAgdmFyIG47IC8vIGJ5dGVzIGF2YWlsYWJsZSB0aGVyZVxcclxcbiAgICAgICAgICAgIHZhciBxOyAvLyBvdXRwdXQgd2luZG93IHdyaXRlIHBvaW50ZXJcXHJcXG4gICAgICAgICAgICB2YXIgbTsgLy8gYnl0ZXMgdG8gZW5kIG9mIHdpbmRvdyBvciByZWFkIHBvaW50ZXJcXHJcXG4gICAgICAgICAgICB2YXIgbWw7IC8vIG1hc2sgZm9yIGxpdGVyYWwvbGVuZ3RoIHRyZWVcXHJcXG4gICAgICAgICAgICB2YXIgbWQ7IC8vIG1hc2sgZm9yIGRpc3RhbmNlIHRyZWVcXHJcXG4gICAgICAgICAgICB2YXIgYzsgLy8gYnl0ZXMgdG8gY29weVxcclxcbiAgICAgICAgICAgIHZhciBkOyAvLyBkaXN0YW5jZSBiYWNrIHRvIGNvcHkgZnJvbVxcclxcbiAgICAgICAgICAgIHZhciByOyAvLyBjb3B5IHNvdXJjZSBwb2ludGVyXFxyXFxuXFxyXFxuICAgICAgICAgICAgdmFyIHRwX2luZGV4X3RfMzsgLy8gKHRwX2luZGV4K3QpKjNcXHJcXG5cXHJcXG4gICAgICAgICAgICAvLyBsb2FkIGlucHV0LCBvdXRwdXQsIGJpdCB2YWx1ZXNcXHJcXG4gICAgICAgICAgICBwID0gei5uZXh0X2luX2luZGV4O1xcclxcbiAgICAgICAgICAgIG4gPSB6LmF2YWlsX2luO1xcclxcbiAgICAgICAgICAgIGIgPSBzLmJpdGI7XFxyXFxuICAgICAgICAgICAgayA9IHMuYml0aztcXHJcXG4gICAgICAgICAgICBxID0gcy53cml0ZTtcXHJcXG4gICAgICAgICAgICBtID0gcSA8IHMucmVhZCA/IHMucmVhZCAtIHEgLSAxIDogcy5lbmQgLSBxO1xcclxcblxcclxcbiAgICAgICAgICAgIC8vIGluaXRpYWxpemUgbWFza3NcXHJcXG4gICAgICAgICAgICBtbCA9IGluZmxhdGVfbWFza1tibF07XFxyXFxuICAgICAgICAgICAgbWQgPSBpbmZsYXRlX21hc2tbYmRdO1xcclxcblxcclxcbiAgICAgICAgICAgIC8vIGRvIHVudGlsIG5vdCBlbm91Z2ggaW5wdXQgb3Igb3V0cHV0IHNwYWNlIGZvciBmYXN0IGxvb3BcXHJcXG4gICAgICAgICAgICBkbyB7IC8vIGFzc3VtZSBjYWxsZWQgd2l0aCBtID49IDI1OCAmJiBuID49IDEwXFxyXFxuICAgICAgICAgICAgICAgIC8vIGdldCBsaXRlcmFsL2xlbmd0aCBjb2RlXFxyXFxuICAgICAgICAgICAgICAgIHdoaWxlIChrIDwgKDIwKSkgeyAvLyBtYXggYml0cyBmb3IgbGl0ZXJhbC9sZW5ndGggY29kZVxcclxcbiAgICAgICAgICAgICAgICAgICAgbi0tO1xcclxcbiAgICAgICAgICAgICAgICAgICAgYiB8PSAoei5yZWFkX2J5dGUocCsrKSAmIDB4ZmYpIDw8IGs7XFxyXFxuICAgICAgICAgICAgICAgICAgICBrICs9IDg7XFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgdCA9IGIgJiBtbDtcXHJcXG4gICAgICAgICAgICAgICAgdHAgPSB0bDtcXHJcXG4gICAgICAgICAgICAgICAgdHBfaW5kZXggPSB0bF9pbmRleDtcXHJcXG4gICAgICAgICAgICAgICAgdHBfaW5kZXhfdF8zID0gKHRwX2luZGV4ICsgdCkgKiAzO1xcclxcbiAgICAgICAgICAgICAgICBpZiAoKGUgPSB0cFt0cF9pbmRleF90XzNdKSA9PT0gMCkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgYiA+Pj0gKHRwW3RwX2luZGV4X3RfMyArIDFdKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGsgLT0gKHRwW3RwX2luZGV4X3RfMyArIDFdKTtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgIHMud2luZG93W3ErK10gPSAvKiAoYnl0ZSkgKi90cFt0cF9pbmRleF90XzMgKyAyXTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIG0tLTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgIGRvIHtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgIGIgPj49ICh0cFt0cF9pbmRleF90XzMgKyAxXSk7XFxyXFxuICAgICAgICAgICAgICAgICAgICBrIC09ICh0cFt0cF9pbmRleF90XzMgKyAxXSk7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICBpZiAoKGUgJiAxNikgIT09IDApIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBlICY9IDE1O1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGMgPSB0cFt0cF9pbmRleF90XzMgKyAyXSArICgvKiAoaW50KSAqL2IgJiBpbmZsYXRlX21hc2tbZV0pO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGIgPj49IGU7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgayAtPSBlO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRlY29kZSBkaXN0YW5jZSBiYXNlIG9mIGJsb2NrIHRvIGNvcHlcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoayA8ICgxNSkpIHsgLy8gbWF4IGJpdHMgZm9yIGRpc3RhbmNlIGNvZGVcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbi0tO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiIHw9ICh6LnJlYWRfYnl0ZShwKyspICYgMHhmZikgPDwgaztcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgayArPSA4O1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB0ID0gYiAmIG1kO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRwID0gdGQ7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgdHBfaW5kZXggPSB0ZF9pbmRleDtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB0cF9pbmRleF90XzMgPSAodHBfaW5kZXggKyB0KSAqIDM7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgZSA9IHRwW3RwX2luZGV4X3RfM107XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgZG8ge1xcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiID4+PSAodHBbdHBfaW5kZXhfdF8zICsgMV0pO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrIC09ICh0cFt0cF9pbmRleF90XzMgKyAxXSk7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoZSAmIDE2KSAhPT0gMCkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IGV4dHJhIGJpdHMgdG8gYWRkIHRvIGRpc3RhbmNlIGJhc2VcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUgJj0gMTU7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoayA8IChlKSkgeyAvLyBnZXQgZXh0cmEgYml0cyAodXAgdG8gMTMpXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbi0tO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIgfD0gKHoucmVhZF9ieXRlKHArKykgJiAweGZmKSA8PCBrO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGsgKz0gODtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQgPSB0cFt0cF9pbmRleF90XzMgKyAyXSArIChiICYgaW5mbGF0ZV9tYXNrW2VdKTtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIgPj49IChlKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGsgLT0gKGUpO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG8gdGhlIGNvcHlcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0gLT0gYztcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChxID49IGQpIHsgLy8gb2Zmc2V0IGJlZm9yZSBkZXN0XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8ganVzdCBjb3B5XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgciA9IHEgLSBkO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChxIC0gciA+IDAgJiYgMiA+IChxIC0gcikpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcy53aW5kb3dbcSsrXSA9IHMud2luZG93W3IrK107IC8vIG1pbmltdW1cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY291bnQgaXNcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhyZWUsXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMud2luZG93W3ErK10gPSBzLndpbmRvd1tyKytdOyAvLyBzbyB1bnJvbGxcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbG9vcCBhXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxpdHRsZVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjIC09IDI7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcy53aW5kb3cuc2V0KHMud2luZG93LnN1YmFycmF5KHIsIHIgKyAyKSwgcSk7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHEgKz0gMjtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgciArPSAyO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjIC09IDI7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gZWxzZSBvZmZzZXQgYWZ0ZXIgZGVzdGluYXRpb25cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByID0gcSAtIGQ7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG8ge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByICs9IHMuZW5kOyAvLyBmb3JjZSBwb2ludGVyIGluIHdpbmRvd1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKHIgPCAwKTsgLy8gY292ZXJzIGludmFsaWQgZGlzdGFuY2VzXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZSA9IHMuZW5kIC0gcjtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYyA+IGUpIHsgLy8gaWYgc291cmNlIGNyb3NzZXMsXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgLT0gZTsgLy8gd3JhcHBlZCBjb3B5XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChxIC0gciA+IDAgJiYgZSA+IChxIC0gcikpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzLndpbmRvd1txKytdID0gcy53aW5kb3dbcisrXTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tZSAhPT0gMCk7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzLndpbmRvdy5zZXQocy53aW5kb3cuc3ViYXJyYXkociwgciArIGUpLCBxKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHEgKz0gZTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgKz0gZTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUgPSAwO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgPSAwOyAvLyBjb3B5IHJlc3QgZnJvbSBzdGFydCBvZiB3aW5kb3dcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb3B5IGFsbCBvciB3aGF0J3MgbGVmdFxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHEgLSByID4gMCAmJiBjID4gKHEgLSByKSkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcy53aW5kb3dbcSsrXSA9IHMud2luZG93W3IrK107XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1jICE9PSAwKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcy53aW5kb3cuc2V0KHMud2luZG93LnN1YmFycmF5KHIsIHIgKyBjKSwgcSk7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcSArPSBjO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgKz0gYztcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjID0gMDtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKChlICYgNjQpID09PSAwKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ICs9IHRwW3RwX2luZGV4X3RfMyArIDJdO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdCArPSAoYiAmIGluZmxhdGVfbWFza1tlXSk7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cF9pbmRleF90XzMgPSAodHBfaW5kZXggKyB0KSAqIDM7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlID0gdHBbdHBfaW5kZXhfdF8zXTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHoubXNnID0gXFxcImludmFsaWQgZGlzdGFuY2UgY29kZVxcXCI7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjID0gei5hdmFpbF9pbiAtIG47XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjID0gKGsgPj4gMykgPCBjID8gayA+PiAzIDogYztcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4gKz0gYztcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAgLT0gYztcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGsgLT0gYyA8PCAzO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcy5iaXRiID0gYjtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMuYml0ayA9IGs7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB6LmF2YWlsX2luID0gbjtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHoudG90YWxfaW4gKz0gcCAtIHoubmV4dF9pbl9pbmRleDtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHoubmV4dF9pbl9pbmRleCA9IHA7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzLndyaXRlID0gcTtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBaX0RBVEFfRVJST1I7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB9IHdoaWxlICh0cnVlKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcXHJcXG4gICAgICAgICAgICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgIGlmICgoZSAmIDY0KSA9PT0gMCkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHQgKz0gdHBbdHBfaW5kZXhfdF8zICsgMl07XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgdCArPSAoYiAmIGluZmxhdGVfbWFza1tlXSk7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgdHBfaW5kZXhfdF8zID0gKHRwX2luZGV4ICsgdCkgKiAzO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoZSA9IHRwW3RwX2luZGV4X3RfM10pID09PSAwKSB7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIgPj49ICh0cFt0cF9pbmRleF90XzMgKyAxXSk7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGsgLT0gKHRwW3RwX2luZGV4X3RfMyArIDFdKTtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcy53aW5kb3dbcSsrXSA9IC8qIChieXRlKSAqL3RwW3RwX2luZGV4X3RfMyArIDJdO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtLS07XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoKGUgJiAzMikgIT09IDApIHtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBjID0gei5hdmFpbF9pbiAtIG47XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgYyA9IChrID4+IDMpIDwgYyA/IGsgPj4gMyA6IGM7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgbiArPSBjO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHAgLT0gYztcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBrIC09IGMgPDwgMztcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBzLmJpdGIgPSBiO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHMuYml0ayA9IGs7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgei5hdmFpbF9pbiA9IG47XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgei50b3RhbF9pbiArPSBwIC0gei5uZXh0X2luX2luZGV4O1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHoubmV4dF9pbl9pbmRleCA9IHA7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgcy53cml0ZSA9IHE7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VORDtcXHJcXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgei5tc2cgPSBcXFwiaW52YWxpZCBsaXRlcmFsL2xlbmd0aCBjb2RlXFxcIjtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBjID0gei5hdmFpbF9pbiAtIG47XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgYyA9IChrID4+IDMpIDwgYyA/IGsgPj4gMyA6IGM7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgbiArPSBjO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHAgLT0gYztcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBrIC09IGMgPDwgMztcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBzLmJpdGIgPSBiO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHMuYml0ayA9IGs7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgei5hdmFpbF9pbiA9IG47XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgei50b3RhbF9pbiArPSBwIC0gei5uZXh0X2luX2luZGV4O1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHoubmV4dF9pbl9pbmRleCA9IHA7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgcy53cml0ZSA9IHE7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFpfREFUQV9FUlJPUjtcXHJcXG4gICAgICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgfSB3aGlsZSAodHJ1ZSk7XFxyXFxuICAgICAgICAgICAgfSB3aGlsZSAobSA+PSAyNTggJiYgbiA+PSAxMCk7XFxyXFxuXFxyXFxuICAgICAgICAgICAgLy8gbm90IGVub3VnaCBpbnB1dCBvciBvdXRwdXQtLXJlc3RvcmUgcG9pbnRlcnMgYW5kIHJldHVyblxcclxcbiAgICAgICAgICAgIGMgPSB6LmF2YWlsX2luIC0gbjtcXHJcXG4gICAgICAgICAgICBjID0gKGsgPj4gMykgPCBjID8gayA+PiAzIDogYztcXHJcXG4gICAgICAgICAgICBuICs9IGM7XFxyXFxuICAgICAgICAgICAgcCAtPSBjO1xcclxcbiAgICAgICAgICAgIGsgLT0gYyA8PCAzO1xcclxcblxcclxcbiAgICAgICAgICAgIHMuYml0YiA9IGI7XFxyXFxuICAgICAgICAgICAgcy5iaXRrID0gaztcXHJcXG4gICAgICAgICAgICB6LmF2YWlsX2luID0gbjtcXHJcXG4gICAgICAgICAgICB6LnRvdGFsX2luICs9IHAgLSB6Lm5leHRfaW5faW5kZXg7XFxyXFxuICAgICAgICAgICAgei5uZXh0X2luX2luZGV4ID0gcDtcXHJcXG4gICAgICAgICAgICBzLndyaXRlID0gcTtcXHJcXG5cXHJcXG4gICAgICAgICAgICByZXR1cm4gWl9PSztcXHJcXG4gICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgIHRoYXQuaW5pdCA9IGZ1bmN0aW9uKGJsLCBiZCwgdGwsIHRsX2luZGV4LCB0ZCwgdGRfaW5kZXgpIHtcXHJcXG4gICAgICAgICAgICBtb2RlID0gU1RBUlQ7XFxyXFxuICAgICAgICAgICAgbGJpdHMgPSAvKiAoYnl0ZSkgKi9ibDtcXHJcXG4gICAgICAgICAgICBkYml0cyA9IC8qIChieXRlKSAqL2JkO1xcclxcbiAgICAgICAgICAgIGx0cmVlID0gdGw7XFxyXFxuICAgICAgICAgICAgbHRyZWVfaW5kZXggPSB0bF9pbmRleDtcXHJcXG4gICAgICAgICAgICBkdHJlZSA9IHRkO1xcclxcbiAgICAgICAgICAgIGR0cmVlX2luZGV4ID0gdGRfaW5kZXg7XFxyXFxuICAgICAgICAgICAgdHJlZSA9IG51bGw7XFxyXFxuICAgICAgICB9O1xcclxcblxcclxcbiAgICAgICAgdGhhdC5wcm9jID0gZnVuY3Rpb24ocywgeiwgcikge1xcclxcbiAgICAgICAgICAgIHZhciBqOyAvLyB0ZW1wb3Jhcnkgc3RvcmFnZVxcclxcbiAgICAgICAgICAgIHZhciB0aW5kZXg7IC8vIHRlbXBvcmFyeSBwb2ludGVyXFxyXFxuICAgICAgICAgICAgdmFyIGU7IC8vIGV4dHJhIGJpdHMgb3Igb3BlcmF0aW9uXFxyXFxuICAgICAgICAgICAgdmFyIGIgPSAwOyAvLyBiaXQgYnVmZmVyXFxyXFxuICAgICAgICAgICAgdmFyIGsgPSAwOyAvLyBiaXRzIGluIGJpdCBidWZmZXJcXHJcXG4gICAgICAgICAgICB2YXIgcCA9IDA7IC8vIGlucHV0IGRhdGEgcG9pbnRlclxcclxcbiAgICAgICAgICAgIHZhciBuOyAvLyBieXRlcyBhdmFpbGFibGUgdGhlcmVcXHJcXG4gICAgICAgICAgICB2YXIgcTsgLy8gb3V0cHV0IHdpbmRvdyB3cml0ZSBwb2ludGVyXFxyXFxuICAgICAgICAgICAgdmFyIG07IC8vIGJ5dGVzIHRvIGVuZCBvZiB3aW5kb3cgb3IgcmVhZCBwb2ludGVyXFxyXFxuICAgICAgICAgICAgdmFyIGY7IC8vIHBvaW50ZXIgdG8gY29weSBzdHJpbmdzIGZyb21cXHJcXG5cXHJcXG4gICAgICAgICAgICAvLyBjb3B5IGlucHV0L291dHB1dCBpbmZvcm1hdGlvbiB0byBsb2NhbHMgKFVQREFURSBtYWNybyByZXN0b3JlcylcXHJcXG4gICAgICAgICAgICBwID0gei5uZXh0X2luX2luZGV4O1xcclxcbiAgICAgICAgICAgIG4gPSB6LmF2YWlsX2luO1xcclxcbiAgICAgICAgICAgIGIgPSBzLmJpdGI7XFxyXFxuICAgICAgICAgICAgayA9IHMuYml0aztcXHJcXG4gICAgICAgICAgICBxID0gcy53cml0ZTtcXHJcXG4gICAgICAgICAgICBtID0gcSA8IHMucmVhZCA/IHMucmVhZCAtIHEgLSAxIDogcy5lbmQgLSBxO1xcclxcblxcclxcbiAgICAgICAgICAgIC8vIHByb2Nlc3MgaW5wdXQgYW5kIG91dHB1dCBiYXNlZCBvbiBjdXJyZW50IHN0YXRlXFxyXFxuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcXHJcXG4gICAgICAgICAgICAgICAgc3dpdGNoIChtb2RlKSB7XFxyXFxuICAgICAgICAgICAgICAgIC8vIHdhaXRpbmcgZm9yIFxcXCJpOlxcXCI9aW5wdXQsIFxcXCJvOlxcXCI9b3V0cHV0LCBcXFwieDpcXFwiPW5vdGhpbmdcXHJcXG4gICAgICAgICAgICAgICAgY2FzZSBTVEFSVDogLy8geDogc2V0IHVwIGZvciBMRU5cXHJcXG4gICAgICAgICAgICAgICAgICAgIGlmIChtID49IDI1OCAmJiBuID49IDEwKSB7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgcy5iaXRiID0gYjtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBzLmJpdGsgPSBrO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHouYXZhaWxfaW4gPSBuO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHoudG90YWxfaW4gKz0gcCAtIHoubmV4dF9pbl9pbmRleDtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB6Lm5leHRfaW5faW5kZXggPSBwO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHMud3JpdGUgPSBxO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHIgPSBpbmZsYXRlX2Zhc3QobGJpdHMsIGRiaXRzLCBsdHJlZSwgbHRyZWVfaW5kZXgsIGR0cmVlLCBkdHJlZV9pbmRleCwgcywgeik7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgcCA9IHoubmV4dF9pbl9pbmRleDtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBuID0gei5hdmFpbF9pbjtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBiID0gcy5iaXRiO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGsgPSBzLmJpdGs7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgcSA9IHMud3JpdGU7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgbSA9IHEgPCBzLnJlYWQgPyBzLnJlYWQgLSBxIC0gMSA6IHMuZW5kIC0gcTtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAociAhPSBaX09LKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGUgPSByID09IFpfU1RSRUFNX0VORCA/IFdBU0ggOiBCQURDT0RFO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgICAgICBuZWVkID0gbGJpdHM7XFxyXFxuICAgICAgICAgICAgICAgICAgICB0cmVlID0gbHRyZWU7XFxyXFxuICAgICAgICAgICAgICAgICAgICB0cmVlX2luZGV4ID0gbHRyZWVfaW5kZXg7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICBtb2RlID0gTEVOO1xcclxcbiAgICAgICAgICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xcclxcbiAgICAgICAgICAgICAgICBjYXNlIExFTjogLy8gaTogZ2V0IGxlbmd0aC9saXRlcmFsL2VvYiBuZXh0XFxyXFxuICAgICAgICAgICAgICAgICAgICBqID0gbmVlZDtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChrIDwgKGopKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG4gIT09IDApXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgPSBaX09LO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzLmJpdGIgPSBiO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzLmJpdGsgPSBrO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB6LmF2YWlsX2luID0gbjtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgei50b3RhbF9pbiArPSBwIC0gei5uZXh0X2luX2luZGV4O1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB6Lm5leHRfaW5faW5kZXggPSBwO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzLndyaXRlID0gcTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHMuaW5mbGF0ZV9mbHVzaCh6LCByKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgbi0tO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGIgfD0gKHoucmVhZF9ieXRlKHArKykgJiAweGZmKSA8PCBrO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGsgKz0gODtcXHJcXG4gICAgICAgICAgICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgIHRpbmRleCA9ICh0cmVlX2luZGV4ICsgKGIgJiBpbmZsYXRlX21hc2tbal0pKSAqIDM7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICBiID4+Pj0gKHRyZWVbdGluZGV4ICsgMV0pO1xcclxcbiAgICAgICAgICAgICAgICAgICAgayAtPSAodHJlZVt0aW5kZXggKyAxXSk7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICBlID0gdHJlZVt0aW5kZXhdO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUgPT09IDApIHsgLy8gbGl0ZXJhbFxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpdCA9IHRyZWVbdGluZGV4ICsgMl07XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZSA9IExJVDtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcXHJcXG4gICAgICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgICAgIGlmICgoZSAmIDE2KSAhPT0gMCkgeyAvLyBsZW5ndGhcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQgPSBlICYgMTU7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVuID0gdHJlZVt0aW5kZXggKyAyXTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlID0gTEVORVhUO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcclxcbiAgICAgICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICAgICAgaWYgKChlICYgNjQpID09PSAwKSB7IC8vIG5leHQgdGFibGVcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBuZWVkID0gZTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmVlX2luZGV4ID0gdGluZGV4IC8gMyArIHRyZWVbdGluZGV4ICsgMl07XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxyXFxuICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgICAgICBpZiAoKGUgJiAzMikgIT09IDApIHsgLy8gZW5kIG9mIGJsb2NrXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZSA9IFdBU0g7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxyXFxuICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgICAgICBtb2RlID0gQkFEQ09ERTsgLy8gaW52YWxpZCBjb2RlXFxyXFxuICAgICAgICAgICAgICAgICAgICB6Lm1zZyA9IFxcXCJpbnZhbGlkIGxpdGVyYWwvbGVuZ3RoIGNvZGVcXFwiO1xcclxcbiAgICAgICAgICAgICAgICAgICAgciA9IFpfREFUQV9FUlJPUjtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgIHMuYml0YiA9IGI7XFxyXFxuICAgICAgICAgICAgICAgICAgICBzLmJpdGsgPSBrO1xcclxcbiAgICAgICAgICAgICAgICAgICAgei5hdmFpbF9pbiA9IG47XFxyXFxuICAgICAgICAgICAgICAgICAgICB6LnRvdGFsX2luICs9IHAgLSB6Lm5leHRfaW5faW5kZXg7XFxyXFxuICAgICAgICAgICAgICAgICAgICB6Lm5leHRfaW5faW5kZXggPSBwO1xcclxcbiAgICAgICAgICAgICAgICAgICAgcy53cml0ZSA9IHE7XFxyXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcy5pbmZsYXRlX2ZsdXNoKHosIHIpO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICBjYXNlIExFTkVYVDogLy8gaTogZ2V0dGluZyBsZW5ndGggZXh0cmEgKGhhdmUgYmFzZSlcXHJcXG4gICAgICAgICAgICAgICAgICAgIGogPSBnZXQ7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoayA8IChqKSkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuICE9PSAwKVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByID0gWl9PSztcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcy5iaXRiID0gYjtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcy5iaXRrID0gaztcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgei5hdmFpbF9pbiA9IG47XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHoudG90YWxfaW4gKz0gcCAtIHoubmV4dF9pbl9pbmRleDtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgei5uZXh0X2luX2luZGV4ID0gcDtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcy53cml0ZSA9IHE7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzLmluZmxhdGVfZmx1c2goeiwgcik7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIG4tLTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBiIHw9ICh6LnJlYWRfYnl0ZShwKyspICYgMHhmZikgPDwgaztcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBrICs9IDg7XFxyXFxuICAgICAgICAgICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICBsZW4gKz0gKGIgJiBpbmZsYXRlX21hc2tbal0pO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgYiA+Pj0gajtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGsgLT0gajtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgIG5lZWQgPSBkYml0cztcXHJcXG4gICAgICAgICAgICAgICAgICAgIHRyZWUgPSBkdHJlZTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHRyZWVfaW5kZXggPSBkdHJlZV9pbmRleDtcXHJcXG4gICAgICAgICAgICAgICAgICAgIG1vZGUgPSBESVNUO1xcclxcbiAgICAgICAgICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xcclxcbiAgICAgICAgICAgICAgICBjYXNlIERJU1Q6IC8vIGk6IGdldCBkaXN0YW5jZSBuZXh0XFxyXFxuICAgICAgICAgICAgICAgICAgICBqID0gbmVlZDtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChrIDwgKGopKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG4gIT09IDApXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgPSBaX09LO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzLmJpdGIgPSBiO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzLmJpdGsgPSBrO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB6LmF2YWlsX2luID0gbjtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgei50b3RhbF9pbiArPSBwIC0gei5uZXh0X2luX2luZGV4O1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB6Lm5leHRfaW5faW5kZXggPSBwO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzLndyaXRlID0gcTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHMuaW5mbGF0ZV9mbHVzaCh6LCByKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgbi0tO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGIgfD0gKHoucmVhZF9ieXRlKHArKykgJiAweGZmKSA8PCBrO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGsgKz0gODtcXHJcXG4gICAgICAgICAgICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgIHRpbmRleCA9ICh0cmVlX2luZGV4ICsgKGIgJiBpbmZsYXRlX21hc2tbal0pKSAqIDM7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICBiID4+PSB0cmVlW3RpbmRleCArIDFdO1xcclxcbiAgICAgICAgICAgICAgICAgICAgayAtPSB0cmVlW3RpbmRleCArIDFdO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgZSA9ICh0cmVlW3RpbmRleF0pO1xcclxcbiAgICAgICAgICAgICAgICAgICAgaWYgKChlICYgMTYpICE9PSAwKSB7IC8vIGRpc3RhbmNlXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0ID0gZSAmIDE1O1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3QgPSB0cmVlW3RpbmRleCArIDJdO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGUgPSBESVNURVhUO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcclxcbiAgICAgICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICAgICAgaWYgKChlICYgNjQpID09PSAwKSB7IC8vIG5leHQgdGFibGVcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBuZWVkID0gZTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmVlX2luZGV4ID0gdGluZGV4IC8gMyArIHRyZWVbdGluZGV4ICsgMl07XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxyXFxuICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgICAgICBtb2RlID0gQkFEQ09ERTsgLy8gaW52YWxpZCBjb2RlXFxyXFxuICAgICAgICAgICAgICAgICAgICB6Lm1zZyA9IFxcXCJpbnZhbGlkIGRpc3RhbmNlIGNvZGVcXFwiO1xcclxcbiAgICAgICAgICAgICAgICAgICAgciA9IFpfREFUQV9FUlJPUjtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgIHMuYml0YiA9IGI7XFxyXFxuICAgICAgICAgICAgICAgICAgICBzLmJpdGsgPSBrO1xcclxcbiAgICAgICAgICAgICAgICAgICAgei5hdmFpbF9pbiA9IG47XFxyXFxuICAgICAgICAgICAgICAgICAgICB6LnRvdGFsX2luICs9IHAgLSB6Lm5leHRfaW5faW5kZXg7XFxyXFxuICAgICAgICAgICAgICAgICAgICB6Lm5leHRfaW5faW5kZXggPSBwO1xcclxcbiAgICAgICAgICAgICAgICAgICAgcy53cml0ZSA9IHE7XFxyXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcy5pbmZsYXRlX2ZsdXNoKHosIHIpO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICBjYXNlIERJU1RFWFQ6IC8vIGk6IGdldHRpbmcgZGlzdGFuY2UgZXh0cmFcXHJcXG4gICAgICAgICAgICAgICAgICAgIGogPSBnZXQ7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoayA8IChqKSkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuICE9PSAwKVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByID0gWl9PSztcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcy5iaXRiID0gYjtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcy5iaXRrID0gaztcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgei5hdmFpbF9pbiA9IG47XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHoudG90YWxfaW4gKz0gcCAtIHoubmV4dF9pbl9pbmRleDtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgei5uZXh0X2luX2luZGV4ID0gcDtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcy53cml0ZSA9IHE7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzLmluZmxhdGVfZmx1c2goeiwgcik7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIG4tLTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBiIHw9ICh6LnJlYWRfYnl0ZShwKyspICYgMHhmZikgPDwgaztcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBrICs9IDg7XFxyXFxuICAgICAgICAgICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICBkaXN0ICs9IChiICYgaW5mbGF0ZV9tYXNrW2pdKTtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgIGIgPj49IGo7XFxyXFxuICAgICAgICAgICAgICAgICAgICBrIC09IGo7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICBtb2RlID0gQ09QWTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cXHJcXG4gICAgICAgICAgICAgICAgY2FzZSBDT1BZOiAvLyBvOiBjb3B5aW5nIGJ5dGVzIGluIHdpbmRvdywgd2FpdGluZyBmb3Igc3BhY2VcXHJcXG4gICAgICAgICAgICAgICAgICAgIGYgPSBxIC0gZGlzdDtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChmIDwgMCkgeyAvLyBtb2R1bG8gd2luZG93IHNpemUtXFxcIndoaWxlXFxcIiBpbnN0ZWFkXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgZiArPSBzLmVuZDsgLy8gb2YgXFxcImlmXFxcIiBoYW5kbGVzIGludmFsaWQgZGlzdGFuY2VzXFxyXFxuICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAobGVuICE9PSAwKSB7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG0gPT09IDApIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHEgPT0gcy5lbmQgJiYgcy5yZWFkICE9PSAwKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxID0gMDtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0gPSBxIDwgcy5yZWFkID8gcy5yZWFkIC0gcSAtIDEgOiBzLmVuZCAtIHE7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG0gPT09IDApIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMud3JpdGUgPSBxO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgciA9IHMuaW5mbGF0ZV9mbHVzaCh6LCByKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHEgPSBzLndyaXRlO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbSA9IHEgPCBzLnJlYWQgPyBzLnJlYWQgLSBxIC0gMSA6IHMuZW5kIC0gcTtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChxID09IHMuZW5kICYmIHMucmVhZCAhPT0gMCkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHEgPSAwO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0gPSBxIDwgcy5yZWFkID8gcy5yZWFkIC0gcSAtIDEgOiBzLmVuZCAtIHE7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobSA9PT0gMCkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMuYml0YiA9IGI7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcy5iaXRrID0gaztcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB6LmF2YWlsX2luID0gbjtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB6LnRvdGFsX2luICs9IHAgLSB6Lm5leHRfaW5faW5kZXg7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgei5uZXh0X2luX2luZGV4ID0gcDtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzLndyaXRlID0gcTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcy5pbmZsYXRlX2ZsdXNoKHosIHIpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHMud2luZG93W3ErK10gPSBzLndpbmRvd1tmKytdO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIG0tLTtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZiA9PSBzLmVuZClcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZiA9IDA7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVuLS07XFxyXFxuICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgICAgICBtb2RlID0gU1RBUlQ7XFxyXFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcXHJcXG4gICAgICAgICAgICAgICAgY2FzZSBMSVQ6IC8vIG86IGdvdCBsaXRlcmFsLCB3YWl0aW5nIGZvciBvdXRwdXQgc3BhY2VcXHJcXG4gICAgICAgICAgICAgICAgICAgIGlmIChtID09PSAwKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHEgPT0gcy5lbmQgJiYgcy5yZWFkICE9PSAwKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHEgPSAwO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtID0gcSA8IHMucmVhZCA/IHMucmVhZCAtIHEgLSAxIDogcy5lbmQgLSBxO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobSA9PT0gMCkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzLndyaXRlID0gcTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgciA9IHMuaW5mbGF0ZV9mbHVzaCh6LCByKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcSA9IHMud3JpdGU7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0gPSBxIDwgcy5yZWFkID8gcy5yZWFkIC0gcSAtIDEgOiBzLmVuZCAtIHE7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChxID09IHMuZW5kICYmIHMucmVhZCAhPT0gMCkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcSA9IDA7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtID0gcSA8IHMucmVhZCA/IHMucmVhZCAtIHEgLSAxIDogcy5lbmQgLSBxO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtID09PSAwKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzLmJpdGIgPSBiO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcy5iaXRrID0gaztcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHouYXZhaWxfaW4gPSBuO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgei50b3RhbF9pbiArPSBwIC0gei5uZXh0X2luX2luZGV4O1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgei5uZXh0X2luX2luZGV4ID0gcDtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMud3JpdGUgPSBxO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHMuaW5mbGF0ZV9mbHVzaCh6LCByKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgICAgIHIgPSBaX09LO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgcy53aW5kb3dbcSsrXSA9IC8qIChieXRlKSAqL2xpdDtcXHJcXG4gICAgICAgICAgICAgICAgICAgIG0tLTtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgIG1vZGUgPSBTVEFSVDtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcclxcbiAgICAgICAgICAgICAgICBjYXNlIFdBU0g6IC8vIG86IGdvdCBlb2IsIHBvc3NpYmx5IG1vcmUgb3V0cHV0XFxyXFxuICAgICAgICAgICAgICAgICAgICBpZiAoayA+IDcpIHsgLy8gcmV0dXJuIHVudXNlZCBieXRlLCBpZiBhbnlcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBrIC09IDg7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgbisrO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHAtLTsgLy8gY2FuIGFsd2F5cyByZXR1cm4gb25lXFxyXFxuICAgICAgICAgICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICBzLndyaXRlID0gcTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHIgPSBzLmluZmxhdGVfZmx1c2goeiwgcik7XFxyXFxuICAgICAgICAgICAgICAgICAgICBxID0gcy53cml0ZTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIG0gPSBxIDwgcy5yZWFkID8gcy5yZWFkIC0gcSAtIDEgOiBzLmVuZCAtIHE7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICBpZiAocy5yZWFkICE9IHMud3JpdGUpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBzLmJpdGIgPSBiO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHMuYml0ayA9IGs7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgei5hdmFpbF9pbiA9IG47XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgei50b3RhbF9pbiArPSBwIC0gei5uZXh0X2luX2luZGV4O1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHoubmV4dF9pbl9pbmRleCA9IHA7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgcy53cml0ZSA9IHE7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHMuaW5mbGF0ZV9mbHVzaCh6LCByKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgICAgIG1vZGUgPSBFTkQ7XFxyXFxuICAgICAgICAgICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXFxyXFxuICAgICAgICAgICAgICAgIGNhc2UgRU5EOlxcclxcbiAgICAgICAgICAgICAgICAgICAgciA9IFpfU1RSRUFNX0VORDtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHMuYml0YiA9IGI7XFxyXFxuICAgICAgICAgICAgICAgICAgICBzLmJpdGsgPSBrO1xcclxcbiAgICAgICAgICAgICAgICAgICAgei5hdmFpbF9pbiA9IG47XFxyXFxuICAgICAgICAgICAgICAgICAgICB6LnRvdGFsX2luICs9IHAgLSB6Lm5leHRfaW5faW5kZXg7XFxyXFxuICAgICAgICAgICAgICAgICAgICB6Lm5leHRfaW5faW5kZXggPSBwO1xcclxcbiAgICAgICAgICAgICAgICAgICAgcy53cml0ZSA9IHE7XFxyXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcy5pbmZsYXRlX2ZsdXNoKHosIHIpO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICBjYXNlIEJBRENPREU6IC8vIHg6IGdvdCBlcnJvclxcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgciA9IFpfREFUQV9FUlJPUjtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgIHMuYml0YiA9IGI7XFxyXFxuICAgICAgICAgICAgICAgICAgICBzLmJpdGsgPSBrO1xcclxcbiAgICAgICAgICAgICAgICAgICAgei5hdmFpbF9pbiA9IG47XFxyXFxuICAgICAgICAgICAgICAgICAgICB6LnRvdGFsX2luICs9IHAgLSB6Lm5leHRfaW5faW5kZXg7XFxyXFxuICAgICAgICAgICAgICAgICAgICB6Lm5leHRfaW5faW5kZXggPSBwO1xcclxcbiAgICAgICAgICAgICAgICAgICAgcy53cml0ZSA9IHE7XFxyXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcy5pbmZsYXRlX2ZsdXNoKHosIHIpO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxcclxcbiAgICAgICAgICAgICAgICAgICAgciA9IFpfU1RSRUFNX0VSUk9SO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgcy5iaXRiID0gYjtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHMuYml0ayA9IGs7XFxyXFxuICAgICAgICAgICAgICAgICAgICB6LmF2YWlsX2luID0gbjtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHoudG90YWxfaW4gKz0gcCAtIHoubmV4dF9pbl9pbmRleDtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHoubmV4dF9pbl9pbmRleCA9IHA7XFxyXFxuICAgICAgICAgICAgICAgICAgICBzLndyaXRlID0gcTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzLmluZmxhdGVfZmx1c2goeiwgcik7XFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICB9O1xcclxcblxcclxcbiAgICAgICAgdGhhdC5mcmVlID0gZnVuY3Rpb24oKSB7XFxyXFxuICAgICAgICAgICAgLy8gWkZSRUUoeiwgYyk7XFxyXFxuICAgICAgICB9O1xcclxcblxcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgIC8vIEluZkJsb2Nrc1xcclxcblxcclxcbiAgICAvLyBUYWJsZSBmb3IgZGVmbGF0ZSBmcm9tIFBLWklQJ3MgYXBwbm90ZS50eHQuXFxyXFxuICAgIHZhciBib3JkZXIgPSBbIC8vIE9yZGVyIG9mIHRoZSBiaXQgbGVuZ3RoIGNvZGUgbGVuZ3Roc1xcclxcbiAgICAxNiwgMTcsIDE4LCAwLCA4LCA3LCA5LCA2LCAxMCwgNSwgMTEsIDQsIDEyLCAzLCAxMywgMiwgMTQsIDEsIDE1IF07XFxyXFxuXFxyXFxuICAgIHZhciBUWVBFID0gMDsgLy8gZ2V0IHR5cGUgYml0cyAoMywgaW5jbHVkaW5nIGVuZCBiaXQpXFxyXFxuICAgIHZhciBMRU5TID0gMTsgLy8gZ2V0IGxlbmd0aHMgZm9yIHN0b3JlZFxcclxcbiAgICB2YXIgU1RPUkVEID0gMjsvLyBwcm9jZXNzaW5nIHN0b3JlZCBibG9ja1xcclxcbiAgICB2YXIgVEFCTEUgPSAzOyAvLyBnZXQgdGFibGUgbGVuZ3Roc1xcclxcbiAgICB2YXIgQlRSRUUgPSA0OyAvLyBnZXQgYml0IGxlbmd0aHMgdHJlZSBmb3IgYSBkeW5hbWljXFxyXFxuICAgIC8vIGJsb2NrXFxyXFxuICAgIHZhciBEVFJFRSA9IDU7IC8vIGdldCBsZW5ndGgsIGRpc3RhbmNlIHRyZWVzIGZvciBhXFxyXFxuICAgIC8vIGR5bmFtaWMgYmxvY2tcXHJcXG4gICAgdmFyIENPREVTID0gNjsgLy8gcHJvY2Vzc2luZyBmaXhlZCBvciBkeW5hbWljIGJsb2NrXFxyXFxuICAgIHZhciBEUlkgPSA3OyAvLyBvdXRwdXQgcmVtYWluaW5nIHdpbmRvdyBieXRlc1xcclxcbiAgICB2YXIgRE9ORUxPQ0tTID0gODsgLy8gZmluaXNoZWQgbGFzdCBibG9jaywgZG9uZVxcclxcbiAgICB2YXIgQkFEQkxPQ0tTID0gOTsgLy8gb3QgYSBkYXRhIGVycm9yLS1zdHVjayBoZXJlXFxyXFxuXFxyXFxuICAgIGZ1bmN0aW9uIEluZkJsb2Nrcyh6LCB3KSB7XFxyXFxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XFxyXFxuXFxyXFxuICAgICAgICB2YXIgbW9kZSA9IFRZUEU7IC8vIGN1cnJlbnQgaW5mbGF0ZV9ibG9jayBtb2RlXFxyXFxuXFxyXFxuICAgICAgICB2YXIgbGVmdCA9IDA7IC8vIGlmIFNUT1JFRCwgYnl0ZXMgbGVmdCB0byBjb3B5XFxyXFxuXFxyXFxuICAgICAgICB2YXIgdGFibGUgPSAwOyAvLyB0YWJsZSBsZW5ndGhzICgxNCBiaXRzKVxcclxcbiAgICAgICAgdmFyIGluZGV4ID0gMDsgLy8gaW5kZXggaW50byBibGVucyAob3IgYm9yZGVyKVxcclxcbiAgICAgICAgdmFyIGJsZW5zOyAvLyBiaXQgbGVuZ3RocyBvZiBjb2Rlc1xcclxcbiAgICAgICAgdmFyIGJiID0gWyAwIF07IC8vIGJpdCBsZW5ndGggdHJlZSBkZXB0aFxcclxcbiAgICAgICAgdmFyIHRiID0gWyAwIF07IC8vIGJpdCBsZW5ndGggZGVjb2RpbmcgdHJlZVxcclxcblxcclxcbiAgICAgICAgdmFyIGNvZGVzID0gbmV3IEluZkNvZGVzKCk7IC8vIGlmIENPREVTLCBjdXJyZW50IHN0YXRlXFxyXFxuXFxyXFxuICAgICAgICB2YXIgbGFzdCA9IDA7IC8vIHRydWUgaWYgdGhpcyBibG9jayBpcyB0aGUgbGFzdCBibG9ja1xcclxcblxcclxcbiAgICAgICAgdmFyIGh1ZnRzID0gbmV3IEludDMyQXJyYXkoTUFOWSAqIDMpOyAvLyBzaW5nbGUgbWFsbG9jIGZvciB0cmVlIHNwYWNlXFxyXFxuICAgICAgICB2YXIgY2hlY2sgPSAwOyAvLyBjaGVjayBvbiBvdXRwdXRcXHJcXG4gICAgICAgIHZhciBpbmZ0cmVlID0gbmV3IEluZlRyZWUoKTtcXHJcXG5cXHJcXG4gICAgICAgIHRoYXQuYml0ayA9IDA7IC8vIGJpdHMgaW4gYml0IGJ1ZmZlclxcclxcbiAgICAgICAgdGhhdC5iaXRiID0gMDsgLy8gYml0IGJ1ZmZlclxcclxcbiAgICAgICAgdGhhdC53aW5kb3cgPSBuZXcgVWludDhBcnJheSh3KTsgLy8gc2xpZGluZyB3aW5kb3dcXHJcXG4gICAgICAgIHRoYXQuZW5kID0gdzsgLy8gb25lIGJ5dGUgYWZ0ZXIgc2xpZGluZyB3aW5kb3dcXHJcXG4gICAgICAgIHRoYXQucmVhZCA9IDA7IC8vIHdpbmRvdyByZWFkIHBvaW50ZXJcXHJcXG4gICAgICAgIHRoYXQud3JpdGUgPSAwOyAvLyB3aW5kb3cgd3JpdGUgcG9pbnRlclxcclxcblxcclxcbiAgICAgICAgdGhhdC5yZXNldCA9IGZ1bmN0aW9uKHosIGMpIHtcXHJcXG4gICAgICAgICAgICBpZiAoYylcXHJcXG4gICAgICAgICAgICAgICAgY1swXSA9IGNoZWNrO1xcclxcbiAgICAgICAgICAgIC8vIGlmIChtb2RlID09IEJUUkVFIHx8IG1vZGUgPT0gRFRSRUUpIHtcXHJcXG4gICAgICAgICAgICAvLyB9XFxyXFxuICAgICAgICAgICAgaWYgKG1vZGUgPT0gQ09ERVMpIHtcXHJcXG4gICAgICAgICAgICAgICAgY29kZXMuZnJlZSh6KTtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgbW9kZSA9IFRZUEU7XFxyXFxuICAgICAgICAgICAgdGhhdC5iaXRrID0gMDtcXHJcXG4gICAgICAgICAgICB0aGF0LmJpdGIgPSAwO1xcclxcbiAgICAgICAgICAgIHRoYXQucmVhZCA9IHRoYXQud3JpdGUgPSAwO1xcclxcbiAgICAgICAgfTtcXHJcXG5cXHJcXG4gICAgICAgIHRoYXQucmVzZXQoeiwgbnVsbCk7XFxyXFxuXFxyXFxuICAgICAgICAvLyBjb3B5IGFzIG11Y2ggYXMgcG9zc2libGUgZnJvbSB0aGUgc2xpZGluZyB3aW5kb3cgdG8gdGhlIG91dHB1dCBhcmVhXFxyXFxuICAgICAgICB0aGF0LmluZmxhdGVfZmx1c2ggPSBmdW5jdGlvbih6LCByKSB7XFxyXFxuICAgICAgICAgICAgdmFyIG47XFxyXFxuICAgICAgICAgICAgdmFyIHA7XFxyXFxuICAgICAgICAgICAgdmFyIHE7XFxyXFxuXFxyXFxuICAgICAgICAgICAgLy8gbG9jYWwgY29waWVzIG9mIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gcG9pbnRlcnNcXHJcXG4gICAgICAgICAgICBwID0gei5uZXh0X291dF9pbmRleDtcXHJcXG4gICAgICAgICAgICBxID0gdGhhdC5yZWFkO1xcclxcblxcclxcbiAgICAgICAgICAgIC8vIGNvbXB1dGUgbnVtYmVyIG9mIGJ5dGVzIHRvIGNvcHkgYXMgZmFyIGFzIGVuZCBvZiB3aW5kb3dcXHJcXG4gICAgICAgICAgICBuID0gLyogKGludCkgKi8oKHEgPD0gdGhhdC53cml0ZSA/IHRoYXQud3JpdGUgOiB0aGF0LmVuZCkgLSBxKTtcXHJcXG4gICAgICAgICAgICBpZiAobiA+IHouYXZhaWxfb3V0KVxcclxcbiAgICAgICAgICAgICAgICBuID0gei5hdmFpbF9vdXQ7XFxyXFxuICAgICAgICAgICAgaWYgKG4gIT09IDAgJiYgciA9PSBaX0JVRl9FUlJPUilcXHJcXG4gICAgICAgICAgICAgICAgciA9IFpfT0s7XFxyXFxuXFxyXFxuICAgICAgICAgICAgLy8gdXBkYXRlIGNvdW50ZXJzXFxyXFxuICAgICAgICAgICAgei5hdmFpbF9vdXQgLT0gbjtcXHJcXG4gICAgICAgICAgICB6LnRvdGFsX291dCArPSBuO1xcclxcblxcclxcbiAgICAgICAgICAgIC8vIGNvcHkgYXMgZmFyIGFzIGVuZCBvZiB3aW5kb3dcXHJcXG4gICAgICAgICAgICB6Lm5leHRfb3V0LnNldCh0aGF0LndpbmRvdy5zdWJhcnJheShxLCBxICsgbiksIHApO1xcclxcbiAgICAgICAgICAgIHAgKz0gbjtcXHJcXG4gICAgICAgICAgICBxICs9IG47XFxyXFxuXFxyXFxuICAgICAgICAgICAgLy8gc2VlIGlmIG1vcmUgdG8gY29weSBhdCBiZWdpbm5pbmcgb2Ygd2luZG93XFxyXFxuICAgICAgICAgICAgaWYgKHEgPT0gdGhhdC5lbmQpIHtcXHJcXG4gICAgICAgICAgICAgICAgLy8gd3JhcCBwb2ludGVyc1xcclxcbiAgICAgICAgICAgICAgICBxID0gMDtcXHJcXG4gICAgICAgICAgICAgICAgaWYgKHRoYXQud3JpdGUgPT0gdGhhdC5lbmQpXFxyXFxuICAgICAgICAgICAgICAgICAgICB0aGF0LndyaXRlID0gMDtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgLy8gY29tcHV0ZSBieXRlcyB0byBjb3B5XFxyXFxuICAgICAgICAgICAgICAgIG4gPSB0aGF0LndyaXRlIC0gcTtcXHJcXG4gICAgICAgICAgICAgICAgaWYgKG4gPiB6LmF2YWlsX291dClcXHJcXG4gICAgICAgICAgICAgICAgICAgIG4gPSB6LmF2YWlsX291dDtcXHJcXG4gICAgICAgICAgICAgICAgaWYgKG4gIT09IDAgJiYgciA9PSBaX0JVRl9FUlJPUilcXHJcXG4gICAgICAgICAgICAgICAgICAgIHIgPSBaX09LO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgY291bnRlcnNcXHJcXG4gICAgICAgICAgICAgICAgei5hdmFpbF9vdXQgLT0gbjtcXHJcXG4gICAgICAgICAgICAgICAgei50b3RhbF9vdXQgKz0gbjtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgLy8gY29weVxcclxcbiAgICAgICAgICAgICAgICB6Lm5leHRfb3V0LnNldCh0aGF0LndpbmRvdy5zdWJhcnJheShxLCBxICsgbiksIHApO1xcclxcbiAgICAgICAgICAgICAgICBwICs9IG47XFxyXFxuICAgICAgICAgICAgICAgIHEgKz0gbjtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgLy8gdXBkYXRlIHBvaW50ZXJzXFxyXFxuICAgICAgICAgICAgei5uZXh0X291dF9pbmRleCA9IHA7XFxyXFxuICAgICAgICAgICAgdGhhdC5yZWFkID0gcTtcXHJcXG5cXHJcXG4gICAgICAgICAgICAvLyBkb25lXFxyXFxuICAgICAgICAgICAgcmV0dXJuIHI7XFxyXFxuICAgICAgICB9O1xcclxcblxcclxcbiAgICAgICAgdGhhdC5wcm9jID0gZnVuY3Rpb24oeiwgcikge1xcclxcbiAgICAgICAgICAgIHZhciB0OyAvLyB0ZW1wb3Jhcnkgc3RvcmFnZVxcclxcbiAgICAgICAgICAgIHZhciBiOyAvLyBiaXQgYnVmZmVyXFxyXFxuICAgICAgICAgICAgdmFyIGs7IC8vIGJpdHMgaW4gYml0IGJ1ZmZlclxcclxcbiAgICAgICAgICAgIHZhciBwOyAvLyBpbnB1dCBkYXRhIHBvaW50ZXJcXHJcXG4gICAgICAgICAgICB2YXIgbjsgLy8gYnl0ZXMgYXZhaWxhYmxlIHRoZXJlXFxyXFxuICAgICAgICAgICAgdmFyIHE7IC8vIG91dHB1dCB3aW5kb3cgd3JpdGUgcG9pbnRlclxcclxcbiAgICAgICAgICAgIHZhciBtOyAvLyBieXRlcyB0byBlbmQgb2Ygd2luZG93IG9yIHJlYWQgcG9pbnRlclxcclxcblxcclxcbiAgICAgICAgICAgIHZhciBpO1xcclxcblxcclxcbiAgICAgICAgICAgIC8vIGNvcHkgaW5wdXQvb3V0cHV0IGluZm9ybWF0aW9uIHRvIGxvY2FscyAoVVBEQVRFIG1hY3JvIHJlc3RvcmVzKVxcclxcbiAgICAgICAgICAgIC8vIHtcXHJcXG4gICAgICAgICAgICBwID0gei5uZXh0X2luX2luZGV4O1xcclxcbiAgICAgICAgICAgIG4gPSB6LmF2YWlsX2luO1xcclxcbiAgICAgICAgICAgIGIgPSB0aGF0LmJpdGI7XFxyXFxuICAgICAgICAgICAgayA9IHRoYXQuYml0aztcXHJcXG4gICAgICAgICAgICAvLyB9XFxyXFxuICAgICAgICAgICAgLy8ge1xcclxcbiAgICAgICAgICAgIHEgPSB0aGF0LndyaXRlO1xcclxcbiAgICAgICAgICAgIG0gPSAvKiAoaW50KSAqLyhxIDwgdGhhdC5yZWFkID8gdGhhdC5yZWFkIC0gcSAtIDEgOiB0aGF0LmVuZCAtIHEpO1xcclxcbiAgICAgICAgICAgIC8vIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICAvLyBwcm9jZXNzIGlucHV0IGJhc2VkIG9uIGN1cnJlbnQgc3RhdGVcXHJcXG4gICAgICAgICAgICAvLyBERUJVRyBkdHJlZVxcclxcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XFxyXFxuICAgICAgICAgICAgICAgIHN3aXRjaCAobW9kZSkge1xcclxcbiAgICAgICAgICAgICAgICBjYXNlIFRZUEU6XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoayA8ICgzKSkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuICE9PSAwKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgPSBaX09LO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuYml0YiA9IGI7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuYml0ayA9IGs7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHouYXZhaWxfaW4gPSBuO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB6LnRvdGFsX2luICs9IHAgLSB6Lm5leHRfaW5faW5kZXg7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHoubmV4dF9pbl9pbmRleCA9IHA7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQud3JpdGUgPSBxO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhhdC5pbmZsYXRlX2ZsdXNoKHosIHIpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBuLS07XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgYiB8PSAoei5yZWFkX2J5dGUocCsrKSAmIDB4ZmYpIDw8IGs7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgayArPSA4O1xcclxcbiAgICAgICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICAgICAgdCA9IC8qIChpbnQpICovKGIgJiA3KTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGxhc3QgPSB0ICYgMTtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodCA+Pj4gMSkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiAvLyBzdG9yZWRcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgYiA+Pj49ICgzKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBrIC09ICgzKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB9XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgdCA9IGsgJiA3OyAvLyBnbyB0byBieXRlIGJvdW5kYXJ5XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8ge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGIgPj4+PSAodCk7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgayAtPSAodCk7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gfVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGUgPSBMRU5TOyAvLyBnZXQgbGVuZ3RoIG9mIHN0b3JlZCBibG9ja1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcclxcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiAvLyBmaXhlZFxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYmwgPSBbXTsgLy8gbmV3IEFycmF5KDEpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiZCA9IFtdOyAvLyBuZXcgQXJyYXkoMSk7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRsID0gWyBbXSBdOyAvLyBuZXcgQXJyYXkoMSk7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRkID0gWyBbXSBdOyAvLyBuZXcgQXJyYXkoMSk7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgSW5mVHJlZS5pbmZsYXRlX3RyZWVzX2ZpeGVkKGJsLCBiZCwgdGwsIHRkKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2Rlcy5pbml0KGJsWzBdLCBiZFswXSwgdGxbMF0sIDAsIHRkWzBdLCAwKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8ge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGIgPj4+PSAoMyk7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgayAtPSAoMyk7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gfVxcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGUgPSBDT0RFUztcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcXHJcXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjogLy8gZHluYW1pY1xcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBiID4+Pj0gKDMpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGsgLT0gKDMpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlID0gVEFCTEU7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxyXFxuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6IC8vIGlsbGVnYWxcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgYiA+Pj49ICgzKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBrIC09ICgzKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB9XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZSA9IEJBREJMT0NLUztcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB6Lm1zZyA9IFxcXCJpbnZhbGlkIGJsb2NrIHR5cGVcXFwiO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHIgPSBaX0RBVEFfRVJST1I7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5iaXRiID0gYjtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmJpdGsgPSBrO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHouYXZhaWxfaW4gPSBuO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHoudG90YWxfaW4gKz0gcCAtIHoubmV4dF9pbl9pbmRleDtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB6Lm5leHRfaW5faW5kZXggPSBwO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQud3JpdGUgPSBxO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGF0LmluZmxhdGVfZmx1c2goeiwgcik7XFxyXFxuICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcXHJcXG4gICAgICAgICAgICAgICAgY2FzZSBMRU5TOlxcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGsgPCAoMzIpKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG4gIT09IDApIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgciA9IFpfT0s7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5iaXRiID0gYjtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5iaXRrID0gaztcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgei5hdmFpbF9pbiA9IG47XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHoudG90YWxfaW4gKz0gcCAtIHoubmV4dF9pbl9pbmRleDtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgei5uZXh0X2luX2luZGV4ID0gcDtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC53cml0ZSA9IHE7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGF0LmluZmxhdGVfZmx1c2goeiwgcik7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIG4tLTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBiIHw9ICh6LnJlYWRfYnl0ZShwKyspICYgMHhmZikgPDwgaztcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBrICs9IDg7XFxyXFxuICAgICAgICAgICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICBpZiAoKCgofmIpID4+PiAxNikgJiAweGZmZmYpICE9IChiICYgMHhmZmZmKSkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGUgPSBCQURCTE9DS1M7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgei5tc2cgPSBcXFwiaW52YWxpZCBzdG9yZWQgYmxvY2sgbGVuZ3Roc1xcXCI7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgciA9IFpfREFUQV9FUlJPUjtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmJpdGIgPSBiO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuYml0ayA9IGs7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgei5hdmFpbF9pbiA9IG47XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgei50b3RhbF9pbiArPSBwIC0gei5uZXh0X2luX2luZGV4O1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHoubmV4dF9pbl9pbmRleCA9IHA7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC53cml0ZSA9IHE7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoYXQuaW5mbGF0ZV9mbHVzaCh6LCByKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSAoYiAmIDB4ZmZmZik7XFxyXFxuICAgICAgICAgICAgICAgICAgICBiID0gayA9IDA7IC8vIGR1bXAgYml0c1xcclxcbiAgICAgICAgICAgICAgICAgICAgbW9kZSA9IGxlZnQgIT09IDAgPyBTVE9SRUQgOiAobGFzdCAhPT0gMCA/IERSWSA6IFRZUEUpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxyXFxuICAgICAgICAgICAgICAgIGNhc2UgU1RPUkVEOlxcclxcbiAgICAgICAgICAgICAgICAgICAgaWYgKG4gPT09IDApIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmJpdGIgPSBiO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuYml0ayA9IGs7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgei5hdmFpbF9pbiA9IG47XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgei50b3RhbF9pbiArPSBwIC0gei5uZXh0X2luX2luZGV4O1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHoubmV4dF9pbl9pbmRleCA9IHA7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC53cml0ZSA9IHE7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoYXQuaW5mbGF0ZV9mbHVzaCh6LCByKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgIGlmIChtID09PSAwKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHEgPT0gdGhhdC5lbmQgJiYgdGhhdC5yZWFkICE9PSAwKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHEgPSAwO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtID0gLyogKGludCkgKi8ocSA8IHRoYXQucmVhZCA/IHRoYXQucmVhZCAtIHEgLSAxIDogdGhhdC5lbmQgLSBxKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG0gPT09IDApIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC53cml0ZSA9IHE7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgPSB0aGF0LmluZmxhdGVfZmx1c2goeiwgcik7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHEgPSB0aGF0LndyaXRlO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtID0gLyogKGludCkgKi8ocSA8IHRoYXQucmVhZCA/IHRoYXQucmVhZCAtIHEgLSAxIDogdGhhdC5lbmQgLSBxKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHEgPT0gdGhhdC5lbmQgJiYgdGhhdC5yZWFkICE9PSAwKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxID0gMDtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0gPSAvKiAoaW50KSAqLyhxIDwgdGhhdC5yZWFkID8gdGhhdC5yZWFkIC0gcSAtIDEgOiB0aGF0LmVuZCAtIHEpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtID09PSAwKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmJpdGIgPSBiO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5iaXRrID0gaztcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHouYXZhaWxfaW4gPSBuO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgei50b3RhbF9pbiArPSBwIC0gei5uZXh0X2luX2luZGV4O1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgei5uZXh0X2luX2luZGV4ID0gcDtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQud3JpdGUgPSBxO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoYXQuaW5mbGF0ZV9mbHVzaCh6LCByKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgICAgIHIgPSBaX09LO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgdCA9IGxlZnQ7XFxyXFxuICAgICAgICAgICAgICAgICAgICBpZiAodCA+IG4pXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgdCA9IG47XFxyXFxuICAgICAgICAgICAgICAgICAgICBpZiAodCA+IG0pXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgdCA9IG07XFxyXFxuICAgICAgICAgICAgICAgICAgICB0aGF0LndpbmRvdy5zZXQoei5yZWFkX2J1ZihwLCB0KSwgcSk7XFxyXFxuICAgICAgICAgICAgICAgICAgICBwICs9IHQ7XFxyXFxuICAgICAgICAgICAgICAgICAgICBuIC09IHQ7XFxyXFxuICAgICAgICAgICAgICAgICAgICBxICs9IHQ7XFxyXFxuICAgICAgICAgICAgICAgICAgICBtIC09IHQ7XFxyXFxuICAgICAgICAgICAgICAgICAgICBpZiAoKGxlZnQgLT0gdCkgIT09IDApXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxyXFxuICAgICAgICAgICAgICAgICAgICBtb2RlID0gbGFzdCAhPT0gMCA/IERSWSA6IFRZUEU7XFxyXFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcXHJcXG4gICAgICAgICAgICAgICAgY2FzZSBUQUJMRTpcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChrIDwgKDE0KSkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuICE9PSAwKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgPSBaX09LO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuYml0YiA9IGI7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuYml0ayA9IGs7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHouYXZhaWxfaW4gPSBuO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB6LnRvdGFsX2luICs9IHAgLSB6Lm5leHRfaW5faW5kZXg7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHoubmV4dF9pbl9pbmRleCA9IHA7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQud3JpdGUgPSBxO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhhdC5pbmZsYXRlX2ZsdXNoKHosIHIpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBuLS07XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgYiB8PSAoei5yZWFkX2J5dGUocCsrKSAmIDB4ZmYpIDw8IGs7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgayArPSA4O1xcclxcbiAgICAgICAgICAgICAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgdGFibGUgPSB0ID0gKGIgJiAweDNmZmYpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgaWYgKCh0ICYgMHgxZikgPiAyOSB8fCAoKHQgPj4gNSkgJiAweDFmKSA+IDI5KSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZSA9IEJBREJMT0NLUztcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB6Lm1zZyA9IFxcXCJ0b28gbWFueSBsZW5ndGggb3IgZGlzdGFuY2Ugc3ltYm9sc1xcXCI7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgciA9IFpfREFUQV9FUlJPUjtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmJpdGIgPSBiO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuYml0ayA9IGs7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgei5hdmFpbF9pbiA9IG47XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgei50b3RhbF9pbiArPSBwIC0gei5uZXh0X2luX2luZGV4O1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHoubmV4dF9pbl9pbmRleCA9IHA7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC53cml0ZSA9IHE7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoYXQuaW5mbGF0ZV9mbHVzaCh6LCByKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgICAgIHQgPSAyNTggKyAodCAmIDB4MWYpICsgKCh0ID4+IDUpICYgMHgxZik7XFxyXFxuICAgICAgICAgICAgICAgICAgICBpZiAoIWJsZW5zIHx8IGJsZW5zLmxlbmd0aCA8IHQpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBibGVucyA9IFtdOyAvLyBuZXcgQXJyYXkodCk7XFxyXFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0OyBpKyspIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxlbnNbaV0gPSAwO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgIC8vIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGIgPj4+PSAoMTQpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgayAtPSAoMTQpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgLy8gfVxcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSAwO1xcclxcbiAgICAgICAgICAgICAgICAgICAgbW9kZSA9IEJUUkVFO1xcclxcbiAgICAgICAgICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xcclxcbiAgICAgICAgICAgICAgICBjYXNlIEJUUkVFOlxcclxcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGluZGV4IDwgNCArICh0YWJsZSA+Pj4gMTApKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGsgPCAoMykpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG4gIT09IDApIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgPSBaX09LO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5iaXRiID0gYjtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuYml0ayA9IGs7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB6LmF2YWlsX2luID0gbjtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHoudG90YWxfaW4gKz0gcCAtIHoubmV4dF9pbl9pbmRleDtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHoubmV4dF9pbl9pbmRleCA9IHA7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LndyaXRlID0gcTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGF0LmluZmxhdGVfZmx1c2goeiwgcik7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbi0tO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiIHw9ICh6LnJlYWRfYnl0ZShwKyspICYgMHhmZikgPDwgaztcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgayArPSA4O1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBibGVuc1tib3JkZXJbaW5kZXgrK11dID0gYiAmIDc7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8ge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGIgPj4+PSAoMyk7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgayAtPSAoMyk7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gfVxcclxcbiAgICAgICAgICAgICAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGluZGV4IDwgMTkpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBibGVuc1tib3JkZXJbaW5kZXgrK11dID0gMDtcXHJcXG4gICAgICAgICAgICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgIGJiWzBdID0gNztcXHJcXG4gICAgICAgICAgICAgICAgICAgIHQgPSBpbmZ0cmVlLmluZmxhdGVfdHJlZXNfYml0cyhibGVucywgYmIsIHRiLCBodWZ0cywgeik7XFxyXFxuICAgICAgICAgICAgICAgICAgICBpZiAodCAhPSBaX09LKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgciA9IHQ7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHIgPT0gWl9EQVRBX0VSUk9SKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsZW5zID0gbnVsbDtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZSA9IEJBREJMT0NLUztcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5iaXRiID0gYjtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmJpdGsgPSBrO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHouYXZhaWxfaW4gPSBuO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHoudG90YWxfaW4gKz0gcCAtIHoubmV4dF9pbl9pbmRleDtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB6Lm5leHRfaW5faW5kZXggPSBwO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQud3JpdGUgPSBxO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGF0LmluZmxhdGVfZmx1c2goeiwgcik7XFxyXFxuICAgICAgICAgICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IDA7XFxyXFxuICAgICAgICAgICAgICAgICAgICBtb2RlID0gRFRSRUU7XFxyXFxuICAgICAgICAgICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXFxyXFxuICAgICAgICAgICAgICAgIGNhc2UgRFRSRUU6XFxyXFxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHQgPSB0YWJsZTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gMjU4ICsgKHQgJiAweDFmKSArICgodCA+PiA1KSAmIDB4MWYpKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaiwgYztcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB0ID0gYmJbMF07XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGsgPCAodCkpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG4gIT09IDApIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgPSBaX09LO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5iaXRiID0gYjtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuYml0ayA9IGs7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB6LmF2YWlsX2luID0gbjtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHoudG90YWxfaW4gKz0gcCAtIHoubmV4dF9pbl9pbmRleDtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHoubmV4dF9pbl9pbmRleCA9IHA7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LndyaXRlID0gcTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGF0LmluZmxhdGVfZmx1c2goeiwgcik7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbi0tO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiIHw9ICh6LnJlYWRfYnl0ZShwKyspICYgMHhmZikgPDwgaztcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgayArPSA4O1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiAodGJbMF0gPT0gLTEpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTeXN0ZW0uZXJyLnByaW50bG4oXFxcIm51bGwuLi5cXFwiKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgdCA9IGh1ZnRzWyh0YlswXSArIChiICYgaW5mbGF0ZV9tYXNrW3RdKSkgKiAzICsgMV07XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgYyA9IGh1ZnRzWyh0YlswXSArIChiICYgaW5mbGF0ZV9tYXNrW3RdKSkgKiAzICsgMl07XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGMgPCAxNikge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiID4+Pj0gKHQpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrIC09ICh0KTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxlbnNbaW5kZXgrK10gPSBjO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8vIGMgPT0gMTYuLjE4XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBjID09IDE4ID8gNyA6IGMgLSAxNDtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaiA9IGMgPT0gMTggPyAxMSA6IDM7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChrIDwgKHQgKyBpKSkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG4gIT09IDApIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByID0gWl9PSztcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5iaXRiID0gYjtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmJpdGsgPSBrO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHouYXZhaWxfaW4gPSBuO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHoudG90YWxfaW4gKz0gcCAtIHoubmV4dF9pbl9pbmRleDtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB6Lm5leHRfaW5faW5kZXggPSBwO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQud3JpdGUgPSBxO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGF0LmluZmxhdGVfZmx1c2goeiwgcik7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuLS07XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiIHw9ICh6LnJlYWRfYnl0ZShwKyspICYgMHhmZikgPDwgaztcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGsgKz0gODtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiID4+Pj0gKHQpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrIC09ICh0KTtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaiArPSAoYiAmIGluZmxhdGVfbWFza1tpXSk7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIgPj4+PSAoaSk7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGsgLT0gKGkpO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gaW5kZXg7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQgPSB0YWJsZTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgKyBqID4gMjU4ICsgKHQgJiAweDFmKSArICgodCA+PiA1KSAmIDB4MWYpIHx8IChjID09IDE2ICYmIGkgPCAxKSkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxlbnMgPSBudWxsO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZSA9IEJBREJMT0NLUztcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHoubXNnID0gXFxcImludmFsaWQgYml0IGxlbmd0aCByZXBlYXRcXFwiO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgciA9IFpfREFUQV9FUlJPUjtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuYml0YiA9IGI7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmJpdGsgPSBrO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgei5hdmFpbF9pbiA9IG47XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB6LnRvdGFsX2luICs9IHAgLSB6Lm5leHRfaW5faW5kZXg7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB6Lm5leHRfaW5faW5kZXggPSBwO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC53cml0ZSA9IHE7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhhdC5pbmZsYXRlX2ZsdXNoKHosIHIpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSBjID09IDE2ID8gYmxlbnNbaSAtIDFdIDogMDtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG8ge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxlbnNbaSsrXSA9IGM7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0taiAhPT0gMCk7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICB0YlswXSA9IC0xO1xcclxcbiAgICAgICAgICAgICAgICAgICAgLy8ge1xcclxcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJsXyA9IFtdOyAvLyBuZXcgQXJyYXkoMSk7XFxyXFxuICAgICAgICAgICAgICAgICAgICB2YXIgYmRfID0gW107IC8vIG5ldyBBcnJheSgxKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHZhciB0bF8gPSBbXTsgLy8gbmV3IEFycmF5KDEpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRkXyA9IFtdOyAvLyBuZXcgQXJyYXkoMSk7XFxyXFxuICAgICAgICAgICAgICAgICAgICBibF9bMF0gPSA5OyAvLyBtdXN0IGJlIDw9IDkgZm9yIGxvb2thaGVhZCBhc3N1bXB0aW9uc1xcclxcbiAgICAgICAgICAgICAgICAgICAgYmRfWzBdID0gNjsgLy8gbXVzdCBiZSA8PSA5IGZvciBsb29rYWhlYWQgYXNzdW1wdGlvbnNcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgIHQgPSB0YWJsZTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHQgPSBpbmZ0cmVlLmluZmxhdGVfdHJlZXNfZHluYW1pYygyNTcgKyAodCAmIDB4MWYpLCAxICsgKCh0ID4+IDUpICYgMHgxZiksIGJsZW5zLCBibF8sIGJkXywgdGxfLCB0ZF8sIGh1ZnRzLCB6KTtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICE9IFpfT0spIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodCA9PSBaX0RBVEFfRVJST1IpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxlbnMgPSBudWxsO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlID0gQkFEQkxPQ0tTO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICByID0gdDtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmJpdGIgPSBiO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuYml0ayA9IGs7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgei5hdmFpbF9pbiA9IG47XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgei50b3RhbF9pbiArPSBwIC0gei5uZXh0X2luX2luZGV4O1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHoubmV4dF9pbl9pbmRleCA9IHA7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC53cml0ZSA9IHE7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoYXQuaW5mbGF0ZV9mbHVzaCh6LCByKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgICAgIGNvZGVzLmluaXQoYmxfWzBdLCBiZF9bMF0sIGh1ZnRzLCB0bF9bMF0sIGh1ZnRzLCB0ZF9bMF0pO1xcclxcbiAgICAgICAgICAgICAgICAgICAgLy8gfVxcclxcbiAgICAgICAgICAgICAgICAgICAgbW9kZSA9IENPREVTO1xcclxcbiAgICAgICAgICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xcclxcbiAgICAgICAgICAgICAgICBjYXNlIENPREVTOlxcclxcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5iaXRiID0gYjtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuYml0ayA9IGs7XFxyXFxuICAgICAgICAgICAgICAgICAgICB6LmF2YWlsX2luID0gbjtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHoudG90YWxfaW4gKz0gcCAtIHoubmV4dF9pbl9pbmRleDtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHoubmV4dF9pbl9pbmRleCA9IHA7XFxyXFxuICAgICAgICAgICAgICAgICAgICB0aGF0LndyaXRlID0gcTtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgIGlmICgociA9IGNvZGVzLnByb2ModGhhdCwgeiwgcikpICE9IFpfU1RSRUFNX0VORCkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGF0LmluZmxhdGVfZmx1c2goeiwgcik7XFxyXFxuICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgICAgICByID0gWl9PSztcXHJcXG4gICAgICAgICAgICAgICAgICAgIGNvZGVzLmZyZWUoeik7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICBwID0gei5uZXh0X2luX2luZGV4O1xcclxcbiAgICAgICAgICAgICAgICAgICAgbiA9IHouYXZhaWxfaW47XFxyXFxuICAgICAgICAgICAgICAgICAgICBiID0gdGhhdC5iaXRiO1xcclxcbiAgICAgICAgICAgICAgICAgICAgayA9IHRoYXQuYml0aztcXHJcXG4gICAgICAgICAgICAgICAgICAgIHEgPSB0aGF0LndyaXRlO1xcclxcbiAgICAgICAgICAgICAgICAgICAgbSA9IC8qIChpbnQpICovKHEgPCB0aGF0LnJlYWQgPyB0aGF0LnJlYWQgLSBxIC0gMSA6IHRoYXQuZW5kIC0gcSk7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICBpZiAobGFzdCA9PT0gMCkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGUgPSBUWVBFO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcclxcbiAgICAgICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICAgICAgbW9kZSA9IERSWTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cXHJcXG4gICAgICAgICAgICAgICAgY2FzZSBEUlk6XFxyXFxuICAgICAgICAgICAgICAgICAgICB0aGF0LndyaXRlID0gcTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHIgPSB0aGF0LmluZmxhdGVfZmx1c2goeiwgcik7XFxyXFxuICAgICAgICAgICAgICAgICAgICBxID0gdGhhdC53cml0ZTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIG0gPSAvKiAoaW50KSAqLyhxIDwgdGhhdC5yZWFkID8gdGhhdC5yZWFkIC0gcSAtIDEgOiB0aGF0LmVuZCAtIHEpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoYXQucmVhZCAhPSB0aGF0LndyaXRlKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5iaXRiID0gYjtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmJpdGsgPSBrO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHouYXZhaWxfaW4gPSBuO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHoudG90YWxfaW4gKz0gcCAtIHoubmV4dF9pbl9pbmRleDtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB6Lm5leHRfaW5faW5kZXggPSBwO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQud3JpdGUgPSBxO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGF0LmluZmxhdGVfZmx1c2goeiwgcik7XFxyXFxuICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgICAgICBtb2RlID0gRE9ORUxPQ0tTO1xcclxcbiAgICAgICAgICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xcclxcbiAgICAgICAgICAgICAgICBjYXNlIERPTkVMT0NLUzpcXHJcXG4gICAgICAgICAgICAgICAgICAgIHIgPSBaX1NUUkVBTV9FTkQ7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICB0aGF0LmJpdGIgPSBiO1xcclxcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5iaXRrID0gaztcXHJcXG4gICAgICAgICAgICAgICAgICAgIHouYXZhaWxfaW4gPSBuO1xcclxcbiAgICAgICAgICAgICAgICAgICAgei50b3RhbF9pbiArPSBwIC0gei5uZXh0X2luX2luZGV4O1xcclxcbiAgICAgICAgICAgICAgICAgICAgei5uZXh0X2luX2luZGV4ID0gcDtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHRoYXQud3JpdGUgPSBxO1xcclxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoYXQuaW5mbGF0ZV9mbHVzaCh6LCByKTtcXHJcXG4gICAgICAgICAgICAgICAgY2FzZSBCQURCTE9DS1M6XFxyXFxuICAgICAgICAgICAgICAgICAgICByID0gWl9EQVRBX0VSUk9SO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5iaXRiID0gYjtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuYml0ayA9IGs7XFxyXFxuICAgICAgICAgICAgICAgICAgICB6LmF2YWlsX2luID0gbjtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHoudG90YWxfaW4gKz0gcCAtIHoubmV4dF9pbl9pbmRleDtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHoubmV4dF9pbl9pbmRleCA9IHA7XFxyXFxuICAgICAgICAgICAgICAgICAgICB0aGF0LndyaXRlID0gcTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGF0LmluZmxhdGVfZmx1c2goeiwgcik7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XFxyXFxuICAgICAgICAgICAgICAgICAgICByID0gWl9TVFJFQU1fRVJST1I7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICB0aGF0LmJpdGIgPSBiO1xcclxcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5iaXRrID0gaztcXHJcXG4gICAgICAgICAgICAgICAgICAgIHouYXZhaWxfaW4gPSBuO1xcclxcbiAgICAgICAgICAgICAgICAgICAgei50b3RhbF9pbiArPSBwIC0gei5uZXh0X2luX2luZGV4O1xcclxcbiAgICAgICAgICAgICAgICAgICAgei5uZXh0X2luX2luZGV4ID0gcDtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHRoYXQud3JpdGUgPSBxO1xcclxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoYXQuaW5mbGF0ZV9mbHVzaCh6LCByKTtcXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH07XFxyXFxuXFxyXFxuICAgICAgICB0aGF0LmZyZWUgPSBmdW5jdGlvbih6KSB7XFxyXFxuICAgICAgICAgICAgdGhhdC5yZXNldCh6LCBudWxsKTtcXHJcXG4gICAgICAgICAgICB0aGF0LndpbmRvdyA9IG51bGw7XFxyXFxuICAgICAgICAgICAgaHVmdHMgPSBudWxsO1xcclxcbiAgICAgICAgICAgIC8vIFpGUkVFKHosIHMpO1xcclxcbiAgICAgICAgfTtcXHJcXG5cXHJcXG4gICAgICAgIHRoYXQuc2V0X2RpY3Rpb25hcnkgPSBmdW5jdGlvbihkLCBzdGFydCwgbikge1xcclxcbiAgICAgICAgICAgIHRoYXQud2luZG93LnNldChkLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIG4pLCAwKTtcXHJcXG4gICAgICAgICAgICB0aGF0LnJlYWQgPSB0aGF0LndyaXRlID0gbjtcXHJcXG4gICAgICAgIH07XFxyXFxuXFxyXFxuICAgICAgICAvLyBSZXR1cm5zIHRydWUgaWYgaW5mbGF0ZSBpcyBjdXJyZW50bHkgYXQgdGhlIGVuZCBvZiBhIGJsb2NrIGdlbmVyYXRlZFxcclxcbiAgICAgICAgLy8gYnkgWl9TWU5DX0ZMVVNIIG9yIFpfRlVMTF9GTFVTSC5cXHJcXG4gICAgICAgIHRoYXQuc3luY19wb2ludCA9IGZ1bmN0aW9uKCkge1xcclxcbiAgICAgICAgICAgIHJldHVybiBtb2RlID09IExFTlMgPyAxIDogMDtcXHJcXG4gICAgICAgIH07XFxyXFxuXFxyXFxuICAgIH1cXHJcXG5cXHJcXG4gICAgLy8gSW5mbGF0ZVxcclxcblxcclxcbiAgICAvLyBwcmVzZXQgZGljdGlvbmFyeSBmbGFnIGluIHpsaWIgaGVhZGVyXFxyXFxuICAgIHZhciBQUkVTRVRfRElDVCA9IDB4MjA7XFxyXFxuXFxyXFxuICAgIHZhciBaX0RFRkxBVEVEID0gODtcXHJcXG5cXHJcXG4gICAgdmFyIE1FVEhPRCA9IDA7IC8vIHdhaXRpbmcgZm9yIG1ldGhvZCBieXRlXFxyXFxuICAgIHZhciBGTEFHID0gMTsgLy8gd2FpdGluZyBmb3IgZmxhZyBieXRlXFxyXFxuICAgIHZhciBESUNUNCA9IDI7IC8vIGZvdXIgZGljdGlvbmFyeSBjaGVjayBieXRlcyB0byBnb1xcclxcbiAgICB2YXIgRElDVDMgPSAzOyAvLyB0aHJlZSBkaWN0aW9uYXJ5IGNoZWNrIGJ5dGVzIHRvIGdvXFxyXFxuICAgIHZhciBESUNUMiA9IDQ7IC8vIHR3byBkaWN0aW9uYXJ5IGNoZWNrIGJ5dGVzIHRvIGdvXFxyXFxuICAgIHZhciBESUNUMSA9IDU7IC8vIG9uZSBkaWN0aW9uYXJ5IGNoZWNrIGJ5dGUgdG8gZ29cXHJcXG4gICAgdmFyIERJQ1QwID0gNjsgLy8gd2FpdGluZyBmb3IgaW5mbGF0ZVNldERpY3Rpb25hcnlcXHJcXG4gICAgdmFyIEJMT0NLUyA9IDc7IC8vIGRlY29tcHJlc3NpbmcgYmxvY2tzXFxyXFxuICAgIHZhciBET05FID0gMTI7IC8vIGZpbmlzaGVkIGNoZWNrLCBkb25lXFxyXFxuICAgIHZhciBCQUQgPSAxMzsgLy8gZ290IGFuIGVycm9yLS1zdGF5IGhlcmVcXHJcXG5cXHJcXG4gICAgdmFyIG1hcmsgPSBbIDAsIDAsIDB4ZmYsIDB4ZmYgXTtcXHJcXG5cXHJcXG4gICAgZnVuY3Rpb24gSW5mbGF0ZSgpIHtcXHJcXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcXHJcXG5cXHJcXG4gICAgICAgIHRoYXQubW9kZSA9IDA7IC8vIGN1cnJlbnQgaW5mbGF0ZSBtb2RlXFxyXFxuXFxyXFxuICAgICAgICAvLyBtb2RlIGRlcGVuZGVudCBpbmZvcm1hdGlvblxcclxcbiAgICAgICAgdGhhdC5tZXRob2QgPSAwOyAvLyBpZiBGTEFHUywgbWV0aG9kIGJ5dGVcXHJcXG5cXHJcXG4gICAgICAgIC8vIGlmIENIRUNLLCBjaGVjayB2YWx1ZXMgdG8gY29tcGFyZVxcclxcbiAgICAgICAgdGhhdC53YXMgPSBbIDAgXTsgLy8gbmV3IEFycmF5KDEpOyAvLyBjb21wdXRlZCBjaGVjayB2YWx1ZVxcclxcbiAgICAgICAgdGhhdC5uZWVkID0gMDsgLy8gc3RyZWFtIGNoZWNrIHZhbHVlXFxyXFxuXFxyXFxuICAgICAgICAvLyBpZiBCQUQsIGluZmxhdGVTeW5jJ3MgbWFya2VyIGJ5dGVzIGNvdW50XFxyXFxuICAgICAgICB0aGF0Lm1hcmtlciA9IDA7XFxyXFxuXFxyXFxuICAgICAgICAvLyBtb2RlIGluZGVwZW5kZW50IGluZm9ybWF0aW9uXFxyXFxuICAgICAgICB0aGF0LndiaXRzID0gMDsgLy8gbG9nMih3aW5kb3cgc2l6ZSkgKDguLjE1LCBkZWZhdWx0cyB0byAxNSlcXHJcXG5cXHJcXG4gICAgICAgIC8vIHRoaXMuYmxvY2tzOyAvLyBjdXJyZW50IGluZmxhdGVfYmxvY2tzIHN0YXRlXFxyXFxuXFxyXFxuICAgICAgICBmdW5jdGlvbiBpbmZsYXRlUmVzZXQoeikge1xcclxcbiAgICAgICAgICAgIGlmICgheiB8fCAhei5pc3RhdGUpXFxyXFxuICAgICAgICAgICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcXHJcXG5cXHJcXG4gICAgICAgICAgICB6LnRvdGFsX2luID0gei50b3RhbF9vdXQgPSAwO1xcclxcbiAgICAgICAgICAgIHoubXNnID0gbnVsbDtcXHJcXG4gICAgICAgICAgICB6LmlzdGF0ZS5tb2RlID0gQkxPQ0tTO1xcclxcbiAgICAgICAgICAgIHouaXN0YXRlLmJsb2Nrcy5yZXNldCh6LCBudWxsKTtcXHJcXG4gICAgICAgICAgICByZXR1cm4gWl9PSztcXHJcXG4gICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgIHRoYXQuaW5mbGF0ZUVuZCA9IGZ1bmN0aW9uKHopIHtcXHJcXG4gICAgICAgICAgICBpZiAodGhhdC5ibG9ja3MpXFxyXFxuICAgICAgICAgICAgICAgIHRoYXQuYmxvY2tzLmZyZWUoeik7XFxyXFxuICAgICAgICAgICAgdGhhdC5ibG9ja3MgPSBudWxsO1xcclxcbiAgICAgICAgICAgIC8vIFpGUkVFKHosIHotPnN0YXRlKTtcXHJcXG4gICAgICAgICAgICByZXR1cm4gWl9PSztcXHJcXG4gICAgICAgIH07XFxyXFxuXFxyXFxuICAgICAgICB0aGF0LmluZmxhdGVJbml0ID0gZnVuY3Rpb24oeiwgdykge1xcclxcbiAgICAgICAgICAgIHoubXNnID0gbnVsbDtcXHJcXG4gICAgICAgICAgICB0aGF0LmJsb2NrcyA9IG51bGw7XFxyXFxuXFxyXFxuICAgICAgICAgICAgLy8gc2V0IHdpbmRvdyBzaXplXFxyXFxuICAgICAgICAgICAgaWYgKHcgPCA4IHx8IHcgPiAxNSkge1xcclxcbiAgICAgICAgICAgICAgICB0aGF0LmluZmxhdGVFbmQoeik7XFxyXFxuICAgICAgICAgICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgdGhhdC53Yml0cyA9IHc7XFxyXFxuXFxyXFxuICAgICAgICAgICAgei5pc3RhdGUuYmxvY2tzID0gbmV3IEluZkJsb2Nrcyh6LCAxIDw8IHcpO1xcclxcblxcclxcbiAgICAgICAgICAgIC8vIHJlc2V0IHN0YXRlXFxyXFxuICAgICAgICAgICAgaW5mbGF0ZVJlc2V0KHopO1xcclxcbiAgICAgICAgICAgIHJldHVybiBaX09LO1xcclxcbiAgICAgICAgfTtcXHJcXG5cXHJcXG4gICAgICAgIHRoYXQuaW5mbGF0ZSA9IGZ1bmN0aW9uKHosIGYpIHtcXHJcXG4gICAgICAgICAgICB2YXIgcjtcXHJcXG4gICAgICAgICAgICB2YXIgYjtcXHJcXG5cXHJcXG4gICAgICAgICAgICBpZiAoIXogfHwgIXouaXN0YXRlIHx8ICF6Lm5leHRfaW4pXFxyXFxuICAgICAgICAgICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcXHJcXG4gICAgICAgICAgICBmID0gZiA9PSBaX0ZJTklTSCA/IFpfQlVGX0VSUk9SIDogWl9PSztcXHJcXG4gICAgICAgICAgICByID0gWl9CVUZfRVJST1I7XFxyXFxuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcXHJcXG4gICAgICAgICAgICAgICAgLy8gU3lzdGVtLm91dC5wcmludGxuKFxcXCJtb2RlOiBcXFwiK3ouaXN0YXRlLm1vZGUpO1xcclxcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHouaXN0YXRlLm1vZGUpIHtcXHJcXG4gICAgICAgICAgICAgICAgY2FzZSBNRVRIT0Q6XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICBpZiAoei5hdmFpbF9pbiA9PT0gMClcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcjtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHIgPSBmO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgei5hdmFpbF9pbi0tO1xcclxcbiAgICAgICAgICAgICAgICAgICAgei50b3RhbF9pbisrO1xcclxcbiAgICAgICAgICAgICAgICAgICAgaWYgKCgoei5pc3RhdGUubWV0aG9kID0gei5yZWFkX2J5dGUoei5uZXh0X2luX2luZGV4KyspKSAmIDB4ZikgIT0gWl9ERUZMQVRFRCkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHouaXN0YXRlLm1vZGUgPSBCQUQ7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgei5tc2cgPSBcXFwidW5rbm93biBjb21wcmVzc2lvbiBtZXRob2RcXFwiO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHouaXN0YXRlLm1hcmtlciA9IDU7IC8vIGNhbid0IHRyeSBpbmZsYXRlU3luY1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcclxcbiAgICAgICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICAgICAgaWYgKCh6LmlzdGF0ZS5tZXRob2QgPj4gNCkgKyA4ID4gei5pc3RhdGUud2JpdHMpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB6LmlzdGF0ZS5tb2RlID0gQkFEO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHoubXNnID0gXFxcImludmFsaWQgd2luZG93IHNpemVcXFwiO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHouaXN0YXRlLm1hcmtlciA9IDU7IC8vIGNhbid0IHRyeSBpbmZsYXRlU3luY1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcclxcbiAgICAgICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICAgICAgei5pc3RhdGUubW9kZSA9IEZMQUc7XFxyXFxuICAgICAgICAgICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXFxyXFxuICAgICAgICAgICAgICAgIGNhc2UgRkxBRzpcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgIGlmICh6LmF2YWlsX2luID09PSAwKVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByO1xcclxcbiAgICAgICAgICAgICAgICAgICAgciA9IGY7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICB6LmF2YWlsX2luLS07XFxyXFxuICAgICAgICAgICAgICAgICAgICB6LnRvdGFsX2luKys7XFxyXFxuICAgICAgICAgICAgICAgICAgICBiID0gKHoucmVhZF9ieXRlKHoubmV4dF9pbl9pbmRleCsrKSkgJiAweGZmO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgaWYgKCgoKHouaXN0YXRlLm1ldGhvZCA8PCA4KSArIGIpICUgMzEpICE9PSAwKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgei5pc3RhdGUubW9kZSA9IEJBRDtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB6Lm1zZyA9IFxcXCJpbmNvcnJlY3QgaGVhZGVyIGNoZWNrXFxcIjtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB6LmlzdGF0ZS5tYXJrZXIgPSA1OyAvLyBjYW4ndCB0cnkgaW5mbGF0ZVN5bmNcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcXHJcXG4gICAgICAgICAgICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgIGlmICgoYiAmIFBSRVNFVF9ESUNUKSA9PT0gMCkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHouaXN0YXRlLm1vZGUgPSBCTE9DS1M7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxyXFxuICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgICAgICB6LmlzdGF0ZS5tb2RlID0gRElDVDQ7XFxyXFxuICAgICAgICAgICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXFxyXFxuICAgICAgICAgICAgICAgIGNhc2UgRElDVDQ6XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICBpZiAoei5hdmFpbF9pbiA9PT0gMClcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcjtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHIgPSBmO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgei5hdmFpbF9pbi0tO1xcclxcbiAgICAgICAgICAgICAgICAgICAgei50b3RhbF9pbisrO1xcclxcbiAgICAgICAgICAgICAgICAgICAgei5pc3RhdGUubmVlZCA9ICgoei5yZWFkX2J5dGUoei5uZXh0X2luX2luZGV4KyspICYgMHhmZikgPDwgMjQpICYgMHhmZjAwMDAwMDtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHouaXN0YXRlLm1vZGUgPSBESUNUMztcXHJcXG4gICAgICAgICAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cXHJcXG4gICAgICAgICAgICAgICAgY2FzZSBESUNUMzpcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgIGlmICh6LmF2YWlsX2luID09PSAwKVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByO1xcclxcbiAgICAgICAgICAgICAgICAgICAgciA9IGY7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICB6LmF2YWlsX2luLS07XFxyXFxuICAgICAgICAgICAgICAgICAgICB6LnRvdGFsX2luKys7XFxyXFxuICAgICAgICAgICAgICAgICAgICB6LmlzdGF0ZS5uZWVkICs9ICgoei5yZWFkX2J5dGUoei5uZXh0X2luX2luZGV4KyspICYgMHhmZikgPDwgMTYpICYgMHhmZjAwMDA7XFxyXFxuICAgICAgICAgICAgICAgICAgICB6LmlzdGF0ZS5tb2RlID0gRElDVDI7XFxyXFxuICAgICAgICAgICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXFxyXFxuICAgICAgICAgICAgICAgIGNhc2UgRElDVDI6XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICBpZiAoei5hdmFpbF9pbiA9PT0gMClcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcjtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHIgPSBmO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgei5hdmFpbF9pbi0tO1xcclxcbiAgICAgICAgICAgICAgICAgICAgei50b3RhbF9pbisrO1xcclxcbiAgICAgICAgICAgICAgICAgICAgei5pc3RhdGUubmVlZCArPSAoKHoucmVhZF9ieXRlKHoubmV4dF9pbl9pbmRleCsrKSAmIDB4ZmYpIDw8IDgpICYgMHhmZjAwO1xcclxcbiAgICAgICAgICAgICAgICAgICAgei5pc3RhdGUubW9kZSA9IERJQ1QxO1xcclxcbiAgICAgICAgICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xcclxcbiAgICAgICAgICAgICAgICBjYXNlIERJQ1QxOlxcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgaWYgKHouYXZhaWxfaW4gPT09IDApXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHI7XFxyXFxuICAgICAgICAgICAgICAgICAgICByID0gZjtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgIHouYXZhaWxfaW4tLTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHoudG90YWxfaW4rKztcXHJcXG4gICAgICAgICAgICAgICAgICAgIHouaXN0YXRlLm5lZWQgKz0gKHoucmVhZF9ieXRlKHoubmV4dF9pbl9pbmRleCsrKSAmIDB4ZmYpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgei5pc3RhdGUubW9kZSA9IERJQ1QwO1xcclxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFpfTkVFRF9ESUNUO1xcclxcbiAgICAgICAgICAgICAgICBjYXNlIERJQ1QwOlxcclxcbiAgICAgICAgICAgICAgICAgICAgei5pc3RhdGUubW9kZSA9IEJBRDtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHoubXNnID0gXFxcIm5lZWQgZGljdGlvbmFyeVxcXCI7XFxyXFxuICAgICAgICAgICAgICAgICAgICB6LmlzdGF0ZS5tYXJrZXIgPSAwOyAvLyBjYW4gdHJ5IGluZmxhdGVTeW5jXFxyXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XFxyXFxuICAgICAgICAgICAgICAgIGNhc2UgQkxPQ0tTOlxcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgciA9IHouaXN0YXRlLmJsb2Nrcy5wcm9jKHosIHIpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgaWYgKHIgPT0gWl9EQVRBX0VSUk9SKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgei5pc3RhdGUubW9kZSA9IEJBRDtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB6LmlzdGF0ZS5tYXJrZXIgPSAwOyAvLyBjYW4gdHJ5IGluZmxhdGVTeW5jXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxyXFxuICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgICAgICBpZiAociA9PSBaX09LKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgciA9IGY7XFxyXFxuICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgICAgICBpZiAociAhPSBaX1NUUkVBTV9FTkQpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcjtcXHJcXG4gICAgICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgICAgIHIgPSBmO1xcclxcbiAgICAgICAgICAgICAgICAgICAgei5pc3RhdGUuYmxvY2tzLnJlc2V0KHosIHouaXN0YXRlLndhcyk7XFxyXFxuICAgICAgICAgICAgICAgICAgICB6LmlzdGF0ZS5tb2RlID0gRE9ORTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cXHJcXG4gICAgICAgICAgICAgICAgY2FzZSBET05FOlxcclxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VORDtcXHJcXG4gICAgICAgICAgICAgICAgY2FzZSBCQUQ6XFxyXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWl9EQVRBX0VSUk9SO1xcclxcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxcclxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgfTtcXHJcXG5cXHJcXG4gICAgICAgIHRoYXQuaW5mbGF0ZVNldERpY3Rpb25hcnkgPSBmdW5jdGlvbih6LCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoKSB7XFxyXFxuICAgICAgICAgICAgdmFyIGluZGV4ID0gMDtcXHJcXG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gZGljdExlbmd0aDtcXHJcXG4gICAgICAgICAgICBpZiAoIXogfHwgIXouaXN0YXRlIHx8IHouaXN0YXRlLm1vZGUgIT0gRElDVDApXFxyXFxuICAgICAgICAgICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcXHJcXG5cXHJcXG4gICAgICAgICAgICBpZiAobGVuZ3RoID49ICgxIDw8IHouaXN0YXRlLndiaXRzKSkge1xcclxcbiAgICAgICAgICAgICAgICBsZW5ndGggPSAoMSA8PCB6LmlzdGF0ZS53Yml0cykgLSAxO1xcclxcbiAgICAgICAgICAgICAgICBpbmRleCA9IGRpY3RMZW5ndGggLSBsZW5ndGg7XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIHouaXN0YXRlLmJsb2Nrcy5zZXRfZGljdGlvbmFyeShkaWN0aW9uYXJ5LCBpbmRleCwgbGVuZ3RoKTtcXHJcXG4gICAgICAgICAgICB6LmlzdGF0ZS5tb2RlID0gQkxPQ0tTO1xcclxcbiAgICAgICAgICAgIHJldHVybiBaX09LO1xcclxcbiAgICAgICAgfTtcXHJcXG5cXHJcXG4gICAgICAgIHRoYXQuaW5mbGF0ZVN5bmMgPSBmdW5jdGlvbih6KSB7XFxyXFxuICAgICAgICAgICAgdmFyIG47IC8vIG51bWJlciBvZiBieXRlcyB0byBsb29rIGF0XFxyXFxuICAgICAgICAgICAgdmFyIHA7IC8vIHBvaW50ZXIgdG8gYnl0ZXNcXHJcXG4gICAgICAgICAgICB2YXIgbTsgLy8gbnVtYmVyIG9mIG1hcmtlciBieXRlcyBmb3VuZCBpbiBhIHJvd1xcclxcbiAgICAgICAgICAgIHZhciByLCB3OyAvLyB0ZW1wb3JhcmllcyB0byBzYXZlIHRvdGFsX2luIGFuZCB0b3RhbF9vdXRcXHJcXG5cXHJcXG4gICAgICAgICAgICAvLyBzZXQgdXBcXHJcXG4gICAgICAgICAgICBpZiAoIXogfHwgIXouaXN0YXRlKVxcclxcbiAgICAgICAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XFxyXFxuICAgICAgICAgICAgaWYgKHouaXN0YXRlLm1vZGUgIT0gQkFEKSB7XFxyXFxuICAgICAgICAgICAgICAgIHouaXN0YXRlLm1vZGUgPSBCQUQ7XFxyXFxuICAgICAgICAgICAgICAgIHouaXN0YXRlLm1hcmtlciA9IDA7XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIGlmICgobiA9IHouYXZhaWxfaW4pID09PSAwKVxcclxcbiAgICAgICAgICAgICAgICByZXR1cm4gWl9CVUZfRVJST1I7XFxyXFxuICAgICAgICAgICAgcCA9IHoubmV4dF9pbl9pbmRleDtcXHJcXG4gICAgICAgICAgICBtID0gei5pc3RhdGUubWFya2VyO1xcclxcblxcclxcbiAgICAgICAgICAgIC8vIHNlYXJjaFxcclxcbiAgICAgICAgICAgIHdoaWxlIChuICE9PSAwICYmIG0gPCA0KSB7XFxyXFxuICAgICAgICAgICAgICAgIGlmICh6LnJlYWRfYnl0ZShwKSA9PSBtYXJrW21dKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICBtKys7XFxyXFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoei5yZWFkX2J5dGUocCkgIT09IDApIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIG0gPSAwO1xcclxcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgICAgICAgICAgICAgbSA9IDQgLSBtO1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgIHArKztcXHJcXG4gICAgICAgICAgICAgICAgbi0tO1xcclxcbiAgICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICAvLyByZXN0b3JlXFxyXFxuICAgICAgICAgICAgei50b3RhbF9pbiArPSBwIC0gei5uZXh0X2luX2luZGV4O1xcclxcbiAgICAgICAgICAgIHoubmV4dF9pbl9pbmRleCA9IHA7XFxyXFxuICAgICAgICAgICAgei5hdmFpbF9pbiA9IG47XFxyXFxuICAgICAgICAgICAgei5pc3RhdGUubWFya2VyID0gbTtcXHJcXG5cXHJcXG4gICAgICAgICAgICAvLyByZXR1cm4gbm8gam95IG9yIHNldCB1cCB0byByZXN0YXJ0IG9uIGEgbmV3IGJsb2NrXFxyXFxuICAgICAgICAgICAgaWYgKG0gIT0gNCkge1xcclxcbiAgICAgICAgICAgICAgICByZXR1cm4gWl9EQVRBX0VSUk9SO1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICByID0gei50b3RhbF9pbjtcXHJcXG4gICAgICAgICAgICB3ID0gei50b3RhbF9vdXQ7XFxyXFxuICAgICAgICAgICAgaW5mbGF0ZVJlc2V0KHopO1xcclxcbiAgICAgICAgICAgIHoudG90YWxfaW4gPSByO1xcclxcbiAgICAgICAgICAgIHoudG90YWxfb3V0ID0gdztcXHJcXG4gICAgICAgICAgICB6LmlzdGF0ZS5tb2RlID0gQkxPQ0tTO1xcclxcbiAgICAgICAgICAgIHJldHVybiBaX09LO1xcclxcbiAgICAgICAgfTtcXHJcXG5cXHJcXG4gICAgICAgIC8vIFJldHVybnMgdHJ1ZSBpZiBpbmZsYXRlIGlzIGN1cnJlbnRseSBhdCB0aGUgZW5kIG9mIGEgYmxvY2sgZ2VuZXJhdGVkXFxyXFxuICAgICAgICAvLyBieSBaX1NZTkNfRkxVU0ggb3IgWl9GVUxMX0ZMVVNILiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgYnkgb25lIFBQUFxcclxcbiAgICAgICAgLy8gaW1wbGVtZW50YXRpb24gdG8gcHJvdmlkZSBhbiBhZGRpdGlvbmFsIHNhZmV0eSBjaGVjay4gUFBQIHVzZXNcXHJcXG4gICAgICAgIC8vIFpfU1lOQ19GTFVTSFxcclxcbiAgICAgICAgLy8gYnV0IHJlbW92ZXMgdGhlIGxlbmd0aCBieXRlcyBvZiB0aGUgcmVzdWx0aW5nIGVtcHR5IHN0b3JlZCBibG9jay4gV2hlblxcclxcbiAgICAgICAgLy8gZGVjb21wcmVzc2luZywgUFBQIGNoZWNrcyB0aGF0IGF0IHRoZSBlbmQgb2YgaW5wdXQgcGFja2V0LCBpbmZsYXRlIGlzXFxyXFxuICAgICAgICAvLyB3YWl0aW5nIGZvciB0aGVzZSBsZW5ndGggYnl0ZXMuXFxyXFxuICAgICAgICB0aGF0LmluZmxhdGVTeW5jUG9pbnQgPSBmdW5jdGlvbih6KSB7XFxyXFxuICAgICAgICAgICAgaWYgKCF6IHx8ICF6LmlzdGF0ZSB8fCAhei5pc3RhdGUuYmxvY2tzKVxcclxcbiAgICAgICAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XFxyXFxuICAgICAgICAgICAgcmV0dXJuIHouaXN0YXRlLmJsb2Nrcy5zeW5jX3BvaW50KCk7XFxyXFxuICAgICAgICB9O1xcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgIC8vIFpTdHJlYW1cXHJcXG5cXHJcXG4gICAgZnVuY3Rpb24gWlN0cmVhbSgpIHtcXHJcXG4gICAgfVxcclxcblxcclxcbiAgICBaU3RyZWFtLnByb3RvdHlwZSA9IHtcXHJcXG4gICAgICAgIGluZmxhdGVJbml0IDogZnVuY3Rpb24oYml0cykge1xcclxcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcXHJcXG4gICAgICAgICAgICB0aGF0LmlzdGF0ZSA9IG5ldyBJbmZsYXRlKCk7XFxyXFxuICAgICAgICAgICAgaWYgKCFiaXRzKVxcclxcbiAgICAgICAgICAgICAgICBiaXRzID0gTUFYX0JJVFM7XFxyXFxuICAgICAgICAgICAgcmV0dXJuIHRoYXQuaXN0YXRlLmluZmxhdGVJbml0KHRoYXQsIGJpdHMpO1xcclxcbiAgICAgICAgfSxcXHJcXG5cXHJcXG4gICAgICAgIGluZmxhdGUgOiBmdW5jdGlvbihmKSB7XFxyXFxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xcclxcbiAgICAgICAgICAgIGlmICghdGhhdC5pc3RhdGUpXFxyXFxuICAgICAgICAgICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcXHJcXG4gICAgICAgICAgICByZXR1cm4gdGhhdC5pc3RhdGUuaW5mbGF0ZSh0aGF0LCBmKTtcXHJcXG4gICAgICAgIH0sXFxyXFxuXFxyXFxuICAgICAgICBpbmZsYXRlRW5kIDogZnVuY3Rpb24oKSB7XFxyXFxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xcclxcbiAgICAgICAgICAgIGlmICghdGhhdC5pc3RhdGUpXFxyXFxuICAgICAgICAgICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcXHJcXG4gICAgICAgICAgICB2YXIgcmV0ID0gdGhhdC5pc3RhdGUuaW5mbGF0ZUVuZCh0aGF0KTtcXHJcXG4gICAgICAgICAgICB0aGF0LmlzdGF0ZSA9IG51bGw7XFxyXFxuICAgICAgICAgICAgcmV0dXJuIHJldDtcXHJcXG4gICAgICAgIH0sXFxyXFxuXFxyXFxuICAgICAgICBpbmZsYXRlU3luYyA6IGZ1bmN0aW9uKCkge1xcclxcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcXHJcXG4gICAgICAgICAgICBpZiAoIXRoYXQuaXN0YXRlKVxcclxcbiAgICAgICAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XFxyXFxuICAgICAgICAgICAgcmV0dXJuIHRoYXQuaXN0YXRlLmluZmxhdGVTeW5jKHRoYXQpO1xcclxcbiAgICAgICAgfSxcXHJcXG4gICAgICAgIGluZmxhdGVTZXREaWN0aW9uYXJ5IDogZnVuY3Rpb24oZGljdGlvbmFyeSwgZGljdExlbmd0aCkge1xcclxcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcXHJcXG4gICAgICAgICAgICBpZiAoIXRoYXQuaXN0YXRlKVxcclxcbiAgICAgICAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XFxyXFxuICAgICAgICAgICAgcmV0dXJuIHRoYXQuaXN0YXRlLmluZmxhdGVTZXREaWN0aW9uYXJ5KHRoYXQsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgpO1xcclxcbiAgICAgICAgfSxcXHJcXG4gICAgICAgIHJlYWRfYnl0ZSA6IGZ1bmN0aW9uKHN0YXJ0KSB7XFxyXFxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xcclxcbiAgICAgICAgICAgIHJldHVybiB0aGF0Lm5leHRfaW4uc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgMSlbMF07XFxyXFxuICAgICAgICB9LFxcclxcbiAgICAgICAgcmVhZF9idWYgOiBmdW5jdGlvbihzdGFydCwgc2l6ZSkge1xcclxcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcXHJcXG4gICAgICAgICAgICByZXR1cm4gdGhhdC5uZXh0X2luLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIHNpemUpO1xcclxcbiAgICAgICAgfVxcclxcbiAgICB9O1xcclxcblxcclxcbiAgICAvLyBJbmZsYXRlclxcclxcblxcclxcbiAgICBmdW5jdGlvbiBJbmZsYXRlcigpIHtcXHJcXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcXHJcXG4gICAgICAgIHZhciB6ID0gbmV3IFpTdHJlYW0oKTtcXHJcXG4gICAgICAgIHZhciBidWZzaXplID0gNTEyO1xcclxcbiAgICAgICAgdmFyIGZsdXNoID0gWl9OT19GTFVTSDtcXHJcXG4gICAgICAgIHZhciBidWYgPSBuZXcgVWludDhBcnJheShidWZzaXplKTtcXHJcXG4gICAgICAgIHZhciBub21vcmVpbnB1dCA9IGZhbHNlO1xcclxcblxcclxcbiAgICAgICAgei5pbmZsYXRlSW5pdCgpO1xcclxcbiAgICAgICAgei5uZXh0X291dCA9IGJ1ZjtcXHJcXG5cXHJcXG4gICAgICAgIHRoYXQuYXBwZW5kID0gZnVuY3Rpb24oZGF0YSwgb25wcm9ncmVzcykge1xcclxcbiAgICAgICAgICAgIHZhciBlcnIsIGJ1ZmZlcnMgPSBbXSwgbGFzdEluZGV4ID0gMCwgYnVmZmVySW5kZXggPSAwLCBidWZmZXJTaXplID0gMCwgYXJyYXk7XFxyXFxuICAgICAgICAgICAgaWYgKGRhdGEubGVuZ3RoID09PSAwKVxcclxcbiAgICAgICAgICAgICAgICByZXR1cm47XFxyXFxuICAgICAgICAgICAgei5uZXh0X2luX2luZGV4ID0gMDtcXHJcXG4gICAgICAgICAgICB6Lm5leHRfaW4gPSBkYXRhO1xcclxcbiAgICAgICAgICAgIHouYXZhaWxfaW4gPSBkYXRhLmxlbmd0aDtcXHJcXG4gICAgICAgICAgICBkbyB7XFxyXFxuICAgICAgICAgICAgICAgIHoubmV4dF9vdXRfaW5kZXggPSAwO1xcclxcbiAgICAgICAgICAgICAgICB6LmF2YWlsX291dCA9IGJ1ZnNpemU7XFxyXFxuICAgICAgICAgICAgICAgIGlmICgoei5hdmFpbF9pbiA9PT0gMCkgJiYgKCFub21vcmVpbnB1dCkpIHsgLy8gaWYgYnVmZmVyIGlzIGVtcHR5IGFuZCBtb3JlIGlucHV0IGlzIGF2YWlsYWJsZSwgcmVmaWxsIGl0XFxyXFxuICAgICAgICAgICAgICAgICAgICB6Lm5leHRfaW5faW5kZXggPSAwO1xcclxcbiAgICAgICAgICAgICAgICAgICAgbm9tb3JlaW5wdXQgPSB0cnVlO1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgIGVyciA9IHouaW5mbGF0ZShmbHVzaCk7XFxyXFxuICAgICAgICAgICAgICAgIGlmIChub21vcmVpbnB1dCAmJiAoZXJyID09PSBaX0JVRl9FUlJPUikpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGlmICh6LmF2YWlsX2luICE9PSAwKVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcXFwiaW5mbGF0aW5nOiBiYWQgaW5wdXRcXFwiKTtcXHJcXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlcnIgIT09IFpfT0sgJiYgZXJyICE9PSBaX1NUUkVBTV9FTkQpXFxyXFxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXFxcImluZmxhdGluZzogXFxcIiArIHoubXNnKTtcXHJcXG4gICAgICAgICAgICAgICAgaWYgKChub21vcmVpbnB1dCB8fCBlcnIgPT09IFpfU1RSRUFNX0VORCkgJiYgKHouYXZhaWxfaW4gPT09IGRhdGEubGVuZ3RoKSlcXHJcXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcXFwiaW5mbGF0aW5nOiBiYWQgaW5wdXRcXFwiKTtcXHJcXG4gICAgICAgICAgICAgICAgaWYgKHoubmV4dF9vdXRfaW5kZXgpXFxyXFxuICAgICAgICAgICAgICAgICAgICBpZiAoei5uZXh0X291dF9pbmRleCA9PT0gYnVmc2l6ZSlcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJzLnB1c2gobmV3IFVpbnQ4QXJyYXkoYnVmKSk7XFxyXFxuICAgICAgICAgICAgICAgICAgICBlbHNlXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVycy5wdXNoKG5ldyBVaW50OEFycmF5KGJ1Zi5zdWJhcnJheSgwLCB6Lm5leHRfb3V0X2luZGV4KSkpO1xcclxcbiAgICAgICAgICAgICAgICBidWZmZXJTaXplICs9IHoubmV4dF9vdXRfaW5kZXg7XFxyXFxuICAgICAgICAgICAgICAgIGlmIChvbnByb2dyZXNzICYmIHoubmV4dF9pbl9pbmRleCA+IDAgJiYgei5uZXh0X2luX2luZGV4ICE9IGxhc3RJbmRleCkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgb25wcm9ncmVzcyh6Lm5leHRfaW5faW5kZXgpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgbGFzdEluZGV4ID0gei5uZXh0X2luX2luZGV4O1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgfSB3aGlsZSAoei5hdmFpbF9pbiA+IDAgfHwgei5hdmFpbF9vdXQgPT09IDApO1xcclxcbiAgICAgICAgICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyU2l6ZSk7XFxyXFxuICAgICAgICAgICAgYnVmZmVycy5mb3JFYWNoKGZ1bmN0aW9uKGNodW5rKSB7XFxyXFxuICAgICAgICAgICAgICAgIGFycmF5LnNldChjaHVuaywgYnVmZmVySW5kZXgpO1xcclxcbiAgICAgICAgICAgICAgICBidWZmZXJJbmRleCArPSBjaHVuay5sZW5ndGg7XFxyXFxuICAgICAgICAgICAgfSk7XFxyXFxuICAgICAgICAgICAgcmV0dXJuIGFycmF5O1xcclxcbiAgICAgICAgfTtcXHJcXG4gICAgICAgIHRoYXQuZmx1c2ggPSBmdW5jdGlvbigpIHtcXHJcXG4gICAgICAgICAgICB6LmluZmxhdGVFbmQoKTtcXHJcXG4gICAgICAgIH07XFxyXFxuICAgIH1cXHJcXG5cXHJcXG4gICAgLy8gJ3ppcCcgbWF5IG5vdCBiZSBkZWZpbmVkIGluIHotd29ya2VyIGFuZCBzb21lIHRlc3RzXFxyXFxuICAgIHZhciBlbnYgPSBnbG9iYWwuemlwIHx8IGdsb2JhbDtcXHJcXG4gICAgZW52LkluZmxhdGVyID0gZW52Ll9qemxpYl9JbmZsYXRlciA9IEluZmxhdGVyO1xcclxcbn0pKHRoaXMpO1wiO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBcIi8qIGpzaGludCB3b3JrZXI6dHJ1ZSAqL1xcclxcbihmdW5jdGlvbiBtYWluKGdsb2JhbCkge1xcclxcbiAgICBcXFwidXNlIHN0cmljdFxcXCI7XFxyXFxuXFxyXFxuICAgIGlmIChnbG9iYWwueldvcmtlckluaXRpYWxpemVkKVxcclxcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd6LXdvcmtlci5qcyBzaG91bGQgYmUgcnVuIG9ubHkgb25jZScpO1xcclxcbiAgICBnbG9iYWwueldvcmtlckluaXRpYWxpemVkID0gdHJ1ZTtcXHJcXG5cXHJcXG4gICAgYWRkRXZlbnRMaXN0ZW5lcihcXFwibWVzc2FnZVxcXCIsIGZ1bmN0aW9uKGV2ZW50KSB7XFxyXFxuICAgICAgICB2YXIgbWVzc2FnZSA9IGV2ZW50LmRhdGEsIHR5cGUgPSBtZXNzYWdlLnR5cGUsIHNuID0gbWVzc2FnZS5zbjtcXHJcXG4gICAgICAgIHZhciBoYW5kbGVyID0gaGFuZGxlcnNbdHlwZV07XFxyXFxuICAgICAgICBpZiAoaGFuZGxlcikge1xcclxcbiAgICAgICAgICAgIHRyeSB7XFxyXFxuICAgICAgICAgICAgICAgIGhhbmRsZXIobWVzc2FnZSk7XFxyXFxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xcclxcbiAgICAgICAgICAgICAgICBvbkVycm9yKHR5cGUsIHNuLCBlKTtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICAvL2ZvciBkZWJ1Z1xcclxcbiAgICAgICAgLy9wb3N0TWVzc2FnZSh7dHlwZTogJ2VjaG8nLCBvcmlnaW5hbFR5cGU6IHR5cGUsIHNuOiBzbn0pO1xcclxcbiAgICB9KTtcXHJcXG5cXHJcXG4gICAgdmFyIGhhbmRsZXJzID0ge1xcclxcbiAgICAgICAgaW1wb3J0U2NyaXB0czogZG9JbXBvcnRTY3JpcHRzLFxcclxcbiAgICAgICAgbmV3VGFzazogbmV3VGFzayxcXHJcXG4gICAgICAgIGFwcGVuZDogcHJvY2Vzc0RhdGEsXFxyXFxuICAgICAgICBmbHVzaDogcHJvY2Vzc0RhdGEsXFxyXFxuICAgIH07XFxyXFxuXFxyXFxuICAgIC8vIGRlZmxhdGVyL2luZmxhdGVyIHRhc2tzIGluZGV4ZWQgYnkgc2VyaWFsIG51bWJlcnNcXHJcXG4gICAgdmFyIHRhc2tzID0ge307XFxyXFxuXFxyXFxuICAgIGZ1bmN0aW9uIGRvSW1wb3J0U2NyaXB0cyhtc2cpIHtcXHJcXG4gICAgICAgIGlmIChtc2cuc2NyaXB0cyAmJiBtc2cuc2NyaXB0cy5sZW5ndGggPiAwKVxcclxcbiAgICAgICAgICAgIGltcG9ydFNjcmlwdHMuYXBwbHkodW5kZWZpbmVkLCBtc2cuc2NyaXB0cyk7XFxyXFxuICAgICAgICBwb3N0TWVzc2FnZSh7dHlwZTogJ2ltcG9ydFNjcmlwdHMnfSk7XFxyXFxuICAgIH1cXHJcXG5cXHJcXG4gICAgZnVuY3Rpb24gbmV3VGFzayhtc2cpIHtcXHJcXG4gICAgICAgIHZhciBDb2RlY0NsYXNzID0gZ2xvYmFsW21zZy5jb2RlY0NsYXNzXTtcXHJcXG4gICAgICAgIHZhciBzbiA9IG1zZy5zbjtcXHJcXG4gICAgICAgIGlmICh0YXNrc1tzbl0pXFxyXFxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ2R1cGxpY2F0ZWQgc24nKTtcXHJcXG4gICAgICAgIHRhc2tzW3NuXSA9ICB7XFxyXFxuICAgICAgICAgICAgY29kZWM6IG5ldyBDb2RlY0NsYXNzKG1zZy5vcHRpb25zKSxcXHJcXG4gICAgICAgICAgICBjcmNJbnB1dDogbXNnLmNyY1R5cGUgPT09ICdpbnB1dCcsXFxyXFxuICAgICAgICAgICAgY3JjT3V0cHV0OiBtc2cuY3JjVHlwZSA9PT0gJ291dHB1dCcsXFxyXFxuICAgICAgICAgICAgY3JjOiBuZXcgQ3JjMzIoKSxcXHJcXG4gICAgICAgIH07XFxyXFxuICAgICAgICBwb3N0TWVzc2FnZSh7dHlwZTogJ25ld1Rhc2snLCBzbjogc259KTtcXHJcXG4gICAgfVxcclxcblxcclxcbiAgICAvLyBwZXJmb3JtYW5jZSBtYXkgbm90IGJlIHN1cHBvcnRlZFxcclxcbiAgICB2YXIgbm93ID0gZ2xvYmFsLnBlcmZvcm1hbmNlID8gZ2xvYmFsLnBlcmZvcm1hbmNlLm5vdy5iaW5kKGdsb2JhbC5wZXJmb3JtYW5jZSkgOiBEYXRlLm5vdztcXHJcXG5cXHJcXG4gICAgZnVuY3Rpb24gcHJvY2Vzc0RhdGEobXNnKSB7XFxyXFxuICAgICAgICB2YXIgc24gPSBtc2cuc24sIHR5cGUgPSBtc2cudHlwZSwgaW5wdXQgPSBtc2cuZGF0YTtcXHJcXG4gICAgICAgIHZhciB0YXNrID0gdGFza3Nbc25dO1xcclxcbiAgICAgICAgLy8gYWxsb3cgY3JlYXRpbmcgY29kZWMgb24gZmlyc3QgYXBwZW5kXFxyXFxuICAgICAgICBpZiAoIXRhc2sgJiYgbXNnLmNvZGVjQ2xhc3MpIHtcXHJcXG4gICAgICAgICAgICBuZXdUYXNrKG1zZyk7XFxyXFxuICAgICAgICAgICAgdGFzayA9IHRhc2tzW3NuXTtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICAgIHZhciBpc0FwcGVuZCA9IHR5cGUgPT09ICdhcHBlbmQnO1xcclxcbiAgICAgICAgdmFyIHN0YXJ0ID0gbm93KCk7XFxyXFxuICAgICAgICB2YXIgb3V0cHV0O1xcclxcbiAgICAgICAgaWYgKGlzQXBwZW5kKSB7XFxyXFxuICAgICAgICAgICAgdHJ5IHtcXHJcXG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gdGFzay5jb2RlYy5hcHBlbmQoaW5wdXQsIGZ1bmN0aW9uIG9ucHJvZ3Jlc3MobG9hZGVkKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZSh7dHlwZTogJ3Byb2dyZXNzJywgc246IHNuLCBsb2FkZWQ6IGxvYWRlZH0pO1xcclxcbiAgICAgICAgICAgICAgICB9KTtcXHJcXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XFxyXFxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0YXNrc1tzbl07XFxyXFxuICAgICAgICAgICAgICAgIHRocm93IGU7XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgICBkZWxldGUgdGFza3Nbc25dO1xcclxcbiAgICAgICAgICAgIG91dHB1dCA9IHRhc2suY29kZWMuZmx1c2goKTtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICAgIHZhciBjb2RlY1RpbWUgPSBub3coKSAtIHN0YXJ0O1xcclxcblxcclxcbiAgICAgICAgc3RhcnQgPSBub3coKTtcXHJcXG4gICAgICAgIGlmIChpbnB1dCAmJiB0YXNrLmNyY0lucHV0KVxcclxcbiAgICAgICAgICAgIHRhc2suY3JjLmFwcGVuZChpbnB1dCk7XFxyXFxuICAgICAgICBpZiAob3V0cHV0ICYmIHRhc2suY3JjT3V0cHV0KVxcclxcbiAgICAgICAgICAgIHRhc2suY3JjLmFwcGVuZChvdXRwdXQpO1xcclxcbiAgICAgICAgdmFyIGNyY1RpbWUgPSBub3coKSAtIHN0YXJ0O1xcclxcblxcclxcbiAgICAgICAgdmFyIHJtc2cgPSB7dHlwZTogdHlwZSwgc246IHNuLCBjb2RlY1RpbWU6IGNvZGVjVGltZSwgY3JjVGltZTogY3JjVGltZX07XFxyXFxuICAgICAgICB2YXIgdHJhbnNmZXJhYmxlcyA9IFtdO1xcclxcbiAgICAgICAgaWYgKG91dHB1dCkge1xcclxcbiAgICAgICAgICAgIHJtc2cuZGF0YSA9IG91dHB1dDtcXHJcXG4gICAgICAgICAgICB0cmFuc2ZlcmFibGVzLnB1c2gob3V0cHV0LmJ1ZmZlcik7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICBpZiAoIWlzQXBwZW5kICYmICh0YXNrLmNyY0lucHV0IHx8IHRhc2suY3JjT3V0cHV0KSlcXHJcXG4gICAgICAgICAgICBybXNnLmNyYyA9IHRhc2suY3JjLmdldCgpO1xcclxcblxcclxcbiAgICAgICAgLy8gcG9zdGluZyBhIG1lc3NhZ2Ugd2l0aCB0cmFuc2ZlcmFibGVzIHdpbGwgZmFpbCBvbiBJRTEwXFxyXFxuICAgICAgICB0cnkge1xcclxcbiAgICAgICAgICAgIHBvc3RNZXNzYWdlKHJtc2csIHRyYW5zZmVyYWJsZXMpO1xcclxcbiAgICAgICAgfSBjYXRjaChleCkge1xcclxcbiAgICAgICAgICAgIHBvc3RNZXNzYWdlKHJtc2cpOyAvLyByZXRyeSB3aXRob3V0IHRyYW5zZmVyYWJsZXNcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgfVxcclxcblxcclxcbiAgICBmdW5jdGlvbiBvbkVycm9yKHR5cGUsIHNuLCBlKSB7XFxyXFxuICAgICAgICB2YXIgbXNnID0ge1xcclxcbiAgICAgICAgICAgIHR5cGU6IHR5cGUsXFxyXFxuICAgICAgICAgICAgc246IHNuLFxcclxcbiAgICAgICAgICAgIGVycm9yOiBmb3JtYXRFcnJvcihlKVxcclxcbiAgICAgICAgfTtcXHJcXG4gICAgICAgIHBvc3RNZXNzYWdlKG1zZyk7XFxyXFxuICAgIH1cXHJcXG5cXHJcXG4gICAgZnVuY3Rpb24gZm9ybWF0RXJyb3IoZSkge1xcclxcbiAgICAgICAgcmV0dXJuIHsgbWVzc2FnZTogZS5tZXNzYWdlLCBzdGFjazogZS5zdGFjayB9O1xcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgIC8vIENyYzMyIGNvZGUgY29waWVkIGZyb20gZmlsZSB6aXAuanNcXHJcXG4gICAgZnVuY3Rpb24gQ3JjMzIoKSB7XFxyXFxuICAgICAgICB0aGlzLmNyYyA9IC0xO1xcclxcbiAgICB9XFxyXFxuICAgIENyYzMyLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbiBhcHBlbmQoZGF0YSkge1xcclxcbiAgICAgICAgdmFyIGNyYyA9IHRoaXMuY3JjIHwgMCwgdGFibGUgPSB0aGlzLnRhYmxlO1xcclxcbiAgICAgICAgZm9yICh2YXIgb2Zmc2V0ID0gMCwgbGVuID0gZGF0YS5sZW5ndGggfCAwOyBvZmZzZXQgPCBsZW47IG9mZnNldCsrKVxcclxcbiAgICAgICAgICAgIGNyYyA9IChjcmMgPj4+IDgpIF4gdGFibGVbKGNyYyBeIGRhdGFbb2Zmc2V0XSkgJiAweEZGXTtcXHJcXG4gICAgICAgIHRoaXMuY3JjID0gY3JjO1xcclxcbiAgICB9O1xcclxcbiAgICBDcmMzMi5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0KCkge1xcclxcbiAgICAgICAgcmV0dXJuIH50aGlzLmNyYztcXHJcXG4gICAgfTtcXHJcXG4gICAgQ3JjMzIucHJvdG90eXBlLnRhYmxlID0gKGZ1bmN0aW9uKCkge1xcclxcbiAgICAgICAgdmFyIGksIGosIHQsIHRhYmxlID0gW107IC8vIFVpbnQzMkFycmF5IGlzIGFjdHVhbGx5IHNsb3dlciB0aGFuIFtdXFxyXFxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcXHJcXG4gICAgICAgICAgICB0ID0gaTtcXHJcXG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgODsgaisrKVxcclxcbiAgICAgICAgICAgICAgICBpZiAodCAmIDEpXFxyXFxuICAgICAgICAgICAgICAgICAgICB0ID0gKHQgPj4+IDEpIF4gMHhFREI4ODMyMDtcXHJcXG4gICAgICAgICAgICAgICAgZWxzZVxcclxcbiAgICAgICAgICAgICAgICAgICAgdCA9IHQgPj4+IDE7XFxyXFxuICAgICAgICAgICAgdGFibGVbaV0gPSB0O1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgcmV0dXJuIHRhYmxlO1xcclxcbiAgICB9KSgpO1xcclxcblxcclxcbiAgICAvLyBcXFwibm8tb3BcXFwiIGNvZGVjXFxyXFxuICAgIGZ1bmN0aW9uIE5PT1AoKSB7fVxcclxcbiAgICBnbG9iYWwuTk9PUCA9IE5PT1A7XFxyXFxuICAgIE5PT1AucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uIGFwcGVuZChieXRlcywgb25wcm9ncmVzcykge1xcclxcbiAgICAgICAgcmV0dXJuIGJ5dGVzO1xcclxcbiAgICB9O1xcclxcbiAgICBOT09QLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uIGZsdXNoKCkge307XFxyXFxufSkodGhpcyk7XCI7XG4iLCIvKlxyXG4gQ29weXJpZ2h0IChjKSAyMDEzIEdpbGRhcyBMb3JtZWF1LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG5cclxuIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxyXG4gbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XHJcblxyXG4gMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxyXG4gdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cclxuXHJcbiAyLiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxyXG4gbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluXHJcbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cclxuXHJcbiAzLiBUaGUgbmFtZXMgb2YgdGhlIGF1dGhvcnMgbWF5IG5vdCBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0c1xyXG4gZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXHJcblxyXG4gVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBgYEFTIElTJycgQU5EIEFOWSBFWFBSRVNTRUQgT1IgSU1QTElFRCBXQVJSQU5USUVTLFxyXG4gSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORFxyXG4gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIEpDUkFGVCxcclxuIElOQy4gT1IgQU5ZIENPTlRSSUJVVE9SUyBUTyBUSElTIFNPRlRXQVJFIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsXHJcbiBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UXHJcbiBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSxcclxuIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0ZcclxuIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HXHJcbiBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsXHJcbiBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxyXG4gKi9cclxuXHJcbihmdW5jdGlvbigpIHtcclxuXHRcInVzZSBzdHJpY3RcIjtcclxuXHJcblx0dmFyIEVSUl9IVFRQX1JBTkdFID0gXCJIVFRQIFJhbmdlIG5vdCBzdXBwb3J0ZWQuXCI7XHJcblxyXG5cdHZhciBSZWFkZXIgPSB6aXAuUmVhZGVyO1xyXG5cdHZhciBXcml0ZXIgPSB6aXAuV3JpdGVyO1xyXG5cdFxyXG5cdHZhciBaaXBEaXJlY3RvcnlFbnRyeTtcclxuXHJcblx0dmFyIGFwcGVuZEFCVmlld1N1cHBvcnRlZDtcclxuXHR0cnkge1xyXG5cdFx0YXBwZW5kQUJWaWV3U3VwcG9ydGVkID0gbmV3IEJsb2IoWyBuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDApKSBdKS5zaXplID09PSAwO1xyXG5cdH0gY2F0Y2ggKGUpIHtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIEh0dHBSZWFkZXIodXJsKSB7XHJcblx0XHR2YXIgdGhhdCA9IHRoaXM7XHJcblxyXG5cdFx0ZnVuY3Rpb24gZ2V0RGF0YShjYWxsYmFjaywgb25lcnJvcikge1xyXG5cdFx0XHR2YXIgcmVxdWVzdDtcclxuXHRcdFx0aWYgKCF0aGF0LmRhdGEpIHtcclxuXHRcdFx0XHRyZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcblx0XHRcdFx0cmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdGlmICghdGhhdC5zaXplKVxyXG5cdFx0XHRcdFx0XHR0aGF0LnNpemUgPSBOdW1iZXIocmVxdWVzdC5nZXRSZXNwb25zZUhlYWRlcihcIkNvbnRlbnQtTGVuZ3RoXCIpKTtcclxuXHRcdFx0XHRcdHRoYXQuZGF0YSA9IG5ldyBVaW50OEFycmF5KHJlcXVlc3QucmVzcG9uc2UpO1xyXG5cdFx0XHRcdFx0Y2FsbGJhY2soKTtcclxuXHRcdFx0XHR9LCBmYWxzZSk7XHJcblx0XHRcdFx0cmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgb25lcnJvciwgZmFsc2UpO1xyXG5cdFx0XHRcdHJlcXVlc3Qub3BlbihcIkdFVFwiLCB1cmwpO1xyXG5cdFx0XHRcdHJlcXVlc3QucmVzcG9uc2VUeXBlID0gXCJhcnJheWJ1ZmZlclwiO1xyXG5cdFx0XHRcdHJlcXVlc3Quc2VuZCgpO1xyXG5cdFx0XHR9IGVsc2VcclxuXHRcdFx0XHRjYWxsYmFjaygpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIGluaXQoY2FsbGJhY2ssIG9uZXJyb3IpIHtcclxuXHRcdFx0dmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuXHRcdFx0cmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHR0aGF0LnNpemUgPSBOdW1iZXIocmVxdWVzdC5nZXRSZXNwb25zZUhlYWRlcihcIkNvbnRlbnQtTGVuZ3RoXCIpKTtcclxuXHRcdFx0XHRjYWxsYmFjaygpO1xyXG5cdFx0XHR9LCBmYWxzZSk7XHJcblx0XHRcdHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIG9uZXJyb3IsIGZhbHNlKTtcclxuXHRcdFx0cmVxdWVzdC5vcGVuKFwiSEVBRFwiLCB1cmwpO1xyXG5cdFx0XHRyZXF1ZXN0LnNlbmQoKTtcclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiByZWFkVWludDhBcnJheShpbmRleCwgbGVuZ3RoLCBjYWxsYmFjaywgb25lcnJvcikge1xyXG5cdFx0XHRnZXREYXRhKGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdGNhbGxiYWNrKG5ldyBVaW50OEFycmF5KHRoYXQuZGF0YS5zdWJhcnJheShpbmRleCwgaW5kZXggKyBsZW5ndGgpKSk7XHJcblx0XHRcdH0sIG9uZXJyb3IpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoYXQuc2l6ZSA9IDA7XHJcblx0XHR0aGF0LmluaXQgPSBpbml0O1xyXG5cdFx0dGhhdC5yZWFkVWludDhBcnJheSA9IHJlYWRVaW50OEFycmF5O1xyXG5cdH1cclxuXHRIdHRwUmVhZGVyLnByb3RvdHlwZSA9IG5ldyBSZWFkZXIoKTtcclxuXHRIdHRwUmVhZGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEh0dHBSZWFkZXI7XHJcblxyXG5cdGZ1bmN0aW9uIEh0dHBSYW5nZVJlYWRlcih1cmwpIHtcclxuXHRcdHZhciB0aGF0ID0gdGhpcztcclxuXHJcblx0XHRmdW5jdGlvbiBpbml0KGNhbGxiYWNrLCBvbmVycm9yKSB7XHJcblx0XHRcdHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcblx0XHRcdHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0dGhhdC5zaXplID0gTnVtYmVyKHJlcXVlc3QuZ2V0UmVzcG9uc2VIZWFkZXIoXCJDb250ZW50LUxlbmd0aFwiKSk7XHJcblx0XHRcdFx0aWYgKHJlcXVlc3QuZ2V0UmVzcG9uc2VIZWFkZXIoXCJBY2NlcHQtUmFuZ2VzXCIpID09IFwiYnl0ZXNcIilcclxuXHRcdFx0XHRcdGNhbGxiYWNrKCk7XHJcblx0XHRcdFx0ZWxzZVxyXG5cdFx0XHRcdFx0b25lcnJvcihFUlJfSFRUUF9SQU5HRSk7XHJcblx0XHRcdH0sIGZhbHNlKTtcclxuXHRcdFx0cmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgb25lcnJvciwgZmFsc2UpO1xyXG5cdFx0XHRyZXF1ZXN0Lm9wZW4oXCJIRUFEXCIsIHVybCk7XHJcblx0XHRcdHJlcXVlc3Quc2VuZCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIHJlYWRBcnJheUJ1ZmZlcihpbmRleCwgbGVuZ3RoLCBjYWxsYmFjaywgb25lcnJvcikge1xyXG5cdFx0XHR2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG5cdFx0XHRyZXF1ZXN0Lm9wZW4oXCJHRVRcIiwgdXJsKTtcclxuXHRcdFx0cmVxdWVzdC5yZXNwb25zZVR5cGUgPSBcImFycmF5YnVmZmVyXCI7XHJcblx0XHRcdHJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcihcIlJhbmdlXCIsIFwiYnl0ZXM9XCIgKyBpbmRleCArIFwiLVwiICsgKGluZGV4ICsgbGVuZ3RoIC0gMSkpO1xyXG5cdFx0XHRyZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdGNhbGxiYWNrKHJlcXVlc3QucmVzcG9uc2UpO1xyXG5cdFx0XHR9LCBmYWxzZSk7XHJcblx0XHRcdHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIG9uZXJyb3IsIGZhbHNlKTtcclxuXHRcdFx0cmVxdWVzdC5zZW5kKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gcmVhZFVpbnQ4QXJyYXkoaW5kZXgsIGxlbmd0aCwgY2FsbGJhY2ssIG9uZXJyb3IpIHtcclxuXHRcdFx0cmVhZEFycmF5QnVmZmVyKGluZGV4LCBsZW5ndGgsIGZ1bmN0aW9uKGFycmF5YnVmZmVyKSB7XHJcblx0XHRcdFx0Y2FsbGJhY2sobmV3IFVpbnQ4QXJyYXkoYXJyYXlidWZmZXIpKTtcclxuXHRcdFx0fSwgb25lcnJvcik7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhhdC5zaXplID0gMDtcclxuXHRcdHRoYXQuaW5pdCA9IGluaXQ7XHJcblx0XHR0aGF0LnJlYWRVaW50OEFycmF5ID0gcmVhZFVpbnQ4QXJyYXk7XHJcblx0fVxyXG5cdEh0dHBSYW5nZVJlYWRlci5wcm90b3R5cGUgPSBuZXcgUmVhZGVyKCk7XHJcblx0SHR0cFJhbmdlUmVhZGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEh0dHBSYW5nZVJlYWRlcjtcclxuXHJcblx0ZnVuY3Rpb24gQXJyYXlCdWZmZXJSZWFkZXIoYXJyYXlCdWZmZXIpIHtcclxuXHRcdHZhciB0aGF0ID0gdGhpcztcclxuXHJcblx0XHRmdW5jdGlvbiBpbml0KGNhbGxiYWNrLCBvbmVycm9yKSB7XHJcblx0XHRcdHRoYXQuc2l6ZSA9IGFycmF5QnVmZmVyLmJ5dGVMZW5ndGg7XHJcblx0XHRcdGNhbGxiYWNrKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gcmVhZFVpbnQ4QXJyYXkoaW5kZXgsIGxlbmd0aCwgY2FsbGJhY2ssIG9uZXJyb3IpIHtcclxuXHRcdFx0Y2FsbGJhY2sobmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIuc2xpY2UoaW5kZXgsIGluZGV4ICsgbGVuZ3RoKSkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoYXQuc2l6ZSA9IDA7XHJcblx0XHR0aGF0LmluaXQgPSBpbml0O1xyXG5cdFx0dGhhdC5yZWFkVWludDhBcnJheSA9IHJlYWRVaW50OEFycmF5O1xyXG5cdH1cclxuXHRBcnJheUJ1ZmZlclJlYWRlci5wcm90b3R5cGUgPSBuZXcgUmVhZGVyKCk7XHJcblx0QXJyYXlCdWZmZXJSZWFkZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQXJyYXlCdWZmZXJSZWFkZXI7XHJcblxyXG5cdGZ1bmN0aW9uIEFycmF5QnVmZmVyV3JpdGVyKCkge1xyXG5cdFx0dmFyIGFycmF5LCB0aGF0ID0gdGhpcztcclxuXHJcblx0XHRmdW5jdGlvbiBpbml0KGNhbGxiYWNrLCBvbmVycm9yKSB7XHJcblx0XHRcdGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoKTtcclxuXHRcdFx0Y2FsbGJhY2soKTtcclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiB3cml0ZVVpbnQ4QXJyYXkoYXJyLCBjYWxsYmFjaywgb25lcnJvcikge1xyXG5cdFx0XHR2YXIgdG1wQXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheS5sZW5ndGggKyBhcnIubGVuZ3RoKTtcclxuXHRcdFx0dG1wQXJyYXkuc2V0KGFycmF5KTtcclxuXHRcdFx0dG1wQXJyYXkuc2V0KGFyciwgYXJyYXkubGVuZ3RoKTtcclxuXHRcdFx0YXJyYXkgPSB0bXBBcnJheTtcclxuXHRcdFx0Y2FsbGJhY2soKTtcclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBnZXREYXRhKGNhbGxiYWNrKSB7XHJcblx0XHRcdGNhbGxiYWNrKGFycmF5LmJ1ZmZlcik7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhhdC5pbml0ID0gaW5pdDtcclxuXHRcdHRoYXQud3JpdGVVaW50OEFycmF5ID0gd3JpdGVVaW50OEFycmF5O1xyXG5cdFx0dGhhdC5nZXREYXRhID0gZ2V0RGF0YTtcclxuXHR9XHJcblx0QXJyYXlCdWZmZXJXcml0ZXIucHJvdG90eXBlID0gbmV3IFdyaXRlcigpO1xyXG5cdEFycmF5QnVmZmVyV3JpdGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEFycmF5QnVmZmVyV3JpdGVyO1xyXG5cclxuXHRmdW5jdGlvbiBGaWxlV3JpdGVyKGZpbGVFbnRyeSwgY29udGVudFR5cGUpIHtcclxuXHRcdHZhciB3cml0ZXIsIHRoYXQgPSB0aGlzO1xyXG5cclxuXHRcdGZ1bmN0aW9uIGluaXQoY2FsbGJhY2ssIG9uZXJyb3IpIHtcclxuXHRcdFx0ZmlsZUVudHJ5LmNyZWF0ZVdyaXRlcihmdW5jdGlvbihmaWxlV3JpdGVyKSB7XHJcblx0XHRcdFx0d3JpdGVyID0gZmlsZVdyaXRlcjtcclxuXHRcdFx0XHRjYWxsYmFjaygpO1xyXG5cdFx0XHR9LCBvbmVycm9yKTtcclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiB3cml0ZVVpbnQ4QXJyYXkoYXJyYXksIGNhbGxiYWNrLCBvbmVycm9yKSB7XHJcblx0XHRcdHZhciBibG9iID0gbmV3IEJsb2IoWyBhcHBlbmRBQlZpZXdTdXBwb3J0ZWQgPyBhcnJheSA6IGFycmF5LmJ1ZmZlciBdLCB7XHJcblx0XHRcdFx0dHlwZSA6IGNvbnRlbnRUeXBlXHJcblx0XHRcdH0pO1xyXG5cdFx0XHR3cml0ZXIub253cml0ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHdyaXRlci5vbndyaXRlID0gbnVsbDtcclxuXHRcdFx0XHRjYWxsYmFjaygpO1xyXG5cdFx0XHR9O1xyXG5cdFx0XHR3cml0ZXIub25lcnJvciA9IG9uZXJyb3I7XHJcblx0XHRcdHdyaXRlci53cml0ZShibG9iKTtcclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBnZXREYXRhKGNhbGxiYWNrKSB7XHJcblx0XHRcdGZpbGVFbnRyeS5maWxlKGNhbGxiYWNrKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGF0LmluaXQgPSBpbml0O1xyXG5cdFx0dGhhdC53cml0ZVVpbnQ4QXJyYXkgPSB3cml0ZVVpbnQ4QXJyYXk7XHJcblx0XHR0aGF0LmdldERhdGEgPSBnZXREYXRhO1xyXG5cdH1cclxuXHRGaWxlV3JpdGVyLnByb3RvdHlwZSA9IG5ldyBXcml0ZXIoKTtcclxuXHRGaWxlV3JpdGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEZpbGVXcml0ZXI7XHJcblxyXG5cdHppcC5GaWxlV3JpdGVyID0gRmlsZVdyaXRlcjtcclxuXHR6aXAuSHR0cFJlYWRlciA9IEh0dHBSZWFkZXI7XHJcblx0emlwLkh0dHBSYW5nZVJlYWRlciA9IEh0dHBSYW5nZVJlYWRlcjtcclxuXHR6aXAuQXJyYXlCdWZmZXJSZWFkZXIgPSBBcnJheUJ1ZmZlclJlYWRlcjtcclxuXHR6aXAuQXJyYXlCdWZmZXJXcml0ZXIgPSBBcnJheUJ1ZmZlcldyaXRlcjtcclxuXHJcblx0aWYgKHppcC5mcykge1xyXG5cdFx0WmlwRGlyZWN0b3J5RW50cnkgPSB6aXAuZnMuWmlwRGlyZWN0b3J5RW50cnk7XHJcblx0XHRaaXBEaXJlY3RvcnlFbnRyeS5wcm90b3R5cGUuYWRkSHR0cENvbnRlbnQgPSBmdW5jdGlvbihuYW1lLCBVUkwsIHVzZVJhbmdlSGVhZGVyKSB7XHJcblx0XHRcdGZ1bmN0aW9uIGFkZENoaWxkKHBhcmVudCwgbmFtZSwgcGFyYW1zLCBkaXJlY3RvcnkpIHtcclxuXHRcdFx0XHRpZiAocGFyZW50LmRpcmVjdG9yeSlcclxuXHRcdFx0XHRcdHJldHVybiBkaXJlY3RvcnkgPyBuZXcgWmlwRGlyZWN0b3J5RW50cnkocGFyZW50LmZzLCBuYW1lLCBwYXJhbXMsIHBhcmVudCkgOiBuZXcgemlwLmZzLlppcEZpbGVFbnRyeShwYXJlbnQuZnMsIG5hbWUsIHBhcmFtcywgcGFyZW50KTtcclxuXHRcdFx0XHRlbHNlXHJcblx0XHRcdFx0XHR0aHJvdyBcIlBhcmVudCBlbnRyeSBpcyBub3QgYSBkaXJlY3RvcnkuXCI7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBhZGRDaGlsZCh0aGlzLCBuYW1lLCB7XHJcblx0XHRcdFx0ZGF0YSA6IFVSTCxcclxuXHRcdFx0XHRSZWFkZXIgOiB1c2VSYW5nZUhlYWRlciA/IEh0dHBSYW5nZVJlYWRlciA6IEh0dHBSZWFkZXJcclxuXHRcdFx0fSk7XHJcblx0XHR9O1xyXG5cdFx0WmlwRGlyZWN0b3J5RW50cnkucHJvdG90eXBlLmltcG9ydEh0dHBDb250ZW50ID0gZnVuY3Rpb24oVVJMLCB1c2VSYW5nZUhlYWRlciwgb25lbmQsIG9uZXJyb3IpIHtcclxuXHRcdFx0dGhpcy5pbXBvcnRaaXAodXNlUmFuZ2VIZWFkZXIgPyBuZXcgSHR0cFJhbmdlUmVhZGVyKFVSTCkgOiBuZXcgSHR0cFJlYWRlcihVUkwpLCBvbmVuZCwgb25lcnJvcik7XHJcblx0XHR9O1xyXG5cdFx0emlwLmZzLkZTLnByb3RvdHlwZS5pbXBvcnRIdHRwQ29udGVudCA9IGZ1bmN0aW9uKFVSTCwgdXNlUmFuZ2VIZWFkZXIsIG9uZW5kLCBvbmVycm9yKSB7XHJcblx0XHRcdHRoaXMuZW50cmllcyA9IFtdO1xyXG5cdFx0XHR0aGlzLnJvb3QgPSBuZXcgWmlwRGlyZWN0b3J5RW50cnkodGhpcyk7XHJcblx0XHRcdHRoaXMucm9vdC5pbXBvcnRIdHRwQ29udGVudChVUkwsIHVzZVJhbmdlSGVhZGVyLCBvbmVuZCwgb25lcnJvcik7XHJcblx0XHR9O1xyXG5cdH1cclxuXHJcbn0pKCk7XHJcbiIsIi8qXHJcbiBDb3B5cmlnaHQgKGMpIDIwMTMgR2lsZGFzIExvcm1lYXUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcblxyXG4gUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XHJcbiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcclxuXHJcbiAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXHJcbiB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxyXG5cclxuIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XHJcbiBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW5cclxuIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxyXG5cclxuIDMuIFRoZSBuYW1lcyBvZiB0aGUgYXV0aG9ycyBtYXkgbm90IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzXHJcbiBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cclxuXHJcbiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIGBgQVMgSVMnJyBBTkQgQU5ZIEVYUFJFU1NFRCBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsXHJcbiBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EXHJcbiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgSkNSQUZULFxyXG4gSU5DLiBPUiBBTlkgQ09OVFJJQlVUT1JTIFRPIFRISVMgU09GVFdBUkUgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCxcclxuIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1RcclxuIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLFxyXG4gT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRlxyXG4gTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkdcclxuIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSxcclxuIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXHJcbiAqL1xyXG5cclxuKGZ1bmN0aW9uKG9iaikge1xyXG5cdFwidXNlIHN0cmljdFwiO1xyXG5cclxuXHR2YXIgRVJSX0JBRF9GT1JNQVQgPSBcIkZpbGUgZm9ybWF0IGlzIG5vdCByZWNvZ25pemVkLlwiO1xyXG5cdHZhciBFUlJfQ1JDID0gXCJDUkMgZmFpbGVkLlwiO1xyXG5cdHZhciBFUlJfRU5DUllQVEVEID0gXCJGaWxlIGNvbnRhaW5zIGVuY3J5cHRlZCBlbnRyeS5cIjtcclxuXHR2YXIgRVJSX1pJUDY0ID0gXCJGaWxlIGlzIHVzaW5nIFppcDY0ICg0Z2IrIGZpbGUgc2l6ZSkuXCI7XHJcblx0dmFyIEVSUl9SRUFEID0gXCJFcnJvciB3aGlsZSByZWFkaW5nIHppcCBmaWxlLlwiO1xyXG5cdHZhciBFUlJfV1JJVEUgPSBcIkVycm9yIHdoaWxlIHdyaXRpbmcgemlwIGZpbGUuXCI7XHJcblx0dmFyIEVSUl9XUklURV9EQVRBID0gXCJFcnJvciB3aGlsZSB3cml0aW5nIGZpbGUgZGF0YS5cIjtcclxuXHR2YXIgRVJSX1JFQURfREFUQSA9IFwiRXJyb3Igd2hpbGUgcmVhZGluZyBmaWxlIGRhdGEuXCI7XHJcblx0dmFyIEVSUl9EVVBMSUNBVEVEX05BTUUgPSBcIkZpbGUgYWxyZWFkeSBleGlzdHMuXCI7XHJcblx0dmFyIENIVU5LX1NJWkUgPSA1MTIgKiAxMDI0O1xyXG5cclxuXHR2YXIgVEVYVF9QTEFJTiA9IFwidGV4dC9wbGFpblwiO1xyXG5cclxuXHR2YXIgYXBwZW5kQUJWaWV3U3VwcG9ydGVkO1xyXG5cdHRyeSB7XHJcblx0XHRhcHBlbmRBQlZpZXdTdXBwb3J0ZWQgPSBuZXcgQmxvYihbIG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMCkpIF0pLnNpemUgPT09IDA7XHJcblx0fSBjYXRjaCAoZSkge1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gQ3JjMzIoKSB7XHJcblx0XHR0aGlzLmNyYyA9IC0xO1xyXG5cdH1cclxuXHRDcmMzMi5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24gYXBwZW5kKGRhdGEpIHtcclxuXHRcdHZhciBjcmMgPSB0aGlzLmNyYyB8IDAsIHRhYmxlID0gdGhpcy50YWJsZTtcclxuXHRcdGZvciAodmFyIG9mZnNldCA9IDAsIGxlbiA9IGRhdGEubGVuZ3RoIHwgMDsgb2Zmc2V0IDwgbGVuOyBvZmZzZXQrKylcclxuXHRcdFx0Y3JjID0gKGNyYyA+Pj4gOCkgXiB0YWJsZVsoY3JjIF4gZGF0YVtvZmZzZXRdKSAmIDB4RkZdO1xyXG5cdFx0dGhpcy5jcmMgPSBjcmM7XHJcblx0fTtcclxuXHRDcmMzMi5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0KCkge1xyXG5cdFx0cmV0dXJuIH50aGlzLmNyYztcclxuXHR9O1xyXG5cdENyYzMyLnByb3RvdHlwZS50YWJsZSA9IChmdW5jdGlvbigpIHtcclxuXHRcdHZhciBpLCBqLCB0LCB0YWJsZSA9IFtdOyAvLyBVaW50MzJBcnJheSBpcyBhY3R1YWxseSBzbG93ZXIgdGhhbiBbXVxyXG5cdFx0Zm9yIChpID0gMDsgaSA8IDI1NjsgaSsrKSB7XHJcblx0XHRcdHQgPSBpO1xyXG5cdFx0XHRmb3IgKGogPSAwOyBqIDwgODsgaisrKVxyXG5cdFx0XHRcdGlmICh0ICYgMSlcclxuXHRcdFx0XHRcdHQgPSAodCA+Pj4gMSkgXiAweEVEQjg4MzIwO1xyXG5cdFx0XHRcdGVsc2VcclxuXHRcdFx0XHRcdHQgPSB0ID4+PiAxO1xyXG5cdFx0XHR0YWJsZVtpXSA9IHQ7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGFibGU7XHJcblx0fSkoKTtcclxuXHJcblx0Ly8gXCJuby1vcFwiIGNvZGVjXHJcblx0ZnVuY3Rpb24gTk9PUCgpIHt9XHJcblx0Tk9PUC5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24gYXBwZW5kKGJ5dGVzLCBvbnByb2dyZXNzKSB7XHJcblx0XHRyZXR1cm4gYnl0ZXM7XHJcblx0fTtcclxuXHROT09QLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uIGZsdXNoKCkge307XHJcblxyXG5cdGZ1bmN0aW9uIGJsb2JTbGljZShibG9iLCBpbmRleCwgbGVuZ3RoKSB7XHJcblx0XHRpZiAoaW5kZXggPCAwIHx8IGxlbmd0aCA8IDAgfHwgaW5kZXggKyBsZW5ndGggPiBibG9iLnNpemUpXHJcblx0XHRcdHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQ6JyArIGluZGV4ICsgJywgbGVuZ3RoOicgKyBsZW5ndGggKyAnLCBzaXplOicgKyBibG9iLnNpemUpO1xyXG5cdFx0aWYgKGJsb2Iuc2xpY2UpXHJcblx0XHRcdHJldHVybiBibG9iLnNsaWNlKGluZGV4LCBpbmRleCArIGxlbmd0aCk7XHJcblx0XHRlbHNlIGlmIChibG9iLndlYmtpdFNsaWNlKVxyXG5cdFx0XHRyZXR1cm4gYmxvYi53ZWJraXRTbGljZShpbmRleCwgaW5kZXggKyBsZW5ndGgpO1xyXG5cdFx0ZWxzZSBpZiAoYmxvYi5tb3pTbGljZSlcclxuXHRcdFx0cmV0dXJuIGJsb2IubW96U2xpY2UoaW5kZXgsIGluZGV4ICsgbGVuZ3RoKTtcclxuXHRcdGVsc2UgaWYgKGJsb2IubXNTbGljZSlcclxuXHRcdFx0cmV0dXJuIGJsb2IubXNTbGljZShpbmRleCwgaW5kZXggKyBsZW5ndGgpO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gZ2V0RGF0YUhlbHBlcihieXRlTGVuZ3RoLCBieXRlcykge1xyXG5cdFx0dmFyIGRhdGFCdWZmZXIsIGRhdGFBcnJheTtcclxuXHRcdGRhdGFCdWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoYnl0ZUxlbmd0aCk7XHJcblx0XHRkYXRhQXJyYXkgPSBuZXcgVWludDhBcnJheShkYXRhQnVmZmVyKTtcclxuXHRcdGlmIChieXRlcylcclxuXHRcdFx0ZGF0YUFycmF5LnNldChieXRlcywgMCk7XHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHRidWZmZXIgOiBkYXRhQnVmZmVyLFxyXG5cdFx0XHRhcnJheSA6IGRhdGFBcnJheSxcclxuXHRcdFx0dmlldyA6IG5ldyBEYXRhVmlldyhkYXRhQnVmZmVyKVxyXG5cdFx0fTtcclxuXHR9XHJcblxyXG5cdC8vIFJlYWRlcnNcclxuXHRmdW5jdGlvbiBSZWFkZXIoKSB7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBUZXh0UmVhZGVyKHRleHQpIHtcclxuXHRcdHZhciB0aGF0ID0gdGhpcywgYmxvYlJlYWRlcjtcclxuXHJcblx0XHRmdW5jdGlvbiBpbml0KGNhbGxiYWNrLCBvbmVycm9yKSB7XHJcblx0XHRcdHZhciBibG9iID0gbmV3IEJsb2IoWyB0ZXh0IF0sIHtcclxuXHRcdFx0XHR0eXBlIDogVEVYVF9QTEFJTlxyXG5cdFx0XHR9KTtcclxuXHRcdFx0YmxvYlJlYWRlciA9IG5ldyBCbG9iUmVhZGVyKGJsb2IpO1xyXG5cdFx0XHRibG9iUmVhZGVyLmluaXQoZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0dGhhdC5zaXplID0gYmxvYlJlYWRlci5zaXplO1xyXG5cdFx0XHRcdGNhbGxiYWNrKCk7XHJcblx0XHRcdH0sIG9uZXJyb3IpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIHJlYWRVaW50OEFycmF5KGluZGV4LCBsZW5ndGgsIGNhbGxiYWNrLCBvbmVycm9yKSB7XHJcblx0XHRcdGJsb2JSZWFkZXIucmVhZFVpbnQ4QXJyYXkoaW5kZXgsIGxlbmd0aCwgY2FsbGJhY2ssIG9uZXJyb3IpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoYXQuc2l6ZSA9IDA7XHJcblx0XHR0aGF0LmluaXQgPSBpbml0O1xyXG5cdFx0dGhhdC5yZWFkVWludDhBcnJheSA9IHJlYWRVaW50OEFycmF5O1xyXG5cdH1cclxuXHRUZXh0UmVhZGVyLnByb3RvdHlwZSA9IG5ldyBSZWFkZXIoKTtcclxuXHRUZXh0UmVhZGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRleHRSZWFkZXI7XHJcblxyXG5cdGZ1bmN0aW9uIERhdGE2NFVSSVJlYWRlcihkYXRhVVJJKSB7XHJcblx0XHR2YXIgdGhhdCA9IHRoaXMsIGRhdGFTdGFydDtcclxuXHJcblx0XHRmdW5jdGlvbiBpbml0KGNhbGxiYWNrKSB7XHJcblx0XHRcdHZhciBkYXRhRW5kID0gZGF0YVVSSS5sZW5ndGg7XHJcblx0XHRcdHdoaWxlIChkYXRhVVJJLmNoYXJBdChkYXRhRW5kIC0gMSkgPT0gXCI9XCIpXHJcblx0XHRcdFx0ZGF0YUVuZC0tO1xyXG5cdFx0XHRkYXRhU3RhcnQgPSBkYXRhVVJJLmluZGV4T2YoXCIsXCIpICsgMTtcclxuXHRcdFx0dGhhdC5zaXplID0gTWF0aC5mbG9vcigoZGF0YUVuZCAtIGRhdGFTdGFydCkgKiAwLjc1KTtcclxuXHRcdFx0Y2FsbGJhY2soKTtcclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiByZWFkVWludDhBcnJheShpbmRleCwgbGVuZ3RoLCBjYWxsYmFjaykge1xyXG5cdFx0XHR2YXIgaSwgZGF0YSA9IGdldERhdGFIZWxwZXIobGVuZ3RoKTtcclxuXHRcdFx0dmFyIHN0YXJ0ID0gTWF0aC5mbG9vcihpbmRleCAvIDMpICogNDtcclxuXHRcdFx0dmFyIGVuZCA9IE1hdGguY2VpbCgoaW5kZXggKyBsZW5ndGgpIC8gMykgKiA0O1xyXG5cdFx0XHR2YXIgYnl0ZXMgPSBvYmouYXRvYihkYXRhVVJJLnN1YnN0cmluZyhzdGFydCArIGRhdGFTdGFydCwgZW5kICsgZGF0YVN0YXJ0KSk7XHJcblx0XHRcdHZhciBkZWx0YSA9IGluZGV4IC0gTWF0aC5mbG9vcihzdGFydCAvIDQpICogMztcclxuXHRcdFx0Zm9yIChpID0gZGVsdGE7IGkgPCBkZWx0YSArIGxlbmd0aDsgaSsrKVxyXG5cdFx0XHRcdGRhdGEuYXJyYXlbaSAtIGRlbHRhXSA9IGJ5dGVzLmNoYXJDb2RlQXQoaSk7XHJcblx0XHRcdGNhbGxiYWNrKGRhdGEuYXJyYXkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoYXQuc2l6ZSA9IDA7XHJcblx0XHR0aGF0LmluaXQgPSBpbml0O1xyXG5cdFx0dGhhdC5yZWFkVWludDhBcnJheSA9IHJlYWRVaW50OEFycmF5O1xyXG5cdH1cclxuXHREYXRhNjRVUklSZWFkZXIucHJvdG90eXBlID0gbmV3IFJlYWRlcigpO1xyXG5cdERhdGE2NFVSSVJlYWRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBEYXRhNjRVUklSZWFkZXI7XHJcblxyXG5cdGZ1bmN0aW9uIEJsb2JSZWFkZXIoYmxvYikge1xyXG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xyXG5cclxuXHRcdGZ1bmN0aW9uIGluaXQoY2FsbGJhY2spIHtcclxuXHRcdFx0dGhhdC5zaXplID0gYmxvYi5zaXplO1xyXG5cdFx0XHRjYWxsYmFjaygpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIHJlYWRVaW50OEFycmF5KGluZGV4LCBsZW5ndGgsIGNhbGxiYWNrLCBvbmVycm9yKSB7XHJcblx0XHRcdHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xyXG5cdFx0XHRyZWFkZXIub25sb2FkID0gZnVuY3Rpb24oZSkge1xyXG5cdFx0XHRcdGNhbGxiYWNrKG5ldyBVaW50OEFycmF5KGUudGFyZ2V0LnJlc3VsdCkpO1xyXG5cdFx0XHR9O1xyXG5cdFx0XHRyZWFkZXIub25lcnJvciA9IG9uZXJyb3I7XHJcblx0XHRcdHRyeSB7XHJcblx0XHRcdFx0cmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGJsb2JTbGljZShibG9iLCBpbmRleCwgbGVuZ3RoKSk7XHJcblx0XHRcdH0gY2F0Y2ggKGUpIHtcclxuXHRcdFx0XHRvbmVycm9yKGUpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0dGhhdC5zaXplID0gMDtcclxuXHRcdHRoYXQuaW5pdCA9IGluaXQ7XHJcblx0XHR0aGF0LnJlYWRVaW50OEFycmF5ID0gcmVhZFVpbnQ4QXJyYXk7XHJcblx0fVxyXG5cdEJsb2JSZWFkZXIucHJvdG90eXBlID0gbmV3IFJlYWRlcigpO1xyXG5cdEJsb2JSZWFkZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQmxvYlJlYWRlcjtcclxuXHJcblx0Ly8gV3JpdGVyc1xyXG5cclxuXHRmdW5jdGlvbiBXcml0ZXIoKSB7XHJcblx0fVxyXG5cdFdyaXRlci5wcm90b3R5cGUuZ2V0RGF0YSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XHJcblx0XHRjYWxsYmFjayh0aGlzLmRhdGEpO1xyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIFRleHRXcml0ZXIoZW5jb2RpbmcpIHtcclxuXHRcdHZhciB0aGF0ID0gdGhpcywgYmxvYjtcclxuXHJcblx0XHRmdW5jdGlvbiBpbml0KGNhbGxiYWNrKSB7XHJcblx0XHRcdGJsb2IgPSBuZXcgQmxvYihbXSwge1xyXG5cdFx0XHRcdHR5cGUgOiBURVhUX1BMQUlOXHJcblx0XHRcdH0pO1xyXG5cdFx0XHRjYWxsYmFjaygpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIHdyaXRlVWludDhBcnJheShhcnJheSwgY2FsbGJhY2spIHtcclxuXHRcdFx0YmxvYiA9IG5ldyBCbG9iKFsgYmxvYiwgYXBwZW5kQUJWaWV3U3VwcG9ydGVkID8gYXJyYXkgOiBhcnJheS5idWZmZXIgXSwge1xyXG5cdFx0XHRcdHR5cGUgOiBURVhUX1BMQUlOXHJcblx0XHRcdH0pO1xyXG5cdFx0XHRjYWxsYmFjaygpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIGdldERhdGEoY2FsbGJhY2ssIG9uZXJyb3IpIHtcclxuXHRcdFx0dmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XHJcblx0XHRcdHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbihlKSB7XHJcblx0XHRcdFx0Y2FsbGJhY2soZS50YXJnZXQucmVzdWx0KTtcclxuXHRcdFx0fTtcclxuXHRcdFx0cmVhZGVyLm9uZXJyb3IgPSBvbmVycm9yO1xyXG5cdFx0XHRyZWFkZXIucmVhZEFzVGV4dChibG9iLCBlbmNvZGluZyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhhdC5pbml0ID0gaW5pdDtcclxuXHRcdHRoYXQud3JpdGVVaW50OEFycmF5ID0gd3JpdGVVaW50OEFycmF5O1xyXG5cdFx0dGhhdC5nZXREYXRhID0gZ2V0RGF0YTtcclxuXHR9XHJcblx0VGV4dFdyaXRlci5wcm90b3R5cGUgPSBuZXcgV3JpdGVyKCk7XHJcblx0VGV4dFdyaXRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUZXh0V3JpdGVyO1xyXG5cclxuXHRmdW5jdGlvbiBEYXRhNjRVUklXcml0ZXIoY29udGVudFR5cGUpIHtcclxuXHRcdHZhciB0aGF0ID0gdGhpcywgZGF0YSA9IFwiXCIsIHBlbmRpbmcgPSBcIlwiO1xyXG5cclxuXHRcdGZ1bmN0aW9uIGluaXQoY2FsbGJhY2spIHtcclxuXHRcdFx0ZGF0YSArPSBcImRhdGE6XCIgKyAoY29udGVudFR5cGUgfHwgXCJcIikgKyBcIjtiYXNlNjQsXCI7XHJcblx0XHRcdGNhbGxiYWNrKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gd3JpdGVVaW50OEFycmF5KGFycmF5LCBjYWxsYmFjaykge1xyXG5cdFx0XHR2YXIgaSwgZGVsdGEgPSBwZW5kaW5nLmxlbmd0aCwgZGF0YVN0cmluZyA9IHBlbmRpbmc7XHJcblx0XHRcdHBlbmRpbmcgPSBcIlwiO1xyXG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgKE1hdGguZmxvb3IoKGRlbHRhICsgYXJyYXkubGVuZ3RoKSAvIDMpICogMykgLSBkZWx0YTsgaSsrKVxyXG5cdFx0XHRcdGRhdGFTdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShhcnJheVtpXSk7XHJcblx0XHRcdGZvciAoOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspXHJcblx0XHRcdFx0cGVuZGluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGFycmF5W2ldKTtcclxuXHRcdFx0aWYgKGRhdGFTdHJpbmcubGVuZ3RoID4gMilcclxuXHRcdFx0XHRkYXRhICs9IG9iai5idG9hKGRhdGFTdHJpbmcpO1xyXG5cdFx0XHRlbHNlXHJcblx0XHRcdFx0cGVuZGluZyA9IGRhdGFTdHJpbmc7XHJcblx0XHRcdGNhbGxiYWNrKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gZ2V0RGF0YShjYWxsYmFjaykge1xyXG5cdFx0XHRjYWxsYmFjayhkYXRhICsgb2JqLmJ0b2EocGVuZGluZykpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoYXQuaW5pdCA9IGluaXQ7XHJcblx0XHR0aGF0LndyaXRlVWludDhBcnJheSA9IHdyaXRlVWludDhBcnJheTtcclxuXHRcdHRoYXQuZ2V0RGF0YSA9IGdldERhdGE7XHJcblx0fVxyXG5cdERhdGE2NFVSSVdyaXRlci5wcm90b3R5cGUgPSBuZXcgV3JpdGVyKCk7XHJcblx0RGF0YTY0VVJJV3JpdGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IERhdGE2NFVSSVdyaXRlcjtcclxuXHJcblx0ZnVuY3Rpb24gQmxvYldyaXRlcihjb250ZW50VHlwZSkge1xyXG5cdFx0dmFyIGJsb2IsIHRoYXQgPSB0aGlzO1xyXG5cclxuXHRcdGZ1bmN0aW9uIGluaXQoY2FsbGJhY2spIHtcclxuXHRcdFx0YmxvYiA9IG5ldyBCbG9iKFtdLCB7XHJcblx0XHRcdFx0dHlwZSA6IGNvbnRlbnRUeXBlXHJcblx0XHRcdH0pO1xyXG5cdFx0XHRjYWxsYmFjaygpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIHdyaXRlVWludDhBcnJheShhcnJheSwgY2FsbGJhY2spIHtcclxuXHRcdFx0YmxvYiA9IG5ldyBCbG9iKFsgYmxvYiwgYXBwZW5kQUJWaWV3U3VwcG9ydGVkID8gYXJyYXkgOiBhcnJheS5idWZmZXIgXSwge1xyXG5cdFx0XHRcdHR5cGUgOiBjb250ZW50VHlwZVxyXG5cdFx0XHR9KTtcclxuXHRcdFx0Y2FsbGJhY2soKTtcclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBnZXREYXRhKGNhbGxiYWNrKSB7XHJcblx0XHRcdGNhbGxiYWNrKGJsb2IpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoYXQuaW5pdCA9IGluaXQ7XHJcblx0XHR0aGF0LndyaXRlVWludDhBcnJheSA9IHdyaXRlVWludDhBcnJheTtcclxuXHRcdHRoYXQuZ2V0RGF0YSA9IGdldERhdGE7XHJcblx0fVxyXG5cdEJsb2JXcml0ZXIucHJvdG90eXBlID0gbmV3IFdyaXRlcigpO1xyXG5cdEJsb2JXcml0ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQmxvYldyaXRlcjtcclxuXHJcblx0LyoqXHJcblx0ICogaW5mbGF0ZS9kZWZsYXRlIGNvcmUgZnVuY3Rpb25zXHJcblx0ICogQHBhcmFtIHdvcmtlciB7V29ya2VyfSB3ZWIgd29ya2VyIGZvciB0aGUgdGFzay5cclxuXHQgKiBAcGFyYW0gaW5pdGlhbE1lc3NhZ2Uge09iamVjdH0gaW5pdGlhbCBtZXNzYWdlIHRvIGJlIHNlbnQgdG8gdGhlIHdvcmtlci4gc2hvdWxkIGNvbnRhaW5cclxuXHQgKiAgIHNuKHNlcmlhbCBudW1iZXIgZm9yIGRpc3Rpbmd1aXNoaW5nIG11bHRpcGxlIHRhc2tzIHNlbnQgdG8gdGhlIHdvcmtlciksIGFuZCBjb2RlY0NsYXNzLlxyXG5cdCAqICAgVGhpcyBmdW5jdGlvbiBtYXkgYWRkIG1vcmUgcHJvcGVydGllcyBiZWZvcmUgc2VuZGluZy5cclxuXHQgKi9cclxuXHRmdW5jdGlvbiBsYXVuY2hXb3JrZXJQcm9jZXNzKHdvcmtlciwgaW5pdGlhbE1lc3NhZ2UsIHJlYWRlciwgd3JpdGVyLCBvZmZzZXQsIHNpemUsIG9ucHJvZ3Jlc3MsIG9uZW5kLCBvbnJlYWRlcnJvciwgb253cml0ZWVycm9yKSB7XHJcblx0XHR2YXIgY2h1bmtJbmRleCA9IDAsIGluZGV4LCBvdXRwdXRTaXplLCBzbiA9IGluaXRpYWxNZXNzYWdlLnNuLCBjcmM7XHJcblxyXG5cdFx0ZnVuY3Rpb24gb25mbHVzaCgpIHtcclxuXHRcdFx0d29ya2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBvbm1lc3NhZ2UsIGZhbHNlKTtcclxuXHRcdFx0b25lbmQob3V0cHV0U2l6ZSwgY3JjKTtcclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBvbm1lc3NhZ2UoZXZlbnQpIHtcclxuXHRcdFx0dmFyIG1lc3NhZ2UgPSBldmVudC5kYXRhLCBkYXRhID0gbWVzc2FnZS5kYXRhLCBlcnIgPSBtZXNzYWdlLmVycm9yO1xyXG5cdFx0XHRpZiAoZXJyKSB7XHJcblx0XHRcdFx0ZXJyLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJ0Vycm9yOiAnICsgdGhpcy5tZXNzYWdlOyB9O1xyXG5cdFx0XHRcdG9ucmVhZGVycm9yKGVycik7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChtZXNzYWdlLnNuICE9PSBzbilcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdGlmICh0eXBlb2YgbWVzc2FnZS5jb2RlY1RpbWUgPT09ICdudW1iZXInKVxyXG5cdFx0XHRcdHdvcmtlci5jb2RlY1RpbWUgKz0gbWVzc2FnZS5jb2RlY1RpbWU7IC8vIHNob3VsZCBiZSBiZWZvcmUgb25mbHVzaCgpXHJcblx0XHRcdGlmICh0eXBlb2YgbWVzc2FnZS5jcmNUaW1lID09PSAnbnVtYmVyJylcclxuXHRcdFx0XHR3b3JrZXIuY3JjVGltZSArPSBtZXNzYWdlLmNyY1RpbWU7XHJcblxyXG5cdFx0XHRzd2l0Y2ggKG1lc3NhZ2UudHlwZSkge1xyXG5cdFx0XHRcdGNhc2UgJ2FwcGVuZCc6XHJcblx0XHRcdFx0XHRpZiAoZGF0YSkge1xyXG5cdFx0XHRcdFx0XHRvdXRwdXRTaXplICs9IGRhdGEubGVuZ3RoO1xyXG5cdFx0XHRcdFx0XHR3cml0ZXIud3JpdGVVaW50OEFycmF5KGRhdGEsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0XHRcdHN0ZXAoKTtcclxuXHRcdFx0XHRcdFx0fSwgb253cml0ZWVycm9yKTtcclxuXHRcdFx0XHRcdH0gZWxzZVxyXG5cdFx0XHRcdFx0XHRzdGVwKCk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRjYXNlICdmbHVzaCc6XHJcblx0XHRcdFx0XHRjcmMgPSBtZXNzYWdlLmNyYztcclxuXHRcdFx0XHRcdGlmIChkYXRhKSB7XHJcblx0XHRcdFx0XHRcdG91dHB1dFNpemUgKz0gZGF0YS5sZW5ndGg7XHJcblx0XHRcdFx0XHRcdHdyaXRlci53cml0ZVVpbnQ4QXJyYXkoZGF0YSwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHRcdFx0b25mbHVzaCgpO1xyXG5cdFx0XHRcdFx0XHR9LCBvbndyaXRlZXJyb3IpO1xyXG5cdFx0XHRcdFx0fSBlbHNlXHJcblx0XHRcdFx0XHRcdG9uZmx1c2goKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdGNhc2UgJ3Byb2dyZXNzJzpcclxuXHRcdFx0XHRcdGlmIChvbnByb2dyZXNzKVxyXG5cdFx0XHRcdFx0XHRvbnByb2dyZXNzKGluZGV4ICsgbWVzc2FnZS5sb2FkZWQsIHNpemUpO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0Y2FzZSAnaW1wb3J0U2NyaXB0cyc6IC8vbm8gbmVlZCB0byBoYW5kbGUgaGVyZVxyXG5cdFx0XHRcdGNhc2UgJ25ld1Rhc2snOlxyXG5cdFx0XHRcdGNhc2UgJ2VjaG8nOlxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0ZGVmYXVsdDpcclxuXHRcdFx0XHRcdGNvbnNvbGUud2FybignemlwLmpzOmxhdW5jaFdvcmtlclByb2Nlc3M6IHVua25vd24gbWVzc2FnZTogJywgbWVzc2FnZSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBzdGVwKCkge1xyXG5cdFx0XHRpbmRleCA9IGNodW5rSW5kZXggKiBDSFVOS19TSVpFO1xyXG5cdFx0XHQvLyB1c2UgYDw9YCBpbnN0ZWFkIG9mIGA8YCwgYmVjYXVzZSBgc2l6ZWAgbWF5IGJlIDAuXHJcblx0XHRcdGlmIChpbmRleCA8PSBzaXplKSB7XHJcblx0XHRcdFx0cmVhZGVyLnJlYWRVaW50OEFycmF5KG9mZnNldCArIGluZGV4LCBNYXRoLm1pbihDSFVOS19TSVpFLCBzaXplIC0gaW5kZXgpLCBmdW5jdGlvbihhcnJheSkge1xyXG5cdFx0XHRcdFx0aWYgKG9ucHJvZ3Jlc3MpXHJcblx0XHRcdFx0XHRcdG9ucHJvZ3Jlc3MoaW5kZXgsIHNpemUpO1xyXG5cdFx0XHRcdFx0dmFyIG1zZyA9IGluZGV4ID09PSAwID8gaW5pdGlhbE1lc3NhZ2UgOiB7c24gOiBzbn07XHJcblx0XHRcdFx0XHRtc2cudHlwZSA9ICdhcHBlbmQnO1xyXG5cdFx0XHRcdFx0bXNnLmRhdGEgPSBhcnJheTtcclxuXHJcblx0XHRcdFx0XHQvLyBwb3N0aW5nIGEgbWVzc2FnZSB3aXRoIHRyYW5zZmVyYWJsZXMgd2lsbCBmYWlsIG9uIElFMTBcclxuXHRcdFx0XHRcdHRyeSB7XHJcblx0XHRcdFx0XHRcdHdvcmtlci5wb3N0TWVzc2FnZShtc2csIFthcnJheS5idWZmZXJdKTtcclxuXHRcdFx0XHRcdH0gY2F0Y2goZXgpIHtcclxuXHRcdFx0XHRcdFx0d29ya2VyLnBvc3RNZXNzYWdlKG1zZyk7IC8vIHJldHJ5IHdpdGhvdXQgdHJhbnNmZXJhYmxlc1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0Y2h1bmtJbmRleCsrO1xyXG5cdFx0XHRcdH0sIG9ucmVhZGVycm9yKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR3b3JrZXIucG9zdE1lc3NhZ2Uoe1xyXG5cdFx0XHRcdFx0c246IHNuLFxyXG5cdFx0XHRcdFx0dHlwZTogJ2ZsdXNoJ1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0b3V0cHV0U2l6ZSA9IDA7XHJcblx0XHR3b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIG9ubWVzc2FnZSwgZmFsc2UpO1xyXG5cdFx0c3RlcCgpO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gbGF1bmNoUHJvY2Vzcyhwcm9jZXNzLCByZWFkZXIsIHdyaXRlciwgb2Zmc2V0LCBzaXplLCBjcmNUeXBlLCBvbnByb2dyZXNzLCBvbmVuZCwgb25yZWFkZXJyb3IsIG9ud3JpdGVlcnJvcikge1xyXG5cdFx0dmFyIGNodW5rSW5kZXggPSAwLCBpbmRleCwgb3V0cHV0U2l6ZSA9IDAsXHJcblx0XHRcdGNyY0lucHV0ID0gY3JjVHlwZSA9PT0gJ2lucHV0JyxcclxuXHRcdFx0Y3JjT3V0cHV0ID0gY3JjVHlwZSA9PT0gJ291dHB1dCcsXHJcblx0XHRcdGNyYyA9IG5ldyBDcmMzMigpO1xyXG5cdFx0ZnVuY3Rpb24gc3RlcCgpIHtcclxuXHRcdFx0dmFyIG91dHB1dERhdGE7XHJcblx0XHRcdGluZGV4ID0gY2h1bmtJbmRleCAqIENIVU5LX1NJWkU7XHJcblx0XHRcdGlmIChpbmRleCA8IHNpemUpXHJcblx0XHRcdFx0cmVhZGVyLnJlYWRVaW50OEFycmF5KG9mZnNldCArIGluZGV4LCBNYXRoLm1pbihDSFVOS19TSVpFLCBzaXplIC0gaW5kZXgpLCBmdW5jdGlvbihpbnB1dERhdGEpIHtcclxuXHRcdFx0XHRcdHZhciBvdXRwdXREYXRhO1xyXG5cdFx0XHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRcdFx0b3V0cHV0RGF0YSA9IHByb2Nlc3MuYXBwZW5kKGlucHV0RGF0YSwgZnVuY3Rpb24obG9hZGVkKSB7XHJcblx0XHRcdFx0XHRcdFx0aWYgKG9ucHJvZ3Jlc3MpXHJcblx0XHRcdFx0XHRcdFx0XHRvbnByb2dyZXNzKGluZGV4ICsgbG9hZGVkLCBzaXplKTtcclxuXHRcdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0XHR9IGNhdGNoIChlKSB7XHJcblx0XHRcdFx0XHRcdG9ucmVhZGVycm9yKGUpO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZiAob3V0cHV0RGF0YSkge1xyXG5cdFx0XHRcdFx0XHRvdXRwdXRTaXplICs9IG91dHB1dERhdGEubGVuZ3RoO1xyXG5cdFx0XHRcdFx0XHR3cml0ZXIud3JpdGVVaW50OEFycmF5KG91dHB1dERhdGEsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0XHRcdGNodW5rSW5kZXgrKztcclxuXHRcdFx0XHRcdFx0XHRzZXRUaW1lb3V0KHN0ZXAsIDEpO1xyXG5cdFx0XHRcdFx0XHR9LCBvbndyaXRlZXJyb3IpO1xyXG5cdFx0XHRcdFx0XHRpZiAoY3JjT3V0cHV0KVxyXG5cdFx0XHRcdFx0XHRcdGNyYy5hcHBlbmQob3V0cHV0RGF0YSk7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRjaHVua0luZGV4Kys7XHJcblx0XHRcdFx0XHRcdHNldFRpbWVvdXQoc3RlcCwgMSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZiAoY3JjSW5wdXQpXHJcblx0XHRcdFx0XHRcdGNyYy5hcHBlbmQoaW5wdXREYXRhKTtcclxuXHRcdFx0XHRcdGlmIChvbnByb2dyZXNzKVxyXG5cdFx0XHRcdFx0XHRvbnByb2dyZXNzKGluZGV4LCBzaXplKTtcclxuXHRcdFx0XHR9LCBvbnJlYWRlcnJvcik7XHJcblx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdHRyeSB7XHJcblx0XHRcdFx0XHRvdXRwdXREYXRhID0gcHJvY2Vzcy5mbHVzaCgpO1xyXG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHtcclxuXHRcdFx0XHRcdG9ucmVhZGVycm9yKGUpO1xyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiAob3V0cHV0RGF0YSkge1xyXG5cdFx0XHRcdFx0aWYgKGNyY091dHB1dClcclxuXHRcdFx0XHRcdFx0Y3JjLmFwcGVuZChvdXRwdXREYXRhKTtcclxuXHRcdFx0XHRcdG91dHB1dFNpemUgKz0gb3V0cHV0RGF0YS5sZW5ndGg7XHJcblx0XHRcdFx0XHR3cml0ZXIud3JpdGVVaW50OEFycmF5KG91dHB1dERhdGEsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0XHRvbmVuZChvdXRwdXRTaXplLCBjcmMuZ2V0KCkpO1xyXG5cdFx0XHRcdFx0fSwgb253cml0ZWVycm9yKTtcclxuXHRcdFx0XHR9IGVsc2VcclxuXHRcdFx0XHRcdG9uZW5kKG91dHB1dFNpemUsIGNyYy5nZXQoKSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRzdGVwKCk7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBpbmZsYXRlKHdvcmtlciwgc24sIHJlYWRlciwgd3JpdGVyLCBvZmZzZXQsIHNpemUsIGNvbXB1dGVDcmMzMiwgb25lbmQsIG9ucHJvZ3Jlc3MsIG9ucmVhZGVycm9yLCBvbndyaXRlZXJyb3IpIHtcclxuXHRcdHZhciBjcmNUeXBlID0gY29tcHV0ZUNyYzMyID8gJ291dHB1dCcgOiAnbm9uZSc7XHJcblx0XHRpZiAob2JqLnppcC51c2VXZWJXb3JrZXJzKSB7XHJcblx0XHRcdHZhciBpbml0aWFsTWVzc2FnZSA9IHtcclxuXHRcdFx0XHRzbjogc24sXHJcblx0XHRcdFx0Y29kZWNDbGFzczogJ0luZmxhdGVyJyxcclxuXHRcdFx0XHRjcmNUeXBlOiBjcmNUeXBlLFxyXG5cdFx0XHR9O1xyXG5cdFx0XHRsYXVuY2hXb3JrZXJQcm9jZXNzKHdvcmtlciwgaW5pdGlhbE1lc3NhZ2UsIHJlYWRlciwgd3JpdGVyLCBvZmZzZXQsIHNpemUsIG9ucHJvZ3Jlc3MsIG9uZW5kLCBvbnJlYWRlcnJvciwgb253cml0ZWVycm9yKTtcclxuXHRcdH0gZWxzZVxyXG5cdFx0XHRsYXVuY2hQcm9jZXNzKG5ldyBvYmouemlwLkluZmxhdGVyKCksIHJlYWRlciwgd3JpdGVyLCBvZmZzZXQsIHNpemUsIGNyY1R5cGUsIG9ucHJvZ3Jlc3MsIG9uZW5kLCBvbnJlYWRlcnJvciwgb253cml0ZWVycm9yKTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGRlZmxhdGUod29ya2VyLCBzbiwgcmVhZGVyLCB3cml0ZXIsIGxldmVsLCBvbmVuZCwgb25wcm9ncmVzcywgb25yZWFkZXJyb3IsIG9ud3JpdGVlcnJvcikge1xyXG5cdFx0dmFyIGNyY1R5cGUgPSAnaW5wdXQnO1xyXG5cdFx0aWYgKG9iai56aXAudXNlV2ViV29ya2Vycykge1xyXG5cdFx0XHR2YXIgaW5pdGlhbE1lc3NhZ2UgPSB7XHJcblx0XHRcdFx0c246IHNuLFxyXG5cdFx0XHRcdG9wdGlvbnM6IHtsZXZlbDogbGV2ZWx9LFxyXG5cdFx0XHRcdGNvZGVjQ2xhc3M6ICdEZWZsYXRlcicsXHJcblx0XHRcdFx0Y3JjVHlwZTogY3JjVHlwZSxcclxuXHRcdFx0fTtcclxuXHRcdFx0bGF1bmNoV29ya2VyUHJvY2Vzcyh3b3JrZXIsIGluaXRpYWxNZXNzYWdlLCByZWFkZXIsIHdyaXRlciwgMCwgcmVhZGVyLnNpemUsIG9ucHJvZ3Jlc3MsIG9uZW5kLCBvbnJlYWRlcnJvciwgb253cml0ZWVycm9yKTtcclxuXHRcdH0gZWxzZVxyXG5cdFx0XHRsYXVuY2hQcm9jZXNzKG5ldyBvYmouemlwLkRlZmxhdGVyKCksIHJlYWRlciwgd3JpdGVyLCAwLCByZWFkZXIuc2l6ZSwgY3JjVHlwZSwgb25wcm9ncmVzcywgb25lbmQsIG9ucmVhZGVycm9yLCBvbndyaXRlZXJyb3IpO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gY29weSh3b3JrZXIsIHNuLCByZWFkZXIsIHdyaXRlciwgb2Zmc2V0LCBzaXplLCBjb21wdXRlQ3JjMzIsIG9uZW5kLCBvbnByb2dyZXNzLCBvbnJlYWRlcnJvciwgb253cml0ZWVycm9yKSB7XHJcblx0XHR2YXIgY3JjVHlwZSA9ICdpbnB1dCc7XHJcblx0XHRpZiAob2JqLnppcC51c2VXZWJXb3JrZXJzICYmIGNvbXB1dGVDcmMzMikge1xyXG5cdFx0XHR2YXIgaW5pdGlhbE1lc3NhZ2UgPSB7XHJcblx0XHRcdFx0c246IHNuLFxyXG5cdFx0XHRcdGNvZGVjQ2xhc3M6ICdOT09QJyxcclxuXHRcdFx0XHRjcmNUeXBlOiBjcmNUeXBlLFxyXG5cdFx0XHR9O1xyXG5cdFx0XHRsYXVuY2hXb3JrZXJQcm9jZXNzKHdvcmtlciwgaW5pdGlhbE1lc3NhZ2UsIHJlYWRlciwgd3JpdGVyLCBvZmZzZXQsIHNpemUsIG9ucHJvZ3Jlc3MsIG9uZW5kLCBvbnJlYWRlcnJvciwgb253cml0ZWVycm9yKTtcclxuXHRcdH0gZWxzZVxyXG5cdFx0XHRsYXVuY2hQcm9jZXNzKG5ldyBOT09QKCksIHJlYWRlciwgd3JpdGVyLCBvZmZzZXQsIHNpemUsIGNyY1R5cGUsIG9ucHJvZ3Jlc3MsIG9uZW5kLCBvbnJlYWRlcnJvciwgb253cml0ZWVycm9yKTtcclxuXHR9XHJcblxyXG5cdC8vIFppcFJlYWRlclxyXG5cclxuXHRmdW5jdGlvbiBkZWNvZGVBU0NJSShzdHIpIHtcclxuXHRcdHZhciBpLCBvdXQgPSBcIlwiLCBjaGFyQ29kZSwgZXh0ZW5kZWRBU0NJSSA9IFsgJ1xcdTAwQzcnLCAnXFx1MDBGQycsICdcXHUwMEU5JywgJ1xcdTAwRTInLCAnXFx1MDBFNCcsICdcXHUwMEUwJywgJ1xcdTAwRTUnLCAnXFx1MDBFNycsICdcXHUwMEVBJywgJ1xcdTAwRUInLFxyXG5cdFx0XHRcdCdcXHUwMEU4JywgJ1xcdTAwRUYnLCAnXFx1MDBFRScsICdcXHUwMEVDJywgJ1xcdTAwQzQnLCAnXFx1MDBDNScsICdcXHUwMEM5JywgJ1xcdTAwRTYnLCAnXFx1MDBDNicsICdcXHUwMEY0JywgJ1xcdTAwRjYnLCAnXFx1MDBGMicsICdcXHUwMEZCJywgJ1xcdTAwRjknLFxyXG5cdFx0XHRcdCdcXHUwMEZGJywgJ1xcdTAwRDYnLCAnXFx1MDBEQycsICdcXHUwMEY4JywgJ1xcdTAwQTMnLCAnXFx1MDBEOCcsICdcXHUwMEQ3JywgJ1xcdTAxOTInLCAnXFx1MDBFMScsICdcXHUwMEVEJywgJ1xcdTAwRjMnLCAnXFx1MDBGQScsICdcXHUwMEYxJywgJ1xcdTAwRDEnLFxyXG5cdFx0XHRcdCdcXHUwMEFBJywgJ1xcdTAwQkEnLCAnXFx1MDBCRicsICdcXHUwMEFFJywgJ1xcdTAwQUMnLCAnXFx1MDBCRCcsICdcXHUwMEJDJywgJ1xcdTAwQTEnLCAnXFx1MDBBQicsICdcXHUwMEJCJywgJ18nLCAnXycsICdfJywgJ1xcdTAwQTYnLCAnXFx1MDBBNicsXHJcblx0XHRcdFx0J1xcdTAwQzEnLCAnXFx1MDBDMicsICdcXHUwMEMwJywgJ1xcdTAwQTknLCAnXFx1MDBBNicsICdcXHUwMEE2JywgJysnLCAnKycsICdcXHUwMEEyJywgJ1xcdTAwQTUnLCAnKycsICcrJywgJy0nLCAnLScsICcrJywgJy0nLCAnKycsICdcXHUwMEUzJyxcclxuXHRcdFx0XHQnXFx1MDBDMycsICcrJywgJysnLCAnLScsICctJywgJ1xcdTAwQTYnLCAnLScsICcrJywgJ1xcdTAwQTQnLCAnXFx1MDBGMCcsICdcXHUwMEQwJywgJ1xcdTAwQ0EnLCAnXFx1MDBDQicsICdcXHUwMEM4JywgJ2knLCAnXFx1MDBDRCcsICdcXHUwMENFJyxcclxuXHRcdFx0XHQnXFx1MDBDRicsICcrJywgJysnLCAnXycsICdfJywgJ1xcdTAwQTYnLCAnXFx1MDBDQycsICdfJywgJ1xcdTAwRDMnLCAnXFx1MDBERicsICdcXHUwMEQ0JywgJ1xcdTAwRDInLCAnXFx1MDBGNScsICdcXHUwMEQ1JywgJ1xcdTAwQjUnLCAnXFx1MDBGRScsXHJcblx0XHRcdFx0J1xcdTAwREUnLCAnXFx1MDBEQScsICdcXHUwMERCJywgJ1xcdTAwRDknLCAnXFx1MDBGRCcsICdcXHUwMEREJywgJ1xcdTAwQUYnLCAnXFx1MDBCNCcsICdcXHUwMEFEJywgJ1xcdTAwQjEnLCAnXycsICdcXHUwMEJFJywgJ1xcdTAwQjYnLCAnXFx1MDBBNycsXHJcblx0XHRcdFx0J1xcdTAwRjcnLCAnXFx1MDBCOCcsICdcXHUwMEIwJywgJ1xcdTAwQTgnLCAnXFx1MDBCNycsICdcXHUwMEI5JywgJ1xcdTAwQjMnLCAnXFx1MDBCMicsICdfJywgJyAnIF07XHJcblx0XHRmb3IgKGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGNoYXJDb2RlID0gc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGO1xyXG5cdFx0XHRpZiAoY2hhckNvZGUgPiAxMjcpXHJcblx0XHRcdFx0b3V0ICs9IGV4dGVuZGVkQVNDSUlbY2hhckNvZGUgLSAxMjhdO1xyXG5cdFx0XHRlbHNlXHJcblx0XHRcdFx0b3V0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG91dDtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGRlY29kZVVURjgoc3RyaW5nKSB7XHJcblx0XHRyZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZShzdHJpbmcpKTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGdldFN0cmluZyhieXRlcykge1xyXG5cdFx0dmFyIGksIHN0ciA9IFwiXCI7XHJcblx0XHRmb3IgKGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspXHJcblx0XHRcdHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldKTtcclxuXHRcdHJldHVybiBzdHI7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBnZXREYXRlKHRpbWVSYXcpIHtcclxuXHRcdHZhciBkYXRlID0gKHRpbWVSYXcgJiAweGZmZmYwMDAwKSA+PiAxNiwgdGltZSA9IHRpbWVSYXcgJiAweDAwMDBmZmZmO1xyXG5cdFx0dHJ5IHtcclxuXHRcdFx0cmV0dXJuIG5ldyBEYXRlKDE5ODAgKyAoKGRhdGUgJiAweEZFMDApID4+IDkpLCAoKGRhdGUgJiAweDAxRTApID4+IDUpIC0gMSwgZGF0ZSAmIDB4MDAxRiwgKHRpbWUgJiAweEY4MDApID4+IDExLCAodGltZSAmIDB4MDdFMCkgPj4gNSxcclxuXHRcdFx0XHRcdCh0aW1lICYgMHgwMDFGKSAqIDIsIDApO1xyXG5cdFx0fSBjYXRjaCAoZSkge1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gcmVhZENvbW1vbkhlYWRlcihlbnRyeSwgZGF0YSwgaW5kZXgsIGNlbnRyYWxEaXJlY3RvcnksIG9uZXJyb3IpIHtcclxuXHRcdGVudHJ5LnZlcnNpb24gPSBkYXRhLnZpZXcuZ2V0VWludDE2KGluZGV4LCB0cnVlKTtcclxuXHRcdGVudHJ5LmJpdEZsYWcgPSBkYXRhLnZpZXcuZ2V0VWludDE2KGluZGV4ICsgMiwgdHJ1ZSk7XHJcblx0XHRlbnRyeS5jb21wcmVzc2lvbk1ldGhvZCA9IGRhdGEudmlldy5nZXRVaW50MTYoaW5kZXggKyA0LCB0cnVlKTtcclxuXHRcdGVudHJ5Lmxhc3RNb2REYXRlUmF3ID0gZGF0YS52aWV3LmdldFVpbnQzMihpbmRleCArIDYsIHRydWUpO1xyXG5cdFx0ZW50cnkubGFzdE1vZERhdGUgPSBnZXREYXRlKGVudHJ5Lmxhc3RNb2REYXRlUmF3KTtcclxuXHRcdGlmICgoZW50cnkuYml0RmxhZyAmIDB4MDEpID09PSAweDAxKSB7XHJcblx0XHRcdG9uZXJyb3IoRVJSX0VOQ1JZUFRFRCk7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHRcdGlmIChjZW50cmFsRGlyZWN0b3J5IHx8IChlbnRyeS5iaXRGbGFnICYgMHgwMDA4KSAhPSAweDAwMDgpIHtcclxuXHRcdFx0ZW50cnkuY3JjMzIgPSBkYXRhLnZpZXcuZ2V0VWludDMyKGluZGV4ICsgMTAsIHRydWUpO1xyXG5cdFx0XHRlbnRyeS5jb21wcmVzc2VkU2l6ZSA9IGRhdGEudmlldy5nZXRVaW50MzIoaW5kZXggKyAxNCwgdHJ1ZSk7XHJcblx0XHRcdGVudHJ5LnVuY29tcHJlc3NlZFNpemUgPSBkYXRhLnZpZXcuZ2V0VWludDMyKGluZGV4ICsgMTgsIHRydWUpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGVudHJ5LmNvbXByZXNzZWRTaXplID09PSAweEZGRkZGRkZGIHx8IGVudHJ5LnVuY29tcHJlc3NlZFNpemUgPT09IDB4RkZGRkZGRkYpIHtcclxuXHRcdFx0b25lcnJvcihFUlJfWklQNjQpO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblx0XHRlbnRyeS5maWxlbmFtZUxlbmd0aCA9IGRhdGEudmlldy5nZXRVaW50MTYoaW5kZXggKyAyMiwgdHJ1ZSk7XHJcblx0XHRlbnRyeS5leHRyYUZpZWxkTGVuZ3RoID0gZGF0YS52aWV3LmdldFVpbnQxNihpbmRleCArIDI0LCB0cnVlKTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGNyZWF0ZVppcFJlYWRlcihyZWFkZXIsIGNhbGxiYWNrLCBvbmVycm9yKSB7XHJcblx0XHR2YXIgaW5mbGF0ZVNOID0gMDtcclxuXHJcblx0XHRmdW5jdGlvbiBFbnRyeSgpIHtcclxuXHRcdH1cclxuXHJcblx0XHRFbnRyeS5wcm90b3R5cGUuZ2V0RGF0YSA9IGZ1bmN0aW9uKHdyaXRlciwgb25lbmQsIG9ucHJvZ3Jlc3MsIGNoZWNrQ3JjMzIpIHtcclxuXHRcdFx0dmFyIHRoYXQgPSB0aGlzO1xyXG5cclxuXHRcdFx0ZnVuY3Rpb24gdGVzdENyYzMyKGNyYzMyKSB7XHJcblx0XHRcdFx0dmFyIGRhdGFDcmMzMiA9IGdldERhdGFIZWxwZXIoNCk7XHJcblx0XHRcdFx0ZGF0YUNyYzMyLnZpZXcuc2V0VWludDMyKDAsIGNyYzMyKTtcclxuXHRcdFx0XHRyZXR1cm4gdGhhdC5jcmMzMiA9PSBkYXRhQ3JjMzIudmlldy5nZXRVaW50MzIoMCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZ1bmN0aW9uIGdldFdyaXRlckRhdGEodW5jb21wcmVzc2VkU2l6ZSwgY3JjMzIpIHtcclxuXHRcdFx0XHRpZiAoY2hlY2tDcmMzMiAmJiAhdGVzdENyYzMyKGNyYzMyKSlcclxuXHRcdFx0XHRcdG9uZXJyb3IoRVJSX0NSQyk7XHJcblx0XHRcdFx0ZWxzZVxyXG5cdFx0XHRcdFx0d3JpdGVyLmdldERhdGEoZnVuY3Rpb24oZGF0YSkge1xyXG5cdFx0XHRcdFx0XHRvbmVuZChkYXRhKTtcclxuXHRcdFx0XHRcdH0pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmdW5jdGlvbiBvbnJlYWRlcnJvcihlcnIpIHtcclxuXHRcdFx0XHRvbmVycm9yKGVyciB8fCBFUlJfUkVBRF9EQVRBKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0ZnVuY3Rpb24gb253cml0ZWVycm9yKGVycikge1xyXG5cdFx0XHRcdG9uZXJyb3IoZXJyIHx8IEVSUl9XUklURV9EQVRBKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmVhZGVyLnJlYWRVaW50OEFycmF5KHRoYXQub2Zmc2V0LCAzMCwgZnVuY3Rpb24oYnl0ZXMpIHtcclxuXHRcdFx0XHR2YXIgZGF0YSA9IGdldERhdGFIZWxwZXIoYnl0ZXMubGVuZ3RoLCBieXRlcyksIGRhdGFPZmZzZXQ7XHJcblx0XHRcdFx0aWYgKGRhdGEudmlldy5nZXRVaW50MzIoMCkgIT0gMHg1MDRiMDMwNCkge1xyXG5cdFx0XHRcdFx0b25lcnJvcihFUlJfQkFEX0ZPUk1BVCk7XHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJlYWRDb21tb25IZWFkZXIodGhhdCwgZGF0YSwgNCwgZmFsc2UsIG9uZXJyb3IpO1xyXG5cdFx0XHRcdGRhdGFPZmZzZXQgPSB0aGF0Lm9mZnNldCArIDMwICsgdGhhdC5maWxlbmFtZUxlbmd0aCArIHRoYXQuZXh0cmFGaWVsZExlbmd0aDtcclxuXHRcdFx0XHR3cml0ZXIuaW5pdChmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdGlmICh0aGF0LmNvbXByZXNzaW9uTWV0aG9kID09PSAwKVxyXG5cdFx0XHRcdFx0XHRjb3B5KHRoYXQuX3dvcmtlciwgaW5mbGF0ZVNOKyssIHJlYWRlciwgd3JpdGVyLCBkYXRhT2Zmc2V0LCB0aGF0LmNvbXByZXNzZWRTaXplLCBjaGVja0NyYzMyLCBnZXRXcml0ZXJEYXRhLCBvbnByb2dyZXNzLCBvbnJlYWRlcnJvciwgb253cml0ZWVycm9yKTtcclxuXHRcdFx0XHRcdGVsc2VcclxuXHRcdFx0XHRcdFx0aW5mbGF0ZSh0aGF0Ll93b3JrZXIsIGluZmxhdGVTTisrLCByZWFkZXIsIHdyaXRlciwgZGF0YU9mZnNldCwgdGhhdC5jb21wcmVzc2VkU2l6ZSwgY2hlY2tDcmMzMiwgZ2V0V3JpdGVyRGF0YSwgb25wcm9ncmVzcywgb25yZWFkZXJyb3IsIG9ud3JpdGVlcnJvcik7XHJcblx0XHRcdFx0fSwgb253cml0ZWVycm9yKTtcclxuXHRcdFx0fSwgb25yZWFkZXJyb3IpO1xyXG5cdFx0fTtcclxuXHJcblx0XHRmdW5jdGlvbiBzZWVrRU9DRFIoZW9jZHJDYWxsYmFjaykge1xyXG5cdFx0XHQvLyBcIkVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeSByZWNvcmRcIiBpcyB0aGUgbGFzdCBwYXJ0IG9mIGEgemlwIGFyY2hpdmUsIGFuZCBpcyBhdCBsZWFzdCAyMiBieXRlcyBsb25nLlxyXG5cdFx0XHQvLyBaaXAgZmlsZSBjb21tZW50IGlzIHRoZSBsYXN0IHBhcnQgb2YgRU9DRFIgYW5kIGhhcyBtYXggbGVuZ3RoIG9mIDY0S0IsXHJcblx0XHRcdC8vIHNvIHdlIG9ubHkgaGF2ZSB0byBzZWFyY2ggdGhlIGxhc3QgNjRLICsgMjIgYnl0ZXMgb2YgYSBhcmNoaXZlIGZvciBFT0NEUiBzaWduYXR1cmUgKDB4MDYwNTRiNTApLlxyXG5cdFx0XHR2YXIgRU9DRFJfTUlOID0gMjI7XHJcblx0XHRcdGlmIChyZWFkZXIuc2l6ZSA8IEVPQ0RSX01JTikge1xyXG5cdFx0XHRcdG9uZXJyb3IoRVJSX0JBRF9GT1JNQVQpO1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cdFx0XHR2YXIgWklQX0NPTU1FTlRfTUFYID0gMjU2ICogMjU2LCBFT0NEUl9NQVggPSBFT0NEUl9NSU4gKyBaSVBfQ09NTUVOVF9NQVg7XHJcblxyXG5cdFx0XHQvLyBJbiBtb3N0IGNhc2VzLCB0aGUgRU9DRFIgaXMgRU9DRFJfTUlOIGJ5dGVzIGxvbmdcclxuXHRcdFx0ZG9TZWVrKEVPQ0RSX01JTiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0Ly8gSWYgbm90IGZvdW5kLCB0cnkgd2l0aGluIEVPQ0RSX01BWCBieXRlc1xyXG5cdFx0XHRcdGRvU2VlayhNYXRoLm1pbihFT0NEUl9NQVgsIHJlYWRlci5zaXplKSwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHRvbmVycm9yKEVSUl9CQURfRk9STUFUKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHQvLyBzZWVrIGxhc3QgbGVuZ3RoIGJ5dGVzIG9mIGZpbGUgZm9yIEVPQ0RSXHJcblx0XHRcdGZ1bmN0aW9uIGRvU2VlayhsZW5ndGgsIGVvY2RyTm90Rm91bmRDYWxsYmFjaykge1xyXG5cdFx0XHRcdHJlYWRlci5yZWFkVWludDhBcnJheShyZWFkZXIuc2l6ZSAtIGxlbmd0aCwgbGVuZ3RoLCBmdW5jdGlvbihieXRlcykge1xyXG5cdFx0XHRcdFx0Zm9yICh2YXIgaSA9IGJ5dGVzLmxlbmd0aCAtIEVPQ0RSX01JTjsgaSA+PSAwOyBpLS0pIHtcclxuXHRcdFx0XHRcdFx0aWYgKGJ5dGVzW2ldID09PSAweDUwICYmIGJ5dGVzW2kgKyAxXSA9PT0gMHg0YiAmJiBieXRlc1tpICsgMl0gPT09IDB4MDUgJiYgYnl0ZXNbaSArIDNdID09PSAweDA2KSB7XHJcblx0XHRcdFx0XHRcdFx0ZW9jZHJDYWxsYmFjayhuZXcgRGF0YVZpZXcoYnl0ZXMuYnVmZmVyLCBpLCBFT0NEUl9NSU4pKTtcclxuXHRcdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGVvY2RyTm90Rm91bmRDYWxsYmFjaygpO1xyXG5cdFx0XHRcdH0sIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0b25lcnJvcihFUlJfUkVBRCk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgemlwUmVhZGVyID0ge1xyXG5cdFx0XHRnZXRFbnRyaWVzIDogZnVuY3Rpb24oY2FsbGJhY2spIHtcclxuXHRcdFx0XHR2YXIgd29ya2VyID0gdGhpcy5fd29ya2VyO1xyXG5cdFx0XHRcdC8vIGxvb2sgZm9yIEVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeSByZWNvcmRcclxuXHRcdFx0XHRzZWVrRU9DRFIoZnVuY3Rpb24oZGF0YVZpZXcpIHtcclxuXHRcdFx0XHRcdHZhciBkYXRhbGVuZ3RoLCBmaWxlc2xlbmd0aDtcclxuXHRcdFx0XHRcdGRhdGFsZW5ndGggPSBkYXRhVmlldy5nZXRVaW50MzIoMTYsIHRydWUpO1xyXG5cdFx0XHRcdFx0ZmlsZXNsZW5ndGggPSBkYXRhVmlldy5nZXRVaW50MTYoOCwgdHJ1ZSk7XHJcblx0XHRcdFx0XHRpZiAoZGF0YWxlbmd0aCA8IDAgfHwgZGF0YWxlbmd0aCA+PSByZWFkZXIuc2l6ZSkge1xyXG5cdFx0XHRcdFx0XHRvbmVycm9yKEVSUl9CQURfRk9STUFUKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0cmVhZGVyLnJlYWRVaW50OEFycmF5KGRhdGFsZW5ndGgsIHJlYWRlci5zaXplIC0gZGF0YWxlbmd0aCwgZnVuY3Rpb24oYnl0ZXMpIHtcclxuXHRcdFx0XHRcdFx0dmFyIGksIGluZGV4ID0gMCwgZW50cmllcyA9IFtdLCBlbnRyeSwgZmlsZW5hbWUsIGNvbW1lbnQsIGRhdGEgPSBnZXREYXRhSGVscGVyKGJ5dGVzLmxlbmd0aCwgYnl0ZXMpO1xyXG5cdFx0XHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgZmlsZXNsZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0XHRcdGVudHJ5ID0gbmV3IEVudHJ5KCk7XHJcblx0XHRcdFx0XHRcdFx0ZW50cnkuX3dvcmtlciA9IHdvcmtlcjtcclxuXHRcdFx0XHRcdFx0XHRpZiAoZGF0YS52aWV3LmdldFVpbnQzMihpbmRleCkgIT0gMHg1MDRiMDEwMikge1xyXG5cdFx0XHRcdFx0XHRcdFx0b25lcnJvcihFUlJfQkFEX0ZPUk1BVCk7XHJcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdHJlYWRDb21tb25IZWFkZXIoZW50cnksIGRhdGEsIGluZGV4ICsgNiwgdHJ1ZSwgb25lcnJvcik7XHJcblx0XHRcdFx0XHRcdFx0ZW50cnkuY29tbWVudExlbmd0aCA9IGRhdGEudmlldy5nZXRVaW50MTYoaW5kZXggKyAzMiwgdHJ1ZSk7XHJcblx0XHRcdFx0XHRcdFx0ZW50cnkuZGlyZWN0b3J5ID0gKChkYXRhLnZpZXcuZ2V0VWludDgoaW5kZXggKyAzOCkgJiAweDEwKSA9PSAweDEwKTtcclxuXHRcdFx0XHRcdFx0XHRlbnRyeS5vZmZzZXQgPSBkYXRhLnZpZXcuZ2V0VWludDMyKGluZGV4ICsgNDIsIHRydWUpO1xyXG5cdFx0XHRcdFx0XHRcdGZpbGVuYW1lID0gZ2V0U3RyaW5nKGRhdGEuYXJyYXkuc3ViYXJyYXkoaW5kZXggKyA0NiwgaW5kZXggKyA0NiArIGVudHJ5LmZpbGVuYW1lTGVuZ3RoKSk7XHJcblx0XHRcdFx0XHRcdFx0ZW50cnkuZmlsZW5hbWUgPSAoKGVudHJ5LmJpdEZsYWcgJiAweDA4MDApID09PSAweDA4MDApID8gZGVjb2RlVVRGOChmaWxlbmFtZSkgOiBkZWNvZGVBU0NJSShmaWxlbmFtZSk7XHJcblx0XHRcdFx0XHRcdFx0aWYgKCFlbnRyeS5kaXJlY3RvcnkgJiYgZW50cnkuZmlsZW5hbWUuY2hhckF0KGVudHJ5LmZpbGVuYW1lLmxlbmd0aCAtIDEpID09IFwiL1wiKVxyXG5cdFx0XHRcdFx0XHRcdFx0ZW50cnkuZGlyZWN0b3J5ID0gdHJ1ZTtcclxuXHRcdFx0XHRcdFx0XHRjb21tZW50ID0gZ2V0U3RyaW5nKGRhdGEuYXJyYXkuc3ViYXJyYXkoaW5kZXggKyA0NiArIGVudHJ5LmZpbGVuYW1lTGVuZ3RoICsgZW50cnkuZXh0cmFGaWVsZExlbmd0aCwgaW5kZXggKyA0NlxyXG5cdFx0XHRcdFx0XHRcdFx0XHQrIGVudHJ5LmZpbGVuYW1lTGVuZ3RoICsgZW50cnkuZXh0cmFGaWVsZExlbmd0aCArIGVudHJ5LmNvbW1lbnRMZW5ndGgpKTtcclxuXHRcdFx0XHRcdFx0XHRlbnRyeS5jb21tZW50ID0gKChlbnRyeS5iaXRGbGFnICYgMHgwODAwKSA9PT0gMHgwODAwKSA/IGRlY29kZVVURjgoY29tbWVudCkgOiBkZWNvZGVBU0NJSShjb21tZW50KTtcclxuXHRcdFx0XHRcdFx0XHRlbnRyaWVzLnB1c2goZW50cnkpO1xyXG5cdFx0XHRcdFx0XHRcdGluZGV4ICs9IDQ2ICsgZW50cnkuZmlsZW5hbWVMZW5ndGggKyBlbnRyeS5leHRyYUZpZWxkTGVuZ3RoICsgZW50cnkuY29tbWVudExlbmd0aDtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRjYWxsYmFjayhlbnRyaWVzKTtcclxuXHRcdFx0XHRcdH0sIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0XHRvbmVycm9yKEVSUl9SRUFEKTtcclxuXHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRjbG9zZSA6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XHJcblx0XHRcdFx0aWYgKHRoaXMuX3dvcmtlcikge1xyXG5cdFx0XHRcdFx0dGhpcy5fd29ya2VyLnRlcm1pbmF0ZSgpO1xyXG5cdFx0XHRcdFx0dGhpcy5fd29ya2VyID0gbnVsbDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKGNhbGxiYWNrKVxyXG5cdFx0XHRcdFx0Y2FsbGJhY2soKTtcclxuXHRcdFx0fSxcclxuXHRcdFx0X3dvcmtlcjogbnVsbFxyXG5cdFx0fTtcclxuXHJcblx0XHRpZiAoIW9iai56aXAudXNlV2ViV29ya2VycylcclxuXHRcdFx0Y2FsbGJhY2soemlwUmVhZGVyKTtcclxuXHRcdGVsc2Uge1xyXG5cdFx0XHRjcmVhdGVXb3JrZXIoJ2luZmxhdGVyJyxcclxuXHRcdFx0XHRmdW5jdGlvbih3b3JrZXIpIHtcclxuXHRcdFx0XHRcdHppcFJlYWRlci5fd29ya2VyID0gd29ya2VyO1xyXG5cdFx0XHRcdFx0Y2FsbGJhY2soemlwUmVhZGVyKTtcclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdGZ1bmN0aW9uKGVycikge1xyXG5cdFx0XHRcdFx0b25lcnJvcihlcnIpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0KTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8vIFppcFdyaXRlclxyXG5cclxuXHRmdW5jdGlvbiBlbmNvZGVVVEY4KHN0cmluZykge1xyXG5cdFx0cmV0dXJuIHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmcpKTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGdldEJ5dGVzKHN0cikge1xyXG5cdFx0dmFyIGksIGFycmF5ID0gW107XHJcblx0XHRmb3IgKGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKVxyXG5cdFx0XHRhcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpKTtcclxuXHRcdHJldHVybiBhcnJheTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGNyZWF0ZVppcFdyaXRlcih3cml0ZXIsIGNhbGxiYWNrLCBvbmVycm9yLCBkb250RGVmbGF0ZSkge1xyXG5cdFx0dmFyIGZpbGVzID0ge30sIGZpbGVuYW1lcyA9IFtdLCBkYXRhbGVuZ3RoID0gMDtcclxuXHRcdHZhciBkZWZsYXRlU04gPSAwO1xyXG5cclxuXHRcdGZ1bmN0aW9uIG9ud3JpdGVlcnJvcihlcnIpIHtcclxuXHRcdFx0b25lcnJvcihlcnIgfHwgRVJSX1dSSVRFKTtcclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBvbnJlYWRlcnJvcihlcnIpIHtcclxuXHRcdFx0b25lcnJvcihlcnIgfHwgRVJSX1JFQURfREFUQSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHppcFdyaXRlciA9IHtcclxuXHRcdFx0YWRkIDogZnVuY3Rpb24obmFtZSwgcmVhZGVyLCBvbmVuZCwgb25wcm9ncmVzcywgb3B0aW9ucykge1xyXG5cdFx0XHRcdHZhciBoZWFkZXIsIGZpbGVuYW1lLCBkYXRlO1xyXG5cdFx0XHRcdHZhciB3b3JrZXIgPSB0aGlzLl93b3JrZXI7XHJcblxyXG5cdFx0XHRcdGZ1bmN0aW9uIHdyaXRlSGVhZGVyKGNhbGxiYWNrKSB7XHJcblx0XHRcdFx0XHR2YXIgZGF0YTtcclxuXHRcdFx0XHRcdGRhdGUgPSBvcHRpb25zLmxhc3RNb2REYXRlIHx8IG5ldyBEYXRlKCk7XHJcblx0XHRcdFx0XHRoZWFkZXIgPSBnZXREYXRhSGVscGVyKDI2KTtcclxuXHRcdFx0XHRcdGZpbGVzW25hbWVdID0ge1xyXG5cdFx0XHRcdFx0XHRoZWFkZXJBcnJheSA6IGhlYWRlci5hcnJheSxcclxuXHRcdFx0XHRcdFx0ZGlyZWN0b3J5IDogb3B0aW9ucy5kaXJlY3RvcnksXHJcblx0XHRcdFx0XHRcdGZpbGVuYW1lIDogZmlsZW5hbWUsXHJcblx0XHRcdFx0XHRcdG9mZnNldCA6IGRhdGFsZW5ndGgsXHJcblx0XHRcdFx0XHRcdGNvbW1lbnQgOiBnZXRCeXRlcyhlbmNvZGVVVEY4KG9wdGlvbnMuY29tbWVudCB8fCBcIlwiKSlcclxuXHRcdFx0XHRcdH07XHJcblx0XHRcdFx0XHRoZWFkZXIudmlldy5zZXRVaW50MzIoMCwgMHgxNDAwMDgwOCk7XHJcblx0XHRcdFx0XHRpZiAob3B0aW9ucy52ZXJzaW9uKVxyXG5cdFx0XHRcdFx0XHRoZWFkZXIudmlldy5zZXRVaW50OCgwLCBvcHRpb25zLnZlcnNpb24pO1xyXG5cdFx0XHRcdFx0aWYgKCFkb250RGVmbGF0ZSAmJiBvcHRpb25zLmxldmVsICE9PSAwICYmICFvcHRpb25zLmRpcmVjdG9yeSlcclxuXHRcdFx0XHRcdFx0aGVhZGVyLnZpZXcuc2V0VWludDE2KDQsIDB4MDgwMCk7XHJcblx0XHRcdFx0XHRoZWFkZXIudmlldy5zZXRVaW50MTYoNiwgKCgoZGF0ZS5nZXRIb3VycygpIDw8IDYpIHwgZGF0ZS5nZXRNaW51dGVzKCkpIDw8IDUpIHwgZGF0ZS5nZXRTZWNvbmRzKCkgLyAyLCB0cnVlKTtcclxuXHRcdFx0XHRcdGhlYWRlci52aWV3LnNldFVpbnQxNig4LCAoKCgoZGF0ZS5nZXRGdWxsWWVhcigpIC0gMTk4MCkgPDwgNCkgfCAoZGF0ZS5nZXRNb250aCgpICsgMSkpIDw8IDUpIHwgZGF0ZS5nZXREYXRlKCksIHRydWUpO1xyXG5cdFx0XHRcdFx0aGVhZGVyLnZpZXcuc2V0VWludDE2KDIyLCBmaWxlbmFtZS5sZW5ndGgsIHRydWUpO1xyXG5cdFx0XHRcdFx0ZGF0YSA9IGdldERhdGFIZWxwZXIoMzAgKyBmaWxlbmFtZS5sZW5ndGgpO1xyXG5cdFx0XHRcdFx0ZGF0YS52aWV3LnNldFVpbnQzMigwLCAweDUwNGIwMzA0KTtcclxuXHRcdFx0XHRcdGRhdGEuYXJyYXkuc2V0KGhlYWRlci5hcnJheSwgNCk7XHJcblx0XHRcdFx0XHRkYXRhLmFycmF5LnNldChmaWxlbmFtZSwgMzApO1xyXG5cdFx0XHRcdFx0ZGF0YWxlbmd0aCArPSBkYXRhLmFycmF5Lmxlbmd0aDtcclxuXHRcdFx0XHRcdHdyaXRlci53cml0ZVVpbnQ4QXJyYXkoZGF0YS5hcnJheSwgY2FsbGJhY2ssIG9ud3JpdGVlcnJvcik7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRmdW5jdGlvbiB3cml0ZUZvb3Rlcihjb21wcmVzc2VkTGVuZ3RoLCBjcmMzMikge1xyXG5cdFx0XHRcdFx0dmFyIGZvb3RlciA9IGdldERhdGFIZWxwZXIoMTYpO1xyXG5cdFx0XHRcdFx0ZGF0YWxlbmd0aCArPSBjb21wcmVzc2VkTGVuZ3RoIHx8IDA7XHJcblx0XHRcdFx0XHRmb290ZXIudmlldy5zZXRVaW50MzIoMCwgMHg1MDRiMDcwOCk7XHJcblx0XHRcdFx0XHRpZiAodHlwZW9mIGNyYzMyICE9IFwidW5kZWZpbmVkXCIpIHtcclxuXHRcdFx0XHRcdFx0aGVhZGVyLnZpZXcuc2V0VWludDMyKDEwLCBjcmMzMiwgdHJ1ZSk7XHJcblx0XHRcdFx0XHRcdGZvb3Rlci52aWV3LnNldFVpbnQzMig0LCBjcmMzMiwgdHJ1ZSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZiAocmVhZGVyKSB7XHJcblx0XHRcdFx0XHRcdGZvb3Rlci52aWV3LnNldFVpbnQzMig4LCBjb21wcmVzc2VkTGVuZ3RoLCB0cnVlKTtcclxuXHRcdFx0XHRcdFx0aGVhZGVyLnZpZXcuc2V0VWludDMyKDE0LCBjb21wcmVzc2VkTGVuZ3RoLCB0cnVlKTtcclxuXHRcdFx0XHRcdFx0Zm9vdGVyLnZpZXcuc2V0VWludDMyKDEyLCByZWFkZXIuc2l6ZSwgdHJ1ZSk7XHJcblx0XHRcdFx0XHRcdGhlYWRlci52aWV3LnNldFVpbnQzMigxOCwgcmVhZGVyLnNpemUsIHRydWUpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0d3JpdGVyLndyaXRlVWludDhBcnJheShmb290ZXIuYXJyYXksIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0XHRkYXRhbGVuZ3RoICs9IDE2O1xyXG5cdFx0XHRcdFx0XHRvbmVuZCgpO1xyXG5cdFx0XHRcdFx0fSwgb253cml0ZWVycm9yKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGZ1bmN0aW9uIHdyaXRlRmlsZSgpIHtcclxuXHRcdFx0XHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cdFx0XHRcdFx0bmFtZSA9IG5hbWUudHJpbSgpO1xyXG5cdFx0XHRcdFx0aWYgKG9wdGlvbnMuZGlyZWN0b3J5ICYmIG5hbWUuY2hhckF0KG5hbWUubGVuZ3RoIC0gMSkgIT0gXCIvXCIpXHJcblx0XHRcdFx0XHRcdG5hbWUgKz0gXCIvXCI7XHJcblx0XHRcdFx0XHRpZiAoZmlsZXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcclxuXHRcdFx0XHRcdFx0b25lcnJvcihFUlJfRFVQTElDQVRFRF9OQU1FKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0ZmlsZW5hbWUgPSBnZXRCeXRlcyhlbmNvZGVVVEY4KG5hbWUpKTtcclxuXHRcdFx0XHRcdGZpbGVuYW1lcy5wdXNoKG5hbWUpO1xyXG5cdFx0XHRcdFx0d3JpdGVIZWFkZXIoZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHRcdGlmIChyZWFkZXIpXHJcblx0XHRcdFx0XHRcdFx0aWYgKGRvbnREZWZsYXRlIHx8IG9wdGlvbnMubGV2ZWwgPT09IDApXHJcblx0XHRcdFx0XHRcdFx0XHRjb3B5KHdvcmtlciwgZGVmbGF0ZVNOKyssIHJlYWRlciwgd3JpdGVyLCAwLCByZWFkZXIuc2l6ZSwgdHJ1ZSwgd3JpdGVGb290ZXIsIG9ucHJvZ3Jlc3MsIG9ucmVhZGVycm9yLCBvbndyaXRlZXJyb3IpO1xyXG5cdFx0XHRcdFx0XHRcdGVsc2VcclxuXHRcdFx0XHRcdFx0XHRcdGRlZmxhdGUod29ya2VyLCBkZWZsYXRlU04rKywgcmVhZGVyLCB3cml0ZXIsIG9wdGlvbnMubGV2ZWwsIHdyaXRlRm9vdGVyLCBvbnByb2dyZXNzLCBvbnJlYWRlcnJvciwgb253cml0ZWVycm9yKTtcclxuXHRcdFx0XHRcdFx0ZWxzZVxyXG5cdFx0XHRcdFx0XHRcdHdyaXRlRm9vdGVyKCk7XHJcblx0XHRcdFx0XHR9LCBvbndyaXRlZXJyb3IpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKHJlYWRlcilcclxuXHRcdFx0XHRcdHJlYWRlci5pbml0KHdyaXRlRmlsZSwgb25yZWFkZXJyb3IpO1xyXG5cdFx0XHRcdGVsc2VcclxuXHRcdFx0XHRcdHdyaXRlRmlsZSgpO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRjbG9zZSA6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XHJcblx0XHRcdFx0aWYgKHRoaXMuX3dvcmtlcikge1xyXG5cdFx0XHRcdFx0dGhpcy5fd29ya2VyLnRlcm1pbmF0ZSgpO1xyXG5cdFx0XHRcdFx0dGhpcy5fd29ya2VyID0gbnVsbDtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHZhciBkYXRhLCBsZW5ndGggPSAwLCBpbmRleCA9IDAsIGluZGV4RmlsZW5hbWUsIGZpbGU7XHJcblx0XHRcdFx0Zm9yIChpbmRleEZpbGVuYW1lID0gMDsgaW5kZXhGaWxlbmFtZSA8IGZpbGVuYW1lcy5sZW5ndGg7IGluZGV4RmlsZW5hbWUrKykge1xyXG5cdFx0XHRcdFx0ZmlsZSA9IGZpbGVzW2ZpbGVuYW1lc1tpbmRleEZpbGVuYW1lXV07XHJcblx0XHRcdFx0XHRsZW5ndGggKz0gNDYgKyBmaWxlLmZpbGVuYW1lLmxlbmd0aCArIGZpbGUuY29tbWVudC5sZW5ndGg7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGRhdGEgPSBnZXREYXRhSGVscGVyKGxlbmd0aCArIDIyKTtcclxuXHRcdFx0XHRmb3IgKGluZGV4RmlsZW5hbWUgPSAwOyBpbmRleEZpbGVuYW1lIDwgZmlsZW5hbWVzLmxlbmd0aDsgaW5kZXhGaWxlbmFtZSsrKSB7XHJcblx0XHRcdFx0XHRmaWxlID0gZmlsZXNbZmlsZW5hbWVzW2luZGV4RmlsZW5hbWVdXTtcclxuXHRcdFx0XHRcdGRhdGEudmlldy5zZXRVaW50MzIoaW5kZXgsIDB4NTA0YjAxMDIpO1xyXG5cdFx0XHRcdFx0ZGF0YS52aWV3LnNldFVpbnQxNihpbmRleCArIDQsIDB4MTQwMCk7XHJcblx0XHRcdFx0XHRkYXRhLmFycmF5LnNldChmaWxlLmhlYWRlckFycmF5LCBpbmRleCArIDYpO1xyXG5cdFx0XHRcdFx0ZGF0YS52aWV3LnNldFVpbnQxNihpbmRleCArIDMyLCBmaWxlLmNvbW1lbnQubGVuZ3RoLCB0cnVlKTtcclxuXHRcdFx0XHRcdGlmIChmaWxlLmRpcmVjdG9yeSlcclxuXHRcdFx0XHRcdFx0ZGF0YS52aWV3LnNldFVpbnQ4KGluZGV4ICsgMzgsIDB4MTApO1xyXG5cdFx0XHRcdFx0ZGF0YS52aWV3LnNldFVpbnQzMihpbmRleCArIDQyLCBmaWxlLm9mZnNldCwgdHJ1ZSk7XHJcblx0XHRcdFx0XHRkYXRhLmFycmF5LnNldChmaWxlLmZpbGVuYW1lLCBpbmRleCArIDQ2KTtcclxuXHRcdFx0XHRcdGRhdGEuYXJyYXkuc2V0KGZpbGUuY29tbWVudCwgaW5kZXggKyA0NiArIGZpbGUuZmlsZW5hbWUubGVuZ3RoKTtcclxuXHRcdFx0XHRcdGluZGV4ICs9IDQ2ICsgZmlsZS5maWxlbmFtZS5sZW5ndGggKyBmaWxlLmNvbW1lbnQubGVuZ3RoO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRkYXRhLnZpZXcuc2V0VWludDMyKGluZGV4LCAweDUwNGIwNTA2KTtcclxuXHRcdFx0XHRkYXRhLnZpZXcuc2V0VWludDE2KGluZGV4ICsgOCwgZmlsZW5hbWVzLmxlbmd0aCwgdHJ1ZSk7XHJcblx0XHRcdFx0ZGF0YS52aWV3LnNldFVpbnQxNihpbmRleCArIDEwLCBmaWxlbmFtZXMubGVuZ3RoLCB0cnVlKTtcclxuXHRcdFx0XHRkYXRhLnZpZXcuc2V0VWludDMyKGluZGV4ICsgMTIsIGxlbmd0aCwgdHJ1ZSk7XHJcblx0XHRcdFx0ZGF0YS52aWV3LnNldFVpbnQzMihpbmRleCArIDE2LCBkYXRhbGVuZ3RoLCB0cnVlKTtcclxuXHRcdFx0XHR3cml0ZXIud3JpdGVVaW50OEFycmF5KGRhdGEuYXJyYXksIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0d3JpdGVyLmdldERhdGEoY2FsbGJhY2spO1xyXG5cdFx0XHRcdH0sIG9ud3JpdGVlcnJvcik7XHJcblx0XHRcdH0sXHJcblx0XHRcdF93b3JrZXI6IG51bGxcclxuXHRcdH07XHJcblxyXG5cdFx0aWYgKCFvYmouemlwLnVzZVdlYldvcmtlcnMpXHJcblx0XHRcdGNhbGxiYWNrKHppcFdyaXRlcik7XHJcblx0XHRlbHNlIHtcclxuXHRcdFx0Y3JlYXRlV29ya2VyKCdkZWZsYXRlcicsXHJcblx0XHRcdFx0ZnVuY3Rpb24od29ya2VyKSB7XHJcblx0XHRcdFx0XHR6aXBXcml0ZXIuX3dvcmtlciA9IHdvcmtlcjtcclxuXHRcdFx0XHRcdGNhbGxiYWNrKHppcFdyaXRlcik7XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRmdW5jdGlvbihlcnIpIHtcclxuXHRcdFx0XHRcdG9uZXJyb3IoZXJyKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdCk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiByZXNvbHZlVVJMcyh1cmxzKSB7XHJcblx0XHR2YXIgYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcclxuXHRcdHJldHVybiB1cmxzLm1hcChmdW5jdGlvbih1cmwpIHtcclxuXHRcdFx0YS5ocmVmID0gdXJsO1xyXG5cdFx0XHRyZXR1cm4gYS5ocmVmO1xyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxuXHR2YXIgREVGQVVMVF9XT1JLRVJfU0NSSVBUUyA9IHtcclxuXHRcdGRlZmxhdGVyOiBbJ3otd29ya2VyLmpzJywgJ2RlZmxhdGUuanMnXSxcclxuXHRcdGluZmxhdGVyOiBbJ3otd29ya2VyLmpzJywgJ2luZmxhdGUuanMnXVxyXG5cdH07XHJcblx0ZnVuY3Rpb24gY3JlYXRlV29ya2VyKHR5cGUsIGNhbGxiYWNrLCBvbmVycm9yKSB7XHJcblx0XHRpZiAob2JqLnppcC53b3JrZXJTY3JpcHRzICE9PSBudWxsICYmIG9iai56aXAud29ya2VyU2NyaXB0c1BhdGggIT09IG51bGwpIHtcclxuXHRcdFx0b25lcnJvcihuZXcgRXJyb3IoJ0VpdGhlciB6aXAud29ya2VyU2NyaXB0cyBvciB6aXAud29ya2VyU2NyaXB0c1BhdGggbWF5IGJlIHNldCwgbm90IGJvdGguJykpO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblx0XHR2YXIgc2NyaXB0cztcclxuXHRcdGlmIChvYmouemlwLndvcmtlclNjcmlwdHMpIHtcclxuXHRcdFx0c2NyaXB0cyA9IG9iai56aXAud29ya2VyU2NyaXB0c1t0eXBlXTtcclxuXHRcdFx0aWYgKCFBcnJheS5pc0FycmF5KHNjcmlwdHMpKSB7XHJcblx0XHRcdFx0b25lcnJvcihuZXcgRXJyb3IoJ3ppcC53b3JrZXJTY3JpcHRzLicgKyB0eXBlICsgJyBpcyBub3QgYW4gYXJyYXkhJykpO1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cdFx0XHRzY3JpcHRzID0gcmVzb2x2ZVVSTHMoc2NyaXB0cyk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRzY3JpcHRzID0gREVGQVVMVF9XT1JLRVJfU0NSSVBUU1t0eXBlXS5zbGljZSgwKTtcclxuXHRcdFx0c2NyaXB0c1swXSA9IChvYmouemlwLndvcmtlclNjcmlwdHNQYXRoIHx8ICcnKSArIHNjcmlwdHNbMF07XHJcblx0XHR9XHJcblx0XHR2YXIgd29ya2VyID0gbmV3IFdvcmtlcihzY3JpcHRzWzBdKTtcclxuXHRcdC8vIHJlY29yZCB0b3RhbCBjb25zdW1lZCB0aW1lIGJ5IGluZmxhdGVyL2RlZmxhdGVyL2NyYzMyIGluIHRoaXMgd29ya2VyXHJcblx0XHR3b3JrZXIuY29kZWNUaW1lID0gd29ya2VyLmNyY1RpbWUgPSAwO1xyXG5cdFx0d29ya2VyLnBvc3RNZXNzYWdlKHsgdHlwZTogJ2ltcG9ydFNjcmlwdHMnLCBzY3JpcHRzOiBzY3JpcHRzLnNsaWNlKDEpIH0pO1xyXG5cdFx0d29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBvbm1lc3NhZ2UpO1xyXG5cdFx0ZnVuY3Rpb24gb25tZXNzYWdlKGV2KSB7XHJcblx0XHRcdHZhciBtc2cgPSBldi5kYXRhO1xyXG5cdFx0XHRpZiAobXNnLmVycm9yKSB7XHJcblx0XHRcdFx0d29ya2VyLnRlcm1pbmF0ZSgpOyAvLyBzaG91bGQgYmVmb3JlIG9uZXJyb3IoKSwgYmVjYXVzZSBvbmVycm9yKCkgbWF5IHRocm93LlxyXG5cdFx0XHRcdG9uZXJyb3IobXNnLmVycm9yKTtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKG1zZy50eXBlID09PSAnaW1wb3J0U2NyaXB0cycpIHtcclxuXHRcdFx0XHR3b3JrZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIG9ubWVzc2FnZSk7XHJcblx0XHRcdFx0d29ya2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZXJyb3JIYW5kbGVyKTtcclxuXHRcdFx0XHRjYWxsYmFjayh3b3JrZXIpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHQvLyBjYXRjaCBlbnRyeSBzY3JpcHQgbG9hZGluZyBlcnJvciBhbmQgb3RoZXIgdW5oYW5kbGVkIGVycm9yc1xyXG5cdFx0d29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZXJyb3JIYW5kbGVyKTtcclxuXHRcdGZ1bmN0aW9uIGVycm9ySGFuZGxlcihlcnIpIHtcclxuXHRcdFx0d29ya2VyLnRlcm1pbmF0ZSgpO1xyXG5cdFx0XHRvbmVycm9yKGVycik7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBvbmVycm9yX2RlZmF1bHQoZXJyb3IpIHtcclxuXHRcdGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xyXG5cdH1cclxuXHRvYmouemlwID0ge1xyXG5cdFx0UmVhZGVyIDogUmVhZGVyLFxyXG5cdFx0V3JpdGVyIDogV3JpdGVyLFxyXG5cdFx0QmxvYlJlYWRlciA6IEJsb2JSZWFkZXIsXHJcblx0XHREYXRhNjRVUklSZWFkZXIgOiBEYXRhNjRVUklSZWFkZXIsXHJcblx0XHRUZXh0UmVhZGVyIDogVGV4dFJlYWRlcixcclxuXHRcdEJsb2JXcml0ZXIgOiBCbG9iV3JpdGVyLFxyXG5cdFx0RGF0YTY0VVJJV3JpdGVyIDogRGF0YTY0VVJJV3JpdGVyLFxyXG5cdFx0VGV4dFdyaXRlciA6IFRleHRXcml0ZXIsXHJcblx0XHRjcmVhdGVSZWFkZXIgOiBmdW5jdGlvbihyZWFkZXIsIGNhbGxiYWNrLCBvbmVycm9yKSB7XHJcblx0XHRcdG9uZXJyb3IgPSBvbmVycm9yIHx8IG9uZXJyb3JfZGVmYXVsdDtcclxuXHJcblx0XHRcdHJlYWRlci5pbml0KGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdGNyZWF0ZVppcFJlYWRlcihyZWFkZXIsIGNhbGxiYWNrLCBvbmVycm9yKTtcclxuXHRcdFx0fSwgb25lcnJvcik7XHJcblx0XHR9LFxyXG5cdFx0Y3JlYXRlV3JpdGVyIDogZnVuY3Rpb24od3JpdGVyLCBjYWxsYmFjaywgb25lcnJvciwgZG9udERlZmxhdGUpIHtcclxuXHRcdFx0b25lcnJvciA9IG9uZXJyb3IgfHwgb25lcnJvcl9kZWZhdWx0O1xyXG5cdFx0XHRkb250RGVmbGF0ZSA9ICEhZG9udERlZmxhdGU7XHJcblxyXG5cdFx0XHR3cml0ZXIuaW5pdChmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRjcmVhdGVaaXBXcml0ZXIod3JpdGVyLCBjYWxsYmFjaywgb25lcnJvciwgZG9udERlZmxhdGUpO1xyXG5cdFx0XHR9LCBvbmVycm9yKTtcclxuXHRcdH0sXHJcblx0XHR1c2VXZWJXb3JrZXJzIDogdHJ1ZSxcclxuXHRcdC8qKlxyXG5cdFx0ICogRGlyZWN0b3J5IGNvbnRhaW5pbmcgdGhlIGRlZmF1bHQgd29ya2VyIHNjcmlwdHMgKHotd29ya2VyLmpzLCBkZWZsYXRlLmpzLCBhbmQgaW5mbGF0ZS5qcyksIHJlbGF0aXZlIHRvIGN1cnJlbnQgYmFzZSB1cmwuXHJcblx0XHQgKiBFLmcuOiB6aXAud29ya2VyU2NyaXB0cyA9ICcuLyc7XHJcblx0XHQgKi9cclxuXHRcdHdvcmtlclNjcmlwdHNQYXRoIDogbnVsbCxcclxuXHRcdC8qKlxyXG5cdFx0ICogQWR2YW5jZWQgb3B0aW9uIHRvIGNvbnRyb2wgd2hpY2ggc2NyaXB0cyBhcmUgbG9hZGVkIGluIHRoZSBXZWIgd29ya2VyLiBJZiB0aGlzIG9wdGlvbiBpcyBzcGVjaWZpZWQsIHRoZW4gd29ya2VyU2NyaXB0c1BhdGggbXVzdCBub3QgYmUgc2V0LlxyXG5cdFx0ICogd29ya2VyU2NyaXB0cy5kZWZsYXRlci93b3JrZXJTY3JpcHRzLmluZmxhdGVyIHNob3VsZCBiZSBhcnJheXMgb2YgdXJscyB0byBzY3JpcHRzIGZvciBkZWZsYXRlci9pbmZsYXRlciwgcmVzcGVjdGl2ZWx5LlxyXG5cdFx0ICogU2NyaXB0cyBpbiB0aGUgYXJyYXkgYXJlIGV4ZWN1dGVkIGluIG9yZGVyLCBhbmQgdGhlIGZpcnN0IG9uZSBzaG91bGQgYmUgei13b3JrZXIuanMsIHdoaWNoIGlzIHVzZWQgdG8gc3RhcnQgdGhlIHdvcmtlci5cclxuXHRcdCAqIEFsbCB1cmxzIGFyZSByZWxhdGl2ZSB0byBjdXJyZW50IGJhc2UgdXJsLlxyXG5cdFx0ICogRS5nLjpcclxuXHRcdCAqIHppcC53b3JrZXJTY3JpcHRzID0ge1xyXG5cdFx0ICogICBkZWZsYXRlcjogWyd6LXdvcmtlci5qcycsICdkZWZsYXRlLmpzJ10sXHJcblx0XHQgKiAgIGluZmxhdGVyOiBbJ3otd29ya2VyLmpzJywgJ2luZmxhdGUuanMnXVxyXG5cdFx0ICogfTtcclxuXHRcdCAqL1xyXG5cdFx0d29ya2VyU2NyaXB0cyA6IG51bGwsXHJcblx0fTtcclxuXHR3aW5kb3cuemlwID0gb2JqLnppcDtcclxuXHJcbn0pKHRoaXMpO1xyXG4iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTphcHBsaWNhdGlvbi9mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFRbEFBQTBBQUFBQjF1UUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCR1JsUk5BQUVKSkFBQUFCc0FBQUFjYllvSjlrOVRMeklBQUFHZ0FBQUFTZ0FBQUdCQk9XSFRZMjFoY0FBQUJGd0FBQURPQUFBQittMENiaDlqZG5RZ0FBQUZMQUFBQUFRQUFBQUVBQkVCUkdkaGMzQUFBUWtjQUFBQUNBQUFBQWovL3dBRFoyeDVaZ0FBQ3ZRQUFQR0JBQUdpY1BraUpoQm9aV0ZrQUFBQk1BQUFBQzRBQUFBMkFtdW5wV2hvWldFQUFBRmdBQUFBSFFBQUFDUUQ4QVNnYUcxMGVBQUFBZXdBQUFKdkFBQUxma0VLQUVsc2IyTmhBQUFGTUFBQUJjSUFBQVhDbExncDFtMWhlSEFBQUFHQUFBQUFJQUFBQUNBRFBBR2pibUZ0WlFBQS9IZ0FBQUZiQUFBQ2hhSVAzRzV3YjNOMEFBRDkxQUFBQzBZQUFCekttY0xWMm5qYVkyQmtZR0FBWWhOVk9mZDRmcHV2RE54TURDQndZWm54RkFUOS93QVRBK01CSUplREFTd05BUGJIQ1hNQUFIamFZMkJrWUdBODhQOEFneDRUQXdnQVNVWUdGTUIwSHdCUmN3T1dBQUFBQUFFQUFBTGdBWElBR2dBQUFBQUFBZ0FBQUFFQUFRQUFBRUFBTGdBQUFBQjQybU5nWWF4aC9NTEF5c0RBNk1PWXhzREE0QTZsdnpKSU1yUXdNREF4c0RFendJRUFnc2tRa09hYXduRGdJOE9YNzR3SC9oOWcwR004d09BQUZHWkVVcUxBd0FnQWZSUU5wQUFBZU5xTlZqdHlGREVRYlkzM0FMQVI0Y1NjUWhFaFJiUWhwUU00NGdMb0FBUUVEb2hBUlVCUkxtNUFNcHdBUW9kYlpKUURIOEhXcHlVOTliU01YWDZsWGtrdDllZDFhK2duUGFmMGQwMWtOakxrODBnbWpUYmlXR1JLYzI0dnR6M2JJNGovZVF6OE8weXdEZkpGMUV1NkYxbDJZQmZhbU1hMVlDRzJKN1IxMDJRTHVoNXN4ejBFWnpKeVBFSTVQL2xOWjc3blc3UXB4ZUtPZFY1SCtYdTNod0l0K1R6TlpyaWZBdCs3Q1orc29pdGo2Q2RuTzRhTnZpWElNMFFjc2w5YTNtUzhmakhrUERGdUdMTnpiRUdLMzBMS0hRN3loUG9wdisvR3VFUjdUWXVSaEpacjMvVEcrRzVLN0owNGkzbEJIdlRTK0lwamwrUzNDbjltTXZMcnJOelpjMjFxekhaNkhDOUM3dEkrRGd2TVpmazkxTWhKOENmTnZZVGYxYmJQa2N0ZXhDUkFuQVBibXVRcm1DdDNtbWJEYVl6SHdBTUxmUUw1RFRGZDZycUhkU2Y0YnlGbjY1NTdLbC9TV1QvQXB4UExWTWJhQTFvdm9MS0hib2U4bW54ZnpXVVFkaUp3N1F6d1NyMWdIdVY2QUp2UkY5ZlhtaDdXeENmdVBXOTRQdTIvRkxIY2hFM3JMdC9qWFYvQXJ5dUdFL1Y0RFRWKzdqMjEyZlZzOUhlUmZDNzJkQzdXZTdiZDI5RnIzZmIreGxncUY2cE05ejNYS21TLy9GdlE1cjR5TE5RRzZxMkNpeG9mWUQvOW50dENpcC9UZm52czcvY09INVQ3MTBuTk9MMlhOcTRuZkdTUWdKLzB2cGtQczdkS3ZzZEJyUDNoUGh5ZUVQOFYrRnhyNngvWHdDWG92eEMraExGbTZhWUErS1RuWDhaVHZwdWVEaG5ZWCsyOFo2VTNJNzhibW0weXJtZ3pmQ3NOUGNlTE03UThTTnNuYnp2MFgvTW9OenUzRGhuMTdxUDRucFQrekRoYUFiVkkrRzJET2NHMzdYODFOUE43Ry90eDVOQ2h4VlRhckh6LzVEelNBL1pXaENNQWVOcGpZR0JnWm9CZ0dRWkdCaEQ0QXVReGd2a3NERGVBdEJHREFwQWw5Tkg4bzlWSGw0L2VuMm8vN2ZwMDlOUHhUNmMrWGZsMDg5UGRUdzgrUGZuMDh0T2JUeDgrL2ZqMDl6UGJaNTdQL0o5bHYzei8vNStCNFNQRFI4dVB0aC9kUC83OE5QWFRQcUNlazU4dWZyb08xdk1ZcU9jMVVNK1hUMzgrczM3bUF1b1IvbXovL3o4L016OFRQd1BmUDc1QVBpcytjejR6UGxNK2ZUNWRQaTArRFQ0MVBpVStSVDQ1UG1rK0NUNUJQajQrSGo1TzNoZFFONU1JR05rWTRCb1ptWUFFRTdvQ2htRVBBQU5uVnI0QUFBQVJBVVFBQUFBcUFDb0FLZ0JTQUdRQW1BQ29BTWdBOEFFQUFTQUJTQUZZQVhZQm5nR3VBYzRCOWdLc0F2WURIQU5JQTJZRGtnTzhCQ1FFY2dTMEJQZ0ZPZ1ZhQlpvRjRnWUtCbG9HbEFhOEJ1b0hEQWN1QjFBSGNnZmNDQ1FJVWdpT0NMWUk4Z2ttQ1lZSnVnblVDZndLV0FxVUNzNExDZ3QwQzRRTHVndlNEQ1FNYmd6d0RXWU5oQTNXRGlJT05nNThEdndQTGc5S0Q1d1B5aEFBRUVJUVpoQ3FFUUlSS0JGZ0Vhd1I2aEswRXZ3VFpCT2FFN0lUeWhQV0ZBNFVOaFJ5RktvVXhCVU1GVEFWaWhZY0ZtZ1dyQmJLRnVvWEVoY21GMVlYbmhld0dBUVlLQmhDR0hBWW9oajBHU2daV2hvZUdwb2JIaHRjRy9RY1dCeTJIT1FkVGgyK0hnZ2VOaDUySHBRZmFCL0NJRElncGlESUlPSWhPQ0YrSWtBaTBpTWtJMG9rSENTMkpSd2xVaVh1SmpBbThpZEtKNEFubmlnY0tLb280aWtBS1c0cG5pbTBLY29xRGlwU0txQXE3Q3NpSzFJcmxDdklLK1FzREN4YUxKWXM0QzBtTFZZdGJDMkNMWmd0cmkzU0xlb3VCaTRrTGxndWVpN09MOVF2N2pBc01KWXhGakYrTWNReCtqSmlNcTR5eWpMbU5HQTBkRFNnTk5ZMUdEVnNOY1EyQmpZeU5wUTJ0RGNNTjVBM3lqaFVPUVE1c0RubU9obzZlanFrT3VZNjlqc3dPMWc3bWp2UVBDbzhmRHkwUFJ3OW1ENCtQeHcva2ovOFFGcEE2RUZFUVhSQmtFRytRZ3hDbWtNOFEzaEVMa1JVUkxaRitrYkNSdDVIMGtuVVNlaEtIRW95U21KS2tFckNTdTVMQ0VzMFM0aExza3ZRVENaTVRFeUlUSzVNMkUwQ1RRNU5PazFLVGJKTnhrM2NUZzVPWGs2NFQwNVAwRkFxVUQ1UWpsQ3dVV0pTSmxMRVV5SlRabE9XVThoVU1GU1VWT3hWVWxXcVZnQldhRlorVnQ1WEdsYytWNEpYd2xneVdMNVpNRm1LV2V4YVVscWlXdnBjTGx5OFhPaGRKRjJBWGFwZDRGNEFYalplVkY2S1hxQmV1RjdFWHR4ZTZGOEFYd3hmSkY4d1gwUmZlbCtZWC9CZ1NHQmVZS3hnL21Fa1lXaGhxbUhHWWVwaUVtSTZZbVppb0dMS1l2UmpMbU5PWTV4andHUGtaQUJrSUdSS1pHaGtpR1NhWkx4azdtVVVaVnBsZkdXOFplWm1BR2E2WnVKbkhtY3laMnhubW1mVWFBUm9IbWhzYUpSb3ZHak9hUkJwUm1sdWFacHA4R29zYWxacWNtcVVhclpxM0dyK2F5UnJRbXRxYTVKcnFtdlliQlJzVEd4MGJLaHM2RzA2YldwdGttMjRiZVp1SEc1R2JtQnVjRzZ5YnQ1dkRtOG1iMHB2cm5BQWNJUndwSERnY1d4eHdISkVjcmh6TW5PR2M2aHp4SFJpZE5aMWFIWFNkZVIxOW5ZSWRocDJLblpPZG5KMmxuYThkczUzckhpTWVNSjQ3SG5xZXNoN1ZIdlNmQjU4Vm56NmZWSjljSDJBZmRoK0RuNXdmclIrN0g4S2YwcC9oSCtvZjc2QVBvQ0tnTHlBNElGVWdhU0I5SUl5Z2xxQ2RJTE9nd0NERklOQWcyQ0RpSU9tZzh5RDVvUUFoREtFV0lTMmhQQ0ZRb1dnaGRxR0JJYUFoczZIRm9jMmlDNkl4SWxjaWZTS05vcHlpcWFLMElzb2kzcUxwb3ZLaSs2TUVvdzJqRmFNY0l5WWpMaU5HbzFZalhhTmlJM0FqZTZPUUk2TWp0S1BBSTljajR5UC9KQldrbktUZkpQSWsvcVVoSlRjbFZDVnNKWmtsdHFYc3BnT21HS1lvSmpLbVB5WlhKbUltYmFaL0pvNG1tcWFpcHJXbXlDYk9KdG1tNDZjQXB6YW5VNmRzcDMwbml5ZVdwNmFucjZlK3A4d240Q2YwcUFNb0N5Z2VLQzhvUWloU3FGOG9ZcWhycUhHb2VTaUNLSStvbUtpcktMVW92cWpLcU5PbzJha0hLUnNwS3lrM3FUNHBRcWxpcVhrcGdhbUdLY3NwN3FwU3FvMnF2eXJTS3djckhhc21xeXlyUWF0TEsyU3JjeXQ0SzN1cmdLdUxxNU9ybml1bXE3WXJ3YXZTcTk4cjdpdjhMQm1zTGF4R3JGb3NaaXh0TEhTc2dpeU1ySmVzdUt6T3JOYXMyeTBITFJ3dEp5MHhMVDZ0WGExNHJaT3RuQzJncmFtdHJpM2lyZ2N1TVM0NUxrS3VTQzVkcm0rdWc2NlVycmN1eWk3Z0x2VXZDYThXcnpzdlk2OXpMNE92b0srMXI4a3YyUy9rcit1ditqQUhNQkF3RjdBbXNDOHdQREJBTUZNd1lEQ01zTDB3OHpFRE1RMHhMREUzc1VBeFVyRnJzWk94dUxIRk1jK3g3Ykg2c2dheUVMSTBNa1F5VWJKMHNwc3l1REwvTTA4emdMT0xzNU96czdQTXM5NHo1N1FJTkNRME9MUkhORTRBQUI0MnF5OUNaUmtSM1VtL0NMZUVtL2ZsOXp6WldabFp1MUxydFZMVldXM3VxWGUxS3FXV28xMmxWcXRIVUZMSUpERlZpQWRJMk00Tk5nQ0dRdFRad3hHV0lBYmJJTXdZMU0yeGdac3o4Z3lHUEJhd0RtL1BmeGpXOE40UEl6SGsvcHZ4TXVzeW1xRURHZitxc3g0OGJaWWJrVGMrOTBiTnlJNXpEa2N4LzBDdXBiak9jTE5mZ3B4Yy9zL1RRVHVIeHFma3NTLzJ2OXBIa09VK3hSUEw0djA4cWVKaFA1dC82Y1J2ZDUwbWs2OTZWU2N4MTkvNTUzbzJ2NHpEbXBDYWp5SE9BNTlBYTF6QnFRZWNGdzFKRktsVks3WHVsNm5FWG50U3RDRkwvcHRTUkNWL2kyS0tFai9XWFJGdDlmclpUUWl5MFJETnl0Sy8zUHo4NnNYTGtCNm1PTmUzT0xXMFFZckl4ZFYyczE2aFcrdXI2L2JhL1o2dk5aRE1YMkdpOUVtV3VNa0x1YTRicjNaYmdiTktMUVF6WGtPMVZaUWt6UWJSZFRzZHZhaGVuTnJmWFZ0OVpUTEszeTYvNDQwSEp3ams4c05BYnRQdTVodkxrKys4N1ZyYS9lbzRXVytmMW1vZHBmNW1SbCtHYktnTllOZ0hlb21jVnd6eVdWejgvekcrYzNOemVIOU5VUkxCSFQxYXUxV3AxbHFoSUZ2WVFsS3dmTXFRUVdpOHZoeHhWY2VSNFNYaUtJUWtlZWZVcFNuaHUvYnlFWG51UlRRRGNoR3k5N3FRTUVocVVhWVIxMElmYVRjbzVpR2NxL2k1cFNHbC9FYVNzNTkwemxGT2Fla1hXWCtXNGJyR3QrYVY5ejBKZVZ0ZDRObVVBazI2UjhVZVpoZnpGRzYwZkoybWxCV3g2ZTU0bHByQlgwMEtaL0VZMW8rZERNVXYvK2Q3ZUlQMysraU5YU1VsdGVqWmJNUUpPSkxVeWlDa0phKzNlcmVyMlJjWldHblhGQlFCZlZHU3c5MU1VemxrdkpXU1J2YXVvM1dkMHE4cTd4ZEtHaXQ3UUNORzBWTWMwN3ZvbWRsTjdVdktXdEVXd1ZKWlZwUFNLWkZ1d1dsOUgrL2hJNExpcHRCdlIrbTl5Vmw5YUpLVUdsWFdERlpnUy9wQzFYSWpuWkZJTWNLcHUySmxuWlQ4NmRldmk5NFhWcExsTkFVa2lyWGxoQ2hwWCtKcm9ENGw2akRZQnpCR05uZ2J1UFdvVVFtMUx0ZW8vL1F0N29kbWtFQkJ6NlI2RCtsYkNWNUFocHdjRHNLbzJhM1NXOEhmdGhzZER2dFZwSkFwWnk4RmZqd0NQelRlOTM2Nk1VQ1l0YzZPKytnWHhrN3U5aVltU29VYldjc3pzOU16VTJlM0QrbWFyWUx6NmNLdkZMTFRrU1JvbGhtS3NyNHJpMGlzWlBDQ010YXlySjFMUXFLaGNwNG9SaWxOTU13bzNSY3FzL1Y0dElIYmNXUUpGRkFTQlJzelRKVVJjRThRcEpJNUlucW1HTVhpdU5UYy9OWEYzS2VrNW8vc2xETDVCMVBVVk9PbGNubXBqS3B0T2NhdXFxYXFRZDBZb3FhbWNsT2pPWFNvYThvaHBIT0ZNcVZ5VUljUnJwdUc0WFB5cHFtdW9halNqS1JWRm15VE4zU0RZbW9SQlNCVXcxcGJYQVJCMXdSZVNXdjJhYTlqSTdpZWdEeDJoUXFTM3lKcndRaGExQ2djM3RYSEczRS9WN2NPOXFVbTBlM05qczF1ZGE1Q1QyY3J0aHV6clUzV1ZoQmNYOFQ5WVRtMGFOTkFmNXFuVTcvTTRnYlUxM1RoWTg2dGhOalBMSUhaZXB4SGdlc29WdGVRaTNnVG5sb21UenlwNkJYVmVxa1Nib1ZWVlhSbTlTcUNwOWZPYmVVUGJmVVUvK3JxbmJVVjhKMzY5V25YcDN3NU8yMGlsQzc3UlJLMjZsRzdTbTBoRXBCYVFrMTBXZG9ZdjFIV2NLV0ZmZC9EWjJLRWNkU1pHbXY5ZUo0TTQ1Wm54K20rNUtwN2twcE5JV2ZvRXlWcVBrU1pUb1ZMN3hra1M1Tjl5WHB4cExjaHlENTlnajF3aitOUHhWRDBxUDBneVI3TVpXUklOUCtEL1NQT1c0dmQ1anl6aUphS0tBdVRadU9NeXE1QWhqdlZJQ1ZsM0JOSWdHUjZpREdPbTA2ZUxwQjJJRjRDL2dybENHSnpTTGQ1Zy94SXRaRjRTRlJKcWNGNFRTUkh4RkVIWXR3M1RiNUd3VGhlc1IvQUU0TFBGOVFWUnJ5SXBxM2hRTUM1cC9DcXZDQVFNZ3BRWkJQRWZLUW9PS25lSjZIM21XYndobGVsSzlGUXUwcWVMREF5L0QySDE0bHFTd0dHSUVUdHZ1N0J2Mjl4UzF5bkV0WlZDSzAvSEFrM20yQWlJRTJBY2E5RDJnWE5qclFHSXlmUU1SelNzNmJjeTUwN2YvRXdpT3kzRitWNWNWOExiOWU4Tnk4M2Q5QVBkZU1hWjhlRFdibC9ubFpSaGZrQ1R1SzdJa2s3RjlBM0l1c2JJQU5Oa0JtcEVCMmpISFR0Ry9Ra2pCK1RNdTFEMUZVMElnV0lxblJhZFhLa3Q5cHRNb1NsV1BBWWRHYlRkODMreCttNGVHNllwODIxSW4zbk9oMFRuVCtKWmY3N042SmliMFRhTVl6djBydmY5WDB4alYxNGkrN0o3cmRFNi9PRlNmb2JjaGYyc1luRG95OUVsZmxKcmdaVmc0bWI2bGNXSEFXUUpKRlpSS1UycldLMCtpMlMwSFk3QUxDSUJSbHdCZDlXTGR0dmY4d0RSME5vM1dzYWJnUG9iZTV1YmJSUTJ0dzh3ZjBKcEoxTzlaOVgzK1IwMS83V3IxbjI3RnR6ODl6U1R1OUFMUzR3UGxjTHFGRk42RUJ4U21VSnRDZloxR2xBelFJQjdRWVBaNklwNmRqSk5OUXVNbzByMmVOOU9CSU9EOVIrTlBDNUNRRUU3Mk8rcHpMTG81OEVybTJYWWFYenYyU1hIYW55ZVJZOG42S200VVVJaE1CSjdWUXV6SnNUZWhOMEp6ZWRwSjF5bXByU3hqeStaY01YL0J1SUZMYjluTlpEOWN5RHltdnlWU3JHZWU0WU55UnFSWXlWN3VXdzgvTVIrNWJ2Y3dkNlRMYVUway9uYTcwOWd1VjlObkxNK1ZkTktUOWFad0R1a1lVUUZDY1Iwd1VTRUhFSkdMWnIwZy9pbzdQblhua2tZOC9Va0pZQ0U4TE1pOGpWRDM0UTdSRUQvM0s2MTUzemI0RmhKRk1yaXRpakt4dnZ3UkIwVWg1Zm5SSlhpTEhsMGlmRytEdEpMME0xd1g2MWhiYVZCNE5aRDZ3bzNvRkVyVlF0K1UxRWhBMXpBaWlDWEpvZFpkUkdxVVdoRHVQUk1ITTVka2lFZ1JlV3RULy9NaWRPWVI0NTdBRXAxaTJnK2pJSGJ5K3RnZmh5bVJ2TXRRUDN5NjFkWXpERlJIZGRQdmh1U2tFa2xzNmxvR1M4WUowOXJEcjdEa3hpbU1JOUdET0hReFRFWkFGc0VOYUNvWklBSElIUG5EUUtHeDBILzJ0UitHRHJrR29pSGlNWGowTlVCenhhVWdlbjRTa2ViVEJubkFSWUlVVVF1K2VoUHR3Rng1Rnh5R2FZREVFTkhrTGxVdGNBWkM3aWVxemlJSHpzSWk4RG5vMEk2bi9XUzBhOHFGQ1VVdkYydTIvb2FLMytTV3ovN3docWRMUmNsa3ZwNUJ4SHlMR2poNnhBZGd4QzhmUUIwMkFnVzVBaDZpVFFEMkt4aVAwU3hqL0w0a1h4WGZ4R09PY0xXRkJXdjB5Rm5nQlhRM2l2cjhwaVkvekFrWUNMdGlTZEJMcWd5RnRIdVRWYjZNbGhwRVh1cDFFakNSYVVDZmErcVFzRjJYNTY3ektmNTNGM3ZkUldTN0k4aC96L0IrenlLQjhMMzRYNU5NSFdScE1HdEc2d3Zzc3NUTTdyeEFGSWgvZEhFbVUwRnVmcEdud0wzNFhjWU0wRnBqd29nZzJTYXY3cXpRTmhXeG5TNU1veUdTblhFazVlTzR5cUV1UHBVR2twQTZOcEVaejZJZnE4c252WFZLWmozSlVaNFQrc2diOXhRSFp0TXdkNUM3bmpuRW5xY3lGdExibFV0UU1vM3JaYnpaYUF5MW9DaWZhQmVVbndFWEtjQTNZRkZ4aHpBU1JBV2V1RDc2cjBHT0NiQzBiNEJTL0JwRDA3WnB0YTAvOHZPWTQybEZOcnVvYVVqUzlLdXVmUDM5K1krT3RiMzBPeFNXQ1JDdndzbGt2c0VWU1dzdmxnSUUveVJqNDNZQXdaYzNvZjA3WDBSV0dKaHNiREl6MDJHY3dSdjhXeHNDSG9IWXpJMk9nM3UwTXhzQmdQQlpCUzZDam9MR0NLQ3luK0tFMUdBMG5qcCtRcEpEbk1YL2lCQVI4SUVrblRtQWNZQmtmVHk3dzZFUHMyYWVQSDVla2dPZVBIV05QSFQrQlpCeGlmT0k0bkVKZjNLVVhaNm11dzdRVWtpaFg5VVIvN1NiS0lYcWQ2aGUwUngvVmNxSDJ0cmRwWVk3R0M3NzY2QklMSHgzYzNZbVBwbDFsYVROSVJKTlBsR09hQTFTcnlmSm9KbDBEdlJHZ3NDQkt3cU9QMHJBbUNJODlCb0JNRXVnVkdnSThlMnhKMElXcVFCK0JneTQ4K2paVmhRZmY5alo0VlZYZWx1UTdEelJlWmJwNFkwZUI2d0IzZzdGSmd6QkFyeXJQejVmNy83WGFMbWVGVXFpYjVwN3kvR1hmV0tpVUZ6clZ3cHdTNWttaGVuaUIyVVZvUGQ2QTNnQnRwdE82MEpKQ2cwVWtzdEFLSGliUGVoeXBETHNiZW9OaHhOMmlvUi9zZnFwblBoOGJhdjgvcVlhaGZpVitRbE9Sb2FDYmRLUFlqUTFqb3ZzSkV6ckhWK2hOMUZDTldPMy9zNnB5bzlpTWNCYU1nT0pPZnhtS3BOb2w1OCt1N3RtenV1ZXFzVXhtTExQQWVzc243anh5NU00anFMU0gzam1kb1hlK3ovckdONC9RTzl3QTQzQW9obmJ5UVM1T0F3WTh4QjJsdFV5azhMQnFnRzZoVXdZK3hHRHN3WFc0dlIyUDJqdFh1aVB4ZXJNZStLaUFEZVcvSzZhcGJFakF0RS8vdi93VlBQMjhBZU0zOEJ2NEYzbitGM0dNUDgvem44ZHorNjlBa1NUOEQ5VTBWYlNxbWhqek45a3FEM3ppVVJaZU9SSS9lZktnem0yM0R5MS9BQzFlK2hFbEQwRjNJODBFYTFSQW5PaFFJc3VpSlpMUU5mek5lLzl5NnpMTmVTdUtlT21mVmR0VzBWV0tDVUxsSnI2ejh2M25IZTNxUVQ2cndLYm5tVDFMNHpnSGtKNDQrR0t1enlWZlpNZnhHdnNNOUswWUFjUURmUkowdHlyQTU5YUFFWUtvcDNySVFNdEJjLzN2T1B3N0ZGOTVCNi9yZXYrYnVyNXVDOElYRk9WM1FDR085WEVkUGtPZEJyQTA1M0pMMUZKVnIzWDI0VWFZYU96VVZOZEpLbzhacG9vS09DSlNSSFVPSms4N1hWRG9nZE1zWTAvbHNhaDg0UXVLaUhuMUk0S2NrWVV0Z2l6eXVjL0p0c0pQSC9DdkFTRXFvTE9CQkxlazRDeElLdjVxdnplTnBrUkpFZ1JRMVcvQWdvRFBnTDcrSjhRMHlaOG9BczVQR3pkVDBZdXVNWG5BRFNhSWJTemNiRXpuRTlvbHVoanR5WFVvZVNNeWhVcDVGdGVYMGJEM2RobFFZWG8wYlRacDYxVVBacTI5WS92eVkvdjNsOHNIN2dpT3RkdkgyamU0Sm1oQTA0VkNDSXBENzYxWmM5NzEzZWxpNWNES1gzYU9kVHJIRHBzdUlXR3hPRjFVRTV0bWpONEM5RmNCQVl4UjVGNUFlVlNpQnI0dWNJRktDN2pCaUxrUkNBVXdIaTBSSXZhM0ZPMHJtcndwRXZuZlhONFIvUDdYZk1IQmttYWhBMmdGS1dvdVowb2x5VkJrZkV3clBCc0VuL05Nb3NhSlRUUEJDQm1hWTNXWHp0S3RVUmxhcFFLVmlGRzlDNnA3SlNKZGRJRWFrZnJyUkRGNHBQQTJldEFVRk1IdS8rcFgvT2F5NzYwMHZjWUxpdlM4cEVCZ1lDek9tTUl4d1o0MWhVTy90M2RzTDN6R3VCSGJSWWJyZ2F6a29sbHFmYVJxYVlOWmNpaW5naTVDalVjOFJZVlVYVzBNekQ3MWJnUVNoaGw0eWdQTEVQQzNicVZMbXE5cHJUeDZjNldFZU9UWjdXRTBwUlhpaFFrYjBCaUNQdXQyWmxwajNiZ3hvVXVEQzkyWjlsaTFkdTNQMXE0Vjh2Y3MzL3lvQm9oUUdjWmtDWTNQZE9aWFEwQ3pBT053M0I3dnpIUVdUZ1VTVHM1YkU3Lyt3QzgrTU1Beld6QitOamlSNDlvZWFmTGRyZWJQYlRVM0VMZjVJcmM1R0YvcjBMNFdHL2tOYUVvVFUxb0RtWnZWcUFTSUZsUGJEVlFmRHVoVk9rRTZ3cXJjLzZJdUl3UDc2RHJjZjFvQy9Lc2Q5eVZOMDkxM1c0aVQxZDhpUkZMVlovMkZrdDVVQ09KMVF4aklsWFdRS3pyVmZ5U3lMRFRiRWRtNjd2WXFKcVdaYTFzYkcrK3I5ZVQ4RmQyWjFRcy96UTM2QVpWL1U5U1NOT1pIRXFuQmFJU3dUR3IxVG8wRzdWYTkwdzI3SFJvMnVtRUVnNVdHZ3hHQmJxeUtXam1YVmtJN1BCRzZnVEpmVTZWcWxTamxYRW9KM09SYUtsZld4TDlmM2J0M2RlOTNEc0dEY2k1ZDFjUnFWVkpyOC9TaFdqa01iVG1YWXEvQ3hWUk9EdTBQN0tVdmpKU3h6czFCWDYxSTBPeDFpUVNWZHExTzZ0MWF2ZEp1ZGxqdm9CcHRHSFVqRWtiTjdmS3RUMHRhM0NtWnFSTVp2ZFNKTldsNkN1QmJKKytrVDZTZGZLZWdpVk4vUGgzSDAvRUhQRC91eERLWm5aVUpSSHp2Uk5hRTUxUXlNVUZVZU5BUGJvcnBnMUFjWlp0blVwdEVCY3Exajd1Q3U0YTdsYnNQK0lZUGZCM0dFVFJtRVAySXVQai8wek05MGlEd1dkOTFlSkg3OGEraU9ra2lPNTlQL3hoWFdMOUgwTy9mQXYzK0pNVk9FcUVtM1VUamJrQlRkRUNIcWRNdXZtUEVwVHFjQ2VBS09ucVJvcXFFNlpScjhHUml2d1VnbHhoNTBWdXdUTXc0a3lvWHc1eXRZVUVSTTZJZ2dFRHd6V3lwbk5WQ0VBbUNBQmNWQVVrOGIrZkNZam1WaVUwaVk2SGxpWVpkdTY0R3d0eHVQVisvUFRVZlYxTDNwc3NwWXBXS2pnV3lRZVdSSXhtRzZDSklSWklzSjQ2SmhuRUtIa3RWNHZuVTdmWHJGMzFlbFgyZmFNUmVITldwTEtaVFVRemM2ZzZ3SjNwenVmekpUNWJMaFZjVXNybkNHYlJXdWFQeW03OEpRUnpuY3ZFSXp5TWdFYnM3Q0NucUFGMGtacDFLVE5lVVNrR1RwaHNPYmVXRUloUnFKUWVKbkdEcmYwYU9vYnUyYnJnTGVqcFZ5M201QlVFcDJ6S1dNOERtaFRvSVM4WDBCbHJuN3h1dW5YR3NkemxleVhNTmJ5R1FyRkNYZFVHeUxDTW5DSnFzeUlvNXdQei9EUnIwM2R3NEIzalNZL2t6bFR1Z25hMU5ZU25USHJlTFdXbFJSTXdYa0lsbTBUTDZWdDFUaW9FbDhtU1pZSVBrTkUwVGRNM0twQzF5NVhSK2R1bGdrTUc1OFF6T290Y1Uyc1dNbGpaMVcvRWxjZFpYVTRRb2ttT0ZwcHZTNHF2eWZ2OExLRE9aeHVuSnpDZytWK25JcDlNZzlOdEY2L05yYTJ2em14c2I2K3NiVzBOOHRRblBFUmlQczhESkVsdUYzeDJ4Z3RIWkhERnlXbkJDbkc0eXM5Tmc4QjZkRzgvbHhuTmpPell3VkxyZDZIOUF3MitXRlUzcUNKSktYQ0xKV3puNjNHUHcwTFBzb1NPNi9RZjNJZ0d3MEw4OUtaTjkwQ0Z0a2RrRWs3S2t1UWxBcWRmQTJVQ3JyODRDRllsRVIwVUhCQ3hBUHBIS2RtQmd0WW9JY0RUcWlvQk1LM080VEFJTEJZbnFnUlBkaXFvZmRWb3JOZ2VHZmxVMWdQU20ydjhNUkxDbEdDaEFtb0xHSVNMMlgwQ0crcGQwUHFQL3YxWGJSZGVxMnQ3OEg2dVlKOUtka3F5SVU3d0FrTklSSlpuUE9wWWZtUEJGTFdRcS9mK2w2c2hHdWpxTGtDYi9WOWxBS1RoMlZNWFFpa2dPRmZUcDlKMS9nR0FVS2dwYVdTZmtmb2tzQUZyV0JiRjB3QWYrbUF1NFVSbXZBWjdKSjd4Qm9pZ1FnTi9RU09XMWFWUFNLVU40OHEwMzMvd1ladUZ6elBLa2h3ZkQ4SXZEYXhET00zTlUvMzlxSDljM3RHMDdFcmVPTGdBbkJ1MGQxR2c2bXdmZjJxRGQxK0oxd0xjNmExYmJmc0dlWnkzSHlwYllueHpvNTIwNmxnZFlqdklzcW5QNUdJcEpwNUVHeGlZS05oalQ4b0ZyVVh4YWF6Vjg5UEQ0SXg5LzVKRXpoenV5YW5nckxjdXlWRTBtaGljNHdkakpzUXE5WUxVcUVIMW1FKzNySEdiMnNYSFJBd1hyTDlubHdCRThnOGlhT255T3ZYS0tUZlR1NkFvYThJc0NZSGc2SlRBd2JIZUFHY0FBNUIzR0Y1aTlRSUdHVS9yZlY5NldVMFR6clBSbmhQeVpoRjRQbDk0THJXUktNcXIwLzBHU2tFZDV0a2pUNWpZWkg0dEFueTZDN09LOGdVMWlvSXcwUTVvMnBEeUovSWJiYUpXN1RzVjVtbW83RjJpd0tLUUVJYVhMc2d3RUJvNElYZkRpVUJXSzRXci8yZGpldG8xejNOWmdUQllCWVhDZEFlZTdORWQzaUs1Qm9sZWtSQzA3eTdyQ2E2bU40MmthZFBaUFR1NmZmQktyait2bW84YlBlQm5QeXlCMWRDajJOeWJwTXovM09tRGx4b1BXVU8rS1FkOVpZOW9RbmZkeFNveWNCUFFoK2pXaENHaXIzMVBSeDlXNHY5N0RYUGZjVjgraE0vMS9SWkw2d25QUHRVWFIxalRvYjlSUTl5dm9MWUJieDZGSEY1QlVoMy9vR0V5OGdhSU5XZ3dNOHBCMDJyUDhIQ29JNkNsWlVFa3dhVWR1NS9xeFkxa1RobC8xcmp2eUU5T3lPSzNPWEx0bldsTUZ1OW0rNmpBS1hJUU1UNVBsTUw3c1EyZDhnYTluN1ZUcFZRdXlycHJXMUdSVjF5Uy9QVHMvck04YThNT1l6VlVmNExnVk5MUkVBeVJPSmp1QWR0VHlWSnRDMUlnWXdlM0tZRUtRenBic1ExVDRicHV6RytIbStkTGNYT2w4TXlUenJubWVUbm5ZdkEzSVV0cDFPczhlU2syOE1EOVhpa3R6ODQ0VkQrZEl6SlFvemxNUk9uTE9Ic29POENYM1Q5QUhUQzVra2crR200Vm1oZmEyUGVEeXMxZnNMeFJFZTZLWVdac3RsMmRMYVAzeVJ2T3hpWEVwWEZsYWpSdXZMTkdyUTE4TnRNNTBoMGxtaldaVndGUi9XS0JVR0FJS0ZOQ0xkZUNwQzhCSHBWQXhESVgzeml3dm4ySFIvdjkwZnRITlpjZkhzN25ZVUw2bUdNWEROOTEwdU1paXFGZ3NVdTByandxRC9FNUNmaEcxdzNlRFpjVG1sd0g3UWo2VUpaQmdEblZCT1FUZzBpNGlDM1ZOeENha0NWVlMyczlXRjFRWldnQ1gwTkpDWkovSVRMOFpyU3o0RGtUMkliZ244WE1ZbFg1K3I3U25Ia1FXbmtMODlLTFFQdTNJYU05bFVmMzJ6bW1Ic0ZoenI3UzNGa1lHUHcxNnkyeUhsZXM3M05NTVQweXh1VERHOFlLazl0UjBBRU9yVm0vVDJVTUp4bGNsWUZkcGE1K0xneUFPL0t4dGkwR0FvTHNDSHJDemZoVmRHOUk3aGJ6M29Lb282ajM5N3hpNmFuM2tJNmFtbWFod0Q3MzJvQWVjbkVwaEp0dmVESHk5QkJyREVlNDBZTjQ3dVB1NTEzT1BNbTdxK0dSZ1FxUGZPaDNmekRZTFE0UnZrNkFidFFrallic09TSjBBbUlpNmNCbGdQSkFSN2dYTnFFd2RQT0IycHdGQUhtZ013NnhPc1NGb0hCRU5TVDJvdDJrRVVpRzBpNE51VXFmd0h4NkhGTkhuQ0tFekFMZmRKcFBiYnFNK1AvZEE1S3hNdm5mRlhVY0YwUUlXZFZUREttaDE5eHhGa2k1aEFZdEhDWThsaEM1ZWdVVWtpQ0wrQVNHYURJbUlDSDNVd0pxcy9Za2xpQVovcXlocFdNYThqcjZtcWFxbWFqVFVVRmRVK24rbkNoZ2ZQQ2dJOUNzcUtLMklWeVFuL1c5L3YvSDl4c0piTmFRWUluLy93aDBTTWhENitNTDlvRzFxRWlKWWZQM0NlUXM5K1AyRjZ4RElYb1IrNWpFc1FyRXdobkVpWTEwVzAwaEV1cXhRZzRhT0ZjeHJTTlJWVlFkTmtJYURmaHBEZjZoVEhhNDluQmR0N05pZkpWS2hsRXhjT3dCOVZFRHI3Zzd2QVEvV2JXMzV6TEptNjB0ekdDdThidXU4Z3ZIYzBtVXp2ZG5aM3N6enNxYko1c1R5OG9USllndkhkUURPZTJWZGwvY0NsTmFQTDF5SXAyZUtGNHJUMDBYS28vQ0xXOXd2UVhsaTdpQjNqSTM2S0xIKzBNa2lRZzAvTUl6S3JjcVFkemJ5ZzhtZE9kUUNwYUVObWswRWc3bEpsZjRHblVFbDdSWTExZ0hIbUpSbGlkY0VBc1FUZkE5QkZ4ZWc0WWlnOFpJczM2Y0RvTThiTnNKRXdhRERJeVFnSmZRVk9DQ1U4MzIwRVdkVFJjT1NlSVNSS0VMQVM1WlJUR1YvUnNjdjZJWWs4T0t0Yjh4aG5VNTFJSFNxcEdrbGJhamZBL3FubzQxTi9DWEFKZm15U2NCS1lyTmpDR1R3QmFiMGxTamV4LzdpcUhDbUVNVlBzcjg0UWh1Rk1GZWRndi9Kc0hEbGxZVndrcDNrd3NLdStTZHR4UFlPa21wZ1dWOTdrUnRnKy9zSFBnMVVLOW1pVDFmcDB4VHBRdDdvTnVxZDAvOGRHbTR4V2VrTjU0YVM1MEdTVUE4S3RMN1I2NDNpWncyUVFZVmFLYlpuMHBzSWNvOHE1VzVyR2JlNyt5aGlva2lJb04vVXRQNFo2UDlQOU5mLzhhWUtraDBGemN3Z3hSSDBDSzFyL1grQlc2cjJJcmUxdFU0d0FHaCtaa0xnaVFvOUs4bnZBdVQyd3NCdXpIVUdYQ3k4NUhqRlpENC9tWDlnSkx6QWtOem9aOXNHczg3R3dHRG1tekI0UWJrZWNCVTJaYmx6eFdIYURMcFhNWFNqVUEyS3hXRC9jNENpc1JWVmcwSWhXRUtXOWhjODJ0Q1YvcC9XN1NBN21kMnMvWDBFZlF0aEYwNVFRZlg0RXRyR0Y4eTJrOWdCZHJYQnJ2YjRFVzJERHI1MGZOQm02OG5oUlc3UWhEUy9xMUFQelEzdHU3UU5xd1A3THVwUmZ4MzYvVFZtMjJVZUpnTWRDbHI5WWE1Rit5K01JemJXcUtHdkU0VUI4YVZ0dFIzdVVWY3FPS25YaUxUTlJKN1FVbEVwbnM4WHNubmsycVl2QzVyR0M2TGpPazU1dG95cStoZnJxV2h1NG5zMTIzSGNzVy83cVNqNGhDRHJud2dFb240N3JhaXFrdjVlc1JRWHZ6akU3c3g0c001b3huV1pndWt3YXdiejMwaE9tMnY2RVIwK1AwOEQrb2Z1cG1IL1NSYmJTU2Zwcy91cGRzaEdYcE9PU3pLRkVzY3lLcktweVpDYUlqcHRxb013TzdRZlVrZy9rTmIwSDcxcnN0bUVqN0c1aVlVcmRTZVNYUkdEQkJDQkRVL2ZOQTJoeUFzeUZsMEp6MkgrU3VGaCt2RGtNeG5Uend1Z1VZVUMxcU84cXJ1S2pXMG5hcmNqQnlLS3E2djVTQzhJMkVFbzcrOHVjNHM3UnpVamdHS3QraXltQlZ6bTk2T2RzclpxYlZaWW4xcEJkMG83cU5reWVybGE1UkFkb1BRL1FEL1R4UGdzUW53bXpSdWc5Z2xJNTVISVl4NmozUDQ4Z2lNdkl0NFE4ZGd2L3djc0hCaFhiUUZVVlhvYlYwL1dJQlF3THlQQmxuU0R0dzhJK0EyZWVjTVZrcXlHS2dnbERDS1NWNURpZVpLcWl5QVRUTkVlcTFxaUNRb2kwVlhKOCtWQVFJOGYwTjIwcGVWVkx5M3J0bXhnVURmbjVqM0x4THBpNjNMYVUyM1pCRzRzcFYyOXNtdStEMUJYNlNkdXlmVWZzd2wvNHJhalBPWTVhTHVMekxNRkJsRVlGSEdkMUVrWEVFNnJRNTBaYXhVTHQ5ZzhLRFhoMEFrVTBQVC9WVUpTazBlSGRQMFF3aTA0QWFTd3ZLNThWblI4Ui95c3NyNHNQMzRzaHdWVWtsMDdqbTBvWHdrSk9IZU01NUd4a0pZZVhXa0VlL1lFRHp3cXBSY012RTJmWG1LTHFvWStFWGQ4VlNQVUJxYjhQVW1rc2xrU3Y2SGtsRi9oZFJsZEorczh4KzMyYi9CRzVRc3pyQVRVRjJnb1o4N0g1OC9IMjZMbVBEMjlkQzQyY2NZZHdJcUJvK3NBZmlRODdxM0FzOTQ2akd5Tm5pU1JrZlNvL0FxWWNZY05ZaXFYTmpaNld6VFkyQmdwZDViNXljRkQ3TnNrN0Fzam5uNHJYZmg2Y09ubW0rOHdicjh2N0lYM2hpdmh6WGZxRUY4SjRYdXZmcSsrMWpuZFdZZS81SURVMDZlNTRUeitKcXNYMVlucklPdm5tRy9sdHFQUGxMRGpCQVRNbGdlQ1VYZHpJRjB3bks2blgvUjRWQ3FINDdLOHBZbmpZYmtValNQTzN0cmFRcmJ6VDh6WEdQWHltVWVqNHZuemxld2JzcmxlcjMveDRrVzBPai9mcyswTHRqM1BQaU4rTjFBeVlTQUxVZTNqMUk1Z1U5UER4NGR0UWNzTWVtQzEzcHhGQTJ2aUNvb1loNiszNmxEY2hUcmpKVXRTQ3hEZkV1b3U4WjMyTWdLTktkcEhKOXlpSmxxNys1aDR2TkUrZnJ3OVdaS21TR2Zsc25zc2xHQWdaTjF6bVcxaGZQMjB6eDlZT3ovZk8zN3Y4WlE0SzAyY1BnRG9pZjdEUnljVU5BUGYwT2s1OEJvYUhEak4yNnVWeVFIUG00ZTYwRGtKbDgxdTRTS29wcFdnM2hXN0FZbEFFWm5xRlYyRXh3N3VlZkxKL29zWHJyNGFjVk5MUzBGNG9IclRUMSs0OFBpZXF3N3Q1YmpkY3h2VkpJRUFFb01oWDczOXVvMk4xcld6UlhHK1Y0TjNWdW5yTy96MlRVQWpML0VlR0V6d1M1VnRYNmFoUlFxOWlaQXBYaFQ0MDdYSkE3ZmM4cmFiZzl2b2ZQVGlFaUhUUEg4bXV2bXhtMjgrT0RuMmEyeVdtdHVlTjZXeTM2UHJBcXJ0THZNSHJUSEx2QW5xWUNXZ016Q3RaWjVPd2FDNDV2VzNaTTE3MkFoRVllOWZMQjBvODI3eHdOVDYrdVg3aXZlRDl2OFhudXlKMG05OFlIeVJoSXZUbGYxcmE5d29Mc3R4NDlSMmpNb21KaVkvaGRyTnhqTHVMdlBRR1NOQ2RTb1lEbzJJV2lRaWVxRlNybE9lMlEyYjZHcXZXSEs5TURYVHpNL05lY1V4SXd6UzA0MUMvdFNwZjZuVTUrYVdtNnFMeVQrZk9wWHZ0Y1VzY1BXeFNhUVpjWkRKNTZlOEZhUHE1SFA1Q2JkejZ2Ujh0WUpXNXZVVXJ6NDRkL3BVcHkyT2djNVVIL2pOTXpwVUFWOVFFTkZOYlB2MFFGRms0bFdlSEJMaHJzdjY1M2xSVWwrSEpjdml4ZGVCTGl4K0hpNmlOZjJCUjNpVnJKekVEcDFyUHRrRHZQaklBeUR5eC9XUmZJYjRsRTJEMEs2ZWhCUTFzTlVNZ3hDOVZxY1ppYnoxZXZoYUVuNjlKZktmcDVuUXFXdkl5T21kNUIxVWNQREpGWWRtTTlSdjE0RGVSY0FVaDdoVjdqcVEwdzl3NytCK25udUtZb3c4Mm9lb0pyS0U5K0hFc1djZldxQm5vRkFOUEhhSHRwaktObU5jd2pGVFgwRDNHcXBjMEVtRWw3aldaWDV1VFdvZ3JpelVteEh6RElCR2pBajA4OG95VDlYY2dRMDQ4QnZsTnZNblF2Wm15cmFkQll1blk1WTRvYTNtRFJYSlJGa3dmVE9uSTl1MlhkK0VlUCtGWWV6WDdGQ3RLTCtsVkZRM3VBSjVVUmFsMHo0TVppL01FclNGQkMzbGVEZ1NGUkFpOHRtTUljb3Y3TC9lYXNseXk3SmFQSS9oZVAySkV6ZFlUZFVVaWQ1c1VnTmcwN3JoaEx3bXkyc3BVMTJqRjlaVWZNbjVtaVJZRStPMklCVWlSWWtRSDZxMWpDNTd1VFFKOFRGWlZSVFJNRXhGSFBwN3JBMzZmWXRaMFc4Q3Z0OXUva2dpdHpzamRCd2JwU2tsWGFkYkI4Rk1UYnhSRjNvSFNjeW95ZVFMalFWK2IwdkxtU29pQ2RYeVdqK2gyTit3dzk4eHNnZ3QwQUc4ZENZaDFSc01XUVQ4Y0pkSWkvMGJRQTJ6eGFqUmF0SEt0c3pQYkZkN0o3aERyV2YwWGhRQ2cyUVV3RWNNZUYyVm9lNm13ZnhwMEVDMjE3bkxvZmRkRHlPcVROaVVlREtGUmpFTzlWK2hFMlZzMWNOQWg0WmpJektCb1V1SmxsTXBNd3JOSm1NUktsbFAxa3RRS0JYU1IrQ2RmN1JDM3pKU29lN2FudTZLUWpFWElzbjA1MzFUREF1SzdHa09Bb2htaGVtSlFzSE5GVFZqTEkrMGl1TldORlFveDJwUW1MZG1OSFZhY2pSWnhLNnErVUlZbFpBWXBWRW93eDljeURhYTh6T1Nxa3J6cHFNNTZXd2hjblhmcmp1OS9YckdYN1R0ZHVOOEVjVGQ1YktwR2hMbzRtWTlMaFR5UmFvSEQrbFFHSHBpdkV6ZGRtcjA4aVZWdHd0WSs2RXkzRERJZWRqMzFobStTbk1MM0JKM0xYY2I5V01aZXNXd3RUMzFMb25vN0ZHOVZvNlNLOVJoakVKVjZoRkhqeEhwMWdselZtTXVEUC8rTTRTUWowbSs5TEhrUUo1NkNwdjRxYWNFOVhmZ2dtekxjRDByU2VRTmNPK25CRkY0MTFQZUc5U00rZ1lQbnZpTjdUZXpNRjVIbjVBTE1uc0M1WGlGdjVxSER6dDgrUGh4aEk0ZngwL3pLbjlLRUU3QkFiUURZVC9QN3dPZ2ZPNjRzazhVOXluSHNiWHpsc256d2o2ZTN3djNieit1N0llSDRmNk9iMU5DcnpxMzhzT1UraEYxSDk3L1lacnNvc05YWHJMMmxaZXM4U1cxeEM5WnU0ZGVzazZqZnZUVTJoOUN5Ky9qRGtMTmdqcXBSa0dsRGgyTmVnRkhRYk1lZ1VSdjE5dDVQSVhwaFNtOGhOandta0pSSGJqVFlQbFNnNHE3TnVJUC9CNmFlUDhQdnJ4U21iVDQ2Z1JlR1h2NzY2MnFJcFNRUFdFRHYzQ2R3UDdRenlGZTBDUXBxbzk3YUxaOTE0Yy8vUHF2UERWVExRUjgvcjZ6WjA5dmZmb21OSGVOSXpjbWJUdXZFcE9RTi83ckhvbFllWHRtK3ZvZE8wUlM5b0NqanRzUlNJOGZLalR4R1hBQW1OYTdjN3RFNDdnMzlvZmpuamVPNXRwM3Z1NnJIeHhrZS92dDEyQ1dPTmx1MzhSV1UyRCtkNzBkN2FFcWtURHFSTFY2bVI2N05hQUVVS0JHUUNmck1NNGtrWEl0YWpCV1Jja1Uwb3Z3YUhoKzR6eGQwclkzdlY4aWl4MytnMDVZaUR2cG1iZjJ2UFNCeGZ3ajQ3WFRvaUlKKzA4Sy9sUEZqS2dLdWk0ZWo2ZmZlWkRzRzllUWd0YlorNmxxMW5CRnZyMG1GdmFFcGFwYnV0eHBuWk9YWnE2b1lHekxIa1pQcTVOVkorYjVjcStjbVRvcUNFVlM0ZVJMNmxRRTdETEw3YUdyWlM3MVg0UmlBNE9KeWxCMGlEVWJoUEtoRG55Wkp4TGxxeUJrT29sYkRQeExESGwxa3FxOStiRmJibm5zbHVlSk5CNmwrV2t4S25tZXFFN2Q3SVh0L2M3ZlMrTUVJMjNzbHQ1NDVzUmVRVko4UmVKSk9qdGJLZTBSQm5WNzRSYWF3SEhYY0lPNGNwMW5sTk5JRGNkdHRQanFab3hqaFJSNUs5c2NteVRZazIyY1NxZjBzcGFmeWVDa3pReW8zMnVZblNqTnJQVjBYUWpuUmFSZVJOMDZkWk1rOVRiQUNWSVBxQW1lc3FCdU13S0FRU2hyNjlZZnVPckJrOW5XbWZidm5UejU0SVB3dmNvN2U5YTc2b0hXdGUxTys5cldWWENoZGFaMUxYck53U3RXOEdSNzlxR1ZadjN3SVJDeVZ4elUvWDM3ZlAxZ2U3bzdQYjA0dFFwWERyWW1GOW5jNDA2WnRNVHVSOHNUUUNHb3pqTEltWllyb3JsREZoQSs4QUE5cnBZZmZMRE1NbnZUOHVVSEQxNitmT3dQSWQyL1BoaW1EeDFLaDRONXBrMkc4Nm4vUXBNTVZVbm1ZdzBTQXlwSjEyZTE2R3FjTnBXbE1IaFJRTUVjWGJDMTNwTVhyNW1abVZ4WUxIdmFwRERqS0ZyR0haKzJMYXRRc0pvTzRucWJtNzJweWFtZWJwNkpuYXF2NnJGclY2YnMyTDU0MGQ2MnNTWDV2MlR1dXpJWVRXN1VoM1lGWlA0cDdoZUg4MlFFUUUyTE1oSTI4ZFNwUTZtcFY5WVVraUxtR2ljbHdLQmVwcDV6bUxrbDBqbS9kc3NyMThNSVZMMWFmYkJlc2hXTkxJNGNYVHBKTDFUYU5VcVVCVGlqODkwcnVKRk1oaThrTStKTjZnWklGYVV3ajZrTHlwbkxCRUNVczNzaVZSZWpjcjZUTDBlaXJrYUxzeHF2bTJuVG9NczJWQ1JsUFZQV2hFUFh2dGQzdmJSWThqU3NXcEtFdnBEeHhtMnptQmtmdjNwOFBCTWI5cmpsSzRLc1lGOFVmZVFaMVlEb1BFRVNueWxuc2xrSWVBa1JYaWZCVFdJT2JiejkxdU1QUnpxYWN2T21OTGQvTEpPUFU3S2Npdk9ac2Yxemt1Wkw2UkNiY2tiUVhGelhvdGVmdUxYL2Q0cXBTUEpSMmRaRUJ5TnhyNS9aYzNpMk5oWm5YY2R4czZWS2JmYnduc0JSZFY5RXVtMGh2WFNnbGlzV1pZeENTUW9SSnNVNFY3dkhONXltcEExc3pFazcvZCsyMEU5T3g1Kzg4aHpIamZpaTFFRjd2Snk3ZXVqYlE1ZXZGSmhmZURsWmhFdkQ4dkJzSDJpdjVjVFBoeUZrYW5qck1NUThYSjQ3YXF2WkhKdXlUTmN5emFQTDdUM2orY08yeUd1NFBodVg5OTViT29RSm53ZDFjMktzSHJsR3BSQVpXcmtRQUpnNzZhNnV1dWhWaFZxOVpDbUdZdXBXenE3dG1TelVVbzRVR0tLRjVvdjFYTTdkUXJJOWxxMFVVMjc2OVVZcTNtOGJxZUkrODVCNzZwUjc4dVJvL1NhQWV4OEZwTVoxZjZoYXc0WEcxUFVkS204QzY2Tzl2KzVIMnd1TmFjVWlxT1JvcGJ2Tm5UbytiMW5Xc1FPTCt5ZUxIUmtKaytsVXBicm5wL2Nia1cyWm1ucWZhYWNkVGJXY3lGT1ZuL0lMU01UcGRHMTZyRmo1OE1tVDVkWFY4c2QxcytDTTc1c3RqcWM5d2RRSm4wbVZKdlA1VXJib0ZVSGwwQ1FpUDVKSlp6WFZ6MlJ6aHZZRE0vU1JiT2FpWE9wZnlxZE9sVStPWWl6S080SGpvSkpUb2dzYW95YjFnd1JaajlhbzRUL3VyLytYbWQ3NHdibHhkcjdXaDFkdWZmaklrWWRQai9wNjh0U0NBaStYVmxDRjFDc0FEdEI2Zi8zUGV6TzE4Ym1ENHpUK3NZZFBuMzc0eU1CZlpQQ094Wlc1QnJlY1dOL3FDMnkxQWhzRlVTUHhNV0JjRlNKTjBESXVjYnRpdmlwd1JoY2V2TDdielJpMms3R2Q5K2NxM1p3djQyN1hmek9iK3RnMGZNOUVTeGozZngvenZXY3lqbTQ0anFFN1lhMTY3cGFxTDZpM1BaUEt2Y2N4K2w4d2ZOOUFCd3ludjRIUmZuaitTL3lnTHlRNGxQb2R6ZTllQTBtTFFRMTJIZGFkZ1NYN1l0S2pxUjlTbTNtekRjMldTVG5PZE8yTUF4L0VWWElGdjl2RnNwOUQ2N3N5MzN6bW1TOE55dmpuNTZxMVhPcVoyMVRCcjk0eXdCZS9DMlVSUWRJdGNpZTRHN2lIdURkemozTmN0UVc0c0Z4bllkVW40WFpuWmZRRVJ0M3NSb21QRjcxY3A1QXFXYlc3cytZOTBmeG9OVVFLc2FoQ1JLamxSK3dzTVgrVVdieTlZbzZDc0VFdnAzVU5DUU1vWGJpRStGN3ZzVjRQSGN5aTExNTl6V3RSdGpCdWRJK1IvQms5NzJZeXJwYzVuRHJSTm4zVjFDVnlUSlI0VVFBOHBVR0t2R0QzTDVoYVJsR0pKQWwwaGRpcEJoS1VBRXNpYmw5NXNtMEZpZ0R0ZmZMSzE1aXVvU21aaDR6QzNIekJTRTJNYnhTTGNRemZ3MFZUVlBhdXJ1NVJSYlBvRjR3YWY5YkpaV3FRcTNrbFh6T0lwSnUvQk55YUxxL1JiSjRuc3FUWkg3TzFRaVRSMVdtUzlFUjVRWkgwdElza0FWV3J1cHZXSldXaFhIMVNjVTFYaWw2bEZ3cDZhb2hiZjVmNU5yZTQvWXo3M2NUZEFTMlFVSDJiNk0waDFmZWh4S0pOSjZJVHVvZGlRdDdBSHh1c3NTVDB5RG9RSU5wNk1tbE53cDFPdFUxcDlMdFo5TkNIS1YxOTErb2V3OFViekRUeTBta1BPUmwwV1hoaXdmTDhmUDgyT1NDeWF0R2xIS3BxdnVCbFBEZm4zZ2JrU28rN01TRkc0UTUyNVNuTjFHUVNmSWtTYnMrcGhIQkJIZ2gzbDVzQ3drV09lVXlzR1BtSnlCVXQxZnBsbXBiNis5UWZCN3J6bTRBYXVpVHBoVlYyYXBnRlVMY3QwZVYyNmJvSkRxNHdXbTM3YVEweGNKMHRRNmhWb21UK3BSNFVVTVFQcjRWUkV5NEdZV20yQkoveE9KV0tVL1k5NzE5ZFczMkJ0OTFEazlYeFkyZUZ6UTk5ZS9YaStuZGZJYzFMZi9UdU41MW56NjZrNkxQZmZQODlxMnNiRTJPVGgxeUxueFBPSGtQbnYvMmg5WXNuWHZHbWQvOFJQRDNLKzRaenhZUFN0UWNsR0I2VEFyQ2NXVzVKTHAraTZUOUhrOXlscTQ2QkJ2TithbDFob25Bd3FwS0ZiRXhqR3NvRjZ1bGJIL29HRGtacmZXVEVla01aWDB0NFNETHpOcnFCeGZEZVlKY0xPaXZuRDk4Wk9OUDZDVDVJWnJEb0lvaDdpMU9xaFBuclZreFRVMnkvT0NXTFBEODkxWE5sWGZXQ1FrWU5UOXduYU12VHVkQjJJV1l0ZjBmTFJKVjZ4dE4wbWVncUJFVFdyZENpUG9aQ0lST0dxcVlia1YvT1dyNm0wdzByTklVUVFTRnE0QnE2QUFNWFBxS2Z0a0pWdDlIYVZNRjFOZDJ5bHE2akMzQ21DcmF0YXBhek5EMkZNZEZpRzk5elBMTEQxUFNTenQ5N1hFOWxNOU5ML2I4SEFXaHFsdTBva0wrcnlJSkluVVlsbVllVUZkVUFpV2JiaWd3Wks1cWlxd1JpeEpTb2tRaUdNNmFMWVVVUkxzazUxeCtSVTFudS91SHVKcnRvdnUyclNZYnJRUWFPNW9PbEpFa0xYTEtEeVBZTUlXdUFJZjNwcE1ud0htMDA5TkFvVmFlTEdUVTRjZC8xT2pTRGIyWjkwZUtKRUFhUlRCU0JFRVcxSmFMcHJwVXIrWkdoYTJvWVpnb0NqTk5NeXRJVnVsTUl0QVMwZytabFFNaG0zcitiWkl5TUszYkt5OUNta0VRRVFCZjRuVWtrVU85RlcxRTFUVkVrVVZaczJ3OU5RMVZFNkJEQUNVMVhGR2o3UWNxS1kxdWFxV3JEZGRVY3VnQWorQXFRMElBMHBaMCt0Z1JDT2ZHdlo3UGpBMHEwQi9jVHY1Vks0bTVPUFZwMjlsbjUzVktoYkVaaFBraVpBTjduZzhEU1pHbDViVTNnTmYxZ09nUzJRNFMxdFZoUURjZDE1d1hlTWgwdjY0VjJ5ejlnOFNKUmdHNVcvcDE3aWFOSDl0VDUzaDAxUlpYa1NsNVZGVnNmZnlnK253L1NsaVVYbjhyb2lnRXNTdVM1N1RYOFNWMStySnE4WENsZnRpUkRUUFJONkd1VDNDc2h4cHlrSUROYWUyQnF5V0VKaFUzYTlaaUN4RVMwUkRwa0dYWEpKS3JVT3l2SXBEQXFFUk5GeEFxYTlDaElpRHBiUXZHcEJaK1pQb1k3MVN5aE92cW1XM2ovbTFZUDJlU3lkckdoNkpKcWwyYkNjTXE0OGhHOGVIVytFS3VsWWdrcFNJRE9FWmdDS0ZCWWxsSjBLYmNZTHUycFZmRll5VmpVZGFrY0xpMnBXcm8rVThtV1FqSTV1ZFNjclJSOEI2R3JjNkYrenpQVGVCSlY4MWdBbklQMFhEc2QzU29SYTJLeEtIb1ZqMDlEcjBPaUlXZ0lZeWt6WDVMMEFQRjVyNnFUcVhRazhVRlJVQU8rakhLQlRwQ1pDdXFsNXV5c0xnL25IaE82L1NSVSszSHEvT09VZTJkdTc3ZWhERXVKNytGZ3hjUjJaMG5HUGxzSDJ4MnloU2pjMlN1b1J2VzFBVnNtblcxT1FUMWtJNThrUzFXMjJRUTlUTkgxSzVoRXkyaUhsNDhtaVg1YmpieTRVU25IdXBYMlhOV0tSSlZYQURtSnVlRHFnaXRuTFYxeWlFZ2tXWUNoSHR1OHFSSExNY2Z6TmNNcys3NGlwaFVEVkVWYmtwMFFDWFlGeWJ4aTJOQ1ppWTU0SkttYUl4bFpGSlYxREFxV0tpdUtMbWhpUmxkdDAxRzFWTFhVS0tLVHM4M0ptY054U1JPenFYcjNLdE1URlo1M3MxZWtjZWpWYmt2Ymhpb0tVbTFLZ2NJaDBpbjRndjdHMlltMHdqdE9FVVZPcUU5T0llaG1ydUZGUjBSUHJKb1dEcEJmVUhsTWtFZzA0cm5Yell4RnZpQ1hDb2NuQm5ZUEVkcmdMUlExN0xUQUR2MFQ2bmVHbE5vaGZZM1ErY2tvM0tIWmRIWklNYUl5ZXNXdUxnR3pVelJ6UUN3M01NZURQWFo1cDVaMmJWaExVV1MxRkxOZTdSNUhkeHg5dTVwSTdoUXNrRXEwdThqYk92elFCdVVOL09EcDZwS29HOVRiWkhDc0FpL3NnbTVsb2VTSUxuN3ptL1lQNGllZnRKOGRpWDcwaWZoTDN4ajdkZnZoOEpjK2xYM2ZONHBQZnVWYm53bkNOL3p5ci8vQ2lGMW5tQmRYaFhRck5HMUlqK3B0YVBNSGtCb05QZ3VKUUFMLzVWdWY0ZUhWRWIzTGdCSVdFczNXSGV5OXdTYjNXNUVmUm5VSmhoV0FGUXZSUGhnbG1JTVpuV2hYYm9SMC9haFVrU3BSZHc1QWJhYzV2REF3QjdFZE5zNXZuTWZLVFQxYldUM3ZkYWF2c2I2WTBsQzc1QVU1MlY1MkRCTW9pUnNIYjI1aUdjMEtnTDVWZGFXV2RTRWk1SnhaUVlRTDdhTWFEcEZSUit2blYxVzdkNU9NejIrc05rNEgzNDcvVkJBUWZzOWFsL1IvYTIrY2lsSVpTM2RucmtRQTZOSG5IemlHWkVLeFBmcC9KcSt4NWVtNnBPZExEK3llVDdDaDVtZnBIaEYrVkI2T2JORFF1d0JIbTFFNUdaWHRWblZJbFRKaGV5N00waFh1akFIVDZ0VzdqVTROU0ZBdlM5U2hOQ0tEQzFOb0NNZ29ZdnRpV3dGTzZPdTJra25CVUV1L2g1ZUZtMEdQbjE4UkVYcVZpOG1lS2JnYzFnM2t1Qmg2bDJrNHk3NEFJenZuemxDcUtFcTJ0dUl6cXJobFVkOXpjNlhjcU1BYjhxZmVpMXdNU1dNSkgvMDhlaEVqLzlxMlpGU242NU9xUFgrVmo5Q0JCMHA1ejhraVY3Y3lRS0o0NzI4TjZYTHNnYzhEdzhlS2ZjVHdacEdJdEcyZWwvaitzRm53TGdsQUoyblhROXI4SWFHMkRndk5JYWhlRWRHNTZpV0VTcTZ4cms2cjlMdTJwbDczYW1RcE41am05WXFOWG8xdEc3MVIrUG96Z3ZETTF3VmhZMFA0OHJQNGZWSDBQdnlzSUw3Ly9lSWx2a2FYNW5aSnlydFRHclFqNXBpdjIybnVGZkErYUZhRXJVUEFVckRnUjNUK1BOeUg2UXc2OUY0MnE3bUVPKzBGNXJaU204SVVkME9YcDgwTDRvVzVEUU1FcERJRllCNzBjYjRkSVVWUkRwMUR5RW56dkFuUUZkMjlyR243NzBYSTFrMmVUNE1RUEhycmE3ckZLWjZmS2g2OVZkTnVQUXB4WWJKNHpTdVVoZmVnTlNFUExkRHN0SnZRTHJZaENJYnRJOXhzZDVvSSszays1dWZLblU2N1U1NFRCSWkxSzBmSzgzei9iNzUwKzZBZFdOMnlkSVVPM1dXRkZuRjNBVEV0dnRpdG8vOURzNy95ajY5TThqNTZtNkxjQnVYb1AvK2U5NkNwenIyajZkUFlQNTI5ZmNUV3FOQzlDcU02NmRaQlEwV2JQOXQ5NXp1N1AvdnhWdnNIZDE4OGYvN2kzVTgvdmR1SGFwZmY3a09hMW4rZnBsRm5YSHE0bC9tS2N3SjdkcEx0YnpSQTFOMWttejRvTHJYblZkb01MdE0xVzNScFg1c0I3N0d5MzBpNXZ1U0x0dGMrcW5hMTgrZnoycmlnamtrOHhzSmRwby9XNHZpTGloL0tzZ1pmd0hNQUswajhnbzMxeVlNRlFjMEVlc2JKU0w2WitYQzhZNHQ2WTFLTzZrQzNZdm9WaUE4WTVFRmlSK3BRelltT1VaTk9xOEZ0b2RFcW83dGZyaUQ5alRqKzdSK3pJT0sybjBHSjdacVZyQWtERWtnV3BsNDI1Vms4eHh6bTI4TU45Z0ptTFlJN2ZCTkFQYlVkZFNzZ0cyOVVnQlY2SUdzTTQ4dUdJU1BrSVY1V2J2U3NPeXovaVhYdlJsZjIxZUNXOExUcWE2Z1hJMTc1YjREb01RYlY2UHNTejhkNXVnb3ZuN2Y2WDJNK1lwczcrR2FaK2FKUVd4WXpZd0dIbytzd2x3VW9TNEZubTBZQWVFbVdsQ2VHQzJEemFGbmcrOC9MMUQvVGJoUFE0VER3cUx2b2ZnY2k1a25iNW5GSmw2Q0VtSkRuTkFGN1NOTFJQZzByaGt4Tjd5SWdjVkQwZ0dvU2tuaFpiSW5xOTRuSVE2aEkzS1crMXBlc3dxR2d0N2E5OGlhUEJsdHZWWGJXNEV6bDFiWnNzOVUzaU81OHFHeXZ3Wmt0dEFvT1czclRTQmJqY0tQN3BCU0grNlRRR2N3NmRmZjdFZHVsdkdwK2RYWCt6a3UzVENsWEZsWlBuMTY5Wk5zVVJtTWIwajhQbzdoQjUzcTdkQU5GdHVFRjM2TE9qRFUyWWNvV0Y1R0JNU1NxRFBiYTJvZlJWUTg4b1BTL3FDalBFZjdpcDdPMWxuSy9GUVNGUUR1a1FSaFkrcTJJSEt4Y2YxM2xBR0MxN2pOS2pTZnp0VXo4a2FEZyt3Vk5LOUJuUjJ6WUlrajdnSzZZN0ZKdnJtNVU3N1RxM2RBZkhubjRFb2ovNGExMzMzM3JvcC9OK3FWeU1EVVZ6SXYreW9xL2QveTY5ZXYremE3ZFZMTm5YM21UdmVlOWUreURHd2hacjNqK0ZkWlZ2eitvNnppSzBYVXNuMHZ5R0tTWnkvbWxKSjN4NjhZaG5hRThIa2NQRHQ0TGZsVHBSbEpJU2pXYXpyQTgzSzcxb1dLeWYrVUtDaURGYm1Ib0pUYmNFc0liYXZkMG80ZEtmYmdkQk4wSm9yMDFOM2ZnRTNTbmh6MU5SUGQrMk5Nb2xwb1RKbCtJT3pOSFQ0eXhmUjhLeGU2TS8zZk4zMmllL0NEYjFTR0wyQ0hYLzlac2UrRlVRSkFXSDZzTTlualFZdi9LYmYvWUhsdGpOc1p4WG9GUHpMT0o3c25BSzNWdGlIaG1YUURRRWY2YVA5Nk9iems0ZVVWQU54ZGU4ZXV1Z0dSZE5pZjJ5Y2F4aFJEOVF0QTRlY3RNNy9wcWJOalpuSEQ2OXVLc0x5Qko2cjk1MzBUZ0xWekJ0dEVabWIrblZ2WlppdldLeU1MMUdxZ3ZjN2dyUmp0eDBHVVdHb1JHcUp1YmhjNzk0QVpWalZYbDhIODhyTUJSUmJkcmFrbFJ4OCtOcTBwSjFmWWNWMDZkVWx1YVhpeFVzcHJhUm11blZRVWU3L1hnYVVVOUFlOHFjcVVpd3pXMXlmKzUybEpWMzFmVkZoTnZMMzZiK3dMUW9rcjNnZkpBNjJsU2RUYWs2NWNyMFdCWjJmQUFYTkNrTGpqSmFscmdUYUV6YjRkQ250ZHNQcVBNVHRtV2F0dVRNeVRMMnhyL1dGZ0l3d0thMGtLRUF2MXV6UkRVdFkrOVJWTVU3UzFKK0xFMVZUQzBMN1BsYXNONXJHUy9CUW42b0U5OU9WZFF2UmtBMkFFa0VnQWtoQjdTamxZUXFaTjJrM3k2MTFodjlISTVlamczRXY5SEZ1L2xrc05PZkdSdlVJV3VxWWdnVVVncFducjB2aWVldU8rVzVkN0cwcnZPci8vUmZXZVhCenhwKzlrcTVGeW5qd2NvWHI2RlB2M29VbS81N0gxL3RINytYVXNidTUvMUNEeElIY2JiRzhOSDBZOTZGbVFRY3kyUHVpamVHQlFEYlJkakJCOUV5VjdHVVpQVW0yM21FZ3VIYmtTbEZOcGN1eCtkV0ZzNzhjcTF0VmV5NCtaSW5CNEhQcFhKUGhhY3graVowSEZ6dmFGOEZpaXpEdmUybzZPK25pNDhIelIzZGdlaXMrcEJmZjBIc3R4L1RwWi9zQW5QOU9RWFpIbGVYdSt0N1g0UHNTbVhYYStpOWZYTjRhdUlXK3V0dzN2d2RtOW5EalBaQzNuUTlvaTFkdGRMV2hzZ0ZxVVduL1FFdEg0MUZQYnFYSTRlK3MrUG5LQno3S1QvRkR1N21nWG9IRHZaa2JmSlhnTUJYVWVYdU5aV3l1MHFkVG1rbEcwRThnL1dvWTVvUFRrK0xQZldvSnFieVNGWlh6MlFqWVRwbHROMFpRclFsZm05ZGdlcjJHcDBUWFZqdUkzaXpqcm9XcDF1VU5CcWxzcUVUbHV4aGJ6dDFSZnM1K3h2MnZUdkR1cFliZFF5ejJWcVNsU293Tmp2L3hPUEJOZDgzbkFRdDJYYlIrWXB2VmZ0TGVhQmpUSm0vMkttVnN1Z1prcmx6Y3k4amFSYS8wL29yTUNJSGp6RmRiaEQzQnIzTFBkNzNCOXdYeDMxZUUrYWgyNXVPYkRnTkxlL0RLY0ZoTzZzVldZd25xMlpINmhkd0tDWk9URXgybEl3UjBFZEFSbmFhZ0JjR2s0a2s4ckFQcE5ZdzRIckR5d3c1VUZLQVAycGp0QmN3Z1A3eXREU1F0VzJZTnZLM3RuSE55SW1xYUdCT21PdGh0K2dTL1RYYWRWaiswWE85bk4ycmVVN0djLzFvcXhISjB4OGZWRzJCYVFpbms0b0NSQjR2aWo3bGZGQVVSd0xzZVdCK3FxOVhrU3VhYWlpSm12QXhuUURjSjRrZ2k2SEJFbFZiREVsbXJicElsNjNMWUJ5a2hUS1JPY0ZHVW1DUmxQUW8wQ1RCUUJjOC9vaDE2VExvL3RiOWdVYnhiWE1XcWEyYXR0L20vYzZpQlhITjAzYnJtV2NIRzlmb0QxL1hzVG9CR2pjU0tZcmNZN0VwcEl1OGFwQWpVQXlzR3Y1RmJ4a3VxcUlNSzhwQkVHcGFKRUZ5WllrMnpWQlZiU2tjc1hPUkxHR0JSV0Jjb294alNBQ1dnN3dXbUZyelhRMzNGK2lmV3JZNzdsazd3dzlXU0ZXYWJlYVBOMkIvMW5vMi9JbTRHTjVjVkh1cjZQNS9uTnJITGQ3dldDSjdzcERkOTVKK2tzejZMSVVLSUtuUTJnWnNiMk5ndnB3RVRyZmJML3dITjE2OTdtL2w1K0xuNU1mUnJud2hqQ0hZcDNjUVBUMWkvSkZHVDdyekhWWUxnYTVYRkRNSWFMclVORnNsdUsxYlJrOWFyL1pXYlBSNWZaeEs5eGwxQTQrcWcxRndCSEo0QnNOZmlkZytQMzN6dEc4YlVQajJUSDdnOEhPamttNGZkeENHM1ovRFRUcURmdmljRHZGdFdHa043TEhJbzJ2cmEyenlPcnE2bTVNUktEY1ozYTgwSVRCeGtaMGF3dTYyZEVzU3JZOFlrcGFSQ2dFWVpzaEFSNW1HeDhWVUxMOUVWT2U2b3dqRGlaTzJOWklnOFU5MThWcVZzNkN5SXBSQUJFMWRtelRIcCt3SjhiaDZMemN6WW1IVk1kMDdaaUlnNlZCLytQSGYvZVNtNStLTGJwNStLRkRnc0w2MHlMVS93aFhnL1k3QWpMTkVxWVFtVUwxS2JvUjZrSzVUWjJjZC8xVVFSUktnejBhazkwZm8yVFI2UGFta0d4SHlLbVZ3U0lWak5sU0ZZUlhORTAweFlwaUtoVTRhaC8yeVhrQ0g5OGt0OTVLL2tOeU1KT0xIMTVCMjM4cnVpYUs1ZGNSVlNXdks0dWk5akI5Qjc3d0tMeEFmY1NUWTNLWjZaVkpmUkxiWDQ0aXFNNkFOZEh2djEvMjlma1UvSC95WmNyMzlEejdPLy95UldIak95bUxUZmNmNi95N09iLzNaZkpjZlBuTWRtVG9FdDJmc1VveC9jQ0luamh2RDM0U1lGOEM4cnVnUmNFRFRlRGlnL01ndWRBb1lKOGtma2RzMmdTdDVLcEJWRE4wUVZORG90K3BrNGtnSjZsMzRJcWo4WFcwaUhPNXJLL3MwVTlJZ29qY0tCczZ4QlJrK1F2aVRMNlF5b0NRTkh4Q3hocVhUWnVTbExiMFFORGRXSmVBcFZwaDFnL0d4SmkzMnI0ZGdNNXVQMGJOY1h4Y1ZteGgxRGZQQVkyQUlYTXZHWmtqVTVGazZJVEJEUlJEajg0ZFdJZ3R3Tm02bVk2NGJCWmtrZDk4dStGbFZDb3piT29kZXY1aXg1WDNaeklzVElZVHFETituS2xsc3oxYnpYaUcyMy92d0VlMjk3WlFiUVhCWTc3U0NyYng4QnJncVczYk11Vzh6Y0Z1M3ZUWFUzcng0TCszdnI2MVJkY0ZYN0wrejlqaE1yVGdGV2ZBSE9iUG4xOGRETzcrZHlIdi9qcnpFeGk4NXdMSHBmdDdmd09oeE9KUEc3UmVrZHFkTGlBQWFwQVlHMjd5c20zeUJ6S3dEeVZZdlNXQnFKZW83Ty9TQlV6c1ZnZEVlVlJBUUVzUS9kU3FTK2dFRER6UlhCWWgrYUdsdDlsbzBuMTVnTG84WFFBS3ZDRWs1UnI5UUNjSjJXcG0zMFQxOGl3YXpONUFuNVJtNmZMUXFJQ0pCSjJ4Z05oY0JIQkphdlVkUEZSbUswanAyb282ZFltRW9WRWJUaDEzT3dES0lLeXovQ1NvWGRCa3I2UERFbzhWdWhXZ1JIY1hFT1QwdnY0TGpIN3ZraVhCUzgzVXNqWlB4YklzWXJvZE5jS2FnZldBRitqZUJOUU1BNEVqRUl1SE0wSGlSU1VVaVlBTU9rVU9tRVFDVE1LMkhTUjBOd3FjamdXQkFNS0FFeDZMU09LSkpTZ0NKdGhBV0pWTVRVU0NnQ0JObkpVY3JDRTZhUytwTG84TW5sQ21aMHFpVXBld0pxQUEwaEd4anJHSkJFQU1xaGlKZkFrVE93MW4xTDlINFdWWEJGSWd1a1FZY295Vk9vTHNNRnc0YUxBVnREeVBKY3BLQVFYdHlYd2s2U1QvQW9VbHZHZ29HdmF4VkpJbDFSQjVYNkpyaTRIeEJuekVoeHBHQ3VPL3ZFYXhLU1NkQnR5bEl3SHJDay9aTXcrNUE0eWgwNUVHc1dVZHVMWWk4S0lrdVFKZEd3ekFSMUlBOU1pQ0traUVyakNFTWhFZ3U0bVFwaUhrcUpnSE1rc2FJaklRS1pCd0NnUHBKVU5BR1VpYjd2Vmc4blpPajdDa3B0c3BxQnNVQVN1eWs1RkRhQitlN2dVaGVIejdqWE9BdWVoZUlMdjJkVlNHL3A1MDJML3EzS3RlOGQ1WG9JMlAzbkRqdVhNMzNqQWNVM1IvaU1SMkUrejREYzZpb1k5Y2JXQTgydWpSdjhuTzhYdVBkKzQ3T0RkM2NPN0RoK2lWUTlyaGFib0NjL3B3YVk1ZTNyWGZUY0QyamV4MHFjWUFZNk84QUdNak1kaUc5WkVWOCtoZVhWV3l0M2VQVGlOc2FaNTUrOElVNkZTMkxDTVZDNjY3c0pTcGFORE1YOUo5M3IzcDFFZllyeCtnaXpLMzYzZVFPTWJqSXBwVkhpV2VLZ3ZVZjdMTFpwWmd4QUxPb3dDL0M0QUtSaTF3bmZCa295cEt0aUpicHF6YVdwVnRrcUxJUUYwVitycWNRbFBPaEFOZEhuM1pzQUM3cXViWEpkR1pzR3JaR2VVaFRVVVBQWVJVN2FIN1J1bTliL3NYTmdCUHNzRWRSR3hMa3lKS2RxTUR0V01Gc1VsRU9tN3JnL2xZOWpzd2ROM2ZYa2xxU2JycTZwSk1mL1JHT2kxcGhDaEdORzVXb0Z5b1ZtbzFRbHUwUlVXUjBBYmNsVXlWRjMxMUVick01Wk4zNVBPU2RPK3RsOVB1WHdCSkFiaFVjdXltR2ZMSVVTUnBsQmRTVDB5Nm0rOGt0V0p0cjZXbUVJMnRCQmh1Z0F4QWphb3ZkUWJPS0ZzSjRZU0t0U0VjZTYvZHFudUI0OGtmWEYxY1hGMDBXL2FTNG5pZWQrL3crbmVIVndaOE9hZ05Manl4U04vNDZ1Q3hwWDhkWHI5L2VHV1hUUXRURk5JdEVZL1pVZm5CRHdaMTJ3TkJSdGl1R0lsakRkdmVQa2JjK3M4WnJpNzhHOGhMaytvUGVEcFdUSUZ5aDhMYytLSUlHc3JtRm1yS2xtNDdtZ2tqWENSSTB1TnBvUWppVjZndGpsc1dERnlRRkxSdE45SGxhSlB1ZDkybGtKWCtBMG1ZTVJ1eURZdjgzK0MyZTh6MWpycHRmRGYvWUFaVEJtQ0l1UWY1VldOdlZ1bDJsZXhlbzlLKzZ4T2VteFZGYTN6enJ2YXczeVkrMmRUdlpkdXZyOE1XTzdmb0R6T3NvRFo4T3RDRDI2MDV2c2I2RHR2aW9nMUFpSzBJYURaRzIrdkNQQkIxbm9nYVpaN0FHQVg0QnhZaUFJL2xGY1cwTFdCZlhiWTUyYy9sTytPTGkrT0xPVHVOQ2U4RHQ1Vmx4cmpoU1dCdmxDdERUQ1FpdkkxVGd6UFhFM2piUDdYOEQ2Ty9XYkZGZDB4bWF3Y2F6R0UxOGE3dHRsaFZsakgxNTdOUTNCR2d1L2JQNmE2cmkyZXo1cGoveEFGaGFCKzVoYzNSRlVFRG9pdXdRcDg0UGpDRkd1QitVTG9CNVVHTDBzSDAwdWZ1enFrRHA4NnM2OGFtR2E5WlZ1dzQ4UnI3alkvNFBBdlJ6ZktrM1A4SFVITkNOVlpEMi82NldsYXZ0ZTNUOHJqOE5kdStSaDFUdjA0dmpxblhnTTcwM1RFMXNPMEF6cEFIcC8rd3N3Y0I1WmQ1T3JzN25OVm1XMm9GRENPMjJTWkFEQ2w2ekZXYnpRSHV4S2kvYXlYWlM3b09jR0dLL1JCWXU4UDIvTnFKTGFIOXFNTzJxd0ZtQzAwcHpjaThjNFBEeXpOMEM5L2ZBVWtHTWdPcmlEZDRMRXV5cjRpZ2JSczhvcUtFM1JMNEJ3bmFPTnBVUkY3bGNYQmpGK2s2NnQ0WTBHVmxvdExzL3pXaUV5dlFxQmdDMXQ1WXBudEx5eXJyT3J5TWFjY0IyVUovUkFFNkEyWXh6RGJWU0h3UkdGWWUrZ2ZzYUxLY0N4cUNBRitxTWRRU3R0S2g1OUxnUy9jZ3ZMRGVmMkh0bS9hZkZRcVRCVUEyOFN2bVA5WjdkaFhGNitzWDF0YWV0TzE5OVBwazRkZmorS2ZtNTd1OTNqalZOT1ZkdjZVenVtOHROMXd1UytVVkhsMCtPL1NKQlI1UkdZbFhreTM0cVJvQjRHdjc5ODQ2dzk5bW94YWora2djY2NuUGlzeXljSXVhb2Rab3NMa2RReGtsNnlxSGFQQzF3ZkV5NVFYRnpVSWNncmZUM3lHN2pNWlF2UDNPaTl3Z3NtWStPUHJqSmNiMncwKzRXZld5SkpFcnQ5Ti8rM2FNRzdHbHZvYjVCalB2bFczZlRXcXlHUDRFMmNDTjBBOTN1N09NL0xjNjdYRG4yVXVkWWRoQzNjN0lMNTRsN3A2UXQyeUpGRlRaZmpZekZzY0NBQkJaZC94aUp1VzZFbFZnWlQvSUZpcGo0OVV4MDdWMFFSWWtYWlRwejNZQXlJTE9SU1JOc1pWMHRWeXYxdUpTUGdCeEo0R2drMGhBclVDMU1kVXpVNVZTbkk0TVFmOGJpYmNWZ0s0S244K1h3MEJYYUUvVm82QllxbXFSSnNJSXFPVmpQOVJVbm5ja2c1cm1SZFhYYklVSGFRNndRaGRFMWRZOXpaVURDeUNob1VaQjNyWWNPMTNNRmNybFRDbzBBWGdLeEhNTHVZSkt0MHJtOUI5YWF6Y0I4bklKK3QwcDdrYnVEdTdWZEdhUHl2VldzOHdPTUdhcDlBZCtaQStPREpTekxkQUpEWVkvOThGK3N3UEFlVFNNdmRSek96Y3ArZGxiZFhUZXRsZHQreUlOVmxlcDhlWmEyVHhzRVJxOFp6djJqbkhadEFnTjNyb2QreWxUSGljV0RXN2RqbjNEbElsMW1BYi9lenYySERNTXNmUlJ6QTZQSndsQWNIQTd0akRJaWNoL3ZSMjdaNURDWWZOdDJ6RWp5UWlDVjI3SFJuUzVpTzQvNFEyV0ROU3BHM0hpcWc1Y2NobDViTGxHTnlKVUU3MzVpZ2RUWlRPOVNKWEt4YlJaVGowWXRyNzczVlo0NDQwTVdhejJpdWxGVVBrVzA4WGVhdit2V25FcnV2SEczZnZHeUd5dmkyR2FVYmRwSmp1L1VCbGFxUS9YMUtPckJzbGllYUo0MnlMTmVmRzI0b1M4ZU5VcWFKZFh2VEZKZVVhZXBpdWhXdFB5NHVBM0kvbHR6TnZrOXRKOVRZYlN3VUpVTklENFp2eTlPNWlKRFprOHNJUUt5SXhFWE5RbzlxSUdNN3BCK0QyZnZNY2l2aVFKZERlOUJyRGZuR0pjZHZZeVE4a0I1MjVncWxHbGJQUCtqRHFwUjFQUFpkUXBMWVUyN3IreDE4dnZNUTJxaXZpZzNvR3VjV0NzZSsvaHcvZDJ4dzRnZHNHbmVzcmN3ZjJIYnV6L2FYZEtYK2c2enRLVVB0ZEVJM1NpeUpDalNIQm5mOWx1dllrSEZnSzB1WEo0N0s3MzNuWFgwVDBMaDFjMi91ckVpYnRQbkVEY3l1R0ZQVWZ2Z3V0amgxZjY1K20xdTArTTJGcERya3BYTjZMUlh6bWo5bFhNN0t0QkU4Qk9iUXJUZlQ2amtRMTkwTFBKRDUxUk8rdk1USmhERytzNm1aa2hlcUtMb0htNXZ3V0tRRHl3dFdheldaU1lXLytZM2UvdHpQa252bXdjNHAwUzJ0eWtHOUgxZThuS1I1SDU3RzZpQzB5V09TREh5b205cXd6ZmJyS1hkYjNUcnBkSm5TSE5HdkhwM28zdGkydHJheGN0SzUyTnJ5cjFYR3UxczI5Lys1UjFxblJWYTNsOWplN3dQRjZyWnd2dTQyNnRwN3lqV1BoWnBWZHpIeStjVzk3ZEozWDJtNE90Qk1hR3pUeWlDeFdhN2FHak4wS1BuQUdsOXdzekU4TGY5aG9uSHpseit5YWNubmtFeFY5NGI2UDN0OExFeXUxbkhobmlzQzFJYjJhQUpLY1FxZFFUNjJtRFR2elNkUUdWMnRBUnhLZWJLdWFadS85L0hKT1VVN3FzbjFLa01ZdzEzbFVSMG1YMUpsWFdFUUpOWE1OLzVWWU4rZUpGUmErNldESmVKOG9pRW5XVEVGT0hpQ3krenBEd3Bmc3pGVWZ0TTkxNm05bCtLOHppR3pCVm9qblVIN3BucFpVVjZld1ZvT3Rkc1JNZDJuQytkK2tORmgzT1ZkSGZMbEk1bDFtMzlqS0xEbzhwbzJ3MnBFdCtXNnd6WEJDZC9EQlhKWm04R2Z3TUs5MUVlNThsL2Z5N1JjbGFPbm5pQTB3SVh6MFMvclFLK3JnaUhicnF4QlVTSUMya1hubjlkV2haTXZ1ZlFUM05rSEkzTUxuOUViYlAzUnFMdjVOS09FL0JoUUpXUE13clltbVVQblJWRmQwMWNPZTMvd3BvQVA2WmRFMTJVUGZaSWloV2haMmxHSEQzSDFtWmJweWpDMW83YzdKQ25lcEJrdHBrN3BiSGJwa2pOc1h2b21zcW0vOGZhMjhDSjlkVjNvbld1ZnUrMzdxMXIxMUw3OVZWWFZWcUxhMXlTNVpsTGFZdFdTM1psdTMyZ214c01NMW1qQU4yRTlzUWJERENnQ0hBUUNkREFzRWtDUEtJQ1dIcEpQTVNFZ2lZelNISjc4MG95eENHa0l6ek1pUWtZY3J6ZmVmZXFxNXVpWVJmM3BPNmJ0MjZ5N24zYk4vNTF2L25HQnZJWFd3WXY1Sy9iVGVTc2QyMzVmR0VoRHdrMGNSWkROQ2VSZVFqUnNCaXR2VWh0bW1ZVmNoQTBsVnIxMmhtbFQwa2FPYVpzVUYrZ21kaytaZWtwTXgrRlpac1VaL1RYTzRPUjJPKzBmOGxDbS80VzNKUy9vaEVKUGJydkdJd3QzR2VQZ2VMT1BQTkt3ZlFoNVJtL25XRWpiV0hhbDN4aVZEaE9SeXRPSURGTG4xbTBNb1RFYysxVFVZSTN3ZUZJVFo4SVRLU2VSVjZGcWxHVnBLK1FJaWgzOEJaU2tZenVSdUFLcEl2VEVuU1MxT01ibnZzWjNrWnhMMHBRbFI2amxuM2swNWdpQ2xIK2JvVXdOMkI5RVdpc1VwYTQxVHl4VWtwSWIyTXBPRkdpLzBjcjJqTUdSQ290V2xDWkZZbGMwYmdKSDBRMlZPaDcydm9DOEVDSmNsRFB4OFBhVWtWR0MreFNvSDN1NEVRbncraGVEMUtXaW9VZDVkMmNJZ1hGMFRjRnplQTdBMEdtUHExVG5kai9VTEtDMHkyVW1ITndQdTlrZjMrOTIyekVHaDgwakpOSzhscmdXWkltc1R6WkgzME9LY0hCWE45ZmYyRytZYWVCSWJwMVZVV3Z1L1k5dXRJdlZKS0poUWhWYXRjVjZtbEJDV2gyRXJjQ09LN2x3Y25xdU1UY0laWEU4bFNDSWxJY3d3OEZMczM4cVV1MGJ5YzVTcXE2U2s3VTZQcTFpZ3RGZFZ5Q2tHOFhCcm1Ud0NHdEQxZ2ptZ1NzeEpGaktFNlQrQ1Q1dWs1OUtlREFlRGwrWGh6UDBPZXRCZ21JRXl0aXdMMzJEMGMxK1RZcWJtemFsRlZ0VnMxRUZ6ZHVKbjJnWnl3UEMrTGlwUFROTTVqVVJ6T3MzQXRiaVdkRXptMnlDTzZZSlVueEI1akVsa3B3VFlZQ2lNMnpsSjlJVU02U2lvZkVGS3hZYkxVVmxtdXhiTGQrZHMwb21vbDVTYU41M2tQeGxmYW14QUVwVkdlenFGcWtPVlZqbVB6WFBna1ZsWk1SeW5DNUdTMENpZHpaS0dHaWo1WmJPQWpZRUdmb0padk50TFJvRXg5TFBabzdDMnh0OFdlaW4wWWVLUnlsaUJZQjM2aHRUaWdVTTRvV29yb0VTeEdjQUFJN1lTb0FCR3JIb1lYYmUzanIzYlhqMlNBTUs1anVFZnprb1JKQ2tKak5RWFRyRkUvTXFxZFI5dG9BT2U3Z3hIcGp3ek9Vdmt6RW9qWjFPZFhrRGtXYWd6cmhNNGVnRU1GU3pMemljQlFvZlZFUXpSbUpnVUJtNXlSVk05S3dxajBranFjNDNsVmttVExsMFNHTWF4c29sd3ZqSitXTXJ5QW9pbkl0R2JtOURneXA0Y0ZTY0FNTW93bVNvcW1vaGI3UEtMUHdZZmxaTUg0bENNUWhXUERJNDA1aTZCcFBCM29wc1J4cXNzS25LYXFLUldXTUVMTS9mdUpKRHRtenRKMEJZaTJwTHAyT3U5NXFrS3VBQVlDaGdIUG1wK2ljblVEZnQ5MzVNZ0ROOXh3SDZQSW1pN0piQWNFR0ZreGJGbmxTR3pvUTRGOTE0NHRnSnh3SlVhdGoxMm1kUmZKenJadDdlZ1V6SVdNQ2JXNmZnanFId3hpd253TTlXcGFJeTBrcDJRRVpvemFwdzRrQVJzYXhDRnN6QStHRFFiTkpTY1VTZFJaaWVYMHoxV1RSUWZyMktOMTFOUmZOYmlvaHIxQmMyZ3FOc2Z0UjQ1ODY0YjdsbGhaU3NqcWIwSXpLckQ4TXljWWZ0dDZmMlM3UFNia2IrZUI3WWo0R2hxNUxrVGgrSkdyQlhVaHFRMHZvUHgvR0dlMFpjd0JkdDdKTVNRcnBSekRFbFdHODUxOGZXNXFiaC9LbkJ3cnphd2NXVncrMEhIeWdzYnlUSkFZdGYyQWxPQllyTUkrWVBySm9tZklxWkxpSks5c1ZtZjNUNlVjUVdBTUVDUGRBKzNUeCtjUHJGamF2R0p5d2dpdnVCVFZDQ0ZSOXBQdGI5NmRwN05wOU0yN2k4emdmRHlQNjNZUVFTVThmRk1wNS9DV1dlc2NXRjQ4c2pJanN5eGhlSFBmM0ZTem5uZmlIS09LbHVFa09ZWWtnZFhmZTRUV1FDNVlpNW1WQS9QSFQ3Y1B1SndDcnlvSVRtcHEvMnkxZVdYU1VVb3AyZkNLU1JrVy9ydWNSRHA5NzhHYnR0bmgvZGdLeGdxN1hsQ0NkYlNFVnFrU3pUMksySDZWa0FWQ0FZdjZLNGJnV2dIYUxxbk9lcEZGUk5CdUp6UmJkYnA3Z09vMk82MVE2UGN3U2NEOFZ1Um5zOVpFK3pSSlZYbE41V2R5VXJwRUhqTk5WalpkazFVMHhUMFNWeENkbkNQeWNhQUdvc2l5OE11STg3UEYxSVM3Y2h4ZFRUVFhzU1FtYnBxd3V1cW1hZVNJc2pzRDA3MldzUXltTUttMjlsV2JyWXJzR1M3aGVja2pucEl1bFdjSlQyVGdrYVpLR1ZraFBrWm5jcG5kdVpiS3pUQ0NaYmxFK0ZSbHZsWEpaaXV0K1VveHdqdmNwTDVpd0lCWEFuR1lCcTBhc3NNLzJVMkJhcnVIZmdySVE1TmRVZy9aUElPNzliTVB4OGVTQTY4QUkrR1B1QXo0R25BZVVvYjZEQ1RINHB2U2RaeEIxVWNQMzlTY21acUNpMHpkOGhQR3FGK0JvVm5ZQ0ZERTFOUk04NmFJcjBlWk1nZjlHUTR3NnNmb2g5NUtjOGp5SURyY0ltbXZqMlhTRmVLYlJMRVVkRTZHTDJKQnljMXJybW02VlpHSTdPK3JGc0xoVzk5ZzRWZkZ1N3d0dG11MzdISjd5eDY3MnR2b3JhTXhGczJ3cTZzYkd4Y3ZScmJsMkFhOGx3bWpMVWx0UjBQOXRVMzFjTlRYdkRUd1Jua0lUVVBGZEQyOW1NdmxMY3RhQzhZeEs4TUVMS21ZNkxQWk5OQkZoUXBzVytNWStZb3VSamQxTWFrY3hRajFxZjlWYUppdm92bzNTcEM5ZFZJUWNkVGlLWExtK1o4Ny9UbzI1OFp6dVhpRGM5eDBxbEp3ZE1NaGVROFBlVG5tZGFjTEcvOVRlT1I2elN1Z1YrZjBtOU9PVzAxWmx1NDZ4cHVjREI0cmVNNlpod1JDM1kwaStoNmo3M1pqN0piWTdiRTcwWnNUUVVsQ2d5eDFLQXZpL2tBQnVTT1NPc3FPaEJFa2FQSEJOYURjM2pxT2RxSnVtSk1odWxwb3pwY3c2WFljUHRiekJzdUl5bTVSVlJqSnlFNWtFN0lpSnZNeVNQVXNacjNYT0JHRVU0a2xKdnd3R0paWGFtakd4VlBQRDNJbS90VlpTeVZDMFU3VkRiZVUwQVFpV1k2Znpmb2tiWXFxYmlpV256UVRFcXM0S0RuWXdON0NYazc3TDRRbDZEc0RSMldHZmFzSUswQkJkdU5Fb05mZERBV3ZGa2JhWmk1MlJleDA3TGJZR293S2c0bWFCQm9GNUs3NVFRanBmQmlXT0VBM2FRNjRpRnFUc25tMXNoQ3BLY05rVHFYWlFiYVNiaXZ1eHlOUWZYU2pvem5lcWdONjlCRkpsRFZlbWVZNTQ4UXF4MDlMZ2lwS29pYzRSbDRTRTU5S2lGTGVjSVE5dFF4QzVDaWZsQmtTNTlqTWZSeXY4TUZTWEZCNGhtcTVmNTZCRG1jSkp4RlVqTlBOejdPY29kNXN5UnlqODJoTWhvM09jSko5c3dwTHA4aXA1bGhySlpOTVprNDN4MHlWY3pKQ1lueHBmR2F4bmhDWTFPMjJac0lEb0h4VGpLc1RMcXNwZmowbFNTbFl4YnF3YmpQVW1ZOGgyN0NDaXhFbmpYYlRVRU1OUXlOVXd3Wmluc1E2aUhOT2ZzMWoyS3pmeTZqS0grcTFqUEUxaTA4MTA5V0V0NkIwKzc4VlYrRWZPZTRseHJLK3FZbktIeHVabXY0N2xyRjNQc3N5M3E1ZFN2KzdjY3pGTUtLbmtXTzkyUDAwTHBhYUtEcE5GTmQ5WEpuUlh3Sk5ib2lWSmtTSXlTQ3RoakNPTkRVbXJPbXcrTUgxaTRTUDFzNXFHWGtaZE01Qmx3Z3NwZzNqbTE2Qy9SemVKSlJEbGdjdUk2ZGx0L0xTaWl2UG52OEQrNHJhdmttRjFRMXJ6R0lad1lkRjBtVGlDRWJKYW9ZS0N3Y0xraXdEWEV6Z1VnTzlnUEM5Ui9COEhDN2trajRlZ0hzTm5WVW05OVd1c0VuSXpJUFk1Z2FLNnFIWXkyckF3aHNhdVNMaFZpcHVZditMU2xQTW43TXRTVFF0cCtDd3hMTW1aOW5BOERDTXN5aXhnczRvZ2FmQ3ZaZ29HMWpTbDhPcGdKMmR0RHpDd2cyV0tVb3Q5cytacVJJREt6cGNBczBNVndjS293dXNWQ3h3d29DKy9UYjVCZGpUS1I2T1dBTU9ROEI0djBVU2tFQWtiL2lYRy8vMTNUSlJwbStjVmxKeS83Mm5Ya1BZZjczeFgxUTVSUThSdWYvNVU0WFlNSWR0NkUvWXB2eG1qSXlnRzRrdEdwT0VsR2xJbmJmSURUQ1dpMHdMTndOVkNUT1E2M3VOWGdPWlFTdnVkeHhMTTZ2ejFVSUJONnJGS3pwYmtBU2UvZGtSa3doWncrc2JqUTIrTk9rNDZJM2hCT2pET3VaK3d4MExkelo0ekdUQmlMemcvVzZZRXV2SjBJcUlXQ2NXRXlOck1UZFdpYjA3OXJIWWI4ZStHZnN1MFAwczR5RmREZTFxbmFEWnhYakplS3NUK0pFNzFqNm00dEZvTHlBdFZiRUU0d2dYQUlxeWlhNjdjS2hHVGY4UmhnWDhMMVZMd2dCVENUTWZrUXlzTE1FaXM4MndrV09DYnJVekJGdkFXMEpvakFxbWowVDNQZlN0R2NDUlViczRsVlZ6ekc1WWlCSFdjeEVIT1BYOENSTncwZXl3N1dyb1dwVW56VTRUeUQrdzhmOGJ2VlhFU1lVVVBKM3RBMitvZXdXaVRJcklKZjF2R0VENFcwd0p0czR4eTUxckdVNjNoYVNJMThMWUU5Z0FTRHpJSjR6QUJ5Q0FzZ2tKQkNxWlNBcHYydHhVb3pFM084WFpKcTlJQkE2Q1NNc3JBUzh3NkhsckJxelFYOUZaUm05OHY2RXpiRW8zNnExclduVkRDMVE3WDAvQnNBV1dFeVJWanVmeUNObnd0N290RzFxMnZGVE9hb1pzNi80dnZoOVdrQVFQNTN3K2oraVZsckVnSVJVakRrSVh3dFFpaW9KaXJXUXhyQzJ5NUp6VEFGYVhIc0pYeHRlZ0Z3RlQzM0M2TWcrWENjQWRnbXd1aUJ4MVlzWklMc0ttRW5KS1FJUU5uZ2dwR2YzaFBMUk1pZ0p3OXF6QUtCWXYzNW9Ca1FSYWhKZDJ5U0lLYXFMNGZzYVNOY1pTWlN5SnhlUzYxekMrWXFMa3ovR200alBzMlRTamNUb0hyeUZRU3lmTml6a1M4MXlLdFdJSFkxZkZqc1plRFJKNHJBS3pxZGh1QmQxdGFWN0xveGxnV2NUVUdVMzcycjBrNDJ1dGhjNnR0UkJ5aXRybmdDZ09GSHQrQ1ZNQjVIRXB4TkdFYTJJNXZBaWxpeHBpeGNBWmZCZzViUFYvZEVQamxlMnR4TEZrSzRuczJlNzAzNDNranYzQWFOcll6dlR2VGt3VXJMcGx3VUxJSm1RUjJwVkpwVFZHMWl3SHN3MG9BbWV4aFE2Y3RuUG95QVVkeWlTclBDdllTVU0rank2Yi8rdlNmTE5DL3kyRnY1dnViaVdjdldwYnR0bi9hd0p1dTFGTUUyS0Q2S25aY0kyYWpzY3R4dEJzZ1lVaGFVakNlRWt6Skk0UmJjRzJjcVlWTjBkMWtZaERGV3RYV0F4WGNmbWdLNUxOdGJWbDY0dkwvUytjM0Z5LzhIeS9COExlcmVUQXIrYmZkMkZBWDErQSt4NkpuWS85WjF4RlE1OUdMKzRaakNpRVMxU3hVNXRoS0tNVjRpQzFnTWxIVm5JL2N2K0JDQ1FCMHpNaEFnTlFBeVRPUVNkY3E2ajNYWmVpVmMyd1ZHTzNuOHhRWjBDRGc3dW9WWlQyL0N5Sjg1Z21FZFpwSUFHZG9CT241Y1REQkJoSUZzZy9HVnBjeThrdzcyVUh4QnNGZUFTdS83d1pCeTRQS0tXcjUrMkNKTTBJNkNjbVdSeWZNSzBhRUN5Y2x5RHQ4OEN0R0Jub1pZYXhCVFVPVEJtdytBSmpDcEljQ0FrZ0FiSWNzT2kxUVpqcE9RWmRRZ1RPckRzemFjTXhNeExIamZYL1FsQVpwcWp5dVJ3Uk9seWVZVFJSRkMwems3UmtseWZITTN0OHpZYVo2cXVlNFNzT0RocFhNQnlRcjRCYmdyZHpGVVhpWVpxeWJKeXJLS1pET01NQ1lzSUpVNHhjOEdRYm1TcUcwMlJGeHJWWjRIamRralJXbFRSQkw4R3lOZ0ZMdXBxOXdtT2t1QnRIR0g3Q0pnMlJrNUtZREZSOEJPblBIcDUxcGpONVZSUnRLeU1LRE1kVk03a3l5K1NNS08vQm41TUg2Zmk0SmZaR0VBRzZ3Rk9jQXprSjRUcm1vVXlESFZpeFlTbkFya2RHSlF3TXJzM0RhZ2FySHdMUmQ2cWRhc2gxNDZZMlA3Q1NCSjRRUnRoVG5VeWNhaXc2MEszWTdhTGdVU1VuemVIaGd5VFJvc01DK1JrYTlJdUtXeHhBRVZkYjNSSUQ0QW1sR1FaeEszTzRNSVE2YTFRT1Vmdyt6RHdyQ25uRXY4U3lmQmhUMUZJZnArOFBOY0RId0h0M20ySUlIRENMVG1ieDBMeVAramgwSXExMllaU3l5TEYxWVBSR0t4OE1QZ3Ird2ZyTkRsS1ZlQmZJVUJPYXhzV1ZDb1VtMkRkWUpHMVFNS3l6T05LaFJUN1BNVHp6cXdGMG9hQ1F2R0pyY1ZWankxT0Nva0YzSnkybUtLbm84b2x1amJBTTZLS01Qa1JBT0RBSExSTndDc1BrMDBhbURPU2VseW9JbkFSRUFhazArUllqS0Fxc0NicGdvNGJBdFdHWWlDQ2RNV0pObFIvbEJWNWp4VUNHS3FKdFEwcHpBZzlTSzlwVk9BMFZVd1FZZTFhU2RFYkFUQ2trcnNHaUl6TG9nY3BhdkNSeDZKRXBBZjJYQlpFdzFwZ0hMRHhEWkpVNENtWUk0eGxIc0luT0VKTkpJWVlaOGlhRVVSa1d5Q2JNcUVDV0ZEYUl1MFNIWnBjWTBaTlRuZ0FMRGlFYVRFYkNuS1BLWVlidm91Y3ArMlpQbGhtSjVmRThpNEV2Q3E5Q24wZzhqbnNvT2Fzd0pYSWpUa1dtLzZlNnpJb3dKMjBKV0ZRTkpoemhaZWhaQmR0RTFSd1F5RGdSSFE0SkQvVVFYRllwaUdtRlNZcE9SU3JLcVZJOXkyYmp1dGxRZ0wyQytzTnNpNnVISGRzME9WY3pXTm5nTEFaZnhSY3dzU2tVeWVpRXJLUWxFZG9JSGdQY1FjbkppMEp1QXBkb2xwT3pTVVBoVk1OUmJZT0Z4WmMxZVZHeVJGZ0dPQmttSzQvWW9nYTBwV1JhQXNkQ1d6T0tUZ1IwQ3ZNd3h4d2xSQmpuQTBzdHd3blFmTkFGYUdFT2lNaUJNTXBhdWtuOEhDK29PaENmOGJ6T21iYmppbWtEaEM4T2xpVDB6MkJVeGNlTXhqQzIwQWtXVm1JUlptMS9VNVlsZ2o1SHNGN0RhUTZ1RS9rRUp5bEN3TWhsR1lnY1NjUmkyMk1BSzF1TWI0djBIcDk0SFA2ZXhzM2pJN2xUM1ZncVJEMFlBVmRFejhGaU0yQzdWRDliSzlhSzVDa2w3ZlkvNTZhVm9tS1J1S1g4MGtQWG5yMjJRUGJGKzM5RHppcHUvNytoMW9JVVhhV202LzB2UERRejg0dkJJRitWVDFiSVBlaXRWUEdMQ05rQi9QeEsvOGV2elQzOWRQNytiMC9jRDkrNSs3ZGpoYkFSaWd0cTFsc1VLbUFFK0hFUHdmcTRtQ09yc2RwckpLeEV3dW8vaTl0RVkrTncvOWtMcTZ2UEZ1RFE4M2dJcE5aRW9kRC8wcmUrTlpydkprUGp6Nk9FMVVNVE1OcGxRdnNLdVVmV05QazkzOUxrbzdLbWMvSnM0NlpaMGFpOWh2NysxbnZ3NVBpWUpzL2UxSmlWT1cxN0RCVkx2V0tvamF1Nzg4VzdyV0FnVWZ6Q2c2K2pMMzRldDJjSzY0VW56aTR0blYxNnlZTVAvdE9PZC8vT0VwNFp4alNHZWF0elE2OWFNY3BrMCtMRDMzNE4xZW43Q0RramlyOTF3d0lMSytjVGtyUnd3OC9XUHAwazY5Sno4dlhYQyt4ejBuNFo5MnFwajRUdGdnbGlUMUhNaWRDZms0WWJrWW5YdmpZMytDUGRrUjhqZllVNWV3TWFIUklVTVVkSms5bkNHK3lXNDBTZFhsVDY2OHJpZE9uRTZyM0hqOTk3L01XTFRmVXo2cjNHN21wMXQrR1I2bkU4K3I1eUpoTWI1TFNONUc0c3Q0UVlEdDFoMmRWdFpRY1V6YnVGYWV4ckZNNDdVazkzS2VMcjE0clRjdjlQNWVsaWR2SEl5djc5Sy91dmJkYmxkOGxmVDVWTTNmZnoyUVBlcityTndzTGsvdjJUSmhCYzFValc1YnVVUGVYeUhzVjZmdkhNNHVLWk4yVGo4YnZydWhaSWxuZnNNM3N5YzNDVXQyUXVFNC8wcHhkcERHd3lpbzBKT3pxQ01ZaUw1UUNuRDNtNDF0a3ozdjl4ODlEaXRIdlZaT2ZFUncvZWNjZkIzbDh6Qy9YeFBZZWFNd2Y1eXRTVmQ5NXh4N0hCM0VXZHJJMWUyNE1NcU1Vb29kdW5Kejl0cDFKMi95bmNrdFZHeXY0czduM2ZUdEY1eGdDUDl5NVkrMUUvR0EveGRkQW9QTit1VlJkSlBNOTBvaDNTYklYeWJoQkhMU21zYVNZUmNMOUQzcEZPck9hbXUrTTlqZXptbExqSGxRaUpNM3JjWTVMQXFzWnRrR2NDeGxGVm9HRXNiOWdUaVY5TEorNTBTbzBLcmhXZlYrT1NxcDZCaGU0WFZJOHoxTWMraVlsK1A4R3hiNGJyR1ZmOWVCNmtzSW5FdHRoY00rYWhsOTRXcG1zUjNvc1hpeldSckVOTm42TTFuYkJUL1I4ZUlST3JSeVlIdjFQMnAxZlhWM2ZHMnVVUncyTG91ZDN5eStpRFdrYi9VNkNCTUh5QWJBQmZGODIvTDFKL2ZXSVdpK0xxZ1lrRHErSmc1eDlmZi9yMDYwOFRpM3J1YTZObjZNN2Zuc2J6STFnVHFPKzlCSnVXYnlNU08zbjNTSWU5R0ZORHJjSFBmNlEvRlR0MTQrUnJYalA1bWxHZmJoWGpvYmY1UWJROElheER1NFVLaWMvdEdoL2ZOVDVmVzE2WVdWaXVIYjd0OEhvOSsxUzJqcHZ5N3RQU2lSUFM2ZDNOcGFYWUNIMUh6S2s0dktGQjhnUjQvQmJ0ZTBRM2JjMnozUnJaa0VSQytnOEk3bDM3VnZZZDdzMTg0R2ZmL25aU3YrVUQrZHpxZHliMzdadThaZ1pJMFBkUFhSZlI4cWRKTC9idFliN0ozdE1URTZQOWlaNG5hRXVvaFVKRVpBNFNnOUpBamVMY1czeVpXRy92T1hseTk1NlRKZkg5SjNidlBySHc5bnVMOTlwQzZlUjkxMTIzcDEzbkYvRGdNTmNocFhkQUZlYmEwNlROazRuK2MyVGozWk9UNzk0TU1RMmVKeCtDT3U2SkhjRG5obVp5MUk1T1VsZVdHdVVHTWJoZ2ZtaEs3MUNmRGRTL0JkM1FzbzZHbnNHb0lQZk9DdHdrSjNXU3FzVElwNEJ6TVAyT3hFM3k0alFoTTl0UGlhYmZsbmg2Nm91TFUxT0xrMCtYQk9rcVlEVnNyaXRKWGNIME9ma3FtUyt4aG1Td1Ara1VaKzZlV0p5WVdJekZSdVB4SllvRFVCSkVFTWZJK3NhTFhsSWZmK1pMN3p3enYvRDExS2xCdTd5TDBzaFlWK3pXOWlNdVlmQ0hieWplKzQ2RmhYZmNXeng2OUlsVjdVMXYwbGFmaVBSaG9WK3lIZGtsWUI1MFJ6M1pnb0VqR3d0blB0cFlyNk90Y1BtS2RyNTQvNWt6cno5emhsbC8yOE1QdjZWOXhUS2FIK3U1WXYvYmVQVDFaOGk1Um1OcjdkdWdQcUZacE5jRFRGZVFGOFRhQUV1WHVvamg0S3VHQWVjVVpwMmVpWWVudmxoS0prdkpqNVF6M3ZqY3dibHhMMU8rK3E2cnYvbnhCeFptL2VyMHJZL2RPbDMxWnhmK0xGRktKRXAyY2NFZUN4cUlFTk1JeHV5Rll1dnFxOS8vdWxPN2JzNk0rY2VtRDk1NjY4SHBvL0d4ek0yN1RtMWZtK094Y1l6aGg3NDMwTTJRV3JVbzVrdzM0TDJnRzdJQytLNDBBakNndUNBVTVqRlVjWWh4Y21aMkllRjFhcnV6elluandWVzVxM3ZuZHMvTUhBLzYzN1hTZkM0dVNhUVZaQ3Z0R3lwdHE4bnlpcEtMRzBvbUlLWDhsU2x2TnU3RjRSNy8rS0VEd1RYQnI2UVRhZG1NNXhXVlo1dDJaNzFUeVNSYVJCVGplU0Z0NHp1VENKTUtNNFBmSHZveVI2aHBZVDV3OUF5MGEvYlFmWm1QRWdxMXFIZWJMNVFGcW03clJqZ252aENXWUpMMjBQY0JYYjdhSSs3TDVEd3dyWUttR0hGUEZvZ29MMmRtOS91cW92RnkvdzhVWk9SNVdURkZWaDNQeENlblBjeTN3Z3FLSXprdlh5UlA4SUpsYUUrZkhWY0VqbDZuMjdkT3g2Vmd1c1RMaGlyOU1LNDZpaW9JOHNNTVJ0MnkvVytseURuT2NEVlIwVlRudDBEU1pXaWVTazZiNElnaEt1ak53Q0dTYW1YV1kyQmZFcms5alp5QnVOV1k1TEl3WnpBRVpCTmVqbkFhWWtlaHJkb3hKVFlKNCs4UVpscUtEWGk3VmpNY2NBaHBRaFViUThxVXAvRXhyUzVpNWZ1aFp4d2ZlcngyMFFsbkVXWlZOU2dKWmN3RmowSmtMY3d2UlM3NmxobUh6OVR1K25qbUFKUDEzQXozWDFRVE04ODZzS2NiMEZTVGg3eDBwcHBPOTg5WjhiakZzNVlxYzN5Z3Vzby9FNEd4TklYbkFrMlJsUVNjamIyUXc5TGloZkZNZHJ6aHBSUDJOV0orSWg4NEw1TElZc1pKdTE0NlhVL0o4VUljSkkxQVZSVk85TmFJd0NVMEtJWm5QVGd4R3R1Sy9wTlZ5alVKUG1wMUF6U1BDcnduenRkUS9rYmJmYVVxZHBwQnFIeWxVWjZZQVNrSzNibWxPWDJjRFdZMHJVb1dwcHRPVFZFbld1engvdjhZeis5NllsZDJVaytMVXVxTmt5Nno5SWRMeEozeTVrMXI0VXRYSDlwMzVOd0JJcFYwdlhqZ3lMNURWNmRtRktYcGtBTlh1M0t0Sm9GZ0tRangzNS9meFI4NXduYzZ5VmxWclZ3aUc4QjZRdk9YZEFrWFNnWlBEeVVEYVdTTlI0eUFKTTN3TW81SUJUdDhMT0p1VU83d1phUnVOZXFjS3JaRWFJT2cxaEtnY09qNFVVZUt0Y1N1ZDZhSmYrNXdjZGZjTlphNDkwOWc3enR3NkNMOXRkMXhZbzJzckN4KzhJMFRYZnZ4R3g1azFuSG5JeXVMSE94djg2ZTFLU3BreUVDTDdTQk1ZMDQyUDN2WHJwV1ZYWGQ5OXJkZXRuZGxaZS9MTHZhVWp4VXVYQ2g4VE9tSkg4RWQ0TUhWSVowMmFPUlBJVFlWbTQ3dGlsMFp1eUYyWit6VmlKczRNRmpRc0M0TTdxWUdLY1FJQTU0dVhxTWtmWmJNb1paRW5LTWFGdW93SDBRKzlBS1NBdGRESGRBTTExMWtFUVk4Y3VhZ2VjUXdoSmZVTUJlT3dYek5KRzdLSlNhbkdaWFRNUHQ4Z1RCenZDSDNDT3N1NnBxd2dCaUlmN3RiVUxXOUFrTW1KVW5rNXdqamxHeVcrYXVtTkpYSUNJemtnbHpQMWlkelhQSXFiMi9LTmd1YXhwZDA1UnNLUXdva2JmSUJaK20zWGc5OHBPTVlQSE5XZDh1Q0w0SDB6eTVKaGpETGRYWGlDQkxqY0x6RW1BNGppZzVoR0ltWGdCUklTNFMxU3c0cVdPWkxmTm9wKzRTenZMSVhOTWM2MlYwZjdhVWNWeEM0SUpYZkwvanlwTTFsMUlERGhHd3lycTlBSjFacC9vTWJZdWRpZDhmdWpUMFllM1BzOFRDRFFyYzYzeTBEcGZDaGFVWU0xYWpiTHJkenBCVVBXdk9VcUtKWVBKcDVKVlJ4dC96UWZsc2VnQzc3clhZVExWaHQ2TFl5OUJmd1hvaG9Vb0JQTGZJU001a1NRcDdqS3VUaklpaUNXTXZFK3JIZkxoWnZyYWE4eko5eUJQMllnS2dLRk4wWGdTMDVWcE00MW1Fd2ZKWUZhc3Z5cklCbmFlU3J4M0dDSkFxTUE2UlorbHlxZW11eCtJcE0vOVU5RXV0OWdxTXh2QklhL0lReElqRzg5SDFzamhkaWhlcXJxNm5xY3NiYnd5dFFHTU9obGh2SUJzUEoyT0lNZzZnakxNK2psWXRIQkRwQ3lxZ3VFZUFoRkVRRnp3dnNNaFR5NnFxWHNkQnJ5b2NMQkN5SWc0SW1HUzVGNEtYL0g4eGl6UTN4RmxtUXhBK2hWUnhidnhLNmZ6RWpBTi9VNTA0RTFuY0xCM2hndUtLd01lVkJHaFBxUE5DdS9kUlhZaE9UWnptaFBYWk9GTStOdFFXT1kzZlZ2MUhmeFhKbjI2NHo2ZHFHQ3NSVkZGUUVUYTE0N3J5bEJtZ0tOOVgwSndjWHFOemdncW83ZWdIbTNOaWNHdXRBb1VKbmJNcFlDdmVXREs0TzBnMm5hMzZReVNiaXFzN3h2amRCVENlbk9obmR5cEovNTN4c2gwL1ROTTFvMWd5ZEhrVS95dnk5biswZ0ZxeGdza0pwbG9MOTdHYzZyVUNNMUIyenBCM2xCODh6NU5kNXlmZ0VBMU5NWnovT01JckVNY3d6akdBSXpETzQrMmxWc0dkMENicjdFNGJFdzRoNG1pUkUvaGxkSm1jSkVmbmZOQ1RtZWtMbVdBR05jN2Vpd1dtVkYzRkFudUQ1aTVMeG03ekluQ1d5L2d3UEVzYjEyMkt3cHlLVXlMbEJad2xCRlIydHV2anFpT0k4UzVwVTBZeW84RjB5SHFUbVR1V3NRTEY0eWI2U2lhZUtJakRPOEZ4dGpvanFWZWRVbHRlWWI5UW1aOGNQaTRxWnlCUXlFeWU1ZENNenBpVVNXanFydVlmM0VsYTc4eXJIamlmVEdTbzNoSDRaRm1xQ3V0Vk9WOGl4UHJJSE0weUE3bXFodFVJZzB1cFZvbEVvSnNndEJiVTBXVHJoS2NxNHJ5ajE5ZU1mYk5jWEo4YjMxNCtmTlBJSGlWZFhsTEVwdXIzVVp6eUtlaEhRZUV0N0NJZm13QThmZmR2WWdsK0dGNjNPVjkrdHZ1K3RkOS85MXJ2SnhteFJVOWg2YXFwWVNVdmNTVHVSc0UrWGZrTlhpOWRtcTlsc2RYUzlGK0VwemRGY1p5RUxHS1dVREQzVCtQQ2JNa0JSZmh5Y0JwM0IrWkZid2hYeUtrNlFlZEVURVlyWlVLeHN5bEZJQXhxZGxYbDliNlc2VjBORnBTbGF4MlpuamhTakMvU3RlNkxGOHdZVzAwV3lzaDRFMmtGRFpLUlVMcGVVZ1prcTFXdG42VkdGWHJGTmhzakdKakRxdFl1UXZ6WHE0aEVJMERjaW5jdzBWc0tqaks2SWRvbHFOOTZLZDlFTm5uclAwSHppUUxtaExwL21tSjh2bFhJbjg2d3dMcXRLVW9SeHFRUGR1MUhPM21WejZDUTk4NFpTNmFBMUtaZ3BKSWsyTEcyNTB4c25FNHIvb2ZLTHkza21GMDl3U1VVVVVUVVBMSytrc2RvdTEzdXBJeWFGeWR1Si9HRzQ2SkN4VjdSTk1TV0lIcWVsM2NMUS93RFg4VEVZNWZNMGwzMmtsb0kvL3pKT0J6UUhhR2VudzhFd29LQVhPZ3NvTnkwVkJqNEhjU05vOUJUM3E2UHVCbUdnNUVXODVNaXJCaDRHa2F0QnppMmsyb1dOVVIrRGV3Znh5bHMrU2t3c0VjdkJlRDJFbnRVMFdXM28wQnlTRldyUzdiSm9TUElSKzUxRkJ6VDBtUFFGa1hwSlV2Y2pUTnhaSzgwamF1aDhwN3RPK05jQ1JXeUxZcXJjUGdvcy90N1g3OTBIM0N1TUkwWHN6UjhHRXNNVWdXK3dDNkxDdElwb0d6M1NKaHUvUUM3c0xuSXMwYStZdlVDQ29QOC9PWkF6aUlTYlR6QzltUUE2MHVDVkZjczZKUUgzUUFnWHpGeEJZcGR2KzVBeWJyVjZiY1RaSXhoMHdsalU5azdVNW9OdnNsNVlwNDBlYmxkWDhhdi8xWkU0bUNmRHhsOGRjMi9xdFFldDN1N2ROTnh0Tk1MRHdtamprNW13OWJmbXNCa3J4aHBiMUp4RzVWSWlIVUtobFVTZ0hTR0NYRUJsWm5TTDI4TTBFWVJ1KzJseVlxYlhtL2tyM0JRMUtYQVkyRWphQXlBMGE1THZlM2RxVWdLUEpTU05iQ3pOL3RmWkpicjVzM09TN2pFdkpwaG4vbnpXVGlidHJLUTU3eHc1U3VYUkFubUI2aVl5R012WGpmSWpWZ2VMYkR5ZzQ0VXV2WHc4UW9HandRb0NKbEVMellaaHhsczZWenVyaTRjUDdacGM2SjBWQ1dma2NJZFRDU2VwKy9lZkl0ejFrbEE5K2E2WFBDYUpsWEtWMFNweGdmQ01uZDEzeTlKaVo0enVKL2pmcU9aelZ2bjBJd0tmUzVaUDcxZnlHWUVubkpNZW0rNm03ZDdNbmFrNHordXNLNEhFWlh1VEUxbmJ4RDNiR05VSkZDSS96OWhjaExTRHhoTHM5L1ZOT05tL3VMNCtpZ09JZWNmTHNkMlJMelFPb20wVGV1Y0E0cmZPb29zd29nNGlyTTBRUzJMZ1ExUm9qZ1E3ay8xRk9KWlg5ZHJxYXErUW53NFBydU53K3RSZ1hPRk8vNWZEd1dUUXJ6OTFxbmlxNG53Z3Jtb0lZTWprTS9QL01CeG5FVzFGTE1RQ3lNZ3hGeG1pTUoxaEpVcjROVW5hTHVLK1VVemVacEZpOGlJTWtkZG9qQ1VQSE5USWZMTGMwQThzTjhySmd3ZTEvbGNPSGtpT05jakJnd2ZoY0hpczBmLzhBVGc0TndmWEg5QXV3V0RFN0R6b1NndkR1cnUxdTc2NHRMR2FLMTBNdjhqNjB1SUxNTlJLdWQ1Z1o0RFJnYkZ0SFBEd0dJdFppTlV4SzZvSWl6U01ybHEzaGVCaUxXRkhvcU9CR29wWXk3M0s0c3RPTGxaNm56L1FUcWZieSsyN2p4NjkrK2daQ3RDeDUwaXJkYVJGTmxiZk5DdDg4cFBDN0p0VzE5WTJqK0lGSVI3SGVnc3ZpRjJDQjRseHVpUDY1cDFabHFqYXlDUzFjaVVvd3h0MjNrOGZVeDU1c0Q2NTVKcWxSbU9WVEo5Y2JkU25DK1IrK3FnYlJ4N2VhWEpIN2w1KzhzbmxNN2ZwTzliOEZsTHE0WnBQZlRGQ3ZRN1ZBOEZQOU9jb2hWQkl1THBUaFVmSUU4eVFVRlUwU09VUXJ2bXY0Q1ZaRVdTQlZZeGtVK1l0VnBTK3JNdU1PYnQ3MW1Sa25lY2szbTM0SlVIZ0phNWg4WEl6WWNMeUxRdUtMUEdzSkVSci9oczFsaFY0NFB0MTJYUXlKbkNON0FsWjUwelBNem0wOUNZMVFSU3Y1Y3lNWThKaGROcGdXVTFrbWRpZ243RjlzWCtuWXQzWXFkaE5WSE50TXFIRHlqQThPYytnMThoK05oNGI5dlY4Q1dsUEYyVmZIN1BZRGFGK2EvdEpxeHVCUkNIVVRiY3o2Q055U3RpZFRoWHlybVJ6SEo5emdtSXhjRTJPNFdYTzRhdjIrVXovdCtPMkhiZmZWU2dVejJoQjVrMnN6VCtORnpsNVhuZTFSQlp0M2h6aFhSQ1RZQjB5SlhvMU9XYXVsTWNLZWs0ZlUxVXZCWk1aNnNsYllrWFpFMndtKzYralVaRnZLOGozWi9ja1A4VUZoSDhaWEpMeXhuT09EU0lBSXhPNUlsbFlucjVLTDZYajdpL0lJaDMvU1lwcmZnMjJDaU82VGRvcXVGelFpREpxZWdnNlZEbm8yeDZWbm5CWlFEdFBWMnlHVjhMYWdlYk9NTU14M29lMlF6TEQ2MEFuNXpTaXNXa3BmNWhsWDZYYXBoLy9XMTZNLzY0dkNhbHJRQlpjZEJWdU42dVJVd29qTWZKUlNlcHhJaEVFVmxwVXhBNVJTU1p4YUp3bHhvTFlzdDlTWmgvVlJXamgxNXZKWGlCTFh2K1BxL25yQ2FONkw3TmJvcWhPeWJxZ1M5eVlJMHY3Q2ZscmxjbzFZUjNqUUdQMzRVcUlEaDRVQjMycmJ1NGkweFdIOVl1cVI0TlBxdEdTaWI5SmNrN2pmSnN3dkdNTWEvSTlZdnRjQ3diK0Z3V1pPU1RKUms5alpVSWs0WVNrT0tzNlF6WVc3SmVkNEdWTjMzcnovdi9MbjNpWkxjRUlGL3JmWVpqckZGVmpwam5nV0NYZDFnWnJTSXptNCt3Z0IvN1RadVA4TjVOeGZyRnkyUVNjeGRMQzNjV0RuSFM1L0p2MzVpdVllRlBSZGlUZVZKU2ZtSGd6bWQ4OXNnNFdhTTdOWFlqVitCL0l1SG5aaEp1WVpQUG9GYnYyVEdSM0RaSnM3bjUwUjVMTlhOSlJveHlicVdRRmMyeU9KTmUwZVVQL041SnJwanZiY210dXh4WU9zOS90Z2wvMmR1T2lFTEY2WFlyNkgwNEZCTDR0eDRjUkZOMHlWb0NzWjd6K1JRUkFKd1V2OHlGcUxGeTJNSGpPTXMxNXJsQ2NuVm5pMjRwSWx2di96YzFrWEZLRWE2K2pOc1A5OUtybnJRdTZPMXNvTHMyWTlnVlIzdjUrNkNNd2puRTM2Q1ZRQXphYUJsMVRmUDBRUnpjWTRLdlNyQnFZVEVQczRPSXNZbTFvbGkvYSttc2JIL0xGVTRibGtvS2J1VTcwNGEyK0t2RlZJTkNzVUJWWWJybXdiT2hZRDhPOHRsQ2NtVjNiZ0J0U2E3NXVaTHkxbEYva2Fyd2s4VFVlUFZkK296QjczckVNdzNUUHcydkhodlM0UjNYS0FWRGtidXdOc1cvQktPLzZXK3FWb0QyaUJZdGljdEhHUUJlV1lZQmU2SEExUEk4V3pWSW9ycldvZTJnN3lzazA5RXFHdWtic1lwa1dnTmtScU52WlZvNjRXbm1XYVlmWHRJWnA0OXBsZndUYkpUdzdsMk5hZ1QrOEsrSkNFZnl2SFQ3dERXNDgwRjBWbHJnQWxqVkoxSlVuVFY0d05GZFVIRTl4YklGVFpJTU5CTW5RNWF0aFZNYlRnZXIwbUZUT2o2ZklsWVpoMk9sa1FaVjVUdFA4SUJDc1hpTGorWnBLcnVSOVUrUXN4V1V0MndJcW8wcVNBTzByMm9UemRWbHhsTGhVNVRqVmRoT1dxQmNNUXdnY1YxWllWdUlkTFFsVWg5VWtMZEJ0bWVQR09FRzM3YXlwR2dWVGRKT2VRNjVuSHhZazFVcTdtSUgyM0ZtZTRSWEo5Qlg1WmpOdHFib3FvNnZ3TzNoV0VLK1dWVGpNRS9FZTFPWUpCMjB0RjhSMWkyZVljbGtRTGF1WjgxSncvbjVCOEhURjBxdzB6SEFEN2k0V29iNW0zRXNWREltNW15RGVFYStvcW43YVRlcHhWVlprVk8wSjdGc1FFa3ZQR1pLUGlaMElrOCtqRjdPbW0xWkMxV1JOMUVCK0JnSDZQUVE0QmQwV0hGOU5xRHE2WlJkQjN1TUVUUjNxdEhDY1hSbGJSdlNpeXY4UEk2VTJNakMzajBPeTV6L2VoODlFQStSdEkwUGlIZjlmbS9SRlc5MzNnZTI5RmRMbkVFZGVwTkpIYkFESU9ZcmtOT1JucGlqS1FBT3hCemR4RTlLdDV5bTZ3RXNwVzNuMDJSQ1JrQnVXcTFKL0plQmtDWVY3UVg0QnB0aG82UVBZaUFFNzNkdEVvRFM2R1Q3Sm8wKytOblNxS0ZEZWRWY2hmT0l5ZmZ6ZThMbGIrc3NKaWh1RUVuclUwMTZPQllHazJFYmN2OEZzeFhTR2U5aTQyT0tqOU9hWXc3V01jYkxBY1d6RzQrUGxpU0FncWpPZTBWK0k2VGRLUVRCVkhJOTd6UExiQ1htQ1lhN3R2eXJWU3B1RWFUSGtIcHRwRWRaTXQ4bjF4NmVuYzBrbElTSmFwcTRXQ2pOallrSk41S1ludXFyZnk1WmYxVTdPclVqTzdOallMRzl6SzNPcG9jOEsycEFsOUtad0EyRHQvVnE3eGdkb1QyRnIzZURpeGJPUGJCUUs1SnpDVG83UHFPck0rQ1FydjVtc3YzenZxWE8vWjMzWlh6N0I1SFBBRVk3bDhzeUpNN0hJWC9keStjdGkrMG1BcVJCRWxNZlFKSVkrY3k1OGFwaWZ1OUZvUEgraGNlRkM0WW5wWU9hZnArUFRmemtUVEJ1OVorSDRlVGhPMW5zOUNZNGVnRS8vNytHUysxSGxIdVdVUkg4UUhFZGJYaklqMERJUGZQd0IrQ043VmlaV1ZpYkllZnJ6SHR4ZldRbGxuKytUajVPbjZMdGk1cEFjamROQkVhY2I0RnUyUjN5ejJ1RncvSGptdHN3ZjNacTVkZjJVOWVJOUc2OTR4Y1lySGc0ZEJ3NFVUeFFMSjRzbkgzNTVNNzN2b1ZOckgxeGIrK0JmblY3Y2QrYk1BN0ZSMzVVb0FuTW81VVN4aytHYmZnOXFITDNtRityMU15aXBSelllNnYrNE15ZGNPUmF6c1QxcFRxU1dYNHVpT2JzdEh3VmVlbHlFejNKOStVdkx5N0N0THkvZmo1dGxFQitYbjRkditBbi92aFR1d045Mis2VnJVK3RsWUcrR1prdHlULy9IOStkaDc3V0UyOUgreWtpTnV1V3dNcyt1YmtaMWVXcDFZQnRkSjZFVFFNd3VpZ1IvclY5U1RpeVNQY1dnVFRhaTIwbDhVT0lndndYYzI4TTdYYnUyRHJzdlFFRTd5dUVpQ1ZiczFraVYzdjc4NnFwRkMxUldWM2VXWXdjaWxyUCtrOThucUluUis4RHQwUXM5andWdHExZTdHNnpqdjUyMjRHN1pwbTZpdGMzSUJ1d1BqTUpSL08vZmhQbUtNQmVETU9JdEpVUWFpM2lUd2tXR2VqSVlqVjh1WEhuYndlYWhWbjRtVjlBY0hiN2dCK245emR6QmczUC9XRzQyeS84WXorZUNMMzhaL1RycExqMDRvcjhJNDRCcjdhS1BPVldCUkxHdGJ2SHBwOG42MC9lOEVMdm42T1prLy90UGYyeHk4bU1QMSt1RW5kakt4Ync1eEVtYmlEVVJrU2MyMEJUczBCYk1JZzVRdVUzaFFLaDF0K1Z6T3k0aEN4blB5N2ptc1c3MzJLNERuV3ExVXpOems3WENQbGMrREV1cld0clQvK05qdTNZZDZ5NTFhclZPbGV4ejhmcDM3OExyNzZ6aXNROU9UeGZXVnFwNlJyNVN0dllXS2lPblVMLzN3dmZJRjhsN1l5Vm8yVDFZMjJxSWtoUzZyVkpuUkZ4WFRSSmxnaERLcnQ4TjJpeHdWL2dML2lhcHFCbHZ6cmRZamxHcktidG5yVm85TzFWVkdZNXRrZGxhYldhMldtMU1ycTlQaXZFRjN4OXIxbStvTjhmOGVOdXlhbWZMajB1eXdPbTMyYWwyTzJYZnBvT2NKVDQrT1RreFFmenJ4c2V2Nno4dittTXAzMDhWTENzOThJRXFVTjBTb3FYNWRrMUVIdjlIVnVMOCtZUkYxaE5XLzZPOUhqbGpKVWJvckJYellvbFlKc29PQnIxQmhUV0tEMEtEVURERVBROVVEVjNZNHFHQ2ovcmV6ZlB3WGNRY2o5THlyb2JWcytLcG94TlA1NnE1L3I5VWM5WDF1NDcxMXJObHN0cnJiL1pJZkZkOVYxcHhycnJLVWJTcGRQMTNlcjBPWEZpRnYvaXgrU09WTysrMDk1VG44eE1URXhOYk1zRXFsU0ZuYWJhREdBemRSYWFad3pCaGtJRDlnVGE0UE55YlllTTcwSnk2OEhMcE5peTU3VFF2Nkt3bSs3TCtNUjIyR3FzTC9CSlZJWDZEYm1IeXIzNGxYY2JrRXVYMFZ3UVZ1TXdhRHZ0NEhMYzFWdUZWZVFSNjhTVjMzLzJUMXc2RWZLMkppQnNYUkd2SHJxTkhzNE8vaUp6OXdzaWhZWHc5K3JnbG95eHRNUklNYTFZYzdsSEpudHRSelZxeFZpWW5wK0Z0WmUyRkdQMmFGaExmVC9UL0h2VWs3dittMisrVGljTDN5ZEg3TnJCQ3FvcmJqZnY4aXlPVnV2NVV1TWI4QTlUcGJWQW50QllNZmRiWVZvQk9xQjVWbGlEL1NKV2sxSm1pVm81RkY3MEVuZENTeXdkZE1pL3B6RkUxK1g2ZjRmL3VIN3drbno4eVFkcm95Slk0bE1BdmNzdUVKZ25jRytNRllQYnFjVStUV3UvcC95VTlOZUtQYmw3cVFVcE9VZC9SMEFWMm16UHNDRjFpc1Q5STBTN2FsOXpkZnk1MGxJM3V3OStudHBVeXFwL2xLWkl2T3F2VWVLb0QzbkpaOTh2MlM1YWV5WDE3bFNpVGcvdS8vZTMvUVE5dGZPeGpnK0ltKzg5dDgrdTlqRStzUzRmTGFMM3Uzc3o5NHJIY0RsZmZiOFBCNDduWXRqV1RwNWh3NGZ1MWhvNkxZZ2hRMk96OFRPL1hzOC9lUkJJVE9PSlc2dFZDUEhIbHJiYytkdXYzZXArQzQ4b0tqazJySU1DUlc3ZmpFaUxHZCtXU045MURZMWFEQ1JLT1BOZW1ZUlQyNkp1ZjVzdFRaYjd0YUpxalBWeS9XS2VPdmI5SDY3RGJUdm5wdEEvcmpPNzBQMHg2aHcvM043ZlBvZFRJSE1LUlBVbENtSVlRYmpHYVNqTUl5S0RPbFRMVElwdXNWbExSZFBxVjNGU3UzQ2lucTgzS05oLzB4T1Y5ME1NbTMrbUMvdXR2eTcxOEtyZmRCZjMzNE5oMGJsdVoxY3VXR1lTdjNCNTk1MHVld0NYTDVXU3VOMVBkclJnSWE3SDlXZDhzTjh2S1RHKzZERExCME84MWZPYmxubmhKNmR0TEc4bXZHL2JuTkhxL3VWRit3VUh5Mk5EclQ5Z0JmN2VUa0c2KzZCWDdwNnE2SzhtT3NieTIxcVFVNVNUZHZtRmtuNnpmY2RYVW9xc2JrcXdaenRyRzJpWWxMQWVvdmpiOHV5dTB2YkE3Zk5lR2RHYkFMZlBBUVQvbm1hWm5IdmpNSTQ5ODVoRmluM3JtMUorWWVPUzVSL0RJMjU0NTljeW83Z2hqUDJuRUJiSTY1WDBNc3JQSXdKWjltM0syNjYwV3NvckhqNiszanJmV2ozOFh2dnQvQlBzRWpnL20vQVBrQVNoUm94eVlXRVkySGwyaGY3RDhnMlh5QUhDK2h0a3lZUDhIWkFKL0dDMXpORmN0eG1YRWNNRUpTVFdWMklCQktKQll5Z1p5UUFyOXplWDAzZW5KSC80UXBnTTVoR0JMMjN3aUVCMWxNT01tQ1FYUEtnK29Gc2IwVUovNXh5WStOdkVZblU1Mzk1OGlHekM1dm11bkdvVkNBNDZrZ0VoYy9PRVBCM09xUjMzY0xaVEovR0gyclE1d0xMVk5ZQUpvSU0zUHJhMlI4K3Mvb2pFMXk4QWdySVZ5OVRRVEl5ZGhUOGJzR2RnSXJRQ0ZHUnFnOU1oYjgyOTlmYjcvb3dkeVozOVVlQ0JQNWgvUFA1N3YvL1BQNUcvY20vK1pmRGhtWjZBL1R1RG9BM2tOYm56Z3U0WCt2enhRZU9sMzgvMS9mU0MvVFdZMDZNajJoOEVjY0FPZG0yUXpEQS93dnZJVjcrTFRUei85ajEvR09uODVxYjM0eGVyNjJxbFRvelNhWXJYdUp4RldxN3RGc25BY3dCSkFMWHF0OTNTLytyVmR1WHZ1MlJqUXFrbDBtUWZLL2FwZEUzaWNESW40cVZOazR0UXBYQWd1TTdZcVZFcHlVVkFxVjZpOHhOTEJSWEJJNFlqNmJ2amRnZzlKYlIwYmlWSHk2ZHBPa2E0WUVCSm4yQ2pCQ3R1SmRNWW1HU1laeXpOZE10Tlk4dmZNek9keTh6TjcvS1hHUXFXU3VDVlRiNVFtTW9sRVpxTFVxR2R1NFdTWnJDL05aZHNIcHhycGRHUHFZRHM3dHpRMTFYL21US2s1VVc0VXM5bGlvenpSTEozaEpHbGIvQUNzUnEydE53amh0eGp4MmExSExZUVAzeW96ZWdyRllnakgvZmJjVkRHQ29FRGxFTURNanNDQjJKK1FkWW9rNnZYNlJwMXV2b1JmOWVmcEZoM0ZKdUVmd2UwTHNjbkpsWW1KVTVPVFR3OTJvakUwaUFsS0QvMERCakZCZXdnbVVTckRYR3dWbTZQUkpvOU5icXI5eHpGTE1CbUpFMnI4OTgrcS96ZTF0VVI1V0NQYk55clJnUGNxQmpEL0xxejJueWViL2Q0eUthQjhYV2k4cnRuY0laUFhZMi9ZV3NIY1JXYWVLdWlvOFhHR29Xb2IrRFZmQzVIQk90MFFnWHVHb2ovQTh0RnBWV3QrSU02eWd1aGorRzFnRUpHR1lQaWRGa2FFWTRDdktHQkJaY1FFQ2pPOFJEcWlUcmc0ZnBZUk9kNFNHWW53TEd1SmhzMDdhRGJqV0daaWZ2THJaYzMxRWJNbVlGaWRJenhSdU1JVVo4aUtZdmdKMXVJWWczaEVKRDZSVXd4UjRwd2hNQXJQb08ra1VEREh0VEcrYU1oeFhpZVNwa3VkYU5YdC96TUhwSjR6Uk1abFpGTlRPTTNnZENIRjZGbExkQm9Iajh4UFRwWm5tWVF2VnhXNXdJc1pFWjRmQ0pLc3M0ckdzNHFJVWFFS3NWbUNNYTJzei9naXF6cWNMUEVlaDE2VVJDeW9PWFJaRlZoZjlGaGJVbHgxMk9hcjBPWUs5SDVpa0xkRWJFZXFrSmJZNm9aZmR6NTU1NHVQWG4zbkx5L20vZnlkaTNtUWFjNi8rS3FEYngyNzZ0d1RKL2J0cTlmaE04VDFEZnN3eE82dWJQWGowR2crWXN2Rzd6aUNVQXRodXovK0dISlZQMDQ1VHNyNU1OMWVjM2hCLzVZZXRkS1BrY0Y2N0FZN1l3LyszbHNyRmtmbkljaHFyWEtZMFJLK05tNWJmUGJaeGR0V01VZnllbXcweDNoQS9TeGlsVmJFQ2JSR3dzT0E2aEZnZUlmSUxKOCtla1crdjVtLzRtaTRYTUMyL3lpNSt3dVVOU3VZdG0yR3dWWmg0QlZwdytpMitwL1I4ZlJPbTFHa2ZidUVieDJkeVdlMm9rMi90SEVSL2xGSmsvNG1EU3ZSZjdiUk9FUC9vdjc3TzZBZFR3NDFyTnU5ZS9ZTUVxQUpRekV1VkZvUUd0TktseTV2ejRrOXJ5NGtFb1hFdWJINU1TTEFZK216clFSd1FIdkc2NytSd0pNZnJLZkd4bEwxYlR4OVZCZW9pb21RZGlXMG5kUFFYdlFWWU5zMW43eEdGViszL2hJV3N3ZmgzcDI4K0twMVRDLytCWWtabng0bkRGSEpFdTdXR2JiL2RIK3FQN0FYQWpVa3ZRSHRRS0d0QW5TakF2UUQ2ZG5nMDV1Y3ZHZGk0dDJUUTcrczk4TGFYd1RLT1lmNVZTcEJEZVhza2RnMkRMb0lYYzFxM1R4Yjg4UmFGS1dJV1pMYlFZM3MzYjE3ZHlseFN6RkxJOS9tOHFtQ3JtWEczNXg0K1Z0NTJTSnZHZDgxZmphZE5rK1Vib0xyaW9sYlhPN0VDZW5NUXZPQVVlVHIyZXliRXZmQ2RjY2w3aTFKREpjN1AxUE5aREovVUtUMWVTL1U1bnZSbkJqeVoyTTcrRFRhemdraTBhOVZ1djFlZUd6a0w4cjlHMXNHZWgyVjUwUXphZkE5eUttN2ZNbk41RERkNmY5bzVCSFIzT21GTVhCcHpJaGIyOWd3My9FT0U5cjQ3V2F2WjI2akU4aXpUNkgvSHFiZ2dGVzNOWXVvbWtpUGNaaWh5MTRBN0ZvM3hJTnpxVy9TSjVsRWFVcVducGZrcVpJZHo5alR3R2x2ak8rWlBwd29KY2hoWGx3WWU2V3VTSktpdjNKc1FlUVBPN3FwWGozN3lnbmZuM2psN05XcXFmYy9nUDVpMFR1OGxNcHFEbklxY1p5MkhrdEFaS05QN05hNnZGL0Q1M2JDZC9uOVV1TEVMNU9hbGhqclB6ZHU3VStReXJPQmErTUxXRW5iSnNmNmZ3S24vUEZYRlhPOXhIdHUvcHJCbWJwRG54N3hmYXNEdVRCOFVuZWtadEVUL04rR1I5d2NWbWRZOEIxYnJ4NFdON3N0ZmpFZDhqNDdKR0FYbVI5Z0VNdmsxSkIvZXZUUlQyOU0vbkh1ajA5UFB2cm9pQlJNVG0yY2hxT1JMbnBFdng5U2x6Q3Y1WjV3M2xCRXFwRk1IUldxa3k3Ni9NZ3hWRHJ1dkk1WXE4c2hyTGJUMzFoZUJZSVdxVGMyUnM2RWVTeUh1VFdXLzgyZmxBNkdQSUZNN1V3byswVmhVdDR3WU1vejZEZ3F0dWNIVG1QVldvZk1KY2ZHa2tCL1BvYzBDUFlQM1hCSC95S1phOTYwYmpqaWQwRFVHLzVOVlF1ZFRpR2R5WGM2UGl6N1cvNEhGeU05S2RxM3RqU2s5RW50clFSY0xYS1kycFUrY1A4alFGOHdHVjVoazFxYTdtcFBOaHFUaitLQjNqWWFpR1hHT2p0Sy9ONVdJYU8zaC9lRmJVQWx0Y3BJN0RXTlN5NjJpMlF6WWZlZlJIZHNjcStkNko5SEY4SHI4ZWRYY2ZQTjcwUnlUb0g2ZExxUlpuSkVLbkh0c3YxUEk5ZVRqVXZMRzRrSE50RFdGSzc2SnBuaHR0ekdiMzdrNXVWNlhmUzdFK1dmYXhTTGpTTFpPSHZGL0pPek0yTHk4TUdWNGhXdks4NFVpek9Sei8zejBCYm5hYVExTUY1K1RZUnBJcllIMHlRZzZ4dU41ZVhHeGdhSXJSdHJqVmZtODVhVno3K3lVYi9yRlRoRFhuSFhpRysyRG55SUg2MWpaWmh2Vk9UQTlkR0ZId1FUNGI0UVc2Nm1udCs4K0VJTVUrTStmdXJVNDZucUM3SDFkYklhNWtabHR2RWdsM0FmbzN6R05xNGl0b01IRFduclQvQzkrNldWZmZ0VzlqbWpaZFgzNGJGZjJsWWlvVEhjcTJTTmFyK2FuWkgwRnpUNWRLaGV1akJ4d0ppeGJ0cDc5WjEzWG4xNGZ2NTloNnFkN3ZIamUyZXF1dzREMjRVSDZzZnZQYjZ6YnVvMkc1cy9zSzA5TjdTckRlT21QempVdjZHM2V6N0NYK2hnVk1KaUNOVDA2aHVUeVo5ZktUNlZlK3FwM0g5dWFIWXFmN3loNUpPOWoxNmZ2REw1cm5qK0hia25uOHg5cUpGWVRPYlV4dEVjVU9OUlhvK24xanFxNStwZ1dvL092OGZ4ZldLcFkzN0ZKRCtCNDlzb1o3UEUvUW44WGpqZWZnRGo3VjJ4c2FHdEdvbS9NR3pZME9jNmlxZjF4SURBV2d1c0RmTmVONW1xVmxKSjl6ME1yTHBWdXNQOC9GMXdhaXdsU0dkc09HaWZWdmhVTmR4UmxETmJlYjdEV0dnYzRXSlFvd0hSZ1JqTWt2MWtsdlhKdSs0dHZpRU1qYTd2dFhpemZjaVYwbiszK2tRVUpQM09zWU91TmlNd1R1L3pPOHZMWHE0OGs4MFRFL1l1VzJ4YWNnKzFUZDdhYTEvdUFUMkhFV1kwOStDWU11Z2ZYTVBDcUd5TVo4UVJRNlU3dXBSUnl1TU1PY095SHgvWlAvdlJzNU9GOUF1eGRHRXkxTzZ2clVYNi9UVnl2dFI2TGorWnRxejBaUDY1VnY4YmREbDRjSFgxL0dBSHE2aU02S1ZDSytsbzNtVzBqSVI1RnJZYlJNTHhITmxDZUJEaWNIa1BJcnNJME5MdFJwRmpkeDJMYkNMM3dvRStuUG1EaWNnMzRETzkzdFRRS29KWFVvUElvL0F6QjM5S21LZGtsQTVtSTQxZUdFK09ydFEyNW5Pbmd5dEFsN09OcFp1VFdlT3FPYlRSaHJ2azl0VURqVm91bFc4ZTNuZmkydjR2dzJiZjZvRm1oUjdaenZ0cmtXVm9TNzRXTWNrMENsZlJKMkw4djljcm5LdStDdjZUVUxmVUkyZnFuNkt5ZkQya1QzOURQa2JlVGVtVHYwVUJocjFJN2VSdnVQQUcrSHZpaWR0dmYrTDJUNjlhYStUZDlFaS9mOGRiNzdqanJSZGV2cEE2OE5BSVR4ZEY3VzhaT1FmRG96TmkvQmtaRHh1VWNmem9DN0VYUDljcWJRMEZodktZNjlqN3pGQXVHV2kvZDBvbEdKWmYzaTZiak1na3Z3RnpzanFVUzdiSkpNZ0NqTWdsc1o4R0o2VlZFeEdmYUtlUzk2N0w0S1M4bk9La2hOZ2JCWUtabWJWWXpHNTE3VnE1Z29KeGpweTY1NTVUcEpCTkpMSWt0dGJmV090bEcrb250Ym1RMXNjMjZUM1JIZlJTZXRHMnNhRENhS09lM1JYZ2J0bzA1M0d0VS9OckxvVzhibmU2c0EvY0NQS3pLS1RrQ0ZuWk85czdsU2dZVDdXK2swalV4MmJ5L2kzM25Eb2wzNWdnUE5OS1pEZGJKNHhwODZWWGRpWUt1Vy9jMWVyL0NDNHFLdE9LYzh0NzE5YVZHeE9mTjhYV1huakZFVXdkckZkaVI4MXFPZUpSc0ZoNHJhMWF0bnVuVHZWbTkreVozVmJkRDVzdmZleWw1clJ4NHR3Sll6Q1BMRHJYY3pBcUI3YitXbWh6RnNzdWltSGR5Tzc4R2RxcmRjOWJxRFlYNnRlTzExL095YTQyZlppRUVzdjU2dUxxK3VyQkQ1T2V0YnhXSmM2VjlXaXNZcjRnSmlZZ1pmSFRwQllKekJjdmZxblJhTUN6KzZ1OVJtT1pFaDk4bjJkaC9GMmdlZkppTVJCUXk5VHkzUW9HbW5qUzIrZHV1UHR3ODJlSDdqaDA2QTZpdjYveHFsYzFjSE1VZngrS2VNY1FKN1VZbThlWWxFcVl1VzZXaUlPTTNCVDBBNnBGMDQzSFRkSWRpUGExNml4RFhTNVpleDUrWWxJT1ZLSDlKNWIxR1lrNWRndzJQc3NlT3k0SThjSHZ1Q0FjLzBVOTdmYWZjMDFkSWZmZTYxZkloTXNiL2VjOGJYVlZkOG1FOFdwV1lPTU1jL3c0dzhSaDk5Z3h2QjN2eHB1UC9hTHV2UkR6c3JLb2t5ZmZsZWwvbmNSTWEzM2RDc2N6clljRDlkaEM0aHErSStybm9UNVVZNHJlMEpqZUJWTjZObEdQalBEUTgrUWZMbm14dzVlOC9MRnRsU08zYlh1ZEgrOTQyV1BicWpLaU03UkJmbDhCYm9WR0hKakVZRUpZZ1M2bXlCYUhtQXZ4UE1KQm9zY3crdDJIbUxUZFlWWURFTklRbFNEMDhlcFNqMUYwM2x3a201SldsVDJXWjRTa1lYbVlzcUZlblhhVmswVS9YL0JTcDJ6R1Rtcyt6emsxMGVFSU1mL2FLK1Q5eERHTmd3Y1podS9HSllhNTB2UWswMkJGWXAvNEFjK0lWcWtWSnhpVUtyR3NsamNWamk4dG4xN1lkV1lwWDVCNUZyM3NNU0d5UkJSZStOaVpYUXVuOTF1OExiTWlnNmh1YkVJdU1TTExDNHJCa2Z6UzlweE8xUGFLMWxJRVFyV3BmR0szVUU3QkZCSW9uL1EyTHp4ZmFEVFdNZlFhVnNITjNrNmZyMjIrU1VqRnUxdTV3S2d0Sk9pMlJEY29kOTFXVUVaL3BRWlpMVmhXZjlXeXlQbit1cFhOWno1azkreUg4OW5DUm1GdGMvTjU2NFVZbklyQjE4V0w2OHZMWkxQUjZKOWZMcUF5aWgzU1lUWTJnVkVWR0loZWFYbUJFZXBXalRETGRqaDlRbDF0cU12dHRIakUwL0pEY01WSmhub2Z6d2NSRHFSSWthTnlUQ3ZlN0RZWENZSk5kR3BrZGIzLzl3K1pyTWxab2lGeEJpdGd3QUF2cFNTT2o2dEdSMWNERldFRE9abXc2dUZrbm9HK0VaamYvRTFabEdRbUlaYlZtbkdTWlZqMk5zRVFDTnhGNFBzMmhLeTl1TDdlUy9sRVppUk9RaFJ5VmlBODlDM0hNcG9nWmlWQkU0aklDZHdyeExuZy9VUmdKY0tJa3ZCSENrOHNQaUdtNUpzd0UraEpUa2JNVzVrN2lRbFVvRFdnUjhtRFFITm5vbWpOZUZSTDlIMXBOYk5rQ0N1R1BnR3RLTHN1QlZ5RGs3QjR3Wml1UmhTVlBNaHh2UFRKVDRrOHg5MW5tS0tzV3BZcWkwejVjQ3JwK0FZeHpKbDJuaTJpWlZqM2FjSVc2ZmVmTW94bDNvcWJmSjdoOWlocE8ra3k3UHNNNDZrck82S1MvcUEyMEZOdXhSN2xZUDR0eFpaak40ZCtzamhjTVBFdjZubmFWWXBrSjNxaDMzZ0hVNXlGbmlNbUNkTWpGS05VYUtGRFF5dEFTSlA5WkFnWGoxUUdYZmhwb0JCNXJieS8zOTh2ejgzNUZoRzBCeldlbU81K2czdHgwRXZlemdrSXlNQ3hrdkMvZUptOTlzNFRweWt5QzB0Z0JzNEpYQUF6bDRSZjg3bzdQKzhZVng4dlZNK3FlZWdXNkxXc2R0TjQ5ZzhOcVA5VGxlYmFXcVAybElRSmJDb0NJOGlJTWZENjF4OUNQQUhvTDQ3aDlySFNHRWR3TTJ5SE1FL2lCTVgzUGs3N0xBcHRIcWFPcGlHSjNUQU1zVm9Ldi9DUWVPbWg2ZzRNRVhLN0lUcEhabWFQV2FMSjhBcW43YTFXOXVwUXk1eGk4UHd3TEZwWG5GVDIyVXNQS2FNUUl4OFVqVkt0WGpKRUlpZHp1WlMwb010aFRMU2lCY0hJL29WdFlDTlJQZjhGNUpBM1FXOGp1dFhSMkxXRERJUTA5d2JtOFViNElwU3RSTXBNb1VORWdFbExnY3JHZ3k1d1U2Z0M4eXJkS2dWazVTSTd0eHVFTHZSaWFNOWI3OGdMazJOYWVmN1FvZm15TmphNUlIZThtUktmVFhiVWlZYWl5WE1UYWllWjVVc3ovWis5VVhjekZYTER6WmdrTGJoUnFHVGNjOWJhS29uTnkvUFhYREUzclV6T3pVMHEwM05MeCtGQWtDMDJpRE92NWpGYVJ1RHk2cnhER3NVc3VSNW9iVDFsZk82UnMyY2ZPVXR1djk0d1VuVkN6cHkzQnJSMVVPZUYvMWh0UmVyTlN0N1loVnBWOUgrL1ZwKzFMcTNBRmRjTUs5Qld0bGNnOTZienNGNXpJMWlQa1ljcSt1QzRkdEZHS283YWNIS2h2MG8yckg2dlR0YjZGMGlETlBvWDRiTUpYQlBOdjd3Tkw1SnFDOGpvM1p0Yk4vWkdidG9tMTd2QXZjL0dkc1h1Z0h0ekxPYndLOVZtV09vK0dPWUpxMEtydVhHNkYzbFRZNnc1UWdGUVRLc3daZmYyRC9YbHV1UlQ2NUtqK2JvRzB6RlYrK1NwNGQ1L0Z3U0dQRFF4bGx1WVBhNjVUd2hxdkRUWUlkY096dDJYMGJMQnlDZWVWUS9zUERJNFN2YmtiN3p1YUJCd3A2SnZ1OU8yeElmNC90ZG1YWlo3b3BqYlhScnN2Q0k4ODNCV3l3VGJQd2RVTFBFeVIwTTd4S0R0QXBoVFYxMm01V0FvdVdHOUw5Yyt0UjF0QTR4bFRieHM0L3dGKzRSeitOOStvVzFIL1lmWUp5NnAvenVkSjlqK0R5L1hhSmR2eXVBdER6bFBqR0tFb04zcEZwVG02ZUx0MFRXN1NVR2RReHliZ1JkeWxLd0NNYUFZbWdRQVBUMHBMbENybWVQQ05MdlZDRUlDVTFUUm14RlVxQ1FRZGFWYVhqUXN5MWdzVjdkMmY0MVN3V09CSzRpOFlMdEtodUY0NGlmc25LajZnY2NRRW1RRlhaRkZ6Rm9sU2hoRFlqZ2VZWlBGbkNVbUZNdFVDZzdEa2ZNN1NnMTNDNVJZL2llWHg2SlpwbzdvTjBtT3lUbHBoaW5BS2pSSkVYQllSbUtoYUZFdlEwSGpMRk94NHd5eHpXbVdiT2ZqSElwNEVLV1lESmNSbWhxS3g2aVJyWVFGTk10UXl4KzJVWHhuRTEyODZXR1dJYzREMTl6NE1NTW9ENUlLR1hsNXdlUTRZbm1EWmhoelZEL3BiR3NGbVd3OGZKUHJhUHlSMWZVYmVjbTU3cFUva3F6SnJacFB5allXTWF3dVB3MjF6Y01LT1JYVlZndjlxR0xvS3lCQWpaQnd6blUzSDNxb3NMR0J2dHJ3RmZsRXJJTHNSYlBURU9xeFRxYmRqUTMzYmFUZ1AvMjAvOVRBSDJ0UWp0ME41dUFxdUx2d0VPbmgxM3BzMnpWODlLenU1bE5QUVFuaytOdmU1dEpIYmI4bWRJK25qeURINlFNUnN6UTY3eUdlUUpnekw4U3pvb25ydTUwdk1NeHBBcnpqR1dEdGpsaEhoQWRoLzBXRVlaYmg5d0dTbGFUK1h4NFFoblhLMFhKb2xoYnFSdzNTU2JFSkRGSVF2L2x5OTkyMm8vQWQ1UUFEV0N6TnQ0cTFNUEVGbFN6L1FoQU85UDlTa2tqMkFOeEVTMlNrMndSNnV5YUVwVEhiNitVS3M4VDJnS1VQQWJpb0hPcDlZY2N0aExsY3diR2QvVldwaGYxRlczaVZOdmRBWjdrUWU0RmNGWHRON0gzVW0yTVFBM2M1S0tUUlFEMDhIWDJobHpNbVk2WndpSEdVUEpCckNFTTh1NTB0Tkt6eUR0eXJ3WG5FRWFNUk9pTVhlVHN2KzRITGlxWnE2NjVqQmFuQWkydUtxcmhXT3A1UHhBTkwweVFRQUF6WlNva2NJMHQ2U2xKRVFRRW1XUzM1bGltTGdsTkZid2xPMUVWTkFmNVRrUTNYU1dTOHVHa3FpcVE0dHUrbGJCMmozNndWa2ZNNWRLd2dISyt3aG1GS0lrdDRGbGhLa0RFNFJlTEVoNGlnR3hTdVh4SnRMeFdVTStuQXRUUlprZ3cxWWFjRDI5Rk1RUlpSZE9FUTVpbWhtRDdqU0daYzVsWDduQ0xCaEdORVR0YzEyL0hOdUtTTG9peWJScEFNQ25iQ3RrU1I0d1ZKc1FxU3RxQ3dQTTJNSXl1YUNnS1BZVWtTTC9ISTI3SjgxSGNrQm4xM1grd0QwSGMvVGRjaE9TcEhYYmQxV1FqajFobjBIdTJpMWsvWmZZUE9teVR0NFRVbThYeGgyMVYvbFdGVlRjV3NWNk85Qit0WFBCRllPdlNlRU5jZHpRQUpnRk5zUllYR0JFRklJREtuV2JadlcwQ3VrelVHczRoeWtpcktFaTlBRXhtMjd5WmQzekJsV1ZKTjAvTUNGY1NqeENGTzhBaUg2YnBCb29NdU1hQWtnbGpvdk1ESkVpTGZyd3VXcWlneWgvM25aSUp5TGpub1B5M2hKZ1BieWtpeVJEQzdDYzlKb2liRG1DTngzb1piV0ZHN2k1Y3c5YmZJYWFwbTJuSE5sVUdBaExGbmVuNGk3U1lOWFJKQnRERm5lYU1MTmNCVW0wU0VQZ2FabFhpV2dNRDJNR1ZaTHBUbll6M2dLWHFSZitkUW5tK2pONmJmOHFtZldLdGQ1c044S1RUR0NQM3AwT2RxdWRjanNXWFk5cDlIc1gzWjJyQzZGaHl5THNKUGtPVXZYc0RvbUFMNngxaEFVb1hoczBaam0wTGt1aEdQczhFMzZ0eVdvZERUMXZXd3hiQ2ZIaTBNaXJJMk53dGh2TlFXVDFRQ0dlTlZzVStnbnlJTXNISkptT1JLMVgzY1BFaVd3RERNUlZDK05lcjJXL2FRLzZHOFpTQnViU2pmZ0Q5YTg1MEtoaEpXMnhSaWRaQkFjTENoSVp6NHpaUXhBME4xKzluUkRlWnAydjZNa1EzNWtIVDMxWmpOQnY2a2xRZUllT2ZWa2dYZjF0cUxVRzcwZUtBQkxHL0xybUlabW1uQjBOUllUQlFubW9LbmtQN1BycjJJWStOOHdHQktBay8yRmN0V2JTMXVHQWFqc0xvaW1TSW5xK3czbDI2UmRGODJKYzgzZFNNd1hOVTFOVitPeTJLU1QzRms2U1l4THNPbGdhc2J1bTlDQ1JhTUprOFdBejdCL0FxNStrNlJQTEFpaGUvSVhIMjNCTDhNd1h2UkdsRTl3UlFOVVpJMFhiY3RVek1OMVpGdFJQaG5QZDdGUEFJdldrc1MwUklsaTVGWkhkZ2pHMThQWHNXRGkzZzJ3UWN3R245SHZHbUpjR2srS2FpQjdCdjRkclpyNkthZGtDd3BxVWkzTERGTXdNZEYyWlVkSGQvTzl1QTkzVUEwSldYRW5tckhUc2FlSEhCQmM1UUpRaUZycnVNMm9STlE1cnJzUnZDYk9iU01kYWsyaUg0UE5xRjJLT2g2WFF5L2phNkhmdDlSUXZSVkV1UGJieDl1bm9YK2xPOWJYbm5nN21za1QrVVpCdW90UXZ1Nkd2YVc2UTlxSThjSnE4b2Mxa3VIVG9aT2pHdllHUXEyRjVBT2JJWDMrVHJ4Rkd4MmljR01hWm9UdHJzcjIwQ1BPWi8zR0VhRkRranhTUkU2Mk5kTWFFN29jdDMwUGNrazV4OVlzYVJyN241Z1pmayttZlJmQVVVTit0M0RyakYxQjFwWnhBSEY4Q3IwRFl3QUZub0toNWFPNzJJN2hxNnpNbU5KMEt2a25SemhWWVp4ZVk5RkowVmJkbFFEMzhhRk5VV1NSQnlrcWtlVUpQUmpBc28yb0YvaFpReGZEbFFoeVZQZmtpMWJlT2oxM2dXWjVoclV6UTR0ei9NMW1xWUZTRHJPMVdhOEJSSnpreDdyZEt0QjlGM3IwcVVFOW1zZVZRSlJqMDJhKzZjVll2TjFhSjY2ZUdURWZ2dWluL2V5dVZwckNkb3dENlN4NkpKSGo3WnZQdXBvVjVTZDNCUTdPMTY4V2xLdXZENHJuTjN2Zm9KTTdwNFM4K1V4WjllMW1PUEtVSnk1Yit3UkRuWTlkWGRrREY4NXVkQ2N0blQ5WGZWcXVwem5abWRJWGRnemZvMW43MzJkbCtnZUZySkhscUM0MnZnc2Q4aWNoSWx4b0owcWlYbkRmT3R1VWkwbWdtcXBkWnliU21sTE8yM3cxNDYwQk0wVUVNeDNhR1F4MXNkRDVMSVEzbE1vVTR3cXJDSnExdW5BcGdnQkFsSzBEa1c2d25tQWU1RUhLam1lMzYxNjNZT2tuTXQ2ZVYvaWlGdms4a0JmR0kwUnJ0Q2NvemNUK2ZvckZjbDM5NThsNWJGeVhwemF6WWpNL0p5akdEREcyS21jMHlscVVmMi9lM2hKUzAxeGNDdk1jMnU2S1FHMW1Kbmw4dVYwbFp6ZWEzdlhqQk90aG9XWmh6Z1lXYWFSRjBzcFJtYUNhcEFvVnNuaGJzSmJQQ0tQMm8veU1CclF5ODdMQ1VGeFVhWUFWTlNhRnlmRjZqQTdKS3pYMUxtVExMS3N5anBNa3ZUWFdZdlhlZUN1R09hYzRSbm4rbjlMSnVxVnpKbE14WmJlVjg4eGR6SC9GYkVLVlpjRllVM2pkY25VL1hqV2ZwM05ZSUpWeHV6L1UvM2NsWVVneUI4NldyWnZTVHBPYkpzL0R2VTR2Y3hiTWYvZWU5ejkweno3STlIenVHMDRUYjNZYTlIbXRUMkdQWWppMjFIVjZRZHhqR05CSkYwTUZ6RVpPREZEOXBOMnR4TW1HNk9weUVBU2FIcjBqbUF1ejNoUnR1QW9ZelZsbUxJa1RNeUhtbU1nblREcFFxaTRlUm9hL3gxTXczaUhoa20rQzR5cThES3cxN3pHOEFyRCtLekxLeXBUQUxaRzBPN0E2MEFRV0pha2M2NktmR3NCV0ExR2hLdFpYbFlaVmVaWndXZUFFZ0lQVXVCRWtLZEphTmt2MFRqNzY2QzVUTDNxazQ4ck5sSGwrL09tSk4zdkVWdjVPUEdydWdsbkM1YVY4T3N1KzNFZVUwVGV6d0Z6cktyQTN2RGsvdi9EM0p1SFNYSlU5NkladVcrVmxaV1ZTKzJWdFdiMVZsMUxWMVhQMHQwMWkwYWpHVWxUa2thRDFsRkxHcUVWcVNVd0drWWdDb1FSWUFHRGpMRlkxV3orN0FjMmc0Mk43QWU0Ylh3RitCb3p6K1ppK0Q2dzIvTHlmUDFzTXl6MncxdnB4WW5NV3JwblJveXUvN2h2cGl2WHlJZ1RKeUlqVDhRNTUzZXdWTXZpZE5QUjJIaU83R1BINzhROFhHaVlBZC80Z0c5K0xLbDVaQTNaMFBLditEeUFsU2JmN09QMDZrbW8xaDBhRm92WkRJMWxMU3dBSWd0aWRuRzB5bHRJRWhRQXJjMWdGckRhSFpBV2RWZFhkVXd0SzZzVlhCbElqNStUVGlJSmkvQTVkQkxQQnlCV3ZJTEpyZURwQUU3cDl6UHFCV0s3RVlaWktXRHRkR1p3VXdwTm9WTjQ0c1NlS0JPQlRUV3p1cDVaUmJ1Zml0NzRWUFRENjV2cmdZMHllWmJNWnlIOXVwK3FUKzZQMzYwODFjQjlpbWpONllnMVEvdHVVQkJ1VjVpaFd4RWZXOVZwTTBzMENjRXJXQkVJRmQxWmdwVjFnR3lIdXlnMXU4Z3JYS3lkcWZJbVg4M3NzRGlGWDV5OTNESVNhTDVZbUtkUllrZjdXMnl2Tko5cDc0cWovbFFac1lOL2oweVhrc25TdElSRUNaV25abWNIbnh5RTZHdzJtMEdEZnl0K1YwT3RYQllOL21XbXVQV2RNK0NkaXphY3lIWWF0OUFmYVovWUZhZEhwUHoxbUQ3OE92YXpnMmZIQlkrSlFiZG54M1lVSDhObFphaFpINWRzNU4rVFR5UHdGUnNhd0VFTVB5eEtNaEVDYjRPVEFONUUxSUlBQnExb1pBR2kxMEE4Rzk2S0VPQXE5Q1l0R3RYZUhSZkYrTHZoNkgyNkxPdDVYWHEzTGdtbkkwY2NTWEs2dWx1cmhTV2ROMDdqTHRJM3RNRUxtb2svb2xGVFF4bk5VTlhCSjFGTENPdURGd1FGZFU5b1BLK2RHUHdKeXVoUHVPNFRZV0h3M3hWbHpDK29Bdy8yTHdqRTlIblV1WGcxOEEybjQ5dUhkcHdXcWpoZFIrcHRvNWJIWDNLVnQyczFsQXkvNWpWaC9yYnQxTW5jNFBNOGo2N2dwYWRkOStsaC9Kc2FudS8zS0pFeXFSVGxnaDBWN3NONVFDcGFtSVRsNkZpK0JSNEtGbzAzMElxdWQzVWR6RG03c05uUUIzZ2U0YjVJZ1gzb1dkZlZmYnZRdGQ3WnM3M0J1WTJOczBPOW9GOGVRM3gvaUI3Uzgwc3JlRG1ya0N2Z1BNNlFuR0VoR21kWjI5aFlkOTErYndKWDBDYklvVlhpRlpNakVJcE5INHNMOXpGOEpqUUo2eXlmMUVKZ1A0Um5LR3Uxd1dyTnJhWHYxSXlhdTltUDNLNGhDc3pIWFV5MTZ3N1h2ak8wYTJoMEJoOFl4dURYTnpmUDFYVDhyeGI0L2EyUDF0RHoxRFR1NmVDcmhQT0hXQloxZjhxRktSaFRZelc5QVB1cDV2YlFlcytkSkdFVktNQWxEamJPbllOOXQrdTZRZW40d0RBeVcySlVDY0F2Z2x5Tk53aW1lY1FMQzlVR1o1RTdPQWNoWUdGaWgwOTEzQVQ0bkJ6VXVsdmZUL0EvSTdsRVFZdGNnT1E5Vk91ZUk5bjBCMmZQVWVySTF4M0tCR1NybVpGVzZEcnFab2dPQWJYMkFORG9QSHZUQmY4OXc3WDN3SlM1MVV5anJYdXJFK3lkWUM5c3V6Kzg3bTZlM1NDOWF4TTI1L0FrRmY5dHVyaG5ESCs5clp2UkFYSzdYWERldzkxL0E1NUZ1SDhPMW4xRzZ4czR3VnJ3NndkUERjOWQvZlFxc1ZVTDZoL2U1b1UxRDFJTzJsWm5KN0RhRXNiV1cxdU9QYnhGMUtnaTM0WVlucjFhYldKWE8zdVdqQ1FqWXIvZFAxdGJxL1h4ZjMrN1d0dU81d1dVWlFGWE05ZnlSdTlBeTQ5U05uUVR3ejhkcmZaV0IvMVZQTlB2WVE2c3dwUy9oM3BkL0dMaE05ZDFCNmR4ejZPNllKemR2VkFaZUw1ZmorVGlhTml4TFdKeVFJN0E2d0l5eGhOOHNud0FKcmRRR2VLQnlaUDN2SS9mODJUUWM0N2d2bk8rUHhua3RZemdYUUhQc2htYXJBek9vK0dTVUlCSkJyWXk1VzFtcExDZ3dXTVJBZDBSaWtSQ21IZW1xWVh5b1lRbDNpQmFpU3UxWllGakJEN0NDRGZRbkdCSWVMTWI1QTdNM2o4OTBHd2VhTzdZT1RXMWMrcVhJdS9wSWplaW5kR2ladWhNeUNBdmZlWWJaOElNRm5Yd1ZJbmxMU3dtUy93WlFmNzl4b0ZHNDhBOVV4QVM2WGdrY2djeEd1UW02bGtJTUJWZXFwWU9QMkZWdWIxS0Y2N0trNFRjcjBUZVFBaGU5UEZaenlQNXE0UzZ1eUlSaGhDNDI0ZHlESEJCZk50MGhiUm5GY3NUMU5pQ0dhTGJqNCtqQWdmNGIxYkJqL1FReEx4MXVFN0pPV1pxV09qQkErR2ZEdzhPNm9NZmNFTDAzTG1JSWpNekRDdW1jeHFlbVZTVXdWbTNwa0VxVEZ1d1IyNi9sc25ybWhiOWU1VVZkRVhRbnI0emUyWlN6Z0hadVR5bWJMaS9DRVUrTmY5RXRqZGNrQTZmQXY4UFpiYVh2dFcrVy9MOTNhSldNL2hXQ0Rud0F2QUs4S0ZyT2kxOWRRM2hzUUc1dFZEMzQwaC9rWHAvQi9VMzlNMjExYlZOL0M1dGJIUTYyL0FEUXNNNDRFNlFFLzZvcmZXRERFNnZyVzMyTjd2ZGtiOGw0Rk9rUWNvakNDRU8yRnJoNlJKZ1V2aEdja1BndzhDZ3lTdkFtbW16a0E4ek02aE1GbHZyRHF6Skl1bnB1NU5ZYmcxNWVFNG5pcXlNYUxkOHNOVjQ4U01QUDlTYmNXbWV4VjkvaUd6Wm9CbEdvaU1NWWpPb2Q4Mk9jb0ZHdEtUd1V4RVdTL2x5eGV2c3VQMm03c29ySUo0a2JTTmEzSUVBNnJoYzdXNk5HelZFbTM4cG1oNStxYkpYTDFZS2xQRUk5UTBVSnZnOG9LWUJPSVpEck13dUd2TnZpTHlXaGYzanhrUWJpZ1NwRjNSTWZtcDZtekVzS2hwdjlSK2ZJMVBxTndFSTFCb0tHMCtTdktnWGZjL0wvNGVBUTIyWjErdVQrRWtFZ3NSdStOUHlNMjgxM2pCdkxHSSsrelByOVNlTngrSDhKWHdIakcxZ3dhY21pSGtEbURvY0gvcUErcFI4bjlnL1hNeVB3ZGppeHhCVWFjdno1L2t4WE1oT21Ld1JUK2J4dTVHSHQyWnpwUCtleVBiMWp0QldwS3loMThGZlJsYURaKzkrVHo4eTFDbFJnSDJ0Z05mOE9PRGo1OVNqUjRkL3lKMDQyVTV6RXVjUURBdkdLUExPT0I5VWhuSlAvZEtERDY0LytPQW5KalAxNlRnMWVBVHVyRCtJTXBPRmJNT1pHWllRbmNDWkNYTCtyZkZUNHp5L08zRXhzSEhlUUUvamZyZ2ZzRU5BMEFFTnBDOUJ0M3lZdXlHTVJlQ0tIcVpCNTJVUEVWOENaUml4VXJiTStrYzdla2M5Zk9nNytmbGEvcTdiMlZUWlM0WjNUYWZxSVY3RHM1STRneVFuT1pPOStlWlNLNTlrYzdhbWFqdnl0Y3YydFgvNHc3WjZ4UlYvVTl0ZjA3MTJ4WnhhekNRMFBJanFFaU1XbmN5c3ZsQkt6MGxXaHM4VTl0Vkd1dWtoN1pVZ1hoc21mUVVGdEJmd3JPMEM5SDJia0tmOE1kRDNWcjFnSGRoS1NPaisrNEVPOVR1WWtDZWYzRjdvMlBjcEFiaXBKWDhVeVoxZkRDOWNuSEhOSEhvSVNoLzh3NmpvOENJdUdxR2tWMDVkZ0ZsSS83TmFJZDlvbHpFeE5pYW1kRmtOMGM5TUxYclc5QTRYdUdSSE1KZEtzZXdjdFEyREQ5cVVRSVNCNVhJQTlSRTBhc0c3MUVaTm80OHFodzZySGYwWEw5Nm1kZ3JhdEx3d3ljb3ZLSWNQSzdoZDdVWWhYOWU5eFdsa0FyMGhudEFyVkdKWjNLcmx6RHlwVTNGL2paNmtuWUUyQlhsdGlGRFNjb2hkeVFVYU5ZMityVDlKbXBPMGJLZVEzYjJWa05WVkpBSU5UN2NKUlU5dkxSUk50T2xMdGVoRkd1MENUVE9jTDRKOGxhYnExUFc0RlVBZ2hDaHB2cm80YUFKODdpK3VZZ21yT1p5MEJzNlpYS05EZlBrQlhqalFjTUthSzRrM0htZ21tMjlJbEJBakl5MHFLK0VQbStrMHJPRnJER3RFN05RMEx5Ykw1ZVNIcld3cVdrV3FvUE5pdnNHeUtUc2V6OXUyVUE1TGtqeWIwa1dCVXd2RnhtWXBydUt2cnFYcHNwS3VaQkN0V1pxbUZ4TGx0cGUxVFJlSmJ2VU9WcFk5WGxENUtGTDFRbTQ2WmtZckRKMmNrbGdrcXJGVXN4REVkS0htU2IyelpHWFZyME5oSENTcXRZWCtDOVViM1N2b0lwOXJNa0xNY2tVTHovN0haUDd0MW1xOWl3MkpaZDdROGpHYmRpSUt2NFdhMjhmVUMrNThRTnNxd2pJb2FSUEEyWCtaTFhMSjNOWi9PamRITmd0QWorOEJlWDU1MjdKMXQrWXdscEZYcUQ3MU51bzkxUHVwajJLZWg4RmVSUWgrWVZTWVJ4T21XZk9vdFFMb0xaM2d0NEthV1RSaHJBVmVUQ3VvTlk4bWpMbnd2QVlQRWdMNE1mblpocEVGRG5nVDlsM05GVFRLY3JSNGJPTGMvUUNSSFdKVEY2alhCZFRQTVVrMUwwYWN0TXlsTFUxMHBaQ1ZacFdNWXdnRk5VVVhDblJhTFFwUjIxWFl0SzFLcnFUYWFVN0oyQkc0emVSU0NkNTErUVRqUmlOY0tzWHhwaXNLa21zS1hFcXlPTVBBbWZPNUhKOWtja2FFUzZld2lKMFRSU0dIN3lkU25CNTF2MFhnVm5YNm5wUW1WdmV1VGJtSDc1R00zSnRUT2ROT2ZVYlV6QXlucEoySWtGZHhEamttaFFtTk9sbUZHMUtTNFdUWGpvcUZVQm9JVGFrRjBYQXlNcGV4UWxMUHpJbUNtTU95ZnpMRlI0dzhuZkFKeVJ1OHltV1NuQkJReXJQSk5FOElGYkpaQVZmRTBQRVQ3RmNJRUd4TDFGTDMwSHMva2p5Y2NveGNPVHRUeGFUZk80cjU3TTg1UUdhOEFVc25WTlMzZFFDQVVkL21XaUFCL0x6eWY3VWJEQ2Q4ZjJPYnVkVGhFSkJVRlIrNTU3QTdWYzBaS1BkZmE4Ri9KazJBcGdVelY1M0pIbjZWM3hUdlN4MU81b3paLzFJVHZKdndFS1J2U3NlOEFwL1ZLV3FCV3FJTzRKbjhMZFM5STk4cWdzNUkzclJocUJ2UGRBTGNHOGRIWm5VV0NGNGo2UHJLUk1tSFArcWdGSU5Cd2dZbFZ3ZVEzUGtHTWJnRkpUeUIxQVN6WVo2WTVLSnFzYnEzQ2lzNmVGZWs5OTZ5OXl6aVpEaVhPYlRZVzF4RG5Na2hYVGRZbm9iUVo3VEJ5NWtLemRQNlVabXY2Zmlnc3Q3TDJQU09hS2J5N2Q1aUpSUGRRZHYvSU84dVYvZm04M3VyNWQyeXhsZjM3cTN5dUhlaGZCNXhhbVZ4OFpmeE1UNUt4MkpMQ0ZaeEdVUE5vR3BFTlVKVnRKSEpGSGxOWHhTYk9VQWx6alhGUlYzamkzN3NrQkcvOW1OTzNVRGRUdDMzRXJ3Q28ySjRtK0hyNU9VTHJYS2UyTU1RbTVpOFlPWHJ4T3JCTjU4aGdPYkFJcnRCdm1Dd3BpN2s4UWhSZ0hDS0RhSlRiTFRQWjlZYVluaW9QTEdGQWMrSWdIWDRFT0daRnpDRFp5RDZPMlpqVDYvNXZMc2FKbXpBemFPVmpNL0VDekhzdjlHTTZMT0NreUVvTjNBUC9zbWN6eENST1U1WW1NYk1QRklOQVF1WEViQ3puaUdNSlBpNTRtaDljeHQrYmhRSkNMOU44eWl3WStrRU5pMGdoeEVCRmIrQWZVVGxYNlE2WDFPK1Z0RjF2VmQ1a2FvSWFUVlZTU3VwRDZYVU5KcCtrY29qeXYyYThvY25LcFUvcWxSZUEydTVkK0M3cDFOSzZtZFRZS2NMOFQ0SDZDbjA1dk5vSUJSMEprb25nVFk3UGxveWVNZzhSVW9IN0lQZDNmeWNNL2RGQjIvdzM0NHV5ZzFleEx6WTErMytVYmQ3MG5Ydm1MT3JqbE8xVCtIOUxRU2l6UGNuQzJMYUc4VDd0OVVCWkMyaEVBRUg0QUtBcFpGWVkvUGdUK2FnbWo3WUFHT2RqM3hLK1p6N09lVlQzMlpaMVZKVVh1VGRzL281dUgzdUxjR3QzOGNYNFI3TGJpbEhJTWo2MUFvaXhRQWZjU0hqRWpiNlVFRC9EOXpQdWY4d3lydmZ4MW4zdTMrTkwyNk1jNTJjT3kyTzU0SEZ2Sy9SSDhrcG5WYWJ4QVJ1QXBnK2o0ZFlXOWlDa3g2b3Q3TWZXWnVyTkJpV1l5VU9vdnh5WnRRenZLako4UXhpR0R4dDUzaTZNVE1YekwzdVhUdHlXY3ZRYUZFWEZWTzFkSldXVTRsRW5LRVRpVVFLOTBQWk1GVmIxaVFaaFNPdHk0NXNuN2MySjlDa1FNOCtzbm56SU1BYjBTS1NtRFlRMTJWc3ZoaVlJNXk5WWVkTWd4RTRUQk9EYVp1a2xHVTRDZGVBYVZSMmpDYlBsMFhDdENUb3NxMmFCbENHNlV6UVRCem9wRlhkVWswRlY0TFdqTXRHYTY4dTBRbHFsQW4rcS82S1ZNZUpFTlN2VnJSVmlCUWlwWlpYaUd4MGU2WER0WE1Bekkyb1BlOUdxN0QyZlhqdzd6WFVxdzFPdTBnZm5LMzkwOTdCMlMweE53U1NMMFZXNENQTlNOU0p6S0JJeXlHZzNLNitjYzc5emNPMWpiTmQzWFZSYjdDSmVqZy81TmJXOUc1dis5cXdST0s4Z3g0Z2pZaUJtVU13dlRCMXVhNTc1cXg3cmpib282NExtZFJxNTl5elozR1cxQURXQUM2V1R3QW55STN6MGMrQ1hSckpDTmNHTWdJYnRVMXdPY001MVNZd0FoVmkrVXJXd1hIRjhOUENjUDROWGJxL2h0eTEyL0JzV2psMGlHZzU0RTFCK2kyZEgvMm9veDQ2TkpHUFNuRDkvSHc4M3lZZlFwUS9NOWg0Qmg1V09ycnVaL0J4ZUZEdGZKeUFUREFFWTNvVlVlZGhGTUZxL0Nxc3RNT3ZyK3VMNUc4N3JoRVBIQUNOekFyS0NibVd2NjRCOGdVSjdQbnh3ZStFME9xcjk5TkhhclVqOVA1WGcySGRhMTYvK2EwYnJxSVBsRW9INkt0R3VBUitmaXFzRDVWeUxTSi9FS0VFNXdVNVBUSE00Z254dWVlNlB6d3hmUDZFOXRSVFJDYnE0ZWRyVklSRVE2ckJhbVRKOFMxRHEyUjhJTzVNZVdMZzAyd1FNN3J5Y0tGMkNHa3BETUZTTGY4Q2VpTVdmMUx0dG5kNXVZUUhVcTlXUDM1ODl1cGEyNTVlS0Z6dUpVcWwrUWhCOE1jU0VzUWwwOEdpd0ZUTmFDSzZnUitNRnZONS9OaGlQS1BQMTl0YXFwQlBUTVd6Wndpdy8rMkEyYkNRTU1IVVFUY1NaalRnNmJBT2NlSlJmUjc5bzlWM0FnQVZFTXRmZ013M0Vyb09XWm9pRXFMNHJRUnRFQ0tXTllzbkZJZ1RjUk5vOHBaUm9HUk8weDM4bldvSkVVZC9ybkptZzhCM2xmN3dyaE5YSjI4NzBlLzNIM3NNVVk4TnNjN0pzenhaSDRNSE5rbmk3aWdSUjlLc2tqU0FtR05UT1lKa2pLZnpIYzREWFJ3Um1acXRNTUt2RUo2SzVmRW9aaldSMnoxenBvdENjMmRyRUtqaDdOd2MwdThnV0xKM3JLUHU2dnI2NnVyKy9iMGV4SjNwcWZ0UDl3Rkp0ai91VDFDZURLdThiVUFySWNEMXRqZURPb0VteUpsaENkN0dEUG9BenZHUk0yY2U0VHJDamk2bzJCYnhzRmJCUlhyU2V0STZmZG9xclFKUXdpb1VCT3VHVkF5ZFJ2ZGM0SnMvMHJJTnJVeTMvMUN3NXk1MDcvUmc3ZURpOEIrcUFBc3I0L043Qm1mMFdxMDc4ZmNpZGZyME92N2JlaFhxci81VUdpOUtJWGVwMUwwMGJXdTZmdnA4dW54OUFjU1V6cEM1TjI2WE5JUXBJMU1WTERRQ1FxdHZsTjFzdEoxV2ZuUTl1SGFPa1JuOGwrUFRsUjFDMXRJWmV5WloyU2xJR1lReWtsbXJ4TEtXNmNvNzVxTTg2aUdrZnhnaFJnb0o3MzdYeDJoR2tSVDJ3KzlrRlVsNE94K1NSbm9BbjVhZlFzbkZpNzFRS1VQTVpPckZJR2J1YnB4L0Jna2FBOTR5Qzh0TU5BaVlpK2NKRHZsZ200SkdCeWJteERROWlPU0wvNjlldmlweStabTg0dDZHWWpsWGkxZjhvTHF2RTJyNWVqMENwckNPcEJsVlJabUxLcEtwaGRGNjZ5Tlh6ZS9QYXRkZFZWbVptbDRlckFXUmRtRjcrc0ExaXpPN1Y1eDRNMVBPeEUxUmRPUFZxaVROeldjeXZCaEpwbjBicGhIZEY2ZjZZbVM5Wk9sYnNLUjNVSmZCZWxqSmhrRENPU2hoQmI4YnJWMklmSkN0NFM4TVp5UW1YNDdva09icEphSm90NFJPRTJKRHpxQTh4S0FTNmp4WnRHeUFxMVlkL1l5Q0NnRHZVVUlxQ015ZzFLM1Y2SEI5NXkyR0hrNGdLaFhpcGRjdytNNDNENzcvb0V6UHZsRDlxeWYzU2FyeGdpWUo0dFYyTEZrcXB1ellsOStvRTA5Q1YyZll1UDZCWXRLeFpkMktmSmw5UXRmZitOVkhIOVVqbFlwKzhpRk5VVlZCc0VOamYzVS9MbjJlS2xQVFJGKzVUTEFXaEdCTnAxTW5wRytwTmxRVkRCS0U0SWVyM1hJVzVsSEJoMVJ2b010RlFkSmVNRlJwMzVNUFQxWnVYVjhqdGRzajdmeU1mUEFEbHl2VkYyYjNoR3hCVUZWRmUraU95YXE4OFNIZGo4Z0ZmMStONkk4K0d0RUJBekV4OHUyNmpscWw3cWRlU3oxQnZaUDZSZW9UMUdlcDM2YitHL1YxNmp2VVgxTC9TUDBFc1NpTW02ZU1GdEFTT294ZWdlNUNEd1B1bVc4MU8zS3l3SDAzVHliQy9OQnBHSTRMK1FXWVVIZUdYc2ZFbHJhMTBDQWhmUU5IRElHWTFUWWJwbWY1UGhURXV3TG40L2hPR1htQlhDRXZpZ0JoYjRpZW5ZVE82bmpFNjZ6UklkOTM4RVJqUUVoditwSThEMzBYaThXKzJGNE92cUlCelczY3FjR2FGMTVERzA4MUNkQUNJWWhVQXFleTJ5c29xQXhNOWpGQm9OSXMyVUtaRC9zdWJRS1ovZ0kxRFdFWnJTQ05kb1oxWHloRGFLV29UZUFDbG1tUHBNWlptTGJWRnNCTHJrb0xnYSsxNDVzUUYvS0ZVVVRZZVpTaG5VYXpFOWpkMnVqKzBpSk5OeEs3bzZ6b3pDVXl0QmhlREl0MEpqSG5pR3gwZDZKQjA0dWw2Ni9QN1diUVFnd1N4V1luRXMzR0lGRnNBVEc3Yzlldno3Z1ptMU1VenM2a0xEdEdlN1lqQzhabjZKanRHWUxzMkcxM1pqNEZLVUswM1lQN3M0b1FPWU52VnlLQ01uc0xwOUFLUjNOOGlCd2dIb3NTb05wL1hkaWtHU01LVGlBeERjOHZaQlI2aEVFMFNscHdJMElqRmJ5RVhtWGtWVFVmTVNKUlR0Z2hjaEVSMzJQb0VIcE1uSVk3T1VPUG1ubi9Xb2lWcFA5WFN3ZzhUUFlkbmFVak1WbEZnc3A5T3FLR0VvS0FjQ296eWdvY0E1ZS9LNllrbWRXbWxDck8xWWh6RmhOaVZVNkgrRjRucWlLTFgzOHBLY2xjZUNvT0RrVndWNURWVDJnOGswa3NSZG01UklPd2h2Q3ZrWmhqbzB1SkRNTnJ3RDNYMlcyeXMxc1R6TExtYnNjRjlxWVpHWmlCdU50c0Q3UElpWVNZVjJLT2Vrd280dGc5bVNFY0N1N09Sa1BNM2ZobWhRbEZaeEdEMlQvdk0xb1p2TjdPd2tuV3h2WCtHREZBZTF0RFJBWENyU1hGWWVXSWFLRUhqTHlpRnZTbWlMckFPTVVSZjQvR0hJN0ZlRVVYWkE1ekdIMDhFb2NXaU1lNElqNWpPZWwvS0VsSnhIeFJQU1NLUWIwdDlMTmlWVXBKRXFmUENGN1ZsUEYxalJWMktnbFJCR2JIbzBvRTgxVGwyVGNrb2pLbkVtYlRSVVRZejB6Z05WNkJSL0xicVZkUnI2T2VwSDZCK2pnZU42aFN3eXdFQXdOLzNxaHdvU0hodkFGaE9CeU14cGEyYjBCQjNremVkb1plWHgxNE80Y0RDTHlRays5ZmRQelNPVFkzeER1QWQyN0xHNGJ1di83NjRMMHFMMDI4TDB2bDg5NG9jN2ZmSTBpWDJXMEdiOVBlV0h6VTc2OEx1cnFKdS8xaTBNZW5jQXVlSmIyYUpUMzh2Mi9wME05UDlHTTZNdmcrNmJ1aG9DZWp5N2IwMisvNkpSUEtKcnNpSVh5aXE1b2p5b09LbVVGWGZUeHZCRjNxTE9sRFJkeWJmcEgwSGR4bDZHdHhsNUZKNS9ueVJJOUJ0NDI2Q1JJL2lQc0ZGL1NSR3lZNnhtU2NhTUFROXdnNnovWllFZURRMmZUeUFCU1NhempFdGhCUU5BZ3VkejZ3bFVLL0lvZEM4bUJORG12S21pdzROUHNSaWVIUWFZNFJma2hPa1NjTzFrU2VRYWNGdElwVG5sVzBzSXg2Y2dqZjFJVkRDRTBMK0dqd0s5OFh4ZTh6L0JaZGFJak1QQm9UQms1TmdzNVp4bWRDYTBRaGVrNzBLUkRSUitVUXd3MTZIRE1rQnVuaTk2SEE3NHU5a0R5TjBDRlNMc2pjb3pVYUg1RVp2djR0YW9uYWo5K1FxOEYrYkx4dTAyNTJ2QmFlNXpkcytKUXd2QUJmbUN6ZGFUbWVZRG5OamxQMjRHTUhZZGM1R3hZUmFRZVdXQ0Y4V0Rrdk1IaXM5aHdBRWZKWGRmNlZadW1ZZVo4WkIvOFp3L3B0bTU2NWRrZk81dXFYWDMzZ011TWU0M1UwTEpOM2RsN2VIbnlSVFIrd1RGVC9pd05wdHQwdzk4M2JOV2NHRC9YbVIyYmNSWHE0OEhPTzduckkyME56S0ZtcGwzN09udS9TenU2ZGI5NjVFeDA4eURVcXJRTjFzN0p6ZDJ5NU9ZVzhxNUQ5YzJpcVdYV3UyblI1ZnZBMVZOSWJEYjJFbUNBbTVwZ25XU3dSQVVkZWlnK0VCeGVxK0FWcmV0U3Y1U2N2V0xmeksvTklVSkgwQmNrUC9CT3Z4ZjJrU3RvUDdFWjNVMWRTTndEZUplNHhNOGdDbjRZbFZNZ1RDOWtXV01tbVVSQTllY0dETVkvQU52cDdiNFRuR09EMkUvbTB0VFZjNE1jNURzc2xYQUh2T0p2N1E0Z2VIM1dpVWJ5L2xXd0wrS2NyaVJlOHhWUzYvRUk1blZyMHFudjJWRitBelZuOFJHSDh2S2ZvU25tNkRGdjhtMWJBUlRpYVc1aWFUaVNUaWVtcEJYMzVlTGQ3ZkhrWWI4dXZweEpZL1hVaG1pMmFJSXk4bTRIdGI4R1AvVXBFMFNYUWhUY1dDTmluNCt0Sy9mZ2doVHl1WTNBRFhUTWljZ2VwR0ttZnhSZTRrNlJXRFZKUG44SmxjZ1ZWZmVwZU41R1dLekJCVFpUeWRaZ0xVYkVGNXhSWjh3NXcvbjM3SkwrMWpnRFNmbkZrRDdnVmtYcXJyV0NnbXJUNTRDc0FscHJCSVFGOGFEYnNodit4Y0phUkQrQkFkQm9CcWdQK20zRG1CalA5d1BFWHFiaE91cnBJdHYvRGRSelhNY3ZsdjU2NGVKUE9SbmtoUGhOMWQ4VjJ1ZEdaT0JZT1dUM2l1YUdRc3JPOVV3bUZYSS9oUlZiUml3a1Z6MGtxQ3hVczlxdUpvcTZ3SWsremNralhiVHV5SEZ1TzJMYXVoMlQyeDZSTWwyeXZkUEtPa3krVzV5YXU1ZmJlS0RFTE1VbUtMVERTalhzUEhKRFljSmlWRG55WFNWODJ0MjlGWkRoWjVoaHhaZC9jWldrR3FacVo0am1PVDVtYVN0NEhuODlNMEU5V3FNc3hueW44ZXVXNVMrQWVlNUhJTWRzanlod3RsOUh4UytETTRMY0lULzlvZ3FHVEhQOVJtYjlJWmE4bmpHRkk0a1dmVlJQSFc5ZUhvVS9kUnYzOCtYaTdIVjZ3QTdtRGlEYit5cm9UZUp1UEp6SWd5Z1RlNWUzUkNqMlJlSWhTWVR3MXNoMC8zRHplbTZBQUk2R2g4UjZDczdkOVZaclhCdldhSDRrZTd4dnZKOUNoSzJTQkx4NE9ZekUySEUxS1dQNFZJWGFYeUFtc2xJeUdHWm9PaHprMVlscTZ5djIwVkxwbFJ0VGIzTGdXMHl4VjFFWFh4UnZWd3FkeFY5MnZYdXhHQUU1Nmtpd20vakVuaUxvWmpxSlJocmhZRkEyYllMTXhMSFNjWWtqWWxoUkpVYy9HTkRZb2xOVmlXYi9JOHk5dTlRa0E2MzZxZUtrTW5HVDYwTGh5OWRKcVBIRmprelRBQ3orTjBOSEZ4LzJBcm9HTWRBSy9VNm5BTDRFcTRkay83Mk1CMWdtV2FOMzBlMHFoMVNTZENQY24zL3dJajFjQnhTUEtQeHNPTTRsa29keldUYjFkTGlRVERGeElGTjI2cU9aVnNlN2lTeWU3YzNQZHVkOGwyNjhaK1ZpOFhSWTFUU3kzNDdHOGtVdkVTaGxWelpUaXNaTnpKQW41ODlmSGhuUytMQm92aWFhWG9tT3liWWtlRS9tTFFZRmJRS3ZwNDV2N3k3aUFZWVg2YTJ0cmVsOWZDM1o5Q09rME9zUC9UdmY3MjN4UkNzTTRMcEVjYW8xQzB3VHJUa0htK0hxLy95SkZZalNzOW5CV3NBaE1kbjBvQVYrbHhwZGdGMkN0QW01cW5FVHJIZUhraEZGZ3ZFVll0WXpHU3NaaFpKK1JXcEg0Z29QTkdicTh0WCtxc2pzMkxZbXB6dTdLMVA1V2RrYzR2T1BPcUNTbHc0WVJYMDVxV25JNWJoamh0Q1JGbldKNTJuV255MFcwdHR6dU5PcWViakdNVVBUcXVOOHZwK0x4MUovYXlaZzluOVE0WWM1eDVnUk9TODdic2FTZGN1TXBSVW5GM2FGdDlKRCtsNkQrSXBSZHJHUy9QYStsK2xqZUVFQlRQTVRRN2dCMHdqREFFZThVRm9pRjNXRk5salU1b3ZNb2l0TFJtQkdMbytqK1JQNWFHYTdmRzlidGNpSmlHMWJNWGs3SGs1T1lEREJ1ZzJmMytSYkNqUUFJWkV0aDlnVnNtTDhjTHlTMkZMeEVpTmxxVGZ6RlREd1IwM1VMMDJFWk5xYmpkd2hwNTlrcWV4ZjRndmpGVzgxeWdCREJDODMyd25JZzNYNmRGTlpNNUJQN295aU9DWWltTVNtc0ZCVC9CejRIWXNsNGV0bU80YUlqaVhKSUNNdVQzeTZSUkQ3S2t2aGVmcmZtV3A1QWVqVGpXeHdUZTRDQ3RiRyt0cnFHYXFkUDkvcmREZlZ6bjFQZHJ1NmlYdjlzdjM5MjQ3blh2T1k1M01YWDNxKys1ejFxZkhVdU5MMXZTMnd0WXlML3ppaGJrdVY2a0ZtUTFabGhGb0dkRytoUXdRc0oxa01MK1FCQWtRRG5nTkVBR1ZNV2ZHeGRNbUl2QkM4SVhFSWZUNmN6RlMvenVKM1AyWTVqNS9MMlRHZ2FydURyWGdWZngxZndkWHpYdjQ3WTlOWHBWT294MjNhNmptMVBhMU9wMUhsWENGMDNvTE9vQWhxSlM2T3J2VEJCMVdlejJVeDFMdk1HTTVzeExjdk1aRTB2N3NFVmZIMnVpcTluc3BVS3Z1ZGZSWEwyV0RhVGVjdzByVVhMTk12eGNpWVRYS25zckpEem9ZMGkxVVdBRmh6eWZZbUpLcDJNZkdJRjNBdHJpS3BVbmhIRmsrSVdYQkltd0svZjlreDUyeHZ4bkovSEt5Y043NGY1L2ZKV0EveXRmVG8rRVVjZ2tOOThCWHh6WkVIL1RTS0trV1htb09NYVJNajZndGdIYXNlWWZHQzlGbUJTZ3NmSU1GQWxnUkFkQ29mTWNLRDBUWTlBbXRxR3lZTjdDYjNkRStsVStYV2ZmdXl4WTN2YnNxSlpDWUlnbW9ycjRiQVFFa1ROWWcwamYyMCtuMHlFdzJFOW5pZ1VyeTRXM2pjV3E2cG9SM3NmaVlKWkZxMVVNVVJDVTI3R1M4V3lWelFNeHRJQTNFYlR3a244cEZjdWx1S1FUeGpSRTlJUXZDckc2SDJSaUVZM2Q1NGY0cXVvbjhFemxwK2wzazM5SXJFNDltZUw3V0V0dHZ0WGVZMGhrNFpYaXR0U2xIL0tlU2svRENkUTN1YmhQL0ZFRVB4eHhNdkROdTdmMmF6Z1dwWnJQemFiemM1bVMzQnN2ZExKWnF1WkxPL2F0bXVoWWpXRGs1WFBTL1dHS3FRcStZbDJUVDd5L0xaVWpwMzFrOTBQYVd3bmU3TUZwd2V5a1BQdTROZ2gxUGgzem1ZaGgxMFc1SERaUlk3djJ2SkVDV3BTWGJMOVZMWXpPZ2xpb1kvYmF6ai9oLzU1WkxKMThnSEh4cTJ4UGZiUmNEL0I3ZkdkZ0x0RHJyNkQ4T0NZenhaa0VSN2VUNjY5aXZBTkhmWnZmWDUwRFZkbnlCL0NtR3hRd1hlUVNrLytyUVIzN2llVkRwNFlZc0pDekpVb3RRUFhidyt1SVlWTUg1T2g0QXNsaEc3QmYvTUkrRVVXNXJ2NEsrSTFIZkNiYmVJdkNyRTZxaThJUVhSNCtDRTNrMktOZmxSME10ZS85dm82bjZ3VTd5bFdrbmhXWitsdUpPdG1JNjV1aVRwNnZOdGJYVjFGMGFucHNwQnRJbFRQYWRucHFaM1hYZmR6WXFsWXJ4U0xsWHF4bEJDMG9yZlc3YTdCcjF6U2JFUy9RSUE5QTJ4UGRsU1BjWlRCVVMwNkJRQnA5d3J3a1JyWGlEbVBWdGZWWFNETERXZytzNVd5ZnJmYmg5K1l3c0hQVDlJZ2JwRXB0OWplRFRGT25jRCtEbjZBSXMwSFA3UUdWalg2b044SHdLb044T0RHLzhqVk5YRHF2a2ZYVjhuZmM2NjdTdjZDOWFrTGxVZTArZTNHUW40aCtFMXE4RWw4TVQrK0VhSklZWENsNTNieC8yOFBTNW5rcHhwRW13WWNFRjlsTm5iZkM2TXEzVG92aE16ekR4dzZrSXZIY3dlK2NQTG93V0pSci9WZVMyeGlaaXZKWkNXSlRoOXE3ejI1STUvZmNYSnYrNmFqdXh2UE5KdjJaUjl2N0dhSkdjd1ZTVWcxRVF0SUJYc29ZNks0MFNyQk1QZlgrL211VCtSMXY1L0xFUE1WNHB6NkhxTUZZa3REVEM5OXExVndiSWJzd051NFBReGJYbTZSRlNJa0xnNDJGcGVPTFcyY2FSNXEvdDFnODgwcEk2YkhjQ2ZaUEhmdTRNelMwc3pCZzZWbWMvQWJaOCt1RzFwTXlPV0VtSlp4eDloZ2ZybU9id0U2V2FyZ0d4TmpmbHJOWWVRNnUyR09TMXlOR1ZCV0Q1ZDdjRnpjVjNEK0JpbHBIUW91SGV5NXc3Sm9DcGRsNFg1ZkpaS0xINGJiR3dxNGNMaU1vbGc2Q3dDcWlCd0Ria2VOdHRjVVNoMEhVY2RPc1NpRzJBZXVyQitMMHhhZHV2M2JaTHM0Y1Yzb2R3ZmRiaGZnbkp3b3k3R3gwSlVQTkdZWmhhM3ZHSHlMN0NadnZCVW43UWIwL1JqOVQvUVVpVG5tbytzUTlNeE9uY1FrOGJFK1BEOUNzdUQ0T0tKTEtBaE9naWtzRWFFUy9ibXkwSkpuVktRajlPQlZ6UnZpV25LMWMvUlJWSUg5ZFkvUytQcEQrUExnTnhlVXFXbGxRMm0xbEtrcFRVQ0NkdFdEQzdOaWJmSFI2NDdqN2M5Y3g2RGgxYTlDa2drTWl3Znd1eFNCdGlJK0RYN2NNaS93ZndQYk0veisrTTUwWURDRUhuanRhOTNYZHZHUDdPUitYKys3ZmQzZklYYi8vc1hMM3Y3Mnl4YUQvZk9IRHFVT3ZmZTllT1B2UnpGVy9USXZVT0syL00vTGNRTERBZnpuWjZrRnNGN3RGQUJ1d3lLbUUyQWQwUUtyS21zY0NLemplOWdUU0FjTHBnS3dxQXNBeXB1dVhxdnBaS05EdzNYWCtvUFZQbUE3bkI2Q1M1d0w3cnQrQXNEcTMwQjRNQUdNaHd5Z0VrQUVMbW9DMnlKSzdPOFdmQ3ZOR1V4U1lRa1JYek9JdTN0QlNuengwWjkyYjQ0SWNydGJhRmtuWlo4WkVkeWZKT09jVDlrSTd6eEdNSGhrRXFXbmhpK2lEdkpBMWVQd0hlaDl6V0djUkV5U0VJaklWVUlmTWF0emVDUVBCaHFpbjhsVkg5YVh1TGZabFZ5MUhwTWprWis1N0tOWE5BNUU5OHdsYk1seDBYUGk0T0NqdGNKcmYwKzhMaFQrZTdkZStOQlVQcEp3ZTk5WU1Zd1Y5b3BHcnpmWFZYUjFIRU1kYzRpTURmT2oyRVZFQWVVRW93RUlaQjBJcHJlZHFFYTdkZHZlYW5WdjlWMmxoUkwrcTBYMk5RSlNidHFEMXV1RkR4VHFzUG5pQjFLVlNnbzI5L1VhVjdBVFpIVG5odmhFUGcwRk1nY2ZCY201V0trZkphVzZrOFVkSDVYMjhBWEtnUDc5ZWJ6NUt0UzRCQkhnQUZtQituemt2TGx4OUVKK3ZEbHJjaTYrZ29uZE11OCtFSW04Vk55dzRkT285K0x3d2R2d0UrT1lPZ1I3dkFROURVYmxRaVRIQVJMSjVwbnU0TVh1WjlEbW9JWTJBRHRjUjY3K0lqV0t0emQrTm5yKzAxRHExaHdHUGJRK21jdTV6VTEvckxtSytqWnE0dkU2RDlxa0RqOE0vakYwZzdPYlFxTkRZR1dKQThtWEZWbmc4dTNhL3JtaXFJbU0wcDA3VkU3VzkvSHh6SzZmWlJSaGFsL05XMUpvV3VYdCtGeTNFbU1QMW0xRHJhZW5kaExDaDJWZHBLVHpNejgvVDZJakF2VE16Vkg4VzlBQVVPMXRNNGZ0TTRuaXR2TmZCaEFpMlNYR0lUZE1IS1BLeE1tZnlIQVNJeFlQN0VXT2grMHhTZE41OGVHSHN2alRKTnNIL1pKOEpKOGc2T1BFbjk5Zk5Xb0RQUUtSQTZQNFRaaEhKTlkxRHl2MnpVZ1dOWndOL2dwYWRJemxwdTNjUk5NMHVnbnRFZWpRaGhITmFJaVo5V2lFSWxHaTZ5UjU0ZS8vSTJCUFdDS1NLTTZsZ2I5eExjRXlKN0p0ZFZCWFZwUExDMUpVWVgrWEZtMWpaY0d4TnZ2MWNDVEljZDM5S00xRW9xa1FZdWJ3K1Q4V3FBdTlQOE9vWThNNmwvREhDbVUrOU1nakgzcGs4UGYrbTFCYnhiTGlJM0RwemVSOWtEZjdGM3Qvbkk3UURId0VWamY3d2Z2enJjM1ZvRnlJaVZqSDg5VytIMGREQURSQVAvWkYwTDF3Ny9JMVl2TUFnRG84OUpkTUJCSmJvMFZXVlNBR2pnRFJoV2hZVkdrVnZEQnk2cjR4UnQzakJZMGhTTHlORmVRVnlwMTZ1K0Uwc2ZqcFlHa0d5eTloUEpLWDVWQ3pVMllZR3JGYyt0V3FwQmtzbTdOb2xrRU1GNVdXdENMREFOaHNMaXBITlBscWxlZTR5emhPRURrTzRSdHhGQW9oVExFa0lDczJxMm9hTDRtaUlDQldZR2xFNjR4NGw0SHdSVU5BcVJ0ZUtYSjNSeTZuTldibDVtL0pJVjB1VmJJTVl2bkNVZEhRRklGdFJXakVZTkhsRGp2RDBBeGZTZXZ5a1NJckFmSXVMbEFVTVhsMEJrVndjUnlQRE8rQUZ0RjRubE1Sci9LQXphdHpoMnk0RXR1enJqRzdJNCt4SXZ0UUsyZ2I0UFUweUhRalRrK3dlWUZ3ZDhqbEVZczdKQjRCL3RCSndCNWU1TktQQUc4NEtTcWErTXdFenVCOXpwQU56SmFiN2s0ZFNEWDJmVXZDOVNwWFhFNzBxeVdMU0V1SEl2aVUxQXZ2U2JXTzcwcS9Ucisrdk1YM01FRXdyTW9FUXlvM3N2QUEvd1Zpd3RGdWdSL0Rsc21QUUVMeTlJelE0RXNodzlVbEh1M2xwY0ZadmRidm56dTNzWUdyUFhnV1FtaWl1ajc0QzE3Qzk2K0JqenlXVFhyRHY0bnlKNzJjSnNySC8xdE9ZRVE1UlBhZEtCU1h0VkU3ZDI2aXJBR2VjdUJKb0w1T1prSHJRYXdKRjcvSHE4UzNRYUtvVm9raDdwR0NnN3BQN3doUHZacit5WFhQZjJDdzhXcnV1bitsWDFjYzJ6WERNelRRMkNvSkhjWkQzVzk5NittRjV6L3cxYThPTnU0WjZxejdKTi9oM0sxRTdhTmU0ZnVQa0hrME5DSHgwOGZsOFVJUVBZZW90ZkJMOGZKOXgwL3I2eDFGZHBYM0txN3lGVG1yVFBHOE41M08yZ29UampudU95L1ZqM202M2I1UDErL0htU0Q4K3lNbHF5UTR3WnhKVDhjNUpwS3pTMU9YNU9jc1hLRCtIdWkvTGxqN0M5VEdjOGlYMFJJS3ZOQ3lmT1pzcitIUGJ5V2RSbzZIRU5KSnRTOVFqOXUzRUptaTJma1k0aENTSWdoQi9ZaGM2OXVJajJLWFJBc1JFcGZXQ2ZZcjgvUDZrWE93SVU1SGZ0U1M0Y0ZXbTNmSWcvSTdhVE55NUk0akFXVGJZQVBMcXJnazlIcmNyM1hjbzJ2VUNuVU5kVHYxR1BWQjZsUFUvem1LMk9PcjE0bWhXM3VJVGs2c0RrcStKcDVZeHhGbG5MQTgwaW1Sa1Jqc0Y4Q05EWFJMQXNTaDhIalFNNEhxRG13YkNyenRLeU1LZVFoamxTZEczN0JtNGdSS3FwRjJxZ254TUpwNFZHNlFnb2s2R3c5RXhEOU9neERsRG00M01BRUExYUNHME92bGtKZ0tpMEpFbG9WMFdPVERxZ3pLWjhiV0JFNm0rZGpnUDJVNUlvamhsQmlTK1RBdmh2RjR3d21hellDcVdnN0YrTXNzbDJHaUlZTTNrd3huaE1LSVRZVVpNQzJWaFJCRG15RkdTYTMyN0VoY0RQRjRtb2lsTHBVUGlmR0kvWUpXTkF4akZ2K0ttbTdnVVo4Rk1RQnZReUVqRXc0WkhKTTBoVWdveWpDdWxXVkNnc3hvY1pyUkpaa05tZitSekVSampEaVhzT0lNZjFuTVZCbTZHTTJ4cUp1WUU1bFlOSk9NOGt6OEtQN0VGR2xHTldQdVBsUkpGV080ejVUU0ZmeU5RbzhhR1R1TGFGRXYyQm1FbmozZXlXa3F3NGhJbGtsWU5TM1hlWVhrek05YXNxTEkxdXk4SThrU1lsU1ZRZEwzVU5pcHBFdFlwb2dWVXg2NnFxQ0xOTXJhNmFpQ1VJYU12K04ra3NPejZxc2dOdGw1dllQYjNoMmM4OXIvSXUzZDJkYWU1N2ZmNEsrM04xanp2QmFTTHRnaW45dkc5UzFjTGsyeTF0akd6L1FGT1BqNnJad0t4aGNmdjRPaWRsT3ZwejVOL1NIMXJ3aThFSEZYeDFQUmhTM1EvandXdGN1T1gxMG5ZRXZiQmxXbmhzQTZtOHpIOEExOGVaZHZBQVNjd21OT3F6MzB0aVR2RG43QnpBd0Vndk9qd0ZqNEdUcU5oakhpd05CamhpWlNZS2ZGWXhHbVRTUkEzRVltdkUwa0pnd1dEdkV6amwwQWtJOXlCeWJIblhJN2VMc2g5SkNGODZJRkRxaWVScVJKT3kzZmtHU1pCaHNVTU1UQzVFT293NEtmbGVYWnUyZ1NrRzZodVMwek1GUFp2TldLcC80dEtYc3hMUFN3TE9ESzR2Y05wQmloYUprNW5zT1hHQWdtUUNOOGlGOVhWVWgrV1dMWWYrSmpRZ3BMVEhpc0YzRnFDRTdHSXBwaitHVWpETUVIYUFiTHgvZ2NQOHN5TkM4WnJNTXJJVjNpNkhnbmkzUVZtU29XMDBRbE9jWFRFS0NBVTBYRTBZcElNMXlrS2hxWUFwRlRjWTVzTXM1aG9nd1JJWU14OEh0eEU2MUZGQ1J5aUZiQ0lFQnhMTXV3RFFkL3NNQ0xsVVVxeE1hVFEwejJHb1hWVTB6SVlNTTBNa1JjRFM2ZXhKSWR5K09TR0VGQ3ZiOFFDM1l4S2tpTXpFWVptcFZGSFlraFpDTTJiRWVpSmtKMlZJdmpBckdBU0FzQ2oyd0ppVWlSWlZ4UlYxTHdkNVBGZ3FZaUtEWitOVGhWUTV5b0NyUmlHRW5WMUxNMENaWEhxcGdEdEdCd21EamFNbmlSUmZnaFY1S1ZqSXpKMVdtd2RJa1dWYU1rRlZnbGhPbkNURk40d2oyT2pvUVVJY1BSYWxWMTRsSkRvdE02RDE2NnVxQ0dvRTBZbHRFQWJrd1NiakJEcXN2YXFzSGo3eFZpa0k0d2JVak9KQldPeDd3M2ttaVVCNWNSK0JIVzMvRDlXS0ZlUzMwU2p4MzEvOEs3NFRVSnRySGZ3V25jdjNINjFrdjM4SUxRYkdPcHRuREpuUmt0dmZ5KytoVThoZEprNkhVWjNPdG9FL3JVaGJ1ZGhwc1IzMnRtZTVmV3d4NytYKzQrc3FpUURzQ0hjQWVnQlZxS2xpN1NCZkRNUnBFemw5Ymc0elVLa0QwcFBHZDRHNkIzMmFSSjRUTzhBcEZDOHlSY0RSNytJVUJsQTdmSjBCcUN4M1VsZzF6VFIrWEpWeEcwVEt2VFdrSCswOHNBVE4xcHc2VmxwclhnRHlTV2lWdlRncmJGbnpuVEpycWhMTEpHY1hMSS8vcysybHBmYjRrdUU0R0JRaEJ3KytCYXNnaFZEbFFRaCtkRTBKYU1SUE1SeHIzejdTd3JHYXJHY0J6dDhNUXdIak1kdDZJSW9BODh3V1RROUZSYUQ1RkRNdERRSWtTa1pEZ2E4YndqODJySXdLL2Z2M3pNZEYwVDRnaXdVN0xvcXJ6T3NSd0twWk5UVThscEpORUpYSzRqR2lYYzBKekgwN3dBa1VsRVFZeVowTTQ4SXh0NFIzT1lmaG5JNVNWVndGS3RIcklGVmVLaFBUaFc0M0VUWVNsWlZ2QzdMc3N4L0RTbWtSVndia09mUW1pTEdwbTl2YnhtUU1xbHMrem9wVmMwV0ovMTZWSW9sVnFpM2p2RWQvUU5xWVQvWC9RWTFJMXI4YmoyeGY4ZEhRZDVVSFE4WHYvZjI0SG9pWGJhdmEyTlhuWnY4dG1adW5SdURwbndweStyYjIyTnpSZ2g4M0dDOGN3QUZDbkJOT2dTRTdxMXdYb1A5ZlhCdWt2aU5PcWdPMEJyTmJ6VnQrTFZFZDhpeUFXQVBnb1IvK251NEl3ZjNyRmZHNXlEbVJVNzhqOHlxUXcxQlg0RktJMi9VY01RVE1BcDhrSHp6Zk1oY0lkdk4xSUhRQ3BMd0NKZGEyR1piaUpLL1p5a1J1M21pbGNzTElURGkvVlhIRHQxNnRqK0I4M24zVnFwR0srcW45Ty9qbVdlV1AyR0hlaWhiNmpzWERTUzBFdmg4RUtoNlBVVzY4NnBUNS9xcmRUUDBicWVhVjlSZHF2Lzk0OFh0TGx3dUhoZ3BidzFkcDRFSzdMUkVUbk1tSVp6d3hMSEpmWDliQkUxbVp2dlY3eUo4MHJpdWZNaG5CdkVJQmtIcVFYZEgzeC9pVVU2K0NrR1lScUVLTDYzQU55QXU1Q29RSUtYa0Jjd1dFellkUFZRdEI4TjZXNlVUNXhLOE5FdnFkeVhPSlZtbFZNSyswRWtTRmlVL3hJVzZDVUIwYUUrL3VvMWJ5bGJlMEpSUlk2cSs2enlMYzFYbEVPaGNqYmViTWJ4U3phNEUzK2s4S2M2VjdHblo2dDFMc0t5RWE1ZW5aMjJwbklzSTZPQUw2TzZYSEpOWHBMTW4wTFV4Rnljck5ORUl4MHZoUFEvZVlHb0tmWU4vdTJKOVlsWWZFRTZDdGJ3Q0VEMCtGNFgzK3ZDNm1scC9JTGlqblF5OHVpamtaT2ZoODNKOHpGQXo5TjNUT2pvSnZVZVh6a0orV3hWZlh6RHozbzdGa3gwVXY4eFZxTU45U0Rrb1pFcWhHUTdmRy9XTWQ5Wll1bGl3VGlEUE9TMENveGpqQ0F4ekFaYWY1RmFSOVRwdDUxNzI2K1JGWE1BVmxsZkgyeXVJL2VadHczT3ZRMVZ5REo2eGczMFcrdEU3d1pJdGhTMTBEQzlKczYyT0RRanFyazlrdDlDekRSamNPcXVRVmJySnB4VFcySVZndzFqb0VGSFRZc0JSWEFUcmRCTGRJRUJQSHhoRzVYdXViaUQ2Y1M1cThwMzN2NEQ5QUg5ZTZISFJ3VDNUdy9PeFdLZ3FIeUZxdjdrWGwwZm5IdjBkV3YvcWFLcElmSFU1RmdDMkRVMitFU1RrcU5lTTAySDZWRXRiRERjT0tPZkMvM2ptZlh2cWJqVVJsQU9LU2FFNUY5eDliWC9WR0xyNnlSekdvdzJ4cnBSZjcxeWZvU3dQUU80NUlVUnluYk9LdUZ6QnRld05QU0dJMWViRGRRSEc0RGFpMVFOOWk2Qnk2ZjBUVUNDV1NlV2dEVWQxamlmMVl4SEhqRzBaME1HZ1RFZnJHOXN2UG5aY1BoWi9manhMVHBhZnkwckM3aWFPVnhpamtRYWNJWTBBWUswVDFPejU2dnZjR2x1RHBaTGM0UE5iTWlNYWdUZFl4VmlKSVErRXJJZWY5ekNPeU40TjNEZjNNUjlzeHpZVEFHMGNuNCtpUFhDd0s3VkpQT0RLQW51MkZ4RzZBekFhdVRVcHNyb0RVWkZJYm81eDRUVzdseGlWWTFlbUdOaVRMck14VCtUcktTenl2eXZLaXBhK0MzVi9lZVFObmorZzRweXZSWWRsdnNUM0g1dkkxWVhXOHFkS0hXeTBIWGZxbUlQVHpzN2FKWGUyYWI1MVp1Vy9TT1Z6dXlpRFdoQ2h6djRQQlpNYnZvdXIvODdMd3crL2lXT3UxblJodml2THA1TExVSUVxV2hncTRKTEJUdUxnckRsWU9KQ0ZYTVZQTUo5UStwRzIvSFJZUVYvTlk5UDA2QWVDVlozNjk5TlZlSm1oMlZGdWxySXdqYzZYbXJoSFZNdHVpd2owbkU3a3pIUlhNbWQ0V2s4MDh4bUxUN004SkZJTE9teEhCYzJGVlY3UFFwTnArMmkyTU41c0h0bldSR3hoU3Raa1lkRG1zMmozR3dKaTBKMHNlYWwwV1BaNlJ3ZFRvYTBTbEtWc1lTVUNPdUtPaHp2aG5YOVg2L3B5Nm5NeTZBNldQZnA0VDVYSS9yK2NiUUhpaUw5SU9lUEZmaERCOUhvaHg1SFE3K2tuNmJOUlB0djZYYXJnLytvZHJ1M2RGdFB0MzdjdWJyZHZocXhWM2Z3d1VNa1ZORWhZdW4wNllsalZOdHpmQS84elMvbmNzdnpRcS9UNlhXKzFJSGREU1RxMEN5eGU3SW5qb1A1K2ZaNlhMZ09BZTNzTml6dWk5SDhhejVSNWNBaUMrajhhN0lkMDluTlpydnpEL2tweU44aFFwdi9OOEk3aHJWN0RXeUxsOGlDUWNzUldpVE1RU2V2c1drcytEZXRqbGR2M0xxeFVaM3lpdWJ6VTN1OWxNb1hYbkhndmUrdHVjY2FDMnl2MysraHFMRXJlemFhTHBiU3NyU3J1dWYyMjhkOXpNOS9lKzdqSExmbE12RXRmZ0NzYllsWFFST2U4eHV4MVRSLzg3N0RoMXVycTNNckt6ZXRtTjNEOXgyZTdTNHU0dU9WdWRiRTk5bkE0MzBlckxVQ0UrUnhGdHZOcHRGdTgvQkVscjgvOGRYZWFCMmV5UDgvdDlwUVQzNnpFMXU4QWtBUTh6R25PcDQxZ2tMLzRIMkhUVUxtNm1ycjhGQVhlN2hGQ2wxYzdNNGV2bTlvUzdSQmRISEVXczdYblBoZHVObG9kM3l6cW9XMTliV09kR0NmMUx6M3ZmZmVlMmpYcllacTNyblNXMFA5dFY1TDJyOWZXamgwRDc2enI4M3N2R0p0UGZoTytKakZHdVhpV2NodGdMZ0hzUFJscjlCeENoa0VubE5Od1d1Q0VWZGdCTi81YVlFeDhtUUZkUlFhQXhhTlJxRXgvb2xXNk5qZUJwc3BlMWwyYWlIditFZVZaTUtFTzduQ0cvMjRFaUZyVzRnTW5zRnpHcG8zR09FR3hDbGhDVStyK0dHVWpEZmhVZHlxdW8xR3ZQUjJzOVJzSmtzUnVJSy9XR2RDNXJaWUdYaTJ5RnNNbVVrR3dUS0c2eXJEMkJqVFpEYjJFbkV4aEk1SE9OVDBoQ2JtMEFxWkZRTjdISDhCdmpBTWpyRzFFak80Z3ViQ0ZKdjF5aG0yc2JlS3QwNjhrSXZCNVVTeXdtYVJ1NTNnVCtGcVJFcnhSc090empWTHBtT1I4eVIxUG9ZWEVoeFBjSlpReCtwRVBNdERaNTU3YnZQTUdaM0FlTjExMTlkT25MZ3RlZDlqajcxSVBmWlluem9QeDh0L3hvZnhHaWNTaVp6VUpUTDdIT2JKUWVwYTZsYnFCUFVBZmh6V3UrRjlIWm5tRSs5WWdHSnBkN1RBdnQrM1FzSC9TK0JHUktab2ZuaFRBaE1xK0VEWHZEQU10UWpYUElKMTdVMWNLWHR0bEtJbHVsMlB4b1U1dzVZVXJmRGFncVpJaXNEempieVlPUExtSTlWNUw5UnNad2YvR2FFaHJxbkd5anlqMHNuZTNub3NGRk0xUHBOVXZtS0h2TGdxN1NweVhJSmYyY2xvY1dldjlUNThpeGUxWkNFZE51WjBHWXZGTk5JZEtjd200dG1xWXpraDF3MDVWcldVekhhYU00ZXV0eGNQSGx4Y1dFbmFmRXlYNUh5ZERUR1lNQWltanZTcGNDcWtxNExJUnAwYkRqS3NDajZwc3BKem5YQ1NpWVNUV1ZwTjBXR1JqeFQxaW1MYVhIWXNod0ovSTNpY0JSdzc0T3Y1dkJzemE0SkZROTUwdDdMZ3p5YnEvTWZqbW41d1dNWHU5bnFVSmdpL2NVeHVmb0pPZWtJUEg4Y2pKd0g5STRidFBvU3UveG5Gclk5aTdBUDVCNFRLek1xTk56NSs0NzdDaVFNSFRoU0s3eE5lbFg4VkY3L3A4UnR2WEpsOVUrSEFpUU9GNGgxYjh3MUJOSXlTNEkwekRRZWVONkFLUjMzbjRha095VFAzWjk2T3hWNXZyZWM0RCtkdWhCemJVN1NIejN1TE93THNVUEJuVTRnbE1OWEtnVVdKVmNCaVlhNEZla3dzQU9Qand1UjFsSlRiOHMwMzQ4M2diMkNMa29PL2dTdVQxdy9HWW00czlzc1Qyd0J6YllOZ3Jpa1RYdWxqbncrS3d2T1YwU2RsNHJnOGNRd1U0Ymw2R1RNUXpQRk1EbE0xUE1leXVoa056ajNUdjRKNnJwc2hzNURhOE9EMDhPQUlpZ3krajlCdDZKcHJVQWIvOEJFK2p4eUh3K01Jam05d2EyU21NdmhoY1BDT1lNL3JOTkZtc0xST3YzWGlHQms2NHNnNlBNdWhJUmJraXovR2JmWVVuc1czU0RTN3ZFWUx2cmFBT0V1M0dtMmlVd1FnZldZWDhqWDgwR002V0VqdlpQQUFPby9GUlQ4d0RpL2dtaFdxQ00xbGFpVXpnZ2ptTHlya010T0ZaZ0xPR0dUWWN6dEw0UVhyemp1dFpnWnZGc0xIZHhtSnBacldmQ2JSTEV4bjhqbEI5UityUkdmZExGa0Y1T2dWMDNDTE5ScGluTk81WWpNMkV6OTZiV3o2WGRjZWpjL2NscXMycG8vVmlxNWg3VlpzMFAvell5d1Q2SXM1WEsrREVFOGVFNnd4d3RacUxiTitsUndUQWtFdjVGdmtRMGRxQXlEcVVNZGxCSEQzVUZFUFRjdkwxZVI4b2lRWnVDcnBZcWJpZFpMNEtLS1dzczFNZFZrKzlxOElpTVNYa2gydmtpbHVIRHVHbjdocEY0SkZ1K1JLbzdyOEE3VnBHZ3NSRjMvNjJsWkVMOVJ4K3F5MVlGc0w2c0dqOEtRQ3RlZnBla0dQV0Q5MytVRjE0VGFvazRqbW1zMnQrZ0xBMHdYc3ppWVo3QXVkTElvSVhxUzV4Qno1d1ErTzlJVHZmT2Z5ZWJUNnJuY05OdDcxcm5XMmo4VCtVNFBOeDhYVTQ1UHIzTUw0ZVhocW1QNUM1VVFodHJjUXdkL0tlUlRoSW9VMDg0TWorQmxSRUw2RFhGd1NQSWU2NzdKWnRqLzRpWXJjeDFQaTQ5UzJzb1o1a0NkSGorQTBlQTVNdllpLzFlK2dxSTR0OFBNSWdMdDRyNHlsS3RzLzhpd3p2NFFDK0tHVzROOXRlN0JiUVVNTUlySkdTSFRsc01taXRuOWRjQ0FTTGlSb0xUVFNhQWhQWklHYlB3QUR3emxaZVNRRkNTUDhvditBd09ocEJuOFVCSnJsdWxFSWFNcXBraTZwbk1xSG9udEFVd2hpUzFwa1dDRXRoZ1NhRVNLaFBYdVVxRWpqZDBoSVR6elBjSHVpSVY0TkhvZmdwOUV1Zmw2bjZZbkhhZEZVdXQyUUFZK0h4Q2NZVVdBanFvclBSRnNyWHNFcFVMNU01MFF4Ujh1Y3lpbmNGVVU5S3VIYnFocGhCWkhSUlk0V0JaclRpcVVRRnEwZzdwZ09tZUM1SUdSaUdKQUpmbkNVQjg0UU1qRU1rUlhsa0Q2Umg2QVdpemdQUWFRNWNZeXZBUEpxbkxyY2o4Tm5EUDF5Q2JJVGxnekRORWdEclFXdTNRR25SZUFsRmhsSjRBczhHTUlYejZtSEVWbkh4Y01nUVg1ck9HM1BFWUlvVGhBRlBUQ2FDaVQySjM3bmlVVmFvR1dVS1pTUGxiSDBLdU96UlR6OXAxMlgxdFJra3VkUU1wM05UZWxlcmhqSFo4bWs2dDhMbTkzZjZacDc2TU5TQ3FLQUt5cmVhNkVwMzZTMC84U3RSN3UwU010MEtxenI0UlErRU9udTBWdC9MVmZSSzdsTWhtUVUwdWh5bWRiMEdKeGxNcVNNbk5QdE9uK0ZqcXE2bVpKVVJZVzllSEJvNE1xTmVGU2w5bExIcURYcU5SQmh2Z2tWSnBnR1pRK0xuZURGREZqOWRZSzdidUVydGhPRUFNZVNwckJBb29UN21ETndzVW5tTVlGMkFPZFNHUEo0N04xRkUvVU5GdFpwM0tWaGpldE5HVHFrbWt1L3RHU3FJVHFGMGtqVHJMaU00bWJSeld1b21NM1pNU1Z1aGpXVWVWaGFvYThJYWFRMkVOdzc5VTZmNDA3cll5Mkg4UHF4aGFYZG45Njl0Q0FqQ2NVT1hua3dodmVmN2Y1S09KOU5PanQzT3Nsc1hzKzdyaDNEMlVmMUVKM1AweUZjbUJLMzhtNWUxdFVyMFI0eFplcXFDaTN3NDREdjNhN1A3eGQySERtNnRIdjMwdEVqTzJRRStXY3lrRDE2cU5zZHI1VnVrQmhwWVlpQjAremdxUXNXaTZPV2c0Zm1wNTc2Vkt2MXFhZmE3M2pITys2ZmVlQ0pkOS94N0xOM1BIdm5uZWorSDE5NTZ2RDI1Nk5FenZFRXlDU0xoL3lDSnhUQTRuSURubTlEVG0yY3g5VFVFdy9NM1A4RHlBYm45ZXkzVGgxKzdMSERwNjRjclkzNWVZMXpjaWFlSHowMVlYTUxYcU03UnY2eC9sSUxmRzZzZGdjV25XRjZSVDZvQlRxd0JyVE1qdThJNUp2Tk5kSFZqWWMvOG5BVEdhSXo1VWlOdmJTN3A4Wkp6cFF0R2Q4OGZkZGRCeTkvNVcvR1lxSVlDMHM2bXV0Y2NmVkREMTE5dUkxRXA0SVQxTmx5bVovaG9wSmRjY1RCbjU1NDE0bTdEbHgrb3hCekJNTVFITmxnM2pUaWtVL3IvS1ZRQ3RiQVhxdGd3VUpYRnIwRWZXK0pZV2swSEJOZm1xNWZGWnlZOEtZM01ZYU15YUw4K0pkRCs4MnRQbm5FZnQyUGVEcEc0OC9DNkFPSS9BRXVmbnNiS1BRdkdvWngyK0pnWS9mbjhtcnVrM2sxLzltY212OUNYc24xdTdPejNkbUZXcUZRS3dBVzd1QW51M2REWXFPRkUzMEJKM0tDQjl4WlNIbHpBVklHZnFZWG8rK1NxZnNwVkYwQ1BiamRXQ3diOTdCc1hLTnU4YTNJYUIrZ0JyNTVLMzdzUHZKSjg5MC9ZU3B2QjI3NUJPOERyS0o4VUtTQ0Q4M25rWTlrWU9WTlRBOTlWVndiOVRJWjFRbHJYbnVtTUpmUHFMeU5EQzJLSjhkU1dGZERDRXc3RUcxS1NHSzRtQ0FiVFRwRXkwbzF6TEpwUFl6d3BCd3hESmlENVd0SVZzVXdyWE55MHAzTnpyV3locm1XS1dvYVhja1c1M2N2RnFNYVVnMlVpV1J0WFdEQ0tBbm1TS2FJeERDWHVjd0l5MnFTTmtKaERWOWtraWdxcWJNN2tDb2hXY3ZVZDgyNWJsbUVkM1RNazVmTmtaZGJ5MHNsZll0L2Z4VFBLZVpnUkNqNUEvb00vbVA4VGlINDFzQUJnc2hDdXdTSXVGWEdnNWsySHZKeDRnekNlWWozWGNFU1FWb2tQdTZSdFNNMFB0ZTBiaWxYUUlNM3J4MWhVYXA3TVBPbmUyL0RDYmk5dHdyWG45d1E4VGYrYm9HZ1ZCdzdzb2JsOFZKWDAyQVI5c2hhNW1BM2hYNWZ1SFV2ZCtxWWVOdGU3aVExOHNFRWVtRjh5RkRUc0hiY2Nwb00rUTdWTVNsMW5pZ1o2Z3VkT2lhdjNtN1dlVUE2QlVKNXF3M0JGWHpVTFM4dmZCTnh4MDRCMmJ5Rzk4TGRWL0R5KzZGUWhlTk9YbzgrZmVyWWtCNkYrNE52b3ZWVHgzU1JFSHVNeFZUZko2S3ZRM1hROVNjNVRybnpGTjRNNnpwYTF6U3czTWhEelBhTzBDbDBtc0l3NmwxejIrcjhGdVByWVh5MFlJWDc5MjVJTDRRUDZvdGdleXlLWUUzTmd5MjE3a3dZV1NzS01VcDJVOVA4bWY1cXIzWm51ZTFGMHBVTTJFdUhBTzJMOW0yb0kwT0Q1RUppQzQwQzhSMXE0b0VBVStrMWhWMUlDRWdrL3BScEZJUnVlMy9GM2d2VVhIKy9ibVJ5VVVJU1A1MXlxOUZVMXRMT3VLdXJQYjFXODlybFJLSHFpc2cxYlpqVWgwYzZNR0VMbG5rSHoxOVg4QXoyY2hJRmQzVzhla2tGeXp2RWdCUUJXZ1owdkVhSHhnSUUvTnI0NXdaN0k5aXorRmVlMkVNNkxLOFQwUnlFOVRLV3VSdFlac04vNk9peXB1dmFNcEhieG9jMzZtQ21Qeml0SDhRN2lDbml1MXIxOUEzOXVLanBQTWVWV0kwcFMyaWRaRFA0d2ZZTXlDRzZSeWU2c3pQZ3FmVU1QajZyNitmSXFmOTN6ci8weTJIaGxDaWU0a1Z4UmVUNUZWaFZHL0VJUm02YlNsTkZ3cWY5bUR2WFVqZGkvcHlZUk1nd0czeGpJUS9vd2p3RXZ2TEtBbTkzeUdGWkoyY09lQjNEalFLYzRkbXFrNkdibHRsb09YN2lxUDhvSG0waGJYbjhqTStrdjlOeHZmVWlEMHRjak16eWVDS2c3WUJKQTQvL3dhemdLSzZmSm5KU0dWOWlTeHlIOE1DaUgvVlRLRmhheDZuMllYN2hKd1VOTHJJMlpvN1B1cHN4SSs2R2RLTHdlY2hLNUsrQkJJdzIrQjN5QUJQWFB5Q0V4UzYraE5rRFZteVlWNDZmQkhXQUVvYjllNUdROFZtY0IwNTFpNzVGZjIyQWozbkhxekp0R0VYclpwUG83VG9CODN4ZllEK1FFaGIrdjRoNG94eW5sekpwUEpmRlk3bEtScThsZGZHaDlZZnVPcVNmb1lYNFFvR2VzUzJFNTBEaC8wbVd6UEhkSTcySEh1b2RmcEMvYlcyN0Q1VUppQUhEbHVyd1dQWWw2MHZ6RVBJS1hLaXRab3VFUFNKZU45NXdaZjZWYU1hMmthaklZWkU1dnI2MjF0UDMzdkxLMDNjM2xjVmdtZDVFdTlONGxoRTJSZWFiYTBkNmE2dFhDeWYySFh6bEt3OWUwVlFYMTRNMVZGOE85TzBDZkZ5OWZRUlZiNXYycVVUQUZNR2RKZ0NOOURWQnplMCtkdDQ0V2FHVUd5ZDh6YVJTYXVYRjNQeDhEbEc1K1pvTFlaOWVwR0NMeklrMHY1dXIrU25tYzZEM0hhWHFUMmlxMmdUZ1pGNG5hQ2VMWnk1Nko4RCszQWpzRkdBdGpFU1hIbXFyU2hQMUdVN1dpb0YwdzVHcmZrV0dQTGt5VUZtTlNVLzQ5VHBLYmd6T2t0cE0zUENKdnRLblpwMVErSWZuWHhyR21IYUpmajZMZStRY1ZTZTJSRmFCQ1l4Um1BSng0dDlGRkFCZTRMYWNSSVVvQWNSc0FacEVSeWgwQ2s3Qnc0TnBMS0srVTQzRXJGNUVQYUJHSHI1RE82QTk2WHpIQ2I4emZLdTJROUhrT3hWTlFVZkNnKytwa1lpS0NtRVQ5aWIrcHcxK0ZlVUhmNDQvVDhZUC9IL0JmSEJJVzRCeUFTdUFGeUROeHpYQVY1bW1Wd0RmcDJhbklKenRYWWdlVmxPMHk3WGRGeVpFRzN3cEtIMnIzaThKTWtlQlNFT1cxeUdyS2d0VlhMN2d0TERzMDVmTm9qZFYzZGk0ZWFHdUk2TjR6ZUo3MzN2Z0ZUMDN1OHVJSWxEWjRSSC9pT0RzbkMzdHVmMzJQZFh0T3I5dE9XL0pibXNtVzNBV3dqNjZ3M1lVQjIrTXUwQWdUV0ROR05BZW5oNkNPUno4aVkrNW9Qc2dENU5RRHIwQWVFRVVBVzVoOE8yelowZmpScGZnSzVGMVpNQy92RkFwemdUS3crbXQ1UVQ0RHFmZHRTMGxqQUVlUnV2ZlhlS2p2UzBtMER3SzRyZU9Zd0w1TVgwbVlnSk5rN0ErUC9yUlJEN0NSRXlnWnN0SEczQUVFaE5JSnlHRkZQLzVqLzNvbW10SVZDQ3lUdE5GSDBOZHpGMi96NDN0VlFLN0VQQllIOGEyQnplMEZZVGJUYkFjaE9XY3FQWTl6YmJDL3lnTDN4TVVGVytrK1R2dXVLYmJSZDJvOWdYTnN2QW0rcjB2Q0pJa2ZFRlFsSGUzTmxxdnl1M05qV0syK09WR3p5K1Q2MWplUlA0b2RjY2RrMWxlanpPaUF0cngvOEEvT08wamVnRUVKTmwwZ2hPOHh4M05LN1NRUFQydGVWNUZTNmMxOXdqWXVOanZQSEJnSitydWZHcW4zTzYzdnlWN3h6MTU1ajVGdHJ1Mm5EcDQ1ZUxHWW04WUU3cVBYSGhEb2ZhRjFrNzgyTi81ZDRkMmVodEVUNVluYUFpV0gzL0d0N0FIRGZjdUJQV0RsV1JpM2VZVitBQk5kZ2tWQW1pcmV3NzJlZ2NycXB4d3UxMDNJYXVWSlpQN0VHZTJPSm1XN0pCZ3I5dEN5SlorN29PNi9rSEhsZVRrTEl0Rk81ZWRUY3FTKzA5N3N0azlmMGtyaGl3NkpaWXRPYUpzS0lITjNaQ3VTNkhxWWpTOFJLbTQvcEhSZDFZaHRsd3BYTm9VbmxPMXNTeTVCMHVTVjFQWFV6ZFR0MU4zVTY4YVdrVFdmZFJoQytJcmVrUXJXQUExb0FWZ3FjMENnVThWbklJUHJRcmJsZ1czbXlTU1V3c3VGSnErMnRBakVScHRvaXhzRTV6V05tTTdFTW1CWkhJV1RDM2hKeDVHY3FKY2N1UmNSQy9HWWtVdklhTXJiNkdsZEtiQzNId3pVOG5ISlEzSjJUemMweU01MlNtNXJvd08zMExMeWR3b1JiblNkUFRVaDF0bHZSamVWMm5Hdytsbm01VllhZ2g4ZHVyMVYxYkx2RWJ6K1JsT3VvS25kWm92VjFzRk1WTGJvKytwR1VLaFZTMExOTTZUdjBMaVp2SThIVUZpdVZyM3hnbXVxS2l4aHJSSHJVaHFiZkNkaXBxb3lWMjFFcElhWVBFdzRuRU16N0VLVklXZ2Evc2N2aEpMb3pkUXQyRnA5SDdxRWVya1ZpNUhpS1JRenhNd2dLanRGRnB0WDlmYTdsaGxFcHdSR0FiS1JZak42RmhFc2RqQ3Y2YkZreHNPVVR3eVJOK0lqNXYrSTd6QThCWjV3bGRGa2xUbEVjTkJFdXM5dEhaa3IwanZUeVJ5bHUxZWJoYXluNGc3bWwzSFFsc2lWV0wrblJaaWhhTzBHTXNmRnVqOWhVTEJqR1hydHBZeWkyKzJ3aGtqLzJtUlBzcVVVbmU2dHBtL1Via09INFp4NG5TSmFSaVpzTlVZQlRkL0dBdUZEL1h3VERXYW5kdVBicGYzY0xUUVZhNmwweUZoemxiZlY4Mkw0Ym1kOVNSUDc5Zm5zbmg3WmJLK24xNVZ1aHg5dFQwbktrVjAwS3BLY3VHZjg5V2RjMkdXNXZiSWlKOHQ0dU43cW5sQm45djVpQ3hWclpDUGI3NkJ2MkViUkE4S21FbnZvWDVoWWcyc00wUWNhamQ4bEE5am04ME8xd2J6endXeWNMMXRVeURZS1R3b3lyWnZ3SERVaFBpczl2Yk5FbXFDZXNLREZwcmNFTVNwYm5kdGZRMnNZRGFySjZwWUFzcTg1Zmp4dHh3L2NmTG8wWk5IRVV3R3VEZ2I1MFdGVmJCNHE0UkRHc3R6WVUwM0ZKWm50VkJZRG9ja2haVUZJY2JGR1o1alkyeE1FQ1JXd29ubHNDRXhBcXNZdWlseEpMRVNsaFdjV09MajdHOThESVYzSE90aFdmbllqbnJyOE9GV0F2K0RCYXFUeDRHQVB6a0tCTnhxS0VJb0lxaWlMb3U4cUltV2FNcHNpQTV4SVo0UDBZeEtxNnhzaXBZVUVqbFJNa1JWa0UxQk1YQjZReEk0Z2FSWEdJVldHSHJyQTZJbThLSWFGdFhPeHo3bWo4cy9STCtOM2s2cFZBbHNGUEZrQXdZNzNJMXhTeFZCaHhOR2RSN0d3alllL1BLdDhncHFPeDN1dFZNN0plM0s5RlZxdm9xdXFob2ZZUGdHT0IwdGxNR2tmNWNZL3N6Z3hVL3VuTzJHdUlnVEtucUwvMUsxUDZOSk93R0pBSlVic0h4VjU1Z1BmSDJJQXdNMnorQlpEbC80RGdJVEdzY1R1TEdXZjgxRjBaMGZmLzZaRHovNElEcTBWR3dVTW1IVWR3Zi9vSzV2UFBQTWd3K2FlM1B4UWlFZXJrY21iR1lOZ256YXdpTXJyRnZ4L3FLVnYrKzBiWS9VRWk3NCs4NHlLbzltOGI3RlVDZUk0RU9nbzN4MDZtVzZrVUhvSVU2SHlSNW11OHhMUENPSFk0M2YwMlFHSDh1U3lER2l3T2ljMUpEOE9YdHREWGV4dFYrVlFod3JjdEdhbGVkNVRtUzVrRVNINTNmT2h6OFJaaEhOQ0NvRC9ZZG1RMUxZWUtRUVB1SjRobEhCbVlJTnA0dy85bWZ1ZndWWnJhL2RHTUpkSzY3eWdnQkp3NllaM21xdnErQzZnMTI5a0VVcnlITVl3V000cnlBVWtzaHJlcHRmOEg3aEY3d3ZiRlovL2RlcmFERjVLbG5wOS8rUG85T29mOW5mOW5wL2UxZHZjRzUxRmVubkZoZFJiUEIzcXplT3NYb2dieHJQMWNMRStpbkl0cW1nWnFmNVc5UFQwMEdHT0xkSzh0VEdqVGR1RG5PQ2ZCWW4ya1VnMkkvRkFQUEhuMnZtQlFmTWhxcklEdXdOUFFnRVJtQkhlYWRCUWhXQlBQdVc1OTZDL3padmFMWDV1dnRCNXpyRFcvUzh4Vy9jc0xkdEtJM2sxYkhmT0hSdjZBRTNoTlpKd2xmc3Z6VTdOVlg3QnFUeDl1Mi9TN3lWbjN1eThqZjNIaXBsMHVXWU5ja3pnWEx4bDJJZmxtSURJRGZRR1BBQnNIbTlSZHdtbXZBRmdDaEx3aEMvM0xHOVZ1Qk9URzdpYnpHQWVIMllVUFd2ekIxWG1qSitnOFZYaHR3UE1lQU04eDB0ZlBWeWRaOGg2M2NuSHNIenZYTDdWaGVGVkRXRWRQbnJicDMvQktIMFhzTThjaXJDZ25QT1o2MVlPUzJacGlUOVBQZGtxTHJudGxyRmRuNTk5aHlhTWtLMWFTT1JNR3g3S2d2ciswRTk0bVJPMlFqc2tLNm5icVh1Z3Q0UEFneHh2b1dscWFYQVp3YmNGUzEvaFdvRitlanR2b2NJeEpGdCtjdFlZVVFVd2NSMmdlaUN5eVFmcTRNL2ZkdXdWdEFKUVRTdnRVVEp1c1lVUmZNYVN4S3Q2MDdRWWxhazZjclBMR2Z4cDV3V1hJRzVPM01GSTJSRmh2WWV3Sk4wUEZpSVROeGoxRnZMREN0a1JPYVZHWmIwOGNGZmtkZm54Nng0amNpRkZ2RVFwclUxVHV4Sm5OYUc4V3pSYXlPYXN6bWFUaXhQV1RZNHRsb2N3K1FxNWowdHhPQmpoQko2d21IQktaZU9KTkJWeXdtR0dTYjVQZkllblNZdmxhOS9DUGduNC9jbVMvRGoybFNQdWdsOHlUc1FDc1h6MlFXRFI0ZXNNbmNBUElzd0ZIOSsrSGxFREIvYStIajBHUXM0U1BpRitVLzRUQko1N1N3U1dxUU52TTcveFN4blBab1I4UWFMUkxjeWdydWZ2clZDWTdhWkZZOWh2SWlJK2NPOE9wT3gvZEhrZnNHOERqZzc1dkcxcG5pRVpjcTNNbUptS1pNNXphRFdsSlZBaUxOMjBqUnJMemVoMWtrYXRWY1NtRVcybnNUM0VncFA4NGpCSGV1ZkNRdmVlbzNJRWhhSE1JdWxub2hackFHTFE1ekxNQWsvQzJTYUU3SHFkTXluQk9qczVpRThlbjBGRlR3OHQvYWFwUndlRlVyUlhOUkJoVHZ2RUdwc3E4MnRzYTlqbjJOL01QZ0s2aGMrL0dHVXlneWV6N3p4bXYrdnRhdUprZU80emwzVmY5WC8vOTB6MC9PMzg5ZjdPNXlkM3BtbXhCK05sVFZGV3FKRVE0NjBBV1ZtSWNVMndjUUdBWWUycFFRUktRa0JJdWVnK0dBSmlCRXdnWU1jRWdTRUQ1WU5HellQQm9MY2VMQ0RJTEVSSWdnUTMwd0RPZVFRTFBOZWRjL3VVZ0Y5aVJ2VE16MDExVy9xNTNYVmUxWHZmYS9aZkg3VmNSYlRmUHZGZzg5dmJkWEk1WU8vSGp3U0R3L1h6R05vZjVIVExQcEpyc0lKazlFSjB1OFFoR3hFY2tMOFM2RCt1blFkNUFacG9yNzZlWklqdmQzLzJjNm5DOGRaZmI2NVhGOURYZlVVU05oQzBJTWVvU1UrWFBWQlNpQ0hNaDdCR1hxS0ZCdGsrVUZLNzEyUVFhYUpXcTU2UTBraVBDdDBOQXgrc3NSZzMvbW5Gd1lyYnEvbjRya3llR0U3azJmcFRoeTVueE92dWU2WDZGZmNLTWxidVp4dEY3bFdaRnU5cjdLMy8xQzlzVExPQ2kwdnZqbUZnOXhNYTFQRGM1MEpuT20wbHJLK0d2anJsdU42RXpqcDBBL1VQblBOajJtdGxqaVpUTXhlQzhUaEd3Mjh2SEhrYzREMUhlTHErR01LbWgrdnpydThETU9UZWxXR2J4YTVmbks0MVh0WGZmdk94Q3IvSUlVL01HN3d2NlVUNFpHK1FyK1pPbUp1THJ2L0JLbDZpelBJVStSNDMvK2VoVjEyeDM3MU5XVWl6bWNLdVgzRUFSOStmWnEvMzJ4ZXpJQTNLait4a241WVVTZEZSYmFQWlB0WlNkaVRmbW45alRLYml4UGx0VmZ0TzFKSmtqalRyd01QWk0rbnpmZnp5dDZpdEgxelFQOTZSdmdzWXBlVW9BK1p5dmVzWnZCMG93a1dybnZDQTk0N3dsUitOQnRxaDl1SXcva1Ixc0JJa0pYaEJkTEFoVnFVWDI1UFBLOWoyRkxzNVBXVyszcW54cHhhdlhhUWQ1cFJ0TnEzL0RCb2RUSzFzM2E2blhwQlZxOGxnZHZxTlBSdWIzc1FkUHRKdlRINHpkMlBGUU5udExGVGIzLzY0MlR2Uit0eFNOdFNQWDNxSno5NW01MVYycU1mczBZOGFpYVJZNXBlMUxCdHAydW50YXdkSnJadU5Oell0b3l1N3JvTEw3Q2R3TzZlRzUrT25vcEdibWowZGplZlhOb1psbTFqOGhXMTQrMVEvT3JhM1RtczBHT0tlL1d3akk4dmdIZ1lWOFVwTmZHUHhNbktnMWxmeFFpNE13U2VMTGhuVitteWNzQmRnWDU2Y24zOUpKeC9lbTc5NURyWjkrMkhBaVlUZUg4bzNOM2R2YnMvbisvRGNlUi9lSk44QStiSnp3bENqT0RtdU03UUlmRVVwRnQ0NGlFQlJENFlGaUJwemlNYmxmR3hNQ2Q4aFV3ZHZpeUFsdjRqanQ0WXRVblpJdWptQVR6QjEybG1QQVFRYmo5aXEvMmp6MlpNdFExS015S1NiMUFLcno4WDZhb2Z3anpXU0p4NHpmUCtvbngxdHpJcGttbXRlU0lZOUFkWjcxbEpJcUVzYjY0Ri9kWHUrckFyZDJVcXE1UW1oTHhDNmZja2NvWFNLMFQ2bmtocXpEQS9sT1VQNjZsUjA4TWZoUHB2Ni9EQ2l5dC8wS3ZMa21lMzBQcyttYVk1a2FRazFrQTdDZXRwOTFGN0pCdWVqNHZDTmRRR2xxdy9Pa1F4VUNwa2xIbnhpTGR5WCtsbjFkWndDUy9NSTc2VXNXRG11RmtjSjJLRnA4RHA4ZGNTUlFkYThHdVdwdXVhWmZ1YTlyZVdwdm1XbzhIeFJ6MUZNeDJ2cmdWZVEyNE9GbkxEQzZ6SWMweE42WUdxWVczdXhxdHJVYTNYdEN4TGZIcTlZWWIyK3BTcUxZVTE1Sm9hYVBXMTRVdjBVMzlwT1RDV1dnMC9OQzNMSGpRczI0T3JMNDZlWEU5YWtPYUxqRXBvQjhsazF3ejlWckorYW1qWHM3WjBRbEU4RjJUemRuYndpL0RNSURGRktuSjNaaTBlbmczOHFzMVViaE01QXNucmt5QXpDSVVOOHdvSG02bU00dnZjVUpsSC8ybFJIdlUwN3hYQUxQeVJrc3M0cUtEQWhxaUhuS0dsaStjOFB3c3pFQUlYOWZqb1BkdTVGVFdkdUtlSW8vVE5mYi9aQ0hwUmtLNHcrU3JvRzU2SENDU1NHbVJ2N28vejhUWW13d3dQTjBRcnQzeWRlZjhnZGFNTk1XdGJObGt0M0ZZVUlacER3MytpMDlQbzZ4N20yTGRXazVuYldMSGhXSm12ZERYUTBYcjFrZGovUHREMlBZNno0MUdCZkVGNFgvZ3I0ZStFYnduZnhUWHF5amFRZDJxbFVWVWhRcmxPUmZsUGlHQ1g0U3FLZ3JvWHoyZVg5b1VGUXJKd25JdGwyanhQMm1JZWwzZ3lKWlJNZ21RS2p2R1V4QXEza3FlbE5XRVpCYlc4U3JaamVaN1pLR1h4VkpTODhEcUpNUldvUWFIbVZLQ1dMb0p3WkNoaGI2UnFUZzBVNHhWTjdpcHlFTmRVU3N5UWlwUXB4TmNEelFidHkxYmtVSTdjbHE2dzFHaDFGTjIxVDZzN2JkVTczYjEwWlRSVTVNUzc4S3lCTnFhaXF0dEszTjQxMWJpNCtpbWFUaFF4OWFVb3NVUktOVVdKRlJZUm9odVN4eVNxV3kwWjlEb29pZTZlSHZvSHYwK2tlSU1RMTNEanE4Q0ZVUWpzR0gxU2lZamtYd3hVdUUvK01yTXh1cDlraFpacUdMSHB5WklWTkszYW9KNVlqa1FWQlFNc1NrNGtyZ2ROUlhlMHNLTXFSRW5IVHRKb2VTcFRyRGdPMjNJbjlWYTNHMFBiOS9xZHhHdUxMY1Raa0dCczBaTE5tcDdPTmphOVpsY21oaTdYaVM3YktsTnp4cWFFTm1NaXkxUk02MnNOekUra1RobzF6QzNGVm9lK0RZM203YU9ZZlRLUXBiQkdJeWI1bGg2NkRpR0hQcXlvMzM5RytMRndYL2dQNGVjd3UyejNjQWUzQ2g2R29DWmNxSFpJV0dJR0paT29OSlBKK1ZNalRzK1drYWVuT1B2dXpJcWQrYzVacVRoYktpZXpIYTYxOE1Ha2ovWi9ZMUpHenExVXM3Z3lUOFpocGtQNGlOWGpZYTJqVXIyRFlhZ2FpSHJMcUdZOXBZeDZuYzE2U3p5SE0rUVFEb1pEUjVXNFVod1NKdTV4UTlncEdyN2lEdjRVemdmRk9SVWFOL1NwWkZKRzI4NGE2NW9tZFczTk1Ja29FVVJRcWJIUWxtcG1yUWFuWkVkcURkSVErRUNraW16SXRrdkkyRjl6MmxTanBreGR3eEtKZXU3MWQ3SWg1TEVsSnBrZW9TSFZxY0hrZ1R0eUZDTVZaUVYwSWhEelBXQVZrZGlhWXhqaWNIZUltV3pkaGlSUjhSQkhDSUVleE5SUW5Nd1pTS29GdndlVWVDYVRGSU5RTm56MzZVUXhsV0Fhd1B0WHVvc3VvcFhyZlZrbHBnYXNZdW4xak9rSThnQ01Kd0t4RU5sZm83N0NtT0pUVFNSUVE0VnlRM1dzSnp4Q2twZlZkVXREY0NDaVNIMTkvZ2wzYStQSldBUHVjNDFRdzRMSkV2RjdOaFRhMEgyTVRVc2MwU1NFS295bUtXR2d3eEZpaXNCU29DYjV1dTRRNnZSODRIaHNTUllaYVBKcmVhYzJQdUFGeDNLM1FWaWRIUHFQSVA5OVFmaVM4QlphUXc5Ly9Td3cveFVjdDl5YTVnWUxQVzY3TUYwR2V5UDNmNDNkbGoyV053NyswOVkwVzlzNzdOWGthVmFtL0w5YWUrdHhuZmd2ZG1qYjRXTFpGOG1NZnovbVoxOTYyZGM1cG9YYVYwR2FROXhnTkp2UGNlOFl3MzkzMFIxdnNkZ24xdy91WFZyc2R5ZTNKeURWUDdpK1dKREpuWHNIRHhhTFM3ZmdPTkpEU3JwV2hiZFJVZVc3dm5BdXFkMDdUdVoyUmVCb2ZTc1h6bU1NOWdBR3BKaDdicFhDLzNLOUpGbjJMWENBWEFtTk9GZFhBU0Z3dFNRNVZCQXFuMnNWN2ErL1JWVVZGMFp4dFREMEd6QUZPRlJtWXBmcUJQVDdoa2JhQXlNQlNRTjAvWmlRU0dXNjl0WUhUeFFwazRNemxya3h1WGl5S081Lys5YXR5MFgreG1xWGpPVFFoUWRKQVhwS0dIaVdKRk9QQXZQNFJLWktxRGt3d2pnd2dMaXVLVXV0VmoxU1h5aUs1M1kyTGZ1SlFNSko4K0p6eGN0dmZ2dk5OTHN4TzMzNU9CNkhLU3lxVmJsbHllVjV4ZTdsQWhJWDdYaDA0V3dIVXhGL1FrRXJuYllNN1FQdDlDZEhwYnpBWUg2alhaSEpVRnVKZ2ZDRmE2UWdQV0ZqU0pyT2NHYUxSWkdacnBjWWd6YlJHdVQyWWJIK1BsU29ERFdDb2NTak1OdDVRYWpBM1ZCcjRvYXlvVWIxVmt1U1RUVG1rUjFKSkk1d1RGK3M4WWhLYUJHdkhvT1V3TkJzV1E3NlE1OWI0b0lHQ2N5UkxPT2JRWllpQnphWlhIRDI5aTd0N2RtZm1GeS9kUDM2S2V1MWpUZmUySGpOT3JVYjd1MU45dmFpM3lDMzcwMDYzbVIvZitKMUp2ZCs5clA3dGU4OGVQQ2RtcnM1Y1BmMzNlSEdVZ2RmbHVYeEpmbS9mL2RSMmxWTWpZZjNRSisvdy9kd1Y0UzVzQ3Q4SFBUWDM4SjRGSS9hNWlyVGVSR3FVWW1qanJqbG9UeFQxTDVOMEZkMWxFVlZqTTR6QkVZaStJTCtYdmxjN2VkRmdoTndyd1F1NGpaRy84NjNRbjczMm9VTDF5Nzg4SjFYQ0h2NXJaZGhBS2lsVzFTdWQrc3kzVXFseG5BMkg3WjIvbmllamtWellZcmpaMzN5UG1QdWk5ZGVkQmw3NloyWHlLU01aMUVmMU91RHo0NGFLK3FEZERoTUg0aWh4aG9IbHh3RkY2OFY1eExUYmR2NDh1VWd1T3dvclpieTNZbXI2Mkd0RnVxZ3MrSU41VGhldG9Fb05JUkNlQmJVMVoxdVNMR2VZZlZvVnR2RnN5ak1wdmlPL2lqNE5zWmduSHdBSDgxUW5VZXNlejdXSDFXWExLNjg4NUpsanp2VXR0RUdkYXZkK3VEcEs1VElyZlpZYkhhYjRyamRZaWZHLzhxWXQ3WitkWDNOcTZwMzgrYkJQdythTjBIcjlrSHFNVTNMVnp3dnV0bjhyMEdUU2JZbTcwZWVwemh4N0dEeVBrTnM3NS9Yc0hJbUhGaTlXbk93eE10OWVCZms2N3ZDRk8wdUNRNkMzSWZqT050d01IVGNDc3Y0RU5uSEhhNHExbVpSbXJ2am5ITDl2ZFhQV0tjM3o1K2ZuRCsvZGNxS0J5dUQ4ZXA3NXpiZzB4dmw2MTFGKy9TNVArT0dTZVR1ZTgvOVRyTjU0aG0yTTE0c3hqdnNtUlBOSnViZmV1NjkxWFhNUDBoazlzckJmNWNobkxDTXYrRDJTeGpUUUFqVTVDa1k4M0l4NnhEdUpkVGZIcUZGUnJBU1FCSGpaUHExcTBZMm92WlBiVHJLakt2TVNucjVGMjkzRVF2V1hYUnZoNXNiNUZxbks4bWpoOExEa1N4MU93Wno2TG5KSGp2NE43TEM5aVljdy9MSVI4REU1K2lJZUVIdUhpY1ZrWDI0OFQ3cDhodFgveGNwWitmaEFBQUFlTnA5anoxT3cwQVFoWi96cHlBaGxDTnNRUkVLYjlhV0szZEpVRVNLdE9rZHZFNHNKWFprYnhTbG93U3Vnc1FKT0FPY2daWVQwTUd6c3lCQkVhOTI1NXMzNHplN0FDN3dEQWZIN3hxUGxoMTA4VzY1Z1E0K0xUZHg2VXd0dDlCMTdpeTMwWE9lTEhlb3Y3TFRhWjB4dTYvL3F0aEJEMitXR3pqSGgrVW1idkJsdVVXZnpISWJ3bm13M0tIK2dqRUthRVF3UEdNSUxIRGdPU1JIMkpCR3JFZk0xcXhYbFQxUzlxNUlFK1RJeUZVc3NHUmR3SWVFWXV5enczQnRFV0xBbGRqZTVMZFhvbVFtcVdycVY4QzQwSkhSc1ZnY3hEQ09ObUpVUlBGYUg4UStOU3N4eVRNenlZdWxGcjVVb3I4eVpoc09CZ25WcEZKbG1jaE1HN3BNNjBFcGJ1dFlVc2l6OURiUFNMUDZoU2wyZkJkbU9rNTNqS2NlRVhMLzl6dXFBVng0N0hPNUZTbWcwWjhiaHVKbkxqRndQZC8xbFJlY3ZONmNzd3RLYVYwUzlLMmNaUjJyMjJDdWl6TE5NNkdVSjVWUzRwVGJOeEQ0Y0tJQWVOcHRsMk8wbmVjV1JyUFdhcHZhU3QzVXpuN1hzMVZ2MXJhTkZDbFQyMGhTMjdidDFMWnQyOGE5dHpQL2JuNzBHK09NN0crZW5UNWp6ckVHK0lELy9mbDc5SUJCQS83UEgzL25QLyt4QVc1dVlXUFoyRGFPRGJSeGJUd2IzeWF3Q1cwaW05Z21zVWx0TXB2Y3ByQXBiU3FiMnFheGFXMlFUV2ZUMnd3Mm84MWtNOXNzTnFzTnR0bHNkcHZENXJTNWJHNmJ4K2ExK1d4K1c4QVd0SVZzaUZXc1dKcXNhaldyVzhPYXRyQXRZb3ZhWXJhNExXRkxXc3ZhMXJHdTlheHZTOW5TdG93dGE4dlo4cmFDcldncjJjcTJpcTFxcTlucXRvYXRhV3ZaMnJhT3JXdnIyZnEyZ1cxb0c5bkd0b2x0YXB2WjVyYUZiV2xiMmRZMjFMYXhiVzA3Mjk2RzJRNjJvKzFrTzlzdXRxc050OTFzZDl2RDlyUzliRy9ieC9hMS9XeC9POEFPdElQc1lEdkVEclhEN0hBN3dvNjBvK3hvRzJFamJaUWRZOGZhY1hhOG5XQW4ya2wyc3AxaXA5cHBkcnFkWVdmYVdYYTJuV1BuMm5sMnZsMWdGOXBGZHJGZFlwZmFaWGE1WFdGWDJsVjJ0VjFqMTlwMWRyM2RZRGZhVFhhejNXSzMybTEydTkxaGQ5cGRkcmZkWTZQdFhydlA3cmNIN0VGN3lCNjJSK3hSZTh3ZXR5ZnNTWHZLbnJabjdGbDd6cDYzRit4RmU4bGV0bGZzVlh2TlhyYzM3RTE3eTk2MmQreGRlOC9ldHcvc1EvdklQclpQN0ZQN3pENjNMK3hMKzhxK3RtL3NXL3ZPdnJjZjdFZjd5WDYyWCt4WCs4MSt0ei9zVC92TC92Yi8vdTkzRHgvTHgvWnhmS0NQNitQNStENkJUK2dUK2NRK2lVL3FrL25rUG9WUDZWUDUxRDZOVCt1RGZEcWYzbWZ3R1gwbW45bG44Vmw5c00vbXMvc2NQcWZQNVhQN1BENnZ6K2Z6K3dLK29DL2tRN3ppeGRQbFZhOTUzUnZlOUlWOUVWL1VGL1BGZlFsZjBsdmU5bzUzdmVkOVg4cVg5bVY4V1YvT2wvY1ZmRVZmeVZmMlZYeFZYODFYOXpWOFRWL0wxL1oxZkYxZno5ZjNEWHhEMzhnMzlrMThVOS9NTi9jdGZFdmZ5cmYyb2I2TmIrdmIrZlkrekhmd0hYMG4zOWwzOFYxOXVPL211L3NldnFmdjVYdjdQcjZ2NytmNyt3RitvQi9rQi9zaGZxZ2Y1b2Y3RVg2a0grVkgrd2dmNmFQOEdEL1dqL1BqL1FRLzBVL3lrLzBVUDlWUDg5UDlERC9Uei9Lei9Sdy8xOC96OC8wQ3Y5QXY4b3Y5RXIvVUwvUEwvUXEvMHEveXEvMGF2OWF2OCt2OUJyL1JiL0tiL1JhLzFXL3oyLzBPdjlQdjhydjlIaC90OS9wOWZyOC80QS82US82d1ArS1ArbVArdUQvaFQvcFQvclEvNDgvNmMvNjh2K0F2K2t2K3NyL2lyL3ByL3JxLzRXLzZXLzYyditQditudit2bi9nSC9wSC9yRi80cC82Wi82NWYrRmYrbGYrdFgvajMvcDMvcjMvNEQvNlQvNnovK0svK20vK3UvL2hmL3BmL25jTUNBdVBpTEZpN0JnbkJzYTRNVjZNSHhQRWhERlJUQnlUeEtReFdVd2VVOFNVTVZWTUhkUEV0REVvcG92cFk0YVlNV2FLbVdPV21EVUd4Mnd4ZTh3UmM4WmNNWGZNRS9QR2ZERi9MQkFMeGtJeEpDcFJJa05SalZyVW94SE5XRGdXaVVWanNWZzhsb2dsb3hYdDZFUTNldEdQcFdMcFdDYVdqZVZpK1ZnaFZveVZZdVZZSlZhTjFXTDFXQ1BXakxWaTdWZ24xbzMxWXYzWUlEYU1qV0xqMkNRMmpjMWk4OWdpdG95dFl1c1lHdHZFdHJGZGJCL0RZb2ZZTVhhS25XT1gyRFdHeDI2eGUrd1JlOFplc1hmc0UvdkdmckYvSEJBSHhrRnhjQndTaDhaaGNYZ2NFVWZHVVhGMGpJaVJNU3FPaVdQanVEZytUb2dUNDZRNE9VNkpVK08wT0QzT2lEUGpyRGc3em9sejQ3dzRQeTZJQytPaXVEZ3VpVXZqc3JnOHJvZ3I0NnE0T3E2SmErTzZ1RDV1aUJ2anByZzVib2xiNDdhNFBlNklPK091dUR2dWlkRnhiOXdYOThjRDhXQThGQS9ISS9Gb1BCYVB4eFB4WkR3VlQ4Y3o4V3c4RjgvSEMvRml2QlF2eHl2eGFyd1dyOGNiOFdhOE5YRDRzS0g5eXBBaFBDczhDOC9rS1o1Vm5qV2VkWjRObmsyZUxaNXRuaDJlWFo0OW52MS9ueFg0RmZnVitCWDRGZmdWK0JYNEZmZ1YrQlg0RmZnVitCWDRGZmdWK0JYNEJYNkJYK0FYK0FWK2dWL2dGL2dGZm9GZjRCZjRCWDZCWCtBWCtBay80U2Y4aEovd0UzN0NUL2dKTitFbW5JU1RjQVJIY0FSSGNBUkh2RmQ4TC9GKzhYN3h2ZnI4dk0vUCsyTit6dmZ0ODN2MCtUMzYvLzRlaGIwVjlsYllXMkZ2aGIwVjlsYllXMkZ2aGIwVjlsYllXMkZ2aGIwVjlsYllXMkZ2aGIwVjlsYllXMkZ2aGIwVjlsYllXMkZ2aGIwVjlsYllXMkZ2aGIwVjlsYllXMkZ2aGIwVjlsYllXMkZ2aGIwVjlsYllXMkZ2aGIwVjlsYllXMkZ2aGIwVjlsYllXMkZ2aGIwVjlsYllXMkZ2aGIwVjlsYllXMkZ2SmVHenU4THVTc0pQK095d3NNUENEZ3M3TE95d3NNUENEZ3M3TElJditPeXlzTXZDTGd1N0xPeXlDTDdnQzc3Z1YrRlg0VmZoVitGWDRWZmhWK0ZYNFZmaFYrRlg0VmZoVitGWDRWZmhWK0hYNE5mZzErRFg0TmZnMStEWDROZmcxK0RYNE5mZzErRFg0TmZnMStEWDROZmgxK0hYNGRmaDErSFg0ZGZoMStIWDRkZmgxK0hYNGRmaDErRTNlVStUOXpSNVQ1UDNOSGxQay9jMGVVK1Q5elRIdklmdjBlUjd0UGdlTGI1SGkrL1I0bnUwK0I0dCtDMzRMZmd0K0MzNExmZ3QrQzM0TGZndCtDMzRiZmh0K0czNGJmaHQrRzM0YmZodCtHMzRiZmh0K0cwNGJUZ2RPQjA0SFRnZE9CMDRIVGdkM3QvaHZSM2UyK1h6WFQ3ZjVmTmRQdC9sYzExK3J5NmY3L0w5ZS93ZVBUN1g0M005L2w2UGY3Y2UvMjU5L242ZnY5Zm45K3Z6NzlDSDE0ZlhIL081ZjNtSi94UC9KNTVQUEo5NFB2RjY0dS9FMzRtL0UzOG4vazc4bmZnNzhYZmk3OFRmaWI4VGJ5WGVTcnlWZUN2eFZ1S3R4RnVKdHhKdkpkNUt2SlY0Sy9GVzRxM0VXNG0zRW04bDNrcThsWGdyOFZiaXJjUmJpYmNTYnlYZVNyeVZlQ3Z4VnVLdHhGdUp0eEp2SmQ1S3ZKVjRLL0ZXNHEzRVc0bTNFbThsM2txOGxYZ3I4VmJpcmNSYmliY1NieVhlU3J5VmVDdnhWdUt0eEZ1SnR4SnZKZDVLdkpWNEsvRlc0cTNFVzFtSFg0ZmZnTitBMzREZmdOK0EzNERmZ04rQTM0RGZnTitBMzREZmdOK0EzNERmZ04rRTM0VGZoTitFMzRTUGJ4UGZKcjVOZkp2NE52RnQ0dHZFdDRsdkU5OG12azE4bS9nMjhXM2kyOFMzaVc4VDN5YStUWHliK0RieGJlTGJ4TGVKYnhQZkpyNU5mSnY0TnZGdDR0dkV0NGx2RTk4bXZrMThtL2cyOFcyMjRiZmh0K0hqNGNURGlZY1REeWNlVGp5Y2VEanhjSGJnNCtQc3dNZkxpWmV6QTc4RHZ3Ty9BNzhEdndzZmp5Y2VUenllZUR5NzhMdnc4WHJpOWNUcjJZWGZoZCtGaisrekM3OExILzluRDM0UFBqMUllcEE5K0QzNFBmZzkrUFFpZS9EcFJ0S043TUh2d2UvQnB5ZlpoOStIMzRkUFo1TE9KSjFKT3BOMEpybGJrcnNsdVZ1Uy91U1kvbkMzSkhlTHVGdkUzU0x1Rm5HM2lMdEZkRXQwUzl3dDRtNFJkNHZvbWVpWjZKbTRXOFRkSXZvbTdoWnh0NGk3UlhSUGRFOTBUM1JQZEU5MFQzUlBkRTkwVDNSUGRFL2NMZUp1RVhlTHVGdkUzU0x1Rm5HM2lMdEYzQzNpYmhGM2k3aGJ4TjBpN2haeHQ0aTdSZHd0NG00UmQ0dTRXOFRkSXU0V2NiZUl1MFhjTGVKdUVYZUx1RnZFM1NMdUZuRzNpTHRGM0MyaS82TC9vditpLzZML292K2kvNkwvb3YraS82TC9vditpLzZML292K2kvNkwvb3YraS82TC9vditpLzZML292K2kvNkwvb3YraS82TC9vditpLzZML292K2kvNkwvb3YraS82TC9vditpLzZML292K2kvNkwvb3YraS82TC9vditpLzZML292K2kvNkwvb3YraS82TC9vditpLzZML292K2kvNkwvb3YraS82TC9vditpLzZML292K2kvNkwvb3YraS82TC9vditpLzZML292K2kvNkwvb3YraS82TC9vditpLzZML292K2kvNkwvb3YraS82TC9vditpLzZML292K2kvNkwvb3YraS82TC9vditpLzZML292K2kvNkwvb3YraS82TC9vditpLzZML292K2kvNkwvb3YraS82TC9vditpLzZML292K2kvNkwvb3YraS82TC9vditpLzZML292K2kvNkwvb3YraS82TC9vditpLzZML292K2kvNkwvb3YraS82TC9vditpLzZML292K2kvNkwvb3YraS82TC9vditpLzZML292K2kvNkwvb3YraS82TC9vditpLzZML292K2kvNkwvb3YraS82TC9vditpLzZML292K2kvNkwvb3YraS82TC9vditpLytyWC93SHVmOWQvQUFBQUFBQUIvLzhBQW5qYVkyQmdZR1FBZ2pPMmk4NkQ2QXZMakNkQjZTa0FTLzBHOUFBPVwiO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaE1BQXdBUGNBQUFBQUFETXpNMlZsWlplWGw1aVltSm1abWFpb3FLdXJxN0N3c0x1N3U4TEN3c3JLeXM3T3pzL1B6OUxTMHRUVTFOWFYxZG5aMmVEZzRPSGg0ZVBqNCtUazVPYm01dWpvNk9ycTZ1dnI2Kzd1N3ZEdzhQTHk4dlB6OC9YMTlmYjI5dmYzOS9qNCtQbjUrZnI2K3Z2NysvejgvUDM5L2Y3Ky92Ly8vNUdSa1phV2xwcWFtazFOVFhSMGRJQ0FnSEp5Y3FtcHFkL2YzelEwTkRZMk5rTkRRMFJFUkVoSVNFbEpTVTlQVDFwYVdsdGJXM2w1ZVg5L2Y1dWJtNStmbjZDZ29LT2pvNlNrcEthbXBxZW5wN096czdTMHRMYTJ0cm01dWIrL3Y4SEJ3YzNOemREUTBOYlcxdGZYMTl6YzNPWGw1ZW5wNmUzdDdWTlRVeDBkSFNBZ0lDWW1Ka1ZGUlhwNmVuNStmb1NFaEpPVGs5SFIwVTVPVG9XRmhRRUJBUUlDQWdRRUJCUVVGQlVWRlJvYUdoc2JHeUlpSWlNakl5OHZMekF3TURFeE1USXlNbEZSVVZaV1ZsZFhWMlptWm1kbloyaG9hR3hzYkhGeGNYTnpjM1oyZG5oNGVIeDhmSWFHaG9lSGg0aUlpSldWbFo2ZW5xeXNyTEd4c2JlM3Q3aTR1THE2dXI2K3ZzUER3OFRFeE12THk4ek16TlBUMDlqWTJOcmEydHZiMjk3ZTN1TGk0dXpzN08vdjcvSHg4ZlQwOUV0TFMxSlNVcEtTa2g0ZUhpUWtKQ2NuSjBaR1JsUlVWSFYxZFh0N2UweE1USGQzZDd5OHZBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFDSC9DMDVGVkZORFFWQkZNaTR3QXdFQUFBQWgvd3RKUTBOU1IwSkhNVEF4TWtnQUFBeElUR2x1YndJUUFBQnRiblJ5VWtkQ0lGaFpXaUFIemdBQ0FBa0FCZ0F4QUFCaFkzTndUVk5HVkFBQUFBQkpSVU1nYzFKSFFnQUFBQUFBQUFBQUFBQUFBUUFBOXRZQUlmOExTVU5EVWtkQ1J6RXdNVEpJQUFBTVNFeHBibThDRUFBQWJXNTBjbEpIUWlCWVdWb2dCODRBQWdBSkFBWUFNUUFBWVdOemNFMVRSbFFBQUFBQVNVVkRJSE5TUjBJQUFBQUFBQUFBQUFBQUFBRUFBUGJXQUNIL0MwbERRMUpIUWtjeE1ERXlTQUFBREVoTWFXNXZBaEFBQUcxdWRISlNSMElnV0ZsYUlBZk9BQUlBQ1FBR0FERUFBR0ZqYzNCTlUwWlVBQUFBQUVsRlF5QnpVa2RDQUFBQUFBQUFBQUFBQUFBQkFBRDIxZ0FoL3d0SlEwTlNSMEpITVRBeE1rZ0FBQXhJVEdsdWJ3SVFBQUJ0Ym5SeVVrZENJRmhaV2lBSHpnQUNBQWtBQmdBeEFBQmhZM053VFZOR1ZBQUFBQUJKUlVNZ2MxSkhRZ0FBQUFBQUFBQUFBQUFBQVFBQTl0WUFJZjhMU1VORFVrZENSekV3TVRKSUFBQU1TRXhwYm04Q0VBQUFiVzUwY2xKSFFpQllXVm9nQjg0QUFnQUpBQVlBTVFBQVlXTnpjRTFUUmxRQUFBQUFTVVZESUhOU1IwSUFBQUFBQUFBQUFBQUFBQUVBQVBiV0FDSC9DMGxEUTFKSFFrY3hNREV5U0FBQURFaE1hVzV2QWhBQUFHMXVkSEpTUjBJZ1dGbGFJQWZPQUFJQUNRQUdBREVBQUdGamMzQk5VMFpVQUFBQUFFbEZReUJ6VWtkQ0FBQUFBQUFBQUFBQUFBQUJBQUQyMWdBaC93dEpRME5TUjBKSE1UQXhNa2dBQUF4SVRHbHVid0lRQUFCdGJuUnlVa2RDSUZoWldpQUh6Z0FDQUFrQUJnQXhBQUJoWTNOd1RWTkdWQUFBQUFCSlJVTWdjMUpIUWdBQUFBQUFBQUFBQUFBQUFRQUE5dFlBSWY4TFNVTkRVa2RDUnpFd01USklBQUFNU0V4cGJtOENFQUFBYlc1MGNsSkhRaUJZV1ZvZ0I4NEFBZ0FKQUFZQU1RQUFZV056Y0UxVFJsUUFBQUFBU1VWRElITlNSMElBQUFBQUFBQUFBQUFBQUFFQUFQYldBQ0grTFUxaFpHVWdZbmtnUzNKaGMybHRhWEpoSUU1bGFtTm9aWFpoSUNoM2QzY3ViRzloWkdsdVptOHVibVYwS1FBaCtRUUVCUUQvQUN3QUFBQUFNQUF3QUFBSC80QW9nb09FaFlhSGlJbUtpNHlOam80bEpZK1RqVTFaVWxKWlRaU2Noa1ZWQUtFQVZVV2RwaENnb3FGVkVLYWNQS3FxUEs2SUp4c1VVQ09ESkRpeG9qZ2t0SVZSUFRrMk9Ec05KeWdqTEw2aExMckNnbEV2TWdIWUFUY0tnbGZQQUZmVGd6M1o1VG9ZS0ExVXZsUU40aWdiT3VYWk13bUNCbE9xVXdidktCUTI4N0w5RUhSQ1NRc3JWbG9vV2ZZT0NvNkEyQTRRT2hFaUJNTitKSFpBck1HazM2SUdOK2JKU0NISm95SUZPV1pnbzVHQ2cwbEdHQkw0T01BazJFdEVKa3pjYkFURnlBQVZSQ3pzVEFRQmk0Q2pBcTRzR1dvSWd3dWtTSzlVWUVyb0NGU29DS2dTN0hFVnFaYVNURTl3N1NyZ3ExWVVWc2xtUGV1MHE5U3pnck9LUWxVS2QxRFBuMEhyRnNxcE54R0lDUThpYUxnSTl3bUNGUU1JQUdGZzgyeUdJUU1pUjE3QmdQRFFFMGtrYXc2aTRld0hHSm9sRTRoUTZJUmxjUjJDaEpiOFlKQ0lDMDZjWEJEaGNRU0MxUU42VEJERTRjR0Mzd3NldU96bm9NQnFCQ0JRaUlBQUhEZ0UydTlFSURFdVdjZ1RRVkNhTjRmaVVjUVdCRUVNSk1rd0tJWjI0REZlanVqd2diRDU4d3ZTczRXL0FOM1pFVXpPTTVGMjFrTis0RXg0ME5jSUdVZ2dRUWI4OWFYZ2dsb0ZBZ0FoK1FRRkJRQXZBQ3dDQUFJQUp3QXJBQUFJL3dCUkNCeElzS0JCRXlZTUtseklzS0NFUFhUbzdKSFFzR0xGUVpFQ2FBd1FhWkRGandVVnJkbTRjWTBpa0NoWGtDUzU0b1hMbHpCanl2U1FZVU9KZ1NYbXJOdzQ1NlpBRVlzUU1UclJzSU9mTG5UczdEbUpvb1NjblJybDNEeWhnRTJaTVdoY1hGallvWUFiQVdBRjFJRWdVQVhVQUNvRTloa0RvQzBBTDF5Mkd2VHpOU3pZTzQ1UUlHS3hrd1VpRkJYU3VIWHJ4WVZCRDNmc2hvWERRR0FDU0NRaEpSQm9BTXhndDJvWUZjeEFSM0hZQkM4UHBZZ1RKOFdobDNrdXV4MlRxT0FHTzU3QkNvbzVZa1JNUFY1VUF6Q3pxS0NKUGJGYlVMQklTSXp1TmlNTUtxcWorQTJDaEJWSnRQaHltWXlDaFJDNndCSGdaZzRDRUNBMXROOElreHZNbVQ1RUZ6cGlBRWdRQmVnZ1J4RFNnOGRBaFlVbjBxUGNMNUREbGdTQU5MQUJmeWhaY0FBQkF3eEFnQUhERVZoUkIzd2tLT0VBQmpUaVlFT0dJRGhoZ29WY3lGQWdHMHI0QjN3ZUVnUmlpQU9NV0tKQkdhTFk0WW9GUVJoaWhUQWFaS0NHQ3paWVkwSCtBU2pnamd6bEIrUkhKWENBZ1FZaERGblFJeEVVc2dBaFcxeEE0bzRmR0xMQWxWY1dJdGVRRTJEcDVSWkpBa25DQTE1aVNZZ0dRNDdnUUpsWVlqQ2tDUkd3dVVBaEhDaUpBU0ZzUnVBVGtDWklnQ2VXaGp5aXBFQWxZSENJQXc5TUFONmdBNWt3QWdreE1TcnBwSlJXK2xGQUFDSDVCQVVGQUN3QUxBTUFBZ0FyQUNjQUFBai9BRkVJSEVpd1lNRVRKd3dxWE1pUUlZWWpQWG9jd2RDd29zV0JFSGdJMkNpQUI0U0xJQlZDMGNoeEl3OG9JVk1LTkZLeXBCR1ZDMGQwK0pCUW9Ja0JMVGtPTURGd0JCUUtHMnBhRk9FQVFSQURTVExZVkpGem93cWVKeHJzd0dFalI0OG9RNUVVR01CMWdKQW5Bb2swRlVCRW9JSWJBZElHa1BFQ2EwTUhXN3R5UlFBQ2hZVk1PVE5aUUlGQmg5cS9QUnFPUUNDM2E0OEpBcGZzS0xsamljQUVNLzZxMWJHQllZY2doYnMrR0ZnQmdTUkpDQ29NL0NGWnJRMEtERC9BeUR5QVFJU0NKVW9VUEZBNkxRNlVDMDhrWVIxRWcwVW1OV3J2SU5Fd3c1RENLeGdJWlZnaWhRekpOeHBZZklKZ1JXc2dESWhmNUpDQ1J0b1pPUlNBc1FReDRVRUVEY3N0a21oeXdFY0NpakRqR3h5aHZhRFBHREdnaUpCL1VMRW1MaDRSNUFFVEN4UzR3QU1jOERlUUFaTUE0Q0FBbEJRaDBBaE5HR2pnQS92eHAwU0REenBZU1JNb1pHQ2hoUmNvaUVtSEhYYUJnZ1FqR3VnRWZ5RllndUtEbDVUQVlvc0x2Q2hmakRNNldLT0lPSmJJMzRrOXFraGhpeGdxdU9HTUh3bzBvSVVJS2lnUWd4MUdTTkI5K1dVbzVRbitBZmlSbENIUkIrYVlaSlpwNXBsb3Bxbm1tbXkyNmVhYmNGNFVFQUFoK1FRRkJRQXBBQ3dEQUFJQUt3QW5BQUFJL3dCUkNCeElzS0RCZ3dnVEtqVFl3VkNnUUlZNkxKeEkwUUlmQWdNR0VPQmpnYUxIZ3h3T1pCdzU0QUNIanlnRmJzRklVdU9XbEFoTmpDQnhZdUNKQkMxSGNxb3BzTVNHREI1NFRpeUI0WkNEQnhOQUNMeVpNMk1Dbm9yMjJLSFR4WS9FaFNZa0VGckFkWUdoUndJYk5CM1FRQ0NFT2dMU0NuQlQ0R3BDREZ1N2NvMVFBc1VHR0RsaGJFRGg2STVhdFc3OEtEUVJRVzdYUWlkUlVEQkEwZ0FGZ1F6Zy9GVjd4MFBDRVE0TWQ4VXdzRkdoUDM4S05ScVlZTEphT2hrU2tuaWdlUUVoRFFWTm1DZ295SFJhTzNzVFRtaTlKY1JFQ2kxczc1bWQ4SU1odzRVdVVEU0I0TTNrT29vbVBvcFF5UFdXQzhRbmdrQXd4NDBBT0YwZ2VOVXN3UUdEQnQ4b1RWQVFCSWlCSTVqd0Q1YW9Hei9sQ1VSNjVMd29FS1AreHdTYUJDQmdBR3NNNHQ5RWh3UTRvSUJTU0hDZ1FwSXN1T0FlRHlJMFFod1NEcmhKZGhVT2RHR0dBbTdZb1VFUmdramhpQVVsbUdHREtCb0U0SUlGdG1qUWZmbnQxNStNQ00ySG80ZUU2SUdIQVJYc1NKQUdMWVRoQlFCZ25OR0hVREtTME1JWEFFUVpKUmtLQ0VtSUdGSm0yY1lJTytweFpKWlJtckhJam5tQUtlVVlpZXhvQUJobUFxQUdJenRXa0lhWlhyZ2dKQXA5akpHbEYxd29KK1FKQ3JCUnhoaG91T0RublNpSXNBZ2lqREJKVUVBQUlma0VCUVVBV3dBc0J3QURBQ2NBS3dBQUIvK0FLSUtEaElRakdSSVNHU09Galk2UGpSNU1DNVFMVEI2UW1ab2prNVdVVEl5YW9vVVlucDRZbzZtQ01hYVZNWVFuSHgyaHFvU3NyUXV2Z2hsSkJrRUlEaUsxZzFDNEMxQ0NUMElEekFNRlNNTERJaEN0RU1JZ0NNM05CUTdEZ2h3UG5nOGNnaE05MnMwSXRMVWlGMDVPRjlFb0Qrak5RUjNlZ3ljbmhSRUU5UU5nZk1nSFNVTVFnRW40RVhSMGdzRUtkRU15TElSRWdnR1FmeXNRUEptWTZZU0dDQThtZ09BNHpJUUprcG9zRUZFeHdBZ3lsSTJXWEJGQVV3QVdDREFKVlpoWms2WUxWRGxSSU9qWjgwalFFbHFJMXV5aEVDVlNwVFNaQmgwSzFXalFuVXAvQmhVa3MrZk5yWU5Vc25RSnRwQkpzQ1NZSFBDUkFDaFlEaW1oYUFRSU1DT0hBckFsVXNpWXkvZEdnNjFNYXZBZHZJTUV3Uk1oUWpSRmNXRHdZQnd2YTUxUTBzS0tsUlpLRlA1d3pOY0dCVzhHcGdBWURXQ0tBVUVKWm5BT29HUERzQVpVU0pPbThoZURqdFU5dkYyUkxmdUtJQVUzQnN0NEVXWFlDQmE4U2JOZ2RLTEJEaHcyY3ZRb1Bvd0VqdVNqY1JnV05BSUtoUTJMYS9IQURvREhWZ2hWa2xmQnViVklldEpWaXBSRjBTU0xGQ2xabXN3ZlZLTEV3a0FBSWZrRUJRVUFMd0FzQndBREFDY0FLd0FBQ1A4QVVRZ2NTTENnd1lNSUV5cGN5TENodzRjUUkwcGNlSUxFQ0JNVEg0S1k4TURCSVF3bE1pNThaR2lCeVFXRUpHQVVlYkJFaEpNbkNXRmdlWkJESVpnbkQ2MmtPUkFEenBNT1J2QWtxSUhRendVUFNBd2RHR0xMMFFsTENWNjRDZFBRaDZnRFRWellZclJRaEVkWUM0YlFnSUZEeUxBS1Q1eEFXM0JEQTBBSnRuQmdpNEtDQVFJREJoQTRZQUZ0SXdONUF3L2cweUZzSWNHQkNSakNhdUlQNHNDQkdEdCtQQ0F5MXNPUEZZZjkrNWd3V3J0NDlmS2w2eGF1WExvRDFTS3NZQUNQSGtKQ0g1cWdJQWdRQTBjSlQvUTVBd2FBbHpBdE5EZ0VnV0NPR3dGd3VrQkFxSUFNZ09mUHY3UlF1dEFFZ2pjQ3NtZXZvOGpnaURiUXc0dlpJY1NRUWd2dDZQZnNGTGpJVEhqb1h2UVFQREZpeE5xQmd0Q2p0N09oWUtJeDcwR1hoMEFuSEpKQ0hIR2tjTWg5Q2VpbkhSMFpGTVNJR2dFQ0FJWUJBaVVBU1FBY0JnQkpBZ0l4QUllREF0emhnVUV1ZUJGZ0doV2dnQWdMSFhiSUFpSW9PSEtIZzI3NGNkQUZYS2dJM1JoOUNLUkNqREdxSUJBRWRhRG5SZ0dGN2VnQ0dtT1V3WVlDYTVVZ0I1RWR5bkdXSW52WVFVY1hmalNKMEFtTUlMS0lDQU9WTUFlV0hNNXhGZ29sYkpDQkIvZEp0QUtiQWF3UWxpSnJZTGxHZDJFTkVrbU1rUXhDbHdSNzBFSEhIaEtnSnBBSjYwVVVFQUFoK1FRRkJRQXRBQ3dDQUFjQUt3QW5BQUFJL3dCUkNCeElzS0RCZ3dnVEtseklzS0hEaHhBalNweElzYUxGaXhnemF0eklzYVBIaGlSR2ZFUUlnUWNYRmp1V25NZ29Ba3FNR0ZCRURpeENDWUJOQUpNTVlPVHdZSUhQQlV3OENHeFM2ZWJOU1Vvc2l1ajUwMmNUa1YyTUdzVms4VUxUcGhsS1hKSjYwMUtJaWs2dS9wU2dsYXROcjJERitwU0FJcXBacWhXdHFzMkFnaWhYcEVxWk5uMHFrS2JSbkR2MUFoVTZzT1RKbENzeHRud1o4MkRJa1F3eEpQQnhvQWtKaUNjMFJIZ3dBWVJEQlRsbUJBaEFJd1VIaHlRWUFDRXdvQWVDSnd3YjNCaE5XMGFLRWd4UE1GZ3hvSGZ2SVhRVGt0aEJ1M2dOSmd3MUJQSE5QRW5pZzFCd0ZDOStvR0FKM0FRanNHYmVHOGFIaEJSc1RMR24vV05nQlFTU0pDR29NUEFCZDk5Qk9pVGNvR044Z0JrSkJDN1pJYUMvZ0pRQ1RkRERld01nSUJOQ1BkaW5Bd1lvV0pDSmYvNWxZZ0VLSUNEd1hnRU9MQlRGQ3pJVWQ0TUNBaEVCSVlSRUNQU0VFTXdWZ0lRSURFWFJRdzQyNExCREF5dVpvTUtJL3FsZ2drQVpKR0ZBRUFoc3dXSkRKMnhBUVdNQ21UQUFqdjBOc0tOQUozelF3WUVXR2NHa0FFWkFCZ1VQT1BJQUJXUW9sQVFoRHhDQUtSQUdSL1RRd3hFTW1qblFDYzlGRkJBQUlma0VCUVVBS1FBc0FnQUhBQ3NBSndBQUNQOEFVUWdjS1BBRUkwU0xSQkJjeUxDaHc0WVhYS0FaVTRhTmdoTVBNMm9rZUlHTEZ3QWdBWXpwczdIa1F4Y2ZRNEpNVThHa3k0R00xS2dNQ2NiQXk1ZUp4c3dNbWVlbXkwVm1kZ0x3b3NlbnlSRnRoSW9oWk5Ta0FqSXp2N1FnMGJUa2lUNW53QXdOMDBKRFZaY1ZET0RSUTJqRTE0MGxTcHg5R2FQQUN6bDZFR0ZjbTNIUW1nQjRBMmhLUVBlaEJDbDU4Mm82MUxmaG5zQ0JKUlZlYUdJVDRyeHh6QzRXMlBneDNzaVRCeDYyckRpendMK1BCM3NlYURmdzN0RUUyNzZOT3hmMXdMU3VNenBpQUVnUUJSTTNRMmpBd0VGdFNRaGQ0QWh3TXdjQkNKTW1MbXdodEtCUWhFY2JGZFVSUUozNkd3UzROMTRvdEtCN2QwTWZNcHJVMkZPOWZBc0tHME5zOGM1K1FzWU5kc3FYRjhRNCswQU56TmwzZjBEVllRWTY4bFhIbDBDTkZQTEhINFUwTWhBRytubm5nR1FOZVhCSGdBTEF3WUJBRkJnd3dJWURHSUFlQ2h4dzEyQUU5alhraHhzQjN1RUlDaHZBd0NHSE1HeUFRZ2tSTkVnSUJocDFVQUNLMWRVQmdVQU52UGhpQXdJOVlnaDdoRWhRb2tNZCtORUZIWGJzb1VoQkNRakpZUUp6Z1REQkF3NGNnb0Z2RzUzZ1FRWWJnSGxDbFZZT3dFbHJKNUF3d3BKTmJVR0FsUVJzZ1JvSEIxaDVBQWV1V2NESG5BTVF3SWNGc2FIUWdTR0JCR0pJQjRYU0ZSQUFPdz09XCI7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTphcHBsaWNhdGlvbi9mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFSVEFBQklBQUFBQ0ZzUUFBWWN0QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCR1JsUk5BQUFCbEFBQUFCd0FBQUFjWlFZRU1rZEVSVVlBQUFHd0FBQUFLZ0FBQUNvSEJBcm9SMUJQVXdBQUFkd0FBQ2MyQUFCTnR1MFlGVHBIVTFWQ0FBQXBGQUFBQXJJQUFBWk1iS3RDSlU5VEx6SUFBQ3ZJQUFBQVZnQUFBR0M1Y3dFV1kyMWhjQUFBTENBQUFBTWhBQUFFZGtFcVRqbGpkblFnQUFBdlJBQUFBREFBQUFBd0dCNEN2bVp3WjIwQUFDOTBBQUFCUEFBQUFid3Y1azZyWjJGemNBQUFNTEFBQUFBTUFBQUFEQUFJQUJObmJIbG1BQUF3dkFBQXZyUUFBWGVJZVZHUjUyaGxZV1FBQU85d0FBQUFNUUFBQURZSlp2U09hR2hsWVFBQTc2UUFBQUFoQUFBQUpBdWRDWlJvYlhSNEFBRHZ5QUFBQ0tvQUFCQkVFV3A4UVd4dlkyRUFBUGgwQUFBSCtRQUFDQ1FEYW1NVWJXRjRjQUFCQUhBQUFBQWdBQUFBSUFZK0FoTnVZVzFsQUFFQWtBQUFBb1FBQUFVMDhhYjNKWEJ2YzNRQUFRTVVBQUFRMHdBQUk2WmZlT0hnY0hKbGNBQUJFK2dBQUFEV0FBQUJNN1ZVUXpNQUFBQUJBQUFBQU5JQkp0b0FBQUFBeFBBUkxnQUFBQURPRk13cEFBRUFBQUFNQUFBQUlnQUFBQUlBQXdBQ0EyWUFBUU5uQTJjQUFnTm9CQkFBQVFBRUFBQUFBZ0FBQUFCNG5NMmNlM3hWeGJuM1oyWWw1SjZkaEl0NEtTQTNMV29GYXN0RnZMUUhQZEw2S3JXMENnZDVxWitLNTZnOTlGQ1BSNjAzRk1TcTlZNVNxNEFpdG1CVlZGUzhFQkNNUW5CRHdpWGNkb0FrTzJ2dm5henNhMkp0clpuM08ydGZzaE1pWWovbmozZXR6NDlaYTlaYU0vTTh6MitlNTVuWlVTR0ZFSVZpdERoZnFNa1hYenBObE43NGk1ditVNXdrY3FnWFdndnpQUHRhM25EdHZQOFUrZWJLUlk1UWxFb1VmdStJa0dQdk51L0tWZFpNem11c2RWWmx6dWljaVRtWDVzekx1VDl2RTZjL3J5Vi92TG5LdVRSL1R2NURCYVVGdCtUNUMyY1ZMaWhjWFZSY3RMUm9ZN0VxSGxJOHNmakNrdXRMWnhjUEtiMnY5TW5TdUtmTU00cC9SMXVWWFNldHprdWVicnR1aXdicGs1N2NzNmlZRnJ2T2ljbXpkSGJtak5OTDNLb3NWbW5RY3ZJMDdjd3JudGdUNmY2NjVFbWU2VkdVems2RDBYTVczR0xPOUhqTVdiaWdxTGcwN3NyTGFmb3N1TVV6RDQxVkpxWEp1YlNvMkdqTzQ1aWFvcVZKMmZKYXJFcnp0T3hWbzd2eUpRVzNGQlZYM0ZlNHV1OHY4ellWRmZkVHBmRisrZjBxQnV3ZStHcHAvTVFsUm5zblBYN1NrbE1lUDJYTG9CbURIbUpFNkdwd29jZEpqdnZVVXpoL21OZHk2cjY4VFZibDBLR210Mkg5Y3VZVnJoNXhoZWtyTFUzK25KeUpCYmVjdXE5d3Ria2ZhYjQ2NWJRM1RyL3AyMmp6MjdOSFRSeTFjVlIxOFVUUHFGSHRad3d5Zlo2NXdHalVNK3BzZGZhazBYTkd6eWtlTXZwK28vRlJHOGNVbXZ2UytLbW5qSjVqVlpiT0xweFZHamNZMWM3N3pxaU5IcWR3dFdjVVBTZlBUYWJmcEo3YytrM0pmODJac2RTOHBEWE5FMWZmOUgvcVBucEl3YlE2YXFONWF0Nm1oUVhtekxiMThhQTNEdlRrUTdiVmU2SjBkcEtIUnBJdTVGenF6cEhNT2VhY01SZVB1WEhNeldOdUgvUHdtSFZqdG84NU1pWStkdURZUVdQUEdYdisyRitPdlkyWk5rTVVpZjVpZ3Vnbkpvb0tNVWtNRU12RUFQbDlVU0hIVTA0RU40Sjd3UDFpZ0JvbStxa1JZQ2JYczhESG9rSnRBZFdpd2hva0JsaER3RkF3bkhha3FOQkR4Q2xpcU40c3J0UVJNVU1mbGhmcHNMeFhOOHVGdWxZdUVlWHllYjFGYmhaOTVVRmRKV082V2wydWw2azUraWZxT3YxYmRUMzNOK2g2ZForT3F6ZjBmNnUxM0grZ0wxZnI5VVBXWEYxdkxkSWQxaVBnQ2YySjlhU09XWXUxMTFxaVB4SktuU2lLZU5QR2F4VHo3NFc2WGN6V0VkcHFFd1hpZmtaeHUwN0l1M1ZVTHRFdGNqUDNCL1VSM2o5aXpkZHQxdE82UStTS0tUck1lRnZvcDQxMm83UWJGZHVGUnc4UTVXQzRyaEpuZFg0dXhxRzF5ZnFRdUZpM2luOEZsNEFmZ1N2QU5QQXplcjlLdDRqcE9paG1nbnY0N2w2d0FDd0U5NEZGNEFYYVdBRmVCQ3ZCUytCUFlCVnRyQVl2ZzcrQVY4QmE4Qlo0Rzd3RDFvSDM2ZU1Ec0I1VWdnMzA5U0hZUk51YmFlY2p5aXJLanlrL29kektOOXVBRit3QXRXQVAyQXYyZzRPZ0hod0dEYUFKTklQUE9qK1hIdDBxeTBGZjBCOE1GLzNrU0hBR3Vqd0xuQTNHZ08rQzc0RUpPaWduODk3RlhGK0NsYWZvUTNJcTc4L2hlaTZZQjI0RnYrT2QzL1BPdzVTUDhzMHo0Rm11bDRIbDRBV2UvUm1nRTdtYThuWGFlSWZ4dkVlNWdlOXJLUS9UdHAvbmJTQUs0clNSb05TNlZRbGdnUklkVlAxMWxScks5WEN1UjRMVHVUNFRqQWFYd2U0ckthZURHVnhmemZOcktPL2ttN3YwSVhVMzVYektoVHhmQkJpM1dneWVCbjhBei9IK012QThlSTM3TmVCMThEN0FIZ3A3cUU4cHZaVGJLWGRRMWxEV1V1NmszRVc1bTNJUFpSM2xYc3A5bFBzcEQxQWVwUFJSMWxNZW9rUm1kWVN5Z2JLUnNva1NXNmtBQ0lGV2dENVVCTVFBK2xCL0ExK0FMd0c2c1NSQU4xWXV5QU1Gb0FpVUFPeHRsVE1UK29MKzRBUndJamdaZkFzTTFrSHJWREFNakFBVDlBRHJQUEFEOEVNd1gyOFUrY3p4L3JKSjlHZHUrNW5iemN4dFAzTzZpVG5keU16ekM4bDdyYUl2Yys1RC9FTVZmbUd0UEtMMzRoUGVWV1g2RFRWSzcxVGYwVnZ3RDh2NXZncWY0RmR2NmsvVlcyQzkzcVlxZGNTNmw5NFhhUnVmRUxBZTFRSDgyZ3o5SWpQNE1XdSs2TXZUQkU5alBJM3pOSWJYT0JldmNZRFpQWTNaZlFHZTRVcFJpbmRZSmgvVEhYaUdRM0lwZm1xei9yTnN3dSs4cXBzWTRjZGlpQmluOTRnSmpIaWlkc1FrWFMrVzZYbzVYTytSSThIM3RTUEhjejhSVE9YK1JzcDd3UDNnZGU3ZkE3VjZqeHJHNkVlQXk3aWVBV2JpNVdhQmE3aitXRHRxQzZqV2pqVUlMemNFREFYRHdYeEdlQklqV01NSTJ1aTlodDVyNkgwTnZhK2g1eHA2cnFIbk5mUmNRODgxOUZ4RHoydm9lUTA5cjZIbk5ucHVvK2MxOUx5R25tdm91WWFlMTlCYkRiM1YwRnNOdmRVUUUzNm0zMEtIbjRoZmRhNFRkK2pUMGM3L0VYL1dENHYzOVBOWTZWVTB0VlUrcnUrVVQrbnI1SE42RVJxN0Zzc3RsU3YwOWZKRnZVcXUxTCtSTCtsWmFIR2xQQ2c4V05RdkcvUnlOSHFUdFBYZFdQY04rWGQ5aC93SDE1MzZWbFdxNzhEYWQySHRKVmo3Z0RwUHoxY1hjUDFqNmkvWGI2cWZ1ZGEvSGZZOGd6ZS9FUmJZV09ZR21QQTRUSGhGdlV2VStFQjRZTVJqTUNLTzdXTlk3VFZzL3k2MmZ4ZmJ2NHZ0MzdVZTF4OWcveGkrM2tTRVlyejRoYUljYVJ2RmJKZ3lYNi9saS8xOHNaOHY5dlBGZnZjdEQyOFY4MVlyYjVYeTFqYmVDdkZXSU1PNGdXaGxOMXFKeXNXNkxSWGZqcUNOQUpwb1JoTmg1a0VGV2dnaCtWNGsyb3MwdTVDbURta01wd1BxRFZHaTFvcGlKS2h6SmVqZVEwZ01Gd1dNMG95NFJPOWdQQlZFcWhiR3RJOEkyMkpHTDM2bFg4VldYbXkxSEZ0OWlLMDJNcW9hK1FnKzh6Rkc4TGorV0Q0aFNoaGhDTHZWWWJjZ2RudVBrWVlZNlRic0ZtUzBCeGp0SjlhRmVoYzZUQ0RyeTR6RXkwaTJNWkp0akdRYitrdWd2d2c1K3d4a3U1Y3ZWMm8vREMzaHpUYmViT1ZOaHpjZFVTYk9JcHFPQjM4RXo0TG53Rkx3R2VNWkJjNEUzd0dqd1Zod0RuaEhoNjB5VU1GN2VlZ3JDak5pc0NLQjNtSllQSUhGUStocGwrakQyRnZjY1RmeG5mRnhsek4vMXRPejVLNUQvSWg0WHNacXBDeGw2UXJpZFpCNEhTUmVCNG5YUVdKMTBOWGRLc3JWNEdYd0YvQUsyQXEyQVMvWUFXckJIckFYN0FjSFFUMDREQnBBRTJobUxQM2R1QmVVMDBRWnNTMUlYQXNTeTRMRXNpQXhLa2g4TXJFcFNHd0tFcHVDeENZVGg0TEVvU0J4S0VnTUNoS0Rnc1NaSUhFbVNKd0pFbU5NVEFrU1U0TEVsQ0F4SllpdkQrTHJnL2o2SUw0K2lLOFA0dXVEK1BvZ3ZqNklQdy9pejRQNDh5QytQR2lORTJYV2VEQVJuQXNtZ2NuZ0l2UnpIcHB4MEl5RFpodzA0NkFaQjYwNGFNVkJLdzVhY2RDS2cxWWN0T0tnRlFldE9HakZRU3NPV25IUWlvTldITFRpb0JVSHJUaG94VUVyRGxweDBJcURSaHcwNHFBUkI0MDRhTVJCSXc0YWNkQ0lnMFljTk9LZ0VRZU5PR2pFUVNNT0duSFFpSU5HSERUaW9CRUhqVGhveEVFakRocHgwSWlEUmh3MDRxQVJCNDA0YU1SQkl3NGFjZENJZzBZY05PS2dFVWNVcFBqVEFuL1d3WmdXbUJhRmFURjQxQXJUT2x3dVdXSUtIdUJLSXNBTWZNVUo1SGdPdVpoREx1YVFpem5rWWc2NW1FTis1SkFmT2VSSER2bUxRNzdpU0RPQ29XQXgrQVA0Ry9nQ2ZBbVFsdmpyRUg4ZDRxOUR6SFZFSG4yVnVISG9PVkhFN0d5Uno0dGlScmNGenhnVGZjaERGNUNITGlEV0xpRFdMaURXTGlEV0xoRFNmVzdtbThOOGM1aHZEdlBOWWI0NXpEZUgrZVl3M3h6bW04TjhjNWh2RHZQTlliNDV6RGVIK2VZdzN4d3hTT1RxdUNnRTAzV0N6RFZCUnBrZ28weVF6U1hrTkIwblEwdVFvU1hNL0NMTFNwQlZKY2ltRW1SVENUS21CRmxRZ2l3b1FSYVVJRU5Ja0NFa3lCQVNaQWdKYXh4K2JUeVlDTTRGazhCa2NCSDlqY2FYL1FxUDhwRDQxWmNieEIyZGQ0ajdPei9BajUyQkgvc3hYdVlYYU9VUmZKaEhQdFVaeEhjTmxrczdtN0hmeFhKRlp4czJuQzVYZG40cFgrcmNUOHk1Z3BpVGk3ZGRUOHlaSXBzNk80azVmUm54dnhOelNvazVmWWs1ZWNTY1V1eGRqdVltWWZPL0VIUDZFM01tRVhOS3NmLzF4SndwZU9saXZQUUY2b2JPR0Y1Nm8zcTFNd0l2eHVDQi9pOHhwNUNZa3d0SFJ1T3g5N0NLUWdkaUZCZ0x6Z0cvQTArQ3hlQXA4RFJZQXRDZjJBS3F3YWRnT3pnRWpvQkc0RWUvcGFBTVZJQis0Ri9BcGVBR2NETzRBeXlCSy9oRDZRVTE2TndEMExjNkRYd2JuQUhPQW1lRG40T3JBT05SakVVeER2VWUrQno4SGZ3RGRHSWpBUlRJQVgxQVBpZ0V4WUF4V1ViR2M1SFVSbEliU1cwa3RaSFVSbEliU1cwa3RaSFVSbEliU1cwa3RaSFVSbEliU1cwa3RaSFVSbEliU1cwa3RaSFVSbEliU1cwa3RaSFVSbEliU1cwa3RiSC9KcVF0UTFvYmFXMmt0WkhXUmxvYmFXMmt0WkhXUmxvYmFXMmt0WkhXUmxvYmFXMmt0WkhXUmxvYmFXMmt0WkhXUmxvYmFXMmt0WkhXUmxvYmFXMmt0WkhXdG95YzQxajErY1c1ZWlkNTF5NVdjbjVXY241V2NuNVdjbjVXY241V2NuN3lzVjJzdXZ5c3VQeXN0dnprWkx2SXlYYXg4dkd6NHZHVGwrMWkxZU5uMWVObjFlTW5SOXNsRitpZDVHbTd5RGtiV2NuNFpSWDN1OGwzKzVNaFRxYWNTWTR3Qzh6bWVpNjRrL3E3d1FOY3J3YjB4NHJDejJyQ3owckN6eXJDendyQ3orckJ6OHJCejZyQno0ckJ6MnJCejByQnp5ckJUNjYzaTF4dkY3bmVMbks5WGVJMGZNb2dmTW9ncFBRaW5SZnB2RWpuUlRvdjBubVJ6b3RrWGlUeklwa1hpYnhJNUVVYUw5SjRrY2FMcDRvamdaZVJleG1sbDFGNkdaMlgwWGtablpmUmVSbWRsOUY1R1oyWDBYa1puWmZSZVJtZGw5RjVHWjBYdnpZSXZ6WUl2ellJdnphSU9MNkV6RmN4ejgwY2Q4UWE0cFNQT09ValR2bUlVejR4RlQ3K0JGeWg2OFJQS2FkUmR4WForWFRkZ1A5cUlJYjVpR0UrWXBpUEdPWWpodmtFY3dZUFhvY0hyOE9EMStIQjYvRGdkYXltNjFsTjE3T2FybWMxWFkvdmE4RDNOUkR6Zk1ROEh6SFBSOHp6RWZOOHhEd2ZNYzlIelBNUjgzekVQQjh4ejBmTTh4SHpmTVE4bjJUK1NPYVBaUDdJSXVBaDZ5b0hmVUYvbnAvQjZ1QXNjRFlZQTc0THZnY202QVppcFkrVmN6M3gwaWNmNU52ZmMvMHcxNC95TEpuTjJaSzVURGJYU2pZWHdpYzN5RCtTZno3clpuWUI0cXVQK09wRGMwMnNvT3ZKOExhVHArMG11enZJYXJxZTZGVEhhcnBlNG0rSXdUNFpvQXlDRUdnRkRtampuVEJsQkVSNUowNGZDY29PN3Y4SzhCM3lDL0FsME5wSDdQWXBmQWZ4MjZjS0tKRlpGYnN4b29Fb1dFZWNhQ0JPTkJEYmZjUjJIN0hkcDRncmFnckFoZ3I3RWV0OXhIb2ZzYVJCNGVmVUxlQjJzSkM2UlFCOXFNZTRKd3NscXRhUkIvaUlySFhFblFiaVRnTnhwMEd0NU5tZndDcndHcy9YZ05mQis2Q0tPbXhEbnVBalQvQ1JKL2pJRTN6a0NUN3lCQjk1Z284b1hVZVVyaU5LMXhHbDY0alNkVVRwT3FKMEhUbUVqeHpDUnc3aEkyTFhrVWY0V0NYWHMwcXVaNVZjenlxNW5sVnlQYXZrZWxiSjljVEFCbUpnQXpHd2dSallJRzRtd2g0Z3doNkF5VkdZSElYSlVaZ2NoYmxSbUJ1QnVUNlk2NE81VVpnYmhibFJtQnVGdVZFWUdvR2hFUmdhZ2FFUkdPcURvVDRZR29XaFVSZ2FoYUZSR0JxRm9WRVlHb1doVVJnYWhhRlJHQnFGb1ZFWUdvV2hVVmdZaFlVUldCaUJoUkZZR0lHRkVWZ1lnWVUrV0JpRmhSRWkvd0dZR0lXRkVWZ1loWVUrbU9jd096MHd6d2ZqV21CY0ZNWkZZWndQeGtYYzFjK2ZLVmNEUC9WUkVPZFpnbEtUWndsZ2dSSTBQaHlNQktkemZ5WVlEYTRFMDhIVjFDK2tYQVFZQXhhUFltMGYxdlpoYlI4V2ptTGhLQmFPWXVFbzFvMWkzU2pXaldMZEtOYU5ZdDJvTWlzSitzYUNVU3dZeFlKUnJCZkZlaEdzRjhGNkVhd1h3WG9SckJmQmVoR3M1OE42UHF6bnczbytNcGdEWkRBSHlHQU9rTUVjSUlNNVFBWnpnQXptQVBFL2w1VlhJWmpDZXUwcThySHB1Z3BMVm1HMUdGYUxZYlVZVm90aHRTcXNWb1htWTJnK2h1WmphRDZHNW1Ob1BvYm1xOUI2REswdlIrTXh0RjJGdHNOdUJIeUdhN0k2dEZ5SmxtTjR4UU5vT1lhV1kyaTNDbTFXb2MwcXRGbUY1cXJRVkJXYXFrSlRWVWdhUTlJWWtzYVFOSWFrTVNTTklXa01TYXVRdEFwSnE1QzBDa21YSStseUpGMk9wTXVSZERtU0xrZlM1ZUo4dUJ1QXV3RzRHNEM3QWJnYmdLOEIrQnFBcndINEdvQ3ZBWGdaZ0pjQmVCbUFsd0Y0R1lDWEFYZ1pnSmNCZUJtQWx3RjRHWUNYQVhnWmdKY0JlQm1BZXdFNEY0QnZBWmRueXlpWEF6K0lnZ1RRckp3RnNNRHA0RXd3R2x3SnBvT0ZnRlUwdkFuQW13QmNDY0NWQUZ3SndKVUFYQW5BbFFCY0NjQ1ZBRndKd0pVQVhBbkFsUUJjQ2NDVkFGd0p3SlVBOGVoNVVTVHVaRjFaekxxeXVOdDZjZ3IzWmsxNUJldHhzNjZjenBzelFXOXJ5N1c4OHhaNEc3d0QxcG05Vzk3OUVQeXo2MDRQYzdBYzlBVm1EVHFCRlVSeUhWcWNXWWMrU3QxanhOSm5LSi9sUGJQS1NLOU56VXBqRlhWbWpkcEdhZGFwY1o3M1hLdVdpQ0s4ZVlzYVRqa1M5TFoydlpyNjdQWHJZdDQzYTlnL1VOS25XZ2JRNURkZDArS1pXL0RNTFhqbUZqeHpDNTY1QmMvY2dtZHU2YmJlTGVIZXJIa0hpeUxyVkRBTWpBRGpSREZyNEdMV3dNV3NnWXRaQXhlekJpNW1EVnhzemRjYnJIdDEyR0tGYVQyaTI4d09odlc0K1pWQmxGcUxSWWxGdHMzNWI3cE5YSTBHSjRIendZVnVadElnbXluYmRadTZDUHdDL0JvOENGN20vVi9DbHlMNFV0VHQ5NElwM0NkL013aTV2eG4wdnVjZmdpY2hlQktDSnlGNEV2cG45L0RoUndoK2hPQkh5TjIvTjN2ejA3Q3YyWDgzZSsvSnJDSU9MMEtadmZjVnhzTXc5MTdDaDYraVBybkhIbkwzMkh2dXJ3L1ZvVzc3NmVtOTlPNzc1YUhVZm5ub3FEM3lyOSs3RG1IN0VMWVBZZnNRdGc5aCt4QzJEL1hZdXc2NWU5ZmpzUGQ0TUJHY0N5YUJ5ZUFpOUY2TUhlUFlNWTRkNDlneGpoM2oyRENPRGVQWU1JNE40OWd3amczajJEQXVCdVBOMjkydlpsSmU3YTZNMi9IaTdYanJkbHBKMEVxQ1ZoSjQ2M2E4ZEx2YldwelN0RmlpMi9ISzdYamxkcmYxcXltemUzaU8rMlhnZVVCdmVPTjJ2SEU3M3JnZGI5d3VGaEJicW9rdDFXSWM2NUFKZWpmcmtYWjNQVEpWMTVMLzFwTDcxakpDbXhGR0dLSHRya2ZlcEc0RDF4K1NLL2JSdGVTaXRlU2l0ZVNpdFhJNGE0MlJ3S3hUSnZEY3JGV21jajlOVjd0cmxlVDZwTjFkbnp6SSs0KzYrV1l0a3RueWRkNTdENnlIODFXOFU4djFUcTUzYzEzSFhEaEludG5JdTgyd0prQVpCQ0hRQ2h3UUJoRVEwMXZSa0kyR0l1U1V0ZVNVdGVTVXRlU1V0ZVNVdGVTU3RlU1J0ZVNSdGVTUnRXalJac1hlcklicDNXalRWaU1vV2FHeGVtOGlqNnhseldTMEd5R2ZyRldYc1Q2NlhIOUVYbGxMWGxtclpxVFdVMWZ6Zm5KTlpTd1FVZGRRLzB0eXhqbGdMblcvcHU1bTNyOEYzRXJkN1pRUFVQOGc5WTl4L1FSNGxubjlITzBzcFZ4R3VaenllY29YM055emx0eXpsdHl6bGpXYXNXWkV2Y0U0elc3U1dxTEtCL1MzWG04bEQ2MTExMktEV1dXYTlSZ3JXWGROTm95U2RSbFd0NG5CMWNUZ2FtSndOVEc0bWhoY1RReXVKZ1pYaXdLMHZCa043a0RLN1l3K29LN1hoK21wbGw0Y2VsbE9MN1ZpQkh5cGhCZUdFeVpiak1DRkNMYXZ4UGFWMkQyQ3pTdXhiUVM3UnJCckpYYXR4SjZWdEw2VjFnOWpud2g2ajZEM05uUWVRZDhSOU4yS2ZpdnArVEI2clVTblJvK1ZqQ0NFWGlMb0pJSStJcWtkdENQSUdFRytDTEpGa0NzaUt1Um0vYW84U05tZ2o4Z20vWXEwV1duOG5kNDYwVTZwUHFKR0lkTjV1bDVkb0J2Vmo3bi9HYmlPMW0vUUI5U3JlcjE2bDU0L0VPVmlFdkxaekljQTh5SE9mQWpBLzVnd21RTDhRRVliZmdmZ2RnQTViWGdkZ05jQmVCMkgxd0hrdFpIWGhzZGhlQnhIYmhzZWgrRnhIQjRIMFlFTmgyUG9vUWFPeHVCZEFNNEY0Sm54RVRGMFlMdmFuMEU1ay9wWllMYnJPMkxvdzRaWFFTd1RoRmRtcHNmZ1V4QXVtUmtmZzBOaCtCT0dPMkY0RTRRcnhzL0VzR0FBQzdhWlg3SFJYUTBjQ2NDUEFOd0l3SXVBZUVRTUYyVmlKREYvRkJnTHpnSGo5QkcwY0FRTkhCYjM4UHhlc0FBc0JQZUJSWUE0TEo0RWk4RlRnSGdzbG9CbndESysyOFE3SDRHUHdSYnFxc0duWURzNEJJNkFSbUR5ZzFKUUJpcEFQekFjTzQ0RTQ3SGhSUEF2MUYxQ3Rub3A1VlRxNTNCOUE5YzM4bXd1MS9QQXpkemZTbmtINVQzVW05L25YK2ZkTjdsZlIvMTdYRytnM0N6NnlXcEs4aUZaQTJxcFQzb1p1Q1A2eWhhZWZRWS84a1daOHBqZmVDbFBwUnhHM1Fod0d0ZmZCbWVBczhEWjRETHFmMDU1RlpqQjlVejROQXRjdzdYeEJ0ZFNHbzl3SGVVTmxMK2h6WnVBOFFpM1VYY24xM2VEKytBa09sWG9VNkZMMXdPczRQa2J0TFZXSDFKdjg4NTcxSC9BZlNVVzNzajlod0JkcTAvQmRsQURkb0xkb0E3c0F3ZUFEeHdDUjBBaitKeDIvZzcrQVRySmJjakhMQVZ5UUIrUUR3cEJNY0ErTU9jd3pEa01jdzdEbk1PVzRjeFljUkx6WkJ4emhLaVZpaUZSWVZadXcrSDVTRENlNjRsZ0t0YzNVdDREa25FZ2luVmljcDN1d0RJeDVrekM5ZjNWM05keXY1Tjc0LzhQdXZPa0hjMjN1Lzc0TXU1bmdKbXN2bVlCNDNldjRkNzQydC9nSDR4dmZaWTErVkt3SEJpZitRYWFXZ3ZlNXZrSFJtdGtZWU5ZcVEwQlE4Rnd4bnd0ODhDVG12MjJPRmVVSW9rTjl6MXczd1AzUFhEZkEvYzljTitEaERiODlzQnZEL3oyWkhrSEUvbHN1T3B4UGNRY3loc3A1MUxPQTdlQ2U3aGZJRXJSZ08xNmpIVmN1MTZEM0drRHo4MWZzVlJSVncxY0QwTDlicTdyZExQclFYeG9wUWxmMThLN3JDdmdhaEN1ZXVDcEIwMlpLR2FyeWFJMDVVMENLVzlpb3BTdFpsT2Y5Q1ROY05KNGsyWTRpVWVoL2pmZ0p0cTRsYnJicUx1VDY3dkJBOVEvUzI2OUZDd0hML0I4aGZFdzFMOUJXMnZCMjF3blBVd0FUcGJDU1ErYzlNQkpENXowd0VrUG5QVEFTUStjOU1CSkQ1ejB3RWtQblBUQVNRK2M5R0FWRTcxTTVESlJ5eGFqc1VnVHZHckdHbVpQMUkrbW05QjBFNXIybzJrL1dtNUN3MmIvMHcrdm10R3FINjAyd2F0bXROb0VyMEpFaDBhNDFReTNtdEZvRTl3S3dhMW0yVUxXbnc4bUk5Rmx4UHdaWUtiMm95ay92R3BHVTAzd3FobGVOYXViZU84QlNySlp1QldDV3lHNDFReW5tczNmSGNDcFp2VWhxNFJCMm84RWZpVHdXMmFmZHhnU05DS0JHWGtqSTI5a3hJMk0xSXl5a1ZINkdXVmphcFFOak5MUEtQMk1zakUxU2oveHpNOUlXeGxwS3lNMXYvVTNNdEpHUnVobmhJMk0wTThJL1l5d2xSSDZlNHpRendqTjZQeU1ybFdjd0doYTBXVUNYU1lZVVNzamFrV1hDWFNaWUdTdDZES0JMaFBvTWNFSVd4bGRLNk14OGJtVlhsdlJUd0w5Sk9pNUZWa1R5SnBBMWdTeUpzVDN5UjRqWkk4UnNzY0lrVE5LeGhnaFU0eVFLVWJJRkNOa2loR3l2d2laWDRTTUx1TCt6bXIyalFKY0IwRUl0QUlIaEVFRXhIaW5uWGM2dVA0citCeDhBYjRrSTFDZ0FOQXVHWjNKS3RyZDM5dklSSWlvVVRLM0NITWdRdFlXSVd1TEVFbWpSTTRvR1ZtRWpDeENOaFloZWtiSnhDSmtZaEd5clFqWlZvUnNLMEwwak1MbkNKbFZSSnlhOVR0V0I3bFBCN2xQQjdsUEJ6bFBSK3AzckE1eW5nNUcyMDZPMDBHTzA4Rm9Pc2h4T3NoeE9oaEZCM2xOQi9sTUIvbE1CL21NeVdVNnlHVTZ5R1U2eUdVNnlHVTZqdm1ibGtKZlc4bGx3cUlRRDlDUHZ0cVkvVzN5YjdEZ2NtTDh0ZUE2Y0J0WUFjaW5XU1htTXRKQ2Q1U205UTVhNzZEMURscnZvUFVPV3UrZzlRNHgvYWdkeE9SZm4wVjczVG5zN2EvSC90bGR3KzUvQ1JaMWR3bk43dUREN3Y1emEyWW4wUHpGbHRuNVMvNVZWdlNvblQvemwxaG14MitVdTJyc3Z1dVh2ZU9YL0N1cnFQdFhWdDl3dCs5ci91S3BheWN3K1JkUFVldGV5a1dzSUIraGZCUWRMV1B0WG9KVlNnUlNvdkV3R2crajhiRDVwUmF0aDkxZkhxWlJwdmQ3WHVDOUZlQkZzQks4QlA3a1dpV01WY0pZSll4VndsZ2wzT3V2RU9sOW9NMThVd1UrQVZ0NWR4dndnaDJnRnV3QmU4RitjQkRVZzhPZ0FUQlBzVlM0eHk4TzRkU2VVRmhPd1JMVFJBbFdDMk8xc0xzdmxOd1Rxc042WWF3WGRuOGh3UEp3ZURWV0RPUFRYbk4vRVloeW5kd1hDbVBOTU5ZTVk4MHcvdTYxMU41UVhkYmVVQmpyTm1MZHNQcU9LTWJDWVN3Y3hzSmhkNC9vSnI2NUN5dk5keTBleHVKaExCNU83ZXlIa3p2NzNmYUx3bGcvalBYRDZrM3Uzd0x2Yy8waDdhQXZCWk1WVEZZd1dlMENzRm5CWmdXYkZXeFdzRmtoazRMTnFzbGxUeGoyaEdGUEdQYUVZVThZOW9SaFR4ajJoTC9tbDRBdzdBbkRubkRxbDRCd0wvdE5KZFo0TUJHY0N5YUJ5ZUFpY0R6N1RhV3UzekFaTG56R2QwUmxKMW8wbWU3bGpQNWFjQjFSM0dTbXQzRzl3dldBVVpOaGloK0ppMFd4K0Zkd2lkbVhCTlBBS3JBYXZBeitBbDRCVzhFMjRBVTdRQzNZQS9hQy9lQWdxQWVIUVFOb0FzMmlXUFlIazgzZUluZ1lMQVBMelY4cmlJblNUOWtpQnNvb1pZd0lucUQ4VFA5VmFrWXZnT1ZLTVZDZFRubW00UVc0SEo1Y1NUa2RYS3YvaW1STlNEWVF5ZjZxRmxLM0NOQ1hlaHFzb080MXlqWGdkZkMrKzVkVFRVZytVREUyRlFBaDBBcmFRQVRFQU9PdzhrQUJLQUllWk1sbmhPL2grM2NRaVE0eWlxbjAvQnhyMTZoNmk5eHp2YjVVREVudC9VVGR2Wi9zZlovMFhrOFQ4YzE0eGhhaWNITFBKOHA4U1BUWTk0bW05bjJTTWUwbW5qL28vcGFSdmZlRDlkeS9uT2krLzJPaVFoMVJvWTZvVUVkVXFDTXExQkVWNm9nS2RVU0ZPcUpDSFZHaFR1UmsvUlZXMG9NVldIUDFQbXJqMU1aVGZ3VVp0NTdRRzYwbllkeGkvWW0xUkc4UWlyYzZ1QXU3ZjVHNTAyMm51eWNzNUkwOTFueFJ6cE1vVDhJOGlmQWtTbHZ2cDlwNmg3YldpbHhhU0ZBYnBzYjhyWjFEYlFzdHpuWC8rakpFYlNzMXpXNk4rU3Z1dVB2ZUV2b3VPSzVaWVVZWWNYdjVKQ1ZYbEhlalppeklNVi83ek50R2JuZVdiZXlwRVo1NmFLdU10c3BNSy9BZ0tWRlhLNmFIUFVMS1ZYaC9zMjlid1dwamhCZ3BUaE9uaTIrTE04U1o0aXp4SFhFMitlNFkxbFRmRmVlSTc0bHhZcnlZSUNheUZwa2t6aFBuaThuaUl1YmVGSEdadUVMOFZQeE1YRW1FbUNIK2pSZ3hpM1hLdmF4UkZySStXU1IrSng0UUQ0cUh4Ty9GdzZ6dUh4V1BpY2ZGRStKSnNWZzhKWjRXUzhRZnhiUGlPYkdVU1BTQ1dDRmVGQ3ZGUytKUHpPS1htY0d2aUxYaUxmRzJlRWVzSTI1c0pHNXNFcHRaNVZTeHl2bEViQkhWNGxPeFhkU0luV0kzYzdxT09iMlBPWDJBT2UxalR0dWlSVGdpTEtJaUxqNFRuNHN2eEpkQ1N5bHpaWjRza0tYU0k4dGt1YXlRZmVVSjhrUjVzaHd1UjhyVDVTaDVwdnlPSEMzSHluUGs5K1Y0T1VGT2xPZks4K1FGOGhJNVJVNlZQNVhUNUJ6NTcvSS81UFh5Qm5tam5DdC9MZjlMenBPL2tUZkovNVkzeS8rUnQ4aGI1VzN5dC9KMmVZZThTOTR0NTh0NzVMMXlnVndvRjhuNzVjUHlVZm1ZZkVJK0paZklaK1FmNWJOeXFWd3VuNWNyNUl0eXBYeEpycEt2eVRYeWRmbUdmRXUrTGQrUjYrUzc4ajM1dmx3dksrVUd1VkYrS0RmSnpmSWpXU1UvbHAvSXJiSmFicE9mU3EvY0lXdGtyZHdwZDhzOWNxL2NKL2ZMZzlJbjYrVWhlVmdla1EyeVVUWkp2MnlXdGd6Sk5ra2VLK015SWR0bGgveGMvazErSWY4aHY1UmFDYVdVcGZKVmdTcFI1YXBDOVZkRDFUQTFYSTFRSTlWb2RaNDZYMTJnTGxTVDFVWHFFdlVqZGFtNlRFMVZWNmtaYXFhNldzMVNzOVV2MUgrcXVlclg2bi9VYjlVZDZrNTFsN3BielZjTDFFSzFTUDFPUGFBZVZFK3F4ZW9QNm8vcVdmV2NXcXFXcWVYcWVmV2lXcWxXcWRYcVpiVkpiVllmcVkvVkZsV3RQbFZldFYzdFVEV3FWdTFVdTlSdXRVZlZxYjFxbjlxdkRxaUR5cWZxMVNGMVdCMVJEYXBSTlNtL2FsYTJDcWlnQ3FrVzFhb2MxYWFJZDRwc1NjVlZRcldyejlUbjZtL3E3K29MOVEvMXBlcFUyaEtXdEpSbFdUbFdybFZpbFZrVjFpQnJzRFhFT3RVYWFnMnpobHNqckpIV09HdThOZEU2MTVwa1RiWXVzdVphZDF2M1dndXRCNndIcllldFI2eEhyY2V0SjZ3bnJjWFcwOVlTNngyaCtybi9WVmZlQXlXZms2ZC9Td2k5V04rdnQrc3E3ZWpOZW8zNEJvZisrVGQ1dTl1WDkyZXUya0dIdmt0SDlDcjl2bjZCNisxRWhYSzlWVlRvUjQ2anBXWVFCRnQ3MUNlKzlzdW1iekRlMXFQNmJBRjdVdmNObVNmUDZCWWRPdXJydGlRNCttWHFJcXpYajMxVTlEWmExc2pKbzV5cmNqTVNjOTJqdjVhdmFmbVloN1oxeUpXd0lhc3VwUGRscmxka3JqWm1ybTRXZmJQZTN0RFpwcXYxVC9SLzZYSzlXLy8yYS9xN0dac25lcldZSjJsWHZkL2NkSDZnRzR6TzlQak1sNi9yUi9SeitnbndFTm9vbzZxTWI4cjA4M3FkL2todjQ0MDc5ZTM4TzlKOWU2QXUwMUg5cG52OWx0NnBkMVB1N042djlyT3l5eDdiWVBmZmcxazFlL1JobzVtVWRrb3o5VzA5cEZyby92dFJqMW83eVNVZDZQcGF0N3B0R1J1VzY5ck1tenV6dm5wQnY2TTM2SDNnWTNoUXJwZkRqWExteDM3bWJHUFdlMmNSbllYK1ZMUDZTN0d3Sk5WZmE3THZydEdtbVBNVmgxNS9qR2V4WTM1NWpGbUZuZDF2V1p2MzBtWjN6WCtUNCtqMnNwNGQwdytRYS95emZUckhlQlpMdG50MDY2NGZLWE92Mm5wdG8vdWNYOWpqcWNkdE8zRXNHK2k5N3IrTHYyck14eHIzVng5R2ttK3VLMzIrUGxOUDF0OEZwOEdvUEtyeXlPank5SS8xUEgyZmZwdzNQTHFZbVgyYmVidnpHdTVyOWZYWmZpVjVkTUlNdlFXOGttcTNJemwvWEZablJwV01BSHFsZmt5dnh3K3ZaNGFITXZwTWxib2F2Ry9tUnVldjNQdmY5Ump4TVRYVTVRTzcxZDU2REEzVVo2NzI5M2pTSVNSNThEbXAvKzc2ZUE0bExDSjNydWpqM3VWeDVvc0M4dU04VjZ0RnFiZFlVWm1WcS9HRFBlSkNCVDdheEovKzd0MkFUUDBBemhOYy96MHdWWE1pT0lsL1R6NnVjUjNmMkx0TzgxK2c5MG1kZWFrejEwWDZORWQrNml4TGpiM3JORkcwZityc09vd002VFA3T0JISlRxVFhpZ3h5K0Q0YnBqK0RQclRYRXoyUHZKVGU4bnBCY3RRQ201aWpzQWZTWDZlUmJDZVgwYWFSUEFabW9mdFJuSVg4cjRDSktHWElhMngvY2dZOWJkSE55N2p0SGU5aHJOY25aYkd5VkkwbFR1SGZQdlNVdEdNQmQzbXVSb3hXaTl3ZXpMdWVsQTZTMzNYeDc4UlUyVldUckRNYXljb3FzbzVzQy9keDU4TXBxYmJOblBpV3lXcGRLd3ppM296WWNwLzNjVWVRNXo1THM4Nk1MNGZ4RFhMSGw3Ymt0MUl3UjFKWEpnL296NXc0ZWh6Sk9XVlkxdlYwaUl2azJKTXNIWnoxMVJEM2ViYmszMHJWcUY2bFRmWlV3dHNsbVMrTzcraUwzSU5UdWpIeUpVZFkwQU41UGI0eWM4SndJc21qcnUrNmppNUw1UjMxTkMrcnpNdk1PWE1rNTFNU1I3Y3BzdVpBVXErRDZEOE5jNXlTMGVMZ1hyOC8xbUhHWUdhZG1SOXBaUHVFNDBGdi9pRWJhZlpreittZTZINGs3OU56dDdjamFZTXU1QjZYdFBLbzBweTUxZyt5SWszWDFRRGF6WjU3WDMyb3JKRW15eTRycEtVNDJZMUo1bSs4REdlN2V6RkxHSGJsdVA4SGtweXMrbHczcXVXNmRVYURwZTVNUGNXTllWOS9ITitjNkI2QmV0ZDNmdVkwMTRXcHN5UTE5cTR6TFVWT0R5bjZaRTdoU3BFOGpTd2UxMCtta2M5MzJlalNSczVST1ByZFl4OWZOeTl5TTBqSDJUNVo2TjcreVZnakcybVBZWTVDSk9zTnhuT1VJSyt4ZlZrR3laNXlSSHJtV2FrYWtXblhITWVUQjNYNXlQeVVaVlRtMzRFaWJWbVZlU2Q5bUhkUHlGem5wTFJRNmw1NXNuU1RQa3hkMG80NW1YR25qMUtlWk44bnRaTHU2eVEzNzBySzFGOTA5K3BkSHFBOGEzd21qK3VmZXRvOU5wdkR5b3d0eC9YbHlSeXBiMmJXNUtaa01FOXozWHdtTi9ORmJtYjg1cTIwYis2YllZQkhkSjhMWHhXQkREdUtlTnNneVVUUnJleDU5TzZuVHNqRW9xN25CZDNHS2pJOE4vVkpIaVcvSzNCMTAwOGNmYVJiTFhjamJyS2w1SnU1UW1UbVhQTG9tbGRkWStucVB6MEg4bE9XTjNFcWphNFdrK2o2dnJzZlNPZmMrZDNxK3FiR2tOc3RpOHYyQ2NlRDN2eERkNlQ3N25NTVpQdVQ1SDE2N29wZWtMUkJGNzRxVWhrL2ZLTHJpMDJzR1pDS09lbTRrc3gzM1RwNXY3dXI3MEVyWGJ2NlIrL3BkOS9QTjd2NUY0dEx4SS9GVlBHVDFJNytkSGMzLytyL2hkMzhWWm45L0RlL1prZC9xNmdXMjhTbndpdTJpeDNIMk5rUGZPWGVmaCtaSi9ObGdTeVVSZDl3ajMrU1BFK2VMeStRRjZaMitvOTNuOS9zOHBzOS9nWHUvdjZEOGxINXBIekczZGRQN3VWbjcrU245L0hOTHI3WncvL3FIWHl6ZjM5WU5ycDc5bWEvUHByYXIwL3UxU2QzNm52ZnAvK3FYZnJwM2ZicC8rTi9aYWUrNnYvRHZmb0pxZDM2ODZ3ZldEODBlL2IvRDVneWFjQUFBSGljN2RSSmJJeGhITWZ4My9QKzN1bFVNWlhXemtuRW9YR2djV3BDR3BwRzZRa1JEc0xFUVVpWG9YVld0VysxYTYxVklTSWhvYmFpU3UyVW92WWxxQzcycmRiYTZ2YytNeGNTaVlpamZ0TG5mZWFaK2M5TU10OFpHQUF4R0l5TmNGSlMwMGNna0JITXpVSXZ1RHBIU3d2OHVoZzRvRTU4aVBydHVUOFl6TWhGNzR5SkU0TG9sNUUxTlJOSklXOU56c2tjSDBKcVRrNmZ2a2pYbW9oaG1uVHN0UGRQdS9yczZrYWUwMXVqN09wSE5PTFFGVDJRZ0VRa1lTQ0dST2FTdzVOT2FmaTJVeEdlZHIrSGIvc0NrV3RDNURvc2NoMEp4elRpTlZkekRkZHlIZGR6QTRzWllnazNNWS9UbWM4Wm5NbFpuTTA1bk10NW5NOEZYTWhGTE9CK0x1WVNMdVV5THVjS3JtUTJDMW4wMDh5ZlRSeG1CWS93S0N0NWpDZDRrcWQ0bW1kNGx1ZFl4Zk04eEF1czVrVmU0bVhXOEFxdjhocXY4NGJiN2kvbjJ2Q20zSkxiY2tmdXlqMjVMd2ZsZ2RUS1E2bVRlbW1RUm5rc1QrU3BQSlBuOGtKZThwVzhsamZTSkcvbG5ieVhEL0pSUGttemZKWXY4bFcreVhkcFlZdXJqOHcxNGdoZHNwemxydmZua3lqeFM3UzBraGhwTFczY3RoS1FXRGVXeDZWTWZjU2pQVHFnSXpxaE03cWdHN3Fyb3M0NjdhN1B2Q2Y2cS9BVXBHazNGR05VVWo3bTZHd2VpakFJYTFHTTRTakJWb3pDTnBSaExBN2hDTEpSaVNya29ocTFtSVo2UE1KeVBFVVRDdkVCemZxdWZERU9OaHVmaWNGMkV6RHhLRFVkVFRMS3pHQ1RoanBUWUFyUW9LWkNhRlJueFhqazFZV1hLdENyTWhxTzZ0cWpuVkhOanFteGovcjNOZjdwelA4ZS8ybVBLaS8rbC9MR2FPYzFOOEEybDJLYkcyR2JHMjJiRzJlYkM5bm1wdHJtOG14eksyeHpSYmE1RXR2Y0Z0dmNEdHZjYnR2Y0FkdGN2VnFLczIzcFY1UVQ5QjdTYlY5cDJuVkZEQ2R6Q2pkeUZYZHlGMHU1bTN1NVQvZVl5UHUwai9uTnQ0aTJZOWlPamUzWWU0MG9Ub3IwcTczai9jWWFVL0FEQjdXazhBQUFlSnhqWUdhWnpxakR3TXJBd0RxTDFaaUJnVkVlUWpOZlpFaGpZbUJnQUdFSWVNREE5RCtBUVNFYXlGUUE4ZDN6ODlPQkZPLy92eHhKZjY4eU1IQWtNV2tyTURETzkyZGtZR0N4WXQwQVZzY0VBSlFGRHpZQUFIaWN6ZFRwYjFWRkdNZng3NXpudHJLMFZub3BXL0YwN3NHMktvallBcVdsRzZVV2tJSlZscTZVQXEwb1ZnTm8zS0lXRlNvaWdpc1NFZE42cXdWQldxT0NDNXFJaVVaalRQUUZ3WmhLN3puOUEweUlKb0xuSEVmYUVBMkpyNTFrNXBubnhTU2Z5Znd5Z0RBOHA2TE1pdFZ1T25XeGoxZzFwajdQTnBLNWlsUWVWeDNxUmRXdCt0V3ZLclF5clFLcjNqcHBmVzE5WXcxWTUwU0p5R2hKazJteVMzWkx0M3d2UDhycFNHZFMxRloybWIzRC9pTnJtUjZyTTdTdEhaMmpaK2w4WGFTTGRhVytYM2ZvSHQycmo4YVNZdEhZaEpnVHk0bk5qRFU3bHBQc3BEbnB6aFRIZHFZN2k1MFdweTM3MjkrL3ZCQUp3dEFQUXlOTFJkTmxSRjJxejRqT1c1TkdSRjhaMFJrajRwSm91eEh0a2JqOFlFUkVkdHJZcGZZMnU4dUkwRkU5VVd1ZGJVUjV1dkNTS0c1RVIvNGxhaHdSamZ1SHFQV2lTQm5SbjJFWS9oWjY0YW13UDR5SCs4TGFjSGs0Tjh3TXpnZjdnNzMrb2FBajJCUTBCMnVDdW1CRlVPNFArbWY5WC93Qi8yZi9qTi9uSHhzNk5kUTVWRFUwdy92SnkvVzBsK1haM2xRdjZxVjdxVjZLbCtTZWRyOXpEN3U5Ym85YjdaYTVKVzdlWUl1Ym03aVFxRHZibnFoT0xFMVVKaFlrNWlRbUo2ekJjT0JBU256VUhaRjIyVHo4bXYrcmtXeU4rYnNvTHJNcHJKR2R4WCtQNFpOQ2hDU1R5aXNZeFdqR01KWVVrNFlyU1RNNUhVYzZVY2FUd1FRbU1vbkpUQ0hUcFBscWJMSk1ZbUk0VE9NYXNza2hsMnU1anV1WnpneHVZQ1kzTW91YnlDT2YyY3hoTGdYTW81QWk1bE5NQ2FXVVVjNENLbGhJSlRkVHhTSVdzNFJiV0VvMXkxak9yZFJ3RzdlemdwV3NZalcxMUZGUEE0MDBzWVptMXRMQ091UHY1R21lNFZsZVlqOXZFT2ROZW5pYnQramxNRWQ0aDZPOFN4L0g2T2M5M3VkRFB1QTRIM0dDazN6S1ozd3VwV3lsbFRidWtuSWVvcHZOM0MwcmVZQk5zcDZkdkNacnVVODJTQ3NiZVZBYXBFa2ExVUZwb1oxSFZTZUgrSVFuMk1DOTBxd3FaSjNheWowOEpoV3M1MGwyOEtvYXJ6SWtYMmJMZkNtV0Fwbkh4OUxHRjZwSWxraU5WTWtpMlNoM1Noa1BTNkdVeUVLMnM1dW5lSTVkN0RVL3hRdnM0UlgybVJ1K3pPc2M1QURuMUNyVnlCWlZxK3BVUFkrb0p0V2dWdjhGdExmOUlBQUFBQUFxQUdZQVZ3Qm9BSXdBcWdFQkFOWUFBQUFWL21BQUZRUTZBQlFGc0FBVkJJMEFFQU1oQUFzR0dBQUNBQUFBQUhpY1haRE5TZ014RklVVFo5VFdIM0RWQ2tGSUdLcFFFdHk3bXNWTVFib1puUzV5WGZpRExkaXVmQUZoRmdwREZqN0xtZDEwMThmcFM0aW1VeTNxSmlmblhQSnhic0QwRU8zTVZweS9VODAvMy9CNlVyV0R1MXNEcnFWTXB3bjR2Y0dXQnU4cmcwRExBWUxlNE5wR0pKMTBsMk1uQi9McFlZeXcxNmdmVEJ5ZFM3RGNUdjA1c2dveGljMTFRblJoRUs0d1lZTng1QUd6YjhDc0FmajNId2JiZWlnUm5HYjJ5cUpJQk9LRWhGSXl4U0t6V0NSQ0VSbnNiRHA2ZlprZXI5dnVhdXowRFZwclFtNFJDekJ5YnUwaWhjSTU0ZndHUDM3eDE5ZWMvUS9pMzRIL2diVG1SZFpNaWtpSlZSQ3BTUG1HbEJpMDlUQzNxYStvZk1VOWpVNXFzSy9SOVhLZ3F6TmVTcGZiZWN4QzlsaTNXRG15YzlZSmxzOGtFSG00TE9zanRzbFdXeDVxeEdVdDJZMnR1aXdSYzlZTmxnbVpMN0VRaUswQUFRQUNBQWdBQXYvL0FBOTRuTnk5ZDN3VTFSWTRQdmRPMmZUc0p0bHNDdWtrZ1FUWWhDV0VEaUpOV2tCNkNUMEJxUWtDV1dyb1JYcVJUdWhGQWRrc0FVRVFSQUVGRkNJV1FBUVVVVVJBVkZDVTdONThiNW1aekN6Qjk5NzM4LzM5OC9NOVpuY21aKy9jY3U3cDUxd09ja1VjQjJxSURvN25ERndkenNHMTdPbUExc2hpR05Da0Y3MFI4STNnMWFTWGt4T2dLYWkrZzdNNkJLTkRjdmlrOXJ3YStXMnZ0SFNRWUxJRkoyVFlRR3hCZ2QrU0plQW1mL2xacDkwY3gwR3VVR2dJcmtoaG5NajVjZ21zYlJFM0o0Ymd0b0hTZ3NPcjFDRWFIVDZsYWVuQmZFSndoczFDcnovSHRlRnpIOFcxRVhMRVpxaU1LNzk1RlpVQmVKMjIrekxIQ1p0eG55TzVHQzZQdGV1UDIvVlgra3dIUVByc0xmR3BEc2xZTE5LM3hWMk5mSUpmWE9yd05oYjdhSjRFbERyOGpRNWpxU1BBNkFnaWYzWEVsRHJNcGZpSGppcWxqdEJTQnpBNndrc2QwT2lJeEowRWNiaC9DUmx4d1hING40MG4vMnptQkQ3T2pKL2p1emg0QzMzY1lVaUhjbURzZ3U2QjZsbERza0FEZlBueGFSZXVIRDNxTU9RNmFOQUZuUVhyVVM1WW53Mk9EZ0JiRVAwM0FMWE94cytlZ3FONGpJQWJWNTdHdTZYRlhFMXVKUnVoTng2VXR6SkNQM3pqcDl6RTRwdFlML2ttQWQ4a2tMSHpDZDVrdmZCb2ZKU3BkcHE4RTlpejRoRE4rSGxqY1lUbU5zSG9pRmQvVVkyMWttQXNUcTBBd1pOUUp5bTVGc2lvVXpjencyYU9Cb0Vnb1U1U1FyeGtEZ20xUkFOemlHUXdKMlRVQWsyQkxTVFVWcnN1UDJmWjRkSlBQdG1YZStBRHlPZHRXYlpxM2Z4VGx6NHVkZVFjZWlUd2VlZVhydG9QaG81ZTlGTHo5OTdhOW1uQStmUEduMDZMYTA5c21EQjJZYk9XNys3ZTlYSEFpZmQ5UC85Q0t0NjRBV1BTNlBMNzRtenhET2VQVjc4Nmw4azFKQmhReitwb1lLWEQ1L0h3ZVdWaWt2Qk5FcGtMbnlTZWpNTEhXbXlDdW5HSFZkdzZZeGhRak5XUlpDeXVxWUdMTVJiWGdackJCOWVwYTZzZEdnVkNwSVQ0cEF3MnhNYUFUUUQ0bDcrSnljQXlldFAwd2swYnA4MG9HakM0YjYrQmczcjNIZ3luNEVkRm0vQ2pnWVBZbzBFb3JpMzh1SzJ3dHZDZGR3bzdUTnUvZjFyUEtWTjZkdWc1YlZwUDE2ZlQzbmxuV2tmbFdjYytreWIzdnA4bWpFM0RPTU56ZmNydkMwZngzTVJ6YVZ4amJqYkRHd2xQZ3FUTWlBWGZXQlJVcVlKdnFwRHBTWkdxNEpFNzYxU1J5QWVYVW9kOCtOZEpJUjhCN0c4bTlyZHc5bUVPRDhBZnhRa1ZLT0ZNQ2dnbnM0YzNXME1kb2xBc3dWT0NrU0lRZ0NZQXo0bGtzQmdTa2dNQW1TR01RY0cxNjJaaXNHUkRBTWFjVUI2alVDWUdvMU1HWm5mdTZOeXc3SzNlM1RhRGplbDFSNy9TOGloY01LbmIrZkdmUDFtK1lHL2ZBNjNRSU5FQXJlT3k5c1kxZmFtNFFmcHIvWExIOEpGRGR2WW8ycmR0Y3UrWkwwMUNNYTBkUTZaZjZYRlZYTnl4NjlkTys2a2g3bVp0WGdhM1JZTlF0ZC9hWmxOMkN6V2JMK2swdSthZ2VsbkRacko5SnpUbmJsT2FGY0ZWRUVCQ3NXQUZ6V09FNm5aU0c2OWNzUnQ2Q0h3K3BiOWRoTkxoS0trWForSzhPWXlKbUNoaFVDT1hHUU1rYURJYmcvQ3drempUSWhDNlY0cFlmdlhxOGdocFAzb0EyNE1Sc05rZzhNcFE5eC9vVUFnNjVQNWpSS3Noc0E0WVI5c01RdW5nRDQ4MmdaSERFMWczeUpSaGhNbVp0bERPQlA1QUQvWkpFY3V1M1ZnVUliME5RbUZqdE1qOTZaQld1VEFJdEE4QnIwQnpicXRCN2cvUW03VE5LRGlWYjR2cFp3RFhYRE5HakNOTy8wQ0JyS0svMVFrRmYvSU5XcDErL3BDaUJmUWpEd3lsVG04L3lna3d6ZlFsOURBeFUrUnRmS0pGRERiNGdtVHdHaXFKQmUyRllWNmdSUnc2ZUt2YjE1OTI0MzhlbVRNWmpFVUxDM05lUjk4MEJlbm84OGFrSCsyNEZVSzZjQmh6aDBnTzB6Y0hSMG16cENWTmxPQ2E0MHdKSmt4dVRUWTRBUnhETFNlaWpzQTVFZDdKUTlIZ2RoNjRUTnJxZ2hBSTVJN2pkVE55ZUR3Vi9DVXRQWkd1RmdnYy9tckxnaUQwQUZoMlkvaDAyQUFhNFdhOGE0STRQTXBpb01OYS9ESm9SSEhnRm15UXc5RTV3eHdOcEhFN01MeU1GeHllTTg1TGp4ZHhoQSttTFZpd2cvMG11bndXL0lYeTFtQ09NRTR0YzAxTHR5UUEyOEpSY01ESXFWSk5qdksxZVhqL0pzaTByU0Y3aXc4RzkxRjJMeVZ1NUpVK3htS1Rub0NINmJwdmhBbnhNQndZZzJ5MWcwekpqUHFZS0MzS0VCS2VYTHY2OU1tMWEzL1pIYnQzdjFPOGE5Y0JtSUYrUXFVZ0hZU0RsdmhmYlhRUjNRMzU3dmZmdjBOdjN2enp5UzAybHVQbC84QmRZZ21lMzhZYVRxNzBUSjBNek1rRlpUNktlUTExaGJ5SWtTWXRYVXd3aVJtSmNKY2RMUUcvR01RR3FWMTcwdmFIWTU1dXdtT1A0TEpZK3liY3BNbXpmUjJqZ3FWTzNzUVJWRFFaaTcwMWZ6QVpIWDZsVGd0bm9tK3NEaktBUWxETUNjbEpNalV5QUV1Y1lITFp3WTNabzlZdDJyVnZEQlQvdW56ODlwcDVhQXlFdi9hRlVXK2U2enQveDVIMTBtSFgxY1AycDJ0UkE1SDBjM0Q1ZmY0SjdtY0tsOC82R1lpN0ZxajBNeExmUkZKcEtUS1FTVXZPL2h6SWRscnh4UkZvTERab2VobEloQjRIWnl4TzBaQlJjd29kVUtUUkVWdUtyMW9TaTllVkxPQno0NkFNTnlHK3FzSnRNVVFxQUNzWGJ0NnhmdTJpZzNsUS9QdkVSM2VuajVzL3Irek1TZlNyQ1BOT3Jkdnd6dUczRnZMaG02Zk8zN1p6bnZUMjdhOVBERDFVSS9ub3RBOXZYanNsTFhSc1hiMXVKY0hIbG5oTjJtSDg5ZUVDdVZjcWtVSlUyUkFJVkVvQTFtS29HYUJFSlNmZlVxY1g5SlZGRVgreW43RzRSUGN6c0lFNFU3S0JIM3JuVG9HN0c5dzh5ejBTUmtrMjhGVU9XZ2J5V3ZBdVZ5TGZCSTVpK1BjVzNodGV1Qzh4M0JEV0U0QmZEcFNlQk9DYkFJSi93RmpNYTZiVEt3Q1FOM3Rac1VqbkZHTzh5QTJXOG9LSnJGY2NxdW1ybDdHNGluYXFJd25WNFp1QXpMcEI1aEM4bTVJMHM0dm4zL0IrWi9pUmUzdmR6Tm41NzkyNWNiUGtOeEdPMkwxdzI5YXR5eGV0aklNcithZ3g3bit3M01PWGMxZHZvTC9QblpGV2Jqejkzdll6dlhyVGZiNFdqeVdHNG5veTExbERUWlRSaE9DYkVNcWxkUmpqREFpaHlCRmdMWTdVZEQzRVdCeXZ3NUxhb1JaRExjeGRwU2lNOTVnQzBBRnc0YUFPRjR4N2JsYUdBZWUxVzFFL3BuNWV4MjFmTlhvdi8vU2RQMCtmd3lKMjlGc1REOFY5c0hyRmdiZkZNL0d4ZzJLalhaL042TmdQL1hIdEN2b1oxQUFpR09NQ1RkenJwdzBlOGZrZlArNDg4RFZabXc0WVQ4amErSEZXTmhwZlBBQmZUeXh4K09wM0tVZHd3UWZ3aG9UTUlJNUkwNExYZzJjcHZuYmZGT0QxamVzVWYweHNpMzUybjBRTEprMENZMkVQWU1nbE1zNFFQSGYrZU80c1dLT3djcSt4OTVueEs4eksreWlLRXF5czZXMG0wMVVUNzhHYVpBL2lpM2Jpbkh4a1RjTFlBbXRHeWtKeG5LWjNabU54c201VzVaMG00SjFHcEJaRnJ1RVZ3WmZJdWRydmQ5NTRmYzVXOU96aVplUXVtdlA2dklmdkgvODk2NVBWYTA5L3VISHQ2ZXJGcytmdDJ6OS96anRDL1FuRjFhcWZuSDc2aTh0blpweXNYczB4NFhqcDU2N0ZiK3pmLzhiU2JkdjUxdE4yYjVrelk4TUdqRE85TU4zNVVjYVpqcFhvUEFyT0ZIT2FFUnBDS0JNMzZCSEczd05oRW9tSVNzUXhtRkdIdy9nU0RrSTRqUEhKbWRHQXlHWVp5cWhBK2E3VEdRZEhmL3lZS3ovK0JVSlB2dW00cVhWb2l6bERaeDVJUExSaDhidjdPdDI4dEtMdkVCQnkvUVpJUVEvUk05VEZqZTVGeHd5SnJRTHV6Qm0wL3RMMUovdjMzT2JLeTduMUdHa1NoSHBHTEF3OTVrd0d6bFQrbUY5RitMWXFyL29SQnNrUjJPR1lyeWNMRFl6SkdPb3B2OW9rY1lFV1RvR2x6RlNHcFhnNGlaL1BsMkpKS1pzN2FBQ1NrT29jSTRGOHAxWEN5MytMWFByVGl3RmZ4aGp3SDI2UmIxWnk4U1lYSUJtWURPc1FTeDFDYVVtQ1lCTmd2c05nSkRxcWQybEpEZTlHM2pBZjQ0TEJiQUZtekZiTUlIN2tTSmpyT3NNM2hNMnJTRlhRazJsZzhrQXdhUnJqNTIrQ1hmd1ZmaS9WclJ0eHVIayt0Y1FJWWdITWRob0J5Q2ZFU2tNdm5VYlNWM3pKOWxCWm1UeENCQ0QraXVzRTM1ejg0MThhN2k0YmpzYzhCWS81bkRKbUNIZ3lab2piNlEvSjBNamxGcmw0NHd2UllMSDJ5K0dCNE81QURNT1RpZURKREpGdnQvQUZ5eEo0NUhqOEpRbWlUY1F3Qmg1U0xocWNRVWVjbVpFOGhlL2dPZ2p0STBmeTNTYWp1UVBSbkNrZ0tGS0t3dVB0aURkb0c0cWowVnlQU3JpNHloMGpJZ2xyZGtSWU1RT1BlREVEanpESnZEQktZMjdBTkZuaDVnWU5GOFRLQTdWQ1RBUXAyU01IejU4MkFiTVF5SCs5NitDRk9aT2FSQm9YTGdTclpnM3RscmRtM1BSRkM4WkxPMCtjM3pmdjg3RVpmUWVna2V2cFdnMUZEYVdmeFVXY2pYdVpHODlocnU1SXR6cFNyVHFLb2hQQ25KSTNZZkZhRmRLUmJpeU8xdHltR291cmFtNHhoY25VOGYvaWw3UnFKVllTeUs2amVoRm1PelpDeG0yOFJJZ0pKcEJ4c1J3UHVUajgzWUloWXJsZytnaXdQemNDbWNHVTRrdFhmTDYrMlBFMVU4YkczRm56Z3kwUDl2UWIyeEx5dFgwNlpTN1o2UnVFSEdnMWVoLzFOUVdEVWFCeno1SW1NYzB1OWtlejBZRGdJUEFWS0FEendJS3lJOGF1QTdvdnJnT3NzUjNUNWpvZ3VJbyt6TzB6WU9Cdlp4Q3daV1JDOTRlekIvenpNWmdERHFEcWFEcWFnMnJXU0doWFBRMDhCZzZ3QjBvb3l2MTB3NUh1WTdGK0JXTXRFYit5ZlJDTCtjTXR6QjhNV05KdnBkYzRkUGFhaXYxUGhRb295RUtGbDJiV0JHWXFJbFlZTEQ4a2dEaVF3SC9temxrOUJWYlBoNGxUWEU5aGUzUlRBcXZSY05IeHJCUGVFQ0VjMVkxUDRqN01venFQQmZjbnV4SVpRcEV4bldFY0ZSckNyRTVyR0dZWmdWcDVJakNNaW5YR1lxUFdwR1FzanRGdVY1c3BUaXVhQVh4TDVZWkUrVFB1SkhqckIzZmhxRG03M0YraTZXRDYxaU83TjZOUklLdG8veEVIdWlnNlRuNlF0eXMyN1B6c2p5N0RFKzdkbTVmTzJwT3pjTjRiQ3ltTm00MzUzejY4eDZLNDF2L09hNGxCQzNQY1lOM2M2ZVJuUEpWUlpDb3RFbVpxSEZZbU1mRVhzSTVLTUFsR2daQWdnbHJDMnpBWS9mclRZL1ExU0huOE16QUd3N3l3YzBkTzNyMTc4c2g1Qy9oWXVsNEcrZ1BMUXhBS0J2NTFTenIwQWJwNjk5RXY2TnJ4WTNqZHlaeC9odWZjRytzL0RmOWx4c2tFYWcxeWVIcDlQZVl6bHNNS05CZEhwcEpyakNXWmhKTmdOL0FGZmRFTzlDZldYZEt1QWd2NitZcm9RQnZSdldQb1oxUWt0aTJMQkxYdW5yZ0RhdEY1STMzcGhmdml5M1d2eEM2aVNySStnc1FzUlU2ckQxNTdvSjg5blhScjFPSWx3VWdUVVZUcFAvNngrMlUrd1pYTHYrbTZEZCtIcDl3N2NrUkhydnVHM0k4QmRFNkcvTXRPd0NLendBUlhaMzh2a0YwUzQyWDF3c1E0eXd2a2x4UjZMZlhDSE1TS256c0w4UVBQVGtvZXZVcVErL1RNM2FpQTMrcjZHcDZHYjd1N2svNThqUHV6QXVQVFJZeFBzVnkvZjljNEhZR2xSTzhNMHV1ZDRack5FY1A3TUFOYVNXQk1UQXpNTG83V1NSa1V5N0JTcXNVeXJKVlNMQ1BNVGJpWWp0eG5FRG9HTXY2NkQ3ek5jRXpFaDhkUFAwS2ZMYitRaUthQ3N2MnRKNFBlSUJpdmVnRG9ldis0dE9JUXVuTVRQYjZEdnUyY0JxYmt5bk43ajY3eG1FcldXRGN3RmZWMHErL0ZWbCtaOVFOZUo4bE0zeUxmdGJOT2xrR3JaaERGMzBRbUdpT3F5U2JjSzNDZExpamdHeFhBSXZjZzBlSHVDdmN4SGVZYXZuU205b0NvU2l6dFNwZG9hemJRMlc3SG9FeXV3YkpmTWI0eEt2SzFUbHVnaWpoZEkySklML2JYYTR3bWFvbFV0UmUrdnYzaDhjK0lGcmhuNDV4OW9xUHM0Y2Yzdi94VUt0cCthQzJuN3BOZktaM01xUVEvdmZDTlY2VmtXOUhBbkJMRFhNbktoQzBpZTVVVVNrc2xxTnROVGw4Z1Via0NKTkI1c3dHYnhSc1lFZ0Q2cEtEZ1k5aDRIblR2Z25QZ0VyamYzUVZQNFNCWUpMcnJ1K05FdFk4RzNFZVJxLzR2ZTBnckNXUDBJNXZBQmpKaHFldUlQUWR2UjlhT2xJYS9tYmd1bGN5cnpwU3NUcktLU2NvTjFmL2xMVUtrS3lLNllHRXhMZDBiOHljYkhseHdNbVpUaG1EOERmU0ZGZ21HRnhYNFNPNGZ1cmp2U0w0Rm1Fa2hFV0pHTlF0T2hjK1E0QUx1K2U2cGRPSFpPQjlSZkg3NS93cWZpU1FMYVplOFNnbFdBUU9aYTVDSmNmUlJnZXVNWkxmekRhVUM0UTRvaThLWUVBMkU3eG0vbm9KcHdrLy9UK3hRUkVZaGpJVjhKTmVCS2w4SnloQitRaGVRcTV4RGwwQWE0SUFBNmhZOCtyTDA1M3VsWHoyRUE5RlBhQWZvQ3lJZWduRFFEMjFEZCtFREVJdStlL0RvVi9RZGlIbkV5YnhsRmJWTkJDdFdUTjJDVVVaRExUR0FaNVlZTFU4aFhRM1NkWldRU2NxMEs3ZzA3aEw0ODhleXNoL1JUREN0NUZESklUUVRacnUzaTQ1N0gzejRjKzY3Q3hjZHBYTlZRd3pBY3hYTXhTbjlNT0pYRzUvVFJubHZJK21IMFZoc0FUcVpVRWNsUVFnMFdBeUpWTVI3MGNTTnlubldCZjNkY0ZhYkY4emVEdlJQbHdmdC9vbUsrdGNweEgwL2p1ZXdWRHlBNWZVRWhTdFdPb2YwSmdqZkJPa25WS3RNKzNCVWkrWTlqUkhxdkdKaENBOGgxR0xHbEo5NlJDcm0yVllBSHY3eWJPNmtlUVd4aVpNU28vZHZRTVBBMERPSEQ3Mkwzb0FyM0tQRkE1K2RHZmR1U3Z5QjJRdGFqSXdQcXpxejFaeTVHM0kzejF1MkFlK1IvaGhYN1hqK2t4V1pUbWVoaXNJM1VYVDJveFJ2V0FBMU1udWdyWFpKb295TytGSjhMVTZzek9OVkZYTXZUM2VYb0xHK0Naenp4cU8vUVBEVjcwR0l3SSsrVkh6Z3pPRmI5LzlFUDl6NEJoMFQ0V2kwYi85WElLZGdUWU5HSDJ6ZmZmbFppYlRpK01aeG8xZldhL1RwN25jdVhyOHN2YjFqTGQzN05mSGFMS1V5czdXU3ZhL3V3T2VjbXdyTHgveDBLZksxSTE5aGtOajIyV0d4YmE1c3g2WStJa0x6NmxaQzgzVDBYU0VqSGl6RnhHd2dtR2d6bG1JU2pxSWJ2OXhGdCszZkZwZmNGaDJ1eEY5ZDdvZjhkVmZpZXhmT0grT3ZzL2NTSGVBU2xYdHEvaWUrb21nQWREU0pGbHNtRmZSdHNHZVVGQVVPelhSL24rLytmdVpmQXdjSzd6M3JST2w0ZlV6SGlaM2RyTkJ4WGRzNjBrWE5KRG92cWlkK08veU1Ea01wSWVVQ2tYbndnR01BNllHbEthRDlTRTR3a042QTkydEltYUJPUHFpVElWbUJZUko2SXg4ZFRaSVMwZUd4NkkzSllPTXQ4SjBRVXZiZ2UvTHhySk9Rdlc1ZDJYYUZuemZFYytHZ2RMMVRKVkt4cnI4cUtTYzNCbnhqb0g1dGc0K016ZFJsNHVEcFZXSk14eHNrMFAvYjREaXdZVG1xQXA0c1JkMVE5K1hnQ1lwY3pqZUhvOTIxM2RGd3Buc2F2QTB2MHY3RTRmNjhoL3ZqeGFWWDBoLzYxa3JDQVF5VWZ4TXVSMWliRFk0RUh5MTBQeXh3Lzc0UXp1T3J1NGE0SDhCSS9rM1Nmbi9jL2dpNjlyTDJwMnV5TW43dEZDQTFkUnAwNk8zMEZ0bExNekV6enlCR0VmT3YvTlN5SjN4djF5bis4NXljdnNLdnVUM3crN2FqVDhCRGFUcmVPOGtjZmhkeEIrR0dPTDJZckpQZlNCQURFWkxCdzh1WDBXSFFWb3I0SnlUWGNBUzNsVlkraXhjVkh3NjA2clpNV25vd3hvaTA4WERBZU5IeHp4ZDBMam44N25iMDNWV3B6NGUzRmd0NjFjYWdmYkdKMkhXd2xBRGFvVU5mZkNGTi83dE5ydlNBeW56d0duVFJPVXZ3bEJYVnlBbVJCaVVZU09RRVZZWjVqSnVueG9IVTNpQmwzT2xvS1JvM2NjVmRIZHdaUHB6aEhTamZ3SStsMm5BVlRrZEc5S0tTU0N4TlkxMUwrZnljSFBxN2JPRTk4SkY0bWhPNGFnNUtqcXpPUXVMUVVEMDlKWnVGQXdMTVBod294QWhXZ2M4bUU4cG4yc0JINDMrSDYvR1BSWkhaV0xBYys0blFFZE9DVkc0RzYwRTQ3a0c0WDJWQ2pHb0g0S1Z3Nm84T2wyVFhwTlVmaTVTeC9tbitNTjhScmlQbHpoQi94UXNkcHlQd2pxb2t4a05QMGVNd09aZWQwRlViS3Y0aEsyQVdKVXpiTEluRStNbklQTi9PejZmUkoxT0xEZ0QrMjBkdnpwMjZjelNVN3BVYy9NWS8wUDFzeHRrYXYyLy9hR0ptcCtyZDh2WXNYbDB5ZDl6c2FYMkFOUEhrNGJmZEQrcVB6T2cyc2QvdGhVTjdqbUd5MVNaTWZ5VXBETlBmR0c2d2htT0ZhT1ZvUDQ4TjcyRjQ0b24zM2VrYndETjNSckZaejh5cWVBZ1V4S3BrSUVJMjlRYVlFb2c0SVJsTTBkU2RKRWpmbmlyWWwrRS8xRjUzejdpUHZwMjRaZFBVZFluVk5rL1lWQVRLSDZOYi9YdHRsOExjOWo2RDBUbmt2Z1Q0S1FPUnBkK1luMDlUdkJpSTEvTXp2SjVSWEF1Tkw4eFBTOU05a012aFJZbFZvTkVSUXE1YXZrdnQwQmsyU3lqV1Z5QVdFSWdCVEdHMFJIQ0Exb0xEdzZINGJNZU4zLys0N253b3dCRUhDdC9admF2VC9JblM2dlBBK212S0E1QjJlYTgwYzhNLzc2ZDg4RGVkNnpHNGYxL0ljejFBUTNsQ3REUHE1eUdvZVdnejJybisxNGtPTmxLVEhaNW1GdHNBNWVpUFRCUFRkTWRjUDUyL0s3Tmd1RS9kdDEvLzhMcDlVOUc0RGFuVlYwOHMyZ3hEQUE4eUIvU0VNLy81ZVZQM3ZpRHU4ZW1maC9VRnJuN2o4WXpUY2ZURjR5akY4eHlLeDlGVk13N1BmZVAwNWFnQjI5ZnFhYUV5NkVVY1g0KytpL0hVcUVJalYrS1kvNEtZR1htTUpwWTQ0aXFxY3dFOUJyNG5QcjdqRmo0c3lpdXFaMnQ4Yk5tY2trQUlKKzB5Z3hvL1pmNE1hcnN1NTBhOSsxZVRCcTgyYThlN0w2d1RveGVmSURqU0hBL2dvRlNUczNEek9lS0hlMjdlZy9GTjhITVVJTmlvTTJ2QVV1Y0Fvbm4vUmk1NVdQMG1sby9zRXF0WFU2S1VwNUVIVzhnRGg5Y0h4RTdDZVlHeHhLVVhxRzNDU0dLNlFrdUpPU2todzhhOE42cWpqR2lIZng0OHVIMWxYSXVFd0RCYi9LQmhBQ0xFWHgxVXROM3A0ejFZTWt6Skt4cmtxc2IyOEJqVWp2K2E0bjBxTjYyUzlkQ05qd29aUHZKTkJMNkpZSGhGN2Q1K09nT2QweEpCdDNTRW5ueFpLUG5DdWx4aUtjRzZhcFZnWGFhczV4T2ZqYTNDbmVPQmdUZk92TDRuTXlEbjdzV09qdVl4elpaMEx0cWF1U2Z2b3h2MkxSZ1hVNUxYVEN6YXhuQXhwKy8rc2k4Ly95TXBMaWMyN3ZDMithLzJBdkYvZkhSdmVEYjRxNThkdVpqTVVJVFp5RGQ0YndWekhiZ0srYW5TbmFXallsUTVvZ0lFYjVRVkJqOGR2U0pFQ3RQZkJCTXo4Vk9OTmJSdWlYM3Z1L2FGa3lidlRNWks2NHlCSTcrODVjNkJteHpyWm94d0Uyb0t1ZjI0VTFYeE4rWnJxZUFnSVZvcDR6azBJNjRlTmRadG1RaXltZkdGSUFpb1dvRC9FeHFBdW52d21wY3ZSdTFBS200L0VJKzRUU1VqcGszNmFhVWt2T1k2bFRQSTZEQlZ2TXRFM2dWMHE1WmhvaDZNMUMxTG9qT2kvSTMxekwyRzVKTWVsSTNhZmNqSE8wZjBtV3dYVm9JR08rajhiOGJ6VCtLVUFoU0tvTVlwcWJUWHowUEE4clRUZURFN3pYOWxsdG42aHQwK0RheFlCRkVXdU1rdmdJSHUzNlV3Vno5d1drUmg3aU1pa3k4cTFrQnIzd3J4bUhUWnZvV25GNFBTMzJHTlJ5ckUreWxSaWFsNGZqS1ZHeW9jKzNtTVJiZTE2STBhQlFraWlEWEthUkRvZHZQUjI4TmpxUFdiSXB6RkErMUM5Q2dJZU44NisrMVRkbGROUHpSei8zSDc0bWtMMXdhQmlVdW5GcjRaUFZGb2NMRC9NUHZrc1ROKyt0MjlBRTc4Wk9jNzh3MFJrcnNBVGp6OTFveFJiaStoZ2JKZnJ1RXhxdnZseFdOVUdHZUZBNDNGV0ZCdm1PQnA0ZlBzT2VtdGwyK2Q0b21PSS9hRjA2ZHRUckFMRGQ0Zk11cktIZmNvdU9LOTlYTkd1LzFKandnZEkvR0NZYmhQeE01VGozdCs0eXAycm44MThnUVR2c0ZGVVo4eGh5a09NVkpnWmtKTUZtWXNCbDI5QmlSVWR2VWI5TXgrNHUzZEp6L1lzK2NFclBtSUJCazlpdnNOWFFMcHZ4MHZKK0ZGY1VjSndUM0taQ1EwUUJCeHZ6eGxKTjI2NjZpTGo1YnUvTi9LU0FUakxaWEtTT0szcDhidXJXdlBDYXk3Rjh0STloMUZFOWNrVmQ4d2J0TjJLaU4xNytTK0pINnpwL2NnSWlOZEJNTHJmZDEvOThwOThKSE1Ld2J3RitXeERQaFB2SUtPMHVlNW5mcS95aUNaeE96NEFobGt6TzY2ZnNNS01uZU5wakpJM3JvYTFkZThyc2dnMmQwM1AwdUN0Yks2RWhua2ZrNFBHTlFySDVWZFV1ZzkzSUxIWWVTYVZUSUtHb3FnM0tpMlVuOGRFM2Y2K0xNUU1KQXMwM1dMbWUwOXVLeFgvdklZKzJ1QjFxSlJsdFFBTExNVmpuR2JoUVlsZmtQeURBS2pFY093RExRSnZ6K1pHMWtKUmxScTUzRkdCV0Jwd1E5Zi9odUxqek00SGdPK3lPeFRWeU9OcWxIT3pMQk9jWVJQbXJyOXc2T2Y3M3YzYXhHT1dUTjkxcXo4dDA1OWNMM2t6UGNTSEcwb3RzOWNEWUxiajYyYThzYTBLWHNQelpkNnpjNXYzMjVRWXVxYjArZnRQajVUR2o5OExCMWpVdmw5bUM5bVlWbXBuMFlQVjhaSWcxeVVHOVhxREl3YWhWQWYvVVFFYkMrOUdoUmNpZ1Z2d25kSURKWXE1eEVkaUxBOEUrajk2NjhkbWtWbFZnMks3cDQ2dHZEWU1URUwzUi9rYmpxOGx5ajE4ZzlZdGhHZUdnVE10Sy9yOFhwY3dZUWttR3RiQ1Q1UUxxL2NxSllWM1E1bC9GL1AvQlBsdnNpbXBVekNpZm5CZFJ6MnZSL2E1MDJadnkzV1ByeTQvOUNmbjhEWDNRdlA3cHMwZ29kbFozRmZhbURhK2hIdWk5NjI1RmNaTDlUWmxvQnFXd0tYRTZRa2tEUUY1UXhBUTZhQXdNSkNQclhzTEtPVGdIdUo0OFRUK0Vadlg2cVVKVkg3a2s3MCs4LzJKZHlMWUZzd3ZUSWRucnEyNTFXWGJEOE4vYW1PVlBQTUZIUW05emVybFBaZ0tEbzdCZlEvZFFwZWR5ZWVQUXV2bDUyRmQ0NGRjMWVoSFFWY2JUd1BKZmk3cjlKUEhmN28rbG01WFlueklmcURVNkxtSmF4NEV4dU0wNXVURkV1UGFsb0NmNERFSldnNW1MWUlmWW8rWFFJSzBmTEZjRHA0ei8zUWZRMThobXd3R1FhenVVdkFzdko1T25lTksrRXd1dW1pQytWRFdKMVhDRUdOUUQyZnc3SUlGV3NWY1luYTR6NVBra0RydVNnbFplNE1jNk9BQUw4TXY0Nzk0dXFqZm5OQTRneCtkVm40NlBYZTRoQW9qdW14UXFoQis5TWJ6OUYraWl1dEtzSGJ5bTFSSFB6dmJGSHdwR3MvWE9TZXp3Zm01UFRrSncvdGhkL1hBbzJFNjZYR1hEU1hSS05LT0t2VGl3dGtYa1pkY0ovRjRNV29vMndlejZDSkEzUi9Sb0VLOHptYyt1NkcvQWtUOGplOEcxRTR2azkyZHArQzZXaGs1c08zYjA5YU1HenU1RHQ3SDJWbVZUKy85TTdvYlluSjIwZmRYbm9tQmZmQmlmNEFsaGZHSVJQYkY3RGs1S0EvcEJOc3pieHhuL3RyK2h4dGRZWkcwejZIV3JXRTAybXdoTExnb0NhQTlwVjFuYXdQNmF2TlREVjN5ZUJkYU84M2VIQy84WVVSaHpmbUZSVGtiWGdYSFU4NXMvUjIzcmFxQ2R2eTd5dzdWejByODlIZU81UG1EVnN3NmZiYkR6TkpINWFDM2NJOVBwZ0x4MWp0OUE3bFV4MmhldUxtVjRyM0Z5SHNXajAzdk5RUmJxWEJlZ1JQcUc1blRtYWFuc3pLNzIyYjJITjV6MmFqNm1XOU5yQm9jbytWdlpxT3FOOWhKTHd6NDNqcnJMb1pFNGNFempyY3RuMTkyL1JCbUhjdlIyK0FHSXdyUktkSVVXZE9DVkJ6OG5SamtLQjhTUlAxck1tSUNySGJmWmNzUVcvd2wwRVNzU1ZPS3ZmbGZ4S1R1QVJ1T1BjOFNhZUJISjcyRWw5cUwvR2xFV2krbWxRZWg1bm1LdUZyaVBaUkJIbFVIRldaVllXazVDUlJ3NG8rWjRmYVZ0b1VIQjRCaFMvZnRKLzQ3T0w3OXFJTFBGOWhYVm53WWRBUGR5d2crWHJLTlpBYzl1MTEwNmViVkNzTG9MbFlhVFRuUkpiZGRSWjJoZHpxYktCZXBjNDRpZXh3UjV6VmFZMGpFWGx4eEVrY3R6UU9abXZkUnc3L1VrY2NEV1FKb1JsWUlaNXltd1VqRjlsK3RpWWdJeG5QT0svbjA4RnhackRBWUt2RkExY1huMWF0REpjdStIN3BQSGFjNS9NVzJLY3U5d1Vmd3BtT0VSODJ5OGtKL01udXlBWFZQcjEzNlIxcDFRTEhablExbDhodW84cC9GUHNMdjlOSTB5VE95WnN4RnZLNnVGQXkyeldmNTJESmhtUVdJSnFabkNuckY1a1dGZzFrc0Jpd3FJd2w1b3c2UkdBV1JuUTZOM3JNdWF3TjNUWTNhdGF5Mlo1dXV6dCtPR0w0aDFsdmQ5L2JwRVd6QnR1N2wvME5Jajg1Q3lMUmoyYy9RVC9PYVp1VjlVcFI5NjJkVDQvTysvVFZ2VDNlZnZtVmRpL3Y3M25nMVhOalJwN3V0S01Ibkh3RlhRYTFybndGYXFJdlZEL1NDcnozUTdteGJIMUM4WktFNmp4OG51NFFaMkF3bityay9NamVMZ2tNamdtRzJZNWdpb2ZCK3ZnUHFkUVpHMGdEMndsSHc5SkdnT2FQUHJJTEhLK1BXYzNnSVA4RE50Z2Y3Rm1JNm9QWFVSK3dFL1VwWUFsd1lDeXF2eERlZ0YrNFRia0hjdEY3b0JYK2dJL3dPbXhXNlplQkM5UHZRNUswQWtRK0ZkTWdreTJjN0x6TmRyc2QvY0h6TGpmL0NmeExqdTB6Q2YweGp0cTRsdHdDbG1taTZJams5eGFhRlhjNHlWTFgwc3JDWnpzc3h1TEcyakJoUytNWHVRNmQ2VFE5N25EMTlQcnByNlRqbjZZYmkrdG8vaHhWSjUxbHp6bXFsVDZmUTZlTjNZZEtWTGFjVmllN0dqMWt6c1JhSUpsbVNlSHZGaG9GS2ZTZk5McGZ2L0t2djBJM1JaaDN1Mmo3MGZWWEh2OHlmbmp2bm9DN2N2TWZBZVlkMzduZnVlcjdwN2ZkZjFackhaTTN0dWhKZkpPbzEyZThEUTRNV2h4WGUvR0lYU2MrKzFhQys0c1dqeGx1Yjl5NGVQZWdKZkhwaTEvYmV2cldlV254OFNXangwNW8rdEx1T2Q1bXY0QUozY2ROYU9FVDVPMC92dXZJcVV4LzNDWUc4NG55dW1UU3BCc3JoNlYvSXR1SW1oelJadDRrL21PemRFQVNzcHQ1WjBuOXBURlNvU1RrT3lDUmZ2QzJGY25XVGR5L0g2Vys4NDRZdkduVEp0emlpUEw3NGwvaWFTNktxODVsa0loTXNtUTE4WkxWVk5EVmhtOXNoTGJFYVdJc2ErTHRxY2s2RWVLU3FkSnNkZm9teHpIVHFOUG9TMHdDeGNHYVg1SEFPTTJ2b2dSZnhvcXBNVHFwTWRDUkZjcmE4Rm9sTXU4OHZmS2E3MEl2S094Y3VlYnc0VFVyZHdtd3oramhvNmRNSGpOaXBPdERNQW9JQUlBeGFBVkN5SVZXZGdORm9CcElCa1ZvSVBvR1hVV0RZRmRwZGRGWDd4VHN1MUwwcHBRL2V2Y00rK3lkSThmTlFmZFFJWmdCU01oeElacUI3b09Hd0lFNm9UUG9OTW1ESW5sRHNBVCtUV080VWptN3hxOUNrRnVxRVM2SDQ4U1N5R0t1bEVnZ3NrdkZqMzdnZlg5NHBOOFV2MFYrZkxhenZSOTQzcW5pVjVsVHhjOVluT1NSNmFmbTlQMG5kd3BjNE8wTEV5ZDNLWmhadFByd3ExbDljd1pEY2NlOHlTdjlBdERHVnJOQ0RnMTRMUXQrR0o1WkphUGxwT0d2ald2Y0xidGRhMjlwME15bGM5RFp0RjQxT3JlM3J1eFFyM2xyR2g4K21kdkdOK1AzR3BQNFZvR2MwY0MzQWkwbzNac0Nadko3ZUM5T0pMNHVVWitZQW5TOG1uaTc5dGpkN2ZrYVlDYW9NaHkzS2VlR0JVbFkyOFhrazh2RnVQZ0h4a1ZmckpuVjVocHliMVFTSzZHNEQ0b0Q5Um1tWmcxZWhYdFRhMFM0MVJuSlV6VTEwbHJDUlJvalliWXpMRHhTamptTkpUR25OczJ2NG0wMDVqVGM2RWlsS1VFTmRibW9Hc1RUZnYrWHVJdGtKVWNvVjhhL3pSai9yaEg4NndaR0F4NUFNSnBpcUJ1dEFKY0dBYml5NkpVV0xScDVlZWY2Q08xN0hUK1VOYUx2NjF2Z05UMFNna1llU09wRUcvbFhwMDFxTVRnNmZIaTdldFdhbTQzbXppbDF1N2J0MDdsTnQ3WTAzMHZNNHIwbzdUQnltRzVvcytpSU1NMTcwWml2cklHRXppemx2NFFUTUg2VCtjL3dtUHRBNVhmRjNpK2NlQ1ZsbDZuc21abzhucVhMY2dZdlhUSWtaMW52WHMxZjZ0SGpwZWE5aEF1NXExYmxEbHU2YkdpTG5qMWJ0T2pURjcrL0c1Y21DTUpqL1A1QXJnSHRMWlk4OWNIN1pEdG9BNFdGUUJwRERJMXlGcFMzUnlJanpUQWNDT1lqKzJnMENCU05CdHRkNy9Ndjg0MXowQ3ZnM1J4d3VLd3hpZGZBdURnQmJvQUh4STlOUEw4RFQ4VUdKZk5CaWF0UFM4Y3dyOE9sOEl4NEZzUHN4RERyRlpocUdLWWFoYUY1cmNmQk5mRXM5ZUVLVnBJaTZTd1VDRUdvOE9GeUJ6aml3K1Zpc0xoRGZiZ2tGUis4dkpML1o2UjRWa0l1dXErMm9RSDhGMVNmNjFlSkhWT25hMVBQam85VysvU01tZE9LaFU2L1FLSUFPWU84QWhueDFkZ0FHR0VoQmpvUXZtVGlndFZWN0VOOTB6YU82dmxHelFLaGdYdmVwVzBGWTNpaDdPeUdibjBhTlhjL0ZiL0IvWHdWNjNteE5ENnNLbGZSdGVkaXZRSEh0QzY4TVBGRUpHc0lUSERQOEh2SURmaDd0NkVYNEQrL0JNUm5uWmhldEF2bWdaZjRxZ3hub1ZWUFI3QzgvOUtHRFRDdmhNRU9RaDBBeVN3STVKcDY1SXVxdjNKNHFiaHIwT0F1UnF3QUxlN2FaQ2tobWNrSG1YLzVaUTBzV21ub1BibkxzQ2pNVHJ2MEdkV3hjY1A2TmIwS0tiNzBnT3RBVC9FTXhvWHQ1ZVZ3bllJTFNyWW14Z1hLTC9nQU9iNnZnWDQvT1gycXlLbnl6bGdTQVAzdmx0OFg1N3JQTzdCcWxlUEF5amNkSTBlTkhEb21iOWl3TWNLRVZjZU9yUnIzNXRHamI0NllQV2Y0dUdGejV3N0QvWjJKNlhjSFNyOWJSeEg2M1JyMHBPUFl3bkhpZStKcFl6Sy9uV3NEMStMUFY0QVhYaXdEdndzZTRMam54eVgvNWh6OXpTdFl4dlpTZm90L3M0T1BxUGlORWlGR2Y3T0k0NlNGNHNmME4xZm9iM2J4MHprTy8yWW5GMTZ4M3hyaDN6UlM1bThrbXNEbkNBMXBua3NIRHU5RkNrS3pXNGhleUpraTVkelAvNXllNnBuZEVnQllHanpCZk9ZTHB6bnlXTllqVlNaZ0k1amFkOVNnZVlYamw4RThDTC9lV1hKKzl1VEdWWXdMRjhKZHM0WjF6Vjh6VnMxdW1mUDU2M1d5QjRBM04rQXgwdndMUTBKUUV0NExKTi9xWlV5ayszUGUzRUUvWGhTdzZNeXBNREVxekFUd0JlaEZZSXk4b0lleEtUQ2dHM2NUWkJPWUFNR2puZG9xVEIvdUN3eUhZUUk5WVNUMVhjTzVnNkE3M2lrSC9VVU13NHB4MEpRdUZYYVkybDR2MEFpc0pyQm0waStpODBZeVdMd3VKbzR6eE9BOUg4aUZjTHNxaVpxclBPaWJGMlExM3ZtSUIvbUhZM2dyMzVUbjh6MEMvSjArbkM0elFHTzNKTTcyQVAwKzBkb2t2SWltN293S0F2bk94dmhTY2lIb2VoRG0rS240TzBsTzVra21DK1lNd2ZRZmlPT1REWVlZMXlXVGUrK1BLL2g4Zm9DN3JRVjJjTDhiQVU4ODJ3Y0RFcVJBTUFkTkp0SDd0M0xkMjhCeXZHRnFrSG1halZxU3ZCQThUMGtZMFEzY0pIQzcvRy84bk9ZOTBMV3Z4dGFlKzBOWmUwbFpEd1lUbzhKTUFBNWw3VDFnYkFvTVh0TmpiTzJOZ2dlTXBMWXpuRnZHMXRVb1loaUhrZVgvMG5VdGY0cUpaRGJ0VnczV3IvTDFyRjhDRDVYMnp1TkZ0ZEorTVpnSlhIZldMNjhLR0I3RDFLTDlxc0g2VlQ2WTlVc1NlQm1tL0JzTWswMzd4ZG9aWGw2UDljdEx4TzJRQlJKVkhNTFNvM0FmNHhDaGphLzlTNmE3VStCRVdiWG9MNUE0ZDNMSkVqelNNUUpLUFNNeFJCMFJKVGJnQ0NVa1FjMXlDWTVUMDF6d3R4dnIxbFhrdWxSRis1UmtGMVFLdXNMaVhMaE96WG1CeGU0U09lZkYvWm04SG8vb1hreG5leEdFS1h0UlhUTWE2MjJvaDJGcXk3UWhIWXdqTUZWNEh6MU1IUlZtQW5nRVJoT1lXRStZTmdvTWZzOHpNSmJBUkFzZU1LMVZtRDdjSXpDY3dNUjR3a1NxN3hyT1hRSWp5RnJGaWhqR0VjdHlsaGlQemVZZThXZUZYbGd1QytXY2dnK2Y2Z1Erc3J2WGg5a2x2VUdtTnlBZWJHK1FEWExSVzFtZ08raVJoZDRDdVZsb1Bkb0FtbUNkckY4bnRJMWUwTW9zTUJLdFl2bGlVOHIzQ1QrSjMzUGhYQ0tldmE2VlJIYXJ3WE8xTk90cDFNVS9PNk5yeFpQK3hNVFhJaDhwN0NPVlBtVGg4VFEwaTlwTjhRMTEzUkZ1TDRhRXhnREFmSFp4bU9jbkFHSzlWSUxtKzI1K2FjQ3dXZDE3azlEdlVVZGZHVEJzL3N0dFhBRU42MG53OVFZYitwZit6RTlPVFpiY0syMnpPaWl4OU5hYUc3N3MrblExalFWdjNtVGp6YTYzWmo2Y2NLb1o0TjMxRzZQdkhnemMzZGdWV0swNkN3dkhhMEJqaE9uZXJDZmpSQ08yTjRONEwyV2RHRXlNQ2pNQlBHTjdNOVFUeHFiQWdHNUFaSHN6VlBDQWtkUjJoblBmc0wwWkttSVlSeWp4V1NtOGdNYXBHc0l3YkNQNW5mdkJxNlE5Zjk1QTI4UDc5MTBNMDRibW9wdVZTaEs2Q0dkRkRzV1NudzlMTDNSNisxQXU3VTFsZW8xem5SaDdBblFxcnBJaVFNVDRZQ1dyRDFoQml4dC8vMzBESGJmYlFZdjlEc2QrMFlGSzc3NTc5RWQwSEg4YjRWNXlwSERtVVlLdmEvQlkyNGcvYzhta21vSm9mWjRucWM1K2I1TkljMHUxdGlTUnlndVlmbFQxeUR4U2RCdHpDR2ZXeFpQVXdSS3RVakFDQk5vLzI3dm95R1NROSszRzdvZVM0NnV2YkRWMU9WbzJ6ZDVoNG5LaHdhZTNOeThkOVZYSDd1ak84blhiclhFNU1lbjIvb05CNUx6c2E2LzJmWDF2RVo1N0dyc3Azc1p6MzBMbUk5dXc5SVBudm9ZUXJxd2xnN21wd2t3QUE3Z3dBcFBtQ2ZPSERDT0JiaU9xRUloYUlvUGdLbUIrVjJINkRBZ2hNTmJuWWM0b01OendabWFDTldrR0RPTklNenBxbG1yZUp5VXJmY0k0ZWc3cmN4Z3lnL1RKa1dGME5KVHBDVS95cktSSlFrZXVGbGVmYTg0ZHJpUkNOUWJmeFB4MzRhck10cUlQVjNYK2hyOVhIclBxckVMalc1MEpYQXcxR2RJUVBrMm9sOE5LSTFodGVqbXlBVFVyTnRYSDhpV3BkaGhibk40T3cyelJ1aGkvUkpwOXgvTDdsWEEvNGZjM0xqWkt2N0g1N2FPM3Z3TFN0Q256Tm8yRzRxMzNwaFJYYTN4eTdDZTMzQUVIRHcvZDFNemFxTmpWTnZka1ZlVGFzR3NtditpTmZmNFE1bTh3ajhudE1lMnQ1VVdIZXM1ZE1UZkhUM3JqME1paGcvUCt2am9rNnVTdkw5WHRrZGx4eUlnbUlIYkphd1B6K1hVWE5vb3hLNDZ4OVJ5SVdwSllVcnhPcldUNXBUZVZYMmpzSThXN05qTGVIV0o0RnlzWUZKeGlNRGRWbUFuZ2RZWjNWVDFoL3BCaE1ONU5vM2dYTHhvcWNJckJuRkZndU9GZEtFNVZOV0FZUjFXakk0N2hWUGxaV2pQdlV3ejNXSlpkWHVPOHFPeWl5aHpjT2d5RHhFOWtHSW1ia0FpcDVDSkE5WDNscEhDUlcveFdhUWZMTHJVNWljb3VvaXE3dklXSldnM1JvYjVyZUxtQmFwVUh2UXpQeVM2RE1YMnBLVDdFTW5NYU41SERDb25ldSt0dmlKUlIwdXhQdnBYVU1EY3lZMGswSnBMVXlYQ0dtQW5tT2FOajZCMFhFazAralA3VUkyeUpEcEdWbFFpS2hsb1hpTUhEQlFKQ2c1Um9JQnBTYXNIc0xWbE1KclpyVEpjc2lSYStUbElHYzgwUkxBeks0QnVOR1lkK3ZWU0svZ1RDTjhPY2RZV2dJZTNScDdWQlRNM0JkWk03ekswUGdHMHVTQ3BadVAvb2h6dUxQaGFEN2VqQTlaNS9vbk1nNlB4OUVOenBaWEhXeFN4SDJ4MXg5U3pEb3R0YlY3WjFmZW1kNk5OKzJFK09ONy9qeXMvaXRhQ3hWK0p2ZUE0N3kzTEhMQzZZekxORlZIVWJHZ3NsZm85aFhwWHg3QndYUmVXZ2lqVmxNRGRVbUFsZ0htZGh1T2dCODdzQ2crV2dGVmlTSkhLUTZBSHptd3JUaDV2SCtoUGpDWE5haHNHNE9EU0VTa0VHWGlzRjhSaFR2eFJxQ1N1b0RkNlh5K1FPOG9BVFVta1pCOVhPWUZDL2NVYUg3L1BtQjJaeVN5UWlLUDRuMUhKRjhEK2gza3Z3ZjNEMnVHZGJYTTIzTVByWXAzeWNFQ2FjME10RU9uKytFdDJwazRuME9XSE9LSjFNVkYwdkV3WExLR05qWmtzdVFSR1FpSDNCWXF0RUppSXhabzFHcG1WbDUvVEpRV1ZYTXdmWDdKZzllTWdvZTZ1WEpEQ2phamZybmhQd1lyUDZFcG9lMXlGMTkwa2FleFlldHZWU20xK1drZmd6YzhpVzg2MStYNU4zUEpNUE5sc1FPcHBiVXQvMWg4a0VTSEljclZWQzRsem9YdThwNDhYSGJLK0hWTkFXQnZPSkNqTUJ6T0hvYmcvemhQbFdnY0Y0c1l6dDlURFJBOFlodytBMXo2RTdQWXpTbnpBU3Y4emdhRXdGZlY5ZitYMHZzL2RGQ0NHS0hMUVZEUkM4OVhrR1ZQUjVjWjdCLzdNWXVzcnpETHhaREoyOTdsdGpLdytoTXh4eFQrL1IvN2tZT25XOERubThlRjRTNkx4RUdQQm9IUkZHaDZWVVkxZVFucWwyaFh6dUNtaExkVjFSMU1zZlIxVzVJWCtJTjVWaUpJMXN3V3dPVFZTYlF3L3VMbGpDZEYyUGR0eXFqTkpqWEFjcTZXaGxsRmhrRjgyMDMxVUpUd085K1hGTWRrRjJIbEZlMTRJOWg5bjBPYTN0UVBXc0pIbGQ3ekk5SzQ3M1ZkNUxjeTRvRFdvbHcvUm5OQ2hlQ0ZSZ1dEdHRsSFl3cnYzQmRMRll3YU9kMytWMk1EOGNUcWxVckJoWTBYL1dUcnphVGs5d1hOYnBSSTkyTGlqOXdUQjFGSHJuMForMmFqdmRnY0IwekhqUC9qeFcrOU45U2hUano1ciswSG9TaGd3TWs4emE0WTR5dlNSY0FFbzdZL0M3SGtoaHhpU3VOYlhpNWZKbnhLR0tGYThxUnUycUlYSzlvUDlCMStlWnJzOWJXY2tjV2kwbmk4ZTZ2dFlERUZpWnJoK3UyekwvWCtuNkxOZEZtSTMzZXppZW0za2FUMytsKzEwWEVhN0tCeUdoWkw4N1Fxek93QkNRcll1VUJxVk93VUNwZ1NtQXBwaUVHQjFocFlUMVIybXRIUjY2Q1FraVo3a3dqWUdjSFVNaUFHeG1HOUNGcFFxemkrVzBHSm9qZzA2RFJnWEZyc0VWS1RMQ3ZUSUxTNDB4czF3WjBDWDMzRG1YUTVzb285aWY2UDZ2SnUvL0VyYi8vVVZKTHdjZVZXVzgvQUs2LytNa2d4N1BldEg5WDAzZS82ZVYvZS9Samx1Uk9USE1QSTVTZ0tvVjlKeTE0NisyMHhQTVlmcnZjLzM1VkcybkoyakRWV0U3c2FJZFpDZTFTMWc3aEY2QVRreGVSU1VrTDRqOWxqNy9pMnVrdmpkRGZXOTM3ak8yVDB5ZS9YK2l2cmM3NWtmUkh2Mm50VUVvSFVtUjZVZ1oyLzhKRmZZYW1ndEQ2VWhiR1dZRzIvKzFLbVFaMWs0WHRaMGVlUDl2SnpDSm51MjQxSFo2Y0c5dzdSbEY5V2duWG0ybkp6akQraE1uZXJSelFXMm5KMmpIK2xORDB3NnFTV3Flc0hhTW1FYUFzK2dUNWJkU1orVzNmQ0dldFFZZWZhQTFScWhOSTFXMmFVUW9kbEIxM21odURMVzd0WlBuSkFQMHhWVEdHVVlDYTVxR2tkUVBRbi9DT1U0Y2h1bFBNS2JnbFZXVFZCSUJuRWJxR3NQU1ZVbWdNY1lJcVJ2Zm81QUFYOHAwQVdjSTlaL2hYYXdyTm1taHhTYXBCWmFFNndScDZqRGlmNFFnMGRvbFJBNFVMcTllVFNxWUxGMUthcGk0T3ZDTlhLZUZ3UVBMRUNsbklzQ0JvQU02Q0RxNHV5SWxkNWovRzlPZFNLSnhrRTZINFU2SEtWU0hrdE5LTSt6VWNnS1JZU0p6aFRzREl3bFpqY1JrVlJ0OUNjVWcyZTRSb0RPNWt3eENySStFc296MzU1TWdTSTZYelJ3SDU2QUQydXloRFJ2c29MTndENjNWNXhBSjl6QkJJZnJXQ2J3d1BlamFNWHR5bi9LZXpHWnFFQldiYy9saURKTkVlZkJqR1Fiekl3OFlyQ1BDSVpRV01adHpmbmxmUm91RUNwZzNNWXhOM0tucWR2bmxxZVYvRWhoUlVtR2VZcGk2bEJheC92UW9IOGxva2FKSnl1OFN4YnRxZjNxVU44U2FnTGRzMzJZNCtUS3lnd1dVaHVCMmpCTG8vVE9qZGFINGVWK0oyTlRhcytleVB2NEpYdHorbEhheDkvYmtVaG1laTNLYmVPMzM0RXNzalkvVTV2dDRta2ZrZko5WXU1MkdLZU8ycjVYZkY2K0xEaVByaTRHckNWUG84LzJvSFhSUjN0MmVQdThBUHFmUE8rQjlQOThRaGZ0U1U5NXo3NFBXcEMvQkt0OHZYNFIvSzRubmc1S0FySGVWTnl4L1FtMldJbGRCUit1VDJqYTRuVnJ5dnArS3ZzVFBONk9HSkpjS1ArOG9QNDlEWHhOZk45N3JrYmpUQVVybWhzNjlyY1B0RitSWWlaQUYzNVNRbUNmSXF1SDhWL2xXT3haTW5EZ1hIRnNJVVZVWXdDOER2eUdqMEFERmd1OUU5OS91YXhLYngySlNCMGY2RHZmYkt2dEhHb01JTW1hZkNwL2Rab3diZ3FFdmhzbVNZVkxCYWc4ZnlrblVrTlRUWWUzUThVOUdYeFBmTEdwSThyblliOG56OGovcGM3bitqdkplREg5QVZMMnJTdmtDdVg3amZ2eitWK2lhWnNtdzhSWHlHSjNQRUJYV28xMU11ejl5NzhGYUVvYWp2bHJTVm9lS3R2RGZ3OTJIeU44bEs0MXhzR0JhVkVibE9ia1dpSzVNZmtWaE9jbVBXWDRKR2ZVSTQrQkpvcVV1V3BXWHF6OVMzYm1VRlo5TE5JdTBxSlloSXhNdldTcW9qejRtZFlVMmJyVHoxaUdqaHJpMzU4Q042YVBTNFc3bXA0akFsMzh3amZURi9PQjVUVXhUUmRmblgvdFZTcUlzT1JKTFF1djVnRXd6b1hPc0Q2MmR6b0xEaHd2NHZxMUd0WEtiNEtuV28xckRYNVE1ZlVUdDlPbHMvV0hZYzc0OVpoKzVvZGhIc0U0eGkra1VZWUtneFpGSGRHM1NaUno1anVKQ0VkNDcxNmdNMGxsKzNrN0ZrVWRVQmttWFpmNk01MlFROXQ3SHFsMm1PN2VGMlZ6Q1ZMdE0rVzhFUmpJck1CZ0hCNHM1Q3Y0b3ZFYXUvM2tZdFJQdTR2VVB3M3JpODVaL1hXQ3ltai96WElKS3BibWJJVFFLT1ZCbU54NjV0bXBaSmVIdTFxVXhkYUlDQXB1WWV3eHluU2IxbFJwSm91T2ZweVIvYzdEa00zTmNMK0VHS0tzcU9zcmlnWENEOW5rVGxqbStFanBpTGIzWGY4b0xWSktjS3FMRmFiS0VFRVZjQlVFNnA2Slc3OURrQ09xelRUWDVnajRaQndvY1I3WXVqVzhRRzJCc0dkNXp3TUxwVXpkV3hRVDd5TUFSVis2NFE4Z0Fob28rVThmQisrK3RuempVOVV4b29QcnFBbFZmWFQ3M21LMXhsUXA1ak5teGpxZzJzM3h1SWJPZlJFbXFUTVhhNmFMNkJYdGdJWDg3MDFjOTJuR3BOck1lM0FZbUg4YUtIdTBNVU52cEMvcGgrVENRT3hoRC9KU09HSkpCcmNqNHREM0pXMjJ2TC9jWGxtRUlMTEhsYVdCSnZFZjVmVU1zclRtY3lDMnBwT3FpVG1qVFpkYW9Mb0pBbldib0RHWXBJTUZXcHpVWWM0UVFuV1NqaytzRXZiL1kxNlBVWkhXYUVpT1gxUXUxcUJVSXhRcnR5aFFTWkloMWJScTQrSlZINkN0US9WRzc5VjM1ZnFRdUlhbFJXSmJiZkZiRFJqTmJmUERkRHo2K29EM3dCbW5BQzNUdzg4NTEzOGgxN3dneGVBbS9HYnpRM3oraWkzZlFuNWpUOThOekVZUHhsWnd4VVorYldZa05VSmVZUjcwbnlteFE3d216TE1Xd2toN2V6Q0JOWENJYUJIWldpYUVtcHlTYTc2NHhManZTcWZXNTduUDVwNVY1TnBSaXFwNUpxYXFib3grUXJxNjQzckRoMTRWeVhZTk45ZW8wUGpaajRmV0dEYjVaSmllc25qaTVaODhKb1lqV09waTRrMW9QbHhkT1hha3BkckIwMnJTbG5sbXM0QmdyZ0lEeGpOYllvdlEzUTZhdE94bjlyY2J6R2pvSTM2WDB0NXZNbzI4eSttc1cvQldZNDVqK2xvb0hXRHVVem82aWRIWWlha3J5TXRsdktZOStnTDVSMzV1aHZCZlQxZy9aM3F4ZVlhdWVROS83V0g2dkJMcTdLZlVORmYwcmRHRmFYNHZhcE9ySy9YK0gyYVJxOE41S096UTNrL2EvdXd6ekN1dC9EVUdGWWUyMFVkckJNdlZScHJ1bENCN3QvQzYzSTRGdVhhbm1saUo2YS9xRFdwSjZYNndkNmlkNmkvcUpocUUySkQrVS9aWStiMUZlcHI2M3JmcmU3dHdGWm51cTRmbmV4K3A3dStkR01ZMVI4OTZhS0lQVTQ4SXdtZkw4RDBPbCtIa1NTaWM1bS9oNUQvYWMreEo5U3VCSi9TNURHb09uN3owT2VsUGR2NEwva1h6UGVWS0VrZjZXeWtZRHhPRUtiNk9uczFUd05xVWVXS0JTL2J2U2lueDRaL25JV2YwZVp4NzU2R1BRL0dsQmlZQlNXZktVNjB1VEVvbjhuUHQyVkE0QXFSeUdmTyt6Y3RPNVlGdHVMdXFIK3hHQysyd1hzekMvbWw1SmppRmxVYnI0ei8rUW8rcVVnb0hjWWEyNkdxeXJDa0VxY0Z0b2g4TUpSWEJFbGpxcXFGbXNwTlBQWjdJcTJhd2dHdDNXWkxSKzlwbWMwNHFlNXFKMzFMUlc4R291OEI0RXpHbzhRbTAxWnFFUDk0enBmMlpSeFJkbXA3K2gydkw3a0ozRS9FbjZ1QWFxLzlXVCtSNWkrbCt3WnpzN1ZiOUJQcmVBNlg5bXlhQnJoK3AvOVdUZUdNRDBQMDBNQld2bnJ0cWZIdHc2cHY5cGZBdXNuV0ZxTzczQVlCWkhGMG5pTllnbUhhZnlSdG9lMWt1VTlucHh2M0pOQ1d3VXNYR1FkT2tFRlphMTIwNXR0eTk0RGV1SjJuYk4ybllGSDJwejZpbnozQ2RZZXRlMmE2bG9GOWxKblRyV0xyVnRGYk0yOEhNL29RRnJnOXJPUjlEbnRBWWN0Y3Mwa0hYRUcweGZqUkRNeWh6UVBGN3FnK2t0dzNSbVBwZ0lVWVZoTVNZMWxCZ1R2UFpIOE42bCsxYWRiK2FQK0ZieFI0QnVIWFd0Vk1TcVNPVnFyTXB3YmpISVlqR09YaXpHMFVjZEs2MlBSbmxFWTVsK2JtTThJb0JYMTQvbXJWS2ZUN1lNMDRINWZBSXE3RTZzSFgrbEhhd2ZGYkE1OEJVOTJqbXN0SU5oNHRrY2FHQllPeGxxTzkyNWs0eDNCQW9lN2R5VTI4RTBjemlWNmdKVmZ6bzdNd2ZtU0RYeHFMdlFNM2wwTnZYZlNNQmNuZ0R5blp3QXhwWlloYVlDVnBCSlRIcUpRL2hBZ1BuT05QTEhMUVJzQUlsVUY1NnJDcTB0NFdNMjdhYkZlNHpoYWJHRFJncFhTZG1lQVpLaE1LK01GTzBCNVdkUU8vZzI3a3NDdDRweldLd1ZjcjlDcmVMeFRieE90eWNPc1hoOTNUalI2Qkg0U2RRQ1U2a3p6NEs3T3NCQ0toU1JTNkdGRkNleU5MWGdFVzBoRDlMdzMwc2NsZzhzcERpUkJZd2xPV2JSSHFaeXZYRCtmSWtpRyt6NVpPdlM2Tm94QVlHTlFuc01MQ2xoeFlyQ2E4Y1BHdmFFdjFwMmFmY2hiNS9Cb3UrTThVSzZ0bXdSazJFWGx0OFhYVkp2S3NOMjVSeEc2Nzh3RVgvR1JQeXRPc0VVYzVCSW5WN3NVZW16b3RnckZjZm9RVi9Sd094UnZmUlBiZG5YQlRmYUwxaGlkMnl0bXZTaTRxL0QrbmtmM0h6aVRuaWJ2ZjJlcndGTFpQaHJ3bFZsVE42VlZKZFNqc1Z3U2lHOHpHZjhkWHJkdjQ1SmxTM2x3Ynk0eXNuUS9VMUg1ZVV0bVZNdHBiSmlKKzFhK0M2ZnV2cG9XSXNkZlNzdmVrTHJja28ycVM3V1FWN1Z4NFlGYUpWVXovTnVuQ0NBWXpZRC9ZbUdIcFhWZ0ptT2dXUUJWMUs5VTVvOEt4L3lwdy9ycW5oZWhBSEZhOFFQN3BqZDJSN2xQR250QjhFbEhNTzZlcTZhamFuekw5Rmo1cDRyQjZJTHY0dXdVQnlMMEpWSGRCcDhBcDZ2MDhNUzhReEtHb2kyUEFRZGwvQVU4cXVXRC9mUjFvbVErdlVWam9scjl3VzRObnBVakpnQ3ZXYU9aL0UzeEdab0lMNFgyV2JZdmJ4RCtWL1V0MS9odTZTK1lDODFkcDUvQjdRQjh6a3pwdlkwL2p5QzFrV1BJTWMxYWVQTjFEZzUvaDN1SzY0MWdXL0FrM2l6QmtZU3lJV3Z6V1I0R3JOT2FmOTgyVDVUeG1oL2VJVjloc2FsVVZxN1I0Ylp5T0tiV2xmRTFkRjRWVU0yaGxrdncvQmdEWUdweXhzcmRPaHhXSWNtZk9zOW1ZZTA1MElwVElWTzBCOGxhK1ZyTEpOT1FCOVMrVHBGSzEvajV5WjBoc3JGbmJWeU1aYTdOM0FDbFlzN3dLMFZjakYrYnFCMEdNODVTQkVhWUo1US9VWDJEZy9qeS9ObHNrREtsaVhSZGFMOWpVM01QUVlvOWJFdzVaczVUbGpKNnVVOVVPdmw5YW5rTGFySDA4L0FzUVJJRDg4dDFzOE5jc2tIclM3dTV4bnpvTlE5U21vTTVFZzdRM0lUZW1oT01sRkV3ZDhYZ0Q5NmN2eVRPOUI5ZWxQK3BreGJvL2RXekNveFF2ZThuVUpIOU9WUG1mZFE2Yk12Y3FNTy9kMjBRWmVtN1YzOHVmVmkxSkwzNlZvSnRZRkpDZ3VXK0hvVm1TdEtqUzlaSjlnaTNJRVh4Szg1TDY0aHBucVV4VUphVmtRTitDazVhYmhrZ05uTnZBTXhrbGtOVFExQ3RqUExBUElkZkdsSks3NDdUMCt6TVNja0d4SXlNbTN3UXQ3dVhhTi9HQ1Q4RmJSbmova0c0K0h6OFR2ZWs5L0JzWGR3cFNXdmNMMDRtRTllQlNwZUJTNEIraW9RQTZ5Z0tTQ3ZJcWZjTUZ1bHpXeElTTTZ3Z2EyN1hyODM4T2V4WXMyM1ROOS9iMkx2V0NpOEE4OVQzU2FJdktEWUQzcnNmVzBGZTNnYUN1dm56Tmtnd242OUIvYkxGaDFTM3FMRlk2UU8vUWEwby9ZMDBRdlVvWG1GNGZxOHdzT0ZjQ25jREZseFV0eVJPbXZXaUY1N0tHL2NLeXdBejhUTE5MOHdtZklSczZxdThPbzNiMk5Gc3VHTE13cjNEbTdWWXREQWxxMEhkY3hJU3JUWkVwTXl4Qm90QitJSGZmdTJUcTVqcTFZdG95NGRjeDlrQjFzeDN3b20rYW5CMW9wc2FYMTVyemcxRzhpaUhwZ0orclJwbjJTTFRROExpMzRsdmYyZzNPeEdBK3JGMUEwSzZCSWMzcXRUNi9rWnRQMWM0UkVzRjIvZzloTXcwZVd3WWtpTEZ4RGpzVVM5Z0R5VlhmeFpmRFhMNGFxb2xrRW51bnowcTIzWDE3VTI2elN5eTBzN01tbzFGOC8xSERlNlZkMmc3dU5IdDhrazh6Wlh1TU9IaXIvUzgzMlRuYnczbjBxUHFGUjFQVFdYa05pdWVUa0owbVlCQ2NrOFNTMU1ock9XUTNRMUg4Yk00Zi9NNWNWZkplU1NnSUN2SXBOWmpxQ040R3I1RHJvdWpUbEhtRlc3R21wMnVZWHpObnJIZXFkNU4vUHU1RDNBTzg5N3V2Y3k3eTNldnRtRU12Tk0vN0M4WUxXT2RHL1VvR3VYaG8yN3RVbU5pYTVlUFRvbTlYYjlEaDNxWjdacmx4bWVXRFVpcW1wVkVxSVpJSnhBb2FJTDQ1U1oxZlJWM3UwTTVBRXJkbXREb2YzZm1pYWNBRTB3L0JiaEpOb2h1aG04ZGtLY2dSeUZ0L0VKcUlaOVgwL1JUV2lyNjREd3FMeU5lQU5yTTMxY3IzQjBUN2hIQ1pmUmVxa1gzaE9zOG9pNnBZdTlOTG5CTEgzUkdTQm5NWUlNZGpSU3BuemVxbnRwN3c3anVobm1GdzNxQ0lUTFU2V1VXdW0xT3ZUTGF0dk8wQVRQcnl0RHVJUE9xT3ZueFpIMTg2STB4RXNUSjNnNDBEZkcxK3FMVjVGRW1oTG5WS1lOWC9sTW03c1U1cU9yY0Rsdzg3bC84bk9FWCtqcWxZbjRTc2Z3R2pxRHVQSlJlQjRTS09Hb1dMMEtGTW5qcG5QTE9HVlhJbTdOR25SbUQ4YmZEL0ErM2kxMS90YzVCQUhydHJTV09xTjNNZFIyTVl5M1NodmtPTWk2N0F4UVBURnM1bHRvV0dyWWJEaGdPR2tRczhrd0RkU2w0MnNsSGg3aVkxS0tFV1RhOFBpc216ZWprQzFiTnIwenFhY1l0bmJ0MnZ2WEsyTE1Pc3N4WFJJWUlqSWRUczRORFphNGlmaUJSUEpEaWMrcS9BbUdmMS9xWWt6aXFnMGgrdXFROGpvY1pIeGY3RUNmcDhyUE85UG5XRzhFaDZUT3hEY3FQeDlJMjIrSVphNW45SG50RVBaOE1pZjdrTVZvK3J3UmcwZGZVZmlleFA1SG5vTzVJYlNmYTVuTTR5aS9EeHRKWGJETXM1cktQRG5sL3VWSGlId1NRdUxIaUtQRFJNdXRSR3BqNmpCL2w4aDRaYi9PUEhxZlNPbk1NWHlmVE0vaXFQRnZKenNKUm4yTmFWYWtYa2gyK3hid0kybUJlZ2ZiOHpYeGVQcktOU1VxTysxRU9aUEFvNnEyWFB3OHpwc2VDQ1hCN3M4K2g4TlFFLzRIRkNHUmc2RHd2MFBDdTBwc0RPMS90UXJkbTk0M1ZzZDNqOTZueW5sQTdDd01ua1pTRm5JVndtNkFwelFCYVlRVU9US1hITDVXY2dDZWhFU2pKYWV4SFNDWExFaE83OEZjQ0xLVDJVb3V3VnNRZWlTTTZhTXNEWjRTUjF4R25QZ3ZwMnJ3WjkxZnd4U3NKNzN3YkkwZE9Ydis0K2thMUVmUHpxckI4MUJEblpkZjZUMDdUNG1jRGZvRFBaOGc3Yjg5MFl0c1Jucm9Zd0l0dVpZQVYwdW85bFFZT2hhR1RoSDVaMjZ5VHNxN3lMa3MrRjFwNnJzZjBmdDB1aVpZZkJmOFpCenh4U3Y0Zkg1M3BYVzhSRmJ4VkxRNnJTSXBPaVNTb2tQaVVoRm02ODRjOXRJZFJzVUtmSkhrVEhMRSszaCtqZXUxQWZDaXUzWTNmcXhyU1U0T2I4emxwVnpGOTRUbFpvbjRudVN6VzM2aDgxUC92ODFFSlo1bnFHUCtMRG9uVHZpbHdQVlJnWkNxN2hONVRsYlJPYkhSOXpYRjk3V283N3RKSmZPaDVxcHBjVTBzOVJnckxTWHZUWkpSTTd3QnNRWWJBRHlKUXZsZUxoTVUzQzcraU9zQkJEZmhYWGRoYmpaY0QvdG01NHJ1czRxdG0vWWxzOEwyUmU4YjBmWHFoZmQwZjNvK1F6U1dyL3BVVWlkS1ZRdURRcWhhR0VTa1RLZXZUNGhjenRwUTZnalNlYjRjb2ZSME0wMnRSbW83QkxaWXpoekN4U1dZRXpJU1lra0NRcHd0d3hZT2xKSVhOT2VnSVREeEZnZ0FhSW1Pb1hKb0J3aWg5OEhMQUFLNzhOWFR2NytjZXVYcFgxZUI4QVJkdXZzTHVuVHFGTEQrOGpPb2ZSemRkSzE5L05FSGZ6dytkZm8zZmhpbHlld2NCenpPaHF6bUNCNm5OeDVudUhLYWlrNW5wODVxM1hsQ3p4VmVDdlVMWWxYV1NBUkFxRDRaelVjdVZrdlZYNDY0YlpNNHBncGJzQ0lNbjBrSGI5clJqUWNUNzZFNzlxc0hwSW5nQXZSKzhDRk1jNWYraGI0THdEcytPeERFUGlIM3ArNzdRdjVIM0Y4Nzd2OXhUTnNTbEJxT1N0VVlmU3kvdGdZQVNXZ3RKZTQ2cmJYZVJJekhKTGlNbUlVVHlibmtNbEV5Qmxrd0xzV1JzbVBFUDhtWnpDR1FGT3lDRDVjZCsrSGtCOStmWEluU1FlcnNyYURhYjQ5QTZ0YVp3SXJTeDVGS01rTEJJeENQYmo0cVFHWG9jdHE0bk42ZzFlWHhJQktUcTYzb3AvR2ZvNk85Yy82WHZONy8wUjVMWW1rblNhbVlSeTZoUEhJSUdJZmZSV0lhaFRCRlR4NVIvaXYvbzVTQ1lWYklNQ25sMXhpTWF0OHZRZ1A1cjJnN3EyU1lscXlkMElxNGlzT1VINGZLL0JqejZXZG5XR1NUSnU1NVEvbDkvakhsMmRzb1RFNG55ckVqQkU2SmZ5ZlhPTlZmVGZ1UDlkOHFXSGJNclVUL3Baam9XWFpPbDRCSTlwYldMaE5nSWpWb25KSDBneHhOSGVaNVBLN3BPYityR3ZTYnFZLzI1UzlucFBsWkFrMld0TWhPZmYwejNoNUh3bjdIN3NrSWNFL1pWRFIrYldySzJuRkZtNFVHcnF2RHVnaEN0cjlQOXJEK3VVcms3NGhCUjkxblR0K2ZuZysyakZ2SlN0UGk4UmFqZktFNXh1TVFQTjVCcW0xVEp6YW9XeXpGajZyOEtkYmk2bG92VlBVVU1yNUFqa1lHY1hxcm9OL3pCeXhyenQybU9ROTE2Z2FyUjNQTENRK0UzR1RBVjQ5OC8xcS9OMWI5Zlg3QTBTYjJQL2VzV2JwbTRiUzlOUStPM3VvOHNIR3BlT2JLV3prN2F5YWZlK09UNzE5cWhrVHg4RHUvdWNjdW01VzMwem5YOWZFcjNmYXRXblNJbkd0WEErUFJSN1N1WjNvbHE2blVJNndnOUNRc3hKdVhBOHZrNDFsSWxWRys5UlNVYjBkNVUwQktncFFrTkNqN0VUVUhKNFJJMTFlRmhXbzlhRXEvVXJoaGxjaGVGRHM4aTBPVDJkSkd0QWswcjlZWnlwSnF3NmpuTVVwSExEd3dCN01aUWFrZlRjc1R5aWxqR2J4aVpXV1ZIREhtbExoLzVURjFhTWRzclA5YzhxdHBoQzB1alFzaHh0WUZYYUk3UiswNUlUcUdpUHZRcU91eW5UWHVXNURzTDRoU3N4V3RzMTE5WmF2cnNwc05ESDZ5M1pYdVk2RWRIbkZCSlhXRmFRa2RnalpoMWJ4WmZhYVNNV0dGWVRDL3BIL1ltREFpeDVGcVRkcERFUG13OEJkVmkzTlVNeGJINm00cHdRelduQ2F0S2ZmV0VKalZ3NlNKNlZiQXFEWmk3SmhCSTM4NGMraHZFWTQ2Tkh2TjJ1WHJqeDdkdlBudHRTdU9qSVlpZW5yNHpGK2crc0JaMGZHRkhWZHNmbXV1MUdmODJKNTljNGZrREI4d2Z0WkFhZU11b2xlOWd2TDRUWGlONldsbGdaWHNGSm8xUUUzTDBXUUZkUldFT1kvb0UyQUcxRDdSa0d5SkFFQ01YNHpOSm1YZ2RRVEpjUm44SmpSdTZtdkxGcmVhdVFDczZsT3p5Y2oyWFR1OWY2YmdEZENGZDdjUUhhOGdmc012azhZdkh6MTAwSWFFSHVIRFd0UnJkR25kT0JEekZ0Z3E1bEtlU21uby8xQTMzY2VEa3YydmRkTVBGQlMvYTE4NGZjcUdSTHZRNE4wQkl5N2ZLN3NvcEwrM2NXS3U2eW1yQjh4emMvRStNZEw2T2NUQ09PL2YvUEVCekpVU2dIV0NBS0lUQkp3TUlEcEJBTllFTGdYY0NvQllOUWdncWdGNVVCaXdsUHpSU3FwV0J3YUFzWjdsNmdQMG9VRFBaV0FaQ2RNTnAwUTN5Q1FxcWIraUhCS1RJUmdmZmZYbEg3OTkrZFh2cmwvaCtyM2J0NzBOMTd0ejkyM0RueGxZSlNnRjZWZ2ZhSW4vMVVZWDBkM1g1MzMzKysvZlBaeDI4ODhudDJoc0hlRlRRdjBYMkczVjJxWENpNWxDaGduVWF0OHlvbGFWOFBqV0taUHRRbjNYdGVIZHZMeDdCUVVzM3N6SEV6NG54OXRpZWVvWlhmdTY1WDhLN2NWZk1hNWlHZC9mcXRQLzZJMTZvRFFFOUtCemY5M3BwNlJZbXNhQjVZeGhXYThQWWx3eHhFN3BGMU1scGtaTW94Z2hQeTNkbGdCWXRWaUN3b1JuMGVSQ2xaM3hDWVpqYzhDbXhySGRXdnFrR01XQWVpRUZVNVBBYTlFZGJQNHhBWUp2allEY2dwcS9TL0ZDMU5iK0l3VFlYL0JlUDlyVnNOZHJQSjhqR0JaUGd2TmVaM3hjcnAyRngxZEE3K1c2MWZpK0Z4M3ZZRFNVdjQzM1ppMXVSQ1hVbDNKdEJiMWo4VTFzSmRUWE8xYXVaYUNUNjJQMUdlZEpQcFNZQVpZbHI5Q1poaFZmUEhaenhZSDNtUWtaL09MN0RzZmVJN05tblh2NC9RbmJrcFYwVzQ5NnRWZm1QWFI1MzhieE16cTJSYUlqZDBuK2FQdlFZc2VLQStORzluOHpycWRsNEV0Tm12OXdkdDNGbE1TVjJUMW5Wcyt0aU1FVE91THh2MHJIM3huZlg4Q2J6S0xFdUZCYTlGdzRpWmFmRXlsWnF6Q2JhR1Z0UDgvejB6MkxuYk9raHppaDl5WU5SaUtMZmFYZ3pYL2hicXJpSlR6dXFzbC9NUlR6eGlJMFFPRGxPdjVaR2l2QWY1TkMrVC9rVGliWENhckluVlJFQ1lILzVsVGUyL1hzQVB6NS9xVTc5cUpOUlJ0VDFyKythU3RObmV6VXp2ME4vOVQ3RnlCZ3BiL3NFaENmYkVGSGUrYmNQODFzNjJOUUR2ODVqZGZyV01tK3BRV0lsVjdUaUNPR1UwUTM1UFRWNDZzWVBRcHk2eXRpa29yNEtzNGtzMExEc0xIampnQkhiSnV4eTNINi9UV0x3WnQ5YWpZZDJTdm5ZZmsvUXNjTFRtbjJPblFreGZsTHNDbDNXUDlWOFQzQ0JqWnIyTkFuRElUOWtISVAyQlI1WkFUR0J5T2U4N2IvY3NJVWlhN1VIektsYzF3SDZzUTVZa1JSUGJrazd5NHpEcWlDUmlyaFo4SUk5UEdvaWVpZnI3R01BY1NyME9ZYXhyeTVZTS83L0JjdGYxZ1dkeHQ5UVdTTEgwRXljRitXaFFySFgrQ3ZBMnpPTytCOWZRNzNXMzkybzU4SGN2emIyWTM4T1ZSZ1IzUDRLZnlYcmhyOGwvTFpqVlFQb0xYMzZsYXlscnI2N2dyN3E0d2dCMlVrd1dRYkVWOEoyb1VERUx4dDRhN1ZzRW5HelBUNm45ODQvNTNRd0wzanMxTlk5VjhHVFBPbmx1LzlHNVgrQ1RqWW04cmErU2hlRE1COUNNTlV1U2M5WGUrNWp1aldTRFgrcUxJVjZWV29adHpoRk5WaTliaEZ0SGdSejBWVlNLaU9UWUxta0NDczV3WVRCVGdKQmdMNDVDZFFCejFDVCszb1NYbTdsMmEyNm5UOGM4a3VuZjhDL25oWUVocWcwNy9mUUJkTktBTmNDQUtaVDdZL21UZ1QvVFAvR1BySEgvSTNYYkhRRiswOUN2d0V5T2ExR2VvbTFCRmF2dUQ4R1YyQmVGMU5RNm91RTJFN0xKeFdTUkFNVkV2eUVxaVdwSTloYzBhR0NiSnVvUk9oZ2pHekNTYWw3WU05T0E1SUFMektrdGFQbnB5K1hBSTFwNkpGVjJ3TjAveGpBbm5mMU1DK281dThMYUdTUXZEbUNXdWJsLzFxK29vQm1VTExaYU5STVd6dXprQkJyM1VYNEZEUk1IRXBtTzJld1h1Qmd6bTlCVGhZOENKam5vaGFpajU0SGFPVXVIT2R6MTRYeDZmTGVxR0lwVXlBRWppdlU1Y2dzZFd3a3cxTWxycEJHVmlVSjhobXBPdVp4SVVEMldZQkgwblh6c0MyeldZMWJJbWVvZnNGajlFVCt5V25oT1dDZU9nSFFqK2VVVGJsOVhzYmtCc2REMFE5d1Z0Qm9BWklCUGVRK2ZGVFg4amZJR09ZWFg1ZjZvWEhVSTNyL1NMYTV2Y2NiVk5DZlVpM05jS0MwNGVMWi9YZGlIOHNzTlFaRTg4eEJVcUNCbnBJdVJKM29OOCs4bGx2Uk54ZDI2WUxYTEo4K3RxSmEyWXNXd3E3dEpuNWN0YUZNek9jMWFvWFR6OTd2bU1Mb2NGODlHalpxWEx1MUdlZ0t2b1c3ekR1MUZKZ1dvQjMyQlAwNll5Wk0yZUFPay8yQXNEcyt1OWhlYXN4OGFzek96MDN2RHlNMWYwSU1haDJlcDE5Z01KdVkvbnhmU2hrcE1ITUl2Q1UvSGdXODU2cXhyd1BBYTh3ZTBSTWhmK2YyUnBDNWJZSVRPUHlNeXpIV28yUm8vTk9ZWFl4R1BnYWc2a2hWRlBxRDh6Qjc1cUJaZVFJam1SdUtCRlh1ckI1RlhzNFhxTStCdm15c21yYStDaGlqa2pRN3BwRWtuZVJWRld1ekd3MkdXbFlqaWtUTDFBd1JTNG0rOEtKSjc2NGlYN2ZPMi9KRG5UbndmZm9vZjNUVDAvdkUvdjM3VDZreXgvZlZmVXErNkRKdmt2bmk5M1gwVjlZL20yRTRFbm9idm9sNHQ5ZGRrS0VZUG04aFcvTUp6RUxWN0JjT2xFOHhpVW81M0RyS3Y5UzFIb3VyNFRYVzFiTnBjNjR3Q29Nb1ppRXljSzZERlE3MTRtZTVDUVEzczgycVh0MDNWQ0xUM3hJV2xZaXVtdEhkNUk3V3MyeFBwYlFqT2h1aytxY3FDcFZGYTVNR1JiZzEwLzBhZEROdmNyOUZ1d0ZoM2RyNENQMjh3c1lOZ1Yxejh1ajlMb2VYcXRFdkVkQ3NiUTVxSkpUQjNTSHM5RmpmTWlOV2M5Qkk0bFU1ZlR4Tjh0QkVTbWF2OFdWT2hQTlZQcE9wQjQwejQxQlpNWTRUTW1TcVN0YnQ1R2t4RjNWclVlY0UzY25WOXRwUC9odXJaUTE0c016TUtPV3E0YzFZOHJVZ2tVVEYwMmNQSlgvWXVDMXVZL1JoV21GaGROQXh1TTUxd1lOZFY4WmQydk1tTzllWjN2Skh6MG1lNm44ZjZsMVdFbU5RaE90VVdoU2F4UlMvZU9wV0lUbDhTcmNFSzVDMzFDV21oSk1YVG9PdWNFNlI0UStjVjYwUkRLM0E4RmlyVVZYOUl4eVltbXNnamxFc2tJOFRRd3I1TU9jMTdyUDlYN241WitCeitNN0lpZytCTTRWdDkvYjFZNDZrT09kM1hkaXF0MjllL1FwRDN1ZldIbXdPRG5HM1pDZDk0ekhTLzF6Skw0STVNc3hQMit6K0NJbFJ4Q1BjMUg1QTZGRVBJczUrdFJLc2x0VTk0UXZqUmp3MVI5WkdFWnJwWlBDMVZsaFdKSHRIMGFjS21GTEZkdUlzNUE4UFlBdnVsSUlnaTc4a1RpRzRxaDVXeEx3UGlhdUxUd05Ga01DTmZ2UXd4a1o1bVFLVGhpTWZ2M3BNZm9hcER6K0dSaURZVjdZdVNNbjc4TCs3cTEzVHg0NWJ3R2ZTTmZMUUg5Z2VRaEN3Y0MvYmttSFBrQlg3emJPNmZBTHVuYjgyUDlmend0LzNsLzNQOW5HTzJDYVgweC9XNVBTakRvYzUyV2xaMGJFY0htVm5CcWhlQVowTXAwVGVJZks2WXVodWtoZGtxbXVuVDZnbno1dmo2ckNtaUo3Y2J3UFNBVVptRkpFQXFDVTJ4TnVnMUUvbHJudW9FajN4V0RUQjArckp4NVlaYkx3MFdCVXlhSERCMFdIdStpWDk5Ly9CVytLTDFBN3REWUhWQVBMNEVwM2ZmZVU5OTZZYzR6Wmk0L2o4WkVZb1NBdVVzbGkwSGxxRkNMdTVBS0Q1RXErL1RtQzE5eFNqdUExUi9MVU9aQlA1QnhJMHdMOVNwMkNIMlNNeTdNY3JLQzM0dmpwU0N2ZDlUYk5rR2txb1ZwYTBNWTNMZ0NqZm5wVzlpT3E0dnFvb0lBdkljTThWTUtiNEdiMy9OdEhqdjRJOTdtNzRrSEh1OWM2NXM0b1puUXJrOGE1TzdBZS9Xb2xxNmZMZGxTdHVCNTZOS0Zib1N6eDN1cFJCTEd5Wkh0Q29kYTVML1U5TlBUUm4vYURSd2NlN1dkSHJTbHB1aGtlK2NVRE5CaHNPcm9sTXR6ZDVQOFE5eWJ3TVYzdi8vZzk1eTZUUkphWlRCWkJaQmxKRUUxSUpDbHFYMnBwQkcxdEVZa2xzWXZZTWdoQkxhWDJwYWdTYlZGTE1SbkVXdFRXRnRVb1NwVlNXa3RwYVlzV21aUC9XZTY5Yys5a2FEK2Z6L2YzK3ZmenlUVno1OXh6bjdNOTUzbk84enp2UitWTDFKNU0vUjdqWkw2MGh2RWxzek4ybWNXUVluNE9QbWY4SFBSUitMbnFpOStBbkJtUStBandqUno3OEQyTGoxQ3hrTEJ5aG9wb1hLaWFGMHQzcnFJelhPdlVGVFgvb1Vza3JwZlI2WDVFY29DYjZCQ1NidGlmandjTTFiR2lDT0p3SUhaNDJna1ZnVDRWL0Nqd0hOeU92MXRsbk1yT2JyaXVDcFpReWFpSFEvQ3N4SndNWG94VUdhR1pVczZsRStid0JrTnZQWDEyRTFYamg1TFBPN2R2MzRrSDZkNFArL2IvaUdkUnVHTnA4YXkzdGxidzgxRDJFZktkN0NPWS9yYW9TSHdiMCsvN0hQcFZMZGNKUXdab09KODJVSldhZFlreldpWGQ3R05wR1V3V1BqRVpyM3dDUytFRkRDU29zVEQzMmJiQlBuMWYvOUJZaGJlOFgxYmtOek9EYitiNGd2UXgvanZlRmN3QkdkRDc2VTYrS2JxQlhoOGovS3pCYzFGOFBsaWN1UFFidFVmUGRMTUhVQ0ZJWi9KNHNWZURhc3ltU0IzUWh5RjEyT09OeE1jQVgvU0o1MHZ0WnM3STFFUGlkV1FrSGtoeUVKYUZwVlpMWkRnQW5zQWk5RitidnhINUxZZWh5SE1CT0ZtY3Z3V2NYSUE4WVBYbGNKZWpIZjE3QUE4NWhtSCtSdjZhT1l4cy9mZkNhNklmM3VOVW00YVNDVURQc0VNOGE3SjBGQ1ZwSVpraHVTRTgzcjVEQ0x3UnZ1aWdSLzl6bTRhUzIwYTcwekdMbU9wNkYyaUppU2Fiby9EYTdBbHpGcURMZDc1Q1owV1krOTNtZzkrZStIemJ0c043UGp1dzhsd3VsRUNWVTNlQWoxQnYyTGJZR1B1TUkxY3VucFRtN040d2YrWENBVXRtemxpN1lacGt1L3lON0c5eG42N3hsbTdXdUZ2bkVKZGhwSWRla2p3ZUpJTm1ERWtuWkFvV3JQbjVVdGxSZkNFT0tpU0FPMUswUGFzQm5IUHJQdVUvbjh2eFdZa0tWcENIbG85cGZXZHE0ZS9YcWI5cjJ4ZDRPT21QdURoOTlqTlhKeFdhNzBPelhRclhyWTU1WnQvTmwycEZMWjNvRTB4ZG9NaVcrQnBhSm0rSnovR3pVWDJmWEgxYTVOOS9vVHhnVWtVZmxISVo1NHVXajJZeGsxcS9FTnh1eXF2cHVtdnNSby9TT1lTbzBEZi9QaGNnN05sVUFtdm1PTTYrc21oUjhDdGVYdDVKQVYxejRwTWMzODJDU3hiejI1NjFMVmhvRVByd1FuYnZJVUlDeC9CZWo0cWJ4SHV5WDBvcVI1VC9nSGlORHdybVdDRGU3czNjVUx5cEc0b2hudXpnV3IrVHloVjhVNnEvMEJPRmZJNEZrZVJYNG9tU1VoVjRnRTdJaHY2dU9xNEsxa08zZzQ3QXM4cTQwQ3NBb1BJcnRxdW9ISERYcW9qVjBKNG5UOUd1OCtmQnEwK2ZnSGFsNkdSWlcrQngvaXp3UUkvUG5rZFArZDFzUHJyNnBKU2dEOFRoMUMrb2hTWmVVOGZyWEhjNFFKT1dRTXFmZkRTT29HeXJvMUJCaVR5ZWJpWDVmQ09ZUDlkejJMTURaTGVEWXJ1bnUxQkR2RVBMdWFDRlpSVGJxSm1iM1lFZW83bXVSN3NmcEh1Ylg3ejJZSWJOYmRmSUQyR1pOZnZBMEFkL1d1MTdjbzcxSjlNYkxnOE4vZVpYc0JnTjIxc1VHZ3J0bUFiY0paS044b1EyYnRhWmJ2SlJOZGpWRzhuRlc0cktwaVpsdHdkMVlUc3JmTlg2MUVQZTZ1bDJqOStHMzRzK01EU202N3ZyZi9SZUphckgxVXZMczlUbWkyVk01emc0NmFBRG9kSXkxM1A0a3o4MDVKU2dSb0E0WG5Hdy9ER1dDZGZLOHNZYmJxaFNkd1hveVRFQmc3QWNyUmdQWHd5T3pic1ZPYnhnSDBYaVFNSGtNNVU0Ykk0WlZPSm83NWdoU3h4MFBXSVpRL3lONW13aGlGaTkzT3pOT2tGV2QzU2g3c0Njd1pQSjdEcmlEYTVwNWxWYThacFVwRzBpZWljcTVGb1pyWHlhMWNvbjYrVWpSMTNhcDZvTVIraHQ0WVphWjE3Vi81Nm1XRmQ2WEdnaGErMERyTDkvU2ZYM1REZSttT3JSUkVYbFBZU21RaU1KcVZ6My9PZG82T2FZYU9iSFJRN2NsSjNkbjBTL1JDUXhrOVVHS0lMd3UzK0FXSFQrajkvUURSR08rUGJBZ2R1TzkySC8yd2NPZk12ZmtjNERpSXJRTDcraU8raUR2eTlMeFVkQjlKMCtPVFh2Z0pxZmxlQSt2VkIrVi9vQ3l5NkJuSVY3M3czbjBDbHFPa1F4Wi9naUU1RjlzTlpHb0xlMytSejB3VnFibncvSXN4ZVNTeHE1WENVL0Zmck1KejhSaEc3N05ueFhaL0R5ZDBWdmRMRlJ5RzY0VkdQRGJOR2RPNjcwaGVLSWkzNjNXb0ZmUlhkY05kb3h4VEVRRDJwcTUrZjY1T0srNllQblcxUEt5NE1VenVJMnE1R09pZUh0eTROdFgxcXJpeDNTOUk1RWp0Q3Q0a1FMWUtjV1ZKMEJEQmc4TWVMNkZOQnovcnRBdWdYMlcxRlBzQjd0MzNWd3h4cVFBL1Bqajg4cnZZbTU3K3Z3citKVkMreE9iSFpxMTIzRjZNYjdmblhKUlAzUk9tcnlWd1ZVWENjbVdkOG0yVUhzVldnVWxzNTd5T0FLTVpuZ3I1cnlqRnlLRXVYb0N3ekJUVUN3bXF5UDJQWmdwek1POVBUaWQ4U285K095aWIyaHNLMTQ1ZmxBb2VHUmZocytQYkJ4dzRHRC9CL293Ym1JRytoSEVINTlGV2dBSnRVSWZxMmQ5SFplc1BuYUlURXRLL3RhVWNTMjMzN2JGdkhCRDR4ZmJjVGpVWW5pZ3dWai9lNU5OM2dJeW9qb2dzc3FHd0U3TXRObERQUHdxOHlNOG5yN1VLSXpqUnZoRFNwampZcGdvUjRSRzhIY0U5ZXkwd2RQdWJBSHJRUHBNeFl2blliL2paKzlZT1Z5OUl2UWNPR0MxeWRWQzVpZnNYZ0YrQU9OSE5pMzUrRCtzRTlHbnd6Q056N0NqV2lDNmRmNzdsZUFOSFB2dTg4M2NWeXh3cFg4MmJLWG1GOE01SkxRWWFFRDdROVZKOVRWcUhxSmFIVkFqdXFBRWsxdnEyNXhaTXNUWEhSQ1BMZ3A1Z2g1eDdQd3hDNkRkNXEzdXVaVThvZUZJenlIbDUwZDVBbm1lR1oxZ0YzUmtPeWh2ejRDTTh0aVVRWm9nZzZEajJESGMraDZMejdiaWZOTzUyZGJLcXRVdy90T0dmVTdtS1h4NWZIVzdzcTZYT1p1UWQ5MCtxQnlObXczUWVvQVlNSWMxb1FaVHFZcDF3UXJhSVFCTEJWVUFJM09vdG1obkJwaGpFNGxORmo0Q3d1czg5R0loVHc0aElZdkJQMFdXaGVCZm92UlVQQVp2d2c4Uk43a1Q0UjFvQ2VLQXQrVFA4ZGp4M21SNllYOXkzL2pQNlMrYm4wMGVxRXJQS1BPVlNURUpPdUl6MWNJWDZ3QjZtTDNLbXFBeEh6RHordmJjOENnRzNzM1BNSDYzNllwYzViUFhieHUzYnpDR2UrTVdUY2NTcitzMzFQS1YwbWJGRmw5YXQ4bEgzKzhVc3FhTnJyUGtMNEQrMlgwSERHMnB6UjkwMnJhdHJWNExuOVBmU1MxK3A5YkUrWS82SDllTHZvZjM4OXFsUndIc1A0bk5IeDJuQjhGeTk0UkdwYk5oVXplcHU4bDJCdmdsbnordEpCaGJ4aGxMQkMyemdRalhSZkQvMHNjUVNqcWNBUjNrQVNxTUkvQ0NlNGdxVlhoeUgrRktuaDQvYmh4YThIY0JSQzFBN2ZoTWoycTRFV1IwRm9idCtjeWpjOXQ2NllmLzN2ZDFHU0VzYUFwU0VnT0FmeGxLMHBlYW91RlVjUDcwUzQ5aTJhaHcrajZFSEFGbU1FUGJLNWkzaW9tVVRwZWQ0TXRxVnVUT3NRdEoxR3ROVjVDSGlUeWhLZzBCb2JnRjVXb2pEQURiNE1QSkxCNWlWVkNPVytpM2xMK3FnMzhJa3pYWUZDMmxDOEVaVk1wZzlQT3NlRnUvRHAwVE1OOXFqRVBsbXJNQTQralI2NEhIc2R0SGdjOVlONk9YSTlDRHpLY0htUTRQWW84OEhEeTJoNlVBMEdveU05L2IzWHNzUkpwWHg2K3F1Qm5ONzVVQ3EzNitKTVhrdmZjK0JQMlNqNUY1Zlg0ZmF0UWxpRFM5NzFPMzBmeHU0V09YQ2plODUySDZLNmVPaTV1T3VRdzFZOGl1ZnE1SUJZb1djdXBHem54aWRJNUc4SDQvSkxCVUh5NjlzcnZmM3h2LzFXQXptemw3NTRBOGIvVnZnZnFmck5aelZKTzZLdEw4RXFlNjVPakxqdko2TUtjTlQ0NVc5RFlmRFNObitqMHlWR3dZS2dQWHk4cUUrU2lMREZEcXN5RmNTOWhEVnpPeGtzRkhFWGEwZUZUMEJtcWcwMVFmQ3QwN202cSs0SzN6aEJPZkV5MHR0aDZKQjJNN1dVaXFNdDQyd29ZZjZEcVlzYk1zbEU2Y1A0SW5ZTis3cW05U1QwdCtaWmVEZmFjL21wM2c0d2ErVkU5a25lZkV2S1hMVTdwR0ZJdExXbngwakt3WUhGQ3g5Q3FyOVZmc2hBR0VKRTJKQWc4UVh6bHF1Z0VLZ3Y4RTEydEhJemFnRDFCbFlubi90ZEFyQnhRdHM4LzhPN1JZNzhFbWZrMi9zR29ySlQxWHdMdXRCMjAvOUxadkVVSGhYWjBqYlZ4dzM5MDRvVGI0M25wT2NmelZHeFlTNWJOY0N3cWZJTTVlQ3gvSHNzSFBVRnordDdobUk3VitMM3FlWVZ1cDljNWhTdE0wQzRDVDNjV2tnajljUVVXVy9EYlYxdGJMMnAxNWxUK095dmJMbWxxQlorSGhPNjdEUHpSYjV0bWdHckIwRmRacytJSjJ2Wkd6L1B2Y2owZDRPZ2FBblR2NG8wMGdFdDNTRkVOL0dnRlY2eFBMeWtONXM4L084N2tOY0FWb1lQU3E1VEhkblh6UHQwODFUbEIvZmZuRk1HTW5LbWV3NTkrN2FTb3JBN3FBWm9UcWlEVytqaGhKLzdvZWs3aEtxWDgxK2NVWnJmbkZCWlFDcEwzblRtekQ3Mk9QaWFmMzVrMWV6Wm1ydmtIbDYvNGpEK0g4bEdWZHdiMm42L0svV0puVEdQRmN3cUZTcDNqNnYrVGM0cHdoZHg4Uml0OGh2ZUVZa0l0cHRyRXFIWHNaSDJLNmVXdnkvUzJjRVB0LzhVNVJRVjZYR2doODIwRTNpUE80ajBpUXJHOTYrUWcxWFhHdzlXYjgzbmJoRDAwbUtxMm9mRXUvclNxYkVtVVE2aVJRRk5pTUNOUGlRTlFITDExS0JULy9QRGMweWZudHQ0VzRkQ1BDOVpzNFhsVUhWeUg0aGIrOXR0V2FlbEpkUHFYMm5mUjZUT2ZTTlBldTdkTnpCWTMvVVQxbkkzbGR5VXpqVW1JVU9Ka2ROeEN4NlYweG5KVkE5SzJBZ1Q3eXhnK0xtWmpQVUpVUkRJNWVwRzEzUmhtS05ZRFcwYUFaRThnbEg0SEpQVHM0aGxVNW9WT1dLMWdpd3BGbEhvZGhLSFQ5MmxvVEpVYnFMTFFVUFZlbFlHSUlFSHo0b3Z4WE5HY01UeGZBbFNnZmV3ODRGaUNEQjJNcDRIM2wxMGV6UlhrUWNBT0dwSnBLb2dJa29HTUw3YVNVL0Jwd0RoaS9GZTcwTU94WTBFWGRIckdEQ0lpZ2gzb05YQWtkTzJvZVR2UnZsNkZZTzhVVlkvN1Y3bkIvaUduRndmS2Y4YjcrQ1c4Yjhkd2IrdHpoVlNVMGF2akw5VjFJaWJ4QVkycFFXWDBtSGk3WHd6eEQ0aXBnR05mblI3RDZMMEJSTDI3RUVlQWhHd3h4S05FYTJsL0RtNnZBbkhmRG4xRkllN1hMSWhvRk9icjF6cWtXeDhHZHI5bmp4VWtDbWZSVmdwMjcwMWdjdnFLWGxQR3dNY3k2djNabkt0WDJUNU16d0lJdmh5NExtT1EzbVg0Y2w2QzZpYzBIUGZsSmJwK2UvN3ZNcDY5R3NQQXJSYXZQZUI1a2VSbklQQzJXS21FcjFTVS9qNytHRUx3RTZvR29Sc3A4T1lXdkhhTGYrWlVyRThxdDNaVjhNa3B4cmxFTU9mL2szeHJKQThBNmdCaTZiT3BsQy9VNERocER2VzFDK01HUEU4TDlYQmhkM2Jnd1NtdzMzcWZRYjhYK3MyWVNBWVd2YnNNMWJGU0VvbU9wVzVzL0FuQ21ML1ppN3FnVjVmYlkySDA4QUZ3STBpZVBadHViMms3NWk4b29mclhFZlRqZ0J2QUgvemcrQVUxbTViVmF6SnVENVpIcFBkeGU0aWZUTFliUHFkVHlYU0kybXE0cGRNcmhvSng2T2ErVCtsLzVneFRqZWc4eVh2UG5NR05vU3JRUWR5T1diTm13emxnSzJzSmpIRjhoNW1hMGdLeXJnbCsrS1gvS1QrRmYrWC9wL2twM2tDSHRma3B0bTYxZ2liQ1ZmU2hTMzZLcXpsbno4cnJWRENLbitOMWVrZjJtK21GVnlhTkdGYjladGlaeENubFRBTHp4WU1NYzl2YkZjUHlsb3BoMmExYkNzT3dESERpTjY1RlJiSysrL28veVljNmtEZjFKRWtySDBMaU9xRExPZWQwbXpIUnNVVnJyV2dWa3dxZkhTYytIWXFjK2duZWJ3ZUpOaTVjNStldHM1cnBuRExkUW5HcjUrRUdyMkJ5cXF5ZGlkVTBxTzU2UzZQbWd6VG8rK0t4eFhYaWR1WnZPMjlkWWkxY1BXSDV4QWtyUk51enUyZXZEQmswYU1pVnMwTGdzN3RGbjN4UzVQeVgwYitxL0s1NEF6Y20zSzJmK3ZPUjgvNXY2UmR2bkZ3NytNTmFkZFlPK2ZCWS9yU2hJK2RaWitVT240V1hTNnRqcHpONzk4NDhmUXp1ZDdSYXVHclZRdWUvOUZ5MzNDSGJ1UWdmR09BbVQ0MHFrL3Q3K2pITHVZdkxrcDhxcVJPOEhlYnlBL1hNd0xNaUozQW0yMlZMUmVVRXNBODZvWmpGU2tvd1R5QmZpWEZNR0lDK0p1WXhZVURPalJ1SWQ5b1dZZmtOdkNaK2xFSm9HMFpyMnFCd0Ftb0pOMnE5Zm95dWJNSGs2b25sbzJ2V2Y5WWdNdldkRGNwRyswQVNrNStQSGJNU1lBcVFKR3NnczQ2K3Z3cHJiTmxnUEpyaE9JQThGZ3dkdUFUUHFZdmw5NlJDOFRoWFMvRmdySVhKck9VV1hpSWFmNGxXcHBFU09LZzd6L1ZuT1hpWXg0TklVd1dKZWkzS1g5KzRjQXJDYkRiYWFsRDI5bnlIM1VURnBaZng4azdBNE9LNDYrLzRqVHJ1amxBY2U5RVRxNVYvS1ZMcnZsc2pKNXU2NzhxdXZkbU9Cc1QrQ3JqMWVGMU53L0pJak5JSHRLVnVwWEFxelNsOW9PRFE2OFFSVTdEQVR1ckpTYUZnbEMwUTNyb2RWMmU0Q0tQSlVQMWxXUzB4dWFLb29zWnVFMkVtaHA3Rmd1clB2QjU4SXdzdDY5WUxFSHlONnZJZmI1WWxtb3UvaTAveHh0YmpDcWhNSlpkcm03RGtzdU11azJnaWJ5RnZ6RVVnOGE0UlBxTitEWDVLOU02L2NYRFNNaEZPOG1DYW5rMmc0VmMrZXBsTkJRYTM4QlNxQjBUd0ZuN2xIL2svZlZJQWcvT2d1Y0FSRDBHWnhDd01LSXI2WDdTR2gxaE9LMm9UcThTWmREWkt0L0ZncXBPZ1ZqZXlDN3lIS2pPNEVtYXNTRmlNeFFETE5sdnRpd3JBMFVIZ1dJSGpDSmkwdklZVUJkS0pQUXl0by9yRFoyQ2cxVXBrdEYrd1RQT05uSE9yUUhPeTdOYSsvQzlPbHJVcW5sM3lrUFA5RkFmeUdsbEFOaXN3eEhWeUNzMkVBa0kvTDdmRnpOWUg3bWJRRjJ3Q0xVZ2ZiNkw5dlJWTnhEUENRcm9idHVhSFBPMmtkRHJyK0xLbHVOdHh1NzZVejQ3TWVBVGtkdEVUUkxleW1sc0g3b3J0VXRXN1NreUtxNlFIQkFiVVptZWdWOWF1NE9lM0M0OFNhQTY2QUU4eVJJdnBjQzFFRjdGNldpcVAxbWR3SEI0bmVjell1RGxtc2xFajdWdU4yM2NUajFzbzFqNkcvQk9pa2hySFFyN1FjQmZTQ2s4ZmljVkdrem52cVYvTWxhbDBVcDFtLzlHWitRbktkQ05BR3FYSWI3SFVaQkJENDNOeFV5TlczL2d1RzNVU2hxSzByTzl1V04vYjlJR1gxYkIrMHdwWXd3ejZPV3FDZ204T3dMV09YcCtlUmROQXdicnBSc2RndUxMU2pMVm9HdThObXpqYjVvSEhyaHFXRUliODAybTlib1RVMHlTUEFObXlRTnJtb1ZjY2dpbWVYeWh0bTk2Mm5DUzNqY1REV3BLMFRRc0ZJTkVjc2ZyU0dRbnQ1ZDlIZTcrK1pGMjBwcVZYdnFIOWh3dEFTY0FUeDlNajMzd0ticVBLNE5NelI0NnNuVzVFTmNCMXIrbHJqOEF1WUFwcDB3V084NUR3ZUVYaEhXcWhHNjhVeXBBcnVLaFVPUGhXSXZ6cEZ5VnV6MjR3VTE1dG9MemFZR1JRZnJyVW0wSFV0VGFjL2hwTk9YbE4vV2JzZmt4OUFmMmVuTUttTFI1ZGtNWUhCVllZMzVJUEZvMUxxbzlxV3EyQ054MW1QSmdWQmxtWXNZWjh6VjVTejlGVHREbDY0ZUdHQk1GWElqSHVOYmlhU3Ivb2dpMHQrSXZGclFEb2R1QjFuV1RudkMzeStaMDIxNE1mbmRzMHpOWVdScThSOUJwRms4ZnJ3VmhjWjRJdit5NTNpRW51Tm5PRUdLbk9pSjRyWm8xTFNFUTlNWmU2R01DbVMwMHlRZkJNME00TllmcWFJMGV5RjlkREFWaW9xVXluemhUY0gyUFFBUDYwSVlPcnd5VnhlMWwvMU1ITnFhUHpDdlZ5V2RmYU14TzdwVW9kMG1oTHZDN0x0QlJKdTZLT3NUaFcweFYxakxhRVVsdENmRE9meVFrTEV0WWsyQklPSlpRbVNCbk5USFVUbWlWMFNzaEtHSkhBZnZISXN6OUlBSG0ybDNCeG95MU9VVnQySEl6N09vNmkzTWFGeGNYSE5ZMFRNbXhKaE92UnNDM204eXpEakpFSVA3ckFYQXpmRVVsT05OekxGd0UvWitLOFJlajZwWmJwblljMmZhblhra1h6bTIwN2MvTFl0R21mN2Q1dVF3ZkJhaGt3MTNaaTUvQXR0YU8zei96MFl2T216ZnNFZDR0WTJudm9tSTltdmJka3dLSVpCU3R5Z0NBajZrS3VOKzdUb1ZJQTdkUGJidlpnT3VHVVBsWHdYZ2pYMElKNkJla3NUZlk2RnJvcDE0blg5cWZkTDdZTzh5S1N1elZZMjRXc2M2OGxQRWlvbE5Fc2drc3dKb1FudUhhenM0d3hyNW01WWhuUGthNGpvTzE2ZVRUa0VaQjdWK012ODl5aE1Lc2pzUHpqb2hYdm9zdWd4c0hidWYxR2prWGxoMTlLN3pTMGFWejYwc1h6YXkzYnNXM0xXNXZaQU1BZUEzcDN5aDZ3WW1iYVpFdjFTYjBXYk5TTVFsNW1UdFlBM3A4T0FQR2Jaamh3L2hLWVRzK1k1RmhyL0gyZERsT1M0Y2NNZndGK2pQWmMyKzViVGNHU0lSQXhDbHlNRmxlR3dNaThHRFZHaDlPUC94R1ozeDZrTURFTW9mK21LM2hrbVM4L2dUaXM4UlBLcHJ1QjZDZmVhbTNiTTNlMWJjMmMvbXE4WXBPVzI5blJUYTRvMWFhbE9UdXhWMlVKeDZ2RzY5ckJ1MWlJS1RhL2NoeWVCT2paUGg1ME14VytVK0lBUWVWbkorRUV4dUZhMFg0Uk9scEFmdjhIYS9hSkVCNkFodjBVbWw4NUQ2LzNBTFg2Wllzb2JyM0RMNyt6UVJRMzNHRzZleWlXWjc4V2oySnA5aFdOTFZjWENlZnF2a3NFSTRNdTNRNTFXVThoZ2I5WVJ5SkJ2MWgyaFdHaGVKZE5xRE43YURWUXFYbG1EV1ROUThGVHVmTHNiSDdQd2dsZ1VQc1J6N0lvMkNNZ0VYeENwSkRLQlNvMFVLYm8xalNuQm5jeEdueGRhVERyZzQrSkRHMjNTTkY3YXhkMEMwc09EUGFLQ0tqWE9SUjluNFdtRlFDL3drTFllVkt1cjArRzZOV3NlOWtPbXZPTjlvZWhzWDgwdEZCL2w3NUNJc1BSQ3lBNDg4U0hxWW9hVnlnU3VrbnVQc2p5cVBmbFM3R3VSakxhazB3cEpLTjlkYlZzQWVyZ1dVYzhacVM1MjR3R3JwZllsMkhFb0E0ZVRZU09SaHF6VHU0TG82bk1WRkNlSjl5VWlNOVd2SUlOb2hzTTFlZ21VRW5BVEJQbWFwMzBxOUVPMGtnRnRsakNSWXdHeVJCb1NZcU9pY1pMSkNVNUpTa3hNQ2c0eUJSVFB5WTZCdCtYRE1RQklUZ29HTjlQVGtuR3EyWGx6QXY1bDk1ZXZuem05L2tYWnE3TXQvWmZuNytwLytqUjJSdnpQKzZmVDViSzF1WG1pUVdtbFZ2cGN0bjJ2aW5mR3JCOEczSHdYRERPYkIxbktsaHc3LzV2Q3lhYUpvdzNqMXR3bjJPNEp4UHd1dGxQMjVhcThZR3Q0SzJnRWJ6SjhVTTFyWFpLblgyMWUxOU4zRHlSdHF3eHFLKzJETGNHdDFqVEpQeWoydFJBbUc4dEh2SFdXM2syNjFiOHo0aXRxRmRtNm1UcnhOU3NySTRGMXNLT21kTkgrYisxNGtIRS9SWFQvUE5HbXFldXdHdHB4VlF6ckw1LzhpQ3oxUm93Y1BMK2lEMVRCZ1pZeDVrSFQ5bERlUUk1eThzeDFPZml1R1pjRys1YlRVUjZoZHdXOWV2eHNiWkFJNW5LdmlRWXdSN3BTd1BRSStQdGxYd3BXRU9nL2tqY1YrK3pIRk5LMGg3SGxkcWIxaU9JV3ZoU01yOWVVYjF0OWZpTUhYNzF3dXJCUEx0ZmZmeEwwL3JrbC9wRjliZlZKNy9VRDZzUDgyejFpQitGcmI2eHVMRVRiaHZmTEc2bStZcHJiMTVxYXg1dmE2VnNUbmEvVmhTY09pVlp0ZHJJNTNIMWs4TkFJRkVaWEkvbDhKNWxEclJFMXFCQ3Q0WEN3T0VsRlVPR1I3Z3ViVHovN1ZicmpwZmlkNHpkZHY3Y0pzbTZoQnc4V2xkTnpuLzMzZnk4c01ub3o0WnRPNlpQeXUwRWpNTlI1TXVOWjR2cm9IanprdU96NzI4TkhqaHc4SzN2WWROTE4wWFlhOWQ2eDJjZmwzeFNCTDVETVVXZmxId01tNjdmQmRxL3VhcExjLyt3bkhFZm9LSzRjWE9tMC9HWlczNVhQQ3YrS28vUGNUZUlBZjlxZkNKOS81dnhzUmVSUzI0OWtFY0hoUTFQRWJuazFnZi9ha3pzelFQSjZhaHVVUDdGZURRR2lZSC9ZanlHU3U4Zk8vN0JzSFd4c1d1SGZuanM2Q3BwNkRSeWtKby9iOVNRYWRPR3ZGdDlDbnJZc0YwcUhvODBZTXhGRVM4M2ZrZG9ETVVMcDlEOTB4Y3k4WDhYVGdQVHFRdDRQRDVlZ2U2L3QzN1Z3b2NQRjY1YS94NHdyZmdZREg1elZlZm0vdFZ6eG4rSTF0RFJnT3pjVy9xRE0yQmQ0U00zNXp5NmFBaDZxT1VLZDZrM1pSZ2tQdFkrMzRCNzE4OUFRdk1OSkV1Um9ha0JTMUNZRlFKTnAyS3RTU2kxRjBxNDFId0o1TzJJbDVxUzlNVis1SVpmR0RWNCtPdEJNdWxCWUZKRWNBVG1IT0kvSFVWRFQvZ25SRHR5K1doM1IrclNCNTA3anh6NSt6K2RxME4ycms0eGxtdHlKVzRRdzJpWDZLQWNYYmRKMWlVSFNXODBKWmQ0dFhNeXlhV2NYTGFSZkJsdSt5ZVRkZ2U1Yk1PZFJMd3g4YndsWHcrU1N6bStrT05CNzFLN24zL1k4N29zaFhYWlA1N2VneThCZkFqUjlseDQxZDB4dnBqWnVmUFVxZWo3ZnpqTUI5dzB0RWpZakdYUEVDVVhzUzVpUmQxWmdOTVQyMTNVSjNRVktnbXlqNHpiSUorQjBpQ0lSZ0RldDE1SDkwSHRQMzhGb1FJY2NlSFRnN2R1SGV5SUZvRjBJK2dKdkNoTXc5UHZKZHN4ZFBIVy9WL1Fkd3l6YkJIRkxOUFRXR0gzK3k5b2RPZE1pR21jbVgvNDZwUHpXMjRKY01pR0NldHQyemEwd3dUMk1vSFlId2dVR1QySlJidHI3eThqK1ZBb0Zrd1R6b3ovaDFtaFRrM0g3eEFOVWJ6RkhKVWkwcjlFSG4rSHpVRkVNcnF5ZCthUDZHb1NpTHFNZmtnQmxwUFRmZ2RSRGJHc2JQc2tjeE1xQnZNMjk5NE1abS9PMmd3R29wNmJlMjhpWTFYMmtYQ28zRTk4ak9lM1A4a0JVY3pyOHFMZ1dST0JtWkxEUEFLZzRXS2pDU2VHN3NQUEZJckI1VjJsUUN5djF1SHMza2JNb2IyTjJnZUpNRVRqam90TnV0b1NhdEQ4cVJicW1vMzFwcVN5bGNPQnNWUHVwRjZwYlJ1aVB5ZUhpYU0rSEo5VDNiOTU1MVZ2a3R3T284VTQ5SXJVQjh0NEhwd2RpSHdzV2Y2SmdjRUd4K2paVFJxSWw2ZlBHUmRIeW4yTXkrVXE1WGlPbG90SmljRjBYMnZRQkx3anhsRmU1L0hVR3gwRkg0bmJPSll5cENtWHhtVnl1VndoUWR4L0k5N1dQOTQyR25OMFRYZmpHYXZORTJON2d4cGMzekFXOTRJNkdhOC9zVkhnYS9GUXpmMDZwYmJSUmx0OWNpMHUwTngvcGRUV3lsajhtcTVqbUkrNkN1SGgrdDM4RDcvL3A5OWQ2eXNyaDhLSXpLdzhBUTZzbDVBUUIzNkdZbDVXMWtnQkRxcWJtQkRYbVg0alArSnY4ZWdiM1ZkSGQ5MmpqamVoa0pmVkowOGt2OWFyaTI3aXI1bjBhM3o5ZW5VYjAyOGpSVGdJZjRzWC9wVFNCZ3hJazJJYk5xaUQ3a29kQitMUGRSbzBqRVdlenMrT0o1cjdQMG1kY25JNjRjOE42b2hWbEdlZlg1N3diNCtudFZBL01GQTh6Z21jSitkTFQ2NnJjeGJNeStOSjlnd3NSdGlxeGR0aTRvbFpxbEo4UmQyTHNub2pXWFZpTUY1emZBeGViaUJGREl6Q2F5NUpCQ2xSd1pJSURHSk1GQi9EcDVoQnNObkFvOWhLNHpOYk4vQWVsOVVHVnZjQnFXajlzekUrYUR2b3lhK0VvSG1yS0ZSZWhubnNvZFlnT3RhMHBQbHhQdE8wdE1XeFYzelJGdEJIK05BWGRFRnJrTW03b08rcmpjZ0ZiRFd1YUJWY1hEYlB0S0wxRi9BbkNOcTBSdWZMYmtDMDcxWEE0cWNQb210aVZ5VTIzQmpEWXNOTkJzNVBlTFg4dWt1TStGcDBUV2loeEJHUXNpU09nSlRsRStXeVNqeUIzaDdiLzBYMldOWHlhdmVIYml5ei8vOFlZeFZiYkQ5Sy8yRE9lYkxuRm5UaCtlWlhrODc4NnYyL3RlSjVGbGl4dldNY3NjQ0s3WE8yYnkvYkl0dGZJY1hEV0lESHdJam5iQXMzMGV4cVVETUhlZmxNMWdWRFNPL2RSOXdnQ0hGWUdRczJ4RWlXcUlpRWxKaVU0QlIycUFVUzhzR2puNTlOTWhobWRGZzRhQ21hQ2lZTmFqK3l3MFF4ZmNkT05CVm1PRDRTYlhjT0hSNXRrTjV0dGJaZVR0alVWdlBGWHUvTTJTUExTY3hYSCt1VHRiaCtiankzZE1jSmRDUzhYR2VTdHllSmdiZWJBanhacEpKT2tQRjBCVWhYV3lHam1nWXpKM1NMeHVtY05BNnJ6K0p3ZzJGdzZxQWVCU00zSjF1ei9aSTNqejV5MmJwMjliaGwwYlZXanU3WE9pOTFhQ2RRL3VkQ1Q0KzNXazV0MUxXVDQydngwb2FlZmRHWHlIRWFDS042T2Y3dWtSTS90OFdNc1o4UnVZSEU0MFlZL0oweEQvOG1GdzJ4OVVvYVZTR0tPcVFrQ2hFT3ozejRWNzdZRHBDa0c2QXY4WmZHODdheHVOaWwvbitJbDNPdG56bThKUEtOSFplc01DYWZ4VlNBSG9UK1dEbVhqbzhpOTdpMTZ0cTlvUkxRcWZXdkVZZzNGYkhHZWJqa1NRVU03RGFSSllhSDg5RkgrUXNXOEVNZGxVQUdQT0pvREkva3dKazVqcXNjb0lkMlRhanZad2MzcDhicSszM1krMzNpWFVJbENGaUE1SnBUcE1MNys2TmQxbzgrZ2lzZFYwQTc4Qmg1Z2NjNTRJY0JhQmJKSllSdUNlMG83bFEzTlp1bjdtaEFOUTBGdXZBQ2M2RE1DendyK0lMN3U5Q1NHTTZaQXFBTXNCWUxsRFJFNTRBUFNQN2xPd21zL3dUOGVlRWN6VXJrK0IzOWlINjZnVTRJc01lemc3ZnZPT0taMzBFUitwUGZUSEZZblhUcTFwQjZDaGZnUXFkL2dKTk9MejJkSmxjNkU0VEFJRWhBQVZPU294bWRmRVBIbGZtM1FUVlE4bG40OHVrUVh0NCtuMFpnb3RWM2JreERmMFZsUk82emJ0dnVlS0xFNkFTalZZWkFpZ3Q1ak9ac0hDdjUwZnZWMENySmorUlFCait6KzZJbmk0dEVyeFBjR0h6L09Mc1Bpc3BMOFAzKzZBMFNONGp2MzVUdko1WFRYRXBvbFZpVitrckdzZnRFTVNNK2FtaVZVSXZXZjRmZDV5MVU5OWhKY2xMaExnelFlVWZxZEZhM0xneXExNExaaStabk1NZmI0ODFFUjhNWFhab0tJSmlwT1lLNnBoQWZCazlvWWQ0Q0xBNk94c0lKUzFBcXVMOE10ZW1Wc3pBL2YyRk9QekJKdEJId0hMZ2RYUWZWSGFuNDIwQlFCY3RIeXpITkJKTzhLZTdRQUFWTFIrZTdwUXZmK1FlYWQyU2FjODBrZHM5Y2FDYkJYbVlTN0dVdU1zT1IvNklOQkVXRXRRRnZXN2dOUG1nOW1MTWFiZStROC9hNGNXL252QVlpaElhT3g0NVM4T0MzMzFoUTMrKy9nMnNjS1ArTDQwUkkxOVEwTi9xZTdzaFU1NDJocGdIdzVUMDFDUFphMDRNdTVORExrMmZ3cVRxUERZRkc0eGhLN1diZzY0eElsRGRma20xZWpreUUvbC9rWDc2Y0Qwem8vdWV3OFV6b1dBK253M2x3aStOMTRmMmNyVnR6MEZpNFduUTBjRVRRR01WS21FODlsaXJqTm8zU25QenEzRGdEM0kySnMwM1F5TnJrMGdUNFB6UUI3Snh0M2JEQkNscWgvWlBBb2prUXBZRWYrRm5Rei9HN2NESG4wcVVjeDJwd1ZFU1ZIYnRGaG5YT2NkSmdLaitNZHVQTm9ETUc2ZHFnK3BwNFFObmliOC8wSU9OQ1lnY0xQZVo3Nk1lRjJQeTFzOHNIZURnYkVaSGtKSjhmLzBVK0NvSjlYTG9maXoyT3Z0cStUOFR6cVM3RjVNNzlweGpJZjZLYmtzd0NJZjhya3VIMTllUFFDT2pwRXRIS244dlJoclRLZktvZDVWT3hNcDlxeVdKM2lic3A1VlAzWkQ1Vm40N05mbzR6SEtMNzhCUTNIa0k2UHZVYzd5cHZMeTF1NERidUlNRU52T29XUXhBYVhWTFp1UmlPSXVpK0tRZUFna1QrRmI2ekl6cWY0Rkh4QXZ3azUya0pYTzNvSys5TGVHeW0wdjE3c3B1WVdSMnZlZzdkakZkeG1GZmg0WVV5NVhrN2lDSk9XQlpwd0h6OEdqanlQeVE3R0w0S2E2QTNXT1RxbStEbkFXVXZzZWhWMnQvYjBYMER5ZjlhbVdnek1xSzR6cEZYVFV1azgrZmhUTUd5RDV2ZTJ1YVN6SmZrV3RmSG43Z1JBYWdZOE1OR25SQ3drV1ZkNDF1NlNBRXh6bnlGVkJhUVpsSHNnSFNWZHQwaHBNN1h5aG45WlF4U2FTZThudE9oNnhQanUxNXVvYkN3ZW1tQVNnVGZycjhISW1SeDROcXU5U3hPRiticDVRRXRSa05CK1UxeHFYaUVxODI5VE5ITzQvRlVxS2lCVVM5UjhnV3ZSUzFxQ0M5UnNzT054VWw2QnhPc3o4UnB5b1h3Y1VSZGlJbWptMEtRMFZhNzFGWTdIbXZxN0lpVDJKL3IrNGRCbWlPTUkzNmkwVERKUkZNZkJPS1JNV0FGQVFUNEUvQndHY2haWERyb1FKYzJxN3VpVzJqN3MyTVNYTDRiK0Y1THpJeGRXSFRSYnIveWxyWGh0UGFPTGlzV2o1KzJiRXJoNGlvV1MzZ0VlQWZFbjBhZ2l3aXowTStuU2hGQ05oL2YzaUJxTytCK0FYSG8zRDMweUladXBQdWI0QnViMEtNTzdZSEhPdUR6NmUrUFNBelUyUEs3d21Tc0w5WEdjcjRjTlVBN1JLY2l1VjFKcXFmV2Mvc3QzclhmYk1tbDlwQmtubllYbjZ4Mmw5cFhMQ2tTTlZZd1dCbVNpb01CWDVQb051TG9rTWduT2ZNd0pEWUJ3dVRYbDdWSW1kejZXL1J3L3hLcDkrUWpIOWRvSFRZOGY5MnNtUnZmVEgwcE82VW9wMHUzck54c3FVMmFkN1dxNGVHZzllUFVyMEFsRVdhZVhaVjJFdjFkeVR2MXp2ekJuejFFejQ0TkxQenVOVjlmY0dqSWtoTzdGdzJmK25sS2c4OEl6aHVXRXoraE1WWFJzang0aGNxSmZkRHJKQVljMzI4ajMzK1QzbjhKODFsTmpuQjgveUhsdjNYUktoS1RqZm52Ny9MOVNSWHpCNUk4S1N6L2xiOEVGdEExSi8rTzk2Q09iakROZEVjaEtvNWNLOHhyN1lJSGtNSEZ0WWtYS2xGL1h4K2EreEJ6MkVBTGMzMUt3cC9oVUhEa0hmVFMxdHRTUG5RY1JuSHZ3Smw4cmJMek9aVWM5MkJWSVllUFpmWjVPVCtYU2NsdHFOT2JkUDc5bENON3VjNFc3U0d5RHBTK1ZTVzhReGhMS2RhN0tNc2RMSmNYb1pTdi9kajYrREthemZKNWdlZ0NOUHVLZ0xMQnloeitJc25weGNlVzFhU1ljTGovRDlMK2J5VHZjM3RZN0RYdS8wdWsvMG5zTmJrUHo5SDJXTkFIMGxEY3Z5WWxBbGUzLytsa0U1VXpRNk5yTkxCSm40ekhtMEtiK0RGL2Nhb0tPcEhrd0E2VXkrL0VzMGZGazJ1Zm5mMnNxaE5SRG5DaDZLRHdHNDFWVG5lenQxWHNjSmttVGsrVHI1NG1MMnE1OU5GcTU0dzBsYkIyNkJ3OGlxNHBZZVA4K2V6c3NnVnE0RGlKSDhOOSs1anFXTi9LZmZ1QTl1MXczTGNPT3JjZnkzMzdsdzRYTDVScnAvSCtjeXVQcXdwM0lCTlhBK05ka25VUzR5dUxBYk9ZSk5WdmdScU5nbW5zZjNLS0RKV1htZlJ5emkvV2NkWWUzYmJuSk5mdnB3RG0rWGtJZnowQ0F3Y3gyTHhPSFFIb2pqYnpIbjRFUGcvVHVoekwyVi9RSEJIdDNKd2FVVXlDQ2pIeG5zQlBkcktWU2wxTzRLaDdjTVNMU0Uza3Y3QzJiaGRlZmNEQnJKejgxczFtRFlpSWJFK0Q1ZjBrWWVNNnNYdHZGakxmc29rSW90QTEzdUJMSXVjQjhha1VGbW14Qm5YOHdEMHFsc1FCMlZWYkJ5MlpLQ01tYUdPMU5sajdIeGgyLzZGMSsyNEtOZWdZV0szNjJYdG9HRmk4WjAzMWFvNk9UTmRlemVMTU1NL3FRUGZaV3VWM3hJVjRudzNuYWlsUlA3cGpUWVVxZXlBRC93bWtucnVCdXBNMHNtWTRmWUFvWGxUUlducEZzcFhHQVJyZkhKeVNKR2ZaVktJdmduMEJVQnk4K0dKMEV4MS9kN1VBTTNQNlNTRHhwZ05VTDJ2MTYvMEpoenJFdERybG1NbTMvdmIwb1IrRFFRZGdYT2xYdkZBY05Na1RCb0ZLSUIxdFFwY0dyN2lLN3JSSTZkSGdOYjV6N1Ird2N2ejlKUTZXLzQzM3lZNFU4eU5hYWFPTzJhbHQ5T2Q4NWZnU2dZSmxXdlRjbDN1Um13RFpDUEVXR0FlU1NCT1RtWmxLem1sR0dzaFRoeSs4QVVMN1NmUm43cWljNXMycmNPV2JQdi9KSVJ4ZVBXTDF5NG1OOXkyWXZzTVB3dkhyQTBHZG13bEI3eFYwR21RKy9xVHNtNXpRWFkrYk5PelNyQVB2T0xsQ3JENzNBQm5IV3FnVkdUZi9hRGhZWHJmZmxuOWNYbDcrTitwRjJvcnZENUgzcWovS0Q3ckprMHl4aGVtWi96RVpEL2FpZ2tmdG81ejFVN3dwZXRiL3MxeG1ETU1NcWliNktyRzJPOUVwWVFPVmlRZTVRU2pYV2Y1MWlXVnBuL3RyeFUxL0YwRjBPOWJBaEZpS1VzNXJaUkhNUndTTlhHeUpVTEdEOEM2SWQ4WTdpbHlNanVmbkY4T1lXWkFQaDFnMHZxa1JqZHZqNVRFQ0xwRHhwajVFZi9JM3FXeU0rWWNzWnVweVNPcjhTblNoYjBvMDZmWUEzb2U1bFhGNG5zUlREMlVYUVZpbXNlNlh2NVljaWxnK0E4SWY5aDRZTjI0RzJMd0F3cTdtS3llbklsUWpJM0xuNkMwYlZMUWpPczdYbUU0SVRsQy9NaitoWWZsMWZMODJ1aWEwcEh6N0YzYWZyMTkrbldLSWQ2QVk0c0hjYS8rRTZha29LTTZkQ1cvNDJ5RXcwL2hoRnloYnV0Zm80N3NqYU1KTy9oWHJCL09ySjRYNitqWU43TllINjN1NGE5K0Fueno1aTBSeDl4TXJUUmtELzZLS0g4bVIySUUvVC90NThqL0ZhYnFselE0QzVSRGtIWmtnRnhDOUR4d0VSTzhEaFlEb2ZZRG9mYUFJWUwxUDN3QVNsQnp3cjlvVGhMZlFEK2FIMWNmdGFSTFVyUS9XVXhoMDBiTmh6dmEwSXdNazI4MDZPZlYxUERiTjZkZ1FHMWx6cDc2T3h5YUIzaWQ3OERMZEhseFgzWU5YNi9iZ0ZNVXVKOUh5QkJXSTFDTytUZXZaaU4vN1BpMS9WMzd2WEhyZmRZMVRMSGV5eHJrYU11YlhMUVh6V1kzQnBSaUlvZ09YYWNYaWEwZW5raEoxeFJCblhsOVdqNlRVd3czbXRyTWNEVVlSMTBNczlUNnFmeVNyNzVoU0h6ZTRHY1V4cUd2QTlkbnFza3grcEp5SjR3eGhsTmEzbGR3TzBuZ2E3NzdCaVlWT2FhOHAwMzVVb1YzU1l5WTRGRndGWEdZbVI2bXZJUnFVL0Q0VHkrK0tZZUl4NnRuYjNNMktVUHd2dDN0alFUbldWU1UzdURqemduQ0dLVW9CTlJtU0tGbmk1Z1QvbEJpeW1jRXRvQ1pvajByK3d2em1nQkRyUUZOT2RJeDU5Zno1MDQ4QlgvYm0zK0l4dEF4ZDJvQXVvdW5nRFJBekp2MFJxTjh5dWNmTEhaKytBMTc1VlV5NmhtNFJtdDh1djhlWENXbVU1dlRuWmZxaUZoWURKeU0rNittMm0xbjJZRDM1eE1OQ2p6K2krQ1ZIRTJSVUprWFExaVRUMWdUQkdpZUJEM3AwNFBPZllKbHVqM0xNV0Mra29YTTNVMjZqMDVyOXFZeDM3ayswMzZXTGVCK2FJYytaM2FBbVJiUVFPUzJpQlNsTDJ5c2V4V1Zuc2puVEk0Q1VqRENRa2hFc2VOTzVaMG5LbnNVTkJtdlpQS3dpK2lnWnBwVTYyZDVsVS9ZdVhMWTV3MGVvWnNCN2w2MGFDVFJSeWxJY2VrTlZaaytndE00Q1EwalplTEVtTGh0dnROVlJ5MUpzUXJMdkVoc0RvVFhNVEVzYWRDVUJOeExYV1lubTVHbnV4dXFxK0wxdGwwQVYvQnl2VjBvcW9BMFFOSmhnNEI2b25oOElIYkY4TmtRdGJ2eUd5ci9haHg2SU1HLy9zZzlLdGhlUEUxdUxPUm1PMytHTmM0ZC9rUEhvZDI1ZytXcEhvakUwL3JFYTVsMDY5cnM5QUhnTHNXNEoreWRLZWtOSEVxR2szYVVIQ0ozYWkrN0xsSHkyZlRCL1doeVE0Ymp2OGRPcFExZS8rMUthdlh2RDNCMGJCeWk0OU5KVE5YZEdIckNBOW1RTiswZ2VlcHlBSWhVbklJK2JVbjdmcFF6RHQ1ZlVlZ1p6NVVxK0pBOWR2aVMxUHB0Y0h4N0RERG96VEFadFNRVlhuc3dMNHV0TjYveWF6WXR3MFF1WERDZkJha3FkTENmMVVUbG5HYTV6QUozRDRRWmVVMUtMVlE4ajlMbEZZYVFUeTk0QThGcUlrTjk1RjNSbTY4YkxkZDJ3ZDE3RFpTUFpPenZWWlpneHZLWWtMa2R4bHczVmNIc3Z5M1dlQjBOSnlXakt2Nk1aRWlhcmsySWZrWGFBTWxabks5cU9hTm8zU2trbG53a2R0Mi9rTVRuSnhpMVlDdEJqTjZ4VHNCdTR2RmNmYVV0d3pyd29rbHJQWU81alpVMEh1SzVwVnA5TnJXK3doWTViRllPMnBGcG5CelhYU2krUURESkl5VENlbEF6VHJuMVc1ME81VGx5V3MzTVNMVXZ5eU9uTFVwMlkwdnF0VE9zWlJtdGxzUktMRXdoVXkxS2NOanJISHN0OGd0SmEyZUNsS1VueWxXQ1pJSWFXeTJON1B6ZFhzVTBTR3pmRHVURksvTmhzVHNsdkltSWVhSXdHMzN0d3hoaXVqckJLNW05TEdDMmhkSjZFYXVtbU9HQ2lEVC96alBqc2NIOEs5ZVJuR2pPZUdHcW84RXdWTEVlMm84L2tSWExHYUg3THFsYVl1dEVjT2RtaSt6ZnV0eHloSWY3OWVrMzYrNGN6Nk8vVDVOOGI0ZWUvMVp6bGpPWTN5MmM1SGZqZk5XYzVvK0Z4eW8va2ZBQllMc2h5ZzZhdHc4N1EyV3ZVMkYrVEtDUFk2aXpaN1FYaUZFdVBkRHhMN2MxOVFCNHgwSkFFSnZpU1JMRnF5UUhWaGxKd2NUNTZFM1ZkQ0M2Y1BveGFMUVFyd01xRnFOVlJ1TnZSRms1MVRJSzdjK0FpeHlJNDNER2M2UXd5SHFBTHZjOC9TNnRJTDNSSGIrcS9vN2ZHYWRCN0RqcUZUczBEdlV0UG9sMXo4YzlSODlDdUw4RGZ5QU44aFJMQjN6bmdNbW9EOXFJYTdEejlOWXJId2pEZ1c3czVmVkJSeVRrZXlDZit2TjVIZ1hPRlZ5TnhsaVNEZWpMQnZtRUEzUHlLZkZUdDV0T25OOEV3dEhqSGp1MDcrZll3NTJtblh6N2RmOHRSRlJidW1qWjdMNTREdVlUSDBET0lWeFhhSkErcVEwWW9PWXZkNG9YYkRaeUhFazlyTEk3UUhaRFpUZkp2dW5PSXV2VmtDb20wbjBKMU1aSVMwK0FMTERFS3piQU9JemkvWVB4MEFZUlhIeFZ1Z2NKM3EvNWtEU0NrNHlac0I2Qm9ibWY3bXdQV3BoNytPcHUxaE5LZVczNUhTcFVxYzVGY29wS0Q3UGtvbWpRUnF5dTZnMTNpcWRkMWlENFBxMzhZemRWYUxZeWFKbmpkZVFyeG9IbEpoNTRwVWZ6R1pLck1HTHlBUlZMeUdnSVo2b0tkUThTQnBOenZqdzc3S05rS0J2ZGV0azRBa1dGakluRnpIeDBjc1RRaXFYakM0ZS9oejdVV2oxNWR0R3IxcVBkcVF4NEdBQjZrOUhnZGpuM1dmUElzK051WjNsOE1CWVY3MHRGRGRCUDJIZHhuRUlqNEUxaTZEMFdPcndPUDNoN1kwei9DUkd5djViZkY0M2c4NnlpWWc3cmxTd0ZBWEdNR3hXcStNa1Nsb0Q5aDBYWkpvRURnUCt5UnRXUUR0ejVhVlkybkRBVzRONUw5bGJHV0lPa05lSG54N0lNYmR0cExEcUlWWU1COXgrekNVZjNCd0c0TDFndkFFajQyc2dZVUh1NWRVR1FBRTJldXlWbjY3bHVMY283c0xkeFRxOGJXS1duOUN5RGdEdmIrY3VqVWt2Um42RHkvYWpOWi8zSGxOd1dDT2FTMmtRWjl1eHJUdFBDNGRrOGpDUWF5aDd3VVdSR3EyaGFwaStlMzE2TEkxWFhyUmFrREswOWIzQlFxYmNVbzdZNXh4cEhDTDBDVHRNbXpCVmlqeG9USVNDRDhzSFp5b1RqWmVoYWVuanhyK2R2b3FRUzhQN3ZZdDFmbUcrZGJ0WUxiUDBoZDIzSFEvRmN2M09CenAzVHVsdGwvY05lTWNmM1dMK2hTRUZuTjJwM3l1TDdvZS82NHVJMkw0blp6RlkyZEtwUVNWS09LZk1WZ041R2ZWOG5ucHI1cHZsaEYzK1lMOHV6bDVPTG5DMGJhNTVQTFFYTEJENHpjOGJYdlZWS29VUDQ5VDRrWHBSNGQ5M0VKbmNkRHNONTJWZDJIVFNHc0x6Z1B5a1hlWWs2eVVFUFU4eVpMUUhBaWYzeHdsOVpSVVdHZnJQeDIzZkdkTzNlaG4wSFZPMDluakorWkwvVTFvWHNnMkNmcXJkYlRaN3lmWGZUMmdwWFpYeDBkdmF0MnBHM2FyRHBSYkMvSVE5ZjUrVFJXZnBTbW45d0d4enQ5VjZoTkRUaTdMa3J1T3RjbUJsWnNJbjdROHJ3bXF2TWl4ZGxFbU1qUHh3MnNIK3o5bHJVY1hIMTM1dHRMMFNrSUVvNThrNVdWM2JPckYybWhvWExmeEt5TXdkazUvYk9IWmE5WjJtTnlSTldwV1gyOWFmdGFsTjgycE9IMUhLSFRScFY1VUFWL3FhSzB6MTArYjd1WGlaUHhGYldwKzZxNGFxTXlFNnV2WldJeVdCeEpGaFVDaE5PTWEwV0dqU1ZNNi9HQnBSOFpISjhmdlo1VWEvMFMwZlpzb3l1SDRvc1A4Yjg3U3RBb05EY2J2QXo2UWRrV2p2bVRSR3o2RVZ4dnJxTExnUTRpVE1WUTlIYXgwZWlEMEt2ci9PTHN3ZFc5R1lmU3dvbEg2SmswVzh0OE81UzlmRk1EVUNjdkI4NEMyZDJuTDhROE9Yd000VWZYdHM1ZkxmRm4wVXAwREgwMUJEd0NQdUNVSXd5MzhhUzl4OEZzVVBCSjEzdC80eGFTbkdKNGZLS3ByV2FxbS9HaG00N2JaTEF2R0N4NzFlQVFGdHk4WTF2VmcxWEpHcXhLVm5UVitlUnpQRUdZdTZyQ3pBWDltMkZrc09EQ1dqQ0VEU0Zwby9qb3dOSzFrc1BMYW9XUGRRTllzSytYUElDZ2xhT2ZhSE84RHJld3NYc1hqMTBJdGZYTWN1UGIrbno4ZkdXVzJpVW91TU9vMzdGTk9raitLWksya1FneWdsaHZ2eS9oeGdIOWxOV3NUcnU1aW9jeXpETG91ZHNoN3VMWWp4dllLbDhlWGt1WWMzakJYUlFvTkVTQjRLNHlzcDhPY0k0c2FlOHNyTXNzRkkvaHVkckNUVnkzYWpNeXVNTDY2ZmhHVlpxZ2hGb29RcWdqZ3h4WkRRTk5BZjZhL1VVU1lNbGY2QVJJL212dyttWTFXeTU0ODh0Nzk3N2NVQ0tBcXBYenErTDFoMzRQQkJsNEh1S05CUFNPaWVvZFlVSGZmWS8rL2dGOUIzZCsyR1Y3Lzhrck9sMjh5Y1pwREpieGpsQU16cVp1WXNGVmdBeXQ3Q3Y1QkZSMDJzWmJJSnRNSkpNNUZXbmswQ2k1QmNUWEFIYWNNWWIzcVRUYXgxYzR0ZTZ5NDg4enZkNk9qWXdiMzNydGhwSk9jUFNBQmhOZWJqVXFhZlZhMFBCRzdldWdZWGhZWnRWUTlOUld1eGc5WWJSR1lIa2xGSytmRUVVeTF0bVJWZUNKaW1iYUlKMC9qOTB2Q01yemdWcG4zYXdEV01QaEVDWTd5aUJiQk9HVWo1RkZZQkRiNStTVStiRUY4T1VRRFFmRDlMVXN2eTJzd0hOZVQ1LzMveWw5Yks2QzQyZ2kvdzdLdzN3V1QxVzhTQzFZalBoeHk1SzFIc1NpN0ppRzZmdDBmWmZ0R1dCTVVkclZ1OG9jWFlUbjZIV2F4N0dQRzk5Tkd0Qkl4bG9yMzFRTzk1Unp5Mmh5RjluNWtNck9mQjBWRWpqU3N3ZHpmU3JGdXVZcmJnUUMyUWNaeVl5Y1RpMTZiOW5NSmNCUzlqMTRTWVM1dHphZk8zdnF3cTVkbDYvOGNuYmYzVndvb004dU85QVg0SjBaOXBqWWJjTU9mM1BaSmszYnNIYkdqS1VERnE2Y3YySDNIT25reFN0TWx4MVMvaHYvczlEQlh3S0xPR1o3NnlEMmNOcGsrTkZDSEwxZkcrdThyenR0TWxqbnJjbk96MUVSemFsS3o4K05CcnlFT25BOE9TdEhSVFQvRUQwckovZTV6ZlErelhkSWM4N1daZGlaOENETE9SdkVjOHJaeW5KY3BsQzhnc3Qwa3N1YzU0SkptZHJPcy8wR3VNd3ZOTTk0UTRhdmljWDVURmFQZWtiVG5PYmdQZVZQTEtNc2QrM2JESU16U0FqUTF4T20xak1XZnNQb3FlSmF6eGRxUFdOaEc0YkxXOFcxSGttdFp6Q3dQL2VzaDlWblUrc2JES0k1TjZjOWN2OGUwL1Z2UCtFR3MwV2dZN3IrN1NmN1V6Sjd4aTdWTHRKSHVBaDZzM3k5ZXJ1SU5GYTJZNUF5MlhqUHdXWHFDQ0ZLR1ZiUFZxVWVmaUozQjZSU3U0Z2dNcnRJWmExZFJHZ3FEVlBzSXZ6RXNkN1VMaUxLZHBHWFM3VjFybGZyTE9DK0I2MUpTVjh5cnNRTlJEMWpLbjlDYWN4VzZ5d1lLSkNTY2JUT09DT0ZtM0hXK1ZpdGM0S3pUdEdsVGtybnk5Sk90YzRKTDZ6emtWcm5lTzRTU05iVnFXczdwck5FclhQOGdMOTBkYXB0SitOb1NKVEhNUWE4eWYwQU1renllSksrOTlYWXJjallpbi9JWXhzTjNoeFN6U1NQTUNrWlY5RitkVktsZFJ4M0diekJ4a20yWDRXNTBEcGJwWFhjSUxOdW5KcHEyKy9ocmRZNWlic0d4dXZxck9aUzUwbTF6a25ER3VqcWZFVlhaNXBhcHhYWDJlNUZkUnA4MVRxdHd6eGVVR2VBV21jK3JyUHpDOXQrVnEwemY1alJmZHZwT0RWUng0bmFGYlhqWkhRZEo0YzZUdDFHcDJySFNXZG5QSWkrcHZtUHFjMlBydGRkbkJlTjkvaWM1c0dpZGo1NmZ3b0hWUnZoTHRWRzJFZllxYXhqdlkyUXJ1TzJjaGtyVzhjYTdIVldUNEphRDlaeThOekRaZnhFRjF2ajd3bytPMGdmRlVCS1dCUkxvMUxQZk1vUGFzcjg0RGpqQi83RVprbENHSjFyZ3RpY3VsQiswRll1TzR2elp1ZjhNdUs3MCtiVWp0SzNYcTIzZ052TjFpKzFoWkl4ZEs1ZmI5cmViSVZPdm1BQ1hiK1J0TlpJbzYxV3FiUE5iMU9lVUZQbUNYS2RKbHFuU1Zzbm9iVUQ1UW1zemdrdnFMTUg1UWsxWlo2d2kvRUV0VTVkK3pHZEpXcWQ0OGYvcGF1empsSW5tUk9VSjlTVWVjSSttU2ZndVVGR3dLU3hCNU41UW5sQ1c4WVRKakdlTUlYdFJKSGFzZm9DQ3k2UDZOeXB3K1lGbjg3bWpzQkRwYjVsdU14UktVdkJXTWRsYW5NR1drWlF5eHhIWDRJTU9tZnJzTG5KWjNBQ3ZyK0M0RkpKbGZIOTErVDdkZWxjTGtDSHFmMUh4Zy9DMUQwdGR4QmJEdnFVMm9Gay9DQjhmMTc1MzZvOTZKUmlnOEx6OXlFWVJYMXdlQytGQm1vSGtzYkl0aWRTWmc1WGpaWVJlS1VNcStlSVVnOC9FWWlnTDdWUUNiSXRxNmJPcnBRakRWWHF3M056RmNWdzNSNHU4cTVsV2IzNzFIb0x1TDlBVDFLMk9xMjNPb0h2VS9rd3BiTy9XbThCTjUvamFWbGFyNjRzcmRlamtscnZoQmZVUytqTmxIYW85VTc0eDNxOTFIckhjNCt4TkthdFY5OFBsZW04N3lLWG5WZitXRmV2cGgvSXVCcmF5dU5LNXVsVE1OSWtqeThaQzFxL1BGNWtyQ2t2NlNLWFhjUlZOY2xqVHN1SzZyaTlVMzVYTEtPMnU1YXlYRlVKeTB4RXp0T1AvM2RFRmdTdFpLejFtWW9zNkZKUHVGcFBTNUFLZXBFeTBhNzEvS2pXMDVMN2t2SEthTmQ2ZGlqMWdENmlFZk5MTi9XUStRaGE2ZWRqaFhyaTFYclNRU1hRaFpTcEpialE4MEN0SjUyYnlabHBHVTMvb0dOaW1kU1QxVVBYVFJtbjlQRjN3a1gyckdZOWZZeU9DSHZvZW4xWnZ2K2tIT0g3NytGOTZnSzFTM1dYNzdlbjlYeU1hZGhEK2NUTGNsdktHWi93NTFYYjgzdVlsMTJnZktLN1hHWTI0eE1CemowRzF5TWxFaGthYzFrMlJyZVpEQjNPKzJ2cUVjcG9ib3MyY3BucE11Y1NmUFgxV05SNldvTGFUS2F2NWxyUEtiV2VsdHpuVEthdjdsclBMcVVlVFBPdnJGMnU5WkIyc1hxYzdhcFFUNEphVHpwM20rMmRZWUlMUFZmVWV0SzU2V3ozanhDZDlhQWpVcUtVek9xaC9YOWJHUmVoVE5qSG50V01DL1d0Sit1QytON1ROdDRIM1VtZG5yemE1OHkyZTBxeDdlSXkweXZvTmhGNGY5bEw1OE1yY3YwbGxFOWJVQzJhTDQwK1MrNkxnZVg5MWZmYWxQZmlQckZqK2NmTmUrbDg2Q1dYYWN2NlRmdGVXaytzV2s4NnR3VjBaTGtQWE9pL291WStTRzlKZXkxRWROclB5enNUZmlZVnFQeHNHenJMN2NLbGJEWGlWWjhERzl3cS9NWUhHTnZ3R1plNDF4T2JrWHU3NEZieEFidG40M0p5bm51dkR0cklyNkpXNHhaY2JMbXZTZUpheEJJOXJKa25CNDB3SE5hRlFvYVNoeUZkU0FBbXFUSW5jbFUwRmtaaUNST2N4OVZWUVNJZmFFblBmYlZwdm5BTnZJeSsyT3IrV1hxdVI1NEZ6bWNCT2VwT0JDYnlzSmlOdmdKMVMraXo1UzhCQ2ZENFdTTkg0YmlkVDBTeEo2VCtyOWJQYjQ3dUFhOVR1RTN0OGJ1QVZObjBLdjh5N25mdUVHekdrU2ZWdzk4QUF0WkJlSWlRQUQya3lzWm9Qb1gyYlFwSGZPUE5tak1ZUXAvQnVWL2c4ajYwUE9VVitGcm1MSy9VVFBNNk1wdHNlbmt5ZUF6OE1kMlZ1QkE5NVNUV1NtQTVQbGtUZ3RXR0pGb2Y5RzliMzlvUG5RVXhPL0Z3ZzloaWNrWkVNQVVvMXZwcmJpeW8veUw0MGNzMW95RExKQitoQkRPYUlvUUkxTW1LMm9NU0s3RHhaOHJpK1RPRHdGZzBtNDM5R3loTHFFZDkyOGRvenRSOTNiM3lmd2cwSVJaQmJlNXJFd1VyOThlRTFnSXlvVEt4SkRwQ3FJZGFqMFBkd0VieU53N3NRNjN4WHhaWWs4MFBIMEFvSDFDMmlKMWZ3V3BRNUQvamZDajJqeGZCL2pHVHVDVUNPa2c4UkpNV1piL3haamI1NDMwN1ptZDNiSjdXdDI4YUh1LzllQkN2Y211TjBad3BrUGhobXNBMk9nL3dmV0dBZWorRzNTZS9rM25FU1VUMk5ReWcyRll4WEJJZXVjN2NtOXk3bksxTFBJRVFxaEJyb1VZRDgwR2hMSG1WWGVKcG1KWW5PZUd6R1V2dDVpQWFsMVdERmNBclA4aFlIS3ZCQytLTnhRbWFyN0ZHV3dNS1Z0dXNGQ3NheGE5cWZnbzFGbmZVd1FyUmZxQzRHRXB2eU5oZlFOZER6dlRWTkF4TzkwMy9HNGdCd1h6YXFzTE80eU10RXp0UFhyMTZVcGRKbHNoeG5hYXNjdmlzS3B5OG12enhyL2Z0MWFOdjMvU2VmY0dsUHIxNjlPbVRucDcxTEpIYzY5ZXpSejlnYkE4L2J3LzZUOXJhc1dYTGpsc25wUlp1U1czWk1uVkxJVCtsY092V3d0UkpXN1pNS2p2VmZXSkJqOVQwOFJONnB2WW9vSi9HcDhOYjNRc0t1cWQybjFUWTdkbVBkWVdSZGZGWWpSWmFjTmVseW1ZSmF4TXFGMUI0RDFtb3VFeWgwQWhjb0dXSXczaW9DMzlTNTdmOEFPQ0djaCtDTW40ekhta1BMZ1JQNnNwNFBnRUxTQUtKdDBIQUlQUWRpQmtFbzFFQm1HQUdFMGo1YkZ6K2tWcGVvdVVUUVNCK0pIc1FpRUhmRFFJQi9HWTAzWXltZzJtRW50VjQzajBsdmptY1FPZVZBRTdUZWR5RUc4ZW5pVld4N090Skl5WmhmTjE2S2JpNzN5YjlOWTQwbVBHZFZGaVhUOFh6ejR0bHJSWGpkWWUyOXNraXlMQS9JSmRtNUdJa0YwbjBsTU5RdEdCV0xHTUFYMnIzOEpiVWcxc1NCUnBJZ0FBaVlnZ3d1U25HQUQvYXRHa1lxaXFBN3llZ0dpQlhxc3lucGg4Ky9CcWM2WGdiM0lWMUtlMFQ0RHZ3VjNFdjVoK3pPSnJjd3RXTXBXQ2syTU5OQk1pT1hNSk1JTTkra0Z6d3A1SDJYSHpaY2RWMDN3UkhrdDlIMnB1U3kzM3krM3h5dVUrZUtTU1hjUEwxQWZrRUJCclZZbEx5YVBob0xRL200SXJwa000RXhFeEttN1lndDMrdmprTkRSb2hiWnJUdStPNHFKSUQ3K1lOZWIrczR4VWZpOFFuRDZ6K0x5aFMxNkRud2x2SVAwV2laUjllbDUrVHZhWEk4dVlabzIvMzkrRmk3bng5Qmt5U1hwdmhDY216cDdEc1VKRjhiSE9oQjBQdElhWExKOWFlUWZqcVVvY29VV3IreVBnazJ6WXhDRGlaaWFQSXpvczZBNEFESmdObG5VbUlUa0VTaUMrbGZmUjNZRjhrYWd2L0FmSkFZeDRPeTE3M2F0QUhuejBqSFBqT2NzKy9iei9Nalpsa25McFRBZXRSYkFoK0ErNkZERGpmTHp2YTdhUTNOV1p0VGZPck8xMXVsSmJOc1JjWDRHNTJQZTdBTUdZajNEZ3ZXb2QvbG5FRmJTcy9vVXRYcnpNMXFNaTlndEhIcTNnbjBNZDkrK2oxRElDaTc5cEFxMVpnWEJuazBzcFI0MzlUUUZLcG1MSzdqNHV3VWFER3B3VHdVL05BaUdTUVc0cHdRSEJTY2FBS0tKNnlBZnZzdHRWbG9TZzMvNmwxalJ4WitVR25reEovUFdjRnJQMDBhWkZwYjlzbTU3VHQzN0RnbnBxRzdmUjFOQi9jUXBSNCt2Z3ZlaDU5dEdtcDFsSWkyY1RuTFFLQWo2OUNjZVo5Ulh5bWpNSTNJRk1SWHloakRid0Vmd1VaWWxtM0JiUzRmZzNjc2U5TklNcXNqUVFialBaMndMbklLejdGWUpic0dCZDEzOVR1Mng4YndzWGdmMEczNTN2b1p4Um5KOWhwTHR0Y1N2NWl3bVBnWUxCYkc2S0dJQTJrU3dDQ1NRY3dGV2trVCtVUkRnd2tRQmZtcjc3UStTaXdCVHdTLzJISGw1T1lHSStwN0pvOXBkQm5kMzRqL0EzNlhHK1EyODB6T2UvbVRMNkRGY1FWYVlLRDUrRDJUYWFDZkVVUStNdWRzeUlsNkNDeEd2OEZHOCszUFkzSklhQjJKaHhhbjRiYUg0dFkzNEJwamFkL1dNTjcyU254RmYwTEZKa1dRaVZYWmxId3hVamhpTTlST2wrSXF1cTlrR2RVMDJpTFV4Mm9haStNMUpTS014Y202TFpUbTFZbG1vZEE2UkVjeVgvVGJhS0orRzhXOEc4Nkd3dnpSNDFhdnNvNVpJTUR1M1RwMTZkdnY5WTdkUU9WVmt3dFhyNW8wWlhVZnZDMzI2ZHV6WjE4a0VqWXZlRW05WjJ5ZG1EclJOck8zMUxqYjVLNnBYU2QxYitSSW43UjE2NlNPaFZ1MkZKTGRzQ1BaRisvSkd3S1JRMy9sWDhiOVZoWExJejNkWUZScmdpYU5MR2hTdDZDQ1NXSmZIZENXVWM5bFBOa0JqR2lRY0MvZytaQkVjamdyN1lZR01sUE1MUHdnMElSWkxqd29GZTl1TUtGNXF3bkpNL01IdkhYMGsxSFRRSlA2TFZ0S1l3dThvWGovYkxUWlB5OGdBSUxpRTU4c3FGMk1kdmJxWHZTcDRGVm40SkE1TTlDcnNLMkQ3dG03T2M2am5uallHTW5WZThJWkxWeUJhQ2wzbUhqT0tMNVZIc1JWZGtHanExRnFENi9ObGhEdWp5eCttZEFTOHlNL0xsaUpMTlo1UHFtaU5jbEpoS1d2eXNFTU9ZYzRidklrY1R0Sk5PQk5IWHo4Q0had3NWRXpQUUlJajQzaExUeE42RzdHL3pQSjJEOUpFZnhUYVUzaU9xbHQ3ODNTMXU3dEhEZVh0MThOSm90QkFFM0dyQmFOaENHb0IvalljUXVjUTNYQXVkYVUxcVhsOTRRRlFrY3VrS3V1MEtwRElWWDlPbFY4SENJTitrUHQ2QlFIUVoyRVhVVTdmYVBvQWs2U1Vld2pXQ2J1RkVCMnd3aFRIQkRNM2ZablhrS25RY3N2dndiaERpNWxibXJtM201b1FmdTVEV0cxNUhkNnB6UUM3VzVmQjJub3hLMTR0RHVwd1N0TitOck5HNkM3b0hyOXhtU2NKcFUva2hxSmRzelpQdUtpNFF6OGJ6c1FTTFduVFh3YXA5ZkxmR1c5YkNoKzVwQjRDSmRkVi80RUxxSFBGTXZQbkhNK1F4ZTU4c3d3L013OWNSc3UrM0g1UFRpUFB2TVRlMGJnbk04b1BySDBtWUg0bVhUNnpFYk9LRC9UVUg1UHJ2TVpoYlBnMlFPNWZsZ2ZEeE4vNVFKa2p3ME5JQ1RGSkdNUk96N3hkcU9QUWZaWDFUcEYrYmc2UlFsWWgyQ3BBNWpYUTBvMGpER1RYTHFVZytLbEEzNEZKaENCZnZ1NkZEMzY4OEtZSTBrQ1FOOFZyUDQ4K3VpQ2pSc1BpNzkyUnpQUXhjdVAwSmZBLzhSdndOaTdpK0FBbHRlZWZzV1ZIKy9hYis2TjdVdXZVZmxyYTdtUHNKaGlGRWVwVkN0UVA3ckU1WnlSWnBzWEZUQ1N4VlpISlN2Lzg1OVM0eWRIcEk5b1hVM1JuOEpLWEpjM1Fiem40M1ZyQnVzdTFFOVhNaklYT0YzZG9pc3FHMWxSRWxsTEJQT0FDQ1dlZ0xndUFMNnFZeGYvNWJPMXNLZGp2UkJTTmc2Mmh5MGN3VG05ZUk0WE1uSWNKcWFUcm9OYitkdDhBSmFIL1FrZDJzMk9PVUh3dDhzKzVWdkNyVG1zZkROVmgwN0F3b1FleEZVbm9oRW9jUzkzbVJOb1JpbXNwbjhiS1ZuQXRBSlVLZXZQRmZkQjJOU3B3c0tubmVCaytoNmVtNEQxdjE4b2JqRFIvOGE3d1liU0liUG84SzVVcEVQSmsvQml1OW5veWJBNHRObHA3UkdTV2ZZYTFnbzFzYVgyT0RNVjFFTkpJaFFDZ0FnVmhVNTFxNkVRaUlFTUd0a1FHRVRpczVNaXlMYmtuNUlVVFFMZUFnMi9QRDFWOHJCdDI0YzdUai81KzZ1ZGo5cTJlMVJ5OGtuK3R0VWxWMEtyWE4xWlpIc3llZXNIMnkrSFJWN2FVYlFWUExxTXZuRnMydVFBY1pjN1hnYng1UnMySW5UbThyYkhhUGZ3MnNQUXpvZkZ4UTlCbTVHMVI0TVdqN2R4b1B3ZDFBR09rRjdDZTFHbXFnZlFEdkRDODFBek0reHJpUGhlRnd2eU8yeW1ReWJpTldvaU1PR21waWFZWVIraEN2aFo1SUkxOEpFa0pGMkhzeXk2WkN0T2Rnb21nYURXbW5uVmswSjlqRTBDdTJWOXREaWlsY1VZVWplODc5QWVjaERvMU5GaXZZL3NYcDVaa3FGd0JPWEQyYUM5WU9idjRURk54UHFaUFNpVWo5MWhDem9VaElscEZvUkpXRUF1SS9DRkRKWEdLNWhxOElvb29VTUg0dWtlWWlSQkdmWm1vYmh0dHRCRG9UQ2paRVRvNU5BRm9WZ1dDOVc0Z1pJdjBUUlBVbTFORlZpYnI2djVXdHRvU3lRdU5IaUlrNE9DR1NObndteE1IREJnanM0Lzk1ZmMrSUxtclp0bDkyemV2Tm00ZWg1MUM1cTFhTkYxY0pOV3pjZlY5V2UvOUc3Y3ZPbjRlZ2IyeS9DR3JacU5yOHQzYmRVUlZFNklDK25ZWmt6cjFKQTY5U3VEdE5ib0IzcXpidVUwZGpNNUdIUnFqZGZlVW00RmYwRTRpdlcvanB6ZHp4djNudEV2M0EvM250RVA1QkVSM3FoWGYveW8zbW4wSmdxcU55N2hiV1RJa3ZxTThFd1pqZUNKbEJtVGduZFlNMTcxNW1ENDJ4MTBlUk00N2ZocmFhT0pOMEhFUnBRTXhmZGY0VGNQUmw4UFJuL0dYaDhNNmcwR0liRjREL2lBZy94UC9DUGpBS3pWdmNITmFNWTFlQS96LzR6eU1zY2J5a21sbWhDUVlxcDNrcGdjZ1o5ZGlKLzlnVDRiZ2ZkbjU3T1AzVDBya0djRlZRWkp3WXppTk9aRklwWkNhajB2a3BzeUJhcTY4aXhxamNTSFdFQUVpTEVZUENsRCtpWUx2STl5c2xBL3ZpcjZ0b1pVQTEwQ3RTeFNsR2h6eERocXdRc3cvTTAzSGRjY1AzYnRTdmpmM1BKc0VNUFozSjZqR2l3cG1LL0Z2UDVxL1p6a00yZXRsRVlzUGZKcjhGb054cXQxTFVlU3VsV0llTkRsOXFPcW05dGtjVlFSSmwvTVJwZGt2UFlzZ3I1MnplT0JCMW5XSG5oWkY1SWI4UjVOeVkyNjVNWWFjc1BtY2NnRE13SE9BMVNJL1liRWxrMXpHU1pTUER6dFNnOGxaeFdtQ0N5Si9iUmp4NEdOTFdlL0d0QjRaTHZ4RXgwTzJNcHE1Uy8ybmYzSnA5VkRCNFJVbXpwK2R0K3lta0pETXE0dGNMdVBTUzlobmF3ZFBYOUpneDl3OG4ycHVmTStQMEJ6UDBlOUg4TzFJL2ZKY3lMK2hRdml1cU9SaHJ2aVZxek5WZU5xYzQyNDVsalhTK1ZlNXpLNFBsdzJONGdieHVWeFk3aEozRlJ1QmplYm04Y3Q0dDRGVlRtaTJQRHhCYmF4OFpWcEg3YkhmZGllN0xBTHUvQ3g5cmtMOEdYcEhIeHB2UVJmbXZLWTh5d3cydDZpNGlsUEhleThxSGc2cWRRV1htcC9FSTdYa0svUlZyZVVwSzU0RTZ0MXBmYnlHTHJ5OExaaGEyMjBOU20xdldLME5WVVpEdjR5c3RRMnZOUTJ1TlRXb3RUVzFHZ2JWV3JMTGJVTktiVzFMTFcxTjlvNnFMN3RhUjJJZzM4SFhGc1hveTIxMU5iQmFNc3B0ZlV0dGZVdXRYV2taUWVVMnZxVjJqSkxiV21ZbExGa1RNZmk1VkNLTDdheFJ0c2IrT1liSUsrRWU4UDRSdmdiL0VqYkhLT3RzTlEyMTJpYldtcGJhTFROS0xVdE1kcG1sdHFXR20yejZiYW1VYmdDemFaRVo2WXR2QzNyMVM4WkJFQ05aQ1dLZmlJNS9VakNDcjBwSXRBU0dFVnl3aWFCUUtiZHgxak1SQUtSLzREbXMxbFIveFZkbDB5MktNMW5Qbmx5OXNESmszTnlwclRjbjUxYnAyYmQ1RUc5MExRT3pacTFiOStpYVh0K2I2L0JuZE1IU2ZDTjVJU2FLVStPNWgwVmEzNmUrL2N3a0hSVXZBZVNjOHQ2VFVwSVNvd1hTMEdRSXgwRU9ucmh6ZHZMK1hsL1JzTlhHalRPS1BzOWovNW5pTXlsLzRGemZjZU42enNpYThLRUxMUWJSblhvRU5QRXo2Zk5TNitsZ2JhdDB0SmFqV2pkc1dOckxKelBTT3ZWT1ZXS2V5bTVUdG1Yb05HSnZMd1Q2SmdVQmtKSGI5dzRHdDNZV0ZheU1iWm1kQnprMjQrbS96MTVtYjJGUDFxelprdzRPbHMyNldsWjRKTko3QjhpNDRoY0w4ZDV3d1dQdmxqYXFjNUZjdEY0WGdkejl2RHFlQ3JDQ0h6aGZQQWxzQ281YXZma3hmckpLVTBBMHdERFFDSTdkTU1ENWdzQ2d5MkJpVHhlb3VSUHFNd2ZMR3RlMWtyd3ExS3piZStOaTkvK21PY1BnMGF4eVkwU2E2YzFPbkhpUkFmaWx5RklYY3JxbGRYanYvNDlxWEdWbUxjNlRsNDJkYXFVV0w5cFVrSnF0WlNlM2RNM09WNFR2T1lLaE4rOVFuQ01oYm5Pdk9GVStqZHF6M1NOTHNZSXZUVFBHUWgrb2wzeW9xRmF2RVE5NXowNWlYclplbEptVFArZkNPdUJudk5RRnRnNkQ2MUE3eTBBVzFIbWZMZ0ZYSE44NXJDRCs4Z0VPOEttVEFadGkzbExCMHlUTjBHWFYzZUlDbVJVY2tFU0pMTmVncVpBUzVMUlA0Vkl0aDJPYkxGK3VkbVJ4L05DemJ0b0xicTRadytJQXRPUFpXTytYWWgxRkUrYTE2MHE1amJPeGxiWVc3ejBMcmg4aFJSdEJMRW5CSkFvTkg5VGpLekJzM1VrZU40L2YrNlBCK2ZPLzI3ZC9OR0htejc1OE1OTk1BbmRSS1dnSGdnQnJmRmZBanFOYmdWYysvMzNhMmpwRDQ4ZVhtWHREeTkvQXY0V2QrQVoxRml2K2VrM0RWRnpicU5ORzJHSHZNaGMzUzBtTVNrSy9HMUZhOEJGZzlnNk5yME5xYjk4RGJvUHYrUmI0aDJ1QnRWekRQRXZnR1NzVzQ5M3dXRE11cW1EWHJ6cENycEkzekVYZFFDeDNFeWFJMExScGVqSUVSbFdoM2tkRmFnVlFoc0RFS3VSTzJkZUk5TG1BTkZyNG1pbW83VkdVOEQ3ZUNXWnFVUVE3NFRyTHZhQk9nWE43Tnk0VXhqWGN3cTZtSVU5VHUweElDMDV0WHB3MWZxV2xEb3RtOVJPZkx0MXB4NGg1dGQ5L1pQRGtuczFJTythaDFZQmlTdlEyUklBZ2NpVXJGYjgwMVd5Lzc4amZBOVBTa2R3T3kzY0RTSXdCTVVUdWNFZVpPWmp5VUdabjBKR014OC92ekMvZUwrbWZtbCttWDVTQmp0c3Qza3J2NWY0ZVlkNXgzdnpJKzJIekZpZ0x6SnZNMk5CMTg4Y1pvNDM4eGtsQkpDNEVIK3dseE0wNVNKY3hENlpYRXJKMTBOQitGTVJ2cFQ0QllVRnhRZVI4a0c1UVlYNHc0NmlvRzFFQUM4bnNuY3B1VXpHNWNpaGR3aTFuSVdxN3k4TnZSYjZJSlNudjRVNzc0WmZDMzhRanUrR010OXorU1JQM1N2TXRHUEpwSStwbnh5Y0hKUVNsSndFajBCcDViUVpLdzJ3VjgrK3ZYdjF5MmpWNUsyWGFpYTNTRytkTXZ1bG1KZEZtNVErZW5TNjFEU3RVeE1BMi9mTmFCam4xN1lmQUprQU5LN0wrdlE2UEdBZ0VlamgzQnpTcDBiYXAvaWZGL1pvU2FIZmZMOGlQejdQWGs3TUJTNzkyOHlUZFhCVGIyR2t2ZENJdXpqTm1Ha2tYV3dNTThZYmNjOFdHVWxjbmhFL1NyeVcxVTArUkdON2QybDhURklURUpPVUhHMUpvY3phRDhBU0tDMmIrdFl5QSt6Ukl6TTkvV0xYZHFJd3ZMTmgyckxlSFFCdWR2Y1JJN3BMalY5TGZjVTBSSWlNbHFLakdyL1d2SEVUS1lXMitTbzhJK1hqTmdkdzQwbGpBMWliL3c5YVMrU1hnRkpjNFk3TWdOd0FtT2ZVdFhDZHRQRk5qYVF2cEF3M0xTUlpFT0dYVUhwL3hzeFZCcGpScTIvdjNzTnorUFZwdURVOVJvN3NJVFhwbU5iNGMvRkxLZ3VQRW42Q2o2V0RuQWVXNGZhUlF3OC90aGFJS2tPb2c1UkdnNFpHUTVpQkpMVVNNckFpcytPK2Q3azNIbzlNNzF6dlFtODhIdHV3WXFPc2lnejdmVzhpOStMTGp2dCs1WDZrbkYrdVg2RWZLZWRIeXRIT0llWDhTRGsvcGc3NVV5VXB5RG1iZzY0RlBRamk2VzhoenJzaDEwSWVoT0M3UWN5N0dCZ3NNZmovVVlrcGRISWJvdW5reHJ5RFR1N0hNUC9MTC9JaDhCbjA5WnV2SkkrcUdSblg3TTFHZGNmSFJNWUx2MGc3ZDByM0xyVkk3dzVoazFvK3pRY0EwQTNDK3JWWTMvQ2xFbWJjWEdYdU5kSTNubXg4WDl3bk5MbTlPaFBWY2JPWk5IT1NFWnVTR0J6RDVBYzJGdzJCQ3FGb3hrT1Era3JHcStMb3Q3dTB4Q1R1M1N2ZEd6MUNESTJ1R2RXK2M4dG16UXoxU1o2UGhYVHMrbUQ2dkxuMkd2bzg0Lzk1NU1qaGRpWE5iNVhDS3NWWGFscUpPTVdvWFNsYVloSXhSZFAzN1pzR2dXRTAralI3NTB4TXpDZWZTUGQ2M2NMOTB4ZjN6NWZ5KzlzUWM2eDNQTVVoODQ1bngyUzRXam5iRUg2bFJCVmR6T1JGbWtqQlUvTnV6ekRQZU0rbW52VGRpU0o3TzBnMFdNRGcwY0FBcCszYk54M0NIMmFWNUlqZjNpTXZCL20zbUQxNHJMQVgvaUF0b3V0dkJubXJ5blBzQndVOG82NFNVQUlkOS9GVTFxT0FHU3VaZEEvSXBITmRoNVZzM29lOFM3MnZlVC93RnZQc21ZVEZwQmxKWEozTVp3STBhekVnTENBK29HbEFXa0JtZ051MVNFWVo2NnZpdW5uejEwdXdkNytoQXdlOE5XWS9YSUxYNHVBWk13ZEpiYnYzYk9OMWxtR1dMeE5LUUxJVS9HSS9KSE5Lb2lIUXNxeGIyNXI1WXRPTGwyYmlma2pDOG1BNmxyME1XQ0pzbzdIeUs5S1hMcUJRTmRjQ0ZsQUk0bDJ0akY3VWY0WW51VXN0NUY5K2dPT0lkU0w0Yml5NFVPQVlCWDU5S0lHNnFGU1krMndVV0FwejhFNjdBY3QrditQMysxSWtoTEZ1WkZKRi90R2RoZ0I5NkhpSU1aeFpObmVraFdTR1lKMDRNd1RyeDJFaDhTRXdZOGY4a0NKOGkvMHpVcXNsMnozOFdNUjVvaWxDcHk3Sm1XZGlMRkdLZnJNQmpENXhMU2RqNk5Sdjk2QURvTVgwUlhNbitxQURaY3ZlWDc2eVRKajczc3IwMmFHQks3TlhyWVZocVBXb29YM3loY3hoZzRaazRYRXBMTDh2VkJKV2NhRll2MzJoYkt1WTRYVDlxY09YRkJpaURwc21CSG1ZYzJOYkUzZ28vbkh5SzFRT3dGZGYzeGRoN3FiVkt6N2QvOTdxalNCUDJuMFVlSjcvOHh6d1BMcExtclBnbTNVUE41eVpzNURsUFJmTWVBdzhzWlRWNkFValFIcmRTeTg0NmlRNzBvME1YWXYySURYcGJRQnp2d0JCNkpjdjBGMFF1UFRNbWFYQ1hQUkg2VGRuMEVPaFp0a3JGejQ4KzhFRk9uL0pQRGhJOVpLZUd1eDYxMzdTblp4TE9odTMzWXVsUHZHS3QyZDZrY0gzaXZmU2c5ZXJ5T2YwangvbzJBMkx5dTd3d1k0K3NDMnNnMTd1TDh6TlJvTmtXZzdRL2hqMmdoVmg5eENnRnVVL2pKekx6UGNnZ29aSHBnZVpjQjVGSG5qNmhYbkVrMzhPZW55TmIrclR3dWdRYnhYSE0wcmNBQUlXSHVUb0MxK0Z3WTQ3aExBM21hNUE1bE1jbmsvaDNFQ3Vvc3FtMFdKc2ZxWFVvWUlvTlA1NmhVWWJmaGpHVXpqOE1MeHJoeEhJZ3JDME1OeHJPb3pQS0FYcG1wcXgvWUI4aU1SczNjVDNUSWlMdmJYNUIzUVBtQzUrZTBPQXVaNXJQbHAzNnZRbms5ZUhvd3RnemZ2TmhwRnBkeFo0N1ZvakNoTW5uZnZvNGZxenpXcURvQng1M0lXWDZiaS80V2JjZFkxejZ5bUhSNEdvbmdWNEdDcmJqYmozdFFmTkZOSldEVlFXWHJZNnNxeFd1TVlLUFIxL0NYTWRQOEl3WmU2Qk1Fd0RyL2c1MFNGMmZTMnRMQkdFNWVmam92UzV0UEw3ZkdmOHhham9yYlNvOHB3YVUrOVYrdi9WZHVWaFVSemJ2cXU2cHdFSisrYUFCaEJSUVpFb29zR1lLMG9TdVdMUVJHVVJBVGZjbFVXRmtTZ29Lc2d5Z2lnYVJVVU03bEZnUkV4OHhnMDBhbUlrYWx4djlEUFJHM1BOalQ2ajJXUjZYaTNkVGZjd2V2TWw5LzB6TVBPZHFhazZkYzc1VlhXZCtoMThkVjZWWmRQdUVReThycnRjMDNoWnc2YnE4K2VXYy9yV3ozYzA3OS9PTDg1YWxjVklmZVM4U1p5Y1lNRW15VW1UeFpBdFY0U1Y3NENUMHBnTjNud3diMVlteEJid2JjVWNRdHFLWit3dTFPbnl3WkVpS1BoQUo3Z2FhbzNmSWVYOUJPMDB4aStNdFJxNWYrd2sxRCtOOU9UV29zK29qNlA4YVkwT0h6alUrSlp1Q25JLzJvNm1IL3JQUVhvK29ab0xNaHFMenlja01uRlZ5Z2MrazJaSUVXYXJGcHBYaWdhRkNjUVJPSkdqYVBpUUIzdlg2bmhoNmxnaG1kZHQzczNlZlRhUDNRZGIzMkZQZ3RiQlpLS3A3aE9JalViOEtSdkY2eGRJMWkvV2hHV1ovallZZ0V3eUljczRGTzB1NFZFK2l6MFBXMFBSelBlRDdEbTZSc0crSG81ODNmeVpoUVZ2Zi9FekMzS1lTaDJZY2V1dXhvdHc0WmVyMTRSZmdQWFZxOEEyNitUdVhjZU83OTU5SEp5L0liUUM3c1pQMTRCR2VIWU5ORFExTlR4cGJEcDVpUFpyTmZjKzZwZEwydzE5Y3BJbjlVcytyMlBKZVIxT2pWQlNNdHFZMTFkekpSWEpGRkdtZlNmNzl6MCsrc1JyYThkYTZ1bUVyYThmSEc0SURMVGNYUkhmN05IOGVhSTllNktDK1UvcXI1VHJRZDdJNVdjWklCYUhhM0JFMFJiNWlwY1NiQmd2OGJCUm5RSWtsWW9UYVZiY1BkeEVsaEpjTkU2c0YrZWpBLy9UZEhIU3BPa0pOdmFMWCtMemRFSWxpRmhYVUxCTytBUVlCWmJUNzZtYVZPVFh1V1JHVnQ5UkhpNGRKL2FiUDMxK1NscHFxZzdiNGd3VWM1NGkzWGVYUmtLVUxZMkVKTkVTelhlMmVlNnRjbFk5SFoxSkxsaG54M3AvMVVqNjRXT3dVSFVPbkNzK0p5T1BWbVFhUkhaeDZmRnJwNzlyT25NSHJUVzJyVjVmdWV6c2xjOSsvdks0OEF5OWJ5N2VkQUQ0eFV3TENTdlRsK3c2Vk1PbmxXVEd4YVdFaEswcFdsMnpzNEZma1pVcFBmODdSZGFnd1JiOFM3WnlzK3cvb0VqVlprOEptVHBoQmJ1WTYvSHNHdGNqaGNha1RjaC9FbEc3VGt4L0MvRlpGVFBsQllZNlREc1J5a2RGcVY4dVVYaHkrU3ZoU2RablZWWG5rTE1hVDl5NGNZSmxXNDJsTzNlV3NpejkzWUhJM2hMSitpSG9QOFZxeGVrNmlrN2ljVG9JZ1NIdXZEdlFMUkVDRmdnQlMxdWlock5IbjgwajhURWF4Y2ZqNkQ4M0tUNnEybGFGQjhJKzRXZ2VFcFUyTGxhbEEyUVBRMWltVVE5Y1FseklLL0JqdS90WmthWDhubzY4eDQ4TEhycnhYamR5aGRQemZuZmc3WXp6aEU5emdMdHVJWnZaV3Jnd204MUVjWFB0c0dHdHM4V1krWjdwQWVkRzhqNHpMVlRCSkFsNnhNbThITVJxUExqZ0RpbkpRMHJaNE5OUEpkbU1BOTVhNEFXbjRxalg0QlpJRWt1OEhPdDhTRGFlbnhwaXFiOGhzL1dqZFZ1bEJYNDdGayt3dDdobVoxV2wva0FhMVB4MjlQUVBlVm5GUlNibTdESGhSMlRESnpkVUdRN3ZLMmExVzNKV2J0dGV3Ty81NXNyUmFRZDdkZjg0NStTdDZ5ZjQ0cnJxZFJ2VzBIa1BRdlB1aWNadnpmU3hzSW9tVDlETjdjM0FjRmJTazNOQXVLV2hINWhiS0VSa0NjTldRbGU0ME5oUlNBQjc0VGU0L1Nqa0o5ZUpYYjNGdEcvU0VzWWFPQWFLR1RjSzF6SFlhT2lQRHNDbk9JUVo0eDU4MHBvQnJ4di96cjQ3WmNvbzlscktDUHlNQ3NXYVcvOFYvT0hGdXU1NEZ0VFB6TmxiM3g4NzhhL3ZqeDk3b051dTE5ZnMwSmZVZ01vemQrK2VBYkduNzkwN0RkYlYxbFVJdXlvTTlldW9qcEVPUUFYcWswYnlhYkxNYWdlLytGbDVpNHFKVEhwSWpoWnhWcUgrb0NMckVoak9kWFdZNWt2YlRVYTZUVWJ0ZWtwK1JZaUMydTFCbFV0bnFDVm5IeXhsZW5KU24wNDRrZUxpSHFTQUFMNnBFUXFrMHg2bE9RSVBYemJaeUlDRHMwY3RtSityUi9aM3FhN21rMlVGd2xFSUowNEIrMmNYRDV1WlV6S0xYM1htd3crbU54WUp6VHp1NjJRMEx6bW9yNEZTRFN5UzlkVU9mYlUyUGVpbW1PeUdEYVZhdkRVaDIyTnhaNHcveWxCT2xZRWxGR3pQSXlOUkpUaUszQ1JBM2pVclZyTkszckcyQWJPelUrS256cnhWdisxZnlLMDJMbHEydG5obGRmV3lSWGxMMDlhbVFmNW1kZDE1Tmo2bTJNOW4xWXpOaGcrcitXa0Z1VE1XcEU1SlQ1bTBLSHNTWDFLN2kyQTV4b3Fma1EvZ1BQNFJGaEJRZGl6STJkQjZqdXJEZFZJR0UrQ3F0QVpyVzJpV3dJL0JSRXJnWnoxdTM5WVo5MEk0Y29ueE9EakRlNEhwS1lJUnNNUFo4TmFic0FDR1VydEpSM09oUi8zeGxtb0JxSHhlTG5jQ1ZBa3dCbTlTcjg1Z2JRL0VIYVRHMjVwa050RVA3RlVzYi9oc1g1VWc1NFhUd2xoTVllUXVLaDVLZXNjWis2VnZ3SlhHT3ozN3ZKZTQ2N05QdjloMUcybTdZbEY1Y2RHaTdCVXZRd2JxWndzWi9yMVo5a3k5NFdMMVp0NXF6c0x5NHB3MXc5K2thODRDTko1RzRnZmRtVGdMcUNsVnljS3hXQkdnRGZhdWpFaURaMnVQS1kxVXViR3U1c3NrUlM2Q2RQSkpJMFJYRnpRQU4yazBNQ0t5OURWdFdIcDA4ZUUrTmJNYW1yNXRxTHNQUU5Yc2FxOXRPVXUzRkhHYk8zcE85SFE5V3JGMXlJaW0ycHJ6dnphRFYwLzhabXhKaU9wVTBWU1pzYlFFY3o2am1LeEZPT1RKeEx5bzBnZnMrQWQ5R1k5YnF4ekxDMXliMDdicXdOZkw1MndzM3ZGaEt0VDhmUEhJbmZYNVFpcUVQNDZIbmRlZEdWK3cvYU9OZkdQcnRVYmRMKzhMQXpVa1R5NE42YjhPNmQ4RHJWV0RtVm0wejZReVFEdi9EcklobFZXRGtIOEg0UjFkVUhDUTJTcVY5UXJDbzNJSThxS0dydUlQZFhPczcyNitESmM4T1ZSa0hDSnVLNjM5OEdwUCtiOCtkZnpzdk8vM2YveG9SZHFrOUp1N3E2K00zYU5iVWx1N2JPRU92NHFaOHpkc21qOWpEVHRsZkhHWHJoV1R0eGdNVzZaVWRPMVNOTDZpWnJ0eDJOVGx5NmZPV3JJRWxpVm1aVXlha0ptSjdDNFpqYnRNdEx1eGlyclQ1bmFuUWpjclZ6dktqV3Jnck96TWpjN096T2o4OFJNcGVvMkJBbEZiS1FUTS9oNHFEUTE4czJKZjMrckVneTNmTmhqdVAvMTRxRDdDL2JVRjc2UnQ5dG4yWGs1VjhaamEvT3J3Tjg3dDJISG44VW1oK3VBL1BUdE8xTHFCaHZGREk4by9xWjJYK1Q2T0NYSG9KWjd0aFRBcVRJRlJ6aFl4Q2hlOFVwL2xja3FZaXArekZnQjR6Q3JSQTdXTEZzdXdGclhyS2EzOWlTMmJ0MXV2aGMvQktFTUF6b2pCeGcwdEc3Y2h3QU1uWXozSHBCMlFTY05hNDZmZ3RiZjdSNCtNVFpvQytjM0xGNjFLbW5ZRmdwM2pnT2V3K09EdzZERkQrWWxGQzlPanNpY2VJVmcxei9RVW5rSjlEbVR5RlZqbC9GeXNha3pXcG1wenRXeGlZNjRXUDdGbDB4c2N0TjRJckJvdmFHOXJINkwzOVIzaEN3QUxxZ0VML2hYQWdvZUdEWTRjc1hQRnduMGFtREoxekxpVXhNVHM3TGl4NCtLaUprK0dmTFZ1K1VZWU5UQko2ejV4Mkp6c0JYUDV3YU5HRElsNk0vNnQ4TmVpaGcza2szUUxjRHdkZzV6YWx2VnRoMWZPTDhBcitFZnhTblhoTEdQRGh0bkN1eHpZbHk1TUJuMTRMZURHN2RrVEFmc1p2d1hsdU9nOVlKYWl1YmlDK3FMR0ttZExXS1ZRY1J0SWVWc1QxSkt4eWxyQ0txakdLbWlPVlZiUHhhcjMrNEo3UW5abjM3akJpOVpWVk9iczFNREpVOGRPU1U0ZU8zcWNLMGdDVGNtUDNEdER0blJSZHRtY1dieFZSR1JjN0tpazNvRmtiZm9VL2tCOFFZMVR6cFp3Q2xyQXFRYkczaEVYeXZXQ2FweUMveG1uY0phVkNxZkF0ZjR6QXQwRHhvUk95T3U2SUdwcDJaNzg1ZnRPTEl4T2RVcU5pWitWeVBaeWRvcDFkRmlRTkxWWFNLRXVvM1JQd2RYbGU0WDBRWDF0a25WSmZ4OFZ5NGd4QTVhaXVWSG53SmhiQ2NtQlVWMUdSSjIwQjUyQlgyZy9rZ01EUy9VTFo2MmVJd3lDQStEcHFtOVA1ZWFlQnU2ekVtZ09kcTZvTTRvdE9nVzJ0UE5IR1ZzYWs0TlNnM0tEMk1RR2h5QnZoQytOdVVHbFFWVkJ5QTI5WUh1Z0lYOEkwRUExME1DL0FEVHc4dHZoVWVQMjV4VWRTQmdaRVYyVHE2c2VNLytkZUoxdTNPaDB6OG1SbzZiTkdEbHNNaHo5ZXBMV2ErcVF1ZG5aYzRlbWVHbVRYcCtXa1NINEQzbjMzU0ZEbzZQQmdZSEQzaHcwS0RLU3JuSFNrUjR1aWJZelhvRTE1clpUejBBTFdOT0F6MExSNGxtQ0hLaUdIUGdDeUpGdUU3ZURuUEtFVEw4NWcxZFc3aWxZdHYrandyNHorcmdHamgzODlrelgxTkd4TTVOR3podzdOYkJYeVlLTXlsMzVEeGR2ZG5LS2M3WUgzVjRON0o2WU9UTnlSQklkVTVucEtZb3p2ZHJ0MVp3dDdkWFUxNlE3bWsyT0lvOVEvUmlPdGQxZldscTdmMVZaN1p6MGlSUG5wazJja0FhOENqZHZMbnhRVUZWVkFKSm16MDc2WWNMczJST3dQUytHKytFZGNnK2hKNzZIWUxpTm9NZmdnRjlHc25pamovOExSaS90THlqQU84Wk5jQXE5b01BeWRkd3NPSUt2WkRqR2tlbUV6MlBzZzVFM2hOdGM0RzV6RHprVHg2Rlc4WGx0cnZpU1lhakNMdy94MjJRTzczaTRaQTdObGplSG9LL3R1cVM5WTUybi9NWmErYkY4UUl0RHJJZVZuMVcvL3JMakQxQ0VMbkJtS1hzcVdaY1FQamcrZm5CNHdoc2hYZjM2OXZYckdzSlg4cWUvR0JJZlB5UThKaWE4YTk4Ky90MzY5VVB6azhPbHdueTBEc1c4QjY5WTRLS1hLVTZCOG5aZWh4WVUrRkZIWEVMY1dId2FiT1htQjk2YnV2M0NJT1BTOGU4V2N5VWd6RTA0b1QvOWVTR3hnVkZvclJ0RCtPN1ZXR1AvSi9aRzBOYkMzaWhVMmh1bDM3dVhaWXlCVlhuR09iQVRId0srU2hIS1FOb2JiR3VyUC9zR3dHZG9SMHdQdUU2b0w5NjRibkM3MFQ1dlh5UmpUWjEzaTRnemVFNWNXdjc0bHNqWmpWendVRUE3eHBtV2QyQ3o4WU1CQTFha0hiNTM2MWJESXcyY3RiUDRnK3B0cTR2WCtzSTFiT2RVNDI5OUJyQ3NpYm4ydGZEcjJWUDhtazNOaHo4NEZUK082Qlh6NGZRbWV3ZzExdGovZis2SjZEZ1lMZWpIcVBkRTY2TEt3N3pEMHFLM2ZUWG9jSHJ6M2FmTlo0Vm40T1hkQ3cvNkhsOVhYcnRIYzZxTHp5U2ZsMXZQTDQxT0VoNWZ2eXJjQjcyQUJxUzJncjhaTitaTW52WGw0M3ZiYTYvUXZFUGtZQWZJblNVbDVwaGJpOFc4eXc2QXRmSWI0QW53M1FMMndJM3Z1dHRtZGVqeDA3blcrK3dhelhEaHZ2R29VSlNkRGViQldNQlRQeDRrREdjZmM5RWtvK050WmkzOXZaN29KM3BLeWZFa0h4NnpZdlIwckF0dXFRdFczVjNDSDBaSWJ0SGdFT0VkZ2FCYmVmcnJaTjFSTEMyaHVQMWhlUGtWc3F6dGFoMUJtRmNkNjhOVVRkWVBWODJBSDNsbUwvSTlFSUpWN1BpY0VxYmsrcjd1SHI1QWtoUE5UTTM1d0Q3ZTIrdVZmKzd2SHVuckUvQldXT1BCTDRXNzM1Mi9OeS9CcDh1cnZXTW0zSzN2RnRrRmpEWTIySG5hdmpOM2E2WGh4cklTWWZtMm5FWFYxVGs1VzltcnZUT0h1cTg2MWFHRGRuQkEvNTdscTNJdWJ0Tk4xQWU2RHduNlc0Si8wUHA0OS9XbmJXMWF2UUIwejRtT1NWc1RHemNaNWllVmxTVzVwNVNYcHhCOTV5R2JmUjNaTE1YNkdRcXN0My94UHRJUWpGNysraTZTUERmL0ErRE91WlprRnRRSVR5OWVFWDZ0WHBsWjlQakU4WjlIZnJGaDA1blRXemVkRFRoVVVGeFhYMUo0Z0F2THJPOFJjRHkzK2RMRlUwdVBCZlNveXp6UzhtV3J2bWpmdnFMU2JSK3d3M0oyYmwyeHRMSVMrZXAwMHdQMmllaXJ5bjJrdWEvK0YvYVJrRndRZGRiU2NtTHRRQjNhNzJnT1BURDM5QlBHZE9TU0lEeTU4ZmJtU1BlSUZkUHphdjBQVnVvUGZUanExb1hHeENuQTd0Smw0QzM4Vy9oZEdHMFV2dmQrT2NXM0U3VEtuNVI1NGViOTdWdHZTdWRYN08va21aZUxkTjVtOGZ5cXJZNko2a1lRYTE2d1hENmtVaDlLSFQ1Mi9mb3huTjJ5cW54MUtmcmJJSXpnOUo5WGJ6dVhzbjV1MmtaUzkrTUIxdy81c0RPS0hCTXMxQlJWTWQ2bzZzSXJLcTJRN0hHN0R2aHNUUlhSTzZodTg1RmxMYm1oUjh0OXVJU3dMcUtEMFN0NTBJM1Y5MjRxTzNuelpyUCsyQ3RCbVJPblp4b0RObS9KM2Q3WmMxUGhsaXJRZjRNQitQN2toa3Q1R0NwQm1QRWI0MTFnYW43dzNhR1JIekltNGRrRndxUEc3WWU0dGhJUFlnbXYxTDlwSG94ek4zWVp1Zkc2ejVSbVNzYzUvTWM4TU4rR0IzWU8vSi9KUTd5eTlPZStJNTEzb2UrVUV4N0lmVkYza1U0TmpDMitEb1ZmZkd6bCsxUWtQd3ZYdTJLWHlMeG1uY3g0ZTZuTVAyUVp6S0htVGpoSnpXVWVTVEpnTEZPR2ZBVHp5N0lhdGN4RFdRWnpsamtUVGxET1RLWkpsT0dabVNrdUttWlZxWTRZa2VQOTViYmltUitaMFZqU0RmY0pWMGYya2pta3FLdzhSblkvOHp2ekp1UEtHRHc1bHRBZU83YmdWNThXaVp0R2lNUTVWVWcrajl3cHlnWUxUYy9RNXlTSGlPaHF1YWlyclpLdVpMNU1Ldk1QV1NZVEpFbTZNcE41Sk1yd1lPd01UNlVFMHliVEpNa3dNLy9tb21JbkZmVmdPb1dBdGlmcDAwcmFKOU4wMmljRjV5WithR1FrZlZwSjJzcnNTbnBrTFVvUU8vc1N5YlNTUHEyazgyZnFRK2VQWnlWZVFCUHFFK3hKK2tSL2E2YUpaMGl2ckRGM0owNkcwTFFvK2kvT3RWN2lZcFBtV3RZRHlUOGd2N2xLMU9kNXBwY1pEeWVWK1VHV3lRVEZURGZLOGFlVzRSbEpCbURtcDBEQ3FXZmVqa21XU1dDS21TNlVVODlNNXBJb2czUSt5MC9GNWlseHY1RnpYOHpweUs0UisvMDc1WFJVOEJkU21hOWxtVXp3RWVXUGREZVgrVjlKQnZXN0NlMnVMTWsweSszTVJMTkpxc2U1YzdoNm5EdGV2RW82SitlRG1xdElkcjM0bTRtTUU2bnAxOGFqUi8zcmtPekw2VXdoNWRGN1NXUG15ODlrMzRwbE5qQlI1djR1NkRnOWlURkxDSmZmT1BnREkrblFsc3hYbnRpSEhEcGZ2cXl0VXMrMlpMN3l4SEVYMHZueU1aUFIzSkJsNHNCb2NVNDVzM2FnTEJQRFZGTDc2ZExXRHNrOXhQeTFKSDd5SU9aTjRoMWFGcGo3MmlIWjE5SW5FWTNZYWRyNTR6UFpaMk16b3A3anMrY2szMGQ5RHFFK1pOZG04N3NFSGM1RHBESlliOEJEOGQzSGN2c3g3NUYrT2luYko3bDVSRy81b3Q3eXFFNzgxSGJlbTdlVlpXS1JuUk11VVg4ekdhTGJmTEdmSTJnN3ZncGZFSHJqUEVBcTQyakZUZ1hqaGJPaVBsOGxQbHNnOW1FVEkwWXZ5Y1pNSlNoTytCUGZwN0Vrd2RTTityNlZ6RlZxV290aytoS2QwMWlTYnBKNGdHVWVVaHpiSUVkMFR0dUpOUTJrZG1ndHh5VEdTZENCV0tMUGxiaW1IeGpYU0hXRlkxNHdtUXNTODBEY00wL0tNc3kyNlhNazBrTlh6VzBrVTBqSFF0aERrWlNMYUIxa3ZnYmd2RGdrVXlUcXdVYTRpTG1JY1Q0YTVoeG1pMmxNOVRmaGIzWVFQWVRPcVJDR2M5YW9EUDR1ODcxd1daeHIrWE1uM0daWDltdUorVUk2QVJleHlFd1d6VldvMFk3aDhjMWd3cWV4UzhabXZlaHYrOXJqalJDRzg4dW9EQm5EQXFrZjZMdVA1UmdkdzV4alZGWW54OFJQNWZpYnpwVFNPTlpKWXhaL2JlWFlHc3RVVVp0ckY2TTd5akxqVWN3TXhIR00yR1dkdjVJem5lUlRrVEdWaVdNS3BtUHEwVGJ2ZUV6MlpFeGxvbTUva2Nka1Q4WlVSdjFvQkJsUkFLdVlkNUxqUkdMVWFySDlPVFJHOVdKdHBQYUpEUEcxMVJTamRZR1VJZGhHMFk0UWlYT2xxQXhaSjB3bjZ3VDZYU2kxai9SYVJPT1NvdjFJWkJ2eUdvM015VXVrLzJUdHB2bFJXcnVCbUFrZGFRUlh4QUdLQ1k5azNFaGdQcUljdm02YzNENlYrVWpHalhUbUNPVnBkZEdZeWJUSzdjUXluek1qS1A2b1pmaHVza3c4OEdVSXo3OFhsc0c1TVcyMVU2bXNqU3c3SG5SSGVFWmtyYWxzRy8vNUpvUWZpV1Q4YThRNG1FTStKL2xIWkd3Vm9rOUcwdmppeWJwSmZhSTQ5MERFT1RRMzA5Mm9qcXpiZEVSbGprb3l6TXpYN1hGUDdBaHEydEdMQkZpTzVMd1FXM3RmdElXaDFOYnMyekNUeXB5VFpKQVBldEErMlhKbU1vOUZHVFJ2eWNUdUhGZ3JsZDFaeDNLYkhVVjdZVmR6a3hqbS93QkFMVHZDZUp4allHUmdZQURpc2c4MXp2SDhObDhaNURrWVFPQnk3WlcxTVBvWHo5K3JuRG9jU1VBdUJ3TVRTQlFBWjBRTkVRQUFBSGljWTJCa1lPQkkrbnVWZ1lIVDV4ZlB2MFJPSFFhZ0NESmdFUVFBaGJFRlF3QUFBSGljalZjTGNCWFZHZjUyenptN0Y2UU1vQ09GZ2tDcEtDOEZMWUpGaFFZWUFpUm9CRWRvZUVoNEJBSVlrSVF4RUV5aGlOZ2tJTkdFZHhKQ0pKZGFLTXFBUVNKeE9rQkJxeTJkdG9qajJCZGFpNlh5VUtsV1ovdjloOTE0dVVQRU8vUE50M2ZQN3A3Ly9mL0h1UUQ3Y3k2RWVBdVZiaHFLOUdjWXBuT1JaODdnVWYxdlpEcVRrT2YrRkNWdUNkcXBtZWlzVjJLTXN4cmozTkhvNy93TGRhb3ZidEsvd0ZOOHA0SElJYVlUSTRpZHhBWWluWmhCVEhSZXdpWm5QNTlwejN0TFVhNXZScUdxd1ZoL0xMSjFnSzc2VXpTYWJsaHBocUpSYnlHMjhuOEJ5a3djalc0dm5OTFpTRGVkZUg4Z0dyMlB1YmFieUVLaHZraWVqa0l6bkRMOERsUDFxK2hycHFCT2Y0eXVmaS9jclQvRVlQMHV1dWxqbU9wOGhPM3FGdlFqUTQxSHVzcUQ0NDdDWkoxT0dmS3dsVEpOSStmcUxwamtia09LenVkMUhpcWRFOWpsbkE1SzFYOVFKZGQrZStyRyswU21mWS92dUFmNC8zck1kdVBvd2YrYjFCbjA4VnJqeCtRN2lPN0VUOXhhREhjTzR5VnlDN01FYTYzdEQyT2R6c1FTWFlaaDVqam02OStncjlPQUtuMFMyYW9STmQ1TXpGVS94MVBxZVN6VmsxRW90dmR5TUV2bElFZDVXS3Z2dzBOcUdCWlRuMFh1VU9SeDd4cjFKaDUwTG1FSHY1L2xCSGhZYmVMNzFWamhkVUMxMTRYWWd4SjFDUE9zM2E4Q2Z4VGFpaStzSHhMZzlnb3UwUmV2RTRyWDc5RE93eU0vSkVQM3cyVHJGL29pRWRZWGgvQ3kzb1AxMXU1WGdYZVlNU0srb0I4UzRSd0xqanJIc0pIOEIyS25ybU84ZmUySEsxR0NWUHBQcmpjbFFueWhpN0ROc3VpYkhzWmZBbHZkdVgrenpCZzFMWkVyK3ROdnVkWStJdU0xV09KWllxcFpacXlMUG1ZbE92QzczV2pqUTlTemxFeTlnM0t4djlpQTloL0dPTHlSZkl6MmlIdnJjRXJ0d3k3SkVlZVBRWW5raWNTcWZoZzF6SmNYK1d5VjVBMTVoYkNieldlRmQ1SDdvTDNiRmgzRmozYnZKTlo1d1RtekNmc2x6cTFmYWR0azlnc3d6NStCS1pLRGtnY2hGNFQ4cE0xTDVrYXp6SnkxZVNQOCs1RGp1TUhHQzMzMmJWbnlYWEpPWXN6Nk44eDd5YjFrcGkzcTNNcmdpQ2xIc1Y1Q1hSYnhHd2RZbzJpL0tBNGtEeVFXSlk1dExDWEphNStWdUp5SFRMVUExV280VnF0cEtIYitpYTNNOFJkYzhINGhjOVZnbGJzVzljQlhyWWxxNE10ZmtlZVRCNURudUQ1ZVUzL0NkdGxYOHRZZytNUnJoYmJ1R25Reml6SFlEQTNLVFFZbXVMT0NQVkd0MURrNGFKNUZYeHRiMUVsaVIrU1VXaW4rTjdkalJGUW5kUUh5YlY3dTVQVkYrMytJNkNEMk1mV1lLRFhTck9INnZYaGM4dHJhYlRuamVpTG1TZ3k0czZ6L045dDdyK0pGcVcwMng3aXV2c1FvR3ljVjFGR2VrNWpMdzEyMkRzbHpOOW9jemRTSGtXR2ZHMmxyYXFidEEveW1LY1JDUFJ4RHplTW84TjdEU3VyNGl0M3JjaDV2bG52Nkk4YlE2T0NrTnhxRG9scGtQdUVlWW9OUktCRy9pTjVXZHVaQWJDdCtHS3RCZzVlTGdkWVdVcU1NN2phMTdCRzBINi8zTnRud2RkWUpmczl2aWZiNjE4elIzZUh6OGw0bGVsb2J4c01hRjlyUDFnSHBNL0xOODlSRDdMY1ArODA0OW9iWnFQZUxVZS9kRVh6bTdjWkIvUUgybWxSczgxTnhVcDltVFpNNmswMHV3RTQxbFQ2dndBQ0pJYTg3T3VudnNGY1dvZGJpWnE0dFJ5OXppcjFVL29zOUxyUHRVK285OUpNWU43OUZydlFZdllacktYalVtNGhhYnk2cVdKKzZleTdmVFNWR1lvRzNuRHlCdlM2cXAvbkIrM2Iva2V6MWpHbmI0MWhUcGM5NWY4WVB2TlA4WG41d3pzckJmY082V2V0M3hDKzlDc3J3UWZDVkhobjh3KytCdDgxRjdOQnZNbThIb1lQdjRZem40YmozSk90QUhTcGpPM0RTbjR1NHZnbjU2cStzRVJKbjlMWE5xVlhVNlN3NnEvT01rOHRzV3FTaE1EYUYrUmptbk4rRyswMUhxZDEzUFd0UUc5citkc2JRMzdDYStiT2RLR0lPNVJGMXdCZXRpSjQyNXNWV29ZeW1OZjJ3a2pKUHgxNjFuTFV3QjcycE8zUWxEcXIvb1VwOGIrMVAvNHNQN0p3aGVuK0lmZnBCMUpoK3dTWHQ0anB2TVRMTVNOeHA2elMvSDJ1REJ2TUdxbUszWXEvSEdtc3VVT2JYc0RqcUV4SWo0cWV3SHZWcFlzYUwrTXk3UVA4TlJtZUpHL0dkR1V1ZWhRM2t1T1NLMXhJOWRYM3czNGdseHB0a0Zka0dVVGJHcUkyVDdZeHRxZHVoYk5FM2Jmd3lodXdNbGRUbm92clcxSjgyWXBrZWpOVVJKOXRGYjhaamdzaStUUnoxZzlDblRjeTRsOWlUUExHeG1zeWhqSktIRW91U0x6Wm1TOUZSalViYnlFNU5YSTQwbWJXOElVanova0xPb0M5NjREYldqeXo2WjZIZmdCUnZBZTcwMytDTXVBVVYranllMXQ5bDdZdXp6bjJQODFVcSt5eHJWbVN6eUE1aUk1bnBvdjZSek0zTkNaYzUrUHliMTc4RlgzdCtHRVZ1MWR4Nk9BZXNKeDlsSG05c3JrK0gzTFhaOWFnWFhvdVQrMi9ZTzYvRmlYMzVhbXl5Z2d4OUF4RHJ5ZHdNbWZNRDNKYWNreWZ4SGpQZDdjZnJHaDVlVGx3K3c1aFYyT1A5REM4TE9PUDJrVjVzTVkyWWo5SHVER1M2YzRnTTFwcHNubTlXWUx4YmdUSzFqYm5iRFEzK1cremZjczdoK2NlZGhubkVUTFVGbGFvQzkvRjhrcTZtY083ZWlpNHluM3ZGT0dEbnZmNTR3UHlkTS9jQlpNYU9vRjZmd3lPbUhjcTlXanpCbUpublA0VDUzaEhPQ2RXWWJsS3dtM1ZtaUg0R3orc3BHQnJMdzFMWEQ0b3B4MHpkaWVlZ25zeVJXM2tHYUltQm5CdEtkUnJyeFdPTTQ3Tkk4YTlIaXVnWXV3MFRZZ013U2E3MWJOeEQyVlAxMDVUM1UzUjFnNkRhT1JHVU91OWpoUE1jMXFncUZLdGx4QXFpQUl0MEN5eFMrY0U2NnBIRnRjWE9VYzdkRzlsenBySEdyT0NacjR6Y20yaER2TUwvN3lBdU02VzZoUHZaTytMY0syN2VKV0pjUDg3MXQ0bG5lWjJGT2V6aHFmcHpiT0VjL2lPdkhjWlN6NlU2ZzNORmY0eGhUaGU3OTJLTU9zNTU2d3ZPQUdsODlqcjIrazQ4THhheGpuVEZBdjE5OXUwWUpxaTdhTXR4bEhNT3hxdlpXSzdtODkxenZKK1BJalVMQ3luM00rb1JMT05NdFVjQlQ3QStQTUM5R3NoMTZpSnphQ0R1MFkyY2JVdHBjOUhyQmZaRXptRzZMRGhySVhLS3pzMUI3TkE3dEVNSTlzSWp0TU1HOGduaWEvMlRJZm9uUXZSUC9uWWl5cTdjcHdsaSswUllQd1FseEhPaExHMUZuZ1MvYkJUZlJCRDVJbHdobi9ncWd2Z3NFV0tYeUlkWGdmV3A2QlA1TkVUc01PYjhIdzVYTFZjQUFIaWNkY0Z0VE5JSkF3QndEODJJak13akl6TkVSVVJFUkVSU1FrUlRNaUpFTWlJek11TklQU05EOGlFRkJNOHoza0hrek1nanpzeklPREpQZWZualhHdk90ZWFhWTY2NTVseGp6am5uSEhPdU9lZmNjNStlYjgvdkZ4WDFQL2lvMnFqNW4vZy9yWUUwb0ZIUUFtZ3ZtaFl0akpaSDI2STkwWE14c0pqeW1NRkQwRU0xaDREWXRGaCs3T0poeW1IT1lkRmh6K0h2WURTNDV3anhpUFRJRWdRUGtVTDhSNk9PaW81Nmo0Yml3SEcxY2NxNEw4Y2d4K3FPT1k4ZFFPdWg4OURkNDZUakRjZUJlRkE4TWI0NTNoTHZpcCtQLzNFaTRRVDVoRDhCa1NCT0NQMU0rTmtPUzRZSllUYlk4a24weWJLVGt5Y1BFcG1KNDZkZ3AycE96Y0dUNFExd0szenROT0cwN1BUNDZlMGtTQklyeWZSdjd4bmtHZE9aU0RJM1dYSVdjWloxTm95b1I3UWdkQWhyQ2pXRm0ySk5XVWdKcCt3ZzRjZ1c1QURTalZ4SDdxWFNVMW1wb2xSVnFqMTFPeTBtTFRFTmswWko0NlNKMGxiVEl1bWdkRmc2T3AyYXprNnZUNWVrYTlLM1VGR29CQlFLUlVaVm9nUW9Rd1lrSXprRG4wSFA0R1UwWm5qUk1EUWFYWWhtb3V2UXJlamV6UEpNVG1aRHBqU3pOOU9lNmM2Y3lWeklYTU5JTUQyWUFZd0xBMkRtTWQrekVyTXNXY05aazFseldkK3lOckZjckFncncrcXdRMWdQRnNET1laZXdHOWo5YkdnMk1wdVlYWjdOeTI3TVZtYXY0a1E0R1U2SEc4SjVjQjl3SWR3S2JnTzNud1BOUWVZUWM4cHplRG1OT1IwNXZUbURPV001TTNna1hvTzM0OTM0R2Z3Q1BvemZ5WTNLamN0RjVGSnlHYm5jWEdGdWUyNTNyaWwzSlRkQ0FCR2doQ1FDZ2NBZzhBZ2l3Z1Foa2dmS2crVWg4M0I1dER4T25panZBeEZCSkJETGlEVkVFVkZPdE9iRDg4ZnpQK1l2NW4vUDM4dy9JTVdUMGtna0VvUEVKd2xKcmFSdWtvM2tKTGxKTTZURkFuaUJwc0JlNEM2WUtWZ29DQmZza0NGa0pKbE1acEg1WkNHNW5hd2gyOGx1OGtmeUlubU52SHNPY2k3NUhQNmM5TnhPb2FCd3RpaXBTRmxrS1hJVmZTZ0tGYTBXL2FDQUtUQUtrb0tqRkZLYUtmT1VsZlB4NTh2T041N3ZQajk5ZnBPS29MS3BWdW9ZOVNOMW5ucFFqQzltRlF1TEI0dEhpc2VMcDRzL0ZTOFdmeS9lTE42bHhkUGdOQ1N0a2lhanFXZ2FtcVVrcmdSV2tsekNMT0dXMUphTWxMaExsa3RXNldsMExKMUlkOUJINlFlbGdsSnBxYTUwcU5SVCtxRTBWTHBSMWxBV3VoQjdRWFZodDV4VGJxK0FWVEFxMkJYZWlwbUtPUWFOd1dEWUdKR0w3SXRqRjc5V3dpdTdLL2N2Q1M3Tlh3cGYrc0VFTTVPWU9LYVZHYmtzdWl5N2JMb2NZWUZZTXRZcWEvTUs2QXJrU3NlVkRUYVZ6V2JYc3lYc1NmWjBWVndWckNxNVNsTFZVYlhCRVhLY25Ba093RG1vanEyR1ZpZFdJNnJSMWZocWNyV3llcjA2d3NWeHhkd3g3czVWeGxYSDFYQk5aYzNYYTlocnhHdU9hd2M4TksrRDE4MzdjVjE0M1hsOWdnL21zL2dEL0ZYKzVvM2tHNmdiMGh2T0c2NWFlbTFsYlUvdFhPM0J6Y3FiOXB2YmRlUTYreTN3TGNHdDFsczlnaGhCb2tBbVVBazBBb2RnOURiMGR1dnRwZHNidC9mcm9mWGMrb2s3Q1hla2Q1WWJCQTNmN21MdXl1NnVDbXVFSDMvQi9lSVgwVVViOThidVRkd0RHdkdObHNaUUU3d0ozMVRleEdtcWEvcmNYUGdyK05jdkxZS1czZnZNKzRQM3Y5eGZGeWVMQ2VMeUI3UUhuZ2V6RDc2MVVscUhXcmNmaWg0T1BKeVR4RW9ZRXJ0a1M3TFhGdHVXMElab3c3YVIyeXh0RVdtdGRQb1IvSkhra2ZLUjd0RmFlMW03czMzM1B6cFprZ3d0SThwb01xYU1LNnVWRGN1MlpRZVBJWTlySGpzZnV4LzdPNkFkRFIwakhlNU9SS2VtMDlicDdIUjFBcDN6Y3J4Y0x0ZkliZkt3Z3FuZ0tSb1VZa1dIb2xkaFZkZ1Zic1dNWWxHeHJvZ29kcFVRWmJLeVhibWszT29DZGNHNzhGM2xYZnd1VjlkbTE0RXFYb1ZXVVZRY2xWRFZvcEtxZENxSGFsTDFTZlZOdGFrR3FSUFZPSFdabXE5dVVjdlVQV3FIMnEvK3BGNVNyNm9qM1pYZHp1NjE3cTNmV0w5OTdhbnNBWDVuL3o3VGkrNDFQWWw1SW4reXBNRnJsSm92V3BxV29lVnFCZHBtYmJ0V283VnIzZG9aN1lJMnJOM1ZRWFZKT3JTdVVNZlUxZXVrT3AzT29adlVmZEt0NkxiMVlEMUNUOUpYNmdWNmlWNmpIOUpQNk9mMHkvcHQvWUVCWWtnMjRBMTBBOWZRYUZBYWJBYVhZY1lRTXF3YjlvMEpSb3lSWW1RWitVYWhzZFVvTjVxTVRxUFhPRzhNRzNkTlVCUEtSREZ4VENLVDNHUXlPVTBUcGxuVFY5TzZhYzhjWjRhYlVXYUNtV3BtbSt2TkVuT1BlY0RzTWdQbWVmT0tPV0xldDRBdFNSYWNwZEJTYnVGWkdpMGRGb1BGOFgrN0xCT1dhVXZJRXVtRDlxSDdLSDNjdnVZK1M5K0NGVzlsV25sV1VUK3VuOWJQNnhmMzkvWmIrMGY3SXphZXJjRzI5WWY4RDl0QXdvRG5LZndwK2FuaDZlWmc3Q0J5a0RKWU16ZysrUFZaMGpQaU05R3pIVHZISG5sT2ZWNzdYUFo4NHZubkljWVFkMGd3SkI0Uy83bmt3UDViNmhoMTdMeEF2ZUM5Nkg3aGYvSFpLWFZ1L2NYNWEyVVlQeXdlOXJ4TWZFbDhLWGtaSGlHTnRJOU12NEs4a3J5YWZMVXdHanZLRyswWW5YMGQ5WnIxZXNRRmNVbGRUdGZ5RzhnYndadWxNZkFZZlV3MzVuMGI5MWIzTnVTbXVJZmRlMyszLzczc0FYc2FQT0YzbUhlbWR6L0dNZVB1OTRudkJlKzczNjlOd0NjRUU3UC9FUDRSVFNJbTdWTXhVNVZUNDFQK3FkRFVwaGZraFhuUjNrSXYweXZ3U3IwRzc2QjN6RHZ0L2VJTmUzZDhzVDY0RCsrais3ZytvYS9kcC9FTitUeStENzZRYjkyMzU0L3pJL3hZUDlYUDl0ZjdKZjRlLzREZjVRZjhjLzRsLzRaL1B3QU5KQVZ3QVZxQUUyZ0lpQU9xZ0RYZ0NJd0hwZ09oUURpd0EwUUJDUUFLSUFNc1FBQTBBM0xBQkRnQk56QURmQWFXZ2ExZ1ZEQWhpQW5TZ3N4Z1hWQWM3QTdhZ3FOQmYzRDJ2KzBWaGxBQUFBQUFBUUFBQkJFQWx3QVdBRjhBQlFBQkFBQUFBQUFPQUFBQ0FBRWJBQU1BQVhpY2paTFBUdHRBRU1ZLzJ3RUVCRlJvaGJoMVR6MVV4UGtEdlFTSmdoQWdwSWhEcURqMTBDVXhpVVh3UnZaR0VaVjY2S1U4UW85VjM2QnYwR2ZvRTdUbkhucnJ2Wjgza3pSQWtXcHI3ZC9PN3M1OE03TUFsUGNCSGtiUFUrd0tleWppcmJDUE9Yd1VEckNPYjhJRkZMMkM4QXpXdkpmQ3M3VDNoZWZvLzZ2d1BHYTlYOEtMV1BBWGhZdDQ3TzhJTHlIMHZ3Z3Y0M253UXZnUlpvTkVlQVV6d1h2aFZSU0R6MVRsRmVZNTIzRUtjL2FvODQyd1QwODN3Z0VxK0NSYzRKNmZ3alBZOEZhRVo3SHVuUW5QWWRkN0p6elB2SDRJTCtLSjkxdTRpR2YrbXZBU1h2dE40V1c4OHI4TFA2TE9zWjRWTEFRRDRWV3NCemM0aEVFQ0M0VTJOUCthMUtLdGoydWtpTkZCMTYwZTBXWTQ2eUhpck1aY3F2emkwQ1JXdGJYVnFtWDYxMm5jNlZwMVpFeW5GNmxhcGNvTlRaNDY1N0FjQ28ySlJ6VE51YkZHTmZJaitiYUlDd082MXd5TFp0UVo5RFJoT216OVFXZDFFYlRKQXk1NGZkcDduVW8yLzF2SkdTT2x5TGljRjBiUmE4aFJjZjYzT0xZbjZkUG5XWlJtc1VsVU5heFdLdFd0NnJhNkg2dDBQMVpwa3ZXMHBKaFJsV3VBcFFMTmhrUzRjdlc0cE0zZzRrNGJ3b24wT0ZOYTJWUzNveXVkWGlweklUMElieGRRaW9NN1h2SjJYNDBYdzVZaDcxTnQ2Z1JaZnJVcnhFaHNYaHhMZTE0YzdIZlRPTE94VGhTRlJLbk5ESTE1dGkzdVM3Z3JZaEtLYlUxY01xbExyZXR1MEI1dm1PYSswZXoybVExYTdyYWhScUVWT285YlVaSkZiVFZJMmxHcWJEZFNlMzNkNGs5V050UzRKN1dRKy9PaVc0YXFvOHgzNk42UWdmOEdEeGtnWlMzS3JNYTBpSXlXQm81WmlnT2M0SlRmMGxoRTE5cCt2VndlRG9laGRzRkRrM2JLdlpHQXJOdzQzajg0T1Qwb09RSFRMWloyWWZwQy9QTW1QSFE1L3dCdkgrZ0JlSnh0MlFWWUc4bmZCL0NmaEZDc2R1N3VkejFpQk00am01YVdRbytXcTV3R1NDRnRTTGhJN2R6ZDNkM2QzZDN2L3VmdTd1NTM3MmJuQzFtNHQ4L1RmR2ZKekh4bVpuZVpaQ0VoNTkrL1h1cWwvK2VmWjRMOXdpU2s1S0VxOGxJMWphRWFxcVU2cXFjR0drdmphRHhOb0ltMEhDMVBLOUNLdEJLdFRLdlFxclFhclU1cjBKcTBGcTFONjlDNnRCNnRUeHZRaHJRUmJVeWIwS2EwR1cxT1c5QWsycElheVVkK0NsQ1FRdFJFWVdxbUZ0cUt0cVp0YUZ2YWpyYW5IU2hDVVlwUm5DeEswR1NhUXEwMGxhWlJHMDJuZHVxZ0diUWpkZEpNbWtWZHRCUE5wamswbCtiUnpyUUw3VXE3MGU2MEJ5WHBhcnFJRHFaRDZCNDZsVDZqUStsWU9vck9vU3ZvWWhZNmt0NmdnK2drK29GK3BHUG9ORHFjSHFKMzZIczZsNjZrbitrbitvVXVwR3ZvQ1hxTXJxVnU2cUhqN1pWNmlsTDBPRDFKejlIVDlBdzlTNS9UZkhxUm5xY1g2RHJxbysvb0JIcUZYcUtYcVorK3BLL3BDRnBBYVZwSUE1U2hMSjFQT2RxVEJpbFBCU3BSa1JiUll2cUNsdEF5V2twNzBUNjBOOTFPRjlCK3RDL3RUd2ZRVi9RTjNjbktIcTVpTDFmekdQcWIvdUVhcnVVNnJxZC9tYmlCeC9JNFpoN1BFM2dpTDhmTDh3cThJcS9FSy9NcXZDcXZSci9SNzd3NnI4RnI4bHE4TnEvRDYvSjZ2RDV2d0J2eVJyd3hiOEtiOG1iMEI3M0ttL01XUEltMzVFYjJzWjhESE9RUU4zR1ltN21GdDZJUDZFUGVtcmZoYlhrNzNwNTM0QWhIT2NaeHRqakJrM2tLdDlMMWRBTlA1V25jeHRPNW5UdDRCdS9JblR5VC9xUy82Q1A2bUdkeEYrL0VzM2tPeitWNXZEUHZ3cnZ5YnJ3Nzc4Rko3dVllN3VVVXorYys3dWMwM2NVTGVDRm5lSUErb1U4NVM1ZHlqZ2Q1VDg1emdZdGM0a1c4bUpmd1VsN0dlL0hldkEvdnkvdngvdlFhdlU5djBsdjBOcjFIcjlPN2ZBQWZ5QWZ4d1h3SUg4cUg4ZUY4QkIvSlIvSFJmQXdmeThmeDhYd0NuOGduOGNsOENsM09wL0pwZkRxZndXZnlXWHcybjhQbjhubDhQbC9BRi9KRmZERmZ3cGZ5Wlh3NW5jZFg4SlY4RlYvTjEvQzFmQjFmenpmd2pYd1QzOHkzOEsxOEc5L09kL0NkZkJmZnpmZnd2WFFXMzhmMzh3UDhJRC9FRC9Nai9DZy94by96RS93a1A4VlA4elA4TEQvSHovTUwvRDkra1YvaWwva1ZmcFZmNDlmNURYNlQzK0szK1IxK2w5L2o5L2tEL3BBLzRvLzVFLzZVUCtQUCtRditrci9pci9rYi9wYS80Ky81Qi82UmYrS2YrUmYrbFgvajMva1AvcFAvNHIvNUgvNVhTRmhFVkR4U0pWNnBsakZTSTdWU0ovWFNJR05sbkl5WENUSlJscFBsWlFWWlVWYVNsV1VWV1ZWV2s5VmxEVmxUMXBLMVpSMVpWOWFUOVdVRDJWQTJrbzFsRTlsVU5wUE5aUXVaSkZ0S28vakVMd0VKU2tpYUpDek4waUpieWRheWpXd3IyOG4yc29ORUpDb3hpWXNsQ1prc1U2UlZwc28wYVpQcDBpNGRNa04ybEU2WktiT2tTM2FTMlRKSDVzbzgyVmwya1YxbE45bGQ5cENrZEV1UDlFcEs1a3VmOUV0YUZzaEN5Y2lBWkNVbmc3S241S1VnUlNuSklsa3NTMlNwTEpPOVpHL1pSL2FWL1dSL09VQU9sSVBrWURsRURwWEQ1SEE1UW82VW8rUm9PVWFPbGVQa2VEbEJUcFNUNUdRNVJVNlYwK1IwT1VQT2xMUGtiRGxIenBYejVIeTVRQzZVaStSaXVVUXVsY3ZrY3JsQ3JwU3I1R3E1UnE2VjYrUjZ1VUZ1bEp2a1pybEZicFhiNUhhNVErNlV1K1J1dVVmdWxmdmtmbmxBSHBTSDVHRjVSQjZWeCtSeGVVS2VsS2ZrYVhsR25wWG41SGw1UWY0bkw4cEw4cks4SXEvS2EvSzZ2Q0Z2eWx2eXRyd2o3OHA3OHI1OElCL0tSL0t4ZkNLZnltZnl1WHdoWDhwWDhyVjhJOS9LZC9LOS9DQS95ay95cy93aXY4cHY4cnY4SVgvS1gvSzMvQ1AvS2ltcnFLcEhxOVNyMVRwR2E3Ulc2N1JlRzNTc2p0UHhPa0VuNm5LNnZLNmdLK3BLdXJLdW9xdnFhcnE2cnFGcjZscTZ0cTZqNitwNnVyNXVvQnZxUnJxeGJxS2I2bWE2dVc2aGszUkxiVlNmK2pXZ1FRMXBrNGExV1Z0MEs5MWF0OUZ0ZFR2ZFhuZlFpRVkxcG5HMU5LR1RkWXEyNmxTZHBtMDZYZHUxUTJmb2p0cXBNK2xHdWtsbmFSZmRTcmZSdzdvVDNVeTMwQ04wSUQxSWgrbHN1b29lMVRrNmwrNmwrM1FlM2EwNzZ5NzBxKzZxdStudXVvY210VnQ3NkdqdDFaVE8xejd0cDlQcFREcUR2cVZMNkVRNm15Nmo0K2hrT29YdTBEVGRyd3Qwb1daMFFMT2EwMEhkVS9OYTBLS1dkSkV1MWlXNlZKZnBYcnEzN3FQNzZuNjZ2eDZnQitwQmVyQWVvb2ZxWVhxNEhxRkg2bEY2dEI2angrcHhlcnllb0NmcVNYcXlucUtuNm1sNnVwNmhaK3BaZXJhZW8rZnFlWHErWHFBWDZrVjZzVjZpbCtwbGVybGVvVmZxVlhxMVhxUFg2blY2dmQ2Z04rcE5lclBlb3JmcWJYcTczcUYzNmwxNnQ5Nmo5K3A5ZXI4K29BL3FRL3F3UHFLUDZtUDZ1RDZoVCtwVCtyUStvOC9xYy9xOHZxRC8weGYxSlgxWlg5Rlg5VFY5WGQvUU4vVXRmVnZmMFhmMVBYMWZQOUFQOVNQOVdEL1JUL1V6L1Z5LzBDLzFLLzFhdjlGdjlUdjlYbi9RSC9Vbi9WbC8wVi8xTi8xZC85QS85Uy85Vy8vUmZ6M2tZWTk0MU9QeFZIbThubXJQR0UrTnA5WlQ1Nm4zTkhqR2VzWjV4bnNtZUNaV2w3THB4c1pJdkRveWtPeko1N0xWU1pQZVNIYyt0U2psVFRwUkhjbjE1YktwaGRWSmszV3hublMrcHpRd1A1TmFVdGRUS1R1OStSb2p5S2czM3BNc2Q5WnJJbTczbkN4V1c2QlNvQ3hEcFp5b3RYcHp4V1JQVHlwYnJFME5GNnN0RENCbDBtdVpIbE5PMUUxMkRhZHY5SEQ4alVoZi9lU2UzTUJBMG5SWjMrYzZxSnZpNnFHL1V2Wk02VTdtUGYzMmk3ZTFtTTcwcHJ4cEo2cGJNWWMwNXRCcTVwQTJ5OVdLMGFaTlN1dFVTUytvbStveUZsVEs5ZFBjbzFvNDRxQXZuMHBsTThsc2I3ckgyNWJzS1JWVDNvd1Q5VzN1ZWhuWGdiZk5MRTNHQ1UrYnZZYWVqUDNpYlRmdHM2Wjl1N3Q5MXQyKzNiVFBtcVhOSmdkemhXSStOOWlmVWl2YnA2bHNYM1VISnAvRDVEdk01SE5PTkhUMGw3Sjl5WHhwSUpNc0ZSdHk3aU52cHhsRDNveWgwejJHdkhzTW5XWU1lUk16VGF1Q0UzVXpYY3RZR0gyeW0veklnSGVXYVZ3MDZ6Q3JmQ0tMNVJQWlpVNWt5WnpJTHN5bGhMbDBtYm1VbktqcXlxZXpmVldsOG10RDE0aDVsZHhIMVYwNDRTWGNIN05kWTF6c0tzOTFsWmRXeXQ1NVpvYkxuS2lkVjdrRmxnMFhxeks1YkYraHFxTS9sODlXNVp6WEx1ZTFWSDQxczA0MDFrYktZelhkSkllTDFSSExaREpsMXJDamtFa1crazA1VnlrN3ZmaDl6Y2dXWkFRWk5Sa0lWeFY2K2hjbnpWRTBaaklScU9uTEp4ZWw3TlBZWGVQMDVwU2NWUzZYUFAyNTNFS25hcUF4TWNhZVZuY3FrMXRjVmN4bGM0V0czblFxbnlxa0M4NVJiU1F6Mko5MGlqWEpiSzZZeXFUU3lYcHJzSkMybDhENThSaXJpUGRiY3lqVmR3eWt5eWZRSEhTNUt0ZDJES1Q2VEtVSmFidjZDS3ZLc1R6UlZERlpOVGxwWDREVmNEeno3QitwN1ZUTjZyZExuakpVTlMwNU9KaTBiOFNCN3Q2a1RDOUplMG5tcEtzaHk0eTBkdmJucW1hbSt3YVNPaXRacXNZb2RFWi9XbVAyL3htRmRIMnJhd1RqVUdIb3VEWTVQUEg2bEh1NnFhSHBwb2VtdTN4cFpGTXpHYWU5cDdzOG1iN3laS3A2VTVsaXNocDllWmFWcDFSK3MraE1xZHhaMVVKblNobG5TdWJzUkdPU0xjbVN0SDE3Ty9QU2ZIL09XeWhQeWxmbGhCYnR1Y0hYUVh0ZVBmWi8rN0FxVjE3b2V2Y2FqeHMxelBxYyt5eVYzR2NwTjN5V3pERGlQcVFmMmVSa3NMRVI2VVA2a1FGa0VCbENEclVMSTV1UkxjZ0lNb3FNSWVOSUM1a3c2WVB2ZysrRDc0UHZnKytENzRQdmc0KzdLNGk3SzRpN0s0aTdLK2lENzRQdmcrK0RqKzBzNklmdmgrK0g3NGZ2aCsrSDc0ZnZoKytINzRmdmgrK0g3NGZ2aCsrSEg0QWZnQitBSDRBZmdCK0FINEFmZ0IrQUg0QWZnQitBSDRBZmdCK0FINEFmaEIrRUg0UWZoQitFSDRRZmhCK0VINFFmaEIrRUg0UWZoQitFSDRRZmhCK0NINElmZ2grQ0g0SWZnaCtDSDRJZmdoK0NINElmZ2grQ0g0SWZnaCtDM3dTL0NUNTJ2R0FUL0NiNFRmQ2I0RGZCYjRMZkJMOEpmaFA4SnZoTjhKdmdOOEVQd3cvREQ4TVB3dy9ERDhNUHd3L0REOE1Qd3cvREQ4TVB3dy9ERDhNUHcyK0czd3kvR1g0ei9HYjR6ZkNiNFRmRGJZYmJETGNaYmpQY1pyak5jSnZodHNCdGdkc0N0d1Z1Qzl3V3VDMXdXekR2RnZndDhGdmd0OEJ2Z2Q4Q3Z3VitDL3dJL0FqOENQd0kvQWo4Q1B3SS9BajhDUHdJL0FqOENQd0kvQWo4Q1B3SS9DajhLUHdvL0NqOEtQd28vQ2o4S1B3by9DajhLUHdvZkh5T0NFYmhSK0ZINGNmZ3grREg0TWZneCtESDRNZmd4K0RINE1mZ3grREg0TWZneCtESDRNZmd4K0ZqWHdwaVh3ckc0Y2ZoeCtFUDdWZHgrSEg0Y2ZoeCtISDRjZmh4K0hINGNmZ1dmQXUrQmQrQ2I4RzM0RnZ3TGZnV2ZBdStCZCtDYjhHMzRGdndMZmdKK0FuNENmZ0orQW40Q2ZnSitBbjRDZmdKK0FuNENmZ0orQW40Q2ZnSjQ0ZXc3NGV3NzRldzc0ZXc3NGV3NzRldzc0ZXc3NGV3NzRldzc0ZXc3NGV3NzRldzc0ZXc3NGV3NzRldzc0ZXc3NGV3NzRldzc0ZXc3NGZNdnUrenpQanM5SmswKzVhZENlOXM1NE94ZDdHSjJlYXovbUluYW1ZUGZUU3FXVHhVTXUwaTZDK0Mvc3o5YmljOGM3L2JHVUkySWNQSVptUUxNb0tNSW1QSU9CTGpOZmU3ejRyQ2o4S1B3by9DajhLUHdvL0NqOEtQd28vQ2o4S1B3by9DajhLUHdvL0NqOEdQd1kvQmo4R1B3WS9CajhHUHdZL0JqOEdQd1kvQmo4R1B3WS9CajhHUHc0L0RqOE9QdzQvRGo4T1B3NC9EajhPUHc0L0RqOE9QdzQvRGo4T1B3N2ZnVy9BdCtCWjhDNzRGMzRKdndiZmdXL0F0K0JaOEM3NEYzNEp2d1UvQVQvaThjODJGdTlRSi9CUjZBbm9DZWdKNkFycTUyMzBKODJuSzMyanVFanQ5U0Q4eWdBd2lROGdtWkJqWmpHeEJScEJSazc1UVF5bmJtOG9YZW5MNVZHOTNwbUhQa3YwRnN2eGRQbDlJOVpvNi9wQjNJSjExbmlqWTMweXp2VFdwSlQzMkZ5Qzd0bmsvSEt6SkZrcURxWHc2bC9kazB2bWtkekJWc0w4d21YY2pVWTlWeXVlY0F4K0c2VE8vQk94c3Fra1ZpdW1CWkRIVlc1UExwbExwdnY1aWYzMnhQNTlDdVZBM1A3MW9xRnhmc0FlV0hYckQ5UUNrM0ZzaWFoYkh6Z0RTV1p5RVpYNGxKaExtVjZhZGNVOTdWMXViZDg2a3drRFBZSzNUcVZPc1daYks1eVpsc3FXQk1mWmduTUxZVERMZlowK3RUTnBmeU90N2x1YlRtVXk2cDN3dzNuMlFTYzB2MWczOW9KanVHZXM4RVJuK090L2dISllybG8vTW04UGYrcGVyUE5vWWJqQ3g4ck9oVnE1cXc0OE9YRDhiN3M3MFBseGxnbXVoOHVVdnhDbHZ4Sm11TjJvaVppSnV3aktSTURIWnhCUVRyU2FtbXBobW9zM0VkQlB0SmpwTTdHaWkwOFJNRTdOTWRKbll5Y1JzY3pLY1UrK3N2SGV1ZVdPZTY5U1VTODZwY1FyRnhUbDNJNmZhL0Z3cGo1SjkzWmg2aGZTU1NvTnkxN1hPSldTcVpkUG9ydHJwdHpSWTdYUmJHcXhCcjZYQk1hYlRjc0hwMDY3amRHblh3YlZqbDlDbFhjbjBhQmZNa08yQy9SVytVT2hPNW11R256RFY5Q1lMNldSdVNUcHBSbHdlbFJteGMvV1Z1M2NHYXZvdkY2djZKaVV6Ull6Y3FlNDR6a3JOTUZOeEhtZVVhelVNWFlmT2hWQm5uaU9iSmJDSy9hWnkrUUdmVTZxTE9GY0t5czdvblBMNFNPWFN3cHZPeGVtVXgwYUdkbDl6QnB6SGFFNXhYT1dKbW5QY0VPdEo5ZHFEU1pvK0xCZG11VEJyRkRiV0dnSFV0YnJhdGJyYXRZNXUxenF5WFh0bHpIVWRyajQ2WEgxMGpKNW9oMnVpSFNQNzYzTDEwZVhxbzJ2ME9McEd0cHRicVZ1UHZ4MWdVWjF6aERmTTQxRHpSc3pWZTJ4VTcvWGxqMUsreGdocU9vOXNUVGxlS2RkYmJzZXFPT01xZnpOQVJiZHJWWG9ZUDNuMHlreDJqZFlaZzcvUk9aamcvbE9CYVR0bGROdld5cXJXdDdxSDF1cnF0TlUxbEhHdEk4YzVmdXFvTGlkTUc2M1d0VlZXYlVMYmY5K3R6SzJtL0tRZjE0aXJUZnQvMnJTN1ZyVERQZXlPeXJBbmpuaUliOTd1ZFBYYStaOWVPMTNuYkticlRNOGNOY1dHbVNOdW41bVZaaE5tL2FmVFdhNU91MXlyM2VVZWRsZGwyTFZkdzdmdHhLNy96S0MreTNVdXhzOGVOYkR4YzBkZjhYTkhYdkh6S3JNYU4yL2tpYXliVnhub09IdDNIVWhtN1U4VHB0My9BZW0wMUJRQWVKd2R6ajBLd2pBWUJ1REV2eGFwYmFrT09raEZ4Q1ZnL0JsRUhBcHFjUlJ4RW9mT0NsSkJPMHJGQzNnRWo2QmtjZlFJZWhPUFVMKzN5OE9iN3lmSjB4QlBKcGppV2thd0Z3ODM4MTZkNmVLVnVlNVc0elJsOTJ1L1gwYktMU2VEVmdrcFB4MEtOMDBGMlhacmFkSkduV1phWTByWE5McTE0WiszMVpucUZ2bFJIY0FGZkVHanlFL0tNeWdGSUFiU29Ob0NoT0FHSGlBQnJzRWpiRVRZaUxBUktjdkVMdmdCMTZTNUFOekFCeVRBTTJrNEJHOGJEOWxVdTRNM3NHeHFTQkE0MUUzQXg4RmZnTVJSVmdnUHhNUWZ6Y0ZaT3dBQVwiO1xuIiwiaW1wb3J0IHtkZWZpbmVDb21wb25lbnRTdHlsZSwgZGVmaW5lU3R5bGVGb3JDb21wb25lbnQsIGRlZmluZUN1c3RvbUJhc2V9IGZyb20gXCJsaWItc291cmNlL3YyL3N0eWxlLmpzXCI7XHJcbmltcG9ydCBSaXBwbGUgZnJvbSBcImxpYi1zb3VyY2UvdWl2Mi9yaXBwbGUuanNcIjtcclxuaW1wb3J0IEljb24gZnJvbSAnbGliLXNvdXJjZS91aXYyL2ljb24uanMnO1xyXG5pbXBvcnQgVG91Y2hhYmxlIGZyb20gJ2xpYi1zb3VyY2UvdWl2Mi9Ub3VjaGFibGUnO1xyXG5pbXBvcnQgdmFycyBmcm9tICdsaWItc291cmNlL3VpdjIvdmFycyc7XHJcbmltcG9ydCB7dHJhbnNmZXJQcm9wc30gZnJvbSAnbGliLXNvdXJjZS92Mi91dGlscyc7XHJcblxyXG5kZWZpbmVDb21wb25lbnRTdHlsZShcclxuICAgICdidXR0b24nLFxyXG4gICAgJ2NvcmUnLFxyXG4gICAge1xyXG4gICAgICAgIFwid3JhcHBlclwiOiB7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxyXG4gICAgICAgICAgICB0ZXh0QWxpZ246ICdjZW50ZXInLFxyXG4gICAgICAgICAgICBtYXJnaW46IDQsXHJcbiAgICAgICAgICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcclxuICAgICAgICAgICAgekluZGV4OiBcIiswXCIsXHJcbiAgICAgICAgICAgIHdoaXRlU3BhY2U6ICdwcmUnLFxyXG4gICAgICAgICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAndHJhbnNwYXJlbnQnLFxyXG4gICAgICAgICAgICBjb2xvcjogJ2JsYWNrJyxcclxuICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAzXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcIndyYXBwZXI6Zm9jdXNcIjoge1xyXG4gICAgICAgICAgICBvdXRsaW5lOiAnbm9uZSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwid3JhcHBlcltkaXNhYmxlZF1cIjoge1xyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjZWFlYWVhJyxcclxuICAgICAgICAgICAgY29sb3I6ICcjYTBhMGEwJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJ0ZXh0LXdyYXBwZXJcIjoge1xyXG4gICAgICAgICAgICBkaXNwbGF5OiAndGFibGUnLFxyXG4gICAgICAgICAgICB3aWR0aDogJzEwMCUnXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcInRleHRcIjoge1xyXG4gICAgICAgICAgICBoZWlnaHQ6ICcxMDAlJyxcclxuICAgICAgICAgICAgd2lkdGg6ICcxMDAlJyxcclxuICAgICAgICAgICAgcGFkZGluZzogNSxcclxuICAgICAgICAgICAgcGFkZGluZ0xlZnQ6IDE1LFxyXG4gICAgICAgICAgICBwYWRkaW5nUmlnaHQ6IDE1LFxyXG4gICAgICAgICAgICB0ZXh0QWxpZ246ICdjZW50ZXInLFxyXG4gICAgICAgICAgICB2ZXJ0aWNhbEFsaWduOiAnbWlkZGxlJyxcclxuICAgICAgICAgICAgd2hpdGVTcGFjZTogJ3ByZScsXHJcbiAgICAgICAgICAgIGRpc3BsYXk6ICd0YWJsZS1jZWxsJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJ3cmFwcGVyID4gb3ZlcmxheVwiOiB7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxyXG4gICAgICAgICAgICB0b3A6IDAsXHJcbiAgICAgICAgICAgIGxlZnQ6IDAsXHJcbiAgICAgICAgICAgIHJpZ2h0OiAwLFxyXG4gICAgICAgICAgICBib3R0b206IDAsXHJcbiAgICAgICAgICAgIHRyYW5zaXRpb246ICdiYWNrZ3JvdW5kLWNvbG9yIDUwMG1zIGxpbmVhcidcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiLmNvcmUtZGVza3RvcCBvdmVybGF5OmhvdmVyXCI6IHtcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiB2YXJzLmhvdmVyQ29sb3JcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwid3JhcHBlcjphY3RpdmUgPiBvdmVybGF5XCI6IHtcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiB2YXJzLmFjdGl2ZUNvbG9yLFxyXG4gICAgICAgICAgICB0cmFuc2l0aW9uOiAnbm9uZSdcclxuICAgICAgICB9XHJcbiAgICB9XHJcbik7XHJcblxyXG5jb25zdCBCdXR0b24gPSBwcm9wcyA9PiB7XHJcbiAgICBsZXQge1xyXG4gICAgICAgIHRleHQsXHJcbiAgICAgICAgb25UYXAgPSAoKSA9PiBjb25zb2xlLndhcm4oXCJObyBvblRhcCBnaXZlbiB0byBCdXR0b25cIiksXHJcbiAgICAgICAgc3R5bGVOYW1lID0gXCJjb3JlXCIsXHJcbiAgICAgICAgYnV0dG9uQ29sb3IgPSBudWxsLFxyXG4gICAgICAgIHRleHRDb2xvciA9IG51bGwsXHJcbiAgICAgICAgZmx1c2gsXHJcbiAgICAgICAgYmxvY2ssXHJcbiAgICAgICAgZmlsbCxcclxuICAgICAgICBwYWRkaW5nLFxyXG4gICAgICAgIGRpc2FibGVkLFxyXG4gICAgICAgIGljb25OYW1lID0gbnVsbCxcclxuICAgICAgICBpY29uU2l6ZSA9IG51bGxcclxuICAgIH0gPSBwcm9wcztcclxuXHJcbiAgICBjb25zdCB3cmFwcGVyTmFtZSA9IGBidXR0b24tY29yZS13cmFwcGVyIGJ1dHRvbi0ke3N0eWxlTmFtZX0td3JhcHBlci1jdXN0b21gO1xyXG5cclxuICAgIGNvbnN0IHdyYXBwZXJTdHlsZSA9IHtiYWNrZ3JvdW5kQ29sb3I6IGJ1dHRvbkNvbG9yfTtcclxuICAgIGNvbnN0IHRleHRXcmFwcGVyU3R5bGUgPSB7fTtcclxuICAgIGNvbnN0IHRleHRTdHlsZSA9IHtjb2xvcjogdGV4dENvbG9yfTtcclxuICAgIGxldCByaXBwbGVFbGVtZW50O1xyXG4gICAgbGV0IG9uVGFwSGFuZGxlcjtcclxuXHJcbiAgICBpZiAoZGlzYWJsZWQgIT09IHRydWUpIHtcclxuICAgICAgICAvLyByaXBwbGVFbGVtZW50ID0gPFJpcHBsZSAvPjtcclxuICAgICAgICBvblRhcEhhbmRsZXIgPSBvblRhcDtcclxuICAgIH1cclxuICAgIGlmIChibG9jayA9PT0gdHJ1ZSkge1xyXG4gICAgICAgIHdyYXBwZXJTdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcclxuICAgIH1cclxuICAgIGlmIChmaWxsID09PSB0cnVlKSB7XHJcbiAgICAgICAgZmx1c2ggPSB0cnVlO1xyXG4gICAgICAgIHdyYXBwZXJTdHlsZS53aWR0aCA9ICcxMDAlJztcclxuICAgICAgICB3cmFwcGVyU3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xyXG4gICAgICAgIHRleHRXcmFwcGVyU3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xyXG4gICAgICAgIHRleHRTdHlsZS5wYWRkaW5nID0gMDtcclxuICAgIH1cclxuICAgIGlmIChmbHVzaCA9PT0gdHJ1ZSkge1xyXG4gICAgICAgIHdyYXBwZXJTdHlsZS5tYXJnaW4gPSAwO1xyXG4gICAgfVxyXG4gICAgaWYgKGljb25OYW1lICE9PSBudWxsKSB7XHJcbiAgICAgICAgdGV4dCA9IDxzcGFuPjxJY29uIG5hbWU9e2ljb25OYW1lfSBzaXplPXtpY29uU2l6ZX0gLz57dGV4dH08L3NwYW4+O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPFRvdWNoYWJsZSBjb21wb25lbnQ9XCJkaXZcIiB0YWJJbmRleD17LTF9IGNsYXNzTmFtZT17d3JhcHBlck5hbWV9IG9uVGFwPXtvblRhcEhhbmRsZXJ9IGRpc2FibGVkPXtkaXNhYmxlZH0gc3R5bGU9e3dyYXBwZXJTdHlsZX0+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYnV0dG9uLWNvcmUtdGV4dC13cmFwcGVyXCIgc3R5bGU9e3RleHRXcmFwcGVyU3R5bGV9PlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJidXR0b24tY29yZS10ZXh0XCIgc3R5bGU9e3RleHRTdHlsZX0+e3RleHR9PC9kaXY+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImJ1dHRvbi1jb3JlLW92ZXJsYXlcIiAvPlxyXG4gICAgICAgICAgICB7cmlwcGxlRWxlbWVudH1cclxuICAgICAgICA8L1RvdWNoYWJsZT5cclxuICAgICk7XHJcbn07XHJcbkJ1dHRvbi5jb21wb25lbnROYW1lID0gJ2J1dHRvbic7XHJcblxyXG5kZWZpbmVDdXN0b21CYXNlKFxyXG4gICAgQnV0dG9uLFxyXG4gICAgKHtub3JtYWwgPSBudWxsLCBmb2N1cyA9IG51bGwsIGRpc2FibGVkID0gbnVsbH0pID0+IHRyYW5zZmVyUHJvcHMoe1xyXG4gICAgICAgIFwiLmJ1dHRvbi1jb3JlLXdyYXBwZXIvd3JhcHBlci1jdXN0b21cIjogW1xyXG4gICAgICAgICAgICBub3JtYWwsXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRleHRDb2xvcjogJ2NvbG9yJyxcclxuICAgICAgICAgICAgICAgIGNvbG9yOiAnYmFja2dyb3VuZENvbG9yJyxcclxuICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1czogJ2JvcmRlclJhZGl1cycsXHJcbiAgICAgICAgICAgICAgICBzaGFkb3c6ICdib3hTaGFkb3cnXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gWydiYWNrZ3JvdW5kQ29sb3InLCAnY29sb3InLCAnYm9yZGVyUmFkaXVzJywgJ2JveFNoYWRvdyddXHJcbiAgICAgICAgXSxcclxuICAgICAgICBcIi5idXR0b24tY29yZS13cmFwcGVyL3dyYXBwZXItY3VzdG9tOmZvY3VzXCI6IFtcclxuICAgICAgICAgICAgZm9jdXMsXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRleHRDb2xvcjogJ2NvbG9yJyxcclxuICAgICAgICAgICAgICAgIGNvbG9yOiAnYmFja2dyb3VuZENvbG9yJyxcclxuICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1czogJ2JvcmRlclJhZGl1cycsXHJcbiAgICAgICAgICAgICAgICBzaGFkb3c6ICdib3hTaGFkb3cnXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gWydiYWNrZ3JvdW5kQ29sb3InLCAnY29sb3InLCAnYm9yZGVyUmFkaXVzJywgJ2JveFNoYWRvdyddXHJcbiAgICAgICAgXSxcclxuICAgICAgICBcIi5idXR0b24tY29yZS13cmFwcGVyL3dyYXBwZXItY3VzdG9tW2Rpc2FibGVkXVwiOiBbXHJcbiAgICAgICAgICAgIGRpc2FibGVkLFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0Q29sb3I6ICdjb2xvcicsXHJcbiAgICAgICAgICAgICAgICBjb2xvcjogJ2JhY2tncm91bmRDb2xvcicsXHJcbiAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6ICdib3JkZXJSYWRpdXMnLFxyXG4gICAgICAgICAgICAgICAgc2hhZG93OiAnYm94U2hhZG93J1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFsnYmFja2dyb3VuZENvbG9yJywgJ2NvbG9yJywgJ2JvcmRlclJhZGl1cycsICdib3hTaGFkb3cnXVxyXG4gICAgICAgIF1cclxuICAgIH0pXHJcbik7XHJcblxyXG5kZWZpbmVTdHlsZUZvckNvbXBvbmVudChcclxuICAgIEJ1dHRvbiwgXCJjYW5jZWxcIixcclxuICAgIHtcclxuICAgICAgICBub3JtYWw6IHtcclxuICAgICAgICAgICAgY29sb3I6IFwiI2I1MjYzZVwiLFxyXG4gICAgICAgICAgICB0ZXh0Q29sb3I6ICd3aGl0ZSdcclxuICAgICAgICB9XHJcbiAgICB9XHJcbik7XHJcbmRlZmluZVN0eWxlRm9yQ29tcG9uZW50KFxyXG4gICAgQnV0dG9uLCBcImNvbmZpcm1cIixcclxuICAgIHtcclxuICAgICAgICBub3JtYWw6IHtcclxuICAgICAgICAgICAgY29sb3I6IFwiIzMwZDVhN1wiXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4pO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uO1xyXG4iLCJpbXBvcnQge2RlZmluZUNvbXBvbmVudFN0eWxlLCBUaGVtZX0gZnJvbSBcImxpYi1zb3VyY2UvdjIvc3R5bGVcIjtcclxuaW1wb3J0IEJ1dHRvbiBmcm9tIFwibGliLXNvdXJjZS91aXYyL0J1dHRvblwiO1xyXG5pbXBvcnQgQ2VudGVyQ29udGVudCBmcm9tICdsaWItc291cmNlL3VpdjIvQ2VudGVyQ29udGVudCc7XHJcblxyXG5jb25zdCBjb29sQmx1ZSA9IFwiIzJGQjFERlwiO1xyXG5kZWZpbmVDb21wb25lbnRTdHlsZShcclxuICAgICdjYWxlbmRhcicsXHJcbiAgICAnY29yZScsXHJcbiAgICB7XHJcbiAgICAgICAgJ2RheSc6IHtcclxuICAgICAgICAgICAgaGVpZ2h0OiAnMTAwJScsXHJcbiAgICAgICAgICAgIGZvbnRTaXplOiAxNCxcclxuICAgICAgICAgICAgdGV4dEFsaWduOiAnY2VudGVyJyxcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiZGF5W2RhdGEtaW5hY3RpdmVdXCI6IHtcclxuICAgICAgICAgICAgY29sb3I6ICdsaWdodGdyYXknLFxyXG4gICAgICAgICAgICBwYWRkaW5nVG9wOiA0XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4pO1xyXG4vKmJnY29sb3IgdGV4dGNvbG9yIGFsbCAzKi9cclxuLy8gY29uc3QgQ2FsZW5kYXIgPSAoe3NlbGVjdGVkRGF0ZX0pID0+XHJcbmNsYXNzIENhbGVuZGFyIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XHJcbiAgICAgICAgc3VwZXIocHJvcHMpO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XHJcbiAgICAgICAgICAgIG1vbnRoOiBwcm9wcy5zZWxlY3RlZERhdGUubW9udGgsXHJcbiAgICAgICAgICAgIHllYXI6IHByb3BzLnNlbGVjdGVkRGF0ZS55ZWFyXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBwcmV2TW9udGggPSAoKSA9PiB7XHJcbiAgICAgICAgbGV0IHttb250aCwgeWVhcn0gPSB0aGlzLnN0YXRlO1xyXG5cclxuICAgICAgICBtb250aCAtPSAxO1xyXG5cclxuICAgICAgICBpZiAobW9udGggPT09IC0xKSB7XHJcbiAgICAgICAgICAgIG1vbnRoID0gMTE7XHJcbiAgICAgICAgICAgIHllYXIgLT0gMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe21vbnRoLCB5ZWFyfSk7XHJcbiAgICB9XHJcbiAgICBuZXh0TW9udGggPSAoKSA9PiB7XHJcbiAgICAgICAgbGV0IHttb250aCwgeWVhcn0gPSB0aGlzLnN0YXRlO1xyXG5cclxuICAgICAgICBtb250aCArPSAxO1xyXG5cclxuICAgICAgICBpZiAobW9udGggPT09IDEyKSB7XHJcbiAgICAgICAgICAgIG1vbnRoID0gMDtcclxuICAgICAgICAgICAgeWVhciArPSAxO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7bW9udGgsIHllYXJ9KTtcclxuICAgIH1cclxuXHJcbiAgICBzZWxlY3QgPSAoZGF0ZSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHtvbkNoYW5nZSA9ICgpID0+IHt9fSA9IHRoaXMucHJvcHM7XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coZGF0ZS50b1N0cmluZygpKTtcclxuICAgICAgICBvbkNoYW5nZShkYXRlKTtcclxuICAgIH1cclxuXHJcbiAgICByZW5kZXIgPSAoKSA9PiB7XHJcbiAgICAgICAgY29uc3Qge3NlbGVjdGVkRGF0ZX0gPSB0aGlzLnByb3BzO1xyXG4gICAgICAgIGNvbnN0IHttb250aCwgeWVhcn0gPSB0aGlzLnN0YXRlO1xyXG4gICAgICAgIGNvbnN0IGJhc2VEYXRlID0gY2hyb25vKHttb250aCwgeWVhcn0pLnN0YXJ0T2YoJ3dlZWsnKTtcclxuXHJcbiAgICAgICAgY29uc3QgY3VycmVudCA9IGNocm9ubyhzZWxlY3RlZERhdGUpO1xyXG5cclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICA8ZGl2IHN0eWxlPXt7Y29sb3I6ICdibGFjayd9fT5cclxuICAgICAgICAgICAgICAgIDxVSS5QaW5ib2FyZCBoZWlnaHQ9ezMwfT5cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IHBpbkluZm89e3tiYWNrZ3JvdW5kQ29sb3I6IGNvb2xCbHVlLCB0b3A6IDAsIGxlZnQ6IDAsIGJvdHRvbTogMCwgcmlnaHQ6IDB9fSAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDxCdXR0b24gcGluSW5mbz17e3RvcDogMCwgbGVmdDogMCwgaGVpZ2h0OiAnMTAwJScsIHdpZHRoOiAzMH19IGljb25OYW1lPVwiaW9uLWFycm93LWxlZnQtYlwiIGZpbGwgZmx1c2ggb25UYXA9e3RoaXMucHJldk1vbnRofSB0ZXh0Q29sb3I9XCJ3aGl0ZVwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPENlbnRlckNvbnRlbnQgcGluSW5mbz17e3RvcDogMCwgbGVmdDogMzAsIHJpZ2h0OiAzMCwgYm90dG9tOiAwLCBjb2xvcjogJ3doaXRlJ319IGhlaWdodD1cIjEwMCVcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAge21vbnRoICsgMX0ve3llYXJ9XHJcbiAgICAgICAgICAgICAgICAgICAgPC9DZW50ZXJDb250ZW50PlxyXG4gICAgICAgICAgICAgICAgICAgIDxCdXR0b24gcGluSW5mbz17e3RvcDogMCwgcmlnaHQ6IDAsIGhlaWdodDogJzEwMCUnLCB3aWR0aDogMzB9fSBpY29uTmFtZT1cImlvbi1hcnJvdy1yaWdodC1iXCIgZmlsbCBmbHVzaCBvblRhcD17dGhpcy5uZXh0TW9udGh9IHRleHRDb2xvcj1cIndoaXRlXCIgLz5cclxuICAgICAgICAgICAgICAgIDwvVUkuUGluYm9hcmQ+XHJcbiAgICAgICAgICAgICAgICA8VUkuR3JpZCBjb2xDb3VudD17N30gcm93Q291bnQ9ezd9IGhlaWdodD17MTk1fT5cclxuICAgICAgICAgICAgICAgICAgICB7WydzJywgJ20nLCAndCcsICd3JywgJ3QnLCAnZicsICdzJ10ubWFwKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXR0ZXIgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDxDZW50ZXJDb250ZW50IGtleT17bGV0dGVyfT57bGV0dGVyLnRvVXBwZXJDYXNlKCl9PC9DZW50ZXJDb250ZW50PjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICl9XHJcbiAgICAgICAgICAgICAgICAgICAge2ZhY3RvdHVtLnJhbmdlKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA0MixcclxuICAgICAgICAgICAgICAgICAgICAgICAgbiA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRlID0gYmFzZURhdGUuc2hpZnQobiwgJ2RheXMnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGVWYWx1ZSA9IHNlbGVjdGVkRGF0ZS5zZXQoe21vbnRoOiBkYXRlLm1vbnRoLCB5ZWFyOiBkYXRlLnllYXIsIGRhdGU6IGRhdGUuZGF0ZX0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRlLm1vbnRoID09PSBtb250aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBidXR0b25TdHlsZSA9IHt9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0ZS55ZWFyID09PSBjdXJyZW50LnllYXIgJiYgZGF0ZS5tb250aCA9PT0gY3VycmVudC5tb250aCAmJiBkYXRlLmRhdGUgPT09IGN1cnJlbnQuZGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b25TdHlsZSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbkNvbG9yOiBjb29sQmx1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRDb2xvcjogJ3doaXRlJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjYWxlbmRhci1jb3JlLWRheVwiIGtleT17bn0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8QnV0dG9uIHRleHQ9e2RhdGUuZGF0ZSArIDF9IGZsdXNoIGZpbGwgb25UYXA9eygpID0+IHRoaXMuc2VsZWN0KGRhdGVWYWx1ZSl9IHsuLi5idXR0b25TdHlsZX0gLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDxkaXYga2V5PXtufSBjbGFzc05hbWU9XCJjYWxlbmRhci1jb3JlLWRheVwiIGRhdGEtaW5hY3RpdmU+e2RhdGUuZGF0ZSArIDF9PC9kaXY+O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgKX1cclxuICAgICAgICAgICAgICAgIDwvVUkuR3JpZD5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgKTtcclxuICAgIH1cclxufVxyXG5DYWxlbmRhci5jb21wb25lbnRTdHlsZU5hbWUgPSAnY2FsZW5kYXInO1xyXG5cclxuQ2FsZW5kYXIudmFsdWVQcm9wID0gXCJzZWxlY3RlZERhdGVcIjtcclxuQ2FsZW5kYXIudmFsdWVGdW5jdGlvbiA9IGRhdGUgPT4gZGF0ZTtcclxuQ2FsZW5kYXIuZGVmYXVsdFByb3BWYWx1ZSA9ICgpID0+IGNocm9ubygpO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgQ2FsZW5kYXI7XHJcbiIsImltcG9ydCB7ZGVmaW5lQ29tcG9uZW50U3R5bGV9IGZyb20gXCJsaWItc291cmNlL3YyL3N0eWxlXCI7XHJcblxyXG5kZWZpbmVDb21wb25lbnRTdHlsZShcclxuICAgICdjYXJkJyxcclxuICAgICdjb3JlJyxcclxuICAgIHtcclxuICAgICAgICBcImNvbnRhaW5lclwiOiB7XHJcbiAgICAgICAgICAgIG1hcmdpbjogNSxcclxuICAgICAgICAgICAgcGFkZGluZzogNSxcclxuICAgICAgICAgICAgYm94U2hhZG93OiAnMXB4IDJweCAycHggcmdiYSgxMjAsIDEyMCwgMTIwLCAwLjE1KScsXHJcbiAgICAgICAgICAgIGJvcmRlcjogJzFweCBzb2xpZCAjZTBlMGUwJyxcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnd2hpdGUnLFxyXG4gICAgICAgICAgICBib3JkZXJSYWRpdXM6IDNcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwidGl0bGVcIjoge1xyXG4gICAgICAgICAgICBmb250U2l6ZTogMjAsXHJcbiAgICAgICAgICAgIHBhZGRpbmc6IDMsXHJcbiAgICAgICAgICAgIGNvbG9yOiAnYmxhY2snXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4pO1xyXG5jb25zdCBDYXJkID0gKHtjaGlsZHJlbiwgdGl0bGUgPSBudWxsfSkgPT4ge1xyXG4gICAgbGV0IGNvbnRlbnQ7XHJcblxyXG4gICAgaWYgKHRpdGxlID09PSBudWxsKSB7XHJcbiAgICAgICAgY29udGVudCA9IGNoaWxkcmVuO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBjb250ZW50ID0gKFxyXG4gICAgICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjYXJkLWNvcmUtdGl0bGVcIj57dGl0bGV9PC9kaXY+XHJcbiAgICAgICAgICAgICAgICB7Y2hpbGRyZW59XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNhcmQtY29yZS1jb250YWluZXJcIj5cclxuICAgICAgICAgICAge2NvbnRlbnR9XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICApO1xyXG59O1xyXG5DYXJkLmNvbXBvbmVudFN0eWxlTmFtZSA9ICdjYXJkJ1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgQ2FyZDtcclxuIiwiaW1wb3J0IHtkZWZpbmVDb21wb25lbnRTdHlsZX0gZnJvbSBcImxpYi1zb3VyY2UvdjIvc3R5bGVcIjtcclxuXHJcbmRlZmluZUNvbXBvbmVudFN0eWxlKFxyXG4gICAgJ2NlbnRlci1jb250ZW50JyxcclxuICAgICdjb3JlJyxcclxuICAgIHtcclxuICAgICAgICAnY29udGFpbmVyJzoge1xyXG4gICAgICAgICAgICBkaXNwbGF5OiAndGFibGUnLFxyXG4gICAgICAgICAgICB3aGl0ZVNwYWNlOiAncHJlJyxcclxuICAgICAgICAgICAgdGV4dEFsaWduOiAnY2VudGVyJyxcclxuICAgICAgICAgICAgd2lkdGg6ICcxMDAlJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgJ2NvbnRlbnQnOiB7XHJcbiAgICAgICAgICAgIGRpc3BsYXk6ICd0YWJsZS1jZWxsJyxcclxuICAgICAgICAgICAgdmVydGljYWxBbGlnbjogJ21pZGRsZScsXHJcbiAgICAgICAgICAgIHBhZGRpbmc6ICdhdXRvJ1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuKTtcclxuY29uc3QgQ2VudGVyQ29udGVudCA9ICh7Y2hpbGRyZW4sIHdpZHRoLCBoZWlnaHQsIGNsYXNzTmFtZSA9IFwiXCJ9KSA9PlxyXG4gICAgPGRpdiBjbGFzc05hbWU9e2BjZW50ZXItY29udGVudC1jb3JlLWNvbnRhaW5lciAke2NsYXNzTmFtZX1gfSBzdHlsZT17e3dpZHRoLCBoZWlnaHR9fT5cclxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNlbnRlci1jb250ZW50LWNvcmUtY29udGVudFwiPlxyXG4gICAgICAgICAgICA8ZGl2IHN0eWxlPXt7bWFyZ2luOiAnYXV0bycsIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snfX0+e2NoaWxkcmVufTwvZGl2PlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgPC9kaXY+XHJcblxyXG5leHBvcnQgZGVmYXVsdCBDZW50ZXJDb250ZW50O1xyXG4iLCJpbXBvcnQge2RlZmluZUNvbXBvbmVudFN0eWxlLCBkZWZpbmVDdXN0b21CYXNlfSBmcm9tIFwibGliLXNvdXJjZS92Mi9zdHlsZVwiO1xyXG5pbXBvcnQgQ2VudGVyQ29udGVudCBmcm9tIFwibGliLXNvdXJjZS91aXYyL0NlbnRlckNvbnRlbnRcIjtcclxuLy8gaW1wb3J0IFJpcHBsZSBmcm9tIFwibGliLXNvdXJjZS91aXYyL1JpcHBsZVwiO1xyXG5pbXBvcnQgSWNvbiBmcm9tIFwibGliLXNvdXJjZS91aXYyL0ljb25cIjtcclxuaW1wb3J0IHZhcnMgZnJvbSAnbGliLXNvdXJjZS91aXYyL3ZhcnMnO1xyXG5pbXBvcnQge3RyYW5zZmVyUHJvcHN9IGZyb20gJ2xpYi1zb3VyY2UvdjIvdXRpbHMnO1xyXG5cclxuZGVmaW5lQ29tcG9uZW50U3R5bGUoXHJcbiAgICAnY2hlY2tib3gnLFxyXG4gICAgJ2NvcmUnLFxyXG4gICAge1xyXG4gICAgICAgIFwiY29udGFpbmVyXCI6IHtcclxuICAgICAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXHJcbiAgICAgICAgICAgIHRyYW5zaXRpb246ICdiYWNrZ3JvdW5kLWNvbG9yIDUwMG1zIGxpbmVhcicsXHJcbiAgICAgICAgICAgIGZvbnRTaXplOiAyMCxcclxuICAgICAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcImNvbnRhaW5lcjphY3RpdmVcIjoge1xyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDAsIDAsIDAsIDAuMDc1KScsXHJcbiAgICAgICAgICAgIHRyYW5zaXRpb246ICdub25lJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJpY29uXCI6IHtcclxuICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXHJcbiAgICAgICAgICAgIHRvcDogMCxcclxuICAgICAgICAgICAgcmlnaHQ6IDAsXHJcbiAgICAgICAgICAgIGJvdHRvbTogMCxcclxuICAgICAgICAgICAgd2lkdGg6IDMwLFxyXG4gICAgICAgICAgICBjb2xvcjogJ2JsYWNrJyxcclxuICAgICAgICAgICAgZm9udFNpemU6IDI0LFxyXG4gICAgICAgICAgICB0cmFuc2l0aW9uOiAnY29sb3IgMjUwbXMgbGluZWFyJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJpY29uW2RhdGEtY2hlY2tlZD0ndHJ1ZSddXCI6IHtcclxuICAgICAgICAgICAgY29sb3I6ICcjMjRiMzI0J1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJsYWJlbFwiOiB7XHJcbiAgICAgICAgICAgIHBhZGRpbmc6IDMsXHJcbiAgICAgICAgICAgIHBhZGRpbmdSaWdodDogMzAsXHJcbiAgICAgICAgICAgIHdoaXRlU3BhY2U6ICdwcmUnLFxyXG4gICAgICAgICAgICBjb2xvcjogJ2JsYWNrJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJzdWJ0aXRsZVwiOiB7XHJcbiAgICAgICAgICAgIGNvbG9yOiAnZ3JheScsXHJcbiAgICAgICAgICAgIGZvbnRTaXplOiAxNFxyXG4gICAgICAgIH1cclxuICAgIH1cclxuKTtcclxuY29uc3QgaW9uT25JY29uID0gXCJpb24tYW5kcm9pZC1jaGVja2JveFwiO1xyXG5jb25zdCBpb25PZmZJY29uID0gXCJpb24tYW5kcm9pZC1jaGVja2JveC1vdXRsaW5lLWJsYW5rXCI7XHJcblxyXG5jb25zdCBDaGVja2JveCA9IHByb3BzID0+IHtcclxuICAgIGNvbnN0IHtcclxuICAgICAgICBjaGVja2VkID0gZmFsc2UsXHJcbiAgICAgICAgb25JY29uTmFtZSA9IGlvbk9uSWNvbixcclxuICAgICAgICBvZmZJY29uTmFtZSA9IGlvbk9mZkljb24sXHJcbiAgICAgICAgbGFiZWwsXHJcbiAgICAgICAgc3ViVGl0bGUgPSBudWxsLFxyXG4gICAgICAgIG9uQ2hhbmdlID0gKCkgPT4gY29uc29sZS53YXJuKFwiTm8gb25DaGFuZ2UgZ2l2ZW4gdG8gY2hlY2tib3hcIiksXHJcbiAgICAgICAgc3R5bGVOYW1lID0gXCJjb3JlXCJcclxuICAgIH0gPSBwcm9wcztcclxuICAgIGNvbnN0IGljb25OYW1lID0gKGNoZWNrZWQgPT09IHRydWUpID8gb25JY29uTmFtZSA6IG9mZkljb25OYW1lO1xyXG4gICAgY29uc3QgaWNvbkNsYXNzTmFtZSA9IGBjaGVja2JveC1jb3JlLWljb24gY2hlY2tib3gtJHtzdHlsZU5hbWV9LWljb24tY3VzdG9tYDtcclxuICAgIGNvbnN0IGxhYmVsQ2xhc3NOYW1lID0gYGNoZWNrYm94LWNvcmUtbGFiZWwgY2hlY2tib3gtJHtzdHlsZU5hbWV9LWxhYmVsLWN1c3RvbWA7XHJcbiAgICBsZXQgY29udGVudCA9IGxhYmVsO1xyXG5cclxuICAgIGlmIChzdWJUaXRsZSAhPT0gbnVsbCkge1xyXG4gICAgICAgIGNvbnN0IHN1YnRpdGxlQ2xhc3NOYW1lID0gYGNoZWNrYm94LWNvcmUtc3VidGl0bGUgY2hlY2tib3gtJHtzdHlsZU5hbWV9LXN1YnRpdGxlLWN1c3RvbWA7XHJcbiAgICAgICAgY29udGVudCA9IChcclxuICAgICAgICAgICAgPGRpdj5cclxuICAgICAgICAgICAgICAgIHtsYWJlbH1cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdWJ0aXRsZUNsYXNzTmFtZX0+e3N1YlRpdGxlfTwvZGl2PlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPFVJLlRvdWNoYWJsZSBjb21wb25lbnQ9XCJkaXZcIiBjbGFzc05hbWU9XCJjaGVja2JveC1jb3JlLWNvbnRhaW5lclwiIG9uVGFwPXsoKSA9PiBvbkNoYW5nZSghY2hlY2tlZCl9PlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17aWNvbkNsYXNzTmFtZX0gZGF0YS1jaGVja2VkPXtjaGVja2VkfT5cclxuICAgICAgICAgICAgICAgIDxDZW50ZXJDb250ZW50IGhlaWdodD1cIjEwMCVcIj5cclxuICAgICAgICAgICAgICAgICAgICA8SWNvbiBuYW1lPXtpY29uTmFtZX0gLz5cclxuICAgICAgICAgICAgICAgIDwvQ2VudGVyQ29udGVudD5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtsYWJlbENsYXNzTmFtZX0+e2NvbnRlbnR9PC9kaXY+XHJcbiAgICAgICAgICAgIHsvKjxSaXBwbGUgLz4qL31cclxuICAgICAgICA8L1VJLlRvdWNoYWJsZT5cclxuICAgICk7XHJcbn07XHJcbkNoZWNrYm94LmNvbXBvbmVudE5hbWUgPSBcImNoZWNrYm94XCI7XHJcblxyXG5DaGVja2JveC52YWx1ZVByb3AgPSBcImNoZWNrZWRcIjtcclxuQ2hlY2tib3gudmFsdWVGdW5jdGlvbiA9IGNoZWNrZWQgPT4gY2hlY2tlZDtcclxuQ2hlY2tib3guZGVmYXVsdFByb3BWYWx1ZSA9IGZhbHNlO1xyXG5cclxuZGVmaW5lQ3VzdG9tQmFzZShcclxuICAgIENoZWNrYm94LFxyXG4gICAgKHtub3JtYWwgPSBudWxsLCBjaGVja2VkID0gbnVsbCwgbGFiZWwgPSBudWxsLCBzdWJ0aXRsZSA9IG51bGx9KSA9PiB0cmFuc2ZlclByb3BzKHtcclxuICAgICAgICBcIi5jaGVja2JveC1jb3JlLWljb24vaWNvbi1jdXN0b21cIjogW1xyXG4gICAgICAgICAgICBub3JtYWwsXHJcbiAgICAgICAgICAgIHtpY29uQ29sb3I6ICdjb2xvcid9XHJcbiAgICAgICAgXSxcclxuICAgICAgICBcIi5jaGVja2JveC1jb3JlLWljb24vaWNvbi1jdXN0b21bZGF0YS1jaGVja2VkPSd0cnVlJ11cIjogW1xyXG4gICAgICAgICAgICBjaGVja2VkLFxyXG4gICAgICAgICAgICB7aWNvbkNvbG9yOiAnY29sb3InfVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgXCIuY2hlY2tib3gtY29yZS1sYWJlbC9sYWJlbC1jdXN0b21cIjogW1xyXG4gICAgICAgICAgICBsYWJlbCxcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGV4dENvbG9yOiAnY29sb3InLFxyXG4gICAgICAgICAgICAgICAgY29sb3I6ICdiYWNrZ3JvdW5kQ29sb3InXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICBdLFxyXG4gICAgICAgIFwiLmNoZWNrYm94LWNvcmUtc3VidGl0bGUvc3VidGl0bGUtY3VzdG9tXCI6IFtcclxuICAgICAgICAgICAgc3VidGl0bGUsXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRleHRDb2xvcjogJ2NvbG9yJyxcclxuICAgICAgICAgICAgICAgIGNvbG9yOiAnYmFja2dyb3VuZENvbG9yJ1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgXVxyXG4gICAgfSlcclxuKTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IENoZWNrYm94O1xyXG4iLCJpbXBvcnQge2RlZmluZUNvbXBvbmVudFN0eWxlfSBmcm9tIFwibGliLXNvdXJjZS92Mi9zdHlsZVwiO1xyXG5pbXBvcnQgQnV0dG9uIGZyb20gXCJsaWItc291cmNlL3VpdjIvQnV0dG9uXCI7XHJcbmltcG9ydCBJY29uIGZyb20gXCJsaWItc291cmNlL3VpdjIvSWNvblwiO1xyXG5pbXBvcnQgT3B0aW9uIGZyb20gXCJsaWItc291cmNlL3VpdjIvT3B0aW9uXCI7XHJcbmltcG9ydCBUb3VjaGFibGUgZnJvbSBcImxpYi1zb3VyY2UvdWl2Mi9Ub3VjaGFibGVcIjtcclxuXHJcbmRlZmluZUNvbXBvbmVudFN0eWxlKFxyXG4gICAgJ2NvbWJvYm94JyxcclxuICAgICdjb3JlJyxcclxuICAgIHtcclxuICAgICAgICAnY29udGFpbmVyJzoge1xyXG4gICAgICAgICAgICBib3JkZXI6ICcxcHggc29saWQgbGlnaHRncmF5JyxcclxuICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAzLFxyXG4gICAgICAgICAgICAvLyBwYWRkaW5nOiAzLFxyXG4gICAgICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcclxuICAgICAgICAgICAgY29sb3I6ICdibGFjaycsXHJcbiAgICAgICAgICAgIGhlaWdodDogMzBcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiaWNvblwiOiB7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxyXG4gICAgICAgICAgICB0b3A6ICc1MCUnLFxyXG4gICAgICAgICAgICByaWdodDogMTAsXHJcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVkoLTUwJSknLFxyXG4gICAgICAgICAgICBwb2ludGVyRXZlbnRzOiAnbm9uZSdcclxuICAgICAgICB9XHJcbiAgICB9XHJcbik7XHJcblxyXG4vLyBjb25zdCBjb21ib2JveFNlbGVjdCA9IChpbmRleCwgdmFsdWUpID0+IGRpYWxvZy5zdWNjZXNzKFtpbmRleCwgdmFsdWVdKTtcclxuY2xhc3MgQ29tYm9ib3ggZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xyXG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcclxuICAgICAgICBzdXBlcihwcm9wcyk7XHJcbiAgICB9XHJcblxyXG4gICAgb3Blbk9wdGlvbnMgPSBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgY29uc3Qge3RpdGxlID0gXCJDb21ib2JveCFcIiwgc2Nyb2xsVG9TZWxlY3RlZCA9IGZhbHNlLCBzZWxlY3RlZEluZGV4fSA9IHRoaXMucHJvcHM7XHJcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBSZWFjdC5DaGlsZHJlbi50b0FycmF5KHRoaXMucHJvcHMuY2hpbGRyZW4pO1xyXG5cclxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGRpYWxvZy5zaG93KHtcclxuICAgICAgICAgICAgdGl0bGUsXHJcbiAgICAgICAgICAgIGNvbnRlbnQ6IGNoaWxkcmVuLm1hcChcclxuICAgICAgICAgICAgICAgICh7cHJvcHM6IHt2YWx1ZSA9IG51bGwsIGNoaWxkcmVuLCBzdHlsZSA9IG51bGwsIGNsYXNzTmFtZSA9IG51bGx9fSwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBvblRhcCA9ICgpID0+IGRpYWxvZy5oaWRlKGRpYWxvZy5zdWNjZXNzKFtpbmRleCwgdmFsdWVdKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiB7Li4ue3N0eWxlLCBjbGFzc05hbWV9fSBrZXk9e2luZGV4fT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxCdXR0b24gdGV4dD17Y2hpbGRyZW59IGJsb2NrIGZsdXNoIG9uVGFwPXtvblRhcH0gLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgKSxcclxuICAgICAgICAgICAgYnV0dG9uczogW1xyXG4gICAgICAgICAgICAgICAge3RleHQ6IFwiQ2FuY2VsXCIsIGNhbmNlbHM6IHRydWV9XHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIHNldHVwKGNvbnRhaW5lcikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNjcm9sbFRvU2VsZWN0ZWQgPT09IHRydWUgJiYgc2VsZWN0ZWRJbmRleCAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250YWluZXIuc2Nyb2xsVG9wID0gY29udGFpbmVyLmNoaWxkcmVuW3NlbGVjdGVkSW5kZXhdLm9mZnNldFRvcCAtIGNvbnRhaW5lci5vZmZzZXRUb3A7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gXCJzdWNjZXNzXCIpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZSguLi5yZXNwb25zZS52YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJlbmRlciA9ICgpID0+IHtcclxuICAgICAgICBjb25zdCB7c2VsZWN0ZWRJbmRleCwgY2hpbGRyZW4sIGhlaWdodCwgLi4uYnV0dG9uUHJvcHN9ID0gdGhpcy5wcm9wcztcclxuICAgICAgICBjb25zdCBmbGF0dGVuZWRDaGlsZHJlbiA9IFJlYWN0LkNoaWxkcmVuLnRvQXJyYXkoY2hpbGRyZW4pO1xyXG4gICAgICAgIGxldCBjdXJyZW50Q2hpbGQgPSBcIlBsZWFzZSBzZWxlY3QgYW4gb3B0aW9uXCI7XHJcblxyXG4gICAgICAgIGlmIChzZWxlY3RlZEluZGV4ICE9PSAtMSkge1xyXG4gICAgICAgICAgICBjdXJyZW50Q2hpbGQgPSBmbGF0dGVuZWRDaGlsZHJlbltzZWxlY3RlZEluZGV4XS5wcm9wcy5jaGlsZHJlbjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29tYm9ib3gtY29yZS1jb250YWluZXJcIiBzdHlsZT17e2hlaWdodH19PlxyXG4gICAgICAgICAgICAgICAgPEJ1dHRvbiB7Li4uYnV0dG9uUHJvcHN9IHRleHQ9e2N1cnJlbnRDaGlsZH0gYmxvY2sgZmx1c2ggZmlsbCBvblRhcD17dGhpcy5vcGVuT3B0aW9uc30gLz5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29tYm9ib3gtY29yZS1pY29uXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPEljb24gbmFtZT1cImlvbi1hcnJvdy1kb3duLWJcIiBzaXplPXsyNH0gLz5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICApO1xyXG4gICAgfVxyXG59XHJcblxyXG5Db21ib2JveC52YWx1ZVByb3AgPSBcInNlbGVjdGVkSW5kZXhcIjtcclxuQ29tYm9ib3gudmFsdWVGdW5jdGlvbiA9IChpbmRleCwgdmFsdWUpID0+ICh7aW5kZXgsIHZhbHVlfSk7XHJcbkNvbWJvYm94LmRlZmF1bHRQcm9wVmFsdWUgPSAwO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgQ29tYm9ib3g7XHJcbiIsImltcG9ydCBCdXR0b24gZnJvbSBcImxpYi1zb3VyY2UvdWl2Mi9CdXR0b25cIjtcclxuXHJcbmNsYXNzIEl0ZW1Db250YWluZXIgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xyXG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcclxuICAgICAgICBzdXBlcihwcm9wcyk7XHJcblxyXG4gICAgICAgIHRoaXMuc3RhdGUgPSB7dmFsdWU6IHByb3BzLmNoaWxkSW5mby5pbml0aWFsVmFsdWV9O1xyXG4gICAgfVxyXG5cclxuICAgIGNoYW5nZSA9ICguLi5hcmdzKSA9PiB7XHJcbiAgICAgICAgY29uc3Qge3VwZGF0ZUZvcm0sIGNoaWxkSW5mbzoge3ZhbHVlRnVuY3Rpb24sIG5hbWV9fSA9IHRoaXMucHJvcHM7XHJcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7dmFsdWU6IGFyZ3NbMF19KTtcclxuICAgICAgICB1cGRhdGVGb3JtKG5hbWUsIHZhbHVlRnVuY3Rpb24oLi4uYXJncykpO1xyXG4gICAgfVxyXG5cclxuICAgIHJlbmRlciA9ICgpID0+IHtcclxuICAgICAgICBjb25zdCB7UmVuZGVyZXIsIHZhbHVlUHJvcCwgY2hpbGRyZW4sIHByb3BzfSA9IHRoaXMucHJvcHMuY2hpbGRJbmZvO1xyXG4gICAgICAgIGNvbnN0IHt2YWx1ZX0gPSB0aGlzLnN0YXRlO1xyXG4gICAgICAgIGNvbnN0IHZhbHVlT2JqID0ge1xyXG4gICAgICAgICAgICBbdmFsdWVQcm9wXTogdmFsdWVcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgICAgICAgPFJlbmRlcmVyIHsuLi5wcm9wc30gb25DaGFuZ2U9e3RoaXMuY2hhbmdlfSB7Li4udmFsdWVPYmp9PlxyXG4gICAgICAgICAgICAgICAge2NoaWxkcmVufVxyXG4gICAgICAgICAgICAgICAgPC9SZW5kZXJlcj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgKTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBGb3JtIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XHJcbiAgICAgICAgc3VwZXIocHJvcHMpO1xyXG5cclxuICAgICAgICBjb25zdCB7aXRlbUNvbnRhaW5lciA9ICdkaXYnLCBsYXlvdXQgPSBudWxsfSA9IHByb3BzO1xyXG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gUmVhY3QuQ2hpbGRyZW4udG9BcnJheShwcm9wcy5jaGlsZHJlbik7XHJcbiAgICAgICAgbGV0IEVsZW1Db250YWluZXI7XHJcblxyXG4gICAgICAgIHRoaXMuaW50ZXJuYWxTdGF0ZSA9IHt9O1xyXG5cclxuICAgICAgICBpZiAobGF5b3V0ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuQ29udGFpbmVyID0gJ2Rpdic7XHJcbiAgICAgICAgICAgIEVsZW1Db250YWluZXIgPSBpdGVtQ29udGFpbmVyO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuQ29udGFpbmVyID0gbGF5b3V0O1xyXG4gICAgICAgICAgICBFbGVtQ29udGFpbmVyID0gbGF5b3V0LkZvcm1Db250YWluZXIgfHwgKCh7Y2hpbGRyZW59KSA9PiBjaGlsZHJlbik7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyUHJvcHMgPSBPYmplY3QuZW50cmllcyhwcm9wcykucmVkdWNlKFxyXG4gICAgICAgICAgICAgICAgKHByb3BzLCBba2V5LCB2YWx1ZV0pID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5LnN0YXJ0c1dpdGgoJ2xheW91dC0nKSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wc1trZXkuc3Vic3RyKDcpXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvcHM7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAge31cclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuY2hpbGRMaXN0ID0gY2hpbGRyZW4ubWFwKFxyXG4gICAgICAgICAgICAoY2hpbGQsIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlbGVtVHlwZSA9IChjaGlsZC50eXBlLnBhcmVudEluZm8gIT09IHVuZGVmaW5lZCkgPyBjaGlsZC50eXBlLnBhcmVudEluZm8gOiBjaGlsZC50eXBlO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaW5pdFZhbHVlID0gY2hpbGQucHJvcHMuZGVmYXVsdFByb3BWYWx1ZSB8fCBlbGVtVHlwZS5kZWZhdWx0UHJvcFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qge2Zvcm1OYW1lID0gaW5kZXgsIGNoaWRyZW4sIC4uLmNoaWxkUHJvcHN9ID0gY2hpbGQucHJvcHM7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZEluZm8gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgUmVuZGVyZXI6IGNoaWxkLnR5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcHM6IGNoaWxkUHJvcHMsXHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IGNoaWxkLnByb3BzLmNoaWxkcmVuLFxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlUHJvcDogZWxlbVR5cGUudmFsdWVQcm9wLFxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlRnVuY3Rpb246IGVsZW1UeXBlLnZhbHVlRnVuY3Rpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgaW5pdGlhbFZhbHVlOiB0eXBlb2YgaW5pdFZhbHVlID09PSAnZnVuY3Rpb24nID8gaW5pdFZhbHVlKCkgOiBpbml0VmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogZm9ybU5hbWVcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb250YWluZXJQcm9wcyA9IE9iamVjdC5lbnRyaWVzKGNoaWxkUHJvcHMpLnJlZHVjZShcclxuICAgICAgICAgICAgICAgICAgICAocHJvcHMsIFtrZXksIHZhbHVlXSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5LnN0YXJ0c1dpdGgoJ2xheW91dC0nKSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHNba2V5LnN1YnN0cig3KV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvcHM7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICB7fVxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGNoaWxkLCBjaGlsZC50eXBlLCBjaGlsZC50eXBlID09PSBDaGVja2JveCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmludGVybmFsU3RhdGVbY2hpbGRJbmZvLm5hbWVdID0gY2hpbGRJbmZvLnZhbHVlRnVuY3Rpb24oY2hpbGRJbmZvLmluaXRpYWxWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICAgICAgICAgIDxFbGVtQ29udGFpbmVyIHsuLi5jb250YWluZXJQcm9wc30ga2V5PXtpbmRleH0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxJdGVtQ29udGFpbmVyIGNoaWxkSW5mbz17Y2hpbGRJbmZvfSB1cGRhdGVGb3JtPXt0aGlzLnVwZGF0ZUludGVybmFsU3RhdGV9IC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9FbGVtQ29udGFpbmVyPlxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlSW50ZXJuYWxTdGF0ZSA9IChuYW1lLCB2YWx1ZSkgPT4ge1xyXG4gICAgICAgIHRoaXMuaW50ZXJuYWxTdGF0ZVtuYW1lXSA9IHZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIHN1Ym1pdCA9IGV2dCA9PiB7XHJcbiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xyXG5cclxuICAgICAgICBjb25zdCB7b25TdWJtaXQgPSBzdGF0ZSA9PiBjb25zb2xlLmxvZyhzdGF0ZSl9ID0gdGhpcy5wcm9wcztcclxuICAgICAgICBvblN1Ym1pdCh0aGlzLmludGVybmFsU3RhdGUpO1xyXG4gICAgfVxyXG5cclxuICAgIHJlbmRlciA9ICgpID0+IHtcclxuICAgICAgICBjb25zdCB7Q29udGFpbmVyLCBjaGlsZExpc3QsIGNvbnRhaW5lclByb3BzfSA9IHRoaXM7XHJcbiAgICAgICAgY29uc3Qge3N1Ym1pdFRleHQgPSBcIlN1Ym1pdFwifSA9IHRoaXMucHJvcHM7XHJcblxyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIDxmb3JtIG9uU3VibWl0PXt0aGlzLnN1Ym1pdH0gcmVmPVwiZm9ybVwiPlxyXG4gICAgICAgICAgICAgICAgPENvbnRhaW5lciB7Li4uY29udGFpbmVyUHJvcHN9PlxyXG4gICAgICAgICAgICAgICAgICAgIHtjaGlsZExpc3R9XHJcbiAgICAgICAgICAgICAgICA8L0NvbnRhaW5lcj5cclxuICAgICAgICAgICAgICAgIDxCdXR0b24gdGV4dD17c3VibWl0VGV4dH0gb25UYXA9e3RoaXMuc3VibWl0fSBibG9jayAvPlxyXG4gICAgICAgICAgICA8L2Zvcm0+XHJcbiAgICAgICAgKTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgRm9ybTtcclxuIiwiaW1wb3J0IHtkZWZpbmVDb21wb25lbnRTdHlsZX0gZnJvbSBcImxpYi1zb3VyY2UvdjIvc3R5bGUuanNcIjtcclxuXHJcbmRlZmluZUNvbXBvbmVudFN0eWxlKFxyXG4gICAgJ2ljb24nLFxyXG4gICAgJ2NvcmUnLFxyXG4gICAge1xyXG4gICAgICAgIFwiY29udGVudFwiOiB7XHJcbiAgICAgICAgICAgIGZvbnRGYW1pbHk6IFwiSW9uaWNcIixcclxuICAgICAgICAgICAgbWFyZ2luTGVmdDogMixcclxuICAgICAgICAgICAgbWFyZ2luUmlnaHQ6IDJcclxuICAgICAgICB9XHJcbiAgICB9XHJcbik7XHJcbmNvbnN0IEljb24gPSAoe25hbWUsIHN0eWxlTmFtZSA9ICdjb3JlJywgc2l6ZX0pID0+XHJcbiAgICA8c3BhbiBjbGFzc05hbWU9e2BpY29uLSR7c3R5bGVOYW1lfS1jb250ZW50YH0gc3R5bGU9e3tmb250U2l6ZTogc2l6ZX19Pntpb25pY1tuYW1lXX08L3NwYW4+O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgSWNvbjtcclxuIiwiY29uc3QgSW1hZ2UgPSAoe3NvdXJjZSwgd2lkdGggPSAnMTAwJScsIGhlaWdodCA9IG51bGwsIGltYWdlU2l6ZSA9ICdmaXQnLCBjb2xvciwgYmxvY2sgPSBmYWxzZX0pID0+IHtcclxuICAgIGlmIChoZWlnaHQgPT09IG51bGwpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOZWVkIHRvIGdpdmUgaW1hZ2UgaGVpZ2h0XCIpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHN0eWxlID0ge1xyXG4gICAgICAgIGRpc3BsYXk6IGJsb2NrID09PSB0cnVlID8gXCJibG9ja1wiIDogXCJpbmxpbmUtYmxvY2tcIixcclxuICAgICAgICBiYWNrZ3JvdW5kUmVwZWF0OiAnbm8tcmVwZWF0JyxcclxuICAgICAgICBiYWNrZ3JvdW5kUG9zaXRpb246ICdjZW50ZXIgY2VudGVyJyxcclxuICAgICAgICBiYWNrZ3JvdW5kSW1hZ2U6IGB1cmwoXCIke3NvdXJjZX1cIilgLFxyXG4gICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxyXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogY29sb3IsXHJcbiAgICAgICAgd2lkdGgsXHJcbiAgICAgICAgaGVpZ2h0XHJcbiAgICB9O1xyXG5cclxuICAgIHN3aXRjaCAoaW1hZ2VTaXplKSB7XHJcbiAgICAgICAgY2FzZSAnZml0JzpcclxuICAgICAgICAgICAgc3R5bGUuYmFja2dyb3VuZFNpemUgPSAnY29udGFpbic7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICBjYXNlICdjbGlwJzpcclxuICAgICAgICAgICAgc3R5bGUuYmFja2dyb3VuZFNpemUgPSAnY292ZXInO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgc3R5bGUuYmFja2dyb3VuZFNpemUgPSBpbWFnZVNpemU7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIDxkaXYgc3R5bGU9e3N0eWxlfSAvPjtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IEltYWdlO1xyXG4iLCJpbXBvcnQge2RlZmluZUNvbXBvbmVudFN0eWxlfSBmcm9tIFwibGliLXNvdXJjZS92Mi9zdHlsZVwiO1xyXG5pbXBvcnQgUmFuZ2VJbnB1dCBmcm9tICdsaWItc291cmNlL3VpdjIvaW5wdXQvUmFuZ2VJbnB1dCc7XHJcbmltcG9ydCBEYXRlSW5wdXQgZnJvbSAnbGliLXNvdXJjZS91aXYyL2lucHV0L0RhdGVJbnB1dCc7XHJcbmltcG9ydCBUaW1lSW5wdXQgZnJvbSAnbGliLXNvdXJjZS91aXYyL2lucHV0L1RpbWVJbnB1dCc7XHJcbmltcG9ydCBGaWxlSW5wdXQgZnJvbSAnbGliLXNvdXJjZS91aXYyL2lucHV0L0ZpbGVJbnB1dCc7XHJcbmltcG9ydCBDZW50ZXJDb250ZW50IGZyb20gJ2xpYi1zb3VyY2UvdWl2Mi9DZW50ZXJDb250ZW50JztcclxuaW1wb3J0IEljb24gZnJvbSAnbGliLXNvdXJjZS91aXYyL0ljb24nO1xyXG5pbXBvcnQgVG91Y2hhYmxlIGZyb20gJ2xpYi1zb3VyY2UvdWl2Mi9Ub3VjaGFibGUnO1xyXG5cclxuY29uc3QgY29vbEJsdWUgPSBcIiMyRkIxREZcIjtcclxuXHJcbmRlZmluZUNvbXBvbmVudFN0eWxlKFxyXG4gICAgJ2lucHV0JyxcclxuICAgICdjb3JlJyxcclxuICAgIHtcclxuICAgICAgICBcIiRib2R5XCI6IHtcclxuICAgICAgICAgICAgV2Via2l0VGFwSGlnaGxpZ2h0Q29sb3I6ICdyZ2JhKDAsIDAsIDAsIDApJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJ3cmFwcGVyXCI6IHtcclxuICAgICAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXHJcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3doaXRlJyxcclxuICAgICAgICAgICAgaGVpZ2h0OiAzMixcclxuICAgICAgICAgICAgbWFyZ2luOiAzXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcImZpZWxkXCI6IHtcclxuICAgICAgICAgICAgd2lkdGg6ICcxMDAlJyxcclxuICAgICAgICAgICAgYm9yZGVyV2lkdGg6IDAsXHJcbiAgICAgICAgICAgIGJvcmRlckJvdHRvbTogJzJweCBzb2xpZCBsaWdodGdyYXknLFxyXG4gICAgICAgICAgICBXZWJraXRCb3JkZXJSYWRpdXM6IDAsXHJcbiAgICAgICAgICAgIFdlYmtpdEFwcGVhcmFuY2U6ICdub25lJyxcclxuICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAwLFxyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICd0cmFuc3BhcmVudCcsXHJcbiAgICAgICAgICAgIG1hcmdpbjogMCxcclxuICAgICAgICAgICAgaGVpZ2h0OiAnMTAwJScsXHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxyXG4gICAgICAgICAgICB6SW5kZXg6ICcrMSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiZmllbGQ6Zm9jdXNcIjoge1xyXG4gICAgICAgICAgICBvdXRsaW5lOiAnbm9uZSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiaWNvblwiOiB7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxyXG4gICAgICAgICAgICB0b3A6IDAsXHJcbiAgICAgICAgICAgIGxlZnQ6IDAsXHJcbiAgICAgICAgICAgIGJvdHRvbTogMCxcclxuICAgICAgICAgICAgd2lkdGg6IDMwXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcImhpZ2hsaWdodC1ib3JkZXJcIjoge1xyXG4gICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcclxuICAgICAgICAgICAgYm90dG9tOiAwLFxyXG4gICAgICAgICAgICBib3JkZXJCb3R0b206IGAycHggc29saWQgJHtjb29sQmx1ZX1gLFxyXG4gICAgICAgICAgICBsZWZ0OiAnNTAlJyxcclxuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlWCgtNTAlKSBzY2FsZVgoMCknLFxyXG4gICAgICAgICAgICB3aWR0aDogJzEwMCUnLFxyXG4gICAgICAgICAgICB6SW5kZXg6ICcrMidcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiZmllbGQ6Zm9jdXMgKyBoaWdobGlnaHQtYm9yZGVyXCI6IHtcclxuICAgICAgICAgICAgLy8gd2lkdGg6ICcxMDAlJyxcclxuICAgICAgICAgICAgV2Via2l0VHJhbnNpdGlvbjogJy13ZWJraXQtdHJhbnNmb3JtIDI1MG1zIGxpbmVhcicsXHJcbiAgICAgICAgICAgIHRyYW5zaXRpb246ICd0cmFuc2Zvcm0gMTUwbXMgbGluZWFyJyxcclxuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlWCgtNTAlKSBzY2FsZVgoMSknXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcImxhYmVsXCI6IHtcclxuICAgICAgICAgICAgY29sb3I6IFwiYmxhY2tcIixcclxuICAgICAgICAgICAgZm9udFNpemU6IDE2LFxyXG4gICAgICAgICAgICBwYWRkaW5nOiAzXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4pO1xyXG5jbGFzcyBJbnB1dFdyYXBwZXIgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xyXG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcclxuICAgICAgICBzdXBlcihwcm9wcyk7XHJcbiAgICB9XHJcblxyXG4gICAgZm9jdXMgPSAoKSA9PiB7XHJcbiAgICAgICAgdGhpcy5yZWZzLmZpZWxkLmZvY3VzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmVuZGVyID0gKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHtwYXJzZXIgPSBpID0+IGksIG9uQ2hhbmdlID0gKCkgPT4ge30sIGljb25OYW1lID0gbnVsbCwgc3R5bGUgPSB7fSwgYm9yZGVyUmFkaXVzID0gbnVsbCwgLi4ucHJvcHN9ID0gdGhpcy5wcm9wcztcclxuICAgICAgICBjb25zdCBoYW5kbGVyID0gZXZ0ID0+IHtcclxuICAgICAgICAgICAgLy8gY29uc3QgcmF3ID0gZXZ0LnRhcmdldC52YWx1ZTtcclxuICAgICAgICAgICAgb25DaGFuZ2UocGFyc2VyKGV2dC50YXJnZXQudmFsdWUpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGxldCByZWFsU3R5bGUgPSB7Li4uc3R5bGV9O1xyXG4gICAgICAgIGxldCBib3JkZXJTdHlsZSA9IHt9O1xyXG4gICAgICAgIGxldCBpY29uRGlzcGxheSA9IG51bGw7XHJcblxyXG4gICAgICAgIGlmIChpY29uTmFtZSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBpY29uRGlzcGxheSA9IDxDZW50ZXJDb250ZW50IGNsYXNzTmFtZT1cImlucHV0LWNvcmUtaWNvblwiIGhlaWdodD1cIjEwMCVcIj48SWNvbiBuYW1lPXtpY29uTmFtZX0gc2l6ZT17MTh9IC8+PC9DZW50ZXJDb250ZW50PjtcclxuICAgICAgICAgICAgcmVhbFN0eWxlLnBhZGRpbmdMZWZ0ID0gMzA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChib3JkZXJSYWRpdXMgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmVhbFN0eWxlLmJvcmRlclJhZGl1cyA9IGJvcmRlclJhZGl1cztcclxuICAgICAgICAgICAgYm9yZGVyU3R5bGUuYm9yZGVyUmFkaXVzID0gYm9yZGVyUmFkaXVzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJpbnB1dC1jb3JlLXdyYXBwZXJcIj5cclxuICAgICAgICAgICAgICAgIDxpbnB1dCB7Li4ucHJvcHN9IHN0eWxlPXtyZWFsU3R5bGV9IG9uQ2hhbmdlPXtoYW5kbGVyfSBjbGFzc05hbWU9XCJpbnB1dC1jb3JlLWZpZWxkXCIgcmVmPVwiZmllbGRcIiAvPlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJpbnB1dC1jb3JlLWhpZ2hsaWdodC1ib3JkZXJcIiBzdHlsZT17Ym9yZGVyU3R5bGV9IC8+XHJcbiAgICAgICAgICAgICAgICB7aWNvbkRpc3BsYXl9XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgTGFiZWxlZElucHV0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XHJcbiAgICAgICAgc3VwZXIocHJvcHMpO1xyXG4gICAgfVxyXG5cclxuICAgIGZvY3VzID0gKCkgPT4ge1xyXG4gICAgICAgIHRoaXMucmVmcy53cmFwcGVkLmZvY3VzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmVuZGVyID0gKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHtsYWJlbCwgV3JhcHBlciA9IElucHV0V3JhcHBlciwgLi4ucHJvcHN9ID0gdGhpcy5wcm9wcztcclxuXHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPGRpdiBzdHlsZT17e3Bvc2l0aW9uOiAncmVsYXRpdmUnfX0+XHJcbiAgICAgICAgICAgICAgICA8VG91Y2hhYmxlIGNvbXBvbmVudD1cImRpdlwiIGNsYXNzTmFtZT1cImlucHV0LWNvcmUtbGFiZWxcIiBvblRhcD17KCkgPT4gdGhpcy5yZWZzLndyYXBwZWQuZm9jdXMoKX0+e2xhYmVsfTwvVG91Y2hhYmxlPlxyXG4gICAgICAgICAgICAgICAgPFdyYXBwZXIgcmVmPVwid3JhcHBlZFwiIHsuLi5wcm9wc30gLz5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgKTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBWYWxpZGF0ZWRJbnB1dCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xyXG4gICAgICAgIHN1cGVyKHByb3BzKTtcclxuICAgIH1cclxuXHJcbiAgICBmb2N1cyA9ICgpID0+IHtcclxuICAgICAgICB0aGlzLnJlZnMuaW5wdXQuZm9jdXMoKTtcclxuICAgIH1cclxuXHJcbiAgICByZW5kZXIgPSAoKSA9PiB7XHJcbiAgICAgICAgY29uc3Qge3ZhbGlkYXRvciwgb25DaGFuZ2UgPSAoKSA9PiB7fSwgLi4ucHJvcHN9ID0gdGhpcy5wcm9wcztcclxuICAgICAgICBjb25zdCBjaGFuZ2VIYW5kbGVyID0gdmFsdWUgPT4gb25DaGFuZ2UodmFsdWUsIHZhbGlkYXRvcih2YWx1ZSkpO1xyXG4gICAgICAgIHJldHVybiA8TGFiZWxlZElucHV0IHsuLi5wcm9wc30gb25DaGFuZ2U9e2NoYW5nZUhhbmRsZXJ9IC8+O1xyXG4gICAgfVxyXG59XHJcblxyXG5jb25zdCBJbnB1dCA9IHtcclxuICAgIFRleHQ6IHByb3BzID0+IDxMYWJlbGVkSW5wdXQgey4uLnByb3BzfSB0eXBlPVwidGV4dFwiIC8+LFxyXG4gICAgUGFzc3dvcmQ6IHByb3BzID0+IDxMYWJlbGVkSW5wdXQgey4uLnByb3BzfSB0eXBlPVwicGFzc3dvcmRcIiAvPixcclxuICAgIFNlYXJjaDogcHJvcHMgPT4gPExhYmVsZWRJbnB1dCB7Li4ucHJvcHN9IHR5cGU9XCJzZWFyY2hcIiBpY29uTmFtZT1cImlvbi1zZWFyY2hcIiAvPixcclxuICAgIERhdGU6IERhdGVJbnB1dCxcclxuICAgIFJhbmdlOiBSYW5nZUlucHV0LFxyXG4gICAgVGltZTogVGltZUlucHV0LFxyXG4gICAgRmlsZTogRmlsZUlucHV0LFxyXG4gICAgLy8gRGF0ZTogcHJvcHMgPT4gPERhdGVJbnB1dCB7Li4ucHJvcHN9IC8+LFxyXG4gICAgLy8gUmFuZ2U6IHByb3BzID0+IDxSYW5nZUlucHV0IHsuLi5wcm9wc30gLz4sXHJcbiAgICAvLyBUaW1lOiBwcm9wcyA9PiA8VGltZUlucHV0IHsuLi5wcm9wc30gLz4sXHJcbiAgICAvLyBGaWxlOiBwcm9wcyA9PiA8RmlsZUlucHV0IHsuLi5wcm9wc30gLz4sXHJcbiAgICBVUkw6ICh7dmFsaWRhdG9yID0gdXJsID0+IC9eKGh0dHBzPzpcXC9cXC8pPyhcXHcrKFxcLlxcdyspK3xsb2NhbGhvc3QpKFxcL1tcXHdcXCNcXC1cXCVdKykqXFwvPyQvLnRlc3QodXJsKSwgLi4ucHJvcHN9KSA9PiA8VmFsaWRhdGVkSW5wdXQgdmFsaWRhdG9yPXt2YWxpZGF0b3J9IHsuLi5wcm9wc30gdHlwZT1cInVybFwiIC8+LFxyXG4gICAgRW1haWw6ICh7dmFsaWRhdG9yID0gZW1haWwgPT4gL14oW2EtekEtWl1cXHcqKShcXC4oW2EtekEtWl1cXHcqKSkqXFxAKFthLXpBLVpdXFx3KikoXFwuKFthLXpBLVpdXFx3KikpKyQvLnRlc3QoZW1haWwpLCAuLi5wcm9wc30pID0+IDxWYWxpZGF0ZWRJbnB1dCB2YWxpZGF0b3I9e3ZhbGlkYXRvcn0gey4uLnByb3BzfSB0eXBlPVwiZW1haWxcIiAvPlxyXG59O1xyXG5cclxuSW5wdXQuVGV4dC52YWx1ZVByb3AgPSAndmFsdWUnO1xyXG5JbnB1dC5UZXh0LnZhbHVlRnVuY3Rpb24gPSB0ZXh0ID0+IHRleHQ7XHJcbklucHV0LlRleHQuZGVmYXVsdFByb3BWYWx1ZSA9IFwiXCI7XHJcblxyXG5JbnB1dC5QYXNzd29yZC52YWx1ZVByb3AgPSAndmFsdWUnO1xyXG5JbnB1dC5QYXNzd29yZC52YWx1ZUZ1bmN0aW9uID0gdGV4dCA9PiB0ZXh0O1xyXG5JbnB1dC5QYXNzd29yZC5kZWZhdWx0UHJvcFZhbHVlID0gXCJcIjtcclxuXHJcbklucHV0LlNlYXJjaC52YWx1ZVByb3AgPSAndmFsdWUnO1xyXG5JbnB1dC5TZWFyY2gudmFsdWVGdW5jdGlvbiA9IHRleHQgPT4gdGV4dDtcclxuSW5wdXQuU2VhcmNoLmRlZmF1bHRQcm9wVmFsdWUgPSBcIlwiO1xyXG5cclxuSW5wdXQuVVJMLnZhbHVlUHJvcCA9ICd2YWx1ZSc7XHJcbklucHV0LlVSTC52YWx1ZUZ1bmN0aW9uID0gKHRleHQsIHZhbGlkKSA9PiAoe3RleHQsIHZhbGlkfSk7XHJcbklucHV0LlVSTC5kZWZhdWx0UHJvcFZhbHVlID0gXCJcIjtcclxuXHJcbklucHV0LkVtYWlsLnZhbHVlUHJvcCA9ICd2YWx1ZSc7XHJcbklucHV0LkVtYWlsLnZhbHVlRnVuY3Rpb24gPSAodGV4dCwgdmFsaWQpID0+ICh7dGV4dCwgdmFsaWR9KTtcclxuSW5wdXQuRW1haWwuZGVmYXVsdFByb3BWYWx1ZSA9IFwiXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBJbnB1dDtcclxuIiwiY29uc3QgT3B0aW9uID0gKCkgPT4ge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiT3B0aW9uIGlzIGludGVuZGVkIGFzIGEgZmlsbGVyIGVsZW1lbnQgYW5kIHNob3VsZCBub3QgYmUgcmVuZGVyZWQgb24gaXRzIG93blwiKTtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IE9wdGlvbjtcclxuIiwiaW1wb3J0IHtkZWZpbmVDb21wb25lbnRTdHlsZX0gZnJvbSBcImxpYi1zb3VyY2UvdjIvc3R5bGVcIjtcclxuaW1wb3J0IENlbnRlckNvbnRlbnQgZnJvbSBcImxpYi1zb3VyY2UvdWl2Mi9DZW50ZXJDb250ZW50XCI7XHJcbmltcG9ydCBUb3VjaGFibGUgZnJvbSBcImxpYi1zb3VyY2UvdWl2Mi9Ub3VjaGFibGVcIjtcclxuaW1wb3J0IEljb24gZnJvbSBcImxpYi1zb3VyY2UvdWl2Mi9JY29uXCI7XHJcblxyXG5kZWZpbmVDb21wb25lbnRTdHlsZShcclxuICAgICdyYWRpbycsXHJcbiAgICAnY29yZScsXHJcbiAgICB7XHJcbiAgICAgICAgXCJ0aXRsZVwiOiB7XHJcbiAgICAgICAgICAgIGZvbnRTaXplOiAyMixcclxuICAgICAgICAgICAgcGFkZGluZzogM1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuKTtcclxuZGVmaW5lQ29tcG9uZW50U3R5bGUoXHJcbiAgICBcInJhZGlvLWl0ZW1cIixcclxuICAgIFwiY29yZVwiLFxyXG4gICAge1xyXG4gICAgICAgIFwiZGVmYXVsdC1pdGVtXCI6IHtcclxuICAgICAgICAgICAgY29sb3I6ICdibGFjaycsXHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxyXG4gICAgICAgICAgICBwYWRkaW5nTGVmdDogMzAsXHJcbiAgICAgICAgICAgIHRyYW5zaXRpb246ICdiYWNrZ3JvdW5kLWNvbG9yIDUwMG1zIGxpbmVhcidcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8vIFwiLnJhZGlvLWl0ZW0tY29udGFpbmVyOmFjdGl2ZSA+IGRlZmF1bHQtaXRlbVwiOiB7XHJcbiAgICAgICAgXCJkZWZhdWx0LWl0ZW06YWN0aXZlXCI6IHtcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSgwLCAwLCAwLCAwLjEpJyxcclxuICAgICAgICAgICAgdHJhbnNpdGlvbjogJ25vbmUnXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcImljb25cIjoge1xyXG4gICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcclxuICAgICAgICAgICAgdG9wOiAwLFxyXG4gICAgICAgICAgICBsZWZ0OiAwLFxyXG4gICAgICAgICAgICBib3R0b206IDAsXHJcbiAgICAgICAgICAgIHdpZHRoOiAzMFxyXG4gICAgICAgIH1cclxuICAgIH1cclxuKTtcclxuY29uc3QgUmFkaW9JdGVtID0gKHtjaGVja2VkLCBpY29uQ29sb3IsIGNoaWxkcmVuLCBvblRhcH0pID0+IHtcclxuICAgIGNvbnN0IGljb25OYW1lID0gYGlvbi1hbmRyb2lkLXJhZGlvLWJ1dHRvbi0ke2NoZWNrZWQgPT09IHRydWUgPyAnb24nIDogJ29mZid9YDtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPFRvdWNoYWJsZSBjb21wb25lbnQ9XCJkaXZcIiBvblRhcD17b25UYXB9IGNsYXNzTmFtZT1cInJhZGlvLWl0ZW0tY29yZS1kZWZhdWx0LWl0ZW1cIiBkYXRhLWNoZWNrZWQ9e2NoZWNrZWR9PlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17YHJhZGlvLWl0ZW0tY29yZS1pY29uYH0gZGF0YS1jaGVja2VkPXtjaGVja2VkfT5cclxuICAgICAgICAgICAgICAgIDxDZW50ZXJDb250ZW50IGhlaWdodD1cIjEwMCVcIj5cclxuICAgICAgICAgICAgICAgICAgICA8SWNvbiBzaXplPXsxOH0gbmFtZT17aWNvbk5hbWV9IC8+XHJcbiAgICAgICAgICAgICAgICA8L0NlbnRlckNvbnRlbnQ+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICB7Y2hpbGRyZW59XHJcbiAgICAgICAgPC9Ub3VjaGFibGU+XHJcbiAgICApO1xyXG59O1xyXG5jbGFzcyBSYWRpbyBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xyXG4gICAgICAgIHN1cGVyKHByb3BzKTtcclxuICAgIH1cclxuXHJcbiAgICBzZWxlY3QgPSAoaW5kZXgsIHZhbHVlKSA9PiB7XHJcbiAgICAgICAgaWYgKGluZGV4ICE9PSB0aGlzLnByb3BzLnNlbGVjdGVkSW5kZXgpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZShpbmRleCwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZW5kZXIgPSAoKSA9PiB7XHJcbiAgICAgICAgY29uc3Qge1xyXG4gICAgICAgICAgICBsYXlvdXQgPSAnZGl2JyxcclxuICAgICAgICAgICAgc2VsZWN0ZWRJbmRleCxcclxuICAgICAgICAgICAgb25DaGFuZ2UgPSAoKSA9PiB7fSxcclxuICAgICAgICAgICAgc3R5bGVOYW1lID0gJ2NvcmUnLFxyXG4gICAgICAgICAgICB0aXRsZVxyXG4gICAgICAgIH0gPSB0aGlzLnByb3BzO1xyXG4gICAgICAgIGNvbnN0IENvbnRhaW5lciA9IGxheW91dDtcclxuXHJcbiAgICAgICAgbGV0IHtcclxuICAgICAgICAgICAgY2hpbGRyZW4sXHJcbiAgICAgICAgICAgIC4uLmxheW91dFByb3BzXHJcbiAgICAgICAgfSA9IHRoaXMucHJvcHM7XHJcbiAgICAgICAgbGV0IEl0ZW07XHJcblxyXG4gICAgICAgIGlmIChDb250YWluZXIgPT09ICdkaXYnKSB7XHJcbiAgICAgICAgICAgIEl0ZW0gPSBSYWRpb0l0ZW07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgSXRlbSA9IENvbnRhaW5lci5SYWRpb0l0ZW07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjaGlsZHJlbiA9IFJlYWN0LkNoaWxkcmVuLnRvQXJyYXkoY2hpbGRyZW4pO1xyXG4gICAgICAgIGxheW91dFByb3BzID0gT2JqZWN0LmVudHJpZXMobGF5b3V0UHJvcHMpLnJlZHVjZShcclxuICAgICAgICAgICAgKG5ld1Byb3BzLCBba2V5LCB2YWx1ZV0pID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChrZXkuc3RhcnRzV2l0aChcImxheW91dC1cIikgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdQcm9wc1trZXkuc2xpY2UoNyldID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3UHJvcHM7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHt9XHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPGRpdj5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicmFkaW8tY29yZS10aXRsZVwiPnt0aXRsZX08L2Rpdj5cclxuICAgICAgICAgICAgICAgIDxDb250YWluZXIgey4uLmxheW91dFByb3BzfT5cclxuICAgICAgICAgICAgICAgIHtjaGlsZHJlbi5tYXAoKGNoaWxkLCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gY2hpbGQucHJvcHMudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gPFRvdWNoYWJsZSBjb21wb25lbnQ9XCJkaXZcIiBjbGFzc05hbWU9XCJyYWRpby1pdGVtLWNvbnRhaW5lclwiIGtleT17aW5kZXh9IG9uVGFwPXsoKSA9PiB0aGlzLnNlbGVjdChpbmRleCwgdmFsdWUpfT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxJdGVtIGNoZWNrZWQ9e3NlbGVjdGVkSW5kZXggPT09IGluZGV4fSB7Li4uY2hpbGQucHJvcHN9IG9uVGFwPXsoKSA9PiB0aGlzLnNlbGVjdChpbmRleCwgdmFsdWUpfSAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB7Lyo8L1RvdWNoYWJsZT4qL31cclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgfSl9XHJcbiAgICAgICAgICAgICAgICA8L0NvbnRhaW5lcj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgKTtcclxuICAgIH1cclxufVxyXG5cclxuUmFkaW8udmFsdWVQcm9wID0gJ3NlbGVjdGVkSW5kZXgnO1xyXG5SYWRpby52YWx1ZUZ1bmN0aW9uID0gKGluZGV4LCB2YWx1ZSkgPT4gKHtpbmRleCwgdmFsdWV9KTtcclxuUmFkaW8uZGVmYXVsdFByb3BWYWx1ZSA9IDA7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBSYWRpbztcclxuIiwiaW1wb3J0IEltYWdlIGZyb20gXCJsaWItc291cmNlL3VpdjIvSW1hZ2VcIjtcclxuaW1wb3J0IFNwaW5uZXJEYXRhVVJMIGZyb20gXCJsaWItc291cmNlL2RhdGEtdXJpL2xvYWQtc3Bpbm5lci5naWYuc291cmNlXCI7XHJcblxyXG5jb25zdCBTcGlubmVyID0gKHtzaXplfSkgPT4gPEltYWdlIHdpZHRoPXtzaXplfSBoZWlnaHQ9e3NpemV9IHNvdXJjZT17U3Bpbm5lckRhdGFVUkx9IC8+O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgU3Bpbm5lcjtcclxuIiwiaW1wb3J0IHtkZWZpbmVDb21wb25lbnRTdHlsZX0gZnJvbSBcImxpYi1zb3VyY2UvdjIvc3R5bGVcIjtcclxuaW1wb3J0IFJhbmdlSW5wdXQgZnJvbSAnbGliLXNvdXJjZS91aXYyL2lucHV0L1JhbmdlSW5wdXQnO1xyXG5cclxuZGVmaW5lQ29tcG9uZW50U3R5bGUoXHJcbiAgICAndGltZS1zZWxlY3RvcicsXHJcbiAgICAnY29yZScsXHJcbiAgICB7XHJcbiAgICAgICAgXCJ0aW1lLWRpc3BsYXlcIjoge1xyXG4gICAgICAgICAgICB0ZXh0QWxpZ246ICdjZW50ZXInLFxyXG4gICAgICAgICAgICBmb250U2l6ZTogMjQsXHJcbiAgICAgICAgICAgIGNvbG9yOiAnYmxhY2snXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4pO1xyXG5jbGFzcyBUaW1lU2VsZWN0b3IgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xyXG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcclxuICAgICAgICBzdXBlcihwcm9wcyk7XHJcbiAgICB9XHJcblxyXG4gICAgY2hhbmdlID0gcHJvcCA9PlxyXG4gICAgICAgIChuZXdWYWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB7dmFsdWUsIG9uQ2hhbmdlID0gd2FybmluZ0Z1bmMoXCJvbkNoYW5nZSBub3QgZ2l2ZW4gdG8gVGltZVNlbGVjdG9yXCIpfSA9IHRoaXMucHJvcHM7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoYW5nZWQgPSB7W3Byb3BdOiBuZXdWYWx1ZX07XHJcblxyXG4gICAgICAgICAgICBvbkNoYW5nZSh2YWx1ZS5zZXQoY2hhbmdlZCkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICByZW5kZXIgPSAoKSA9PiB7XHJcbiAgICAgICAgY29uc3Qge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IG51bGwsXHJcbiAgICAgICAgICAgIGZvcm1hdCA9IFwie2hvdXIvMTJwYWRkZWR9OnttaW51dGUvcGFkZGVkfSB7dG9kfVwiXHJcbiAgICAgICAgfSA9IHRoaXMucHJvcHM7XHJcbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBhIHZhbHVlIHRvIFRpbWVTZWxlY3RvclwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qge2hvdXJzLCBtaW51dGVzfSA9IHZhbHVlO1xyXG5cclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0aW1lLXNlbGVjdG9yLWNvcmUtdGltZS1kaXNwbGF5XCI+e3ZhbHVlLmZvcm1hdChmb3JtYXQpfTwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPFJhbmdlSW5wdXQga2V5PVwiMFwiIHZhbHVlPXtob3Vyc30gbWluPXswfSBtYXg9ezIzfSBsYWJlbD1cIkhvdXJcIiBvbkNoYW5nZT17dGhpcy5jaGFuZ2UoJ2hvdXJzJyl9IHNob3dBcnJvd3MgLz5cclxuICAgICAgICAgICAgICAgIDxSYW5nZUlucHV0IGtleT1cIjFcIiB2YWx1ZT17bWludXRlc30gbWluPXswfSBtYXg9ezU5fSBsYWJlbD1cIk1pbnV0ZVwiIG9uQ2hhbmdlPXt0aGlzLmNoYW5nZSgnbWludXRlcycpfSBzaG93QXJyb3dzIC8+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFRpbWVTZWxlY3RvcjtcclxuIiwiaW1wb3J0IHtkZWZpbmVDb21wb25lbnRTdHlsZSwgZGVmaW5lQ3VzdG9tQmFzZX0gZnJvbSBcImxpYi1zb3VyY2UvdjIvc3R5bGVcIjtcclxuaW1wb3J0IHt0cmFuc2ZlclByb3BzfSBmcm9tICdsaWItc291cmNlL3YyL3V0aWxzJztcclxuXHJcbmNvbnN0IGFuaW1hdGlvblRpbWUgPSAxMDA7XHJcbmRlZmluZUNvbXBvbmVudFN0eWxlKFxyXG4gICAgJ3RvZ2dsZScsXHJcbiAgICAnY29yZScsXHJcbiAgICB7XHJcbiAgICAgICAgXCJjb250YWluZXJcIjoge1xyXG4gICAgICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcclxuICAgICAgICAgICAgdHJhbnNpdGlvbjogJ2JhY2tncm91bmQtY29sb3IgNTAwbXMgbGluZWFyJyxcclxuICAgICAgICAgICAgZm9udFNpemU6IDIwLFxyXG4gICAgICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbidcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiY29udGFpbmVyOmFjdGl2ZVwiOiB7XHJcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMCwgMCwgMCwgMC4wNzUpJyxcclxuICAgICAgICAgICAgdHJhbnNpdGlvbjogJ25vbmUnXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcInRvZ2dsZS1jb250YWluZXJcIjoge1xyXG4gICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcclxuICAgICAgICAgICAgcmlnaHQ6IDEzLFxyXG4gICAgICAgICAgICB3aWR0aDogMzAsXHJcbiAgICAgICAgICAgIHRvcDogJzUwJScsXHJcbiAgICAgICAgICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGVZKC01MCUpXCIsXHJcbiAgICAgICAgICAgIGhlaWdodDogOCxcclxuICAgICAgICAgICAgZm9udFNpemU6IDExLFxyXG4gICAgICAgICAgICBib3JkZXJSYWRpdXM6IDE1LFxyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdsaWdodGdyYXknLFxyXG4gICAgICAgICAgICBsaW5lSGVpZ2h0OiAnMjJweCdcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwidG9nZ2xlLWNvbnRhaW5lcltkYXRhLW9uPSd0cnVlJ11cIjoge1xyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjYmVkMGJkJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJ0b2dnbGVcIjoge1xyXG4gICAgICAgICAgICBXZWJraXRUcmFuc2l0aW9uOiBgYmFja2dyb3VuZC1jb2xvciAke2FuaW1hdGlvblRpbWV9bXMgbGluZWFyLCAtd2Via2l0LXRyYW5zZm9ybSAke2FuaW1hdGlvblRpbWV9bXMgbGluZWFyYCxcclxuICAgICAgICAgICAgdHJhbnNpdGlvbjogYGJhY2tncm91bmQtY29sb3IgJHthbmltYXRpb25UaW1lfW1zIGxpbmVhciwgdHJhbnNmb3JtICR7YW5pbWF0aW9uVGltZX1tcyBsaW5lYXJgLFxyXG4gICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcclxuICAgICAgICAgICAgbGVmdDogLTExLFxyXG4gICAgICAgICAgICB0b3A6IC03LFxyXG4gICAgICAgICAgICBoZWlnaHQ6IDIyLFxyXG4gICAgICAgICAgICB3aWR0aDogMjIsXHJcbiAgICAgICAgICAgIGJvcmRlclJhZGl1czogMTUsXHJcbiAgICAgICAgICAgIHRleHRBbGlnbjogJ2NlbnRlcicsXHJcbiAgICAgICAgICAgIGJvcmRlcjogJzFweCBzb2xpZCBsaWdodGdyYXknLFxyXG4gICAgICAgICAgICBib3hTaGFkb3c6ICcycHggMnB4IDJweCByZ2JhKDAsIDAsIDAsIDAuMTUpJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJ0b2dnbGVbZGF0YS1vbj0nZmFsc2UnXVwiOiB7XHJcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVgoMCknLFxyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICd3aGl0ZSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwidG9nZ2xlW2RhdGEtb249J3RydWUnXVwiOiB7XHJcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVgoMzBweCknLFxyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjMjRiMzI0J1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJsYWJlbFwiOiB7XHJcbiAgICAgICAgICAgIHBhZGRpbmc6IDMsXHJcbiAgICAgICAgICAgIHBhZGRpbmdSaWdodDogNzAsXHJcbiAgICAgICAgICAgIHdoaXRlU3BhY2U6ICdwcmUnLFxyXG4gICAgICAgICAgICBjb2xvcjogJ2JsYWNrJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJzdWJ0aXRsZVwiOiB7XHJcbiAgICAgICAgICAgIGNvbG9yOiAnZ3JheScsXHJcbiAgICAgICAgICAgIGZvbnRTaXplOiAxNFxyXG4gICAgICAgIH1cclxuICAgIH1cclxuKTtcclxuXHJcbmNvbnN0IFRvZ2dsZSA9IHByb3BzID0+IHtcclxuICAgIGNvbnN0IHtcclxuICAgICAgICBvbiA9IGZhbHNlLFxyXG4gICAgICAgIGxhYmVsLFxyXG4gICAgICAgIHN1YlRpdGxlID0gbnVsbCxcclxuICAgICAgICBvbkNoYW5nZSA9ICgpID0+IGNvbnNvbGUud2FybihcIk5vIG9uQ2hhbmdlIGdpdmVuIHRvIGNoZWNrYm94XCIpLFxyXG4gICAgICAgIHN0eWxlTmFtZSA9ICdjb3JlJ1xyXG4gICAgfSA9IHByb3BzO1xyXG4gICAgbGV0IGNvbnRlbnQgPSBsYWJlbDtcclxuICAgIGxldCB0b2dnbGVTdHlsZTtcclxuXHJcbiAgICBpZiAoc3ViVGl0bGUgIT09IG51bGwpIHtcclxuICAgICAgICBjb250ZW50ID0gKFxyXG4gICAgICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgICAgICAge2xhYmVsfVxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjaGVja2JveC1jb3JlLXN1YnRpdGxlXCI+e3N1YlRpdGxlfTwvZGl2PlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPFVJLlRvdWNoYWJsZSBjb21wb25lbnQ9XCJkaXZcIiBjbGFzc05hbWU9XCJ0b2dnbGUtY29yZS1jb250YWluZXJcIiBvblRhcD17KCkgPT4gb25DaGFuZ2UoIW9uKX0+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtgdG9nZ2xlLWNvcmUtbGFiZWwgdG9nZ2xlLSR7c3R5bGVOYW1lfS1sYWJlbC1jdXN0b21gfT57Y29udGVudH08L2Rpdj5cclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2B0b2dnbGUtY29yZS10b2dnbGUtY29udGFpbmVyIHRvZ2dsZS0ke3N0eWxlTmFtZX0tdG9nZ2xlLWNvbnRhaW5lci1jdXN0b21gfSBkYXRhLW9uPXtvbn0+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17YHRvZ2dsZS1jb3JlLXRvZ2dsZSB0b2dnbGUtJHtzdHlsZU5hbWV9LXRvZ2dsZS1jdXN0b21gfSBkYXRhLW9uPXtvbn0gLz5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIHsvKjxSaXBwbGUgLz4qL31cclxuICAgICAgICA8L1VJLlRvdWNoYWJsZT5cclxuICAgICk7XHJcbn07XHJcblRvZ2dsZS5jb21wb25lbnROYW1lID0gJ3RvZ2dsZSc7XHJcblxyXG5kZWZpbmVDdXN0b21CYXNlKFxyXG4gICAgVG9nZ2xlLFxyXG4gICAgKHtub3JtYWwgPSBudWxsLCBvbiA9IG51bGwsIGxhYmVsID0gbnVsbCwgc3VidGl0bGUgPSBudWxsfSkgPT4gdHJhbnNmZXJQcm9wcyh7XHJcbiAgICAgICAgXCIudG9nZ2xlLWNvcmUtdG9nZ2xlLWNvbnRhaW5lci90b2dnbGUtY29udGFpbmVyLWN1c3RvbVwiOiBbXHJcbiAgICAgICAgICAgIG5vcm1hbCxcclxuICAgICAgICAgICAge3RyYWNrQ29sb3I6ICdiYWNrZ3JvdW5kQ29sb3InfVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgXCIudG9nZ2xlLWNvcmUtdG9nZ2xlLWNvbnRhaW5lci90b2dnbGUtY29udGFpbmVyLWN1c3RvbVtkYXRhLW9uPSd0cnVlJ11cIjogW1xyXG4gICAgICAgICAgICBvbixcclxuICAgICAgICAgICAge3RyYWNrQ29sb3I6ICdiYWNrZ3JvdW5kQ29sb3InfVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgXCIudG9nZ2xlLWNvcmUtdG9nZ2xlL3RvZ2dsZS1jdXN0b21cIjogW1xyXG4gICAgICAgICAgICBub3JtYWwsXHJcbiAgICAgICAgICAgIHt0aHVtYkNvbG9yOiAnYmFja2dyb3VuZENvbG9yJ31cclxuICAgICAgICBdLFxyXG4gICAgICAgIFwiLnRvZ2dsZS1jb3JlLXRvZ2dsZS90b2dnbGUtY3VzdG9tW2RhdGEtb249J3RydWUnXVwiOiBbXHJcbiAgICAgICAgICAgIG9uLFxyXG4gICAgICAgICAgICB7dGh1bWJDb2xvcjogJ2JhY2tncm91bmRDb2xvcid9XHJcbiAgICAgICAgXSxcclxuICAgICAgICBcIi50b2dnbGUtY29yZS1sYWJlbC9sYWJlbC1jdXN0b21cIjogW1xyXG4gICAgICAgICAgICBsYWJlbCxcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGV4dENvbG9yOiAnY29sb3InLFxyXG4gICAgICAgICAgICAgICAgY29sb3I6ICdiYWNrZ3JvdW5kQ29sb3InXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICBdLFxyXG4gICAgICAgIFwiLnRvZ2dsZS1jb3JlLXN1YnRpdGxlL3N1YnRpdGxlLWN1c3RvbVwiOiBbXHJcbiAgICAgICAgICAgIHN1YnRpdGxlLFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0Q29sb3I6ICdjb2xvcicsXHJcbiAgICAgICAgICAgICAgICBjb2xvcjogJ2JhY2tncm91bmRDb2xvcidcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIF1cclxuICAgIH0pXHJcbik7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBUb2dnbGU7XHJcbiIsIi8vIGltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcclxuLy8gaW1wb3J0IFJlYWN0RE9NIGZyb20gXCJyZWFjdC1kb21cIjtcclxuXHJcbmNvbnN0IGZvckVhY2ggPSBBcnJheS5wcm90b3R5cGUuZm9yRWFjaDtcclxuY29uc3Qge3NxcnR9ID0gTWF0aDtcclxuXHJcbmxldCBUb3VjaGFibGU7XHJcblxyXG5Ub3VjaGFibGUgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XHJcbiAgICB0b3VjaFN0YXJ0KGV2dCkge1xyXG4gICAgICAgIGNvbnN0IHtvblRvdWNoU3RhcnR9ID0gdGhpcy5wcm9wcztcclxuICAgICAgICBjb25zdCBbdG91Y2hdID0gZXZ0LmNoYW5nZWRUb3VjaGVzO1xyXG5cclxuICAgICAgICBSZWFjdERPTS5maW5kRE9NTm9kZSh0aGlzKS5jbGFzc0xpc3QuYWRkKFwiY29yLXRvdWNoLWFjdGl2ZVwiKTtcclxuICAgICAgICBpZiAob25Ub3VjaFN0YXJ0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgb25Ub3VjaFN0YXJ0KGV2dCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmluZm8gPSB7XHJcbiAgICAgICAgICAgIGlkOiB0b3VjaC5pZGVudGlmaWVyLFxyXG4gICAgICAgICAgICB4OiB0b3VjaC5wYWdlWCxcclxuICAgICAgICAgICAgeTogdG91Y2gucGFnZVlcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxuICAgIHRvdWNoTW92ZShldnQpIHtcclxuICAgICAgICBjb25zdCB7b25Ub3VjaE1vdmV9ID0gdGhpcy5wcm9wcztcclxuICAgICAgICBpZiAob25Ub3VjaE1vdmUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBvblRvdWNoTW92ZShldnQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZXZ0LmNoYW5nZWRUb3VjaGVzOjpmb3JFYWNoKHRvdWNoID0+IHtcclxuICAgICAgICAgICAgaWYgKHRvdWNoLmlkZW50aWZpZXIgIT09IHRoaXMuaW5mby5pZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoc3FydCgodG91Y2gucGFnZVggLSB0aGlzLmluZm8ueCkgKiogMiArICh0b3VjaC5wYWdlWSAtIHRoaXMuaW5mby55KSAqKiAyKSA+IDI1KSB7XHJcbiAgICAgICAgICAgICAgICBSZWFjdERPTS5maW5kRE9NTm9kZSh0aGlzKS5jbGFzc0xpc3QucmVtb3ZlKFwiY29yLXRvdWNoLWFjdGl2ZVwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgIHRvdWNoRW5kKGV2dCkge1xyXG4gICAgICAgIGNvbnN0IHtvblRvdWNoRW5kfSA9IHRoaXMucHJvcHM7XHJcbiAgICAgICAgaWYgKG9uVG91Y2hFbmQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBvblRvdWNoRW5kKGV2dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGV2dC5jaGFuZ2VkVG91Y2hlczo6Zm9yRWFjaCh0b3VjaCA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0b3VjaC5pZGVudGlmaWVyICE9PSB0aGlzLmluZm8uaWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgUmVhY3RET00uZmluZERPTU5vZGUodGhpcykuY2xhc3NMaXN0LnJlbW92ZShcImNvci10b3VjaC1hY3RpdmVcIik7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gdGhpcy5wcm9wcy5vblRvdWNoRW5kKGV2dCk7XHJcbiAgICB9LFxyXG4gICAgZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlZnMubm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgIH0sXHJcbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcclxuICAgICAgICBjb25zdCB7bm9kZX0gPSB0aGlzLnJlZnM7XHJcbiAgICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKFxyXG4gICAgICAgICAgICAndGFwJyxcclxuICAgICAgICAgICAgZXZ0ID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHtvblRhcH0gPSB0aGlzLnByb3BzO1xyXG4gICAgICAgICAgICAgICAgbm9kZS5mb2N1cygpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG9uVGFwICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzOjpvblRhcChldnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gOjp0aGlzLnByb3BzLm9uVGFwKGV2dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICApO1xyXG4gICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcclxuICAgICAgICAgICAgJ2hvbGQnLFxyXG4gICAgICAgICAgICBldnQgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qge29uSG9sZH0gPSB0aGlzLnByb3BzO1xyXG4gICAgICAgICAgICAgICAgbm9kZS5mb2N1cygpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG9uSG9sZCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpczo6b25Ib2xkKGV2dCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyA6OnRoaXMucHJvcHMub25Ib2xkKGV2dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICApO1xyXG4gICAgfSxcclxuICAgIHJlbmRlcigpIHtcclxuICAgICAgICBjb25zdCB7Y29tcG9uZW50ID0gbnVsbCwgY2hpbGRyZW4sIG9uVGFwLCBvbkhvbGQsIC4uLnByb3BzfSA9IHRoaXMucHJvcHM7XHJcbiAgICAgICAgY29uc3QgQ29tcG9uZW50ID0gY29tcG9uZW50O1xyXG4gICAgICAgIGNvbnN0IGNvbXBvbmVudFByb3BzID0ge1xyXG4gICAgICAgICAgICAuLi5wcm9wcyxcclxuICAgICAgICAgICAgb25Ub3VjaFN0YXJ0OiB0aGlzLnRvdWNoU3RhcnQsXHJcbiAgICAgICAgICAgIG9uVG91Y2hNb3ZlOiB0aGlzLnRvdWNoTW92ZSxcclxuICAgICAgICAgICAgb25Ub3VjaEVuZDogdGhpcy50b3VjaEVuZCxcclxuICAgICAgICAgICAgb25Ub3VjaENhbmNlbDogdGhpcy50b3VjaEVuZFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGlmIChDb21wb25lbnQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwYXNzIGEgY29tcG9uZW50IGludG8gVG91Y2hhYmxlXCIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIDxDb21wb25lbnQgcmVmPVwibm9kZVwiIHsuLi5jb21wb25lbnRQcm9wc30+e2NoaWxkcmVufTwvQ29tcG9uZW50PjtcclxuICAgIH1cclxufSk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBUb3VjaGFibGU7XHJcbiIsImltcG9ydCB7ZGVmaW5lQ29tcG9uZW50U3R5bGUsIGRlZmluZVN0eWxlRm9yQ29tcG9uZW50LCBkZWZpbmVDdXN0b21CYXNlfSBmcm9tIFwibGliLXNvdXJjZS92Mi9zdHlsZS5qc1wiO1xyXG5pbXBvcnQgUmlwcGxlIGZyb20gXCJsaWItc291cmNlL3VpdjIvcmlwcGxlLmpzXCI7XHJcbmltcG9ydCBJY29uIGZyb20gJ2xpYi1zb3VyY2UvdWl2Mi9pY29uLmpzJztcclxuaW1wb3J0IFRvdWNoYWJsZSBmcm9tICdsaWItc291cmNlL3VpdjIvVG91Y2hhYmxlJztcclxuaW1wb3J0IHZhcnMgZnJvbSAnbGliLXNvdXJjZS91aXYyL3ZhcnMnO1xyXG5pbXBvcnQge3RyYW5zZmVyUHJvcHN9IGZyb20gJ2xpYi1zb3VyY2UvdjIvdXRpbHMnO1xyXG5cclxuZGVmaW5lQ29tcG9uZW50U3R5bGUoXHJcbiAgICAnYnV0dG9uJyxcclxuICAgICdjb3JlJyxcclxuICAgIHtcclxuICAgICAgICBcIndyYXBwZXJcIjoge1xyXG4gICAgICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcclxuICAgICAgICAgICAgdGV4dEFsaWduOiAnY2VudGVyJyxcclxuICAgICAgICAgICAgbWFyZ2luOiA0LFxyXG4gICAgICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXHJcbiAgICAgICAgICAgIHpJbmRleDogXCIrMFwiLFxyXG4gICAgICAgICAgICB3aGl0ZVNwYWNlOiAncHJlJyxcclxuICAgICAgICAgICAgZGlzcGxheTogJ2lubGluZS1ibG9jaycsXHJcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3RyYW5zcGFyZW50JyxcclxuICAgICAgICAgICAgY29sb3I6ICdibGFjaycsXHJcbiAgICAgICAgICAgIGJvcmRlclJhZGl1czogM1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJ3cmFwcGVyOmZvY3VzXCI6IHtcclxuICAgICAgICAgICAgb3V0bGluZTogJ25vbmUnXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcIndyYXBwZXJbZGlzYWJsZWRdXCI6IHtcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnI2VhZWFlYScsXHJcbiAgICAgICAgICAgIGNvbG9yOiAnI2EwYTBhMCdcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwidGV4dC13cmFwcGVyXCI6IHtcclxuICAgICAgICAgICAgZGlzcGxheTogJ3RhYmxlJyxcclxuICAgICAgICAgICAgd2lkdGg6ICcxMDAlJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJ0ZXh0XCI6IHtcclxuICAgICAgICAgICAgaGVpZ2h0OiAnMTAwJScsXHJcbiAgICAgICAgICAgIHdpZHRoOiAnMTAwJScsXHJcbiAgICAgICAgICAgIHBhZGRpbmc6IDUsXHJcbiAgICAgICAgICAgIHBhZGRpbmdMZWZ0OiAxNSxcclxuICAgICAgICAgICAgcGFkZGluZ1JpZ2h0OiAxNSxcclxuICAgICAgICAgICAgdGV4dEFsaWduOiAnY2VudGVyJyxcclxuICAgICAgICAgICAgdmVydGljYWxBbGlnbjogJ21pZGRsZScsXHJcbiAgICAgICAgICAgIHdoaXRlU3BhY2U6ICdwcmUnLFxyXG4gICAgICAgICAgICBkaXNwbGF5OiAndGFibGUtY2VsbCdcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwid3JhcHBlciA+IG92ZXJsYXlcIjoge1xyXG4gICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcclxuICAgICAgICAgICAgdG9wOiAwLFxyXG4gICAgICAgICAgICBsZWZ0OiAwLFxyXG4gICAgICAgICAgICByaWdodDogMCxcclxuICAgICAgICAgICAgYm90dG9tOiAwLFxyXG4gICAgICAgICAgICB0cmFuc2l0aW9uOiAnYmFja2dyb3VuZC1jb2xvciA1MDBtcyBsaW5lYXInXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcIi5jb3JlLWRlc2t0b3Agb3ZlcmxheTpob3ZlclwiOiB7XHJcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogdmFycy5ob3ZlckNvbG9yXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcIndyYXBwZXI6YWN0aXZlID4gb3ZlcmxheVwiOiB7XHJcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogdmFycy5hY3RpdmVDb2xvcixcclxuICAgICAgICAgICAgdHJhbnNpdGlvbjogJ25vbmUnXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4pO1xyXG5cclxuY29uc3QgQnV0dG9uID0gcHJvcHMgPT4ge1xyXG4gICAgbGV0IHtcclxuICAgICAgICB0ZXh0LFxyXG4gICAgICAgIG9uVGFwID0gKCkgPT4gY29uc29sZS53YXJuKFwiTm8gb25UYXAgZ2l2ZW4gdG8gQnV0dG9uXCIpLFxyXG4gICAgICAgIHN0eWxlTmFtZSA9IFwiY29yZVwiLFxyXG4gICAgICAgIGJ1dHRvbkNvbG9yID0gbnVsbCxcclxuICAgICAgICB0ZXh0Q29sb3IgPSBudWxsLFxyXG4gICAgICAgIGZsdXNoLFxyXG4gICAgICAgIGJsb2NrLFxyXG4gICAgICAgIGZpbGwsXHJcbiAgICAgICAgcGFkZGluZyxcclxuICAgICAgICBkaXNhYmxlZCxcclxuICAgICAgICBpY29uTmFtZSA9IG51bGwsXHJcbiAgICAgICAgaWNvblNpemUgPSBudWxsXHJcbiAgICB9ID0gcHJvcHM7XHJcblxyXG4gICAgY29uc3Qgd3JhcHBlck5hbWUgPSBgYnV0dG9uLWNvcmUtd3JhcHBlciBidXR0b24tJHtzdHlsZU5hbWV9LXdyYXBwZXItY3VzdG9tYDtcclxuXHJcbiAgICBjb25zdCB3cmFwcGVyU3R5bGUgPSB7YmFja2dyb3VuZENvbG9yOiBidXR0b25Db2xvcn07XHJcbiAgICBjb25zdCB0ZXh0V3JhcHBlclN0eWxlID0ge307XHJcbiAgICBjb25zdCB0ZXh0U3R5bGUgPSB7Y29sb3I6IHRleHRDb2xvcn07XHJcbiAgICBsZXQgcmlwcGxlRWxlbWVudDtcclxuICAgIGxldCBvblRhcEhhbmRsZXI7XHJcblxyXG4gICAgaWYgKGRpc2FibGVkICE9PSB0cnVlKSB7XHJcbiAgICAgICAgLy8gcmlwcGxlRWxlbWVudCA9IDxSaXBwbGUgLz47XHJcbiAgICAgICAgb25UYXBIYW5kbGVyID0gb25UYXA7XHJcbiAgICB9XHJcbiAgICBpZiAoYmxvY2sgPT09IHRydWUpIHtcclxuICAgICAgICB3cmFwcGVyU3R5bGUuZGlzcGxheSA9ICdibG9jayc7XHJcbiAgICB9XHJcbiAgICBpZiAoZmlsbCA9PT0gdHJ1ZSkge1xyXG4gICAgICAgIGZsdXNoID0gdHJ1ZTtcclxuICAgICAgICB3cmFwcGVyU3R5bGUud2lkdGggPSAnMTAwJSc7XHJcbiAgICAgICAgd3JhcHBlclN0eWxlLmhlaWdodCA9ICcxMDAlJztcclxuICAgICAgICB0ZXh0V3JhcHBlclN0eWxlLmhlaWdodCA9ICcxMDAlJztcclxuICAgICAgICB0ZXh0U3R5bGUucGFkZGluZyA9IDA7XHJcbiAgICB9XHJcbiAgICBpZiAoZmx1c2ggPT09IHRydWUpIHtcclxuICAgICAgICB3cmFwcGVyU3R5bGUubWFyZ2luID0gMDtcclxuICAgIH1cclxuICAgIGlmIChpY29uTmFtZSAhPT0gbnVsbCkge1xyXG4gICAgICAgIHRleHQgPSA8c3Bhbj48SWNvbiBuYW1lPXtpY29uTmFtZX0gc2l6ZT17aWNvblNpemV9IC8+e3RleHR9PC9zcGFuPjtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxUb3VjaGFibGUgY29tcG9uZW50PVwiZGl2XCIgdGFiSW5kZXg9ey0xfSBjbGFzc05hbWU9e3dyYXBwZXJOYW1lfSBvblRhcD17b25UYXBIYW5kbGVyfSBkaXNhYmxlZD17ZGlzYWJsZWR9IHN0eWxlPXt3cmFwcGVyU3R5bGV9PlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImJ1dHRvbi1jb3JlLXRleHQtd3JhcHBlclwiIHN0eWxlPXt0ZXh0V3JhcHBlclN0eWxlfT5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYnV0dG9uLWNvcmUtdGV4dFwiIHN0eWxlPXt0ZXh0U3R5bGV9Pnt0ZXh0fTwvZGl2PlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJidXR0b24tY29yZS1vdmVybGF5XCIgLz5cclxuICAgICAgICAgICAge3JpcHBsZUVsZW1lbnR9XHJcbiAgICAgICAgPC9Ub3VjaGFibGU+XHJcbiAgICApO1xyXG59O1xyXG5CdXR0b24uY29tcG9uZW50TmFtZSA9ICdidXR0b24nO1xyXG5cclxuZGVmaW5lQ3VzdG9tQmFzZShcclxuICAgIEJ1dHRvbixcclxuICAgICh7bm9ybWFsID0gbnVsbCwgZm9jdXMgPSBudWxsLCBkaXNhYmxlZCA9IG51bGx9KSA9PiB0cmFuc2ZlclByb3BzKHtcclxuICAgICAgICBcIi5idXR0b24tY29yZS13cmFwcGVyL3dyYXBwZXItY3VzdG9tXCI6IFtcclxuICAgICAgICAgICAgbm9ybWFsLFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0Q29sb3I6ICdjb2xvcicsXHJcbiAgICAgICAgICAgICAgICBjb2xvcjogJ2JhY2tncm91bmRDb2xvcicsXHJcbiAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6ICdib3JkZXJSYWRpdXMnLFxyXG4gICAgICAgICAgICAgICAgc2hhZG93OiAnYm94U2hhZG93J1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFsnYmFja2dyb3VuZENvbG9yJywgJ2NvbG9yJywgJ2JvcmRlclJhZGl1cycsICdib3hTaGFkb3cnXVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgXCIuYnV0dG9uLWNvcmUtd3JhcHBlci93cmFwcGVyLWN1c3RvbTpmb2N1c1wiOiBbXHJcbiAgICAgICAgICAgIGZvY3VzLFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0Q29sb3I6ICdjb2xvcicsXHJcbiAgICAgICAgICAgICAgICBjb2xvcjogJ2JhY2tncm91bmRDb2xvcicsXHJcbiAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6ICdib3JkZXJSYWRpdXMnLFxyXG4gICAgICAgICAgICAgICAgc2hhZG93OiAnYm94U2hhZG93J1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFsnYmFja2dyb3VuZENvbG9yJywgJ2NvbG9yJywgJ2JvcmRlclJhZGl1cycsICdib3hTaGFkb3cnXVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgXCIuYnV0dG9uLWNvcmUtd3JhcHBlci93cmFwcGVyLWN1c3RvbVtkaXNhYmxlZF1cIjogW1xyXG4gICAgICAgICAgICBkaXNhYmxlZCxcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGV4dENvbG9yOiAnY29sb3InLFxyXG4gICAgICAgICAgICAgICAgY29sb3I6ICdiYWNrZ3JvdW5kQ29sb3InLFxyXG4gICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAnYm9yZGVyUmFkaXVzJyxcclxuICAgICAgICAgICAgICAgIHNoYWRvdzogJ2JveFNoYWRvdydcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBbJ2JhY2tncm91bmRDb2xvcicsICdjb2xvcicsICdib3JkZXJSYWRpdXMnLCAnYm94U2hhZG93J11cclxuICAgICAgICBdXHJcbiAgICB9KVxyXG4pO1xyXG5cclxuZGVmaW5lU3R5bGVGb3JDb21wb25lbnQoXHJcbiAgICBCdXR0b24sIFwiY2FuY2VsXCIsXHJcbiAgICB7XHJcbiAgICAgICAgbm9ybWFsOiB7XHJcbiAgICAgICAgICAgIGNvbG9yOiBcIiNiNTI2M2VcIixcclxuICAgICAgICAgICAgdGV4dENvbG9yOiAnd2hpdGUnXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4pO1xyXG5kZWZpbmVTdHlsZUZvckNvbXBvbmVudChcclxuICAgIEJ1dHRvbiwgXCJjb25maXJtXCIsXHJcbiAgICB7XHJcbiAgICAgICAgbm9ybWFsOiB7XHJcbiAgICAgICAgICAgIGNvbG9yOiBcIiMzMGQ1YTdcIlxyXG4gICAgICAgIH1cclxuICAgIH1cclxuKTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbjtcclxuIiwiaW1wb3J0IHtkZWZpbmVDb21wb25lbnRTdHlsZX0gZnJvbSBcImxpYi1zb3VyY2UvdjIvc3R5bGVcIjtcclxuaW1wb3J0IEJ1dHRvbiBmcm9tIFwibGliLXNvdXJjZS91aXYyL0J1dHRvblwiO1xyXG5pbXBvcnQgVG91Y2hhYmxlIGZyb20gXCJsaWItc291cmNlL3VpdjIvVG91Y2hhYmxlXCI7XHJcbmltcG9ydCBGbGV4Ym94IGZyb20gXCJsaWItc291cmNlL3VpdjIvbGF5b3V0L0ZsZXhib3hcIjtcclxuXHJcbmNvbnN0IGFuaW1hdGlvblRpbWUgPSAyNTA7XHJcbmRlZmluZUNvbXBvbmVudFN0eWxlKFxyXG4gICAgJ2RpYWxvZycsXHJcbiAgICAnY29yZScsXHJcbiAgICB7XHJcbiAgICAgICAgXCJvdmVybGF5XCI6IHtcclxuICAgICAgICAgICAgcG9zaXRpb246ICdmaXhlZCcsXHJcbiAgICAgICAgICAgIHRvcDogMCxcclxuICAgICAgICAgICAgbGVmdDogMCxcclxuICAgICAgICAgICAgd2lkdGg6ICcxMDAlJyxcclxuICAgICAgICAgICAgaGVpZ2h0OiAnMTAwJScsXHJcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMCwgMCwgMCwgMC4zNSknLFxyXG4gICAgICAgICAgICB6SW5kZXg6ICcrMTAwJyxcclxuICAgICAgICAgICAgZGlzcGxheTogJ25vbmUnLFxyXG4gICAgICAgICAgICBvcGFjaXR5OiAwLFxyXG4gICAgICAgICAgICB0cmFuc2l0aW9uOiBgb3BhY2l0eSAke2FuaW1hdGlvblRpbWV9bXMgbGluZWFyYFxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIFwid2luZG93XCI6IHtcclxuICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXHJcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3doaXRlJyxcclxuICAgICAgICAgICAgYm94U2hhZG93OiAnMHB4IDBweCAxMHB4IHJnYmEoMCwgMCwgMCwgMC42KScsXHJcbiAgICAgICAgICAgIHdpZHRoOiAnNzUlJyxcclxuICAgICAgICAgICAgbWF4V2lkdGg6IDQ4MCxcclxuICAgICAgICAgICAgcGFkZGluZzogMCxcclxuICAgICAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcIndpbmRvdy10b3BcIjoge1xyXG4gICAgICAgICAgICB0b3A6ICcxNSUnLFxyXG4gICAgICAgICAgICBsZWZ0OiAnNTAlJyxcclxuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlWCgtNTAlKSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwid2luZG93LWNlbnRlclwiOiB7XHJcbiAgICAgICAgICAgIHRvcDogJzUwJScsXHJcbiAgICAgICAgICAgIGxlZnQ6ICc1MCUnLFxyXG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUoLTUwJSwgLTUwJSknXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgXCJjb250ZW50XCI6IHtcclxuICAgICAgICAgICAgbWF4SGVpZ2h0OiAnNTB2aCcsXHJcbiAgICAgICAgICAgIFdlYmtpdE92ZXJmbG93U2Nyb2xsaW5nOiAndG91Y2gnLFxyXG4gICAgICAgICAgICBvdmVyZmxvdzogJ2F1dG8nXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcImJ1dHRvbnNcIjoge1xyXG4gICAgICAgICAgICBib3JkZXJUb3A6ICcxcHggc29saWQgbGlnaHRncmF5J1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJ0aXRsZVwiOiB7XHJcbiAgICAgICAgICAgIGJvcmRlckJvdHRvbTogJzFweCBzb2xpZCBsaWdodGdyYXknLFxyXG4gICAgICAgICAgICBwYWRkaW5nOiAnNSAxNScsXHJcbiAgICAgICAgICAgIGZvbnRTaXplOiAyMCxcclxuICAgICAgICAgICAgZm9udFdlaWdodDogOTAwLFxyXG4gICAgICAgICAgICBjb2xvcjogJ2JsYWNrJ1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuKTtcclxuXHJcbmxldCBjdXJyZW50RGlhbG9nID0gbnVsbDtcclxud2luZG93LmRpYWxvZyA9IHtcclxuICAgIHNob3cob3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiBjdXJyZW50RGlhbG9nLnNob3cob3B0aW9ucyk7XHJcbiAgICB9LFxyXG4gICAgaGlkZSh2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiBjdXJyZW50RGlhbG9nLmhpZGUodmFsdWUpO1xyXG4gICAgfSxcclxuICAgIHN1Y2Nlc3ModmFsdWUpIHtcclxuICAgICAgICByZXR1cm4ge3ZhbHVlLCBzdGF0dXM6ICdzdWNjZXNzJ307XHJcbiAgICB9LFxyXG4gICAgY2FuY2VsKHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHt2YWx1ZSwgc3RhdHVzOiAnY2FuY2VsZWQnfTtcclxuICAgIH0sXHJcbiAgICBpbnZhbGlkKHZhbHVlID0gbnVsbCwgcmVhc29uID0gJ2ludmFsaWQnKSB7XHJcbiAgICAgICAgcmV0dXJuIHt2YWx1ZSwgcmVhc29ufTtcclxuICAgIH1cclxufTtcclxuY2xhc3MgRGlhbG9nIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XHJcbiAgICAgICAgc3VwZXIocHJvcHMpO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XHJcbiAgICAgICAgICAgIGRpc3BsYXk6IG51bGwsXHJcbiAgICAgICAgICAgIG9wYWNpdHk6IG51bGwsXHJcbiAgICAgICAgICAgIG5hbWU6IG51bGwsXHJcbiAgICAgICAgICAgIHBvczogJ3RvcCcsXHJcbiAgICAgICAgICAgIGNvbnRlbnQ6IG51bGwsXHJcbiAgICAgICAgICAgIGNsb3NhYmxlOiAhdHJ1ZSxcclxuICAgICAgICAgICAgYnV0dG9uczogbnVsbCxcclxuICAgICAgICAgICAgdGl0bGU6IG51bGxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuYW5pbWF0aW5nID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5yZXNvbHZlciA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgc2hvdyA9IGFzeW5jIChkaXNwbGF5UHJvcHMpID0+IHtcclxuICAgICAgICBpZiAodGhpcy5hbmltYXRpbmcgPT09IHRydWUgfHwgdGhpcy5yZXNvbHZlciAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZGlhbG9nLmludmFsaWQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xyXG4gICAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUuV2Via2l0T3ZlcmZsb3dTY3JvbGxpbmcgPSAnYXV0byc7XHJcbiAgICAgICAgdGhpcy5hbmltYXRpbmcgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMucmVzb2x2ZXIgPSBuZXcgUHJvbWlzZShcclxuICAgICAgICAgICAgcmVzb2x2ZSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3BvbnNlID0gdmFsdWUgPT4gcmVzb2x2ZSh2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICApO1xyXG5cclxuICAgICAgICBjb25zdCB7XHJcbiAgICAgICAgICAgIGNvbnRlbnQgPSBudWxsLFxyXG4gICAgICAgICAgICBjbG9zYWJsZSA9IHRydWUsXHJcbiAgICAgICAgICAgIGJ1dHRvbnMgPSBbXHJcbiAgICAgICAgICAgICAgICB7dGV4dDogJ29rJ31cclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgdGl0bGUgPSBudWxsLFxyXG4gICAgICAgICAgICBzZXR1cCA9IG51bGxcclxuICAgICAgICB9ID0gZGlzcGxheVByb3BzO1xyXG5cclxuICAgICAgICB0aGlzLnNldFN0YXRlKHtkaXNwbGF5OiAnYmxvY2snLCBjb250ZW50LCBidXR0b25zLCBjbG9zYWJsZSwgdGl0bGV9KTtcclxuICAgICAgICBhd2FpdCBjaHJvbm8ud2FpdCg1MCk7XHJcbiAgICAgICAgdGhpcy5yZWZzLmNvbnRhaW5lci5zY3JvbGxUb3AgPSAwO1xyXG4gICAgICAgIGlmIChzZXR1cCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBzZXR1cCh0aGlzLnJlZnMuY29udGFpbmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7b3BhY2l0eTogMX0pO1xyXG4gICAgICAgIGF3YWl0IGNocm9uby53YWl0KGFuaW1hdGlvblRpbWUpO1xyXG4gICAgICAgIHRoaXMuYW5pbWF0aW5nID0gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucmVzb2x2ZXI7XHJcbiAgICB9XHJcbiAgICBoaWRlID0gYXN5bmMgKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2codGhpcy5hbmltYXRpbmcsIHRoaXMuYW5pbWF0aW5nID09PSB0cnVlKTtcclxuICAgICAgICBpZiAodGhpcy5hbmltYXRpbmcgPT09IHRydWUgfHwgdGhpcy5yZXNvbHZlID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5hbmltYXRpbmcgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe29wYWNpdHk6IG51bGx9KTtcclxuICAgICAgICBhd2FpdCBjaHJvbm8ud2FpdChhbmltYXRpb25UaW1lKTtcclxuICAgICAgICB0aGlzLnNldFN0YXRlKHtkaXNwbGF5OiBudWxsfSk7XHJcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvdyA9ICcnO1xyXG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLldlYmtpdE92ZXJmbG93U2Nyb2xsaW5nID0gJyc7XHJcbiAgICAgICAgICAgIHRoaXMucmVzcG9uc2UodmFsdWUpO1xyXG4gICAgICAgICAgICB0aGlzLnJlc3BvbnNlID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5yZXNvbHZlciA9IG51bGw7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5hbmltYXRpbmcgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBjbG9zZSA9ICgpID0+IHtcclxuICAgICAgICBpZiAodGhpcy5zdGF0ZS5jbG9zYWJsZSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmhpZGUoZGlhbG9nLmNhbmNlbChudWxsKSk7XHJcbiAgICB9XHJcbiAgICBzdG9wcGVyID0gKGV2dCkgPT4ge1xyXG4gICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgIH1cclxuICAgIHN0b3BTY3JvbGwgPSAoZXZ0KSA9PiB7XHJcbiAgICAgICAgLy8gaWYgKGV2dC5jYW5jZWxhYmxlID09PSB0cnVlKSB7XHJcbiAgICAgICAgLy8gICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIC8vIH1cclxuICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICB9XHJcblxyXG4gICAgY29tcG9uZW50RGlkTW91bnQgPSAoKSA9PiB7XHJcbiAgICAgICAgY3VycmVudERpYWxvZyA9IHRoaXM7XHJcbiAgICB9XHJcbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCA9ICgpID0+IHtcclxuICAgICAgICBjdXJyZW50RGlhbG9nID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICByZW5kZXIgPSAoKSA9PiB7XHJcbiAgICAgICAgY29uc3Qge2Rpc3BsYXksIG9wYWNpdHksIHBvcywgY29udGVudCwgYnV0dG9ucywgdGl0bGV9ID0gdGhpcy5zdGF0ZTtcclxuICAgICAgICBjb25zdCBidXR0b25MaXN0ID0gKGJ1dHRvbnMgfHwgW10pLm1hcChcclxuICAgICAgICAgICAgKHt0ZXh0LCB2YWx1ZSA9IG51bGwsIGNhbmNlbHMgPSBmYWxzZX0sIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBjb25zdCB2YWx1ZUZ1bmMgPSAoY2FuY2VscyA9PT0gdHJ1ZSkgPyBkaWFsb2cuY2FuY2VsIDogZGlhbG9nLnN1Y2Nlc3M7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvblRhcCA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUodGhpcy5yZWZzLmNvbnRhaW5lcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJldFZhbHVlID0gKGNhbmNlbHMgPT09IHRydWUpID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlhbG9nLmNhbmNlbCh2YWx1ZSkgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWFsb2cuc3VjY2Vzcyh2YWx1ZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGlkZShyZXRWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDxCdXR0b24gdGV4dD17dGV4dH0ga2V5PXtpbmRleH0gb25UYXA9e29uVGFwfSBibG9jayBmbHVzaCAvPjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgbGV0IHRpdGxlRGlzcGxheSA9IG51bGw7XHJcblxyXG4gICAgICAgIGlmICh0aXRsZSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aXRsZURpc3BsYXkgPSA8ZGl2IGNsYXNzTmFtZT1cImRpYWxvZy1jb3JlLXRpdGxlXCI+e3RpdGxlfTwvZGl2PjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIDxUb3VjaGFibGUgY29tcG9uZW50PVwiZGl2XCIgb25UYXA9e3RoaXMuY2xvc2V9IG9uVG91Y2hNb3ZlPXtldnQgPT4gZXZ0LnByZXZlbnREZWZhdWx0KCl9IGNsYXNzTmFtZT1cImRpYWxvZy1jb3JlLW92ZXJsYXlcIiBzdHlsZT17e2Rpc3BsYXksIG9wYWNpdHl9fT5cclxuICAgICAgICAgICAgICAgIDxUb3VjaGFibGUgY29tcG9uZW50PVwiZGl2XCIgY2xhc3NOYW1lPXtgZGlhbG9nLWNvcmUtd2luZG93IGRpYWxvZy1jb3JlLXdpbmRvdy0ke3Bvc31gfSBvblRhcD17dGhpcy5zdG9wcGVyfSBvblRvdWNoTW92ZT17dGhpcy5zdG9wU2Nyb2xsfT5cclxuICAgICAgICAgICAgICAgICAgICB7dGl0bGVEaXNwbGF5fVxyXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZGlhbG9nLWNvcmUtY29udGVudFwiIHJlZj1cImNvbnRhaW5lclwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7Lyo8QnV0dG9uIHRleHQ9XCJkZW1vXCIgYmxvY2sgb25UYXA9eygpID0+IHRoaXMuaGlkZSgndGVzdCcpfSAvPiovfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7Y29udGVudH1cclxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImRpYWxvZy1jb3JlLWJ1dHRvbnNcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPEZsZXhib3ggY2xhc3NOYW1lPVwiZGlhbG9nLWNvcmUtYnV0dG9uc1wiIGNvbENvdW50PXszfT57YnV0dG9uTGlzdH08L0ZsZXhib3g+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8L1RvdWNoYWJsZT5cclxuICAgICAgICAgICAgPC9Ub3VjaGFibGU+XHJcbiAgICAgICAgKTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgRGlhbG9nO1xyXG4iLCJpbXBvcnQge2RlZmluZUNvbXBvbmVudFN0eWxlfSBmcm9tIFwibGliLXNvdXJjZS92Mi9zdHlsZS5qc1wiO1xyXG5cclxuZGVmaW5lQ29tcG9uZW50U3R5bGUoXHJcbiAgICAnaWNvbicsXHJcbiAgICAnY29yZScsXHJcbiAgICB7XHJcbiAgICAgICAgXCJjb250ZW50XCI6IHtcclxuICAgICAgICAgICAgZm9udEZhbWlseTogXCJJb25pY1wiLFxyXG4gICAgICAgICAgICBtYXJnaW5MZWZ0OiAyLFxyXG4gICAgICAgICAgICBtYXJnaW5SaWdodDogMlxyXG4gICAgICAgIH1cclxuICAgIH1cclxuKTtcclxuY29uc3QgSWNvbiA9ICh7bmFtZSwgc3R5bGVOYW1lID0gJ2NvcmUnLCBzaXplfSkgPT5cclxuICAgIDxzcGFuIGNsYXNzTmFtZT17YGljb24tJHtzdHlsZU5hbWV9LWNvbnRlbnRgfSBzdHlsZT17e2ZvbnRTaXplOiBzaXplfX0+e2lvbmljW25hbWVdfTwvc3Bhbj47XHJcblxyXG5leHBvcnQgZGVmYXVsdCBJY29uO1xyXG4iLCJpbXBvcnQge2RlZmluZUNvbXBvbmVudFN0eWxlLCBUaGVtZX0gZnJvbSBcImxpYi1zb3VyY2UvdjIvc3R5bGUuanNcIjtcclxuLy8gaW1wb3J0IFJpcHBsZSBmcm9tIFwibGliLXNvdXJjZS91aXYyL3JpcHBsZS5qc1wiO1xyXG5pbXBvcnQgSWNvbiBmcm9tICdsaWItc291cmNlL3VpdjIvaWNvbi5qcyc7XHJcblxyXG5kZWZpbmVDb21wb25lbnRTdHlsZShcclxuICAgICdpY29uLWJ1dHRvbicsXHJcbiAgICAnY29yZScsXHJcbiAgICB7XHJcbiAgICAgICAgXCJ3cmFwcGVyXCI6IHtcclxuICAgICAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXHJcbiAgICAgICAgICAgIHRleHRBbGlnbjogJ2NlbnRlcicsXHJcbiAgICAgICAgICAgIG1hcmdpbjogNCxcclxuICAgICAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxyXG4gICAgICAgICAgICB6SW5kZXg6IFwiKzBcIixcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAndHJhbnNwYXJlbnQnLFxyXG4gICAgICAgICAgICBjb2xvcjogJ2JsYWNrJyxcclxuICAgICAgICAgICAgZGlzcGxheTogJ2lubGluZS1ibG9jaycsXHJcbiAgICAgICAgICAgIGJvcmRlclJhZGl1czogJzUwJSdcclxuICAgICAgICB9XHJcbiAgICB9XHJcbik7XHJcbmNvbnN0IEljb25CdXR0b24gPSBwcm9wcyA9PiB7XHJcbiAgICBjb25zdCB7XHJcbiAgICAgICAgc2l6ZSA9IDQyLFxyXG4gICAgICAgIG5hbWUsXHJcbiAgICAgICAgaWNvblNpemUsXHJcbiAgICAgICAgc3R5bGVOYW1lID0gJ2NvcmUnXHJcbiAgICB9ID0gcHJvcHM7XHJcblxyXG4gICAgY29uc3Qgd3JhcHBlck5hbWUgPSBgaWNvbi1idXR0b24tJHtzdHlsZU5hbWV9LXdyYXBwZXJgO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPFVJLlRvdWNoYWJsZSBjb21wb25lbnQ9XCJkaXZcIiBjbGFzc05hbWU9e3dyYXBwZXJOYW1lfSBzdHlsZT17e3dpZHRoOiBzaXplLCBoZWlnaHQ6IHNpemV9fT5cclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJidXR0b24tY29yZS10ZXh0LXdyYXBwZXJcIiBzdHlsZT17e2hlaWdodDogJzEwMCUnfX0+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImJ1dHRvbi1jb3JlLXRleHRcIiBzdHlsZT17e3BhZGRpbmc6IDB9fT48SWNvbiBuYW1lPXtuYW1lfSBzaXplPXtpY29uU2l6ZX0gLz48L2Rpdj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9VSS5Ub3VjaGFibGU+XHJcbiAgICApO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgSWNvbkJ1dHRvbjtcclxuIiwiaW1wb3J0IHtkZWZpbmVDb21wb25lbnRTdHlsZX0gZnJvbSBcImxpYi1zb3VyY2UvdjIvc3R5bGVcIjtcclxuaW1wb3J0IEJ1dHRvbiBmcm9tIFwibGliLXNvdXJjZS91aXYyL0J1dHRvblwiO1xyXG5pbXBvcnQgQ2FsZW5kYXIgZnJvbSBcImxpYi1zb3VyY2UvdWl2Mi9DYWxlbmRhclwiO1xyXG5cclxuY29uc3QgRGF0ZUlucHV0ID0gKHt2YWx1ZSA9IGNocm9ubygpLCBmb3JtYXQgPSBcInttb250aH0ve2RheX0ve3llYXJ9XCIsIG9uQ2hhbmdlID0gKCkgPT4ge30sIGljb25OYW1lfSkgPT4ge1xyXG4gICAgY29uc3QgY2hhbmdlRGF0ZSA9IGFzeW5jICgpID0+IHtcclxuICAgICAgICBjb25zdCBoYW5kbGVyID0gZGF0ZSA9PiB7XHJcbiAgICAgICAgICAgIGRpYWxvZy5oaWRlKGRpYWxvZy5zdWNjZXNzKGRhdGUpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGRpYWxvZy5zaG93KHtcclxuICAgICAgICAgICAgY29udGVudDogPENhbGVuZGFyIHNlbGVjdGVkRGF0ZT17dmFsdWV9IG9uQ2hhbmdlPXtoYW5kbGVyfSBrZXk9e0RhdGUubm93KCl9IC8+LFxyXG4gICAgICAgICAgICBidXR0b25zOiBbe3RleHQ6IFwiQ2FuY2VsXCJ9XSxcclxuICAgICAgICAgICAgLy8gdGl0bGU6IFwiU2VsZWN0IERhdGVcIlxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpZiAocmVzdWx0LnZhbHVlICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIG9uQ2hhbmdlKHJlc3VsdC52YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPGRpdiBzdHlsZT17e2hlaWdodDogMzB9fT5cclxuICAgICAgICAgICAgPEJ1dHRvbiB0ZXh0PXt2YWx1ZS5mb3JtYXQoZm9ybWF0KX0gb25UYXA9e2NoYW5nZURhdGV9IGZsdXNoIGZpbGwgaWNvbk5hbWU9e2ljb25OYW1lfSAvPlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgKTtcclxufTtcclxuXHJcbkRhdGVJbnB1dC52YWx1ZVByb3AgPSAndmFsdWUnO1xyXG5EYXRlSW5wdXQudmFsdWVGdW5jdGlvbiA9IGRhdGUgPT4gZGF0ZTtcclxuRGF0ZUlucHV0LmRlZmF1bHRQcm9wVmFsdWUgPSAoKSA9PiBjaHJvbm8oKTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IERhdGVJbnB1dDtcclxuIiwiaW1wb3J0IHtkZWZpbmVDb21wb25lbnRTdHlsZX0gZnJvbSBcImxpYi1zb3VyY2UvdjIvc3R5bGVcIjtcclxuaW1wb3J0IEJ1dHRvbiBmcm9tICdsaWItc291cmNlL3VpdjIvQnV0dG9uJztcclxuXHJcbmNsYXNzIEZpbGVJbnB1dCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xyXG4gICAgICAgIHN1cGVyKHByb3BzKTtcclxuICAgIH1cclxuXHJcbiAgICB0cmlnZ2VyID0gKCkgPT4ge1xyXG4gICAgICAgIHRoaXMucmVmcy5maWxlLmNsaWNrKCk7XHJcbiAgICB9XHJcbiAgICB1cGxvYWQgPSAoZXZ0KSA9PiB7XHJcbiAgICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZShBcnJheS5mcm9tKGV2dC50YXJnZXQuZmlsZXMpKTtcclxuICAgIH1cclxuXHJcbiAgICByZW5kZXIgPSAoKSA9PiB7XHJcbiAgICAgICAgY29uc3Qge3ZhbHVlLCB2YWx1ZUZvcm1hdCA9IGZpbGVMaXN0ID0+IGZpbGVMaXN0WzBdLm5hbWUsIG51bGxUZXh0ID0gXCJTZWxlY3QgYSBmaWxlXCIsIC4uLnByb3BzfSA9IHRoaXMucHJvcHM7XHJcbiAgICAgICAgbGV0IGJ1dHRvblRleHQ7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIGJ1dHRvblRleHQgPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIGJ1dHRvblRleHQgPSB2YWx1ZUZvcm1hdCh2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgYnV0dG9uVGV4dCA9IG51bGxUZXh0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPGRpdj5cclxuICAgICAgICAgICAgICAgIDxpbnB1dCB7Li4ucHJvcHN9IHR5cGU9XCJmaWxlXCIgcmVmPVwiZmlsZVwiIHN0eWxlPXt7ZGlzcGxheTogJ25vbmUnfX0gdmFsdWU9XCJcIiBvbkNoYW5nZT17dGhpcy51cGxvYWR9IC8+XHJcbiAgICAgICAgICAgICAgICA8QnV0dG9uIHRleHQ9e2J1dHRvblRleHR9IG9uVGFwPXt0aGlzLnRyaWdnZXJ9IGJsb2NrIC8+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcbn1cclxuXHJcbkZpbGVJbnB1dC52YWx1ZVByb3AgPSBcInZhbHVlXCI7XHJcbkZpbGVJbnB1dC52YWx1ZUZ1bmN0aW9uID0gZmlsZUxpc3QgPT4gZmlsZUxpc3Q7XHJcbkZpbGVJbnB1dC5kZWZhdWx0UHJvcFZhbHVlID0gbnVsbDtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IEZpbGVJbnB1dDtcclxuIiwiaW1wb3J0IHtkZWZpbmVDb21wb25lbnRTdHlsZX0gZnJvbSBcImxpYi1zb3VyY2UvdjIvc3R5bGVcIjtcclxuaW1wb3J0IEJ1dHRvbiBmcm9tICdsaWItc291cmNlL3VpdjIvQnV0dG9uJztcclxuXHJcbmNvbnN0IGNvb2xCbHVlID0gXCIjMkZCMURGXCI7XHJcbmNvbnN0IGNsYW1wVmFsdWUgPSAodmFsdWUsIG1pbiwgbWF4KSA9PiBNYXRoLm1pbihNYXRoLm1heCh2YWx1ZSwgbWluKSwgbWF4KTtcclxuY29uc3QgdGh1bWJTaXplID0ge1xyXG4gICAgd2lkdGg6IDI0LFxyXG4gICAgaGVpZ2h0OiAyNFxyXG59O1xyXG5jb25zdCB0cmFja0Jhc2UgPSB7XHJcbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcclxuICAgIGxlZnQ6IDAsXHJcbiAgICB0b3A6ICc1MCUnLFxyXG4gICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlWSgtNTAlKScsXHJcbiAgICBoZWlnaHQ6IDQsXHJcbiAgICBib3JkZXJSYWRpdXM6IDJcclxufTtcclxuZGVmaW5lQ29tcG9uZW50U3R5bGUoXHJcbiAgICAncmFuZ2UtaW5wdXQnLFxyXG4gICAgJ2NvcmUnLFxyXG4gICAge1xyXG4gICAgICAgIFwid3JhcHBlclwiOiB7XHJcbiAgICAgICAgICAgIGhlaWdodDogMzAsXHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcImZvY3VzLWJhY2tncm91bmRcIjoge1xyXG4gICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcclxuICAgICAgICAgICAgdG9wOiAwLFxyXG4gICAgICAgICAgICBsZWZ0OiAwLFxyXG4gICAgICAgICAgICByaWdodDogMCxcclxuICAgICAgICAgICAgYm90dG9tOiAwLFxyXG4gICAgICAgICAgICBvcGFjaXR5OiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcInRyYWNrLWNvbnRhaW5lclwiOiB7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxyXG4gICAgICAgICAgICB0b3A6IDAsXHJcbiAgICAgICAgICAgIGxlZnQ6IDEyLFxyXG4gICAgICAgICAgICByaWdodDogMTIsXHJcbiAgICAgICAgICAgIGJvdHRvbTogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJ0cmFjay1iYWNrZ3JvdW5kXCI6IHtcclxuICAgICAgICAgICAgLi4udHJhY2tCYXNlLFxyXG4gICAgICAgICAgICByaWdodDogMCxcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnbGlnaHRncmF5J1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJ0cmFja1wiOiB7XHJcbiAgICAgICAgICAgIC4uLnRyYWNrQmFzZSxcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBjb29sQmx1ZVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJ0cmFjazo6YWZ0ZXJcIjoge1xyXG4gICAgICAgICAgICAuLi50aHVtYlNpemUsXHJcbiAgICAgICAgICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxyXG4gICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcclxuICAgICAgICAgICAgdG9wOiAnNTAlJyxcclxuICAgICAgICAgICAgcmlnaHQ6IDAsXHJcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZSg1MCUsIC01MCUpJyxcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnd2hpdGUnLFxyXG4gICAgICAgICAgICBib3JkZXI6IGAzcHggc29saWQgJHtjb29sQmx1ZX1gLFxyXG4gICAgICAgICAgICBib3JkZXJSYWRpdXM6ICc1MCUnLFxyXG4gICAgICAgICAgICBjb250ZW50OiBcIicnXCJcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiYXJyb3dcIjoge1xyXG4gICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcclxuICAgICAgICAgICAgdG9wOiAwLFxyXG4gICAgICAgICAgICBib3R0b206IDAsXHJcbiAgICAgICAgICAgIHdpZHRoOiAzMCxcclxuICAgICAgICAgICAgY29sb3I6ICdibGFjaydcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwid3JhcHBlciA+ICRpbnB1dFt0eXBlPSdyYW5nZSddXCI6IHtcclxuICAgICAgICAgICAgV2Via2l0QXBwZWFyYW5jZTogJ25vbmUnLFxyXG4gICAgICAgICAgICB3aWR0aDogJzEwMCUnLFxyXG4gICAgICAgICAgICBoZWlnaHQ6ICcxMDAlJyxcclxuICAgICAgICAgICAgbGVmdDogMCxcclxuICAgICAgICAgICAgcmlnaHQ6IDAsXHJcbiAgICAgICAgICAgIG1hcmdpbjogMCxcclxuICAgICAgICAgICAgekluZGV4OiAnKzEwJyxcclxuICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXHJcbiAgICAgICAgICAgIG9wYWNpdHk6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwid3JhcHBlciA+ICRpbnB1dFt0eXBlPSdyYW5nZSddOjotd2Via2l0LXNsaWRlci10aHVtYlwiOiB7XHJcbiAgICAgICAgICAgIC4uLnRodW1iU2l6ZSxcclxuICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAnNTAlJyxcclxuICAgICAgICAgICAgV2Via2l0QXBwZWFyYW5jZTogJ25vbmUnLFxyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdncmVlbidcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwid3JhcHBlciA+ICRpbnB1dFt0eXBlPSdyYW5nZSddOmZvY3VzICsgZm9jdXMtYmFja2dyb3VuZFwiOiB7XHJcbiAgICAgICAgICAgIG9wYWNpdHk6IDFcclxuICAgICAgICB9XHJcbiAgICB9XHJcbik7XHJcbmNvbnN0IFJhbmdlSW5wdXQgPSBwcm9wcyA9PiB7XHJcbiAgICBjb25zdCB7XHJcbiAgICAgICAgbWluID0gMCxcclxuICAgICAgICBtYXggPSAxMCxcclxuICAgICAgICBzdGVwID0gMSxcclxuICAgICAgICBvbkNoYW5nZSA9ICgpID0+IHt9LFxyXG4gICAgICAgIGZvY3VzU3R5bGUgPSBudWxsLFxyXG4gICAgICAgIGxhYmVsLFxyXG4gICAgICAgIHNob3dBcnJvd3MgPSBmYWxzZVxyXG4gICAgfSA9IHByb3BzO1xyXG4gICAgY29uc3QgcmFuZ2UgPSBtYXggLSBtaW47XHJcbiAgICBjb25zdCBjaGFuZ2VIYW5kbGVyID0gZXZ0ID0+IHtcclxuICAgICAgICAvLyBldnQudGFyZ2V0LmZvY3VzKCk7XHJcbiAgICAgICAgb25DaGFuZ2UoZXZ0LnRhcmdldC52YWx1ZSk7XHJcbiAgICB9O1xyXG4gICAgbGV0IHt2YWx1ZSA9IG51bGx9ID0gcHJvcHM7XHJcbiAgICBsZXQgYWRqdXN0ZWQ7XHJcbiAgICBsZXQgaW5wdXRPZmZzZXQgPSBudWxsO1xyXG4gICAgbGV0IHRyYWNrT2Zmc2V0ID0gbnVsbDtcclxuICAgIGxldCBhcnJvd3MgPSBudWxsO1xyXG5cclxuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xyXG4gICAgICAgIHZhbHVlID0gbWluO1xyXG4gICAgfVxyXG5cclxuICAgIGFkanVzdGVkID0gdmFsdWUgLSBtaW47XHJcbiAgICBpZiAoYWRqdXN0ZWQgJSBzdGVwICE9PSAwKSB7XHJcbiAgICAgICAgYWRqdXN0ZWQgLT0gYWRqdXN0ZWQgJSBzdGVwO1xyXG4gICAgfVxyXG4gICAgYWRqdXN0ZWQgPSBjbGFtcFZhbHVlKGFkanVzdGVkLCBtaW4sIG1heCk7XHJcblxyXG4gICAgaWYgKHNob3dBcnJvd3MgPT09IHRydWUpIHtcclxuICAgICAgICBjb25zdCBhcnJvd0NoYW5nZSA9IGFkanVzdCA9PlxyXG4gICAgICAgICAgICAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgbmV3VmFsdWUgPSB2YWx1ZSArIGFkanVzdDtcclxuICAgICAgICAgICAgICAgIG5ld1ZhbHVlID0gTWF0aC5tYXgobmV3VmFsdWUsIG1pbik7XHJcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IE1hdGgubWluKG5ld1ZhbHVlLCBtYXgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBuZXdWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlKG5ld1ZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICBpbnB1dE9mZnNldCA9IHtsZWZ0OiAzMCwgd2lkdGg6ICdjYWxjKDEwMCUgLSA2MHB4KSd9O1xyXG4gICAgICAgIHRyYWNrT2Zmc2V0ID0ge2xlZnQ6IDQyLCByaWdodDogNDJ9O1xyXG4gICAgICAgIGFycm93cyA9IFtcclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJyYW5nZS1pbnB1dC1jb3JlLWFycm93XCIgc3R5bGU9e3tsZWZ0OiAwfX0ga2V5PXswfT5cclxuICAgICAgICAgICAgICAgIDxCdXR0b24gaWNvbk5hbWU9XCJpb24tYXJyb3ctbGVmdC1iXCIgZmx1c2ggZmlsbCBpY29uU2l6ZT17MjB9IG9uVGFwPXthcnJvd0NoYW5nZSgtMSl9IC8+XHJcbiAgICAgICAgICAgIDwvZGl2PixcclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJyYW5nZS1pbnB1dC1jb3JlLWFycm93XCIgc3R5bGU9e3tyaWdodDogMH19IGtleT17MX0+XHJcbiAgICAgICAgICAgICAgICA8QnV0dG9uIGljb25OYW1lPVwiaW9uLWFycm93LXJpZ2h0LWJcIiBmbHVzaCBmaWxsIGljb25TaXplPXsyMH0gb25UYXA9e2Fycm93Q2hhbmdlKDEpfSAvPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICBdO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPGRpdj5cclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJpbnB1dC1jb3JlLWxhYmVsXCI+e2xhYmVsfTwvZGl2PlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInJhbmdlLWlucHV0LWNvcmUtd3JhcHBlclwiPlxyXG4gICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJyYW5nZVwiIHN0eWxlPXtpbnB1dE9mZnNldH0gbWluPXttaW59IG1heD17bWF4fSBzdGVwPXtzdGVwfSB2YWx1ZT17YWRqdXN0ZWR9IG9uQ2hhbmdlPXtjaGFuZ2VIYW5kbGVyfSBvblRvdWNoU3RhcnQ9e2V2dCA9PiBldnQudGFyZ2V0LmZvY3VzKCl9IC8+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInJhbmdlLWlucHV0LWNvcmUtZm9jdXMtYmFja2dyb3VuZFwiIHN0eWxlPXtmb2N1c1N0eWxlfSAvPlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJyYW5nZS1pbnB1dC1jb3JlLXRyYWNrLWNvbnRhaW5lclwiIHN0eWxlPXt0cmFja09mZnNldH0+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJyYW5nZS1pbnB1dC1jb3JlLXRyYWNrLWJhY2tncm91bmRcIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicmFuZ2UtaW5wdXQtY29yZS10cmFja1wiIHN0eWxlPXt7d2lkdGg6IGAkeyhhZGp1c3RlZCAvIHJhbmdlKSAqIDEwMH0lYH19IC8+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgIHthcnJvd3N9XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgKTtcclxufTtcclxuXHJcblJhbmdlSW5wdXQudmFsdWVQcm9wID0gJ3ZhbHVlJztcclxuUmFuZ2VJbnB1dC52YWx1ZUZ1bmN0aW9uID0gbiA9PiBuO1xyXG5SYW5nZUlucHV0LmRlZmF1bHRQcm9wVmFsdWUgPSAwO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgUmFuZ2VJbnB1dDtcclxuIiwiaW1wb3J0IHtkZWZpbmVDb21wb25lbnRTdHlsZX0gZnJvbSBcImxpYi1zb3VyY2UvdjIvc3R5bGVcIjtcclxuaW1wb3J0IEJ1dHRvbiBmcm9tICdsaWItc291cmNlL3VpdjIvQnV0dG9uJztcclxuaW1wb3J0IFRpbWVTZWxlY3RvciBmcm9tICdsaWItc291cmNlL3VpdjIvVGltZVNlbGVjdG9yJztcclxuaW1wb3J0IHtzaGFyZWRSZWZlcmVuY2UsIFNoYXJlZE9iamVjdERpc3BsYXl9IGZyb20gXCJsaWItc291cmNlL3YyL3NoYXJlZFwiO1xyXG5cclxuY2xhc3MgVGltZUlucHV0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XHJcbiAgICAgICAgc3VwZXIocHJvcHMpO1xyXG4gICAgfVxyXG5cclxuICAgIHNlbGVjdCA9IGFzeW5jICgpID0+IHtcclxuICAgICAgICBjb25zdCB7XHJcbiAgICAgICAgICAgIG9uQ2hhbmdlID0gd2FybmluZ0Z1bmMoXCJvbkNoYW5nZSBub3QgZ2l2ZW4gdG8gVGltZUlucHV0XCIpLFxyXG4gICAgICAgICAgICB0aW1lRm9ybWF0XHJcbiAgICAgICAgfSA9IHRoaXMucHJvcHM7XHJcbiAgICAgICAgY29uc3QgY3VycmVudERhdGUgPSBzaGFyZWRSZWZlcmVuY2UodGhpcy5wcm9wcy52YWx1ZSk7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZGlhbG9nLnNob3coe1xyXG4gICAgICAgICAgICAvLyBjb250ZW50OiA8ZGl2IHN0eWxlPXt7cGFkZGluZzogM319PjxUaW1lU2VsZWN0b3IgdmFsdWU9e2N1cnJlbnREYXRlfSBvbkNoYW5nZT17ZGF0ZSA9PiBjdXJyZW50RGF0ZSA9IGRhdGV9IC8+PC9kaXY+LFxyXG4gICAgICAgICAgICBjb250ZW50OiA8U2hhcmVkT2JqZWN0RGlzcGxheSBrZXk9e0RhdGUubm93KCl9IHJlZmVyZW5jZT17Y3VycmVudERhdGV9IGNvbXBvbmVudD17VGltZVNlbGVjdG9yfSB2YWx1ZVByb3A9XCJ2YWx1ZVwiIGZvcm1hdD17dGltZUZvcm1hdH0gLz4sXHJcbiAgICAgICAgICAgIGJ1dHRvbnM6IFtcclxuICAgICAgICAgICAgICAgIHt0ZXh0OiBcIkNhbmNlbFwiLCBjYW5jZWxzOiB0cnVlfSxcclxuICAgICAgICAgICAgICAgIHt0ZXh0OiBcIlNldFwiLCB2YWx1ZTogKCkgPT4gY3VycmVudERhdGUudmFsdWV9XHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaWYgKHJlc3VsdC5zdGF0dXMgPT09ICdzdWNjZXNzJykge1xyXG4gICAgICAgICAgICBvbkNoYW5nZShyZXN1bHQudmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZW5kZXIgPSAoKSA9PiB7XHJcbiAgICAgICAgY29uc3Qge2Zvcm1hdCA9IFwie2hvdXJ9OnttaW51dGUvcGFkZGVkfVwiLCB2YWx1ZSwgLi4uYnV0dG9uUHJvcHN9ID0gdGhpcy5wcm9wcztcclxuICAgICAgICByZXR1cm4gPEJ1dHRvbiB7Li4uYnV0dG9uUHJvcHN9IHRleHQ9e3ZhbHVlLmZvcm1hdChmb3JtYXQpfSBvblRhcD17dGhpcy5zZWxlY3R9IGJsb2NrIC8+O1xyXG4gICAgfVxyXG59XHJcblxyXG5UaW1lSW5wdXQudmFsdWVQcm9wID0gJ3ZhbHVlJztcclxuVGltZUlucHV0LnZhbHVlRnVuY3Rpb24gPSBkYXRlID0+IGRhdGU7XHJcblRpbWVJbnB1dC5kZWZhdWx0UHJvcFZhbHVlID0gKCkgPT4gY2hyb25vKCk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBUaW1lSW5wdXQ7XHJcbiIsImltcG9ydCB7ZGVmaW5lQ29tcG9uZW50U3R5bGV9IGZyb20gXCJsaWItc291cmNlL3YyL3N0eWxlXCI7XHJcbmltcG9ydCBUb3VjaGFibGUgZnJvbSBcImxpYi1zb3VyY2UvdWl2Mi9Ub3VjaGFibGVcIjtcclxuXHJcbmNvbnN0IGNvb2xCbHVlID0gXCIjMkZCMURGXCI7XHJcblxyXG5kZWZpbmVDb21wb25lbnRTdHlsZShcclxuICAgICdmbGV4Ym94JyxcclxuICAgICdjb3JlJyxcclxuICAgIHtcclxuICAgICAgICBcImNvbnRhaW5lclwiOiB7XHJcbiAgICAgICAgICAgIGRpc3BsYXk6IFsnLXdlYmtpdC1mbGV4JywgJ2ZsZXgnXSxcclxuICAgICAgICAgICAgV2Via2l0RmxleFdyYXA6ICd3cmFwJyxcclxuICAgICAgICAgICAgZmxleFdyYXA6ICd3cmFwJyxcclxuICAgICAgICAgICAgLy8gYWxpZ25JdGVtczogJ2NlbnRlcicsXHJcbiAgICAgICAgICAgIC8vIGp1c3RpZnlDb250ZW50OiAnY2VudGVyJ1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuKTtcclxuY29uc3QgRmxleGJveCA9IHByb3BzID0+IHtcclxuICAgIGNvbnN0IHtcclxuICAgICAgICBjb2xDb3VudCxcclxuICAgICAgICB3aWR0aCA9ICcxMDAlJyxcclxuICAgICAgICBwYWRFbmQgPSBmYWxzZSxcclxuICAgICAgICBtaW5JdGVtV2lkdGggPSBudWxsLFxyXG4gICAgICAgIG1heEl0ZW1XaWR0aCA9IG51bGwsXHJcbiAgICAgICAgYWxpZ24gPSAnY2VudGVyJ1xyXG4gICAgfSA9IHByb3BzO1xyXG4gICAgY29uc3QgZmxleFdpZHRoID0gMTAwIC8gY29sQ291bnQ7XHJcbiAgICBsZXQge2NoaWxkcmVufSA9IHByb3BzO1xyXG5cclxuICAgIGlmIChpc05hTihmbGV4V2lkdGgpID09PSB0cnVlIHx8IGZsZXhXaWR0aCA8PSAwKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB3aWR0aCBwcm9wZXJ0eSBmb3IgRmxleGJveFwiKTtcclxuICAgIH1cclxuXHJcbiAgICBjaGlsZHJlbiA9IFJlYWN0LkNoaWxkcmVuLnRvQXJyYXkoY2hpbGRyZW4pO1xyXG4gICAgaWYgKHBhZEVuZCA9PT0gdHJ1ZSAmJiBtaW5JdGVtV2lkdGggPT09IG51bGwgJiYgbWF4SXRlbVdpZHRoID09PSBudWxsKSB7XHJcbiAgICAgICAgY29uc3QgZmlsbGVyID0gbmV3IEFycmF5KGNvbENvdW50IC0gY2hpbGRyZW4ubGVuZ3RoICUgY29sQ291bnQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5maWxsKG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoKCkgPT4gPGRpdiAvPik7XHJcbiAgICAgICAgY2hpbGRyZW4gPSBbLi4uY2hpbGRyZW4sIC4uLmZpbGxlcl07XHJcbiAgICB9XHJcblxyXG4gICAgY2hpbGRyZW4gPSBjaGlsZHJlbi5tYXAoXHJcbiAgICAgICAgKGNoaWxkLCBpbmRleCkgPT5cclxuICAgICAgICAgICAgPEZsZXhib3hJdGVtIGtleT17aW5kZXh9IHdpZHRoPXtmbGV4V2lkdGh9IGNvbnRlbnQ9e2NoaWxkfSBtaW5XaWR0aD17bWluSXRlbVdpZHRofSBtYXhXaWR0aD17bWF4SXRlbVdpZHRofSAvPlxyXG4gICAgKVxyXG5cclxuICAgIC8vIGNvbnNvbGUudHJhY2UoKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxkaXYgc3R5bGU9e3t3aWR0aCwganVzdGlmeUNvbnRlbnQ6IGFsaWduLCBXZWJraXRKdXN0aWZ5Q29udGVudDogYWxpZ259fSBjbGFzc05hbWU9XCJmbGV4Ym94LWNvcmUtY29udGFpbmVyXCI+XHJcbiAgICAgICAgICAgIHtjaGlsZHJlbn1cclxuICAgICAgICA8L2Rpdj5cclxuICAgICk7XHJcbn07XHJcbmNvbnN0IEZsZXhib3hJdGVtID0gKHtjb250ZW50LCB3aWR0aCwgbWF4V2lkdGgsIG1pbldpZHRofSkgPT4ge1xyXG4gICAgY29uc3QgZmxleENTUyA9IGAxIDAgJHt3aWR0aH0lYDtcclxuICAgIGNvbnN0IGl0ZW1TdHlsZSA9IHtcclxuICAgICAgICBXZWJraXRGbGV4OiBmbGV4Q1NTLFxyXG4gICAgICAgIGZsZXg6IGZsZXhDU1MsXHJcbiAgICAgICAgbWF4V2lkdGgsXHJcbiAgICAgICAgbWluV2lkdGhcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIDxkaXYgc3R5bGU9e2l0ZW1TdHlsZX0+e2NvbnRlbnR9PC9kaXY+O1xyXG59O1xyXG5cclxuZGVmaW5lQ29tcG9uZW50U3R5bGUoXHJcbiAgICBcImZsZXhib3gtcmFkaW9cIixcclxuICAgICdjb3JlJyxcclxuICAgIHtcclxuICAgICAgICAnaXRlbSc6IHtcclxuICAgICAgICAgICAgdHJhbnNpdGlvbjogJ2JhY2tncm91bmQtY29sb3IgNTAwbXMgbGluZWFyJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJpdGVtOmFjdGl2ZVwiOiB7XHJcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMCwgMCwgMCwgMC4xKScsXHJcbiAgICAgICAgICAgIHRyYW5zaXRpb246ICdub25lJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJpdGVtW2RhdGEtY2hlY2tlZD0ndHJ1ZSddXCI6IHtcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBjb29sQmx1ZSxcclxuICAgICAgICAgICAgY29sb3I6ICd3aGl0ZScsXHJcbiAgICAgICAgICAgIHRyYW5zaXRpb246ICdub25lJ1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuKTtcclxuRmxleGJveC5SYWRpb0l0ZW0gPSAoe2NoaWxkcmVuLCBjaGVja2VkLCBvblRhcH0pID0+IChcclxuICAgIDxUb3VjaGFibGUgY29tcG9uZW50PVwiZGl2XCIgY2xhc3NOYW1lPVwiZmxleGJveC1yYWRpby1jb3JlLWl0ZW1cIiBkYXRhLWNoZWNrZWQ9e2NoZWNrZWR9IG9uVGFwPXtvblRhcH0+XHJcbiAgICAgICAge2NoaWxkcmVufVxyXG4gICAgPC9Ub3VjaGFibGU+XHJcbik7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBGbGV4Ym94O1xyXG4iLCJpbXBvcnQge2RlZmluZUNvbXBvbmVudFN0eWxlfSBmcm9tIFwibGliLXNvdXJjZS92Mi9zdHlsZVwiO1xyXG5pbXBvcnQgVG91Y2hhYmxlIGZyb20gXCJsaWItc291cmNlL3VpdjIvVG91Y2hhYmxlXCI7XHJcblxyXG5jb25zdCBjb29sQmx1ZSA9IFwiIzJGQjFERlwiO1xyXG5cclxuZGVmaW5lQ29tcG9uZW50U3R5bGUoXHJcbiAgICAnZ3JpZCcsXHJcbiAgICAnY29yZScsXHJcbiAgICB7XHJcbiAgICAgICAgXCJpdGVtXCI6IHtcclxuICAgICAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIlxyXG4gICAgICAgIH1cclxuICAgIH1cclxuKTtcclxuXHJcbmNvbnN0IEdyaWQgPSAoe2NoaWxkcmVuLCBjb2xDb3VudCwgcm93Q291bnQsIHdpZHRoID0gJzEwMCUnLCBoZWlnaHQgPSAnMTAwJSd9KSA9PiB7XHJcbiAgICBpZiAoaGVpZ2h0ID09PSBudWxsKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSGVpZ2h0IG5lZWRzIHRvIGJlIGdpdmVuIHRvIHRoZSBncmlkXCIpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgaXRlbVdpZHRoID0gMTAwIC8gY29sQ291bnQ7XHJcbiAgICBjb25zdCBpdGVtSGVpZ2h0ID0gMTAwIC8gcm93Q291bnQ7XHJcbiAgICBjb25zdCBncmlkU3R5bGUgPSB7XHJcbiAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXHJcbiAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxyXG4gICAgICAgIHdpZHRoLFxyXG4gICAgICAgIGhlaWdodFxyXG4gICAgfTtcclxuXHJcbiAgICBjaGlsZHJlbiA9IFJlYWN0LkNoaWxkcmVuLnRvQXJyYXkoY2hpbGRyZW4pO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPGRpdiBzdHlsZT17Z3JpZFN0eWxlfT5cclxuICAgICAgICAgICAge2NoaWxkcmVuLm1hcCgoY2hpbGQsIGluZGV4KSA9PiA8R3JpZEl0ZW0ga2V5PXtpbmRleH0gd2lkdGg9e2l0ZW1XaWR0aH0gaGVpZ2h0PXtpdGVtSGVpZ2h0fSB4PXtpbmRleCAlIGNvbENvdW50fSB5PXtNYXRoLmZsb29yKGluZGV4IC8gY29sQ291bnQpfSBjb250ZW50PXtjaGlsZH0gLz4pfVxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgKTtcclxufTtcclxuY29uc3QgR3JpZEl0ZW0gPSAoe3dpZHRoLCBoZWlnaHQsIHgsIHksIGNvbnRlbnR9KSA9PiB7XHJcbiAgICBjb25zdCBzdHlsZSA9IHtcclxuICAgICAgICB3aWR0aDogYCR7d2lkdGh9JWAsXHJcbiAgICAgICAgaGVpZ2h0OiBgJHtoZWlnaHR9JWAsXHJcbiAgICAgICAgbGVmdDogYCR7eCAqIHdpZHRofSVgLFxyXG4gICAgICAgIHRvcDogYCR7eSAqIGhlaWdodH0lYFxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gPGRpdiBjbGFzc05hbWU9XCJncmlkLWNvcmUtaXRlbVwiIHN0eWxlPXtzdHlsZX0+e2NvbnRlbnR9PC9kaXY+O1xyXG59O1xyXG5cclxuZGVmaW5lQ29tcG9uZW50U3R5bGUoXHJcbiAgICBcImdyaWQtcmFkaW9cIixcclxuICAgICdjb3JlJyxcclxuICAgIHtcclxuICAgICAgICAnaXRlbSc6IHtcclxuICAgICAgICAgICAgd2lkdGg6ICcxMDAlJyxcclxuICAgICAgICAgICAgaGVpZ2h0OiAnMTAwJScsXHJcbiAgICAgICAgICAgIHRyYW5zaXRpb246ICdiYWNrZ3JvdW5kLWNvbG9yIDUwMG1zIGxpbmVhcidcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiaXRlbTphY3RpdmVcIjoge1xyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDAsIDAsIDAsIDAuMSknLFxyXG4gICAgICAgICAgICB0cmFuc2l0aW9uOiAnbm9uZSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiaXRlbVtkYXRhLWNoZWNrZWQ9J3RydWUnXVwiOiB7XHJcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogY29vbEJsdWUsXHJcbiAgICAgICAgICAgIGNvbG9yOiAnd2hpdGUnLFxyXG4gICAgICAgICAgICB0cmFuc2l0aW9uOiAnbm9uZSdcclxuICAgICAgICB9XHJcbiAgICB9XHJcbik7XHJcbkdyaWQuUmFkaW9JdGVtID0gKHtjaGlsZHJlbiwgY2hlY2tlZCwgb25UYXB9KSA9PiAoXHJcbiAgICA8VG91Y2hhYmxlIGNvbXBvbmVudD1cImRpdlwiIGNsYXNzTmFtZT1cImdyaWQtcmFkaW8tY29yZS1pdGVtXCIgZGF0YS1jaGVja2VkPXtjaGVja2VkfSBvblRhcD17b25UYXB9PlxyXG4gICAgICAgIHtjaGlsZHJlbn1cclxuICAgIDwvVG91Y2hhYmxlPlxyXG4pO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgR3JpZDtcclxuIiwiaW1wb3J0IHtkZWZpbmVDb21wb25lbnRTdHlsZX0gZnJvbSBcImxpYi1zb3VyY2UvdjIvc3R5bGVcIjtcclxuaW1wb3J0IFRvdWNoYWJsZSBmcm9tIFwibGliLXNvdXJjZS91aXYyL1RvdWNoYWJsZVwiO1xyXG5cclxuY29uc3QgY29vbEJsdWUgPSBcIiMyRkIxREZcIjtcclxuXHJcbmRlZmluZUNvbXBvbmVudFN0eWxlKFxyXG4gICAgXCJwaW5ib2FyZFwiLFxyXG4gICAgJ2NvcmUnLFxyXG4gICAge1xyXG4gICAgICAgICdjb250YWluZXInOiB7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4pO1xyXG5jb25zdCBQaW5ib2FyZCA9ICh7Y2hpbGRyZW4sIHdpZHRoID0gJzEwMCUnLCBoZWlnaHQgPSAnMTAwJSd9KSA9PiB7XHJcbiAgICBjaGlsZHJlbiA9IFJlYWN0LkNoaWxkcmVuLnRvQXJyYXkoY2hpbGRyZW4pO1xyXG5cclxuICAgIGNoaWxkcmVuID0gY2hpbGRyZW4ubWFwKFxyXG4gICAgICAgIChjaGlsZCwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgY29uc3Qge3BpbkluZm8sIC4uLnByb3BzfSA9IGNoaWxkLnByb3BzO1xyXG4gICAgICAgICAgICAvLyBjb25zdCB7cHJvcHM6IHtwaW5JbmZvfX0gPSBjaGlsZDtcclxuICAgICAgICAgICAgY29uc3QgZGlzcGxheWVkQ2hpbGQgPSA8Y2hpbGQudHlwZSB7Li4ucHJvcHN9IC8+O1xyXG4gICAgICAgICAgICAvLyBjaGlsZCA9IFJlYWN0LmNsb25lXHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGNoaWxkLnR5cGUpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIDxkaXYga2V5PXtpbmRleH0gc3R5bGU9e3suLi5waW5JbmZvLCBwb3NpdGlvbjogJ2Fic29sdXRlJ319PntkaXNwbGF5ZWRDaGlsZH08L2Rpdj47XHJcbiAgICAgICAgfVxyXG4gICAgKTtcclxuXHJcbiAgICByZXR1cm4gPGRpdiBzdHlsZT17e3Bvc2l0aW9uOiAncmVsYXRpdmUnLCB3aWR0aCwgaGVpZ2h0fX0+e2NoaWxkcmVufTwvZGl2PjtcclxufTtcclxuZGVmaW5lQ29tcG9uZW50U3R5bGUoXHJcbiAgICBcInBpbmJvYXJkLXJhZGlvXCIsXHJcbiAgICAnY29yZScsXHJcbiAgICB7XHJcbiAgICAgICAgJ2l0ZW0nOiB7XHJcbiAgICAgICAgICAgIHdpZHRoOiAnMTAwJScsXHJcbiAgICAgICAgICAgIGhlaWdodDogJzEwMCUnLFxyXG4gICAgICAgICAgICB0cmFuc2l0aW9uOiAnYmFja2dyb3VuZC1jb2xvciA1MDBtcyBsaW5lYXInXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcIml0ZW06YWN0aXZlXCI6IHtcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSgwLCAwLCAwLCAwLjEpJyxcclxuICAgICAgICAgICAgdHJhbnNpdGlvbjogJ25vbmUnXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcIml0ZW1bZGF0YS1jaGVja2VkPSd0cnVlJ11cIjoge1xyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGNvb2xCbHVlLFxyXG4gICAgICAgICAgICBjb2xvcjogJ3doaXRlJyxcclxuICAgICAgICAgICAgdHJhbnNpdGlvbjogJ25vbmUnXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4pO1xyXG5QaW5ib2FyZC5SYWRpb0l0ZW0gPSAoe2NoaWxkcmVuLCBjaGVja2VkLCBvblRhcH0pID0+IChcclxuICAgIDxUb3VjaGFibGUgY29tcG9uZW50PVwiZGl2XCIgY2xhc3NOYW1lPVwicGluYm9hcmQtcmFkaW8tY29yZS1pdGVtXCIgZGF0YS1jaGVja2VkPXtjaGVja2VkfSBvblRhcD17b25UYXB9PlxyXG4gICAgICAgIHtjaGlsZHJlbn1cclxuICAgIDwvVG91Y2hhYmxlPlxyXG4pO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgUGluYm9hcmQ7XHJcbiIsImltcG9ydCB7ZGVmaW5lQ29tcG9uZW50U3R5bGV9IGZyb20gXCJsaWItc291cmNlL3YyL3N0eWxlLmpzXCI7XHJcblxyXG5jb25zdCBhbmltYXRpb25EdXJhdGlvbiA9IDMwMDtcclxuZGVmaW5lQ29tcG9uZW50U3R5bGUoXHJcbiAgICAncmlwcGxlJyxcclxuICAgICdjb3JlJyxcclxuICAgIHtcclxuICAgICAgICBcIndyYXBwZXJcIjoge1xyXG4gICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcclxuICAgICAgICAgICAgdG9wOiAwLFxyXG4gICAgICAgICAgICBsZWZ0OiAwLFxyXG4gICAgICAgICAgICByaWdodDogMCxcclxuICAgICAgICAgICAgYm90dG9tOiAwLFxyXG4gICAgICAgICAgICB6SW5kZXg6ICcrNSdcclxuICAgICAgICAgICAgLy8gdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcImRvdFwiOiB7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxyXG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUoLTUwJSwgLTUwJSknLFxyXG4gICAgICAgICAgICBhbmltYXRpb246IGByaXBwbGUtY29yZS1hbmltYXRpb24tcmlwcGxlLWVmZmVjdCAke2FuaW1hdGlvbkR1cmF0aW9ufW1zIGxpbmVhcmAsXHJcbiAgICAgICAgICAgIGJvcmRlclJhZGl1czogJzUwJScsXHJcbiAgICAgICAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxyXG4gICAgICAgICAgICB3aWR0aDogJzI1MCUnXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcImRvdDpiZWZvcmVcIjoge1xyXG4gICAgICAgICAgICBwYWRkaW5nVG9wOiAnMTAwJScsXHJcbiAgICAgICAgICAgIGNvbnRlbnQ6IGBcIlwiYCxcclxuICAgICAgICAgICAgZmxvYXQ6ICdsZWZ0J1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCIhcmlwcGxlLWVmZmVjdFwiOiB7XHJcbiAgICAgICAgICAgIFwiMCVcIjoge1xyXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlKC01MCUsIC01MCUpIHNjYWxlKDAsIDApJyxcclxuICAgICAgICAgICAgICAgIC8vIHdpZHRoOiAwLFxyXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSgwLCAwLCAwLCAwKSdcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXCI3MCVcIjoge1xyXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSgwLCAwLCAwLCAwLjEpJ1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBcIjEwMCVcIjoge1xyXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlKC01MCUsIC01MCUpIHNjYWxlKDEsIDEpJyxcclxuICAgICAgICAgICAgICAgIC8vIHdpZHRoOiAnMTUwJScsXHJcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDAsIDAsIDAsIDAuMCknXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbik7XHJcblxyXG5jbGFzcyBSaXBwbGUgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xyXG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcclxuICAgICAgICBzdXBlcihwcm9wcyk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtsaXN0OiBbXX07XHJcbiAgICB9XHJcblxyXG4gICAgdG91Y2ggPSAoZXZ0KSA9PiB7XHJcbiAgICAgICAgY29uc3Qge3Bvc2l0aW9ufSA9IGV2dC50b3VjaDtcclxuICAgICAgICBjb25zdCB7dG9wLCBsZWZ0fSA9IHRoaXMucmVmcy53cmFwcGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgIHRoaXMudHJpZ2dlclJpcHBsZShwb3NpdGlvbi54IC0gbGVmdCwgcG9zaXRpb24ueSAtIHRvcCk7XHJcbiAgICB9XHJcbiAgICB0cmlnZ2VyUmlwcGxlID0gKHggPSBudWxsLCB5KSA9PiB7XHJcbiAgICAgICAgbGV0IHtsaXN0fSA9IHRoaXMuc3RhdGU7XHJcblxyXG4gICAgICAgIGlmICh4ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHt3aWR0aCwgaGVpZ2h0fSA9IHRoaXMucmVmcy53cmFwcGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgICAgICB4ID0gd2lkdGggLyAyO1xyXG4gICAgICAgICAgICB5ID0gaGVpZ2h0IC8gMjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNocm9uby50cmlnZ2VyKFxyXG4gICAgICAgICAgICBhbmltYXRpb25EdXJhdGlvbixcclxuICAgICAgICAgICAgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYWN0aXZlID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xyXG4gICAgICAgICAgICAgICAgICAgIGxpc3Q6IHRoaXMuc3RhdGUubGlzdC5zbGljZSgxKVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICApO1xyXG4gICAgICAgIGxpc3QgPSBbLi4ubGlzdCwge3gsIHksIGlkOiBEYXRlLm5vdygpfV07XHJcblxyXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe2xpc3R9KTtcclxuICAgIH1cclxuXHJcbiAgICBjb21wb25lbnREaWRNb3VudCA9ICgpID0+IHtcclxuICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCA9ICgpID0+IHtcclxuICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdyZW1vdmluZycpO1xyXG4gICAgfVxyXG5cclxuICAgIHJlbmRlciA9ICgpID0+IHtcclxuICAgICAgICBjb25zdCB7bGlzdH0gPSB0aGlzLnN0YXRlO1xyXG5cclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICA8VUkuVG91Y2hhYmxlIGNvbXBvbmVudD1cImRpdlwiIGNsYXNzTmFtZT1cInJpcHBsZS1jb3JlLXdyYXBwZXJcIiBvblRhcD17dGhpcy50b3VjaH0gcmVmPVwid3JhcHBlclwiPlxyXG4gICAgICAgICAgICAgICAge2xpc3QubWFwKCh7aWQsIHgsIHl9KSA9PiA8ZGl2IGtleT17aWR9IHN0eWxlPXt7dG9wOiB5LCBsZWZ0OiB4fX0gY2xhc3NOYW1lPVwicmlwcGxlLWNvcmUtZG90XCIgLz4pfVxyXG4gICAgICAgICAgICA8L1VJLlRvdWNoYWJsZT5cclxuICAgICAgICApO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBSaXBwbGU7XHJcbiIsImNvbnN0IHJnYiA9IChyLCBnLCBiKSA9PiBgcmdiYSgke3J9LCAke2d9LCAke2J9KWA7XHJcbmNvbnN0IHJnYmEgPSAociwgZywgYiwgYSkgPT4gYHJnYmEoJHtyfSwgJHtnfSwgJHtifSwgJHthfSlgO1xyXG5cclxuY29uc3QgaG92ZXJDb2xvciA9IHJnYmEoMCwgMCwgMCwgMC4xKTtcclxuY29uc3QgYWN0aXZlQ29sb3IgPSByZ2JhKDAsIDAsIDAsIDAuMik7XHJcbmNvbnN0IHNoYWRvdyA9IG51bGw7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBPYmplY3QuZnJlZXplKHtcclxuICAgIHJnYiwgcmdiYSxcclxuXHJcbiAgICBob3ZlckNvbG9yLFxyXG4gICAgYWN0aXZlQ29sb3IsXHJcbiAgICBzaGFkb3dcclxufSk7XHJcbiIsImV4cG9ydCBkZWZhdWx0IE9iamVjdC5mcmVlemUoe1xyXG4gICAgbW9iaWxlOiB0eXBlb2Ygb3JpZW50YXRpb24gIT09ICd1bmRlZmluZWQnIHx8IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcIk1vYmlsZVwiKSAhPT0gLTEsXHJcbiAgICBhcHA6IHR5cGVvZiBjb3Jkb3ZhICE9PSAndW5kZWZpbmVkJ1xyXG59KTtcclxuIiwiY29uc3QgYWpheCA9ICh1cmwsIG9wdGlvbnMgPSB7fSkgPT4gbmV3IFByb21pc2UoXHJcbiAgICAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgY29uc3Qge1xyXG4gICAgICAgICAgICBoZWFkZXJzID0ge30sXHJcbiAgICAgICAgICAgIHRpbWVvdXQgPSAwLFxyXG4gICAgICAgICAgICB0eXBlID0gbnVsbCxcclxuICAgICAgICAgICAgb25Qcm9ncmVzcyA9ICgpID0+IHt9LFxyXG4gICAgICAgICAgICB0b2tlbiA9IG51bGxcclxuICAgICAgICB9ID0gb3B0aW9ucztcclxuICAgICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcbiAgICAgICAgbGV0IHtwb3N0ID0gbnVsbH0gPSBvcHRpb25zO1xyXG5cclxuICAgICAgICBsZXQgY29udGVudFR5cGUgPSBudWxsO1xyXG4gICAgICAgIGxldCBtZXRob2Q7XHJcblxyXG4gICAgICAgIGlmICh0b2tlbiAhPT0gbnVsbCAmJiB0b2tlbi51c2VkID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICB0b2tlbi5iaW5kVG8ocmVxdWVzdCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAocG9zdCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICBtZXRob2QgPSAnR0VUJztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBtZXRob2QgPSBcIlBPU1RcIjtcclxuICAgICAgICAgICAgaWYgKEZvcm1EYXRhLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKHBvc3QpID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgZGVidWdnZXI7XHJcbiAgICAgICAgICAgICAgICBwb3N0ID0gSlNPTi5zdHJpbmdpZnkocG9zdCk7XHJcbiAgICAgICAgICAgICAgICBjb250ZW50VHlwZSA9IFwiYXBwbGljYXRpb24vanNvblwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodHlwZSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9IHR5cGU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoXHJcbiAgICAgICAgICAgICdsb2FkJyxcclxuICAgICAgICAgICAgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzID09PSAwIHx8IChyZXF1ZXN0LnN0YXR1cyA+PSAyMDAgJiYgcmVxdWVzdC5zdGF0dXMgPCAzMDApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogcmVxdWVzdC5zdGF0dXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1c1RleHQ6IHJlcXVlc3Quc3RhdHVzVGV4dCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6IHJlcXVlc3QucmVzcG9uc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHJlcXVlc3QpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgKTtcclxuICAgICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCByZWplY3QpO1xyXG4gICAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcihcInRpbWVvdXRcIiwgcmVqZWN0KTtcclxuICAgICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCAoKSA9PiByZXNvbHZlKG51bGwpKTtcclxuICAgICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoXCJwcm9ncmVzc1wiLCBvblByb2dyZXNzKTtcclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmVxdWVzdC5vcGVuKG1ldGhvZCwgdXJsLCB0cnVlKTtcclxuICAgICAgICAgICAgcmVxdWVzdC50aW1lb3V0ID0gdGltZW91dDtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBbaGVhZGVyLCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoaGVhZGVycykpIHtcclxuICAgICAgICAgICAgICAgIHJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcihoZWFkZXIsIHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIoXCJBY2NlcHRcIiwgXCJcIik7XHJcbiAgICAgICAgICAgIHJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcihcIkFjY2VwdFwiLCBcIiovKlwiKTtcclxuICAgICAgICAgICAgaWYgKGNvbnRlbnRUeXBlICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIoXCJDb250ZW50LVR5cGVcIiwgY29udGVudFR5cGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlcXVlc3Quc2VuZChwb3N0KTtcclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICByZWplY3QoZXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuKTtcclxuYWpheC5jYW5jZWxUb2tlbiA9ICgpID0+IHtcclxuICAgIGxldCByZXF1ZXN0ID0gbnVsbDtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGNhbmNlbCgpIHtcclxuICAgICAgICAgICAgaWYgKHJlcXVlc3QgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJlcXVlc3QuYWJvcnQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0IHVzZWQoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZXF1ZXN0ICE9PSBudWxsO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYmluZFRvKHJlcSkge1xyXG4gICAgICAgICAgICBpZiAocmVxdWVzdCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdCA9IHJlcTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBhamF4O1xyXG4iLCJpbXBvcnQgcmVnZXggZnJvbSBcInhyZWdleHBcIjtcclxuXHJcbmNvbnN0IGNocm9ub1NwZWNpYWwgPSB7XHJcbiAgICAneWVzdGVyZGF5JyhkYXRlKSB7XHJcbiAgICAgICAgZGF0ZS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpIC0gMSk7XHJcbiAgICAgICAgcmV0dXJuIGRhdGU7XHJcbiAgICB9LFxyXG4gICAgJzEgd2VlayBhZ28nKGRhdGUpIHtcclxuICAgICAgICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgLSA3KTtcclxuICAgICAgICByZXR1cm4gZGF0ZTtcclxuICAgIH1cclxufTtcclxuY29uc3QgY2hyb25vVW5pdFJlZ2V4ID0gcmVnZXgoXCIoPzxvZmZzZXQ+KFxcXFwrfFxcXFwtKVxcXFxkKykgKD88dW5pdD5cXFxcdyspXCIpO1xyXG5jb25zdCB1bml0RnVuY3Rpb24gPSB7XHJcbiAgICBtaWxsaXNlY29uZChkYXRlLCBtaWxsaXNlY29uZHMpIHtcclxuICAgICAgICBkYXRlLnNldE1pbGxpc2Vjb25kcyhkYXRlLmdldE1pbGxpc2Vjb25kcygpICsgbWlsbGlzZWNvbmRzKTtcclxuICAgICAgICByZXR1cm4gZGF0ZTtcclxuICAgIH0sXHJcbiAgICBzZWNvbmQoZGF0ZSwgc2Vjb25kcykge1xyXG4gICAgICAgIGRhdGUuc2V0U2Vjb25kcyhkYXRlLmdldFNlY29uZHMoKSArIHNlY29uZHMpO1xyXG4gICAgICAgIHJldHVybiBkYXRlO1xyXG4gICAgfSxcclxuICAgIG1pbnV0ZShkYXRlLCBtaW51dGVzKSB7XHJcbiAgICAgICAgZGF0ZS5zZXRNaW51dGVzKGRhdGUuZ2V0TWludXRlcygpICsgbWludXRlcyk7XHJcbiAgICAgICAgcmV0dXJuIGRhdGU7XHJcbiAgICB9LFxyXG4gICAgaG91cihkYXRlLCBob3Vycykge1xyXG4gICAgICAgIGRhdGUuc2V0SG91cnMoZGF0ZS5nZXRIb3VycygpICsgaG91cnMpO1xyXG4gICAgICAgIHJldHVybiBkYXRlO1xyXG4gICAgfSxcclxuICAgIGRheShkYXRlLCBkYXlzKSB7XHJcbiAgICAgICAgZGF0ZS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpICsgZGF5cyk7XHJcbiAgICAgICAgcmV0dXJuIGRhdGU7XHJcbiAgICB9LFxyXG4gICAgd2VlayhkYXRlLCB3ZWVrcykge1xyXG4gICAgICAgIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSArIHdlZWtzICogNyk7XHJcbiAgICAgICAgcmV0dXJuIGRhdGU7XHJcbiAgICB9LFxyXG4gICAgbW9udGgoZGF0ZSwgbW9udGhzKSB7XHJcbiAgICAgICAgY29uc3QgZXhwZWN0ZWQgPSBkYXRlLmdldE1vbnRoKCkgKyBtb250aHM7XHJcbiAgICAgICAgZGF0ZS5zZXRNb250aChleHBlY3RlZCk7XHJcbiAgICAgICAgaWYgKGRhdGUuZ2V0TW9udGgoKSAhPT0gZXhwZWN0ZWQpIHtcclxuICAgICAgICAgICAgZGF0ZS5zZXREYXRlKDApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGF0ZTtcclxuICAgIH0sXHJcbiAgICB5ZWFyKGRhdGUsIHllYXJzKSB7XHJcbiAgICAgICAgZGF0ZS5zZXRGdWxsWWVhcihkYXRlLmdldEZ1bGxZZWFyKCkgKyB5ZWFycyk7XHJcbiAgICAgICAgcmV0dXJuIGRhdGU7XHJcbiAgICB9LFxyXG4gICAgZGVjYWRlKGRhdGUsIGRlY2FkZXMpIHtcclxuICAgICAgICBkYXRlLnNldEZ1bGxZZWFyKGRhdGUuZ2V0RnVsbFllYXIoKSArIGRlY2FkZXMgKiAxMCk7XHJcbiAgICAgICAgcmV0dXJuIGRhdGU7XHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IHN0YXJ0T2YgPSB7XHJcbiAgICBzZWNvbmQoZGF0ZSkge1xyXG4gICAgICAgIGRhdGUuc2V0TWlsbGlzZWNvbmRzKDApO1xyXG4gICAgfSxcclxuICAgIG1pbnV0ZShkYXRlKSB7XHJcbiAgICAgICAgc3RhcnRPZi5zZWNvbmQoZGF0ZSk7XHJcbiAgICAgICAgZGF0ZS5zZXRTZWNvbmRzKDApO1xyXG4gICAgfSxcclxuICAgIGhvdXIoZGF0ZSkge1xyXG4gICAgICAgIHN0YXJ0T2YubWludXRlKGRhdGUpO1xyXG4gICAgICAgIGRhdGUuc2V0TWludXRlcygwKTtcclxuICAgIH0sXHJcbiAgICBkYXkoZGF0ZSkge1xyXG4gICAgICAgIHN0YXJ0T2YuaG91cihkYXRlKTtcclxuICAgICAgICBkYXRlLnNldEhvdXJzKDApO1xyXG4gICAgfSxcclxuICAgIHdlZWsoZGF0ZSkge1xyXG4gICAgICAgIHN0YXJ0T2YuZGF5KGRhdGUpO1xyXG4gICAgICAgIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSAtIGRhdGUuZ2V0RGF5KCkpO1xyXG4gICAgfSxcclxuICAgIG1vbnRoKGRhdGUpIHtcclxuICAgICAgICBzdGFydE9mLmRheShkYXRlKTtcclxuICAgICAgICBkYXRlLnNldERhdGUoMSk7XHJcbiAgICB9LFxyXG4gICAgeWVhcihkYXRlKSB7XHJcbiAgICAgICAgc3RhcnRPZi5tb250aChkYXRlKTtcclxuICAgICAgICBkYXRlLnNldE1vbnRoKDApO1xyXG4gICAgfVxyXG59O1xyXG5jb25zdCBlbmRPZiA9IHtcclxuICAgIHNlY29uZChkYXRlKSB7XHJcbiAgICAgICAgZGF0ZS5zZXRNaWxsaXNlY29uZHMoOTk5KTtcclxuICAgIH0sXHJcbiAgICBtaW51dGUoZGF0ZSkge1xyXG4gICAgICAgIGVuZE9mLnNlY29uZChkYXRlKTtcclxuICAgICAgICBkYXRlLnNldFNlY29uZHMoNTkpO1xyXG4gICAgfSxcclxuICAgIGhvdXIoZGF0ZSkge1xyXG4gICAgICAgIGVuZE9mLm1pbnV0ZShkYXRlKTtcclxuICAgICAgICBkYXRlLnNldE1pbnV0ZXMoNTkpO1xyXG4gICAgfSxcclxuICAgIGRheShkYXRlKSB7XHJcbiAgICAgICAgZW5kT2YuaG91cihkYXRlKTtcclxuICAgICAgICBkYXRlLnNldEhvdXJzKDIzKTtcclxuICAgIH0sXHJcbiAgICB3ZWVrKGRhdGUpIHtcclxuICAgICAgICBlbmRPZi5kYXkoZGF0ZSk7XHJcbiAgICAgICAgZGF0ZS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpICsgKDYgLSBkYXRlLmdldERheSgpKSk7XHJcbiAgICB9LFxyXG4gICAgbW9udGgoZGF0ZSkge1xyXG4gICAgICAgIGVuZE9mLmRheShkYXRlKTtcclxuICAgICAgICBkYXRlLnNldE1vbnRoKGRhdGUuZ2V0TW9udGgoKSArIDEpO1xyXG4gICAgICAgIGRhdGUuc2V0RGF0ZSgwKTtcclxuICAgIH0sXHJcbiAgICB5ZWFyKGRhdGUpIHtcclxuICAgICAgICBlbmRPZi5tb250aChkYXRlKTtcclxuICAgICAgICBkYXRlLnNldE1vbnRoKDExKTtcclxuICAgIH1cclxufTtcclxuY29uc3QgdW5pdENvbnZlcnNpb24gPSB7XHJcbiAgICAnbWlsbGlzZWNvbmQnOiAnbWlsbGlzZWNvbmQnLFxyXG4gICAgJ21pbGxpc2Vjb25kcyc6ICdtaWxsaXNlY29uZCcsXHJcbiAgICAnbXMnOiAnbWlsbGlzZWNvbmQnLFxyXG5cclxuICAgICdzZWNvbmQnOiAnc2Vjb25kJyxcclxuICAgICdzZWNvbmRzJzogJ3NlY29uZCcsXHJcbiAgICAncyc6ICdzZWNvbmQnLFxyXG5cclxuICAgICdtaW51dGUnOiAnbWludXRlJyxcclxuICAgICdtaW51dGVzJzogJ21pbnV0ZScsXHJcbiAgICAnbWluJzogJ21pbnV0ZScsXHJcblxyXG4gICAgJ2hvdXInOiAnaG91cicsXHJcbiAgICAnaG91cnMnOiAnaG91cicsXHJcbiAgICAnaHInOiAnaG91cicsXHJcblxyXG4gICAgJ2RheSc6ICdkYXknLFxyXG4gICAgJ2RheXMnOiAnZGF5JyxcclxuICAgICduaSc6ICdkYXknLFxyXG4gICAgJ2hpJzogJ2RheScsXHJcbiAgICAn5pelJzogJ2RheScsXHJcblxyXG4gICAgJ3dlZWsnOiAnd2VlaycsXHJcbiAgICAnd2Vla3MnOiAnd2VlaycsXHJcbiAgICAnc2h1dSc6ICd3ZWVrJyxcclxuICAgICfjgZfjgoXjgYYnOiAnd2VlaycsXHJcbiAgICAn6YCxJzogJ3dlZWsnLFxyXG5cclxuICAgICdtb250aCc6ICdtb250aCcsXHJcbiAgICAnbW9udGhzJzogJ21vbnRoJyxcclxuXHJcbiAgICAneWVhcic6ICd5ZWFyJyxcclxuICAgICd5ZWFycyc6ICd5ZWFyJyxcclxuXHJcbiAgICAnZGVjYWRlJzogJ2RlY2FkZScsXHJcbiAgICAnZGVjYWRlcyc6ICdkZWNhZGUnXHJcbn07XHJcbmNvbnN0IGNocm9ub0luZm8gPSB7XHJcbiAgICBkYXlzOiBbXHJcbiAgICAgICAgJ1N1bmRheScsXHJcbiAgICAgICAgJ01vbmRheScsXHJcbiAgICAgICAgJ1R1ZXNkYXknLFxyXG4gICAgICAgICdXZWRuZXNkYXknLFxyXG4gICAgICAgICdUaHVyc2RheScsXHJcbiAgICAgICAgJ0ZyaWRheScsXHJcbiAgICAgICAgJ1NhdHVyZGF5J1xyXG4gICAgXSxcclxuICAgIG1vbnRoczogW1xyXG4gICAgICAgICdKYW51YXJ5JyxcclxuICAgICAgICAnRmVicnVhcnknLFxyXG4gICAgICAgICdNYXJjaCcsXHJcbiAgICAgICAgJ0FwcmlsJyxcclxuICAgICAgICAnTWF5JyxcclxuICAgICAgICAnSnVuZScsXHJcbiAgICAgICAgJ0p1bHknLFxyXG4gICAgICAgICdBdWd1c3QnLFxyXG4gICAgICAgICdTZXB0ZW1iZXInLFxyXG4gICAgICAgICdPY3RvYmVyJyxcclxuICAgICAgICAnTm92ZW1iZXInLFxyXG4gICAgICAgICdEZWNlbWJlcidcclxuICAgIF1cclxufTtcclxuY29uc3QgY2hyb25vRm9ybWF0ID0ge1xyXG4gICAgbXM6IHtcclxuICAgICAgICBiYXNlOiBkYXRlID0+IGRhdGUuZ2V0TWlsbGlzZWNvbmRzKCksXHJcbiAgICAgICAgcGFkZGVkOiBkYXRlID0+IGAwMCR7ZGF0ZS5nZXRNaWxsaXNlY29uZHMoKX1gLnNsaWNlKC0zKVxyXG4gICAgfSxcclxuICAgIHNlY29uZDoge1xyXG4gICAgICAgIGJhc2U6IGRhdGUgPT4gZGF0ZS5nZXRTZWNvbmRzKCksXHJcbiAgICAgICAgcGFkZGVkOiBkYXRlID0+IGAwJHtkYXRlLmdldFNlY29uZHMoKX1gLnNsaWNlKC0yKVxyXG4gICAgfSxcclxuICAgIG1pbnV0ZToge1xyXG4gICAgICAgIGJhc2U6IGRhdGUgPT4gZGF0ZS5nZXRNaW51dGVzKCksXHJcbiAgICAgICAgcGFkZGVkOiBkYXRlID0+IGAwJHtkYXRlLmdldE1pbnV0ZXMoKX1gLnNsaWNlKC0yKVxyXG4gICAgfSxcclxuICAgIGhvdXI6IHtcclxuICAgICAgICBiYXNlOiBkYXRlID0+IGRhdGUuZ2V0SG91cnMoKSxcclxuICAgICAgICBwYWRkZWQ6IGRhdGUgPT4gYDAke2RhdGUuZ2V0SG91cnMoKX1gLnNsaWNlKC0yKSxcclxuICAgICAgICBcIjEyXCI6IGRhdGUgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBob3VyID0gZGF0ZS5nZXRIb3VycygpICUgMTI7XHJcbiAgICAgICAgICAgIGlmIChob3VyID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMTI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGhvdXJcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiMTJwYWRkZWRcIjogZGF0ZSA9PiBgMCR7Y2hyb25vRm9ybWF0LmhvdXJbJzEyJ10oZGF0ZSl9YC5zbGljZSgtMilcclxuICAgIH0sXHJcbiAgICB3ZWVrZGF5OiB7XHJcbiAgICAgICAgYmFzZTogZGF0ZSA9PiBkYXRlLmdldERheSgpLFxyXG4gICAgICAgIHNob3J0OiBkYXRlID0+IGNocm9ub0luZm8uZGF5c1tkYXRlLmdldERheSgpXS5zbGljZSgwLCAzKSxcclxuICAgICAgICBmdWxsOiBkYXRlID0+IGNocm9ub0luZm8uZGF5c1tkYXRlLmdldERheSgpXVxyXG4gICAgfSxcclxuICAgIGRhdGU6IHtcclxuICAgICAgICBiYXNlOiBkYXRlID0+IGRhdGUuZ2V0RGF0ZSgpLFxyXG4gICAgICAgIHBhZGRlZDogZGF0ZSA9PiBgMCR7ZGF0ZS5nZXREYXRlKCl9YC5zbGljZSgtMilcclxuICAgIH0sXHJcbiAgICBtb250aDoge1xyXG4gICAgICAgIGJhc2U6IGRhdGUgPT4gZGF0ZS5nZXRNb250aCgpICsgMSxcclxuICAgICAgICBzaG9ydDogZGF0ZSA9PiBjaHJvbm9JbmZvLm1vbnRoc1tkYXRlLmdldERhdGUoKV0uc2xpY2UoMCwgMyksXHJcbiAgICAgICAgZnVsbDogZGF0ZSA9PiBjaHJvbm9JbmZvLm1vbnRoc1tkYXRlLmdldERhdGUoKV1cclxuICAgIH0sXHJcbiAgICB5ZWFyOiB7XHJcbiAgICAgICAgYmFzZTogZGF0ZSA9PiBkYXRlLmdldEZ1bGxZZWFyKCkgJSAxMDAsXHJcbiAgICAgICAgZnVsbDogZGF0ZSA9PiBkYXRlLmdldEZ1bGxZZWFyKClcclxuICAgIH0sXHJcbiAgICB0b2Q6IHtcclxuICAgICAgICBiYXNlOiBkYXRlID0+IChkYXRlLmdldEhvdXJzKCkgPCAxMiA9PT0gdHJ1ZSkgPyBcIkFNXCIgOiBcIlBNXCJcclxuICAgIH1cclxufTtcclxuY2hyb25vRm9ybWF0LmRheSA9IGNocm9ub0Zvcm1hdC5kYXRlO1xyXG5jb25zdCBjaHJvbm9DaGVja1VuaXQgPSB1bml0ID0+IHtcclxuICAgIGlmICh1bml0Q29udmVyc2lvbi5oYXNPd25Qcm9wZXJ0eSh1bml0KSA9PT0gZmFsc2UpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVucmVjb2duaXplZCB1bml0OiAke3VuaXR9YCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKiAtQXhlbERvYy1cclxubW9kdWxlIGdsb2JhbCB7XHJcbiAgICBAZnVuY3Rpb24gY2hyb25vIHtcclxuICAgICAgICBAZGVzYyBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIHtjaHJvbm99LlxyXG4gICAgICAgIEBhcmdzIHtcclxuICAgICAgICAgICAgQGFyZyBkYXRlVGltZSBbRGF0ZV1cclxuICAgICAgICAgICAgICAgIFRoaXMgaXMgc29tZSBsb25nIGRlc2NyaXB0aW9uIG9mIHRoZSB0aGluZ1xyXG4gICAgICAgICAgICAgICAge3llYXIsIG1vbnRofSBkZXN0cnVjdHVyaW5nP1xyXG4gICAgICAgICAgICAgICAgW3RpdGxlXXllYXJbdGl0bGVdXHJcbiAgICAgICAgfVxyXG4gICAgICAgIEByZXR1cm4gY2hyb25vXHJcblxyXG4gICAgICAgIEBmdW5jdGlvbiBkaWZmIHtcclxuICAgICAgICAgICAgQGRlc2MgQSBmdW5jdGlvbiB0aGF0IHdpbGwgY2FsY3VsYXRlIHRoZSBhbW91bnQgb2YgdGltZSB0byBhZGQgdG8gdGhlIGZpcnN0IGFyZ3VtZW50IGluIG9yZGVyIHRvIGdldCB0aGUgc2Vjb25kIGFyZ3VtZW50LlxyXG4gICAgICAgICAgICBAYXJncyB7XHJcbiAgICAgICAgICAgICAgICBAYXJnIHN0YXJ0RGF0ZSBbY2hyb25vXSBUaGUgZGF0ZSB0byBzdGFydCBmcm9tLlxyXG4gICAgICAgICAgICAgICAgQGFyZyB0YXJnZXREYXRlIFtjaHJvbm9dIFRoZSBkYXRlIHRvIGdldCB0by5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBAcmV0dXJuIG9iamVjdFxyXG4gICAgICAgIH1cclxuICAgICAgICBAZnVuY3Rpb24gbm93IHtcclxuICAgICAgICAgICAgQGRlc2MgUmV0dXJucyB0aGUgY3VycmVudCBkYXRlIGFzIGEgY2hyb25vIG9iamVjdC5cclxuICAgICAgICAgICAgQGFyZ3Mge31cclxuICAgICAgICAgICAgQHJldHVybiBjaHJvbm9cclxuICAgICAgICB9XHJcbiAgICAgICAgQGZ1bmN0aW9uIHBhcnNlIHtcclxuICAgICAgICAgICAgQGRlc2MgUGFyc2VzIGEgZGF0ZSBzdHJpbmcgYW5kIHJldHVybnMgdGhlIGNocm9ubyBvYmplY3QgcmVwcmVzZW50ZWQgYnkgaXQuXHJcbiAgICAgICAgICAgIEBhcmdzIHtcclxuICAgICAgICAgICAgICAgIEBhcmcgZGF0ZVN0cmluZyBbc3RyaW5nXSBUaGUgc3RyaW5nIHRvIHBhcnNlLlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIEByZXR1cm4gY2hyb25vXHJcbiAgICAgICAgfVxyXG4gICAgICAgIEBmdW5jdGlvbiBwYXJzZU1TIHtcclxuICAgICAgICAgICAgQGRlc2MgUGFyc2VzIGEgZGF0ZSBzdHJpbmcgZ2VuZXJhdGVkIGJ5IEMjIGNvZGUgYW5kIHJldHVybnMgdGhlIGNocm9ubyBvYmplY3QgcmVwcmVzZW50ZWQgYnkgaXQuXHJcbiAgICAgICAgICAgIEBhcmdzIHtcclxuICAgICAgICAgICAgICAgIEBhcmcgZGF0ZVN0cmluZyBbc3RyaW5nXSBUaGUgc3RyaW5nIHRvIHBhcnNlLlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIEByZXR1cm4gY2hyb25vXHJcbiAgICAgICAgfVxyXG4gICAgICAgIEBmdW5jdGlvbiB0cmlnZ2VyIHtcclxuICAgICAgICAgICAgQGRlc2MgRmlyZXMgYSBmdW5jdGlvbiBhZnRlciBhIHNwZWNpZmllZCB0aW1lLlxyXG4gICAgICAgICAgICBAYXJncyB7XHJcbiAgICAgICAgICAgICAgICBAYXJnIGRlbGF5IFtudW1iZXJdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHdhaXQuXHJcbiAgICAgICAgICAgICAgICBAYXJnIGZ1bmMgW2Z1bmN0aW9uXSBUaGUgZnVuY3Rpb24gdG8gY2FsbC5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBAcmV0dXJuIGNocm9ub1RyaWdnZXJcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgb2JqZWN0IGNocm9ubyB7XHJcbiAgICAgICAgQHByb3AgZGF0ZU9iamVjdCB7XHJcbiAgICAgICAgICAgIEBkZXNjIEdldHMgYSBjb3B5IG9mIHRoZSBpbnRlcm5hbCBEYXRlIG9iamVjdC5cclxuICAgICAgICAgICAgQHR5cGUgRGF0ZVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgQHByb3AgdW5peFRpbWVzdGFtcCB7XHJcbiAgICAgICAgICAgIEBkZXNjIEdldHMgdGhlIHVuaXggdGltZXN0YW1wIG9mIHRoZSBjaHJvbm8gb2JqZWN0LlxyXG4gICAgICAgICAgICBAdHlwZSBudW1iZXJcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIEBwcm9wIG1pbGxpc2Vjb25kcyB7XHJcbiAgICAgICAgICAgIEBkZXNjIEdldHMgdGhlIG1pbGxpc2Vjb25kcyBvZiB0aGUgY2hyb25vIG9iamVjdC5cclxuICAgICAgICAgICAgQHR5cGUgbnVtYmVyXHJcbiAgICAgICAgfVxyXG4gICAgICAgIEBwcm9wIHNlY29uZHMge1xyXG4gICAgICAgICAgICBAZGVzYyBHZXRzIHRoZSBzZWNvbmRzIG9mIHRoZSBjaHJvbm8gb2JqZWN0LlxyXG4gICAgICAgICAgICBAdHlwZSBudW1iZXJcclxuICAgICAgICB9XHJcbiAgICAgICAgQHByb3AgbWludXRlcyB7XHJcbiAgICAgICAgICAgIEBkZXNjIEdldHMgdGhlIG1pbnV0ZXMgb2YgdGhlIGNocm9ubyBvYmplY3QuXHJcbiAgICAgICAgICAgIEB0eXBlIG51bWJlclxyXG4gICAgICAgIH1cclxuICAgICAgICBAcHJvcCBob3VycyB7XHJcbiAgICAgICAgICAgIEBkZXNjIEdldHMgdGhlIGhvdXJzIG9mIHRoZSBjaHJvbm8gb2JqZWN0LlxyXG4gICAgICAgICAgICBAdHlwZSBudW1iZXJcclxuICAgICAgICB9XHJcbiAgICAgICAgQHByb3Agd2Vla2RheSB7XHJcbiAgICAgICAgICAgIEBkZXNjIEdldHMgdGhlIHdlZWtkYXkgb2YgdGhlIGNocm9ubyBvYmplY3QuXHJcbiAgICAgICAgICAgIEB0eXBlIG51bWJlclxyXG4gICAgICAgIH1cclxuICAgICAgICBAcHJvcCBkYXRlIHtcclxuICAgICAgICAgICAgQGRlc2MgR2V0cyB0aGUgZGF0ZSBvZiB0aGUgY2hyb25vIG9iamVjdC4gVGhpcyBudW1iZXIgaXMgYWRqdXN0ZWQgdG8gdGhlIHJhbmdlICgwLTMwKSB1bmxpa2UgdGhlIG5vcm1hbCBEYXRlIG9iamVjdC5cclxuICAgICAgICAgICAgQHR5cGUgbnVtYmVyXHJcbiAgICAgICAgfVxyXG4gICAgICAgIEBwcm9wIG1vbnRocyB7XHJcbiAgICAgICAgICAgIEBkZXNjIEdldHMgdGhlIG1vbnRocyBvZiB0aGUgY2hyb25vIG9iamVjdC5cclxuICAgICAgICAgICAgQHR5cGUgbnVtYmVyXHJcbiAgICAgICAgfVxyXG4gICAgICAgIEBwcm9wIHllYXIge1xyXG4gICAgICAgICAgICBAZGVzYyBHZXRzIHRoZSB5ZWFyIG9mIHRoZSBjaHJvbm8gb2JqZWN0LlxyXG4gICAgICAgICAgICBAdHlwZSBudW1iZXJcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIEBmdW5jdGlvbiBzaGlmdCB7XHJcbiAgICAgICAgICAgIEBkZXNjIFNoaWZ0cyB0aGUgZGF0ZSBmb3J3YXJkIG9yIGJhY2t3YXJkIGluIHRpbWUuXHJcbiAgICAgICAgICAgIEBhcmdzIHtcclxuICAgICAgICAgICAgICAgIEBhcmcgb2Zmc2V0IFtOdW1iZXJdIFRoZSBhbW91bnQgb2YgdGltZSB0byBzaGlmdCB0aGUgZGF0ZS5cclxuICAgICAgICAgICAgICAgIEBhcmcgdW5pdCBbU3RyaW5nXSBUaGUgdW5pdHMgdG8gc2hpZnQgYnkuIFZhbGlkIHZhbHVlcyBhcmU6ICdzZWNvbmQnLCAnbWludXRlJywgJ2hvdXInLCAnZGF5JywgJ3dlZWsnLCAnbW9udGgnLCAneWVhcicsICdkZWNhZGUnLlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIEBhcmdzIHtcclxuICAgICAgICAgICAgICAgIEBhcmcgZHVyYXRpb24gW29iamVjdF0gQW4gb2JqZWN0IHRoYXQgd2lsbCBzaGlmdCB0aGUgZGF0ZS5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBAcmV0dXJuIGNocm9ub1xyXG4gICAgICAgIH1cclxuICAgICAgICBAZnVuY3Rpb24gc3RhcnRPZiB7XHJcbiAgICAgICAgICAgIEBkZXNjIE1vdmVzIHRoZSBkYXRlIHRvIHRoZSBzdGFydCBvZiB0aGUgc3BlY2lmaWVkIHVuaXQuXHJcbiAgICAgICAgICAgIEBhcmdzIHtcclxuICAgICAgICAgICAgICAgIEBhcmcgdW5pdCBbc3RyaW5nXSBUaGUgdW5pdCB0byBtb3ZlIHRvIHRoZSBzdGFydCBvZi4gVmFsaWQgdmFsdWVzIGFyZTogJ3NlY29uZCcsICdtaW51dGUnLCAnaG91cicsICdkYXknLCAnd2VlaycsICdtb250aCcsICd5ZWFyJy5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBAcmV0dXJuIGNocm9ub1xyXG4gICAgICAgIH1cclxuICAgICAgICBAZnVuY3Rpb24gZm9ybWF0IHtcclxuICAgICAgICAgICAgQGRlc2MgRm9ybWF0cyB0aGUgY2hyb25vIG9iamVjdCB1c2luZyB0aGUgc3BlY2lmaWVkIHN0cmluZy5cclxuICAgICAgICAgICAgQGFyZ3Mge1xyXG4gICAgICAgICAgICAgICAgQGFyZyBmb3JtYXQgW3N0cmluZ10gVGhlIHN0cmluZyBkZXNjcmliaW5nIHRoZSBmb3JtYXQgdGhlIGRhdGUgc2hvdWxkIGJlIHB1dCBpbnRvLlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIEByZXR1cm4gc3RyaW5nXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIG9iamVjdCBjaHJvbm9UcmlnZ2VyIHtcclxuICAgICAgICBAcHJvcCBzdGF0dXMge1xyXG4gICAgICAgICAgICBAZGVzYyBUaGUgc3RhdHVzIG9mIHRoZSB0cmlnZ2VyLlxyXG4gICAgICAgICAgICBAdHlwZSBzdHJpbmdcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIEBmdW5jdGlvbiBjYW5jZWwge1xyXG4gICAgICAgICAgICBAZGVzYyBDYW5jZWxzIHRoZSB0cmlnZ2VyIGlmIGl0IGhhc24ndCBmaXJlZCB5ZXQuXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbiovXHJcbmNvbnN0IGNocm9ubyA9IChhcmcgPSBudWxsKSA9PiB7XHJcbiAgICBjb25zdCBpbnRlcm5hbERhdGUgPSAoKCkgPT4ge1xyXG4gICAgICAgIGlmIChhcmcgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoRGF0ZS5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihhcmcpID09PSB0cnVlIHx8ICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKGFyZyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoYXJnLl9fY2hyb25vID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhcmcuZGF0ZU9iamVjdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBhcmcgPSBhcmcudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgaWYgKGNocm9ub1NwZWNpYWwuaGFzT3duUHJvcGVydHkoYXJnKSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNocm9ub1NwZWNpYWxbYXJnXShuZXcgRGF0ZSgpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSByZWdleC5leGVjKGFyZywgY2hyb25vVW5pdFJlZ2V4KTtcclxuICAgICAgICAgICAgaWYgKG1hdGNoICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7b2Zmc2V0LCB1bml0fSA9IG1hdGNoO1xyXG5cclxuICAgICAgICAgICAgICAgIGNocm9ub0NoZWNrVW5pdCh1bml0KTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5pdEZ1bmN0aW9uW3VuaXRDb252ZXJzaW9uW3VuaXRdXShuZXcgRGF0ZSgpLCBwYXJzZUludChvZmZzZXQpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKGFyZyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCB7eWVhciA9IDE5NzAsIG1vbnRoID0gMCwgZGF0ZSA9IDAsIGhvdXJzID0gMCwgbWludXRlcyA9IDAsIHNlY29uZHMgPSAwLCBtaWxsaXNlY29uZHMgPSAwfSA9IGFyZztcclxuICAgICAgICByZXR1cm4gbmV3IERhdGUoeWVhciwgbW9udGgsIGRhdGUgKyAxLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzKTtcclxuICAgIH0pKCk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBfX2Nocm9ubzogdHJ1ZSxcclxuICAgICAgICBnZXQgZGF0ZU9iamVjdCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKGludGVybmFsRGF0ZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXQgdW5peFRpbWVzdGFtcCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGludGVybmFsRGF0ZS5nZXRUaW1lKCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZ2V0IG1pbGxpc2Vjb25kcygpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGludGVybmFsRGF0ZS5nZXRNaWxsaXNlY29uZHMoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldCBzZWNvbmRzKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxEYXRlLmdldFNlY29uZHMoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldCBtaW51dGVzKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxEYXRlLmdldE1pbnV0ZXMoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldCBob3VycygpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGludGVybmFsRGF0ZS5nZXRIb3VycygpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0IHdlZWtkYXkoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbERhdGUuZ2V0RGF5KCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXQgZGF0ZSgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGludGVybmFsRGF0ZS5nZXREYXRlKCkgLSAxO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0IG1vbnRoKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxEYXRlLmdldE1vbnRoKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXQgeWVhcigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGludGVybmFsRGF0ZS5nZXRGdWxsWWVhcigpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldChwcm9wcykge1xyXG4gICAgICAgICAgICBjb25zdCB7XHJcbiAgICAgICAgICAgICAgICB5ZWFyID0gaW50ZXJuYWxEYXRlLmdldEZ1bGxZZWFyKCksXHJcbiAgICAgICAgICAgICAgICBtb250aCA9IGludGVybmFsRGF0ZS5nZXRNb250aCgpLFxyXG4gICAgICAgICAgICAgICAgZGF0ZSA9IGludGVybmFsRGF0ZS5nZXREYXRlKCkgLSAxLFxyXG4gICAgICAgICAgICAgICAgaG91cnMgPSBpbnRlcm5hbERhdGUuZ2V0SG91cnMoKSxcclxuICAgICAgICAgICAgICAgIG1pbnV0ZXMgPSBpbnRlcm5hbERhdGUuZ2V0TWludXRlcygpLFxyXG4gICAgICAgICAgICAgICAgc2Vjb25kcyA9IGludGVybmFsRGF0ZS5nZXRTZWNvbmRzKCksXHJcbiAgICAgICAgICAgICAgICBtaWxsaXNlY29uZHMgPSBpbnRlcm5hbERhdGUuZ2V0TWlsbGlzZWNvbmRzKClcclxuICAgICAgICAgICAgfSA9IHByb3BzO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGNocm9ubyhuZXcgRGF0ZSh5ZWFyLCBtb250aCwgZGF0ZSArIDEsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMpKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNoaWZ0KG9mZnNldCwgdW5pdCkge1xyXG4gICAgICAgICAgICBsZXQgbmV3RGF0ZTtcclxuICAgICAgICAgICAgbmV3RGF0ZSA9IG5ldyBEYXRlKGludGVybmFsRGF0ZSk7XHJcblxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgICAgIC8vIGlmIChvZmZzZXQuaGFzT3duUHJvcGVydHkoJ19fY2hyb25vX2R1cmF0aW9uJykgJiYgb2Zmc2V0Ll9fY2hyb25vX2R1cmF0aW9uID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyAgICAgb2Zmc2V0ID0gb2Zmc2V0LmFzT2JqZWN0KCk7XHJcbiAgICAgICAgICAgICAgICAvLyB9XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBbdW5pdCwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG9mZnNldCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjaHJvbm9DaGVja1VuaXQodW5pdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3RGF0ZSA9IHVuaXRGdW5jdGlvblt1bml0Q29udmVyc2lvblt1bml0XV0obmV3RGF0ZSwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBjaHJvbm8obmV3RGF0ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXRjaCA9IHJlZ2V4LmV4ZWMob2Zmc2V0LCBjaHJvbm9Vbml0UmVnZXgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAoe29mZnNldCwgdW5pdH0gPSBtYXRjaCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hyb25vQ2hlY2tVbml0KHVuaXQpO1xyXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IHBhcnNlSW50KG9mZnNldCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNocm9ubyh1bml0RnVuY3Rpb25bdW5pdENvbnZlcnNpb25bdW5pdF1dKG5ld0RhdGUsIG9mZnNldCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzdGFydE9mKHVuaXQpIHtcclxuICAgICAgICAgICAgY29uc3QgYWRqdXN0ZWREYXRlID0gbmV3IERhdGUoaW50ZXJuYWxEYXRlKTtcclxuXHJcbiAgICAgICAgICAgIHN0YXJ0T2ZbdW5pdF0oYWRqdXN0ZWREYXRlKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBjaHJvbm8oYWRqdXN0ZWREYXRlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVuZE9mKHVuaXQpIHtcclxuICAgICAgICAgICAgY29uc3QgYWRqdXN0ZWREYXRlID0gbmV3IERhdGUoaW50ZXJuYWxEYXRlKTtcclxuXHJcbiAgICAgICAgICAgIGVuZE9mW3VuaXRdKGFkanVzdGVkRGF0ZSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gY2hyb25vKGFkanVzdGVkRGF0ZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBmb3JtYXQoZm9ybWF0U3RyaW5nID0gbnVsbCkge1xyXG4gICAgICAgICAgICBpZiAoZm9ybWF0U3RyaW5nID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxEYXRlLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChmb3JtYXRTdHJpbmcgPT09ICd1dGMnKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxEYXRlLnRvVVRDU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGZvcm1hdFN0cmluZyA9PT0gJ2xvY2FsZScpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbERhdGUudG9Mb2NhbGVTdHJpbmcoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdFN0cmluZy5yZXBsYWNlKFxyXG4gICAgICAgICAgICAgICAgL1xceyhcXHcrKShcXC8oXFx3KykpP1xcfS9nLFxyXG4gICAgICAgICAgICAgICAgKGZ1bGwsIHByb3AsIHNraXAsIHR5cGUgPSAnYmFzZScpID0+IGNocm9ub0Zvcm1hdFtwcm9wXVt0eXBlXShpbnRlcm5hbERhdGUpXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB0b1N0cmluZygpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGludGVybmFsRGF0ZS50b1N0cmluZygpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdG9KU09OKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxEYXRlLnRvSlNPTigpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn07XHJcbmNocm9uby5kaWZmID0gKGZpcnN0LCBzZWNvbmQpID0+IHtcclxuICAgIGNvbnN0IGludGVybmFsRGF0ZSA9IG5ldyBEYXRlKHNlY29uZC51bml4VGltZXN0YW1wIC0gZmlyc3QudW5peFRpbWVzdGFtcCk7XHJcbiAgICBjb25zb2xlLmxvZyhzZWNvbmQudW5peFRpbWVzdGFtcCAtIGZpcnN0LnVuaXhUaW1lc3RhbXApO1xyXG4gICAgY29uc29sZS5sb2coaW50ZXJuYWxEYXRlKTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG1pbGxpc2Vjb25kczogaW50ZXJuYWxEYXRlLmdldE1pbGxpc2Vjb25kcygpLFxyXG4gICAgICAgIHNlY29uZHM6IGludGVybmFsRGF0ZS5nZXRTZWNvbmRzKCksXHJcbiAgICAgICAgbWludXRlczogaW50ZXJuYWxEYXRlLmdldE1pbnV0ZXMoKSxcclxuICAgICAgICBob3VyczogaW50ZXJuYWxEYXRlLmdldEhvdXJzKCksXHJcbiAgICAgICAgZGF5czogaW50ZXJuYWxEYXRlLmdldERhdGUoKSAtIDEsXHJcbiAgICAgICAgbW9udGhzOiBpbnRlcm5hbERhdGUuZ2V0TW9udGgoKSxcclxuICAgICAgICB5ZWFyczogaW50ZXJuYWxEYXRlLmdldEZ1bGxZZWFyKCkgLSAxOTcwXHJcbiAgICB9O1xyXG59O1xyXG5jaHJvbm8ubm93ID0gKCkgPT4gY2hyb25vKERhdGUubm93KCkpO1xyXG5jaHJvbm8ucGFyc2UgPSBzdHJpbmcgPT4gY2hyb25vKERhdGUucGFyc2Uoc3RyaW5nKSk7XHJcbmNocm9uby5wYXJzZU1TID0gc3RyaW5nID0+IGNocm9ubyhEYXRlLnBhcnNlKHN0cmluZy5yZXBsYWNlKFwiVFwiLCBcIiBcIikpKTtcclxuY2hyb25vLnRyaWdnZXIgPSAoZGVsYXksIGZ1bmMsIC4uLmFyZ3MpID0+IHtcclxuICAgIGNvbnN0IGlkID0gc2V0VGltZW91dChcclxuICAgICAgICAoKSA9PiB7XHJcbiAgICAgICAgICAgIHN0YXR1cyA9ICdmaXJlZCc7XHJcbiAgICAgICAgICAgIGZ1bmMoLi4uYXJncyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBkZWxheVxyXG4gICAgKTtcclxuICAgIGxldCBzdGF0dXM7XHJcblxyXG4gICAgc3RhdHVzID0gJ3dhaXRpbmcnO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgY2FuY2VsKCkge1xyXG4gICAgICAgICAgICBzdGF0dXMgPSAnY2FuY2VsbGVkJztcclxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGlkKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldCBzdGF0dXMoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzdGF0dXM7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufTtcclxuY2hyb25vLndhaXQgPSB3YWl0ID0+IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dCgoKSA9PiByZXNvbHZlKG51bGwpLCB3YWl0KSk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjaHJvbm87XHJcbiIsImltcG9ydCBjcnlwdG8gZnJvbSBcImNyeXB0b1wiO1xyXG5cclxubGV0IGVuY3J5cHQ7XHJcbmxldCBkZWNyeXB0O1xyXG5sZXQgaGFzaDtcclxuXHJcbmVuY3J5cHQgPSAoc3RyLCBrZXksIHtpdiA9IG51bGwsIGFsZ29yaXRobSA9ICdhZXMyNTYnLCBvdXRwdXQgPSAnaGV4JywgaW5wdXQgPSAndXRmOCd9ID0ge30pID0+IHtcclxuICAgIGxldCBlbmNyeXB0b3I7XHJcbiAgICBsZXQgcmVzdWx0O1xyXG5cclxuICAgIGtleSA9IG5ldyBCdWZmZXIoa2V5KTtcclxuXHJcbiAgICBpZiAoaXYgPT09IG51bGwpIHtcclxuICAgICAgICBlbmNyeXB0b3IgPSBjcnlwdG8uY3JlYXRlQ2lwaGVyKGFsZ29yaXRobSwga2V5KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaXYgPSBuZXcgQnVmZmVyKGl2KTtcclxuICAgICAgICBlbmNyeXB0b3IgPSBjcnlwdG8uY3JlYXRlQ2lwaGVyKGFsZ29yaXRobSwga2V5LCBpdik7XHJcbiAgICB9XHJcblxyXG4gICAgcmVzdWx0ID0gZW5jcnlwdG9yLnVwZGF0ZShzdHIsIGlucHV0LCBvdXRwdXQpO1xyXG4gICAgcmVzdWx0ICs9IGVuY3J5cHRvci5maW5hbChvdXRwdXQpO1xyXG4gICAgZW5jcnlwdG9yID0gbnVsbDtcclxuICAgIHN0ciA9IG51bGw7XHJcbiAgICBrZXkuZmlsbCgwKTtcclxuXHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxuZGVjcnlwdCA9IChzdHIsIGtleSwge2l2ID0gbnVsbCwgYWxnb3JpdGhtID0gJ2FlczI1NicsIGlucHV0ID0gJ2hleCcsIG91dHB1dCA9ICd1dGY4J30gPSB7fSkgPT4ge1xyXG4gICAgbGV0IGRlY3J5cHRvcjtcclxuICAgIGxldCByZXN1bHQ7XHJcblxyXG4gICAga2V5ID0gbmV3IEJ1ZmZlcihrZXkpO1xyXG5cclxuICAgIGlmIChpdiA9PT0gbnVsbCkge1xyXG4gICAgICAgIGRlY3J5cHRvciA9IGNyeXB0by5jcmVhdGVEZWNpcGhlcihhbGdvcml0aG0sIGtleSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGl2ID0gbmV3IEJ1ZmZlcihpdik7XHJcbiAgICAgICAgZGVjcnlwdG9yID0gY3J5cHRvLmNyZWF0ZURlY2lwaGVyKGFsZ29yaXRobSwga2V5LCBpdik7XHJcbiAgICB9XHJcblxyXG4gICAgcmVzdWx0ID0gZGVjcnlwdG9yLnVwZGF0ZShzdHIsIGlucHV0LCBvdXRwdXQpO1xyXG4gICAgcmVzdWx0ICs9IGRlY3J5cHRvci5maW5hbChvdXRwdXQpO1xyXG4gICAgZGVjcnlwdG9yID0gbnVsbDtcclxuICAgIHN0ciA9IG51bGw7XHJcbiAgICBrZXkuZmlsbCgwKTtcclxuXHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxuaGFzaCA9IChzdHIsIGFsZ29yaXRobSA9ICdzaGE1MTInKSA9PiB7XHJcbiAgICBsZXQgaGFzaGVyO1xyXG5cclxuICAgIGhhc2hlciA9IGNyeXB0by5jcmVhdGVIYXNoKGFsZ29yaXRobSk7XHJcbiAgICBoYXNoZXIudXBkYXRlKHN0ciwgJ3V0ZjgnKTtcclxuICAgIHN0ciA9IG51bGw7XHJcblxyXG4gICAgcmV0dXJuIGhhc2hlci5kaWdlc3QoJ2hleCcpO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgZW5jcnlwdCxcclxuICAgIGRlY3J5cHQsXHJcbiAgICBoYXNoXHJcbn07XHJcbiIsImNvbnN0IHNoYXJlZFJlZmVyZW5jZSA9IHZhbHVlID0+ICh7XHJcbiAgICBnZXQgdmFsdWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfSxcclxuICAgIHNldChuZXdWYWx1ZSkge1xyXG4gICAgICAgIHZhbHVlID0gbmV3VmFsdWU7XHJcbiAgICB9XHJcbn0pO1xyXG5jbGFzcyBTaGFyZWRPYmplY3REaXNwbGF5IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XHJcbiAgICAgICAgc3VwZXIocHJvcHMpO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSB7dmFsdWU6IHRoaXMucHJvcHMucmVmZXJlbmNlLnZhbHVlfTtcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGUgPSAodmFsdWUpID0+IHtcclxuICAgICAgICB0aGlzLnByb3BzLnJlZmVyZW5jZS5zZXQodmFsdWUpO1xyXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe3ZhbHVlfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmVuZGVyID0gKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHtjb21wb25lbnQ6IENvbXBvbmVudCwgcmVmZXJlbmNlLCB2YWx1ZVByb3AsIGNvbnRhaW5lclN0eWxlLCAuLi5wcm9wc30gPSB0aGlzLnByb3BzO1xyXG4gICAgICAgIGNvbnN0IHt2YWx1ZX0gPSB0aGlzLnN0YXRlO1xyXG5cclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICA8ZGl2IHN0eWxlPXtjb250YWluZXJTdHlsZX0+XHJcbiAgICAgICAgICAgICAgICA8Q29tcG9uZW50IHsuLi5wcm9wc30gey4uLntbdmFsdWVQcm9wXTogdmFsdWV9fSBvbkNoYW5nZT17dGhpcy51cGRhdGV9IC8+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCB7XHJcbiAgICBzaGFyZWRSZWZlcmVuY2UsXHJcbiAgICBTaGFyZWRPYmplY3REaXNwbGF5XHJcbn07XHJcbiIsImNvbnN0IGNzc05vTWVhc3VyZW1lbnQgPSBuZXcgU2V0KFtcclxuICAgIFwiYW5pbWF0aW9uSXRlcmF0aW9uQ291bnRcIixcclxuICAgIFwiYm94RmxleFwiLFxyXG4gICAgXCJib3hGbGV4R3JvdXBcIixcclxuICAgIFwiYm94T3JkaW5hbEdyb3VwXCIsXHJcbiAgICBcImNvbHVtbkNvdW50XCIsXHJcbiAgICBcImZpbGxPcGFjaXR5XCIsXHJcbiAgICBcImZsZXhcIixcclxuICAgIFwiZmxleEdyb3dcIixcclxuICAgIFwiZmxleFBvc2l0aXZlXCIsXHJcbiAgICBcImZsZXhTaHJpbmtcIixcclxuICAgIFwiZmxleE5lZ2F0aXZlXCIsXHJcbiAgICBcImZsZXhPcmRlclwiLFxyXG4gICAgXCJmb250V2VpZ2h0XCIsXHJcbiAgICBcImxpbmVDbGFtcFwiLFxyXG4gICAgXCJsaW5lSGVpZ2h0XCIsXHJcbiAgICBcIm9wYWNpdHlcIixcclxuICAgIFwib3JkZXJcIixcclxuICAgIFwib3JwaGFuc1wiLFxyXG4gICAgXCJzdG9wT3BhY2l0eVwiLFxyXG4gICAgXCJzdHJva2VEYXNob2Zmc2V0XCIsXHJcbiAgICBcInN0cm9rZU9wYWNpdHlcIixcclxuICAgIFwic3Ryb2tlV2lkdGhcIixcclxuICAgIFwidGFiU2l6ZVwiLFxyXG4gICAgXCJ3aWRvd3NcIixcclxuICAgIFwiekluZGV4XCIsXHJcbiAgICBcInpvb21cIlxyXG5dKTtcclxuY29uc3QgY3NzUHJlZml4TmFtZXMgPSBuZXcgU2V0KFtcclxuICAgICd0cmFuc2Zvcm0nLFxyXG4gICAgJ2JveC1zaGFkb3cnLFxyXG4gICAgJ3RyYW5zaXRpb24nLFxyXG4gICAgJ2FuaW1hdGlvbicsXHJcbiAgICAnYW5pbWF0aW9uRGVsYXknLFxyXG4gICAgJ2FuaW1hdGlvbkRpcmVjdGlvbicsXHJcbiAgICAnYW5pbWF0aW9uRHVyYXRpb24nLFxyXG4gICAgJ2FuaW1hdGlvbkZpbGxNb2RlJyxcclxuICAgICdhbmltYXRpb25JdGVyYXRpb25Db3VudCcsXHJcbiAgICAnYW5pbWF0aW9uTmFtZScsXHJcbiAgICAnYW5pbWF0aW9uUGxheVN0YXRlJyxcclxuICAgICdhbmltYXRpb25UaW1pbmdGdW5jdGlvbidcclxuXSk7XHJcbmNvbnN0IGNzc1ByZWZpeGVzID0gWyctd2Via2l0LScsICctbW96LScsICctbXMtJywgJy1vLScsICcnXTtcclxuXHJcbmNvbnN0IGdldENTU1ZhbHVlID0gKHByb3AsIHZhbHVlKSA9PiB7XHJcbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICB2YWx1ZSA9IHZhbHVlKCk7XHJcbiAgICB9XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgPT09IHRydWUpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWUubWFwKHZhbHVlID0+IGdldENTU1ZhbHVlKHByb3AsIHZhbHVlKVswXSk7XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBjc3NOb01lYXN1cmVtZW50Lmhhcyhwcm9wKSA9PT0gZmFsc2UpIHtcclxuICAgICAgICB2YWx1ZSArPSBcInB4XCI7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gW3ZhbHVlXTtcclxufTtcclxuY29uc3QgcHJvY2Vzc1NlbGVjdG9yID0gKGNvbXBvbmVudE5hbWUsIHN0eWxlTmFtZSwgc2VsZWN0b3IpID0+IHtcclxuICAgIGNvbnN0IHBhcnRzID0gc2VsZWN0b3Iuc3BsaXQoL1xccysvKTtcclxuICAgIGNvbnN0IHJlYWxQYXJ0cyA9IHBhcnRzLm1hcChwYXJ0ID0+IHtcclxuICAgICAgICBwYXJ0ID0gcGFydC5yZXBsYWNlKFwiOmFjdGl2ZVwiLCBcIi5jb3ItdG91Y2gtYWN0aXZlXCIpO1xyXG4gICAgICAgIHJldHVybiBwYXJ0LnNwbGl0KCcvJykubWFwKHBhcnQgPT4ge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHRydWUpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgcGFydC5jaGFyQXQoMCkgPT09IFwiJFwiOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0LnNsaWNlKDEpO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAvXlthLXpdL2kudGVzdChwYXJ0KSA9PT0gdHJ1ZTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYC4ke2NvbXBvbmVudE5hbWV9LSR7c3R5bGVOYW1lfS0ke3BhcnR9YDtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KS5qb2luKCcnKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJlYWxQYXJ0cy5qb2luKCcgJyk7XHJcbn07XHJcbmNvbnN0IHByb2Nlc3NEZWYgPSAoY3NzTGluZXMsIHNlbGVjdG9yLCBkZWZzKSA9PiB7XHJcbiAgICBjc3NMaW5lcyA9IFsuLi5jc3NMaW5lcywgYCR7c2VsZWN0b3J9IHtgXTtcclxuICAgIGZvciAoY29uc3QgW2Nzc1Byb3AsIGNzc1ZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhkZWZzKSkge1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gZ2V0Q1NTVmFsdWUoY3NzUHJvcCwgY3NzVmFsdWUpO1xyXG4gICAgICAgIGNvbnN0IHByb3AgPSBjc3NQcm9wLnJlcGxhY2UoL1tBLVpdL2csIGxldHRlciA9PiAnLScgKyBsZXR0ZXIudG9Mb3dlckNhc2UoKSk7XHJcbiAgICAgICAgaWYgKHZhbHVlICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmIChjc3NQcmVmaXhOYW1lcy5oYXMoY3NzUHJvcCkgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgIGNzc0xpbmVzID0gW1xyXG4gICAgICAgICAgICAgICAgICAgIC4uLmNzc0xpbmVzLFxyXG4gICAgICAgICAgICAgICAgICAgIC4uLmNzc1ByZWZpeGVzLm1hcChwcmVmaXggPT4gYFxcdCR7cHJlZml4fSR7cHJvcH06ICR7dmFsdWVbMF19O2ApXHJcbiAgICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY3NzTGluZXMgPSBbXHJcbiAgICAgICAgICAgICAgICAgICAgLi4uY3NzTGluZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgLi4udmFsdWUubWFwKHZhbHVlID0+IGBcXHQke3Byb3B9OiAke3ZhbHVlfTtgKVxyXG4gICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNzc0xpbmVzID0gWy4uLmNzc0xpbmVzLCBcIn1cIl07XHJcbiAgICByZXR1cm4gY3NzTGluZXM7XHJcbiAgICAvLyBjc3NMaW5lcy5wdXNoKFwifVwiKTtcclxufTtcclxuXHJcbmNvbnN0IGNvbXBvbmVudFN0eWxlcyA9IHt9O1xyXG5jb25zdCBjcmVhdGVQcm9wID0gKG9iamVjdCwgcHJvcE5hbWUsIGRlZmF1bHRWYWx1ZSkgPT4ge1xyXG4gICAgaWYgKG9iamVjdC5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgb2JqZWN0W3Byb3BOYW1lXSA9IGRlZmF1bHRWYWx1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBvYmplY3RbcHJvcE5hbWVdO1xyXG59O1xyXG5jb25zdCBkZWZpbmVDb21wb25lbnRTdHlsZSA9IChjb21wb25lbnQsIHN0eWxlTmFtZSwgc3R5bGVzKSA9PlxyXG4gICAgY3JlYXRlUHJvcChcclxuICAgICAgICBjcmVhdGVQcm9wKGNvbXBvbmVudFN0eWxlcywgY29tcG9uZW50LCB7fSksXHJcbiAgICAgICAgc3R5bGVOYW1lLFxyXG4gICAgICAgIHN0eWxlc1xyXG4gICAgKTtcclxuY29uc3QgYmFzZVN0eWxlcyA9IHt9O1xyXG5jb25zdCBkZWZpbmVDdXN0b21CYXNlID0gKGNvbXBvbmVudCwgYmFzZUZ1bmMpID0+IHtcclxuICAgIGlmICh0eXBlb2YgY29tcG9uZW50ICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgIGNvbXBvbmVudCA9IGNvbXBvbmVudC5jb21wb25lbnROYW1lO1xyXG4gICAgfVxyXG4gICAgYmFzZVN0eWxlc1tjb21wb25lbnRdID0gYmFzZUZ1bmM7XHJcbn07XHJcbmNvbnN0IHByb3BTdHlsZU5hbWUgPSBuYW1lID0+IG5hbWUucmVwbGFjZSgvKF5cXHcpfFxcLVxcdy9nLCBzID0+IHMuc2xpY2UoLTEpLnRvVXBwZXJDYXNlKCkpO1xyXG5jb25zdCBkZWZpbmVTdHlsZUZvckNvbXBvbmVudCA9IChjb21wb25lbnQsIHN0eWxlTmFtZSwgb3B0aW9ucykgPT4ge1xyXG4gICAgY29uc3QgQ29tcG9uZW50ID0gY29tcG9uZW50O1xyXG4gICAgY29uc3Qgc3R5bGVEZWYgPSBiYXNlU3R5bGVzW2NvbXBvbmVudC5jb21wb25lbnROYW1lXShvcHRpb25zKTtcclxuICAgIGxldCBzdHlsZWRDb21wb25lbnQgPSBudWxsO1xyXG5cclxuICAgIGlmIChzdHlsZURlZiA9PT0gbnVsbCB8fCBzdHlsZURlZiA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBzdHlsZURlZiAhPT0gJ29iamVjdCcpIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oYEltcHJvcGVyIHR5cGUgcmV0dXJuZWQgZnJvbSBzdHlsZSBmdW5jdGlvbiBmb3IgJHtjb21wb25lbnQuY29tcG9uZW50TmFtZX06JHtzdHlsZU5hbWV9LiBEaWQgeW91IGZvcmdldCB0byByZXR1cm4gdGhlIGNvbnN0cnVjdGVkIHN0eWxlP2ApO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBkZWZpbmVDb21wb25lbnRTdHlsZShjb21wb25lbnQuY29tcG9uZW50TmFtZSwgc3R5bGVOYW1lLCBzdHlsZURlZik7XHJcbiAgICB9XHJcblxyXG4gICAgc3R5bGVkQ29tcG9uZW50ID0gcHJvcHMgPT4gPENvbXBvbmVudCB7Li4ucHJvcHN9IHN0eWxlTmFtZT17c3R5bGVOYW1lfSAvPjtcclxuICAgIHN0eWxlZENvbXBvbmVudC5wYXJlbnRJbmZvID0gY29tcG9uZW50O1xyXG4gICAgY29tcG9uZW50W3Byb3BTdHlsZU5hbWUoc3R5bGVOYW1lKV0gPSBzdHlsZWRDb21wb25lbnQ7XHJcbn07XHJcblxyXG5jb25zdCBjcmVhdGVTdHlsZXMgPSAoKSA9PiB7XHJcbiAgICBjb25zdCBoZWFkID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcImhlYWRcIik7XHJcblxyXG4gICAgLy8gIEl0ZXJhdGUgb3ZlciB0aGUgY29tcG9uZW50cyB0aGF0IGhhdmUgc3R5bGVzIGRlZmluZWRcclxuICAgIGZvciAoY29uc3QgW2NvbXBvbmVudE5hbWUsIHN0eWxlc10gb2YgT2JqZWN0LmVudHJpZXMoY29tcG9uZW50U3R5bGVzKSkge1xyXG4gICAgICAgIC8vICBJdGVyYXRlIG92ZXIgdGhlIHZhcmlvdXMgbmFtZWQgc3R5bGVzIGZvciB0aGUgZ2l2ZW4gY29tcG9uZW50XHJcbiAgICAgICAgZm9yIChjb25zdCBbc3R5bGVOYW1lLCBzdHlsZURlZnNdIG9mIE9iamVjdC5lbnRyaWVzKHN0eWxlcykpIHtcclxuICAgICAgICAgICAgbGV0IGNzc0xpbmVzID0gW107XHJcbiAgICAgICAgICAgIC8vICBHcmFiIGFsbCB0aGUgaW5kaXZpZHVhbCBncm91cHMgb2Ygc3R5bGVzIGRlZmluZWQgaW4gdGhlIG5hbWVkIHN0eWxlXHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2Rlc2NyaXB0b3IsIGRlZnNdIG9mIE9iamVjdC5lbnRyaWVzKHN0eWxlRGVmcykpIHtcclxuICAgICAgICAgICAgICAgIGlmIChkZXNjcmlwdG9yLnN0YXJ0c1dpdGgoXCIhXCIpID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gIFJlcGVhdCBhbiBleHRyYSB0aW1lIHdpdGggcHJlZml4ZWQga2V5ZnJhbWVzIGJlY2F1c2UgaW9zIDwgOSBpcyBwcmV0dHkgYXdmdWxcclxuICAgICAgICAgICAgICAgICAgICBjc3NMaW5lcy5wdXNoKGBALXdlYmtpdC1rZXlmcmFtZXMgJHtjb21wb25lbnROYW1lfS0ke3N0eWxlTmFtZX0tYW5pbWF0aW9uLSR7ZGVzY3JpcHRvci5zbGljZSgxKX0ge2ApO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW3NlbGVjdG9yLCBkZWZdIG9mIE9iamVjdC5lbnRyaWVzKGRlZnMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNzc0xpbmVzID0gcHJvY2Vzc0RlZihjc3NMaW5lcywgc2VsZWN0b3IsIGRlZik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNzc0xpbmVzLnB1c2goXCJ9XCIpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyAgbm9ybWFsIEBrZXlmcmFtZXMgY3NzXHJcbiAgICAgICAgICAgICAgICAgICAgY3NzTGluZXMucHVzaChgQGtleWZyYW1lcyAke2NvbXBvbmVudE5hbWV9LSR7c3R5bGVOYW1lfS1hbmltYXRpb24tJHtkZXNjcmlwdG9yLnNsaWNlKDEpfSB7YCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBbc2VsZWN0b3IsIGRlZl0gb2YgT2JqZWN0LmVudHJpZXMoZGVmcykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3NzTGluZXMgPSBwcm9jZXNzRGVmKGNzc0xpbmVzLCBzZWxlY3RvciwgZGVmKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY3NzTGluZXMucHVzaChcIn1cIik7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlbGVjdG9yID0gcHJvY2Vzc1NlbGVjdG9yKGNvbXBvbmVudE5hbWUsIHN0eWxlTmFtZSwgZGVzY3JpcHRvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgY3NzTGluZXMgPSBwcm9jZXNzRGVmKGNzc0xpbmVzLCBzZWxlY3RvciwgZGVmcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3Qgc3R5bGVUYWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XHJcbiAgICAgICAgICAgIHN0eWxlVGFnLnNldEF0dHJpYnV0ZShcInR5cGVcIiwgXCJ0ZXh0L2Nzc1wiKTtcclxuICAgICAgICAgICAgc3R5bGVUYWcuc2V0QXR0cmlidXRlKFwiZGF0YS1uYW1lXCIsIGAke2NvbXBvbmVudE5hbWV9LyR7c3R5bGVOYW1lfWApO1xyXG4gICAgICAgICAgICBzdHlsZVRhZy5pbm5lckhUTUwgPSBjc3NMaW5lcy5qb2luKCdcXG4nKTtcclxuICAgICAgICAgICAgaGVhZC5hcHBlbmRDaGlsZChzdHlsZVRhZyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxubGV0IHRoZW1lVmFsdWVzO1xyXG5jb25zdCBUaGVtZSA9IHtcclxuICAgIGRlZmluZSh0aGVtZSkge1xyXG4gICAgICAgIHRoZW1lVmFsdWVzID0gdGhlbWU7XHJcbiAgICB9LFxyXG4gICAgZ2V0IHZhcmlhYmxlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGVtZVZhbHVlcztcclxuICAgIH1cclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIGRlZmluZUNvbXBvbmVudFN0eWxlLFxyXG4gICAgZGVmaW5lQ3VzdG9tQmFzZSxcclxuICAgIGRlZmluZVN0eWxlRm9yQ29tcG9uZW50LFxyXG4gICAgZ2VuRm9udENTUyhuYW1lLCBkYXRhVVJJKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZm9udEZhbWlseTogYFwiJHtuYW1lfVwiYCxcclxuICAgICAgICAgICAgc3JjOiBgdXJsKFwiJHtkYXRhVVJJfVwiKWAsXHJcbiAgICAgICAgICAgIGZvbnRXZWlnaHQ6IFwibm9ybWFsXCIsXHJcbiAgICAgICAgICAgIGZvbnRTdHlsZTogXCJub3JtYWxcIlxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBUaGVtZSxcclxuICAgIF9fc2V0dXA6IGNyZWF0ZVN0eWxlc1xyXG59O1xyXG4iLCJjb25zdCB3YXJuaW5nRnVuYyA9IGVycm9yTWVzc2FnZSA9PlxyXG4gICAgKCkgPT4gY29uc29sZS53YXJuKGVycm9yTWVzc2FnZSk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgICB3YXJuaW5nRnVuYyxcclxuICAgIHRyYW5zZmVyUHJvcHMoc291cmNlcykge1xyXG4gICAgICAgIGNvbnN0IGRlc3QgPSB7fTtcclxuXHJcbiAgICAgICAgZm9yIChjb25zdCBbZGVzdE5hbWUsIHNvdXJjZV0gb2YgT2JqZWN0LmVudHJpZXMoc291cmNlcykpIHtcclxuICAgICAgICAgICAgLy8gZGVidWdnZXI7XHJcbiAgICAgICAgICAgIGNvbnN0IFtzb3VyY2VPYmosIHByb3BzXSA9IHNvdXJjZTtcclxuICAgICAgICAgICAgY29uc3QgY29weSA9IHt9O1xyXG5cclxuICAgICAgICAgICAgaWYgKHNvdXJjZU9iaiAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBbc291cmNlUHJvcCwgZGVzdFByb3BdIG9mIE9iamVjdC5lbnRyaWVzKHByb3BzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2VPYmpbc291cmNlUHJvcF0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3B5W2Rlc3RQcm9wXSA9IHNvdXJjZU9ialtzb3VyY2VQcm9wXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKGNvcHkpLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBkZXN0W2Rlc3ROYW1lXSA9IGNvcHk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBkZXN0O1xyXG4gICAgfVxyXG59O1xyXG4iLCJpbXBvcnQgXCJleHRlcm5hbC96aXAuanNcIjtcclxuaW1wb3J0IFwiZXh0ZXJuYWwvemlwLWV4dC5qc1wiO1xyXG5cclxuaW1wb3J0IGRlZmxhdGVTb3VyY2UgZnJvbSBcImV4dGVybmFsL2RlZmxhdGUuanMuc291cmNlXCI7XHJcbmltcG9ydCBpbmZsYXRlU291cmNlIGZyb20gXCJleHRlcm5hbC9pbmZsYXRlLmpzLnNvdXJjZVwiO1xyXG5pbXBvcnQgd29ya2VyU291cmNlIGZyb20gXCJleHRlcm5hbC96LXdvcmtlci5qcy5zb3VyY2VcIjtcclxuXHJcbmNvbnN0IGNyZWF0ZVVSTCA9IHNvdXJjZSA9PiB7XHJcbiAgICBjb25zdCBibG9iID0gbmV3IEJsb2IoW3NvdXJjZV0sIHt0eXBlOiBcImFwcGxpY2F0aW9uL2phdmFzY3JpcHRcIn0pO1xyXG4gICAgcmV0dXJuIFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XHJcbn07XHJcblxyXG5jb25zdCB3b3JrZXJVUkwgPSBjcmVhdGVVUkwod29ya2VyU291cmNlKTtcclxuY29uc3QgaW5mbGF0ZVVSTCA9IGNyZWF0ZVVSTChpbmZsYXRlU291cmNlKTtcclxuY29uc3QgZGVmbGF0ZVVSTCA9IGNyZWF0ZVVSTChkZWZsYXRlU291cmNlKTtcclxuXHJcbnppcC53b3JrZXJTY3JpcHRzID0ge1xyXG4gICAgaW5mbGF0ZXI6IFt3b3JrZXJVUkwsIGluZmxhdGVVUkxdLFxyXG4gICAgZGVmbGF0ZXI6IFt3b3JrZXJVUkwsIGRlZmxhdGVVUkxdXHJcbn07XHJcblxyXG5jb25zdCB6aXBMaWIgPSB6aXA7XHJcblxyXG53aW5kb3cuemlwID0gbnVsbDtcclxuXHJcbmNvbnN0IHJlYWRFbnRyeSA9IChlbnRyeSwgd3JpdGVyKSA9PiBuZXcgUHJvbWlzZShcclxuICAgIHJlc29sdmUgPT4gZW50cnkuZ2V0RGF0YSh3cml0ZXIsIHJlc29sdmUpXHJcbik7XHJcbmNvbnN0IHppcEVudHJ5ID0gZW50cnkgPT4ge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByZWFkVGV4dCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlYWRFbnRyeShlbnRyeSwgbmV3IHppcExpYi5UZXh0V3JpdGVyKCkpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVhZEJsb2IoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZWFkRW50cnkoZW50cnksIG5ldyB6aXBMaWIuQmxvYldyaXRlcigpKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldCBlbnRyeSgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGVudHJ5O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn07XHJcblxyXG5jb25zdCByZWFkQXJyYXlCdWZmZXIgPSBidWZmZXIgPT4gbmV3IFByb21pc2UoXHJcbiAgICAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgemlwTGliLmNyZWF0ZVJlYWRlcihcclxuICAgICAgICAgICAgbmV3IHppcExpYi5BcnJheUJ1ZmZlclJlYWRlcihidWZmZXIpLFxyXG4gICAgICAgICAgICByZWFkZXIgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmVhZGVyLmdldEVudHJpZXMoZW50cmllcyA9PiByZXNvbHZlKFtlbnRyaWVzLCByZWFkZXJdKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICApO1xyXG4gICAgfVxyXG4pO1xyXG5jb25zdCBkb3dubG9hZCA9IGFzeW5jICh1cmwsIG9uUHJvZ3Jlc3MpID0+IHtcclxuICAgIGNvbnN0IGJ1ZmZlciA9IGF3YWl0IGZhY3RvdHVtLmFqYXgodXJsLCB7dHlwZTogJ2FycmF5YnVmZmVyJywgb25Qcm9ncmVzc30pO1xyXG4gICAgcmV0dXJuIGF3YWl0IHJlYWRBcnJheUJ1ZmZlcihidWZmZXIucmVzcG9uc2UpO1xyXG59O1xyXG5cclxuY29uc3QgemlwRmlsZSA9IChbZW50cmllcywgcmVhZGVyXSkgPT4ge1xyXG4gICAgY29uc3QgZW50cnlTb3J0ID0gKGZpcnN0LCBzZWNvbmQpID0+IHtcclxuICAgICAgICBpZiAoZmlyc3QuZmlsZW5hbWUgPCBzZWNvbmQuZmlsZW5hbWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZmlyc3QuZmlsZW5hbWUgPiBzZWNvbmQuZmlsZW5hbWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IGZpbGVzID0gZW50cmllcy5zb3J0KGVudHJ5U29ydCkucmVkdWNlKFxyXG4gICAgICAgIChjb2xsZWN0aW9uLCBlbnRyeSkgPT4ge1xyXG4gICAgICAgICAgICBjb2xsZWN0aW9uW2VudHJ5LmZpbGVuYW1lXSA9IGVudHJ5O1xyXG4gICAgICAgICAgICByZXR1cm4gY29sbGVjdGlvbjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHt9XHJcbiAgICApO1xyXG4gICAgZW50cmllcyA9IGVudHJpZXMuc29ydChlbnRyeVNvcnQpO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZ2V0RmlsZShuYW1lKSB7XHJcbiAgICAgICAgICAgIGlmIChmaWxlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHppcEVudHJ5KGZpbGVzW25hbWVdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldEVudHJpZXMoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBlbnRyaWVzLm1hcCh6aXBFbnRyeSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBhc3luYyBleHRyYWN0VG8oZGVzdCwgb25Qcm9ncmVzcyA9ICgpID0+IHt9KSB7XHJcbiAgICAgICAgICAgIGxldCBpbmRleDtcclxuXHJcbiAgICAgICAgICAgIGluZGV4ID0gMDtcclxuICAgICAgICAgICAgZm9yKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHtmaWxlbmFtZX0gPSBlbnRyeTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZW50cnkuZGlyZWN0b3J5ID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgZnMuZGlyQ3JlYXRlKGAke2Rlc3R9JHtmaWxlbmFtZX1gKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgZnMuZmlsZVdyaXRlKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBgJHtkZXN0fSR7ZmlsZW5hbWV9YCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgemlwRW50cnkoZW50cnkpLnJlYWRCbG9iKClcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaW5kZXggKz0gMTtcclxuICAgICAgICAgICAgICAgIG9uUHJvZ3Jlc3Moe1xyXG4gICAgICAgICAgICAgICAgICAgIGV4dHJhY3RlZDogaW5kZXgsXHJcbiAgICAgICAgICAgICAgICAgICAgdG90YWw6IGVudHJpZXMubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRGaWxlOiB6aXBFbnRyeShlbnRyeSksXHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dEZpbGU6IChpbmRleCA8IGVudHJpZXMubGVuZ3RoKSA/IHppcEVudHJ5KGVudHJpZXNbaW5kZXhdKSA6IG51bGxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY2xvc2UoKSB7XHJcbiAgICAgICAgICAgIHJlYWRlci5jbG9zZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgICBhc3luYyBkb3dubG9hZCh1cmwsIG9uUHJvZ3Jlc3MpIHtcclxuICAgICAgICBjb25zdCB6aXBJbmZvID0gYXdhaXQgZG93bmxvYWQodXJsLCBvblByb2dyZXNzKTtcclxuICAgICAgICByZXR1cm4gemlwRmlsZSh6aXBJbmZvKTtcclxuICAgIH1cclxufTtcclxuIiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL2FycmF5L2Zyb21cIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vZ2V0LWl0ZXJhdG9yXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9hc3NpZ25cIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2NyZWF0ZVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZGVmaW5lLXByb3BlcnRpZXNcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2VudHJpZXNcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2ZyZWV6ZVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3Qva2V5c1wiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZlwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9wcm9taXNlXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL3NldFwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9zeW1ib2xcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBmdW5jdGlvbiAoaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufTtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9PYmplY3QkYXNzaWduID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvYXNzaWduXCIpW1wiZGVmYXVsdFwiXTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBfT2JqZWN0JGFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfT2JqZWN0JGNyZWF0ZSA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2NyZWF0ZVwiKVtcImRlZmF1bHRcIl07XG5cbnZhciBfT2JqZWN0JHNldFByb3RvdHlwZU9mID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZlwiKVtcImRlZmF1bHRcIl07XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gZnVuY3Rpb24gKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IF9PYmplY3QkY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBfT2JqZWN0JHNldFByb3RvdHlwZU9mID8gX09iamVjdCRzZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xufTtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgXCJkZWZhdWx0XCI6IG9ialxuICB9O1xufTtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBmdW5jdGlvbiAob2JqLCBrZXlzKSB7XG4gIHZhciB0YXJnZXQgPSB7fTtcblxuICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgIGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7XG4gICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpKSkgY29udGludWU7XG4gICAgdGFyZ2V0W2ldID0gb2JqW2ldO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5hcnJheS5mcm9tJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvJC5jb3JlJykuQXJyYXkuZnJvbTsiLCJyZXF1aXJlKCcuLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9tb2R1bGVzL2NvcmUuZ2V0LWl0ZXJhdG9yJyk7IiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzLyQuY29yZScpLk9iamVjdC5hc3NpZ247IiwidmFyICQgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzLyQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlKFAsIEQpe1xuICByZXR1cm4gJC5jcmVhdGUoUCwgRCk7XG59OyIsInZhciAkID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy8kJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoVCwgRCl7XG4gIHJldHVybiAkLnNldERlc2NzKFQsIEQpO1xufTsiLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNy5vYmplY3QuZW50cmllcycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzLyQuY29yZScpLk9iamVjdC5lbnRyaWVzOyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5mcmVlemUnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy8kLmNvcmUnKS5PYmplY3QuZnJlZXplOyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5rZXlzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvJC5jb3JlJykuT2JqZWN0LmtleXM7IiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LnNldC1wcm90b3R5cGUtb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy8kLmNvcmUnKS5PYmplY3Quc2V0UHJvdG90eXBlT2Y7IiwicmVxdWlyZSgnLi4vbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZycpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnByb21pc2UnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vbW9kdWxlcy8kLmNvcmUnKS5Qcm9taXNlOyIsInJlcXVpcmUoJy4uL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5zZXQnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM3LnNldC50by1qc29uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL21vZHVsZXMvJC5jb3JlJykuU2V0OyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2LnN5bWJvbCcpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzLyQuY29yZScpLlN5bWJvbDsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYodHlwZW9mIGl0ICE9ICdmdW5jdGlvbicpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSBmdW5jdGlvbiEnKTtcbiAgcmV0dXJuIGl0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCl7IC8qIGVtcHR5ICovIH07IiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi8kLmlzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIGlmKCFpc09iamVjdChpdCkpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYW4gb2JqZWN0IScpO1xuICByZXR1cm4gaXQ7XG59OyIsIi8vIGdldHRpbmcgdGFnIGZyb20gMTkuMS4zLjYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZygpXG52YXIgY29mID0gcmVxdWlyZSgnLi8kLmNvZicpXG4gICwgVEFHID0gcmVxdWlyZSgnLi8kLndrcycpKCd0b1N0cmluZ1RhZycpXG4gIC8vIEVTMyB3cm9uZyBoZXJlXG4gICwgQVJHID0gY29mKGZ1bmN0aW9uKCl7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPT0gJ0FyZ3VtZW50cyc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICB2YXIgTywgVCwgQjtcbiAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgPyAnVW5kZWZpbmVkJyA6IGl0ID09PSBudWxsID8gJ051bGwnXG4gICAgLy8gQEB0b1N0cmluZ1RhZyBjYXNlXG4gICAgOiB0eXBlb2YgKFQgPSAoTyA9IE9iamVjdChpdCkpW1RBR10pID09ICdzdHJpbmcnID8gVFxuICAgIC8vIGJ1aWx0aW5UYWcgY2FzZVxuICAgIDogQVJHID8gY29mKE8pXG4gICAgLy8gRVMzIGFyZ3VtZW50cyBmYWxsYmFja1xuICAgIDogKEIgPSBjb2YoTykpID09ICdPYmplY3QnICYmIHR5cGVvZiBPLmNhbGxlZSA9PSAnZnVuY3Rpb24nID8gJ0FyZ3VtZW50cycgOiBCO1xufTsiLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGl0KS5zbGljZSg4LCAtMSk7XG59OyIsIid1c2Ugc3RyaWN0JztcbnZhciAkICAgICAgICAgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsIGhpZGUgICAgICAgICA9IHJlcXVpcmUoJy4vJC5oaWRlJylcbiAgLCByZWRlZmluZUFsbCAgPSByZXF1aXJlKCcuLyQucmVkZWZpbmUtYWxsJylcbiAgLCBjdHggICAgICAgICAgPSByZXF1aXJlKCcuLyQuY3R4JylcbiAgLCBzdHJpY3ROZXcgICAgPSByZXF1aXJlKCcuLyQuc3RyaWN0LW5ldycpXG4gICwgZGVmaW5lZCAgICAgID0gcmVxdWlyZSgnLi8kLmRlZmluZWQnKVxuICAsIGZvck9mICAgICAgICA9IHJlcXVpcmUoJy4vJC5mb3Itb2YnKVxuICAsICRpdGVyRGVmaW5lICA9IHJlcXVpcmUoJy4vJC5pdGVyLWRlZmluZScpXG4gICwgc3RlcCAgICAgICAgID0gcmVxdWlyZSgnLi8kLml0ZXItc3RlcCcpXG4gICwgSUQgICAgICAgICAgID0gcmVxdWlyZSgnLi8kLnVpZCcpKCdpZCcpXG4gICwgJGhhcyAgICAgICAgID0gcmVxdWlyZSgnLi8kLmhhcycpXG4gICwgaXNPYmplY3QgICAgID0gcmVxdWlyZSgnLi8kLmlzLW9iamVjdCcpXG4gICwgc2V0U3BlY2llcyAgID0gcmVxdWlyZSgnLi8kLnNldC1zcGVjaWVzJylcbiAgLCBERVNDUklQVE9SUyAgPSByZXF1aXJlKCcuLyQuZGVzY3JpcHRvcnMnKVxuICAsIGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGUgfHwgaXNPYmplY3RcbiAgLCBTSVpFICAgICAgICAgPSBERVNDUklQVE9SUyA/ICdfcycgOiAnc2l6ZSdcbiAgLCBpZCAgICAgICAgICAgPSAwO1xuXG52YXIgZmFzdEtleSA9IGZ1bmN0aW9uKGl0LCBjcmVhdGUpe1xuICAvLyByZXR1cm4gcHJpbWl0aXZlIHdpdGggcHJlZml4XG4gIGlmKCFpc09iamVjdChpdCkpcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJyA/IGl0IDogKHR5cGVvZiBpdCA9PSAnc3RyaW5nJyA/ICdTJyA6ICdQJykgKyBpdDtcbiAgaWYoISRoYXMoaXQsIElEKSl7XG4gICAgLy8gY2FuJ3Qgc2V0IGlkIHRvIGZyb3plbiBvYmplY3RcbiAgICBpZighaXNFeHRlbnNpYmxlKGl0KSlyZXR1cm4gJ0YnO1xuICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIGlkXG4gICAgaWYoIWNyZWF0ZSlyZXR1cm4gJ0UnO1xuICAgIC8vIGFkZCBtaXNzaW5nIG9iamVjdCBpZFxuICAgIGhpZGUoaXQsIElELCArK2lkKTtcbiAgLy8gcmV0dXJuIG9iamVjdCBpZCB3aXRoIHByZWZpeFxuICB9IHJldHVybiAnTycgKyBpdFtJRF07XG59O1xuXG52YXIgZ2V0RW50cnkgPSBmdW5jdGlvbih0aGF0LCBrZXkpe1xuICAvLyBmYXN0IGNhc2VcbiAgdmFyIGluZGV4ID0gZmFzdEtleShrZXkpLCBlbnRyeTtcbiAgaWYoaW5kZXggIT09ICdGJylyZXR1cm4gdGhhdC5faVtpbmRleF07XG4gIC8vIGZyb3plbiBvYmplY3QgY2FzZVxuICBmb3IoZW50cnkgPSB0aGF0Ll9mOyBlbnRyeTsgZW50cnkgPSBlbnRyeS5uKXtcbiAgICBpZihlbnRyeS5rID09IGtleSlyZXR1cm4gZW50cnk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRDb25zdHJ1Y3RvcjogZnVuY3Rpb24od3JhcHBlciwgTkFNRSwgSVNfTUFQLCBBRERFUil7XG4gICAgdmFyIEMgPSB3cmFwcGVyKGZ1bmN0aW9uKHRoYXQsIGl0ZXJhYmxlKXtcbiAgICAgIHN0cmljdE5ldyh0aGF0LCBDLCBOQU1FKTtcbiAgICAgIHRoYXQuX2kgPSAkLmNyZWF0ZShudWxsKTsgLy8gaW5kZXhcbiAgICAgIHRoYXQuX2YgPSB1bmRlZmluZWQ7ICAgICAgLy8gZmlyc3QgZW50cnlcbiAgICAgIHRoYXQuX2wgPSB1bmRlZmluZWQ7ICAgICAgLy8gbGFzdCBlbnRyeVxuICAgICAgdGhhdFtTSVpFXSA9IDA7ICAgICAgICAgICAvLyBzaXplXG4gICAgICBpZihpdGVyYWJsZSAhPSB1bmRlZmluZWQpZm9yT2YoaXRlcmFibGUsIElTX01BUCwgdGhhdFtBRERFUl0sIHRoYXQpO1xuICAgIH0pO1xuICAgIHJlZGVmaW5lQWxsKEMucHJvdG90eXBlLCB7XG4gICAgICAvLyAyMy4xLjMuMSBNYXAucHJvdG90eXBlLmNsZWFyKClcbiAgICAgIC8vIDIzLjIuMy4yIFNldC5wcm90b3R5cGUuY2xlYXIoKVxuICAgICAgY2xlYXI6IGZ1bmN0aW9uIGNsZWFyKCl7XG4gICAgICAgIGZvcih2YXIgdGhhdCA9IHRoaXMsIGRhdGEgPSB0aGF0Ll9pLCBlbnRyeSA9IHRoYXQuX2Y7IGVudHJ5OyBlbnRyeSA9IGVudHJ5Lm4pe1xuICAgICAgICAgIGVudHJ5LnIgPSB0cnVlO1xuICAgICAgICAgIGlmKGVudHJ5LnApZW50cnkucCA9IGVudHJ5LnAubiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBkZWxldGUgZGF0YVtlbnRyeS5pXTtcbiAgICAgICAgfVxuICAgICAgICB0aGF0Ll9mID0gdGhhdC5fbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhhdFtTSVpFXSA9IDA7XG4gICAgICB9LFxuICAgICAgLy8gMjMuMS4zLjMgTWFwLnByb3RvdHlwZS5kZWxldGUoa2V5KVxuICAgICAgLy8gMjMuMi4zLjQgU2V0LnByb3RvdHlwZS5kZWxldGUodmFsdWUpXG4gICAgICAnZGVsZXRlJzogZnVuY3Rpb24oa2V5KXtcbiAgICAgICAgdmFyIHRoYXQgID0gdGhpc1xuICAgICAgICAgICwgZW50cnkgPSBnZXRFbnRyeSh0aGF0LCBrZXkpO1xuICAgICAgICBpZihlbnRyeSl7XG4gICAgICAgICAgdmFyIG5leHQgPSBlbnRyeS5uXG4gICAgICAgICAgICAsIHByZXYgPSBlbnRyeS5wO1xuICAgICAgICAgIGRlbGV0ZSB0aGF0Ll9pW2VudHJ5LmldO1xuICAgICAgICAgIGVudHJ5LnIgPSB0cnVlO1xuICAgICAgICAgIGlmKHByZXYpcHJldi5uID0gbmV4dDtcbiAgICAgICAgICBpZihuZXh0KW5leHQucCA9IHByZXY7XG4gICAgICAgICAgaWYodGhhdC5fZiA9PSBlbnRyeSl0aGF0Ll9mID0gbmV4dDtcbiAgICAgICAgICBpZih0aGF0Ll9sID09IGVudHJ5KXRoYXQuX2wgPSBwcmV2O1xuICAgICAgICAgIHRoYXRbU0laRV0tLTtcbiAgICAgICAgfSByZXR1cm4gISFlbnRyeTtcbiAgICAgIH0sXG4gICAgICAvLyAyMy4yLjMuNiBTZXQucHJvdG90eXBlLmZvckVhY2goY2FsbGJhY2tmbiwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgICAgIC8vIDIzLjEuMy41IE1hcC5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxuICAgICAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFja2ZuIC8qLCB0aGF0ID0gdW5kZWZpbmVkICovKXtcbiAgICAgICAgdmFyIGYgPSBjdHgoY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIDMpXG4gICAgICAgICAgLCBlbnRyeTtcbiAgICAgICAgd2hpbGUoZW50cnkgPSBlbnRyeSA/IGVudHJ5Lm4gOiB0aGlzLl9mKXtcbiAgICAgICAgICBmKGVudHJ5LnYsIGVudHJ5LmssIHRoaXMpO1xuICAgICAgICAgIC8vIHJldmVydCB0byB0aGUgbGFzdCBleGlzdGluZyBlbnRyeVxuICAgICAgICAgIHdoaWxlKGVudHJ5ICYmIGVudHJ5LnIpZW50cnkgPSBlbnRyeS5wO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gMjMuMS4zLjcgTWFwLnByb3RvdHlwZS5oYXMoa2V5KVxuICAgICAgLy8gMjMuMi4zLjcgU2V0LnByb3RvdHlwZS5oYXModmFsdWUpXG4gICAgICBoYXM6IGZ1bmN0aW9uIGhhcyhrZXkpe1xuICAgICAgICByZXR1cm4gISFnZXRFbnRyeSh0aGlzLCBrZXkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmKERFU0NSSVBUT1JTKSQuc2V0RGVzYyhDLnByb3RvdHlwZSwgJ3NpemUnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiBkZWZpbmVkKHRoaXNbU0laRV0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBDO1xuICB9LFxuICBkZWY6IGZ1bmN0aW9uKHRoYXQsIGtleSwgdmFsdWUpe1xuICAgIHZhciBlbnRyeSA9IGdldEVudHJ5KHRoYXQsIGtleSlcbiAgICAgICwgcHJldiwgaW5kZXg7XG4gICAgLy8gY2hhbmdlIGV4aXN0aW5nIGVudHJ5XG4gICAgaWYoZW50cnkpe1xuICAgICAgZW50cnkudiA9IHZhbHVlO1xuICAgIC8vIGNyZWF0ZSBuZXcgZW50cnlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhhdC5fbCA9IGVudHJ5ID0ge1xuICAgICAgICBpOiBpbmRleCA9IGZhc3RLZXkoa2V5LCB0cnVlKSwgLy8gPC0gaW5kZXhcbiAgICAgICAgazoga2V5LCAgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIGtleVxuICAgICAgICB2OiB2YWx1ZSwgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gdmFsdWVcbiAgICAgICAgcDogcHJldiA9IHRoYXQuX2wsICAgICAgICAgICAgIC8vIDwtIHByZXZpb3VzIGVudHJ5XG4gICAgICAgIG46IHVuZGVmaW5lZCwgICAgICAgICAgICAgICAgICAvLyA8LSBuZXh0IGVudHJ5XG4gICAgICAgIHI6IGZhbHNlICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSByZW1vdmVkXG4gICAgICB9O1xuICAgICAgaWYoIXRoYXQuX2YpdGhhdC5fZiA9IGVudHJ5O1xuICAgICAgaWYocHJldilwcmV2Lm4gPSBlbnRyeTtcbiAgICAgIHRoYXRbU0laRV0rKztcbiAgICAgIC8vIGFkZCB0byBpbmRleFxuICAgICAgaWYoaW5kZXggIT09ICdGJyl0aGF0Ll9pW2luZGV4XSA9IGVudHJ5O1xuICAgIH0gcmV0dXJuIHRoYXQ7XG4gIH0sXG4gIGdldEVudHJ5OiBnZXRFbnRyeSxcbiAgc2V0U3Ryb25nOiBmdW5jdGlvbihDLCBOQU1FLCBJU19NQVApe1xuICAgIC8vIGFkZCAua2V5cywgLnZhbHVlcywgLmVudHJpZXMsIFtAQGl0ZXJhdG9yXVxuICAgIC8vIDIzLjEuMy40LCAyMy4xLjMuOCwgMjMuMS4zLjExLCAyMy4xLjMuMTIsIDIzLjIuMy41LCAyMy4yLjMuOCwgMjMuMi4zLjEwLCAyMy4yLjMuMTFcbiAgICAkaXRlckRlZmluZShDLCBOQU1FLCBmdW5jdGlvbihpdGVyYXRlZCwga2luZCl7XG4gICAgICB0aGlzLl90ID0gaXRlcmF0ZWQ7ICAvLyB0YXJnZXRcbiAgICAgIHRoaXMuX2sgPSBraW5kOyAgICAgIC8vIGtpbmRcbiAgICAgIHRoaXMuX2wgPSB1bmRlZmluZWQ7IC8vIHByZXZpb3VzXG4gICAgfSwgZnVuY3Rpb24oKXtcbiAgICAgIHZhciB0aGF0ICA9IHRoaXNcbiAgICAgICAgLCBraW5kICA9IHRoYXQuX2tcbiAgICAgICAgLCBlbnRyeSA9IHRoYXQuX2w7XG4gICAgICAvLyByZXZlcnQgdG8gdGhlIGxhc3QgZXhpc3RpbmcgZW50cnlcbiAgICAgIHdoaWxlKGVudHJ5ICYmIGVudHJ5LnIpZW50cnkgPSBlbnRyeS5wO1xuICAgICAgLy8gZ2V0IG5leHQgZW50cnlcbiAgICAgIGlmKCF0aGF0Ll90IHx8ICEodGhhdC5fbCA9IGVudHJ5ID0gZW50cnkgPyBlbnRyeS5uIDogdGhhdC5fdC5fZikpe1xuICAgICAgICAvLyBvciBmaW5pc2ggdGhlIGl0ZXJhdGlvblxuICAgICAgICB0aGF0Ll90ID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gc3RlcCgxKTtcbiAgICAgIH1cbiAgICAgIC8vIHJldHVybiBzdGVwIGJ5IGtpbmRcbiAgICAgIGlmKGtpbmQgPT0gJ2tleXMnICApcmV0dXJuIHN0ZXAoMCwgZW50cnkuayk7XG4gICAgICBpZihraW5kID09ICd2YWx1ZXMnKXJldHVybiBzdGVwKDAsIGVudHJ5LnYpO1xuICAgICAgcmV0dXJuIHN0ZXAoMCwgW2VudHJ5LmssIGVudHJ5LnZdKTtcbiAgICB9LCBJU19NQVAgPyAnZW50cmllcycgOiAndmFsdWVzJyAsICFJU19NQVAsIHRydWUpO1xuXG4gICAgLy8gYWRkIFtAQHNwZWNpZXNdLCAyMy4xLjIuMiwgMjMuMi4yLjJcbiAgICBzZXRTcGVjaWVzKE5BTUUpO1xuICB9XG59OyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXZpZEJydWFudC9NYXAtU2V0LnByb3RvdHlwZS50b0pTT05cbnZhciBmb3JPZiAgID0gcmVxdWlyZSgnLi8kLmZvci1vZicpXG4gICwgY2xhc3NvZiA9IHJlcXVpcmUoJy4vJC5jbGFzc29mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKE5BTUUpe1xuICByZXR1cm4gZnVuY3Rpb24gdG9KU09OKCl7XG4gICAgaWYoY2xhc3NvZih0aGlzKSAhPSBOQU1FKXRocm93IFR5cGVFcnJvcihOQU1FICsgXCIjdG9KU09OIGlzbid0IGdlbmVyaWNcIik7XG4gICAgdmFyIGFyciA9IFtdO1xuICAgIGZvck9mKHRoaXMsIGZhbHNlLCBhcnIucHVzaCwgYXJyKTtcbiAgICByZXR1cm4gYXJyO1xuICB9O1xufTsiLCIndXNlIHN0cmljdCc7XG52YXIgJCAgICAgICAgICAgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsIGdsb2JhbCAgICAgICAgID0gcmVxdWlyZSgnLi8kLmdsb2JhbCcpXG4gICwgJGV4cG9ydCAgICAgICAgPSByZXF1aXJlKCcuLyQuZXhwb3J0JylcbiAgLCBmYWlscyAgICAgICAgICA9IHJlcXVpcmUoJy4vJC5mYWlscycpXG4gICwgaGlkZSAgICAgICAgICAgPSByZXF1aXJlKCcuLyQuaGlkZScpXG4gICwgcmVkZWZpbmVBbGwgICAgPSByZXF1aXJlKCcuLyQucmVkZWZpbmUtYWxsJylcbiAgLCBmb3JPZiAgICAgICAgICA9IHJlcXVpcmUoJy4vJC5mb3Itb2YnKVxuICAsIHN0cmljdE5ldyAgICAgID0gcmVxdWlyZSgnLi8kLnN0cmljdC1uZXcnKVxuICAsIGlzT2JqZWN0ICAgICAgID0gcmVxdWlyZSgnLi8kLmlzLW9iamVjdCcpXG4gICwgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuLyQuc2V0LXRvLXN0cmluZy10YWcnKVxuICAsIERFU0NSSVBUT1JTICAgID0gcmVxdWlyZSgnLi8kLmRlc2NyaXB0b3JzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oTkFNRSwgd3JhcHBlciwgbWV0aG9kcywgY29tbW9uLCBJU19NQVAsIElTX1dFQUspe1xuICB2YXIgQmFzZSAgPSBnbG9iYWxbTkFNRV1cbiAgICAsIEMgICAgID0gQmFzZVxuICAgICwgQURERVIgPSBJU19NQVAgPyAnc2V0JyA6ICdhZGQnXG4gICAgLCBwcm90byA9IEMgJiYgQy5wcm90b3R5cGVcbiAgICAsIE8gICAgID0ge307XG4gIGlmKCFERVNDUklQVE9SUyB8fCB0eXBlb2YgQyAhPSAnZnVuY3Rpb24nIHx8ICEoSVNfV0VBSyB8fCBwcm90by5mb3JFYWNoICYmICFmYWlscyhmdW5jdGlvbigpe1xuICAgIG5ldyBDKCkuZW50cmllcygpLm5leHQoKTtcbiAgfSkpKXtcbiAgICAvLyBjcmVhdGUgY29sbGVjdGlvbiBjb25zdHJ1Y3RvclxuICAgIEMgPSBjb21tb24uZ2V0Q29uc3RydWN0b3Iod3JhcHBlciwgTkFNRSwgSVNfTUFQLCBBRERFUik7XG4gICAgcmVkZWZpbmVBbGwoQy5wcm90b3R5cGUsIG1ldGhvZHMpO1xuICB9IGVsc2Uge1xuICAgIEMgPSB3cmFwcGVyKGZ1bmN0aW9uKHRhcmdldCwgaXRlcmFibGUpe1xuICAgICAgc3RyaWN0TmV3KHRhcmdldCwgQywgTkFNRSk7XG4gICAgICB0YXJnZXQuX2MgPSBuZXcgQmFzZTtcbiAgICAgIGlmKGl0ZXJhYmxlICE9IHVuZGVmaW5lZClmb3JPZihpdGVyYWJsZSwgSVNfTUFQLCB0YXJnZXRbQURERVJdLCB0YXJnZXQpO1xuICAgIH0pO1xuICAgICQuZWFjaC5jYWxsKCdhZGQsY2xlYXIsZGVsZXRlLGZvckVhY2gsZ2V0LGhhcyxzZXQsa2V5cyx2YWx1ZXMsZW50cmllcycuc3BsaXQoJywnKSxmdW5jdGlvbihLRVkpe1xuICAgICAgdmFyIElTX0FEREVSID0gS0VZID09ICdhZGQnIHx8IEtFWSA9PSAnc2V0JztcbiAgICAgIGlmKEtFWSBpbiBwcm90byAmJiAhKElTX1dFQUsgJiYgS0VZID09ICdjbGVhcicpKWhpZGUoQy5wcm90b3R5cGUsIEtFWSwgZnVuY3Rpb24oYSwgYil7XG4gICAgICAgIGlmKCFJU19BRERFUiAmJiBJU19XRUFLICYmICFpc09iamVjdChhKSlyZXR1cm4gS0VZID09ICdnZXQnID8gdW5kZWZpbmVkIDogZmFsc2U7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9jW0tFWV0oYSA9PT0gMCA/IDAgOiBhLCBiKTtcbiAgICAgICAgcmV0dXJuIElTX0FEREVSID8gdGhpcyA6IHJlc3VsdDtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGlmKCdzaXplJyBpbiBwcm90bykkLnNldERlc2MoQy5wcm90b3R5cGUsICdzaXplJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gdGhpcy5fYy5zaXplO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgc2V0VG9TdHJpbmdUYWcoQywgTkFNRSk7XG5cbiAgT1tOQU1FXSA9IEM7XG4gICRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GLCBPKTtcblxuICBpZighSVNfV0VBSyljb21tb24uc2V0U3Ryb25nKEMsIE5BTUUsIElTX01BUCk7XG5cbiAgcmV0dXJuIEM7XG59OyIsInZhciBjb3JlID0gbW9kdWxlLmV4cG9ydHMgPSB7dmVyc2lvbjogJzEuMi42J307XG5pZih0eXBlb2YgX19lID09ICdudW1iZXInKV9fZSA9IGNvcmU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWYiLCIvLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuLyQuYS1mdW5jdGlvbicpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihmbiwgdGhhdCwgbGVuZ3RoKXtcbiAgYUZ1bmN0aW9uKGZuKTtcbiAgaWYodGhhdCA9PT0gdW5kZWZpbmVkKXJldHVybiBmbjtcbiAgc3dpdGNoKGxlbmd0aCl7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24oYSl7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhKTtcbiAgICB9O1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uKGEsIGIpe1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYik7XG4gICAgfTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbihhLCBiLCBjKXtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIsIGMpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKC8qIC4uLmFyZ3MgKi8pe1xuICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuICB9O1xufTsiLCIvLyA3LjIuMSBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGFyZ3VtZW50KVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIGlmKGl0ID09IHVuZGVmaW5lZCl0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjYWxsIG1ldGhvZCBvbiAgXCIgKyBpdCk7XG4gIHJldHVybiBpdDtcbn07IiwiLy8gVGhhbmsncyBJRTggZm9yIGhpcyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxubW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi8kLmZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7Z2V0OiBmdW5jdGlvbigpeyByZXR1cm4gNzsgfX0pLmEgIT0gNztcbn0pOyIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vJC5pcy1vYmplY3QnKVxuICAsIGRvY3VtZW50ID0gcmVxdWlyZSgnLi8kLmdsb2JhbCcpLmRvY3VtZW50XG4gIC8vIGluIG9sZCBJRSB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCBpcyAnb2JqZWN0J1xuICAsIGlzID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpcyA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaXQpIDoge307XG59OyIsIi8vIGFsbCBlbnVtZXJhYmxlIG9iamVjdCBrZXlzLCBpbmNsdWRlcyBzeW1ib2xzXG52YXIgJCA9IHJlcXVpcmUoJy4vJCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHZhciBrZXlzICAgICAgID0gJC5nZXRLZXlzKGl0KVxuICAgICwgZ2V0U3ltYm9scyA9ICQuZ2V0U3ltYm9scztcbiAgaWYoZ2V0U3ltYm9scyl7XG4gICAgdmFyIHN5bWJvbHMgPSBnZXRTeW1ib2xzKGl0KVxuICAgICAgLCBpc0VudW0gID0gJC5pc0VudW1cbiAgICAgICwgaSAgICAgICA9IDBcbiAgICAgICwga2V5O1xuICAgIHdoaWxlKHN5bWJvbHMubGVuZ3RoID4gaSlpZihpc0VudW0uY2FsbChpdCwga2V5ID0gc3ltYm9sc1tpKytdKSlrZXlzLnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn07IiwidmFyIGdsb2JhbCAgICA9IHJlcXVpcmUoJy4vJC5nbG9iYWwnKVxuICAsIGNvcmUgICAgICA9IHJlcXVpcmUoJy4vJC5jb3JlJylcbiAgLCBjdHggICAgICAgPSByZXF1aXJlKCcuLyQuY3R4JylcbiAgLCBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxudmFyICRleHBvcnQgPSBmdW5jdGlvbih0eXBlLCBuYW1lLCBzb3VyY2Upe1xuICB2YXIgSVNfRk9SQ0VEID0gdHlwZSAmICRleHBvcnQuRlxuICAgICwgSVNfR0xPQkFMID0gdHlwZSAmICRleHBvcnQuR1xuICAgICwgSVNfU1RBVElDID0gdHlwZSAmICRleHBvcnQuU1xuICAgICwgSVNfUFJPVE8gID0gdHlwZSAmICRleHBvcnQuUFxuICAgICwgSVNfQklORCAgID0gdHlwZSAmICRleHBvcnQuQlxuICAgICwgSVNfV1JBUCAgID0gdHlwZSAmICRleHBvcnQuV1xuICAgICwgZXhwb3J0cyAgID0gSVNfR0xPQkFMID8gY29yZSA6IGNvcmVbbmFtZV0gfHwgKGNvcmVbbmFtZV0gPSB7fSlcbiAgICAsIHRhcmdldCAgICA9IElTX0dMT0JBTCA/IGdsb2JhbCA6IElTX1NUQVRJQyA/IGdsb2JhbFtuYW1lXSA6IChnbG9iYWxbbmFtZV0gfHwge30pW1BST1RPVFlQRV1cbiAgICAsIGtleSwgb3duLCBvdXQ7XG4gIGlmKElTX0dMT0JBTClzb3VyY2UgPSBuYW1lO1xuICBmb3Ioa2V5IGluIHNvdXJjZSl7XG4gICAgLy8gY29udGFpbnMgaW4gbmF0aXZlXG4gICAgb3duID0gIUlTX0ZPUkNFRCAmJiB0YXJnZXQgJiYga2V5IGluIHRhcmdldDtcbiAgICBpZihvd24gJiYga2V5IGluIGV4cG9ydHMpY29udGludWU7XG4gICAgLy8gZXhwb3J0IG5hdGl2ZSBvciBwYXNzZWRcbiAgICBvdXQgPSBvd24gPyB0YXJnZXRba2V5XSA6IHNvdXJjZVtrZXldO1xuICAgIC8vIHByZXZlbnQgZ2xvYmFsIHBvbGx1dGlvbiBmb3IgbmFtZXNwYWNlc1xuICAgIGV4cG9ydHNba2V5XSA9IElTX0dMT0JBTCAmJiB0eXBlb2YgdGFyZ2V0W2tleV0gIT0gJ2Z1bmN0aW9uJyA/IHNvdXJjZVtrZXldXG4gICAgLy8gYmluZCB0aW1lcnMgdG8gZ2xvYmFsIGZvciBjYWxsIGZyb20gZXhwb3J0IGNvbnRleHRcbiAgICA6IElTX0JJTkQgJiYgb3duID8gY3R4KG91dCwgZ2xvYmFsKVxuICAgIC8vIHdyYXAgZ2xvYmFsIGNvbnN0cnVjdG9ycyBmb3IgcHJldmVudCBjaGFuZ2UgdGhlbSBpbiBsaWJyYXJ5XG4gICAgOiBJU19XUkFQICYmIHRhcmdldFtrZXldID09IG91dCA/IChmdW5jdGlvbihDKXtcbiAgICAgIHZhciBGID0gZnVuY3Rpb24ocGFyYW0pe1xuICAgICAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIEMgPyBuZXcgQyhwYXJhbSkgOiBDKHBhcmFtKTtcbiAgICAgIH07XG4gICAgICBGW1BST1RPVFlQRV0gPSBDW1BST1RPVFlQRV07XG4gICAgICByZXR1cm4gRjtcbiAgICAvLyBtYWtlIHN0YXRpYyB2ZXJzaW9ucyBmb3IgcHJvdG90eXBlIG1ldGhvZHNcbiAgICB9KShvdXQpIDogSVNfUFJPVE8gJiYgdHlwZW9mIG91dCA9PSAnZnVuY3Rpb24nID8gY3R4KEZ1bmN0aW9uLmNhbGwsIG91dCkgOiBvdXQ7XG4gICAgaWYoSVNfUFJPVE8pKGV4cG9ydHNbUFJPVE9UWVBFXSB8fCAoZXhwb3J0c1tQUk9UT1RZUEVdID0ge30pKVtrZXldID0gb3V0O1xuICB9XG59O1xuLy8gdHlwZSBiaXRtYXBcbiRleHBvcnQuRiA9IDE7ICAvLyBmb3JjZWRcbiRleHBvcnQuRyA9IDI7ICAvLyBnbG9iYWxcbiRleHBvcnQuUyA9IDQ7ICAvLyBzdGF0aWNcbiRleHBvcnQuUCA9IDg7ICAvLyBwcm90b1xuJGV4cG9ydC5CID0gMTY7IC8vIGJpbmRcbiRleHBvcnQuVyA9IDMyOyAvLyB3cmFwXG5tb2R1bGUuZXhwb3J0cyA9ICRleHBvcnQ7IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihleGVjKXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2goZSl7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07IiwidmFyIGN0eCAgICAgICAgID0gcmVxdWlyZSgnLi8kLmN0eCcpXG4gICwgY2FsbCAgICAgICAgPSByZXF1aXJlKCcuLyQuaXRlci1jYWxsJylcbiAgLCBpc0FycmF5SXRlciA9IHJlcXVpcmUoJy4vJC5pcy1hcnJheS1pdGVyJylcbiAgLCBhbk9iamVjdCAgICA9IHJlcXVpcmUoJy4vJC5hbi1vYmplY3QnKVxuICAsIHRvTGVuZ3RoICAgID0gcmVxdWlyZSgnLi8kLnRvLWxlbmd0aCcpXG4gICwgZ2V0SXRlckZuICAgPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdGVyYWJsZSwgZW50cmllcywgZm4sIHRoYXQpe1xuICB2YXIgaXRlckZuID0gZ2V0SXRlckZuKGl0ZXJhYmxlKVxuICAgICwgZiAgICAgID0gY3R4KGZuLCB0aGF0LCBlbnRyaWVzID8gMiA6IDEpXG4gICAgLCBpbmRleCAgPSAwXG4gICAgLCBsZW5ndGgsIHN0ZXAsIGl0ZXJhdG9yO1xuICBpZih0eXBlb2YgaXRlckZuICE9ICdmdW5jdGlvbicpdGhyb3cgVHlwZUVycm9yKGl0ZXJhYmxlICsgJyBpcyBub3QgaXRlcmFibGUhJyk7XG4gIC8vIGZhc3QgY2FzZSBmb3IgYXJyYXlzIHdpdGggZGVmYXVsdCBpdGVyYXRvclxuICBpZihpc0FycmF5SXRlcihpdGVyRm4pKWZvcihsZW5ndGggPSB0b0xlbmd0aChpdGVyYWJsZS5sZW5ndGgpOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKyl7XG4gICAgZW50cmllcyA/IGYoYW5PYmplY3Qoc3RlcCA9IGl0ZXJhYmxlW2luZGV4XSlbMF0sIHN0ZXBbMV0pIDogZihpdGVyYWJsZVtpbmRleF0pO1xuICB9IGVsc2UgZm9yKGl0ZXJhdG9yID0gaXRlckZuLmNhbGwoaXRlcmFibGUpOyAhKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmU7ICl7XG4gICAgY2FsbChpdGVyYXRvciwgZiwgc3RlcC52YWx1ZSwgZW50cmllcyk7XG4gIH1cbn07IiwiLy8gZmFsbGJhY2sgZm9yIElFMTEgYnVnZ3kgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgd2l0aCBpZnJhbWUgYW5kIHdpbmRvd1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vJC50by1pb2JqZWN0JylcbiAgLCBnZXROYW1lcyAgPSByZXF1aXJlKCcuLyQnKS5nZXROYW1lc1xuICAsIHRvU3RyaW5nICA9IHt9LnRvU3RyaW5nO1xuXG52YXIgd2luZG93TmFtZXMgPSB0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzXG4gID8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMod2luZG93KSA6IFtdO1xuXG52YXIgZ2V0V2luZG93TmFtZXMgPSBmdW5jdGlvbihpdCl7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGdldE5hbWVzKGl0KTtcbiAgfSBjYXRjaChlKXtcbiAgICByZXR1cm4gd2luZG93TmFtZXMuc2xpY2UoKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMuZ2V0ID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCl7XG4gIGlmKHdpbmRvd05hbWVzICYmIHRvU3RyaW5nLmNhbGwoaXQpID09ICdbb2JqZWN0IFdpbmRvd10nKXJldHVybiBnZXRXaW5kb3dOYW1lcyhpdCk7XG4gIHJldHVybiBnZXROYW1lcyh0b0lPYmplY3QoaXQpKTtcbn07IiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbnZhciBnbG9iYWwgPSBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lk1hdGggPT0gTWF0aFxuICA/IHdpbmRvdyA6IHR5cGVvZiBzZWxmICE9ICd1bmRlZmluZWQnICYmIHNlbGYuTWF0aCA9PSBNYXRoID8gc2VsZiA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5pZih0eXBlb2YgX19nID09ICdudW1iZXInKV9fZyA9IGdsb2JhbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZiIsInZhciBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwga2V5KXtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoaXQsIGtleSk7XG59OyIsInZhciAkICAgICAgICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi8kLnByb3BlcnR5LWRlc2MnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi8kLmRlc2NyaXB0b3JzJykgPyBmdW5jdGlvbihvYmplY3QsIGtleSwgdmFsdWUpe1xuICByZXR1cm4gJC5zZXREZXNjKG9iamVjdCwga2V5LCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG59IDogZnVuY3Rpb24ob2JqZWN0LCBrZXksIHZhbHVlKXtcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIG9iamVjdDtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLyQuZ2xvYmFsJykuZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50OyIsIi8vIGZhc3QgYXBwbHksIGh0dHA6Ly9qc3BlcmYubG5raXQuY29tL2Zhc3QtYXBwbHkvNVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihmbiwgYXJncywgdGhhdCl7XG4gIHZhciB1biA9IHRoYXQgPT09IHVuZGVmaW5lZDtcbiAgc3dpdGNoKGFyZ3MubGVuZ3RoKXtcbiAgICBjYXNlIDA6IHJldHVybiB1biA/IGZuKClcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCk7XG4gICAgY2FzZSAxOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdKTtcbiAgICBjYXNlIDI6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgIGNhc2UgMzogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgY2FzZSA0OiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKTtcbiAgfSByZXR1cm4gICAgICAgICAgICAgIGZuLmFwcGx5KHRoYXQsIGFyZ3MpO1xufTsiLCIvLyBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIGFuZCBub24tZW51bWVyYWJsZSBvbGQgVjggc3RyaW5nc1xudmFyIGNvZiA9IHJlcXVpcmUoJy4vJC5jb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCkgPyBPYmplY3QgOiBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBjb2YoaXQpID09ICdTdHJpbmcnID8gaXQuc3BsaXQoJycpIDogT2JqZWN0KGl0KTtcbn07IiwiLy8gY2hlY2sgb24gZGVmYXVsdCBBcnJheSBpdGVyYXRvclxudmFyIEl0ZXJhdG9ycyAgPSByZXF1aXJlKCcuLyQuaXRlcmF0b3JzJylcbiAgLCBJVEVSQVRPUiAgID0gcmVxdWlyZSgnLi8kLndrcycpKCdpdGVyYXRvcicpXG4gICwgQXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpdCAhPT0gdW5kZWZpbmVkICYmIChJdGVyYXRvcnMuQXJyYXkgPT09IGl0IHx8IEFycmF5UHJvdG9bSVRFUkFUT1JdID09PSBpdCk7XG59OyIsIi8vIDcuMi4yIElzQXJyYXkoYXJndW1lbnQpXG52YXIgY29mID0gcmVxdWlyZSgnLi8kLmNvZicpO1xubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uKGFyZyl7XG4gIHJldHVybiBjb2YoYXJnKSA9PSAnQXJyYXknO1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IHR5cGVvZiBpdCA9PT0gJ2Z1bmN0aW9uJztcbn07IiwiLy8gY2FsbCBzb21ldGhpbmcgb24gaXRlcmF0b3Igc3RlcCB3aXRoIHNhZmUgY2xvc2luZyBvbiBlcnJvclxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi8kLmFuLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdGVyYXRvciwgZm4sIHZhbHVlLCBlbnRyaWVzKXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZW50cmllcyA/IGZuKGFuT2JqZWN0KHZhbHVlKVswXSwgdmFsdWVbMV0pIDogZm4odmFsdWUpO1xuICAvLyA3LjQuNiBJdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCBjb21wbGV0aW9uKVxuICB9IGNhdGNoKGUpe1xuICAgIHZhciByZXQgPSBpdGVyYXRvclsncmV0dXJuJ107XG4gICAgaWYocmV0ICE9PSB1bmRlZmluZWQpYW5PYmplY3QocmV0LmNhbGwoaXRlcmF0b3IpKTtcbiAgICB0aHJvdyBlO1xuICB9XG59OyIsIid1c2Ugc3RyaWN0JztcbnZhciAkICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgZGVzY3JpcHRvciAgICAgPSByZXF1aXJlKCcuLyQucHJvcGVydHktZGVzYycpXG4gICwgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuLyQuc2V0LXRvLXN0cmluZy10YWcnKVxuICAsIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG5cbi8vIDI1LjEuMi4xLjEgJUl0ZXJhdG9yUHJvdG90eXBlJVtAQGl0ZXJhdG9yXSgpXG5yZXF1aXJlKCcuLyQuaGlkZScpKEl0ZXJhdG9yUHJvdG90eXBlLCByZXF1aXJlKCcuLyQud2tzJykoJ2l0ZXJhdG9yJyksIGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzOyB9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCl7XG4gIENvbnN0cnVjdG9yLnByb3RvdHlwZSA9ICQuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlLCB7bmV4dDogZGVzY3JpcHRvcigxLCBuZXh0KX0pO1xuICBzZXRUb1N0cmluZ1RhZyhDb25zdHJ1Y3RvciwgTkFNRSArICcgSXRlcmF0b3InKTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xudmFyIExJQlJBUlkgICAgICAgID0gcmVxdWlyZSgnLi8kLmxpYnJhcnknKVxuICAsICRleHBvcnQgICAgICAgID0gcmVxdWlyZSgnLi8kLmV4cG9ydCcpXG4gICwgcmVkZWZpbmUgICAgICAgPSByZXF1aXJlKCcuLyQucmVkZWZpbmUnKVxuICAsIGhpZGUgICAgICAgICAgID0gcmVxdWlyZSgnLi8kLmhpZGUnKVxuICAsIGhhcyAgICAgICAgICAgID0gcmVxdWlyZSgnLi8kLmhhcycpXG4gICwgSXRlcmF0b3JzICAgICAgPSByZXF1aXJlKCcuLyQuaXRlcmF0b3JzJylcbiAgLCAkaXRlckNyZWF0ZSAgICA9IHJlcXVpcmUoJy4vJC5pdGVyLWNyZWF0ZScpXG4gICwgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuLyQuc2V0LXRvLXN0cmluZy10YWcnKVxuICAsIGdldFByb3RvICAgICAgID0gcmVxdWlyZSgnLi8kJykuZ2V0UHJvdG9cbiAgLCBJVEVSQVRPUiAgICAgICA9IHJlcXVpcmUoJy4vJC53a3MnKSgnaXRlcmF0b3InKVxuICAsIEJVR0dZICAgICAgICAgID0gIShbXS5rZXlzICYmICduZXh0JyBpbiBbXS5rZXlzKCkpIC8vIFNhZmFyaSBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcbiAgLCBGRl9JVEVSQVRPUiAgICA9ICdAQGl0ZXJhdG9yJ1xuICAsIEtFWVMgICAgICAgICAgID0gJ2tleXMnXG4gICwgVkFMVUVTICAgICAgICAgPSAndmFsdWVzJztcblxudmFyIHJldHVyblRoaXMgPSBmdW5jdGlvbigpeyByZXR1cm4gdGhpczsgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihCYXNlLCBOQU1FLCBDb25zdHJ1Y3RvciwgbmV4dCwgREVGQVVMVCwgSVNfU0VULCBGT1JDRUQpe1xuICAkaXRlckNyZWF0ZShDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG4gIHZhciBnZXRNZXRob2QgPSBmdW5jdGlvbihraW5kKXtcbiAgICBpZighQlVHR1kgJiYga2luZCBpbiBwcm90bylyZXR1cm4gcHJvdG9ba2luZF07XG4gICAgc3dpdGNoKGtpbmQpe1xuICAgICAgY2FzZSBLRVlTOiByZXR1cm4gZnVuY3Rpb24ga2V5cygpeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgICAgY2FzZSBWQUxVRVM6IHJldHVybiBmdW5jdGlvbiB2YWx1ZXMoKXsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICB9IHJldHVybiBmdW5jdGlvbiBlbnRyaWVzKCl7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gIH07XG4gIHZhciBUQUcgICAgICAgID0gTkFNRSArICcgSXRlcmF0b3InXG4gICAgLCBERUZfVkFMVUVTID0gREVGQVVMVCA9PSBWQUxVRVNcbiAgICAsIFZBTFVFU19CVUcgPSBmYWxzZVxuICAgICwgcHJvdG8gICAgICA9IEJhc2UucHJvdG90eXBlXG4gICAgLCAkbmF0aXZlICAgID0gcHJvdG9bSVRFUkFUT1JdIHx8IHByb3RvW0ZGX0lURVJBVE9SXSB8fCBERUZBVUxUICYmIHByb3RvW0RFRkFVTFRdXG4gICAgLCAkZGVmYXVsdCAgID0gJG5hdGl2ZSB8fCBnZXRNZXRob2QoREVGQVVMVClcbiAgICAsIG1ldGhvZHMsIGtleTtcbiAgLy8gRml4IG5hdGl2ZVxuICBpZigkbmF0aXZlKXtcbiAgICB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90bygkZGVmYXVsdC5jYWxsKG5ldyBCYXNlKSk7XG4gICAgLy8gU2V0IEBAdG9TdHJpbmdUYWcgdG8gbmF0aXZlIGl0ZXJhdG9yc1xuICAgIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yUHJvdG90eXBlLCBUQUcsIHRydWUpO1xuICAgIC8vIEZGIGZpeFxuICAgIGlmKCFMSUJSQVJZICYmIGhhcyhwcm90bywgRkZfSVRFUkFUT1IpKWhpZGUoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SLCByZXR1cm5UaGlzKTtcbiAgICAvLyBmaXggQXJyYXkje3ZhbHVlcywgQEBpdGVyYXRvcn0ubmFtZSBpbiBWOCAvIEZGXG4gICAgaWYoREVGX1ZBTFVFUyAmJiAkbmF0aXZlLm5hbWUgIT09IFZBTFVFUyl7XG4gICAgICBWQUxVRVNfQlVHID0gdHJ1ZTtcbiAgICAgICRkZWZhdWx0ID0gZnVuY3Rpb24gdmFsdWVzKCl7IHJldHVybiAkbmF0aXZlLmNhbGwodGhpcyk7IH07XG4gICAgfVxuICB9XG4gIC8vIERlZmluZSBpdGVyYXRvclxuICBpZigoIUxJQlJBUlkgfHwgRk9SQ0VEKSAmJiAoQlVHR1kgfHwgVkFMVUVTX0JVRyB8fCAhcHJvdG9bSVRFUkFUT1JdKSl7XG4gICAgaGlkZShwcm90bywgSVRFUkFUT1IsICRkZWZhdWx0KTtcbiAgfVxuICAvLyBQbHVnIGZvciBsaWJyYXJ5XG4gIEl0ZXJhdG9yc1tOQU1FXSA9ICRkZWZhdWx0O1xuICBJdGVyYXRvcnNbVEFHXSAgPSByZXR1cm5UaGlzO1xuICBpZihERUZBVUxUKXtcbiAgICBtZXRob2RzID0ge1xuICAgICAgdmFsdWVzOiAgREVGX1ZBTFVFUyAgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChWQUxVRVMpLFxuICAgICAga2V5czogICAgSVNfU0VUICAgICAgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChLRVlTKSxcbiAgICAgIGVudHJpZXM6ICFERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoJ2VudHJpZXMnKVxuICAgIH07XG4gICAgaWYoRk9SQ0VEKWZvcihrZXkgaW4gbWV0aG9kcyl7XG4gICAgICBpZighKGtleSBpbiBwcm90bykpcmVkZWZpbmUocHJvdG8sIGtleSwgbWV0aG9kc1trZXldKTtcbiAgICB9IGVsc2UgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoQlVHR1kgfHwgVkFMVUVTX0JVRyksIE5BTUUsIG1ldGhvZHMpO1xuICB9XG4gIHJldHVybiBtZXRob2RzO1xufTsiLCJ2YXIgSVRFUkFUT1IgICAgID0gcmVxdWlyZSgnLi8kLndrcycpKCdpdGVyYXRvcicpXG4gICwgU0FGRV9DTE9TSU5HID0gZmFsc2U7XG5cbnRyeSB7XG4gIHZhciByaXRlciA9IFs3XVtJVEVSQVRPUl0oKTtcbiAgcml0ZXJbJ3JldHVybiddID0gZnVuY3Rpb24oKXsgU0FGRV9DTE9TSU5HID0gdHJ1ZTsgfTtcbiAgQXJyYXkuZnJvbShyaXRlciwgZnVuY3Rpb24oKXsgdGhyb3cgMjsgfSk7XG59IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZXhlYywgc2tpcENsb3Npbmcpe1xuICBpZighc2tpcENsb3NpbmcgJiYgIVNBRkVfQ0xPU0lORylyZXR1cm4gZmFsc2U7XG4gIHZhciBzYWZlID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgdmFyIGFyciAgPSBbN11cbiAgICAgICwgaXRlciA9IGFycltJVEVSQVRPUl0oKTtcbiAgICBpdGVyLm5leHQgPSBmdW5jdGlvbigpeyBzYWZlID0gdHJ1ZTsgfTtcbiAgICBhcnJbSVRFUkFUT1JdID0gZnVuY3Rpb24oKXsgcmV0dXJuIGl0ZXI7IH07XG4gICAgZXhlYyhhcnIpO1xuICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG4gIHJldHVybiBzYWZlO1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGRvbmUsIHZhbHVlKXtcbiAgcmV0dXJuIHt2YWx1ZTogdmFsdWUsIGRvbmU6ICEhZG9uZX07XG59OyIsIm1vZHVsZS5leHBvcnRzID0ge307IiwidmFyICRPYmplY3QgPSBPYmplY3Q7XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY3JlYXRlOiAgICAgJE9iamVjdC5jcmVhdGUsXG4gIGdldFByb3RvOiAgICRPYmplY3QuZ2V0UHJvdG90eXBlT2YsXG4gIGlzRW51bTogICAgIHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlLFxuICBnZXREZXNjOiAgICAkT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcixcbiAgc2V0RGVzYzogICAgJE9iamVjdC5kZWZpbmVQcm9wZXJ0eSxcbiAgc2V0RGVzY3M6ICAgJE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzLFxuICBnZXRLZXlzOiAgICAkT2JqZWN0LmtleXMsXG4gIGdldE5hbWVzOiAgICRPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyxcbiAgZ2V0U3ltYm9sczogJE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsXG4gIGVhY2g6ICAgICAgIFtdLmZvckVhY2hcbn07IiwidmFyICQgICAgICAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi8kLnRvLWlvYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqZWN0LCBlbCl7XG4gIHZhciBPICAgICAgPSB0b0lPYmplY3Qob2JqZWN0KVxuICAgICwga2V5cyAgID0gJC5nZXRLZXlzKE8pXG4gICAgLCBsZW5ndGggPSBrZXlzLmxlbmd0aFxuICAgICwgaW5kZXggID0gMFxuICAgICwga2V5O1xuICB3aGlsZShsZW5ndGggPiBpbmRleClpZihPW2tleSA9IGtleXNbaW5kZXgrK11dID09PSBlbClyZXR1cm4ga2V5O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHRydWU7IiwidmFyIGdsb2JhbCAgICA9IHJlcXVpcmUoJy4vJC5nbG9iYWwnKVxuICAsIG1hY3JvdGFzayA9IHJlcXVpcmUoJy4vJC50YXNrJykuc2V0XG4gICwgT2JzZXJ2ZXIgID0gZ2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIgfHwgZ2xvYmFsLldlYktpdE11dGF0aW9uT2JzZXJ2ZXJcbiAgLCBwcm9jZXNzICAgPSBnbG9iYWwucHJvY2Vzc1xuICAsIFByb21pc2UgICA9IGdsb2JhbC5Qcm9taXNlXG4gICwgaXNOb2RlICAgID0gcmVxdWlyZSgnLi8kLmNvZicpKHByb2Nlc3MpID09ICdwcm9jZXNzJ1xuICAsIGhlYWQsIGxhc3QsIG5vdGlmeTtcblxudmFyIGZsdXNoID0gZnVuY3Rpb24oKXtcbiAgdmFyIHBhcmVudCwgZG9tYWluLCBmbjtcbiAgaWYoaXNOb2RlICYmIChwYXJlbnQgPSBwcm9jZXNzLmRvbWFpbikpe1xuICAgIHByb2Nlc3MuZG9tYWluID0gbnVsbDtcbiAgICBwYXJlbnQuZXhpdCgpO1xuICB9XG4gIHdoaWxlKGhlYWQpe1xuICAgIGRvbWFpbiA9IGhlYWQuZG9tYWluO1xuICAgIGZuICAgICA9IGhlYWQuZm47XG4gICAgaWYoZG9tYWluKWRvbWFpbi5lbnRlcigpO1xuICAgIGZuKCk7IC8vIDwtIGN1cnJlbnRseSB3ZSB1c2UgaXQgb25seSBmb3IgUHJvbWlzZSAtIHRyeSAvIGNhdGNoIG5vdCByZXF1aXJlZFxuICAgIGlmKGRvbWFpbilkb21haW4uZXhpdCgpO1xuICAgIGhlYWQgPSBoZWFkLm5leHQ7XG4gIH0gbGFzdCA9IHVuZGVmaW5lZDtcbiAgaWYocGFyZW50KXBhcmVudC5lbnRlcigpO1xufTtcblxuLy8gTm9kZS5qc1xuaWYoaXNOb2RlKXtcbiAgbm90aWZ5ID0gZnVuY3Rpb24oKXtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZsdXNoKTtcbiAgfTtcbi8vIGJyb3dzZXJzIHdpdGggTXV0YXRpb25PYnNlcnZlclxufSBlbHNlIGlmKE9ic2VydmVyKXtcbiAgdmFyIHRvZ2dsZSA9IDFcbiAgICAsIG5vZGUgICA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcbiAgbmV3IE9ic2VydmVyKGZsdXNoKS5vYnNlcnZlKG5vZGUsIHtjaGFyYWN0ZXJEYXRhOiB0cnVlfSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gIG5vdGlmeSA9IGZ1bmN0aW9uKCl7XG4gICAgbm9kZS5kYXRhID0gdG9nZ2xlID0gLXRvZ2dsZTtcbiAgfTtcbi8vIGVudmlyb25tZW50cyB3aXRoIG1heWJlIG5vbi1jb21wbGV0ZWx5IGNvcnJlY3QsIGJ1dCBleGlzdGVudCBQcm9taXNlXG59IGVsc2UgaWYoUHJvbWlzZSAmJiBQcm9taXNlLnJlc29sdmUpe1xuICBub3RpZnkgPSBmdW5jdGlvbigpe1xuICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZmx1c2gpO1xuICB9O1xuLy8gZm9yIG90aGVyIGVudmlyb25tZW50cyAtIG1hY3JvdGFzayBiYXNlZCBvbjpcbi8vIC0gc2V0SW1tZWRpYXRlXG4vLyAtIE1lc3NhZ2VDaGFubmVsXG4vLyAtIHdpbmRvdy5wb3N0TWVzc2FnXG4vLyAtIG9ucmVhZHlzdGF0ZWNoYW5nZVxuLy8gLSBzZXRUaW1lb3V0XG59IGVsc2Uge1xuICBub3RpZnkgPSBmdW5jdGlvbigpe1xuICAgIC8vIHN0cmFuZ2UgSUUgKyB3ZWJwYWNrIGRldiBzZXJ2ZXIgYnVnIC0gdXNlIC5jYWxsKGdsb2JhbClcbiAgICBtYWNyb3Rhc2suY2FsbChnbG9iYWwsIGZsdXNoKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBhc2FwKGZuKXtcbiAgdmFyIHRhc2sgPSB7Zm46IGZuLCBuZXh0OiB1bmRlZmluZWQsIGRvbWFpbjogaXNOb2RlICYmIHByb2Nlc3MuZG9tYWlufTtcbiAgaWYobGFzdClsYXN0Lm5leHQgPSB0YXNrO1xuICBpZighaGVhZCl7XG4gICAgaGVhZCA9IHRhc2s7XG4gICAgbm90aWZ5KCk7XG4gIH0gbGFzdCA9IHRhc2s7XG59OyIsIi8vIDE5LjEuMi4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UsIC4uLilcbnZhciAkICAgICAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgdG9PYmplY3QgPSByZXF1aXJlKCcuLyQudG8tb2JqZWN0JylcbiAgLCBJT2JqZWN0ICA9IHJlcXVpcmUoJy4vJC5pb2JqZWN0Jyk7XG5cbi8vIHNob3VsZCB3b3JrIHdpdGggc3ltYm9scyBhbmQgc2hvdWxkIGhhdmUgZGV0ZXJtaW5pc3RpYyBwcm9wZXJ0eSBvcmRlciAoVjggYnVnKVxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLyQuZmFpbHMnKShmdW5jdGlvbigpe1xuICB2YXIgYSA9IE9iamVjdC5hc3NpZ25cbiAgICAsIEEgPSB7fVxuICAgICwgQiA9IHt9XG4gICAgLCBTID0gU3ltYm9sKClcbiAgICAsIEsgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3QnO1xuICBBW1NdID0gNztcbiAgSy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbihrKXsgQltrXSA9IGs7IH0pO1xuICByZXR1cm4gYSh7fSwgQSlbU10gIT0gNyB8fCBPYmplY3Qua2V5cyhhKHt9LCBCKSkuam9pbignJykgIT0gSztcbn0pID8gZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlKXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICB2YXIgVCAgICAgPSB0b09iamVjdCh0YXJnZXQpXG4gICAgLCAkJCAgICA9IGFyZ3VtZW50c1xuICAgICwgJCRsZW4gPSAkJC5sZW5ndGhcbiAgICAsIGluZGV4ID0gMVxuICAgICwgZ2V0S2V5cyAgICA9ICQuZ2V0S2V5c1xuICAgICwgZ2V0U3ltYm9scyA9ICQuZ2V0U3ltYm9sc1xuICAgICwgaXNFbnVtICAgICA9ICQuaXNFbnVtO1xuICB3aGlsZSgkJGxlbiA+IGluZGV4KXtcbiAgICB2YXIgUyAgICAgID0gSU9iamVjdCgkJFtpbmRleCsrXSlcbiAgICAgICwga2V5cyAgID0gZ2V0U3ltYm9scyA/IGdldEtleXMoUykuY29uY2F0KGdldFN5bWJvbHMoUykpIDogZ2V0S2V5cyhTKVxuICAgICAgLCBsZW5ndGggPSBrZXlzLmxlbmd0aFxuICAgICAgLCBqICAgICAgPSAwXG4gICAgICAsIGtleTtcbiAgICB3aGlsZShsZW5ndGggPiBqKWlmKGlzRW51bS5jYWxsKFMsIGtleSA9IGtleXNbaisrXSkpVFtrZXldID0gU1trZXldO1xuICB9XG4gIHJldHVybiBUO1xufSA6IE9iamVjdC5hc3NpZ247IiwiLy8gbW9zdCBPYmplY3QgbWV0aG9kcyBieSBFUzYgc2hvdWxkIGFjY2VwdCBwcmltaXRpdmVzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vJC5leHBvcnQnKVxuICAsIGNvcmUgICAgPSByZXF1aXJlKCcuLyQuY29yZScpXG4gICwgZmFpbHMgICA9IHJlcXVpcmUoJy4vJC5mYWlscycpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihLRVksIGV4ZWMpe1xuICB2YXIgZm4gID0gKGNvcmUuT2JqZWN0IHx8IHt9KVtLRVldIHx8IE9iamVjdFtLRVldXG4gICAgLCBleHAgPSB7fTtcbiAgZXhwW0tFWV0gPSBleGVjKGZuKTtcbiAgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiBmYWlscyhmdW5jdGlvbigpeyBmbigxKTsgfSksICdPYmplY3QnLCBleHApO1xufTsiLCJ2YXIgJCAgICAgICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCB0b0lPYmplY3QgPSByZXF1aXJlKCcuLyQudG8taW9iamVjdCcpXG4gICwgaXNFbnVtICAgID0gJC5pc0VudW07XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGlzRW50cmllcyl7XG4gIHJldHVybiBmdW5jdGlvbihpdCl7XG4gICAgdmFyIE8gICAgICA9IHRvSU9iamVjdChpdClcbiAgICAgICwga2V5cyAgID0gJC5nZXRLZXlzKE8pXG4gICAgICAsIGxlbmd0aCA9IGtleXMubGVuZ3RoXG4gICAgICAsIGkgICAgICA9IDBcbiAgICAgICwgcmVzdWx0ID0gW11cbiAgICAgICwga2V5O1xuICAgIHdoaWxlKGxlbmd0aCA+IGkpaWYoaXNFbnVtLmNhbGwoTywga2V5ID0ga2V5c1tpKytdKSl7XG4gICAgICByZXN1bHQucHVzaChpc0VudHJpZXMgPyBba2V5LCBPW2tleV1dIDogT1trZXldKTtcbiAgICB9IHJldHVybiByZXN1bHQ7XG4gIH07XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYml0bWFwLCB2YWx1ZSl7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZSAgOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZSAgICA6ICEoYml0bWFwICYgNCksXG4gICAgdmFsdWUgICAgICAgOiB2YWx1ZVxuICB9O1xufTsiLCJ2YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuLyQucmVkZWZpbmUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odGFyZ2V0LCBzcmMpe1xuICBmb3IodmFyIGtleSBpbiBzcmMpcmVkZWZpbmUodGFyZ2V0LCBrZXksIHNyY1trZXldKTtcbiAgcmV0dXJuIHRhcmdldDtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLyQuaGlkZScpOyIsIi8vIDcuMi45IFNhbWVWYWx1ZSh4LCB5KVxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuaXMgfHwgZnVuY3Rpb24gaXMoeCwgeSl7XG4gIHJldHVybiB4ID09PSB5ID8geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHkgOiB4ICE9IHggJiYgeSAhPSB5O1xufTsiLCIvLyBXb3JrcyB3aXRoIF9fcHJvdG9fXyBvbmx5LiBPbGQgdjggY2FuJ3Qgd29yayB3aXRoIG51bGwgcHJvdG8gb2JqZWN0cy5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG52YXIgZ2V0RGVzYyAgPSByZXF1aXJlKCcuLyQnKS5nZXREZXNjXG4gICwgaXNPYmplY3QgPSByZXF1aXJlKCcuLyQuaXMtb2JqZWN0JylcbiAgLCBhbk9iamVjdCA9IHJlcXVpcmUoJy4vJC5hbi1vYmplY3QnKTtcbnZhciBjaGVjayA9IGZ1bmN0aW9uKE8sIHByb3RvKXtcbiAgYW5PYmplY3QoTyk7XG4gIGlmKCFpc09iamVjdChwcm90bykgJiYgcHJvdG8gIT09IG51bGwpdGhyb3cgVHlwZUVycm9yKHByb3RvICsgXCI6IGNhbid0IHNldCBhcyBwcm90b3R5cGUhXCIpO1xufTtcbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXQ6IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCAoJ19fcHJvdG9fXycgaW4ge30gPyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgZnVuY3Rpb24odGVzdCwgYnVnZ3ksIHNldCl7XG4gICAgICB0cnkge1xuICAgICAgICBzZXQgPSByZXF1aXJlKCcuLyQuY3R4JykoRnVuY3Rpb24uY2FsbCwgZ2V0RGVzYyhPYmplY3QucHJvdG90eXBlLCAnX19wcm90b19fJykuc2V0LCAyKTtcbiAgICAgICAgc2V0KHRlc3QsIFtdKTtcbiAgICAgICAgYnVnZ3kgPSAhKHRlc3QgaW5zdGFuY2VvZiBBcnJheSk7XG4gICAgICB9IGNhdGNoKGUpeyBidWdneSA9IHRydWU7IH1cbiAgICAgIHJldHVybiBmdW5jdGlvbiBzZXRQcm90b3R5cGVPZihPLCBwcm90byl7XG4gICAgICAgIGNoZWNrKE8sIHByb3RvKTtcbiAgICAgICAgaWYoYnVnZ3kpTy5fX3Byb3RvX18gPSBwcm90bztcbiAgICAgICAgZWxzZSBzZXQoTywgcHJvdG8pO1xuICAgICAgICByZXR1cm4gTztcbiAgICAgIH07XG4gICAgfSh7fSwgZmFsc2UpIDogdW5kZWZpbmVkKSxcbiAgY2hlY2s6IGNoZWNrXG59OyIsIid1c2Ugc3RyaWN0JztcbnZhciBjb3JlICAgICAgICA9IHJlcXVpcmUoJy4vJC5jb3JlJylcbiAgLCAkICAgICAgICAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLyQuZGVzY3JpcHRvcnMnKVxuICAsIFNQRUNJRVMgICAgID0gcmVxdWlyZSgnLi8kLndrcycpKCdzcGVjaWVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oS0VZKXtcbiAgdmFyIEMgPSBjb3JlW0tFWV07XG4gIGlmKERFU0NSSVBUT1JTICYmIEMgJiYgIUNbU1BFQ0lFU10pJC5zZXREZXNjKEMsIFNQRUNJRVMsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpczsgfVxuICB9KTtcbn07IiwidmFyIGRlZiA9IHJlcXVpcmUoJy4vJCcpLnNldERlc2NcbiAgLCBoYXMgPSByZXF1aXJlKCcuLyQuaGFzJylcbiAgLCBUQUcgPSByZXF1aXJlKCcuLyQud2tzJykoJ3RvU3RyaW5nVGFnJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQsIHRhZywgc3RhdCl7XG4gIGlmKGl0ICYmICFoYXMoaXQgPSBzdGF0ID8gaXQgOiBpdC5wcm90b3R5cGUsIFRBRykpZGVmKGl0LCBUQUcsIHtjb25maWd1cmFibGU6IHRydWUsIHZhbHVlOiB0YWd9KTtcbn07IiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vJC5nbG9iYWwnKVxuICAsIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nXG4gICwgc3RvcmUgID0gZ2xvYmFsW1NIQVJFRF0gfHwgKGdsb2JhbFtTSEFSRURdID0ge30pO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihrZXkpe1xuICByZXR1cm4gc3RvcmVba2V5XSB8fCAoc3RvcmVba2V5XSA9IHt9KTtcbn07IiwiLy8gNy4zLjIwIFNwZWNpZXNDb25zdHJ1Y3RvcihPLCBkZWZhdWx0Q29uc3RydWN0b3IpXG52YXIgYW5PYmplY3QgID0gcmVxdWlyZSgnLi8kLmFuLW9iamVjdCcpXG4gICwgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi8kLmEtZnVuY3Rpb24nKVxuICAsIFNQRUNJRVMgICA9IHJlcXVpcmUoJy4vJC53a3MnKSgnc3BlY2llcycpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihPLCBEKXtcbiAgdmFyIEMgPSBhbk9iamVjdChPKS5jb25zdHJ1Y3RvciwgUztcbiAgcmV0dXJuIEMgPT09IHVuZGVmaW5lZCB8fCAoUyA9IGFuT2JqZWN0KEMpW1NQRUNJRVNdKSA9PSB1bmRlZmluZWQgPyBEIDogYUZ1bmN0aW9uKFMpO1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCBDb25zdHJ1Y3RvciwgbmFtZSl7XG4gIGlmKCEoaXQgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpdGhyb3cgVHlwZUVycm9yKG5hbWUgKyBcIjogdXNlIHRoZSAnbmV3JyBvcGVyYXRvciFcIik7XG4gIHJldHVybiBpdDtcbn07IiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vJC50by1pbnRlZ2VyJylcbiAgLCBkZWZpbmVkICAgPSByZXF1aXJlKCcuLyQuZGVmaW5lZCcpO1xuLy8gdHJ1ZSAgLT4gU3RyaW5nI2F0XG4vLyBmYWxzZSAtPiBTdHJpbmcjY29kZVBvaW50QXRcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oVE9fU1RSSU5HKXtcbiAgcmV0dXJuIGZ1bmN0aW9uKHRoYXQsIHBvcyl7XG4gICAgdmFyIHMgPSBTdHJpbmcoZGVmaW5lZCh0aGF0KSlcbiAgICAgICwgaSA9IHRvSW50ZWdlcihwb3MpXG4gICAgICAsIGwgPSBzLmxlbmd0aFxuICAgICAgLCBhLCBiO1xuICAgIGlmKGkgPCAwIHx8IGkgPj0gbClyZXR1cm4gVE9fU1RSSU5HID8gJycgOiB1bmRlZmluZWQ7XG4gICAgYSA9IHMuY2hhckNvZGVBdChpKTtcbiAgICByZXR1cm4gYSA8IDB4ZDgwMCB8fCBhID4gMHhkYmZmIHx8IGkgKyAxID09PSBsIHx8IChiID0gcy5jaGFyQ29kZUF0KGkgKyAxKSkgPCAweGRjMDAgfHwgYiA+IDB4ZGZmZlxuICAgICAgPyBUT19TVFJJTkcgPyBzLmNoYXJBdChpKSA6IGFcbiAgICAgIDogVE9fU1RSSU5HID8gcy5zbGljZShpLCBpICsgMikgOiAoYSAtIDB4ZDgwMCA8PCAxMCkgKyAoYiAtIDB4ZGMwMCkgKyAweDEwMDAwO1xuICB9O1xufTsiLCJ2YXIgY3R4ICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi8kLmN0eCcpXG4gICwgaW52b2tlICAgICAgICAgICAgID0gcmVxdWlyZSgnLi8kLmludm9rZScpXG4gICwgaHRtbCAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi8kLmh0bWwnKVxuICAsIGNlbCAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vJC5kb20tY3JlYXRlJylcbiAgLCBnbG9iYWwgICAgICAgICAgICAgPSByZXF1aXJlKCcuLyQuZ2xvYmFsJylcbiAgLCBwcm9jZXNzICAgICAgICAgICAgPSBnbG9iYWwucHJvY2Vzc1xuICAsIHNldFRhc2sgICAgICAgICAgICA9IGdsb2JhbC5zZXRJbW1lZGlhdGVcbiAgLCBjbGVhclRhc2sgICAgICAgICAgPSBnbG9iYWwuY2xlYXJJbW1lZGlhdGVcbiAgLCBNZXNzYWdlQ2hhbm5lbCAgICAgPSBnbG9iYWwuTWVzc2FnZUNoYW5uZWxcbiAgLCBjb3VudGVyICAgICAgICAgICAgPSAwXG4gICwgcXVldWUgICAgICAgICAgICAgID0ge31cbiAgLCBPTlJFQURZU1RBVEVDSEFOR0UgPSAnb25yZWFkeXN0YXRlY2hhbmdlJ1xuICAsIGRlZmVyLCBjaGFubmVsLCBwb3J0O1xudmFyIHJ1biA9IGZ1bmN0aW9uKCl7XG4gIHZhciBpZCA9ICt0aGlzO1xuICBpZihxdWV1ZS5oYXNPd25Qcm9wZXJ0eShpZCkpe1xuICAgIHZhciBmbiA9IHF1ZXVlW2lkXTtcbiAgICBkZWxldGUgcXVldWVbaWRdO1xuICAgIGZuKCk7XG4gIH1cbn07XG52YXIgbGlzdG5lciA9IGZ1bmN0aW9uKGV2ZW50KXtcbiAgcnVuLmNhbGwoZXZlbnQuZGF0YSk7XG59O1xuLy8gTm9kZS5qcyAwLjkrICYgSUUxMCsgaGFzIHNldEltbWVkaWF0ZSwgb3RoZXJ3aXNlOlxuaWYoIXNldFRhc2sgfHwgIWNsZWFyVGFzayl7XG4gIHNldFRhc2sgPSBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoZm4pe1xuICAgIHZhciBhcmdzID0gW10sIGkgPSAxO1xuICAgIHdoaWxlKGFyZ3VtZW50cy5sZW5ndGggPiBpKWFyZ3MucHVzaChhcmd1bWVudHNbaSsrXSk7XG4gICAgcXVldWVbKytjb3VudGVyXSA9IGZ1bmN0aW9uKCl7XG4gICAgICBpbnZva2UodHlwZW9mIGZuID09ICdmdW5jdGlvbicgPyBmbiA6IEZ1bmN0aW9uKGZuKSwgYXJncyk7XG4gICAgfTtcbiAgICBkZWZlcihjb3VudGVyKTtcbiAgICByZXR1cm4gY291bnRlcjtcbiAgfTtcbiAgY2xlYXJUYXNrID0gZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaWQpe1xuICAgIGRlbGV0ZSBxdWV1ZVtpZF07XG4gIH07XG4gIC8vIE5vZGUuanMgMC44LVxuICBpZihyZXF1aXJlKCcuLyQuY29mJykocHJvY2VzcykgPT0gJ3Byb2Nlc3MnKXtcbiAgICBkZWZlciA9IGZ1bmN0aW9uKGlkKXtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soY3R4KHJ1biwgaWQsIDEpKTtcbiAgICB9O1xuICAvLyBCcm93c2VycyB3aXRoIE1lc3NhZ2VDaGFubmVsLCBpbmNsdWRlcyBXZWJXb3JrZXJzXG4gIH0gZWxzZSBpZihNZXNzYWdlQ2hhbm5lbCl7XG4gICAgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbDtcbiAgICBwb3J0ICAgID0gY2hhbm5lbC5wb3J0MjtcbiAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGxpc3RuZXI7XG4gICAgZGVmZXIgPSBjdHgocG9ydC5wb3N0TWVzc2FnZSwgcG9ydCwgMSk7XG4gIC8vIEJyb3dzZXJzIHdpdGggcG9zdE1lc3NhZ2UsIHNraXAgV2ViV29ya2Vyc1xuICAvLyBJRTggaGFzIHBvc3RNZXNzYWdlLCBidXQgaXQncyBzeW5jICYgdHlwZW9mIGl0cyBwb3N0TWVzc2FnZSBpcyAnb2JqZWN0J1xuICB9IGVsc2UgaWYoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIgJiYgdHlwZW9mIHBvc3RNZXNzYWdlID09ICdmdW5jdGlvbicgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzKXtcbiAgICBkZWZlciA9IGZ1bmN0aW9uKGlkKXtcbiAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShpZCArICcnLCAnKicpO1xuICAgIH07XG4gICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBsaXN0bmVyLCBmYWxzZSk7XG4gIC8vIElFOC1cbiAgfSBlbHNlIGlmKE9OUkVBRFlTVEFURUNIQU5HRSBpbiBjZWwoJ3NjcmlwdCcpKXtcbiAgICBkZWZlciA9IGZ1bmN0aW9uKGlkKXtcbiAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoY2VsKCdzY3JpcHQnKSlbT05SRUFEWVNUQVRFQ0hBTkdFXSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQodGhpcyk7XG4gICAgICAgIHJ1bi5jYWxsKGlkKTtcbiAgICAgIH07XG4gICAgfTtcbiAgLy8gUmVzdCBvbGQgYnJvd3NlcnNcbiAgfSBlbHNlIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uKGlkKXtcbiAgICAgIHNldFRpbWVvdXQoY3R4KHJ1biwgaWQsIDEpLCAwKTtcbiAgICB9O1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiAgIHNldFRhc2ssXG4gIGNsZWFyOiBjbGVhclRhc2tcbn07IiwiLy8gNy4xLjQgVG9JbnRlZ2VyXG52YXIgY2VpbCAgPSBNYXRoLmNlaWxcbiAgLCBmbG9vciA9IE1hdGguZmxvb3I7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGlzTmFOKGl0ID0gK2l0KSA/IDAgOiAoaXQgPiAwID8gZmxvb3IgOiBjZWlsKShpdCk7XG59OyIsIi8vIHRvIGluZGV4ZWQgb2JqZWN0LCB0b09iamVjdCB3aXRoIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgc3RyaW5nc1xudmFyIElPYmplY3QgPSByZXF1aXJlKCcuLyQuaW9iamVjdCcpXG4gICwgZGVmaW5lZCA9IHJlcXVpcmUoJy4vJC5kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIElPYmplY3QoZGVmaW5lZChpdCkpO1xufTsiLCIvLyA3LjEuMTUgVG9MZW5ndGhcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuLyQudG8taW50ZWdlcicpXG4gICwgbWluICAgICAgID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGl0ID4gMCA/IG1pbih0b0ludGVnZXIoaXQpLCAweDFmZmZmZmZmZmZmZmZmKSA6IDA7IC8vIHBvdygyLCA1MykgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTFcbn07IiwiLy8gNy4xLjEzIFRvT2JqZWN0KGFyZ3VtZW50KVxudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuLyQuZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBPYmplY3QoZGVmaW5lZChpdCkpO1xufTsiLCJ2YXIgaWQgPSAwXG4gICwgcHggPSBNYXRoLnJhbmRvbSgpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihrZXkpe1xuICByZXR1cm4gJ1N5bWJvbCgnLmNvbmNhdChrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5LCAnKV8nLCAoKytpZCArIHB4KS50b1N0cmluZygzNikpO1xufTsiLCJ2YXIgc3RvcmUgID0gcmVxdWlyZSgnLi8kLnNoYXJlZCcpKCd3a3MnKVxuICAsIHVpZCAgICA9IHJlcXVpcmUoJy4vJC51aWQnKVxuICAsIFN5bWJvbCA9IHJlcXVpcmUoJy4vJC5nbG9iYWwnKS5TeW1ib2w7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG5hbWUpe1xuICByZXR1cm4gc3RvcmVbbmFtZV0gfHwgKHN0b3JlW25hbWVdID1cbiAgICBTeW1ib2wgJiYgU3ltYm9sW25hbWVdIHx8IChTeW1ib2wgfHwgdWlkKSgnU3ltYm9sLicgKyBuYW1lKSk7XG59OyIsInZhciBjbGFzc29mICAgPSByZXF1aXJlKCcuLyQuY2xhc3NvZicpXG4gICwgSVRFUkFUT1IgID0gcmVxdWlyZSgnLi8kLndrcycpKCdpdGVyYXRvcicpXG4gICwgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi8kLml0ZXJhdG9ycycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLyQuY29yZScpLmdldEl0ZXJhdG9yTWV0aG9kID0gZnVuY3Rpb24oaXQpe1xuICBpZihpdCAhPSB1bmRlZmluZWQpcmV0dXJuIGl0W0lURVJBVE9SXVxuICAgIHx8IGl0WydAQGl0ZXJhdG9yJ11cbiAgICB8fCBJdGVyYXRvcnNbY2xhc3NvZihpdCldO1xufTsiLCJ2YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLyQuYW4tb2JqZWN0JylcbiAgLCBnZXQgICAgICA9IHJlcXVpcmUoJy4vY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vJC5jb3JlJykuZ2V0SXRlcmF0b3IgPSBmdW5jdGlvbihpdCl7XG4gIHZhciBpdGVyRm4gPSBnZXQoaXQpO1xuICBpZih0eXBlb2YgaXRlckZuICE9ICdmdW5jdGlvbicpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgaXRlcmFibGUhJyk7XG4gIHJldHVybiBhbk9iamVjdChpdGVyRm4uY2FsbChpdCkpO1xufTsiLCIndXNlIHN0cmljdCc7XG52YXIgY3R4ICAgICAgICAgPSByZXF1aXJlKCcuLyQuY3R4JylcbiAgLCAkZXhwb3J0ICAgICA9IHJlcXVpcmUoJy4vJC5leHBvcnQnKVxuICAsIHRvT2JqZWN0ICAgID0gcmVxdWlyZSgnLi8kLnRvLW9iamVjdCcpXG4gICwgY2FsbCAgICAgICAgPSByZXF1aXJlKCcuLyQuaXRlci1jYWxsJylcbiAgLCBpc0FycmF5SXRlciA9IHJlcXVpcmUoJy4vJC5pcy1hcnJheS1pdGVyJylcbiAgLCB0b0xlbmd0aCAgICA9IHJlcXVpcmUoJy4vJC50by1sZW5ndGgnKVxuICAsIGdldEl0ZXJGbiAgID0gcmVxdWlyZSgnLi9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QnKTtcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vJC5pdGVyLWRldGVjdCcpKGZ1bmN0aW9uKGl0ZXIpeyBBcnJheS5mcm9tKGl0ZXIpOyB9KSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjIuMSBBcnJheS5mcm9tKGFycmF5TGlrZSwgbWFwZm4gPSB1bmRlZmluZWQsIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gIGZyb206IGZ1bmN0aW9uIGZyb20oYXJyYXlMaWtlLyosIG1hcGZuID0gdW5kZWZpbmVkLCB0aGlzQXJnID0gdW5kZWZpbmVkKi8pe1xuICAgIHZhciBPICAgICAgID0gdG9PYmplY3QoYXJyYXlMaWtlKVxuICAgICAgLCBDICAgICAgID0gdHlwZW9mIHRoaXMgPT0gJ2Z1bmN0aW9uJyA/IHRoaXMgOiBBcnJheVxuICAgICAgLCAkJCAgICAgID0gYXJndW1lbnRzXG4gICAgICAsICQkbGVuICAgPSAkJC5sZW5ndGhcbiAgICAgICwgbWFwZm4gICA9ICQkbGVuID4gMSA/ICQkWzFdIDogdW5kZWZpbmVkXG4gICAgICAsIG1hcHBpbmcgPSBtYXBmbiAhPT0gdW5kZWZpbmVkXG4gICAgICAsIGluZGV4ICAgPSAwXG4gICAgICAsIGl0ZXJGbiAgPSBnZXRJdGVyRm4oTylcbiAgICAgICwgbGVuZ3RoLCByZXN1bHQsIHN0ZXAsIGl0ZXJhdG9yO1xuICAgIGlmKG1hcHBpbmcpbWFwZm4gPSBjdHgobWFwZm4sICQkbGVuID4gMiA/ICQkWzJdIDogdW5kZWZpbmVkLCAyKTtcbiAgICAvLyBpZiBvYmplY3QgaXNuJ3QgaXRlcmFibGUgb3IgaXQncyBhcnJheSB3aXRoIGRlZmF1bHQgaXRlcmF0b3IgLSB1c2Ugc2ltcGxlIGNhc2VcbiAgICBpZihpdGVyRm4gIT0gdW5kZWZpbmVkICYmICEoQyA9PSBBcnJheSAmJiBpc0FycmF5SXRlcihpdGVyRm4pKSl7XG4gICAgICBmb3IoaXRlcmF0b3IgPSBpdGVyRm4uY2FsbChPKSwgcmVzdWx0ID0gbmV3IEM7ICEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZTsgaW5kZXgrKyl7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBtYXBwaW5nID8gY2FsbChpdGVyYXRvciwgbWFwZm4sIFtzdGVwLnZhbHVlLCBpbmRleF0sIHRydWUpIDogc3RlcC52YWx1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgICAgZm9yKHJlc3VsdCA9IG5ldyBDKGxlbmd0aCk7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKXtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IG1hcHBpbmcgPyBtYXBmbihPW2luZGV4XSwgaW5kZXgpIDogT1tpbmRleF07XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC5sZW5ndGggPSBpbmRleDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBhZGRUb1Vuc2NvcGFibGVzID0gcmVxdWlyZSgnLi8kLmFkZC10by11bnNjb3BhYmxlcycpXG4gICwgc3RlcCAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vJC5pdGVyLXN0ZXAnKVxuICAsIEl0ZXJhdG9ycyAgICAgICAgPSByZXF1aXJlKCcuLyQuaXRlcmF0b3JzJylcbiAgLCB0b0lPYmplY3QgICAgICAgID0gcmVxdWlyZSgnLi8kLnRvLWlvYmplY3QnKTtcblxuLy8gMjIuMS4zLjQgQXJyYXkucHJvdG90eXBlLmVudHJpZXMoKVxuLy8gMjIuMS4zLjEzIEFycmF5LnByb3RvdHlwZS5rZXlzKClcbi8vIDIyLjEuMy4yOSBBcnJheS5wcm90b3R5cGUudmFsdWVzKClcbi8vIDIyLjEuMy4zMCBBcnJheS5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLyQuaXRlci1kZWZpbmUnKShBcnJheSwgJ0FycmF5JywgZnVuY3Rpb24oaXRlcmF0ZWQsIGtpbmQpe1xuICB0aGlzLl90ID0gdG9JT2JqZWN0KGl0ZXJhdGVkKTsgLy8gdGFyZ2V0XG4gIHRoaXMuX2kgPSAwOyAgICAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4gIHRoaXMuX2sgPSBraW5kOyAgICAgICAgICAgICAgICAvLyBraW5kXG4vLyAyMi4xLjUuMi4xICVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcbn0sIGZ1bmN0aW9uKCl7XG4gIHZhciBPICAgICA9IHRoaXMuX3RcbiAgICAsIGtpbmQgID0gdGhpcy5fa1xuICAgICwgaW5kZXggPSB0aGlzLl9pKys7XG4gIGlmKCFPIHx8IGluZGV4ID49IE8ubGVuZ3RoKXtcbiAgICB0aGlzLl90ID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiBzdGVwKDEpO1xuICB9XG4gIGlmKGtpbmQgPT0gJ2tleXMnICApcmV0dXJuIHN0ZXAoMCwgaW5kZXgpO1xuICBpZihraW5kID09ICd2YWx1ZXMnKXJldHVybiBzdGVwKDAsIE9baW5kZXhdKTtcbiAgcmV0dXJuIHN0ZXAoMCwgW2luZGV4LCBPW2luZGV4XV0pO1xufSwgJ3ZhbHVlcycpO1xuXG4vLyBhcmd1bWVudHNMaXN0W0BAaXRlcmF0b3JdIGlzICVBcnJheVByb3RvX3ZhbHVlcyUgKDkuNC40LjYsIDkuNC40LjcpXG5JdGVyYXRvcnMuQXJndW1lbnRzID0gSXRlcmF0b3JzLkFycmF5O1xuXG5hZGRUb1Vuc2NvcGFibGVzKCdrZXlzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCd2YWx1ZXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ2VudHJpZXMnKTsiLCIvLyAxOS4xLjMuMSBPYmplY3QuYXNzaWduKHRhcmdldCwgc291cmNlKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuLyQuZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GLCAnT2JqZWN0Jywge2Fzc2lnbjogcmVxdWlyZSgnLi8kLm9iamVjdC1hc3NpZ24nKX0pOyIsIi8vIDE5LjEuMi41IE9iamVjdC5mcmVlemUoTylcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vJC5pcy1vYmplY3QnKTtcblxucmVxdWlyZSgnLi8kLm9iamVjdC1zYXAnKSgnZnJlZXplJywgZnVuY3Rpb24oJGZyZWV6ZSl7XG4gIHJldHVybiBmdW5jdGlvbiBmcmVlemUoaXQpe1xuICAgIHJldHVybiAkZnJlZXplICYmIGlzT2JqZWN0KGl0KSA/ICRmcmVlemUoaXQpIDogaXQ7XG4gIH07XG59KTsiLCIvLyAxOS4xLjIuMTQgT2JqZWN0LmtleXMoTylcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vJC50by1vYmplY3QnKTtcblxucmVxdWlyZSgnLi8kLm9iamVjdC1zYXAnKSgna2V5cycsIGZ1bmN0aW9uKCRrZXlzKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGtleXMoaXQpe1xuICAgIHJldHVybiAka2V5cyh0b09iamVjdChpdCkpO1xuICB9O1xufSk7IiwiLy8gMTkuMS4zLjE5IE9iamVjdC5zZXRQcm90b3R5cGVPZihPLCBwcm90bylcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi8kLmV4cG9ydCcpO1xuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7c2V0UHJvdG90eXBlT2Y6IHJlcXVpcmUoJy4vJC5zZXQtcHJvdG8nKS5zZXR9KTsiLG51bGwsIid1c2Ugc3RyaWN0JztcbnZhciAkICAgICAgICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCBMSUJSQVJZICAgID0gcmVxdWlyZSgnLi8kLmxpYnJhcnknKVxuICAsIGdsb2JhbCAgICAgPSByZXF1aXJlKCcuLyQuZ2xvYmFsJylcbiAgLCBjdHggICAgICAgID0gcmVxdWlyZSgnLi8kLmN0eCcpXG4gICwgY2xhc3NvZiAgICA9IHJlcXVpcmUoJy4vJC5jbGFzc29mJylcbiAgLCAkZXhwb3J0ICAgID0gcmVxdWlyZSgnLi8kLmV4cG9ydCcpXG4gICwgaXNPYmplY3QgICA9IHJlcXVpcmUoJy4vJC5pcy1vYmplY3QnKVxuICAsIGFuT2JqZWN0ICAgPSByZXF1aXJlKCcuLyQuYW4tb2JqZWN0JylcbiAgLCBhRnVuY3Rpb24gID0gcmVxdWlyZSgnLi8kLmEtZnVuY3Rpb24nKVxuICAsIHN0cmljdE5ldyAgPSByZXF1aXJlKCcuLyQuc3RyaWN0LW5ldycpXG4gICwgZm9yT2YgICAgICA9IHJlcXVpcmUoJy4vJC5mb3Itb2YnKVxuICAsIHNldFByb3RvICAgPSByZXF1aXJlKCcuLyQuc2V0LXByb3RvJykuc2V0XG4gICwgc2FtZSAgICAgICA9IHJlcXVpcmUoJy4vJC5zYW1lLXZhbHVlJylcbiAgLCBTUEVDSUVTICAgID0gcmVxdWlyZSgnLi8kLndrcycpKCdzcGVjaWVzJylcbiAgLCBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuLyQuc3BlY2llcy1jb25zdHJ1Y3RvcicpXG4gICwgYXNhcCAgICAgICA9IHJlcXVpcmUoJy4vJC5taWNyb3Rhc2snKVxuICAsIFBST01JU0UgICAgPSAnUHJvbWlzZSdcbiAgLCBwcm9jZXNzICAgID0gZ2xvYmFsLnByb2Nlc3NcbiAgLCBpc05vZGUgICAgID0gY2xhc3NvZihwcm9jZXNzKSA9PSAncHJvY2VzcydcbiAgLCBQICAgICAgICAgID0gZ2xvYmFsW1BST01JU0VdXG4gICwgV3JhcHBlcjtcblxudmFyIHRlc3RSZXNvbHZlID0gZnVuY3Rpb24oc3ViKXtcbiAgdmFyIHRlc3QgPSBuZXcgUChmdW5jdGlvbigpe30pO1xuICBpZihzdWIpdGVzdC5jb25zdHJ1Y3RvciA9IE9iamVjdDtcbiAgcmV0dXJuIFAucmVzb2x2ZSh0ZXN0KSA9PT0gdGVzdDtcbn07XG5cbnZhciBVU0VfTkFUSVZFID0gZnVuY3Rpb24oKXtcbiAgdmFyIHdvcmtzID0gZmFsc2U7XG4gIGZ1bmN0aW9uIFAyKHgpe1xuICAgIHZhciBzZWxmID0gbmV3IFAoeCk7XG4gICAgc2V0UHJvdG8oc2VsZiwgUDIucHJvdG90eXBlKTtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuICB0cnkge1xuICAgIHdvcmtzID0gUCAmJiBQLnJlc29sdmUgJiYgdGVzdFJlc29sdmUoKTtcbiAgICBzZXRQcm90byhQMiwgUCk7XG4gICAgUDIucHJvdG90eXBlID0gJC5jcmVhdGUoUC5wcm90b3R5cGUsIHtjb25zdHJ1Y3Rvcjoge3ZhbHVlOiBQMn19KTtcbiAgICAvLyBhY3R1YWwgRmlyZWZveCBoYXMgYnJva2VuIHN1YmNsYXNzIHN1cHBvcnQsIHRlc3QgdGhhdFxuICAgIGlmKCEoUDIucmVzb2x2ZSg1KS50aGVuKGZ1bmN0aW9uKCl7fSkgaW5zdGFuY2VvZiBQMikpe1xuICAgICAgd29ya3MgPSBmYWxzZTtcbiAgICB9XG4gICAgLy8gYWN0dWFsIFY4IGJ1ZywgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTQxNjJcbiAgICBpZih3b3JrcyAmJiByZXF1aXJlKCcuLyQuZGVzY3JpcHRvcnMnKSl7XG4gICAgICB2YXIgdGhlbmFibGVUaGVuR290dGVuID0gZmFsc2U7XG4gICAgICBQLnJlc29sdmUoJC5zZXREZXNjKHt9LCAndGhlbicsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpeyB0aGVuYWJsZVRoZW5Hb3R0ZW4gPSB0cnVlOyB9XG4gICAgICB9KSk7XG4gICAgICB3b3JrcyA9IHRoZW5hYmxlVGhlbkdvdHRlbjtcbiAgICB9XG4gIH0gY2F0Y2goZSl7IHdvcmtzID0gZmFsc2U7IH1cbiAgcmV0dXJuIHdvcmtzO1xufSgpO1xuXG4vLyBoZWxwZXJzXG52YXIgc2FtZUNvbnN0cnVjdG9yID0gZnVuY3Rpb24oYSwgYil7XG4gIC8vIGxpYnJhcnkgd3JhcHBlciBzcGVjaWFsIGNhc2VcbiAgaWYoTElCUkFSWSAmJiBhID09PSBQICYmIGIgPT09IFdyYXBwZXIpcmV0dXJuIHRydWU7XG4gIHJldHVybiBzYW1lKGEsIGIpO1xufTtcbnZhciBnZXRDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uKEMpe1xuICB2YXIgUyA9IGFuT2JqZWN0KEMpW1NQRUNJRVNdO1xuICByZXR1cm4gUyAhPSB1bmRlZmluZWQgPyBTIDogQztcbn07XG52YXIgaXNUaGVuYWJsZSA9IGZ1bmN0aW9uKGl0KXtcbiAgdmFyIHRoZW47XG4gIHJldHVybiBpc09iamVjdChpdCkgJiYgdHlwZW9mICh0aGVuID0gaXQudGhlbikgPT0gJ2Z1bmN0aW9uJyA/IHRoZW4gOiBmYWxzZTtcbn07XG52YXIgUHJvbWlzZUNhcGFiaWxpdHkgPSBmdW5jdGlvbihDKXtcbiAgdmFyIHJlc29sdmUsIHJlamVjdDtcbiAgdGhpcy5wcm9taXNlID0gbmV3IEMoZnVuY3Rpb24oJCRyZXNvbHZlLCAkJHJlamVjdCl7XG4gICAgaWYocmVzb2x2ZSAhPT0gdW5kZWZpbmVkIHx8IHJlamVjdCAhPT0gdW5kZWZpbmVkKXRocm93IFR5cGVFcnJvcignQmFkIFByb21pc2UgY29uc3RydWN0b3InKTtcbiAgICByZXNvbHZlID0gJCRyZXNvbHZlO1xuICAgIHJlamVjdCAgPSAkJHJlamVjdDtcbiAgfSk7XG4gIHRoaXMucmVzb2x2ZSA9IGFGdW5jdGlvbihyZXNvbHZlKSxcbiAgdGhpcy5yZWplY3QgID0gYUZ1bmN0aW9uKHJlamVjdClcbn07XG52YXIgcGVyZm9ybSA9IGZ1bmN0aW9uKGV4ZWMpe1xuICB0cnkge1xuICAgIGV4ZWMoKTtcbiAgfSBjYXRjaChlKXtcbiAgICByZXR1cm4ge2Vycm9yOiBlfTtcbiAgfVxufTtcbnZhciBub3RpZnkgPSBmdW5jdGlvbihyZWNvcmQsIGlzUmVqZWN0KXtcbiAgaWYocmVjb3JkLm4pcmV0dXJuO1xuICByZWNvcmQubiA9IHRydWU7XG4gIHZhciBjaGFpbiA9IHJlY29yZC5jO1xuICBhc2FwKGZ1bmN0aW9uKCl7XG4gICAgdmFyIHZhbHVlID0gcmVjb3JkLnZcbiAgICAgICwgb2sgICAgPSByZWNvcmQucyA9PSAxXG4gICAgICAsIGkgICAgID0gMDtcbiAgICB2YXIgcnVuID0gZnVuY3Rpb24ocmVhY3Rpb24pe1xuICAgICAgdmFyIGhhbmRsZXIgPSBvayA/IHJlYWN0aW9uLm9rIDogcmVhY3Rpb24uZmFpbFxuICAgICAgICAsIHJlc29sdmUgPSByZWFjdGlvbi5yZXNvbHZlXG4gICAgICAgICwgcmVqZWN0ICA9IHJlYWN0aW9uLnJlamVjdFxuICAgICAgICAsIHJlc3VsdCwgdGhlbjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmKGhhbmRsZXIpe1xuICAgICAgICAgIGlmKCFvaylyZWNvcmQuaCA9IHRydWU7XG4gICAgICAgICAgcmVzdWx0ID0gaGFuZGxlciA9PT0gdHJ1ZSA/IHZhbHVlIDogaGFuZGxlcih2YWx1ZSk7XG4gICAgICAgICAgaWYocmVzdWx0ID09PSByZWFjdGlvbi5wcm9taXNlKXtcbiAgICAgICAgICAgIHJlamVjdChUeXBlRXJyb3IoJ1Byb21pc2UtY2hhaW4gY3ljbGUnKSk7XG4gICAgICAgICAgfSBlbHNlIGlmKHRoZW4gPSBpc1RoZW5hYmxlKHJlc3VsdCkpe1xuICAgICAgICAgICAgdGhlbi5jYWxsKHJlc3VsdCwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9IGVsc2UgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9IGVsc2UgcmVqZWN0KHZhbHVlKTtcbiAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHdoaWxlKGNoYWluLmxlbmd0aCA+IGkpcnVuKGNoYWluW2krK10pOyAvLyB2YXJpYWJsZSBsZW5ndGggLSBjYW4ndCB1c2UgZm9yRWFjaFxuICAgIGNoYWluLmxlbmd0aCA9IDA7XG4gICAgcmVjb3JkLm4gPSBmYWxzZTtcbiAgICBpZihpc1JlamVjdClzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgcHJvbWlzZSA9IHJlY29yZC5wXG4gICAgICAgICwgaGFuZGxlciwgY29uc29sZTtcbiAgICAgIGlmKGlzVW5oYW5kbGVkKHByb21pc2UpKXtcbiAgICAgICAgaWYoaXNOb2RlKXtcbiAgICAgICAgICBwcm9jZXNzLmVtaXQoJ3VuaGFuZGxlZFJlamVjdGlvbicsIHZhbHVlLCBwcm9taXNlKTtcbiAgICAgICAgfSBlbHNlIGlmKGhhbmRsZXIgPSBnbG9iYWwub251bmhhbmRsZWRyZWplY3Rpb24pe1xuICAgICAgICAgIGhhbmRsZXIoe3Byb21pc2U6IHByb21pc2UsIHJlYXNvbjogdmFsdWV9KTtcbiAgICAgICAgfSBlbHNlIGlmKChjb25zb2xlID0gZ2xvYmFsLmNvbnNvbGUpICYmIGNvbnNvbGUuZXJyb3Ipe1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1VuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbicsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSByZWNvcmQuYSA9IHVuZGVmaW5lZDtcbiAgICB9LCAxKTtcbiAgfSk7XG59O1xudmFyIGlzVW5oYW5kbGVkID0gZnVuY3Rpb24ocHJvbWlzZSl7XG4gIHZhciByZWNvcmQgPSBwcm9taXNlLl9kXG4gICAgLCBjaGFpbiAgPSByZWNvcmQuYSB8fCByZWNvcmQuY1xuICAgICwgaSAgICAgID0gMFxuICAgICwgcmVhY3Rpb247XG4gIGlmKHJlY29yZC5oKXJldHVybiBmYWxzZTtcbiAgd2hpbGUoY2hhaW4ubGVuZ3RoID4gaSl7XG4gICAgcmVhY3Rpb24gPSBjaGFpbltpKytdO1xuICAgIGlmKHJlYWN0aW9uLmZhaWwgfHwgIWlzVW5oYW5kbGVkKHJlYWN0aW9uLnByb21pc2UpKXJldHVybiBmYWxzZTtcbiAgfSByZXR1cm4gdHJ1ZTtcbn07XG52YXIgJHJlamVjdCA9IGZ1bmN0aW9uKHZhbHVlKXtcbiAgdmFyIHJlY29yZCA9IHRoaXM7XG4gIGlmKHJlY29yZC5kKXJldHVybjtcbiAgcmVjb3JkLmQgPSB0cnVlO1xuICByZWNvcmQgPSByZWNvcmQuciB8fCByZWNvcmQ7IC8vIHVud3JhcFxuICByZWNvcmQudiA9IHZhbHVlO1xuICByZWNvcmQucyA9IDI7XG4gIHJlY29yZC5hID0gcmVjb3JkLmMuc2xpY2UoKTtcbiAgbm90aWZ5KHJlY29yZCwgdHJ1ZSk7XG59O1xudmFyICRyZXNvbHZlID0gZnVuY3Rpb24odmFsdWUpe1xuICB2YXIgcmVjb3JkID0gdGhpc1xuICAgICwgdGhlbjtcbiAgaWYocmVjb3JkLmQpcmV0dXJuO1xuICByZWNvcmQuZCA9IHRydWU7XG4gIHJlY29yZCA9IHJlY29yZC5yIHx8IHJlY29yZDsgLy8gdW53cmFwXG4gIHRyeSB7XG4gICAgaWYocmVjb3JkLnAgPT09IHZhbHVlKXRocm93IFR5cGVFcnJvcihcIlByb21pc2UgY2FuJ3QgYmUgcmVzb2x2ZWQgaXRzZWxmXCIpO1xuICAgIGlmKHRoZW4gPSBpc1RoZW5hYmxlKHZhbHVlKSl7XG4gICAgICBhc2FwKGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciB3cmFwcGVyID0ge3I6IHJlY29yZCwgZDogZmFsc2V9OyAvLyB3cmFwXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhlbi5jYWxsKHZhbHVlLCBjdHgoJHJlc29sdmUsIHdyYXBwZXIsIDEpLCBjdHgoJHJlamVjdCwgd3JhcHBlciwgMSkpO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICRyZWplY3QuY2FsbCh3cmFwcGVyLCBlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlY29yZC52ID0gdmFsdWU7XG4gICAgICByZWNvcmQucyA9IDE7XG4gICAgICBub3RpZnkocmVjb3JkLCBmYWxzZSk7XG4gICAgfVxuICB9IGNhdGNoKGUpe1xuICAgICRyZWplY3QuY2FsbCh7cjogcmVjb3JkLCBkOiBmYWxzZX0sIGUpOyAvLyB3cmFwXG4gIH1cbn07XG5cbi8vIGNvbnN0cnVjdG9yIHBvbHlmaWxsXG5pZighVVNFX05BVElWRSl7XG4gIC8vIDI1LjQuMy4xIFByb21pc2UoZXhlY3V0b3IpXG4gIFAgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKXtcbiAgICBhRnVuY3Rpb24oZXhlY3V0b3IpO1xuICAgIHZhciByZWNvcmQgPSB0aGlzLl9kID0ge1xuICAgICAgcDogc3RyaWN0TmV3KHRoaXMsIFAsIFBST01JU0UpLCAgICAgICAgIC8vIDwtIHByb21pc2VcbiAgICAgIGM6IFtdLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSBhd2FpdGluZyByZWFjdGlvbnNcbiAgICAgIGE6IHVuZGVmaW5lZCwgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSBjaGVja2VkIGluIGlzVW5oYW5kbGVkIHJlYWN0aW9uc1xuICAgICAgczogMCwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIHN0YXRlXG4gICAgICBkOiBmYWxzZSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gZG9uZVxuICAgICAgdjogdW5kZWZpbmVkLCAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIHZhbHVlXG4gICAgICBoOiBmYWxzZSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gaGFuZGxlZCByZWplY3Rpb25cbiAgICAgIG46IGZhbHNlICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSBub3RpZnlcbiAgICB9O1xuICAgIHRyeSB7XG4gICAgICBleGVjdXRvcihjdHgoJHJlc29sdmUsIHJlY29yZCwgMSksIGN0eCgkcmVqZWN0LCByZWNvcmQsIDEpKTtcbiAgICB9IGNhdGNoKGVycil7XG4gICAgICAkcmVqZWN0LmNhbGwocmVjb3JkLCBlcnIpO1xuICAgIH1cbiAgfTtcbiAgcmVxdWlyZSgnLi8kLnJlZGVmaW5lLWFsbCcpKFAucHJvdG90eXBlLCB7XG4gICAgLy8gMjUuNC41LjMgUHJvbWlzZS5wcm90b3R5cGUudGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZClcbiAgICB0aGVuOiBmdW5jdGlvbiB0aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKXtcbiAgICAgIHZhciByZWFjdGlvbiA9IG5ldyBQcm9taXNlQ2FwYWJpbGl0eShzcGVjaWVzQ29uc3RydWN0b3IodGhpcywgUCkpXG4gICAgICAgICwgcHJvbWlzZSAgPSByZWFjdGlvbi5wcm9taXNlXG4gICAgICAgICwgcmVjb3JkICAgPSB0aGlzLl9kO1xuICAgICAgcmVhY3Rpb24ub2sgICA9IHR5cGVvZiBvbkZ1bGZpbGxlZCA9PSAnZnVuY3Rpb24nID8gb25GdWxmaWxsZWQgOiB0cnVlO1xuICAgICAgcmVhY3Rpb24uZmFpbCA9IHR5cGVvZiBvblJlamVjdGVkID09ICdmdW5jdGlvbicgJiYgb25SZWplY3RlZDtcbiAgICAgIHJlY29yZC5jLnB1c2gocmVhY3Rpb24pO1xuICAgICAgaWYocmVjb3JkLmEpcmVjb3JkLmEucHVzaChyZWFjdGlvbik7XG4gICAgICBpZihyZWNvcmQucylub3RpZnkocmVjb3JkLCBmYWxzZSk7XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9LFxuICAgIC8vIDI1LjQuNS4xIFByb21pc2UucHJvdG90eXBlLmNhdGNoKG9uUmVqZWN0ZWQpXG4gICAgJ2NhdGNoJzogZnVuY3Rpb24ob25SZWplY3RlZCl7XG4gICAgICByZXR1cm4gdGhpcy50aGVuKHVuZGVmaW5lZCwgb25SZWplY3RlZCk7XG4gICAgfVxuICB9KTtcbn1cblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwge1Byb21pc2U6IFB9KTtcbnJlcXVpcmUoJy4vJC5zZXQtdG8tc3RyaW5nLXRhZycpKFAsIFBST01JU0UpO1xucmVxdWlyZSgnLi8kLnNldC1zcGVjaWVzJykoUFJPTUlTRSk7XG5XcmFwcGVyID0gcmVxdWlyZSgnLi8kLmNvcmUnKVtQUk9NSVNFXTtcblxuLy8gc3RhdGljc1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgUFJPTUlTRSwge1xuICAvLyAyNS40LjQuNSBQcm9taXNlLnJlamVjdChyKVxuICByZWplY3Q6IGZ1bmN0aW9uIHJlamVjdChyKXtcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ldyBQcm9taXNlQ2FwYWJpbGl0eSh0aGlzKVxuICAgICAgLCAkJHJlamVjdCAgID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgJCRyZWplY3Qocik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICghVVNFX05BVElWRSB8fCB0ZXN0UmVzb2x2ZSh0cnVlKSksIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjYgUHJvbWlzZS5yZXNvbHZlKHgpXG4gIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoeCl7XG4gICAgLy8gaW5zdGFuY2VvZiBpbnN0ZWFkIG9mIGludGVybmFsIHNsb3QgY2hlY2sgYmVjYXVzZSB3ZSBzaG91bGQgZml4IGl0IHdpdGhvdXQgcmVwbGFjZW1lbnQgbmF0aXZlIFByb21pc2UgY29yZVxuICAgIGlmKHggaW5zdGFuY2VvZiBQICYmIHNhbWVDb25zdHJ1Y3Rvcih4LmNvbnN0cnVjdG9yLCB0aGlzKSlyZXR1cm4geDtcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ldyBQcm9taXNlQ2FwYWJpbGl0eSh0aGlzKVxuICAgICAgLCAkJHJlc29sdmUgID0gY2FwYWJpbGl0eS5yZXNvbHZlO1xuICAgICQkcmVzb2x2ZSh4KTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTtcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIShVU0VfTkFUSVZFICYmIHJlcXVpcmUoJy4vJC5pdGVyLWRldGVjdCcpKGZ1bmN0aW9uKGl0ZXIpe1xuICBQLmFsbChpdGVyKVsnY2F0Y2gnXShmdW5jdGlvbigpe30pO1xufSkpLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC4xIFByb21pc2UuYWxsKGl0ZXJhYmxlKVxuICBhbGw6IGZ1bmN0aW9uIGFsbChpdGVyYWJsZSl7XG4gICAgdmFyIEMgICAgICAgICAgPSBnZXRDb25zdHJ1Y3Rvcih0aGlzKVxuICAgICAgLCBjYXBhYmlsaXR5ID0gbmV3IFByb21pc2VDYXBhYmlsaXR5KEMpXG4gICAgICAsIHJlc29sdmUgICAgPSBjYXBhYmlsaXR5LnJlc29sdmVcbiAgICAgICwgcmVqZWN0ICAgICA9IGNhcGFiaWxpdHkucmVqZWN0XG4gICAgICAsIHZhbHVlcyAgICAgPSBbXTtcbiAgICB2YXIgYWJydXB0ID0gcGVyZm9ybShmdW5jdGlvbigpe1xuICAgICAgZm9yT2YoaXRlcmFibGUsIGZhbHNlLCB2YWx1ZXMucHVzaCwgdmFsdWVzKTtcbiAgICAgIHZhciByZW1haW5pbmcgPSB2YWx1ZXMubGVuZ3RoXG4gICAgICAgICwgcmVzdWx0cyAgID0gQXJyYXkocmVtYWluaW5nKTtcbiAgICAgIGlmKHJlbWFpbmluZykkLmVhY2guY2FsbCh2YWx1ZXMsIGZ1bmN0aW9uKHByb21pc2UsIGluZGV4KXtcbiAgICAgICAgdmFyIGFscmVhZHlDYWxsZWQgPSBmYWxzZTtcbiAgICAgICAgQy5yZXNvbHZlKHByb21pc2UpLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgICAgICAgIGlmKGFscmVhZHlDYWxsZWQpcmV0dXJuO1xuICAgICAgICAgIGFscmVhZHlDYWxsZWQgPSB0cnVlO1xuICAgICAgICAgIHJlc3VsdHNbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgICAgLS1yZW1haW5pbmcgfHwgcmVzb2x2ZShyZXN1bHRzKTtcbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgIH0pO1xuICAgICAgZWxzZSByZXNvbHZlKHJlc3VsdHMpO1xuICAgIH0pO1xuICAgIGlmKGFicnVwdClyZWplY3QoYWJydXB0LmVycm9yKTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9LFxuICAvLyAyNS40LjQuNCBQcm9taXNlLnJhY2UoaXRlcmFibGUpXG4gIHJhY2U6IGZ1bmN0aW9uIHJhY2UoaXRlcmFibGUpe1xuICAgIHZhciBDICAgICAgICAgID0gZ2V0Q29uc3RydWN0b3IodGhpcylcbiAgICAgICwgY2FwYWJpbGl0eSA9IG5ldyBQcm9taXNlQ2FwYWJpbGl0eShDKVxuICAgICAgLCByZWplY3QgICAgID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgdmFyIGFicnVwdCA9IHBlcmZvcm0oZnVuY3Rpb24oKXtcbiAgICAgIGZvck9mKGl0ZXJhYmxlLCBmYWxzZSwgZnVuY3Rpb24ocHJvbWlzZSl7XG4gICAgICAgIEMucmVzb2x2ZShwcm9taXNlKS50aGVuKGNhcGFiaWxpdHkucmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGlmKGFicnVwdClyZWplY3QoYWJydXB0LmVycm9yKTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG52YXIgc3Ryb25nID0gcmVxdWlyZSgnLi8kLmNvbGxlY3Rpb24tc3Ryb25nJyk7XG5cbi8vIDIzLjIgU2V0IE9iamVjdHNcbnJlcXVpcmUoJy4vJC5jb2xsZWN0aW9uJykoJ1NldCcsIGZ1bmN0aW9uKGdldCl7XG4gIHJldHVybiBmdW5jdGlvbiBTZXQoKXsgcmV0dXJuIGdldCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7IH07XG59LCB7XG4gIC8vIDIzLjIuMy4xIFNldC5wcm90b3R5cGUuYWRkKHZhbHVlKVxuICBhZGQ6IGZ1bmN0aW9uIGFkZCh2YWx1ZSl7XG4gICAgcmV0dXJuIHN0cm9uZy5kZWYodGhpcywgdmFsdWUgPSB2YWx1ZSA9PT0gMCA/IDAgOiB2YWx1ZSwgdmFsdWUpO1xuICB9XG59LCBzdHJvbmcpOyIsIid1c2Ugc3RyaWN0JztcbnZhciAkYXQgID0gcmVxdWlyZSgnLi8kLnN0cmluZy1hdCcpKHRydWUpO1xuXG4vLyAyMS4xLjMuMjcgU3RyaW5nLnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXG5yZXF1aXJlKCcuLyQuaXRlci1kZWZpbmUnKShTdHJpbmcsICdTdHJpbmcnLCBmdW5jdGlvbihpdGVyYXRlZCl7XG4gIHRoaXMuX3QgPSBTdHJpbmcoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbi8vIDIxLjEuNS4yLjEgJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcbn0sIGZ1bmN0aW9uKCl7XG4gIHZhciBPICAgICA9IHRoaXMuX3RcbiAgICAsIGluZGV4ID0gdGhpcy5faVxuICAgICwgcG9pbnQ7XG4gIGlmKGluZGV4ID49IE8ubGVuZ3RoKXJldHVybiB7dmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZX07XG4gIHBvaW50ID0gJGF0KE8sIGluZGV4KTtcbiAgdGhpcy5faSArPSBwb2ludC5sZW5ndGg7XG4gIHJldHVybiB7dmFsdWU6IHBvaW50LCBkb25lOiBmYWxzZX07XG59KTsiLCIndXNlIHN0cmljdCc7XG4vLyBFQ01BU2NyaXB0IDYgc3ltYm9scyBzaGltXG52YXIgJCAgICAgICAgICAgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsIGdsb2JhbCAgICAgICAgID0gcmVxdWlyZSgnLi8kLmdsb2JhbCcpXG4gICwgaGFzICAgICAgICAgICAgPSByZXF1aXJlKCcuLyQuaGFzJylcbiAgLCBERVNDUklQVE9SUyAgICA9IHJlcXVpcmUoJy4vJC5kZXNjcmlwdG9ycycpXG4gICwgJGV4cG9ydCAgICAgICAgPSByZXF1aXJlKCcuLyQuZXhwb3J0JylcbiAgLCByZWRlZmluZSAgICAgICA9IHJlcXVpcmUoJy4vJC5yZWRlZmluZScpXG4gICwgJGZhaWxzICAgICAgICAgPSByZXF1aXJlKCcuLyQuZmFpbHMnKVxuICAsIHNoYXJlZCAgICAgICAgID0gcmVxdWlyZSgnLi8kLnNoYXJlZCcpXG4gICwgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuLyQuc2V0LXRvLXN0cmluZy10YWcnKVxuICAsIHVpZCAgICAgICAgICAgID0gcmVxdWlyZSgnLi8kLnVpZCcpXG4gICwgd2tzICAgICAgICAgICAgPSByZXF1aXJlKCcuLyQud2tzJylcbiAgLCBrZXlPZiAgICAgICAgICA9IHJlcXVpcmUoJy4vJC5rZXlvZicpXG4gICwgJG5hbWVzICAgICAgICAgPSByZXF1aXJlKCcuLyQuZ2V0LW5hbWVzJylcbiAgLCBlbnVtS2V5cyAgICAgICA9IHJlcXVpcmUoJy4vJC5lbnVtLWtleXMnKVxuICAsIGlzQXJyYXkgICAgICAgID0gcmVxdWlyZSgnLi8kLmlzLWFycmF5JylcbiAgLCBhbk9iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vJC5hbi1vYmplY3QnKVxuICAsIHRvSU9iamVjdCAgICAgID0gcmVxdWlyZSgnLi8kLnRvLWlvYmplY3QnKVxuICAsIGNyZWF0ZURlc2MgICAgID0gcmVxdWlyZSgnLi8kLnByb3BlcnR5LWRlc2MnKVxuICAsIGdldERlc2MgICAgICAgID0gJC5nZXREZXNjXG4gICwgc2V0RGVzYyAgICAgICAgPSAkLnNldERlc2NcbiAgLCBfY3JlYXRlICAgICAgICA9ICQuY3JlYXRlXG4gICwgZ2V0TmFtZXMgICAgICAgPSAkbmFtZXMuZ2V0XG4gICwgJFN5bWJvbCAgICAgICAgPSBnbG9iYWwuU3ltYm9sXG4gICwgJEpTT04gICAgICAgICAgPSBnbG9iYWwuSlNPTlxuICAsIF9zdHJpbmdpZnkgICAgID0gJEpTT04gJiYgJEpTT04uc3RyaW5naWZ5XG4gICwgc2V0dGVyICAgICAgICAgPSBmYWxzZVxuICAsIEhJRERFTiAgICAgICAgID0gd2tzKCdfaGlkZGVuJylcbiAgLCBpc0VudW0gICAgICAgICA9ICQuaXNFbnVtXG4gICwgU3ltYm9sUmVnaXN0cnkgPSBzaGFyZWQoJ3N5bWJvbC1yZWdpc3RyeScpXG4gICwgQWxsU3ltYm9scyAgICAgPSBzaGFyZWQoJ3N5bWJvbHMnKVxuICAsIHVzZU5hdGl2ZSAgICAgID0gdHlwZW9mICRTeW1ib2wgPT0gJ2Z1bmN0aW9uJ1xuICAsIE9iamVjdFByb3RvICAgID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLy8gZmFsbGJhY2sgZm9yIG9sZCBBbmRyb2lkLCBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9Njg3XG52YXIgc2V0U3ltYm9sRGVzYyA9IERFU0NSSVBUT1JTICYmICRmYWlscyhmdW5jdGlvbigpe1xuICByZXR1cm4gX2NyZWF0ZShzZXREZXNjKHt9LCAnYScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiBzZXREZXNjKHRoaXMsICdhJywge3ZhbHVlOiA3fSkuYTsgfVxuICB9KSkuYSAhPSA3O1xufSkgPyBmdW5jdGlvbihpdCwga2V5LCBEKXtcbiAgdmFyIHByb3RvRGVzYyA9IGdldERlc2MoT2JqZWN0UHJvdG8sIGtleSk7XG4gIGlmKHByb3RvRGVzYylkZWxldGUgT2JqZWN0UHJvdG9ba2V5XTtcbiAgc2V0RGVzYyhpdCwga2V5LCBEKTtcbiAgaWYocHJvdG9EZXNjICYmIGl0ICE9PSBPYmplY3RQcm90bylzZXREZXNjKE9iamVjdFByb3RvLCBrZXksIHByb3RvRGVzYyk7XG59IDogc2V0RGVzYztcblxudmFyIHdyYXAgPSBmdW5jdGlvbih0YWcpe1xuICB2YXIgc3ltID0gQWxsU3ltYm9sc1t0YWddID0gX2NyZWF0ZSgkU3ltYm9sLnByb3RvdHlwZSk7XG4gIHN5bS5fayA9IHRhZztcbiAgREVTQ1JJUFRPUlMgJiYgc2V0dGVyICYmIHNldFN5bWJvbERlc2MoT2JqZWN0UHJvdG8sIHRhZywge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgIGlmKGhhcyh0aGlzLCBISURERU4pICYmIGhhcyh0aGlzW0hJRERFTl0sIHRhZykpdGhpc1tISURERU5dW3RhZ10gPSBmYWxzZTtcbiAgICAgIHNldFN5bWJvbERlc2ModGhpcywgdGFnLCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHN5bTtcbn07XG5cbnZhciBpc1N5bWJvbCA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJztcbn07XG5cbnZhciAkZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBEKXtcbiAgaWYoRCAmJiBoYXMoQWxsU3ltYm9scywga2V5KSl7XG4gICAgaWYoIUQuZW51bWVyYWJsZSl7XG4gICAgICBpZighaGFzKGl0LCBISURERU4pKXNldERlc2MoaXQsIEhJRERFTiwgY3JlYXRlRGVzYygxLCB7fSkpO1xuICAgICAgaXRbSElEREVOXVtrZXldID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSlpdFtISURERU5dW2tleV0gPSBmYWxzZTtcbiAgICAgIEQgPSBfY3JlYXRlKEQsIHtlbnVtZXJhYmxlOiBjcmVhdGVEZXNjKDAsIGZhbHNlKX0pO1xuICAgIH0gcmV0dXJuIHNldFN5bWJvbERlc2MoaXQsIGtleSwgRCk7XG4gIH0gcmV0dXJuIHNldERlc2MoaXQsIGtleSwgRCk7XG59O1xudmFyICRkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhpdCwgUCl7XG4gIGFuT2JqZWN0KGl0KTtcbiAgdmFyIGtleXMgPSBlbnVtS2V5cyhQID0gdG9JT2JqZWN0KFApKVxuICAgICwgaSAgICA9IDBcbiAgICAsIGwgPSBrZXlzLmxlbmd0aFxuICAgICwga2V5O1xuICB3aGlsZShsID4gaSkkZGVmaW5lUHJvcGVydHkoaXQsIGtleSA9IGtleXNbaSsrXSwgUFtrZXldKTtcbiAgcmV0dXJuIGl0O1xufTtcbnZhciAkY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGl0LCBQKXtcbiAgcmV0dXJuIFAgPT09IHVuZGVmaW5lZCA/IF9jcmVhdGUoaXQpIDogJGRlZmluZVByb3BlcnRpZXMoX2NyZWF0ZShpdCksIFApO1xufTtcbnZhciAkcHJvcGVydHlJc0VudW1lcmFibGUgPSBmdW5jdGlvbiBwcm9wZXJ0eUlzRW51bWVyYWJsZShrZXkpe1xuICB2YXIgRSA9IGlzRW51bS5jYWxsKHRoaXMsIGtleSk7XG4gIHJldHVybiBFIHx8ICFoYXModGhpcywga2V5KSB8fCAhaGFzKEFsbFN5bWJvbHMsIGtleSkgfHwgaGFzKHRoaXMsIEhJRERFTikgJiYgdGhpc1tISURERU5dW2tleV1cbiAgICA/IEUgOiB0cnVlO1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGl0LCBrZXkpe1xuICB2YXIgRCA9IGdldERlc2MoaXQgPSB0b0lPYmplY3QoaXQpLCBrZXkpO1xuICBpZihEICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICEoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSkpRC5lbnVtZXJhYmxlID0gdHJ1ZTtcbiAgcmV0dXJuIEQ7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eU5hbWVzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCl7XG4gIHZhciBuYW1lcyAgPSBnZXROYW1lcyh0b0lPYmplY3QoaXQpKVxuICAgICwgcmVzdWx0ID0gW11cbiAgICAsIGkgICAgICA9IDBcbiAgICAsIGtleTtcbiAgd2hpbGUobmFtZXMubGVuZ3RoID4gaSlpZighaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pICYmIGtleSAhPSBISURERU4pcmVzdWx0LnB1c2goa2V5KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgJGdldE93blByb3BlcnR5U3ltYm9scyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5U3ltYm9scyhpdCl7XG4gIHZhciBuYW1lcyAgPSBnZXROYW1lcyh0b0lPYmplY3QoaXQpKVxuICAgICwgcmVzdWx0ID0gW11cbiAgICAsIGkgICAgICA9IDBcbiAgICAsIGtleTtcbiAgd2hpbGUobmFtZXMubGVuZ3RoID4gaSlpZihoYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkpcmVzdWx0LnB1c2goQWxsU3ltYm9sc1trZXldKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgJHN0cmluZ2lmeSA9IGZ1bmN0aW9uIHN0cmluZ2lmeShpdCl7XG4gIGlmKGl0ID09PSB1bmRlZmluZWQgfHwgaXNTeW1ib2woaXQpKXJldHVybjsgLy8gSUU4IHJldHVybnMgc3RyaW5nIG9uIHVuZGVmaW5lZFxuICB2YXIgYXJncyA9IFtpdF1cbiAgICAsIGkgICAgPSAxXG4gICAgLCAkJCAgID0gYXJndW1lbnRzXG4gICAgLCByZXBsYWNlciwgJHJlcGxhY2VyO1xuICB3aGlsZSgkJC5sZW5ndGggPiBpKWFyZ3MucHVzaCgkJFtpKytdKTtcbiAgcmVwbGFjZXIgPSBhcmdzWzFdO1xuICBpZih0eXBlb2YgcmVwbGFjZXIgPT0gJ2Z1bmN0aW9uJykkcmVwbGFjZXIgPSByZXBsYWNlcjtcbiAgaWYoJHJlcGxhY2VyIHx8ICFpc0FycmF5KHJlcGxhY2VyKSlyZXBsYWNlciA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpe1xuICAgIGlmKCRyZXBsYWNlcil2YWx1ZSA9ICRyZXBsYWNlci5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgIGlmKCFpc1N5bWJvbCh2YWx1ZSkpcmV0dXJuIHZhbHVlO1xuICB9O1xuICBhcmdzWzFdID0gcmVwbGFjZXI7XG4gIHJldHVybiBfc3RyaW5naWZ5LmFwcGx5KCRKU09OLCBhcmdzKTtcbn07XG52YXIgYnVnZ3lKU09OID0gJGZhaWxzKGZ1bmN0aW9uKCl7XG4gIHZhciBTID0gJFN5bWJvbCgpO1xuICAvLyBNUyBFZGdlIGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyB7fVxuICAvLyBXZWJLaXQgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIG51bGxcbiAgLy8gVjggdGhyb3dzIG9uIGJveGVkIHN5bWJvbHNcbiAgcmV0dXJuIF9zdHJpbmdpZnkoW1NdKSAhPSAnW251bGxdJyB8fCBfc3RyaW5naWZ5KHthOiBTfSkgIT0gJ3t9JyB8fCBfc3RyaW5naWZ5KE9iamVjdChTKSkgIT0gJ3t9Jztcbn0pO1xuXG4vLyAxOS40LjEuMSBTeW1ib2woW2Rlc2NyaXB0aW9uXSlcbmlmKCF1c2VOYXRpdmUpe1xuICAkU3ltYm9sID0gZnVuY3Rpb24gU3ltYm9sKCl7XG4gICAgaWYoaXNTeW1ib2wodGhpcykpdGhyb3cgVHlwZUVycm9yKCdTeW1ib2wgaXMgbm90IGEgY29uc3RydWN0b3InKTtcbiAgICByZXR1cm4gd3JhcCh1aWQoYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpKTtcbiAgfTtcbiAgcmVkZWZpbmUoJFN5bWJvbC5wcm90b3R5cGUsICd0b1N0cmluZycsIGZ1bmN0aW9uIHRvU3RyaW5nKCl7XG4gICAgcmV0dXJuIHRoaXMuX2s7XG4gIH0pO1xuXG4gIGlzU3ltYm9sID0gZnVuY3Rpb24oaXQpe1xuICAgIHJldHVybiBpdCBpbnN0YW5jZW9mICRTeW1ib2w7XG4gIH07XG5cbiAgJC5jcmVhdGUgICAgID0gJGNyZWF0ZTtcbiAgJC5pc0VudW0gICAgID0gJHByb3BlcnR5SXNFbnVtZXJhYmxlO1xuICAkLmdldERlc2MgICAgPSAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuICAkLnNldERlc2MgICAgPSAkZGVmaW5lUHJvcGVydHk7XG4gICQuc2V0RGVzY3MgICA9ICRkZWZpbmVQcm9wZXJ0aWVzO1xuICAkLmdldE5hbWVzICAgPSAkbmFtZXMuZ2V0ID0gJGdldE93blByb3BlcnR5TmFtZXM7XG4gICQuZ2V0U3ltYm9scyA9ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbiAgaWYoREVTQ1JJUFRPUlMgJiYgIXJlcXVpcmUoJy4vJC5saWJyYXJ5Jykpe1xuICAgIHJlZGVmaW5lKE9iamVjdFByb3RvLCAncHJvcGVydHlJc0VudW1lcmFibGUnLCAkcHJvcGVydHlJc0VudW1lcmFibGUsIHRydWUpO1xuICB9XG59XG5cbnZhciBzeW1ib2xTdGF0aWNzID0ge1xuICAvLyAxOS40LjIuMSBTeW1ib2wuZm9yKGtleSlcbiAgJ2Zvcic6IGZ1bmN0aW9uKGtleSl7XG4gICAgcmV0dXJuIGhhcyhTeW1ib2xSZWdpc3RyeSwga2V5ICs9ICcnKVxuICAgICAgPyBTeW1ib2xSZWdpc3RyeVtrZXldXG4gICAgICA6IFN5bWJvbFJlZ2lzdHJ5W2tleV0gPSAkU3ltYm9sKGtleSk7XG4gIH0sXG4gIC8vIDE5LjQuMi41IFN5bWJvbC5rZXlGb3Ioc3ltKVxuICBrZXlGb3I6IGZ1bmN0aW9uIGtleUZvcihrZXkpe1xuICAgIHJldHVybiBrZXlPZihTeW1ib2xSZWdpc3RyeSwga2V5KTtcbiAgfSxcbiAgdXNlU2V0dGVyOiBmdW5jdGlvbigpeyBzZXR0ZXIgPSB0cnVlOyB9LFxuICB1c2VTaW1wbGU6IGZ1bmN0aW9uKCl7IHNldHRlciA9IGZhbHNlOyB9XG59O1xuLy8gMTkuNC4yLjIgU3ltYm9sLmhhc0luc3RhbmNlXG4vLyAxOS40LjIuMyBTeW1ib2wuaXNDb25jYXRTcHJlYWRhYmxlXG4vLyAxOS40LjIuNCBTeW1ib2wuaXRlcmF0b3Jcbi8vIDE5LjQuMi42IFN5bWJvbC5tYXRjaFxuLy8gMTkuNC4yLjggU3ltYm9sLnJlcGxhY2Vcbi8vIDE5LjQuMi45IFN5bWJvbC5zZWFyY2hcbi8vIDE5LjQuMi4xMCBTeW1ib2wuc3BlY2llc1xuLy8gMTkuNC4yLjExIFN5bWJvbC5zcGxpdFxuLy8gMTkuNC4yLjEyIFN5bWJvbC50b1ByaW1pdGl2ZVxuLy8gMTkuNC4yLjEzIFN5bWJvbC50b1N0cmluZ1RhZ1xuLy8gMTkuNC4yLjE0IFN5bWJvbC51bnNjb3BhYmxlc1xuJC5lYWNoLmNhbGwoKFxuICAnaGFzSW5zdGFuY2UsaXNDb25jYXRTcHJlYWRhYmxlLGl0ZXJhdG9yLG1hdGNoLHJlcGxhY2Usc2VhcmNoLCcgK1xuICAnc3BlY2llcyxzcGxpdCx0b1ByaW1pdGl2ZSx0b1N0cmluZ1RhZyx1bnNjb3BhYmxlcydcbikuc3BsaXQoJywnKSwgZnVuY3Rpb24oaXQpe1xuICB2YXIgc3ltID0gd2tzKGl0KTtcbiAgc3ltYm9sU3RhdGljc1tpdF0gPSB1c2VOYXRpdmUgPyBzeW0gOiB3cmFwKHN5bSk7XG59KTtcblxuc2V0dGVyID0gdHJ1ZTtcblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcsIHtTeW1ib2w6ICRTeW1ib2x9KTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdTeW1ib2wnLCBzeW1ib2xTdGF0aWNzKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhdXNlTmF0aXZlLCAnT2JqZWN0Jywge1xuICAvLyAxOS4xLjIuMiBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG4gIGNyZWF0ZTogJGNyZWF0ZSxcbiAgLy8gMTkuMS4yLjQgT2JqZWN0LmRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpXG4gIGRlZmluZVByb3BlcnR5OiAkZGVmaW5lUHJvcGVydHksXG4gIC8vIDE5LjEuMi4zIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpXG4gIGRlZmluZVByb3BlcnRpZXM6ICRkZWZpbmVQcm9wZXJ0aWVzLFxuICAvLyAxOS4xLjIuNiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApXG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogJGdldE93blByb3BlcnR5RGVzY3JpcHRvcixcbiAgLy8gMTkuMS4yLjcgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcbiAgZ2V0T3duUHJvcGVydHlOYW1lczogJGdldE93blByb3BlcnR5TmFtZXMsXG4gIC8vIDE5LjEuMi44IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoTylcbiAgZ2V0T3duUHJvcGVydHlTeW1ib2xzOiAkZ2V0T3duUHJvcGVydHlTeW1ib2xzXG59KTtcblxuLy8gMjQuMy4yIEpTT04uc3RyaW5naWZ5KHZhbHVlIFssIHJlcGxhY2VyIFssIHNwYWNlXV0pXG4kSlNPTiAmJiAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICghdXNlTmF0aXZlIHx8IGJ1Z2d5SlNPTiksICdKU09OJywge3N0cmluZ2lmeTogJHN0cmluZ2lmeX0pO1xuXG4vLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZygkU3ltYm9sLCAnU3ltYm9sJyk7XG4vLyAyMC4yLjEuOSBNYXRoW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZyhNYXRoLCAnTWF0aCcsIHRydWUpO1xuLy8gMjQuMy4zIEpTT05bQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKGdsb2JhbC5KU09OLCAnSlNPTicsIHRydWUpOyIsIi8vIGh0dHA6Ly9nb28uZ2wvWGtCcmpEXG52YXIgJGV4cG9ydCAgPSByZXF1aXJlKCcuLyQuZXhwb3J0JylcbiAgLCAkZW50cmllcyA9IHJlcXVpcmUoJy4vJC5vYmplY3QtdG8tYXJyYXknKSh0cnVlKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7XG4gIGVudHJpZXM6IGZ1bmN0aW9uIGVudHJpZXMoaXQpe1xuICAgIHJldHVybiAkZW50cmllcyhpdCk7XG4gIH1cbn0pOyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXZpZEJydWFudC9NYXAtU2V0LnByb3RvdHlwZS50b0pTT05cbnZhciAkZXhwb3J0ICA9IHJlcXVpcmUoJy4vJC5leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdTZXQnLCB7dG9KU09OOiByZXF1aXJlKCcuLyQuY29sbGVjdGlvbi10by1qc29uJykoJ1NldCcpfSk7IiwicmVxdWlyZSgnLi9lczYuYXJyYXkuaXRlcmF0b3InKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuLyQuaXRlcmF0b3JzJyk7XG5JdGVyYXRvcnMuTm9kZUxpc3QgPSBJdGVyYXRvcnMuSFRNTENvbGxlY3Rpb24gPSBJdGVyYXRvcnMuQXJyYXk7IiwiLy8gVGhpcyBtZXRob2Qgb2Ygb2J0YWluaW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0IG5lZWRzIHRvIGJlXG4vLyBrZXB0IGlkZW50aWNhbCB0byB0aGUgd2F5IGl0IGlzIG9idGFpbmVkIGluIHJ1bnRpbWUuanNcbnZhciBnID1cbiAgdHlwZW9mIGdsb2JhbCA9PT0gXCJvYmplY3RcIiA/IGdsb2JhbCA6XG4gIHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIgPyB3aW5kb3cgOlxuICB0eXBlb2Ygc2VsZiA9PT0gXCJvYmplY3RcIiA/IHNlbGYgOiB0aGlzO1xuXG4vLyBVc2UgYGdldE93blByb3BlcnR5TmFtZXNgIGJlY2F1c2Ugbm90IGFsbCBicm93c2VycyBzdXBwb3J0IGNhbGxpbmdcbi8vIGBoYXNPd25Qcm9wZXJ0eWAgb24gdGhlIGdsb2JhbCBgc2VsZmAgb2JqZWN0IGluIGEgd29ya2VyLiBTZWUgIzE4My5cbnZhciBoYWRSdW50aW1lID0gZy5yZWdlbmVyYXRvclJ1bnRpbWUgJiZcbiAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZykuaW5kZXhPZihcInJlZ2VuZXJhdG9yUnVudGltZVwiKSA+PSAwO1xuXG4vLyBTYXZlIHRoZSBvbGQgcmVnZW5lcmF0b3JSdW50aW1lIGluIGNhc2UgaXQgbmVlZHMgdG8gYmUgcmVzdG9yZWQgbGF0ZXIuXG52YXIgb2xkUnVudGltZSA9IGhhZFJ1bnRpbWUgJiYgZy5yZWdlbmVyYXRvclJ1bnRpbWU7XG5cbi8vIEZvcmNlIHJlZXZhbHV0YXRpb24gb2YgcnVudGltZS5qcy5cbmcucmVnZW5lcmF0b3JSdW50aW1lID0gdW5kZWZpbmVkO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL3J1bnRpbWVcIik7XG5cbmlmIChoYWRSdW50aW1lKSB7XG4gIC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIHJ1bnRpbWUuXG4gIGcucmVnZW5lcmF0b3JSdW50aW1lID0gb2xkUnVudGltZTtcbn0gZWxzZSB7XG4gIC8vIFJlbW92ZSB0aGUgZ2xvYmFsIHByb3BlcnR5IGFkZGVkIGJ5IHJ1bnRpbWUuanMuXG4gIHRyeSB7XG4gICAgZGVsZXRlIGcucmVnZW5lcmF0b3JSdW50aW1lO1xuICB9IGNhdGNoKGUpIHtcbiAgICBnLnJlZ2VuZXJhdG9yUnVudGltZSA9IHVuZGVmaW5lZDtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IG1vZHVsZS5leHBvcnRzLCBfX2VzTW9kdWxlOiB0cnVlIH07XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBodHRwczovL3Jhdy5naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL21hc3Rlci9MSUNFTlNFIGZpbGUuIEFuXG4gKiBhZGRpdGlvbmFsIGdyYW50IG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW5cbiAqIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIF9TeW1ib2wgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL3N5bWJvbFwiKVtcImRlZmF1bHRcIl07XG5cbnZhciBfT2JqZWN0JGNyZWF0ZSA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2NyZWF0ZVwiKVtcImRlZmF1bHRcIl07XG5cbnZhciBfT2JqZWN0JHNldFByb3RvdHlwZU9mID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZlwiKVtcImRlZmF1bHRcIl07XG5cbnZhciBfUHJvbWlzZSA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvcHJvbWlzZVwiKVtcImRlZmF1bHRcIl07XG5cbiEoZnVuY3Rpb24gKGdsb2JhbCkge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIHVuZGVmaW5lZDsgLy8gTW9yZSBjb21wcmVzc2libGUgdGhhbiB2b2lkIDAuXG4gIHZhciAkU3ltYm9sID0gdHlwZW9mIF9TeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IF9TeW1ib2wgOiB7fTtcbiAgdmFyIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIjtcbiAgdmFyIHRvU3RyaW5nVGFnU3ltYm9sID0gJFN5bWJvbC50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjtcblxuICB2YXIgaW5Nb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiO1xuICB2YXIgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWU7XG4gIGlmIChydW50aW1lKSB7XG4gICAgaWYgKGluTW9kdWxlKSB7XG4gICAgICAvLyBJZiByZWdlbmVyYXRvclJ1bnRpbWUgaXMgZGVmaW5lZCBnbG9iYWxseSBhbmQgd2UncmUgaW4gYSBtb2R1bGUsXG4gICAgICAvLyBtYWtlIHRoZSBleHBvcnRzIG9iamVjdCBpZGVudGljYWwgdG8gcmVnZW5lcmF0b3JSdW50aW1lLlxuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBydW50aW1lO1xuICAgIH1cbiAgICAvLyBEb24ndCBib3RoZXIgZXZhbHVhdGluZyB0aGUgcmVzdCBvZiB0aGlzIGZpbGUgaWYgdGhlIHJ1bnRpbWUgd2FzXG4gICAgLy8gYWxyZWFkeSBkZWZpbmVkIGdsb2JhbGx5LlxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIERlZmluZSB0aGUgcnVudGltZSBnbG9iYWxseSAoYXMgZXhwZWN0ZWQgYnkgZ2VuZXJhdGVkIGNvZGUpIGFzIGVpdGhlclxuICAvLyBtb2R1bGUuZXhwb3J0cyAoaWYgd2UncmUgaW4gYSBtb2R1bGUpIG9yIGEgbmV3LCBlbXB0eSBvYmplY3QuXG4gIHJ1bnRpbWUgPSBnbG9iYWwucmVnZW5lcmF0b3JSdW50aW1lID0gaW5Nb2R1bGUgPyBtb2R1bGUuZXhwb3J0cyA6IHt9O1xuXG4gIGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBJZiBvdXRlckZuIHByb3ZpZGVkLCB0aGVuIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yLlxuICAgIHZhciBnZW5lcmF0b3IgPSBfT2JqZWN0JGNyZWF0ZSgob3V0ZXJGbiB8fCBHZW5lcmF0b3IpLnByb3RvdHlwZSk7XG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7XG5cbiAgICAvLyBUaGUgLl9pbnZva2UgbWV0aG9kIHVuaWZpZXMgdGhlIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzLlxuICAgIGdlbmVyYXRvci5faW52b2tlID0gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcblxuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH1cbiAgcnVudGltZS53cmFwID0gd3JhcDtcblxuICAvLyBUcnkvY2F0Y2ggaGVscGVyIHRvIG1pbmltaXplIGRlb3B0aW1pemF0aW9ucy4gUmV0dXJucyBhIGNvbXBsZXRpb25cbiAgLy8gcmVjb3JkIGxpa2UgY29udGV4dC50cnlFbnRyaWVzW2ldLmNvbXBsZXRpb24uIFRoaXMgaW50ZXJmYWNlIGNvdWxkXG4gIC8vIGhhdmUgYmVlbiAoYW5kIHdhcyBwcmV2aW91c2x5KSBkZXNpZ25lZCB0byB0YWtlIGEgY2xvc3VyZSB0byBiZVxuICAvLyBpbnZva2VkIHdpdGhvdXQgYXJndW1lbnRzLCBidXQgaW4gYWxsIHRoZSBjYXNlcyB3ZSBjYXJlIGFib3V0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBtZXRob2Qgd2Ugd2FudCB0byBjYWxsLCBzbyB0aGVyZSdzIG5vIG5lZWRcbiAgLy8gdG8gY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIG9iamVjdC4gV2UgY2FuIGV2ZW4gZ2V0IGF3YXkgd2l0aCBhc3N1bWluZ1xuICAvLyB0aGUgbWV0aG9kIHRha2VzIGV4YWN0bHkgb25lIGFyZ3VtZW50LCBzaW5jZSB0aGF0IGhhcHBlbnMgdG8gYmUgdHJ1ZVxuICAvLyBpbiBldmVyeSBjYXNlLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHRvdWNoIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBUaGVcbiAgLy8gb25seSBhZGRpdGlvbmFsIGFsbG9jYXRpb24gcmVxdWlyZWQgaXMgdGhlIGNvbXBsZXRpb24gcmVjb3JkLCB3aGljaFxuICAvLyBoYXMgYSBzdGFibGUgc2hhcGUgYW5kIHNvIGhvcGVmdWxseSBzaG91bGQgYmUgY2hlYXAgdG8gYWxsb2NhdGUuXG4gIGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcIm5vcm1hbFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInRocm93XCIsIGFyZzogZXJyIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgPSBcInN1c3BlbmRlZFN0YXJ0XCI7XG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkID0gXCJzdXNwZW5kZWRZaWVsZFwiO1xuICB2YXIgR2VuU3RhdGVFeGVjdXRpbmcgPSBcImV4ZWN1dGluZ1wiO1xuICB2YXIgR2VuU3RhdGVDb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xuXG4gIC8vIFJldHVybmluZyB0aGlzIG9iamVjdCBmcm9tIHRoZSBpbm5lckZuIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXNcbiAgLy8gYnJlYWtpbmcgb3V0IG9mIHRoZSBkaXNwYXRjaCBzd2l0Y2ggc3RhdGVtZW50LlxuICB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9O1xuXG4gIC8vIER1bW15IGNvbnN0cnVjdG9yIGZ1bmN0aW9ucyB0aGF0IHdlIHVzZSBhcyB0aGUgLmNvbnN0cnVjdG9yIGFuZFxuICAvLyAuY29uc3RydWN0b3IucHJvdG90eXBlIHByb3BlcnRpZXMgZm9yIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcbiAgLy8gbWluaWZpZXIgbm90IHRvIG1hbmdsZSB0aGUgbmFtZXMgb2YgdGhlc2UgdHdvIGZ1bmN0aW9ucy5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9XG5cbiAgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID0gR2VuZXJhdG9yLnByb3RvdHlwZTtcbiAgR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR3AuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvbjtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGVbdG9TdHJpbmdUYWdTeW1ib2xdID0gR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG5cbiAgLy8gSGVscGVyIGZvciBkZWZpbmluZyB0aGUgLm5leHQsIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcyBvZiB0aGVcbiAgLy8gSXRlcmF0b3IgaW50ZXJmYWNlIGluIHRlcm1zIG9mIGEgc2luZ2xlIC5faW52b2tlIG1ldGhvZC5cbiAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkge1xuICAgIFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgIHByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24gKGFyZykge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbiAoZ2VuRnVuKSB7XG4gICAgdmFyIGN0b3IgPSB0eXBlb2YgZ2VuRnVuID09PSBcImZ1bmN0aW9uXCIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiBjdG9yID8gY3RvciA9PT0gR2VuZXJhdG9yRnVuY3Rpb24gfHxcbiAgICAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXG4gICAgLy8gZG8gaXMgdG8gY2hlY2sgaXRzIC5uYW1lIHByb3BlcnR5LlxuICAgIChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkgPT09IFwiR2VuZXJhdG9yRnVuY3Rpb25cIiA6IGZhbHNlO1xuICB9O1xuXG4gIHJ1bnRpbWUubWFyayA9IGZ1bmN0aW9uIChnZW5GdW4pIHtcbiAgICBpZiAoX09iamVjdCRzZXRQcm90b3R5cGVPZikge1xuICAgICAgX09iamVjdCRzZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgICAgaWYgKCEodG9TdHJpbmdUYWdTeW1ib2wgaW4gZ2VuRnVuKSkge1xuICAgICAgICBnZW5GdW5bdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuICAgICAgfVxuICAgIH1cbiAgICBnZW5GdW4ucHJvdG90eXBlID0gX09iamVjdCRjcmVhdGUoR3ApO1xuICAgIHJldHVybiBnZW5GdW47XG4gIH07XG5cbiAgLy8gV2l0aGluIHRoZSBib2R5IG9mIGFueSBhc3luYyBmdW5jdGlvbiwgYGF3YWl0IHhgIGlzIHRyYW5zZm9ybWVkIHRvXG4gIC8vIGB5aWVsZCByZWdlbmVyYXRvclJ1bnRpbWUuYXdyYXAoeClgLCBzbyB0aGF0IHRoZSBydW50aW1lIGNhbiB0ZXN0XG4gIC8vIGB2YWx1ZSBpbnN0YW5jZW9mIEF3YWl0QXJndW1lbnRgIHRvIGRldGVybWluZSBpZiB0aGUgeWllbGRlZCB2YWx1ZSBpc1xuICAvLyBtZWFudCB0byBiZSBhd2FpdGVkLiBTb21lIG1heSBjb25zaWRlciB0aGUgbmFtZSBvZiB0aGlzIG1ldGhvZCB0b29cbiAgLy8gY3V0ZXN5LCBidXQgdGhleSBhcmUgY3VybXVkZ2VvbnMuXG4gIHJ1bnRpbWUuYXdyYXAgPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgcmV0dXJuIG5ldyBBd2FpdEFyZ3VtZW50KGFyZyk7XG4gIH07XG5cbiAgZnVuY3Rpb24gQXdhaXRBcmd1bWVudChhcmcpIHtcbiAgICB0aGlzLmFyZyA9IGFyZztcbiAgfVxuXG4gIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChnZW5lcmF0b3JbbWV0aG9kXSwgZ2VuZXJhdG9yLCBhcmcpO1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgcmVqZWN0KHJlY29yZC5hcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlY29yZC5hcmc7XG4gICAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXdhaXRBcmd1bWVudCkge1xuICAgICAgICAgIHJldHVybiBfUHJvbWlzZS5yZXNvbHZlKHZhbHVlLmFyZykudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgaW52b2tlKFwidGhyb3dcIiwgZXJyLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF9Qcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24gKHVud3JhcHBlZCkge1xuICAgICAgICAgIC8vIFdoZW4gYSB5aWVsZGVkIFByb21pc2UgaXMgcmVzb2x2ZWQsIGl0cyBmaW5hbCB2YWx1ZSBiZWNvbWVzXG4gICAgICAgICAgLy8gdGhlIC52YWx1ZSBvZiB0aGUgUHJvbWlzZTx7dmFsdWUsZG9uZX0+IHJlc3VsdCBmb3IgdGhlXG4gICAgICAgICAgLy8gY3VycmVudCBpdGVyYXRpb24uIElmIHRoZSBQcm9taXNlIGlzIHJlamVjdGVkLCBob3dldmVyLCB0aGVcbiAgICAgICAgICAvLyByZXN1bHQgZm9yIHRoaXMgaXRlcmF0aW9uIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aCB0aGUgc2FtZVxuICAgICAgICAgIC8vIHJlYXNvbi4gTm90ZSB0aGF0IHJlamVjdGlvbnMgb2YgeWllbGRlZCBQcm9taXNlcyBhcmUgbm90XG4gICAgICAgICAgLy8gdGhyb3duIGJhY2sgaW50byB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uLCBhcyBpcyB0aGUgY2FzZVxuICAgICAgICAgIC8vIHdoZW4gYW4gYXdhaXRlZCBQcm9taXNlIGlzIHJlamVjdGVkLiBUaGlzIGRpZmZlcmVuY2UgaW5cbiAgICAgICAgICAvLyBiZWhhdmlvciBiZXR3ZWVuIHlpZWxkIGFuZCBhd2FpdCBpcyBpbXBvcnRhbnQsIGJlY2F1c2UgaXRcbiAgICAgICAgICAvLyBhbGxvd3MgdGhlIGNvbnN1bWVyIHRvIGRlY2lkZSB3aGF0IHRvIGRvIHdpdGggdGhlIHlpZWxkZWRcbiAgICAgICAgICAvLyByZWplY3Rpb24gKHN3YWxsb3cgaXQgYW5kIGNvbnRpbnVlLCBtYW51YWxseSAudGhyb3cgaXQgYmFja1xuICAgICAgICAgIC8vIGludG8gdGhlIGdlbmVyYXRvciwgYWJhbmRvbiBpdGVyYXRpb24sIHdoYXRldmVyKS4gV2l0aFxuICAgICAgICAgIC8vIGF3YWl0LCBieSBjb250cmFzdCwgdGhlcmUgaXMgbm8gb3Bwb3J0dW5pdHkgdG8gZXhhbWluZSB0aGVcbiAgICAgICAgICAvLyByZWplY3Rpb24gcmVhc29uIG91dHNpZGUgdGhlIGdlbmVyYXRvciBmdW5jdGlvbiwgc28gdGhlXG4gICAgICAgICAgLy8gb25seSBvcHRpb24gaXMgdG8gdGhyb3cgaXQgZnJvbSB0aGUgYXdhaXQgZXhwcmVzc2lvbiwgYW5kXG4gICAgICAgICAgLy8gbGV0IHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24gaGFuZGxlIHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmVzdWx0LnZhbHVlID0gdW53cmFwcGVkO1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgPT09IFwib2JqZWN0XCIgJiYgcHJvY2Vzcy5kb21haW4pIHtcbiAgICAgIGludm9rZSA9IHByb2Nlc3MuZG9tYWluLmJpbmQoaW52b2tlKTtcbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXNQcm9taXNlO1xuXG4gICAgZnVuY3Rpb24gZW5xdWV1ZShtZXRob2QsIGFyZykge1xuICAgICAgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7XG4gICAgICAgIHJldHVybiBuZXcgX1Byb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmV2aW91c1Byb21pc2UgPVxuICAgICAgLy8gSWYgZW5xdWV1ZSBoYXMgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gd2FpdCB1bnRpbFxuICAgICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXG4gICAgICAvLyBzbyB0aGF0IHJlc3VsdHMgYXJlIGFsd2F5cyBkZWxpdmVyZWQgaW4gdGhlIGNvcnJlY3Qgb3JkZXIuIElmXG4gICAgICAvLyBlbnF1ZXVlIGhhcyBub3QgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIGl0IGlzIGltcG9ydGFudCB0b1xuICAgICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXG4gICAgICAvLyBzbyB0aGF0IHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gaGFzIHRoZSBvcHBvcnR1bml0eSB0byBkb1xuICAgICAgLy8gYW55IG5lY2Vzc2FyeSBzZXR1cCBpbiBhIHByZWRpY3RhYmxlIHdheS4gVGhpcyBwcmVkaWN0YWJpbGl0eVxuICAgICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcbiAgICAgIC8vIGV4ZWN1dG9yIGNhbGxiYWNrLCBhbmQgd2h5IGFzeW5jIGZ1bmN0aW9ucyBzeW5jaHJvbm91c2x5XG4gICAgICAvLyBleGVjdXRlIGNvZGUgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdC4gU2luY2Ugd2UgaW1wbGVtZW50IHNpbXBsZVxuICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcbiAgICAgIC8vIGltcG9ydGFudCB0byBnZXQgdGhpcyByaWdodCwgZXZlbiB0aG91Z2ggaXQgcmVxdWlyZXMgY2FyZS5cbiAgICAgIHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLFxuICAgICAgLy8gQXZvaWQgcHJvcGFnYXRpbmcgZmFpbHVyZXMgdG8gUHJvbWlzZXMgcmV0dXJuZWQgYnkgbGF0ZXJcbiAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKSA6IGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCk7XG4gICAgfVxuXG4gICAgLy8gRGVmaW5lIHRoZSB1bmlmaWVkIGhlbHBlciBtZXRob2QgdGhhdCBpcyB1c2VkIHRvIGltcGxlbWVudCAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIChzZWUgZGVmaW5lSXRlcmF0b3JNZXRob2RzKS5cbiAgICB0aGlzLl9pbnZva2UgPSBlbnF1ZXVlO1xuICB9XG5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKTtcblxuICAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxuICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cbiAgcnVudGltZS5hc3luYyA9IGZ1bmN0aW9uIChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIHZhciBpdGVyID0gbmV3IEFzeW5jSXRlcmF0b3Iod3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkpO1xuXG4gICAgcmV0dXJuIHJ1bnRpbWUuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKSA/IGl0ZXIgLy8gSWYgb3V0ZXJGbiBpcyBhIGdlbmVyYXRvciwgcmV0dXJuIHRoZSBmdWxsIGl0ZXJhdG9yLlxuICAgIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTtcbiAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHtcbiAgICB2YXIgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykge1xuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUV4ZWN1dGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlQ29tcGxldGVkKSB7XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJlIGZvcmdpdmluZywgcGVyIDI1LjMuMy4zLjMgb2YgdGhlIHNwZWM6XG4gICAgICAgIC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1nZW5lcmF0b3JyZXN1bWVcbiAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcbiAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJyZXR1cm5cIiB8fCBtZXRob2QgPT09IFwidGhyb3dcIiAmJiBkZWxlZ2F0ZS5pdGVyYXRvclttZXRob2RdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIEEgcmV0dXJuIG9yIHRocm93ICh3aGVuIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgbm8gdGhyb3dcbiAgICAgICAgICAgIC8vIG1ldGhvZCkgYWx3YXlzIHRlcm1pbmF0ZXMgdGhlIHlpZWxkKiBsb29wLlxuICAgICAgICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgYSByZXR1cm4gbWV0aG9kLCBnaXZlIGl0IGFcbiAgICAgICAgICAgIC8vIGNoYW5jZSB0byBjbGVhbiB1cC5cbiAgICAgICAgICAgIHZhciByZXR1cm5NZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvcltcInJldHVyblwiXTtcbiAgICAgICAgICAgIGlmIChyZXR1cm5NZXRob2QpIHtcbiAgICAgICAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKHJldHVybk1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGFyZyk7XG4gICAgICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHJldHVybiBtZXRob2QgdGhyZXcgYW4gZXhjZXB0aW9uLCBsZXQgdGhhdFxuICAgICAgICAgICAgICAgIC8vIGV4Y2VwdGlvbiBwcmV2YWlsIG92ZXIgdGhlIG9yaWdpbmFsIHJldHVybiBvciB0aHJvdy5cbiAgICAgICAgICAgICAgICBtZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgICAgICAgYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobWV0aG9kID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgICAgIC8vIENvbnRpbnVlIHdpdGggdGhlIG91dGVyIHJldHVybiwgbm93IHRoYXQgdGhlIGRlbGVnYXRlXG4gICAgICAgICAgICAgIC8vIGl0ZXJhdG9yIGhhcyBiZWVuIHRlcm1pbmF0ZWQuXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChkZWxlZ2F0ZS5pdGVyYXRvclttZXRob2RdLCBkZWxlZ2F0ZS5pdGVyYXRvciwgYXJnKTtcblxuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgICAgICAgLy8gTGlrZSByZXR1cm5pbmcgZ2VuZXJhdG9yLnRocm93KHVuY2F1Z2h0KSwgYnV0IHdpdGhvdXQgdGhlXG4gICAgICAgICAgICAvLyBvdmVyaGVhZCBvZiBhbiBleHRyYSBmdW5jdGlvbiBjYWxsLlxuICAgICAgICAgICAgbWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgICAgYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIERlbGVnYXRlIGdlbmVyYXRvciByYW4gYW5kIGhhbmRsZWQgaXRzIG93biBleGNlcHRpb25zIHNvXG4gICAgICAgICAgLy8gcmVnYXJkbGVzcyBvZiB3aGF0IHRoZSBtZXRob2Qgd2FzLCB3ZSBjb250aW51ZSBhcyBpZiBpdCBpc1xuICAgICAgICAgIC8vIFwibmV4dFwiIHdpdGggYW4gdW5kZWZpbmVkIGFyZy5cbiAgICAgICAgICBtZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICBhcmcgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICB2YXIgaW5mbyA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7XG4gICAgICAgICAgICBjb250ZXh0Lm5leHQgPSBkZWxlZ2F0ZS5uZXh0TG9jO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XG4gICAgICAgICAgICByZXR1cm4gaW5mbztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkKSB7XG4gICAgICAgICAgICBjb250ZXh0LnNlbnQgPSBhcmc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRleHQuc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgICB0aHJvdyBhcmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oYXJnKSkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIGRpc3BhdGNoZWQgZXhjZXB0aW9uIHdhcyBjYXVnaHQgYnkgYSBjYXRjaCBibG9jayxcbiAgICAgICAgICAgIC8vIHRoZW4gbGV0IHRoYXQgY2F0Y2ggYmxvY2sgaGFuZGxlIHRoZSBleGNlcHRpb24gbm9ybWFsbHkuXG4gICAgICAgICAgICBtZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICAgIGFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobWV0aG9kID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgYXJnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlID0gR2VuU3RhdGVFeGVjdXRpbmc7XG5cbiAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIpIHtcbiAgICAgICAgICAvLyBJZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIGZyb20gaW5uZXJGbiwgd2UgbGVhdmUgc3RhdGUgPT09XG4gICAgICAgICAgLy8gR2VuU3RhdGVFeGVjdXRpbmcgYW5kIGxvb3AgYmFjayBmb3IgYW5vdGhlciBpbnZvY2F0aW9uLlxuICAgICAgICAgIHN0YXRlID0gY29udGV4dC5kb25lID8gR2VuU3RhdGVDb21wbGV0ZWQgOiBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuXG4gICAgICAgICAgdmFyIGluZm8gPSB7XG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcbiAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAocmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkge1xuICAgICAgICAgICAgaWYgKGNvbnRleHQuZGVsZWdhdGUgJiYgbWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgICAgICAvLyBEZWxpYmVyYXRlbHkgZm9yZ2V0IHRoZSBsYXN0IHNlbnQgdmFsdWUgc28gdGhhdCB3ZSBkb24ndFxuICAgICAgICAgICAgICAvLyBhY2NpZGVudGFsbHkgcGFzcyBpdCBvbiB0byB0aGUgZGVsZWdhdGUuXG4gICAgICAgICAgICAgIGFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGluZm87XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgIC8vIERpc3BhdGNoIHRoZSBleGNlcHRpb24gYnkgbG9vcGluZyBiYWNrIGFyb3VuZCB0byB0aGVcbiAgICAgICAgICAvLyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGFyZykgY2FsbCBhYm92ZS5cbiAgICAgICAgICBtZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XG5cbiAgR3BbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEdwW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFwiR2VuZXJhdG9yXCI7XG5cbiAgR3AudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gIH07XG5cbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcbiAgICB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9O1xuXG4gICAgaWYgKDEgaW4gbG9jcykge1xuICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xuICAgIH1cblxuICAgIGlmICgyIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xuICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xuICAgIH1cblxuICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcbiAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICByZWNvcmQudHlwZSA9IFwibm9ybWFsXCI7XG4gICAgZGVsZXRlIHJlY29yZC5hcmc7XG4gICAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBUaGUgcm9vdCBlbnRyeSBvYmplY3QgKGVmZmVjdGl2ZWx5IGEgdHJ5IHN0YXRlbWVudCB3aXRob3V0IGEgY2F0Y2hcbiAgICAvLyBvciBhIGZpbmFsbHkgYmxvY2spIGdpdmVzIHVzIGEgcGxhY2UgdG8gc3RvcmUgdmFsdWVzIHRocm93biBmcm9tXG4gICAgLy8gbG9jYXRpb25zIHdoZXJlIHRoZXJlIGlzIG5vIGVuY2xvc2luZyB0cnkgc3RhdGVtZW50LlxuICAgIHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXCJyb290XCIgfV07XG4gICAgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpO1xuICAgIHRoaXMucmVzZXQodHJ1ZSk7XG4gIH1cblxuICBydW50aW1lLmtleXMgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gICAga2V5cy5yZXZlcnNlKCk7XG5cbiAgICAvLyBSYXRoZXIgdGhhbiByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggYSBuZXh0IG1ldGhvZCwgd2Uga2VlcFxuICAgIC8vIHRoaW5ncyBzaW1wbGUgYW5kIHJldHVybiB0aGUgbmV4dCBmdW5jdGlvbiBpdHNlbGYuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXMucG9wKCk7XG4gICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgbmV4dC52YWx1ZSA9IGtleTtcbiAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUbyBhdm9pZCBjcmVhdGluZyBhbiBhZGRpdGlvbmFsIG9iamVjdCwgd2UganVzdCBoYW5nIHRoZSAudmFsdWVcbiAgICAgIC8vIGFuZCAuZG9uZSBwcm9wZXJ0aWVzIG9mZiB0aGUgbmV4dCBmdW5jdGlvbiBvYmplY3QgaXRzZWxmLiBUaGlzXG4gICAgICAvLyBhbHNvIGVuc3VyZXMgdGhhdCB0aGUgbWluaWZpZXIgd2lsbCBub3QgYW5vbnltaXplIHRoZSBmdW5jdGlvbi5cbiAgICAgIG5leHQuZG9uZSA9IHRydWU7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdO1xuICAgICAgaWYgKGl0ZXJhdG9yTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYWJsZS5uZXh0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIGkgPSAtMSxcbiAgICAgICAgICAgIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgIHdoaWxlICgrK2kgPCBpdGVyYWJsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHtcbiAgICAgICAgICAgICAgbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldO1xuICAgICAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV4dC52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGFuIGl0ZXJhdG9yIHdpdGggbm8gdmFsdWVzLlxuICAgIHJldHVybiB7IG5leHQ6IGRvbmVSZXN1bHQgfTtcbiAgfVxuICBydW50aW1lLnZhbHVlcyA9IHZhbHVlcztcblxuICBmdW5jdGlvbiBkb25lUmVzdWx0KCkge1xuICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgfVxuXG4gIENvbnRleHQucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBDb250ZXh0LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uIHJlc2V0KHNraXBUZW1wUmVzZXQpIHtcbiAgICAgIHRoaXMucHJldiA9IDA7XG4gICAgICB0aGlzLm5leHQgPSAwO1xuICAgICAgdGhpcy5zZW50ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICB0aGlzLmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG5cbiAgICAgIGlmICghc2tpcFRlbXBSZXNldCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxuICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXCJ0XCIgJiYgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiYgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG5cbiAgICAgIHZhciByb290RW50cnkgPSB0aGlzLnRyeUVudHJpZXNbMF07XG4gICAgICB2YXIgcm9vdFJlY29yZCA9IHJvb3RFbnRyeS5jb21wbGV0aW9uO1xuICAgICAgaWYgKHJvb3RSZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJvb3RSZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5ydmFsO1xuICAgIH0sXG5cbiAgICBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24gZGlzcGF0Y2hFeGNlcHRpb24oZXhjZXB0aW9uKSB7XG4gICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuICAgICAgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7XG4gICAgICAgIHJlY29yZC50eXBlID0gXCJ0aHJvd1wiO1xuICAgICAgICByZWNvcmQuYXJnID0gZXhjZXB0aW9uO1xuICAgICAgICBjb250ZXh0Lm5leHQgPSBsb2M7XG4gICAgICAgIHJldHVybiAhIWNhdWdodDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IFwicm9vdFwiKSB7XG4gICAgICAgICAgLy8gRXhjZXB0aW9uIHRocm93biBvdXRzaWRlIG9mIGFueSB0cnkgYmxvY2sgdGhhdCBjb3VsZCBoYW5kbGVcbiAgICAgICAgICAvLyBpdCwgc28gc2V0IHRoZSBjb21wbGV0aW9uIHZhbHVlIG9mIHRoZSBlbnRpcmUgZnVuY3Rpb24gdG9cbiAgICAgICAgICAvLyB0aHJvdyB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJldHVybiBoYW5kbGUoXCJlbmRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikge1xuICAgICAgICAgIHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpO1xuICAgICAgICAgIHZhciBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKTtcblxuICAgICAgICAgIGlmIChoYXNDYXRjaCAmJiBoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYWJydXB0OiBmdW5jdGlvbiBhYnJ1cHQodHlwZSwgYXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiYgaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKSAmJiB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkgJiYgKHR5cGUgPT09IFwiYnJlYWtcIiB8fCB0eXBlID09PSBcImNvbnRpbnVlXCIpICYmIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAvLyBJZ25vcmUgdGhlIGZpbmFsbHkgZW50cnkgaWYgY29udHJvbCBpcyBub3QganVtcGluZyB0byBhXG4gICAgICAgIC8vIGxvY2F0aW9uIG91dHNpZGUgdGhlIHRyeS9jYXRjaCBibG9jay5cbiAgICAgICAgZmluYWxseUVudHJ5ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307XG4gICAgICByZWNvcmQudHlwZSA9IHR5cGU7XG4gICAgICByZWNvcmQuYXJnID0gYXJnO1xuXG4gICAgICBpZiAoZmluYWxseUVudHJ5KSB7XG4gICAgICAgIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9LFxuXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uIGNvbXBsZXRlKHJlY29yZCwgYWZ0ZXJMb2MpIHtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJicmVha1wiIHx8IHJlY29yZC50eXBlID09PSBcImNvbnRpbnVlXCIpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gcmVjb3JkLmFyZztcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgdGhpcy5ydmFsID0gcmVjb3JkLmFyZztcbiAgICAgICAgdGhpcy5uZXh0ID0gXCJlbmRcIjtcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIgJiYgYWZ0ZXJMb2MpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gYWZ0ZXJMb2M7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24gZmluaXNoKGZpbmFsbHlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykge1xuICAgICAgICAgIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpO1xuICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIFwiY2F0Y2hcIjogZnVuY3Rpb24gX2NhdGNoKHRyeUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IHRyeUxvYykge1xuICAgICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICB2YXIgdGhyb3duID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhyb3duO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBjb250ZXh0LmNhdGNoIG1ldGhvZCBtdXN0IG9ubHkgYmUgY2FsbGVkIHdpdGggYSBsb2NhdGlvblxuICAgICAgLy8gYXJndW1lbnQgdGhhdCBjb3JyZXNwb25kcyB0byBhIGtub3duIGNhdGNoIGJsb2NrLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpO1xuICAgIH0sXG5cbiAgICBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbiBkZWxlZ2F0ZVlpZWxkKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7XG4gICAgICB0aGlzLmRlbGVnYXRlID0ge1xuICAgICAgICBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSxcbiAgICAgICAgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSxcbiAgICAgICAgbmV4dExvYzogbmV4dExvY1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuICB9O1xufSkoXG4vLyBBbW9uZyB0aGUgdmFyaW91cyB0cmlja3MgZm9yIG9idGFpbmluZyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsXG4vLyBvYmplY3QsIHRoaXMgc2VlbXMgdG8gYmUgdGhlIG1vc3QgcmVsaWFibGUgdGVjaG5pcXVlIHRoYXQgZG9lcyBub3Rcbi8vIHVzZSBpbmRpcmVjdCBldmFsICh3aGljaCB2aW9sYXRlcyBDb250ZW50IFNlY3VyaXR5IFBvbGljeSkuXG50eXBlb2YgZ2xvYmFsID09PSBcIm9iamVjdFwiID8gZ2xvYmFsIDogdHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIiA/IHdpbmRvdyA6IHR5cGVvZiBzZWxmID09PSBcIm9iamVjdFwiID8gc2VsZiA6IHVuZGVmaW5lZCk7IiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbnZhciByb290UGFyZW50ID0ge31cblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgVXNlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogRHVlIHRvIHZhcmlvdXMgYnJvd3NlciBidWdzLCBzb21ldGltZXMgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiB3aWxsIGJlIHVzZWQgZXZlblxuICogd2hlbiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0eXBlZCBhcnJheXMuXG4gKlxuICogTm90ZTpcbiAqXG4gKiAgIC0gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWAgaW5zdGFuY2VzLFxuICogICAgIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4LlxuICpcbiAqICAgLSBTYWZhcmkgNS03IGxhY2tzIHN1cHBvcnQgZm9yIGNoYW5naW5nIHRoZSBgT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3RvcmAgcHJvcGVydHlcbiAqICAgICBvbiBvYmplY3RzLlxuICpcbiAqICAgLSBDaHJvbWUgOS0xMCBpcyBtaXNzaW5nIHRoZSBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uLlxuICpcbiAqICAgLSBJRTEwIGhhcyBhIGJyb2tlbiBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYXJyYXlzIG9mXG4gKiAgICAgaW5jb3JyZWN0IGxlbmd0aCBpbiBzb21lIHNpdHVhdGlvbnMuXG5cbiAqIFdlIGRldGVjdCB0aGVzZSBidWdneSBicm93c2VycyBhbmQgc2V0IGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGAgdG8gYGZhbHNlYCBzbyB0aGV5XG4gKiBnZXQgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaXMgc2xvd2VyIGJ1dCBiZWhhdmVzIGNvcnJlY3RseS5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVCAhPT0gdW5kZWZpbmVkXG4gID8gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgOiB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgZnVuY3Rpb24gQmFyICgpIHt9XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgYXJyLmZvbyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH1cbiAgICBhcnIuY29uc3RydWN0b3IgPSBCYXJcbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MiAmJiAvLyB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZFxuICAgICAgICBhcnIuY29uc3RydWN0b3IgPT09IEJhciAmJiAvLyBjb25zdHJ1Y3RvciBjYW4gYmUgc2V0XG4gICAgICAgIHR5cGVvZiBhcnIuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicgJiYgLy8gY2hyb21lIDktMTAgbGFjayBgc3ViYXJyYXlgXG4gICAgICAgIGFyci5zdWJhcnJheSgxLCAxKS5ieXRlTGVuZ3RoID09PSAwIC8vIGllMTAgaGFzIGJyb2tlbiBgc3ViYXJyYXlgXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBrTWF4TGVuZ3RoICgpIHtcbiAgcmV0dXJuIEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gICAgPyAweDdmZmZmZmZmXG4gICAgOiAweDNmZmZmZmZmXG59XG5cbi8qKlxuICogQ2xhc3M6IEJ1ZmZlclxuICogPT09PT09PT09PT09PVxuICpcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgYXJlIGF1Z21lbnRlZFxuICogd2l0aCBmdW5jdGlvbiBwcm9wZXJ0aWVzIGZvciBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgQVBJIGZ1bmN0aW9ucy4gV2UgdXNlXG4gKiBgVWludDhBcnJheWAgc28gdGhhdCBzcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdCByZXR1cm5zXG4gKiBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBCeSBhdWdtZW50aW5nIHRoZSBpbnN0YW5jZXMsIHdlIGNhbiBhdm9pZCBtb2RpZnlpbmcgdGhlIGBVaW50OEFycmF5YFxuICogcHJvdG90eXBlLlxuICovXG5mdW5jdGlvbiBCdWZmZXIgKGFyZykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSkge1xuICAgIC8vIEF2b2lkIGdvaW5nIHRocm91Z2ggYW4gQXJndW1lbnRzQWRhcHRvclRyYW1wb2xpbmUgaW4gdGhlIGNvbW1vbiBjYXNlLlxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkgcmV0dXJuIG5ldyBCdWZmZXIoYXJnLCBhcmd1bWVudHNbMV0pXG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoYXJnKVxuICB9XG5cbiAgdGhpcy5sZW5ndGggPSAwXG4gIHRoaXMucGFyZW50ID0gdW5kZWZpbmVkXG5cbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBmcm9tTnVtYmVyKHRoaXMsIGFyZylcbiAgfVxuXG4gIC8vIFNsaWdodGx5IGxlc3MgY29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHRoaXMsIGFyZywgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiAndXRmOCcpXG4gIH1cblxuICAvLyBVbnVzdWFsLlxuICByZXR1cm4gZnJvbU9iamVjdCh0aGlzLCBhcmcpXG59XG5cbmZ1bmN0aW9uIGZyb21OdW1iZXIgKHRoYXQsIGxlbmd0aCkge1xuICB0aGF0ID0gYWxsb2NhdGUodGhhdCwgbGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGxlbmd0aCkgfCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdGhhdFtpXSA9IDBcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAodGhhdCwgc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgLy8gQXNzdW1wdGlvbjogYnl0ZUxlbmd0aCgpIHJldHVybiB2YWx1ZSBpcyBhbHdheXMgPCBrTWF4TGVuZ3RoLlxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdGhhdCA9IGFsbG9jYXRlKHRoYXQsIGxlbmd0aClcblxuICB0aGF0LndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKHRoYXQsIG9iamVjdCkge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iamVjdCkpIHJldHVybiBmcm9tQnVmZmVyKHRoYXQsIG9iamVjdClcblxuICBpZiAoaXNBcnJheShvYmplY3QpKSByZXR1cm4gZnJvbUFycmF5KHRoYXQsIG9iamVjdClcblxuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtdXN0IHN0YXJ0IHdpdGggbnVtYmVyLCBidWZmZXIsIGFycmF5IG9yIHN0cmluZycpXG4gIH1cblxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmIChvYmplY3QuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgIHJldHVybiBmcm9tVHlwZWRBcnJheSh0aGF0LCBvYmplY3QpXG4gICAgfVxuICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih0aGF0LCBvYmplY3QpXG4gICAgfVxuICB9XG5cbiAgaWYgKG9iamVjdC5sZW5ndGgpIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iamVjdClcblxuICByZXR1cm4gZnJvbUpzb25PYmplY3QodGhhdCwgb2JqZWN0KVxufVxuXG5mdW5jdGlvbiBmcm9tQnVmZmVyICh0aGF0LCBidWZmZXIpIHtcbiAgdmFyIGxlbmd0aCA9IGNoZWNrZWQoYnVmZmVyLmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBhbGxvY2F0ZSh0aGF0LCBsZW5ndGgpXG4gIGJ1ZmZlci5jb3B5KHRoYXQsIDAsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5ICh0aGF0LCBhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB0aGF0ID0gYWxsb2NhdGUodGhhdCwgbGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuLy8gRHVwbGljYXRlIG9mIGZyb21BcnJheSgpIHRvIGtlZXAgZnJvbUFycmF5KCkgbW9ub21vcnBoaWMuXG5mdW5jdGlvbiBmcm9tVHlwZWRBcnJheSAodGhhdCwgYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGFsbG9jYXRlKHRoYXQsIGxlbmd0aClcbiAgLy8gVHJ1bmNhdGluZyB0aGUgZWxlbWVudHMgaXMgcHJvYmFibHkgbm90IHdoYXQgcGVvcGxlIGV4cGVjdCBmcm9tIHR5cGVkXG4gIC8vIGFycmF5cyB3aXRoIEJZVEVTX1BFUl9FTEVNRU5UID4gMSBidXQgaXQncyBjb21wYXRpYmxlIHdpdGggdGhlIGJlaGF2aW9yXG4gIC8vIG9mIHRoZSBvbGQgQnVmZmVyIGNvbnN0cnVjdG9yLlxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyICh0aGF0LCBhcnJheSkge1xuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICBhcnJheS5ieXRlTGVuZ3RoXG4gICAgdGhhdCA9IEJ1ZmZlci5fYXVnbWVudChuZXcgVWludDhBcnJheShhcnJheSkpXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIHRoYXQgPSBmcm9tVHlwZWRBcnJheSh0aGF0LCBuZXcgVWludDhBcnJheShhcnJheSkpXG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAodGhhdCwgYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGFsbG9jYXRlKHRoYXQsIGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbi8vIERlc2VyaWFsaXplIHsgdHlwZTogJ0J1ZmZlcicsIGRhdGE6IFsxLDIsMywuLi5dIH0gaW50byBhIEJ1ZmZlciBvYmplY3QuXG4vLyBSZXR1cm5zIGEgemVyby1sZW5ndGggYnVmZmVyIGZvciBpbnB1dHMgdGhhdCBkb24ndCBjb25mb3JtIHRvIHRoZSBzcGVjLlxuZnVuY3Rpb24gZnJvbUpzb25PYmplY3QgKHRoYXQsIG9iamVjdCkge1xuICB2YXIgYXJyYXlcbiAgdmFyIGxlbmd0aCA9IDBcblxuICBpZiAob2JqZWN0LnR5cGUgPT09ICdCdWZmZXInICYmIGlzQXJyYXkob2JqZWN0LmRhdGEpKSB7XG4gICAgYXJyYXkgPSBvYmplY3QuZGF0YVxuICAgIGxlbmd0aCA9IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgfVxuICB0aGF0ID0gYWxsb2NhdGUodGhhdCwgbGVuZ3RoKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5pZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgQnVmZmVyLnByb3RvdHlwZS5fX3Byb3RvX18gPSBVaW50OEFycmF5LnByb3RvdHlwZVxuICBCdWZmZXIuX19wcm90b19fID0gVWludDhBcnJheVxufVxuXG5mdW5jdGlvbiBhbGxvY2F0ZSAodGhhdCwgbGVuZ3RoKSB7XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBCdWZmZXIuX2F1Z21lbnQobmV3IFVpbnQ4QXJyYXkobGVuZ3RoKSlcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgdGhhdC5sZW5ndGggPSBsZW5ndGhcbiAgICB0aGF0Ll9pc0J1ZmZlciA9IHRydWVcbiAgfVxuXG4gIHZhciBmcm9tUG9vbCA9IGxlbmd0aCAhPT0gMCAmJiBsZW5ndGggPD0gQnVmZmVyLnBvb2xTaXplID4+PiAxXG4gIGlmIChmcm9tUG9vbCkgdGhhdC5wYXJlbnQgPSByb290UGFyZW50XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IGtNYXhMZW5ndGhgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0ga01heExlbmd0aCgpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIGtNYXhMZW5ndGgoKS50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChzdWJqZWN0LCBlbmNvZGluZykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU2xvd0J1ZmZlcikpIHJldHVybiBuZXcgU2xvd0J1ZmZlcihzdWJqZWN0LCBlbmNvZGluZylcblxuICB2YXIgYnVmID0gbmV3IEJ1ZmZlcihzdWJqZWN0LCBlbmNvZGluZylcbiAgZGVsZXRlIGJ1Zi5wYXJlbnRcbiAgcmV0dXJuIGJ1ZlxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG5cbiAgdmFyIGkgPSAwXG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSBicmVha1xuXG4gICAgKytpXG4gIH1cblxuICBpZiAoaSAhPT0gbGVuKSB7XG4gICAgeCA9IGFbaV1cbiAgICB5ID0gYltpXVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICdyYXcnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFpc0FycmF5KGxpc3QpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdsaXN0IGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycy4nKVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKDApXG4gIH1cblxuICB2YXIgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWYgPSBuZXcgQnVmZmVyKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IGxpc3RbaV1cbiAgICBpdGVtLmNvcHkoYnVmLCBwb3MpXG4gICAgcG9zICs9IGl0ZW0ubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykgc3RyaW5nID0gJycgKyBzdHJpbmdcblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAobGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgIC8vIERlcHJlY2F0ZWRcbiAgICAgIGNhc2UgJ3Jhdyc6XG4gICAgICBjYXNlICdyYXdzJzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbi8vIHByZS1zZXQgZm9yIHZhbHVlcyB0aGF0IG1heSBleGlzdCBpbiB0aGUgZnV0dXJlXG5CdWZmZXIucHJvdG90eXBlLmxlbmd0aCA9IHVuZGVmaW5lZFxuQnVmZmVyLnByb3RvdHlwZS5wYXJlbnQgPSB1bmRlZmluZWRcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIHN0YXJ0ID0gc3RhcnQgfCAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA9PT0gSW5maW5pdHkgPyB0aGlzLmxlbmd0aCA6IGVuZCB8IDBcblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAoZW5kIDw9IHN0YXJ0KSByZXR1cm4gJydcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBiaW5hcnlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoIHwgMFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkubWF0Y2goLy57Mn0vZykuam9pbignICcpXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIDBcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCkge1xuICBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIGJ5dGVPZmZzZXQgPj49IDBcblxuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiAtMVxuICBpZiAoYnl0ZU9mZnNldCA+PSB0aGlzLmxlbmd0aCkgcmV0dXJuIC0xXG5cbiAgLy8gTmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBNYXRoLm1heCh0aGlzLmxlbmd0aCArIGJ5dGVPZmZzZXQsIDApXG5cbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHJldHVybiAtMSAvLyBzcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZyBhbHdheXMgZmFpbHNcbiAgICByZXR1cm4gU3RyaW5nLnByb3RvdHlwZS5pbmRleE9mLmNhbGwodGhpcywgdmFsLCBieXRlT2Zmc2V0KVxuICB9XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIHJldHVybiBhcnJheUluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0KVxuICB9XG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKHRoaXMsIHZhbCwgYnl0ZU9mZnNldClcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZih0aGlzLCBbIHZhbCBdLCBieXRlT2Zmc2V0KVxuICB9XG5cbiAgZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCkge1xuICAgIHZhciBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKHZhciBpID0gMDsgYnl0ZU9mZnNldCArIGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhcnJbYnl0ZU9mZnNldCArIGldID09PSB2YWxbZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXhdKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsLmxlbmd0aCkgcmV0dXJuIGJ5dGVPZmZzZXQgKyBmb3VuZEluZGV4XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG4vLyBgZ2V0YCBpcyBkZXByZWNhdGVkXG5CdWZmZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAob2Zmc2V0KSB7XG4gIGNvbnNvbGUubG9nKCcuZ2V0KCkgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHVzaW5nIGFycmF5IGluZGV4ZXMgaW5zdGVhZC4nKVxuICByZXR1cm4gdGhpcy5yZWFkVUludDgob2Zmc2V0KVxufVxuXG4vLyBgc2V0YCBpcyBkZXByZWNhdGVkXG5CdWZmZXIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIHNldCAodiwgb2Zmc2V0KSB7XG4gIGNvbnNvbGUubG9nKCcuc2V0KCkgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHVzaW5nIGFycmF5IGluZGV4ZXMgaW5zdGVhZC4nKVxuICByZXR1cm4gdGhpcy53cml0ZVVJbnQ4KHYsIG9mZnNldClcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAoc3RyTGVuICUgMiAhPT0gMCkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChpc05hTihwYXJzZWQpKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiaW5hcnlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCB8IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICAvLyBsZWdhY3kgd3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpIC0gcmVtb3ZlIGluIHYwLjEzXG4gIH0gZWxzZSB7XG4gICAgdmFyIHN3YXAgPSBlbmNvZGluZ1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgb2Zmc2V0ID0gbGVuZ3RoIHwgMFxuICAgIGxlbmd0aCA9IHN3YXBcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdhdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gYmluYXJ5V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICB2YXIgcmVzID0gW11cblxuICB2YXIgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBiaW5hcnlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgYnl0ZXNbaSArIDFdICogMjU2KVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWZcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgbmV3QnVmID0gQnVmZmVyLl9hdWdtZW50KHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCkpXG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnRcbiAgICBuZXdCdWYgPSBuZXcgQnVmZmVyKHNsaWNlTGVuLCB1bmRlZmluZWQpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZUxlbjsgaSsrKSB7XG4gICAgICBuZXdCdWZbaV0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH1cblxuICBpZiAobmV3QnVmLmxlbmd0aCkgbmV3QnVmLnBhcmVudCA9IHRoaXMucGFyZW50IHx8IHRoaXNcblxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aFxuICB2YXIgbXVsID0gMVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2J1ZmZlciBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndmFsdWUgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignaW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCksIDApXG5cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCksIDApXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDIpOyBpIDwgajsgaSsrKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlICYgKDB4ZmYgPDwgKDggKiAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSkpKSA+Pj5cbiAgICAgIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpICogOFxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCA0KTsgaSA8IGo7IGkrKykge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSA+Pj4gKGxpdHRsZUVuZGlhbiA/IGkgOiAzIC0gaSkgKiA4KSAmIDB4ZmZcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSB2YWx1ZSA8IDAgPyAxIDogMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IHZhbHVlIDwgMCA/IDEgOiAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3ZhbHVlIGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignaW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcbiAgdmFyIGlcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHN0YXJ0IDwgdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0U3RhcnQgPCBlbmQpIHtcbiAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcbiAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSBpZiAobGVuIDwgMTAwMCB8fCAhQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBhc2NlbmRpbmcgY29weSBmcm9tIHN0YXJ0XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQuX3NldCh0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksIHRhcmdldFN0YXJ0KVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBmaWxsKHZhbHVlLCBzdGFydD0wLCBlbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gIGlmICghdmFsdWUpIHZhbHVlID0gMFxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQpIGVuZCA9IHRoaXMubGVuZ3RoXG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignZW5kIDwgc3RhcnQnKVxuXG4gIC8vIEZpbGwgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuXG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuXG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3N0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoZW5kIDwgMCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2VuZCBvdXQgb2YgYm91bmRzJylcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIHRoaXNbaV0gPSB2YWx1ZVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSB1dGY4VG9CeXRlcyh2YWx1ZS50b1N0cmluZygpKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICB0aGlzW2ldID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgYEFycmF5QnVmZmVyYCB3aXRoIHRoZSAqY29waWVkKiBtZW1vcnkgb2YgdGhlIGJ1ZmZlciBpbnN0YW5jZS5cbiAqIEFkZGVkIGluIE5vZGUgMC4xMi4gT25seSBhdmFpbGFibGUgaW4gYnJvd3NlcnMgdGhhdCBzdXBwb3J0IEFycmF5QnVmZmVyLlxuICovXG5CdWZmZXIucHJvdG90eXBlLnRvQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiB0b0FycmF5QnVmZmVyICgpIHtcbiAgaWYgKHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgICAgcmV0dXJuIChuZXcgQnVmZmVyKHRoaXMpKS5idWZmZXJcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KHRoaXMubGVuZ3RoKVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGJ1Zi5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBidWZbaV0gPSB0aGlzW2ldXG4gICAgICB9XG4gICAgICByZXR1cm4gYnVmLmJ1ZmZlclxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCdWZmZXIudG9BcnJheUJ1ZmZlciBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlcicpXG4gIH1cbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgQlAgPSBCdWZmZXIucHJvdG90eXBlXG5cbi8qKlxuICogQXVnbWVudCBhIFVpbnQ4QXJyYXkgKmluc3RhbmNlKiAobm90IHRoZSBVaW50OEFycmF5IGNsYXNzISkgd2l0aCBCdWZmZXIgbWV0aG9kc1xuICovXG5CdWZmZXIuX2F1Z21lbnQgPSBmdW5jdGlvbiBfYXVnbWVudCAoYXJyKSB7XG4gIGFyci5jb25zdHJ1Y3RvciA9IEJ1ZmZlclxuICBhcnIuX2lzQnVmZmVyID0gdHJ1ZVxuXG4gIC8vIHNhdmUgcmVmZXJlbmNlIHRvIG9yaWdpbmFsIFVpbnQ4QXJyYXkgc2V0IG1ldGhvZCBiZWZvcmUgb3ZlcndyaXRpbmdcbiAgYXJyLl9zZXQgPSBhcnIuc2V0XG5cbiAgLy8gZGVwcmVjYXRlZFxuICBhcnIuZ2V0ID0gQlAuZ2V0XG4gIGFyci5zZXQgPSBCUC5zZXRcblxuICBhcnIud3JpdGUgPSBCUC53cml0ZVxuICBhcnIudG9TdHJpbmcgPSBCUC50b1N0cmluZ1xuICBhcnIudG9Mb2NhbGVTdHJpbmcgPSBCUC50b1N0cmluZ1xuICBhcnIudG9KU09OID0gQlAudG9KU09OXG4gIGFyci5lcXVhbHMgPSBCUC5lcXVhbHNcbiAgYXJyLmNvbXBhcmUgPSBCUC5jb21wYXJlXG4gIGFyci5pbmRleE9mID0gQlAuaW5kZXhPZlxuICBhcnIuY29weSA9IEJQLmNvcHlcbiAgYXJyLnNsaWNlID0gQlAuc2xpY2VcbiAgYXJyLnJlYWRVSW50TEUgPSBCUC5yZWFkVUludExFXG4gIGFyci5yZWFkVUludEJFID0gQlAucmVhZFVJbnRCRVxuICBhcnIucmVhZFVJbnQ4ID0gQlAucmVhZFVJbnQ4XG4gIGFyci5yZWFkVUludDE2TEUgPSBCUC5yZWFkVUludDE2TEVcbiAgYXJyLnJlYWRVSW50MTZCRSA9IEJQLnJlYWRVSW50MTZCRVxuICBhcnIucmVhZFVJbnQzMkxFID0gQlAucmVhZFVJbnQzMkxFXG4gIGFyci5yZWFkVUludDMyQkUgPSBCUC5yZWFkVUludDMyQkVcbiAgYXJyLnJlYWRJbnRMRSA9IEJQLnJlYWRJbnRMRVxuICBhcnIucmVhZEludEJFID0gQlAucmVhZEludEJFXG4gIGFyci5yZWFkSW50OCA9IEJQLnJlYWRJbnQ4XG4gIGFyci5yZWFkSW50MTZMRSA9IEJQLnJlYWRJbnQxNkxFXG4gIGFyci5yZWFkSW50MTZCRSA9IEJQLnJlYWRJbnQxNkJFXG4gIGFyci5yZWFkSW50MzJMRSA9IEJQLnJlYWRJbnQzMkxFXG4gIGFyci5yZWFkSW50MzJCRSA9IEJQLnJlYWRJbnQzMkJFXG4gIGFyci5yZWFkRmxvYXRMRSA9IEJQLnJlYWRGbG9hdExFXG4gIGFyci5yZWFkRmxvYXRCRSA9IEJQLnJlYWRGbG9hdEJFXG4gIGFyci5yZWFkRG91YmxlTEUgPSBCUC5yZWFkRG91YmxlTEVcbiAgYXJyLnJlYWREb3VibGVCRSA9IEJQLnJlYWREb3VibGVCRVxuICBhcnIud3JpdGVVSW50OCA9IEJQLndyaXRlVUludDhcbiAgYXJyLndyaXRlVUludExFID0gQlAud3JpdGVVSW50TEVcbiAgYXJyLndyaXRlVUludEJFID0gQlAud3JpdGVVSW50QkVcbiAgYXJyLndyaXRlVUludDE2TEUgPSBCUC53cml0ZVVJbnQxNkxFXG4gIGFyci53cml0ZVVJbnQxNkJFID0gQlAud3JpdGVVSW50MTZCRVxuICBhcnIud3JpdGVVSW50MzJMRSA9IEJQLndyaXRlVUludDMyTEVcbiAgYXJyLndyaXRlVUludDMyQkUgPSBCUC53cml0ZVVJbnQzMkJFXG4gIGFyci53cml0ZUludExFID0gQlAud3JpdGVJbnRMRVxuICBhcnIud3JpdGVJbnRCRSA9IEJQLndyaXRlSW50QkVcbiAgYXJyLndyaXRlSW50OCA9IEJQLndyaXRlSW50OFxuICBhcnIud3JpdGVJbnQxNkxFID0gQlAud3JpdGVJbnQxNkxFXG4gIGFyci53cml0ZUludDE2QkUgPSBCUC53cml0ZUludDE2QkVcbiAgYXJyLndyaXRlSW50MzJMRSA9IEJQLndyaXRlSW50MzJMRVxuICBhcnIud3JpdGVJbnQzMkJFID0gQlAud3JpdGVJbnQzMkJFXG4gIGFyci53cml0ZUZsb2F0TEUgPSBCUC53cml0ZUZsb2F0TEVcbiAgYXJyLndyaXRlRmxvYXRCRSA9IEJQLndyaXRlRmxvYXRCRVxuICBhcnIud3JpdGVEb3VibGVMRSA9IEJQLndyaXRlRG91YmxlTEVcbiAgYXJyLndyaXRlRG91YmxlQkUgPSBCUC53cml0ZURvdWJsZUJFXG4gIGFyci5maWxsID0gQlAuZmlsbFxuICBhcnIuaW5zcGVjdCA9IEJQLmluc3BlY3RcbiAgYXJyLnRvQXJyYXlCdWZmZXIgPSBCUC50b0FycmF5QnVmZmVyXG5cbiAgcmV0dXJuIGFyclxufVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rXFwvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyaW5ndHJpbShzdHIpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHN0cmluZ3RyaW0gKHN0cikge1xuICBpZiAoc3RyLnRyaW0pIHJldHVybiBzdHIudHJpbSgpXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cbiIsInZhciBsb29rdXAgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyc7XG5cbjsoZnVuY3Rpb24gKGV4cG9ydHMpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG4gIHZhciBBcnIgPSAodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKVxuICAgID8gVWludDhBcnJheVxuICAgIDogQXJyYXlcblxuXHR2YXIgUExVUyAgID0gJysnLmNoYXJDb2RlQXQoMClcblx0dmFyIFNMQVNIICA9ICcvJy5jaGFyQ29kZUF0KDApXG5cdHZhciBOVU1CRVIgPSAnMCcuY2hhckNvZGVBdCgwKVxuXHR2YXIgTE9XRVIgID0gJ2EnLmNoYXJDb2RlQXQoMClcblx0dmFyIFVQUEVSICA9ICdBJy5jaGFyQ29kZUF0KDApXG5cdHZhciBQTFVTX1VSTF9TQUZFID0gJy0nLmNoYXJDb2RlQXQoMClcblx0dmFyIFNMQVNIX1VSTF9TQUZFID0gJ18nLmNoYXJDb2RlQXQoMClcblxuXHRmdW5jdGlvbiBkZWNvZGUgKGVsdCkge1xuXHRcdHZhciBjb2RlID0gZWx0LmNoYXJDb2RlQXQoMClcblx0XHRpZiAoY29kZSA9PT0gUExVUyB8fFxuXHRcdCAgICBjb2RlID09PSBQTFVTX1VSTF9TQUZFKVxuXHRcdFx0cmV0dXJuIDYyIC8vICcrJ1xuXHRcdGlmIChjb2RlID09PSBTTEFTSCB8fFxuXHRcdCAgICBjb2RlID09PSBTTEFTSF9VUkxfU0FGRSlcblx0XHRcdHJldHVybiA2MyAvLyAnLydcblx0XHRpZiAoY29kZSA8IE5VTUJFUilcblx0XHRcdHJldHVybiAtMSAvL25vIG1hdGNoXG5cdFx0aWYgKGNvZGUgPCBOVU1CRVIgKyAxMClcblx0XHRcdHJldHVybiBjb2RlIC0gTlVNQkVSICsgMjYgKyAyNlxuXHRcdGlmIChjb2RlIDwgVVBQRVIgKyAyNilcblx0XHRcdHJldHVybiBjb2RlIC0gVVBQRVJcblx0XHRpZiAoY29kZSA8IExPV0VSICsgMjYpXG5cdFx0XHRyZXR1cm4gY29kZSAtIExPV0VSICsgMjZcblx0fVxuXG5cdGZ1bmN0aW9uIGI2NFRvQnl0ZUFycmF5IChiNjQpIHtcblx0XHR2YXIgaSwgaiwgbCwgdG1wLCBwbGFjZUhvbGRlcnMsIGFyclxuXG5cdFx0aWYgKGI2NC5sZW5ndGggJSA0ID4gMCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0Jylcblx0XHR9XG5cblx0XHQvLyB0aGUgbnVtYmVyIG9mIGVxdWFsIHNpZ25zIChwbGFjZSBob2xkZXJzKVxuXHRcdC8vIGlmIHRoZXJlIGFyZSB0d28gcGxhY2Vob2xkZXJzLCB0aGFuIHRoZSB0d28gY2hhcmFjdGVycyBiZWZvcmUgaXRcblx0XHQvLyByZXByZXNlbnQgb25lIGJ5dGVcblx0XHQvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSwgdGhlbiB0aGUgdGhyZWUgY2hhcmFjdGVycyBiZWZvcmUgaXQgcmVwcmVzZW50IDIgYnl0ZXNcblx0XHQvLyB0aGlzIGlzIGp1c3QgYSBjaGVhcCBoYWNrIHRvIG5vdCBkbyBpbmRleE9mIHR3aWNlXG5cdFx0dmFyIGxlbiA9IGI2NC5sZW5ndGhcblx0XHRwbGFjZUhvbGRlcnMgPSAnPScgPT09IGI2NC5jaGFyQXQobGVuIC0gMikgPyAyIDogJz0nID09PSBiNjQuY2hhckF0KGxlbiAtIDEpID8gMSA6IDBcblxuXHRcdC8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuXHRcdGFyciA9IG5ldyBBcnIoYjY0Lmxlbmd0aCAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzKVxuXG5cdFx0Ly8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuXHRcdGwgPSBwbGFjZUhvbGRlcnMgPiAwID8gYjY0Lmxlbmd0aCAtIDQgOiBiNjQubGVuZ3RoXG5cblx0XHR2YXIgTCA9IDBcblxuXHRcdGZ1bmN0aW9uIHB1c2ggKHYpIHtcblx0XHRcdGFycltMKytdID0gdlxuXHRcdH1cblxuXHRcdGZvciAoaSA9IDAsIGogPSAwOyBpIDwgbDsgaSArPSA0LCBqICs9IDMpIHtcblx0XHRcdHRtcCA9IChkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMTgpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPDwgMTIpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAyKSkgPDwgNikgfCBkZWNvZGUoYjY0LmNoYXJBdChpICsgMykpXG5cdFx0XHRwdXNoKCh0bXAgJiAweEZGMDAwMCkgPj4gMTYpXG5cdFx0XHRwdXNoKCh0bXAgJiAweEZGMDApID4+IDgpXG5cdFx0XHRwdXNoKHRtcCAmIDB4RkYpXG5cdFx0fVxuXG5cdFx0aWYgKHBsYWNlSG9sZGVycyA9PT0gMikge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAyKSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMSkpID4+IDQpXG5cdFx0XHRwdXNoKHRtcCAmIDB4RkYpXG5cdFx0fSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHtcblx0XHRcdHRtcCA9IChkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMTApIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPDwgNCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDIpKSA+PiAyKVxuXHRcdFx0cHVzaCgodG1wID4+IDgpICYgMHhGRilcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9XG5cblx0XHRyZXR1cm4gYXJyXG5cdH1cblxuXHRmdW5jdGlvbiB1aW50OFRvQmFzZTY0ICh1aW50OCkge1xuXHRcdHZhciBpLFxuXHRcdFx0ZXh0cmFCeXRlcyA9IHVpbnQ4Lmxlbmd0aCAlIDMsIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG5cdFx0XHRvdXRwdXQgPSBcIlwiLFxuXHRcdFx0dGVtcCwgbGVuZ3RoXG5cblx0XHRmdW5jdGlvbiBlbmNvZGUgKG51bSkge1xuXHRcdFx0cmV0dXJuIGxvb2t1cC5jaGFyQXQobnVtKVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG5cdFx0XHRyZXR1cm4gZW5jb2RlKG51bSA+PiAxOCAmIDB4M0YpICsgZW5jb2RlKG51bSA+PiAxMiAmIDB4M0YpICsgZW5jb2RlKG51bSA+PiA2ICYgMHgzRikgKyBlbmNvZGUobnVtICYgMHgzRilcblx0XHR9XG5cblx0XHQvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG5cdFx0Zm9yIChpID0gMCwgbGVuZ3RoID0gdWludDgubGVuZ3RoIC0gZXh0cmFCeXRlczsgaSA8IGxlbmd0aDsgaSArPSAzKSB7XG5cdFx0XHR0ZW1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKVxuXHRcdFx0b3V0cHV0ICs9IHRyaXBsZXRUb0Jhc2U2NCh0ZW1wKVxuXHRcdH1cblxuXHRcdC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcblx0XHRzd2l0Y2ggKGV4dHJhQnl0ZXMpIHtcblx0XHRcdGNhc2UgMTpcblx0XHRcdFx0dGVtcCA9IHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDFdXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUodGVtcCA+PiAyKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wIDw8IDQpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9ICc9PSdcblx0XHRcdFx0YnJlYWtcblx0XHRcdGNhc2UgMjpcblx0XHRcdFx0dGVtcCA9ICh1aW50OFt1aW50OC5sZW5ndGggLSAyXSA8PCA4KSArICh1aW50OFt1aW50OC5sZW5ndGggLSAxXSlcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSh0ZW1wID4+IDEwKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wID4+IDQpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSgodGVtcCA8PCAyKSAmIDB4M0YpXG5cdFx0XHRcdG91dHB1dCArPSAnPSdcblx0XHRcdFx0YnJlYWtcblx0XHR9XG5cblx0XHRyZXR1cm4gb3V0cHV0XG5cdH1cblxuXHRleHBvcnRzLnRvQnl0ZUFycmF5ID0gYjY0VG9CeXRlQXJyYXlcblx0ZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gdWludDhUb0Jhc2U2NFxufSh0eXBlb2YgZXhwb3J0cyA9PT0gJ3VuZGVmaW5lZCcgPyAodGhpcy5iYXNlNjRqcyA9IHt9KSA6IGV4cG9ydHMpKVxuIiwiZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gZSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG4iLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLnJhbmRvbUJ5dGVzID0gZXhwb3J0cy5ybmcgPSBleHBvcnRzLnBzZXVkb1JhbmRvbUJ5dGVzID0gZXhwb3J0cy5wcm5nID0gcmVxdWlyZSgncmFuZG9tYnl0ZXMnKVxuZXhwb3J0cy5jcmVhdGVIYXNoID0gZXhwb3J0cy5IYXNoID0gcmVxdWlyZSgnY3JlYXRlLWhhc2gnKVxuZXhwb3J0cy5jcmVhdGVIbWFjID0gZXhwb3J0cy5IbWFjID0gcmVxdWlyZSgnY3JlYXRlLWhtYWMnKVxuXG52YXIgaGFzaGVzID0gWydzaGExJywgJ3NoYTIyNCcsICdzaGEyNTYnLCAnc2hhMzg0JywgJ3NoYTUxMicsICdtZDUnLCAncm1kMTYwJ10uY29uY2F0KE9iamVjdC5rZXlzKHJlcXVpcmUoJ2Jyb3dzZXJpZnktc2lnbi9hbGdvcycpKSlcbmV4cG9ydHMuZ2V0SGFzaGVzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gaGFzaGVzXG59XG5cbnZhciBwID0gcmVxdWlyZSgncGJrZGYyJylcbmV4cG9ydHMucGJrZGYyID0gcC5wYmtkZjJcbmV4cG9ydHMucGJrZGYyU3luYyA9IHAucGJrZGYyU3luY1xuXG52YXIgYWVzID0gcmVxdWlyZSgnYnJvd3NlcmlmeS1jaXBoZXInKVxuO1tcbiAgJ0NpcGhlcicsXG4gICdjcmVhdGVDaXBoZXInLFxuICAnQ2lwaGVyaXYnLFxuICAnY3JlYXRlQ2lwaGVyaXYnLFxuICAnRGVjaXBoZXInLFxuICAnY3JlYXRlRGVjaXBoZXInLFxuICAnRGVjaXBoZXJpdicsXG4gICdjcmVhdGVEZWNpcGhlcml2JyxcbiAgJ2dldENpcGhlcnMnLFxuICAnbGlzdENpcGhlcnMnXG5dLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBleHBvcnRzW2tleV0gPSBhZXNba2V5XVxufSlcblxudmFyIGRoID0gcmVxdWlyZSgnZGlmZmllLWhlbGxtYW4nKVxuO1tcbiAgJ0RpZmZpZUhlbGxtYW5Hcm91cCcsXG4gICdjcmVhdGVEaWZmaWVIZWxsbWFuR3JvdXAnLFxuICAnZ2V0RGlmZmllSGVsbG1hbicsXG4gICdjcmVhdGVEaWZmaWVIZWxsbWFuJyxcbiAgJ0RpZmZpZUhlbGxtYW4nXG5dLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBleHBvcnRzW2tleV0gPSBkaFtrZXldXG59KVxuXG52YXIgc2lnbiA9IHJlcXVpcmUoJ2Jyb3dzZXJpZnktc2lnbicpXG47W1xuICAnY3JlYXRlU2lnbicsXG4gICdTaWduJyxcbiAgJ2NyZWF0ZVZlcmlmeScsXG4gICdWZXJpZnknXG5dLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBleHBvcnRzW2tleV0gPSBzaWduW2tleV1cbn0pXG5cbmV4cG9ydHMuY3JlYXRlRUNESCA9IHJlcXVpcmUoJ2NyZWF0ZS1lY2RoJylcblxudmFyIHB1YmxpY0VuY3J5cHQgPSByZXF1aXJlKCdwdWJsaWMtZW5jcnlwdCcpXG5cbjtbXG4gICdwdWJsaWNFbmNyeXB0JyxcbiAgJ3ByaXZhdGVFbmNyeXB0JyxcbiAgJ3B1YmxpY0RlY3J5cHQnLFxuICAncHJpdmF0ZURlY3J5cHQnXG5dLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBleHBvcnRzW2tleV0gPSBwdWJsaWNFbmNyeXB0W2tleV1cbn0pXG5cbi8vIHRoZSBsZWFzdCBJIGNhbiBkbyBpcyBtYWtlIGVycm9yIG1lc3NhZ2VzIGZvciB0aGUgcmVzdCBvZiB0aGUgbm9kZS5qcy9jcnlwdG8gYXBpLlxuO1tcbiAgJ2NyZWF0ZUNyZWRlbnRpYWxzJ1xuXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIGV4cG9ydHNbbmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFtcbiAgICAgICdzb3JyeSwgJyArIG5hbWUgKyAnIGlzIG5vdCBpbXBsZW1lbnRlZCB5ZXQnLFxuICAgICAgJ3dlIGFjY2VwdCBwdWxsIHJlcXVlc3RzJyxcbiAgICAgICdodHRwczovL2dpdGh1Yi5jb20vY3J5cHRvLWJyb3dzZXJpZnkvY3J5cHRvLWJyb3dzZXJpZnknXG4gICAgXS5qb2luKCdcXG4nKSlcbiAgfVxufSlcbiIsInZhciBlYnRrID0gcmVxdWlyZSgnZXZwX2J5dGVzdG9rZXknKVxudmFyIGFlcyA9IHJlcXVpcmUoJ2Jyb3dzZXJpZnktYWVzL2Jyb3dzZXInKVxudmFyIERFUyA9IHJlcXVpcmUoJ2Jyb3dzZXJpZnktZGVzJylcbnZhciBkZXNNb2RlcyA9IHJlcXVpcmUoJ2Jyb3dzZXJpZnktZGVzL21vZGVzJylcbnZhciBhZXNNb2RlcyA9IHJlcXVpcmUoJ2Jyb3dzZXJpZnktYWVzL21vZGVzJylcbmZ1bmN0aW9uIGNyZWF0ZUNpcGhlciAoc3VpdGUsIHBhc3N3b3JkKSB7XG4gIHZhciBrZXlMZW4sIGl2TGVuXG4gIHN1aXRlID0gc3VpdGUudG9Mb3dlckNhc2UoKVxuICBpZiAoYWVzTW9kZXNbc3VpdGVdKSB7XG4gICAga2V5TGVuID0gYWVzTW9kZXNbc3VpdGVdLmtleVxuICAgIGl2TGVuID0gYWVzTW9kZXNbc3VpdGVdLml2XG4gIH0gZWxzZSBpZiAoZGVzTW9kZXNbc3VpdGVdKSB7XG4gICAga2V5TGVuID0gZGVzTW9kZXNbc3VpdGVdLmtleSAqIDhcbiAgICBpdkxlbiA9IGRlc01vZGVzW3N1aXRlXS5pdlxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgc3VpdGUgdHlwZScpXG4gIH1cbiAgdmFyIGtleXMgPSBlYnRrKHBhc3N3b3JkLCBmYWxzZSwga2V5TGVuLCBpdkxlbilcbiAgcmV0dXJuIGNyZWF0ZUNpcGhlcml2KHN1aXRlLCBrZXlzLmtleSwga2V5cy5pdilcbn1cbmZ1bmN0aW9uIGNyZWF0ZURlY2lwaGVyIChzdWl0ZSwgcGFzc3dvcmQpIHtcbiAgdmFyIGtleUxlbiwgaXZMZW5cbiAgc3VpdGUgPSBzdWl0ZS50b0xvd2VyQ2FzZSgpXG4gIGlmIChhZXNNb2Rlc1tzdWl0ZV0pIHtcbiAgICBrZXlMZW4gPSBhZXNNb2Rlc1tzdWl0ZV0ua2V5XG4gICAgaXZMZW4gPSBhZXNNb2Rlc1tzdWl0ZV0uaXZcbiAgfSBlbHNlIGlmIChkZXNNb2Rlc1tzdWl0ZV0pIHtcbiAgICBrZXlMZW4gPSBkZXNNb2Rlc1tzdWl0ZV0ua2V5ICogOFxuICAgIGl2TGVuID0gZGVzTW9kZXNbc3VpdGVdLml2XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBzdWl0ZSB0eXBlJylcbiAgfVxuICB2YXIga2V5cyA9IGVidGsocGFzc3dvcmQsIGZhbHNlLCBrZXlMZW4sIGl2TGVuKVxuICByZXR1cm4gY3JlYXRlRGVjaXBoZXJpdihzdWl0ZSwga2V5cy5rZXksIGtleXMuaXYpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNpcGhlcml2IChzdWl0ZSwga2V5LCBpdikge1xuICBzdWl0ZSA9IHN1aXRlLnRvTG93ZXJDYXNlKClcbiAgaWYgKGFlc01vZGVzW3N1aXRlXSkge1xuICAgIHJldHVybiBhZXMuY3JlYXRlQ2lwaGVyaXYoc3VpdGUsIGtleSwgaXYpXG4gIH0gZWxzZSBpZiAoZGVzTW9kZXNbc3VpdGVdKSB7XG4gICAgcmV0dXJuIG5ldyBERVMoe1xuICAgICAga2V5OiBrZXksXG4gICAgICBpdjogaXYsXG4gICAgICBtb2RlOiBzdWl0ZVxuICAgIH0pXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBzdWl0ZSB0eXBlJylcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlRGVjaXBoZXJpdiAoc3VpdGUsIGtleSwgaXYpIHtcbiAgc3VpdGUgPSBzdWl0ZS50b0xvd2VyQ2FzZSgpXG4gIGlmIChhZXNNb2Rlc1tzdWl0ZV0pIHtcbiAgICByZXR1cm4gYWVzLmNyZWF0ZURlY2lwaGVyaXYoc3VpdGUsIGtleSwgaXYpXG4gIH0gZWxzZSBpZiAoZGVzTW9kZXNbc3VpdGVdKSB7XG4gICAgcmV0dXJuIG5ldyBERVMoe1xuICAgICAga2V5OiBrZXksXG4gICAgICBpdjogaXYsXG4gICAgICBtb2RlOiBzdWl0ZSxcbiAgICAgIGRlY3J5cHQ6IHRydWVcbiAgICB9KVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgc3VpdGUgdHlwZScpXG4gIH1cbn1cbmV4cG9ydHMuY3JlYXRlQ2lwaGVyID0gZXhwb3J0cy5DaXBoZXIgPSBjcmVhdGVDaXBoZXJcbmV4cG9ydHMuY3JlYXRlQ2lwaGVyaXYgPSBleHBvcnRzLkNpcGhlcml2ID0gY3JlYXRlQ2lwaGVyaXZcbmV4cG9ydHMuY3JlYXRlRGVjaXBoZXIgPSBleHBvcnRzLkRlY2lwaGVyID0gY3JlYXRlRGVjaXBoZXJcbmV4cG9ydHMuY3JlYXRlRGVjaXBoZXJpdiA9IGV4cG9ydHMuRGVjaXBoZXJpdiA9IGNyZWF0ZURlY2lwaGVyaXZcbmZ1bmN0aW9uIGdldENpcGhlcnMgKCkge1xuICByZXR1cm4gT2JqZWN0LmtleXMoZGVzTW9kZXMpLmNvbmNhdChhZXMuZ2V0Q2lwaGVycygpKVxufVxuZXhwb3J0cy5saXN0Q2lwaGVycyA9IGV4cG9ydHMuZ2V0Q2lwaGVycyA9IGdldENpcGhlcnNcbiIsIi8vIGJhc2VkIG9uIHRoZSBhZXMgaW1wbGltZW50YXRpb24gaW4gdHJpcGxlIHNlY1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2tleWJhc2UvdHJpcGxlc2VjXG5cbi8vIHdoaWNoIGlzIGluIHR1cm4gYmFzZWQgb24gdGhlIG9uZSBmcm9tIGNyeXB0by1qc1xuLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jcnlwdG8tanMvXG5cbnZhciB1aW50X21heCA9IE1hdGgucG93KDIsIDMyKVxuZnVuY3Rpb24gZml4dXBfdWludDMyICh4KSB7XG4gIHZhciByZXQsIHhfcG9zXG4gIHJldCA9IHggPiB1aW50X21heCB8fCB4IDwgMCA/ICh4X3BvcyA9IE1hdGguYWJzKHgpICUgdWludF9tYXgsIHggPCAwID8gdWludF9tYXggLSB4X3BvcyA6IHhfcG9zKSA6IHhcbiAgcmV0dXJuIHJldFxufVxuZnVuY3Rpb24gc2NydWJfdmVjICh2KSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdi5sZW5ndGg7IHYrKykge1xuICAgIHZbaV0gPSAwXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIEdsb2JhbCAoKSB7XG4gIHRoaXMuU0JPWCA9IFtdXG4gIHRoaXMuSU5WX1NCT1ggPSBbXVxuICB0aGlzLlNVQl9NSVggPSBbW10sIFtdLCBbXSwgW11dXG4gIHRoaXMuSU5WX1NVQl9NSVggPSBbW10sIFtdLCBbXSwgW11dXG4gIHRoaXMuaW5pdCgpXG4gIHRoaXMuUkNPTiA9IFsweDAwLCAweDAxLCAweDAyLCAweDA0LCAweDA4LCAweDEwLCAweDIwLCAweDQwLCAweDgwLCAweDFiLCAweDM2XVxufVxuXG5HbG9iYWwucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBkLCBpLCBzeCwgdCwgeCwgeDIsIHg0LCB4OCwgeGksIF9pXG4gIGQgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBfaSwgX3Jlc3VsdHNcbiAgICBfcmVzdWx0cyA9IFtdXG4gICAgZm9yIChpID0gX2kgPSAwOyBfaSA8IDI1NjsgaSA9ICsrX2kpIHtcbiAgICAgIGlmIChpIDwgMTI4KSB7XG4gICAgICAgIF9yZXN1bHRzLnB1c2goaSA8PCAxKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3Jlc3VsdHMucHVzaCgoaSA8PCAxKSBeIDB4MTFiKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gX3Jlc3VsdHNcbiAgfSkoKVxuICB4ID0gMFxuICB4aSA9IDBcbiAgZm9yIChpID0gX2kgPSAwOyBfaSA8IDI1NjsgaSA9ICsrX2kpIHtcbiAgICBzeCA9IHhpIF4gKHhpIDw8IDEpIF4gKHhpIDw8IDIpIF4gKHhpIDw8IDMpIF4gKHhpIDw8IDQpXG4gICAgc3ggPSAoc3ggPj4+IDgpIF4gKHN4ICYgMHhmZikgXiAweDYzXG4gICAgdGhpcy5TQk9YW3hdID0gc3hcbiAgICB0aGlzLklOVl9TQk9YW3N4XSA9IHhcbiAgICB4MiA9IGRbeF1cbiAgICB4NCA9IGRbeDJdXG4gICAgeDggPSBkW3g0XVxuICAgIHQgPSAoZFtzeF0gKiAweDEwMSkgXiAoc3ggKiAweDEwMTAxMDApXG4gICAgdGhpcy5TVUJfTUlYWzBdW3hdID0gKHQgPDwgMjQpIHwgKHQgPj4+IDgpXG4gICAgdGhpcy5TVUJfTUlYWzFdW3hdID0gKHQgPDwgMTYpIHwgKHQgPj4+IDE2KVxuICAgIHRoaXMuU1VCX01JWFsyXVt4XSA9ICh0IDw8IDgpIHwgKHQgPj4+IDI0KVxuICAgIHRoaXMuU1VCX01JWFszXVt4XSA9IHRcbiAgICB0ID0gKHg4ICogMHgxMDEwMTAxKSBeICh4NCAqIDB4MTAwMDEpIF4gKHgyICogMHgxMDEpIF4gKHggKiAweDEwMTAxMDApXG4gICAgdGhpcy5JTlZfU1VCX01JWFswXVtzeF0gPSAodCA8PCAyNCkgfCAodCA+Pj4gOClcbiAgICB0aGlzLklOVl9TVUJfTUlYWzFdW3N4XSA9ICh0IDw8IDE2KSB8ICh0ID4+PiAxNilcbiAgICB0aGlzLklOVl9TVUJfTUlYWzJdW3N4XSA9ICh0IDw8IDgpIHwgKHQgPj4+IDI0KVxuICAgIHRoaXMuSU5WX1NVQl9NSVhbM11bc3hdID0gdFxuICAgIGlmICh4ID09PSAwKSB7XG4gICAgICB4ID0geGkgPSAxXG4gICAgfSBlbHNlIHtcbiAgICAgIHggPSB4MiBeIGRbZFtkW3g4IF4geDJdXV1cbiAgICAgIHhpIF49IGRbZFt4aV1dXG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbnZhciBHID0gbmV3IEdsb2JhbCgpXG5cbkFFUy5ibG9ja1NpemUgPSA0ICogNFxuXG5BRVMucHJvdG90eXBlLmJsb2NrU2l6ZSA9IEFFUy5ibG9ja1NpemVcblxuQUVTLmtleVNpemUgPSAyNTYgLyA4XG5cbkFFUy5wcm90b3R5cGUua2V5U2l6ZSA9IEFFUy5rZXlTaXplXG5cbmZ1bmN0aW9uIGJ1ZmZlclRvQXJyYXkgKGJ1Zikge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aCAvIDRcbiAgdmFyIG91dCA9IG5ldyBBcnJheShsZW4pXG4gIHZhciBpID0gLTFcbiAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgIG91dFtpXSA9IGJ1Zi5yZWFkVUludDMyQkUoaSAqIDQpXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuZnVuY3Rpb24gQUVTIChrZXkpIHtcbiAgdGhpcy5fa2V5ID0gYnVmZmVyVG9BcnJheShrZXkpXG4gIHRoaXMuX2RvUmVzZXQoKVxufVxuXG5BRVMucHJvdG90eXBlLl9kb1Jlc2V0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaW52S3NSb3csIGtleVNpemUsIGtleVdvcmRzLCBrc1Jvdywga3NSb3dzLCB0XG4gIGtleVdvcmRzID0gdGhpcy5fa2V5XG4gIGtleVNpemUgPSBrZXlXb3Jkcy5sZW5ndGhcbiAgdGhpcy5fblJvdW5kcyA9IGtleVNpemUgKyA2XG4gIGtzUm93cyA9ICh0aGlzLl9uUm91bmRzICsgMSkgKiA0XG4gIHRoaXMuX2tleVNjaGVkdWxlID0gW11cbiAgZm9yIChrc1JvdyA9IDA7IGtzUm93IDwga3NSb3dzOyBrc1JvdysrKSB7XG4gICAgdGhpcy5fa2V5U2NoZWR1bGVba3NSb3ddID0ga3NSb3cgPCBrZXlTaXplID8ga2V5V29yZHNba3NSb3ddIDogKHQgPSB0aGlzLl9rZXlTY2hlZHVsZVtrc1JvdyAtIDFdLCAoa3NSb3cgJSBrZXlTaXplKSA9PT0gMCA/ICh0ID0gKHQgPDwgOCkgfCAodCA+Pj4gMjQpLCB0ID0gKEcuU0JPWFt0ID4+PiAyNF0gPDwgMjQpIHwgKEcuU0JPWFsodCA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKEcuU0JPWFsodCA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IEcuU0JPWFt0ICYgMHhmZl0sIHQgXj0gRy5SQ09OWyhrc1JvdyAvIGtleVNpemUpIHwgMF0gPDwgMjQpIDoga2V5U2l6ZSA+IDYgJiYga3NSb3cgJSBrZXlTaXplID09PSA0ID8gdCA9IChHLlNCT1hbdCA+Pj4gMjRdIDw8IDI0KSB8IChHLlNCT1hbKHQgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChHLlNCT1hbKHQgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBHLlNCT1hbdCAmIDB4ZmZdIDogdm9pZCAwLCB0aGlzLl9rZXlTY2hlZHVsZVtrc1JvdyAtIGtleVNpemVdIF4gdClcbiAgfVxuICB0aGlzLl9pbnZLZXlTY2hlZHVsZSA9IFtdXG4gIGZvciAoaW52S3NSb3cgPSAwOyBpbnZLc1JvdyA8IGtzUm93czsgaW52S3NSb3crKykge1xuICAgIGtzUm93ID0ga3NSb3dzIC0gaW52S3NSb3dcbiAgICB0ID0gdGhpcy5fa2V5U2NoZWR1bGVba3NSb3cgLSAoaW52S3NSb3cgJSA0ID8gMCA6IDQpXVxuICAgIHRoaXMuX2ludktleVNjaGVkdWxlW2ludktzUm93XSA9IGludktzUm93IDwgNCB8fCBrc1JvdyA8PSA0ID8gdCA6IEcuSU5WX1NVQl9NSVhbMF1bRy5TQk9YW3QgPj4+IDI0XV0gXiBHLklOVl9TVUJfTUlYWzFdW0cuU0JPWFsodCA+Pj4gMTYpICYgMHhmZl1dIF4gRy5JTlZfU1VCX01JWFsyXVtHLlNCT1hbKHQgPj4+IDgpICYgMHhmZl1dIF4gRy5JTlZfU1VCX01JWFszXVtHLlNCT1hbdCAmIDB4ZmZdXVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbkFFUy5wcm90b3R5cGUuZW5jcnlwdEJsb2NrID0gZnVuY3Rpb24gKE0pIHtcbiAgTSA9IGJ1ZmZlclRvQXJyYXkobmV3IEJ1ZmZlcihNKSlcbiAgdmFyIG91dCA9IHRoaXMuX2RvQ3J5cHRCbG9jayhNLCB0aGlzLl9rZXlTY2hlZHVsZSwgRy5TVUJfTUlYLCBHLlNCT1gpXG4gIHZhciBidWYgPSBuZXcgQnVmZmVyKDE2KVxuICBidWYud3JpdGVVSW50MzJCRShvdXRbMF0sIDApXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKG91dFsxXSwgNClcbiAgYnVmLndyaXRlVUludDMyQkUob3V0WzJdLCA4KVxuICBidWYud3JpdGVVSW50MzJCRShvdXRbM10sIDEyKVxuICByZXR1cm4gYnVmXG59XG5cbkFFUy5wcm90b3R5cGUuZGVjcnlwdEJsb2NrID0gZnVuY3Rpb24gKE0pIHtcbiAgTSA9IGJ1ZmZlclRvQXJyYXkobmV3IEJ1ZmZlcihNKSlcbiAgdmFyIHRlbXAgPSBbTVszXSwgTVsxXV1cbiAgTVsxXSA9IHRlbXBbMF1cbiAgTVszXSA9IHRlbXBbMV1cbiAgdmFyIG91dCA9IHRoaXMuX2RvQ3J5cHRCbG9jayhNLCB0aGlzLl9pbnZLZXlTY2hlZHVsZSwgRy5JTlZfU1VCX01JWCwgRy5JTlZfU0JPWClcbiAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIoMTYpXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKG91dFswXSwgMClcbiAgYnVmLndyaXRlVUludDMyQkUob3V0WzNdLCA0KVxuICBidWYud3JpdGVVSW50MzJCRShvdXRbMl0sIDgpXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKG91dFsxXSwgMTIpXG4gIHJldHVybiBidWZcbn1cblxuQUVTLnByb3RvdHlwZS5zY3J1YiA9IGZ1bmN0aW9uICgpIHtcbiAgc2NydWJfdmVjKHRoaXMuX2tleVNjaGVkdWxlKVxuICBzY3J1Yl92ZWModGhpcy5faW52S2V5U2NoZWR1bGUpXG4gIHNjcnViX3ZlYyh0aGlzLl9rZXkpXG59XG5cbkFFUy5wcm90b3R5cGUuX2RvQ3J5cHRCbG9jayA9IGZ1bmN0aW9uIChNLCBrZXlTY2hlZHVsZSwgU1VCX01JWCwgU0JPWCkge1xuICB2YXIga3NSb3csIHMwLCBzMSwgczIsIHMzLCB0MCwgdDEsIHQyLCB0M1xuXG4gIHMwID0gTVswXSBeIGtleVNjaGVkdWxlWzBdXG4gIHMxID0gTVsxXSBeIGtleVNjaGVkdWxlWzFdXG4gIHMyID0gTVsyXSBeIGtleVNjaGVkdWxlWzJdXG4gIHMzID0gTVszXSBeIGtleVNjaGVkdWxlWzNdXG4gIGtzUm93ID0gNFxuICBmb3IgKHZhciByb3VuZCA9IDE7IHJvdW5kIDwgdGhpcy5fblJvdW5kczsgcm91bmQrKykge1xuICAgIHQwID0gU1VCX01JWFswXVtzMCA+Pj4gMjRdIF4gU1VCX01JWFsxXVsoczEgPj4+IDE2KSAmIDB4ZmZdIF4gU1VCX01JWFsyXVsoczIgPj4+IDgpICYgMHhmZl0gXiBTVUJfTUlYWzNdW3MzICYgMHhmZl0gXiBrZXlTY2hlZHVsZVtrc1JvdysrXVxuICAgIHQxID0gU1VCX01JWFswXVtzMSA+Pj4gMjRdIF4gU1VCX01JWFsxXVsoczIgPj4+IDE2KSAmIDB4ZmZdIF4gU1VCX01JWFsyXVsoczMgPj4+IDgpICYgMHhmZl0gXiBTVUJfTUlYWzNdW3MwICYgMHhmZl0gXiBrZXlTY2hlZHVsZVtrc1JvdysrXVxuICAgIHQyID0gU1VCX01JWFswXVtzMiA+Pj4gMjRdIF4gU1VCX01JWFsxXVsoczMgPj4+IDE2KSAmIDB4ZmZdIF4gU1VCX01JWFsyXVsoczAgPj4+IDgpICYgMHhmZl0gXiBTVUJfTUlYWzNdW3MxICYgMHhmZl0gXiBrZXlTY2hlZHVsZVtrc1JvdysrXVxuICAgIHQzID0gU1VCX01JWFswXVtzMyA+Pj4gMjRdIF4gU1VCX01JWFsxXVsoczAgPj4+IDE2KSAmIDB4ZmZdIF4gU1VCX01JWFsyXVsoczEgPj4+IDgpICYgMHhmZl0gXiBTVUJfTUlYWzNdW3MyICYgMHhmZl0gXiBrZXlTY2hlZHVsZVtrc1JvdysrXVxuICAgIHMwID0gdDBcbiAgICBzMSA9IHQxXG4gICAgczIgPSB0MlxuICAgIHMzID0gdDNcbiAgfVxuICB0MCA9ICgoU0JPWFtzMCA+Pj4gMjRdIDw8IDI0KSB8IChTQk9YWyhzMSA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKFNCT1hbKHMyID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgU0JPWFtzMyAmIDB4ZmZdKSBeIGtleVNjaGVkdWxlW2tzUm93KytdXG4gIHQxID0gKChTQk9YW3MxID4+PiAyNF0gPDwgMjQpIHwgKFNCT1hbKHMyID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoU0JPWFsoczMgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBTQk9YW3MwICYgMHhmZl0pIF4ga2V5U2NoZWR1bGVba3NSb3crK11cbiAgdDIgPSAoKFNCT1hbczIgPj4+IDI0XSA8PCAyNCkgfCAoU0JPWFsoczMgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChTQk9YWyhzMCA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IFNCT1hbczEgJiAweGZmXSkgXiBrZXlTY2hlZHVsZVtrc1JvdysrXVxuICB0MyA9ICgoU0JPWFtzMyA+Pj4gMjRdIDw8IDI0KSB8IChTQk9YWyhzMCA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKFNCT1hbKHMxID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgU0JPWFtzMiAmIDB4ZmZdKSBeIGtleVNjaGVkdWxlW2tzUm93KytdXG4gIHJldHVybiBbXG4gICAgZml4dXBfdWludDMyKHQwKSxcbiAgICBmaXh1cF91aW50MzIodDEpLFxuICAgIGZpeHVwX3VpbnQzMih0MiksXG4gICAgZml4dXBfdWludDMyKHQzKVxuICBdXG59XG5cbmV4cG9ydHMuQUVTID0gQUVTXG4iLCJ2YXIgYWVzID0gcmVxdWlyZSgnLi9hZXMnKVxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJ2NpcGhlci1iYXNlJylcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBHSEFTSCA9IHJlcXVpcmUoJy4vZ2hhc2gnKVxudmFyIHhvciA9IHJlcXVpcmUoJ2J1ZmZlci14b3InKVxuaW5oZXJpdHMoU3RyZWFtQ2lwaGVyLCBUcmFuc2Zvcm0pXG5tb2R1bGUuZXhwb3J0cyA9IFN0cmVhbUNpcGhlclxuXG5mdW5jdGlvbiBTdHJlYW1DaXBoZXIgKG1vZGUsIGtleSwgaXYsIGRlY3J5cHQpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFN0cmVhbUNpcGhlcikpIHtcbiAgICByZXR1cm4gbmV3IFN0cmVhbUNpcGhlcihtb2RlLCBrZXksIGl2KVxuICB9XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMpXG4gIHRoaXMuX2ZpbklEID0gQnVmZmVyLmNvbmNhdChbaXYsIG5ldyBCdWZmZXIoWzAsIDAsIDAsIDFdKV0pXG4gIGl2ID0gQnVmZmVyLmNvbmNhdChbaXYsIG5ldyBCdWZmZXIoWzAsIDAsIDAsIDJdKV0pXG4gIHRoaXMuX2NpcGhlciA9IG5ldyBhZXMuQUVTKGtleSlcbiAgdGhpcy5fcHJldiA9IG5ldyBCdWZmZXIoaXYubGVuZ3RoKVxuICB0aGlzLl9jYWNoZSA9IG5ldyBCdWZmZXIoJycpXG4gIHRoaXMuX3NlY0NhY2hlID0gbmV3IEJ1ZmZlcignJylcbiAgdGhpcy5fZGVjcnlwdCA9IGRlY3J5cHRcbiAgdGhpcy5fYWxlbiA9IDBcbiAgdGhpcy5fbGVuID0gMFxuICBpdi5jb3B5KHRoaXMuX3ByZXYpXG4gIHRoaXMuX21vZGUgPSBtb2RlXG4gIHZhciBoID0gbmV3IEJ1ZmZlcig0KVxuICBoLmZpbGwoMClcbiAgdGhpcy5fZ2hhc2ggPSBuZXcgR0hBU0godGhpcy5fY2lwaGVyLmVuY3J5cHRCbG9jayhoKSlcbiAgdGhpcy5fYXV0aFRhZyA9IG51bGxcbiAgdGhpcy5fY2FsbGVkID0gZmFsc2Vcbn1cblN0cmVhbUNpcGhlci5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChjaHVuaykge1xuICBpZiAoIXRoaXMuX2NhbGxlZCAmJiB0aGlzLl9hbGVuKSB7XG4gICAgdmFyIHJ1bXAgPSAxNiAtICh0aGlzLl9hbGVuICUgMTYpXG4gICAgaWYgKHJ1bXAgPCAxNikge1xuICAgICAgcnVtcCA9IG5ldyBCdWZmZXIocnVtcClcbiAgICAgIHJ1bXAuZmlsbCgwKVxuICAgICAgdGhpcy5fZ2hhc2gudXBkYXRlKHJ1bXApXG4gICAgfVxuICB9XG4gIHRoaXMuX2NhbGxlZCA9IHRydWVcbiAgdmFyIG91dCA9IHRoaXMuX21vZGUuZW5jcnlwdCh0aGlzLCBjaHVuaylcbiAgaWYgKHRoaXMuX2RlY3J5cHQpIHtcbiAgICB0aGlzLl9naGFzaC51cGRhdGUoY2h1bmspXG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fZ2hhc2gudXBkYXRlKG91dClcbiAgfVxuICB0aGlzLl9sZW4gKz0gY2h1bmsubGVuZ3RoXG4gIHJldHVybiBvdXRcbn1cblN0cmVhbUNpcGhlci5wcm90b3R5cGUuX2ZpbmFsID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5fZGVjcnlwdCAmJiAhdGhpcy5fYXV0aFRhZykge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgc3RhdGUgb3IgdW5hYmxlIHRvIGF1dGhlbnRpY2F0ZSBkYXRhJylcbiAgfVxuICB2YXIgdGFnID0geG9yKHRoaXMuX2doYXNoLmZpbmFsKHRoaXMuX2FsZW4gKiA4LCB0aGlzLl9sZW4gKiA4KSwgdGhpcy5fY2lwaGVyLmVuY3J5cHRCbG9jayh0aGlzLl9maW5JRCkpXG4gIGlmICh0aGlzLl9kZWNyeXB0KSB7XG4gICAgaWYgKHhvclRlc3QodGFnLCB0aGlzLl9hdXRoVGFnKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBzdGF0ZSBvciB1bmFibGUgdG8gYXV0aGVudGljYXRlIGRhdGEnKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9hdXRoVGFnID0gdGFnXG4gIH1cbiAgdGhpcy5fY2lwaGVyLnNjcnViKClcbn1cblN0cmVhbUNpcGhlci5wcm90b3R5cGUuZ2V0QXV0aFRhZyA9IGZ1bmN0aW9uIGdldEF1dGhUYWcgKCkge1xuICBpZiAoIXRoaXMuX2RlY3J5cHQgJiYgQnVmZmVyLmlzQnVmZmVyKHRoaXMuX2F1dGhUYWcpKSB7XG4gICAgcmV0dXJuIHRoaXMuX2F1dGhUYWdcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0F0dGVtcHRpbmcgdG8gZ2V0IGF1dGggdGFnIGluIHVuc3VwcG9ydGVkIHN0YXRlJylcbiAgfVxufVxuU3RyZWFtQ2lwaGVyLnByb3RvdHlwZS5zZXRBdXRoVGFnID0gZnVuY3Rpb24gc2V0QXV0aFRhZyAodGFnKSB7XG4gIGlmICh0aGlzLl9kZWNyeXB0KSB7XG4gICAgdGhpcy5fYXV0aFRhZyA9IHRhZ1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignQXR0ZW1wdGluZyB0byBzZXQgYXV0aCB0YWcgaW4gdW5zdXBwb3J0ZWQgc3RhdGUnKVxuICB9XG59XG5TdHJlYW1DaXBoZXIucHJvdG90eXBlLnNldEFBRCA9IGZ1bmN0aW9uIHNldEFBRCAoYnVmKSB7XG4gIGlmICghdGhpcy5fY2FsbGVkKSB7XG4gICAgdGhpcy5fZ2hhc2gudXBkYXRlKGJ1ZilcbiAgICB0aGlzLl9hbGVuICs9IGJ1Zi5sZW5ndGhcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0F0dGVtcHRpbmcgdG8gc2V0IEFBRCBpbiB1bnN1cHBvcnRlZCBzdGF0ZScpXG4gIH1cbn1cbmZ1bmN0aW9uIHhvclRlc3QgKGEsIGIpIHtcbiAgdmFyIG91dCA9IDBcbiAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgIG91dCsrXG4gIH1cbiAgdmFyIGxlbiA9IE1hdGgubWluKGEubGVuZ3RoLCBiLmxlbmd0aClcbiAgdmFyIGkgPSAtMVxuICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgb3V0ICs9IChhW2ldIF4gYltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG4iLCJ2YXIgY2lwaGVycyA9IHJlcXVpcmUoJy4vZW5jcnlwdGVyJylcbmV4cG9ydHMuY3JlYXRlQ2lwaGVyID0gZXhwb3J0cy5DaXBoZXIgPSBjaXBoZXJzLmNyZWF0ZUNpcGhlclxuZXhwb3J0cy5jcmVhdGVDaXBoZXJpdiA9IGV4cG9ydHMuQ2lwaGVyaXYgPSBjaXBoZXJzLmNyZWF0ZUNpcGhlcml2XG52YXIgZGVjaXBoZXJzID0gcmVxdWlyZSgnLi9kZWNyeXB0ZXInKVxuZXhwb3J0cy5jcmVhdGVEZWNpcGhlciA9IGV4cG9ydHMuRGVjaXBoZXIgPSBkZWNpcGhlcnMuY3JlYXRlRGVjaXBoZXJcbmV4cG9ydHMuY3JlYXRlRGVjaXBoZXJpdiA9IGV4cG9ydHMuRGVjaXBoZXJpdiA9IGRlY2lwaGVycy5jcmVhdGVEZWNpcGhlcml2XG52YXIgbW9kZXMgPSByZXF1aXJlKCcuL21vZGVzJylcbmZ1bmN0aW9uIGdldENpcGhlcnMgKCkge1xuICByZXR1cm4gT2JqZWN0LmtleXMobW9kZXMpXG59XG5leHBvcnRzLmxpc3RDaXBoZXJzID0gZXhwb3J0cy5nZXRDaXBoZXJzID0gZ2V0Q2lwaGVyc1xuIiwidmFyIGFlcyA9IHJlcXVpcmUoJy4vYWVzJylcbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCdjaXBoZXItYmFzZScpXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgbW9kZXMgPSByZXF1aXJlKCcuL21vZGVzJylcbnZhciBTdHJlYW1DaXBoZXIgPSByZXF1aXJlKCcuL3N0cmVhbUNpcGhlcicpXG52YXIgQXV0aENpcGhlciA9IHJlcXVpcmUoJy4vYXV0aENpcGhlcicpXG52YXIgZWJ0ayA9IHJlcXVpcmUoJ2V2cF9ieXRlc3Rva2V5JylcblxuaW5oZXJpdHMoRGVjaXBoZXIsIFRyYW5zZm9ybSlcbmZ1bmN0aW9uIERlY2lwaGVyIChtb2RlLCBrZXksIGl2KSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEZWNpcGhlcikpIHtcbiAgICByZXR1cm4gbmV3IERlY2lwaGVyKG1vZGUsIGtleSwgaXYpXG4gIH1cbiAgVHJhbnNmb3JtLmNhbGwodGhpcylcbiAgdGhpcy5fY2FjaGUgPSBuZXcgU3BsaXR0ZXIoKVxuICB0aGlzLl9sYXN0ID0gdm9pZCAwXG4gIHRoaXMuX2NpcGhlciA9IG5ldyBhZXMuQUVTKGtleSlcbiAgdGhpcy5fcHJldiA9IG5ldyBCdWZmZXIoaXYubGVuZ3RoKVxuICBpdi5jb3B5KHRoaXMuX3ByZXYpXG4gIHRoaXMuX21vZGUgPSBtb2RlXG4gIHRoaXMuX2F1dG9wYWRkaW5nID0gdHJ1ZVxufVxuRGVjaXBoZXIucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB0aGlzLl9jYWNoZS5hZGQoZGF0YSlcbiAgdmFyIGNodW5rXG4gIHZhciB0aGluZ1xuICB2YXIgb3V0ID0gW11cbiAgd2hpbGUgKChjaHVuayA9IHRoaXMuX2NhY2hlLmdldCh0aGlzLl9hdXRvcGFkZGluZykpKSB7XG4gICAgdGhpbmcgPSB0aGlzLl9tb2RlLmRlY3J5cHQodGhpcywgY2h1bmspXG4gICAgb3V0LnB1c2godGhpbmcpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5jb25jYXQob3V0KVxufVxuRGVjaXBoZXIucHJvdG90eXBlLl9maW5hbCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGNodW5rID0gdGhpcy5fY2FjaGUuZmx1c2goKVxuICBpZiAodGhpcy5fYXV0b3BhZGRpbmcpIHtcbiAgICByZXR1cm4gdW5wYWQodGhpcy5fbW9kZS5kZWNyeXB0KHRoaXMsIGNodW5rKSlcbiAgfSBlbHNlIGlmIChjaHVuaykge1xuICAgIHRocm93IG5ldyBFcnJvcignZGF0YSBub3QgbXVsdGlwbGUgb2YgYmxvY2sgbGVuZ3RoJylcbiAgfVxufVxuRGVjaXBoZXIucHJvdG90eXBlLnNldEF1dG9QYWRkaW5nID0gZnVuY3Rpb24gKHNldFRvKSB7XG4gIHRoaXMuX2F1dG9wYWRkaW5nID0gISFzZXRUb1xufVxuZnVuY3Rpb24gU3BsaXR0ZXIgKCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU3BsaXR0ZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBTcGxpdHRlcigpXG4gIH1cbiAgdGhpcy5jYWNoZSA9IG5ldyBCdWZmZXIoJycpXG59XG5TcGxpdHRlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgdGhpcy5jYWNoZSA9IEJ1ZmZlci5jb25jYXQoW3RoaXMuY2FjaGUsIGRhdGFdKVxufVxuXG5TcGxpdHRlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGF1dG9QYWRkaW5nKSB7XG4gIHZhciBvdXRcbiAgaWYgKGF1dG9QYWRkaW5nKSB7XG4gICAgaWYgKHRoaXMuY2FjaGUubGVuZ3RoID4gMTYpIHtcbiAgICAgIG91dCA9IHRoaXMuY2FjaGUuc2xpY2UoMCwgMTYpXG4gICAgICB0aGlzLmNhY2hlID0gdGhpcy5jYWNoZS5zbGljZSgxNilcbiAgICAgIHJldHVybiBvdXRcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHRoaXMuY2FjaGUubGVuZ3RoID49IDE2KSB7XG4gICAgICBvdXQgPSB0aGlzLmNhY2hlLnNsaWNlKDAsIDE2KVxuICAgICAgdGhpcy5jYWNoZSA9IHRoaXMuY2FjaGUuc2xpY2UoMTYpXG4gICAgICByZXR1cm4gb3V0XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsXG59XG5TcGxpdHRlci5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmNhY2hlLmxlbmd0aCkge1xuICAgIHJldHVybiB0aGlzLmNhY2hlXG4gIH1cbn1cbmZ1bmN0aW9uIHVucGFkIChsYXN0KSB7XG4gIHZhciBwYWRkZWQgPSBsYXN0WzE1XVxuICB2YXIgaSA9IC0xXG4gIHdoaWxlICgrK2kgPCBwYWRkZWQpIHtcbiAgICBpZiAobGFzdFsoaSArICgxNiAtIHBhZGRlZCkpXSAhPT0gcGFkZGVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuYWJsZSB0byBkZWNyeXB0IGRhdGEnKVxuICAgIH1cbiAgfVxuICBpZiAocGFkZGVkID09PSAxNikge1xuICAgIHJldHVyblxuICB9XG4gIHJldHVybiBsYXN0LnNsaWNlKDAsIDE2IC0gcGFkZGVkKVxufVxuXG52YXIgbW9kZWxpc3QgPSB7XG4gIEVDQjogcmVxdWlyZSgnLi9tb2Rlcy9lY2InKSxcbiAgQ0JDOiByZXF1aXJlKCcuL21vZGVzL2NiYycpLFxuICBDRkI6IHJlcXVpcmUoJy4vbW9kZXMvY2ZiJyksXG4gIENGQjg6IHJlcXVpcmUoJy4vbW9kZXMvY2ZiOCcpLFxuICBDRkIxOiByZXF1aXJlKCcuL21vZGVzL2NmYjEnKSxcbiAgT0ZCOiByZXF1aXJlKCcuL21vZGVzL29mYicpLFxuICBDVFI6IHJlcXVpcmUoJy4vbW9kZXMvY3RyJyksXG4gIEdDTTogcmVxdWlyZSgnLi9tb2Rlcy9jdHInKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVEZWNpcGhlcml2IChzdWl0ZSwgcGFzc3dvcmQsIGl2KSB7XG4gIHZhciBjb25maWcgPSBtb2Rlc1tzdWl0ZS50b0xvd2VyQ2FzZSgpXVxuICBpZiAoIWNvbmZpZykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgc3VpdGUgdHlwZScpXG4gIH1cbiAgaWYgKHR5cGVvZiBpdiA9PT0gJ3N0cmluZycpIHtcbiAgICBpdiA9IG5ldyBCdWZmZXIoaXYpXG4gIH1cbiAgaWYgKHR5cGVvZiBwYXNzd29yZCA9PT0gJ3N0cmluZycpIHtcbiAgICBwYXNzd29yZCA9IG5ldyBCdWZmZXIocGFzc3dvcmQpXG4gIH1cbiAgaWYgKHBhc3N3b3JkLmxlbmd0aCAhPT0gY29uZmlnLmtleSAvIDgpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGtleSBsZW5ndGggJyArIHBhc3N3b3JkLmxlbmd0aClcbiAgfVxuICBpZiAoaXYubGVuZ3RoICE9PSBjb25maWcuaXYpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGl2IGxlbmd0aCAnICsgaXYubGVuZ3RoKVxuICB9XG4gIGlmIChjb25maWcudHlwZSA9PT0gJ3N0cmVhbScpIHtcbiAgICByZXR1cm4gbmV3IFN0cmVhbUNpcGhlcihtb2RlbGlzdFtjb25maWcubW9kZV0sIHBhc3N3b3JkLCBpdiwgdHJ1ZSlcbiAgfSBlbHNlIGlmIChjb25maWcudHlwZSA9PT0gJ2F1dGgnKSB7XG4gICAgcmV0dXJuIG5ldyBBdXRoQ2lwaGVyKG1vZGVsaXN0W2NvbmZpZy5tb2RlXSwgcGFzc3dvcmQsIGl2LCB0cnVlKVxuICB9XG4gIHJldHVybiBuZXcgRGVjaXBoZXIobW9kZWxpc3RbY29uZmlnLm1vZGVdLCBwYXNzd29yZCwgaXYpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZURlY2lwaGVyIChzdWl0ZSwgcGFzc3dvcmQpIHtcbiAgdmFyIGNvbmZpZyA9IG1vZGVzW3N1aXRlLnRvTG93ZXJDYXNlKCldXG4gIGlmICghY29uZmlnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBzdWl0ZSB0eXBlJylcbiAgfVxuICB2YXIga2V5cyA9IGVidGsocGFzc3dvcmQsIGZhbHNlLCBjb25maWcua2V5LCBjb25maWcuaXYpXG4gIHJldHVybiBjcmVhdGVEZWNpcGhlcml2KHN1aXRlLCBrZXlzLmtleSwga2V5cy5pdilcbn1cbmV4cG9ydHMuY3JlYXRlRGVjaXBoZXIgPSBjcmVhdGVEZWNpcGhlclxuZXhwb3J0cy5jcmVhdGVEZWNpcGhlcml2ID0gY3JlYXRlRGVjaXBoZXJpdlxuIiwidmFyIGFlcyA9IHJlcXVpcmUoJy4vYWVzJylcbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCdjaXBoZXItYmFzZScpXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgbW9kZXMgPSByZXF1aXJlKCcuL21vZGVzJylcbnZhciBlYnRrID0gcmVxdWlyZSgnZXZwX2J5dGVzdG9rZXknKVxudmFyIFN0cmVhbUNpcGhlciA9IHJlcXVpcmUoJy4vc3RyZWFtQ2lwaGVyJylcbnZhciBBdXRoQ2lwaGVyID0gcmVxdWlyZSgnLi9hdXRoQ2lwaGVyJylcbmluaGVyaXRzKENpcGhlciwgVHJhbnNmb3JtKVxuZnVuY3Rpb24gQ2lwaGVyIChtb2RlLCBrZXksIGl2KSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBDaXBoZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBDaXBoZXIobW9kZSwga2V5LCBpdilcbiAgfVxuICBUcmFuc2Zvcm0uY2FsbCh0aGlzKVxuICB0aGlzLl9jYWNoZSA9IG5ldyBTcGxpdHRlcigpXG4gIHRoaXMuX2NpcGhlciA9IG5ldyBhZXMuQUVTKGtleSlcbiAgdGhpcy5fcHJldiA9IG5ldyBCdWZmZXIoaXYubGVuZ3RoKVxuICBpdi5jb3B5KHRoaXMuX3ByZXYpXG4gIHRoaXMuX21vZGUgPSBtb2RlXG4gIHRoaXMuX2F1dG9wYWRkaW5nID0gdHJ1ZVxufVxuQ2lwaGVyLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgdGhpcy5fY2FjaGUuYWRkKGRhdGEpXG4gIHZhciBjaHVua1xuICB2YXIgdGhpbmdcbiAgdmFyIG91dCA9IFtdXG4gIHdoaWxlICgoY2h1bmsgPSB0aGlzLl9jYWNoZS5nZXQoKSkpIHtcbiAgICB0aGluZyA9IHRoaXMuX21vZGUuZW5jcnlwdCh0aGlzLCBjaHVuaylcbiAgICBvdXQucHVzaCh0aGluZylcbiAgfVxuICByZXR1cm4gQnVmZmVyLmNvbmNhdChvdXQpXG59XG5DaXBoZXIucHJvdG90eXBlLl9maW5hbCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGNodW5rID0gdGhpcy5fY2FjaGUuZmx1c2goKVxuICBpZiAodGhpcy5fYXV0b3BhZGRpbmcpIHtcbiAgICBjaHVuayA9IHRoaXMuX21vZGUuZW5jcnlwdCh0aGlzLCBjaHVuaylcbiAgICB0aGlzLl9jaXBoZXIuc2NydWIoKVxuICAgIHJldHVybiBjaHVua1xuICB9IGVsc2UgaWYgKGNodW5rLnRvU3RyaW5nKCdoZXgnKSAhPT0gJzEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwJykge1xuICAgIHRoaXMuX2NpcGhlci5zY3J1YigpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdkYXRhIG5vdCBtdWx0aXBsZSBvZiBibG9jayBsZW5ndGgnKVxuICB9XG59XG5DaXBoZXIucHJvdG90eXBlLnNldEF1dG9QYWRkaW5nID0gZnVuY3Rpb24gKHNldFRvKSB7XG4gIHRoaXMuX2F1dG9wYWRkaW5nID0gISFzZXRUb1xufVxuXG5mdW5jdGlvbiBTcGxpdHRlciAoKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTcGxpdHRlcikpIHtcbiAgICByZXR1cm4gbmV3IFNwbGl0dGVyKClcbiAgfVxuICB0aGlzLmNhY2hlID0gbmV3IEJ1ZmZlcignJylcbn1cblNwbGl0dGVyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB0aGlzLmNhY2hlID0gQnVmZmVyLmNvbmNhdChbdGhpcy5jYWNoZSwgZGF0YV0pXG59XG5cblNwbGl0dGVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmNhY2hlLmxlbmd0aCA+IDE1KSB7XG4gICAgdmFyIG91dCA9IHRoaXMuY2FjaGUuc2xpY2UoMCwgMTYpXG4gICAgdGhpcy5jYWNoZSA9IHRoaXMuY2FjaGUuc2xpY2UoMTYpXG4gICAgcmV0dXJuIG91dFxuICB9XG4gIHJldHVybiBudWxsXG59XG5TcGxpdHRlci5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBsZW4gPSAxNiAtIHRoaXMuY2FjaGUubGVuZ3RoXG4gIHZhciBwYWRCdWZmID0gbmV3IEJ1ZmZlcihsZW4pXG5cbiAgdmFyIGkgPSAtMVxuICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgcGFkQnVmZi53cml0ZVVJbnQ4KGxlbiwgaSlcbiAgfVxuICB2YXIgb3V0ID0gQnVmZmVyLmNvbmNhdChbdGhpcy5jYWNoZSwgcGFkQnVmZl0pXG4gIHJldHVybiBvdXRcbn1cbnZhciBtb2RlbGlzdCA9IHtcbiAgRUNCOiByZXF1aXJlKCcuL21vZGVzL2VjYicpLFxuICBDQkM6IHJlcXVpcmUoJy4vbW9kZXMvY2JjJyksXG4gIENGQjogcmVxdWlyZSgnLi9tb2Rlcy9jZmInKSxcbiAgQ0ZCODogcmVxdWlyZSgnLi9tb2Rlcy9jZmI4JyksXG4gIENGQjE6IHJlcXVpcmUoJy4vbW9kZXMvY2ZiMScpLFxuICBPRkI6IHJlcXVpcmUoJy4vbW9kZXMvb2ZiJyksXG4gIENUUjogcmVxdWlyZSgnLi9tb2Rlcy9jdHInKSxcbiAgR0NNOiByZXF1aXJlKCcuL21vZGVzL2N0cicpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNpcGhlcml2IChzdWl0ZSwgcGFzc3dvcmQsIGl2KSB7XG4gIHZhciBjb25maWcgPSBtb2Rlc1tzdWl0ZS50b0xvd2VyQ2FzZSgpXVxuICBpZiAoIWNvbmZpZykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgc3VpdGUgdHlwZScpXG4gIH1cbiAgaWYgKHR5cGVvZiBpdiA9PT0gJ3N0cmluZycpIHtcbiAgICBpdiA9IG5ldyBCdWZmZXIoaXYpXG4gIH1cbiAgaWYgKHR5cGVvZiBwYXNzd29yZCA9PT0gJ3N0cmluZycpIHtcbiAgICBwYXNzd29yZCA9IG5ldyBCdWZmZXIocGFzc3dvcmQpXG4gIH1cbiAgaWYgKHBhc3N3b3JkLmxlbmd0aCAhPT0gY29uZmlnLmtleSAvIDgpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGtleSBsZW5ndGggJyArIHBhc3N3b3JkLmxlbmd0aClcbiAgfVxuICBpZiAoaXYubGVuZ3RoICE9PSBjb25maWcuaXYpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGl2IGxlbmd0aCAnICsgaXYubGVuZ3RoKVxuICB9XG4gIGlmIChjb25maWcudHlwZSA9PT0gJ3N0cmVhbScpIHtcbiAgICByZXR1cm4gbmV3IFN0cmVhbUNpcGhlcihtb2RlbGlzdFtjb25maWcubW9kZV0sIHBhc3N3b3JkLCBpdilcbiAgfSBlbHNlIGlmIChjb25maWcudHlwZSA9PT0gJ2F1dGgnKSB7XG4gICAgcmV0dXJuIG5ldyBBdXRoQ2lwaGVyKG1vZGVsaXN0W2NvbmZpZy5tb2RlXSwgcGFzc3dvcmQsIGl2KVxuICB9XG4gIHJldHVybiBuZXcgQ2lwaGVyKG1vZGVsaXN0W2NvbmZpZy5tb2RlXSwgcGFzc3dvcmQsIGl2KVxufVxuZnVuY3Rpb24gY3JlYXRlQ2lwaGVyIChzdWl0ZSwgcGFzc3dvcmQpIHtcbiAgdmFyIGNvbmZpZyA9IG1vZGVzW3N1aXRlLnRvTG93ZXJDYXNlKCldXG4gIGlmICghY29uZmlnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBzdWl0ZSB0eXBlJylcbiAgfVxuICB2YXIga2V5cyA9IGVidGsocGFzc3dvcmQsIGZhbHNlLCBjb25maWcua2V5LCBjb25maWcuaXYpXG4gIHJldHVybiBjcmVhdGVDaXBoZXJpdihzdWl0ZSwga2V5cy5rZXksIGtleXMuaXYpXG59XG5cbmV4cG9ydHMuY3JlYXRlQ2lwaGVyaXYgPSBjcmVhdGVDaXBoZXJpdlxuZXhwb3J0cy5jcmVhdGVDaXBoZXIgPSBjcmVhdGVDaXBoZXJcbiIsInZhciB6ZXJvcyA9IG5ldyBCdWZmZXIoMTYpXG56ZXJvcy5maWxsKDApXG5tb2R1bGUuZXhwb3J0cyA9IEdIQVNIXG5mdW5jdGlvbiBHSEFTSCAoa2V5KSB7XG4gIHRoaXMuaCA9IGtleVxuICB0aGlzLnN0YXRlID0gbmV3IEJ1ZmZlcigxNilcbiAgdGhpcy5zdGF0ZS5maWxsKDApXG4gIHRoaXMuY2FjaGUgPSBuZXcgQnVmZmVyKCcnKVxufVxuLy8gZnJvbSBodHRwOi8vYml0d2lzZXNoaWZ0bGVmdC5naXRodWIuaW8vc2pjbC9kb2Mvc3ltYm9scy9zcmMvY29yZV9nY20uanMuaHRtbFxuLy8gYnkgSnVobyBWw6Row6QtSGVydHR1YVxuR0hBU0gucHJvdG90eXBlLmdoYXNoID0gZnVuY3Rpb24gKGJsb2NrKSB7XG4gIHZhciBpID0gLTFcbiAgd2hpbGUgKCsraSA8IGJsb2NrLmxlbmd0aCkge1xuICAgIHRoaXMuc3RhdGVbaV0gXj0gYmxvY2tbaV1cbiAgfVxuICB0aGlzLl9tdWx0aXBseSgpXG59XG5cbkdIQVNILnByb3RvdHlwZS5fbXVsdGlwbHkgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBWaSA9IHRvQXJyYXkodGhpcy5oKVxuICB2YXIgWmkgPSBbMCwgMCwgMCwgMF1cbiAgdmFyIGosIHhpLCBsc2JfVmlcbiAgdmFyIGkgPSAtMVxuICB3aGlsZSAoKytpIDwgMTI4KSB7XG4gICAgeGkgPSAodGhpcy5zdGF0ZVt+fihpIC8gOCldICYgKDEgPDwgKDcgLSBpICUgOCkpKSAhPT0gMFxuICAgIGlmICh4aSkge1xuICAgICAgLy8gWl9pKzEgPSBaX2kgXiBWX2lcbiAgICAgIFppID0geG9yKFppLCBWaSlcbiAgICB9XG5cbiAgICAvLyBTdG9yZSB0aGUgdmFsdWUgb2YgTFNCKFZfaSlcbiAgICBsc2JfVmkgPSAoVmlbM10gJiAxKSAhPT0gMFxuXG4gICAgLy8gVl9pKzEgPSBWX2kgPj4gMVxuICAgIGZvciAoaiA9IDM7IGogPiAwOyBqLS0pIHtcbiAgICAgIFZpW2pdID0gKFZpW2pdID4+PiAxKSB8ICgoVmlbaiAtIDFdICYgMSkgPDwgMzEpXG4gICAgfVxuICAgIFZpWzBdID0gVmlbMF0gPj4+IDFcblxuICAgIC8vIElmIExTQihWX2kpIGlzIDEsIFZfaSsxID0gKFZfaSA+PiAxKSBeIFJcbiAgICBpZiAobHNiX1ZpKSB7XG4gICAgICBWaVswXSA9IFZpWzBdIF4gKDB4ZTEgPDwgMjQpXG4gICAgfVxuICB9XG4gIHRoaXMuc3RhdGUgPSBmcm9tQXJyYXkoWmkpXG59XG5HSEFTSC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGJ1Zikge1xuICB0aGlzLmNhY2hlID0gQnVmZmVyLmNvbmNhdChbdGhpcy5jYWNoZSwgYnVmXSlcbiAgdmFyIGNodW5rXG4gIHdoaWxlICh0aGlzLmNhY2hlLmxlbmd0aCA+PSAxNikge1xuICAgIGNodW5rID0gdGhpcy5jYWNoZS5zbGljZSgwLCAxNilcbiAgICB0aGlzLmNhY2hlID0gdGhpcy5jYWNoZS5zbGljZSgxNilcbiAgICB0aGlzLmdoYXNoKGNodW5rKVxuICB9XG59XG5HSEFTSC5wcm90b3R5cGUuZmluYWwgPSBmdW5jdGlvbiAoYWJsLCBibCkge1xuICBpZiAodGhpcy5jYWNoZS5sZW5ndGgpIHtcbiAgICB0aGlzLmdoYXNoKEJ1ZmZlci5jb25jYXQoW3RoaXMuY2FjaGUsIHplcm9zXSwgMTYpKVxuICB9XG4gIHRoaXMuZ2hhc2goZnJvbUFycmF5KFtcbiAgICAwLCBhYmwsXG4gICAgMCwgYmxcbiAgXSkpXG4gIHJldHVybiB0aGlzLnN0YXRlXG59XG5cbmZ1bmN0aW9uIHRvQXJyYXkgKGJ1Zikge1xuICByZXR1cm4gW1xuICAgIGJ1Zi5yZWFkVUludDMyQkUoMCksXG4gICAgYnVmLnJlYWRVSW50MzJCRSg0KSxcbiAgICBidWYucmVhZFVJbnQzMkJFKDgpLFxuICAgIGJ1Zi5yZWFkVUludDMyQkUoMTIpXG4gIF1cbn1cbmZ1bmN0aW9uIGZyb21BcnJheSAob3V0KSB7XG4gIG91dCA9IG91dC5tYXAoZml4dXBfdWludDMyKVxuICB2YXIgYnVmID0gbmV3IEJ1ZmZlcigxNilcbiAgYnVmLndyaXRlVUludDMyQkUob3V0WzBdLCAwKVxuICBidWYud3JpdGVVSW50MzJCRShvdXRbMV0sIDQpXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKG91dFsyXSwgOClcbiAgYnVmLndyaXRlVUludDMyQkUob3V0WzNdLCAxMilcbiAgcmV0dXJuIGJ1ZlxufVxudmFyIHVpbnRfbWF4ID0gTWF0aC5wb3coMiwgMzIpXG5mdW5jdGlvbiBmaXh1cF91aW50MzIgKHgpIHtcbiAgdmFyIHJldCwgeF9wb3NcbiAgcmV0ID0geCA+IHVpbnRfbWF4IHx8IHggPCAwID8gKHhfcG9zID0gTWF0aC5hYnMoeCkgJSB1aW50X21heCwgeCA8IDAgPyB1aW50X21heCAtIHhfcG9zIDogeF9wb3MpIDogeFxuICByZXR1cm4gcmV0XG59XG5mdW5jdGlvbiB4b3IgKGEsIGIpIHtcbiAgcmV0dXJuIFtcbiAgICBhWzBdIF4gYlswXSxcbiAgICBhWzFdIF4gYlsxXSxcbiAgICBhWzJdIF4gYlsyXSxcbiAgICBhWzNdIF4gYlszXVxuICBdXG59XG4iLCJleHBvcnRzWydhZXMtMTI4LWVjYiddID0ge1xuICBjaXBoZXI6ICdBRVMnLFxuICBrZXk6IDEyOCxcbiAgaXY6IDAsXG4gIG1vZGU6ICdFQ0InLFxuICB0eXBlOiAnYmxvY2snXG59XG5leHBvcnRzWydhZXMtMTkyLWVjYiddID0ge1xuICBjaXBoZXI6ICdBRVMnLFxuICBrZXk6IDE5MixcbiAgaXY6IDAsXG4gIG1vZGU6ICdFQ0InLFxuICB0eXBlOiAnYmxvY2snXG59XG5leHBvcnRzWydhZXMtMjU2LWVjYiddID0ge1xuICBjaXBoZXI6ICdBRVMnLFxuICBrZXk6IDI1NixcbiAgaXY6IDAsXG4gIG1vZGU6ICdFQ0InLFxuICB0eXBlOiAnYmxvY2snXG59XG5leHBvcnRzWydhZXMtMTI4LWNiYyddID0ge1xuICBjaXBoZXI6ICdBRVMnLFxuICBrZXk6IDEyOCxcbiAgaXY6IDE2LFxuICBtb2RlOiAnQ0JDJyxcbiAgdHlwZTogJ2Jsb2NrJ1xufVxuZXhwb3J0c1snYWVzLTE5Mi1jYmMnXSA9IHtcbiAgY2lwaGVyOiAnQUVTJyxcbiAga2V5OiAxOTIsXG4gIGl2OiAxNixcbiAgbW9kZTogJ0NCQycsXG4gIHR5cGU6ICdibG9jaydcbn1cbmV4cG9ydHNbJ2Flcy0yNTYtY2JjJ10gPSB7XG4gIGNpcGhlcjogJ0FFUycsXG4gIGtleTogMjU2LFxuICBpdjogMTYsXG4gIG1vZGU6ICdDQkMnLFxuICB0eXBlOiAnYmxvY2snXG59XG5leHBvcnRzWydhZXMxMjgnXSA9IGV4cG9ydHNbJ2Flcy0xMjgtY2JjJ11cbmV4cG9ydHNbJ2FlczE5MiddID0gZXhwb3J0c1snYWVzLTE5Mi1jYmMnXVxuZXhwb3J0c1snYWVzMjU2J10gPSBleHBvcnRzWydhZXMtMjU2LWNiYyddXG5leHBvcnRzWydhZXMtMTI4LWNmYiddID0ge1xuICBjaXBoZXI6ICdBRVMnLFxuICBrZXk6IDEyOCxcbiAgaXY6IDE2LFxuICBtb2RlOiAnQ0ZCJyxcbiAgdHlwZTogJ3N0cmVhbSdcbn1cbmV4cG9ydHNbJ2Flcy0xOTItY2ZiJ10gPSB7XG4gIGNpcGhlcjogJ0FFUycsXG4gIGtleTogMTkyLFxuICBpdjogMTYsXG4gIG1vZGU6ICdDRkInLFxuICB0eXBlOiAnc3RyZWFtJ1xufVxuZXhwb3J0c1snYWVzLTI1Ni1jZmInXSA9IHtcbiAgY2lwaGVyOiAnQUVTJyxcbiAga2V5OiAyNTYsXG4gIGl2OiAxNixcbiAgbW9kZTogJ0NGQicsXG4gIHR5cGU6ICdzdHJlYW0nXG59XG5leHBvcnRzWydhZXMtMTI4LWNmYjgnXSA9IHtcbiAgY2lwaGVyOiAnQUVTJyxcbiAga2V5OiAxMjgsXG4gIGl2OiAxNixcbiAgbW9kZTogJ0NGQjgnLFxuICB0eXBlOiAnc3RyZWFtJ1xufVxuZXhwb3J0c1snYWVzLTE5Mi1jZmI4J10gPSB7XG4gIGNpcGhlcjogJ0FFUycsXG4gIGtleTogMTkyLFxuICBpdjogMTYsXG4gIG1vZGU6ICdDRkI4JyxcbiAgdHlwZTogJ3N0cmVhbSdcbn1cbmV4cG9ydHNbJ2Flcy0yNTYtY2ZiOCddID0ge1xuICBjaXBoZXI6ICdBRVMnLFxuICBrZXk6IDI1NixcbiAgaXY6IDE2LFxuICBtb2RlOiAnQ0ZCOCcsXG4gIHR5cGU6ICdzdHJlYW0nXG59XG5leHBvcnRzWydhZXMtMTI4LWNmYjEnXSA9IHtcbiAgY2lwaGVyOiAnQUVTJyxcbiAga2V5OiAxMjgsXG4gIGl2OiAxNixcbiAgbW9kZTogJ0NGQjEnLFxuICB0eXBlOiAnc3RyZWFtJ1xufVxuZXhwb3J0c1snYWVzLTE5Mi1jZmIxJ10gPSB7XG4gIGNpcGhlcjogJ0FFUycsXG4gIGtleTogMTkyLFxuICBpdjogMTYsXG4gIG1vZGU6ICdDRkIxJyxcbiAgdHlwZTogJ3N0cmVhbSdcbn1cbmV4cG9ydHNbJ2Flcy0yNTYtY2ZiMSddID0ge1xuICBjaXBoZXI6ICdBRVMnLFxuICBrZXk6IDI1NixcbiAgaXY6IDE2LFxuICBtb2RlOiAnQ0ZCMScsXG4gIHR5cGU6ICdzdHJlYW0nXG59XG5leHBvcnRzWydhZXMtMTI4LW9mYiddID0ge1xuICBjaXBoZXI6ICdBRVMnLFxuICBrZXk6IDEyOCxcbiAgaXY6IDE2LFxuICBtb2RlOiAnT0ZCJyxcbiAgdHlwZTogJ3N0cmVhbSdcbn1cbmV4cG9ydHNbJ2Flcy0xOTItb2ZiJ10gPSB7XG4gIGNpcGhlcjogJ0FFUycsXG4gIGtleTogMTkyLFxuICBpdjogMTYsXG4gIG1vZGU6ICdPRkInLFxuICB0eXBlOiAnc3RyZWFtJ1xufVxuZXhwb3J0c1snYWVzLTI1Ni1vZmInXSA9IHtcbiAgY2lwaGVyOiAnQUVTJyxcbiAga2V5OiAyNTYsXG4gIGl2OiAxNixcbiAgbW9kZTogJ09GQicsXG4gIHR5cGU6ICdzdHJlYW0nXG59XG5leHBvcnRzWydhZXMtMTI4LWN0ciddID0ge1xuICBjaXBoZXI6ICdBRVMnLFxuICBrZXk6IDEyOCxcbiAgaXY6IDE2LFxuICBtb2RlOiAnQ1RSJyxcbiAgdHlwZTogJ3N0cmVhbSdcbn1cbmV4cG9ydHNbJ2Flcy0xOTItY3RyJ10gPSB7XG4gIGNpcGhlcjogJ0FFUycsXG4gIGtleTogMTkyLFxuICBpdjogMTYsXG4gIG1vZGU6ICdDVFInLFxuICB0eXBlOiAnc3RyZWFtJ1xufVxuZXhwb3J0c1snYWVzLTI1Ni1jdHInXSA9IHtcbiAgY2lwaGVyOiAnQUVTJyxcbiAga2V5OiAyNTYsXG4gIGl2OiAxNixcbiAgbW9kZTogJ0NUUicsXG4gIHR5cGU6ICdzdHJlYW0nXG59XG5leHBvcnRzWydhZXMtMTI4LWdjbSddID0ge1xuICBjaXBoZXI6ICdBRVMnLFxuICBrZXk6IDEyOCxcbiAgaXY6IDEyLFxuICBtb2RlOiAnR0NNJyxcbiAgdHlwZTogJ2F1dGgnXG59XG5leHBvcnRzWydhZXMtMTkyLWdjbSddID0ge1xuICBjaXBoZXI6ICdBRVMnLFxuICBrZXk6IDE5MixcbiAgaXY6IDEyLFxuICBtb2RlOiAnR0NNJyxcbiAgdHlwZTogJ2F1dGgnXG59XG5leHBvcnRzWydhZXMtMjU2LWdjbSddID0ge1xuICBjaXBoZXI6ICdBRVMnLFxuICBrZXk6IDI1NixcbiAgaXY6IDEyLFxuICBtb2RlOiAnR0NNJyxcbiAgdHlwZTogJ2F1dGgnXG59XG4iLCJ2YXIgeG9yID0gcmVxdWlyZSgnYnVmZmVyLXhvcicpXG5cbmV4cG9ydHMuZW5jcnlwdCA9IGZ1bmN0aW9uIChzZWxmLCBibG9jaykge1xuICB2YXIgZGF0YSA9IHhvcihibG9jaywgc2VsZi5fcHJldilcblxuICBzZWxmLl9wcmV2ID0gc2VsZi5fY2lwaGVyLmVuY3J5cHRCbG9jayhkYXRhKVxuICByZXR1cm4gc2VsZi5fcHJldlxufVxuXG5leHBvcnRzLmRlY3J5cHQgPSBmdW5jdGlvbiAoc2VsZiwgYmxvY2spIHtcbiAgdmFyIHBhZCA9IHNlbGYuX3ByZXZcblxuICBzZWxmLl9wcmV2ID0gYmxvY2tcbiAgdmFyIG91dCA9IHNlbGYuX2NpcGhlci5kZWNyeXB0QmxvY2soYmxvY2spXG5cbiAgcmV0dXJuIHhvcihvdXQsIHBhZClcbn1cbiIsInZhciB4b3IgPSByZXF1aXJlKCdidWZmZXIteG9yJylcblxuZXhwb3J0cy5lbmNyeXB0ID0gZnVuY3Rpb24gKHNlbGYsIGRhdGEsIGRlY3J5cHQpIHtcbiAgdmFyIG91dCA9IG5ldyBCdWZmZXIoJycpXG4gIHZhciBsZW5cblxuICB3aGlsZSAoZGF0YS5sZW5ndGgpIHtcbiAgICBpZiAoc2VsZi5fY2FjaGUubGVuZ3RoID09PSAwKSB7XG4gICAgICBzZWxmLl9jYWNoZSA9IHNlbGYuX2NpcGhlci5lbmNyeXB0QmxvY2soc2VsZi5fcHJldilcbiAgICAgIHNlbGYuX3ByZXYgPSBuZXcgQnVmZmVyKCcnKVxuICAgIH1cblxuICAgIGlmIChzZWxmLl9jYWNoZS5sZW5ndGggPD0gZGF0YS5sZW5ndGgpIHtcbiAgICAgIGxlbiA9IHNlbGYuX2NhY2hlLmxlbmd0aFxuICAgICAgb3V0ID0gQnVmZmVyLmNvbmNhdChbb3V0LCBlbmNyeXB0U3RhcnQoc2VsZiwgZGF0YS5zbGljZSgwLCBsZW4pLCBkZWNyeXB0KV0pXG4gICAgICBkYXRhID0gZGF0YS5zbGljZShsZW4pXG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCA9IEJ1ZmZlci5jb25jYXQoW291dCwgZW5jcnlwdFN0YXJ0KHNlbGYsIGRhdGEsIGRlY3J5cHQpXSlcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG91dFxufVxuZnVuY3Rpb24gZW5jcnlwdFN0YXJ0IChzZWxmLCBkYXRhLCBkZWNyeXB0KSB7XG4gIHZhciBsZW4gPSBkYXRhLmxlbmd0aFxuICB2YXIgb3V0ID0geG9yKGRhdGEsIHNlbGYuX2NhY2hlKVxuICBzZWxmLl9jYWNoZSA9IHNlbGYuX2NhY2hlLnNsaWNlKGxlbilcbiAgc2VsZi5fcHJldiA9IEJ1ZmZlci5jb25jYXQoW3NlbGYuX3ByZXYsIGRlY3J5cHQgPyBkYXRhIDogb3V0XSlcbiAgcmV0dXJuIG91dFxufVxuIiwiZnVuY3Rpb24gZW5jcnlwdEJ5dGUgKHNlbGYsIGJ5dGVQYXJhbSwgZGVjcnlwdCkge1xuICB2YXIgcGFkXG4gIHZhciBpID0gLTFcbiAgdmFyIGxlbiA9IDhcbiAgdmFyIG91dCA9IDBcbiAgdmFyIGJpdCwgdmFsdWVcbiAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgIHBhZCA9IHNlbGYuX2NpcGhlci5lbmNyeXB0QmxvY2soc2VsZi5fcHJldilcbiAgICBiaXQgPSAoYnl0ZVBhcmFtICYgKDEgPDwgKDcgLSBpKSkpID8gMHg4MCA6IDBcbiAgICB2YWx1ZSA9IHBhZFswXSBeIGJpdFxuICAgIG91dCArPSAoKHZhbHVlICYgMHg4MCkgPj4gKGkgJSA4KSlcbiAgICBzZWxmLl9wcmV2ID0gc2hpZnRJbihzZWxmLl9wcmV2LCBkZWNyeXB0ID8gYml0IDogdmFsdWUpXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuZXhwb3J0cy5lbmNyeXB0ID0gZnVuY3Rpb24gKHNlbGYsIGNodW5rLCBkZWNyeXB0KSB7XG4gIHZhciBsZW4gPSBjaHVuay5sZW5ndGhcbiAgdmFyIG91dCA9IG5ldyBCdWZmZXIobGVuKVxuICB2YXIgaSA9IC0xXG4gIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICBvdXRbaV0gPSBlbmNyeXB0Qnl0ZShzZWxmLCBjaHVua1tpXSwgZGVjcnlwdClcbiAgfVxuICByZXR1cm4gb3V0XG59XG5mdW5jdGlvbiBzaGlmdEluIChidWZmZXIsIHZhbHVlKSB7XG4gIHZhciBsZW4gPSBidWZmZXIubGVuZ3RoXG4gIHZhciBpID0gLTFcbiAgdmFyIG91dCA9IG5ldyBCdWZmZXIoYnVmZmVyLmxlbmd0aClcbiAgYnVmZmVyID0gQnVmZmVyLmNvbmNhdChbYnVmZmVyLCBuZXcgQnVmZmVyKFt2YWx1ZV0pXSlcbiAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgIG91dFtpXSA9IGJ1ZmZlcltpXSA8PCAxIHwgYnVmZmVyW2kgKyAxXSA+PiAoNylcbiAgfVxuICByZXR1cm4gb3V0XG59XG4iLCJmdW5jdGlvbiBlbmNyeXB0Qnl0ZSAoc2VsZiwgYnl0ZVBhcmFtLCBkZWNyeXB0KSB7XG4gIHZhciBwYWQgPSBzZWxmLl9jaXBoZXIuZW5jcnlwdEJsb2NrKHNlbGYuX3ByZXYpXG4gIHZhciBvdXQgPSBwYWRbMF0gXiBieXRlUGFyYW1cbiAgc2VsZi5fcHJldiA9IEJ1ZmZlci5jb25jYXQoW3NlbGYuX3ByZXYuc2xpY2UoMSksIG5ldyBCdWZmZXIoW2RlY3J5cHQgPyBieXRlUGFyYW0gOiBvdXRdKV0pXG4gIHJldHVybiBvdXRcbn1cbmV4cG9ydHMuZW5jcnlwdCA9IGZ1bmN0aW9uIChzZWxmLCBjaHVuaywgZGVjcnlwdCkge1xuICB2YXIgbGVuID0gY2h1bmsubGVuZ3RoXG4gIHZhciBvdXQgPSBuZXcgQnVmZmVyKGxlbilcbiAgdmFyIGkgPSAtMVxuICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgb3V0W2ldID0gZW5jcnlwdEJ5dGUoc2VsZiwgY2h1bmtbaV0sIGRlY3J5cHQpXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuIiwidmFyIHhvciA9IHJlcXVpcmUoJ2J1ZmZlci14b3InKVxuXG5mdW5jdGlvbiBpbmNyMzIgKGl2KSB7XG4gIHZhciBsZW4gPSBpdi5sZW5ndGhcbiAgdmFyIGl0ZW1cbiAgd2hpbGUgKGxlbi0tKSB7XG4gICAgaXRlbSA9IGl2LnJlYWRVSW50OChsZW4pXG4gICAgaWYgKGl0ZW0gPT09IDI1NSkge1xuICAgICAgaXYud3JpdGVVSW50OCgwLCBsZW4pXG4gICAgfSBlbHNlIHtcbiAgICAgIGl0ZW0rK1xuICAgICAgaXYud3JpdGVVSW50OChpdGVtLCBsZW4pXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRCbG9jayAoc2VsZikge1xuICB2YXIgb3V0ID0gc2VsZi5fY2lwaGVyLmVuY3J5cHRCbG9jayhzZWxmLl9wcmV2KVxuICBpbmNyMzIoc2VsZi5fcHJldilcbiAgcmV0dXJuIG91dFxufVxuXG5leHBvcnRzLmVuY3J5cHQgPSBmdW5jdGlvbiAoc2VsZiwgY2h1bmspIHtcbiAgd2hpbGUgKHNlbGYuX2NhY2hlLmxlbmd0aCA8IGNodW5rLmxlbmd0aCkge1xuICAgIHNlbGYuX2NhY2hlID0gQnVmZmVyLmNvbmNhdChbc2VsZi5fY2FjaGUsIGdldEJsb2NrKHNlbGYpXSlcbiAgfVxuICB2YXIgcGFkID0gc2VsZi5fY2FjaGUuc2xpY2UoMCwgY2h1bmsubGVuZ3RoKVxuICBzZWxmLl9jYWNoZSA9IHNlbGYuX2NhY2hlLnNsaWNlKGNodW5rLmxlbmd0aClcbiAgcmV0dXJuIHhvcihjaHVuaywgcGFkKVxufVxuIiwiZXhwb3J0cy5lbmNyeXB0ID0gZnVuY3Rpb24gKHNlbGYsIGJsb2NrKSB7XG4gIHJldHVybiBzZWxmLl9jaXBoZXIuZW5jcnlwdEJsb2NrKGJsb2NrKVxufVxuZXhwb3J0cy5kZWNyeXB0ID0gZnVuY3Rpb24gKHNlbGYsIGJsb2NrKSB7XG4gIHJldHVybiBzZWxmLl9jaXBoZXIuZGVjcnlwdEJsb2NrKGJsb2NrKVxufVxuIiwidmFyIHhvciA9IHJlcXVpcmUoJ2J1ZmZlci14b3InKVxuXG5mdW5jdGlvbiBnZXRCbG9jayAoc2VsZikge1xuICBzZWxmLl9wcmV2ID0gc2VsZi5fY2lwaGVyLmVuY3J5cHRCbG9jayhzZWxmLl9wcmV2KVxuICByZXR1cm4gc2VsZi5fcHJldlxufVxuXG5leHBvcnRzLmVuY3J5cHQgPSBmdW5jdGlvbiAoc2VsZiwgY2h1bmspIHtcbiAgd2hpbGUgKHNlbGYuX2NhY2hlLmxlbmd0aCA8IGNodW5rLmxlbmd0aCkge1xuICAgIHNlbGYuX2NhY2hlID0gQnVmZmVyLmNvbmNhdChbc2VsZi5fY2FjaGUsIGdldEJsb2NrKHNlbGYpXSlcbiAgfVxuXG4gIHZhciBwYWQgPSBzZWxmLl9jYWNoZS5zbGljZSgwLCBjaHVuay5sZW5ndGgpXG4gIHNlbGYuX2NhY2hlID0gc2VsZi5fY2FjaGUuc2xpY2UoY2h1bmsubGVuZ3RoKVxuICByZXR1cm4geG9yKGNodW5rLCBwYWQpXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHhvciAoYSwgYikge1xuICB2YXIgbGVuZ3RoID0gTWF0aC5taW4oYS5sZW5ndGgsIGIubGVuZ3RoKVxuICB2YXIgYnVmZmVyID0gbmV3IEJ1ZmZlcihsZW5ndGgpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGJ1ZmZlcltpXSA9IGFbaV0gXiBiW2ldXG4gIH1cblxuICByZXR1cm4gYnVmZmVyXG59XG4iLCJ2YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnc3RyZWFtJykuVHJhbnNmb3JtXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyJykuU3RyaW5nRGVjb2RlclxubW9kdWxlLmV4cG9ydHMgPSBDaXBoZXJCYXNlXG5pbmhlcml0cyhDaXBoZXJCYXNlLCBUcmFuc2Zvcm0pXG5mdW5jdGlvbiBDaXBoZXJCYXNlIChoYXNoTW9kZSkge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzKVxuICB0aGlzLmhhc2hNb2RlID0gdHlwZW9mIGhhc2hNb2RlID09PSAnc3RyaW5nJ1xuICBpZiAodGhpcy5oYXNoTW9kZSkge1xuICAgIHRoaXNbaGFzaE1vZGVdID0gdGhpcy5fZmluYWxPckRpZ2VzdFxuICB9IGVsc2Uge1xuICAgIHRoaXMuZmluYWwgPSB0aGlzLl9maW5hbE9yRGlnZXN0XG4gIH1cbiAgdGhpcy5fZGVjb2RlciA9IG51bGxcbiAgdGhpcy5fZW5jb2RpbmcgPSBudWxsXG59XG5DaXBoZXJCYXNlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGF0YSwgaW5wdXRFbmMsIG91dHB1dEVuYykge1xuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgZGF0YSA9IG5ldyBCdWZmZXIoZGF0YSwgaW5wdXRFbmMpXG4gIH1cbiAgdmFyIG91dERhdGEgPSB0aGlzLl91cGRhdGUoZGF0YSlcbiAgaWYgKHRoaXMuaGFzaE1vZGUpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG4gIGlmIChvdXRwdXRFbmMpIHtcbiAgICBvdXREYXRhID0gdGhpcy5fdG9TdHJpbmcob3V0RGF0YSwgb3V0cHV0RW5jKVxuICB9XG4gIHJldHVybiBvdXREYXRhXG59XG5cbkNpcGhlckJhc2UucHJvdG90eXBlLnNldEF1dG9QYWRkaW5nID0gZnVuY3Rpb24gKCkge31cblxuQ2lwaGVyQmFzZS5wcm90b3R5cGUuZ2V0QXV0aFRhZyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCd0cnlpbmcgdG8gZ2V0IGF1dGggdGFnIGluIHVuc3VwcG9ydGVkIHN0YXRlJylcbn1cblxuQ2lwaGVyQmFzZS5wcm90b3R5cGUuc2V0QXV0aFRhZyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCd0cnlpbmcgdG8gc2V0IGF1dGggdGFnIGluIHVuc3VwcG9ydGVkIHN0YXRlJylcbn1cblxuQ2lwaGVyQmFzZS5wcm90b3R5cGUuc2V0QUFEID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ3RyeWluZyB0byBzZXQgYWFkIGluIHVuc3VwcG9ydGVkIHN0YXRlJylcbn1cblxuQ2lwaGVyQmFzZS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChkYXRhLCBfLCBuZXh0KSB7XG4gIHZhciBlcnJcbiAgdHJ5IHtcbiAgICBpZiAodGhpcy5oYXNoTW9kZSkge1xuICAgICAgdGhpcy5fdXBkYXRlKGRhdGEpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucHVzaCh0aGlzLl91cGRhdGUoZGF0YSkpXG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgZXJyID0gZVxuICB9IGZpbmFsbHkge1xuICAgIG5leHQoZXJyKVxuICB9XG59XG5DaXBoZXJCYXNlLnByb3RvdHlwZS5fZmx1c2ggPSBmdW5jdGlvbiAoZG9uZSkge1xuICB2YXIgZXJyXG4gIHRyeSB7XG4gICAgdGhpcy5wdXNoKHRoaXMuX2ZpbmFsKCkpXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBlcnIgPSBlXG4gIH0gZmluYWxseSB7XG4gICAgZG9uZShlcnIpXG4gIH1cbn1cbkNpcGhlckJhc2UucHJvdG90eXBlLl9maW5hbE9yRGlnZXN0ID0gZnVuY3Rpb24gKG91dHB1dEVuYykge1xuICB2YXIgb3V0RGF0YSA9IHRoaXMuX2ZpbmFsKCkgfHwgbmV3IEJ1ZmZlcignJylcbiAgaWYgKG91dHB1dEVuYykge1xuICAgIG91dERhdGEgPSB0aGlzLl90b1N0cmluZyhvdXREYXRhLCBvdXRwdXRFbmMsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG91dERhdGFcbn1cblxuQ2lwaGVyQmFzZS5wcm90b3R5cGUuX3RvU3RyaW5nID0gZnVuY3Rpb24gKHZhbHVlLCBlbmMsIGZpbmFsKSB7XG4gIGlmICghdGhpcy5fZGVjb2Rlcikge1xuICAgIHRoaXMuX2RlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihlbmMpXG4gICAgdGhpcy5fZW5jb2RpbmcgPSBlbmNcbiAgfVxuICBpZiAodGhpcy5fZW5jb2RpbmcgIT09IGVuYykge1xuICAgIHRocm93IG5ldyBFcnJvcignY2FuXFwndCBzd2l0Y2ggZW5jb2RpbmdzJylcbiAgfVxuICB2YXIgb3V0ID0gdGhpcy5fZGVjb2Rlci53cml0ZSh2YWx1ZSlcbiAgaWYgKGZpbmFsKSB7XG4gICAgb3V0ICs9IHRoaXMuX2RlY29kZXIuZW5kKClcbiAgfVxuICByZXR1cm4gb3V0XG59XG4iLCJ2YXIgYWVzID0gcmVxdWlyZSgnLi9hZXMnKVxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJ2NpcGhlci1iYXNlJylcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcblxuaW5oZXJpdHMoU3RyZWFtQ2lwaGVyLCBUcmFuc2Zvcm0pXG5tb2R1bGUuZXhwb3J0cyA9IFN0cmVhbUNpcGhlclxuZnVuY3Rpb24gU3RyZWFtQ2lwaGVyIChtb2RlLCBrZXksIGl2LCBkZWNyeXB0KSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTdHJlYW1DaXBoZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBTdHJlYW1DaXBoZXIobW9kZSwga2V5LCBpdilcbiAgfVxuICBUcmFuc2Zvcm0uY2FsbCh0aGlzKVxuICB0aGlzLl9jaXBoZXIgPSBuZXcgYWVzLkFFUyhrZXkpXG4gIHRoaXMuX3ByZXYgPSBuZXcgQnVmZmVyKGl2Lmxlbmd0aClcbiAgdGhpcy5fY2FjaGUgPSBuZXcgQnVmZmVyKCcnKVxuICB0aGlzLl9zZWNDYWNoZSA9IG5ldyBCdWZmZXIoJycpXG4gIHRoaXMuX2RlY3J5cHQgPSBkZWNyeXB0XG4gIGl2LmNvcHkodGhpcy5fcHJldilcbiAgdGhpcy5fbW9kZSA9IG1vZGVcbn1cblN0cmVhbUNpcGhlci5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChjaHVuaykge1xuICByZXR1cm4gdGhpcy5fbW9kZS5lbmNyeXB0KHRoaXMsIGNodW5rLCB0aGlzLl9kZWNyeXB0KVxufVxuU3RyZWFtQ2lwaGVyLnByb3RvdHlwZS5fZmluYWwgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX2NpcGhlci5zY3J1YigpXG59XG4iLCJ2YXIgQ2lwaGVyQmFzZSA9IHJlcXVpcmUoJ2NpcGhlci1iYXNlJylcbnZhciBkZXMgPSByZXF1aXJlKCdkZXMuanMnKVxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuXG52YXIgbW9kZXMgPSB7XG4gICdkZXMtZWRlMy1jYmMnOiBkZXMuQ0JDLmluc3RhbnRpYXRlKGRlcy5FREUpLFxuICAnZGVzLWVkZTMnOiBkZXMuRURFLFxuICAnZGVzLWVkZS1jYmMnOiBkZXMuQ0JDLmluc3RhbnRpYXRlKGRlcy5FREUpLFxuICAnZGVzLWVkZSc6IGRlcy5FREUsXG4gICdkZXMtY2JjJzogZGVzLkNCQy5pbnN0YW50aWF0ZShkZXMuREVTKSxcbiAgJ2Rlcy1lY2InOiBkZXMuREVTXG59XG5tb2Rlcy5kZXMgPSBtb2Rlc1snZGVzLWNiYyddXG5tb2Rlcy5kZXMzID0gbW9kZXNbJ2Rlcy1lZGUzLWNiYyddXG5tb2R1bGUuZXhwb3J0cyA9IERFU1xuaW5oZXJpdHMoREVTLCBDaXBoZXJCYXNlKVxuZnVuY3Rpb24gREVTIChvcHRzKSB7XG4gIENpcGhlckJhc2UuY2FsbCh0aGlzKVxuICB2YXIgbW9kZU5hbWUgPSBvcHRzLm1vZGUudG9Mb3dlckNhc2UoKVxuICB2YXIgbW9kZSA9IG1vZGVzW21vZGVOYW1lXVxuICB2YXIgdHlwZVxuICBpZiAob3B0cy5kZWNyeXB0KSB7XG4gICAgdHlwZSA9ICdkZWNyeXB0J1xuICB9IGVsc2Uge1xuICAgIHR5cGUgPSAnZW5jcnlwdCdcbiAgfVxuICB2YXIga2V5ID0gb3B0cy5rZXlcbiAgaWYgKG1vZGVOYW1lID09PSAnZGVzLWVkZScgfHwgbW9kZU5hbWUgPT09ICdkZXMtZWRlLWNiYycpIHtcbiAgICBrZXkgPSBCdWZmZXIuY29uY2F0KFtrZXksIGtleS5zbGljZSgwLCA4KV0pXG4gIH1cbiAgdmFyIGl2ID0gb3B0cy5pdlxuICB0aGlzLl9kZXMgPSBtb2RlLmNyZWF0ZSh7XG4gICAga2V5OiBrZXksXG4gICAgaXY6IGl2LFxuICAgIHR5cGU6IHR5cGVcbiAgfSlcbn1cbkRFUy5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHJldHVybiBuZXcgQnVmZmVyKHRoaXMuX2Rlcy51cGRhdGUoZGF0YSkpXG59XG5ERVMucHJvdG90eXBlLl9maW5hbCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5ldyBCdWZmZXIodGhpcy5fZGVzLmZpbmFsKCkpXG59XG4iLCJleHBvcnRzWydkZXMtZWNiJ10gPSB7XG4gIGtleTogOCxcbiAgaXY6IDBcbn1cbmV4cG9ydHNbJ2Rlcy1jYmMnXSA9IGV4cG9ydHMuZGVzID0ge1xuICBrZXk6IDgsXG4gIGl2OiA4XG59XG5leHBvcnRzWydkZXMtZWRlMy1jYmMnXSA9IGV4cG9ydHMuZGVzMyA9IHtcbiAga2V5OiAyNCxcbiAgaXY6IDhcbn1cbmV4cG9ydHNbJ2Rlcy1lZGUzJ10gPSB7XG4gIGtleTogMjQsXG4gIGl2OiAwXG59XG5leHBvcnRzWydkZXMtZWRlLWNiYyddID0ge1xuICBrZXk6IDE2LFxuICBpdjogOFxufVxuZXhwb3J0c1snZGVzLWVkZSddID0ge1xuICBrZXk6IDE2LFxuICBpdjogMFxufVxuIiwidmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJ3N0cmVhbScpLlRyYW5zZm9ybVxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2RlcicpLlN0cmluZ0RlY29kZXJcbm1vZHVsZS5leHBvcnRzID0gQ2lwaGVyQmFzZVxuaW5oZXJpdHMoQ2lwaGVyQmFzZSwgVHJhbnNmb3JtKVxuZnVuY3Rpb24gQ2lwaGVyQmFzZSAoaGFzaE1vZGUpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcylcbiAgdGhpcy5oYXNoTW9kZSA9IHR5cGVvZiBoYXNoTW9kZSA9PT0gJ3N0cmluZydcbiAgaWYgKHRoaXMuaGFzaE1vZGUpIHtcbiAgICB0aGlzW2hhc2hNb2RlXSA9IHRoaXMuX2ZpbmFsT3JEaWdlc3RcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmZpbmFsID0gdGhpcy5fZmluYWxPckRpZ2VzdFxuICB9XG4gIHRoaXMuX2RlY29kZXIgPSBudWxsXG4gIHRoaXMuX2VuY29kaW5nID0gbnVsbFxufVxuQ2lwaGVyQmFzZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRhdGEsIGlucHV0RW5jLCBvdXRwdXRFbmMpIHtcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgIGRhdGEgPSBuZXcgQnVmZmVyKGRhdGEsIGlucHV0RW5jKVxuICB9XG4gIHZhciBvdXREYXRhID0gdGhpcy5fdXBkYXRlKGRhdGEpXG4gIGlmICh0aGlzLmhhc2hNb2RlKSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuICBpZiAob3V0cHV0RW5jKSB7XG4gICAgb3V0RGF0YSA9IHRoaXMuX3RvU3RyaW5nKG91dERhdGEsIG91dHB1dEVuYylcbiAgfVxuICByZXR1cm4gb3V0RGF0YVxufVxuXG5DaXBoZXJCYXNlLnByb3RvdHlwZS5zZXRBdXRvUGFkZGluZyA9IGZ1bmN0aW9uICgpIHt9XG5cbkNpcGhlckJhc2UucHJvdG90eXBlLmdldEF1dGhUYWcgPSBmdW5jdGlvbiAoKSB7XG4gIHRocm93IG5ldyBFcnJvcigndHJ5aW5nIHRvIGdldCBhdXRoIHRhZyBpbiB1bnN1cHBvcnRlZCBzdGF0ZScpXG59XG5cbkNpcGhlckJhc2UucHJvdG90eXBlLnNldEF1dGhUYWcgPSBmdW5jdGlvbiAoKSB7XG4gIHRocm93IG5ldyBFcnJvcigndHJ5aW5nIHRvIHNldCBhdXRoIHRhZyBpbiB1bnN1cHBvcnRlZCBzdGF0ZScpXG59XG5cbkNpcGhlckJhc2UucHJvdG90eXBlLnNldEFBRCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCd0cnlpbmcgdG8gc2V0IGFhZCBpbiB1bnN1cHBvcnRlZCBzdGF0ZScpXG59XG5cbkNpcGhlckJhc2UucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoZGF0YSwgXywgbmV4dCkge1xuICB2YXIgZXJyXG4gIHRyeSB7XG4gICAgaWYgKHRoaXMuaGFzaE1vZGUpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZShkYXRhKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnB1c2godGhpcy5fdXBkYXRlKGRhdGEpKVxuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIGVyciA9IGVcbiAgfSBmaW5hbGx5IHtcbiAgICBuZXh0KGVycilcbiAgfVxufVxuQ2lwaGVyQmFzZS5wcm90b3R5cGUuX2ZsdXNoID0gZnVuY3Rpb24gKGRvbmUpIHtcbiAgdmFyIGVyclxuICB0cnkge1xuICAgIHRoaXMucHVzaCh0aGlzLl9maW5hbCgpKVxuICB9IGNhdGNoIChlKSB7XG4gICAgZXJyID0gZVxuICB9IGZpbmFsbHkge1xuICAgIGRvbmUoZXJyKVxuICB9XG59XG5DaXBoZXJCYXNlLnByb3RvdHlwZS5fZmluYWxPckRpZ2VzdCA9IGZ1bmN0aW9uIChvdXRwdXRFbmMpIHtcbiAgdmFyIG91dERhdGEgPSB0aGlzLl9maW5hbCgpIHx8IG5ldyBCdWZmZXIoJycpXG4gIGlmIChvdXRwdXRFbmMpIHtcbiAgICBvdXREYXRhID0gdGhpcy5fdG9TdHJpbmcob3V0RGF0YSwgb3V0cHV0RW5jLCB0cnVlKVxuICB9XG4gIHJldHVybiBvdXREYXRhXG59XG5cbkNpcGhlckJhc2UucHJvdG90eXBlLl90b1N0cmluZyA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jLCBmaW5hbCkge1xuICBpZiAoIXRoaXMuX2RlY29kZXIpIHtcbiAgICB0aGlzLl9kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoZW5jKVxuICAgIHRoaXMuX2VuY29kaW5nID0gZW5jXG4gIH1cbiAgaWYgKHRoaXMuX2VuY29kaW5nICE9PSBlbmMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NhblxcJ3Qgc3dpdGNoIGVuY29kaW5ncycpXG4gIH1cbiAgdmFyIG91dCA9IHRoaXMuX2RlY29kZXIud3JpdGUodmFsdWUpXG4gIGlmIChmaW5hbCkge1xuICAgIG91dCArPSB0aGlzLl9kZWNvZGVyLmVuZCgpXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLnV0aWxzID0gcmVxdWlyZSgnLi9kZXMvdXRpbHMnKTtcbmV4cG9ydHMuQ2lwaGVyID0gcmVxdWlyZSgnLi9kZXMvY2lwaGVyJyk7XG5leHBvcnRzLkRFUyA9IHJlcXVpcmUoJy4vZGVzL2RlcycpO1xuZXhwb3J0cy5DQkMgPSByZXF1aXJlKCcuL2Rlcy9jYmMnKTtcbmV4cG9ydHMuRURFID0gcmVxdWlyZSgnLi9kZXMvZWRlJyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKCdtaW5pbWFsaXN0aWMtYXNzZXJ0Jyk7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG52YXIgcHJvdG8gPSB7fTtcblxuZnVuY3Rpb24gQ0JDU3RhdGUoaXYpIHtcbiAgYXNzZXJ0LmVxdWFsKGl2Lmxlbmd0aCwgOCwgJ0ludmFsaWQgSVYgbGVuZ3RoJyk7XG5cbiAgdGhpcy5pdiA9IG5ldyBBcnJheSg4KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLml2Lmxlbmd0aDsgaSsrKVxuICAgIHRoaXMuaXZbaV0gPSBpdltpXTtcbn1cblxuZnVuY3Rpb24gaW5zdGFudGlhdGUoQmFzZSkge1xuICBmdW5jdGlvbiBDQkMob3B0aW9ucykge1xuICAgIEJhc2UuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICB0aGlzLl9jYmNJbml0KCk7XG4gIH1cbiAgaW5oZXJpdHMoQ0JDLCBCYXNlKTtcblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3RvKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgQ0JDLnByb3RvdHlwZVtrZXldID0gcHJvdG9ba2V5XTtcbiAgfVxuXG4gIENCQy5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUob3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgQ0JDKG9wdGlvbnMpO1xuICB9O1xuXG4gIHJldHVybiBDQkM7XG59XG5cbmV4cG9ydHMuaW5zdGFudGlhdGUgPSBpbnN0YW50aWF0ZTtcblxucHJvdG8uX2NiY0luaXQgPSBmdW5jdGlvbiBfY2JjSW5pdCgpIHtcbiAgdmFyIHN0YXRlID0gbmV3IENCQ1N0YXRlKHRoaXMub3B0aW9ucy5pdik7XG4gIHRoaXMuX2NiY1N0YXRlID0gc3RhdGU7XG59O1xuXG5wcm90by5fdXBkYXRlID0gZnVuY3Rpb24gX3VwZGF0ZShpbnAsIGluT2ZmLCBvdXQsIG91dE9mZikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9jYmNTdGF0ZTtcbiAgdmFyIHN1cGVyUHJvdG8gPSB0aGlzLmNvbnN0cnVjdG9yLnN1cGVyXy5wcm90b3R5cGU7XG5cbiAgdmFyIGl2ID0gc3RhdGUuaXY7XG4gIGlmICh0aGlzLnR5cGUgPT09ICdlbmNyeXB0Jykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ibG9ja1NpemU7IGkrKylcbiAgICAgIGl2W2ldIF49IGlucFtpbk9mZiArIGldO1xuXG4gICAgc3VwZXJQcm90by5fdXBkYXRlLmNhbGwodGhpcywgaXYsIDAsIG91dCwgb3V0T2ZmKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ibG9ja1NpemU7IGkrKylcbiAgICAgIGl2W2ldID0gb3V0W291dE9mZiArIGldO1xuICB9IGVsc2Uge1xuICAgIHN1cGVyUHJvdG8uX3VwZGF0ZS5jYWxsKHRoaXMsIGlucCwgaW5PZmYsIG91dCwgb3V0T2ZmKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ibG9ja1NpemU7IGkrKylcbiAgICAgIG91dFtvdXRPZmYgKyBpXSBePSBpdltpXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ibG9ja1NpemU7IGkrKylcbiAgICAgIGl2W2ldID0gaW5wW2luT2ZmICsgaV07XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKCdtaW5pbWFsaXN0aWMtYXNzZXJ0Jyk7XG5cbmZ1bmN0aW9uIENpcGhlcihvcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cbiAgdGhpcy50eXBlID0gdGhpcy5vcHRpb25zLnR5cGU7XG4gIHRoaXMuYmxvY2tTaXplID0gODtcbiAgdGhpcy5faW5pdCgpO1xuXG4gIHRoaXMuYnVmZmVyID0gbmV3IEFycmF5KHRoaXMuYmxvY2tTaXplKTtcbiAgdGhpcy5idWZmZXJPZmYgPSAwO1xufVxubW9kdWxlLmV4cG9ydHMgPSBDaXBoZXI7XG5cbkNpcGhlci5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiBfaW5pdCgpIHtcbiAgLy8gTWlnaHQgYmUgb3ZlcnJpZGVkXG59O1xuXG5DaXBoZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShkYXRhKSB7XG4gIGlmIChkYXRhLmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm4gW107XG5cbiAgaWYgKHRoaXMudHlwZSA9PT0gJ2RlY3J5cHQnKVxuICAgIHJldHVybiB0aGlzLl91cGRhdGVEZWNyeXB0KGRhdGEpO1xuICBlbHNlXG4gICAgcmV0dXJuIHRoaXMuX3VwZGF0ZUVuY3J5cHQoZGF0YSk7XG59O1xuXG5DaXBoZXIucHJvdG90eXBlLl9idWZmZXIgPSBmdW5jdGlvbiBfYnVmZmVyKGRhdGEsIG9mZikge1xuICAvLyBBcHBlbmQgZGF0YSB0byBidWZmZXJcbiAgdmFyIG1pbiA9IE1hdGgubWluKHRoaXMuYnVmZmVyLmxlbmd0aCAtIHRoaXMuYnVmZmVyT2ZmLCBkYXRhLmxlbmd0aCAtIG9mZik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbWluOyBpKyspXG4gICAgdGhpcy5idWZmZXJbdGhpcy5idWZmZXJPZmYgKyBpXSA9IGRhdGFbb2ZmICsgaV07XG4gIHRoaXMuYnVmZmVyT2ZmICs9IG1pbjtcblxuICAvLyBTaGlmdCBuZXh0XG4gIHJldHVybiBtaW47XG59O1xuXG5DaXBoZXIucHJvdG90eXBlLl9mbHVzaEJ1ZmZlciA9IGZ1bmN0aW9uIF9mbHVzaEJ1ZmZlcihvdXQsIG9mZikge1xuICB0aGlzLl91cGRhdGUodGhpcy5idWZmZXIsIDAsIG91dCwgb2ZmKTtcbiAgdGhpcy5idWZmZXJPZmYgPSAwO1xuICByZXR1cm4gdGhpcy5ibG9ja1NpemU7XG59O1xuXG5DaXBoZXIucHJvdG90eXBlLl91cGRhdGVFbmNyeXB0ID0gZnVuY3Rpb24gX3VwZGF0ZUVuY3J5cHQoZGF0YSkge1xuICB2YXIgaW5wdXRPZmYgPSAwO1xuICB2YXIgb3V0cHV0T2ZmID0gMDtcblxuICB2YXIgY291bnQgPSAoKHRoaXMuYnVmZmVyT2ZmICsgZGF0YS5sZW5ndGgpIC8gdGhpcy5ibG9ja1NpemUpIHwgMDtcbiAgdmFyIG91dCA9IG5ldyBBcnJheShjb3VudCAqIHRoaXMuYmxvY2tTaXplKTtcblxuICBpZiAodGhpcy5idWZmZXJPZmYgIT09IDApIHtcbiAgICBpbnB1dE9mZiArPSB0aGlzLl9idWZmZXIoZGF0YSwgaW5wdXRPZmYpO1xuXG4gICAgaWYgKHRoaXMuYnVmZmVyT2ZmID09PSB0aGlzLmJ1ZmZlci5sZW5ndGgpXG4gICAgICBvdXRwdXRPZmYgKz0gdGhpcy5fZmx1c2hCdWZmZXIob3V0LCBvdXRwdXRPZmYpO1xuICB9XG5cbiAgLy8gV3JpdGUgYmxvY2tzXG4gIHZhciBtYXggPSBkYXRhLmxlbmd0aCAtICgoZGF0YS5sZW5ndGggLSBpbnB1dE9mZikgJSB0aGlzLmJsb2NrU2l6ZSk7XG4gIGZvciAoOyBpbnB1dE9mZiA8IG1heDsgaW5wdXRPZmYgKz0gdGhpcy5ibG9ja1NpemUpIHtcbiAgICB0aGlzLl91cGRhdGUoZGF0YSwgaW5wdXRPZmYsIG91dCwgb3V0cHV0T2ZmKTtcbiAgICBvdXRwdXRPZmYgKz0gdGhpcy5ibG9ja1NpemU7XG4gIH1cblxuICAvLyBRdWV1ZSByZXN0XG4gIGZvciAoOyBpbnB1dE9mZiA8IGRhdGEubGVuZ3RoOyBpbnB1dE9mZisrLCB0aGlzLmJ1ZmZlck9mZisrKVxuICAgIHRoaXMuYnVmZmVyW3RoaXMuYnVmZmVyT2ZmXSA9IGRhdGFbaW5wdXRPZmZdO1xuXG4gIHJldHVybiBvdXQ7XG59O1xuXG5DaXBoZXIucHJvdG90eXBlLl91cGRhdGVEZWNyeXB0ID0gZnVuY3Rpb24gX3VwZGF0ZURlY3J5cHQoZGF0YSkge1xuICB2YXIgaW5wdXRPZmYgPSAwO1xuICB2YXIgb3V0cHV0T2ZmID0gMDtcblxuICB2YXIgY291bnQgPSBNYXRoLmNlaWwoKHRoaXMuYnVmZmVyT2ZmICsgZGF0YS5sZW5ndGgpIC8gdGhpcy5ibG9ja1NpemUpIC0gMTtcbiAgdmFyIG91dCA9IG5ldyBBcnJheShjb3VudCAqIHRoaXMuYmxvY2tTaXplKTtcblxuICAvLyBUT0RPKGluZHV0bnkpOiBvcHRpbWl6ZSBpdCwgdGhpcyBpcyBmYXIgZnJvbSBvcHRpbWFsXG4gIGZvciAoOyBjb3VudCA+IDA7IGNvdW50LS0pIHtcbiAgICBpbnB1dE9mZiArPSB0aGlzLl9idWZmZXIoZGF0YSwgaW5wdXRPZmYpO1xuICAgIG91dHB1dE9mZiArPSB0aGlzLl9mbHVzaEJ1ZmZlcihvdXQsIG91dHB1dE9mZik7XG4gIH1cblxuICAvLyBCdWZmZXIgcmVzdCBvZiB0aGUgaW5wdXRcbiAgaW5wdXRPZmYgKz0gdGhpcy5fYnVmZmVyKGRhdGEsIGlucHV0T2ZmKTtcblxuICByZXR1cm4gb3V0O1xufTtcblxuQ2lwaGVyLnByb3RvdHlwZS5maW5hbCA9IGZ1bmN0aW9uIGZpbmFsKGJ1ZmZlcikge1xuICB2YXIgZmlyc3Q7XG4gIGlmIChidWZmZXIpXG4gICAgZmlyc3QgPSB0aGlzLnVwZGF0ZShidWZmZXIpO1xuXG4gIHZhciBsYXN0O1xuICBpZiAodGhpcy50eXBlID09PSAnZW5jcnlwdCcpXG4gICAgbGFzdCA9IHRoaXMuX2ZpbmFsRW5jcnlwdCgpO1xuICBlbHNlXG4gICAgbGFzdCA9IHRoaXMuX2ZpbmFsRGVjcnlwdCgpO1xuXG4gIGlmIChmaXJzdClcbiAgICByZXR1cm4gZmlyc3QuY29uY2F0KGxhc3QpO1xuICBlbHNlXG4gICAgcmV0dXJuIGxhc3Q7XG59O1xuXG5DaXBoZXIucHJvdG90eXBlLl9wYWQgPSBmdW5jdGlvbiBfcGFkKGJ1ZmZlciwgb2ZmKSB7XG4gIGlmIChvZmYgPT09IDApXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIHdoaWxlIChvZmYgPCBidWZmZXIubGVuZ3RoKVxuICAgIGJ1ZmZlcltvZmYrK10gPSAwO1xuXG4gIHJldHVybiB0cnVlO1xufTtcblxuQ2lwaGVyLnByb3RvdHlwZS5fZmluYWxFbmNyeXB0ID0gZnVuY3Rpb24gX2ZpbmFsRW5jcnlwdCgpIHtcbiAgaWYgKCF0aGlzLl9wYWQodGhpcy5idWZmZXIsIHRoaXMuYnVmZmVyT2ZmKSlcbiAgICByZXR1cm4gW107XG5cbiAgdmFyIG91dCA9IG5ldyBBcnJheSh0aGlzLmJsb2NrU2l6ZSk7XG4gIHRoaXMuX3VwZGF0ZSh0aGlzLmJ1ZmZlciwgMCwgb3V0LCAwKTtcbiAgcmV0dXJuIG91dDtcbn07XG5cbkNpcGhlci5wcm90b3R5cGUuX3VucGFkID0gZnVuY3Rpb24gX3VucGFkKGJ1ZmZlcikge1xuICByZXR1cm4gYnVmZmVyO1xufTtcblxuQ2lwaGVyLnByb3RvdHlwZS5fZmluYWxEZWNyeXB0ID0gZnVuY3Rpb24gX2ZpbmFsRGVjcnlwdCgpIHtcbiAgYXNzZXJ0LmVxdWFsKHRoaXMuYnVmZmVyT2ZmLCB0aGlzLmJsb2NrU2l6ZSwgJ05vdCBlbm91Z2ggZGF0YSB0byBkZWNyeXB0Jyk7XG4gIHZhciBvdXQgPSBuZXcgQXJyYXkodGhpcy5ibG9ja1NpemUpO1xuICB0aGlzLl9mbHVzaEJ1ZmZlcihvdXQsIDApO1xuXG4gIHJldHVybiB0aGlzLl91bnBhZChvdXQpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ21pbmltYWxpc3RpYy1hc3NlcnQnKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbnZhciBkZXMgPSByZXF1aXJlKCcuLi9kZXMnKTtcbnZhciB1dGlscyA9IGRlcy51dGlscztcbnZhciBDaXBoZXIgPSBkZXMuQ2lwaGVyO1xuXG5mdW5jdGlvbiBERVNTdGF0ZSgpIHtcbiAgdGhpcy50bXAgPSBuZXcgQXJyYXkoMik7XG4gIHRoaXMua2V5cyA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIERFUyhvcHRpb25zKSB7XG4gIENpcGhlci5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIHZhciBzdGF0ZSA9IG5ldyBERVNTdGF0ZSgpO1xuICB0aGlzLl9kZXNTdGF0ZSA9IHN0YXRlO1xuXG4gIHRoaXMuZGVyaXZlS2V5cyhzdGF0ZSwgb3B0aW9ucy5rZXkpO1xufVxuaW5oZXJpdHMoREVTLCBDaXBoZXIpO1xubW9kdWxlLmV4cG9ydHMgPSBERVM7XG5cbkRFUy5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUob3B0aW9ucykge1xuICByZXR1cm4gbmV3IERFUyhvcHRpb25zKTtcbn07XG5cbnZhciBzaGlmdFRhYmxlID0gW1xuICAxLCAxLCAyLCAyLCAyLCAyLCAyLCAyLFxuICAxLCAyLCAyLCAyLCAyLCAyLCAyLCAxXG5dO1xuXG5ERVMucHJvdG90eXBlLmRlcml2ZUtleXMgPSBmdW5jdGlvbiBkZXJpdmVLZXlzKHN0YXRlLCBrZXkpIHtcbiAgc3RhdGUua2V5cyA9IG5ldyBBcnJheSgxNiAqIDIpO1xuXG4gIGFzc2VydC5lcXVhbChrZXkubGVuZ3RoLCB0aGlzLmJsb2NrU2l6ZSwgJ0ludmFsaWQga2V5IGxlbmd0aCcpO1xuXG4gIHZhciBrTCA9IHV0aWxzLnJlYWRVSW50MzJCRShrZXksIDApO1xuICB2YXIga1IgPSB1dGlscy5yZWFkVUludDMyQkUoa2V5LCA0KTtcblxuICB1dGlscy5wYzEoa0wsIGtSLCBzdGF0ZS50bXAsIDApO1xuICBrTCA9IHN0YXRlLnRtcFswXTtcbiAga1IgPSBzdGF0ZS50bXBbMV07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhdGUua2V5cy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHZhciBzaGlmdCA9IHNoaWZ0VGFibGVbaSA+Pj4gMV07XG4gICAga0wgPSB1dGlscy5yMjhzaGwoa0wsIHNoaWZ0KTtcbiAgICBrUiA9IHV0aWxzLnIyOHNobChrUiwgc2hpZnQpO1xuICAgIHV0aWxzLnBjMihrTCwga1IsIHN0YXRlLmtleXMsIGkpO1xuICB9XG59O1xuXG5ERVMucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiBfdXBkYXRlKGlucCwgaW5PZmYsIG91dCwgb3V0T2ZmKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Rlc1N0YXRlO1xuXG4gIHZhciBsID0gdXRpbHMucmVhZFVJbnQzMkJFKGlucCwgaW5PZmYpO1xuICB2YXIgciA9IHV0aWxzLnJlYWRVSW50MzJCRShpbnAsIGluT2ZmICsgNCk7XG5cbiAgLy8gSW5pdGlhbCBQZXJtdXRhdGlvblxuICB1dGlscy5pcChsLCByLCBzdGF0ZS50bXAsIDApO1xuICBsID0gc3RhdGUudG1wWzBdO1xuICByID0gc3RhdGUudG1wWzFdO1xuXG4gIGlmICh0aGlzLnR5cGUgPT09ICdlbmNyeXB0JylcbiAgICB0aGlzLl9lbmNyeXB0KHN0YXRlLCBsLCByLCBzdGF0ZS50bXAsIDApO1xuICBlbHNlXG4gICAgdGhpcy5fZGVjcnlwdChzdGF0ZSwgbCwgciwgc3RhdGUudG1wLCAwKTtcblxuICBsID0gc3RhdGUudG1wWzBdO1xuICByID0gc3RhdGUudG1wWzFdO1xuXG4gIHV0aWxzLndyaXRlVUludDMyQkUob3V0LCBsLCBvdXRPZmYpO1xuICB1dGlscy53cml0ZVVJbnQzMkJFKG91dCwgciwgb3V0T2ZmICsgNCk7XG59O1xuXG5ERVMucHJvdG90eXBlLl9wYWQgPSBmdW5jdGlvbiBfcGFkKGJ1ZmZlciwgb2ZmKSB7XG4gIHZhciB2YWx1ZSA9IGJ1ZmZlci5sZW5ndGggLSBvZmY7XG4gIGZvciAodmFyIGkgPSBvZmY7IGkgPCBidWZmZXIubGVuZ3RoOyBpKyspXG4gICAgYnVmZmVyW2ldID0gdmFsdWU7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5ERVMucHJvdG90eXBlLl91bnBhZCA9IGZ1bmN0aW9uIF91bnBhZChidWZmZXIpIHtcbiAgdmFyIHBhZCA9IGJ1ZmZlcltidWZmZXIubGVuZ3RoIC0gMV07XG4gIGZvciAodmFyIGkgPSBidWZmZXIubGVuZ3RoIC0gcGFkOyBpIDwgYnVmZmVyLmxlbmd0aDsgaSsrKVxuICAgIGFzc2VydC5lcXVhbChidWZmZXJbaV0sIHBhZCk7XG5cbiAgcmV0dXJuIGJ1ZmZlci5zbGljZSgwLCBidWZmZXIubGVuZ3RoIC0gcGFkKTtcbn07XG5cbkRFUy5wcm90b3R5cGUuX2VuY3J5cHQgPSBmdW5jdGlvbiBfZW5jcnlwdChzdGF0ZSwgbFN0YXJ0LCByU3RhcnQsIG91dCwgb2ZmKSB7XG4gIHZhciBsID0gbFN0YXJ0O1xuICB2YXIgciA9IHJTdGFydDtcblxuICAvLyBBcHBseSBmKCkgeDE2IHRpbWVzXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhdGUua2V5cy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHZhciBrZXlMID0gc3RhdGUua2V5c1tpXTtcbiAgICB2YXIga2V5UiA9IHN0YXRlLmtleXNbaSArIDFdO1xuXG4gICAgLy8gZihyLCBrKVxuICAgIHV0aWxzLmV4cGFuZChyLCBzdGF0ZS50bXAsIDApO1xuXG4gICAga2V5TCBePSBzdGF0ZS50bXBbMF07XG4gICAga2V5UiBePSBzdGF0ZS50bXBbMV07XG4gICAgdmFyIHMgPSB1dGlscy5zdWJzdGl0dXRlKGtleUwsIGtleVIpO1xuICAgIHZhciBmID0gdXRpbHMucGVybXV0ZShzKTtcblxuICAgIHZhciB0ID0gcjtcbiAgICByID0gKGwgXiBmKSA+Pj4gMDtcbiAgICBsID0gdDtcbiAgfVxuXG4gIC8vIFJldmVyc2UgSW5pdGlhbCBQZXJtdXRhdGlvblxuICB1dGlscy5yaXAociwgbCwgb3V0LCBvZmYpO1xufTtcblxuREVTLnByb3RvdHlwZS5fZGVjcnlwdCA9IGZ1bmN0aW9uIF9kZWNyeXB0KHN0YXRlLCBsU3RhcnQsIHJTdGFydCwgb3V0LCBvZmYpIHtcbiAgdmFyIGwgPSByU3RhcnQ7XG4gIHZhciByID0gbFN0YXJ0O1xuXG4gIC8vIEFwcGx5IGYoKSB4MTYgdGltZXNcbiAgZm9yICh2YXIgaSA9IHN0YXRlLmtleXMubGVuZ3RoIC0gMjsgaSA+PSAwOyBpIC09IDIpIHtcbiAgICB2YXIga2V5TCA9IHN0YXRlLmtleXNbaV07XG4gICAgdmFyIGtleVIgPSBzdGF0ZS5rZXlzW2kgKyAxXTtcblxuICAgIC8vIGYociwgaylcbiAgICB1dGlscy5leHBhbmQobCwgc3RhdGUudG1wLCAwKTtcblxuICAgIGtleUwgXj0gc3RhdGUudG1wWzBdO1xuICAgIGtleVIgXj0gc3RhdGUudG1wWzFdO1xuICAgIHZhciBzID0gdXRpbHMuc3Vic3RpdHV0ZShrZXlMLCBrZXlSKTtcbiAgICB2YXIgZiA9IHV0aWxzLnBlcm11dGUocyk7XG5cbiAgICB2YXIgdCA9IGw7XG4gICAgbCA9IChyIF4gZikgPj4+IDA7XG4gICAgciA9IHQ7XG4gIH1cblxuICAvLyBSZXZlcnNlIEluaXRpYWwgUGVybXV0YXRpb25cbiAgdXRpbHMucmlwKGwsIHIsIG91dCwgb2ZmKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKCdtaW5pbWFsaXN0aWMtYXNzZXJ0Jyk7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG52YXIgZGVzID0gcmVxdWlyZSgnLi4vZGVzJyk7XG52YXIgQ2lwaGVyID0gZGVzLkNpcGhlcjtcbnZhciBERVMgPSBkZXMuREVTO1xuXG5mdW5jdGlvbiBFREVTdGF0ZSh0eXBlLCBrZXkpIHtcbiAgYXNzZXJ0LmVxdWFsKGtleS5sZW5ndGgsIDI0LCAnSW52YWxpZCBrZXkgbGVuZ3RoJyk7XG5cbiAgdmFyIGsxID0ga2V5LnNsaWNlKDAsIDgpO1xuICB2YXIgazIgPSBrZXkuc2xpY2UoOCwgMTYpO1xuICB2YXIgazMgPSBrZXkuc2xpY2UoMTYsIDI0KTtcblxuICBpZiAodHlwZSA9PT0gJ2VuY3J5cHQnKSB7XG4gICAgdGhpcy5jaXBoZXJzID0gW1xuICAgICAgREVTLmNyZWF0ZSh7IHR5cGU6ICdlbmNyeXB0Jywga2V5OiBrMSB9KSxcbiAgICAgIERFUy5jcmVhdGUoeyB0eXBlOiAnZGVjcnlwdCcsIGtleTogazIgfSksXG4gICAgICBERVMuY3JlYXRlKHsgdHlwZTogJ2VuY3J5cHQnLCBrZXk6IGszIH0pXG4gICAgXTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmNpcGhlcnMgPSBbXG4gICAgICBERVMuY3JlYXRlKHsgdHlwZTogJ2RlY3J5cHQnLCBrZXk6IGszIH0pLFxuICAgICAgREVTLmNyZWF0ZSh7IHR5cGU6ICdlbmNyeXB0Jywga2V5OiBrMiB9KSxcbiAgICAgIERFUy5jcmVhdGUoeyB0eXBlOiAnZGVjcnlwdCcsIGtleTogazEgfSlcbiAgICBdO1xuICB9XG59XG5cbmZ1bmN0aW9uIEVERShvcHRpb25zKSB7XG4gIENpcGhlci5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIHZhciBzdGF0ZSA9IG5ldyBFREVTdGF0ZSh0aGlzLnR5cGUsIHRoaXMub3B0aW9ucy5rZXkpO1xuICB0aGlzLl9lZGVTdGF0ZSA9IHN0YXRlO1xufVxuaW5oZXJpdHMoRURFLCBDaXBoZXIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEVERTtcblxuRURFLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgRURFKG9wdGlvbnMpO1xufTtcblxuRURFLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gX3VwZGF0ZShpbnAsIGluT2ZmLCBvdXQsIG91dE9mZikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9lZGVTdGF0ZTtcblxuICBzdGF0ZS5jaXBoZXJzWzBdLl91cGRhdGUoaW5wLCBpbk9mZiwgb3V0LCBvdXRPZmYpO1xuICBzdGF0ZS5jaXBoZXJzWzFdLl91cGRhdGUob3V0LCBvdXRPZmYsIG91dCwgb3V0T2ZmKTtcbiAgc3RhdGUuY2lwaGVyc1syXS5fdXBkYXRlKG91dCwgb3V0T2ZmLCBvdXQsIG91dE9mZik7XG59O1xuXG5FREUucHJvdG90eXBlLl9wYWQgPSBERVMucHJvdG90eXBlLl9wYWQ7XG5FREUucHJvdG90eXBlLl91bnBhZCA9IERFUy5wcm90b3R5cGUuX3VucGFkO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRShieXRlcywgb2ZmKSB7XG4gIHZhciByZXMgPSAgKGJ5dGVzWzAgKyBvZmZdIDw8IDI0KSB8XG4gICAgICAgICAgICAgKGJ5dGVzWzEgKyBvZmZdIDw8IDE2KSB8XG4gICAgICAgICAgICAgKGJ5dGVzWzIgKyBvZmZdIDw8IDgpIHxcbiAgICAgICAgICAgICBieXRlc1szICsgb2ZmXTtcbiAgcmV0dXJuIHJlcyA+Pj4gMDtcbn07XG5cbmV4cG9ydHMud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUoYnl0ZXMsIHZhbHVlLCBvZmYpIHtcbiAgYnl0ZXNbMCArIG9mZl0gPSB2YWx1ZSA+Pj4gMjQ7XG4gIGJ5dGVzWzEgKyBvZmZdID0gKHZhbHVlID4+PiAxNikgJiAweGZmO1xuICBieXRlc1syICsgb2ZmXSA9ICh2YWx1ZSA+Pj4gOCkgJiAweGZmO1xuICBieXRlc1szICsgb2ZmXSA9IHZhbHVlICYgMHhmZjtcbn07XG5cbmV4cG9ydHMuaXAgPSBmdW5jdGlvbiBpcChpbkwsIGluUiwgb3V0LCBvZmYpIHtcbiAgdmFyIG91dEwgPSAwO1xuICB2YXIgb3V0UiA9IDA7XG5cbiAgZm9yICh2YXIgaSA9IDY7IGkgPj0gMDsgaSAtPSAyKSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPD0gMjQ7IGogKz0gOCkge1xuICAgICAgb3V0TCA8PD0gMTtcbiAgICAgIG91dEwgfD0gKGluUiA+Pj4gKGogKyBpKSkgJiAxO1xuICAgIH1cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8PSAyNDsgaiArPSA4KSB7XG4gICAgICBvdXRMIDw8PSAxO1xuICAgICAgb3V0TCB8PSAoaW5MID4+PiAoaiArIGkpKSAmIDE7XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IDY7IGkgPj0gMDsgaSAtPSAyKSB7XG4gICAgZm9yICh2YXIgaiA9IDE7IGogPD0gMjU7IGogKz0gOCkge1xuICAgICAgb3V0UiA8PD0gMTtcbiAgICAgIG91dFIgfD0gKGluUiA+Pj4gKGogKyBpKSkgJiAxO1xuICAgIH1cbiAgICBmb3IgKHZhciBqID0gMTsgaiA8PSAyNTsgaiArPSA4KSB7XG4gICAgICBvdXRSIDw8PSAxO1xuICAgICAgb3V0UiB8PSAoaW5MID4+PiAoaiArIGkpKSAmIDE7XG4gICAgfVxuICB9XG5cbiAgb3V0W29mZiArIDBdID0gb3V0TCA+Pj4gMDtcbiAgb3V0W29mZiArIDFdID0gb3V0UiA+Pj4gMDtcbn07XG5cbmV4cG9ydHMucmlwID0gZnVuY3Rpb24gcmlwKGluTCwgaW5SLCBvdXQsIG9mZikge1xuICB2YXIgb3V0TCA9IDA7XG4gIHZhciBvdXRSID0gMDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgIGZvciAodmFyIGogPSAyNDsgaiA+PSAwOyBqIC09IDgpIHtcbiAgICAgIG91dEwgPDw9IDE7XG4gICAgICBvdXRMIHw9IChpblIgPj4+IChqICsgaSkpICYgMTtcbiAgICAgIG91dEwgPDw9IDE7XG4gICAgICBvdXRMIHw9IChpbkwgPj4+IChqICsgaSkpICYgMTtcbiAgICB9XG4gIH1cbiAgZm9yICh2YXIgaSA9IDQ7IGkgPCA4OyBpKyspIHtcbiAgICBmb3IgKHZhciBqID0gMjQ7IGogPj0gMDsgaiAtPSA4KSB7XG4gICAgICBvdXRSIDw8PSAxO1xuICAgICAgb3V0UiB8PSAoaW5SID4+PiAoaiArIGkpKSAmIDE7XG4gICAgICBvdXRSIDw8PSAxO1xuICAgICAgb3V0UiB8PSAoaW5MID4+PiAoaiArIGkpKSAmIDE7XG4gICAgfVxuICB9XG5cbiAgb3V0W29mZiArIDBdID0gb3V0TCA+Pj4gMDtcbiAgb3V0W29mZiArIDFdID0gb3V0UiA+Pj4gMDtcbn07XG5cbmV4cG9ydHMucGMxID0gZnVuY3Rpb24gcGMxKGluTCwgaW5SLCBvdXQsIG9mZikge1xuICB2YXIgb3V0TCA9IDA7XG4gIHZhciBvdXRSID0gMDtcblxuICAvLyA3LCAxNSwgMjMsIDMxLCAzOSwgNDcsIDU1LCA2M1xuICAvLyA2LCAxNCwgMjIsIDMwLCAzOSwgNDcsIDU1LCA2M1xuICAvLyA1LCAxMywgMjEsIDI5LCAzOSwgNDcsIDU1LCA2M1xuICAvLyA0LCAxMiwgMjAsIDI4XG4gIGZvciAodmFyIGkgPSA3OyBpID49IDU7IGktLSkge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDw9IDI0OyBqICs9IDgpIHtcbiAgICAgIG91dEwgPDw9IDE7XG4gICAgICBvdXRMIHw9IChpblIgPj4gKGogKyBpKSkgJiAxO1xuICAgIH1cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8PSAyNDsgaiArPSA4KSB7XG4gICAgICBvdXRMIDw8PSAxO1xuICAgICAgb3V0TCB8PSAoaW5MID4+IChqICsgaSkpICYgMTtcbiAgICB9XG4gIH1cbiAgZm9yICh2YXIgaiA9IDA7IGogPD0gMjQ7IGogKz0gOCkge1xuICAgIG91dEwgPDw9IDE7XG4gICAgb3V0TCB8PSAoaW5SID4+IChqICsgaSkpICYgMTtcbiAgfVxuXG4gIC8vIDEsIDksIDE3LCAyNSwgMzMsIDQxLCA0OSwgNTdcbiAgLy8gMiwgMTAsIDE4LCAyNiwgMzQsIDQyLCA1MCwgNThcbiAgLy8gMywgMTEsIDE5LCAyNywgMzUsIDQzLCA1MSwgNTlcbiAgLy8gMzYsIDQ0LCA1MiwgNjBcbiAgZm9yICh2YXIgaSA9IDE7IGkgPD0gMzsgaSsrKSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPD0gMjQ7IGogKz0gOCkge1xuICAgICAgb3V0UiA8PD0gMTtcbiAgICAgIG91dFIgfD0gKGluUiA+PiAoaiArIGkpKSAmIDE7XG4gICAgfVxuICAgIGZvciAodmFyIGogPSAwOyBqIDw9IDI0OyBqICs9IDgpIHtcbiAgICAgIG91dFIgPDw9IDE7XG4gICAgICBvdXRSIHw9IChpbkwgPj4gKGogKyBpKSkgJiAxO1xuICAgIH1cbiAgfVxuICBmb3IgKHZhciBqID0gMDsgaiA8PSAyNDsgaiArPSA4KSB7XG4gICAgb3V0UiA8PD0gMTtcbiAgICBvdXRSIHw9IChpbkwgPj4gKGogKyBpKSkgJiAxO1xuICB9XG5cbiAgb3V0W29mZiArIDBdID0gb3V0TCA+Pj4gMDtcbiAgb3V0W29mZiArIDFdID0gb3V0UiA+Pj4gMDtcbn07XG5cbmV4cG9ydHMucjI4c2hsID0gZnVuY3Rpb24gcjI4c2hsKG51bSwgc2hpZnQpIHtcbiAgcmV0dXJuICgobnVtIDw8IHNoaWZ0KSAmIDB4ZmZmZmZmZikgfCAobnVtID4+PiAoMjggLSBzaGlmdCkpO1xufTtcblxudmFyIHBjMnRhYmxlID0gW1xuICAvLyBpbkwgPT4gb3V0TFxuICAxNCwgMTEsIDE3LCA0LCAyNywgMjMsIDI1LCAwLFxuICAxMywgMjIsIDcsIDE4LCA1LCA5LCAxNiwgMjQsXG4gIDIsIDIwLCAxMiwgMjEsIDEsIDgsIDE1LCAyNixcblxuICAvLyBpblIgPT4gb3V0UlxuICAxNSwgNCwgMjUsIDE5LCA5LCAxLCAyNiwgMTYsXG4gIDUsIDExLCAyMywgOCwgMTIsIDcsIDE3LCAwLFxuICAyMiwgMywgMTAsIDE0LCA2LCAyMCwgMjcsIDI0XG5dO1xuXG5leHBvcnRzLnBjMiA9IGZ1bmN0aW9uIHBjMihpbkwsIGluUiwgb3V0LCBvZmYpIHtcbiAgdmFyIG91dEwgPSAwO1xuICB2YXIgb3V0UiA9IDA7XG5cbiAgdmFyIGxlbiA9IHBjMnRhYmxlLmxlbmd0aCA+Pj4gMTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIG91dEwgPDw9IDE7XG4gICAgb3V0TCB8PSAoaW5MID4+PiBwYzJ0YWJsZVtpXSkgJiAweDE7XG4gIH1cbiAgZm9yICh2YXIgaSA9IGxlbjsgaSA8IHBjMnRhYmxlLmxlbmd0aDsgaSsrKSB7XG4gICAgb3V0UiA8PD0gMTtcbiAgICBvdXRSIHw9IChpblIgPj4+IHBjMnRhYmxlW2ldKSAmIDB4MTtcbiAgfVxuXG4gIG91dFtvZmYgKyAwXSA9IG91dEwgPj4+IDA7XG4gIG91dFtvZmYgKyAxXSA9IG91dFIgPj4+IDA7XG59O1xuXG5leHBvcnRzLmV4cGFuZCA9IGZ1bmN0aW9uIGV4cGFuZChyLCBvdXQsIG9mZikge1xuICB2YXIgb3V0TCA9IDA7XG4gIHZhciBvdXRSID0gMDtcblxuICBvdXRMID0gKChyICYgMSkgPDwgNSkgfCAociA+Pj4gMjcpO1xuICBmb3IgKHZhciBpID0gMjM7IGkgPj0gMTU7IGkgLT0gNCkge1xuICAgIG91dEwgPDw9IDY7XG4gICAgb3V0TCB8PSAociA+Pj4gaSkgJiAweDNmO1xuICB9XG4gIGZvciAodmFyIGkgPSAxMTsgaSA+PSAzOyBpIC09IDQpIHtcbiAgICBvdXRSIHw9IChyID4+PiBpKSAmIDB4M2Y7XG4gICAgb3V0UiA8PD0gNjtcbiAgfVxuICBvdXRSIHw9ICgociAmIDB4MWYpIDw8IDEpIHwgKHIgPj4+IDMxKTtcblxuICBvdXRbb2ZmICsgMF0gPSBvdXRMID4+PiAwO1xuICBvdXRbb2ZmICsgMV0gPSBvdXRSID4+PiAwO1xufTtcblxudmFyIHNUYWJsZSA9IFtcbiAgMTQsIDAsIDQsIDE1LCAxMywgNywgMSwgNCwgMiwgMTQsIDE1LCAyLCAxMSwgMTMsIDgsIDEsXG4gIDMsIDEwLCAxMCwgNiwgNiwgMTIsIDEyLCAxMSwgNSwgOSwgOSwgNSwgMCwgMywgNywgOCxcbiAgNCwgMTUsIDEsIDEyLCAxNCwgOCwgOCwgMiwgMTMsIDQsIDYsIDksIDIsIDEsIDExLCA3LFxuICAxNSwgNSwgMTIsIDExLCA5LCAzLCA3LCAxNCwgMywgMTAsIDEwLCAwLCA1LCA2LCAwLCAxMyxcblxuICAxNSwgMywgMSwgMTMsIDgsIDQsIDE0LCA3LCA2LCAxNSwgMTEsIDIsIDMsIDgsIDQsIDE0LFxuICA5LCAxMiwgNywgMCwgMiwgMSwgMTMsIDEwLCAxMiwgNiwgMCwgOSwgNSwgMTEsIDEwLCA1LFxuICAwLCAxMywgMTQsIDgsIDcsIDEwLCAxMSwgMSwgMTAsIDMsIDQsIDE1LCAxMywgNCwgMSwgMixcbiAgNSwgMTEsIDgsIDYsIDEyLCA3LCA2LCAxMiwgOSwgMCwgMywgNSwgMiwgMTQsIDE1LCA5LFxuXG4gIDEwLCAxMywgMCwgNywgOSwgMCwgMTQsIDksIDYsIDMsIDMsIDQsIDE1LCA2LCA1LCAxMCxcbiAgMSwgMiwgMTMsIDgsIDEyLCA1LCA3LCAxNCwgMTEsIDEyLCA0LCAxMSwgMiwgMTUsIDgsIDEsXG4gIDEzLCAxLCA2LCAxMCwgNCwgMTMsIDksIDAsIDgsIDYsIDE1LCA5LCAzLCA4LCAwLCA3LFxuICAxMSwgNCwgMSwgMTUsIDIsIDE0LCAxMiwgMywgNSwgMTEsIDEwLCA1LCAxNCwgMiwgNywgMTIsXG5cbiAgNywgMTMsIDEzLCA4LCAxNCwgMTEsIDMsIDUsIDAsIDYsIDYsIDE1LCA5LCAwLCAxMCwgMyxcbiAgMSwgNCwgMiwgNywgOCwgMiwgNSwgMTIsIDExLCAxLCAxMiwgMTAsIDQsIDE0LCAxNSwgOSxcbiAgMTAsIDMsIDYsIDE1LCA5LCAwLCAwLCA2LCAxMiwgMTAsIDExLCAxLCA3LCAxMywgMTMsIDgsXG4gIDE1LCA5LCAxLCA0LCAzLCA1LCAxNCwgMTEsIDUsIDEyLCAyLCA3LCA4LCAyLCA0LCAxNCxcblxuICAyLCAxNCwgMTIsIDExLCA0LCAyLCAxLCAxMiwgNywgNCwgMTAsIDcsIDExLCAxMywgNiwgMSxcbiAgOCwgNSwgNSwgMCwgMywgMTUsIDE1LCAxMCwgMTMsIDMsIDAsIDksIDE0LCA4LCA5LCA2LFxuICA0LCAxMSwgMiwgOCwgMSwgMTIsIDExLCA3LCAxMCwgMSwgMTMsIDE0LCA3LCAyLCA4LCAxMyxcbiAgMTUsIDYsIDksIDE1LCAxMiwgMCwgNSwgOSwgNiwgMTAsIDMsIDQsIDAsIDUsIDE0LCAzLFxuXG4gIDEyLCAxMCwgMSwgMTUsIDEwLCA0LCAxNSwgMiwgOSwgNywgMiwgMTIsIDYsIDksIDgsIDUsXG4gIDAsIDYsIDEzLCAxLCAzLCAxMywgNCwgMTQsIDE0LCAwLCA3LCAxMSwgNSwgMywgMTEsIDgsXG4gIDksIDQsIDE0LCAzLCAxNSwgMiwgNSwgMTIsIDIsIDksIDgsIDUsIDEyLCAxNSwgMywgMTAsXG4gIDcsIDExLCAwLCAxNCwgNCwgMSwgMTAsIDcsIDEsIDYsIDEzLCAwLCAxMSwgOCwgNiwgMTMsXG5cbiAgNCwgMTMsIDExLCAwLCAyLCAxMSwgMTQsIDcsIDE1LCA0LCAwLCA5LCA4LCAxLCAxMywgMTAsXG4gIDMsIDE0LCAxMiwgMywgOSwgNSwgNywgMTIsIDUsIDIsIDEwLCAxNSwgNiwgOCwgMSwgNixcbiAgMSwgNiwgNCwgMTEsIDExLCAxMywgMTMsIDgsIDEyLCAxLCAzLCA0LCA3LCAxMCwgMTQsIDcsXG4gIDEwLCA5LCAxNSwgNSwgNiwgMCwgOCwgMTUsIDAsIDE0LCA1LCAyLCA5LCAzLCAyLCAxMixcblxuICAxMywgMSwgMiwgMTUsIDgsIDEzLCA0LCA4LCA2LCAxMCwgMTUsIDMsIDExLCA3LCAxLCA0LFxuICAxMCwgMTIsIDksIDUsIDMsIDYsIDE0LCAxMSwgNSwgMCwgMCwgMTQsIDEyLCA5LCA3LCAyLFxuICA3LCAyLCAxMSwgMSwgNCwgMTQsIDEsIDcsIDksIDQsIDEyLCAxMCwgMTQsIDgsIDIsIDEzLFxuICAwLCAxNSwgNiwgMTIsIDEwLCA5LCAxMywgMCwgMTUsIDMsIDMsIDUsIDUsIDYsIDgsIDExXG5dO1xuXG5leHBvcnRzLnN1YnN0aXR1dGUgPSBmdW5jdGlvbiBzdWJzdGl0dXRlKGluTCwgaW5SKSB7XG4gIHZhciBvdXQgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgIHZhciBiID0gKGluTCA+Pj4gKDE4IC0gaSAqIDYpKSAmIDB4M2Y7XG4gICAgdmFyIHNiID0gc1RhYmxlW2kgKiAweDQwICsgYl07XG5cbiAgICBvdXQgPDw9IDQ7XG4gICAgb3V0IHw9IHNiO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgdmFyIGIgPSAoaW5SID4+PiAoMTggLSBpICogNikpICYgMHgzZjtcbiAgICB2YXIgc2IgPSBzVGFibGVbNCAqIDB4NDAgKyBpICogMHg0MCArIGJdO1xuXG4gICAgb3V0IDw8PSA0O1xuICAgIG91dCB8PSBzYjtcbiAgfVxuICByZXR1cm4gb3V0ID4+PiAwO1xufTtcblxudmFyIHBlcm11dGVUYWJsZSA9IFtcbiAgMTYsIDI1LCAxMiwgMTEsIDMsIDIwLCA0LCAxNSwgMzEsIDE3LCA5LCA2LCAyNywgMTQsIDEsIDIyLFxuICAzMCwgMjQsIDgsIDE4LCAwLCA1LCAyOSwgMjMsIDEzLCAxOSwgMiwgMjYsIDEwLCAyMSwgMjgsIDdcbl07XG5cbmV4cG9ydHMucGVybXV0ZSA9IGZ1bmN0aW9uIHBlcm11dGUobnVtKSB7XG4gIHZhciBvdXQgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBlcm11dGVUYWJsZS5sZW5ndGg7IGkrKykge1xuICAgIG91dCA8PD0gMTtcbiAgICBvdXQgfD0gKG51bSA+Pj4gcGVybXV0ZVRhYmxlW2ldKSAmIDB4MTtcbiAgfVxuICByZXR1cm4gb3V0ID4+PiAwO1xufTtcblxuZXhwb3J0cy5wYWRTcGxpdCA9IGZ1bmN0aW9uIHBhZFNwbGl0KG51bSwgc2l6ZSwgZ3JvdXApIHtcbiAgdmFyIHN0ciA9IG51bS50b1N0cmluZygyKTtcbiAgd2hpbGUgKHN0ci5sZW5ndGggPCBzaXplKVxuICAgIHN0ciA9ICcwJyArIHN0cjtcblxuICB2YXIgb3V0ID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSArPSBncm91cClcbiAgICBvdXQucHVzaChzdHIuc2xpY2UoaSwgaSArIGdyb3VwKSk7XG4gIHJldHVybiBvdXQuam9pbignICcpO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gYXNzZXJ0O1xuXG5mdW5jdGlvbiBhc3NlcnQodmFsLCBtc2cpIHtcbiAgaWYgKCF2YWwpXG4gICAgdGhyb3cgbmV3IEVycm9yKG1zZyB8fCAnQXNzZXJ0aW9uIGZhaWxlZCcpO1xufVxuXG5hc3NlcnQuZXF1YWwgPSBmdW5jdGlvbiBhc3NlcnRFcXVhbChsLCByLCBtc2cpIHtcbiAgaWYgKGwgIT0gcilcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnIHx8ICgnQXNzZXJ0aW9uIGZhaWxlZDogJyArIGwgKyAnICE9ICcgKyByKSk7XG59O1xuIiwidmFyIG1kNSA9IHJlcXVpcmUoJ2NyZWF0ZS1oYXNoL21kNScpXG5tb2R1bGUuZXhwb3J0cyA9IEVWUF9CeXRlc1RvS2V5XG5mdW5jdGlvbiBFVlBfQnl0ZXNUb0tleSAocGFzc3dvcmQsIHNhbHQsIGtleUxlbiwgaXZMZW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIocGFzc3dvcmQpKSB7XG4gICAgcGFzc3dvcmQgPSBuZXcgQnVmZmVyKHBhc3N3b3JkLCAnYmluYXJ5JylcbiAgfVxuICBpZiAoc2FsdCAmJiAhQnVmZmVyLmlzQnVmZmVyKHNhbHQpKSB7XG4gICAgc2FsdCA9IG5ldyBCdWZmZXIoc2FsdCwgJ2JpbmFyeScpXG4gIH1cbiAga2V5TGVuID0ga2V5TGVuIC8gOFxuICBpdkxlbiA9IGl2TGVuIHx8IDBcbiAgdmFyIGtpID0gMFxuICB2YXIgaWkgPSAwXG4gIHZhciBrZXkgPSBuZXcgQnVmZmVyKGtleUxlbilcbiAgdmFyIGl2ID0gbmV3IEJ1ZmZlcihpdkxlbilcbiAgdmFyIGFkZG1kID0gMFxuICB2YXIgbWRfYnVmXG4gIHZhciBpXG4gIHZhciBidWZzID0gW11cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAoYWRkbWQrKyA+IDApIHtcbiAgICAgIGJ1ZnMucHVzaChtZF9idWYpXG4gICAgfVxuICAgIGJ1ZnMucHVzaChwYXNzd29yZClcbiAgICBpZiAoc2FsdCkge1xuICAgICAgYnVmcy5wdXNoKHNhbHQpXG4gICAgfVxuICAgIG1kX2J1ZiA9IG1kNShCdWZmZXIuY29uY2F0KGJ1ZnMpKVxuICAgIGJ1ZnMgPSBbXVxuICAgIGkgPSAwXG4gICAgaWYgKGtleUxlbiA+IDApIHtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGlmIChrZXlMZW4gPT09IDApIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGlmIChpID09PSBtZF9idWYubGVuZ3RoKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBrZXlba2krK10gPSBtZF9idWZbaV1cbiAgICAgICAga2V5TGVuLS1cbiAgICAgICAgaSsrXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpdkxlbiA+IDAgJiYgaSAhPT0gbWRfYnVmLmxlbmd0aCkge1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgaWYgKGl2TGVuID09PSAwKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA9PT0gbWRfYnVmLmxlbmd0aCkge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgaXZbaWkrK10gPSBtZF9idWZbaV1cbiAgICAgICAgaXZMZW4tLVxuICAgICAgICBpKytcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGtleUxlbiA9PT0gMCAmJiBpdkxlbiA9PT0gMCkge1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbiAgZm9yIChpID0gMDsgaSA8IG1kX2J1Zi5sZW5ndGg7IGkrKykge1xuICAgIG1kX2J1ZltpXSA9IDBcbiAgfVxuICByZXR1cm4ge1xuICAgIGtleToga2V5LFxuICAgIGl2OiBpdlxuICB9XG59XG4iLCIndXNlIHN0cmljdCdcbmV4cG9ydHNbJ1JTQS1TSEEyMjQnXSA9IGV4cG9ydHMuc2hhMjI0V2l0aFJTQUVuY3J5cHRpb24gPSB7XG4gIHNpZ246ICdyc2EnLFxuICBoYXNoOiAnc2hhMjI0JyxcbiAgaWQ6IG5ldyBCdWZmZXIoJzMwMmQzMDBkMDYwOTYwODY0ODAxNjUwMzA0MDIwNDA1MDAwNDFjJywgJ2hleCcpXG59XG5leHBvcnRzWydSU0EtU0hBMjU2J10gPSBleHBvcnRzLnNoYTI1NldpdGhSU0FFbmNyeXB0aW9uID0ge1xuICBzaWduOiAncnNhJyxcbiAgaGFzaDogJ3NoYTI1NicsXG4gIGlkOiBuZXcgQnVmZmVyKCczMDMxMzAwZDA2MDk2MDg2NDgwMTY1MDMwNDAyMDEwNTAwMDQyMCcsICdoZXgnKVxufVxuZXhwb3J0c1snUlNBLVNIQTM4NCddID0gZXhwb3J0cy5zaGEzODRXaXRoUlNBRW5jcnlwdGlvbiA9IHtcbiAgc2lnbjogJ3JzYScsXG4gIGhhc2g6ICdzaGEzODQnLFxuICBpZDogbmV3IEJ1ZmZlcignMzA0MTMwMGQwNjA5NjA4NjQ4MDE2NTAzMDQwMjAyMDUwMDA0MzAnLCAnaGV4Jylcbn1cbmV4cG9ydHNbJ1JTQS1TSEE1MTInXSA9IGV4cG9ydHMuc2hhNTEyV2l0aFJTQUVuY3J5cHRpb24gPSB7XG4gIHNpZ246ICdyc2EnLFxuICBoYXNoOiAnc2hhNTEyJyxcbiAgaWQ6IG5ldyBCdWZmZXIoJzMwNTEzMDBkMDYwOTYwODY0ODAxNjUwMzA0MDIwMzA1MDAwNDQwJywgJ2hleCcpXG59XG5leHBvcnRzWydSU0EtU0hBMSddID0ge1xuICBzaWduOiAncnNhJyxcbiAgaGFzaDogJ3NoYTEnLFxuICBpZDogbmV3IEJ1ZmZlcignMzAyMTMwMDkwNjA1MmIwZTAzMDIxYTA1MDAwNDE0JywgJ2hleCcpXG59XG5leHBvcnRzWydlY2RzYS13aXRoLVNIQTEnXSA9IHtcbiAgc2lnbjogJ2VjZHNhJyxcbiAgaGFzaDogJ3NoYTEnLFxuICBpZDogbmV3IEJ1ZmZlcignJywgJ2hleCcpXG59XG5cbmV4cG9ydHMuRFNBID0gZXhwb3J0c1snRFNBLVNIQTEnXSA9IGV4cG9ydHNbJ0RTQS1TSEEnXSA9IHtcbiAgc2lnbjogJ2RzYScsXG4gIGhhc2g6ICdzaGExJyxcbiAgaWQ6IG5ldyBCdWZmZXIoJycsICdoZXgnKVxufVxuZXhwb3J0c1snRFNBLVNIQTIyNCddID0gZXhwb3J0c1snRFNBLVdJVEgtU0hBMjI0J10gPSB7XG4gIHNpZ246ICdkc2EnLFxuICBoYXNoOiAnc2hhMjI0JyxcbiAgaWQ6IG5ldyBCdWZmZXIoJycsICdoZXgnKVxufVxuZXhwb3J0c1snRFNBLVNIQTI1NiddID0gZXhwb3J0c1snRFNBLVdJVEgtU0hBMjU2J10gPSB7XG4gIHNpZ246ICdkc2EnLFxuICBoYXNoOiAnc2hhMjU2JyxcbiAgaWQ6IG5ldyBCdWZmZXIoJycsICdoZXgnKVxufVxuZXhwb3J0c1snRFNBLVNIQTM4NCddID0gZXhwb3J0c1snRFNBLVdJVEgtU0hBMzg0J10gPSB7XG4gIHNpZ246ICdkc2EnLFxuICBoYXNoOiAnc2hhMzg0JyxcbiAgaWQ6IG5ldyBCdWZmZXIoJycsICdoZXgnKVxufVxuZXhwb3J0c1snRFNBLVNIQTUxMiddID0gZXhwb3J0c1snRFNBLVdJVEgtU0hBNTEyJ10gPSB7XG4gIHNpZ246ICdkc2EnLFxuICBoYXNoOiAnc2hhNTEyJyxcbiAgaWQ6IG5ldyBCdWZmZXIoJycsICdoZXgnKVxufVxuZXhwb3J0c1snRFNBLVJJUEVNRDE2MCddID0ge1xuICBzaWduOiAnZHNhJyxcbiAgaGFzaDogJ3JtZDE2MCcsXG4gIGlkOiBuZXcgQnVmZmVyKCcnLCAnaGV4Jylcbn1cbmV4cG9ydHNbJ1JTQS1SSVBFTUQxNjAnXSA9IGV4cG9ydHMucmlwZW1kMTYwV2l0aFJTQSA9IHtcbiAgc2lnbjogJ3JzYScsXG4gIGhhc2g6ICdybWQxNjAnLFxuICBpZDogbmV3IEJ1ZmZlcignMzAyMTMwMDkwNjA1MmIyNDAzMDIwMTA1MDAwNDE0JywgJ2hleCcpXG59XG5leHBvcnRzWydSU0EtTUQ1J10gPSBleHBvcnRzLm1kNVdpdGhSU0FFbmNyeXB0aW9uID0ge1xuICBzaWduOiAncnNhJyxcbiAgaGFzaDogJ21kNScsXG4gIGlkOiBuZXcgQnVmZmVyKCczMDIwMzAwYzA2MDgyYTg2NDg4NmY3MGQwMjA1MDUwMDA0MTAnLCAnaGV4Jylcbn1cbiIsInZhciBfYWxnb3MgPSByZXF1aXJlKCcuL2FsZ29zJylcbnZhciBjcmVhdGVIYXNoID0gcmVxdWlyZSgnY3JlYXRlLWhhc2gnKVxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIHNpZ24gPSByZXF1aXJlKCcuL3NpZ24nKVxudmFyIHN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpXG52YXIgdmVyaWZ5ID0gcmVxdWlyZSgnLi92ZXJpZnknKVxuXG52YXIgYWxnb3MgPSB7fVxuT2JqZWN0LmtleXMoX2FsZ29zKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgYWxnb3Nba2V5XSA9IGFsZ29zW2tleS50b0xvd2VyQ2FzZSgpXSA9IF9hbGdvc1trZXldXG59KVxuXG5mdW5jdGlvbiBTaWduIChhbGdvcml0aG0pIHtcbiAgc3RyZWFtLldyaXRhYmxlLmNhbGwodGhpcylcblxuICB2YXIgZGF0YSA9IGFsZ29zW2FsZ29yaXRobV1cbiAgaWYgKCFkYXRhKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIG1lc3NhZ2UgZGlnZXN0JylcbiAgfVxuXG4gIHRoaXMuX2hhc2hUeXBlID0gZGF0YS5oYXNoXG4gIHRoaXMuX2hhc2ggPSBjcmVhdGVIYXNoKGRhdGEuaGFzaClcbiAgdGhpcy5fdGFnID0gZGF0YS5pZFxuICB0aGlzLl9zaWduVHlwZSA9IGRhdGEuc2lnblxufVxuaW5oZXJpdHMoU2lnbiwgc3RyZWFtLldyaXRhYmxlKVxuXG5TaWduLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiBfd3JpdGUgKGRhdGEsIF8sIGRvbmUpIHtcbiAgdGhpcy5faGFzaC51cGRhdGUoZGF0YSlcbiAgZG9uZSgpXG59XG5cblNpZ24ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAoZGF0YSwgZW5jKSB7XG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICBkYXRhID0gbmV3IEJ1ZmZlcihkYXRhLCBlbmMpXG4gIH1cblxuICB0aGlzLl9oYXNoLnVwZGF0ZShkYXRhKVxuICByZXR1cm4gdGhpc1xufVxuXG5TaWduLnByb3RvdHlwZS5zaWduID0gZnVuY3Rpb24gc2lnbk1ldGhvZCAoa2V5LCBlbmMpIHtcbiAgdGhpcy5lbmQoKVxuICB2YXIgaGFzaCA9IHRoaXMuX2hhc2guZGlnZXN0KClcbiAgdmFyIHNpZyA9IHNpZ24oQnVmZmVyLmNvbmNhdChbdGhpcy5fdGFnLCBoYXNoXSksIGtleSwgdGhpcy5faGFzaFR5cGUsIHRoaXMuX3NpZ25UeXBlKVxuXG4gIHJldHVybiBlbmMgPyBzaWcudG9TdHJpbmcoZW5jKSA6IHNpZ1xufVxuXG5mdW5jdGlvbiBWZXJpZnkgKGFsZ29yaXRobSkge1xuICBzdHJlYW0uV3JpdGFibGUuY2FsbCh0aGlzKVxuXG4gIHZhciBkYXRhID0gYWxnb3NbYWxnb3JpdGhtXVxuICBpZiAoIWRhdGEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gbWVzc2FnZSBkaWdlc3QnKVxuICB9XG5cbiAgdGhpcy5faGFzaCA9IGNyZWF0ZUhhc2goZGF0YS5oYXNoKVxuICB0aGlzLl90YWcgPSBkYXRhLmlkXG4gIHRoaXMuX3NpZ25UeXBlID0gZGF0YS5zaWduXG59XG5pbmhlcml0cyhWZXJpZnksIHN0cmVhbS5Xcml0YWJsZSlcblxuVmVyaWZ5LnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiBfd3JpdGUgKGRhdGEsIF8sIGRvbmUpIHtcbiAgdGhpcy5faGFzaC51cGRhdGUoZGF0YSlcblxuICBkb25lKClcbn1cblxuVmVyaWZ5LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUgKGRhdGEsIGVuYykge1xuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgZGF0YSA9IG5ldyBCdWZmZXIoZGF0YSwgZW5jKVxuICB9XG5cbiAgdGhpcy5faGFzaC51cGRhdGUoZGF0YSlcbiAgcmV0dXJuIHRoaXNcbn1cblxuVmVyaWZ5LnByb3RvdHlwZS52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnlNZXRob2QgKGtleSwgc2lnLCBlbmMpIHtcbiAgaWYgKHR5cGVvZiBzaWcgPT09ICdzdHJpbmcnKSB7XG4gICAgc2lnID0gbmV3IEJ1ZmZlcihzaWcsIGVuYylcbiAgfVxuXG4gIHRoaXMuZW5kKClcbiAgdmFyIGhhc2ggPSB0aGlzLl9oYXNoLmRpZ2VzdCgpXG5cbiAgcmV0dXJuIHZlcmlmeShzaWcsIEJ1ZmZlci5jb25jYXQoW3RoaXMuX3RhZywgaGFzaF0pLCBrZXksIHRoaXMuX3NpZ25UeXBlKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTaWduIChhbGdvcml0aG0pIHtcbiAgcmV0dXJuIG5ldyBTaWduKGFsZ29yaXRobSlcbn1cblxuZnVuY3Rpb24gY3JlYXRlVmVyaWZ5IChhbGdvcml0aG0pIHtcbiAgcmV0dXJuIG5ldyBWZXJpZnkoYWxnb3JpdGhtKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgU2lnbjogY3JlYXRlU2lnbixcbiAgVmVyaWZ5OiBjcmVhdGVWZXJpZnksXG4gIGNyZWF0ZVNpZ246IGNyZWF0ZVNpZ24sXG4gIGNyZWF0ZVZlcmlmeTogY3JlYXRlVmVyaWZ5XG59XG4iLCIndXNlIHN0cmljdCdcbmV4cG9ydHNbJzEuMy4xMzIuMC4xMCddID0gJ3NlY3AyNTZrMSdcblxuZXhwb3J0c1snMS4zLjEzMi4wLjMzJ10gPSAncDIyNCdcblxuZXhwb3J0c1snMS4yLjg0MC4xMDA0NS4zLjEuMSddID0gJ3AxOTInXG5cbmV4cG9ydHNbJzEuMi44NDAuMTAwNDUuMy4xLjcnXSA9ICdwMjU2J1xuXG5leHBvcnRzWycxLjMuMTMyLjAuMzQnXSA9ICdwMzg0J1xuXG5leHBvcnRzWycxLjMuMTMyLjAuMzUnXSA9ICdwNTIxJ1xuIiwiKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBVdGlsc1xuXG5mdW5jdGlvbiBhc3NlcnQodmFsLCBtc2cpIHtcbiAgaWYgKCF2YWwpXG4gICAgdGhyb3cgbmV3IEVycm9yKG1zZyB8fCAnQXNzZXJ0aW9uIGZhaWxlZCcpO1xufVxuXG4vLyBDb3VsZCB1c2UgYGluaGVyaXRzYCBtb2R1bGUsIGJ1dCBkb24ndCB3YW50IHRvIG1vdmUgZnJvbSBzaW5nbGUgZmlsZVxuLy8gYXJjaGl0ZWN0dXJlIHlldC5cbmZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvcjtcbiAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge307XG4gIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGU7XG4gIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKCk7XG4gIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3Rvcjtcbn1cblxuLy8gQk5cblxuZnVuY3Rpb24gQk4obnVtYmVyLCBiYXNlLCBlbmRpYW4pIHtcbiAgLy8gTWF5IGJlIGBuZXcgQk4oYm4pYCA/XG4gIGlmIChudW1iZXIgIT09IG51bGwgJiZcbiAgICAgIHR5cGVvZiBudW1iZXIgPT09ICdvYmplY3QnICYmXG4gICAgICBBcnJheS5pc0FycmF5KG51bWJlci53b3JkcykpIHtcbiAgICByZXR1cm4gbnVtYmVyO1xuICB9XG5cbiAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gIHRoaXMud29yZHMgPSBudWxsO1xuICB0aGlzLmxlbmd0aCA9IDA7XG5cbiAgLy8gUmVkdWN0aW9uIGNvbnRleHRcbiAgdGhpcy5yZWQgPSBudWxsO1xuXG4gIGlmIChudW1iZXIgIT09IG51bGwpIHtcbiAgICBpZiAoYmFzZSA9PT0gJ2xlJyB8fCBiYXNlID09PSAnYmUnKSB7XG4gICAgICBlbmRpYW4gPSBiYXNlO1xuICAgICAgYmFzZSA9IDEwO1xuICAgIH1cblxuICAgIHRoaXMuX2luaXQobnVtYmVyIHx8IDAsIGJhc2UgfHwgMTAsIGVuZGlhbiB8fCAnYmUnKTtcbiAgfVxufVxuaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuICBtb2R1bGUuZXhwb3J0cyA9IEJOO1xuZWxzZVxuICBleHBvcnRzLkJOID0gQk47XG5cbkJOLkJOID0gQk47XG5CTi53b3JkU2l6ZSA9IDI2O1xuXG5CTi5tYXggPSBmdW5jdGlvbiBtYXgobGVmdCwgcmlnaHQpIHtcbiAgaWYgKGxlZnQuY21wKHJpZ2h0KSA+IDApXG4gICAgcmV0dXJuIGxlZnQ7XG4gIGVsc2VcbiAgICByZXR1cm4gcmlnaHQ7XG59O1xuXG5CTi5taW4gPSBmdW5jdGlvbiBtaW4obGVmdCwgcmlnaHQpIHtcbiAgaWYgKGxlZnQuY21wKHJpZ2h0KSA8IDApXG4gICAgcmV0dXJuIGxlZnQ7XG4gIGVsc2VcbiAgICByZXR1cm4gcmlnaHQ7XG59O1xuXG5CTi5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiBpbml0KG51bWJlciwgYmFzZSwgZW5kaWFuKSB7XG4gIGlmICh0eXBlb2YgbnVtYmVyID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB0aGlzLl9pbml0TnVtYmVyKG51bWJlciwgYmFzZSwgZW5kaWFuKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgbnVtYmVyID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiB0aGlzLl9pbml0QXJyYXkobnVtYmVyLCBiYXNlLCBlbmRpYW4pO1xuICB9XG4gIGlmIChiYXNlID09PSAnaGV4JylcbiAgICBiYXNlID0gMTY7XG4gIGFzc2VydChiYXNlID09PSAoYmFzZSB8IDApICYmIGJhc2UgPj0gMiAmJiBiYXNlIDw9IDM2KTtcblxuICBudW1iZXIgPSBudW1iZXIudG9TdHJpbmcoKS5yZXBsYWNlKC9cXHMrL2csICcnKTtcbiAgdmFyIHN0YXJ0ID0gMDtcbiAgaWYgKG51bWJlclswXSA9PT0gJy0nKVxuICAgIHN0YXJ0Kys7XG5cbiAgaWYgKGJhc2UgPT09IDE2KVxuICAgIHRoaXMuX3BhcnNlSGV4KG51bWJlciwgc3RhcnQpO1xuICBlbHNlXG4gICAgdGhpcy5fcGFyc2VCYXNlKG51bWJlciwgYmFzZSwgc3RhcnQpO1xuXG4gIGlmIChudW1iZXJbMF0gPT09ICctJylcbiAgICB0aGlzLm5lZ2F0aXZlID0gMTtcblxuICB0aGlzLnN0cmlwKCk7XG5cbiAgaWYgKGVuZGlhbiAhPT0gJ2xlJylcbiAgICByZXR1cm47XG5cbiAgdGhpcy5faW5pdEFycmF5KHRoaXMudG9BcnJheSgpLCBiYXNlLCBlbmRpYW4pO1xufTtcblxuQk4ucHJvdG90eXBlLl9pbml0TnVtYmVyID0gZnVuY3Rpb24gX2luaXROdW1iZXIobnVtYmVyLCBiYXNlLCBlbmRpYW4pIHtcbiAgaWYgKG51bWJlciA8IDApIHtcbiAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICBudW1iZXIgPSAtbnVtYmVyO1xuICB9XG4gIGlmIChudW1iZXIgPCAweDQwMDAwMDApIHtcbiAgICB0aGlzLndvcmRzID0gWyBudW1iZXIgJiAweDNmZmZmZmYgXTtcbiAgICB0aGlzLmxlbmd0aCA9IDE7XG4gIH0gZWxzZSBpZiAobnVtYmVyIDwgMHgxMDAwMDAwMDAwMDAwMCkge1xuICAgIHRoaXMud29yZHMgPSBbXG4gICAgICBudW1iZXIgJiAweDNmZmZmZmYsXG4gICAgICAobnVtYmVyIC8gMHg0MDAwMDAwKSAmIDB4M2ZmZmZmZlxuICAgIF07XG4gICAgdGhpcy5sZW5ndGggPSAyO1xuICB9IGVsc2Uge1xuICAgIGFzc2VydChudW1iZXIgPCAweDIwMDAwMDAwMDAwMDAwKTsgLy8gMiBeIDUzICh1bnNhZmUpXG4gICAgdGhpcy53b3JkcyA9IFtcbiAgICAgIG51bWJlciAmIDB4M2ZmZmZmZixcbiAgICAgIChudW1iZXIgLyAweDQwMDAwMDApICYgMHgzZmZmZmZmLFxuICAgICAgMVxuICAgIF07XG4gICAgdGhpcy5sZW5ndGggPSAzO1xuICB9XG5cbiAgaWYgKGVuZGlhbiAhPT0gJ2xlJylcbiAgICByZXR1cm47XG5cbiAgLy8gUmV2ZXJzZSB0aGUgYnl0ZXNcbiAgdGhpcy5faW5pdEFycmF5KHRoaXMudG9BcnJheSgpLCBiYXNlLCBlbmRpYW4pO1xufTtcblxuQk4ucHJvdG90eXBlLl9pbml0QXJyYXkgPSBmdW5jdGlvbiBfaW5pdEFycmF5KG51bWJlciwgYmFzZSwgZW5kaWFuKSB7XG4gIC8vIFBlcmhhcHMgYSBVaW50OEFycmF5XG4gIGFzc2VydCh0eXBlb2YgbnVtYmVyLmxlbmd0aCA9PT0gJ251bWJlcicpO1xuICBpZiAobnVtYmVyLmxlbmd0aCA8PSAwKSB7XG4gICAgdGhpcy53b3JkcyA9IFsgMCBdO1xuICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHRoaXMubGVuZ3RoID0gTWF0aC5jZWlsKG51bWJlci5sZW5ndGggLyAzKTtcbiAgdGhpcy53b3JkcyA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKylcbiAgICB0aGlzLndvcmRzW2ldID0gMDtcblxuICB2YXIgb2ZmID0gMDtcbiAgaWYgKGVuZGlhbiA9PT0gJ2JlJykge1xuICAgIGZvciAodmFyIGkgPSBudW1iZXIubGVuZ3RoIC0gMSwgaiA9IDA7IGkgPj0gMDsgaSAtPSAzKSB7XG4gICAgICB2YXIgdyA9IG51bWJlcltpXSB8IChudW1iZXJbaSAtIDFdIDw8IDgpIHwgKG51bWJlcltpIC0gMl0gPDwgMTYpO1xuICAgICAgdGhpcy53b3Jkc1tqXSB8PSAodyA8PCBvZmYpICYgMHgzZmZmZmZmO1xuICAgICAgdGhpcy53b3Jkc1tqICsgMV0gPSAodyA+Pj4gKDI2IC0gb2ZmKSkgJiAweDNmZmZmZmY7XG4gICAgICBvZmYgKz0gMjQ7XG4gICAgICBpZiAob2ZmID49IDI2KSB7XG4gICAgICAgIG9mZiAtPSAyNjtcbiAgICAgICAgaisrO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChlbmRpYW4gPT09ICdsZScpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IDA7IGkgPCBudW1iZXIubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgIHZhciB3ID0gbnVtYmVyW2ldIHwgKG51bWJlcltpICsgMV0gPDwgOCkgfCAobnVtYmVyW2kgKyAyXSA8PCAxNik7XG4gICAgICB0aGlzLndvcmRzW2pdIHw9ICh3IDw8IG9mZikgJiAweDNmZmZmZmY7XG4gICAgICB0aGlzLndvcmRzW2ogKyAxXSA9ICh3ID4+PiAoMjYgLSBvZmYpKSAmIDB4M2ZmZmZmZjtcbiAgICAgIG9mZiArPSAyNDtcbiAgICAgIGlmIChvZmYgPj0gMjYpIHtcbiAgICAgICAgb2ZmIC09IDI2O1xuICAgICAgICBqKys7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzLnN0cmlwKCk7XG59O1xuXG5mdW5jdGlvbiBwYXJzZUhleChzdHIsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHIgPSAwO1xuICB2YXIgbGVuID0gTWF0aC5taW4oc3RyLmxlbmd0aCwgZW5kKTtcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgYyA9IHN0ci5jaGFyQ29kZUF0KGkpIC0gNDg7XG5cbiAgICByIDw8PSA0O1xuXG4gICAgLy8gJ2EnIC0gJ2YnXG4gICAgaWYgKGMgPj0gNDkgJiYgYyA8PSA1NClcbiAgICAgIHIgfD0gYyAtIDQ5ICsgMHhhO1xuXG4gICAgLy8gJ0EnIC0gJ0YnXG4gICAgZWxzZSBpZiAoYyA+PSAxNyAmJiBjIDw9IDIyKVxuICAgICAgciB8PSBjIC0gMTcgKyAweGE7XG5cbiAgICAvLyAnMCcgLSAnOSdcbiAgICBlbHNlXG4gICAgICByIHw9IGMgJiAweGY7XG4gIH1cbiAgcmV0dXJuIHI7XG59XG5cbkJOLnByb3RvdHlwZS5fcGFyc2VIZXggPSBmdW5jdGlvbiBfcGFyc2VIZXgobnVtYmVyLCBzdGFydCkge1xuICAvLyBDcmVhdGUgcG9zc2libHkgYmlnZ2VyIGFycmF5IHRvIGVuc3VyZSB0aGF0IGl0IGZpdHMgdGhlIG51bWJlclxuICB0aGlzLmxlbmd0aCA9IE1hdGguY2VpbCgobnVtYmVyLmxlbmd0aCAtIHN0YXJ0KSAvIDYpO1xuICB0aGlzLndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKVxuICAgIHRoaXMud29yZHNbaV0gPSAwO1xuXG4gIC8vIFNjYW4gMjQtYml0IGNodW5rcyBhbmQgYWRkIHRoZW0gdG8gdGhlIG51bWJlclxuICB2YXIgb2ZmID0gMDtcbiAgZm9yICh2YXIgaSA9IG51bWJlci5sZW5ndGggLSA2LCBqID0gMDsgaSA+PSBzdGFydDsgaSAtPSA2KSB7XG4gICAgdmFyIHcgPSBwYXJzZUhleChudW1iZXIsIGksIGkgKyA2KTtcbiAgICB0aGlzLndvcmRzW2pdIHw9ICh3IDw8IG9mZikgJiAweDNmZmZmZmY7XG4gICAgdGhpcy53b3Jkc1tqICsgMV0gfD0gdyA+Pj4gKDI2IC0gb2ZmKSAmIDB4M2ZmZmZmO1xuICAgIG9mZiArPSAyNDtcbiAgICBpZiAob2ZmID49IDI2KSB7XG4gICAgICBvZmYgLT0gMjY7XG4gICAgICBqKys7XG4gICAgfVxuICB9XG4gIGlmIChpICsgNiAhPT0gc3RhcnQpIHtcbiAgICB2YXIgdyA9IHBhcnNlSGV4KG51bWJlciwgc3RhcnQsIGkgKyA2KTtcbiAgICB0aGlzLndvcmRzW2pdIHw9ICh3IDw8IG9mZikgJiAweDNmZmZmZmY7XG4gICAgdGhpcy53b3Jkc1tqICsgMV0gfD0gdyA+Pj4gKDI2IC0gb2ZmKSAmIDB4M2ZmZmZmO1xuICB9XG4gIHRoaXMuc3RyaXAoKTtcbn07XG5cbmZ1bmN0aW9uIHBhcnNlQmFzZShzdHIsIHN0YXJ0LCBlbmQsIG11bCkge1xuICB2YXIgciA9IDA7XG4gIHZhciBsZW4gPSBNYXRoLm1pbihzdHIubGVuZ3RoLCBlbmQpO1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSkgLSA0ODtcblxuICAgIHIgKj0gbXVsO1xuXG4gICAgLy8gJ2EnXG4gICAgaWYgKGMgPj0gNDkpXG4gICAgICByICs9IGMgLSA0OSArIDB4YTtcblxuICAgIC8vICdBJ1xuICAgIGVsc2UgaWYgKGMgPj0gMTcpXG4gICAgICByICs9IGMgLSAxNyArIDB4YTtcblxuICAgIC8vICcwJyAtICc5J1xuICAgIGVsc2VcbiAgICAgIHIgKz0gYztcbiAgfVxuICByZXR1cm4gcjtcbn1cblxuQk4ucHJvdG90eXBlLl9wYXJzZUJhc2UgPSBmdW5jdGlvbiBfcGFyc2VCYXNlKG51bWJlciwgYmFzZSwgc3RhcnQpIHtcbiAgLy8gSW5pdGlhbGl6ZSBhcyB6ZXJvXG4gIHRoaXMud29yZHMgPSBbIDAgXTtcbiAgdGhpcy5sZW5ndGggPSAxO1xuXG4gIC8vIEZpbmQgbGVuZ3RoIG9mIGxpbWIgaW4gYmFzZVxuICBmb3IgKHZhciBsaW1iTGVuID0gMCwgbGltYlBvdyA9IDE7IGxpbWJQb3cgPD0gMHgzZmZmZmZmOyBsaW1iUG93ICo9IGJhc2UpXG4gICAgbGltYkxlbisrO1xuICBsaW1iTGVuLS07XG4gIGxpbWJQb3cgPSAobGltYlBvdyAvIGJhc2UpIHwgMDtcblxuICB2YXIgdG90YWwgPSBudW1iZXIubGVuZ3RoIC0gc3RhcnQ7XG4gIHZhciBtb2QgPSB0b3RhbCAlIGxpbWJMZW47XG4gIHZhciBlbmQgPSBNYXRoLm1pbih0b3RhbCwgdG90YWwgLSBtb2QpICsgc3RhcnQ7XG5cbiAgdmFyIHdvcmQgPSAwO1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gbGltYkxlbikge1xuICAgIHdvcmQgPSBwYXJzZUJhc2UobnVtYmVyLCBpLCBpICsgbGltYkxlbiwgYmFzZSk7XG5cbiAgICB0aGlzLmltdWxuKGxpbWJQb3cpO1xuICAgIGlmICh0aGlzLndvcmRzWzBdICsgd29yZCA8IDB4NDAwMDAwMClcbiAgICAgIHRoaXMud29yZHNbMF0gKz0gd29yZDtcbiAgICBlbHNlXG4gICAgICB0aGlzLl9pYWRkbih3b3JkKTtcbiAgfVxuXG4gIGlmIChtb2QgIT09IDApIHtcbiAgICB2YXIgcG93ID0gMTtcbiAgICB2YXIgd29yZCA9IHBhcnNlQmFzZShudW1iZXIsIGksIG51bWJlci5sZW5ndGgsIGJhc2UpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtb2Q7IGkrKylcbiAgICAgIHBvdyAqPSBiYXNlO1xuICAgIHRoaXMuaW11bG4ocG93KTtcbiAgICBpZiAodGhpcy53b3Jkc1swXSArIHdvcmQgPCAweDQwMDAwMDApXG4gICAgICB0aGlzLndvcmRzWzBdICs9IHdvcmQ7XG4gICAgZWxzZVxuICAgICAgdGhpcy5faWFkZG4od29yZCk7XG4gIH1cbn07XG5cbkJOLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weShkZXN0KSB7XG4gIGRlc3Qud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspXG4gICAgZGVzdC53b3Jkc1tpXSA9IHRoaXMud29yZHNbaV07XG4gIGRlc3QubGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gIGRlc3QubmVnYXRpdmUgPSB0aGlzLm5lZ2F0aXZlO1xuICBkZXN0LnJlZCA9IHRoaXMucmVkO1xufTtcblxuQk4ucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gY2xvbmUoKSB7XG4gIHZhciByID0gbmV3IEJOKG51bGwpO1xuICB0aGlzLmNvcHkocik7XG4gIHJldHVybiByO1xufTtcblxuLy8gUmVtb3ZlIGxlYWRpbmcgYDBgIGZyb20gYHRoaXNgXG5CTi5wcm90b3R5cGUuc3RyaXAgPSBmdW5jdGlvbiBzdHJpcCgpIHtcbiAgd2hpbGUgKHRoaXMubGVuZ3RoID4gMSAmJiB0aGlzLndvcmRzW3RoaXMubGVuZ3RoIC0gMV0gPT09IDApXG4gICAgdGhpcy5sZW5ndGgtLTtcbiAgcmV0dXJuIHRoaXMuX25vcm1TaWduKCk7XG59O1xuXG5CTi5wcm90b3R5cGUuX25vcm1TaWduID0gZnVuY3Rpb24gX25vcm1TaWduKCkge1xuICAvLyAtMCA9IDBcbiAgaWYgKHRoaXMubGVuZ3RoID09PSAxICYmIHRoaXMud29yZHNbMF0gPT09IDApXG4gICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gIHJldHVybiB0aGlzO1xufTtcblxuQk4ucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0KCkge1xuICByZXR1cm4gKHRoaXMucmVkID8gJzxCTi1SOiAnIDogJzxCTjogJykgKyB0aGlzLnRvU3RyaW5nKDE2KSArICc+Jztcbn07XG5cbi8qXG5cbnZhciB6ZXJvcyA9IFtdO1xudmFyIGdyb3VwU2l6ZXMgPSBbXTtcbnZhciBncm91cEJhc2VzID0gW107XG5cbnZhciBzID0gJyc7XG52YXIgaSA9IC0xO1xud2hpbGUgKCsraSA8IEJOLndvcmRTaXplKSB7XG4gIHplcm9zW2ldID0gcztcbiAgcyArPSAnMCc7XG59XG5ncm91cFNpemVzWzBdID0gMDtcbmdyb3VwU2l6ZXNbMV0gPSAwO1xuZ3JvdXBCYXNlc1swXSA9IDA7XG5ncm91cEJhc2VzWzFdID0gMDtcbnZhciBiYXNlID0gMiAtIDE7XG53aGlsZSAoKytiYXNlIDwgMzYgKyAxKSB7XG4gIHZhciBncm91cFNpemUgPSAwO1xuICB2YXIgZ3JvdXBCYXNlID0gMTtcbiAgd2hpbGUgKGdyb3VwQmFzZSA8ICgxIDw8IEJOLndvcmRTaXplKSAvIGJhc2UpIHtcbiAgICBncm91cEJhc2UgKj0gYmFzZTtcbiAgICBncm91cFNpemUgKz0gMTtcbiAgfVxuICBncm91cFNpemVzW2Jhc2VdID0gZ3JvdXBTaXplO1xuICBncm91cEJhc2VzW2Jhc2VdID0gZ3JvdXBCYXNlO1xufVxuXG4qL1xuXG52YXIgemVyb3MgPSBbXG4gICcnLFxuICAnMCcsXG4gICcwMCcsXG4gICcwMDAnLFxuICAnMDAwMCcsXG4gICcwMDAwMCcsXG4gICcwMDAwMDAnLFxuICAnMDAwMDAwMCcsXG4gICcwMDAwMDAwMCcsXG4gICcwMDAwMDAwMDAnLFxuICAnMDAwMDAwMDAwMCcsXG4gICcwMDAwMDAwMDAwMCcsXG4gICcwMDAwMDAwMDAwMDAnLFxuICAnMDAwMDAwMDAwMDAwMCcsXG4gICcwMDAwMDAwMDAwMDAwMCcsXG4gICcwMDAwMDAwMDAwMDAwMDAnLFxuICAnMDAwMDAwMDAwMDAwMDAwMCcsXG4gICcwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICcwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAnMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICcwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCdcbl07XG5cbnZhciBncm91cFNpemVzID0gW1xuICAwLCAwLFxuICAyNSwgMTYsIDEyLCAxMSwgMTAsIDksIDgsXG4gIDgsIDcsIDcsIDcsIDcsIDYsIDYsXG4gIDYsIDYsIDYsIDYsIDYsIDUsIDUsXG4gIDUsIDUsIDUsIDUsIDUsIDUsIDUsXG4gIDUsIDUsIDUsIDUsIDUsIDUsIDVcbl07XG5cbnZhciBncm91cEJhc2VzID0gW1xuICAwLCAwLFxuICAzMzU1NDQzMiwgNDMwNDY3MjEsIDE2Nzc3MjE2LCA0ODgyODEyNSwgNjA0NjYxNzYsIDQwMzUzNjA3LCAxNjc3NzIxNixcbiAgNDMwNDY3MjEsIDEwMDAwMDAwLCAxOTQ4NzE3MSwgMzU4MzE4MDgsIDYyNzQ4NTE3LCA3NTI5NTM2LCAxMTM5MDYyNSxcbiAgMTY3NzcyMTYsIDI0MTM3NTY5LCAzNDAxMjIyNCwgNDcwNDU4ODEsIDY0MDAwMDAwLCA0MDg0MTAxLCA1MTUzNjMyLFxuICA2NDM2MzQzLCA3OTYyNjI0LCA5NzY1NjI1LCAxMTg4MTM3NiwgMTQzNDg5MDcsIDE3MjEwMzY4LCAyMDUxMTE0OSxcbiAgMjQzMDAwMDAsIDI4NjI5MTUxLCAzMzU1NDQzMiwgMzkxMzUzOTMsIDQ1NDM1NDI0LCA1MjUyMTg3NSwgNjA0NjYxNzZcbl07XG5cbkJOLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKGJhc2UsIHBhZGRpbmcpIHtcbiAgYmFzZSA9IGJhc2UgfHwgMTA7XG4gIHZhciBwYWRkaW5nID0gcGFkZGluZyB8IDAgfHwgMTtcbiAgaWYgKGJhc2UgPT09IDE2IHx8IGJhc2UgPT09ICdoZXgnKSB7XG4gICAgdmFyIG91dCA9ICcnO1xuICAgIHZhciBvZmYgPSAwO1xuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdyA9IHRoaXMud29yZHNbaV07XG4gICAgICB2YXIgd29yZCA9ICgoKHcgPDwgb2ZmKSB8IGNhcnJ5KSAmIDB4ZmZmZmZmKS50b1N0cmluZygxNik7XG4gICAgICBjYXJyeSA9ICh3ID4+PiAoMjQgLSBvZmYpKSAmIDB4ZmZmZmZmO1xuICAgICAgaWYgKGNhcnJ5ICE9PSAwIHx8IGkgIT09IHRoaXMubGVuZ3RoIC0gMSlcbiAgICAgICAgb3V0ID0gemVyb3NbNiAtIHdvcmQubGVuZ3RoXSArIHdvcmQgKyBvdXQ7XG4gICAgICBlbHNlXG4gICAgICAgIG91dCA9IHdvcmQgKyBvdXQ7XG4gICAgICBvZmYgKz0gMjtcbiAgICAgIGlmIChvZmYgPj0gMjYpIHtcbiAgICAgICAgb2ZmIC09IDI2O1xuICAgICAgICBpLS07XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjYXJyeSAhPT0gMClcbiAgICAgIG91dCA9IGNhcnJ5LnRvU3RyaW5nKDE2KSArIG91dDtcbiAgICB3aGlsZSAob3V0Lmxlbmd0aCAlIHBhZGRpbmcgIT09IDApXG4gICAgICBvdXQgPSAnMCcgKyBvdXQ7XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApXG4gICAgICBvdXQgPSAnLScgKyBvdXQ7XG4gICAgcmV0dXJuIG91dDtcbiAgfSBlbHNlIGlmIChiYXNlID09PSAoYmFzZSB8IDApICYmIGJhc2UgPj0gMiAmJiBiYXNlIDw9IDM2KSB7XG4gICAgLy8gdmFyIGdyb3VwU2l6ZSA9IE1hdGguZmxvb3IoQk4ud29yZFNpemUgKiBNYXRoLkxOMiAvIE1hdGgubG9nKGJhc2UpKTtcbiAgICB2YXIgZ3JvdXBTaXplID0gZ3JvdXBTaXplc1tiYXNlXTtcbiAgICAvLyB2YXIgZ3JvdXBCYXNlID0gTWF0aC5wb3coYmFzZSwgZ3JvdXBTaXplKTtcbiAgICB2YXIgZ3JvdXBCYXNlID0gZ3JvdXBCYXNlc1tiYXNlXTtcbiAgICB2YXIgb3V0ID0gJyc7XG4gICAgdmFyIGMgPSB0aGlzLmNsb25lKCk7XG4gICAgYy5uZWdhdGl2ZSA9IDA7XG4gICAgd2hpbGUgKGMuY21wbigwKSAhPT0gMCkge1xuICAgICAgdmFyIHIgPSBjLm1vZG4oZ3JvdXBCYXNlKS50b1N0cmluZyhiYXNlKTtcbiAgICAgIGMgPSBjLmlkaXZuKGdyb3VwQmFzZSk7XG5cbiAgICAgIGlmIChjLmNtcG4oMCkgIT09IDApXG4gICAgICAgIG91dCA9IHplcm9zW2dyb3VwU2l6ZSAtIHIubGVuZ3RoXSArIHIgKyBvdXQ7XG4gICAgICBlbHNlXG4gICAgICAgIG91dCA9IHIgKyBvdXQ7XG4gICAgfVxuICAgIGlmICh0aGlzLmNtcG4oMCkgPT09IDApXG4gICAgICBvdXQgPSAnMCcgKyBvdXQ7XG4gICAgd2hpbGUgKG91dC5sZW5ndGggJSBwYWRkaW5nICE9PSAwKVxuICAgICAgb3V0ID0gJzAnICsgb3V0O1xuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKVxuICAgICAgb3V0ID0gJy0nICsgb3V0O1xuICAgIHJldHVybiBvdXQ7XG4gIH0gZWxzZSB7XG4gICAgYXNzZXJ0KGZhbHNlLCAnQmFzZSBzaG91bGQgYmUgYmV0d2VlbiAyIGFuZCAzNicpO1xuICB9XG59O1xuXG5CTi5wcm90b3R5cGUudG9OdW1iZXIgPSBmdW5jdGlvbiB0b051bWJlcigpIHtcbiAgYXNzZXJ0KHRoaXMuYml0TGVuZ3RoKCkgPD0gNTMsICdOdW1iZXIgY2FuIG9ubHkgc2FmZWx5IHN0b3JlIHVwIHRvIDUzIGJpdHMnKTtcbiAgcmV0dXJuIHBhcnNlSW50KHRoaXMudG9TdHJpbmcoKSwgMTApO1xufTtcblxuQk4ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgcmV0dXJuIHRoaXMudG9TdHJpbmcoMTYpO1xufTtcblxuQk4ucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiB0b0FycmF5KGVuZGlhbiwgbGVuZ3RoKSB7XG4gIHZhciBieXRlTGVuZ3RoID0gdGhpcy5ieXRlTGVuZ3RoKCk7XG4gIHZhciByZXFMZW5ndGggPSBsZW5ndGggfHwgYnl0ZUxlbmd0aDtcbiAgYXNzZXJ0KGJ5dGVMZW5ndGggPD0gcmVxTGVuZ3RoLCAnYnl0ZSBhcnJheSBsb25nZXIgdGhhbiBkZXNpcmVkIGxlbmd0aCcpO1xuXG4gIHRoaXMuc3RyaXAoKTtcbiAgdmFyIGxpdHRsZUVuZGlhbiA9IGVuZGlhbiA9PT0gJ2xlJztcbiAgdmFyIHJlcyA9IG5ldyBBcnJheShyZXFMZW5ndGgpO1xuXG4gIHZhciBxID0gdGhpcy5jbG9uZSgpO1xuICBpZiAoIWxpdHRsZUVuZGlhbikge1xuICAgIC8vIEFzc3VtZSBiaWctZW5kaWFuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXFMZW5ndGggLSBieXRlTGVuZ3RoOyBpKyspXG4gICAgICByZXNbaV0gPSAwO1xuICAgIGZvciAoaSA9IDA7IHEuY21wbigwKSAhPT0gMDsgaSsrKSB7XG4gICAgICB2YXIgYiA9IHEuYW5kbG4oMHhmZik7XG4gICAgICBxLml1c2hybig4KTtcblxuICAgICAgcmVzW3JlcUxlbmd0aCAtIGkgLSAxXSA9IGI7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSAwOyBxLmNtcG4oMCkgIT09IDA7IGkrKykge1xuICAgICAgdmFyIGIgPSBxLmFuZGxuKDB4ZmYpO1xuICAgICAgcS5pdXNocm4oOCk7XG5cbiAgICAgIHJlc1tpXSA9IGI7XG4gICAgfVxuICAgIGZvciAoOyBpIDwgcmVxTGVuZ3RoOyBpKyspXG4gICAgICByZXNbaV0gPSAwO1xuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cbmlmIChNYXRoLmNsejMyKSB7XG4gIEJOLnByb3RvdHlwZS5fY291bnRCaXRzID0gZnVuY3Rpb24gX2NvdW50Qml0cyh3KSB7XG4gICAgcmV0dXJuIDMyIC0gTWF0aC5jbHozMih3KTtcbiAgfTtcbn0gZWxzZSB7XG4gIEJOLnByb3RvdHlwZS5fY291bnRCaXRzID0gZnVuY3Rpb24gX2NvdW50Qml0cyh3KSB7XG4gICAgdmFyIHQgPSB3O1xuICAgIHZhciByID0gMDtcbiAgICBpZiAodCA+PSAweDEwMDApIHtcbiAgICAgIHIgKz0gMTM7XG4gICAgICB0ID4+Pj0gMTM7XG4gICAgfVxuICAgIGlmICh0ID49IDB4NDApIHtcbiAgICAgIHIgKz0gNztcbiAgICAgIHQgPj4+PSA3O1xuICAgIH1cbiAgICBpZiAodCA+PSAweDgpIHtcbiAgICAgIHIgKz0gNDtcbiAgICAgIHQgPj4+PSA0O1xuICAgIH1cbiAgICBpZiAodCA+PSAweDAyKSB7XG4gICAgICByICs9IDI7XG4gICAgICB0ID4+Pj0gMjtcbiAgICB9XG4gICAgcmV0dXJuIHIgKyB0O1xuICB9O1xufVxuXG5CTi5wcm90b3R5cGUuX3plcm9CaXRzID0gZnVuY3Rpb24gX3plcm9CaXRzKHcpIHtcbiAgLy8gU2hvcnQtY3V0XG4gIGlmICh3ID09PSAwKVxuICAgIHJldHVybiAyNjtcblxuICB2YXIgdCA9IHc7XG4gIHZhciByID0gMDtcbiAgaWYgKCh0ICYgMHgxZmZmKSA9PT0gMCkge1xuICAgIHIgKz0gMTM7XG4gICAgdCA+Pj49IDEzO1xuICB9XG4gIGlmICgodCAmIDB4N2YpID09PSAwKSB7XG4gICAgciArPSA3O1xuICAgIHQgPj4+PSA3O1xuICB9XG4gIGlmICgodCAmIDB4ZikgPT09IDApIHtcbiAgICByICs9IDQ7XG4gICAgdCA+Pj49IDQ7XG4gIH1cbiAgaWYgKCh0ICYgMHgzKSA9PT0gMCkge1xuICAgIHIgKz0gMjtcbiAgICB0ID4+Pj0gMjtcbiAgfVxuICBpZiAoKHQgJiAweDEpID09PSAwKVxuICAgIHIrKztcbiAgcmV0dXJuIHI7XG59O1xuXG4vLyBSZXR1cm4gbnVtYmVyIG9mIHVzZWQgYml0cyBpbiBhIEJOXG5CTi5wcm90b3R5cGUuYml0TGVuZ3RoID0gZnVuY3Rpb24gYml0TGVuZ3RoKCkge1xuICB2YXIgaGkgPSAwO1xuICB2YXIgdyA9IHRoaXMud29yZHNbdGhpcy5sZW5ndGggLSAxXTtcbiAgdmFyIGhpID0gdGhpcy5fY291bnRCaXRzKHcpO1xuICByZXR1cm4gKHRoaXMubGVuZ3RoIC0gMSkgKiAyNiArIGhpO1xufTtcblxuZnVuY3Rpb24gdG9CaXRBcnJheShudW0pIHtcbiAgdmFyIHcgPSBuZXcgQXJyYXkobnVtLmJpdExlbmd0aCgpKTtcblxuICBmb3IgKHZhciBiaXQgPSAwOyBiaXQgPCB3Lmxlbmd0aDsgYml0KyspIHtcbiAgICB2YXIgb2ZmID0gKGJpdCAvIDI2KSB8IDA7XG4gICAgdmFyIHdiaXQgPSBiaXQgJSAyNjtcblxuICAgIHdbYml0XSA9IChudW0ud29yZHNbb2ZmXSAmICgxIDw8IHdiaXQpKSA+Pj4gd2JpdDtcbiAgfVxuXG4gIHJldHVybiB3O1xufVxuXG4vLyBOdW1iZXIgb2YgdHJhaWxpbmcgemVybyBiaXRzXG5CTi5wcm90b3R5cGUuemVyb0JpdHMgPSBmdW5jdGlvbiB6ZXJvQml0cygpIHtcbiAgaWYgKHRoaXMuY21wbigwKSA9PT0gMClcbiAgICByZXR1cm4gMDtcblxuICB2YXIgciA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBiID0gdGhpcy5femVyb0JpdHModGhpcy53b3Jkc1tpXSk7XG4gICAgciArPSBiO1xuICAgIGlmIChiICE9PSAyNilcbiAgICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiByO1xufTtcblxuQk4ucHJvdG90eXBlLmJ5dGVMZW5ndGggPSBmdW5jdGlvbiBieXRlTGVuZ3RoKCkge1xuICByZXR1cm4gTWF0aC5jZWlsKHRoaXMuYml0TGVuZ3RoKCkgLyA4KTtcbn07XG5cbkJOLnByb3RvdHlwZS5pc05lZyA9IGZ1bmN0aW9uIGlzTmVnKCkge1xuICByZXR1cm4gdGhpcy5uZWdhdGl2ZSAhPT0gMDtcbn07XG5cbi8vIFJldHVybiBuZWdhdGl2ZSBjbG9uZSBvZiBgdGhpc2BcbkJOLnByb3RvdHlwZS5uZWcgPSBmdW5jdGlvbiBuZWcoKSB7XG4gIGlmICh0aGlzLmNtcG4oMCkgPT09IDApXG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKTtcblxuICB2YXIgciA9IHRoaXMuY2xvbmUoKTtcbiAgci5uZWdhdGl2ZSA9IHRoaXMubmVnYXRpdmUgXiAxO1xuICByZXR1cm4gcjtcbn07XG5cbkJOLnByb3RvdHlwZS5pbmVnID0gZnVuY3Rpb24gaW5lZygpIHtcbiAgdGhpcy5uZWdhdGl2ZSBePSAxO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIE9yIGBudW1gIHdpdGggYHRoaXNgIGluLXBsYWNlXG5CTi5wcm90b3R5cGUuaXVvciA9IGZ1bmN0aW9uIGl1b3IobnVtKSB7XG4gIHdoaWxlICh0aGlzLmxlbmd0aCA8IG51bS5sZW5ndGgpXG4gICAgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCsrXSA9IDA7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW0ubGVuZ3RoOyBpKyspXG4gICAgdGhpcy53b3Jkc1tpXSA9IHRoaXMud29yZHNbaV0gfCBudW0ud29yZHNbaV07XG5cbiAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbn07XG5cbkJOLnByb3RvdHlwZS5pb3IgPSBmdW5jdGlvbiBpb3IobnVtKSB7XG4gIGFzc2VydCgodGhpcy5uZWdhdGl2ZSB8IG51bS5uZWdhdGl2ZSkgPT09IDApO1xuICByZXR1cm4gdGhpcy5pdW9yKG51bSk7XG59O1xuXG5cbi8vIE9yIGBudW1gIHdpdGggYHRoaXNgXG5CTi5wcm90b3R5cGUub3IgPSBmdW5jdGlvbiBvcihudW0pIHtcbiAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aClcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlvcihudW0pO1xuICBlbHNlXG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLmlvcih0aGlzKTtcbn07XG5cbkJOLnByb3RvdHlwZS51b3IgPSBmdW5jdGlvbiB1b3IobnVtKSB7XG4gIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpXG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pdW9yKG51bSk7XG4gIGVsc2VcbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaXVvcih0aGlzKTtcbn07XG5cblxuLy8gQW5kIGBudW1gIHdpdGggYHRoaXNgIGluLXBsYWNlXG5CTi5wcm90b3R5cGUuaXVhbmQgPSBmdW5jdGlvbiBpdWFuZChudW0pIHtcbiAgLy8gYiA9IG1pbi1sZW5ndGgobnVtLCB0aGlzKVxuICB2YXIgYjtcbiAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aClcbiAgICBiID0gbnVtO1xuICBlbHNlXG4gICAgYiA9IHRoaXM7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKVxuICAgIHRoaXMud29yZHNbaV0gPSB0aGlzLndvcmRzW2ldICYgbnVtLndvcmRzW2ldO1xuXG4gIHRoaXMubGVuZ3RoID0gYi5sZW5ndGg7XG5cbiAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbn07XG5cbkJOLnByb3RvdHlwZS5pYW5kID0gZnVuY3Rpb24gaWFuZChudW0pIHtcbiAgYXNzZXJ0KCh0aGlzLm5lZ2F0aXZlIHwgbnVtLm5lZ2F0aXZlKSA9PT0gMCk7XG4gIHJldHVybiB0aGlzLml1YW5kKG51bSk7XG59O1xuXG5cbi8vIEFuZCBgbnVtYCB3aXRoIGB0aGlzYFxuQk4ucHJvdG90eXBlLmFuZCA9IGZ1bmN0aW9uIGFuZChudW0pIHtcbiAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aClcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlhbmQobnVtKTtcbiAgZWxzZVxuICAgIHJldHVybiBudW0uY2xvbmUoKS5pYW5kKHRoaXMpO1xufTtcblxuQk4ucHJvdG90eXBlLnVhbmQgPSBmdW5jdGlvbiB1YW5kKG51bSkge1xuICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKVxuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXVhbmQobnVtKTtcbiAgZWxzZVxuICAgIHJldHVybiBudW0uY2xvbmUoKS5pdWFuZCh0aGlzKTtcbn07XG5cblxuLy8gWG9yIGBudW1gIHdpdGggYHRoaXNgIGluLXBsYWNlXG5CTi5wcm90b3R5cGUuaXV4b3IgPSBmdW5jdGlvbiBpdXhvcihudW0pIHtcbiAgLy8gYS5sZW5ndGggPiBiLmxlbmd0aFxuICB2YXIgYTtcbiAgdmFyIGI7XG4gIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHtcbiAgICBhID0gdGhpcztcbiAgICBiID0gbnVtO1xuICB9IGVsc2Uge1xuICAgIGEgPSBudW07XG4gICAgYiA9IHRoaXM7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspXG4gICAgdGhpcy53b3Jkc1tpXSA9IGEud29yZHNbaV0gXiBiLndvcmRzW2ldO1xuXG4gIGlmICh0aGlzICE9PSBhKVxuICAgIGZvciAoOyBpIDwgYS5sZW5ndGg7IGkrKylcbiAgICAgIHRoaXMud29yZHNbaV0gPSBhLndvcmRzW2ldO1xuXG4gIHRoaXMubGVuZ3RoID0gYS5sZW5ndGg7XG5cbiAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbn07XG5cbkJOLnByb3RvdHlwZS5peG9yID0gZnVuY3Rpb24gaXhvcihudW0pIHtcbiAgYXNzZXJ0KCh0aGlzLm5lZ2F0aXZlIHwgbnVtLm5lZ2F0aXZlKSA9PT0gMCk7XG4gIHJldHVybiB0aGlzLml1eG9yKG51bSk7XG59O1xuXG5cbi8vIFhvciBgbnVtYCB3aXRoIGB0aGlzYFxuQk4ucHJvdG90eXBlLnhvciA9IGZ1bmN0aW9uIHhvcihudW0pIHtcbiAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aClcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLml4b3IobnVtKTtcbiAgZWxzZVxuICAgIHJldHVybiBudW0uY2xvbmUoKS5peG9yKHRoaXMpO1xufTtcblxuQk4ucHJvdG90eXBlLnV4b3IgPSBmdW5jdGlvbiB1eG9yKG51bSkge1xuICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKVxuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXV4b3IobnVtKTtcbiAgZWxzZVxuICAgIHJldHVybiBudW0uY2xvbmUoKS5pdXhvcih0aGlzKTtcbn07XG5cblxuLy8gU2V0IGBiaXRgIG9mIGB0aGlzYFxuQk4ucHJvdG90eXBlLnNldG4gPSBmdW5jdGlvbiBzZXRuKGJpdCwgdmFsKSB7XG4gIGFzc2VydCh0eXBlb2YgYml0ID09PSAnbnVtYmVyJyAmJiBiaXQgPj0gMCk7XG5cbiAgdmFyIG9mZiA9IChiaXQgLyAyNikgfCAwO1xuICB2YXIgd2JpdCA9IGJpdCAlIDI2O1xuXG4gIHdoaWxlICh0aGlzLmxlbmd0aCA8PSBvZmYpXG4gICAgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCsrXSA9IDA7XG5cbiAgaWYgKHZhbClcbiAgICB0aGlzLndvcmRzW29mZl0gPSB0aGlzLndvcmRzW29mZl0gfCAoMSA8PCB3Yml0KTtcbiAgZWxzZVxuICAgIHRoaXMud29yZHNbb2ZmXSA9IHRoaXMud29yZHNbb2ZmXSAmIH4oMSA8PCB3Yml0KTtcblxuICByZXR1cm4gdGhpcy5zdHJpcCgpO1xufTtcblxuXG4vLyBBZGQgYG51bWAgdG8gYHRoaXNgIGluLXBsYWNlXG5CTi5wcm90b3R5cGUuaWFkZCA9IGZ1bmN0aW9uIGlhZGQobnVtKSB7XG4gIC8vIG5lZ2F0aXZlICsgcG9zaXRpdmVcbiAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDAgJiYgbnVtLm5lZ2F0aXZlID09PSAwKSB7XG4gICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgdmFyIHIgPSB0aGlzLmlzdWIobnVtKTtcbiAgICB0aGlzLm5lZ2F0aXZlIF49IDE7XG4gICAgcmV0dXJuIHRoaXMuX25vcm1TaWduKCk7XG5cbiAgLy8gcG9zaXRpdmUgKyBuZWdhdGl2ZVxuICB9IGVsc2UgaWYgKHRoaXMubmVnYXRpdmUgPT09IDAgJiYgbnVtLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgbnVtLm5lZ2F0aXZlID0gMDtcbiAgICB2YXIgciA9IHRoaXMuaXN1YihudW0pO1xuICAgIG51bS5uZWdhdGl2ZSA9IDE7XG4gICAgcmV0dXJuIHIuX25vcm1TaWduKCk7XG4gIH1cblxuICAvLyBhLmxlbmd0aCA+IGIubGVuZ3RoXG4gIHZhciBhO1xuICB2YXIgYjtcbiAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkge1xuICAgIGEgPSB0aGlzO1xuICAgIGIgPSBudW07XG4gIH0gZWxzZSB7XG4gICAgYSA9IG51bTtcbiAgICBiID0gdGhpcztcbiAgfVxuXG4gIHZhciBjYXJyeSA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xuICAgIHZhciByID0gKGEud29yZHNbaV0gfCAwKSArIChiLndvcmRzW2ldIHwgMCkgKyBjYXJyeTtcbiAgICB0aGlzLndvcmRzW2ldID0gciAmIDB4M2ZmZmZmZjtcbiAgICBjYXJyeSA9IHIgPj4+IDI2O1xuICB9XG4gIGZvciAoOyBjYXJyeSAhPT0gMCAmJiBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgIHZhciByID0gKGEud29yZHNbaV0gfCAwKSArIGNhcnJ5O1xuICAgIHRoaXMud29yZHNbaV0gPSByICYgMHgzZmZmZmZmO1xuICAgIGNhcnJ5ID0gciA+Pj4gMjY7XG4gIH1cblxuICB0aGlzLmxlbmd0aCA9IGEubGVuZ3RoO1xuICBpZiAoY2FycnkgIT09IDApIHtcbiAgICB0aGlzLndvcmRzW3RoaXMubGVuZ3RoXSA9IGNhcnJ5O1xuICAgIHRoaXMubGVuZ3RoKys7XG4gIC8vIENvcHkgdGhlIHJlc3Qgb2YgdGhlIHdvcmRzXG4gIH0gZWxzZSBpZiAoYSAhPT0gdGhpcykge1xuICAgIGZvciAoOyBpIDwgYS5sZW5ndGg7IGkrKylcbiAgICAgIHRoaXMud29yZHNbaV0gPSBhLndvcmRzW2ldO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBBZGQgYG51bWAgdG8gYHRoaXNgXG5CTi5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKG51bSkge1xuICBpZiAobnVtLm5lZ2F0aXZlICE9PSAwICYmIHRoaXMubmVnYXRpdmUgPT09IDApIHtcbiAgICBudW0ubmVnYXRpdmUgPSAwO1xuICAgIHZhciByZXMgPSB0aGlzLnN1YihudW0pO1xuICAgIG51bS5uZWdhdGl2ZSBePSAxO1xuICAgIHJldHVybiByZXM7XG4gIH0gZWxzZSBpZiAobnVtLm5lZ2F0aXZlID09PSAwICYmIHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICB2YXIgcmVzID0gbnVtLnN1Yih0aGlzKTtcbiAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICByZXR1cm4gcmVzO1xuICB9XG5cbiAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aClcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlhZGQobnVtKTtcbiAgZWxzZVxuICAgIHJldHVybiBudW0uY2xvbmUoKS5pYWRkKHRoaXMpO1xufTtcblxuLy8gU3VidHJhY3QgYG51bWAgZnJvbSBgdGhpc2AgaW4tcGxhY2VcbkJOLnByb3RvdHlwZS5pc3ViID0gZnVuY3Rpb24gaXN1YihudW0pIHtcbiAgLy8gdGhpcyAtICgtbnVtKSA9IHRoaXMgKyBudW1cbiAgaWYgKG51bS5uZWdhdGl2ZSAhPT0gMCkge1xuICAgIG51bS5uZWdhdGl2ZSA9IDA7XG4gICAgdmFyIHIgPSB0aGlzLmlhZGQobnVtKTtcbiAgICBudW0ubmVnYXRpdmUgPSAxO1xuICAgIHJldHVybiByLl9ub3JtU2lnbigpO1xuXG4gIC8vIC10aGlzIC0gbnVtID0gLSh0aGlzICsgbnVtKVxuICB9IGVsc2UgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICB0aGlzLmlhZGQobnVtKTtcbiAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICByZXR1cm4gdGhpcy5fbm9ybVNpZ24oKTtcbiAgfVxuXG4gIC8vIEF0IHRoaXMgcG9pbnQgYm90aCBudW1iZXJzIGFyZSBwb3NpdGl2ZVxuICB2YXIgY21wID0gdGhpcy5jbXAobnVtKTtcblxuICAvLyBPcHRpbWl6YXRpb24gLSB6ZXJvaWZ5XG4gIGlmIChjbXAgPT09IDApIHtcbiAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgdGhpcy53b3Jkc1swXSA9IDA7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBhID4gYlxuICB2YXIgYTtcbiAgdmFyIGI7XG4gIGlmIChjbXAgPiAwKSB7XG4gICAgYSA9IHRoaXM7XG4gICAgYiA9IG51bTtcbiAgfSBlbHNlIHtcbiAgICBhID0gbnVtO1xuICAgIGIgPSB0aGlzO1xuICB9XG5cbiAgdmFyIGNhcnJ5ID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHIgPSAoYS53b3Jkc1tpXSB8IDApIC0gKGIud29yZHNbaV0gfCAwKSArIGNhcnJ5O1xuICAgIGNhcnJ5ID0gciA+PiAyNjtcbiAgICB0aGlzLndvcmRzW2ldID0gciAmIDB4M2ZmZmZmZjtcbiAgfVxuICBmb3IgKDsgY2FycnkgIT09IDAgJiYgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgciA9IChhLndvcmRzW2ldIHwgMCkgKyBjYXJyeTtcbiAgICBjYXJyeSA9IHIgPj4gMjY7XG4gICAgdGhpcy53b3Jkc1tpXSA9IHIgJiAweDNmZmZmZmY7XG4gIH1cblxuICAvLyBDb3B5IHJlc3Qgb2YgdGhlIHdvcmRzXG4gIGlmIChjYXJyeSA9PT0gMCAmJiBpIDwgYS5sZW5ndGggJiYgYSAhPT0gdGhpcylcbiAgICBmb3IgKDsgaSA8IGEubGVuZ3RoOyBpKyspXG4gICAgICB0aGlzLndvcmRzW2ldID0gYS53b3Jkc1tpXTtcbiAgdGhpcy5sZW5ndGggPSBNYXRoLm1heCh0aGlzLmxlbmd0aCwgaSk7XG5cbiAgaWYgKGEgIT09IHRoaXMpXG4gICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG5cbiAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbn07XG5cbi8vIFN1YnRyYWN0IGBudW1gIGZyb20gYHRoaXNgXG5CTi5wcm90b3R5cGUuc3ViID0gZnVuY3Rpb24gc3ViKG51bSkge1xuICByZXR1cm4gdGhpcy5jbG9uZSgpLmlzdWIobnVtKTtcbn07XG5cbi8qXG4vLyBOT1RFOiBUaGlzIGNvdWxkIGJlIHBvdGVudGlvbmFsbHkgdXNlZCB0byBnZW5lcmF0ZSBsb29wLWxlc3MgbXVsdGlwbGljYXRpb25zXG5mdW5jdGlvbiBfZ2VuQ29tYk11bFRvKGFsZW4sIGJsZW4pIHtcbiAgdmFyIGxlbiA9IGFsZW4gKyBibGVuIC0gMTtcbiAgdmFyIHNyYyA9IFtcbiAgICAndmFyIGEgPSBzZWxmLndvcmRzOycsXG4gICAgJ3ZhciBiID0gbnVtLndvcmRzOycsXG4gICAgJ3ZhciBvID0gb3V0LndvcmRzOycsXG4gICAgJ3ZhciBjID0gMDsnLFxuICAgICd2YXIgbG87JyxcbiAgICAndmFyIG1pZDsnLFxuICAgICd2YXIgaGk7J1xuICBdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFsZW47IGkrKykge1xuICAgIHNyYy5wdXNoKCd2YXIgYScgKyBpICsgJyA9IGFbJyArIGkgKyAnXSB8IDA7Jyk7XG4gICAgc3JjLnB1c2goJ3ZhciBhbCcgKyBpICsgJyA9IGEnICsgaSArICcgJiAweDFmZmY7Jyk7XG4gICAgc3JjLnB1c2goJ3ZhciBhaCcgKyBpICsgJyA9IGEnICsgaSArICcgPj4+IDEzOycpO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYmxlbjsgaSsrKSB7XG4gICAgc3JjLnB1c2goJ3ZhciBiJyArIGkgKyAnID0gYlsnICsgaSArICddIHwgMDsnKTtcbiAgICBzcmMucHVzaCgndmFyIGJsJyArIGkgKyAnID0gYicgKyBpICsgJyAmIDB4MWZmZjsnKTtcbiAgICBzcmMucHVzaCgndmFyIGJoJyArIGkgKyAnID0gYicgKyBpICsgJyA+Pj4gMTM7Jyk7XG4gIH1cbiAgc3JjLnB1c2goJycpO1xuICBzcmMucHVzaCgnb3V0Lmxlbmd0aCA9ICcgKyBsZW4gKyAnOycpO1xuXG4gIGZvciAodmFyIGsgPSAwOyBrIDwgbGVuOyBrKyspIHtcbiAgICB2YXIgbWluSiA9IE1hdGgubWF4KDAsIGsgLSBhbGVuICsgMSk7XG4gICAgdmFyIG1heEogPSBNYXRoLm1pbihrLCBibGVuIC0gMSk7XG5cbiAgICBzcmMucHVzaCgnXFwvKiBrID0gJyArIGsgKyAnICpcXC8nKTtcbiAgICBzcmMucHVzaCgndmFyIHcnICsgayArICcgPSBjOycpO1xuICAgIHNyYy5wdXNoKCdjID0gMDsnKTtcbiAgICBmb3IgKHZhciBqID0gbWluSjsgaiA8PSBtYXhKOyBqKyspIHtcbiAgICAgIHZhciBpID0gayAtIGo7XG5cbiAgICAgIHNyYy5wdXNoKCdsbyA9IE1hdGguaW11bChhbCcgKyBpICsgJywgYmwnICsgaiArICcpOycpO1xuICAgICAgc3JjLnB1c2goJ21pZCA9IE1hdGguaW11bChhbCcgKyBpICsgJywgYmgnICsgaiArICcpOycpO1xuICAgICAgc3JjLnB1c2goJ21pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgnICsgaSArICcsIGJsJyArIGogKyAnKSkgfCAwOycpO1xuICAgICAgc3JjLnB1c2goJ2hpID0gTWF0aC5pbXVsKGFoJyArIGkgKyAnLCBiaCcgKyBqICsgJyk7Jyk7XG5cbiAgICAgIHNyYy5wdXNoKCd3JyArIGsgKyAnID0gKHcnICsgayArICcgKyBsbykgfCAwOycpO1xuICAgICAgc3JjLnB1c2goJ3cnICsgayArICcgPSAodycgKyBrICsgJyArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDsnKTtcbiAgICAgIHNyYy5wdXNoKCdjID0gKGMgKyBoaSkgfCAwOycpO1xuICAgICAgc3JjLnB1c2goJ2MgPSAoYyArIChtaWQgPj4+IDEzKSkgfCAwOycpO1xuICAgICAgc3JjLnB1c2goJ2MgPSAoYyArICh3JyArIGsgKyAnID4+PiAyNikpIHwgMDsnKTtcbiAgICAgIHNyYy5wdXNoKCd3JyArIGsgKyAnICY9IDB4M2ZmZmZmZjsnKTtcbiAgICB9XG4gIH1cbiAgLy8gU3RvcmUgaW4gc2VwYXJhdGUgc3RlcCBmb3IgYmV0dGVyIG1lbW9yeSBhY2Nlc3NcbiAgZm9yICh2YXIgayA9IDA7IGsgPCBsZW47IGsrKylcbiAgICBzcmMucHVzaCgnb1snICsgayArICddID0gdycgKyBrICsgJzsnKTtcbiAgc3JjLnB1c2goJ2lmIChjICE9PSAwKSB7JyxcbiAgICAgICAgICAgJyAgb1snICsgayArICddID0gYzsnLFxuICAgICAgICAgICAnICBvdXQubGVuZ3RoKys7JyxcbiAgICAgICAgICAgJ30nLFxuICAgICAgICAgICAncmV0dXJuIG91dDsnKTtcblxuICByZXR1cm4gc3JjLmpvaW4oJ1xcbicpO1xufVxuY29uc29sZS5sb2coX2dlbkNvbWJNdWxUbygxMCwgMTApKTtcbiovXG5cbmZ1bmN0aW9uIHNtYWxsTXVsVG8oc2VsZiwgbnVtLCBvdXQpIHtcbiAgb3V0Lm5lZ2F0aXZlID0gbnVtLm5lZ2F0aXZlIF4gc2VsZi5uZWdhdGl2ZTtcbiAgdmFyIGxlbiA9IChzZWxmLmxlbmd0aCArIG51bS5sZW5ndGgpIHwgMDtcbiAgb3V0Lmxlbmd0aCA9IGxlbjtcbiAgbGVuID0gKGxlbiAtIDEpIHwgMDtcblxuICAvLyBQZWVsIG9uZSBpdGVyYXRpb24gKGNvbXBpbGVyIGNhbid0IGRvIGl0LCBiZWNhdXNlIG9mIGNvZGUgY29tcGxleGl0eSlcbiAgdmFyIGEgPSBzZWxmLndvcmRzWzBdIHwgMDtcbiAgdmFyIGIgPSBudW0ud29yZHNbMF0gfCAwO1xuICB2YXIgciA9IGEgKiBiO1xuXG4gIHZhciBsbyA9IHIgJiAweDNmZmZmZmY7XG4gIHZhciBjYXJyeSA9IChyIC8gMHg0MDAwMDAwKSB8IDA7XG4gIG91dC53b3Jkc1swXSA9IGxvO1xuXG4gIGZvciAodmFyIGsgPSAxOyBrIDwgbGVuOyBrKyspIHtcbiAgICAvLyBTdW0gYWxsIHdvcmRzIHdpdGggdGhlIHNhbWUgYGkgKyBqID0ga2AgYW5kIGFjY3VtdWxhdGUgYG5jYXJyeWAsXG4gICAgLy8gbm90ZSB0aGF0IG5jYXJyeSBjb3VsZCBiZSA+PSAweDNmZmZmZmZcbiAgICB2YXIgbmNhcnJ5ID0gY2FycnkgPj4+IDI2O1xuICAgIHZhciByd29yZCA9IGNhcnJ5ICYgMHgzZmZmZmZmO1xuICAgIHZhciBtYXhKID0gTWF0aC5taW4oaywgbnVtLmxlbmd0aCAtIDEpO1xuICAgIGZvciAodmFyIGogPSBNYXRoLm1heCgwLCBrIC0gc2VsZi5sZW5ndGggKyAxKTsgaiA8PSBtYXhKOyBqKyspIHtcbiAgICAgIHZhciBpID0gKGsgLSBqKSB8IDA7XG4gICAgICB2YXIgYSA9IHNlbGYud29yZHNbaV0gfCAwO1xuICAgICAgdmFyIGIgPSBudW0ud29yZHNbal0gfCAwO1xuICAgICAgdmFyIHIgPSBhICogYjtcblxuICAgICAgdmFyIGxvID0gciAmIDB4M2ZmZmZmZjtcbiAgICAgIG5jYXJyeSA9IChuY2FycnkgKyAoKHIgLyAweDQwMDAwMDApIHwgMCkpIHwgMDtcbiAgICAgIGxvID0gKGxvICsgcndvcmQpIHwgMDtcbiAgICAgIHJ3b3JkID0gbG8gJiAweDNmZmZmZmY7XG4gICAgICBuY2FycnkgPSAobmNhcnJ5ICsgKGxvID4+PiAyNikpIHwgMDtcbiAgICB9XG4gICAgb3V0LndvcmRzW2tdID0gcndvcmQgfCAwO1xuICAgIGNhcnJ5ID0gbmNhcnJ5IHwgMDtcbiAgfVxuICBpZiAoY2FycnkgIT09IDApIHtcbiAgICBvdXQud29yZHNba10gPSBjYXJyeSB8IDA7XG4gIH0gZWxzZSB7XG4gICAgb3V0Lmxlbmd0aC0tO1xuICB9XG5cbiAgcmV0dXJuIG91dC5zdHJpcCgpO1xufVxuXG4vLyBUT0RPKGluZHV0bnkpOiBpdCBtYXkgYmUgcmVhc29uYWJsZSB0byBvbWl0IGl0IGZvciB1c2VycyB3aG8gZG9uJ3QgbmVlZFxuLy8gdG8gd29yayB3aXRoIDI1Ni1iaXQgbnVtYmVycywgb3RoZXJ3aXNlIGl0IGdpdmVzIDIwJSBpbXByb3ZlbWVudCBmb3IgMjU2LWJpdFxuLy8gbXVsdGlwbGljYXRpb24gKGxpa2UgZWxsaXB0aWMgc2VjcDI1NmsxKS5cbnZhciBjb21iMTBNdWxUbyA9IGZ1bmN0aW9uIGNvbWIxME11bFRvKHNlbGYsIG51bSwgb3V0KSB7XG4gIHZhciBhID0gc2VsZi53b3JkcztcbiAgdmFyIGIgPSBudW0ud29yZHM7XG4gIHZhciBvID0gb3V0LndvcmRzO1xuICB2YXIgYyA9IDA7XG4gIHZhciBsbztcbiAgdmFyIG1pZDtcbiAgdmFyIGhpO1xuICB2YXIgYTAgPSBhWzBdIHwgMDtcbiAgdmFyIGFsMCA9IGEwICYgMHgxZmZmO1xuICB2YXIgYWgwID0gYTAgPj4+IDEzO1xuICB2YXIgYTEgPSBhWzFdIHwgMDtcbiAgdmFyIGFsMSA9IGExICYgMHgxZmZmO1xuICB2YXIgYWgxID0gYTEgPj4+IDEzO1xuICB2YXIgYTIgPSBhWzJdIHwgMDtcbiAgdmFyIGFsMiA9IGEyICYgMHgxZmZmO1xuICB2YXIgYWgyID0gYTIgPj4+IDEzO1xuICB2YXIgYTMgPSBhWzNdIHwgMDtcbiAgdmFyIGFsMyA9IGEzICYgMHgxZmZmO1xuICB2YXIgYWgzID0gYTMgPj4+IDEzO1xuICB2YXIgYTQgPSBhWzRdIHwgMDtcbiAgdmFyIGFsNCA9IGE0ICYgMHgxZmZmO1xuICB2YXIgYWg0ID0gYTQgPj4+IDEzO1xuICB2YXIgYTUgPSBhWzVdIHwgMDtcbiAgdmFyIGFsNSA9IGE1ICYgMHgxZmZmO1xuICB2YXIgYWg1ID0gYTUgPj4+IDEzO1xuICB2YXIgYTYgPSBhWzZdIHwgMDtcbiAgdmFyIGFsNiA9IGE2ICYgMHgxZmZmO1xuICB2YXIgYWg2ID0gYTYgPj4+IDEzO1xuICB2YXIgYTcgPSBhWzddIHwgMDtcbiAgdmFyIGFsNyA9IGE3ICYgMHgxZmZmO1xuICB2YXIgYWg3ID0gYTcgPj4+IDEzO1xuICB2YXIgYTggPSBhWzhdIHwgMDtcbiAgdmFyIGFsOCA9IGE4ICYgMHgxZmZmO1xuICB2YXIgYWg4ID0gYTggPj4+IDEzO1xuICB2YXIgYTkgPSBhWzldIHwgMDtcbiAgdmFyIGFsOSA9IGE5ICYgMHgxZmZmO1xuICB2YXIgYWg5ID0gYTkgPj4+IDEzO1xuICB2YXIgYjAgPSBiWzBdIHwgMDtcbiAgdmFyIGJsMCA9IGIwICYgMHgxZmZmO1xuICB2YXIgYmgwID0gYjAgPj4+IDEzO1xuICB2YXIgYjEgPSBiWzFdIHwgMDtcbiAgdmFyIGJsMSA9IGIxICYgMHgxZmZmO1xuICB2YXIgYmgxID0gYjEgPj4+IDEzO1xuICB2YXIgYjIgPSBiWzJdIHwgMDtcbiAgdmFyIGJsMiA9IGIyICYgMHgxZmZmO1xuICB2YXIgYmgyID0gYjIgPj4+IDEzO1xuICB2YXIgYjMgPSBiWzNdIHwgMDtcbiAgdmFyIGJsMyA9IGIzICYgMHgxZmZmO1xuICB2YXIgYmgzID0gYjMgPj4+IDEzO1xuICB2YXIgYjQgPSBiWzRdIHwgMDtcbiAgdmFyIGJsNCA9IGI0ICYgMHgxZmZmO1xuICB2YXIgYmg0ID0gYjQgPj4+IDEzO1xuICB2YXIgYjUgPSBiWzVdIHwgMDtcbiAgdmFyIGJsNSA9IGI1ICYgMHgxZmZmO1xuICB2YXIgYmg1ID0gYjUgPj4+IDEzO1xuICB2YXIgYjYgPSBiWzZdIHwgMDtcbiAgdmFyIGJsNiA9IGI2ICYgMHgxZmZmO1xuICB2YXIgYmg2ID0gYjYgPj4+IDEzO1xuICB2YXIgYjcgPSBiWzddIHwgMDtcbiAgdmFyIGJsNyA9IGI3ICYgMHgxZmZmO1xuICB2YXIgYmg3ID0gYjcgPj4+IDEzO1xuICB2YXIgYjggPSBiWzhdIHwgMDtcbiAgdmFyIGJsOCA9IGI4ICYgMHgxZmZmO1xuICB2YXIgYmg4ID0gYjggPj4+IDEzO1xuICB2YXIgYjkgPSBiWzldIHwgMDtcbiAgdmFyIGJsOSA9IGI5ICYgMHgxZmZmO1xuICB2YXIgYmg5ID0gYjkgPj4+IDEzO1xuXG4gIG91dC5sZW5ndGggPSAxOTtcbiAgLyogayA9IDAgKi9cbiAgdmFyIHcwID0gYztcbiAgYyA9IDA7XG4gIGxvID0gTWF0aC5pbXVsKGFsMCwgYmwwKTtcbiAgbWlkID0gTWF0aC5pbXVsKGFsMCwgYmgwKTtcbiAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsMCkpIHwgMDtcbiAgaGkgPSBNYXRoLmltdWwoYWgwLCBiaDApO1xuICB3MCA9ICh3MCArIGxvKSB8IDA7XG4gIHcwID0gKHcwICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICBjID0gKGMgKyBoaSkgfCAwO1xuICBjID0gKGMgKyAobWlkID4+PiAxMykpIHwgMDtcbiAgYyA9IChjICsgKHcwID4+PiAyNikpIHwgMDtcbiAgdzAgJj0gMHgzZmZmZmZmO1xuICAvKiBrID0gMSAqL1xuICB2YXIgdzEgPSBjO1xuICBjID0gMDtcbiAgbG8gPSBNYXRoLmltdWwoYWwxLCBibDApO1xuICBtaWQgPSBNYXRoLmltdWwoYWwxLCBiaDApO1xuICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmwwKSkgfCAwO1xuICBoaSA9IE1hdGguaW11bChhaDEsIGJoMCk7XG4gIHcxID0gKHcxICsgbG8pIHwgMDtcbiAgdzEgPSAodzEgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gIGMgPSAoYyArIGhpKSB8IDA7XG4gIGMgPSAoYyArIChtaWQgPj4+IDEzKSkgfCAwO1xuICBjID0gKGMgKyAodzEgPj4+IDI2KSkgfCAwO1xuICB3MSAmPSAweDNmZmZmZmY7XG4gIGxvID0gTWF0aC5pbXVsKGFsMCwgYmwxKTtcbiAgbWlkID0gTWF0aC5pbXVsKGFsMCwgYmgxKTtcbiAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsMSkpIHwgMDtcbiAgaGkgPSBNYXRoLmltdWwoYWgwLCBiaDEpO1xuICB3MSA9ICh3MSArIGxvKSB8IDA7XG4gIHcxID0gKHcxICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICBjID0gKGMgKyBoaSkgfCAwO1xuICBjID0gKGMgKyAobWlkID4+PiAxMykpIHwgMDtcbiAgYyA9IChjICsgKHcxID4+PiAyNikpIHwgMDtcbiAgdzEgJj0gMHgzZmZmZmZmO1xuICAvKiBrID0gMiAqL1xuICB2YXIgdzIgPSBjO1xuICBjID0gMDtcbiAgbG8gPSBNYXRoLmltdWwoYWwyLCBibDApO1xuICBtaWQgPSBNYXRoLmltdWwoYWwyLCBiaDApO1xuICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmwwKSkgfCAwO1xuICBoaSA9IE1hdGguaW11bChhaDIsIGJoMCk7XG4gIHcyID0gKHcyICsgbG8pIHwgMDtcbiAgdzIgPSAodzIgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gIGMgPSAoYyArIGhpKSB8IDA7XG4gIGMgPSAoYyArIChtaWQgPj4+IDEzKSkgfCAwO1xuICBjID0gKGMgKyAodzIgPj4+IDI2KSkgfCAwO1xuICB3MiAmPSAweDNmZmZmZmY7XG4gIGxvID0gTWF0aC5pbXVsKGFsMSwgYmwxKTtcbiAgbWlkID0gTWF0aC5pbXVsKGFsMSwgYmgxKTtcbiAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsMSkpIHwgMDtcbiAgaGkgPSBNYXRoLmltdWwoYWgxLCBiaDEpO1xuICB3MiA9ICh3MiArIGxvKSB8IDA7XG4gIHcyID0gKHcyICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICBjID0gKGMgKyBoaSkgfCAwO1xuICBjID0gKGMgKyAobWlkID4+PiAxMykpIHwgMDtcbiAgYyA9IChjICsgKHcyID4+PiAyNikpIHwgMDtcbiAgdzIgJj0gMHgzZmZmZmZmO1xuICBsbyA9IE1hdGguaW11bChhbDAsIGJsMik7XG4gIG1pZCA9IE1hdGguaW11bChhbDAsIGJoMik7XG4gIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDIpKSB8IDA7XG4gIGhpID0gTWF0aC5pbXVsKGFoMCwgYmgyKTtcbiAgdzIgPSAodzIgKyBsbykgfCAwO1xuICB3MiA9ICh3MiArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgYyA9IChjICsgaGkpIHwgMDtcbiAgYyA9IChjICsgKG1pZCA+Pj4gMTMpKSB8IDA7XG4gIGMgPSAoYyArICh3MiA+Pj4gMjYpKSB8IDA7XG4gIHcyICY9IDB4M2ZmZmZmZjtcbiAgLyogayA9IDMgKi9cbiAgdmFyIHczID0gYztcbiAgYyA9IDA7XG4gIGxvID0gTWF0aC5pbXVsKGFsMywgYmwwKTtcbiAgbWlkID0gTWF0aC5pbXVsKGFsMywgYmgwKTtcbiAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsMCkpIHwgMDtcbiAgaGkgPSBNYXRoLmltdWwoYWgzLCBiaDApO1xuICB3MyA9ICh3MyArIGxvKSB8IDA7XG4gIHczID0gKHczICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICBjID0gKGMgKyBoaSkgfCAwO1xuICBjID0gKGMgKyAobWlkID4+PiAxMykpIHwgMDtcbiAgYyA9IChjICsgKHczID4+PiAyNikpIHwgMDtcbiAgdzMgJj0gMHgzZmZmZmZmO1xuICBsbyA9IE1hdGguaW11bChhbDIsIGJsMSk7XG4gIG1pZCA9IE1hdGguaW11bChhbDIsIGJoMSk7XG4gIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDEpKSB8IDA7XG4gIGhpID0gTWF0aC5pbXVsKGFoMiwgYmgxKTtcbiAgdzMgPSAodzMgKyBsbykgfCAwO1xuICB3MyA9ICh3MyArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgYyA9IChjICsgaGkpIHwgMDtcbiAgYyA9IChjICsgKG1pZCA+Pj4gMTMpKSB8IDA7XG4gIGMgPSAoYyArICh3MyA+Pj4gMjYpKSB8IDA7XG4gIHczICY9IDB4M2ZmZmZmZjtcbiAgbG8gPSBNYXRoLmltdWwoYWwxLCBibDIpO1xuICBtaWQgPSBNYXRoLmltdWwoYWwxLCBiaDIpO1xuICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmwyKSkgfCAwO1xuICBoaSA9IE1hdGguaW11bChhaDEsIGJoMik7XG4gIHczID0gKHczICsgbG8pIHwgMDtcbiAgdzMgPSAodzMgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gIGMgPSAoYyArIGhpKSB8IDA7XG4gIGMgPSAoYyArIChtaWQgPj4+IDEzKSkgfCAwO1xuICBjID0gKGMgKyAodzMgPj4+IDI2KSkgfCAwO1xuICB3MyAmPSAweDNmZmZmZmY7XG4gIGxvID0gTWF0aC5pbXVsKGFsMCwgYmwzKTtcbiAgbWlkID0gTWF0aC5pbXVsKGFsMCwgYmgzKTtcbiAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsMykpIHwgMDtcbiAgaGkgPSBNYXRoLmltdWwoYWgwLCBiaDMpO1xuICB3MyA9ICh3MyArIGxvKSB8IDA7XG4gIHczID0gKHczICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICBjID0gKGMgKyBoaSkgfCAwO1xuICBjID0gKGMgKyAobWlkID4+PiAxMykpIHwgMDtcbiAgYyA9IChjICsgKHczID4+PiAyNikpIHwgMDtcbiAgdzMgJj0gMHgzZmZmZmZmO1xuICAvKiBrID0gNCAqL1xuICB2YXIgdzQgPSBjO1xuICBjID0gMDtcbiAgbG8gPSBNYXRoLmltdWwoYWw0LCBibDApO1xuICBtaWQgPSBNYXRoLmltdWwoYWw0LCBiaDApO1xuICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmwwKSkgfCAwO1xuICBoaSA9IE1hdGguaW11bChhaDQsIGJoMCk7XG4gIHc0ID0gKHc0ICsgbG8pIHwgMDtcbiAgdzQgPSAodzQgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gIGMgPSAoYyArIGhpKSB8IDA7XG4gIGMgPSAoYyArIChtaWQgPj4+IDEzKSkgfCAwO1xuICBjID0gKGMgKyAodzQgPj4+IDI2KSkgfCAwO1xuICB3NCAmPSAweDNmZmZmZmY7XG4gIGxvID0gTWF0aC5pbXVsKGFsMywgYmwxKTtcbiAgbWlkID0gTWF0aC5pbXVsKGFsMywgYmgxKTtcbiAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsMSkpIHwgMDtcbiAgaGkgPSBNYXRoLmltdWwoYWgzLCBiaDEpO1xuICB3NCA9ICh3NCArIGxvKSB8IDA7XG4gIHc0ID0gKHc0ICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICBjID0gKGMgKyBoaSkgfCAwO1xuICBjID0gKGMgKyAobWlkID4+PiAxMykpIHwgMDtcbiAgYyA9IChjICsgKHc0ID4+PiAyNikpIHwgMDtcbiAgdzQgJj0gMHgzZmZmZmZmO1xuICBsbyA9IE1hdGguaW11bChhbDIsIGJsMik7XG4gIG1pZCA9IE1hdGguaW11bChhbDIsIGJoMik7XG4gIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDIpKSB8IDA7XG4gIGhpID0gTWF0aC5pbXVsKGFoMiwgYmgyKTtcbiAgdzQgPSAodzQgKyBsbykgfCAwO1xuICB3NCA9ICh3NCArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgYyA9IChjICsgaGkpIHwgMDtcbiAgYyA9IChjICsgKG1pZCA+Pj4gMTMpKSB8IDA7XG4gIGMgPSAoYyArICh3NCA+Pj4gMjYpKSB8IDA7XG4gIHc0ICY9IDB4M2ZmZmZmZjtcbiAgbG8gPSBNYXRoLmltdWwoYWwxLCBibDMpO1xuICBtaWQgPSBNYXRoLmltdWwoYWwxLCBiaDMpO1xuICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmwzKSkgfCAwO1xuICBoaSA9IE1hdGguaW11bChhaDEsIGJoMyk7XG4gIHc0ID0gKHc0ICsgbG8pIHwgMDtcbiAgdzQgPSAodzQgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gIGMgPSAoYyArIGhpKSB8IDA7XG4gIGMgPSAoYyArIChtaWQgPj4+IDEzKSkgfCAwO1xuICBjID0gKGMgKyAodzQgPj4+IDI2KSkgfCAwO1xuICB3NCAmPSAweDNmZmZmZmY7XG4gIGxvID0gTWF0aC5pbXVsKGFsMCwgYmw0KTtcbiAgbWlkID0gTWF0aC5pbXVsKGFsMCwgYmg0KTtcbiAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsNCkpIHwgMDtcbiAgaGkgPSBNYXRoLmltdWwoYWgwLCBiaDQpO1xuICB3NCA9ICh3NCArIGxvKSB8IDA7XG4gIHc0ID0gKHc0ICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICBjID0gKGMgKyBoaSkgfCAwO1xuICBjID0gKGMgKyAobWlkID4+PiAxMykpIHwgMDtcbiAgYyA9IChjICsgKHc0ID4+PiAyNikpIHwgMDtcbiAgdzQgJj0gMHgzZmZmZmZmO1xuICAvKiBrID0gNSAqL1xuICB2YXIgdzUgPSBjO1xuICBjID0gMDtcbiAgbG8gPSBNYXRoLmltdWwoYWw1LCBibDApO1xuICBtaWQgPSBNYXRoLmltdWwoYWw1LCBiaDApO1xuICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmwwKSkgfCAwO1xuICBoaSA9IE1hdGguaW11bChhaDUsIGJoMCk7XG4gIHc1ID0gKHc1ICsgbG8pIHwgMDtcbiAgdzUgPSAodzUgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gIGMgPSAoYyArIGhpKSB8IDA7XG4gIGMgPSAoYyArIChtaWQgPj4+IDEzKSkgfCAwO1xuICBjID0gKGMgKyAodzUgPj4+IDI2KSkgfCAwO1xuICB3NSAmPSAweDNmZmZmZmY7XG4gIGxvID0gTWF0aC5pbXVsKGFsNCwgYmwxKTtcbiAgbWlkID0gTWF0aC5pbXVsKGFsNCwgYmgxKTtcbiAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsMSkpIHwgMDtcbiAgaGkgPSBNYXRoLmltdWwoYWg0LCBiaDEpO1xuICB3NSA9ICh3NSArIGxvKSB8IDA7XG4gIHc1ID0gKHc1ICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICBjID0gKGMgKyBoaSkgfCAwO1xuICBjID0gKGMgKyAobWlkID4+PiAxMykpIHwgMDtcbiAgYyA9IChjICsgKHc1ID4+PiAyNikpIHwgMDtcbiAgdzUgJj0gMHgzZmZmZmZmO1xuICBsbyA9IE1hdGguaW11bChhbDMsIGJsMik7XG4gIG1pZCA9IE1hdGguaW11bChhbDMsIGJoMik7XG4gIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDIpKSB8IDA7XG4gIGhpID0gTWF0aC5pbXVsKGFoMywgYmgyKTtcbiAgdzUgPSAodzUgKyBsbykgfCAwO1xuICB3NSA9ICh3NSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgYyA9IChjICsgaGkpIHwgMDtcbiAgYyA9IChjICsgKG1pZCA+Pj4gMTMpKSB8IDA7XG4gIGMgPSAoYyArICh3NSA+Pj4gMjYpKSB8IDA7XG4gIHc1ICY9IDB4M2ZmZmZmZjtcbiAgbG8gPSBNYXRoLmltdWwoYWwyLCBibDMpO1xuICBtaWQgPSBNYXRoLmltdWwoYWwyLCBiaDMpO1xuICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmwzKSkgfCAwO1xuICBoaSA9IE1hdGguaW11bChhaDIsIGJoMyk7XG4gIHc1ID0gKHc1ICsgbG8pIHwgMDtcbiAgdzUgPSAodzUgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gIGMgPSAoYyArIGhpKSB8IDA7XG4gIGMgPSAoYyArIChtaWQgPj4+IDEzKSkgfCAwO1xuICBjID0gKGMgKyAodzUgPj4+IDI2KSkgfCAwO1xuICB3NSAmPSAweDNmZmZmZmY7XG4gIGxvID0gTWF0aC5pbXVsKGFsMSwgYmw0KTtcbiAgbWlkID0gTWF0aC5pbXVsKGFsMSwgYmg0KTtcbiAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsNCkpIHwgMDtcbiAgaGkgPSBNYXRoLmltdWwoYWgxLCBiaDQpO1xuICB3NSA9ICh3NSArIGxvKSB8IDA7XG4gIHc1ID0gKHc1ICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICBjID0gKGMgKyBoaSkgfCAwO1xuICBjID0gKGMgKyAobWlkID4+PiAxMykpIHwgMDtcbiAgYyA9IChjICsgKHc1ID4+PiAyNikpIHwgMDtcbiAgdzUgJj0gMHgzZmZmZmZmO1xuICBsbyA9IE1hdGguaW11bChhbDAsIGJsNSk7XG4gIG1pZCA9IE1hdGguaW11bChhbDAsIGJoNSk7XG4gIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDUpKSB8IDA7XG4gIGhpID0gTWF0aC5pbXVsKGFoMCwgYmg1KTtcbiAgdzUgPSAodzUgKyBsbykgfCAwO1xuICB3NSA9ICh3NSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgYyA9IChjICsgaGkpIHwgMDtcbiAgYyA9IChjICsgKG1pZCA+Pj4gMTMpKSB8IDA7XG4gIGMgPSAoYyArICh3NSA+Pj4gMjYpKSB8IDA7XG4gIHc1ICY9IDB4M2ZmZmZmZjtcbiAgLyogayA9IDYgKi9cbiAgdmFyIHc2ID0gYztcbiAgYyA9IDA7XG4gIGxvID0gTWF0aC5pbXVsKGFsNiwgYmwwKTtcbiAgbWlkID0gTWF0aC5pbXVsKGFsNiwgYmgwKTtcbiAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsMCkpIHwgMDtcbiAgaGkgPSBNYXRoLmltdWwoYWg2LCBiaDApO1xuICB3NiA9ICh3NiArIGxvKSB8IDA7XG4gIHc2ID0gKHc2ICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICBjID0gKGMgKyBoaSkgfCAwO1xuICBjID0gKGMgKyAobWlkID4+PiAxMykpIHwgMDtcbiAgYyA9IChjICsgKHc2ID4+PiAyNikpIHwgMDtcbiAgdzYgJj0gMHgzZmZmZmZmO1xuICBsbyA9IE1hdGguaW11bChhbDUsIGJsMSk7XG4gIG1pZCA9IE1hdGguaW11bChhbDUsIGJoMSk7XG4gIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDEpKSB8IDA7XG4gIGhpID0gTWF0aC5pbXVsKGFoNSwgYmgxKTtcbiAgdzYgPSAodzYgKyBsbykgfCAwO1xuICB3NiA9ICh3NiArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgYyA9IChjICsgaGkpIHwgMDtcbiAgYyA9IChjICsgKG1pZCA+Pj4gMTMpKSB8IDA7XG4gIGMgPSAoYyArICh3NiA+Pj4gMjYpKSB8IDA7XG4gIHc2ICY9IDB4M2ZmZmZmZjtcbiAgbG8gPSBNYXRoLmltdWwoYWw0LCBibDIpO1xuICBtaWQgPSBNYXRoLmltdWwoYWw0LCBiaDIpO1xuICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmwyKSkgfCAwO1xuICBoaSA9IE1hdGguaW11bChhaDQsIGJoMik7XG4gIHc2ID0gKHc2ICsgbG8pIHwgMDtcbiAgdzYgPSAodzYgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gIGMgPSAoYyArIGhpKSB8IDA7XG4gIGMgPSAoYyArIChtaWQgPj4+IDEzKSkgfCAwO1xuICBjID0gKGMgKyAodzYgPj4+IDI2KSkgfCAwO1xuICB3NiAmPSAweDNmZmZmZmY7XG4gIGxvID0gTWF0aC5pbXVsKGFsMywgYmwzKTtcbiAgbWlkID0gTWF0aC5pbXVsKGFsMywgYmgzKTtcbiAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsMykpIHwgMDtcbiAgaGkgPSBNYXRoLmltdWwoYWgzLCBiaDMpO1xuICB3NiA9ICh3NiArIGxvKSB8IDA7XG4gIHc2ID0gKHc2ICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICBjID0gKGMgKyBoaSkgfCAwO1xuICBjID0gKGMgKyAobWlkID4+PiAxMykpIHwgMDtcbiAgYyA9IChjICsgKHc2ID4+PiAyNikpIHwgMDtcbiAgdzYgJj0gMHgzZmZmZmZmO1xuICBsbyA9IE1hdGguaW11bChhbDIsIGJsNCk7XG4gIG1pZCA9IE1hdGguaW11bChhbDIsIGJoNCk7XG4gIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDQpKSB8IDA7XG4gIGhpID0gTWF0aC5pbXVsKGFoMiwgYmg0KTtcbiAgdzYgPSAodzYgKyBsbykgfCAwO1xuICB3NiA9ICh3NiArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgYyA9IChjICsgaGkpIHwgMDtcbiAgYyA9IChjICsgKG1pZCA+Pj4gMTMpKSB8IDA7XG4gIGMgPSAoYyArICh3NiA+Pj4gMjYpKSB8IDA7XG4gIHc2ICY9IDB4M2ZmZmZmZjtcbiAgbG8gPSBNYXRoLmltdWwoYWwxLCBibDUpO1xuICBtaWQgPSBNYXRoLmltdWwoYWwxLCBiaDUpO1xuICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmw1KSkgfCAwO1xuICBoaSA9IE1hdGguaW11bChhaDEsIGJoNSk7XG4gIHc2ID0gKHc2ICsgbG8pIHwgMDtcbiAgdzYgPSAodzYgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gIGMgPSAoYyArIGhpKSB8IDA7XG4gIGMgPSAoYyArIChtaWQgPj4+IDEzKSkgfCAwO1xuICBjID0gKGMgKyAodzYgPj4+IDI2KSkgfCAwO1xuICB3NiAmPSAweDNmZmZmZmY7XG4gIGxvID0gTWF0aC5pbXVsKGFsMCwgYmw2KTtcbiAgbWlkID0gTWF0aC5pbXVsKGFsMCwgYmg2KTtcbiAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsNikpIHwgMDtcbiAgaGkgPSBNYXRoLmltdWwoYWgwLCBiaDYpO1xuICB3NiA9ICh3NiArIGxvKSB8IDA7XG4gIHc2ID0gKHc2ICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICBjID0gKGMgKyBoaSkgfCAwO1xuICBjID0gKGMgKyAobWlkID4+PiAxMykpIHwgMDtcbiAgYyA9IChjICsgKHc2ID4+PiAyNikpIHwgMDtcbiAgdzYgJj0gMHgzZmZmZmZmO1xuICAvKiBrID0gNyAqL1xuICB2YXIgdzcgPSBjO1xuICBjID0gMDtcbiAgbG8gPSBNYXRoLmltdWwoYWw3LCBibDApO1xuICBtaWQgPSBNYXRoLmltdWwoYWw3LCBiaDApO1xuICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmwwKSkgfCAwO1xuICBoaSA9IE1hdGguaW11bChhaDcsIGJoMCk7XG4gIHc3ID0gKHc3ICsgbG8pIHwgMDtcbiAgdzcgPSAodzcgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gIGMgPSAoYyArIGhpKSB8IDA7XG4gIGMgPSAoYyArIChtaWQgPj4+IDEzKSkgfCAwO1xuICBjID0gKGMgKyAodzcgPj4+IDI2KSkgfCAwO1xuICB3NyAmPSAweDNmZmZmZmY7XG4gIGxvID0gTWF0aC5pbXVsKGFsNiwgYmwxKTtcbiAgbWlkID0gTWF0aC5pbXVsKGFsNiwgYmgxKTtcbiAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsMSkpIHwgMDtcbiAgaGkgPSBNYXRoLmltdWwoYWg2LCBiaDEpO1xuICB3NyA9ICh3NyArIGxvKSB8IDA7XG4gIHc3ID0gKHc3ICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICBjID0gKGMgKyBoaSkgfCAwO1xuICBjID0gKGMgKyAobWlkID4+PiAxMykpIHwgMDtcbiAgYyA9IChjICsgKHc3ID4+PiAyNikpIHwgMDtcbiAgdzcgJj0gMHgzZmZmZmZmO1xuICBsbyA9IE1hdGguaW11bChhbDUsIGJsMik7XG4gIG1pZCA9IE1hdGguaW11bChhbDUsIGJoMik7XG4gIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDIpKSB8IDA7XG4gIGhpID0gTWF0aC5pbXVsKGFoNSwgYmgyKTtcbiAgdzcgPSAodzcgKyBsbykgfCAwO1xuICB3NyA9ICh3NyArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgYyA9IChjICsgaGkpIHwgMDtcbiAgYyA9IChjICsgKG1pZCA+Pj4gMTMpKSB8IDA7XG4gIGMgPSAoYyArICh3NyA+Pj4gMjYpKSB8IDA7XG4gIHc3ICY9IDB4M2ZmZmZmZjtcbiAgbG8gPSBNYXRoLmltdWwoYWw0LCBibDMpO1xuICBtaWQgPSBNYXRoLmltdWwoYWw0LCBiaDMpO1xuICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmwzKSkgfCAwO1xuICBoaSA9IE1hdGguaW11bChhaDQsIGJoMyk7XG4gIHc3ID0gKHc3ICsgbG8pIHwgMDtcbiAgdzcgPSAodzcgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gIGMgPSAoYyArIGhpKSB8IDA7XG4gIGMgPSAoYyArIChtaWQgPj4+IDEzKSkgfCAwO1xuICBjID0gKGMgKyAodzcgPj4+IDI2KSkgfCAwO1xuICB3NyAmPSAweDNmZmZmZmY7XG4gIGxvID0gTWF0aC5pbXVsKGFsMywgYmw0KTtcbiAgbWlkID0gTWF0aC5pbXVsKGFsMywgYmg0KTtcbiAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsNCkpIHwgMDtcbiAgaGkgPSBNYXRoLmltdWwoYWgzLCBiaDQpO1xuICB3NyA9ICh3NyArIGxvKSB8IDA7XG4gIHc3ID0gKHc3ICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICBjID0gKGMgKyBoaSkgfCAwO1xuICBjID0gKGMgKyAobWlkID4+PiAxMykpIHwgMDtcbiAgYyA9IChjICsgKHc3ID4+PiAyNikpIHwgMDtcbiAgdzcgJj0gMHgzZmZmZmZmO1xuICBsbyA9IE1hdGguaW11bChhbDIsIGJsNSk7XG4gIG1pZCA9IE1hdGguaW11bChhbDIsIGJoNSk7XG4gIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDUpKSB8IDA7XG4gIGhpID0gTWF0aC5pbXVsKGFoMiwgYmg1KTtcbiAgdzcgPSAodzcgKyBsbykgfCAwO1xuICB3NyA9ICh3NyArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgYyA9IChjICsgaGkpIHwgMDtcbiAgYyA9IChjICsgKG1pZCA+Pj4gMTMpKSB8IDA7XG4gIGMgPSAoYyArICh3NyA+Pj4gMjYpKSB8IDA7XG4gIHc3ICY9IDB4M2ZmZmZmZjtcbiAgbG8gPSBNYXRoLmltdWwoYWwxLCBibDYpO1xuICBtaWQgPSBNYXRoLmltdWwoYWwxLCBiaDYpO1xuICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmw2KSkgfCAwO1xuICBoaSA9IE1hdGguaW11bChhaDEsIGJoNik7XG4gIHc3ID0gKHc3ICsgbG8pIHwgMDtcbiAgdzcgPSAodzcgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gIGMgPSAoYyArIGhpKSB8IDA7XG4gIGMgPSAoYyArIChtaWQgPj4+IDEzKSkgfCAwO1xuICBjID0gKGMgKyAodzcgPj4+IDI2KSkgfCAwO1xuICB3NyAmPSAweDNmZmZmZmY7XG4gIGxvID0gTWF0aC5pbXVsKGFsMCwgYmw3KTtcbiAgbWlkID0gTWF0aC5pbXVsKGFsMCwgYmg3KTtcbiAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsNykpIHwgMDtcbiAgaGkgPSBNYXRoLmltdWwoYWgwLCBiaDcpO1xuICB3NyA9ICh3NyArIGxvKSB8IDA7XG4gIHc3ID0gKHc3ICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICBjID0gKGMgKyBoaSkgfCAwO1xuICBjID0gKGMgKyAobWlkID4+PiAxMykpIHwgMDtcbiAgYyA9IChjICsgKHc3ID4+PiAyNikpIHwgMDtcbiAgdzcgJj0gMHgzZmZmZmZmO1xuICAvKiBrID0gOCAqL1xuICB2YXIgdzggPSBjO1xuICBjID0gMDtcbiAgbG8gPSBNYXRoLmltdWwoYWw4LCBibDApO1xuICBtaWQgPSBNYXRoLmltdWwoYWw4LCBiaDApO1xuICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmwwKSkgfCAwO1xuICBoaSA9IE1hdGguaW11bChhaDgsIGJoMCk7XG4gIHc4ID0gKHc4ICsgbG8pIHwgMDtcbiAgdzggPSAodzggKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gIGMgPSAoYyArIGhpKSB8IDA7XG4gIGMgPSAoYyArIChtaWQgPj4+IDEzKSkgfCAwO1xuICBjID0gKGMgKyAodzggPj4+IDI2KSkgfCAwO1xuICB3OCAmPSAweDNmZmZmZmY7XG4gIGxvID0gTWF0aC5pbXVsKGFsNywgYmwxKTtcbiAgbWlkID0gTWF0aC5pbXVsKGFsNywgYmgxKTtcbiAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsMSkpIHwgMDtcbiAgaGkgPSBNYXRoLmltdWwoYWg3LCBiaDEpO1xuICB3OCA9ICh3OCArIGxvKSB8IDA7XG4gIHc4ID0gKHc4ICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICBjID0gKGMgKyBoaSkgfCAwO1xuICBjID0gKGMgKyAobWlkID4+PiAxMykpIHwgMDtcbiAgYyA9IChjICsgKHc4ID4+PiAyNikpIHwgMDtcbiAgdzggJj0gMHgzZmZmZmZmO1xuICBsbyA9IE1hdGguaW11bChhbDYsIGJsMik7XG4gIG1pZCA9IE1hdGguaW11bChhbDYsIGJoMik7XG4gIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDIpKSB8IDA7XG4gIGhpID0gTWF0aC5pbXVsKGFoNiwgYmgyKTtcbiAgdzggPSAodzggKyBsbykgfCAwO1xuICB3OCA9ICh3OCArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgYyA9IChjICsgaGkpIHwgMDtcbiAgYyA9IChjICsgKG1pZCA+Pj4gMTMpKSB8IDA7XG4gIGMgPSAoYyArICh3OCA+Pj4gMjYpKSB8IDA7XG4gIHc4ICY9IDB4M2ZmZmZmZjtcbiAgbG8gPSBNYXRoLmltdWwoYWw1LCBibDMpO1xuICBtaWQgPSBNYXRoLmltdWwoYWw1LCBiaDMpO1xuICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmwzKSkgfCAwO1xuICBoaSA9IE1hdGguaW11bChhaDUsIGJoMyk7XG4gIHc4ID0gKHc4ICsgbG8pIHwgMDtcbiAgdzggPSAodzggKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gIGMgPSAoYyArIGhpKSB8IDA7XG4gIGMgPSAoYyArIChtaWQgPj4+IDEzKSkgfCAwO1xuICBjID0gKGMgKyAodzggPj4+IDI2KSkgfCAwO1xuICB3OCAmPSAweDNmZmZmZmY7XG4gIGxvID0gTWF0aC5pbXVsKGFsNCwgYmw0KTtcbiAgbWlkID0gTWF0aC5pbXVsKGFsNCwgYmg0KTtcbiAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsNCkpIHwgMDtcbiAgaGkgPSBNYXRoLmltdWwoYWg0LCBiaDQpO1xuICB3OCA9ICh3OCArIGxvKSB8IDA7XG4gIHc4ID0gKHc4ICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICBjID0gKGMgKyBoaSkgfCAwO1xuICBjID0gKGMgKyAobWlkID4+PiAxMykpIHwgMDtcbiAgYyA9IChjICsgKHc4ID4+PiAyNikpIHwgMDtcbiAgdzggJj0gMHgzZmZmZmZmO1xuICBsbyA9IE1hdGguaW11bChhbDMsIGJsNSk7XG4gIG1pZCA9IE1hdGguaW11bChhbDMsIGJoNSk7XG4gIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDUpKSB8IDA7XG4gIGhpID0gTWF0aC5pbXVsKGFoMywgYmg1KTtcbiAgdzggPSAodzggKyBsbykgfCAwO1xuICB3OCA9ICh3OCArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgYyA9IChjICsgaGkpIHwgMDtcbiAgYyA9IChjICsgKG1pZCA+Pj4gMTMpKSB8IDA7XG4gIGMgPSAoYyArICh3OCA+Pj4gMjYpKSB8IDA7XG4gIHc4ICY9IDB4M2ZmZmZmZjtcbiAgbG8gPSBNYXRoLmltdWwoYWwyLCBibDYpO1xuICBtaWQgPSBNYXRoLmltdWwoYWwyLCBiaDYpO1xuICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw2KSkgfCAwO1xuICBoaSA9IE1hdGguaW11bChhaDIsIGJoNik7XG4gIHc4ID0gKHc4ICsgbG8pIHwgMDtcbiAgdzggPSAodzggKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gIGMgPSAoYyArIGhpKSB8IDA7XG4gIGMgPSAoYyArIChtaWQgPj4+IDEzKSkgfCAwO1xuICBjID0gKGMgKyAodzggPj4+IDI2KSkgfCAwO1xuICB3OCAmPSAweDNmZmZmZmY7XG4gIGxvID0gTWF0aC5pbXVsKGFsMSwgYmw3KTtcbiAgbWlkID0gTWF0aC5pbXVsKGFsMSwgYmg3KTtcbiAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsNykpIHwgMDtcbiAgaGkgPSBNYXRoLmltdWwoYWgxLCBiaDcpO1xuICB3OCA9ICh3OCArIGxvKSB8IDA7XG4gIHc4ID0gKHc4ICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICBjID0gKGMgKyBoaSkgfCAwO1xuICBjID0gKGMgKyAobWlkID4+PiAxMykpIHwgMDtcbiAgYyA9IChjICsgKHc4ID4+PiAyNikpIHwgMDtcbiAgdzggJj0gMHgzZmZmZmZmO1xuICBsbyA9IE1hdGguaW11bChhbDAsIGJsOCk7XG4gIG1pZCA9IE1hdGguaW11bChhbDAsIGJoOCk7XG4gIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDgpKSB8IDA7XG4gIGhpID0gTWF0aC5pbXVsKGFoMCwgYmg4KTtcbiAgdzggPSAodzggKyBsbykgfCAwO1xuICB3OCA9ICh3OCArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgYyA9IChjICsgaGkpIHwgMDtcbiAgYyA9IChjICsgKG1pZCA+Pj4gMTMpKSB8IDA7XG4gIGMgPSAoYyArICh3OCA+Pj4gMjYpKSB8IDA7XG4gIHc4ICY9IDB4M2ZmZmZmZjtcbiAgLyogayA9IDkgKi9cbiAgdmFyIHc5ID0gYztcbiAgYyA9IDA7XG4gIGxvID0gTWF0aC5pbXVsKGFsOSwgYmwwKTtcbiAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmgwKTtcbiAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsMCkpIHwgMDtcbiAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDApO1xuICB3OSA9ICh3OSArIGxvKSB8IDA7XG4gIHc5ID0gKHc5ICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICBjID0gKGMgKyBoaSkgfCAwO1xuICBjID0gKGMgKyAobWlkID4+PiAxMykpIHwgMDtcbiAgYyA9IChjICsgKHc5ID4+PiAyNikpIHwgMDtcbiAgdzkgJj0gMHgzZmZmZmZmO1xuICBsbyA9IE1hdGguaW11bChhbDgsIGJsMSk7XG4gIG1pZCA9IE1hdGguaW11bChhbDgsIGJoMSk7XG4gIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDEpKSB8IDA7XG4gIGhpID0gTWF0aC5pbXVsKGFoOCwgYmgxKTtcbiAgdzkgPSAodzkgKyBsbykgfCAwO1xuICB3OSA9ICh3OSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgYyA9IChjICsgaGkpIHwgMDtcbiAgYyA9IChjICsgKG1pZCA+Pj4gMTMpKSB8IDA7XG4gIGMgPSAoYyArICh3OSA+Pj4gMjYpKSB8IDA7XG4gIHc5ICY9IDB4M2ZmZmZmZjtcbiAgbG8gPSBNYXRoLmltdWwoYWw3LCBibDIpO1xuICBtaWQgPSBNYXRoLmltdWwoYWw3LCBiaDIpO1xuICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmwyKSkgfCAwO1xuICBoaSA9IE1hdGguaW11bChhaDcsIGJoMik7XG4gIHc5ID0gKHc5ICsgbG8pIHwgMDtcbiAgdzkgPSAodzkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gIGMgPSAoYyArIGhpKSB8IDA7XG4gIGMgPSAoYyArIChtaWQgPj4+IDEzKSkgfCAwO1xuICBjID0gKGMgKyAodzkgPj4+IDI2KSkgfCAwO1xuICB3OSAmPSAweDNmZmZmZmY7XG4gIGxvID0gTWF0aC5pbXVsKGFsNiwgYmwzKTtcbiAgbWlkID0gTWF0aC5pbXVsKGFsNiwgYmgzKTtcbiAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsMykpIHwgMDtcbiAgaGkgPSBNYXRoLmltdWwoYWg2LCBiaDMpO1xuICB3OSA9ICh3OSArIGxvKSB8IDA7XG4gIHc5ID0gKHc5ICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICBjID0gKGMgKyBoaSkgfCAwO1xuICBjID0gKGMgKyAobWlkID4+PiAxMykpIHwgMDtcbiAgYyA9IChjICsgKHc5ID4+PiAyNikpIHwgMDtcbiAgdzkgJj0gMHgzZmZmZmZmO1xuICBsbyA9IE1hdGguaW11bChhbDUsIGJsNCk7XG4gIG1pZCA9IE1hdGguaW11bChhbDUsIGJoNCk7XG4gIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDQpKSB8IDA7XG4gIGhpID0gTWF0aC5pbXVsKGFoNSwgYmg0KTtcbiAgdzkgPSAodzkgKyBsbykgfCAwO1xuICB3OSA9ICh3OSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgYyA9IChjICsgaGkpIHwgMDtcbiAgYyA9IChjICsgKG1pZCA+Pj4gMTMpKSB8IDA7XG4gIGMgPSAoYyArICh3OSA+Pj4gMjYpKSB8IDA7XG4gIHc5ICY9IDB4M2ZmZmZmZjtcbiAgbG8gPSBNYXRoLmltdWwoYWw0LCBibDUpO1xuICBtaWQgPSBNYXRoLmltdWwoYWw0LCBiaDUpO1xuICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmw1KSkgfCAwO1xuICBoaSA9IE1hdGguaW11bChhaDQsIGJoNSk7XG4gIHc5ID0gKHc5ICsgbG8pIHwgMDtcbiAgdzkgPSAodzkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gIGMgPSAoYyArIGhpKSB8IDA7XG4gIGMgPSAoYyArIChtaWQgPj4+IDEzKSkgfCAwO1xuICBjID0gKGMgKyAodzkgPj4+IDI2KSkgfCAwO1xuICB3OSAmPSAweDNmZmZmZmY7XG4gIGxvID0gTWF0aC5pbXVsKGFsMywgYmw2KTtcbiAgbWlkID0gTWF0aC5pbXVsKGFsMywgYmg2KTtcbiAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsNikpIHwgMDtcbiAgaGkgPSBNYXRoLmltdWwoYWgzLCBiaDYpO1xuICB3OSA9ICh3OSArIGxvKSB8IDA7XG4gIHc5ID0gKHc5ICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICBjID0gKGMgKyBoaSkgfCAwO1xuICBjID0gKGMgKyAobWlkID4+PiAxMykpIHwgMDtcbiAgYyA9IChjICsgKHc5ID4+PiAyNikpIHwgMDtcbiAgdzkgJj0gMHgzZmZmZmZmO1xuICBsbyA9IE1hdGguaW11bChhbDIsIGJsNyk7XG4gIG1pZCA9IE1hdGguaW11bChhbDIsIGJoNyk7XG4gIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDcpKSB8IDA7XG4gIGhpID0gTWF0aC5pbXVsKGFoMiwgYmg3KTtcbiAgdzkgPSAodzkgKyBsbykgfCAwO1xuICB3OSA9ICh3OSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgYyA9IChjICsgaGkpIHwgMDtcbiAgYyA9IChjICsgKG1pZCA+Pj4gMTMpKSB8IDA7XG4gIGMgPSAoYyArICh3OSA+Pj4gMjYpKSB8IDA7XG4gIHc5ICY9IDB4M2ZmZmZmZjtcbiAgbG8gPSBNYXRoLmltdWwoYWwxLCBibDgpO1xuICBtaWQgPSBNYXRoLmltdWwoYWwxLCBiaDgpO1xuICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmw4KSkgfCAwO1xuICBoaSA9IE1hdGguaW11bChhaDEsIGJoOCk7XG4gIHc5ID0gKHc5ICsgbG8pIHwgMDtcbiAgdzkgPSAodzkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gIGMgPSAoYyArIGhpKSB8IDA7XG4gIGMgPSAoYyArIChtaWQgPj4+IDEzKSkgfCAwO1xuICBjID0gKGMgKyAodzkgPj4+IDI2KSkgfCAwO1xuICB3OSAmPSAweDNmZmZmZmY7XG4gIGxvID0gTWF0aC5pbXVsKGFsMCwgYmw5KTtcbiAgbWlkID0gTWF0aC5pbXVsKGFsMCwgYmg5KTtcbiAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsOSkpIHwgMDtcbiAgaGkgPSBNYXRoLmltdWwoYWgwLCBiaDkpO1xuICB3OSA9ICh3OSArIGxvKSB8IDA7XG4gIHc5ID0gKHc5ICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICBjID0gKGMgKyBoaSkgfCAwO1xuICBjID0gKGMgKyAobWlkID4+PiAxMykpIHwgMDtcbiAgYyA9IChjICsgKHc5ID4+PiAyNikpIHwgMDtcbiAgdzkgJj0gMHgzZmZmZmZmO1xuICAvKiBrID0gMTAgKi9cbiAgdmFyIHcxMCA9IGM7XG4gIGMgPSAwO1xuICBsbyA9IE1hdGguaW11bChhbDksIGJsMSk7XG4gIG1pZCA9IE1hdGguaW11bChhbDksIGJoMSk7XG4gIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDEpKSB8IDA7XG4gIGhpID0gTWF0aC5pbXVsKGFoOSwgYmgxKTtcbiAgdzEwID0gKHcxMCArIGxvKSB8IDA7XG4gIHcxMCA9ICh3MTAgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gIGMgPSAoYyArIGhpKSB8IDA7XG4gIGMgPSAoYyArIChtaWQgPj4+IDEzKSkgfCAwO1xuICBjID0gKGMgKyAodzEwID4+PiAyNikpIHwgMDtcbiAgdzEwICY9IDB4M2ZmZmZmZjtcbiAgbG8gPSBNYXRoLmltdWwoYWw4LCBibDIpO1xuICBtaWQgPSBNYXRoLmltdWwoYWw4LCBiaDIpO1xuICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmwyKSkgfCAwO1xuICBoaSA9IE1hdGguaW11bChhaDgsIGJoMik7XG4gIHcxMCA9ICh3MTAgKyBsbykgfCAwO1xuICB3MTAgPSAodzEwICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICBjID0gKGMgKyBoaSkgfCAwO1xuICBjID0gKGMgKyAobWlkID4+PiAxMykpIHwgMDtcbiAgYyA9IChjICsgKHcxMCA+Pj4gMjYpKSB8IDA7XG4gIHcxMCAmPSAweDNmZmZmZmY7XG4gIGxvID0gTWF0aC5pbXVsKGFsNywgYmwzKTtcbiAgbWlkID0gTWF0aC5pbXVsKGFsNywgYmgzKTtcbiAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsMykpIHwgMDtcbiAgaGkgPSBNYXRoLmltdWwoYWg3LCBiaDMpO1xuICB3MTAgPSAodzEwICsgbG8pIHwgMDtcbiAgdzEwID0gKHcxMCArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgYyA9IChjICsgaGkpIHwgMDtcbiAgYyA9IChjICsgKG1pZCA+Pj4gMTMpKSB8IDA7XG4gIGMgPSAoYyArICh3MTAgPj4+IDI2KSkgfCAwO1xuICB3MTAgJj0gMHgzZmZmZmZmO1xuICBsbyA9IE1hdGguaW11bChhbDYsIGJsNCk7XG4gIG1pZCA9IE1hdGguaW11bChhbDYsIGJoNCk7XG4gIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDQpKSB8IDA7XG4gIGhpID0gTWF0aC5pbXVsKGFoNiwgYmg0KTtcbiAgdzEwID0gKHcxMCArIGxvKSB8IDA7XG4gIHcxMCA9ICh3MTAgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gIGMgPSAoYyArIGhpKSB8IDA7XG4gIGMgPSAoYyArIChtaWQgPj4+IDEzKSkgfCAwO1xuICBjID0gKGMgKyAodzEwID4+PiAyNikpIHwgMDtcbiAgdzEwICY9IDB4M2ZmZmZmZjtcbiAgbG8gPSBNYXRoLmltdWwoYWw1LCBibDUpO1xuICBtaWQgPSBNYXRoLmltdWwoYWw1LCBiaDUpO1xuICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmw1KSkgfCAwO1xuICBoaSA9IE1hdGguaW11bChhaDUsIGJoNSk7XG4gIHcxMCA9ICh3MTAgKyBsbykgfCAwO1xuICB3MTAgPSAodzEwICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICBjID0gKGMgKyBoaSkgfCAwO1xuICBjID0gKGMgKyAobWlkID4+PiAxMykpIHwgMDtcbiAgYyA9IChjICsgKHcxMCA+Pj4gMjYpKSB8IDA7XG4gIHcxMCAmPSAweDNmZmZmZmY7XG4gIGxvID0gTWF0aC5pbXVsKGFsNCwgYmw2KTtcbiAgbWlkID0gTWF0aC5pbXVsKGFsNCwgYmg2KTtcbiAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsNikpIHwgMDtcbiAgaGkgPSBNYXRoLmltdWwoYWg0LCBiaDYpO1xuICB3MTAgPSAodzEwICsgbG8pIHwgMDtcbiAgdzEwID0gKHcxMCArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgYyA9IChjICsgaGkpIHwgMDtcbiAgYyA9IChjICsgKG1pZCA+Pj4gMTMpKSB8IDA7XG4gIGMgPSAoYyArICh3MTAgPj4+IDI2KSkgfCAwO1xuICB3MTAgJj0gMHgzZmZmZmZmO1xuICBsbyA9IE1hdGguaW11bChhbDMsIGJsNyk7XG4gIG1pZCA9IE1hdGguaW11bChhbDMsIGJoNyk7XG4gIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDcpKSB8IDA7XG4gIGhpID0gTWF0aC5pbXVsKGFoMywgYmg3KTtcbiAgdzEwID0gKHcxMCArIGxvKSB8IDA7XG4gIHcxMCA9ICh3MTAgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gIGMgPSAoYyArIGhpKSB8IDA7XG4gIGMgPSAoYyArIChtaWQgPj4+IDEzKSkgfCAwO1xuICBjID0gKGMgKyAodzEwID4+PiAyNikpIHwgMDtcbiAgdzEwICY9IDB4M2ZmZmZmZjtcbiAgbG8gPSBNYXRoLmltdWwoYWwyLCBibDgpO1xuICBtaWQgPSBNYXRoLmltdWwoYWwyLCBiaDgpO1xuICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw4KSkgfCAwO1xuICBoaSA9IE1hdGguaW11bChhaDIsIGJoOCk7XG4gIHcxMCA9ICh3MTAgKyBsbykgfCAwO1xuICB3MTAgPSAodzEwICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICBjID0gKGMgKyBoaSkgfCAwO1xuICBjID0gKGMgKyAobWlkID4+PiAxMykpIHwgMDtcbiAgYyA9IChjICsgKHcxMCA+Pj4gMjYpKSB8IDA7XG4gIHcxMCAmPSAweDNmZmZmZmY7XG4gIGxvID0gTWF0aC5pbXVsKGFsMSwgYmw5KTtcbiAgbWlkID0gTWF0aC5pbXVsKGFsMSwgYmg5KTtcbiAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsOSkpIHwgMDtcbiAgaGkgPSBNYXRoLmltdWwoYWgxLCBiaDkpO1xuICB3MTAgPSAodzEwICsgbG8pIHwgMDtcbiAgdzEwID0gKHcxMCArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgYyA9IChjICsgaGkpIHwgMDtcbiAgYyA9IChjICsgKG1pZCA+Pj4gMTMpKSB8IDA7XG4gIGMgPSAoYyArICh3MTAgPj4+IDI2KSkgfCAwO1xuICB3MTAgJj0gMHgzZmZmZmZmO1xuICAvKiBrID0gMTEgKi9cbiAgdmFyIHcxMSA9IGM7XG4gIGMgPSAwO1xuICBsbyA9IE1hdGguaW11bChhbDksIGJsMik7XG4gIG1pZCA9IE1hdGguaW11bChhbDksIGJoMik7XG4gIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDIpKSB8IDA7XG4gIGhpID0gTWF0aC5pbXVsKGFoOSwgYmgyKTtcbiAgdzExID0gKHcxMSArIGxvKSB8IDA7XG4gIHcxMSA9ICh3MTEgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gIGMgPSAoYyArIGhpKSB8IDA7XG4gIGMgPSAoYyArIChtaWQgPj4+IDEzKSkgfCAwO1xuICBjID0gKGMgKyAodzExID4+PiAyNikpIHwgMDtcbiAgdzExICY9IDB4M2ZmZmZmZjtcbiAgbG8gPSBNYXRoLmltdWwoYWw4LCBibDMpO1xuICBtaWQgPSBNYXRoLmltdWwoYWw4LCBiaDMpO1xuICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmwzKSkgfCAwO1xuICBoaSA9IE1hdGguaW11bChhaDgsIGJoMyk7XG4gIHcxMSA9ICh3MTEgKyBsbykgfCAwO1xuICB3MTEgPSAodzExICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICBjID0gKGMgKyBoaSkgfCAwO1xuICBjID0gKGMgKyAobWlkID4+PiAxMykpIHwgMDtcbiAgYyA9IChjICsgKHcxMSA+Pj4gMjYpKSB8IDA7XG4gIHcxMSAmPSAweDNmZmZmZmY7XG4gIGxvID0gTWF0aC5pbXVsKGFsNywgYmw0KTtcbiAgbWlkID0gTWF0aC5pbXVsKGFsNywgYmg0KTtcbiAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsNCkpIHwgMDtcbiAgaGkgPSBNYXRoLmltdWwoYWg3LCBiaDQpO1xuICB3MTEgPSAodzExICsgbG8pIHwgMDtcbiAgdzExID0gKHcxMSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgYyA9IChjICsgaGkpIHwgMDtcbiAgYyA9IChjICsgKG1pZCA+Pj4gMTMpKSB8IDA7XG4gIGMgPSAoYyArICh3MTEgPj4+IDI2KSkgfCAwO1xuICB3MTEgJj0gMHgzZmZmZmZmO1xuICBsbyA9IE1hdGguaW11bChhbDYsIGJsNSk7XG4gIG1pZCA9IE1hdGguaW11bChhbDYsIGJoNSk7XG4gIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDUpKSB8IDA7XG4gIGhpID0gTWF0aC5pbXVsKGFoNiwgYmg1KTtcbiAgdzExID0gKHcxMSArIGxvKSB8IDA7XG4gIHcxMSA9ICh3MTEgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gIGMgPSAoYyArIGhpKSB8IDA7XG4gIGMgPSAoYyArIChtaWQgPj4+IDEzKSkgfCAwO1xuICBjID0gKGMgKyAodzExID4+PiAyNikpIHwgMDtcbiAgdzExICY9IDB4M2ZmZmZmZjtcbiAgbG8gPSBNYXRoLmltdWwoYWw1LCBibDYpO1xuICBtaWQgPSBNYXRoLmltdWwoYWw1LCBiaDYpO1xuICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmw2KSkgfCAwO1xuICBoaSA9IE1hdGguaW11bChhaDUsIGJoNik7XG4gIHcxMSA9ICh3MTEgKyBsbykgfCAwO1xuICB3MTEgPSAodzExICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICBjID0gKGMgKyBoaSkgfCAwO1xuICBjID0gKGMgKyAobWlkID4+PiAxMykpIHwgMDtcbiAgYyA9IChjICsgKHcxMSA+Pj4gMjYpKSB8IDA7XG4gIHcxMSAmPSAweDNmZmZmZmY7XG4gIGxvID0gTWF0aC5pbXVsKGFsNCwgYmw3KTtcbiAgbWlkID0gTWF0aC5pbXVsKGFsNCwgYmg3KTtcbiAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsNykpIHwgMDtcbiAgaGkgPSBNYXRoLmltdWwoYWg0LCBiaDcpO1xuICB3MTEgPSAodzExICsgbG8pIHwgMDtcbiAgdzExID0gKHcxMSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgYyA9IChjICsgaGkpIHwgMDtcbiAgYyA9IChjICsgKG1pZCA+Pj4gMTMpKSB8IDA7XG4gIGMgPSAoYyArICh3MTEgPj4+IDI2KSkgfCAwO1xuICB3MTEgJj0gMHgzZmZmZmZmO1xuICBsbyA9IE1hdGguaW11bChhbDMsIGJsOCk7XG4gIG1pZCA9IE1hdGguaW11bChhbDMsIGJoOCk7XG4gIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDgpKSB8IDA7XG4gIGhpID0gTWF0aC5pbXVsKGFoMywgYmg4KTtcbiAgdzExID0gKHcxMSArIGxvKSB8IDA7XG4gIHcxMSA9ICh3MTEgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gIGMgPSAoYyArIGhpKSB8IDA7XG4gIGMgPSAoYyArIChtaWQgPj4+IDEzKSkgfCAwO1xuICBjID0gKGMgKyAodzExID4+PiAyNikpIHwgMDtcbiAgdzExICY9IDB4M2ZmZmZmZjtcbiAgbG8gPSBNYXRoLmltdWwoYWwyLCBibDkpO1xuICBtaWQgPSBNYXRoLmltdWwoYWwyLCBiaDkpO1xuICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw5KSkgfCAwO1xuICBoaSA9IE1hdGguaW11bChhaDIsIGJoOSk7XG4gIHcxMSA9ICh3MTEgKyBsbykgfCAwO1xuICB3MTEgPSAodzExICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICBjID0gKGMgKyBoaSkgfCAwO1xuICBjID0gKGMgKyAobWlkID4+PiAxMykpIHwgMDtcbiAgYyA9IChjICsgKHcxMSA+Pj4gMjYpKSB8IDA7XG4gIHcxMSAmPSAweDNmZmZmZmY7XG4gIC8qIGsgPSAxMiAqL1xuICB2YXIgdzEyID0gYztcbiAgYyA9IDA7XG4gIGxvID0gTWF0aC5pbXVsKGFsOSwgYmwzKTtcbiAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmgzKTtcbiAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsMykpIHwgMDtcbiAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDMpO1xuICB3MTIgPSAodzEyICsgbG8pIHwgMDtcbiAgdzEyID0gKHcxMiArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgYyA9IChjICsgaGkpIHwgMDtcbiAgYyA9IChjICsgKG1pZCA+Pj4gMTMpKSB8IDA7XG4gIGMgPSAoYyArICh3MTIgPj4+IDI2KSkgfCAwO1xuICB3MTIgJj0gMHgzZmZmZmZmO1xuICBsbyA9IE1hdGguaW11bChhbDgsIGJsNCk7XG4gIG1pZCA9IE1hdGguaW11bChhbDgsIGJoNCk7XG4gIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDQpKSB8IDA7XG4gIGhpID0gTWF0aC5pbXVsKGFoOCwgYmg0KTtcbiAgdzEyID0gKHcxMiArIGxvKSB8IDA7XG4gIHcxMiA9ICh3MTIgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gIGMgPSAoYyArIGhpKSB8IDA7XG4gIGMgPSAoYyArIChtaWQgPj4+IDEzKSkgfCAwO1xuICBjID0gKGMgKyAodzEyID4+PiAyNikpIHwgMDtcbiAgdzEyICY9IDB4M2ZmZmZmZjtcbiAgbG8gPSBNYXRoLmltdWwoYWw3LCBibDUpO1xuICBtaWQgPSBNYXRoLmltdWwoYWw3LCBiaDUpO1xuICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmw1KSkgfCAwO1xuICBoaSA9IE1hdGguaW11bChhaDcsIGJoNSk7XG4gIHcxMiA9ICh3MTIgKyBsbykgfCAwO1xuICB3MTIgPSAodzEyICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICBjID0gKGMgKyBoaSkgfCAwO1xuICBjID0gKGMgKyAobWlkID4+PiAxMykpIHwgMDtcbiAgYyA9IChjICsgKHcxMiA+Pj4gMjYpKSB8IDA7XG4gIHcxMiAmPSAweDNmZmZmZmY7XG4gIGxvID0gTWF0aC5pbXVsKGFsNiwgYmw2KTtcbiAgbWlkID0gTWF0aC5pbXVsKGFsNiwgYmg2KTtcbiAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsNikpIHwgMDtcbiAgaGkgPSBNYXRoLmltdWwoYWg2LCBiaDYpO1xuICB3MTIgPSAodzEyICsgbG8pIHwgMDtcbiAgdzEyID0gKHcxMiArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgYyA9IChjICsgaGkpIHwgMDtcbiAgYyA9IChjICsgKG1pZCA+Pj4gMTMpKSB8IDA7XG4gIGMgPSAoYyArICh3MTIgPj4+IDI2KSkgfCAwO1xuICB3MTIgJj0gMHgzZmZmZmZmO1xuICBsbyA9IE1hdGguaW11bChhbDUsIGJsNyk7XG4gIG1pZCA9IE1hdGguaW11bChhbDUsIGJoNyk7XG4gIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDcpKSB8IDA7XG4gIGhpID0gTWF0aC5pbXVsKGFoNSwgYmg3KTtcbiAgdzEyID0gKHcxMiArIGxvKSB8IDA7XG4gIHcxMiA9ICh3MTIgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gIGMgPSAoYyArIGhpKSB8IDA7XG4gIGMgPSAoYyArIChtaWQgPj4+IDEzKSkgfCAwO1xuICBjID0gKGMgKyAodzEyID4+PiAyNikpIHwgMDtcbiAgdzEyICY9IDB4M2ZmZmZmZjtcbiAgbG8gPSBNYXRoLmltdWwoYWw0LCBibDgpO1xuICBtaWQgPSBNYXRoLmltdWwoYWw0LCBiaDgpO1xuICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmw4KSkgfCAwO1xuICBoaSA9IE1hdGguaW11bChhaDQsIGJoOCk7XG4gIHcxMiA9ICh3MTIgKyBsbykgfCAwO1xuICB3MTIgPSAodzEyICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICBjID0gKGMgKyBoaSkgfCAwO1xuICBjID0gKGMgKyAobWlkID4+PiAxMykpIHwgMDtcbiAgYyA9IChjICsgKHcxMiA+Pj4gMjYpKSB8IDA7XG4gIHcxMiAmPSAweDNmZmZmZmY7XG4gIGxvID0gTWF0aC5pbXVsKGFsMywgYmw5KTtcbiAgbWlkID0gTWF0aC5pbXVsKGFsMywgYmg5KTtcbiAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsOSkpIHwgMDtcbiAgaGkgPSBNYXRoLmltdWwoYWgzLCBiaDkpO1xuICB3MTIgPSAodzEyICsgbG8pIHwgMDtcbiAgdzEyID0gKHcxMiArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgYyA9IChjICsgaGkpIHwgMDtcbiAgYyA9IChjICsgKG1pZCA+Pj4gMTMpKSB8IDA7XG4gIGMgPSAoYyArICh3MTIgPj4+IDI2KSkgfCAwO1xuICB3MTIgJj0gMHgzZmZmZmZmO1xuICAvKiBrID0gMTMgKi9cbiAgdmFyIHcxMyA9IGM7XG4gIGMgPSAwO1xuICBsbyA9IE1hdGguaW11bChhbDksIGJsNCk7XG4gIG1pZCA9IE1hdGguaW11bChhbDksIGJoNCk7XG4gIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDQpKSB8IDA7XG4gIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg0KTtcbiAgdzEzID0gKHcxMyArIGxvKSB8IDA7XG4gIHcxMyA9ICh3MTMgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gIGMgPSAoYyArIGhpKSB8IDA7XG4gIGMgPSAoYyArIChtaWQgPj4+IDEzKSkgfCAwO1xuICBjID0gKGMgKyAodzEzID4+PiAyNikpIHwgMDtcbiAgdzEzICY9IDB4M2ZmZmZmZjtcbiAgbG8gPSBNYXRoLmltdWwoYWw4LCBibDUpO1xuICBtaWQgPSBNYXRoLmltdWwoYWw4LCBiaDUpO1xuICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmw1KSkgfCAwO1xuICBoaSA9IE1hdGguaW11bChhaDgsIGJoNSk7XG4gIHcxMyA9ICh3MTMgKyBsbykgfCAwO1xuICB3MTMgPSAodzEzICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICBjID0gKGMgKyBoaSkgfCAwO1xuICBjID0gKGMgKyAobWlkID4+PiAxMykpIHwgMDtcbiAgYyA9IChjICsgKHcxMyA+Pj4gMjYpKSB8IDA7XG4gIHcxMyAmPSAweDNmZmZmZmY7XG4gIGxvID0gTWF0aC5pbXVsKGFsNywgYmw2KTtcbiAgbWlkID0gTWF0aC5pbXVsKGFsNywgYmg2KTtcbiAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsNikpIHwgMDtcbiAgaGkgPSBNYXRoLmltdWwoYWg3LCBiaDYpO1xuICB3MTMgPSAodzEzICsgbG8pIHwgMDtcbiAgdzEzID0gKHcxMyArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgYyA9IChjICsgaGkpIHwgMDtcbiAgYyA9IChjICsgKG1pZCA+Pj4gMTMpKSB8IDA7XG4gIGMgPSAoYyArICh3MTMgPj4+IDI2KSkgfCAwO1xuICB3MTMgJj0gMHgzZmZmZmZmO1xuICBsbyA9IE1hdGguaW11bChhbDYsIGJsNyk7XG4gIG1pZCA9IE1hdGguaW11bChhbDYsIGJoNyk7XG4gIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDcpKSB8IDA7XG4gIGhpID0gTWF0aC5pbXVsKGFoNiwgYmg3KTtcbiAgdzEzID0gKHcxMyArIGxvKSB8IDA7XG4gIHcxMyA9ICh3MTMgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gIGMgPSAoYyArIGhpKSB8IDA7XG4gIGMgPSAoYyArIChtaWQgPj4+IDEzKSkgfCAwO1xuICBjID0gKGMgKyAodzEzID4+PiAyNikpIHwgMDtcbiAgdzEzICY9IDB4M2ZmZmZmZjtcbiAgbG8gPSBNYXRoLmltdWwoYWw1LCBibDgpO1xuICBtaWQgPSBNYXRoLmltdWwoYWw1LCBiaDgpO1xuICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmw4KSkgfCAwO1xuICBoaSA9IE1hdGguaW11bChhaDUsIGJoOCk7XG4gIHcxMyA9ICh3MTMgKyBsbykgfCAwO1xuICB3MTMgPSAodzEzICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICBjID0gKGMgKyBoaSkgfCAwO1xuICBjID0gKGMgKyAobWlkID4+PiAxMykpIHwgMDtcbiAgYyA9IChjICsgKHcxMyA+Pj4gMjYpKSB8IDA7XG4gIHcxMyAmPSAweDNmZmZmZmY7XG4gIGxvID0gTWF0aC5pbXVsKGFsNCwgYmw5KTtcbiAgbWlkID0gTWF0aC5pbXVsKGFsNCwgYmg5KTtcbiAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsOSkpIHwgMDtcbiAgaGkgPSBNYXRoLmltdWwoYWg0LCBiaDkpO1xuICB3MTMgPSAodzEzICsgbG8pIHwgMDtcbiAgdzEzID0gKHcxMyArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgYyA9IChjICsgaGkpIHwgMDtcbiAgYyA9IChjICsgKG1pZCA+Pj4gMTMpKSB8IDA7XG4gIGMgPSAoYyArICh3MTMgPj4+IDI2KSkgfCAwO1xuICB3MTMgJj0gMHgzZmZmZmZmO1xuICAvKiBrID0gMTQgKi9cbiAgdmFyIHcxNCA9IGM7XG4gIGMgPSAwO1xuICBsbyA9IE1hdGguaW11bChhbDksIGJsNSk7XG4gIG1pZCA9IE1hdGguaW11bChhbDksIGJoNSk7XG4gIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDUpKSB8IDA7XG4gIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg1KTtcbiAgdzE0ID0gKHcxNCArIGxvKSB8IDA7XG4gIHcxNCA9ICh3MTQgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gIGMgPSAoYyArIGhpKSB8IDA7XG4gIGMgPSAoYyArIChtaWQgPj4+IDEzKSkgfCAwO1xuICBjID0gKGMgKyAodzE0ID4+PiAyNikpIHwgMDtcbiAgdzE0ICY9IDB4M2ZmZmZmZjtcbiAgbG8gPSBNYXRoLmltdWwoYWw4LCBibDYpO1xuICBtaWQgPSBNYXRoLmltdWwoYWw4LCBiaDYpO1xuICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmw2KSkgfCAwO1xuICBoaSA9IE1hdGguaW11bChhaDgsIGJoNik7XG4gIHcxNCA9ICh3MTQgKyBsbykgfCAwO1xuICB3MTQgPSAodzE0ICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICBjID0gKGMgKyBoaSkgfCAwO1xuICBjID0gKGMgKyAobWlkID4+PiAxMykpIHwgMDtcbiAgYyA9IChjICsgKHcxNCA+Pj4gMjYpKSB8IDA7XG4gIHcxNCAmPSAweDNmZmZmZmY7XG4gIGxvID0gTWF0aC5pbXVsKGFsNywgYmw3KTtcbiAgbWlkID0gTWF0aC5pbXVsKGFsNywgYmg3KTtcbiAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsNykpIHwgMDtcbiAgaGkgPSBNYXRoLmltdWwoYWg3LCBiaDcpO1xuICB3MTQgPSAodzE0ICsgbG8pIHwgMDtcbiAgdzE0ID0gKHcxNCArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgYyA9IChjICsgaGkpIHwgMDtcbiAgYyA9IChjICsgKG1pZCA+Pj4gMTMpKSB8IDA7XG4gIGMgPSAoYyArICh3MTQgPj4+IDI2KSkgfCAwO1xuICB3MTQgJj0gMHgzZmZmZmZmO1xuICBsbyA9IE1hdGguaW11bChhbDYsIGJsOCk7XG4gIG1pZCA9IE1hdGguaW11bChhbDYsIGJoOCk7XG4gIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDgpKSB8IDA7XG4gIGhpID0gTWF0aC5pbXVsKGFoNiwgYmg4KTtcbiAgdzE0ID0gKHcxNCArIGxvKSB8IDA7XG4gIHcxNCA9ICh3MTQgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gIGMgPSAoYyArIGhpKSB8IDA7XG4gIGMgPSAoYyArIChtaWQgPj4+IDEzKSkgfCAwO1xuICBjID0gKGMgKyAodzE0ID4+PiAyNikpIHwgMDtcbiAgdzE0ICY9IDB4M2ZmZmZmZjtcbiAgbG8gPSBNYXRoLmltdWwoYWw1LCBibDkpO1xuICBtaWQgPSBNYXRoLmltdWwoYWw1LCBiaDkpO1xuICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmw5KSkgfCAwO1xuICBoaSA9IE1hdGguaW11bChhaDUsIGJoOSk7XG4gIHcxNCA9ICh3MTQgKyBsbykgfCAwO1xuICB3MTQgPSAodzE0ICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICBjID0gKGMgKyBoaSkgfCAwO1xuICBjID0gKGMgKyAobWlkID4+PiAxMykpIHwgMDtcbiAgYyA9IChjICsgKHcxNCA+Pj4gMjYpKSB8IDA7XG4gIHcxNCAmPSAweDNmZmZmZmY7XG4gIC8qIGsgPSAxNSAqL1xuICB2YXIgdzE1ID0gYztcbiAgYyA9IDA7XG4gIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw2KTtcbiAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg2KTtcbiAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsNikpIHwgMDtcbiAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDYpO1xuICB3MTUgPSAodzE1ICsgbG8pIHwgMDtcbiAgdzE1ID0gKHcxNSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgYyA9IChjICsgaGkpIHwgMDtcbiAgYyA9IChjICsgKG1pZCA+Pj4gMTMpKSB8IDA7XG4gIGMgPSAoYyArICh3MTUgPj4+IDI2KSkgfCAwO1xuICB3MTUgJj0gMHgzZmZmZmZmO1xuICBsbyA9IE1hdGguaW11bChhbDgsIGJsNyk7XG4gIG1pZCA9IE1hdGguaW11bChhbDgsIGJoNyk7XG4gIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDcpKSB8IDA7XG4gIGhpID0gTWF0aC5pbXVsKGFoOCwgYmg3KTtcbiAgdzE1ID0gKHcxNSArIGxvKSB8IDA7XG4gIHcxNSA9ICh3MTUgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gIGMgPSAoYyArIGhpKSB8IDA7XG4gIGMgPSAoYyArIChtaWQgPj4+IDEzKSkgfCAwO1xuICBjID0gKGMgKyAodzE1ID4+PiAyNikpIHwgMDtcbiAgdzE1ICY9IDB4M2ZmZmZmZjtcbiAgbG8gPSBNYXRoLmltdWwoYWw3LCBibDgpO1xuICBtaWQgPSBNYXRoLmltdWwoYWw3LCBiaDgpO1xuICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmw4KSkgfCAwO1xuICBoaSA9IE1hdGguaW11bChhaDcsIGJoOCk7XG4gIHcxNSA9ICh3MTUgKyBsbykgfCAwO1xuICB3MTUgPSAodzE1ICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICBjID0gKGMgKyBoaSkgfCAwO1xuICBjID0gKGMgKyAobWlkID4+PiAxMykpIHwgMDtcbiAgYyA9IChjICsgKHcxNSA+Pj4gMjYpKSB8IDA7XG4gIHcxNSAmPSAweDNmZmZmZmY7XG4gIGxvID0gTWF0aC5pbXVsKGFsNiwgYmw5KTtcbiAgbWlkID0gTWF0aC5pbXVsKGFsNiwgYmg5KTtcbiAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsOSkpIHwgMDtcbiAgaGkgPSBNYXRoLmltdWwoYWg2LCBiaDkpO1xuICB3MTUgPSAodzE1ICsgbG8pIHwgMDtcbiAgdzE1ID0gKHcxNSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgYyA9IChjICsgaGkpIHwgMDtcbiAgYyA9IChjICsgKG1pZCA+Pj4gMTMpKSB8IDA7XG4gIGMgPSAoYyArICh3MTUgPj4+IDI2KSkgfCAwO1xuICB3MTUgJj0gMHgzZmZmZmZmO1xuICAvKiBrID0gMTYgKi9cbiAgdmFyIHcxNiA9IGM7XG4gIGMgPSAwO1xuICBsbyA9IE1hdGguaW11bChhbDksIGJsNyk7XG4gIG1pZCA9IE1hdGguaW11bChhbDksIGJoNyk7XG4gIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDcpKSB8IDA7XG4gIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg3KTtcbiAgdzE2ID0gKHcxNiArIGxvKSB8IDA7XG4gIHcxNiA9ICh3MTYgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gIGMgPSAoYyArIGhpKSB8IDA7XG4gIGMgPSAoYyArIChtaWQgPj4+IDEzKSkgfCAwO1xuICBjID0gKGMgKyAodzE2ID4+PiAyNikpIHwgMDtcbiAgdzE2ICY9IDB4M2ZmZmZmZjtcbiAgbG8gPSBNYXRoLmltdWwoYWw4LCBibDgpO1xuICBtaWQgPSBNYXRoLmltdWwoYWw4LCBiaDgpO1xuICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmw4KSkgfCAwO1xuICBoaSA9IE1hdGguaW11bChhaDgsIGJoOCk7XG4gIHcxNiA9ICh3MTYgKyBsbykgfCAwO1xuICB3MTYgPSAodzE2ICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICBjID0gKGMgKyBoaSkgfCAwO1xuICBjID0gKGMgKyAobWlkID4+PiAxMykpIHwgMDtcbiAgYyA9IChjICsgKHcxNiA+Pj4gMjYpKSB8IDA7XG4gIHcxNiAmPSAweDNmZmZmZmY7XG4gIGxvID0gTWF0aC5pbXVsKGFsNywgYmw5KTtcbiAgbWlkID0gTWF0aC5pbXVsKGFsNywgYmg5KTtcbiAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsOSkpIHwgMDtcbiAgaGkgPSBNYXRoLmltdWwoYWg3LCBiaDkpO1xuICB3MTYgPSAodzE2ICsgbG8pIHwgMDtcbiAgdzE2ID0gKHcxNiArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgYyA9IChjICsgaGkpIHwgMDtcbiAgYyA9IChjICsgKG1pZCA+Pj4gMTMpKSB8IDA7XG4gIGMgPSAoYyArICh3MTYgPj4+IDI2KSkgfCAwO1xuICB3MTYgJj0gMHgzZmZmZmZmO1xuICAvKiBrID0gMTcgKi9cbiAgdmFyIHcxNyA9IGM7XG4gIGMgPSAwO1xuICBsbyA9IE1hdGguaW11bChhbDksIGJsOCk7XG4gIG1pZCA9IE1hdGguaW11bChhbDksIGJoOCk7XG4gIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDgpKSB8IDA7XG4gIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg4KTtcbiAgdzE3ID0gKHcxNyArIGxvKSB8IDA7XG4gIHcxNyA9ICh3MTcgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gIGMgPSAoYyArIGhpKSB8IDA7XG4gIGMgPSAoYyArIChtaWQgPj4+IDEzKSkgfCAwO1xuICBjID0gKGMgKyAodzE3ID4+PiAyNikpIHwgMDtcbiAgdzE3ICY9IDB4M2ZmZmZmZjtcbiAgbG8gPSBNYXRoLmltdWwoYWw4LCBibDkpO1xuICBtaWQgPSBNYXRoLmltdWwoYWw4LCBiaDkpO1xuICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmw5KSkgfCAwO1xuICBoaSA9IE1hdGguaW11bChhaDgsIGJoOSk7XG4gIHcxNyA9ICh3MTcgKyBsbykgfCAwO1xuICB3MTcgPSAodzE3ICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICBjID0gKGMgKyBoaSkgfCAwO1xuICBjID0gKGMgKyAobWlkID4+PiAxMykpIHwgMDtcbiAgYyA9IChjICsgKHcxNyA+Pj4gMjYpKSB8IDA7XG4gIHcxNyAmPSAweDNmZmZmZmY7XG4gIC8qIGsgPSAxOCAqL1xuICB2YXIgdzE4ID0gYztcbiAgYyA9IDA7XG4gIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw5KTtcbiAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg5KTtcbiAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsOSkpIHwgMDtcbiAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDkpO1xuICB3MTggPSAodzE4ICsgbG8pIHwgMDtcbiAgdzE4ID0gKHcxOCArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgYyA9IChjICsgaGkpIHwgMDtcbiAgYyA9IChjICsgKG1pZCA+Pj4gMTMpKSB8IDA7XG4gIGMgPSAoYyArICh3MTggPj4+IDI2KSkgfCAwO1xuICB3MTggJj0gMHgzZmZmZmZmO1xuICBvWzBdID0gdzA7XG4gIG9bMV0gPSB3MTtcbiAgb1syXSA9IHcyO1xuICBvWzNdID0gdzM7XG4gIG9bNF0gPSB3NDtcbiAgb1s1XSA9IHc1O1xuICBvWzZdID0gdzY7XG4gIG9bN10gPSB3NztcbiAgb1s4XSA9IHc4O1xuICBvWzldID0gdzk7XG4gIG9bMTBdID0gdzEwO1xuICBvWzExXSA9IHcxMTtcbiAgb1sxMl0gPSB3MTI7XG4gIG9bMTNdID0gdzEzO1xuICBvWzE0XSA9IHcxNDtcbiAgb1sxNV0gPSB3MTU7XG4gIG9bMTZdID0gdzE2O1xuICBvWzE3XSA9IHcxNztcbiAgb1sxOF0gPSB3MTg7XG4gIGlmIChjICE9PSAwKSB7XG4gICAgb1sxOV0gPSBjO1xuICAgIG91dC5sZW5ndGgrKztcbiAgfVxuICByZXR1cm4gb3V0O1xufTtcblxuLy8gUG9seWZpbGwgY29tYlxuaWYgKCFNYXRoLmltdWwpXG4gIGNvbWIxME11bFRvID0gc21hbGxNdWxUbztcblxuZnVuY3Rpb24gYmlnTXVsVG8oc2VsZiwgbnVtLCBvdXQpIHtcbiAgb3V0Lm5lZ2F0aXZlID0gbnVtLm5lZ2F0aXZlIF4gc2VsZi5uZWdhdGl2ZTtcbiAgb3V0Lmxlbmd0aCA9IHNlbGYubGVuZ3RoICsgbnVtLmxlbmd0aDtcblxuICB2YXIgY2FycnkgPSAwO1xuICB2YXIgaG5jYXJyeSA9IDA7XG4gIGZvciAodmFyIGsgPSAwOyBrIDwgb3V0Lmxlbmd0aCAtIDE7IGsrKykge1xuICAgIC8vIFN1bSBhbGwgd29yZHMgd2l0aCB0aGUgc2FtZSBgaSArIGogPSBrYCBhbmQgYWNjdW11bGF0ZSBgbmNhcnJ5YCxcbiAgICAvLyBub3RlIHRoYXQgbmNhcnJ5IGNvdWxkIGJlID49IDB4M2ZmZmZmZlxuICAgIHZhciBuY2FycnkgPSBobmNhcnJ5O1xuICAgIGhuY2FycnkgPSAwO1xuICAgIHZhciByd29yZCA9IGNhcnJ5ICYgMHgzZmZmZmZmO1xuICAgIHZhciBtYXhKID0gTWF0aC5taW4oaywgbnVtLmxlbmd0aCAtIDEpO1xuICAgIGZvciAodmFyIGogPSBNYXRoLm1heCgwLCBrIC0gc2VsZi5sZW5ndGggKyAxKTsgaiA8PSBtYXhKOyBqKyspIHtcbiAgICAgIHZhciBpID0gayAtIGo7XG4gICAgICB2YXIgYSA9IHNlbGYud29yZHNbaV0gfCAwO1xuICAgICAgdmFyIGIgPSBudW0ud29yZHNbal0gfCAwO1xuICAgICAgdmFyIHIgPSBhICogYjtcblxuICAgICAgdmFyIGxvID0gciAmIDB4M2ZmZmZmZjtcbiAgICAgIG5jYXJyeSA9IChuY2FycnkgKyAoKHIgLyAweDQwMDAwMDApIHwgMCkpIHwgMDtcbiAgICAgIGxvID0gKGxvICsgcndvcmQpIHwgMDtcbiAgICAgIHJ3b3JkID0gbG8gJiAweDNmZmZmZmY7XG4gICAgICBuY2FycnkgPSAobmNhcnJ5ICsgKGxvID4+PiAyNikpIHwgMDtcblxuICAgICAgaG5jYXJyeSArPSBuY2FycnkgPj4+IDI2O1xuICAgICAgbmNhcnJ5ICY9IDB4M2ZmZmZmZjtcbiAgICB9XG4gICAgb3V0LndvcmRzW2tdID0gcndvcmQ7XG4gICAgY2FycnkgPSBuY2Fycnk7XG4gICAgbmNhcnJ5ID0gaG5jYXJyeTtcbiAgfVxuICBpZiAoY2FycnkgIT09IDApIHtcbiAgICBvdXQud29yZHNba10gPSBjYXJyeTtcbiAgfSBlbHNlIHtcbiAgICBvdXQubGVuZ3RoLS07XG4gIH1cblxuICByZXR1cm4gb3V0LnN0cmlwKCk7XG59XG5cbmZ1bmN0aW9uIGp1bWJvTXVsVG8oc2VsZiwgbnVtLCBvdXQpIHtcbiAgdmFyIGZmdG0gPSBuZXcgRkZUTSgpO1xuICByZXR1cm4gZmZ0bS5tdWxwKHNlbGYsIG51bSwgb3V0KTtcbn1cblxuQk4ucHJvdG90eXBlLm11bFRvID0gZnVuY3Rpb24gbXVsVG8obnVtLCBvdXQpIHtcbiAgdmFyIHJlcztcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoICsgbnVtLmxlbmd0aDtcbiAgaWYgKHRoaXMubGVuZ3RoID09PSAxMCAmJiBudW0ubGVuZ3RoID09PSAxMClcbiAgICByZXMgPSBjb21iMTBNdWxUbyh0aGlzLCBudW0sIG91dCk7XG4gIGVsc2UgaWYgKGxlbiA8IDYzKVxuICAgIHJlcyA9IHNtYWxsTXVsVG8odGhpcywgbnVtLCBvdXQpO1xuICBlbHNlIGlmIChsZW4gPCAxMDI0KVxuICAgIHJlcyA9IGJpZ011bFRvKHRoaXMsIG51bSwgb3V0KTtcbiAgZWxzZVxuICAgIHJlcyA9IGp1bWJvTXVsVG8odGhpcywgbnVtLCBvdXQpO1xuICByZXR1cm4gcmVzO1xufTtcblxuLy8gQ29vbGV5LVR1a2V5IGFsZ29yaXRobSBmb3IgRkZUXG4vLyBzbGlnaHRseSByZXZpc2l0ZWQgdG8gcmVseSBvbiBsb29waW5nIGluc3RlYWQgb2YgcmVjdXJzaW9uXG5cbmZ1bmN0aW9uIEZGVE0oeCwgeSkge1xuICB0aGlzLnggPSB4O1xuICB0aGlzLnkgPSB5O1xufVxuXG5GRlRNLnByb3RvdHlwZS5tYWtlUkJUID0gZnVuY3Rpb24gbWFrZVJCVChOKSB7XG4gIHZhciB0ID0gbmV3IEFycmF5KE4pO1xuICB2YXIgbCA9IEJOLnByb3RvdHlwZS5fY291bnRCaXRzKE4pIC0gMTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBOOyBpKyspIHtcbiAgICB0W2ldID0gdGhpcy5yZXZCaW4oaSwgbCwgTik7XG4gIH1cblxuICByZXR1cm4gdDtcbn07XG5cbi8vIFJldHVybnMgYmluYXJ5LXJldmVyc2VkIHJlcHJlc2VudGF0aW9uIG9mIGB4YFxuRkZUTS5wcm90b3R5cGUucmV2QmluID0gZnVuY3Rpb24gcmV2QmluKHgsIGwsIE4pIHtcbiAgaWYgKHggPT09IDAgfHwgeCA9PT0gTiAtIDEpXG4gICAgcmV0dXJuIHg7XG5cbiAgdmFyIHJiID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICByYiB8PSAoeCAmIDEpIDw8IChsIC0gaSAtIDEpO1xuICAgIHggPj49IDE7XG4gIH1cblxuICByZXR1cm4gcmI7XG59O1xuXG4vLyBQZXJmb3JtcyBcInR3ZWVkbGluZ1wiIHBoYXNlLCB0aGVyZWZvcmUgJ2VtdWxhdGluZydcbi8vIGJlaGF2aW91ciBvZiB0aGUgcmVjdXJzaXZlIGFsZ29yaXRobVxuRkZUTS5wcm90b3R5cGUucGVybXV0ZSA9IGZ1bmN0aW9uIHBlcm11dGUocmJ0LCByd3MsIGl3cywgcnR3cywgaXR3cywgTikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IE47IGkrKykge1xuICAgIHJ0d3NbaV0gPSByd3NbcmJ0W2ldXTtcbiAgICBpdHdzW2ldID0gaXdzW3JidFtpXV07XG4gIH1cbn07XG5cbkZGVE0ucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uIHRyYW5zZm9ybShyd3MsIGl3cywgcnR3cywgaXR3cywgTiwgcmJ0KSB7XG4gIHRoaXMucGVybXV0ZShyYnQsIHJ3cywgaXdzLCBydHdzLCBpdHdzLCBOKTtcblxuICBmb3IgKHZhciBzID0gMTsgcyA8IE47IHMgPDw9IDEpIHtcbiAgICB2YXIgbCA9IHMgPDwgMTtcblxuICAgIHZhciBydHdkZiA9IE1hdGguY29zKDIgKiBNYXRoLlBJIC8gbCk7XG4gICAgdmFyIGl0d2RmID0gTWF0aC5zaW4oMiAqIE1hdGguUEkgLyBsKTtcblxuICAgIGZvciAodmFyIHAgPSAwOyBwIDwgTjsgcCArPSBsKSB7XG4gICAgICB2YXIgcnR3ZGZfID0gcnR3ZGY7XG4gICAgICB2YXIgaXR3ZGZfID0gaXR3ZGY7XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgczsgaisrKSB7XG4gICAgICAgIHZhciByZSA9IHJ0d3NbcCArIGpdO1xuICAgICAgICB2YXIgaWUgPSBpdHdzW3AgKyBqXTtcblxuICAgICAgICB2YXIgcm8gPSBydHdzW3AgKyBqICsgc107XG4gICAgICAgIHZhciBpbyA9IGl0d3NbcCArIGogKyBzXTtcblxuICAgICAgICB2YXIgcnggPSBydHdkZl8gKiBybyAtIGl0d2RmXyAqIGlvO1xuXG4gICAgICAgIGlvID0gcnR3ZGZfICogaW8gKyBpdHdkZl8gKiBybztcbiAgICAgICAgcm8gPSByeDtcblxuICAgICAgICBydHdzW3AgKyBqXSA9IHJlICsgcm87XG4gICAgICAgIGl0d3NbcCArIGpdID0gaWUgKyBpbztcblxuICAgICAgICBydHdzW3AgKyBqICsgc10gPSByZSAtIHJvO1xuICAgICAgICBpdHdzW3AgKyBqICsgc10gPSBpZSAtIGlvO1xuXG4gICAgICAgIC8qIGpzaGludCBtYXhkZXB0aCA6IGZhbHNlICovXG4gICAgICAgIGlmIChqICE9PSBsKSB7XG4gICAgICAgICAgcnggPSBydHdkZiAqIHJ0d2RmXyAtIGl0d2RmICogaXR3ZGZfO1xuXG4gICAgICAgICAgaXR3ZGZfID0gcnR3ZGYgKiBpdHdkZl8gKyBpdHdkZiAqIHJ0d2RmXztcbiAgICAgICAgICBydHdkZl8gPSByeDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuRkZUTS5wcm90b3R5cGUuZ3Vlc3NMZW4xM2IgPSBmdW5jdGlvbiBndWVzc0xlbjEzYihuLCBtKSB7XG4gIHZhciBOID0gTWF0aC5tYXgobSwgbikgfCAxO1xuICB2YXIgb2RkID0gTiAmIDE7XG4gIHZhciBpID0gMDtcbiAgZm9yIChOID0gTiAvIDIgfCAwOyBOOyBOID0gTiA+Pj4gMSkge1xuICAgIGkrKztcbiAgfVxuXG4gIHJldHVybiAxIDw8IGkgKyAxICsgb2RkO1xufTtcblxuRkZUTS5wcm90b3R5cGUuY29uanVnYXRlID0gZnVuY3Rpb24gY29uanVnYXRlKHJ3cywgaXdzLCBOKSB7XG4gIGlmIChOIDw9IDEpXG4gICAgcmV0dXJuO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgTiAvIDI7IGkrKykge1xuICAgIHZhciB0ID0gcndzW2ldO1xuXG4gICAgcndzW2ldID0gcndzW04gLSBpIC0gMV07XG4gICAgcndzW04gLSBpIC0gMV0gPSB0O1xuXG4gICAgdCA9IGl3c1tpXTtcblxuICAgIGl3c1tpXSA9IC1pd3NbTiAtIGkgLSAxXTtcbiAgICBpd3NbTiAtIGkgLSAxXSA9IC10O1xuICB9XG59O1xuXG5GRlRNLnByb3RvdHlwZS5ub3JtYWxpemUxM2IgPSBmdW5jdGlvbiBub3JtYWxpemUxM2Iod3MsIE4pIHtcbiAgdmFyIGNhcnJ5ID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBOIC8gMjsgaSsrKSB7XG4gICAgdmFyIHcgPSBNYXRoLnJvdW5kKHdzWzIgKiBpICsgMV0gLyBOKSAqIDB4MjAwMCArXG4gICAgICAgICAgICBNYXRoLnJvdW5kKHdzWzIgKiBpXSAvIE4pICtcbiAgICAgICAgICAgIGNhcnJ5O1xuXG4gICAgd3NbaV0gPSB3ICYgMHgzZmZmZmZmO1xuXG4gICAgaWYgKHcgPCAweDQwMDAwMDApIHtcbiAgICAgIGNhcnJ5ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FycnkgPSB3IC8gMHg0MDAwMDAwIHwgMDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gd3M7XG59O1xuXG5GRlRNLnByb3RvdHlwZS5jb252ZXJ0MTNiID0gZnVuY3Rpb24gY29udmVydDEzYih3cywgbGVuLCByd3MsIE4pIHtcbiAgdmFyIGNhcnJ5ID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBjYXJyeSA9IGNhcnJ5ICsgKHdzW2ldIHwgMCk7XG5cbiAgICByd3NbMiAqIGldICAgICA9IGNhcnJ5ICYgMHgxZmZmOyBjYXJyeSA9IGNhcnJ5ID4+PiAxMztcbiAgICByd3NbMiAqIGkgKyAxXSA9IGNhcnJ5ICYgMHgxZmZmOyBjYXJyeSA9IGNhcnJ5ID4+PiAxMztcbiAgfVxuXG4gIC8vIFBhZCB3aXRoIHplcm9lc1xuICBmb3IgKHZhciBpID0gMiAqIGxlbjsgaSA8IE47ICsraSlcbiAgICByd3NbaV0gPSAwO1xuXG4gIGFzc2VydChjYXJyeSA9PT0gMCk7XG4gIGFzc2VydCgoY2FycnkgJiB+MHgxZmZmKSA9PT0gMCk7XG59O1xuXG5GRlRNLnByb3RvdHlwZS5zdHViID0gZnVuY3Rpb24gc3R1YihOKSB7XG4gIHZhciBwaCA9IG5ldyBBcnJheShOKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBOOyBpKyspXG4gICAgcGhbaV0gPSAwO1xuXG4gIHJldHVybiBwaDtcbn07XG5cbkZGVE0ucHJvdG90eXBlLm11bHAgPSBmdW5jdGlvbiBtdWxwKHgsIHksIG91dCkge1xuICB2YXIgTiA9IDIgKiB0aGlzLmd1ZXNzTGVuMTNiKHgubGVuZ3RoLCB5Lmxlbmd0aCk7XG5cbiAgdmFyIHJidCA9IHRoaXMubWFrZVJCVChOKTtcblxuICB2YXIgXyA9IHRoaXMuc3R1YihOKTtcblxuICB2YXIgcndzICAgPSBuZXcgQXJyYXkoTik7XG4gIHZhciByd3N0ICA9IG5ldyBBcnJheShOKTtcbiAgdmFyIGl3c3QgID0gbmV3IEFycmF5KE4pO1xuXG4gIHZhciBucndzICA9IG5ldyBBcnJheShOKTtcbiAgdmFyIG5yd3N0ID0gbmV3IEFycmF5KE4pO1xuICB2YXIgbml3c3QgPSBuZXcgQXJyYXkoTik7XG5cbiAgdmFyIHJtd3MgPSBvdXQud29yZHM7XG4gIHJtd3MubGVuZ3RoID0gTjtcblxuICB0aGlzLmNvbnZlcnQxM2IoeC53b3JkcywgeC5sZW5ndGgsIHJ3cywgTik7XG4gIHRoaXMuY29udmVydDEzYih5LndvcmRzLCB5Lmxlbmd0aCwgbnJ3cywgTik7XG5cbiAgdGhpcy50cmFuc2Zvcm0ocndzLCBfLCByd3N0LCBpd3N0LCBOLCByYnQpO1xuICB0aGlzLnRyYW5zZm9ybShucndzLCBfLCBucndzdCwgbml3c3QsIE4sIHJidCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBOOyBpKyspIHtcbiAgICB2YXIgcnggPSByd3N0W2ldICogbnJ3c3RbaV0gLSBpd3N0W2ldICogbml3c3RbaV07XG4gICAgaXdzdFtpXSA9IHJ3c3RbaV0gKiBuaXdzdFtpXSArIGl3c3RbaV0gKiBucndzdFtpXTtcbiAgICByd3N0W2ldID0gcng7XG4gIH1cblxuICB0aGlzLmNvbmp1Z2F0ZShyd3N0LCBpd3N0LCBOKTtcblxuICB0aGlzLnRyYW5zZm9ybShyd3N0LCBpd3N0LCBybXdzLCBfLCBOLCByYnQpO1xuXG4gIHRoaXMuY29uanVnYXRlKHJtd3MsIF8sIE4pO1xuXG4gIHRoaXMubm9ybWFsaXplMTNiKHJtd3MsIE4pO1xuXG4gIG91dC5uZWdhdGl2ZSA9IHgubmVnYXRpdmUgXiB5Lm5lZ2F0aXZlO1xuICBvdXQubGVuZ3RoID0geC5sZW5ndGggKyB5Lmxlbmd0aDtcbiAgcmV0dXJuIG91dC5zdHJpcCgpO1xufTtcblxuLy8gTXVsdGlwbHkgYHRoaXNgIGJ5IGBudW1gXG5CTi5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gbXVsKG51bSkge1xuICB2YXIgb3V0ID0gbmV3IEJOKG51bGwpO1xuICBvdXQud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGggKyBudW0ubGVuZ3RoKTtcbiAgcmV0dXJuIHRoaXMubXVsVG8obnVtLCBvdXQpO1xufTtcblxuLy8gTXVsdGlwbHkgZW1wbG95aW5nIEZGVFxuQk4ucHJvdG90eXBlLm11bGYgPSBmdW5jdGlvbiBtdWxmKG51bSkge1xuICB2YXIgb3V0ID0gbmV3IEJOKG51bGwpO1xuICBvdXQud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGggKyBudW0ubGVuZ3RoKTtcbiAgcmV0dXJuIGp1bWJvTXVsVG8odGhpcywgbnVtLCBvdXQpO1xufTtcblxuLy8gSW4tcGxhY2UgTXVsdGlwbGljYXRpb25cbkJOLnByb3RvdHlwZS5pbXVsID0gZnVuY3Rpb24gaW11bChudW0pIHtcbiAgcmV0dXJuIHRoaXMuY2xvbmUoKS5tdWxUbyhudW0sIHRoaXMpO1xufTtcblxuQk4ucHJvdG90eXBlLmltdWxuID0gZnVuY3Rpb24gaW11bG4obnVtKSB7XG4gIGFzc2VydCh0eXBlb2YgbnVtID09PSAnbnVtYmVyJyk7XG5cbiAgLy8gQ2FycnlcbiAgdmFyIGNhcnJ5ID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHcgPSAodGhpcy53b3Jkc1tpXSB8IDApICogbnVtO1xuICAgIHZhciBsbyA9ICh3ICYgMHgzZmZmZmZmKSArIChjYXJyeSAmIDB4M2ZmZmZmZik7XG4gICAgY2FycnkgPj49IDI2O1xuICAgIGNhcnJ5ICs9ICh3IC8gMHg0MDAwMDAwKSB8IDA7XG4gICAgLy8gTk9URTogbG8gaXMgMjdiaXQgbWF4aW11bVxuICAgIGNhcnJ5ICs9IGxvID4+PiAyNjtcbiAgICB0aGlzLndvcmRzW2ldID0gbG8gJiAweDNmZmZmZmY7XG4gIH1cblxuICBpZiAoY2FycnkgIT09IDApIHtcbiAgICB0aGlzLndvcmRzW2ldID0gY2Fycnk7XG4gICAgdGhpcy5sZW5ndGgrKztcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuQk4ucHJvdG90eXBlLm11bG4gPSBmdW5jdGlvbiBtdWxuKG51bSkge1xuICByZXR1cm4gdGhpcy5jbG9uZSgpLmltdWxuKG51bSk7XG59O1xuXG4vLyBgdGhpc2AgKiBgdGhpc2BcbkJOLnByb3RvdHlwZS5zcXIgPSBmdW5jdGlvbiBzcXIoKSB7XG4gIHJldHVybiB0aGlzLm11bCh0aGlzKTtcbn07XG5cbi8vIGB0aGlzYCAqIGB0aGlzYCBpbi1wbGFjZVxuQk4ucHJvdG90eXBlLmlzcXIgPSBmdW5jdGlvbiBpc3FyKCkge1xuICByZXR1cm4gdGhpcy5pbXVsKHRoaXMuY2xvbmUoKSk7XG59O1xuXG4vLyBNYXRoLnBvdyhgdGhpc2AsIGBudW1gKVxuQk4ucHJvdG90eXBlLnBvdyA9IGZ1bmN0aW9uIHBvdyhudW0pIHtcbiAgdmFyIHcgPSB0b0JpdEFycmF5KG51bSk7XG4gIGlmICh3Lmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm4gbmV3IEJOKDEpO1xuXG4gIC8vIFNraXAgbGVhZGluZyB6ZXJvZXNcbiAgdmFyIHJlcyA9IHRoaXM7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdy5sZW5ndGg7IGkrKywgcmVzID0gcmVzLnNxcigpKVxuICAgIGlmICh3W2ldICE9PSAwKVxuICAgICAgYnJlYWs7XG5cbiAgaWYgKCsraSA8IHcubGVuZ3RoKSB7XG4gICAgZm9yICh2YXIgcSA9IHJlcy5zcXIoKTsgaSA8IHcubGVuZ3RoOyBpKyssIHEgPSBxLnNxcigpKSB7XG4gICAgICBpZiAod1tpXSA9PT0gMClcbiAgICAgICAgY29udGludWU7XG4gICAgICByZXMgPSByZXMubXVsKHEpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuXG4vLyBTaGlmdC1sZWZ0IGluLXBsYWNlXG5CTi5wcm90b3R5cGUuaXVzaGxuID0gZnVuY3Rpb24gaXVzaGxuKGJpdHMpIHtcbiAgYXNzZXJ0KHR5cGVvZiBiaXRzID09PSAnbnVtYmVyJyAmJiBiaXRzID49IDApO1xuICB2YXIgciA9IGJpdHMgJSAyNjtcbiAgdmFyIHMgPSAoYml0cyAtIHIpIC8gMjY7XG4gIHZhciBjYXJyeU1hc2sgPSAoMHgzZmZmZmZmID4+PiAoMjYgLSByKSkgPDwgKDI2IC0gcik7XG5cbiAgaWYgKHIgIT09IDApIHtcbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5ld0NhcnJ5ID0gdGhpcy53b3Jkc1tpXSAmIGNhcnJ5TWFzaztcbiAgICAgIHZhciBjID0gKCh0aGlzLndvcmRzW2ldIHwgMCkgLSBuZXdDYXJyeSkgPDwgcjtcbiAgICAgIHRoaXMud29yZHNbaV0gPSBjIHwgY2Fycnk7XG4gICAgICBjYXJyeSA9IG5ld0NhcnJ5ID4+PiAoMjYgLSByKTtcbiAgICB9XG4gICAgaWYgKGNhcnJ5KSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gY2Fycnk7XG4gICAgICB0aGlzLmxlbmd0aCsrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzICE9PSAwKSB7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICB0aGlzLndvcmRzW2kgKyBzXSA9IHRoaXMud29yZHNbaV07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzOyBpKyspXG4gICAgICB0aGlzLndvcmRzW2ldID0gMDtcbiAgICB0aGlzLmxlbmd0aCArPSBzO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbn07XG5cbkJOLnByb3RvdHlwZS5pc2hsbiA9IGZ1bmN0aW9uIGlzaGxuKGJpdHMpIHtcbiAgLy8gVE9ETyhpbmR1dG55KTogaW1wbGVtZW50IG1lXG4gIGFzc2VydCh0aGlzLm5lZ2F0aXZlID09PSAwKTtcbiAgcmV0dXJuIHRoaXMuaXVzaGxuKGJpdHMpO1xufTtcblxuLy8gU2hpZnQtcmlnaHQgaW4tcGxhY2Vcbi8vIE5PVEU6IGBoaW50YCBpcyBhIGxvd2VzdCBiaXQgYmVmb3JlIHRyYWlsaW5nIHplcm9lc1xuLy8gTk9URTogaWYgYGV4dGVuZGVkYCBpcyBwcmVzZW50IC0gaXQgd2lsbCBiZSBmaWxsZWQgd2l0aCBkZXN0cm95ZWQgYml0c1xuQk4ucHJvdG90eXBlLml1c2hybiA9IGZ1bmN0aW9uIGl1c2hybihiaXRzLCBoaW50LCBleHRlbmRlZCkge1xuICBhc3NlcnQodHlwZW9mIGJpdHMgPT09ICdudW1iZXInICYmIGJpdHMgPj0gMCk7XG4gIHZhciBoO1xuICBpZiAoaGludClcbiAgICBoID0gKGhpbnQgLSAoaGludCAlIDI2KSkgLyAyNjtcbiAgZWxzZVxuICAgIGggPSAwO1xuXG4gIHZhciByID0gYml0cyAlIDI2O1xuICB2YXIgcyA9IE1hdGgubWluKChiaXRzIC0gcikgLyAyNiwgdGhpcy5sZW5ndGgpO1xuICB2YXIgbWFzayA9IDB4M2ZmZmZmZiBeICgoMHgzZmZmZmZmID4+PiByKSA8PCByKTtcbiAgdmFyIG1hc2tlZFdvcmRzID0gZXh0ZW5kZWQ7XG5cbiAgaCAtPSBzO1xuICBoID0gTWF0aC5tYXgoMCwgaCk7XG5cbiAgLy8gRXh0ZW5kZWQgbW9kZSwgY29weSBtYXNrZWQgcGFydFxuICBpZiAobWFza2VkV29yZHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHM7IGkrKylcbiAgICAgIG1hc2tlZFdvcmRzLndvcmRzW2ldID0gdGhpcy53b3Jkc1tpXTtcbiAgICBtYXNrZWRXb3Jkcy5sZW5ndGggPSBzO1xuICB9XG5cbiAgaWYgKHMgPT09IDApIHtcbiAgICAvLyBOby1vcCwgd2Ugc2hvdWxkIG5vdCBtb3ZlIGFueXRoaW5nIGF0IGFsbFxuICB9IGVsc2UgaWYgKHRoaXMubGVuZ3RoID4gcykge1xuICAgIHRoaXMubGVuZ3RoIC09IHM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKVxuICAgICAgdGhpcy53b3Jkc1tpXSA9IHRoaXMud29yZHNbaSArIHNdO1xuICB9IGVsc2Uge1xuICAgIHRoaXMud29yZHNbMF0gPSAwO1xuICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgfVxuXG4gIHZhciBjYXJyeSA9IDA7XG4gIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMCAmJiAoY2FycnkgIT09IDAgfHwgaSA+PSBoKTsgaS0tKSB7XG4gICAgdmFyIHdvcmQgPSB0aGlzLndvcmRzW2ldIHwgMDtcbiAgICB0aGlzLndvcmRzW2ldID0gKGNhcnJ5IDw8ICgyNiAtIHIpKSB8ICh3b3JkID4+PiByKTtcbiAgICBjYXJyeSA9IHdvcmQgJiBtYXNrO1xuICB9XG5cbiAgLy8gUHVzaCBjYXJyaWVkIGJpdHMgYXMgYSBtYXNrXG4gIGlmIChtYXNrZWRXb3JkcyAmJiBjYXJyeSAhPT0gMClcbiAgICBtYXNrZWRXb3Jkcy53b3Jkc1ttYXNrZWRXb3Jkcy5sZW5ndGgrK10gPSBjYXJyeTtcblxuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHtcbiAgICB0aGlzLndvcmRzWzBdID0gMDtcbiAgICB0aGlzLmxlbmd0aCA9IDE7XG4gIH1cblxuICByZXR1cm4gdGhpcy5zdHJpcCgpO1xufTtcblxuQk4ucHJvdG90eXBlLmlzaHJuID0gZnVuY3Rpb24gaXNocm4oYml0cywgaGludCwgZXh0ZW5kZWQpIHtcbiAgLy8gVE9ETyhpbmR1dG55KTogaW1wbGVtZW50IG1lXG4gIGFzc2VydCh0aGlzLm5lZ2F0aXZlID09PSAwKTtcbiAgcmV0dXJuIHRoaXMuaXVzaHJuKGJpdHMsIGhpbnQsIGV4dGVuZGVkKTtcbn07XG5cbi8vIFNoaWZ0LWxlZnRcbkJOLnByb3RvdHlwZS5zaGxuID0gZnVuY3Rpb24gc2hsbihiaXRzKSB7XG4gIHJldHVybiB0aGlzLmNsb25lKCkuaXNobG4oYml0cyk7XG59O1xuXG5CTi5wcm90b3R5cGUudXNobG4gPSBmdW5jdGlvbiB1c2hsbihiaXRzKSB7XG4gIHJldHVybiB0aGlzLmNsb25lKCkuaXVzaGxuKGJpdHMpO1xufTtcblxuLy8gU2hpZnQtcmlnaHRcbkJOLnByb3RvdHlwZS5zaHJuID0gZnVuY3Rpb24gc2hybihiaXRzKSB7XG4gIHJldHVybiB0aGlzLmNsb25lKCkuaXNocm4oYml0cyk7XG59O1xuXG5CTi5wcm90b3R5cGUudXNocm4gPSBmdW5jdGlvbiB1c2hybihiaXRzKSB7XG4gIHJldHVybiB0aGlzLmNsb25lKCkuaXVzaHJuKGJpdHMpO1xufTtcblxuLy8gVGVzdCBpZiBuIGJpdCBpcyBzZXRcbkJOLnByb3RvdHlwZS50ZXN0biA9IGZ1bmN0aW9uIHRlc3RuKGJpdCkge1xuICBhc3NlcnQodHlwZW9mIGJpdCA9PT0gJ251bWJlcicgJiYgYml0ID49IDApO1xuICB2YXIgciA9IGJpdCAlIDI2O1xuICB2YXIgcyA9IChiaXQgLSByKSAvIDI2O1xuICB2YXIgcSA9IDEgPDwgcjtcblxuICAvLyBGYXN0IGNhc2U6IGJpdCBpcyBtdWNoIGhpZ2hlciB0aGFuIGFsbCBleGlzdGluZyB3b3Jkc1xuICBpZiAodGhpcy5sZW5ndGggPD0gcykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIENoZWNrIGJpdCBhbmQgcmV0dXJuXG4gIHZhciB3ID0gdGhpcy53b3Jkc1tzXTtcblxuICByZXR1cm4gISEodyAmIHEpO1xufTtcblxuLy8gUmV0dXJuIG9ubHkgbG93ZXJzIGJpdHMgb2YgbnVtYmVyIChpbi1wbGFjZSlcbkJOLnByb3RvdHlwZS5pbWFza24gPSBmdW5jdGlvbiBpbWFza24oYml0cykge1xuICBhc3NlcnQodHlwZW9mIGJpdHMgPT09ICdudW1iZXInICYmIGJpdHMgPj0gMCk7XG4gIHZhciByID0gYml0cyAlIDI2O1xuICB2YXIgcyA9IChiaXRzIC0gcikgLyAyNjtcblxuICBhc3NlcnQodGhpcy5uZWdhdGl2ZSA9PT0gMCwgJ2ltYXNrbiB3b3JrcyBvbmx5IHdpdGggcG9zaXRpdmUgbnVtYmVycycpO1xuXG4gIGlmIChyICE9PSAwKVxuICAgIHMrKztcbiAgdGhpcy5sZW5ndGggPSBNYXRoLm1pbihzLCB0aGlzLmxlbmd0aCk7XG5cbiAgaWYgKHIgIT09IDApIHtcbiAgICB2YXIgbWFzayA9IDB4M2ZmZmZmZiBeICgoMHgzZmZmZmZmID4+PiByKSA8PCByKTtcbiAgICB0aGlzLndvcmRzW3RoaXMubGVuZ3RoIC0gMV0gJj0gbWFzaztcbiAgfVxuXG4gIHJldHVybiB0aGlzLnN0cmlwKCk7XG59O1xuXG4vLyBSZXR1cm4gb25seSBsb3dlcnMgYml0cyBvZiBudW1iZXJcbkJOLnByb3RvdHlwZS5tYXNrbiA9IGZ1bmN0aW9uIG1hc2tuKGJpdHMpIHtcbiAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pbWFza24oYml0cyk7XG59O1xuXG4vLyBBZGQgcGxhaW4gbnVtYmVyIGBudW1gIHRvIGB0aGlzYFxuQk4ucHJvdG90eXBlLmlhZGRuID0gZnVuY3Rpb24gaWFkZG4obnVtKSB7XG4gIGFzc2VydCh0eXBlb2YgbnVtID09PSAnbnVtYmVyJyk7XG4gIGlmIChudW0gPCAwKVxuICAgIHJldHVybiB0aGlzLmlzdWJuKC1udW0pO1xuXG4gIC8vIFBvc3NpYmxlIHNpZ24gY2hhbmdlXG4gIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxICYmICh0aGlzLndvcmRzWzBdIHwgMCkgPCBudW0pIHtcbiAgICAgIHRoaXMud29yZHNbMF0gPSBudW0gLSAodGhpcy53b3Jkc1swXSB8IDApO1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICB0aGlzLmlzdWJuKG51bSk7XG4gICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBBZGQgd2l0aG91dCBjaGVja3NcbiAgcmV0dXJuIHRoaXMuX2lhZGRuKG51bSk7XG59O1xuXG5CTi5wcm90b3R5cGUuX2lhZGRuID0gZnVuY3Rpb24gX2lhZGRuKG51bSkge1xuICB0aGlzLndvcmRzWzBdICs9IG51bTtcblxuICAvLyBDYXJyeVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoICYmIHRoaXMud29yZHNbaV0gPj0gMHg0MDAwMDAwOyBpKyspIHtcbiAgICB0aGlzLndvcmRzW2ldIC09IDB4NDAwMDAwMDtcbiAgICBpZiAoaSA9PT0gdGhpcy5sZW5ndGggLSAxKVxuICAgICAgdGhpcy53b3Jkc1tpICsgMV0gPSAxO1xuICAgIGVsc2VcbiAgICAgIHRoaXMud29yZHNbaSArIDFdKys7XG4gIH1cbiAgdGhpcy5sZW5ndGggPSBNYXRoLm1heCh0aGlzLmxlbmd0aCwgaSArIDEpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gU3VidHJhY3QgcGxhaW4gbnVtYmVyIGBudW1gIGZyb20gYHRoaXNgXG5CTi5wcm90b3R5cGUuaXN1Ym4gPSBmdW5jdGlvbiBpc3VibihudW0pIHtcbiAgYXNzZXJ0KHR5cGVvZiBudW0gPT09ICdudW1iZXInKTtcbiAgaWYgKG51bSA8IDApXG4gICAgcmV0dXJuIHRoaXMuaWFkZG4oLW51bSk7XG5cbiAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICB0aGlzLmlhZGRuKG51bSk7XG4gICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB0aGlzLndvcmRzWzBdIC09IG51bTtcblxuICBpZiAodGhpcy5sZW5ndGggPT09IDEgJiYgdGhpcy53b3Jkc1swXSA8IDApIHtcbiAgICB0aGlzLndvcmRzWzBdID0gLXRoaXMud29yZHNbMF07XG4gICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gIH0gZWxzZSB7XG4gICAgLy8gQ2FycnlcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoICYmIHRoaXMud29yZHNbaV0gPCAwOyBpKyspIHtcbiAgICAgIHRoaXMud29yZHNbaV0gKz0gMHg0MDAwMDAwO1xuICAgICAgdGhpcy53b3Jkc1tpICsgMV0gLT0gMTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcy5zdHJpcCgpO1xufTtcblxuQk4ucHJvdG90eXBlLmFkZG4gPSBmdW5jdGlvbiBhZGRuKG51bSkge1xuICByZXR1cm4gdGhpcy5jbG9uZSgpLmlhZGRuKG51bSk7XG59O1xuXG5CTi5wcm90b3R5cGUuc3VibiA9IGZ1bmN0aW9uIHN1Ym4obnVtKSB7XG4gIHJldHVybiB0aGlzLmNsb25lKCkuaXN1Ym4obnVtKTtcbn07XG5cbkJOLnByb3RvdHlwZS5pYWJzID0gZnVuY3Rpb24gaWFicygpIHtcbiAgdGhpcy5uZWdhdGl2ZSA9IDA7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5CTi5wcm90b3R5cGUuYWJzID0gZnVuY3Rpb24gYWJzKCkge1xuICByZXR1cm4gdGhpcy5jbG9uZSgpLmlhYnMoKTtcbn07XG5cbkJOLnByb3RvdHlwZS5faXNobG5zdWJtdWwgPSBmdW5jdGlvbiBfaXNobG5zdWJtdWwobnVtLCBtdWwsIHNoaWZ0KSB7XG4gIC8vIEJpZ2dlciBzdG9yYWdlIGlzIG5lZWRlZFxuICB2YXIgbGVuID0gbnVtLmxlbmd0aCArIHNoaWZ0O1xuICB2YXIgaTtcbiAgaWYgKHRoaXMud29yZHMubGVuZ3RoIDwgbGVuKSB7XG4gICAgdmFyIHQgPSBuZXcgQXJyYXkobGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspXG4gICAgICB0W2ldID0gdGhpcy53b3Jkc1tpXTtcbiAgICB0aGlzLndvcmRzID0gdDtcbiAgfSBlbHNlIHtcbiAgICBpID0gdGhpcy5sZW5ndGg7XG4gIH1cblxuICAvLyBaZXJvaWZ5IHJlc3RcbiAgdGhpcy5sZW5ndGggPSBNYXRoLm1heCh0aGlzLmxlbmd0aCwgbGVuKTtcbiAgZm9yICg7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKVxuICAgIHRoaXMud29yZHNbaV0gPSAwO1xuXG4gIHZhciBjYXJyeSA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHcgPSAodGhpcy53b3Jkc1tpICsgc2hpZnRdIHwgMCkgKyBjYXJyeTtcbiAgICB2YXIgcmlnaHQgPSAobnVtLndvcmRzW2ldIHwgMCkgKiBtdWw7XG4gICAgdyAtPSByaWdodCAmIDB4M2ZmZmZmZjtcbiAgICBjYXJyeSA9ICh3ID4+IDI2KSAtICgocmlnaHQgLyAweDQwMDAwMDApIHwgMCk7XG4gICAgdGhpcy53b3Jkc1tpICsgc2hpZnRdID0gdyAmIDB4M2ZmZmZmZjtcbiAgfVxuICBmb3IgKDsgaSA8IHRoaXMubGVuZ3RoIC0gc2hpZnQ7IGkrKykge1xuICAgIHZhciB3ID0gKHRoaXMud29yZHNbaSArIHNoaWZ0XSB8IDApICsgY2Fycnk7XG4gICAgY2FycnkgPSB3ID4+IDI2O1xuICAgIHRoaXMud29yZHNbaSArIHNoaWZ0XSA9IHcgJiAweDNmZmZmZmY7XG4gIH1cblxuICBpZiAoY2FycnkgPT09IDApXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcblxuICAvLyBTdWJ0cmFjdGlvbiBvdmVyZmxvd1xuICBhc3NlcnQoY2FycnkgPT09IC0xKTtcbiAgY2FycnkgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdyA9IC0odGhpcy53b3Jkc1tpXSB8IDApICsgY2Fycnk7XG4gICAgY2FycnkgPSB3ID4+IDI2O1xuICAgIHRoaXMud29yZHNbaV0gPSB3ICYgMHgzZmZmZmZmO1xuICB9XG4gIHRoaXMubmVnYXRpdmUgPSAxO1xuXG4gIHJldHVybiB0aGlzLnN0cmlwKCk7XG59O1xuXG5CTi5wcm90b3R5cGUuX3dvcmREaXYgPSBmdW5jdGlvbiBfd29yZERpdihudW0sIG1vZGUpIHtcbiAgdmFyIHNoaWZ0ID0gdGhpcy5sZW5ndGggLSBudW0ubGVuZ3RoO1xuXG4gIHZhciBhID0gdGhpcy5jbG9uZSgpO1xuICB2YXIgYiA9IG51bTtcblxuICAvLyBOb3JtYWxpemVcbiAgdmFyIGJoaSA9IGIud29yZHNbYi5sZW5ndGggLSAxXSB8IDA7XG4gIHZhciBiaGlCaXRzID0gdGhpcy5fY291bnRCaXRzKGJoaSk7XG4gIHNoaWZ0ID0gMjYgLSBiaGlCaXRzO1xuICBpZiAoc2hpZnQgIT09IDApIHtcbiAgICBiID0gYi51c2hsbihzaGlmdCk7XG4gICAgYS5pdXNobG4oc2hpZnQpO1xuICAgIGJoaSA9IGIud29yZHNbYi5sZW5ndGggLSAxXSB8IDA7XG4gIH1cblxuICAvLyBJbml0aWFsaXplIHF1b3RpZW50XG4gIHZhciBtID0gYS5sZW5ndGggLSBiLmxlbmd0aDtcbiAgdmFyIHE7XG5cbiAgaWYgKG1vZGUgIT09ICdtb2QnKSB7XG4gICAgcSA9IG5ldyBCTihudWxsKTtcbiAgICBxLmxlbmd0aCA9IG0gKyAxO1xuICAgIHEud29yZHMgPSBuZXcgQXJyYXkocS5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcS5sZW5ndGg7IGkrKylcbiAgICAgIHEud29yZHNbaV0gPSAwO1xuICB9XG5cbiAgdmFyIGRpZmYgPSBhLmNsb25lKCkuX2lzaGxuc3VibXVsKGIsIDEsIG0pO1xuICBpZiAoZGlmZi5uZWdhdGl2ZSA9PT0gMCkge1xuICAgIGEgPSBkaWZmO1xuICAgIGlmIChxKVxuICAgICAgcS53b3Jkc1ttXSA9IDE7XG4gIH1cblxuICBmb3IgKHZhciBqID0gbSAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgdmFyIHFqID0gKGEud29yZHNbYi5sZW5ndGggKyBqXSB8IDApICogMHg0MDAwMDAwICtcbiAgICAgICAgICAgICAoYS53b3Jkc1tiLmxlbmd0aCArIGogLSAxXSB8IDApO1xuXG4gICAgLy8gTk9URTogKHFqIC8gYmhpKSBpcyAoMHgzZmZmZmZmICogMHg0MDAwMDAwICsgMHgzZmZmZmZmKSAvIDB4MjAwMDAwMCBtYXhcbiAgICAvLyAoMHg3ZmZmZmZmKVxuICAgIHFqID0gTWF0aC5taW4oKHFqIC8gYmhpKSB8IDAsIDB4M2ZmZmZmZik7XG5cbiAgICBhLl9pc2hsbnN1Ym11bChiLCBxaiwgaik7XG4gICAgd2hpbGUgKGEubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIHFqLS07XG4gICAgICBhLm5lZ2F0aXZlID0gMDtcbiAgICAgIGEuX2lzaGxuc3VibXVsKGIsIDEsIGopO1xuICAgICAgaWYgKGEuY21wbigwKSAhPT0gMClcbiAgICAgICAgYS5uZWdhdGl2ZSBePSAxO1xuICAgIH1cbiAgICBpZiAocSlcbiAgICAgIHEud29yZHNbal0gPSBxajtcbiAgfVxuICBpZiAocSlcbiAgICBxLnN0cmlwKCk7XG4gIGEuc3RyaXAoKTtcblxuICAvLyBEZW5vcm1hbGl6ZVxuICBpZiAobW9kZSAhPT0gJ2RpdicgJiYgc2hpZnQgIT09IDApXG4gICAgYS5pdXNocm4oc2hpZnQpO1xuICByZXR1cm4geyBkaXY6IHEgPyBxIDogbnVsbCwgbW9kOiBhIH07XG59O1xuXG5CTi5wcm90b3R5cGUuZGl2bW9kID0gZnVuY3Rpb24gZGl2bW9kKG51bSwgbW9kZSwgcG9zaXRpdmUpIHtcbiAgYXNzZXJ0KG51bS5jbXBuKDApICE9PSAwKTtcblxuICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCAmJiBudW0ubmVnYXRpdmUgPT09IDApIHtcbiAgICB2YXIgcmVzID0gdGhpcy5uZWcoKS5kaXZtb2QobnVtLCBtb2RlKTtcbiAgICB2YXIgZGl2O1xuICAgIHZhciBtb2Q7XG4gICAgaWYgKG1vZGUgIT09ICdtb2QnKVxuICAgICAgZGl2ID0gcmVzLmRpdi5uZWcoKTtcbiAgICBpZiAobW9kZSAhPT0gJ2RpdicpIHtcbiAgICAgIG1vZCA9IHJlcy5tb2QubmVnKCk7XG4gICAgICBpZiAocG9zaXRpdmUgJiYgbW9kLm5lZylcbiAgICAgICAgbW9kID0gbW9kLmFkZChudW0pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgZGl2OiBkaXYsXG4gICAgICBtb2Q6IG1vZFxuICAgIH07XG4gIH0gZWxzZSBpZiAodGhpcy5uZWdhdGl2ZSA9PT0gMCAmJiBudW0ubmVnYXRpdmUgIT09IDApIHtcbiAgICB2YXIgcmVzID0gdGhpcy5kaXZtb2QobnVtLm5lZygpLCBtb2RlKTtcbiAgICB2YXIgZGl2O1xuICAgIGlmIChtb2RlICE9PSAnbW9kJylcbiAgICAgIGRpdiA9IHJlcy5kaXYubmVnKCk7XG4gICAgcmV0dXJuIHsgZGl2OiBkaXYsIG1vZDogcmVzLm1vZCB9O1xuICB9IGVsc2UgaWYgKCh0aGlzLm5lZ2F0aXZlICYgbnVtLm5lZ2F0aXZlKSAhPT0gMCkge1xuICAgIHZhciByZXMgPSB0aGlzLm5lZygpLmRpdm1vZChudW0ubmVnKCksIG1vZGUpO1xuICAgIHZhciBtb2Q7XG4gICAgaWYgKG1vZGUgIT09ICdkaXYnKSB7XG4gICAgICBtb2QgPSByZXMubW9kLm5lZygpO1xuICAgICAgaWYgKHBvc2l0aXZlICYmIG1vZC5uZWcpXG4gICAgICAgIG1vZCA9IG1vZC5pc3ViKG51bSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBkaXY6IHJlcy5kaXYsXG4gICAgICBtb2Q6IG1vZFxuICAgIH07XG4gIH1cblxuICAvLyBCb3RoIG51bWJlcnMgYXJlIHBvc2l0aXZlIGF0IHRoaXMgcG9pbnRcblxuICAvLyBTdHJpcCBib3RoIG51bWJlcnMgdG8gYXBwcm94aW1hdGUgc2hpZnQgdmFsdWVcbiAgaWYgKG51bS5sZW5ndGggPiB0aGlzLmxlbmd0aCB8fCB0aGlzLmNtcChudW0pIDwgMClcbiAgICByZXR1cm4geyBkaXY6IG5ldyBCTigwKSwgbW9kOiB0aGlzIH07XG5cbiAgLy8gVmVyeSBzaG9ydCByZWR1Y3Rpb25cbiAgaWYgKG51bS5sZW5ndGggPT09IDEpIHtcbiAgICBpZiAobW9kZSA9PT0gJ2RpdicpXG4gICAgICByZXR1cm4geyBkaXY6IHRoaXMuZGl2bihudW0ud29yZHNbMF0pLCBtb2Q6IG51bGwgfTtcbiAgICBlbHNlIGlmIChtb2RlID09PSAnbW9kJylcbiAgICAgIHJldHVybiB7IGRpdjogbnVsbCwgbW9kOiBuZXcgQk4odGhpcy5tb2RuKG51bS53b3Jkc1swXSkpIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIGRpdjogdGhpcy5kaXZuKG51bS53b3Jkc1swXSksXG4gICAgICBtb2Q6IG5ldyBCTih0aGlzLm1vZG4obnVtLndvcmRzWzBdKSlcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuX3dvcmREaXYobnVtLCBtb2RlKTtcbn07XG5cbi8vIEZpbmQgYHRoaXNgIC8gYG51bWBcbkJOLnByb3RvdHlwZS5kaXYgPSBmdW5jdGlvbiBkaXYobnVtKSB7XG4gIHJldHVybiB0aGlzLmRpdm1vZChudW0sICdkaXYnLCBmYWxzZSkuZGl2O1xufTtcblxuLy8gRmluZCBgdGhpc2AgJSBgbnVtYFxuQk4ucHJvdG90eXBlLm1vZCA9IGZ1bmN0aW9uIG1vZChudW0pIHtcbiAgcmV0dXJuIHRoaXMuZGl2bW9kKG51bSwgJ21vZCcsIGZhbHNlKS5tb2Q7XG59O1xuXG5CTi5wcm90b3R5cGUudW1vZCA9IGZ1bmN0aW9uIHVtb2QobnVtKSB7XG4gIHJldHVybiB0aGlzLmRpdm1vZChudW0sICdtb2QnLCB0cnVlKS5tb2Q7XG59O1xuXG4vLyBGaW5kIFJvdW5kKGB0aGlzYCAvIGBudW1gKVxuQk4ucHJvdG90eXBlLmRpdlJvdW5kID0gZnVuY3Rpb24gZGl2Um91bmQobnVtKSB7XG4gIHZhciBkbSA9IHRoaXMuZGl2bW9kKG51bSk7XG5cbiAgLy8gRmFzdCBjYXNlIC0gZXhhY3QgZGl2aXNpb25cbiAgaWYgKGRtLm1vZC5jbXBuKDApID09PSAwKVxuICAgIHJldHVybiBkbS5kaXY7XG5cbiAgdmFyIG1vZCA9IGRtLmRpdi5uZWdhdGl2ZSAhPT0gMCA/IGRtLm1vZC5pc3ViKG51bSkgOiBkbS5tb2Q7XG5cbiAgdmFyIGhhbGYgPSBudW0udXNocm4oMSk7XG4gIHZhciByMiA9IG51bS5hbmRsbigxKTtcbiAgdmFyIGNtcCA9IG1vZC5jbXAoaGFsZik7XG5cbiAgLy8gUm91bmQgZG93blxuICBpZiAoY21wIDwgMCB8fCByMiA9PT0gMSAmJiBjbXAgPT09IDApXG4gICAgcmV0dXJuIGRtLmRpdjtcblxuICAvLyBSb3VuZCB1cFxuICByZXR1cm4gZG0uZGl2Lm5lZ2F0aXZlICE9PSAwID8gZG0uZGl2LmlzdWJuKDEpIDogZG0uZGl2LmlhZGRuKDEpO1xufTtcblxuQk4ucHJvdG90eXBlLm1vZG4gPSBmdW5jdGlvbiBtb2RuKG51bSkge1xuICBhc3NlcnQobnVtIDw9IDB4M2ZmZmZmZik7XG4gIHZhciBwID0gKDEgPDwgMjYpICUgbnVtO1xuXG4gIHZhciBhY2MgPSAwO1xuICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICBhY2MgPSAocCAqIGFjYyArICh0aGlzLndvcmRzW2ldIHwgMCkpICUgbnVtO1xuXG4gIHJldHVybiBhY2M7XG59O1xuXG4vLyBJbi1wbGFjZSBkaXZpc2lvbiBieSBudW1iZXJcbkJOLnByb3RvdHlwZS5pZGl2biA9IGZ1bmN0aW9uIGlkaXZuKG51bSkge1xuICBhc3NlcnQobnVtIDw9IDB4M2ZmZmZmZik7XG5cbiAgdmFyIGNhcnJ5ID0gMDtcbiAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgdyA9ICh0aGlzLndvcmRzW2ldIHwgMCkgKyBjYXJyeSAqIDB4NDAwMDAwMDtcbiAgICB0aGlzLndvcmRzW2ldID0gKHcgLyBudW0pIHwgMDtcbiAgICBjYXJyeSA9IHcgJSBudW07XG4gIH1cblxuICByZXR1cm4gdGhpcy5zdHJpcCgpO1xufTtcblxuQk4ucHJvdG90eXBlLmRpdm4gPSBmdW5jdGlvbiBkaXZuKG51bSkge1xuICByZXR1cm4gdGhpcy5jbG9uZSgpLmlkaXZuKG51bSk7XG59O1xuXG5CTi5wcm90b3R5cGUuZWdjZCA9IGZ1bmN0aW9uIGVnY2QocCkge1xuICBhc3NlcnQocC5uZWdhdGl2ZSA9PT0gMCk7XG4gIGFzc2VydChwLmNtcG4oMCkgIT09IDApO1xuXG4gIHZhciB4ID0gdGhpcztcbiAgdmFyIHkgPSBwLmNsb25lKCk7XG5cbiAgaWYgKHgubmVnYXRpdmUgIT09IDApXG4gICAgeCA9IHgudW1vZChwKTtcbiAgZWxzZVxuICAgIHggPSB4LmNsb25lKCk7XG5cbiAgLy8gQSAqIHggKyBCICogeSA9IHhcbiAgdmFyIEEgPSBuZXcgQk4oMSk7XG4gIHZhciBCID0gbmV3IEJOKDApO1xuXG4gIC8vIEMgKiB4ICsgRCAqIHkgPSB5XG4gIHZhciBDID0gbmV3IEJOKDApO1xuICB2YXIgRCA9IG5ldyBCTigxKTtcblxuICB2YXIgZyA9IDA7XG5cbiAgd2hpbGUgKHguaXNFdmVuKCkgJiYgeS5pc0V2ZW4oKSkge1xuICAgIHguaXVzaHJuKDEpO1xuICAgIHkuaXVzaHJuKDEpO1xuICAgICsrZztcbiAgfVxuXG4gIHZhciB5cCA9IHkuY2xvbmUoKTtcbiAgdmFyIHhwID0geC5jbG9uZSgpO1xuXG4gIHdoaWxlICh4LmNtcG4oMCkgIT09IDApIHtcbiAgICB3aGlsZSAoeC5pc0V2ZW4oKSkge1xuICAgICAgeC5pdXNocm4oMSk7XG4gICAgICBpZiAoQS5pc0V2ZW4oKSAmJiBCLmlzRXZlbigpKSB7XG4gICAgICAgIEEuaXVzaHJuKDEpO1xuICAgICAgICBCLml1c2hybigxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIEEuaWFkZCh5cCkuaXVzaHJuKDEpO1xuICAgICAgICBCLmlzdWIoeHApLml1c2hybigxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB3aGlsZSAoeS5pc0V2ZW4oKSkge1xuICAgICAgeS5pdXNocm4oMSk7XG4gICAgICBpZiAoQy5pc0V2ZW4oKSAmJiBELmlzRXZlbigpKSB7XG4gICAgICAgIEMuaXVzaHJuKDEpO1xuICAgICAgICBELml1c2hybigxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIEMuaWFkZCh5cCkuaXVzaHJuKDEpO1xuICAgICAgICBELmlzdWIoeHApLml1c2hybigxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoeC5jbXAoeSkgPj0gMCkge1xuICAgICAgeC5pc3ViKHkpO1xuICAgICAgQS5pc3ViKEMpO1xuICAgICAgQi5pc3ViKEQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB5LmlzdWIoeCk7XG4gICAgICBDLmlzdWIoQSk7XG4gICAgICBELmlzdWIoQik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBhOiBDLFxuICAgIGI6IEQsXG4gICAgZ2NkOiB5Lml1c2hsbihnKVxuICB9O1xufTtcblxuLy8gVGhpcyBpcyByZWR1Y2VkIGluY2FybmF0aW9uIG9mIHRoZSBiaW5hcnkgRUVBXG4vLyBhYm92ZSwgZGVzaWduYXRlZCB0byBpbnZlcnQgbWVtYmVycyBvZiB0aGVcbi8vIF9wcmltZV8gZmllbGRzIEYocCkgYXQgYSBtYXhpbWFsIHNwZWVkXG5CTi5wcm90b3R5cGUuX2ludm1wID0gZnVuY3Rpb24gX2ludm1wKHApIHtcbiAgYXNzZXJ0KHAubmVnYXRpdmUgPT09IDApO1xuICBhc3NlcnQocC5jbXBuKDApICE9PSAwKTtcblxuICB2YXIgYSA9IHRoaXM7XG4gIHZhciBiID0gcC5jbG9uZSgpO1xuXG4gIGlmIChhLm5lZ2F0aXZlICE9PSAwKVxuICAgIGEgPSBhLnVtb2QocCk7XG4gIGVsc2VcbiAgICBhID0gYS5jbG9uZSgpO1xuXG4gIHZhciB4MSA9IG5ldyBCTigxKTtcbiAgdmFyIHgyID0gbmV3IEJOKDApO1xuXG4gIHZhciBkZWx0YSA9IGIuY2xvbmUoKTtcblxuICB3aGlsZSAoYS5jbXBuKDEpID4gMCAmJiBiLmNtcG4oMSkgPiAwKSB7XG4gICAgd2hpbGUgKGEuaXNFdmVuKCkpIHtcbiAgICAgIGEuaXVzaHJuKDEpO1xuICAgICAgaWYgKHgxLmlzRXZlbigpKVxuICAgICAgICB4MS5pdXNocm4oMSk7XG4gICAgICBlbHNlXG4gICAgICAgIHgxLmlhZGQoZGVsdGEpLml1c2hybigxKTtcbiAgICB9XG4gICAgd2hpbGUgKGIuaXNFdmVuKCkpIHtcbiAgICAgIGIuaXVzaHJuKDEpO1xuICAgICAgaWYgKHgyLmlzRXZlbigpKVxuICAgICAgICB4Mi5pdXNocm4oMSk7XG4gICAgICBlbHNlXG4gICAgICAgIHgyLmlhZGQoZGVsdGEpLml1c2hybigxKTtcbiAgICB9XG4gICAgaWYgKGEuY21wKGIpID49IDApIHtcbiAgICAgIGEuaXN1YihiKTtcbiAgICAgIHgxLmlzdWIoeDIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBiLmlzdWIoYSk7XG4gICAgICB4Mi5pc3ViKHgxKTtcbiAgICB9XG4gIH1cblxuICB2YXIgcmVzO1xuICBpZiAoYS5jbXBuKDEpID09PSAwKVxuICAgIHJlcyA9IHgxO1xuICBlbHNlXG4gICAgcmVzID0geDI7XG5cbiAgaWYgKHJlcy5jbXBuKDApIDwgMClcbiAgICByZXMuaWFkZChwKTtcblxuICByZXR1cm4gcmVzO1xufTtcblxuQk4ucHJvdG90eXBlLmdjZCA9IGZ1bmN0aW9uIGdjZChudW0pIHtcbiAgaWYgKHRoaXMuY21wbigwKSA9PT0gMClcbiAgICByZXR1cm4gbnVtLmNsb25lKCk7XG4gIGlmIChudW0uY21wbigwKSA9PT0gMClcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpO1xuXG4gIHZhciBhID0gdGhpcy5jbG9uZSgpO1xuICB2YXIgYiA9IG51bS5jbG9uZSgpO1xuICBhLm5lZ2F0aXZlID0gMDtcbiAgYi5uZWdhdGl2ZSA9IDA7XG5cbiAgLy8gUmVtb3ZlIGNvbW1vbiBmYWN0b3Igb2YgdHdvXG4gIGZvciAodmFyIHNoaWZ0ID0gMDsgYS5pc0V2ZW4oKSAmJiBiLmlzRXZlbigpOyBzaGlmdCsrKSB7XG4gICAgYS5pdXNocm4oMSk7XG4gICAgYi5pdXNocm4oMSk7XG4gIH1cblxuICBkbyB7XG4gICAgd2hpbGUgKGEuaXNFdmVuKCkpXG4gICAgICBhLml1c2hybigxKTtcbiAgICB3aGlsZSAoYi5pc0V2ZW4oKSlcbiAgICAgIGIuaXVzaHJuKDEpO1xuXG4gICAgdmFyIHIgPSBhLmNtcChiKTtcbiAgICBpZiAociA8IDApIHtcbiAgICAgIC8vIFN3YXAgYGFgIGFuZCBgYmAgdG8gbWFrZSBgYWAgYWx3YXlzIGJpZ2dlciB0aGFuIGBiYFxuICAgICAgdmFyIHQgPSBhO1xuICAgICAgYSA9IGI7XG4gICAgICBiID0gdDtcbiAgICB9IGVsc2UgaWYgKHIgPT09IDAgfHwgYi5jbXBuKDEpID09PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBhLmlzdWIoYik7XG4gIH0gd2hpbGUgKHRydWUpO1xuXG4gIHJldHVybiBiLml1c2hsbihzaGlmdCk7XG59O1xuXG4vLyBJbnZlcnQgbnVtYmVyIGluIHRoZSBmaWVsZCBGKG51bSlcbkJOLnByb3RvdHlwZS5pbnZtID0gZnVuY3Rpb24gaW52bShudW0pIHtcbiAgcmV0dXJuIHRoaXMuZWdjZChudW0pLmEudW1vZChudW0pO1xufTtcblxuQk4ucHJvdG90eXBlLmlzRXZlbiA9IGZ1bmN0aW9uIGlzRXZlbigpIHtcbiAgcmV0dXJuICh0aGlzLndvcmRzWzBdICYgMSkgPT09IDA7XG59O1xuXG5CTi5wcm90b3R5cGUuaXNPZGQgPSBmdW5jdGlvbiBpc09kZCgpIHtcbiAgcmV0dXJuICh0aGlzLndvcmRzWzBdICYgMSkgPT09IDE7XG59O1xuXG4vLyBBbmQgZmlyc3Qgd29yZCBhbmQgbnVtXG5CTi5wcm90b3R5cGUuYW5kbG4gPSBmdW5jdGlvbiBhbmRsbihudW0pIHtcbiAgcmV0dXJuIHRoaXMud29yZHNbMF0gJiBudW07XG59O1xuXG4vLyBJbmNyZW1lbnQgYXQgdGhlIGJpdCBwb3NpdGlvbiBpbi1saW5lXG5CTi5wcm90b3R5cGUuYmluY24gPSBmdW5jdGlvbiBiaW5jbihiaXQpIHtcbiAgYXNzZXJ0KHR5cGVvZiBiaXQgPT09ICdudW1iZXInKTtcbiAgdmFyIHIgPSBiaXQgJSAyNjtcbiAgdmFyIHMgPSAoYml0IC0gcikgLyAyNjtcbiAgdmFyIHEgPSAxIDw8IHI7XG5cbiAgLy8gRmFzdCBjYXNlOiBiaXQgaXMgbXVjaCBoaWdoZXIgdGhhbiBhbGwgZXhpc3Rpbmcgd29yZHNcbiAgaWYgKHRoaXMubGVuZ3RoIDw9IHMpIHtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGg7IGkgPCBzICsgMTsgaSsrKVxuICAgICAgdGhpcy53b3Jkc1tpXSA9IDA7XG4gICAgdGhpcy53b3Jkc1tzXSB8PSBxO1xuICAgIHRoaXMubGVuZ3RoID0gcyArIDE7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBBZGQgYml0IGFuZCBwcm9wYWdhdGUsIGlmIG5lZWRlZFxuICB2YXIgY2FycnkgPSBxO1xuICBmb3IgKHZhciBpID0gczsgY2FycnkgIT09IDAgJiYgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdyA9IHRoaXMud29yZHNbaV0gfCAwO1xuICAgIHcgKz0gY2Fycnk7XG4gICAgY2FycnkgPSB3ID4+PiAyNjtcbiAgICB3ICY9IDB4M2ZmZmZmZjtcbiAgICB0aGlzLndvcmRzW2ldID0gdztcbiAgfVxuICBpZiAoY2FycnkgIT09IDApIHtcbiAgICB0aGlzLndvcmRzW2ldID0gY2Fycnk7XG4gICAgdGhpcy5sZW5ndGgrKztcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbkJOLnByb3RvdHlwZS5pc1plcm8gPSBmdW5jdGlvbiBpc1plcm8oKSB7XG4gIHJldHVybiB0aGlzLmxlbmd0aCA9PT0gMSAmJiB0aGlzLndvcmRzWzBdID09PSAwO1xufTtcblxuQk4ucHJvdG90eXBlLmNtcG4gPSBmdW5jdGlvbiBjbXBuKG51bSkge1xuICB2YXIgbmVnYXRpdmUgPSBudW0gPCAwO1xuXG4gIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwICYmICFuZWdhdGl2ZSlcbiAgICByZXR1cm4gLTE7XG4gIGVsc2UgaWYgKHRoaXMubmVnYXRpdmUgPT09IDAgJiYgbmVnYXRpdmUpXG4gICAgcmV0dXJuIDE7XG5cbiAgdGhpcy5zdHJpcCgpO1xuXG4gIHZhciByZXM7XG4gIGlmICh0aGlzLmxlbmd0aCA+IDEpIHtcbiAgICByZXMgPSAxO1xuICB9IGVsc2Uge1xuICAgIGlmIChuZWdhdGl2ZSlcbiAgICAgIG51bSA9IC1udW07XG4gICAgYXNzZXJ0KG51bSA8PSAweDNmZmZmZmYsICdOdW1iZXIgaXMgdG9vIGJpZycpO1xuXG4gICAgdmFyIHcgPSB0aGlzLndvcmRzWzBdIHwgMDtcbiAgICByZXMgPSB3ID09PSBudW0gPyAwIDogdyA8IG51bSA/IC0xIDogMTtcbiAgfVxuICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMClcbiAgICByZXMgPSAtcmVzO1xuICByZXR1cm4gcmVzO1xufTtcblxuLy8gQ29tcGFyZSB0d28gbnVtYmVycyBhbmQgcmV0dXJuOlxuLy8gMSAtIGlmIGB0aGlzYCA+IGBudW1gXG4vLyAwIC0gaWYgYHRoaXNgID09IGBudW1gXG4vLyAtMSAtIGlmIGB0aGlzYCA8IGBudW1gXG5CTi5wcm90b3R5cGUuY21wID0gZnVuY3Rpb24gY21wKG51bSkge1xuICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCAmJiBudW0ubmVnYXRpdmUgPT09IDApXG4gICAgcmV0dXJuIC0xO1xuICBlbHNlIGlmICh0aGlzLm5lZ2F0aXZlID09PSAwICYmIG51bS5uZWdhdGl2ZSAhPT0gMClcbiAgICByZXR1cm4gMTtcblxuICB2YXIgcmVzID0gdGhpcy51Y21wKG51bSk7XG4gIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKVxuICAgIHJldHVybiAtcmVzO1xuICBlbHNlXG4gICAgcmV0dXJuIHJlcztcbn07XG5cbi8vIFVuc2lnbmVkIGNvbXBhcmlzb25cbkJOLnByb3RvdHlwZS51Y21wID0gZnVuY3Rpb24gdWNtcChudW0pIHtcbiAgLy8gQXQgdGhpcyBwb2ludCBib3RoIG51bWJlcnMgaGF2ZSB0aGUgc2FtZSBzaWduXG4gIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpXG4gICAgcmV0dXJuIDE7XG4gIGVsc2UgaWYgKHRoaXMubGVuZ3RoIDwgbnVtLmxlbmd0aClcbiAgICByZXR1cm4gLTE7XG5cbiAgdmFyIHJlcyA9IDA7XG4gIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIGEgPSB0aGlzLndvcmRzW2ldIHwgMDtcbiAgICB2YXIgYiA9IG51bS53b3Jkc1tpXSB8IDA7XG5cbiAgICBpZiAoYSA9PT0gYilcbiAgICAgIGNvbnRpbnVlO1xuICAgIGlmIChhIDwgYilcbiAgICAgIHJlcyA9IC0xO1xuICAgIGVsc2UgaWYgKGEgPiBiKVxuICAgICAgcmVzID0gMTtcbiAgICBicmVhaztcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcblxuLy9cbi8vIEEgcmVkdWNlIGNvbnRleHQsIGNvdWxkIGJlIHVzaW5nIG1vbnRnb21lcnkgb3Igc29tZXRoaW5nIGJldHRlciwgZGVwZW5kaW5nXG4vLyBvbiB0aGUgYG1gIGl0c2VsZi5cbi8vXG5CTi5yZWQgPSBmdW5jdGlvbiByZWQobnVtKSB7XG4gIHJldHVybiBuZXcgUmVkKG51bSk7XG59O1xuXG5CTi5wcm90b3R5cGUudG9SZWQgPSBmdW5jdGlvbiB0b1JlZChjdHgpIHtcbiAgYXNzZXJ0KCF0aGlzLnJlZCwgJ0FscmVhZHkgYSBudW1iZXIgaW4gcmVkdWN0aW9uIGNvbnRleHQnKTtcbiAgYXNzZXJ0KHRoaXMubmVnYXRpdmUgPT09IDAsICdyZWQgd29ya3Mgb25seSB3aXRoIHBvc2l0aXZlcycpO1xuICByZXR1cm4gY3R4LmNvbnZlcnRUbyh0aGlzKS5fZm9yY2VSZWQoY3R4KTtcbn07XG5cbkJOLnByb3RvdHlwZS5mcm9tUmVkID0gZnVuY3Rpb24gZnJvbVJlZCgpIHtcbiAgYXNzZXJ0KHRoaXMucmVkLCAnZnJvbVJlZCB3b3JrcyBvbmx5IHdpdGggbnVtYmVycyBpbiByZWR1Y3Rpb24gY29udGV4dCcpO1xuICByZXR1cm4gdGhpcy5yZWQuY29udmVydEZyb20odGhpcyk7XG59O1xuXG5CTi5wcm90b3R5cGUuX2ZvcmNlUmVkID0gZnVuY3Rpb24gX2ZvcmNlUmVkKGN0eCkge1xuICB0aGlzLnJlZCA9IGN0eDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5CTi5wcm90b3R5cGUuZm9yY2VSZWQgPSBmdW5jdGlvbiBmb3JjZVJlZChjdHgpIHtcbiAgYXNzZXJ0KCF0aGlzLnJlZCwgJ0FscmVhZHkgYSBudW1iZXIgaW4gcmVkdWN0aW9uIGNvbnRleHQnKTtcbiAgcmV0dXJuIHRoaXMuX2ZvcmNlUmVkKGN0eCk7XG59O1xuXG5CTi5wcm90b3R5cGUucmVkQWRkID0gZnVuY3Rpb24gcmVkQWRkKG51bSkge1xuICBhc3NlcnQodGhpcy5yZWQsICdyZWRBZGQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gIHJldHVybiB0aGlzLnJlZC5hZGQodGhpcywgbnVtKTtcbn07XG5cbkJOLnByb3RvdHlwZS5yZWRJQWRkID0gZnVuY3Rpb24gcmVkSUFkZChudW0pIHtcbiAgYXNzZXJ0KHRoaXMucmVkLCAncmVkSUFkZCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgcmV0dXJuIHRoaXMucmVkLmlhZGQodGhpcywgbnVtKTtcbn07XG5cbkJOLnByb3RvdHlwZS5yZWRTdWIgPSBmdW5jdGlvbiByZWRTdWIobnVtKSB7XG4gIGFzc2VydCh0aGlzLnJlZCwgJ3JlZFN1YiB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgcmV0dXJuIHRoaXMucmVkLnN1Yih0aGlzLCBudW0pO1xufTtcblxuQk4ucHJvdG90eXBlLnJlZElTdWIgPSBmdW5jdGlvbiByZWRJU3ViKG51bSkge1xuICBhc3NlcnQodGhpcy5yZWQsICdyZWRJU3ViIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICByZXR1cm4gdGhpcy5yZWQuaXN1Yih0aGlzLCBudW0pO1xufTtcblxuQk4ucHJvdG90eXBlLnJlZFNobCA9IGZ1bmN0aW9uIHJlZFNobChudW0pIHtcbiAgYXNzZXJ0KHRoaXMucmVkLCAncmVkU2hsIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICByZXR1cm4gdGhpcy5yZWQudXNobCh0aGlzLCBudW0pO1xufTtcblxuQk4ucHJvdG90eXBlLnJlZE11bCA9IGZ1bmN0aW9uIHJlZE11bChudW0pIHtcbiAgYXNzZXJ0KHRoaXMucmVkLCAncmVkTXVsIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICB0aGlzLnJlZC5fdmVyaWZ5Mih0aGlzLCBudW0pO1xuICByZXR1cm4gdGhpcy5yZWQubXVsKHRoaXMsIG51bSk7XG59O1xuXG5CTi5wcm90b3R5cGUucmVkSU11bCA9IGZ1bmN0aW9uIHJlZElNdWwobnVtKSB7XG4gIGFzc2VydCh0aGlzLnJlZCwgJ3JlZE11bCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgdGhpcy5yZWQuX3ZlcmlmeTIodGhpcywgbnVtKTtcbiAgcmV0dXJuIHRoaXMucmVkLmltdWwodGhpcywgbnVtKTtcbn07XG5cbkJOLnByb3RvdHlwZS5yZWRTcXIgPSBmdW5jdGlvbiByZWRTcXIoKSB7XG4gIGFzc2VydCh0aGlzLnJlZCwgJ3JlZFNxciB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gIHJldHVybiB0aGlzLnJlZC5zcXIodGhpcyk7XG59O1xuXG5CTi5wcm90b3R5cGUucmVkSVNxciA9IGZ1bmN0aW9uIHJlZElTcXIoKSB7XG4gIGFzc2VydCh0aGlzLnJlZCwgJ3JlZElTcXIgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuICByZXR1cm4gdGhpcy5yZWQuaXNxcih0aGlzKTtcbn07XG5cbi8vIFNxdWFyZSByb290IG92ZXIgcFxuQk4ucHJvdG90eXBlLnJlZFNxcnQgPSBmdW5jdGlvbiByZWRTcXJ0KCkge1xuICBhc3NlcnQodGhpcy5yZWQsICdyZWRTcXJ0IHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcbiAgcmV0dXJuIHRoaXMucmVkLnNxcnQodGhpcyk7XG59O1xuXG5CTi5wcm90b3R5cGUucmVkSW52bSA9IGZ1bmN0aW9uIHJlZEludm0oKSB7XG4gIGFzc2VydCh0aGlzLnJlZCwgJ3JlZEludm0gd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuICByZXR1cm4gdGhpcy5yZWQuaW52bSh0aGlzKTtcbn07XG5cbi8vIFJldHVybiBuZWdhdGl2ZSBjbG9uZSBvZiBgdGhpc2AgJSBgcmVkIG1vZHVsb2BcbkJOLnByb3RvdHlwZS5yZWROZWcgPSBmdW5jdGlvbiByZWROZWcoKSB7XG4gIGFzc2VydCh0aGlzLnJlZCwgJ3JlZE5lZyB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gIHJldHVybiB0aGlzLnJlZC5uZWcodGhpcyk7XG59O1xuXG5CTi5wcm90b3R5cGUucmVkUG93ID0gZnVuY3Rpb24gcmVkUG93KG51bSkge1xuICBhc3NlcnQodGhpcy5yZWQgJiYgIW51bS5yZWQsICdyZWRQb3cobm9ybWFsTnVtKScpO1xuICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcbiAgcmV0dXJuIHRoaXMucmVkLnBvdyh0aGlzLCBudW0pO1xufTtcblxuLy8gUHJpbWUgbnVtYmVycyB3aXRoIGVmZmljaWVudCByZWR1Y3Rpb25cbnZhciBwcmltZXMgPSB7XG4gIGsyNTY6IG51bGwsXG4gIHAyMjQ6IG51bGwsXG4gIHAxOTI6IG51bGwsXG4gIHAyNTUxOTogbnVsbFxufTtcblxuLy8gUHNldWRvLU1lcnNlbm5lIHByaW1lXG5mdW5jdGlvbiBNUHJpbWUobmFtZSwgcCkge1xuICAvLyBQID0gMiBeIE4gLSBLXG4gIHRoaXMubmFtZSA9IG5hbWU7XG4gIHRoaXMucCA9IG5ldyBCTihwLCAxNik7XG4gIHRoaXMubiA9IHRoaXMucC5iaXRMZW5ndGgoKTtcbiAgdGhpcy5rID0gbmV3IEJOKDEpLml1c2hsbih0aGlzLm4pLmlzdWIodGhpcy5wKTtcblxuICB0aGlzLnRtcCA9IHRoaXMuX3RtcCgpO1xufVxuXG5NUHJpbWUucHJvdG90eXBlLl90bXAgPSBmdW5jdGlvbiBfdG1wKCkge1xuICB2YXIgdG1wID0gbmV3IEJOKG51bGwpO1xuICB0bXAud29yZHMgPSBuZXcgQXJyYXkoTWF0aC5jZWlsKHRoaXMubiAvIDEzKSk7XG4gIHJldHVybiB0bXA7XG59O1xuXG5NUHJpbWUucHJvdG90eXBlLmlyZWR1Y2UgPSBmdW5jdGlvbiBpcmVkdWNlKG51bSkge1xuICAvLyBBc3N1bWVzIHRoYXQgYG51bWAgaXMgbGVzcyB0aGFuIGBQXjJgXG4gIC8vIG51bSA9IEhJICogKDIgXiBOIC0gSykgKyBISSAqIEsgKyBMTyA9IEhJICogSyArIExPIChtb2QgUClcbiAgdmFyIHIgPSBudW07XG4gIHZhciBybGVuO1xuXG4gIGRvIHtcbiAgICB0aGlzLnNwbGl0KHIsIHRoaXMudG1wKTtcbiAgICByID0gdGhpcy5pbXVsSyhyKTtcbiAgICByID0gci5pYWRkKHRoaXMudG1wKTtcbiAgICBybGVuID0gci5iaXRMZW5ndGgoKTtcbiAgfSB3aGlsZSAocmxlbiA+IHRoaXMubik7XG5cbiAgdmFyIGNtcCA9IHJsZW4gPCB0aGlzLm4gPyAtMSA6IHIudWNtcCh0aGlzLnApO1xuICBpZiAoY21wID09PSAwKSB7XG4gICAgci53b3Jkc1swXSA9IDA7XG4gICAgci5sZW5ndGggPSAxO1xuICB9IGVsc2UgaWYgKGNtcCA+IDApIHtcbiAgICByLmlzdWIodGhpcy5wKTtcbiAgfSBlbHNlIHtcbiAgICByLnN0cmlwKCk7XG4gIH1cblxuICByZXR1cm4gcjtcbn07XG5cbk1QcmltZS5wcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbiBzcGxpdChpbnB1dCwgb3V0KSB7XG4gIGlucHV0Lml1c2hybih0aGlzLm4sIDAsIG91dCk7XG59O1xuXG5NUHJpbWUucHJvdG90eXBlLmltdWxLID0gZnVuY3Rpb24gaW11bEsobnVtKSB7XG4gIHJldHVybiBudW0uaW11bCh0aGlzLmspO1xufTtcblxuZnVuY3Rpb24gSzI1NigpIHtcbiAgTVByaW1lLmNhbGwoXG4gICAgdGhpcyxcbiAgICAnazI1NicsXG4gICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGZmZmZmYzJmJyk7XG59XG5pbmhlcml0cyhLMjU2LCBNUHJpbWUpO1xuXG5LMjU2LnByb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uIHNwbGl0KGlucHV0LCBvdXRwdXQpIHtcbiAgLy8gMjU2ID0gOSAqIDI2ICsgMjJcbiAgdmFyIG1hc2sgPSAweDNmZmZmZjtcblxuICB2YXIgb3V0TGVuID0gTWF0aC5taW4oaW5wdXQubGVuZ3RoLCA5KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdXRMZW47IGkrKylcbiAgICBvdXRwdXQud29yZHNbaV0gPSBpbnB1dC53b3Jkc1tpXTtcbiAgb3V0cHV0Lmxlbmd0aCA9IG91dExlbjtcblxuICBpZiAoaW5wdXQubGVuZ3RoIDw9IDkpIHtcbiAgICBpbnB1dC53b3Jkc1swXSA9IDA7XG4gICAgaW5wdXQubGVuZ3RoID0gMTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBTaGlmdCBieSA5IGxpbWJzXG4gIHZhciBwcmV2ID0gaW5wdXQud29yZHNbOV07XG4gIG91dHB1dC53b3Jkc1tvdXRwdXQubGVuZ3RoKytdID0gcHJldiAmIG1hc2s7XG5cbiAgZm9yICh2YXIgaSA9IDEwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbmV4dCA9IGlucHV0LndvcmRzW2ldIHwgMDtcbiAgICBpbnB1dC53b3Jkc1tpIC0gMTBdID0gKChuZXh0ICYgbWFzaykgPDwgNCkgfCAocHJldiA+Pj4gMjIpO1xuICAgIHByZXYgPSBuZXh0O1xuICB9XG4gIGlucHV0LndvcmRzW2kgLSAxMF0gPSBwcmV2ID4+PiAyMjtcbiAgaW5wdXQubGVuZ3RoIC09IDk7XG59O1xuXG5LMjU2LnByb3RvdHlwZS5pbXVsSyA9IGZ1bmN0aW9uIGltdWxLKG51bSkge1xuICAvLyBLID0gMHgxMDAwMDAzZDEgPSBbIDB4NDAsIDB4M2QxIF1cbiAgbnVtLndvcmRzW251bS5sZW5ndGhdID0gMDtcbiAgbnVtLndvcmRzW251bS5sZW5ndGggKyAxXSA9IDA7XG4gIG51bS5sZW5ndGggKz0gMjtcblxuICAvLyBib3VuZGVkIGF0OiAweDQwICogMHgzZmZmZmZmICsgMHgzZDAgPSAweDEwMDAwMDM5MFxuICB2YXIgaGk7XG4gIHZhciBsbyA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHcgPSBudW0ud29yZHNbaV0gfCAwO1xuICAgIGhpID0gdyAqIDB4NDA7XG4gICAgbG8gKz0gdyAqIDB4M2QxO1xuICAgIGhpICs9IChsbyAvIDB4NDAwMDAwMCkgfCAwO1xuICAgIGxvICY9IDB4M2ZmZmZmZjtcblxuICAgIG51bS53b3Jkc1tpXSA9IGxvO1xuXG4gICAgbG8gPSBoaTtcbiAgfVxuXG4gIC8vIEZhc3QgbGVuZ3RoIHJlZHVjdGlvblxuICBpZiAobnVtLndvcmRzW251bS5sZW5ndGggLSAxXSA9PT0gMCkge1xuICAgIG51bS5sZW5ndGgtLTtcbiAgICBpZiAobnVtLndvcmRzW251bS5sZW5ndGggLSAxXSA9PT0gMClcbiAgICAgIG51bS5sZW5ndGgtLTtcbiAgfVxuICByZXR1cm4gbnVtO1xufTtcblxuZnVuY3Rpb24gUDIyNCgpIHtcbiAgTVByaW1lLmNhbGwoXG4gICAgdGhpcyxcbiAgICAncDIyNCcsXG4gICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIDAwMDAwMDAwIDAwMDAwMDAwIDAwMDAwMDAxJyk7XG59XG5pbmhlcml0cyhQMjI0LCBNUHJpbWUpO1xuXG5mdW5jdGlvbiBQMTkyKCkge1xuICBNUHJpbWUuY2FsbChcbiAgICB0aGlzLFxuICAgICdwMTkyJyxcbiAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZmZmYgZmZmZmZmZmYnKTtcbn1cbmluaGVyaXRzKFAxOTIsIE1QcmltZSk7XG5cbmZ1bmN0aW9uIFAyNTUxOSgpIHtcbiAgLy8gMiBeIDI1NSAtIDE5XG4gIE1QcmltZS5jYWxsKFxuICAgIHRoaXMsXG4gICAgJzI1NTE5JyxcbiAgICAnN2ZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZlZCcpO1xufVxuaW5oZXJpdHMoUDI1NTE5LCBNUHJpbWUpO1xuXG5QMjU1MTkucHJvdG90eXBlLmltdWxLID0gZnVuY3Rpb24gaW11bEsobnVtKSB7XG4gIC8vIEsgPSAweDEzXG4gIHZhciBjYXJyeSA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGhpID0gKG51bS53b3Jkc1tpXSB8IDApICogMHgxMyArIGNhcnJ5O1xuICAgIHZhciBsbyA9IGhpICYgMHgzZmZmZmZmO1xuICAgIGhpID4+Pj0gMjY7XG5cbiAgICBudW0ud29yZHNbaV0gPSBsbztcbiAgICBjYXJyeSA9IGhpO1xuICB9XG4gIGlmIChjYXJyeSAhPT0gMClcbiAgICBudW0ud29yZHNbbnVtLmxlbmd0aCsrXSA9IGNhcnJ5O1xuICByZXR1cm4gbnVtO1xufTtcblxuLy8gRXhwb3J0ZWQgbW9zdGx5IGZvciB0ZXN0aW5nIHB1cnBvc2VzLCB1c2UgcGxhaW4gbmFtZSBpbnN0ZWFkXG5CTi5fcHJpbWUgPSBmdW5jdGlvbiBwcmltZShuYW1lKSB7XG4gIC8vIENhY2hlZCB2ZXJzaW9uIG9mIHByaW1lXG4gIGlmIChwcmltZXNbbmFtZV0pXG4gICAgcmV0dXJuIHByaW1lc1tuYW1lXTtcblxuICB2YXIgcHJpbWU7XG4gIGlmIChuYW1lID09PSAnazI1NicpXG4gICAgcHJpbWUgPSBuZXcgSzI1NigpO1xuICBlbHNlIGlmIChuYW1lID09PSAncDIyNCcpXG4gICAgcHJpbWUgPSBuZXcgUDIyNCgpO1xuICBlbHNlIGlmIChuYW1lID09PSAncDE5MicpXG4gICAgcHJpbWUgPSBuZXcgUDE5MigpO1xuICBlbHNlIGlmIChuYW1lID09PSAncDI1NTE5JylcbiAgICBwcmltZSA9IG5ldyBQMjU1MTkoKTtcbiAgZWxzZVxuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBwcmltZSAnICsgbmFtZSk7XG4gIHByaW1lc1tuYW1lXSA9IHByaW1lO1xuXG4gIHJldHVybiBwcmltZTtcbn07XG5cbi8vXG4vLyBCYXNlIHJlZHVjdGlvbiBlbmdpbmVcbi8vXG5mdW5jdGlvbiBSZWQobSkge1xuICBpZiAodHlwZW9mIG0gPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIHByaW1lID0gQk4uX3ByaW1lKG0pO1xuICAgIHRoaXMubSA9IHByaW1lLnA7XG4gICAgdGhpcy5wcmltZSA9IHByaW1lO1xuICB9IGVsc2Uge1xuICAgIHRoaXMubSA9IG07XG4gICAgdGhpcy5wcmltZSA9IG51bGw7XG4gIH1cbn1cblxuUmVkLnByb3RvdHlwZS5fdmVyaWZ5MSA9IGZ1bmN0aW9uIF92ZXJpZnkxKGEpIHtcbiAgYXNzZXJ0KGEubmVnYXRpdmUgPT09IDAsICdyZWQgd29ya3Mgb25seSB3aXRoIHBvc2l0aXZlcycpO1xuICBhc3NlcnQoYS5yZWQsICdyZWQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG59O1xuXG5SZWQucHJvdG90eXBlLl92ZXJpZnkyID0gZnVuY3Rpb24gX3ZlcmlmeTIoYSwgYikge1xuICBhc3NlcnQoKGEubmVnYXRpdmUgfCBiLm5lZ2F0aXZlKSA9PT0gMCwgJ3JlZCB3b3JrcyBvbmx5IHdpdGggcG9zaXRpdmVzJyk7XG4gIGFzc2VydChhLnJlZCAmJiBhLnJlZCA9PT0gYi5yZWQsXG4gICAgICAgICAncmVkIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xufTtcblxuUmVkLnByb3RvdHlwZS5pbW9kID0gZnVuY3Rpb24gaW1vZChhKSB7XG4gIGlmICh0aGlzLnByaW1lKVxuICAgIHJldHVybiB0aGlzLnByaW1lLmlyZWR1Y2UoYSkuX2ZvcmNlUmVkKHRoaXMpO1xuICByZXR1cm4gYS51bW9kKHRoaXMubSkuX2ZvcmNlUmVkKHRoaXMpO1xufTtcblxuUmVkLnByb3RvdHlwZS5uZWcgPSBmdW5jdGlvbiBuZWcoYSkge1xuICB2YXIgciA9IGEuY2xvbmUoKTtcbiAgci5uZWdhdGl2ZSBePSAxO1xuICByZXR1cm4gci5pYWRkKHRoaXMubSkuX2ZvcmNlUmVkKHRoaXMpO1xufTtcblxuUmVkLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQoYSwgYikge1xuICB0aGlzLl92ZXJpZnkyKGEsIGIpO1xuXG4gIHZhciByZXMgPSBhLmFkZChiKTtcbiAgaWYgKHJlcy5jbXAodGhpcy5tKSA+PSAwKVxuICAgIHJlcy5pc3ViKHRoaXMubSk7XG4gIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xufTtcblxuUmVkLnByb3RvdHlwZS5pYWRkID0gZnVuY3Rpb24gaWFkZChhLCBiKSB7XG4gIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG5cbiAgdmFyIHJlcyA9IGEuaWFkZChiKTtcbiAgaWYgKHJlcy5jbXAodGhpcy5tKSA+PSAwKVxuICAgIHJlcy5pc3ViKHRoaXMubSk7XG4gIHJldHVybiByZXM7XG59O1xuXG5SZWQucHJvdG90eXBlLnN1YiA9IGZ1bmN0aW9uIHN1YihhLCBiKSB7XG4gIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG5cbiAgdmFyIHJlcyA9IGEuc3ViKGIpO1xuICBpZiAocmVzLmNtcG4oMCkgPCAwKVxuICAgIHJlcy5pYWRkKHRoaXMubSk7XG4gIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xufTtcblxuUmVkLnByb3RvdHlwZS5pc3ViID0gZnVuY3Rpb24gaXN1YihhLCBiKSB7XG4gIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG5cbiAgdmFyIHJlcyA9IGEuaXN1YihiKTtcbiAgaWYgKHJlcy5jbXBuKDApIDwgMClcbiAgICByZXMuaWFkZCh0aGlzLm0pO1xuICByZXR1cm4gcmVzO1xufTtcblxuUmVkLnByb3RvdHlwZS5zaGwgPSBmdW5jdGlvbiBzaGwoYSwgbnVtKSB7XG4gIHRoaXMuX3ZlcmlmeTEoYSk7XG4gIHJldHVybiB0aGlzLmltb2QoYS51c2hsbihudW0pKTtcbn07XG5cblJlZC5wcm90b3R5cGUuaW11bCA9IGZ1bmN0aW9uIGltdWwoYSwgYikge1xuICB0aGlzLl92ZXJpZnkyKGEsIGIpO1xuICByZXR1cm4gdGhpcy5pbW9kKGEuaW11bChiKSk7XG59O1xuXG5SZWQucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uIG11bChhLCBiKSB7XG4gIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG4gIHJldHVybiB0aGlzLmltb2QoYS5tdWwoYikpO1xufTtcblxuUmVkLnByb3RvdHlwZS5pc3FyID0gZnVuY3Rpb24gaXNxcihhKSB7XG4gIHJldHVybiB0aGlzLmltdWwoYSwgYSk7XG59O1xuXG5SZWQucHJvdG90eXBlLnNxciA9IGZ1bmN0aW9uIHNxcihhKSB7XG4gIHJldHVybiB0aGlzLm11bChhLCBhKTtcbn07XG5cblJlZC5wcm90b3R5cGUuc3FydCA9IGZ1bmN0aW9uIHNxcnQoYSkge1xuICBpZiAoYS5jbXBuKDApID09PSAwKVxuICAgIHJldHVybiBhLmNsb25lKCk7XG5cbiAgdmFyIG1vZDMgPSB0aGlzLm0uYW5kbG4oMyk7XG4gIGFzc2VydChtb2QzICUgMiA9PT0gMSk7XG5cbiAgLy8gRmFzdCBjYXNlXG4gIGlmIChtb2QzID09PSAzKSB7XG4gICAgdmFyIHBvdyA9IHRoaXMubS5hZGQobmV3IEJOKDEpKS5pdXNocm4oMik7XG4gICAgdmFyIHIgPSB0aGlzLnBvdyhhLCBwb3cpO1xuICAgIHJldHVybiByO1xuICB9XG5cbiAgLy8gVG9uZWxsaS1TaGFua3MgYWxnb3JpdGhtIChUb3RhbGx5IHVub3B0aW1pemVkIGFuZCBzbG93KVxuICAvL1xuICAvLyBGaW5kIFEgYW5kIFMsIHRoYXQgUSAqIDIgXiBTID0gKFAgLSAxKVxuICB2YXIgcSA9IHRoaXMubS5zdWJuKDEpO1xuICB2YXIgcyA9IDA7XG4gIHdoaWxlIChxLmNtcG4oMCkgIT09IDAgJiYgcS5hbmRsbigxKSA9PT0gMCkge1xuICAgIHMrKztcbiAgICBxLml1c2hybigxKTtcbiAgfVxuICBhc3NlcnQocS5jbXBuKDApICE9PSAwKTtcblxuICB2YXIgb25lID0gbmV3IEJOKDEpLnRvUmVkKHRoaXMpO1xuICB2YXIgbk9uZSA9IG9uZS5yZWROZWcoKTtcblxuICAvLyBGaW5kIHF1YWRyYXRpYyBub24tcmVzaWR1ZVxuICAvLyBOT1RFOiBNYXggaXMgc3VjaCBiZWNhdXNlIG9mIGdlbmVyYWxpemVkIFJpZW1hbm4gaHlwb3RoZXNpcy5cbiAgdmFyIGxwb3cgPSB0aGlzLm0uc3VibigxKS5pdXNocm4oMSk7XG4gIHZhciB6ID0gdGhpcy5tLmJpdExlbmd0aCgpO1xuICB6ID0gbmV3IEJOKDIgKiB6ICogeikudG9SZWQodGhpcyk7XG4gIHdoaWxlICh0aGlzLnBvdyh6LCBscG93KS5jbXAobk9uZSkgIT09IDApXG4gICAgei5yZWRJQWRkKG5PbmUpO1xuXG4gIHZhciBjID0gdGhpcy5wb3coeiwgcSk7XG4gIHZhciByID0gdGhpcy5wb3coYSwgcS5hZGRuKDEpLml1c2hybigxKSk7XG4gIHZhciB0ID0gdGhpcy5wb3coYSwgcSk7XG4gIHZhciBtID0gcztcbiAgd2hpbGUgKHQuY21wKG9uZSkgIT09IDApIHtcbiAgICB2YXIgdG1wID0gdDtcbiAgICBmb3IgKHZhciBpID0gMDsgdG1wLmNtcChvbmUpICE9PSAwOyBpKyspXG4gICAgICB0bXAgPSB0bXAucmVkU3FyKCk7XG4gICAgYXNzZXJ0KGkgPCBtKTtcbiAgICB2YXIgYiA9IHRoaXMucG93KGMsIG5ldyBCTigxKS5pdXNobG4obSAtIGkgLSAxKSk7XG5cbiAgICByID0gci5yZWRNdWwoYik7XG4gICAgYyA9IGIucmVkU3FyKCk7XG4gICAgdCA9IHQucmVkTXVsKGMpO1xuICAgIG0gPSBpO1xuICB9XG5cbiAgcmV0dXJuIHI7XG59O1xuXG5SZWQucHJvdG90eXBlLmludm0gPSBmdW5jdGlvbiBpbnZtKGEpIHtcbiAgdmFyIGludiA9IGEuX2ludm1wKHRoaXMubSk7XG4gIGlmIChpbnYubmVnYXRpdmUgIT09IDApIHtcbiAgICBpbnYubmVnYXRpdmUgPSAwO1xuICAgIHJldHVybiB0aGlzLmltb2QoaW52KS5yZWROZWcoKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGhpcy5pbW9kKGludik7XG4gIH1cbn07XG5cblJlZC5wcm90b3R5cGUucG93ID0gZnVuY3Rpb24gcG93KGEsIG51bSkge1xuICBpZiAobnVtLmNtcG4oMCkgPT09IDApXG4gICAgcmV0dXJuIG5ldyBCTigxKTtcbiAgaWYgKG51bS5jbXBuKDEpID09PSAwKVxuICAgIHJldHVybiBhLmNsb25lKCk7XG5cbiAgdmFyIHdpbmRvd1NpemUgPSA0O1xuICB2YXIgd25kID0gbmV3IEFycmF5KDEgPDwgd2luZG93U2l6ZSk7XG4gIHduZFswXSA9IG5ldyBCTigxKS50b1JlZCh0aGlzKTtcbiAgd25kWzFdID0gYTtcbiAgZm9yICh2YXIgaSA9IDI7IGkgPCB3bmQubGVuZ3RoOyBpKyspXG4gICAgd25kW2ldID0gdGhpcy5tdWwod25kW2kgLSAxXSwgYSk7XG5cbiAgdmFyIHJlcyA9IHduZFswXTtcbiAgdmFyIGN1cnJlbnQgPSAwO1xuICB2YXIgY3VycmVudExlbiA9IDA7XG4gIHZhciBzdGFydCA9IG51bS5iaXRMZW5ndGgoKSAlIDI2O1xuICBpZiAoc3RhcnQgPT09IDApXG4gICAgc3RhcnQgPSAyNjtcbiAgZm9yICh2YXIgaSA9IG51bS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciB3b3JkID0gbnVtLndvcmRzW2ldO1xuICAgIGZvciAodmFyIGogPSBzdGFydCAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICB2YXIgYml0ID0gKHdvcmQgPj4gaikgJiAxO1xuICAgICAgaWYgKHJlcyAhPT0gd25kWzBdKVxuICAgICAgICByZXMgPSB0aGlzLnNxcihyZXMpO1xuICAgICAgaWYgKGJpdCA9PT0gMCAmJiBjdXJyZW50ID09PSAwKSB7XG4gICAgICAgIGN1cnJlbnRMZW4gPSAwO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY3VycmVudCA8PD0gMTtcbiAgICAgIGN1cnJlbnQgfD0gYml0O1xuICAgICAgY3VycmVudExlbisrO1xuICAgICAgaWYgKGN1cnJlbnRMZW4gIT09IHdpbmRvd1NpemUgJiYgKGkgIT09IDAgfHwgaiAhPT0gMCkpXG4gICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICByZXMgPSB0aGlzLm11bChyZXMsIHduZFtjdXJyZW50XSk7XG4gICAgICBjdXJyZW50TGVuID0gMDtcbiAgICAgIGN1cnJlbnQgPSAwO1xuICAgIH1cbiAgICBzdGFydCA9IDI2O1xuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cblJlZC5wcm90b3R5cGUuY29udmVydFRvID0gZnVuY3Rpb24gY29udmVydFRvKG51bSkge1xuICB2YXIgciA9IG51bS51bW9kKHRoaXMubSk7XG4gIGlmIChyID09PSBudW0pXG4gICAgcmV0dXJuIHIuY2xvbmUoKTtcbiAgZWxzZVxuICAgIHJldHVybiByO1xufTtcblxuUmVkLnByb3RvdHlwZS5jb252ZXJ0RnJvbSA9IGZ1bmN0aW9uIGNvbnZlcnRGcm9tKG51bSkge1xuICB2YXIgcmVzID0gbnVtLmNsb25lKCk7XG4gIHJlcy5yZWQgPSBudWxsO1xuICByZXR1cm4gcmVzO1xufTtcblxuLy9cbi8vIE1vbnRnb21lcnkgbWV0aG9kIGVuZ2luZVxuLy9cblxuQk4ubW9udCA9IGZ1bmN0aW9uIG1vbnQobnVtKSB7XG4gIHJldHVybiBuZXcgTW9udChudW0pO1xufTtcblxuZnVuY3Rpb24gTW9udChtKSB7XG4gIFJlZC5jYWxsKHRoaXMsIG0pO1xuXG4gIHRoaXMuc2hpZnQgPSB0aGlzLm0uYml0TGVuZ3RoKCk7XG4gIGlmICh0aGlzLnNoaWZ0ICUgMjYgIT09IDApXG4gICAgdGhpcy5zaGlmdCArPSAyNiAtICh0aGlzLnNoaWZ0ICUgMjYpO1xuICB0aGlzLnIgPSBuZXcgQk4oMSkuaXVzaGxuKHRoaXMuc2hpZnQpO1xuICB0aGlzLnIyID0gdGhpcy5pbW9kKHRoaXMuci5zcXIoKSk7XG4gIHRoaXMucmludiA9IHRoaXMuci5faW52bXAodGhpcy5tKTtcblxuICB0aGlzLm1pbnYgPSB0aGlzLnJpbnYubXVsKHRoaXMucikuaXN1Ym4oMSkuZGl2KHRoaXMubSk7XG4gIHRoaXMubWludiA9IHRoaXMubWludi51bW9kKHRoaXMucik7XG4gIHRoaXMubWludiA9IHRoaXMuci5zdWIodGhpcy5taW52KTtcbn1cbmluaGVyaXRzKE1vbnQsIFJlZCk7XG5cbk1vbnQucHJvdG90eXBlLmNvbnZlcnRUbyA9IGZ1bmN0aW9uIGNvbnZlcnRUbyhudW0pIHtcbiAgcmV0dXJuIHRoaXMuaW1vZChudW0udXNobG4odGhpcy5zaGlmdCkpO1xufTtcblxuTW9udC5wcm90b3R5cGUuY29udmVydEZyb20gPSBmdW5jdGlvbiBjb252ZXJ0RnJvbShudW0pIHtcbiAgdmFyIHIgPSB0aGlzLmltb2QobnVtLm11bCh0aGlzLnJpbnYpKTtcbiAgci5yZWQgPSBudWxsO1xuICByZXR1cm4gcjtcbn07XG5cbk1vbnQucHJvdG90eXBlLmltdWwgPSBmdW5jdGlvbiBpbXVsKGEsIGIpIHtcbiAgaWYgKGEuY21wbigwKSA9PT0gMCB8fCBiLmNtcG4oMCkgPT09IDApIHtcbiAgICBhLndvcmRzWzBdID0gMDtcbiAgICBhLmxlbmd0aCA9IDE7XG4gICAgcmV0dXJuIGE7XG4gIH1cblxuICB2YXIgdCA9IGEuaW11bChiKTtcbiAgdmFyIGMgPSB0Lm1hc2tuKHRoaXMuc2hpZnQpLm11bCh0aGlzLm1pbnYpLmltYXNrbih0aGlzLnNoaWZ0KS5tdWwodGhpcy5tKTtcbiAgdmFyIHUgPSB0LmlzdWIoYykuaXVzaHJuKHRoaXMuc2hpZnQpO1xuICB2YXIgcmVzID0gdTtcbiAgaWYgKHUuY21wKHRoaXMubSkgPj0gMClcbiAgICByZXMgPSB1LmlzdWIodGhpcy5tKTtcbiAgZWxzZSBpZiAodS5jbXBuKDApIDwgMClcbiAgICByZXMgPSB1LmlhZGQodGhpcy5tKTtcblxuICByZXR1cm4gcmVzLl9mb3JjZVJlZCh0aGlzKTtcbn07XG5cbk1vbnQucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uIG11bChhLCBiKSB7XG4gIGlmIChhLmNtcG4oMCkgPT09IDAgfHwgYi5jbXBuKDApID09PSAwKVxuICAgIHJldHVybiBuZXcgQk4oMCkuX2ZvcmNlUmVkKHRoaXMpO1xuXG4gIHZhciB0ID0gYS5tdWwoYik7XG4gIHZhciBjID0gdC5tYXNrbih0aGlzLnNoaWZ0KS5tdWwodGhpcy5taW52KS5pbWFza24odGhpcy5zaGlmdCkubXVsKHRoaXMubSk7XG4gIHZhciB1ID0gdC5pc3ViKGMpLml1c2hybih0aGlzLnNoaWZ0KTtcbiAgdmFyIHJlcyA9IHU7XG4gIGlmICh1LmNtcCh0aGlzLm0pID49IDApXG4gICAgcmVzID0gdS5pc3ViKHRoaXMubSk7XG4gIGVsc2UgaWYgKHUuY21wbigwKSA8IDApXG4gICAgcmVzID0gdS5pYWRkKHRoaXMubSk7XG5cbiAgcmV0dXJuIHJlcy5fZm9yY2VSZWQodGhpcyk7XG59O1xuXG5Nb250LnByb3RvdHlwZS5pbnZtID0gZnVuY3Rpb24gaW52bShhKSB7XG4gIC8vIChBUileLTEgKiBSXjIgPSAoQV4tMSAqIFJeLTEpICogUl4yID0gQV4tMSAqIFJcbiAgdmFyIHJlcyA9IHRoaXMuaW1vZChhLl9pbnZtcCh0aGlzLm0pLm11bCh0aGlzLnIyKSk7XG4gIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xufTtcblxufSkodHlwZW9mIG1vZHVsZSA9PT0gJ3VuZGVmaW5lZCcgfHwgbW9kdWxlLCB0aGlzKTtcbiIsInZhciBibiA9IHJlcXVpcmUoJ2JuLmpzJyk7XG52YXIgcmFuZG9tQnl0ZXMgPSByZXF1aXJlKCdyYW5kb21ieXRlcycpO1xubW9kdWxlLmV4cG9ydHMgPSBjcnQ7XG5mdW5jdGlvbiBibGluZChwcml2KSB7XG4gIHZhciByID0gZ2V0cihwcml2KTtcbiAgdmFyIGJsaW5kZXIgPSByLnRvUmVkKGJuLm1vbnQocHJpdi5tb2R1bHVzKSlcbiAgLnJlZFBvdyhuZXcgYm4ocHJpdi5wdWJsaWNFeHBvbmVudCkpLmZyb21SZWQoKTtcbiAgcmV0dXJuIHtcbiAgICBibGluZGVyOiBibGluZGVyLFxuICAgIHVuYmxpbmRlcjpyLmludm0ocHJpdi5tb2R1bHVzKVxuICB9O1xufVxuZnVuY3Rpb24gY3J0KG1zZywgcHJpdikge1xuICB2YXIgYmxpbmRzID0gYmxpbmQocHJpdik7XG4gIHZhciBsZW4gPSBwcml2Lm1vZHVsdXMuYnl0ZUxlbmd0aCgpO1xuICB2YXIgbW9kID0gYm4ubW9udChwcml2Lm1vZHVsdXMpO1xuICB2YXIgYmxpbmRlZCA9IG5ldyBibihtc2cpLm11bChibGluZHMuYmxpbmRlcikudW1vZChwcml2Lm1vZHVsdXMpO1xuICB2YXIgYzEgPSBibGluZGVkLnRvUmVkKGJuLm1vbnQocHJpdi5wcmltZTEpKTtcbiAgdmFyIGMyID0gYmxpbmRlZC50b1JlZChibi5tb250KHByaXYucHJpbWUyKSk7XG4gIHZhciBxaW52ID0gcHJpdi5jb2VmZmljaWVudDtcbiAgdmFyIHAgPSBwcml2LnByaW1lMTtcbiAgdmFyIHEgPSBwcml2LnByaW1lMjtcbiAgdmFyIG0xID0gYzEucmVkUG93KHByaXYuZXhwb25lbnQxKTtcbiAgdmFyIG0yID0gYzIucmVkUG93KHByaXYuZXhwb25lbnQyKTtcbiAgbTEgPSBtMS5mcm9tUmVkKCk7XG4gIG0yID0gbTIuZnJvbVJlZCgpO1xuICB2YXIgaCA9IG0xLmlzdWIobTIpLmltdWwocWludikudW1vZChwKTtcbiAgaC5pbXVsKHEpO1xuICBtMi5pYWRkKGgpO1xuICByZXR1cm4gbmV3IEJ1ZmZlcihtMi5pbXVsKGJsaW5kcy51bmJsaW5kZXIpLnVtb2QocHJpdi5tb2R1bHVzKS50b0FycmF5KGZhbHNlLCBsZW4pKTtcbn1cbmNydC5nZXRyID0gZ2V0cjtcbmZ1bmN0aW9uIGdldHIocHJpdikge1xuICB2YXIgbGVuID0gcHJpdi5tb2R1bHVzLmJ5dGVMZW5ndGgoKTtcbiAgdmFyIHIgPSBuZXcgYm4ocmFuZG9tQnl0ZXMobGVuKSk7XG4gIHdoaWxlIChyLmNtcChwcml2Lm1vZHVsdXMpID49ICAwIHx8ICFyLnVtb2QocHJpdi5wcmltZTEpIHx8ICFyLnVtb2QocHJpdi5wcmltZTIpKSB7XG4gICAgciA9IG5ldyBibihyYW5kb21CeXRlcyhsZW4pKTtcbiAgfVxuICByZXR1cm4gcjtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGVsbGlwdGljID0gZXhwb3J0cztcblxuZWxsaXB0aWMudmVyc2lvbiA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb247XG5lbGxpcHRpYy51dGlscyA9IHJlcXVpcmUoJy4vZWxsaXB0aWMvdXRpbHMnKTtcbmVsbGlwdGljLnJhbmQgPSByZXF1aXJlKCdicm9yYW5kJyk7XG5lbGxpcHRpYy5obWFjRFJCRyA9IHJlcXVpcmUoJy4vZWxsaXB0aWMvaG1hYy1kcmJnJyk7XG5lbGxpcHRpYy5jdXJ2ZSA9IHJlcXVpcmUoJy4vZWxsaXB0aWMvY3VydmUnKTtcbmVsbGlwdGljLmN1cnZlcyA9IHJlcXVpcmUoJy4vZWxsaXB0aWMvY3VydmVzJyk7XG5cbi8vIFByb3RvY29sc1xuZWxsaXB0aWMuZWMgPSByZXF1aXJlKCcuL2VsbGlwdGljL2VjJyk7XG5lbGxpcHRpYy5lZGRzYSA9IHJlcXVpcmUoJy4vZWxsaXB0aWMvZWRkc2EnKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGJuID0gcmVxdWlyZSgnYm4uanMnKTtcbnZhciBlbGxpcHRpYyA9IHJlcXVpcmUoJy4uLy4uL2VsbGlwdGljJyk7XG52YXIgdXRpbHMgPSBlbGxpcHRpYy51dGlscztcbnZhciBnZXROQUYgPSB1dGlscy5nZXROQUY7XG52YXIgZ2V0SlNGID0gdXRpbHMuZ2V0SlNGO1xudmFyIGFzc2VydCA9IHV0aWxzLmFzc2VydDtcblxuZnVuY3Rpb24gQmFzZUN1cnZlKHR5cGUsIGNvbmYpIHtcbiAgdGhpcy50eXBlID0gdHlwZTtcbiAgdGhpcy5wID0gbmV3IGJuKGNvbmYucCwgMTYpO1xuXG4gIC8vIFVzZSBNb250Z29tZXJ5LCB3aGVuIHRoZXJlIGlzIG5vIGZhc3QgcmVkdWN0aW9uIGZvciB0aGUgcHJpbWVcbiAgdGhpcy5yZWQgPSBjb25mLnByaW1lID8gYm4ucmVkKGNvbmYucHJpbWUpIDogYm4ubW9udCh0aGlzLnApO1xuXG4gIC8vIFVzZWZ1bCBmb3IgbWFueSBjdXJ2ZXNcbiAgdGhpcy56ZXJvID0gbmV3IGJuKDApLnRvUmVkKHRoaXMucmVkKTtcbiAgdGhpcy5vbmUgPSBuZXcgYm4oMSkudG9SZWQodGhpcy5yZWQpO1xuICB0aGlzLnR3byA9IG5ldyBibigyKS50b1JlZCh0aGlzLnJlZCk7XG5cbiAgLy8gQ3VydmUgY29uZmlndXJhdGlvbiwgb3B0aW9uYWxcbiAgdGhpcy5uID0gY29uZi5uICYmIG5ldyBibihjb25mLm4sIDE2KTtcbiAgdGhpcy5nID0gY29uZi5nICYmIHRoaXMucG9pbnRGcm9tSlNPTihjb25mLmcsIGNvbmYuZ1JlZCk7XG5cbiAgLy8gVGVtcG9yYXJ5IGFycmF5c1xuICB0aGlzLl93bmFmVDEgPSBuZXcgQXJyYXkoNCk7XG4gIHRoaXMuX3duYWZUMiA9IG5ldyBBcnJheSg0KTtcbiAgdGhpcy5fd25hZlQzID0gbmV3IEFycmF5KDQpO1xuICB0aGlzLl93bmFmVDQgPSBuZXcgQXJyYXkoNCk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEJhc2VDdXJ2ZTtcblxuQmFzZUN1cnZlLnByb3RvdHlwZS5wb2ludCA9IGZ1bmN0aW9uIHBvaW50KCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpO1xufTtcblxuQmFzZUN1cnZlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uIHZhbGlkYXRlKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpO1xufTtcblxuQmFzZUN1cnZlLnByb3RvdHlwZS5fZml4ZWROYWZNdWwgPSBmdW5jdGlvbiBfZml4ZWROYWZNdWwocCwgaykge1xuICBhc3NlcnQocC5wcmVjb21wdXRlZCk7XG4gIHZhciBkb3VibGVzID0gcC5fZ2V0RG91YmxlcygpO1xuXG4gIHZhciBuYWYgPSBnZXROQUYoaywgMSk7XG4gIHZhciBJID0gKDEgPDwgKGRvdWJsZXMuc3RlcCArIDEpKSAtIChkb3VibGVzLnN0ZXAgJSAyID09PSAwID8gMiA6IDEpO1xuICBJIC89IDM7XG5cbiAgLy8gVHJhbnNsYXRlIGludG8gbW9yZSB3aW5kb3dlZCBmb3JtXG4gIHZhciByZXByID0gW107XG4gIGZvciAodmFyIGogPSAwOyBqIDwgbmFmLmxlbmd0aDsgaiArPSBkb3VibGVzLnN0ZXApIHtcbiAgICB2YXIgbmFmVyA9IDA7XG4gICAgZm9yICh2YXIgayA9IGogKyBkb3VibGVzLnN0ZXAgLSAxOyBrID49IGo7IGstLSlcbiAgICAgIG5hZlcgPSAobmFmVyA8PCAxKSArIG5hZltrXTtcbiAgICByZXByLnB1c2gobmFmVyk7XG4gIH1cblxuICB2YXIgYSA9IHRoaXMuanBvaW50KG51bGwsIG51bGwsIG51bGwpO1xuICB2YXIgYiA9IHRoaXMuanBvaW50KG51bGwsIG51bGwsIG51bGwpO1xuICBmb3IgKHZhciBpID0gSTsgaSA+IDA7IGktLSkge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgcmVwci5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIG5hZlcgPSByZXByW2pdO1xuICAgICAgaWYgKG5hZlcgPT09IGkpXG4gICAgICAgIGIgPSBiLm1peGVkQWRkKGRvdWJsZXMucG9pbnRzW2pdKTtcbiAgICAgIGVsc2UgaWYgKG5hZlcgPT09IC1pKVxuICAgICAgICBiID0gYi5taXhlZEFkZChkb3VibGVzLnBvaW50c1tqXS5uZWcoKSk7XG4gICAgfVxuICAgIGEgPSBhLmFkZChiKTtcbiAgfVxuICByZXR1cm4gYS50b1AoKTtcbn07XG5cbkJhc2VDdXJ2ZS5wcm90b3R5cGUuX3duYWZNdWwgPSBmdW5jdGlvbiBfd25hZk11bChwLCBrKSB7XG4gIHZhciB3ID0gNDtcblxuICAvLyBQcmVjb21wdXRlIHdpbmRvd1xuICB2YXIgbmFmUG9pbnRzID0gcC5fZ2V0TkFGUG9pbnRzKHcpO1xuICB3ID0gbmFmUG9pbnRzLnduZDtcbiAgdmFyIHduZCA9IG5hZlBvaW50cy5wb2ludHM7XG5cbiAgLy8gR2V0IE5BRiBmb3JtXG4gIHZhciBuYWYgPSBnZXROQUYoaywgdyk7XG5cbiAgLy8gQWRkIGB0aGlzYCooTisxKSBmb3IgZXZlcnkgdy1OQUYgaW5kZXhcbiAgdmFyIGFjYyA9IHRoaXMuanBvaW50KG51bGwsIG51bGwsIG51bGwpO1xuICBmb3IgKHZhciBpID0gbmFmLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgLy8gQ291bnQgemVyb2VzXG4gICAgZm9yICh2YXIgayA9IDA7IGkgPj0gMCAmJiBuYWZbaV0gPT09IDA7IGktLSlcbiAgICAgIGsrKztcbiAgICBpZiAoaSA+PSAwKVxuICAgICAgaysrO1xuICAgIGFjYyA9IGFjYy5kYmxwKGspO1xuXG4gICAgaWYgKGkgPCAwKVxuICAgICAgYnJlYWs7XG4gICAgdmFyIHogPSBuYWZbaV07XG4gICAgYXNzZXJ0KHogIT09IDApO1xuICAgIGlmIChwLnR5cGUgPT09ICdhZmZpbmUnKSB7XG4gICAgICAvLyBKICstIFBcbiAgICAgIGlmICh6ID4gMClcbiAgICAgICAgYWNjID0gYWNjLm1peGVkQWRkKHduZFsoeiAtIDEpID4+IDFdKTtcbiAgICAgIGVsc2VcbiAgICAgICAgYWNjID0gYWNjLm1peGVkQWRkKHduZFsoLXogLSAxKSA+PiAxXS5uZWcoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEogKy0gSlxuICAgICAgaWYgKHogPiAwKVxuICAgICAgICBhY2MgPSBhY2MuYWRkKHduZFsoeiAtIDEpID4+IDFdKTtcbiAgICAgIGVsc2VcbiAgICAgICAgYWNjID0gYWNjLmFkZCh3bmRbKC16IC0gMSkgPj4gMV0ubmVnKCkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcC50eXBlID09PSAnYWZmaW5lJyA/IGFjYy50b1AoKSA6IGFjYztcbn07XG5cbkJhc2VDdXJ2ZS5wcm90b3R5cGUuX3duYWZNdWxBZGQgPSBmdW5jdGlvbiBfd25hZk11bEFkZChkZWZXLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2VmZnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuKSB7XG4gIHZhciB3bmRXaWR0aCA9IHRoaXMuX3duYWZUMTtcbiAgdmFyIHduZCA9IHRoaXMuX3duYWZUMjtcbiAgdmFyIG5hZiA9IHRoaXMuX3duYWZUMztcblxuICAvLyBGaWxsIGFsbCBhcnJheXNcbiAgdmFyIG1heCA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgcCA9IHBvaW50c1tpXTtcbiAgICB2YXIgbmFmUG9pbnRzID0gcC5fZ2V0TkFGUG9pbnRzKGRlZlcpO1xuICAgIHduZFdpZHRoW2ldID0gbmFmUG9pbnRzLnduZDtcbiAgICB3bmRbaV0gPSBuYWZQb2ludHMucG9pbnRzO1xuICB9XG5cbiAgLy8gQ29tYiBzbWFsbCB3aW5kb3cgTkFGc1xuICBmb3IgKHZhciBpID0gbGVuIC0gMTsgaSA+PSAxOyBpIC09IDIpIHtcbiAgICB2YXIgYSA9IGkgLSAxO1xuICAgIHZhciBiID0gaTtcbiAgICBpZiAod25kV2lkdGhbYV0gIT09IDEgfHwgd25kV2lkdGhbYl0gIT09IDEpIHtcbiAgICAgIG5hZlthXSA9IGdldE5BRihjb2VmZnNbYV0sIHduZFdpZHRoW2FdKTtcbiAgICAgIG5hZltiXSA9IGdldE5BRihjb2VmZnNbYl0sIHduZFdpZHRoW2JdKTtcbiAgICAgIG1heCA9IE1hdGgubWF4KG5hZlthXS5sZW5ndGgsIG1heCk7XG4gICAgICBtYXggPSBNYXRoLm1heChuYWZbYl0ubGVuZ3RoLCBtYXgpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIGNvbWIgPSBbXG4gICAgICBwb2ludHNbYV0sIC8qIDEgKi9cbiAgICAgIG51bGwsIC8qIDMgKi9cbiAgICAgIG51bGwsIC8qIDUgKi9cbiAgICAgIHBvaW50c1tiXSAvKiA3ICovXG4gICAgXTtcblxuICAgIC8vIFRyeSB0byBhdm9pZCBQcm9qZWN0aXZlIHBvaW50cywgaWYgcG9zc2libGVcbiAgICBpZiAocG9pbnRzW2FdLnkuY21wKHBvaW50c1tiXS55KSA9PT0gMCkge1xuICAgICAgY29tYlsxXSA9IHBvaW50c1thXS5hZGQocG9pbnRzW2JdKTtcbiAgICAgIGNvbWJbMl0gPSBwb2ludHNbYV0udG9KKCkubWl4ZWRBZGQocG9pbnRzW2JdLm5lZygpKTtcbiAgICB9IGVsc2UgaWYgKHBvaW50c1thXS55LmNtcChwb2ludHNbYl0ueS5yZWROZWcoKSkgPT09IDApIHtcbiAgICAgIGNvbWJbMV0gPSBwb2ludHNbYV0udG9KKCkubWl4ZWRBZGQocG9pbnRzW2JdKTtcbiAgICAgIGNvbWJbMl0gPSBwb2ludHNbYV0uYWRkKHBvaW50c1tiXS5uZWcoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbWJbMV0gPSBwb2ludHNbYV0udG9KKCkubWl4ZWRBZGQocG9pbnRzW2JdKTtcbiAgICAgIGNvbWJbMl0gPSBwb2ludHNbYV0udG9KKCkubWl4ZWRBZGQocG9pbnRzW2JdLm5lZygpKTtcbiAgICB9XG5cbiAgICB2YXIgaW5kZXggPSBbXG4gICAgICAtMywgLyogLTEgLTEgKi9cbiAgICAgIC0xLCAvKiAtMSAwICovXG4gICAgICAtNSwgLyogLTEgMSAqL1xuICAgICAgLTcsIC8qIDAgLTEgKi9cbiAgICAgIDAsIC8qIDAgMCAqL1xuICAgICAgNywgLyogMCAxICovXG4gICAgICA1LCAvKiAxIC0xICovXG4gICAgICAxLCAvKiAxIDAgKi9cbiAgICAgIDMgIC8qIDEgMSAqL1xuICAgIF07XG5cbiAgICB2YXIganNmID0gZ2V0SlNGKGNvZWZmc1thXSwgY29lZmZzW2JdKTtcbiAgICBtYXggPSBNYXRoLm1heChqc2ZbMF0ubGVuZ3RoLCBtYXgpO1xuICAgIG5hZlthXSA9IG5ldyBBcnJheShtYXgpO1xuICAgIG5hZltiXSA9IG5ldyBBcnJheShtYXgpO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWF4OyBqKyspIHtcbiAgICAgIHZhciBqYSA9IGpzZlswXVtqXSB8IDA7XG4gICAgICB2YXIgamIgPSBqc2ZbMV1bal0gfCAwO1xuXG4gICAgICBuYWZbYV1bal0gPSBpbmRleFsoamEgKyAxKSAqIDMgKyAoamIgKyAxKV07XG4gICAgICBuYWZbYl1bal0gPSAwO1xuICAgICAgd25kW2FdID0gY29tYjtcbiAgICB9XG4gIH1cblxuICB2YXIgYWNjID0gdGhpcy5qcG9pbnQobnVsbCwgbnVsbCwgbnVsbCk7XG4gIHZhciB0bXAgPSB0aGlzLl93bmFmVDQ7XG4gIGZvciAodmFyIGkgPSBtYXg7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIGsgPSAwO1xuXG4gICAgd2hpbGUgKGkgPj0gMCkge1xuICAgICAgdmFyIHplcm8gPSB0cnVlO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZW47IGorKykge1xuICAgICAgICB0bXBbal0gPSBuYWZbal1baV0gfCAwO1xuICAgICAgICBpZiAodG1wW2pdICE9PSAwKVxuICAgICAgICAgIHplcm8gPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICghemVybylcbiAgICAgICAgYnJlYWs7XG4gICAgICBrKys7XG4gICAgICBpLS07XG4gICAgfVxuICAgIGlmIChpID49IDApXG4gICAgICBrKys7XG4gICAgYWNjID0gYWNjLmRibHAoayk7XG4gICAgaWYgKGkgPCAwKVxuICAgICAgYnJlYWs7XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICB2YXIgeiA9IHRtcFtqXTtcbiAgICAgIHZhciBwO1xuICAgICAgaWYgKHogPT09IDApXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgZWxzZSBpZiAoeiA+IDApXG4gICAgICAgIHAgPSB3bmRbal1bKHogLSAxKSA+PiAxXTtcbiAgICAgIGVsc2UgaWYgKHogPCAwKVxuICAgICAgICBwID0gd25kW2pdWygteiAtIDEpID4+IDFdLm5lZygpO1xuXG4gICAgICBpZiAocC50eXBlID09PSAnYWZmaW5lJylcbiAgICAgICAgYWNjID0gYWNjLm1peGVkQWRkKHApO1xuICAgICAgZWxzZVxuICAgICAgICBhY2MgPSBhY2MuYWRkKHApO1xuICAgIH1cbiAgfVxuICAvLyBaZXJvaWZ5IHJlZmVyZW5jZXNcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICB3bmRbaV0gPSBudWxsO1xuICByZXR1cm4gYWNjLnRvUCgpO1xufTtcblxuZnVuY3Rpb24gQmFzZVBvaW50KGN1cnZlLCB0eXBlKSB7XG4gIHRoaXMuY3VydmUgPSBjdXJ2ZTtcbiAgdGhpcy50eXBlID0gdHlwZTtcbiAgdGhpcy5wcmVjb21wdXRlZCA9IG51bGw7XG59XG5CYXNlQ3VydmUuQmFzZVBvaW50ID0gQmFzZVBvaW50O1xuXG5CYXNlUG9pbnQucHJvdG90eXBlLmVxID0gZnVuY3Rpb24gZXEoLypvdGhlciovKSB7XG4gIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG59O1xuXG5CYXNlUG9pbnQucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gdmFsaWRhdGUoKSB7XG4gIHJldHVybiB0aGlzLmN1cnZlLnZhbGlkYXRlKHRoaXMpO1xufTtcblxuQmFzZUN1cnZlLnByb3RvdHlwZS5kZWNvZGVQb2ludCA9IGZ1bmN0aW9uIGRlY29kZVBvaW50KGJ5dGVzLCBlbmMpIHtcbiAgYnl0ZXMgPSB1dGlscy50b0FycmF5KGJ5dGVzLCBlbmMpO1xuXG4gIHZhciBsZW4gPSB0aGlzLnAuYnl0ZUxlbmd0aCgpO1xuICBpZiAoYnl0ZXNbMF0gPT09IDB4MDQgJiYgYnl0ZXMubGVuZ3RoIC0gMSA9PT0gMiAqIGxlbikge1xuICAgIHJldHVybiB0aGlzLnBvaW50KGJ5dGVzLnNsaWNlKDEsIDEgKyBsZW4pLFxuICAgICAgICAgICAgICAgICAgICAgIGJ5dGVzLnNsaWNlKDEgKyBsZW4sIDEgKyAyICogbGVuKSk7XG4gIH0gZWxzZSBpZiAoKGJ5dGVzWzBdID09PSAweDAyIHx8IGJ5dGVzWzBdID09PSAweDAzKSAmJlxuICAgICAgICAgICAgICBieXRlcy5sZW5ndGggLSAxID09PSBsZW4pIHtcbiAgICByZXR1cm4gdGhpcy5wb2ludEZyb21YKGJ5dGVzLnNsaWNlKDEsIDEgKyBsZW4pLCBieXRlc1swXSA9PT0gMHgwMyk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHBvaW50IGZvcm1hdCcpO1xufTtcblxuQmFzZVBvaW50LnByb3RvdHlwZS5lbmNvZGVDb21wcmVzc2VkID0gZnVuY3Rpb24gZW5jb2RlQ29tcHJlc3NlZChlbmMpIHtcbiAgcmV0dXJuIHRoaXMuZW5jb2RlKGVuYywgdHJ1ZSk7XG59O1xuXG5CYXNlUG9pbnQucHJvdG90eXBlLl9lbmNvZGUgPSBmdW5jdGlvbiBfZW5jb2RlKGNvbXBhY3QpIHtcbiAgdmFyIGxlbiA9IHRoaXMuY3VydmUucC5ieXRlTGVuZ3RoKCk7XG4gIHZhciB4ID0gdGhpcy5nZXRYKCkudG9BcnJheSgnYmUnLCBsZW4pO1xuXG4gIGlmIChjb21wYWN0KVxuICAgIHJldHVybiBbIHRoaXMuZ2V0WSgpLmlzRXZlbigpID8gMHgwMiA6IDB4MDMgXS5jb25jYXQoeCk7XG5cbiAgcmV0dXJuIFsgMHgwNCBdLmNvbmNhdCh4LCB0aGlzLmdldFkoKS50b0FycmF5KCdiZScsIGxlbikpIDtcbn07XG5cbkJhc2VQb2ludC5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKGVuYywgY29tcGFjdCkge1xuICByZXR1cm4gdXRpbHMuZW5jb2RlKHRoaXMuX2VuY29kZShjb21wYWN0KSwgZW5jKTtcbn07XG5cbkJhc2VQb2ludC5wcm90b3R5cGUucHJlY29tcHV0ZSA9IGZ1bmN0aW9uIHByZWNvbXB1dGUocG93ZXIpIHtcbiAgaWYgKHRoaXMucHJlY29tcHV0ZWQpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgdmFyIHByZWNvbXB1dGVkID0ge1xuICAgIGRvdWJsZXM6IG51bGwsXG4gICAgbmFmOiBudWxsLFxuICAgIGJldGE6IG51bGxcbiAgfTtcbiAgcHJlY29tcHV0ZWQubmFmID0gdGhpcy5fZ2V0TkFGUG9pbnRzKDgpO1xuICBwcmVjb21wdXRlZC5kb3VibGVzID0gdGhpcy5fZ2V0RG91Ymxlcyg0LCBwb3dlcik7XG4gIHByZWNvbXB1dGVkLmJldGEgPSB0aGlzLl9nZXRCZXRhKCk7XG4gIHRoaXMucHJlY29tcHV0ZWQgPSBwcmVjb21wdXRlZDtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbkJhc2VQb2ludC5wcm90b3R5cGUuX2hhc0RvdWJsZXMgPSBmdW5jdGlvbiBfaGFzRG91YmxlcyhrKSB7XG4gIGlmICghdGhpcy5wcmVjb21wdXRlZClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIGRvdWJsZXMgPSB0aGlzLnByZWNvbXB1dGVkLmRvdWJsZXM7XG4gIGlmICghZG91YmxlcylcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgcmV0dXJuIGRvdWJsZXMucG9pbnRzLmxlbmd0aCA+PSBNYXRoLmNlaWwoKGsuYml0TGVuZ3RoKCkgKyAxKSAvIGRvdWJsZXMuc3RlcCk7XG59O1xuXG5CYXNlUG9pbnQucHJvdG90eXBlLl9nZXREb3VibGVzID0gZnVuY3Rpb24gX2dldERvdWJsZXMoc3RlcCwgcG93ZXIpIHtcbiAgaWYgKHRoaXMucHJlY29tcHV0ZWQgJiYgdGhpcy5wcmVjb21wdXRlZC5kb3VibGVzKVxuICAgIHJldHVybiB0aGlzLnByZWNvbXB1dGVkLmRvdWJsZXM7XG5cbiAgdmFyIGRvdWJsZXMgPSBbIHRoaXMgXTtcbiAgdmFyIGFjYyA9IHRoaXM7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcG93ZXI7IGkgKz0gc3RlcCkge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgc3RlcDsgaisrKVxuICAgICAgYWNjID0gYWNjLmRibCgpO1xuICAgIGRvdWJsZXMucHVzaChhY2MpO1xuICB9XG4gIHJldHVybiB7XG4gICAgc3RlcDogc3RlcCxcbiAgICBwb2ludHM6IGRvdWJsZXNcbiAgfTtcbn07XG5cbkJhc2VQb2ludC5wcm90b3R5cGUuX2dldE5BRlBvaW50cyA9IGZ1bmN0aW9uIF9nZXROQUZQb2ludHMod25kKSB7XG4gIGlmICh0aGlzLnByZWNvbXB1dGVkICYmIHRoaXMucHJlY29tcHV0ZWQubmFmKVxuICAgIHJldHVybiB0aGlzLnByZWNvbXB1dGVkLm5hZjtcblxuICB2YXIgcmVzID0gWyB0aGlzIF07XG4gIHZhciBtYXggPSAoMSA8PCB3bmQpIC0gMTtcbiAgdmFyIGRibCA9IG1heCA9PT0gMSA/IG51bGwgOiB0aGlzLmRibCgpO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IG1heDsgaSsrKVxuICAgIHJlc1tpXSA9IHJlc1tpIC0gMV0uYWRkKGRibCk7XG4gIHJldHVybiB7XG4gICAgd25kOiB3bmQsXG4gICAgcG9pbnRzOiByZXNcbiAgfTtcbn07XG5cbkJhc2VQb2ludC5wcm90b3R5cGUuX2dldEJldGEgPSBmdW5jdGlvbiBfZ2V0QmV0YSgpIHtcbiAgcmV0dXJuIG51bGw7XG59O1xuXG5CYXNlUG9pbnQucHJvdG90eXBlLmRibHAgPSBmdW5jdGlvbiBkYmxwKGspIHtcbiAgdmFyIHIgPSB0aGlzO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGs7IGkrKylcbiAgICByID0gci5kYmwoKTtcbiAgcmV0dXJuIHI7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY3VydmUgPSByZXF1aXJlKCcuLi9jdXJ2ZScpO1xudmFyIGVsbGlwdGljID0gcmVxdWlyZSgnLi4vLi4vZWxsaXB0aWMnKTtcbnZhciBibiA9IHJlcXVpcmUoJ2JuLmpzJyk7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xudmFyIEJhc2UgPSBjdXJ2ZS5iYXNlO1xuXG52YXIgYXNzZXJ0ID0gZWxsaXB0aWMudXRpbHMuYXNzZXJ0O1xuXG5mdW5jdGlvbiBFZHdhcmRzQ3VydmUoY29uZikge1xuICAvLyBOT1RFOiBJbXBvcnRhbnQgYXMgd2UgYXJlIGNyZWF0aW5nIHBvaW50IGluIEJhc2UuY2FsbCgpXG4gIHRoaXMudHdpc3RlZCA9IChjb25mLmEgfCAwKSAhPT0gMTtcbiAgdGhpcy5tT25lQSA9IHRoaXMudHdpc3RlZCAmJiAoY29uZi5hIHwgMCkgPT09IC0xO1xuICB0aGlzLmV4dGVuZGVkID0gdGhpcy5tT25lQTtcblxuICBCYXNlLmNhbGwodGhpcywgJ2Vkd2FyZHMnLCBjb25mKTtcblxuICB0aGlzLmEgPSBuZXcgYm4oY29uZi5hLCAxNikudW1vZCh0aGlzLnJlZC5tKTtcbiAgdGhpcy5hID0gdGhpcy5hLnRvUmVkKHRoaXMucmVkKTtcbiAgdGhpcy5jID0gbmV3IGJuKGNvbmYuYywgMTYpLnRvUmVkKHRoaXMucmVkKTtcbiAgdGhpcy5jMiA9IHRoaXMuYy5yZWRTcXIoKTtcbiAgdGhpcy5kID0gbmV3IGJuKGNvbmYuZCwgMTYpLnRvUmVkKHRoaXMucmVkKTtcbiAgdGhpcy5kZCA9IHRoaXMuZC5yZWRBZGQodGhpcy5kKTtcblxuICBhc3NlcnQoIXRoaXMudHdpc3RlZCB8fCB0aGlzLmMuZnJvbVJlZCgpLmNtcG4oMSkgPT09IDApO1xuICB0aGlzLm9uZUMgPSAoY29uZi5jIHwgMCkgPT09IDE7XG59XG5pbmhlcml0cyhFZHdhcmRzQ3VydmUsIEJhc2UpO1xubW9kdWxlLmV4cG9ydHMgPSBFZHdhcmRzQ3VydmU7XG5cbkVkd2FyZHNDdXJ2ZS5wcm90b3R5cGUuX211bEEgPSBmdW5jdGlvbiBfbXVsQShudW0pIHtcbiAgaWYgKHRoaXMubU9uZUEpXG4gICAgcmV0dXJuIG51bS5yZWROZWcoKTtcbiAgZWxzZVxuICAgIHJldHVybiB0aGlzLmEucmVkTXVsKG51bSk7XG59O1xuXG5FZHdhcmRzQ3VydmUucHJvdG90eXBlLl9tdWxDID0gZnVuY3Rpb24gX211bEMobnVtKSB7XG4gIGlmICh0aGlzLm9uZUMpXG4gICAgcmV0dXJuIG51bTtcbiAgZWxzZVxuICAgIHJldHVybiB0aGlzLmMucmVkTXVsKG51bSk7XG59O1xuXG4vLyBKdXN0IGZvciBjb21wYXRpYmlsaXR5IHdpdGggU2hvcnQgY3VydmVcbkVkd2FyZHNDdXJ2ZS5wcm90b3R5cGUuanBvaW50ID0gZnVuY3Rpb24ganBvaW50KHgsIHksIHosIHQpIHtcbiAgcmV0dXJuIHRoaXMucG9pbnQoeCwgeSwgeiwgdCk7XG59O1xuXG5FZHdhcmRzQ3VydmUucHJvdG90eXBlLnBvaW50RnJvbVggPSBmdW5jdGlvbiBwb2ludEZyb21YKHgsIG9kZCkge1xuICB4ID0gbmV3IGJuKHgsIDE2KTtcbiAgaWYgKCF4LnJlZClcbiAgICB4ID0geC50b1JlZCh0aGlzLnJlZCk7XG5cbiAgdmFyIHgyID0geC5yZWRTcXIoKTtcbiAgdmFyIHJocyA9IHRoaXMuYzIucmVkU3ViKHRoaXMuYS5yZWRNdWwoeDIpKTtcbiAgdmFyIGxocyA9IHRoaXMub25lLnJlZFN1Yih0aGlzLmMyLnJlZE11bCh0aGlzLmQpLnJlZE11bCh4MikpO1xuXG4gIHZhciB5ID0gcmhzLnJlZE11bChsaHMucmVkSW52bSgpKS5yZWRTcXJ0KCk7XG4gIHZhciBpc09kZCA9IHkuZnJvbVJlZCgpLmlzT2RkKCk7XG4gIGlmIChvZGQgJiYgIWlzT2RkIHx8ICFvZGQgJiYgaXNPZGQpXG4gICAgeSA9IHkucmVkTmVnKCk7XG5cbiAgcmV0dXJuIHRoaXMucG9pbnQoeCwgeSk7XG59O1xuXG5FZHdhcmRzQ3VydmUucHJvdG90eXBlLnBvaW50RnJvbVkgPSBmdW5jdGlvbiBwb2ludEZyb21ZKHksIG9kZCkge1xuICB5ID0gbmV3IGJuKHksIDE2KTtcbiAgaWYgKCF5LnJlZClcbiAgICB5ID0geS50b1JlZCh0aGlzLnJlZCk7XG5cbiAgLy8geF4yID0gKHleMiAtIDEpIC8gKGQgeV4yICsgMSlcbiAgdmFyIHkyID0geS5yZWRTcXIoKTtcbiAgdmFyIGxocyA9IHkyLnJlZFN1Yih0aGlzLm9uZSk7XG4gIHZhciByaHMgPSB5Mi5yZWRNdWwodGhpcy5kKS5yZWRBZGQodGhpcy5vbmUpO1xuICB2YXIgeDIgPSBsaHMucmVkTXVsKHJocy5yZWRJbnZtKCkpO1xuXG4gIGlmICh4Mi5jbXAodGhpcy56ZXJvKSA9PT0gMCkge1xuICAgIGlmIChvZGQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcG9pbnQnKTtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gdGhpcy5wb2ludCh0aGlzLnplcm8sIHkpO1xuICB9XG5cbiAgdmFyIHggPSB4Mi5yZWRTcXJ0KCk7XG4gIGlmICh4LnJlZFNxcigpLnJlZFN1Yih4MikuY21wKHRoaXMuemVybykgIT09IDApXG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHBvaW50Jyk7XG5cbiAgaWYgKHguaXNPZGQoKSAhPT0gb2RkKVxuICAgIHggPSB4LnJlZE5lZygpO1xuXG4gIHJldHVybiB0aGlzLnBvaW50KHgsIHkpO1xufTtcblxuRWR3YXJkc0N1cnZlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uIHZhbGlkYXRlKHBvaW50KSB7XG4gIGlmIChwb2ludC5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHRydWU7XG5cbiAgLy8gQ3VydmU6IEEgKiBYXjIgKyBZXjIgPSBDXjIgKiAoMSArIEQgKiBYXjIgKiBZXjIpXG4gIHBvaW50Lm5vcm1hbGl6ZSgpO1xuXG4gIHZhciB4MiA9IHBvaW50LngucmVkU3FyKCk7XG4gIHZhciB5MiA9IHBvaW50LnkucmVkU3FyKCk7XG4gIHZhciBsaHMgPSB4Mi5yZWRNdWwodGhpcy5hKS5yZWRBZGQoeTIpO1xuICB2YXIgcmhzID0gdGhpcy5jMi5yZWRNdWwodGhpcy5vbmUucmVkQWRkKHRoaXMuZC5yZWRNdWwoeDIpLnJlZE11bCh5MikpKTtcblxuICByZXR1cm4gbGhzLmNtcChyaHMpID09PSAwO1xufTtcblxuZnVuY3Rpb24gUG9pbnQoY3VydmUsIHgsIHksIHosIHQpIHtcbiAgQmFzZS5CYXNlUG9pbnQuY2FsbCh0aGlzLCBjdXJ2ZSwgJ3Byb2plY3RpdmUnKTtcbiAgaWYgKHggPT09IG51bGwgJiYgeSA9PT0gbnVsbCAmJiB6ID09PSBudWxsKSB7XG4gICAgdGhpcy54ID0gdGhpcy5jdXJ2ZS56ZXJvO1xuICAgIHRoaXMueSA9IHRoaXMuY3VydmUub25lO1xuICAgIHRoaXMueiA9IHRoaXMuY3VydmUub25lO1xuICAgIHRoaXMudCA9IHRoaXMuY3VydmUuemVybztcbiAgICB0aGlzLnpPbmUgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHRoaXMueCA9IG5ldyBibih4LCAxNik7XG4gICAgdGhpcy55ID0gbmV3IGJuKHksIDE2KTtcbiAgICB0aGlzLnogPSB6ID8gbmV3IGJuKHosIDE2KSA6IHRoaXMuY3VydmUub25lO1xuICAgIHRoaXMudCA9IHQgJiYgbmV3IGJuKHQsIDE2KTtcbiAgICBpZiAoIXRoaXMueC5yZWQpXG4gICAgICB0aGlzLnggPSB0aGlzLngudG9SZWQodGhpcy5jdXJ2ZS5yZWQpO1xuICAgIGlmICghdGhpcy55LnJlZClcbiAgICAgIHRoaXMueSA9IHRoaXMueS50b1JlZCh0aGlzLmN1cnZlLnJlZCk7XG4gICAgaWYgKCF0aGlzLnoucmVkKVxuICAgICAgdGhpcy56ID0gdGhpcy56LnRvUmVkKHRoaXMuY3VydmUucmVkKTtcbiAgICBpZiAodGhpcy50ICYmICF0aGlzLnQucmVkKVxuICAgICAgdGhpcy50ID0gdGhpcy50LnRvUmVkKHRoaXMuY3VydmUucmVkKTtcbiAgICB0aGlzLnpPbmUgPSB0aGlzLnogPT09IHRoaXMuY3VydmUub25lO1xuXG4gICAgLy8gVXNlIGV4dGVuZGVkIGNvb3JkaW5hdGVzXG4gICAgaWYgKHRoaXMuY3VydmUuZXh0ZW5kZWQgJiYgIXRoaXMudCkge1xuICAgICAgdGhpcy50ID0gdGhpcy54LnJlZE11bCh0aGlzLnkpO1xuICAgICAgaWYgKCF0aGlzLnpPbmUpXG4gICAgICAgIHRoaXMudCA9IHRoaXMudC5yZWRNdWwodGhpcy56LnJlZEludm0oKSk7XG4gICAgfVxuICB9XG59XG5pbmhlcml0cyhQb2ludCwgQmFzZS5CYXNlUG9pbnQpO1xuXG5FZHdhcmRzQ3VydmUucHJvdG90eXBlLnBvaW50RnJvbUpTT04gPSBmdW5jdGlvbiBwb2ludEZyb21KU09OKG9iaikge1xuICByZXR1cm4gUG9pbnQuZnJvbUpTT04odGhpcywgb2JqKTtcbn07XG5cbkVkd2FyZHNDdXJ2ZS5wcm90b3R5cGUucG9pbnQgPSBmdW5jdGlvbiBwb2ludCh4LCB5LCB6LCB0KSB7XG4gIHJldHVybiBuZXcgUG9pbnQodGhpcywgeCwgeSwgeiwgdCk7XG59O1xuXG5Qb2ludC5mcm9tSlNPTiA9IGZ1bmN0aW9uIGZyb21KU09OKGN1cnZlLCBvYmopIHtcbiAgcmV0dXJuIG5ldyBQb2ludChjdXJ2ZSwgb2JqWzBdLCBvYmpbMV0sIG9ialsyXSk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QoKSB7XG4gIGlmICh0aGlzLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gJzxFQyBQb2ludCBJbmZpbml0eT4nO1xuICByZXR1cm4gJzxFQyBQb2ludCB4OiAnICsgdGhpcy54LmZyb21SZWQoKS50b1N0cmluZygxNiwgMikgK1xuICAgICAgJyB5OiAnICsgdGhpcy55LmZyb21SZWQoKS50b1N0cmluZygxNiwgMikgK1xuICAgICAgJyB6OiAnICsgdGhpcy56LmZyb21SZWQoKS50b1N0cmluZygxNiwgMikgKyAnPic7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuaXNJbmZpbml0eSA9IGZ1bmN0aW9uIGlzSW5maW5pdHkoKSB7XG4gIC8vIFhYWCBUaGlzIGNvZGUgYXNzdW1lcyB0aGF0IHplcm8gaXMgYWx3YXlzIHplcm8gaW4gcmVkXG4gIHJldHVybiB0aGlzLnguY21wbigwKSA9PT0gMCAmJlxuICAgICAgICAgdGhpcy55LmNtcCh0aGlzLnopID09PSAwO1xufTtcblxuUG9pbnQucHJvdG90eXBlLl9leHREYmwgPSBmdW5jdGlvbiBfZXh0RGJsKCkge1xuICAvLyBoeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tdHdpc3RlZC1leHRlbmRlZC0xLmh0bWxcbiAgLy8gICAgICNkb3VibGluZy1kYmwtMjAwOC1od2NkXG4gIC8vIDRNICsgNFNcblxuICAvLyBBID0gWDFeMlxuICB2YXIgYSA9IHRoaXMueC5yZWRTcXIoKTtcbiAgLy8gQiA9IFkxXjJcbiAgdmFyIGIgPSB0aGlzLnkucmVkU3FyKCk7XG4gIC8vIEMgPSAyICogWjFeMlxuICB2YXIgYyA9IHRoaXMuei5yZWRTcXIoKTtcbiAgYyA9IGMucmVkSUFkZChjKTtcbiAgLy8gRCA9IGEgKiBBXG4gIHZhciBkID0gdGhpcy5jdXJ2ZS5fbXVsQShhKTtcbiAgLy8gRSA9IChYMSArIFkxKV4yIC0gQSAtIEJcbiAgdmFyIGUgPSB0aGlzLngucmVkQWRkKHRoaXMueSkucmVkU3FyKCkucmVkSVN1YihhKS5yZWRJU3ViKGIpO1xuICAvLyBHID0gRCArIEJcbiAgdmFyIGcgPSBkLnJlZEFkZChiKTtcbiAgLy8gRiA9IEcgLSBDXG4gIHZhciBmID0gZy5yZWRTdWIoYyk7XG4gIC8vIEggPSBEIC0gQlxuICB2YXIgaCA9IGQucmVkU3ViKGIpO1xuICAvLyBYMyA9IEUgKiBGXG4gIHZhciBueCA9IGUucmVkTXVsKGYpO1xuICAvLyBZMyA9IEcgKiBIXG4gIHZhciBueSA9IGcucmVkTXVsKGgpO1xuICAvLyBUMyA9IEUgKiBIXG4gIHZhciBudCA9IGUucmVkTXVsKGgpO1xuICAvLyBaMyA9IEYgKiBHXG4gIHZhciBueiA9IGYucmVkTXVsKGcpO1xuICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChueCwgbnksIG56LCBudCk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuX3Byb2pEYmwgPSBmdW5jdGlvbiBfcHJvakRibCgpIHtcbiAgLy8gaHlwZXJlbGxpcHRpYy5vcmcvRUZEL2cxcC9hdXRvLXR3aXN0ZWQtcHJvamVjdGl2ZS5odG1sXG4gIC8vICAgICAjZG91YmxpbmctZGJsLTIwMDgtYmJqbHBcbiAgLy8gICAgICNkb3VibGluZy1kYmwtMjAwNy1ibFxuICAvLyBhbmQgb3RoZXJzXG4gIC8vIEdlbmVyYWxseSAzTSArIDRTIG9yIDJNICsgNFNcblxuICAvLyBCID0gKFgxICsgWTEpXjJcbiAgdmFyIGIgPSB0aGlzLngucmVkQWRkKHRoaXMueSkucmVkU3FyKCk7XG4gIC8vIEMgPSBYMV4yXG4gIHZhciBjID0gdGhpcy54LnJlZFNxcigpO1xuICAvLyBEID0gWTFeMlxuICB2YXIgZCA9IHRoaXMueS5yZWRTcXIoKTtcblxuICB2YXIgbng7XG4gIHZhciBueTtcbiAgdmFyIG56O1xuICBpZiAodGhpcy5jdXJ2ZS50d2lzdGVkKSB7XG4gICAgLy8gRSA9IGEgKiBDXG4gICAgdmFyIGUgPSB0aGlzLmN1cnZlLl9tdWxBKGMpO1xuICAgIC8vIEYgPSBFICsgRFxuICAgIHZhciBmID0gZS5yZWRBZGQoZCk7XG4gICAgaWYgKHRoaXMuek9uZSkge1xuICAgICAgLy8gWDMgPSAoQiAtIEMgLSBEKSAqIChGIC0gMilcbiAgICAgIG54ID0gYi5yZWRTdWIoYykucmVkU3ViKGQpLnJlZE11bChmLnJlZFN1Yih0aGlzLmN1cnZlLnR3bykpO1xuICAgICAgLy8gWTMgPSBGICogKEUgLSBEKVxuICAgICAgbnkgPSBmLnJlZE11bChlLnJlZFN1YihkKSk7XG4gICAgICAvLyBaMyA9IEZeMiAtIDIgKiBGXG4gICAgICBueiA9IGYucmVkU3FyKCkucmVkU3ViKGYpLnJlZFN1YihmKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSCA9IFoxXjJcbiAgICAgIHZhciBoID0gdGhpcy56LnJlZFNxcigpO1xuICAgICAgLy8gSiA9IEYgLSAyICogSFxuICAgICAgdmFyIGogPSBmLnJlZFN1YihoKS5yZWRJU3ViKGgpO1xuICAgICAgLy8gWDMgPSAoQi1DLUQpKkpcbiAgICAgIG54ID0gYi5yZWRTdWIoYykucmVkSVN1YihkKS5yZWRNdWwoaik7XG4gICAgICAvLyBZMyA9IEYgKiAoRSAtIEQpXG4gICAgICBueSA9IGYucmVkTXVsKGUucmVkU3ViKGQpKTtcbiAgICAgIC8vIFozID0gRiAqIEpcbiAgICAgIG56ID0gZi5yZWRNdWwoaik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIEUgPSBDICsgRFxuICAgIHZhciBlID0gYy5yZWRBZGQoZCk7XG4gICAgLy8gSCA9IChjICogWjEpXjJcbiAgICB2YXIgaCA9IHRoaXMuY3VydmUuX211bEModGhpcy5jLnJlZE11bCh0aGlzLnopKS5yZWRTcXIoKTtcbiAgICAvLyBKID0gRSAtIDIgKiBIXG4gICAgdmFyIGogPSBlLnJlZFN1YihoKS5yZWRTdWIoaCk7XG4gICAgLy8gWDMgPSBjICogKEIgLSBFKSAqIEpcbiAgICBueCA9IHRoaXMuY3VydmUuX211bEMoYi5yZWRJU3ViKGUpKS5yZWRNdWwoaik7XG4gICAgLy8gWTMgPSBjICogRSAqIChDIC0gRClcbiAgICBueSA9IHRoaXMuY3VydmUuX211bEMoZSkucmVkTXVsKGMucmVkSVN1YihkKSk7XG4gICAgLy8gWjMgPSBFICogSlxuICAgIG56ID0gZS5yZWRNdWwoaik7XG4gIH1cbiAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobngsIG55LCBueik7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZGJsID0gZnVuY3Rpb24gZGJsKCkge1xuICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gRG91YmxlIGluIGV4dGVuZGVkIGNvb3JkaW5hdGVzXG4gIGlmICh0aGlzLmN1cnZlLmV4dGVuZGVkKVxuICAgIHJldHVybiB0aGlzLl9leHREYmwoKTtcbiAgZWxzZVxuICAgIHJldHVybiB0aGlzLl9wcm9qRGJsKCk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuX2V4dEFkZCA9IGZ1bmN0aW9uIF9leHRBZGQocCkge1xuICAvLyBoeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tdHdpc3RlZC1leHRlbmRlZC0xLmh0bWxcbiAgLy8gICAgICNhZGRpdGlvbi1hZGQtMjAwOC1od2NkLTNcbiAgLy8gOE1cblxuICAvLyBBID0gKFkxIC0gWDEpICogKFkyIC0gWDIpXG4gIHZhciBhID0gdGhpcy55LnJlZFN1Yih0aGlzLngpLnJlZE11bChwLnkucmVkU3ViKHAueCkpO1xuICAvLyBCID0gKFkxICsgWDEpICogKFkyICsgWDIpXG4gIHZhciBiID0gdGhpcy55LnJlZEFkZCh0aGlzLngpLnJlZE11bChwLnkucmVkQWRkKHAueCkpO1xuICAvLyBDID0gVDEgKiBrICogVDJcbiAgdmFyIGMgPSB0aGlzLnQucmVkTXVsKHRoaXMuY3VydmUuZGQpLnJlZE11bChwLnQpO1xuICAvLyBEID0gWjEgKiAyICogWjJcbiAgdmFyIGQgPSB0aGlzLnoucmVkTXVsKHAuei5yZWRBZGQocC56KSk7XG4gIC8vIEUgPSBCIC0gQVxuICB2YXIgZSA9IGIucmVkU3ViKGEpO1xuICAvLyBGID0gRCAtIENcbiAgdmFyIGYgPSBkLnJlZFN1YihjKTtcbiAgLy8gRyA9IEQgKyBDXG4gIHZhciBnID0gZC5yZWRBZGQoYyk7XG4gIC8vIEggPSBCICsgQVxuICB2YXIgaCA9IGIucmVkQWRkKGEpO1xuICAvLyBYMyA9IEUgKiBGXG4gIHZhciBueCA9IGUucmVkTXVsKGYpO1xuICAvLyBZMyA9IEcgKiBIXG4gIHZhciBueSA9IGcucmVkTXVsKGgpO1xuICAvLyBUMyA9IEUgKiBIXG4gIHZhciBudCA9IGUucmVkTXVsKGgpO1xuICAvLyBaMyA9IEYgKiBHXG4gIHZhciBueiA9IGYucmVkTXVsKGcpO1xuICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChueCwgbnksIG56LCBudCk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuX3Byb2pBZGQgPSBmdW5jdGlvbiBfcHJvakFkZChwKSB7XG4gIC8vIGh5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by10d2lzdGVkLXByb2plY3RpdmUuaHRtbFxuICAvLyAgICAgI2FkZGl0aW9uLWFkZC0yMDA4LWJiamxwXG4gIC8vICAgICAjYWRkaXRpb24tYWRkLTIwMDctYmxcbiAgLy8gMTBNICsgMVNcblxuICAvLyBBID0gWjEgKiBaMlxuICB2YXIgYSA9IHRoaXMuei5yZWRNdWwocC56KTtcbiAgLy8gQiA9IEFeMlxuICB2YXIgYiA9IGEucmVkU3FyKCk7XG4gIC8vIEMgPSBYMSAqIFgyXG4gIHZhciBjID0gdGhpcy54LnJlZE11bChwLngpO1xuICAvLyBEID0gWTEgKiBZMlxuICB2YXIgZCA9IHRoaXMueS5yZWRNdWwocC55KTtcbiAgLy8gRSA9IGQgKiBDICogRFxuICB2YXIgZSA9IHRoaXMuY3VydmUuZC5yZWRNdWwoYykucmVkTXVsKGQpO1xuICAvLyBGID0gQiAtIEVcbiAgdmFyIGYgPSBiLnJlZFN1YihlKTtcbiAgLy8gRyA9IEIgKyBFXG4gIHZhciBnID0gYi5yZWRBZGQoZSk7XG4gIC8vIFgzID0gQSAqIEYgKiAoKFgxICsgWTEpICogKFgyICsgWTIpIC0gQyAtIEQpXG4gIHZhciB0bXAgPSB0aGlzLngucmVkQWRkKHRoaXMueSkucmVkTXVsKHAueC5yZWRBZGQocC55KSkucmVkSVN1YihjKS5yZWRJU3ViKGQpO1xuICB2YXIgbnggPSBhLnJlZE11bChmKS5yZWRNdWwodG1wKTtcbiAgdmFyIG55O1xuICB2YXIgbno7XG4gIGlmICh0aGlzLmN1cnZlLnR3aXN0ZWQpIHtcbiAgICAvLyBZMyA9IEEgKiBHICogKEQgLSBhICogQylcbiAgICBueSA9IGEucmVkTXVsKGcpLnJlZE11bChkLnJlZFN1Yih0aGlzLmN1cnZlLl9tdWxBKGMpKSk7XG4gICAgLy8gWjMgPSBGICogR1xuICAgIG56ID0gZi5yZWRNdWwoZyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gWTMgPSBBICogRyAqIChEIC0gQylcbiAgICBueSA9IGEucmVkTXVsKGcpLnJlZE11bChkLnJlZFN1YihjKSk7XG4gICAgLy8gWjMgPSBjICogRiAqIEdcbiAgICBueiA9IHRoaXMuY3VydmUuX211bEMoZikucmVkTXVsKGcpO1xuICB9XG4gIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG54LCBueSwgbnopO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZChwKSB7XG4gIGlmICh0aGlzLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gcDtcbiAgaWYgKHAuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIGlmICh0aGlzLmN1cnZlLmV4dGVuZGVkKVxuICAgIHJldHVybiB0aGlzLl9leHRBZGQocCk7XG4gIGVsc2VcbiAgICByZXR1cm4gdGhpcy5fcHJvakFkZChwKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiBtdWwoaykge1xuICBpZiAodGhpcy5faGFzRG91YmxlcyhrKSlcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5fZml4ZWROYWZNdWwodGhpcywgayk7XG4gIGVsc2VcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5fd25hZk11bCh0aGlzLCBrKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5tdWxBZGQgPSBmdW5jdGlvbiBtdWxBZGQoazEsIHAsIGsyKSB7XG4gIHJldHVybiB0aGlzLmN1cnZlLl93bmFmTXVsQWRkKDEsIFsgdGhpcywgcCBdLCBbIGsxLCBrMiBdLCAyKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5ub3JtYWxpemUgPSBmdW5jdGlvbiBub3JtYWxpemUoKSB7XG4gIGlmICh0aGlzLnpPbmUpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gTm9ybWFsaXplIGNvb3JkaW5hdGVzXG4gIHZhciB6aSA9IHRoaXMuei5yZWRJbnZtKCk7XG4gIHRoaXMueCA9IHRoaXMueC5yZWRNdWwoemkpO1xuICB0aGlzLnkgPSB0aGlzLnkucmVkTXVsKHppKTtcbiAgaWYgKHRoaXMudClcbiAgICB0aGlzLnQgPSB0aGlzLnQucmVkTXVsKHppKTtcbiAgdGhpcy56ID0gdGhpcy5jdXJ2ZS5vbmU7XG4gIHRoaXMuek9uZSA9IHRydWU7XG4gIHJldHVybiB0aGlzO1xufTtcblxuUG9pbnQucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uIG5lZygpIHtcbiAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQodGhpcy54LnJlZE5lZygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMueixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50ICYmIHRoaXMudC5yZWROZWcoKSk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZ2V0WCA9IGZ1bmN0aW9uIGdldFgoKSB7XG4gIHRoaXMubm9ybWFsaXplKCk7XG4gIHJldHVybiB0aGlzLnguZnJvbVJlZCgpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmdldFkgPSBmdW5jdGlvbiBnZXRZKCkge1xuICB0aGlzLm5vcm1hbGl6ZSgpO1xuICByZXR1cm4gdGhpcy55LmZyb21SZWQoKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5lcSA9IGZ1bmN0aW9uIGVxKG90aGVyKSB7XG4gIHJldHVybiB0aGlzID09PSBvdGhlciB8fFxuICAgICAgICAgdGhpcy5nZXRYKCkuY21wKG90aGVyLmdldFgoKSkgPT09IDAgJiZcbiAgICAgICAgIHRoaXMuZ2V0WSgpLmNtcChvdGhlci5nZXRZKCkpID09PSAwO1xufTtcblxuLy8gQ29tcGF0aWJpbGl0eSB3aXRoIEJhc2VDdXJ2ZVxuUG9pbnQucHJvdG90eXBlLnRvUCA9IFBvaW50LnByb3RvdHlwZS5ub3JtYWxpemU7XG5Qb2ludC5wcm90b3R5cGUubWl4ZWRBZGQgPSBQb2ludC5wcm90b3R5cGUuYWRkO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY3VydmUgPSBleHBvcnRzO1xuXG5jdXJ2ZS5iYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XG5jdXJ2ZS5zaG9ydCA9IHJlcXVpcmUoJy4vc2hvcnQnKTtcbmN1cnZlLm1vbnQgPSByZXF1aXJlKCcuL21vbnQnKTtcbmN1cnZlLmVkd2FyZHMgPSByZXF1aXJlKCcuL2Vkd2FyZHMnKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGN1cnZlID0gcmVxdWlyZSgnLi4vY3VydmUnKTtcbnZhciBibiA9IHJlcXVpcmUoJ2JuLmpzJyk7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xudmFyIEJhc2UgPSBjdXJ2ZS5iYXNlO1xuXG52YXIgZWxsaXB0aWMgPSByZXF1aXJlKCcuLi8uLi9lbGxpcHRpYycpO1xudmFyIHV0aWxzID0gZWxsaXB0aWMudXRpbHM7XG5cbmZ1bmN0aW9uIE1vbnRDdXJ2ZShjb25mKSB7XG4gIEJhc2UuY2FsbCh0aGlzLCAnbW9udCcsIGNvbmYpO1xuXG4gIHRoaXMuYSA9IG5ldyBibihjb25mLmEsIDE2KS50b1JlZCh0aGlzLnJlZCk7XG4gIHRoaXMuYiA9IG5ldyBibihjb25mLmIsIDE2KS50b1JlZCh0aGlzLnJlZCk7XG4gIHRoaXMuaTQgPSBuZXcgYm4oNCkudG9SZWQodGhpcy5yZWQpLnJlZEludm0oKTtcbiAgdGhpcy50d28gPSBuZXcgYm4oMikudG9SZWQodGhpcy5yZWQpO1xuICB0aGlzLmEyNCA9IHRoaXMuaTQucmVkTXVsKHRoaXMuYS5yZWRBZGQodGhpcy50d28pKTtcbn1cbmluaGVyaXRzKE1vbnRDdXJ2ZSwgQmFzZSk7XG5tb2R1bGUuZXhwb3J0cyA9IE1vbnRDdXJ2ZTtcblxuTW9udEN1cnZlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uIHZhbGlkYXRlKHBvaW50KSB7XG4gIHZhciB4ID0gcG9pbnQubm9ybWFsaXplKCkueDtcbiAgdmFyIHgyID0geC5yZWRTcXIoKTtcbiAgdmFyIHJocyA9IHgyLnJlZE11bCh4KS5yZWRBZGQoeDIucmVkTXVsKHRoaXMuYSkpLnJlZEFkZCh4KTtcbiAgdmFyIHkgPSByaHMucmVkU3FydCgpO1xuXG4gIHJldHVybiB5LnJlZFNxcigpLmNtcChyaHMpID09PSAwO1xufTtcblxuZnVuY3Rpb24gUG9pbnQoY3VydmUsIHgsIHopIHtcbiAgQmFzZS5CYXNlUG9pbnQuY2FsbCh0aGlzLCBjdXJ2ZSwgJ3Byb2plY3RpdmUnKTtcbiAgaWYgKHggPT09IG51bGwgJiYgeiA9PT0gbnVsbCkge1xuICAgIHRoaXMueCA9IHRoaXMuY3VydmUub25lO1xuICAgIHRoaXMueiA9IHRoaXMuY3VydmUuemVybztcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnggPSBuZXcgYm4oeCwgMTYpO1xuICAgIHRoaXMueiA9IG5ldyBibih6LCAxNik7XG4gICAgaWYgKCF0aGlzLngucmVkKVxuICAgICAgdGhpcy54ID0gdGhpcy54LnRvUmVkKHRoaXMuY3VydmUucmVkKTtcbiAgICBpZiAoIXRoaXMuei5yZWQpXG4gICAgICB0aGlzLnogPSB0aGlzLnoudG9SZWQodGhpcy5jdXJ2ZS5yZWQpO1xuICB9XG59XG5pbmhlcml0cyhQb2ludCwgQmFzZS5CYXNlUG9pbnQpO1xuXG5Nb250Q3VydmUucHJvdG90eXBlLmRlY29kZVBvaW50ID0gZnVuY3Rpb24gZGVjb2RlUG9pbnQoYnl0ZXMsIGVuYykge1xuICByZXR1cm4gdGhpcy5wb2ludCh1dGlscy50b0FycmF5KGJ5dGVzLCBlbmMpLCAxKTtcbn07XG5cbk1vbnRDdXJ2ZS5wcm90b3R5cGUucG9pbnQgPSBmdW5jdGlvbiBwb2ludCh4LCB6KSB7XG4gIHJldHVybiBuZXcgUG9pbnQodGhpcywgeCwgeik7XG59O1xuXG5Nb250Q3VydmUucHJvdG90eXBlLnBvaW50RnJvbUpTT04gPSBmdW5jdGlvbiBwb2ludEZyb21KU09OKG9iaikge1xuICByZXR1cm4gUG9pbnQuZnJvbUpTT04odGhpcywgb2JqKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5wcmVjb21wdXRlID0gZnVuY3Rpb24gcHJlY29tcHV0ZSgpIHtcbiAgLy8gTm8tb3Bcbn07XG5cblBvaW50LnByb3RvdHlwZS5fZW5jb2RlID0gZnVuY3Rpb24gX2VuY29kZSgpIHtcbiAgcmV0dXJuIHRoaXMuZ2V0WCgpLnRvQXJyYXkoJ2JlJywgdGhpcy5jdXJ2ZS5wLmJ5dGVMZW5ndGgoKSk7XG59O1xuXG5Qb2ludC5mcm9tSlNPTiA9IGZ1bmN0aW9uIGZyb21KU09OKGN1cnZlLCBvYmopIHtcbiAgcmV0dXJuIG5ldyBQb2ludChjdXJ2ZSwgb2JqWzBdLCBvYmpbMV0gfHwgY3VydmUub25lKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCgpIHtcbiAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiAnPEVDIFBvaW50IEluZmluaXR5Pic7XG4gIHJldHVybiAnPEVDIFBvaW50IHg6ICcgKyB0aGlzLnguZnJvbVJlZCgpLnRvU3RyaW5nKDE2LCAyKSArXG4gICAgICAnIHo6ICcgKyB0aGlzLnouZnJvbVJlZCgpLnRvU3RyaW5nKDE2LCAyKSArICc+Jztcbn07XG5cblBvaW50LnByb3RvdHlwZS5pc0luZmluaXR5ID0gZnVuY3Rpb24gaXNJbmZpbml0eSgpIHtcbiAgLy8gWFhYIFRoaXMgY29kZSBhc3N1bWVzIHRoYXQgemVybyBpcyBhbHdheXMgemVybyBpbiByZWRcbiAgcmV0dXJuIHRoaXMuei5jbXBuKDApID09PSAwO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmRibCA9IGZ1bmN0aW9uIGRibCgpIHtcbiAgLy8gaHR0cDovL2h5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by1tb250Z29tLXh6Lmh0bWwjZG91YmxpbmctZGJsLTE5ODctbS0zXG4gIC8vIDJNICsgMlMgKyA0QVxuXG4gIC8vIEEgPSBYMSArIFoxXG4gIHZhciBhID0gdGhpcy54LnJlZEFkZCh0aGlzLnopO1xuICAvLyBBQSA9IEFeMlxuICB2YXIgYWEgPSBhLnJlZFNxcigpO1xuICAvLyBCID0gWDEgLSBaMVxuICB2YXIgYiA9IHRoaXMueC5yZWRTdWIodGhpcy56KTtcbiAgLy8gQkIgPSBCXjJcbiAgdmFyIGJiID0gYi5yZWRTcXIoKTtcbiAgLy8gQyA9IEFBIC0gQkJcbiAgdmFyIGMgPSBhYS5yZWRTdWIoYmIpO1xuICAvLyBYMyA9IEFBICogQkJcbiAgdmFyIG54ID0gYWEucmVkTXVsKGJiKTtcbiAgLy8gWjMgPSBDICogKEJCICsgQTI0ICogQylcbiAgdmFyIG56ID0gYy5yZWRNdWwoYmIucmVkQWRkKHRoaXMuY3VydmUuYTI0LnJlZE11bChjKSkpO1xuICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChueCwgbnopO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdOb3Qgc3VwcG9ydGVkIG9uIE1vbnRnb21lcnkgY3VydmUnKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5kaWZmQWRkID0gZnVuY3Rpb24gZGlmZkFkZChwLCBkaWZmKSB7XG4gIC8vIGh0dHA6Ly9oeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tbW9udGdvbS14ei5odG1sI2RpZmZhZGQtZGFkZC0xOTg3LW0tM1xuICAvLyA0TSArIDJTICsgNkFcblxuICAvLyBBID0gWDIgKyBaMlxuICB2YXIgYSA9IHRoaXMueC5yZWRBZGQodGhpcy56KTtcbiAgLy8gQiA9IFgyIC0gWjJcbiAgdmFyIGIgPSB0aGlzLngucmVkU3ViKHRoaXMueik7XG4gIC8vIEMgPSBYMyArIFozXG4gIHZhciBjID0gcC54LnJlZEFkZChwLnopO1xuICAvLyBEID0gWDMgLSBaM1xuICB2YXIgZCA9IHAueC5yZWRTdWIocC56KTtcbiAgLy8gREEgPSBEICogQVxuICB2YXIgZGEgPSBkLnJlZE11bChhKTtcbiAgLy8gQ0IgPSBDICogQlxuICB2YXIgY2IgPSBjLnJlZE11bChiKTtcbiAgLy8gWDUgPSBaMSAqIChEQSArIENCKV4yXG4gIHZhciBueCA9IGRpZmYuei5yZWRNdWwoZGEucmVkQWRkKGNiKS5yZWRTcXIoKSk7XG4gIC8vIFo1ID0gWDEgKiAoREEgLSBDQileMlxuICB2YXIgbnogPSBkaWZmLngucmVkTXVsKGRhLnJlZElTdWIoY2IpLnJlZFNxcigpKTtcbiAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobngsIG56KTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiBtdWwoaykge1xuICB2YXIgdCA9IGsuY2xvbmUoKTtcbiAgdmFyIGEgPSB0aGlzOyAvLyAoTiAvIDIpICogUSArIFFcbiAgdmFyIGIgPSB0aGlzLmN1cnZlLnBvaW50KG51bGwsIG51bGwpOyAvLyAoTiAvIDIpICogUVxuICB2YXIgYyA9IHRoaXM7IC8vIFFcblxuICBmb3IgKHZhciBiaXRzID0gW107IHQuY21wbigwKSAhPT0gMDsgdC5pdXNocm4oMSkpXG4gICAgYml0cy5wdXNoKHQuYW5kbG4oMSkpO1xuXG4gIGZvciAodmFyIGkgPSBiaXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKGJpdHNbaV0gPT09IDApIHtcbiAgICAgIC8vIE4gKiBRICsgUSA9ICgoTiAvIDIpICogUSArIFEpKSArIChOIC8gMikgKiBRXG4gICAgICBhID0gYS5kaWZmQWRkKGIsIGMpO1xuICAgICAgLy8gTiAqIFEgPSAyICogKChOIC8gMikgKiBRICsgUSkpXG4gICAgICBiID0gYi5kYmwoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTiAqIFEgPSAoKE4gLyAyKSAqIFEgKyBRKSArICgoTiAvIDIpICogUSlcbiAgICAgIGIgPSBhLmRpZmZBZGQoYiwgYyk7XG4gICAgICAvLyBOICogUSArIFEgPSAyICogKChOIC8gMikgKiBRICsgUSlcbiAgICAgIGEgPSBhLmRibCgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYjtcbn07XG5cblBvaW50LnByb3RvdHlwZS5tdWxBZGQgPSBmdW5jdGlvbiBtdWxBZGQoKSB7XG4gIHRocm93IG5ldyBFcnJvcignTm90IHN1cHBvcnRlZCBvbiBNb250Z29tZXJ5IGN1cnZlJyk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZXEgPSBmdW5jdGlvbiBlcShvdGhlcikge1xuICByZXR1cm4gdGhpcy5nZXRYKCkuY21wKG90aGVyLmdldFgoKSkgPT09IDA7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUubm9ybWFsaXplID0gZnVuY3Rpb24gbm9ybWFsaXplKCkge1xuICB0aGlzLnggPSB0aGlzLngucmVkTXVsKHRoaXMuei5yZWRJbnZtKCkpO1xuICB0aGlzLnogPSB0aGlzLmN1cnZlLm9uZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZ2V0WCA9IGZ1bmN0aW9uIGdldFgoKSB7XG4gIC8vIE5vcm1hbGl6ZSBjb29yZGluYXRlc1xuICB0aGlzLm5vcm1hbGl6ZSgpO1xuXG4gIHJldHVybiB0aGlzLnguZnJvbVJlZCgpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGN1cnZlID0gcmVxdWlyZSgnLi4vY3VydmUnKTtcbnZhciBlbGxpcHRpYyA9IHJlcXVpcmUoJy4uLy4uL2VsbGlwdGljJyk7XG52YXIgYm4gPSByZXF1aXJlKCdibi5qcycpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbnZhciBCYXNlID0gY3VydmUuYmFzZTtcblxudmFyIGFzc2VydCA9IGVsbGlwdGljLnV0aWxzLmFzc2VydDtcblxuZnVuY3Rpb24gU2hvcnRDdXJ2ZShjb25mKSB7XG4gIEJhc2UuY2FsbCh0aGlzLCAnc2hvcnQnLCBjb25mKTtcblxuICB0aGlzLmEgPSBuZXcgYm4oY29uZi5hLCAxNikudG9SZWQodGhpcy5yZWQpO1xuICB0aGlzLmIgPSBuZXcgYm4oY29uZi5iLCAxNikudG9SZWQodGhpcy5yZWQpO1xuICB0aGlzLnRpbnYgPSB0aGlzLnR3by5yZWRJbnZtKCk7XG5cbiAgdGhpcy56ZXJvQSA9IHRoaXMuYS5mcm9tUmVkKCkuY21wbigwKSA9PT0gMDtcbiAgdGhpcy50aHJlZUEgPSB0aGlzLmEuZnJvbVJlZCgpLnN1Yih0aGlzLnApLmNtcG4oLTMpID09PSAwO1xuXG4gIC8vIElmIHRoZSBjdXJ2ZSBpcyBlbmRvbW9ycGhpYywgcHJlY2FsY3VsYXRlIGJldGEgYW5kIGxhbWJkYVxuICB0aGlzLmVuZG8gPSB0aGlzLl9nZXRFbmRvbW9ycGhpc20oY29uZik7XG4gIHRoaXMuX2VuZG9XbmFmVDEgPSBuZXcgQXJyYXkoNCk7XG4gIHRoaXMuX2VuZG9XbmFmVDIgPSBuZXcgQXJyYXkoNCk7XG59XG5pbmhlcml0cyhTaG9ydEN1cnZlLCBCYXNlKTtcbm1vZHVsZS5leHBvcnRzID0gU2hvcnRDdXJ2ZTtcblxuU2hvcnRDdXJ2ZS5wcm90b3R5cGUuX2dldEVuZG9tb3JwaGlzbSA9IGZ1bmN0aW9uIF9nZXRFbmRvbW9ycGhpc20oY29uZikge1xuICAvLyBObyBlZmZpY2llbnQgZW5kb21vcnBoaXNtXG4gIGlmICghdGhpcy56ZXJvQSB8fCAhdGhpcy5nIHx8ICF0aGlzLm4gfHwgdGhpcy5wLm1vZG4oMykgIT09IDEpXG4gICAgcmV0dXJuO1xuXG4gIC8vIENvbXB1dGUgYmV0YSBhbmQgbGFtYmRhLCB0aGF0IGxhbWJkYSAqIFAgPSAoYmV0YSAqIFB4OyBQeSlcbiAgdmFyIGJldGE7XG4gIHZhciBsYW1iZGE7XG4gIGlmIChjb25mLmJldGEpIHtcbiAgICBiZXRhID0gbmV3IGJuKGNvbmYuYmV0YSwgMTYpLnRvUmVkKHRoaXMucmVkKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgYmV0YXMgPSB0aGlzLl9nZXRFbmRvUm9vdHModGhpcy5wKTtcbiAgICAvLyBDaG9vc2UgdGhlIHNtYWxsZXN0IGJldGFcbiAgICBiZXRhID0gYmV0YXNbMF0uY21wKGJldGFzWzFdKSA8IDAgPyBiZXRhc1swXSA6IGJldGFzWzFdO1xuICAgIGJldGEgPSBiZXRhLnRvUmVkKHRoaXMucmVkKTtcbiAgfVxuICBpZiAoY29uZi5sYW1iZGEpIHtcbiAgICBsYW1iZGEgPSBuZXcgYm4oY29uZi5sYW1iZGEsIDE2KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBDaG9vc2UgdGhlIGxhbWJkYSB0aGF0IGlzIG1hdGNoaW5nIHNlbGVjdGVkIGJldGFcbiAgICB2YXIgbGFtYmRhcyA9IHRoaXMuX2dldEVuZG9Sb290cyh0aGlzLm4pO1xuICAgIGlmICh0aGlzLmcubXVsKGxhbWJkYXNbMF0pLnguY21wKHRoaXMuZy54LnJlZE11bChiZXRhKSkgPT09IDApIHtcbiAgICAgIGxhbWJkYSA9IGxhbWJkYXNbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxhbWJkYSA9IGxhbWJkYXNbMV07XG4gICAgICBhc3NlcnQodGhpcy5nLm11bChsYW1iZGEpLnguY21wKHRoaXMuZy54LnJlZE11bChiZXRhKSkgPT09IDApO1xuICAgIH1cbiAgfVxuXG4gIC8vIEdldCBiYXNpcyB2ZWN0b3JzLCB1c2VkIGZvciBiYWxhbmNlZCBsZW5ndGgtdHdvIHJlcHJlc2VudGF0aW9uXG4gIHZhciBiYXNpcztcbiAgaWYgKGNvbmYuYmFzaXMpIHtcbiAgICBiYXNpcyA9IGNvbmYuYmFzaXMubWFwKGZ1bmN0aW9uKHZlYykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYTogbmV3IGJuKHZlYy5hLCAxNiksXG4gICAgICAgIGI6IG5ldyBibih2ZWMuYiwgMTYpXG4gICAgICB9O1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGJhc2lzID0gdGhpcy5fZ2V0RW5kb0Jhc2lzKGxhbWJkYSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGJldGE6IGJldGEsXG4gICAgbGFtYmRhOiBsYW1iZGEsXG4gICAgYmFzaXM6IGJhc2lzXG4gIH07XG59O1xuXG5TaG9ydEN1cnZlLnByb3RvdHlwZS5fZ2V0RW5kb1Jvb3RzID0gZnVuY3Rpb24gX2dldEVuZG9Sb290cyhudW0pIHtcbiAgLy8gRmluZCByb290cyBvZiBmb3IgeF4yICsgeCArIDEgaW4gRlxuICAvLyBSb290ID0gKC0xICstIFNxcnQoLTMpKSAvIDJcbiAgLy9cbiAgdmFyIHJlZCA9IG51bSA9PT0gdGhpcy5wID8gdGhpcy5yZWQgOiBibi5tb250KG51bSk7XG4gIHZhciB0aW52ID0gbmV3IGJuKDIpLnRvUmVkKHJlZCkucmVkSW52bSgpO1xuICB2YXIgbnRpbnYgPSB0aW52LnJlZE5lZygpO1xuXG4gIHZhciBzID0gbmV3IGJuKDMpLnRvUmVkKHJlZCkucmVkTmVnKCkucmVkU3FydCgpLnJlZE11bCh0aW52KTtcblxuICB2YXIgbDEgPSBudGludi5yZWRBZGQocykuZnJvbVJlZCgpO1xuICB2YXIgbDIgPSBudGludi5yZWRTdWIocykuZnJvbVJlZCgpO1xuICByZXR1cm4gWyBsMSwgbDIgXTtcbn07XG5cblNob3J0Q3VydmUucHJvdG90eXBlLl9nZXRFbmRvQmFzaXMgPSBmdW5jdGlvbiBfZ2V0RW5kb0Jhc2lzKGxhbWJkYSkge1xuICAvLyBhcHJ4U3FydCA+PSBzcXJ0KHRoaXMubilcbiAgdmFyIGFwcnhTcXJ0ID0gdGhpcy5uLnVzaHJuKE1hdGguZmxvb3IodGhpcy5uLmJpdExlbmd0aCgpIC8gMikpO1xuXG4gIC8vIDMuNzRcbiAgLy8gUnVuIEVHQ0QsIHVudGlsIHIoTCArIDEpIDwgYXByeFNxcnRcbiAgdmFyIHUgPSBsYW1iZGE7XG4gIHZhciB2ID0gdGhpcy5uLmNsb25lKCk7XG4gIHZhciB4MSA9IG5ldyBibigxKTtcbiAgdmFyIHkxID0gbmV3IGJuKDApO1xuICB2YXIgeDIgPSBuZXcgYm4oMCk7XG4gIHZhciB5MiA9IG5ldyBibigxKTtcblxuICAvLyBOT1RFOiBhbGwgdmVjdG9ycyBhcmUgcm9vdHMgb2Y6IGEgKyBiICogbGFtYmRhID0gMCAobW9kIG4pXG4gIHZhciBhMDtcbiAgdmFyIGIwO1xuICAvLyBGaXJzdCB2ZWN0b3JcbiAgdmFyIGExO1xuICB2YXIgYjE7XG4gIC8vIFNlY29uZCB2ZWN0b3JcbiAgdmFyIGEyO1xuICB2YXIgYjI7XG5cbiAgdmFyIHByZXZSO1xuICB2YXIgaSA9IDA7XG4gIHZhciByO1xuICB2YXIgeDtcbiAgd2hpbGUgKHUuY21wbigwKSAhPT0gMCkge1xuICAgIHZhciBxID0gdi5kaXYodSk7XG4gICAgciA9IHYuc3ViKHEubXVsKHUpKTtcbiAgICB4ID0geDIuc3ViKHEubXVsKHgxKSk7XG4gICAgdmFyIHkgPSB5Mi5zdWIocS5tdWwoeTEpKTtcblxuICAgIGlmICghYTEgJiYgci5jbXAoYXByeFNxcnQpIDwgMCkge1xuICAgICAgYTAgPSBwcmV2Ui5uZWcoKTtcbiAgICAgIGIwID0geDE7XG4gICAgICBhMSA9IHIubmVnKCk7XG4gICAgICBiMSA9IHg7XG4gICAgfSBlbHNlIGlmIChhMSAmJiArK2kgPT09IDIpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBwcmV2UiA9IHI7XG5cbiAgICB2ID0gdTtcbiAgICB1ID0gcjtcbiAgICB4MiA9IHgxO1xuICAgIHgxID0geDtcbiAgICB5MiA9IHkxO1xuICAgIHkxID0geTtcbiAgfVxuICBhMiA9IHIubmVnKCk7XG4gIGIyID0geDtcblxuICB2YXIgbGVuMSA9IGExLnNxcigpLmFkZChiMS5zcXIoKSk7XG4gIHZhciBsZW4yID0gYTIuc3FyKCkuYWRkKGIyLnNxcigpKTtcbiAgaWYgKGxlbjIuY21wKGxlbjEpID49IDApIHtcbiAgICBhMiA9IGEwO1xuICAgIGIyID0gYjA7XG4gIH1cblxuICAvLyBOb3JtYWxpemUgc2lnbnNcbiAgaWYgKGExLm5lZ2F0aXZlKSB7XG4gICAgYTEgPSBhMS5uZWcoKTtcbiAgICBiMSA9IGIxLm5lZygpO1xuICB9XG4gIGlmIChhMi5uZWdhdGl2ZSkge1xuICAgIGEyID0gYTIubmVnKCk7XG4gICAgYjIgPSBiMi5uZWcoKTtcbiAgfVxuXG4gIHJldHVybiBbXG4gICAgeyBhOiBhMSwgYjogYjEgfSxcbiAgICB7IGE6IGEyLCBiOiBiMiB9XG4gIF07XG59O1xuXG5TaG9ydEN1cnZlLnByb3RvdHlwZS5fZW5kb1NwbGl0ID0gZnVuY3Rpb24gX2VuZG9TcGxpdChrKSB7XG4gIHZhciBiYXNpcyA9IHRoaXMuZW5kby5iYXNpcztcbiAgdmFyIHYxID0gYmFzaXNbMF07XG4gIHZhciB2MiA9IGJhc2lzWzFdO1xuXG4gIHZhciBjMSA9IHYyLmIubXVsKGspLmRpdlJvdW5kKHRoaXMubik7XG4gIHZhciBjMiA9IHYxLmIubmVnKCkubXVsKGspLmRpdlJvdW5kKHRoaXMubik7XG5cbiAgdmFyIHAxID0gYzEubXVsKHYxLmEpO1xuICB2YXIgcDIgPSBjMi5tdWwodjIuYSk7XG4gIHZhciBxMSA9IGMxLm11bCh2MS5iKTtcbiAgdmFyIHEyID0gYzIubXVsKHYyLmIpO1xuXG4gIC8vIENhbGN1bGF0ZSBhbnN3ZXJcbiAgdmFyIGsxID0gay5zdWIocDEpLnN1YihwMik7XG4gIHZhciBrMiA9IHExLmFkZChxMikubmVnKCk7XG4gIHJldHVybiB7IGsxOiBrMSwgazI6IGsyIH07XG59O1xuXG5TaG9ydEN1cnZlLnByb3RvdHlwZS5wb2ludEZyb21YID0gZnVuY3Rpb24gcG9pbnRGcm9tWCh4LCBvZGQpIHtcbiAgeCA9IG5ldyBibih4LCAxNik7XG4gIGlmICgheC5yZWQpXG4gICAgeCA9IHgudG9SZWQodGhpcy5yZWQpO1xuXG4gIHZhciB5MiA9IHgucmVkU3FyKCkucmVkTXVsKHgpLnJlZElBZGQoeC5yZWRNdWwodGhpcy5hKSkucmVkSUFkZCh0aGlzLmIpO1xuICB2YXIgeSA9IHkyLnJlZFNxcnQoKTtcblxuICAvLyBYWFggSXMgdGhlcmUgYW55IHdheSB0byB0ZWxsIGlmIHRoZSBudW1iZXIgaXMgb2RkIHdpdGhvdXQgY29udmVydGluZyBpdFxuICAvLyB0byBub24tcmVkIGZvcm0/XG4gIHZhciBpc09kZCA9IHkuZnJvbVJlZCgpLmlzT2RkKCk7XG4gIGlmIChvZGQgJiYgIWlzT2RkIHx8ICFvZGQgJiYgaXNPZGQpXG4gICAgeSA9IHkucmVkTmVnKCk7XG5cbiAgcmV0dXJuIHRoaXMucG9pbnQoeCwgeSk7XG59O1xuXG5TaG9ydEN1cnZlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uIHZhbGlkYXRlKHBvaW50KSB7XG4gIGlmIChwb2ludC5pbmYpXG4gICAgcmV0dXJuIHRydWU7XG5cbiAgdmFyIHggPSBwb2ludC54O1xuICB2YXIgeSA9IHBvaW50Lnk7XG5cbiAgdmFyIGF4ID0gdGhpcy5hLnJlZE11bCh4KTtcbiAgdmFyIHJocyA9IHgucmVkU3FyKCkucmVkTXVsKHgpLnJlZElBZGQoYXgpLnJlZElBZGQodGhpcy5iKTtcbiAgcmV0dXJuIHkucmVkU3FyKCkucmVkSVN1YihyaHMpLmNtcG4oMCkgPT09IDA7XG59O1xuXG5TaG9ydEN1cnZlLnByb3RvdHlwZS5fZW5kb1duYWZNdWxBZGQgPVxuICAgIGZ1bmN0aW9uIF9lbmRvV25hZk11bEFkZChwb2ludHMsIGNvZWZmcykge1xuICB2YXIgbnBvaW50cyA9IHRoaXMuX2VuZG9XbmFmVDE7XG4gIHZhciBuY29lZmZzID0gdGhpcy5fZW5kb1duYWZUMjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc3BsaXQgPSB0aGlzLl9lbmRvU3BsaXQoY29lZmZzW2ldKTtcbiAgICB2YXIgcCA9IHBvaW50c1tpXTtcbiAgICB2YXIgYmV0YSA9IHAuX2dldEJldGEoKTtcblxuICAgIGlmIChzcGxpdC5rMS5uZWdhdGl2ZSkge1xuICAgICAgc3BsaXQuazEuaW5lZygpO1xuICAgICAgcCA9IHAubmVnKHRydWUpO1xuICAgIH1cbiAgICBpZiAoc3BsaXQuazIubmVnYXRpdmUpIHtcbiAgICAgIHNwbGl0LmsyLmluZWcoKTtcbiAgICAgIGJldGEgPSBiZXRhLm5lZyh0cnVlKTtcbiAgICB9XG5cbiAgICBucG9pbnRzW2kgKiAyXSA9IHA7XG4gICAgbnBvaW50c1tpICogMiArIDFdID0gYmV0YTtcbiAgICBuY29lZmZzW2kgKiAyXSA9IHNwbGl0LmsxO1xuICAgIG5jb2VmZnNbaSAqIDIgKyAxXSA9IHNwbGl0LmsyO1xuICB9XG4gIHZhciByZXMgPSB0aGlzLl93bmFmTXVsQWRkKDEsIG5wb2ludHMsIG5jb2VmZnMsIGkgKiAyKTtcblxuICAvLyBDbGVhbi11cCByZWZlcmVuY2VzIHRvIHBvaW50cyBhbmQgY29lZmZpY2llbnRzXG4gIGZvciAodmFyIGogPSAwOyBqIDwgaSAqIDI7IGorKykge1xuICAgIG5wb2ludHNbal0gPSBudWxsO1xuICAgIG5jb2VmZnNbal0gPSBudWxsO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuXG5mdW5jdGlvbiBQb2ludChjdXJ2ZSwgeCwgeSwgaXNSZWQpIHtcbiAgQmFzZS5CYXNlUG9pbnQuY2FsbCh0aGlzLCBjdXJ2ZSwgJ2FmZmluZScpO1xuICBpZiAoeCA9PT0gbnVsbCAmJiB5ID09PSBudWxsKSB7XG4gICAgdGhpcy54ID0gbnVsbDtcbiAgICB0aGlzLnkgPSBudWxsO1xuICAgIHRoaXMuaW5mID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnggPSBuZXcgYm4oeCwgMTYpO1xuICAgIHRoaXMueSA9IG5ldyBibih5LCAxNik7XG4gICAgLy8gRm9yY2UgcmVkZ29tZXJ5IHJlcHJlc2VudGF0aW9uIHdoZW4gbG9hZGluZyBmcm9tIEpTT05cbiAgICBpZiAoaXNSZWQpIHtcbiAgICAgIHRoaXMueC5mb3JjZVJlZCh0aGlzLmN1cnZlLnJlZCk7XG4gICAgICB0aGlzLnkuZm9yY2VSZWQodGhpcy5jdXJ2ZS5yZWQpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMueC5yZWQpXG4gICAgICB0aGlzLnggPSB0aGlzLngudG9SZWQodGhpcy5jdXJ2ZS5yZWQpO1xuICAgIGlmICghdGhpcy55LnJlZClcbiAgICAgIHRoaXMueSA9IHRoaXMueS50b1JlZCh0aGlzLmN1cnZlLnJlZCk7XG4gICAgdGhpcy5pbmYgPSBmYWxzZTtcbiAgfVxufVxuaW5oZXJpdHMoUG9pbnQsIEJhc2UuQmFzZVBvaW50KTtcblxuU2hvcnRDdXJ2ZS5wcm90b3R5cGUucG9pbnQgPSBmdW5jdGlvbiBwb2ludCh4LCB5LCBpc1JlZCkge1xuICByZXR1cm4gbmV3IFBvaW50KHRoaXMsIHgsIHksIGlzUmVkKTtcbn07XG5cblNob3J0Q3VydmUucHJvdG90eXBlLnBvaW50RnJvbUpTT04gPSBmdW5jdGlvbiBwb2ludEZyb21KU09OKG9iaiwgcmVkKSB7XG4gIHJldHVybiBQb2ludC5mcm9tSlNPTih0aGlzLCBvYmosIHJlZCk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuX2dldEJldGEgPSBmdW5jdGlvbiBfZ2V0QmV0YSgpIHtcbiAgaWYgKCF0aGlzLmN1cnZlLmVuZG8pXG4gICAgcmV0dXJuO1xuXG4gIHZhciBwcmUgPSB0aGlzLnByZWNvbXB1dGVkO1xuICBpZiAocHJlICYmIHByZS5iZXRhKVxuICAgIHJldHVybiBwcmUuYmV0YTtcblxuICB2YXIgYmV0YSA9IHRoaXMuY3VydmUucG9pbnQodGhpcy54LnJlZE11bCh0aGlzLmN1cnZlLmVuZG8uYmV0YSksIHRoaXMueSk7XG4gIGlmIChwcmUpIHtcbiAgICB2YXIgY3VydmUgPSB0aGlzLmN1cnZlO1xuICAgIHZhciBlbmRvTXVsID0gZnVuY3Rpb24ocCkge1xuICAgICAgcmV0dXJuIGN1cnZlLnBvaW50KHAueC5yZWRNdWwoY3VydmUuZW5kby5iZXRhKSwgcC55KTtcbiAgICB9O1xuICAgIHByZS5iZXRhID0gYmV0YTtcbiAgICBiZXRhLnByZWNvbXB1dGVkID0ge1xuICAgICAgYmV0YTogbnVsbCxcbiAgICAgIG5hZjogcHJlLm5hZiAmJiB7XG4gICAgICAgIHduZDogcHJlLm5hZi53bmQsXG4gICAgICAgIHBvaW50czogcHJlLm5hZi5wb2ludHMubWFwKGVuZG9NdWwpXG4gICAgICB9LFxuICAgICAgZG91YmxlczogcHJlLmRvdWJsZXMgJiYge1xuICAgICAgICBzdGVwOiBwcmUuZG91Ymxlcy5zdGVwLFxuICAgICAgICBwb2ludHM6IHByZS5kb3VibGVzLnBvaW50cy5tYXAoZW5kb011bClcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHJldHVybiBiZXRhO1xufTtcblxuUG9pbnQucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgaWYgKCF0aGlzLnByZWNvbXB1dGVkKVxuICAgIHJldHVybiBbIHRoaXMueCwgdGhpcy55IF07XG5cbiAgcmV0dXJuIFsgdGhpcy54LCB0aGlzLnksIHRoaXMucHJlY29tcHV0ZWQgJiYge1xuICAgIGRvdWJsZXM6IHRoaXMucHJlY29tcHV0ZWQuZG91YmxlcyAmJiB7XG4gICAgICBzdGVwOiB0aGlzLnByZWNvbXB1dGVkLmRvdWJsZXMuc3RlcCxcbiAgICAgIHBvaW50czogdGhpcy5wcmVjb21wdXRlZC5kb3VibGVzLnBvaW50cy5zbGljZSgxKVxuICAgIH0sXG4gICAgbmFmOiB0aGlzLnByZWNvbXB1dGVkLm5hZiAmJiB7XG4gICAgICB3bmQ6IHRoaXMucHJlY29tcHV0ZWQubmFmLnduZCxcbiAgICAgIHBvaW50czogdGhpcy5wcmVjb21wdXRlZC5uYWYucG9pbnRzLnNsaWNlKDEpXG4gICAgfVxuICB9IF07XG59O1xuXG5Qb2ludC5mcm9tSlNPTiA9IGZ1bmN0aW9uIGZyb21KU09OKGN1cnZlLCBvYmosIHJlZCkge1xuICBpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpXG4gICAgb2JqID0gSlNPTi5wYXJzZShvYmopO1xuICB2YXIgcmVzID0gY3VydmUucG9pbnQob2JqWzBdLCBvYmpbMV0sIHJlZCk7XG4gIGlmICghb2JqWzJdKVxuICAgIHJldHVybiByZXM7XG5cbiAgZnVuY3Rpb24gb2JqMnBvaW50KG9iaikge1xuICAgIHJldHVybiBjdXJ2ZS5wb2ludChvYmpbMF0sIG9ialsxXSwgcmVkKTtcbiAgfVxuXG4gIHZhciBwcmUgPSBvYmpbMl07XG4gIHJlcy5wcmVjb21wdXRlZCA9IHtcbiAgICBiZXRhOiBudWxsLFxuICAgIGRvdWJsZXM6IHByZS5kb3VibGVzICYmIHtcbiAgICAgIHN0ZXA6IHByZS5kb3VibGVzLnN0ZXAsXG4gICAgICBwb2ludHM6IFsgcmVzIF0uY29uY2F0KHByZS5kb3VibGVzLnBvaW50cy5tYXAob2JqMnBvaW50KSlcbiAgICB9LFxuICAgIG5hZjogcHJlLm5hZiAmJiB7XG4gICAgICB3bmQ6IHByZS5uYWYud25kLFxuICAgICAgcG9pbnRzOiBbIHJlcyBdLmNvbmNhdChwcmUubmFmLnBvaW50cy5tYXAob2JqMnBvaW50KSlcbiAgICB9XG4gIH07XG4gIHJldHVybiByZXM7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QoKSB7XG4gIGlmICh0aGlzLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gJzxFQyBQb2ludCBJbmZpbml0eT4nO1xuICByZXR1cm4gJzxFQyBQb2ludCB4OiAnICsgdGhpcy54LmZyb21SZWQoKS50b1N0cmluZygxNiwgMikgK1xuICAgICAgJyB5OiAnICsgdGhpcy55LmZyb21SZWQoKS50b1N0cmluZygxNiwgMikgKyAnPic7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuaXNJbmZpbml0eSA9IGZ1bmN0aW9uIGlzSW5maW5pdHkoKSB7XG4gIHJldHVybiB0aGlzLmluZjtcbn07XG5cblBvaW50LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQocCkge1xuICAvLyBPICsgUCA9IFBcbiAgaWYgKHRoaXMuaW5mKVxuICAgIHJldHVybiBwO1xuXG4gIC8vIFAgKyBPID0gUFxuICBpZiAocC5pbmYpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gUCArIFAgPSAyUFxuICBpZiAodGhpcy5lcShwKSlcbiAgICByZXR1cm4gdGhpcy5kYmwoKTtcblxuICAvLyBQICsgKC1QKSA9IE9cbiAgaWYgKHRoaXMubmVnKCkuZXEocCkpXG4gICAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobnVsbCwgbnVsbCk7XG5cbiAgLy8gUCArIFEgPSBPXG4gIGlmICh0aGlzLnguY21wKHAueCkgPT09IDApXG4gICAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobnVsbCwgbnVsbCk7XG5cbiAgdmFyIGMgPSB0aGlzLnkucmVkU3ViKHAueSk7XG4gIGlmIChjLmNtcG4oMCkgIT09IDApXG4gICAgYyA9IGMucmVkTXVsKHRoaXMueC5yZWRTdWIocC54KS5yZWRJbnZtKCkpO1xuICB2YXIgbnggPSBjLnJlZFNxcigpLnJlZElTdWIodGhpcy54KS5yZWRJU3ViKHAueCk7XG4gIHZhciBueSA9IGMucmVkTXVsKHRoaXMueC5yZWRTdWIobngpKS5yZWRJU3ViKHRoaXMueSk7XG4gIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG54LCBueSk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZGJsID0gZnVuY3Rpb24gZGJsKCkge1xuICBpZiAodGhpcy5pbmYpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gMlAgPSBPXG4gIHZhciB5czEgPSB0aGlzLnkucmVkQWRkKHRoaXMueSk7XG4gIGlmICh5czEuY21wbigwKSA9PT0gMClcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChudWxsLCBudWxsKTtcblxuICB2YXIgYSA9IHRoaXMuY3VydmUuYTtcblxuICB2YXIgeDIgPSB0aGlzLngucmVkU3FyKCk7XG4gIHZhciBkeWludiA9IHlzMS5yZWRJbnZtKCk7XG4gIHZhciBjID0geDIucmVkQWRkKHgyKS5yZWRJQWRkKHgyKS5yZWRJQWRkKGEpLnJlZE11bChkeWludik7XG5cbiAgdmFyIG54ID0gYy5yZWRTcXIoKS5yZWRJU3ViKHRoaXMueC5yZWRBZGQodGhpcy54KSk7XG4gIHZhciBueSA9IGMucmVkTXVsKHRoaXMueC5yZWRTdWIobngpKS5yZWRJU3ViKHRoaXMueSk7XG4gIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG54LCBueSk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZ2V0WCA9IGZ1bmN0aW9uIGdldFgoKSB7XG4gIHJldHVybiB0aGlzLnguZnJvbVJlZCgpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmdldFkgPSBmdW5jdGlvbiBnZXRZKCkge1xuICByZXR1cm4gdGhpcy55LmZyb21SZWQoKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiBtdWwoaykge1xuICBrID0gbmV3IGJuKGssIDE2KTtcblxuICBpZiAodGhpcy5faGFzRG91YmxlcyhrKSlcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5fZml4ZWROYWZNdWwodGhpcywgayk7XG4gIGVsc2UgaWYgKHRoaXMuY3VydmUuZW5kbylcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5fZW5kb1duYWZNdWxBZGQoWyB0aGlzIF0sIFsgayBdKTtcbiAgZWxzZVxuICAgIHJldHVybiB0aGlzLmN1cnZlLl93bmFmTXVsKHRoaXMsIGspO1xufTtcblxuUG9pbnQucHJvdG90eXBlLm11bEFkZCA9IGZ1bmN0aW9uIG11bEFkZChrMSwgcDIsIGsyKSB7XG4gIHZhciBwb2ludHMgPSBbIHRoaXMsIHAyIF07XG4gIHZhciBjb2VmZnMgPSBbIGsxLCBrMiBdO1xuICBpZiAodGhpcy5jdXJ2ZS5lbmRvKVxuICAgIHJldHVybiB0aGlzLmN1cnZlLl9lbmRvV25hZk11bEFkZChwb2ludHMsIGNvZWZmcyk7XG4gIGVsc2VcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5fd25hZk11bEFkZCgxLCBwb2ludHMsIGNvZWZmcywgMik7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZXEgPSBmdW5jdGlvbiBlcShwKSB7XG4gIHJldHVybiB0aGlzID09PSBwIHx8XG4gICAgICAgICB0aGlzLmluZiA9PT0gcC5pbmYgJiZcbiAgICAgICAgICAgICAodGhpcy5pbmYgfHwgdGhpcy54LmNtcChwLngpID09PSAwICYmIHRoaXMueS5jbXAocC55KSA9PT0gMCk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUubmVnID0gZnVuY3Rpb24gbmVnKF9wcmVjb21wdXRlKSB7XG4gIGlmICh0aGlzLmluZilcbiAgICByZXR1cm4gdGhpcztcblxuICB2YXIgcmVzID0gdGhpcy5jdXJ2ZS5wb2ludCh0aGlzLngsIHRoaXMueS5yZWROZWcoKSk7XG4gIGlmIChfcHJlY29tcHV0ZSAmJiB0aGlzLnByZWNvbXB1dGVkKSB7XG4gICAgdmFyIHByZSA9IHRoaXMucHJlY29tcHV0ZWQ7XG4gICAgdmFyIG5lZ2F0ZSA9IGZ1bmN0aW9uKHApIHtcbiAgICAgIHJldHVybiBwLm5lZygpO1xuICAgIH07XG4gICAgcmVzLnByZWNvbXB1dGVkID0ge1xuICAgICAgbmFmOiBwcmUubmFmICYmIHtcbiAgICAgICAgd25kOiBwcmUubmFmLnduZCxcbiAgICAgICAgcG9pbnRzOiBwcmUubmFmLnBvaW50cy5tYXAobmVnYXRlKVxuICAgICAgfSxcbiAgICAgIGRvdWJsZXM6IHByZS5kb3VibGVzICYmIHtcbiAgICAgICAgc3RlcDogcHJlLmRvdWJsZXMuc3RlcCxcbiAgICAgICAgcG9pbnRzOiBwcmUuZG91Ymxlcy5wb2ludHMubWFwKG5lZ2F0ZSlcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUudG9KID0gZnVuY3Rpb24gdG9KKCkge1xuICBpZiAodGhpcy5pbmYpXG4gICAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG51bGwsIG51bGwsIG51bGwpO1xuXG4gIHZhciByZXMgPSB0aGlzLmN1cnZlLmpwb2ludCh0aGlzLngsIHRoaXMueSwgdGhpcy5jdXJ2ZS5vbmUpO1xuICByZXR1cm4gcmVzO1xufTtcblxuZnVuY3Rpb24gSlBvaW50KGN1cnZlLCB4LCB5LCB6KSB7XG4gIEJhc2UuQmFzZVBvaW50LmNhbGwodGhpcywgY3VydmUsICdqYWNvYmlhbicpO1xuICBpZiAoeCA9PT0gbnVsbCAmJiB5ID09PSBudWxsICYmIHogPT09IG51bGwpIHtcbiAgICB0aGlzLnggPSB0aGlzLmN1cnZlLm9uZTtcbiAgICB0aGlzLnkgPSB0aGlzLmN1cnZlLm9uZTtcbiAgICB0aGlzLnogPSBuZXcgYm4oMCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy54ID0gbmV3IGJuKHgsIDE2KTtcbiAgICB0aGlzLnkgPSBuZXcgYm4oeSwgMTYpO1xuICAgIHRoaXMueiA9IG5ldyBibih6LCAxNik7XG4gIH1cbiAgaWYgKCF0aGlzLngucmVkKVxuICAgIHRoaXMueCA9IHRoaXMueC50b1JlZCh0aGlzLmN1cnZlLnJlZCk7XG4gIGlmICghdGhpcy55LnJlZClcbiAgICB0aGlzLnkgPSB0aGlzLnkudG9SZWQodGhpcy5jdXJ2ZS5yZWQpO1xuICBpZiAoIXRoaXMuei5yZWQpXG4gICAgdGhpcy56ID0gdGhpcy56LnRvUmVkKHRoaXMuY3VydmUucmVkKTtcblxuICB0aGlzLnpPbmUgPSB0aGlzLnogPT09IHRoaXMuY3VydmUub25lO1xufVxuaW5oZXJpdHMoSlBvaW50LCBCYXNlLkJhc2VQb2ludCk7XG5cblNob3J0Q3VydmUucHJvdG90eXBlLmpwb2ludCA9IGZ1bmN0aW9uIGpwb2ludCh4LCB5LCB6KSB7XG4gIHJldHVybiBuZXcgSlBvaW50KHRoaXMsIHgsIHksIHopO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS50b1AgPSBmdW5jdGlvbiB0b1AoKSB7XG4gIGlmICh0aGlzLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChudWxsLCBudWxsKTtcblxuICB2YXIgemludiA9IHRoaXMuei5yZWRJbnZtKCk7XG4gIHZhciB6aW52MiA9IHppbnYucmVkU3FyKCk7XG4gIHZhciBheCA9IHRoaXMueC5yZWRNdWwoemludjIpO1xuICB2YXIgYXkgPSB0aGlzLnkucmVkTXVsKHppbnYyKS5yZWRNdWwoemludik7XG5cbiAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQoYXgsIGF5KTtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUubmVnID0gZnVuY3Rpb24gbmVnKCkge1xuICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQodGhpcy54LCB0aGlzLnkucmVkTmVnKCksIHRoaXMueik7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZChwKSB7XG4gIC8vIE8gKyBQID0gUFxuICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHA7XG5cbiAgLy8gUCArIE8gPSBQXG4gIGlmIChwLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyAxMk0gKyA0UyArIDdBXG4gIHZhciBwejIgPSBwLnoucmVkU3FyKCk7XG4gIHZhciB6MiA9IHRoaXMuei5yZWRTcXIoKTtcbiAgdmFyIHUxID0gdGhpcy54LnJlZE11bChwejIpO1xuICB2YXIgdTIgPSBwLngucmVkTXVsKHoyKTtcbiAgdmFyIHMxID0gdGhpcy55LnJlZE11bChwejIucmVkTXVsKHAueikpO1xuICB2YXIgczIgPSBwLnkucmVkTXVsKHoyLnJlZE11bCh0aGlzLnopKTtcblxuICB2YXIgaCA9IHUxLnJlZFN1Yih1Mik7XG4gIHZhciByID0gczEucmVkU3ViKHMyKTtcbiAgaWYgKGguY21wbigwKSA9PT0gMCkge1xuICAgIGlmIChyLmNtcG4oMCkgIT09IDApXG4gICAgICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobnVsbCwgbnVsbCwgbnVsbCk7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIHRoaXMuZGJsKCk7XG4gIH1cblxuICB2YXIgaDIgPSBoLnJlZFNxcigpO1xuICB2YXIgaDMgPSBoMi5yZWRNdWwoaCk7XG4gIHZhciB2ID0gdTEucmVkTXVsKGgyKTtcblxuICB2YXIgbnggPSByLnJlZFNxcigpLnJlZElBZGQoaDMpLnJlZElTdWIodikucmVkSVN1Yih2KTtcbiAgdmFyIG55ID0gci5yZWRNdWwodi5yZWRJU3ViKG54KSkucmVkSVN1YihzMS5yZWRNdWwoaDMpKTtcbiAgdmFyIG56ID0gdGhpcy56LnJlZE11bChwLnopLnJlZE11bChoKTtcblxuICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobngsIG55LCBueik7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLm1peGVkQWRkID0gZnVuY3Rpb24gbWl4ZWRBZGQocCkge1xuICAvLyBPICsgUCA9IFBcbiAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiBwLnRvSigpO1xuXG4gIC8vIFAgKyBPID0gUFxuICBpZiAocC5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gOE0gKyAzUyArIDdBXG4gIHZhciB6MiA9IHRoaXMuei5yZWRTcXIoKTtcbiAgdmFyIHUxID0gdGhpcy54O1xuICB2YXIgdTIgPSBwLngucmVkTXVsKHoyKTtcbiAgdmFyIHMxID0gdGhpcy55O1xuICB2YXIgczIgPSBwLnkucmVkTXVsKHoyKS5yZWRNdWwodGhpcy56KTtcblxuICB2YXIgaCA9IHUxLnJlZFN1Yih1Mik7XG4gIHZhciByID0gczEucmVkU3ViKHMyKTtcbiAgaWYgKGguY21wbigwKSA9PT0gMCkge1xuICAgIGlmIChyLmNtcG4oMCkgIT09IDApXG4gICAgICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobnVsbCwgbnVsbCwgbnVsbCk7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIHRoaXMuZGJsKCk7XG4gIH1cblxuICB2YXIgaDIgPSBoLnJlZFNxcigpO1xuICB2YXIgaDMgPSBoMi5yZWRNdWwoaCk7XG4gIHZhciB2ID0gdTEucmVkTXVsKGgyKTtcblxuICB2YXIgbnggPSByLnJlZFNxcigpLnJlZElBZGQoaDMpLnJlZElTdWIodikucmVkSVN1Yih2KTtcbiAgdmFyIG55ID0gci5yZWRNdWwodi5yZWRJU3ViKG54KSkucmVkSVN1YihzMS5yZWRNdWwoaDMpKTtcbiAgdmFyIG56ID0gdGhpcy56LnJlZE11bChoKTtcblxuICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobngsIG55LCBueik7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLmRibHAgPSBmdW5jdGlvbiBkYmxwKHBvdykge1xuICBpZiAocG93ID09PSAwKVxuICAgIHJldHVybiB0aGlzO1xuICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHRoaXM7XG4gIGlmICghcG93KVxuICAgIHJldHVybiB0aGlzLmRibCgpO1xuXG4gIGlmICh0aGlzLmN1cnZlLnplcm9BIHx8IHRoaXMuY3VydmUudGhyZWVBKSB7XG4gICAgdmFyIHIgPSB0aGlzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG93OyBpKyspXG4gICAgICByID0gci5kYmwoKTtcbiAgICByZXR1cm4gcjtcbiAgfVxuXG4gIC8vIDFNICsgMlMgKyAxQSArIE4gKiAoNFMgKyA1TSArIDhBKVxuICAvLyBOID0gMSA9PiA2TSArIDZTICsgOUFcbiAgdmFyIGEgPSB0aGlzLmN1cnZlLmE7XG4gIHZhciB0aW52ID0gdGhpcy5jdXJ2ZS50aW52O1xuXG4gIHZhciBqeCA9IHRoaXMueDtcbiAgdmFyIGp5ID0gdGhpcy55O1xuICB2YXIganogPSB0aGlzLno7XG4gIHZhciBqejQgPSBqei5yZWRTcXIoKS5yZWRTcXIoKTtcblxuICAvLyBSZXVzZSByZXN1bHRzXG4gIHZhciBqeWQgPSBqeS5yZWRBZGQoankpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBvdzsgaSsrKSB7XG4gICAgdmFyIGp4MiA9IGp4LnJlZFNxcigpO1xuICAgIHZhciBqeWQyID0ganlkLnJlZFNxcigpO1xuICAgIHZhciBqeWQ0ID0ganlkMi5yZWRTcXIoKTtcbiAgICB2YXIgYyA9IGp4Mi5yZWRBZGQoangyKS5yZWRJQWRkKGp4MikucmVkSUFkZChhLnJlZE11bChqejQpKTtcblxuICAgIHZhciB0MSA9IGp4LnJlZE11bChqeWQyKTtcbiAgICB2YXIgbnggPSBjLnJlZFNxcigpLnJlZElTdWIodDEucmVkQWRkKHQxKSk7XG4gICAgdmFyIHQyID0gdDEucmVkSVN1YihueCk7XG4gICAgdmFyIGRueSA9IGMucmVkTXVsKHQyKTtcbiAgICBkbnkgPSBkbnkucmVkSUFkZChkbnkpLnJlZElTdWIoanlkNCk7XG4gICAgdmFyIG56ID0ganlkLnJlZE11bChqeik7XG4gICAgaWYgKGkgKyAxIDwgcG93KVxuICAgICAgano0ID0gano0LnJlZE11bChqeWQ0KTtcblxuICAgIGp4ID0gbng7XG4gICAganogPSBuejtcbiAgICBqeWQgPSBkbnk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQoangsIGp5ZC5yZWRNdWwodGludiksIGp6KTtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUuZGJsID0gZnVuY3Rpb24gZGJsKCkge1xuICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgaWYgKHRoaXMuY3VydmUuemVyb0EpXG4gICAgcmV0dXJuIHRoaXMuX3plcm9EYmwoKTtcbiAgZWxzZSBpZiAodGhpcy5jdXJ2ZS50aHJlZUEpXG4gICAgcmV0dXJuIHRoaXMuX3RocmVlRGJsKCk7XG4gIGVsc2VcbiAgICByZXR1cm4gdGhpcy5fZGJsKCk7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLl96ZXJvRGJsID0gZnVuY3Rpb24gX3plcm9EYmwoKSB7XG4gIHZhciBueDtcbiAgdmFyIG55O1xuICB2YXIgbno7XG4gIC8vIFogPSAxXG4gIGlmICh0aGlzLnpPbmUpIHtcbiAgICAvLyBoeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tc2hvcnR3LWphY29iaWFuLTAuaHRtbFxuICAgIC8vICAgICAjZG91YmxpbmctbWRibC0yMDA3LWJsXG4gICAgLy8gMU0gKyA1UyArIDE0QVxuXG4gICAgLy8gWFggPSBYMV4yXG4gICAgdmFyIHh4ID0gdGhpcy54LnJlZFNxcigpO1xuICAgIC8vIFlZID0gWTFeMlxuICAgIHZhciB5eSA9IHRoaXMueS5yZWRTcXIoKTtcbiAgICAvLyBZWVlZID0gWVleMlxuICAgIHZhciB5eXl5ID0geXkucmVkU3FyKCk7XG4gICAgLy8gUyA9IDIgKiAoKFgxICsgWVkpXjIgLSBYWCAtIFlZWVkpXG4gICAgdmFyIHMgPSB0aGlzLngucmVkQWRkKHl5KS5yZWRTcXIoKS5yZWRJU3ViKHh4KS5yZWRJU3ViKHl5eXkpO1xuICAgIHMgPSBzLnJlZElBZGQocyk7XG4gICAgLy8gTSA9IDMgKiBYWCArIGE7IGEgPSAwXG4gICAgdmFyIG0gPSB4eC5yZWRBZGQoeHgpLnJlZElBZGQoeHgpO1xuICAgIC8vIFQgPSBNIF4gMiAtIDIqU1xuICAgIHZhciB0ID0gbS5yZWRTcXIoKS5yZWRJU3ViKHMpLnJlZElTdWIocyk7XG5cbiAgICAvLyA4ICogWVlZWVxuICAgIHZhciB5eXl5OCA9IHl5eXkucmVkSUFkZCh5eXl5KTtcbiAgICB5eXl5OCA9IHl5eXk4LnJlZElBZGQoeXl5eTgpO1xuICAgIHl5eXk4ID0geXl5eTgucmVkSUFkZCh5eXl5OCk7XG5cbiAgICAvLyBYMyA9IFRcbiAgICBueCA9IHQ7XG4gICAgLy8gWTMgPSBNICogKFMgLSBUKSAtIDggKiBZWVlZXG4gICAgbnkgPSBtLnJlZE11bChzLnJlZElTdWIodCkpLnJlZElTdWIoeXl5eTgpO1xuICAgIC8vIFozID0gMipZMVxuICAgIG56ID0gdGhpcy55LnJlZEFkZCh0aGlzLnkpO1xuICB9IGVsc2Uge1xuICAgIC8vIGh5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by1zaG9ydHctamFjb2JpYW4tMC5odG1sXG4gICAgLy8gICAgICNkb3VibGluZy1kYmwtMjAwOS1sXG4gICAgLy8gMk0gKyA1UyArIDEzQVxuXG4gICAgLy8gQSA9IFgxXjJcbiAgICB2YXIgYSA9IHRoaXMueC5yZWRTcXIoKTtcbiAgICAvLyBCID0gWTFeMlxuICAgIHZhciBiID0gdGhpcy55LnJlZFNxcigpO1xuICAgIC8vIEMgPSBCXjJcbiAgICB2YXIgYyA9IGIucmVkU3FyKCk7XG4gICAgLy8gRCA9IDIgKiAoKFgxICsgQileMiAtIEEgLSBDKVxuICAgIHZhciBkID0gdGhpcy54LnJlZEFkZChiKS5yZWRTcXIoKS5yZWRJU3ViKGEpLnJlZElTdWIoYyk7XG4gICAgZCA9IGQucmVkSUFkZChkKTtcbiAgICAvLyBFID0gMyAqIEFcbiAgICB2YXIgZSA9IGEucmVkQWRkKGEpLnJlZElBZGQoYSk7XG4gICAgLy8gRiA9IEVeMlxuICAgIHZhciBmID0gZS5yZWRTcXIoKTtcblxuICAgIC8vIDggKiBDXG4gICAgdmFyIGM4ID0gYy5yZWRJQWRkKGMpO1xuICAgIGM4ID0gYzgucmVkSUFkZChjOCk7XG4gICAgYzggPSBjOC5yZWRJQWRkKGM4KTtcblxuICAgIC8vIFgzID0gRiAtIDIgKiBEXG4gICAgbnggPSBmLnJlZElTdWIoZCkucmVkSVN1YihkKTtcbiAgICAvLyBZMyA9IEUgKiAoRCAtIFgzKSAtIDggKiBDXG4gICAgbnkgPSBlLnJlZE11bChkLnJlZElTdWIobngpKS5yZWRJU3ViKGM4KTtcbiAgICAvLyBaMyA9IDIgKiBZMSAqIFoxXG4gICAgbnogPSB0aGlzLnkucmVkTXVsKHRoaXMueik7XG4gICAgbnogPSBuei5yZWRJQWRkKG56KTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludChueCwgbnksIG56KTtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUuX3RocmVlRGJsID0gZnVuY3Rpb24gX3RocmVlRGJsKCkge1xuICB2YXIgbng7XG4gIHZhciBueTtcbiAgdmFyIG56O1xuICAvLyBaID0gMVxuICBpZiAodGhpcy56T25lKSB7XG4gICAgLy8gaHlwZXJlbGxpcHRpYy5vcmcvRUZEL2cxcC9hdXRvLXNob3J0dy1qYWNvYmlhbi0zLmh0bWxcbiAgICAvLyAgICAgI2RvdWJsaW5nLW1kYmwtMjAwNy1ibFxuICAgIC8vIDFNICsgNVMgKyAxNUFcblxuICAgIC8vIFhYID0gWDFeMlxuICAgIHZhciB4eCA9IHRoaXMueC5yZWRTcXIoKTtcbiAgICAvLyBZWSA9IFkxXjJcbiAgICB2YXIgeXkgPSB0aGlzLnkucmVkU3FyKCk7XG4gICAgLy8gWVlZWSA9IFlZXjJcbiAgICB2YXIgeXl5eSA9IHl5LnJlZFNxcigpO1xuICAgIC8vIFMgPSAyICogKChYMSArIFlZKV4yIC0gWFggLSBZWVlZKVxuICAgIHZhciBzID0gdGhpcy54LnJlZEFkZCh5eSkucmVkU3FyKCkucmVkSVN1Yih4eCkucmVkSVN1Yih5eXl5KTtcbiAgICBzID0gcy5yZWRJQWRkKHMpO1xuICAgIC8vIE0gPSAzICogWFggKyBhXG4gICAgdmFyIG0gPSB4eC5yZWRBZGQoeHgpLnJlZElBZGQoeHgpLnJlZElBZGQodGhpcy5jdXJ2ZS5hKTtcbiAgICAvLyBUID0gTV4yIC0gMiAqIFNcbiAgICB2YXIgdCA9IG0ucmVkU3FyKCkucmVkSVN1YihzKS5yZWRJU3ViKHMpO1xuICAgIC8vIFgzID0gVFxuICAgIG54ID0gdDtcbiAgICAvLyBZMyA9IE0gKiAoUyAtIFQpIC0gOCAqIFlZWVlcbiAgICB2YXIgeXl5eTggPSB5eXl5LnJlZElBZGQoeXl5eSk7XG4gICAgeXl5eTggPSB5eXl5OC5yZWRJQWRkKHl5eXk4KTtcbiAgICB5eXl5OCA9IHl5eXk4LnJlZElBZGQoeXl5eTgpO1xuICAgIG55ID0gbS5yZWRNdWwocy5yZWRJU3ViKHQpKS5yZWRJU3ViKHl5eXk4KTtcbiAgICAvLyBaMyA9IDIgKiBZMVxuICAgIG56ID0gdGhpcy55LnJlZEFkZCh0aGlzLnkpO1xuICB9IGVsc2Uge1xuICAgIC8vIGh5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by1zaG9ydHctamFjb2JpYW4tMy5odG1sI2RvdWJsaW5nLWRibC0yMDAxLWJcbiAgICAvLyAzTSArIDVTXG5cbiAgICAvLyBkZWx0YSA9IFoxXjJcbiAgICB2YXIgZGVsdGEgPSB0aGlzLnoucmVkU3FyKCk7XG4gICAgLy8gZ2FtbWEgPSBZMV4yXG4gICAgdmFyIGdhbW1hID0gdGhpcy55LnJlZFNxcigpO1xuICAgIC8vIGJldGEgPSBYMSAqIGdhbW1hXG4gICAgdmFyIGJldGEgPSB0aGlzLngucmVkTXVsKGdhbW1hKTtcbiAgICAvLyBhbHBoYSA9IDMgKiAoWDEgLSBkZWx0YSkgKiAoWDEgKyBkZWx0YSlcbiAgICB2YXIgYWxwaGEgPSB0aGlzLngucmVkU3ViKGRlbHRhKS5yZWRNdWwodGhpcy54LnJlZEFkZChkZWx0YSkpO1xuICAgIGFscGhhID0gYWxwaGEucmVkQWRkKGFscGhhKS5yZWRJQWRkKGFscGhhKTtcbiAgICAvLyBYMyA9IGFscGhhXjIgLSA4ICogYmV0YVxuICAgIHZhciBiZXRhNCA9IGJldGEucmVkSUFkZChiZXRhKTtcbiAgICBiZXRhNCA9IGJldGE0LnJlZElBZGQoYmV0YTQpO1xuICAgIHZhciBiZXRhOCA9IGJldGE0LnJlZEFkZChiZXRhNCk7XG4gICAgbnggPSBhbHBoYS5yZWRTcXIoKS5yZWRJU3ViKGJldGE4KTtcbiAgICAvLyBaMyA9IChZMSArIFoxKV4yIC0gZ2FtbWEgLSBkZWx0YVxuICAgIG56ID0gdGhpcy55LnJlZEFkZCh0aGlzLnopLnJlZFNxcigpLnJlZElTdWIoZ2FtbWEpLnJlZElTdWIoZGVsdGEpO1xuICAgIC8vIFkzID0gYWxwaGEgKiAoNCAqIGJldGEgLSBYMykgLSA4ICogZ2FtbWFeMlxuICAgIHZhciBnZ2FtbWE4ID0gZ2FtbWEucmVkU3FyKCk7XG4gICAgZ2dhbW1hOCA9IGdnYW1tYTgucmVkSUFkZChnZ2FtbWE4KTtcbiAgICBnZ2FtbWE4ID0gZ2dhbW1hOC5yZWRJQWRkKGdnYW1tYTgpO1xuICAgIGdnYW1tYTggPSBnZ2FtbWE4LnJlZElBZGQoZ2dhbW1hOCk7XG4gICAgbnkgPSBhbHBoYS5yZWRNdWwoYmV0YTQucmVkSVN1YihueCkpLnJlZElTdWIoZ2dhbW1hOCk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobngsIG55LCBueik7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLl9kYmwgPSBmdW5jdGlvbiBfZGJsKCkge1xuICB2YXIgYSA9IHRoaXMuY3VydmUuYTtcblxuICAvLyA0TSArIDZTICsgMTBBXG4gIHZhciBqeCA9IHRoaXMueDtcbiAgdmFyIGp5ID0gdGhpcy55O1xuICB2YXIganogPSB0aGlzLno7XG4gIHZhciBqejQgPSBqei5yZWRTcXIoKS5yZWRTcXIoKTtcblxuICB2YXIgangyID0gangucmVkU3FyKCk7XG4gIHZhciBqeTIgPSBqeS5yZWRTcXIoKTtcblxuICB2YXIgYyA9IGp4Mi5yZWRBZGQoangyKS5yZWRJQWRkKGp4MikucmVkSUFkZChhLnJlZE11bChqejQpKTtcblxuICB2YXIganhkNCA9IGp4LnJlZEFkZChqeCk7XG4gIGp4ZDQgPSBqeGQ0LnJlZElBZGQoanhkNCk7XG4gIHZhciB0MSA9IGp4ZDQucmVkTXVsKGp5Mik7XG4gIHZhciBueCA9IGMucmVkU3FyKCkucmVkSVN1Yih0MS5yZWRBZGQodDEpKTtcbiAgdmFyIHQyID0gdDEucmVkSVN1YihueCk7XG5cbiAgdmFyIGp5ZDggPSBqeTIucmVkU3FyKCk7XG4gIGp5ZDggPSBqeWQ4LnJlZElBZGQoanlkOCk7XG4gIGp5ZDggPSBqeWQ4LnJlZElBZGQoanlkOCk7XG4gIGp5ZDggPSBqeWQ4LnJlZElBZGQoanlkOCk7XG4gIHZhciBueSA9IGMucmVkTXVsKHQyKS5yZWRJU3ViKGp5ZDgpO1xuICB2YXIgbnogPSBqeS5yZWRBZGQoankpLnJlZE11bChqeik7XG5cbiAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG54LCBueSwgbnopO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS50cnBsID0gZnVuY3Rpb24gdHJwbCgpIHtcbiAgaWYgKCF0aGlzLmN1cnZlLnplcm9BKVxuICAgIHJldHVybiB0aGlzLmRibCgpLmFkZCh0aGlzKTtcblxuICAvLyBoeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tc2hvcnR3LWphY29iaWFuLTAuaHRtbCN0cmlwbGluZy10cGwtMjAwNy1ibFxuICAvLyA1TSArIDEwUyArIC4uLlxuXG4gIC8vIFhYID0gWDFeMlxuICB2YXIgeHggPSB0aGlzLngucmVkU3FyKCk7XG4gIC8vIFlZID0gWTFeMlxuICB2YXIgeXkgPSB0aGlzLnkucmVkU3FyKCk7XG4gIC8vIFpaID0gWjFeMlxuICB2YXIgenogPSB0aGlzLnoucmVkU3FyKCk7XG4gIC8vIFlZWVkgPSBZWV4yXG4gIHZhciB5eXl5ID0geXkucmVkU3FyKCk7XG4gIC8vIE0gPSAzICogWFggKyBhICogWloyOyBhID0gMFxuICB2YXIgbSA9IHh4LnJlZEFkZCh4eCkucmVkSUFkZCh4eCk7XG4gIC8vIE1NID0gTV4yXG4gIHZhciBtbSA9IG0ucmVkU3FyKCk7XG4gIC8vIEUgPSA2ICogKChYMSArIFlZKV4yIC0gWFggLSBZWVlZKSAtIE1NXG4gIHZhciBlID0gdGhpcy54LnJlZEFkZCh5eSkucmVkU3FyKCkucmVkSVN1Yih4eCkucmVkSVN1Yih5eXl5KTtcbiAgZSA9IGUucmVkSUFkZChlKTtcbiAgZSA9IGUucmVkQWRkKGUpLnJlZElBZGQoZSk7XG4gIGUgPSBlLnJlZElTdWIobW0pO1xuICAvLyBFRSA9IEVeMlxuICB2YXIgZWUgPSBlLnJlZFNxcigpO1xuICAvLyBUID0gMTYqWVlZWVxuICB2YXIgdCA9IHl5eXkucmVkSUFkZCh5eXl5KTtcbiAgdCA9IHQucmVkSUFkZCh0KTtcbiAgdCA9IHQucmVkSUFkZCh0KTtcbiAgdCA9IHQucmVkSUFkZCh0KTtcbiAgLy8gVSA9IChNICsgRSleMiAtIE1NIC0gRUUgLSBUXG4gIHZhciB1ID0gbS5yZWRJQWRkKGUpLnJlZFNxcigpLnJlZElTdWIobW0pLnJlZElTdWIoZWUpLnJlZElTdWIodCk7XG4gIC8vIFgzID0gNCAqIChYMSAqIEVFIC0gNCAqIFlZICogVSlcbiAgdmFyIHl5dTQgPSB5eS5yZWRNdWwodSk7XG4gIHl5dTQgPSB5eXU0LnJlZElBZGQoeXl1NCk7XG4gIHl5dTQgPSB5eXU0LnJlZElBZGQoeXl1NCk7XG4gIHZhciBueCA9IHRoaXMueC5yZWRNdWwoZWUpLnJlZElTdWIoeXl1NCk7XG4gIG54ID0gbngucmVkSUFkZChueCk7XG4gIG54ID0gbngucmVkSUFkZChueCk7XG4gIC8vIFkzID0gOCAqIFkxICogKFUgKiAoVCAtIFUpIC0gRSAqIEVFKVxuICB2YXIgbnkgPSB0aGlzLnkucmVkTXVsKHUucmVkTXVsKHQucmVkSVN1Yih1KSkucmVkSVN1YihlLnJlZE11bChlZSkpKTtcbiAgbnkgPSBueS5yZWRJQWRkKG55KTtcbiAgbnkgPSBueS5yZWRJQWRkKG55KTtcbiAgbnkgPSBueS5yZWRJQWRkKG55KTtcbiAgLy8gWjMgPSAoWjEgKyBFKV4yIC0gWlogLSBFRVxuICB2YXIgbnogPSB0aGlzLnoucmVkQWRkKGUpLnJlZFNxcigpLnJlZElTdWIoenopLnJlZElTdWIoZWUpO1xuXG4gIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludChueCwgbnksIG56KTtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gbXVsKGssIGtiYXNlKSB7XG4gIGsgPSBuZXcgYm4oaywga2Jhc2UpO1xuXG4gIHJldHVybiB0aGlzLmN1cnZlLl93bmFmTXVsKHRoaXMsIGspO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS5lcSA9IGZ1bmN0aW9uIGVxKHApIHtcbiAgaWYgKHAudHlwZSA9PT0gJ2FmZmluZScpXG4gICAgcmV0dXJuIHRoaXMuZXEocC50b0ooKSk7XG5cbiAgaWYgKHRoaXMgPT09IHApXG4gICAgcmV0dXJuIHRydWU7XG5cbiAgLy8geDEgKiB6Ml4yID09IHgyICogejFeMlxuICB2YXIgejIgPSB0aGlzLnoucmVkU3FyKCk7XG4gIHZhciBwejIgPSBwLnoucmVkU3FyKCk7XG4gIGlmICh0aGlzLngucmVkTXVsKHB6MikucmVkSVN1YihwLngucmVkTXVsKHoyKSkuY21wbigwKSAhPT0gMClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgLy8geTEgKiB6Ml4zID09IHkyICogejFeM1xuICB2YXIgejMgPSB6Mi5yZWRNdWwodGhpcy56KTtcbiAgdmFyIHB6MyA9IHB6Mi5yZWRNdWwocC56KTtcbiAgcmV0dXJuIHRoaXMueS5yZWRNdWwocHozKS5yZWRJU3ViKHAueS5yZWRNdWwoejMpKS5jbXBuKDApID09PSAwO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCgpIHtcbiAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiAnPEVDIEpQb2ludCBJbmZpbml0eT4nO1xuICByZXR1cm4gJzxFQyBKUG9pbnQgeDogJyArIHRoaXMueC50b1N0cmluZygxNiwgMikgK1xuICAgICAgJyB5OiAnICsgdGhpcy55LnRvU3RyaW5nKDE2LCAyKSArXG4gICAgICAnIHo6ICcgKyB0aGlzLnoudG9TdHJpbmcoMTYsIDIpICsgJz4nO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS5pc0luZmluaXR5ID0gZnVuY3Rpb24gaXNJbmZpbml0eSgpIHtcbiAgLy8gWFhYIFRoaXMgY29kZSBhc3N1bWVzIHRoYXQgemVybyBpcyBhbHdheXMgemVybyBpbiByZWRcbiAgcmV0dXJuIHRoaXMuei5jbXBuKDApID09PSAwO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGN1cnZlcyA9IGV4cG9ydHM7XG5cbnZhciBoYXNoID0gcmVxdWlyZSgnaGFzaC5qcycpO1xudmFyIGVsbGlwdGljID0gcmVxdWlyZSgnLi4vZWxsaXB0aWMnKTtcblxudmFyIGFzc2VydCA9IGVsbGlwdGljLnV0aWxzLmFzc2VydDtcblxuZnVuY3Rpb24gUHJlc2V0Q3VydmUob3B0aW9ucykge1xuICBpZiAob3B0aW9ucy50eXBlID09PSAnc2hvcnQnKVxuICAgIHRoaXMuY3VydmUgPSBuZXcgZWxsaXB0aWMuY3VydmUuc2hvcnQob3B0aW9ucyk7XG4gIGVsc2UgaWYgKG9wdGlvbnMudHlwZSA9PT0gJ2Vkd2FyZHMnKVxuICAgIHRoaXMuY3VydmUgPSBuZXcgZWxsaXB0aWMuY3VydmUuZWR3YXJkcyhvcHRpb25zKTtcbiAgZWxzZVxuICAgIHRoaXMuY3VydmUgPSBuZXcgZWxsaXB0aWMuY3VydmUubW9udChvcHRpb25zKTtcbiAgdGhpcy5nID0gdGhpcy5jdXJ2ZS5nO1xuICB0aGlzLm4gPSB0aGlzLmN1cnZlLm47XG4gIHRoaXMuaGFzaCA9IG9wdGlvbnMuaGFzaDtcblxuICBhc3NlcnQodGhpcy5nLnZhbGlkYXRlKCksICdJbnZhbGlkIGN1cnZlJyk7XG4gIGFzc2VydCh0aGlzLmcubXVsKHRoaXMubikuaXNJbmZpbml0eSgpLCAnSW52YWxpZCBjdXJ2ZSwgRypOICE9IE8nKTtcbn1cbmN1cnZlcy5QcmVzZXRDdXJ2ZSA9IFByZXNldEN1cnZlO1xuXG5mdW5jdGlvbiBkZWZpbmVDdXJ2ZShuYW1lLCBvcHRpb25zKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdXJ2ZXMsIG5hbWUsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGN1cnZlID0gbmV3IFByZXNldEN1cnZlKG9wdGlvbnMpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1cnZlcywgbmFtZSwge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBjdXJ2ZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gY3VydmU7XG4gICAgfVxuICB9KTtcbn1cblxuZGVmaW5lQ3VydmUoJ3AxOTInLCB7XG4gIHR5cGU6ICdzaG9ydCcsXG4gIHByaW1lOiAncDE5MicsXG4gIHA6ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmZmZiBmZmZmZmZmZicsXG4gIGE6ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmZmZiBmZmZmZmZmYycsXG4gIGI6ICc2NDIxMDUxOSBlNTljODBlNyAwZmE3ZTlhYiA3MjI0MzA0OSBmZWI4ZGVlYyBjMTQ2YjliMScsXG4gIG46ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiA5OWRlZjgzNiAxNDZiYzliMSBiNGQyMjgzMScsXG4gIGhhc2g6IGhhc2guc2hhMjU2LFxuICBnUmVkOiBmYWxzZSxcbiAgZzogW1xuICAgICcxODhkYTgwZSBiMDMwOTBmNiA3Y2JmMjBlYiA0M2ExODgwMCBmNGZmMGFmZCA4MmZmMTAxMicsXG4gICAgJzA3MTkyYjk1IGZmYzhkYTc4IDYzMTAxMWVkIDZiMjRjZGQ1IDczZjk3N2ExIDFlNzk0ODExJ1xuICBdXG59KTtcblxuZGVmaW5lQ3VydmUoJ3AyMjQnLCB7XG4gIHR5cGU6ICdzaG9ydCcsXG4gIHByaW1lOiAncDIyNCcsXG4gIHA6ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAwMDAwMDAwMCAwMDAwMDAwMCAwMDAwMDAwMScsXG4gIGE6ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZScsXG4gIGI6ICdiNDA1MGE4NSAwYzA0YjNhYiBmNTQxMzI1NiA1MDQ0YjBiNyBkN2JmZDhiYSAyNzBiMzk0MyAyMzU1ZmZiNCcsXG4gIG46ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmMTZhMiBlMGI4ZjAzZSAxM2RkMjk0NSA1YzVjMmEzZCcsXG4gIGhhc2g6IGhhc2guc2hhMjU2LFxuICBnUmVkOiBmYWxzZSxcbiAgZzogW1xuICAgICdiNzBlMGNiZCA2YmI0YmY3ZiAzMjEzOTBiOSA0YTAzYzFkMyA1NmMyMTEyMiAzNDMyODBkNiAxMTVjMWQyMScsXG4gICAgJ2JkMzc2Mzg4IGI1ZjcyM2ZiIDRjMjJkZmU2IGNkNDM3NWEwIDVhMDc0NzY0IDQ0ZDU4MTk5IDg1MDA3ZTM0J1xuICBdXG59KTtcblxuZGVmaW5lQ3VydmUoJ3AyNTYnLCB7XG4gIHR5cGU6ICdzaG9ydCcsXG4gIHByaW1lOiBudWxsLFxuICBwOiAnZmZmZmZmZmYgMDAwMDAwMDEgMDAwMDAwMDAgMDAwMDAwMDAgMDAwMDAwMDAgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYnLFxuICBhOiAnZmZmZmZmZmYgMDAwMDAwMDEgMDAwMDAwMDAgMDAwMDAwMDAgMDAwMDAwMDAgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmMnLFxuICBiOiAnNWFjNjM1ZDggYWEzYTkzZTcgYjNlYmJkNTUgNzY5ODg2YmMgNjUxZDA2YjAgY2M1M2IwZjYgM2JjZTNjM2UgMjdkMjYwNGInLFxuICBuOiAnZmZmZmZmZmYgMDAwMDAwMDAgZmZmZmZmZmYgZmZmZmZmZmYgYmNlNmZhYWQgYTcxNzllODQgZjNiOWNhYzIgZmM2MzI1NTEnLFxuICBoYXNoOiBoYXNoLnNoYTI1NixcbiAgZ1JlZDogZmFsc2UsXG4gIGc6IFtcbiAgICAnNmIxN2QxZjIgZTEyYzQyNDcgZjhiY2U2ZTUgNjNhNDQwZjIgNzcwMzdkODEgMmRlYjMzYTAgZjRhMTM5NDUgZDg5OGMyOTYnLFxuICAgICc0ZmUzNDJlMiBmZTFhN2Y5YiA4ZWU3ZWI0YSA3YzBmOWUxNiAyYmNlMzM1NyA2YjMxNWVjZSBjYmI2NDA2OCAzN2JmNTFmNSdcbiAgXVxufSk7XG5cbmRlZmluZUN1cnZlKCdwMzg0Jywge1xuICB0eXBlOiAnc2hvcnQnLFxuICBwcmltZTogbnVsbCxcbiAgcDogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmICcgK1xuICAgICAnZmZmZmZmZmUgZmZmZmZmZmYgMDAwMDAwMDAgMDAwMDAwMDAgZmZmZmZmZmYnLFxuICBhOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgJyArXG4gICAgICdmZmZmZmZmZSBmZmZmZmZmZiAwMDAwMDAwMCAwMDAwMDAwMCBmZmZmZmZmYycsXG4gIGI6ICdiMzMxMmZhNyBlMjNlZTdlNCA5ODhlMDU2YiBlM2Y4MmQxOSAxODFkOWM2ZSBmZTgxNDExMiAwMzE0MDg4ZiAnICtcbiAgICAgJzUwMTM4NzVhIGM2NTYzOThkIDhhMmVkMTlkIDJhODVjOGVkIGQzZWMyYWVmJyxcbiAgbjogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGM3NjM0ZDgxICcgK1xuICAgICAnZjQzNzJkZGYgNTgxYTBkYjIgNDhiMGE3N2EgZWNlYzE5NmEgY2NjNTI5NzMnLFxuICBoYXNoOiBoYXNoLnNoYTM4NCxcbiAgZ1JlZDogZmFsc2UsXG4gIGc6IFtcbiAgICAnYWE4N2NhMjIgYmU4YjA1MzcgOGViMWM3MWUgZjMyMGFkNzQgNmUxZDNiNjIgOGJhNzliOTggNTlmNzQxZTAgODI1NDJhMzggJyArXG4gICAgJzU1MDJmMjVkIGJmNTUyOTZjIDNhNTQ1ZTM4IDcyNzYwYWI3JyxcbiAgICAnMzYxN2RlNGEgOTYyNjJjNmYgNWQ5ZTk4YmYgOTI5MmRjMjkgZjhmNDFkYmQgMjg5YTE0N2MgZTlkYTMxMTMgYjVmMGI4YzAgJyArXG4gICAgJzBhNjBiMWNlIDFkN2U4MTlkIDdhNDMxZDdjIDkwZWEwZTVmJ1xuICBdXG59KTtcblxuZGVmaW5lQ3VydmUoJ3A1MjEnLCB7XG4gIHR5cGU6ICdzaG9ydCcsXG4gIHByaW1lOiBudWxsLFxuICBwOiAnMDAwMDAxZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgJyArXG4gICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAnICtcbiAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmJyxcbiAgYTogJzAwMDAwMWZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmICcgK1xuICAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgJyArXG4gICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmYycsXG4gIGI6ICcwMDAwMDA1MSA5NTNlYjk2MSA4ZTFjOWExZiA5MjlhMjFhMCBiNjg1NDBlZSBhMmRhNzI1YiAnICtcbiAgICAgJzk5YjMxNWYzIGI4YjQ4OTkxIDhlZjEwOWUxIDU2MTkzOTUxIGVjN2U5MzdiIDE2NTJjMGJkICcgK1xuICAgICAnM2JiMWJmMDcgMzU3M2RmODggM2QyYzM0ZjEgZWY0NTFmZDQgNmI1MDNmMDAnLFxuICBuOiAnMDAwMDAxZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgJyArXG4gICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmYSA1MTg2ODc4MyBiZjJmOTY2YiA3ZmNjMDE0OCAnICtcbiAgICAgJ2Y3MDlhNWQwIDNiYjVjOWI4IDg5OWM0N2FlIGJiNmZiNzFlIDkxMzg2NDA5JyxcbiAgaGFzaDogaGFzaC5zaGE1MTIsXG4gIGdSZWQ6IGZhbHNlLFxuICBnOiBbXG4gICAgJzAwMDAwMGM2IDg1OGUwNmI3IDA0MDRlOWNkIDllM2VjYjY2IDIzOTViNDQyIDljNjQ4MTM5ICcgK1xuICAgICcwNTNmYjUyMSBmODI4YWY2MCA2YjRkM2RiYSBhMTRiNWU3NyBlZmU3NTkyOCBmZTFkYzEyNyAnICtcbiAgICAnYTJmZmE4ZGUgMzM0OGIzYzEgODU2YTQyOWIgZjk3ZTdlMzEgYzJlNWJkNjYnLFxuICAgICcwMDAwMDExOCAzOTI5NmE3OCA5YTNiYzAwNCA1YzhhNWZiNCAyYzdkMWJkOSA5OGY1NDQ0OSAnICtcbiAgICAnNTc5YjQ0NjggMTdhZmJkMTcgMjczZTY2MmMgOTdlZTcyOTkgNWVmNDI2NDAgYzU1MGI5MDEgJyArXG4gICAgJzNmYWQwNzYxIDM1M2M3MDg2IGEyNzJjMjQwIDg4YmU5NDc2IDlmZDE2NjUwJ1xuICBdXG59KTtcblxuZGVmaW5lQ3VydmUoJ2N1cnZlMjU1MTknLCB7XG4gIHR5cGU6ICdtb250JyxcbiAgcHJpbWU6ICdwMjU1MTknLFxuICBwOiAnN2ZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZlZCcsXG4gIGE6ICc3NmQwNicsXG4gIGI6ICcwJyxcbiAgbjogJzEwMDAwMDAwMDAwMDAwMDAgMDAwMDAwMDAwMDAwMDAwMCAxNGRlZjlkZWEyZjc5Y2Q2IDU4MTI2MzFhNWNmNWQzZWQnLFxuICBoYXNoOiBoYXNoLnNoYTI1NixcbiAgZ1JlZDogZmFsc2UsXG4gIGc6IFtcbiAgICAnOSdcbiAgXVxufSk7XG5cbmRlZmluZUN1cnZlKCdlZDI1NTE5Jywge1xuICB0eXBlOiAnZWR3YXJkcycsXG4gIHByaW1lOiAncDI1NTE5JyxcbiAgcDogJzdmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZWQnLFxuICBhOiAnLTEnLFxuICBjOiAnMScsXG4gIC8vIC0xMjE2NjUgKiAoMTIxNjY2XigtMSkpIChtb2QgUClcbiAgZDogJzUyMDM2Y2VlMmI2ZmZlNzMgOGNjNzQwNzk3Nzc5ZTg5OCAwMDcwMGE0ZDQxNDFkOGFiIDc1ZWI0ZGNhMTM1OTc4YTMnLFxuICBuOiAnMTAwMDAwMDAwMDAwMDAwMCAwMDAwMDAwMDAwMDAwMDAwIDE0ZGVmOWRlYTJmNzljZDYgNTgxMjYzMWE1Y2Y1ZDNlZCcsXG4gIGhhc2g6IGhhc2guc2hhMjU2LFxuICBnUmVkOiBmYWxzZSxcbiAgZzogW1xuICAgICcyMTY5MzZkM2NkNmU1M2ZlYzBhNGUyMzFmZGQ2ZGM1YzY5MmNjNzYwOTUyNWE3YjJjOTU2MmQ2MDhmMjVkNTFhJyxcblxuICAgIC8vIDQvNVxuICAgICc2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjU4J1xuICBdXG59KTtcblxudmFyIHByZTtcbnRyeSB7XG4gIHByZSA9IHJlcXVpcmUoJy4vcHJlY29tcHV0ZWQvc2VjcDI1NmsxJyk7XG59IGNhdGNoIChlKSB7XG4gIHByZSA9IHVuZGVmaW5lZDtcbn1cblxuZGVmaW5lQ3VydmUoJ3NlY3AyNTZrMScsIHtcbiAgdHlwZTogJ3Nob3J0JyxcbiAgcHJpbWU6ICdrMjU2JyxcbiAgcDogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGZmZmZmYzJmJyxcbiAgYTogJzAnLFxuICBiOiAnNycsXG4gIG46ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBiYWFlZGNlNiBhZjQ4YTAzYiBiZmQyNWU4YyBkMDM2NDE0MScsXG4gIGg6ICcxJyxcbiAgaGFzaDogaGFzaC5zaGEyNTYsXG5cbiAgLy8gUHJlY29tcHV0ZWQgZW5kb21vcnBoaXNtXG4gIGJldGE6ICc3YWU5NmEyYjY1N2MwNzEwNmU2NDQ3OWVhYzM0MzRlOTljZjA0OTc1MTJmNTg5OTVjMTM5NmMyODcxOTUwMWVlJyxcbiAgbGFtYmRhOiAnNTM2M2FkNGNjMDVjMzBlMGE1MjYxYzAyODgxMjY0NWExMjJlMjJlYTIwODE2Njc4ZGYwMjk2N2MxYjIzYmQ3MicsXG4gIGJhc2lzOiBbXG4gICAge1xuICAgICAgYTogJzMwODZkMjIxYTdkNDZiY2RlODZjOTBlNDkyODRlYjE1JyxcbiAgICAgIGI6ICctZTQ0MzdlZDYwMTBlODgyODZmNTQ3ZmE5MGFiZmU0YzMnXG4gICAgfSxcbiAgICB7XG4gICAgICBhOiAnMTE0Y2E1MGY3YThlMmYzZjY1N2MxMTA4ZDlkNDRjZmQ4JyxcbiAgICAgIGI6ICczMDg2ZDIyMWE3ZDQ2YmNkZTg2YzkwZTQ5Mjg0ZWIxNSdcbiAgICB9XG4gIF0sXG5cbiAgZ1JlZDogZmFsc2UsXG4gIGc6IFtcbiAgICAnNzliZTY2N2VmOWRjYmJhYzU1YTA2Mjk1Y2U4NzBiMDcwMjliZmNkYjJkY2UyOGQ5NTlmMjgxNWIxNmY4MTc5OCcsXG4gICAgJzQ4M2FkYTc3MjZhM2M0NjU1ZGE0ZmJmYzBlMTEwOGE4ZmQxN2I0NDhhNjg1NTQxOTljNDdkMDhmZmIxMGQ0YjgnLFxuICAgIHByZVxuICBdXG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGJuID0gcmVxdWlyZSgnYm4uanMnKTtcbnZhciBlbGxpcHRpYyA9IHJlcXVpcmUoJy4uLy4uL2VsbGlwdGljJyk7XG52YXIgdXRpbHMgPSBlbGxpcHRpYy51dGlscztcbnZhciBhc3NlcnQgPSB1dGlscy5hc3NlcnQ7XG5cbnZhciBLZXlQYWlyID0gcmVxdWlyZSgnLi9rZXknKTtcbnZhciBTaWduYXR1cmUgPSByZXF1aXJlKCcuL3NpZ25hdHVyZScpO1xuXG5mdW5jdGlvbiBFQyhvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBFQykpXG4gICAgcmV0dXJuIG5ldyBFQyhvcHRpb25zKTtcblxuICAvLyBTaG9ydGN1dCBgZWxsaXB0aWMuZWMoY3VydmUtbmFtZSlgXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICBhc3NlcnQoZWxsaXB0aWMuY3VydmVzLmhhc093blByb3BlcnR5KG9wdGlvbnMpLCAnVW5rbm93biBjdXJ2ZSAnICsgb3B0aW9ucyk7XG5cbiAgICBvcHRpb25zID0gZWxsaXB0aWMuY3VydmVzW29wdGlvbnNdO1xuICB9XG5cbiAgLy8gU2hvcnRjdXQgZm9yIGBlbGxpcHRpYy5lYyhlbGxpcHRpYy5jdXJ2ZXMuY3VydmVOYW1lKWBcbiAgaWYgKG9wdGlvbnMgaW5zdGFuY2VvZiBlbGxpcHRpYy5jdXJ2ZXMuUHJlc2V0Q3VydmUpXG4gICAgb3B0aW9ucyA9IHsgY3VydmU6IG9wdGlvbnMgfTtcblxuICB0aGlzLmN1cnZlID0gb3B0aW9ucy5jdXJ2ZS5jdXJ2ZTtcbiAgdGhpcy5uID0gdGhpcy5jdXJ2ZS5uO1xuICB0aGlzLm5oID0gdGhpcy5uLnVzaHJuKDEpO1xuICB0aGlzLmcgPSB0aGlzLmN1cnZlLmc7XG5cbiAgLy8gUG9pbnQgb24gY3VydmVcbiAgdGhpcy5nID0gb3B0aW9ucy5jdXJ2ZS5nO1xuICB0aGlzLmcucHJlY29tcHV0ZShvcHRpb25zLmN1cnZlLm4uYml0TGVuZ3RoKCkgKyAxKTtcblxuICAvLyBIYXNoIGZvciBmdW5jdGlvbiBmb3IgRFJCR1xuICB0aGlzLmhhc2ggPSBvcHRpb25zLmhhc2ggfHwgb3B0aW9ucy5jdXJ2ZS5oYXNoO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFQztcblxuRUMucHJvdG90eXBlLmtleVBhaXIgPSBmdW5jdGlvbiBrZXlQYWlyKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBLZXlQYWlyKHRoaXMsIG9wdGlvbnMpO1xufTtcblxuRUMucHJvdG90eXBlLmtleUZyb21Qcml2YXRlID0gZnVuY3Rpb24ga2V5RnJvbVByaXZhdGUocHJpdiwgZW5jKSB7XG4gIHJldHVybiBLZXlQYWlyLmZyb21Qcml2YXRlKHRoaXMsIHByaXYsIGVuYyk7XG59O1xuXG5FQy5wcm90b3R5cGUua2V5RnJvbVB1YmxpYyA9IGZ1bmN0aW9uIGtleUZyb21QdWJsaWMocHViLCBlbmMpIHtcbiAgcmV0dXJuIEtleVBhaXIuZnJvbVB1YmxpYyh0aGlzLCBwdWIsIGVuYyk7XG59O1xuXG5FQy5wcm90b3R5cGUuZ2VuS2V5UGFpciA9IGZ1bmN0aW9uIGdlbktleVBhaXIob3B0aW9ucykge1xuICBpZiAoIW9wdGlvbnMpXG4gICAgb3B0aW9ucyA9IHt9O1xuXG4gIC8vIEluc3RhbnRpYXRlIEhtYWNfRFJCR1xuICB2YXIgZHJiZyA9IG5ldyBlbGxpcHRpYy5obWFjRFJCRyh7XG4gICAgaGFzaDogdGhpcy5oYXNoLFxuICAgIHBlcnM6IG9wdGlvbnMucGVycyxcbiAgICBlbnRyb3B5OiBvcHRpb25zLmVudHJvcHkgfHwgZWxsaXB0aWMucmFuZCh0aGlzLmhhc2guaG1hY1N0cmVuZ3RoKSxcbiAgICBub25jZTogdGhpcy5uLnRvQXJyYXkoKVxuICB9KTtcblxuICB2YXIgYnl0ZXMgPSB0aGlzLm4uYnl0ZUxlbmd0aCgpO1xuICB2YXIgbnMyID0gdGhpcy5uLnN1YihuZXcgYm4oMikpO1xuICBkbyB7XG4gICAgdmFyIHByaXYgPSBuZXcgYm4oZHJiZy5nZW5lcmF0ZShieXRlcykpO1xuICAgIGlmIChwcml2LmNtcChuczIpID4gMClcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgcHJpdi5pYWRkbigxKTtcbiAgICByZXR1cm4gdGhpcy5rZXlGcm9tUHJpdmF0ZShwcml2KTtcbiAgfSB3aGlsZSAodHJ1ZSk7XG59O1xuXG5FQy5wcm90b3R5cGUuX3RydW5jYXRlVG9OID0gZnVuY3Rpb24gdHJ1bmNhdGVUb04obXNnLCB0cnVuY09ubHkpIHtcbiAgdmFyIGRlbHRhID0gbXNnLmJ5dGVMZW5ndGgoKSAqIDggLSB0aGlzLm4uYml0TGVuZ3RoKCk7XG4gIGlmIChkZWx0YSA+IDApXG4gICAgbXNnID0gbXNnLnVzaHJuKGRlbHRhKTtcbiAgaWYgKCF0cnVuY09ubHkgJiYgbXNnLmNtcCh0aGlzLm4pID49IDApXG4gICAgcmV0dXJuIG1zZy5zdWIodGhpcy5uKTtcbiAgZWxzZVxuICAgIHJldHVybiBtc2c7XG59O1xuXG5FQy5wcm90b3R5cGUuc2lnbiA9IGZ1bmN0aW9uIHNpZ24obXNnLCBrZXksIGVuYywgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIGVuYyA9PT0gJ29iamVjdCcpIHtcbiAgICBvcHRpb25zID0gZW5jO1xuICAgIGVuYyA9IG51bGw7XG4gIH1cbiAgaWYgKCFvcHRpb25zKVxuICAgIG9wdGlvbnMgPSB7fTtcblxuICBrZXkgPSB0aGlzLmtleUZyb21Qcml2YXRlKGtleSwgZW5jKTtcbiAgbXNnID0gdGhpcy5fdHJ1bmNhdGVUb04obmV3IGJuKG1zZywgMTYpKTtcblxuICAvLyBaZXJvLWV4dGVuZCBrZXkgdG8gcHJvdmlkZSBlbm91Z2ggZW50cm9weVxuICB2YXIgYnl0ZXMgPSB0aGlzLm4uYnl0ZUxlbmd0aCgpO1xuICB2YXIgYmtleSA9IGtleS5nZXRQcml2YXRlKCkudG9BcnJheSgpO1xuICBmb3IgKHZhciBpID0gYmtleS5sZW5ndGg7IGkgPCBieXRlczsgaSsrKVxuICAgIGJrZXkudW5zaGlmdCgwKTtcblxuICAvLyBaZXJvLWV4dGVuZCBub25jZSB0byBoYXZlIHRoZSBzYW1lIGJ5dGUgc2l6ZSBhcyBOXG4gIHZhciBub25jZSA9IG1zZy50b0FycmF5KCk7XG4gIGZvciAodmFyIGkgPSBub25jZS5sZW5ndGg7IGkgPCBieXRlczsgaSsrKVxuICAgIG5vbmNlLnVuc2hpZnQoMCk7XG5cbiAgLy8gSW5zdGFudGlhdGUgSG1hY19EUkJHXG4gIHZhciBkcmJnID0gbmV3IGVsbGlwdGljLmhtYWNEUkJHKHtcbiAgICBoYXNoOiB0aGlzLmhhc2gsXG4gICAgZW50cm9weTogYmtleSxcbiAgICBub25jZTogbm9uY2VcbiAgfSk7XG5cbiAgLy8gTnVtYmVyIG9mIGJ5dGVzIHRvIGdlbmVyYXRlXG4gIHZhciBuczEgPSB0aGlzLm4uc3ViKG5ldyBibigxKSk7XG4gIGRvIHtcbiAgICB2YXIgayA9IG5ldyBibihkcmJnLmdlbmVyYXRlKHRoaXMubi5ieXRlTGVuZ3RoKCkpKTtcbiAgICBrID0gdGhpcy5fdHJ1bmNhdGVUb04oaywgdHJ1ZSk7XG4gICAgaWYgKGsuY21wbigxKSA8PSAwIHx8IGsuY21wKG5zMSkgPj0gMClcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgdmFyIGtwID0gdGhpcy5nLm11bChrKTtcbiAgICBpZiAoa3AuaXNJbmZpbml0eSgpKVxuICAgICAgY29udGludWU7XG5cbiAgICB2YXIga3BYID0ga3AuZ2V0WCgpO1xuICAgIHZhciByID0ga3BYLnVtb2QodGhpcy5uKTtcbiAgICBpZiAoci5jbXBuKDApID09PSAwKVxuICAgICAgY29udGludWU7XG5cbiAgICB2YXIgcyA9IGsuaW52bSh0aGlzLm4pLm11bChyLm11bChrZXkuZ2V0UHJpdmF0ZSgpKS5pYWRkKG1zZykpO1xuICAgIHMgPSBzLnVtb2QodGhpcy5uKTtcbiAgICBpZiAocy5jbXBuKDApID09PSAwKVxuICAgICAgY29udGludWU7XG5cbiAgICB2YXIgcmVjb3ZlcnlQYXJhbSA9IChrcC5nZXRZKCkuaXNPZGQoKSA/IDEgOiAwKSB8XG4gICAgICAgICAgICAgICAgICAgICAgICAoa3BYLmNtcChyKSAhPT0gMCA/IDIgOiAwKTtcblxuICAgIC8vIFVzZSBjb21wbGVtZW50IG9mIGBzYCwgaWYgaXQgaXMgPiBgbiAvIDJgXG4gICAgaWYgKG9wdGlvbnMuY2Fub25pY2FsICYmIHMuY21wKHRoaXMubmgpID4gMCkge1xuICAgICAgcyA9IHRoaXMubi5zdWIocyk7XG4gICAgICByZWNvdmVyeVBhcmFtIF49IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBTaWduYXR1cmUoeyByOiByLCBzOiBzLCByZWNvdmVyeVBhcmFtOiByZWNvdmVyeVBhcmFtIH0pO1xuICB9IHdoaWxlICh0cnVlKTtcbn07XG5cbkVDLnByb3RvdHlwZS52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobXNnLCBzaWduYXR1cmUsIGtleSwgZW5jKSB7XG4gIG1zZyA9IHRoaXMuX3RydW5jYXRlVG9OKG5ldyBibihtc2csIDE2KSk7XG4gIGtleSA9IHRoaXMua2V5RnJvbVB1YmxpYyhrZXksIGVuYyk7XG4gIHNpZ25hdHVyZSA9IG5ldyBTaWduYXR1cmUoc2lnbmF0dXJlLCAnaGV4Jyk7XG5cbiAgLy8gUGVyZm9ybSBwcmltaXRpdmUgdmFsdWVzIHZhbGlkYXRpb25cbiAgdmFyIHIgPSBzaWduYXR1cmUucjtcbiAgdmFyIHMgPSBzaWduYXR1cmUucztcbiAgaWYgKHIuY21wbigxKSA8IDAgfHwgci5jbXAodGhpcy5uKSA+PSAwKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKHMuY21wbigxKSA8IDAgfHwgcy5jbXAodGhpcy5uKSA+PSAwKVxuICAgIHJldHVybiBmYWxzZTtcblxuICAvLyBWYWxpZGF0ZSBzaWduYXR1cmVcbiAgdmFyIHNpbnYgPSBzLmludm0odGhpcy5uKTtcbiAgdmFyIHUxID0gc2ludi5tdWwobXNnKS51bW9kKHRoaXMubik7XG4gIHZhciB1MiA9IHNpbnYubXVsKHIpLnVtb2QodGhpcy5uKTtcblxuICB2YXIgcCA9IHRoaXMuZy5tdWxBZGQodTEsIGtleS5nZXRQdWJsaWMoKSwgdTIpO1xuICBpZiAocC5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIHJldHVybiBwLmdldFgoKS51bW9kKHRoaXMubikuY21wKHIpID09PSAwO1xufTtcblxuRUMucHJvdG90eXBlLnJlY292ZXJQdWJLZXkgPSBmdW5jdGlvbihtc2csIHNpZ25hdHVyZSwgaiwgZW5jKSB7XG4gIGFzc2VydCgoMyAmIGopID09PSBqLCAnVGhlIHJlY292ZXJ5IHBhcmFtIGlzIG1vcmUgdGhhbiB0d28gYml0cycpO1xuICBzaWduYXR1cmUgPSBuZXcgU2lnbmF0dXJlKHNpZ25hdHVyZSwgZW5jKTtcblxuICB2YXIgbiA9IHRoaXMubjtcbiAgdmFyIGUgPSBuZXcgYm4obXNnKTtcbiAgdmFyIHIgPSBzaWduYXR1cmUucjtcbiAgdmFyIHMgPSBzaWduYXR1cmUucztcblxuICAvLyBBIHNldCBMU0Igc2lnbmlmaWVzIHRoYXQgdGhlIHktY29vcmRpbmF0ZSBpcyBvZGRcbiAgdmFyIGlzWU9kZCA9IGogJiAxO1xuICB2YXIgaXNTZWNvbmRLZXkgPSBqID4+IDE7XG4gIGlmIChyLmNtcCh0aGlzLmN1cnZlLnAudW1vZCh0aGlzLmN1cnZlLm4pKSA+PSAwICYmIGlzU2Vjb25kS2V5KVxuICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgc2VuY29uZCBrZXkgY2FuZGluYXRlJyk7XG5cbiAgLy8gMS4xLiBMZXQgeCA9IHIgKyBqbi5cbiAgaWYgKGlzU2Vjb25kS2V5KVxuICAgIHIgPSB0aGlzLmN1cnZlLnBvaW50RnJvbVgoci5hZGQodGhpcy5jdXJ2ZS5uKSwgaXNZT2RkKTtcbiAgZWxzZVxuICAgIHIgPSB0aGlzLmN1cnZlLnBvaW50RnJvbVgociwgaXNZT2RkKTtcblxuICB2YXIgZU5lZyA9IG4uc3ViKGUpO1xuXG4gIC8vIDEuNi4xIENvbXB1dGUgUSA9IHJeLTEgKHNSIC0gIGVHKVxuICAvLyAgICAgICAgICAgICAgIFEgPSByXi0xIChzUiArIC1lRylcbiAgdmFyIHJJbnYgPSBzaWduYXR1cmUuci5pbnZtKG4pO1xuICByZXR1cm4gci5tdWwocykuYWRkKHRoaXMuZy5tdWwoZU5lZykpLm11bChySW52KTtcbn07XG5cbkVDLnByb3RvdHlwZS5nZXRLZXlSZWNvdmVyeVBhcmFtID0gZnVuY3Rpb24oZSwgc2lnbmF0dXJlLCBRLCBlbmMpIHtcbiAgc2lnbmF0dXJlID0gbmV3IFNpZ25hdHVyZShzaWduYXR1cmUsIGVuYyk7XG4gIGlmIChzaWduYXR1cmUucmVjb3ZlcnlQYXJhbSAhPT0gbnVsbClcbiAgICByZXR1cm4gc2lnbmF0dXJlLnJlY292ZXJ5UGFyYW07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICB2YXIgUXByaW1lID0gdGhpcy5yZWNvdmVyUHViS2V5KGUsIHNpZ25hdHVyZSwgaSk7XG5cbiAgICBpZiAoUXByaW1lLmVxKFEpKVxuICAgICAgcmV0dXJuIGk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZmluZCB2YWxpZCByZWNvdmVyeSBmYWN0b3InKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBibiA9IHJlcXVpcmUoJ2JuLmpzJyk7XG5cbmZ1bmN0aW9uIEtleVBhaXIoZWMsIG9wdGlvbnMpIHtcbiAgdGhpcy5lYyA9IGVjO1xuICB0aGlzLnByaXYgPSBudWxsO1xuICB0aGlzLnB1YiA9IG51bGw7XG5cbiAgLy8gS2V5UGFpcihlYywgeyBwcml2OiAuLi4sIHB1YjogLi4uIH0pXG4gIGlmIChvcHRpb25zLnByaXYpXG4gICAgdGhpcy5faW1wb3J0UHJpdmF0ZShvcHRpb25zLnByaXYsIG9wdGlvbnMucHJpdkVuYyk7XG4gIGlmIChvcHRpb25zLnB1YilcbiAgICB0aGlzLl9pbXBvcnRQdWJsaWMob3B0aW9ucy5wdWIsIG9wdGlvbnMucHViRW5jKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gS2V5UGFpcjtcblxuS2V5UGFpci5mcm9tUHVibGljID0gZnVuY3Rpb24gZnJvbVB1YmxpYyhlYywgcHViLCBlbmMpIHtcbiAgaWYgKHB1YiBpbnN0YW5jZW9mIEtleVBhaXIpXG4gICAgcmV0dXJuIHB1YjtcblxuICByZXR1cm4gbmV3IEtleVBhaXIoZWMsIHtcbiAgICBwdWI6IHB1YixcbiAgICBwdWJFbmM6IGVuY1xuICB9KTtcbn07XG5cbktleVBhaXIuZnJvbVByaXZhdGUgPSBmdW5jdGlvbiBmcm9tUHJpdmF0ZShlYywgcHJpdiwgZW5jKSB7XG4gIGlmIChwcml2IGluc3RhbmNlb2YgS2V5UGFpcilcbiAgICByZXR1cm4gcHJpdjtcblxuICByZXR1cm4gbmV3IEtleVBhaXIoZWMsIHtcbiAgICBwcml2OiBwcml2LFxuICAgIHByaXZFbmM6IGVuY1xuICB9KTtcbn07XG5cbktleVBhaXIucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gdmFsaWRhdGUoKSB7XG4gIHZhciBwdWIgPSB0aGlzLmdldFB1YmxpYygpO1xuXG4gIGlmIChwdWIuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiB7IHJlc3VsdDogZmFsc2UsIHJlYXNvbjogJ0ludmFsaWQgcHVibGljIGtleScgfTtcbiAgaWYgKCFwdWIudmFsaWRhdGUoKSlcbiAgICByZXR1cm4geyByZXN1bHQ6IGZhbHNlLCByZWFzb246ICdQdWJsaWMga2V5IGlzIG5vdCBhIHBvaW50JyB9O1xuICBpZiAoIXB1Yi5tdWwodGhpcy5lYy5jdXJ2ZS5uKS5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHsgcmVzdWx0OiBmYWxzZSwgcmVhc29uOiAnUHVibGljIGtleSAqIE4gIT0gTycgfTtcblxuICByZXR1cm4geyByZXN1bHQ6IHRydWUsIHJlYXNvbjogbnVsbCB9O1xufTtcblxuS2V5UGFpci5wcm90b3R5cGUuZ2V0UHVibGljID0gZnVuY3Rpb24gZ2V0UHVibGljKGNvbXBhY3QsIGVuYykge1xuICAvLyBjb21wYWN0IGlzIG9wdGlvbmFsIGFyZ3VtZW50XG4gIGlmICh0eXBlb2YgY29tcGFjdCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmMgPSBjb21wYWN0O1xuICAgIGNvbXBhY3QgPSBudWxsO1xuICB9XG5cbiAgaWYgKCF0aGlzLnB1YilcbiAgICB0aGlzLnB1YiA9IHRoaXMuZWMuZy5tdWwodGhpcy5wcml2KTtcblxuICBpZiAoIWVuYylcbiAgICByZXR1cm4gdGhpcy5wdWI7XG5cbiAgcmV0dXJuIHRoaXMucHViLmVuY29kZShlbmMsIGNvbXBhY3QpO1xufTtcblxuS2V5UGFpci5wcm90b3R5cGUuZ2V0UHJpdmF0ZSA9IGZ1bmN0aW9uIGdldFByaXZhdGUoZW5jKSB7XG4gIGlmIChlbmMgPT09ICdoZXgnKVxuICAgIHJldHVybiB0aGlzLnByaXYudG9TdHJpbmcoMTYsIDIpO1xuICBlbHNlXG4gICAgcmV0dXJuIHRoaXMucHJpdjtcbn07XG5cbktleVBhaXIucHJvdG90eXBlLl9pbXBvcnRQcml2YXRlID0gZnVuY3Rpb24gX2ltcG9ydFByaXZhdGUoa2V5LCBlbmMpIHtcbiAgdGhpcy5wcml2ID0gbmV3IGJuKGtleSwgZW5jIHx8IDE2KTtcblxuICAvLyBFbnN1cmUgdGhhdCB0aGUgcHJpdiB3b24ndCBiZSBiaWdnZXIgdGhhbiBuLCBvdGhlcndpc2Ugd2UgbWF5IGZhaWxcbiAgLy8gaW4gZml4ZWQgbXVsdGlwbGljYXRpb24gbWV0aG9kXG4gIHRoaXMucHJpdiA9IHRoaXMucHJpdi51bW9kKHRoaXMuZWMuY3VydmUubik7XG59O1xuXG5LZXlQYWlyLnByb3RvdHlwZS5faW1wb3J0UHVibGljID0gZnVuY3Rpb24gX2ltcG9ydFB1YmxpYyhrZXksIGVuYykge1xuICBpZiAoa2V5LnggfHwga2V5LnkpIHtcbiAgICB0aGlzLnB1YiA9IHRoaXMuZWMuY3VydmUucG9pbnQoa2V5LngsIGtleS55KTtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5wdWIgPSB0aGlzLmVjLmN1cnZlLmRlY29kZVBvaW50KGtleSwgZW5jKTtcbn07XG5cbi8vIEVDREhcbktleVBhaXIucHJvdG90eXBlLmRlcml2ZSA9IGZ1bmN0aW9uIGRlcml2ZShwdWIpIHtcbiAgcmV0dXJuIHB1Yi5tdWwodGhpcy5wcml2KS5nZXRYKCk7XG59O1xuXG4vLyBFQ0RTQVxuS2V5UGFpci5wcm90b3R5cGUuc2lnbiA9IGZ1bmN0aW9uIHNpZ24obXNnLCBlbmMsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHRoaXMuZWMuc2lnbihtc2csIHRoaXMsIGVuYywgb3B0aW9ucyk7XG59O1xuXG5LZXlQYWlyLnByb3RvdHlwZS52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobXNnLCBzaWduYXR1cmUpIHtcbiAgcmV0dXJuIHRoaXMuZWMudmVyaWZ5KG1zZywgc2lnbmF0dXJlLCB0aGlzKTtcbn07XG5cbktleVBhaXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0KCkge1xuICByZXR1cm4gJzxLZXkgcHJpdjogJyArICh0aGlzLnByaXYgJiYgdGhpcy5wcml2LnRvU3RyaW5nKDE2LCAyKSkgK1xuICAgICAgICAgJyBwdWI6ICcgKyAodGhpcy5wdWIgJiYgdGhpcy5wdWIuaW5zcGVjdCgpKSArICcgPic7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYm4gPSByZXF1aXJlKCdibi5qcycpO1xuXG52YXIgZWxsaXB0aWMgPSByZXF1aXJlKCcuLi8uLi9lbGxpcHRpYycpO1xudmFyIHV0aWxzID0gZWxsaXB0aWMudXRpbHM7XG52YXIgYXNzZXJ0ID0gdXRpbHMuYXNzZXJ0O1xuXG5mdW5jdGlvbiBTaWduYXR1cmUob3B0aW9ucywgZW5jKSB7XG4gIGlmIChvcHRpb25zIGluc3RhbmNlb2YgU2lnbmF0dXJlKVxuICAgIHJldHVybiBvcHRpb25zO1xuXG4gIGlmICh0aGlzLl9pbXBvcnRERVIob3B0aW9ucywgZW5jKSlcbiAgICByZXR1cm47XG5cbiAgYXNzZXJ0KG9wdGlvbnMuciAmJiBvcHRpb25zLnMsICdTaWduYXR1cmUgd2l0aG91dCByIG9yIHMnKTtcbiAgdGhpcy5yID0gbmV3IGJuKG9wdGlvbnMuciwgMTYpO1xuICB0aGlzLnMgPSBuZXcgYm4ob3B0aW9ucy5zLCAxNik7XG4gIGlmIChvcHRpb25zLnJlY292ZXJ5UGFyYW0gIT09IG51bGwpXG4gICAgdGhpcy5yZWNvdmVyeVBhcmFtID0gb3B0aW9ucy5yZWNvdmVyeVBhcmFtO1xuICBlbHNlXG4gICAgdGhpcy5yZWNvdmVyeVBhcmFtID0gbnVsbDtcbn1cbm1vZHVsZS5leHBvcnRzID0gU2lnbmF0dXJlO1xuXG5mdW5jdGlvbiBQb3NpdGlvbigpIHtcbiAgdGhpcy5wbGFjZSA9IDA7XG59XG5cbmZ1bmN0aW9uIGdldExlbmd0aChidWYsIHApIHtcbiAgdmFyIGluaXRpYWwgPSBidWZbcC5wbGFjZSsrXTtcbiAgaWYgKCEoaW5pdGlhbCAmIDB4ODApKSB7XG4gICAgcmV0dXJuIGluaXRpYWw7XG4gIH1cbiAgdmFyIG9jdGV0TGVuID0gaW5pdGlhbCAmIDB4ZjtcbiAgdmFyIHZhbCA9IDA7XG4gIGZvciAodmFyIGkgPSAwLCBvZmYgPSBwLnBsYWNlOyBpIDwgb2N0ZXRMZW47IGkrKywgb2ZmKyspIHtcbiAgICB2YWwgPDw9IDg7XG4gICAgdmFsIHw9IGJ1ZltvZmZdO1xuICB9XG4gIHAucGxhY2UgPSBvZmY7XG4gIHJldHVybiB2YWw7XG59XG5cbmZ1bmN0aW9uIHJtUGFkZGluZyhidWYpIHtcbiAgdmFyIGkgPSAwO1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aCAtIDE7XG4gIHdoaWxlICghYnVmW2ldICYmICEoYnVmW2kgKyAxXSAmIDB4ODApICYmIGkgPCBsZW4pIHtcbiAgICBpKys7XG4gIH1cbiAgaWYgKGkgPT09IDApIHtcbiAgICByZXR1cm4gYnVmO1xuICB9XG4gIHJldHVybiBidWYuc2xpY2UoaSk7XG59XG5cblNpZ25hdHVyZS5wcm90b3R5cGUuX2ltcG9ydERFUiA9IGZ1bmN0aW9uIF9pbXBvcnRERVIoZGF0YSwgZW5jKSB7XG4gIGRhdGEgPSB1dGlscy50b0FycmF5KGRhdGEsIGVuYyk7XG4gIHZhciBwID0gbmV3IFBvc2l0aW9uKCk7XG4gIGlmIChkYXRhW3AucGxhY2UrK10gIT09IDB4MzApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGxlbiA9IGdldExlbmd0aChkYXRhLCBwKTtcbiAgaWYgKChsZW4gKyBwLnBsYWNlKSAhPT0gZGF0YS5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGRhdGFbcC5wbGFjZSsrXSAhPT0gMHgwMikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcmxlbiA9IGdldExlbmd0aChkYXRhLCBwKTtcbiAgdmFyIHIgPSBkYXRhLnNsaWNlKHAucGxhY2UsIHJsZW4gKyBwLnBsYWNlKTtcbiAgcC5wbGFjZSArPSBybGVuO1xuICBpZiAoZGF0YVtwLnBsYWNlKytdICE9PSAweDAyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBzbGVuID0gZ2V0TGVuZ3RoKGRhdGEsIHApO1xuICBpZiAoZGF0YS5sZW5ndGggIT09IHNsZW4gKyBwLnBsYWNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBzID0gZGF0YS5zbGljZShwLnBsYWNlLCBzbGVuICsgcC5wbGFjZSk7XG4gIGlmIChyWzBdID09PSAwICYmIChyWzFdICYgMHg4MCkpIHtcbiAgICByID0gci5zbGljZSgxKTtcbiAgfVxuICBpZiAoc1swXSA9PT0gMCAmJiAoc1sxXSAmIDB4ODApKSB7XG4gICAgcyA9IHMuc2xpY2UoMSk7XG4gIH1cblxuICB0aGlzLnIgPSBuZXcgYm4ocik7XG4gIHRoaXMucyA9IG5ldyBibihzKTtcbiAgdGhpcy5yZWNvdmVyeVBhcmFtID0gbnVsbDtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdExlbmd0aChhcnIsIGxlbikge1xuICBpZiAobGVuIDwgMHg4MCkge1xuICAgIGFyci5wdXNoKGxlbik7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBvY3RldHMgPSAxICsgKE1hdGgubG9nKGxlbikgLyBNYXRoLkxOMiA+Pj4gMyk7XG4gIGFyci5wdXNoKG9jdGV0cyB8IDB4ODApO1xuICB3aGlsZSAoLS1vY3RldHMpIHtcbiAgICBhcnIucHVzaCgobGVuID4+PiAob2N0ZXRzIDw8IDMpKSAmIDB4ZmYpO1xuICB9XG4gIGFyci5wdXNoKGxlbik7XG59XG5cblNpZ25hdHVyZS5wcm90b3R5cGUudG9ERVIgPSBmdW5jdGlvbiB0b0RFUihlbmMpIHtcbiAgdmFyIHIgPSB0aGlzLnIudG9BcnJheSgpO1xuICB2YXIgcyA9IHRoaXMucy50b0FycmF5KCk7XG5cbiAgLy8gUGFkIHZhbHVlc1xuICBpZiAoclswXSAmIDB4ODApXG4gICAgciA9IFsgMCBdLmNvbmNhdChyKTtcbiAgLy8gUGFkIHZhbHVlc1xuICBpZiAoc1swXSAmIDB4ODApXG4gICAgcyA9IFsgMCBdLmNvbmNhdChzKTtcblxuICByID0gcm1QYWRkaW5nKHIpO1xuICBzID0gcm1QYWRkaW5nKHMpO1xuXG4gIHdoaWxlICghc1swXSAmJiAhKHNbMV0gJiAweDgwKSkge1xuICAgIHMgPSBzLnNsaWNlKDEpO1xuICB9XG4gIHZhciBhcnIgPSBbIDB4MDIgXTtcbiAgY29uc3RydWN0TGVuZ3RoKGFyciwgci5sZW5ndGgpO1xuICBhcnIgPSBhcnIuY29uY2F0KHIpO1xuICBhcnIucHVzaCgweDAyKTtcbiAgY29uc3RydWN0TGVuZ3RoKGFyciwgcy5sZW5ndGgpO1xuICB2YXIgYmFja0hhbGYgPSBhcnIuY29uY2F0KHMpO1xuICB2YXIgcmVzID0gWyAweDMwIF07XG4gIGNvbnN0cnVjdExlbmd0aChyZXMsIGJhY2tIYWxmLmxlbmd0aCk7XG4gIHJlcyA9IHJlcy5jb25jYXQoYmFja0hhbGYpO1xuICByZXR1cm4gdXRpbHMuZW5jb2RlKHJlcywgZW5jKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBoYXNoID0gcmVxdWlyZSgnaGFzaC5qcycpO1xudmFyIGVsbGlwdGljID0gcmVxdWlyZSgnLi4vLi4vZWxsaXB0aWMnKTtcbnZhciB1dGlscyA9IGVsbGlwdGljLnV0aWxzO1xudmFyIGFzc2VydCA9IHV0aWxzLmFzc2VydDtcbnZhciBwYXJzZUJ5dGVzID0gdXRpbHMucGFyc2VCeXRlcztcbnZhciBLZXlQYWlyID0gcmVxdWlyZSgnLi9rZXknKTtcbnZhciBTaWduYXR1cmUgPSByZXF1aXJlKCcuL3NpZ25hdHVyZScpO1xuXG5mdW5jdGlvbiBFRERTQShjdXJ2ZSkge1xuICBhc3NlcnQoY3VydmUgPT09ICdlZDI1NTE5JywgJ29ubHkgdGVzdGVkIHdpdGggZWQyNTUxOSBzbyBmYXInKTtcblxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRUREU0EpKVxuICAgIHJldHVybiBuZXcgRUREU0EoY3VydmUpO1xuXG4gIHZhciBjdXJ2ZSA9IGVsbGlwdGljLmN1cnZlc1tjdXJ2ZV0uY3VydmU7XG4gIHRoaXMuY3VydmUgPSBjdXJ2ZTtcbiAgdGhpcy5nID0gY3VydmUuZztcbiAgdGhpcy5nLnByZWNvbXB1dGUoY3VydmUubi5iaXRMZW5ndGgoKSArIDEpO1xuXG4gIHRoaXMucG9pbnRDbGFzcyA9IGN1cnZlLnBvaW50KCkuY29uc3RydWN0b3I7XG4gIHRoaXMuZW5jb2RpbmdMZW5ndGggPSBNYXRoLmNlaWwoY3VydmUubi5iaXRMZW5ndGgoKSAvIDgpO1xuICB0aGlzLmhhc2ggPSBoYXNoLnNoYTUxMjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBFRERTQTtcblxuLyoqXG4qIEBwYXJhbSB7QXJyYXl8U3RyaW5nfSBtZXNzYWdlIC0gbWVzc2FnZSBieXRlc1xuKiBAcGFyYW0ge0FycmF5fFN0cmluZ3xLZXlQYWlyfSBzZWNyZXQgLSBzZWNyZXQgYnl0ZXMgb3IgYSBrZXlwYWlyXG4qIEByZXR1cm5zIHtTaWduYXR1cmV9IC0gc2lnbmF0dXJlXG4qL1xuRUREU0EucHJvdG90eXBlLnNpZ24gPSBmdW5jdGlvbiBzaWduKG1lc3NhZ2UsIHNlY3JldCkge1xuICBtZXNzYWdlID0gcGFyc2VCeXRlcyhtZXNzYWdlKTtcbiAgdmFyIGtleSA9IHRoaXMua2V5RnJvbVNlY3JldChzZWNyZXQpO1xuICB2YXIgciA9IHRoaXMuaGFzaEludChrZXkubWVzc2FnZVByZWZpeCgpLCBtZXNzYWdlKTtcbiAgdmFyIFIgPSB0aGlzLmcubXVsKHIpO1xuICB2YXIgUmVuY29kZWQgPSB0aGlzLmVuY29kZVBvaW50KFIpO1xuICB2YXIgc18gPSB0aGlzLmhhc2hJbnQoUmVuY29kZWQsIGtleS5wdWJCeXRlcygpLCBtZXNzYWdlKVxuICAgICAgICAgICAgICAgLm11bChrZXkucHJpdigpKTtcbiAgdmFyIFMgPSByLmFkZChzXykudW1vZCh0aGlzLmN1cnZlLm4pO1xuICByZXR1cm4gdGhpcy5tYWtlU2lnbmF0dXJlKHsgUjogUiwgUzogUywgUmVuY29kZWQ6IFJlbmNvZGVkIH0pO1xufTtcblxuLyoqXG4qIEBwYXJhbSB7QXJyYXl9IG1lc3NhZ2UgLSBtZXNzYWdlIGJ5dGVzXG4qIEBwYXJhbSB7QXJyYXl8U3RyaW5nfFNpZ25hdHVyZX0gc2lnIC0gc2lnIGJ5dGVzXG4qIEBwYXJhbSB7QXJyYXl8U3RyaW5nfFBvaW50fEtleVBhaXJ9IHB1YiAtIHB1YmxpYyBrZXlcbiogQHJldHVybnMge0Jvb2xlYW59IC0gdHJ1ZSBpZiBwdWJsaWMga2V5IG1hdGNoZXMgc2lnIG9mIG1lc3NhZ2VcbiovXG5FRERTQS5wcm90b3R5cGUudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UsIHNpZywgcHViKSB7XG4gIG1lc3NhZ2UgPSBwYXJzZUJ5dGVzKG1lc3NhZ2UpO1xuICBzaWcgPSB0aGlzLm1ha2VTaWduYXR1cmUoc2lnKTtcbiAgdmFyIGtleSA9IHRoaXMua2V5RnJvbVB1YmxpYyhwdWIpO1xuICB2YXIgaCA9IHRoaXMuaGFzaEludChzaWcuUmVuY29kZWQoKSwga2V5LnB1YkJ5dGVzKCksIG1lc3NhZ2UpO1xuICB2YXIgU0cgPSB0aGlzLmcubXVsKHNpZy5TKCkpO1xuICB2YXIgUnBsdXNBaCA9IHNpZy5SKCkuYWRkKGtleS5wdWIoKS5tdWwoaCkpO1xuICByZXR1cm4gUnBsdXNBaC5lcShTRyk7XG59O1xuXG5FRERTQS5wcm90b3R5cGUuaGFzaEludCA9IGZ1bmN0aW9uIGhhc2hJbnQoKSB7XG4gIHZhciBoYXNoID0gdGhpcy5oYXNoKCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxuICAgIGhhc2gudXBkYXRlKGFyZ3VtZW50c1tpXSk7XG4gIHJldHVybiB1dGlscy5pbnRGcm9tTEUoaGFzaC5kaWdlc3QoKSkudW1vZCh0aGlzLmN1cnZlLm4pO1xufTtcblxuRUREU0EucHJvdG90eXBlLmtleUZyb21QdWJsaWMgPSBmdW5jdGlvbiBrZXlGcm9tUHVibGljKHB1Yikge1xuICByZXR1cm4gS2V5UGFpci5mcm9tUHVibGljKHRoaXMsIHB1Yik7XG59O1xuXG5FRERTQS5wcm90b3R5cGUua2V5RnJvbVNlY3JldCA9IGZ1bmN0aW9uIGtleUZyb21TZWNyZXQoc2VjcmV0KSB7XG4gIHJldHVybiBLZXlQYWlyLmZyb21TZWNyZXQodGhpcywgc2VjcmV0KTtcbn07XG5cbkVERFNBLnByb3RvdHlwZS5tYWtlU2lnbmF0dXJlID0gZnVuY3Rpb24gbWFrZVNpZ25hdHVyZShzaWcpIHtcbiAgaWYgKHNpZyBpbnN0YW5jZW9mIFNpZ25hdHVyZSlcbiAgICByZXR1cm4gc2lnO1xuICByZXR1cm4gbmV3IFNpZ25hdHVyZSh0aGlzLCBzaWcpO1xufTtcblxuLyoqXG4qICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LWpvc2Vmc3Nvbi1lZGRzYS1lZDI1NTE5LTAzI3NlY3Rpb24tNS4yXG4qXG4qIEVERFNBIGRlZmluZXMgbWV0aG9kcyBmb3IgZW5jb2RpbmcgYW5kIGRlY29kaW5nIHBvaW50cyBhbmQgaW50ZWdlcnMuIFRoZXNlIGFyZVxuKiBoZWxwZXIgY29udmVuaWVuY2UgbWV0aG9kcywgdGhhdCBwYXNzIGFsb25nIHRvIHV0aWxpdHkgZnVuY3Rpb25zIGltcGxpZWRcbiogcGFyYW1ldGVycy5cbipcbiovXG5FRERTQS5wcm90b3R5cGUuZW5jb2RlUG9pbnQgPSBmdW5jdGlvbiBlbmNvZGVQb2ludChwb2ludCkge1xuICB2YXIgZW5jID0gcG9pbnQuZ2V0WSgpLnRvQXJyYXkoJ2xlJywgdGhpcy5lbmNvZGluZ0xlbmd0aCk7XG4gIGVuY1t0aGlzLmVuY29kaW5nTGVuZ3RoIC0gMV0gfD0gcG9pbnQuZ2V0WCgpLmlzT2RkKCkgPyAweDgwIDogMDtcbiAgcmV0dXJuIGVuYztcbn07XG5cbkVERFNBLnByb3RvdHlwZS5kZWNvZGVQb2ludCA9IGZ1bmN0aW9uIGRlY29kZVBvaW50KGJ5dGVzKSB7XG4gIGJ5dGVzID0gdXRpbHMucGFyc2VCeXRlcyhieXRlcyk7XG5cbiAgdmFyIGxhc3RJeCA9IGJ5dGVzLmxlbmd0aCAtIDE7XG4gIHZhciBub3JtZWQgPSBieXRlcy5zbGljZSgwLCBsYXN0SXgpLmNvbmNhdChieXRlc1tsYXN0SXhdICYgfjB4ODApO1xuICB2YXIgeElzT2RkID0gKGJ5dGVzW2xhc3RJeF0gJiAweDgwKSAhPT0gMDtcblxuICB2YXIgeSA9IHV0aWxzLmludEZyb21MRShub3JtZWQpO1xuICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludEZyb21ZKHksIHhJc09kZCk7XG59O1xuXG5FRERTQS5wcm90b3R5cGUuZW5jb2RlSW50ID0gZnVuY3Rpb24gZW5jb2RlSW50KG51bSkge1xuICByZXR1cm4gbnVtLnRvQXJyYXkoJ2xlJywgdGhpcy5lbmNvZGluZ0xlbmd0aCk7XG59O1xuXG5FRERTQS5wcm90b3R5cGUuZGVjb2RlSW50ID0gZnVuY3Rpb24gZGVjb2RlSW50KGJ5dGVzKSB7XG4gIHJldHVybiB1dGlscy5pbnRGcm9tTEUoYnl0ZXMpO1xufTtcblxuRUREU0EucHJvdG90eXBlLmlzUG9pbnQgPSBmdW5jdGlvbiBpc1BvaW50KHZhbCkge1xuICByZXR1cm4gdmFsIGluc3RhbmNlb2YgdGhpcy5wb2ludENsYXNzO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGVsbGlwdGljID0gcmVxdWlyZSgnLi4vLi4vZWxsaXB0aWMnKTtcbnZhciB1dGlscyA9IGVsbGlwdGljLnV0aWxzO1xudmFyIGFzc2VydCA9IHV0aWxzLmFzc2VydDtcbnZhciBwYXJzZUJ5dGVzID0gdXRpbHMucGFyc2VCeXRlcztcbnZhciBjYWNoZWRQcm9wZXJ0eSA9IHV0aWxzLmNhY2hlZFByb3BlcnR5O1xuXG4vKipcbiogQHBhcmFtIHtFRERTQX0gZWRkc2EgLSBpbnN0YW5jZVxuKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIC0gcHVibGljL3ByaXZhdGUga2V5IHBhcmFtZXRlcnNcbipcbiogQHBhcmFtIHtBcnJheTxCeXRlPn0gW3BhcmFtcy5zZWNyZXRdIC0gc2VjcmV0IHNlZWQgYnl0ZXNcbiogQHBhcmFtIHtQb2ludH0gW3BhcmFtcy5wdWJdIC0gcHVibGljIGtleSBwb2ludCAoYWthIGBBYCBpbiBlZGRzYSB0ZXJtcylcbiogQHBhcmFtIHtBcnJheTxCeXRlPn0gW3BhcmFtcy5wdWJdIC0gcHVibGljIGtleSBwb2ludCBlbmNvZGVkIGFzIGJ5dGVzXG4qXG4qL1xuZnVuY3Rpb24gS2V5UGFpcihlZGRzYSwgcGFyYW1zKSB7XG4gIHRoaXMuZWRkc2EgPSBlZGRzYTtcbiAgdGhpcy5fc2VjcmV0ID0gcGFyc2VCeXRlcyhwYXJhbXMuc2VjcmV0KTtcbiAgaWYgKGVkZHNhLmlzUG9pbnQocGFyYW1zLnB1YikpXG4gICAgdGhpcy5fcHViID0gcGFyYW1zLnB1YjtcbiAgZWxzZVxuICAgIHRoaXMuX3B1YkJ5dGVzID0gcGFyc2VCeXRlcyhwYXJhbXMucHViKTtcbn1cblxuS2V5UGFpci5mcm9tUHVibGljID0gZnVuY3Rpb24gZnJvbVB1YmxpYyhlZGRzYSwgcHViKSB7XG4gIGlmIChwdWIgaW5zdGFuY2VvZiBLZXlQYWlyKVxuICAgIHJldHVybiBwdWI7XG4gIHJldHVybiBuZXcgS2V5UGFpcihlZGRzYSwgeyBwdWI6IHB1YiB9KTtcbn07XG5cbktleVBhaXIuZnJvbVNlY3JldCA9IGZ1bmN0aW9uIGZyb21TZWNyZXQoZWRkc2EsIHNlY3JldCkge1xuICBpZiAoc2VjcmV0IGluc3RhbmNlb2YgS2V5UGFpcilcbiAgICByZXR1cm4gc2VjcmV0O1xuICByZXR1cm4gbmV3IEtleVBhaXIoZWRkc2EsIHsgc2VjcmV0OiBzZWNyZXQgfSk7XG59O1xuXG5LZXlQYWlyLnByb3RvdHlwZS5zZWNyZXQgPSBmdW5jdGlvbiBzZWNyZXQoKSB7XG4gIHJldHVybiB0aGlzLl9zZWNyZXQ7XG59O1xuXG5jYWNoZWRQcm9wZXJ0eShLZXlQYWlyLCBmdW5jdGlvbiBwdWJCeXRlcygpIHtcbiAgcmV0dXJuIHRoaXMuZWRkc2EuZW5jb2RlUG9pbnQodGhpcy5wdWIoKSk7XG59KTtcblxuY2FjaGVkUHJvcGVydHkoS2V5UGFpciwgZnVuY3Rpb24gcHViKCkge1xuICBpZiAodGhpcy5fcHViQnl0ZXMpXG4gICAgcmV0dXJuIHRoaXMuZWRkc2EuZGVjb2RlUG9pbnQodGhpcy5fcHViQnl0ZXMpO1xuICByZXR1cm4gdGhpcy5lZGRzYS5nLm11bCh0aGlzLnByaXYoKSk7XG59KTtcblxuY2FjaGVkUHJvcGVydHkoS2V5UGFpciwgZnVuY3Rpb24gcHJpdkJ5dGVzKCkge1xuICB2YXIgZWRkc2EgPSB0aGlzLmVkZHNhO1xuICB2YXIgaGFzaCA9IHRoaXMuaGFzaCgpO1xuICB2YXIgbGFzdEl4ID0gZWRkc2EuZW5jb2RpbmdMZW5ndGggLSAxO1xuXG4gIHZhciBhID0gaGFzaC5zbGljZSgwLCBlZGRzYS5lbmNvZGluZ0xlbmd0aCk7XG4gIGFbMF0gJj0gMjQ4O1xuICBhW2xhc3RJeF0gJj0gMTI3O1xuICBhW2xhc3RJeF0gfD0gNjQ7XG5cbiAgcmV0dXJuIGE7XG59KTtcblxuY2FjaGVkUHJvcGVydHkoS2V5UGFpciwgZnVuY3Rpb24gcHJpdigpIHtcbiAgcmV0dXJuIHRoaXMuZWRkc2EuZGVjb2RlSW50KHRoaXMucHJpdkJ5dGVzKCkpO1xufSk7XG5cbmNhY2hlZFByb3BlcnR5KEtleVBhaXIsIGZ1bmN0aW9uIGhhc2goKSB7XG4gIHJldHVybiB0aGlzLmVkZHNhLmhhc2goKS51cGRhdGUodGhpcy5zZWNyZXQoKSkuZGlnZXN0KCk7XG59KTtcblxuY2FjaGVkUHJvcGVydHkoS2V5UGFpciwgZnVuY3Rpb24gbWVzc2FnZVByZWZpeCgpIHtcbiAgcmV0dXJuIHRoaXMuaGFzaCgpLnNsaWNlKHRoaXMuZWRkc2EuZW5jb2RpbmdMZW5ndGgpO1xufSk7XG5cbktleVBhaXIucHJvdG90eXBlLnNpZ24gPSBmdW5jdGlvbiBzaWduKG1lc3NhZ2UpIHtcbiAgYXNzZXJ0KHRoaXMuX3NlY3JldCwgJ0tleVBhaXIgY2FuIG9ubHkgdmVyaWZ5Jyk7XG4gIHJldHVybiB0aGlzLmVkZHNhLnNpZ24obWVzc2FnZSwgdGhpcyk7XG59O1xuXG5LZXlQYWlyLnByb3RvdHlwZS52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSwgc2lnKSB7XG4gIHJldHVybiB0aGlzLmVkZHNhLnZlcmlmeShtZXNzYWdlLCBzaWcsIHRoaXMpO1xufTtcblxuS2V5UGFpci5wcm90b3R5cGUuZ2V0U2VjcmV0ID0gZnVuY3Rpb24gZ2V0U2VjcmV0KGVuYykge1xuICBhc3NlcnQodGhpcy5fc2VjcmV0LCAnS2V5UGFpciBpcyBwdWJsaWMgb25seScpO1xuICByZXR1cm4gdXRpbHMuZW5jb2RlKHRoaXMuc2VjcmV0KCksIGVuYyk7XG59O1xuXG5LZXlQYWlyLnByb3RvdHlwZS5nZXRQdWJsaWMgPSBmdW5jdGlvbiBnZXRQdWJsaWMoZW5jKSB7XG4gIHJldHVybiB1dGlscy5lbmNvZGUodGhpcy5wdWJCeXRlcygpLCBlbmMpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBLZXlQYWlyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYm4gPSByZXF1aXJlKCdibi5qcycpO1xudmFyIGVsbGlwdGljID0gcmVxdWlyZSgnLi4vLi4vZWxsaXB0aWMnKTtcbnZhciB1dGlscyA9IGVsbGlwdGljLnV0aWxzO1xudmFyIGFzc2VydCA9IHV0aWxzLmFzc2VydDtcbnZhciBjYWNoZWRQcm9wZXJ0eSA9IHV0aWxzLmNhY2hlZFByb3BlcnR5O1xudmFyIHBhcnNlQnl0ZXMgPSB1dGlscy5wYXJzZUJ5dGVzO1xuXG4vKipcbiogQHBhcmFtIHtFRERTQX0gZWRkc2EgLSBlZGRzYSBpbnN0YW5jZVxuKiBAcGFyYW0ge0FycmF5PEJ5dGVzPnxPYmplY3R9IHNpZyAtXG4qIEBwYXJhbSB7QXJyYXk8Qnl0ZXM+fFBvaW50fSBbc2lnLlJdIC0gUiBwb2ludCBhcyBQb2ludCBvciBieXRlc1xuKiBAcGFyYW0ge0FycmF5PEJ5dGVzPnxibn0gW3NpZy5TXSAtIFMgc2NhbGFyIGFzIGJuIG9yIGJ5dGVzXG4qIEBwYXJhbSB7QXJyYXk8Qnl0ZXM+fSBbc2lnLlJlbmNvZGVkXSAtIFIgcG9pbnQgZW5jb2RlZFxuKiBAcGFyYW0ge0FycmF5PEJ5dGVzPn0gW3NpZy5TZW5jb2RlZF0gLSBTIHNjYWxhciBlbmNvZGVkXG4qL1xuZnVuY3Rpb24gU2lnbmF0dXJlKGVkZHNhLCBzaWcpIHtcbiAgdGhpcy5lZGRzYSA9IGVkZHNhO1xuXG4gIGlmICh0eXBlb2Ygc2lnICE9PSAnb2JqZWN0JylcbiAgICBzaWcgPSBwYXJzZUJ5dGVzKHNpZyk7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoc2lnKSkge1xuICAgIHNpZyA9IHtcbiAgICAgIFI6IHNpZy5zbGljZSgwLCBlZGRzYS5lbmNvZGluZ0xlbmd0aCksXG4gICAgICBTOiBzaWcuc2xpY2UoZWRkc2EuZW5jb2RpbmdMZW5ndGgpXG4gICAgfTtcbiAgfVxuXG4gIGFzc2VydChzaWcuUiAmJiBzaWcuUywgJ1NpZ25hdHVyZSB3aXRob3V0IFIgb3IgUycpO1xuXG4gIGlmIChlZGRzYS5pc1BvaW50KHNpZy5SKSlcbiAgICB0aGlzLl9SID0gc2lnLlI7XG4gIGlmIChzaWcuUyBpbnN0YW5jZW9mIGJuKVxuICAgIHRoaXMuX1MgPSBzaWcuUztcblxuICB0aGlzLl9SZW5jb2RlZCA9IEFycmF5LmlzQXJyYXkoc2lnLlIpID8gc2lnLlIgOiBzaWcuUmVuY29kZWQ7XG4gIHRoaXMuX1NlbmNvZGVkID0gQXJyYXkuaXNBcnJheShzaWcuUykgPyBzaWcuUyA6IHNpZy5TZW5jb2RlZDtcbn1cblxuY2FjaGVkUHJvcGVydHkoU2lnbmF0dXJlLCBmdW5jdGlvbiBTKCkge1xuICByZXR1cm4gdGhpcy5lZGRzYS5kZWNvZGVJbnQodGhpcy5TZW5jb2RlZCgpKTtcbn0pO1xuXG5jYWNoZWRQcm9wZXJ0eShTaWduYXR1cmUsIGZ1bmN0aW9uIFIoKSB7XG4gIHJldHVybiB0aGlzLmVkZHNhLmRlY29kZVBvaW50KHRoaXMuUmVuY29kZWQoKSk7XG59KTtcblxuY2FjaGVkUHJvcGVydHkoU2lnbmF0dXJlLCBmdW5jdGlvbiBSZW5jb2RlZCgpIHtcbiAgcmV0dXJuIHRoaXMuZWRkc2EuZW5jb2RlUG9pbnQodGhpcy5SKCkpO1xufSk7XG5cbmNhY2hlZFByb3BlcnR5KFNpZ25hdHVyZSwgZnVuY3Rpb24gU2VuY29kZWQoKSB7XG4gIHJldHVybiB0aGlzLmVkZHNhLmVuY29kZUludCh0aGlzLlMoKSk7XG59KTtcblxuU2lnbmF0dXJlLnByb3RvdHlwZS50b0J5dGVzID0gZnVuY3Rpb24gdG9CeXRlcygpIHtcbiAgcmV0dXJuIHRoaXMuUmVuY29kZWQoKS5jb25jYXQodGhpcy5TZW5jb2RlZCgpKTtcbn07XG5cblNpZ25hdHVyZS5wcm90b3R5cGUudG9IZXggPSBmdW5jdGlvbiB0b0hleCgpIHtcbiAgcmV0dXJuIHV0aWxzLmVuY29kZSh0aGlzLnRvQnl0ZXMoKSwgJ2hleCcpLnRvVXBwZXJDYXNlKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNpZ25hdHVyZTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGhhc2ggPSByZXF1aXJlKCdoYXNoLmpzJyk7XG52YXIgZWxsaXB0aWMgPSByZXF1aXJlKCcuLi9lbGxpcHRpYycpO1xudmFyIHV0aWxzID0gZWxsaXB0aWMudXRpbHM7XG52YXIgYXNzZXJ0ID0gdXRpbHMuYXNzZXJ0O1xuXG5mdW5jdGlvbiBIbWFjRFJCRyhvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBIbWFjRFJCRykpXG4gICAgcmV0dXJuIG5ldyBIbWFjRFJCRyhvcHRpb25zKTtcbiAgdGhpcy5oYXNoID0gb3B0aW9ucy5oYXNoO1xuICB0aGlzLnByZWRSZXNpc3QgPSAhIW9wdGlvbnMucHJlZFJlc2lzdDtcblxuICB0aGlzLm91dExlbiA9IHRoaXMuaGFzaC5vdXRTaXplO1xuICB0aGlzLm1pbkVudHJvcHkgPSBvcHRpb25zLm1pbkVudHJvcHkgfHwgdGhpcy5oYXNoLmhtYWNTdHJlbmd0aDtcblxuICB0aGlzLnJlc2VlZCA9IG51bGw7XG4gIHRoaXMucmVzZWVkSW50ZXJ2YWwgPSBudWxsO1xuICB0aGlzLksgPSBudWxsO1xuICB0aGlzLlYgPSBudWxsO1xuXG4gIHZhciBlbnRyb3B5ID0gdXRpbHMudG9BcnJheShvcHRpb25zLmVudHJvcHksIG9wdGlvbnMuZW50cm9weUVuYyk7XG4gIHZhciBub25jZSA9IHV0aWxzLnRvQXJyYXkob3B0aW9ucy5ub25jZSwgb3B0aW9ucy5ub25jZUVuYyk7XG4gIHZhciBwZXJzID0gdXRpbHMudG9BcnJheShvcHRpb25zLnBlcnMsIG9wdGlvbnMucGVyc0VuYyk7XG4gIGFzc2VydChlbnRyb3B5Lmxlbmd0aCA+PSAodGhpcy5taW5FbnRyb3B5IC8gOCksXG4gICAgICAgICAnTm90IGVub3VnaCBlbnRyb3B5LiBNaW5pbXVtIGlzOiAnICsgdGhpcy5taW5FbnRyb3B5ICsgJyBiaXRzJyk7XG4gIHRoaXMuX2luaXQoZW50cm9weSwgbm9uY2UsIHBlcnMpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBIbWFjRFJCRztcblxuSG1hY0RSQkcucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gaW5pdChlbnRyb3B5LCBub25jZSwgcGVycykge1xuICB2YXIgc2VlZCA9IGVudHJvcHkuY29uY2F0KG5vbmNlKS5jb25jYXQocGVycyk7XG5cbiAgdGhpcy5LID0gbmV3IEFycmF5KHRoaXMub3V0TGVuIC8gOCk7XG4gIHRoaXMuViA9IG5ldyBBcnJheSh0aGlzLm91dExlbiAvIDgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuVi5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMuS1tpXSA9IDB4MDA7XG4gICAgdGhpcy5WW2ldID0gMHgwMTtcbiAgfVxuXG4gIHRoaXMuX3VwZGF0ZShzZWVkKTtcbiAgdGhpcy5yZXNlZWQgPSAxO1xuICB0aGlzLnJlc2VlZEludGVydmFsID0gMHgxMDAwMDAwMDAwMDAwOyAgLy8gMl40OFxufTtcblxuSG1hY0RSQkcucHJvdG90eXBlLl9obWFjID0gZnVuY3Rpb24gaG1hYygpIHtcbiAgcmV0dXJuIG5ldyBoYXNoLmhtYWModGhpcy5oYXNoLCB0aGlzLkspO1xufTtcblxuSG1hY0RSQkcucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoc2VlZCkge1xuICB2YXIga21hYyA9IHRoaXMuX2htYWMoKVxuICAgICAgICAgICAgICAgICAudXBkYXRlKHRoaXMuVilcbiAgICAgICAgICAgICAgICAgLnVwZGF0ZShbIDB4MDAgXSk7XG4gIGlmIChzZWVkKVxuICAgIGttYWMgPSBrbWFjLnVwZGF0ZShzZWVkKTtcbiAgdGhpcy5LID0ga21hYy5kaWdlc3QoKTtcbiAgdGhpcy5WID0gdGhpcy5faG1hYygpLnVwZGF0ZSh0aGlzLlYpLmRpZ2VzdCgpO1xuICBpZiAoIXNlZWQpXG4gICAgcmV0dXJuO1xuXG4gIHRoaXMuSyA9IHRoaXMuX2htYWMoKVxuICAgICAgICAgICAgICAgLnVwZGF0ZSh0aGlzLlYpXG4gICAgICAgICAgICAgICAudXBkYXRlKFsgMHgwMSBdKVxuICAgICAgICAgICAgICAgLnVwZGF0ZShzZWVkKVxuICAgICAgICAgICAgICAgLmRpZ2VzdCgpO1xuICB0aGlzLlYgPSB0aGlzLl9obWFjKCkudXBkYXRlKHRoaXMuVikuZGlnZXN0KCk7XG59O1xuXG5IbWFjRFJCRy5wcm90b3R5cGUucmVzZWVkID0gZnVuY3Rpb24gcmVzZWVkKGVudHJvcHksIGVudHJvcHlFbmMsIGFkZCwgYWRkRW5jKSB7XG4gIC8vIE9wdGlvbmFsIGVudHJvcHkgZW5jXG4gIGlmICh0eXBlb2YgZW50cm9weUVuYyAhPT0gJ3N0cmluZycpIHtcbiAgICBhZGRFbmMgPSBhZGQ7XG4gICAgYWRkID0gZW50cm9weUVuYztcbiAgICBlbnRyb3B5RW5jID0gbnVsbDtcbiAgfVxuXG4gIGVudHJvcHkgPSB1dGlscy50b0J1ZmZlcihlbnRyb3B5LCBlbnRyb3B5RW5jKTtcbiAgYWRkID0gdXRpbHMudG9CdWZmZXIoYWRkLCBhZGRFbmMpO1xuXG4gIGFzc2VydChlbnRyb3B5Lmxlbmd0aCA+PSAodGhpcy5taW5FbnRyb3B5IC8gOCksXG4gICAgICAgICAnTm90IGVub3VnaCBlbnRyb3B5LiBNaW5pbXVtIGlzOiAnICsgdGhpcy5taW5FbnRyb3B5ICsgJyBiaXRzJyk7XG5cbiAgdGhpcy5fdXBkYXRlKGVudHJvcHkuY29uY2F0KGFkZCB8fCBbXSkpO1xuICB0aGlzLnJlc2VlZCA9IDE7XG59O1xuXG5IbWFjRFJCRy5wcm90b3R5cGUuZ2VuZXJhdGUgPSBmdW5jdGlvbiBnZW5lcmF0ZShsZW4sIGVuYywgYWRkLCBhZGRFbmMpIHtcbiAgaWYgKHRoaXMucmVzZWVkID4gdGhpcy5yZXNlZWRJbnRlcnZhbClcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc2VlZCBpcyByZXF1aXJlZCcpO1xuXG4gIC8vIE9wdGlvbmFsIGVuY29kaW5nXG4gIGlmICh0eXBlb2YgZW5jICE9PSAnc3RyaW5nJykge1xuICAgIGFkZEVuYyA9IGFkZDtcbiAgICBhZGQgPSBlbmM7XG4gICAgZW5jID0gbnVsbDtcbiAgfVxuXG4gIC8vIE9wdGlvbmFsIGFkZGl0aW9uYWwgZGF0YVxuICBpZiAoYWRkKSB7XG4gICAgYWRkID0gdXRpbHMudG9BcnJheShhZGQsIGFkZEVuYyk7XG4gICAgdGhpcy5fdXBkYXRlKGFkZCk7XG4gIH1cblxuICB2YXIgdGVtcCA9IFtdO1xuICB3aGlsZSAodGVtcC5sZW5ndGggPCBsZW4pIHtcbiAgICB0aGlzLlYgPSB0aGlzLl9obWFjKCkudXBkYXRlKHRoaXMuVikuZGlnZXN0KCk7XG4gICAgdGVtcCA9IHRlbXAuY29uY2F0KHRoaXMuVik7XG4gIH1cblxuICB2YXIgcmVzID0gdGVtcC5zbGljZSgwLCBsZW4pO1xuICB0aGlzLl91cGRhdGUoYWRkKTtcbiAgdGhpcy5yZXNlZWQrKztcbiAgcmV0dXJuIHV0aWxzLmVuY29kZShyZXMsIGVuYyk7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRvdWJsZXM6IHtcbiAgICBzdGVwOiA0LFxuICAgIHBvaW50czogW1xuICAgICAgW1xuICAgICAgICAnZTYwZmNlOTNiNTllOWVjNTMwMTFhYWJjMjFjMjNlOTdiMmEzMTM2OWI4N2E1YWU5YzQ0ZWU4OWUyYTZkZWMwYScsXG4gICAgICAgICdmN2UzNTA3Mzk5ZTU5NTkyOWRiOTlmMzRmNTc5MzcxMDEyOTY4OTFlNDRkMjNmMGJlMWYzMmNjZTY5NjE2ODIxJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzgyODIyNjMyMTJjNjA5ZDllYTJhNmUzZTE3MmRlMjM4ZDhjMzljYWJkNWFjMWNhMTA2NDZlMjNmZDVmNTE1MDgnLFxuICAgICAgICAnMTFmOGE4MDk4NTU3ZGZlNDVlODI1NmU4MzBiNjBhY2U2MmQ2MTNhYzJmN2IxN2JlZDMxYjZlYWZmNmUyNmNhZidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcxNzVlMTU5ZjcyOGI4NjVhNzJmOTljYzZjNmZjODQ2ZGUwYjkzODMzZmQyMjIyZWQ3M2ZjZTViNTUxZTViNzM5JyxcbiAgICAgICAgJ2QzNTA2ZTBkOWUzYzc5ZWJhNGVmOTdhNTFmZjcxZjVlYWNiNTk1NWFkZDI0MzQ1YzZlZmE2ZmZlZTlmZWQ2OTUnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMzYzZDkwZDQ0N2IwMGM5Yzk5Y2VhYzA1YjYyNjJlZTA1MzQ0MWM3ZTU1NTUyZmZlNTI2YmFkOGY4M2ZmNDY0MCcsXG4gICAgICAgICc0ZTI3M2FkZmM3MzIyMjE5NTNiNDQ1Mzk3ZjMzNjMxNDViOWE4OTAwODE5OWVjYjYyMDAzYzdmM2JlZTlkZTknXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnOGI0YjVmMTY1ZGYzYzJiZThjNjI0NGI1Yjc0NTYzODg0M2U0YTc4MWExNWJjZDFiNjlmNzlhNTVkZmZkZjgwYycsXG4gICAgICAgICc0YWFkMGE2ZjY4ZDMwOGI0YjNmYmQ3ODEzYWIwZGEwNGY5ZTMzNjU0NjE2MmVlNTZiM2VmZjBjNjVmZDRmZDM2J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzcyM2NiYWE2ZTVkYjk5NmQ2YmY3NzFjMDBiZDU0OGM3YjcwMGRiZmZhNmMwZTc3YmNiNjExNTkyNTIzMmZjZGEnLFxuICAgICAgICAnOTZlODY3YjU1OTVjYzQ5OGE5MjExMzc0ODg4MjRkNmUyNjYwYTA2NTM3Nzk0OTQ4MDFkYzA2OWQ5ZWIzOWY1ZidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlZWJmYTRkNDkzYmViZjk4YmE1ZmVlYzgxMmMyZDNiNTA5NDc5NjEyMzdhOTE5ODM5YTUzM2VjYTBlN2RkN2ZhJyxcbiAgICAgICAgJzVkOWE4Y2EzOTcwZWYwZjI2OWVlN2VkYWYxNzgwODlkOWFlNGNkYzNhNzExZjcxMmRkZmQ0ZmRhZTFkZTg5OTknXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMTAwZjQ0ZGE2OTZlNzE2NzI3OTFkMGEwOWI3YmRlNDU5ZjEyMTVhMjliM2MwM2JmZWZkNzgzNWIzOWE0OGRiMCcsXG4gICAgICAgICdjZGQ5ZTEzMTkyYTAwYjc3MmVjOGYzMzAwYzA5MDY2NmI3ZmY0YTE4ZmY1MTk1YWMwZmJkNWNkNjJiYzY1YTA5J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2UxMDMxYmUyNjJjN2VkMWIxZGM5MjI3YTRhMDRjMDE3YTc3ZjhkNDQ2NGYzYjM4NTJjOGFjZGU2ZTUzNGZkMmQnLFxuICAgICAgICAnOWQ3MDYxOTI4OTQwNDA1ZTZiYjZhNDE3NjU5NzUzNWFmMjkyZGQ0MTllMWNlZDc5YTQ0ZjE4ZjI5NDU2YTAwZCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdmZWVhNmNhZTQ2ZDU1YjUzMGFjMjgzOWYxNDNiZDdlYzVjZjhiMjY2YTQxZDZhZjUyZDVlNjg4ZDkwOTQ2OTZkJyxcbiAgICAgICAgJ2U1N2M2YjZjOTdkY2UxYmFiMDZlNGUxMmJmM2VjZDVjOTgxYzg5NTdjYzQxNDQyZDMxNTVkZWJmMTgwOTAwODgnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZGE2N2E5MWQ5MTA0OWNkY2IzNjdiZTRiZTZmZmNhM2NmZWVkNjU3ZDgwODU4M2RlMzNmYTk3OGJjMWVjNmNiMScsXG4gICAgICAgICc5YmFjYWEzNTQ4MTY0MmJjNDFmNDYzZjdlYzk3ODBlNWRlYzdhZGM1MDhmNzQwYTE3ZTllYThlMjdhNjhiZTFkJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzUzOTA0ZmFhMGIzMzRjZGRhNmUwMDA5MzVlZjIyMTUxZWMwOGQwZjdiYjExMDY5ZjU3NTQ1Y2NjMWEzN2I3YzAnLFxuICAgICAgICAnNWJjMDg3ZDBiYzgwMTA2ZDg4YzllY2NhYzIwZDNjMWMxMzk5OTk4MWUxNDQzNDY5OWRjYjA5NmIwMjI3NzFjOCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc4ZTdiY2QwYmQzNTk4M2E3NzE5Y2NhNzc2NGNhOTA2Nzc5YjUzYTA0M2E5YjhiY2FlZmY5NTlmNDNhZDg2MDQ3JyxcbiAgICAgICAgJzEwYjc3NzBiMmEzZGE0YjM5NDAzMTA0MjBjYTk1MTQ1NzllODhlMmU0N2ZkNjhiM2VhMTAwNDdlODQ2MDM3MmEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMzg1ZWVkMzRjMWNkZmYyMWU2ZDA4MTg2ODliODFiZGU3MWE3ZjRmMTgzOTdlNjY5MGE4NDFlMTU5OWM0Mzg2MicsXG4gICAgICAgICcyODNiZWJjM2U4ZWEyM2Y1NjcwMWRlMTllOWViZjQ1NzZiMzA0ZWVjMjA4NmRjOGNjMDQ1OGZlNTU0MmU1NDUzJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzZmOWQ5YjgwM2VjZjE5MTYzN2M3M2E0NDEzZGZhMTgwZmRkZjg0YTU5NDdmYmM5YzYwNmVkODZjM2ZhYzNhNycsXG4gICAgICAgICc3YzgwYzY4ZTYwMzA1OWJhNjliOGUyYTMwZTQ1YzRkNDdlYTRkZDJmNWMyODEwMDJkODY4OTA2MDNhODQyMTYwJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzMzMjJkNDAxMjQzYzRlMjU4MmEyMTQ3YzEwNGQ2ZWNiZjc3NGQxNjNkYjBmNWU1MzEzYjdlMGU3NDJkMGU2YmQnLFxuICAgICAgICAnNTZlNzA3OTdlOTY2NGVmNWJmYjAxOWJjNGRkYWY5YjcyODA1ZjYzZWEyODczYWY2MjRmM2EyZTk2YzI4YjJhMCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc4NTY3MmM3ZDJkZTBiN2RhMmJkMTc3MGQ4OTY2NTg2ODc0MWIzZjlhZjc2NDMzOTc3MjFkNzRkMjgxMzRhYjgzJyxcbiAgICAgICAgJzdjNDgxYjliNWI0M2IyZWI2Mzc0MDQ5YmZhNjJjMmU1ZTc3ZjE3ZmNjNTI5OGY0NGM4ZTMwOTRmNzkwMzEzYTYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnOTQ4YmY4MDliMTk4OGE0NmIwNmM5ZjE5MTk0MTNiMTBmOTIyNmM2MGY2Njg4MzJmZmQ5NTlhZjYwYzgyYTBhJyxcbiAgICAgICAgJzUzYTU2Mjg1NmRjYjY2NDZkYzZiNzRjNWQxYzM0MThjNmQ0ZGZmMDhjOTdjZDJiZWQ0Y2I3Zjg4ZDhjOGU1ODknXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNjI2MGNlN2Y0NjE4MDFjMzRmMDY3Y2UwZjAyODczYThmMWIwZTQ0ZGZjNjk3NTJhY2NlY2Q4MTlmMzhmZDhlOCcsXG4gICAgICAgICdiYzJkYTgyYjZmYTViNTcxYTdmMDkwNDk3NzZhMWVmN2VjZDI5MjIzODA1MWMxOThjMWE4NGU5NWIyYjRhZTE3J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2U1MDM3ZGUwYWZjMWQ4ZDQzZDgzNDg0MTRiYmY0MTAzMDQzZWM4ZjU3NWJmZGM0MzI5NTNjYzhkMjAzN2ZhMmQnLFxuICAgICAgICAnNDU3MTUzNGJhYTk0ZDNiNWY5Zjk4ZDA5ZmI5OTBiZGRiZDVmNWIwM2VjNDgxZjEwZTBlNWRjODQxZDc1NWJkYSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlMDYzNzJiMGY0YTIwN2FkZjVlYTkwNWU4ZjE3NzFiNGU3ZThkYmQxYzZhNmM1YjcyNTg2NmEwYWU0ZmNlNzI1JyxcbiAgICAgICAgJzdhOTA4OTc0YmNlMThjZmUxMmEyN2JiMmFkNWE0ODhjZDc0ODRhNzc4NzEwNDg3MGIyNzAzNGY5NGVlZTMxZGQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMjEzYzdhNzE1Y2Q1ZDQ1MzU4ZDBiYmY5ZGMwY2UwMjIwNGIxMGJkZGUyYTNmNTg1NDBhZDY5MDhkMDU1OTc1NCcsXG4gICAgICAgICc0YjZkYWQwYjVhZTQ2MjUwNzAxM2FkMDYyNDViYTE5MGJiNDg1MGY1ZjM2YTdlZWRkZmYyYzI3NTM0YjQ1OGYyJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzRlN2MyNzJhN2FmNGIzNGU4ZGJiOTM1MmE1NDE5YTg3ZTI4MzhjNzBhZGM2MmNkZGYwY2MzYTNiMDhmYmQ1M2MnLFxuICAgICAgICAnMTc3NDljNzY2YzlkMGIxOGUxNmZkMDlmNmRlZjY4MWI1MzBiOTYxNGJmZjdkZDMzZTBiMzk0MTgxN2RjYWFlNidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdmZWE3NGUzZGJlNzc4YjFiMTBmMjM4YWQ2MTY4NmFhNWM3NmUzZGIyYmU0MzA1NzYzMjQyN2UyODQwZmIyN2I2JyxcbiAgICAgICAgJzZlMDU2OGRiOWIwYjEzMjk3Y2Y2NzRkZWNjYjZhZjkzMTI2YjU5NmI5NzNmN2I3NzcwMWQzZGI3ZjIzY2I5NmYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNzZlNjQxMTNmNjc3Y2YwZTEwYTI1NzBkNTk5OTY4ZDMxNTQ0ZTE3OWI3NjA0MzI5NTJjMDJhNDQxN2JkZGUzOScsXG4gICAgICAgICdjOTBkZGY4ZGVlNGU5NWNmNTc3MDY2ZDcwNjgxZjBkMzVlMmEzM2QyYjU2ZDIwMzJiNGIxNzUyZDE5MDFhYzAxJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2M3MzhjNTZiMDNiMmFiZTFlODI4MWJhYTc0M2Y4ZjlhOGY3Y2M2NDNkZjI2Y2JlZTNhYjE1MDI0MmJjYmI4OTEnLFxuICAgICAgICAnODkzZmI1Nzg5NTFhZDI1MzdmNzE4ZjJlYWNiZmJiYmI4MjMxNGVlZjc4ODBjZmU5MTdlNzM1ZDk2OTlhODRjMydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkODk1NjI2NTQ4YjY1YjgxZTI2NGM3NjM3Yzk3Mjg3N2QxZDcyZTVmM2E5MjUwMTQzNzJlOWY2NTg4ZjZjMTRiJyxcbiAgICAgICAgJ2ZlYmZhYTM4ZjJiYzdlYWU3MjhlYzYwODE4YzM0MGViMDM0MjhkNjMyYmIwNjdlMTc5MzYzZWQ3NWQ3ZDk5MWYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYjhkYTk0MDMyYTk1NzUxOGViMGY2NDMzNTcxZTg3NjFjZWZmYzczNjkzZTg0ZWRkNDkxNTBhNTY0ZjY3NmUwMycsXG4gICAgICAgICcyODA0ZGZhNDQ4MDVhMWU0ZDdjOTljYzk3NjI4MDhiMDkyY2M1ODRkOTVmZjNiNTExNDg4ZTRlNzRlZmRmNmU3J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2U4MGZlYTE0NDQxZmIzM2E3ZDhhZGFiOTQ3NWQ3ZmFiMjAxOWVmZmI1MTU2YTc5MmYxYTExNzc4ZTNjMGRmNWQnLFxuICAgICAgICAnZWVkMWRlN2Y2MzhlMDA3NzFlODk3NjhjYTNjYTk0NDcyZDE1NWU4MGFmMzIyZWE5ZmNiNDI5MWI2YWM5ZWM3OCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdhMzAxNjk3YmRmY2Q3MDQzMTNiYTQ4ZTUxZDU2NzU0M2YyYTE4MjAzMWVmZDY5MTVkZGMwN2JiY2M0ZTE2MDcwJyxcbiAgICAgICAgJzczNzBmOTFjZmI2N2U0ZjUwODE4MDlmYTI1ZDQwZjliMTczNWRiZjdjMGExMWExMzBjMGQxYTA0MWUxNzdlYTEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnOTBhZDg1YjM4OWQ2YjkzNjQ2M2Y5ZDA1MTI2NzhkZTIwOGNjMzMwYjExMzA3ZmZmYWI3YWM2M2UzZmIwNGVkNCcsXG4gICAgICAgICdlNTA3YTM2MjBhMzgyNjFhZmZkY2JkOTQyNzIyMmI4MzlhZWZhYmUxNTgyODk0ZDk5MWQ0ZDQ4Y2I2ZWYxNTAnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnOGY2OGI5ZDJmNjNiNWYzMzkyMzljMWFkOTgxZjE2MmVlODhjNTY3ODcyM2VhMzM1MWI3YjQ0NGM5ZWM0YzBkYScsXG4gICAgICAgICc2NjJhOWYyZGJhMDYzOTg2ZGUxZDkwYzJiNmJlMjE1ZGJiZWEyY2ZlOTU1MTBiZmRmMjNjYmY3OTUwMWZmZjgyJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2U0ZjNmYjAxNzZhZjg1ZDY1ZmY5OWZmOTE5OGMzNjA5MWY0OGU4NjUwMzY4MWUzZTY2ODZmZDUwNTMyMzFlMTEnLFxuICAgICAgICAnMWU2MzYzM2FkMGVmNGYxYzE2NjFhNmQwZWEwMmI3Mjg2Y2M3ZTc0ZWM5NTFkMWM5ODIyYzM4NTc2ZmViNzNiYydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc4YzAwZmE5YjE4ZWJmMzMxZWI5NjE1MzdhNDVhNDI2NmM3MDM0ZjJmMGQ0ZTFkMDcxNmZiNmVhZTIwZWFlMjllJyxcbiAgICAgICAgJ2VmYTQ3MjY3ZmVhNTIxYTFhOWRjMzQzYTM3MzZjOTc0YzJmYWRhZmE4MWUzNmM1NGU3ZDJhNGM2NjcwMjQxNGInXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZTdhMjZjZTY5ZGQ0ODI5ZjNlMTBjZWMwYTllOThlZDMxNDNkMDg0ZjMwOGI5MmMwOTk3ZmRkZmM2MGNiM2U0MScsXG4gICAgICAgICcyYTc1OGUzMDBmYTc5ODRiNDcxYjAwNmExYWFmYmIxOGQwYTZiMmMwNDIwZTgzZTIwZThhOTQyMWNmMmNmZDUxJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2I2NDU5ZTBlZTM2NjJlYzhkMjM1NDBjMjIzYmNiZGM1NzFjYmNiOTY3ZDc5NDI0ZjNjZjI5ZWIzZGU2YjgwZWYnLFxuICAgICAgICAnNjdjODc2ZDA2ZjNlMDZkZTFkYWRmMTZlNTY2MWRiM2M0YjNhZTZkNDhlMzViMmZmMzBiZjBiNjFhNzFiYTQ1J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2Q2OGE4MGM4MjgwYmI4NDA3OTMyMzRhYTExOGYwNjIzMWQ2ZjFmYzY3ZTczYzVhNWRlZGEwZjViNDk2OTQzZTgnLFxuICAgICAgICAnZGI4YmE5ZmZmNGI1ODZkMDBjNGIxZjkxNzdiMGUyOGI1YjBlN2I4Zjc4NDUyOTVhMjk0Yzg0MjY2YjEzMzEyMCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICczMjRhZWQ3ZGY2NWM4MDQyNTJkYzAyNzA5MDdhMzBiMDk2MTJhZWI5NzM0NDljZWE0MDk1OTgwZmMyOGQzZDVkJyxcbiAgICAgICAgJzY0OGEzNjU3NzRiNjFmMmZmMTMwYzBjMzVhZWMxZjRmMTkyMTNiMGM3ZTMzMjg0Mzk2NzIyNGFmOTZhYjdjODQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNGRmOWMxNDkxOWNkZTYxZjZkNTFkZmRiZTVmZWU1ZGNlZWM0MTQzYmE4ZDFjYTg4OGU4YmQzNzNmZDA1NGM5NicsXG4gICAgICAgICczNWVjNTEwOTJkODcyODA1MDk3NGMyM2ExZDg1ZDRiNWQ1MDZjZGMyODg0OTAxOTJlYmFjMDZjYWQxMGQ1ZCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc5YzM5MTlhODRhNDc0ODcwZmFlZDhhOWMxY2M2NjAyMTUyMzQ4OTA1NGQ3ZjAzMDhjYmZjOTljOGFjMWY5OGNkJyxcbiAgICAgICAgJ2RkYjg0ZjBmNGE0ZGRkNTc1ODRmMDQ0YmYyNjBlNjQxOTA1MzI2Zjc2YzY0YzhlNmJlN2U1ZTAzZDRmYzU5OWQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNjA1NzE3MGIxZGQxMmZkZjhkZTA1ZjI4MWQ4ZTA2YmI5MWUxNDkzYThiOTFkNGNjNWEyMTM4MjEyMGE5NTllNScsXG4gICAgICAgICc5YTFhZjBiMjZhNmE0ODA3YWRkOWEyZGFmNzFkZjI2MjQ2NTE1MmJjM2VlMjRjNjVlODk5YmU5MzIzODVhMmE4J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2E1NzZkZjhlMjNhMDg0MTE0MjE0MzlhNDUxOGRhMzE4ODBjZWYwZmJhN2Q0ZGYxMmIxYTY5NzNlZWNiOTQyNjYnLFxuICAgICAgICAnNDBhNmJmMjBlNzY2NDBiMmM5MmI5N2FmZTU4Y2Q4MmM0MzJlMTBhN2Y1MTRkOWYzZWU4YmUxMWFlMWIyOGVjOCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc3Nzc4YTc4YzI4ZGVjM2UzMGEwNWZlOTYyOWRlOGMzOGJiMzBkMWY1Y2Y5YTNhMjA4Zjc2Mzg4OWJlNThhZDcxJyxcbiAgICAgICAgJzM0NjI2ZDlhYjVhNWIyMmZmNzA5OGUxMmYyZmY1ODAwODdiMzg0MTFmZjI0YWM1NjNiNTEzZmMxZmQ5ZjQzYWMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnOTI4OTU1ZWU2MzdhODQ0NjM3MjlmZDMwZTdhZmQyZWQ1Zjk2Mjc0ZTVhZDdlNWNiMDllZGE5YzA2ZDkwM2FjJyxcbiAgICAgICAgJ2MyNTYyMTAwM2QzZjQyYTgyN2I3OGExMzA5M2E5NWVlYWMzZDI2ZWZhOGE4ZDgzZmM1MTgwZTkzNWJjZDA5MWYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnODVkMGZlZjNlYzZkYjEwOTM5OTA2NGYzYTBlM2IyODU1NjQ1YjRhOTA3YWQzNTQ1MjdhYWU3NTE2M2Q4Mjc1MScsXG4gICAgICAgICcxZjAzNjQ4NDEzYTM4YzBiZTI5ZDQ5NmU1ODJjZjU2NjNlODc1MWU5Njg3NzMzMTU4MmMyMzdhMjRlYjFmOTYyJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2ZmMmIwZGNlOTdlZWNlOTdjMWM5YjYwNDE3OThiODVkZmRmYjZkODg4MmRhMjAzMDhmNTQwNDgyNDUyNjA4N2UnLFxuICAgICAgICAnNDkzZDEzZmVmNTI0YmExODhhZjRjNGRjNTRkMDc5MzZjN2I3ZWQ2ZmI5MGUyY2ViMmM5NTFlMDFmMGMyOTkwNydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc4MjdmYmJlNGIxZTg4MGVhOWVkMmIyZTYzMDFiMjEyYjU3ZjFlZTE0OGNkNmRkMjg3ODBlNWUyY2Y4NTZlMjQxJyxcbiAgICAgICAgJ2M2MGY5YzkyM2M3MjdiMGI3MWJlZjJjNjdkMWQxMjY4N2ZmN2E2MzE4NjkwMzE2NmQ2MDViNjhiYWVjMjkzZWMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZWFhNjQ5ZjIxZjUxYmRiYWU3YmU0YWUzNGNlNmU1MjE3YTU4ZmRjZTdmNDdmOWFhN2YzYjU4ZmEyMTIwZTJiMycsXG4gICAgICAgICdiZTMyNzllZDViYmJiMDNhYzY5YTgwZjg5ODc5YWE1YTAxYTZiOTY1ZjEzZjdlNTlkNDdhNTMwNWJhNWFkOTNkJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2U0YTQyZDQzYzVjZjE2OWQ5MzkxZGY2ZGVjZjQyZWU1NDFiNmQ4ZjBjOWExMzc0MDFlMjM2MzJkZGEzNGQyNGYnLFxuICAgICAgICAnNGQ5ZjkyZTcxNmQxYzczNTI2ZmM5OWNjZmI4YWQzNGNlODg2ZWVkZmE4ZDhlNGYxM2E3ZjcxMzFkZWJhOTQxNCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcxZWM4MGZlZjM2MGNiZGQ5NTQxNjBmYWRhYjM1MmI2YjkyYjUzNTc2YTg4ZmVhNDk0NzE3M2I5ZDQzMDBiZjE5JyxcbiAgICAgICAgJ2FlZWZlOTM3NTZiNTM0MGQyZjNhNDk1OGE3YWJiZjVlMDE0NmU3N2Y2Mjk1YTA3YjY3MWNkYzFjYzEwN2NlZmQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMTQ2YTc3OGMwNDY3MGMyZjkxYjAwYWY0NjgwZGZhOGJjZTM0OTA3MTdkNThiYTg4OWRkYjU5MjgzNjY2NDJiZScsXG4gICAgICAgICdiMzE4ZTBlYzMzNTQwMjhhZGQ2Njk4MjdmOWQ0YjI4NzBhYWE5NzFkMmY3ZTVlZDFkMGIyOTc0ODNkODNlZmQwJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2ZhNTBjMGY2MWQyMmU1ZjA3ZTNhY2ViYjFhYTA3YjEyOGQwMDEyMjA5YTI4Yjk3NzZkNzZhODc5MzE4MGVlZjknLFxuICAgICAgICAnNmI4NGM2OTIyMzk3ZWJhOWI3MmNkMjg3MjI4MWE2OGE1ZTY4MzI5M2E1N2EyMTNiMzhjZDhkN2QzZjRmMjgxMSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkYTFkNjFkMGNhNzIxYTExYjFhNWJmNmI3ZDg4ZTg0MjFhMjg4YWI1ZDViYmE1MjIwZTUzZDMyYjVmMDY3ZWMyJyxcbiAgICAgICAgJzgxNTdmNTVhN2M5OTMwNmM3OWMwNzY2MTYxYzkxZTI5NjZhNzM4OTlkMjc5YjQ4YTY1NWZiYTBmMWFkODM2ZjEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYThlMjgyZmYwYzk3MDY5MDcyMTVmZjk4ZThmZDQxNjYxNTMxMWRlMDQ0NmYxZTA2MmE3M2IwNjEwZDA2NGUxMycsXG4gICAgICAgICc3Zjk3MzU1YjhkYjgxYzA5YWJmYjdmM2M1YjI1MTU4ODhiNjc5YTNlNTBkZDZiZDZjZWY3YzczMTExZjRjYzBjJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzE3NGE1M2I5YzlhMjg1ODcyZDM5ZTU2ZTY5MTNjYWIxNWQ1OWIxZmE1MTI1MDhjMDIyZjM4MmRlODMxOTQ5N2MnLFxuICAgICAgICAnY2NjOWRjMzdhYmZjOWMxNjU3YjQxNTVmMmM0N2Y5ZTY2NDZiM2ExZDhjYjk4NTQzODNkYTEzYWMwNzlhZmE3MydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc5NTkzOTY5ODE5NDM3ODVjM2QzZTU3ZWRmNTAxOGNkYmUwMzllNzMwZTQ5MThiM2Q4ODRmZGZmMDk0NzViN2JhJyxcbiAgICAgICAgJzJlN2U1NTI4ODhjMzMxZGQ4YmEwMzg2YTRiOWNkNjg0OWM2NTNmNjRjODcwOTM4NWU5YjhhYmY4NzUyNGYyZmQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZDJhNjNhNTBhZTQwMWU1NmQ2NDVhMTE1M2IxMDlhOGZjY2EwYTQzZDU2MWZiYTJkYmI1MTM0MGM5ZDgyYjE1MScsXG4gICAgICAgICdlODJkODZmYjY0NDNmY2I3NTY1YWVlNThiMjk0ODIyMGE3MGY3NTBhZjQ4NGNhNTJkNDE0MjE3NGRjZjg5NDA1J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzY0NTg3ZTIzMzU0NzFlYjg5MGVlNzg5NmQ3Y2ZkYzg2NmJhY2JkYmQzODM5MzE3YjM0MzZmOWI0NTYxN2UwNzMnLFxuICAgICAgICAnZDk5ZmNkZDViZjY5MDJlMmFlOTZkZDY0NDdjMjk5YTE4NWI5MGEzOTEzM2FlYWIzNTgyOTllNWU5ZmFmNjU4OSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc4NDgxYmRlMGU0ZTRkODg1YjNhNTQ2ZDNlNTQ5ZGUwNDJmMGFhNmNlYTI1MGU3ZmQzNThkNmM4NmRkNDVlNDU4JyxcbiAgICAgICAgJzM4ZWU3YjhjYmE1NDA0ZGQ4NGEyNWJmMzljZWNiMmNhOTAwYTc5YzQyYjI2MmU1NTZkNjRiMWI1OTc3OTA1N2UnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMTM0NjRhNTdhNzgxMDJhYTYyYjY5NzlhZTgxN2Y0NjM3ZmZjZmVkM2M0YjFjZTMwYmNkNjMwM2Y2Y2FmNjY2YicsXG4gICAgICAgICc2OWJlMTU5MDA0NjE0NTgwZWY3ZTQzMzQ1M2NjYjBjYTQ4ZjMwMGE4MWQwOTQyZTEzZjQ5NWE5MDdmNmVjYzI3J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2JjNGE5ZGY1YjcxM2ZlMmU5YWVmNDMwYmNjMWRjOTdhMGNkOWNjZWRlMmYyODU4OGNhZGEzYTBkMmQ4M2YzNjYnLFxuICAgICAgICAnZDNhODFjYTZlNzg1YzA2MzgzOTM3YWRmNGI3OThjYWE2ZThhOWZiZmE1NDdiMTZkNzU4ZDY2NjU4MWYzM2MxJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzhjMjhhOTdiZjgyOThiYzBkMjNkOGM3NDk0NTJhMzJlNjk0YjY1ZTMwYTk0NzJhMzk1NGFiMzBmZTUzMjRjYWEnLFxuICAgICAgICAnNDBhMzA0NjNhMzMwNTE5MzM3OGZlZGYzMWY3Y2MwZWI3YWU3ODRmMDQ1MWNiOTQ1OWU3MWRjNzNjYmVmOTQ4MidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc4ZWE5NjY2MTM5NTI3YThjMWRkOTRjZTRmMDcxZmQyM2M4YjM1MGM1YTRiYjMzNzQ4YzRiYTExMWZhY2NhZTAnLFxuICAgICAgICAnNjIwZWZhYmJjOGVlMjc4MmUyNGU3YzBjZmI5NWM1ZDczNWI3ODNiZTljZjBmOGU5NTVhZjM0YTMwZTYyYjk0NSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkZDM2MjVmYWVmNWJhMDYwNzQ2Njk3MTZiYmQzNzg4ZDg5YmRkZTgxNTk1OTk2ODA5MmY3NmNjNGViOWE5Nzg3JyxcbiAgICAgICAgJzdhMTg4ZmEzNTIwZTMwZDQ2MWRhMjUwMTA0NTczMWNhOTQxNDYxOTgyODgzMzk1OTM3ZjY4ZDAwYzY0NGE1NzMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZjcxMGQ3OWQ5ZWI5NjIyOTdlNGY2MjMyYjQwZThmN2ZlYjJiYzYzODE0NjE0ZDY5MmMxMmRlNzUyNDA4MjIxZScsXG4gICAgICAgICdlYTk4ZTY3MjMyZDNiMzI5NWQzYjUzNTUzMjExNWNjYWM4NjEyYzcyMTg1MTYxNzUyNmFlNDdhOWM3N2JmYzgyJ1xuICAgICAgXVxuICAgIF1cbiAgfSxcbiAgbmFmOiB7XG4gICAgd25kOiA3LFxuICAgIHBvaW50czogW1xuICAgICAgW1xuICAgICAgICAnZjkzMDhhMDE5MjU4YzMxMDQ5MzQ0Zjg1Zjg5ZDUyMjliNTMxYzg0NTgzNmY5OWIwODYwMWYxMTNiY2UwMzZmOScsXG4gICAgICAgICczODhmN2IwZjYzMmRlODE0MGZlMzM3ZTYyYTM3ZjM1NjY1MDBhOTk5MzRjMjIzMWI2Y2I5ZmQ3NTg0YjhlNjcyJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzJmOGJkZTRkMWEwNzIwOTM1NWI0YTcyNTBhNWM1MTI4ZTg4Yjg0YmRkYzYxOWFiN2NiYThkNTY5YjI0MGVmZTQnLFxuICAgICAgICAnZDhhYzIyMjYzNmU1ZTNkNmQ0ZGJhOWRkYTZjOWM0MjZmNzg4MjcxYmFiMGQ2ODQwZGNhODdkM2FhNmFjNjJkNidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc1Y2JkZjA2NDZlNWRiNGVhYTM5OGYzNjVmMmVhN2EwZTNkNDE5YjdlMDMzMGUzOWNlOTJiZGRlZGNhYzRmOWJjJyxcbiAgICAgICAgJzZhZWJjYTQwYmEyNTU5NjBhMzE3OGQ2ZDg2MWE1NGRiYTgxM2QwYjgxM2ZkZTdiNWE1MDgyNjI4MDg3MjY0ZGEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYWNkNDg0ZTJmMGM3ZjY1MzA5YWQxNzhhOWY1NTlhYmRlMDk3OTY5NzRjNTdlNzE0YzM1ZjExMGRmYzI3Y2NiZScsXG4gICAgICAgICdjYzMzODkyMWIwYTdkOWZkNjQzODA5NzE3NjNiNjFlOWFkZDg4OGE0Mzc1ZjhlMGYwNWNjMjYyYWM2NGY5YzM3J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzc3NGFlN2Y4NThhOTQxMWU1ZWY0MjQ2YjcwYzY1YWFjNTY0OTk4MGJlNWMxNzg5MWJiZWMxNzg5NWRhMDA4Y2InLFxuICAgICAgICAnZDk4NGEwMzJlYjZiNWUxOTAyNDNkZDU2ZDdiN2IzNjUzNzJkYjFlMmRmZjlkNmE4MzAxZDc0YzljOTUzYzYxYidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdmMjg3NzNjMmQ5NzUyODhiYzdkMWQyMDVjMzc0ODY1MWIwNzVmYmM2NjEwZTU4Y2RkZWVkZGY4ZjE5NDA1YWE4JyxcbiAgICAgICAgJ2FiMDkwMmU4ZDg4MGE4OTc1ODIxMmViNjVjZGFmNDczYTFhMDZkYTUyMWZhOTFmMjliNWNiNTJkYjAzZWQ4MSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkNzkyNGQ0ZjdkNDNlYTk2NWE0NjVhZTMwOTVmZjQxMTMxZTU5NDZmM2M4NWY3OWU0NGFkYmNmOGUyN2UwODBlJyxcbiAgICAgICAgJzU4MWUyODcyYTg2YzcyYTY4Mzg0MmVjMjI4Y2M2ZGVmZWE0MGFmMmJkODk2ZDNhNWM1MDRkYzlmZjZhMjZiNTgnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZGVmZGVhNGNkYjY3Nzc1MGE0MjBmZWU4MDdlYWNmMjFlYjk4OThhZTc5Yjk3Njg3NjZlNGZhYTA0YTJkNGEzNCcsXG4gICAgICAgICc0MjExYWIwNjk0NjM1MTY4ZTk5N2IwZWFkMmE5M2RhZWNlZDFmNGEwNGE5NWMwZjZjZmIxOTlmNjllNTZlYjc3J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzJiNGVhMGE3OTdhNDQzZDI5M2VmNWNmZjQ0NGY0OTc5ZjA2YWNmZWJkN2U4NmQyNzc0NzU2NTYxMzgzODViNmMnLFxuICAgICAgICAnODVlODliYzAzNzk0NWQ5M2IzNDMwODNiNWExYzg2MTMxYTAxZjYwYzUwMjY5NzYzYjU3MGM4NTRlNWMwOWI3YSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICczNTJiYmY0YTRjZGQxMjU2NGY5M2ZhMzMyY2UzMzMzMDFkOWFkNDAyNzFmODEwNzE4MTM0MGFlZjI1YmU1OWQ1JyxcbiAgICAgICAgJzMyMWViNDA3NTM0OGY1MzRkNTljMTgyNTlkZGEzZTFmNGExYjNiMmU3MWIxMDM5YzY3YmQzZDhiY2Y4MTk5OGMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMmZhMjEwNGQ2YjM4ZDExYjAyMzAwMTA1NTk4NzkxMjRlNDJhYjhkZmVmZjVmZjI5ZGM5Y2RhZGQ0ZWNhY2MzZicsXG4gICAgICAgICcyZGUxMDY4Mjk1ZGQ4NjViNjQ1NjkzMzViZDVkZDgwMTgxZDcwZWNmYzg4MjY0ODQyM2JhNzZiNTMyYjdkNjcnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnOTI0ODI3OWIwOWI0ZDY4ZGFiMjFhOWIwNjZlZGRhODMyNjNjM2Q4NGUwOTU3MmUyNjljYTBjZDdmNTQ1MzcxNCcsXG4gICAgICAgICc3MzAxNmY3YmYyMzRhYWRlNWQxYWE3MWJkZWEyYjFmZjNmYzBkZTJhODg3OTEyZmZlNTRhMzJjZTk3Y2IzNDAyJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2RhZWQ0ZjJiZTNhOGJmMjc4ZTcwMTMyZmIwYmViNzUyMmY1NzBlMTQ0YmY2MTVjMDdlOTk2ZDQ0M2RlZTg3MjknLFxuICAgICAgICAnYTY5ZGNlNGE3ZDZjOThlOGQ0YTFhY2E4N2VmOGQ3MDAzZjgzYzIzMGYzYWZhNzI2YWI0MGU1MjI5MGJlMWM1NSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdjNDRkMTJjNzA2NWQ4MTJlOGFjZjI4ZDdjYmIxOWY5MDExZWNkOWU5ZmRmMjgxYjBlNmEzYjVlODdkMjJlN2RiJyxcbiAgICAgICAgJzIxMTlhNDYwY2UzMjZjZGM3NmM0NTkyNmM5ODJmZGFjMGUxMDZlODYxZWRmNjFjNWEwMzkwNjNmMGUwZTY0ODInXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNmEyNDViZjZkYzY5ODUwNGM4OWEyMGNmZGVkNjA4NTMxNTJiNjk1MzM2YzI4MDYzYjYxYzY1Y2JkMjY5ZTZiNCcsXG4gICAgICAgICdlMDIyY2Y0MmMyYmQ0YTcwOGIzZjUxMjZmMTZhMjRhZDhiMzNiYTQ4ZDA0MjNiNmVmZDVlNjM0ODEwMGQ4YTgyJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzE2OTdmZmE2ZmQ5ZGU2MjdjMDc3ZTNkMmZlNTQxMDg0Y2UxMzMwMGIwYmVjMTE0NmY5NWFlNTdmMGQwYmQ2YTUnLFxuICAgICAgICAnYjljMzk4ZjE4NjgwNmY1ZDI3NTYxNTA2ZTQ1NTc0MzNhMmNmMTUwMDllNDk4YWU3YWRlZTlkNjNkMDFiMjM5NidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc2MDViZGIwMTk5ODE3MThiOTg2ZDBmMDdlODM0Y2IwZDlkZWI4MzYwZmZiN2Y2MWRmOTgyMzQ1ZWYyN2E3NDc5JyxcbiAgICAgICAgJzI5NzJkMmRlNGY4ZDIwNjgxYTc4ZDkzZWM5NmZlMjNjMjZiZmFlODRmYjE0ZGI0M2IwMWUxZTkwNTZiOGM0OSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc2MmQxNGRhYjQxNTBiZjQ5NzQwMmZkYzQ1YTIxNWUxMGRjYjAxYzM1NDk1OWIxMGNmZTMxYzdlOWQ4N2ZmMzNkJyxcbiAgICAgICAgJzgwZmMwNmJkOGNjNWIwMTA5ODA4OGExOTUwZWVkMGRiMDFhYTEzMjk2N2FiNDcyMjM1ZjU2NDI0ODNiMjVlYWYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnODBjNjBhZDAwNDBmMjdkYWRlNWI0YjA2YzQwOGU1NmIyYzUwZTlmNTZiOWI4YjQyNWU1NTVjMmY4NjMwOGI2ZicsXG4gICAgICAgICcxYzM4MzAzZjFjYzVjMzBmMjZlNjZiYWQ3ZmU3MmY3MGE2NWVlZDRjYmU3MDI0ZWIxYWEwMWY1NjQzMGJkNTdhJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzdhOTM3NWFkNjE2N2FkNTRhYTc0YzYzNDhjYzU0ZDM0NGNjNWRjOTQ4N2Q4NDcwNDlkNWVhYmIwZmEwM2M4ZmInLFxuICAgICAgICAnZDBlM2ZhOWVjYTg3MjY5MDk1NTllMGQ3OTI2OTA0NmJkYzU5ZWExMGM3MGNlMmIwMmQ0OTllYzIyNGRjN2Y3J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2Q1MjhlY2Q5YjY5NmI1NGM5MDdhOWVkMDQ1NDQ3YTc5YmI0MDhlYzM5YjY4ZGY1MDRiYjUxZjQ1OWJjM2ZmYzknLFxuICAgICAgICAnZWVjZjQxMjUzMTM2ZTVmOTk5NjZmMjE4ODFmZDY1NmViYzQzNDU0MDVjNTIwZGJjMDYzNDY1YjUyMTQwOTkzMydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc0OTM3MGE0YjVmNDM0MTJlYTI1ZjUxNGU4ZWNkYWQwNTI2NjExNWU0YTdlY2IxMzg3MjMxODA4ZjhiNDU5NjMnLFxuICAgICAgICAnNzU4ZjNmNDFhZmQ2ZWQ0MjhiMzA4MWIwNTEyZmQ2MmE1NGMzZjNhZmJiNWI2NzY0YjY1MzA1MmExMjk0OWM5YSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc3N2YyMzA5MzZlZTg4Y2JiZDczZGY5MzBkNjQ3MDJlZjg4MWQ4MTFlMGUxNDk4ZTJmMWMxM2ViMWZjMzQ1ZDc0JyxcbiAgICAgICAgJzk1OGVmNDJhNzg4NmI2NDAwYTA4MjY2ZTliYTFiMzc4OTZjOTUzMzBkOTcwNzdjYmJlOGViM2M3NjcxYzYwZDYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZjJkYWM5OTFjYzRjZTRiOWVhNDQ4ODdlNWM3YzBiY2U1OGM4MDA3NGFiOWQ0ZGJhZWIyODUzMWI3NzM5ZjUzMCcsXG4gICAgICAgICdlMGRlZGM5YjNiMmY4ZGFkNGRhMWYzMmRlYzI1MzFkZjllYjVmYmViMDU5OGU0ZmQxYTExN2RiYTcwM2EzYzM3J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzQ2M2IzZDlmNjYyNjIxZmIxYjRiZThmYmJlMjUyMDEyNWEyMTZjZGZjOWRhZTNkZWJjYmE0ODUwYzY5MGQ0NWInLFxuICAgICAgICAnNWVkNDMwZDc4YzI5NmMzNTQzMTE0MzA2ZGQ4NjIyZDdjNjIyZTI3Yzk3MGExZGUzMWNiMzc3YjAxYWY3MzA3ZSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdmMTZmODA0MjQ0ZTQ2ZTJhMDkyMzJkNGFmZjNiNTk5NzZiOThmYWMxNDMyOGEyZDFhMzI0OTZiNDk5OThmMjQ3JyxcbiAgICAgICAgJ2NlZGFiZDliODIyMDNmN2UxM2QyMDZmY2RmNGUzM2Q5MmE2YzUzYzI2ZTVjY2UyNmQ2NTc5OTYyYzRlMzFkZjYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnY2FmNzU0MjcyZGM4NDU2M2IwMzUyYjdhMTQzMTFhZjU1ZDI0NTMxNWFjZTI3YzY1MzY5ZTE1ZjcxNTFkNDFkMScsXG4gICAgICAgICdjYjQ3NDY2MGVmMzVmNWYyYTQxYjY0M2ZhNWU0NjA1NzVmNGZhOWI3OTYyMjMyYTVjMzJmOTA4MzE4YTA0NDc2J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzI2MDBjYTRiMjgyY2I5ODZmODVkMGYxNzA5OTc5ZDhiNDRhMDljMDdjYjg2ZDdjMTI0NDk3YmM4NmYwODIxMjAnLFxuICAgICAgICAnNDExOWI4ODc1M2MxNWJkNmE2OTNiMDNmY2RkYmI0NWQ1YWM2YmU3NGFiNWYwZWY0NGIwYmU5NDc1YTdlNGI0MCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc3NjM1Y2E3MmQ3ZTg0MzJjMzM4ZWM1M2NkMTIyMjBiYzAxYzQ4Njg1ZTI0ZjdkYzhjNjAyYTc3NDY5OThlNDM1JyxcbiAgICAgICAgJzkxYjY0OTYwOTQ4OWQ2MTNkMWQ1ZTU5MGY3OGU2ZDc0ZWNmYzA2MWQ1NzA0OGJhZDllNzZmMzAyYzViOWM2MSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc3NTRlMzIzOWYzMjU1NzBjZGJiZjRhODdkZWVlOGE2NmI3ZjJiMzM0NzlkNDY4ZmJjMWE1MDc0M2JmNTZjYzE4JyxcbiAgICAgICAgJzY3M2ZiODZlNWJkYTMwZmIzY2QwZWQzMDRlYTQ5YTAyM2VlMzNkMDE5N2E2OTVkMGM1ZDk4MDkzYzUzNjY4MydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlM2U2YmQxMDcxYTFlOTZhZmY1Nzg1OWM4MmQ1NzBmMDMzMDgwMDY2MWQxYzk1MmY5ZmUyNjk0NjkxZDliOWU4JyxcbiAgICAgICAgJzU5YzllMGJiYTM5NGU3NmY0MGMwYWE1ODM3OWEzY2I2YTVhMjI4Mzk5M2U5MGM0MTY3MDAyYWY0OTIwZTM3ZjUnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMTg2YjQ4M2QwNTZhMDMzODI2YWU3M2Q4OGY3MzI5ODVjNGNjYjFmMzJiYTM1ZjRiNGNjNDdmZGNmMDRhYTZlYicsXG4gICAgICAgICczYjk1MmQzMmM2N2NmNzdlMmUxNzQ0NmUyMDQxODBhYjIxZmI4MDkwODk1MTM4YjRhNGE3OTdmODZlODA4ODhiJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2RmOWQ3MGE2Yjk4NzZjZTU0NGM5ODU2MWY0YmU0ZjcyNTQ0MmU2ZDJiNzM3ZDljOTFhODMyMTcyNGNlMDk2M2YnLFxuICAgICAgICAnNTVlYjJkYWZkODRkNmNjZDVmODYyYjc4NWRjMzlkNGFiMTU3MjIyNzIwZWY5ZGEyMTdiOGM0NWNmMmJhMjQxNydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc1ZWRkNWNjMjNjNTFlODdhNDk3Y2E4MTVkNWRjZTBmOGFiNTI1NTRmODQ5ZWQ4OTk1ZGU2NGM1ZjM0Y2U3MTQzJyxcbiAgICAgICAgJ2VmYWU5YzhkYmMxNDEzMDY2MWU4Y2VjMDMwYzg5YWQwYzEzYzY2YzBkMTdhMjkwNWNkYzcwNmFiNzM5OWE4NjgnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMjkwNzk4YzJiNjQ3NjgzMGRhMTJmZTAyMjg3ZTllNzc3YWEzZmJhMWMzNTViMTdhNzIyZDM2MmY4NDYxNGZiYScsXG4gICAgICAgICdlMzhkYTc2ZGNkNDQwNjIxOTg4ZDAwYmNmNzlhZjI1ZDViMjljMDk0ZGIyYTIzMTQ2ZDAwM2FmZDQxOTQzZTdhJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2FmM2M0MjNhOTVkOWY1YjMwNTQ3NTRlZmExNTBhYzM5Y2QyOTU1MmZlMzYwMjU3MzYyZGZkZWNlZjQwNTNiNDUnLFxuICAgICAgICAnZjk4YTNmZDgzMWViMmI3NDlhOTNiMGU2ZjM1Y2ZiNDBjOGNkNWFhNjY3YTE1NTgxYmMyZmVkZWQ0OThmZDljNidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc3NjZkYmIyNGQxMzRlNzQ1Y2NjYWEyOGM5OWJmMjc0OTA2YmI2NmIyNmRjZjk4ZGY4ZDJmZWQ1MGQ4ODQyNDlhJyxcbiAgICAgICAgJzc0NGIxMTUyZWFjYmU1ZTM4ZGNjODg3OTgwZGEzOGI4OTc1ODRhNjVmYTA2Y2VkZDJjOTI0Zjk3Y2JhYzU5OTYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNTlkYmY0NmY4Yzk0NzU5YmEyMTI3N2MzMzc4NGY0MTY0NWY3YjQ0ZjZjNTk2YTU4Y2U5MmU2NjYxOTFhYmUzZScsXG4gICAgICAgICdjNTM0YWQ0NDE3NWZiYzMwMGY0ZWE2Y2U2NDgzMDlhMDQyY2U3MzlhNzkxOTc5OGNkODVlMjE2YzRhMzA3ZjZlJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2YxM2FkYTk1MTAzYzQ1MzczMDVlNjkxZTc0ZTlhNGE4ZGQ2NDdlNzExYTk1ZTczY2I2MmRjNjAxOGNmZDg3YjgnLFxuICAgICAgICAnZTEzODE3YjQ0ZWUxNGRlNjYzYmY0YmM4MDgzNDFmMzI2OTQ5ZTIxYTZhNzVjMjU3MDc3ODQxOWJkYWY1NzMzZCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc3NzU0YjRmYTBlOGFjZWQwNmQ0MTY3YTJjNTljY2E0Y2RhMTg2OWMwNmViYWRmYjY0ODg1NTAwMTVhODg1MjJjJyxcbiAgICAgICAgJzMwZTkzZTg2NGU2NjlkODIyMjRiOTY3YzMwMjBiOGZhOGQxZTRlMzUwYjZjYmNjNTM3YTQ4YjU3ODQxMTYzYTInXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnOTQ4ZGNhZGY1OTkwZTA0OGFhMzg3NGQ0NmFiZWY5ZDcwMTg1OGY5NWRlODA0MWQyYTY4MjhjOTllMjI2MjUxOScsXG4gICAgICAgICdlNDkxYTQyNTM3ZjZlNTk3ZDVkMjhhMzIyNGIxYmMyNWRmOTE1NGVmYmQyZWYxZDJjYmJhMmNhZTUzNDdkNTdlJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzc5NjI0MTQ0NTBjNzZjMTY4OWM3YjQ4ZjgyMDJlYzM3ZmIyMjRjZjVhYzBiZmExNTcwMzI4YThhM2Q3Yzc3YWInLFxuICAgICAgICAnMTAwYjYxMGVjNGZmYjQ3NjBkNWMxZmMxMzNlZjZmNmIxMjUwN2EwNTFmMDRhYzU3NjBhZmE1YjI5ZGI4MzQzNydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICczNTE0MDg3ODM0OTY0YjU0YjE1YjE2MDY0NGQ5MTU0ODVhMTY5NzcyMjViODg0N2JiMGRkMDg1MTM3ZWM0N2NhJyxcbiAgICAgICAgJ2VmMGFmYmIyMDU2MjA1NDQ4ZTE2NTJjNDhlODEyN2ZjNjAzOWU3N2MxNWMyMzc4YjdlN2QxNWEwZGUyOTMzMTEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZDNjYzMwYWQ2YjQ4M2U0YmM3OWNlMmM5ZGQ4YmM1NDk5M2U5NDdlYjhkZjc4N2I0NDI5NDNkM2Y3YjUyN2VhZicsXG4gICAgICAgICc4YjM3OGEyMmQ4MjcyNzhkODljNWU5YmU4Zjk1MDhhZTNjMmFkNDYyOTAzNTg2MzBhZmIzNGRiMDRlZWRlMGE0J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzE2MjRkODQ3ODA3MzI4NjBjZTFjNzhmY2JmZWZlMDhiMmIyOTgyM2RiOTEzZjY0OTM5NzViYTBmZjQ4NDc2MTAnLFxuICAgICAgICAnNjg2NTFjZjliNmRhOTAzZTA5MTQ0NDhjNmNkOWQ0Y2E4OTY4NzhmNTI4MmJlNGM4Y2MwNmUyYTQwNDA3ODU3NSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc3MzNjZTgwZGE5NTVhOGEyNjkwMmM5NTYzM2U2MmE5ODUxOTI0NzRiNWFmMjA3ZGE2ZGY3YjRmZDVmYzYxY2Q0JyxcbiAgICAgICAgJ2Y1NDM1YTJiZDJiYWRmN2Q0ODVhNGQ4YjhkYjlmY2NlM2UxZWY4ZTAyMDFlNDU3OGM1NDY3M2JjMWRjNWVhMWQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMTVkOTQ0MTI1NDk0NTA2NGNmMWExYzMzYmJkM2I0OWY4OTY2YzUwOTIxNzFlNjk5ZWYyNThkZmFiODFjMDQ1YycsXG4gICAgICAgICdkNTZlYjMwYjY5NDYzZTcyMzRmNTEzN2I3M2I4NDE3NzQzNDgwMGJhY2ViZmM2ODVmYzM3YmJlOWVmZTQwNzBkJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2ExZDBmY2YyZWM5ZGU2NzViNjEyMTM2ZTVjZTcwZDI3MWMyMTQxN2M5ZDJiOGFhYWFjMTM4NTk5ZDA3MTc5NDAnLFxuICAgICAgICAnZWRkNzdmNTBiY2I1YTNjYWIyZTkwNzM3MzA5NjY3ZjI2NDE0NjJhNTQwNzBmM2Q1MTkyMTJkMzljMTk3YTYyOSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlMjJmYmUxNWMwYWY4Y2NjNTc4MGMwNzM1Zjg0ZGJlOWE3OTBiYWRlZTgyNDVjMDZjN2NhMzczMzFjYjM2OTgwJyxcbiAgICAgICAgJ2E4NTViYWJhZDVjZDYwYzg4YjQzMGE2OWY1M2ExYTdhMzgyODkxNTQ5NjQ3OTliZTQzZDA2ZDc3ZDMxZGEwNidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICczMTEwOTFkZDk4NjBlOGUyMGVlMTM0NzNjMTE1NWY1ZjY5NjM1ZTM5NDcwNGVhYTc0MDA5NDUyMjQ2Y2ZhOWIzJyxcbiAgICAgICAgJzY2ZGI2NTZmODdkMWYwNGZmZmQxZjA0Nzg4YzA2ODMwODcxZWM1YTY0ZmVlZTY4NWJkODBmMGIxMjg2ZDgzNzQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMzRjMWZkMDRkMzAxYmU4OWIzMWMwNDQyZDNlNmFjMjQ4ODM5MjhiNDVhOTM0MDc4MTg2N2Q0MjMyZWMyZGJkZicsXG4gICAgICAgICc5NDE0Njg1ZTk3YjFiNTk1NGJkNDZmNzMwMTc0MTM2ZDU3ZjFjZWViNDg3NDQzZGM1MzIxODU3YmE3M2FiZWUnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZjIxOWVhNWQ2YjU0NzAxYzFjMTRkZTViNTU3ZWI0MmE4ZDEzZjNhYmJjZDA4YWZmY2MyYTVlNmIwNDliOGQ2MycsXG4gICAgICAgICc0Y2I5NTk1N2U4M2Q0MGIwZjczYWY0NTQ0Y2NjZjZiMWY0YjA4ZDNjMDdiMjdmYjhkOGMyOTYyYTQwMDc2NmQxJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2Q3Yjg3NDBmNzRhOGZiYWFiMWY2ODNkYjhmNDVkZTI2NTQzYTU0OTBiY2E2MjcwODcyMzY5MTI0NjlhMGI0NDgnLFxuICAgICAgICAnZmE3Nzk2ODEyOGQ5YzkyZWUxMDEwZjMzN2FkNDcxN2VmZjE1ZGI1ZWQzYzA0OWIzNDExZTAzMTVlYWE0NTkzYidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICczMmQzMWMyMjJmOGY2ZjBlZjg2ZjdjOThkM2EzMzM1ZWFkNWJjZDMyYWJkZDk0Mjg5ZmU0ZDMwOTFhYTgyNGJmJyxcbiAgICAgICAgJzVmMzAzMmY1ODkyMTU2ZTM5Y2NkM2Q3OTE1YjllMWRhMmU2ZGFjOWU2ZjI2ZTk2MTExOGQxNGI4NDYyZTE2NjEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNzQ2MWYzNzE5MTRhYjMyNjcxMDQ1YTE1NWQ5ODMxZWE4NzkzZDc3Y2Q1OTU5MmM0MzQwZjg2Y2JjMTgzNDdiNScsXG4gICAgICAgICc4ZWMwYmEyMzhiOTZiZWMwY2JkZGRjYWUwYWE0NDI1NDJlZWUxZmY1MGM5ODZlYTZiMzk4NDdiM2NjMDkyZmY2J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2VlMDc5YWRiMWRmMTg2MDA3NDM1NmEyNWFhMzgyMDZhNmQ3MTZiMmMzZTY3NDUzZDI4NzY5OGJhZDdiMmIyZDYnLFxuICAgICAgICAnOGRjMjQxMmFhZmUzYmU1YzRjNWYzN2UwZWNjNWY5ZjZhNDQ2OTg5YWYwNGM0ZTI1ZWJhYWM0NzllYzFjOGMxZSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcxNmVjOTNlNDQ3ZWM4M2YwNDY3YjE4MzAyZWU2MjBmN2U2NWRlMzMxODc0YzlkYzcyYmZkODYxNmJhOWRhNmI1JyxcbiAgICAgICAgJzVlNDYzMTE1MGU2MmZiNDBkMGU4YzJhN2NhNTgwNGEzOWQ1ODE4NmE1MGU0OTcxMzk2MjY3NzhlMjViMDY3NGQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZWFhNWY5ODBjMjQ1ZjZmMDM4OTc4MjkwYWZhNzBiNmJkODg1NTg5N2Y5OGI2YWE0ODViOTYwNjVkNTM3YmQ5OScsXG4gICAgICAgICdmNjVmNWQzZTI5MmMyZTA4MTlhNTI4MzkxYzk5NDYyNGQ3ODQ4NjlkN2U2ZWE2N2ZiMTgwNDEwMjRlZGMwN2RjJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzc4Yzk0MDc1NDRhYzEzMjY5MmVlMTkxMGEwMjQzOTk1OGFlMDQ4NzcxNTEzNDJlYTk2YzRiNmIzNWE0OWY1MScsXG4gICAgICAgICdmM2UwMzE5MTY5ZWI5Yjg1ZDU0MDQ3OTU1MzlhNWU2OGZhMWZiZDU4M2MwNjRkMjQ2MmI2NzVmMTk0YTNkZGI0J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzQ5NGY0YmUyMTlhMWE3NzAxNmRjZDgzODQzMWFlYTAwMDFjZGM4YWU3YTZmYzY4ODcyNjU3OGQ5NzAyODU3YTUnLFxuICAgICAgICAnNDIyNDJhOTY5MjgzYTVmMzM5YmE3ZjA3NWUzNmJhMmFmOTI1Y2UzMGQ3NjdlZDZlNTVmNGIwMzE4ODBkNTYyYydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdhNTk4YTgwMzBkYTZkODZjNmJjN2YyZjUxNDRlYTU0OWQyODIxMWVhNThmYWE3MGViZjRjMWU2NjVjMWZlOWI1JyxcbiAgICAgICAgJzIwNGI1ZDZmODQ4MjJjMzA3ZTRiNGE3MTQwNzM3YWVjMjNmYzYzYjY1YjM1Zjg2YTEwMDI2ZGJkMmQ4NjRlNmInXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYzQxOTE2MzY1YWJiMmI1ZDA5MTkyZjVmMmRiZWFmZWMyMDhmMDIwZjEyNTcwYTE4NGRiYWRjM2U1ODU5NTk5NycsXG4gICAgICAgICc0ZjE0MzUxZDAwODdlZmE0OWQyNDViMzI4OTg0OTg5ZDVjYWY5NDUwZjM0YmZjMGVkMTZlOTZiNThmYTk5MTMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnODQxZDYwNjNhNTg2ZmE0NzVhNzI0NjA0ZGEwM2JjNWI5MmEyZTBkMmUwYTM2YWNmZTRjNzNhNTUxNDc0Mjg4MScsXG4gICAgICAgICc3Mzg2N2Y1OWMwNjU5ZTgxOTA0ZjlhMWM3NTQzNjk4ZTYyNTYyZDY3NDRjMTY5Y2U3YTM2ZGUwMWE4ZDYxNTQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNWU5NWJiMzk5YTY5NzFkMzc2MDI2OTQ3Zjg5YmRlMmYyODJiMzM4MTA5MjhiZTRkZWQxMTJhYzRkNzBlMjBkNScsXG4gICAgICAgICczOWYyM2YzNjY4MDkwODViZWViZmM3MTE4MTMxMzc3NWE5OWM5YWVkN2Q4YmEzOGIxNjEzODRjNzQ2MDEyODY1J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzM2ZTQ2NDFhNTM5NDhmZDQ3NmMzOWY4YTk5ZmQ5NzRlNWVjMDc1NjRiNTMxNWQ4YmY5OTQ3MWJjYTBlZjJmNjYnLFxuICAgICAgICAnZDI0MjRiMWIxYWJlNGViODE2NDIyN2IwODVjOWFhOTQ1NmVhMTM0OTNmZDU2M2UwNmZkNTFjZjU2OTRjNzhmYydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICczMzY1ODFlYTdiZmJiYjI5MGMxOTFhMmY1MDdhNDFjZjU2NDM4NDIxNzBlOTE0ZmFlYWIyN2MyYzU3OWY3MjYnLFxuICAgICAgICAnZWFkMTIxNjg1OTVmZTFiZTk5MjUyMTI5YjZlNTZiMzM5MWY3YWIxNDEwY2QxZTBlZjNkY2RjYWJkMmZkYTIyNCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc4YWI4OTgxNmRhZGZkNmI2YTFmMjYzNGZjZjAwZWM4NDAzNzgxMDI1ZWQ2ODkwYzQ4NDk3NDI3MDZiZDQzZWRlJyxcbiAgICAgICAgJzZmZGNlZjA5ZjJmNmQwYTA0NGU2NTRhZWY2MjQxMzZmNTAzZDQ1OWMzZTg5ODQ1ODU4YTQ3YTkxMjljZGQyNGUnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMWUzM2YxYTc0NmM5YzU3NzgxMzMzNDRkOTI5OWZjYWEyMGIwOTM4ZThhY2ZmMjU0NGJiNDAyODRiOGM1ZmI5NCcsXG4gICAgICAgICc2MDY2MDI1N2RkMTFiM2FhOWM4ZWQ2MThkMjRlZGZmMjMwNmQzMjBmMWQwMzAxMGUzM2E3ZDIwNTdmM2IzYjYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnODViN2MxZGNiM2NlYzFiN2VlN2YzMGRlZDc5ZGQyMGEwZWQxZjRjYzE4Y2JjZmNmYTQxMDM2MWZkOGYwOGYzMScsXG4gICAgICAgICczZDk4YTljZGQwMjZkZDQzZjM5MDQ4ZjI1YTg4NDdmNGZjYWZhZDE4OTVkN2E2MzNjNmZlZDNjMzVlOTk5NTExJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzI5ZGY5ZmJkOGQ5ZTQ2NTA5Mjc1ZjRiMTI1ZDZkNDVkN2ZiZTlhM2I4NzhhN2FmODcyYTI4MDA2NjFhYzVmNTEnLFxuICAgICAgICAnYjRjNGZlOTljNzc1YTYwNmUyZDg4NjIxNzkxMzlmZmRhNjFkYzg2MWMwMTllNTVjZDI4NzZlYjJhMjdkODRiJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2EwYjFjYWUwNmIwYTg0N2EzZmVhNmU2NzFhYWY4YWRmZGZlNThjYTJmNzY4MTA1YzgwODJiMmU0NDlmY2UyNTInLFxuICAgICAgICAnYWU0MzQxMDJlZGRlMDk1OGVjNGIxOWQ5MTdhNmEyOGU2YjcyZGExODM0YWZmMGU2NTBmMDQ5NTAzYTI5NmNmMidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc0ZThjZWFmYjliM2U5YTEzNmRjN2ZmNjdlODQwMjk1YjQ5OWRmYjNiMjEzM2U0YmExMTNmMmU0YzBlMTIxZTUnLFxuICAgICAgICAnY2YyMTc0MTE4YzhiNmQ3YTRiNDhmNmQ1MzRjZTVjNzk0MjJjMDg2YTYzNDYwNTAyYjgyN2NlNjJhMzI2NjgzYydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkMjRhNDRlMDQ3ZTE5YjZmNWFmYjgxYzdjYTJmNjkwODBhNTA3NjY4OWEwMTA5MTlmNDI3MjVjMmI3ODlhMzNiJyxcbiAgICAgICAgJzZmYjhkNTU5MWI0NjZmOGZjNjNkYjUwZjFjMGYxYzY5MDEzZjk5Njg4N2I4MjQ0ZDJjZGVjNDE3YWZlYThmYTMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZWEwMTYwNmE3YTZjOWNkZDI0OWZkZmNmYWNiOTk1ODQwMDFlZGQyOGFiYmFiNzdiNTEwNGU5OGU4ZTNiMzVkNCcsXG4gICAgICAgICczMjJhZjQ5MDhjNzMxMmIwY2ZiZmUzNjlmN2E3YjNjZGI3ZDQ0OTRiYzI4MjM3MDBjZmQ2NTIxODhhM2VhOThkJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2FmOGFkZGJmMmI2NjFjOGE2YzYzMjg2NTVlYjk2NjUxMjUyMDA3ZDhjNWVhMzFiZTRhZDE5NmRlOGNlMjEzMWYnLFxuICAgICAgICAnNjc0OWU2N2MwMjliODVmNTJhMDM0ZWFmZDA5NjgzNmIyNTIwODE4NjgwZTI2YWM4ZjNkZmJjZGI3MTc0OTcwMCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlM2FlMTk3NDU2NmNhMDZjYzUxNmQ0N2UwZmIxNjVhNjc0YTNkYWJjZmNhMTVlNzIyZjBlMzQ1MGY0NTg4OScsXG4gICAgICAgICcyYWVhYmU3ZTQ1MzE1MTAxMTYyMTdmMDdiZjRkMDczMDBkZTk3ZTQ4NzRmODFmNTMzNDIwYTcyZWViMGJkNmE0J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzU5MWVlMzU1MzEzZDk5NzIxY2Y2OTkzZmZlZDFlM2UzMDE5OTNmZjNlZDI1ODgwMjA3NWVhOGNlZDM5N2UyNDYnLFxuICAgICAgICAnYjBlYTU1OGExMTNjMzBiZWE2MGZjNDc3NTQ2MGM3OTAxZmYwYjA1M2QyNWNhMmJkZWVlOThmMWE0YmU1ZDE5NidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcxMTM5NmQ1NWZkYTU0YzQ5ZjE5YWE5NzMxOGQ4ZGE2MWZhODU4NGU0N2IwODQ5NDUwNzdjZjAzMjU1YjUyOTg0JyxcbiAgICAgICAgJzk5OGM3NGE4Y2Q0NWFjMDEyODlkNTgzM2E3YmViNDc0NGZmNTM2YjAxYjI1N2JlNGM1NzY3YmVhOTNlYTU3YTQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnM2M1ZDJhMWJhMzljNWExNzkwMDAwNzM4YzllMGM0MGI4ZGNkZmQ1NDY4NzU0YjY0MDU1NDAxNTdlMDE3YWE3YScsXG4gICAgICAgICdiMjI4NDI3OTk5NWEzNGUyZjlkNGRlNzM5NmZjMThiODBmOWI4YjlmZGQyNzBmNjY2MWY3OWNhNGM4MWJkMjU3J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2NjODcwNGI4YTYwYTBkZWZhM2E5OWE3Mjk5ZjJlOWMzZmJjMzk1YWZiMDRhYzA3ODQyNWVmOGExNzkzY2MwMzAnLFxuICAgICAgICAnYmRkNDYwMzlmZWVkMTc4ODFkMWUwODYyZGIzNDdmOGNmMzk1Yjc0ZmM0YmNkYzRlOTQwYjc0ZTNhYzFmMWIxMydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdjNTMzZTRmN2VhODU1NWFhY2Q5Nzc3YWM1Y2FkMjliOTdkZDRkZWZjY2M1M2VlN2VhMjA0MTE5YjI4ODliMTk3JyxcbiAgICAgICAgJzZmMGEyNTZiYzVlZmRmNDI5YTJmYjYyNDJmMWE0M2EyZDliOTI1YmI0YTRiM2EyNmJiOGUwZjQ1ZWI1OTYwOTYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYzE0ZjhmMmNjYjI3ZDZmMTA5ZjZkMDhkMDNjYzk2YTY5YmE4YzM0ZWVjMDdiYmNmNTY2ZDQ4ZTMzZGE2NTkzJyxcbiAgICAgICAgJ2MzNTlkNjkyM2JiMzk4ZjdmZDQ0NzNlMTZmZTFjMjg0NzViNzQwZGQwOTgwNzVlNmMwZTg2NDkxMTNkYzNhMzgnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYTZjYmMzMDQ2YmM2YTQ1MGJhYzI0Nzg5ZmExNzExNWE0Yzk3MzllZDc1ZjhmMjFjZTQ0MWY3MmUwYjkwZTZlZicsXG4gICAgICAgICcyMWFlN2Y0NjgwZTg4OWJiMTMwNjE5ZTJjMGY5NWEzNjBjZWI1NzNjNzA2MDMxMzk4NjJhZmQ2MTdmYTliOWYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMzQ3ZDZkOWEwMmM0ODkyN2ViZmI4NmMxMzU5YjFjYWYxMzBhM2MwMjY3ZDExY2U2MzQ0YjM5Zjk5ZDQzY2MzOCcsXG4gICAgICAgICc2MGVhN2Y2MWEzNTM1MjRkMWM5ODdmNmVjZWM5MmYwODZkNTY1YWI2ODc4NzBjYjEyNjg5ZmYxZTMxYzc0NDQ4J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2RhNjU0NWQyMTgxZGI4ZDk4M2Y3ZGNiMzc1ZWY1ODY2ZDQ3YzY3YjFiZjMxYzhjZjg1NWVmNzQzN2I3MjY1NmEnLFxuICAgICAgICAnNDliOTY3MTVhYjY4NzhhNzllNzhmMDdjZTU2ODBjNWQ2NjczMDUxYjQ5MzViZDg5N2ZlYTgyNGI3N2RjMjA4YSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdjNDA3NDdjYzlkMDEyY2IxYTEzYjgxNDgzMDljNmRlN2VjMjVkNjk0NWQ2NTcxNDZiOWQ1OTk0YjhmZWIxMTExJyxcbiAgICAgICAgJzVjYTU2MDc1M2JlMmExMmZjNmRlNmNhZjJjYjQ4OTU2NWRiOTM2MTU2Yjk1MTRlMWJiNWU4MzAzN2UwZmEyZDQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNGU0MmM4ZWM4MmM5OTc5OGNjZjNhNjEwYmU4NzBlNzgzMzhjN2Y3MTMzNDhiZDM0YzgyMDNlZjQwMzdmMzUwMicsXG4gICAgICAgICc3NTcxZDc0ZWU1ZTBmYjkyYTdhOGIzM2EwNzc4MzM0MWE1NDkyMTQ0Y2M1NGJjYzQwYTk0NDczNjkzNjA2NDM3J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzM3NzVhYjcwODliYzZhZjgyM2FiYTJlMWFmNzBiMjM2ZDI1MWNhZGIwYzg2NzQzMjg3NTIyYTFiM2IwZGVkZWEnLFxuICAgICAgICAnYmU1MmQxMDdiY2ZhMDlkOGJjYjk3MzZhODI4Y2ZhN2ZhYzhkYjE3YmY3YTc2YTJjNDJhZDk2MTQwOTAxOGNmNydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdjZWUzMWNiZjdlMzRlYzM3OWQ5NGZiODE0ZDNkNzc1YWQ5NTQ1OTVkMTMxNGJhODg0Njk1OWUzZTgyZjc0ZTI2JyxcbiAgICAgICAgJzhmZDY0YTE0YzA2YjU4OWMyNmI5NDdhZTJiY2Y2YmZhMDE0OWVmMGJlMTRlZDRkODBmNDQ4YTAxYzQzYjFjNmQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYjRmOWVhZWEwOWI2OTE3NjE5ZjZlYTZhNGViNTQ2NGVmZGRiNThmZDQ1YjFlYmVmY2RjMWEwMWQwOGI0Nzk4NicsXG4gICAgICAgICczOWU1Yzk5MjViNWE1NGIwNzQzM2E0ZjE4YzYxNzI2ZjhiYjEzMWMwMTJjYTU0MmViMjRhOGFjMDcyMDA2ODJhJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2Q0MjYzZGZjM2QyZGY5MjNhMDE3OWE0ODk2NmQzMGNlODRlMjUxNWFmYzNkY2NjMWI3NzkwNzc5MmViY2M2MGUnLFxuICAgICAgICAnNjJkZmFmMDdhMGY3OGZlYjMwZTMwZDYyOTU4NTNjZTE4OWUxMjc3NjBhZDZjZjdmYWUxNjRlMTIyYTIwOGQ1NCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc0ODQ1NzUyNDgyMGZhNjVhNGY4ZDM1ZWI2OTMwODU3YzAwMzJhY2MwYTRhMmRlNDIyMjMzZWVkYTg5NzYxMmM0JyxcbiAgICAgICAgJzI1YTc0OGFiMzY3OTc5ZDk4NzMzYzM4YTFmYTFjMmU3ZGM2Y2MwN2RiMmQ2MGE5YWU3YTc2YWFhNDliZDBmNzcnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZGZlZWVmMTg4MTEwMWYyY2IxMTY0NGYzYTJhZmRmYzIwNDVlMTk5MTkxNTI5MjNmMzY3YTE3NjdjMTFjY2VkYScsXG4gICAgICAgICdlY2ZiNzA1NmNmMWRlMDQyZjk0MjBiYWIzOTY3OTNjMGMzOTBiZGU3NGI0YmJkZmYxNmE4M2FlMDlhOWE3NTE3J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzZkN2VmNmIxNzU0M2Y4MzczYzU3M2Y0NGUxZjM4OTgzNWQ4OWJjYmM2MDYyY2VkMzZjODJkZjgzYjhmYWU4NTknLFxuICAgICAgICAnY2Q0NTBlYzMzNTQzODk4NmRmZWZhMTBjNTdmZWE5YmNjNTIxYTA5NTliMmQ4MGJiZjc0YjE5MGRjYTcxMmQxMCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlNzU2MDVkNTkxMDJhNWEyNjg0NTAwZDNiOTkxZjJlM2YzYzg4YjkzMjI1NTQ3MDM1YWYyNWFmNjZlMDQ1NDFmJyxcbiAgICAgICAgJ2Y1YzU0NzU0YThmNzFlZTU0MGI5YjQ4NzI4NDczZTMxNGY3MjlhYzUzMDhiMDY5MzgzNjA5OTBlMmJmYWQxMjUnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZWI5ODY2MGY0YzRkZmFhMDZhMmJlNDUzZDUwMjBiYzk5YTBjMmU2MGFiZTM4ODQ1N2RkNDNmZWZiMWVkNjIwYycsXG4gICAgICAgICc2Y2I5YTg4NzZkOWNiODUyMDYwOWFmM2FkZDI2Y2QyMGEwYTdjZDhhOTQxMTEzMWNlODVmNDQxMDAwOTkyMjNlJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzEzZTg3YjAyN2Q4NTE0ZDM1OTM5ZjJlNjg5MmIxOTkyMjE1NDU5Njk0MTg4ODMzNmRjMzU2M2UzYjhkYmE5NDInLFxuICAgICAgICAnZmVmNWEzYzY4MDU5YTZkZWM1ZDYyNDExNGJmMWU5MWFhYzJiOWRhNTY4ZDZhYmViMjU3MGQ1NTY0NmI4YWRmMSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlZTE2MzAyNmU5ZmQ2ZmUwMTdjMzhmMDZhNWJlNmZjMTI1NDI0YjM3MWNlMjcwOGU3YmY0NDkxNjkxZTU3NjRhJyxcbiAgICAgICAgJzFhY2IyNTBmMjU1ZGQ2MWM0M2Q5NGNjYzY3MGQwZjU4ZjQ5YWUzZmExNWI5NjYyM2U1NDMwZGEwYWQ2YzYyYjInXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYjI2OGY1ZWY5YWQ1MWU0ZDc4ZGUzYTc1MGMyZGM4OWIxZTYyNmQ0MzUwNTg2Nzk5OTkzMmU1ZGIzM2FmM2Q4MCcsXG4gICAgICAgICc1ZjMxMGQ0YjNjOTliOWViYjE5Zjc3ZDQxYzFkZWUwMThjZjBkMzRmZDQxOTE2MTQwMDNlOTQ1YTEyMTZlNDIzJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2ZmMDdmMzExOGE5ZGYwMzVlOWZhZDg1ZWI2YzdiZmU0MmIwMmYwMWNhOTljZWVhM2JmN2ZmZGJhOTNjNDc1MGQnLFxuICAgICAgICAnNDM4MTM2ZDYwM2U4NThhM2E1YzQ0MGMzOGVjY2JhZGRjMWQyOTQyMTE0ZTJlZGRkNDc0MGQwOThjZWQxZjBkOCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc4ZDhiOTg1NWM3YzA1MmEzNDE0NmZkMjBmZmI2NThiZWE0YjlmNjllMGQ4MjVlYmVjMTZlOGMzY2UyYjUyNmExJyxcbiAgICAgICAgJ2NkYjU1OWVlZGMyZDc5ZjkyNmJhZjQ0ZmI4NGVhNGQ0NGJjZjUwZmVlNTFkN2NlYjMwZTJlN2Y0NjMwMzY3NTgnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNTJkYjBiNTM4NGRmYmYwNWJmYTlkNDcyZDdhZTI2ZGZlNGI4NTFjZWNhOTFiMWViYTU0MjYzMTgwZGEzMmI2MycsXG4gICAgICAgICdjM2I5OTdkMDUwZWU1ZDQyM2ViYWY2NmE2ZGI5ZjU3YjMxODBjOTAyODc1Njc5ZGU5MjRiNjlkODRhN2IzNzUnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZTYyZjk0OTBkM2Q1MWRhNjM5NWVmZDI0ZTgwOTE5Y2M3ZDBmMjljM2YzZmE0OGM2ZmZmNTQzYmVjYmQ0MzM1MicsXG4gICAgICAgICc2ZDg5YWQ3YmE0ODc2YjBiMjJjMmNhMjgwYzY4Mjg2MmYzNDJjODU5MWYxZGFmNTE3MGUwN2JmZDljY2FmYTdkJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzdmMzBlYTI0NzZiMzk5YjQ5NTc1MDljODhmNzdkMDE5MWFmYTJmZjVjYjdiMTRmZDZkOGU3ZDY1YWFhYjExOTMnLFxuICAgICAgICAnY2E1ZWY3ZDRiMjMxYzk0YzNiMTUzODlhNWY2MzExZTlkYWZmN2JiNjdiMTAzZTk4ODBlZjRiZmY2MzdhY2FlYydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc1MDk4ZmYxZTFkOWYxNGZiNDZhMjEwZmFkYTZjOTAzZmVmMGZiN2I0YTFkZDFkOWFjNjBhMDM2MTgwMGI3YTAwJyxcbiAgICAgICAgJzk3MzExNDFkODFmYzhmODA4NGQzN2M2ZTc1NDIwMDZiM2VlMWI0MGQ2MGRmZTUzNjJhNWIxMzJmZDE3ZGRjMCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICczMmI3OGM3ZGU5ZWU1MTJhNzI4OTViZTZiOWNiZWZhNmUyZjNjNGNjY2U0NDVjOTZiOWYyYzgxZTI3NzhhZDU4JyxcbiAgICAgICAgJ2VlMTg0OWY1MTNkZjcxZTMyZWZjMzg5NmVlMjgyNjBjNzNiYjgwNTQ3YWUyMjc1YmE0OTcyMzc3OTRjODc1M2MnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZTJjYjc0ZmRkYzhlOWZiY2QwNzZlZWYyYTdjNzJiMGNlMzdkNTBmMDgyNjlkZmMwNzRiNTgxNTUwNTQ3YTRmNycsXG4gICAgICAgICdkM2FhMmVkNzFjOWRkMjI0N2E2MmRmMDYyNzM2ZWIwYmFkZGVhOWUzNjEyMmQyYmU4NjQxYWJjYjAwNWNjNGE0J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzg0Mzg0NDc1NjZkNGQ3YmVkYWRjMjk5NDk2YWIzNTc0MjYwMDlhMzVmMjM1Y2IxNDFiZTBkOTljZDEwYWUzYTgnLFxuICAgICAgICAnYzRlMTAyMDkxNjk4MGE0ZGE1ZDAxYWM1ZTZhZDMzMDczNGVmMGQ3OTA2NjMxYzRmMjM5MDQyNmIyZWRkNzkxZidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc0MTYyZDQ4OGI4OTQwMjAzOWI1ODRjNmZjNmMzMDg4NzA1ODdkOWM0NmY2NjBiODc4YWI2NWM4MmM3MTFkNjdlJyxcbiAgICAgICAgJzY3MTYzZTkwMzIzNjI4OWY3NzZmMjJjMjVmYjhhM2FmYzE3MzJmMmI4NGI0ZTk1ZGJkYTQ3YWU1YTA4NTI2NDknXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnM2ZhZDNmYTg0Y2FmMGYzNGYwZjg5YmZkMmRjZjU0ZmMxNzVkNzY3YWVjM2U1MDY4NGYzYmE0YTRiZjVmNjgzZCcsXG4gICAgICAgICdjZDFiYzdjYjZjYzQwN2JiMmYwY2E2NDdjNzE4YTczMGNmNzE4NzJlN2QwZDJhNTNmYTIwZWZjZGZlNjE4MjYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNjc0ZjI2MDBhMzAwN2EwMDU2OGMxYTdjZTA1ZDA4MTZjMWZiODRiZjEzNzA3OThmMWM2OTUzMmZhZWIxYTg2YicsXG4gICAgICAgICcyOTlkMjFmOTQxM2YzM2IzZWRmNDNiMjU3MDA0NTgwYjcwZGI1N2RhMGIxODIyNTllMDllZWNjNjllMGQzOGE1J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2QzMmY0ZGE1NGFkZTc0YWJiODFiODE1YWQxZmIzYjI2M2Q4MmQ2YzY5MjcxNGJjZmY4N2QyOWJkNWVlOWYwOGYnLFxuICAgICAgICAnZjk0MjllNzM4YjhlNTNiOTY4ZTk5MDE2YzA1OTcwNzc4MmUxNGY0NTM1MzU5ZDU4MmZjNDE2OTEwYjNlZWE4NydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICczMGU0ZTY3MDQzNTM4NTU1NmU1OTM2NTcxMzU4NDVkMzZmYmI2OTMxZjcyYjA4Y2IxZWQ5NTRmMWUzY2UzZmY2JyxcbiAgICAgICAgJzQ2MmY5YmNlNjE5ODk4NjM4NDk5MzUwMTEzYmJjOWIxMGE4NzhkMzVkYTcwNzQwZGM2OTVhNTU5ZWI4OGRiN2InXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYmUyMDYyMDAzYzUxY2MzMDA0NjgyOTA0MzMwZTRkZWU3ZjNkY2QxMGIwMWU1ODBiZjE5NzFiMDRkNGNhZDI5NycsXG4gICAgICAgICc2MjE4OGJjNDlkNjFlNTQyODU3M2Q0OGE3NGUxYzY1NWIxYzYxMDkwOTA1NjgyYTBkNTU1OGVkNzJkY2NiOWJjJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzkzMTQ0NDIzYWNlMzQ1MWVkMjllMGZiOWFjMmFmMjExY2I2ZTg0YTYwMWRmNTk5M2M0MTk4NTlmZmY1ZGYwNGEnLFxuICAgICAgICAnN2MxMGRmYjE2NGMzNDI1ZjVjNzFhM2Y5ZDc5OTIwMzhmMTA2NTIyNGY3MmJiOWQxZDkwMmE2ZDEzMDM3YjQ3YydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdiMDE1ZjgwNDRmNWZjYmRjZjIxY2EyNmQ2YzM0ZmI4MTk3ODI5MjA1YzdiN2QyYTdjYjY2NDE4YzE1N2IxMTJjJyxcbiAgICAgICAgJ2FiOGMxZTA4NmQwNGU4MTM3NDRhNjU1YjJkZjhkNWY4M2IzY2RjNmZhYTMwODhjMWQzYWVhMTQ1NGUzYTFkNWYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZDVlOWUxZGE2NDlkOTdkODllNDg2ODExN2E0NjVhM2E0ZjhhMThkZTU3YTE0MGQzNmIzZjJhZjM0MWEyMWI1MicsXG4gICAgICAgICc0Y2IwNDQzN2YzOTFlZDczMTExYTEzY2MxZDRkZDBkYjE2OTM0NjVjMjI0MDQ4MGQ4OTU1ZTg1OTJmMjc0NDdhJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2QzYWU0MTA0N2RkN2NhMDY1ZGJmOGVkNzdiOTkyNDM5OTgzMDA1Y2Q3MmUxNmQ2Zjk5NmE1MzE2ZDM2OTY2YmInLFxuICAgICAgICAnYmQxYWViMjFhZDIyZWJiMjJhMTBmMDMwMzQxN2M2ZDk2NGY4Y2RkN2RmMGFjYTYxNGIxMGRjMTRkMTI1YWM0NidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc0NjNlMjc2M2Q4ODVmOTU4ZmM2NmNkZDIyODAwZjBhNDg3MTk3ZDBhODJlMzc3YjQ5ZjgwYWY4N2M4OTdiMDY1JyxcbiAgICAgICAgJ2JmZWZhY2RiMGU1ZDBmZDdkZjNhMzExYTk0ZGUwNjJiMjZiODBjNjFmYmM5NzUwOGI3OTk5MjY3MWVmN2NhN2YnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNzk4NWZkZmQxMjdjMDU2N2M2ZjUzZWMxYmI2M2VjMzE1OGU1OTdjNDBiZmU3NDdjODNjZGRmYzkxMDY0MTkxNycsXG4gICAgICAgICc2MDNjMTJkYWYzZDk4NjJlZjJiMjVmZTFkZTI4OWFlZDI0ZWQyOTFlMGVjNjcwODcwM2E1YmQ1NjdmMzJlZDAzJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzc0YTFhZDZiNWY3NmUzOWRiMmRkMjQ5NDEwZWFjN2Y5OWU3NGM1OWNiODNkMmQwZWQ1ZmYxNTQzZGE3NzAzZTknLFxuICAgICAgICAnY2M2MTU3ZWYxOGM5YzYzY2Q2MTkzZDgzNjMxYmJlYTAwOTNlMDk2ODk0MmU4YzMzZDU3MzdmZDc5MGUwZGIwOCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICczMDY4MmE1MDcwMzM3NWY2MDJkNDE2NjY0YmExOWI3ZmM5YmFiNDJjNzI3NDc0NjNhNzFkMDg5NmIyMmY2ZGEzJyxcbiAgICAgICAgJzU1M2UwNGY2YjAxOGI0ZmE2YzhmMzllN2YzMTFkMzE3NjI5MGQwZTBmMTljYTczZjE3NzE0ZDk5NzdhMjJmZjgnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnOWUyMTU4ZjBkN2MwZDVmMjZjMzc5MWVmZWZhNzk1OTc2NTRlN2EyYjI0NjRmNTJiMWVlNmMxMzQ3NzY5ZWY1NycsXG4gICAgICAgICc3MTJmY2RkMWI5MDUzZjA5MDAzYTM0ODFmYTc3NjJlOWZmZDdjOGVmMzVhMzg1MDllMmZiZjI2MjkwMDgzNzMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMTc2ZTI2OTg5YTQzYzljZmViYTQwMjljMjAyNTM4YzI4MTcyZTU2NmUzYzRmY2U3MzIyODU3ZjNiZTMyN2Q2NicsXG4gICAgICAgICdlZDhjYzlkMDRiMjllYjg3N2QyNzBiNDg3OGRjNDNjMTlhZWZkMzFmNGVlZTA5ZWU3YjQ3ODM0YzFmYTRiMWMzJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzc1ZDQ2ZWZlYTM3NzFlNmU2OGFiYjg5YTEzYWQ3NDdlY2YxODkyMzkzZGZjNGYxYjcwMDQ3ODhjNTAzNzRkYTgnLFxuICAgICAgICAnOTg1MjM5MGE5OTUwNzY3OWZkMGI4NmZkMmIzOWE4NjhkN2VmYzIyMTUxMzQ2ZTFhM2NhNDcyNjU4NmE2YmVkOCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc4MDlhMjBjNjdkNjQ5MDBmZmI2OThjNGM4MjVmNmQ1ZjIzMTBmYjA0NTFjODY5MzQ1YjczMTlmNjQ1NjA1NzIxJyxcbiAgICAgICAgJzllOTk0OTgwZDk5MTdlMjJiNzZiMDYxOTI3ZmEwNDE0M2QwOTZjY2M1NDk2M2U2YTVlYmZhNWYzZjhlMjg2YzEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMWIzODkwM2E0M2Y3ZjExNGVkNDUwMGI0ZWFjNzA4M2ZkZWZlY2UxY2YyOWM2MzUyOGQ1NjM0NDZmOTcyYzE4MCcsXG4gICAgICAgICc0MDM2ZWRjOTMxYTYwYWU4ODkzNTNmNzdmZDUzZGU0YTI3MDhiMjZiNmY1ZGE3MmFkMzM5NDExOWRhZjQwOGY5J1xuICAgICAgXVxuICAgIF1cbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gZXhwb3J0cztcbnZhciBibiA9IHJlcXVpcmUoJ2JuLmpzJyk7XG5cbnV0aWxzLmFzc2VydCA9IGZ1bmN0aW9uIGFzc2VydCh2YWwsIG1zZykge1xuICBpZiAoIXZhbClcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnIHx8ICdBc3NlcnRpb24gZmFpbGVkJyk7XG59O1xuXG5mdW5jdGlvbiB0b0FycmF5KG1zZywgZW5jKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KG1zZykpXG4gICAgcmV0dXJuIG1zZy5zbGljZSgpO1xuICBpZiAoIW1zZylcbiAgICByZXR1cm4gW107XG4gIHZhciByZXMgPSBbXTtcbiAgaWYgKHR5cGVvZiBtc2cgIT09ICdzdHJpbmcnKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpKyspXG4gICAgICByZXNbaV0gPSBtc2dbaV0gfCAwO1xuICAgIHJldHVybiByZXM7XG4gIH1cbiAgaWYgKCFlbmMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGMgPSBtc2cuY2hhckNvZGVBdChpKTtcbiAgICAgIHZhciBoaSA9IGMgPj4gODtcbiAgICAgIHZhciBsbyA9IGMgJiAweGZmO1xuICAgICAgaWYgKGhpKVxuICAgICAgICByZXMucHVzaChoaSwgbG8pO1xuICAgICAgZWxzZVxuICAgICAgICByZXMucHVzaChsbyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGVuYyA9PT0gJ2hleCcpIHtcbiAgICBtc2cgPSBtc2cucmVwbGFjZSgvW15hLXowLTldKy9pZywgJycpO1xuICAgIGlmIChtc2cubGVuZ3RoICUgMiAhPT0gMClcbiAgICAgIG1zZyA9ICcwJyArIG1zZztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkgKz0gMilcbiAgICAgIHJlcy5wdXNoKHBhcnNlSW50KG1zZ1tpXSArIG1zZ1tpICsgMV0sIDE2KSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cbnV0aWxzLnRvQXJyYXkgPSB0b0FycmF5O1xuXG5mdW5jdGlvbiB6ZXJvMih3b3JkKSB7XG4gIGlmICh3b3JkLmxlbmd0aCA9PT0gMSlcbiAgICByZXR1cm4gJzAnICsgd29yZDtcbiAgZWxzZVxuICAgIHJldHVybiB3b3JkO1xufVxudXRpbHMuemVybzIgPSB6ZXJvMjtcblxuZnVuY3Rpb24gdG9IZXgobXNnKSB7XG4gIHZhciByZXMgPSAnJztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpKyspXG4gICAgcmVzICs9IHplcm8yKG1zZ1tpXS50b1N0cmluZygxNikpO1xuICByZXR1cm4gcmVzO1xufVxudXRpbHMudG9IZXggPSB0b0hleDtcblxudXRpbHMuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKGFyciwgZW5jKSB7XG4gIGlmIChlbmMgPT09ICdoZXgnKVxuICAgIHJldHVybiB0b0hleChhcnIpO1xuICBlbHNlXG4gICAgcmV0dXJuIGFycjtcbn07XG5cbi8vIFJlcHJlc2VudCBudW0gaW4gYSB3LU5BRiBmb3JtXG5mdW5jdGlvbiBnZXROQUYobnVtLCB3KSB7XG4gIHZhciBuYWYgPSBbXTtcbiAgdmFyIHdzID0gMSA8PCAodyArIDEpO1xuICB2YXIgayA9IG51bS5jbG9uZSgpO1xuICB3aGlsZSAoay5jbXBuKDEpID49IDApIHtcbiAgICB2YXIgejtcbiAgICBpZiAoay5pc09kZCgpKSB7XG4gICAgICB2YXIgbW9kID0gay5hbmRsbih3cyAtIDEpO1xuICAgICAgaWYgKG1vZCA+ICh3cyA+PiAxKSAtIDEpXG4gICAgICAgIHogPSAod3MgPj4gMSkgLSBtb2Q7XG4gICAgICBlbHNlXG4gICAgICAgIHogPSBtb2Q7XG4gICAgICBrLmlzdWJuKHopO1xuICAgIH0gZWxzZSB7XG4gICAgICB6ID0gMDtcbiAgICB9XG4gICAgbmFmLnB1c2goeik7XG5cbiAgICAvLyBPcHRpbWl6YXRpb24sIHNoaWZ0IGJ5IHdvcmQgaWYgcG9zc2libGVcbiAgICB2YXIgc2hpZnQgPSAoay5jbXBuKDApICE9PSAwICYmIGsuYW5kbG4od3MgLSAxKSA9PT0gMCkgPyAodyArIDEpIDogMTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHNoaWZ0OyBpKyspXG4gICAgICBuYWYucHVzaCgwKTtcbiAgICBrLml1c2hybihzaGlmdCk7XG4gIH1cblxuICByZXR1cm4gbmFmO1xufVxudXRpbHMuZ2V0TkFGID0gZ2V0TkFGO1xuXG4vLyBSZXByZXNlbnQgazEsIGsyIGluIGEgSm9pbnQgU3BhcnNlIEZvcm1cbmZ1bmN0aW9uIGdldEpTRihrMSwgazIpIHtcbiAgdmFyIGpzZiA9IFtcbiAgICBbXSxcbiAgICBbXVxuICBdO1xuXG4gIGsxID0gazEuY2xvbmUoKTtcbiAgazIgPSBrMi5jbG9uZSgpO1xuICB2YXIgZDEgPSAwO1xuICB2YXIgZDIgPSAwO1xuICB3aGlsZSAoazEuY21wbigtZDEpID4gMCB8fCBrMi5jbXBuKC1kMikgPiAwKSB7XG5cbiAgICAvLyBGaXJzdCBwaGFzZVxuICAgIHZhciBtMTQgPSAoazEuYW5kbG4oMykgKyBkMSkgJiAzO1xuICAgIHZhciBtMjQgPSAoazIuYW5kbG4oMykgKyBkMikgJiAzO1xuICAgIGlmIChtMTQgPT09IDMpXG4gICAgICBtMTQgPSAtMTtcbiAgICBpZiAobTI0ID09PSAzKVxuICAgICAgbTI0ID0gLTE7XG4gICAgdmFyIHUxO1xuICAgIGlmICgobTE0ICYgMSkgPT09IDApIHtcbiAgICAgIHUxID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG04ID0gKGsxLmFuZGxuKDcpICsgZDEpICYgNztcbiAgICAgIGlmICgobTggPT09IDMgfHwgbTggPT09IDUpICYmIG0yNCA9PT0gMilcbiAgICAgICAgdTEgPSAtbTE0O1xuICAgICAgZWxzZVxuICAgICAgICB1MSA9IG0xNDtcbiAgICB9XG4gICAganNmWzBdLnB1c2godTEpO1xuXG4gICAgdmFyIHUyO1xuICAgIGlmICgobTI0ICYgMSkgPT09IDApIHtcbiAgICAgIHUyID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG04ID0gKGsyLmFuZGxuKDcpICsgZDIpICYgNztcbiAgICAgIGlmICgobTggPT09IDMgfHwgbTggPT09IDUpICYmIG0xNCA9PT0gMilcbiAgICAgICAgdTIgPSAtbTI0O1xuICAgICAgZWxzZVxuICAgICAgICB1MiA9IG0yNDtcbiAgICB9XG4gICAganNmWzFdLnB1c2godTIpO1xuXG4gICAgLy8gU2Vjb25kIHBoYXNlXG4gICAgaWYgKDIgKiBkMSA9PT0gdTEgKyAxKVxuICAgICAgZDEgPSAxIC0gZDE7XG4gICAgaWYgKDIgKiBkMiA9PT0gdTIgKyAxKVxuICAgICAgZDIgPSAxIC0gZDI7XG4gICAgazEuaXVzaHJuKDEpO1xuICAgIGsyLml1c2hybigxKTtcbiAgfVxuXG4gIHJldHVybiBqc2Y7XG59XG51dGlscy5nZXRKU0YgPSBnZXRKU0Y7XG5cbmZ1bmN0aW9uIGNhY2hlZFByb3BlcnR5KG9iaiwgY29tcHV0ZXIpIHtcbiAgdmFyIG5hbWUgPSBjb21wdXRlci5uYW1lO1xuICB2YXIga2V5ID0gJ18nICsgbmFtZTtcbiAgb2JqLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uIGNhY2hlZFByb3BlcnR5KCkge1xuICAgIHJldHVybiB0aGlzW2tleV0gIT09IHVuZGVmaW5lZCA/IHRoaXNba2V5XSA6XG4gICAgICAgICAgIHRoaXNba2V5XSA9IGNvbXB1dGVyLmNhbGwodGhpcyk7XG4gIH07XG59XG51dGlscy5jYWNoZWRQcm9wZXJ0eSA9IGNhY2hlZFByb3BlcnR5O1xuXG5mdW5jdGlvbiBwYXJzZUJ5dGVzKGJ5dGVzKSB7XG4gIHJldHVybiB0eXBlb2YgYnl0ZXMgPT09ICdzdHJpbmcnID8gdXRpbHMudG9BcnJheShieXRlcywgJ2hleCcpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBieXRlcztcbn1cbnV0aWxzLnBhcnNlQnl0ZXMgPSBwYXJzZUJ5dGVzO1xuXG5mdW5jdGlvbiBpbnRGcm9tTEUoYnl0ZXMpIHtcbiAgcmV0dXJuIG5ldyBibihieXRlcywgJ2hleCcsICdsZScpO1xufVxudXRpbHMuaW50RnJvbUxFID0gaW50RnJvbUxFO1xuXG4iLCJ2YXIgcjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiByYW5kKGxlbikge1xuICBpZiAoIXIpXG4gICAgciA9IG5ldyBSYW5kKG51bGwpO1xuXG4gIHJldHVybiByLmdlbmVyYXRlKGxlbik7XG59O1xuXG5mdW5jdGlvbiBSYW5kKHJhbmQpIHtcbiAgdGhpcy5yYW5kID0gcmFuZDtcbn1cbm1vZHVsZS5leHBvcnRzLlJhbmQgPSBSYW5kO1xuXG5SYW5kLnByb3RvdHlwZS5nZW5lcmF0ZSA9IGZ1bmN0aW9uIGdlbmVyYXRlKGxlbikge1xuICByZXR1cm4gdGhpcy5fcmFuZChsZW4pO1xufTtcblxuaWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnKSB7XG4gIGlmICh3aW5kb3cuY3J5cHRvICYmIHdpbmRvdy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgLy8gTW9kZXJuIGJyb3dzZXJzXG4gICAgUmFuZC5wcm90b3R5cGUuX3JhbmQgPSBmdW5jdGlvbiBfcmFuZChuKSB7XG4gICAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkobik7XG4gICAgICB3aW5kb3cuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhhcnIpO1xuICAgICAgcmV0dXJuIGFycjtcbiAgICB9O1xuICB9IGVsc2UgaWYgKHdpbmRvdy5tc0NyeXB0byAmJiB3aW5kb3cubXNDcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgLy8gSUVcbiAgICBSYW5kLnByb3RvdHlwZS5fcmFuZCA9IGZ1bmN0aW9uIF9yYW5kKG4pIHtcbiAgICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheShuKTtcbiAgICAgIHdpbmRvdy5tc0NyeXB0by5nZXRSYW5kb21WYWx1ZXMoYXJyKTtcbiAgICAgIHJldHVybiBhcnI7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICAvLyBPbGQganVua1xuICAgIFJhbmQucHJvdG90eXBlLl9yYW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCB5ZXQnKTtcbiAgICB9O1xuICB9XG59IGVsc2Uge1xuICAvLyBOb2RlLmpzIG9yIFdlYiB3b3JrZXJcbiAgdHJ5IHtcbiAgICB2YXIgY3J5cHRvID0gcmVxdWlyZSgnY3J5JyArICdwdG8nKTtcblxuICAgIFJhbmQucHJvdG90eXBlLl9yYW5kID0gZnVuY3Rpb24gX3JhbmQobikge1xuICAgICAgcmV0dXJuIGNyeXB0by5yYW5kb21CeXRlcyhuKTtcbiAgICB9O1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gRW11bGF0ZSBjcnlwdG8gQVBJIHVzaW5nIHJhbmR5XG4gICAgUmFuZC5wcm90b3R5cGUuX3JhbmQgPSBmdW5jdGlvbiBfcmFuZChuKSB7XG4gICAgICB2YXIgcmVzID0gbmV3IFVpbnQ4QXJyYXkobik7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgcmVzW2ldID0gdGhpcy5yYW5kLmdldEJ5dGUoKTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgfVxufVxuIiwidmFyIGhhc2ggPSBleHBvcnRzO1xuXG5oYXNoLnV0aWxzID0gcmVxdWlyZSgnLi9oYXNoL3V0aWxzJyk7XG5oYXNoLmNvbW1vbiA9IHJlcXVpcmUoJy4vaGFzaC9jb21tb24nKTtcbmhhc2guc2hhID0gcmVxdWlyZSgnLi9oYXNoL3NoYScpO1xuaGFzaC5yaXBlbWQgPSByZXF1aXJlKCcuL2hhc2gvcmlwZW1kJyk7XG5oYXNoLmhtYWMgPSByZXF1aXJlKCcuL2hhc2gvaG1hYycpO1xuXG4vLyBQcm94eSBoYXNoIGZ1bmN0aW9ucyB0byB0aGUgbWFpbiBvYmplY3Rcbmhhc2guc2hhMSA9IGhhc2guc2hhLnNoYTE7XG5oYXNoLnNoYTI1NiA9IGhhc2guc2hhLnNoYTI1Njtcbmhhc2guc2hhMjI0ID0gaGFzaC5zaGEuc2hhMjI0O1xuaGFzaC5zaGEzODQgPSBoYXNoLnNoYS5zaGEzODQ7XG5oYXNoLnNoYTUxMiA9IGhhc2guc2hhLnNoYTUxMjtcbmhhc2gucmlwZW1kMTYwID0gaGFzaC5yaXBlbWQucmlwZW1kMTYwO1xuIiwidmFyIGhhc2ggPSByZXF1aXJlKCcuLi9oYXNoJyk7XG52YXIgdXRpbHMgPSBoYXNoLnV0aWxzO1xudmFyIGFzc2VydCA9IHV0aWxzLmFzc2VydDtcblxuZnVuY3Rpb24gQmxvY2tIYXNoKCkge1xuICB0aGlzLnBlbmRpbmcgPSBudWxsO1xuICB0aGlzLnBlbmRpbmdUb3RhbCA9IDA7XG4gIHRoaXMuYmxvY2tTaXplID0gdGhpcy5jb25zdHJ1Y3Rvci5ibG9ja1NpemU7XG4gIHRoaXMub3V0U2l6ZSA9IHRoaXMuY29uc3RydWN0b3Iub3V0U2l6ZTtcbiAgdGhpcy5obWFjU3RyZW5ndGggPSB0aGlzLmNvbnN0cnVjdG9yLmhtYWNTdHJlbmd0aDtcbiAgdGhpcy5wYWRMZW5ndGggPSB0aGlzLmNvbnN0cnVjdG9yLnBhZExlbmd0aCAvIDg7XG4gIHRoaXMuZW5kaWFuID0gJ2JpZyc7XG5cbiAgdGhpcy5fZGVsdGE4ID0gdGhpcy5ibG9ja1NpemUgLyA4O1xuICB0aGlzLl9kZWx0YTMyID0gdGhpcy5ibG9ja1NpemUgLyAzMjtcbn1cbmV4cG9ydHMuQmxvY2tIYXNoID0gQmxvY2tIYXNoO1xuXG5CbG9ja0hhc2gucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShtc2csIGVuYykge1xuICAvLyBDb252ZXJ0IG1lc3NhZ2UgdG8gYXJyYXksIHBhZCBpdCwgYW5kIGpvaW4gaW50byAzMmJpdCBibG9ja3NcbiAgbXNnID0gdXRpbHMudG9BcnJheShtc2csIGVuYyk7XG4gIGlmICghdGhpcy5wZW5kaW5nKVxuICAgIHRoaXMucGVuZGluZyA9IG1zZztcbiAgZWxzZVxuICAgIHRoaXMucGVuZGluZyA9IHRoaXMucGVuZGluZy5jb25jYXQobXNnKTtcbiAgdGhpcy5wZW5kaW5nVG90YWwgKz0gbXNnLmxlbmd0aDtcblxuICAvLyBFbm91Z2ggZGF0YSwgdHJ5IHVwZGF0aW5nXG4gIGlmICh0aGlzLnBlbmRpbmcubGVuZ3RoID49IHRoaXMuX2RlbHRhOCkge1xuICAgIG1zZyA9IHRoaXMucGVuZGluZztcblxuICAgIC8vIFByb2Nlc3MgcGVuZGluZyBkYXRhIGluIGJsb2Nrc1xuICAgIHZhciByID0gbXNnLmxlbmd0aCAlIHRoaXMuX2RlbHRhODtcbiAgICB0aGlzLnBlbmRpbmcgPSBtc2cuc2xpY2UobXNnLmxlbmd0aCAtIHIsIG1zZy5sZW5ndGgpO1xuICAgIGlmICh0aGlzLnBlbmRpbmcubGVuZ3RoID09PSAwKVxuICAgICAgdGhpcy5wZW5kaW5nID0gbnVsbDtcblxuICAgIG1zZyA9IHV0aWxzLmpvaW4zMihtc2csIDAsIG1zZy5sZW5ndGggLSByLCB0aGlzLmVuZGlhbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpICs9IHRoaXMuX2RlbHRhMzIpXG4gICAgICB0aGlzLl91cGRhdGUobXNnLCBpLCBpICsgdGhpcy5fZGVsdGEzMik7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkJsb2NrSGFzaC5wcm90b3R5cGUuZGlnZXN0ID0gZnVuY3Rpb24gZGlnZXN0KGVuYykge1xuICB0aGlzLnVwZGF0ZSh0aGlzLl9wYWQoKSk7XG4gIGFzc2VydCh0aGlzLnBlbmRpbmcgPT09IG51bGwpO1xuXG4gIHJldHVybiB0aGlzLl9kaWdlc3QoZW5jKTtcbn07XG5cbkJsb2NrSGFzaC5wcm90b3R5cGUuX3BhZCA9IGZ1bmN0aW9uIHBhZCgpIHtcbiAgdmFyIGxlbiA9IHRoaXMucGVuZGluZ1RvdGFsO1xuICB2YXIgYnl0ZXMgPSB0aGlzLl9kZWx0YTg7XG4gIHZhciBrID0gYnl0ZXMgLSAoKGxlbiArIHRoaXMucGFkTGVuZ3RoKSAlIGJ5dGVzKTtcbiAgdmFyIHJlcyA9IG5ldyBBcnJheShrICsgdGhpcy5wYWRMZW5ndGgpO1xuICByZXNbMF0gPSAweDgwO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGs7IGkrKylcbiAgICByZXNbaV0gPSAwO1xuXG4gIC8vIEFwcGVuZCBsZW5ndGhcbiAgbGVuIDw8PSAzO1xuICBpZiAodGhpcy5lbmRpYW4gPT09ICdiaWcnKSB7XG4gICAgZm9yICh2YXIgdCA9IDg7IHQgPCB0aGlzLnBhZExlbmd0aDsgdCsrKVxuICAgICAgcmVzW2krK10gPSAwO1xuXG4gICAgcmVzW2krK10gPSAwO1xuICAgIHJlc1tpKytdID0gMDtcbiAgICByZXNbaSsrXSA9IDA7XG4gICAgcmVzW2krK10gPSAwO1xuICAgIHJlc1tpKytdID0gKGxlbiA+Pj4gMjQpICYgMHhmZjtcbiAgICByZXNbaSsrXSA9IChsZW4gPj4+IDE2KSAmIDB4ZmY7XG4gICAgcmVzW2krK10gPSAobGVuID4+PiA4KSAmIDB4ZmY7XG4gICAgcmVzW2krK10gPSBsZW4gJiAweGZmO1xuICB9IGVsc2Uge1xuICAgIHJlc1tpKytdID0gbGVuICYgMHhmZjtcbiAgICByZXNbaSsrXSA9IChsZW4gPj4+IDgpICYgMHhmZjtcbiAgICByZXNbaSsrXSA9IChsZW4gPj4+IDE2KSAmIDB4ZmY7XG4gICAgcmVzW2krK10gPSAobGVuID4+PiAyNCkgJiAweGZmO1xuICAgIHJlc1tpKytdID0gMDtcbiAgICByZXNbaSsrXSA9IDA7XG4gICAgcmVzW2krK10gPSAwO1xuICAgIHJlc1tpKytdID0gMDtcblxuICAgIGZvciAodmFyIHQgPSA4OyB0IDwgdGhpcy5wYWRMZW5ndGg7IHQrKylcbiAgICAgIHJlc1tpKytdID0gMDtcbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuIiwidmFyIGhtYWMgPSBleHBvcnRzO1xuXG52YXIgaGFzaCA9IHJlcXVpcmUoJy4uL2hhc2gnKTtcbnZhciB1dGlscyA9IGhhc2gudXRpbHM7XG52YXIgYXNzZXJ0ID0gdXRpbHMuYXNzZXJ0O1xuXG5mdW5jdGlvbiBIbWFjKGhhc2gsIGtleSwgZW5jKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBIbWFjKSlcbiAgICByZXR1cm4gbmV3IEhtYWMoaGFzaCwga2V5LCBlbmMpO1xuICB0aGlzLkhhc2ggPSBoYXNoO1xuICB0aGlzLmJsb2NrU2l6ZSA9IGhhc2guYmxvY2tTaXplIC8gODtcbiAgdGhpcy5vdXRTaXplID0gaGFzaC5vdXRTaXplIC8gODtcbiAgdGhpcy5pbm5lciA9IG51bGw7XG4gIHRoaXMub3V0ZXIgPSBudWxsO1xuXG4gIHRoaXMuX2luaXQodXRpbHMudG9BcnJheShrZXksIGVuYykpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBIbWFjO1xuXG5IbWFjLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIGluaXQoa2V5KSB7XG4gIC8vIFNob3J0ZW4ga2V5LCBpZiBuZWVkZWRcbiAgaWYgKGtleS5sZW5ndGggPiB0aGlzLmJsb2NrU2l6ZSlcbiAgICBrZXkgPSBuZXcgdGhpcy5IYXNoKCkudXBkYXRlKGtleSkuZGlnZXN0KCk7XG4gIGFzc2VydChrZXkubGVuZ3RoIDw9IHRoaXMuYmxvY2tTaXplKTtcblxuICAvLyBBZGQgcGFkZGluZyB0byBrZXlcbiAgZm9yICh2YXIgaSA9IGtleS5sZW5ndGg7IGkgPCB0aGlzLmJsb2NrU2l6ZTsgaSsrKVxuICAgIGtleS5wdXNoKDApO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5Lmxlbmd0aDsgaSsrKVxuICAgIGtleVtpXSBePSAweDM2O1xuICB0aGlzLmlubmVyID0gbmV3IHRoaXMuSGFzaCgpLnVwZGF0ZShrZXkpO1xuXG4gIC8vIDB4MzYgXiAweDVjID0gMHg2YVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleS5sZW5ndGg7IGkrKylcbiAgICBrZXlbaV0gXj0gMHg2YTtcbiAgdGhpcy5vdXRlciA9IG5ldyB0aGlzLkhhc2goKS51cGRhdGUoa2V5KTtcbn07XG5cbkhtYWMucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShtc2csIGVuYykge1xuICB0aGlzLmlubmVyLnVwZGF0ZShtc2csIGVuYyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuSG1hYy5wcm90b3R5cGUuZGlnZXN0ID0gZnVuY3Rpb24gZGlnZXN0KGVuYykge1xuICB0aGlzLm91dGVyLnVwZGF0ZSh0aGlzLmlubmVyLmRpZ2VzdCgpKTtcbiAgcmV0dXJuIHRoaXMub3V0ZXIuZGlnZXN0KGVuYyk7XG59O1xuIiwidmFyIGhhc2ggPSByZXF1aXJlKCcuLi9oYXNoJyk7XG52YXIgdXRpbHMgPSBoYXNoLnV0aWxzO1xuXG52YXIgcm90bDMyID0gdXRpbHMucm90bDMyO1xudmFyIHN1bTMyID0gdXRpbHMuc3VtMzI7XG52YXIgc3VtMzJfMyA9IHV0aWxzLnN1bTMyXzM7XG52YXIgc3VtMzJfNCA9IHV0aWxzLnN1bTMyXzQ7XG52YXIgQmxvY2tIYXNoID0gaGFzaC5jb21tb24uQmxvY2tIYXNoO1xuXG5mdW5jdGlvbiBSSVBFTUQxNjAoKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSSVBFTUQxNjApKVxuICAgIHJldHVybiBuZXcgUklQRU1EMTYwKCk7XG5cbiAgQmxvY2tIYXNoLmNhbGwodGhpcyk7XG5cbiAgdGhpcy5oID0gWyAweDY3NDUyMzAxLCAweGVmY2RhYjg5LCAweDk4YmFkY2ZlLCAweDEwMzI1NDc2LCAweGMzZDJlMWYwIF07XG4gIHRoaXMuZW5kaWFuID0gJ2xpdHRsZSc7XG59XG51dGlscy5pbmhlcml0cyhSSVBFTUQxNjAsIEJsb2NrSGFzaCk7XG5leHBvcnRzLnJpcGVtZDE2MCA9IFJJUEVNRDE2MDtcblxuUklQRU1EMTYwLmJsb2NrU2l6ZSA9IDUxMjtcblJJUEVNRDE2MC5vdXRTaXplID0gMTYwO1xuUklQRU1EMTYwLmhtYWNTdHJlbmd0aCA9IDE5MjtcblJJUEVNRDE2MC5wYWRMZW5ndGggPSA2NDtcblxuUklQRU1EMTYwLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKG1zZywgc3RhcnQpIHtcbiAgdmFyIEEgPSB0aGlzLmhbMF07XG4gIHZhciBCID0gdGhpcy5oWzFdO1xuICB2YXIgQyA9IHRoaXMuaFsyXTtcbiAgdmFyIEQgPSB0aGlzLmhbM107XG4gIHZhciBFID0gdGhpcy5oWzRdO1xuICB2YXIgQWggPSBBO1xuICB2YXIgQmggPSBCO1xuICB2YXIgQ2ggPSBDO1xuICB2YXIgRGggPSBEO1xuICB2YXIgRWggPSBFO1xuICBmb3IgKHZhciBqID0gMDsgaiA8IDgwOyBqKyspIHtcbiAgICB2YXIgVCA9IHN1bTMyKFxuICAgICAgcm90bDMyKFxuICAgICAgICBzdW0zMl80KEEsIGYoaiwgQiwgQywgRCksIG1zZ1tyW2pdICsgc3RhcnRdLCBLKGopKSxcbiAgICAgICAgc1tqXSksXG4gICAgICBFKTtcbiAgICBBID0gRTtcbiAgICBFID0gRDtcbiAgICBEID0gcm90bDMyKEMsIDEwKTtcbiAgICBDID0gQjtcbiAgICBCID0gVDtcbiAgICBUID0gc3VtMzIoXG4gICAgICByb3RsMzIoXG4gICAgICAgIHN1bTMyXzQoQWgsIGYoNzkgLSBqLCBCaCwgQ2gsIERoKSwgbXNnW3JoW2pdICsgc3RhcnRdLCBLaChqKSksXG4gICAgICAgIHNoW2pdKSxcbiAgICAgIEVoKTtcbiAgICBBaCA9IEVoO1xuICAgIEVoID0gRGg7XG4gICAgRGggPSByb3RsMzIoQ2gsIDEwKTtcbiAgICBDaCA9IEJoO1xuICAgIEJoID0gVDtcbiAgfVxuICBUID0gc3VtMzJfMyh0aGlzLmhbMV0sIEMsIERoKTtcbiAgdGhpcy5oWzFdID0gc3VtMzJfMyh0aGlzLmhbMl0sIEQsIEVoKTtcbiAgdGhpcy5oWzJdID0gc3VtMzJfMyh0aGlzLmhbM10sIEUsIEFoKTtcbiAgdGhpcy5oWzNdID0gc3VtMzJfMyh0aGlzLmhbNF0sIEEsIEJoKTtcbiAgdGhpcy5oWzRdID0gc3VtMzJfMyh0aGlzLmhbMF0sIEIsIENoKTtcbiAgdGhpcy5oWzBdID0gVDtcbn07XG5cblJJUEVNRDE2MC5wcm90b3R5cGUuX2RpZ2VzdCA9IGZ1bmN0aW9uIGRpZ2VzdChlbmMpIHtcbiAgaWYgKGVuYyA9PT0gJ2hleCcpXG4gICAgcmV0dXJuIHV0aWxzLnRvSGV4MzIodGhpcy5oLCAnbGl0dGxlJyk7XG4gIGVsc2VcbiAgICByZXR1cm4gdXRpbHMuc3BsaXQzMih0aGlzLmgsICdsaXR0bGUnKTtcbn07XG5cbmZ1bmN0aW9uIGYoaiwgeCwgeSwgeikge1xuICBpZiAoaiA8PSAxNSlcbiAgICByZXR1cm4geCBeIHkgXiB6O1xuICBlbHNlIGlmIChqIDw9IDMxKVxuICAgIHJldHVybiAoeCAmIHkpIHwgKCh+eCkgJiB6KTtcbiAgZWxzZSBpZiAoaiA8PSA0NylcbiAgICByZXR1cm4gKHggfCAofnkpKSBeIHo7XG4gIGVsc2UgaWYgKGogPD0gNjMpXG4gICAgcmV0dXJuICh4ICYgeikgfCAoeSAmICh+eikpO1xuICBlbHNlXG4gICAgcmV0dXJuIHggXiAoeSB8ICh+eikpO1xufVxuXG5mdW5jdGlvbiBLKGopIHtcbiAgaWYgKGogPD0gMTUpXG4gICAgcmV0dXJuIDB4MDAwMDAwMDA7XG4gIGVsc2UgaWYgKGogPD0gMzEpXG4gICAgcmV0dXJuIDB4NWE4Mjc5OTk7XG4gIGVsc2UgaWYgKGogPD0gNDcpXG4gICAgcmV0dXJuIDB4NmVkOWViYTE7XG4gIGVsc2UgaWYgKGogPD0gNjMpXG4gICAgcmV0dXJuIDB4OGYxYmJjZGM7XG4gIGVsc2VcbiAgICByZXR1cm4gMHhhOTUzZmQ0ZTtcbn1cblxuZnVuY3Rpb24gS2goaikge1xuICBpZiAoaiA8PSAxNSlcbiAgICByZXR1cm4gMHg1MGEyOGJlNjtcbiAgZWxzZSBpZiAoaiA8PSAzMSlcbiAgICByZXR1cm4gMHg1YzRkZDEyNDtcbiAgZWxzZSBpZiAoaiA8PSA0NylcbiAgICByZXR1cm4gMHg2ZDcwM2VmMztcbiAgZWxzZSBpZiAoaiA8PSA2MylcbiAgICByZXR1cm4gMHg3YTZkNzZlOTtcbiAgZWxzZVxuICAgIHJldHVybiAweDAwMDAwMDAwO1xufVxuXG52YXIgciA9IFtcbiAgMCwgMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMiwgMTMsIDE0LCAxNSxcbiAgNywgNCwgMTMsIDEsIDEwLCA2LCAxNSwgMywgMTIsIDAsIDksIDUsIDIsIDE0LCAxMSwgOCxcbiAgMywgMTAsIDE0LCA0LCA5LCAxNSwgOCwgMSwgMiwgNywgMCwgNiwgMTMsIDExLCA1LCAxMixcbiAgMSwgOSwgMTEsIDEwLCAwLCA4LCAxMiwgNCwgMTMsIDMsIDcsIDE1LCAxNCwgNSwgNiwgMixcbiAgNCwgMCwgNSwgOSwgNywgMTIsIDIsIDEwLCAxNCwgMSwgMywgOCwgMTEsIDYsIDE1LCAxM1xuXTtcblxudmFyIHJoID0gW1xuICA1LCAxNCwgNywgMCwgOSwgMiwgMTEsIDQsIDEzLCA2LCAxNSwgOCwgMSwgMTAsIDMsIDEyLFxuICA2LCAxMSwgMywgNywgMCwgMTMsIDUsIDEwLCAxNCwgMTUsIDgsIDEyLCA0LCA5LCAxLCAyLFxuICAxNSwgNSwgMSwgMywgNywgMTQsIDYsIDksIDExLCA4LCAxMiwgMiwgMTAsIDAsIDQsIDEzLFxuICA4LCA2LCA0LCAxLCAzLCAxMSwgMTUsIDAsIDUsIDEyLCAyLCAxMywgOSwgNywgMTAsIDE0LFxuICAxMiwgMTUsIDEwLCA0LCAxLCA1LCA4LCA3LCA2LCAyLCAxMywgMTQsIDAsIDMsIDksIDExXG5dO1xuXG52YXIgcyA9IFtcbiAgMTEsIDE0LCAxNSwgMTIsIDUsIDgsIDcsIDksIDExLCAxMywgMTQsIDE1LCA2LCA3LCA5LCA4LFxuICA3LCA2LCA4LCAxMywgMTEsIDksIDcsIDE1LCA3LCAxMiwgMTUsIDksIDExLCA3LCAxMywgMTIsXG4gIDExLCAxMywgNiwgNywgMTQsIDksIDEzLCAxNSwgMTQsIDgsIDEzLCA2LCA1LCAxMiwgNywgNSxcbiAgMTEsIDEyLCAxNCwgMTUsIDE0LCAxNSwgOSwgOCwgOSwgMTQsIDUsIDYsIDgsIDYsIDUsIDEyLFxuICA5LCAxNSwgNSwgMTEsIDYsIDgsIDEzLCAxMiwgNSwgMTIsIDEzLCAxNCwgMTEsIDgsIDUsIDZcbl07XG5cbnZhciBzaCA9IFtcbiAgOCwgOSwgOSwgMTEsIDEzLCAxNSwgMTUsIDUsIDcsIDcsIDgsIDExLCAxNCwgMTQsIDEyLCA2LFxuICA5LCAxMywgMTUsIDcsIDEyLCA4LCA5LCAxMSwgNywgNywgMTIsIDcsIDYsIDE1LCAxMywgMTEsXG4gIDksIDcsIDE1LCAxMSwgOCwgNiwgNiwgMTQsIDEyLCAxMywgNSwgMTQsIDEzLCAxMywgNywgNSxcbiAgMTUsIDUsIDgsIDExLCAxNCwgMTQsIDYsIDE0LCA2LCA5LCAxMiwgOSwgMTIsIDUsIDE1LCA4LFxuICA4LCA1LCAxMiwgOSwgMTIsIDUsIDE0LCA2LCA4LCAxMywgNiwgNSwgMTUsIDEzLCAxMSwgMTFcbl07XG4iLCJ2YXIgaGFzaCA9IHJlcXVpcmUoJy4uL2hhc2gnKTtcbnZhciB1dGlscyA9IGhhc2gudXRpbHM7XG52YXIgYXNzZXJ0ID0gdXRpbHMuYXNzZXJ0O1xuXG52YXIgcm90cjMyID0gdXRpbHMucm90cjMyO1xudmFyIHJvdGwzMiA9IHV0aWxzLnJvdGwzMjtcbnZhciBzdW0zMiA9IHV0aWxzLnN1bTMyO1xudmFyIHN1bTMyXzQgPSB1dGlscy5zdW0zMl80O1xudmFyIHN1bTMyXzUgPSB1dGlscy5zdW0zMl81O1xudmFyIHJvdHI2NF9oaSA9IHV0aWxzLnJvdHI2NF9oaTtcbnZhciByb3RyNjRfbG8gPSB1dGlscy5yb3RyNjRfbG87XG52YXIgc2hyNjRfaGkgPSB1dGlscy5zaHI2NF9oaTtcbnZhciBzaHI2NF9sbyA9IHV0aWxzLnNocjY0X2xvO1xudmFyIHN1bTY0ID0gdXRpbHMuc3VtNjQ7XG52YXIgc3VtNjRfaGkgPSB1dGlscy5zdW02NF9oaTtcbnZhciBzdW02NF9sbyA9IHV0aWxzLnN1bTY0X2xvO1xudmFyIHN1bTY0XzRfaGkgPSB1dGlscy5zdW02NF80X2hpO1xudmFyIHN1bTY0XzRfbG8gPSB1dGlscy5zdW02NF80X2xvO1xudmFyIHN1bTY0XzVfaGkgPSB1dGlscy5zdW02NF81X2hpO1xudmFyIHN1bTY0XzVfbG8gPSB1dGlscy5zdW02NF81X2xvO1xudmFyIEJsb2NrSGFzaCA9IGhhc2guY29tbW9uLkJsb2NrSGFzaDtcblxudmFyIHNoYTI1Nl9LID0gW1xuICAweDQyOGEyZjk4LCAweDcxMzc0NDkxLCAweGI1YzBmYmNmLCAweGU5YjVkYmE1LFxuICAweDM5NTZjMjViLCAweDU5ZjExMWYxLCAweDkyM2Y4MmE0LCAweGFiMWM1ZWQ1LFxuICAweGQ4MDdhYTk4LCAweDEyODM1YjAxLCAweDI0MzE4NWJlLCAweDU1MGM3ZGMzLFxuICAweDcyYmU1ZDc0LCAweDgwZGViMWZlLCAweDliZGMwNmE3LCAweGMxOWJmMTc0LFxuICAweGU0OWI2OWMxLCAweGVmYmU0Nzg2LCAweDBmYzE5ZGM2LCAweDI0MGNhMWNjLFxuICAweDJkZTkyYzZmLCAweDRhNzQ4NGFhLCAweDVjYjBhOWRjLCAweDc2Zjk4OGRhLFxuICAweDk4M2U1MTUyLCAweGE4MzFjNjZkLCAweGIwMDMyN2M4LCAweGJmNTk3ZmM3LFxuICAweGM2ZTAwYmYzLCAweGQ1YTc5MTQ3LCAweDA2Y2E2MzUxLCAweDE0MjkyOTY3LFxuICAweDI3YjcwYTg1LCAweDJlMWIyMTM4LCAweDRkMmM2ZGZjLCAweDUzMzgwZDEzLFxuICAweDY1MGE3MzU0LCAweDc2NmEwYWJiLCAweDgxYzJjOTJlLCAweDkyNzIyYzg1LFxuICAweGEyYmZlOGExLCAweGE4MWE2NjRiLCAweGMyNGI4YjcwLCAweGM3NmM1MWEzLFxuICAweGQxOTJlODE5LCAweGQ2OTkwNjI0LCAweGY0MGUzNTg1LCAweDEwNmFhMDcwLFxuICAweDE5YTRjMTE2LCAweDFlMzc2YzA4LCAweDI3NDg3NzRjLCAweDM0YjBiY2I1LFxuICAweDM5MWMwY2IzLCAweDRlZDhhYTRhLCAweDViOWNjYTRmLCAweDY4MmU2ZmYzLFxuICAweDc0OGY4MmVlLCAweDc4YTU2MzZmLCAweDg0Yzg3ODE0LCAweDhjYzcwMjA4LFxuICAweDkwYmVmZmZhLCAweGE0NTA2Y2ViLCAweGJlZjlhM2Y3LCAweGM2NzE3OGYyXG5dO1xuXG52YXIgc2hhNTEyX0sgPSBbXG4gIDB4NDI4YTJmOTgsIDB4ZDcyOGFlMjIsIDB4NzEzNzQ0OTEsIDB4MjNlZjY1Y2QsXG4gIDB4YjVjMGZiY2YsIDB4ZWM0ZDNiMmYsIDB4ZTliNWRiYTUsIDB4ODE4OWRiYmMsXG4gIDB4Mzk1NmMyNWIsIDB4ZjM0OGI1MzgsIDB4NTlmMTExZjEsIDB4YjYwNWQwMTksXG4gIDB4OTIzZjgyYTQsIDB4YWYxOTRmOWIsIDB4YWIxYzVlZDUsIDB4ZGE2ZDgxMTgsXG4gIDB4ZDgwN2FhOTgsIDB4YTMwMzAyNDIsIDB4MTI4MzViMDEsIDB4NDU3MDZmYmUsXG4gIDB4MjQzMTg1YmUsIDB4NGVlNGIyOGMsIDB4NTUwYzdkYzMsIDB4ZDVmZmI0ZTIsXG4gIDB4NzJiZTVkNzQsIDB4ZjI3Yjg5NmYsIDB4ODBkZWIxZmUsIDB4M2IxNjk2YjEsXG4gIDB4OWJkYzA2YTcsIDB4MjVjNzEyMzUsIDB4YzE5YmYxNzQsIDB4Y2Y2OTI2OTQsXG4gIDB4ZTQ5YjY5YzEsIDB4OWVmMTRhZDIsIDB4ZWZiZTQ3ODYsIDB4Mzg0ZjI1ZTMsXG4gIDB4MGZjMTlkYzYsIDB4OGI4Y2Q1YjUsIDB4MjQwY2ExY2MsIDB4NzdhYzljNjUsXG4gIDB4MmRlOTJjNmYsIDB4NTkyYjAyNzUsIDB4NGE3NDg0YWEsIDB4NmVhNmU0ODMsXG4gIDB4NWNiMGE5ZGMsIDB4YmQ0MWZiZDQsIDB4NzZmOTg4ZGEsIDB4ODMxMTUzYjUsXG4gIDB4OTgzZTUxNTIsIDB4ZWU2NmRmYWIsIDB4YTgzMWM2NmQsIDB4MmRiNDMyMTAsXG4gIDB4YjAwMzI3YzgsIDB4OThmYjIxM2YsIDB4YmY1OTdmYzcsIDB4YmVlZjBlZTQsXG4gIDB4YzZlMDBiZjMsIDB4M2RhODhmYzIsIDB4ZDVhNzkxNDcsIDB4OTMwYWE3MjUsXG4gIDB4MDZjYTYzNTEsIDB4ZTAwMzgyNmYsIDB4MTQyOTI5NjcsIDB4MGEwZTZlNzAsXG4gIDB4MjdiNzBhODUsIDB4NDZkMjJmZmMsIDB4MmUxYjIxMzgsIDB4NWMyNmM5MjYsXG4gIDB4NGQyYzZkZmMsIDB4NWFjNDJhZWQsIDB4NTMzODBkMTMsIDB4OWQ5NWIzZGYsXG4gIDB4NjUwYTczNTQsIDB4OGJhZjYzZGUsIDB4NzY2YTBhYmIsIDB4M2M3N2IyYTgsXG4gIDB4ODFjMmM5MmUsIDB4NDdlZGFlZTYsIDB4OTI3MjJjODUsIDB4MTQ4MjM1M2IsXG4gIDB4YTJiZmU4YTEsIDB4NGNmMTAzNjQsIDB4YTgxYTY2NGIsIDB4YmM0MjMwMDEsXG4gIDB4YzI0YjhiNzAsIDB4ZDBmODk3OTEsIDB4Yzc2YzUxYTMsIDB4MDY1NGJlMzAsXG4gIDB4ZDE5MmU4MTksIDB4ZDZlZjUyMTgsIDB4ZDY5OTA2MjQsIDB4NTU2NWE5MTAsXG4gIDB4ZjQwZTM1ODUsIDB4NTc3MTIwMmEsIDB4MTA2YWEwNzAsIDB4MzJiYmQxYjgsXG4gIDB4MTlhNGMxMTYsIDB4YjhkMmQwYzgsIDB4MWUzNzZjMDgsIDB4NTE0MWFiNTMsXG4gIDB4Mjc0ODc3NGMsIDB4ZGY4ZWViOTksIDB4MzRiMGJjYjUsIDB4ZTE5YjQ4YTgsXG4gIDB4MzkxYzBjYjMsIDB4YzVjOTVhNjMsIDB4NGVkOGFhNGEsIDB4ZTM0MThhY2IsXG4gIDB4NWI5Y2NhNGYsIDB4Nzc2M2UzNzMsIDB4NjgyZTZmZjMsIDB4ZDZiMmI4YTMsXG4gIDB4NzQ4ZjgyZWUsIDB4NWRlZmIyZmMsIDB4NzhhNTYzNmYsIDB4NDMxNzJmNjAsXG4gIDB4ODRjODc4MTQsIDB4YTFmMGFiNzIsIDB4OGNjNzAyMDgsIDB4MWE2NDM5ZWMsXG4gIDB4OTBiZWZmZmEsIDB4MjM2MzFlMjgsIDB4YTQ1MDZjZWIsIDB4ZGU4MmJkZTksXG4gIDB4YmVmOWEzZjcsIDB4YjJjNjc5MTUsIDB4YzY3MTc4ZjIsIDB4ZTM3MjUzMmIsXG4gIDB4Y2EyNzNlY2UsIDB4ZWEyNjYxOWMsIDB4ZDE4NmI4YzcsIDB4MjFjMGMyMDcsXG4gIDB4ZWFkYTdkZDYsIDB4Y2RlMGViMWUsIDB4ZjU3ZDRmN2YsIDB4ZWU2ZWQxNzgsXG4gIDB4MDZmMDY3YWEsIDB4NzIxNzZmYmEsIDB4MGE2MzdkYzUsIDB4YTJjODk4YTYsXG4gIDB4MTEzZjk4MDQsIDB4YmVmOTBkYWUsIDB4MWI3MTBiMzUsIDB4MTMxYzQ3MWIsXG4gIDB4MjhkYjc3ZjUsIDB4MjMwNDdkODQsIDB4MzJjYWFiN2IsIDB4NDBjNzI0OTMsXG4gIDB4M2M5ZWJlMGEsIDB4MTVjOWJlYmMsIDB4NDMxZDY3YzQsIDB4OWMxMDBkNGMsXG4gIDB4NGNjNWQ0YmUsIDB4Y2IzZTQyYjYsIDB4NTk3ZjI5OWMsIDB4ZmM2NTdlMmEsXG4gIDB4NWZjYjZmYWIsIDB4M2FkNmZhZWMsIDB4NmM0NDE5OGMsIDB4NGE0NzU4MTdcbl07XG5cbnZhciBzaGExX0sgPSBbXG4gIDB4NUE4Mjc5OTksIDB4NkVEOUVCQTEsXG4gIDB4OEYxQkJDREMsIDB4Q0E2MkMxRDZcbl07XG5cbmZ1bmN0aW9uIFNIQTI1NigpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNIQTI1NikpXG4gICAgcmV0dXJuIG5ldyBTSEEyNTYoKTtcblxuICBCbG9ja0hhc2guY2FsbCh0aGlzKTtcbiAgdGhpcy5oID0gWyAweDZhMDllNjY3LCAweGJiNjdhZTg1LCAweDNjNmVmMzcyLCAweGE1NGZmNTNhLFxuICAgICAgICAgICAgIDB4NTEwZTUyN2YsIDB4OWIwNTY4OGMsIDB4MWY4M2Q5YWIsIDB4NWJlMGNkMTkgXTtcbiAgdGhpcy5rID0gc2hhMjU2X0s7XG4gIHRoaXMuVyA9IG5ldyBBcnJheSg2NCk7XG59XG51dGlscy5pbmhlcml0cyhTSEEyNTYsIEJsb2NrSGFzaCk7XG5leHBvcnRzLnNoYTI1NiA9IFNIQTI1NjtcblxuU0hBMjU2LmJsb2NrU2l6ZSA9IDUxMjtcblNIQTI1Ni5vdXRTaXplID0gMjU2O1xuU0hBMjU2LmhtYWNTdHJlbmd0aCA9IDE5MjtcblNIQTI1Ni5wYWRMZW5ndGggPSA2NDtcblxuU0hBMjU2LnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gX3VwZGF0ZShtc2csIHN0YXJ0KSB7XG4gIHZhciBXID0gdGhpcy5XO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7IGkrKylcbiAgICBXW2ldID0gbXNnW3N0YXJ0ICsgaV07XG4gIGZvciAoOyBpIDwgVy5sZW5ndGg7IGkrKylcbiAgICBXW2ldID0gc3VtMzJfNChnMV8yNTYoV1tpIC0gMl0pLCBXW2kgLSA3XSwgZzBfMjU2KFdbaSAtIDE1XSksIFdbaSAtIDE2XSk7XG5cbiAgdmFyIGEgPSB0aGlzLmhbMF07XG4gIHZhciBiID0gdGhpcy5oWzFdO1xuICB2YXIgYyA9IHRoaXMuaFsyXTtcbiAgdmFyIGQgPSB0aGlzLmhbM107XG4gIHZhciBlID0gdGhpcy5oWzRdO1xuICB2YXIgZiA9IHRoaXMuaFs1XTtcbiAgdmFyIGcgPSB0aGlzLmhbNl07XG4gIHZhciBoID0gdGhpcy5oWzddO1xuXG4gIGFzc2VydCh0aGlzLmsubGVuZ3RoID09PSBXLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgVy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBUMSA9IHN1bTMyXzUoaCwgczFfMjU2KGUpLCBjaDMyKGUsIGYsIGcpLCB0aGlzLmtbaV0sIFdbaV0pO1xuICAgIHZhciBUMiA9IHN1bTMyKHMwXzI1NihhKSwgbWFqMzIoYSwgYiwgYykpO1xuICAgIGggPSBnO1xuICAgIGcgPSBmO1xuICAgIGYgPSBlO1xuICAgIGUgPSBzdW0zMihkLCBUMSk7XG4gICAgZCA9IGM7XG4gICAgYyA9IGI7XG4gICAgYiA9IGE7XG4gICAgYSA9IHN1bTMyKFQxLCBUMik7XG4gIH1cblxuICB0aGlzLmhbMF0gPSBzdW0zMih0aGlzLmhbMF0sIGEpO1xuICB0aGlzLmhbMV0gPSBzdW0zMih0aGlzLmhbMV0sIGIpO1xuICB0aGlzLmhbMl0gPSBzdW0zMih0aGlzLmhbMl0sIGMpO1xuICB0aGlzLmhbM10gPSBzdW0zMih0aGlzLmhbM10sIGQpO1xuICB0aGlzLmhbNF0gPSBzdW0zMih0aGlzLmhbNF0sIGUpO1xuICB0aGlzLmhbNV0gPSBzdW0zMih0aGlzLmhbNV0sIGYpO1xuICB0aGlzLmhbNl0gPSBzdW0zMih0aGlzLmhbNl0sIGcpO1xuICB0aGlzLmhbN10gPSBzdW0zMih0aGlzLmhbN10sIGgpO1xufTtcblxuU0hBMjU2LnByb3RvdHlwZS5fZGlnZXN0ID0gZnVuY3Rpb24gZGlnZXN0KGVuYykge1xuICBpZiAoZW5jID09PSAnaGV4JylcbiAgICByZXR1cm4gdXRpbHMudG9IZXgzMih0aGlzLmgsICdiaWcnKTtcbiAgZWxzZVxuICAgIHJldHVybiB1dGlscy5zcGxpdDMyKHRoaXMuaCwgJ2JpZycpO1xufTtcblxuZnVuY3Rpb24gU0hBMjI0KCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU0hBMjI0KSlcbiAgICByZXR1cm4gbmV3IFNIQTIyNCgpO1xuXG4gIFNIQTI1Ni5jYWxsKHRoaXMpO1xuICB0aGlzLmggPSBbIDB4YzEwNTllZDgsIDB4MzY3Y2Q1MDcsIDB4MzA3MGRkMTcsIDB4ZjcwZTU5MzksXG4gICAgICAgICAgICAgMHhmZmMwMGIzMSwgMHg2ODU4MTUxMSwgMHg2NGY5OGZhNywgMHhiZWZhNGZhNCBdO1xufVxudXRpbHMuaW5oZXJpdHMoU0hBMjI0LCBTSEEyNTYpO1xuZXhwb3J0cy5zaGEyMjQgPSBTSEEyMjQ7XG5cblNIQTIyNC5ibG9ja1NpemUgPSA1MTI7XG5TSEEyMjQub3V0U2l6ZSA9IDIyNDtcblNIQTIyNC5obWFjU3RyZW5ndGggPSAxOTI7XG5TSEEyMjQucGFkTGVuZ3RoID0gNjQ7XG5cblNIQTIyNC5wcm90b3R5cGUuX2RpZ2VzdCA9IGZ1bmN0aW9uIGRpZ2VzdChlbmMpIHtcbiAgLy8gSnVzdCB0cnVuY2F0ZSBvdXRwdXRcbiAgaWYgKGVuYyA9PT0gJ2hleCcpXG4gICAgcmV0dXJuIHV0aWxzLnRvSGV4MzIodGhpcy5oLnNsaWNlKDAsIDcpLCAnYmlnJyk7XG4gIGVsc2VcbiAgICByZXR1cm4gdXRpbHMuc3BsaXQzMih0aGlzLmguc2xpY2UoMCwgNyksICdiaWcnKTtcbn07XG5cbmZ1bmN0aW9uIFNIQTUxMigpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNIQTUxMikpXG4gICAgcmV0dXJuIG5ldyBTSEE1MTIoKTtcblxuICBCbG9ja0hhc2guY2FsbCh0aGlzKTtcbiAgdGhpcy5oID0gWyAweDZhMDllNjY3LCAweGYzYmNjOTA4LFxuICAgICAgICAgICAgIDB4YmI2N2FlODUsIDB4ODRjYWE3M2IsXG4gICAgICAgICAgICAgMHgzYzZlZjM3MiwgMHhmZTk0ZjgyYixcbiAgICAgICAgICAgICAweGE1NGZmNTNhLCAweDVmMWQzNmYxLFxuICAgICAgICAgICAgIDB4NTEwZTUyN2YsIDB4YWRlNjgyZDEsXG4gICAgICAgICAgICAgMHg5YjA1Njg4YywgMHgyYjNlNmMxZixcbiAgICAgICAgICAgICAweDFmODNkOWFiLCAweGZiNDFiZDZiLFxuICAgICAgICAgICAgIDB4NWJlMGNkMTksIDB4MTM3ZTIxNzkgXTtcbiAgdGhpcy5rID0gc2hhNTEyX0s7XG4gIHRoaXMuVyA9IG5ldyBBcnJheSgxNjApO1xufVxudXRpbHMuaW5oZXJpdHMoU0hBNTEyLCBCbG9ja0hhc2gpO1xuZXhwb3J0cy5zaGE1MTIgPSBTSEE1MTI7XG5cblNIQTUxMi5ibG9ja1NpemUgPSAxMDI0O1xuU0hBNTEyLm91dFNpemUgPSA1MTI7XG5TSEE1MTIuaG1hY1N0cmVuZ3RoID0gMTkyO1xuU0hBNTEyLnBhZExlbmd0aCA9IDEyODtcblxuU0hBNTEyLnByb3RvdHlwZS5fcHJlcGFyZUJsb2NrID0gZnVuY3Rpb24gX3ByZXBhcmVCbG9jayhtc2csIHN0YXJ0KSB7XG4gIHZhciBXID0gdGhpcy5XO1xuXG4gIC8vIDMyIHggMzJiaXQgd29yZHNcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAzMjsgaSsrKVxuICAgIFdbaV0gPSBtc2dbc3RhcnQgKyBpXTtcbiAgZm9yICg7IGkgPCBXLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgdmFyIGMwX2hpID0gZzFfNTEyX2hpKFdbaSAtIDRdLCBXW2kgLSAzXSk7ICAvLyBpIC0gMlxuICAgIHZhciBjMF9sbyA9IGcxXzUxMl9sbyhXW2kgLSA0XSwgV1tpIC0gM10pO1xuICAgIHZhciBjMV9oaSA9IFdbaSAtIDE0XTsgIC8vIGkgLSA3XG4gICAgdmFyIGMxX2xvID0gV1tpIC0gMTNdO1xuICAgIHZhciBjMl9oaSA9IGcwXzUxMl9oaShXW2kgLSAzMF0sIFdbaSAtIDI5XSk7ICAvLyBpIC0gMTVcbiAgICB2YXIgYzJfbG8gPSBnMF81MTJfbG8oV1tpIC0gMzBdLCBXW2kgLSAyOV0pO1xuICAgIHZhciBjM19oaSA9IFdbaSAtIDMyXTsgIC8vIGkgLSAxNlxuICAgIHZhciBjM19sbyA9IFdbaSAtIDMxXTtcblxuICAgIFdbaV0gPSBzdW02NF80X2hpKGMwX2hpLCBjMF9sbyxcbiAgICAgICAgICAgICAgICAgICAgICBjMV9oaSwgYzFfbG8sXG4gICAgICAgICAgICAgICAgICAgICAgYzJfaGksIGMyX2xvLFxuICAgICAgICAgICAgICAgICAgICAgIGMzX2hpLCBjM19sbyk7XG4gICAgV1tpICsgMV0gPSBzdW02NF80X2xvKGMwX2hpLCBjMF9sbyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYzFfaGksIGMxX2xvLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBjMl9oaSwgYzJfbG8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGMzX2hpLCBjM19sbyk7XG4gIH1cbn07XG5cblNIQTUxMi5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIF91cGRhdGUobXNnLCBzdGFydCkge1xuICB0aGlzLl9wcmVwYXJlQmxvY2sobXNnLCBzdGFydCk7XG5cbiAgdmFyIFcgPSB0aGlzLlc7XG5cbiAgdmFyIGFoID0gdGhpcy5oWzBdO1xuICB2YXIgYWwgPSB0aGlzLmhbMV07XG4gIHZhciBiaCA9IHRoaXMuaFsyXTtcbiAgdmFyIGJsID0gdGhpcy5oWzNdO1xuICB2YXIgY2ggPSB0aGlzLmhbNF07XG4gIHZhciBjbCA9IHRoaXMuaFs1XTtcbiAgdmFyIGRoID0gdGhpcy5oWzZdO1xuICB2YXIgZGwgPSB0aGlzLmhbN107XG4gIHZhciBlaCA9IHRoaXMuaFs4XTtcbiAgdmFyIGVsID0gdGhpcy5oWzldO1xuICB2YXIgZmggPSB0aGlzLmhbMTBdO1xuICB2YXIgZmwgPSB0aGlzLmhbMTFdO1xuICB2YXIgZ2ggPSB0aGlzLmhbMTJdO1xuICB2YXIgZ2wgPSB0aGlzLmhbMTNdO1xuICB2YXIgaGggPSB0aGlzLmhbMTRdO1xuICB2YXIgaGwgPSB0aGlzLmhbMTVdO1xuXG4gIGFzc2VydCh0aGlzLmsubGVuZ3RoID09PSBXLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgVy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHZhciBjMF9oaSA9IGhoO1xuICAgIHZhciBjMF9sbyA9IGhsO1xuICAgIHZhciBjMV9oaSA9IHMxXzUxMl9oaShlaCwgZWwpO1xuICAgIHZhciBjMV9sbyA9IHMxXzUxMl9sbyhlaCwgZWwpO1xuICAgIHZhciBjMl9oaSA9IGNoNjRfaGkoZWgsIGVsLCBmaCwgZmwsIGdoLCBnbCk7XG4gICAgdmFyIGMyX2xvID0gY2g2NF9sbyhlaCwgZWwsIGZoLCBmbCwgZ2gsIGdsKTtcbiAgICB2YXIgYzNfaGkgPSB0aGlzLmtbaV07XG4gICAgdmFyIGMzX2xvID0gdGhpcy5rW2kgKyAxXTtcbiAgICB2YXIgYzRfaGkgPSBXW2ldO1xuICAgIHZhciBjNF9sbyA9IFdbaSArIDFdO1xuXG4gICAgdmFyIFQxX2hpID0gc3VtNjRfNV9oaShjMF9oaSwgYzBfbG8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjMV9oaSwgYzFfbG8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjMl9oaSwgYzJfbG8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjM19oaSwgYzNfbG8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjNF9oaSwgYzRfbG8pO1xuICAgIHZhciBUMV9sbyA9IHN1bTY0XzVfbG8oYzBfaGksIGMwX2xvLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgYzFfaGksIGMxX2xvLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgYzJfaGksIGMyX2xvLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgYzNfaGksIGMzX2xvLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgYzRfaGksIGM0X2xvKTtcblxuICAgIHZhciBjMF9oaSA9IHMwXzUxMl9oaShhaCwgYWwpO1xuICAgIHZhciBjMF9sbyA9IHMwXzUxMl9sbyhhaCwgYWwpO1xuICAgIHZhciBjMV9oaSA9IG1hajY0X2hpKGFoLCBhbCwgYmgsIGJsLCBjaCwgY2wpO1xuICAgIHZhciBjMV9sbyA9IG1hajY0X2xvKGFoLCBhbCwgYmgsIGJsLCBjaCwgY2wpO1xuXG4gICAgdmFyIFQyX2hpID0gc3VtNjRfaGkoYzBfaGksIGMwX2xvLCBjMV9oaSwgYzFfbG8pO1xuICAgIHZhciBUMl9sbyA9IHN1bTY0X2xvKGMwX2hpLCBjMF9sbywgYzFfaGksIGMxX2xvKTtcblxuICAgIGhoID0gZ2g7XG4gICAgaGwgPSBnbDtcblxuICAgIGdoID0gZmg7XG4gICAgZ2wgPSBmbDtcblxuICAgIGZoID0gZWg7XG4gICAgZmwgPSBlbDtcblxuICAgIGVoID0gc3VtNjRfaGkoZGgsIGRsLCBUMV9oaSwgVDFfbG8pO1xuICAgIGVsID0gc3VtNjRfbG8oZGwsIGRsLCBUMV9oaSwgVDFfbG8pO1xuXG4gICAgZGggPSBjaDtcbiAgICBkbCA9IGNsO1xuXG4gICAgY2ggPSBiaDtcbiAgICBjbCA9IGJsO1xuXG4gICAgYmggPSBhaDtcbiAgICBibCA9IGFsO1xuXG4gICAgYWggPSBzdW02NF9oaShUMV9oaSwgVDFfbG8sIFQyX2hpLCBUMl9sbyk7XG4gICAgYWwgPSBzdW02NF9sbyhUMV9oaSwgVDFfbG8sIFQyX2hpLCBUMl9sbyk7XG4gIH1cblxuICBzdW02NCh0aGlzLmgsIDAsIGFoLCBhbCk7XG4gIHN1bTY0KHRoaXMuaCwgMiwgYmgsIGJsKTtcbiAgc3VtNjQodGhpcy5oLCA0LCBjaCwgY2wpO1xuICBzdW02NCh0aGlzLmgsIDYsIGRoLCBkbCk7XG4gIHN1bTY0KHRoaXMuaCwgOCwgZWgsIGVsKTtcbiAgc3VtNjQodGhpcy5oLCAxMCwgZmgsIGZsKTtcbiAgc3VtNjQodGhpcy5oLCAxMiwgZ2gsIGdsKTtcbiAgc3VtNjQodGhpcy5oLCAxNCwgaGgsIGhsKTtcbn07XG5cblNIQTUxMi5wcm90b3R5cGUuX2RpZ2VzdCA9IGZ1bmN0aW9uIGRpZ2VzdChlbmMpIHtcbiAgaWYgKGVuYyA9PT0gJ2hleCcpXG4gICAgcmV0dXJuIHV0aWxzLnRvSGV4MzIodGhpcy5oLCAnYmlnJyk7XG4gIGVsc2VcbiAgICByZXR1cm4gdXRpbHMuc3BsaXQzMih0aGlzLmgsICdiaWcnKTtcbn07XG5cbmZ1bmN0aW9uIFNIQTM4NCgpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNIQTM4NCkpXG4gICAgcmV0dXJuIG5ldyBTSEEzODQoKTtcblxuICBTSEE1MTIuY2FsbCh0aGlzKTtcbiAgdGhpcy5oID0gWyAweGNiYmI5ZDVkLCAweGMxMDU5ZWQ4LFxuICAgICAgICAgICAgIDB4NjI5YTI5MmEsIDB4MzY3Y2Q1MDcsXG4gICAgICAgICAgICAgMHg5MTU5MDE1YSwgMHgzMDcwZGQxNyxcbiAgICAgICAgICAgICAweDE1MmZlY2Q4LCAweGY3MGU1OTM5LFxuICAgICAgICAgICAgIDB4NjczMzI2NjcsIDB4ZmZjMDBiMzEsXG4gICAgICAgICAgICAgMHg4ZWI0NGE4NywgMHg2ODU4MTUxMSxcbiAgICAgICAgICAgICAweGRiMGMyZTBkLCAweDY0Zjk4ZmE3LFxuICAgICAgICAgICAgIDB4NDdiNTQ4MWQsIDB4YmVmYTRmYTQgXTtcbn1cbnV0aWxzLmluaGVyaXRzKFNIQTM4NCwgU0hBNTEyKTtcbmV4cG9ydHMuc2hhMzg0ID0gU0hBMzg0O1xuXG5TSEEzODQuYmxvY2tTaXplID0gMTAyNDtcblNIQTM4NC5vdXRTaXplID0gMzg0O1xuU0hBMzg0LmhtYWNTdHJlbmd0aCA9IDE5MjtcblNIQTM4NC5wYWRMZW5ndGggPSAxMjg7XG5cblNIQTM4NC5wcm90b3R5cGUuX2RpZ2VzdCA9IGZ1bmN0aW9uIGRpZ2VzdChlbmMpIHtcbiAgaWYgKGVuYyA9PT0gJ2hleCcpXG4gICAgcmV0dXJuIHV0aWxzLnRvSGV4MzIodGhpcy5oLnNsaWNlKDAsIDEyKSwgJ2JpZycpO1xuICBlbHNlXG4gICAgcmV0dXJuIHV0aWxzLnNwbGl0MzIodGhpcy5oLnNsaWNlKDAsIDEyKSwgJ2JpZycpO1xufTtcblxuZnVuY3Rpb24gU0hBMSgpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNIQTEpKVxuICAgIHJldHVybiBuZXcgU0hBMSgpO1xuXG4gIEJsb2NrSGFzaC5jYWxsKHRoaXMpO1xuICB0aGlzLmggPSBbIDB4Njc0NTIzMDEsIDB4ZWZjZGFiODksIDB4OThiYWRjZmUsXG4gICAgICAgICAgICAgMHgxMDMyNTQ3NiwgMHhjM2QyZTFmMCBdO1xuICB0aGlzLlcgPSBuZXcgQXJyYXkoODApO1xufVxuXG51dGlscy5pbmhlcml0cyhTSEExLCBCbG9ja0hhc2gpO1xuZXhwb3J0cy5zaGExID0gU0hBMTtcblxuU0hBMS5ibG9ja1NpemUgPSA1MTI7XG5TSEExLm91dFNpemUgPSAxNjA7XG5TSEExLmhtYWNTdHJlbmd0aCA9IDgwO1xuU0hBMS5wYWRMZW5ndGggPSA2NDtcblxuU0hBMS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIF91cGRhdGUobXNnLCBzdGFydCkge1xuICB2YXIgVyA9IHRoaXMuVztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyBpKyspXG4gICAgV1tpXSA9IG1zZ1tzdGFydCArIGldO1xuXG4gIGZvcig7IGkgPCBXLmxlbmd0aDsgaSsrKVxuICAgIFdbaV0gPSByb3RsMzIoV1tpIC0gM10gXiBXW2kgLSA4XSBeIFdbaSAtIDE0XSBeIFdbaSAtIDE2XSwgMSk7XG5cbiAgdmFyIGEgPSB0aGlzLmhbMF07XG4gIHZhciBiID0gdGhpcy5oWzFdO1xuICB2YXIgYyA9IHRoaXMuaFsyXTtcbiAgdmFyIGQgPSB0aGlzLmhbM107XG4gIHZhciBlID0gdGhpcy5oWzRdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgVy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzID0gfn4oaSAvIDIwKTtcbiAgICB2YXIgdCA9IHN1bTMyXzUocm90bDMyKGEsIDUpLCBmdF8xKHMsIGIsIGMsIGQpLCBlLCBXW2ldLCBzaGExX0tbc10pO1xuICAgIGUgPSBkO1xuICAgIGQgPSBjO1xuICAgIGMgPSByb3RsMzIoYiwgMzApO1xuICAgIGIgPSBhO1xuICAgIGEgPSB0O1xuICB9XG5cbiAgdGhpcy5oWzBdID0gc3VtMzIodGhpcy5oWzBdLCBhKTtcbiAgdGhpcy5oWzFdID0gc3VtMzIodGhpcy5oWzFdLCBiKTtcbiAgdGhpcy5oWzJdID0gc3VtMzIodGhpcy5oWzJdLCBjKTtcbiAgdGhpcy5oWzNdID0gc3VtMzIodGhpcy5oWzNdLCBkKTtcbiAgdGhpcy5oWzRdID0gc3VtMzIodGhpcy5oWzRdLCBlKTtcbn07XG5cblNIQTEucHJvdG90eXBlLl9kaWdlc3QgPSBmdW5jdGlvbiBkaWdlc3QoZW5jKSB7XG4gIGlmIChlbmMgPT09ICdoZXgnKVxuICAgIHJldHVybiB1dGlscy50b0hleDMyKHRoaXMuaCwgJ2JpZycpO1xuICBlbHNlXG4gICAgcmV0dXJuIHV0aWxzLnNwbGl0MzIodGhpcy5oLCAnYmlnJyk7XG59O1xuXG5mdW5jdGlvbiBjaDMyKHgsIHksIHopIHtcbiAgcmV0dXJuICh4ICYgeSkgXiAoKH54KSAmIHopO1xufVxuXG5mdW5jdGlvbiBtYWozMih4LCB5LCB6KSB7XG4gIHJldHVybiAoeCAmIHkpIF4gKHggJiB6KSBeICh5ICYgeik7XG59XG5cbmZ1bmN0aW9uIHAzMih4LCB5LCB6KSB7XG4gIHJldHVybiB4IF4geSBeIHo7XG59XG5cbmZ1bmN0aW9uIHMwXzI1Nih4KSB7XG4gIHJldHVybiByb3RyMzIoeCwgMikgXiByb3RyMzIoeCwgMTMpIF4gcm90cjMyKHgsIDIyKTtcbn1cblxuZnVuY3Rpb24gczFfMjU2KHgpIHtcbiAgcmV0dXJuIHJvdHIzMih4LCA2KSBeIHJvdHIzMih4LCAxMSkgXiByb3RyMzIoeCwgMjUpO1xufVxuXG5mdW5jdGlvbiBnMF8yNTYoeCkge1xuICByZXR1cm4gcm90cjMyKHgsIDcpIF4gcm90cjMyKHgsIDE4KSBeICh4ID4+PiAzKTtcbn1cblxuZnVuY3Rpb24gZzFfMjU2KHgpIHtcbiAgcmV0dXJuIHJvdHIzMih4LCAxNykgXiByb3RyMzIoeCwgMTkpIF4gKHggPj4+IDEwKTtcbn1cblxuZnVuY3Rpb24gZnRfMShzLCB4LCB5LCB6KSB7XG4gIGlmIChzID09PSAwKVxuICAgIHJldHVybiBjaDMyKHgsIHksIHopO1xuICBpZiAocyA9PT0gMSB8fCBzID09PSAzKVxuICAgIHJldHVybiBwMzIoeCwgeSwgeik7XG4gIGlmIChzID09PSAyKVxuICAgIHJldHVybiBtYWozMih4LCB5LCB6KTtcbn1cblxuZnVuY3Rpb24gY2g2NF9oaSh4aCwgeGwsIHloLCB5bCwgemgsIHpsKSB7XG4gIHZhciByID0gKHhoICYgeWgpIF4gKCh+eGgpICYgemgpO1xuICBpZiAociA8IDApXG4gICAgciArPSAweDEwMDAwMDAwMDtcbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIGNoNjRfbG8oeGgsIHhsLCB5aCwgeWwsIHpoLCB6bCkge1xuICB2YXIgciA9ICh4bCAmIHlsKSBeICgofnhsKSAmIHpsKTtcbiAgaWYgKHIgPCAwKVxuICAgIHIgKz0gMHgxMDAwMDAwMDA7XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBtYWo2NF9oaSh4aCwgeGwsIHloLCB5bCwgemgsIHpsKSB7XG4gIHZhciByID0gKHhoICYgeWgpIF4gKHhoICYgemgpIF4gKHloICYgemgpO1xuICBpZiAociA8IDApXG4gICAgciArPSAweDEwMDAwMDAwMDtcbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIG1hajY0X2xvKHhoLCB4bCwgeWgsIHlsLCB6aCwgemwpIHtcbiAgdmFyIHIgPSAoeGwgJiB5bCkgXiAoeGwgJiB6bCkgXiAoeWwgJiB6bCk7XG4gIGlmIChyIDwgMClcbiAgICByICs9IDB4MTAwMDAwMDAwO1xuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gczBfNTEyX2hpKHhoLCB4bCkge1xuICB2YXIgYzBfaGkgPSByb3RyNjRfaGkoeGgsIHhsLCAyOCk7XG4gIHZhciBjMV9oaSA9IHJvdHI2NF9oaSh4bCwgeGgsIDIpOyAgLy8gMzRcbiAgdmFyIGMyX2hpID0gcm90cjY0X2hpKHhsLCB4aCwgNyk7ICAvLyAzOVxuXG4gIHZhciByID0gYzBfaGkgXiBjMV9oaSBeIGMyX2hpO1xuICBpZiAociA8IDApXG4gICAgciArPSAweDEwMDAwMDAwMDtcbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIHMwXzUxMl9sbyh4aCwgeGwpIHtcbiAgdmFyIGMwX2xvID0gcm90cjY0X2xvKHhoLCB4bCwgMjgpO1xuICB2YXIgYzFfbG8gPSByb3RyNjRfbG8oeGwsIHhoLCAyKTsgIC8vIDM0XG4gIHZhciBjMl9sbyA9IHJvdHI2NF9sbyh4bCwgeGgsIDcpOyAgLy8gMzlcblxuICB2YXIgciA9IGMwX2xvIF4gYzFfbG8gXiBjMl9sbztcbiAgaWYgKHIgPCAwKVxuICAgIHIgKz0gMHgxMDAwMDAwMDA7XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBzMV81MTJfaGkoeGgsIHhsKSB7XG4gIHZhciBjMF9oaSA9IHJvdHI2NF9oaSh4aCwgeGwsIDE0KTtcbiAgdmFyIGMxX2hpID0gcm90cjY0X2hpKHhoLCB4bCwgMTgpO1xuICB2YXIgYzJfaGkgPSByb3RyNjRfaGkoeGwsIHhoLCA5KTsgIC8vIDQxXG5cbiAgdmFyIHIgPSBjMF9oaSBeIGMxX2hpIF4gYzJfaGk7XG4gIGlmIChyIDwgMClcbiAgICByICs9IDB4MTAwMDAwMDAwO1xuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gczFfNTEyX2xvKHhoLCB4bCkge1xuICB2YXIgYzBfbG8gPSByb3RyNjRfbG8oeGgsIHhsLCAxNCk7XG4gIHZhciBjMV9sbyA9IHJvdHI2NF9sbyh4aCwgeGwsIDE4KTtcbiAgdmFyIGMyX2xvID0gcm90cjY0X2xvKHhsLCB4aCwgOSk7ICAvLyA0MVxuXG4gIHZhciByID0gYzBfbG8gXiBjMV9sbyBeIGMyX2xvO1xuICBpZiAociA8IDApXG4gICAgciArPSAweDEwMDAwMDAwMDtcbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIGcwXzUxMl9oaSh4aCwgeGwpIHtcbiAgdmFyIGMwX2hpID0gcm90cjY0X2hpKHhoLCB4bCwgMSk7XG4gIHZhciBjMV9oaSA9IHJvdHI2NF9oaSh4aCwgeGwsIDgpO1xuICB2YXIgYzJfaGkgPSBzaHI2NF9oaSh4aCwgeGwsIDcpO1xuXG4gIHZhciByID0gYzBfaGkgXiBjMV9oaSBeIGMyX2hpO1xuICBpZiAociA8IDApXG4gICAgciArPSAweDEwMDAwMDAwMDtcbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIGcwXzUxMl9sbyh4aCwgeGwpIHtcbiAgdmFyIGMwX2xvID0gcm90cjY0X2xvKHhoLCB4bCwgMSk7XG4gIHZhciBjMV9sbyA9IHJvdHI2NF9sbyh4aCwgeGwsIDgpO1xuICB2YXIgYzJfbG8gPSBzaHI2NF9sbyh4aCwgeGwsIDcpO1xuXG4gIHZhciByID0gYzBfbG8gXiBjMV9sbyBeIGMyX2xvO1xuICBpZiAociA8IDApXG4gICAgciArPSAweDEwMDAwMDAwMDtcbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIGcxXzUxMl9oaSh4aCwgeGwpIHtcbiAgdmFyIGMwX2hpID0gcm90cjY0X2hpKHhoLCB4bCwgMTkpO1xuICB2YXIgYzFfaGkgPSByb3RyNjRfaGkoeGwsIHhoLCAyOSk7ICAvLyA2MVxuICB2YXIgYzJfaGkgPSBzaHI2NF9oaSh4aCwgeGwsIDYpO1xuXG4gIHZhciByID0gYzBfaGkgXiBjMV9oaSBeIGMyX2hpO1xuICBpZiAociA8IDApXG4gICAgciArPSAweDEwMDAwMDAwMDtcbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIGcxXzUxMl9sbyh4aCwgeGwpIHtcbiAgdmFyIGMwX2xvID0gcm90cjY0X2xvKHhoLCB4bCwgMTkpO1xuICB2YXIgYzFfbG8gPSByb3RyNjRfbG8oeGwsIHhoLCAyOSk7ICAvLyA2MVxuICB2YXIgYzJfbG8gPSBzaHI2NF9sbyh4aCwgeGwsIDYpO1xuXG4gIHZhciByID0gYzBfbG8gXiBjMV9sbyBeIGMyX2xvO1xuICBpZiAociA8IDApXG4gICAgciArPSAweDEwMDAwMDAwMDtcbiAgcmV0dXJuIHI7XG59XG4iLCJ2YXIgdXRpbHMgPSBleHBvcnRzO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuZnVuY3Rpb24gdG9BcnJheShtc2csIGVuYykge1xuICBpZiAoQXJyYXkuaXNBcnJheShtc2cpKVxuICAgIHJldHVybiBtc2cuc2xpY2UoKTtcbiAgaWYgKCFtc2cpXG4gICAgcmV0dXJuIFtdO1xuICB2YXIgcmVzID0gW107XG4gIGlmICh0eXBlb2YgbXNnID09PSAnc3RyaW5nJykge1xuICAgIGlmICghZW5jKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYyA9IG1zZy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB2YXIgaGkgPSBjID4+IDg7XG4gICAgICAgIHZhciBsbyA9IGMgJiAweGZmO1xuICAgICAgICBpZiAoaGkpXG4gICAgICAgICAgcmVzLnB1c2goaGksIGxvKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHJlcy5wdXNoKGxvKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVuYyA9PT0gJ2hleCcpIHtcbiAgICAgIG1zZyA9IG1zZy5yZXBsYWNlKC9bXmEtejAtOV0rL2lnLCAnJyk7XG4gICAgICBpZiAobXNnLmxlbmd0aCAlIDIgIT09IDApXG4gICAgICAgIG1zZyA9ICcwJyArIG1zZztcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSArPSAyKVxuICAgICAgICByZXMucHVzaChwYXJzZUludChtc2dbaV0gKyBtc2dbaSArIDFdLCAxNikpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKylcbiAgICAgIHJlc1tpXSA9IG1zZ1tpXSB8IDA7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cbnV0aWxzLnRvQXJyYXkgPSB0b0FycmF5O1xuXG5mdW5jdGlvbiB0b0hleChtc2cpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKylcbiAgICByZXMgKz0gemVybzIobXNnW2ldLnRvU3RyaW5nKDE2KSk7XG4gIHJldHVybiByZXM7XG59XG51dGlscy50b0hleCA9IHRvSGV4O1xuXG5mdW5jdGlvbiBodG9ubCh3KSB7XG4gIHZhciByZXMgPSAodyA+Pj4gMjQpIHxcbiAgICAgICAgICAgICgodyA+Pj4gOCkgJiAweGZmMDApIHxcbiAgICAgICAgICAgICgodyA8PCA4KSAmIDB4ZmYwMDAwKSB8XG4gICAgICAgICAgICAoKHcgJiAweGZmKSA8PCAyNCk7XG4gIHJldHVybiByZXMgPj4+IDA7XG59XG51dGlscy5odG9ubCA9IGh0b25sO1xuXG5mdW5jdGlvbiB0b0hleDMyKG1zZywgZW5kaWFuKSB7XG4gIHZhciByZXMgPSAnJztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdyA9IG1zZ1tpXTtcbiAgICBpZiAoZW5kaWFuID09PSAnbGl0dGxlJylcbiAgICAgIHcgPSBodG9ubCh3KTtcbiAgICByZXMgKz0gemVybzgody50b1N0cmluZygxNikpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG51dGlscy50b0hleDMyID0gdG9IZXgzMjtcblxuZnVuY3Rpb24gemVybzIod29yZCkge1xuICBpZiAod29yZC5sZW5ndGggPT09IDEpXG4gICAgcmV0dXJuICcwJyArIHdvcmQ7XG4gIGVsc2VcbiAgICByZXR1cm4gd29yZDtcbn1cbnV0aWxzLnplcm8yID0gemVybzI7XG5cbmZ1bmN0aW9uIHplcm84KHdvcmQpIHtcbiAgaWYgKHdvcmQubGVuZ3RoID09PSA3KVxuICAgIHJldHVybiAnMCcgKyB3b3JkO1xuICBlbHNlIGlmICh3b3JkLmxlbmd0aCA9PT0gNilcbiAgICByZXR1cm4gJzAwJyArIHdvcmQ7XG4gIGVsc2UgaWYgKHdvcmQubGVuZ3RoID09PSA1KVxuICAgIHJldHVybiAnMDAwJyArIHdvcmQ7XG4gIGVsc2UgaWYgKHdvcmQubGVuZ3RoID09PSA0KVxuICAgIHJldHVybiAnMDAwMCcgKyB3b3JkO1xuICBlbHNlIGlmICh3b3JkLmxlbmd0aCA9PT0gMylcbiAgICByZXR1cm4gJzAwMDAwJyArIHdvcmQ7XG4gIGVsc2UgaWYgKHdvcmQubGVuZ3RoID09PSAyKVxuICAgIHJldHVybiAnMDAwMDAwJyArIHdvcmQ7XG4gIGVsc2UgaWYgKHdvcmQubGVuZ3RoID09PSAxKVxuICAgIHJldHVybiAnMDAwMDAwMCcgKyB3b3JkO1xuICBlbHNlXG4gICAgcmV0dXJuIHdvcmQ7XG59XG51dGlscy56ZXJvOCA9IHplcm84O1xuXG5mdW5jdGlvbiBqb2luMzIobXNnLCBzdGFydCwgZW5kLCBlbmRpYW4pIHtcbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0O1xuICBhc3NlcnQobGVuICUgNCA9PT0gMCk7XG4gIHZhciByZXMgPSBuZXcgQXJyYXkobGVuIC8gNCk7XG4gIGZvciAodmFyIGkgPSAwLCBrID0gc3RhcnQ7IGkgPCByZXMubGVuZ3RoOyBpKyssIGsgKz0gNCkge1xuICAgIHZhciB3O1xuICAgIGlmIChlbmRpYW4gPT09ICdiaWcnKVxuICAgICAgdyA9IChtc2dba10gPDwgMjQpIHwgKG1zZ1trICsgMV0gPDwgMTYpIHwgKG1zZ1trICsgMl0gPDwgOCkgfCBtc2dbayArIDNdO1xuICAgIGVsc2VcbiAgICAgIHcgPSAobXNnW2sgKyAzXSA8PCAyNCkgfCAobXNnW2sgKyAyXSA8PCAxNikgfCAobXNnW2sgKyAxXSA8PCA4KSB8IG1zZ1trXTtcbiAgICByZXNbaV0gPSB3ID4+PiAwO1xuICB9XG4gIHJldHVybiByZXM7XG59XG51dGlscy5qb2luMzIgPSBqb2luMzI7XG5cbmZ1bmN0aW9uIHNwbGl0MzIobXNnLCBlbmRpYW4pIHtcbiAgdmFyIHJlcyA9IG5ldyBBcnJheShtc2cubGVuZ3RoICogNCk7XG4gIGZvciAodmFyIGkgPSAwLCBrID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKywgayArPSA0KSB7XG4gICAgdmFyIG0gPSBtc2dbaV07XG4gICAgaWYgKGVuZGlhbiA9PT0gJ2JpZycpIHtcbiAgICAgIHJlc1trXSA9IG0gPj4+IDI0O1xuICAgICAgcmVzW2sgKyAxXSA9IChtID4+PiAxNikgJiAweGZmO1xuICAgICAgcmVzW2sgKyAyXSA9IChtID4+PiA4KSAmIDB4ZmY7XG4gICAgICByZXNbayArIDNdID0gbSAmIDB4ZmY7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc1trICsgM10gPSBtID4+PiAyNDtcbiAgICAgIHJlc1trICsgMl0gPSAobSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgIHJlc1trICsgMV0gPSAobSA+Pj4gOCkgJiAweGZmO1xuICAgICAgcmVzW2tdID0gbSAmIDB4ZmY7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59XG51dGlscy5zcGxpdDMyID0gc3BsaXQzMjtcblxuZnVuY3Rpb24gcm90cjMyKHcsIGIpIHtcbiAgcmV0dXJuICh3ID4+PiBiKSB8ICh3IDw8ICgzMiAtIGIpKTtcbn1cbnV0aWxzLnJvdHIzMiA9IHJvdHIzMjtcblxuZnVuY3Rpb24gcm90bDMyKHcsIGIpIHtcbiAgcmV0dXJuICh3IDw8IGIpIHwgKHcgPj4+ICgzMiAtIGIpKTtcbn1cbnV0aWxzLnJvdGwzMiA9IHJvdGwzMjtcblxuZnVuY3Rpb24gc3VtMzIoYSwgYikge1xuICByZXR1cm4gKGEgKyBiKSA+Pj4gMDtcbn1cbnV0aWxzLnN1bTMyID0gc3VtMzI7XG5cbmZ1bmN0aW9uIHN1bTMyXzMoYSwgYiwgYykge1xuICByZXR1cm4gKGEgKyBiICsgYykgPj4+IDA7XG59XG51dGlscy5zdW0zMl8zID0gc3VtMzJfMztcblxuZnVuY3Rpb24gc3VtMzJfNChhLCBiLCBjLCBkKSB7XG4gIHJldHVybiAoYSArIGIgKyBjICsgZCkgPj4+IDA7XG59XG51dGlscy5zdW0zMl80ID0gc3VtMzJfNDtcblxuZnVuY3Rpb24gc3VtMzJfNShhLCBiLCBjLCBkLCBlKSB7XG4gIHJldHVybiAoYSArIGIgKyBjICsgZCArIGUpID4+PiAwO1xufVxudXRpbHMuc3VtMzJfNSA9IHN1bTMyXzU7XG5cbmZ1bmN0aW9uIGFzc2VydChjb25kLCBtc2cpIHtcbiAgaWYgKCFjb25kKVxuICAgIHRocm93IG5ldyBFcnJvcihtc2cgfHwgJ0Fzc2VydGlvbiBmYWlsZWQnKTtcbn1cbnV0aWxzLmFzc2VydCA9IGFzc2VydDtcblxudXRpbHMuaW5oZXJpdHMgPSBpbmhlcml0cztcblxuZnVuY3Rpb24gc3VtNjQoYnVmLCBwb3MsIGFoLCBhbCkge1xuICB2YXIgYmggPSBidWZbcG9zXTtcbiAgdmFyIGJsID0gYnVmW3BvcyArIDFdO1xuXG4gIHZhciBsbyA9IChhbCArIGJsKSA+Pj4gMDtcbiAgdmFyIGhpID0gKGxvIDwgYWwgPyAxIDogMCkgKyBhaCArIGJoO1xuICBidWZbcG9zXSA9IGhpID4+PiAwO1xuICBidWZbcG9zICsgMV0gPSBsbztcbn1cbmV4cG9ydHMuc3VtNjQgPSBzdW02NDtcblxuZnVuY3Rpb24gc3VtNjRfaGkoYWgsIGFsLCBiaCwgYmwpIHtcbiAgdmFyIGxvID0gKGFsICsgYmwpID4+PiAwO1xuICB2YXIgaGkgPSAobG8gPCBhbCA/IDEgOiAwKSArIGFoICsgYmg7XG4gIHJldHVybiBoaSA+Pj4gMDtcbn07XG5leHBvcnRzLnN1bTY0X2hpID0gc3VtNjRfaGk7XG5cbmZ1bmN0aW9uIHN1bTY0X2xvKGFoLCBhbCwgYmgsIGJsKSB7XG4gIHZhciBsbyA9IGFsICsgYmw7XG4gIHJldHVybiBsbyA+Pj4gMDtcbn07XG5leHBvcnRzLnN1bTY0X2xvID0gc3VtNjRfbG87XG5cbmZ1bmN0aW9uIHN1bTY0XzRfaGkoYWgsIGFsLCBiaCwgYmwsIGNoLCBjbCwgZGgsIGRsKSB7XG4gIHZhciBjYXJyeSA9IDA7XG4gIHZhciBsbyA9IGFsO1xuICBsbyA9IChsbyArIGJsKSA+Pj4gMDtcbiAgY2FycnkgKz0gbG8gPCBhbCA/IDEgOiAwO1xuICBsbyA9IChsbyArIGNsKSA+Pj4gMDtcbiAgY2FycnkgKz0gbG8gPCBjbCA/IDEgOiAwO1xuICBsbyA9IChsbyArIGRsKSA+Pj4gMDtcbiAgY2FycnkgKz0gbG8gPCBkbCA/IDEgOiAwO1xuXG4gIHZhciBoaSA9IGFoICsgYmggKyBjaCArIGRoICsgY2Fycnk7XG4gIHJldHVybiBoaSA+Pj4gMDtcbn07XG5leHBvcnRzLnN1bTY0XzRfaGkgPSBzdW02NF80X2hpO1xuXG5mdW5jdGlvbiBzdW02NF80X2xvKGFoLCBhbCwgYmgsIGJsLCBjaCwgY2wsIGRoLCBkbCkge1xuICB2YXIgbG8gPSBhbCArIGJsICsgY2wgKyBkbDtcbiAgcmV0dXJuIGxvID4+PiAwO1xufTtcbmV4cG9ydHMuc3VtNjRfNF9sbyA9IHN1bTY0XzRfbG87XG5cbmZ1bmN0aW9uIHN1bTY0XzVfaGkoYWgsIGFsLCBiaCwgYmwsIGNoLCBjbCwgZGgsIGRsLCBlaCwgZWwpIHtcbiAgdmFyIGNhcnJ5ID0gMDtcbiAgdmFyIGxvID0gYWw7XG4gIGxvID0gKGxvICsgYmwpID4+PiAwO1xuICBjYXJyeSArPSBsbyA8IGFsID8gMSA6IDA7XG4gIGxvID0gKGxvICsgY2wpID4+PiAwO1xuICBjYXJyeSArPSBsbyA8IGNsID8gMSA6IDA7XG4gIGxvID0gKGxvICsgZGwpID4+PiAwO1xuICBjYXJyeSArPSBsbyA8IGRsID8gMSA6IDA7XG4gIGxvID0gKGxvICsgZWwpID4+PiAwO1xuICBjYXJyeSArPSBsbyA8IGVsID8gMSA6IDA7XG5cbiAgdmFyIGhpID0gYWggKyBiaCArIGNoICsgZGggKyBlaCArIGNhcnJ5O1xuICByZXR1cm4gaGkgPj4+IDA7XG59O1xuZXhwb3J0cy5zdW02NF81X2hpID0gc3VtNjRfNV9oaTtcblxuZnVuY3Rpb24gc3VtNjRfNV9sbyhhaCwgYWwsIGJoLCBibCwgY2gsIGNsLCBkaCwgZGwsIGVoLCBlbCkge1xuICB2YXIgbG8gPSBhbCArIGJsICsgY2wgKyBkbCArIGVsO1xuXG4gIHJldHVybiBsbyA+Pj4gMDtcbn07XG5leHBvcnRzLnN1bTY0XzVfbG8gPSBzdW02NF81X2xvO1xuXG5mdW5jdGlvbiByb3RyNjRfaGkoYWgsIGFsLCBudW0pIHtcbiAgdmFyIHIgPSAoYWwgPDwgKDMyIC0gbnVtKSkgfCAoYWggPj4+IG51bSk7XG4gIHJldHVybiByID4+PiAwO1xufTtcbmV4cG9ydHMucm90cjY0X2hpID0gcm90cjY0X2hpO1xuXG5mdW5jdGlvbiByb3RyNjRfbG8oYWgsIGFsLCBudW0pIHtcbiAgdmFyIHIgPSAoYWggPDwgKDMyIC0gbnVtKSkgfCAoYWwgPj4+IG51bSk7XG4gIHJldHVybiByID4+PiAwO1xufTtcbmV4cG9ydHMucm90cjY0X2xvID0gcm90cjY0X2xvO1xuXG5mdW5jdGlvbiBzaHI2NF9oaShhaCwgYWwsIG51bSkge1xuICByZXR1cm4gYWggPj4+IG51bTtcbn07XG5leHBvcnRzLnNocjY0X2hpID0gc2hyNjRfaGk7XG5cbmZ1bmN0aW9uIHNocjY0X2xvKGFoLCBhbCwgbnVtKSB7XG4gIHZhciByID0gKGFoIDw8ICgzMiAtIG51bSkpIHwgKGFsID4+PiBudW0pO1xuICByZXR1cm4gciA+Pj4gMDtcbn07XG5leHBvcnRzLnNocjY0X2xvID0gc2hyNjRfbG87XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwibmFtZVwiOiBcImVsbGlwdGljXCIsXG4gIFwidmVyc2lvblwiOiBcIjYuMC4yXCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJFQyBjcnlwdG9ncmFwaHlcIixcbiAgXCJtYWluXCI6IFwibGliL2VsbGlwdGljLmpzXCIsXG4gIFwiZmlsZXNcIjogW1xuICAgIFwibGliXCJcbiAgXSxcbiAgXCJzY3JpcHRzXCI6IHtcbiAgICBcInRlc3RcIjogXCJtYWtlIGxpbnQgJiYgaXN0YW5idWwgdGVzdCBfbW9jaGEgLS1yZXBvcnRlcj1zcGVjIHRlc3QvKi10ZXN0LmpzXCIsXG4gICAgXCJjb3ZlcmFsbHNcIjogXCJjYXQgLi9jb3ZlcmFnZS9sY292LmluZm8gfCBjb3ZlcmFsbHNcIlxuICB9LFxuICBcInJlcG9zaXRvcnlcIjoge1xuICAgIFwidHlwZVwiOiBcImdpdFwiLFxuICAgIFwidXJsXCI6IFwiZ2l0K3NzaDovL2dpdEBnaXRodWIuY29tL2luZHV0bnkvZWxsaXB0aWMuZ2l0XCJcbiAgfSxcbiAgXCJrZXl3b3Jkc1wiOiBbXG4gICAgXCJFQ1wiLFxuICAgIFwiRWxsaXB0aWNcIixcbiAgICBcImN1cnZlXCIsXG4gICAgXCJDcnlwdG9ncmFwaHlcIlxuICBdLFxuICBcImF1dGhvclwiOiB7XG4gICAgXCJuYW1lXCI6IFwiRmVkb3IgSW5kdXRueVwiLFxuICAgIFwiZW1haWxcIjogXCJmZWRvckBpbmR1dG55LmNvbVwiXG4gIH0sXG4gIFwibGljZW5zZVwiOiBcIk1JVFwiLFxuICBcImJ1Z3NcIjoge1xuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvZWxsaXB0aWMvaXNzdWVzXCJcbiAgfSxcbiAgXCJob21lcGFnZVwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9pbmR1dG55L2VsbGlwdGljXCIsXG4gIFwiZGV2RGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcImJyb3dzZXJpZnlcIjogXCJeMy40NC4yXCIsXG4gICAgXCJjb3ZlcmFsbHNcIjogXCJeMi4xMS4zXCIsXG4gICAgXCJpc3RhbmJ1bFwiOiBcIl4wLjMuMTdcIixcbiAgICBcImpzY3NcIjogXCJeMS4xMS4zXCIsXG4gICAgXCJqc2hpbnRcIjogXCJeMi42LjBcIixcbiAgICBcIm1vY2hhXCI6IFwiXjIuMS4wXCIsXG4gICAgXCJ1Z2xpZnktanNcIjogXCJeMi40LjEzXCJcbiAgfSxcbiAgXCJkZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiYm4uanNcIjogXCJeNC4wLjBcIixcbiAgICBcImJyb3JhbmRcIjogXCJeMS4wLjFcIixcbiAgICBcImhhc2guanNcIjogXCJeMS4wLjBcIixcbiAgICBcImluaGVyaXRzXCI6IFwiXjIuMC4xXCJcbiAgfSxcbiAgXCJnaXRIZWFkXCI6IFwiMzMwMTA2ZGExODY3MTJkMjI4ZDc5YmM3MWFlOGU3ZTY4NTY1ZmE5ZFwiLFxuICBcIl9pZFwiOiBcImVsbGlwdGljQDYuMC4yXCIsXG4gIFwiX3NoYXN1bVwiOiBcIjIxOWI5NmNkOTJhYTk4ODVkOTFkMzFjMWZkNDJlYWE1ZWI0NDgzYTlcIixcbiAgXCJfZnJvbVwiOiBcImVsbGlwdGljQD49Ni4wLjAgPDcuMC4wXCIsXG4gIFwiX25wbVZlcnNpb25cIjogXCIzLjMuNlwiLFxuICBcIl9ub2RlVmVyc2lvblwiOiBcIjUuMC4wXCIsXG4gIFwiX25wbVVzZXJcIjoge1xuICAgIFwibmFtZVwiOiBcImluZHV0bnlcIixcbiAgICBcImVtYWlsXCI6IFwiZmVkb3JAaW5kdXRueS5jb21cIlxuICB9LFxuICBcImRpc3RcIjoge1xuICAgIFwic2hhc3VtXCI6IFwiMjE5Yjk2Y2Q5MmFhOTg4NWQ5MWQzMWMxZmQ0MmVhYTVlYjQ0ODNhOVwiLFxuICAgIFwidGFyYmFsbFwiOiBcImh0dHA6Ly9yZWdpc3RyeS5ucG1qcy5vcmcvZWxsaXB0aWMvLS9lbGxpcHRpYy02LjAuMi50Z3pcIlxuICB9LFxuICBcIm1haW50YWluZXJzXCI6IFtcbiAgICB7XG4gICAgICBcIm5hbWVcIjogXCJpbmR1dG55XCIsXG4gICAgICBcImVtYWlsXCI6IFwiZmVkb3JAaW5kdXRueS5jb21cIlxuICAgIH1cbiAgXSxcbiAgXCJkaXJlY3Rvcmllc1wiOiB7fSxcbiAgXCJfcmVzb2x2ZWRcIjogXCJodHRwczovL3JlZ2lzdHJ5Lm5wbWpzLm9yZy9lbGxpcHRpYy8tL2VsbGlwdGljLTYuMC4yLnRnelwiLFxuICBcInJlYWRtZVwiOiBcIkVSUk9SOiBObyBSRUFETUUgZGF0YSBmb3VuZCFcIlxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1wiMi4xNi44NDAuMS4xMDEuMy40LjEuMVwiOiBcImFlcy0xMjgtZWNiXCIsXG5cIjIuMTYuODQwLjEuMTAxLjMuNC4xLjJcIjogXCJhZXMtMTI4LWNiY1wiLFxuXCIyLjE2Ljg0MC4xLjEwMS4zLjQuMS4zXCI6IFwiYWVzLTEyOC1vZmJcIixcblwiMi4xNi44NDAuMS4xMDEuMy40LjEuNFwiOiBcImFlcy0xMjgtY2ZiXCIsXG5cIjIuMTYuODQwLjEuMTAxLjMuNC4xLjIxXCI6IFwiYWVzLTE5Mi1lY2JcIixcblwiMi4xNi44NDAuMS4xMDEuMy40LjEuMjJcIjogXCJhZXMtMTkyLWNiY1wiLFxuXCIyLjE2Ljg0MC4xLjEwMS4zLjQuMS4yM1wiOiBcImFlcy0xOTItb2ZiXCIsXG5cIjIuMTYuODQwLjEuMTAxLjMuNC4xLjI0XCI6IFwiYWVzLTE5Mi1jZmJcIixcblwiMi4xNi44NDAuMS4xMDEuMy40LjEuNDFcIjogXCJhZXMtMjU2LWVjYlwiLFxuXCIyLjE2Ljg0MC4xLjEwMS4zLjQuMS40MlwiOiBcImFlcy0yNTYtY2JjXCIsXG5cIjIuMTYuODQwLjEuMTAxLjMuNC4xLjQzXCI6IFwiYWVzLTI1Ni1vZmJcIixcblwiMi4xNi44NDAuMS4xMDEuMy40LjEuNDRcIjogXCJhZXMtMjU2LWNmYlwiXG59IiwiLy8gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vaW5kdXRueS9zZWxmLXNpZ25lZC9ibG9iL2doLXBhZ2VzL2xpYi9hc24xLmpzXG4vLyBGZWRvciwgeW91IGFyZSBhbWF6aW5nLlxuXG52YXIgYXNuMSA9IHJlcXVpcmUoJ2FzbjEuanMnKVxuXG52YXIgUlNBUHJpdmF0ZUtleSA9IGFzbjEuZGVmaW5lKCdSU0FQcml2YXRlS2V5JywgZnVuY3Rpb24gKCkge1xuICB0aGlzLnNlcSgpLm9iaihcbiAgICB0aGlzLmtleSgndmVyc2lvbicpLmludCgpLFxuICAgIHRoaXMua2V5KCdtb2R1bHVzJykuaW50KCksXG4gICAgdGhpcy5rZXkoJ3B1YmxpY0V4cG9uZW50JykuaW50KCksXG4gICAgdGhpcy5rZXkoJ3ByaXZhdGVFeHBvbmVudCcpLmludCgpLFxuICAgIHRoaXMua2V5KCdwcmltZTEnKS5pbnQoKSxcbiAgICB0aGlzLmtleSgncHJpbWUyJykuaW50KCksXG4gICAgdGhpcy5rZXkoJ2V4cG9uZW50MScpLmludCgpLFxuICAgIHRoaXMua2V5KCdleHBvbmVudDInKS5pbnQoKSxcbiAgICB0aGlzLmtleSgnY29lZmZpY2llbnQnKS5pbnQoKVxuICApXG59KVxuZXhwb3J0cy5SU0FQcml2YXRlS2V5ID0gUlNBUHJpdmF0ZUtleVxuXG52YXIgUlNBUHVibGljS2V5ID0gYXNuMS5kZWZpbmUoJ1JTQVB1YmxpY0tleScsIGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zZXEoKS5vYmooXG4gICAgdGhpcy5rZXkoJ21vZHVsdXMnKS5pbnQoKSxcbiAgICB0aGlzLmtleSgncHVibGljRXhwb25lbnQnKS5pbnQoKVxuICApXG59KVxuZXhwb3J0cy5SU0FQdWJsaWNLZXkgPSBSU0FQdWJsaWNLZXlcblxudmFyIFB1YmxpY0tleSA9IGFzbjEuZGVmaW5lKCdTdWJqZWN0UHVibGljS2V5SW5mbycsIGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zZXEoKS5vYmooXG4gICAgdGhpcy5rZXkoJ2FsZ29yaXRobScpLnVzZShBbGdvcml0aG1JZGVudGlmaWVyKSxcbiAgICB0aGlzLmtleSgnc3ViamVjdFB1YmxpY0tleScpLmJpdHN0cigpXG4gIClcbn0pXG5leHBvcnRzLlB1YmxpY0tleSA9IFB1YmxpY0tleVxuXG52YXIgQWxnb3JpdGhtSWRlbnRpZmllciA9IGFzbjEuZGVmaW5lKCdBbGdvcml0aG1JZGVudGlmaWVyJywgZnVuY3Rpb24gKCkge1xuICB0aGlzLnNlcSgpLm9iaihcbiAgICB0aGlzLmtleSgnYWxnb3JpdGhtJykub2JqaWQoKSxcbiAgICB0aGlzLmtleSgnbm9uZScpLm51bGxfKCkub3B0aW9uYWwoKSxcbiAgICB0aGlzLmtleSgnY3VydmUnKS5vYmppZCgpLm9wdGlvbmFsKCksXG4gICAgdGhpcy5rZXkoJ3BhcmFtcycpLnNlcSgpLm9iaihcbiAgICAgIHRoaXMua2V5KCdwJykuaW50KCksXG4gICAgICB0aGlzLmtleSgncScpLmludCgpLFxuICAgICAgdGhpcy5rZXkoJ2cnKS5pbnQoKVxuICAgICkub3B0aW9uYWwoKVxuICApXG59KVxuXG52YXIgUHJpdmF0ZUtleUluZm8gPSBhc24xLmRlZmluZSgnUHJpdmF0ZUtleUluZm8nLCBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc2VxKCkub2JqKFxuICAgIHRoaXMua2V5KCd2ZXJzaW9uJykuaW50KCksXG4gICAgdGhpcy5rZXkoJ2FsZ29yaXRobScpLnVzZShBbGdvcml0aG1JZGVudGlmaWVyKSxcbiAgICB0aGlzLmtleSgnc3ViamVjdFByaXZhdGVLZXknKS5vY3RzdHIoKVxuICApXG59KVxuZXhwb3J0cy5Qcml2YXRlS2V5ID0gUHJpdmF0ZUtleUluZm9cbnZhciBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mbyA9IGFzbjEuZGVmaW5lKCdFbmNyeXB0ZWRQcml2YXRlS2V5SW5mbycsIGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zZXEoKS5vYmooXG4gICAgdGhpcy5rZXkoJ2FsZ29yaXRobScpLnNlcSgpLm9iaihcbiAgICAgIHRoaXMua2V5KCdpZCcpLm9iamlkKCksXG4gICAgICB0aGlzLmtleSgnZGVjcnlwdCcpLnNlcSgpLm9iaihcbiAgICAgICAgdGhpcy5rZXkoJ2tkZScpLnNlcSgpLm9iaihcbiAgICAgICAgICB0aGlzLmtleSgnaWQnKS5vYmppZCgpLFxuICAgICAgICAgIHRoaXMua2V5KCdrZGVwYXJhbXMnKS5zZXEoKS5vYmooXG4gICAgICAgICAgICB0aGlzLmtleSgnc2FsdCcpLm9jdHN0cigpLFxuICAgICAgICAgICAgdGhpcy5rZXkoJ2l0ZXJzJykuaW50KClcbiAgICAgICAgICApXG4gICAgICAgICksXG4gICAgICAgIHRoaXMua2V5KCdjaXBoZXInKS5zZXEoKS5vYmooXG4gICAgICAgICAgdGhpcy5rZXkoJ2FsZ28nKS5vYmppZCgpLFxuICAgICAgICAgIHRoaXMua2V5KCdpdicpLm9jdHN0cigpXG4gICAgICAgIClcbiAgICAgIClcbiAgICApLFxuICAgIHRoaXMua2V5KCdzdWJqZWN0UHJpdmF0ZUtleScpLm9jdHN0cigpXG4gIClcbn0pXG5cbmV4cG9ydHMuRW5jcnlwdGVkUHJpdmF0ZUtleSA9IEVuY3J5cHRlZFByaXZhdGVLZXlJbmZvXG5cbnZhciBEU0FQcml2YXRlS2V5ID0gYXNuMS5kZWZpbmUoJ0RTQVByaXZhdGVLZXknLCBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc2VxKCkub2JqKFxuICAgIHRoaXMua2V5KCd2ZXJzaW9uJykuaW50KCksXG4gICAgdGhpcy5rZXkoJ3AnKS5pbnQoKSxcbiAgICB0aGlzLmtleSgncScpLmludCgpLFxuICAgIHRoaXMua2V5KCdnJykuaW50KCksXG4gICAgdGhpcy5rZXkoJ3B1Yl9rZXknKS5pbnQoKSxcbiAgICB0aGlzLmtleSgncHJpdl9rZXknKS5pbnQoKVxuICApXG59KVxuZXhwb3J0cy5EU0FQcml2YXRlS2V5ID0gRFNBUHJpdmF0ZUtleVxuXG5leHBvcnRzLkRTQXBhcmFtID0gYXNuMS5kZWZpbmUoJ0RTQXBhcmFtJywgZnVuY3Rpb24gKCkge1xuICB0aGlzLmludCgpXG59KVxudmFyIEVDUHJpdmF0ZUtleSA9IGFzbjEuZGVmaW5lKCdFQ1ByaXZhdGVLZXknLCBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc2VxKCkub2JqKFxuICAgIHRoaXMua2V5KCd2ZXJzaW9uJykuaW50KCksXG4gICAgdGhpcy5rZXkoJ3ByaXZhdGVLZXknKS5vY3RzdHIoKSxcbiAgICB0aGlzLmtleSgncGFyYW1ldGVycycpLm9wdGlvbmFsKCkuZXhwbGljaXQoMCkudXNlKEVDUGFyYW1ldGVycyksXG4gICAgdGhpcy5rZXkoJ3B1YmxpY0tleScpLm9wdGlvbmFsKCkuZXhwbGljaXQoMSkuYml0c3RyKClcbiAgKVxufSlcbmV4cG9ydHMuRUNQcml2YXRlS2V5ID0gRUNQcml2YXRlS2V5XG52YXIgRUNQYXJhbWV0ZXJzID0gYXNuMS5kZWZpbmUoJ0VDUGFyYW1ldGVycycsIGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5jaG9pY2Uoe1xuICAgIG5hbWVkQ3VydmU6IHRoaXMub2JqaWQoKVxuICB9KVxufSlcblxuZXhwb3J0cy5zaWduYXR1cmUgPSBhc24xLmRlZmluZSgnc2lnbmF0dXJlJywgZnVuY3Rpb24gKCkge1xuICB0aGlzLnNlcSgpLm9iaihcbiAgICB0aGlzLmtleSgncicpLmludCgpLFxuICAgIHRoaXMua2V5KCdzJykuaW50KClcbiAgKVxufSlcbiIsIi8vIGFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vYXBhdGlsL3BlbXN0cmlwXG52YXIgZmluZFByb2MgPSAvUHJvYy1UeXBlOiA0LEVOQ1JZUFRFRFxccj9cXG5ERUstSW5mbzogQUVTLSgoPzoxMjgpfCg/OjE5Mil8KD86MjU2KSktQ0JDLChbMC05QS1IXSspXFxyP1xcblxccj9cXG4oWzAtOUEtelxcblxcclxcK1xcL1xcPV0rKVxccj9cXG4vbVxudmFyIHN0YXJ0UmVnZXggPSAvXi0tLS0tQkVHSU4gKC4qKSBLRVktLS0tLVxccj9cXG4vbVxudmFyIGZ1bGxSZWdleCA9IC9eLS0tLS1CRUdJTiAoLiopIEtFWS0tLS0tXFxyP1xcbihbMC05QS16XFxuXFxyXFwrXFwvXFw9XSspXFxyP1xcbi0tLS0tRU5EIFxcMSBLRVktLS0tLSQvbVxudmFyIGV2cCA9IHJlcXVpcmUoJ2V2cF9ieXRlc3Rva2V5JylcbnZhciBjaXBoZXJzID0gcmVxdWlyZSgnYnJvd3NlcmlmeS1hZXMnKVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2tleSwgcGFzc3dvcmQpIHtcbiAgdmFyIGtleSA9IG9rZXkudG9TdHJpbmcoKVxuICB2YXIgbWF0Y2ggPSBrZXkubWF0Y2goZmluZFByb2MpXG4gIHZhciBkZWNyeXB0ZWRcbiAgaWYgKCFtYXRjaCkge1xuICAgIHZhciBtYXRjaDIgPSBrZXkubWF0Y2goZnVsbFJlZ2V4KVxuICAgIGRlY3J5cHRlZCA9IG5ldyBCdWZmZXIobWF0Y2gyWzJdLnJlcGxhY2UoL1xccj9cXG4vZywgJycpLCAnYmFzZTY0JylcbiAgfSBlbHNlIHtcbiAgICB2YXIgc3VpdGUgPSAnYWVzJyArIG1hdGNoWzFdXG4gICAgdmFyIGl2ID0gbmV3IEJ1ZmZlcihtYXRjaFsyXSwgJ2hleCcpXG4gICAgdmFyIGNpcGhlclRleHQgPSBuZXcgQnVmZmVyKG1hdGNoWzNdLnJlcGxhY2UoL1xccj9cXG4vZywgJycpLCAnYmFzZTY0JylcbiAgICB2YXIgY2lwaGVyS2V5ID0gZXZwKHBhc3N3b3JkLCBpdi5zbGljZSgwLCA4KSwgcGFyc2VJbnQobWF0Y2hbMV0sIDEwKSkua2V5XG4gICAgdmFyIG91dCA9IFtdXG4gICAgdmFyIGNpcGhlciA9IGNpcGhlcnMuY3JlYXRlRGVjaXBoZXJpdihzdWl0ZSwgY2lwaGVyS2V5LCBpdilcbiAgICBvdXQucHVzaChjaXBoZXIudXBkYXRlKGNpcGhlclRleHQpKVxuICAgIG91dC5wdXNoKGNpcGhlci5maW5hbCgpKVxuICAgIGRlY3J5cHRlZCA9IEJ1ZmZlci5jb25jYXQob3V0KVxuICB9XG4gIHZhciB0YWcgPSBrZXkubWF0Y2goc3RhcnRSZWdleClbMV0gKyAnIEtFWSdcbiAgcmV0dXJuIHtcbiAgICB0YWc6IHRhZyxcbiAgICBkYXRhOiBkZWNyeXB0ZWRcbiAgfVxufVxuIiwidmFyIGFzbjEgPSByZXF1aXJlKCcuL2FzbjEnKVxudmFyIGFlc2lkID0gcmVxdWlyZSgnLi9hZXNpZC5qc29uJylcbnZhciBmaXhQcm9jID0gcmVxdWlyZSgnLi9maXhQcm9jJylcbnZhciBjaXBoZXJzID0gcmVxdWlyZSgnYnJvd3NlcmlmeS1hZXMnKVxudmFyIGNvbXBhdCA9IHJlcXVpcmUoJ3Bia2RmMicpXG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlS2V5c1xuXG5mdW5jdGlvbiBwYXJzZUtleXMgKGJ1ZmZlcikge1xuICB2YXIgcGFzc3dvcmRcbiAgaWYgKHR5cGVvZiBidWZmZXIgPT09ICdvYmplY3QnICYmICFCdWZmZXIuaXNCdWZmZXIoYnVmZmVyKSkge1xuICAgIHBhc3N3b3JkID0gYnVmZmVyLnBhc3NwaHJhc2VcbiAgICBidWZmZXIgPSBidWZmZXIua2V5XG4gIH1cbiAgaWYgKHR5cGVvZiBidWZmZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgYnVmZmVyID0gbmV3IEJ1ZmZlcihidWZmZXIpXG4gIH1cblxuICB2YXIgc3RyaXBwZWQgPSBmaXhQcm9jKGJ1ZmZlciwgcGFzc3dvcmQpXG5cbiAgdmFyIHR5cGUgPSBzdHJpcHBlZC50YWdcbiAgdmFyIGRhdGEgPSBzdHJpcHBlZC5kYXRhXG4gIHZhciBzdWJ0eXBlLCBuZGF0YVxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdQVUJMSUMgS0VZJzpcbiAgICAgIG5kYXRhID0gYXNuMS5QdWJsaWNLZXkuZGVjb2RlKGRhdGEsICdkZXInKVxuICAgICAgc3VidHlwZSA9IG5kYXRhLmFsZ29yaXRobS5hbGdvcml0aG0uam9pbignLicpXG4gICAgICBzd2l0Y2ggKHN1YnR5cGUpIHtcbiAgICAgICAgY2FzZSAnMS4yLjg0MC4xMTM1NDkuMS4xLjEnOlxuICAgICAgICAgIHJldHVybiBhc24xLlJTQVB1YmxpY0tleS5kZWNvZGUobmRhdGEuc3ViamVjdFB1YmxpY0tleS5kYXRhLCAnZGVyJylcbiAgICAgICAgY2FzZSAnMS4yLjg0MC4xMDA0NS4yLjEnOlxuICAgICAgICAgIG5kYXRhLnN1YmplY3RQcml2YXRlS2V5ID0gbmRhdGEuc3ViamVjdFB1YmxpY0tleVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnZWMnLFxuICAgICAgICAgICAgZGF0YTogbmRhdGFcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJzEuMi44NDAuMTAwNDAuNC4xJzpcbiAgICAgICAgICBuZGF0YS5hbGdvcml0aG0ucGFyYW1zLnB1Yl9rZXkgPSBhc24xLkRTQXBhcmFtLmRlY29kZShuZGF0YS5zdWJqZWN0UHVibGljS2V5LmRhdGEsICdkZXInKVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnZHNhJyxcbiAgICAgICAgICAgIGRhdGE6IG5kYXRhLmFsZ29yaXRobS5wYXJhbXNcbiAgICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcigndW5rbm93biBrZXkgaWQgJyArIHN1YnR5cGUpXG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24ga2V5IHR5cGUgJyArIHR5cGUpXG4gICAgY2FzZSAnRU5DUllQVEVEIFBSSVZBVEUgS0VZJzpcbiAgICAgIGRhdGEgPSBhc24xLkVuY3J5cHRlZFByaXZhdGVLZXkuZGVjb2RlKGRhdGEsICdkZXInKVxuICAgICAgZGF0YSA9IGRlY3J5cHQoZGF0YSwgcGFzc3dvcmQpXG4gICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgY2FzZSAnUFJJVkFURSBLRVknOlxuICAgICAgbmRhdGEgPSBhc24xLlByaXZhdGVLZXkuZGVjb2RlKGRhdGEsICdkZXInKVxuICAgICAgc3VidHlwZSA9IG5kYXRhLmFsZ29yaXRobS5hbGdvcml0aG0uam9pbignLicpXG4gICAgICBzd2l0Y2ggKHN1YnR5cGUpIHtcbiAgICAgICAgY2FzZSAnMS4yLjg0MC4xMTM1NDkuMS4xLjEnOlxuICAgICAgICAgIHJldHVybiBhc24xLlJTQVByaXZhdGVLZXkuZGVjb2RlKG5kYXRhLnN1YmplY3RQcml2YXRlS2V5LCAnZGVyJylcbiAgICAgICAgY2FzZSAnMS4yLjg0MC4xMDA0NS4yLjEnOlxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjdXJ2ZTogbmRhdGEuYWxnb3JpdGhtLmN1cnZlLFxuICAgICAgICAgICAgcHJpdmF0ZUtleTogYXNuMS5FQ1ByaXZhdGVLZXkuZGVjb2RlKG5kYXRhLnN1YmplY3RQcml2YXRlS2V5LCAnZGVyJykucHJpdmF0ZUtleVxuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAnMS4yLjg0MC4xMDA0MC40LjEnOlxuICAgICAgICAgIG5kYXRhLmFsZ29yaXRobS5wYXJhbXMucHJpdl9rZXkgPSBhc24xLkRTQXBhcmFtLmRlY29kZShuZGF0YS5zdWJqZWN0UHJpdmF0ZUtleSwgJ2RlcicpXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdkc2EnLFxuICAgICAgICAgICAgcGFyYW1zOiBuZGF0YS5hbGdvcml0aG0ucGFyYW1zXG4gICAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24ga2V5IGlkICcgKyBzdWJ0eXBlKVxuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGtleSB0eXBlICcgKyB0eXBlKVxuICAgIGNhc2UgJ1JTQSBQVUJMSUMgS0VZJzpcbiAgICAgIHJldHVybiBhc24xLlJTQVB1YmxpY0tleS5kZWNvZGUoZGF0YSwgJ2RlcicpXG4gICAgY2FzZSAnUlNBIFBSSVZBVEUgS0VZJzpcbiAgICAgIHJldHVybiBhc24xLlJTQVByaXZhdGVLZXkuZGVjb2RlKGRhdGEsICdkZXInKVxuICAgIGNhc2UgJ0RTQSBQUklWQVRFIEtFWSc6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnZHNhJyxcbiAgICAgICAgcGFyYW1zOiBhc24xLkRTQVByaXZhdGVLZXkuZGVjb2RlKGRhdGEsICdkZXInKVxuICAgICAgfVxuICAgIGNhc2UgJ0VDIFBSSVZBVEUgS0VZJzpcbiAgICAgIGRhdGEgPSBhc24xLkVDUHJpdmF0ZUtleS5kZWNvZGUoZGF0YSwgJ2RlcicpXG4gICAgICByZXR1cm4ge1xuICAgICAgICBjdXJ2ZTogZGF0YS5wYXJhbWV0ZXJzLnZhbHVlLFxuICAgICAgICBwcml2YXRlS2V5OiBkYXRhLnByaXZhdGVLZXlcbiAgICAgIH1cbiAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24ga2V5IHR5cGUgJyArIHR5cGUpXG4gIH1cbn1cbnBhcnNlS2V5cy5zaWduYXR1cmUgPSBhc24xLnNpZ25hdHVyZVxuZnVuY3Rpb24gZGVjcnlwdCAoZGF0YSwgcGFzc3dvcmQpIHtcbiAgdmFyIHNhbHQgPSBkYXRhLmFsZ29yaXRobS5kZWNyeXB0LmtkZS5rZGVwYXJhbXMuc2FsdFxuICB2YXIgaXRlcnMgPSBwYXJzZUludChkYXRhLmFsZ29yaXRobS5kZWNyeXB0LmtkZS5rZGVwYXJhbXMuaXRlcnMudG9TdHJpbmcoKSwgMTApXG4gIHZhciBhbGdvID0gYWVzaWRbZGF0YS5hbGdvcml0aG0uZGVjcnlwdC5jaXBoZXIuYWxnby5qb2luKCcuJyldXG4gIHZhciBpdiA9IGRhdGEuYWxnb3JpdGhtLmRlY3J5cHQuY2lwaGVyLml2XG4gIHZhciBjaXBoZXJUZXh0ID0gZGF0YS5zdWJqZWN0UHJpdmF0ZUtleVxuICB2YXIga2V5bGVuID0gcGFyc2VJbnQoYWxnby5zcGxpdCgnLScpWzFdLCAxMCkgLyA4XG4gIHZhciBrZXkgPSBjb21wYXQucGJrZGYyU3luYyhwYXNzd29yZCwgc2FsdCwgaXRlcnMsIGtleWxlbilcbiAgdmFyIGNpcGhlciA9IGNpcGhlcnMuY3JlYXRlRGVjaXBoZXJpdihhbGdvLCBrZXksIGl2KVxuICB2YXIgb3V0ID0gW11cbiAgb3V0LnB1c2goY2lwaGVyLnVwZGF0ZShjaXBoZXJUZXh0KSlcbiAgb3V0LnB1c2goY2lwaGVyLmZpbmFsKCkpXG4gIHJldHVybiBCdWZmZXIuY29uY2F0KG91dClcbn1cbiIsInZhciBhc24xID0gZXhwb3J0cztcblxuYXNuMS5iaWdudW0gPSByZXF1aXJlKCdibi5qcycpO1xuXG5hc24xLmRlZmluZSA9IHJlcXVpcmUoJy4vYXNuMS9hcGknKS5kZWZpbmU7XG5hc24xLmJhc2UgPSByZXF1aXJlKCcuL2FzbjEvYmFzZScpO1xuYXNuMS5jb25zdGFudHMgPSByZXF1aXJlKCcuL2FzbjEvY29uc3RhbnRzJyk7XG5hc24xLmRlY29kZXJzID0gcmVxdWlyZSgnLi9hc24xL2RlY29kZXJzJyk7XG5hc24xLmVuY29kZXJzID0gcmVxdWlyZSgnLi9hc24xL2VuY29kZXJzJyk7XG4iLCJ2YXIgYXNuMSA9IHJlcXVpcmUoJy4uL2FzbjEnKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbnZhciBhcGkgPSBleHBvcnRzO1xuXG5hcGkuZGVmaW5lID0gZnVuY3Rpb24gZGVmaW5lKG5hbWUsIGJvZHkpIHtcbiAgcmV0dXJuIG5ldyBFbnRpdHkobmFtZSwgYm9keSk7XG59O1xuXG5mdW5jdGlvbiBFbnRpdHkobmFtZSwgYm9keSkge1xuICB0aGlzLm5hbWUgPSBuYW1lO1xuICB0aGlzLmJvZHkgPSBib2R5O1xuXG4gIHRoaXMuZGVjb2RlcnMgPSB7fTtcbiAgdGhpcy5lbmNvZGVycyA9IHt9O1xufTtcblxuRW50aXR5LnByb3RvdHlwZS5fY3JlYXRlTmFtZWQgPSBmdW5jdGlvbiBjcmVhdGVOYW1lZChiYXNlKSB7XG4gIHZhciBuYW1lZDtcbiAgdHJ5IHtcbiAgICBuYW1lZCA9IHJlcXVpcmUoJ3ZtJykucnVuSW5UaGlzQ29udGV4dChcbiAgICAgICcoZnVuY3Rpb24gJyArIHRoaXMubmFtZSArICcoZW50aXR5KSB7XFxuJyArXG4gICAgICAnICB0aGlzLl9pbml0TmFtZWQoZW50aXR5KTtcXG4nICtcbiAgICAgICd9KSdcbiAgICApO1xuICB9IGNhdGNoIChlKSB7XG4gICAgbmFtZWQgPSBmdW5jdGlvbiAoZW50aXR5KSB7XG4gICAgICB0aGlzLl9pbml0TmFtZWQoZW50aXR5KTtcbiAgICB9O1xuICB9XG4gIGluaGVyaXRzKG5hbWVkLCBiYXNlKTtcbiAgbmFtZWQucHJvdG90eXBlLl9pbml0TmFtZWQgPSBmdW5jdGlvbiBpbml0bmFtZWQoZW50aXR5KSB7XG4gICAgYmFzZS5jYWxsKHRoaXMsIGVudGl0eSk7XG4gIH07XG5cbiAgcmV0dXJuIG5ldyBuYW1lZCh0aGlzKTtcbn07XG5cbkVudGl0eS5wcm90b3R5cGUuX2dldERlY29kZXIgPSBmdW5jdGlvbiBfZ2V0RGVjb2RlcihlbmMpIHtcbiAgLy8gTGF6aWx5IGNyZWF0ZSBkZWNvZGVyXG4gIGlmICghdGhpcy5kZWNvZGVycy5oYXNPd25Qcm9wZXJ0eShlbmMpKVxuICAgIHRoaXMuZGVjb2RlcnNbZW5jXSA9IHRoaXMuX2NyZWF0ZU5hbWVkKGFzbjEuZGVjb2RlcnNbZW5jXSk7XG4gIHJldHVybiB0aGlzLmRlY29kZXJzW2VuY107XG59O1xuXG5FbnRpdHkucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShkYXRhLCBlbmMsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHRoaXMuX2dldERlY29kZXIoZW5jKS5kZWNvZGUoZGF0YSwgb3B0aW9ucyk7XG59O1xuXG5FbnRpdHkucHJvdG90eXBlLl9nZXRFbmNvZGVyID0gZnVuY3Rpb24gX2dldEVuY29kZXIoZW5jKSB7XG4gIC8vIExhemlseSBjcmVhdGUgZW5jb2RlclxuICBpZiAoIXRoaXMuZW5jb2RlcnMuaGFzT3duUHJvcGVydHkoZW5jKSlcbiAgICB0aGlzLmVuY29kZXJzW2VuY10gPSB0aGlzLl9jcmVhdGVOYW1lZChhc24xLmVuY29kZXJzW2VuY10pO1xuICByZXR1cm4gdGhpcy5lbmNvZGVyc1tlbmNdO1xufTtcblxuRW50aXR5LnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUoZGF0YSwgZW5jLCAvKiBpbnRlcm5hbCAqLyByZXBvcnRlcikge1xuICByZXR1cm4gdGhpcy5fZ2V0RW5jb2RlcihlbmMpLmVuY29kZShkYXRhLCByZXBvcnRlcik7XG59O1xuIiwidmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbnZhciBSZXBvcnRlciA9IHJlcXVpcmUoJy4uL2Jhc2UnKS5SZXBvcnRlcjtcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG5cbmZ1bmN0aW9uIERlY29kZXJCdWZmZXIoYmFzZSwgb3B0aW9ucykge1xuICBSZXBvcnRlci5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiYXNlKSkge1xuICAgIHRoaXMuZXJyb3IoJ0lucHV0IG5vdCBCdWZmZXInKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLmJhc2UgPSBiYXNlO1xuICB0aGlzLm9mZnNldCA9IDA7XG4gIHRoaXMubGVuZ3RoID0gYmFzZS5sZW5ndGg7XG59XG5pbmhlcml0cyhEZWNvZGVyQnVmZmVyLCBSZXBvcnRlcik7XG5leHBvcnRzLkRlY29kZXJCdWZmZXIgPSBEZWNvZGVyQnVmZmVyO1xuXG5EZWNvZGVyQnVmZmVyLnByb3RvdHlwZS5zYXZlID0gZnVuY3Rpb24gc2F2ZSgpIHtcbiAgcmV0dXJuIHsgb2Zmc2V0OiB0aGlzLm9mZnNldCwgcmVwb3J0ZXI6IFJlcG9ydGVyLnByb3RvdHlwZS5zYXZlLmNhbGwodGhpcykgfTtcbn07XG5cbkRlY29kZXJCdWZmZXIucHJvdG90eXBlLnJlc3RvcmUgPSBmdW5jdGlvbiByZXN0b3JlKHNhdmUpIHtcbiAgLy8gUmV0dXJuIHNraXBwZWQgZGF0YVxuICB2YXIgcmVzID0gbmV3IERlY29kZXJCdWZmZXIodGhpcy5iYXNlKTtcbiAgcmVzLm9mZnNldCA9IHNhdmUub2Zmc2V0O1xuICByZXMubGVuZ3RoID0gdGhpcy5vZmZzZXQ7XG5cbiAgdGhpcy5vZmZzZXQgPSBzYXZlLm9mZnNldDtcbiAgUmVwb3J0ZXIucHJvdG90eXBlLnJlc3RvcmUuY2FsbCh0aGlzLCBzYXZlLnJlcG9ydGVyKTtcblxuICByZXR1cm4gcmVzO1xufTtcblxuRGVjb2RlckJ1ZmZlci5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uIGlzRW1wdHkoKSB7XG4gIHJldHVybiB0aGlzLm9mZnNldCA9PT0gdGhpcy5sZW5ndGg7XG59O1xuXG5EZWNvZGVyQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDgoZmFpbCkge1xuICBpZiAodGhpcy5vZmZzZXQgKyAxIDw9IHRoaXMubGVuZ3RoKVxuICAgIHJldHVybiB0aGlzLmJhc2UucmVhZFVJbnQ4KHRoaXMub2Zmc2V0KyssIHRydWUpO1xuICBlbHNlXG4gICAgcmV0dXJuIHRoaXMuZXJyb3IoZmFpbCB8fCAnRGVjb2RlckJ1ZmZlciBvdmVycnVuJyk7XG59XG5cbkRlY29kZXJCdWZmZXIucHJvdG90eXBlLnNraXAgPSBmdW5jdGlvbiBza2lwKGJ5dGVzLCBmYWlsKSB7XG4gIGlmICghKHRoaXMub2Zmc2V0ICsgYnl0ZXMgPD0gdGhpcy5sZW5ndGgpKVxuICAgIHJldHVybiB0aGlzLmVycm9yKGZhaWwgfHwgJ0RlY29kZXJCdWZmZXIgb3ZlcnJ1bicpO1xuXG4gIHZhciByZXMgPSBuZXcgRGVjb2RlckJ1ZmZlcih0aGlzLmJhc2UpO1xuXG4gIC8vIFNoYXJlIHJlcG9ydGVyIHN0YXRlXG4gIHJlcy5fcmVwb3J0ZXJTdGF0ZSA9IHRoaXMuX3JlcG9ydGVyU3RhdGU7XG5cbiAgcmVzLm9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICByZXMubGVuZ3RoID0gdGhpcy5vZmZzZXQgKyBieXRlcztcbiAgdGhpcy5vZmZzZXQgKz0gYnl0ZXM7XG4gIHJldHVybiByZXM7XG59XG5cbkRlY29kZXJCdWZmZXIucHJvdG90eXBlLnJhdyA9IGZ1bmN0aW9uIHJhdyhzYXZlKSB7XG4gIHJldHVybiB0aGlzLmJhc2Uuc2xpY2Uoc2F2ZSA/IHNhdmUub2Zmc2V0IDogdGhpcy5vZmZzZXQsIHRoaXMubGVuZ3RoKTtcbn1cblxuZnVuY3Rpb24gRW5jb2RlckJ1ZmZlcih2YWx1ZSwgcmVwb3J0ZXIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZS5tYXAoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgaWYgKCEoaXRlbSBpbnN0YW5jZW9mIEVuY29kZXJCdWZmZXIpKVxuICAgICAgICBpdGVtID0gbmV3IEVuY29kZXJCdWZmZXIoaXRlbSwgcmVwb3J0ZXIpO1xuICAgICAgdGhpcy5sZW5ndGggKz0gaXRlbS5sZW5ndGg7XG4gICAgICByZXR1cm4gaXRlbTtcbiAgICB9LCB0aGlzKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKCEoMCA8PSB2YWx1ZSAmJiB2YWx1ZSA8PSAweGZmKSlcbiAgICAgIHJldHVybiByZXBvcnRlci5lcnJvcignbm9uLWJ5dGUgRW5jb2RlckJ1ZmZlciB2YWx1ZScpO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLmxlbmd0aCA9IDE7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLmxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbHVlKTtcbiAgfSBlbHNlIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMubGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiByZXBvcnRlci5lcnJvcignVW5zdXBwb3J0ZWQgdHlwZTogJyArIHR5cGVvZiB2YWx1ZSk7XG4gIH1cbn1cbmV4cG9ydHMuRW5jb2RlckJ1ZmZlciA9IEVuY29kZXJCdWZmZXI7XG5cbkVuY29kZXJCdWZmZXIucHJvdG90eXBlLmpvaW4gPSBmdW5jdGlvbiBqb2luKG91dCwgb2Zmc2V0KSB7XG4gIGlmICghb3V0KVxuICAgIG91dCA9IG5ldyBCdWZmZXIodGhpcy5sZW5ndGgpO1xuICBpZiAoIW9mZnNldClcbiAgICBvZmZzZXQgPSAwO1xuXG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm4gb3V0O1xuXG4gIGlmIChBcnJheS5pc0FycmF5KHRoaXMudmFsdWUpKSB7XG4gICAgdGhpcy52YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgIGl0ZW0uam9pbihvdXQsIG9mZnNldCk7XG4gICAgICBvZmZzZXQgKz0gaXRlbS5sZW5ndGg7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLnZhbHVlID09PSAnbnVtYmVyJylcbiAgICAgIG91dFtvZmZzZXRdID0gdGhpcy52YWx1ZTtcbiAgICBlbHNlIGlmICh0eXBlb2YgdGhpcy52YWx1ZSA9PT0gJ3N0cmluZycpXG4gICAgICBvdXQud3JpdGUodGhpcy52YWx1ZSwgb2Zmc2V0KTtcbiAgICBlbHNlIGlmIChCdWZmZXIuaXNCdWZmZXIodGhpcy52YWx1ZSkpXG4gICAgICB0aGlzLnZhbHVlLmNvcHkob3V0LCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSB0aGlzLmxlbmd0aDtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59O1xuIiwidmFyIGJhc2UgPSBleHBvcnRzO1xuXG5iYXNlLlJlcG9ydGVyID0gcmVxdWlyZSgnLi9yZXBvcnRlcicpLlJlcG9ydGVyO1xuYmFzZS5EZWNvZGVyQnVmZmVyID0gcmVxdWlyZSgnLi9idWZmZXInKS5EZWNvZGVyQnVmZmVyO1xuYmFzZS5FbmNvZGVyQnVmZmVyID0gcmVxdWlyZSgnLi9idWZmZXInKS5FbmNvZGVyQnVmZmVyO1xuYmFzZS5Ob2RlID0gcmVxdWlyZSgnLi9ub2RlJyk7XG4iLCJ2YXIgUmVwb3J0ZXIgPSByZXF1aXJlKCcuLi9iYXNlJykuUmVwb3J0ZXI7XG52YXIgRW5jb2RlckJ1ZmZlciA9IHJlcXVpcmUoJy4uL2Jhc2UnKS5FbmNvZGVyQnVmZmVyO1xudmFyIGFzc2VydCA9IHJlcXVpcmUoJ21pbmltYWxpc3RpYy1hc3NlcnQnKTtcblxuLy8gU3VwcG9ydGVkIHRhZ3NcbnZhciB0YWdzID0gW1xuICAnc2VxJywgJ3NlcW9mJywgJ3NldCcsICdzZXRvZicsICdvY3RzdHInLCAnYml0c3RyJywgJ29iamlkJywgJ2Jvb2wnLFxuICAnZ2VudGltZScsICd1dGN0aW1lJywgJ251bGxfJywgJ2VudW0nLCAnaW50JywgJ2lhNXN0cicsICd1dGY4c3RyJywgJ2JtcHN0cicsXG4gICdudW1zdHInLCAncHJpbnRzdHInXG5dO1xuXG4vLyBQdWJsaWMgbWV0aG9kcyBsaXN0XG52YXIgbWV0aG9kcyA9IFtcbiAgJ2tleScsICdvYmonLCAndXNlJywgJ29wdGlvbmFsJywgJ2V4cGxpY2l0JywgJ2ltcGxpY2l0JywgJ2RlZicsICdjaG9pY2UnLFxuICAnYW55J1xuXS5jb25jYXQodGFncyk7XG5cbi8vIE92ZXJyaWRlZCBtZXRob2RzIGxpc3RcbnZhciBvdmVycmlkZWQgPSBbXG4gICdfcGVla1RhZycsICdfZGVjb2RlVGFnJywgJ191c2UnLFxuICAnX2RlY29kZVN0cicsICdfZGVjb2RlT2JqaWQnLCAnX2RlY29kZVRpbWUnLFxuICAnX2RlY29kZU51bGwnLCAnX2RlY29kZUludCcsICdfZGVjb2RlQm9vbCcsICdfZGVjb2RlTGlzdCcsXG5cbiAgJ19lbmNvZGVDb21wb3NpdGUnLCAnX2VuY29kZVN0cicsICdfZW5jb2RlT2JqaWQnLCAnX2VuY29kZVRpbWUnLFxuICAnX2VuY29kZU51bGwnLCAnX2VuY29kZUludCcsICdfZW5jb2RlQm9vbCdcbl07XG5cbmZ1bmN0aW9uIE5vZGUoZW5jLCBwYXJlbnQpIHtcbiAgdmFyIHN0YXRlID0ge307XG4gIHRoaXMuX2Jhc2VTdGF0ZSA9IHN0YXRlO1xuXG4gIHN0YXRlLmVuYyA9IGVuYztcblxuICBzdGF0ZS5wYXJlbnQgPSBwYXJlbnQgfHwgbnVsbDtcbiAgc3RhdGUuY2hpbGRyZW4gPSBudWxsO1xuXG4gIC8vIFN0YXRlXG4gIHN0YXRlLnRhZyA9IG51bGw7XG4gIHN0YXRlLmFyZ3MgPSBudWxsO1xuICBzdGF0ZS5yZXZlcnNlQXJncyA9IG51bGw7XG4gIHN0YXRlLmNob2ljZSA9IG51bGw7XG4gIHN0YXRlLm9wdGlvbmFsID0gZmFsc2U7XG4gIHN0YXRlLmFueSA9IGZhbHNlO1xuICBzdGF0ZS5vYmogPSBmYWxzZTtcbiAgc3RhdGUudXNlID0gbnVsbDtcbiAgc3RhdGUudXNlRGVjb2RlciA9IG51bGw7XG4gIHN0YXRlLmtleSA9IG51bGw7XG4gIHN0YXRlWydkZWZhdWx0J10gPSBudWxsO1xuICBzdGF0ZS5leHBsaWNpdCA9IG51bGw7XG4gIHN0YXRlLmltcGxpY2l0ID0gbnVsbDtcblxuICAvLyBTaG91bGQgY3JlYXRlIG5ldyBpbnN0YW5jZSBvbiBlYWNoIG1ldGhvZFxuICBpZiAoIXN0YXRlLnBhcmVudCkge1xuICAgIHN0YXRlLmNoaWxkcmVuID0gW107XG4gICAgdGhpcy5fd3JhcCgpO1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IE5vZGU7XG5cbnZhciBzdGF0ZVByb3BzID0gW1xuICAnZW5jJywgJ3BhcmVudCcsICdjaGlsZHJlbicsICd0YWcnLCAnYXJncycsICdyZXZlcnNlQXJncycsICdjaG9pY2UnLFxuICAnb3B0aW9uYWwnLCAnYW55JywgJ29iaicsICd1c2UnLCAnYWx0ZXJlZFVzZScsICdrZXknLCAnZGVmYXVsdCcsICdleHBsaWNpdCcsXG4gICdpbXBsaWNpdCdcbl07XG5cbk5vZGUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gY2xvbmUoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcbiAgdmFyIGNzdGF0ZSA9IHt9O1xuICBzdGF0ZVByb3BzLmZvckVhY2goZnVuY3Rpb24ocHJvcCkge1xuICAgIGNzdGF0ZVtwcm9wXSA9IHN0YXRlW3Byb3BdO1xuICB9KTtcbiAgdmFyIHJlcyA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKGNzdGF0ZS5wYXJlbnQpO1xuICByZXMuX2Jhc2VTdGF0ZSA9IGNzdGF0ZTtcbiAgcmV0dXJuIHJlcztcbn07XG5cbk5vZGUucHJvdG90eXBlLl93cmFwID0gZnVuY3Rpb24gd3JhcCgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuICBtZXRob2RzLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgdGhpc1ttZXRob2RdID0gZnVuY3Rpb24gX3dyYXBwZWRNZXRob2QoKSB7XG4gICAgICB2YXIgY2xvbmUgPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzKTtcbiAgICAgIHN0YXRlLmNoaWxkcmVuLnB1c2goY2xvbmUpO1xuICAgICAgcmV0dXJuIGNsb25lW21ldGhvZF0uYXBwbHkoY2xvbmUsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfSwgdGhpcyk7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIGluaXQoYm9keSkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG5cbiAgYXNzZXJ0KHN0YXRlLnBhcmVudCA9PT0gbnVsbCk7XG4gIGJvZHkuY2FsbCh0aGlzKTtcblxuICAvLyBGaWx0ZXIgY2hpbGRyZW5cbiAgc3RhdGUuY2hpbGRyZW4gPSBzdGF0ZS5jaGlsZHJlbi5maWx0ZXIoZnVuY3Rpb24oY2hpbGQpIHtcbiAgICByZXR1cm4gY2hpbGQuX2Jhc2VTdGF0ZS5wYXJlbnQgPT09IHRoaXM7XG4gIH0sIHRoaXMpO1xuICBhc3NlcnQuZXF1YWwoc3RhdGUuY2hpbGRyZW4ubGVuZ3RoLCAxLCAnUm9vdCBub2RlIGNhbiBoYXZlIG9ubHkgb25lIGNoaWxkJyk7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5fdXNlQXJncyA9IGZ1bmN0aW9uIHVzZUFyZ3MoYXJncykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG5cbiAgLy8gRmlsdGVyIGNoaWxkcmVuIGFuZCBhcmdzXG4gIHZhciBjaGlsZHJlbiA9IGFyZ3MuZmlsdGVyKGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBhcmcgaW5zdGFuY2VvZiB0aGlzLmNvbnN0cnVjdG9yO1xuICB9LCB0aGlzKTtcbiAgYXJncyA9IGFyZ3MuZmlsdGVyKGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiAhKGFyZyBpbnN0YW5jZW9mIHRoaXMuY29uc3RydWN0b3IpO1xuICB9LCB0aGlzKTtcblxuICBpZiAoY2hpbGRyZW4ubGVuZ3RoICE9PSAwKSB7XG4gICAgYXNzZXJ0KHN0YXRlLmNoaWxkcmVuID09PSBudWxsKTtcbiAgICBzdGF0ZS5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuXG4gICAgLy8gUmVwbGFjZSBwYXJlbnQgdG8gbWFpbnRhaW4gYmFja3dhcmQgbGlua1xuICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgIGNoaWxkLl9iYXNlU3RhdGUucGFyZW50ID0gdGhpcztcbiAgICB9LCB0aGlzKTtcbiAgfVxuICBpZiAoYXJncy5sZW5ndGggIT09IDApIHtcbiAgICBhc3NlcnQoc3RhdGUuYXJncyA9PT0gbnVsbCk7XG4gICAgc3RhdGUuYXJncyA9IGFyZ3M7XG4gICAgc3RhdGUucmV2ZXJzZUFyZ3MgPSBhcmdzLm1hcChmdW5jdGlvbihhcmcpIHtcbiAgICAgIGlmICh0eXBlb2YgYXJnICE9PSAnb2JqZWN0JyB8fCBhcmcuY29uc3RydWN0b3IgIT09IE9iamVjdClcbiAgICAgICAgcmV0dXJuIGFyZztcblxuICAgICAgdmFyIHJlcyA9IHt9O1xuICAgICAgT2JqZWN0LmtleXMoYXJnKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICBpZiAoa2V5ID09IChrZXkgfCAwKSlcbiAgICAgICAgICBrZXkgfD0gMDtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJnW2tleV07XG4gICAgICAgIHJlc1t2YWx1ZV0gPSBrZXk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfSk7XG4gIH1cbn07XG5cbi8vXG4vLyBPdmVycmlkZWQgbWV0aG9kc1xuLy9cblxub3ZlcnJpZGVkLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gIE5vZGUucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbiBfb3ZlcnJpZGVkKCkge1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWV0aG9kICsgJyBub3QgaW1wbGVtZW50ZWQgZm9yIGVuY29kaW5nOiAnICsgc3RhdGUuZW5jKTtcbiAgfTtcbn0pO1xuXG4vL1xuLy8gUHVibGljIG1ldGhvZHNcbi8vXG5cbnRhZ3MuZm9yRWFjaChmdW5jdGlvbih0YWcpIHtcbiAgTm9kZS5wcm90b3R5cGVbdGFnXSA9IGZ1bmN0aW9uIF90YWdNZXRob2QoKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblxuICAgIGFzc2VydChzdGF0ZS50YWcgPT09IG51bGwpO1xuICAgIHN0YXRlLnRhZyA9IHRhZztcblxuICAgIHRoaXMuX3VzZUFyZ3MoYXJncyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbn0pO1xuXG5Ob2RlLnByb3RvdHlwZS51c2UgPSBmdW5jdGlvbiB1c2UoaXRlbSkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG5cbiAgYXNzZXJ0KHN0YXRlLnVzZSA9PT0gbnVsbCk7XG4gIHN0YXRlLnVzZSA9IGl0ZW07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5vcHRpb25hbCA9IGZ1bmN0aW9uIG9wdGlvbmFsKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG5cbiAgc3RhdGUub3B0aW9uYWwgPSB0cnVlO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuTm9kZS5wcm90b3R5cGUuZGVmID0gZnVuY3Rpb24gZGVmKHZhbCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG5cbiAgYXNzZXJ0KHN0YXRlWydkZWZhdWx0J10gPT09IG51bGwpO1xuICBzdGF0ZVsnZGVmYXVsdCddID0gdmFsO1xuICBzdGF0ZS5vcHRpb25hbCA9IHRydWU7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5leHBsaWNpdCA9IGZ1bmN0aW9uIGV4cGxpY2l0KG51bSkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG5cbiAgYXNzZXJ0KHN0YXRlLmV4cGxpY2l0ID09PSBudWxsICYmIHN0YXRlLmltcGxpY2l0ID09PSBudWxsKTtcbiAgc3RhdGUuZXhwbGljaXQgPSBudW07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5pbXBsaWNpdCA9IGZ1bmN0aW9uIGltcGxpY2l0KG51bSkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG5cbiAgYXNzZXJ0KHN0YXRlLmV4cGxpY2l0ID09PSBudWxsICYmIHN0YXRlLmltcGxpY2l0ID09PSBudWxsKTtcbiAgc3RhdGUuaW1wbGljaXQgPSBudW07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5vYmogPSBmdW5jdGlvbiBvYmooKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcbiAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXG4gIHN0YXRlLm9iaiA9IHRydWU7XG5cbiAgaWYgKGFyZ3MubGVuZ3RoICE9PSAwKVxuICAgIHRoaXMuX3VzZUFyZ3MoYXJncyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5rZXkgPSBmdW5jdGlvbiBrZXkobmV3S2V5KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcblxuICBhc3NlcnQoc3RhdGUua2V5ID09PSBudWxsKTtcbiAgc3RhdGUua2V5ID0gbmV3S2V5O1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuTm9kZS5wcm90b3R5cGUuYW55ID0gZnVuY3Rpb24gYW55KCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG5cbiAgc3RhdGUuYW55ID0gdHJ1ZTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbk5vZGUucHJvdG90eXBlLmNob2ljZSA9IGZ1bmN0aW9uIGNob2ljZShvYmopIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuXG4gIGFzc2VydChzdGF0ZS5jaG9pY2UgPT09IG51bGwpO1xuICBzdGF0ZS5jaG9pY2UgPSBvYmo7XG4gIHRoaXMuX3VzZUFyZ3MoT2JqZWN0LmtleXMob2JqKS5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIG9ialtrZXldO1xuICB9KSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vL1xuLy8gRGVjb2Rpbmdcbi8vXG5cbk5vZGUucHJvdG90eXBlLl9kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUoaW5wdXQpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuXG4gIC8vIERlY29kZSByb290IG5vZGVcbiAgaWYgKHN0YXRlLnBhcmVudCA9PT0gbnVsbClcbiAgICByZXR1cm4gaW5wdXQud3JhcFJlc3VsdChzdGF0ZS5jaGlsZHJlblswXS5fZGVjb2RlKGlucHV0KSk7XG5cbiAgdmFyIHJlc3VsdCA9IHN0YXRlWydkZWZhdWx0J107XG4gIHZhciBwcmVzZW50ID0gdHJ1ZTtcblxuICB2YXIgcHJldktleTtcbiAgaWYgKHN0YXRlLmtleSAhPT0gbnVsbClcbiAgICBwcmV2S2V5ID0gaW5wdXQuZW50ZXJLZXkoc3RhdGUua2V5KTtcblxuICAvLyBDaGVjayBpZiB0YWcgaXMgdGhlcmVcbiAgaWYgKHN0YXRlLm9wdGlvbmFsKSB7XG4gICAgdmFyIHRhZyA9IG51bGw7XG4gICAgaWYgKHN0YXRlLmV4cGxpY2l0ICE9PSBudWxsKVxuICAgICAgdGFnID0gc3RhdGUuZXhwbGljaXQ7XG4gICAgZWxzZSBpZiAoc3RhdGUuaW1wbGljaXQgIT09IG51bGwpXG4gICAgICB0YWcgPSBzdGF0ZS5pbXBsaWNpdDtcbiAgICBlbHNlIGlmIChzdGF0ZS50YWcgIT09IG51bGwpXG4gICAgICB0YWcgPSBzdGF0ZS50YWc7XG5cbiAgICBpZiAodGFnID09PSBudWxsICYmICFzdGF0ZS5hbnkpIHtcbiAgICAgIC8vIFRyaWFsIGFuZCBFcnJvclxuICAgICAgdmFyIHNhdmUgPSBpbnB1dC5zYXZlKCk7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoc3RhdGUuY2hvaWNlID09PSBudWxsKVxuICAgICAgICAgIHRoaXMuX2RlY29kZUdlbmVyaWMoc3RhdGUudGFnLCBpbnB1dCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB0aGlzLl9kZWNvZGVDaG9pY2UoaW5wdXQpO1xuICAgICAgICBwcmVzZW50ID0gdHJ1ZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcHJlc2VudCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaW5wdXQucmVzdG9yZShzYXZlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJlc2VudCA9IHRoaXMuX3BlZWtUYWcoaW5wdXQsIHRhZywgc3RhdGUuYW55KTtcblxuICAgICAgaWYgKGlucHV0LmlzRXJyb3IocHJlc2VudCkpXG4gICAgICAgIHJldHVybiBwcmVzZW50O1xuICAgIH1cbiAgfVxuXG4gIC8vIFB1c2ggb2JqZWN0IG9uIHN0YWNrXG4gIHZhciBwcmV2T2JqO1xuICBpZiAoc3RhdGUub2JqICYmIHByZXNlbnQpXG4gICAgcHJldk9iaiA9IGlucHV0LmVudGVyT2JqZWN0KCk7XG5cbiAgaWYgKHByZXNlbnQpIHtcbiAgICAvLyBVbndyYXAgZXhwbGljaXQgdmFsdWVzXG4gICAgaWYgKHN0YXRlLmV4cGxpY2l0ICE9PSBudWxsKSB7XG4gICAgICB2YXIgZXhwbGljaXQgPSB0aGlzLl9kZWNvZGVUYWcoaW5wdXQsIHN0YXRlLmV4cGxpY2l0KTtcbiAgICAgIGlmIChpbnB1dC5pc0Vycm9yKGV4cGxpY2l0KSlcbiAgICAgICAgcmV0dXJuIGV4cGxpY2l0O1xuICAgICAgaW5wdXQgPSBleHBsaWNpdDtcbiAgICB9XG5cbiAgICAvLyBVbndyYXAgaW1wbGljaXQgYW5kIG5vcm1hbCB2YWx1ZXNcbiAgICBpZiAoc3RhdGUudXNlID09PSBudWxsICYmIHN0YXRlLmNob2ljZSA9PT0gbnVsbCkge1xuICAgICAgaWYgKHN0YXRlLmFueSlcbiAgICAgICAgdmFyIHNhdmUgPSBpbnB1dC5zYXZlKCk7XG4gICAgICB2YXIgYm9keSA9IHRoaXMuX2RlY29kZVRhZyhcbiAgICAgICAgaW5wdXQsXG4gICAgICAgIHN0YXRlLmltcGxpY2l0ICE9PSBudWxsID8gc3RhdGUuaW1wbGljaXQgOiBzdGF0ZS50YWcsXG4gICAgICAgIHN0YXRlLmFueVxuICAgICAgKTtcbiAgICAgIGlmIChpbnB1dC5pc0Vycm9yKGJvZHkpKVxuICAgICAgICByZXR1cm4gYm9keTtcblxuICAgICAgaWYgKHN0YXRlLmFueSlcbiAgICAgICAgcmVzdWx0ID0gaW5wdXQucmF3KHNhdmUpO1xuICAgICAgZWxzZVxuICAgICAgICBpbnB1dCA9IGJvZHk7XG4gICAgfVxuXG4gICAgLy8gU2VsZWN0IHByb3BlciBtZXRob2QgZm9yIHRhZ1xuICAgIGlmIChzdGF0ZS5hbnkpXG4gICAgICByZXN1bHQgPSByZXN1bHQ7XG4gICAgZWxzZSBpZiAoc3RhdGUuY2hvaWNlID09PSBudWxsKVxuICAgICAgcmVzdWx0ID0gdGhpcy5fZGVjb2RlR2VuZXJpYyhzdGF0ZS50YWcsIGlucHV0KTtcbiAgICBlbHNlXG4gICAgICByZXN1bHQgPSB0aGlzLl9kZWNvZGVDaG9pY2UoaW5wdXQpO1xuXG4gICAgaWYgKGlucHV0LmlzRXJyb3IocmVzdWx0KSlcbiAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICAvLyBEZWNvZGUgY2hpbGRyZW5cbiAgICBpZiAoIXN0YXRlLmFueSAmJiBzdGF0ZS5jaG9pY2UgPT09IG51bGwgJiYgc3RhdGUuY2hpbGRyZW4gIT09IG51bGwpIHtcbiAgICAgIHZhciBmYWlsID0gc3RhdGUuY2hpbGRyZW4uc29tZShmdW5jdGlvbiBkZWNvZGVDaGlsZHJlbihjaGlsZCkge1xuICAgICAgICAvLyBOT1RFOiBXZSBhcmUgaWdub3JpbmcgZXJyb3JzIGhlcmUsIHRvIGxldCBwYXJzZXIgY29udGludWUgd2l0aCBvdGhlclxuICAgICAgICAvLyBwYXJ0cyBvZiBlbmNvZGVkIGRhdGFcbiAgICAgICAgY2hpbGQuX2RlY29kZShpbnB1dCk7XG4gICAgICB9KTtcbiAgICAgIGlmIChmYWlsKVxuICAgICAgICByZXR1cm4gZXJyO1xuICAgIH1cbiAgfVxuXG4gIC8vIFBvcCBvYmplY3RcbiAgaWYgKHN0YXRlLm9iaiAmJiBwcmVzZW50KVxuICAgIHJlc3VsdCA9IGlucHV0LmxlYXZlT2JqZWN0KHByZXZPYmopO1xuXG4gIC8vIFNldCBrZXlcbiAgaWYgKHN0YXRlLmtleSAhPT0gbnVsbCAmJiAocmVzdWx0ICE9PSBudWxsIHx8IHByZXNlbnQgPT09IHRydWUpKVxuICAgIGlucHV0LmxlYXZlS2V5KHByZXZLZXksIHN0YXRlLmtleSwgcmVzdWx0KTtcblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuTm9kZS5wcm90b3R5cGUuX2RlY29kZUdlbmVyaWMgPSBmdW5jdGlvbiBkZWNvZGVHZW5lcmljKHRhZywgaW5wdXQpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuXG4gIGlmICh0YWcgPT09ICdzZXEnIHx8IHRhZyA9PT0gJ3NldCcpXG4gICAgcmV0dXJuIG51bGw7XG4gIGlmICh0YWcgPT09ICdzZXFvZicgfHwgdGFnID09PSAnc2V0b2YnKVxuICAgIHJldHVybiB0aGlzLl9kZWNvZGVMaXN0KGlucHV0LCB0YWcsIHN0YXRlLmFyZ3NbMF0pO1xuICBlbHNlIGlmICh0YWcgPT09ICdvY3RzdHInIHx8IHRhZyA9PT0gJ2JpdHN0cicpXG4gICAgcmV0dXJuIHRoaXMuX2RlY29kZVN0cihpbnB1dCwgdGFnKTtcbiAgZWxzZSBpZiAodGFnID09PSAnaWE1c3RyJyB8fCB0YWcgPT09ICd1dGY4c3RyJyB8fCB0YWcgPT09ICdibXBzdHInKVxuICAgIHJldHVybiB0aGlzLl9kZWNvZGVTdHIoaW5wdXQsIHRhZyk7XG4gIGVsc2UgaWYgKHRhZyA9PT0gJ251bXN0cicgfHwgdGFnID09PSAncHJpbnRzdHInKVxuICAgIHJldHVybiB0aGlzLl9kZWNvZGVTdHIoaW5wdXQsIHRhZyk7XG4gIGVsc2UgaWYgKHRhZyA9PT0gJ29iamlkJyAmJiBzdGF0ZS5hcmdzKVxuICAgIHJldHVybiB0aGlzLl9kZWNvZGVPYmppZChpbnB1dCwgc3RhdGUuYXJnc1swXSwgc3RhdGUuYXJnc1sxXSk7XG4gIGVsc2UgaWYgKHRhZyA9PT0gJ29iamlkJylcbiAgICByZXR1cm4gdGhpcy5fZGVjb2RlT2JqaWQoaW5wdXQsIG51bGwsIG51bGwpO1xuICBlbHNlIGlmICh0YWcgPT09ICdnZW50aW1lJyB8fCB0YWcgPT09ICd1dGN0aW1lJylcbiAgICByZXR1cm4gdGhpcy5fZGVjb2RlVGltZShpbnB1dCwgdGFnKTtcbiAgZWxzZSBpZiAodGFnID09PSAnbnVsbF8nKVxuICAgIHJldHVybiB0aGlzLl9kZWNvZGVOdWxsKGlucHV0KTtcbiAgZWxzZSBpZiAodGFnID09PSAnYm9vbCcpXG4gICAgcmV0dXJuIHRoaXMuX2RlY29kZUJvb2woaW5wdXQpO1xuICBlbHNlIGlmICh0YWcgPT09ICdpbnQnIHx8IHRhZyA9PT0gJ2VudW0nKVxuICAgIHJldHVybiB0aGlzLl9kZWNvZGVJbnQoaW5wdXQsIHN0YXRlLmFyZ3MgJiYgc3RhdGUuYXJnc1swXSk7XG4gIGVsc2UgaWYgKHN0YXRlLnVzZSAhPT0gbnVsbClcbiAgICByZXR1cm4gdGhpcy5fZ2V0VXNlKHN0YXRlLnVzZSwgaW5wdXQuX3JlcG9ydGVyU3RhdGUub2JqKS5fZGVjb2RlKGlucHV0KTtcbiAgZWxzZVxuICAgIHJldHVybiBpbnB1dC5lcnJvcigndW5rbm93biB0YWc6ICcgKyB0YWcpO1xuXG4gIHJldHVybiBudWxsO1xufTtcblxuTm9kZS5wcm90b3R5cGUuX2dldFVzZSA9IGZ1bmN0aW9uIF9nZXRVc2UoZW50aXR5LCBvYmopIHtcblxuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG4gIC8vIENyZWF0ZSBhbHRlcmVkIHVzZSBkZWNvZGVyIGlmIGltcGxpY2l0IGlzIHNldFxuICBzdGF0ZS51c2VEZWNvZGVyID0gdGhpcy5fdXNlKGVudGl0eSwgb2JqKTtcbiAgYXNzZXJ0KHN0YXRlLnVzZURlY29kZXIuX2Jhc2VTdGF0ZS5wYXJlbnQgPT09IG51bGwpO1xuICBzdGF0ZS51c2VEZWNvZGVyID0gc3RhdGUudXNlRGVjb2Rlci5fYmFzZVN0YXRlLmNoaWxkcmVuWzBdO1xuICBpZiAoc3RhdGUuaW1wbGljaXQgIT09IHN0YXRlLnVzZURlY29kZXIuX2Jhc2VTdGF0ZS5pbXBsaWNpdCkge1xuICAgIHN0YXRlLnVzZURlY29kZXIgPSBzdGF0ZS51c2VEZWNvZGVyLmNsb25lKCk7XG4gICAgc3RhdGUudXNlRGVjb2Rlci5fYmFzZVN0YXRlLmltcGxpY2l0ID0gc3RhdGUuaW1wbGljaXQ7XG4gIH1cbiAgcmV0dXJuIHN0YXRlLnVzZURlY29kZXI7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5fZGVjb2RlQ2hvaWNlID0gZnVuY3Rpb24gZGVjb2RlQ2hvaWNlKGlucHV0KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcbiAgdmFyIHJlc3VsdCA9IG51bGw7XG4gIHZhciBtYXRjaCA9IGZhbHNlO1xuXG4gIE9iamVjdC5rZXlzKHN0YXRlLmNob2ljZSkuc29tZShmdW5jdGlvbihrZXkpIHtcbiAgICB2YXIgc2F2ZSA9IGlucHV0LnNhdmUoKTtcbiAgICB2YXIgbm9kZSA9IHN0YXRlLmNob2ljZVtrZXldO1xuICAgIHRyeSB7XG4gICAgICB2YXIgdmFsdWUgPSBub2RlLl9kZWNvZGUoaW5wdXQpO1xuICAgICAgaWYgKGlucHV0LmlzRXJyb3IodmFsdWUpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgIHJlc3VsdCA9IHsgdHlwZToga2V5LCB2YWx1ZTogdmFsdWUgfTtcbiAgICAgIG1hdGNoID0gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpbnB1dC5yZXN0b3JlKHNhdmUpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgdGhpcyk7XG5cbiAgaWYgKCFtYXRjaClcbiAgICByZXR1cm4gaW5wdXQuZXJyb3IoJ0Nob2ljZSBub3QgbWF0Y2hlZCcpO1xuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vL1xuLy8gRW5jb2Rpbmdcbi8vXG5cbk5vZGUucHJvdG90eXBlLl9jcmVhdGVFbmNvZGVyQnVmZmVyID0gZnVuY3Rpb24gY3JlYXRlRW5jb2RlckJ1ZmZlcihkYXRhKSB7XG4gIHJldHVybiBuZXcgRW5jb2RlckJ1ZmZlcihkYXRhLCB0aGlzLnJlcG9ydGVyKTtcbn07XG5cbk5vZGUucHJvdG90eXBlLl9lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUoZGF0YSwgcmVwb3J0ZXIsIHBhcmVudCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG4gIGlmIChzdGF0ZVsnZGVmYXVsdCddICE9PSBudWxsICYmIHN0YXRlWydkZWZhdWx0J10gPT09IGRhdGEpXG4gICAgcmV0dXJuO1xuXG4gIHZhciByZXN1bHQgPSB0aGlzLl9lbmNvZGVWYWx1ZShkYXRhLCByZXBvcnRlciwgcGFyZW50KTtcbiAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybjtcblxuICBpZiAodGhpcy5fc2tpcERlZmF1bHQocmVzdWx0LCByZXBvcnRlciwgcGFyZW50KSlcbiAgICByZXR1cm47XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbk5vZGUucHJvdG90eXBlLl9lbmNvZGVWYWx1ZSA9IGZ1bmN0aW9uIGVuY29kZShkYXRhLCByZXBvcnRlciwgcGFyZW50KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcblxuICAvLyBEZWNvZGUgcm9vdCBub2RlXG4gIGlmIChzdGF0ZS5wYXJlbnQgPT09IG51bGwpXG4gICAgcmV0dXJuIHN0YXRlLmNoaWxkcmVuWzBdLl9lbmNvZGUoZGF0YSwgcmVwb3J0ZXIgfHwgbmV3IFJlcG9ydGVyKCkpO1xuXG4gIHZhciByZXN1bHQgPSBudWxsO1xuICB2YXIgcHJlc2VudCA9IHRydWU7XG5cbiAgLy8gU2V0IHJlcG9ydGVyIHRvIHNoYXJlIGl0IHdpdGggYSBjaGlsZCBjbGFzc1xuICB0aGlzLnJlcG9ydGVyID0gcmVwb3J0ZXI7XG5cbiAgLy8gQ2hlY2sgaWYgZGF0YSBpcyB0aGVyZVxuICBpZiAoc3RhdGUub3B0aW9uYWwgJiYgZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHN0YXRlWydkZWZhdWx0J10gIT09IG51bGwpXG4gICAgICBkYXRhID0gc3RhdGVbJ2RlZmF1bHQnXVxuICAgIGVsc2VcbiAgICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEZvciBlcnJvciByZXBvcnRpbmdcbiAgdmFyIHByZXZLZXk7XG5cbiAgLy8gRW5jb2RlIGNoaWxkcmVuIGZpcnN0XG4gIHZhciBjb250ZW50ID0gbnVsbDtcbiAgdmFyIHByaW1pdGl2ZSA9IGZhbHNlO1xuICBpZiAoc3RhdGUuYW55KSB7XG4gICAgLy8gQW55dGhpbmcgdGhhdCB3YXMgZ2l2ZW4gaXMgdHJhbnNsYXRlZCB0byBidWZmZXJcbiAgICByZXN1bHQgPSB0aGlzLl9jcmVhdGVFbmNvZGVyQnVmZmVyKGRhdGEpO1xuICB9IGVsc2UgaWYgKHN0YXRlLmNob2ljZSkge1xuICAgIHJlc3VsdCA9IHRoaXMuX2VuY29kZUNob2ljZShkYXRhLCByZXBvcnRlcik7XG4gIH0gZWxzZSBpZiAoc3RhdGUuY2hpbGRyZW4pIHtcbiAgICBjb250ZW50ID0gc3RhdGUuY2hpbGRyZW4ubWFwKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICBpZiAoY2hpbGQuX2Jhc2VTdGF0ZS50YWcgPT09ICdudWxsXycpXG4gICAgICAgIHJldHVybiBjaGlsZC5fZW5jb2RlKG51bGwsIHJlcG9ydGVyLCBkYXRhKTtcblxuICAgICAgaWYgKGNoaWxkLl9iYXNlU3RhdGUua2V5ID09PSBudWxsKVxuICAgICAgICByZXR1cm4gcmVwb3J0ZXIuZXJyb3IoJ0NoaWxkIHNob3VsZCBoYXZlIGEga2V5Jyk7XG4gICAgICB2YXIgcHJldktleSA9IHJlcG9ydGVyLmVudGVyS2V5KGNoaWxkLl9iYXNlU3RhdGUua2V5KTtcblxuICAgICAgaWYgKHR5cGVvZiBkYXRhICE9PSAnb2JqZWN0JylcbiAgICAgICAgcmV0dXJuIHJlcG9ydGVyLmVycm9yKCdDaGlsZCBleHBlY3RlZCwgYnV0IGlucHV0IGlzIG5vdCBvYmplY3QnKTtcblxuICAgICAgdmFyIHJlcyA9IGNoaWxkLl9lbmNvZGUoZGF0YVtjaGlsZC5fYmFzZVN0YXRlLmtleV0sIHJlcG9ydGVyLCBkYXRhKTtcbiAgICAgIHJlcG9ydGVyLmxlYXZlS2V5KHByZXZLZXkpO1xuXG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0sIHRoaXMpLmZpbHRlcihmdW5jdGlvbihjaGlsZCkge1xuICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH0pO1xuXG4gICAgY29udGVudCA9IHRoaXMuX2NyZWF0ZUVuY29kZXJCdWZmZXIoY29udGVudCk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHN0YXRlLnRhZyA9PT0gJ3NlcW9mJyB8fCBzdGF0ZS50YWcgPT09ICdzZXRvZicpIHtcbiAgICAgIC8vIFRPRE8oaW5kdXRueSk6IHRoaXMgc2hvdWxkIGJlIHRocm93biBvbiBEU0wgbGV2ZWxcbiAgICAgIGlmICghKHN0YXRlLmFyZ3MgJiYgc3RhdGUuYXJncy5sZW5ndGggPT09IDEpKVxuICAgICAgICByZXR1cm4gcmVwb3J0ZXIuZXJyb3IoJ1RvbyBtYW55IGFyZ3MgZm9yIDogJyArIHN0YXRlLnRhZyk7XG5cbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShkYXRhKSlcbiAgICAgICAgcmV0dXJuIHJlcG9ydGVyLmVycm9yKCdzZXFvZi9zZXRvZiwgYnV0IGRhdGEgaXMgbm90IEFycmF5Jyk7XG5cbiAgICAgIHZhciBjaGlsZCA9IHRoaXMuY2xvbmUoKTtcbiAgICAgIGNoaWxkLl9iYXNlU3RhdGUuaW1wbGljaXQgPSBudWxsO1xuICAgICAgY29udGVudCA9IHRoaXMuX2NyZWF0ZUVuY29kZXJCdWZmZXIoZGF0YS5tYXAoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFVzZShzdGF0ZS5hcmdzWzBdLCBkYXRhKS5fZW5jb2RlKGl0ZW0sIHJlcG9ydGVyKTtcbiAgICAgIH0sIGNoaWxkKSk7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS51c2UgIT09IG51bGwpIHtcbiAgICAgIHJlc3VsdCA9IHRoaXMuX2dldFVzZShzdGF0ZS51c2UsIHBhcmVudCkuX2VuY29kZShkYXRhLCByZXBvcnRlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRlbnQgPSB0aGlzLl9lbmNvZGVQcmltaXRpdmUoc3RhdGUudGFnLCBkYXRhKTtcbiAgICAgIHByaW1pdGl2ZSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLy8gRW5jb2RlIGRhdGEgaXRzZWxmXG4gIHZhciByZXN1bHQ7XG4gIGlmICghc3RhdGUuYW55ICYmIHN0YXRlLmNob2ljZSA9PT0gbnVsbCkge1xuICAgIHZhciB0YWcgPSBzdGF0ZS5pbXBsaWNpdCAhPT0gbnVsbCA/IHN0YXRlLmltcGxpY2l0IDogc3RhdGUudGFnO1xuICAgIHZhciBjbHMgPSBzdGF0ZS5pbXBsaWNpdCA9PT0gbnVsbCA/ICd1bml2ZXJzYWwnIDogJ2NvbnRleHQnO1xuXG4gICAgaWYgKHRhZyA9PT0gbnVsbCkge1xuICAgICAgaWYgKHN0YXRlLnVzZSA9PT0gbnVsbClcbiAgICAgICAgcmVwb3J0ZXIuZXJyb3IoJ1RhZyBjb3VsZCBiZSBvbW1pdGVkIG9ubHkgZm9yIC51c2UoKScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc3RhdGUudXNlID09PSBudWxsKVxuICAgICAgICByZXN1bHQgPSB0aGlzLl9lbmNvZGVDb21wb3NpdGUodGFnLCBwcmltaXRpdmUsIGNscywgY29udGVudCk7XG4gICAgfVxuICB9XG5cbiAgLy8gV3JhcCBpbiBleHBsaWNpdFxuICBpZiAoc3RhdGUuZXhwbGljaXQgIT09IG51bGwpXG4gICAgcmVzdWx0ID0gdGhpcy5fZW5jb2RlQ29tcG9zaXRlKHN0YXRlLmV4cGxpY2l0LCBmYWxzZSwgJ2NvbnRleHQnLCByZXN1bHQpO1xuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5fZW5jb2RlQ2hvaWNlID0gZnVuY3Rpb24gZW5jb2RlQ2hvaWNlKGRhdGEsIHJlcG9ydGVyKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcblxuICB2YXIgbm9kZSA9IHN0YXRlLmNob2ljZVtkYXRhLnR5cGVdO1xuICBpZiAoIW5vZGUpIHtcbiAgICBhc3NlcnQoXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBkYXRhLnR5cGUgKyAnIG5vdCBmb3VuZCBpbiAnICtcbiAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KE9iamVjdC5rZXlzKHN0YXRlLmNob2ljZSkpKTtcbiAgfVxuICByZXR1cm4gbm9kZS5fZW5jb2RlKGRhdGEudmFsdWUsIHJlcG9ydGVyKTtcbn07XG5cbk5vZGUucHJvdG90eXBlLl9lbmNvZGVQcmltaXRpdmUgPSBmdW5jdGlvbiBlbmNvZGVQcmltaXRpdmUodGFnLCBkYXRhKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcblxuICBpZiAodGFnID09PSAnb2N0c3RyJyB8fCB0YWcgPT09ICdiaXRzdHInIHx8IHRhZyA9PT0gJ2lhNXN0cicpXG4gICAgcmV0dXJuIHRoaXMuX2VuY29kZVN0cihkYXRhLCB0YWcpO1xuICBlbHNlIGlmICh0YWcgPT09ICd1dGY4c3RyJyB8fCB0YWcgPT09ICdibXBzdHInKVxuICAgIHJldHVybiB0aGlzLl9lbmNvZGVTdHIoZGF0YSwgdGFnKTtcbiAgZWxzZSBpZiAodGFnID09PSAnbnVtc3RyJyB8fCB0YWcgPT09ICdwcmludHN0cicpXG4gICAgcmV0dXJuIHRoaXMuX2VuY29kZVN0cihkYXRhLCB0YWcpO1xuICBlbHNlIGlmICh0YWcgPT09ICdvYmppZCcgJiYgc3RhdGUuYXJncylcbiAgICByZXR1cm4gdGhpcy5fZW5jb2RlT2JqaWQoZGF0YSwgc3RhdGUucmV2ZXJzZUFyZ3NbMF0sIHN0YXRlLmFyZ3NbMV0pO1xuICBlbHNlIGlmICh0YWcgPT09ICdvYmppZCcpXG4gICAgcmV0dXJuIHRoaXMuX2VuY29kZU9iamlkKGRhdGEsIG51bGwsIG51bGwpO1xuICBlbHNlIGlmICh0YWcgPT09ICdnZW50aW1lJyB8fCB0YWcgPT09ICd1dGN0aW1lJylcbiAgICByZXR1cm4gdGhpcy5fZW5jb2RlVGltZShkYXRhLCB0YWcpO1xuICBlbHNlIGlmICh0YWcgPT09ICdudWxsXycpXG4gICAgcmV0dXJuIHRoaXMuX2VuY29kZU51bGwoKTtcbiAgZWxzZSBpZiAodGFnID09PSAnaW50JyB8fCB0YWcgPT09ICdlbnVtJylcbiAgICByZXR1cm4gdGhpcy5fZW5jb2RlSW50KGRhdGEsIHN0YXRlLmFyZ3MgJiYgc3RhdGUucmV2ZXJzZUFyZ3NbMF0pO1xuICBlbHNlIGlmICh0YWcgPT09ICdib29sJylcbiAgICByZXR1cm4gdGhpcy5fZW5jb2RlQm9vbChkYXRhKTtcbiAgZWxzZVxuICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgdGFnOiAnICsgdGFnKTtcbn07XG5cbk5vZGUucHJvdG90eXBlLl9pc051bXN0ciA9IGZ1bmN0aW9uIGlzTnVtc3RyKHN0cikge1xuICByZXR1cm4gL15bMC05IF0qJC8udGVzdChzdHIpO1xufTtcblxuTm9kZS5wcm90b3R5cGUuX2lzUHJpbnRzdHIgPSBmdW5jdGlvbiBpc1ByaW50c3RyKHN0cikge1xuICByZXR1cm4gL15bQS1aYS16MC05ICdcXChcXClcXCssXFwtXFwuXFwvOj1cXD9dKiQvLnRlc3Qoc3RyKTtcbn07IiwidmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuZnVuY3Rpb24gUmVwb3J0ZXIob3B0aW9ucykge1xuICB0aGlzLl9yZXBvcnRlclN0YXRlID0ge1xuICAgIG9iajogbnVsbCxcbiAgICBwYXRoOiBbXSxcbiAgICBvcHRpb25zOiBvcHRpb25zIHx8IHt9LFxuICAgIGVycm9yczogW11cbiAgfTtcbn1cbmV4cG9ydHMuUmVwb3J0ZXIgPSBSZXBvcnRlcjtcblxuUmVwb3J0ZXIucHJvdG90eXBlLmlzRXJyb3IgPSBmdW5jdGlvbiBpc0Vycm9yKG9iaikge1xuICByZXR1cm4gb2JqIGluc3RhbmNlb2YgUmVwb3J0ZXJFcnJvcjtcbn07XG5cblJlcG9ydGVyLnByb3RvdHlwZS5zYXZlID0gZnVuY3Rpb24gc2F2ZSgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVwb3J0ZXJTdGF0ZTtcblxuICByZXR1cm4geyBvYmo6IHN0YXRlLm9iaiwgcGF0aExlbjogc3RhdGUucGF0aC5sZW5ndGggfTtcbn07XG5cblJlcG9ydGVyLnByb3RvdHlwZS5yZXN0b3JlID0gZnVuY3Rpb24gcmVzdG9yZShkYXRhKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlcG9ydGVyU3RhdGU7XG5cbiAgc3RhdGUub2JqID0gZGF0YS5vYmo7XG4gIHN0YXRlLnBhdGggPSBzdGF0ZS5wYXRoLnNsaWNlKDAsIGRhdGEucGF0aExlbik7XG59O1xuXG5SZXBvcnRlci5wcm90b3R5cGUuZW50ZXJLZXkgPSBmdW5jdGlvbiBlbnRlcktleShrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX3JlcG9ydGVyU3RhdGUucGF0aC5wdXNoKGtleSk7XG59O1xuXG5SZXBvcnRlci5wcm90b3R5cGUubGVhdmVLZXkgPSBmdW5jdGlvbiBsZWF2ZUtleShpbmRleCwga2V5LCB2YWx1ZSkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZXBvcnRlclN0YXRlO1xuXG4gIHN0YXRlLnBhdGggPSBzdGF0ZS5wYXRoLnNsaWNlKDAsIGluZGV4IC0gMSk7XG4gIGlmIChzdGF0ZS5vYmogIT09IG51bGwpXG4gICAgc3RhdGUub2JqW2tleV0gPSB2YWx1ZTtcbn07XG5cblJlcG9ydGVyLnByb3RvdHlwZS5lbnRlck9iamVjdCA9IGZ1bmN0aW9uIGVudGVyT2JqZWN0KCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZXBvcnRlclN0YXRlO1xuXG4gIHZhciBwcmV2ID0gc3RhdGUub2JqO1xuICBzdGF0ZS5vYmogPSB7fTtcbiAgcmV0dXJuIHByZXY7XG59O1xuXG5SZXBvcnRlci5wcm90b3R5cGUubGVhdmVPYmplY3QgPSBmdW5jdGlvbiBsZWF2ZU9iamVjdChwcmV2KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlcG9ydGVyU3RhdGU7XG5cbiAgdmFyIG5vdyA9IHN0YXRlLm9iajtcbiAgc3RhdGUub2JqID0gcHJldjtcbiAgcmV0dXJuIG5vdztcbn07XG5cblJlcG9ydGVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIGVycm9yKG1zZykge1xuICB2YXIgZXJyO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZXBvcnRlclN0YXRlO1xuXG4gIHZhciBpbmhlcml0ZWQgPSBtc2cgaW5zdGFuY2VvZiBSZXBvcnRlckVycm9yO1xuICBpZiAoaW5oZXJpdGVkKSB7XG4gICAgZXJyID0gbXNnO1xuICB9IGVsc2Uge1xuICAgIGVyciA9IG5ldyBSZXBvcnRlckVycm9yKHN0YXRlLnBhdGgubWFwKGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgIHJldHVybiAnWycgKyBKU09OLnN0cmluZ2lmeShlbGVtKSArICddJztcbiAgICB9KS5qb2luKCcnKSwgbXNnLm1lc3NhZ2UgfHwgbXNnLCBtc2cuc3RhY2spO1xuICB9XG5cbiAgaWYgKCFzdGF0ZS5vcHRpb25zLnBhcnRpYWwpXG4gICAgdGhyb3cgZXJyO1xuXG4gIGlmICghaW5oZXJpdGVkKVxuICAgIHN0YXRlLmVycm9ycy5wdXNoKGVycik7XG5cbiAgcmV0dXJuIGVycjtcbn07XG5cblJlcG9ydGVyLnByb3RvdHlwZS53cmFwUmVzdWx0ID0gZnVuY3Rpb24gd3JhcFJlc3VsdChyZXN1bHQpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVwb3J0ZXJTdGF0ZTtcbiAgaWYgKCFzdGF0ZS5vcHRpb25zLnBhcnRpYWwpXG4gICAgcmV0dXJuIHJlc3VsdDtcblxuICByZXR1cm4ge1xuICAgIHJlc3VsdDogdGhpcy5pc0Vycm9yKHJlc3VsdCkgPyBudWxsIDogcmVzdWx0LFxuICAgIGVycm9yczogc3RhdGUuZXJyb3JzXG4gIH07XG59O1xuXG5mdW5jdGlvbiBSZXBvcnRlckVycm9yKHBhdGgsIG1zZykge1xuICB0aGlzLnBhdGggPSBwYXRoO1xuICB0aGlzLnJldGhyb3cobXNnKTtcbn07XG5pbmhlcml0cyhSZXBvcnRlckVycm9yLCBFcnJvcik7XG5cblJlcG9ydGVyRXJyb3IucHJvdG90eXBlLnJldGhyb3cgPSBmdW5jdGlvbiByZXRocm93KG1zZykge1xuICB0aGlzLm1lc3NhZ2UgPSBtc2cgKyAnIGF0OiAnICsgKHRoaXMucGF0aCB8fCAnKHNoYWxsb3cpJyk7XG4gIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIFJlcG9ydGVyRXJyb3IpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcbiIsInZhciBjb25zdGFudHMgPSByZXF1aXJlKCcuLi9jb25zdGFudHMnKTtcblxuZXhwb3J0cy50YWdDbGFzcyA9IHtcbiAgMDogJ3VuaXZlcnNhbCcsXG4gIDE6ICdhcHBsaWNhdGlvbicsXG4gIDI6ICdjb250ZXh0JyxcbiAgMzogJ3ByaXZhdGUnXG59O1xuZXhwb3J0cy50YWdDbGFzc0J5TmFtZSA9IGNvbnN0YW50cy5fcmV2ZXJzZShleHBvcnRzLnRhZ0NsYXNzKTtcblxuZXhwb3J0cy50YWcgPSB7XG4gIDB4MDA6ICdlbmQnLFxuICAweDAxOiAnYm9vbCcsXG4gIDB4MDI6ICdpbnQnLFxuICAweDAzOiAnYml0c3RyJyxcbiAgMHgwNDogJ29jdHN0cicsXG4gIDB4MDU6ICdudWxsXycsXG4gIDB4MDY6ICdvYmppZCcsXG4gIDB4MDc6ICdvYmpEZXNjJyxcbiAgMHgwODogJ2V4dGVybmFsJyxcbiAgMHgwOTogJ3JlYWwnLFxuICAweDBhOiAnZW51bScsXG4gIDB4MGI6ICdlbWJlZCcsXG4gIDB4MGM6ICd1dGY4c3RyJyxcbiAgMHgwZDogJ3JlbGF0aXZlT2lkJyxcbiAgMHgxMDogJ3NlcScsXG4gIDB4MTE6ICdzZXQnLFxuICAweDEyOiAnbnVtc3RyJyxcbiAgMHgxMzogJ3ByaW50c3RyJyxcbiAgMHgxNDogJ3Q2MXN0cicsXG4gIDB4MTU6ICd2aWRlb3N0cicsXG4gIDB4MTY6ICdpYTVzdHInLFxuICAweDE3OiAndXRjdGltZScsXG4gIDB4MTg6ICdnZW50aW1lJyxcbiAgMHgxOTogJ2dyYXBoc3RyJyxcbiAgMHgxYTogJ2lzbzY0NnN0cicsXG4gIDB4MWI6ICdnZW5zdHInLFxuICAweDFjOiAndW5pc3RyJyxcbiAgMHgxZDogJ2NoYXJzdHInLFxuICAweDFlOiAnYm1wc3RyJ1xufTtcbmV4cG9ydHMudGFnQnlOYW1lID0gY29uc3RhbnRzLl9yZXZlcnNlKGV4cG9ydHMudGFnKTtcbiIsInZhciBjb25zdGFudHMgPSBleHBvcnRzO1xuXG4vLyBIZWxwZXJcbmNvbnN0YW50cy5fcmV2ZXJzZSA9IGZ1bmN0aW9uIHJldmVyc2UobWFwKSB7XG4gIHZhciByZXMgPSB7fTtcblxuICBPYmplY3Qua2V5cyhtYXApLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgLy8gQ29udmVydCBrZXkgdG8gaW50ZWdlciBpZiBpdCBpcyBzdHJpbmdpZmllZFxuICAgIGlmICgoa2V5IHwgMCkgPT0ga2V5KVxuICAgICAga2V5ID0ga2V5IHwgMDtcblxuICAgIHZhciB2YWx1ZSA9IG1hcFtrZXldO1xuICAgIHJlc1t2YWx1ZV0gPSBrZXk7XG4gIH0pO1xuXG4gIHJldHVybiByZXM7XG59O1xuXG5jb25zdGFudHMuZGVyID0gcmVxdWlyZSgnLi9kZXInKTtcbiIsInZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbnZhciBhc24xID0gcmVxdWlyZSgnLi4vLi4vYXNuMScpO1xudmFyIGJhc2UgPSBhc24xLmJhc2U7XG52YXIgYmlnbnVtID0gYXNuMS5iaWdudW07XG5cbi8vIEltcG9ydCBERVIgY29uc3RhbnRzXG52YXIgZGVyID0gYXNuMS5jb25zdGFudHMuZGVyO1xuXG5mdW5jdGlvbiBERVJEZWNvZGVyKGVudGl0eSkge1xuICB0aGlzLmVuYyA9ICdkZXInO1xuICB0aGlzLm5hbWUgPSBlbnRpdHkubmFtZTtcbiAgdGhpcy5lbnRpdHkgPSBlbnRpdHk7XG5cbiAgLy8gQ29uc3RydWN0IGJhc2UgdHJlZVxuICB0aGlzLnRyZWUgPSBuZXcgREVSTm9kZSgpO1xuICB0aGlzLnRyZWUuX2luaXQoZW50aXR5LmJvZHkpO1xufTtcbm1vZHVsZS5leHBvcnRzID0gREVSRGVjb2RlcjtcblxuREVSRGVjb2Rlci5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKGRhdGEsIG9wdGlvbnMpIHtcbiAgaWYgKCEoZGF0YSBpbnN0YW5jZW9mIGJhc2UuRGVjb2RlckJ1ZmZlcikpXG4gICAgZGF0YSA9IG5ldyBiYXNlLkRlY29kZXJCdWZmZXIoZGF0YSwgb3B0aW9ucyk7XG5cbiAgcmV0dXJuIHRoaXMudHJlZS5fZGVjb2RlKGRhdGEsIG9wdGlvbnMpO1xufTtcblxuLy8gVHJlZSBtZXRob2RzXG5cbmZ1bmN0aW9uIERFUk5vZGUocGFyZW50KSB7XG4gIGJhc2UuTm9kZS5jYWxsKHRoaXMsICdkZXInLCBwYXJlbnQpO1xufVxuaW5oZXJpdHMoREVSTm9kZSwgYmFzZS5Ob2RlKTtcblxuREVSTm9kZS5wcm90b3R5cGUuX3BlZWtUYWcgPSBmdW5jdGlvbiBwZWVrVGFnKGJ1ZmZlciwgdGFnLCBhbnkpIHtcbiAgaWYgKGJ1ZmZlci5pc0VtcHR5KCkpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBzdGF0ZSA9IGJ1ZmZlci5zYXZlKCk7XG4gIHZhciBkZWNvZGVkVGFnID0gZGVyRGVjb2RlVGFnKGJ1ZmZlciwgJ0ZhaWxlZCB0byBwZWVrIHRhZzogXCInICsgdGFnICsgJ1wiJyk7XG4gIGlmIChidWZmZXIuaXNFcnJvcihkZWNvZGVkVGFnKSlcbiAgICByZXR1cm4gZGVjb2RlZFRhZztcblxuICBidWZmZXIucmVzdG9yZShzdGF0ZSk7XG5cbiAgcmV0dXJuIGRlY29kZWRUYWcudGFnID09PSB0YWcgfHwgZGVjb2RlZFRhZy50YWdTdHIgPT09IHRhZyB8fCBhbnk7XG59O1xuXG5ERVJOb2RlLnByb3RvdHlwZS5fZGVjb2RlVGFnID0gZnVuY3Rpb24gZGVjb2RlVGFnKGJ1ZmZlciwgdGFnLCBhbnkpIHtcbiAgdmFyIGRlY29kZWRUYWcgPSBkZXJEZWNvZGVUYWcoYnVmZmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnRmFpbGVkIHRvIGRlY29kZSB0YWcgb2YgXCInICsgdGFnICsgJ1wiJyk7XG4gIGlmIChidWZmZXIuaXNFcnJvcihkZWNvZGVkVGFnKSlcbiAgICByZXR1cm4gZGVjb2RlZFRhZztcblxuICB2YXIgbGVuID0gZGVyRGVjb2RlTGVuKGJ1ZmZlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkVGFnLnByaW1pdGl2ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAnRmFpbGVkIHRvIGdldCBsZW5ndGggb2YgXCInICsgdGFnICsgJ1wiJyk7XG5cbiAgLy8gRmFpbHVyZVxuICBpZiAoYnVmZmVyLmlzRXJyb3IobGVuKSlcbiAgICByZXR1cm4gbGVuO1xuXG4gIGlmICghYW55ICYmXG4gICAgICBkZWNvZGVkVGFnLnRhZyAhPT0gdGFnICYmXG4gICAgICBkZWNvZGVkVGFnLnRhZ1N0ciAhPT0gdGFnICYmXG4gICAgICBkZWNvZGVkVGFnLnRhZ1N0ciArICdvZicgIT09IHRhZykge1xuICAgIHJldHVybiBidWZmZXIuZXJyb3IoJ0ZhaWxlZCB0byBtYXRjaCB0YWc6IFwiJyArIHRhZyArICdcIicpO1xuICB9XG5cbiAgaWYgKGRlY29kZWRUYWcucHJpbWl0aXZlIHx8IGxlbiAhPT0gbnVsbClcbiAgICByZXR1cm4gYnVmZmVyLnNraXAobGVuLCAnRmFpbGVkIHRvIG1hdGNoIGJvZHkgb2Y6IFwiJyArIHRhZyArICdcIicpO1xuXG4gIC8vIEluZGVmaW5pdGUgbGVuZ3RoLi4uIGZpbmQgRU5EIHRhZ1xuICB2YXIgc3RhdGUgPSBidWZmZXIuc2F2ZSgpO1xuICB2YXIgcmVzID0gdGhpcy5fc2tpcFVudGlsRW5kKFxuICAgICAgYnVmZmVyLFxuICAgICAgJ0ZhaWxlZCB0byBza2lwIGluZGVmaW5pdGUgbGVuZ3RoIGJvZHk6IFwiJyArIHRoaXMudGFnICsgJ1wiJyk7XG4gIGlmIChidWZmZXIuaXNFcnJvcihyZXMpKVxuICAgIHJldHVybiByZXM7XG5cbiAgbGVuID0gYnVmZmVyLm9mZnNldCAtIHN0YXRlLm9mZnNldDtcbiAgYnVmZmVyLnJlc3RvcmUoc3RhdGUpO1xuICByZXR1cm4gYnVmZmVyLnNraXAobGVuLCAnRmFpbGVkIHRvIG1hdGNoIGJvZHkgb2Y6IFwiJyArIHRhZyArICdcIicpO1xufTtcblxuREVSTm9kZS5wcm90b3R5cGUuX3NraXBVbnRpbEVuZCA9IGZ1bmN0aW9uIHNraXBVbnRpbEVuZChidWZmZXIsIGZhaWwpIHtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICB2YXIgdGFnID0gZGVyRGVjb2RlVGFnKGJ1ZmZlciwgZmFpbCk7XG4gICAgaWYgKGJ1ZmZlci5pc0Vycm9yKHRhZykpXG4gICAgICByZXR1cm4gdGFnO1xuICAgIHZhciBsZW4gPSBkZXJEZWNvZGVMZW4oYnVmZmVyLCB0YWcucHJpbWl0aXZlLCBmYWlsKTtcbiAgICBpZiAoYnVmZmVyLmlzRXJyb3IobGVuKSlcbiAgICAgIHJldHVybiBsZW47XG5cbiAgICB2YXIgcmVzO1xuICAgIGlmICh0YWcucHJpbWl0aXZlIHx8IGxlbiAhPT0gbnVsbClcbiAgICAgIHJlcyA9IGJ1ZmZlci5za2lwKGxlbilcbiAgICBlbHNlXG4gICAgICByZXMgPSB0aGlzLl9za2lwVW50aWxFbmQoYnVmZmVyLCBmYWlsKTtcblxuICAgIC8vIEZhaWx1cmVcbiAgICBpZiAoYnVmZmVyLmlzRXJyb3IocmVzKSlcbiAgICAgIHJldHVybiByZXM7XG5cbiAgICBpZiAodGFnLnRhZ1N0ciA9PT0gJ2VuZCcpXG4gICAgICBicmVhaztcbiAgfVxufTtcblxuREVSTm9kZS5wcm90b3R5cGUuX2RlY29kZUxpc3QgPSBmdW5jdGlvbiBkZWNvZGVMaXN0KGJ1ZmZlciwgdGFnLCBkZWNvZGVyKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgd2hpbGUgKCFidWZmZXIuaXNFbXB0eSgpKSB7XG4gICAgdmFyIHBvc3NpYmxlRW5kID0gdGhpcy5fcGVla1RhZyhidWZmZXIsICdlbmQnKTtcbiAgICBpZiAoYnVmZmVyLmlzRXJyb3IocG9zc2libGVFbmQpKVxuICAgICAgcmV0dXJuIHBvc3NpYmxlRW5kO1xuXG4gICAgdmFyIHJlcyA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlciwgJ2RlcicpO1xuICAgIGlmIChidWZmZXIuaXNFcnJvcihyZXMpICYmIHBvc3NpYmxlRW5kKVxuICAgICAgYnJlYWs7XG4gICAgcmVzdWx0LnB1c2gocmVzKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuREVSTm9kZS5wcm90b3R5cGUuX2RlY29kZVN0ciA9IGZ1bmN0aW9uIGRlY29kZVN0cihidWZmZXIsIHRhZykge1xuICBpZiAodGFnID09PSAnb2N0c3RyJykge1xuICAgIHJldHVybiBidWZmZXIucmF3KCk7XG4gIH0gZWxzZSBpZiAodGFnID09PSAnYml0c3RyJykge1xuICAgIHZhciB1bnVzZWQgPSBidWZmZXIucmVhZFVJbnQ4KCk7XG4gICAgaWYgKGJ1ZmZlci5pc0Vycm9yKHVudXNlZCkpXG4gICAgICByZXR1cm4gdW51c2VkO1xuXG4gICAgcmV0dXJuIHsgdW51c2VkOiB1bnVzZWQsIGRhdGE6IGJ1ZmZlci5yYXcoKSB9O1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lhNXN0cicgfHwgdGFnID09PSAndXRmOHN0cicpIHtcbiAgICByZXR1cm4gYnVmZmVyLnJhdygpLnRvU3RyaW5nKCk7XG4gIH0gZWxzZSBpZih0YWcgPT09ICdudW1zdHInKSB7XG4gICAgdmFyIG51bXN0ciA9IGJ1ZmZlci5yYXcoKS50b1N0cmluZygnYXNjaWknKTtcbiAgICBpZiAoIXRoaXMuX2lzTnVtc3RyKG51bXN0cikpIHtcbiAgICAgIHJldHVybiBidWZmZXIuZXJyb3IoJ0RlY29kaW5nIG9mIHN0cmluZyB0eXBlOiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ251bXN0ciB1bnN1cHBvcnRlZCBjaGFyYWN0ZXJzJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bXN0cjtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdwcmludHN0cicpIHtcbiAgICB2YXIgcHJpbnRzdHIgPSBidWZmZXIucmF3KCkudG9TdHJpbmcoJ2FzY2lpJyk7XG4gICAgaWYgKCF0aGlzLl9pc1ByaW50c3RyKHByaW50c3RyKSkge1xuICAgICAgcmV0dXJuIGJ1ZmZlci5lcnJvcignRGVjb2Rpbmcgb2Ygc3RyaW5nIHR5cGU6ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAncHJpbnRzdHIgdW5zdXBwb3J0ZWQgY2hhcmFjdGVycycpO1xuICAgIH1cblxuICAgIHJldHVybiBwcmludHN0cjtcbiAgfSBlbHNlIGlmKHRhZyA9PT0gJ2JtcHN0cicpIHtcbiAgICB2YXIgcmF3ID0gYnVmZmVyLnJhdygpO1xuICAgIGlmIChyYXcubGVuZ3RoICUgMiA9PT0gMSlcbiAgICAgIHJldHVybiBidWZmZXIuZXJyb3IoJ0RlY29kaW5nIG9mIHN0cmluZyB0eXBlOiBibXBzdHIgbGVuZ3RoIG1pc21hdGNoJyk7XG5cbiAgICB2YXIgc3RyID0gJyc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYXcubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShyYXcucmVhZFVJbnQxNkJFKGkgKiAyKSk7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJ1ZmZlci5lcnJvcignRGVjb2Rpbmcgb2Ygc3RyaW5nIHR5cGU6ICcgKyB0YWcgKyAnIHVuc3VwcG9ydGVkJyk7XG4gIH1cbn07XG5cbkRFUk5vZGUucHJvdG90eXBlLl9kZWNvZGVPYmppZCA9IGZ1bmN0aW9uIGRlY29kZU9iamlkKGJ1ZmZlciwgdmFsdWVzLCByZWxhdGl2ZSkge1xuICB2YXIgaWRlbnRpZmllcnMgPSBbXTtcbiAgdmFyIGlkZW50ID0gMDtcbiAgd2hpbGUgKCFidWZmZXIuaXNFbXB0eSgpKSB7XG4gICAgdmFyIHN1YmlkZW50ID0gYnVmZmVyLnJlYWRVSW50OCgpO1xuICAgIGlkZW50IDw8PSA3O1xuICAgIGlkZW50IHw9IHN1YmlkZW50ICYgMHg3ZjtcbiAgICBpZiAoKHN1YmlkZW50ICYgMHg4MCkgPT09IDApIHtcbiAgICAgIGlkZW50aWZpZXJzLnB1c2goaWRlbnQpO1xuICAgICAgaWRlbnQgPSAwO1xuICAgIH1cbiAgfVxuICBpZiAoc3ViaWRlbnQgJiAweDgwKVxuICAgIGlkZW50aWZpZXJzLnB1c2goaWRlbnQpO1xuXG4gIHZhciBmaXJzdCA9IChpZGVudGlmaWVyc1swXSAvIDQwKSB8IDA7XG4gIHZhciBzZWNvbmQgPSBpZGVudGlmaWVyc1swXSAlIDQwO1xuXG4gIGlmIChyZWxhdGl2ZSlcbiAgICByZXN1bHQgPSBpZGVudGlmaWVycztcbiAgZWxzZVxuICAgIHJlc3VsdCA9IFtmaXJzdCwgc2Vjb25kXS5jb25jYXQoaWRlbnRpZmllcnMuc2xpY2UoMSkpO1xuXG4gIGlmICh2YWx1ZXMpXG4gICAgcmVzdWx0ID0gdmFsdWVzW3Jlc3VsdC5qb2luKCcgJyldO1xuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5ERVJOb2RlLnByb3RvdHlwZS5fZGVjb2RlVGltZSA9IGZ1bmN0aW9uIGRlY29kZVRpbWUoYnVmZmVyLCB0YWcpIHtcbiAgdmFyIHN0ciA9IGJ1ZmZlci5yYXcoKS50b1N0cmluZygpO1xuICBpZiAodGFnID09PSAnZ2VudGltZScpIHtcbiAgICB2YXIgeWVhciA9IHN0ci5zbGljZSgwLCA0KSB8IDA7XG4gICAgdmFyIG1vbiA9IHN0ci5zbGljZSg0LCA2KSB8IDA7XG4gICAgdmFyIGRheSA9IHN0ci5zbGljZSg2LCA4KSB8IDA7XG4gICAgdmFyIGhvdXIgPSBzdHIuc2xpY2UoOCwgMTApIHwgMDtcbiAgICB2YXIgbWluID0gc3RyLnNsaWNlKDEwLCAxMikgfCAwO1xuICAgIHZhciBzZWMgPSBzdHIuc2xpY2UoMTIsIDE0KSB8IDA7XG4gIH0gZWxzZSBpZiAodGFnID09PSAndXRjdGltZScpIHtcbiAgICB2YXIgeWVhciA9IHN0ci5zbGljZSgwLCAyKSB8IDA7XG4gICAgdmFyIG1vbiA9IHN0ci5zbGljZSgyLCA0KSB8IDA7XG4gICAgdmFyIGRheSA9IHN0ci5zbGljZSg0LCA2KSB8IDA7XG4gICAgdmFyIGhvdXIgPSBzdHIuc2xpY2UoNiwgOCkgfCAwO1xuICAgIHZhciBtaW4gPSBzdHIuc2xpY2UoOCwgMTApIHwgMDtcbiAgICB2YXIgc2VjID0gc3RyLnNsaWNlKDEwLCAxMikgfCAwO1xuICAgIGlmICh5ZWFyIDwgNzApXG4gICAgICB5ZWFyID0gMjAwMCArIHllYXI7XG4gICAgZWxzZVxuICAgICAgeWVhciA9IDE5MDAgKyB5ZWFyO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBidWZmZXIuZXJyb3IoJ0RlY29kaW5nICcgKyB0YWcgKyAnIHRpbWUgaXMgbm90IHN1cHBvcnRlZCB5ZXQnKTtcbiAgfVxuXG4gIHJldHVybiBEYXRlLlVUQyh5ZWFyLCBtb24gLSAxLCBkYXksIGhvdXIsIG1pbiwgc2VjLCAwKTtcbn07XG5cbkRFUk5vZGUucHJvdG90eXBlLl9kZWNvZGVOdWxsID0gZnVuY3Rpb24gZGVjb2RlTnVsbChidWZmZXIpIHtcbiAgcmV0dXJuIG51bGw7XG59O1xuXG5ERVJOb2RlLnByb3RvdHlwZS5fZGVjb2RlQm9vbCA9IGZ1bmN0aW9uIGRlY29kZUJvb2woYnVmZmVyKSB7XG4gIHZhciByZXMgPSBidWZmZXIucmVhZFVJbnQ4KCk7XG4gIGlmIChidWZmZXIuaXNFcnJvcihyZXMpKVxuICAgIHJldHVybiByZXM7XG4gIGVsc2VcbiAgICByZXR1cm4gcmVzICE9PSAwO1xufTtcblxuREVSTm9kZS5wcm90b3R5cGUuX2RlY29kZUludCA9IGZ1bmN0aW9uIGRlY29kZUludChidWZmZXIsIHZhbHVlcykge1xuICAvLyBCaWdpbnQsIHJldHVybiBhcyBpdCBpcyAoYXNzdW1lIGJpZyBlbmRpYW4pXG4gIHZhciByYXcgPSBidWZmZXIucmF3KCk7XG4gIHZhciByZXMgPSBuZXcgYmlnbnVtKHJhdyk7XG5cbiAgaWYgKHZhbHVlcylcbiAgICByZXMgPSB2YWx1ZXNbcmVzLnRvU3RyaW5nKDEwKV0gfHwgcmVzO1xuXG4gIHJldHVybiByZXM7XG59O1xuXG5ERVJOb2RlLnByb3RvdHlwZS5fdXNlID0gZnVuY3Rpb24gdXNlKGVudGl0eSwgb2JqKSB7XG4gIGlmICh0eXBlb2YgZW50aXR5ID09PSAnZnVuY3Rpb24nKVxuICAgIGVudGl0eSA9IGVudGl0eShvYmopO1xuICByZXR1cm4gZW50aXR5Ll9nZXREZWNvZGVyKCdkZXInKS50cmVlO1xufTtcblxuLy8gVXRpbGl0eSBtZXRob2RzXG5cbmZ1bmN0aW9uIGRlckRlY29kZVRhZyhidWYsIGZhaWwpIHtcbiAgdmFyIHRhZyA9IGJ1Zi5yZWFkVUludDgoZmFpbCk7XG4gIGlmIChidWYuaXNFcnJvcih0YWcpKVxuICAgIHJldHVybiB0YWc7XG5cbiAgdmFyIGNscyA9IGRlci50YWdDbGFzc1t0YWcgPj4gNl07XG4gIHZhciBwcmltaXRpdmUgPSAodGFnICYgMHgyMCkgPT09IDA7XG5cbiAgLy8gTXVsdGktb2N0ZXQgdGFnIC0gbG9hZFxuICBpZiAoKHRhZyAmIDB4MWYpID09PSAweDFmKSB7XG4gICAgdmFyIG9jdCA9IHRhZztcbiAgICB0YWcgPSAwO1xuICAgIHdoaWxlICgob2N0ICYgMHg4MCkgPT09IDB4ODApIHtcbiAgICAgIG9jdCA9IGJ1Zi5yZWFkVUludDgoZmFpbCk7XG4gICAgICBpZiAoYnVmLmlzRXJyb3Iob2N0KSlcbiAgICAgICAgcmV0dXJuIG9jdDtcblxuICAgICAgdGFnIDw8PSA3O1xuICAgICAgdGFnIHw9IG9jdCAmIDB4N2Y7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRhZyAmPSAweDFmO1xuICB9XG4gIHZhciB0YWdTdHIgPSBkZXIudGFnW3RhZ107XG5cbiAgcmV0dXJuIHtcbiAgICBjbHM6IGNscyxcbiAgICBwcmltaXRpdmU6IHByaW1pdGl2ZSxcbiAgICB0YWc6IHRhZyxcbiAgICB0YWdTdHI6IHRhZ1N0clxuICB9O1xufVxuXG5mdW5jdGlvbiBkZXJEZWNvZGVMZW4oYnVmLCBwcmltaXRpdmUsIGZhaWwpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5yZWFkVUludDgoZmFpbCk7XG4gIGlmIChidWYuaXNFcnJvcihsZW4pKVxuICAgIHJldHVybiBsZW47XG5cbiAgLy8gSW5kZWZpbml0ZSBmb3JtXG4gIGlmICghcHJpbWl0aXZlICYmIGxlbiA9PT0gMHg4MClcbiAgICByZXR1cm4gbnVsbDtcblxuICAvLyBEZWZpbml0ZSBmb3JtXG4gIGlmICgobGVuICYgMHg4MCkgPT09IDApIHtcbiAgICAvLyBTaG9ydCBmb3JtXG4gICAgcmV0dXJuIGxlbjtcbiAgfVxuXG4gIC8vIExvbmcgZm9ybVxuICB2YXIgbnVtID0gbGVuICYgMHg3ZjtcbiAgaWYgKG51bSA+PSA0KVxuICAgIHJldHVybiBidWYuZXJyb3IoJ2xlbmd0aCBvY3RlY3QgaXMgdG9vIGxvbmcnKTtcblxuICBsZW4gPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG51bTsgaSsrKSB7XG4gICAgbGVuIDw8PSA4O1xuICAgIHZhciBqID0gYnVmLnJlYWRVSW50OChmYWlsKTtcbiAgICBpZiAoYnVmLmlzRXJyb3IoaikpXG4gICAgICByZXR1cm4gajtcbiAgICBsZW4gfD0gajtcbiAgfVxuXG4gIHJldHVybiBsZW47XG59XG4iLCJ2YXIgZGVjb2RlcnMgPSBleHBvcnRzO1xuXG5kZWNvZGVycy5kZXIgPSByZXF1aXJlKCcuL2RlcicpO1xuZGVjb2RlcnMucGVtID0gcmVxdWlyZSgnLi9wZW0nKTtcbiIsInZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuXG52YXIgYXNuMSA9IHJlcXVpcmUoJy4uLy4uL2FzbjEnKTtcbnZhciBERVJEZWNvZGVyID0gcmVxdWlyZSgnLi9kZXInKTtcblxuZnVuY3Rpb24gUEVNRGVjb2RlcihlbnRpdHkpIHtcbiAgREVSRGVjb2Rlci5jYWxsKHRoaXMsIGVudGl0eSk7XG4gIHRoaXMuZW5jID0gJ3BlbSc7XG59O1xuaW5oZXJpdHMoUEVNRGVjb2RlciwgREVSRGVjb2Rlcik7XG5tb2R1bGUuZXhwb3J0cyA9IFBFTURlY29kZXI7XG5cblBFTURlY29kZXIucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShkYXRhLCBvcHRpb25zKSB7XG4gIHZhciBsaW5lcyA9IGRhdGEudG9TdHJpbmcoKS5zcGxpdCgvW1xcclxcbl0rL2cpO1xuXG4gIHZhciBsYWJlbCA9IG9wdGlvbnMubGFiZWwudG9VcHBlckNhc2UoKTtcblxuICB2YXIgcmUgPSAvXi0tLS0tKEJFR0lOfEVORCkgKFteLV0rKS0tLS0tJC87XG4gIHZhciBzdGFydCA9IC0xO1xuICB2YXIgZW5kID0gLTE7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbWF0Y2ggPSBsaW5lc1tpXS5tYXRjaChyZSk7XG4gICAgaWYgKG1hdGNoID09PSBudWxsKVxuICAgICAgY29udGludWU7XG5cbiAgICBpZiAobWF0Y2hbMl0gIT09IGxhYmVsKVxuICAgICAgY29udGludWU7XG5cbiAgICBpZiAoc3RhcnQgPT09IC0xKSB7XG4gICAgICBpZiAobWF0Y2hbMV0gIT09ICdCRUdJTicpXG4gICAgICAgIGJyZWFrO1xuICAgICAgc3RhcnQgPSBpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobWF0Y2hbMV0gIT09ICdFTkQnKVxuICAgICAgICBicmVhaztcbiAgICAgIGVuZCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgaWYgKHN0YXJ0ID09PSAtMSB8fCBlbmQgPT09IC0xKVxuICAgIHRocm93IG5ldyBFcnJvcignUEVNIHNlY3Rpb24gbm90IGZvdW5kIGZvcjogJyArIGxhYmVsKTtcblxuICB2YXIgYmFzZTY0ID0gbGluZXMuc2xpY2Uoc3RhcnQgKyAxLCBlbmQpLmpvaW4oJycpO1xuICAvLyBSZW1vdmUgZXhjZXNzaXZlIHN5bWJvbHNcbiAgYmFzZTY0LnJlcGxhY2UoL1teYS16MC05XFwrXFwvPV0rL2dpLCAnJyk7XG5cbiAgdmFyIGlucHV0ID0gbmV3IEJ1ZmZlcihiYXNlNjQsICdiYXNlNjQnKTtcbiAgcmV0dXJuIERFUkRlY29kZXIucHJvdG90eXBlLmRlY29kZS5jYWxsKHRoaXMsIGlucHV0LCBvcHRpb25zKTtcbn07XG4iLCJ2YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcblxudmFyIGFzbjEgPSByZXF1aXJlKCcuLi8uLi9hc24xJyk7XG52YXIgYmFzZSA9IGFzbjEuYmFzZTtcbnZhciBiaWdudW0gPSBhc24xLmJpZ251bTtcblxuLy8gSW1wb3J0IERFUiBjb25zdGFudHNcbnZhciBkZXIgPSBhc24xLmNvbnN0YW50cy5kZXI7XG5cbmZ1bmN0aW9uIERFUkVuY29kZXIoZW50aXR5KSB7XG4gIHRoaXMuZW5jID0gJ2Rlcic7XG4gIHRoaXMubmFtZSA9IGVudGl0eS5uYW1lO1xuICB0aGlzLmVudGl0eSA9IGVudGl0eTtcblxuICAvLyBDb25zdHJ1Y3QgYmFzZSB0cmVlXG4gIHRoaXMudHJlZSA9IG5ldyBERVJOb2RlKCk7XG4gIHRoaXMudHJlZS5faW5pdChlbnRpdHkuYm9keSk7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBERVJFbmNvZGVyO1xuXG5ERVJFbmNvZGVyLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUoZGF0YSwgcmVwb3J0ZXIpIHtcbiAgcmV0dXJuIHRoaXMudHJlZS5fZW5jb2RlKGRhdGEsIHJlcG9ydGVyKS5qb2luKCk7XG59O1xuXG4vLyBUcmVlIG1ldGhvZHNcblxuZnVuY3Rpb24gREVSTm9kZShwYXJlbnQpIHtcbiAgYmFzZS5Ob2RlLmNhbGwodGhpcywgJ2RlcicsIHBhcmVudCk7XG59XG5pbmhlcml0cyhERVJOb2RlLCBiYXNlLk5vZGUpO1xuXG5ERVJOb2RlLnByb3RvdHlwZS5fZW5jb2RlQ29tcG9zaXRlID0gZnVuY3Rpb24gZW5jb2RlQ29tcG9zaXRlKHRhZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpbWl0aXZlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQpIHtcbiAgdmFyIGVuY29kZWRUYWcgPSBlbmNvZGVUYWcodGFnLCBwcmltaXRpdmUsIGNscywgdGhpcy5yZXBvcnRlcik7XG5cbiAgLy8gU2hvcnQgZm9ybVxuICBpZiAoY29udGVudC5sZW5ndGggPCAweDgwKSB7XG4gICAgdmFyIGhlYWRlciA9IG5ldyBCdWZmZXIoMik7XG4gICAgaGVhZGVyWzBdID0gZW5jb2RlZFRhZztcbiAgICBoZWFkZXJbMV0gPSBjb250ZW50Lmxlbmd0aDtcbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlRW5jb2RlckJ1ZmZlcihbIGhlYWRlciwgY29udGVudCBdKTtcbiAgfVxuXG4gIC8vIExvbmcgZm9ybVxuICAvLyBDb3VudCBvY3RldHMgcmVxdWlyZWQgdG8gc3RvcmUgbGVuZ3RoXG4gIHZhciBsZW5PY3RldHMgPSAxO1xuICBmb3IgKHZhciBpID0gY29udGVudC5sZW5ndGg7IGkgPj0gMHgxMDA7IGkgPj49IDgpXG4gICAgbGVuT2N0ZXRzKys7XG5cbiAgdmFyIGhlYWRlciA9IG5ldyBCdWZmZXIoMSArIDEgKyBsZW5PY3RldHMpO1xuICBoZWFkZXJbMF0gPSBlbmNvZGVkVGFnO1xuICBoZWFkZXJbMV0gPSAweDgwIHwgbGVuT2N0ZXRzO1xuXG4gIGZvciAodmFyIGkgPSAxICsgbGVuT2N0ZXRzLCBqID0gY29udGVudC5sZW5ndGg7IGogPiAwOyBpLS0sIGogPj49IDgpXG4gICAgaGVhZGVyW2ldID0gaiAmIDB4ZmY7XG5cbiAgcmV0dXJuIHRoaXMuX2NyZWF0ZUVuY29kZXJCdWZmZXIoWyBoZWFkZXIsIGNvbnRlbnQgXSk7XG59O1xuXG5ERVJOb2RlLnByb3RvdHlwZS5fZW5jb2RlU3RyID0gZnVuY3Rpb24gZW5jb2RlU3RyKHN0ciwgdGFnKSB7XG4gIGlmICh0YWcgPT09ICdvY3RzdHInKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZUVuY29kZXJCdWZmZXIoc3RyKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdiaXRzdHInKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZUVuY29kZXJCdWZmZXIoWyBzdHIudW51c2VkIHwgMCwgc3RyLmRhdGEgXSk7XG4gIH0gZWxzZSBpZiAodGFnID09PSAnaWE1c3RyJyB8fCB0YWcgPT09ICd1dGY4c3RyJykge1xuICAgIHJldHVybiB0aGlzLl9jcmVhdGVFbmNvZGVyQnVmZmVyKHN0cik7XG4gIH0gZWxzZSBpZiAodGFnID09PSAnYm1wc3RyJykge1xuICAgIHZhciBidWYgPSBuZXcgQnVmZmVyKHN0ci5sZW5ndGggKiAyKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgYnVmLndyaXRlVUludDE2QkUoc3RyLmNoYXJDb2RlQXQoaSksIGkgKiAyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZUVuY29kZXJCdWZmZXIoYnVmKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdudW1zdHInKSB7XG4gICAgaWYgKCF0aGlzLl9pc051bXN0cihzdHIpKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXBvcnRlci5lcnJvcignRW5jb2Rpbmcgb2Ygc3RyaW5nIHR5cGU6IG51bXN0ciBzdXBwb3J0cyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdvbmx5IGRpZ2l0cyBhbmQgc3BhY2UnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlRW5jb2RlckJ1ZmZlcihzdHIpO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ3ByaW50c3RyJykge1xuICAgIGlmICghdGhpcy5faXNQcmludHN0cihzdHIpKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXBvcnRlci5lcnJvcignRW5jb2Rpbmcgb2Ygc3RyaW5nIHR5cGU6IHByaW50c3RyIHN1cHBvcnRzICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29ubHkgbGF0aW4gdXBwZXIgYW5kIGxvd2VyIGNhc2UgbGV0dGVycywgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZGlnaXRzLCBzcGFjZSwgYXBvc3Ryb3BoZSwgbGVmdCBhbmQgcmlndGggJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAncGFyZW50aGVzaXMsIHBsdXMgc2lnbiwgY29tbWEsIGh5cGhlbiwgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZG90LCBzbGFzaCwgY29sb24sIGVxdWFsIHNpZ24sICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3F1ZXN0aW9uIG1hcmsnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlRW5jb2RlckJ1ZmZlcihzdHIpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aGlzLnJlcG9ydGVyLmVycm9yKCdFbmNvZGluZyBvZiBzdHJpbmcgdHlwZTogJyArIHRhZyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyB1bnN1cHBvcnRlZCcpO1xuICB9XG59O1xuXG5ERVJOb2RlLnByb3RvdHlwZS5fZW5jb2RlT2JqaWQgPSBmdW5jdGlvbiBlbmNvZGVPYmppZChpZCwgdmFsdWVzLCByZWxhdGl2ZSkge1xuICBpZiAodHlwZW9mIGlkID09PSAnc3RyaW5nJykge1xuICAgIGlmICghdmFsdWVzKVxuICAgICAgcmV0dXJuIHRoaXMucmVwb3J0ZXIuZXJyb3IoJ3N0cmluZyBvYmppZCBnaXZlbiwgYnV0IG5vIHZhbHVlcyBtYXAgZm91bmQnKTtcbiAgICBpZiAoIXZhbHVlcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICByZXR1cm4gdGhpcy5yZXBvcnRlci5lcnJvcignb2JqaWQgbm90IGZvdW5kIGluIHZhbHVlcyBtYXAnKTtcbiAgICBpZCA9IHZhbHVlc1tpZF0uc3BsaXQoL1tcXHNcXC5dKy9nKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlkLmxlbmd0aDsgaSsrKVxuICAgICAgaWRbaV0gfD0gMDtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGlkKSkge1xuICAgIGlkID0gaWQuc2xpY2UoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlkLmxlbmd0aDsgaSsrKVxuICAgICAgaWRbaV0gfD0gMDtcbiAgfVxuXG4gIGlmICghQXJyYXkuaXNBcnJheShpZCkpIHtcbiAgICByZXR1cm4gdGhpcy5yZXBvcnRlci5lcnJvcignb2JqaWQoKSBzaG91bGQgYmUgZWl0aGVyIGFycmF5IG9yIHN0cmluZywgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2dvdDogJyArIEpTT04uc3RyaW5naWZ5KGlkKSk7XG4gIH1cblxuICBpZiAoIXJlbGF0aXZlKSB7XG4gICAgaWYgKGlkWzFdID49IDQwKVxuICAgICAgcmV0dXJuIHRoaXMucmVwb3J0ZXIuZXJyb3IoJ1NlY29uZCBvYmppZCBpZGVudGlmaWVyIE9PQicpO1xuICAgIGlkLnNwbGljZSgwLCAyLCBpZFswXSAqIDQwICsgaWRbMV0pO1xuICB9XG5cbiAgLy8gQ291bnQgbnVtYmVyIG9mIG9jdGV0c1xuICB2YXIgc2l6ZSA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaWQubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaWRlbnQgPSBpZFtpXTtcbiAgICBmb3IgKHNpemUrKzsgaWRlbnQgPj0gMHg4MDsgaWRlbnQgPj49IDcpXG4gICAgICBzaXplKys7XG4gIH1cblxuICB2YXIgb2JqaWQgPSBuZXcgQnVmZmVyKHNpemUpO1xuICB2YXIgb2Zmc2V0ID0gb2JqaWQubGVuZ3RoIC0gMTtcbiAgZm9yICh2YXIgaSA9IGlkLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIGlkZW50ID0gaWRbaV07XG4gICAgb2JqaWRbb2Zmc2V0LS1dID0gaWRlbnQgJiAweDdmO1xuICAgIHdoaWxlICgoaWRlbnQgPj49IDcpID4gMClcbiAgICAgIG9iamlkW29mZnNldC0tXSA9IDB4ODAgfCAoaWRlbnQgJiAweDdmKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLl9jcmVhdGVFbmNvZGVyQnVmZmVyKG9iamlkKTtcbn07XG5cbmZ1bmN0aW9uIHR3byhudW0pIHtcbiAgaWYgKG51bSA8IDEwKVxuICAgIHJldHVybiAnMCcgKyBudW07XG4gIGVsc2VcbiAgICByZXR1cm4gbnVtO1xufVxuXG5ERVJOb2RlLnByb3RvdHlwZS5fZW5jb2RlVGltZSA9IGZ1bmN0aW9uIGVuY29kZVRpbWUodGltZSwgdGFnKSB7XG4gIHZhciBzdHI7XG4gIHZhciBkYXRlID0gbmV3IERhdGUodGltZSk7XG5cbiAgaWYgKHRhZyA9PT0gJ2dlbnRpbWUnKSB7XG4gICAgc3RyID0gW1xuICAgICAgdHdvKGRhdGUuZ2V0RnVsbFllYXIoKSksXG4gICAgICB0d28oZGF0ZS5nZXRVVENNb250aCgpICsgMSksXG4gICAgICB0d28oZGF0ZS5nZXRVVENEYXRlKCkpLFxuICAgICAgdHdvKGRhdGUuZ2V0VVRDSG91cnMoKSksXG4gICAgICB0d28oZGF0ZS5nZXRVVENNaW51dGVzKCkpLFxuICAgICAgdHdvKGRhdGUuZ2V0VVRDU2Vjb25kcygpKSxcbiAgICAgICdaJ1xuICAgIF0uam9pbignJyk7XG4gIH0gZWxzZSBpZiAodGFnID09PSAndXRjdGltZScpIHtcbiAgICBzdHIgPSBbXG4gICAgICB0d28oZGF0ZS5nZXRGdWxsWWVhcigpICUgMTAwKSxcbiAgICAgIHR3byhkYXRlLmdldFVUQ01vbnRoKCkgKyAxKSxcbiAgICAgIHR3byhkYXRlLmdldFVUQ0RhdGUoKSksXG4gICAgICB0d28oZGF0ZS5nZXRVVENIb3VycygpKSxcbiAgICAgIHR3byhkYXRlLmdldFVUQ01pbnV0ZXMoKSksXG4gICAgICB0d28oZGF0ZS5nZXRVVENTZWNvbmRzKCkpLFxuICAgICAgJ1onXG4gICAgXS5qb2luKCcnKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnJlcG9ydGVyLmVycm9yKCdFbmNvZGluZyAnICsgdGFnICsgJyB0aW1lIGlzIG5vdCBzdXBwb3J0ZWQgeWV0Jyk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5fZW5jb2RlU3RyKHN0ciwgJ29jdHN0cicpO1xufTtcblxuREVSTm9kZS5wcm90b3R5cGUuX2VuY29kZU51bGwgPSBmdW5jdGlvbiBlbmNvZGVOdWxsKCkge1xuICByZXR1cm4gdGhpcy5fY3JlYXRlRW5jb2RlckJ1ZmZlcignJyk7XG59O1xuXG5ERVJOb2RlLnByb3RvdHlwZS5fZW5jb2RlSW50ID0gZnVuY3Rpb24gZW5jb2RlSW50KG51bSwgdmFsdWVzKSB7XG4gIGlmICh0eXBlb2YgbnVtID09PSAnc3RyaW5nJykge1xuICAgIGlmICghdmFsdWVzKVxuICAgICAgcmV0dXJuIHRoaXMucmVwb3J0ZXIuZXJyb3IoJ1N0cmluZyBpbnQgb3IgZW51bSBnaXZlbiwgYnV0IG5vIHZhbHVlcyBtYXAnKTtcbiAgICBpZiAoIXZhbHVlcy5oYXNPd25Qcm9wZXJ0eShudW0pKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXBvcnRlci5lcnJvcignVmFsdWVzIG1hcCBkb2VzblxcJ3QgY29udGFpbjogJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShudW0pKTtcbiAgICB9XG4gICAgbnVtID0gdmFsdWVzW251bV07XG4gIH1cblxuICAvLyBCaWdudW0sIGFzc3VtZSBiaWcgZW5kaWFuXG4gIGlmICh0eXBlb2YgbnVtICE9PSAnbnVtYmVyJyAmJiAhQnVmZmVyLmlzQnVmZmVyKG51bSkpIHtcbiAgICB2YXIgbnVtQXJyYXkgPSBudW0udG9BcnJheSgpO1xuICAgIGlmICghbnVtLnNpZ24gJiYgbnVtQXJyYXlbMF0gJiAweDgwKSB7XG4gICAgICBudW1BcnJheS51bnNoaWZ0KDApO1xuICAgIH1cbiAgICBudW0gPSBuZXcgQnVmZmVyKG51bUFycmF5KTtcbiAgfVxuXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIobnVtKSkge1xuICAgIHZhciBzaXplID0gbnVtLmxlbmd0aDtcbiAgICBpZiAobnVtLmxlbmd0aCA9PT0gMClcbiAgICAgIHNpemUrKztcblxuICAgIHZhciBvdXQgPSBuZXcgQnVmZmVyKHNpemUpO1xuICAgIG51bS5jb3B5KG91dCk7XG4gICAgaWYgKG51bS5sZW5ndGggPT09IDApXG4gICAgICBvdXRbMF0gPSAwXG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZUVuY29kZXJCdWZmZXIob3V0KTtcbiAgfVxuXG4gIGlmIChudW0gPCAweDgwKVxuICAgIHJldHVybiB0aGlzLl9jcmVhdGVFbmNvZGVyQnVmZmVyKG51bSk7XG5cbiAgaWYgKG51bSA8IDB4MTAwKVxuICAgIHJldHVybiB0aGlzLl9jcmVhdGVFbmNvZGVyQnVmZmVyKFswLCBudW1dKTtcblxuICB2YXIgc2l6ZSA9IDE7XG4gIGZvciAodmFyIGkgPSBudW07IGkgPj0gMHgxMDA7IGkgPj49IDgpXG4gICAgc2l6ZSsrO1xuXG4gIHZhciBvdXQgPSBuZXcgQXJyYXkoc2l6ZSk7XG4gIGZvciAodmFyIGkgPSBvdXQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBvdXRbaV0gPSBudW0gJiAweGZmO1xuICAgIG51bSA+Pj0gODtcbiAgfVxuICBpZihvdXRbMF0gJiAweDgwKSB7XG4gICAgb3V0LnVuc2hpZnQoMCk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5fY3JlYXRlRW5jb2RlckJ1ZmZlcihuZXcgQnVmZmVyKG91dCkpO1xufTtcblxuREVSTm9kZS5wcm90b3R5cGUuX2VuY29kZUJvb2wgPSBmdW5jdGlvbiBlbmNvZGVCb29sKHZhbHVlKSB7XG4gIHJldHVybiB0aGlzLl9jcmVhdGVFbmNvZGVyQnVmZmVyKHZhbHVlID8gMHhmZiA6IDApO1xufTtcblxuREVSTm9kZS5wcm90b3R5cGUuX3VzZSA9IGZ1bmN0aW9uIHVzZShlbnRpdHksIG9iaikge1xuICBpZiAodHlwZW9mIGVudGl0eSA9PT0gJ2Z1bmN0aW9uJylcbiAgICBlbnRpdHkgPSBlbnRpdHkob2JqKTtcbiAgcmV0dXJuIGVudGl0eS5fZ2V0RW5jb2RlcignZGVyJykudHJlZTtcbn07XG5cbkRFUk5vZGUucHJvdG90eXBlLl9za2lwRGVmYXVsdCA9IGZ1bmN0aW9uIHNraXBEZWZhdWx0KGRhdGFCdWZmZXIsIHJlcG9ydGVyLCBwYXJlbnQpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuICB2YXIgaTtcbiAgaWYgKHN0YXRlWydkZWZhdWx0J10gPT09IG51bGwpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBkYXRhID0gZGF0YUJ1ZmZlci5qb2luKCk7XG4gIGlmIChzdGF0ZS5kZWZhdWx0QnVmZmVyID09PSB1bmRlZmluZWQpXG4gICAgc3RhdGUuZGVmYXVsdEJ1ZmZlciA9IHRoaXMuX2VuY29kZVZhbHVlKHN0YXRlWydkZWZhdWx0J10sIHJlcG9ydGVyLCBwYXJlbnQpLmpvaW4oKTtcblxuICBpZiAoZGF0YS5sZW5ndGggIT09IHN0YXRlLmRlZmF1bHRCdWZmZXIubGVuZ3RoKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBmb3IgKGk9MDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspXG4gICAgaWYgKGRhdGFbaV0gIT09IHN0YXRlLmRlZmF1bHRCdWZmZXJbaV0pXG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vLyBVdGlsaXR5IG1ldGhvZHNcblxuZnVuY3Rpb24gZW5jb2RlVGFnKHRhZywgcHJpbWl0aXZlLCBjbHMsIHJlcG9ydGVyKSB7XG4gIHZhciByZXM7XG5cbiAgaWYgKHRhZyA9PT0gJ3NlcW9mJylcbiAgICB0YWcgPSAnc2VxJztcbiAgZWxzZSBpZiAodGFnID09PSAnc2V0b2YnKVxuICAgIHRhZyA9ICdzZXQnO1xuXG4gIGlmIChkZXIudGFnQnlOYW1lLmhhc093blByb3BlcnR5KHRhZykpXG4gICAgcmVzID0gZGVyLnRhZ0J5TmFtZVt0YWddO1xuICBlbHNlIGlmICh0eXBlb2YgdGFnID09PSAnbnVtYmVyJyAmJiAodGFnIHwgMCkgPT09IHRhZylcbiAgICByZXMgPSB0YWc7XG4gIGVsc2VcbiAgICByZXR1cm4gcmVwb3J0ZXIuZXJyb3IoJ1Vua25vd24gdGFnOiAnICsgdGFnKTtcblxuICBpZiAocmVzID49IDB4MWYpXG4gICAgcmV0dXJuIHJlcG9ydGVyLmVycm9yKCdNdWx0aS1vY3RldCB0YWcgZW5jb2RpbmcgdW5zdXBwb3J0ZWQnKTtcblxuICBpZiAoIXByaW1pdGl2ZSlcbiAgICByZXMgfD0gMHgyMDtcblxuICByZXMgfD0gKGRlci50YWdDbGFzc0J5TmFtZVtjbHMgfHwgJ3VuaXZlcnNhbCddIDw8IDYpO1xuXG4gIHJldHVybiByZXM7XG59XG4iLCJ2YXIgZW5jb2RlcnMgPSBleHBvcnRzO1xuXG5lbmNvZGVycy5kZXIgPSByZXF1aXJlKCcuL2RlcicpO1xuZW5jb2RlcnMucGVtID0gcmVxdWlyZSgnLi9wZW0nKTtcbiIsInZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuXG52YXIgYXNuMSA9IHJlcXVpcmUoJy4uLy4uL2FzbjEnKTtcbnZhciBERVJFbmNvZGVyID0gcmVxdWlyZSgnLi9kZXInKTtcblxuZnVuY3Rpb24gUEVNRW5jb2RlcihlbnRpdHkpIHtcbiAgREVSRW5jb2Rlci5jYWxsKHRoaXMsIGVudGl0eSk7XG4gIHRoaXMuZW5jID0gJ3BlbSc7XG59O1xuaW5oZXJpdHMoUEVNRW5jb2RlciwgREVSRW5jb2Rlcik7XG5tb2R1bGUuZXhwb3J0cyA9IFBFTUVuY29kZXI7XG5cblBFTUVuY29kZXIucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShkYXRhLCBvcHRpb25zKSB7XG4gIHZhciBidWYgPSBERVJFbmNvZGVyLnByb3RvdHlwZS5lbmNvZGUuY2FsbCh0aGlzLCBkYXRhKTtcblxuICB2YXIgcCA9IGJ1Zi50b1N0cmluZygnYmFzZTY0Jyk7XG4gIHZhciBvdXQgPSBbICctLS0tLUJFR0lOICcgKyBvcHRpb25zLmxhYmVsICsgJy0tLS0tJyBdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHAubGVuZ3RoOyBpICs9IDY0KVxuICAgIG91dC5wdXNoKHAuc2xpY2UoaSwgaSArIDY0KSk7XG4gIG91dC5wdXNoKCctLS0tLUVORCAnICsgb3B0aW9ucy5sYWJlbCArICctLS0tLScpO1xuICByZXR1cm4gb3V0LmpvaW4oJ1xcbicpO1xufTtcbiIsIi8vIGJhc2VkIG9uIHRoZSBhZXMgaW1wbGltZW50YXRpb24gaW4gdHJpcGxlIHNlY1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2tleWJhc2UvdHJpcGxlc2VjXG5cbi8vIHdoaWNoIGlzIGluIHR1cm4gYmFzZWQgb24gdGhlIG9uZSBmcm9tIGNyeXB0by1qc1xuLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jcnlwdG8tanMvXG5cbnZhciB1aW50X21heCA9IE1hdGgucG93KDIsIDMyKVxuZnVuY3Rpb24gZml4dXBfdWludDMyICh4KSB7XG4gIHZhciByZXQsIHhfcG9zXG4gIHJldCA9IHggPiB1aW50X21heCB8fCB4IDwgMCA/ICh4X3BvcyA9IE1hdGguYWJzKHgpICUgdWludF9tYXgsIHggPCAwID8gdWludF9tYXggLSB4X3BvcyA6IHhfcG9zKSA6IHhcbiAgcmV0dXJuIHJldFxufVxuZnVuY3Rpb24gc2NydWJfdmVjICh2KSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdi5sZW5ndGg7IHYrKykge1xuICAgIHZbaV0gPSAwXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIEdsb2JhbCAoKSB7XG4gIHRoaXMuU0JPWCA9IFtdXG4gIHRoaXMuSU5WX1NCT1ggPSBbXVxuICB0aGlzLlNVQl9NSVggPSBbW10sIFtdLCBbXSwgW11dXG4gIHRoaXMuSU5WX1NVQl9NSVggPSBbW10sIFtdLCBbXSwgW11dXG4gIHRoaXMuaW5pdCgpXG4gIHRoaXMuUkNPTiA9IFsweDAwLCAweDAxLCAweDAyLCAweDA0LCAweDA4LCAweDEwLCAweDIwLCAweDQwLCAweDgwLCAweDFiLCAweDM2XVxufVxuXG5HbG9iYWwucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBkLCBpLCBzeCwgdCwgeCwgeDIsIHg0LCB4OCwgeGksIF9pXG4gIGQgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBfaSwgX3Jlc3VsdHNcbiAgICBfcmVzdWx0cyA9IFtdXG4gICAgZm9yIChpID0gX2kgPSAwOyBfaSA8IDI1NjsgaSA9ICsrX2kpIHtcbiAgICAgIGlmIChpIDwgMTI4KSB7XG4gICAgICAgIF9yZXN1bHRzLnB1c2goaSA8PCAxKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3Jlc3VsdHMucHVzaCgoaSA8PCAxKSBeIDB4MTFiKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gX3Jlc3VsdHNcbiAgfSkoKVxuICB4ID0gMFxuICB4aSA9IDBcbiAgZm9yIChpID0gX2kgPSAwOyBfaSA8IDI1NjsgaSA9ICsrX2kpIHtcbiAgICBzeCA9IHhpIF4gKHhpIDw8IDEpIF4gKHhpIDw8IDIpIF4gKHhpIDw8IDMpIF4gKHhpIDw8IDQpXG4gICAgc3ggPSAoc3ggPj4+IDgpIF4gKHN4ICYgMHhmZikgXiAweDYzXG4gICAgdGhpcy5TQk9YW3hdID0gc3hcbiAgICB0aGlzLklOVl9TQk9YW3N4XSA9IHhcbiAgICB4MiA9IGRbeF1cbiAgICB4NCA9IGRbeDJdXG4gICAgeDggPSBkW3g0XVxuICAgIHQgPSAoZFtzeF0gKiAweDEwMSkgXiAoc3ggKiAweDEwMTAxMDApXG4gICAgdGhpcy5TVUJfTUlYWzBdW3hdID0gKHQgPDwgMjQpIHwgKHQgPj4+IDgpXG4gICAgdGhpcy5TVUJfTUlYWzFdW3hdID0gKHQgPDwgMTYpIHwgKHQgPj4+IDE2KVxuICAgIHRoaXMuU1VCX01JWFsyXVt4XSA9ICh0IDw8IDgpIHwgKHQgPj4+IDI0KVxuICAgIHRoaXMuU1VCX01JWFszXVt4XSA9IHRcbiAgICB0ID0gKHg4ICogMHgxMDEwMTAxKSBeICh4NCAqIDB4MTAwMDEpIF4gKHgyICogMHgxMDEpIF4gKHggKiAweDEwMTAxMDApXG4gICAgdGhpcy5JTlZfU1VCX01JWFswXVtzeF0gPSAodCA8PCAyNCkgfCAodCA+Pj4gOClcbiAgICB0aGlzLklOVl9TVUJfTUlYWzFdW3N4XSA9ICh0IDw8IDE2KSB8ICh0ID4+PiAxNilcbiAgICB0aGlzLklOVl9TVUJfTUlYWzJdW3N4XSA9ICh0IDw8IDgpIHwgKHQgPj4+IDI0KVxuICAgIHRoaXMuSU5WX1NVQl9NSVhbM11bc3hdID0gdFxuICAgIGlmICh4ID09PSAwKSB7XG4gICAgICB4ID0geGkgPSAxXG4gICAgfSBlbHNlIHtcbiAgICAgIHggPSB4MiBeIGRbZFtkW3g4IF4geDJdXV1cbiAgICAgIHhpIF49IGRbZFt4aV1dXG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbnZhciBHID0gbmV3IEdsb2JhbCgpXG5cbkFFUy5ibG9ja1NpemUgPSA0ICogNFxuXG5BRVMucHJvdG90eXBlLmJsb2NrU2l6ZSA9IEFFUy5ibG9ja1NpemVcblxuQUVTLmtleVNpemUgPSAyNTYgLyA4XG5cbkFFUy5wcm90b3R5cGUua2V5U2l6ZSA9IEFFUy5rZXlTaXplXG5cbmZ1bmN0aW9uIGJ1ZmZlclRvQXJyYXkgKGJ1Zikge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aCAvIDRcbiAgdmFyIG91dCA9IG5ldyBBcnJheShsZW4pXG4gIHZhciBpID0gLTFcbiAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgIG91dFtpXSA9IGJ1Zi5yZWFkVUludDMyQkUoaSAqIDQpXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuZnVuY3Rpb24gQUVTIChrZXkpIHtcbiAgdGhpcy5fa2V5ID0gYnVmZmVyVG9BcnJheShrZXkpXG4gIHRoaXMuX2RvUmVzZXQoKVxufVxuXG5BRVMucHJvdG90eXBlLl9kb1Jlc2V0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaW52S3NSb3csIGtleVNpemUsIGtleVdvcmRzLCBrc1Jvdywga3NSb3dzLCB0XG4gIGtleVdvcmRzID0gdGhpcy5fa2V5XG4gIGtleVNpemUgPSBrZXlXb3Jkcy5sZW5ndGhcbiAgdGhpcy5fblJvdW5kcyA9IGtleVNpemUgKyA2XG4gIGtzUm93cyA9ICh0aGlzLl9uUm91bmRzICsgMSkgKiA0XG4gIHRoaXMuX2tleVNjaGVkdWxlID0gW11cbiAgZm9yIChrc1JvdyA9IDA7IGtzUm93IDwga3NSb3dzOyBrc1JvdysrKSB7XG4gICAgdGhpcy5fa2V5U2NoZWR1bGVba3NSb3ddID0ga3NSb3cgPCBrZXlTaXplID8ga2V5V29yZHNba3NSb3ddIDogKHQgPSB0aGlzLl9rZXlTY2hlZHVsZVtrc1JvdyAtIDFdLCAoa3NSb3cgJSBrZXlTaXplKSA9PT0gMCA/ICh0ID0gKHQgPDwgOCkgfCAodCA+Pj4gMjQpLCB0ID0gKEcuU0JPWFt0ID4+PiAyNF0gPDwgMjQpIHwgKEcuU0JPWFsodCA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKEcuU0JPWFsodCA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IEcuU0JPWFt0ICYgMHhmZl0sIHQgXj0gRy5SQ09OWyhrc1JvdyAvIGtleVNpemUpIHwgMF0gPDwgMjQpIDoga2V5U2l6ZSA+IDYgJiYga3NSb3cgJSBrZXlTaXplID09PSA0ID8gdCA9IChHLlNCT1hbdCA+Pj4gMjRdIDw8IDI0KSB8IChHLlNCT1hbKHQgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChHLlNCT1hbKHQgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBHLlNCT1hbdCAmIDB4ZmZdIDogdm9pZCAwLCB0aGlzLl9rZXlTY2hlZHVsZVtrc1JvdyAtIGtleVNpemVdIF4gdClcbiAgfVxuICB0aGlzLl9pbnZLZXlTY2hlZHVsZSA9IFtdXG4gIGZvciAoaW52S3NSb3cgPSAwOyBpbnZLc1JvdyA8IGtzUm93czsgaW52S3NSb3crKykge1xuICAgIGtzUm93ID0ga3NSb3dzIC0gaW52S3NSb3dcbiAgICB0ID0gdGhpcy5fa2V5U2NoZWR1bGVba3NSb3cgLSAoaW52S3NSb3cgJSA0ID8gMCA6IDQpXVxuICAgIHRoaXMuX2ludktleVNjaGVkdWxlW2ludktzUm93XSA9IGludktzUm93IDwgNCB8fCBrc1JvdyA8PSA0ID8gdCA6IEcuSU5WX1NVQl9NSVhbMF1bRy5TQk9YW3QgPj4+IDI0XV0gXiBHLklOVl9TVUJfTUlYWzFdW0cuU0JPWFsodCA+Pj4gMTYpICYgMHhmZl1dIF4gRy5JTlZfU1VCX01JWFsyXVtHLlNCT1hbKHQgPj4+IDgpICYgMHhmZl1dIF4gRy5JTlZfU1VCX01JWFszXVtHLlNCT1hbdCAmIDB4ZmZdXVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbkFFUy5wcm90b3R5cGUuZW5jcnlwdEJsb2NrID0gZnVuY3Rpb24gKE0pIHtcbiAgTSA9IGJ1ZmZlclRvQXJyYXkobmV3IEJ1ZmZlcihNKSlcbiAgdmFyIG91dCA9IHRoaXMuX2RvQ3J5cHRCbG9jayhNLCB0aGlzLl9rZXlTY2hlZHVsZSwgRy5TVUJfTUlYLCBHLlNCT1gpXG4gIHZhciBidWYgPSBuZXcgQnVmZmVyKDE2KVxuICBidWYud3JpdGVVSW50MzJCRShvdXRbMF0sIDApXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKG91dFsxXSwgNClcbiAgYnVmLndyaXRlVUludDMyQkUob3V0WzJdLCA4KVxuICBidWYud3JpdGVVSW50MzJCRShvdXRbM10sIDEyKVxuICByZXR1cm4gYnVmXG59XG5cbkFFUy5wcm90b3R5cGUuZGVjcnlwdEJsb2NrID0gZnVuY3Rpb24gKE0pIHtcbiAgTSA9IGJ1ZmZlclRvQXJyYXkobmV3IEJ1ZmZlcihNKSlcbiAgdmFyIHRlbXAgPSBbTVszXSwgTVsxXV1cbiAgTVsxXSA9IHRlbXBbMF1cbiAgTVszXSA9IHRlbXBbMV1cbiAgdmFyIG91dCA9IHRoaXMuX2RvQ3J5cHRCbG9jayhNLCB0aGlzLl9pbnZLZXlTY2hlZHVsZSwgRy5JTlZfU1VCX01JWCwgRy5JTlZfU0JPWClcbiAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIoMTYpXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKG91dFswXSwgMClcbiAgYnVmLndyaXRlVUludDMyQkUob3V0WzNdLCA0KVxuICBidWYud3JpdGVVSW50MzJCRShvdXRbMl0sIDgpXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKG91dFsxXSwgMTIpXG4gIHJldHVybiBidWZcbn1cblxuQUVTLnByb3RvdHlwZS5zY3J1YiA9IGZ1bmN0aW9uICgpIHtcbiAgc2NydWJfdmVjKHRoaXMuX2tleVNjaGVkdWxlKVxuICBzY3J1Yl92ZWModGhpcy5faW52S2V5U2NoZWR1bGUpXG4gIHNjcnViX3ZlYyh0aGlzLl9rZXkpXG59XG5cbkFFUy5wcm90b3R5cGUuX2RvQ3J5cHRCbG9jayA9IGZ1bmN0aW9uIChNLCBrZXlTY2hlZHVsZSwgU1VCX01JWCwgU0JPWCkge1xuICB2YXIga3NSb3csIHMwLCBzMSwgczIsIHMzLCB0MCwgdDEsIHQyLCB0M1xuXG4gIHMwID0gTVswXSBeIGtleVNjaGVkdWxlWzBdXG4gIHMxID0gTVsxXSBeIGtleVNjaGVkdWxlWzFdXG4gIHMyID0gTVsyXSBeIGtleVNjaGVkdWxlWzJdXG4gIHMzID0gTVszXSBeIGtleVNjaGVkdWxlWzNdXG4gIGtzUm93ID0gNFxuICBmb3IgKHZhciByb3VuZCA9IDE7IHJvdW5kIDwgdGhpcy5fblJvdW5kczsgcm91bmQrKykge1xuICAgIHQwID0gU1VCX01JWFswXVtzMCA+Pj4gMjRdIF4gU1VCX01JWFsxXVsoczEgPj4+IDE2KSAmIDB4ZmZdIF4gU1VCX01JWFsyXVsoczIgPj4+IDgpICYgMHhmZl0gXiBTVUJfTUlYWzNdW3MzICYgMHhmZl0gXiBrZXlTY2hlZHVsZVtrc1JvdysrXVxuICAgIHQxID0gU1VCX01JWFswXVtzMSA+Pj4gMjRdIF4gU1VCX01JWFsxXVsoczIgPj4+IDE2KSAmIDB4ZmZdIF4gU1VCX01JWFsyXVsoczMgPj4+IDgpICYgMHhmZl0gXiBTVUJfTUlYWzNdW3MwICYgMHhmZl0gXiBrZXlTY2hlZHVsZVtrc1JvdysrXVxuICAgIHQyID0gU1VCX01JWFswXVtzMiA+Pj4gMjRdIF4gU1VCX01JWFsxXVsoczMgPj4+IDE2KSAmIDB4ZmZdIF4gU1VCX01JWFsyXVsoczAgPj4+IDgpICYgMHhmZl0gXiBTVUJfTUlYWzNdW3MxICYgMHhmZl0gXiBrZXlTY2hlZHVsZVtrc1JvdysrXVxuICAgIHQzID0gU1VCX01JWFswXVtzMyA+Pj4gMjRdIF4gU1VCX01JWFsxXVsoczAgPj4+IDE2KSAmIDB4ZmZdIF4gU1VCX01JWFsyXVsoczEgPj4+IDgpICYgMHhmZl0gXiBTVUJfTUlYWzNdW3MyICYgMHhmZl0gXiBrZXlTY2hlZHVsZVtrc1JvdysrXVxuICAgIHMwID0gdDBcbiAgICBzMSA9IHQxXG4gICAgczIgPSB0MlxuICAgIHMzID0gdDNcbiAgfVxuICB0MCA9ICgoU0JPWFtzMCA+Pj4gMjRdIDw8IDI0KSB8IChTQk9YWyhzMSA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKFNCT1hbKHMyID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgU0JPWFtzMyAmIDB4ZmZdKSBeIGtleVNjaGVkdWxlW2tzUm93KytdXG4gIHQxID0gKChTQk9YW3MxID4+PiAyNF0gPDwgMjQpIHwgKFNCT1hbKHMyID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoU0JPWFsoczMgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBTQk9YW3MwICYgMHhmZl0pIF4ga2V5U2NoZWR1bGVba3NSb3crK11cbiAgdDIgPSAoKFNCT1hbczIgPj4+IDI0XSA8PCAyNCkgfCAoU0JPWFsoczMgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChTQk9YWyhzMCA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IFNCT1hbczEgJiAweGZmXSkgXiBrZXlTY2hlZHVsZVtrc1JvdysrXVxuICB0MyA9ICgoU0JPWFtzMyA+Pj4gMjRdIDw8IDI0KSB8IChTQk9YWyhzMCA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKFNCT1hbKHMxID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgU0JPWFtzMiAmIDB4ZmZdKSBeIGtleVNjaGVkdWxlW2tzUm93KytdXG4gIHJldHVybiBbXG4gICAgZml4dXBfdWludDMyKHQwKSxcbiAgICBmaXh1cF91aW50MzIodDEpLFxuICAgIGZpeHVwX3VpbnQzMih0MiksXG4gICAgZml4dXBfdWludDMyKHQzKVxuICBdXG59XG5cbmV4cG9ydHMuQUVTID0gQUVTXG4iLCJ2YXIgYWVzID0gcmVxdWlyZSgnLi9hZXMnKVxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJ2NpcGhlci1iYXNlJylcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBHSEFTSCA9IHJlcXVpcmUoJy4vZ2hhc2gnKVxudmFyIHhvciA9IHJlcXVpcmUoJ2J1ZmZlci14b3InKVxuaW5oZXJpdHMoU3RyZWFtQ2lwaGVyLCBUcmFuc2Zvcm0pXG5tb2R1bGUuZXhwb3J0cyA9IFN0cmVhbUNpcGhlclxuXG5mdW5jdGlvbiBTdHJlYW1DaXBoZXIgKG1vZGUsIGtleSwgaXYsIGRlY3J5cHQpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFN0cmVhbUNpcGhlcikpIHtcbiAgICByZXR1cm4gbmV3IFN0cmVhbUNpcGhlcihtb2RlLCBrZXksIGl2KVxuICB9XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMpXG4gIHRoaXMuX2ZpbklEID0gQnVmZmVyLmNvbmNhdChbaXYsIG5ldyBCdWZmZXIoWzAsIDAsIDAsIDFdKV0pXG4gIGl2ID0gQnVmZmVyLmNvbmNhdChbaXYsIG5ldyBCdWZmZXIoWzAsIDAsIDAsIDJdKV0pXG4gIHRoaXMuX2NpcGhlciA9IG5ldyBhZXMuQUVTKGtleSlcbiAgdGhpcy5fcHJldiA9IG5ldyBCdWZmZXIoaXYubGVuZ3RoKVxuICB0aGlzLl9jYWNoZSA9IG5ldyBCdWZmZXIoJycpXG4gIHRoaXMuX3NlY0NhY2hlID0gbmV3IEJ1ZmZlcignJylcbiAgdGhpcy5fZGVjcnlwdCA9IGRlY3J5cHRcbiAgdGhpcy5fYWxlbiA9IDBcbiAgdGhpcy5fbGVuID0gMFxuICBpdi5jb3B5KHRoaXMuX3ByZXYpXG4gIHRoaXMuX21vZGUgPSBtb2RlXG4gIHZhciBoID0gbmV3IEJ1ZmZlcig0KVxuICBoLmZpbGwoMClcbiAgdGhpcy5fZ2hhc2ggPSBuZXcgR0hBU0godGhpcy5fY2lwaGVyLmVuY3J5cHRCbG9jayhoKSlcbiAgdGhpcy5fYXV0aFRhZyA9IG51bGxcbiAgdGhpcy5fY2FsbGVkID0gZmFsc2Vcbn1cblN0cmVhbUNpcGhlci5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChjaHVuaykge1xuICBpZiAoIXRoaXMuX2NhbGxlZCAmJiB0aGlzLl9hbGVuKSB7XG4gICAgdmFyIHJ1bXAgPSAxNiAtICh0aGlzLl9hbGVuICUgMTYpXG4gICAgaWYgKHJ1bXAgPCAxNikge1xuICAgICAgcnVtcCA9IG5ldyBCdWZmZXIocnVtcClcbiAgICAgIHJ1bXAuZmlsbCgwKVxuICAgICAgdGhpcy5fZ2hhc2gudXBkYXRlKHJ1bXApXG4gICAgfVxuICB9XG4gIHRoaXMuX2NhbGxlZCA9IHRydWVcbiAgdmFyIG91dCA9IHRoaXMuX21vZGUuZW5jcnlwdCh0aGlzLCBjaHVuaylcbiAgaWYgKHRoaXMuX2RlY3J5cHQpIHtcbiAgICB0aGlzLl9naGFzaC51cGRhdGUoY2h1bmspXG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fZ2hhc2gudXBkYXRlKG91dClcbiAgfVxuICB0aGlzLl9sZW4gKz0gY2h1bmsubGVuZ3RoXG4gIHJldHVybiBvdXRcbn1cblN0cmVhbUNpcGhlci5wcm90b3R5cGUuX2ZpbmFsID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5fZGVjcnlwdCAmJiAhdGhpcy5fYXV0aFRhZykge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgc3RhdGUgb3IgdW5hYmxlIHRvIGF1dGhlbnRpY2F0ZSBkYXRhJylcbiAgfVxuICB2YXIgdGFnID0geG9yKHRoaXMuX2doYXNoLmZpbmFsKHRoaXMuX2FsZW4gKiA4LCB0aGlzLl9sZW4gKiA4KSwgdGhpcy5fY2lwaGVyLmVuY3J5cHRCbG9jayh0aGlzLl9maW5JRCkpXG4gIGlmICh0aGlzLl9kZWNyeXB0KSB7XG4gICAgaWYgKHhvclRlc3QodGFnLCB0aGlzLl9hdXRoVGFnKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBzdGF0ZSBvciB1bmFibGUgdG8gYXV0aGVudGljYXRlIGRhdGEnKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9hdXRoVGFnID0gdGFnXG4gIH1cbiAgdGhpcy5fY2lwaGVyLnNjcnViKClcbn1cblN0cmVhbUNpcGhlci5wcm90b3R5cGUuZ2V0QXV0aFRhZyA9IGZ1bmN0aW9uIGdldEF1dGhUYWcgKCkge1xuICBpZiAoIXRoaXMuX2RlY3J5cHQgJiYgQnVmZmVyLmlzQnVmZmVyKHRoaXMuX2F1dGhUYWcpKSB7XG4gICAgcmV0dXJuIHRoaXMuX2F1dGhUYWdcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0F0dGVtcHRpbmcgdG8gZ2V0IGF1dGggdGFnIGluIHVuc3VwcG9ydGVkIHN0YXRlJylcbiAgfVxufVxuU3RyZWFtQ2lwaGVyLnByb3RvdHlwZS5zZXRBdXRoVGFnID0gZnVuY3Rpb24gc2V0QXV0aFRhZyAodGFnKSB7XG4gIGlmICh0aGlzLl9kZWNyeXB0KSB7XG4gICAgdGhpcy5fYXV0aFRhZyA9IHRhZ1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignQXR0ZW1wdGluZyB0byBzZXQgYXV0aCB0YWcgaW4gdW5zdXBwb3J0ZWQgc3RhdGUnKVxuICB9XG59XG5TdHJlYW1DaXBoZXIucHJvdG90eXBlLnNldEFBRCA9IGZ1bmN0aW9uIHNldEFBRCAoYnVmKSB7XG4gIGlmICghdGhpcy5fY2FsbGVkKSB7XG4gICAgdGhpcy5fZ2hhc2gudXBkYXRlKGJ1ZilcbiAgICB0aGlzLl9hbGVuICs9IGJ1Zi5sZW5ndGhcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0F0dGVtcHRpbmcgdG8gc2V0IEFBRCBpbiB1bnN1cHBvcnRlZCBzdGF0ZScpXG4gIH1cbn1cbmZ1bmN0aW9uIHhvclRlc3QgKGEsIGIpIHtcbiAgdmFyIG91dCA9IDBcbiAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgIG91dCsrXG4gIH1cbiAgdmFyIGxlbiA9IE1hdGgubWluKGEubGVuZ3RoLCBiLmxlbmd0aClcbiAgdmFyIGkgPSAtMVxuICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgb3V0ICs9IChhW2ldIF4gYltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG4iLCJ2YXIgYWVzID0gcmVxdWlyZSgnLi9hZXMnKVxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJ2NpcGhlci1iYXNlJylcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBtb2RlcyA9IHJlcXVpcmUoJy4vbW9kZXMnKVxudmFyIFN0cmVhbUNpcGhlciA9IHJlcXVpcmUoJy4vc3RyZWFtQ2lwaGVyJylcbnZhciBBdXRoQ2lwaGVyID0gcmVxdWlyZSgnLi9hdXRoQ2lwaGVyJylcbnZhciBlYnRrID0gcmVxdWlyZSgnZXZwX2J5dGVzdG9rZXknKVxuXG5pbmhlcml0cyhEZWNpcGhlciwgVHJhbnNmb3JtKVxuZnVuY3Rpb24gRGVjaXBoZXIgKG1vZGUsIGtleSwgaXYpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIERlY2lwaGVyKSkge1xuICAgIHJldHVybiBuZXcgRGVjaXBoZXIobW9kZSwga2V5LCBpdilcbiAgfVxuICBUcmFuc2Zvcm0uY2FsbCh0aGlzKVxuICB0aGlzLl9jYWNoZSA9IG5ldyBTcGxpdHRlcigpXG4gIHRoaXMuX2xhc3QgPSB2b2lkIDBcbiAgdGhpcy5fY2lwaGVyID0gbmV3IGFlcy5BRVMoa2V5KVxuICB0aGlzLl9wcmV2ID0gbmV3IEJ1ZmZlcihpdi5sZW5ndGgpXG4gIGl2LmNvcHkodGhpcy5fcHJldilcbiAgdGhpcy5fbW9kZSA9IG1vZGVcbiAgdGhpcy5fYXV0b3BhZGRpbmcgPSB0cnVlXG59XG5EZWNpcGhlci5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHRoaXMuX2NhY2hlLmFkZChkYXRhKVxuICB2YXIgY2h1bmtcbiAgdmFyIHRoaW5nXG4gIHZhciBvdXQgPSBbXVxuICB3aGlsZSAoKGNodW5rID0gdGhpcy5fY2FjaGUuZ2V0KHRoaXMuX2F1dG9wYWRkaW5nKSkpIHtcbiAgICB0aGluZyA9IHRoaXMuX21vZGUuZGVjcnlwdCh0aGlzLCBjaHVuaylcbiAgICBvdXQucHVzaCh0aGluZylcbiAgfVxuICByZXR1cm4gQnVmZmVyLmNvbmNhdChvdXQpXG59XG5EZWNpcGhlci5wcm90b3R5cGUuX2ZpbmFsID0gZnVuY3Rpb24gKCkge1xuICB2YXIgY2h1bmsgPSB0aGlzLl9jYWNoZS5mbHVzaCgpXG4gIGlmICh0aGlzLl9hdXRvcGFkZGluZykge1xuICAgIHJldHVybiB1bnBhZCh0aGlzLl9tb2RlLmRlY3J5cHQodGhpcywgY2h1bmspKVxuICB9IGVsc2UgaWYgKGNodW5rKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdkYXRhIG5vdCBtdWx0aXBsZSBvZiBibG9jayBsZW5ndGgnKVxuICB9XG59XG5EZWNpcGhlci5wcm90b3R5cGUuc2V0QXV0b1BhZGRpbmcgPSBmdW5jdGlvbiAoc2V0VG8pIHtcbiAgdGhpcy5fYXV0b3BhZGRpbmcgPSAhIXNldFRvXG59XG5mdW5jdGlvbiBTcGxpdHRlciAoKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTcGxpdHRlcikpIHtcbiAgICByZXR1cm4gbmV3IFNwbGl0dGVyKClcbiAgfVxuICB0aGlzLmNhY2hlID0gbmV3IEJ1ZmZlcignJylcbn1cblNwbGl0dGVyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB0aGlzLmNhY2hlID0gQnVmZmVyLmNvbmNhdChbdGhpcy5jYWNoZSwgZGF0YV0pXG59XG5cblNwbGl0dGVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoYXV0b1BhZGRpbmcpIHtcbiAgdmFyIG91dFxuICBpZiAoYXV0b1BhZGRpbmcpIHtcbiAgICBpZiAodGhpcy5jYWNoZS5sZW5ndGggPiAxNikge1xuICAgICAgb3V0ID0gdGhpcy5jYWNoZS5zbGljZSgwLCAxNilcbiAgICAgIHRoaXMuY2FjaGUgPSB0aGlzLmNhY2hlLnNsaWNlKDE2KVxuICAgICAgcmV0dXJuIG91dFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodGhpcy5jYWNoZS5sZW5ndGggPj0gMTYpIHtcbiAgICAgIG91dCA9IHRoaXMuY2FjaGUuc2xpY2UoMCwgMTYpXG4gICAgICB0aGlzLmNhY2hlID0gdGhpcy5jYWNoZS5zbGljZSgxNilcbiAgICAgIHJldHVybiBvdXRcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGxcbn1cblNwbGl0dGVyLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuY2FjaGUubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FjaGVcbiAgfVxufVxuZnVuY3Rpb24gdW5wYWQgKGxhc3QpIHtcbiAgdmFyIHBhZGRlZCA9IGxhc3RbMTVdXG4gIHZhciBpID0gLTFcbiAgd2hpbGUgKCsraSA8IHBhZGRlZCkge1xuICAgIGlmIChsYXN0WyhpICsgKDE2IC0gcGFkZGVkKSldICE9PSBwYWRkZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndW5hYmxlIHRvIGRlY3J5cHQgZGF0YScpXG4gICAgfVxuICB9XG4gIGlmIChwYWRkZWQgPT09IDE2KSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgcmV0dXJuIGxhc3Quc2xpY2UoMCwgMTYgLSBwYWRkZWQpXG59XG5cbnZhciBtb2RlbGlzdCA9IHtcbiAgRUNCOiByZXF1aXJlKCcuL21vZGVzL2VjYicpLFxuICBDQkM6IHJlcXVpcmUoJy4vbW9kZXMvY2JjJyksXG4gIENGQjogcmVxdWlyZSgnLi9tb2Rlcy9jZmInKSxcbiAgQ0ZCODogcmVxdWlyZSgnLi9tb2Rlcy9jZmI4JyksXG4gIENGQjE6IHJlcXVpcmUoJy4vbW9kZXMvY2ZiMScpLFxuICBPRkI6IHJlcXVpcmUoJy4vbW9kZXMvb2ZiJyksXG4gIENUUjogcmVxdWlyZSgnLi9tb2Rlcy9jdHInKSxcbiAgR0NNOiByZXF1aXJlKCcuL21vZGVzL2N0cicpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZURlY2lwaGVyaXYgKHN1aXRlLCBwYXNzd29yZCwgaXYpIHtcbiAgdmFyIGNvbmZpZyA9IG1vZGVzW3N1aXRlLnRvTG93ZXJDYXNlKCldXG4gIGlmICghY29uZmlnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBzdWl0ZSB0eXBlJylcbiAgfVxuICBpZiAodHlwZW9mIGl2ID09PSAnc3RyaW5nJykge1xuICAgIGl2ID0gbmV3IEJ1ZmZlcihpdilcbiAgfVxuICBpZiAodHlwZW9mIHBhc3N3b3JkID09PSAnc3RyaW5nJykge1xuICAgIHBhc3N3b3JkID0gbmV3IEJ1ZmZlcihwYXNzd29yZClcbiAgfVxuICBpZiAocGFzc3dvcmQubGVuZ3RoICE9PSBjb25maWcua2V5IC8gOCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQga2V5IGxlbmd0aCAnICsgcGFzc3dvcmQubGVuZ3RoKVxuICB9XG4gIGlmIChpdi5sZW5ndGggIT09IGNvbmZpZy5pdikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgaXYgbGVuZ3RoICcgKyBpdi5sZW5ndGgpXG4gIH1cbiAgaWYgKGNvbmZpZy50eXBlID09PSAnc3RyZWFtJykge1xuICAgIHJldHVybiBuZXcgU3RyZWFtQ2lwaGVyKG1vZGVsaXN0W2NvbmZpZy5tb2RlXSwgcGFzc3dvcmQsIGl2LCB0cnVlKVxuICB9IGVsc2UgaWYgKGNvbmZpZy50eXBlID09PSAnYXV0aCcpIHtcbiAgICByZXR1cm4gbmV3IEF1dGhDaXBoZXIobW9kZWxpc3RbY29uZmlnLm1vZGVdLCBwYXNzd29yZCwgaXYsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG5ldyBEZWNpcGhlcihtb2RlbGlzdFtjb25maWcubW9kZV0sIHBhc3N3b3JkLCBpdilcbn1cblxuZnVuY3Rpb24gY3JlYXRlRGVjaXBoZXIgKHN1aXRlLCBwYXNzd29yZCkge1xuICB2YXIgY29uZmlnID0gbW9kZXNbc3VpdGUudG9Mb3dlckNhc2UoKV1cbiAgaWYgKCFjb25maWcpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHN1aXRlIHR5cGUnKVxuICB9XG4gIHZhciBrZXlzID0gZWJ0ayhwYXNzd29yZCwgZmFsc2UsIGNvbmZpZy5rZXksIGNvbmZpZy5pdilcbiAgcmV0dXJuIGNyZWF0ZURlY2lwaGVyaXYoc3VpdGUsIGtleXMua2V5LCBrZXlzLml2KVxufVxuZXhwb3J0cy5jcmVhdGVEZWNpcGhlciA9IGNyZWF0ZURlY2lwaGVyXG5leHBvcnRzLmNyZWF0ZURlY2lwaGVyaXYgPSBjcmVhdGVEZWNpcGhlcml2XG4iLCJ2YXIgYWVzID0gcmVxdWlyZSgnLi9hZXMnKVxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJ2NpcGhlci1iYXNlJylcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBtb2RlcyA9IHJlcXVpcmUoJy4vbW9kZXMnKVxudmFyIGVidGsgPSByZXF1aXJlKCdldnBfYnl0ZXN0b2tleScpXG52YXIgU3RyZWFtQ2lwaGVyID0gcmVxdWlyZSgnLi9zdHJlYW1DaXBoZXInKVxudmFyIEF1dGhDaXBoZXIgPSByZXF1aXJlKCcuL2F1dGhDaXBoZXInKVxuaW5oZXJpdHMoQ2lwaGVyLCBUcmFuc2Zvcm0pXG5mdW5jdGlvbiBDaXBoZXIgKG1vZGUsIGtleSwgaXYpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIENpcGhlcikpIHtcbiAgICByZXR1cm4gbmV3IENpcGhlcihtb2RlLCBrZXksIGl2KVxuICB9XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMpXG4gIHRoaXMuX2NhY2hlID0gbmV3IFNwbGl0dGVyKClcbiAgdGhpcy5fY2lwaGVyID0gbmV3IGFlcy5BRVMoa2V5KVxuICB0aGlzLl9wcmV2ID0gbmV3IEJ1ZmZlcihpdi5sZW5ndGgpXG4gIGl2LmNvcHkodGhpcy5fcHJldilcbiAgdGhpcy5fbW9kZSA9IG1vZGVcbiAgdGhpcy5fYXV0b3BhZGRpbmcgPSB0cnVlXG59XG5DaXBoZXIucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB0aGlzLl9jYWNoZS5hZGQoZGF0YSlcbiAgdmFyIGNodW5rXG4gIHZhciB0aGluZ1xuICB2YXIgb3V0ID0gW11cbiAgd2hpbGUgKChjaHVuayA9IHRoaXMuX2NhY2hlLmdldCgpKSkge1xuICAgIHRoaW5nID0gdGhpcy5fbW9kZS5lbmNyeXB0KHRoaXMsIGNodW5rKVxuICAgIG91dC5wdXNoKHRoaW5nKVxuICB9XG4gIHJldHVybiBCdWZmZXIuY29uY2F0KG91dClcbn1cbkNpcGhlci5wcm90b3R5cGUuX2ZpbmFsID0gZnVuY3Rpb24gKCkge1xuICB2YXIgY2h1bmsgPSB0aGlzLl9jYWNoZS5mbHVzaCgpXG4gIGlmICh0aGlzLl9hdXRvcGFkZGluZykge1xuICAgIGNodW5rID0gdGhpcy5fbW9kZS5lbmNyeXB0KHRoaXMsIGNodW5rKVxuICAgIHRoaXMuX2NpcGhlci5zY3J1YigpXG4gICAgcmV0dXJuIGNodW5rXG4gIH0gZWxzZSBpZiAoY2h1bmsudG9TdHJpbmcoJ2hleCcpICE9PSAnMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAnKSB7XG4gICAgdGhpcy5fY2lwaGVyLnNjcnViKClcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2RhdGEgbm90IG11bHRpcGxlIG9mIGJsb2NrIGxlbmd0aCcpXG4gIH1cbn1cbkNpcGhlci5wcm90b3R5cGUuc2V0QXV0b1BhZGRpbmcgPSBmdW5jdGlvbiAoc2V0VG8pIHtcbiAgdGhpcy5fYXV0b3BhZGRpbmcgPSAhIXNldFRvXG59XG5cbmZ1bmN0aW9uIFNwbGl0dGVyICgpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNwbGl0dGVyKSkge1xuICAgIHJldHVybiBuZXcgU3BsaXR0ZXIoKVxuICB9XG4gIHRoaXMuY2FjaGUgPSBuZXcgQnVmZmVyKCcnKVxufVxuU3BsaXR0ZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHRoaXMuY2FjaGUgPSBCdWZmZXIuY29uY2F0KFt0aGlzLmNhY2hlLCBkYXRhXSlcbn1cblxuU3BsaXR0ZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuY2FjaGUubGVuZ3RoID4gMTUpIHtcbiAgICB2YXIgb3V0ID0gdGhpcy5jYWNoZS5zbGljZSgwLCAxNilcbiAgICB0aGlzLmNhY2hlID0gdGhpcy5jYWNoZS5zbGljZSgxNilcbiAgICByZXR1cm4gb3V0XG4gIH1cbiAgcmV0dXJuIG51bGxcbn1cblNwbGl0dGVyLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGxlbiA9IDE2IC0gdGhpcy5jYWNoZS5sZW5ndGhcbiAgdmFyIHBhZEJ1ZmYgPSBuZXcgQnVmZmVyKGxlbilcblxuICB2YXIgaSA9IC0xXG4gIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICBwYWRCdWZmLndyaXRlVUludDgobGVuLCBpKVxuICB9XG4gIHZhciBvdXQgPSBCdWZmZXIuY29uY2F0KFt0aGlzLmNhY2hlLCBwYWRCdWZmXSlcbiAgcmV0dXJuIG91dFxufVxudmFyIG1vZGVsaXN0ID0ge1xuICBFQ0I6IHJlcXVpcmUoJy4vbW9kZXMvZWNiJyksXG4gIENCQzogcmVxdWlyZSgnLi9tb2Rlcy9jYmMnKSxcbiAgQ0ZCOiByZXF1aXJlKCcuL21vZGVzL2NmYicpLFxuICBDRkI4OiByZXF1aXJlKCcuL21vZGVzL2NmYjgnKSxcbiAgQ0ZCMTogcmVxdWlyZSgnLi9tb2Rlcy9jZmIxJyksXG4gIE9GQjogcmVxdWlyZSgnLi9tb2Rlcy9vZmInKSxcbiAgQ1RSOiByZXF1aXJlKCcuL21vZGVzL2N0cicpLFxuICBHQ006IHJlcXVpcmUoJy4vbW9kZXMvY3RyJylcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ2lwaGVyaXYgKHN1aXRlLCBwYXNzd29yZCwgaXYpIHtcbiAgdmFyIGNvbmZpZyA9IG1vZGVzW3N1aXRlLnRvTG93ZXJDYXNlKCldXG4gIGlmICghY29uZmlnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBzdWl0ZSB0eXBlJylcbiAgfVxuICBpZiAodHlwZW9mIGl2ID09PSAnc3RyaW5nJykge1xuICAgIGl2ID0gbmV3IEJ1ZmZlcihpdilcbiAgfVxuICBpZiAodHlwZW9mIHBhc3N3b3JkID09PSAnc3RyaW5nJykge1xuICAgIHBhc3N3b3JkID0gbmV3IEJ1ZmZlcihwYXNzd29yZClcbiAgfVxuICBpZiAocGFzc3dvcmQubGVuZ3RoICE9PSBjb25maWcua2V5IC8gOCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQga2V5IGxlbmd0aCAnICsgcGFzc3dvcmQubGVuZ3RoKVxuICB9XG4gIGlmIChpdi5sZW5ndGggIT09IGNvbmZpZy5pdikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgaXYgbGVuZ3RoICcgKyBpdi5sZW5ndGgpXG4gIH1cbiAgaWYgKGNvbmZpZy50eXBlID09PSAnc3RyZWFtJykge1xuICAgIHJldHVybiBuZXcgU3RyZWFtQ2lwaGVyKG1vZGVsaXN0W2NvbmZpZy5tb2RlXSwgcGFzc3dvcmQsIGl2KVxuICB9IGVsc2UgaWYgKGNvbmZpZy50eXBlID09PSAnYXV0aCcpIHtcbiAgICByZXR1cm4gbmV3IEF1dGhDaXBoZXIobW9kZWxpc3RbY29uZmlnLm1vZGVdLCBwYXNzd29yZCwgaXYpXG4gIH1cbiAgcmV0dXJuIG5ldyBDaXBoZXIobW9kZWxpc3RbY29uZmlnLm1vZGVdLCBwYXNzd29yZCwgaXYpXG59XG5mdW5jdGlvbiBjcmVhdGVDaXBoZXIgKHN1aXRlLCBwYXNzd29yZCkge1xuICB2YXIgY29uZmlnID0gbW9kZXNbc3VpdGUudG9Mb3dlckNhc2UoKV1cbiAgaWYgKCFjb25maWcpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHN1aXRlIHR5cGUnKVxuICB9XG4gIHZhciBrZXlzID0gZWJ0ayhwYXNzd29yZCwgZmFsc2UsIGNvbmZpZy5rZXksIGNvbmZpZy5pdilcbiAgcmV0dXJuIGNyZWF0ZUNpcGhlcml2KHN1aXRlLCBrZXlzLmtleSwga2V5cy5pdilcbn1cblxuZXhwb3J0cy5jcmVhdGVDaXBoZXJpdiA9IGNyZWF0ZUNpcGhlcml2XG5leHBvcnRzLmNyZWF0ZUNpcGhlciA9IGNyZWF0ZUNpcGhlclxuIiwidmFyIHplcm9zID0gbmV3IEJ1ZmZlcigxNilcbnplcm9zLmZpbGwoMClcbm1vZHVsZS5leHBvcnRzID0gR0hBU0hcbmZ1bmN0aW9uIEdIQVNIIChrZXkpIHtcbiAgdGhpcy5oID0ga2V5XG4gIHRoaXMuc3RhdGUgPSBuZXcgQnVmZmVyKDE2KVxuICB0aGlzLnN0YXRlLmZpbGwoMClcbiAgdGhpcy5jYWNoZSA9IG5ldyBCdWZmZXIoJycpXG59XG4vLyBmcm9tIGh0dHA6Ly9iaXR3aXNlc2hpZnRsZWZ0LmdpdGh1Yi5pby9zamNsL2RvYy9zeW1ib2xzL3NyYy9jb3JlX2djbS5qcy5odG1sXG4vLyBieSBKdWhvIFbDpGjDpC1IZXJ0dHVhXG5HSEFTSC5wcm90b3R5cGUuZ2hhc2ggPSBmdW5jdGlvbiAoYmxvY2spIHtcbiAgdmFyIGkgPSAtMVxuICB3aGlsZSAoKytpIDwgYmxvY2subGVuZ3RoKSB7XG4gICAgdGhpcy5zdGF0ZVtpXSBePSBibG9ja1tpXVxuICB9XG4gIHRoaXMuX211bHRpcGx5KClcbn1cblxuR0hBU0gucHJvdG90eXBlLl9tdWx0aXBseSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIFZpID0gdG9BcnJheSh0aGlzLmgpXG4gIHZhciBaaSA9IFswLCAwLCAwLCAwXVxuICB2YXIgaiwgeGksIGxzYl9WaVxuICB2YXIgaSA9IC0xXG4gIHdoaWxlICgrK2kgPCAxMjgpIHtcbiAgICB4aSA9ICh0aGlzLnN0YXRlW35+KGkgLyA4KV0gJiAoMSA8PCAoNyAtIGkgJSA4KSkpICE9PSAwXG4gICAgaWYgKHhpKSB7XG4gICAgICAvLyBaX2krMSA9IFpfaSBeIFZfaVxuICAgICAgWmkgPSB4b3IoWmksIFZpKVxuICAgIH1cblxuICAgIC8vIFN0b3JlIHRoZSB2YWx1ZSBvZiBMU0IoVl9pKVxuICAgIGxzYl9WaSA9IChWaVszXSAmIDEpICE9PSAwXG5cbiAgICAvLyBWX2krMSA9IFZfaSA+PiAxXG4gICAgZm9yIChqID0gMzsgaiA+IDA7IGotLSkge1xuICAgICAgVmlbal0gPSAoVmlbal0gPj4+IDEpIHwgKChWaVtqIC0gMV0gJiAxKSA8PCAzMSlcbiAgICB9XG4gICAgVmlbMF0gPSBWaVswXSA+Pj4gMVxuXG4gICAgLy8gSWYgTFNCKFZfaSkgaXMgMSwgVl9pKzEgPSAoVl9pID4+IDEpIF4gUlxuICAgIGlmIChsc2JfVmkpIHtcbiAgICAgIFZpWzBdID0gVmlbMF0gXiAoMHhlMSA8PCAyNClcbiAgICB9XG4gIH1cbiAgdGhpcy5zdGF0ZSA9IGZyb21BcnJheShaaSlcbn1cbkdIQVNILnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIHRoaXMuY2FjaGUgPSBCdWZmZXIuY29uY2F0KFt0aGlzLmNhY2hlLCBidWZdKVxuICB2YXIgY2h1bmtcbiAgd2hpbGUgKHRoaXMuY2FjaGUubGVuZ3RoID49IDE2KSB7XG4gICAgY2h1bmsgPSB0aGlzLmNhY2hlLnNsaWNlKDAsIDE2KVxuICAgIHRoaXMuY2FjaGUgPSB0aGlzLmNhY2hlLnNsaWNlKDE2KVxuICAgIHRoaXMuZ2hhc2goY2h1bmspXG4gIH1cbn1cbkdIQVNILnByb3RvdHlwZS5maW5hbCA9IGZ1bmN0aW9uIChhYmwsIGJsKSB7XG4gIGlmICh0aGlzLmNhY2hlLmxlbmd0aCkge1xuICAgIHRoaXMuZ2hhc2goQnVmZmVyLmNvbmNhdChbdGhpcy5jYWNoZSwgemVyb3NdLCAxNikpXG4gIH1cbiAgdGhpcy5naGFzaChmcm9tQXJyYXkoW1xuICAgIDAsIGFibCxcbiAgICAwLCBibFxuICBdKSlcbiAgcmV0dXJuIHRoaXMuc3RhdGVcbn1cblxuZnVuY3Rpb24gdG9BcnJheSAoYnVmKSB7XG4gIHJldHVybiBbXG4gICAgYnVmLnJlYWRVSW50MzJCRSgwKSxcbiAgICBidWYucmVhZFVJbnQzMkJFKDQpLFxuICAgIGJ1Zi5yZWFkVUludDMyQkUoOCksXG4gICAgYnVmLnJlYWRVSW50MzJCRSgxMilcbiAgXVxufVxuZnVuY3Rpb24gZnJvbUFycmF5IChvdXQpIHtcbiAgb3V0ID0gb3V0Lm1hcChmaXh1cF91aW50MzIpXG4gIHZhciBidWYgPSBuZXcgQnVmZmVyKDE2KVxuICBidWYud3JpdGVVSW50MzJCRShvdXRbMF0sIDApXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKG91dFsxXSwgNClcbiAgYnVmLndyaXRlVUludDMyQkUob3V0WzJdLCA4KVxuICBidWYud3JpdGVVSW50MzJCRShvdXRbM10sIDEyKVxuICByZXR1cm4gYnVmXG59XG52YXIgdWludF9tYXggPSBNYXRoLnBvdygyLCAzMilcbmZ1bmN0aW9uIGZpeHVwX3VpbnQzMiAoeCkge1xuICB2YXIgcmV0LCB4X3Bvc1xuICByZXQgPSB4ID4gdWludF9tYXggfHwgeCA8IDAgPyAoeF9wb3MgPSBNYXRoLmFicyh4KSAlIHVpbnRfbWF4LCB4IDwgMCA/IHVpbnRfbWF4IC0geF9wb3MgOiB4X3BvcykgOiB4XG4gIHJldHVybiByZXRcbn1cbmZ1bmN0aW9uIHhvciAoYSwgYikge1xuICByZXR1cm4gW1xuICAgIGFbMF0gXiBiWzBdLFxuICAgIGFbMV0gXiBiWzFdLFxuICAgIGFbMl0gXiBiWzJdLFxuICAgIGFbM10gXiBiWzNdXG4gIF1cbn1cbiIsInZhciB4b3IgPSByZXF1aXJlKCdidWZmZXIteG9yJylcblxuZXhwb3J0cy5lbmNyeXB0ID0gZnVuY3Rpb24gKHNlbGYsIGRhdGEsIGRlY3J5cHQpIHtcbiAgdmFyIG91dCA9IG5ldyBCdWZmZXIoJycpXG4gIHZhciBsZW5cblxuICB3aGlsZSAoZGF0YS5sZW5ndGgpIHtcbiAgICBpZiAoc2VsZi5fY2FjaGUubGVuZ3RoID09PSAwKSB7XG4gICAgICBzZWxmLl9jYWNoZSA9IHNlbGYuX2NpcGhlci5lbmNyeXB0QmxvY2soc2VsZi5fcHJldilcbiAgICAgIHNlbGYuX3ByZXYgPSBuZXcgQnVmZmVyKCcnKVxuICAgIH1cblxuICAgIGlmIChzZWxmLl9jYWNoZS5sZW5ndGggPD0gZGF0YS5sZW5ndGgpIHtcbiAgICAgIGxlbiA9IHNlbGYuX2NhY2hlLmxlbmd0aFxuICAgICAgb3V0ID0gQnVmZmVyLmNvbmNhdChbb3V0LCBlbmNyeXB0U3RhcnQoc2VsZiwgZGF0YS5zbGljZSgwLCBsZW4pLCBkZWNyeXB0KV0pXG4gICAgICBkYXRhID0gZGF0YS5zbGljZShsZW4pXG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCA9IEJ1ZmZlci5jb25jYXQoW291dCwgZW5jcnlwdFN0YXJ0KHNlbGYsIGRhdGEsIGRlY3J5cHQpXSlcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG91dFxufVxuZnVuY3Rpb24gZW5jcnlwdFN0YXJ0IChzZWxmLCBkYXRhLCBkZWNyeXB0KSB7XG4gIHZhciBsZW4gPSBkYXRhLmxlbmd0aFxuICB2YXIgb3V0ID0geG9yKGRhdGEsIHNlbGYuX2NhY2hlKVxuICBzZWxmLl9jYWNoZSA9IHNlbGYuX2NhY2hlLnNsaWNlKGxlbilcbiAgc2VsZi5fcHJldiA9IEJ1ZmZlci5jb25jYXQoW3NlbGYuX3ByZXYsIGRlY3J5cHQgPyBkYXRhIDogb3V0XSlcbiAgcmV0dXJuIG91dFxufVxuIiwiZnVuY3Rpb24gZW5jcnlwdEJ5dGUgKHNlbGYsIGJ5dGVQYXJhbSwgZGVjcnlwdCkge1xuICB2YXIgcGFkXG4gIHZhciBpID0gLTFcbiAgdmFyIGxlbiA9IDhcbiAgdmFyIG91dCA9IDBcbiAgdmFyIGJpdCwgdmFsdWVcbiAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgIHBhZCA9IHNlbGYuX2NpcGhlci5lbmNyeXB0QmxvY2soc2VsZi5fcHJldilcbiAgICBiaXQgPSAoYnl0ZVBhcmFtICYgKDEgPDwgKDcgLSBpKSkpID8gMHg4MCA6IDBcbiAgICB2YWx1ZSA9IHBhZFswXSBeIGJpdFxuICAgIG91dCArPSAoKHZhbHVlICYgMHg4MCkgPj4gKGkgJSA4KSlcbiAgICBzZWxmLl9wcmV2ID0gc2hpZnRJbihzZWxmLl9wcmV2LCBkZWNyeXB0ID8gYml0IDogdmFsdWUpXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuZXhwb3J0cy5lbmNyeXB0ID0gZnVuY3Rpb24gKHNlbGYsIGNodW5rLCBkZWNyeXB0KSB7XG4gIHZhciBsZW4gPSBjaHVuay5sZW5ndGhcbiAgdmFyIG91dCA9IG5ldyBCdWZmZXIobGVuKVxuICB2YXIgaSA9IC0xXG4gIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICBvdXRbaV0gPSBlbmNyeXB0Qnl0ZShzZWxmLCBjaHVua1tpXSwgZGVjcnlwdClcbiAgfVxuICByZXR1cm4gb3V0XG59XG5mdW5jdGlvbiBzaGlmdEluIChidWZmZXIsIHZhbHVlKSB7XG4gIHZhciBsZW4gPSBidWZmZXIubGVuZ3RoXG4gIHZhciBpID0gLTFcbiAgdmFyIG91dCA9IG5ldyBCdWZmZXIoYnVmZmVyLmxlbmd0aClcbiAgYnVmZmVyID0gQnVmZmVyLmNvbmNhdChbYnVmZmVyLCBuZXcgQnVmZmVyKFt2YWx1ZV0pXSlcbiAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgIG91dFtpXSA9IGJ1ZmZlcltpXSA8PCAxIHwgYnVmZmVyW2kgKyAxXSA+PiAoNylcbiAgfVxuICByZXR1cm4gb3V0XG59XG4iLCJmdW5jdGlvbiBlbmNyeXB0Qnl0ZSAoc2VsZiwgYnl0ZVBhcmFtLCBkZWNyeXB0KSB7XG4gIHZhciBwYWQgPSBzZWxmLl9jaXBoZXIuZW5jcnlwdEJsb2NrKHNlbGYuX3ByZXYpXG4gIHZhciBvdXQgPSBwYWRbMF0gXiBieXRlUGFyYW1cbiAgc2VsZi5fcHJldiA9IEJ1ZmZlci5jb25jYXQoW3NlbGYuX3ByZXYuc2xpY2UoMSksIG5ldyBCdWZmZXIoW2RlY3J5cHQgPyBieXRlUGFyYW0gOiBvdXRdKV0pXG4gIHJldHVybiBvdXRcbn1cbmV4cG9ydHMuZW5jcnlwdCA9IGZ1bmN0aW9uIChzZWxmLCBjaHVuaywgZGVjcnlwdCkge1xuICB2YXIgbGVuID0gY2h1bmsubGVuZ3RoXG4gIHZhciBvdXQgPSBuZXcgQnVmZmVyKGxlbilcbiAgdmFyIGkgPSAtMVxuICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgb3V0W2ldID0gZW5jcnlwdEJ5dGUoc2VsZiwgY2h1bmtbaV0sIGRlY3J5cHQpXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuIiwidmFyIHhvciA9IHJlcXVpcmUoJ2J1ZmZlci14b3InKVxuXG5mdW5jdGlvbiBpbmNyMzIgKGl2KSB7XG4gIHZhciBsZW4gPSBpdi5sZW5ndGhcbiAgdmFyIGl0ZW1cbiAgd2hpbGUgKGxlbi0tKSB7XG4gICAgaXRlbSA9IGl2LnJlYWRVSW50OChsZW4pXG4gICAgaWYgKGl0ZW0gPT09IDI1NSkge1xuICAgICAgaXYud3JpdGVVSW50OCgwLCBsZW4pXG4gICAgfSBlbHNlIHtcbiAgICAgIGl0ZW0rK1xuICAgICAgaXYud3JpdGVVSW50OChpdGVtLCBsZW4pXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRCbG9jayAoc2VsZikge1xuICB2YXIgb3V0ID0gc2VsZi5fY2lwaGVyLmVuY3J5cHRCbG9jayhzZWxmLl9wcmV2KVxuICBpbmNyMzIoc2VsZi5fcHJldilcbiAgcmV0dXJuIG91dFxufVxuXG5leHBvcnRzLmVuY3J5cHQgPSBmdW5jdGlvbiAoc2VsZiwgY2h1bmspIHtcbiAgd2hpbGUgKHNlbGYuX2NhY2hlLmxlbmd0aCA8IGNodW5rLmxlbmd0aCkge1xuICAgIHNlbGYuX2NhY2hlID0gQnVmZmVyLmNvbmNhdChbc2VsZi5fY2FjaGUsIGdldEJsb2NrKHNlbGYpXSlcbiAgfVxuICB2YXIgcGFkID0gc2VsZi5fY2FjaGUuc2xpY2UoMCwgY2h1bmsubGVuZ3RoKVxuICBzZWxmLl9jYWNoZSA9IHNlbGYuX2NhY2hlLnNsaWNlKGNodW5rLmxlbmd0aClcbiAgcmV0dXJuIHhvcihjaHVuaywgcGFkKVxufVxuIiwidmFyIHhvciA9IHJlcXVpcmUoJ2J1ZmZlci14b3InKVxuXG5mdW5jdGlvbiBnZXRCbG9jayAoc2VsZikge1xuICBzZWxmLl9wcmV2ID0gc2VsZi5fY2lwaGVyLmVuY3J5cHRCbG9jayhzZWxmLl9wcmV2KVxuICByZXR1cm4gc2VsZi5fcHJldlxufVxuXG5leHBvcnRzLmVuY3J5cHQgPSBmdW5jdGlvbiAoc2VsZiwgY2h1bmspIHtcbiAgd2hpbGUgKHNlbGYuX2NhY2hlLmxlbmd0aCA8IGNodW5rLmxlbmd0aCkge1xuICAgIHNlbGYuX2NhY2hlID0gQnVmZmVyLmNvbmNhdChbc2VsZi5fY2FjaGUsIGdldEJsb2NrKHNlbGYpXSlcbiAgfVxuXG4gIHZhciBwYWQgPSBzZWxmLl9jYWNoZS5zbGljZSgwLCBjaHVuay5sZW5ndGgpXG4gIHNlbGYuX2NhY2hlID0gc2VsZi5fY2FjaGUuc2xpY2UoY2h1bmsubGVuZ3RoKVxuICByZXR1cm4geG9yKGNodW5rLCBwYWQpXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHhvciAoYSwgYikge1xuICB2YXIgbGVuZ3RoID0gTWF0aC5taW4oYS5sZW5ndGgsIGIubGVuZ3RoKVxuICB2YXIgYnVmZmVyID0gbmV3IEJ1ZmZlcihsZW5ndGgpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGJ1ZmZlcltpXSA9IGFbaV0gXiBiW2ldXG4gIH1cblxuICByZXR1cm4gYnVmZmVyXG59XG4iLCJ2YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnc3RyZWFtJykuVHJhbnNmb3JtXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyJykuU3RyaW5nRGVjb2RlclxubW9kdWxlLmV4cG9ydHMgPSBDaXBoZXJCYXNlXG5pbmhlcml0cyhDaXBoZXJCYXNlLCBUcmFuc2Zvcm0pXG5mdW5jdGlvbiBDaXBoZXJCYXNlIChoYXNoTW9kZSkge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzKVxuICB0aGlzLmhhc2hNb2RlID0gdHlwZW9mIGhhc2hNb2RlID09PSAnc3RyaW5nJ1xuICBpZiAodGhpcy5oYXNoTW9kZSkge1xuICAgIHRoaXNbaGFzaE1vZGVdID0gdGhpcy5fZmluYWxPckRpZ2VzdFxuICB9IGVsc2Uge1xuICAgIHRoaXMuZmluYWwgPSB0aGlzLl9maW5hbE9yRGlnZXN0XG4gIH1cbiAgdGhpcy5fZGVjb2RlciA9IG51bGxcbiAgdGhpcy5fZW5jb2RpbmcgPSBudWxsXG59XG5DaXBoZXJCYXNlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGF0YSwgaW5wdXRFbmMsIG91dHB1dEVuYykge1xuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgZGF0YSA9IG5ldyBCdWZmZXIoZGF0YSwgaW5wdXRFbmMpXG4gIH1cbiAgdmFyIG91dERhdGEgPSB0aGlzLl91cGRhdGUoZGF0YSlcbiAgaWYgKHRoaXMuaGFzaE1vZGUpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG4gIGlmIChvdXRwdXRFbmMpIHtcbiAgICBvdXREYXRhID0gdGhpcy5fdG9TdHJpbmcob3V0RGF0YSwgb3V0cHV0RW5jKVxuICB9XG4gIHJldHVybiBvdXREYXRhXG59XG5cbkNpcGhlckJhc2UucHJvdG90eXBlLnNldEF1dG9QYWRkaW5nID0gZnVuY3Rpb24gKCkge31cblxuQ2lwaGVyQmFzZS5wcm90b3R5cGUuZ2V0QXV0aFRhZyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCd0cnlpbmcgdG8gZ2V0IGF1dGggdGFnIGluIHVuc3VwcG9ydGVkIHN0YXRlJylcbn1cblxuQ2lwaGVyQmFzZS5wcm90b3R5cGUuc2V0QXV0aFRhZyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCd0cnlpbmcgdG8gc2V0IGF1dGggdGFnIGluIHVuc3VwcG9ydGVkIHN0YXRlJylcbn1cblxuQ2lwaGVyQmFzZS5wcm90b3R5cGUuc2V0QUFEID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ3RyeWluZyB0byBzZXQgYWFkIGluIHVuc3VwcG9ydGVkIHN0YXRlJylcbn1cblxuQ2lwaGVyQmFzZS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChkYXRhLCBfLCBuZXh0KSB7XG4gIHZhciBlcnJcbiAgdHJ5IHtcbiAgICBpZiAodGhpcy5oYXNoTW9kZSkge1xuICAgICAgdGhpcy5fdXBkYXRlKGRhdGEpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucHVzaCh0aGlzLl91cGRhdGUoZGF0YSkpXG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgZXJyID0gZVxuICB9IGZpbmFsbHkge1xuICAgIG5leHQoZXJyKVxuICB9XG59XG5DaXBoZXJCYXNlLnByb3RvdHlwZS5fZmx1c2ggPSBmdW5jdGlvbiAoZG9uZSkge1xuICB2YXIgZXJyXG4gIHRyeSB7XG4gICAgdGhpcy5wdXNoKHRoaXMuX2ZpbmFsKCkpXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBlcnIgPSBlXG4gIH0gZmluYWxseSB7XG4gICAgZG9uZShlcnIpXG4gIH1cbn1cbkNpcGhlckJhc2UucHJvdG90eXBlLl9maW5hbE9yRGlnZXN0ID0gZnVuY3Rpb24gKG91dHB1dEVuYykge1xuICB2YXIgb3V0RGF0YSA9IHRoaXMuX2ZpbmFsKCkgfHwgbmV3IEJ1ZmZlcignJylcbiAgaWYgKG91dHB1dEVuYykge1xuICAgIG91dERhdGEgPSB0aGlzLl90b1N0cmluZyhvdXREYXRhLCBvdXRwdXRFbmMsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG91dERhdGFcbn1cblxuQ2lwaGVyQmFzZS5wcm90b3R5cGUuX3RvU3RyaW5nID0gZnVuY3Rpb24gKHZhbHVlLCBlbmMsIGZpbmFsKSB7XG4gIGlmICghdGhpcy5fZGVjb2Rlcikge1xuICAgIHRoaXMuX2RlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihlbmMpXG4gICAgdGhpcy5fZW5jb2RpbmcgPSBlbmNcbiAgfVxuICBpZiAodGhpcy5fZW5jb2RpbmcgIT09IGVuYykge1xuICAgIHRocm93IG5ldyBFcnJvcignY2FuXFwndCBzd2l0Y2ggZW5jb2RpbmdzJylcbiAgfVxuICB2YXIgb3V0ID0gdGhpcy5fZGVjb2Rlci53cml0ZSh2YWx1ZSlcbiAgaWYgKGZpbmFsKSB7XG4gICAgb3V0ICs9IHRoaXMuX2RlY29kZXIuZW5kKClcbiAgfVxuICByZXR1cm4gb3V0XG59XG4iLCJ2YXIgYWVzID0gcmVxdWlyZSgnLi9hZXMnKVxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJ2NpcGhlci1iYXNlJylcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcblxuaW5oZXJpdHMoU3RyZWFtQ2lwaGVyLCBUcmFuc2Zvcm0pXG5tb2R1bGUuZXhwb3J0cyA9IFN0cmVhbUNpcGhlclxuZnVuY3Rpb24gU3RyZWFtQ2lwaGVyIChtb2RlLCBrZXksIGl2LCBkZWNyeXB0KSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTdHJlYW1DaXBoZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBTdHJlYW1DaXBoZXIobW9kZSwga2V5LCBpdilcbiAgfVxuICBUcmFuc2Zvcm0uY2FsbCh0aGlzKVxuICB0aGlzLl9jaXBoZXIgPSBuZXcgYWVzLkFFUyhrZXkpXG4gIHRoaXMuX3ByZXYgPSBuZXcgQnVmZmVyKGl2Lmxlbmd0aClcbiAgdGhpcy5fY2FjaGUgPSBuZXcgQnVmZmVyKCcnKVxuICB0aGlzLl9zZWNDYWNoZSA9IG5ldyBCdWZmZXIoJycpXG4gIHRoaXMuX2RlY3J5cHQgPSBkZWNyeXB0XG4gIGl2LmNvcHkodGhpcy5fcHJldilcbiAgdGhpcy5fbW9kZSA9IG1vZGVcbn1cblN0cmVhbUNpcGhlci5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChjaHVuaykge1xuICByZXR1cm4gdGhpcy5fbW9kZS5lbmNyeXB0KHRoaXMsIGNodW5rLCB0aGlzLl9kZWNyeXB0KVxufVxuU3RyZWFtQ2lwaGVyLnByb3RvdHlwZS5fZmluYWwgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX2NpcGhlci5zY3J1YigpXG59XG4iLCJ2YXIgbWQ1ID0gcmVxdWlyZSgnY3JlYXRlLWhhc2gvbWQ1Jylcbm1vZHVsZS5leHBvcnRzID0gRVZQX0J5dGVzVG9LZXlcbmZ1bmN0aW9uIEVWUF9CeXRlc1RvS2V5IChwYXNzd29yZCwgc2FsdCwga2V5TGVuLCBpdkxlbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihwYXNzd29yZCkpIHtcbiAgICBwYXNzd29yZCA9IG5ldyBCdWZmZXIocGFzc3dvcmQsICdiaW5hcnknKVxuICB9XG4gIGlmIChzYWx0ICYmICFCdWZmZXIuaXNCdWZmZXIoc2FsdCkpIHtcbiAgICBzYWx0ID0gbmV3IEJ1ZmZlcihzYWx0LCAnYmluYXJ5JylcbiAgfVxuICBrZXlMZW4gPSBrZXlMZW4gLyA4XG4gIGl2TGVuID0gaXZMZW4gfHwgMFxuICB2YXIga2kgPSAwXG4gIHZhciBpaSA9IDBcbiAgdmFyIGtleSA9IG5ldyBCdWZmZXIoa2V5TGVuKVxuICB2YXIgaXYgPSBuZXcgQnVmZmVyKGl2TGVuKVxuICB2YXIgYWRkbWQgPSAwXG4gIHZhciBtZF9idWZcbiAgdmFyIGlcbiAgdmFyIGJ1ZnMgPSBbXVxuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmIChhZGRtZCsrID4gMCkge1xuICAgICAgYnVmcy5wdXNoKG1kX2J1ZilcbiAgICB9XG4gICAgYnVmcy5wdXNoKHBhc3N3b3JkKVxuICAgIGlmIChzYWx0KSB7XG4gICAgICBidWZzLnB1c2goc2FsdClcbiAgICB9XG4gICAgbWRfYnVmID0gbWQ1KEJ1ZmZlci5jb25jYXQoYnVmcykpXG4gICAgYnVmcyA9IFtdXG4gICAgaSA9IDBcbiAgICBpZiAoa2V5TGVuID4gMCkge1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgaWYgKGtleUxlbiA9PT0gMCkge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPT09IG1kX2J1Zi5sZW5ndGgpIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGtleVtraSsrXSA9IG1kX2J1ZltpXVxuICAgICAgICBrZXlMZW4tLVxuICAgICAgICBpKytcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGl2TGVuID4gMCAmJiBpICE9PSBtZF9idWYubGVuZ3RoKSB7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBpZiAoaXZMZW4gPT09IDApIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGlmIChpID09PSBtZF9idWYubGVuZ3RoKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBpdltpaSsrXSA9IG1kX2J1ZltpXVxuICAgICAgICBpdkxlbi0tXG4gICAgICAgIGkrK1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoa2V5TGVuID09PSAwICYmIGl2TGVuID09PSAwKSB7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuICBmb3IgKGkgPSAwOyBpIDwgbWRfYnVmLmxlbmd0aDsgaSsrKSB7XG4gICAgbWRfYnVmW2ldID0gMFxuICB9XG4gIHJldHVybiB7XG4gICAga2V5OiBrZXksXG4gICAgaXY6IGl2XG4gIH1cbn1cbiIsIi8vIG11Y2ggb2YgdGhpcyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vaW5kdXRueS9zZWxmLXNpZ25lZC9ibG9iL2doLXBhZ2VzL2xpYi9yc2EuanNcbnZhciBjcmVhdGVIbWFjID0gcmVxdWlyZSgnY3JlYXRlLWhtYWMnKVxudmFyIGNydCA9IHJlcXVpcmUoJ2Jyb3dzZXJpZnktcnNhJylcbnZhciBjdXJ2ZXMgPSByZXF1aXJlKCcuL2N1cnZlcycpXG52YXIgZWxsaXB0aWMgPSByZXF1aXJlKCdlbGxpcHRpYycpXG52YXIgcGFyc2VLZXlzID0gcmVxdWlyZSgncGFyc2UtYXNuMScpXG5cbnZhciBCTiA9IHJlcXVpcmUoJ2JuLmpzJylcbnZhciBFQyA9IGVsbGlwdGljLmVjXG5cbmZ1bmN0aW9uIHNpZ24gKGhhc2gsIGtleSwgaGFzaFR5cGUsIHNpZ25UeXBlKSB7XG4gIHZhciBwcml2ID0gcGFyc2VLZXlzKGtleSlcbiAgaWYgKHByaXYuY3VydmUpIHtcbiAgICBpZiAoc2lnblR5cGUgIT09ICdlY2RzYScpIHRocm93IG5ldyBFcnJvcignd3JvbmcgcHJpdmF0ZSBrZXkgdHlwZScpXG5cbiAgICByZXR1cm4gZWNTaWduKGhhc2gsIHByaXYpXG4gIH0gZWxzZSBpZiAocHJpdi50eXBlID09PSAnZHNhJykge1xuICAgIGlmIChzaWduVHlwZSAhPT0gJ2RzYScpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignd3JvbmcgcHJpdmF0ZSBrZXkgdHlwZScpXG4gICAgfVxuICAgIHJldHVybiBkc2FTaWduKGhhc2gsIHByaXYsIGhhc2hUeXBlKVxuICB9IGVsc2Uge1xuICAgIGlmIChzaWduVHlwZSAhPT0gJ3JzYScpIHRocm93IG5ldyBFcnJvcignd3JvbmcgcHJpdmF0ZSBrZXkgdHlwZScpXG4gIH1cblxuICB2YXIgbGVuID0gcHJpdi5tb2R1bHVzLmJ5dGVMZW5ndGgoKVxuICB2YXIgcGFkID0gWyAwLCAxIF1cbiAgd2hpbGUgKGhhc2gubGVuZ3RoICsgcGFkLmxlbmd0aCArIDEgPCBsZW4pIHtcbiAgICBwYWQucHVzaCgweGZmKVxuICB9XG4gIHBhZC5wdXNoKDB4MDApXG4gIHZhciBpID0gLTFcbiAgd2hpbGUgKCsraSA8IGhhc2gubGVuZ3RoKSB7XG4gICAgcGFkLnB1c2goaGFzaFtpXSlcbiAgfVxuXG4gIHZhciBvdXQgPSBjcnQocGFkLCBwcml2KVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIGVjU2lnbiAoaGFzaCwgcHJpdikge1xuICB2YXIgY3VydmVJZCA9IGN1cnZlc1twcml2LmN1cnZlLmpvaW4oJy4nKV1cbiAgaWYgKCFjdXJ2ZUlkKSB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gY3VydmUgJyArIHByaXYuY3VydmUuam9pbignLicpKVxuXG4gIHZhciBjdXJ2ZSA9IG5ldyBFQyhjdXJ2ZUlkKVxuICB2YXIga2V5ID0gY3VydmUuZ2VuS2V5UGFpcigpXG5cbiAga2V5Ll9pbXBvcnRQcml2YXRlKHByaXYucHJpdmF0ZUtleSlcbiAgdmFyIG91dCA9IGtleS5zaWduKGhhc2gpXG5cbiAgcmV0dXJuIG5ldyBCdWZmZXIob3V0LnRvREVSKCkpXG59XG5cbmZ1bmN0aW9uIGRzYVNpZ24gKGhhc2gsIHByaXYsIGFsZ28pIHtcbiAgdmFyIHggPSBwcml2LnBhcmFtcy5wcml2X2tleVxuICB2YXIgcCA9IHByaXYucGFyYW1zLnBcbiAgdmFyIHEgPSBwcml2LnBhcmFtcy5xXG4gIHZhciBnID0gcHJpdi5wYXJhbXMuZ1xuICB2YXIgciA9IG5ldyBCTigwKVxuICB2YXIga1xuICB2YXIgSCA9IGJpdHMyaW50KGhhc2gsIHEpLm1vZChxKVxuICB2YXIgcyA9IGZhbHNlXG4gIHZhciBrdiA9IGdldEtleSh4LCBxLCBoYXNoLCBhbGdvKVxuICB3aGlsZSAocyA9PT0gZmFsc2UpIHtcbiAgICBrID0gbWFrZUtleShxLCBrdiwgYWxnbylcbiAgICByID0gbWFrZVIoZywgaywgcCwgcSlcbiAgICBzID0gay5pbnZtKHEpLmltdWwoSC5hZGQoeC5tdWwocikpKS5tb2QocSlcbiAgICBpZiAoIXMuY21wbigwKSkge1xuICAgICAgcyA9IGZhbHNlXG4gICAgICByID0gbmV3IEJOKDApXG4gICAgfVxuICB9XG4gIHJldHVybiB0b0RFUihyLCBzKVxufVxuXG5mdW5jdGlvbiB0b0RFUiAociwgcykge1xuICByID0gci50b0FycmF5KClcbiAgcyA9IHMudG9BcnJheSgpXG5cbiAgLy8gUGFkIHZhbHVlc1xuICBpZiAoclswXSAmIDB4ODApIHtcbiAgICByID0gWyAwIF0uY29uY2F0KHIpXG4gIH1cbiAgLy8gUGFkIHZhbHVlc1xuICBpZiAoc1swXSAmIDB4ODApIHtcbiAgICBzID0gWzBdLmNvbmNhdChzKVxuICB9XG5cbiAgdmFyIHRvdGFsID0gci5sZW5ndGggKyBzLmxlbmd0aCArIDRcbiAgdmFyIHJlcyA9IFsgMHgzMCwgdG90YWwsIDB4MDIsIHIubGVuZ3RoIF1cbiAgcmVzID0gcmVzLmNvbmNhdChyLCBbIDB4MDIsIHMubGVuZ3RoIF0sIHMpXG4gIHJldHVybiBuZXcgQnVmZmVyKHJlcylcbn1cblxuZnVuY3Rpb24gZ2V0S2V5ICh4LCBxLCBoYXNoLCBhbGdvKSB7XG4gIHggPSBuZXcgQnVmZmVyKHgudG9BcnJheSgpKVxuICBpZiAoeC5sZW5ndGggPCBxLmJ5dGVMZW5ndGgoKSkge1xuICAgIHZhciB6ZXJvcyA9IG5ldyBCdWZmZXIocS5ieXRlTGVuZ3RoKCkgLSB4Lmxlbmd0aClcbiAgICB6ZXJvcy5maWxsKDApXG4gICAgeCA9IEJ1ZmZlci5jb25jYXQoW3plcm9zLCB4XSlcbiAgfVxuICB2YXIgaGxlbiA9IGhhc2gubGVuZ3RoXG4gIHZhciBoYml0cyA9IGJpdHMyb2N0ZXRzKGhhc2gsIHEpXG4gIHZhciB2ID0gbmV3IEJ1ZmZlcihobGVuKVxuICB2LmZpbGwoMSlcbiAgdmFyIGsgPSBuZXcgQnVmZmVyKGhsZW4pXG4gIGsuZmlsbCgwKVxuICBrID0gY3JlYXRlSG1hYyhhbGdvLCBrKVxuICAgIC51cGRhdGUodilcbiAgICAudXBkYXRlKG5ldyBCdWZmZXIoWzBdKSlcbiAgICAudXBkYXRlKHgpXG4gICAgLnVwZGF0ZShoYml0cylcbiAgICAuZGlnZXN0KClcbiAgdiA9IGNyZWF0ZUhtYWMoYWxnbywgaylcbiAgICAudXBkYXRlKHYpXG4gICAgLmRpZ2VzdCgpXG4gIGsgPSBjcmVhdGVIbWFjKGFsZ28sIGspXG4gICAgLnVwZGF0ZSh2KVxuICAgIC51cGRhdGUobmV3IEJ1ZmZlcihbMV0pKVxuICAgIC51cGRhdGUoeClcbiAgICAudXBkYXRlKGhiaXRzKVxuICAgIC5kaWdlc3QoKVxuICB2ID0gY3JlYXRlSG1hYyhhbGdvLCBrKVxuICAgIC51cGRhdGUodilcbiAgICAuZGlnZXN0KClcbiAgcmV0dXJuIHtcbiAgICBrOiBrLFxuICAgIHY6IHZcbiAgfVxufVxuXG5mdW5jdGlvbiBiaXRzMmludCAob2JpdHMsIHEpIHtcbiAgdmFyIGJpdHMgPSBuZXcgQk4ob2JpdHMpXG4gIHZhciBzaGlmdCA9IChvYml0cy5sZW5ndGggPDwgMykgLSBxLmJpdExlbmd0aCgpXG4gIGlmIChzaGlmdCA+IDApIHtcbiAgICBiaXRzLmlzaHJuKHNoaWZ0KVxuICB9XG4gIHJldHVybiBiaXRzXG59XG5cbmZ1bmN0aW9uIGJpdHMyb2N0ZXRzIChiaXRzLCBxKSB7XG4gIGJpdHMgPSBiaXRzMmludChiaXRzLCBxKVxuICBiaXRzID0gYml0cy5tb2QocSlcbiAgdmFyIG91dCA9IG5ldyBCdWZmZXIoYml0cy50b0FycmF5KCkpXG4gIGlmIChvdXQubGVuZ3RoIDwgcS5ieXRlTGVuZ3RoKCkpIHtcbiAgICB2YXIgemVyb3MgPSBuZXcgQnVmZmVyKHEuYnl0ZUxlbmd0aCgpIC0gb3V0Lmxlbmd0aClcbiAgICB6ZXJvcy5maWxsKDApXG4gICAgb3V0ID0gQnVmZmVyLmNvbmNhdChbemVyb3MsIG91dF0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiBtYWtlS2V5IChxLCBrdiwgYWxnbykge1xuICB2YXIgdCwga1xuXG4gIGRvIHtcbiAgICB0ID0gbmV3IEJ1ZmZlcignJylcblxuICAgIHdoaWxlICh0Lmxlbmd0aCAqIDggPCBxLmJpdExlbmd0aCgpKSB7XG4gICAgICBrdi52ID0gY3JlYXRlSG1hYyhhbGdvLCBrdi5rKVxuICAgICAgICAudXBkYXRlKGt2LnYpXG4gICAgICAgIC5kaWdlc3QoKVxuICAgICAgdCA9IEJ1ZmZlci5jb25jYXQoW3QsIGt2LnZdKVxuICAgIH1cblxuICAgIGsgPSBiaXRzMmludCh0LCBxKVxuICAgIGt2LmsgPSBjcmVhdGVIbWFjKGFsZ28sIGt2LmspXG4gICAgICAudXBkYXRlKGt2LnYpXG4gICAgICAudXBkYXRlKG5ldyBCdWZmZXIoWzBdKSlcbiAgICAgIC5kaWdlc3QoKVxuICAgIGt2LnYgPSBjcmVhdGVIbWFjKGFsZ28sIGt2LmspXG4gICAgICAudXBkYXRlKGt2LnYpXG4gICAgICAuZGlnZXN0KClcbiAgfSB3aGlsZSAoay5jbXAocSkgIT09IC0xKVxuXG4gIHJldHVybiBrXG59XG5cbmZ1bmN0aW9uIG1ha2VSIChnLCBrLCBwLCBxKSB7XG4gIHJldHVybiBnLnRvUmVkKEJOLm1vbnQocCkpLnJlZFBvdyhrKS5mcm9tUmVkKCkubW9kKHEpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2lnblxubW9kdWxlLmV4cG9ydHMuZ2V0S2V5ID0gZ2V0S2V5XG5tb2R1bGUuZXhwb3J0cy5tYWtlS2V5ID0gbWFrZUtleVxuIiwiLy8gbXVjaCBvZiB0aGlzIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9pbmR1dG55L3NlbGYtc2lnbmVkL2Jsb2IvZ2gtcGFnZXMvbGliL3JzYS5qc1xudmFyIGN1cnZlcyA9IHJlcXVpcmUoJy4vY3VydmVzJylcbnZhciBlbGxpcHRpYyA9IHJlcXVpcmUoJ2VsbGlwdGljJylcbnZhciBwYXJzZUtleXMgPSByZXF1aXJlKCdwYXJzZS1hc24xJylcblxudmFyIEJOID0gcmVxdWlyZSgnYm4uanMnKVxudmFyIEVDID0gZWxsaXB0aWMuZWNcblxuZnVuY3Rpb24gdmVyaWZ5IChzaWcsIGhhc2gsIGtleSwgc2lnblR5cGUpIHtcbiAgdmFyIHB1YiA9IHBhcnNlS2V5cyhrZXkpXG4gIGlmIChwdWIudHlwZSA9PT0gJ2VjJykge1xuICAgIGlmIChzaWduVHlwZSAhPT0gJ2VjZHNhJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd3cm9uZyBwdWJsaWMga2V5IHR5cGUnKVxuICAgIH1cbiAgICByZXR1cm4gZWNWZXJpZnkoc2lnLCBoYXNoLCBwdWIpXG4gIH0gZWxzZSBpZiAocHViLnR5cGUgPT09ICdkc2EnKSB7XG4gICAgaWYgKHNpZ25UeXBlICE9PSAnZHNhJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd3cm9uZyBwdWJsaWMga2V5IHR5cGUnKVxuICAgIH1cbiAgICByZXR1cm4gZHNhVmVyaWZ5KHNpZywgaGFzaCwgcHViKVxuICB9IGVsc2Uge1xuICAgIGlmIChzaWduVHlwZSAhPT0gJ3JzYScpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignd3JvbmcgcHVibGljIGtleSB0eXBlJylcbiAgICB9XG4gIH1cbiAgdmFyIGxlbiA9IHB1Yi5tb2R1bHVzLmJ5dGVMZW5ndGgoKVxuICB2YXIgcGFkID0gWyAxIF1cbiAgdmFyIHBhZE51bSA9IDBcbiAgd2hpbGUgKGhhc2gubGVuZ3RoICsgcGFkLmxlbmd0aCArIDIgPCBsZW4pIHtcbiAgICBwYWQucHVzaCgweGZmKVxuICAgIHBhZE51bSsrXG4gIH1cbiAgcGFkLnB1c2goMHgwMClcbiAgdmFyIGkgPSAtMVxuICB3aGlsZSAoKytpIDwgaGFzaC5sZW5ndGgpIHtcbiAgICBwYWQucHVzaChoYXNoW2ldKVxuICB9XG4gIHBhZCA9IG5ldyBCdWZmZXIocGFkKVxuICB2YXIgcmVkID0gQk4ubW9udChwdWIubW9kdWx1cylcbiAgc2lnID0gbmV3IEJOKHNpZykudG9SZWQocmVkKVxuXG4gIHNpZyA9IHNpZy5yZWRQb3cobmV3IEJOKHB1Yi5wdWJsaWNFeHBvbmVudCkpXG5cbiAgc2lnID0gbmV3IEJ1ZmZlcihzaWcuZnJvbVJlZCgpLnRvQXJyYXkoKSlcbiAgdmFyIG91dCA9IDBcbiAgaWYgKHBhZE51bSA8IDgpIHtcbiAgICBvdXQgPSAxXG4gIH1cbiAgbGVuID0gTWF0aC5taW4oc2lnLmxlbmd0aCwgcGFkLmxlbmd0aClcbiAgaWYgKHNpZy5sZW5ndGggIT09IHBhZC5sZW5ndGgpIHtcbiAgICBvdXQgPSAxXG4gIH1cblxuICBpID0gLTFcbiAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgIG91dCB8PSAoc2lnW2ldIF4gcGFkW2ldKVxuICB9XG4gIHJldHVybiBvdXQgPT09IDBcbn1cblxuZnVuY3Rpb24gZWNWZXJpZnkgKHNpZywgaGFzaCwgcHViKSB7XG4gIHZhciBjdXJ2ZUlkID0gY3VydmVzW3B1Yi5kYXRhLmFsZ29yaXRobS5jdXJ2ZS5qb2luKCcuJyldXG4gIGlmICghY3VydmVJZCkgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGN1cnZlICcgKyBwdWIuZGF0YS5hbGdvcml0aG0uY3VydmUuam9pbignLicpKVxuXG4gIHZhciBjdXJ2ZSA9IG5ldyBFQyhjdXJ2ZUlkKVxuICB2YXIgcHVia2V5ID0gcHViLmRhdGEuc3ViamVjdFByaXZhdGVLZXkuZGF0YVxuXG4gIHJldHVybiBjdXJ2ZS52ZXJpZnkoaGFzaCwgc2lnLCBwdWJrZXkpXG59XG5cbmZ1bmN0aW9uIGRzYVZlcmlmeSAoc2lnLCBoYXNoLCBwdWIpIHtcbiAgdmFyIHAgPSBwdWIuZGF0YS5wXG4gIHZhciBxID0gcHViLmRhdGEucVxuICB2YXIgZyA9IHB1Yi5kYXRhLmdcbiAgdmFyIHkgPSBwdWIuZGF0YS5wdWJfa2V5XG4gIHZhciB1bnBhY2tlZCA9IHBhcnNlS2V5cy5zaWduYXR1cmUuZGVjb2RlKHNpZywgJ2RlcicpXG4gIHZhciBzID0gdW5wYWNrZWQuc1xuICB2YXIgciA9IHVucGFja2VkLnJcbiAgY2hlY2tWYWx1ZShzLCBxKVxuICBjaGVja1ZhbHVlKHIsIHEpXG4gIHZhciBtb250cCA9IEJOLm1vbnQocClcbiAgdmFyIHcgPSBzLmludm0ocSlcbiAgdmFyIHYgPSBnLnRvUmVkKG1vbnRwKVxuICAgIC5yZWRQb3cobmV3IEJOKGhhc2gpLm11bCh3KS5tb2QocSkpXG4gICAgLmZyb21SZWQoKVxuICAgIC5tdWwoXG4gICAgICB5LnRvUmVkKG1vbnRwKVxuICAgICAgICAucmVkUG93KHIubXVsKHcpLm1vZChxKSlcbiAgICAgICAgLmZyb21SZWQoKVxuICApLm1vZChwKS5tb2QocSlcbiAgcmV0dXJuICF2LmNtcChyKVxufVxuXG5mdW5jdGlvbiBjaGVja1ZhbHVlIChiLCBxKSB7XG4gIGlmIChiLmNtcG4oMCkgPD0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBzaWcnKVxuICB9XG4gIGlmIChiLmNtcChxKSA+PSBxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHNpZycpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB2ZXJpZnlcbiIsInZhciBlbGxpcHRpYyA9IHJlcXVpcmUoJ2VsbGlwdGljJyk7XG52YXIgQk4gPSByZXF1aXJlKCdibi5qcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNyZWF0ZUVDREgoY3VydmUpIHtcblx0cmV0dXJuIG5ldyBFQ0RIKGN1cnZlKTtcbn07XG5cbnZhciBhbGlhc2VzID0ge1xuXHRzZWNwMjU2azE6IHtcblx0XHRuYW1lOiAnc2VjcDI1NmsxJyxcblx0XHRieXRlTGVuZ3RoOiAzMlxuXHR9LFxuXHRzZWNwMjI0cjE6IHtcblx0XHRuYW1lOiAncDIyNCcsXG5cdFx0Ynl0ZUxlbmd0aDogMjhcblx0fSxcblx0cHJpbWUyNTZ2MToge1xuXHRcdG5hbWU6ICdwMjU2Jyxcblx0XHRieXRlTGVuZ3RoOiAzMlxuXHR9LFxuXHRwcmltZTE5MnYxOiB7XG5cdFx0bmFtZTogJ3AxOTInLFxuXHRcdGJ5dGVMZW5ndGg6IDI0XG5cdH0sXG5cdGVkMjU1MTk6IHtcblx0XHRuYW1lOiAnZWQyNTUxOScsXG5cdFx0Ynl0ZUxlbmd0aDogMzJcblx0fSxcblx0c2VjcDM4NHIxOiB7XG5cdFx0bmFtZTogJ3AzODQnLFxuXHRcdGJ5dGVMZW5ndGg6IDQ4XG5cdH0sXG5cdHNlY3A1MjFyMToge1xuXHRcdG5hbWU6ICdwNTIxJyxcblx0XHRieXRlTGVuZ3RoOiA2NlxuXHR9XG59O1xuXG5hbGlhc2VzLnAyMjQgPSBhbGlhc2VzLnNlY3AyMjRyMTtcbmFsaWFzZXMucDI1NiA9IGFsaWFzZXMuc2VjcDI1NnIxID0gYWxpYXNlcy5wcmltZTI1NnYxO1xuYWxpYXNlcy5wMTkyID0gYWxpYXNlcy5zZWNwMTkycjEgPSBhbGlhc2VzLnByaW1lMTkydjE7XG5hbGlhc2VzLnAzODQgPSBhbGlhc2VzLnNlY3AzODRyMTtcbmFsaWFzZXMucDUyMSA9IGFsaWFzZXMuc2VjcDUyMXIxO1xuXG5mdW5jdGlvbiBFQ0RIKGN1cnZlKSB7XG5cdHRoaXMuY3VydmVUeXBlID0gYWxpYXNlc1tjdXJ2ZV07XG5cdGlmICghdGhpcy5jdXJ2ZVR5cGUgKSB7XG5cdFx0dGhpcy5jdXJ2ZVR5cGUgPSB7XG5cdFx0XHRuYW1lOiBjdXJ2ZVxuXHRcdH07XG5cdH1cblx0dGhpcy5jdXJ2ZSA9IG5ldyBlbGxpcHRpYy5lYyh0aGlzLmN1cnZlVHlwZS5uYW1lKTtcblx0dGhpcy5rZXlzID0gdm9pZCAwO1xufVxuXG5FQ0RILnByb3RvdHlwZS5nZW5lcmF0ZUtleXMgPSBmdW5jdGlvbiAoZW5jLCBmb3JtYXQpIHtcblx0dGhpcy5rZXlzID0gdGhpcy5jdXJ2ZS5nZW5LZXlQYWlyKCk7XG5cdHJldHVybiB0aGlzLmdldFB1YmxpY0tleShlbmMsIGZvcm1hdCk7XG59O1xuXG5FQ0RILnByb3RvdHlwZS5jb21wdXRlU2VjcmV0ID0gZnVuY3Rpb24gKG90aGVyLCBpbmVuYywgZW5jKSB7XG5cdGluZW5jID0gaW5lbmMgfHwgJ3V0ZjgnO1xuXHRpZiAoIUJ1ZmZlci5pc0J1ZmZlcihvdGhlcikpIHtcblx0XHRvdGhlciA9IG5ldyBCdWZmZXIob3RoZXIsIGluZW5jKTtcblx0fVxuXHR2YXIgb3RoZXJQdWIgPSB0aGlzLmN1cnZlLmtleUZyb21QdWJsaWMob3RoZXIpLmdldFB1YmxpYygpO1xuXHR2YXIgb3V0ID0gb3RoZXJQdWIubXVsKHRoaXMua2V5cy5nZXRQcml2YXRlKCkpLmdldFgoKTtcblx0cmV0dXJuIGZvcm1hdFJldHVyblZhbHVlKG91dCwgZW5jLCB0aGlzLmN1cnZlVHlwZS5ieXRlTGVuZ3RoKTtcbn07XG5cbkVDREgucHJvdG90eXBlLmdldFB1YmxpY0tleSA9IGZ1bmN0aW9uIChlbmMsIGZvcm1hdCkge1xuXHR2YXIga2V5ID0gdGhpcy5rZXlzLmdldFB1YmxpYyhmb3JtYXQgPT09ICdjb21wcmVzc2VkJywgdHJ1ZSk7XG5cdGlmIChmb3JtYXQgPT09ICdoeWJyaWQnKSB7XG5cdFx0aWYgKGtleVtrZXkubGVuZ3RoIC0gMV0gJSAyKSB7XG5cdFx0XHRrZXlbMF0gPSA3O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRrZXkgWzBdID0gNjtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGZvcm1hdFJldHVyblZhbHVlKGtleSwgZW5jKTtcbn07XG5cbkVDREgucHJvdG90eXBlLmdldFByaXZhdGVLZXkgPSBmdW5jdGlvbiAoZW5jKSB7XG5cdHJldHVybiBmb3JtYXRSZXR1cm5WYWx1ZSh0aGlzLmtleXMuZ2V0UHJpdmF0ZSgpLCBlbmMpO1xufTtcblxuRUNESC5wcm90b3R5cGUuc2V0UHVibGljS2V5ID0gZnVuY3Rpb24gKHB1YiwgZW5jKSB7XG5cdGVuYyA9IGVuYyB8fCAndXRmOCc7XG5cdGlmICghQnVmZmVyLmlzQnVmZmVyKHB1YikpIHtcblx0XHRwdWIgPSBuZXcgQnVmZmVyKHB1YiwgZW5jKTtcblx0fVxuXHR0aGlzLmtleXMuX2ltcG9ydFB1YmxpYyhwdWIpO1xuXHRyZXR1cm4gdGhpcztcbn07XG5cbkVDREgucHJvdG90eXBlLnNldFByaXZhdGVLZXkgPSBmdW5jdGlvbiAocHJpdiwgZW5jKSB7XG5cdGVuYyA9IGVuYyB8fCAndXRmOCc7XG5cdGlmICghQnVmZmVyLmlzQnVmZmVyKHByaXYpKSB7XG5cdFx0cHJpdiA9IG5ldyBCdWZmZXIocHJpdiwgZW5jKTtcblx0fVxuXHR2YXIgX3ByaXYgPSBuZXcgQk4ocHJpdik7XG5cdF9wcml2ID0gX3ByaXYudG9TdHJpbmcoMTYpO1xuXHR0aGlzLmtleXMuX2ltcG9ydFByaXZhdGUoX3ByaXYpO1xuXHRyZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGZvcm1hdFJldHVyblZhbHVlKGJuLCBlbmMsIGxlbikge1xuXHRpZiAoIUFycmF5LmlzQXJyYXkoYm4pKSB7XG5cdFx0Ym4gPSBibi50b0FycmF5KCk7XG5cdH1cblx0dmFyIGJ1ZiA9IG5ldyBCdWZmZXIoYm4pO1xuXHRpZiAobGVuICYmIGJ1Zi5sZW5ndGggPCBsZW4pIHtcblx0XHR2YXIgemVyb3MgPSBuZXcgQnVmZmVyKGxlbiAtIGJ1Zi5sZW5ndGgpO1xuXHRcdHplcm9zLmZpbGwoMCk7XG5cdFx0YnVmID0gQnVmZmVyLmNvbmNhdChbemVyb3MsIGJ1Zl0pO1xuXHR9XG5cdGlmICghZW5jKSB7XG5cdFx0cmV0dXJuIGJ1Zjtcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gYnVmLnRvU3RyaW5nKGVuYyk7XG5cdH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBtZDUgPSByZXF1aXJlKCcuL21kNScpXG52YXIgcm1kMTYwID0gcmVxdWlyZSgncmlwZW1kMTYwJylcbnZhciBzaGEgPSByZXF1aXJlKCdzaGEuanMnKVxuXG52YXIgQmFzZSA9IHJlcXVpcmUoJ2NpcGhlci1iYXNlJylcblxuZnVuY3Rpb24gSGFzaE5vQ29uc3RydWN0b3IoaGFzaCkge1xuICBCYXNlLmNhbGwodGhpcywgJ2RpZ2VzdCcpXG5cbiAgdGhpcy5faGFzaCA9IGhhc2hcbiAgdGhpcy5idWZmZXJzID0gW11cbn1cblxuaW5oZXJpdHMoSGFzaE5vQ29uc3RydWN0b3IsIEJhc2UpXG5cbkhhc2hOb0NvbnN0cnVjdG9yLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgdGhpcy5idWZmZXJzLnB1c2goZGF0YSlcbn1cblxuSGFzaE5vQ29uc3RydWN0b3IucHJvdG90eXBlLl9maW5hbCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGJ1ZiA9IEJ1ZmZlci5jb25jYXQodGhpcy5idWZmZXJzKVxuICB2YXIgciA9IHRoaXMuX2hhc2goYnVmKVxuICB0aGlzLmJ1ZmZlcnMgPSBudWxsXG5cbiAgcmV0dXJuIHJcbn1cblxuZnVuY3Rpb24gSGFzaChoYXNoKSB7XG4gIEJhc2UuY2FsbCh0aGlzLCAnZGlnZXN0JylcblxuICB0aGlzLl9oYXNoID0gaGFzaFxufVxuXG5pbmhlcml0cyhIYXNoLCBCYXNlKVxuXG5IYXNoLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgdGhpcy5faGFzaC51cGRhdGUoZGF0YSlcbn1cblxuSGFzaC5wcm90b3R5cGUuX2ZpbmFsID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5faGFzaC5kaWdlc3QoKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNyZWF0ZUhhc2ggKGFsZykge1xuICBhbGcgPSBhbGcudG9Mb3dlckNhc2UoKVxuICBpZiAoJ21kNScgPT09IGFsZykgcmV0dXJuIG5ldyBIYXNoTm9Db25zdHJ1Y3RvcihtZDUpXG4gIGlmICgncm1kMTYwJyA9PT0gYWxnIHx8ICdyaXBlbWQxNjAnID09PSBhbGcpIHJldHVybiBuZXcgSGFzaE5vQ29uc3RydWN0b3Iocm1kMTYwKVxuXG4gIHJldHVybiBuZXcgSGFzaChzaGEoYWxnKSlcbn1cbiIsIid1c2Ugc3RyaWN0JztcbnZhciBpbnRTaXplID0gNDtcbnZhciB6ZXJvQnVmZmVyID0gbmV3IEJ1ZmZlcihpbnRTaXplKTsgemVyb0J1ZmZlci5maWxsKDApO1xudmFyIGNocnN6ID0gODtcblxuZnVuY3Rpb24gdG9BcnJheShidWYsIGJpZ0VuZGlhbikge1xuICBpZiAoKGJ1Zi5sZW5ndGggJSBpbnRTaXplKSAhPT0gMCkge1xuICAgIHZhciBsZW4gPSBidWYubGVuZ3RoICsgKGludFNpemUgLSAoYnVmLmxlbmd0aCAlIGludFNpemUpKTtcbiAgICBidWYgPSBCdWZmZXIuY29uY2F0KFtidWYsIHplcm9CdWZmZXJdLCBsZW4pO1xuICB9XG5cbiAgdmFyIGFyciA9IFtdO1xuICB2YXIgZm4gPSBiaWdFbmRpYW4gPyBidWYucmVhZEludDMyQkUgOiBidWYucmVhZEludDMyTEU7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmLmxlbmd0aDsgaSArPSBpbnRTaXplKSB7XG4gICAgYXJyLnB1c2goZm4uY2FsbChidWYsIGkpKTtcbiAgfVxuICByZXR1cm4gYXJyO1xufVxuXG5mdW5jdGlvbiB0b0J1ZmZlcihhcnIsIHNpemUsIGJpZ0VuZGlhbikge1xuICB2YXIgYnVmID0gbmV3IEJ1ZmZlcihzaXplKTtcbiAgdmFyIGZuID0gYmlnRW5kaWFuID8gYnVmLndyaXRlSW50MzJCRSA6IGJ1Zi53cml0ZUludDMyTEU7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgZm4uY2FsbChidWYsIGFycltpXSwgaSAqIDQsIHRydWUpO1xuICB9XG4gIHJldHVybiBidWY7XG59XG5cbmZ1bmN0aW9uIGhhc2goYnVmLCBmbiwgaGFzaFNpemUsIGJpZ0VuZGlhbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSBidWYgPSBuZXcgQnVmZmVyKGJ1Zik7XG4gIHZhciBhcnIgPSBmbih0b0FycmF5KGJ1ZiwgYmlnRW5kaWFuKSwgYnVmLmxlbmd0aCAqIGNocnN6KTtcbiAgcmV0dXJuIHRvQnVmZmVyKGFyciwgaGFzaFNpemUsIGJpZ0VuZGlhbik7XG59XG5leHBvcnRzLmhhc2ggPSBoYXNoOyIsIid1c2Ugc3RyaWN0Jztcbi8qXG4gKiBBIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIFJTQSBEYXRhIFNlY3VyaXR5LCBJbmMuIE1ENSBNZXNzYWdlXG4gKiBEaWdlc3QgQWxnb3JpdGhtLCBhcyBkZWZpbmVkIGluIFJGQyAxMzIxLlxuICogVmVyc2lvbiAyLjEgQ29weXJpZ2h0IChDKSBQYXVsIEpvaG5zdG9uIDE5OTkgLSAyMDAyLlxuICogT3RoZXIgY29udHJpYnV0b3JzOiBHcmVnIEhvbHQsIEFuZHJldyBLZXBlcnQsIFlkbmFyLCBMb3N0aW5ldFxuICogRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIEJTRCBMaWNlbnNlXG4gKiBTZWUgaHR0cDovL3BhamhvbWUub3JnLnVrL2NyeXB0L21kNSBmb3IgbW9yZSBpbmZvLlxuICovXG5cbnZhciBoZWxwZXJzID0gcmVxdWlyZSgnLi9oZWxwZXJzJyk7XG5cbi8qXG4gKiBDYWxjdWxhdGUgdGhlIE1ENSBvZiBhbiBhcnJheSBvZiBsaXR0bGUtZW5kaWFuIHdvcmRzLCBhbmQgYSBiaXQgbGVuZ3RoXG4gKi9cbmZ1bmN0aW9uIGNvcmVfbWQ1KHgsIGxlbilcbntcbiAgLyogYXBwZW5kIHBhZGRpbmcgKi9cbiAgeFtsZW4gPj4gNV0gfD0gMHg4MCA8PCAoKGxlbikgJSAzMik7XG4gIHhbKCgobGVuICsgNjQpID4+PiA5KSA8PCA0KSArIDE0XSA9IGxlbjtcblxuICB2YXIgYSA9ICAxNzMyNTg0MTkzO1xuICB2YXIgYiA9IC0yNzE3MzM4Nzk7XG4gIHZhciBjID0gLTE3MzI1ODQxOTQ7XG4gIHZhciBkID0gIDI3MTczMzg3ODtcblxuICBmb3IodmFyIGkgPSAwOyBpIDwgeC5sZW5ndGg7IGkgKz0gMTYpXG4gIHtcbiAgICB2YXIgb2xkYSA9IGE7XG4gICAgdmFyIG9sZGIgPSBiO1xuICAgIHZhciBvbGRjID0gYztcbiAgICB2YXIgb2xkZCA9IGQ7XG5cbiAgICBhID0gbWQ1X2ZmKGEsIGIsIGMsIGQsIHhbaSsgMF0sIDcgLCAtNjgwODc2OTM2KTtcbiAgICBkID0gbWQ1X2ZmKGQsIGEsIGIsIGMsIHhbaSsgMV0sIDEyLCAtMzg5NTY0NTg2KTtcbiAgICBjID0gbWQ1X2ZmKGMsIGQsIGEsIGIsIHhbaSsgMl0sIDE3LCAgNjA2MTA1ODE5KTtcbiAgICBiID0gbWQ1X2ZmKGIsIGMsIGQsIGEsIHhbaSsgM10sIDIyLCAtMTA0NDUyNTMzMCk7XG4gICAgYSA9IG1kNV9mZihhLCBiLCBjLCBkLCB4W2krIDRdLCA3ICwgLTE3NjQxODg5Nyk7XG4gICAgZCA9IG1kNV9mZihkLCBhLCBiLCBjLCB4W2krIDVdLCAxMiwgIDEyMDAwODA0MjYpO1xuICAgIGMgPSBtZDVfZmYoYywgZCwgYSwgYiwgeFtpKyA2XSwgMTcsIC0xNDczMjMxMzQxKTtcbiAgICBiID0gbWQ1X2ZmKGIsIGMsIGQsIGEsIHhbaSsgN10sIDIyLCAtNDU3MDU5ODMpO1xuICAgIGEgPSBtZDVfZmYoYSwgYiwgYywgZCwgeFtpKyA4XSwgNyAsICAxNzcwMDM1NDE2KTtcbiAgICBkID0gbWQ1X2ZmKGQsIGEsIGIsIGMsIHhbaSsgOV0sIDEyLCAtMTk1ODQxNDQxNyk7XG4gICAgYyA9IG1kNV9mZihjLCBkLCBhLCBiLCB4W2krMTBdLCAxNywgLTQyMDYzKTtcbiAgICBiID0gbWQ1X2ZmKGIsIGMsIGQsIGEsIHhbaSsxMV0sIDIyLCAtMTk5MDQwNDE2Mik7XG4gICAgYSA9IG1kNV9mZihhLCBiLCBjLCBkLCB4W2krMTJdLCA3ICwgIDE4MDQ2MDM2ODIpO1xuICAgIGQgPSBtZDVfZmYoZCwgYSwgYiwgYywgeFtpKzEzXSwgMTIsIC00MDM0MTEwMSk7XG4gICAgYyA9IG1kNV9mZihjLCBkLCBhLCBiLCB4W2krMTRdLCAxNywgLTE1MDIwMDIyOTApO1xuICAgIGIgPSBtZDVfZmYoYiwgYywgZCwgYSwgeFtpKzE1XSwgMjIsICAxMjM2NTM1MzI5KTtcblxuICAgIGEgPSBtZDVfZ2coYSwgYiwgYywgZCwgeFtpKyAxXSwgNSAsIC0xNjU3OTY1MTApO1xuICAgIGQgPSBtZDVfZ2coZCwgYSwgYiwgYywgeFtpKyA2XSwgOSAsIC0xMDY5NTAxNjMyKTtcbiAgICBjID0gbWQ1X2dnKGMsIGQsIGEsIGIsIHhbaSsxMV0sIDE0LCAgNjQzNzE3NzEzKTtcbiAgICBiID0gbWQ1X2dnKGIsIGMsIGQsIGEsIHhbaSsgMF0sIDIwLCAtMzczODk3MzAyKTtcbiAgICBhID0gbWQ1X2dnKGEsIGIsIGMsIGQsIHhbaSsgNV0sIDUgLCAtNzAxNTU4NjkxKTtcbiAgICBkID0gbWQ1X2dnKGQsIGEsIGIsIGMsIHhbaSsxMF0sIDkgLCAgMzgwMTYwODMpO1xuICAgIGMgPSBtZDVfZ2coYywgZCwgYSwgYiwgeFtpKzE1XSwgMTQsIC02NjA0NzgzMzUpO1xuICAgIGIgPSBtZDVfZ2coYiwgYywgZCwgYSwgeFtpKyA0XSwgMjAsIC00MDU1Mzc4NDgpO1xuICAgIGEgPSBtZDVfZ2coYSwgYiwgYywgZCwgeFtpKyA5XSwgNSAsICA1Njg0NDY0MzgpO1xuICAgIGQgPSBtZDVfZ2coZCwgYSwgYiwgYywgeFtpKzE0XSwgOSAsIC0xMDE5ODAzNjkwKTtcbiAgICBjID0gbWQ1X2dnKGMsIGQsIGEsIGIsIHhbaSsgM10sIDE0LCAtMTg3MzYzOTYxKTtcbiAgICBiID0gbWQ1X2dnKGIsIGMsIGQsIGEsIHhbaSsgOF0sIDIwLCAgMTE2MzUzMTUwMSk7XG4gICAgYSA9IG1kNV9nZyhhLCBiLCBjLCBkLCB4W2krMTNdLCA1ICwgLTE0NDQ2ODE0NjcpO1xuICAgIGQgPSBtZDVfZ2coZCwgYSwgYiwgYywgeFtpKyAyXSwgOSAsIC01MTQwMzc4NCk7XG4gICAgYyA9IG1kNV9nZyhjLCBkLCBhLCBiLCB4W2krIDddLCAxNCwgIDE3MzUzMjg0NzMpO1xuICAgIGIgPSBtZDVfZ2coYiwgYywgZCwgYSwgeFtpKzEyXSwgMjAsIC0xOTI2NjA3NzM0KTtcblxuICAgIGEgPSBtZDVfaGgoYSwgYiwgYywgZCwgeFtpKyA1XSwgNCAsIC0zNzg1NTgpO1xuICAgIGQgPSBtZDVfaGgoZCwgYSwgYiwgYywgeFtpKyA4XSwgMTEsIC0yMDIyNTc0NDYzKTtcbiAgICBjID0gbWQ1X2hoKGMsIGQsIGEsIGIsIHhbaSsxMV0sIDE2LCAgMTgzOTAzMDU2Mik7XG4gICAgYiA9IG1kNV9oaChiLCBjLCBkLCBhLCB4W2krMTRdLCAyMywgLTM1MzA5NTU2KTtcbiAgICBhID0gbWQ1X2hoKGEsIGIsIGMsIGQsIHhbaSsgMV0sIDQgLCAtMTUzMDk5MjA2MCk7XG4gICAgZCA9IG1kNV9oaChkLCBhLCBiLCBjLCB4W2krIDRdLCAxMSwgIDEyNzI4OTMzNTMpO1xuICAgIGMgPSBtZDVfaGgoYywgZCwgYSwgYiwgeFtpKyA3XSwgMTYsIC0xNTU0OTc2MzIpO1xuICAgIGIgPSBtZDVfaGgoYiwgYywgZCwgYSwgeFtpKzEwXSwgMjMsIC0xMDk0NzMwNjQwKTtcbiAgICBhID0gbWQ1X2hoKGEsIGIsIGMsIGQsIHhbaSsxM10sIDQgLCAgNjgxMjc5MTc0KTtcbiAgICBkID0gbWQ1X2hoKGQsIGEsIGIsIGMsIHhbaSsgMF0sIDExLCAtMzU4NTM3MjIyKTtcbiAgICBjID0gbWQ1X2hoKGMsIGQsIGEsIGIsIHhbaSsgM10sIDE2LCAtNzIyNTIxOTc5KTtcbiAgICBiID0gbWQ1X2hoKGIsIGMsIGQsIGEsIHhbaSsgNl0sIDIzLCAgNzYwMjkxODkpO1xuICAgIGEgPSBtZDVfaGgoYSwgYiwgYywgZCwgeFtpKyA5XSwgNCAsIC02NDAzNjQ0ODcpO1xuICAgIGQgPSBtZDVfaGgoZCwgYSwgYiwgYywgeFtpKzEyXSwgMTEsIC00MjE4MTU4MzUpO1xuICAgIGMgPSBtZDVfaGgoYywgZCwgYSwgYiwgeFtpKzE1XSwgMTYsICA1MzA3NDI1MjApO1xuICAgIGIgPSBtZDVfaGgoYiwgYywgZCwgYSwgeFtpKyAyXSwgMjMsIC05OTUzMzg2NTEpO1xuXG4gICAgYSA9IG1kNV9paShhLCBiLCBjLCBkLCB4W2krIDBdLCA2ICwgLTE5ODYzMDg0NCk7XG4gICAgZCA9IG1kNV9paShkLCBhLCBiLCBjLCB4W2krIDddLCAxMCwgIDExMjY4OTE0MTUpO1xuICAgIGMgPSBtZDVfaWkoYywgZCwgYSwgYiwgeFtpKzE0XSwgMTUsIC0xNDE2MzU0OTA1KTtcbiAgICBiID0gbWQ1X2lpKGIsIGMsIGQsIGEsIHhbaSsgNV0sIDIxLCAtNTc0MzQwNTUpO1xuICAgIGEgPSBtZDVfaWkoYSwgYiwgYywgZCwgeFtpKzEyXSwgNiAsICAxNzAwNDg1NTcxKTtcbiAgICBkID0gbWQ1X2lpKGQsIGEsIGIsIGMsIHhbaSsgM10sIDEwLCAtMTg5NDk4NjYwNik7XG4gICAgYyA9IG1kNV9paShjLCBkLCBhLCBiLCB4W2krMTBdLCAxNSwgLTEwNTE1MjMpO1xuICAgIGIgPSBtZDVfaWkoYiwgYywgZCwgYSwgeFtpKyAxXSwgMjEsIC0yMDU0OTIyNzk5KTtcbiAgICBhID0gbWQ1X2lpKGEsIGIsIGMsIGQsIHhbaSsgOF0sIDYgLCAgMTg3MzMxMzM1OSk7XG4gICAgZCA9IG1kNV9paShkLCBhLCBiLCBjLCB4W2krMTVdLCAxMCwgLTMwNjExNzQ0KTtcbiAgICBjID0gbWQ1X2lpKGMsIGQsIGEsIGIsIHhbaSsgNl0sIDE1LCAtMTU2MDE5ODM4MCk7XG4gICAgYiA9IG1kNV9paShiLCBjLCBkLCBhLCB4W2krMTNdLCAyMSwgIDEzMDkxNTE2NDkpO1xuICAgIGEgPSBtZDVfaWkoYSwgYiwgYywgZCwgeFtpKyA0XSwgNiAsIC0xNDU1MjMwNzApO1xuICAgIGQgPSBtZDVfaWkoZCwgYSwgYiwgYywgeFtpKzExXSwgMTAsIC0xMTIwMjEwMzc5KTtcbiAgICBjID0gbWQ1X2lpKGMsIGQsIGEsIGIsIHhbaSsgMl0sIDE1LCAgNzE4Nzg3MjU5KTtcbiAgICBiID0gbWQ1X2lpKGIsIGMsIGQsIGEsIHhbaSsgOV0sIDIxLCAtMzQzNDg1NTUxKTtcblxuICAgIGEgPSBzYWZlX2FkZChhLCBvbGRhKTtcbiAgICBiID0gc2FmZV9hZGQoYiwgb2xkYik7XG4gICAgYyA9IHNhZmVfYWRkKGMsIG9sZGMpO1xuICAgIGQgPSBzYWZlX2FkZChkLCBvbGRkKTtcbiAgfVxuICByZXR1cm4gQXJyYXkoYSwgYiwgYywgZCk7XG5cbn1cblxuLypcbiAqIFRoZXNlIGZ1bmN0aW9ucyBpbXBsZW1lbnQgdGhlIGZvdXIgYmFzaWMgb3BlcmF0aW9ucyB0aGUgYWxnb3JpdGhtIHVzZXMuXG4gKi9cbmZ1bmN0aW9uIG1kNV9jbW4ocSwgYSwgYiwgeCwgcywgdClcbntcbiAgcmV0dXJuIHNhZmVfYWRkKGJpdF9yb2woc2FmZV9hZGQoc2FmZV9hZGQoYSwgcSksIHNhZmVfYWRkKHgsIHQpKSwgcyksYik7XG59XG5mdW5jdGlvbiBtZDVfZmYoYSwgYiwgYywgZCwgeCwgcywgdClcbntcbiAgcmV0dXJuIG1kNV9jbW4oKGIgJiBjKSB8ICgofmIpICYgZCksIGEsIGIsIHgsIHMsIHQpO1xufVxuZnVuY3Rpb24gbWQ1X2dnKGEsIGIsIGMsIGQsIHgsIHMsIHQpXG57XG4gIHJldHVybiBtZDVfY21uKChiICYgZCkgfCAoYyAmICh+ZCkpLCBhLCBiLCB4LCBzLCB0KTtcbn1cbmZ1bmN0aW9uIG1kNV9oaChhLCBiLCBjLCBkLCB4LCBzLCB0KVxue1xuICByZXR1cm4gbWQ1X2NtbihiIF4gYyBeIGQsIGEsIGIsIHgsIHMsIHQpO1xufVxuZnVuY3Rpb24gbWQ1X2lpKGEsIGIsIGMsIGQsIHgsIHMsIHQpXG57XG4gIHJldHVybiBtZDVfY21uKGMgXiAoYiB8ICh+ZCkpLCBhLCBiLCB4LCBzLCB0KTtcbn1cblxuLypcbiAqIEFkZCBpbnRlZ2Vycywgd3JhcHBpbmcgYXQgMl4zMi4gVGhpcyB1c2VzIDE2LWJpdCBvcGVyYXRpb25zIGludGVybmFsbHlcbiAqIHRvIHdvcmsgYXJvdW5kIGJ1Z3MgaW4gc29tZSBKUyBpbnRlcnByZXRlcnMuXG4gKi9cbmZ1bmN0aW9uIHNhZmVfYWRkKHgsIHkpXG57XG4gIHZhciBsc3cgPSAoeCAmIDB4RkZGRikgKyAoeSAmIDB4RkZGRik7XG4gIHZhciBtc3cgPSAoeCA+PiAxNikgKyAoeSA+PiAxNikgKyAobHN3ID4+IDE2KTtcbiAgcmV0dXJuIChtc3cgPDwgMTYpIHwgKGxzdyAmIDB4RkZGRik7XG59XG5cbi8qXG4gKiBCaXR3aXNlIHJvdGF0ZSBhIDMyLWJpdCBudW1iZXIgdG8gdGhlIGxlZnQuXG4gKi9cbmZ1bmN0aW9uIGJpdF9yb2wobnVtLCBjbnQpXG57XG4gIHJldHVybiAobnVtIDw8IGNudCkgfCAobnVtID4+PiAoMzIgLSBjbnQpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBtZDUoYnVmKSB7XG4gIHJldHVybiBoZWxwZXJzLmhhc2goYnVmLCBjb3JlX21kNSwgMTYpO1xufTsiLCJ2YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnc3RyZWFtJykuVHJhbnNmb3JtXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyJykuU3RyaW5nRGVjb2RlclxubW9kdWxlLmV4cG9ydHMgPSBDaXBoZXJCYXNlXG5pbmhlcml0cyhDaXBoZXJCYXNlLCBUcmFuc2Zvcm0pXG5mdW5jdGlvbiBDaXBoZXJCYXNlIChoYXNoTW9kZSkge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzKVxuICB0aGlzLmhhc2hNb2RlID0gdHlwZW9mIGhhc2hNb2RlID09PSAnc3RyaW5nJ1xuICBpZiAodGhpcy5oYXNoTW9kZSkge1xuICAgIHRoaXNbaGFzaE1vZGVdID0gdGhpcy5fZmluYWxPckRpZ2VzdFxuICB9IGVsc2Uge1xuICAgIHRoaXMuZmluYWwgPSB0aGlzLl9maW5hbE9yRGlnZXN0XG4gIH1cbiAgdGhpcy5fZGVjb2RlciA9IG51bGxcbiAgdGhpcy5fZW5jb2RpbmcgPSBudWxsXG59XG5DaXBoZXJCYXNlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGF0YSwgaW5wdXRFbmMsIG91dHB1dEVuYykge1xuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgZGF0YSA9IG5ldyBCdWZmZXIoZGF0YSwgaW5wdXRFbmMpXG4gIH1cbiAgdmFyIG91dERhdGEgPSB0aGlzLl91cGRhdGUoZGF0YSlcbiAgaWYgKHRoaXMuaGFzaE1vZGUpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG4gIGlmIChvdXRwdXRFbmMpIHtcbiAgICBvdXREYXRhID0gdGhpcy5fdG9TdHJpbmcob3V0RGF0YSwgb3V0cHV0RW5jKVxuICB9XG4gIHJldHVybiBvdXREYXRhXG59XG5cbkNpcGhlckJhc2UucHJvdG90eXBlLnNldEF1dG9QYWRkaW5nID0gZnVuY3Rpb24gKCkge31cblxuQ2lwaGVyQmFzZS5wcm90b3R5cGUuZ2V0QXV0aFRhZyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCd0cnlpbmcgdG8gZ2V0IGF1dGggdGFnIGluIHVuc3VwcG9ydGVkIHN0YXRlJylcbn1cblxuQ2lwaGVyQmFzZS5wcm90b3R5cGUuc2V0QXV0aFRhZyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCd0cnlpbmcgdG8gc2V0IGF1dGggdGFnIGluIHVuc3VwcG9ydGVkIHN0YXRlJylcbn1cblxuQ2lwaGVyQmFzZS5wcm90b3R5cGUuc2V0QUFEID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ3RyeWluZyB0byBzZXQgYWFkIGluIHVuc3VwcG9ydGVkIHN0YXRlJylcbn1cblxuQ2lwaGVyQmFzZS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChkYXRhLCBfLCBuZXh0KSB7XG4gIHZhciBlcnJcbiAgdHJ5IHtcbiAgICBpZiAodGhpcy5oYXNoTW9kZSkge1xuICAgICAgdGhpcy5fdXBkYXRlKGRhdGEpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucHVzaCh0aGlzLl91cGRhdGUoZGF0YSkpXG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgZXJyID0gZVxuICB9IGZpbmFsbHkge1xuICAgIG5leHQoZXJyKVxuICB9XG59XG5DaXBoZXJCYXNlLnByb3RvdHlwZS5fZmx1c2ggPSBmdW5jdGlvbiAoZG9uZSkge1xuICB2YXIgZXJyXG4gIHRyeSB7XG4gICAgdGhpcy5wdXNoKHRoaXMuX2ZpbmFsKCkpXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBlcnIgPSBlXG4gIH0gZmluYWxseSB7XG4gICAgZG9uZShlcnIpXG4gIH1cbn1cbkNpcGhlckJhc2UucHJvdG90eXBlLl9maW5hbE9yRGlnZXN0ID0gZnVuY3Rpb24gKG91dHB1dEVuYykge1xuICB2YXIgb3V0RGF0YSA9IHRoaXMuX2ZpbmFsKCkgfHwgbmV3IEJ1ZmZlcignJylcbiAgaWYgKG91dHB1dEVuYykge1xuICAgIG91dERhdGEgPSB0aGlzLl90b1N0cmluZyhvdXREYXRhLCBvdXRwdXRFbmMsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG91dERhdGFcbn1cblxuQ2lwaGVyQmFzZS5wcm90b3R5cGUuX3RvU3RyaW5nID0gZnVuY3Rpb24gKHZhbHVlLCBlbmMsIGZpbmFsKSB7XG4gIGlmICghdGhpcy5fZGVjb2Rlcikge1xuICAgIHRoaXMuX2RlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihlbmMpXG4gICAgdGhpcy5fZW5jb2RpbmcgPSBlbmNcbiAgfVxuICBpZiAodGhpcy5fZW5jb2RpbmcgIT09IGVuYykge1xuICAgIHRocm93IG5ldyBFcnJvcignY2FuXFwndCBzd2l0Y2ggZW5jb2RpbmdzJylcbiAgfVxuICB2YXIgb3V0ID0gdGhpcy5fZGVjb2Rlci53cml0ZSh2YWx1ZSlcbiAgaWYgKGZpbmFsKSB7XG4gICAgb3V0ICs9IHRoaXMuX2RlY29kZXIuZW5kKClcbiAgfVxuICByZXR1cm4gb3V0XG59XG4iLCIvKlxuQ3J5cHRvSlMgdjMuMS4yXG5jb2RlLmdvb2dsZS5jb20vcC9jcnlwdG8tanNcbihjKSAyMDA5LTIwMTMgYnkgSmVmZiBNb3R0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuY29kZS5nb29nbGUuY29tL3AvY3J5cHRvLWpzL3dpa2kvTGljZW5zZVxuKi9cbi8qKiBAcHJlc2VydmVcbihjKSAyMDEyIGJ5IEPDqWRyaWMgTWVzbmlsLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXG5SZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG5cbiAgICAtIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAgICAtIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuKi9cblxuLy8gY29uc3RhbnRzIHRhYmxlXG52YXIgemwgPSBbXG4gIDAsIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMSwgMTIsIDEzLCAxNCwgMTUsXG4gIDcsIDQsIDEzLCAxLCAxMCwgNiwgMTUsIDMsIDEyLCAwLCA5LCA1LCAyLCAxNCwgMTEsIDgsXG4gIDMsIDEwLCAxNCwgNCwgOSwgMTUsIDgsIDEsIDIsIDcsIDAsIDYsIDEzLCAxMSwgNSwgMTIsXG4gIDEsIDksIDExLCAxMCwgMCwgOCwgMTIsIDQsIDEzLCAzLCA3LCAxNSwgMTQsIDUsIDYsIDIsXG4gIDQsIDAsIDUsIDksIDcsIDEyLCAyLCAxMCwgMTQsIDEsIDMsIDgsIDExLCA2LCAxNSwgMTNcbl1cblxudmFyIHpyID0gW1xuICA1LCAxNCwgNywgMCwgOSwgMiwgMTEsIDQsIDEzLCA2LCAxNSwgOCwgMSwgMTAsIDMsIDEyLFxuICA2LCAxMSwgMywgNywgMCwgMTMsIDUsIDEwLCAxNCwgMTUsIDgsIDEyLCA0LCA5LCAxLCAyLFxuICAxNSwgNSwgMSwgMywgNywgMTQsIDYsIDksIDExLCA4LCAxMiwgMiwgMTAsIDAsIDQsIDEzLFxuICA4LCA2LCA0LCAxLCAzLCAxMSwgMTUsIDAsIDUsIDEyLCAyLCAxMywgOSwgNywgMTAsIDE0LFxuICAxMiwgMTUsIDEwLCA0LCAxLCA1LCA4LCA3LCA2LCAyLCAxMywgMTQsIDAsIDMsIDksIDExXG5dXG5cbnZhciBzbCA9IFtcbiAgMTEsIDE0LCAxNSwgMTIsIDUsIDgsIDcsIDksIDExLCAxMywgMTQsIDE1LCA2LCA3LCA5LCA4LFxuICA3LCA2LCA4LCAxMywgMTEsIDksIDcsIDE1LCA3LCAxMiwgMTUsIDksIDExLCA3LCAxMywgMTIsXG4gIDExLCAxMywgNiwgNywgMTQsIDksIDEzLCAxNSwgMTQsIDgsIDEzLCA2LCA1LCAxMiwgNywgNSxcbiAgMTEsIDEyLCAxNCwgMTUsIDE0LCAxNSwgOSwgOCwgOSwgMTQsIDUsIDYsIDgsIDYsIDUsIDEyLFxuICA5LCAxNSwgNSwgMTEsIDYsIDgsIDEzLCAxMiwgNSwgMTIsIDEzLCAxNCwgMTEsIDgsIDUsIDZcbl1cblxudmFyIHNyID0gW1xuICA4LCA5LCA5LCAxMSwgMTMsIDE1LCAxNSwgNSwgNywgNywgOCwgMTEsIDE0LCAxNCwgMTIsIDYsXG4gIDksIDEzLCAxNSwgNywgMTIsIDgsIDksIDExLCA3LCA3LCAxMiwgNywgNiwgMTUsIDEzLCAxMSxcbiAgOSwgNywgMTUsIDExLCA4LCA2LCA2LCAxNCwgMTIsIDEzLCA1LCAxNCwgMTMsIDEzLCA3LCA1LFxuICAxNSwgNSwgOCwgMTEsIDE0LCAxNCwgNiwgMTQsIDYsIDksIDEyLCA5LCAxMiwgNSwgMTUsIDgsXG4gIDgsIDUsIDEyLCA5LCAxMiwgNSwgMTQsIDYsIDgsIDEzLCA2LCA1LCAxNSwgMTMsIDExLCAxMVxuXVxuXG52YXIgaGwgPSBbMHgwMDAwMDAwMCwgMHg1QTgyNzk5OSwgMHg2RUQ5RUJBMSwgMHg4RjFCQkNEQywgMHhBOTUzRkQ0RV1cbnZhciBociA9IFsweDUwQTI4QkU2LCAweDVDNEREMTI0LCAweDZENzAzRUYzLCAweDdBNkQ3NkU5LCAweDAwMDAwMDAwXVxuXG5mdW5jdGlvbiBieXRlc1RvV29yZHMgKGJ5dGVzKSB7XG4gIHZhciB3b3JkcyA9IFtdXG4gIGZvciAodmFyIGkgPSAwLCBiID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrLCBiICs9IDgpIHtcbiAgICB3b3Jkc1tiID4+PiA1XSB8PSBieXRlc1tpXSA8PCAoMjQgLSBiICUgMzIpXG4gIH1cbiAgcmV0dXJuIHdvcmRzXG59XG5cbmZ1bmN0aW9uIHdvcmRzVG9CeXRlcyAod29yZHMpIHtcbiAgdmFyIGJ5dGVzID0gW11cbiAgZm9yICh2YXIgYiA9IDA7IGIgPCB3b3Jkcy5sZW5ndGggKiAzMjsgYiArPSA4KSB7XG4gICAgYnl0ZXMucHVzaCgod29yZHNbYiA+Pj4gNV0gPj4+ICgyNCAtIGIgJSAzMikpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0Jsb2NrIChILCBNLCBvZmZzZXQpIHtcbiAgLy8gc3dhcCBlbmRpYW5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgdmFyIG9mZnNldF9pID0gb2Zmc2V0ICsgaVxuICAgIHZhciBNX29mZnNldF9pID0gTVtvZmZzZXRfaV1cblxuICAgIC8vIFN3YXBcbiAgICBNW29mZnNldF9pXSA9IChcbiAgICAgICgoKE1fb2Zmc2V0X2kgPDwgOCkgfCAoTV9vZmZzZXRfaSA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHxcbiAgICAgICgoKE1fb2Zmc2V0X2kgPDwgMjQpIHwgKE1fb2Zmc2V0X2kgPj4+IDgpKSAmIDB4ZmYwMGZmMDApXG4gICAgKVxuICB9XG5cbiAgLy8gV29ya2luZyB2YXJpYWJsZXNcbiAgdmFyIGFsLCBibCwgY2wsIGRsLCBlbFxuICB2YXIgYXIsIGJyLCBjciwgZHIsIGVyXG5cbiAgYXIgPSBhbCA9IEhbMF1cbiAgYnIgPSBibCA9IEhbMV1cbiAgY3IgPSBjbCA9IEhbMl1cbiAgZHIgPSBkbCA9IEhbM11cbiAgZXIgPSBlbCA9IEhbNF1cblxuICAvLyBjb21wdXRhdGlvblxuICB2YXIgdFxuICBmb3IgKGkgPSAwOyBpIDwgODA7IGkgKz0gMSkge1xuICAgIHQgPSAoYWwgKyBNW29mZnNldCArIHpsW2ldXSkgfCAwXG4gICAgaWYgKGkgPCAxNikge1xuICAgICAgdCArPSBmMShibCwgY2wsIGRsKSArIGhsWzBdXG4gICAgfSBlbHNlIGlmIChpIDwgMzIpIHtcbiAgICAgIHQgKz0gZjIoYmwsIGNsLCBkbCkgKyBobFsxXVxuICAgIH0gZWxzZSBpZiAoaSA8IDQ4KSB7XG4gICAgICB0ICs9IGYzKGJsLCBjbCwgZGwpICsgaGxbMl1cbiAgICB9IGVsc2UgaWYgKGkgPCA2NCkge1xuICAgICAgdCArPSBmNChibCwgY2wsIGRsKSArIGhsWzNdXG4gICAgfSBlbHNlIHsvLyBpZiAoaTw4MCkge1xuICAgICAgdCArPSBmNShibCwgY2wsIGRsKSArIGhsWzRdXG4gICAgfVxuICAgIHQgPSB0IHwgMFxuICAgIHQgPSByb3RsKHQsIHNsW2ldKVxuICAgIHQgPSAodCArIGVsKSB8IDBcbiAgICBhbCA9IGVsXG4gICAgZWwgPSBkbFxuICAgIGRsID0gcm90bChjbCwgMTApXG4gICAgY2wgPSBibFxuICAgIGJsID0gdFxuXG4gICAgdCA9IChhciArIE1bb2Zmc2V0ICsgenJbaV1dKSB8IDBcbiAgICBpZiAoaSA8IDE2KSB7XG4gICAgICB0ICs9IGY1KGJyLCBjciwgZHIpICsgaHJbMF1cbiAgICB9IGVsc2UgaWYgKGkgPCAzMikge1xuICAgICAgdCArPSBmNChiciwgY3IsIGRyKSArIGhyWzFdXG4gICAgfSBlbHNlIGlmIChpIDwgNDgpIHtcbiAgICAgIHQgKz0gZjMoYnIsIGNyLCBkcikgKyBoclsyXVxuICAgIH0gZWxzZSBpZiAoaSA8IDY0KSB7XG4gICAgICB0ICs9IGYyKGJyLCBjciwgZHIpICsgaHJbM11cbiAgICB9IGVsc2Ugey8vIGlmIChpPDgwKSB7XG4gICAgICB0ICs9IGYxKGJyLCBjciwgZHIpICsgaHJbNF1cbiAgICB9XG5cbiAgICB0ID0gdCB8IDBcbiAgICB0ID0gcm90bCh0LCBzcltpXSlcbiAgICB0ID0gKHQgKyBlcikgfCAwXG4gICAgYXIgPSBlclxuICAgIGVyID0gZHJcbiAgICBkciA9IHJvdGwoY3IsIDEwKVxuICAgIGNyID0gYnJcbiAgICBiciA9IHRcbiAgfVxuXG4gIC8vIGludGVybWVkaWF0ZSBoYXNoIHZhbHVlXG4gIHQgPSAoSFsxXSArIGNsICsgZHIpIHwgMFxuICBIWzFdID0gKEhbMl0gKyBkbCArIGVyKSB8IDBcbiAgSFsyXSA9IChIWzNdICsgZWwgKyBhcikgfCAwXG4gIEhbM10gPSAoSFs0XSArIGFsICsgYnIpIHwgMFxuICBIWzRdID0gKEhbMF0gKyBibCArIGNyKSB8IDBcbiAgSFswXSA9IHRcbn1cblxuZnVuY3Rpb24gZjEgKHgsIHksIHopIHtcbiAgcmV0dXJuICgoeCkgXiAoeSkgXiAoeikpXG59XG5cbmZ1bmN0aW9uIGYyICh4LCB5LCB6KSB7XG4gIHJldHVybiAoKCh4KSAmICh5KSkgfCAoKH54KSAmICh6KSkpXG59XG5cbmZ1bmN0aW9uIGYzICh4LCB5LCB6KSB7XG4gIHJldHVybiAoKCh4KSB8ICh+KHkpKSkgXiAoeikpXG59XG5cbmZ1bmN0aW9uIGY0ICh4LCB5LCB6KSB7XG4gIHJldHVybiAoKCh4KSAmICh6KSkgfCAoKHkpICYgKH4oeikpKSlcbn1cblxuZnVuY3Rpb24gZjUgKHgsIHksIHopIHtcbiAgcmV0dXJuICgoeCkgXiAoKHkpIHwgKH4oeikpKSlcbn1cblxuZnVuY3Rpb24gcm90bCAoeCwgbikge1xuICByZXR1cm4gKHggPDwgbikgfCAoeCA+Pj4gKDMyIC0gbikpXG59XG5cbmZ1bmN0aW9uIHJpcGVtZDE2MCAobWVzc2FnZSkge1xuICB2YXIgSCA9IFsweDY3NDUyMzAxLCAweEVGQ0RBQjg5LCAweDk4QkFEQ0ZFLCAweDEwMzI1NDc2LCAweEMzRDJFMUYwXVxuXG4gIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICBtZXNzYWdlID0gbmV3IEJ1ZmZlcihtZXNzYWdlLCAndXRmOCcpXG4gIH1cblxuICB2YXIgbSA9IGJ5dGVzVG9Xb3JkcyhtZXNzYWdlKVxuXG4gIHZhciBuQml0c0xlZnQgPSBtZXNzYWdlLmxlbmd0aCAqIDhcbiAgdmFyIG5CaXRzVG90YWwgPSBtZXNzYWdlLmxlbmd0aCAqIDhcblxuICAvLyBBZGQgcGFkZGluZ1xuICBtW25CaXRzTGVmdCA+Pj4gNV0gfD0gMHg4MCA8PCAoMjQgLSBuQml0c0xlZnQgJSAzMilcbiAgbVsoKChuQml0c0xlZnQgKyA2NCkgPj4+IDkpIDw8IDQpICsgMTRdID0gKFxuICAgICgoKG5CaXRzVG90YWwgPDwgOCkgfCAobkJpdHNUb3RhbCA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHxcbiAgICAoKChuQml0c1RvdGFsIDw8IDI0KSB8IChuQml0c1RvdGFsID4+PiA4KSkgJiAweGZmMDBmZjAwKVxuICApXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtLmxlbmd0aDsgaSArPSAxNikge1xuICAgIHByb2Nlc3NCbG9jayhILCBtLCBpKVxuICB9XG5cbiAgLy8gc3dhcCBlbmRpYW5cbiAgZm9yIChpID0gMDsgaSA8IDU7IGkrKykge1xuICAgIC8vIHNob3J0Y3V0XG4gICAgdmFyIEhfaSA9IEhbaV1cblxuICAgIC8vIFN3YXBcbiAgICBIW2ldID0gKCgoSF9pIDw8IDgpIHwgKEhfaSA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHxcbiAgICAgICgoKEhfaSA8PCAyNCkgfCAoSF9pID4+PiA4KSkgJiAweGZmMDBmZjAwKVxuICB9XG5cbiAgdmFyIGRpZ2VzdGJ5dGVzID0gd29yZHNUb0J5dGVzKEgpXG4gIHJldHVybiBuZXcgQnVmZmVyKGRpZ2VzdGJ5dGVzKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJpcGVtZDE2MFxuIiwiLy8gcHJvdG90eXBlIGNsYXNzIGZvciBoYXNoIGZ1bmN0aW9uc1xuZnVuY3Rpb24gSGFzaCAoYmxvY2tTaXplLCBmaW5hbFNpemUpIHtcbiAgdGhpcy5fYmxvY2sgPSBuZXcgQnVmZmVyKGJsb2NrU2l6ZSlcbiAgdGhpcy5fZmluYWxTaXplID0gZmluYWxTaXplXG4gIHRoaXMuX2Jsb2NrU2l6ZSA9IGJsb2NrU2l6ZVxuICB0aGlzLl9sZW4gPSAwXG4gIHRoaXMuX3MgPSAwXG59XG5cbkhhc2gucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhLCBlbmMpIHtcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgIGVuYyA9IGVuYyB8fCAndXRmOCdcbiAgICBkYXRhID0gbmV3IEJ1ZmZlcihkYXRhLCBlbmMpXG4gIH1cblxuICB2YXIgbCA9IHRoaXMuX2xlbiArPSBkYXRhLmxlbmd0aFxuICB2YXIgcyA9IHRoaXMuX3MgfHwgMFxuICB2YXIgZiA9IDBcbiAgdmFyIGJ1ZmZlciA9IHRoaXMuX2Jsb2NrXG5cbiAgd2hpbGUgKHMgPCBsKSB7XG4gICAgdmFyIHQgPSBNYXRoLm1pbihkYXRhLmxlbmd0aCwgZiArIHRoaXMuX2Jsb2NrU2l6ZSAtIChzICUgdGhpcy5fYmxvY2tTaXplKSlcbiAgICB2YXIgY2ggPSAodCAtIGYpXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoOyBpKyspIHtcbiAgICAgIGJ1ZmZlclsocyAlIHRoaXMuX2Jsb2NrU2l6ZSkgKyBpXSA9IGRhdGFbaSArIGZdXG4gICAgfVxuXG4gICAgcyArPSBjaFxuICAgIGYgKz0gY2hcblxuICAgIGlmICgocyAlIHRoaXMuX2Jsb2NrU2l6ZSkgPT09IDApIHtcbiAgICAgIHRoaXMuX3VwZGF0ZShidWZmZXIpXG4gICAgfVxuICB9XG4gIHRoaXMuX3MgPSBzXG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuSGFzaC5wcm90b3R5cGUuZGlnZXN0ID0gZnVuY3Rpb24gKGVuYykge1xuICAvLyBTdXBwb3NlIHRoZSBsZW5ndGggb2YgdGhlIG1lc3NhZ2UgTSwgaW4gYml0cywgaXMgbFxuICB2YXIgbCA9IHRoaXMuX2xlbiAqIDhcblxuICAvLyBBcHBlbmQgdGhlIGJpdCAxIHRvIHRoZSBlbmQgb2YgdGhlIG1lc3NhZ2VcbiAgdGhpcy5fYmxvY2tbdGhpcy5fbGVuICUgdGhpcy5fYmxvY2tTaXplXSA9IDB4ODBcblxuICAvLyBhbmQgdGhlbiBrIHplcm8gYml0cywgd2hlcmUgayBpcyB0aGUgc21hbGxlc3Qgbm9uLW5lZ2F0aXZlIHNvbHV0aW9uIHRvIHRoZSBlcXVhdGlvbiAobCArIDEgKyBrKSA9PT0gZmluYWxTaXplIG1vZCBibG9ja1NpemVcbiAgdGhpcy5fYmxvY2suZmlsbCgwLCB0aGlzLl9sZW4gJSB0aGlzLl9ibG9ja1NpemUgKyAxKVxuXG4gIGlmIChsICUgKHRoaXMuX2Jsb2NrU2l6ZSAqIDgpID49IHRoaXMuX2ZpbmFsU2l6ZSAqIDgpIHtcbiAgICB0aGlzLl91cGRhdGUodGhpcy5fYmxvY2spXG4gICAgdGhpcy5fYmxvY2suZmlsbCgwKVxuICB9XG5cbiAgLy8gdG8gdGhpcyBhcHBlbmQgdGhlIGJsb2NrIHdoaWNoIGlzIGVxdWFsIHRvIHRoZSBudW1iZXIgbCB3cml0dGVuIGluIGJpbmFyeVxuICAvLyBUT0RPOiBoYW5kbGUgY2FzZSB3aGVyZSBsIGlzID4gTWF0aC5wb3coMiwgMjkpXG4gIHRoaXMuX2Jsb2NrLndyaXRlSW50MzJCRShsLCB0aGlzLl9ibG9ja1NpemUgLSA0KVxuXG4gIHZhciBoYXNoID0gdGhpcy5fdXBkYXRlKHRoaXMuX2Jsb2NrKSB8fCB0aGlzLl9oYXNoKClcblxuICByZXR1cm4gZW5jID8gaGFzaC50b1N0cmluZyhlbmMpIDogaGFzaFxufVxuXG5IYXNoLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ191cGRhdGUgbXVzdCBiZSBpbXBsZW1lbnRlZCBieSBzdWJjbGFzcycpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gSGFzaFxuIiwidmFyIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIFNIQSAoYWxnb3JpdGhtKSB7XG4gIGFsZ29yaXRobSA9IGFsZ29yaXRobS50b0xvd2VyQ2FzZSgpXG5cbiAgdmFyIEFsZ29yaXRobSA9IGV4cG9ydHNbYWxnb3JpdGhtXVxuICBpZiAoIUFsZ29yaXRobSkgdGhyb3cgbmV3IEVycm9yKGFsZ29yaXRobSArICcgaXMgbm90IHN1cHBvcnRlZCAod2UgYWNjZXB0IHB1bGwgcmVxdWVzdHMpJylcblxuICByZXR1cm4gbmV3IEFsZ29yaXRobSgpXG59XG5cbmV4cG9ydHMuc2hhID0gcmVxdWlyZSgnLi9zaGEnKVxuZXhwb3J0cy5zaGExID0gcmVxdWlyZSgnLi9zaGExJylcbmV4cG9ydHMuc2hhMjI0ID0gcmVxdWlyZSgnLi9zaGEyMjQnKVxuZXhwb3J0cy5zaGEyNTYgPSByZXF1aXJlKCcuL3NoYTI1NicpXG5leHBvcnRzLnNoYTM4NCA9IHJlcXVpcmUoJy4vc2hhMzg0JylcbmV4cG9ydHMuc2hhNTEyID0gcmVxdWlyZSgnLi9zaGE1MTInKVxuIiwiLypcbiAqIEEgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgU2VjdXJlIEhhc2ggQWxnb3JpdGhtLCBTSEEtMCwgYXMgZGVmaW5lZFxuICogaW4gRklQUyBQVUIgMTgwLTFcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgZGVyaXZlZCBmcm9tIHNoYTEuanMgb2YgdGhlIHNhbWUgcmVwb3NpdG9yeS5cbiAqIFRoZSBkaWZmZXJlbmNlIGJldHdlZW4gU0hBLTAgYW5kIFNIQS0xIGlzIGp1c3QgYSBiaXR3aXNlIHJvdGF0ZSBsZWZ0XG4gKiBvcGVyYXRpb24gd2FzIGFkZGVkLlxuICovXG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBIYXNoID0gcmVxdWlyZSgnLi9oYXNoJylcblxudmFyIFcgPSBuZXcgQXJyYXkoODApXG5cbmZ1bmN0aW9uIFNoYSAoKSB7XG4gIHRoaXMuaW5pdCgpXG4gIHRoaXMuX3cgPSBXXG5cbiAgSGFzaC5jYWxsKHRoaXMsIDY0LCA1Nilcbn1cblxuaW5oZXJpdHMoU2hhLCBIYXNoKVxuXG5TaGEucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX2EgPSAweDY3NDUyMzAxIHwgMFxuICB0aGlzLl9iID0gMHhlZmNkYWI4OSB8IDBcbiAgdGhpcy5fYyA9IDB4OThiYWRjZmUgfCAwXG4gIHRoaXMuX2QgPSAweDEwMzI1NDc2IHwgMFxuICB0aGlzLl9lID0gMHhjM2QyZTFmMCB8IDBcblxuICByZXR1cm4gdGhpc1xufVxuXG4vKlxuICogQml0d2lzZSByb3RhdGUgYSAzMi1iaXQgbnVtYmVyIHRvIHRoZSBsZWZ0LlxuICovXG5mdW5jdGlvbiByb2wgKG51bSwgY250KSB7XG4gIHJldHVybiAobnVtIDw8IGNudCkgfCAobnVtID4+PiAoMzIgLSBjbnQpKVxufVxuXG5TaGEucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoTSkge1xuICB2YXIgVyA9IHRoaXMuX3dcblxuICB2YXIgYSA9IHRoaXMuX2FcbiAgdmFyIGIgPSB0aGlzLl9iXG4gIHZhciBjID0gdGhpcy5fY1xuICB2YXIgZCA9IHRoaXMuX2RcbiAgdmFyIGUgPSB0aGlzLl9lXG5cbiAgdmFyIGogPSAwXG4gIHZhciBrXG5cbiAgLypcbiAgICogU0hBLTEgaGFzIGEgYml0d2lzZSByb3RhdGUgbGVmdCBvcGVyYXRpb24uIEJ1dCwgU0hBIGlzIG5vdFxuICAgKiBmdW5jdGlvbiBjYWxjVygpIHsgcmV0dXJuIHJvbChXW2ogLSAzXSBeIFdbaiAtICA4XSBeIFdbaiAtIDE0XSBeIFdbaiAtIDE2XSwgMSkgfVxuICAgKi9cbiAgZnVuY3Rpb24gY2FsY1cgKCkgeyByZXR1cm4gV1tqIC0gM10gXiBXW2ogLSA4XSBeIFdbaiAtIDE0XSBeIFdbaiAtIDE2XSB9XG4gIGZ1bmN0aW9uIGxvb3AgKHcsIGYpIHtcbiAgICBXW2pdID0gd1xuXG4gICAgdmFyIHQgPSByb2woYSwgNSkgKyBmICsgZSArIHcgKyBrXG5cbiAgICBlID0gZFxuICAgIGQgPSBjXG4gICAgYyA9IHJvbChiLCAzMClcbiAgICBiID0gYVxuICAgIGEgPSB0XG4gICAgaisrXG4gIH1cblxuICBrID0gMTUxODUwMDI0OVxuICB3aGlsZSAoaiA8IDE2KSBsb29wKE0ucmVhZEludDMyQkUoaiAqIDQpLCAoYiAmIGMpIHwgKCh+YikgJiBkKSlcbiAgd2hpbGUgKGogPCAyMCkgbG9vcChjYWxjVygpLCAoYiAmIGMpIHwgKCh+YikgJiBkKSlcbiAgayA9IDE4NTk3NzUzOTNcbiAgd2hpbGUgKGogPCA0MCkgbG9vcChjYWxjVygpLCBiIF4gYyBeIGQpXG4gIGsgPSAtMTg5NDAwNzU4OFxuICB3aGlsZSAoaiA8IDYwKSBsb29wKGNhbGNXKCksIChiICYgYykgfCAoYiAmIGQpIHwgKGMgJiBkKSlcbiAgayA9IC04OTk0OTc1MTRcbiAgd2hpbGUgKGogPCA4MCkgbG9vcChjYWxjVygpLCBiIF4gYyBeIGQpXG5cbiAgdGhpcy5fYSA9IChhICsgdGhpcy5fYSkgfCAwXG4gIHRoaXMuX2IgPSAoYiArIHRoaXMuX2IpIHwgMFxuICB0aGlzLl9jID0gKGMgKyB0aGlzLl9jKSB8IDBcbiAgdGhpcy5fZCA9IChkICsgdGhpcy5fZCkgfCAwXG4gIHRoaXMuX2UgPSAoZSArIHRoaXMuX2UpIHwgMFxufVxuXG5TaGEucHJvdG90eXBlLl9oYXNoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgSCA9IG5ldyBCdWZmZXIoMjApXG5cbiAgSC53cml0ZUludDMyQkUodGhpcy5fYSB8IDAsIDApXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2IgfCAwLCA0KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9jIHwgMCwgOClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZCB8IDAsIDEyKVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9lIHwgMCwgMTYpXG5cbiAgcmV0dXJuIEhcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTaGFcblxuIiwiLypcbiAqIEEgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgU2VjdXJlIEhhc2ggQWxnb3JpdGhtLCBTSEEtMSwgYXMgZGVmaW5lZFxuICogaW4gRklQUyBQVUIgMTgwLTFcbiAqIFZlcnNpb24gMi4xYSBDb3B5cmlnaHQgUGF1bCBKb2huc3RvbiAyMDAwIC0gMjAwMi5cbiAqIE90aGVyIGNvbnRyaWJ1dG9yczogR3JlZyBIb2x0LCBBbmRyZXcgS2VwZXJ0LCBZZG5hciwgTG9zdGluZXRcbiAqIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBCU0QgTGljZW5zZVxuICogU2VlIGh0dHA6Ly9wYWpob21lLm9yZy51ay9jcnlwdC9tZDUgZm9yIGRldGFpbHMuXG4gKi9cblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIEhhc2ggPSByZXF1aXJlKCcuL2hhc2gnKVxuXG52YXIgVyA9IG5ldyBBcnJheSg4MClcblxuZnVuY3Rpb24gU2hhMSAoKSB7XG4gIHRoaXMuaW5pdCgpXG4gIHRoaXMuX3cgPSBXXG5cbiAgSGFzaC5jYWxsKHRoaXMsIDY0LCA1Nilcbn1cblxuaW5oZXJpdHMoU2hhMSwgSGFzaClcblxuU2hhMS5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fYSA9IDB4Njc0NTIzMDEgfCAwXG4gIHRoaXMuX2IgPSAweGVmY2RhYjg5IHwgMFxuICB0aGlzLl9jID0gMHg5OGJhZGNmZSB8IDBcbiAgdGhpcy5fZCA9IDB4MTAzMjU0NzYgfCAwXG4gIHRoaXMuX2UgPSAweGMzZDJlMWYwIHwgMFxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8qXG4gKiBCaXR3aXNlIHJvdGF0ZSBhIDMyLWJpdCBudW1iZXIgdG8gdGhlIGxlZnQuXG4gKi9cbmZ1bmN0aW9uIHJvbCAobnVtLCBjbnQpIHtcbiAgcmV0dXJuIChudW0gPDwgY250KSB8IChudW0gPj4+ICgzMiAtIGNudCkpXG59XG5cblNoYTEucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoTSkge1xuICB2YXIgVyA9IHRoaXMuX3dcblxuICB2YXIgYSA9IHRoaXMuX2FcbiAgdmFyIGIgPSB0aGlzLl9iXG4gIHZhciBjID0gdGhpcy5fY1xuICB2YXIgZCA9IHRoaXMuX2RcbiAgdmFyIGUgPSB0aGlzLl9lXG5cbiAgdmFyIGogPSAwXG4gIHZhciBrXG5cbiAgZnVuY3Rpb24gY2FsY1cgKCkgeyByZXR1cm4gcm9sKFdbaiAtIDNdIF4gV1tqIC0gOF0gXiBXW2ogLSAxNF0gXiBXW2ogLSAxNl0sIDEpIH1cbiAgZnVuY3Rpb24gbG9vcCAodywgZikge1xuICAgIFdbal0gPSB3XG5cbiAgICB2YXIgdCA9IHJvbChhLCA1KSArIGYgKyBlICsgdyArIGtcblxuICAgIGUgPSBkXG4gICAgZCA9IGNcbiAgICBjID0gcm9sKGIsIDMwKVxuICAgIGIgPSBhXG4gICAgYSA9IHRcbiAgICBqKytcbiAgfVxuXG4gIGsgPSAxNTE4NTAwMjQ5XG4gIHdoaWxlIChqIDwgMTYpIGxvb3AoTS5yZWFkSW50MzJCRShqICogNCksIChiICYgYykgfCAoKH5iKSAmIGQpKVxuICB3aGlsZSAoaiA8IDIwKSBsb29wKGNhbGNXKCksIChiICYgYykgfCAoKH5iKSAmIGQpKVxuICBrID0gMTg1OTc3NTM5M1xuICB3aGlsZSAoaiA8IDQwKSBsb29wKGNhbGNXKCksIGIgXiBjIF4gZClcbiAgayA9IC0xODk0MDA3NTg4XG4gIHdoaWxlIChqIDwgNjApIGxvb3AoY2FsY1coKSwgKGIgJiBjKSB8IChiICYgZCkgfCAoYyAmIGQpKVxuICBrID0gLTg5OTQ5NzUxNFxuICB3aGlsZSAoaiA8IDgwKSBsb29wKGNhbGNXKCksIGIgXiBjIF4gZClcblxuICB0aGlzLl9hID0gKGEgKyB0aGlzLl9hKSB8IDBcbiAgdGhpcy5fYiA9IChiICsgdGhpcy5fYikgfCAwXG4gIHRoaXMuX2MgPSAoYyArIHRoaXMuX2MpIHwgMFxuICB0aGlzLl9kID0gKGQgKyB0aGlzLl9kKSB8IDBcbiAgdGhpcy5fZSA9IChlICsgdGhpcy5fZSkgfCAwXG59XG5cblNoYTEucHJvdG90eXBlLl9oYXNoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgSCA9IG5ldyBCdWZmZXIoMjApXG5cbiAgSC53cml0ZUludDMyQkUodGhpcy5fYSB8IDAsIDApXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2IgfCAwLCA0KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9jIHwgMCwgOClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZCB8IDAsIDEyKVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9lIHwgMCwgMTYpXG5cbiAgcmV0dXJuIEhcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTaGExXG4iLCIvKipcbiAqIEEgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgU2VjdXJlIEhhc2ggQWxnb3JpdGhtLCBTSEEtMjU2LCBhcyBkZWZpbmVkXG4gKiBpbiBGSVBTIDE4MC0yXG4gKiBWZXJzaW9uIDIuMi1iZXRhIENvcHlyaWdodCBBbmdlbCBNYXJpbiwgUGF1bCBKb2huc3RvbiAyMDAwIC0gMjAwOS5cbiAqIE90aGVyIGNvbnRyaWJ1dG9yczogR3JlZyBIb2x0LCBBbmRyZXcgS2VwZXJ0LCBZZG5hciwgTG9zdGluZXRcbiAqXG4gKi9cblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIFNoYTI1NiA9IHJlcXVpcmUoJy4vc2hhMjU2JylcbnZhciBIYXNoID0gcmVxdWlyZSgnLi9oYXNoJylcblxudmFyIFcgPSBuZXcgQXJyYXkoNjQpXG5cbmZ1bmN0aW9uIFNoYTIyNCAoKSB7XG4gIHRoaXMuaW5pdCgpXG5cbiAgdGhpcy5fdyA9IFcgLy8gbmV3IEFycmF5KDY0KVxuXG4gIEhhc2guY2FsbCh0aGlzLCA2NCwgNTYpXG59XG5cbmluaGVyaXRzKFNoYTIyNCwgU2hhMjU2KVxuXG5TaGEyMjQucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX2EgPSAweGMxMDU5ZWQ4IHwgMFxuICB0aGlzLl9iID0gMHgzNjdjZDUwNyB8IDBcbiAgdGhpcy5fYyA9IDB4MzA3MGRkMTcgfCAwXG4gIHRoaXMuX2QgPSAweGY3MGU1OTM5IHwgMFxuICB0aGlzLl9lID0gMHhmZmMwMGIzMSB8IDBcbiAgdGhpcy5fZiA9IDB4Njg1ODE1MTEgfCAwXG4gIHRoaXMuX2cgPSAweDY0Zjk4ZmE3IHwgMFxuICB0aGlzLl9oID0gMHhiZWZhNGZhNCB8IDBcblxuICByZXR1cm4gdGhpc1xufVxuXG5TaGEyMjQucHJvdG90eXBlLl9oYXNoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgSCA9IG5ldyBCdWZmZXIoMjgpXG5cbiAgSC53cml0ZUludDMyQkUodGhpcy5fYSwgMClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fYiwgNClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fYywgOClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZCwgMTIpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2UsIDE2KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9mLCAyMClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZywgMjQpXG5cbiAgcmV0dXJuIEhcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTaGEyMjRcbiIsIi8qKlxuICogQSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBTZWN1cmUgSGFzaCBBbGdvcml0aG0sIFNIQS0yNTYsIGFzIGRlZmluZWRcbiAqIGluIEZJUFMgMTgwLTJcbiAqIFZlcnNpb24gMi4yLWJldGEgQ29weXJpZ2h0IEFuZ2VsIE1hcmluLCBQYXVsIEpvaG5zdG9uIDIwMDAgLSAyMDA5LlxuICogT3RoZXIgY29udHJpYnV0b3JzOiBHcmVnIEhvbHQsIEFuZHJldyBLZXBlcnQsIFlkbmFyLCBMb3N0aW5ldFxuICpcbiAqL1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgSGFzaCA9IHJlcXVpcmUoJy4vaGFzaCcpXG5cbnZhciBLID0gW1xuICAweDQyOEEyRjk4LCAweDcxMzc0NDkxLCAweEI1QzBGQkNGLCAweEU5QjVEQkE1LFxuICAweDM5NTZDMjVCLCAweDU5RjExMUYxLCAweDkyM0Y4MkE0LCAweEFCMUM1RUQ1LFxuICAweEQ4MDdBQTk4LCAweDEyODM1QjAxLCAweDI0MzE4NUJFLCAweDU1MEM3REMzLFxuICAweDcyQkU1RDc0LCAweDgwREVCMUZFLCAweDlCREMwNkE3LCAweEMxOUJGMTc0LFxuICAweEU0OUI2OUMxLCAweEVGQkU0Nzg2LCAweDBGQzE5REM2LCAweDI0MENBMUNDLFxuICAweDJERTkyQzZGLCAweDRBNzQ4NEFBLCAweDVDQjBBOURDLCAweDc2Rjk4OERBLFxuICAweDk4M0U1MTUyLCAweEE4MzFDNjZELCAweEIwMDMyN0M4LCAweEJGNTk3RkM3LFxuICAweEM2RTAwQkYzLCAweEQ1QTc5MTQ3LCAweDA2Q0E2MzUxLCAweDE0MjkyOTY3LFxuICAweDI3QjcwQTg1LCAweDJFMUIyMTM4LCAweDREMkM2REZDLCAweDUzMzgwRDEzLFxuICAweDY1MEE3MzU0LCAweDc2NkEwQUJCLCAweDgxQzJDOTJFLCAweDkyNzIyQzg1LFxuICAweEEyQkZFOEExLCAweEE4MUE2NjRCLCAweEMyNEI4QjcwLCAweEM3NkM1MUEzLFxuICAweEQxOTJFODE5LCAweEQ2OTkwNjI0LCAweEY0MEUzNTg1LCAweDEwNkFBMDcwLFxuICAweDE5QTRDMTE2LCAweDFFMzc2QzA4LCAweDI3NDg3NzRDLCAweDM0QjBCQ0I1LFxuICAweDM5MUMwQ0IzLCAweDRFRDhBQTRBLCAweDVCOUNDQTRGLCAweDY4MkU2RkYzLFxuICAweDc0OEY4MkVFLCAweDc4QTU2MzZGLCAweDg0Qzg3ODE0LCAweDhDQzcwMjA4LFxuICAweDkwQkVGRkZBLCAweEE0NTA2Q0VCLCAweEJFRjlBM0Y3LCAweEM2NzE3OEYyXG5dXG5cbnZhciBXID0gbmV3IEFycmF5KDY0KVxuXG5mdW5jdGlvbiBTaGEyNTYgKCkge1xuICB0aGlzLmluaXQoKVxuXG4gIHRoaXMuX3cgPSBXIC8vIG5ldyBBcnJheSg2NClcblxuICBIYXNoLmNhbGwodGhpcywgNjQsIDU2KVxufVxuXG5pbmhlcml0cyhTaGEyNTYsIEhhc2gpXG5cblNoYTI1Ni5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fYSA9IDB4NmEwOWU2NjcgfCAwXG4gIHRoaXMuX2IgPSAweGJiNjdhZTg1IHwgMFxuICB0aGlzLl9jID0gMHgzYzZlZjM3MiB8IDBcbiAgdGhpcy5fZCA9IDB4YTU0ZmY1M2EgfCAwXG4gIHRoaXMuX2UgPSAweDUxMGU1MjdmIHwgMFxuICB0aGlzLl9mID0gMHg5YjA1Njg4YyB8IDBcbiAgdGhpcy5fZyA9IDB4MWY4M2Q5YWIgfCAwXG4gIHRoaXMuX2ggPSAweDViZTBjZDE5IHwgMFxuXG4gIHJldHVybiB0aGlzXG59XG5cbmZ1bmN0aW9uIENoICh4LCB5LCB6KSB7XG4gIHJldHVybiB6IF4gKHggJiAoeSBeIHopKVxufVxuXG5mdW5jdGlvbiBNYWogKHgsIHksIHopIHtcbiAgcmV0dXJuICh4ICYgeSkgfCAoeiAmICh4IHwgeSkpXG59XG5cbmZ1bmN0aW9uIFNpZ21hMCAoeCkge1xuICByZXR1cm4gKHggPj4+IDIgfCB4IDw8IDMwKSBeICh4ID4+PiAxMyB8IHggPDwgMTkpIF4gKHggPj4+IDIyIHwgeCA8PCAxMClcbn1cblxuZnVuY3Rpb24gU2lnbWExICh4KSB7XG4gIHJldHVybiAoeCA+Pj4gNiB8IHggPDwgMjYpIF4gKHggPj4+IDExIHwgeCA8PCAyMSkgXiAoeCA+Pj4gMjUgfCB4IDw8IDcpXG59XG5cbmZ1bmN0aW9uIEdhbW1hMCAoeCkge1xuICByZXR1cm4gKHggPj4+IDcgfCB4IDw8IDI1KSBeICh4ID4+PiAxOCB8IHggPDwgMTQpIF4gKHggPj4+IDMpXG59XG5cbmZ1bmN0aW9uIEdhbW1hMSAoeCkge1xuICByZXR1cm4gKHggPj4+IDE3IHwgeCA8PCAxNSkgXiAoeCA+Pj4gMTkgfCB4IDw8IDEzKSBeICh4ID4+PiAxMClcbn1cblxuU2hhMjU2LnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKE0pIHtcbiAgdmFyIFcgPSB0aGlzLl93XG5cbiAgdmFyIGEgPSB0aGlzLl9hIHwgMFxuICB2YXIgYiA9IHRoaXMuX2IgfCAwXG4gIHZhciBjID0gdGhpcy5fYyB8IDBcbiAgdmFyIGQgPSB0aGlzLl9kIHwgMFxuICB2YXIgZSA9IHRoaXMuX2UgfCAwXG4gIHZhciBmID0gdGhpcy5fZiB8IDBcbiAgdmFyIGcgPSB0aGlzLl9nIHwgMFxuICB2YXIgaCA9IHRoaXMuX2ggfCAwXG5cbiAgdmFyIGogPSAwXG5cbiAgZnVuY3Rpb24gY2FsY1cgKCkgeyByZXR1cm4gR2FtbWExKFdbaiAtIDJdKSArIFdbaiAtIDddICsgR2FtbWEwKFdbaiAtIDE1XSkgKyBXW2ogLSAxNl0gfVxuICBmdW5jdGlvbiBsb29wICh3KSB7XG4gICAgV1tqXSA9IHdcblxuICAgIHZhciBUMSA9IGggKyBTaWdtYTEoZSkgKyBDaChlLCBmLCBnKSArIEtbal0gKyB3XG4gICAgdmFyIFQyID0gU2lnbWEwKGEpICsgTWFqKGEsIGIsIGMpXG5cbiAgICBoID0gZ1xuICAgIGcgPSBmXG4gICAgZiA9IGVcbiAgICBlID0gZCArIFQxXG4gICAgZCA9IGNcbiAgICBjID0gYlxuICAgIGIgPSBhXG4gICAgYSA9IFQxICsgVDJcblxuICAgIGorK1xuICB9XG5cbiAgd2hpbGUgKGogPCAxNikgbG9vcChNLnJlYWRJbnQzMkJFKGogKiA0KSlcbiAgd2hpbGUgKGogPCA2NCkgbG9vcChjYWxjVygpKVxuXG4gIHRoaXMuX2EgPSAoYSArIHRoaXMuX2EpIHwgMFxuICB0aGlzLl9iID0gKGIgKyB0aGlzLl9iKSB8IDBcbiAgdGhpcy5fYyA9IChjICsgdGhpcy5fYykgfCAwXG4gIHRoaXMuX2QgPSAoZCArIHRoaXMuX2QpIHwgMFxuICB0aGlzLl9lID0gKGUgKyB0aGlzLl9lKSB8IDBcbiAgdGhpcy5fZiA9IChmICsgdGhpcy5fZikgfCAwXG4gIHRoaXMuX2cgPSAoZyArIHRoaXMuX2cpIHwgMFxuICB0aGlzLl9oID0gKGggKyB0aGlzLl9oKSB8IDBcbn1cblxuU2hhMjU2LnByb3RvdHlwZS5faGFzaCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIEggPSBuZXcgQnVmZmVyKDMyKVxuXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2EsIDApXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2IsIDQpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2MsIDgpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2QsIDEyKVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9lLCAxNilcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZiwgMjApXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2csIDI0KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9oLCAyOClcblxuICByZXR1cm4gSFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNoYTI1NlxuIiwidmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIFNIQTUxMiA9IHJlcXVpcmUoJy4vc2hhNTEyJylcbnZhciBIYXNoID0gcmVxdWlyZSgnLi9oYXNoJylcblxudmFyIFcgPSBuZXcgQXJyYXkoMTYwKVxuXG5mdW5jdGlvbiBTaGEzODQgKCkge1xuICB0aGlzLmluaXQoKVxuICB0aGlzLl93ID0gV1xuXG4gIEhhc2guY2FsbCh0aGlzLCAxMjgsIDExMilcbn1cblxuaW5oZXJpdHMoU2hhMzg0LCBTSEE1MTIpXG5cblNoYTM4NC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fYSA9IDB4Y2JiYjlkNWQgfCAwXG4gIHRoaXMuX2IgPSAweDYyOWEyOTJhIHwgMFxuICB0aGlzLl9jID0gMHg5MTU5MDE1YSB8IDBcbiAgdGhpcy5fZCA9IDB4MTUyZmVjZDggfCAwXG4gIHRoaXMuX2UgPSAweDY3MzMyNjY3IHwgMFxuICB0aGlzLl9mID0gMHg4ZWI0NGE4NyB8IDBcbiAgdGhpcy5fZyA9IDB4ZGIwYzJlMGQgfCAwXG4gIHRoaXMuX2ggPSAweDQ3YjU0ODFkIHwgMFxuXG4gIHRoaXMuX2FsID0gMHhjMTA1OWVkOCB8IDBcbiAgdGhpcy5fYmwgPSAweDM2N2NkNTA3IHwgMFxuICB0aGlzLl9jbCA9IDB4MzA3MGRkMTcgfCAwXG4gIHRoaXMuX2RsID0gMHhmNzBlNTkzOSB8IDBcbiAgdGhpcy5fZWwgPSAweGZmYzAwYjMxIHwgMFxuICB0aGlzLl9mbCA9IDB4Njg1ODE1MTEgfCAwXG4gIHRoaXMuX2dsID0gMHg2NGY5OGZhNyB8IDBcbiAgdGhpcy5faGwgPSAweGJlZmE0ZmE0IHwgMFxuXG4gIHJldHVybiB0aGlzXG59XG5cblNoYTM4NC5wcm90b3R5cGUuX2hhc2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBIID0gbmV3IEJ1ZmZlcig0OClcblxuICBmdW5jdGlvbiB3cml0ZUludDY0QkUgKGgsIGwsIG9mZnNldCkge1xuICAgIEgud3JpdGVJbnQzMkJFKGgsIG9mZnNldClcbiAgICBILndyaXRlSW50MzJCRShsLCBvZmZzZXQgKyA0KVxuICB9XG5cbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2EsIHRoaXMuX2FsLCAwKVxuICB3cml0ZUludDY0QkUodGhpcy5fYiwgdGhpcy5fYmwsIDgpXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9jLCB0aGlzLl9jbCwgMTYpXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9kLCB0aGlzLl9kbCwgMjQpXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9lLCB0aGlzLl9lbCwgMzIpXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9mLCB0aGlzLl9mbCwgNDApXG5cbiAgcmV0dXJuIEhcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTaGEzODRcbiIsInZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBIYXNoID0gcmVxdWlyZSgnLi9oYXNoJylcblxudmFyIEsgPSBbXG4gIDB4NDI4YTJmOTgsIDB4ZDcyOGFlMjIsIDB4NzEzNzQ0OTEsIDB4MjNlZjY1Y2QsXG4gIDB4YjVjMGZiY2YsIDB4ZWM0ZDNiMmYsIDB4ZTliNWRiYTUsIDB4ODE4OWRiYmMsXG4gIDB4Mzk1NmMyNWIsIDB4ZjM0OGI1MzgsIDB4NTlmMTExZjEsIDB4YjYwNWQwMTksXG4gIDB4OTIzZjgyYTQsIDB4YWYxOTRmOWIsIDB4YWIxYzVlZDUsIDB4ZGE2ZDgxMTgsXG4gIDB4ZDgwN2FhOTgsIDB4YTMwMzAyNDIsIDB4MTI4MzViMDEsIDB4NDU3MDZmYmUsXG4gIDB4MjQzMTg1YmUsIDB4NGVlNGIyOGMsIDB4NTUwYzdkYzMsIDB4ZDVmZmI0ZTIsXG4gIDB4NzJiZTVkNzQsIDB4ZjI3Yjg5NmYsIDB4ODBkZWIxZmUsIDB4M2IxNjk2YjEsXG4gIDB4OWJkYzA2YTcsIDB4MjVjNzEyMzUsIDB4YzE5YmYxNzQsIDB4Y2Y2OTI2OTQsXG4gIDB4ZTQ5YjY5YzEsIDB4OWVmMTRhZDIsIDB4ZWZiZTQ3ODYsIDB4Mzg0ZjI1ZTMsXG4gIDB4MGZjMTlkYzYsIDB4OGI4Y2Q1YjUsIDB4MjQwY2ExY2MsIDB4NzdhYzljNjUsXG4gIDB4MmRlOTJjNmYsIDB4NTkyYjAyNzUsIDB4NGE3NDg0YWEsIDB4NmVhNmU0ODMsXG4gIDB4NWNiMGE5ZGMsIDB4YmQ0MWZiZDQsIDB4NzZmOTg4ZGEsIDB4ODMxMTUzYjUsXG4gIDB4OTgzZTUxNTIsIDB4ZWU2NmRmYWIsIDB4YTgzMWM2NmQsIDB4MmRiNDMyMTAsXG4gIDB4YjAwMzI3YzgsIDB4OThmYjIxM2YsIDB4YmY1OTdmYzcsIDB4YmVlZjBlZTQsXG4gIDB4YzZlMDBiZjMsIDB4M2RhODhmYzIsIDB4ZDVhNzkxNDcsIDB4OTMwYWE3MjUsXG4gIDB4MDZjYTYzNTEsIDB4ZTAwMzgyNmYsIDB4MTQyOTI5NjcsIDB4MGEwZTZlNzAsXG4gIDB4MjdiNzBhODUsIDB4NDZkMjJmZmMsIDB4MmUxYjIxMzgsIDB4NWMyNmM5MjYsXG4gIDB4NGQyYzZkZmMsIDB4NWFjNDJhZWQsIDB4NTMzODBkMTMsIDB4OWQ5NWIzZGYsXG4gIDB4NjUwYTczNTQsIDB4OGJhZjYzZGUsIDB4NzY2YTBhYmIsIDB4M2M3N2IyYTgsXG4gIDB4ODFjMmM5MmUsIDB4NDdlZGFlZTYsIDB4OTI3MjJjODUsIDB4MTQ4MjM1M2IsXG4gIDB4YTJiZmU4YTEsIDB4NGNmMTAzNjQsIDB4YTgxYTY2NGIsIDB4YmM0MjMwMDEsXG4gIDB4YzI0YjhiNzAsIDB4ZDBmODk3OTEsIDB4Yzc2YzUxYTMsIDB4MDY1NGJlMzAsXG4gIDB4ZDE5MmU4MTksIDB4ZDZlZjUyMTgsIDB4ZDY5OTA2MjQsIDB4NTU2NWE5MTAsXG4gIDB4ZjQwZTM1ODUsIDB4NTc3MTIwMmEsIDB4MTA2YWEwNzAsIDB4MzJiYmQxYjgsXG4gIDB4MTlhNGMxMTYsIDB4YjhkMmQwYzgsIDB4MWUzNzZjMDgsIDB4NTE0MWFiNTMsXG4gIDB4Mjc0ODc3NGMsIDB4ZGY4ZWViOTksIDB4MzRiMGJjYjUsIDB4ZTE5YjQ4YTgsXG4gIDB4MzkxYzBjYjMsIDB4YzVjOTVhNjMsIDB4NGVkOGFhNGEsIDB4ZTM0MThhY2IsXG4gIDB4NWI5Y2NhNGYsIDB4Nzc2M2UzNzMsIDB4NjgyZTZmZjMsIDB4ZDZiMmI4YTMsXG4gIDB4NzQ4ZjgyZWUsIDB4NWRlZmIyZmMsIDB4NzhhNTYzNmYsIDB4NDMxNzJmNjAsXG4gIDB4ODRjODc4MTQsIDB4YTFmMGFiNzIsIDB4OGNjNzAyMDgsIDB4MWE2NDM5ZWMsXG4gIDB4OTBiZWZmZmEsIDB4MjM2MzFlMjgsIDB4YTQ1MDZjZWIsIDB4ZGU4MmJkZTksXG4gIDB4YmVmOWEzZjcsIDB4YjJjNjc5MTUsIDB4YzY3MTc4ZjIsIDB4ZTM3MjUzMmIsXG4gIDB4Y2EyNzNlY2UsIDB4ZWEyNjYxOWMsIDB4ZDE4NmI4YzcsIDB4MjFjMGMyMDcsXG4gIDB4ZWFkYTdkZDYsIDB4Y2RlMGViMWUsIDB4ZjU3ZDRmN2YsIDB4ZWU2ZWQxNzgsXG4gIDB4MDZmMDY3YWEsIDB4NzIxNzZmYmEsIDB4MGE2MzdkYzUsIDB4YTJjODk4YTYsXG4gIDB4MTEzZjk4MDQsIDB4YmVmOTBkYWUsIDB4MWI3MTBiMzUsIDB4MTMxYzQ3MWIsXG4gIDB4MjhkYjc3ZjUsIDB4MjMwNDdkODQsIDB4MzJjYWFiN2IsIDB4NDBjNzI0OTMsXG4gIDB4M2M5ZWJlMGEsIDB4MTVjOWJlYmMsIDB4NDMxZDY3YzQsIDB4OWMxMDBkNGMsXG4gIDB4NGNjNWQ0YmUsIDB4Y2IzZTQyYjYsIDB4NTk3ZjI5OWMsIDB4ZmM2NTdlMmEsXG4gIDB4NWZjYjZmYWIsIDB4M2FkNmZhZWMsIDB4NmM0NDE5OGMsIDB4NGE0NzU4MTdcbl1cblxudmFyIFcgPSBuZXcgQXJyYXkoMTYwKVxuXG5mdW5jdGlvbiBTaGE1MTIgKCkge1xuICB0aGlzLmluaXQoKVxuICB0aGlzLl93ID0gV1xuXG4gIEhhc2guY2FsbCh0aGlzLCAxMjgsIDExMilcbn1cblxuaW5oZXJpdHMoU2hhNTEyLCBIYXNoKVxuXG5TaGE1MTIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX2EgPSAweDZhMDllNjY3IHwgMFxuICB0aGlzLl9iID0gMHhiYjY3YWU4NSB8IDBcbiAgdGhpcy5fYyA9IDB4M2M2ZWYzNzIgfCAwXG4gIHRoaXMuX2QgPSAweGE1NGZmNTNhIHwgMFxuICB0aGlzLl9lID0gMHg1MTBlNTI3ZiB8IDBcbiAgdGhpcy5fZiA9IDB4OWIwNTY4OGMgfCAwXG4gIHRoaXMuX2cgPSAweDFmODNkOWFiIHwgMFxuICB0aGlzLl9oID0gMHg1YmUwY2QxOSB8IDBcblxuICB0aGlzLl9hbCA9IDB4ZjNiY2M5MDggfCAwXG4gIHRoaXMuX2JsID0gMHg4NGNhYTczYiB8IDBcbiAgdGhpcy5fY2wgPSAweGZlOTRmODJiIHwgMFxuICB0aGlzLl9kbCA9IDB4NWYxZDM2ZjEgfCAwXG4gIHRoaXMuX2VsID0gMHhhZGU2ODJkMSB8IDBcbiAgdGhpcy5fZmwgPSAweDJiM2U2YzFmIHwgMFxuICB0aGlzLl9nbCA9IDB4ZmI0MWJkNmIgfCAwXG4gIHRoaXMuX2hsID0gMHgxMzdlMjE3OSB8IDBcblxuICByZXR1cm4gdGhpc1xufVxuXG5mdW5jdGlvbiBDaCAoeCwgeSwgeikge1xuICByZXR1cm4geiBeICh4ICYgKHkgXiB6KSlcbn1cblxuZnVuY3Rpb24gTWFqICh4LCB5LCB6KSB7XG4gIHJldHVybiAoeCAmIHkpIHwgKHogJiAoeCB8IHkpKVxufVxuXG5mdW5jdGlvbiBTaWdtYTAgKHgsIHhsKSB7XG4gIHJldHVybiAoeCA+Pj4gMjggfCB4bCA8PCA0KSBeICh4bCA+Pj4gMiB8IHggPDwgMzApIF4gKHhsID4+PiA3IHwgeCA8PCAyNSlcbn1cblxuZnVuY3Rpb24gU2lnbWExICh4LCB4bCkge1xuICByZXR1cm4gKHggPj4+IDE0IHwgeGwgPDwgMTgpIF4gKHggPj4+IDE4IHwgeGwgPDwgMTQpIF4gKHhsID4+PiA5IHwgeCA8PCAyMylcbn1cblxuZnVuY3Rpb24gR2FtbWEwICh4LCB4bCkge1xuICByZXR1cm4gKHggPj4+IDEgfCB4bCA8PCAzMSkgXiAoeCA+Pj4gOCB8IHhsIDw8IDI0KSBeICh4ID4+PiA3KVxufVxuXG5mdW5jdGlvbiBHYW1tYTBsICh4LCB4bCkge1xuICByZXR1cm4gKHggPj4+IDEgfCB4bCA8PCAzMSkgXiAoeCA+Pj4gOCB8IHhsIDw8IDI0KSBeICh4ID4+PiA3IHwgeGwgPDwgMjUpXG59XG5cbmZ1bmN0aW9uIEdhbW1hMSAoeCwgeGwpIHtcbiAgcmV0dXJuICh4ID4+PiAxOSB8IHhsIDw8IDEzKSBeICh4bCA+Pj4gMjkgfCB4IDw8IDMpIF4gKHggPj4+IDYpXG59XG5cbmZ1bmN0aW9uIEdhbW1hMWwgKHgsIHhsKSB7XG4gIHJldHVybiAoeCA+Pj4gMTkgfCB4bCA8PCAxMykgXiAoeGwgPj4+IDI5IHwgeCA8PCAzKSBeICh4ID4+PiA2IHwgeGwgPDwgMjYpXG59XG5cblNoYTUxMi5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChNKSB7XG4gIHZhciBXID0gdGhpcy5fd1xuXG4gIHZhciBhID0gdGhpcy5fYSB8IDBcbiAgdmFyIGIgPSB0aGlzLl9iIHwgMFxuICB2YXIgYyA9IHRoaXMuX2MgfCAwXG4gIHZhciBkID0gdGhpcy5fZCB8IDBcbiAgdmFyIGUgPSB0aGlzLl9lIHwgMFxuICB2YXIgZiA9IHRoaXMuX2YgfCAwXG4gIHZhciBnID0gdGhpcy5fZyB8IDBcbiAgdmFyIGggPSB0aGlzLl9oIHwgMFxuXG4gIHZhciBhbCA9IHRoaXMuX2FsIHwgMFxuICB2YXIgYmwgPSB0aGlzLl9ibCB8IDBcbiAgdmFyIGNsID0gdGhpcy5fY2wgfCAwXG4gIHZhciBkbCA9IHRoaXMuX2RsIHwgMFxuICB2YXIgZWwgPSB0aGlzLl9lbCB8IDBcbiAgdmFyIGZsID0gdGhpcy5fZmwgfCAwXG4gIHZhciBnbCA9IHRoaXMuX2dsIHwgMFxuICB2YXIgaGwgPSB0aGlzLl9obCB8IDBcblxuICB2YXIgaSA9IDBcbiAgdmFyIGogPSAwXG4gIHZhciBXaSwgV2lsXG4gIGZ1bmN0aW9uIGNhbGNXICgpIHtcbiAgICB2YXIgeCA9IFdbaiAtIDE1ICogMl1cbiAgICB2YXIgeGwgPSBXW2ogLSAxNSAqIDIgKyAxXVxuICAgIHZhciBnYW1tYTAgPSBHYW1tYTAoeCwgeGwpXG4gICAgdmFyIGdhbW1hMGwgPSBHYW1tYTBsKHhsLCB4KVxuXG4gICAgeCA9IFdbaiAtIDIgKiAyXVxuICAgIHhsID0gV1tqIC0gMiAqIDIgKyAxXVxuICAgIHZhciBnYW1tYTEgPSBHYW1tYTEoeCwgeGwpXG4gICAgdmFyIGdhbW1hMWwgPSBHYW1tYTFsKHhsLCB4KVxuXG4gICAgLy8gV1tpXSA9IGdhbW1hMCArIFdbaSAtIDddICsgZ2FtbWExICsgV1tpIC0gMTZdXG4gICAgdmFyIFdpNyA9IFdbaiAtIDcgKiAyXVxuICAgIHZhciBXaTdsID0gV1tqIC0gNyAqIDIgKyAxXVxuXG4gICAgdmFyIFdpMTYgPSBXW2ogLSAxNiAqIDJdXG4gICAgdmFyIFdpMTZsID0gV1tqIC0gMTYgKiAyICsgMV1cblxuICAgIFdpbCA9IGdhbW1hMGwgKyBXaTdsXG4gICAgV2kgPSBnYW1tYTAgKyBXaTcgKyAoKFdpbCA+Pj4gMCkgPCAoZ2FtbWEwbCA+Pj4gMCkgPyAxIDogMClcbiAgICBXaWwgPSBXaWwgKyBnYW1tYTFsXG4gICAgV2kgPSBXaSArIGdhbW1hMSArICgoV2lsID4+PiAwKSA8IChnYW1tYTFsID4+PiAwKSA/IDEgOiAwKVxuICAgIFdpbCA9IFdpbCArIFdpMTZsXG4gICAgV2kgPSBXaSArIFdpMTYgKyAoKFdpbCA+Pj4gMCkgPCAoV2kxNmwgPj4+IDApID8gMSA6IDApXG4gIH1cblxuICBmdW5jdGlvbiBsb29wICgpIHtcbiAgICBXW2pdID0gV2lcbiAgICBXW2ogKyAxXSA9IFdpbFxuXG4gICAgdmFyIG1haiA9IE1haihhLCBiLCBjKVxuICAgIHZhciBtYWpsID0gTWFqKGFsLCBibCwgY2wpXG5cbiAgICB2YXIgc2lnbWEwaCA9IFNpZ21hMChhLCBhbClcbiAgICB2YXIgc2lnbWEwbCA9IFNpZ21hMChhbCwgYSlcbiAgICB2YXIgc2lnbWExaCA9IFNpZ21hMShlLCBlbClcbiAgICB2YXIgc2lnbWExbCA9IFNpZ21hMShlbCwgZSlcblxuICAgIC8vIHQxID0gaCArIHNpZ21hMSArIGNoICsgS1tpXSArIFdbaV1cbiAgICB2YXIgS2kgPSBLW2pdXG4gICAgdmFyIEtpbCA9IEtbaiArIDFdXG5cbiAgICB2YXIgY2ggPSBDaChlLCBmLCBnKVxuICAgIHZhciBjaGwgPSBDaChlbCwgZmwsIGdsKVxuXG4gICAgdmFyIHQxbCA9IGhsICsgc2lnbWExbFxuICAgIHZhciB0MSA9IGggKyBzaWdtYTFoICsgKCh0MWwgPj4+IDApIDwgKGhsID4+PiAwKSA/IDEgOiAwKVxuICAgIHQxbCA9IHQxbCArIGNobFxuICAgIHQxID0gdDEgKyBjaCArICgodDFsID4+PiAwKSA8IChjaGwgPj4+IDApID8gMSA6IDApXG4gICAgdDFsID0gdDFsICsgS2lsXG4gICAgdDEgPSB0MSArIEtpICsgKCh0MWwgPj4+IDApIDwgKEtpbCA+Pj4gMCkgPyAxIDogMClcbiAgICB0MWwgPSB0MWwgKyBXaWxcbiAgICB0MSA9IHQxICsgV2kgKyAoKHQxbCA+Pj4gMCkgPCAoV2lsID4+PiAwKSA/IDEgOiAwKVxuXG4gICAgLy8gdDIgPSBzaWdtYTAgKyBtYWpcbiAgICB2YXIgdDJsID0gc2lnbWEwbCArIG1hamxcbiAgICB2YXIgdDIgPSBzaWdtYTBoICsgbWFqICsgKCh0MmwgPj4+IDApIDwgKHNpZ21hMGwgPj4+IDApID8gMSA6IDApXG5cbiAgICBoID0gZ1xuICAgIGhsID0gZ2xcbiAgICBnID0gZlxuICAgIGdsID0gZmxcbiAgICBmID0gZVxuICAgIGZsID0gZWxcbiAgICBlbCA9IChkbCArIHQxbCkgfCAwXG4gICAgZSA9IChkICsgdDEgKyAoKGVsID4+PiAwKSA8IChkbCA+Pj4gMCkgPyAxIDogMCkpIHwgMFxuICAgIGQgPSBjXG4gICAgZGwgPSBjbFxuICAgIGMgPSBiXG4gICAgY2wgPSBibFxuICAgIGIgPSBhXG4gICAgYmwgPSBhbFxuICAgIGFsID0gKHQxbCArIHQybCkgfCAwXG4gICAgYSA9ICh0MSArIHQyICsgKChhbCA+Pj4gMCkgPCAodDFsID4+PiAwKSA/IDEgOiAwKSkgfCAwXG5cbiAgICBpKytcbiAgICBqICs9IDJcbiAgfVxuXG4gIHdoaWxlIChpIDwgMTYpIHtcbiAgICBXaSA9IE0ucmVhZEludDMyQkUoaiAqIDQpXG4gICAgV2lsID0gTS5yZWFkSW50MzJCRShqICogNCArIDQpXG5cbiAgICBsb29wKClcbiAgfVxuXG4gIHdoaWxlIChpIDwgODApIHtcbiAgICBjYWxjVygpXG4gICAgbG9vcCgpXG4gIH1cblxuICB0aGlzLl9hbCA9ICh0aGlzLl9hbCArIGFsKSB8IDBcbiAgdGhpcy5fYmwgPSAodGhpcy5fYmwgKyBibCkgfCAwXG4gIHRoaXMuX2NsID0gKHRoaXMuX2NsICsgY2wpIHwgMFxuICB0aGlzLl9kbCA9ICh0aGlzLl9kbCArIGRsKSB8IDBcbiAgdGhpcy5fZWwgPSAodGhpcy5fZWwgKyBlbCkgfCAwXG4gIHRoaXMuX2ZsID0gKHRoaXMuX2ZsICsgZmwpIHwgMFxuICB0aGlzLl9nbCA9ICh0aGlzLl9nbCArIGdsKSB8IDBcbiAgdGhpcy5faGwgPSAodGhpcy5faGwgKyBobCkgfCAwXG5cbiAgdGhpcy5fYSA9ICh0aGlzLl9hICsgYSArICgodGhpcy5fYWwgPj4+IDApIDwgKGFsID4+PiAwKSA/IDEgOiAwKSkgfCAwXG4gIHRoaXMuX2IgPSAodGhpcy5fYiArIGIgKyAoKHRoaXMuX2JsID4+PiAwKSA8IChibCA+Pj4gMCkgPyAxIDogMCkpIHwgMFxuICB0aGlzLl9jID0gKHRoaXMuX2MgKyBjICsgKCh0aGlzLl9jbCA+Pj4gMCkgPCAoY2wgPj4+IDApID8gMSA6IDApKSB8IDBcbiAgdGhpcy5fZCA9ICh0aGlzLl9kICsgZCArICgodGhpcy5fZGwgPj4+IDApIDwgKGRsID4+PiAwKSA/IDEgOiAwKSkgfCAwXG4gIHRoaXMuX2UgPSAodGhpcy5fZSArIGUgKyAoKHRoaXMuX2VsID4+PiAwKSA8IChlbCA+Pj4gMCkgPyAxIDogMCkpIHwgMFxuICB0aGlzLl9mID0gKHRoaXMuX2YgKyBmICsgKCh0aGlzLl9mbCA+Pj4gMCkgPCAoZmwgPj4+IDApID8gMSA6IDApKSB8IDBcbiAgdGhpcy5fZyA9ICh0aGlzLl9nICsgZyArICgodGhpcy5fZ2wgPj4+IDApIDwgKGdsID4+PiAwKSA/IDEgOiAwKSkgfCAwXG4gIHRoaXMuX2ggPSAodGhpcy5faCArIGggKyAoKHRoaXMuX2hsID4+PiAwKSA8IChobCA+Pj4gMCkgPyAxIDogMCkpIHwgMFxufVxuXG5TaGE1MTIucHJvdG90eXBlLl9oYXNoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgSCA9IG5ldyBCdWZmZXIoNjQpXG5cbiAgZnVuY3Rpb24gd3JpdGVJbnQ2NEJFIChoLCBsLCBvZmZzZXQpIHtcbiAgICBILndyaXRlSW50MzJCRShoLCBvZmZzZXQpXG4gICAgSC53cml0ZUludDMyQkUobCwgb2Zmc2V0ICsgNClcbiAgfVxuXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9hLCB0aGlzLl9hbCwgMClcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2IsIHRoaXMuX2JsLCA4KVxuICB3cml0ZUludDY0QkUodGhpcy5fYywgdGhpcy5fY2wsIDE2KVxuICB3cml0ZUludDY0QkUodGhpcy5fZCwgdGhpcy5fZGwsIDI0KVxuICB3cml0ZUludDY0QkUodGhpcy5fZSwgdGhpcy5fZWwsIDMyKVxuICB3cml0ZUludDY0QkUodGhpcy5fZiwgdGhpcy5fZmwsIDQwKVxuICB3cml0ZUludDY0QkUodGhpcy5fZywgdGhpcy5fZ2wsIDQ4KVxuICB3cml0ZUludDY0QkUodGhpcy5faCwgdGhpcy5faGwsIDU2KVxuXG4gIHJldHVybiBIXG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2hhNTEyXG4iLCIndXNlIHN0cmljdCc7XG52YXIgY3JlYXRlSGFzaCA9IHJlcXVpcmUoJ2NyZWF0ZS1oYXNoL2Jyb3dzZXInKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcblxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJ3N0cmVhbScpLlRyYW5zZm9ybVxuXG52YXIgWkVST1MgPSBuZXcgQnVmZmVyKDEyOClcblpFUk9TLmZpbGwoMClcblxuZnVuY3Rpb24gSG1hYyhhbGcsIGtleSkge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzKVxuICBhbGcgPSBhbGcudG9Mb3dlckNhc2UoKVxuICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycpIHtcbiAgICBrZXkgPSBuZXcgQnVmZmVyKGtleSlcbiAgfVxuXG4gIHZhciBibG9ja3NpemUgPSAoYWxnID09PSAnc2hhNTEyJyB8fCBhbGcgPT09ICdzaGEzODQnKSA/IDEyOCA6IDY0XG5cbiAgdGhpcy5fYWxnID0gYWxnXG4gIHRoaXMuX2tleSA9IGtleVxuXG4gIGlmIChrZXkubGVuZ3RoID4gYmxvY2tzaXplKSB7XG4gICAga2V5ID0gY3JlYXRlSGFzaChhbGcpLnVwZGF0ZShrZXkpLmRpZ2VzdCgpXG5cbiAgfSBlbHNlIGlmIChrZXkubGVuZ3RoIDwgYmxvY2tzaXplKSB7XG4gICAga2V5ID0gQnVmZmVyLmNvbmNhdChba2V5LCBaRVJPU10sIGJsb2Nrc2l6ZSlcbiAgfVxuXG4gIHZhciBpcGFkID0gdGhpcy5faXBhZCA9IG5ldyBCdWZmZXIoYmxvY2tzaXplKVxuICB2YXIgb3BhZCA9IHRoaXMuX29wYWQgPSBuZXcgQnVmZmVyKGJsb2Nrc2l6ZSlcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGJsb2Nrc2l6ZTsgaSsrKSB7XG4gICAgaXBhZFtpXSA9IGtleVtpXSBeIDB4MzZcbiAgICBvcGFkW2ldID0ga2V5W2ldIF4gMHg1Q1xuICB9XG5cbiAgdGhpcy5faGFzaCA9IGNyZWF0ZUhhc2goYWxnKS51cGRhdGUoaXBhZClcbn1cblxuaW5oZXJpdHMoSG1hYywgVHJhbnNmb3JtKVxuXG5IbWFjLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGF0YSwgZW5jKSB7XG4gIHRoaXMuX2hhc2gudXBkYXRlKGRhdGEsIGVuYylcblxuICByZXR1cm4gdGhpc1xufVxuXG5IbWFjLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGRhdGEsIF8sIG5leHQpIHtcbiAgdGhpcy5faGFzaC51cGRhdGUoZGF0YSlcblxuICBuZXh0KClcbn1cblxuSG1hYy5wcm90b3R5cGUuX2ZsdXNoID0gZnVuY3Rpb24gKG5leHQpIHtcbiAgdGhpcy5wdXNoKHRoaXMuZGlnZXN0KCkpXG5cbiAgbmV4dCgpXG59XG5cbkhtYWMucHJvdG90eXBlLmRpZ2VzdCA9IGZ1bmN0aW9uIChlbmMpIHtcbiAgdmFyIGggPSB0aGlzLl9oYXNoLmRpZ2VzdCgpXG5cbiAgcmV0dXJuIGNyZWF0ZUhhc2godGhpcy5fYWxnKS51cGRhdGUodGhpcy5fb3BhZCkudXBkYXRlKGgpLmRpZ2VzdChlbmMpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlSG1hYyhhbGcsIGtleSkge1xuICByZXR1cm4gbmV3IEhtYWMoYWxnLCBrZXkpXG59XG4iLCJ2YXIgZ2VuZXJhdGVQcmltZSA9IHJlcXVpcmUoJy4vbGliL2dlbmVyYXRlUHJpbWUnKTtcbnZhciBwcmltZXMgPSByZXF1aXJlKCcuL2xpYi9wcmltZXMnKTtcblxudmFyIERIID0gcmVxdWlyZSgnLi9saWIvZGgnKTtcblxuZnVuY3Rpb24gZ2V0RGlmZmllSGVsbG1hbihtb2QpIHtcbiAgdmFyIHByaW1lID0gbmV3IEJ1ZmZlcihwcmltZXNbbW9kXS5wcmltZSwgJ2hleCcpO1xuICB2YXIgZ2VuID0gbmV3IEJ1ZmZlcihwcmltZXNbbW9kXS5nZW4sICdoZXgnKTtcblxuICByZXR1cm4gbmV3IERIKHByaW1lLCBnZW4pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVEaWZmaWVIZWxsbWFuKHByaW1lLCBlbmMsIGdlbmVyYXRvciwgZ2VuYykge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGVuYykgfHwgKHR5cGVvZiBlbmMgPT09ICdzdHJpbmcnICYmIFsnaGV4JywgJ2JpbmFyeScsICdiYXNlNjQnXS5pbmRleE9mKGVuYykgPT09IC0xKSkge1xuICAgIGdlbmMgPSBnZW5lcmF0b3I7XG4gICAgZ2VuZXJhdG9yID0gZW5jO1xuICAgIGVuYyA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGVuYyA9IGVuYyB8fCAnYmluYXJ5JztcbiAgZ2VuYyA9IGdlbmMgfHwgJ2JpbmFyeSc7XG4gIGdlbmVyYXRvciA9IGdlbmVyYXRvciB8fCBuZXcgQnVmZmVyKFsyXSk7XG5cbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoZ2VuZXJhdG9yKSkge1xuICAgIGdlbmVyYXRvciA9IG5ldyBCdWZmZXIoZ2VuZXJhdG9yLCBnZW5jKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcHJpbWUgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIG5ldyBESChnZW5lcmF0ZVByaW1lKHByaW1lLCBnZW5lcmF0b3IpLCBnZW5lcmF0b3IsIHRydWUpO1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIocHJpbWUpKSB7XG4gICAgcHJpbWUgPSBuZXcgQnVmZmVyKHByaW1lLCBlbmMpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBESChwcmltZSwgZ2VuZXJhdG9yLCB0cnVlKTtcbn1cblxuZXhwb3J0cy5EaWZmaWVIZWxsbWFuR3JvdXAgPSBleHBvcnRzLmNyZWF0ZURpZmZpZUhlbGxtYW5Hcm91cCA9IGV4cG9ydHMuZ2V0RGlmZmllSGVsbG1hbiA9IGdldERpZmZpZUhlbGxtYW47XG5leHBvcnRzLmNyZWF0ZURpZmZpZUhlbGxtYW4gPSBleHBvcnRzLkRpZmZpZUhlbGxtYW4gPSBjcmVhdGVEaWZmaWVIZWxsbWFuO1xuIiwidmFyIEJOID0gcmVxdWlyZSgnYm4uanMnKTtcbnZhciBNaWxsZXJSYWJpbiA9IHJlcXVpcmUoJ21pbGxlci1yYWJpbicpO1xudmFyIG1pbGxlclJhYmluID0gbmV3IE1pbGxlclJhYmluKCk7XG52YXIgVFdFTlRZRk9VUiA9IG5ldyBCTigyNCk7XG52YXIgRUxFVkVOID0gbmV3IEJOKDExKTtcbnZhciBURU4gPSBuZXcgQk4oMTApO1xudmFyIFRIUkVFID0gbmV3IEJOKDMpO1xudmFyIFNFVkVOID0gbmV3IEJOKDcpO1xudmFyIHByaW1lcyA9IHJlcXVpcmUoJy4vZ2VuZXJhdGVQcmltZScpO1xudmFyIHJhbmRvbUJ5dGVzID0gcmVxdWlyZSgncmFuZG9tYnl0ZXMnKTtcbm1vZHVsZS5leHBvcnRzID0gREg7XG5cbmZ1bmN0aW9uIHNldFB1YmxpY0tleShwdWIsIGVuYykge1xuICBlbmMgPSBlbmMgfHwgJ3V0ZjgnO1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihwdWIpKSB7XG4gICAgcHViID0gbmV3IEJ1ZmZlcihwdWIsIGVuYyk7XG4gIH1cbiAgdGhpcy5fcHViID0gbmV3IEJOKHB1Yik7XG4gIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiBzZXRQcml2YXRlS2V5KHByaXYsIGVuYykge1xuICBlbmMgPSBlbmMgfHwgJ3V0ZjgnO1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihwcml2KSkge1xuICAgIHByaXYgPSBuZXcgQnVmZmVyKHByaXYsIGVuYyk7XG4gIH1cbiAgdGhpcy5fcHJpdiA9IG5ldyBCTihwcml2KTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbnZhciBwcmltZUNhY2hlID0ge307XG5mdW5jdGlvbiBjaGVja1ByaW1lKHByaW1lLCBnZW5lcmF0b3IpIHtcbiAgdmFyIGdlbiA9IGdlbmVyYXRvci50b1N0cmluZygnaGV4Jyk7XG4gIHZhciBoZXggPSBbZ2VuLCBwcmltZS50b1N0cmluZygxNildLmpvaW4oJ18nKTtcbiAgaWYgKGhleCBpbiBwcmltZUNhY2hlKSB7XG4gICAgcmV0dXJuIHByaW1lQ2FjaGVbaGV4XTtcbiAgfVxuICB2YXIgZXJyb3IgPSAwO1xuXG4gIGlmIChwcmltZS5pc0V2ZW4oKSB8fFxuICAgICFwcmltZXMuc2ltcGxlU2lldmUgfHxcbiAgICAhcHJpbWVzLmZlcm1hdFRlc3QocHJpbWUpIHx8XG4gICAgIW1pbGxlclJhYmluLnRlc3QocHJpbWUpKSB7XG4gICAgLy9ub3QgYSBwcmltZSBzbyArMVxuICAgIGVycm9yICs9IDE7XG5cbiAgICBpZiAoZ2VuID09PSAnMDInIHx8IGdlbiA9PT0gJzA1Jykge1xuICAgICAgLy8gd2UnZCBiZSBhYmxlIHRvIGNoZWNrIHRoZSBnZW5lcmF0b3JcbiAgICAgIC8vIGl0IHdvdWxkIGZhaWwgc28gKzhcbiAgICAgIGVycm9yICs9IDg7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vd2Ugd291bGRuJ3QgYmUgYWJsZSB0byB0ZXN0IHRoZSBnZW5lcmF0b3JcbiAgICAgIC8vIHNvICs0XG4gICAgICBlcnJvciArPSA0O1xuICAgIH1cbiAgICBwcmltZUNhY2hlW2hleF0gPSBlcnJvcjtcbiAgICByZXR1cm4gZXJyb3I7XG4gIH1cbiAgaWYgKCFtaWxsZXJSYWJpbi50ZXN0KHByaW1lLnNocm4oMSkpKSB7XG4gICAgLy9ub3QgYSBzYWZlIHByaW1lXG4gICAgZXJyb3IgKz0gMjtcbiAgfVxuICB2YXIgcmVtO1xuICBzd2l0Y2ggKGdlbikge1xuICAgIGNhc2UgJzAyJzpcbiAgICAgIGlmIChwcmltZS5tb2QoVFdFTlRZRk9VUikuY21wKEVMRVZFTikpIHtcbiAgICAgICAgLy8gdW5zdWlkYWJsZSBnZW5lcmF0b3JcbiAgICAgICAgZXJyb3IgKz0gODtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJzA1JzpcbiAgICAgIHJlbSA9IHByaW1lLm1vZChURU4pO1xuICAgICAgaWYgKHJlbS5jbXAoVEhSRUUpICYmIHJlbS5jbXAoU0VWRU4pKSB7XG4gICAgICAgIC8vIHByaW1lIG1vZCAxMCBuZWVkcyB0byBlcXVhbCAzIG9yIDdcbiAgICAgICAgZXJyb3IgKz0gODtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBlcnJvciArPSA0O1xuICB9XG4gIHByaW1lQ2FjaGVbaGV4XSA9IGVycm9yO1xuICByZXR1cm4gZXJyb3I7XG59XG5cbmZ1bmN0aW9uIERIKHByaW1lLCBnZW5lcmF0b3IsIG1hbGxlYWJsZSkge1xuICB0aGlzLnNldEdlbmVyYXRvcihnZW5lcmF0b3IpO1xuICB0aGlzLl9fcHJpbWUgPSBuZXcgQk4ocHJpbWUpO1xuICB0aGlzLl9wcmltZSA9IEJOLm1vbnQodGhpcy5fX3ByaW1lKTtcbiAgdGhpcy5fcHJpbWVMZW4gPSBwcmltZS5sZW5ndGg7XG4gIHRoaXMuX3B1YiA9IHVuZGVmaW5lZDtcbiAgdGhpcy5fcHJpdiA9IHVuZGVmaW5lZDtcbiAgdGhpcy5fcHJpbWVDb2RlID0gdW5kZWZpbmVkO1xuICBpZiAobWFsbGVhYmxlKSB7XG4gICAgdGhpcy5zZXRQdWJsaWNLZXkgPSBzZXRQdWJsaWNLZXk7XG4gICAgdGhpcy5zZXRQcml2YXRlS2V5ID0gc2V0UHJpdmF0ZUtleTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9wcmltZUNvZGUgPSA4O1xuICB9XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoREgucHJvdG90eXBlLCAndmVyaWZ5RXJyb3InLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5fcHJpbWVDb2RlICE9PSAnbnVtYmVyJykge1xuICAgICAgdGhpcy5fcHJpbWVDb2RlID0gY2hlY2tQcmltZSh0aGlzLl9fcHJpbWUsIHRoaXMuX19nZW4pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcHJpbWVDb2RlO1xuICB9XG59KTtcbkRILnByb3RvdHlwZS5nZW5lcmF0ZUtleXMgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5fcHJpdikge1xuICAgIHRoaXMuX3ByaXYgPSBuZXcgQk4ocmFuZG9tQnl0ZXModGhpcy5fcHJpbWVMZW4pKTtcbiAgfVxuICB0aGlzLl9wdWIgPSB0aGlzLl9nZW4udG9SZWQodGhpcy5fcHJpbWUpLnJlZFBvdyh0aGlzLl9wcml2KS5mcm9tUmVkKCk7XG4gIHJldHVybiB0aGlzLmdldFB1YmxpY0tleSgpO1xufTtcblxuREgucHJvdG90eXBlLmNvbXB1dGVTZWNyZXQgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgb3RoZXIgPSBuZXcgQk4ob3RoZXIpO1xuICBvdGhlciA9IG90aGVyLnRvUmVkKHRoaXMuX3ByaW1lKTtcbiAgdmFyIHNlY3JldCA9IG90aGVyLnJlZFBvdyh0aGlzLl9wcml2KS5mcm9tUmVkKCk7XG4gIHZhciBvdXQgPSBuZXcgQnVmZmVyKHNlY3JldC50b0FycmF5KCkpO1xuICB2YXIgcHJpbWUgPSB0aGlzLmdldFByaW1lKCk7XG4gIGlmIChvdXQubGVuZ3RoIDwgcHJpbWUubGVuZ3RoKSB7XG4gICAgdmFyIGZyb250ID0gbmV3IEJ1ZmZlcihwcmltZS5sZW5ndGggLSBvdXQubGVuZ3RoKTtcbiAgICBmcm9udC5maWxsKDApO1xuICAgIG91dCA9IEJ1ZmZlci5jb25jYXQoW2Zyb250LCBvdXRdKTtcbiAgfVxuICByZXR1cm4gb3V0O1xufTtcblxuREgucHJvdG90eXBlLmdldFB1YmxpY0tleSA9IGZ1bmN0aW9uIGdldFB1YmxpY0tleShlbmMpIHtcbiAgcmV0dXJuIGZvcm1hdFJldHVyblZhbHVlKHRoaXMuX3B1YiwgZW5jKTtcbn07XG5cbkRILnByb3RvdHlwZS5nZXRQcml2YXRlS2V5ID0gZnVuY3Rpb24gZ2V0UHJpdmF0ZUtleShlbmMpIHtcbiAgcmV0dXJuIGZvcm1hdFJldHVyblZhbHVlKHRoaXMuX3ByaXYsIGVuYyk7XG59O1xuXG5ESC5wcm90b3R5cGUuZ2V0UHJpbWUgPSBmdW5jdGlvbiAoZW5jKSB7XG4gIHJldHVybiBmb3JtYXRSZXR1cm5WYWx1ZSh0aGlzLl9fcHJpbWUsIGVuYyk7XG59O1xuXG5ESC5wcm90b3R5cGUuZ2V0R2VuZXJhdG9yID0gZnVuY3Rpb24gKGVuYykge1xuICByZXR1cm4gZm9ybWF0UmV0dXJuVmFsdWUodGhpcy5fZ2VuLCBlbmMpO1xufTtcblxuREgucHJvdG90eXBlLnNldEdlbmVyYXRvciA9IGZ1bmN0aW9uIChnZW4sIGVuYykge1xuICBlbmMgPSBlbmMgfHwgJ3V0ZjgnO1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihnZW4pKSB7XG4gICAgZ2VuID0gbmV3IEJ1ZmZlcihnZW4sIGVuYyk7XG4gIH1cbiAgdGhpcy5fX2dlbiA9IGdlbjtcbiAgdGhpcy5fZ2VuID0gbmV3IEJOKGdlbik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gZm9ybWF0UmV0dXJuVmFsdWUoYm4sIGVuYykge1xuICB2YXIgYnVmID0gbmV3IEJ1ZmZlcihibi50b0FycmF5KCkpO1xuICBpZiAoIWVuYykge1xuICAgIHJldHVybiBidWY7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJ1Zi50b1N0cmluZyhlbmMpO1xuICB9XG59XG4iLCJ2YXIgcmFuZG9tQnl0ZXMgPSByZXF1aXJlKCdyYW5kb21ieXRlcycpO1xubW9kdWxlLmV4cG9ydHMgPSBmaW5kUHJpbWU7XG5maW5kUHJpbWUuc2ltcGxlU2lldmUgPSBzaW1wbGVTaWV2ZTtcbmZpbmRQcmltZS5mZXJtYXRUZXN0ID0gZmVybWF0VGVzdDtcbnZhciBCTiA9IHJlcXVpcmUoJ2JuLmpzJyk7XG52YXIgVFdFTlRZRk9VUiA9IG5ldyBCTigyNCk7XG52YXIgTWlsbGVyUmFiaW4gPSByZXF1aXJlKCdtaWxsZXItcmFiaW4nKTtcbnZhciBtaWxsZXJSYWJpbiA9IG5ldyBNaWxsZXJSYWJpbigpO1xudmFyIE9ORSA9IG5ldyBCTigxKTtcbnZhciBUV08gPSBuZXcgQk4oMik7XG52YXIgRklWRSA9IG5ldyBCTig1KTtcbnZhciBTSVhURUVOID0gbmV3IEJOKDE2KTtcbnZhciBFSUdIVCA9IG5ldyBCTig4KTtcbnZhciBURU4gPSBuZXcgQk4oMTApO1xudmFyIFRIUkVFID0gbmV3IEJOKDMpO1xudmFyIFNFVkVOID0gbmV3IEJOKDcpO1xudmFyIEVMRVZFTiA9IG5ldyBCTigxMSk7XG52YXIgRk9VUiA9IG5ldyBCTig0KTtcbnZhciBUV0VMVkUgPSBuZXcgQk4oMTIpO1xudmFyIHByaW1lcyA9IG51bGw7XG5cbmZ1bmN0aW9uIF9nZXRQcmltZXMoKSB7XG4gIGlmIChwcmltZXMgIT09IG51bGwpXG4gICAgcmV0dXJuIHByaW1lcztcblxuICB2YXIgbGltaXQgPSAweDEwMDAwMDtcbiAgdmFyIHJlcyA9IFtdO1xuICByZXNbMF0gPSAyO1xuICBmb3IgKHZhciBpID0gMSwgayA9IDM7IGsgPCBsaW1pdDsgayArPSAyKSB7XG4gICAgdmFyIHNxcnQgPSBNYXRoLmNlaWwoTWF0aC5zcXJ0KGspKTtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGkgJiYgcmVzW2pdIDw9IHNxcnQ7IGorKylcbiAgICAgIGlmIChrICUgcmVzW2pdID09PSAwKVxuICAgICAgICBicmVhaztcblxuICAgIGlmIChpICE9PSBqICYmIHJlc1tqXSA8PSBzcXJ0KVxuICAgICAgY29udGludWU7XG5cbiAgICByZXNbaSsrXSA9IGs7XG4gIH1cbiAgcHJpbWVzID0gcmVzO1xuICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBzaW1wbGVTaWV2ZShwKSB7XG4gIHZhciBwcmltZXMgPSBfZ2V0UHJpbWVzKCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmltZXMubGVuZ3RoOyBpKyspXG4gICAgaWYgKHAubW9kbihwcmltZXNbaV0pID09PSAwKSB7XG4gICAgICBpZiAocC5jbXBuKHByaW1lc1tpXSkgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBmZXJtYXRUZXN0KHApIHtcbiAgdmFyIHJlZCA9IEJOLm1vbnQocCk7XG4gIHJldHVybiBUV08udG9SZWQocmVkKS5yZWRQb3cocC5zdWJuKDEpKS5mcm9tUmVkKCkuY21wbigxKSA9PT0gMDtcbn1cblxuZnVuY3Rpb24gZmluZFByaW1lKGJpdHMsIGdlbikge1xuICBpZiAoYml0cyA8IDE2KSB7XG4gICAgLy8gdGhpcyBpcyB3aGF0IG9wZW5zc2wgZG9lc1xuICAgIGlmIChnZW4gPT09IDIgfHwgZ2VuID09PSA1KSB7XG4gICAgICByZXR1cm4gbmV3IEJOKFsweDhjLCAweDdiXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgQk4oWzB4OGMsIDB4MjddKTtcbiAgICB9XG4gIH1cbiAgZ2VuID0gbmV3IEJOKGdlbik7XG5cbiAgdmFyIG51bSwgbjI7XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBudW0gPSBuZXcgQk4ocmFuZG9tQnl0ZXMoTWF0aC5jZWlsKGJpdHMgLyA4KSkpO1xuICAgIHdoaWxlIChudW0uYml0TGVuZ3RoKCkgPiBiaXRzKSB7XG4gICAgICBudW0uaXNocm4oMSk7XG4gICAgfVxuICAgIGlmIChudW0uaXNFdmVuKCkpIHtcbiAgICAgIG51bS5pYWRkKE9ORSk7XG4gICAgfVxuICAgIGlmICghbnVtLnRlc3RuKDEpKSB7XG4gICAgICBudW0uaWFkZChUV08pO1xuICAgIH1cbiAgICBpZiAoIWdlbi5jbXAoVFdPKSkge1xuICAgICAgd2hpbGUgKG51bS5tb2QoVFdFTlRZRk9VUikuY21wKEVMRVZFTikpIHtcbiAgICAgICAgbnVtLmlhZGQoRk9VUik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghZ2VuLmNtcChGSVZFKSkge1xuICAgICAgd2hpbGUgKG51bS5tb2QoVEVOKS5jbXAoVEhSRUUpKSB7XG4gICAgICAgIG51bS5pYWRkKEZPVVIpO1xuICAgICAgfVxuICAgIH1cbiAgICBuMiA9IG51bS5zaHJuKDEpO1xuICAgIGlmIChzaW1wbGVTaWV2ZShuMikgJiYgc2ltcGxlU2lldmUobnVtKSAmJlxuICAgICAgZmVybWF0VGVzdChuMikgJiYgZmVybWF0VGVzdChudW0pICYmXG4gICAgICBtaWxsZXJSYWJpbi50ZXN0KG4yKSAmJiBtaWxsZXJSYWJpbi50ZXN0KG51bSkpIHtcbiAgICAgIHJldHVybiBudW07XG4gICAgfVxuICB9XG5cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgICBcIm1vZHAxXCI6IHtcbiAgICAgICAgXCJnZW5cIjogXCIwMlwiLFxuICAgICAgICBcInByaW1lXCI6IFwiZmZmZmZmZmZmZmZmZmZmZmM5MGZkYWEyMjE2OGMyMzRjNGM2NjI4YjgwZGMxY2QxMjkwMjRlMDg4YTY3Y2M3NDAyMGJiZWE2M2IxMzliMjI1MTRhMDg3OThlMzQwNGRkZWY5NTE5YjNjZDNhNDMxYjMwMmIwYTZkZjI1ZjE0Mzc0ZmUxMzU2ZDZkNTFjMjQ1ZTQ4NWI1NzY2MjVlN2VjNmY0NGM0MmU5YTYzYTM2MjBmZmZmZmZmZmZmZmZmZmZmXCJcbiAgICB9LFxuICAgIFwibW9kcDJcIjoge1xuICAgICAgICBcImdlblwiOiBcIjAyXCIsXG4gICAgICAgIFwicHJpbWVcIjogXCJmZmZmZmZmZmZmZmZmZmZmYzkwZmRhYTIyMTY4YzIzNGM0YzY2MjhiODBkYzFjZDEyOTAyNGUwODhhNjdjYzc0MDIwYmJlYTYzYjEzOWIyMjUxNGEwODc5OGUzNDA0ZGRlZjk1MTliM2NkM2E0MzFiMzAyYjBhNmRmMjVmMTQzNzRmZTEzNTZkNmQ1MWMyNDVlNDg1YjU3NjYyNWU3ZWM2ZjQ0YzQyZTlhNjM3ZWQ2YjBiZmY1Y2I2ZjQwNmI3ZWRlZTM4NmJmYjVhODk5ZmE1YWU5ZjI0MTE3YzRiMWZlNjQ5Mjg2NjUxZWNlNjUzODFmZmZmZmZmZmZmZmZmZmZmXCJcbiAgICB9LFxuICAgIFwibW9kcDVcIjoge1xuICAgICAgICBcImdlblwiOiBcIjAyXCIsXG4gICAgICAgIFwicHJpbWVcIjogXCJmZmZmZmZmZmZmZmZmZmZmYzkwZmRhYTIyMTY4YzIzNGM0YzY2MjhiODBkYzFjZDEyOTAyNGUwODhhNjdjYzc0MDIwYmJlYTYzYjEzOWIyMjUxNGEwODc5OGUzNDA0ZGRlZjk1MTliM2NkM2E0MzFiMzAyYjBhNmRmMjVmMTQzNzRmZTEzNTZkNmQ1MWMyNDVlNDg1YjU3NjYyNWU3ZWM2ZjQ0YzQyZTlhNjM3ZWQ2YjBiZmY1Y2I2ZjQwNmI3ZWRlZTM4NmJmYjVhODk5ZmE1YWU5ZjI0MTE3YzRiMWZlNjQ5Mjg2NjUxZWNlNDViM2RjMjAwN2NiOGExNjNiZjA1OThkYTQ4MzYxYzU1ZDM5YTY5MTYzZmE4ZmQyNGNmNWY4MzY1NWQyM2RjYTNhZDk2MWM2MmYzNTYyMDg1NTJiYjllZDUyOTA3NzA5Njk2NmQ2NzBjMzU0ZTRhYmM5ODA0ZjE3NDZjMDhjYTIzNzMyN2ZmZmZmZmZmZmZmZmZmZmZcIlxuICAgIH0sXG4gICAgXCJtb2RwMTRcIjoge1xuICAgICAgICBcImdlblwiOiBcIjAyXCIsXG4gICAgICAgIFwicHJpbWVcIjogXCJmZmZmZmZmZmZmZmZmZmZmYzkwZmRhYTIyMTY4YzIzNGM0YzY2MjhiODBkYzFjZDEyOTAyNGUwODhhNjdjYzc0MDIwYmJlYTYzYjEzOWIyMjUxNGEwODc5OGUzNDA0ZGRlZjk1MTliM2NkM2E0MzFiMzAyYjBhNmRmMjVmMTQzNzRmZTEzNTZkNmQ1MWMyNDVlNDg1YjU3NjYyNWU3ZWM2ZjQ0YzQyZTlhNjM3ZWQ2YjBiZmY1Y2I2ZjQwNmI3ZWRlZTM4NmJmYjVhODk5ZmE1YWU5ZjI0MTE3YzRiMWZlNjQ5Mjg2NjUxZWNlNDViM2RjMjAwN2NiOGExNjNiZjA1OThkYTQ4MzYxYzU1ZDM5YTY5MTYzZmE4ZmQyNGNmNWY4MzY1NWQyM2RjYTNhZDk2MWM2MmYzNTYyMDg1NTJiYjllZDUyOTA3NzA5Njk2NmQ2NzBjMzU0ZTRhYmM5ODA0ZjE3NDZjMDhjYTE4MjE3YzMyOTA1ZTQ2MmUzNmNlM2JlMzllNzcyYzE4MGU4NjAzOWIyNzgzYTJlYzA3YTI4ZmI1YzU1ZGYwNmY0YzUyYzlkZTJiY2JmNjk1NTgxNzE4Mzk5NTQ5N2NlYTk1NmFlNTE1ZDIyNjE4OThmYTA1MTAxNTcyOGU1YThhYWNhYTY4ZmZmZmZmZmZmZmZmZmZmZlwiXG4gICAgfSxcbiAgICBcIm1vZHAxNVwiOiB7XG4gICAgICAgIFwiZ2VuXCI6IFwiMDJcIixcbiAgICAgICAgXCJwcmltZVwiOiBcImZmZmZmZmZmZmZmZmZmZmZjOTBmZGFhMjIxNjhjMjM0YzRjNjYyOGI4MGRjMWNkMTI5MDI0ZTA4OGE2N2NjNzQwMjBiYmVhNjNiMTM5YjIyNTE0YTA4Nzk4ZTM0MDRkZGVmOTUxOWIzY2QzYTQzMWIzMDJiMGE2ZGYyNWYxNDM3NGZlMTM1NmQ2ZDUxYzI0NWU0ODViNTc2NjI1ZTdlYzZmNDRjNDJlOWE2MzdlZDZiMGJmZjVjYjZmNDA2YjdlZGVlMzg2YmZiNWE4OTlmYTVhZTlmMjQxMTdjNGIxZmU2NDkyODY2NTFlY2U0NWIzZGMyMDA3Y2I4YTE2M2JmMDU5OGRhNDgzNjFjNTVkMzlhNjkxNjNmYThmZDI0Y2Y1ZjgzNjU1ZDIzZGNhM2FkOTYxYzYyZjM1NjIwODU1MmJiOWVkNTI5MDc3MDk2OTY2ZDY3MGMzNTRlNGFiYzk4MDRmMTc0NmMwOGNhMTgyMTdjMzI5MDVlNDYyZTM2Y2UzYmUzOWU3NzJjMTgwZTg2MDM5YjI3ODNhMmVjMDdhMjhmYjVjNTVkZjA2ZjRjNTJjOWRlMmJjYmY2OTU1ODE3MTgzOTk1NDk3Y2VhOTU2YWU1MTVkMjI2MTg5OGZhMDUxMDE1NzI4ZTVhOGFhYWM0MmRhZDMzMTcwZDA0NTA3YTMzYTg1NTIxYWJkZjFjYmE2NGVjZmI4NTA0NThkYmVmMGE4YWVhNzE1NzVkMDYwYzdkYjM5NzBmODVhNmUxZTRjN2FiZjVhZThjZGIwOTMzZDcxZThjOTRlMDRhMjU2MTlkY2VlM2QyMjYxYWQyZWU2YmYxMmZmYTA2ZDk4YTA4NjRkODc2MDI3MzNlYzg2YTY0NTIxZjJiMTgxNzdiMjAwY2JiZTExNzU3N2E2MTVkNmM3NzA5ODhjMGJhZDk0NmUyMDhlMjRmYTA3NGU1YWIzMTQzZGI1YmZjZTBmZDEwOGU0YjgyZDEyMGE5M2FkMmNhZmZmZmZmZmZmZmZmZmZmZlwiXG4gICAgfSxcbiAgICBcIm1vZHAxNlwiOiB7XG4gICAgICAgIFwiZ2VuXCI6IFwiMDJcIixcbiAgICAgICAgXCJwcmltZVwiOiBcImZmZmZmZmZmZmZmZmZmZmZjOTBmZGFhMjIxNjhjMjM0YzRjNjYyOGI4MGRjMWNkMTI5MDI0ZTA4OGE2N2NjNzQwMjBiYmVhNjNiMTM5YjIyNTE0YTA4Nzk4ZTM0MDRkZGVmOTUxOWIzY2QzYTQzMWIzMDJiMGE2ZGYyNWYxNDM3NGZlMTM1NmQ2ZDUxYzI0NWU0ODViNTc2NjI1ZTdlYzZmNDRjNDJlOWE2MzdlZDZiMGJmZjVjYjZmNDA2YjdlZGVlMzg2YmZiNWE4OTlmYTVhZTlmMjQxMTdjNGIxZmU2NDkyODY2NTFlY2U0NWIzZGMyMDA3Y2I4YTE2M2JmMDU5OGRhNDgzNjFjNTVkMzlhNjkxNjNmYThmZDI0Y2Y1ZjgzNjU1ZDIzZGNhM2FkOTYxYzYyZjM1NjIwODU1MmJiOWVkNTI5MDc3MDk2OTY2ZDY3MGMzNTRlNGFiYzk4MDRmMTc0NmMwOGNhMTgyMTdjMzI5MDVlNDYyZTM2Y2UzYmUzOWU3NzJjMTgwZTg2MDM5YjI3ODNhMmVjMDdhMjhmYjVjNTVkZjA2ZjRjNTJjOWRlMmJjYmY2OTU1ODE3MTgzOTk1NDk3Y2VhOTU2YWU1MTVkMjI2MTg5OGZhMDUxMDE1NzI4ZTVhOGFhYWM0MmRhZDMzMTcwZDA0NTA3YTMzYTg1NTIxYWJkZjFjYmE2NGVjZmI4NTA0NThkYmVmMGE4YWVhNzE1NzVkMDYwYzdkYjM5NzBmODVhNmUxZTRjN2FiZjVhZThjZGIwOTMzZDcxZThjOTRlMDRhMjU2MTlkY2VlM2QyMjYxYWQyZWU2YmYxMmZmYTA2ZDk4YTA4NjRkODc2MDI3MzNlYzg2YTY0NTIxZjJiMTgxNzdiMjAwY2JiZTExNzU3N2E2MTVkNmM3NzA5ODhjMGJhZDk0NmUyMDhlMjRmYTA3NGU1YWIzMTQzZGI1YmZjZTBmZDEwOGU0YjgyZDEyMGE5MjEwODAxMWE3MjNjMTJhNzg3ZTZkNzg4NzE5YTEwYmRiYTViMjY5OWMzMjcxODZhZjRlMjNjMWE5NDY4MzRiNjE1MGJkYTI1ODNlOWNhMmFkNDRjZThkYmJiYzJkYjA0ZGU4ZWY5MmU4ZWZjMTQxZmJlY2FhNjI4N2M1OTQ3NGU2YmMwNWQ5OWIyOTY0ZmEwOTBjM2EyMjMzYmExODY1MTViZTdlZDFmNjEyOTcwY2VlMmQ3YWZiODFiZGQ3NjIxNzA0ODFjZDAwNjkxMjdkNWIwNWFhOTkzYjRlYTk4OGQ4ZmRkYzE4NmZmYjdkYzkwYTZjMDhmNGRmNDM1YzkzNDA2MzE5OWZmZmZmZmZmZmZmZmZmZmZcIlxuICAgIH0sXG4gICAgXCJtb2RwMTdcIjoge1xuICAgICAgICBcImdlblwiOiBcIjAyXCIsXG4gICAgICAgIFwicHJpbWVcIjogXCJmZmZmZmZmZmZmZmZmZmZmYzkwZmRhYTIyMTY4YzIzNGM0YzY2MjhiODBkYzFjZDEyOTAyNGUwODhhNjdjYzc0MDIwYmJlYTYzYjEzOWIyMjUxNGEwODc5OGUzNDA0ZGRlZjk1MTliM2NkM2E0MzFiMzAyYjBhNmRmMjVmMTQzNzRmZTEzNTZkNmQ1MWMyNDVlNDg1YjU3NjYyNWU3ZWM2ZjQ0YzQyZTlhNjM3ZWQ2YjBiZmY1Y2I2ZjQwNmI3ZWRlZTM4NmJmYjVhODk5ZmE1YWU5ZjI0MTE3YzRiMWZlNjQ5Mjg2NjUxZWNlNDViM2RjMjAwN2NiOGExNjNiZjA1OThkYTQ4MzYxYzU1ZDM5YTY5MTYzZmE4ZmQyNGNmNWY4MzY1NWQyM2RjYTNhZDk2MWM2MmYzNTYyMDg1NTJiYjllZDUyOTA3NzA5Njk2NmQ2NzBjMzU0ZTRhYmM5ODA0ZjE3NDZjMDhjYTE4MjE3YzMyOTA1ZTQ2MmUzNmNlM2JlMzllNzcyYzE4MGU4NjAzOWIyNzgzYTJlYzA3YTI4ZmI1YzU1ZGYwNmY0YzUyYzlkZTJiY2JmNjk1NTgxNzE4Mzk5NTQ5N2NlYTk1NmFlNTE1ZDIyNjE4OThmYTA1MTAxNTcyOGU1YThhYWFjNDJkYWQzMzE3MGQwNDUwN2EzM2E4NTUyMWFiZGYxY2JhNjRlY2ZiODUwNDU4ZGJlZjBhOGFlYTcxNTc1ZDA2MGM3ZGIzOTcwZjg1YTZlMWU0YzdhYmY1YWU4Y2RiMDkzM2Q3MWU4Yzk0ZTA0YTI1NjE5ZGNlZTNkMjI2MWFkMmVlNmJmMTJmZmEwNmQ5OGEwODY0ZDg3NjAyNzMzZWM4NmE2NDUyMWYyYjE4MTc3YjIwMGNiYmUxMTc1NzdhNjE1ZDZjNzcwOTg4YzBiYWQ5NDZlMjA4ZTI0ZmEwNzRlNWFiMzE0M2RiNWJmY2UwZmQxMDhlNGI4MmQxMjBhOTIxMDgwMTFhNzIzYzEyYTc4N2U2ZDc4ODcxOWExMGJkYmE1YjI2OTljMzI3MTg2YWY0ZTIzYzFhOTQ2ODM0YjYxNTBiZGEyNTgzZTljYTJhZDQ0Y2U4ZGJiYmMyZGIwNGRlOGVmOTJlOGVmYzE0MWZiZWNhYTYyODdjNTk0NzRlNmJjMDVkOTliMjk2NGZhMDkwYzNhMjIzM2JhMTg2NTE1YmU3ZWQxZjYxMjk3MGNlZTJkN2FmYjgxYmRkNzYyMTcwNDgxY2QwMDY5MTI3ZDViMDVhYTk5M2I0ZWE5ODhkOGZkZGMxODZmZmI3ZGM5MGE2YzA4ZjRkZjQzNWM5MzQwMjg0OTIzNmMzZmFiNGQyN2M3MDI2YzFkNGRjYjI2MDI2NDZkZWM5NzUxZTc2M2RiYTM3YmRmOGZmOTQwNmFkOWU1MzBlZTVkYjM4MmY0MTMwMDFhZWIwNmE1M2VkOTAyN2Q4MzExNzk3MjdiMDg2NWE4OTE4ZGEzZWRiZWJjZjliMTRlZDQ0Y2U2Y2JhY2VkNGJiMWJkYjdmMTQ0N2U2Y2MyNTRiMzMyMDUxNTEyYmQ3YWY0MjZmYjhmNDAxMzc4Y2QyYmY1OTgzY2EwMWM2NGI5MmVjZjAzMmVhMTVkMTcyMWQwM2Y0ODJkN2NlNmU3NGZlZjZkNTVlNzAyZjQ2OTgwYzgyYjVhODQwMzE5MDBiMWM5ZTU5ZTdjOTdmYmVjN2U4ZjMyM2E5N2E3ZTM2Y2M4OGJlMGYxZDQ1YjdmZjU4NWFjNTRiZDQwN2IyMmI0MTU0YWFjYzhmNmQ3ZWJmNDhlMWQ4MTRjYzVlZDIwZjgwMzdlMGE3OTcxNWVlZjI5YmUzMjgwNmExZDU4YmI3YzVkYTc2ZjU1MGFhM2Q4YTFmYmZmMGViMTljY2IxYTMxM2Q1NWNkYTU2YzllYzJlZjI5NjMyMzg3ZmU4ZDc2ZTNjMDQ2ODA0M2U4ZjY2M2Y0ODYwZWUxMmJmMmQ1YjBiNzQ3NGQ2ZTY5NGY5MWU2ZGNjNDAyNGZmZmZmZmZmZmZmZmZmZmZcIlxuICAgIH0sXG4gICAgXCJtb2RwMThcIjoge1xuICAgICAgICBcImdlblwiOiBcIjAyXCIsXG4gICAgICAgIFwicHJpbWVcIjogXCJmZmZmZmZmZmZmZmZmZmZmYzkwZmRhYTIyMTY4YzIzNGM0YzY2MjhiODBkYzFjZDEyOTAyNGUwODhhNjdjYzc0MDIwYmJlYTYzYjEzOWIyMjUxNGEwODc5OGUzNDA0ZGRlZjk1MTliM2NkM2E0MzFiMzAyYjBhNmRmMjVmMTQzNzRmZTEzNTZkNmQ1MWMyNDVlNDg1YjU3NjYyNWU3ZWM2ZjQ0YzQyZTlhNjM3ZWQ2YjBiZmY1Y2I2ZjQwNmI3ZWRlZTM4NmJmYjVhODk5ZmE1YWU5ZjI0MTE3YzRiMWZlNjQ5Mjg2NjUxZWNlNDViM2RjMjAwN2NiOGExNjNiZjA1OThkYTQ4MzYxYzU1ZDM5YTY5MTYzZmE4ZmQyNGNmNWY4MzY1NWQyM2RjYTNhZDk2MWM2MmYzNTYyMDg1NTJiYjllZDUyOTA3NzA5Njk2NmQ2NzBjMzU0ZTRhYmM5ODA0ZjE3NDZjMDhjYTE4MjE3YzMyOTA1ZTQ2MmUzNmNlM2JlMzllNzcyYzE4MGU4NjAzOWIyNzgzYTJlYzA3YTI4ZmI1YzU1ZGYwNmY0YzUyYzlkZTJiY2JmNjk1NTgxNzE4Mzk5NTQ5N2NlYTk1NmFlNTE1ZDIyNjE4OThmYTA1MTAxNTcyOGU1YThhYWFjNDJkYWQzMzE3MGQwNDUwN2EzM2E4NTUyMWFiZGYxY2JhNjRlY2ZiODUwNDU4ZGJlZjBhOGFlYTcxNTc1ZDA2MGM3ZGIzOTcwZjg1YTZlMWU0YzdhYmY1YWU4Y2RiMDkzM2Q3MWU4Yzk0ZTA0YTI1NjE5ZGNlZTNkMjI2MWFkMmVlNmJmMTJmZmEwNmQ5OGEwODY0ZDg3NjAyNzMzZWM4NmE2NDUyMWYyYjE4MTc3YjIwMGNiYmUxMTc1NzdhNjE1ZDZjNzcwOTg4YzBiYWQ5NDZlMjA4ZTI0ZmEwNzRlNWFiMzE0M2RiNWJmY2UwZmQxMDhlNGI4MmQxMjBhOTIxMDgwMTFhNzIzYzEyYTc4N2U2ZDc4ODcxOWExMGJkYmE1YjI2OTljMzI3MTg2YWY0ZTIzYzFhOTQ2ODM0YjYxNTBiZGEyNTgzZTljYTJhZDQ0Y2U4ZGJiYmMyZGIwNGRlOGVmOTJlOGVmYzE0MWZiZWNhYTYyODdjNTk0NzRlNmJjMDVkOTliMjk2NGZhMDkwYzNhMjIzM2JhMTg2NTE1YmU3ZWQxZjYxMjk3MGNlZTJkN2FmYjgxYmRkNzYyMTcwNDgxY2QwMDY5MTI3ZDViMDVhYTk5M2I0ZWE5ODhkOGZkZGMxODZmZmI3ZGM5MGE2YzA4ZjRkZjQzNWM5MzQwMjg0OTIzNmMzZmFiNGQyN2M3MDI2YzFkNGRjYjI2MDI2NDZkZWM5NzUxZTc2M2RiYTM3YmRmOGZmOTQwNmFkOWU1MzBlZTVkYjM4MmY0MTMwMDFhZWIwNmE1M2VkOTAyN2Q4MzExNzk3MjdiMDg2NWE4OTE4ZGEzZWRiZWJjZjliMTRlZDQ0Y2U2Y2JhY2VkNGJiMWJkYjdmMTQ0N2U2Y2MyNTRiMzMyMDUxNTEyYmQ3YWY0MjZmYjhmNDAxMzc4Y2QyYmY1OTgzY2EwMWM2NGI5MmVjZjAzMmVhMTVkMTcyMWQwM2Y0ODJkN2NlNmU3NGZlZjZkNTVlNzAyZjQ2OTgwYzgyYjVhODQwMzE5MDBiMWM5ZTU5ZTdjOTdmYmVjN2U4ZjMyM2E5N2E3ZTM2Y2M4OGJlMGYxZDQ1YjdmZjU4NWFjNTRiZDQwN2IyMmI0MTU0YWFjYzhmNmQ3ZWJmNDhlMWQ4MTRjYzVlZDIwZjgwMzdlMGE3OTcxNWVlZjI5YmUzMjgwNmExZDU4YmI3YzVkYTc2ZjU1MGFhM2Q4YTFmYmZmMGViMTljY2IxYTMxM2Q1NWNkYTU2YzllYzJlZjI5NjMyMzg3ZmU4ZDc2ZTNjMDQ2ODA0M2U4ZjY2M2Y0ODYwZWUxMmJmMmQ1YjBiNzQ3NGQ2ZTY5NGY5MWU2ZGJlMTE1OTc0YTM5MjZmMTJmZWU1ZTQzODc3N2NiNmE5MzJkZjhjZDhiZWM0ZDA3M2I5MzFiYTNiYzgzMmI2OGQ5ZGQzMDA3NDFmYTdiZjhhZmM0N2VkMjU3NmY2OTM2YmE0MjQ2NjNhYWI2MzljNWFlNGY1NjgzNDIzYjQ3NDJiZjFjOTc4MjM4ZjE2Y2JlMzlkNjUyZGUzZmRiOGJlZmM4NDhhZDkyMjIyMmUwNGE0MDM3YzA3MTNlYjU3YTgxYTIzZjBjNzM0NzNmYzY0NmNlYTMwNmI0YmNiYzg4NjJmODM4NWRkZmE5ZDRiN2ZhMmMwODdlODc5NjgzMzAzZWQ1YmRkM2EwNjJiM2NmNWIzYTI3OGE2NmQyYTEzZjgzZjQ0ZjgyZGRmMzEwZWUwNzRhYjZhMzY0NTk3ZTg5OWEwMjU1ZGMxNjRmMzFjYzUwODQ2ODUxZGY5YWI0ODE5NWRlZDdlYTFiMWQ1MTBiZDdlZTc0ZDczZmFmMzZiYzMxZWNmYTI2ODM1OTA0NmY0ZWI4NzlmOTI0MDA5NDM4YjQ4MWM2Y2Q3ODg5YTAwMmVkNWVlMzgyYmM5MTkwZGE2ZmMwMjZlNDc5NTU4ZTQ0NzU2NzdlOWFhOWUzMDUwZTI3NjU2OTRkZmM4MWY1NmU4ODBiOTZlNzE2MGM5ODBkZDk4ZWRkM2RmZmZmZmZmZmZmZmZmZmZmZlwiXG4gICAgfVxufSIsInZhciBibiA9IHJlcXVpcmUoJ2JuLmpzJyk7XG52YXIgYnJvcmFuZCA9IHJlcXVpcmUoJ2Jyb3JhbmQnKTtcblxuZnVuY3Rpb24gTWlsbGVyUmFiaW4ocmFuZCkge1xuICB0aGlzLnJhbmQgPSByYW5kIHx8IG5ldyBicm9yYW5kLlJhbmQoKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gTWlsbGVyUmFiaW47XG5cbk1pbGxlclJhYmluLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShyYW5kKSB7XG4gIHJldHVybiBuZXcgTWlsbGVyUmFiaW4ocmFuZCk7XG59O1xuXG5NaWxsZXJSYWJpbi5wcm90b3R5cGUuX3JhbmQgPSBmdW5jdGlvbiBfcmFuZChuKSB7XG4gIHZhciBsZW4gPSBuLmJpdExlbmd0aCgpO1xuICB2YXIgYnVmID0gdGhpcy5yYW5kLmdlbmVyYXRlKE1hdGguY2VpbChsZW4gLyA4KSk7XG5cbiAgLy8gU2V0IGxvdyBiaXRzXG4gIGJ1ZlswXSB8PSAzO1xuXG4gIC8vIE1hc2sgaGlnaCBiaXRzXG4gIHZhciBtYXNrID0gbGVuICYgMHg3O1xuICBpZiAobWFzayAhPT0gMClcbiAgICBidWZbYnVmLmxlbmd0aCAtIDFdID4+PSA3IC0gbWFzaztcblxuICByZXR1cm4gbmV3IGJuKGJ1Zik7XG59XG5cbk1pbGxlclJhYmluLnByb3RvdHlwZS50ZXN0ID0gZnVuY3Rpb24gdGVzdChuLCBrLCBjYikge1xuICB2YXIgbGVuID0gbi5iaXRMZW5ndGgoKTtcbiAgdmFyIHJlZCA9IGJuLm1vbnQobik7XG4gIHZhciByb25lID0gbmV3IGJuKDEpLnRvUmVkKHJlZCk7XG5cbiAgaWYgKCFrKVxuICAgIGsgPSBNYXRoLm1heCgxLCAobGVuIC8gNDgpIHwgMCk7XG5cbiAgLy8gRmluZCBkIGFuZCBzLCAobiAtIDEpID0gKDIgXiBzKSAqIGQ7XG4gIHZhciBuMSA9IG4uc3VibigxKTtcbiAgdmFyIG4yID0gbjEuc3VibigxKTtcbiAgZm9yICh2YXIgcyA9IDA7ICFuMS50ZXN0bihzKTsgcysrKSB7fVxuICB2YXIgZCA9IG4uc2hybihzKTtcblxuICB2YXIgcm4xID0gbjEudG9SZWQocmVkKTtcblxuICB2YXIgcHJpbWUgPSB0cnVlO1xuICBmb3IgKDsgayA+IDA7IGstLSkge1xuICAgIHZhciBhID0gdGhpcy5fcmFuZChuMik7XG4gICAgaWYgKGNiKVxuICAgICAgY2IoYSk7XG5cbiAgICB2YXIgeCA9IGEudG9SZWQocmVkKS5yZWRQb3coZCk7XG4gICAgaWYgKHguY21wKHJvbmUpID09PSAwIHx8IHguY21wKHJuMSkgPT09IDApXG4gICAgICBjb250aW51ZTtcblxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgczsgaSsrKSB7XG4gICAgICB4ID0geC5yZWRTcXIoKTtcblxuICAgICAgaWYgKHguY21wKHJvbmUpID09PSAwKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAoeC5jbXAocm4xKSA9PT0gMClcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKGkgPT09IHMpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gcHJpbWU7XG59O1xuXG5NaWxsZXJSYWJpbi5wcm90b3R5cGUuZ2V0RGl2aXNvciA9IGZ1bmN0aW9uIGdldERpdmlzb3Iobiwgaykge1xuICB2YXIgbGVuID0gbi5iaXRMZW5ndGgoKTtcbiAgdmFyIHJlZCA9IGJuLm1vbnQobik7XG4gIHZhciByb25lID0gbmV3IGJuKDEpLnRvUmVkKHJlZCk7XG5cbiAgaWYgKCFrKVxuICAgIGsgPSBNYXRoLm1heCgxLCAobGVuIC8gNDgpIHwgMCk7XG5cbiAgLy8gRmluZCBkIGFuZCBzLCAobiAtIDEpID0gKDIgXiBzKSAqIGQ7XG4gIHZhciBuMSA9IG4uc3VibigxKTtcbiAgdmFyIG4yID0gbjEuc3VibigxKTtcbiAgZm9yICh2YXIgcyA9IDA7ICFuMS50ZXN0bihzKTsgcysrKSB7fVxuICB2YXIgZCA9IG4uc2hybihzKTtcblxuICB2YXIgcm4xID0gbjEudG9SZWQocmVkKTtcblxuICBmb3IgKDsgayA+IDA7IGstLSkge1xuICAgIHZhciBhID0gdGhpcy5fcmFuZChuMik7XG5cbiAgICB2YXIgZyA9IG4uZ2NkKGEpO1xuICAgIGlmIChnLmNtcG4oMSkgIT09IDApXG4gICAgICByZXR1cm4gZztcblxuICAgIHZhciB4ID0gYS50b1JlZChyZWQpLnJlZFBvdyhkKTtcbiAgICBpZiAoeC5jbXAocm9uZSkgPT09IDAgfHwgeC5jbXAocm4xKSA9PT0gMClcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBzOyBpKyspIHtcbiAgICAgIHggPSB4LnJlZFNxcigpO1xuXG4gICAgICBpZiAoeC5jbXAocm9uZSkgPT09IDApXG4gICAgICAgIHJldHVybiB4LmZyb21SZWQoKS5zdWJuKDEpLmdjZChuKTtcbiAgICAgIGlmICh4LmNtcChybjEpID09PSAwKVxuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoaSA9PT0gcykge1xuICAgICAgeCA9IHgucmVkU3FyKCk7XG4gICAgICByZXR1cm4geC5mcm9tUmVkKCkuc3VibigxKS5nY2Qobik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcbiIsInZhciBjcmVhdGVIbWFjID0gcmVxdWlyZSgnY3JlYXRlLWhtYWMnKVxudmFyIE1BWF9BTExPQyA9IE1hdGgucG93KDIsIDMwKSAtIDEgLy8gZGVmYXVsdCBpbiBpb2pzXG5cbmV4cG9ydHMucGJrZGYyID0gcGJrZGYyXG5mdW5jdGlvbiBwYmtkZjIgKHBhc3N3b3JkLCBzYWx0LCBpdGVyYXRpb25zLCBrZXlsZW4sIGRpZ2VzdCwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBkaWdlc3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IGRpZ2VzdFxuICAgIGRpZ2VzdCA9IHVuZGVmaW5lZFxuICB9XG5cbiAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcignTm8gY2FsbGJhY2sgcHJvdmlkZWQgdG8gcGJrZGYyJylcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBwYmtkZjJTeW5jKHBhc3N3b3JkLCBzYWx0LCBpdGVyYXRpb25zLCBrZXlsZW4sIGRpZ2VzdClcbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgY2FsbGJhY2sodW5kZWZpbmVkLCByZXN1bHQpXG4gIH0pXG59XG5cbmV4cG9ydHMucGJrZGYyU3luYyA9IHBia2RmMlN5bmNcbmZ1bmN0aW9uIHBia2RmMlN5bmMgKHBhc3N3b3JkLCBzYWx0LCBpdGVyYXRpb25zLCBrZXlsZW4sIGRpZ2VzdCkge1xuICBpZiAodHlwZW9mIGl0ZXJhdGlvbnMgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSXRlcmF0aW9ucyBub3QgYSBudW1iZXInKVxuICB9XG5cbiAgaWYgKGl0ZXJhdGlvbnMgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQmFkIGl0ZXJhdGlvbnMnKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBrZXlsZW4gIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignS2V5IGxlbmd0aCBub3QgYSBudW1iZXInKVxuICB9XG5cbiAgaWYgKGtleWxlbiA8IDAgfHwga2V5bGVuID4gTUFYX0FMTE9DKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQmFkIGtleSBsZW5ndGgnKVxuICB9XG5cbiAgZGlnZXN0ID0gZGlnZXN0IHx8ICdzaGExJ1xuXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHBhc3N3b3JkKSkgcGFzc3dvcmQgPSBuZXcgQnVmZmVyKHBhc3N3b3JkLCAnYmluYXJ5JylcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoc2FsdCkpIHNhbHQgPSBuZXcgQnVmZmVyKHNhbHQsICdiaW5hcnknKVxuXG4gIHZhciBoTGVuXG4gIHZhciBsID0gMVxuICB2YXIgREsgPSBuZXcgQnVmZmVyKGtleWxlbilcbiAgdmFyIGJsb2NrMSA9IG5ldyBCdWZmZXIoc2FsdC5sZW5ndGggKyA0KVxuICBzYWx0LmNvcHkoYmxvY2sxLCAwLCAwLCBzYWx0Lmxlbmd0aClcblxuICB2YXIgclxuICB2YXIgVFxuXG4gIGZvciAodmFyIGkgPSAxOyBpIDw9IGw7IGkrKykge1xuICAgIGJsb2NrMS53cml0ZVVJbnQzMkJFKGksIHNhbHQubGVuZ3RoKVxuICAgIHZhciBVID0gY3JlYXRlSG1hYyhkaWdlc3QsIHBhc3N3b3JkKS51cGRhdGUoYmxvY2sxKS5kaWdlc3QoKVxuXG4gICAgaWYgKCFoTGVuKSB7XG4gICAgICBoTGVuID0gVS5sZW5ndGhcbiAgICAgIFQgPSBuZXcgQnVmZmVyKGhMZW4pXG4gICAgICBsID0gTWF0aC5jZWlsKGtleWxlbiAvIGhMZW4pXG4gICAgICByID0ga2V5bGVuIC0gKGwgLSAxKSAqIGhMZW5cbiAgICB9XG5cbiAgICBVLmNvcHkoVCwgMCwgMCwgaExlbilcblxuICAgIGZvciAodmFyIGogPSAxOyBqIDwgaXRlcmF0aW9uczsgaisrKSB7XG4gICAgICBVID0gY3JlYXRlSG1hYyhkaWdlc3QsIHBhc3N3b3JkKS51cGRhdGUoVSkuZGlnZXN0KClcblxuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBoTGVuOyBrKyspIHtcbiAgICAgICAgVFtrXSBePSBVW2tdXG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRlc3RQb3MgPSAoaSAtIDEpICogaExlblxuICAgIHZhciBsZW4gPSAoaSA9PT0gbCA/IHIgOiBoTGVuKVxuICAgIFQuY29weShESywgZGVzdFBvcywgMCwgbGVuKVxuICB9XG5cbiAgcmV0dXJuIERLXG59XG4iLCJleHBvcnRzLnB1YmxpY0VuY3J5cHQgPSByZXF1aXJlKCcuL3B1YmxpY0VuY3J5cHQnKTtcbmV4cG9ydHMucHJpdmF0ZURlY3J5cHQgPSByZXF1aXJlKCcuL3ByaXZhdGVEZWNyeXB0Jyk7XG5cbmV4cG9ydHMucHJpdmF0ZUVuY3J5cHQgPSBmdW5jdGlvbiBwcml2YXRlRW5jcnlwdChrZXksIGJ1Zikge1xuICByZXR1cm4gZXhwb3J0cy5wdWJsaWNFbmNyeXB0KGtleSwgYnVmLCB0cnVlKTtcbn07XG5cbmV4cG9ydHMucHVibGljRGVjcnlwdCA9IGZ1bmN0aW9uIHB1YmxpY0RlY3J5cHQoa2V5LCBidWYpIHtcbiAgcmV0dXJuIGV4cG9ydHMucHJpdmF0ZURlY3J5cHQoa2V5LCBidWYsIHRydWUpO1xufTsiLCJ2YXIgY3JlYXRlSGFzaCA9IHJlcXVpcmUoJ2NyZWF0ZS1oYXNoJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzZWVkLCBsZW4pIHtcbiAgdmFyIHQgPSBuZXcgQnVmZmVyKCcnKTtcbiAgdmFyICBpID0gMCwgYztcbiAgd2hpbGUgKHQubGVuZ3RoIDwgbGVuKSB7XG4gICAgYyA9IGkyb3BzKGkrKyk7XG4gICAgdCA9IEJ1ZmZlci5jb25jYXQoW3QsIGNyZWF0ZUhhc2goJ3NoYTEnKS51cGRhdGUoc2VlZCkudXBkYXRlKGMpLmRpZ2VzdCgpXSk7XG4gIH1cbiAgcmV0dXJuIHQuc2xpY2UoMCwgbGVuKTtcbn07XG5cbmZ1bmN0aW9uIGkyb3BzKGMpIHtcbiAgdmFyIG91dCA9IG5ldyBCdWZmZXIoNCk7XG4gIG91dC53cml0ZVVJbnQzMkJFKGMsMCk7XG4gIHJldHVybiBvdXQ7XG59IiwidmFyIGJuID0gcmVxdWlyZSgnYm4uanMnKTtcbnZhciByYW5kb21CeXRlcyA9IHJlcXVpcmUoJ3JhbmRvbWJ5dGVzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGNydDtcbmZ1bmN0aW9uIGJsaW5kKHByaXYpIHtcbiAgdmFyIHIgPSBnZXRyKHByaXYpO1xuICB2YXIgYmxpbmRlciA9IHIudG9SZWQoYm4ubW9udChwcml2Lm1vZHVsdXMpKVxuICAucmVkUG93KG5ldyBibihwcml2LnB1YmxpY0V4cG9uZW50KSkuZnJvbVJlZCgpO1xuICByZXR1cm4ge1xuICAgIGJsaW5kZXI6IGJsaW5kZXIsXG4gICAgdW5ibGluZGVyOnIuaW52bShwcml2Lm1vZHVsdXMpXG4gIH07XG59XG5mdW5jdGlvbiBjcnQobXNnLCBwcml2KSB7XG4gIHZhciBibGluZHMgPSBibGluZChwcml2KTtcbiAgdmFyIGxlbiA9IHByaXYubW9kdWx1cy5ieXRlTGVuZ3RoKCk7XG4gIHZhciBtb2QgPSBibi5tb250KHByaXYubW9kdWx1cyk7XG4gIHZhciBibGluZGVkID0gbmV3IGJuKG1zZykubXVsKGJsaW5kcy5ibGluZGVyKS51bW9kKHByaXYubW9kdWx1cyk7XG4gIHZhciBjMSA9IGJsaW5kZWQudG9SZWQoYm4ubW9udChwcml2LnByaW1lMSkpO1xuICB2YXIgYzIgPSBibGluZGVkLnRvUmVkKGJuLm1vbnQocHJpdi5wcmltZTIpKTtcbiAgdmFyIHFpbnYgPSBwcml2LmNvZWZmaWNpZW50O1xuICB2YXIgcCA9IHByaXYucHJpbWUxO1xuICB2YXIgcSA9IHByaXYucHJpbWUyO1xuICB2YXIgbTEgPSBjMS5yZWRQb3cocHJpdi5leHBvbmVudDEpO1xuICB2YXIgbTIgPSBjMi5yZWRQb3cocHJpdi5leHBvbmVudDIpO1xuICBtMSA9IG0xLmZyb21SZWQoKTtcbiAgbTIgPSBtMi5mcm9tUmVkKCk7XG4gIHZhciBoID0gbTEuaXN1YihtMikuaW11bChxaW52KS51bW9kKHApO1xuICBoLmltdWwocSk7XG4gIG0yLmlhZGQoaCk7XG4gIHJldHVybiBuZXcgQnVmZmVyKG0yLmltdWwoYmxpbmRzLnVuYmxpbmRlcikudW1vZChwcml2Lm1vZHVsdXMpLnRvQXJyYXkoZmFsc2UsIGxlbikpO1xufVxuY3J0LmdldHIgPSBnZXRyO1xuZnVuY3Rpb24gZ2V0cihwcml2KSB7XG4gIHZhciBsZW4gPSBwcml2Lm1vZHVsdXMuYnl0ZUxlbmd0aCgpO1xuICB2YXIgciA9IG5ldyBibihyYW5kb21CeXRlcyhsZW4pKTtcbiAgd2hpbGUgKHIuY21wKHByaXYubW9kdWx1cykgPj0gIDAgfHwgIXIudW1vZChwcml2LnByaW1lMSkgfHwgIXIudW1vZChwcml2LnByaW1lMikpIHtcbiAgICByID0gbmV3IGJuKHJhbmRvbUJ5dGVzKGxlbikpO1xuICB9XG4gIHJldHVybiByO1xufVxuIiwiLy8gYWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9hcGF0aWwvcGVtc3RyaXBcbnZhciBmaW5kUHJvYyA9IC9Qcm9jLVR5cGU6IDQsRU5DUllQVEVEXFxyP1xcbkRFSy1JbmZvOiBBRVMtKCg/OjEyOCl8KD86MTkyKXwoPzoyNTYpKS1DQkMsKFswLTlBLUhdKylcXHI/XFxuXFxyP1xcbihbMC05QS16XFxuXFxyXFwrXFwvXFw9XSspXFxyP1xcbi9tXG52YXIgc3RhcnRSZWdleCA9IC9eLS0tLS1CRUdJTiAoLiopIEtFWS0tLS0tXFxyP1xcbi9tXG52YXIgZnVsbFJlZ2V4ID0gL14tLS0tLUJFR0lOICguKikgS0VZLS0tLS1cXHI/XFxuKFswLTlBLXpcXG5cXHJcXCtcXC9cXD1dKylcXHI/XFxuLS0tLS1FTkQgXFwxIEtFWS0tLS0tJC9tXG52YXIgZXZwID0gcmVxdWlyZSgnZXZwX2J5dGVzdG9rZXknKVxudmFyIGNpcGhlcnMgPSByZXF1aXJlKCdicm93c2VyaWZ5LWFlcycpXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChva2V5LCBwYXNzd29yZCkge1xuICB2YXIga2V5ID0gb2tleS50b1N0cmluZygpXG4gIHZhciBtYXRjaCA9IGtleS5tYXRjaChmaW5kUHJvYylcbiAgdmFyIGRlY3J5cHRlZFxuICBpZiAoIW1hdGNoKSB7XG4gICAgdmFyIG1hdGNoMiA9IGtleS5tYXRjaChmdWxsUmVnZXgpXG4gICAgZGVjcnlwdGVkID0gbmV3IEJ1ZmZlcihtYXRjaDJbMl0ucmVwbGFjZSgvXFxyP1xcbi9nLCAnJyksICdiYXNlNjQnKVxuICB9IGVsc2Uge1xuICAgIHZhciBzdWl0ZSA9ICdhZXMnICsgbWF0Y2hbMV1cbiAgICB2YXIgaXYgPSBuZXcgQnVmZmVyKG1hdGNoWzJdLCAnaGV4JylcbiAgICB2YXIgY2lwaGVyVGV4dCA9IG5ldyBCdWZmZXIobWF0Y2hbM10ucmVwbGFjZSgvXFxyP1xcbi9nLCAnJyksICdiYXNlNjQnKVxuICAgIHZhciBjaXBoZXJLZXkgPSBldnAocGFzc3dvcmQsIGl2LnNsaWNlKDAsIDgpLCBwYXJzZUludChtYXRjaFsxXSwgMTApKS5rZXlcbiAgICB2YXIgb3V0ID0gW11cbiAgICB2YXIgY2lwaGVyID0gY2lwaGVycy5jcmVhdGVEZWNpcGhlcml2KHN1aXRlLCBjaXBoZXJLZXksIGl2KVxuICAgIG91dC5wdXNoKGNpcGhlci51cGRhdGUoY2lwaGVyVGV4dCkpXG4gICAgb3V0LnB1c2goY2lwaGVyLmZpbmFsKCkpXG4gICAgZGVjcnlwdGVkID0gQnVmZmVyLmNvbmNhdChvdXQpXG4gIH1cbiAgdmFyIHRhZyA9IGtleS5tYXRjaChzdGFydFJlZ2V4KVsxXSArICcgS0VZJ1xuICByZXR1cm4ge1xuICAgIHRhZzogdGFnLFxuICAgIGRhdGE6IGRlY3J5cHRlZFxuICB9XG59XG4iLCJ2YXIgYXNuMSA9IHJlcXVpcmUoJy4vYXNuMScpXG52YXIgYWVzaWQgPSByZXF1aXJlKCcuL2Flc2lkLmpzb24nKVxudmFyIGZpeFByb2MgPSByZXF1aXJlKCcuL2ZpeFByb2MnKVxudmFyIGNpcGhlcnMgPSByZXF1aXJlKCdicm93c2VyaWZ5LWFlcycpXG52YXIgY29tcGF0ID0gcmVxdWlyZSgncGJrZGYyJylcbm1vZHVsZS5leHBvcnRzID0gcGFyc2VLZXlzXG5cbmZ1bmN0aW9uIHBhcnNlS2V5cyAoYnVmZmVyKSB7XG4gIHZhciBwYXNzd29yZFxuICBpZiAodHlwZW9mIGJ1ZmZlciA9PT0gJ29iamVjdCcgJiYgIUJ1ZmZlci5pc0J1ZmZlcihidWZmZXIpKSB7XG4gICAgcGFzc3dvcmQgPSBidWZmZXIucGFzc3BocmFzZVxuICAgIGJ1ZmZlciA9IGJ1ZmZlci5rZXlcbiAgfVxuICBpZiAodHlwZW9mIGJ1ZmZlciA9PT0gJ3N0cmluZycpIHtcbiAgICBidWZmZXIgPSBuZXcgQnVmZmVyKGJ1ZmZlcilcbiAgfVxuXG4gIHZhciBzdHJpcHBlZCA9IGZpeFByb2MoYnVmZmVyLCBwYXNzd29yZClcblxuICB2YXIgdHlwZSA9IHN0cmlwcGVkLnRhZ1xuICB2YXIgZGF0YSA9IHN0cmlwcGVkLmRhdGFcbiAgdmFyIHN1YnR5cGUsIG5kYXRhXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ1BVQkxJQyBLRVknOlxuICAgICAgbmRhdGEgPSBhc24xLlB1YmxpY0tleS5kZWNvZGUoZGF0YSwgJ2RlcicpXG4gICAgICBzdWJ0eXBlID0gbmRhdGEuYWxnb3JpdGhtLmFsZ29yaXRobS5qb2luKCcuJylcbiAgICAgIHN3aXRjaCAoc3VidHlwZSkge1xuICAgICAgICBjYXNlICcxLjIuODQwLjExMzU0OS4xLjEuMSc6XG4gICAgICAgICAgcmV0dXJuIGFzbjEuUlNBUHVibGljS2V5LmRlY29kZShuZGF0YS5zdWJqZWN0UHVibGljS2V5LmRhdGEsICdkZXInKVxuICAgICAgICBjYXNlICcxLjIuODQwLjEwMDQ1LjIuMSc6XG4gICAgICAgICAgbmRhdGEuc3ViamVjdFByaXZhdGVLZXkgPSBuZGF0YS5zdWJqZWN0UHVibGljS2V5XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdlYycsXG4gICAgICAgICAgICBkYXRhOiBuZGF0YVxuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAnMS4yLjg0MC4xMDA0MC40LjEnOlxuICAgICAgICAgIG5kYXRhLmFsZ29yaXRobS5wYXJhbXMucHViX2tleSA9IGFzbjEuRFNBcGFyYW0uZGVjb2RlKG5kYXRhLnN1YmplY3RQdWJsaWNLZXkuZGF0YSwgJ2RlcicpXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdkc2EnLFxuICAgICAgICAgICAgZGF0YTogbmRhdGEuYWxnb3JpdGhtLnBhcmFtc1xuICAgICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGtleSBpZCAnICsgc3VidHlwZSlcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biBrZXkgdHlwZSAnICsgdHlwZSlcbiAgICBjYXNlICdFTkNSWVBURUQgUFJJVkFURSBLRVknOlxuICAgICAgZGF0YSA9IGFzbjEuRW5jcnlwdGVkUHJpdmF0ZUtleS5kZWNvZGUoZGF0YSwgJ2RlcicpXG4gICAgICBkYXRhID0gZGVjcnlwdChkYXRhLCBwYXNzd29yZClcbiAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICBjYXNlICdQUklWQVRFIEtFWSc6XG4gICAgICBuZGF0YSA9IGFzbjEuUHJpdmF0ZUtleS5kZWNvZGUoZGF0YSwgJ2RlcicpXG4gICAgICBzdWJ0eXBlID0gbmRhdGEuYWxnb3JpdGhtLmFsZ29yaXRobS5qb2luKCcuJylcbiAgICAgIHN3aXRjaCAoc3VidHlwZSkge1xuICAgICAgICBjYXNlICcxLjIuODQwLjExMzU0OS4xLjEuMSc6XG4gICAgICAgICAgcmV0dXJuIGFzbjEuUlNBUHJpdmF0ZUtleS5kZWNvZGUobmRhdGEuc3ViamVjdFByaXZhdGVLZXksICdkZXInKVxuICAgICAgICBjYXNlICcxLjIuODQwLjEwMDQ1LjIuMSc6XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGN1cnZlOiBuZGF0YS5hbGdvcml0aG0uY3VydmUsXG4gICAgICAgICAgICBwcml2YXRlS2V5OiBhc24xLkVDUHJpdmF0ZUtleS5kZWNvZGUobmRhdGEuc3ViamVjdFByaXZhdGVLZXksICdkZXInKS5wcml2YXRlS2V5XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlICcxLjIuODQwLjEwMDQwLjQuMSc6XG4gICAgICAgICAgbmRhdGEuYWxnb3JpdGhtLnBhcmFtcy5wcml2X2tleSA9IGFzbjEuRFNBcGFyYW0uZGVjb2RlKG5kYXRhLnN1YmplY3RQcml2YXRlS2V5LCAnZGVyJylcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ2RzYScsXG4gICAgICAgICAgICBwYXJhbXM6IG5kYXRhLmFsZ29yaXRobS5wYXJhbXNcbiAgICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcigndW5rbm93biBrZXkgaWQgJyArIHN1YnR5cGUpXG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24ga2V5IHR5cGUgJyArIHR5cGUpXG4gICAgY2FzZSAnUlNBIFBVQkxJQyBLRVknOlxuICAgICAgcmV0dXJuIGFzbjEuUlNBUHVibGljS2V5LmRlY29kZShkYXRhLCAnZGVyJylcbiAgICBjYXNlICdSU0EgUFJJVkFURSBLRVknOlxuICAgICAgcmV0dXJuIGFzbjEuUlNBUHJpdmF0ZUtleS5kZWNvZGUoZGF0YSwgJ2RlcicpXG4gICAgY2FzZSAnRFNBIFBSSVZBVEUgS0VZJzpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdkc2EnLFxuICAgICAgICBwYXJhbXM6IGFzbjEuRFNBUHJpdmF0ZUtleS5kZWNvZGUoZGF0YSwgJ2RlcicpXG4gICAgICB9XG4gICAgY2FzZSAnRUMgUFJJVkFURSBLRVknOlxuICAgICAgZGF0YSA9IGFzbjEuRUNQcml2YXRlS2V5LmRlY29kZShkYXRhLCAnZGVyJylcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGN1cnZlOiBkYXRhLnBhcmFtZXRlcnMudmFsdWUsXG4gICAgICAgIHByaXZhdGVLZXk6IGRhdGEucHJpdmF0ZUtleVxuICAgICAgfVxuICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcigndW5rbm93biBrZXkgdHlwZSAnICsgdHlwZSlcbiAgfVxufVxucGFyc2VLZXlzLnNpZ25hdHVyZSA9IGFzbjEuc2lnbmF0dXJlXG5mdW5jdGlvbiBkZWNyeXB0IChkYXRhLCBwYXNzd29yZCkge1xuICB2YXIgc2FsdCA9IGRhdGEuYWxnb3JpdGhtLmRlY3J5cHQua2RlLmtkZXBhcmFtcy5zYWx0XG4gIHZhciBpdGVycyA9IHBhcnNlSW50KGRhdGEuYWxnb3JpdGhtLmRlY3J5cHQua2RlLmtkZXBhcmFtcy5pdGVycy50b1N0cmluZygpLCAxMClcbiAgdmFyIGFsZ28gPSBhZXNpZFtkYXRhLmFsZ29yaXRobS5kZWNyeXB0LmNpcGhlci5hbGdvLmpvaW4oJy4nKV1cbiAgdmFyIGl2ID0gZGF0YS5hbGdvcml0aG0uZGVjcnlwdC5jaXBoZXIuaXZcbiAgdmFyIGNpcGhlclRleHQgPSBkYXRhLnN1YmplY3RQcml2YXRlS2V5XG4gIHZhciBrZXlsZW4gPSBwYXJzZUludChhbGdvLnNwbGl0KCctJylbMV0sIDEwKSAvIDhcbiAgdmFyIGtleSA9IGNvbXBhdC5wYmtkZjJTeW5jKHBhc3N3b3JkLCBzYWx0LCBpdGVycywga2V5bGVuKVxuICB2YXIgY2lwaGVyID0gY2lwaGVycy5jcmVhdGVEZWNpcGhlcml2KGFsZ28sIGtleSwgaXYpXG4gIHZhciBvdXQgPSBbXVxuICBvdXQucHVzaChjaXBoZXIudXBkYXRlKGNpcGhlclRleHQpKVxuICBvdXQucHVzaChjaXBoZXIuZmluYWwoKSlcbiAgcmV0dXJuIEJ1ZmZlci5jb25jYXQob3V0KVxufVxuIiwiLy8gYmFzZWQgb24gdGhlIGFlcyBpbXBsaW1lbnRhdGlvbiBpbiB0cmlwbGUgc2VjXG4vLyBodHRwczovL2dpdGh1Yi5jb20va2V5YmFzZS90cmlwbGVzZWNcblxuLy8gd2hpY2ggaXMgaW4gdHVybiBiYXNlZCBvbiB0aGUgb25lIGZyb20gY3J5cHRvLWpzXG4vLyBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2NyeXB0by1qcy9cblxudmFyIHVpbnRfbWF4ID0gTWF0aC5wb3coMiwgMzIpXG5mdW5jdGlvbiBmaXh1cF91aW50MzIgKHgpIHtcbiAgdmFyIHJldCwgeF9wb3NcbiAgcmV0ID0geCA+IHVpbnRfbWF4IHx8IHggPCAwID8gKHhfcG9zID0gTWF0aC5hYnMoeCkgJSB1aW50X21heCwgeCA8IDAgPyB1aW50X21heCAtIHhfcG9zIDogeF9wb3MpIDogeFxuICByZXR1cm4gcmV0XG59XG5mdW5jdGlvbiBzY3J1Yl92ZWMgKHYpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2Lmxlbmd0aDsgdisrKSB7XG4gICAgdltpXSA9IDBcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gR2xvYmFsICgpIHtcbiAgdGhpcy5TQk9YID0gW11cbiAgdGhpcy5JTlZfU0JPWCA9IFtdXG4gIHRoaXMuU1VCX01JWCA9IFtbXSwgW10sIFtdLCBbXV1cbiAgdGhpcy5JTlZfU1VCX01JWCA9IFtbXSwgW10sIFtdLCBbXV1cbiAgdGhpcy5pbml0KClcbiAgdGhpcy5SQ09OID0gWzB4MDAsIDB4MDEsIDB4MDIsIDB4MDQsIDB4MDgsIDB4MTAsIDB4MjAsIDB4NDAsIDB4ODAsIDB4MWIsIDB4MzZdXG59XG5cbkdsb2JhbC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGQsIGksIHN4LCB0LCB4LCB4MiwgeDQsIHg4LCB4aSwgX2lcbiAgZCA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9pLCBfcmVzdWx0c1xuICAgIF9yZXN1bHRzID0gW11cbiAgICBmb3IgKGkgPSBfaSA9IDA7IF9pIDwgMjU2OyBpID0gKytfaSkge1xuICAgICAgaWYgKGkgPCAxMjgpIHtcbiAgICAgICAgX3Jlc3VsdHMucHVzaChpIDw8IDEpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfcmVzdWx0cy5wdXNoKChpIDw8IDEpIF4gMHgxMWIpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBfcmVzdWx0c1xuICB9KSgpXG4gIHggPSAwXG4gIHhpID0gMFxuICBmb3IgKGkgPSBfaSA9IDA7IF9pIDwgMjU2OyBpID0gKytfaSkge1xuICAgIHN4ID0geGkgXiAoeGkgPDwgMSkgXiAoeGkgPDwgMikgXiAoeGkgPDwgMykgXiAoeGkgPDwgNClcbiAgICBzeCA9IChzeCA+Pj4gOCkgXiAoc3ggJiAweGZmKSBeIDB4NjNcbiAgICB0aGlzLlNCT1hbeF0gPSBzeFxuICAgIHRoaXMuSU5WX1NCT1hbc3hdID0geFxuICAgIHgyID0gZFt4XVxuICAgIHg0ID0gZFt4Ml1cbiAgICB4OCA9IGRbeDRdXG4gICAgdCA9IChkW3N4XSAqIDB4MTAxKSBeIChzeCAqIDB4MTAxMDEwMClcbiAgICB0aGlzLlNVQl9NSVhbMF1beF0gPSAodCA8PCAyNCkgfCAodCA+Pj4gOClcbiAgICB0aGlzLlNVQl9NSVhbMV1beF0gPSAodCA8PCAxNikgfCAodCA+Pj4gMTYpXG4gICAgdGhpcy5TVUJfTUlYWzJdW3hdID0gKHQgPDwgOCkgfCAodCA+Pj4gMjQpXG4gICAgdGhpcy5TVUJfTUlYWzNdW3hdID0gdFxuICAgIHQgPSAoeDggKiAweDEwMTAxMDEpIF4gKHg0ICogMHgxMDAwMSkgXiAoeDIgKiAweDEwMSkgXiAoeCAqIDB4MTAxMDEwMClcbiAgICB0aGlzLklOVl9TVUJfTUlYWzBdW3N4XSA9ICh0IDw8IDI0KSB8ICh0ID4+PiA4KVxuICAgIHRoaXMuSU5WX1NVQl9NSVhbMV1bc3hdID0gKHQgPDwgMTYpIHwgKHQgPj4+IDE2KVxuICAgIHRoaXMuSU5WX1NVQl9NSVhbMl1bc3hdID0gKHQgPDwgOCkgfCAodCA+Pj4gMjQpXG4gICAgdGhpcy5JTlZfU1VCX01JWFszXVtzeF0gPSB0XG4gICAgaWYgKHggPT09IDApIHtcbiAgICAgIHggPSB4aSA9IDFcbiAgICB9IGVsc2Uge1xuICAgICAgeCA9IHgyIF4gZFtkW2RbeDggXiB4Ml1dXVxuICAgICAgeGkgXj0gZFtkW3hpXV1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxudmFyIEcgPSBuZXcgR2xvYmFsKClcblxuQUVTLmJsb2NrU2l6ZSA9IDQgKiA0XG5cbkFFUy5wcm90b3R5cGUuYmxvY2tTaXplID0gQUVTLmJsb2NrU2l6ZVxuXG5BRVMua2V5U2l6ZSA9IDI1NiAvIDhcblxuQUVTLnByb3RvdHlwZS5rZXlTaXplID0gQUVTLmtleVNpemVcblxuZnVuY3Rpb24gYnVmZmVyVG9BcnJheSAoYnVmKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoIC8gNFxuICB2YXIgb3V0ID0gbmV3IEFycmF5KGxlbilcbiAgdmFyIGkgPSAtMVxuICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgb3V0W2ldID0gYnVmLnJlYWRVSW50MzJCRShpICogNClcbiAgfVxuICByZXR1cm4gb3V0XG59XG5mdW5jdGlvbiBBRVMgKGtleSkge1xuICB0aGlzLl9rZXkgPSBidWZmZXJUb0FycmF5KGtleSlcbiAgdGhpcy5fZG9SZXNldCgpXG59XG5cbkFFUy5wcm90b3R5cGUuX2RvUmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBpbnZLc1Jvdywga2V5U2l6ZSwga2V5V29yZHMsIGtzUm93LCBrc1Jvd3MsIHRcbiAga2V5V29yZHMgPSB0aGlzLl9rZXlcbiAga2V5U2l6ZSA9IGtleVdvcmRzLmxlbmd0aFxuICB0aGlzLl9uUm91bmRzID0ga2V5U2l6ZSArIDZcbiAga3NSb3dzID0gKHRoaXMuX25Sb3VuZHMgKyAxKSAqIDRcbiAgdGhpcy5fa2V5U2NoZWR1bGUgPSBbXVxuICBmb3IgKGtzUm93ID0gMDsga3NSb3cgPCBrc1Jvd3M7IGtzUm93KyspIHtcbiAgICB0aGlzLl9rZXlTY2hlZHVsZVtrc1Jvd10gPSBrc1JvdyA8IGtleVNpemUgPyBrZXlXb3Jkc1trc1Jvd10gOiAodCA9IHRoaXMuX2tleVNjaGVkdWxlW2tzUm93IC0gMV0sIChrc1JvdyAlIGtleVNpemUpID09PSAwID8gKHQgPSAodCA8PCA4KSB8ICh0ID4+PiAyNCksIHQgPSAoRy5TQk9YW3QgPj4+IDI0XSA8PCAyNCkgfCAoRy5TQk9YWyh0ID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoRy5TQk9YWyh0ID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgRy5TQk9YW3QgJiAweGZmXSwgdCBePSBHLlJDT05bKGtzUm93IC8ga2V5U2l6ZSkgfCAwXSA8PCAyNCkgOiBrZXlTaXplID4gNiAmJiBrc1JvdyAlIGtleVNpemUgPT09IDQgPyB0ID0gKEcuU0JPWFt0ID4+PiAyNF0gPDwgMjQpIHwgKEcuU0JPWFsodCA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKEcuU0JPWFsodCA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IEcuU0JPWFt0ICYgMHhmZl0gOiB2b2lkIDAsIHRoaXMuX2tleVNjaGVkdWxlW2tzUm93IC0ga2V5U2l6ZV0gXiB0KVxuICB9XG4gIHRoaXMuX2ludktleVNjaGVkdWxlID0gW11cbiAgZm9yIChpbnZLc1JvdyA9IDA7IGludktzUm93IDwga3NSb3dzOyBpbnZLc1JvdysrKSB7XG4gICAga3NSb3cgPSBrc1Jvd3MgLSBpbnZLc1Jvd1xuICAgIHQgPSB0aGlzLl9rZXlTY2hlZHVsZVtrc1JvdyAtIChpbnZLc1JvdyAlIDQgPyAwIDogNCldXG4gICAgdGhpcy5faW52S2V5U2NoZWR1bGVbaW52S3NSb3ddID0gaW52S3NSb3cgPCA0IHx8IGtzUm93IDw9IDQgPyB0IDogRy5JTlZfU1VCX01JWFswXVtHLlNCT1hbdCA+Pj4gMjRdXSBeIEcuSU5WX1NVQl9NSVhbMV1bRy5TQk9YWyh0ID4+PiAxNikgJiAweGZmXV0gXiBHLklOVl9TVUJfTUlYWzJdW0cuU0JPWFsodCA+Pj4gOCkgJiAweGZmXV0gXiBHLklOVl9TVUJfTUlYWzNdW0cuU0JPWFt0ICYgMHhmZl1dXG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuQUVTLnByb3RvdHlwZS5lbmNyeXB0QmxvY2sgPSBmdW5jdGlvbiAoTSkge1xuICBNID0gYnVmZmVyVG9BcnJheShuZXcgQnVmZmVyKE0pKVxuICB2YXIgb3V0ID0gdGhpcy5fZG9DcnlwdEJsb2NrKE0sIHRoaXMuX2tleVNjaGVkdWxlLCBHLlNVQl9NSVgsIEcuU0JPWClcbiAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIoMTYpXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKG91dFswXSwgMClcbiAgYnVmLndyaXRlVUludDMyQkUob3V0WzFdLCA0KVxuICBidWYud3JpdGVVSW50MzJCRShvdXRbMl0sIDgpXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKG91dFszXSwgMTIpXG4gIHJldHVybiBidWZcbn1cblxuQUVTLnByb3RvdHlwZS5kZWNyeXB0QmxvY2sgPSBmdW5jdGlvbiAoTSkge1xuICBNID0gYnVmZmVyVG9BcnJheShuZXcgQnVmZmVyKE0pKVxuICB2YXIgdGVtcCA9IFtNWzNdLCBNWzFdXVxuICBNWzFdID0gdGVtcFswXVxuICBNWzNdID0gdGVtcFsxXVxuICB2YXIgb3V0ID0gdGhpcy5fZG9DcnlwdEJsb2NrKE0sIHRoaXMuX2ludktleVNjaGVkdWxlLCBHLklOVl9TVUJfTUlYLCBHLklOVl9TQk9YKVxuICB2YXIgYnVmID0gbmV3IEJ1ZmZlcigxNilcbiAgYnVmLndyaXRlVUludDMyQkUob3V0WzBdLCAwKVxuICBidWYud3JpdGVVSW50MzJCRShvdXRbM10sIDQpXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKG91dFsyXSwgOClcbiAgYnVmLndyaXRlVUludDMyQkUob3V0WzFdLCAxMilcbiAgcmV0dXJuIGJ1ZlxufVxuXG5BRVMucHJvdG90eXBlLnNjcnViID0gZnVuY3Rpb24gKCkge1xuICBzY3J1Yl92ZWModGhpcy5fa2V5U2NoZWR1bGUpXG4gIHNjcnViX3ZlYyh0aGlzLl9pbnZLZXlTY2hlZHVsZSlcbiAgc2NydWJfdmVjKHRoaXMuX2tleSlcbn1cblxuQUVTLnByb3RvdHlwZS5fZG9DcnlwdEJsb2NrID0gZnVuY3Rpb24gKE0sIGtleVNjaGVkdWxlLCBTVUJfTUlYLCBTQk9YKSB7XG4gIHZhciBrc1JvdywgczAsIHMxLCBzMiwgczMsIHQwLCB0MSwgdDIsIHQzXG5cbiAgczAgPSBNWzBdIF4ga2V5U2NoZWR1bGVbMF1cbiAgczEgPSBNWzFdIF4ga2V5U2NoZWR1bGVbMV1cbiAgczIgPSBNWzJdIF4ga2V5U2NoZWR1bGVbMl1cbiAgczMgPSBNWzNdIF4ga2V5U2NoZWR1bGVbM11cbiAga3NSb3cgPSA0XG4gIGZvciAodmFyIHJvdW5kID0gMTsgcm91bmQgPCB0aGlzLl9uUm91bmRzOyByb3VuZCsrKSB7XG4gICAgdDAgPSBTVUJfTUlYWzBdW3MwID4+PiAyNF0gXiBTVUJfTUlYWzFdWyhzMSA+Pj4gMTYpICYgMHhmZl0gXiBTVUJfTUlYWzJdWyhzMiA+Pj4gOCkgJiAweGZmXSBeIFNVQl9NSVhbM11bczMgJiAweGZmXSBeIGtleVNjaGVkdWxlW2tzUm93KytdXG4gICAgdDEgPSBTVUJfTUlYWzBdW3MxID4+PiAyNF0gXiBTVUJfTUlYWzFdWyhzMiA+Pj4gMTYpICYgMHhmZl0gXiBTVUJfTUlYWzJdWyhzMyA+Pj4gOCkgJiAweGZmXSBeIFNVQl9NSVhbM11bczAgJiAweGZmXSBeIGtleVNjaGVkdWxlW2tzUm93KytdXG4gICAgdDIgPSBTVUJfTUlYWzBdW3MyID4+PiAyNF0gXiBTVUJfTUlYWzFdWyhzMyA+Pj4gMTYpICYgMHhmZl0gXiBTVUJfTUlYWzJdWyhzMCA+Pj4gOCkgJiAweGZmXSBeIFNVQl9NSVhbM11bczEgJiAweGZmXSBeIGtleVNjaGVkdWxlW2tzUm93KytdXG4gICAgdDMgPSBTVUJfTUlYWzBdW3MzID4+PiAyNF0gXiBTVUJfTUlYWzFdWyhzMCA+Pj4gMTYpICYgMHhmZl0gXiBTVUJfTUlYWzJdWyhzMSA+Pj4gOCkgJiAweGZmXSBeIFNVQl9NSVhbM11bczIgJiAweGZmXSBeIGtleVNjaGVkdWxlW2tzUm93KytdXG4gICAgczAgPSB0MFxuICAgIHMxID0gdDFcbiAgICBzMiA9IHQyXG4gICAgczMgPSB0M1xuICB9XG4gIHQwID0gKChTQk9YW3MwID4+PiAyNF0gPDwgMjQpIHwgKFNCT1hbKHMxID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoU0JPWFsoczIgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBTQk9YW3MzICYgMHhmZl0pIF4ga2V5U2NoZWR1bGVba3NSb3crK11cbiAgdDEgPSAoKFNCT1hbczEgPj4+IDI0XSA8PCAyNCkgfCAoU0JPWFsoczIgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChTQk9YWyhzMyA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IFNCT1hbczAgJiAweGZmXSkgXiBrZXlTY2hlZHVsZVtrc1JvdysrXVxuICB0MiA9ICgoU0JPWFtzMiA+Pj4gMjRdIDw8IDI0KSB8IChTQk9YWyhzMyA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKFNCT1hbKHMwID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgU0JPWFtzMSAmIDB4ZmZdKSBeIGtleVNjaGVkdWxlW2tzUm93KytdXG4gIHQzID0gKChTQk9YW3MzID4+PiAyNF0gPDwgMjQpIHwgKFNCT1hbKHMwID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoU0JPWFsoczEgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBTQk9YW3MyICYgMHhmZl0pIF4ga2V5U2NoZWR1bGVba3NSb3crK11cbiAgcmV0dXJuIFtcbiAgICBmaXh1cF91aW50MzIodDApLFxuICAgIGZpeHVwX3VpbnQzMih0MSksXG4gICAgZml4dXBfdWludDMyKHQyKSxcbiAgICBmaXh1cF91aW50MzIodDMpXG4gIF1cbn1cblxuZXhwb3J0cy5BRVMgPSBBRVNcbiIsInZhciBhZXMgPSByZXF1aXJlKCcuL2FlcycpXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnY2lwaGVyLWJhc2UnKVxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIEdIQVNIID0gcmVxdWlyZSgnLi9naGFzaCcpXG52YXIgeG9yID0gcmVxdWlyZSgnYnVmZmVyLXhvcicpXG5pbmhlcml0cyhTdHJlYW1DaXBoZXIsIFRyYW5zZm9ybSlcbm1vZHVsZS5leHBvcnRzID0gU3RyZWFtQ2lwaGVyXG5cbmZ1bmN0aW9uIFN0cmVhbUNpcGhlciAobW9kZSwga2V5LCBpdiwgZGVjcnlwdCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU3RyZWFtQ2lwaGVyKSkge1xuICAgIHJldHVybiBuZXcgU3RyZWFtQ2lwaGVyKG1vZGUsIGtleSwgaXYpXG4gIH1cbiAgVHJhbnNmb3JtLmNhbGwodGhpcylcbiAgdGhpcy5fZmluSUQgPSBCdWZmZXIuY29uY2F0KFtpdiwgbmV3IEJ1ZmZlcihbMCwgMCwgMCwgMV0pXSlcbiAgaXYgPSBCdWZmZXIuY29uY2F0KFtpdiwgbmV3IEJ1ZmZlcihbMCwgMCwgMCwgMl0pXSlcbiAgdGhpcy5fY2lwaGVyID0gbmV3IGFlcy5BRVMoa2V5KVxuICB0aGlzLl9wcmV2ID0gbmV3IEJ1ZmZlcihpdi5sZW5ndGgpXG4gIHRoaXMuX2NhY2hlID0gbmV3IEJ1ZmZlcignJylcbiAgdGhpcy5fc2VjQ2FjaGUgPSBuZXcgQnVmZmVyKCcnKVxuICB0aGlzLl9kZWNyeXB0ID0gZGVjcnlwdFxuICB0aGlzLl9hbGVuID0gMFxuICB0aGlzLl9sZW4gPSAwXG4gIGl2LmNvcHkodGhpcy5fcHJldilcbiAgdGhpcy5fbW9kZSA9IG1vZGVcbiAgdmFyIGggPSBuZXcgQnVmZmVyKDQpXG4gIGguZmlsbCgwKVxuICB0aGlzLl9naGFzaCA9IG5ldyBHSEFTSCh0aGlzLl9jaXBoZXIuZW5jcnlwdEJsb2NrKGgpKVxuICB0aGlzLl9hdXRoVGFnID0gbnVsbFxuICB0aGlzLl9jYWxsZWQgPSBmYWxzZVxufVxuU3RyZWFtQ2lwaGVyLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIGlmICghdGhpcy5fY2FsbGVkICYmIHRoaXMuX2FsZW4pIHtcbiAgICB2YXIgcnVtcCA9IDE2IC0gKHRoaXMuX2FsZW4gJSAxNilcbiAgICBpZiAocnVtcCA8IDE2KSB7XG4gICAgICBydW1wID0gbmV3IEJ1ZmZlcihydW1wKVxuICAgICAgcnVtcC5maWxsKDApXG4gICAgICB0aGlzLl9naGFzaC51cGRhdGUocnVtcClcbiAgICB9XG4gIH1cbiAgdGhpcy5fY2FsbGVkID0gdHJ1ZVxuICB2YXIgb3V0ID0gdGhpcy5fbW9kZS5lbmNyeXB0KHRoaXMsIGNodW5rKVxuICBpZiAodGhpcy5fZGVjcnlwdCkge1xuICAgIHRoaXMuX2doYXNoLnVwZGF0ZShjaHVuaylcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9naGFzaC51cGRhdGUob3V0KVxuICB9XG4gIHRoaXMuX2xlbiArPSBjaHVuay5sZW5ndGhcbiAgcmV0dXJuIG91dFxufVxuU3RyZWFtQ2lwaGVyLnByb3RvdHlwZS5fZmluYWwgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLl9kZWNyeXB0ICYmICF0aGlzLl9hdXRoVGFnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBzdGF0ZSBvciB1bmFibGUgdG8gYXV0aGVudGljYXRlIGRhdGEnKVxuICB9XG4gIHZhciB0YWcgPSB4b3IodGhpcy5fZ2hhc2guZmluYWwodGhpcy5fYWxlbiAqIDgsIHRoaXMuX2xlbiAqIDgpLCB0aGlzLl9jaXBoZXIuZW5jcnlwdEJsb2NrKHRoaXMuX2ZpbklEKSlcbiAgaWYgKHRoaXMuX2RlY3J5cHQpIHtcbiAgICBpZiAoeG9yVGVzdCh0YWcsIHRoaXMuX2F1dGhUYWcpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHN0YXRlIG9yIHVuYWJsZSB0byBhdXRoZW50aWNhdGUgZGF0YScpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRoaXMuX2F1dGhUYWcgPSB0YWdcbiAgfVxuICB0aGlzLl9jaXBoZXIuc2NydWIoKVxufVxuU3RyZWFtQ2lwaGVyLnByb3RvdHlwZS5nZXRBdXRoVGFnID0gZnVuY3Rpb24gZ2V0QXV0aFRhZyAoKSB7XG4gIGlmICghdGhpcy5fZGVjcnlwdCAmJiBCdWZmZXIuaXNCdWZmZXIodGhpcy5fYXV0aFRhZykpIHtcbiAgICByZXR1cm4gdGhpcy5fYXV0aFRhZ1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignQXR0ZW1wdGluZyB0byBnZXQgYXV0aCB0YWcgaW4gdW5zdXBwb3J0ZWQgc3RhdGUnKVxuICB9XG59XG5TdHJlYW1DaXBoZXIucHJvdG90eXBlLnNldEF1dGhUYWcgPSBmdW5jdGlvbiBzZXRBdXRoVGFnICh0YWcpIHtcbiAgaWYgKHRoaXMuX2RlY3J5cHQpIHtcbiAgICB0aGlzLl9hdXRoVGFnID0gdGFnXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdBdHRlbXB0aW5nIHRvIHNldCBhdXRoIHRhZyBpbiB1bnN1cHBvcnRlZCBzdGF0ZScpXG4gIH1cbn1cblN0cmVhbUNpcGhlci5wcm90b3R5cGUuc2V0QUFEID0gZnVuY3Rpb24gc2V0QUFEIChidWYpIHtcbiAgaWYgKCF0aGlzLl9jYWxsZWQpIHtcbiAgICB0aGlzLl9naGFzaC51cGRhdGUoYnVmKVxuICAgIHRoaXMuX2FsZW4gKz0gYnVmLmxlbmd0aFxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignQXR0ZW1wdGluZyB0byBzZXQgQUFEIGluIHVuc3VwcG9ydGVkIHN0YXRlJylcbiAgfVxufVxuZnVuY3Rpb24geG9yVGVzdCAoYSwgYikge1xuICB2YXIgb3V0ID0gMFxuICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgb3V0KytcbiAgfVxuICB2YXIgbGVuID0gTWF0aC5taW4oYS5sZW5ndGgsIGIubGVuZ3RoKVxuICB2YXIgaSA9IC0xXG4gIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICBvdXQgKz0gKGFbaV0gXiBiW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cbiIsInZhciBhZXMgPSByZXF1aXJlKCcuL2FlcycpXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnY2lwaGVyLWJhc2UnKVxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIG1vZGVzID0gcmVxdWlyZSgnLi9tb2RlcycpXG52YXIgU3RyZWFtQ2lwaGVyID0gcmVxdWlyZSgnLi9zdHJlYW1DaXBoZXInKVxudmFyIEF1dGhDaXBoZXIgPSByZXF1aXJlKCcuL2F1dGhDaXBoZXInKVxudmFyIGVidGsgPSByZXF1aXJlKCdldnBfYnl0ZXN0b2tleScpXG5cbmluaGVyaXRzKERlY2lwaGVyLCBUcmFuc2Zvcm0pXG5mdW5jdGlvbiBEZWNpcGhlciAobW9kZSwga2V5LCBpdikge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRGVjaXBoZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBEZWNpcGhlcihtb2RlLCBrZXksIGl2KVxuICB9XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMpXG4gIHRoaXMuX2NhY2hlID0gbmV3IFNwbGl0dGVyKClcbiAgdGhpcy5fbGFzdCA9IHZvaWQgMFxuICB0aGlzLl9jaXBoZXIgPSBuZXcgYWVzLkFFUyhrZXkpXG4gIHRoaXMuX3ByZXYgPSBuZXcgQnVmZmVyKGl2Lmxlbmd0aClcbiAgaXYuY29weSh0aGlzLl9wcmV2KVxuICB0aGlzLl9tb2RlID0gbW9kZVxuICB0aGlzLl9hdXRvcGFkZGluZyA9IHRydWVcbn1cbkRlY2lwaGVyLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgdGhpcy5fY2FjaGUuYWRkKGRhdGEpXG4gIHZhciBjaHVua1xuICB2YXIgdGhpbmdcbiAgdmFyIG91dCA9IFtdXG4gIHdoaWxlICgoY2h1bmsgPSB0aGlzLl9jYWNoZS5nZXQodGhpcy5fYXV0b3BhZGRpbmcpKSkge1xuICAgIHRoaW5nID0gdGhpcy5fbW9kZS5kZWNyeXB0KHRoaXMsIGNodW5rKVxuICAgIG91dC5wdXNoKHRoaW5nKVxuICB9XG4gIHJldHVybiBCdWZmZXIuY29uY2F0KG91dClcbn1cbkRlY2lwaGVyLnByb3RvdHlwZS5fZmluYWwgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBjaHVuayA9IHRoaXMuX2NhY2hlLmZsdXNoKClcbiAgaWYgKHRoaXMuX2F1dG9wYWRkaW5nKSB7XG4gICAgcmV0dXJuIHVucGFkKHRoaXMuX21vZGUuZGVjcnlwdCh0aGlzLCBjaHVuaykpXG4gIH0gZWxzZSBpZiAoY2h1bmspIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2RhdGEgbm90IG11bHRpcGxlIG9mIGJsb2NrIGxlbmd0aCcpXG4gIH1cbn1cbkRlY2lwaGVyLnByb3RvdHlwZS5zZXRBdXRvUGFkZGluZyA9IGZ1bmN0aW9uIChzZXRUbykge1xuICB0aGlzLl9hdXRvcGFkZGluZyA9ICEhc2V0VG9cbn1cbmZ1bmN0aW9uIFNwbGl0dGVyICgpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNwbGl0dGVyKSkge1xuICAgIHJldHVybiBuZXcgU3BsaXR0ZXIoKVxuICB9XG4gIHRoaXMuY2FjaGUgPSBuZXcgQnVmZmVyKCcnKVxufVxuU3BsaXR0ZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHRoaXMuY2FjaGUgPSBCdWZmZXIuY29uY2F0KFt0aGlzLmNhY2hlLCBkYXRhXSlcbn1cblxuU3BsaXR0ZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChhdXRvUGFkZGluZykge1xuICB2YXIgb3V0XG4gIGlmIChhdXRvUGFkZGluZykge1xuICAgIGlmICh0aGlzLmNhY2hlLmxlbmd0aCA+IDE2KSB7XG4gICAgICBvdXQgPSB0aGlzLmNhY2hlLnNsaWNlKDAsIDE2KVxuICAgICAgdGhpcy5jYWNoZSA9IHRoaXMuY2FjaGUuc2xpY2UoMTYpXG4gICAgICByZXR1cm4gb3V0XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh0aGlzLmNhY2hlLmxlbmd0aCA+PSAxNikge1xuICAgICAgb3V0ID0gdGhpcy5jYWNoZS5zbGljZSgwLCAxNilcbiAgICAgIHRoaXMuY2FjaGUgPSB0aGlzLmNhY2hlLnNsaWNlKDE2KVxuICAgICAgcmV0dXJuIG91dFxuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbFxufVxuU3BsaXR0ZXIucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5jYWNoZS5sZW5ndGgpIHtcbiAgICByZXR1cm4gdGhpcy5jYWNoZVxuICB9XG59XG5mdW5jdGlvbiB1bnBhZCAobGFzdCkge1xuICB2YXIgcGFkZGVkID0gbGFzdFsxNV1cbiAgdmFyIGkgPSAtMVxuICB3aGlsZSAoKytpIDwgcGFkZGVkKSB7XG4gICAgaWYgKGxhc3RbKGkgKyAoMTYgLSBwYWRkZWQpKV0gIT09IHBhZGRlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmFibGUgdG8gZGVjcnlwdCBkYXRhJylcbiAgICB9XG4gIH1cbiAgaWYgKHBhZGRlZCA9PT0gMTYpIHtcbiAgICByZXR1cm5cbiAgfVxuICByZXR1cm4gbGFzdC5zbGljZSgwLCAxNiAtIHBhZGRlZClcbn1cblxudmFyIG1vZGVsaXN0ID0ge1xuICBFQ0I6IHJlcXVpcmUoJy4vbW9kZXMvZWNiJyksXG4gIENCQzogcmVxdWlyZSgnLi9tb2Rlcy9jYmMnKSxcbiAgQ0ZCOiByZXF1aXJlKCcuL21vZGVzL2NmYicpLFxuICBDRkI4OiByZXF1aXJlKCcuL21vZGVzL2NmYjgnKSxcbiAgQ0ZCMTogcmVxdWlyZSgnLi9tb2Rlcy9jZmIxJyksXG4gIE9GQjogcmVxdWlyZSgnLi9tb2Rlcy9vZmInKSxcbiAgQ1RSOiByZXF1aXJlKCcuL21vZGVzL2N0cicpLFxuICBHQ006IHJlcXVpcmUoJy4vbW9kZXMvY3RyJylcbn1cblxuZnVuY3Rpb24gY3JlYXRlRGVjaXBoZXJpdiAoc3VpdGUsIHBhc3N3b3JkLCBpdikge1xuICB2YXIgY29uZmlnID0gbW9kZXNbc3VpdGUudG9Mb3dlckNhc2UoKV1cbiAgaWYgKCFjb25maWcpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHN1aXRlIHR5cGUnKVxuICB9XG4gIGlmICh0eXBlb2YgaXYgPT09ICdzdHJpbmcnKSB7XG4gICAgaXYgPSBuZXcgQnVmZmVyKGl2KVxuICB9XG4gIGlmICh0eXBlb2YgcGFzc3dvcmQgPT09ICdzdHJpbmcnKSB7XG4gICAgcGFzc3dvcmQgPSBuZXcgQnVmZmVyKHBhc3N3b3JkKVxuICB9XG4gIGlmIChwYXNzd29yZC5sZW5ndGggIT09IGNvbmZpZy5rZXkgLyA4KSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBrZXkgbGVuZ3RoICcgKyBwYXNzd29yZC5sZW5ndGgpXG4gIH1cbiAgaWYgKGl2Lmxlbmd0aCAhPT0gY29uZmlnLml2KSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBpdiBsZW5ndGggJyArIGl2Lmxlbmd0aClcbiAgfVxuICBpZiAoY29uZmlnLnR5cGUgPT09ICdzdHJlYW0nKSB7XG4gICAgcmV0dXJuIG5ldyBTdHJlYW1DaXBoZXIobW9kZWxpc3RbY29uZmlnLm1vZGVdLCBwYXNzd29yZCwgaXYsIHRydWUpXG4gIH0gZWxzZSBpZiAoY29uZmlnLnR5cGUgPT09ICdhdXRoJykge1xuICAgIHJldHVybiBuZXcgQXV0aENpcGhlcihtb2RlbGlzdFtjb25maWcubW9kZV0sIHBhc3N3b3JkLCBpdiwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gbmV3IERlY2lwaGVyKG1vZGVsaXN0W2NvbmZpZy5tb2RlXSwgcGFzc3dvcmQsIGl2KVxufVxuXG5mdW5jdGlvbiBjcmVhdGVEZWNpcGhlciAoc3VpdGUsIHBhc3N3b3JkKSB7XG4gIHZhciBjb25maWcgPSBtb2Rlc1tzdWl0ZS50b0xvd2VyQ2FzZSgpXVxuICBpZiAoIWNvbmZpZykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgc3VpdGUgdHlwZScpXG4gIH1cbiAgdmFyIGtleXMgPSBlYnRrKHBhc3N3b3JkLCBmYWxzZSwgY29uZmlnLmtleSwgY29uZmlnLml2KVxuICByZXR1cm4gY3JlYXRlRGVjaXBoZXJpdihzdWl0ZSwga2V5cy5rZXksIGtleXMuaXYpXG59XG5leHBvcnRzLmNyZWF0ZURlY2lwaGVyID0gY3JlYXRlRGVjaXBoZXJcbmV4cG9ydHMuY3JlYXRlRGVjaXBoZXJpdiA9IGNyZWF0ZURlY2lwaGVyaXZcbiIsInZhciBhZXMgPSByZXF1aXJlKCcuL2FlcycpXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnY2lwaGVyLWJhc2UnKVxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIG1vZGVzID0gcmVxdWlyZSgnLi9tb2RlcycpXG52YXIgZWJ0ayA9IHJlcXVpcmUoJ2V2cF9ieXRlc3Rva2V5JylcbnZhciBTdHJlYW1DaXBoZXIgPSByZXF1aXJlKCcuL3N0cmVhbUNpcGhlcicpXG52YXIgQXV0aENpcGhlciA9IHJlcXVpcmUoJy4vYXV0aENpcGhlcicpXG5pbmhlcml0cyhDaXBoZXIsIFRyYW5zZm9ybSlcbmZ1bmN0aW9uIENpcGhlciAobW9kZSwga2V5LCBpdikge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQ2lwaGVyKSkge1xuICAgIHJldHVybiBuZXcgQ2lwaGVyKG1vZGUsIGtleSwgaXYpXG4gIH1cbiAgVHJhbnNmb3JtLmNhbGwodGhpcylcbiAgdGhpcy5fY2FjaGUgPSBuZXcgU3BsaXR0ZXIoKVxuICB0aGlzLl9jaXBoZXIgPSBuZXcgYWVzLkFFUyhrZXkpXG4gIHRoaXMuX3ByZXYgPSBuZXcgQnVmZmVyKGl2Lmxlbmd0aClcbiAgaXYuY29weSh0aGlzLl9wcmV2KVxuICB0aGlzLl9tb2RlID0gbW9kZVxuICB0aGlzLl9hdXRvcGFkZGluZyA9IHRydWVcbn1cbkNpcGhlci5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHRoaXMuX2NhY2hlLmFkZChkYXRhKVxuICB2YXIgY2h1bmtcbiAgdmFyIHRoaW5nXG4gIHZhciBvdXQgPSBbXVxuICB3aGlsZSAoKGNodW5rID0gdGhpcy5fY2FjaGUuZ2V0KCkpKSB7XG4gICAgdGhpbmcgPSB0aGlzLl9tb2RlLmVuY3J5cHQodGhpcywgY2h1bmspXG4gICAgb3V0LnB1c2godGhpbmcpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5jb25jYXQob3V0KVxufVxuQ2lwaGVyLnByb3RvdHlwZS5fZmluYWwgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBjaHVuayA9IHRoaXMuX2NhY2hlLmZsdXNoKClcbiAgaWYgKHRoaXMuX2F1dG9wYWRkaW5nKSB7XG4gICAgY2h1bmsgPSB0aGlzLl9tb2RlLmVuY3J5cHQodGhpcywgY2h1bmspXG4gICAgdGhpcy5fY2lwaGVyLnNjcnViKClcbiAgICByZXR1cm4gY2h1bmtcbiAgfSBlbHNlIGlmIChjaHVuay50b1N0cmluZygnaGV4JykgIT09ICcxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMCcpIHtcbiAgICB0aGlzLl9jaXBoZXIuc2NydWIoKVxuICAgIHRocm93IG5ldyBFcnJvcignZGF0YSBub3QgbXVsdGlwbGUgb2YgYmxvY2sgbGVuZ3RoJylcbiAgfVxufVxuQ2lwaGVyLnByb3RvdHlwZS5zZXRBdXRvUGFkZGluZyA9IGZ1bmN0aW9uIChzZXRUbykge1xuICB0aGlzLl9hdXRvcGFkZGluZyA9ICEhc2V0VG9cbn1cblxuZnVuY3Rpb24gU3BsaXR0ZXIgKCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU3BsaXR0ZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBTcGxpdHRlcigpXG4gIH1cbiAgdGhpcy5jYWNoZSA9IG5ldyBCdWZmZXIoJycpXG59XG5TcGxpdHRlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgdGhpcy5jYWNoZSA9IEJ1ZmZlci5jb25jYXQoW3RoaXMuY2FjaGUsIGRhdGFdKVxufVxuXG5TcGxpdHRlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5jYWNoZS5sZW5ndGggPiAxNSkge1xuICAgIHZhciBvdXQgPSB0aGlzLmNhY2hlLnNsaWNlKDAsIDE2KVxuICAgIHRoaXMuY2FjaGUgPSB0aGlzLmNhY2hlLnNsaWNlKDE2KVxuICAgIHJldHVybiBvdXRcbiAgfVxuICByZXR1cm4gbnVsbFxufVxuU3BsaXR0ZXIucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbGVuID0gMTYgLSB0aGlzLmNhY2hlLmxlbmd0aFxuICB2YXIgcGFkQnVmZiA9IG5ldyBCdWZmZXIobGVuKVxuXG4gIHZhciBpID0gLTFcbiAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgIHBhZEJ1ZmYud3JpdGVVSW50OChsZW4sIGkpXG4gIH1cbiAgdmFyIG91dCA9IEJ1ZmZlci5jb25jYXQoW3RoaXMuY2FjaGUsIHBhZEJ1ZmZdKVxuICByZXR1cm4gb3V0XG59XG52YXIgbW9kZWxpc3QgPSB7XG4gIEVDQjogcmVxdWlyZSgnLi9tb2Rlcy9lY2InKSxcbiAgQ0JDOiByZXF1aXJlKCcuL21vZGVzL2NiYycpLFxuICBDRkI6IHJlcXVpcmUoJy4vbW9kZXMvY2ZiJyksXG4gIENGQjg6IHJlcXVpcmUoJy4vbW9kZXMvY2ZiOCcpLFxuICBDRkIxOiByZXF1aXJlKCcuL21vZGVzL2NmYjEnKSxcbiAgT0ZCOiByZXF1aXJlKCcuL21vZGVzL29mYicpLFxuICBDVFI6IHJlcXVpcmUoJy4vbW9kZXMvY3RyJyksXG4gIEdDTTogcmVxdWlyZSgnLi9tb2Rlcy9jdHInKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDaXBoZXJpdiAoc3VpdGUsIHBhc3N3b3JkLCBpdikge1xuICB2YXIgY29uZmlnID0gbW9kZXNbc3VpdGUudG9Mb3dlckNhc2UoKV1cbiAgaWYgKCFjb25maWcpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHN1aXRlIHR5cGUnKVxuICB9XG4gIGlmICh0eXBlb2YgaXYgPT09ICdzdHJpbmcnKSB7XG4gICAgaXYgPSBuZXcgQnVmZmVyKGl2KVxuICB9XG4gIGlmICh0eXBlb2YgcGFzc3dvcmQgPT09ICdzdHJpbmcnKSB7XG4gICAgcGFzc3dvcmQgPSBuZXcgQnVmZmVyKHBhc3N3b3JkKVxuICB9XG4gIGlmIChwYXNzd29yZC5sZW5ndGggIT09IGNvbmZpZy5rZXkgLyA4KSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBrZXkgbGVuZ3RoICcgKyBwYXNzd29yZC5sZW5ndGgpXG4gIH1cbiAgaWYgKGl2Lmxlbmd0aCAhPT0gY29uZmlnLml2KSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBpdiBsZW5ndGggJyArIGl2Lmxlbmd0aClcbiAgfVxuICBpZiAoY29uZmlnLnR5cGUgPT09ICdzdHJlYW0nKSB7XG4gICAgcmV0dXJuIG5ldyBTdHJlYW1DaXBoZXIobW9kZWxpc3RbY29uZmlnLm1vZGVdLCBwYXNzd29yZCwgaXYpXG4gIH0gZWxzZSBpZiAoY29uZmlnLnR5cGUgPT09ICdhdXRoJykge1xuICAgIHJldHVybiBuZXcgQXV0aENpcGhlcihtb2RlbGlzdFtjb25maWcubW9kZV0sIHBhc3N3b3JkLCBpdilcbiAgfVxuICByZXR1cm4gbmV3IENpcGhlcihtb2RlbGlzdFtjb25maWcubW9kZV0sIHBhc3N3b3JkLCBpdilcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNpcGhlciAoc3VpdGUsIHBhc3N3b3JkKSB7XG4gIHZhciBjb25maWcgPSBtb2Rlc1tzdWl0ZS50b0xvd2VyQ2FzZSgpXVxuICBpZiAoIWNvbmZpZykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgc3VpdGUgdHlwZScpXG4gIH1cbiAgdmFyIGtleXMgPSBlYnRrKHBhc3N3b3JkLCBmYWxzZSwgY29uZmlnLmtleSwgY29uZmlnLml2KVxuICByZXR1cm4gY3JlYXRlQ2lwaGVyaXYoc3VpdGUsIGtleXMua2V5LCBrZXlzLml2KVxufVxuXG5leHBvcnRzLmNyZWF0ZUNpcGhlcml2ID0gY3JlYXRlQ2lwaGVyaXZcbmV4cG9ydHMuY3JlYXRlQ2lwaGVyID0gY3JlYXRlQ2lwaGVyXG4iLCJ2YXIgemVyb3MgPSBuZXcgQnVmZmVyKDE2KVxuemVyb3MuZmlsbCgwKVxubW9kdWxlLmV4cG9ydHMgPSBHSEFTSFxuZnVuY3Rpb24gR0hBU0ggKGtleSkge1xuICB0aGlzLmggPSBrZXlcbiAgdGhpcy5zdGF0ZSA9IG5ldyBCdWZmZXIoMTYpXG4gIHRoaXMuc3RhdGUuZmlsbCgwKVxuICB0aGlzLmNhY2hlID0gbmV3IEJ1ZmZlcignJylcbn1cbi8vIGZyb20gaHR0cDovL2JpdHdpc2VzaGlmdGxlZnQuZ2l0aHViLmlvL3NqY2wvZG9jL3N5bWJvbHMvc3JjL2NvcmVfZ2NtLmpzLmh0bWxcbi8vIGJ5IEp1aG8gVsOkaMOkLUhlcnR0dWFcbkdIQVNILnByb3RvdHlwZS5naGFzaCA9IGZ1bmN0aW9uIChibG9jaykge1xuICB2YXIgaSA9IC0xXG4gIHdoaWxlICgrK2kgPCBibG9jay5sZW5ndGgpIHtcbiAgICB0aGlzLnN0YXRlW2ldIF49IGJsb2NrW2ldXG4gIH1cbiAgdGhpcy5fbXVsdGlwbHkoKVxufVxuXG5HSEFTSC5wcm90b3R5cGUuX211bHRpcGx5ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgVmkgPSB0b0FycmF5KHRoaXMuaClcbiAgdmFyIFppID0gWzAsIDAsIDAsIDBdXG4gIHZhciBqLCB4aSwgbHNiX1ZpXG4gIHZhciBpID0gLTFcbiAgd2hpbGUgKCsraSA8IDEyOCkge1xuICAgIHhpID0gKHRoaXMuc3RhdGVbfn4oaSAvIDgpXSAmICgxIDw8ICg3IC0gaSAlIDgpKSkgIT09IDBcbiAgICBpZiAoeGkpIHtcbiAgICAgIC8vIFpfaSsxID0gWl9pIF4gVl9pXG4gICAgICBaaSA9IHhvcihaaSwgVmkpXG4gICAgfVxuXG4gICAgLy8gU3RvcmUgdGhlIHZhbHVlIG9mIExTQihWX2kpXG4gICAgbHNiX1ZpID0gKFZpWzNdICYgMSkgIT09IDBcblxuICAgIC8vIFZfaSsxID0gVl9pID4+IDFcbiAgICBmb3IgKGogPSAzOyBqID4gMDsgai0tKSB7XG4gICAgICBWaVtqXSA9IChWaVtqXSA+Pj4gMSkgfCAoKFZpW2ogLSAxXSAmIDEpIDw8IDMxKVxuICAgIH1cbiAgICBWaVswXSA9IFZpWzBdID4+PiAxXG5cbiAgICAvLyBJZiBMU0IoVl9pKSBpcyAxLCBWX2krMSA9IChWX2kgPj4gMSkgXiBSXG4gICAgaWYgKGxzYl9WaSkge1xuICAgICAgVmlbMF0gPSBWaVswXSBeICgweGUxIDw8IDI0KVxuICAgIH1cbiAgfVxuICB0aGlzLnN0YXRlID0gZnJvbUFycmF5KFppKVxufVxuR0hBU0gucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChidWYpIHtcbiAgdGhpcy5jYWNoZSA9IEJ1ZmZlci5jb25jYXQoW3RoaXMuY2FjaGUsIGJ1Zl0pXG4gIHZhciBjaHVua1xuICB3aGlsZSAodGhpcy5jYWNoZS5sZW5ndGggPj0gMTYpIHtcbiAgICBjaHVuayA9IHRoaXMuY2FjaGUuc2xpY2UoMCwgMTYpXG4gICAgdGhpcy5jYWNoZSA9IHRoaXMuY2FjaGUuc2xpY2UoMTYpXG4gICAgdGhpcy5naGFzaChjaHVuaylcbiAgfVxufVxuR0hBU0gucHJvdG90eXBlLmZpbmFsID0gZnVuY3Rpb24gKGFibCwgYmwpIHtcbiAgaWYgKHRoaXMuY2FjaGUubGVuZ3RoKSB7XG4gICAgdGhpcy5naGFzaChCdWZmZXIuY29uY2F0KFt0aGlzLmNhY2hlLCB6ZXJvc10sIDE2KSlcbiAgfVxuICB0aGlzLmdoYXNoKGZyb21BcnJheShbXG4gICAgMCwgYWJsLFxuICAgIDAsIGJsXG4gIF0pKVxuICByZXR1cm4gdGhpcy5zdGF0ZVxufVxuXG5mdW5jdGlvbiB0b0FycmF5IChidWYpIHtcbiAgcmV0dXJuIFtcbiAgICBidWYucmVhZFVJbnQzMkJFKDApLFxuICAgIGJ1Zi5yZWFkVUludDMyQkUoNCksXG4gICAgYnVmLnJlYWRVSW50MzJCRSg4KSxcbiAgICBidWYucmVhZFVJbnQzMkJFKDEyKVxuICBdXG59XG5mdW5jdGlvbiBmcm9tQXJyYXkgKG91dCkge1xuICBvdXQgPSBvdXQubWFwKGZpeHVwX3VpbnQzMilcbiAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIoMTYpXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKG91dFswXSwgMClcbiAgYnVmLndyaXRlVUludDMyQkUob3V0WzFdLCA0KVxuICBidWYud3JpdGVVSW50MzJCRShvdXRbMl0sIDgpXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKG91dFszXSwgMTIpXG4gIHJldHVybiBidWZcbn1cbnZhciB1aW50X21heCA9IE1hdGgucG93KDIsIDMyKVxuZnVuY3Rpb24gZml4dXBfdWludDMyICh4KSB7XG4gIHZhciByZXQsIHhfcG9zXG4gIHJldCA9IHggPiB1aW50X21heCB8fCB4IDwgMCA/ICh4X3BvcyA9IE1hdGguYWJzKHgpICUgdWludF9tYXgsIHggPCAwID8gdWludF9tYXggLSB4X3BvcyA6IHhfcG9zKSA6IHhcbiAgcmV0dXJuIHJldFxufVxuZnVuY3Rpb24geG9yIChhLCBiKSB7XG4gIHJldHVybiBbXG4gICAgYVswXSBeIGJbMF0sXG4gICAgYVsxXSBeIGJbMV0sXG4gICAgYVsyXSBeIGJbMl0sXG4gICAgYVszXSBeIGJbM11cbiAgXVxufVxuIiwidmFyIHhvciA9IHJlcXVpcmUoJ2J1ZmZlci14b3InKVxuXG5leHBvcnRzLmVuY3J5cHQgPSBmdW5jdGlvbiAoc2VsZiwgZGF0YSwgZGVjcnlwdCkge1xuICB2YXIgb3V0ID0gbmV3IEJ1ZmZlcignJylcbiAgdmFyIGxlblxuXG4gIHdoaWxlIChkYXRhLmxlbmd0aCkge1xuICAgIGlmIChzZWxmLl9jYWNoZS5sZW5ndGggPT09IDApIHtcbiAgICAgIHNlbGYuX2NhY2hlID0gc2VsZi5fY2lwaGVyLmVuY3J5cHRCbG9jayhzZWxmLl9wcmV2KVxuICAgICAgc2VsZi5fcHJldiA9IG5ldyBCdWZmZXIoJycpXG4gICAgfVxuXG4gICAgaWYgKHNlbGYuX2NhY2hlLmxlbmd0aCA8PSBkYXRhLmxlbmd0aCkge1xuICAgICAgbGVuID0gc2VsZi5fY2FjaGUubGVuZ3RoXG4gICAgICBvdXQgPSBCdWZmZXIuY29uY2F0KFtvdXQsIGVuY3J5cHRTdGFydChzZWxmLCBkYXRhLnNsaWNlKDAsIGxlbiksIGRlY3J5cHQpXSlcbiAgICAgIGRhdGEgPSBkYXRhLnNsaWNlKGxlbilcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ID0gQnVmZmVyLmNvbmNhdChbb3V0LCBlbmNyeXB0U3RhcnQoc2VsZiwgZGF0YSwgZGVjcnlwdCldKVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb3V0XG59XG5mdW5jdGlvbiBlbmNyeXB0U3RhcnQgKHNlbGYsIGRhdGEsIGRlY3J5cHQpIHtcbiAgdmFyIGxlbiA9IGRhdGEubGVuZ3RoXG4gIHZhciBvdXQgPSB4b3IoZGF0YSwgc2VsZi5fY2FjaGUpXG4gIHNlbGYuX2NhY2hlID0gc2VsZi5fY2FjaGUuc2xpY2UobGVuKVxuICBzZWxmLl9wcmV2ID0gQnVmZmVyLmNvbmNhdChbc2VsZi5fcHJldiwgZGVjcnlwdCA/IGRhdGEgOiBvdXRdKVxuICByZXR1cm4gb3V0XG59XG4iLCJmdW5jdGlvbiBlbmNyeXB0Qnl0ZSAoc2VsZiwgYnl0ZVBhcmFtLCBkZWNyeXB0KSB7XG4gIHZhciBwYWRcbiAgdmFyIGkgPSAtMVxuICB2YXIgbGVuID0gOFxuICB2YXIgb3V0ID0gMFxuICB2YXIgYml0LCB2YWx1ZVxuICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgcGFkID0gc2VsZi5fY2lwaGVyLmVuY3J5cHRCbG9jayhzZWxmLl9wcmV2KVxuICAgIGJpdCA9IChieXRlUGFyYW0gJiAoMSA8PCAoNyAtIGkpKSkgPyAweDgwIDogMFxuICAgIHZhbHVlID0gcGFkWzBdIF4gYml0XG4gICAgb3V0ICs9ICgodmFsdWUgJiAweDgwKSA+PiAoaSAlIDgpKVxuICAgIHNlbGYuX3ByZXYgPSBzaGlmdEluKHNlbGYuX3ByZXYsIGRlY3J5cHQgPyBiaXQgOiB2YWx1ZSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5leHBvcnRzLmVuY3J5cHQgPSBmdW5jdGlvbiAoc2VsZiwgY2h1bmssIGRlY3J5cHQpIHtcbiAgdmFyIGxlbiA9IGNodW5rLmxlbmd0aFxuICB2YXIgb3V0ID0gbmV3IEJ1ZmZlcihsZW4pXG4gIHZhciBpID0gLTFcbiAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgIG91dFtpXSA9IGVuY3J5cHRCeXRlKHNlbGYsIGNodW5rW2ldLCBkZWNyeXB0KVxuICB9XG4gIHJldHVybiBvdXRcbn1cbmZ1bmN0aW9uIHNoaWZ0SW4gKGJ1ZmZlciwgdmFsdWUpIHtcbiAgdmFyIGxlbiA9IGJ1ZmZlci5sZW5ndGhcbiAgdmFyIGkgPSAtMVxuICB2YXIgb3V0ID0gbmV3IEJ1ZmZlcihidWZmZXIubGVuZ3RoKVxuICBidWZmZXIgPSBCdWZmZXIuY29uY2F0KFtidWZmZXIsIG5ldyBCdWZmZXIoW3ZhbHVlXSldKVxuICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgb3V0W2ldID0gYnVmZmVyW2ldIDw8IDEgfCBidWZmZXJbaSArIDFdID4+ICg3KVxuICB9XG4gIHJldHVybiBvdXRcbn1cbiIsImZ1bmN0aW9uIGVuY3J5cHRCeXRlIChzZWxmLCBieXRlUGFyYW0sIGRlY3J5cHQpIHtcbiAgdmFyIHBhZCA9IHNlbGYuX2NpcGhlci5lbmNyeXB0QmxvY2soc2VsZi5fcHJldilcbiAgdmFyIG91dCA9IHBhZFswXSBeIGJ5dGVQYXJhbVxuICBzZWxmLl9wcmV2ID0gQnVmZmVyLmNvbmNhdChbc2VsZi5fcHJldi5zbGljZSgxKSwgbmV3IEJ1ZmZlcihbZGVjcnlwdCA/IGJ5dGVQYXJhbSA6IG91dF0pXSlcbiAgcmV0dXJuIG91dFxufVxuZXhwb3J0cy5lbmNyeXB0ID0gZnVuY3Rpb24gKHNlbGYsIGNodW5rLCBkZWNyeXB0KSB7XG4gIHZhciBsZW4gPSBjaHVuay5sZW5ndGhcbiAgdmFyIG91dCA9IG5ldyBCdWZmZXIobGVuKVxuICB2YXIgaSA9IC0xXG4gIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICBvdXRbaV0gPSBlbmNyeXB0Qnl0ZShzZWxmLCBjaHVua1tpXSwgZGVjcnlwdClcbiAgfVxuICByZXR1cm4gb3V0XG59XG4iLCJ2YXIgeG9yID0gcmVxdWlyZSgnYnVmZmVyLXhvcicpXG5cbmZ1bmN0aW9uIGluY3IzMiAoaXYpIHtcbiAgdmFyIGxlbiA9IGl2Lmxlbmd0aFxuICB2YXIgaXRlbVxuICB3aGlsZSAobGVuLS0pIHtcbiAgICBpdGVtID0gaXYucmVhZFVJbnQ4KGxlbilcbiAgICBpZiAoaXRlbSA9PT0gMjU1KSB7XG4gICAgICBpdi53cml0ZVVJbnQ4KDAsIGxlbilcbiAgICB9IGVsc2Uge1xuICAgICAgaXRlbSsrXG4gICAgICBpdi53cml0ZVVJbnQ4KGl0ZW0sIGxlbilcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldEJsb2NrIChzZWxmKSB7XG4gIHZhciBvdXQgPSBzZWxmLl9jaXBoZXIuZW5jcnlwdEJsb2NrKHNlbGYuX3ByZXYpXG4gIGluY3IzMihzZWxmLl9wcmV2KVxuICByZXR1cm4gb3V0XG59XG5cbmV4cG9ydHMuZW5jcnlwdCA9IGZ1bmN0aW9uIChzZWxmLCBjaHVuaykge1xuICB3aGlsZSAoc2VsZi5fY2FjaGUubGVuZ3RoIDwgY2h1bmsubGVuZ3RoKSB7XG4gICAgc2VsZi5fY2FjaGUgPSBCdWZmZXIuY29uY2F0KFtzZWxmLl9jYWNoZSwgZ2V0QmxvY2soc2VsZildKVxuICB9XG4gIHZhciBwYWQgPSBzZWxmLl9jYWNoZS5zbGljZSgwLCBjaHVuay5sZW5ndGgpXG4gIHNlbGYuX2NhY2hlID0gc2VsZi5fY2FjaGUuc2xpY2UoY2h1bmsubGVuZ3RoKVxuICByZXR1cm4geG9yKGNodW5rLCBwYWQpXG59XG4iLCJ2YXIgeG9yID0gcmVxdWlyZSgnYnVmZmVyLXhvcicpXG5cbmZ1bmN0aW9uIGdldEJsb2NrIChzZWxmKSB7XG4gIHNlbGYuX3ByZXYgPSBzZWxmLl9jaXBoZXIuZW5jcnlwdEJsb2NrKHNlbGYuX3ByZXYpXG4gIHJldHVybiBzZWxmLl9wcmV2XG59XG5cbmV4cG9ydHMuZW5jcnlwdCA9IGZ1bmN0aW9uIChzZWxmLCBjaHVuaykge1xuICB3aGlsZSAoc2VsZi5fY2FjaGUubGVuZ3RoIDwgY2h1bmsubGVuZ3RoKSB7XG4gICAgc2VsZi5fY2FjaGUgPSBCdWZmZXIuY29uY2F0KFtzZWxmLl9jYWNoZSwgZ2V0QmxvY2soc2VsZildKVxuICB9XG5cbiAgdmFyIHBhZCA9IHNlbGYuX2NhY2hlLnNsaWNlKDAsIGNodW5rLmxlbmd0aClcbiAgc2VsZi5fY2FjaGUgPSBzZWxmLl9jYWNoZS5zbGljZShjaHVuay5sZW5ndGgpXG4gIHJldHVybiB4b3IoY2h1bmssIHBhZClcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24geG9yIChhLCBiKSB7XG4gIHZhciBsZW5ndGggPSBNYXRoLm1pbihhLmxlbmd0aCwgYi5sZW5ndGgpXG4gIHZhciBidWZmZXIgPSBuZXcgQnVmZmVyKGxlbmd0aClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgYnVmZmVyW2ldID0gYVtpXSBeIGJbaV1cbiAgfVxuXG4gIHJldHVybiBidWZmZXJcbn1cbiIsInZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCdzdHJlYW0nKS5UcmFuc2Zvcm1cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXInKS5TdHJpbmdEZWNvZGVyXG5tb2R1bGUuZXhwb3J0cyA9IENpcGhlckJhc2VcbmluaGVyaXRzKENpcGhlckJhc2UsIFRyYW5zZm9ybSlcbmZ1bmN0aW9uIENpcGhlckJhc2UgKGhhc2hNb2RlKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMpXG4gIHRoaXMuaGFzaE1vZGUgPSB0eXBlb2YgaGFzaE1vZGUgPT09ICdzdHJpbmcnXG4gIGlmICh0aGlzLmhhc2hNb2RlKSB7XG4gICAgdGhpc1toYXNoTW9kZV0gPSB0aGlzLl9maW5hbE9yRGlnZXN0XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5maW5hbCA9IHRoaXMuX2ZpbmFsT3JEaWdlc3RcbiAgfVxuICB0aGlzLl9kZWNvZGVyID0gbnVsbFxuICB0aGlzLl9lbmNvZGluZyA9IG51bGxcbn1cbkNpcGhlckJhc2UucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhLCBpbnB1dEVuYywgb3V0cHV0RW5jKSB7XG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICBkYXRhID0gbmV3IEJ1ZmZlcihkYXRhLCBpbnB1dEVuYylcbiAgfVxuICB2YXIgb3V0RGF0YSA9IHRoaXMuX3VwZGF0ZShkYXRhKVxuICBpZiAodGhpcy5oYXNoTW9kZSkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cbiAgaWYgKG91dHB1dEVuYykge1xuICAgIG91dERhdGEgPSB0aGlzLl90b1N0cmluZyhvdXREYXRhLCBvdXRwdXRFbmMpXG4gIH1cbiAgcmV0dXJuIG91dERhdGFcbn1cblxuQ2lwaGVyQmFzZS5wcm90b3R5cGUuc2V0QXV0b1BhZGRpbmcgPSBmdW5jdGlvbiAoKSB7fVxuXG5DaXBoZXJCYXNlLnByb3RvdHlwZS5nZXRBdXRoVGFnID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ3RyeWluZyB0byBnZXQgYXV0aCB0YWcgaW4gdW5zdXBwb3J0ZWQgc3RhdGUnKVxufVxuXG5DaXBoZXJCYXNlLnByb3RvdHlwZS5zZXRBdXRoVGFnID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ3RyeWluZyB0byBzZXQgYXV0aCB0YWcgaW4gdW5zdXBwb3J0ZWQgc3RhdGUnKVxufVxuXG5DaXBoZXJCYXNlLnByb3RvdHlwZS5zZXRBQUQgPSBmdW5jdGlvbiAoKSB7XG4gIHRocm93IG5ldyBFcnJvcigndHJ5aW5nIHRvIHNldCBhYWQgaW4gdW5zdXBwb3J0ZWQgc3RhdGUnKVxufVxuXG5DaXBoZXJCYXNlLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGRhdGEsIF8sIG5leHQpIHtcbiAgdmFyIGVyclxuICB0cnkge1xuICAgIGlmICh0aGlzLmhhc2hNb2RlKSB7XG4gICAgICB0aGlzLl91cGRhdGUoZGF0YSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wdXNoKHRoaXMuX3VwZGF0ZShkYXRhKSlcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBlcnIgPSBlXG4gIH0gZmluYWxseSB7XG4gICAgbmV4dChlcnIpXG4gIH1cbn1cbkNpcGhlckJhc2UucHJvdG90eXBlLl9mbHVzaCA9IGZ1bmN0aW9uIChkb25lKSB7XG4gIHZhciBlcnJcbiAgdHJ5IHtcbiAgICB0aGlzLnB1c2godGhpcy5fZmluYWwoKSlcbiAgfSBjYXRjaCAoZSkge1xuICAgIGVyciA9IGVcbiAgfSBmaW5hbGx5IHtcbiAgICBkb25lKGVycilcbiAgfVxufVxuQ2lwaGVyQmFzZS5wcm90b3R5cGUuX2ZpbmFsT3JEaWdlc3QgPSBmdW5jdGlvbiAob3V0cHV0RW5jKSB7XG4gIHZhciBvdXREYXRhID0gdGhpcy5fZmluYWwoKSB8fCBuZXcgQnVmZmVyKCcnKVxuICBpZiAob3V0cHV0RW5jKSB7XG4gICAgb3V0RGF0YSA9IHRoaXMuX3RvU3RyaW5nKG91dERhdGEsIG91dHB1dEVuYywgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb3V0RGF0YVxufVxuXG5DaXBoZXJCYXNlLnByb3RvdHlwZS5fdG9TdHJpbmcgPSBmdW5jdGlvbiAodmFsdWUsIGVuYywgZmluYWwpIHtcbiAgaWYgKCF0aGlzLl9kZWNvZGVyKSB7XG4gICAgdGhpcy5fZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKGVuYylcbiAgICB0aGlzLl9lbmNvZGluZyA9IGVuY1xuICB9XG4gIGlmICh0aGlzLl9lbmNvZGluZyAhPT0gZW5jKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjYW5cXCd0IHN3aXRjaCBlbmNvZGluZ3MnKVxuICB9XG4gIHZhciBvdXQgPSB0aGlzLl9kZWNvZGVyLndyaXRlKHZhbHVlKVxuICBpZiAoZmluYWwpIHtcbiAgICBvdXQgKz0gdGhpcy5fZGVjb2Rlci5lbmQoKVxuICB9XG4gIHJldHVybiBvdXRcbn1cbiIsInZhciBhZXMgPSByZXF1aXJlKCcuL2FlcycpXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnY2lwaGVyLWJhc2UnKVxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuXG5pbmhlcml0cyhTdHJlYW1DaXBoZXIsIFRyYW5zZm9ybSlcbm1vZHVsZS5leHBvcnRzID0gU3RyZWFtQ2lwaGVyXG5mdW5jdGlvbiBTdHJlYW1DaXBoZXIgKG1vZGUsIGtleSwgaXYsIGRlY3J5cHQpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFN0cmVhbUNpcGhlcikpIHtcbiAgICByZXR1cm4gbmV3IFN0cmVhbUNpcGhlcihtb2RlLCBrZXksIGl2KVxuICB9XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMpXG4gIHRoaXMuX2NpcGhlciA9IG5ldyBhZXMuQUVTKGtleSlcbiAgdGhpcy5fcHJldiA9IG5ldyBCdWZmZXIoaXYubGVuZ3RoKVxuICB0aGlzLl9jYWNoZSA9IG5ldyBCdWZmZXIoJycpXG4gIHRoaXMuX3NlY0NhY2hlID0gbmV3IEJ1ZmZlcignJylcbiAgdGhpcy5fZGVjcnlwdCA9IGRlY3J5cHRcbiAgaXYuY29weSh0aGlzLl9wcmV2KVxuICB0aGlzLl9tb2RlID0gbW9kZVxufVxuU3RyZWFtQ2lwaGVyLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHJldHVybiB0aGlzLl9tb2RlLmVuY3J5cHQodGhpcywgY2h1bmssIHRoaXMuX2RlY3J5cHQpXG59XG5TdHJlYW1DaXBoZXIucHJvdG90eXBlLl9maW5hbCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fY2lwaGVyLnNjcnViKClcbn1cbiIsInZhciBtZDUgPSByZXF1aXJlKCdjcmVhdGUtaGFzaC9tZDUnKVxubW9kdWxlLmV4cG9ydHMgPSBFVlBfQnl0ZXNUb0tleVxuZnVuY3Rpb24gRVZQX0J5dGVzVG9LZXkgKHBhc3N3b3JkLCBzYWx0LCBrZXlMZW4sIGl2TGVuKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHBhc3N3b3JkKSkge1xuICAgIHBhc3N3b3JkID0gbmV3IEJ1ZmZlcihwYXNzd29yZCwgJ2JpbmFyeScpXG4gIH1cbiAgaWYgKHNhbHQgJiYgIUJ1ZmZlci5pc0J1ZmZlcihzYWx0KSkge1xuICAgIHNhbHQgPSBuZXcgQnVmZmVyKHNhbHQsICdiaW5hcnknKVxuICB9XG4gIGtleUxlbiA9IGtleUxlbiAvIDhcbiAgaXZMZW4gPSBpdkxlbiB8fCAwXG4gIHZhciBraSA9IDBcbiAgdmFyIGlpID0gMFxuICB2YXIga2V5ID0gbmV3IEJ1ZmZlcihrZXlMZW4pXG4gIHZhciBpdiA9IG5ldyBCdWZmZXIoaXZMZW4pXG4gIHZhciBhZGRtZCA9IDBcbiAgdmFyIG1kX2J1ZlxuICB2YXIgaVxuICB2YXIgYnVmcyA9IFtdXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKGFkZG1kKysgPiAwKSB7XG4gICAgICBidWZzLnB1c2gobWRfYnVmKVxuICAgIH1cbiAgICBidWZzLnB1c2gocGFzc3dvcmQpXG4gICAgaWYgKHNhbHQpIHtcbiAgICAgIGJ1ZnMucHVzaChzYWx0KVxuICAgIH1cbiAgICBtZF9idWYgPSBtZDUoQnVmZmVyLmNvbmNhdChidWZzKSlcbiAgICBidWZzID0gW11cbiAgICBpID0gMFxuICAgIGlmIChrZXlMZW4gPiAwKSB7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBpZiAoa2V5TGVuID09PSAwKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA9PT0gbWRfYnVmLmxlbmd0aCkge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAga2V5W2tpKytdID0gbWRfYnVmW2ldXG4gICAgICAgIGtleUxlbi0tXG4gICAgICAgIGkrK1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXZMZW4gPiAwICYmIGkgIT09IG1kX2J1Zi5sZW5ndGgpIHtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGlmIChpdkxlbiA9PT0gMCkge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPT09IG1kX2J1Zi5sZW5ndGgpIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGl2W2lpKytdID0gbWRfYnVmW2ldXG4gICAgICAgIGl2TGVuLS1cbiAgICAgICAgaSsrXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChrZXlMZW4gPT09IDAgJiYgaXZMZW4gPT09IDApIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG4gIGZvciAoaSA9IDA7IGkgPCBtZF9idWYubGVuZ3RoOyBpKyspIHtcbiAgICBtZF9idWZbaV0gPSAwXG4gIH1cbiAgcmV0dXJuIHtcbiAgICBrZXk6IGtleSxcbiAgICBpdjogaXZcbiAgfVxufVxuIiwidmFyIHBhcnNlS2V5cyA9IHJlcXVpcmUoJ3BhcnNlLWFzbjEnKTtcbnZhciBtZ2YgPSByZXF1aXJlKCcuL21nZicpO1xudmFyIHhvciA9IHJlcXVpcmUoJy4veG9yJyk7XG52YXIgYm4gPSByZXF1aXJlKCdibi5qcycpO1xudmFyIGNydCA9IHJlcXVpcmUoJ2Jyb3dzZXJpZnktcnNhJyk7XG52YXIgY3JlYXRlSGFzaCA9IHJlcXVpcmUoJ2NyZWF0ZS1oYXNoJyk7XG52YXIgd2l0aFB1YmxpYyA9IHJlcXVpcmUoJy4vd2l0aFB1YmxpYycpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwcml2YXRlRGVjcnlwdChwcml2YXRlX2tleSwgZW5jLCByZXZlcnNlKSB7XG4gIHZhciBwYWRkaW5nO1xuICBpZiAocHJpdmF0ZV9rZXkucGFkZGluZykge1xuICAgIHBhZGRpbmcgPSBwcml2YXRlX2tleS5wYWRkaW5nO1xuICB9IGVsc2UgaWYgKHJldmVyc2UpIHtcbiAgICBwYWRkaW5nID0gMTtcbiAgfSBlbHNlIHtcbiAgICBwYWRkaW5nID0gNDtcbiAgfVxuICBcbiAgdmFyIGtleSA9IHBhcnNlS2V5cyhwcml2YXRlX2tleSk7XG4gIHZhciBrID0ga2V5Lm1vZHVsdXMuYnl0ZUxlbmd0aCgpO1xuICBpZiAoZW5jLmxlbmd0aCA+IGsgfHwgbmV3IGJuKGVuYykuY21wKGtleS5tb2R1bHVzKSA+PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdkZWNyeXB0aW9uIGVycm9yJyk7XG4gIH1cbiAgdmFyIG1zZztcbiAgaWYgKHJldmVyc2UpIHtcbiAgICBtc2cgPSB3aXRoUHVibGljKG5ldyBibihlbmMpLCBrZXkpO1xuICB9IGVsc2Uge1xuICAgIG1zZyA9IGNydChlbmMsIGtleSk7XG4gIH1cbiAgdmFyIHpCdWZmZXIgPSBuZXcgQnVmZmVyKGsgLSBtc2cubGVuZ3RoKTtcbiAgekJ1ZmZlci5maWxsKDApO1xuICBtc2cgPSBCdWZmZXIuY29uY2F0KFt6QnVmZmVyLCBtc2ddLCBrKTtcbiAgaWYgKHBhZGRpbmcgPT09IDQpIHtcbiAgICByZXR1cm4gb2FlcChrZXksIG1zZyk7XG4gIH0gZWxzZSBpZiAocGFkZGluZyA9PT0gMSkge1xuICAgIHJldHVybiBwa2NzMShrZXksIG1zZywgcmV2ZXJzZSk7XG4gIH0gZWxzZSBpZiAocGFkZGluZyA9PT0gMykge1xuICAgIHJldHVybiBtc2c7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIHBhZGRpbmcnKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gb2FlcChrZXksIG1zZyl7XG4gIHZhciBuID0ga2V5Lm1vZHVsdXM7XG4gIHZhciBrID0ga2V5Lm1vZHVsdXMuYnl0ZUxlbmd0aCgpO1xuICB2YXIgbUxlbiA9IG1zZy5sZW5ndGg7XG4gIHZhciBpSGFzaCA9IGNyZWF0ZUhhc2goJ3NoYTEnKS51cGRhdGUobmV3IEJ1ZmZlcignJykpLmRpZ2VzdCgpO1xuICB2YXIgaExlbiA9IGlIYXNoLmxlbmd0aDtcbiAgdmFyIGhMZW4yID0gMiAqIGhMZW47XG4gIGlmIChtc2dbMF0gIT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2RlY3J5cHRpb24gZXJyb3InKTtcbiAgfVxuICB2YXIgbWFza2VkU2VlZCA9IG1zZy5zbGljZSgxLCBoTGVuICsgMSk7XG4gIHZhciBtYXNrZWREYiA9ICBtc2cuc2xpY2UoaExlbiArIDEpO1xuICB2YXIgc2VlZCA9IHhvcihtYXNrZWRTZWVkLCBtZ2YobWFza2VkRGIsIGhMZW4pKTtcbiAgdmFyIGRiID0geG9yKG1hc2tlZERiLCBtZ2Yoc2VlZCwgayAtIGhMZW4gLSAxKSk7XG4gIGlmIChjb21wYXJlKGlIYXNoLCBkYi5zbGljZSgwLCBoTGVuKSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2RlY3J5cHRpb24gZXJyb3InKTtcbiAgfVxuICB2YXIgaSA9IGhMZW47XG4gIHdoaWxlIChkYltpXSA9PT0gMCkge1xuICAgIGkrKztcbiAgfVxuICBpZiAoZGJbaSsrXSAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignZGVjcnlwdGlvbiBlcnJvcicpO1xuICB9XG4gIHJldHVybiBkYi5zbGljZShpKTtcbn1cblxuZnVuY3Rpb24gcGtjczEoa2V5LCBtc2csIHJldmVyc2Upe1xuICB2YXIgcDEgPSBtc2cuc2xpY2UoMCwgMik7XG4gIHZhciBpID0gMjtcbiAgdmFyIHN0YXR1cyA9IDA7XG4gIHdoaWxlIChtc2dbaSsrXSAhPT0gMCkge1xuICAgIGlmIChpID49IG1zZy5sZW5ndGgpIHtcbiAgICAgIHN0YXR1cysrO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHZhciBwcyA9IG1zZy5zbGljZSgyLCBpIC0gMSk7XG4gIHZhciBwMiA9IG1zZy5zbGljZShpIC0gMSwgaSk7XG5cbiAgaWYgKChwMS50b1N0cmluZygnaGV4JykgIT09ICcwMDAyJyAmJiAhcmV2ZXJzZSkgfHwgKHAxLnRvU3RyaW5nKCdoZXgnKSAhPT0gJzAwMDEnICYmIHJldmVyc2UpKXtcbiAgICBzdGF0dXMrKztcbiAgfVxuICBpZiAocHMubGVuZ3RoIDwgOCkge1xuICAgIHN0YXR1cysrO1xuICB9XG4gIGlmIChzdGF0dXMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2RlY3J5cHRpb24gZXJyb3InKTtcbiAgfVxuICByZXR1cm4gIG1zZy5zbGljZShpKTtcbn1cbmZ1bmN0aW9uIGNvbXBhcmUoYSwgYil7XG4gIGEgPSBuZXcgQnVmZmVyKGEpO1xuICBiID0gbmV3IEJ1ZmZlcihiKTtcbiAgdmFyIGRpZiA9IDA7XG4gIHZhciBsZW4gPSBhLmxlbmd0aDtcbiAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgIGRpZisrO1xuICAgIGxlbiA9IE1hdGgubWluKGEubGVuZ3RoLCBiLmxlbmd0aCk7XG4gIH1cbiAgdmFyIGkgPSAtMTtcbiAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgIGRpZiArPSAoYVtpXSBeIGJbaV0pO1xuICB9XG4gIHJldHVybiBkaWY7XG59IiwidmFyIHBhcnNlS2V5cyA9IHJlcXVpcmUoJ3BhcnNlLWFzbjEnKTtcbnZhciByYW5kb21CeXRlcyA9IHJlcXVpcmUoJ3JhbmRvbWJ5dGVzJyk7XG52YXIgY3JlYXRlSGFzaCA9IHJlcXVpcmUoJ2NyZWF0ZS1oYXNoJyk7XG52YXIgbWdmID0gcmVxdWlyZSgnLi9tZ2YnKTtcbnZhciB4b3IgPSByZXF1aXJlKCcuL3hvcicpO1xudmFyIGJuID0gcmVxdWlyZSgnYm4uanMnKTtcbnZhciB3aXRoUHVibGljID0gcmVxdWlyZSgnLi93aXRoUHVibGljJyk7XG52YXIgY3J0ID0gcmVxdWlyZSgnYnJvd3NlcmlmeS1yc2EnKTtcblxudmFyIGNvbnN0YW50cyA9IHtcbiAgUlNBX1BLQ1MxX09BRVBfUEFERElORzogNCxcbiAgUlNBX1BLQ1MxX1BBRERJTjogMSxcbiAgUlNBX05PX1BBRERJTkc6IDNcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcHVibGljRW5jcnlwdChwdWJsaWNfa2V5LCBtc2csIHJldmVyc2UpIHtcbiAgdmFyIHBhZGRpbmc7XG4gIGlmIChwdWJsaWNfa2V5LnBhZGRpbmcpIHtcbiAgICBwYWRkaW5nID0gcHVibGljX2tleS5wYWRkaW5nO1xuICB9IGVsc2UgaWYgKHJldmVyc2UpIHtcbiAgICBwYWRkaW5nID0gMTtcbiAgfSBlbHNlIHtcbiAgICBwYWRkaW5nID0gNDtcbiAgfVxuICB2YXIga2V5ID0gcGFyc2VLZXlzKHB1YmxpY19rZXkpO1xuICB2YXIgcGFkZGVkTXNnO1xuICBpZiAocGFkZGluZyA9PT0gNCkge1xuICAgIHBhZGRlZE1zZyA9IG9hZXAoa2V5LCBtc2cpO1xuICB9IGVsc2UgaWYgKHBhZGRpbmcgPT09IDEpIHtcbiAgICBwYWRkZWRNc2cgPSBwa2NzMShrZXksIG1zZywgcmV2ZXJzZSk7XG4gIH0gZWxzZSBpZiAocGFkZGluZyA9PT0gMykge1xuICAgIHBhZGRlZE1zZyA9IG5ldyBibihtc2cpO1xuICAgIGlmIChwYWRkZWRNc2cuY21wKGtleS5tb2R1bHVzKSA+PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RhdGEgdG9vIGxvbmcgZm9yIG1vZHVsdXMnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIHBhZGRpbmcnKTtcbiAgfVxuICBpZiAocmV2ZXJzZSkge1xuICAgIHJldHVybiBjcnQocGFkZGVkTXNnLCBrZXkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB3aXRoUHVibGljKHBhZGRlZE1zZywga2V5KTtcbiAgfVxufTtcblxuZnVuY3Rpb24gb2FlcChrZXksIG1zZyl7XG4gIHZhciBrID0ga2V5Lm1vZHVsdXMuYnl0ZUxlbmd0aCgpO1xuICB2YXIgbUxlbiA9IG1zZy5sZW5ndGg7XG4gIHZhciBpSGFzaCA9IGNyZWF0ZUhhc2goJ3NoYTEnKS51cGRhdGUobmV3IEJ1ZmZlcignJykpLmRpZ2VzdCgpO1xuICB2YXIgaExlbiA9IGlIYXNoLmxlbmd0aDtcbiAgdmFyIGhMZW4yID0gMiAqIGhMZW47XG4gIGlmIChtTGVuID4gayAtIGhMZW4yIC0gMikge1xuICAgIHRocm93IG5ldyBFcnJvcignbWVzc2FnZSB0b28gbG9uZycpO1xuICB9XG4gIHZhciBwcyA9IG5ldyBCdWZmZXIoayAtIG1MZW4gLSBoTGVuMiAtIDIpO1xuICBwcy5maWxsKDApO1xuICB2YXIgZGJsZW4gPSBrIC0gaExlbiAtIDE7XG4gIHZhciBzZWVkID0gcmFuZG9tQnl0ZXMoaExlbik7XG4gIHZhciBtYXNrZWREYiA9IHhvcihCdWZmZXIuY29uY2F0KFtpSGFzaCwgcHMsIG5ldyBCdWZmZXIoWzFdKSwgbXNnXSwgZGJsZW4pLCBtZ2Yoc2VlZCwgZGJsZW4pKTtcbiAgdmFyIG1hc2tlZFNlZWQgPSB4b3Ioc2VlZCwgbWdmKG1hc2tlZERiLCBoTGVuKSk7XG4gIHJldHVybiBuZXcgYm4oQnVmZmVyLmNvbmNhdChbbmV3IEJ1ZmZlcihbMF0pLCBtYXNrZWRTZWVkLCBtYXNrZWREYl0sIGspKTtcbn1cbmZ1bmN0aW9uIHBrY3MxKGtleSwgbXNnLCByZXZlcnNlKXtcbiAgdmFyIG1MZW4gPSBtc2cubGVuZ3RoO1xuICB2YXIgayA9IGtleS5tb2R1bHVzLmJ5dGVMZW5ndGgoKTtcbiAgaWYgKG1MZW4gPiBrIC0gMTEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ21lc3NhZ2UgdG9vIGxvbmcnKTtcbiAgfVxuICB2YXIgcHM7XG4gIGlmIChyZXZlcnNlKSB7XG4gICAgcHMgPSBuZXcgQnVmZmVyKGsgLSBtTGVuIC0gMyk7XG4gICAgcHMuZmlsbCgweGZmKTtcbiAgfSBlbHNlIHtcbiAgICBwcyA9IG5vblplcm8oayAtIG1MZW4gLSAzKTtcbiAgfVxuICByZXR1cm4gbmV3IGJuKEJ1ZmZlci5jb25jYXQoW25ldyBCdWZmZXIoWzAsIHJldmVyc2U/MToyXSksIHBzLCBuZXcgQnVmZmVyKFswXSksIG1zZ10sIGspKTtcbn1cbmZ1bmN0aW9uIG5vblplcm8obGVuLCBjcnlwdG8pIHtcbiAgdmFyIG91dCA9IG5ldyBCdWZmZXIobGVuKTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgY2FjaGUgPSByYW5kb21CeXRlcyhsZW4qMik7XG4gIHZhciBjdXIgPSAwO1xuICB2YXIgbnVtO1xuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIGlmIChjdXIgPT09IGNhY2hlLmxlbmd0aCkge1xuICAgICAgY2FjaGUgPSByYW5kb21CeXRlcyhsZW4qMik7XG4gICAgICBjdXIgPSAwO1xuICAgIH1cbiAgICBudW0gPSBjYWNoZVtjdXIrK107XG4gICAgaWYgKG51bSkge1xuICAgICAgb3V0W2krK10gPSBudW07XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXQ7XG59IiwidmFyIGJuID0gcmVxdWlyZSgnYm4uanMnKTtcbmZ1bmN0aW9uIHdpdGhQdWJsaWMocGFkZGVkTXNnLCBrZXkpIHtcbiAgcmV0dXJuIG5ldyBCdWZmZXIocGFkZGVkTXNnXG4gICAgLnRvUmVkKGJuLm1vbnQoa2V5Lm1vZHVsdXMpKVxuICAgIC5yZWRQb3cobmV3IGJuKGtleS5wdWJsaWNFeHBvbmVudCkpXG4gICAgLmZyb21SZWQoKVxuICAgIC50b0FycmF5KCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdpdGhQdWJsaWM7IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB4b3IoYSwgYikge1xuICB2YXIgbGVuID0gYS5sZW5ndGg7XG4gIHZhciBpID0gLTE7XG4gIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICBhW2ldIF49IGJbaV07XG4gIH1cbiAgcmV0dXJuIGFcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY3J5cHRvID0gZ2xvYmFsLmNyeXB0byB8fCBnbG9iYWwubXNDcnlwdG9cbmlmKGNyeXB0byAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmFuZG9tQnl0ZXM7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IG9sZEJyb3dzZXI7XG59XG5mdW5jdGlvbiByYW5kb21CeXRlcyhzaXplLCBjYikge1xuICB2YXIgYnl0ZXMgPSBuZXcgQnVmZmVyKHNpemUpOyAvL2luIGJyb3dzZXJpZnksIHRoaXMgaXMgYW4gZXh0ZW5kZWQgVWludDhBcnJheVxuICAgIC8qIFRoaXMgd2lsbCBub3Qgd29yayBpbiBvbGRlciBicm93c2Vycy5cbiAgICAgKiBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL3dpbmRvdy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzXG4gICAgICovXG5cbiAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhieXRlcyk7XG4gIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICBjYihudWxsLCBieXRlcyk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGJ5dGVzO1xufVxuZnVuY3Rpb24gb2xkQnJvd3NlcigpIHtcbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ3NlY3VyZSByYW5kb20gbnVtYmVyIGdlbmVyYXRpb24gbm90IHN1cHBvcnRlZCBieSB0aGlzIGJyb3dzZXJcXG4nK1xuICAgICAgJ3VzZSBjaHJvbWUsIEZpcmVGb3ggb3IgSW50ZXJuZXQgRXhwbG9yZXIgMTEnXG4gICAgKVxufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG5FdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbihuKSB7XG4gIGlmICghaXNOdW1iZXIobikgfHwgbiA8IDAgfHwgaXNOYU4obikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCduIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBlciwgaGFuZGxlciwgbGVuLCBhcmdzLCBpLCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgIGlmICghdGhpcy5fZXZlbnRzLmVycm9yIHx8XG4gICAgICAgIChpc09iamVjdCh0aGlzLl9ldmVudHMuZXJyb3IpICYmICF0aGlzLl9ldmVudHMuZXJyb3IubGVuZ3RoKSkge1xuICAgICAgZXIgPSBhcmd1bWVudHNbMV07XG4gICAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICAgIH1cbiAgICAgIHRocm93IFR5cGVFcnJvcignVW5jYXVnaHQsIHVuc3BlY2lmaWVkIFwiZXJyb3JcIiBldmVudC4nKTtcbiAgICB9XG4gIH1cblxuICBoYW5kbGVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc1VuZGVmaW5lZChoYW5kbGVyKSlcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIGZhc3QgY2FzZXNcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIHNsb3dlclxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IGxlbjsgaSsrKVxuICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChoYW5kbGVyKSkge1xuICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICBmb3IgKGkgPSAxOyBpIDwgbGVuOyBpKyspXG4gICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcblxuICAgIGxpc3RlbmVycyA9IGhhbmRsZXIuc2xpY2UoKTtcbiAgICBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBtO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gIGlmICh0aGlzLl9ldmVudHMubmV3TGlzdGVuZXIpXG4gICAgdGhpcy5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgIGlzRnVuY3Rpb24obGlzdGVuZXIubGlzdGVuZXIpID9cbiAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gIGVsc2UgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZVxuICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV0sIGxpc3RlbmVyXTtcblxuICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSAmJiAhdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCkge1xuICAgIHZhciBtO1xuICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5fbWF4TGlzdGVuZXJzKSkge1xuICAgICAgbSA9IHRoaXMuX21heExpc3RlbmVycztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICAgIH1cblxuICAgIGlmIChtICYmIG0gPiAwICYmIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGggPiBtKSB7XG4gICAgICB0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkID0gdHJ1ZTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJyhub2RlKSB3YXJuaW5nOiBwb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5ICcgK1xuICAgICAgICAgICAgICAgICAgICAnbGVhayBkZXRlY3RlZC4gJWQgbGlzdGVuZXJzIGFkZGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ1VzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0LicsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGgpO1xuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlLnRyYWNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIG5vdCBzdXBwb3J0ZWQgaW4gSUUgMTBcbiAgICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICB2YXIgZmlyZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBnKCkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgZyk7XG5cbiAgICBpZiAoIWZpcmVkKSB7XG4gICAgICBmaXJlZCA9IHRydWU7XG4gICAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxuXG4gIGcubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgdGhpcy5vbih0eXBlLCBnKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZmYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIGxpc3QsIHBvc2l0aW9uLCBsZW5ndGgsIGk7XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgbGlzdCA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gIHBvc2l0aW9uID0gLTE7XG5cbiAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8XG4gICAgICAoaXNGdW5jdGlvbihsaXN0Lmxpc3RlbmVyKSAmJiBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuXG4gIH0gZWxzZSBpZiAoaXNPYmplY3QobGlzdCkpIHtcbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSA+IDA7KSB7XG4gICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHxcbiAgICAgICAgICAobGlzdFtpXS5saXN0ZW5lciAmJiBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICAgIGxpc3QubGVuZ3RoID0gMDtcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpc3Quc3BsaWNlKHBvc2l0aW9uLCAxKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBrZXksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gIGlmICghdGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICBlbHNlIGlmICh0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgZm9yIChrZXkgaW4gdGhpcy5fZXZlbnRzKSB7XG4gICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGxpc3RlbmVycykpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gTElGTyBvcmRlclxuICAgIHdoaWxlIChsaXN0ZW5lcnMubGVuZ3RoKVxuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbbGlzdGVuZXJzLmxlbmd0aCAtIDFdKTtcbiAgfVxuICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciByZXQ7XG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0ID0gW107XG4gIGVsc2UgaWYgKGlzRnVuY3Rpb24odGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICByZXQgPSBbdGhpcy5fZXZlbnRzW3R5cGVdXTtcbiAgZWxzZVxuICAgIHJldCA9IHRoaXMuX2V2ZW50c1t0eXBlXS5zbGljZSgpO1xuICByZXR1cm4gcmV0O1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIHZhciByZXQ7XG4gIGlmICghZW1pdHRlci5fZXZlbnRzIHx8ICFlbWl0dGVyLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0ID0gMDtcbiAgZWxzZSBpZiAoaXNGdW5jdGlvbihlbWl0dGVyLl9ldmVudHNbdHlwZV0pKVxuICAgIHJldCA9IDE7XG4gIGVsc2VcbiAgICByZXQgPSBlbWl0dGVyLl9ldmVudHNbdHlwZV0ubGVuZ3RoO1xuICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG4iLCIvKipcbiAqIERldGVybWluZSBpZiBhbiBvYmplY3QgaXMgQnVmZmVyXG4gKlxuICogQXV0aG9yOiAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBMaWNlbnNlOiAgTUlUXG4gKlxuICogYG5wbSBpbnN0YWxsIGlzLWJ1ZmZlcmBcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuICEhKG9iaiAhPSBudWxsICYmXG4gICAgKG9iai5faXNCdWZmZXIgfHwgLy8gRm9yIFNhZmFyaSA1LTcgKG1pc3NpbmcgT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3RvcilcbiAgICAgIChvYmouY29uc3RydWN0b3IgJiZcbiAgICAgIHR5cGVvZiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlcihvYmopKVxuICAgICkpXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcblxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gc2V0VGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgc2V0VGltZW91dChkcmFpblF1ZXVlLCAwKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vbGliL19zdHJlYW1fZHVwbGV4LmpzXCIpXG4iLCIvLyBhIGR1cGxleCBzdHJlYW0gaXMganVzdCBhIHN0cmVhbSB0aGF0IGlzIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLlxuLy8gU2luY2UgSlMgZG9lc24ndCBoYXZlIG11bHRpcGxlIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UsIHRoaXMgY2xhc3Ncbi8vIHByb3RvdHlwYWxseSBpbmhlcml0cyBmcm9tIFJlYWRhYmxlLCBhbmQgdGhlbiBwYXJhc2l0aWNhbGx5IGZyb21cbi8vIFdyaXRhYmxlLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikga2V5cy5wdXNoKGtleSk7XG4gIHJldHVybiBrZXlzO1xufVxuLyo8L3JlcGxhY2VtZW50PiovXG5cblxubW9kdWxlLmV4cG9ydHMgPSBEdXBsZXg7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgcHJvY2Vzc05leHRUaWNrID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgUmVhZGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fcmVhZGFibGUnKTtcbnZhciBXcml0YWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV93cml0YWJsZScpO1xuXG51dGlsLmluaGVyaXRzKER1cGxleCwgUmVhZGFibGUpO1xuXG52YXIga2V5cyA9IG9iamVjdEtleXMoV3JpdGFibGUucHJvdG90eXBlKTtcbmZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykge1xuICB2YXIgbWV0aG9kID0ga2V5c1t2XTtcbiAgaWYgKCFEdXBsZXgucHJvdG90eXBlW21ldGhvZF0pXG4gICAgRHVwbGV4LnByb3RvdHlwZVttZXRob2RdID0gV3JpdGFibGUucHJvdG90eXBlW21ldGhvZF07XG59XG5cbmZ1bmN0aW9uIER1cGxleChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKVxuICAgIHJldHVybiBuZXcgRHVwbGV4KG9wdGlvbnMpO1xuXG4gIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIFdyaXRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZWFkYWJsZSA9PT0gZmFsc2UpXG4gICAgdGhpcy5yZWFkYWJsZSA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMud3JpdGFibGUgPT09IGZhbHNlKVxuICAgIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcblxuICB0aGlzLmFsbG93SGFsZk9wZW4gPSB0cnVlO1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmFsbG93SGFsZk9wZW4gPT09IGZhbHNlKVxuICAgIHRoaXMuYWxsb3dIYWxmT3BlbiA9IGZhbHNlO1xuXG4gIHRoaXMub25jZSgnZW5kJywgb25lbmQpO1xufVxuXG4vLyB0aGUgbm8taGFsZi1vcGVuIGVuZm9yY2VyXG5mdW5jdGlvbiBvbmVuZCgpIHtcbiAgLy8gaWYgd2UgYWxsb3cgaGFsZi1vcGVuIHN0YXRlLCBvciBpZiB0aGUgd3JpdGFibGUgc2lkZSBlbmRlZCxcbiAgLy8gdGhlbiB3ZSdyZSBvay5cbiAgaWYgKHRoaXMuYWxsb3dIYWxmT3BlbiB8fCB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkKVxuICAgIHJldHVybjtcblxuICAvLyBubyBtb3JlIGRhdGEgY2FuIGJlIHdyaXR0ZW4uXG4gIC8vIEJ1dCBhbGxvdyBtb3JlIHdyaXRlcyB0byBoYXBwZW4gaW4gdGhpcyB0aWNrLlxuICBwcm9jZXNzTmV4dFRpY2sob25FbmROVCwgdGhpcyk7XG59XG5cbmZ1bmN0aW9uIG9uRW5kTlQoc2VsZikge1xuICBzZWxmLmVuZCgpO1xufVxuXG5mdW5jdGlvbiBmb3JFYWNoICh4cywgZikge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGYoeHNbaV0sIGkpO1xuICB9XG59XG4iLCIvLyBhIHBhc3N0aHJvdWdoIHN0cmVhbS5cbi8vIGJhc2ljYWxseSBqdXN0IHRoZSBtb3N0IG1pbmltYWwgc29ydCBvZiBUcmFuc2Zvcm0gc3RyZWFtLlxuLy8gRXZlcnkgd3JpdHRlbiBjaHVuayBnZXRzIG91dHB1dCBhcy1pcy5cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhc3NUaHJvdWdoO1xuXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9fc3RyZWFtX3RyYW5zZm9ybScpO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnV0aWwuaW5oZXJpdHMoUGFzc1Rocm91Z2gsIFRyYW5zZm9ybSk7XG5cbmZ1bmN0aW9uIFBhc3NUaHJvdWdoKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFBhc3NUaHJvdWdoKSlcbiAgICByZXR1cm4gbmV3IFBhc3NUaHJvdWdoKG9wdGlvbnMpO1xuXG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xufVxuXG5QYXNzVGhyb3VnaC5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobnVsbCwgY2h1bmspO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFkYWJsZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBwcm9jZXNzTmV4dFRpY2sgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuUmVhZGFibGUuUmVhZGFibGVTdGF0ZSA9IFJlYWRhYmxlU3RhdGU7XG5cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIEVFbGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJzKHR5cGUpLmxlbmd0aDtcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgU3RyZWFtO1xuKGZ1bmN0aW9uICgpe3RyeXtcbiAgU3RyZWFtID0gcmVxdWlyZSgnc3QnICsgJ3JlYW0nKTtcbn1jYXRjaChfKXt9ZmluYWxseXtcbiAgaWYgKCFTdHJlYW0pXG4gICAgU3RyZWFtID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xufX0oKSlcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblxuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGRlYnVnVXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBkZWJ1ZztcbmlmIChkZWJ1Z1V0aWwgJiYgZGVidWdVdGlsLmRlYnVnbG9nKSB7XG4gIGRlYnVnID0gZGVidWdVdGlsLmRlYnVnbG9nKCdzdHJlYW0nKTtcbn0gZWxzZSB7XG4gIGRlYnVnID0gZnVuY3Rpb24gKCkge307XG59XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIFN0cmluZ0RlY29kZXI7XG5cbnV0aWwuaW5oZXJpdHMoUmVhZGFibGUsIFN0cmVhbSk7XG5cbnZhciBEdXBsZXg7XG5mdW5jdGlvbiBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZy4gVXNlZCB0byBtYWtlIHJlYWQobikgaWdub3JlIG4gYW5kIHRvXG4gIC8vIG1ha2UgYWxsIHRoZSBidWZmZXIgbWVyZ2luZyBhbmQgbGVuZ3RoIGNoZWNrcyBnbyBhd2F5XG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIGlmIChzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXgpXG4gICAgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy5yZWFkYWJsZU9iamVjdE1vZGU7XG5cbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIGl0IHN0b3BzIGNhbGxpbmcgX3JlYWQoKSB0byBmaWxsIHRoZSBidWZmZXJcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyBcImRvbid0IGNhbGwgX3JlYWQgcHJlZW1wdGl2ZWx5IGV2ZXJcIlxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB2YXIgZGVmYXVsdEh3bSA9IHRoaXMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSAoaHdtIHx8IGh3bSA9PT0gMCkgPyBod20gOiBkZWZhdWx0SHdtO1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gfn50aGlzLmhpZ2hXYXRlck1hcms7XG5cbiAgdGhpcy5idWZmZXIgPSBbXTtcbiAgdGhpcy5sZW5ndGggPSAwO1xuICB0aGlzLnBpcGVzID0gbnVsbDtcbiAgdGhpcy5waXBlc0NvdW50ID0gMDtcbiAgdGhpcy5mbG93aW5nID0gbnVsbDtcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICB0aGlzLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgdGhpcy5yZWFkaW5nID0gZmFsc2U7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2UgYW55XG4gIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gd2hlbmV2ZXIgd2UgcmV0dXJuIG51bGwsIHRoZW4gd2Ugc2V0IGEgZmxhZyB0byBzYXlcbiAgLy8gdGhhdCB3ZSdyZSBhd2FpdGluZyBhICdyZWFkYWJsZScgZXZlbnQgZW1pc3Npb24uXG4gIHRoaXMubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMucmVhZGFibGVMaXN0ZW5pbmcgPSBmYWxzZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyB3aGVuIHBpcGluZywgd2Ugb25seSBjYXJlIGFib3V0ICdyZWFkYWJsZScgZXZlbnRzIHRoYXQgaGFwcGVuXG4gIC8vIGFmdGVyIHJlYWQoKWluZyBhbGwgdGhlIGJ5dGVzIGFuZCBub3QgZ2V0dGluZyBhbnkgcHVzaGJhY2suXG4gIHRoaXMucmFuT3V0ID0gZmFsc2U7XG5cbiAgLy8gdGhlIG51bWJlciBvZiB3cml0ZXJzIHRoYXQgYXJlIGF3YWl0aW5nIGEgZHJhaW4gZXZlbnQgaW4gLnBpcGUoKXNcbiAgdGhpcy5hd2FpdERyYWluID0gMDtcblxuICAvLyBpZiB0cnVlLCBhIG1heWJlUmVhZE1vcmUgaGFzIGJlZW4gc2NoZWR1bGVkXG4gIHRoaXMucmVhZGluZ01vcmUgPSBmYWxzZTtcblxuICB0aGlzLmRlY29kZXIgPSBudWxsO1xuICB0aGlzLmVuY29kaW5nID0gbnVsbDtcbiAgaWYgKG9wdGlvbnMuZW5jb2RpbmcpIHtcbiAgICBpZiAoIVN0cmluZ0RlY29kZXIpXG4gICAgICBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgICB0aGlzLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihvcHRpb25zLmVuY29kaW5nKTtcbiAgICB0aGlzLmVuY29kaW5nID0gb3B0aW9ucy5lbmNvZGluZztcbiAgfVxufVxuXG52YXIgRHVwbGV4O1xuZnVuY3Rpb24gUmVhZGFibGUob3B0aW9ucykge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZWFkYWJsZSkpXG4gICAgcmV0dXJuIG5ldyBSZWFkYWJsZShvcHRpb25zKTtcblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlID0gbmV3IFJlYWRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5XG4gIHRoaXMucmVhZGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLnJlYWQgPT09ICdmdW5jdGlvbicpXG4gICAgdGhpcy5fcmVhZCA9IG9wdGlvbnMucmVhZDtcblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuLy8gTWFudWFsbHkgc2hvdmUgc29tZXRoaW5nIGludG8gdGhlIHJlYWQoKSBidWZmZXIuXG4vLyBUaGlzIHJldHVybnMgdHJ1ZSBpZiB0aGUgaGlnaFdhdGVyTWFyayBoYXMgbm90IGJlZW4gaGl0IHlldCxcbi8vIHNpbWlsYXIgdG8gaG93IFdyaXRhYmxlLndyaXRlKCkgcmV0dXJucyB0cnVlIGlmIHlvdSBzaG91bGRcbi8vIHdyaXRlKCkgc29tZSBtb3JlLlxuUmVhZGFibGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuICAgIGlmIChlbmNvZGluZyAhPT0gc3RhdGUuZW5jb2RpbmcpIHtcbiAgICAgIGNodW5rID0gbmV3IEJ1ZmZlcihjaHVuaywgZW5jb2RpbmcpO1xuICAgICAgZW5jb2RpbmcgPSAnJztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBmYWxzZSk7XG59O1xuXG4vLyBVbnNoaWZ0IHNob3VsZCAqYWx3YXlzKiBiZSBzb21ldGhpbmcgZGlyZWN0bHkgb3V0IG9mIHJlYWQoKVxuUmVhZGFibGUucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbihjaHVuaykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssICcnLCB0cnVlKTtcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5pc1BhdXNlZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID09PSBmYWxzZTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRhYmxlQWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBhZGRUb0Zyb250KSB7XG4gIHZhciBlciA9IGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspO1xuICBpZiAoZXIpIHtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIH0gZWxzZSBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKTtcbiAgfSBlbHNlIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rICYmIGNodW5rLmxlbmd0aCA+IDApIHtcbiAgICBpZiAoc3RhdGUuZW5kZWQgJiYgIWFkZFRvRnJvbnQpIHtcbiAgICAgIHZhciBlID0gbmV3IEVycm9yKCdzdHJlYW0ucHVzaCgpIGFmdGVyIEVPRicpO1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZSk7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5lbmRFbWl0dGVkICYmIGFkZFRvRnJvbnQpIHtcbiAgICAgIHZhciBlID0gbmV3IEVycm9yKCdzdHJlYW0udW5zaGlmdCgpIGFmdGVyIGVuZCBldmVudCcpO1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFhZGRUb0Zyb250ICYmICFlbmNvZGluZylcbiAgICAgICAgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcblxuICAgICAgaWYgKCFhZGRUb0Zyb250KVxuICAgICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG5cbiAgICAgIC8vIGlmIHdlIHdhbnQgdGhlIGRhdGEgbm93LCBqdXN0IGVtaXQgaXQuXG4gICAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgIXN0YXRlLnN5bmMpIHtcbiAgICAgICAgc3RyZWFtLmVtaXQoJ2RhdGEnLCBjaHVuayk7XG4gICAgICAgIHN0cmVhbS5yZWFkKDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdXBkYXRlIHRoZSBidWZmZXIgaW5mby5cbiAgICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgICAgICBpZiAoYWRkVG9Gcm9udClcbiAgICAgICAgICBzdGF0ZS5idWZmZXIudW5zaGlmdChjaHVuayk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG5cbiAgICAgICAgaWYgKHN0YXRlLm5lZWRSZWFkYWJsZSlcbiAgICAgICAgICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbiAgICAgIH1cblxuICAgICAgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoIWFkZFRvRnJvbnQpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gbmVlZE1vcmVEYXRhKHN0YXRlKTtcbn1cblxuXG4vLyBpZiBpdCdzIHBhc3QgdGhlIGhpZ2ggd2F0ZXIgbWFyaywgd2UgY2FuIHB1c2ggaW4gc29tZSBtb3JlLlxuLy8gQWxzbywgaWYgd2UgaGF2ZSBubyBkYXRhIHlldCwgd2UgY2FuIHN0YW5kIHNvbWVcbi8vIG1vcmUgYnl0ZXMuICBUaGlzIGlzIHRvIHdvcmsgYXJvdW5kIGNhc2VzIHdoZXJlIGh3bT0wLFxuLy8gc3VjaCBhcyB0aGUgcmVwbC4gIEFsc28sIGlmIHRoZSBwdXNoKCkgdHJpZ2dlcmVkIGFcbi8vIHJlYWRhYmxlIGV2ZW50LCBhbmQgdGhlIHVzZXIgY2FsbGVkIHJlYWQobGFyZ2VOdW1iZXIpIHN1Y2ggdGhhdFxuLy8gbmVlZFJlYWRhYmxlIHdhcyBzZXQsIHRoZW4gd2Ugb3VnaHQgdG8gcHVzaCBtb3JlLCBzbyB0aGF0IGFub3RoZXJcbi8vICdyZWFkYWJsZScgZXZlbnQgd2lsbCBiZSB0cmlnZ2VyZWQuXG5mdW5jdGlvbiBuZWVkTW9yZURhdGEoc3RhdGUpIHtcbiAgcmV0dXJuICFzdGF0ZS5lbmRlZCAmJlxuICAgICAgICAgKHN0YXRlLm5lZWRSZWFkYWJsZSB8fFxuICAgICAgICAgIHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHxcbiAgICAgICAgICBzdGF0ZS5sZW5ndGggPT09IDApO1xufVxuXG4vLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cblJlYWRhYmxlLnByb3RvdHlwZS5zZXRFbmNvZGluZyA9IGZ1bmN0aW9uKGVuYykge1xuICBpZiAoIVN0cmluZ0RlY29kZXIpXG4gICAgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKGVuYyk7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5jb2RpbmcgPSBlbmM7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gRG9uJ3QgcmFpc2UgdGhlIGh3bSA+IDhNQlxudmFyIE1BWF9IV00gPSAweDgwMDAwMDtcbmZ1bmN0aW9uIGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pIHtcbiAgaWYgKG4gPj0gTUFYX0hXTSkge1xuICAgIG4gPSBNQVhfSFdNO1xuICB9IGVsc2Uge1xuICAgIC8vIEdldCB0aGUgbmV4dCBoaWdoZXN0IHBvd2VyIG9mIDJcbiAgICBuLS07XG4gICAgbiB8PSBuID4+PiAxO1xuICAgIG4gfD0gbiA+Pj4gMjtcbiAgICBuIHw9IG4gPj4+IDQ7XG4gICAgbiB8PSBuID4+PiA4O1xuICAgIG4gfD0gbiA+Pj4gMTY7XG4gICAgbisrO1xuICB9XG4gIHJldHVybiBuO1xufVxuXG5mdW5jdGlvbiBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpXG4gICAgcmV0dXJuIDA7XG5cbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpXG4gICAgcmV0dXJuIG4gPT09IDAgPyAwIDogMTtcblxuICBpZiAobiA9PT0gbnVsbCB8fCBpc05hTihuKSkge1xuICAgIC8vIG9ubHkgZmxvdyBvbmUgYnVmZmVyIGF0IGEgdGltZVxuICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmJ1ZmZlci5sZW5ndGgpXG4gICAgICByZXR1cm4gc3RhdGUuYnVmZmVyWzBdLmxlbmd0aDtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gc3RhdGUubGVuZ3RoO1xuICB9XG5cbiAgaWYgKG4gPD0gMClcbiAgICByZXR1cm4gMDtcblxuICAvLyBJZiB3ZSdyZSBhc2tpbmcgZm9yIG1vcmUgdGhhbiB0aGUgdGFyZ2V0IGJ1ZmZlciBsZXZlbCxcbiAgLy8gdGhlbiByYWlzZSB0aGUgd2F0ZXIgbWFyay4gIEJ1bXAgdXAgdG8gdGhlIG5leHQgaGlnaGVzdFxuICAvLyBwb3dlciBvZiAyLCB0byBwcmV2ZW50IGluY3JlYXNpbmcgaXQgZXhjZXNzaXZlbHkgaW4gdGlueVxuICAvLyBhbW91bnRzLlxuICBpZiAobiA+IHN0YXRlLmhpZ2hXYXRlck1hcmspXG4gICAgc3RhdGUuaGlnaFdhdGVyTWFyayA9IGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pO1xuXG4gIC8vIGRvbid0IGhhdmUgdGhhdCBtdWNoLiAgcmV0dXJuIG51bGwsIHVubGVzcyB3ZSd2ZSBlbmRlZC5cbiAgaWYgKG4gPiBzdGF0ZS5sZW5ndGgpIHtcbiAgICBpZiAoIXN0YXRlLmVuZGVkKSB7XG4gICAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzdGF0ZS5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG47XG59XG5cbi8vIHlvdSBjYW4gb3ZlcnJpZGUgZWl0aGVyIHRoaXMgbWV0aG9kLCBvciB0aGUgYXN5bmMgX3JlYWQobikgYmVsb3cuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uKG4pIHtcbiAgZGVidWcoJ3JlYWQnLCBuKTtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIG5PcmlnID0gbjtcblxuICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInIHx8IG4gPiAwKVxuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuXG4gIC8vIGlmIHdlJ3JlIGRvaW5nIHJlYWQoMCkgdG8gdHJpZ2dlciBhIHJlYWRhYmxlIGV2ZW50LCBidXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGEgYnVuY2ggb2YgZGF0YSBpbiB0aGUgYnVmZmVyLCB0aGVuIGp1c3QgdHJpZ2dlclxuICAvLyB0aGUgJ3JlYWRhYmxlJyBldmVudCBhbmQgbW92ZSBvbi5cbiAgaWYgKG4gPT09IDAgJiZcbiAgICAgIHN0YXRlLm5lZWRSZWFkYWJsZSAmJlxuICAgICAgKHN0YXRlLmxlbmd0aCA+PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmVuZGVkKSkge1xuICAgIGRlYnVnKCdyZWFkOiBlbWl0UmVhZGFibGUnLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLmVuZGVkKTtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKVxuICAgICAgZW5kUmVhZGFibGUodGhpcyk7XG4gICAgZWxzZVxuICAgICAgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbiA9IGhvd011Y2hUb1JlYWQobiwgc3RhdGUpO1xuXG4gIC8vIGlmIHdlJ3ZlIGVuZGVkLCBhbmQgd2UncmUgbm93IGNsZWFyLCB0aGVuIGZpbmlzaCBpdCB1cC5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUuZW5kZWQpIHtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKVxuICAgICAgZW5kUmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBBbGwgdGhlIGFjdHVhbCBjaHVuayBnZW5lcmF0aW9uIGxvZ2ljIG5lZWRzIHRvIGJlXG4gIC8vICpiZWxvdyogdGhlIGNhbGwgdG8gX3JlYWQuICBUaGUgcmVhc29uIGlzIHRoYXQgaW4gY2VydGFpblxuICAvLyBzeW50aGV0aWMgc3RyZWFtIGNhc2VzLCBzdWNoIGFzIHBhc3N0aHJvdWdoIHN0cmVhbXMsIF9yZWFkXG4gIC8vIG1heSBiZSBhIGNvbXBsZXRlbHkgc3luY2hyb25vdXMgb3BlcmF0aW9uIHdoaWNoIG1heSBjaGFuZ2VcbiAgLy8gdGhlIHN0YXRlIG9mIHRoZSByZWFkIGJ1ZmZlciwgcHJvdmlkaW5nIGVub3VnaCBkYXRhIHdoZW5cbiAgLy8gYmVmb3JlIHRoZXJlIHdhcyAqbm90KiBlbm91Z2guXG4gIC8vXG4gIC8vIFNvLCB0aGUgc3RlcHMgYXJlOlxuICAvLyAxLiBGaWd1cmUgb3V0IHdoYXQgdGhlIHN0YXRlIG9mIHRoaW5ncyB3aWxsIGJlIGFmdGVyIHdlIGRvXG4gIC8vIGEgcmVhZCBmcm9tIHRoZSBidWZmZXIuXG4gIC8vXG4gIC8vIDIuIElmIHRoYXQgcmVzdWx0aW5nIHN0YXRlIHdpbGwgdHJpZ2dlciBhIF9yZWFkLCB0aGVuIGNhbGwgX3JlYWQuXG4gIC8vIE5vdGUgdGhhdCB0aGlzIG1heSBiZSBhc3luY2hyb25vdXMsIG9yIHN5bmNocm9ub3VzLiAgWWVzLCBpdCBpc1xuICAvLyBkZWVwbHkgdWdseSB0byB3cml0ZSBBUElzIHRoaXMgd2F5LCBidXQgdGhhdCBzdGlsbCBkb2Vzbid0IG1lYW5cbiAgLy8gdGhhdCB0aGUgUmVhZGFibGUgY2xhc3Mgc2hvdWxkIGJlaGF2ZSBpbXByb3Blcmx5LCBhcyBzdHJlYW1zIGFyZVxuICAvLyBkZXNpZ25lZCB0byBiZSBzeW5jL2FzeW5jIGFnbm9zdGljLlxuICAvLyBUYWtlIG5vdGUgaWYgdGhlIF9yZWFkIGNhbGwgaXMgc3luYyBvciBhc3luYyAoaWUsIGlmIHRoZSByZWFkIGNhbGxcbiAgLy8gaGFzIHJldHVybmVkIHlldCksIHNvIHRoYXQgd2Uga25vdyB3aGV0aGVyIG9yIG5vdCBpdCdzIHNhZmUgdG8gZW1pdFxuICAvLyAncmVhZGFibGUnIGV0Yy5cbiAgLy9cbiAgLy8gMy4gQWN0dWFsbHkgcHVsbCB0aGUgcmVxdWVzdGVkIGNodW5rcyBvdXQgb2YgdGhlIGJ1ZmZlciBhbmQgcmV0dXJuLlxuXG4gIC8vIGlmIHdlIG5lZWQgYSByZWFkYWJsZSBldmVudCwgdGhlbiB3ZSBuZWVkIHRvIGRvIHNvbWUgcmVhZGluZy5cbiAgdmFyIGRvUmVhZCA9IHN0YXRlLm5lZWRSZWFkYWJsZTtcbiAgZGVidWcoJ25lZWQgcmVhZGFibGUnLCBkb1JlYWQpO1xuXG4gIC8vIGlmIHdlIGN1cnJlbnRseSBoYXZlIGxlc3MgdGhhbiB0aGUgaGlnaFdhdGVyTWFyaywgdGhlbiBhbHNvIHJlYWQgc29tZVxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwIHx8IHN0YXRlLmxlbmd0aCAtIG4gPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZG9SZWFkID0gdHJ1ZTtcbiAgICBkZWJ1ZygnbGVuZ3RoIGxlc3MgdGhhbiB3YXRlcm1hcmsnLCBkb1JlYWQpO1xuICB9XG5cbiAgLy8gaG93ZXZlciwgaWYgd2UndmUgZW5kZWQsIHRoZW4gdGhlcmUncyBubyBwb2ludCwgYW5kIGlmIHdlJ3JlIGFscmVhZHlcbiAgLy8gcmVhZGluZywgdGhlbiBpdCdzIHVubmVjZXNzYXJ5LlxuICBpZiAoc3RhdGUuZW5kZWQgfHwgc3RhdGUucmVhZGluZykge1xuICAgIGRvUmVhZCA9IGZhbHNlO1xuICAgIGRlYnVnKCdyZWFkaW5nIG9yIGVuZGVkJywgZG9SZWFkKTtcbiAgfVxuXG4gIGlmIChkb1JlYWQpIHtcbiAgICBkZWJ1ZygnZG8gcmVhZCcpO1xuICAgIHN0YXRlLnJlYWRpbmcgPSB0cnVlO1xuICAgIHN0YXRlLnN5bmMgPSB0cnVlO1xuICAgIC8vIGlmIHRoZSBsZW5ndGggaXMgY3VycmVudGx5IHplcm8sIHRoZW4gd2UgKm5lZWQqIGEgcmVhZGFibGUgZXZlbnQuXG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMClcbiAgICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgLy8gY2FsbCBpbnRlcm5hbCByZWFkIG1ldGhvZFxuICAgIHRoaXMuX3JlYWQoc3RhdGUuaGlnaFdhdGVyTWFyayk7XG4gICAgc3RhdGUuc3luYyA9IGZhbHNlO1xuICB9XG5cbiAgLy8gSWYgX3JlYWQgcHVzaGVkIGRhdGEgc3luY2hyb25vdXNseSwgdGhlbiBgcmVhZGluZ2Agd2lsbCBiZSBmYWxzZSxcbiAgLy8gYW5kIHdlIG5lZWQgdG8gcmUtZXZhbHVhdGUgaG93IG11Y2ggZGF0YSB3ZSBjYW4gcmV0dXJuIHRvIHRoZSB1c2VyLlxuICBpZiAoZG9SZWFkICYmICFzdGF0ZS5yZWFkaW5nKVxuICAgIG4gPSBob3dNdWNoVG9SZWFkKG5PcmlnLCBzdGF0ZSk7XG5cbiAgdmFyIHJldDtcbiAgaWYgKG4gPiAwKVxuICAgIHJldCA9IGZyb21MaXN0KG4sIHN0YXRlKTtcbiAgZWxzZVxuICAgIHJldCA9IG51bGw7XG5cbiAgaWYgKHJldCA9PT0gbnVsbCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgbiA9IDA7XG4gIH1cblxuICBzdGF0ZS5sZW5ndGggLT0gbjtcblxuICAvLyBJZiB3ZSBoYXZlIG5vdGhpbmcgaW4gdGhlIGJ1ZmZlciwgdGhlbiB3ZSB3YW50IHRvIGtub3dcbiAgLy8gYXMgc29vbiBhcyB3ZSAqZG8qIGdldCBzb21ldGhpbmcgaW50byB0aGUgYnVmZmVyLlxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmICFzdGF0ZS5lbmRlZClcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gIC8vIElmIHdlIHRyaWVkIHRvIHJlYWQoKSBwYXN0IHRoZSBFT0YsIHRoZW4gZW1pdCBlbmQgb24gdGhlIG5leHQgdGljay5cbiAgaWYgKG5PcmlnICE9PSBuICYmIHN0YXRlLmVuZGVkICYmIHN0YXRlLmxlbmd0aCA9PT0gMClcbiAgICBlbmRSZWFkYWJsZSh0aGlzKTtcblxuICBpZiAocmV0ICE9PSBudWxsKVxuICAgIHRoaXMuZW1pdCgnZGF0YScsIHJldCk7XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspIHtcbiAgdmFyIGVyID0gbnVsbDtcbiAgaWYgKCEoQnVmZmVyLmlzQnVmZmVyKGNodW5rKSkgJiZcbiAgICAgIHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiZcbiAgICAgIGNodW5rICE9PSBudWxsICYmXG4gICAgICBjaHVuayAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICB9XG4gIHJldHVybiBlcjtcbn1cblxuXG5mdW5jdGlvbiBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmVuZGVkKSByZXR1cm47XG4gIGlmIChzdGF0ZS5kZWNvZGVyKSB7XG4gICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSB7XG4gICAgICBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG4gICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgfVxuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcblxuICAvLyBlbWl0ICdyZWFkYWJsZScgbm93IHRvIG1ha2Ugc3VyZSBpdCBnZXRzIHBpY2tlZCB1cC5cbiAgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG59XG5cbi8vIERvbid0IGVtaXQgcmVhZGFibGUgcmlnaHQgYXdheSBpbiBzeW5jIG1vZGUsIGJlY2F1c2UgdGhpcyBjYW4gdHJpZ2dlclxuLy8gYW5vdGhlciByZWFkKCkgY2FsbCA9PiBzdGFjayBvdmVyZmxvdy4gIFRoaXMgd2F5LCBpdCBtaWdodCB0cmlnZ2VyXG4vLyBhIG5leHRUaWNrIHJlY3Vyc2lvbiB3YXJuaW5nLCBidXQgdGhhdCdzIG5vdCBzbyBiYWQuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgc3RhdGUubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIGlmICghc3RhdGUuZW1pdHRlZFJlYWRhYmxlKSB7XG4gICAgZGVidWcoJ2VtaXRSZWFkYWJsZScsIHN0YXRlLmZsb3dpbmcpO1xuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgaWYgKHN0YXRlLnN5bmMpXG4gICAgICBwcm9jZXNzTmV4dFRpY2soZW1pdFJlYWRhYmxlXywgc3RyZWFtKTtcbiAgICBlbHNlXG4gICAgICBlbWl0UmVhZGFibGVfKHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlXyhzdHJlYW0pIHtcbiAgZGVidWcoJ2VtaXQgcmVhZGFibGUnKTtcbiAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJyk7XG4gIGZsb3coc3RyZWFtKTtcbn1cblxuXG4vLyBhdCB0aGlzIHBvaW50LCB0aGUgdXNlciBoYXMgcHJlc3VtYWJseSBzZWVuIHRoZSAncmVhZGFibGUnIGV2ZW50LFxuLy8gYW5kIGNhbGxlZCByZWFkKCkgdG8gY29uc3VtZSBzb21lIGRhdGEuICB0aGF0IG1heSBoYXZlIHRyaWdnZXJlZFxuLy8gaW4gdHVybiBhbm90aGVyIF9yZWFkKG4pIGNhbGwsIGluIHdoaWNoIGNhc2UgcmVhZGluZyA9IHRydWUgaWZcbi8vIGl0J3MgaW4gcHJvZ3Jlc3MuXG4vLyBIb3dldmVyLCBpZiB3ZSdyZSBub3QgZW5kZWQsIG9yIHJlYWRpbmcsIGFuZCB0aGUgbGVuZ3RoIDwgaHdtLFxuLy8gdGhlbiBnbyBhaGVhZCBhbmQgdHJ5IHRvIHJlYWQgc29tZSBtb3JlIHByZWVtcHRpdmVseS5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmdNb3JlKSB7XG4gICAgc3RhdGUucmVhZGluZ01vcmUgPSB0cnVlO1xuICAgIHByb2Nlc3NOZXh0VGljayhtYXliZVJlYWRNb3JlXywgc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZV8oc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB3aGlsZSAoIXN0YXRlLnJlYWRpbmcgJiYgIXN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLmVuZGVkICYmXG4gICAgICAgICBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZGVidWcoJ21heWJlUmVhZE1vcmUgcmVhZCAwJyk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gICAgaWYgKGxlbiA9PT0gc3RhdGUubGVuZ3RoKVxuICAgICAgLy8gZGlkbid0IGdldCBhbnkgZGF0YSwgc3RvcCBzcGlubmluZy5cbiAgICAgIGJyZWFrO1xuICAgIGVsc2VcbiAgICAgIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgfVxuICBzdGF0ZS5yZWFkaW5nTW9yZSA9IGZhbHNlO1xufVxuXG4vLyBhYnN0cmFjdCBtZXRob2QuICB0byBiZSBvdmVycmlkZGVuIGluIHNwZWNpZmljIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyBjYWxsIGNiKGVyLCBkYXRhKSB3aGVyZSBkYXRhIGlzIDw9IG4gaW4gbGVuZ3RoLlxuLy8gZm9yIHZpcnR1YWwgKG5vbi1zdHJpbmcsIG5vbi1idWZmZXIpIHN0cmVhbXMsIFwibGVuZ3RoXCIgaXMgc29tZXdoYXRcbi8vIGFyYml0cmFyeSwgYW5kIHBlcmhhcHMgbm90IHZlcnkgbWVhbmluZ2Z1bC5cblJlYWRhYmxlLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uKG4pIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbihkZXN0LCBwaXBlT3B0cykge1xuICB2YXIgc3JjID0gdGhpcztcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBzd2l0Y2ggKHN0YXRlLnBpcGVzQ291bnQpIHtcbiAgICBjYXNlIDA6XG4gICAgICBzdGF0ZS5waXBlcyA9IGRlc3Q7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDE6XG4gICAgICBzdGF0ZS5waXBlcyA9IFtzdGF0ZS5waXBlcywgZGVzdF07XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgc3RhdGUucGlwZXMucHVzaChkZXN0KTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHN0YXRlLnBpcGVzQ291bnQgKz0gMTtcbiAgZGVidWcoJ3BpcGUgY291bnQ9JWQgb3B0cz0laicsIHN0YXRlLnBpcGVzQ291bnQsIHBpcGVPcHRzKTtcblxuICB2YXIgZG9FbmQgPSAoIXBpcGVPcHRzIHx8IHBpcGVPcHRzLmVuZCAhPT0gZmFsc2UpICYmXG4gICAgICAgICAgICAgIGRlc3QgIT09IHByb2Nlc3Muc3Rkb3V0ICYmXG4gICAgICAgICAgICAgIGRlc3QgIT09IHByb2Nlc3Muc3RkZXJyO1xuXG4gIHZhciBlbmRGbiA9IGRvRW5kID8gb25lbmQgOiBjbGVhbnVwO1xuICBpZiAoc3RhdGUuZW5kRW1pdHRlZClcbiAgICBwcm9jZXNzTmV4dFRpY2soZW5kRm4pO1xuICBlbHNlXG4gICAgc3JjLm9uY2UoJ2VuZCcsIGVuZEZuKTtcblxuICBkZXN0Lm9uKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gIGZ1bmN0aW9uIG9udW5waXBlKHJlYWRhYmxlKSB7XG4gICAgZGVidWcoJ29udW5waXBlJyk7XG4gICAgaWYgKHJlYWRhYmxlID09PSBzcmMpIHtcbiAgICAgIGNsZWFudXAoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBkZWJ1Zygnb25lbmQnKTtcbiAgICBkZXN0LmVuZCgpO1xuICB9XG5cbiAgLy8gd2hlbiB0aGUgZGVzdCBkcmFpbnMsIGl0IHJlZHVjZXMgdGhlIGF3YWl0RHJhaW4gY291bnRlclxuICAvLyBvbiB0aGUgc291cmNlLiAgVGhpcyB3b3VsZCBiZSBtb3JlIGVsZWdhbnQgd2l0aCBhIC5vbmNlKClcbiAgLy8gaGFuZGxlciBpbiBmbG93KCksIGJ1dCBhZGRpbmcgYW5kIHJlbW92aW5nIHJlcGVhdGVkbHkgaXNcbiAgLy8gdG9vIHNsb3cuXG4gIHZhciBvbmRyYWluID0gcGlwZU9uRHJhaW4oc3JjKTtcbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICB2YXIgY2xlYW5lZFVwID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgZGVidWcoJ2NsZWFudXAnKTtcbiAgICAvLyBjbGVhbnVwIGV2ZW50IGhhbmRsZXJzIG9uY2UgdGhlIHBpcGUgaXMgYnJva2VuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ3VucGlwZScsIG9udW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIGNsZWFudXApO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7XG5cbiAgICBjbGVhbmVkVXAgPSB0cnVlO1xuXG4gICAgLy8gaWYgdGhlIHJlYWRlciBpcyB3YWl0aW5nIGZvciBhIGRyYWluIGV2ZW50IGZyb20gdGhpc1xuICAgIC8vIHNwZWNpZmljIHdyaXRlciwgdGhlbiBpdCB3b3VsZCBjYXVzZSBpdCB0byBuZXZlciBzdGFydFxuICAgIC8vIGZsb3dpbmcgYWdhaW4uXG4gICAgLy8gU28sIGlmIHRoaXMgaXMgYXdhaXRpbmcgYSBkcmFpbiwgdGhlbiB3ZSBqdXN0IGNhbGwgaXQgbm93LlxuICAgIC8vIElmIHdlIGRvbid0IGtub3csIHRoZW4gYXNzdW1lIHRoYXQgd2UgYXJlIHdhaXRpbmcgZm9yIG9uZS5cbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiAmJlxuICAgICAgICAoIWRlc3QuX3dyaXRhYmxlU3RhdGUgfHwgZGVzdC5fd3JpdGFibGVTdGF0ZS5uZWVkRHJhaW4pKVxuICAgICAgb25kcmFpbigpO1xuICB9XG5cbiAgc3JjLm9uKCdkYXRhJywgb25kYXRhKTtcbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgZGVidWcoJ29uZGF0YScpO1xuICAgIHZhciByZXQgPSBkZXN0LndyaXRlKGNodW5rKTtcbiAgICBpZiAoZmFsc2UgPT09IHJldCkge1xuICAgICAgLy8gSWYgdGhlIHVzZXIgdW5waXBlZCBkdXJpbmcgYGRlc3Qud3JpdGUoKWAsIGl0IGlzIHBvc3NpYmxlXG4gICAgICAvLyB0byBnZXQgc3R1Y2sgaW4gYSBwZXJtYW5lbnRseSBwYXVzZWQgc3RhdGUgaWYgdGhhdCB3cml0ZVxuICAgICAgLy8gYWxzbyByZXR1cm5lZCBmYWxzZS5cbiAgICAgIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxICYmXG4gICAgICAgICAgc3RhdGUucGlwZXNbMF0gPT09IGRlc3QgJiZcbiAgICAgICAgICBzcmMubGlzdGVuZXJDb3VudCgnZGF0YScpID09PSAxICYmXG4gICAgICAgICAgIWNsZWFuZWRVcCkge1xuICAgICAgICBkZWJ1ZygnZmFsc2Ugd3JpdGUgcmVzcG9uc2UsIHBhdXNlJywgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4pO1xuICAgICAgICBzcmMuX3JlYWRhYmxlU3RhdGUuYXdhaXREcmFpbisrO1xuICAgICAgfVxuICAgICAgc3JjLnBhdXNlKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIGRlc3QgaGFzIGFuIGVycm9yLCB0aGVuIHN0b3AgcGlwaW5nIGludG8gaXQuXG4gIC8vIGhvd2V2ZXIsIGRvbid0IHN1cHByZXNzIHRoZSB0aHJvd2luZyBiZWhhdmlvciBmb3IgdGhpcy5cbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgIGRlYnVnKCdvbmVycm9yJywgZXIpO1xuICAgIHVucGlwZSgpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgaWYgKEVFbGlzdGVuZXJDb3VudChkZXN0LCAnZXJyb3InKSA9PT0gMClcbiAgICAgIGRlc3QuZW1pdCgnZXJyb3InLCBlcik7XG4gIH1cbiAgLy8gVGhpcyBpcyBhIGJydXRhbGx5IHVnbHkgaGFjayB0byBtYWtlIHN1cmUgdGhhdCBvdXIgZXJyb3IgaGFuZGxlclxuICAvLyBpcyBhdHRhY2hlZCBiZWZvcmUgYW55IHVzZXJsYW5kIG9uZXMuICBORVZFUiBETyBUSElTLlxuICBpZiAoIWRlc3QuX2V2ZW50cyB8fCAhZGVzdC5fZXZlbnRzLmVycm9yKVxuICAgIGRlc3Qub24oJ2Vycm9yJywgb25lcnJvcik7XG4gIGVsc2UgaWYgKGlzQXJyYXkoZGVzdC5fZXZlbnRzLmVycm9yKSlcbiAgICBkZXN0Ll9ldmVudHMuZXJyb3IudW5zaGlmdChvbmVycm9yKTtcbiAgZWxzZVxuICAgIGRlc3QuX2V2ZW50cy5lcnJvciA9IFtvbmVycm9yLCBkZXN0Ll9ldmVudHMuZXJyb3JdO1xuXG5cbiAgLy8gQm90aCBjbG9zZSBhbmQgZmluaXNoIHNob3VsZCB0cmlnZ2VyIHVucGlwZSwgYnV0IG9ubHkgb25jZS5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdjbG9zZScsIG9uY2xvc2UpO1xuICBmdW5jdGlvbiBvbmZpbmlzaCgpIHtcbiAgICBkZWJ1Zygnb25maW5pc2gnKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnZmluaXNoJywgb25maW5pc2gpO1xuXG4gIGZ1bmN0aW9uIHVucGlwZSgpIHtcbiAgICBkZWJ1ZygndW5waXBlJyk7XG4gICAgc3JjLnVucGlwZShkZXN0KTtcbiAgfVxuXG4gIC8vIHRlbGwgdGhlIGRlc3QgdGhhdCBpdCdzIGJlaW5nIHBpcGVkIHRvXG4gIGRlc3QuZW1pdCgncGlwZScsIHNyYyk7XG5cbiAgLy8gc3RhcnQgdGhlIGZsb3cgaWYgaXQgaGFzbid0IGJlZW4gc3RhcnRlZCBhbHJlYWR5LlxuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGlwZSByZXN1bWUnKTtcbiAgICBzcmMucmVzdW1lKCk7XG4gIH1cblxuICByZXR1cm4gZGVzdDtcbn07XG5cbmZ1bmN0aW9uIHBpcGVPbkRyYWluKHNyYykge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xuICAgIGRlYnVnKCdwaXBlT25EcmFpbicsIHN0YXRlLmF3YWl0RHJhaW4pO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluKVxuICAgICAgc3RhdGUuYXdhaXREcmFpbi0tO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluID09PSAwICYmIEVFbGlzdGVuZXJDb3VudChzcmMsICdkYXRhJykpIHtcbiAgICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgICAgZmxvdyhzcmMpO1xuICAgIH1cbiAgfTtcbn1cblxuXG5SZWFkYWJsZS5wcm90b3R5cGUudW5waXBlID0gZnVuY3Rpb24oZGVzdCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIC8vIGlmIHdlJ3JlIG5vdCBwaXBpbmcgYW55d2hlcmUsIHRoZW4gZG8gbm90aGluZy5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDApXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8ganVzdCBvbmUgZGVzdGluYXRpb24uICBtb3N0IGNvbW1vbiBjYXNlLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkge1xuICAgIC8vIHBhc3NlZCBpbiBvbmUsIGJ1dCBpdCdzIG5vdCB0aGUgcmlnaHQgb25lLlxuICAgIGlmIChkZXN0ICYmIGRlc3QgIT09IHN0YXRlLnBpcGVzKVxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAoIWRlc3QpXG4gICAgICBkZXN0ID0gc3RhdGUucGlwZXM7XG5cbiAgICAvLyBnb3QgYSBtYXRjaC5cbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIGlmIChkZXN0KVxuICAgICAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHNsb3cgY2FzZS4gbXVsdGlwbGUgcGlwZSBkZXN0aW5hdGlvbnMuXG5cbiAgaWYgKCFkZXN0KSB7XG4gICAgLy8gcmVtb3ZlIGFsbC5cbiAgICB2YXIgZGVzdHMgPSBzdGF0ZS5waXBlcztcbiAgICB2YXIgbGVuID0gc3RhdGUucGlwZXNDb3VudDtcbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgIGRlc3RzW2ldLmVtaXQoJ3VucGlwZScsIHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gdHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IG9uZS5cbiAgdmFyIGkgPSBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KTtcbiAgaWYgKGkgPT09IC0xKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIHN0YXRlLnBpcGVzLnNwbGljZShpLCAxKTtcbiAgc3RhdGUucGlwZXNDb3VudCAtPSAxO1xuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSlcbiAgICBzdGF0ZS5waXBlcyA9IHN0YXRlLnBpcGVzWzBdO1xuXG4gIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBzZXQgdXAgZGF0YSBldmVudHMgaWYgdGhleSBhcmUgYXNrZWQgZm9yXG4vLyBFbnN1cmUgcmVhZGFibGUgbGlzdGVuZXJzIGV2ZW50dWFsbHkgZ2V0IHNvbWV0aGluZ1xuUmVhZGFibGUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24oZXYsIGZuKSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXYsIGZuKTtcblxuICAvLyBJZiBsaXN0ZW5pbmcgdG8gZGF0YSwgYW5kIGl0IGhhcyBub3QgZXhwbGljaXRseSBiZWVuIHBhdXNlZCxcbiAgLy8gdGhlbiBjYWxsIHJlc3VtZSB0byBzdGFydCB0aGUgZmxvdyBvZiBkYXRhIG9uIHRoZSBuZXh0IHRpY2suXG4gIGlmIChldiA9PT0gJ2RhdGEnICYmIGZhbHNlICE9PSB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpIHtcbiAgICB0aGlzLnJlc3VtZSgpO1xuICB9XG5cbiAgaWYgKGV2ID09PSAncmVhZGFibGUnICYmIHRoaXMucmVhZGFibGUpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICghc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcpIHtcbiAgICAgIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gdHJ1ZTtcbiAgICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgIGlmICghc3RhdGUucmVhZGluZykge1xuICAgICAgICBwcm9jZXNzTmV4dFRpY2soblJlYWRpbmdOZXh0VGljaywgdGhpcyk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmxlbmd0aCkge1xuICAgICAgICBlbWl0UmVhZGFibGUodGhpcywgc3RhdGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuUmVhZGFibGUucHJvdG90eXBlLmFkZExpc3RlbmVyID0gUmVhZGFibGUucHJvdG90eXBlLm9uO1xuXG5mdW5jdGlvbiBuUmVhZGluZ05leHRUaWNrKHNlbGYpIHtcbiAgZGVidWcoJ3JlYWRhYmxlIG5leHR0aWNrIHJlYWQgMCcpO1xuICBzZWxmLnJlYWQoMCk7XG59XG5cbi8vIHBhdXNlKCkgYW5kIHJlc3VtZSgpIGFyZSByZW1uYW50cyBvZiB0aGUgbGVnYWN5IHJlYWRhYmxlIHN0cmVhbSBBUElcbi8vIElmIHRoZSB1c2VyIHVzZXMgdGhlbSwgdGhlbiBzd2l0Y2ggaW50byBvbGQgbW9kZS5cblJlYWRhYmxlLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZScpO1xuICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgIHJlc3VtZSh0aGlzLCBzdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiByZXN1bWUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlc3VtZVNjaGVkdWxlZCkge1xuICAgIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgcHJvY2Vzc05leHRUaWNrKHJlc3VtZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3VtZV8oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICBkZWJ1ZygncmVzdW1lIHJlYWQgMCcpO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICB9XG5cbiAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG4gIHN0cmVhbS5lbWl0KCdyZXN1bWUnKTtcbiAgZmxvdyhzdHJlYW0pO1xuICBpZiAoc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUucmVhZGluZylcbiAgICBzdHJlYW0ucmVhZCgwKTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdjYWxsIHBhdXNlIGZsb3dpbmc9JWonLCB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpO1xuICBpZiAoZmFsc2UgIT09IHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwYXVzZScpO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgncGF1c2UnKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGZsb3coc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2Zsb3cnLCBzdGF0ZS5mbG93aW5nKTtcbiAgaWYgKHN0YXRlLmZsb3dpbmcpIHtcbiAgICBkbyB7XG4gICAgICB2YXIgY2h1bmsgPSBzdHJlYW0ucmVhZCgpO1xuICAgIH0gd2hpbGUgKG51bGwgIT09IGNodW5rICYmIHN0YXRlLmZsb3dpbmcpO1xuICB9XG59XG5cbi8vIHdyYXAgYW4gb2xkLXN0eWxlIHN0cmVhbSBhcyB0aGUgYXN5bmMgZGF0YSBzb3VyY2UuXG4vLyBUaGlzIGlzICpub3QqIHBhcnQgb2YgdGhlIHJlYWRhYmxlIHN0cmVhbSBpbnRlcmZhY2UuXG4vLyBJdCBpcyBhbiB1Z2x5IHVuZm9ydHVuYXRlIG1lc3Mgb2YgaGlzdG9yeS5cblJlYWRhYmxlLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24oc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBwYXVzZWQgPSBmYWxzZTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHN0cmVhbS5vbignZW5kJywgZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZW5kJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIXN0YXRlLmVuZGVkKSB7XG4gICAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aClcbiAgICAgICAgc2VsZi5wdXNoKGNodW5rKTtcbiAgICB9XG5cbiAgICBzZWxmLnB1c2gobnVsbCk7XG4gIH0pO1xuXG4gIHN0cmVhbS5vbignZGF0YScsIGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZGF0YScpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyKVxuICAgICAgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcblxuICAgIC8vIGRvbid0IHNraXAgb3ZlciBmYWxzeSB2YWx1ZXMgaW4gb2JqZWN0TW9kZVxuICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlICYmIChjaHVuayA9PT0gbnVsbCB8fCBjaHVuayA9PT0gdW5kZWZpbmVkKSlcbiAgICAgIHJldHVybjtcbiAgICBlbHNlIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiAoIWNodW5rIHx8ICFjaHVuay5sZW5ndGgpKVxuICAgICAgcmV0dXJuO1xuXG4gICAgdmFyIHJldCA9IHNlbGYucHVzaChjaHVuayk7XG4gICAgaWYgKCFyZXQpIHtcbiAgICAgIHBhdXNlZCA9IHRydWU7XG4gICAgICBzdHJlYW0ucGF1c2UoKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIHByb3h5IGFsbCB0aGUgb3RoZXIgbWV0aG9kcy5cbiAgLy8gaW1wb3J0YW50IHdoZW4gd3JhcHBpbmcgZmlsdGVycyBhbmQgZHVwbGV4ZXMuXG4gIGZvciAodmFyIGkgaW4gc3RyZWFtKSB7XG4gICAgaWYgKHRoaXNbaV0gPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygc3RyZWFtW2ldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzW2ldID0gZnVuY3Rpb24obWV0aG9kKSB7IHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHN0cmVhbVttZXRob2RdLmFwcGx5KHN0cmVhbSwgYXJndW1lbnRzKTtcbiAgICAgIH07IH0oaSk7XG4gICAgfVxuICB9XG5cbiAgLy8gcHJveHkgY2VydGFpbiBpbXBvcnRhbnQgZXZlbnRzLlxuICB2YXIgZXZlbnRzID0gWydlcnJvcicsICdjbG9zZScsICdkZXN0cm95JywgJ3BhdXNlJywgJ3Jlc3VtZSddO1xuICBmb3JFYWNoKGV2ZW50cywgZnVuY3Rpb24oZXYpIHtcbiAgICBzdHJlYW0ub24oZXYsIHNlbGYuZW1pdC5iaW5kKHNlbGYsIGV2KSk7XG4gIH0pO1xuXG4gIC8vIHdoZW4gd2UgdHJ5IHRvIGNvbnN1bWUgc29tZSBtb3JlIGJ5dGVzLCBzaW1wbHkgdW5wYXVzZSB0aGVcbiAgLy8gdW5kZXJseWluZyBzdHJlYW0uXG4gIHNlbGYuX3JlYWQgPSBmdW5jdGlvbihuKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgX3JlYWQnLCBuKTtcbiAgICBpZiAocGF1c2VkKSB7XG4gICAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5yZXN1bWUoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHNlbGY7XG59O1xuXG5cbi8vIGV4cG9zZWQgZm9yIHRlc3RpbmcgcHVycG9zZXMgb25seS5cblJlYWRhYmxlLl9mcm9tTGlzdCA9IGZyb21MaXN0O1xuXG4vLyBQbHVjayBvZmYgbiBieXRlcyBmcm9tIGFuIGFycmF5IG9mIGJ1ZmZlcnMuXG4vLyBMZW5ndGggaXMgdGhlIGNvbWJpbmVkIGxlbmd0aHMgb2YgYWxsIHRoZSBidWZmZXJzIGluIHRoZSBsaXN0LlxuZnVuY3Rpb24gZnJvbUxpc3Qobiwgc3RhdGUpIHtcbiAgdmFyIGxpc3QgPSBzdGF0ZS5idWZmZXI7XG4gIHZhciBsZW5ndGggPSBzdGF0ZS5sZW5ndGg7XG4gIHZhciBzdHJpbmdNb2RlID0gISFzdGF0ZS5kZWNvZGVyO1xuICB2YXIgb2JqZWN0TW9kZSA9ICEhc3RhdGUub2JqZWN0TW9kZTtcbiAgdmFyIHJldDtcblxuICAvLyBub3RoaW5nIGluIHRoZSBsaXN0LCBkZWZpbml0ZWx5IGVtcHR5LlxuICBpZiAobGlzdC5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuIG51bGw7XG5cbiAgaWYgKGxlbmd0aCA9PT0gMClcbiAgICByZXQgPSBudWxsO1xuICBlbHNlIGlmIChvYmplY3RNb2RlKVxuICAgIHJldCA9IGxpc3Quc2hpZnQoKTtcbiAgZWxzZSBpZiAoIW4gfHwgbiA+PSBsZW5ndGgpIHtcbiAgICAvLyByZWFkIGl0IGFsbCwgdHJ1bmNhdGUgdGhlIGFycmF5LlxuICAgIGlmIChzdHJpbmdNb2RlKVxuICAgICAgcmV0ID0gbGlzdC5qb2luKCcnKTtcbiAgICBlbHNlIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSlcbiAgICAgIHJldCA9IGxpc3RbMF07XG4gICAgZWxzZVxuICAgICAgcmV0ID0gQnVmZmVyLmNvbmNhdChsaXN0LCBsZW5ndGgpO1xuICAgIGxpc3QubGVuZ3RoID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyByZWFkIGp1c3Qgc29tZSBvZiBpdC5cbiAgICBpZiAobiA8IGxpc3RbMF0ubGVuZ3RoKSB7XG4gICAgICAvLyBqdXN0IHRha2UgYSBwYXJ0IG9mIHRoZSBmaXJzdCBsaXN0IGl0ZW0uXG4gICAgICAvLyBzbGljZSBpcyB0aGUgc2FtZSBmb3IgYnVmZmVycyBhbmQgc3RyaW5ncy5cbiAgICAgIHZhciBidWYgPSBsaXN0WzBdO1xuICAgICAgcmV0ID0gYnVmLnNsaWNlKDAsIG4pO1xuICAgICAgbGlzdFswXSA9IGJ1Zi5zbGljZShuKTtcbiAgICB9IGVsc2UgaWYgKG4gPT09IGxpc3RbMF0ubGVuZ3RoKSB7XG4gICAgICAvLyBmaXJzdCBsaXN0IGlzIGEgcGVyZmVjdCBtYXRjaFxuICAgICAgcmV0ID0gbGlzdC5zaGlmdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjb21wbGV4IGNhc2UuXG4gICAgICAvLyB3ZSBoYXZlIGVub3VnaCB0byBjb3ZlciBpdCwgYnV0IGl0IHNwYW5zIHBhc3QgdGhlIGZpcnN0IGJ1ZmZlci5cbiAgICAgIGlmIChzdHJpbmdNb2RlKVxuICAgICAgICByZXQgPSAnJztcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0ID0gbmV3IEJ1ZmZlcihuKTtcblxuICAgICAgdmFyIGMgPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGwgJiYgYyA8IG47IGkrKykge1xuICAgICAgICB2YXIgYnVmID0gbGlzdFswXTtcbiAgICAgICAgdmFyIGNweSA9IE1hdGgubWluKG4gLSBjLCBidWYubGVuZ3RoKTtcblxuICAgICAgICBpZiAoc3RyaW5nTW9kZSlcbiAgICAgICAgICByZXQgKz0gYnVmLnNsaWNlKDAsIGNweSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBidWYuY29weShyZXQsIGMsIDAsIGNweSk7XG5cbiAgICAgICAgaWYgKGNweSA8IGJ1Zi5sZW5ndGgpXG4gICAgICAgICAgbGlzdFswXSA9IGJ1Zi5zbGljZShjcHkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgbGlzdC5zaGlmdCgpO1xuXG4gICAgICAgIGMgKz0gY3B5O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG5cbiAgLy8gSWYgd2UgZ2V0IGhlcmUgYmVmb3JlIGNvbnN1bWluZyBhbGwgdGhlIGJ5dGVzLCB0aGVuIHRoYXQgaXMgYVxuICAvLyBidWcgaW4gbm9kZS4gIFNob3VsZCBuZXZlciBoYXBwZW4uXG4gIGlmIChzdGF0ZS5sZW5ndGggPiAwKVxuICAgIHRocm93IG5ldyBFcnJvcignZW5kUmVhZGFibGUgY2FsbGVkIG9uIG5vbi1lbXB0eSBzdHJlYW0nKTtcblxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gICAgcHJvY2Vzc05leHRUaWNrKGVuZFJlYWRhYmxlTlQsIHN0YXRlLCBzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlTlQoc3RhdGUsIHN0cmVhbSkge1xuICAvLyBDaGVjayB0aGF0IHdlIGRpZG4ndCBnZXQgb25lIGxhc3QgdW5zaGlmdC5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmIHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgIHN0YXRlLmVuZEVtaXR0ZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5yZWFkYWJsZSA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdlbmQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmb3JFYWNoICh4cywgZikge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGYoeHNbaV0sIGkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluZGV4T2YgKHhzLCB4KSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKHhzW2ldID09PSB4KSByZXR1cm4gaTtcbiAgfVxuICByZXR1cm4gLTE7XG59XG4iLCIvLyBhIHRyYW5zZm9ybSBzdHJlYW0gaXMgYSByZWFkYWJsZS93cml0YWJsZSBzdHJlYW0gd2hlcmUgeW91IGRvXG4vLyBzb21ldGhpbmcgd2l0aCB0aGUgZGF0YS4gIFNvbWV0aW1lcyBpdCdzIGNhbGxlZCBhIFwiZmlsdGVyXCIsXG4vLyBidXQgdGhhdCdzIG5vdCBhIGdyZWF0IG5hbWUgZm9yIGl0LCBzaW5jZSB0aGF0IGltcGxpZXMgYSB0aGluZyB3aGVyZVxuLy8gc29tZSBiaXRzIHBhc3MgdGhyb3VnaCwgYW5kIG90aGVycyBhcmUgc2ltcGx5IGlnbm9yZWQuICAoVGhhdCB3b3VsZFxuLy8gYmUgYSB2YWxpZCBleGFtcGxlIG9mIGEgdHJhbnNmb3JtLCBvZiBjb3Vyc2UuKVxuLy9cbi8vIFdoaWxlIHRoZSBvdXRwdXQgaXMgY2F1c2FsbHkgcmVsYXRlZCB0byB0aGUgaW5wdXQsIGl0J3Mgbm90IGFcbi8vIG5lY2Vzc2FyaWx5IHN5bW1ldHJpYyBvciBzeW5jaHJvbm91cyB0cmFuc2Zvcm1hdGlvbi4gIEZvciBleGFtcGxlLFxuLy8gYSB6bGliIHN0cmVhbSBtaWdodCB0YWtlIG11bHRpcGxlIHBsYWluLXRleHQgd3JpdGVzKCksIGFuZCB0aGVuXG4vLyBlbWl0IGEgc2luZ2xlIGNvbXByZXNzZWQgY2h1bmsgc29tZSB0aW1lIGluIHRoZSBmdXR1cmUuXG4vL1xuLy8gSGVyZSdzIGhvdyB0aGlzIHdvcmtzOlxuLy9cbi8vIFRoZSBUcmFuc2Zvcm0gc3RyZWFtIGhhcyBhbGwgdGhlIGFzcGVjdHMgb2YgdGhlIHJlYWRhYmxlIGFuZCB3cml0YWJsZVxuLy8gc3RyZWFtIGNsYXNzZXMuICBXaGVuIHlvdSB3cml0ZShjaHVuayksIHRoYXQgY2FsbHMgX3dyaXRlKGNodW5rLGNiKVxuLy8gaW50ZXJuYWxseSwgYW5kIHJldHVybnMgZmFsc2UgaWYgdGhlcmUncyBhIGxvdCBvZiBwZW5kaW5nIHdyaXRlc1xuLy8gYnVmZmVyZWQgdXAuICBXaGVuIHlvdSBjYWxsIHJlYWQoKSwgdGhhdCBjYWxscyBfcmVhZChuKSB1bnRpbFxuLy8gdGhlcmUncyBlbm91Z2ggcGVuZGluZyByZWFkYWJsZSBkYXRhIGJ1ZmZlcmVkIHVwLlxuLy9cbi8vIEluIGEgdHJhbnNmb3JtIHN0cmVhbSwgdGhlIHdyaXR0ZW4gZGF0YSBpcyBwbGFjZWQgaW4gYSBidWZmZXIuICBXaGVuXG4vLyBfcmVhZChuKSBpcyBjYWxsZWQsIGl0IHRyYW5zZm9ybXMgdGhlIHF1ZXVlZCB1cCBkYXRhLCBjYWxsaW5nIHRoZVxuLy8gYnVmZmVyZWQgX3dyaXRlIGNiJ3MgYXMgaXQgY29uc3VtZXMgY2h1bmtzLiAgSWYgY29uc3VtaW5nIGEgc2luZ2xlXG4vLyB3cml0dGVuIGNodW5rIHdvdWxkIHJlc3VsdCBpbiBtdWx0aXBsZSBvdXRwdXQgY2h1bmtzLCB0aGVuIHRoZSBmaXJzdFxuLy8gb3V0cHV0dGVkIGJpdCBjYWxscyB0aGUgcmVhZGNiLCBhbmQgc3Vic2VxdWVudCBjaHVua3MganVzdCBnbyBpbnRvXG4vLyB0aGUgcmVhZCBidWZmZXIsIGFuZCB3aWxsIGNhdXNlIGl0IHRvIGVtaXQgJ3JlYWRhYmxlJyBpZiBuZWNlc3NhcnkuXG4vL1xuLy8gVGhpcyB3YXksIGJhY2stcHJlc3N1cmUgaXMgYWN0dWFsbHkgZGV0ZXJtaW5lZCBieSB0aGUgcmVhZGluZyBzaWRlLFxuLy8gc2luY2UgX3JlYWQgaGFzIHRvIGJlIGNhbGxlZCB0byBzdGFydCBwcm9jZXNzaW5nIGEgbmV3IGNodW5rLiAgSG93ZXZlcixcbi8vIGEgcGF0aG9sb2dpY2FsIGluZmxhdGUgdHlwZSBvZiB0cmFuc2Zvcm0gY2FuIGNhdXNlIGV4Y2Vzc2l2ZSBidWZmZXJpbmdcbi8vIGhlcmUuICBGb3IgZXhhbXBsZSwgaW1hZ2luZSBhIHN0cmVhbSB3aGVyZSBldmVyeSBieXRlIG9mIGlucHV0IGlzXG4vLyBpbnRlcnByZXRlZCBhcyBhbiBpbnRlZ2VyIGZyb20gMC0yNTUsIGFuZCB0aGVuIHJlc3VsdHMgaW4gdGhhdCBtYW55XG4vLyBieXRlcyBvZiBvdXRwdXQuICBXcml0aW5nIHRoZSA0IGJ5dGVzIHtmZixmZixmZixmZn0gd291bGQgcmVzdWx0IGluXG4vLyAxa2Igb2YgZGF0YSBiZWluZyBvdXRwdXQuICBJbiB0aGlzIGNhc2UsIHlvdSBjb3VsZCB3cml0ZSBhIHZlcnkgc21hbGxcbi8vIGFtb3VudCBvZiBpbnB1dCwgYW5kIGVuZCB1cCB3aXRoIGEgdmVyeSBsYXJnZSBhbW91bnQgb2Ygb3V0cHV0LiAgSW5cbi8vIHN1Y2ggYSBwYXRob2xvZ2ljYWwgaW5mbGF0aW5nIG1lY2hhbmlzbSwgdGhlcmUnZCBiZSBubyB3YXkgdG8gdGVsbFxuLy8gdGhlIHN5c3RlbSB0byBzdG9wIGRvaW5nIHRoZSB0cmFuc2Zvcm0uICBBIHNpbmdsZSA0TUIgd3JpdGUgY291bGRcbi8vIGNhdXNlIHRoZSBzeXN0ZW0gdG8gcnVuIG91dCBvZiBtZW1vcnkuXG4vL1xuLy8gSG93ZXZlciwgZXZlbiBpbiBzdWNoIGEgcGF0aG9sb2dpY2FsIGNhc2UsIG9ubHkgYSBzaW5nbGUgd3JpdHRlbiBjaHVua1xuLy8gd291bGQgYmUgY29uc3VtZWQsIGFuZCB0aGVuIHRoZSByZXN0IHdvdWxkIHdhaXQgKHVuLXRyYW5zZm9ybWVkKSB1bnRpbFxuLy8gdGhlIHJlc3VsdHMgb2YgdGhlIHByZXZpb3VzIHRyYW5zZm9ybWVkIGNodW5rIHdlcmUgY29uc3VtZWQuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2Zvcm07XG5cbnZhciBEdXBsZXggPSByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudXRpbC5pbmhlcml0cyhUcmFuc2Zvcm0sIER1cGxleCk7XG5cblxuZnVuY3Rpb24gVHJhbnNmb3JtU3RhdGUoc3RyZWFtKSB7XG4gIHRoaXMuYWZ0ZXJUcmFuc2Zvcm0gPSBmdW5jdGlvbihlciwgZGF0YSkge1xuICAgIHJldHVybiBhZnRlclRyYW5zZm9ybShzdHJlYW0sIGVyLCBkYXRhKTtcbiAgfTtcblxuICB0aGlzLm5lZWRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgdGhpcy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcbiAgdGhpcy53cml0ZWNiID0gbnVsbDtcbiAgdGhpcy53cml0ZWNodW5rID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gYWZ0ZXJUcmFuc2Zvcm0oc3RyZWFtLCBlciwgZGF0YSkge1xuICB2YXIgdHMgPSBzdHJlYW0uX3RyYW5zZm9ybVN0YXRlO1xuICB0cy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcblxuICB2YXIgY2IgPSB0cy53cml0ZWNiO1xuXG4gIGlmICghY2IpXG4gICAgcmV0dXJuIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignbm8gd3JpdGVjYiBpbiBUcmFuc2Zvcm0gY2xhc3MnKSk7XG5cbiAgdHMud3JpdGVjaHVuayA9IG51bGw7XG4gIHRzLndyaXRlY2IgPSBudWxsO1xuXG4gIGlmIChkYXRhICE9PSBudWxsICYmIGRhdGEgIT09IHVuZGVmaW5lZClcbiAgICBzdHJlYW0ucHVzaChkYXRhKTtcblxuICBpZiAoY2IpXG4gICAgY2IoZXIpO1xuXG4gIHZhciBycyA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgcnMucmVhZGluZyA9IGZhbHNlO1xuICBpZiAocnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHtcbiAgICBzdHJlYW0uX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBUcmFuc2Zvcm0ob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVHJhbnNmb3JtKSlcbiAgICByZXR1cm4gbmV3IFRyYW5zZm9ybShvcHRpb25zKTtcblxuICBEdXBsZXguY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZSA9IG5ldyBUcmFuc2Zvcm1TdGF0ZSh0aGlzKTtcblxuICAvLyB3aGVuIHRoZSB3cml0YWJsZSBzaWRlIGZpbmlzaGVzLCB0aGVuIGZsdXNoIG91dCBhbnl0aGluZyByZW1haW5pbmcuXG4gIHZhciBzdHJlYW0gPSB0aGlzO1xuXG4gIC8vIHN0YXJ0IG91dCBhc2tpbmcgZm9yIGEgcmVhZGFibGUgZXZlbnQgb25jZSBkYXRhIGlzIHRyYW5zZm9ybWVkLlxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgLy8gd2UgaGF2ZSBpbXBsZW1lbnRlZCB0aGUgX3JlYWQgbWV0aG9kLCBhbmQgZG9uZSB0aGUgb3RoZXIgdGhpbmdzXG4gIC8vIHRoYXQgUmVhZGFibGUgd2FudHMgYmVmb3JlIHRoZSBmaXJzdCBfcmVhZCBjYWxsLCBzbyB1bnNldCB0aGVcbiAgLy8gc3luYyBndWFyZCBmbGFnLlxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLnN5bmMgPSBmYWxzZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50cmFuc2Zvcm0gPT09ICdmdW5jdGlvbicpXG4gICAgICB0aGlzLl90cmFuc2Zvcm0gPSBvcHRpb25zLnRyYW5zZm9ybTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5mbHVzaCA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgIHRoaXMuX2ZsdXNoID0gb3B0aW9ucy5mbHVzaDtcbiAgfVxuXG4gIHRoaXMub25jZSgncHJlZmluaXNoJywgZnVuY3Rpb24oKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLl9mbHVzaCA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgIHRoaXMuX2ZsdXNoKGZ1bmN0aW9uKGVyKSB7XG4gICAgICAgIGRvbmUoc3RyZWFtLCBlcik7XG4gICAgICB9KTtcbiAgICBlbHNlXG4gICAgICBkb25lKHN0cmVhbSk7XG4gIH0pO1xufVxuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcpIHtcbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xuICByZXR1cm4gRHVwbGV4LnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGVuY29kaW5nKTtcbn07XG5cbi8vIFRoaXMgaXMgdGhlIHBhcnQgd2hlcmUgeW91IGRvIHN0dWZmIVxuLy8gb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiBpbiBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gJ2NodW5rJyBpcyBhbiBpbnB1dCBjaHVuay5cbi8vXG4vLyBDYWxsIGBwdXNoKG5ld0NodW5rKWAgdG8gcGFzcyBhbG9uZyB0cmFuc2Zvcm1lZCBvdXRwdXRcbi8vIHRvIHRoZSByZWFkYWJsZSBzaWRlLiAgWW91IG1heSBjYWxsICdwdXNoJyB6ZXJvIG9yIG1vcmUgdGltZXMuXG4vL1xuLy8gQ2FsbCBgY2IoZXJyKWAgd2hlbiB5b3UgYXJlIGRvbmUgd2l0aCB0aGlzIGNodW5rLiAgSWYgeW91IHBhc3Ncbi8vIGFuIGVycm9yLCB0aGVuIHRoYXQnbGwgcHV0IHRoZSBodXJ0IG9uIHRoZSB3aG9sZSBvcGVyYXRpb24uICBJZiB5b3Vcbi8vIG5ldmVyIGNhbGwgY2IoKSwgdGhlbiB5b3UnbGwgbmV2ZXIgZ2V0IGFub3RoZXIgY2h1bmsuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJyk7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLndyaXRlY2IgPSBjYjtcbiAgdHMud3JpdGVjaHVuayA9IGNodW5rO1xuICB0cy53cml0ZWVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIGlmICghdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAodHMubmVlZFRyYW5zZm9ybSB8fFxuICAgICAgICBycy5uZWVkUmVhZGFibGUgfHxcbiAgICAgICAgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaylcbiAgICAgIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn07XG5cbi8vIERvZXNuJ3QgbWF0dGVyIHdoYXQgdGhlIGFyZ3MgYXJlIGhlcmUuXG4vLyBfdHJhbnNmb3JtIGRvZXMgYWxsIHRoZSB3b3JrLlxuLy8gVGhhdCB3ZSBnb3QgaGVyZSBtZWFucyB0aGF0IHRoZSByZWFkYWJsZSBzaWRlIHdhbnRzIG1vcmUgZGF0YS5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbihuKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuXG4gIGlmICh0cy53cml0ZWNodW5rICE9PSBudWxsICYmIHRzLndyaXRlY2IgJiYgIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHRzLnRyYW5zZm9ybWluZyA9IHRydWU7XG4gICAgdGhpcy5fdHJhbnNmb3JtKHRzLndyaXRlY2h1bmssIHRzLndyaXRlZW5jb2RpbmcsIHRzLmFmdGVyVHJhbnNmb3JtKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBtYXJrIHRoYXQgd2UgbmVlZCBhIHRyYW5zZm9ybSwgc28gdGhhdCBhbnkgZGF0YSB0aGF0IGNvbWVzIGluXG4gICAgLy8gd2lsbCBnZXQgcHJvY2Vzc2VkLCBub3cgdGhhdCB3ZSd2ZSBhc2tlZCBmb3IgaXQuXG4gICAgdHMubmVlZFRyYW5zZm9ybSA9IHRydWU7XG4gIH1cbn07XG5cblxuZnVuY3Rpb24gZG9uZShzdHJlYW0sIGVyKSB7XG4gIGlmIChlcilcbiAgICByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuXG4gIC8vIGlmIHRoZXJlJ3Mgbm90aGluZyBpbiB0aGUgd3JpdGUgYnVmZmVyLCB0aGVuIHRoYXQgbWVhbnNcbiAgLy8gdGhhdCBub3RoaW5nIG1vcmUgd2lsbCBldmVyIGJlIHByb3ZpZGVkXG4gIHZhciB3cyA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHRzID0gc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZTtcblxuICBpZiAod3MubGVuZ3RoKVxuICAgIHRocm93IG5ldyBFcnJvcignY2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHdzLmxlbmd0aCAhPSAwJyk7XG5cbiAgaWYgKHRzLnRyYW5zZm9ybWluZylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiBzdGlsbCB0cmFuc2Zvcm1pbmcnKTtcblxuICByZXR1cm4gc3RyZWFtLnB1c2gobnVsbCk7XG59XG4iLCIvLyBBIGJpdCBzaW1wbGVyIHRoYW4gcmVhZGFibGUgc3RyZWFtcy5cbi8vIEltcGxlbWVudCBhbiBhc3luYyAuX3dyaXRlKGNodW5rLCBlbmNvZGluZywgY2IpLCBhbmQgaXQnbGwgaGFuZGxlIGFsbFxuLy8gdGhlIGRyYWluIGV2ZW50IGVtaXNzaW9uIGFuZCBidWZmZXJpbmcuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBXcml0YWJsZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBwcm9jZXNzTmV4dFRpY2sgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuV3JpdGFibGUuV3JpdGFibGVTdGF0ZSA9IFdyaXRhYmxlU3RhdGU7XG5cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgaW50ZXJuYWxVdGlsID0ge1xuICBkZXByZWNhdGU6IHJlcXVpcmUoJ3V0aWwtZGVwcmVjYXRlJylcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgU3RyZWFtO1xuKGZ1bmN0aW9uICgpe3RyeXtcbiAgU3RyZWFtID0gcmVxdWlyZSgnc3QnICsgJ3JlYW0nKTtcbn1jYXRjaChfKXt9ZmluYWxseXtcbiAgaWYgKCFTdHJlYW0pXG4gICAgU3RyZWFtID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xufX0oKSlcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuXG51dGlsLmluaGVyaXRzKFdyaXRhYmxlLCBTdHJlYW0pO1xuXG5mdW5jdGlvbiBub3AoKSB7fVxuXG5mdW5jdGlvbiBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRoaXMuY2h1bmsgPSBjaHVuaztcbiAgdGhpcy5lbmNvZGluZyA9IGVuY29kaW5nO1xuICB0aGlzLmNhbGxiYWNrID0gY2I7XG4gIHRoaXMubmV4dCA9IG51bGw7XG59XG5cbnZhciBEdXBsZXg7XG5mdW5jdGlvbiBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZyB0byBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGlzIHN0cmVhbVxuICAvLyBjb250YWlucyBidWZmZXJzIG9yIG9iamVjdHMuXG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIGlmIChzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXgpXG4gICAgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy53cml0YWJsZU9iamVjdE1vZGU7XG5cbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIHdyaXRlKCkgc3RhcnRzIHJldHVybmluZyBmYWxzZVxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIHRoYXQgd2UgYWx3YXlzIHJldHVybiBmYWxzZSBpZlxuICAvLyB0aGUgZW50aXJlIGJ1ZmZlciBpcyBub3QgZmx1c2hlZCBpbW1lZGlhdGVseSBvbiB3cml0ZSgpXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIHZhciBkZWZhdWx0SHdtID0gdGhpcy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IChod20gfHwgaHdtID09PSAwKSA/IGh3bSA6IGRlZmF1bHRId207XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSB+fnRoaXMuaGlnaFdhdGVyTWFyaztcblxuICB0aGlzLm5lZWREcmFpbiA9IGZhbHNlO1xuICAvLyBhdCB0aGUgc3RhcnQgb2YgY2FsbGluZyBlbmQoKVxuICB0aGlzLmVuZGluZyA9IGZhbHNlO1xuICAvLyB3aGVuIGVuZCgpIGhhcyBiZWVuIGNhbGxlZCwgYW5kIHJldHVybmVkXG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgLy8gd2hlbiAnZmluaXNoJyBpcyBlbWl0dGVkXG4gIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBzaG91bGQgd2UgZGVjb2RlIHN0cmluZ3MgaW50byBidWZmZXJzIGJlZm9yZSBwYXNzaW5nIHRvIF93cml0ZT9cbiAgLy8gdGhpcyBpcyBoZXJlIHNvIHRoYXQgc29tZSBub2RlLWNvcmUgc3RyZWFtcyBjYW4gb3B0aW1pemUgc3RyaW5nXG4gIC8vIGhhbmRsaW5nIGF0IGEgbG93ZXIgbGV2ZWwuXG4gIHZhciBub0RlY29kZSA9IG9wdGlvbnMuZGVjb2RlU3RyaW5ncyA9PT0gZmFsc2U7XG4gIHRoaXMuZGVjb2RlU3RyaW5ncyA9ICFub0RlY29kZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyBub3QgYW4gYWN0dWFsIGJ1ZmZlciB3ZSBrZWVwIHRyYWNrIG9mLCBidXQgYSBtZWFzdXJlbWVudFxuICAvLyBvZiBob3cgbXVjaCB3ZSdyZSB3YWl0aW5nIHRvIGdldCBwdXNoZWQgdG8gc29tZSB1bmRlcmx5aW5nXG4gIC8vIHNvY2tldCBvciBmaWxlLlxuICB0aGlzLmxlbmd0aCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIHNlZSB3aGVuIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgYSB3cml0ZS5cbiAgdGhpcy53cml0aW5nID0gZmFsc2U7XG5cbiAgLy8gd2hlbiB0cnVlIGFsbCB3cml0ZXMgd2lsbCBiZSBidWZmZXJlZCB1bnRpbCAudW5jb3JrKCkgY2FsbFxuICB0aGlzLmNvcmtlZCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2UgYW55XG4gIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gYSBmbGFnIHRvIGtub3cgaWYgd2UncmUgcHJvY2Vzc2luZyBwcmV2aW91c2x5IGJ1ZmZlcmVkIGl0ZW1zLCB3aGljaFxuICAvLyBtYXkgY2FsbCB0aGUgX3dyaXRlKCkgY2FsbGJhY2sgaW4gdGhlIHNhbWUgdGljaywgc28gdGhhdCB3ZSBkb24ndFxuICAvLyBlbmQgdXAgaW4gYW4gb3ZlcmxhcHBlZCBvbndyaXRlIHNpdHVhdGlvbi5cbiAgdGhpcy5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQncyBwYXNzZWQgdG8gX3dyaXRlKGNodW5rLGNiKVxuICB0aGlzLm9ud3JpdGUgPSBmdW5jdGlvbihlcikge1xuICAgIG9ud3JpdGUoc3RyZWFtLCBlcik7XG4gIH07XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQgdGhlIHVzZXIgc3VwcGxpZXMgdG8gd3JpdGUoY2h1bmssZW5jb2RpbmcsY2IpXG4gIHRoaXMud3JpdGVjYiA9IG51bGw7XG5cbiAgLy8gdGhlIGFtb3VudCB0aGF0IGlzIGJlaW5nIHdyaXR0ZW4gd2hlbiBfd3JpdGUgaXMgY2FsbGVkLlxuICB0aGlzLndyaXRlbGVuID0gMDtcblxuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gIHRoaXMubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG5cbiAgLy8gbnVtYmVyIG9mIHBlbmRpbmcgdXNlci1zdXBwbGllZCB3cml0ZSBjYWxsYmFja3NcbiAgLy8gdGhpcyBtdXN0IGJlIDAgYmVmb3JlICdmaW5pc2gnIGNhbiBiZSBlbWl0dGVkXG4gIHRoaXMucGVuZGluZ2NiID0gMDtcblxuICAvLyBlbWl0IHByZWZpbmlzaCBpZiB0aGUgb25seSB0aGluZyB3ZSdyZSB3YWl0aW5nIGZvciBpcyBfd3JpdGUgY2JzXG4gIC8vIFRoaXMgaXMgcmVsZXZhbnQgZm9yIHN5bmNocm9ub3VzIFRyYW5zZm9ybSBzdHJlYW1zXG4gIHRoaXMucHJlZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBUcnVlIGlmIHRoZSBlcnJvciB3YXMgYWxyZWFkeSBlbWl0dGVkIGFuZCBzaG91bGQgbm90IGJlIHRocm93biBhZ2FpblxuICB0aGlzLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xufVxuXG5Xcml0YWJsZVN0YXRlLnByb3RvdHlwZS5nZXRCdWZmZXIgPSBmdW5jdGlvbiB3cml0YWJsZVN0YXRlR2V0QnVmZmVyKCkge1xuICB2YXIgY3VycmVudCA9IHRoaXMuYnVmZmVyZWRSZXF1ZXN0O1xuICB2YXIgb3V0ID0gW107XG4gIHdoaWxlIChjdXJyZW50KSB7XG4gICAgb3V0LnB1c2goY3VycmVudCk7XG4gICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgfVxuICByZXR1cm4gb3V0O1xufTtcblxuKGZ1bmN0aW9uICgpe3RyeSB7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUsICdidWZmZXInLCB7XG4gIGdldDogaW50ZXJuYWxVdGlsLmRlcHJlY2F0ZShmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRCdWZmZXIoKTtcbiAgfSwgJ193cml0YWJsZVN0YXRlLmJ1ZmZlciBpcyBkZXByZWNhdGVkLiBVc2UgX3dyaXRhYmxlU3RhdGUuZ2V0QnVmZmVyICcgK1xuICAgICAnaW5zdGVhZC4nKVxufSk7XG59Y2F0Y2goXyl7fX0oKSk7XG5cblxudmFyIER1cGxleDtcbmZ1bmN0aW9uIFdyaXRhYmxlKG9wdGlvbnMpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICAvLyBXcml0YWJsZSBjdG9yIGlzIGFwcGxpZWQgdG8gRHVwbGV4ZXMsIHRob3VnaCB0aGV5J3JlIG5vdFxuICAvLyBpbnN0YW5jZW9mIFdyaXRhYmxlLCB0aGV5J3JlIGluc3RhbmNlb2YgUmVhZGFibGUuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBXcml0YWJsZSkgJiYgISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSlcbiAgICByZXR1cm4gbmV3IFdyaXRhYmxlKG9wdGlvbnMpO1xuXG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUgPSBuZXcgV3JpdGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyBsZWdhY3kuXG4gIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRlID09PSAnZnVuY3Rpb24nKVxuICAgICAgdGhpcy5fd3JpdGUgPSBvcHRpb25zLndyaXRlO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRldiA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgIHRoaXMuX3dyaXRldiA9IG9wdGlvbnMud3JpdGV2O1xuICB9XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbi8vIE90aGVyd2lzZSBwZW9wbGUgY2FuIHBpcGUgV3JpdGFibGUgc3RyZWFtcywgd2hpY2ggaXMganVzdCB3cm9uZy5cbldyaXRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0Nhbm5vdCBwaXBlLiBOb3QgcmVhZGFibGUuJykpO1xufTtcblxuXG5mdW5jdGlvbiB3cml0ZUFmdGVyRW5kKHN0cmVhbSwgY2IpIHtcbiAgdmFyIGVyID0gbmV3IEVycm9yKCd3cml0ZSBhZnRlciBlbmQnKTtcbiAgLy8gVE9ETzogZGVmZXIgZXJyb3IgZXZlbnRzIGNvbnNpc3RlbnRseSBldmVyeXdoZXJlLCBub3QganVzdCB0aGUgY2JcbiAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICBwcm9jZXNzTmV4dFRpY2soY2IsIGVyKTtcbn1cblxuLy8gSWYgd2UgZ2V0IHNvbWV0aGluZyB0aGF0IGlzIG5vdCBhIGJ1ZmZlciwgc3RyaW5nLCBudWxsLCBvciB1bmRlZmluZWQsXG4vLyBhbmQgd2UncmUgbm90IGluIG9iamVjdE1vZGUsIHRoZW4gdGhhdCdzIGFuIGVycm9yLlxuLy8gT3RoZXJ3aXNlIHN0cmVhbSBjaHVua3MgYXJlIGFsbCBjb25zaWRlcmVkIHRvIGJlIG9mIGxlbmd0aD0xLCBhbmQgdGhlXG4vLyB3YXRlcm1hcmtzIGRldGVybWluZSBob3cgbWFueSBvYmplY3RzIHRvIGtlZXAgaW4gdGhlIGJ1ZmZlciwgcmF0aGVyIHRoYW5cbi8vIGhvdyBtYW55IGJ5dGVzIG9yIGNoYXJhY3RlcnMuXG5mdW5jdGlvbiB2YWxpZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBjYikge1xuICB2YXIgdmFsaWQgPSB0cnVlO1xuXG4gIGlmICghKEJ1ZmZlci5pc0J1ZmZlcihjaHVuaykpICYmXG4gICAgICB0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmXG4gICAgICBjaHVuayAhPT0gbnVsbCAmJlxuICAgICAgY2h1bmsgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICB2YXIgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIHByb2Nlc3NOZXh0VGljayhjYiwgZXIpO1xuICAgIHZhbGlkID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHZhbGlkO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG4gIHZhciByZXQgPSBmYWxzZTtcblxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGNodW5rKSlcbiAgICBlbmNvZGluZyA9ICdidWZmZXInO1xuICBlbHNlIGlmICghZW5jb2RpbmcpXG4gICAgZW5jb2RpbmcgPSBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG5cbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJylcbiAgICBjYiA9IG5vcDtcblxuICBpZiAoc3RhdGUuZW5kZWQpXG4gICAgd3JpdGVBZnRlckVuZCh0aGlzLCBjYik7XG4gIGVsc2UgaWYgKHZhbGlkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBjYikpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICByZXQgPSB3cml0ZU9yQnVmZmVyKHRoaXMsIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuY29yayA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIHN0YXRlLmNvcmtlZCsrO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnVuY29yayA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQtLTtcblxuICAgIGlmICghc3RhdGUud3JpdGluZyAmJlxuICAgICAgICAhc3RhdGUuY29ya2VkICYmXG4gICAgICAgICFzdGF0ZS5maW5pc2hlZCAmJlxuICAgICAgICAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJlxuICAgICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpXG4gICAgICBjbGVhckJ1ZmZlcih0aGlzLCBzdGF0ZSk7XG4gIH1cbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5zZXREZWZhdWx0RW5jb2RpbmcgPSBmdW5jdGlvbiBzZXREZWZhdWx0RW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgLy8gbm9kZTo6UGFyc2VFbmNvZGluZygpIHJlcXVpcmVzIGxvd2VyIGNhc2UuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKVxuICAgIGVuY29kaW5nID0gZW5jb2RpbmcudG9Mb3dlckNhc2UoKTtcbiAgaWYgKCEoWydoZXgnLCAndXRmOCcsICd1dGYtOCcsICdhc2NpaScsICdiaW5hcnknLCAnYmFzZTY0Jyxcbid1Y3MyJywgJ3Vjcy0yJywndXRmMTZsZScsICd1dGYtMTZsZScsICdyYXcnXVxuLmluZGV4T2YoKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKCkpID4gLTEpKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZyk7XG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVmYXVsdEVuY29kaW5nID0gZW5jb2Rpbmc7XG59O1xuXG5mdW5jdGlvbiBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKSB7XG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJlxuICAgICAgc3RhdGUuZGVjb2RlU3RyaW5ncyAhPT0gZmFsc2UgJiZcbiAgICAgIHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICBjaHVuayA9IG5ldyBCdWZmZXIoY2h1bmssIGVuY29kaW5nKTtcbiAgfVxuICByZXR1cm4gY2h1bms7XG59XG5cbi8vIGlmIHdlJ3JlIGFscmVhZHkgd3JpdGluZyBzb21ldGhpbmcsIHRoZW4ganVzdCBwdXQgdGhpc1xuLy8gaW4gdGhlIHF1ZXVlLCBhbmQgd2FpdCBvdXIgdHVybi4gIE90aGVyd2lzZSwgY2FsbCBfd3JpdGVcbi8vIElmIHdlIHJldHVybiBmYWxzZSwgdGhlbiB3ZSBuZWVkIGEgZHJhaW4gZXZlbnQsIHNvIHNldCB0aGF0IGZsYWcuXG5mdW5jdGlvbiB3cml0ZU9yQnVmZmVyKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2h1bmsgPSBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKTtcblxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGNodW5rKSlcbiAgICBlbmNvZGluZyA9ICdidWZmZXInO1xuICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgc3RhdGUubGVuZ3RoICs9IGxlbjtcblxuICB2YXIgcmV0ID0gc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgLy8gd2UgbXVzdCBlbnN1cmUgdGhhdCBwcmV2aW91cyBuZWVkRHJhaW4gd2lsbCBub3QgYmUgcmVzZXQgdG8gZmFsc2UuXG4gIGlmICghcmV0KVxuICAgIHN0YXRlLm5lZWREcmFpbiA9IHRydWU7XG5cbiAgaWYgKHN0YXRlLndyaXRpbmcgfHwgc3RhdGUuY29ya2VkKSB7XG4gICAgdmFyIGxhc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBuZXcgV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYik7XG4gICAgaWYgKGxhc3QpIHtcbiAgICAgIGxhc3QubmV4dCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHdyaXRldiwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHN0YXRlLndyaXRlbGVuID0gbGVuO1xuICBzdGF0ZS53cml0ZWNiID0gY2I7XG4gIHN0YXRlLndyaXRpbmcgPSB0cnVlO1xuICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgaWYgKHdyaXRldilcbiAgICBzdHJlYW0uX3dyaXRldihjaHVuaywgc3RhdGUub253cml0ZSk7XG4gIGVsc2VcbiAgICBzdHJlYW0uX3dyaXRlKGNodW5rLCBlbmNvZGluZywgc3RhdGUub253cml0ZSk7XG4gIHN0YXRlLnN5bmMgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYikge1xuICAtLXN0YXRlLnBlbmRpbmdjYjtcbiAgaWYgKHN5bmMpXG4gICAgcHJvY2Vzc05leHRUaWNrKGNiLCBlcik7XG4gIGVsc2VcbiAgICBjYihlcik7XG5cbiAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbn1cblxuZnVuY3Rpb24gb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKSB7XG4gIHN0YXRlLndyaXRpbmcgPSBmYWxzZTtcbiAgc3RhdGUud3JpdGVjYiA9IG51bGw7XG4gIHN0YXRlLmxlbmd0aCAtPSBzdGF0ZS53cml0ZWxlbjtcbiAgc3RhdGUud3JpdGVsZW4gPSAwO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlKHN0cmVhbSwgZXIpIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgc3luYyA9IHN0YXRlLnN5bmM7XG4gIHZhciBjYiA9IHN0YXRlLndyaXRlY2I7XG5cbiAgb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKTtcblxuICBpZiAoZXIpXG4gICAgb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYik7XG4gIGVsc2Uge1xuICAgIC8vIENoZWNrIGlmIHdlJ3JlIGFjdHVhbGx5IHJlYWR5IHRvIGZpbmlzaCwgYnV0IGRvbid0IGVtaXQgeWV0XG4gICAgdmFyIGZpbmlzaGVkID0gbmVlZEZpbmlzaChzdGF0ZSk7XG5cbiAgICBpZiAoIWZpbmlzaGVkICYmXG4gICAgICAgICFzdGF0ZS5jb3JrZWQgJiZcbiAgICAgICAgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiZcbiAgICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSB7XG4gICAgICBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoc3luYykge1xuICAgICAgcHJvY2Vzc05leHRUaWNrKGFmdGVyV3JpdGUsIHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpIHtcbiAgaWYgKCFmaW5pc2hlZClcbiAgICBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSk7XG4gIHN0YXRlLnBlbmRpbmdjYi0tO1xuICBjYigpO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbn1cblxuLy8gTXVzdCBmb3JjZSBjYWxsYmFjayB0byBiZSBjYWxsZWQgb24gbmV4dFRpY2ssIHNvIHRoYXQgd2UgZG9uJ3Rcbi8vIGVtaXQgJ2RyYWluJyBiZWZvcmUgdGhlIHdyaXRlKCkgY29uc3VtZXIgZ2V0cyB0aGUgJ2ZhbHNlJyByZXR1cm5cbi8vIHZhbHVlLCBhbmQgaGFzIGEgY2hhbmNlIHRvIGF0dGFjaCBhICdkcmFpbicgbGlzdGVuZXIuXG5mdW5jdGlvbiBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLm5lZWREcmFpbikge1xuICAgIHN0YXRlLm5lZWREcmFpbiA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdkcmFpbicpO1xuICB9XG59XG5cblxuLy8gaWYgdGhlcmUncyBzb21ldGhpbmcgaW4gdGhlIGJ1ZmZlciB3YWl0aW5nLCB0aGVuIHByb2Nlc3MgaXRcbmZ1bmN0aW9uIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IHRydWU7XG4gIHZhciBlbnRyeSA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdDtcblxuICBpZiAoc3RyZWFtLl93cml0ZXYgJiYgZW50cnkgJiYgZW50cnkubmV4dCkge1xuICAgIC8vIEZhc3QgY2FzZSwgd3JpdGUgZXZlcnl0aGluZyB1c2luZyBfd3JpdGV2KClcbiAgICB2YXIgYnVmZmVyID0gW107XG4gICAgdmFyIGNicyA9IFtdO1xuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgY2JzLnB1c2goZW50cnkuY2FsbGJhY2spO1xuICAgICAgYnVmZmVyLnB1c2goZW50cnkpO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgIH1cblxuICAgIC8vIGNvdW50IHRoZSBvbmUgd2UgYXJlIGFkZGluZywgYXMgd2VsbC5cbiAgICAvLyBUT0RPKGlzYWFjcykgY2xlYW4gdGhpcyB1cFxuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgdHJ1ZSwgc3RhdGUubGVuZ3RoLCBidWZmZXIsICcnLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuICAgICAgICBjYnNbaV0oZXJyKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIENsZWFyIGJ1ZmZlclxuICB9IGVsc2Uge1xuICAgIC8vIFNsb3cgY2FzZSwgd3JpdGUgY2h1bmtzIG9uZS1ieS1vbmVcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIHZhciBjaHVuayA9IGVudHJ5LmNodW5rO1xuICAgICAgdmFyIGVuY29kaW5nID0gZW50cnkuZW5jb2Rpbmc7XG4gICAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICAgIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcblxuICAgICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgIC8vIGlmIHdlIGRpZG4ndCBjYWxsIHRoZSBvbndyaXRlIGltbWVkaWF0ZWx5LCB0aGVuXG4gICAgICAvLyBpdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gd2FpdCB1bnRpbCBpdCBkb2VzLlxuICAgICAgLy8gYWxzbywgdGhhdCBtZWFucyB0aGF0IHRoZSBjaHVuayBhbmQgY2IgYXJlIGN1cnJlbnRseVxuICAgICAgLy8gYmVpbmcgcHJvY2Vzc2VkLCBzbyBtb3ZlIHRoZSBidWZmZXIgY291bnRlciBwYXN0IHRoZW0uXG4gICAgICBpZiAoc3RhdGUud3JpdGluZykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZW50cnkgPT09IG51bGwpXG4gICAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgfVxuICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBlbnRyeTtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpKTtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGV2ID0gbnVsbDtcblxuV3JpdGFibGUucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAodHlwZW9mIGNodW5rID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBjaHVuaztcbiAgICBjaHVuayA9IG51bGw7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGNodW5rICE9PSBudWxsICYmIGNodW5rICE9PSB1bmRlZmluZWQpXG4gICAgdGhpcy53cml0ZShjaHVuaywgZW5jb2RpbmcpO1xuXG4gIC8vIC5lbmQoKSBmdWxseSB1bmNvcmtzXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQgPSAxO1xuICAgIHRoaXMudW5jb3JrKCk7XG4gIH1cblxuICAvLyBpZ25vcmUgdW5uZWNlc3NhcnkgZW5kKCkgY2FsbHMuXG4gIGlmICghc3RhdGUuZW5kaW5nICYmICFzdGF0ZS5maW5pc2hlZClcbiAgICBlbmRXcml0YWJsZSh0aGlzLCBzdGF0ZSwgY2IpO1xufTtcblxuXG5mdW5jdGlvbiBuZWVkRmluaXNoKHN0YXRlKSB7XG4gIHJldHVybiAoc3RhdGUuZW5kaW5nICYmXG4gICAgICAgICAgc3RhdGUubGVuZ3RoID09PSAwICYmXG4gICAgICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID09PSBudWxsICYmXG4gICAgICAgICAgIXN0YXRlLmZpbmlzaGVkICYmXG4gICAgICAgICAgIXN0YXRlLndyaXRpbmcpO1xufVxuXG5mdW5jdGlvbiBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnByZWZpbmlzaGVkKSB7XG4gICAgc3RhdGUucHJlZmluaXNoZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBuZWVkID0gbmVlZEZpbmlzaChzdGF0ZSk7XG4gIGlmIChuZWVkKSB7XG4gICAgaWYgKHN0YXRlLnBlbmRpbmdjYiA9PT0gMCkge1xuICAgICAgcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgc3RhdGUuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLmVtaXQoJ2ZpbmlzaCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZWVkO1xufVxuXG5mdW5jdGlvbiBlbmRXcml0YWJsZShzdHJlYW0sIHN0YXRlLCBjYikge1xuICBzdGF0ZS5lbmRpbmcgPSB0cnVlO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgaWYgKGNiKSB7XG4gICAgaWYgKHN0YXRlLmZpbmlzaGVkKVxuICAgICAgcHJvY2Vzc05leHRUaWNrKGNiKTtcbiAgICBlbHNlXG4gICAgICBzdHJlYW0ub25jZSgnZmluaXNoJywgY2IpO1xuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbn1cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxuXG5mdW5jdGlvbiBpc0FycmF5KGFyZykge1xuICBpZiAoQXJyYXkuaXNBcnJheSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGFyZyk7XG4gIH1cbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKGFyZykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbmV4cG9ydHMuaXNCdWZmZXIgPSBCdWZmZXIuaXNCdWZmZXI7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaWYgKCFwcm9jZXNzLnZlcnNpb24gfHxcbiAgICBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjAuJykgPT09IDAgfHxcbiAgICBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjEuJykgPT09IDAgJiYgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YxLjguJykgIT09IDApIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBuZXh0VGljaztcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcHJvY2Vzcy5uZXh0VGljaztcbn1cblxuZnVuY3Rpb24gbmV4dFRpY2soZm4pIHtcbiAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICB2YXIgaSA9IDA7XG4gIHdoaWxlIChpIDwgYXJncy5sZW5ndGgpIHtcbiAgICBhcmdzW2krK10gPSBhcmd1bWVudHNbaV07XG4gIH1cbiAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2soKSB7XG4gICAgZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gIH0pO1xufVxuIiwiXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZGVwcmVjYXRlO1xuXG4vKipcbiAqIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4gKiBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2Uubm9EZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2UudGhyb3dEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9uc1xuICogd2lsbCB0aHJvdyBhbiBFcnJvciB3aGVuIGludm9rZWQuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS50cmFjZURlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGRlcHJlY2F0ZWQgZnVuY3Rpb25zXG4gKiB3aWxsIGludm9rZSBgY29uc29sZS50cmFjZSgpYCBpbnN0ZWFkIG9mIGBjb25zb2xlLmVycm9yKClgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gdGhlIGZ1bmN0aW9uIHRvIGRlcHJlY2F0ZVxuICogQHBhcmFtIHtTdHJpbmd9IG1zZyAtIHRoZSBzdHJpbmcgdG8gcHJpbnQgdG8gdGhlIGNvbnNvbGUgd2hlbiBgZm5gIGlzIGludm9rZWRcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gYSBuZXcgXCJkZXByZWNhdGVkXCIgdmVyc2lvbiBvZiBgZm5gXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRlcHJlY2F0ZSAoZm4sIG1zZykge1xuICBpZiAoY29uZmlnKCdub0RlcHJlY2F0aW9uJykpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChjb25maWcoJ3Rocm93RGVwcmVjYXRpb24nKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAoY29uZmlnKCd0cmFjZURlcHJlY2F0aW9uJykpIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufVxuXG4vKipcbiAqIENoZWNrcyBgbG9jYWxTdG9yYWdlYCBmb3IgYm9vbGVhbiB2YWx1ZXMgZm9yIHRoZSBnaXZlbiBgbmFtZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29uZmlnIChuYW1lKSB7XG4gIC8vIGFjY2Vzc2luZyBnbG9iYWwubG9jYWxTdG9yYWdlIGNhbiB0cmlnZ2VyIGEgRE9NRXhjZXB0aW9uIGluIHNhbmRib3hlZCBpZnJhbWVzXG4gIHRyeSB7XG4gICAgaWYgKCFnbG9iYWwubG9jYWxTdG9yYWdlKSByZXR1cm4gZmFsc2U7XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHZhbCA9IGdsb2JhbC5sb2NhbFN0b3JhZ2VbbmFtZV07XG4gIGlmIChudWxsID09IHZhbCkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gU3RyaW5nKHZhbCkudG9Mb3dlckNhc2UoKSA9PT0gJ3RydWUnO1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qc1wiKVxuIiwidmFyIFN0cmVhbSA9IChmdW5jdGlvbiAoKXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gcmVxdWlyZSgnc3QnICsgJ3JlYW0nKTsgLy8gaGFjayB0byBmaXggYSBjaXJjdWxhciBkZXBlbmRlbmN5IGlzc3VlIHdoZW4gdXNlZCB3aXRoIGJyb3dzZXJpZnlcbiAgfSBjYXRjaChfKXt9XG59KCkpO1xuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcycpO1xuZXhwb3J0cy5TdHJlYW0gPSBTdHJlYW0gfHwgZXhwb3J0cztcbmV4cG9ydHMuUmVhZGFibGUgPSBleHBvcnRzO1xuZXhwb3J0cy5Xcml0YWJsZSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fd3JpdGFibGUuanMnKTtcbmV4cG9ydHMuRHVwbGV4ID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9kdXBsZXguanMnKTtcbmV4cG9ydHMuVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMnKTtcbmV4cG9ydHMuUGFzc1Rocm91Z2ggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzJyk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qc1wiKVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9saWIvX3N0cmVhbV93cml0YWJsZS5qc1wiKVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbm1vZHVsZS5leHBvcnRzID0gU3RyZWFtO1xuXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5pbmhlcml0cyhTdHJlYW0sIEVFKTtcblN0cmVhbS5SZWFkYWJsZSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9yZWFkYWJsZS5qcycpO1xuU3RyZWFtLldyaXRhYmxlID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3dyaXRhYmxlLmpzJyk7XG5TdHJlYW0uRHVwbGV4ID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL2R1cGxleC5qcycpO1xuU3RyZWFtLlRyYW5zZm9ybSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS90cmFuc2Zvcm0uanMnKTtcblN0cmVhbS5QYXNzVGhyb3VnaCA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9wYXNzdGhyb3VnaC5qcycpO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjQueFxuU3RyZWFtLlN0cmVhbSA9IFN0cmVhbTtcblxuXG5cbi8vIG9sZC1zdHlsZSBzdHJlYW1zLiAgTm90ZSB0aGF0IHRoZSBwaXBlIG1ldGhvZCAodGhlIG9ubHkgcmVsZXZhbnRcbi8vIHBhcnQgb2YgdGhpcyBjbGFzcykgaXMgb3ZlcnJpZGRlbiBpbiB0aGUgUmVhZGFibGUgY2xhc3MuXG5cbmZ1bmN0aW9uIFN0cmVhbSgpIHtcbiAgRUUuY2FsbCh0aGlzKTtcbn1cblxuU3RyZWFtLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24oZGVzdCwgb3B0aW9ucykge1xuICB2YXIgc291cmNlID0gdGhpcztcblxuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcbiAgICBpZiAoZGVzdC53cml0YWJsZSkge1xuICAgICAgaWYgKGZhbHNlID09PSBkZXN0LndyaXRlKGNodW5rKSAmJiBzb3VyY2UucGF1c2UpIHtcbiAgICAgICAgc291cmNlLnBhdXNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc291cmNlLm9uKCdkYXRhJywgb25kYXRhKTtcblxuICBmdW5jdGlvbiBvbmRyYWluKCkge1xuICAgIGlmIChzb3VyY2UucmVhZGFibGUgJiYgc291cmNlLnJlc3VtZSkge1xuICAgICAgc291cmNlLnJlc3VtZSgpO1xuICAgIH1cbiAgfVxuXG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XG5cbiAgLy8gSWYgdGhlICdlbmQnIG9wdGlvbiBpcyBub3Qgc3VwcGxpZWQsIGRlc3QuZW5kKCkgd2lsbCBiZSBjYWxsZWQgd2hlblxuICAvLyBzb3VyY2UgZ2V0cyB0aGUgJ2VuZCcgb3IgJ2Nsb3NlJyBldmVudHMuICBPbmx5IGRlc3QuZW5kKCkgb25jZS5cbiAgaWYgKCFkZXN0Ll9pc1N0ZGlvICYmICghb3B0aW9ucyB8fCBvcHRpb25zLmVuZCAhPT0gZmFsc2UpKSB7XG4gICAgc291cmNlLm9uKCdlbmQnLCBvbmVuZCk7XG4gICAgc291cmNlLm9uKCdjbG9zZScsIG9uY2xvc2UpO1xuICB9XG5cbiAgdmFyIGRpZE9uRW5kID0gZmFsc2U7XG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGlmIChkaWRPbkVuZCkgcmV0dXJuO1xuICAgIGRpZE9uRW5kID0gdHJ1ZTtcblxuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgaWYgKGRpZE9uRW5kKSByZXR1cm47XG4gICAgZGlkT25FbmQgPSB0cnVlO1xuXG4gICAgaWYgKHR5cGVvZiBkZXN0LmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIGRlc3QuZGVzdHJveSgpO1xuICB9XG5cbiAgLy8gZG9uJ3QgbGVhdmUgZGFuZ2xpbmcgcGlwZXMgd2hlbiB0aGVyZSBhcmUgZXJyb3JzLlxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgY2xlYW51cCgpO1xuICAgIGlmIChFRS5saXN0ZW5lckNvdW50KHRoaXMsICdlcnJvcicpID09PSAwKSB7XG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkIHN0cmVhbSBlcnJvciBpbiBwaXBlLlxuICAgIH1cbiAgfVxuXG4gIHNvdXJjZS5vbignZXJyb3InLCBvbmVycm9yKTtcbiAgZGVzdC5vbignZXJyb3InLCBvbmVycm9yKTtcblxuICAvLyByZW1vdmUgYWxsIHRoZSBldmVudCBsaXN0ZW5lcnMgdGhhdCB3ZXJlIGFkZGVkLlxuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBjbGVhbnVwKTtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIGNsZWFudXApO1xuICB9XG5cbiAgc291cmNlLm9uKCdlbmQnLCBjbGVhbnVwKTtcbiAgc291cmNlLm9uKCdjbG9zZScsIGNsZWFudXApO1xuXG4gIGRlc3Qub24oJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgZGVzdC5lbWl0KCdwaXBlJywgc291cmNlKTtcblxuICAvLyBBbGxvdyBmb3IgdW5peC1saWtlIHVzYWdlOiBBLnBpcGUoQikucGlwZShDKVxuICByZXR1cm4gZGVzdDtcbn07XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcblxudmFyIGlzQnVmZmVyRW5jb2RpbmcgPSBCdWZmZXIuaXNFbmNvZGluZ1xuICB8fCBmdW5jdGlvbihlbmNvZGluZykge1xuICAgICAgIHN3aXRjaCAoZW5jb2RpbmcgJiYgZW5jb2RpbmcudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgY2FzZSAnaGV4JzogY2FzZSAndXRmOCc6IGNhc2UgJ3V0Zi04JzogY2FzZSAnYXNjaWknOiBjYXNlICdiaW5hcnknOiBjYXNlICdiYXNlNjQnOiBjYXNlICd1Y3MyJzogY2FzZSAndWNzLTInOiBjYXNlICd1dGYxNmxlJzogY2FzZSAndXRmLTE2bGUnOiBjYXNlICdyYXcnOiByZXR1cm4gdHJ1ZTtcbiAgICAgICAgIGRlZmF1bHQ6IHJldHVybiBmYWxzZTtcbiAgICAgICB9XG4gICAgIH1cblxuXG5mdW5jdGlvbiBhc3NlcnRFbmNvZGluZyhlbmNvZGluZykge1xuICBpZiAoZW5jb2RpbmcgJiYgIWlzQnVmZmVyRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpO1xuICB9XG59XG5cbi8vIFN0cmluZ0RlY29kZXIgcHJvdmlkZXMgYW4gaW50ZXJmYWNlIGZvciBlZmZpY2llbnRseSBzcGxpdHRpbmcgYSBzZXJpZXMgb2Zcbi8vIGJ1ZmZlcnMgaW50byBhIHNlcmllcyBvZiBKUyBzdHJpbmdzIHdpdGhvdXQgYnJlYWtpbmcgYXBhcnQgbXVsdGktYnl0ZVxuLy8gY2hhcmFjdGVycy4gQ0VTVS04IGlzIGhhbmRsZWQgYXMgcGFydCBvZiB0aGUgVVRGLTggZW5jb2RpbmcuXG4vL1xuLy8gQFRPRE8gSGFuZGxpbmcgYWxsIGVuY29kaW5ncyBpbnNpZGUgYSBzaW5nbGUgb2JqZWN0IG1ha2VzIGl0IHZlcnkgZGlmZmljdWx0XG4vLyB0byByZWFzb24gYWJvdXQgdGhpcyBjb2RlLCBzbyBpdCBzaG91bGQgYmUgc3BsaXQgdXAgaW4gdGhlIGZ1dHVyZS5cbi8vIEBUT0RPIFRoZXJlIHNob3VsZCBiZSBhIHV0Zjgtc3RyaWN0IGVuY29kaW5nIHRoYXQgcmVqZWN0cyBpbnZhbGlkIFVURi04IGNvZGVcbi8vIHBvaW50cyBhcyB1c2VkIGJ5IENFU1UtOC5cbnZhciBTdHJpbmdEZWNvZGVyID0gZXhwb3J0cy5TdHJpbmdEZWNvZGVyID0gZnVuY3Rpb24oZW5jb2RpbmcpIHtcbiAgdGhpcy5lbmNvZGluZyA9IChlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvWy1fXS8sICcnKTtcbiAgYXNzZXJ0RW5jb2RpbmcoZW5jb2RpbmcpO1xuICBzd2l0Y2ggKHRoaXMuZW5jb2RpbmcpIHtcbiAgICBjYXNlICd1dGY4JzpcbiAgICAgIC8vIENFU1UtOCByZXByZXNlbnRzIGVhY2ggb2YgU3Vycm9nYXRlIFBhaXIgYnkgMy1ieXRlc1xuICAgICAgdGhpcy5zdXJyb2dhdGVTaXplID0gMztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgLy8gVVRGLTE2IHJlcHJlc2VudHMgZWFjaCBvZiBTdXJyb2dhdGUgUGFpciBieSAyLWJ5dGVzXG4gICAgICB0aGlzLnN1cnJvZ2F0ZVNpemUgPSAyO1xuICAgICAgdGhpcy5kZXRlY3RJbmNvbXBsZXRlQ2hhciA9IHV0ZjE2RGV0ZWN0SW5jb21wbGV0ZUNoYXI7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgLy8gQmFzZS02NCBzdG9yZXMgMyBieXRlcyBpbiA0IGNoYXJzLCBhbmQgcGFkcyB0aGUgcmVtYWluZGVyLlxuICAgICAgdGhpcy5zdXJyb2dhdGVTaXplID0gMztcbiAgICAgIHRoaXMuZGV0ZWN0SW5jb21wbGV0ZUNoYXIgPSBiYXNlNjREZXRlY3RJbmNvbXBsZXRlQ2hhcjtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aGlzLndyaXRlID0gcGFzc1Rocm91Z2hXcml0ZTtcbiAgICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEVub3VnaCBzcGFjZSB0byBzdG9yZSBhbGwgYnl0ZXMgb2YgYSBzaW5nbGUgY2hhcmFjdGVyLiBVVEYtOCBuZWVkcyA0XG4gIC8vIGJ5dGVzLCBidXQgQ0VTVS04IG1heSByZXF1aXJlIHVwIHRvIDYgKDMgYnl0ZXMgcGVyIHN1cnJvZ2F0ZSkuXG4gIHRoaXMuY2hhckJ1ZmZlciA9IG5ldyBCdWZmZXIoNik7XG4gIC8vIE51bWJlciBvZiBieXRlcyByZWNlaXZlZCBmb3IgdGhlIGN1cnJlbnQgaW5jb21wbGV0ZSBtdWx0aS1ieXRlIGNoYXJhY3Rlci5cbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSAwO1xuICAvLyBOdW1iZXIgb2YgYnl0ZXMgZXhwZWN0ZWQgZm9yIHRoZSBjdXJyZW50IGluY29tcGxldGUgbXVsdGktYnl0ZSBjaGFyYWN0ZXIuXG4gIHRoaXMuY2hhckxlbmd0aCA9IDA7XG59O1xuXG5cbi8vIHdyaXRlIGRlY29kZXMgdGhlIGdpdmVuIGJ1ZmZlciBhbmQgcmV0dXJucyBpdCBhcyBKUyBzdHJpbmcgdGhhdCBpc1xuLy8gZ3VhcmFudGVlZCB0byBub3QgY29udGFpbiBhbnkgcGFydGlhbCBtdWx0aS1ieXRlIGNoYXJhY3RlcnMuIEFueSBwYXJ0aWFsXG4vLyBjaGFyYWN0ZXIgZm91bmQgYXQgdGhlIGVuZCBvZiB0aGUgYnVmZmVyIGlzIGJ1ZmZlcmVkIHVwLCBhbmQgd2lsbCBiZVxuLy8gcmV0dXJuZWQgd2hlbiBjYWxsaW5nIHdyaXRlIGFnYWluIHdpdGggdGhlIHJlbWFpbmluZyBieXRlcy5cbi8vXG4vLyBOb3RlOiBDb252ZXJ0aW5nIGEgQnVmZmVyIGNvbnRhaW5pbmcgYW4gb3JwaGFuIHN1cnJvZ2F0ZSB0byBhIFN0cmluZ1xuLy8gY3VycmVudGx5IHdvcmtzLCBidXQgY29udmVydGluZyBhIFN0cmluZyB0byBhIEJ1ZmZlciAodmlhIGBuZXcgQnVmZmVyYCwgb3Jcbi8vIEJ1ZmZlciN3cml0ZSkgd2lsbCByZXBsYWNlIGluY29tcGxldGUgc3Vycm9nYXRlcyB3aXRoIHRoZSB1bmljb2RlXG4vLyByZXBsYWNlbWVudCBjaGFyYWN0ZXIuIFNlZSBodHRwczovL2NvZGVyZXZpZXcuY2hyb21pdW0ub3JnLzEyMTE3MzAwOS8gLlxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgdmFyIGNoYXJTdHIgPSAnJztcbiAgLy8gaWYgb3VyIGxhc3Qgd3JpdGUgZW5kZWQgd2l0aCBhbiBpbmNvbXBsZXRlIG11bHRpYnl0ZSBjaGFyYWN0ZXJcbiAgd2hpbGUgKHRoaXMuY2hhckxlbmd0aCkge1xuICAgIC8vIGRldGVybWluZSBob3cgbWFueSByZW1haW5pbmcgYnl0ZXMgdGhpcyBidWZmZXIgaGFzIHRvIG9mZmVyIGZvciB0aGlzIGNoYXJcbiAgICB2YXIgYXZhaWxhYmxlID0gKGJ1ZmZlci5sZW5ndGggPj0gdGhpcy5jaGFyTGVuZ3RoIC0gdGhpcy5jaGFyUmVjZWl2ZWQpID9cbiAgICAgICAgdGhpcy5jaGFyTGVuZ3RoIC0gdGhpcy5jaGFyUmVjZWl2ZWQgOlxuICAgICAgICBidWZmZXIubGVuZ3RoO1xuXG4gICAgLy8gYWRkIHRoZSBuZXcgYnl0ZXMgdG8gdGhlIGNoYXIgYnVmZmVyXG4gICAgYnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCB0aGlzLmNoYXJSZWNlaXZlZCwgMCwgYXZhaWxhYmxlKTtcbiAgICB0aGlzLmNoYXJSZWNlaXZlZCArPSBhdmFpbGFibGU7XG5cbiAgICBpZiAodGhpcy5jaGFyUmVjZWl2ZWQgPCB0aGlzLmNoYXJMZW5ndGgpIHtcbiAgICAgIC8vIHN0aWxsIG5vdCBlbm91Z2ggY2hhcnMgaW4gdGhpcyBidWZmZXI/IHdhaXQgZm9yIG1vcmUgLi4uXG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIGJ5dGVzIGJlbG9uZ2luZyB0byB0aGUgY3VycmVudCBjaGFyYWN0ZXIgZnJvbSB0aGUgYnVmZmVyXG4gICAgYnVmZmVyID0gYnVmZmVyLnNsaWNlKGF2YWlsYWJsZSwgYnVmZmVyLmxlbmd0aCk7XG5cbiAgICAvLyBnZXQgdGhlIGNoYXJhY3RlciB0aGF0IHdhcyBzcGxpdFxuICAgIGNoYXJTdHIgPSB0aGlzLmNoYXJCdWZmZXIuc2xpY2UoMCwgdGhpcy5jaGFyTGVuZ3RoKS50b1N0cmluZyh0aGlzLmVuY29kaW5nKTtcblxuICAgIC8vIENFU1UtODogbGVhZCBzdXJyb2dhdGUgKEQ4MDAtREJGRikgaXMgYWxzbyB0aGUgaW5jb21wbGV0ZSBjaGFyYWN0ZXJcbiAgICB2YXIgY2hhckNvZGUgPSBjaGFyU3RyLmNoYXJDb2RlQXQoY2hhclN0ci5sZW5ndGggLSAxKTtcbiAgICBpZiAoY2hhckNvZGUgPj0gMHhEODAwICYmIGNoYXJDb2RlIDw9IDB4REJGRikge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoICs9IHRoaXMuc3Vycm9nYXRlU2l6ZTtcbiAgICAgIGNoYXJTdHIgPSAnJztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB0aGlzLmNoYXJSZWNlaXZlZCA9IHRoaXMuY2hhckxlbmd0aCA9IDA7XG5cbiAgICAvLyBpZiB0aGVyZSBhcmUgbm8gbW9yZSBieXRlcyBpbiB0aGlzIGJ1ZmZlciwganVzdCBlbWl0IG91ciBjaGFyXG4gICAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBjaGFyU3RyO1xuICAgIH1cbiAgICBicmVhaztcbiAgfVxuXG4gIC8vIGRldGVybWluZSBhbmQgc2V0IGNoYXJMZW5ndGggLyBjaGFyUmVjZWl2ZWRcbiAgdGhpcy5kZXRlY3RJbmNvbXBsZXRlQ2hhcihidWZmZXIpO1xuXG4gIHZhciBlbmQgPSBidWZmZXIubGVuZ3RoO1xuICBpZiAodGhpcy5jaGFyTGVuZ3RoKSB7XG4gICAgLy8gYnVmZmVyIHRoZSBpbmNvbXBsZXRlIGNoYXJhY3RlciBieXRlcyB3ZSBnb3RcbiAgICBidWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIDAsIGJ1ZmZlci5sZW5ndGggLSB0aGlzLmNoYXJSZWNlaXZlZCwgZW5kKTtcbiAgICBlbmQgLT0gdGhpcy5jaGFyUmVjZWl2ZWQ7XG4gIH1cblxuICBjaGFyU3RyICs9IGJ1ZmZlci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCBlbmQpO1xuXG4gIHZhciBlbmQgPSBjaGFyU3RyLmxlbmd0aCAtIDE7XG4gIHZhciBjaGFyQ29kZSA9IGNoYXJTdHIuY2hhckNvZGVBdChlbmQpO1xuICAvLyBDRVNVLTg6IGxlYWQgc3Vycm9nYXRlIChEODAwLURCRkYpIGlzIGFsc28gdGhlIGluY29tcGxldGUgY2hhcmFjdGVyXG4gIGlmIChjaGFyQ29kZSA+PSAweEQ4MDAgJiYgY2hhckNvZGUgPD0gMHhEQkZGKSB7XG4gICAgdmFyIHNpemUgPSB0aGlzLnN1cnJvZ2F0ZVNpemU7XG4gICAgdGhpcy5jaGFyTGVuZ3RoICs9IHNpemU7XG4gICAgdGhpcy5jaGFyUmVjZWl2ZWQgKz0gc2l6ZTtcbiAgICB0aGlzLmNoYXJCdWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIHNpemUsIDAsIHNpemUpO1xuICAgIGJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgMCwgMCwgc2l6ZSk7XG4gICAgcmV0dXJuIGNoYXJTdHIuc3Vic3RyaW5nKDAsIGVuZCk7XG4gIH1cblxuICAvLyBvciBqdXN0IGVtaXQgdGhlIGNoYXJTdHJcbiAgcmV0dXJuIGNoYXJTdHI7XG59O1xuXG4vLyBkZXRlY3RJbmNvbXBsZXRlQ2hhciBkZXRlcm1pbmVzIGlmIHRoZXJlIGlzIGFuIGluY29tcGxldGUgVVRGLTggY2hhcmFjdGVyIGF0XG4vLyB0aGUgZW5kIG9mIHRoZSBnaXZlbiBidWZmZXIuIElmIHNvLCBpdCBzZXRzIHRoaXMuY2hhckxlbmd0aCB0byB0aGUgYnl0ZVxuLy8gbGVuZ3RoIHRoYXQgY2hhcmFjdGVyLCBhbmQgc2V0cyB0aGlzLmNoYXJSZWNlaXZlZCB0byB0aGUgbnVtYmVyIG9mIGJ5dGVzXG4vLyB0aGF0IGFyZSBhdmFpbGFibGUgZm9yIHRoaXMgY2hhcmFjdGVyLlxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZGV0ZWN0SW5jb21wbGV0ZUNoYXIgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgLy8gZGV0ZXJtaW5lIGhvdyBtYW55IGJ5dGVzIHdlIGhhdmUgdG8gY2hlY2sgYXQgdGhlIGVuZCBvZiB0aGlzIGJ1ZmZlclxuICB2YXIgaSA9IChidWZmZXIubGVuZ3RoID49IDMpID8gMyA6IGJ1ZmZlci5sZW5ndGg7XG5cbiAgLy8gRmlndXJlIG91dCBpZiBvbmUgb2YgdGhlIGxhc3QgaSBieXRlcyBvZiBvdXIgYnVmZmVyIGFubm91bmNlcyBhblxuICAvLyBpbmNvbXBsZXRlIGNoYXIuXG4gIGZvciAoOyBpID4gMDsgaS0tKSB7XG4gICAgdmFyIGMgPSBidWZmZXJbYnVmZmVyLmxlbmd0aCAtIGldO1xuXG4gICAgLy8gU2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVVRGLTgjRGVzY3JpcHRpb25cblxuICAgIC8vIDExMFhYWFhYXG4gICAgaWYgKGkgPT0gMSAmJiBjID4+IDUgPT0gMHgwNikge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoID0gMjtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIDExMTBYWFhYXG4gICAgaWYgKGkgPD0gMiAmJiBjID4+IDQgPT0gMHgwRSkge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoID0gMztcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIDExMTEwWFhYXG4gICAgaWYgKGkgPD0gMyAmJiBjID4+IDMgPT0gMHgxRSkge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoID0gNDtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICB0aGlzLmNoYXJSZWNlaXZlZCA9IGk7XG59O1xuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICBpZiAoYnVmZmVyICYmIGJ1ZmZlci5sZW5ndGgpXG4gICAgcmVzID0gdGhpcy53cml0ZShidWZmZXIpO1xuXG4gIGlmICh0aGlzLmNoYXJSZWNlaXZlZCkge1xuICAgIHZhciBjciA9IHRoaXMuY2hhclJlY2VpdmVkO1xuICAgIHZhciBidWYgPSB0aGlzLmNoYXJCdWZmZXI7XG4gICAgdmFyIGVuYyA9IHRoaXMuZW5jb2Rpbmc7XG4gICAgcmVzICs9IGJ1Zi5zbGljZSgwLCBjcikudG9TdHJpbmcoZW5jKTtcbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuXG5mdW5jdGlvbiBwYXNzVGhyb3VnaFdyaXRlKGJ1ZmZlcikge1xuICByZXR1cm4gYnVmZmVyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpO1xufVxuXG5mdW5jdGlvbiB1dGYxNkRldGVjdEluY29tcGxldGVDaGFyKGJ1ZmZlcikge1xuICB0aGlzLmNoYXJSZWNlaXZlZCA9IGJ1ZmZlci5sZW5ndGggJSAyO1xuICB0aGlzLmNoYXJMZW5ndGggPSB0aGlzLmNoYXJSZWNlaXZlZCA/IDIgOiAwO1xufVxuXG5mdW5jdGlvbiBiYXNlNjREZXRlY3RJbmNvbXBsZXRlQ2hhcihidWZmZXIpIHtcbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSBidWZmZXIubGVuZ3RoICUgMztcbiAgdGhpcy5jaGFyTGVuZ3RoID0gdGhpcy5jaGFyUmVjZWl2ZWQgPyAzIDogMDtcbn1cbiIsInZhciBpbmRleE9mID0gcmVxdWlyZSgnaW5kZXhvZicpO1xuXG52YXIgT2JqZWN0X2tleXMgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgaWYgKE9iamVjdC5rZXlzKSByZXR1cm4gT2JqZWN0LmtleXMob2JqKVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgcmVzID0gW107XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHJlcy5wdXNoKGtleSlcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG59O1xuXG52YXIgZm9yRWFjaCA9IGZ1bmN0aW9uICh4cywgZm4pIHtcbiAgICBpZiAoeHMuZm9yRWFjaCkgcmV0dXJuIHhzLmZvckVhY2goZm4pXG4gICAgZWxzZSBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZuKHhzW2ldLCBpLCB4cyk7XG4gICAgfVxufTtcblxudmFyIGRlZmluZVByb3AgPSAoZnVuY3Rpb24oKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnXycsIHt9KTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iaiwgbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIG5hbWUsIHtcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgIH0gY2F0Y2goZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24ob2JqLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgb2JqW25hbWVdID0gdmFsdWU7XG4gICAgICAgIH07XG4gICAgfVxufSgpKTtcblxudmFyIGdsb2JhbHMgPSBbJ0FycmF5JywgJ0Jvb2xlYW4nLCAnRGF0ZScsICdFcnJvcicsICdFdmFsRXJyb3InLCAnRnVuY3Rpb24nLFxuJ0luZmluaXR5JywgJ0pTT04nLCAnTWF0aCcsICdOYU4nLCAnTnVtYmVyJywgJ09iamVjdCcsICdSYW5nZUVycm9yJyxcbidSZWZlcmVuY2VFcnJvcicsICdSZWdFeHAnLCAnU3RyaW5nJywgJ1N5bnRheEVycm9yJywgJ1R5cGVFcnJvcicsICdVUklFcnJvcicsXG4nZGVjb2RlVVJJJywgJ2RlY29kZVVSSUNvbXBvbmVudCcsICdlbmNvZGVVUkknLCAnZW5jb2RlVVJJQ29tcG9uZW50JywgJ2VzY2FwZScsXG4nZXZhbCcsICdpc0Zpbml0ZScsICdpc05hTicsICdwYXJzZUZsb2F0JywgJ3BhcnNlSW50JywgJ3VuZGVmaW5lZCcsICd1bmVzY2FwZSddO1xuXG5mdW5jdGlvbiBDb250ZXh0KCkge31cbkNvbnRleHQucHJvdG90eXBlID0ge307XG5cbnZhciBTY3JpcHQgPSBleHBvcnRzLlNjcmlwdCA9IGZ1bmN0aW9uIE5vZGVTY3JpcHQgKGNvZGUpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU2NyaXB0KSkgcmV0dXJuIG5ldyBTY3JpcHQoY29kZSk7XG4gICAgdGhpcy5jb2RlID0gY29kZTtcbn07XG5cblNjcmlwdC5wcm90b3R5cGUucnVuSW5Db250ZXh0ID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICBpZiAoIShjb250ZXh0IGluc3RhbmNlb2YgQ29udGV4dCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIm5lZWRzIGEgJ2NvbnRleHQnIGFyZ3VtZW50LlwiKTtcbiAgICB9XG4gICAgXG4gICAgdmFyIGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgIGlmICghaWZyYW1lLnN0eWxlKSBpZnJhbWUuc3R5bGUgPSB7fTtcbiAgICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICBcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gICAgXG4gICAgdmFyIHdpbiA9IGlmcmFtZS5jb250ZW50V2luZG93O1xuICAgIHZhciB3RXZhbCA9IHdpbi5ldmFsLCB3RXhlY1NjcmlwdCA9IHdpbi5leGVjU2NyaXB0O1xuXG4gICAgaWYgKCF3RXZhbCAmJiB3RXhlY1NjcmlwdCkge1xuICAgICAgICAvLyB3aW4uZXZhbCgpIG1hZ2ljYWxseSBhcHBlYXJzIHdoZW4gdGhpcyBpcyBjYWxsZWQgaW4gSUU6XG4gICAgICAgIHdFeGVjU2NyaXB0LmNhbGwod2luLCAnbnVsbCcpO1xuICAgICAgICB3RXZhbCA9IHdpbi5ldmFsO1xuICAgIH1cbiAgICBcbiAgICBmb3JFYWNoKE9iamVjdF9rZXlzKGNvbnRleHQpLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHdpbltrZXldID0gY29udGV4dFtrZXldO1xuICAgIH0pO1xuICAgIGZvckVhY2goZ2xvYmFscywgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoY29udGV4dFtrZXldKSB7XG4gICAgICAgICAgICB3aW5ba2V5XSA9IGNvbnRleHRba2V5XTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIHZhciB3aW5LZXlzID0gT2JqZWN0X2tleXMod2luKTtcblxuICAgIHZhciByZXMgPSB3RXZhbC5jYWxsKHdpbiwgdGhpcy5jb2RlKTtcbiAgICBcbiAgICBmb3JFYWNoKE9iamVjdF9rZXlzKHdpbiksIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgLy8gQXZvaWQgY29weWluZyBjaXJjdWxhciBvYmplY3RzIGxpa2UgYHRvcGAgYW5kIGB3aW5kb3dgIGJ5IG9ubHlcbiAgICAgICAgLy8gdXBkYXRpbmcgZXhpc3RpbmcgY29udGV4dCBwcm9wZXJ0aWVzIG9yIG5ldyBwcm9wZXJ0aWVzIGluIHRoZSBgd2luYFxuICAgICAgICAvLyB0aGF0IHdhcyBvbmx5IGludHJvZHVjZWQgYWZ0ZXIgdGhlIGV2YWwuXG4gICAgICAgIGlmIChrZXkgaW4gY29udGV4dCB8fCBpbmRleE9mKHdpbktleXMsIGtleSkgPT09IC0xKSB7XG4gICAgICAgICAgICBjb250ZXh0W2tleV0gPSB3aW5ba2V5XTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgZm9yRWFjaChnbG9iYWxzLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmICghKGtleSBpbiBjb250ZXh0KSkge1xuICAgICAgICAgICAgZGVmaW5lUHJvcChjb250ZXh0LCBrZXksIHdpbltrZXldKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgICBcbiAgICByZXR1cm4gcmVzO1xufTtcblxuU2NyaXB0LnByb3RvdHlwZS5ydW5JblRoaXNDb250ZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBldmFsKHRoaXMuY29kZSk7IC8vIG1heWJlLi4uXG59O1xuXG5TY3JpcHQucHJvdG90eXBlLnJ1bkluTmV3Q29udGV4dCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgdmFyIGN0eCA9IFNjcmlwdC5jcmVhdGVDb250ZXh0KGNvbnRleHQpO1xuICAgIHZhciByZXMgPSB0aGlzLnJ1bkluQ29udGV4dChjdHgpO1xuXG4gICAgZm9yRWFjaChPYmplY3Rfa2V5cyhjdHgpLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGNvbnRleHRba2V5XSA9IGN0eFtrZXldO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlcztcbn07XG5cbmZvckVhY2goT2JqZWN0X2tleXMoU2NyaXB0LnByb3RvdHlwZSksIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgZXhwb3J0c1tuYW1lXSA9IFNjcmlwdFtuYW1lXSA9IGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgICAgIHZhciBzID0gU2NyaXB0KGNvZGUpO1xuICAgICAgICByZXR1cm4gc1tuYW1lXS5hcHBseShzLCBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgIH07XG59KTtcblxuZXhwb3J0cy5jcmVhdGVTY3JpcHQgPSBmdW5jdGlvbiAoY29kZSkge1xuICAgIHJldHVybiBleHBvcnRzLlNjcmlwdChjb2RlKTtcbn07XG5cbmV4cG9ydHMuY3JlYXRlQ29udGV4dCA9IFNjcmlwdC5jcmVhdGVDb250ZXh0ID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICB2YXIgY29weSA9IG5ldyBDb250ZXh0KCk7XG4gICAgaWYodHlwZW9mIGNvbnRleHQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGZvckVhY2goT2JqZWN0X2tleXMoY29udGV4dCksIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGNvcHlba2V5XSA9IGNvbnRleHRba2V5XTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBjb3B5O1xufTtcbiIsIlxudmFyIGluZGV4T2YgPSBbXS5pbmRleE9mO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGFyciwgb2JqKXtcbiAgaWYgKGluZGV4T2YpIHJldHVybiBhcnIuaW5kZXhPZihvYmopO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7ICsraSkge1xuICAgIGlmIChhcnJbaV0gPT09IG9iaikgcmV0dXJuIGk7XG4gIH1cbiAgcmV0dXJuIC0xO1xufTsiLCIvKiFcbiAqIFhSZWdFeHAtQWxsIDMuMC4wXG4gKiA8aHR0cDovL3hyZWdleHAuY29tLz5cbiAqIFN0ZXZlbiBMZXZpdGhhbiAoYykgMjAxMi0yMDE1IE1JVCBMaWNlbnNlXG4gKi9cblxuLy8gTW9kdWxlIHN5c3RlbXMgbWFnaWMgZGFuY2UuIERvbid0IHVzZSBzdHJpY3QgbW9kZSBmb3IgdGhpcyBmdW5jdGlvbiwgc28gaXQgY2FuIGFzc2lnbiB0byBnbG9iYWwuXG47KGZ1bmN0aW9uKHJvb3QsIGRlZmluaXRpb24pIHtcbiAgICB2YXIgc2VsZjtcblxuICAgIC8vIFJlcXVpcmVKU1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGRlZmluZShkZWZpbml0aW9uKTtcbiAgICAvLyBDb21tb25KU1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHNlbGYgPSBkZWZpbml0aW9uKCk7XG4gICAgICAgIC8vIFVzZSBOb2RlLmpzJ3MgYG1vZHVsZS5leHBvcnRzYC4gVGhpcyBzdXBwb3J0cyBib3RoIGByZXF1aXJlKCd4cmVnZXhwJylgIGFuZFxuICAgICAgICAvLyBgcmVxdWlyZSgneHJlZ2V4cCcpLlhSZWdFeHBgXG4gICAgICAgICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyA/IChtb2R1bGUuZXhwb3J0cyA9IHNlbGYpIDogZXhwb3J0cykuWFJlZ0V4cCA9IHNlbGY7XG4gICAgLy8gPHNjcmlwdD5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBDcmVhdGUgZ2xvYmFsXG4gICAgICAgIHJvb3QuWFJlZ0V4cCA9IGRlZmluaXRpb24oKTtcbiAgICB9XG59KHRoaXMsIGZ1bmN0aW9uKCkge1xuXG4vKiFcbiAqIFhSZWdFeHAgMy4wLjBcbiAqIDxodHRwOi8veHJlZ2V4cC5jb20vPlxuICogU3RldmVuIExldml0aGFuIChjKSAyMDA3LTIwMTUgTUlUIExpY2Vuc2VcbiAqL1xuXG4vKipcbiAqIFhSZWdFeHAgcHJvdmlkZXMgYXVnbWVudGVkLCBleHRlbnNpYmxlIHJlZ3VsYXIgZXhwcmVzc2lvbnMuIFlvdSBnZXQgYWRkaXRpb25hbCByZWdleCBzeW50YXggYW5kXG4gKiBmbGFncywgYmV5b25kIHdoYXQgYnJvd3NlcnMgc3VwcG9ydCBuYXRpdmVseS4gWFJlZ0V4cCBpcyBhbHNvIGEgcmVnZXggdXRpbGl0eSBiZWx0IHdpdGggdG9vbHMgdG9cbiAqIG1ha2UgeW91ciBjbGllbnQtc2lkZSBncmVwcGluZyBzaW1wbGVyIGFuZCBtb3JlIHBvd2VyZnVsLCB3aGlsZSBmcmVlaW5nIHlvdSBmcm9tIHJlbGF0ZWRcbiAqIGNyb3NzLWJyb3dzZXIgaW5jb25zaXN0ZW5jaWVzLlxuICovXG52YXIgWFJlZ0V4cCA9IChmdW5jdGlvbih1bmRlZmluZWQpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogUHJpdmF0ZSB2YXJpYWJsZXNcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG4gICAgdmFyIC8vIEludGVybmFsIHJlZmVyZW5jZSB0byB0aGUgYFhSZWdFeHBgIG9iamVjdFxuICAgICAgICBzZWxmLFxuICAgICAgICAvLyBQcm9wZXJ0eSBuYW1lIHVzZWQgZm9yIGV4dGVuZGVkIHJlZ2V4IGluc3RhbmNlIGRhdGFcbiAgICAgICAgUkVHRVhfREFUQSA9ICd4cmVnZXhwJyxcbiAgICAgICAgLy8gT3B0aW9uYWwgZmVhdHVyZXMgdGhhdCBjYW4gYmUgaW5zdGFsbGVkIGFuZCB1bmluc3RhbGxlZFxuICAgICAgICBmZWF0dXJlcyA9IHtcbiAgICAgICAgICAgIGFzdHJhbDogZmFsc2UsXG4gICAgICAgICAgICBuYXRpdmVzOiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICAvLyBOYXRpdmUgbWV0aG9kcyB0byB1c2UgYW5kIHJlc3RvcmUgKCduYXRpdmUnIGlzIGFuIEVTMyByZXNlcnZlZCBrZXl3b3JkKVxuICAgICAgICBuYXRpdiA9IHtcbiAgICAgICAgICAgIGV4ZWM6IFJlZ0V4cC5wcm90b3R5cGUuZXhlYyxcbiAgICAgICAgICAgIHRlc3Q6IFJlZ0V4cC5wcm90b3R5cGUudGVzdCxcbiAgICAgICAgICAgIG1hdGNoOiBTdHJpbmcucHJvdG90eXBlLm1hdGNoLFxuICAgICAgICAgICAgcmVwbGFjZTogU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlLFxuICAgICAgICAgICAgc3BsaXQ6IFN0cmluZy5wcm90b3R5cGUuc3BsaXRcbiAgICAgICAgfSxcbiAgICAgICAgLy8gU3RvcmFnZSBmb3IgZml4ZWQvZXh0ZW5kZWQgbmF0aXZlIG1ldGhvZHNcbiAgICAgICAgZml4ZWQgPSB7fSxcbiAgICAgICAgLy8gU3RvcmFnZSBmb3IgcmVnZXhlcyBjYWNoZWQgYnkgYFhSZWdFeHAuY2FjaGVgXG4gICAgICAgIHJlZ2V4Q2FjaGUgPSB7fSxcbiAgICAgICAgLy8gU3RvcmFnZSBmb3IgcGF0dGVybiBkZXRhaWxzIGNhY2hlZCBieSB0aGUgYFhSZWdFeHBgIGNvbnN0cnVjdG9yXG4gICAgICAgIHBhdHRlcm5DYWNoZSA9IHt9LFxuICAgICAgICAvLyBTdG9yYWdlIGZvciByZWdleCBzeW50YXggdG9rZW5zIGFkZGVkIGludGVybmFsbHkgb3IgYnkgYFhSZWdFeHAuYWRkVG9rZW5gXG4gICAgICAgIHRva2VucyA9IFtdLFxuICAgICAgICAvLyBUb2tlbiBzY29wZXNcbiAgICAgICAgZGVmYXVsdFNjb3BlID0gJ2RlZmF1bHQnLFxuICAgICAgICBjbGFzc1Njb3BlID0gJ2NsYXNzJyxcbiAgICAgICAgLy8gUmVnZXhlcyB0aGF0IG1hdGNoIG5hdGl2ZSByZWdleCBzeW50YXgsIGluY2x1ZGluZyBvY3RhbHNcbiAgICAgICAgbmF0aXZlVG9rZW5zID0ge1xuICAgICAgICAgICAgLy8gQW55IG5hdGl2ZSBtdWx0aWNoYXJhY3RlciB0b2tlbiBpbiBkZWZhdWx0IHNjb3BlLCBvciBhbnkgc2luZ2xlIGNoYXJhY3RlclxuICAgICAgICAgICAgJ2RlZmF1bHQnOiAvXFxcXCg/OjAoPzpbMC0zXVswLTddezAsMn18WzQtN11bMC03XT8pP3xbMS05XVxcZCp8eFtcXGRBLUZhLWZdezJ9fHUoPzpbXFxkQS1GYS1mXXs0fXx7W1xcZEEtRmEtZl0rfSl8Y1tBLVphLXpdfFtcXHNcXFNdKXxcXChcXD9bOj0hXXxbPyorXVxcP3x7XFxkKyg/OixcXGQqKT99XFw/P3xbXFxzXFxTXS8sXG4gICAgICAgICAgICAvLyBBbnkgbmF0aXZlIG11bHRpY2hhcmFjdGVyIHRva2VuIGluIGNoYXJhY3RlciBjbGFzcyBzY29wZSwgb3IgYW55IHNpbmdsZSBjaGFyYWN0ZXJcbiAgICAgICAgICAgICdjbGFzcyc6IC9cXFxcKD86WzAtM11bMC03XXswLDJ9fFs0LTddWzAtN10/fHhbXFxkQS1GYS1mXXsyfXx1KD86W1xcZEEtRmEtZl17NH18e1tcXGRBLUZhLWZdK30pfGNbQS1aYS16XXxbXFxzXFxTXSl8W1xcc1xcU10vXG4gICAgICAgIH0sXG4gICAgICAgIC8vIEFueSBiYWNrcmVmZXJlbmNlIG9yIGRvbGxhci1wcmVmaXhlZCBjaGFyYWN0ZXIgaW4gcmVwbGFjZW1lbnQgc3RyaW5nc1xuICAgICAgICByZXBsYWNlbWVudFRva2VuID0gL1xcJCg/OnsoW1xcdyRdKyl9fChcXGRcXGQ/fFtcXHNcXFNdKSkvZyxcbiAgICAgICAgLy8gQ2hlY2sgZm9yIGNvcnJlY3QgYGV4ZWNgIGhhbmRsaW5nIG9mIG5vbnBhcnRpY2lwYXRpbmcgY2FwdHVyaW5nIGdyb3Vwc1xuICAgICAgICBjb3JyZWN0RXhlY05wY2cgPSBuYXRpdi5leGVjLmNhbGwoLygpPz8vLCAnJylbMV0gPT09IHVuZGVmaW5lZCxcbiAgICAgICAgLy8gQ2hlY2sgZm9yIEVTNiBgdWAgZmxhZyBzdXBwb3J0XG4gICAgICAgIGhhc05hdGl2ZVUgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaXNTdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBuZXcgUmVnRXhwKCcnLCAndScpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgaXNTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpc1N1cHBvcnRlZDtcbiAgICAgICAgfSgpKSxcbiAgICAgICAgLy8gQ2hlY2sgZm9yIEVTNiBgeWAgZmxhZyBzdXBwb3J0XG4gICAgICAgIGhhc05hdGl2ZVkgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaXNTdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBuZXcgUmVnRXhwKCcnLCAneScpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgaXNTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpc1N1cHBvcnRlZDtcbiAgICAgICAgfSgpKSxcbiAgICAgICAgLy8gQ2hlY2sgZm9yIEVTNiBgZmxhZ3NgIHByb3Agc3VwcG9ydFxuICAgICAgICBoYXNGbGFnc1Byb3AgPSAvYS8uZmxhZ3MgIT09IHVuZGVmaW5lZCxcbiAgICAgICAgLy8gVHJhY2tlciBmb3Iga25vd24gZmxhZ3MsIGluY2x1ZGluZyBhZGRvbiBmbGFnc1xuICAgICAgICByZWdpc3RlcmVkRmxhZ3MgPSB7XG4gICAgICAgICAgICBnOiB0cnVlLFxuICAgICAgICAgICAgaTogdHJ1ZSxcbiAgICAgICAgICAgIG06IHRydWUsXG4gICAgICAgICAgICB1OiBoYXNOYXRpdmVVLFxuICAgICAgICAgICAgeTogaGFzTmF0aXZlWVxuICAgICAgICB9LFxuICAgICAgICAvLyBTaG9ydGN1dCB0byBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2BcbiAgICAgICAgdG9TdHJpbmcgPSB7fS50b1N0cmluZyxcbiAgICAgICAgLy8gU2hvcnRjdXQgdG8gYFhSZWdFeHAuYWRkVG9rZW5gXG4gICAgICAgIGFkZDtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBQcml2YXRlIGZ1bmN0aW9uc1xuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cbi8qKlxuICogQXR0YWNoZXMgZXh0ZW5kZWQgZGF0YSBhbmQgYFhSZWdFeHAucHJvdG90eXBlYCBwcm9wZXJ0aWVzIHRvIGEgcmVnZXggb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1JlZ0V4cH0gcmVnZXggUmVnZXggdG8gYXVnbWVudC5cbiAqIEBwYXJhbSB7QXJyYXl9IGNhcHR1cmVOYW1lcyBBcnJheSB3aXRoIGNhcHR1cmUgbmFtZXMsIG9yIGBudWxsYC5cbiAqIEBwYXJhbSB7U3RyaW5nfSB4U291cmNlIFhSZWdFeHAgcGF0dGVybiB1c2VkIHRvIGdlbmVyYXRlIGByZWdleGAsIG9yIGBudWxsYCBpZiBOL0EuXG4gKiBAcGFyYW0ge1N0cmluZ30geEZsYWdzIFhSZWdFeHAgZmxhZ3MgdXNlZCB0byBnZW5lcmF0ZSBgcmVnZXhgLCBvciBgbnVsbGAgaWYgTi9BLlxuICogQHBhcmFtIHtCb29sZWFufSBbaXNJbnRlcm5hbE9ubHk9ZmFsc2VdIFdoZXRoZXIgdGhlIHJlZ2V4IHdpbGwgYmUgdXNlZCBvbmx5IGZvciBpbnRlcm5hbFxuICogICBvcGVyYXRpb25zLCBhbmQgbmV2ZXIgZXhwb3NlZCB0byB1c2Vycy4gRm9yIGludGVybmFsLW9ubHkgcmVnZXhlcywgd2UgY2FuIGltcHJvdmUgcGVyZiBieVxuICogICBza2lwcGluZyBzb21lIG9wZXJhdGlvbnMgbGlrZSBhdHRhY2hpbmcgYFhSZWdFeHAucHJvdG90eXBlYCBwcm9wZXJ0aWVzLlxuICogQHJldHVybnMge1JlZ0V4cH0gQXVnbWVudGVkIHJlZ2V4LlxuICovXG4gICAgZnVuY3Rpb24gYXVnbWVudChyZWdleCwgY2FwdHVyZU5hbWVzLCB4U291cmNlLCB4RmxhZ3MsIGlzSW50ZXJuYWxPbmx5KSB7XG4gICAgICAgIHZhciBwO1xuXG4gICAgICAgIHJlZ2V4W1JFR0VYX0RBVEFdID0ge1xuICAgICAgICAgICAgY2FwdHVyZU5hbWVzOiBjYXB0dXJlTmFtZXNcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoaXNJbnRlcm5hbE9ubHkpIHtcbiAgICAgICAgICAgIHJldHVybiByZWdleDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENhbid0IGF1dG8taW5oZXJpdCB0aGVzZSBzaW5jZSB0aGUgWFJlZ0V4cCBjb25zdHJ1Y3RvciByZXR1cm5zIGEgbm9ucHJpbWl0aXZlIHZhbHVlXG4gICAgICAgIGlmIChyZWdleC5fX3Byb3RvX18pIHtcbiAgICAgICAgICAgIHJlZ2V4Ll9fcHJvdG9fXyA9IHNlbGYucHJvdG90eXBlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yIChwIGluIHNlbGYucHJvdG90eXBlKSB7XG4gICAgICAgICAgICAgICAgLy8gQSBgc2VsZi5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkocClgIGNoZWNrIHdvdWxkbid0IGJlIHdvcnRoIGl0IGhlcmUsIHNpbmNlIHRoaXNcbiAgICAgICAgICAgICAgICAvLyBpcyBwZXJmb3JtYW5jZSBzZW5zaXRpdmUsIGFuZCBlbnVtZXJhYmxlIGBPYmplY3QucHJvdG90eXBlYCBvciBgUmVnRXhwLnByb3RvdHlwZWBcbiAgICAgICAgICAgICAgICAvLyBleHRlbnNpb25zIGV4aXN0IG9uIGByZWdleC5wcm90b3R5cGVgIGFueXdheVxuICAgICAgICAgICAgICAgIHJlZ2V4W3BdID0gc2VsZi5wcm90b3R5cGVbcF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZWdleFtSRUdFWF9EQVRBXS5zb3VyY2UgPSB4U291cmNlO1xuICAgICAgICAvLyBFbXVsYXRlIHRoZSBFUzYgYGZsYWdzYCBwcm9wIGJ5IGVuc3VyaW5nIGZsYWdzIGFyZSBpbiBhbHBoYWJldGljYWwgb3JkZXJcbiAgICAgICAgcmVnZXhbUkVHRVhfREFUQV0uZmxhZ3MgPSB4RmxhZ3MgPyB4RmxhZ3Muc3BsaXQoJycpLnNvcnQoKS5qb2luKCcnKSA6IHhGbGFncztcblxuICAgICAgICByZXR1cm4gcmVnZXg7XG4gICAgfVxuXG4vKipcbiAqIFJlbW92ZXMgYW55IGR1cGxpY2F0ZSBjaGFyYWN0ZXJzIGZyb20gdGhlIHByb3ZpZGVkIHN0cmluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBTdHJpbmcgdG8gcmVtb3ZlIGR1cGxpY2F0ZSBjaGFyYWN0ZXJzIGZyb20uXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBTdHJpbmcgd2l0aCBhbnkgZHVwbGljYXRlIGNoYXJhY3RlcnMgcmVtb3ZlZC5cbiAqL1xuICAgIGZ1bmN0aW9uIGNsaXBEdXBsaWNhdGVzKHN0cikge1xuICAgICAgICByZXR1cm4gbmF0aXYucmVwbGFjZS5jYWxsKHN0ciwgLyhbXFxzXFxTXSkoPz1bXFxzXFxTXSpcXDEpL2csICcnKTtcbiAgICB9XG5cbi8qKlxuICogQ29waWVzIGEgcmVnZXggb2JqZWN0IHdoaWxlIHByZXNlcnZpbmcgZXh0ZW5kZWQgZGF0YSBhbmQgYXVnbWVudGluZyB3aXRoIGBYUmVnRXhwLnByb3RvdHlwZWBcbiAqIHByb3BlcnRpZXMuIFRoZSBjb3B5IGhhcyBhIGZyZXNoIGBsYXN0SW5kZXhgIHByb3BlcnR5IChzZXQgdG8gemVybykuIEFsbG93cyBhZGRpbmcgYW5kIHJlbW92aW5nXG4gKiBmbGFncyBnIGFuZCB5IHdoaWxlIGNvcHlpbmcgdGhlIHJlZ2V4LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1JlZ0V4cH0gcmVnZXggUmVnZXggdG8gY29weS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3Qgd2l0aCBvcHRpb25hbCBwcm9wZXJ0aWVzOlxuICogICA8bGk+YGFkZEdgIHtCb29sZWFufSBBZGQgZmxhZyBnIHdoaWxlIGNvcHlpbmcgdGhlIHJlZ2V4LlxuICogICA8bGk+YGFkZFlgIHtCb29sZWFufSBBZGQgZmxhZyB5IHdoaWxlIGNvcHlpbmcgdGhlIHJlZ2V4LlxuICogICA8bGk+YHJlbW92ZUdgIHtCb29sZWFufSBSZW1vdmUgZmxhZyBnIHdoaWxlIGNvcHlpbmcgdGhlIHJlZ2V4LlxuICogICA8bGk+YHJlbW92ZVlgIHtCb29sZWFufSBSZW1vdmUgZmxhZyB5IHdoaWxlIGNvcHlpbmcgdGhlIHJlZ2V4LlxuICogICA8bGk+YGlzSW50ZXJuYWxPbmx5YCB7Qm9vbGVhbn0gV2hldGhlciB0aGUgY29waWVkIHJlZ2V4IHdpbGwgYmUgdXNlZCBvbmx5IGZvciBpbnRlcm5hbFxuICogICAgIG9wZXJhdGlvbnMsIGFuZCBuZXZlciBleHBvc2VkIHRvIHVzZXJzLiBGb3IgaW50ZXJuYWwtb25seSByZWdleGVzLCB3ZSBjYW4gaW1wcm92ZSBwZXJmIGJ5XG4gKiAgICAgc2tpcHBpbmcgc29tZSBvcGVyYXRpb25zIGxpa2UgYXR0YWNoaW5nIGBYUmVnRXhwLnByb3RvdHlwZWAgcHJvcGVydGllcy5cbiAqIEByZXR1cm5zIHtSZWdFeHB9IENvcHkgb2YgdGhlIHByb3ZpZGVkIHJlZ2V4LCBwb3NzaWJseSB3aXRoIG1vZGlmaWVkIGZsYWdzLlxuICovXG4gICAgZnVuY3Rpb24gY29weVJlZ2V4KHJlZ2V4LCBvcHRpb25zKSB7XG4gICAgICAgIGlmICghc2VsZi5pc1JlZ0V4cChyZWdleCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1R5cGUgUmVnRXhwIGV4cGVjdGVkJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgeERhdGEgPSByZWdleFtSRUdFWF9EQVRBXSB8fCB7fSxcbiAgICAgICAgICAgIGZsYWdzID0gZ2V0TmF0aXZlRmxhZ3MocmVnZXgpLFxuICAgICAgICAgICAgZmxhZ3NUb0FkZCA9ICcnLFxuICAgICAgICAgICAgZmxhZ3NUb1JlbW92ZSA9ICcnLFxuICAgICAgICAgICAgeHJlZ2V4cFNvdXJjZSA9IG51bGwsXG4gICAgICAgICAgICB4cmVnZXhwRmxhZ3MgPSBudWxsO1xuXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIGlmIChvcHRpb25zLnJlbW92ZUcpIHtmbGFnc1RvUmVtb3ZlICs9ICdnJzt9XG4gICAgICAgIGlmIChvcHRpb25zLnJlbW92ZVkpIHtmbGFnc1RvUmVtb3ZlICs9ICd5Jzt9XG4gICAgICAgIGlmIChmbGFnc1RvUmVtb3ZlKSB7XG4gICAgICAgICAgICBmbGFncyA9IG5hdGl2LnJlcGxhY2UuY2FsbChmbGFncywgbmV3IFJlZ0V4cCgnWycgKyBmbGFnc1RvUmVtb3ZlICsgJ10rJywgJ2cnKSwgJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuYWRkRykge2ZsYWdzVG9BZGQgKz0gJ2cnO31cbiAgICAgICAgaWYgKG9wdGlvbnMuYWRkWSkge2ZsYWdzVG9BZGQgKz0gJ3knO31cbiAgICAgICAgaWYgKGZsYWdzVG9BZGQpIHtcbiAgICAgICAgICAgIGZsYWdzID0gY2xpcER1cGxpY2F0ZXMoZmxhZ3MgKyBmbGFnc1RvQWRkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghb3B0aW9ucy5pc0ludGVybmFsT25seSkge1xuICAgICAgICAgICAgaWYgKHhEYXRhLnNvdXJjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgeHJlZ2V4cFNvdXJjZSA9IHhEYXRhLnNvdXJjZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG51bGwgb3IgdW5kZWZpbmVkOyBkb24ndCB3YW50IHRvIGFkZCB0byBgZmxhZ3NgIGlmIHRoZSBwcmV2aW91cyB2YWx1ZSB3YXMgbnVsbCwgc2luY2VcbiAgICAgICAgICAgIC8vIHRoYXQgaW5kaWNhdGVzIHdlJ3JlIG5vdCB0cmFja2luZyBvcmlnaW5hbCBwcmVjb21waWxhdGlvbiBmbGFnc1xuICAgICAgICAgICAgaWYgKHhEYXRhLmZsYWdzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBGbGFncyBhcmUgb25seSBhZGRlZCBmb3Igbm9uLWludGVybmFsIHJlZ2V4ZXMgYnkgYFhSZWdFeHAuZ2xvYmFsaXplYC4gRmxhZ3MgYXJlXG4gICAgICAgICAgICAgICAgLy8gbmV2ZXIgcmVtb3ZlZCBmb3Igbm9uLWludGVybmFsIHJlZ2V4ZXMsIHNvIGRvbid0IG5lZWQgdG8gaGFuZGxlIGl0XG4gICAgICAgICAgICAgICAgeHJlZ2V4cEZsYWdzID0gZmxhZ3NUb0FkZCA/IGNsaXBEdXBsaWNhdGVzKHhEYXRhLmZsYWdzICsgZmxhZ3NUb0FkZCkgOiB4RGF0YS5mbGFncztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEF1Z21lbnQgd2l0aCBgWFJlZ0V4cC5wcm90b3R5cGVgIHByb3BlcnRpZXMsIGJ1dCB1c2UgdGhlIG5hdGl2ZSBgUmVnRXhwYCBjb25zdHJ1Y3RvciB0b1xuICAgICAgICAvLyBhdm9pZCBzZWFyY2hpbmcgZm9yIHNwZWNpYWwgdG9rZW5zLiBUaGF0IHdvdWxkIGJlIHdyb25nIGZvciByZWdleGVzIGNvbnN0cnVjdGVkIGJ5XG4gICAgICAgIC8vIGBSZWdFeHBgLCBhbmQgdW5uZWNlc3NhcnkgZm9yIHJlZ2V4ZXMgY29uc3RydWN0ZWQgYnkgYFhSZWdFeHBgIGJlY2F1c2UgdGhlIHJlZ2V4IGhhc1xuICAgICAgICAvLyBhbHJlYWR5IHVuZGVyZ29uZSB0aGUgdHJhbnNsYXRpb24gdG8gbmF0aXZlIHJlZ2V4IHN5bnRheFxuICAgICAgICByZWdleCA9IGF1Z21lbnQoXG4gICAgICAgICAgICBuZXcgUmVnRXhwKHJlZ2V4LnNvdXJjZSwgZmxhZ3MpLFxuICAgICAgICAgICAgaGFzTmFtZWRDYXB0dXJlKHJlZ2V4KSA/IHhEYXRhLmNhcHR1cmVOYW1lcy5zbGljZSgwKSA6IG51bGwsXG4gICAgICAgICAgICB4cmVnZXhwU291cmNlLFxuICAgICAgICAgICAgeHJlZ2V4cEZsYWdzLFxuICAgICAgICAgICAgb3B0aW9ucy5pc0ludGVybmFsT25seVxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiByZWdleDtcbiAgICB9XG5cbi8qKlxuICogQ29udmVydHMgaGV4YWRlY2ltYWwgdG8gZGVjaW1hbC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtTdHJpbmd9IGhleFxuICogQHJldHVybnMge051bWJlcn1cbiAqL1xuICAgIGZ1bmN0aW9uIGRlYyhoZXgpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KGhleCwgMTYpO1xuICAgIH1cblxuLyoqXG4gKiBSZXR1cm5zIG5hdGl2ZSBgUmVnRXhwYCBmbGFncyB1c2VkIGJ5IGEgcmVnZXggb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1JlZ0V4cH0gcmVnZXggUmVnZXggdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBOYXRpdmUgZmxhZ3MgaW4gdXNlLlxuICovXG4gICAgZnVuY3Rpb24gZ2V0TmF0aXZlRmxhZ3MocmVnZXgpIHtcbiAgICAgICAgcmV0dXJuIGhhc0ZsYWdzUHJvcCA/XG4gICAgICAgICAgICByZWdleC5mbGFncyA6XG4gICAgICAgICAgICAvLyBFeHBsaWNpdGx5IHVzaW5nIGBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nYCAocmF0aGVyIHRoYW4gZS5nLiBgU3RyaW5nYCBvclxuICAgICAgICAgICAgLy8gY29uY2F0ZW5hdGlvbiB3aXRoIGFuIGVtcHR5IHN0cmluZykgYWxsb3dzIHRoaXMgdG8gY29udGludWUgd29ya2luZyBwcmVkaWN0YWJseSB3aGVuXG4gICAgICAgICAgICAvLyBgWFJlZ0V4cC5wcm9wdG90eXBlLnRvU3RyaW5nYCBpcyBvdmVycmlkZW5cbiAgICAgICAgICAgIG5hdGl2LmV4ZWMuY2FsbCgvXFwvKFthLXpdKikkL2ksIFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChyZWdleCkpWzFdO1xuICAgIH1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgYSByZWdleCBoYXMgZXh0ZW5kZWQgaW5zdGFuY2UgZGF0YSB1c2VkIHRvIHRyYWNrIGNhcHR1cmUgbmFtZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7UmVnRXhwfSByZWdleCBSZWdleCB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBXaGV0aGVyIHRoZSByZWdleCB1c2VzIG5hbWVkIGNhcHR1cmUuXG4gKi9cbiAgICBmdW5jdGlvbiBoYXNOYW1lZENhcHR1cmUocmVnZXgpIHtcbiAgICAgICAgcmV0dXJuICEhKHJlZ2V4W1JFR0VYX0RBVEFdICYmIHJlZ2V4W1JFR0VYX0RBVEFdLmNhcHR1cmVOYW1lcyk7XG4gICAgfVxuXG4vKipcbiAqIENvbnZlcnRzIGRlY2ltYWwgdG8gaGV4YWRlY2ltYWwuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gZGVjXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG4gICAgZnVuY3Rpb24gaGV4KGRlYykge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQoZGVjLCAxMCkudG9TdHJpbmcoMTYpO1xuICAgIH1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCBpbmRleCBhdCB3aGljaCBhIGdpdmVuIHZhbHVlIGNhbiBiZSBmb3VuZCBpbiBhbiBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgQXJyYXkgdG8gc2VhcmNoLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBsb2NhdGUgaW4gdGhlIGFycmF5LlxuICogQHJldHVybnMge051bWJlcn0gWmVyby1iYXNlZCBpbmRleCBhdCB3aGljaCB0aGUgaXRlbSBpcyBmb3VuZCwgb3IgLTEuXG4gKi9cbiAgICBmdW5jdGlvbiBpbmRleE9mKGFycmF5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgbGVuID0gYXJyYXkubGVuZ3RoLCBpO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgaWYgKGFycmF5W2ldID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgYSB2YWx1ZSBpcyBvZiB0aGUgc3BlY2lmaWVkIHR5cGUsIGJ5IHJlc29sdmluZyBpdHMgaW50ZXJuYWwgW1tDbGFzc11dLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIE9iamVjdCB0byBjaGVjay5cbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFR5cGUgdG8gY2hlY2sgZm9yLCBpbiBUaXRsZUNhc2UuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gV2hldGhlciB0aGUgb2JqZWN0IG1hdGNoZXMgdGhlIHR5cGUuXG4gKi9cbiAgICBmdW5jdGlvbiBpc1R5cGUodmFsdWUsIHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCAnICsgdHlwZSArICddJztcbiAgICB9XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgdGhlIG5leHQgbm9uaWdub3JhYmxlIHRva2VuIGFmdGVyIHRoZSBzcGVjaWZpZWQgcG9zaXRpb24gaXMgYSBxdWFudGlmaWVyLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0dGVybiBQYXR0ZXJuIHRvIHNlYXJjaCB3aXRoaW4uXG4gKiBAcGFyYW0ge051bWJlcn0gcG9zIEluZGV4IGluIGBwYXR0ZXJuYCB0byBzZWFyY2ggYXQuXG4gKiBAcGFyYW0ge1N0cmluZ30gZmxhZ3MgRmxhZ3MgdXNlZCBieSB0aGUgcGF0dGVybi5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBXaGV0aGVyIHRoZSBuZXh0IHRva2VuIGlzIGEgcXVhbnRpZmllci5cbiAqL1xuICAgIGZ1bmN0aW9uIGlzUXVhbnRpZmllck5leHQocGF0dGVybiwgcG9zLCBmbGFncykge1xuICAgICAgICByZXR1cm4gbmF0aXYudGVzdC5jYWxsKFxuICAgICAgICAgICAgZmxhZ3MuaW5kZXhPZigneCcpID4gLTEgP1xuICAgICAgICAgICAgICAgIC8vIElnbm9yZSBhbnkgbGVhZGluZyB3aGl0ZXNwYWNlLCBsaW5lIGNvbW1lbnRzLCBhbmQgaW5saW5lIGNvbW1lbnRzXG4gICAgICAgICAgICAgICAgL14oPzpcXHMrfCMuKnxcXChcXD8jW14pXSpcXCkpKig/Ols/KitdfHtcXGQrKD86LFxcZCopP30pLyA6XG4gICAgICAgICAgICAgICAgLy8gSWdub3JlIGFueSBsZWFkaW5nIGlubGluZSBjb21tZW50c1xuICAgICAgICAgICAgICAgIC9eKD86XFwoXFw/I1teKV0qXFwpKSooPzpbPyorXXx7XFxkKyg/OixcXGQqKT99KS8sXG4gICAgICAgICAgICBwYXR0ZXJuLnNsaWNlKHBvcylcbiAgICAgICAgKTtcbiAgICB9XG5cbi8qKlxuICogUGFkcyB0aGUgcHJvdmlkZWQgc3RyaW5nIHdpdGggYXMgbWFueSBsZWFkaW5nIHplcm9zIGFzIG5lZWRlZCB0byBnZXQgdG8gbGVuZ3RoIDQuIFVzZWQgdG8gcHJvZHVjZVxuICogZml4ZWQtbGVuZ3RoIGhleGFkZWNpbWFsIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuICAgIGZ1bmN0aW9uIHBhZDQoc3RyKSB7XG4gICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgNCkge1xuICAgICAgICAgICAgc3RyID0gJzAnICsgc3RyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuXG4vKipcbiAqIENoZWNrcyBmb3IgZmxhZy1yZWxhdGVkIGVycm9ycywgYW5kIHN0cmlwcy9hcHBsaWVzIGZsYWdzIGluIGEgbGVhZGluZyBtb2RlIG1vZGlmaWVyLiBPZmZsb2Fkc1xuICogdGhlIGZsYWcgcHJlcGFyYXRpb24gbG9naWMgZnJvbSB0aGUgYFhSZWdFeHBgIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0dGVybiBSZWdleCBwYXR0ZXJuLCBwb3NzaWJseSB3aXRoIGEgbGVhZGluZyBtb2RlIG1vZGlmaWVyLlxuICogQHBhcmFtIHtTdHJpbmd9IGZsYWdzIEFueSBjb21iaW5hdGlvbiBvZiBmbGFncy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IE9iamVjdCB3aXRoIHByb3BlcnRpZXMgYHBhdHRlcm5gIGFuZCBgZmxhZ3NgLlxuICovXG4gICAgZnVuY3Rpb24gcHJlcGFyZUZsYWdzKHBhdHRlcm4sIGZsYWdzKSB7XG4gICAgICAgIHZhciBpO1xuXG4gICAgICAgIC8vIFJlY2VudCBicm93c2VycyB0aHJvdyBvbiBkdXBsaWNhdGUgZmxhZ3MsIHNvIGNvcHkgdGhpcyBiZWhhdmlvciBmb3Igbm9ubmF0aXZlIGZsYWdzXG4gICAgICAgIGlmIChjbGlwRHVwbGljYXRlcyhmbGFncykgIT09IGZsYWdzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0ludmFsaWQgZHVwbGljYXRlIHJlZ2V4IGZsYWcgJyArIGZsYWdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN0cmlwIGFuZCBhcHBseSBhIGxlYWRpbmcgbW9kZSBtb2RpZmllciB3aXRoIGFueSBjb21iaW5hdGlvbiBvZiBmbGFncyBleGNlcHQgZyBvciB5XG4gICAgICAgIHBhdHRlcm4gPSBuYXRpdi5yZXBsYWNlLmNhbGwocGF0dGVybiwgL15cXChcXD8oW1xcdyRdKylcXCkvLCBmdW5jdGlvbigkMCwgJDEpIHtcbiAgICAgICAgICAgIGlmIChuYXRpdi50ZXN0LmNhbGwoL1tneV0vLCAkMSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0Nhbm5vdCB1c2UgZmxhZyBnIG9yIHkgaW4gbW9kZSBtb2RpZmllciAnICsgJDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQWxsb3cgZHVwbGljYXRlIGZsYWdzIHdpdGhpbiB0aGUgbW9kZSBtb2RpZmllclxuICAgICAgICAgICAgZmxhZ3MgPSBjbGlwRHVwbGljYXRlcyhmbGFncyArICQxKTtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gVGhyb3cgb24gdW5rbm93biBuYXRpdmUgb3Igbm9ubmF0aXZlIGZsYWdzXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBmbGFncy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKCFyZWdpc3RlcmVkRmxhZ3NbZmxhZ3MuY2hhckF0KGkpXSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignVW5rbm93biByZWdleCBmbGFnICcgKyBmbGFncy5jaGFyQXQoaSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBhdHRlcm46IHBhdHRlcm4sXG4gICAgICAgICAgICBmbGFnczogZmxhZ3NcbiAgICAgICAgfTtcbiAgICB9XG5cbi8qKlxuICogUHJlcGFyZXMgYW4gb3B0aW9ucyBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gdmFsdWUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gdmFsdWUgVmFsdWUgdG8gY29udmVydCB0byBhbiBvcHRpb25zIG9iamVjdC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IE9wdGlvbnMgb2JqZWN0LlxuICovXG4gICAgZnVuY3Rpb24gcHJlcGFyZU9wdGlvbnModmFsdWUpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7fTtcblxuICAgICAgICBpZiAoaXNUeXBlKHZhbHVlLCAnU3RyaW5nJykpIHtcbiAgICAgICAgICAgIHNlbGYuZm9yRWFjaCh2YWx1ZSwgL1teXFxzLF0rLywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zW21hdGNoXSA9IHRydWU7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4vKipcbiAqIFJlZ2lzdGVycyBhIGZsYWcgc28gaXQgZG9lc24ndCB0aHJvdyBhbiAndW5rbm93biBmbGFnJyBlcnJvci5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtTdHJpbmd9IGZsYWcgU2luZ2xlLWNoYXJhY3RlciBmbGFnIHRvIHJlZ2lzdGVyLlxuICovXG4gICAgZnVuY3Rpb24gcmVnaXN0ZXJGbGFnKGZsYWcpIHtcbiAgICAgICAgaWYgKCEvXltcXHckXSQvLnRlc3QoZmxhZykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmxhZyBtdXN0IGJlIGEgc2luZ2xlIGNoYXJhY3RlciBBLVphLXowLTlfJCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVnaXN0ZXJlZEZsYWdzW2ZsYWddID0gdHJ1ZTtcbiAgICB9XG5cbi8qKlxuICogUnVucyBidWlsdC1pbiBhbmQgY3VzdG9tIHJlZ2V4IHN5bnRheCB0b2tlbnMgaW4gcmV2ZXJzZSBpbnNlcnRpb24gb3JkZXIgYXQgdGhlIHNwZWNpZmllZFxuICogcG9zaXRpb24sIHVudGlsIGEgbWF0Y2ggaXMgZm91bmQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXR0ZXJuIE9yaWdpbmFsIHBhdHRlcm4gZnJvbSB3aGljaCBhbiBYUmVnRXhwIG9iamVjdCBpcyBiZWluZyBidWlsdC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBmbGFncyBGbGFncyBiZWluZyB1c2VkIHRvIGNvbnN0cnVjdCB0aGUgcmVnZXguXG4gKiBAcGFyYW0ge051bWJlcn0gcG9zIFBvc2l0aW9uIHRvIHNlYXJjaCBmb3IgdG9rZW5zIHdpdGhpbiBgcGF0dGVybmAuXG4gKiBAcGFyYW0ge051bWJlcn0gc2NvcGUgUmVnZXggc2NvcGUgdG8gYXBwbHk6ICdkZWZhdWx0JyBvciAnY2xhc3MnLlxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHQgQ29udGV4dCBvYmplY3QgdG8gdXNlIGZvciB0b2tlbiBoYW5kbGVyIGZ1bmN0aW9ucy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IE9iamVjdCB3aXRoIHByb3BlcnRpZXMgYG1hdGNoTGVuZ3RoYCwgYG91dHB1dGAsIGFuZCBgcmVwYXJzZWA7IG9yIGBudWxsYC5cbiAqL1xuICAgIGZ1bmN0aW9uIHJ1blRva2VucyhwYXR0ZXJuLCBmbGFncywgcG9zLCBzY29wZSwgY29udGV4dCkge1xuICAgICAgICB2YXIgaSA9IHRva2Vucy5sZW5ndGgsXG4gICAgICAgICAgICBsZWFkQ2hhciA9IHBhdHRlcm4uY2hhckF0KHBvcyksXG4gICAgICAgICAgICByZXN1bHQgPSBudWxsLFxuICAgICAgICAgICAgbWF0Y2gsXG4gICAgICAgICAgICB0O1xuXG4gICAgICAgIC8vIFJ1biBpbiByZXZlcnNlIGluc2VydGlvbiBvcmRlclxuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICB0ID0gdG9rZW5zW2ldO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICh0LmxlYWRDaGFyICYmIHQubGVhZENoYXIgIT09IGxlYWRDaGFyKSB8fFxuICAgICAgICAgICAgICAgICh0LnNjb3BlICE9PSBzY29wZSAmJiB0LnNjb3BlICE9PSAnYWxsJykgfHxcbiAgICAgICAgICAgICAgICAodC5mbGFnICYmIGZsYWdzLmluZGV4T2YodC5mbGFnKSA9PT0gLTEpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWF0Y2ggPSBzZWxmLmV4ZWMocGF0dGVybiwgdC5yZWdleCwgcG9zLCAnc3RpY2t5Jyk7XG4gICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoTGVuZ3RoOiBtYXRjaFswXS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dDogdC5oYW5kbGVyLmNhbGwoY29udGV4dCwgbWF0Y2gsIHNjb3BlLCBmbGFncyksXG4gICAgICAgICAgICAgICAgICAgIHJlcGFyc2U6IHQucmVwYXJzZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgLy8gRmluaXNoZWQgd2l0aCB0b2tlbiB0ZXN0c1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbi8qKlxuICogRW5hYmxlcyBvciBkaXNhYmxlcyBpbXBsaWNpdCBhc3RyYWwgbW9kZSBvcHQtaW4uIFdoZW4gZW5hYmxlZCwgZmxhZyBBIGlzIGF1dG9tYXRpY2FsbHkgYWRkZWQgdG9cbiAqIGFsbCBuZXcgcmVnZXhlcyBjcmVhdGVkIGJ5IFhSZWdFeHAuIFRoaXMgY2F1c2VzIGFuIGVycm9yIHRvIGJlIHRocm93biB3aGVuIGNyZWF0aW5nIHJlZ2V4ZXMgaWZcbiAqIHRoZSBVbmljb2RlIEJhc2UgYWRkb24gaXMgbm90IGF2YWlsYWJsZSwgc2luY2UgZmxhZyBBIGlzIHJlZ2lzdGVyZWQgYnkgdGhhdCBhZGRvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtCb29sZWFufSBvbiBgdHJ1ZWAgdG8gZW5hYmxlOyBgZmFsc2VgIHRvIGRpc2FibGUuXG4gKi9cbiAgICBmdW5jdGlvbiBzZXRBc3RyYWwob24pIHtcbiAgICAgICAgZmVhdHVyZXMuYXN0cmFsID0gb247XG4gICAgfVxuXG4vKipcbiAqIEVuYWJsZXMgb3IgZGlzYWJsZXMgbmF0aXZlIG1ldGhvZCBvdmVycmlkZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb24gYHRydWVgIHRvIGVuYWJsZTsgYGZhbHNlYCB0byBkaXNhYmxlLlxuICovXG4gICAgZnVuY3Rpb24gc2V0TmF0aXZlcyhvbikge1xuICAgICAgICBSZWdFeHAucHJvdG90eXBlLmV4ZWMgPSAob24gPyBmaXhlZCA6IG5hdGl2KS5leGVjO1xuICAgICAgICBSZWdFeHAucHJvdG90eXBlLnRlc3QgPSAob24gPyBmaXhlZCA6IG5hdGl2KS50ZXN0O1xuICAgICAgICBTdHJpbmcucHJvdG90eXBlLm1hdGNoID0gKG9uID8gZml4ZWQgOiBuYXRpdikubWF0Y2g7XG4gICAgICAgIFN0cmluZy5wcm90b3R5cGUucmVwbGFjZSA9IChvbiA/IGZpeGVkIDogbmF0aXYpLnJlcGxhY2U7XG4gICAgICAgIFN0cmluZy5wcm90b3R5cGUuc3BsaXQgPSAob24gPyBmaXhlZCA6IG5hdGl2KS5zcGxpdDtcblxuICAgICAgICBmZWF0dXJlcy5uYXRpdmVzID0gb247XG4gICAgfVxuXG4vKipcbiAqIFJldHVybnMgdGhlIG9iamVjdCwgb3IgdGhyb3dzIGFuIGVycm9yIGlmIGl0IGlzIGBudWxsYCBvciBgdW5kZWZpbmVkYC4gVGhpcyBpcyB1c2VkIHRvIGZvbGxvd1xuICogdGhlIEVTNSBhYnN0cmFjdCBvcGVyYXRpb24gYFRvT2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBPYmplY3QgdG8gY2hlY2sgYW5kIHJldHVybi5cbiAqIEByZXR1cm5zIHsqfSBUaGUgcHJvdmlkZWQgb2JqZWN0LlxuICovXG4gICAgZnVuY3Rpb24gdG9PYmplY3QodmFsdWUpIHtcbiAgICAgICAgLy8gbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IG51bGwgb3IgdW5kZWZpbmVkIHRvIG9iamVjdCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb25zdHJ1Y3RvclxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cbi8qKlxuICogQ3JlYXRlcyBhbiBleHRlbmRlZCByZWd1bGFyIGV4cHJlc3Npb24gb2JqZWN0IGZvciBtYXRjaGluZyB0ZXh0IHdpdGggYSBwYXR0ZXJuLiBEaWZmZXJzIGZyb20gYVxuICogbmF0aXZlIHJlZ3VsYXIgZXhwcmVzc2lvbiBpbiB0aGF0IGFkZGl0aW9uYWwgc3ludGF4IGFuZCBmbGFncyBhcmUgc3VwcG9ydGVkLiBUaGUgcmV0dXJuZWQgb2JqZWN0XG4gKiBpcyBpbiBmYWN0IGEgbmF0aXZlIGBSZWdFeHBgIGFuZCB3b3JrcyB3aXRoIGFsbCBuYXRpdmUgbWV0aG9kcy5cbiAqXG4gKiBAY2xhc3MgWFJlZ0V4cFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB9IHBhdHRlcm4gUmVnZXggcGF0dGVybiBzdHJpbmcsIG9yIGFuIGV4aXN0aW5nIHJlZ2V4IG9iamVjdCB0byBjb3B5LlxuICogQHBhcmFtIHtTdHJpbmd9IFtmbGFnc10gQW55IGNvbWJpbmF0aW9uIG9mIGZsYWdzLlxuICogICBOYXRpdmUgZmxhZ3M6XG4gKiAgICAgPGxpPmBnYCAtIGdsb2JhbFxuICogICAgIDxsaT5gaWAgLSBpZ25vcmUgY2FzZVxuICogICAgIDxsaT5gbWAgLSBtdWx0aWxpbmUgYW5jaG9yc1xuICogICAgIDxsaT5gdWAgLSB1bmljb2RlIChFUzYpXG4gKiAgICAgPGxpPmB5YCAtIHN0aWNreSAoRmlyZWZveCAzKywgRVM2KVxuICogICBBZGRpdGlvbmFsIFhSZWdFeHAgZmxhZ3M6XG4gKiAgICAgPGxpPmBuYCAtIGV4cGxpY2l0IGNhcHR1cmVcbiAqICAgICA8bGk+YHNgIC0gZG90IG1hdGNoZXMgYWxsIChha2Egc2luZ2xlbGluZSlcbiAqICAgICA8bGk+YHhgIC0gZnJlZS1zcGFjaW5nIGFuZCBsaW5lIGNvbW1lbnRzIChha2EgZXh0ZW5kZWQpXG4gKiAgICAgPGxpPmBBYCAtIGFzdHJhbCAocmVxdWlyZXMgdGhlIFVuaWNvZGUgQmFzZSBhZGRvbilcbiAqICAgRmxhZ3MgY2Fubm90IGJlIHByb3ZpZGVkIHdoZW4gY29uc3RydWN0aW5nIG9uZSBgUmVnRXhwYCBmcm9tIGFub3RoZXIuXG4gKiBAcmV0dXJucyB7UmVnRXhwfSBFeHRlbmRlZCByZWd1bGFyIGV4cHJlc3Npb24gb2JqZWN0LlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBXaXRoIG5hbWVkIGNhcHR1cmUgYW5kIGZsYWcgeFxuICogWFJlZ0V4cCgnKD88eWVhcj4gIFswLTldezR9ICkgLT8gICMgeWVhciAgXFxuXFxcbiAqICAgICAgICAgICg/PG1vbnRoPiBbMC05XXsyfSApIC0/ICAjIG1vbnRoIFxcblxcXG4gKiAgICAgICAgICAoPzxkYXk+ICAgWzAtOV17Mn0gKSAgICAgIyBkYXkgICAnLCAneCcpO1xuICpcbiAqIC8vIFByb3ZpZGluZyBhIHJlZ2V4IG9iamVjdCBjb3BpZXMgaXQuIE5hdGl2ZSByZWdleGVzIGFyZSByZWNvbXBpbGVkIHVzaW5nIG5hdGl2ZSAobm90IFhSZWdFeHApXG4gKiAvLyBzeW50YXguIENvcGllcyBtYWludGFpbiBleHRlbmRlZCBkYXRhLCBhcmUgYXVnbWVudGVkIHdpdGggYFhSZWdFeHAucHJvdG90eXBlYCBwcm9wZXJ0aWVzLCBhbmRcbiAqIC8vIGhhdmUgZnJlc2ggYGxhc3RJbmRleGAgcHJvcGVydGllcyAoc2V0IHRvIHplcm8pLlxuICogWFJlZ0V4cCgvcmVnZXgvKTtcbiAqL1xuICAgIHNlbGYgPSBmdW5jdGlvbihwYXR0ZXJuLCBmbGFncykge1xuICAgICAgICB2YXIgY29udGV4dCA9IHtcbiAgICAgICAgICAgICAgICBoYXNOYW1lZENhcHR1cmU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNhcHR1cmVOYW1lczogW11cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzY29wZSA9IGRlZmF1bHRTY29wZSxcbiAgICAgICAgICAgIG91dHB1dCA9ICcnLFxuICAgICAgICAgICAgcG9zID0gMCxcbiAgICAgICAgICAgIHJlc3VsdCxcbiAgICAgICAgICAgIHRva2VuLFxuICAgICAgICAgICAgZ2VuZXJhdGVkLFxuICAgICAgICAgICAgYXBwbGllZFBhdHRlcm4sXG4gICAgICAgICAgICBhcHBsaWVkRmxhZ3M7XG5cbiAgICAgICAgaWYgKHNlbGYuaXNSZWdFeHAocGF0dGVybikpIHtcbiAgICAgICAgICAgIGlmIChmbGFncyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IHN1cHBseSBmbGFncyB3aGVuIGNvcHlpbmcgYSBSZWdFeHAnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb3B5UmVnZXgocGF0dGVybik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb3B5IHRoZSBhcmd1bWVudCBiZWhhdmlvciBvZiBgUmVnRXhwYFxuICAgICAgICBwYXR0ZXJuID0gcGF0dGVybiA9PT0gdW5kZWZpbmVkID8gJycgOiBTdHJpbmcocGF0dGVybik7XG4gICAgICAgIGZsYWdzID0gZmxhZ3MgPT09IHVuZGVmaW5lZCA/ICcnIDogU3RyaW5nKGZsYWdzKTtcblxuICAgICAgICBpZiAoc2VsZi5pc0luc3RhbGxlZCgnYXN0cmFsJykgJiYgZmxhZ3MuaW5kZXhPZignQScpID09PSAtMSkge1xuICAgICAgICAgICAgLy8gVGhpcyBjYXVzZXMgYW4gZXJyb3IgdG8gYmUgdGhyb3duIGlmIHRoZSBVbmljb2RlIEJhc2UgYWRkb24gaXMgbm90IGF2YWlsYWJsZVxuICAgICAgICAgICAgZmxhZ3MgKz0gJ0EnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFwYXR0ZXJuQ2FjaGVbcGF0dGVybl0pIHtcbiAgICAgICAgICAgIHBhdHRlcm5DYWNoZVtwYXR0ZXJuXSA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFwYXR0ZXJuQ2FjaGVbcGF0dGVybl1bZmxhZ3NdKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgZmxhZy1yZWxhdGVkIGVycm9ycywgYW5kIHN0cmlwL2FwcGx5IGZsYWdzIGluIGEgbGVhZGluZyBtb2RlIG1vZGlmaWVyXG4gICAgICAgICAgICByZXN1bHQgPSBwcmVwYXJlRmxhZ3MocGF0dGVybiwgZmxhZ3MpO1xuICAgICAgICAgICAgYXBwbGllZFBhdHRlcm4gPSByZXN1bHQucGF0dGVybjtcbiAgICAgICAgICAgIGFwcGxpZWRGbGFncyA9IHJlc3VsdC5mbGFncztcblxuICAgICAgICAgICAgLy8gVXNlIFhSZWdFeHAncyB0b2tlbnMgdG8gdHJhbnNsYXRlIHRoZSBwYXR0ZXJuIHRvIGEgbmF0aXZlIHJlZ2V4IHBhdHRlcm4uXG4gICAgICAgICAgICAvLyBgYXBwbGllZFBhdHRlcm4ubGVuZ3RoYCBtYXkgY2hhbmdlIG9uIGVhY2ggaXRlcmF0aW9uIGlmIHRva2VucyB1c2UgYHJlcGFyc2VgXG4gICAgICAgICAgICB3aGlsZSAocG9zIDwgYXBwbGllZFBhdHRlcm4ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBmb3IgY3VzdG9tIHRva2VucyBhdCB0aGUgY3VycmVudCBwb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBydW5Ub2tlbnMoYXBwbGllZFBhdHRlcm4sIGFwcGxpZWRGbGFncywgcG9zLCBzY29wZSwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBtYXRjaGVkIHRva2VuIHVzZWQgdGhlIGByZXBhcnNlYCBvcHRpb24sIHNwbGljZSBpdHMgb3V0cHV0IGludG8gdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIHBhdHRlcm4gYmVmb3JlIHJ1bm5pbmcgdG9rZW5zIGFnYWluIGF0IHRoZSBzYW1lIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0LnJlcGFyc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwcGxpZWRQYXR0ZXJuID0gYXBwbGllZFBhdHRlcm4uc2xpY2UoMCwgcG9zKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lm91dHB1dCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwbGllZFBhdHRlcm4uc2xpY2UocG9zICsgcmVzdWx0Lm1hdGNoTGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gd2hpbGUgKHJlc3VsdCAmJiByZXN1bHQucmVwYXJzZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dCArPSByZXN1bHQub3V0cHV0O1xuICAgICAgICAgICAgICAgICAgICBwb3MgKz0gKHJlc3VsdC5tYXRjaExlbmd0aCB8fCAxKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIG5hdGl2ZSB0b2tlbiBhdCB0aGUgY3VycmVudCBwb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHNlbGYuZXhlYyhhcHBsaWVkUGF0dGVybiwgbmF0aXZlVG9rZW5zW3Njb3BlXSwgcG9zLCAnc3RpY2t5JylbMF07XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dCArPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgcG9zICs9IHRva2VuLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuID09PSAnWycgJiYgc2NvcGUgPT09IGRlZmF1bHRTY29wZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUgPSBjbGFzc1Njb3BlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRva2VuID09PSAnXScgJiYgc2NvcGUgPT09IGNsYXNzU2NvcGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlID0gZGVmYXVsdFNjb3BlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwYXR0ZXJuQ2FjaGVbcGF0dGVybl1bZmxhZ3NdID0ge1xuICAgICAgICAgICAgICAgIC8vIENsZWFudXAgdG9rZW4gY3J1ZnQ6IHJlcGVhdGVkIGAoPzopKD86KWAgYW5kIGxlYWRpbmcvdHJhaWxpbmcgYCg/OilgXG4gICAgICAgICAgICAgICAgcGF0dGVybjogbmF0aXYucmVwbGFjZS5jYWxsKG91dHB1dCwgL1xcKFxcPzpcXCkoPz1cXChcXD86XFwpKXxeXFwoXFw/OlxcKXxcXChcXD86XFwpJC9nLCAnJyksXG4gICAgICAgICAgICAgICAgLy8gU3RyaXAgYWxsIGJ1dCBuYXRpdmUgZmxhZ3NcbiAgICAgICAgICAgICAgICBmbGFnczogbmF0aXYucmVwbGFjZS5jYWxsKGFwcGxpZWRGbGFncywgL1teZ2ltdXldKy9nLCAnJyksXG4gICAgICAgICAgICAgICAgLy8gYGNvbnRleHQuY2FwdHVyZU5hbWVzYCBoYXMgYW4gaXRlbSBmb3IgZWFjaCBjYXB0dXJpbmcgZ3JvdXAsIGV2ZW4gaWYgdW5uYW1lZFxuICAgICAgICAgICAgICAgIGNhcHR1cmVzOiBjb250ZXh0Lmhhc05hbWVkQ2FwdHVyZSA/IGNvbnRleHQuY2FwdHVyZU5hbWVzIDogbnVsbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdlbmVyYXRlZCA9IHBhdHRlcm5DYWNoZVtwYXR0ZXJuXVtmbGFnc107XG4gICAgICAgIHJldHVybiBhdWdtZW50KFxuICAgICAgICAgICAgbmV3IFJlZ0V4cChnZW5lcmF0ZWQucGF0dGVybiwgZ2VuZXJhdGVkLmZsYWdzKSxcbiAgICAgICAgICAgIGdlbmVyYXRlZC5jYXB0dXJlcyxcbiAgICAgICAgICAgIHBhdHRlcm4sXG4gICAgICAgICAgICBmbGFnc1xuICAgICAgICApO1xuICAgIH07XG5cbi8vIEFkZCBgUmVnRXhwLnByb3RvdHlwZWAgdG8gdGhlIHByb3RvdHlwZSBjaGFpblxuICAgIHNlbGYucHJvdG90eXBlID0gbmV3IFJlZ0V4cCgpO1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFB1YmxpYyBwcm9wZXJ0aWVzXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuLyoqXG4gKiBUaGUgWFJlZ0V4cCB2ZXJzaW9uIG51bWJlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgWFJlZ0V4cFxuICogQHR5cGUgU3RyaW5nXG4gKi9cbiAgICBzZWxmLnZlcnNpb24gPSAnMy4wLjAnO1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFB1YmxpYyBtZXRob2RzXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuLyoqXG4gKiBFeHRlbmRzIFhSZWdFeHAgc3ludGF4IGFuZCBhbGxvd3MgY3VzdG9tIGZsYWdzLiBUaGlzIGlzIHVzZWQgaW50ZXJuYWxseSBhbmQgY2FuIGJlIHVzZWQgdG9cbiAqIGNyZWF0ZSBYUmVnRXhwIGFkZG9ucy4gSWYgbW9yZSB0aGFuIG9uZSB0b2tlbiBjYW4gbWF0Y2ggdGhlIHNhbWUgc3RyaW5nLCB0aGUgbGFzdCBhZGRlZCB3aW5zLlxuICpcbiAqIEBtZW1iZXJPZiBYUmVnRXhwXG4gKiBAcGFyYW0ge1JlZ0V4cH0gcmVnZXggUmVnZXggb2JqZWN0IHRoYXQgbWF0Y2hlcyB0aGUgbmV3IHRva2VuLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBGdW5jdGlvbiB0aGF0IHJldHVybnMgYSBuZXcgcGF0dGVybiBzdHJpbmcgKHVzaW5nIG5hdGl2ZSByZWdleCBzeW50YXgpXG4gKiAgIHRvIHJlcGxhY2UgdGhlIG1hdGNoZWQgdG9rZW4gd2l0aGluIGFsbCBmdXR1cmUgWFJlZ0V4cCByZWdleGVzLiBIYXMgYWNjZXNzIHRvIHBlcnNpc3RlbnRcbiAqICAgcHJvcGVydGllcyBvZiB0aGUgcmVnZXggYmVpbmcgYnVpbHQsIHRocm91Z2ggYHRoaXNgLiBJbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOlxuICogICA8bGk+VGhlIG1hdGNoIGFycmF5LCB3aXRoIG5hbWVkIGJhY2tyZWZlcmVuY2UgcHJvcGVydGllcy5cbiAqICAgPGxpPlRoZSByZWdleCBzY29wZSB3aGVyZSB0aGUgbWF0Y2ggd2FzIGZvdW5kOiAnZGVmYXVsdCcgb3IgJ2NsYXNzJy5cbiAqICAgPGxpPlRoZSBmbGFncyB1c2VkIGJ5IHRoZSByZWdleCwgaW5jbHVkaW5nIGFueSBmbGFncyBpbiBhIGxlYWRpbmcgbW9kZSBtb2RpZmllci5cbiAqICAgVGhlIGhhbmRsZXIgZnVuY3Rpb24gYmVjb21lcyBwYXJ0IG9mIHRoZSBYUmVnRXhwIGNvbnN0cnVjdGlvbiBwcm9jZXNzLCBzbyBiZSBjYXJlZnVsIG5vdCB0b1xuICogICBjb25zdHJ1Y3QgWFJlZ0V4cHMgd2l0aGluIHRoZSBmdW5jdGlvbiBvciB5b3Ugd2lsbCB0cmlnZ2VyIGluZmluaXRlIHJlY3Vyc2lvbi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3Qgd2l0aCBvcHRpb25hbCBwcm9wZXJ0aWVzOlxuICogICA8bGk+YHNjb3BlYCB7U3RyaW5nfSBTY29wZSB3aGVyZSB0aGUgdG9rZW4gYXBwbGllczogJ2RlZmF1bHQnLCAnY2xhc3MnLCBvciAnYWxsJy5cbiAqICAgPGxpPmBmbGFnYCB7U3RyaW5nfSBTaW5nbGUtY2hhcmFjdGVyIGZsYWcgdGhhdCB0cmlnZ2VycyB0aGUgdG9rZW4uIFRoaXMgYWxzbyByZWdpc3RlcnMgdGhlXG4gKiAgICAgZmxhZywgd2hpY2ggcHJldmVudHMgWFJlZ0V4cCBmcm9tIHRocm93aW5nIGFuICd1bmtub3duIGZsYWcnIGVycm9yIHdoZW4gdGhlIGZsYWcgaXMgdXNlZC5cbiAqICAgPGxpPmBvcHRpb25hbEZsYWdzYCB7U3RyaW5nfSBBbnkgY3VzdG9tIGZsYWdzIGNoZWNrZWQgZm9yIHdpdGhpbiB0aGUgdG9rZW4gYGhhbmRsZXJgIHRoYXQgYXJlXG4gKiAgICAgbm90IHJlcXVpcmVkIHRvIHRyaWdnZXIgdGhlIHRva2VuLiBUaGlzIHJlZ2lzdGVycyB0aGUgZmxhZ3MsIHRvIHByZXZlbnQgWFJlZ0V4cCBmcm9tXG4gKiAgICAgdGhyb3dpbmcgYW4gJ3Vua25vd24gZmxhZycgZXJyb3Igd2hlbiBhbnkgb2YgdGhlIGZsYWdzIGFyZSB1c2VkLlxuICogICA8bGk+YHJlcGFyc2VgIHtCb29sZWFufSBXaGV0aGVyIHRoZSBgaGFuZGxlcmAgZnVuY3Rpb24ncyBvdXRwdXQgc2hvdWxkIG5vdCBiZSB0cmVhdGVkIGFzXG4gKiAgICAgZmluYWwsIGFuZCBpbnN0ZWFkIGJlIHJlcGFyc2VhYmxlIGJ5IG90aGVyIHRva2VucyAoaW5jbHVkaW5nIHRoZSBjdXJyZW50IHRva2VuKS4gQWxsb3dzXG4gKiAgICAgdG9rZW4gY2hhaW5pbmcgb3IgZGVmZXJyaW5nLlxuICogICA8bGk+YGxlYWRDaGFyYCB7U3RyaW5nfSBTaW5nbGUgY2hhcmFjdGVyIHRoYXQgb2NjdXJzIGF0IHRoZSBiZWdpbm5pbmcgb2YgYW55IHN1Y2Nlc3NmdWwgbWF0Y2hcbiAqICAgICBvZiB0aGUgdG9rZW4gKG5vdCBhbHdheXMgYXBwbGljYWJsZSkuIFRoaXMgZG9lc24ndCBjaGFuZ2UgdGhlIGJlaGF2aW9yIG9mIHRoZSB0b2tlbiB1bmxlc3NcbiAqICAgICB5b3UgcHJvdmlkZSBhbiBlcnJvbmVvdXMgdmFsdWUuIEhvd2V2ZXIsIHByb3ZpZGluZyBpdCBjYW4gaW5jcmVhc2UgdGhlIHRva2VuJ3MgcGVyZm9ybWFuY2UuXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIEJhc2ljIHVzYWdlOiBBZGQgXFxhIGZvciB0aGUgQUxFUlQgY29udHJvbCBjb2RlXG4gKiBYUmVnRXhwLmFkZFRva2VuKFxuICogICAvXFxcXGEvLFxuICogICBmdW5jdGlvbigpIHtyZXR1cm4gJ1xcXFx4MDcnO30sXG4gKiAgIHtzY29wZTogJ2FsbCd9XG4gKiApO1xuICogWFJlZ0V4cCgnXFxcXGFbXFxcXGEtXFxcXG5dKycpLnRlc3QoJ1xceDA3XFxuXFx4MDcnKTsgLy8gLT4gdHJ1ZVxuICpcbiAqIC8vIEFkZCB0aGUgVSAodW5ncmVlZHkpIGZsYWcgZnJvbSBQQ1JFIGFuZCBSRTIsIHdoaWNoIHJldmVyc2VzIGdyZWVkeSBhbmQgbGF6eSBxdWFudGlmaWVyc1xuICogWFJlZ0V4cC5hZGRUb2tlbihcbiAqICAgLyhbPyorXXx7XFxkKyg/OixcXGQqKT99KShcXD8/KS8sXG4gKiAgIGZ1bmN0aW9uKG1hdGNoKSB7cmV0dXJuIG1hdGNoWzFdICsgKG1hdGNoWzJdID8gJycgOiAnPycpO30sXG4gKiAgIHtmbGFnOiAnVSd9XG4gKiApO1xuICogWFJlZ0V4cCgnYSsnLCAnVScpLmV4ZWMoJ2FhYScpWzBdOyAvLyAtPiAnYSdcbiAqIFhSZWdFeHAoJ2ErPycsICdVJykuZXhlYygnYWFhJylbMF07IC8vIC0+ICdhYWEnXG4gKi9cbiAgICBzZWxmLmFkZFRva2VuID0gZnVuY3Rpb24ocmVnZXgsIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIHZhciBvcHRpb25hbEZsYWdzID0gb3B0aW9ucy5vcHRpb25hbEZsYWdzLCBpO1xuXG4gICAgICAgIGlmIChvcHRpb25zLmZsYWcpIHtcbiAgICAgICAgICAgIHJlZ2lzdGVyRmxhZyhvcHRpb25zLmZsYWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbmFsRmxhZ3MpIHtcbiAgICAgICAgICAgIG9wdGlvbmFsRmxhZ3MgPSBuYXRpdi5zcGxpdC5jYWxsKG9wdGlvbmFsRmxhZ3MsICcnKTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBvcHRpb25hbEZsYWdzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgcmVnaXN0ZXJGbGFnKG9wdGlvbmFsRmxhZ3NbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIHRvIHRoZSBwcml2YXRlIGxpc3Qgb2Ygc3ludGF4IHRva2Vuc1xuICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgICByZWdleDogY29weVJlZ2V4KHJlZ2V4LCB7XG4gICAgICAgICAgICAgICAgYWRkRzogdHJ1ZSxcbiAgICAgICAgICAgICAgICBhZGRZOiBoYXNOYXRpdmVZLFxuICAgICAgICAgICAgICAgIGlzSW50ZXJuYWxPbmx5OiB0cnVlXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGhhbmRsZXI6IGhhbmRsZXIsXG4gICAgICAgICAgICBzY29wZTogb3B0aW9ucy5zY29wZSB8fCBkZWZhdWx0U2NvcGUsXG4gICAgICAgICAgICBmbGFnOiBvcHRpb25zLmZsYWcsXG4gICAgICAgICAgICByZXBhcnNlOiBvcHRpb25zLnJlcGFyc2UsXG4gICAgICAgICAgICBsZWFkQ2hhcjogb3B0aW9ucy5sZWFkQ2hhclxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBSZXNldCB0aGUgcGF0dGVybiBjYWNoZSB1c2VkIGJ5IHRoZSBgWFJlZ0V4cGAgY29uc3RydWN0b3IsIHNpbmNlIHRoZSBzYW1lIHBhdHRlcm4gYW5kXG4gICAgICAgIC8vIGZsYWdzIG1pZ2h0IG5vdyBwcm9kdWNlIGRpZmZlcmVudCByZXN1bHRzXG4gICAgICAgIHNlbGYuY2FjaGUuZmx1c2goJ3BhdHRlcm5zJyk7XG4gICAgfTtcblxuLyoqXG4gKiBDYWNoZXMgYW5kIHJldHVybnMgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBYUmVnRXhwKHBhdHRlcm4sIGZsYWdzKWAuIE9uIGFueSBzdWJzZXF1ZW50IGNhbGwgd2l0aFxuICogdGhlIHNhbWUgcGF0dGVybiBhbmQgZmxhZyBjb21iaW5hdGlvbiwgdGhlIGNhY2hlZCBjb3B5IG9mIHRoZSByZWdleCBpcyByZXR1cm5lZC5cbiAqXG4gKiBAbWVtYmVyT2YgWFJlZ0V4cFxuICogQHBhcmFtIHtTdHJpbmd9IHBhdHRlcm4gUmVnZXggcGF0dGVybiBzdHJpbmcuXG4gKiBAcGFyYW0ge1N0cmluZ30gW2ZsYWdzXSBBbnkgY29tYmluYXRpb24gb2YgWFJlZ0V4cCBmbGFncy5cbiAqIEByZXR1cm5zIHtSZWdFeHB9IENhY2hlZCBYUmVnRXhwIG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKlxuICogd2hpbGUgKG1hdGNoID0gWFJlZ0V4cC5jYWNoZSgnLicsICdncycpLmV4ZWMoc3RyKSkge1xuICogICAvLyBUaGUgcmVnZXggaXMgY29tcGlsZWQgb25jZSBvbmx5XG4gKiB9XG4gKi9cbiAgICBzZWxmLmNhY2hlID0gZnVuY3Rpb24ocGF0dGVybiwgZmxhZ3MpIHtcbiAgICAgICAgaWYgKCFyZWdleENhY2hlW3BhdHRlcm5dKSB7XG4gICAgICAgICAgICByZWdleENhY2hlW3BhdHRlcm5dID0ge307XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlZ2V4Q2FjaGVbcGF0dGVybl1bZmxhZ3NdIHx8IChcbiAgICAgICAgICAgIHJlZ2V4Q2FjaGVbcGF0dGVybl1bZmxhZ3NdID0gc2VsZihwYXR0ZXJuLCBmbGFncylcbiAgICAgICAgKTtcbiAgICB9O1xuXG4vLyBJbnRlbnRpb25hbGx5IHVuZG9jdW1lbnRlZFxuICAgIHNlbGYuY2FjaGUuZmx1c2ggPSBmdW5jdGlvbihjYWNoZU5hbWUpIHtcbiAgICAgICAgaWYgKGNhY2hlTmFtZSA9PT0gJ3BhdHRlcm5zJykge1xuICAgICAgICAgICAgLy8gRmx1c2ggdGhlIHBhdHRlcm4gY2FjaGUgdXNlZCBieSB0aGUgYFhSZWdFeHBgIGNvbnN0cnVjdG9yXG4gICAgICAgICAgICBwYXR0ZXJuQ2FjaGUgPSB7fTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEZsdXNoIHRoZSByZWdleCBjYWNoZSBwb3B1bGF0ZWQgYnkgYFhSZWdFeHAuY2FjaGVgXG4gICAgICAgICAgICByZWdleENhY2hlID0ge307XG4gICAgICAgIH1cbiAgICB9O1xuXG4vKipcbiAqIEVzY2FwZXMgYW55IHJlZ3VsYXIgZXhwcmVzc2lvbiBtZXRhY2hhcmFjdGVycywgZm9yIHVzZSB3aGVuIG1hdGNoaW5nIGxpdGVyYWwgc3RyaW5ncy4gVGhlIHJlc3VsdFxuICogY2FuIHNhZmVseSBiZSB1c2VkIGF0IGFueSBwb2ludCB3aXRoaW4gYSByZWdleCB0aGF0IHVzZXMgYW55IGZsYWdzLlxuICpcbiAqIEBtZW1iZXJPZiBYUmVnRXhwXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFN0cmluZyB0byBlc2NhcGUuXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBTdHJpbmcgd2l0aCByZWdleCBtZXRhY2hhcmFjdGVycyBlc2NhcGVkLlxuICogQGV4YW1wbGVcbiAqXG4gKiBYUmVnRXhwLmVzY2FwZSgnRXNjYXBlZD8gPC4+Jyk7XG4gKiAvLyAtPiAnRXNjYXBlZFxcP1xcIDxcXC4+J1xuICovXG4gICAgc2VsZi5lc2NhcGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgcmV0dXJuIG5hdGl2LnJlcGxhY2UuY2FsbCh0b09iamVjdChzdHIpLCAvWy1bXFxde30oKSorPy4sXFxcXF4kfCNcXHNdL2csICdcXFxcJCYnKTtcbiAgICB9O1xuXG4vKipcbiAqIEV4ZWN1dGVzIGEgcmVnZXggc2VhcmNoIGluIGEgc3BlY2lmaWVkIHN0cmluZy4gUmV0dXJucyBhIG1hdGNoIGFycmF5IG9yIGBudWxsYC4gSWYgdGhlIHByb3ZpZGVkXG4gKiByZWdleCB1c2VzIG5hbWVkIGNhcHR1cmUsIG5hbWVkIGJhY2tyZWZlcmVuY2UgcHJvcGVydGllcyBhcmUgaW5jbHVkZWQgb24gdGhlIG1hdGNoIGFycmF5LlxuICogT3B0aW9uYWwgYHBvc2AgYW5kIGBzdGlja3lgIGFyZ3VtZW50cyBzcGVjaWZ5IHRoZSBzZWFyY2ggc3RhcnQgcG9zaXRpb24sIGFuZCB3aGV0aGVyIHRoZSBtYXRjaFxuICogbXVzdCBzdGFydCBhdCB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uIG9ubHkuIFRoZSBgbGFzdEluZGV4YCBwcm9wZXJ0eSBvZiB0aGUgcHJvdmlkZWQgcmVnZXggaXMgbm90XG4gKiB1c2VkLCBidXQgaXMgdXBkYXRlZCBmb3IgY29tcGF0aWJpbGl0eS4gQWxzbyBmaXhlcyBicm93c2VyIGJ1Z3MgY29tcGFyZWQgdG8gdGhlIG5hdGl2ZVxuICogYFJlZ0V4cC5wcm90b3R5cGUuZXhlY2AgYW5kIGNhbiBiZSB1c2VkIHJlbGlhYmx5IGNyb3NzLWJyb3dzZXIuXG4gKlxuICogQG1lbWJlck9mIFhSZWdFeHBcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgU3RyaW5nIHRvIHNlYXJjaC5cbiAqIEBwYXJhbSB7UmVnRXhwfSByZWdleCBSZWdleCB0byBzZWFyY2ggd2l0aC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbcG9zPTBdIFplcm8tYmFzZWQgaW5kZXggYXQgd2hpY2ggdG8gc3RhcnQgdGhlIHNlYXJjaC5cbiAqIEBwYXJhbSB7Qm9vbGVhbnxTdHJpbmd9IFtzdGlja3k9ZmFsc2VdIFdoZXRoZXIgdGhlIG1hdGNoIG11c3Qgc3RhcnQgYXQgdGhlIHNwZWNpZmllZCBwb3NpdGlvblxuICogICBvbmx5LiBUaGUgc3RyaW5nIGAnc3RpY2t5J2AgaXMgYWNjZXB0ZWQgYXMgYW4gYWx0ZXJuYXRpdmUgdG8gYHRydWVgLlxuICogQHJldHVybnMge0FycmF5fSBNYXRjaCBhcnJheSB3aXRoIG5hbWVkIGJhY2tyZWZlcmVuY2UgcHJvcGVydGllcywgb3IgYG51bGxgLlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBCYXNpYyB1c2UsIHdpdGggbmFtZWQgYmFja3JlZmVyZW5jZVxuICogdmFyIG1hdGNoID0gWFJlZ0V4cC5leGVjKCdVKzI2MjAnLCBYUmVnRXhwKCdVXFxcXCsoPzxoZXg+WzAtOUEtRl17NH0pJykpO1xuICogbWF0Y2guaGV4OyAvLyAtPiAnMjYyMCdcbiAqXG4gKiAvLyBXaXRoIHBvcyBhbmQgc3RpY2t5LCBpbiBhIGxvb3BcbiAqIHZhciBwb3MgPSAyLCByZXN1bHQgPSBbXSwgbWF0Y2g7XG4gKiB3aGlsZSAobWF0Y2ggPSBYUmVnRXhwLmV4ZWMoJzwxPjwyPjwzPjw0PjU8Nj4nLCAvPChcXGQpPi8sIHBvcywgJ3N0aWNreScpKSB7XG4gKiAgIHJlc3VsdC5wdXNoKG1hdGNoWzFdKTtcbiAqICAgcG9zID0gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG4gKiB9XG4gKiAvLyByZXN1bHQgLT4gWycyJywgJzMnLCAnNCddXG4gKi9cbiAgICBzZWxmLmV4ZWMgPSBmdW5jdGlvbihzdHIsIHJlZ2V4LCBwb3MsIHN0aWNreSkge1xuICAgICAgICB2YXIgY2FjaGVLZXkgPSAnZycsXG4gICAgICAgICAgICBhZGRZID0gZmFsc2UsXG4gICAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICAgIHIyO1xuXG4gICAgICAgIGFkZFkgPSBoYXNOYXRpdmVZICYmICEhKHN0aWNreSB8fCAocmVnZXguc3RpY2t5ICYmIHN0aWNreSAhPT0gZmFsc2UpKTtcbiAgICAgICAgaWYgKGFkZFkpIHtcbiAgICAgICAgICAgIGNhY2hlS2V5ICs9ICd5JztcbiAgICAgICAgfVxuXG4gICAgICAgIHJlZ2V4W1JFR0VYX0RBVEFdID0gcmVnZXhbUkVHRVhfREFUQV0gfHwge307XG5cbiAgICAgICAgLy8gU2hhcmVzIGNhY2hlZCBjb3BpZXMgd2l0aCBgWFJlZ0V4cC5tYXRjaGAvYHJlcGxhY2VgXG4gICAgICAgIHIyID0gcmVnZXhbUkVHRVhfREFUQV1bY2FjaGVLZXldIHx8IChcbiAgICAgICAgICAgIHJlZ2V4W1JFR0VYX0RBVEFdW2NhY2hlS2V5XSA9IGNvcHlSZWdleChyZWdleCwge1xuICAgICAgICAgICAgICAgIGFkZEc6IHRydWUsXG4gICAgICAgICAgICAgICAgYWRkWTogYWRkWSxcbiAgICAgICAgICAgICAgICByZW1vdmVZOiBzdGlja3kgPT09IGZhbHNlLFxuICAgICAgICAgICAgICAgIGlzSW50ZXJuYWxPbmx5OiB0cnVlXG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuXG4gICAgICAgIHIyLmxhc3RJbmRleCA9IHBvcyA9IHBvcyB8fCAwO1xuXG4gICAgICAgIC8vIEZpeGVkIGBleGVjYCByZXF1aXJlZCBmb3IgYGxhc3RJbmRleGAgZml4LCBuYW1lZCBiYWNrcmVmZXJlbmNlcywgZXRjLlxuICAgICAgICBtYXRjaCA9IGZpeGVkLmV4ZWMuY2FsbChyMiwgc3RyKTtcblxuICAgICAgICBpZiAoc3RpY2t5ICYmIG1hdGNoICYmIG1hdGNoLmluZGV4ICE9PSBwb3MpIHtcbiAgICAgICAgICAgIG1hdGNoID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZWdleC5nbG9iYWwpIHtcbiAgICAgICAgICAgIHJlZ2V4Lmxhc3RJbmRleCA9IG1hdGNoID8gcjIubGFzdEluZGV4IDogMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9O1xuXG4vKipcbiAqIEV4ZWN1dGVzIGEgcHJvdmlkZWQgZnVuY3Rpb24gb25jZSBwZXIgcmVnZXggbWF0Y2guXG4gKlxuICogQG1lbWJlck9mIFhSZWdFeHBcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgU3RyaW5nIHRvIHNlYXJjaC5cbiAqIEBwYXJhbSB7UmVnRXhwfSByZWdleCBSZWdleCB0byBzZWFyY2ggd2l0aC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgZm9yIGVhY2ggbWF0Y2guIEludm9rZWQgd2l0aCBmb3VyIGFyZ3VtZW50czpcbiAqICAgPGxpPlRoZSBtYXRjaCBhcnJheSwgd2l0aCBuYW1lZCBiYWNrcmVmZXJlbmNlIHByb3BlcnRpZXMuXG4gKiAgIDxsaT5UaGUgemVyby1iYXNlZCBtYXRjaCBpbmRleC5cbiAqICAgPGxpPlRoZSBzdHJpbmcgYmVpbmcgdHJhdmVyc2VkLlxuICogICA8bGk+VGhlIHJlZ2V4IG9iamVjdCBiZWluZyB1c2VkIHRvIHRyYXZlcnNlIHRoZSBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIEV4dHJhY3RzIGV2ZXJ5IG90aGVyIGRpZ2l0IGZyb20gYSBzdHJpbmdcbiAqIFhSZWdFeHAuZm9yRWFjaCgnMWEyMzQ1JywgL1xcZC8sIGZ1bmN0aW9uKG1hdGNoLCBpKSB7XG4gKiAgIGlmIChpICUgMikgdGhpcy5wdXNoKCttYXRjaFswXSk7XG4gKiB9LCBbXSk7XG4gKiAvLyAtPiBbMiwgNF1cbiAqL1xuICAgIHNlbGYuZm9yRWFjaCA9IGZ1bmN0aW9uKHN0ciwgcmVnZXgsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBwb3MgPSAwLFxuICAgICAgICAgICAgaSA9IC0xLFxuICAgICAgICAgICAgbWF0Y2g7XG5cbiAgICAgICAgd2hpbGUgKChtYXRjaCA9IHNlbGYuZXhlYyhzdHIsIHJlZ2V4LCBwb3MpKSkge1xuICAgICAgICAgICAgLy8gQmVjYXVzZSBgcmVnZXhgIGlzIHByb3ZpZGVkIHRvIGBjYWxsYmFja2AsIHRoZSBmdW5jdGlvbiBjb3VsZCB1c2UgdGhlIGRlcHJlY2F0ZWQvXG4gICAgICAgICAgICAvLyBub25zdGFuZGFyZCBgUmVnRXhwLnByb3RvdHlwZS5jb21waWxlYCB0byBtdXRhdGUgdGhlIHJlZ2V4LiBIb3dldmVyLCBzaW5jZVxuICAgICAgICAgICAgLy8gYFhSZWdFeHAuZXhlY2AgZG9lc24ndCB1c2UgYGxhc3RJbmRleGAgdG8gc2V0IHRoZSBzZWFyY2ggcG9zaXRpb24sIHRoaXMgY2FuJ3QgbGVhZFxuICAgICAgICAgICAgLy8gdG8gYW4gaW5maW5pdGUgbG9vcCwgYXQgbGVhc3QuIEFjdHVhbGx5LCBiZWNhdXNlIG9mIHRoZSB3YXkgYFhSZWdFeHAuZXhlY2AgY2FjaGVzXG4gICAgICAgICAgICAvLyBnbG9iYWxpemVkIHZlcnNpb25zIG9mIHJlZ2V4ZXMsIG11dGF0aW5nIHRoZSByZWdleCB3aWxsIG5vdCBoYXZlIGFueSBlZmZlY3Qgb24gdGhlXG4gICAgICAgICAgICAvLyBpdGVyYXRpb24gb3IgbWF0Y2hlZCBzdHJpbmdzLCB3aGljaCBpcyBhIG5pY2Ugc2lkZSBlZmZlY3QgdGhhdCBicmluZ3MgZXh0cmEgc2FmZXR5XG4gICAgICAgICAgICBjYWxsYmFjayhtYXRjaCwgKytpLCBzdHIsIHJlZ2V4KTtcblxuICAgICAgICAgICAgcG9zID0gbWF0Y2guaW5kZXggKyAobWF0Y2hbMF0ubGVuZ3RoIHx8IDEpO1xuICAgICAgICB9XG4gICAgfTtcblxuLyoqXG4gKiBDb3BpZXMgYSByZWdleCBvYmplY3QgYW5kIGFkZHMgZmxhZyBgZ2AuIFRoZSBjb3B5IG1haW50YWlucyBleHRlbmRlZCBkYXRhLCBpcyBhdWdtZW50ZWQgd2l0aFxuICogYFhSZWdFeHAucHJvdG90eXBlYCBwcm9wZXJ0aWVzLCBhbmQgaGFzIGEgZnJlc2ggYGxhc3RJbmRleGAgcHJvcGVydHkgKHNldCB0byB6ZXJvKS4gTmF0aXZlXG4gKiByZWdleGVzIGFyZSBub3QgcmVjb21waWxlZCB1c2luZyBYUmVnRXhwIHN5bnRheC5cbiAqXG4gKiBAbWVtYmVyT2YgWFJlZ0V4cFxuICogQHBhcmFtIHtSZWdFeHB9IHJlZ2V4IFJlZ2V4IHRvIGdsb2JhbGl6ZS5cbiAqIEByZXR1cm5zIHtSZWdFeHB9IENvcHkgb2YgdGhlIHByb3ZpZGVkIHJlZ2V4IHdpdGggZmxhZyBgZ2AgYWRkZWQuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBnbG9iYWxDb3B5ID0gWFJlZ0V4cC5nbG9iYWxpemUoL3JlZ2V4Lyk7XG4gKiBnbG9iYWxDb3B5Lmdsb2JhbDsgLy8gLT4gdHJ1ZVxuICovXG4gICAgc2VsZi5nbG9iYWxpemUgPSBmdW5jdGlvbihyZWdleCkge1xuICAgICAgICByZXR1cm4gY29weVJlZ2V4KHJlZ2V4LCB7YWRkRzogdHJ1ZX0pO1xuICAgIH07XG5cbi8qKlxuICogSW5zdGFsbHMgb3B0aW9uYWwgZmVhdHVyZXMgYWNjb3JkaW5nIHRvIHRoZSBzcGVjaWZpZWQgb3B0aW9ucy4gQ2FuIGJlIHVuZG9uZSB1c2luZ1xuICoge0BsaW5rICNYUmVnRXhwLnVuaW5zdGFsbH0uXG4gKlxuICogQG1lbWJlck9mIFhSZWdFeHBcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gb3B0aW9ucyBPcHRpb25zIG9iamVjdCBvciBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIFdpdGggYW4gb3B0aW9ucyBvYmplY3RcbiAqIFhSZWdFeHAuaW5zdGFsbCh7XG4gKiAgIC8vIEVuYWJsZXMgc3VwcG9ydCBmb3IgYXN0cmFsIGNvZGUgcG9pbnRzIGluIFVuaWNvZGUgYWRkb25zIChpbXBsaWNpdGx5IHNldHMgZmxhZyBBKVxuICogICBhc3RyYWw6IHRydWUsXG4gKlxuICogICAvLyBPdmVycmlkZXMgbmF0aXZlIHJlZ2V4IG1ldGhvZHMgd2l0aCBmaXhlZC9leHRlbmRlZCB2ZXJzaW9ucyB0aGF0IHN1cHBvcnQgbmFtZWRcbiAqICAgLy8gYmFja3JlZmVyZW5jZXMgYW5kIGZpeCBudW1lcm91cyBjcm9zcy1icm93c2VyIGJ1Z3NcbiAqICAgbmF0aXZlczogdHJ1ZVxuICogfSk7XG4gKlxuICogLy8gV2l0aCBhbiBvcHRpb25zIHN0cmluZ1xuICogWFJlZ0V4cC5pbnN0YWxsKCdhc3RyYWwgbmF0aXZlcycpO1xuICovXG4gICAgc2VsZi5pbnN0YWxsID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gcHJlcGFyZU9wdGlvbnMob3B0aW9ucyk7XG5cbiAgICAgICAgaWYgKCFmZWF0dXJlcy5hc3RyYWwgJiYgb3B0aW9ucy5hc3RyYWwpIHtcbiAgICAgICAgICAgIHNldEFzdHJhbCh0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZmVhdHVyZXMubmF0aXZlcyAmJiBvcHRpb25zLm5hdGl2ZXMpIHtcbiAgICAgICAgICAgIHNldE5hdGl2ZXModHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGFuIGluZGl2aWR1YWwgb3B0aW9uYWwgZmVhdHVyZSBpcyBpbnN0YWxsZWQuXG4gKlxuICogQG1lbWJlck9mIFhSZWdFeHBcbiAqIEBwYXJhbSB7U3RyaW5nfSBmZWF0dXJlIE5hbWUgb2YgdGhlIGZlYXR1cmUgdG8gY2hlY2suIE9uZSBvZjpcbiAqICAgPGxpPmBuYXRpdmVzYFxuICogICA8bGk+YGFzdHJhbGBcbiAqIEByZXR1cm5zIHtCb29sZWFufSBXaGV0aGVyIHRoZSBmZWF0dXJlIGlzIGluc3RhbGxlZC5cbiAqIEBleGFtcGxlXG4gKlxuICogWFJlZ0V4cC5pc0luc3RhbGxlZCgnbmF0aXZlcycpO1xuICovXG4gICAgc2VsZi5pc0luc3RhbGxlZCA9IGZ1bmN0aW9uKGZlYXR1cmUpIHtcbiAgICAgICAgcmV0dXJuICEhKGZlYXR1cmVzW2ZlYXR1cmVdKTtcbiAgICB9O1xuXG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIGFuIG9iamVjdCBpcyBhIHJlZ2V4OyBgZmFsc2VgIGlmIGl0IGlzbid0LiBUaGlzIHdvcmtzIGNvcnJlY3RseSBmb3IgcmVnZXhlc1xuICogY3JlYXRlZCBpbiBhbm90aGVyIGZyYW1lLCB3aGVuIGBpbnN0YW5jZW9mYCBhbmQgYGNvbnN0cnVjdG9yYCBjaGVja3Mgd291bGQgZmFpbC5cbiAqXG4gKiBAbWVtYmVyT2YgWFJlZ0V4cFxuICogQHBhcmFtIHsqfSB2YWx1ZSBPYmplY3QgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gV2hldGhlciB0aGUgb2JqZWN0IGlzIGEgYFJlZ0V4cGAgb2JqZWN0LlxuICogQGV4YW1wbGVcbiAqXG4gKiBYUmVnRXhwLmlzUmVnRXhwKCdzdHJpbmcnKTsgLy8gLT4gZmFsc2VcbiAqIFhSZWdFeHAuaXNSZWdFeHAoL3JlZ2V4L2kpOyAvLyAtPiB0cnVlXG4gKiBYUmVnRXhwLmlzUmVnRXhwKFJlZ0V4cCgnXicsICdtJykpOyAvLyAtPiB0cnVlXG4gKiBYUmVnRXhwLmlzUmVnRXhwKFhSZWdFeHAoJyg/cykuJykpOyAvLyAtPiB0cnVlXG4gKi9cbiAgICBzZWxmLmlzUmVnRXhwID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbiAgICAgICAgLy9yZXR1cm4gaXNUeXBlKHZhbHVlLCAnUmVnRXhwJyk7XG4gICAgfTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCBtYXRjaGVkIHN0cmluZywgb3IgaW4gZ2xvYmFsIG1vZGUsIGFuIGFycmF5IGNvbnRhaW5pbmcgYWxsIG1hdGNoZWQgc3RyaW5ncy5cbiAqIFRoaXMgaXMgZXNzZW50aWFsbHkgYSBtb3JlIGNvbnZlbmllbnQgcmUtaW1wbGVtZW50YXRpb24gb2YgYFN0cmluZy5wcm90b3R5cGUubWF0Y2hgIHRoYXQgZ2l2ZXNcbiAqIHRoZSByZXN1bHQgdHlwZXMgeW91IGFjdHVhbGx5IHdhbnQgKHN0cmluZyBpbnN0ZWFkIG9mIGBleGVjYC1zdHlsZSBhcnJheSBpbiBtYXRjaC1maXJzdCBtb2RlLFxuICogYW5kIGFuIGVtcHR5IGFycmF5IGluc3RlYWQgb2YgYG51bGxgIHdoZW4gbm8gbWF0Y2hlcyBhcmUgZm91bmQgaW4gbWF0Y2gtYWxsIG1vZGUpLiBJdCBhbHNvIGxldHNcbiAqIHlvdSBvdmVycmlkZSBmbGFnIGcgYW5kIGlnbm9yZSBgbGFzdEluZGV4YCwgYW5kIGZpeGVzIGJyb3dzZXIgYnVncy5cbiAqXG4gKiBAbWVtYmVyT2YgWFJlZ0V4cFxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBTdHJpbmcgdG8gc2VhcmNoLlxuICogQHBhcmFtIHtSZWdFeHB9IHJlZ2V4IFJlZ2V4IHRvIHNlYXJjaCB3aXRoLlxuICogQHBhcmFtIHtTdHJpbmd9IFtzY29wZT0nb25lJ10gVXNlICdvbmUnIHRvIHJldHVybiB0aGUgZmlyc3QgbWF0Y2ggYXMgYSBzdHJpbmcuIFVzZSAnYWxsJyB0b1xuICogICByZXR1cm4gYW4gYXJyYXkgb2YgYWxsIG1hdGNoZWQgc3RyaW5ncy4gSWYgbm90IGV4cGxpY2l0bHkgc3BlY2lmaWVkIGFuZCBgcmVnZXhgIHVzZXMgZmxhZyBnLFxuICogICBgc2NvcGVgIGlzICdhbGwnLlxuICogQHJldHVybnMge1N0cmluZ3xBcnJheX0gSW4gbWF0Y2gtZmlyc3QgbW9kZTogRmlyc3QgbWF0Y2ggYXMgYSBzdHJpbmcsIG9yIGBudWxsYC4gSW4gbWF0Y2gtYWxsXG4gKiAgIG1vZGU6IEFycmF5IG9mIGFsbCBtYXRjaGVkIHN0cmluZ3MsIG9yIGFuIGVtcHR5IGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBNYXRjaCBmaXJzdFxuICogWFJlZ0V4cC5tYXRjaCgnYWJjJywgL1xcdy8pOyAvLyAtPiAnYSdcbiAqIFhSZWdFeHAubWF0Y2goJ2FiYycsIC9cXHcvZywgJ29uZScpOyAvLyAtPiAnYSdcbiAqIFhSZWdFeHAubWF0Y2goJ2FiYycsIC94L2csICdvbmUnKTsgLy8gLT4gbnVsbFxuICpcbiAqIC8vIE1hdGNoIGFsbFxuICogWFJlZ0V4cC5tYXRjaCgnYWJjJywgL1xcdy9nKTsgLy8gLT4gWydhJywgJ2InLCAnYyddXG4gKiBYUmVnRXhwLm1hdGNoKCdhYmMnLCAvXFx3LywgJ2FsbCcpOyAvLyAtPiBbJ2EnLCAnYicsICdjJ11cbiAqIFhSZWdFeHAubWF0Y2goJ2FiYycsIC94LywgJ2FsbCcpOyAvLyAtPiBbXVxuICovXG4gICAgc2VsZi5tYXRjaCA9IGZ1bmN0aW9uKHN0ciwgcmVnZXgsIHNjb3BlKSB7XG4gICAgICAgIHZhciBnbG9iYWwgPSAocmVnZXguZ2xvYmFsICYmIHNjb3BlICE9PSAnb25lJykgfHwgc2NvcGUgPT09ICdhbGwnLFxuICAgICAgICAgICAgY2FjaGVLZXkgPSAoKGdsb2JhbCA/ICdnJyA6ICcnKSArIChyZWdleC5zdGlja3kgPyAneScgOiAnJykpIHx8ICdub0dZJyxcbiAgICAgICAgICAgIHJlc3VsdCxcbiAgICAgICAgICAgIHIyO1xuXG4gICAgICAgIHJlZ2V4W1JFR0VYX0RBVEFdID0gcmVnZXhbUkVHRVhfREFUQV0gfHwge307XG5cbiAgICAgICAgLy8gU2hhcmVzIGNhY2hlZCBjb3BpZXMgd2l0aCBgWFJlZ0V4cC5leGVjYC9gcmVwbGFjZWBcbiAgICAgICAgcjIgPSByZWdleFtSRUdFWF9EQVRBXVtjYWNoZUtleV0gfHwgKFxuICAgICAgICAgICAgcmVnZXhbUkVHRVhfREFUQV1bY2FjaGVLZXldID0gY29weVJlZ2V4KHJlZ2V4LCB7XG4gICAgICAgICAgICAgICAgYWRkRzogISFnbG9iYWwsXG4gICAgICAgICAgICAgICAgYWRkWTogISFyZWdleC5zdGlja3ksXG4gICAgICAgICAgICAgICAgcmVtb3ZlRzogc2NvcGUgPT09ICdvbmUnLFxuICAgICAgICAgICAgICAgIGlzSW50ZXJuYWxPbmx5OiB0cnVlXG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuXG4gICAgICAgIHJlc3VsdCA9IG5hdGl2Lm1hdGNoLmNhbGwodG9PYmplY3Qoc3RyKSwgcjIpO1xuXG4gICAgICAgIGlmIChyZWdleC5nbG9iYWwpIHtcbiAgICAgICAgICAgIHJlZ2V4Lmxhc3RJbmRleCA9IChcbiAgICAgICAgICAgICAgICAoc2NvcGUgPT09ICdvbmUnICYmIHJlc3VsdCkgP1xuICAgICAgICAgICAgICAgICAgICAvLyBDYW4ndCB1c2UgYHIyLmxhc3RJbmRleGAgc2luY2UgYHIyYCBpcyBub25nbG9iYWwgaW4gdGhpcyBjYXNlXG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHQuaW5kZXggKyByZXN1bHRbMF0ubGVuZ3RoKSA6IDBcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2xvYmFsID8gKHJlc3VsdCB8fCBbXSkgOiAocmVzdWx0ICYmIHJlc3VsdFswXSk7XG4gICAgfTtcblxuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIG1hdGNoZXMgZnJvbSBzZWFyY2hpbmcgYSBzdHJpbmcgdXNpbmcgYSBjaGFpbiBvZiByZWdleGVzIHRoYXQgc3VjY2Vzc2l2ZWx5IHNlYXJjaFxuICogd2l0aGluIHByZXZpb3VzIG1hdGNoZXMuIFRoZSBwcm92aWRlZCBgY2hhaW5gIGFycmF5IGNhbiBjb250YWluIHJlZ2V4ZXMgYW5kIG9iamVjdHMgd2l0aCBgcmVnZXhgXG4gKiBhbmQgYGJhY2tyZWZgIHByb3BlcnRpZXMuIFdoZW4gYSBiYWNrcmVmZXJlbmNlIGlzIHNwZWNpZmllZCwgdGhlIG5hbWVkIG9yIG51bWJlcmVkIGJhY2tyZWZlcmVuY2VcbiAqIGlzIHBhc3NlZCBmb3J3YXJkIHRvIHRoZSBuZXh0IHJlZ2V4IG9yIHJldHVybmVkLlxuICpcbiAqIEBtZW1iZXJPZiBYUmVnRXhwXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFN0cmluZyB0byBzZWFyY2guXG4gKiBAcGFyYW0ge0FycmF5fSBjaGFpbiBSZWdleGVzIHRoYXQgZWFjaCBzZWFyY2ggZm9yIG1hdGNoZXMgd2l0aGluIHByZWNlZGluZyByZXN1bHRzLlxuICogQHJldHVybnMge0FycmF5fSBNYXRjaGVzIGJ5IHRoZSBsYXN0IHJlZ2V4IGluIHRoZSBjaGFpbiwgb3IgYW4gZW1wdHkgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIEJhc2ljIHVzYWdlOyBtYXRjaGVzIG51bWJlcnMgd2l0aGluIDxiPiB0YWdzXG4gKiBYUmVnRXhwLm1hdGNoQ2hhaW4oJzEgPGI+MjwvYj4gMyA8Yj40IGEgNTY8L2I+JywgW1xuICogICBYUmVnRXhwKCcoP2lzKTxiPi4qPzwvYj4nKSxcbiAqICAgL1xcZCsvXG4gKiBdKTtcbiAqIC8vIC0+IFsnMicsICc0JywgJzU2J11cbiAqXG4gKiAvLyBQYXNzaW5nIGZvcndhcmQgYW5kIHJldHVybmluZyBzcGVjaWZpYyBiYWNrcmVmZXJlbmNlc1xuICogaHRtbCA9ICc8YSBocmVmPVwiaHR0cDovL3hyZWdleHAuY29tL2FwaS9cIj5YUmVnRXhwPC9hPlxcXG4gKiAgICAgICAgIDxhIGhyZWY9XCJodHRwOi8vd3d3Lmdvb2dsZS5jb20vXCI+R29vZ2xlPC9hPic7XG4gKiBYUmVnRXhwLm1hdGNoQ2hhaW4oaHRtbCwgW1xuICogICB7cmVnZXg6IC88YSBocmVmPVwiKFteXCJdKylcIj4vaSwgYmFja3JlZjogMX0sXG4gKiAgIHtyZWdleDogWFJlZ0V4cCgnKD9pKV5odHRwcz86Ly8oPzxkb21haW4+W14vPyNdKyknKSwgYmFja3JlZjogJ2RvbWFpbid9XG4gKiBdKTtcbiAqIC8vIC0+IFsneHJlZ2V4cC5jb20nLCAnd3d3Lmdvb2dsZS5jb20nXVxuICovXG4gICAgc2VsZi5tYXRjaENoYWluID0gZnVuY3Rpb24oc3RyLCBjaGFpbikge1xuICAgICAgICByZXR1cm4gKGZ1bmN0aW9uIHJlY3Vyc2VDaGFpbih2YWx1ZXMsIGxldmVsKSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IGNoYWluW2xldmVsXS5yZWdleCA/IGNoYWluW2xldmVsXSA6IHtyZWdleDogY2hhaW5bbGV2ZWxdfSxcbiAgICAgICAgICAgICAgICBtYXRjaGVzID0gW10sXG4gICAgICAgICAgICAgICAgYWRkTWF0Y2ggPSBmdW5jdGlvbihtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5iYWNrcmVmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBTYWZhcmkgNC4wLjUgKGJ1dCBub3QgNS4wLjUrKSBpbmFwcHJvcHJpYXRlbHkgdXNlcyBzcGFyc2UgYXJyYXlzIHRvIGhvbGRcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIHRoZSBgdW5kZWZpbmVkYHMgZm9yIGJhY2tyZWZlcmVuY2VzIHRvIG5vbnBhcnRpY2lwYXRpbmcgY2FwdHVyaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBncm91cHMuIEluIHN1Y2ggY2FzZXMsIGEgYGhhc093blByb3BlcnR5YCBvciBgaW5gIGNoZWNrIG9uIGl0cyBvd24gd291bGRcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIGluYXBwcm9wcmlhdGVseSB0aHJvdyB0aGUgZXhjZXB0aW9uLCBzbyBhbHNvIGNoZWNrIGlmIHRoZSBiYWNrcmVmZXJlbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBpcyBhIG51bWJlciB0aGF0IGlzIHdpdGhpbiB0aGUgYm91bmRzIG9mIHRoZSBhcnJheS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobWF0Y2guaGFzT3duUHJvcGVydHkoaXRlbS5iYWNrcmVmKSB8fCAraXRlbS5iYWNrcmVmIDwgbWF0Y2gubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcignQmFja3JlZmVyZW5jZSB0byB1bmRlZmluZWQgZ3JvdXA6ICcgKyBpdGVtLmJhY2tyZWYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVzLnB1c2gobWF0Y2hbaXRlbS5iYWNrcmVmXSB8fCAnJyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVzLnB1c2gobWF0Y2hbMF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5mb3JFYWNoKHZhbHVlc1tpXSwgaXRlbS5yZWdleCwgYWRkTWF0Y2gpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gKChsZXZlbCA9PT0gY2hhaW4ubGVuZ3RoIC0gMSkgfHwgIW1hdGNoZXMubGVuZ3RoKSA/XG4gICAgICAgICAgICAgICAgbWF0Y2hlcyA6XG4gICAgICAgICAgICAgICAgcmVjdXJzZUNoYWluKG1hdGNoZXMsIGxldmVsICsgMSk7XG4gICAgICAgIH0oW3N0cl0sIDApKTtcbiAgICB9O1xuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgc3RyaW5nIHdpdGggb25lIG9yIGFsbCBtYXRjaGVzIG9mIGEgcGF0dGVybiByZXBsYWNlZC4gVGhlIHBhdHRlcm4gY2FuIGJlIGEgc3RyaW5nXG4gKiBvciByZWdleCwgYW5kIHRoZSByZXBsYWNlbWVudCBjYW4gYmUgYSBzdHJpbmcgb3IgYSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgZm9yIGVhY2ggbWF0Y2guIFRvXG4gKiBwZXJmb3JtIGEgZ2xvYmFsIHNlYXJjaCBhbmQgcmVwbGFjZSwgdXNlIHRoZSBvcHRpb25hbCBgc2NvcGVgIGFyZ3VtZW50IG9yIGluY2x1ZGUgZmxhZyBnIGlmIHVzaW5nXG4gKiBhIHJlZ2V4LiBSZXBsYWNlbWVudCBzdHJpbmdzIGNhbiB1c2UgYCR7bn1gIGZvciBuYW1lZCBhbmQgbnVtYmVyZWQgYmFja3JlZmVyZW5jZXMuIFJlcGxhY2VtZW50XG4gKiBmdW5jdGlvbnMgY2FuIHVzZSBuYW1lZCBiYWNrcmVmZXJlbmNlcyB2aWEgYGFyZ3VtZW50c1swXS5uYW1lYC4gQWxzbyBmaXhlcyBicm93c2VyIGJ1Z3MgY29tcGFyZWRcbiAqIHRvIHRoZSBuYXRpdmUgYFN0cmluZy5wcm90b3R5cGUucmVwbGFjZWAgYW5kIGNhbiBiZSB1c2VkIHJlbGlhYmx5IGNyb3NzLWJyb3dzZXIuXG4gKlxuICogQG1lbWJlck9mIFhSZWdFeHBcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgU3RyaW5nIHRvIHNlYXJjaC5cbiAqIEBwYXJhbSB7UmVnRXhwfFN0cmluZ30gc2VhcmNoIFNlYXJjaCBwYXR0ZXJuIHRvIGJlIHJlcGxhY2VkLlxuICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IHJlcGxhY2VtZW50IFJlcGxhY2VtZW50IHN0cmluZyBvciBhIGZ1bmN0aW9uIGludm9rZWQgdG8gY3JlYXRlIGl0LlxuICogICBSZXBsYWNlbWVudCBzdHJpbmdzIGNhbiBpbmNsdWRlIHNwZWNpYWwgcmVwbGFjZW1lbnQgc3ludGF4OlxuICogICAgIDxsaT4kJCAtIEluc2VydHMgYSBsaXRlcmFsICQgY2hhcmFjdGVyLlxuICogICAgIDxsaT4kJiwgJDAgLSBJbnNlcnRzIHRoZSBtYXRjaGVkIHN1YnN0cmluZy5cbiAqICAgICA8bGk+JGAgLSBJbnNlcnRzIHRoZSBzdHJpbmcgdGhhdCBwcmVjZWRlcyB0aGUgbWF0Y2hlZCBzdWJzdHJpbmcgKGxlZnQgY29udGV4dCkuXG4gKiAgICAgPGxpPiQnIC0gSW5zZXJ0cyB0aGUgc3RyaW5nIHRoYXQgZm9sbG93cyB0aGUgbWF0Y2hlZCBzdWJzdHJpbmcgKHJpZ2h0IGNvbnRleHQpLlxuICogICAgIDxsaT4kbiwgJG5uIC0gV2hlcmUgbi9ubiBhcmUgZGlnaXRzIHJlZmVyZW5jaW5nIGFuIGV4aXN0ZW50IGNhcHR1cmluZyBncm91cCwgaW5zZXJ0c1xuICogICAgICAgYmFja3JlZmVyZW5jZSBuL25uLlxuICogICAgIDxsaT4ke259IC0gV2hlcmUgbiBpcyBhIG5hbWUgb3IgYW55IG51bWJlciBvZiBkaWdpdHMgdGhhdCByZWZlcmVuY2UgYW4gZXhpc3RlbnQgY2FwdHVyaW5nXG4gKiAgICAgICBncm91cCwgaW5zZXJ0cyBiYWNrcmVmZXJlbmNlIG4uXG4gKiAgIFJlcGxhY2VtZW50IGZ1bmN0aW9ucyBhcmUgaW52b2tlZCB3aXRoIHRocmVlIG9yIG1vcmUgYXJndW1lbnRzOlxuICogICAgIDxsaT5UaGUgbWF0Y2hlZCBzdWJzdHJpbmcgKGNvcnJlc3BvbmRzIHRvICQmIGFib3ZlKS4gTmFtZWQgYmFja3JlZmVyZW5jZXMgYXJlIGFjY2Vzc2libGUgYXNcbiAqICAgICAgIHByb3BlcnRpZXMgb2YgdGhpcyBmaXJzdCBhcmd1bWVudC5cbiAqICAgICA8bGk+MC4ubiBhcmd1bWVudHMsIG9uZSBmb3IgZWFjaCBiYWNrcmVmZXJlbmNlIChjb3JyZXNwb25kaW5nIHRvICQxLCAkMiwgZXRjLiBhYm92ZSkuXG4gKiAgICAgPGxpPlRoZSB6ZXJvLWJhc2VkIGluZGV4IG9mIHRoZSBtYXRjaCB3aXRoaW4gdGhlIHRvdGFsIHNlYXJjaCBzdHJpbmcuXG4gKiAgICAgPGxpPlRoZSB0b3RhbCBzdHJpbmcgYmVpbmcgc2VhcmNoZWQuXG4gKiBAcGFyYW0ge1N0cmluZ30gW3Njb3BlPSdvbmUnXSBVc2UgJ29uZScgdG8gcmVwbGFjZSB0aGUgZmlyc3QgbWF0Y2ggb25seSwgb3IgJ2FsbCcuIElmIG5vdFxuICogICBleHBsaWNpdGx5IHNwZWNpZmllZCBhbmQgdXNpbmcgYSByZWdleCB3aXRoIGZsYWcgZywgYHNjb3BlYCBpcyAnYWxsJy5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IE5ldyBzdHJpbmcgd2l0aCBvbmUgb3IgYWxsIG1hdGNoZXMgcmVwbGFjZWQuXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIFJlZ2V4IHNlYXJjaCwgdXNpbmcgbmFtZWQgYmFja3JlZmVyZW5jZXMgaW4gcmVwbGFjZW1lbnQgc3RyaW5nXG4gKiB2YXIgbmFtZSA9IFhSZWdFeHAoJyg/PGZpcnN0PlxcXFx3KykgKD88bGFzdD5cXFxcdyspJyk7XG4gKiBYUmVnRXhwLnJlcGxhY2UoJ0pvaG4gU21pdGgnLCBuYW1lLCAnJHtsYXN0fSwgJHtmaXJzdH0nKTtcbiAqIC8vIC0+ICdTbWl0aCwgSm9obidcbiAqXG4gKiAvLyBSZWdleCBzZWFyY2gsIHVzaW5nIG5hbWVkIGJhY2tyZWZlcmVuY2VzIGluIHJlcGxhY2VtZW50IGZ1bmN0aW9uXG4gKiBYUmVnRXhwLnJlcGxhY2UoJ0pvaG4gU21pdGgnLCBuYW1lLCBmdW5jdGlvbihtYXRjaCkge1xuICogICByZXR1cm4gbWF0Y2gubGFzdCArICcsICcgKyBtYXRjaC5maXJzdDtcbiAqIH0pO1xuICogLy8gLT4gJ1NtaXRoLCBKb2huJ1xuICpcbiAqIC8vIFN0cmluZyBzZWFyY2gsIHdpdGggcmVwbGFjZS1hbGxcbiAqIFhSZWdFeHAucmVwbGFjZSgnUmVnRXhwIGJ1aWxkcyBSZWdFeHBzJywgJ1JlZ0V4cCcsICdYUmVnRXhwJywgJ2FsbCcpO1xuICogLy8gLT4gJ1hSZWdFeHAgYnVpbGRzIFhSZWdFeHBzJ1xuICovXG4gICAgc2VsZi5yZXBsYWNlID0gZnVuY3Rpb24oc3RyLCBzZWFyY2gsIHJlcGxhY2VtZW50LCBzY29wZSkge1xuICAgICAgICB2YXIgaXNSZWdleCA9IHNlbGYuaXNSZWdFeHAoc2VhcmNoKSxcbiAgICAgICAgICAgIGdsb2JhbCA9IChzZWFyY2guZ2xvYmFsICYmIHNjb3BlICE9PSAnb25lJykgfHwgc2NvcGUgPT09ICdhbGwnLFxuICAgICAgICAgICAgY2FjaGVLZXkgPSAoKGdsb2JhbCA/ICdnJyA6ICcnKSArIChzZWFyY2guc3RpY2t5ID8gJ3knIDogJycpKSB8fCAnbm9HWScsXG4gICAgICAgICAgICBzMiA9IHNlYXJjaCxcbiAgICAgICAgICAgIHJlc3VsdDtcblxuICAgICAgICBpZiAoaXNSZWdleCkge1xuICAgICAgICAgICAgc2VhcmNoW1JFR0VYX0RBVEFdID0gc2VhcmNoW1JFR0VYX0RBVEFdIHx8IHt9O1xuXG4gICAgICAgICAgICAvLyBTaGFyZXMgY2FjaGVkIGNvcGllcyB3aXRoIGBYUmVnRXhwLmV4ZWNgL2BtYXRjaGAuIFNpbmNlIGEgY29weSBpcyB1c2VkLCBgc2VhcmNoYCdzXG4gICAgICAgICAgICAvLyBgbGFzdEluZGV4YCBpc24ndCB1cGRhdGVkICpkdXJpbmcqIHJlcGxhY2VtZW50IGl0ZXJhdGlvbnNcbiAgICAgICAgICAgIHMyID0gc2VhcmNoW1JFR0VYX0RBVEFdW2NhY2hlS2V5XSB8fCAoXG4gICAgICAgICAgICAgICAgc2VhcmNoW1JFR0VYX0RBVEFdW2NhY2hlS2V5XSA9IGNvcHlSZWdleChzZWFyY2gsIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkRzogISFnbG9iYWwsXG4gICAgICAgICAgICAgICAgICAgIGFkZFk6ICEhc2VhcmNoLnN0aWNreSxcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlRzogc2NvcGUgPT09ICdvbmUnLFxuICAgICAgICAgICAgICAgICAgICBpc0ludGVybmFsT25seTogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKGdsb2JhbCkge1xuICAgICAgICAgICAgczIgPSBuZXcgUmVnRXhwKHNlbGYuZXNjYXBlKFN0cmluZyhzZWFyY2gpKSwgJ2cnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZpeGVkIGByZXBsYWNlYCByZXF1aXJlZCBmb3IgbmFtZWQgYmFja3JlZmVyZW5jZXMsIGV0Yy5cbiAgICAgICAgcmVzdWx0ID0gZml4ZWQucmVwbGFjZS5jYWxsKHRvT2JqZWN0KHN0ciksIHMyLCByZXBsYWNlbWVudCk7XG5cbiAgICAgICAgaWYgKGlzUmVnZXggJiYgc2VhcmNoLmdsb2JhbCkge1xuICAgICAgICAgICAgLy8gRml4ZXMgSUUsIFNhZmFyaSBidWcgKGxhc3QgdGVzdGVkIElFIDksIFNhZmFyaSA1LjEpXG4gICAgICAgICAgICBzZWFyY2gubGFzdEluZGV4ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuLyoqXG4gKiBQZXJmb3JtcyBiYXRjaCBwcm9jZXNzaW5nIG9mIHN0cmluZyByZXBsYWNlbWVudHMuIFVzZWQgbGlrZSB7QGxpbmsgI1hSZWdFeHAucmVwbGFjZX0sIGJ1dFxuICogYWNjZXB0cyBhbiBhcnJheSBvZiByZXBsYWNlbWVudCBkZXRhaWxzLiBMYXRlciByZXBsYWNlbWVudHMgb3BlcmF0ZSBvbiB0aGUgb3V0cHV0IG9mIGVhcmxpZXJcbiAqIHJlcGxhY2VtZW50cy4gUmVwbGFjZW1lbnQgZGV0YWlscyBhcmUgYWNjZXB0ZWQgYXMgYW4gYXJyYXkgd2l0aCBhIHJlZ2V4IG9yIHN0cmluZyB0byBzZWFyY2ggZm9yLFxuICogdGhlIHJlcGxhY2VtZW50IHN0cmluZyBvciBmdW5jdGlvbiwgYW5kIGFuIG9wdGlvbmFsIHNjb3BlIG9mICdvbmUnIG9yICdhbGwnLiBVc2VzIHRoZSBYUmVnRXhwXG4gKiByZXBsYWNlbWVudCB0ZXh0IHN5bnRheCwgd2hpY2ggc3VwcG9ydHMgbmFtZWQgYmFja3JlZmVyZW5jZSBwcm9wZXJ0aWVzIHZpYSBgJHtuYW1lfWAuXG4gKlxuICogQG1lbWJlck9mIFhSZWdFeHBcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgU3RyaW5nIHRvIHNlYXJjaC5cbiAqIEBwYXJhbSB7QXJyYXl9IHJlcGxhY2VtZW50cyBBcnJheSBvZiByZXBsYWNlbWVudCBkZXRhaWwgYXJyYXlzLlxuICogQHJldHVybnMge1N0cmluZ30gTmV3IHN0cmluZyB3aXRoIGFsbCByZXBsYWNlbWVudHMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHN0ciA9IFhSZWdFeHAucmVwbGFjZUVhY2goc3RyLCBbXG4gKiAgIFtYUmVnRXhwKCcoPzxuYW1lPmEpJyksICd6JHtuYW1lfSddLFxuICogICBbL2IvZ2ksICd5J10sXG4gKiAgIFsvYy9nLCAneCcsICdvbmUnXSwgLy8gc2NvcGUgJ29uZScgb3ZlcnJpZGVzIC9nXG4gKiAgIFsvZC8sICd3JywgJ2FsbCddLCAgLy8gc2NvcGUgJ2FsbCcgb3ZlcnJpZGVzIGxhY2sgb2YgL2dcbiAqICAgWydlJywgJ3YnLCAnYWxsJ10sICAvLyBzY29wZSAnYWxsJyBhbGxvd3MgcmVwbGFjZS1hbGwgZm9yIHN0cmluZ3NcbiAqICAgWy9mL2csIGZ1bmN0aW9uKCQwKSB7XG4gKiAgICAgcmV0dXJuICQwLnRvVXBwZXJDYXNlKCk7XG4gKiAgIH1dXG4gKiBdKTtcbiAqL1xuICAgIHNlbGYucmVwbGFjZUVhY2ggPSBmdW5jdGlvbihzdHIsIHJlcGxhY2VtZW50cykge1xuICAgICAgICB2YXIgaSwgcjtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcmVwbGFjZW1lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICByID0gcmVwbGFjZW1lbnRzW2ldO1xuICAgICAgICAgICAgc3RyID0gc2VsZi5yZXBsYWNlKHN0ciwgclswXSwgclsxXSwgclsyXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH07XG5cbi8qKlxuICogU3BsaXRzIGEgc3RyaW5nIGludG8gYW4gYXJyYXkgb2Ygc3RyaW5ncyB1c2luZyBhIHJlZ2V4IG9yIHN0cmluZyBzZXBhcmF0b3IuIE1hdGNoZXMgb2YgdGhlXG4gKiBzZXBhcmF0b3IgYXJlIG5vdCBpbmNsdWRlZCBpbiB0aGUgcmVzdWx0IGFycmF5LiBIb3dldmVyLCBpZiBgc2VwYXJhdG9yYCBpcyBhIHJlZ2V4IHRoYXQgY29udGFpbnNcbiAqIGNhcHR1cmluZyBncm91cHMsIGJhY2tyZWZlcmVuY2VzIGFyZSBzcGxpY2VkIGludG8gdGhlIHJlc3VsdCBlYWNoIHRpbWUgYHNlcGFyYXRvcmAgaXMgbWF0Y2hlZC5cbiAqIEZpeGVzIGJyb3dzZXIgYnVncyBjb21wYXJlZCB0byB0aGUgbmF0aXZlIGBTdHJpbmcucHJvdG90eXBlLnNwbGl0YCBhbmQgY2FuIGJlIHVzZWQgcmVsaWFibHlcbiAqIGNyb3NzLWJyb3dzZXIuXG4gKlxuICogQG1lbWJlck9mIFhSZWdFeHBcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgU3RyaW5nIHRvIHNwbGl0LlxuICogQHBhcmFtIHtSZWdFeHB8U3RyaW5nfSBzZXBhcmF0b3IgUmVnZXggb3Igc3RyaW5nIHRvIHVzZSBmb3Igc2VwYXJhdGluZyB0aGUgc3RyaW5nLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtsaW1pdF0gTWF4aW11bSBudW1iZXIgb2YgaXRlbXMgdG8gaW5jbHVkZSBpbiB0aGUgcmVzdWx0IGFycmF5LlxuICogQHJldHVybnMge0FycmF5fSBBcnJheSBvZiBzdWJzdHJpbmdzLlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBCYXNpYyB1c2VcbiAqIFhSZWdFeHAuc3BsaXQoJ2EgYiBjJywgJyAnKTtcbiAqIC8vIC0+IFsnYScsICdiJywgJ2MnXVxuICpcbiAqIC8vIFdpdGggbGltaXRcbiAqIFhSZWdFeHAuc3BsaXQoJ2EgYiBjJywgJyAnLCAyKTtcbiAqIC8vIC0+IFsnYScsICdiJ11cbiAqXG4gKiAvLyBCYWNrcmVmZXJlbmNlcyBpbiByZXN1bHQgYXJyYXlcbiAqIFhSZWdFeHAuc3BsaXQoJy4ud29yZDEuLicsIC8oW2Etel0rKShcXGQrKS9pKTtcbiAqIC8vIC0+IFsnLi4nLCAnd29yZCcsICcxJywgJy4uJ11cbiAqL1xuICAgIHNlbGYuc3BsaXQgPSBmdW5jdGlvbihzdHIsIHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAgICAgcmV0dXJuIGZpeGVkLnNwbGl0LmNhbGwodG9PYmplY3Qoc3RyKSwgc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgfTtcblxuLyoqXG4gKiBFeGVjdXRlcyBhIHJlZ2V4IHNlYXJjaCBpbiBhIHNwZWNpZmllZCBzdHJpbmcuIFJldHVybnMgYHRydWVgIG9yIGBmYWxzZWAuIE9wdGlvbmFsIGBwb3NgIGFuZFxuICogYHN0aWNreWAgYXJndW1lbnRzIHNwZWNpZnkgdGhlIHNlYXJjaCBzdGFydCBwb3NpdGlvbiwgYW5kIHdoZXRoZXIgdGhlIG1hdGNoIG11c3Qgc3RhcnQgYXQgdGhlXG4gKiBzcGVjaWZpZWQgcG9zaXRpb24gb25seS4gVGhlIGBsYXN0SW5kZXhgIHByb3BlcnR5IG9mIHRoZSBwcm92aWRlZCByZWdleCBpcyBub3QgdXNlZCwgYnV0IGlzXG4gKiB1cGRhdGVkIGZvciBjb21wYXRpYmlsaXR5LiBBbHNvIGZpeGVzIGJyb3dzZXIgYnVncyBjb21wYXJlZCB0byB0aGUgbmF0aXZlXG4gKiBgUmVnRXhwLnByb3RvdHlwZS50ZXN0YCBhbmQgY2FuIGJlIHVzZWQgcmVsaWFibHkgY3Jvc3MtYnJvd3Nlci5cbiAqXG4gKiBAbWVtYmVyT2YgWFJlZ0V4cFxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBTdHJpbmcgdG8gc2VhcmNoLlxuICogQHBhcmFtIHtSZWdFeHB9IHJlZ2V4IFJlZ2V4IHRvIHNlYXJjaCB3aXRoLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtwb3M9MF0gWmVyby1iYXNlZCBpbmRleCBhdCB3aGljaCB0byBzdGFydCB0aGUgc2VhcmNoLlxuICogQHBhcmFtIHtCb29sZWFufFN0cmluZ30gW3N0aWNreT1mYWxzZV0gV2hldGhlciB0aGUgbWF0Y2ggbXVzdCBzdGFydCBhdCB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uXG4gKiAgIG9ubHkuIFRoZSBzdHJpbmcgYCdzdGlja3knYCBpcyBhY2NlcHRlZCBhcyBhbiBhbHRlcm5hdGl2ZSB0byBgdHJ1ZWAuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gV2hldGhlciB0aGUgcmVnZXggbWF0Y2hlZCB0aGUgcHJvdmlkZWQgdmFsdWUuXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIEJhc2ljIHVzZVxuICogWFJlZ0V4cC50ZXN0KCdhYmMnLCAvYy8pOyAvLyAtPiB0cnVlXG4gKlxuICogLy8gV2l0aCBwb3MgYW5kIHN0aWNreVxuICogWFJlZ0V4cC50ZXN0KCdhYmMnLCAvYy8sIDAsICdzdGlja3knKTsgLy8gLT4gZmFsc2VcbiAqL1xuICAgIHNlbGYudGVzdCA9IGZ1bmN0aW9uKHN0ciwgcmVnZXgsIHBvcywgc3RpY2t5KSB7XG4gICAgICAgIC8vIERvIHRoaXMgdGhlIGVhc3kgd2F5IDotKVxuICAgICAgICByZXR1cm4gISFzZWxmLmV4ZWMoc3RyLCByZWdleCwgcG9zLCBzdGlja3kpO1xuICAgIH07XG5cbi8qKlxuICogVW5pbnN0YWxscyBvcHRpb25hbCBmZWF0dXJlcyBhY2NvcmRpbmcgdG8gdGhlIHNwZWNpZmllZCBvcHRpb25zLiBBbGwgb3B0aW9uYWwgZmVhdHVyZXMgc3RhcnQgb3V0XG4gKiB1bmluc3RhbGxlZCwgc28gdGhpcyBpcyB1c2VkIHRvIHVuZG8gdGhlIGFjdGlvbnMgb2Yge0BsaW5rICNYUmVnRXhwLmluc3RhbGx9LlxuICpcbiAqIEBtZW1iZXJPZiBYUmVnRXhwXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IG9wdGlvbnMgT3B0aW9ucyBvYmplY3Qgb3Igc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBXaXRoIGFuIG9wdGlvbnMgb2JqZWN0XG4gKiBYUmVnRXhwLnVuaW5zdGFsbCh7XG4gKiAgIC8vIERpc2FibGVzIHN1cHBvcnQgZm9yIGFzdHJhbCBjb2RlIHBvaW50cyBpbiBVbmljb2RlIGFkZG9uc1xuICogICBhc3RyYWw6IHRydWUsXG4gKlxuICogICAvLyBSZXN0b3JlcyBuYXRpdmUgcmVnZXggbWV0aG9kc1xuICogICBuYXRpdmVzOiB0cnVlXG4gKiB9KTtcbiAqXG4gKiAvLyBXaXRoIGFuIG9wdGlvbnMgc3RyaW5nXG4gKiBYUmVnRXhwLnVuaW5zdGFsbCgnYXN0cmFsIG5hdGl2ZXMnKTtcbiAqL1xuICAgIHNlbGYudW5pbnN0YWxsID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gcHJlcGFyZU9wdGlvbnMob3B0aW9ucyk7XG5cbiAgICAgICAgaWYgKGZlYXR1cmVzLmFzdHJhbCAmJiBvcHRpb25zLmFzdHJhbCkge1xuICAgICAgICAgICAgc2V0QXN0cmFsKGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmZWF0dXJlcy5uYXRpdmVzICYmIG9wdGlvbnMubmF0aXZlcykge1xuICAgICAgICAgICAgc2V0TmF0aXZlcyhmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4vKipcbiAqIFJldHVybnMgYW4gWFJlZ0V4cCBvYmplY3QgdGhhdCBpcyB0aGUgdW5pb24gb2YgdGhlIGdpdmVuIHBhdHRlcm5zLiBQYXR0ZXJucyBjYW4gYmUgcHJvdmlkZWQgYXNcbiAqIHJlZ2V4IG9iamVjdHMgb3Igc3RyaW5ncy4gTWV0YWNoYXJhY3RlcnMgYXJlIGVzY2FwZWQgaW4gcGF0dGVybnMgcHJvdmlkZWQgYXMgc3RyaW5ncy5cbiAqIEJhY2tyZWZlcmVuY2VzIGluIHByb3ZpZGVkIHJlZ2V4IG9iamVjdHMgYXJlIGF1dG9tYXRpY2FsbHkgcmVudW1iZXJlZCB0byB3b3JrIGNvcnJlY3RseSB3aXRoaW5cbiAqIHRoZSBsYXJnZXIgY29tYmluZWQgcGF0dGVybi4gTmF0aXZlIGZsYWdzIHVzZWQgYnkgcHJvdmlkZWQgcmVnZXhlcyBhcmUgaWdub3JlZCBpbiBmYXZvciBvZiB0aGVcbiAqIGBmbGFnc2AgYXJndW1lbnQuXG4gKlxuICogQG1lbWJlck9mIFhSZWdFeHBcbiAqIEBwYXJhbSB7QXJyYXl9IHBhdHRlcm5zIFJlZ2V4ZXMgYW5kIHN0cmluZ3MgdG8gY29tYmluZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbZmxhZ3NdIEFueSBjb21iaW5hdGlvbiBvZiBYUmVnRXhwIGZsYWdzLlxuICogQHJldHVybnMge1JlZ0V4cH0gVW5pb24gb2YgdGhlIHByb3ZpZGVkIHJlZ2V4ZXMgYW5kIHN0cmluZ3MuXG4gKiBAZXhhbXBsZVxuICpcbiAqIFhSZWdFeHAudW5pb24oWydhK2IqYycsIC8oZG9ncylcXDEvLCAvKGNhdHMpXFwxL10sICdpJyk7XG4gKiAvLyAtPiAvYVxcK2JcXCpjfChkb2dzKVxcMXwoY2F0cylcXDIvaVxuICovXG4gICAgc2VsZi51bmlvbiA9IGZ1bmN0aW9uKHBhdHRlcm5zLCBmbGFncykge1xuICAgICAgICB2YXIgcGFydHMgPSAvKFxcKCkoPyFcXD8pfFxcXFwoWzEtOV1cXGQqKXxcXFxcW1xcc1xcU118XFxbKD86W15cXFxcXFxdXXxcXFxcW1xcc1xcU10pKl0vZyxcbiAgICAgICAgICAgIG91dHB1dCA9IFtdLFxuICAgICAgICAgICAgbnVtQ2FwdHVyZXMgPSAwLFxuICAgICAgICAgICAgbnVtUHJpb3JDYXB0dXJlcyxcbiAgICAgICAgICAgIGNhcHR1cmVOYW1lcyxcbiAgICAgICAgICAgIHBhdHRlcm4sXG4gICAgICAgICAgICByZXdyaXRlID0gZnVuY3Rpb24obWF0Y2gsIHBhcmVuLCBiYWNrcmVmKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBjYXB0dXJlTmFtZXNbbnVtQ2FwdHVyZXMgLSBudW1QcmlvckNhcHR1cmVzXTtcblxuICAgICAgICAgICAgICAgIC8vIENhcHR1cmluZyBncm91cFxuICAgICAgICAgICAgICAgIGlmIChwYXJlbikge1xuICAgICAgICAgICAgICAgICAgICArK251bUNhcHR1cmVzO1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgY3VycmVudCBjYXB0dXJlIGhhcyBhIG5hbWUsIHByZXNlcnZlIHRoZSBuYW1lXG4gICAgICAgICAgICAgICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyg/PCcgKyBuYW1lICsgJz4nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQmFja3JlZmVyZW5jZVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYmFja3JlZikge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZXdyaXRlIHRoZSBiYWNrcmVmZXJlbmNlXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnXFxcXCcgKyAoK2JhY2tyZWYgKyBudW1QcmlvckNhcHR1cmVzKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaTtcblxuICAgICAgICBpZiAoIShpc1R5cGUocGF0dGVybnMsICdBcnJheScpICYmIHBhdHRlcm5zLmxlbmd0aCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ011c3QgcHJvdmlkZSBhIG5vbmVtcHR5IGFycmF5IG9mIHBhdHRlcm5zIHRvIG1lcmdlJyk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGF0dGVybnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHBhdHRlcm4gPSBwYXR0ZXJuc1tpXTtcblxuICAgICAgICAgICAgaWYgKHNlbGYuaXNSZWdFeHAocGF0dGVybikpIHtcbiAgICAgICAgICAgICAgICBudW1QcmlvckNhcHR1cmVzID0gbnVtQ2FwdHVyZXM7XG4gICAgICAgICAgICAgICAgY2FwdHVyZU5hbWVzID0gKHBhdHRlcm5bUkVHRVhfREFUQV0gJiYgcGF0dGVybltSRUdFWF9EQVRBXS5jYXB0dXJlTmFtZXMpIHx8IFtdO1xuXG4gICAgICAgICAgICAgICAgLy8gUmV3cml0ZSBiYWNrcmVmZXJlbmNlcy4gUGFzc2luZyB0byBYUmVnRXhwIGRpZXMgb24gb2N0YWxzIGFuZCBlbnN1cmVzIHBhdHRlcm5zXG4gICAgICAgICAgICAgICAgLy8gYXJlIGluZGVwZW5kZW50bHkgdmFsaWQ7IGhlbHBzIGtlZXAgdGhpcyBzaW1wbGUuIE5hbWVkIGNhcHR1cmVzIGFyZSBwdXQgYmFja1xuICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKG5hdGl2LnJlcGxhY2UuY2FsbChzZWxmKHBhdHRlcm4uc291cmNlKS5zb3VyY2UsIHBhcnRzLCByZXdyaXRlKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKHNlbGYuZXNjYXBlKHBhdHRlcm4pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZWxmKG91dHB1dC5qb2luKCd8JyksIGZsYWdzKTtcbiAgICB9O1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZpeGVkL2V4dGVuZGVkIG5hdGl2ZSBtZXRob2RzXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuLyoqXG4gKiBBZGRzIG5hbWVkIGNhcHR1cmUgc3VwcG9ydCAod2l0aCBiYWNrcmVmZXJlbmNlcyByZXR1cm5lZCBhcyBgcmVzdWx0Lm5hbWVgKSwgYW5kIGZpeGVzIGJyb3dzZXJcbiAqIGJ1Z3MgaW4gdGhlIG5hdGl2ZSBgUmVnRXhwLnByb3RvdHlwZS5leGVjYC4gQ2FsbGluZyBgWFJlZ0V4cC5pbnN0YWxsKCduYXRpdmVzJylgIHVzZXMgdGhpcyB0b1xuICogb3ZlcnJpZGUgdGhlIG5hdGl2ZSBtZXRob2QuIFVzZSB2aWEgYFhSZWdFeHAuZXhlY2Agd2l0aG91dCBvdmVycmlkaW5nIG5hdGl2ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgU3RyaW5nIHRvIHNlYXJjaC5cbiAqIEByZXR1cm5zIHtBcnJheX0gTWF0Y2ggYXJyYXkgd2l0aCBuYW1lZCBiYWNrcmVmZXJlbmNlIHByb3BlcnRpZXMsIG9yIGBudWxsYC5cbiAqL1xuICAgIGZpeGVkLmV4ZWMgPSBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgdmFyIG9yaWdMYXN0SW5kZXggPSB0aGlzLmxhc3RJbmRleCxcbiAgICAgICAgICAgIG1hdGNoID0gbmF0aXYuZXhlYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIHIyLFxuICAgICAgICAgICAgaTtcblxuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIC8vIEZpeCBicm93c2VycyB3aG9zZSBgZXhlY2AgbWV0aG9kcyBkb24ndCByZXR1cm4gYHVuZGVmaW5lZGAgZm9yIG5vbnBhcnRpY2lwYXRpbmdcbiAgICAgICAgICAgIC8vIGNhcHR1cmluZyBncm91cHMuIFRoaXMgZml4ZXMgSUUgNS41LTgsIGJ1dCBub3QgSUUgOSdzIHF1aXJrcyBtb2RlIG9yIGVtdWxhdGlvbiBvZlxuICAgICAgICAgICAgLy8gb2xkZXIgSUVzLiBJRSA5IGluIHN0YW5kYXJkcyBtb2RlIGZvbGxvd3MgdGhlIHNwZWNcbiAgICAgICAgICAgIGlmICghY29ycmVjdEV4ZWNOcGNnICYmIG1hdGNoLmxlbmd0aCA+IDEgJiYgaW5kZXhPZihtYXRjaCwgJycpID4gLTEpIHtcbiAgICAgICAgICAgICAgICByMiA9IGNvcHlSZWdleCh0aGlzLCB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUc6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGlzSW50ZXJuYWxPbmx5OiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gVXNpbmcgYHN0ci5zbGljZShtYXRjaC5pbmRleClgIHJhdGhlciB0aGFuIGBtYXRjaFswXWAgaW4gY2FzZSBsb29rYWhlYWQgYWxsb3dlZFxuICAgICAgICAgICAgICAgIC8vIG1hdGNoaW5nIGR1ZSB0byBjaGFyYWN0ZXJzIG91dHNpZGUgdGhlIG1hdGNoXG4gICAgICAgICAgICAgICAgbmF0aXYucmVwbGFjZS5jYWxsKFN0cmluZyhzdHIpLnNsaWNlKG1hdGNoLmluZGV4KSwgcjIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgaTtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2tpcCBpbmRleCAwIGFuZCB0aGUgbGFzdCAyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDE7IGkgPCBsZW4gLSAyOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcmd1bWVudHNbaV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoW2ldID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEF0dGFjaCBuYW1lZCBjYXB0dXJlIHByb3BlcnRpZXNcbiAgICAgICAgICAgIGlmICh0aGlzW1JFR0VYX0RBVEFdICYmIHRoaXNbUkVHRVhfREFUQV0uY2FwdHVyZU5hbWVzKSB7XG4gICAgICAgICAgICAgICAgLy8gU2tpcCBpbmRleCAwXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMTsgaSA8IG1hdGNoLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSB0aGlzW1JFR0VYX0RBVEFdLmNhcHR1cmVOYW1lc1tpIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFtuYW1lXSA9IG1hdGNoW2ldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGaXggYnJvd3NlcnMgdGhhdCBpbmNyZW1lbnQgYGxhc3RJbmRleGAgYWZ0ZXIgemVyby1sZW5ndGggbWF0Y2hlc1xuICAgICAgICAgICAgaWYgKHRoaXMuZ2xvYmFsICYmICFtYXRjaFswXS5sZW5ndGggJiYgKHRoaXMubGFzdEluZGV4ID4gbWF0Y2guaW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0SW5kZXggPSBtYXRjaC5pbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5nbG9iYWwpIHtcbiAgICAgICAgICAgIC8vIEZpeGVzIElFLCBPcGVyYSBidWcgKGxhc3QgdGVzdGVkIElFIDksIE9wZXJhIDExLjYpXG4gICAgICAgICAgICB0aGlzLmxhc3RJbmRleCA9IG9yaWdMYXN0SW5kZXg7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfTtcblxuLyoqXG4gKiBGaXhlcyBicm93c2VyIGJ1Z3MgaW4gdGhlIG5hdGl2ZSBgUmVnRXhwLnByb3RvdHlwZS50ZXN0YC4gQ2FsbGluZyBgWFJlZ0V4cC5pbnN0YWxsKCduYXRpdmVzJylgXG4gKiB1c2VzIHRoaXMgdG8gb3ZlcnJpZGUgdGhlIG5hdGl2ZSBtZXRob2QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgU3RyaW5nIHRvIHNlYXJjaC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBXaGV0aGVyIHRoZSByZWdleCBtYXRjaGVkIHRoZSBwcm92aWRlZCB2YWx1ZS5cbiAqL1xuICAgIGZpeGVkLnRlc3QgPSBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgLy8gRG8gdGhpcyB0aGUgZWFzeSB3YXkgOi0pXG4gICAgICAgIHJldHVybiAhIWZpeGVkLmV4ZWMuY2FsbCh0aGlzLCBzdHIpO1xuICAgIH07XG5cbi8qKlxuICogQWRkcyBuYW1lZCBjYXB0dXJlIHN1cHBvcnQgKHdpdGggYmFja3JlZmVyZW5jZXMgcmV0dXJuZWQgYXMgYHJlc3VsdC5uYW1lYCksIGFuZCBmaXhlcyBicm93c2VyXG4gKiBidWdzIGluIHRoZSBuYXRpdmUgYFN0cmluZy5wcm90b3R5cGUubWF0Y2hgLiBDYWxsaW5nIGBYUmVnRXhwLmluc3RhbGwoJ25hdGl2ZXMnKWAgdXNlcyB0aGlzIHRvXG4gKiBvdmVycmlkZSB0aGUgbmF0aXZlIG1ldGhvZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtSZWdFeHB8Kn0gcmVnZXggUmVnZXggdG8gc2VhcmNoIHdpdGguIElmIG5vdCBhIHJlZ2V4IG9iamVjdCwgaXQgaXMgcGFzc2VkIHRvIGBSZWdFeHBgLlxuICogQHJldHVybnMge0FycmF5fSBJZiBgcmVnZXhgIHVzZXMgZmxhZyBnLCBhbiBhcnJheSBvZiBtYXRjaCBzdHJpbmdzIG9yIGBudWxsYC4gV2l0aG91dCBmbGFnIGcsXG4gKiAgIHRoZSByZXN1bHQgb2YgY2FsbGluZyBgcmVnZXguZXhlYyh0aGlzKWAuXG4gKi9cbiAgICBmaXhlZC5tYXRjaCA9IGZ1bmN0aW9uKHJlZ2V4KSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgICAgaWYgKCFzZWxmLmlzUmVnRXhwKHJlZ2V4KSkge1xuICAgICAgICAgICAgLy8gVXNlIHRoZSBuYXRpdmUgYFJlZ0V4cGAgcmF0aGVyIHRoYW4gYFhSZWdFeHBgXG4gICAgICAgICAgICByZWdleCA9IG5ldyBSZWdFeHAocmVnZXgpO1xuICAgICAgICB9IGVsc2UgaWYgKHJlZ2V4Lmdsb2JhbCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gbmF0aXYubWF0Y2guYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIC8vIEZpeGVzIElFIGJ1Z1xuICAgICAgICAgICAgcmVnZXgubGFzdEluZGV4ID0gMDtcblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmaXhlZC5leGVjLmNhbGwocmVnZXgsIHRvT2JqZWN0KHRoaXMpKTtcbiAgICB9O1xuXG4vKipcbiAqIEFkZHMgc3VwcG9ydCBmb3IgYCR7bn1gIHRva2VucyBmb3IgbmFtZWQgYW5kIG51bWJlcmVkIGJhY2tyZWZlcmVuY2VzIGluIHJlcGxhY2VtZW50IHRleHQsIGFuZFxuICogcHJvdmlkZXMgbmFtZWQgYmFja3JlZmVyZW5jZXMgdG8gcmVwbGFjZW1lbnQgZnVuY3Rpb25zIGFzIGBhcmd1bWVudHNbMF0ubmFtZWAuIEFsc28gZml4ZXMgYnJvd3NlclxuICogYnVncyBpbiByZXBsYWNlbWVudCB0ZXh0IHN5bnRheCB3aGVuIHBlcmZvcm1pbmcgYSByZXBsYWNlbWVudCB1c2luZyBhIG5vbnJlZ2V4IHNlYXJjaCB2YWx1ZSwgYW5kXG4gKiB0aGUgdmFsdWUgb2YgYSByZXBsYWNlbWVudCByZWdleCdzIGBsYXN0SW5kZXhgIHByb3BlcnR5IGR1cmluZyByZXBsYWNlbWVudCBpdGVyYXRpb25zIGFuZCB1cG9uXG4gKiBjb21wbGV0aW9uLiBDYWxsaW5nIGBYUmVnRXhwLmluc3RhbGwoJ25hdGl2ZXMnKWAgdXNlcyB0aGlzIHRvIG92ZXJyaWRlIHRoZSBuYXRpdmUgbWV0aG9kLiBOb3RlXG4gKiB0aGF0IHRoaXMgZG9lc24ndCBzdXBwb3J0IFNwaWRlck1vbmtleSdzIHByb3ByaWV0YXJ5IHRoaXJkIChgZmxhZ3NgKSBhcmd1bWVudC4gVXNlIHZpYVxuICogYFhSZWdFeHAucmVwbGFjZWAgd2l0aG91dCBvdmVycmlkaW5nIG5hdGl2ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7UmVnRXhwfFN0cmluZ30gc2VhcmNoIFNlYXJjaCBwYXR0ZXJuIHRvIGJlIHJlcGxhY2VkLlxuICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IHJlcGxhY2VtZW50IFJlcGxhY2VtZW50IHN0cmluZyBvciBhIGZ1bmN0aW9uIGludm9rZWQgdG8gY3JlYXRlIGl0LlxuICogQHJldHVybnMge1N0cmluZ30gTmV3IHN0cmluZyB3aXRoIG9uZSBvciBhbGwgbWF0Y2hlcyByZXBsYWNlZC5cbiAqL1xuICAgIGZpeGVkLnJlcGxhY2UgPSBmdW5jdGlvbihzZWFyY2gsIHJlcGxhY2VtZW50KSB7XG4gICAgICAgIHZhciBpc1JlZ2V4ID0gc2VsZi5pc1JlZ0V4cChzZWFyY2gpLFxuICAgICAgICAgICAgb3JpZ0xhc3RJbmRleCxcbiAgICAgICAgICAgIGNhcHR1cmVOYW1lcyxcbiAgICAgICAgICAgIHJlc3VsdDtcblxuICAgICAgICBpZiAoaXNSZWdleCkge1xuICAgICAgICAgICAgaWYgKHNlYXJjaFtSRUdFWF9EQVRBXSkge1xuICAgICAgICAgICAgICAgIGNhcHR1cmVOYW1lcyA9IHNlYXJjaFtSRUdFWF9EQVRBXS5jYXB0dXJlTmFtZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBPbmx5IG5lZWRlZCBpZiBgc2VhcmNoYCBpcyBub25nbG9iYWxcbiAgICAgICAgICAgIG9yaWdMYXN0SW5kZXggPSBzZWFyY2gubGFzdEluZGV4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VhcmNoICs9ICcnOyAvLyBUeXBlLWNvbnZlcnRcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERvbid0IHVzZSBgdHlwZW9mYDsgc29tZSBvbGRlciBicm93c2VycyByZXR1cm4gJ2Z1bmN0aW9uJyBmb3IgcmVnZXggb2JqZWN0c1xuICAgICAgICBpZiAoaXNUeXBlKHJlcGxhY2VtZW50LCAnRnVuY3Rpb24nKSkge1xuICAgICAgICAgICAgLy8gU3RyaW5naWZ5aW5nIGB0aGlzYCBmaXhlcyBhIGJ1ZyBpbiBJRSA8IDkgd2hlcmUgdGhlIGxhc3QgYXJndW1lbnQgaW4gcmVwbGFjZW1lbnRcbiAgICAgICAgICAgIC8vIGZ1bmN0aW9ucyBpc24ndCB0eXBlLWNvbnZlcnRlZCB0byBhIHN0cmluZ1xuICAgICAgICAgICAgcmVzdWx0ID0gbmF0aXYucmVwbGFjZS5jYWxsKFN0cmluZyh0aGlzKSwgc2VhcmNoLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cywgaTtcbiAgICAgICAgICAgICAgICBpZiAoY2FwdHVyZU5hbWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENoYW5nZSB0aGUgYGFyZ3VtZW50c1swXWAgc3RyaW5nIHByaW1pdGl2ZSB0byBhIGBTdHJpbmdgIG9iamVjdCB0aGF0IGNhblxuICAgICAgICAgICAgICAgICAgICAvLyBzdG9yZSBwcm9wZXJ0aWVzLiBUaGlzIHJlYWxseSBkb2VzIG5lZWQgdG8gdXNlIGBTdHJpbmdgIGFzIGEgY29uc3RydWN0b3JcbiAgICAgICAgICAgICAgICAgICAgYXJnc1swXSA9IG5ldyBTdHJpbmcoYXJnc1swXSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFN0b3JlIG5hbWVkIGJhY2tyZWZlcmVuY2VzIG9uIHRoZSBmaXJzdCBhcmd1bWVudFxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2FwdHVyZU5hbWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FwdHVyZU5hbWVzW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnc1swXVtjYXB0dXJlTmFtZXNbaV1dID0gYXJnc1tpICsgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIGBsYXN0SW5kZXhgIGJlZm9yZSBjYWxsaW5nIGByZXBsYWNlbWVudGAuIEZpeGVzIElFLCBDaHJvbWUsIEZpcmVmb3gsXG4gICAgICAgICAgICAgICAgLy8gU2FmYXJpIGJ1ZyAobGFzdCB0ZXN0ZWQgSUUgOSwgQ2hyb21lIDE3LCBGaXJlZm94IDExLCBTYWZhcmkgNS4xKVxuICAgICAgICAgICAgICAgIGlmIChpc1JlZ2V4ICYmIHNlYXJjaC5nbG9iYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VhcmNoLmxhc3RJbmRleCA9IGFyZ3NbYXJncy5sZW5ndGggLSAyXSArIGFyZ3NbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBFUzYgc3BlY3MgdGhlIGNvbnRleHQgZm9yIHJlcGxhY2VtZW50IGZ1bmN0aW9ucyBhcyBgdW5kZWZpbmVkYFxuICAgICAgICAgICAgICAgIHJldHVybiByZXBsYWNlbWVudC5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBFbnN1cmUgdGhhdCB0aGUgbGFzdCB2YWx1ZSBvZiBgYXJnc2Agd2lsbCBiZSBhIHN0cmluZyB3aGVuIGdpdmVuIG5vbnN0cmluZyBgdGhpc2AsXG4gICAgICAgICAgICAvLyB3aGlsZSBzdGlsbCB0aHJvd2luZyBvbiBudWxsIG9yIHVuZGVmaW5lZCBjb250ZXh0XG4gICAgICAgICAgICByZXN1bHQgPSBuYXRpdi5yZXBsYWNlLmNhbGwodGhpcyA9PSBudWxsID8gdGhpcyA6IFN0cmluZyh0aGlzKSwgc2VhcmNoLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBLZWVwIHRoaXMgZnVuY3Rpb24ncyBgYXJndW1lbnRzYCBhdmFpbGFibGUgdGhyb3VnaCBjbG9zdXJlXG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5hdGl2LnJlcGxhY2UuY2FsbChTdHJpbmcocmVwbGFjZW1lbnQpLCByZXBsYWNlbWVudFRva2VuLCBmdW5jdGlvbigkMCwgJDEsICQyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuO1xuICAgICAgICAgICAgICAgICAgICAvLyBOYW1lZCBvciBudW1iZXJlZCBiYWNrcmVmZXJlbmNlIHdpdGggY3VybHkgYnJhY2VzXG4gICAgICAgICAgICAgICAgICAgIGlmICgkMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gWFJlZ0V4cCBiZWhhdmlvciBmb3IgYCR7bn1gOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gMS4gQmFja3JlZmVyZW5jZSB0byBudW1iZXJlZCBjYXB0dXJlLCBpZiBgbmAgaXMgYW4gaW50ZWdlci4gVXNlIGAwYCBmb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgIGZvciB0aGUgZW50aXJlIG1hdGNoLiBBbnkgbnVtYmVyIG9mIGxlYWRpbmcgemVyb3MgbWF5IGJlIHVzZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAyLiBCYWNrcmVmZXJlbmNlIHRvIG5hbWVkIGNhcHR1cmUgYG5gLCBpZiBpdCBleGlzdHMgYW5kIGlzIG5vdCBhblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgaW50ZWdlciBvdmVycmlkZGVuIGJ5IG51bWJlcmVkIGNhcHR1cmUuIEluIHByYWN0aWNlLCB0aGlzIGRvZXMgbm90XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICBvdmVybGFwIHdpdGggbnVtYmVyZWQgY2FwdHVyZSBzaW5jZSBYUmVnRXhwIGRvZXMgbm90IGFsbG93IG5hbWVkXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICBjYXB0dXJlIHRvIHVzZSBhIGJhcmUgaW50ZWdlciBhcyB0aGUgbmFtZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIDMuIElmIHRoZSBuYW1lIG9yIG51bWJlciBkb2VzIG5vdCByZWZlciB0byBhbiBleGlzdGluZyBjYXB0dXJpbmcgZ3JvdXAsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICBpdCdzIGFuIGVycm9yLlxuICAgICAgICAgICAgICAgICAgICAgICAgbiA9ICskMTsgLy8gVHlwZS1jb252ZXJ0OyBkcm9wIGxlYWRpbmcgemVyb3NcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuIDw9IGFyZ3MubGVuZ3RoIC0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhcmdzW25dIHx8ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gR3JvdXBzIHdpdGggdGhlIHNhbWUgbmFtZSBpcyBhbiBlcnJvciwgZWxzZSB3b3VsZCBuZWVkIGBsYXN0SW5kZXhPZmBcbiAgICAgICAgICAgICAgICAgICAgICAgIG4gPSBjYXB0dXJlTmFtZXMgPyBpbmRleE9mKGNhcHR1cmVOYW1lcywgJDEpIDogLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobiA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0JhY2tyZWZlcmVuY2UgdG8gdW5kZWZpbmVkIGdyb3VwICcgKyAkMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJnc1tuICsgMV0gfHwgJyc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gRWxzZSwgc3BlY2lhbCB2YXJpYWJsZSBvciBudW1iZXJlZCBiYWNrcmVmZXJlbmNlIHdpdGhvdXQgY3VybHkgYnJhY2VzXG4gICAgICAgICAgICAgICAgICAgIGlmICgkMiA9PT0gJyQnKSB7IC8vICQkXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyQnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICgkMiA9PT0gJyYnIHx8ICskMiA9PT0gMCkgeyAvLyAkJiwgJDAgKG5vdCBmb2xsb3dlZCBieSAxLTkpLCAkMDBcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhcmdzWzBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICgkMiA9PT0gJ2AnKSB7IC8vICRgIChsZWZ0IGNvbnRleHQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJnc1thcmdzLmxlbmd0aCAtIDFdLnNsaWNlKDAsIGFyZ3NbYXJncy5sZW5ndGggLSAyXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCQyID09PSBcIidcIikgeyAvLyAkJyAocmlnaHQgY29udGV4dClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0uc2xpY2UoYXJnc1thcmdzLmxlbmd0aCAtIDJdICsgYXJnc1swXS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEVsc2UsIG51bWJlcmVkIGJhY2tyZWZlcmVuY2Ugd2l0aG91dCBjdXJseSBicmFjZXNcbiAgICAgICAgICAgICAgICAgICAgJDIgPSArJDI7IC8vIFR5cGUtY29udmVydDsgZHJvcCBsZWFkaW5nIHplcm9cbiAgICAgICAgICAgICAgICAgICAgLy8gWFJlZ0V4cCBiZWhhdmlvciBmb3IgYCRuYCBhbmQgYCRubmA6XG4gICAgICAgICAgICAgICAgICAgIC8vIC0gQmFja3JlZnMgZW5kIGFmdGVyIDEgb3IgMiBkaWdpdHMuIFVzZSBgJHsuLn1gIGZvciBtb3JlIGRpZ2l0cy5cbiAgICAgICAgICAgICAgICAgICAgLy8gLSBgJDFgIGlzIGFuIGVycm9yIGlmIG5vIGNhcHR1cmluZyBncm91cHMuXG4gICAgICAgICAgICAgICAgICAgIC8vIC0gYCQxMGAgaXMgYW4gZXJyb3IgaWYgbGVzcyB0aGFuIDEwIGNhcHR1cmluZyBncm91cHMuIFVzZSBgJHsxfTBgIGluc3RlYWQuXG4gICAgICAgICAgICAgICAgICAgIC8vIC0gYCQwMWAgaXMgYCQxYCBpZiBhdCBsZWFzdCBvbmUgY2FwdHVyaW5nIGdyb3VwLCBlbHNlIGl0J3MgYW4gZXJyb3IuXG4gICAgICAgICAgICAgICAgICAgIC8vIC0gYCQwYCAobm90IGZvbGxvd2VkIGJ5IDEtOSkgYW5kIGAkMDBgIGFyZSB0aGUgZW50aXJlIG1hdGNoLlxuICAgICAgICAgICAgICAgICAgICAvLyBOYXRpdmUgYmVoYXZpb3IsIGZvciBjb21wYXJpc29uOlxuICAgICAgICAgICAgICAgICAgICAvLyAtIEJhY2tyZWZzIGVuZCBhZnRlciAxIG9yIDIgZGlnaXRzLiBDYW5ub3QgcmVmZXJlbmNlIGNhcHR1cmluZyBncm91cCAxMDArLlxuICAgICAgICAgICAgICAgICAgICAvLyAtIGAkMWAgaXMgYSBsaXRlcmFsIGAkMWAgaWYgbm8gY2FwdHVyaW5nIGdyb3Vwcy5cbiAgICAgICAgICAgICAgICAgICAgLy8gLSBgJDEwYCBpcyBgJDFgIGZvbGxvd2VkIGJ5IGEgbGl0ZXJhbCBgMGAgaWYgbGVzcyB0aGFuIDEwIGNhcHR1cmluZyBncm91cHMuXG4gICAgICAgICAgICAgICAgICAgIC8vIC0gYCQwMWAgaXMgYCQxYCBpZiBhdCBsZWFzdCBvbmUgY2FwdHVyaW5nIGdyb3VwLCBlbHNlIGl0J3MgYSBsaXRlcmFsIGAkMDFgLlxuICAgICAgICAgICAgICAgICAgICAvLyAtIGAkMGAgaXMgYSBsaXRlcmFsIGAkMGAuXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNOYU4oJDIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJDIgPiBhcmdzLmxlbmd0aCAtIDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0JhY2tyZWZlcmVuY2UgdG8gdW5kZWZpbmVkIGdyb3VwICcgKyAkMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJnc1skMl0gfHwgJyc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gYCRgIGZvbGxvd2VkIGJ5IGFuIHVuc3VwcG9ydGVkIGNoYXIgaXMgYW4gZXJyb3IsIHVubGlrZSBuYXRpdmUgSlNcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdJbnZhbGlkIHRva2VuICcgKyAkMCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1JlZ2V4KSB7XG4gICAgICAgICAgICBpZiAoc2VhcmNoLmdsb2JhbCkge1xuICAgICAgICAgICAgICAgIC8vIEZpeGVzIElFLCBTYWZhcmkgYnVnIChsYXN0IHRlc3RlZCBJRSA5LCBTYWZhcmkgNS4xKVxuICAgICAgICAgICAgICAgIHNlYXJjaC5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBGaXhlcyBJRSwgT3BlcmEgYnVnIChsYXN0IHRlc3RlZCBJRSA5LCBPcGVyYSAxMS42KVxuICAgICAgICAgICAgICAgIHNlYXJjaC5sYXN0SW5kZXggPSBvcmlnTGFzdEluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4vKipcbiAqIEZpeGVzIGJyb3dzZXIgYnVncyBpbiB0aGUgbmF0aXZlIGBTdHJpbmcucHJvdG90eXBlLnNwbGl0YC4gQ2FsbGluZyBgWFJlZ0V4cC5pbnN0YWxsKCduYXRpdmVzJylgXG4gKiB1c2VzIHRoaXMgdG8gb3ZlcnJpZGUgdGhlIG5hdGl2ZSBtZXRob2QuIFVzZSB2aWEgYFhSZWdFeHAuc3BsaXRgIHdpdGhvdXQgb3ZlcnJpZGluZyBuYXRpdmVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1JlZ0V4cHxTdHJpbmd9IHNlcGFyYXRvciBSZWdleCBvciBzdHJpbmcgdG8gdXNlIGZvciBzZXBhcmF0aW5nIHRoZSBzdHJpbmcuXG4gKiBAcGFyYW0ge051bWJlcn0gW2xpbWl0XSBNYXhpbXVtIG51bWJlciBvZiBpdGVtcyB0byBpbmNsdWRlIGluIHRoZSByZXN1bHQgYXJyYXkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IEFycmF5IG9mIHN1YnN0cmluZ3MuXG4gKi9cbiAgICBmaXhlZC5zcGxpdCA9IGZ1bmN0aW9uKHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAgICAgaWYgKCFzZWxmLmlzUmVnRXhwKHNlcGFyYXRvcikpIHtcbiAgICAgICAgICAgIC8vIEJyb3dzZXJzIGhhbmRsZSBub25yZWdleCBzcGxpdCBjb3JyZWN0bHksIHNvIHVzZSB0aGUgZmFzdGVyIG5hdGl2ZSBtZXRob2RcbiAgICAgICAgICAgIHJldHVybiBuYXRpdi5zcGxpdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0ciA9IFN0cmluZyh0aGlzKSxcbiAgICAgICAgICAgIG91dHB1dCA9IFtdLFxuICAgICAgICAgICAgb3JpZ0xhc3RJbmRleCA9IHNlcGFyYXRvci5sYXN0SW5kZXgsXG4gICAgICAgICAgICBsYXN0TGFzdEluZGV4ID0gMCxcbiAgICAgICAgICAgIGxhc3RMZW5ndGg7XG5cbiAgICAgICAgLy8gVmFsdWVzIGZvciBgbGltaXRgLCBwZXIgdGhlIHNwZWM6XG4gICAgICAgIC8vIElmIHVuZGVmaW5lZDogcG93KDIsMzIpIC0gMVxuICAgICAgICAvLyBJZiAwLCBJbmZpbml0eSwgb3IgTmFOOiAwXG4gICAgICAgIC8vIElmIHBvc2l0aXZlIG51bWJlcjogbGltaXQgPSBmbG9vcihsaW1pdCk7IGlmIChsaW1pdCA+PSBwb3coMiwzMikpIGxpbWl0IC09IHBvdygyLDMyKTtcbiAgICAgICAgLy8gSWYgbmVnYXRpdmUgbnVtYmVyOiBwb3coMiwzMikgLSBmbG9vcihhYnMobGltaXQpKVxuICAgICAgICAvLyBJZiBvdGhlcjogVHlwZS1jb252ZXJ0LCB0aGVuIHVzZSB0aGUgYWJvdmUgcnVsZXNcbiAgICAgICAgLy8gVGhpcyBsaW5lIGZhaWxzIGluIHZlcnkgc3RyYW5nZSB3YXlzIGZvciBzb21lIHZhbHVlcyBvZiBgbGltaXRgIGluIE9wZXJhIDEwLjUtMTAuNjMsXG4gICAgICAgIC8vIHVubGVzcyBPcGVyYSBEcmFnb25mbHkgaXMgb3BlbiAoZ28gZmlndXJlKS4gSXQgd29ya3MgaW4gYXQgbGVhc3QgT3BlcmEgOS41LTEwLjEgYW5kIDExK1xuICAgICAgICBsaW1pdCA9IChsaW1pdCA9PT0gdW5kZWZpbmVkID8gLTEgOiBsaW1pdCkgPj4+IDA7XG5cbiAgICAgICAgc2VsZi5mb3JFYWNoKHN0ciwgc2VwYXJhdG9yLCBmdW5jdGlvbihtYXRjaCkge1xuICAgICAgICAgICAgLy8gVGhpcyBjb25kaXRpb24gaXMgbm90IHRoZSBzYW1lIGFzIGBpZiAobWF0Y2hbMF0ubGVuZ3RoKWBcbiAgICAgICAgICAgIGlmICgobWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGgpID4gbGFzdExhc3RJbmRleCkge1xuICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKHN0ci5zbGljZShsYXN0TGFzdEluZGV4LCBtYXRjaC5pbmRleCkpO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaC5sZW5ndGggPiAxICYmIG1hdGNoLmluZGV4IDwgc3RyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShvdXRwdXQsIG1hdGNoLnNsaWNlKDEpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGFzdExlbmd0aCA9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBsYXN0TGFzdEluZGV4ID0gbWF0Y2guaW5kZXggKyBsYXN0TGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAobGFzdExhc3RJbmRleCA9PT0gc3RyLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKCFuYXRpdi50ZXN0LmNhbGwoc2VwYXJhdG9yLCAnJykgfHwgbGFzdExlbmd0aCkge1xuICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dHB1dC5wdXNoKHN0ci5zbGljZShsYXN0TGFzdEluZGV4KSk7XG4gICAgICAgIH1cblxuICAgICAgICBzZXBhcmF0b3IubGFzdEluZGV4ID0gb3JpZ0xhc3RJbmRleDtcbiAgICAgICAgcmV0dXJuIG91dHB1dC5sZW5ndGggPiBsaW1pdCA/IG91dHB1dC5zbGljZSgwLCBsaW1pdCkgOiBvdXRwdXQ7XG4gICAgfTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBCdWlsdC1pbiBzeW50YXgvZmxhZyB0b2tlbnNcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG4gICAgYWRkID0gc2VsZi5hZGRUb2tlbjtcblxuLypcbiAqIExldHRlciBlc2NhcGVzIHRoYXQgbmF0aXZlbHkgbWF0Y2ggbGl0ZXJhbCBjaGFyYWN0ZXJzOiBgXFxhYCwgYFxcQWAsIGV0Yy4gVGhlc2Ugc2hvdWxkIGJlXG4gKiBTeW50YXhFcnJvcnMgYnV0IGFyZSBhbGxvd2VkIGluIHdlYiByZWFsaXR5LiBYUmVnRXhwIG1ha2VzIHRoZW0gZXJyb3JzIGZvciBjcm9zcy1icm93c2VyXG4gKiBjb25zaXN0ZW5jeSBhbmQgdG8gcmVzZXJ2ZSB0aGVpciBzeW50YXgsIGJ1dCBsZXRzIHRoZW0gYmUgc3VwZXJzZWRlZCBieSBhZGRvbnMuXG4gKi9cbiAgICBhZGQoXG4gICAgICAgIC9cXFxcKFtBQkNFLVJUVVZYWVphZWctbW9wcXl6XXxjKD8hW0EtWmEtel0pfHUoPyFbXFxkQS1GYS1mXXs0fXx7W1xcZEEtRmEtZl0rfSl8eCg/IVtcXGRBLUZhLWZdezJ9KSkvLFxuICAgICAgICBmdW5jdGlvbihtYXRjaCwgc2NvcGUpIHtcbiAgICAgICAgICAgIC8vIFxcQiBpcyBhbGxvd2VkIGluIGRlZmF1bHQgc2NvcGUgb25seVxuICAgICAgICAgICAgaWYgKG1hdGNoWzFdID09PSAnQicgJiYgc2NvcGUgPT09IGRlZmF1bHRTY29wZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaFswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignSW52YWxpZCBlc2NhcGUgJyArIG1hdGNoWzBdKTtcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgc2NvcGU6ICdhbGwnLFxuICAgICAgICAgICAgbGVhZENoYXI6ICdcXFxcJ1xuICAgICAgICB9XG4gICAgKTtcblxuLypcbiAqIFVuaWNvZGUgY29kZSBwb2ludCBlc2NhcGUgd2l0aCBjdXJseSBicmFjZXM6IGBcXHV7Ti4ufWAuIGBOLi5gIGlzIGFueSBvbmUgb3IgbW9yZSBkaWdpdFxuICogaGV4YWRlY2ltYWwgbnVtYmVyIGZyb20gMC0xMEZGRkYsIGFuZCBjYW4gaW5jbHVkZSBsZWFkaW5nIHplcm9zLiBSZXF1aXJlcyB0aGUgbmF0aXZlIEVTNiBgdWAgZmxhZ1xuICogdG8gc3VwcG9ydCBjb2RlIHBvaW50cyBncmVhdGVyIHRoYW4gVStGRkZGLiBBdm9pZHMgY29udmVydGluZyBjb2RlIHBvaW50cyBhYm92ZSBVK0ZGRkYgdG9cbiAqIHN1cnJvZ2F0ZSBwYWlycyAod2hpY2ggY291bGQgYmUgZG9uZSB3aXRob3V0IGZsYWcgYHVgKSwgc2luY2UgdGhhdCBjb3VsZCBsZWFkIHRvIGJyb2tlbiBiZWhhdmlvclxuICogaWYgeW91IGZvbGxvdyBhIGBcXHV7Ti4ufWAgdG9rZW4gdGhhdCByZWZlcmVuY2VzIGEgY29kZSBwb2ludCBhYm92ZSBVK0ZGRkYgd2l0aCBhIHF1YW50aWZpZXIsIG9yXG4gKiBpZiB5b3UgdXNlIHRoZSBzYW1lIGluIGEgY2hhcmFjdGVyIGNsYXNzLlxuICovXG4gICAgYWRkKFxuICAgICAgICAvXFxcXHV7KFtcXGRBLUZhLWZdKyl9LyxcbiAgICAgICAgZnVuY3Rpb24obWF0Y2gsIHNjb3BlLCBmbGFncykge1xuICAgICAgICAgICAgdmFyIGNvZGUgPSBkZWMobWF0Y2hbMV0pO1xuICAgICAgICAgICAgaWYgKGNvZGUgPiAweDEwRkZGRikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignSW52YWxpZCBVbmljb2RlIGNvZGUgcG9pbnQgJyArIG1hdGNoWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb2RlIDw9IDB4RkZGRikge1xuICAgICAgICAgICAgICAgIC8vIENvbnZlcnRpbmcgdG8gXFx1Tk5OTiBhdm9pZHMgbmVlZGluZyB0byBlc2NhcGUgdGhlIGxpdGVyYWwgY2hhcmFjdGVyIGFuZCBrZWVwIGl0XG4gICAgICAgICAgICAgICAgLy8gc2VwYXJhdGUgZnJvbSBwcmVjZWRpbmcgdG9rZW5zXG4gICAgICAgICAgICAgICAgcmV0dXJuICdcXFxcdScgKyBwYWQ0KGhleChjb2RlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiBgY29kZWAgaXMgYmV0d2VlbiAweEZGRkYgYW5kIDB4MTBGRkZGLCByZXF1aXJlIGFuZCBkZWZlciB0byBuYXRpdmUgaGFuZGxpbmdcbiAgICAgICAgICAgIGlmIChoYXNOYXRpdmVVICYmIGZsYWdzLmluZGV4T2YoJ3UnKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdDYW5ub3QgdXNlIFVuaWNvZGUgY29kZSBwb2ludCBhYm92ZSBcXFxcdXtGRkZGfSB3aXRob3V0IGZsYWcgdScpO1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBzY29wZTogJ2FsbCcsXG4gICAgICAgICAgICBsZWFkQ2hhcjogJ1xcXFwnXG4gICAgICAgIH1cbiAgICApO1xuXG4vKlxuICogRW1wdHkgY2hhcmFjdGVyIGNsYXNzOiBgW11gIG9yIGBbXl1gLiBUaGlzIGZpeGVzIGEgY3JpdGljYWwgY3Jvc3MtYnJvd3NlciBzeW50YXggaW5jb25zaXN0ZW5jeS5cbiAqIFVubGVzcyB0aGlzIGlzIHN0YW5kYXJkaXplZCAocGVyIHRoZSBFUyBzcGVjKSwgcmVnZXggc3ludGF4IGNhbid0IGJlIGFjY3VyYXRlbHkgcGFyc2VkIGJlY2F1c2VcbiAqIGNoYXJhY3RlciBjbGFzcyBlbmRpbmdzIGNhbid0IGJlIGRldGVybWluZWQuXG4gKi9cbiAgICBhZGQoXG4gICAgICAgIC9cXFsoXFxePyldLyxcbiAgICAgICAgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICAgICAgICAgIC8vIEZvciBjcm9zcy1icm93c2VyIGNvbXBhdGliaWxpdHkgd2l0aCBFUzMsIGNvbnZlcnQgW10gdG8gXFxiXFxCIGFuZCBbXl0gdG8gW1xcc1xcU10uXG4gICAgICAgICAgICAvLyAoPyEpIHNob3VsZCB3b3JrIGxpa2UgXFxiXFxCLCBidXQgaXMgdW5yZWxpYWJsZSBpbiBzb21lIHZlcnNpb25zIG9mIEZpcmVmb3hcbiAgICAgICAgICAgIHJldHVybiBtYXRjaFsxXSA/ICdbXFxcXHNcXFxcU10nIDogJ1xcXFxiXFxcXEInO1xuICAgICAgICB9LFxuICAgICAgICB7bGVhZENoYXI6ICdbJ31cbiAgICApO1xuXG4vKlxuICogQ29tbWVudCBwYXR0ZXJuOiBgKD8jIClgLiBJbmxpbmUgY29tbWVudHMgYXJlIGFuIGFsdGVybmF0aXZlIHRvIHRoZSBsaW5lIGNvbW1lbnRzIGFsbG93ZWQgaW5cbiAqIGZyZWUtc3BhY2luZyBtb2RlIChmbGFnIHgpLlxuICovXG4gICAgYWRkKFxuICAgICAgICAvXFwoXFw/I1teKV0qXFwpLyxcbiAgICAgICAgZnVuY3Rpb24obWF0Y2gsIHNjb3BlLCBmbGFncykge1xuICAgICAgICAgICAgLy8gS2VlcCB0b2tlbnMgc2VwYXJhdGVkIHVubGVzcyB0aGUgZm9sbG93aW5nIHRva2VuIGlzIGEgcXVhbnRpZmllclxuICAgICAgICAgICAgcmV0dXJuIGlzUXVhbnRpZmllck5leHQobWF0Y2guaW5wdXQsIG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoLCBmbGFncykgP1xuICAgICAgICAgICAgICAgICcnIDogJyg/OiknO1xuICAgICAgICB9LFxuICAgICAgICB7bGVhZENoYXI6ICcoJ31cbiAgICApO1xuXG4vKlxuICogV2hpdGVzcGFjZSBhbmQgbGluZSBjb21tZW50cywgaW4gZnJlZS1zcGFjaW5nIG1vZGUgKGFrYSBleHRlbmRlZCBtb2RlLCBmbGFnIHgpIG9ubHkuXG4gKi9cbiAgICBhZGQoXG4gICAgICAgIC9cXHMrfCMuKi8sXG4gICAgICAgIGZ1bmN0aW9uKG1hdGNoLCBzY29wZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIC8vIEtlZXAgdG9rZW5zIHNlcGFyYXRlZCB1bmxlc3MgdGhlIGZvbGxvd2luZyB0b2tlbiBpcyBhIHF1YW50aWZpZXJcbiAgICAgICAgICAgIHJldHVybiBpc1F1YW50aWZpZXJOZXh0KG1hdGNoLmlucHV0LCBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCwgZmxhZ3MpID9cbiAgICAgICAgICAgICAgICAnJyA6ICcoPzopJztcbiAgICAgICAgfSxcbiAgICAgICAge2ZsYWc6ICd4J31cbiAgICApO1xuXG4vKlxuICogRG90LCBpbiBkb3RhbGwgbW9kZSAoYWthIHNpbmdsZWxpbmUgbW9kZSwgZmxhZyBzKSBvbmx5LlxuICovXG4gICAgYWRkKFxuICAgICAgICAvXFwuLyxcbiAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1tcXFxcc1xcXFxTXSc7XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGZsYWc6ICdzJyxcbiAgICAgICAgICAgIGxlYWRDaGFyOiAnLidcbiAgICAgICAgfVxuICAgICk7XG5cbi8qXG4gKiBOYW1lZCBiYWNrcmVmZXJlbmNlOiBgXFxrPG5hbWU+YC4gQmFja3JlZmVyZW5jZSBuYW1lcyBjYW4gdXNlIHRoZSBjaGFyYWN0ZXJzIEEtWiwgYS16LCAwLTksIF8sXG4gKiBhbmQgJCBvbmx5LiBBbHNvIGFsbG93cyBudW1iZXJlZCBiYWNrcmVmZXJlbmNlcyBhcyBgXFxrPG4+YC5cbiAqL1xuICAgIGFkZChcbiAgICAgICAgL1xcXFxrPChbXFx3JF0rKT4vLFxuICAgICAgICBmdW5jdGlvbihtYXRjaCkge1xuICAgICAgICAgICAgLy8gR3JvdXBzIHdpdGggdGhlIHNhbWUgbmFtZSBpcyBhbiBlcnJvciwgZWxzZSB3b3VsZCBuZWVkIGBsYXN0SW5kZXhPZmBcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGlzTmFOKG1hdGNoWzFdKSA/IChpbmRleE9mKHRoaXMuY2FwdHVyZU5hbWVzLCBtYXRjaFsxXSkgKyAxKSA6ICttYXRjaFsxXSxcbiAgICAgICAgICAgICAgICBlbmRJbmRleCA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKCFpbmRleCB8fCBpbmRleCA+IHRoaXMuY2FwdHVyZU5hbWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQmFja3JlZmVyZW5jZSB0byB1bmRlZmluZWQgZ3JvdXAgJyArIG1hdGNoWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEtlZXAgYmFja3JlZmVyZW5jZXMgc2VwYXJhdGUgZnJvbSBzdWJzZXF1ZW50IGxpdGVyYWwgbnVtYmVyc1xuICAgICAgICAgICAgcmV0dXJuICdcXFxcJyArIGluZGV4ICsgKFxuICAgICAgICAgICAgICAgIGVuZEluZGV4ID09PSBtYXRjaC5pbnB1dC5sZW5ndGggfHwgaXNOYU4obWF0Y2guaW5wdXQuY2hhckF0KGVuZEluZGV4KSkgP1xuICAgICAgICAgICAgICAgICAgICAnJyA6ICcoPzopJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcbiAgICAgICAge2xlYWRDaGFyOiAnXFxcXCd9XG4gICAgKTtcblxuLypcbiAqIE51bWJlcmVkIGJhY2tyZWZlcmVuY2Ugb3Igb2N0YWwsIHBsdXMgYW55IGZvbGxvd2luZyBkaWdpdHM6IGBcXDBgLCBgXFwxMWAsIGV0Yy4gT2N0YWxzIGV4Y2VwdCBgXFwwYFxuICogbm90IGZvbGxvd2VkIGJ5IDAtOSBhbmQgYmFja3JlZmVyZW5jZXMgdG8gdW5vcGVuZWQgY2FwdHVyZSBncm91cHMgdGhyb3cgYW4gZXJyb3IuIE90aGVyIG1hdGNoZXNcbiAqIGFyZSByZXR1cm5lZCB1bmFsdGVyZWQuIElFIDwgOSBkb2Vzbid0IHN1cHBvcnQgYmFja3JlZmVyZW5jZXMgYWJvdmUgYFxcOTlgIGluIHJlZ2V4IHN5bnRheC5cbiAqL1xuICAgIGFkZChcbiAgICAgICAgL1xcXFwoXFxkKykvLFxuICAgICAgICBmdW5jdGlvbihtYXRjaCwgc2NvcGUpIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAhKFxuICAgICAgICAgICAgICAgICAgICBzY29wZSA9PT0gZGVmYXVsdFNjb3BlICYmXG4gICAgICAgICAgICAgICAgICAgIC9eWzEtOV0vLnRlc3QobWF0Y2hbMV0pICYmXG4gICAgICAgICAgICAgICAgICAgICttYXRjaFsxXSA8PSB0aGlzLmNhcHR1cmVOYW1lcy5sZW5ndGhcbiAgICAgICAgICAgICAgICApICYmXG4gICAgICAgICAgICAgICAgbWF0Y2hbMV0gIT09ICcwJ1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdDYW5ub3QgdXNlIG9jdGFsIGVzY2FwZSBvciBiYWNrcmVmZXJlbmNlIHRvIHVuZGVmaW5lZCBncm91cCAnICtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hbMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoWzBdO1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBzY29wZTogJ2FsbCcsXG4gICAgICAgICAgICBsZWFkQ2hhcjogJ1xcXFwnXG4gICAgICAgIH1cbiAgICApO1xuXG4vKlxuICogTmFtZWQgY2FwdHVyaW5nIGdyb3VwOyBtYXRjaCB0aGUgb3BlbmluZyBkZWxpbWl0ZXIgb25seTogYCg/PG5hbWU+YC4gQ2FwdHVyZSBuYW1lcyBjYW4gdXNlIHRoZVxuICogY2hhcmFjdGVycyBBLVosIGEteiwgMC05LCBfLCBhbmQgJCBvbmx5LiBOYW1lcyBjYW4ndCBiZSBpbnRlZ2Vycy4gU3VwcG9ydHMgUHl0aG9uLXN0eWxlXG4gKiBgKD9QPG5hbWU+YCBhcyBhbiBhbHRlcm5hdGUgc3ludGF4IHRvIGF2b2lkIGlzc3VlcyBpbiBzb21lIG9sZGVyIHZlcnNpb25zIG9mIE9wZXJhIHdoaWNoIG5hdGl2ZWx5XG4gKiBzdXBwb3J0ZWQgdGhlIFB5dGhvbi1zdHlsZSBzeW50YXguIE90aGVyd2lzZSwgWFJlZ0V4cCBtaWdodCB0cmVhdCBudW1iZXJlZCBiYWNrcmVmZXJlbmNlcyB0b1xuICogUHl0aG9uLXN0eWxlIG5hbWVkIGNhcHR1cmUgYXMgb2N0YWxzLlxuICovXG4gICAgYWRkKFxuICAgICAgICAvXFwoXFw/UD88KFtcXHckXSspPi8sXG4gICAgICAgIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgICAgICAgICAvLyBEaXNhbGxvdyBiYXJlIGludGVnZXJzIGFzIG5hbWVzIGJlY2F1c2UgbmFtZWQgYmFja3JlZmVyZW5jZXMgYXJlIGFkZGVkIHRvIG1hdGNoXG4gICAgICAgICAgICAvLyBhcnJheXMgYW5kIHRoZXJlZm9yZSBudW1lcmljIHByb3BlcnRpZXMgbWF5IGxlYWQgdG8gaW5jb3JyZWN0IGxvb2t1cHNcbiAgICAgICAgICAgIGlmICghaXNOYU4obWF0Y2hbMV0pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdDYW5ub3QgdXNlIGludGVnZXIgYXMgY2FwdHVyZSBuYW1lICcgKyBtYXRjaFswXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hbMV0gPT09ICdsZW5ndGgnIHx8IG1hdGNoWzFdID09PSAnX19wcm90b19fJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQ2Fubm90IHVzZSByZXNlcnZlZCB3b3JkIGFzIGNhcHR1cmUgbmFtZSAnICsgbWF0Y2hbMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluZGV4T2YodGhpcy5jYXB0dXJlTmFtZXMsIG1hdGNoWzFdKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdDYW5ub3QgdXNlIHNhbWUgbmFtZSBmb3IgbXVsdGlwbGUgZ3JvdXBzICcgKyBtYXRjaFswXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNhcHR1cmVOYW1lcy5wdXNoKG1hdGNoWzFdKTtcbiAgICAgICAgICAgIHRoaXMuaGFzTmFtZWRDYXB0dXJlID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiAnKCc7XG4gICAgICAgIH0sXG4gICAgICAgIHtsZWFkQ2hhcjogJygnfVxuICAgICk7XG5cbi8qXG4gKiBDYXB0dXJpbmcgZ3JvdXA7IG1hdGNoIHRoZSBvcGVuaW5nIHBhcmVudGhlc2lzIG9ubHkuIFJlcXVpcmVkIGZvciBzdXBwb3J0IG9mIG5hbWVkIGNhcHR1cmluZ1xuICogZ3JvdXBzLiBBbHNvIGFkZHMgZXhwbGljaXQgY2FwdHVyZSBtb2RlIChmbGFnIG4pLlxuICovXG4gICAgYWRkKFxuICAgICAgICAvXFwoKD8hXFw/KS8sXG4gICAgICAgIGZ1bmN0aW9uKG1hdGNoLCBzY29wZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIGlmIChmbGFncy5pbmRleE9mKCduJykgPiAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnKD86JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2FwdHVyZU5hbWVzLnB1c2gobnVsbCk7XG4gICAgICAgICAgICByZXR1cm4gJygnO1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBvcHRpb25hbEZsYWdzOiAnbicsXG4gICAgICAgICAgICBsZWFkQ2hhcjogJygnXG4gICAgICAgIH1cbiAgICApO1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEV4cG9zZSBYUmVnRXhwXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuICAgIHJldHVybiBzZWxmO1xuXG59KCkpO1xuXG4vKiFcbiAqIFhSZWdFeHAuYnVpbGQgMy4wLjBcbiAqIDxodHRwOi8veHJlZ2V4cC5jb20vPlxuICogU3RldmVuIExldml0aGFuIChjKSAyMDEyLTIwMTUgTUlUIExpY2Vuc2VcbiAqIEluc3BpcmVkIGJ5IExlYSBWZXJvdSdzIFJlZ0V4cC5jcmVhdGUgPGh0dHA6Ly9sZWEudmVyb3UubWUvPlxuICovXG5cbihmdW5jdGlvbihYUmVnRXhwKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIFJFR0VYX0RBVEEgPSAneHJlZ2V4cCcsXG4gICAgICAgIHN1YlBhcnRzID0gLyhcXCgpKD8hXFw/KXxcXFxcKFsxLTldXFxkKil8XFxcXFtcXHNcXFNdfFxcWyg/OlteXFxcXFxcXV18XFxcXFtcXHNcXFNdKSpdL2csXG4gICAgICAgIHBhcnRzID0gWFJlZ0V4cC51bmlvbihbL1xcKHt7KFtcXHckXSspfX1cXCl8e3soW1xcdyRdKyl9fS8sIHN1YlBhcnRzXSwgJ2cnKTtcblxuLyoqXG4gKiBTdHJpcHMgYSBsZWFkaW5nIGBeYCBhbmQgdHJhaWxpbmcgdW5lc2NhcGVkIGAkYCwgaWYgYm90aCBhcmUgcHJlc2VudC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtTdHJpbmd9IHBhdHRlcm4gUGF0dGVybiB0byBwcm9jZXNzLlxuICogQHJldHVybnMge1N0cmluZ30gUGF0dGVybiB3aXRoIGVkZ2UgYW5jaG9ycyByZW1vdmVkLlxuICovXG4gICAgZnVuY3Rpb24gZGVhbmNob3IocGF0dGVybikge1xuICAgICAgICB2YXIgbGVhZGluZ0FuY2hvciA9IC9eXFxeLyxcbiAgICAgICAgICAgIHRyYWlsaW5nQW5jaG9yID0gL1xcJCQvO1xuXG4gICAgICAgIC8vIEVuc3VyZSB0aGF0IHRoZSB0cmFpbGluZyBgJGAgaXNuJ3QgZXNjYXBlZFxuICAgICAgICBpZiAobGVhZGluZ0FuY2hvci50ZXN0KHBhdHRlcm4pICYmIHRyYWlsaW5nQW5jaG9yLnRlc3QocGF0dGVybi5yZXBsYWNlKC9cXFxcW1xcc1xcU10vZywgJycpKSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhdHRlcm4ucmVwbGFjZShsZWFkaW5nQW5jaG9yLCAnJykucmVwbGFjZSh0cmFpbGluZ0FuY2hvciwgJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhdHRlcm47XG4gICAgfVxuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBwcm92aWRlZCB2YWx1ZSB0byBhbiBYUmVnRXhwLiBOYXRpdmUgUmVnRXhwIGZsYWdzIGFyZSBub3QgcHJlc2VydmVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB9IHZhbHVlIFZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7UmVnRXhwfSBYUmVnRXhwIG9iamVjdCB3aXRoIFhSZWdFeHAgc3ludGF4IGFwcGxpZWQuXG4gKi9cbiAgICBmdW5jdGlvbiBhc1hSZWdFeHAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIFhSZWdFeHAuaXNSZWdFeHAodmFsdWUpID9cbiAgICAgICAgICAgICh2YWx1ZVtSRUdFWF9EQVRBXSAmJiB2YWx1ZVtSRUdFWF9EQVRBXS5jYXB0dXJlTmFtZXMgP1xuICAgICAgICAgICAgICAgIC8vIERvbid0IHJlY29tcGlsZSwgdG8gcHJlc2VydmUgY2FwdHVyZSBuYW1lc1xuICAgICAgICAgICAgICAgIHZhbHVlIDpcbiAgICAgICAgICAgICAgICAvLyBSZWNvbXBpbGUgYXMgWFJlZ0V4cFxuICAgICAgICAgICAgICAgIFhSZWdFeHAodmFsdWUuc291cmNlKVxuICAgICAgICAgICAgKSA6XG4gICAgICAgICAgICAvLyBDb21waWxlIHN0cmluZyBhcyBYUmVnRXhwXG4gICAgICAgICAgICBYUmVnRXhwKHZhbHVlKTtcbiAgICB9XG5cbi8qKlxuICogQnVpbGRzIHJlZ2V4ZXMgdXNpbmcgbmFtZWQgc3VicGF0dGVybnMsIGZvciByZWFkYWJpbGl0eSBhbmQgcGF0dGVybiByZXVzZS4gQmFja3JlZmVyZW5jZXMgaW4gdGhlXG4gKiBvdXRlciBwYXR0ZXJuIGFuZCBwcm92aWRlZCBzdWJwYXR0ZXJucyBhcmUgYXV0b21hdGljYWxseSByZW51bWJlcmVkIHRvIHdvcmsgY29ycmVjdGx5LiBOYXRpdmVcbiAqIGZsYWdzIHVzZWQgYnkgcHJvdmlkZWQgc3VicGF0dGVybnMgYXJlIGlnbm9yZWQgaW4gZmF2b3Igb2YgdGhlIGBmbGFnc2AgYXJndW1lbnQuXG4gKlxuICogQG1lbWJlck9mIFhSZWdFeHBcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXR0ZXJuIFhSZWdFeHAgcGF0dGVybiB1c2luZyBge3tuYW1lfX1gIGZvciBlbWJlZGRlZCBzdWJwYXR0ZXJucy4gQWxsb3dzXG4gKiAgIGAoe3tuYW1lfX0pYCBhcyBzaG9ydGhhbmQgZm9yIGAoPzxuYW1lPnt7bmFtZX19KWAuIFBhdHRlcm5zIGNhbm5vdCBiZSBlbWJlZGRlZCB3aXRoaW5cbiAqICAgY2hhcmFjdGVyIGNsYXNzZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3VicyBMb29rdXAgb2JqZWN0IGZvciBuYW1lZCBzdWJwYXR0ZXJucy4gVmFsdWVzIGNhbiBiZSBzdHJpbmdzIG9yIHJlZ2V4ZXMuIEFcbiAqICAgbGVhZGluZyBgXmAgYW5kIHRyYWlsaW5nIHVuZXNjYXBlZCBgJGAgYXJlIHN0cmlwcGVkIGZyb20gc3VicGF0dGVybnMsIGlmIGJvdGggYXJlIHByZXNlbnQuXG4gKiBAcGFyYW0ge1N0cmluZ30gW2ZsYWdzXSBBbnkgY29tYmluYXRpb24gb2YgWFJlZ0V4cCBmbGFncy5cbiAqIEByZXR1cm5zIHtSZWdFeHB9IFJlZ2V4IHdpdGggaW50ZXJwb2xhdGVkIHN1YnBhdHRlcm5zLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgdGltZSA9IFhSZWdFeHAuYnVpbGQoJyg/eCleIHt7aG91cnN9fSAoe3ttaW51dGVzfX0pICQnLCB7XG4gKiAgIGhvdXJzOiBYUmVnRXhwLmJ1aWxkKCd7e2gxMn19IDogfCB7e2gyNH19Jywge1xuICogICAgIGgxMjogLzFbMC0yXXwwP1sxLTldLyxcbiAqICAgICBoMjQ6IC8yWzAtM118WzAxXVswLTldL1xuICogICB9LCAneCcpLFxuICogICBtaW51dGVzOiAvXlswLTVdWzAtOV0kL1xuICogfSk7XG4gKiB0aW1lLnRlc3QoJzEwOjU5Jyk7IC8vIC0+IHRydWVcbiAqIFhSZWdFeHAuZXhlYygnMTA6NTknLCB0aW1lKS5taW51dGVzOyAvLyAtPiAnNTknXG4gKi9cbiAgICBYUmVnRXhwLmJ1aWxkID0gZnVuY3Rpb24ocGF0dGVybiwgc3VicywgZmxhZ3MpIHtcbiAgICAgICAgdmFyIGlubGluZUZsYWdzID0gL15cXChcXD8oW1xcdyRdKylcXCkvLmV4ZWMocGF0dGVybiksXG4gICAgICAgICAgICBkYXRhID0ge30sXG4gICAgICAgICAgICBudW1DYXBzID0gMCwgLy8gJ0NhcHMnIGlzIHNob3J0IGZvciBjYXB0dXJlc1xuICAgICAgICAgICAgbnVtUHJpb3JDYXBzLFxuICAgICAgICAgICAgbnVtT3V0ZXJDYXBzID0gMCxcbiAgICAgICAgICAgIG91dGVyQ2Fwc01hcCA9IFswXSxcbiAgICAgICAgICAgIG91dGVyQ2FwTmFtZXMsXG4gICAgICAgICAgICBzdWIsXG4gICAgICAgICAgICBwO1xuXG4gICAgICAgIC8vIEFkZCBmbGFncyB3aXRoaW4gYSBsZWFkaW5nIG1vZGUgbW9kaWZpZXIgdG8gdGhlIG92ZXJhbGwgcGF0dGVybidzIGZsYWdzXG4gICAgICAgIGlmIChpbmxpbmVGbGFncykge1xuICAgICAgICAgICAgZmxhZ3MgPSBmbGFncyB8fCAnJztcbiAgICAgICAgICAgIGlubGluZUZsYWdzWzFdLnJlcGxhY2UoLy4vZywgZnVuY3Rpb24oZmxhZykge1xuICAgICAgICAgICAgICAgIC8vIERvbid0IGFkZCBkdXBsaWNhdGVzXG4gICAgICAgICAgICAgICAgZmxhZ3MgKz0gKGZsYWdzLmluZGV4T2YoZmxhZykgPiAtMSA/ICcnIDogZmxhZyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAocCBpbiBzdWJzKSB7XG4gICAgICAgICAgICBpZiAoc3Vicy5oYXNPd25Qcm9wZXJ0eShwKSkge1xuICAgICAgICAgICAgICAgIC8vIFBhc3NpbmcgdG8gWFJlZ0V4cCBlbmFibGVzIGV4dGVuZGVkIHN5bnRheCBhbmQgZW5zdXJlcyBpbmRlcGVuZGVudCB2YWxpZGl0eSxcbiAgICAgICAgICAgICAgICAvLyBsZXN0IGFuIHVuZXNjYXBlZCBgKGAsIGApYCwgYFtgLCBvciB0cmFpbGluZyBgXFxgIGJyZWFrcyB0aGUgYCg/OilgIHdyYXBwZXIuIEZvclxuICAgICAgICAgICAgICAgIC8vIHN1YnBhdHRlcm5zIHByb3ZpZGVkIGFzIG5hdGl2ZSByZWdleGVzLCBpdCBkaWVzIG9uIG9jdGFscyBhbmQgYWRkcyB0aGUgcHJvcGVydHlcbiAgICAgICAgICAgICAgICAvLyB1c2VkIHRvIGhvbGQgZXh0ZW5kZWQgcmVnZXggaW5zdGFuY2UgZGF0YSwgZm9yIHNpbXBsaWNpdHlcbiAgICAgICAgICAgICAgICBzdWIgPSBhc1hSZWdFeHAoc3Vic1twXSk7XG4gICAgICAgICAgICAgICAgZGF0YVtwXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRGVhbmNob3JpbmcgYWxsb3dzIGVtYmVkZGluZyBpbmRlcGVuZGVudGx5IHVzZWZ1bCBhbmNob3JlZCByZWdleGVzLiBJZiB5b3VcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVhbGx5IG5lZWQgdG8ga2VlcCB5b3VyIGFuY2hvcnMsIGRvdWJsZSB0aGVtIChpLmUuLCBgXl4uLi4kJGApXG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm46IGRlYW5jaG9yKHN1Yi5zb3VyY2UpLFxuICAgICAgICAgICAgICAgICAgICBuYW1lczogc3ViW1JFR0VYX0RBVEFdLmNhcHR1cmVOYW1lcyB8fCBbXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQYXNzaW5nIHRvIFhSZWdFeHAgZGllcyBvbiBvY3RhbHMgYW5kIGVuc3VyZXMgdGhlIG91dGVyIHBhdHRlcm4gaXMgaW5kZXBlbmRlbnRseSB2YWxpZDtcbiAgICAgICAgLy8gaGVscHMga2VlcCB0aGlzIHNpbXBsZS4gTmFtZWQgY2FwdHVyZXMgd2lsbCBiZSBwdXQgYmFja1xuICAgICAgICBwYXR0ZXJuID0gYXNYUmVnRXhwKHBhdHRlcm4pO1xuICAgICAgICBvdXRlckNhcE5hbWVzID0gcGF0dGVybltSRUdFWF9EQVRBXS5jYXB0dXJlTmFtZXMgfHwgW107XG4gICAgICAgIHBhdHRlcm4gPSBwYXR0ZXJuLnNvdXJjZS5yZXBsYWNlKHBhcnRzLCBmdW5jdGlvbigkMCwgJDEsICQyLCAkMywgJDQpIHtcbiAgICAgICAgICAgIHZhciBzdWJOYW1lID0gJDEgfHwgJDIsIGNhcE5hbWUsIGludHJvO1xuICAgICAgICAgICAgLy8gTmFtZWQgc3VicGF0dGVyblxuICAgICAgICAgICAgaWYgKHN1Yk5hbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWRhdGEuaGFzT3duUHJvcGVydHkoc3ViTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKCdVbmRlZmluZWQgcHJvcGVydHkgJyArICQwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gTmFtZWQgc3VicGF0dGVybiB3YXMgd3JhcHBlZCBpbiBhIGNhcHR1cmluZyBncm91cFxuICAgICAgICAgICAgICAgIGlmICgkMSkge1xuICAgICAgICAgICAgICAgICAgICBjYXBOYW1lID0gb3V0ZXJDYXBOYW1lc1tudW1PdXRlckNhcHNdO1xuICAgICAgICAgICAgICAgICAgICBvdXRlckNhcHNNYXBbKytudW1PdXRlckNhcHNdID0gKytudW1DYXBzO1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBpdCdzIGEgbmFtZWQgZ3JvdXAsIHByZXNlcnZlIHRoZSBuYW1lLiBPdGhlcndpc2UsIHVzZSB0aGUgc3VicGF0dGVybiBuYW1lXG4gICAgICAgICAgICAgICAgICAgIC8vIGFzIHRoZSBjYXB0dXJlIG5hbWVcbiAgICAgICAgICAgICAgICAgICAgaW50cm8gPSAnKD88JyArIChjYXBOYW1lIHx8IHN1Yk5hbWUpICsgJz4nO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGludHJvID0gJyg/Oic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG51bVByaW9yQ2FwcyA9IG51bUNhcHM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGludHJvICsgZGF0YVtzdWJOYW1lXS5wYXR0ZXJuLnJlcGxhY2Uoc3ViUGFydHMsIGZ1bmN0aW9uKG1hdGNoLCBwYXJlbiwgYmFja3JlZikge1xuICAgICAgICAgICAgICAgICAgICAvLyBDYXB0dXJpbmcgZ3JvdXBcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXBOYW1lID0gZGF0YVtzdWJOYW1lXS5uYW1lc1tudW1DYXBzIC0gbnVtUHJpb3JDYXBzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICsrbnVtQ2FwcztcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBjdXJyZW50IGNhcHR1cmUgaGFzIGEgbmFtZSwgcHJlc2VydmUgdGhlIG5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYXBOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcoPzwnICsgY2FwTmFtZSArICc+JztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gQmFja3JlZmVyZW5jZVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGJhY2tyZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJld3JpdGUgdGhlIGJhY2tyZWZlcmVuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnXFxcXCcgKyAoK2JhY2tyZWYgKyBudW1QcmlvckNhcHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgICAgICAgICB9KSArICcpJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENhcHR1cmluZyBncm91cFxuICAgICAgICAgICAgaWYgKCQzKSB7XG4gICAgICAgICAgICAgICAgY2FwTmFtZSA9IG91dGVyQ2FwTmFtZXNbbnVtT3V0ZXJDYXBzXTtcbiAgICAgICAgICAgICAgICBvdXRlckNhcHNNYXBbKytudW1PdXRlckNhcHNdID0gKytudW1DYXBzO1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBjdXJyZW50IGNhcHR1cmUgaGFzIGEgbmFtZSwgcHJlc2VydmUgdGhlIG5hbWVcbiAgICAgICAgICAgICAgICBpZiAoY2FwTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyg/PCcgKyBjYXBOYW1lICsgJz4nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEJhY2tyZWZlcmVuY2VcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoJDQpIHtcbiAgICAgICAgICAgICAgICAvLyBSZXdyaXRlIHRoZSBiYWNrcmVmZXJlbmNlXG4gICAgICAgICAgICAgICAgcmV0dXJuICdcXFxcJyArIG91dGVyQ2Fwc01hcFsrJDRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICQwO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gWFJlZ0V4cChwYXR0ZXJuLCBmbGFncyk7XG4gICAgfTtcblxufShYUmVnRXhwKSk7XG5cbi8qIVxuICogWFJlZ0V4cC5tYXRjaFJlY3Vyc2l2ZSAzLjAuMFxuICogPGh0dHA6Ly94cmVnZXhwLmNvbS8+XG4gKiBTdGV2ZW4gTGV2aXRoYW4gKGMpIDIwMDktMjAxNSBNSVQgTGljZW5zZVxuICovXG5cbihmdW5jdGlvbihYUmVnRXhwKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFJldHVybnMgYSBtYXRjaCBkZXRhaWwgb2JqZWN0IGNvbXBvc2VkIG9mIHRoZSBwcm92aWRlZCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuICAgIGZ1bmN0aW9uIHJvdyhuYW1lLCB2YWx1ZSwgc3RhcnQsIGVuZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgIGVuZDogZW5kXG4gICAgICAgIH07XG4gICAgfVxuXG4vKipcbiAqIFJldHVybnMgYW4gYXJyYXkgb2YgbWF0Y2ggc3RyaW5ncyBiZXR3ZWVuIG91dGVybW9zdCBsZWZ0IGFuZCByaWdodCBkZWxpbWl0ZXJzLCBvciBhbiBhcnJheSBvZlxuICogb2JqZWN0cyB3aXRoIGRldGFpbGVkIG1hdGNoIHBhcnRzIGFuZCBwb3NpdGlvbiBkYXRhLiBBbiBlcnJvciBpcyB0aHJvd24gaWYgZGVsaW1pdGVycyBhcmVcbiAqIHVuYmFsYW5jZWQgd2l0aGluIHRoZSBkYXRhLlxuICpcbiAqIEBtZW1iZXJPZiBYUmVnRXhwXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFN0cmluZyB0byBzZWFyY2guXG4gKiBAcGFyYW0ge1N0cmluZ30gbGVmdCBMZWZ0IGRlbGltaXRlciBhcyBhbiBYUmVnRXhwIHBhdHRlcm4uXG4gKiBAcGFyYW0ge1N0cmluZ30gcmlnaHQgUmlnaHQgZGVsaW1pdGVyIGFzIGFuIFhSZWdFeHAgcGF0dGVybi5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbZmxhZ3NdIEFueSBuYXRpdmUgb3IgWFJlZ0V4cCBmbGFncywgdXNlZCBmb3IgdGhlIGxlZnQgYW5kIHJpZ2h0IGRlbGltaXRlcnMuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIExldHMgeW91IHNwZWNpZnkgYHZhbHVlTmFtZXNgIGFuZCBgZXNjYXBlQ2hhcmAgb3B0aW9ucy5cbiAqIEByZXR1cm5zIHtBcnJheX0gQXJyYXkgb2YgbWF0Y2hlcywgb3IgYW4gZW1wdHkgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIEJhc2ljIHVzYWdlXG4gKiB2YXIgc3RyID0gJyh0KChlKSlzKXQoKShpbmcpJztcbiAqIFhSZWdFeHAubWF0Y2hSZWN1cnNpdmUoc3RyLCAnXFxcXCgnLCAnXFxcXCknLCAnZycpO1xuICogLy8gLT4gWyd0KChlKSlzJywgJycsICdpbmcnXVxuICpcbiAqIC8vIEV4dGVuZGVkIGluZm9ybWF0aW9uIG1vZGUgd2l0aCB2YWx1ZU5hbWVzXG4gKiBzdHIgPSAnSGVyZSBpcyA8ZGl2PiA8ZGl2PmFuPC9kaXY+PC9kaXY+IGV4YW1wbGUnO1xuICogWFJlZ0V4cC5tYXRjaFJlY3Vyc2l2ZShzdHIsICc8ZGl2XFxcXHMqPicsICc8L2Rpdj4nLCAnZ2knLCB7XG4gKiAgIHZhbHVlTmFtZXM6IFsnYmV0d2VlbicsICdsZWZ0JywgJ21hdGNoJywgJ3JpZ2h0J11cbiAqIH0pO1xuICogLy8gLT4gW1xuICogLy8ge25hbWU6ICdiZXR3ZWVuJywgdmFsdWU6ICdIZXJlIGlzICcsICAgICAgIHN0YXJ0OiAwLCAgZW5kOiA4fSxcbiAqIC8vIHtuYW1lOiAnbGVmdCcsICAgIHZhbHVlOiAnPGRpdj4nLCAgICAgICAgICBzdGFydDogOCwgIGVuZDogMTN9LFxuICogLy8ge25hbWU6ICdtYXRjaCcsICAgdmFsdWU6ICcgPGRpdj5hbjwvZGl2PicsIHN0YXJ0OiAxMywgZW5kOiAyN30sXG4gKiAvLyB7bmFtZTogJ3JpZ2h0JywgICB2YWx1ZTogJzwvZGl2PicsICAgICAgICAgc3RhcnQ6IDI3LCBlbmQ6IDMzfSxcbiAqIC8vIHtuYW1lOiAnYmV0d2VlbicsIHZhbHVlOiAnIGV4YW1wbGUnLCAgICAgICBzdGFydDogMzMsIGVuZDogNDF9XG4gKiAvLyBdXG4gKlxuICogLy8gT21pdHRpbmcgdW5uZWVkZWQgcGFydHMgd2l0aCBudWxsIHZhbHVlTmFtZXMsIGFuZCB1c2luZyBlc2NhcGVDaGFyXG4gKiBzdHIgPSAnLi4uezF9XFxcXHt7ZnVuY3Rpb24oeCx5KXtyZXR1cm4geSt4O319JztcbiAqIFhSZWdFeHAubWF0Y2hSZWN1cnNpdmUoc3RyLCAneycsICd9JywgJ2cnLCB7XG4gKiAgIHZhbHVlTmFtZXM6IFsnbGl0ZXJhbCcsIG51bGwsICd2YWx1ZScsIG51bGxdLFxuICogICBlc2NhcGVDaGFyOiAnXFxcXCdcbiAqIH0pO1xuICogLy8gLT4gW1xuICogLy8ge25hbWU6ICdsaXRlcmFsJywgdmFsdWU6ICcuLi4nLCBzdGFydDogMCwgZW5kOiAzfSxcbiAqIC8vIHtuYW1lOiAndmFsdWUnLCAgIHZhbHVlOiAnMScsICAgc3RhcnQ6IDQsIGVuZDogNX0sXG4gKiAvLyB7bmFtZTogJ2xpdGVyYWwnLCB2YWx1ZTogJ1xcXFx7Jywgc3RhcnQ6IDYsIGVuZDogOH0sXG4gKiAvLyB7bmFtZTogJ3ZhbHVlJywgICB2YWx1ZTogJ2Z1bmN0aW9uKHgseSl7cmV0dXJuIHkreDt9Jywgc3RhcnQ6IDksIGVuZDogMzV9XG4gKiAvLyBdXG4gKlxuICogLy8gU3RpY2t5IG1vZGUgdmlhIGZsYWcgeVxuICogc3RyID0gJzwxPjw8PDI+Pj48Mz40PDU+JztcbiAqIFhSZWdFeHAubWF0Y2hSZWN1cnNpdmUoc3RyLCAnPCcsICc+JywgJ2d5Jyk7XG4gKiAvLyAtPiBbJzEnLCAnPDwyPj4nLCAnMyddXG4gKi9cbiAgICBYUmVnRXhwLm1hdGNoUmVjdXJzaXZlID0gZnVuY3Rpb24oc3RyLCBsZWZ0LCByaWdodCwgZmxhZ3MsIG9wdGlvbnMpIHtcbiAgICAgICAgZmxhZ3MgPSBmbGFncyB8fCAnJztcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIHZhciBnbG9iYWwgPSBmbGFncy5pbmRleE9mKCdnJykgPiAtMSxcbiAgICAgICAgICAgIHN0aWNreSA9IGZsYWdzLmluZGV4T2YoJ3knKSA+IC0xLFxuICAgICAgICAgICAgLy8gRmxhZyBgeWAgaXMgY29udHJvbGxlZCBpbnRlcm5hbGx5XG4gICAgICAgICAgICBiYXNpY0ZsYWdzID0gZmxhZ3MucmVwbGFjZSgveS9nLCAnJyksXG4gICAgICAgICAgICBlc2NhcGVDaGFyID0gb3B0aW9ucy5lc2NhcGVDaGFyLFxuICAgICAgICAgICAgdk4gPSBvcHRpb25zLnZhbHVlTmFtZXMsXG4gICAgICAgICAgICBvdXRwdXQgPSBbXSxcbiAgICAgICAgICAgIG9wZW5Ub2tlbnMgPSAwLFxuICAgICAgICAgICAgZGVsaW1TdGFydCA9IDAsXG4gICAgICAgICAgICBkZWxpbUVuZCA9IDAsXG4gICAgICAgICAgICBsYXN0T3V0ZXJFbmQgPSAwLFxuICAgICAgICAgICAgb3V0ZXJTdGFydCxcbiAgICAgICAgICAgIGlubmVyU3RhcnQsXG4gICAgICAgICAgICBsZWZ0TWF0Y2gsXG4gICAgICAgICAgICByaWdodE1hdGNoLFxuICAgICAgICAgICAgZXNjO1xuICAgICAgICBsZWZ0ID0gWFJlZ0V4cChsZWZ0LCBiYXNpY0ZsYWdzKTtcbiAgICAgICAgcmlnaHQgPSBYUmVnRXhwKHJpZ2h0LCBiYXNpY0ZsYWdzKTtcblxuICAgICAgICBpZiAoZXNjYXBlQ2hhcikge1xuICAgICAgICAgICAgaWYgKGVzY2FwZUNoYXIubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHVzZSBtb3JlIHRoYW4gb25lIGVzY2FwZSBjaGFyYWN0ZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVzY2FwZUNoYXIgPSBYUmVnRXhwLmVzY2FwZShlc2NhcGVDaGFyKTtcbiAgICAgICAgICAgIC8vIFVzaW5nIGBYUmVnRXhwLnVuaW9uYCBzYWZlbHkgcmV3cml0ZXMgYmFja3JlZmVyZW5jZXMgaW4gYGxlZnRgIGFuZCBgcmlnaHRgXG4gICAgICAgICAgICBlc2MgPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgICAgICcoPzonICsgZXNjYXBlQ2hhciArICdbXFxcXFNcXFxcc118KD86KD8hJyArXG4gICAgICAgICAgICAgICAgICAgIFhSZWdFeHAudW5pb24oW2xlZnQsIHJpZ2h0XSkuc291cmNlICtcbiAgICAgICAgICAgICAgICAgICAgJylbXicgKyBlc2NhcGVDaGFyICsgJ10pKykrJyxcbiAgICAgICAgICAgICAgICAvLyBGbGFncyBgZ3lgIG5vdCBuZWVkZWQgaGVyZVxuICAgICAgICAgICAgICAgIGZsYWdzLnJlcGxhY2UoL1teaW11XSsvZywgJycpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIC8vIElmIHVzaW5nIGFuIGVzY2FwZSBjaGFyYWN0ZXIsIGFkdmFuY2UgdG8gdGhlIGRlbGltaXRlcidzIG5leHQgc3RhcnRpbmcgcG9zaXRpb24sXG4gICAgICAgICAgICAvLyBza2lwcGluZyBhbnkgZXNjYXBlZCBjaGFyYWN0ZXJzIGluIGJldHdlZW5cbiAgICAgICAgICAgIGlmIChlc2NhcGVDaGFyKSB7XG4gICAgICAgICAgICAgICAgZGVsaW1FbmQgKz0gKFhSZWdFeHAuZXhlYyhzdHIsIGVzYywgZGVsaW1FbmQsICdzdGlja3knKSB8fCBbJyddKVswXS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZWZ0TWF0Y2ggPSBYUmVnRXhwLmV4ZWMoc3RyLCBsZWZ0LCBkZWxpbUVuZCk7XG4gICAgICAgICAgICByaWdodE1hdGNoID0gWFJlZ0V4cC5leGVjKHN0ciwgcmlnaHQsIGRlbGltRW5kKTtcbiAgICAgICAgICAgIC8vIEtlZXAgdGhlIGxlZnRtb3N0IG1hdGNoIG9ubHlcbiAgICAgICAgICAgIGlmIChsZWZ0TWF0Y2ggJiYgcmlnaHRNYXRjaCkge1xuICAgICAgICAgICAgICAgIGlmIChsZWZ0TWF0Y2guaW5kZXggPD0gcmlnaHRNYXRjaC5pbmRleCkge1xuICAgICAgICAgICAgICAgICAgICByaWdodE1hdGNoID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0TWF0Y2ggPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFBhdGhzIChMTTogbGVmdE1hdGNoLCBSTTogcmlnaHRNYXRjaCwgT1Q6IG9wZW5Ub2tlbnMpOlxuICAgICAgICAgICAgLy8gTE0gfCBSTSB8IE9UIHwgUmVzdWx0XG4gICAgICAgICAgICAvLyAxICB8IDAgIHwgMSAgfCBsb29wXG4gICAgICAgICAgICAvLyAxICB8IDAgIHwgMCAgfCBsb29wXG4gICAgICAgICAgICAvLyAwICB8IDEgIHwgMSAgfCBsb29wXG4gICAgICAgICAgICAvLyAwICB8IDEgIHwgMCAgfCB0aHJvd1xuICAgICAgICAgICAgLy8gMCAgfCAwICB8IDEgIHwgdGhyb3dcbiAgICAgICAgICAgIC8vIDAgIHwgMCAgfCAwICB8IGJyZWFrXG4gICAgICAgICAgICAvLyBUaGUgcGF0aHMgYWJvdmUgZG9uJ3QgaW5jbHVkZSB0aGUgc3RpY2t5IG1vZGUgc3BlY2lhbCBjYXNlLiBUaGUgbG9vcCBlbmRzIGFmdGVyIHRoZVxuICAgICAgICAgICAgLy8gZmlyc3QgY29tcGxldGVkIG1hdGNoIGlmIG5vdCBgZ2xvYmFsYC5cbiAgICAgICAgICAgIGlmIChsZWZ0TWF0Y2ggfHwgcmlnaHRNYXRjaCkge1xuICAgICAgICAgICAgICAgIGRlbGltU3RhcnQgPSAobGVmdE1hdGNoIHx8IHJpZ2h0TWF0Y2gpLmluZGV4O1xuICAgICAgICAgICAgICAgIGRlbGltRW5kID0gZGVsaW1TdGFydCArIChsZWZ0TWF0Y2ggfHwgcmlnaHRNYXRjaClbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghb3BlblRva2Vucykge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0aWNreSAmJiAhb3BlblRva2VucyAmJiBkZWxpbVN0YXJ0ID4gbGFzdE91dGVyRW5kKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGVmdE1hdGNoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFvcGVuVG9rZW5zKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dGVyU3RhcnQgPSBkZWxpbVN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICBpbm5lclN0YXJ0ID0gZGVsaW1FbmQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICsrb3BlblRva2VucztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmlnaHRNYXRjaCAmJiBvcGVuVG9rZW5zKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEtLW9wZW5Ub2tlbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZOKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodk5bMF0gJiYgb3V0ZXJTdGFydCA+IGxhc3RPdXRlckVuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKHJvdyh2TlswXSwgc3RyLnNsaWNlKGxhc3RPdXRlckVuZCwgb3V0ZXJTdGFydCksIGxhc3RPdXRlckVuZCwgb3V0ZXJTdGFydCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZOWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2gocm93KHZOWzFdLCBzdHIuc2xpY2Uob3V0ZXJTdGFydCwgaW5uZXJTdGFydCksIG91dGVyU3RhcnQsIGlubmVyU3RhcnQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2TlsyXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKHJvdyh2TlsyXSwgc3RyLnNsaWNlKGlubmVyU3RhcnQsIGRlbGltU3RhcnQpLCBpbm5lclN0YXJ0LCBkZWxpbVN0YXJ0KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodk5bM10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChyb3codk5bM10sIHN0ci5zbGljZShkZWxpbVN0YXJ0LCBkZWxpbUVuZCksIGRlbGltU3RhcnQsIGRlbGltRW5kKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChzdHIuc2xpY2UoaW5uZXJTdGFydCwgZGVsaW1TdGFydCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxhc3RPdXRlckVuZCA9IGRlbGltRW5kO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWdsb2JhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5iYWxhbmNlZCBkZWxpbWl0ZXIgZm91bmQgaW4gc3RyaW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB0aGUgZGVsaW1pdGVyIG1hdGNoZWQgYW4gZW1wdHkgc3RyaW5nLCBhdm9pZCBhbiBpbmZpbml0ZSBsb29wXG4gICAgICAgICAgICBpZiAoZGVsaW1TdGFydCA9PT0gZGVsaW1FbmQpIHtcbiAgICAgICAgICAgICAgICArK2RlbGltRW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGdsb2JhbCAmJiAhc3RpY2t5ICYmIHZOICYmIHZOWzBdICYmIHN0ci5sZW5ndGggPiBsYXN0T3V0ZXJFbmQpIHtcbiAgICAgICAgICAgIG91dHB1dC5wdXNoKHJvdyh2TlswXSwgc3RyLnNsaWNlKGxhc3RPdXRlckVuZCksIGxhc3RPdXRlckVuZCwgc3RyLmxlbmd0aCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9O1xuXG59KFhSZWdFeHApKTtcblxuLyohXG4gKiBYUmVnRXhwIFVuaWNvZGUgQmFzZSAzLjAuMFxuICogPGh0dHA6Ly94cmVnZXhwLmNvbS8+XG4gKiBTdGV2ZW4gTGV2aXRoYW4gKGMpIDIwMDgtMjAxNSBNSVQgTGljZW5zZVxuICovXG5cbi8qKlxuICogQWRkcyBiYXNlIHN1cHBvcnQgZm9yIFVuaWNvZGUgbWF0Y2hpbmc6XG4gKiAtIEFkZHMgc3ludGF4IGBcXHB7Li59YCBmb3IgbWF0Y2hpbmcgVW5pY29kZSB0b2tlbnMuIFRva2VucyBjYW4gYmUgaW52ZXJ0ZWQgdXNpbmcgYFxcUHsuLn1gIG9yXG4gKiAgIGBcXHB7Xi4ufWAuIFRva2VuIG5hbWVzIGlnbm9yZSBjYXNlLCBzcGFjZXMsIGh5cGhlbnMsIGFuZCB1bmRlcnNjb3Jlcy4gWW91IGNhbiBvbWl0IHRoZSBicmFja2V0c1xuICogICBmb3IgdG9rZW4gbmFtZXMgdGhhdCBhcmUgYSBzaW5nbGUgbGV0dGVyIChlLmcuIGBcXHBMYCBvciBgUExgKS5cbiAqIC0gQWRkcyBmbGFnIEEgKGFzdHJhbCksIHdoaWNoIGVuYWJsZXMgMjEtYml0IFVuaWNvZGUgc3VwcG9ydC5cbiAqIC0gQWRkcyB0aGUgYFhSZWdFeHAuYWRkVW5pY29kZURhdGFgIG1ldGhvZCB1c2VkIGJ5IG90aGVyIGFkZG9ucyB0byBwcm92aWRlIGNoYXJhY3RlciBkYXRhLlxuICpcbiAqIFVuaWNvZGUgQmFzZSByZWxpZXMgb24gZXh0ZXJuYWxseSBwcm92aWRlZCBVbmljb2RlIGNoYXJhY3RlciBkYXRhLiBPZmZpY2lhbCBhZGRvbnMgYXJlIGF2YWlsYWJsZVxuICogdG8gcHJvdmlkZSBkYXRhIGZvciBVbmljb2RlIGNhdGVnb3JpZXMsIHNjcmlwdHMsIGJsb2NrcywgYW5kIHByb3BlcnRpZXMuXG4gKlxuICogQHJlcXVpcmVzIFhSZWdFeHBcbiAqL1xuKGZ1bmN0aW9uKFhSZWdFeHApIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbi8vIFN0b3JhZ2UgZm9yIFVuaWNvZGUgZGF0YVxuICAgIHZhciB1bmljb2RlID0ge307XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogUHJpdmF0ZSBmdW5jdGlvbnNcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG4vLyBHZW5lcmF0ZXMgYSB0b2tlbiBsb29rdXAgbmFtZTogbG93ZXJjYXNlLCB3aXRoIGh5cGhlbnMsIHNwYWNlcywgYW5kIHVuZGVyc2NvcmVzIHJlbW92ZWRcbiAgICBmdW5jdGlvbiBub3JtYWxpemUobmFtZSkge1xuICAgICAgICByZXR1cm4gbmFtZS5yZXBsYWNlKC9bLSBfXSsvZywgJycpLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4vLyBBZGRzIGxlYWRpbmcgemVyb3MgaWYgc2hvcnRlciB0aGFuIGZvdXIgY2hhcmFjdGVyc1xuICAgIGZ1bmN0aW9uIHBhZDQoc3RyKSB7XG4gICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgNCkge1xuICAgICAgICAgICAgc3RyID0gJzAnICsgc3RyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuXG4vLyBDb252ZXJ0cyBhIGhleGFkZWNpbWFsIG51bWJlciB0byBkZWNpbWFsXG4gICAgZnVuY3Rpb24gZGVjKGhleCkge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQoaGV4LCAxNik7XG4gICAgfVxuXG4vLyBDb252ZXJ0cyBhIGRlY2ltYWwgbnVtYmVyIHRvIGhleGFkZWNpbWFsXG4gICAgZnVuY3Rpb24gaGV4KGRlYykge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQoZGVjLCAxMCkudG9TdHJpbmcoMTYpO1xuICAgIH1cblxuLy8gR2V0cyB0aGUgZGVjaW1hbCBjb2RlIG9mIGEgbGl0ZXJhbCBjb2RlIHVuaXQsIFxceEhILCBcXHVISEhILCBvciBhIGJhY2tzbGFzaC1lc2NhcGVkIGxpdGVyYWxcbiAgICBmdW5jdGlvbiBjaGFyQ29kZShjaHIpIHtcbiAgICAgICAgdmFyIGVzYyA9IC9eXFxcXFt4dV0oLispLy5leGVjKGNocik7XG4gICAgICAgIHJldHVybiBlc2MgP1xuICAgICAgICAgICAgZGVjKGVzY1sxXSkgOlxuICAgICAgICAgICAgY2hyLmNoYXJDb2RlQXQoY2hyLmNoYXJBdCgwKSA9PT0gJ1xcXFwnID8gMSA6IDApO1xuICAgIH1cblxuLy8gSW52ZXJ0cyBhIGxpc3Qgb2Ygb3JkZXJlZCBCTVAgY2hhcmFjdGVycyBhbmQgcmFuZ2VzXG4gICAgZnVuY3Rpb24gaW52ZXJ0Qm1wKHJhbmdlKSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSAnJyxcbiAgICAgICAgICAgIGxhc3RFbmQgPSAtMSxcbiAgICAgICAgICAgIHN0YXJ0O1xuICAgICAgICBYUmVnRXhwLmZvckVhY2gocmFuZ2UsIC8oXFxcXHguLnxcXFxcdS4uLi58XFxcXD9bXFxzXFxTXSkoPzotKFxcXFx4Li58XFxcXHUuLi4ufFxcXFw/W1xcc1xcU10pKT8vLCBmdW5jdGlvbihtKSB7XG4gICAgICAgICAgICBzdGFydCA9IGNoYXJDb2RlKG1bMV0pO1xuICAgICAgICAgICAgaWYgKHN0YXJ0ID4gKGxhc3RFbmQgKyAxKSkge1xuICAgICAgICAgICAgICAgIG91dHB1dCArPSAnXFxcXHUnICsgcGFkNChoZXgobGFzdEVuZCArIDEpKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnQgPiAobGFzdEVuZCArIDIpKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dCArPSAnLVxcXFx1JyArIHBhZDQoaGV4KHN0YXJ0IC0gMSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3RFbmQgPSBjaGFyQ29kZShtWzJdIHx8IG1bMV0pO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGxhc3RFbmQgPCAweEZGRkYpIHtcbiAgICAgICAgICAgIG91dHB1dCArPSAnXFxcXHUnICsgcGFkNChoZXgobGFzdEVuZCArIDEpKTtcbiAgICAgICAgICAgIGlmIChsYXN0RW5kIDwgMHhGRkZFKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ICs9ICctXFxcXHVGRkZGJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cblxuLy8gR2VuZXJhdGVzIGFuIGludmVydGVkIEJNUCByYW5nZSBvbiBmaXJzdCB1c2VcbiAgICBmdW5jdGlvbiBjYWNoZUludmVydGVkQm1wKHNsdWcpIHtcbiAgICAgICAgdmFyIHByb3AgPSAnYiEnO1xuICAgICAgICByZXR1cm4gdW5pY29kZVtzbHVnXVtwcm9wXSB8fCAoXG4gICAgICAgICAgICB1bmljb2RlW3NsdWddW3Byb3BdID0gaW52ZXJ0Qm1wKHVuaWNvZGVbc2x1Z10uYm1wKVxuICAgICAgICApO1xuICAgIH1cblxuLy8gQ29tYmluZXMgYW5kIG9wdGlvbmFsbHkgbmVnYXRlcyBCTVAgYW5kIGFzdHJhbCBkYXRhXG4gICAgZnVuY3Rpb24gYnVpbGRBc3RyYWwoc2x1ZywgaXNOZWdhdGVkKSB7XG4gICAgICAgIHZhciBpdGVtID0gdW5pY29kZVtzbHVnXSxcbiAgICAgICAgICAgIGNvbWJpbmVkID0gJyc7XG4gICAgICAgIGlmIChpdGVtLmJtcCAmJiAhaXRlbS5pc0JtcExhc3QpIHtcbiAgICAgICAgICAgIGNvbWJpbmVkID0gJ1snICsgaXRlbS5ibXAgKyAnXScgKyAoaXRlbS5hc3RyYWwgPyAnfCcgOiAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGl0ZW0uYXN0cmFsKSB7XG4gICAgICAgICAgICBjb21iaW5lZCArPSBpdGVtLmFzdHJhbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXRlbS5pc0JtcExhc3QgJiYgaXRlbS5ibXApIHtcbiAgICAgICAgICAgIGNvbWJpbmVkICs9IChpdGVtLmFzdHJhbCA/ICd8JyA6ICcnKSArICdbJyArIGl0ZW0uYm1wICsgJ10nO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFzdHJhbCBVbmljb2RlIHRva2VucyBhbHdheXMgbWF0Y2ggYSBjb2RlIHBvaW50LCBuZXZlciBhIGNvZGUgdW5pdFxuICAgICAgICByZXR1cm4gaXNOZWdhdGVkID9cbiAgICAgICAgICAgICcoPzooPyEnICsgY29tYmluZWQgKyAnKSg/OltcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl18W1xcMC1cXHVGRkZGXSkpJyA6XG4gICAgICAgICAgICAnKD86JyArIGNvbWJpbmVkICsgJyknO1xuICAgIH1cblxuLy8gQnVpbGRzIGEgY29tcGxldGUgYXN0cmFsIHBhdHRlcm4gb24gZmlyc3QgdXNlXG4gICAgZnVuY3Rpb24gY2FjaGVBc3RyYWwoc2x1ZywgaXNOZWdhdGVkKSB7XG4gICAgICAgIHZhciBwcm9wID0gaXNOZWdhdGVkID8gJ2EhJyA6ICdhPSc7XG4gICAgICAgIHJldHVybiB1bmljb2RlW3NsdWddW3Byb3BdIHx8IChcbiAgICAgICAgICAgIHVuaWNvZGVbc2x1Z11bcHJvcF0gPSBidWlsZEFzdHJhbChzbHVnLCBpc05lZ2F0ZWQpXG4gICAgICAgICk7XG4gICAgfVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcmUgZnVuY3Rpb25hbGl0eVxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cbi8qXG4gKiBBZGQgVW5pY29kZSB0b2tlbiBzeW50YXg6IFxccHsuLn0sIFxcUHsuLn0sIFxccHteLi59LiBBbHNvIGFkZCBhc3RyYWwgbW9kZSAoZmxhZyBBKS5cbiAqL1xuICAgIFhSZWdFeHAuYWRkVG9rZW4oXG4gICAgICAgIC8vIFVzZSBgKmAgaW5zdGVhZCBvZiBgK2AgdG8gYXZvaWQgY2FwdHVyaW5nIGBeYCBhcyB0aGUgdG9rZW4gbmFtZSBpbiBgXFxwe159YFxuICAgICAgICAvXFxcXChbcFBdKSg/OnsoXFxePykoW159XSopfXwoW0EtWmEtel0pKS8sXG4gICAgICAgIGZ1bmN0aW9uKG1hdGNoLCBzY29wZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHZhciBFUlJfRE9VQkxFX05FRyA9ICdJbnZhbGlkIGRvdWJsZSBuZWdhdGlvbiAnLFxuICAgICAgICAgICAgICAgIEVSUl9VTktOT1dOX05BTUUgPSAnVW5rbm93biBVbmljb2RlIHRva2VuICcsXG4gICAgICAgICAgICAgICAgRVJSX1VOS05PV05fUkVGID0gJ1VuaWNvZGUgdG9rZW4gbWlzc2luZyBkYXRhICcsXG4gICAgICAgICAgICAgICAgRVJSX0FTVFJBTF9PTkxZID0gJ0FzdHJhbCBtb2RlIHJlcXVpcmVkIGZvciBVbmljb2RlIHRva2VuICcsXG4gICAgICAgICAgICAgICAgRVJSX0FTVFJBTF9JTl9DTEFTUyA9ICdBc3RyYWwgbW9kZSBkb2VzIG5vdCBzdXBwb3J0IFVuaWNvZGUgdG9rZW5zIHdpdGhpbiBjaGFyYWN0ZXIgY2xhc3NlcycsXG4gICAgICAgICAgICAgICAgLy8gTmVnYXRlZCB2aWEgXFxQey4ufSBvciBcXHB7Xi4ufVxuICAgICAgICAgICAgICAgIGlzTmVnYXRlZCA9IG1hdGNoWzFdID09PSAnUCcgfHwgISFtYXRjaFsyXSxcbiAgICAgICAgICAgICAgICAvLyBTd2l0Y2ggZnJvbSBCTVAgKDAtRkZGRikgdG8gYXN0cmFsICgwLTEwRkZGRikgbW9kZSB2aWEgZmxhZyBBXG4gICAgICAgICAgICAgICAgaXNBc3RyYWxNb2RlID0gZmxhZ3MuaW5kZXhPZignQScpID4gLTEsXG4gICAgICAgICAgICAgICAgLy8gVG9rZW4gbG9va3VwIG5hbWUuIENoZWNrIGBbNF1gIGZpcnN0IHRvIGF2b2lkIHBhc3NpbmcgYHVuZGVmaW5lZGAgdmlhIGBcXHB7fWBcbiAgICAgICAgICAgICAgICBzbHVnID0gbm9ybWFsaXplKG1hdGNoWzRdIHx8IG1hdGNoWzNdKSxcbiAgICAgICAgICAgICAgICAvLyBUb2tlbiBkYXRhIG9iamVjdFxuICAgICAgICAgICAgICAgIGl0ZW0gPSB1bmljb2RlW3NsdWddO1xuXG4gICAgICAgICAgICBpZiAobWF0Y2hbMV0gPT09ICdQJyAmJiBtYXRjaFsyXSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihFUlJfRE9VQkxFX05FRyArIG1hdGNoWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdW5pY29kZS5oYXNPd25Qcm9wZXJ0eShzbHVnKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihFUlJfVU5LTk9XTl9OQU1FICsgbWF0Y2hbMF0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTd2l0Y2ggdG8gdGhlIG5lZ2F0ZWQgZm9ybSBvZiB0aGUgcmVmZXJlbmNlZCBVbmljb2RlIHRva2VuXG4gICAgICAgICAgICBpZiAoaXRlbS5pbnZlcnNlT2YpIHtcbiAgICAgICAgICAgICAgICBzbHVnID0gbm9ybWFsaXplKGl0ZW0uaW52ZXJzZU9mKTtcbiAgICAgICAgICAgICAgICBpZiAoIXVuaWNvZGUuaGFzT3duUHJvcGVydHkoc2x1ZykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKEVSUl9VTktOT1dOX1JFRiArIG1hdGNoWzBdICsgJyAtPiAnICsgaXRlbS5pbnZlcnNlT2YpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpdGVtID0gdW5pY29kZVtzbHVnXTtcbiAgICAgICAgICAgICAgICBpc05lZ2F0ZWQgPSAhaXNOZWdhdGVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIShpdGVtLmJtcCB8fCBpc0FzdHJhbE1vZGUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKEVSUl9BU1RSQUxfT05MWSArIG1hdGNoWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0FzdHJhbE1vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2NvcGUgPT09ICdjbGFzcycpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKEVSUl9BU1RSQUxfSU5fQ0xBU1MpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZUFzdHJhbChzbHVnLCBpc05lZ2F0ZWQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gc2NvcGUgPT09ICdjbGFzcycgP1xuICAgICAgICAgICAgICAgIChpc05lZ2F0ZWQgPyBjYWNoZUludmVydGVkQm1wKHNsdWcpIDogaXRlbS5ibXApIDpcbiAgICAgICAgICAgICAgICAoaXNOZWdhdGVkID8gJ1teJyA6ICdbJykgKyBpdGVtLmJtcCArICddJztcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgc2NvcGU6ICdhbGwnLFxuICAgICAgICAgICAgb3B0aW9uYWxGbGFnczogJ0EnLFxuICAgICAgICAgICAgbGVhZENoYXI6ICdcXFxcJ1xuICAgICAgICB9XG4gICAgKTtcblxuLyoqXG4gKiBBZGRzIHRvIHRoZSBsaXN0IG9mIFVuaWNvZGUgdG9rZW5zIHRoYXQgWFJlZ0V4cCByZWdleGVzIGNhbiBtYXRjaCB2aWEgYFxccGAgb3IgYFxcUGAuXG4gKlxuICogQG1lbWJlck9mIFhSZWdFeHBcbiAqIEBwYXJhbSB7QXJyYXl9IGRhdGEgT2JqZWN0cyB3aXRoIG5hbWVkIGNoYXJhY3RlciByYW5nZXMuIEVhY2ggb2JqZWN0IG1heSBoYXZlIHByb3BlcnRpZXMgYG5hbWVgLFxuICogICBgYWxpYXNgLCBgaXNCbXBMYXN0YCwgYGludmVyc2VPZmAsIGBibXBgLCBhbmQgYGFzdHJhbGAuIEFsbCBidXQgYG5hbWVgIGFyZSBvcHRpb25hbCwgYWx0aG91Z2hcbiAqICAgb25lIG9mIGBibXBgIG9yIGBhc3RyYWxgIGlzIHJlcXVpcmVkICh1bmxlc3MgYGludmVyc2VPZmAgaXMgc2V0KS4gSWYgYGFzdHJhbGAgaXMgYWJzZW50LCB0aGVcbiAqICAgYGJtcGAgZGF0YSBpcyB1c2VkIGZvciBCTVAgYW5kIGFzdHJhbCBtb2Rlcy4gSWYgYGJtcGAgaXMgYWJzZW50LCB0aGUgbmFtZSBlcnJvcnMgaW4gQk1QIG1vZGVcbiAqICAgYnV0IHdvcmtzIGluIGFzdHJhbCBtb2RlLiBJZiBib3RoIGBibXBgIGFuZCBgYXN0cmFsYCBhcmUgcHJvdmlkZWQsIHRoZSBgYm1wYCBkYXRhIG9ubHkgaXMgdXNlZFxuICogICBpbiBCTVAgbW9kZSwgYW5kIHRoZSBjb21iaW5hdGlvbiBvZiBgYm1wYCBhbmQgYGFzdHJhbGAgZGF0YSBpcyB1c2VkIGluIGFzdHJhbCBtb2RlLlxuICogICBgaXNCbXBMYXN0YCBpcyBuZWVkZWQgd2hlbiBhIHRva2VuIG1hdGNoZXMgb3JwaGFuIGhpZ2ggc3Vycm9nYXRlcyAqYW5kKiB1c2VzIHN1cnJvZ2F0ZSBwYWlyc1xuICogICB0byBtYXRjaCBhc3RyYWwgY29kZSBwb2ludHMuIFRoZSBgYm1wYCBhbmQgYGFzdHJhbGAgZGF0YSBzaG91bGQgYmUgYSBjb21iaW5hdGlvbiBvZiBsaXRlcmFsXG4gKiAgIGNoYXJhY3RlcnMgYW5kIGBcXHhISGAgb3IgYFxcdUhISEhgIGVzY2FwZSBzZXF1ZW5jZXMsIHdpdGggaHlwaGVucyB0byBjcmVhdGUgcmFuZ2VzLiBBbnkgcmVnZXhcbiAqICAgbWV0YWNoYXJhY3RlcnMgaW4gdGhlIGRhdGEgc2hvdWxkIGJlIGVzY2FwZWQsIGFwYXJ0IGZyb20gcmFuZ2UtY3JlYXRpbmcgaHlwaGVucy4gVGhlIGBhc3RyYWxgXG4gKiAgIGRhdGEgY2FuIGFkZGl0aW9uYWxseSB1c2UgY2hhcmFjdGVyIGNsYXNzZXMgYW5kIGFsdGVybmF0aW9uLCBhbmQgc2hvdWxkIHVzZSBzdXJyb2dhdGUgcGFpcnMgdG9cbiAqICAgcmVwcmVzZW50IGFzdHJhbCBjb2RlIHBvaW50cy4gYGludmVyc2VPZmAgY2FuIGJlIHVzZWQgdG8gYXZvaWQgZHVwbGljYXRpbmcgY2hhcmFjdGVyIGRhdGEgaWYgYVxuICogICBVbmljb2RlIHRva2VuIGlzIGRlZmluZWQgYXMgdGhlIGV4YWN0IGludmVyc2Ugb2YgYW5vdGhlciB0b2tlbi5cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gQmFzaWMgdXNlXG4gKiBYUmVnRXhwLmFkZFVuaWNvZGVEYXRhKFt7XG4gKiAgIG5hbWU6ICdYRGlnaXQnLFxuICogICBhbGlhczogJ0hleGFkZWNpbWFsJyxcbiAqICAgYm1wOiAnMC05QS1GYS1mJ1xuICogfV0pO1xuICogWFJlZ0V4cCgnXFxcXHB7WERpZ2l0fTpcXFxccHtIZXhhZGVjaW1hbH0rJykudGVzdCgnMDozRCcpOyAvLyAtPiB0cnVlXG4gKi9cbiAgICBYUmVnRXhwLmFkZFVuaWNvZGVEYXRhID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB2YXIgRVJSX05PX05BTUUgPSAnVW5pY29kZSB0b2tlbiByZXF1aXJlcyBuYW1lJyxcbiAgICAgICAgICAgIEVSUl9OT19EQVRBID0gJ1VuaWNvZGUgdG9rZW4gaGFzIG5vIGNoYXJhY3RlciBkYXRhICcsXG4gICAgICAgICAgICBpdGVtLFxuICAgICAgICAgICAgaTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaXRlbSA9IGRhdGFbaV07XG4gICAgICAgICAgICBpZiAoIWl0ZW0ubmFtZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihFUlJfTk9fTkFNRSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIShpdGVtLmludmVyc2VPZiB8fCBpdGVtLmJtcCB8fCBpdGVtLmFzdHJhbCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoRVJSX05PX0RBVEEgKyBpdGVtLm5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdW5pY29kZVtub3JtYWxpemUoaXRlbS5uYW1lKV0gPSBpdGVtO1xuICAgICAgICAgICAgaWYgKGl0ZW0uYWxpYXMpIHtcbiAgICAgICAgICAgICAgICB1bmljb2RlW25vcm1hbGl6ZShpdGVtLmFsaWFzKV0gPSBpdGVtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVzZXQgdGhlIHBhdHRlcm4gY2FjaGUgdXNlZCBieSB0aGUgYFhSZWdFeHBgIGNvbnN0cnVjdG9yLCBzaW5jZSB0aGUgc2FtZSBwYXR0ZXJuIGFuZFxuICAgICAgICAvLyBmbGFncyBtaWdodCBub3cgcHJvZHVjZSBkaWZmZXJlbnQgcmVzdWx0c1xuICAgICAgICBYUmVnRXhwLmNhY2hlLmZsdXNoKCdwYXR0ZXJucycpO1xuICAgIH07XG5cbn0oWFJlZ0V4cCkpO1xuXG4vKiFcbiAqIFhSZWdFeHAgVW5pY29kZSBCbG9ja3MgMy4wLjBcbiAqIDxodHRwOi8veHJlZ2V4cC5jb20vPlxuICogU3RldmVuIExldml0aGFuIChjKSAyMDEwLTIwMTUgTUlUIExpY2Vuc2VcbiAqIFVuaWNvZGUgZGF0YSBwcm92aWRlZCBieSBNYXRoaWFzIEJ5bmVucyA8aHR0cDovL21hdGhpYXNieW5lbnMuYmUvPlxuICovXG5cbi8qKlxuICogQWRkcyBzdXBwb3J0IGZvciBhbGwgVW5pY29kZSBibG9ja3MuIEJsb2NrIG5hbWVzIHVzZSB0aGUgcHJlZml4ICdJbicuIEUuZy4sIGBcXHB7SW5CYXNpY0xhdGlufWAuXG4gKiBUb2tlbiBuYW1lcyBhcmUgY2FzZSBpbnNlbnNpdGl2ZSwgYW5kIGFueSBzcGFjZXMsIGh5cGhlbnMsIGFuZCB1bmRlcnNjb3JlcyBhcmUgaWdub3JlZC5cbiAqXG4gKiBVc2VzIFVuaWNvZGUgOC4wLjAuXG4gKlxuICogQHJlcXVpcmVzIFhSZWdFeHAsIFVuaWNvZGUgQmFzZVxuICovXG4oZnVuY3Rpb24oWFJlZ0V4cCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGlmICghWFJlZ0V4cC5hZGRVbmljb2RlRGF0YSkge1xuICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoJ1VuaWNvZGUgQmFzZSBtdXN0IGJlIGxvYWRlZCBiZWZvcmUgVW5pY29kZSBCbG9ja3MnKTtcbiAgICB9XG5cbiAgICBYUmVnRXhwLmFkZFVuaWNvZGVEYXRhKFtcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luQWVnZWFuX051bWJlcnMnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMFtcXHVERDAwLVxcdUREM0ZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5BaG9tJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDVbXFx1REYwMC1cXHVERjNGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luQWxjaGVtaWNhbF9TeW1ib2xzJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4M0RbXFx1REYwMC1cXHVERjdGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luQWxwaGFiZXRpY19QcmVzZW50YXRpb25fRm9ybXMnLFxuICAgICAgICAgICAgYm1wOiAnXFx1RkIwMC1cXHVGQjRGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5BbmF0b2xpYW5fSGllcm9nbHlwaHMnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgxMVtcXHVEQzAwLVxcdURFN0ZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5BbmNpZW50X0dyZWVrX011c2ljYWxfTm90YXRpb24nLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgzNFtcXHVERTAwLVxcdURFNEZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5BbmNpZW50X0dyZWVrX051bWJlcnMnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMFtcXHVERDQwLVxcdUREOEZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5BbmNpZW50X1N5bWJvbHMnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMFtcXHVERDkwLVxcdUREQ0ZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5BcmFiaWMnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MDYwMC1cXHUwNkZGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5BcmFiaWNfRXh0ZW5kZWRfQScsXG4gICAgICAgICAgICBibXA6ICdcXHUwOEEwLVxcdTA4RkYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkFyYWJpY19NYXRoZW1hdGljYWxfQWxwaGFiZXRpY19TeW1ib2xzJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4M0JbXFx1REUwMC1cXHVERUZGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luQXJhYmljX1ByZXNlbnRhdGlvbl9Gb3Jtc19BJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdUZCNTAtXFx1RkRGRidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luQXJhYmljX1ByZXNlbnRhdGlvbl9Gb3Jtc19CJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdUZFNzAtXFx1RkVGRidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luQXJhYmljX1N1cHBsZW1lbnQnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MDc1MC1cXHUwNzdGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5Bcm1lbmlhbicsXG4gICAgICAgICAgICBibXA6ICdcXHUwNTMwLVxcdTA1OEYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkFycm93cycsXG4gICAgICAgICAgICBibXA6ICdcXHUyMTkwLVxcdTIxRkYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkF2ZXN0YW4nLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMltcXHVERjAwLVxcdURGM0ZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5CYWxpbmVzZScsXG4gICAgICAgICAgICBibXA6ICdcXHUxQjAwLVxcdTFCN0YnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkJhbXVtJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdUE2QTAtXFx1QTZGRidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luQmFtdW1fU3VwcGxlbWVudCcsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODFBW1xcdURDMDAtXFx1REUzRl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkJhc2ljX0xhdGluJyxcbiAgICAgICAgICAgIGJtcDogJ1xcMC1cXHg3RidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luQmFzc2FfVmFoJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MUFbXFx1REVEMC1cXHVERUZGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luQmF0YWsnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MUJDMC1cXHUxQkZGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5CZW5nYWxpJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTA5ODAtXFx1MDlGRidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luQmxvY2tfRWxlbWVudHMnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MjU4MC1cXHUyNTlGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5Cb3BvbW9mbycsXG4gICAgICAgICAgICBibXA6ICdcXHUzMTAwLVxcdTMxMkYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkJvcG9tb2ZvX0V4dGVuZGVkJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTMxQTAtXFx1MzFCRidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luQm94X0RyYXdpbmcnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MjUwMC1cXHUyNTdGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5CcmFobWknLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwNFtcXHVEQzAwLVxcdURDN0ZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5CcmFpbGxlX1BhdHRlcm5zJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTI4MDAtXFx1MjhGRidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luQnVnaW5lc2UnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MUEwMC1cXHUxQTFGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5CdWhpZCcsXG4gICAgICAgICAgICBibXA6ICdcXHUxNzQwLVxcdTE3NUYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkJ5emFudGluZV9NdXNpY2FsX1N5bWJvbHMnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgzNFtcXHVEQzAwLVxcdURDRkZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5DSktfQ29tcGF0aWJpbGl0eScsXG4gICAgICAgICAgICBibXA6ICdcXHUzMzAwLVxcdTMzRkYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkNKS19Db21wYXRpYmlsaXR5X0Zvcm1zJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdUZFMzAtXFx1RkU0RidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luQ0pLX0NvbXBhdGliaWxpdHlfSWRlb2dyYXBocycsXG4gICAgICAgICAgICBibXA6ICdcXHVGOTAwLVxcdUZBRkYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkNKS19Db21wYXRpYmlsaXR5X0lkZW9ncmFwaHNfU3VwcGxlbWVudCcsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODdFW1xcdURDMDAtXFx1REUxRl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkNKS19SYWRpY2Fsc19TdXBwbGVtZW50JyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTJFODAtXFx1MkVGRidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luQ0pLX1N0cm9rZXMnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MzFDMC1cXHUzMUVGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5DSktfU3ltYm9sc19hbmRfUHVuY3R1YXRpb24nLFxuICAgICAgICAgICAgYm1wOiAnXFx1MzAwMC1cXHUzMDNGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5DSktfVW5pZmllZF9JZGVvZ3JhcGhzJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTRFMDAtXFx1OUZGRidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luQ0pLX1VuaWZpZWRfSWRlb2dyYXBoc19FeHRlbnNpb25fQScsXG4gICAgICAgICAgICBibXA6ICdcXHUzNDAwLVxcdTREQkYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkNKS19VbmlmaWVkX0lkZW9ncmFwaHNfRXh0ZW5zaW9uX0InLFxuICAgICAgICAgICAgYXN0cmFsOiAnW1xcdUQ4NDAtXFx1RDg2OF1bXFx1REMwMC1cXHVERkZGXXxcXHVEODY5W1xcdURDMDAtXFx1REVERl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkNKS19VbmlmaWVkX0lkZW9ncmFwaHNfRXh0ZW5zaW9uX0MnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDg2RFtcXHVEQzAwLVxcdURGM0ZdfFtcXHVEODZBLVxcdUQ4NkNdW1xcdURDMDAtXFx1REZGRl18XFx1RDg2OVtcXHVERjAwLVxcdURGRkZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5DSktfVW5pZmllZF9JZGVvZ3JhcGhzX0V4dGVuc2lvbl9EJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4NkRbXFx1REY0MC1cXHVERkZGXXxcXHVEODZFW1xcdURDMDAtXFx1REMxRl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkNKS19VbmlmaWVkX0lkZW9ncmFwaHNfRXh0ZW5zaW9uX0UnLFxuICAgICAgICAgICAgYXN0cmFsOiAnW1xcdUQ4NkYtXFx1RDg3Ml1bXFx1REMwMC1cXHVERkZGXXxcXHVEODczW1xcdURDMDAtXFx1REVBRl18XFx1RDg2RVtcXHVEQzIwLVxcdURGRkZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5DYXJpYW4nLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMFtcXHVERUEwLVxcdURFREZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5DYXVjYXNpYW5fQWxiYW5pYW4nLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMVtcXHVERDMwLVxcdURENkZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5DaGFrbWEnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwNFtcXHVERDAwLVxcdURENEZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5DaGFtJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdUFBMDAtXFx1QUE1RidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luQ2hlcm9rZWUnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MTNBMC1cXHUxM0ZGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5DaGVyb2tlZV9TdXBwbGVtZW50JyxcbiAgICAgICAgICAgIGJtcDogJ1xcdUFCNzAtXFx1QUJCRidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luQ29tYmluaW5nX0RpYWNyaXRpY2FsX01hcmtzJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTAzMDAtXFx1MDM2RidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luQ29tYmluaW5nX0RpYWNyaXRpY2FsX01hcmtzX0V4dGVuZGVkJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTFBQjAtXFx1MUFGRidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luQ29tYmluaW5nX0RpYWNyaXRpY2FsX01hcmtzX1N1cHBsZW1lbnQnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MURDMC1cXHUxREZGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5Db21iaW5pbmdfRGlhY3JpdGljYWxfTWFya3NfZm9yX1N5bWJvbHMnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MjBEMC1cXHUyMEZGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5Db21iaW5pbmdfSGFsZl9NYXJrcycsXG4gICAgICAgICAgICBibXA6ICdcXHVGRTIwLVxcdUZFMkYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkNvbW1vbl9JbmRpY19OdW1iZXJfRm9ybXMnLFxuICAgICAgICAgICAgYm1wOiAnXFx1QTgzMC1cXHVBODNGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5Db250cm9sX1BpY3R1cmVzJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTI0MDAtXFx1MjQzRidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luQ29wdGljJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTJDODAtXFx1MkNGRidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luQ29wdGljX0VwYWN0X051bWJlcnMnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMFtcXHVERUUwLVxcdURFRkZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5Db3VudGluZ19Sb2RfTnVtZXJhbHMnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgzNFtcXHVERjYwLVxcdURGN0ZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5DdW5laWZvcm0nLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwOFtcXHVEQzAwLVxcdURGRkZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5DdW5laWZvcm1fTnVtYmVyc19hbmRfUHVuY3R1YXRpb24nLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwOVtcXHVEQzAwLVxcdURDN0ZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5DdXJyZW5jeV9TeW1ib2xzJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTIwQTAtXFx1MjBDRidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luQ3lwcmlvdF9TeWxsYWJhcnknLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMltcXHVEQzAwLVxcdURDM0ZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5DeXJpbGxpYycsXG4gICAgICAgICAgICBibXA6ICdcXHUwNDAwLVxcdTA0RkYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkN5cmlsbGljX0V4dGVuZGVkX0EnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MkRFMC1cXHUyREZGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5DeXJpbGxpY19FeHRlbmRlZF9CJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdUE2NDAtXFx1QTY5RidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luQ3lyaWxsaWNfU3VwcGxlbWVudCcsXG4gICAgICAgICAgICBibXA6ICdcXHUwNTAwLVxcdTA1MkYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkRlc2VyZXQnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMVtcXHVEQzAwLVxcdURDNEZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5EZXZhbmFnYXJpJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTA5MDAtXFx1MDk3RidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luRGV2YW5hZ2FyaV9FeHRlbmRlZCcsXG4gICAgICAgICAgICBibXA6ICdcXHVBOEUwLVxcdUE4RkYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkRpbmdiYXRzJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTI3MDAtXFx1MjdCRidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luRG9taW5vX1RpbGVzJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4M0NbXFx1REMzMC1cXHVEQzlGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luRHVwbG95YW4nLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgyRltcXHVEQzAwLVxcdURDOUZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5FYXJseV9EeW5hc3RpY19DdW5laWZvcm0nLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwOVtcXHVEQzgwLVxcdURENEZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5FZ3lwdGlhbl9IaWVyb2dseXBocycsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODBDW1xcdURDMDAtXFx1REZGRl18XFx1RDgwRFtcXHVEQzAwLVxcdURDMkZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5FbGJhc2FuJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDFbXFx1REQwMC1cXHVERDJGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luRW1vdGljb25zJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4M0RbXFx1REUwMC1cXHVERTRGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luRW5jbG9zZWRfQWxwaGFudW1lcmljX1N1cHBsZW1lbnQnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgzQ1tcXHVERDAwLVxcdURERkZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5FbmNsb3NlZF9BbHBoYW51bWVyaWNzJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTI0NjAtXFx1MjRGRidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luRW5jbG9zZWRfQ0pLX0xldHRlcnNfYW5kX01vbnRocycsXG4gICAgICAgICAgICBibXA6ICdcXHUzMjAwLVxcdTMyRkYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkVuY2xvc2VkX0lkZW9ncmFwaGljX1N1cHBsZW1lbnQnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgzQ1tcXHVERTAwLVxcdURFRkZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5FdGhpb3BpYycsXG4gICAgICAgICAgICBibXA6ICdcXHUxMjAwLVxcdTEzN0YnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkV0aGlvcGljX0V4dGVuZGVkJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTJEODAtXFx1MkRERidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luRXRoaW9waWNfRXh0ZW5kZWRfQScsXG4gICAgICAgICAgICBibXA6ICdcXHVBQjAwLVxcdUFCMkYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkV0aGlvcGljX1N1cHBsZW1lbnQnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MTM4MC1cXHUxMzlGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5HZW5lcmFsX1B1bmN0dWF0aW9uJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTIwMDAtXFx1MjA2RidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luR2VvbWV0cmljX1NoYXBlcycsXG4gICAgICAgICAgICBibXA6ICdcXHUyNUEwLVxcdTI1RkYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkdlb21ldHJpY19TaGFwZXNfRXh0ZW5kZWQnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgzRFtcXHVERjgwLVxcdURGRkZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5HZW9yZ2lhbicsXG4gICAgICAgICAgICBibXA6ICdcXHUxMEEwLVxcdTEwRkYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkdlb3JnaWFuX1N1cHBsZW1lbnQnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MkQwMC1cXHUyRDJGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5HbGFnb2xpdGljJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTJDMDAtXFx1MkM1RidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luR290aGljJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDBbXFx1REYzMC1cXHVERjRGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luR3JhbnRoYScsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODA0W1xcdURGMDAtXFx1REY3Rl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkdyZWVrX0V4dGVuZGVkJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTFGMDAtXFx1MUZGRidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luR3JlZWtfYW5kX0NvcHRpYycsXG4gICAgICAgICAgICBibXA6ICdcXHUwMzcwLVxcdTAzRkYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkd1amFyYXRpJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTBBODAtXFx1MEFGRidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luR3VybXVraGknLFxuICAgICAgICAgICAgYm1wOiAnXFx1MEEwMC1cXHUwQTdGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5IYWxmd2lkdGhfYW5kX0Z1bGx3aWR0aF9Gb3JtcycsXG4gICAgICAgICAgICBibXA6ICdcXHVGRjAwLVxcdUZGRUYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkhhbmd1bF9Db21wYXRpYmlsaXR5X0phbW8nLFxuICAgICAgICAgICAgYm1wOiAnXFx1MzEzMC1cXHUzMThGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5IYW5ndWxfSmFtbycsXG4gICAgICAgICAgICBibXA6ICdcXHUxMTAwLVxcdTExRkYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkhhbmd1bF9KYW1vX0V4dGVuZGVkX0EnLFxuICAgICAgICAgICAgYm1wOiAnXFx1QTk2MC1cXHVBOTdGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5IYW5ndWxfSmFtb19FeHRlbmRlZF9CJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdUQ3QjAtXFx1RDdGRidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luSGFuZ3VsX1N5bGxhYmxlcycsXG4gICAgICAgICAgICBibXA6ICdcXHVBQzAwLVxcdUQ3QUYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkhhbnVub28nLFxuICAgICAgICAgICAgYm1wOiAnXFx1MTcyMC1cXHUxNzNGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5IYXRyYW4nLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMltcXHVEQ0UwLVxcdURDRkZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5IZWJyZXcnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MDU5MC1cXHUwNUZGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5IaWdoX1ByaXZhdGVfVXNlX1N1cnJvZ2F0ZXMnLFxuICAgICAgICAgICAgYm1wOiAnXFx1REI4MC1cXHVEQkZGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5IaWdoX1N1cnJvZ2F0ZXMnLFxuICAgICAgICAgICAgYm1wOiAnXFx1RDgwMC1cXHVEQjdGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5IaXJhZ2FuYScsXG4gICAgICAgICAgICBibXA6ICdcXHUzMDQwLVxcdTMwOUYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbklQQV9FeHRlbnNpb25zJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTAyNTAtXFx1MDJBRidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luSWRlb2dyYXBoaWNfRGVzY3JpcHRpb25fQ2hhcmFjdGVycycsXG4gICAgICAgICAgICBibXA6ICdcXHUyRkYwLVxcdTJGRkYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkltcGVyaWFsX0FyYW1haWMnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMltcXHVEQzQwLVxcdURDNUZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5JbnNjcmlwdGlvbmFsX1BhaGxhdmknLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMltcXHVERjYwLVxcdURGN0ZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5JbnNjcmlwdGlvbmFsX1BhcnRoaWFuJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDJbXFx1REY0MC1cXHVERjVGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luSmF2YW5lc2UnLFxuICAgICAgICAgICAgYm1wOiAnXFx1QTk4MC1cXHVBOURGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5LYWl0aGknLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwNFtcXHVEQzgwLVxcdURDQ0ZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5LYW5hX1N1cHBsZW1lbnQnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgyQ1tcXHVEQzAwLVxcdURDRkZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5LYW5idW4nLFxuICAgICAgICAgICAgYm1wOiAnXFx1MzE5MC1cXHUzMTlGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5LYW5neGlfUmFkaWNhbHMnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MkYwMC1cXHUyRkRGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5LYW5uYWRhJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTBDODAtXFx1MENGRidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luS2F0YWthbmEnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MzBBMC1cXHUzMEZGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5LYXRha2FuYV9QaG9uZXRpY19FeHRlbnNpb25zJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTMxRjAtXFx1MzFGRidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luS2F5YWhfTGknLFxuICAgICAgICAgICAgYm1wOiAnXFx1QTkwMC1cXHVBOTJGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5LaGFyb3NodGhpJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDJbXFx1REUwMC1cXHVERTVGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luS2htZXInLFxuICAgICAgICAgICAgYm1wOiAnXFx1MTc4MC1cXHUxN0ZGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5LaG1lcl9TeW1ib2xzJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTE5RTAtXFx1MTlGRidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luS2hvamtpJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDRbXFx1REUwMC1cXHVERTRGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luS2h1ZGF3YWRpJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDRbXFx1REVCMC1cXHVERUZGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luTGFvJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTBFODAtXFx1MEVGRidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luTGF0aW5fRXh0ZW5kZWRfQWRkaXRpb25hbCcsXG4gICAgICAgICAgICBibXA6ICdcXHUxRTAwLVxcdTFFRkYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkxhdGluX0V4dGVuZGVkX0EnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MDEwMC1cXHUwMTdGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5MYXRpbl9FeHRlbmRlZF9CJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTAxODAtXFx1MDI0RidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luTGF0aW5fRXh0ZW5kZWRfQycsXG4gICAgICAgICAgICBibXA6ICdcXHUyQzYwLVxcdTJDN0YnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkxhdGluX0V4dGVuZGVkX0QnLFxuICAgICAgICAgICAgYm1wOiAnXFx1QTcyMC1cXHVBN0ZGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5MYXRpbl9FeHRlbmRlZF9FJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdUFCMzAtXFx1QUI2RidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luTGF0aW5fMV9TdXBwbGVtZW50JyxcbiAgICAgICAgICAgIGJtcDogJ1xceDgwLVxceEZGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5MZXBjaGEnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MUMwMC1cXHUxQzRGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5MZXR0ZXJsaWtlX1N5bWJvbHMnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MjEwMC1cXHUyMTRGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5MaW1idScsXG4gICAgICAgICAgICBibXA6ICdcXHUxOTAwLVxcdTE5NEYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkxpbmVhcl9BJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDFbXFx1REUwMC1cXHVERjdGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luTGluZWFyX0JfSWRlb2dyYW1zJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDBbXFx1REM4MC1cXHVEQ0ZGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luTGluZWFyX0JfU3lsbGFiYXJ5JyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDBbXFx1REMwMC1cXHVEQzdGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luTGlzdScsXG4gICAgICAgICAgICBibXA6ICdcXHVBNEQwLVxcdUE0RkYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkxvd19TdXJyb2dhdGVzJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdURDMDAtXFx1REZGRidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luTHljaWFuJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDBbXFx1REU4MC1cXHVERTlGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luTHlkaWFuJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDJbXFx1REQyMC1cXHVERDNGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luTWFoYWphbmknLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwNFtcXHVERDUwLVxcdUREN0ZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5NYWhqb25nX1RpbGVzJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4M0NbXFx1REMwMC1cXHVEQzJGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luTWFsYXlhbGFtJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTBEMDAtXFx1MEQ3RidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luTWFuZGFpYycsXG4gICAgICAgICAgICBibXA6ICdcXHUwODQwLVxcdTA4NUYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbk1hbmljaGFlYW4nLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMltcXHVERUMwLVxcdURFRkZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5NYXRoZW1hdGljYWxfQWxwaGFudW1lcmljX1N5bWJvbHMnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgzNVtcXHVEQzAwLVxcdURGRkZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5NYXRoZW1hdGljYWxfT3BlcmF0b3JzJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTIyMDAtXFx1MjJGRidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luTWVldGVpX01heWVrJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdUFCQzAtXFx1QUJGRidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luTWVldGVpX01heWVrX0V4dGVuc2lvbnMnLFxuICAgICAgICAgICAgYm1wOiAnXFx1QUFFMC1cXHVBQUZGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5NZW5kZV9LaWtha3VpJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4M0FbXFx1REMwMC1cXHVEQ0RGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luTWVyb2l0aWNfQ3Vyc2l2ZScsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAyW1xcdUREQTAtXFx1RERGRl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbk1lcm9pdGljX0hpZXJvZ2x5cGhzJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDJbXFx1REQ4MC1cXHVERDlGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luTWlhbycsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODFCW1xcdURGMDAtXFx1REY5Rl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbk1pc2NlbGxhbmVvdXNfTWF0aGVtYXRpY2FsX1N5bWJvbHNfQScsXG4gICAgICAgICAgICBibXA6ICdcXHUyN0MwLVxcdTI3RUYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbk1pc2NlbGxhbmVvdXNfTWF0aGVtYXRpY2FsX1N5bWJvbHNfQicsXG4gICAgICAgICAgICBibXA6ICdcXHUyOTgwLVxcdTI5RkYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbk1pc2NlbGxhbmVvdXNfU3ltYm9scycsXG4gICAgICAgICAgICBibXA6ICdcXHUyNjAwLVxcdTI2RkYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbk1pc2NlbGxhbmVvdXNfU3ltYm9sc19hbmRfQXJyb3dzJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTJCMDAtXFx1MkJGRidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luTWlzY2VsbGFuZW91c19TeW1ib2xzX2FuZF9QaWN0b2dyYXBocycsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODNEW1xcdURDMDAtXFx1RERGRl18XFx1RDgzQ1tcXHVERjAwLVxcdURGRkZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5NaXNjZWxsYW5lb3VzX1RlY2huaWNhbCcsXG4gICAgICAgICAgICBibXA6ICdcXHUyMzAwLVxcdTIzRkYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbk1vZGknLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwNVtcXHVERTAwLVxcdURFNUZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5Nb2RpZmllcl9Ub25lX0xldHRlcnMnLFxuICAgICAgICAgICAgYm1wOiAnXFx1QTcwMC1cXHVBNzFGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5Nb25nb2xpYW4nLFxuICAgICAgICAgICAgYm1wOiAnXFx1MTgwMC1cXHUxOEFGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5Ncm8nLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgxQVtcXHVERTQwLVxcdURFNkZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5NdWx0YW5pJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDRbXFx1REU4MC1cXHVERUFGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luTXVzaWNhbF9TeW1ib2xzJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MzRbXFx1REQwMC1cXHVEREZGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luTXlhbm1hcicsXG4gICAgICAgICAgICBibXA6ICdcXHUxMDAwLVxcdTEwOUYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbk15YW5tYXJfRXh0ZW5kZWRfQScsXG4gICAgICAgICAgICBibXA6ICdcXHVBQTYwLVxcdUFBN0YnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbk15YW5tYXJfRXh0ZW5kZWRfQicsXG4gICAgICAgICAgICBibXA6ICdcXHVBOUUwLVxcdUE5RkYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbk5LbycsXG4gICAgICAgICAgICBibXA6ICdcXHUwN0MwLVxcdTA3RkYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbk5hYmF0YWVhbicsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAyW1xcdURDODAtXFx1RENBRl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbk5ld19UYWlfTHVlJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTE5ODAtXFx1MTlERidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luTnVtYmVyX0Zvcm1zJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTIxNTAtXFx1MjE4RidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luT2doYW0nLFxuICAgICAgICAgICAgYm1wOiAnXFx1MTY4MC1cXHUxNjlGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5PbF9DaGlraScsXG4gICAgICAgICAgICBibXA6ICdcXHUxQzUwLVxcdTFDN0YnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbk9sZF9IdW5nYXJpYW4nLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwM1tcXHVEQzgwLVxcdURDRkZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5PbGRfSXRhbGljJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDBbXFx1REYwMC1cXHVERjJGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luT2xkX05vcnRoX0FyYWJpYW4nLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMltcXHVERTgwLVxcdURFOUZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5PbGRfUGVybWljJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDBbXFx1REY1MC1cXHVERjdGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luT2xkX1BlcnNpYW4nLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMFtcXHVERkEwLVxcdURGREZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5PbGRfU291dGhfQXJhYmlhbicsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAyW1xcdURFNjAtXFx1REU3Rl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbk9sZF9UdXJraWMnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwM1tcXHVEQzAwLVxcdURDNEZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5PcHRpY2FsX0NoYXJhY3Rlcl9SZWNvZ25pdGlvbicsXG4gICAgICAgICAgICBibXA6ICdcXHUyNDQwLVxcdTI0NUYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbk9yaXlhJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTBCMDAtXFx1MEI3RidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luT3JuYW1lbnRhbF9EaW5nYmF0cycsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODNEW1xcdURFNTAtXFx1REU3Rl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbk9zbWFueWEnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMVtcXHVEQzgwLVxcdURDQUZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5QYWhhd2hfSG1vbmcnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgxQVtcXHVERjAwLVxcdURGOEZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5QYWxteXJlbmUnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMltcXHVEQzYwLVxcdURDN0ZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5QYXVfQ2luX0hhdScsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODA2W1xcdURFQzAtXFx1REVGRl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJblBoYWdzX3BhJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdUE4NDAtXFx1QTg3RidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luUGhhaXN0b3NfRGlzYycsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAwW1xcdURERDAtXFx1RERGRl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJblBob2VuaWNpYW4nLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMltcXHVERDAwLVxcdUREMUZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5QaG9uZXRpY19FeHRlbnNpb25zJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTFEMDAtXFx1MUQ3RidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luUGhvbmV0aWNfRXh0ZW5zaW9uc19TdXBwbGVtZW50JyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTFEODAtXFx1MURCRidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luUGxheWluZ19DYXJkcycsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODNDW1xcdURDQTAtXFx1RENGRl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJblByaXZhdGVfVXNlX0FyZWEnLFxuICAgICAgICAgICAgYm1wOiAnXFx1RTAwMC1cXHVGOEZGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5Qc2FsdGVyX1BhaGxhdmknLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMltcXHVERjgwLVxcdURGQUZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5SZWphbmcnLFxuICAgICAgICAgICAgYm1wOiAnXFx1QTkzMC1cXHVBOTVGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5SdW1pX051bWVyYWxfU3ltYm9scycsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAzW1xcdURFNjAtXFx1REU3Rl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJblJ1bmljJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTE2QTAtXFx1MTZGRidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luU2FtYXJpdGFuJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTA4MDAtXFx1MDgzRidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luU2F1cmFzaHRyYScsXG4gICAgICAgICAgICBibXA6ICdcXHVBODgwLVxcdUE4REYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJblNoYXJhZGEnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwNFtcXHVERDgwLVxcdUREREZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5TaGF2aWFuJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDFbXFx1REM1MC1cXHVEQzdGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luU2hvcnRoYW5kX0Zvcm1hdF9Db250cm9scycsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODJGW1xcdURDQTAtXFx1RENBRl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJblNpZGRoYW0nLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwNVtcXHVERDgwLVxcdURERkZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5TaW5oYWxhJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTBEODAtXFx1MERGRidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luU2luaGFsYV9BcmNoYWljX051bWJlcnMnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwNFtcXHVEREUwLVxcdURERkZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5TbWFsbF9Gb3JtX1ZhcmlhbnRzJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdUZFNTAtXFx1RkU2RidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luU29yYV9Tb21wZW5nJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDRbXFx1RENEMC1cXHVEQ0ZGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luU3BhY2luZ19Nb2RpZmllcl9MZXR0ZXJzJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTAyQjAtXFx1MDJGRidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luU3BlY2lhbHMnLFxuICAgICAgICAgICAgYm1wOiAnXFx1RkZGMC1cXHVGRkZGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5TdW5kYW5lc2UnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MUI4MC1cXHUxQkJGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5TdW5kYW5lc2VfU3VwcGxlbWVudCcsXG4gICAgICAgICAgICBibXA6ICdcXHUxQ0MwLVxcdTFDQ0YnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJblN1cGVyc2NyaXB0c19hbmRfU3Vic2NyaXB0cycsXG4gICAgICAgICAgICBibXA6ICdcXHUyMDcwLVxcdTIwOUYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJblN1cHBsZW1lbnRhbF9BcnJvd3NfQScsXG4gICAgICAgICAgICBibXA6ICdcXHUyN0YwLVxcdTI3RkYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJblN1cHBsZW1lbnRhbF9BcnJvd3NfQicsXG4gICAgICAgICAgICBibXA6ICdcXHUyOTAwLVxcdTI5N0YnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJblN1cHBsZW1lbnRhbF9BcnJvd3NfQycsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODNFW1xcdURDMDAtXFx1RENGRl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJblN1cHBsZW1lbnRhbF9NYXRoZW1hdGljYWxfT3BlcmF0b3JzJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTJBMDAtXFx1MkFGRidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luU3VwcGxlbWVudGFsX1B1bmN0dWF0aW9uJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTJFMDAtXFx1MkU3RidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luU3VwcGxlbWVudGFsX1N5bWJvbHNfYW5kX1BpY3RvZ3JhcGhzJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4M0VbXFx1REQwMC1cXHVEREZGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luU3VwcGxlbWVudGFyeV9Qcml2YXRlX1VzZV9BcmVhX0EnLFxuICAgICAgICAgICAgYXN0cmFsOiAnW1xcdURCODAtXFx1REJCRl1bXFx1REMwMC1cXHVERkZGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luU3VwcGxlbWVudGFyeV9Qcml2YXRlX1VzZV9BcmVhX0InLFxuICAgICAgICAgICAgYXN0cmFsOiAnW1xcdURCQzAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luU3V0dG9uX1NpZ25Xcml0aW5nJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MzZbXFx1REMwMC1cXHVERUFGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luU3lsb3RpX05hZ3JpJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdUE4MDAtXFx1QTgyRidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luU3lyaWFjJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTA3MDAtXFx1MDc0RidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luVGFnYWxvZycsXG4gICAgICAgICAgICBibXA6ICdcXHUxNzAwLVxcdTE3MUYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJblRhZ2JhbndhJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTE3NjAtXFx1MTc3RidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luVGFncycsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEQjQwW1xcdURDMDAtXFx1REM3Rl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJblRhaV9MZScsXG4gICAgICAgICAgICBibXA6ICdcXHUxOTUwLVxcdTE5N0YnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJblRhaV9UaGFtJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTFBMjAtXFx1MUFBRidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luVGFpX1ZpZXQnLFxuICAgICAgICAgICAgYm1wOiAnXFx1QUE4MC1cXHVBQURGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5UYWlfWHVhbl9KaW5nX1N5bWJvbHMnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgzNFtcXHVERjAwLVxcdURGNUZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5UYWtyaScsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODA1W1xcdURFODAtXFx1REVDRl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJblRhbWlsJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTBCODAtXFx1MEJGRidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luVGVsdWd1JyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTBDMDAtXFx1MEM3RidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luVGhhYW5hJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTA3ODAtXFx1MDdCRidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luVGhhaScsXG4gICAgICAgICAgICBibXA6ICdcXHUwRTAwLVxcdTBFN0YnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJblRpYmV0YW4nLFxuICAgICAgICAgICAgYm1wOiAnXFx1MEYwMC1cXHUwRkZGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5UaWZpbmFnaCcsXG4gICAgICAgICAgICBibXA6ICdcXHUyRDMwLVxcdTJEN0YnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJblRpcmh1dGEnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwNVtcXHVEQzgwLVxcdURDREZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5UcmFuc3BvcnRfYW5kX01hcF9TeW1ib2xzJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4M0RbXFx1REU4MC1cXHVERUZGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luVWdhcml0aWMnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMFtcXHVERjgwLVxcdURGOUZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5VbmlmaWVkX0NhbmFkaWFuX0Fib3JpZ2luYWxfU3lsbGFiaWNzJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTE0MDAtXFx1MTY3RidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luVW5pZmllZF9DYW5hZGlhbl9BYm9yaWdpbmFsX1N5bGxhYmljc19FeHRlbmRlZCcsXG4gICAgICAgICAgICBibXA6ICdcXHUxOEIwLVxcdTE4RkYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJblZhaScsXG4gICAgICAgICAgICBibXA6ICdcXHVBNTAwLVxcdUE2M0YnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJblZhcmlhdGlvbl9TZWxlY3RvcnMnLFxuICAgICAgICAgICAgYm1wOiAnXFx1RkUwMC1cXHVGRTBGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5WYXJpYXRpb25fU2VsZWN0b3JzX1N1cHBsZW1lbnQnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1REI0MFtcXHVERDAwLVxcdURERUZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5WZWRpY19FeHRlbnNpb25zJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTFDRDAtXFx1MUNGRidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luVmVydGljYWxfRm9ybXMnLFxuICAgICAgICAgICAgYm1wOiAnXFx1RkUxMC1cXHVGRTFGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5XYXJhbmdfQ2l0aScsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODA2W1xcdURDQTAtXFx1RENGRl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbllpX1JhZGljYWxzJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdUE0OTAtXFx1QTRDRidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luWWlfU3lsbGFibGVzJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdUEwMDAtXFx1QTQ4RidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luWWlqaW5nX0hleGFncmFtX1N5bWJvbHMnLFxuICAgICAgICAgICAgYm1wOiAnXFx1NERDMC1cXHU0REZGJ1xuICAgICAgICB9XG4gICAgXSk7XG5cbn0oWFJlZ0V4cCkpO1xuXG4vKiFcbiAqIFhSZWdFeHAgVW5pY29kZSBDYXRlZ29yaWVzIDMuMC4wXG4gKiA8aHR0cDovL3hyZWdleHAuY29tLz5cbiAqIFN0ZXZlbiBMZXZpdGhhbiAoYykgMjAxMC0yMDE1IE1JVCBMaWNlbnNlXG4gKiBVbmljb2RlIGRhdGEgcHJvdmlkZWQgYnkgTWF0aGlhcyBCeW5lbnMgPGh0dHA6Ly9tYXRoaWFzYnluZW5zLmJlLz5cbiAqL1xuXG4vKipcbiAqIEFkZHMgc3VwcG9ydCBmb3IgVW5pY29kZSdzIGdlbmVyYWwgY2F0ZWdvcmllcy4gRS5nLiwgYFxccHtMdX1gIG9yIGBcXHB7VXBwZXJjYXNlIExldHRlcn1gLiBTZWVcbiAqIGNhdGVnb3J5IGRlc2NyaXB0aW9ucyBpbiBVQVggIzQ0IDxodHRwOi8vdW5pY29kZS5vcmcvcmVwb3J0cy90cjQ0LyNHQ19WYWx1ZXNfVGFibGU+LiBUb2tlbiBuYW1lc1xuICogYXJlIGNhc2UgaW5zZW5zaXRpdmUsIGFuZCBhbnkgc3BhY2VzLCBoeXBoZW5zLCBhbmQgdW5kZXJzY29yZXMgYXJlIGlnbm9yZWQuXG4gKlxuICogVXNlcyBVbmljb2RlIDguMC4wLlxuICpcbiAqIEByZXF1aXJlcyBYUmVnRXhwLCBVbmljb2RlIEJhc2VcbiAqL1xuKGZ1bmN0aW9uKFhSZWdFeHApIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBpZiAoIVhSZWdFeHAuYWRkVW5pY29kZURhdGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKCdVbmljb2RlIEJhc2UgbXVzdCBiZSBsb2FkZWQgYmVmb3JlIFVuaWNvZGUgQ2F0ZWdvcmllcycpO1xuICAgIH1cblxuICAgIFhSZWdFeHAuYWRkVW5pY29kZURhdGEoW1xuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnQycsXG4gICAgICAgICAgICBhbGlhczogJ090aGVyJyxcbiAgICAgICAgICAgIGlzQm1wTGFzdDogdHJ1ZSxcbiAgICAgICAgICAgIGJtcDogJ1xcMC1cXHgxRlxceDdGLVxceDlGXFx4QURcXHUwMzc4XFx1MDM3OVxcdTAzODAtXFx1MDM4M1xcdTAzOEJcXHUwMzhEXFx1MDNBMlxcdTA1MzBcXHUwNTU3XFx1MDU1OFxcdTA1NjBcXHUwNTg4XFx1MDU4QlxcdTA1OENcXHUwNTkwXFx1MDVDOC1cXHUwNUNGXFx1MDVFQi1cXHUwNUVGXFx1MDVGNS1cXHUwNjA1XFx1MDYxQ1xcdTA2MURcXHUwNkREXFx1MDcwRVxcdTA3MEZcXHUwNzRCXFx1MDc0Q1xcdTA3QjItXFx1MDdCRlxcdTA3RkItXFx1MDdGRlxcdTA4MkVcXHUwODJGXFx1MDgzRlxcdTA4NUNcXHUwODVEXFx1MDg1Ri1cXHUwODlGXFx1MDhCNS1cXHUwOEUyXFx1MDk4NFxcdTA5OERcXHUwOThFXFx1MDk5MVxcdTA5OTJcXHUwOUE5XFx1MDlCMVxcdTA5QjMtXFx1MDlCNVxcdTA5QkFcXHUwOUJCXFx1MDlDNVxcdTA5QzZcXHUwOUM5XFx1MDlDQVxcdTA5Q0YtXFx1MDlENlxcdTA5RDgtXFx1MDlEQlxcdTA5REVcXHUwOUU0XFx1MDlFNVxcdTA5RkMtXFx1MEEwMFxcdTBBMDRcXHUwQTBCLVxcdTBBMEVcXHUwQTExXFx1MEExMlxcdTBBMjlcXHUwQTMxXFx1MEEzNFxcdTBBMzdcXHUwQTNBXFx1MEEzQlxcdTBBM0RcXHUwQTQzLVxcdTBBNDZcXHUwQTQ5XFx1MEE0QVxcdTBBNEUtXFx1MEE1MFxcdTBBNTItXFx1MEE1OFxcdTBBNURcXHUwQTVGLVxcdTBBNjVcXHUwQTc2LVxcdTBBODBcXHUwQTg0XFx1MEE4RVxcdTBBOTJcXHUwQUE5XFx1MEFCMVxcdTBBQjRcXHUwQUJBXFx1MEFCQlxcdTBBQzZcXHUwQUNBXFx1MEFDRVxcdTBBQ0ZcXHUwQUQxLVxcdTBBREZcXHUwQUU0XFx1MEFFNVxcdTBBRjItXFx1MEFGOFxcdTBBRkEtXFx1MEIwMFxcdTBCMDRcXHUwQjBEXFx1MEIwRVxcdTBCMTFcXHUwQjEyXFx1MEIyOVxcdTBCMzFcXHUwQjM0XFx1MEIzQVxcdTBCM0JcXHUwQjQ1XFx1MEI0NlxcdTBCNDlcXHUwQjRBXFx1MEI0RS1cXHUwQjU1XFx1MEI1OC1cXHUwQjVCXFx1MEI1RVxcdTBCNjRcXHUwQjY1XFx1MEI3OC1cXHUwQjgxXFx1MEI4NFxcdTBCOEItXFx1MEI4RFxcdTBCOTFcXHUwQjk2LVxcdTBCOThcXHUwQjlCXFx1MEI5RFxcdTBCQTAtXFx1MEJBMlxcdTBCQTUtXFx1MEJBN1xcdTBCQUItXFx1MEJBRFxcdTBCQkEtXFx1MEJCRFxcdTBCQzMtXFx1MEJDNVxcdTBCQzlcXHUwQkNFXFx1MEJDRlxcdTBCRDEtXFx1MEJENlxcdTBCRDgtXFx1MEJFNVxcdTBCRkItXFx1MEJGRlxcdTBDMDRcXHUwQzBEXFx1MEMxMVxcdTBDMjlcXHUwQzNBLVxcdTBDM0NcXHUwQzQ1XFx1MEM0OVxcdTBDNEUtXFx1MEM1NFxcdTBDNTdcXHUwQzVCLVxcdTBDNUZcXHUwQzY0XFx1MEM2NVxcdTBDNzAtXFx1MEM3N1xcdTBDODBcXHUwQzg0XFx1MEM4RFxcdTBDOTFcXHUwQ0E5XFx1MENCNFxcdTBDQkFcXHUwQ0JCXFx1MENDNVxcdTBDQzlcXHUwQ0NFLVxcdTBDRDRcXHUwQ0Q3LVxcdTBDRERcXHUwQ0RGXFx1MENFNFxcdTBDRTVcXHUwQ0YwXFx1MENGMy1cXHUwRDAwXFx1MEQwNFxcdTBEMERcXHUwRDExXFx1MEQzQlxcdTBEM0NcXHUwRDQ1XFx1MEQ0OVxcdTBENEYtXFx1MEQ1NlxcdTBENTgtXFx1MEQ1RVxcdTBENjRcXHUwRDY1XFx1MEQ3Ni1cXHUwRDc4XFx1MEQ4MFxcdTBEODFcXHUwRDg0XFx1MEQ5Ny1cXHUwRDk5XFx1MERCMlxcdTBEQkNcXHUwREJFXFx1MERCRlxcdTBEQzctXFx1MERDOVxcdTBEQ0ItXFx1MERDRVxcdTBERDVcXHUwREQ3XFx1MERFMC1cXHUwREU1XFx1MERGMFxcdTBERjFcXHUwREY1LVxcdTBFMDBcXHUwRTNCLVxcdTBFM0VcXHUwRTVDLVxcdTBFODBcXHUwRTgzXFx1MEU4NVxcdTBFODZcXHUwRTg5XFx1MEU4QlxcdTBFOENcXHUwRThFLVxcdTBFOTNcXHUwRTk4XFx1MEVBMFxcdTBFQTRcXHUwRUE2XFx1MEVBOFxcdTBFQTlcXHUwRUFDXFx1MEVCQVxcdTBFQkVcXHUwRUJGXFx1MEVDNVxcdTBFQzdcXHUwRUNFXFx1MEVDRlxcdTBFREFcXHUwRURCXFx1MEVFMC1cXHUwRUZGXFx1MEY0OFxcdTBGNkQtXFx1MEY3MFxcdTBGOThcXHUwRkJEXFx1MEZDRFxcdTBGREItXFx1MEZGRlxcdTEwQzZcXHUxMEM4LVxcdTEwQ0NcXHUxMENFXFx1MTBDRlxcdTEyNDlcXHUxMjRFXFx1MTI0RlxcdTEyNTdcXHUxMjU5XFx1MTI1RVxcdTEyNUZcXHUxMjg5XFx1MTI4RVxcdTEyOEZcXHUxMkIxXFx1MTJCNlxcdTEyQjdcXHUxMkJGXFx1MTJDMVxcdTEyQzZcXHUxMkM3XFx1MTJEN1xcdTEzMTFcXHUxMzE2XFx1MTMxN1xcdTEzNUJcXHUxMzVDXFx1MTM3RC1cXHUxMzdGXFx1MTM5QS1cXHUxMzlGXFx1MTNGNlxcdTEzRjdcXHUxM0ZFXFx1MTNGRlxcdTE2OUQtXFx1MTY5RlxcdTE2RjktXFx1MTZGRlxcdTE3MERcXHUxNzE1LVxcdTE3MUZcXHUxNzM3LVxcdTE3M0ZcXHUxNzU0LVxcdTE3NUZcXHUxNzZEXFx1MTc3MVxcdTE3NzQtXFx1MTc3RlxcdTE3REVcXHUxN0RGXFx1MTdFQS1cXHUxN0VGXFx1MTdGQS1cXHUxN0ZGXFx1MTgwRVxcdTE4MEZcXHUxODFBLVxcdTE4MUZcXHUxODc4LVxcdTE4N0ZcXHUxOEFCLVxcdTE4QUZcXHUxOEY2LVxcdTE4RkZcXHUxOTFGXFx1MTkyQy1cXHUxOTJGXFx1MTkzQy1cXHUxOTNGXFx1MTk0MS1cXHUxOTQzXFx1MTk2RVxcdTE5NkZcXHUxOTc1LVxcdTE5N0ZcXHUxOUFDLVxcdTE5QUZcXHUxOUNBLVxcdTE5Q0ZcXHUxOURCLVxcdTE5RERcXHUxQTFDXFx1MUExRFxcdTFBNUZcXHUxQTdEXFx1MUE3RVxcdTFBOEEtXFx1MUE4RlxcdTFBOUEtXFx1MUE5RlxcdTFBQUVcXHUxQUFGXFx1MUFCRi1cXHUxQUZGXFx1MUI0Qy1cXHUxQjRGXFx1MUI3RC1cXHUxQjdGXFx1MUJGNC1cXHUxQkZCXFx1MUMzOC1cXHUxQzNBXFx1MUM0QS1cXHUxQzRDXFx1MUM4MC1cXHUxQ0JGXFx1MUNDOC1cXHUxQ0NGXFx1MUNGN1xcdTFDRkEtXFx1MUNGRlxcdTFERjYtXFx1MURGQlxcdTFGMTZcXHUxRjE3XFx1MUYxRVxcdTFGMUZcXHUxRjQ2XFx1MUY0N1xcdTFGNEVcXHUxRjRGXFx1MUY1OFxcdTFGNUFcXHUxRjVDXFx1MUY1RVxcdTFGN0VcXHUxRjdGXFx1MUZCNVxcdTFGQzVcXHUxRkQ0XFx1MUZENVxcdTFGRENcXHUxRkYwXFx1MUZGMVxcdTFGRjVcXHUxRkZGXFx1MjAwQi1cXHUyMDBGXFx1MjAyQS1cXHUyMDJFXFx1MjA2MC1cXHUyMDZGXFx1MjA3MlxcdTIwNzNcXHUyMDhGXFx1MjA5RC1cXHUyMDlGXFx1MjBCRi1cXHUyMENGXFx1MjBGMS1cXHUyMEZGXFx1MjE4Qy1cXHUyMThGXFx1MjNGQi1cXHUyM0ZGXFx1MjQyNy1cXHUyNDNGXFx1MjQ0Qi1cXHUyNDVGXFx1MkI3NFxcdTJCNzVcXHUyQjk2XFx1MkI5N1xcdTJCQkEtXFx1MkJCQ1xcdTJCQzlcXHUyQkQyLVxcdTJCRUJcXHUyQkYwLVxcdTJCRkZcXHUyQzJGXFx1MkM1RlxcdTJDRjQtXFx1MkNGOFxcdTJEMjZcXHUyRDI4LVxcdTJEMkNcXHUyRDJFXFx1MkQyRlxcdTJENjgtXFx1MkQ2RVxcdTJENzEtXFx1MkQ3RVxcdTJEOTctXFx1MkQ5RlxcdTJEQTdcXHUyREFGXFx1MkRCN1xcdTJEQkZcXHUyREM3XFx1MkRDRlxcdTJERDdcXHUyRERGXFx1MkU0My1cXHUyRTdGXFx1MkU5QVxcdTJFRjQtXFx1MkVGRlxcdTJGRDYtXFx1MkZFRlxcdTJGRkMtXFx1MkZGRlxcdTMwNDBcXHUzMDk3XFx1MzA5OFxcdTMxMDAtXFx1MzEwNFxcdTMxMkUtXFx1MzEzMFxcdTMxOEZcXHUzMUJCLVxcdTMxQkZcXHUzMUU0LVxcdTMxRUZcXHUzMjFGXFx1MzJGRlxcdTREQjYtXFx1NERCRlxcdTlGRDYtXFx1OUZGRlxcdUE0OEQtXFx1QTQ4RlxcdUE0QzctXFx1QTRDRlxcdUE2MkMtXFx1QTYzRlxcdUE2RjgtXFx1QTZGRlxcdUE3QUVcXHVBN0FGXFx1QTdCOC1cXHVBN0Y2XFx1QTgyQy1cXHVBODJGXFx1QTgzQS1cXHVBODNGXFx1QTg3OC1cXHVBODdGXFx1QThDNS1cXHVBOENEXFx1QThEQS1cXHVBOERGXFx1QThGRVxcdUE4RkZcXHVBOTU0LVxcdUE5NUVcXHVBOTdELVxcdUE5N0ZcXHVBOUNFXFx1QTlEQS1cXHVBOUREXFx1QTlGRlxcdUFBMzctXFx1QUEzRlxcdUFBNEVcXHVBQTRGXFx1QUE1QVxcdUFBNUJcXHVBQUMzLVxcdUFBREFcXHVBQUY3LVxcdUFCMDBcXHVBQjA3XFx1QUIwOFxcdUFCMEZcXHVBQjEwXFx1QUIxNy1cXHVBQjFGXFx1QUIyN1xcdUFCMkZcXHVBQjY2LVxcdUFCNkZcXHVBQkVFXFx1QUJFRlxcdUFCRkEtXFx1QUJGRlxcdUQ3QTQtXFx1RDdBRlxcdUQ3QzctXFx1RDdDQVxcdUQ3RkMtXFx1RjhGRlxcdUZBNkVcXHVGQTZGXFx1RkFEQS1cXHVGQUZGXFx1RkIwNy1cXHVGQjEyXFx1RkIxOC1cXHVGQjFDXFx1RkIzN1xcdUZCM0RcXHVGQjNGXFx1RkI0MlxcdUZCNDVcXHVGQkMyLVxcdUZCRDJcXHVGRDQwLVxcdUZENEZcXHVGRDkwXFx1RkQ5MVxcdUZEQzgtXFx1RkRFRlxcdUZERkVcXHVGREZGXFx1RkUxQS1cXHVGRTFGXFx1RkU1M1xcdUZFNjdcXHVGRTZDLVxcdUZFNkZcXHVGRTc1XFx1RkVGRC1cXHVGRjAwXFx1RkZCRi1cXHVGRkMxXFx1RkZDOFxcdUZGQzlcXHVGRkQwXFx1RkZEMVxcdUZGRDhcXHVGRkQ5XFx1RkZERC1cXHVGRkRGXFx1RkZFN1xcdUZGRUYtXFx1RkZGQlxcdUZGRkVcXHVGRkZGJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MzRbXFx1RENGNi1cXHVEQ0ZGXFx1REQyN1xcdUREMjhcXHVERDczLVxcdUREN0FcXHVEREU5LVxcdURERkZcXHVERTQ2LVxcdURFRkZcXHVERjU3LVxcdURGNUZcXHVERjcyLVxcdURGRkZdfFxcdUQ4MzZbXFx1REU4Qy1cXHVERTlBXFx1REVBMFxcdURFQjAtXFx1REZGRl18XFx1RDgzQ1tcXHVEQzJDLVxcdURDMkZcXHVEQzk0LVxcdURDOUZcXHVEQ0FGXFx1RENCMFxcdURDQzBcXHVEQ0QwXFx1RENGNi1cXHVEQ0ZGXFx1REQwRC1cXHVERDBGXFx1REQyRlxcdURENkMtXFx1REQ2RlxcdUREOUItXFx1RERFNVxcdURFMDMtXFx1REUwRlxcdURFM0ItXFx1REUzRlxcdURFNDktXFx1REU0RlxcdURFNTItXFx1REVGRl18XFx1RDgxQVtcXHVERTM5LVxcdURFM0ZcXHVERTVGXFx1REU2QS1cXHVERTZEXFx1REU3MC1cXHVERUNGXFx1REVFRVxcdURFRUZcXHVERUY2LVxcdURFRkZcXHVERjQ2LVxcdURGNEZcXHVERjVBXFx1REY2MlxcdURGNzgtXFx1REY3Q1xcdURGOTAtXFx1REZGRl18XFx1RDgwOVtcXHVEQzZGXFx1REM3NS1cXHVEQzdGXFx1REQ0NC1cXHVERkZGXXxcXHVEODFCW1xcdURDMDAtXFx1REVGRlxcdURGNDUtXFx1REY0RlxcdURGN0YtXFx1REY4RVxcdURGQTAtXFx1REZGRl18XFx1RDg2RVtcXHVEQzFFXFx1REMxRl18XFx1RDgzRFtcXHVERDdBXFx1RERBNFxcdURFRDEtXFx1REVERlxcdURFRUQtXFx1REVFRlxcdURFRjQtXFx1REVGRlxcdURGNzQtXFx1REY3RlxcdURGRDUtXFx1REZGRl18XFx1RDgwMVtcXHVEQzlFXFx1REM5RlxcdURDQUEtXFx1RENGRlxcdUREMjgtXFx1REQyRlxcdURENjQtXFx1REQ2RVxcdURENzAtXFx1RERGRlxcdURGMzctXFx1REYzRlxcdURGNTYtXFx1REY1RlxcdURGNjgtXFx1REZGRl18XFx1RDgwMFtcXHVEQzBDXFx1REMyN1xcdURDM0JcXHVEQzNFXFx1REM0RVxcdURDNEZcXHVEQzVFLVxcdURDN0ZcXHVEQ0ZCLVxcdURDRkZcXHVERDAzLVxcdUREMDZcXHVERDM0LVxcdUREMzZcXHVERDhELVxcdUREOEZcXHVERDlDLVxcdUREOUZcXHVEREExLVxcdUREQ0ZcXHVEREZFLVxcdURFN0ZcXHVERTlELVxcdURFOUZcXHVERUQxLVxcdURFREZcXHVERUZDLVxcdURFRkZcXHVERjI0LVxcdURGMkZcXHVERjRCLVxcdURGNEZcXHVERjdCLVxcdURGN0ZcXHVERjlFXFx1REZDNC1cXHVERkM3XFx1REZENi1cXHVERkZGXXxcXHVEODY5W1xcdURFRDctXFx1REVGRl18XFx1RDgzQltcXHVEQzAwLVxcdURERkZcXHVERTA0XFx1REUyMFxcdURFMjNcXHVERTI1XFx1REUyNlxcdURFMjhcXHVERTMzXFx1REUzOFxcdURFM0FcXHVERTNDLVxcdURFNDFcXHVERTQzLVxcdURFNDZcXHVERTQ4XFx1REU0QVxcdURFNENcXHVERTUwXFx1REU1M1xcdURFNTVcXHVERTU2XFx1REU1OFxcdURFNUFcXHVERTVDXFx1REU1RVxcdURFNjBcXHVERTYzXFx1REU2NVxcdURFNjZcXHVERTZCXFx1REU3M1xcdURFNzhcXHVERTdEXFx1REU3RlxcdURFOEFcXHVERTlDLVxcdURFQTBcXHVERUE0XFx1REVBQVxcdURFQkMtXFx1REVFRlxcdURFRjItXFx1REZGRl18XFx1RDg3RVtcXHVERTFFLVxcdURGRkZdfFxcdURCNDBbXFx1REMwMC1cXHVEQ0ZGXFx1RERGMC1cXHVERkZGXXxcXHVEODA0W1xcdURDNEUtXFx1REM1MVxcdURDNzAtXFx1REM3RVxcdURDQkRcXHVEQ0MyLVxcdURDQ0ZcXHVEQ0U5LVxcdURDRUZcXHVEQ0ZBLVxcdURDRkZcXHVERDM1XFx1REQ0NC1cXHVERDRGXFx1REQ3Ny1cXHVERDdGXFx1RERDRVxcdUREQ0ZcXHVEREUwXFx1RERGNS1cXHVEREZGXFx1REUxMlxcdURFM0UtXFx1REU3RlxcdURFODdcXHVERTg5XFx1REU4RVxcdURFOUVcXHVERUFBLVxcdURFQUZcXHVERUVCLVxcdURFRUZcXHVERUZBLVxcdURFRkZcXHVERjA0XFx1REYwRFxcdURGMEVcXHVERjExXFx1REYxMlxcdURGMjlcXHVERjMxXFx1REYzNFxcdURGM0FcXHVERjNCXFx1REY0NVxcdURGNDZcXHVERjQ5XFx1REY0QVxcdURGNEVcXHVERjRGXFx1REY1MS1cXHVERjU2XFx1REY1OC1cXHVERjVDXFx1REY2NFxcdURGNjVcXHVERjZELVxcdURGNkZcXHVERjc1LVxcdURGRkZdfFxcdUQ4M0FbXFx1RENDNVxcdURDQzZcXHVEQ0Q3LVxcdURGRkZdfFxcdUQ4MERbXFx1REMyRi1cXHVERkZGXXxcXHVEODZEW1xcdURGMzUtXFx1REYzRl18W1xcdUQ4MDdcXHVEODBBXFx1RDgwQlxcdUQ4MEUtXFx1RDgxMFxcdUQ4MTItXFx1RDgxOVxcdUQ4MUMtXFx1RDgyQlxcdUQ4MkRcXHVEODJFXFx1RDgzMC1cXHVEODMzXFx1RDgzNy1cXHVEODM5XFx1RDgzRlxcdUQ4NzQtXFx1RDg3RFxcdUQ4N0YtXFx1REIzRlxcdURCNDEtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXXxcXHVEODA2W1xcdURDMDAtXFx1REM5RlxcdURDRjMtXFx1RENGRVxcdUREMDAtXFx1REVCRlxcdURFRjktXFx1REZGRl18XFx1RDgwM1tcXHVEQzQ5LVxcdURDN0ZcXHVEQ0IzLVxcdURDQkZcXHVEQ0YzLVxcdURDRjlcXHVERDAwLVxcdURFNUZcXHVERTdGLVxcdURGRkZdfFxcdUQ4MzVbXFx1REM1NVxcdURDOURcXHVEQ0EwXFx1RENBMVxcdURDQTNcXHVEQ0E0XFx1RENBN1xcdURDQThcXHVEQ0FEXFx1RENCQVxcdURDQkNcXHVEQ0M0XFx1REQwNlxcdUREMEJcXHVERDBDXFx1REQxNVxcdUREMURcXHVERDNBXFx1REQzRlxcdURENDVcXHVERDQ3LVxcdURENDlcXHVERDUxXFx1REVBNlxcdURFQTdcXHVERkNDXFx1REZDRF18XFx1RDgwNVtcXHVEQzAwLVxcdURDN0ZcXHVEQ0M4LVxcdURDQ0ZcXHVEQ0RBLVxcdUREN0ZcXHVEREI2XFx1RERCN1xcdUREREUtXFx1RERGRlxcdURFNDUtXFx1REU0RlxcdURFNUEtXFx1REU3RlxcdURFQjgtXFx1REVCRlxcdURFQ0EtXFx1REVGRlxcdURGMUEtXFx1REYxQ1xcdURGMkMtXFx1REYyRlxcdURGNDAtXFx1REZGRl18XFx1RDgwMltcXHVEQzA2XFx1REMwN1xcdURDMDlcXHVEQzM2XFx1REMzOS1cXHVEQzNCXFx1REMzRFxcdURDM0VcXHVEQzU2XFx1REM5Ri1cXHVEQ0E2XFx1RENCMC1cXHVEQ0RGXFx1RENGM1xcdURDRjYtXFx1RENGQVxcdUREMUMtXFx1REQxRVxcdUREM0EtXFx1REQzRVxcdURENDAtXFx1REQ3RlxcdUREQjgtXFx1RERCQlxcdURERDBcXHVEREQxXFx1REUwNFxcdURFMDctXFx1REUwQlxcdURFMTRcXHVERTE4XFx1REUzNC1cXHVERTM3XFx1REUzQi1cXHVERTNFXFx1REU0OC1cXHVERTRGXFx1REU1OS1cXHVERTVGXFx1REVBMC1cXHVERUJGXFx1REVFNy1cXHVERUVBXFx1REVGNy1cXHVERUZGXFx1REYzNi1cXHVERjM4XFx1REY1NlxcdURGNTdcXHVERjczLVxcdURGNzdcXHVERjkyLVxcdURGOThcXHVERjlELVxcdURGQThcXHVERkIwLVxcdURGRkZdfFxcdUQ4MDhbXFx1REY5QS1cXHVERkZGXXxcXHVEODJGW1xcdURDNkItXFx1REM2RlxcdURDN0QtXFx1REM3RlxcdURDODktXFx1REM4RlxcdURDOUFcXHVEQzlCXFx1RENBMC1cXHVERkZGXXxcXHVEODJDW1xcdURDMDItXFx1REZGRl18XFx1RDgxMVtcXHVERTQ3LVxcdURGRkZdfFxcdUQ4M0VbXFx1REMwQy1cXHVEQzBGXFx1REM0OC1cXHVEQzRGXFx1REM1QS1cXHVEQzVGXFx1REM4OC1cXHVEQzhGXFx1RENBRS1cXHVERDBGXFx1REQxOS1cXHVERDdGXFx1REQ4NS1cXHVEREJGXFx1RERDMS1cXHVERkZGXXxcXHVEODczW1xcdURFQTItXFx1REZGRl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdDYycsXG4gICAgICAgICAgICBhbGlhczogJ0NvbnRyb2wnLFxuICAgICAgICAgICAgYm1wOiAnXFwwLVxceDFGXFx4N0YtXFx4OUYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdDZicsXG4gICAgICAgICAgICBhbGlhczogJ0Zvcm1hdCcsXG4gICAgICAgICAgICBibXA6ICdcXHhBRFxcdTA2MDAtXFx1MDYwNVxcdTA2MUNcXHUwNkREXFx1MDcwRlxcdTE4MEVcXHUyMDBCLVxcdTIwMEZcXHUyMDJBLVxcdTIwMkVcXHUyMDYwLVxcdTIwNjRcXHUyMDY2LVxcdTIwNkZcXHVGRUZGXFx1RkZGOS1cXHVGRkZCJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdURCNDBbXFx1REMwMVxcdURDMjAtXFx1REM3Rl18XFx1RDgyRltcXHVEQ0EwLVxcdURDQTNdfFxcdUQ4MzRbXFx1REQ3My1cXHVERDdBXXxcXHVEODA0XFx1RENCRCdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0NuJyxcbiAgICAgICAgICAgIGFsaWFzOiAnVW5hc3NpZ25lZCcsXG4gICAgICAgICAgICBibXA6ICdcXHUwMzc4XFx1MDM3OVxcdTAzODAtXFx1MDM4M1xcdTAzOEJcXHUwMzhEXFx1MDNBMlxcdTA1MzBcXHUwNTU3XFx1MDU1OFxcdTA1NjBcXHUwNTg4XFx1MDU4QlxcdTA1OENcXHUwNTkwXFx1MDVDOC1cXHUwNUNGXFx1MDVFQi1cXHUwNUVGXFx1MDVGNS1cXHUwNUZGXFx1MDYxRFxcdTA3MEVcXHUwNzRCXFx1MDc0Q1xcdTA3QjItXFx1MDdCRlxcdTA3RkItXFx1MDdGRlxcdTA4MkVcXHUwODJGXFx1MDgzRlxcdTA4NUNcXHUwODVEXFx1MDg1Ri1cXHUwODlGXFx1MDhCNS1cXHUwOEUyXFx1MDk4NFxcdTA5OERcXHUwOThFXFx1MDk5MVxcdTA5OTJcXHUwOUE5XFx1MDlCMVxcdTA5QjMtXFx1MDlCNVxcdTA5QkFcXHUwOUJCXFx1MDlDNVxcdTA5QzZcXHUwOUM5XFx1MDlDQVxcdTA5Q0YtXFx1MDlENlxcdTA5RDgtXFx1MDlEQlxcdTA5REVcXHUwOUU0XFx1MDlFNVxcdTA5RkMtXFx1MEEwMFxcdTBBMDRcXHUwQTBCLVxcdTBBMEVcXHUwQTExXFx1MEExMlxcdTBBMjlcXHUwQTMxXFx1MEEzNFxcdTBBMzdcXHUwQTNBXFx1MEEzQlxcdTBBM0RcXHUwQTQzLVxcdTBBNDZcXHUwQTQ5XFx1MEE0QVxcdTBBNEUtXFx1MEE1MFxcdTBBNTItXFx1MEE1OFxcdTBBNURcXHUwQTVGLVxcdTBBNjVcXHUwQTc2LVxcdTBBODBcXHUwQTg0XFx1MEE4RVxcdTBBOTJcXHUwQUE5XFx1MEFCMVxcdTBBQjRcXHUwQUJBXFx1MEFCQlxcdTBBQzZcXHUwQUNBXFx1MEFDRVxcdTBBQ0ZcXHUwQUQxLVxcdTBBREZcXHUwQUU0XFx1MEFFNVxcdTBBRjItXFx1MEFGOFxcdTBBRkEtXFx1MEIwMFxcdTBCMDRcXHUwQjBEXFx1MEIwRVxcdTBCMTFcXHUwQjEyXFx1MEIyOVxcdTBCMzFcXHUwQjM0XFx1MEIzQVxcdTBCM0JcXHUwQjQ1XFx1MEI0NlxcdTBCNDlcXHUwQjRBXFx1MEI0RS1cXHUwQjU1XFx1MEI1OC1cXHUwQjVCXFx1MEI1RVxcdTBCNjRcXHUwQjY1XFx1MEI3OC1cXHUwQjgxXFx1MEI4NFxcdTBCOEItXFx1MEI4RFxcdTBCOTFcXHUwQjk2LVxcdTBCOThcXHUwQjlCXFx1MEI5RFxcdTBCQTAtXFx1MEJBMlxcdTBCQTUtXFx1MEJBN1xcdTBCQUItXFx1MEJBRFxcdTBCQkEtXFx1MEJCRFxcdTBCQzMtXFx1MEJDNVxcdTBCQzlcXHUwQkNFXFx1MEJDRlxcdTBCRDEtXFx1MEJENlxcdTBCRDgtXFx1MEJFNVxcdTBCRkItXFx1MEJGRlxcdTBDMDRcXHUwQzBEXFx1MEMxMVxcdTBDMjlcXHUwQzNBLVxcdTBDM0NcXHUwQzQ1XFx1MEM0OVxcdTBDNEUtXFx1MEM1NFxcdTBDNTdcXHUwQzVCLVxcdTBDNUZcXHUwQzY0XFx1MEM2NVxcdTBDNzAtXFx1MEM3N1xcdTBDODBcXHUwQzg0XFx1MEM4RFxcdTBDOTFcXHUwQ0E5XFx1MENCNFxcdTBDQkFcXHUwQ0JCXFx1MENDNVxcdTBDQzlcXHUwQ0NFLVxcdTBDRDRcXHUwQ0Q3LVxcdTBDRERcXHUwQ0RGXFx1MENFNFxcdTBDRTVcXHUwQ0YwXFx1MENGMy1cXHUwRDAwXFx1MEQwNFxcdTBEMERcXHUwRDExXFx1MEQzQlxcdTBEM0NcXHUwRDQ1XFx1MEQ0OVxcdTBENEYtXFx1MEQ1NlxcdTBENTgtXFx1MEQ1RVxcdTBENjRcXHUwRDY1XFx1MEQ3Ni1cXHUwRDc4XFx1MEQ4MFxcdTBEODFcXHUwRDg0XFx1MEQ5Ny1cXHUwRDk5XFx1MERCMlxcdTBEQkNcXHUwREJFXFx1MERCRlxcdTBEQzctXFx1MERDOVxcdTBEQ0ItXFx1MERDRVxcdTBERDVcXHUwREQ3XFx1MERFMC1cXHUwREU1XFx1MERGMFxcdTBERjFcXHUwREY1LVxcdTBFMDBcXHUwRTNCLVxcdTBFM0VcXHUwRTVDLVxcdTBFODBcXHUwRTgzXFx1MEU4NVxcdTBFODZcXHUwRTg5XFx1MEU4QlxcdTBFOENcXHUwRThFLVxcdTBFOTNcXHUwRTk4XFx1MEVBMFxcdTBFQTRcXHUwRUE2XFx1MEVBOFxcdTBFQTlcXHUwRUFDXFx1MEVCQVxcdTBFQkVcXHUwRUJGXFx1MEVDNVxcdTBFQzdcXHUwRUNFXFx1MEVDRlxcdTBFREFcXHUwRURCXFx1MEVFMC1cXHUwRUZGXFx1MEY0OFxcdTBGNkQtXFx1MEY3MFxcdTBGOThcXHUwRkJEXFx1MEZDRFxcdTBGREItXFx1MEZGRlxcdTEwQzZcXHUxMEM4LVxcdTEwQ0NcXHUxMENFXFx1MTBDRlxcdTEyNDlcXHUxMjRFXFx1MTI0RlxcdTEyNTdcXHUxMjU5XFx1MTI1RVxcdTEyNUZcXHUxMjg5XFx1MTI4RVxcdTEyOEZcXHUxMkIxXFx1MTJCNlxcdTEyQjdcXHUxMkJGXFx1MTJDMVxcdTEyQzZcXHUxMkM3XFx1MTJEN1xcdTEzMTFcXHUxMzE2XFx1MTMxN1xcdTEzNUJcXHUxMzVDXFx1MTM3RC1cXHUxMzdGXFx1MTM5QS1cXHUxMzlGXFx1MTNGNlxcdTEzRjdcXHUxM0ZFXFx1MTNGRlxcdTE2OUQtXFx1MTY5RlxcdTE2RjktXFx1MTZGRlxcdTE3MERcXHUxNzE1LVxcdTE3MUZcXHUxNzM3LVxcdTE3M0ZcXHUxNzU0LVxcdTE3NUZcXHUxNzZEXFx1MTc3MVxcdTE3NzQtXFx1MTc3RlxcdTE3REVcXHUxN0RGXFx1MTdFQS1cXHUxN0VGXFx1MTdGQS1cXHUxN0ZGXFx1MTgwRlxcdTE4MUEtXFx1MTgxRlxcdTE4NzgtXFx1MTg3RlxcdTE4QUItXFx1MThBRlxcdTE4RjYtXFx1MThGRlxcdTE5MUZcXHUxOTJDLVxcdTE5MkZcXHUxOTNDLVxcdTE5M0ZcXHUxOTQxLVxcdTE5NDNcXHUxOTZFXFx1MTk2RlxcdTE5NzUtXFx1MTk3RlxcdTE5QUMtXFx1MTlBRlxcdTE5Q0EtXFx1MTlDRlxcdTE5REItXFx1MTlERFxcdTFBMUNcXHUxQTFEXFx1MUE1RlxcdTFBN0RcXHUxQTdFXFx1MUE4QS1cXHUxQThGXFx1MUE5QS1cXHUxQTlGXFx1MUFBRVxcdTFBQUZcXHUxQUJGLVxcdTFBRkZcXHUxQjRDLVxcdTFCNEZcXHUxQjdELVxcdTFCN0ZcXHUxQkY0LVxcdTFCRkJcXHUxQzM4LVxcdTFDM0FcXHUxQzRBLVxcdTFDNENcXHUxQzgwLVxcdTFDQkZcXHUxQ0M4LVxcdTFDQ0ZcXHUxQ0Y3XFx1MUNGQS1cXHUxQ0ZGXFx1MURGNi1cXHUxREZCXFx1MUYxNlxcdTFGMTdcXHUxRjFFXFx1MUYxRlxcdTFGNDZcXHUxRjQ3XFx1MUY0RVxcdTFGNEZcXHUxRjU4XFx1MUY1QVxcdTFGNUNcXHUxRjVFXFx1MUY3RVxcdTFGN0ZcXHUxRkI1XFx1MUZDNVxcdTFGRDRcXHUxRkQ1XFx1MUZEQ1xcdTFGRjBcXHUxRkYxXFx1MUZGNVxcdTFGRkZcXHUyMDY1XFx1MjA3MlxcdTIwNzNcXHUyMDhGXFx1MjA5RC1cXHUyMDlGXFx1MjBCRi1cXHUyMENGXFx1MjBGMS1cXHUyMEZGXFx1MjE4Qy1cXHUyMThGXFx1MjNGQi1cXHUyM0ZGXFx1MjQyNy1cXHUyNDNGXFx1MjQ0Qi1cXHUyNDVGXFx1MkI3NFxcdTJCNzVcXHUyQjk2XFx1MkI5N1xcdTJCQkEtXFx1MkJCQ1xcdTJCQzlcXHUyQkQyLVxcdTJCRUJcXHUyQkYwLVxcdTJCRkZcXHUyQzJGXFx1MkM1RlxcdTJDRjQtXFx1MkNGOFxcdTJEMjZcXHUyRDI4LVxcdTJEMkNcXHUyRDJFXFx1MkQyRlxcdTJENjgtXFx1MkQ2RVxcdTJENzEtXFx1MkQ3RVxcdTJEOTctXFx1MkQ5RlxcdTJEQTdcXHUyREFGXFx1MkRCN1xcdTJEQkZcXHUyREM3XFx1MkRDRlxcdTJERDdcXHUyRERGXFx1MkU0My1cXHUyRTdGXFx1MkU5QVxcdTJFRjQtXFx1MkVGRlxcdTJGRDYtXFx1MkZFRlxcdTJGRkMtXFx1MkZGRlxcdTMwNDBcXHUzMDk3XFx1MzA5OFxcdTMxMDAtXFx1MzEwNFxcdTMxMkUtXFx1MzEzMFxcdTMxOEZcXHUzMUJCLVxcdTMxQkZcXHUzMUU0LVxcdTMxRUZcXHUzMjFGXFx1MzJGRlxcdTREQjYtXFx1NERCRlxcdTlGRDYtXFx1OUZGRlxcdUE0OEQtXFx1QTQ4RlxcdUE0QzctXFx1QTRDRlxcdUE2MkMtXFx1QTYzRlxcdUE2RjgtXFx1QTZGRlxcdUE3QUVcXHVBN0FGXFx1QTdCOC1cXHVBN0Y2XFx1QTgyQy1cXHVBODJGXFx1QTgzQS1cXHVBODNGXFx1QTg3OC1cXHVBODdGXFx1QThDNS1cXHVBOENEXFx1QThEQS1cXHVBOERGXFx1QThGRVxcdUE4RkZcXHVBOTU0LVxcdUE5NUVcXHVBOTdELVxcdUE5N0ZcXHVBOUNFXFx1QTlEQS1cXHVBOUREXFx1QTlGRlxcdUFBMzctXFx1QUEzRlxcdUFBNEVcXHVBQTRGXFx1QUE1QVxcdUFBNUJcXHVBQUMzLVxcdUFBREFcXHVBQUY3LVxcdUFCMDBcXHVBQjA3XFx1QUIwOFxcdUFCMEZcXHVBQjEwXFx1QUIxNy1cXHVBQjFGXFx1QUIyN1xcdUFCMkZcXHVBQjY2LVxcdUFCNkZcXHVBQkVFXFx1QUJFRlxcdUFCRkEtXFx1QUJGRlxcdUQ3QTQtXFx1RDdBRlxcdUQ3QzctXFx1RDdDQVxcdUQ3RkMtXFx1RDdGRlxcdUZBNkVcXHVGQTZGXFx1RkFEQS1cXHVGQUZGXFx1RkIwNy1cXHVGQjEyXFx1RkIxOC1cXHVGQjFDXFx1RkIzN1xcdUZCM0RcXHVGQjNGXFx1RkI0MlxcdUZCNDVcXHVGQkMyLVxcdUZCRDJcXHVGRDQwLVxcdUZENEZcXHVGRDkwXFx1RkQ5MVxcdUZEQzgtXFx1RkRFRlxcdUZERkVcXHVGREZGXFx1RkUxQS1cXHVGRTFGXFx1RkU1M1xcdUZFNjdcXHVGRTZDLVxcdUZFNkZcXHVGRTc1XFx1RkVGRFxcdUZFRkVcXHVGRjAwXFx1RkZCRi1cXHVGRkMxXFx1RkZDOFxcdUZGQzlcXHVGRkQwXFx1RkZEMVxcdUZGRDhcXHVGRkQ5XFx1RkZERC1cXHVGRkRGXFx1RkZFN1xcdUZGRUYtXFx1RkZGOFxcdUZGRkVcXHVGRkZGJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdURCNDBbXFx1REMwMFxcdURDMDItXFx1REMxRlxcdURDODAtXFx1RENGRlxcdURERjAtXFx1REZGRl18XFx1RDgzNFtcXHVEQ0Y2LVxcdURDRkZcXHVERDI3XFx1REQyOFxcdURERTktXFx1RERGRlxcdURFNDYtXFx1REVGRlxcdURGNTctXFx1REY1RlxcdURGNzItXFx1REZGRl18XFx1RDgzQ1tcXHVEQzJDLVxcdURDMkZcXHVEQzk0LVxcdURDOUZcXHVEQ0FGXFx1RENCMFxcdURDQzBcXHVEQ0QwXFx1RENGNi1cXHVEQ0ZGXFx1REQwRC1cXHVERDBGXFx1REQyRlxcdURENkMtXFx1REQ2RlxcdUREOUItXFx1RERFNVxcdURFMDMtXFx1REUwRlxcdURFM0ItXFx1REUzRlxcdURFNDktXFx1REU0RlxcdURFNTItXFx1REVGRl18XFx1RDgxQVtcXHVERTM5LVxcdURFM0ZcXHVERTVGXFx1REU2QS1cXHVERTZEXFx1REU3MC1cXHVERUNGXFx1REVFRVxcdURFRUZcXHVERUY2LVxcdURFRkZcXHVERjQ2LVxcdURGNEZcXHVERjVBXFx1REY2MlxcdURGNzgtXFx1REY3Q1xcdURGOTAtXFx1REZGRl18XFx1RDgwOVtcXHVEQzZGXFx1REM3NS1cXHVEQzdGXFx1REQ0NC1cXHVERkZGXXxcXHVEODFCW1xcdURDMDAtXFx1REVGRlxcdURGNDUtXFx1REY0RlxcdURGN0YtXFx1REY4RVxcdURGQTAtXFx1REZGRl18XFx1RDg2RVtcXHVEQzFFXFx1REMxRl18XFx1RDgzRFtcXHVERDdBXFx1RERBNFxcdURFRDEtXFx1REVERlxcdURFRUQtXFx1REVFRlxcdURFRjQtXFx1REVGRlxcdURGNzQtXFx1REY3RlxcdURGRDUtXFx1REZGRl18XFx1RDgwMVtcXHVEQzlFXFx1REM5RlxcdURDQUEtXFx1RENGRlxcdUREMjgtXFx1REQyRlxcdURENjQtXFx1REQ2RVxcdURENzAtXFx1RERGRlxcdURGMzctXFx1REYzRlxcdURGNTYtXFx1REY1RlxcdURGNjgtXFx1REZGRl18XFx1RDgwMFtcXHVEQzBDXFx1REMyN1xcdURDM0JcXHVEQzNFXFx1REM0RVxcdURDNEZcXHVEQzVFLVxcdURDN0ZcXHVEQ0ZCLVxcdURDRkZcXHVERDAzLVxcdUREMDZcXHVERDM0LVxcdUREMzZcXHVERDhELVxcdUREOEZcXHVERDlDLVxcdUREOUZcXHVEREExLVxcdUREQ0ZcXHVEREZFLVxcdURFN0ZcXHVERTlELVxcdURFOUZcXHVERUQxLVxcdURFREZcXHVERUZDLVxcdURFRkZcXHVERjI0LVxcdURGMkZcXHVERjRCLVxcdURGNEZcXHVERjdCLVxcdURGN0ZcXHVERjlFXFx1REZDNC1cXHVERkM3XFx1REZENi1cXHVERkZGXXxcXHVEODY5W1xcdURFRDctXFx1REVGRl18XFx1RDgzQltcXHVEQzAwLVxcdURERkZcXHVERTA0XFx1REUyMFxcdURFMjNcXHVERTI1XFx1REUyNlxcdURFMjhcXHVERTMzXFx1REUzOFxcdURFM0FcXHVERTNDLVxcdURFNDFcXHVERTQzLVxcdURFNDZcXHVERTQ4XFx1REU0QVxcdURFNENcXHVERTUwXFx1REU1M1xcdURFNTVcXHVERTU2XFx1REU1OFxcdURFNUFcXHVERTVDXFx1REU1RVxcdURFNjBcXHVERTYzXFx1REU2NVxcdURFNjZcXHVERTZCXFx1REU3M1xcdURFNzhcXHVERTdEXFx1REU3RlxcdURFOEFcXHVERTlDLVxcdURFQTBcXHVERUE0XFx1REVBQVxcdURFQkMtXFx1REVFRlxcdURFRjItXFx1REZGRl18W1xcdURCQkZcXHVEQkZGXVtcXHVERkZFXFx1REZGRl18XFx1RDg3RVtcXHVERTFFLVxcdURGRkZdfFxcdUQ4MkZbXFx1REM2Qi1cXHVEQzZGXFx1REM3RC1cXHVEQzdGXFx1REM4OS1cXHVEQzhGXFx1REM5QVxcdURDOUJcXHVEQ0E0LVxcdURGRkZdfFxcdUQ4M0FbXFx1RENDNVxcdURDQzZcXHVEQ0Q3LVxcdURGRkZdfFxcdUQ4MERbXFx1REMyRi1cXHVERkZGXXxcXHVEODZEW1xcdURGMzUtXFx1REYzRl18W1xcdUQ4MDdcXHVEODBBXFx1RDgwQlxcdUQ4MEUtXFx1RDgxMFxcdUQ4MTItXFx1RDgxOVxcdUQ4MUMtXFx1RDgyQlxcdUQ4MkRcXHVEODJFXFx1RDgzMC1cXHVEODMzXFx1RDgzNy1cXHVEODM5XFx1RDgzRlxcdUQ4NzQtXFx1RDg3RFxcdUQ4N0YtXFx1REIzRlxcdURCNDEtXFx1REI3Rl1bXFx1REMwMC1cXHVERkZGXXxcXHVEODA2W1xcdURDMDAtXFx1REM5RlxcdURDRjMtXFx1RENGRVxcdUREMDAtXFx1REVCRlxcdURFRjktXFx1REZGRl18XFx1RDgwM1tcXHVEQzQ5LVxcdURDN0ZcXHVEQ0IzLVxcdURDQkZcXHVEQ0YzLVxcdURDRjlcXHVERDAwLVxcdURFNUZcXHVERTdGLVxcdURGRkZdfFxcdUQ4MzVbXFx1REM1NVxcdURDOURcXHVEQ0EwXFx1RENBMVxcdURDQTNcXHVEQ0E0XFx1RENBN1xcdURDQThcXHVEQ0FEXFx1RENCQVxcdURDQkNcXHVEQ0M0XFx1REQwNlxcdUREMEJcXHVERDBDXFx1REQxNVxcdUREMURcXHVERDNBXFx1REQzRlxcdURENDVcXHVERDQ3LVxcdURENDlcXHVERDUxXFx1REVBNlxcdURFQTdcXHVERkNDXFx1REZDRF18XFx1RDgzNltcXHVERThDLVxcdURFOUFcXHVERUEwXFx1REVCMC1cXHVERkZGXXxcXHVEODA1W1xcdURDMDAtXFx1REM3RlxcdURDQzgtXFx1RENDRlxcdURDREEtXFx1REQ3RlxcdUREQjZcXHVEREI3XFx1RERERS1cXHVEREZGXFx1REU0NS1cXHVERTRGXFx1REU1QS1cXHVERTdGXFx1REVCOC1cXHVERUJGXFx1REVDQS1cXHVERUZGXFx1REYxQS1cXHVERjFDXFx1REYyQy1cXHVERjJGXFx1REY0MC1cXHVERkZGXXxcXHVEODAyW1xcdURDMDZcXHVEQzA3XFx1REMwOVxcdURDMzZcXHVEQzM5LVxcdURDM0JcXHVEQzNEXFx1REMzRVxcdURDNTZcXHVEQzlGLVxcdURDQTZcXHVEQ0IwLVxcdURDREZcXHVEQ0YzXFx1RENGNi1cXHVEQ0ZBXFx1REQxQy1cXHVERDFFXFx1REQzQS1cXHVERDNFXFx1REQ0MC1cXHVERDdGXFx1RERCOC1cXHVEREJCXFx1REREMFxcdURERDFcXHVERTA0XFx1REUwNy1cXHVERTBCXFx1REUxNFxcdURFMThcXHVERTM0LVxcdURFMzdcXHVERTNCLVxcdURFM0VcXHVERTQ4LVxcdURFNEZcXHVERTU5LVxcdURFNUZcXHVERUEwLVxcdURFQkZcXHVERUU3LVxcdURFRUFcXHVERUY3LVxcdURFRkZcXHVERjM2LVxcdURGMzhcXHVERjU2XFx1REY1N1xcdURGNzMtXFx1REY3N1xcdURGOTItXFx1REY5OFxcdURGOUQtXFx1REZBOFxcdURGQjAtXFx1REZGRl18XFx1RDgwOFtcXHVERjlBLVxcdURGRkZdfFxcdUQ4MDRbXFx1REM0RS1cXHVEQzUxXFx1REM3MC1cXHVEQzdFXFx1RENDMi1cXHVEQ0NGXFx1RENFOS1cXHVEQ0VGXFx1RENGQS1cXHVEQ0ZGXFx1REQzNVxcdURENDQtXFx1REQ0RlxcdURENzctXFx1REQ3RlxcdUREQ0VcXHVERENGXFx1RERFMFxcdURERjUtXFx1RERGRlxcdURFMTJcXHVERTNFLVxcdURFN0ZcXHVERTg3XFx1REU4OVxcdURFOEVcXHVERTlFXFx1REVBQS1cXHVERUFGXFx1REVFQi1cXHVERUVGXFx1REVGQS1cXHVERUZGXFx1REYwNFxcdURGMERcXHVERjBFXFx1REYxMVxcdURGMTJcXHVERjI5XFx1REYzMVxcdURGMzRcXHVERjNBXFx1REYzQlxcdURGNDVcXHVERjQ2XFx1REY0OVxcdURGNEFcXHVERjRFXFx1REY0RlxcdURGNTEtXFx1REY1NlxcdURGNTgtXFx1REY1Q1xcdURGNjRcXHVERjY1XFx1REY2RC1cXHVERjZGXFx1REY3NS1cXHVERkZGXXxcXHVEODJDW1xcdURDMDItXFx1REZGRl18XFx1RDgxMVtcXHVERTQ3LVxcdURGRkZdfFxcdUQ4M0VbXFx1REMwQy1cXHVEQzBGXFx1REM0OC1cXHVEQzRGXFx1REM1QS1cXHVEQzVGXFx1REM4OC1cXHVEQzhGXFx1RENBRS1cXHVERDBGXFx1REQxOS1cXHVERDdGXFx1REQ4NS1cXHVEREJGXFx1RERDMS1cXHVERkZGXXxcXHVEODczW1xcdURFQTItXFx1REZGRl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdDbycsXG4gICAgICAgICAgICBhbGlhczogJ1ByaXZhdGVfVXNlJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdUUwMDAtXFx1RjhGRicsXG4gICAgICAgICAgICBhc3RyYWw6ICdbXFx1REI4MC1cXHVEQkJFXFx1REJDMC1cXHVEQkZFXVtcXHVEQzAwLVxcdURGRkZdfFtcXHVEQkJGXFx1REJGRl1bXFx1REMwMC1cXHVERkZEXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0NzJyxcbiAgICAgICAgICAgIGFsaWFzOiAnU3Vycm9nYXRlJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdUQ4MDAtXFx1REZGRidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0wnLFxuICAgICAgICAgICAgYWxpYXM6ICdMZXR0ZXInLFxuICAgICAgICAgICAgYm1wOiAnQS1aYS16XFx4QUFcXHhCNVxceEJBXFx4QzAtXFx4RDZcXHhEOC1cXHhGNlxceEY4LVxcdTAyQzFcXHUwMkM2LVxcdTAyRDFcXHUwMkUwLVxcdTAyRTRcXHUwMkVDXFx1MDJFRVxcdTAzNzAtXFx1MDM3NFxcdTAzNzZcXHUwMzc3XFx1MDM3QS1cXHUwMzdEXFx1MDM3RlxcdTAzODZcXHUwMzg4LVxcdTAzOEFcXHUwMzhDXFx1MDM4RS1cXHUwM0ExXFx1MDNBMy1cXHUwM0Y1XFx1MDNGNy1cXHUwNDgxXFx1MDQ4QS1cXHUwNTJGXFx1MDUzMS1cXHUwNTU2XFx1MDU1OVxcdTA1NjEtXFx1MDU4N1xcdTA1RDAtXFx1MDVFQVxcdTA1RjAtXFx1MDVGMlxcdTA2MjAtXFx1MDY0QVxcdTA2NkVcXHUwNjZGXFx1MDY3MS1cXHUwNkQzXFx1MDZENVxcdTA2RTVcXHUwNkU2XFx1MDZFRVxcdTA2RUZcXHUwNkZBLVxcdTA2RkNcXHUwNkZGXFx1MDcxMFxcdTA3MTItXFx1MDcyRlxcdTA3NEQtXFx1MDdBNVxcdTA3QjFcXHUwN0NBLVxcdTA3RUFcXHUwN0Y0XFx1MDdGNVxcdTA3RkFcXHUwODAwLVxcdTA4MTVcXHUwODFBXFx1MDgyNFxcdTA4MjhcXHUwODQwLVxcdTA4NThcXHUwOEEwLVxcdTA4QjRcXHUwOTA0LVxcdTA5MzlcXHUwOTNEXFx1MDk1MFxcdTA5NTgtXFx1MDk2MVxcdTA5NzEtXFx1MDk4MFxcdTA5ODUtXFx1MDk4Q1xcdTA5OEZcXHUwOTkwXFx1MDk5My1cXHUwOUE4XFx1MDlBQS1cXHUwOUIwXFx1MDlCMlxcdTA5QjYtXFx1MDlCOVxcdTA5QkRcXHUwOUNFXFx1MDlEQ1xcdTA5RERcXHUwOURGLVxcdTA5RTFcXHUwOUYwXFx1MDlGMVxcdTBBMDUtXFx1MEEwQVxcdTBBMEZcXHUwQTEwXFx1MEExMy1cXHUwQTI4XFx1MEEyQS1cXHUwQTMwXFx1MEEzMlxcdTBBMzNcXHUwQTM1XFx1MEEzNlxcdTBBMzhcXHUwQTM5XFx1MEE1OS1cXHUwQTVDXFx1MEE1RVxcdTBBNzItXFx1MEE3NFxcdTBBODUtXFx1MEE4RFxcdTBBOEYtXFx1MEE5MVxcdTBBOTMtXFx1MEFBOFxcdTBBQUEtXFx1MEFCMFxcdTBBQjJcXHUwQUIzXFx1MEFCNS1cXHUwQUI5XFx1MEFCRFxcdTBBRDBcXHUwQUUwXFx1MEFFMVxcdTBBRjlcXHUwQjA1LVxcdTBCMENcXHUwQjBGXFx1MEIxMFxcdTBCMTMtXFx1MEIyOFxcdTBCMkEtXFx1MEIzMFxcdTBCMzJcXHUwQjMzXFx1MEIzNS1cXHUwQjM5XFx1MEIzRFxcdTBCNUNcXHUwQjVEXFx1MEI1Ri1cXHUwQjYxXFx1MEI3MVxcdTBCODNcXHUwQjg1LVxcdTBCOEFcXHUwQjhFLVxcdTBCOTBcXHUwQjkyLVxcdTBCOTVcXHUwQjk5XFx1MEI5QVxcdTBCOUNcXHUwQjlFXFx1MEI5RlxcdTBCQTNcXHUwQkE0XFx1MEJBOC1cXHUwQkFBXFx1MEJBRS1cXHUwQkI5XFx1MEJEMFxcdTBDMDUtXFx1MEMwQ1xcdTBDMEUtXFx1MEMxMFxcdTBDMTItXFx1MEMyOFxcdTBDMkEtXFx1MEMzOVxcdTBDM0RcXHUwQzU4LVxcdTBDNUFcXHUwQzYwXFx1MEM2MVxcdTBDODUtXFx1MEM4Q1xcdTBDOEUtXFx1MEM5MFxcdTBDOTItXFx1MENBOFxcdTBDQUEtXFx1MENCM1xcdTBDQjUtXFx1MENCOVxcdTBDQkRcXHUwQ0RFXFx1MENFMFxcdTBDRTFcXHUwQ0YxXFx1MENGMlxcdTBEMDUtXFx1MEQwQ1xcdTBEMEUtXFx1MEQxMFxcdTBEMTItXFx1MEQzQVxcdTBEM0RcXHUwRDRFXFx1MEQ1Ri1cXHUwRDYxXFx1MEQ3QS1cXHUwRDdGXFx1MEQ4NS1cXHUwRDk2XFx1MEQ5QS1cXHUwREIxXFx1MERCMy1cXHUwREJCXFx1MERCRFxcdTBEQzAtXFx1MERDNlxcdTBFMDEtXFx1MEUzMFxcdTBFMzJcXHUwRTMzXFx1MEU0MC1cXHUwRTQ2XFx1MEU4MVxcdTBFODJcXHUwRTg0XFx1MEU4N1xcdTBFODhcXHUwRThBXFx1MEU4RFxcdTBFOTQtXFx1MEU5N1xcdTBFOTktXFx1MEU5RlxcdTBFQTEtXFx1MEVBM1xcdTBFQTVcXHUwRUE3XFx1MEVBQVxcdTBFQUJcXHUwRUFELVxcdTBFQjBcXHUwRUIyXFx1MEVCM1xcdTBFQkRcXHUwRUMwLVxcdTBFQzRcXHUwRUM2XFx1MEVEQy1cXHUwRURGXFx1MEYwMFxcdTBGNDAtXFx1MEY0N1xcdTBGNDktXFx1MEY2Q1xcdTBGODgtXFx1MEY4Q1xcdTEwMDAtXFx1MTAyQVxcdTEwM0ZcXHUxMDUwLVxcdTEwNTVcXHUxMDVBLVxcdTEwNURcXHUxMDYxXFx1MTA2NVxcdTEwNjZcXHUxMDZFLVxcdTEwNzBcXHUxMDc1LVxcdTEwODFcXHUxMDhFXFx1MTBBMC1cXHUxMEM1XFx1MTBDN1xcdTEwQ0RcXHUxMEQwLVxcdTEwRkFcXHUxMEZDLVxcdTEyNDhcXHUxMjRBLVxcdTEyNERcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1QS1cXHUxMjVEXFx1MTI2MC1cXHUxMjg4XFx1MTI4QS1cXHUxMjhEXFx1MTI5MC1cXHUxMkIwXFx1MTJCMi1cXHUxMkI1XFx1MTJCOC1cXHUxMkJFXFx1MTJDMFxcdTEyQzItXFx1MTJDNVxcdTEyQzgtXFx1MTJENlxcdTEyRDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1QVxcdTEzODAtXFx1MTM4RlxcdTEzQTAtXFx1MTNGNVxcdTEzRjgtXFx1MTNGRFxcdTE0MDEtXFx1MTY2Q1xcdTE2NkYtXFx1MTY3RlxcdTE2ODEtXFx1MTY5QVxcdTE2QTAtXFx1MTZFQVxcdTE2RjEtXFx1MTZGOFxcdTE3MDAtXFx1MTcwQ1xcdTE3MEUtXFx1MTcxMVxcdTE3MjAtXFx1MTczMVxcdTE3NDAtXFx1MTc1MVxcdTE3NjAtXFx1MTc2Q1xcdTE3NkUtXFx1MTc3MFxcdTE3ODAtXFx1MTdCM1xcdTE3RDdcXHUxN0RDXFx1MTgyMC1cXHUxODc3XFx1MTg4MC1cXHUxOEE4XFx1MThBQVxcdTE4QjAtXFx1MThGNVxcdTE5MDAtXFx1MTkxRVxcdTE5NTAtXFx1MTk2RFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlBQlxcdTE5QjAtXFx1MTlDOVxcdTFBMDAtXFx1MUExNlxcdTFBMjAtXFx1MUE1NFxcdTFBQTdcXHUxQjA1LVxcdTFCMzNcXHUxQjQ1LVxcdTFCNEJcXHUxQjgzLVxcdTFCQTBcXHUxQkFFXFx1MUJBRlxcdTFCQkEtXFx1MUJFNVxcdTFDMDAtXFx1MUMyM1xcdTFDNEQtXFx1MUM0RlxcdTFDNUEtXFx1MUM3RFxcdTFDRTktXFx1MUNFQ1xcdTFDRUUtXFx1MUNGMVxcdTFDRjVcXHUxQ0Y2XFx1MUQwMC1cXHUxREJGXFx1MUUwMC1cXHUxRjE1XFx1MUYxOC1cXHUxRjFEXFx1MUYyMC1cXHUxRjQ1XFx1MUY0OC1cXHUxRjREXFx1MUY1MC1cXHUxRjU3XFx1MUY1OVxcdTFGNUJcXHUxRjVEXFx1MUY1Ri1cXHUxRjdEXFx1MUY4MC1cXHUxRkI0XFx1MUZCNi1cXHUxRkJDXFx1MUZCRVxcdTFGQzItXFx1MUZDNFxcdTFGQzYtXFx1MUZDQ1xcdTFGRDAtXFx1MUZEM1xcdTFGRDYtXFx1MUZEQlxcdTFGRTAtXFx1MUZFQ1xcdTFGRjItXFx1MUZGNFxcdTFGRjYtXFx1MUZGQ1xcdTIwNzFcXHUyMDdGXFx1MjA5MC1cXHUyMDlDXFx1MjEwMlxcdTIxMDdcXHUyMTBBLVxcdTIxMTNcXHUyMTE1XFx1MjExOS1cXHUyMTFEXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyQS1cXHUyMTJEXFx1MjEyRi1cXHUyMTM5XFx1MjEzQy1cXHUyMTNGXFx1MjE0NS1cXHUyMTQ5XFx1MjE0RVxcdTIxODNcXHUyMTg0XFx1MkMwMC1cXHUyQzJFXFx1MkMzMC1cXHUyQzVFXFx1MkM2MC1cXHUyQ0U0XFx1MkNFQi1cXHUyQ0VFXFx1MkNGMlxcdTJDRjNcXHUyRDAwLVxcdTJEMjVcXHUyRDI3XFx1MkQyRFxcdTJEMzAtXFx1MkQ2N1xcdTJENkZcXHUyRDgwLVxcdTJEOTZcXHUyREEwLVxcdTJEQTZcXHUyREE4LVxcdTJEQUVcXHUyREIwLVxcdTJEQjZcXHUyREI4LVxcdTJEQkVcXHUyREMwLVxcdTJEQzZcXHUyREM4LVxcdTJEQ0VcXHUyREQwLVxcdTJERDZcXHUyREQ4LVxcdTJEREVcXHUyRTJGXFx1MzAwNVxcdTMwMDZcXHUzMDMxLVxcdTMwMzVcXHUzMDNCXFx1MzAzQ1xcdTMwNDEtXFx1MzA5NlxcdTMwOUQtXFx1MzA5RlxcdTMwQTEtXFx1MzBGQVxcdTMwRkMtXFx1MzBGRlxcdTMxMDUtXFx1MzEyRFxcdTMxMzEtXFx1MzE4RVxcdTMxQTAtXFx1MzFCQVxcdTMxRjAtXFx1MzFGRlxcdTM0MDAtXFx1NERCNVxcdTRFMDAtXFx1OUZENVxcdUEwMDAtXFx1QTQ4Q1xcdUE0RDAtXFx1QTRGRFxcdUE1MDAtXFx1QTYwQ1xcdUE2MTAtXFx1QTYxRlxcdUE2MkFcXHVBNjJCXFx1QTY0MC1cXHVBNjZFXFx1QTY3Ri1cXHVBNjlEXFx1QTZBMC1cXHVBNkU1XFx1QTcxNy1cXHVBNzFGXFx1QTcyMi1cXHVBNzg4XFx1QTc4Qi1cXHVBN0FEXFx1QTdCMC1cXHVBN0I3XFx1QTdGNy1cXHVBODAxXFx1QTgwMy1cXHVBODA1XFx1QTgwNy1cXHVBODBBXFx1QTgwQy1cXHVBODIyXFx1QTg0MC1cXHVBODczXFx1QTg4Mi1cXHVBOEIzXFx1QThGMi1cXHVBOEY3XFx1QThGQlxcdUE4RkRcXHVBOTBBLVxcdUE5MjVcXHVBOTMwLVxcdUE5NDZcXHVBOTYwLVxcdUE5N0NcXHVBOTg0LVxcdUE5QjJcXHVBOUNGXFx1QTlFMC1cXHVBOUU0XFx1QTlFNi1cXHVBOUVGXFx1QTlGQS1cXHVBOUZFXFx1QUEwMC1cXHVBQTI4XFx1QUE0MC1cXHVBQTQyXFx1QUE0NC1cXHVBQTRCXFx1QUE2MC1cXHVBQTc2XFx1QUE3QVxcdUFBN0UtXFx1QUFBRlxcdUFBQjFcXHVBQUI1XFx1QUFCNlxcdUFBQjktXFx1QUFCRFxcdUFBQzBcXHVBQUMyXFx1QUFEQi1cXHVBQUREXFx1QUFFMC1cXHVBQUVBXFx1QUFGMi1cXHVBQUY0XFx1QUIwMS1cXHVBQjA2XFx1QUIwOS1cXHVBQjBFXFx1QUIxMS1cXHVBQjE2XFx1QUIyMC1cXHVBQjI2XFx1QUIyOC1cXHVBQjJFXFx1QUIzMC1cXHVBQjVBXFx1QUI1Qy1cXHVBQjY1XFx1QUI3MC1cXHVBQkUyXFx1QUMwMC1cXHVEN0EzXFx1RDdCMC1cXHVEN0M2XFx1RDdDQi1cXHVEN0ZCXFx1RjkwMC1cXHVGQTZEXFx1RkE3MC1cXHVGQUQ5XFx1RkIwMC1cXHVGQjA2XFx1RkIxMy1cXHVGQjE3XFx1RkIxRFxcdUZCMUYtXFx1RkIyOFxcdUZCMkEtXFx1RkIzNlxcdUZCMzgtXFx1RkIzQ1xcdUZCM0VcXHVGQjQwXFx1RkI0MVxcdUZCNDNcXHVGQjQ0XFx1RkI0Ni1cXHVGQkIxXFx1RkJEMy1cXHVGRDNEXFx1RkQ1MC1cXHVGRDhGXFx1RkQ5Mi1cXHVGREM3XFx1RkRGMC1cXHVGREZCXFx1RkU3MC1cXHVGRTc0XFx1RkU3Ni1cXHVGRUZDXFx1RkYyMS1cXHVGRjNBXFx1RkY0MS1cXHVGRjVBXFx1RkY2Ni1cXHVGRkJFXFx1RkZDMi1cXHVGRkM3XFx1RkZDQS1cXHVGRkNGXFx1RkZEMi1cXHVGRkQ3XFx1RkZEQS1cXHVGRkRDJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4NkVbXFx1REMwMC1cXHVEQzFEXFx1REMyMC1cXHVERkZGXXxcXHVEODZEW1xcdURDMDAtXFx1REYzNFxcdURGNDAtXFx1REZGRl18XFx1RDg2OVtcXHVEQzAwLVxcdURFRDZcXHVERjAwLVxcdURGRkZdfFxcdUQ4MDNbXFx1REMwMC1cXHVEQzQ4XFx1REM4MC1cXHVEQ0IyXFx1RENDMC1cXHVEQ0YyXXxcXHVEODNBW1xcdURDMDAtXFx1RENDNF18XFx1RDgwMVtcXHVEQzAwLVxcdURDOURcXHVERDAwLVxcdUREMjdcXHVERDMwLVxcdURENjNcXHVERTAwLVxcdURGMzZcXHVERjQwLVxcdURGNTVcXHVERjYwLVxcdURGNjddfFxcdUQ4MDBbXFx1REMwMC1cXHVEQzBCXFx1REMwRC1cXHVEQzI2XFx1REMyOC1cXHVEQzNBXFx1REMzQ1xcdURDM0RcXHVEQzNGLVxcdURDNERcXHVEQzUwLVxcdURDNURcXHVEQzgwLVxcdURDRkFcXHVERTgwLVxcdURFOUNcXHVERUEwLVxcdURFRDBcXHVERjAwLVxcdURGMUZcXHVERjMwLVxcdURGNDBcXHVERjQyLVxcdURGNDlcXHVERjUwLVxcdURGNzVcXHVERjgwLVxcdURGOURcXHVERkEwLVxcdURGQzNcXHVERkM4LVxcdURGQ0ZdfFxcdUQ4MERbXFx1REMwMC1cXHVEQzJFXXxcXHVEODdFW1xcdURDMDAtXFx1REUxRF18XFx1RDgxQltcXHVERjAwLVxcdURGNDRcXHVERjUwXFx1REY5My1cXHVERjlGXXxbXFx1RDgwQ1xcdUQ4NDAtXFx1RDg2OFxcdUQ4NkEtXFx1RDg2Q1xcdUQ4NkYtXFx1RDg3Ml1bXFx1REMwMC1cXHVERkZGXXxcXHVEODA1W1xcdURDODAtXFx1RENBRlxcdURDQzRcXHVEQ0M1XFx1RENDN1xcdUREODAtXFx1RERBRVxcdURERDgtXFx1REREQlxcdURFMDAtXFx1REUyRlxcdURFNDRcXHVERTgwLVxcdURFQUFcXHVERjAwLVxcdURGMTldfFxcdUQ4MUFbXFx1REMwMC1cXHVERTM4XFx1REU0MC1cXHVERTVFXFx1REVEMC1cXHVERUVEXFx1REYwMC1cXHVERjJGXFx1REY0MC1cXHVERjQzXFx1REY2My1cXHVERjc3XFx1REY3RC1cXHVERjhGXXxcXHVEODA5W1xcdURDODAtXFx1REQ0M118XFx1RDgwMltcXHVEQzAwLVxcdURDMDVcXHVEQzA4XFx1REMwQS1cXHVEQzM1XFx1REMzN1xcdURDMzhcXHVEQzNDXFx1REMzRi1cXHVEQzU1XFx1REM2MC1cXHVEQzc2XFx1REM4MC1cXHVEQzlFXFx1RENFMC1cXHVEQ0YyXFx1RENGNFxcdURDRjVcXHVERDAwLVxcdUREMTVcXHVERDIwLVxcdUREMzlcXHVERDgwLVxcdUREQjdcXHVEREJFXFx1RERCRlxcdURFMDBcXHVERTEwLVxcdURFMTNcXHVERTE1LVxcdURFMTdcXHVERTE5LVxcdURFMzNcXHVERTYwLVxcdURFN0NcXHVERTgwLVxcdURFOUNcXHVERUMwLVxcdURFQzdcXHVERUM5LVxcdURFRTRcXHVERjAwLVxcdURGMzVcXHVERjQwLVxcdURGNTVcXHVERjYwLVxcdURGNzJcXHVERjgwLVxcdURGOTFdfFxcdUQ4MzVbXFx1REMwMC1cXHVEQzU0XFx1REM1Ni1cXHVEQzlDXFx1REM5RVxcdURDOUZcXHVEQ0EyXFx1RENBNVxcdURDQTZcXHVEQ0E5LVxcdURDQUNcXHVEQ0FFLVxcdURDQjlcXHVEQ0JCXFx1RENCRC1cXHVEQ0MzXFx1RENDNS1cXHVERDA1XFx1REQwNy1cXHVERDBBXFx1REQwRC1cXHVERDE0XFx1REQxNi1cXHVERDFDXFx1REQxRS1cXHVERDM5XFx1REQzQi1cXHVERDNFXFx1REQ0MC1cXHVERDQ0XFx1REQ0NlxcdURENEEtXFx1REQ1MFxcdURENTItXFx1REVBNVxcdURFQTgtXFx1REVDMFxcdURFQzItXFx1REVEQVxcdURFREMtXFx1REVGQVxcdURFRkMtXFx1REYxNFxcdURGMTYtXFx1REYzNFxcdURGMzYtXFx1REY0RVxcdURGNTAtXFx1REY2RVxcdURGNzAtXFx1REY4OFxcdURGOEEtXFx1REZBOFxcdURGQUEtXFx1REZDMlxcdURGQzQtXFx1REZDQl18XFx1RDgwNFtcXHVEQzAzLVxcdURDMzdcXHVEQzgzLVxcdURDQUZcXHVEQ0QwLVxcdURDRThcXHVERDAzLVxcdUREMjZcXHVERDUwLVxcdURENzJcXHVERDc2XFx1REQ4My1cXHVEREIyXFx1RERDMS1cXHVEREM0XFx1REREQVxcdURERENcXHVERTAwLVxcdURFMTFcXHVERTEzLVxcdURFMkJcXHVERTgwLVxcdURFODZcXHVERTg4XFx1REU4QS1cXHVERThEXFx1REU4Ri1cXHVERTlEXFx1REU5Ri1cXHVERUE4XFx1REVCMC1cXHVERURFXFx1REYwNS1cXHVERjBDXFx1REYwRlxcdURGMTBcXHVERjEzLVxcdURGMjhcXHVERjJBLVxcdURGMzBcXHVERjMyXFx1REYzM1xcdURGMzUtXFx1REYzOVxcdURGM0RcXHVERjUwXFx1REY1RC1cXHVERjYxXXxcXHVEODA4W1xcdURDMDAtXFx1REY5OV18XFx1RDgzQltcXHVERTAwLVxcdURFMDNcXHVERTA1LVxcdURFMUZcXHVERTIxXFx1REUyMlxcdURFMjRcXHVERTI3XFx1REUyOS1cXHVERTMyXFx1REUzNC1cXHVERTM3XFx1REUzOVxcdURFM0JcXHVERTQyXFx1REU0N1xcdURFNDlcXHVERTRCXFx1REU0RC1cXHVERTRGXFx1REU1MVxcdURFNTJcXHVERTU0XFx1REU1N1xcdURFNTlcXHVERTVCXFx1REU1RFxcdURFNUZcXHVERTYxXFx1REU2MlxcdURFNjRcXHVERTY3LVxcdURFNkFcXHVERTZDLVxcdURFNzJcXHVERTc0LVxcdURFNzdcXHVERTc5LVxcdURFN0NcXHVERTdFXFx1REU4MC1cXHVERTg5XFx1REU4Qi1cXHVERTlCXFx1REVBMS1cXHVERUEzXFx1REVBNS1cXHVERUE5XFx1REVBQi1cXHVERUJCXXxcXHVEODA2W1xcdURDQTAtXFx1RENERlxcdURDRkZcXHVERUMwLVxcdURFRjhdfFxcdUQ4MTFbXFx1REMwMC1cXHVERTQ2XXxcXHVEODJGW1xcdURDMDAtXFx1REM2QVxcdURDNzAtXFx1REM3Q1xcdURDODAtXFx1REM4OFxcdURDOTAtXFx1REM5OV18XFx1RDgyQ1tcXHVEQzAwXFx1REMwMV18XFx1RDg3M1tcXHVEQzAwLVxcdURFQTFdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnTGwnLFxuICAgICAgICAgICAgYWxpYXM6ICdMb3dlcmNhc2VfTGV0dGVyJyxcbiAgICAgICAgICAgIGJtcDogJ2EtelxceEI1XFx4REYtXFx4RjZcXHhGOC1cXHhGRlxcdTAxMDFcXHUwMTAzXFx1MDEwNVxcdTAxMDdcXHUwMTA5XFx1MDEwQlxcdTAxMERcXHUwMTBGXFx1MDExMVxcdTAxMTNcXHUwMTE1XFx1MDExN1xcdTAxMTlcXHUwMTFCXFx1MDExRFxcdTAxMUZcXHUwMTIxXFx1MDEyM1xcdTAxMjVcXHUwMTI3XFx1MDEyOVxcdTAxMkJcXHUwMTJEXFx1MDEyRlxcdTAxMzFcXHUwMTMzXFx1MDEzNVxcdTAxMzdcXHUwMTM4XFx1MDEzQVxcdTAxM0NcXHUwMTNFXFx1MDE0MFxcdTAxNDJcXHUwMTQ0XFx1MDE0NlxcdTAxNDhcXHUwMTQ5XFx1MDE0QlxcdTAxNERcXHUwMTRGXFx1MDE1MVxcdTAxNTNcXHUwMTU1XFx1MDE1N1xcdTAxNTlcXHUwMTVCXFx1MDE1RFxcdTAxNUZcXHUwMTYxXFx1MDE2M1xcdTAxNjVcXHUwMTY3XFx1MDE2OVxcdTAxNkJcXHUwMTZEXFx1MDE2RlxcdTAxNzFcXHUwMTczXFx1MDE3NVxcdTAxNzdcXHUwMTdBXFx1MDE3Q1xcdTAxN0UtXFx1MDE4MFxcdTAxODNcXHUwMTg1XFx1MDE4OFxcdTAxOENcXHUwMThEXFx1MDE5MlxcdTAxOTVcXHUwMTk5LVxcdTAxOUJcXHUwMTlFXFx1MDFBMVxcdTAxQTNcXHUwMUE1XFx1MDFBOFxcdTAxQUFcXHUwMUFCXFx1MDFBRFxcdTAxQjBcXHUwMUI0XFx1MDFCNlxcdTAxQjlcXHUwMUJBXFx1MDFCRC1cXHUwMUJGXFx1MDFDNlxcdTAxQzlcXHUwMUNDXFx1MDFDRVxcdTAxRDBcXHUwMUQyXFx1MDFENFxcdTAxRDZcXHUwMUQ4XFx1MDFEQVxcdTAxRENcXHUwMUREXFx1MDFERlxcdTAxRTFcXHUwMUUzXFx1MDFFNVxcdTAxRTdcXHUwMUU5XFx1MDFFQlxcdTAxRURcXHUwMUVGXFx1MDFGMFxcdTAxRjNcXHUwMUY1XFx1MDFGOVxcdTAxRkJcXHUwMUZEXFx1MDFGRlxcdTAyMDFcXHUwMjAzXFx1MDIwNVxcdTAyMDdcXHUwMjA5XFx1MDIwQlxcdTAyMERcXHUwMjBGXFx1MDIxMVxcdTAyMTNcXHUwMjE1XFx1MDIxN1xcdTAyMTlcXHUwMjFCXFx1MDIxRFxcdTAyMUZcXHUwMjIxXFx1MDIyM1xcdTAyMjVcXHUwMjI3XFx1MDIyOVxcdTAyMkJcXHUwMjJEXFx1MDIyRlxcdTAyMzFcXHUwMjMzLVxcdTAyMzlcXHUwMjNDXFx1MDIzRlxcdTAyNDBcXHUwMjQyXFx1MDI0N1xcdTAyNDlcXHUwMjRCXFx1MDI0RFxcdTAyNEYtXFx1MDI5M1xcdTAyOTUtXFx1MDJBRlxcdTAzNzFcXHUwMzczXFx1MDM3N1xcdTAzN0ItXFx1MDM3RFxcdTAzOTBcXHUwM0FDLVxcdTAzQ0VcXHUwM0QwXFx1MDNEMVxcdTAzRDUtXFx1MDNEN1xcdTAzRDlcXHUwM0RCXFx1MDNERFxcdTAzREZcXHUwM0UxXFx1MDNFM1xcdTAzRTVcXHUwM0U3XFx1MDNFOVxcdTAzRUJcXHUwM0VEXFx1MDNFRi1cXHUwM0YzXFx1MDNGNVxcdTAzRjhcXHUwM0ZCXFx1MDNGQ1xcdTA0MzAtXFx1MDQ1RlxcdTA0NjFcXHUwNDYzXFx1MDQ2NVxcdTA0NjdcXHUwNDY5XFx1MDQ2QlxcdTA0NkRcXHUwNDZGXFx1MDQ3MVxcdTA0NzNcXHUwNDc1XFx1MDQ3N1xcdTA0NzlcXHUwNDdCXFx1MDQ3RFxcdTA0N0ZcXHUwNDgxXFx1MDQ4QlxcdTA0OERcXHUwNDhGXFx1MDQ5MVxcdTA0OTNcXHUwNDk1XFx1MDQ5N1xcdTA0OTlcXHUwNDlCXFx1MDQ5RFxcdTA0OUZcXHUwNEExXFx1MDRBM1xcdTA0QTVcXHUwNEE3XFx1MDRBOVxcdTA0QUJcXHUwNEFEXFx1MDRBRlxcdTA0QjFcXHUwNEIzXFx1MDRCNVxcdTA0QjdcXHUwNEI5XFx1MDRCQlxcdTA0QkRcXHUwNEJGXFx1MDRDMlxcdTA0QzRcXHUwNEM2XFx1MDRDOFxcdTA0Q0FcXHUwNENDXFx1MDRDRVxcdTA0Q0ZcXHUwNEQxXFx1MDREM1xcdTA0RDVcXHUwNEQ3XFx1MDREOVxcdTA0REJcXHUwNEREXFx1MDRERlxcdTA0RTFcXHUwNEUzXFx1MDRFNVxcdTA0RTdcXHUwNEU5XFx1MDRFQlxcdTA0RURcXHUwNEVGXFx1MDRGMVxcdTA0RjNcXHUwNEY1XFx1MDRGN1xcdTA0RjlcXHUwNEZCXFx1MDRGRFxcdTA0RkZcXHUwNTAxXFx1MDUwM1xcdTA1MDVcXHUwNTA3XFx1MDUwOVxcdTA1MEJcXHUwNTBEXFx1MDUwRlxcdTA1MTFcXHUwNTEzXFx1MDUxNVxcdTA1MTdcXHUwNTE5XFx1MDUxQlxcdTA1MURcXHUwNTFGXFx1MDUyMVxcdTA1MjNcXHUwNTI1XFx1MDUyN1xcdTA1MjlcXHUwNTJCXFx1MDUyRFxcdTA1MkZcXHUwNTYxLVxcdTA1ODdcXHUxM0Y4LVxcdTEzRkRcXHUxRDAwLVxcdTFEMkJcXHUxRDZCLVxcdTFENzdcXHUxRDc5LVxcdTFEOUFcXHUxRTAxXFx1MUUwM1xcdTFFMDVcXHUxRTA3XFx1MUUwOVxcdTFFMEJcXHUxRTBEXFx1MUUwRlxcdTFFMTFcXHUxRTEzXFx1MUUxNVxcdTFFMTdcXHUxRTE5XFx1MUUxQlxcdTFFMURcXHUxRTFGXFx1MUUyMVxcdTFFMjNcXHUxRTI1XFx1MUUyN1xcdTFFMjlcXHUxRTJCXFx1MUUyRFxcdTFFMkZcXHUxRTMxXFx1MUUzM1xcdTFFMzVcXHUxRTM3XFx1MUUzOVxcdTFFM0JcXHUxRTNEXFx1MUUzRlxcdTFFNDFcXHUxRTQzXFx1MUU0NVxcdTFFNDdcXHUxRTQ5XFx1MUU0QlxcdTFFNERcXHUxRTRGXFx1MUU1MVxcdTFFNTNcXHUxRTU1XFx1MUU1N1xcdTFFNTlcXHUxRTVCXFx1MUU1RFxcdTFFNUZcXHUxRTYxXFx1MUU2M1xcdTFFNjVcXHUxRTY3XFx1MUU2OVxcdTFFNkJcXHUxRTZEXFx1MUU2RlxcdTFFNzFcXHUxRTczXFx1MUU3NVxcdTFFNzdcXHUxRTc5XFx1MUU3QlxcdTFFN0RcXHUxRTdGXFx1MUU4MVxcdTFFODNcXHUxRTg1XFx1MUU4N1xcdTFFODlcXHUxRThCXFx1MUU4RFxcdTFFOEZcXHUxRTkxXFx1MUU5M1xcdTFFOTUtXFx1MUU5RFxcdTFFOUZcXHUxRUExXFx1MUVBM1xcdTFFQTVcXHUxRUE3XFx1MUVBOVxcdTFFQUJcXHUxRUFEXFx1MUVBRlxcdTFFQjFcXHUxRUIzXFx1MUVCNVxcdTFFQjdcXHUxRUI5XFx1MUVCQlxcdTFFQkRcXHUxRUJGXFx1MUVDMVxcdTFFQzNcXHUxRUM1XFx1MUVDN1xcdTFFQzlcXHUxRUNCXFx1MUVDRFxcdTFFQ0ZcXHUxRUQxXFx1MUVEM1xcdTFFRDVcXHUxRUQ3XFx1MUVEOVxcdTFFREJcXHUxRUREXFx1MUVERlxcdTFFRTFcXHUxRUUzXFx1MUVFNVxcdTFFRTdcXHUxRUU5XFx1MUVFQlxcdTFFRURcXHUxRUVGXFx1MUVGMVxcdTFFRjNcXHUxRUY1XFx1MUVGN1xcdTFFRjlcXHUxRUZCXFx1MUVGRFxcdTFFRkYtXFx1MUYwN1xcdTFGMTAtXFx1MUYxNVxcdTFGMjAtXFx1MUYyN1xcdTFGMzAtXFx1MUYzN1xcdTFGNDAtXFx1MUY0NVxcdTFGNTAtXFx1MUY1N1xcdTFGNjAtXFx1MUY2N1xcdTFGNzAtXFx1MUY3RFxcdTFGODAtXFx1MUY4N1xcdTFGOTAtXFx1MUY5N1xcdTFGQTAtXFx1MUZBN1xcdTFGQjAtXFx1MUZCNFxcdTFGQjZcXHUxRkI3XFx1MUZCRVxcdTFGQzItXFx1MUZDNFxcdTFGQzZcXHUxRkM3XFx1MUZEMC1cXHUxRkQzXFx1MUZENlxcdTFGRDdcXHUxRkUwLVxcdTFGRTdcXHUxRkYyLVxcdTFGRjRcXHUxRkY2XFx1MUZGN1xcdTIxMEFcXHUyMTBFXFx1MjEwRlxcdTIxMTNcXHUyMTJGXFx1MjEzNFxcdTIxMzlcXHUyMTNDXFx1MjEzRFxcdTIxNDYtXFx1MjE0OVxcdTIxNEVcXHUyMTg0XFx1MkMzMC1cXHUyQzVFXFx1MkM2MVxcdTJDNjVcXHUyQzY2XFx1MkM2OFxcdTJDNkFcXHUyQzZDXFx1MkM3MVxcdTJDNzNcXHUyQzc0XFx1MkM3Ni1cXHUyQzdCXFx1MkM4MVxcdTJDODNcXHUyQzg1XFx1MkM4N1xcdTJDODlcXHUyQzhCXFx1MkM4RFxcdTJDOEZcXHUyQzkxXFx1MkM5M1xcdTJDOTVcXHUyQzk3XFx1MkM5OVxcdTJDOUJcXHUyQzlEXFx1MkM5RlxcdTJDQTFcXHUyQ0EzXFx1MkNBNVxcdTJDQTdcXHUyQ0E5XFx1MkNBQlxcdTJDQURcXHUyQ0FGXFx1MkNCMVxcdTJDQjNcXHUyQ0I1XFx1MkNCN1xcdTJDQjlcXHUyQ0JCXFx1MkNCRFxcdTJDQkZcXHUyQ0MxXFx1MkNDM1xcdTJDQzVcXHUyQ0M3XFx1MkNDOVxcdTJDQ0JcXHUyQ0NEXFx1MkNDRlxcdTJDRDFcXHUyQ0QzXFx1MkNENVxcdTJDRDdcXHUyQ0Q5XFx1MkNEQlxcdTJDRERcXHUyQ0RGXFx1MkNFMVxcdTJDRTNcXHUyQ0U0XFx1MkNFQ1xcdTJDRUVcXHUyQ0YzXFx1MkQwMC1cXHUyRDI1XFx1MkQyN1xcdTJEMkRcXHVBNjQxXFx1QTY0M1xcdUE2NDVcXHVBNjQ3XFx1QTY0OVxcdUE2NEJcXHVBNjREXFx1QTY0RlxcdUE2NTFcXHVBNjUzXFx1QTY1NVxcdUE2NTdcXHVBNjU5XFx1QTY1QlxcdUE2NURcXHVBNjVGXFx1QTY2MVxcdUE2NjNcXHVBNjY1XFx1QTY2N1xcdUE2NjlcXHVBNjZCXFx1QTY2RFxcdUE2ODFcXHVBNjgzXFx1QTY4NVxcdUE2ODdcXHVBNjg5XFx1QTY4QlxcdUE2OERcXHVBNjhGXFx1QTY5MVxcdUE2OTNcXHVBNjk1XFx1QTY5N1xcdUE2OTlcXHVBNjlCXFx1QTcyM1xcdUE3MjVcXHVBNzI3XFx1QTcyOVxcdUE3MkJcXHVBNzJEXFx1QTcyRi1cXHVBNzMxXFx1QTczM1xcdUE3MzVcXHVBNzM3XFx1QTczOVxcdUE3M0JcXHVBNzNEXFx1QTczRlxcdUE3NDFcXHVBNzQzXFx1QTc0NVxcdUE3NDdcXHVBNzQ5XFx1QTc0QlxcdUE3NERcXHVBNzRGXFx1QTc1MVxcdUE3NTNcXHVBNzU1XFx1QTc1N1xcdUE3NTlcXHVBNzVCXFx1QTc1RFxcdUE3NUZcXHVBNzYxXFx1QTc2M1xcdUE3NjVcXHVBNzY3XFx1QTc2OVxcdUE3NkJcXHVBNzZEXFx1QTc2RlxcdUE3NzEtXFx1QTc3OFxcdUE3N0FcXHVBNzdDXFx1QTc3RlxcdUE3ODFcXHVBNzgzXFx1QTc4NVxcdUE3ODdcXHVBNzhDXFx1QTc4RVxcdUE3OTFcXHVBNzkzLVxcdUE3OTVcXHVBNzk3XFx1QTc5OVxcdUE3OUJcXHVBNzlEXFx1QTc5RlxcdUE3QTFcXHVBN0EzXFx1QTdBNVxcdUE3QTdcXHVBN0E5XFx1QTdCNVxcdUE3QjdcXHVBN0ZBXFx1QUIzMC1cXHVBQjVBXFx1QUI2MC1cXHVBQjY1XFx1QUI3MC1cXHVBQkJGXFx1RkIwMC1cXHVGQjA2XFx1RkIxMy1cXHVGQjE3XFx1RkY0MS1cXHVGRjVBJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDNbXFx1RENDMC1cXHVEQ0YyXXxcXHVEODM1W1xcdURDMUEtXFx1REMzM1xcdURDNEUtXFx1REM1NFxcdURDNTYtXFx1REM2N1xcdURDODItXFx1REM5QlxcdURDQjYtXFx1RENCOVxcdURDQkJcXHVEQ0JELVxcdURDQzNcXHVEQ0M1LVxcdURDQ0ZcXHVEQ0VBLVxcdUREMDNcXHVERDFFLVxcdUREMzdcXHVERDUyLVxcdURENkJcXHVERDg2LVxcdUREOUZcXHVEREJBLVxcdURERDNcXHVEREVFLVxcdURFMDdcXHVERTIyLVxcdURFM0JcXHVERTU2LVxcdURFNkZcXHVERThBLVxcdURFQTVcXHVERUMyLVxcdURFREFcXHVERURDLVxcdURFRTFcXHVERUZDLVxcdURGMTRcXHVERjE2LVxcdURGMUJcXHVERjM2LVxcdURGNEVcXHVERjUwLVxcdURGNTVcXHVERjcwLVxcdURGODhcXHVERjhBLVxcdURGOEZcXHVERkFBLVxcdURGQzJcXHVERkM0LVxcdURGQzlcXHVERkNCXXxcXHVEODAxW1xcdURDMjgtXFx1REM0Rl18XFx1RDgwNltcXHVEQ0MwLVxcdURDREZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnTG0nLFxuICAgICAgICAgICAgYWxpYXM6ICdNb2RpZmllcl9MZXR0ZXInLFxuICAgICAgICAgICAgYm1wOiAnXFx1MDJCMC1cXHUwMkMxXFx1MDJDNi1cXHUwMkQxXFx1MDJFMC1cXHUwMkU0XFx1MDJFQ1xcdTAyRUVcXHUwMzc0XFx1MDM3QVxcdTA1NTlcXHUwNjQwXFx1MDZFNVxcdTA2RTZcXHUwN0Y0XFx1MDdGNVxcdTA3RkFcXHUwODFBXFx1MDgyNFxcdTA4MjhcXHUwOTcxXFx1MEU0NlxcdTBFQzZcXHUxMEZDXFx1MTdEN1xcdTE4NDNcXHUxQUE3XFx1MUM3OC1cXHUxQzdEXFx1MUQyQy1cXHUxRDZBXFx1MUQ3OFxcdTFEOUItXFx1MURCRlxcdTIwNzFcXHUyMDdGXFx1MjA5MC1cXHUyMDlDXFx1MkM3Q1xcdTJDN0RcXHUyRDZGXFx1MkUyRlxcdTMwMDVcXHUzMDMxLVxcdTMwMzVcXHUzMDNCXFx1MzA5RFxcdTMwOUVcXHUzMEZDLVxcdTMwRkVcXHVBMDE1XFx1QTRGOC1cXHVBNEZEXFx1QTYwQ1xcdUE2N0ZcXHVBNjlDXFx1QTY5RFxcdUE3MTctXFx1QTcxRlxcdUE3NzBcXHVBNzg4XFx1QTdGOFxcdUE3RjlcXHVBOUNGXFx1QTlFNlxcdUFBNzBcXHVBQUREXFx1QUFGM1xcdUFBRjRcXHVBQjVDLVxcdUFCNUZcXHVGRjcwXFx1RkY5RVxcdUZGOUYnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgxQVtcXHVERjQwLVxcdURGNDNdfFxcdUQ4MUJbXFx1REY5My1cXHVERjlGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0xvJyxcbiAgICAgICAgICAgIGFsaWFzOiAnT3RoZXJfTGV0dGVyJyxcbiAgICAgICAgICAgIGJtcDogJ1xceEFBXFx4QkFcXHUwMUJCXFx1MDFDMC1cXHUwMUMzXFx1MDI5NFxcdTA1RDAtXFx1MDVFQVxcdTA1RjAtXFx1MDVGMlxcdTA2MjAtXFx1MDYzRlxcdTA2NDEtXFx1MDY0QVxcdTA2NkVcXHUwNjZGXFx1MDY3MS1cXHUwNkQzXFx1MDZENVxcdTA2RUVcXHUwNkVGXFx1MDZGQS1cXHUwNkZDXFx1MDZGRlxcdTA3MTBcXHUwNzEyLVxcdTA3MkZcXHUwNzRELVxcdTA3QTVcXHUwN0IxXFx1MDdDQS1cXHUwN0VBXFx1MDgwMC1cXHUwODE1XFx1MDg0MC1cXHUwODU4XFx1MDhBMC1cXHUwOEI0XFx1MDkwNC1cXHUwOTM5XFx1MDkzRFxcdTA5NTBcXHUwOTU4LVxcdTA5NjFcXHUwOTcyLVxcdTA5ODBcXHUwOTg1LVxcdTA5OENcXHUwOThGXFx1MDk5MFxcdTA5OTMtXFx1MDlBOFxcdTA5QUEtXFx1MDlCMFxcdTA5QjJcXHUwOUI2LVxcdTA5QjlcXHUwOUJEXFx1MDlDRVxcdTA5RENcXHUwOUREXFx1MDlERi1cXHUwOUUxXFx1MDlGMFxcdTA5RjFcXHUwQTA1LVxcdTBBMEFcXHUwQTBGXFx1MEExMFxcdTBBMTMtXFx1MEEyOFxcdTBBMkEtXFx1MEEzMFxcdTBBMzJcXHUwQTMzXFx1MEEzNVxcdTBBMzZcXHUwQTM4XFx1MEEzOVxcdTBBNTktXFx1MEE1Q1xcdTBBNUVcXHUwQTcyLVxcdTBBNzRcXHUwQTg1LVxcdTBBOERcXHUwQThGLVxcdTBBOTFcXHUwQTkzLVxcdTBBQThcXHUwQUFBLVxcdTBBQjBcXHUwQUIyXFx1MEFCM1xcdTBBQjUtXFx1MEFCOVxcdTBBQkRcXHUwQUQwXFx1MEFFMFxcdTBBRTFcXHUwQUY5XFx1MEIwNS1cXHUwQjBDXFx1MEIwRlxcdTBCMTBcXHUwQjEzLVxcdTBCMjhcXHUwQjJBLVxcdTBCMzBcXHUwQjMyXFx1MEIzM1xcdTBCMzUtXFx1MEIzOVxcdTBCM0RcXHUwQjVDXFx1MEI1RFxcdTBCNUYtXFx1MEI2MVxcdTBCNzFcXHUwQjgzXFx1MEI4NS1cXHUwQjhBXFx1MEI4RS1cXHUwQjkwXFx1MEI5Mi1cXHUwQjk1XFx1MEI5OVxcdTBCOUFcXHUwQjlDXFx1MEI5RVxcdTBCOUZcXHUwQkEzXFx1MEJBNFxcdTBCQTgtXFx1MEJBQVxcdTBCQUUtXFx1MEJCOVxcdTBCRDBcXHUwQzA1LVxcdTBDMENcXHUwQzBFLVxcdTBDMTBcXHUwQzEyLVxcdTBDMjhcXHUwQzJBLVxcdTBDMzlcXHUwQzNEXFx1MEM1OC1cXHUwQzVBXFx1MEM2MFxcdTBDNjFcXHUwQzg1LVxcdTBDOENcXHUwQzhFLVxcdTBDOTBcXHUwQzkyLVxcdTBDQThcXHUwQ0FBLVxcdTBDQjNcXHUwQ0I1LVxcdTBDQjlcXHUwQ0JEXFx1MENERVxcdTBDRTBcXHUwQ0UxXFx1MENGMVxcdTBDRjJcXHUwRDA1LVxcdTBEMENcXHUwRDBFLVxcdTBEMTBcXHUwRDEyLVxcdTBEM0FcXHUwRDNEXFx1MEQ0RVxcdTBENUYtXFx1MEQ2MVxcdTBEN0EtXFx1MEQ3RlxcdTBEODUtXFx1MEQ5NlxcdTBEOUEtXFx1MERCMVxcdTBEQjMtXFx1MERCQlxcdTBEQkRcXHUwREMwLVxcdTBEQzZcXHUwRTAxLVxcdTBFMzBcXHUwRTMyXFx1MEUzM1xcdTBFNDAtXFx1MEU0NVxcdTBFODFcXHUwRTgyXFx1MEU4NFxcdTBFODdcXHUwRTg4XFx1MEU4QVxcdTBFOERcXHUwRTk0LVxcdTBFOTdcXHUwRTk5LVxcdTBFOUZcXHUwRUExLVxcdTBFQTNcXHUwRUE1XFx1MEVBN1xcdTBFQUFcXHUwRUFCXFx1MEVBRC1cXHUwRUIwXFx1MEVCMlxcdTBFQjNcXHUwRUJEXFx1MEVDMC1cXHUwRUM0XFx1MEVEQy1cXHUwRURGXFx1MEYwMFxcdTBGNDAtXFx1MEY0N1xcdTBGNDktXFx1MEY2Q1xcdTBGODgtXFx1MEY4Q1xcdTEwMDAtXFx1MTAyQVxcdTEwM0ZcXHUxMDUwLVxcdTEwNTVcXHUxMDVBLVxcdTEwNURcXHUxMDYxXFx1MTA2NVxcdTEwNjZcXHUxMDZFLVxcdTEwNzBcXHUxMDc1LVxcdTEwODFcXHUxMDhFXFx1MTBEMC1cXHUxMEZBXFx1MTBGRC1cXHUxMjQ4XFx1MTI0QS1cXHUxMjREXFx1MTI1MC1cXHUxMjU2XFx1MTI1OFxcdTEyNUEtXFx1MTI1RFxcdTEyNjAtXFx1MTI4OFxcdTEyOEEtXFx1MTI4RFxcdTEyOTAtXFx1MTJCMFxcdTEyQjItXFx1MTJCNVxcdTEyQjgtXFx1MTJCRVxcdTEyQzBcXHUxMkMyLVxcdTEyQzVcXHUxMkM4LVxcdTEyRDZcXHUxMkQ4LVxcdTEzMTBcXHUxMzEyLVxcdTEzMTVcXHUxMzE4LVxcdTEzNUFcXHUxMzgwLVxcdTEzOEZcXHUxNDAxLVxcdTE2NkNcXHUxNjZGLVxcdTE2N0ZcXHUxNjgxLVxcdTE2OUFcXHUxNkEwLVxcdTE2RUFcXHUxNkYxLVxcdTE2RjhcXHUxNzAwLVxcdTE3MENcXHUxNzBFLVxcdTE3MTFcXHUxNzIwLVxcdTE3MzFcXHUxNzQwLVxcdTE3NTFcXHUxNzYwLVxcdTE3NkNcXHUxNzZFLVxcdTE3NzBcXHUxNzgwLVxcdTE3QjNcXHUxN0RDXFx1MTgyMC1cXHUxODQyXFx1MTg0NC1cXHUxODc3XFx1MTg4MC1cXHUxOEE4XFx1MThBQVxcdTE4QjAtXFx1MThGNVxcdTE5MDAtXFx1MTkxRVxcdTE5NTAtXFx1MTk2RFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlBQlxcdTE5QjAtXFx1MTlDOVxcdTFBMDAtXFx1MUExNlxcdTFBMjAtXFx1MUE1NFxcdTFCMDUtXFx1MUIzM1xcdTFCNDUtXFx1MUI0QlxcdTFCODMtXFx1MUJBMFxcdTFCQUVcXHUxQkFGXFx1MUJCQS1cXHUxQkU1XFx1MUMwMC1cXHUxQzIzXFx1MUM0RC1cXHUxQzRGXFx1MUM1QS1cXHUxQzc3XFx1MUNFOS1cXHUxQ0VDXFx1MUNFRS1cXHUxQ0YxXFx1MUNGNVxcdTFDRjZcXHUyMTM1LVxcdTIxMzhcXHUyRDMwLVxcdTJENjdcXHUyRDgwLVxcdTJEOTZcXHUyREEwLVxcdTJEQTZcXHUyREE4LVxcdTJEQUVcXHUyREIwLVxcdTJEQjZcXHUyREI4LVxcdTJEQkVcXHUyREMwLVxcdTJEQzZcXHUyREM4LVxcdTJEQ0VcXHUyREQwLVxcdTJERDZcXHUyREQ4LVxcdTJEREVcXHUzMDA2XFx1MzAzQ1xcdTMwNDEtXFx1MzA5NlxcdTMwOUZcXHUzMEExLVxcdTMwRkFcXHUzMEZGXFx1MzEwNS1cXHUzMTJEXFx1MzEzMS1cXHUzMThFXFx1MzFBMC1cXHUzMUJBXFx1MzFGMC1cXHUzMUZGXFx1MzQwMC1cXHU0REI1XFx1NEUwMC1cXHU5RkQ1XFx1QTAwMC1cXHVBMDE0XFx1QTAxNi1cXHVBNDhDXFx1QTREMC1cXHVBNEY3XFx1QTUwMC1cXHVBNjBCXFx1QTYxMC1cXHVBNjFGXFx1QTYyQVxcdUE2MkJcXHVBNjZFXFx1QTZBMC1cXHVBNkU1XFx1QTc4RlxcdUE3RjdcXHVBN0ZCLVxcdUE4MDFcXHVBODAzLVxcdUE4MDVcXHVBODA3LVxcdUE4MEFcXHVBODBDLVxcdUE4MjJcXHVBODQwLVxcdUE4NzNcXHVBODgyLVxcdUE4QjNcXHVBOEYyLVxcdUE4RjdcXHVBOEZCXFx1QThGRFxcdUE5MEEtXFx1QTkyNVxcdUE5MzAtXFx1QTk0NlxcdUE5NjAtXFx1QTk3Q1xcdUE5ODQtXFx1QTlCMlxcdUE5RTAtXFx1QTlFNFxcdUE5RTctXFx1QTlFRlxcdUE5RkEtXFx1QTlGRVxcdUFBMDAtXFx1QUEyOFxcdUFBNDAtXFx1QUE0MlxcdUFBNDQtXFx1QUE0QlxcdUFBNjAtXFx1QUE2RlxcdUFBNzEtXFx1QUE3NlxcdUFBN0FcXHVBQTdFLVxcdUFBQUZcXHVBQUIxXFx1QUFCNVxcdUFBQjZcXHVBQUI5LVxcdUFBQkRcXHVBQUMwXFx1QUFDMlxcdUFBREJcXHVBQURDXFx1QUFFMC1cXHVBQUVBXFx1QUFGMlxcdUFCMDEtXFx1QUIwNlxcdUFCMDktXFx1QUIwRVxcdUFCMTEtXFx1QUIxNlxcdUFCMjAtXFx1QUIyNlxcdUFCMjgtXFx1QUIyRVxcdUFCQzAtXFx1QUJFMlxcdUFDMDAtXFx1RDdBM1xcdUQ3QjAtXFx1RDdDNlxcdUQ3Q0ItXFx1RDdGQlxcdUY5MDAtXFx1RkE2RFxcdUZBNzAtXFx1RkFEOVxcdUZCMURcXHVGQjFGLVxcdUZCMjhcXHVGQjJBLVxcdUZCMzZcXHVGQjM4LVxcdUZCM0NcXHVGQjNFXFx1RkI0MFxcdUZCNDFcXHVGQjQzXFx1RkI0NFxcdUZCNDYtXFx1RkJCMVxcdUZCRDMtXFx1RkQzRFxcdUZENTAtXFx1RkQ4RlxcdUZEOTItXFx1RkRDN1xcdUZERjAtXFx1RkRGQlxcdUZFNzAtXFx1RkU3NFxcdUZFNzYtXFx1RkVGQ1xcdUZGNjYtXFx1RkY2RlxcdUZGNzEtXFx1RkY5RFxcdUZGQTAtXFx1RkZCRVxcdUZGQzItXFx1RkZDN1xcdUZGQ0EtXFx1RkZDRlxcdUZGRDItXFx1RkZEN1xcdUZGREEtXFx1RkZEQycsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODZFW1xcdURDMDAtXFx1REMxRFxcdURDMjAtXFx1REZGRl18XFx1RDg2RFtcXHVEQzAwLVxcdURGMzRcXHVERjQwLVxcdURGRkZdfFxcdUQ4NjlbXFx1REMwMC1cXHVERUQ2XFx1REYwMC1cXHVERkZGXXxcXHVEODNBW1xcdURDMDAtXFx1RENDNF18XFx1RDgwM1tcXHVEQzAwLVxcdURDNDhdfFxcdUQ4MDBbXFx1REMwMC1cXHVEQzBCXFx1REMwRC1cXHVEQzI2XFx1REMyOC1cXHVEQzNBXFx1REMzQ1xcdURDM0RcXHVEQzNGLVxcdURDNERcXHVEQzUwLVxcdURDNURcXHVEQzgwLVxcdURDRkFcXHVERTgwLVxcdURFOUNcXHVERUEwLVxcdURFRDBcXHVERjAwLVxcdURGMUZcXHVERjMwLVxcdURGNDBcXHVERjQyLVxcdURGNDlcXHVERjUwLVxcdURGNzVcXHVERjgwLVxcdURGOURcXHVERkEwLVxcdURGQzNcXHVERkM4LVxcdURGQ0ZdfFxcdUQ4MERbXFx1REMwMC1cXHVEQzJFXXxcXHVEODdFW1xcdURDMDAtXFx1REUxRF18XFx1RDgxQltcXHVERjAwLVxcdURGNDRcXHVERjUwXXxbXFx1RDgwQ1xcdUQ4NDAtXFx1RDg2OFxcdUQ4NkEtXFx1RDg2Q1xcdUQ4NkYtXFx1RDg3Ml1bXFx1REMwMC1cXHVERkZGXXxcXHVEODA1W1xcdURDODAtXFx1RENBRlxcdURDQzRcXHVEQ0M1XFx1RENDN1xcdUREODAtXFx1RERBRVxcdURERDgtXFx1REREQlxcdURFMDAtXFx1REUyRlxcdURFNDRcXHVERTgwLVxcdURFQUFcXHVERjAwLVxcdURGMTldfFxcdUQ4MDZbXFx1RENGRlxcdURFQzAtXFx1REVGOF18XFx1RDgwOVtcXHVEQzgwLVxcdURENDNdfFxcdUQ4MDJbXFx1REMwMC1cXHVEQzA1XFx1REMwOFxcdURDMEEtXFx1REMzNVxcdURDMzdcXHVEQzM4XFx1REMzQ1xcdURDM0YtXFx1REM1NVxcdURDNjAtXFx1REM3NlxcdURDODAtXFx1REM5RVxcdURDRTAtXFx1RENGMlxcdURDRjRcXHVEQ0Y1XFx1REQwMC1cXHVERDE1XFx1REQyMC1cXHVERDM5XFx1REQ4MC1cXHVEREI3XFx1RERCRVxcdUREQkZcXHVERTAwXFx1REUxMC1cXHVERTEzXFx1REUxNS1cXHVERTE3XFx1REUxOS1cXHVERTMzXFx1REU2MC1cXHVERTdDXFx1REU4MC1cXHVERTlDXFx1REVDMC1cXHVERUM3XFx1REVDOS1cXHVERUU0XFx1REYwMC1cXHVERjM1XFx1REY0MC1cXHVERjU1XFx1REY2MC1cXHVERjcyXFx1REY4MC1cXHVERjkxXXxcXHVEODA0W1xcdURDMDMtXFx1REMzN1xcdURDODMtXFx1RENBRlxcdURDRDAtXFx1RENFOFxcdUREMDMtXFx1REQyNlxcdURENTAtXFx1REQ3MlxcdURENzZcXHVERDgzLVxcdUREQjJcXHVEREMxLVxcdUREQzRcXHVERERBXFx1REREQ1xcdURFMDAtXFx1REUxMVxcdURFMTMtXFx1REUyQlxcdURFODAtXFx1REU4NlxcdURFODhcXHVERThBLVxcdURFOERcXHVERThGLVxcdURFOURcXHVERTlGLVxcdURFQThcXHVERUIwLVxcdURFREVcXHVERjA1LVxcdURGMENcXHVERjBGXFx1REYxMFxcdURGMTMtXFx1REYyOFxcdURGMkEtXFx1REYzMFxcdURGMzJcXHVERjMzXFx1REYzNS1cXHVERjM5XFx1REYzRFxcdURGNTBcXHVERjVELVxcdURGNjFdfFxcdUQ4MDhbXFx1REMwMC1cXHVERjk5XXxcXHVEODNCW1xcdURFMDAtXFx1REUwM1xcdURFMDUtXFx1REUxRlxcdURFMjFcXHVERTIyXFx1REUyNFxcdURFMjdcXHVERTI5LVxcdURFMzJcXHVERTM0LVxcdURFMzdcXHVERTM5XFx1REUzQlxcdURFNDJcXHVERTQ3XFx1REU0OVxcdURFNEJcXHVERTRELVxcdURFNEZcXHVERTUxXFx1REU1MlxcdURFNTRcXHVERTU3XFx1REU1OVxcdURFNUJcXHVERTVEXFx1REU1RlxcdURFNjFcXHVERTYyXFx1REU2NFxcdURFNjctXFx1REU2QVxcdURFNkMtXFx1REU3MlxcdURFNzQtXFx1REU3N1xcdURFNzktXFx1REU3Q1xcdURFN0VcXHVERTgwLVxcdURFODlcXHVERThCLVxcdURFOUJcXHVERUExLVxcdURFQTNcXHVERUE1LVxcdURFQTlcXHVERUFCLVxcdURFQkJdfFxcdUQ4MUFbXFx1REMwMC1cXHVERTM4XFx1REU0MC1cXHVERTVFXFx1REVEMC1cXHVERUVEXFx1REYwMC1cXHVERjJGXFx1REY2My1cXHVERjc3XFx1REY3RC1cXHVERjhGXXxcXHVEODAxW1xcdURDNTAtXFx1REM5RFxcdUREMDAtXFx1REQyN1xcdUREMzAtXFx1REQ2M1xcdURFMDAtXFx1REYzNlxcdURGNDAtXFx1REY1NVxcdURGNjAtXFx1REY2N118XFx1RDgxMVtcXHVEQzAwLVxcdURFNDZdfFxcdUQ4MkZbXFx1REMwMC1cXHVEQzZBXFx1REM3MC1cXHVEQzdDXFx1REM4MC1cXHVEQzg4XFx1REM5MC1cXHVEQzk5XXxcXHVEODJDW1xcdURDMDBcXHVEQzAxXXxcXHVEODczW1xcdURDMDAtXFx1REVBMV0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdMdCcsXG4gICAgICAgICAgICBhbGlhczogJ1RpdGxlY2FzZV9MZXR0ZXInLFxuICAgICAgICAgICAgYm1wOiAnXFx1MDFDNVxcdTAxQzhcXHUwMUNCXFx1MDFGMlxcdTFGODgtXFx1MUY4RlxcdTFGOTgtXFx1MUY5RlxcdTFGQTgtXFx1MUZBRlxcdTFGQkNcXHUxRkNDXFx1MUZGQydcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0x1JyxcbiAgICAgICAgICAgIGFsaWFzOiAnVXBwZXJjYXNlX0xldHRlcicsXG4gICAgICAgICAgICBibXA6ICdBLVpcXHhDMC1cXHhENlxceEQ4LVxceERFXFx1MDEwMFxcdTAxMDJcXHUwMTA0XFx1MDEwNlxcdTAxMDhcXHUwMTBBXFx1MDEwQ1xcdTAxMEVcXHUwMTEwXFx1MDExMlxcdTAxMTRcXHUwMTE2XFx1MDExOFxcdTAxMUFcXHUwMTFDXFx1MDExRVxcdTAxMjBcXHUwMTIyXFx1MDEyNFxcdTAxMjZcXHUwMTI4XFx1MDEyQVxcdTAxMkNcXHUwMTJFXFx1MDEzMFxcdTAxMzJcXHUwMTM0XFx1MDEzNlxcdTAxMzlcXHUwMTNCXFx1MDEzRFxcdTAxM0ZcXHUwMTQxXFx1MDE0M1xcdTAxNDVcXHUwMTQ3XFx1MDE0QVxcdTAxNENcXHUwMTRFXFx1MDE1MFxcdTAxNTJcXHUwMTU0XFx1MDE1NlxcdTAxNThcXHUwMTVBXFx1MDE1Q1xcdTAxNUVcXHUwMTYwXFx1MDE2MlxcdTAxNjRcXHUwMTY2XFx1MDE2OFxcdTAxNkFcXHUwMTZDXFx1MDE2RVxcdTAxNzBcXHUwMTcyXFx1MDE3NFxcdTAxNzZcXHUwMTc4XFx1MDE3OVxcdTAxN0JcXHUwMTdEXFx1MDE4MVxcdTAxODJcXHUwMTg0XFx1MDE4NlxcdTAxODdcXHUwMTg5LVxcdTAxOEJcXHUwMThFLVxcdTAxOTFcXHUwMTkzXFx1MDE5NFxcdTAxOTYtXFx1MDE5OFxcdTAxOUNcXHUwMTlEXFx1MDE5RlxcdTAxQTBcXHUwMUEyXFx1MDFBNFxcdTAxQTZcXHUwMUE3XFx1MDFBOVxcdTAxQUNcXHUwMUFFXFx1MDFBRlxcdTAxQjEtXFx1MDFCM1xcdTAxQjVcXHUwMUI3XFx1MDFCOFxcdTAxQkNcXHUwMUM0XFx1MDFDN1xcdTAxQ0FcXHUwMUNEXFx1MDFDRlxcdTAxRDFcXHUwMUQzXFx1MDFENVxcdTAxRDdcXHUwMUQ5XFx1MDFEQlxcdTAxREVcXHUwMUUwXFx1MDFFMlxcdTAxRTRcXHUwMUU2XFx1MDFFOFxcdTAxRUFcXHUwMUVDXFx1MDFFRVxcdTAxRjFcXHUwMUY0XFx1MDFGNi1cXHUwMUY4XFx1MDFGQVxcdTAxRkNcXHUwMUZFXFx1MDIwMFxcdTAyMDJcXHUwMjA0XFx1MDIwNlxcdTAyMDhcXHUwMjBBXFx1MDIwQ1xcdTAyMEVcXHUwMjEwXFx1MDIxMlxcdTAyMTRcXHUwMjE2XFx1MDIxOFxcdTAyMUFcXHUwMjFDXFx1MDIxRVxcdTAyMjBcXHUwMjIyXFx1MDIyNFxcdTAyMjZcXHUwMjI4XFx1MDIyQVxcdTAyMkNcXHUwMjJFXFx1MDIzMFxcdTAyMzJcXHUwMjNBXFx1MDIzQlxcdTAyM0RcXHUwMjNFXFx1MDI0MVxcdTAyNDMtXFx1MDI0NlxcdTAyNDhcXHUwMjRBXFx1MDI0Q1xcdTAyNEVcXHUwMzcwXFx1MDM3MlxcdTAzNzZcXHUwMzdGXFx1MDM4NlxcdTAzODgtXFx1MDM4QVxcdTAzOENcXHUwMzhFXFx1MDM4RlxcdTAzOTEtXFx1MDNBMVxcdTAzQTMtXFx1MDNBQlxcdTAzQ0ZcXHUwM0QyLVxcdTAzRDRcXHUwM0Q4XFx1MDNEQVxcdTAzRENcXHUwM0RFXFx1MDNFMFxcdTAzRTJcXHUwM0U0XFx1MDNFNlxcdTAzRThcXHUwM0VBXFx1MDNFQ1xcdTAzRUVcXHUwM0Y0XFx1MDNGN1xcdTAzRjlcXHUwM0ZBXFx1MDNGRC1cXHUwNDJGXFx1MDQ2MFxcdTA0NjJcXHUwNDY0XFx1MDQ2NlxcdTA0NjhcXHUwNDZBXFx1MDQ2Q1xcdTA0NkVcXHUwNDcwXFx1MDQ3MlxcdTA0NzRcXHUwNDc2XFx1MDQ3OFxcdTA0N0FcXHUwNDdDXFx1MDQ3RVxcdTA0ODBcXHUwNDhBXFx1MDQ4Q1xcdTA0OEVcXHUwNDkwXFx1MDQ5MlxcdTA0OTRcXHUwNDk2XFx1MDQ5OFxcdTA0OUFcXHUwNDlDXFx1MDQ5RVxcdTA0QTBcXHUwNEEyXFx1MDRBNFxcdTA0QTZcXHUwNEE4XFx1MDRBQVxcdTA0QUNcXHUwNEFFXFx1MDRCMFxcdTA0QjJcXHUwNEI0XFx1MDRCNlxcdTA0QjhcXHUwNEJBXFx1MDRCQ1xcdTA0QkVcXHUwNEMwXFx1MDRDMVxcdTA0QzNcXHUwNEM1XFx1MDRDN1xcdTA0QzlcXHUwNENCXFx1MDRDRFxcdTA0RDBcXHUwNEQyXFx1MDRENFxcdTA0RDZcXHUwNEQ4XFx1MDREQVxcdTA0RENcXHUwNERFXFx1MDRFMFxcdTA0RTJcXHUwNEU0XFx1MDRFNlxcdTA0RThcXHUwNEVBXFx1MDRFQ1xcdTA0RUVcXHUwNEYwXFx1MDRGMlxcdTA0RjRcXHUwNEY2XFx1MDRGOFxcdTA0RkFcXHUwNEZDXFx1MDRGRVxcdTA1MDBcXHUwNTAyXFx1MDUwNFxcdTA1MDZcXHUwNTA4XFx1MDUwQVxcdTA1MENcXHUwNTBFXFx1MDUxMFxcdTA1MTJcXHUwNTE0XFx1MDUxNlxcdTA1MThcXHUwNTFBXFx1MDUxQ1xcdTA1MUVcXHUwNTIwXFx1MDUyMlxcdTA1MjRcXHUwNTI2XFx1MDUyOFxcdTA1MkFcXHUwNTJDXFx1MDUyRVxcdTA1MzEtXFx1MDU1NlxcdTEwQTAtXFx1MTBDNVxcdTEwQzdcXHUxMENEXFx1MTNBMC1cXHUxM0Y1XFx1MUUwMFxcdTFFMDJcXHUxRTA0XFx1MUUwNlxcdTFFMDhcXHUxRTBBXFx1MUUwQ1xcdTFFMEVcXHUxRTEwXFx1MUUxMlxcdTFFMTRcXHUxRTE2XFx1MUUxOFxcdTFFMUFcXHUxRTFDXFx1MUUxRVxcdTFFMjBcXHUxRTIyXFx1MUUyNFxcdTFFMjZcXHUxRTI4XFx1MUUyQVxcdTFFMkNcXHUxRTJFXFx1MUUzMFxcdTFFMzJcXHUxRTM0XFx1MUUzNlxcdTFFMzhcXHUxRTNBXFx1MUUzQ1xcdTFFM0VcXHUxRTQwXFx1MUU0MlxcdTFFNDRcXHUxRTQ2XFx1MUU0OFxcdTFFNEFcXHUxRTRDXFx1MUU0RVxcdTFFNTBcXHUxRTUyXFx1MUU1NFxcdTFFNTZcXHUxRTU4XFx1MUU1QVxcdTFFNUNcXHUxRTVFXFx1MUU2MFxcdTFFNjJcXHUxRTY0XFx1MUU2NlxcdTFFNjhcXHUxRTZBXFx1MUU2Q1xcdTFFNkVcXHUxRTcwXFx1MUU3MlxcdTFFNzRcXHUxRTc2XFx1MUU3OFxcdTFFN0FcXHUxRTdDXFx1MUU3RVxcdTFFODBcXHUxRTgyXFx1MUU4NFxcdTFFODZcXHUxRTg4XFx1MUU4QVxcdTFFOENcXHUxRThFXFx1MUU5MFxcdTFFOTJcXHUxRTk0XFx1MUU5RVxcdTFFQTBcXHUxRUEyXFx1MUVBNFxcdTFFQTZcXHUxRUE4XFx1MUVBQVxcdTFFQUNcXHUxRUFFXFx1MUVCMFxcdTFFQjJcXHUxRUI0XFx1MUVCNlxcdTFFQjhcXHUxRUJBXFx1MUVCQ1xcdTFFQkVcXHUxRUMwXFx1MUVDMlxcdTFFQzRcXHUxRUM2XFx1MUVDOFxcdTFFQ0FcXHUxRUNDXFx1MUVDRVxcdTFFRDBcXHUxRUQyXFx1MUVENFxcdTFFRDZcXHUxRUQ4XFx1MUVEQVxcdTFFRENcXHUxRURFXFx1MUVFMFxcdTFFRTJcXHUxRUU0XFx1MUVFNlxcdTFFRThcXHUxRUVBXFx1MUVFQ1xcdTFFRUVcXHUxRUYwXFx1MUVGMlxcdTFFRjRcXHUxRUY2XFx1MUVGOFxcdTFFRkFcXHUxRUZDXFx1MUVGRVxcdTFGMDgtXFx1MUYwRlxcdTFGMTgtXFx1MUYxRFxcdTFGMjgtXFx1MUYyRlxcdTFGMzgtXFx1MUYzRlxcdTFGNDgtXFx1MUY0RFxcdTFGNTlcXHUxRjVCXFx1MUY1RFxcdTFGNUZcXHUxRjY4LVxcdTFGNkZcXHUxRkI4LVxcdTFGQkJcXHUxRkM4LVxcdTFGQ0JcXHUxRkQ4LVxcdTFGREJcXHUxRkU4LVxcdTFGRUNcXHUxRkY4LVxcdTFGRkJcXHUyMTAyXFx1MjEwN1xcdTIxMEItXFx1MjEwRFxcdTIxMTAtXFx1MjExMlxcdTIxMTVcXHUyMTE5LVxcdTIxMURcXHUyMTI0XFx1MjEyNlxcdTIxMjhcXHUyMTJBLVxcdTIxMkRcXHUyMTMwLVxcdTIxMzNcXHUyMTNFXFx1MjEzRlxcdTIxNDVcXHUyMTgzXFx1MkMwMC1cXHUyQzJFXFx1MkM2MFxcdTJDNjItXFx1MkM2NFxcdTJDNjdcXHUyQzY5XFx1MkM2QlxcdTJDNkQtXFx1MkM3MFxcdTJDNzJcXHUyQzc1XFx1MkM3RS1cXHUyQzgwXFx1MkM4MlxcdTJDODRcXHUyQzg2XFx1MkM4OFxcdTJDOEFcXHUyQzhDXFx1MkM4RVxcdTJDOTBcXHUyQzkyXFx1MkM5NFxcdTJDOTZcXHUyQzk4XFx1MkM5QVxcdTJDOUNcXHUyQzlFXFx1MkNBMFxcdTJDQTJcXHUyQ0E0XFx1MkNBNlxcdTJDQThcXHUyQ0FBXFx1MkNBQ1xcdTJDQUVcXHUyQ0IwXFx1MkNCMlxcdTJDQjRcXHUyQ0I2XFx1MkNCOFxcdTJDQkFcXHUyQ0JDXFx1MkNCRVxcdTJDQzBcXHUyQ0MyXFx1MkNDNFxcdTJDQzZcXHUyQ0M4XFx1MkNDQVxcdTJDQ0NcXHUyQ0NFXFx1MkNEMFxcdTJDRDJcXHUyQ0Q0XFx1MkNENlxcdTJDRDhcXHUyQ0RBXFx1MkNEQ1xcdTJDREVcXHUyQ0UwXFx1MkNFMlxcdTJDRUJcXHUyQ0VEXFx1MkNGMlxcdUE2NDBcXHVBNjQyXFx1QTY0NFxcdUE2NDZcXHVBNjQ4XFx1QTY0QVxcdUE2NENcXHVBNjRFXFx1QTY1MFxcdUE2NTJcXHVBNjU0XFx1QTY1NlxcdUE2NThcXHVBNjVBXFx1QTY1Q1xcdUE2NUVcXHVBNjYwXFx1QTY2MlxcdUE2NjRcXHVBNjY2XFx1QTY2OFxcdUE2NkFcXHVBNjZDXFx1QTY4MFxcdUE2ODJcXHVBNjg0XFx1QTY4NlxcdUE2ODhcXHVBNjhBXFx1QTY4Q1xcdUE2OEVcXHVBNjkwXFx1QTY5MlxcdUE2OTRcXHVBNjk2XFx1QTY5OFxcdUE2OUFcXHVBNzIyXFx1QTcyNFxcdUE3MjZcXHVBNzI4XFx1QTcyQVxcdUE3MkNcXHVBNzJFXFx1QTczMlxcdUE3MzRcXHVBNzM2XFx1QTczOFxcdUE3M0FcXHVBNzNDXFx1QTczRVxcdUE3NDBcXHVBNzQyXFx1QTc0NFxcdUE3NDZcXHVBNzQ4XFx1QTc0QVxcdUE3NENcXHVBNzRFXFx1QTc1MFxcdUE3NTJcXHVBNzU0XFx1QTc1NlxcdUE3NThcXHVBNzVBXFx1QTc1Q1xcdUE3NUVcXHVBNzYwXFx1QTc2MlxcdUE3NjRcXHVBNzY2XFx1QTc2OFxcdUE3NkFcXHVBNzZDXFx1QTc2RVxcdUE3NzlcXHVBNzdCXFx1QTc3RFxcdUE3N0VcXHVBNzgwXFx1QTc4MlxcdUE3ODRcXHVBNzg2XFx1QTc4QlxcdUE3OERcXHVBNzkwXFx1QTc5MlxcdUE3OTZcXHVBNzk4XFx1QTc5QVxcdUE3OUNcXHVBNzlFXFx1QTdBMFxcdUE3QTJcXHVBN0E0XFx1QTdBNlxcdUE3QThcXHVBN0FBLVxcdUE3QURcXHVBN0IwLVxcdUE3QjRcXHVBN0I2XFx1RkYyMS1cXHVGRjNBJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDZbXFx1RENBMC1cXHVEQ0JGXXxcXHVEODAzW1xcdURDODAtXFx1RENCMl18XFx1RDgwMVtcXHVEQzAwLVxcdURDMjddfFxcdUQ4MzVbXFx1REMwMC1cXHVEQzE5XFx1REMzNC1cXHVEQzREXFx1REM2OC1cXHVEQzgxXFx1REM5Q1xcdURDOUVcXHVEQzlGXFx1RENBMlxcdURDQTVcXHVEQ0E2XFx1RENBOS1cXHVEQ0FDXFx1RENBRS1cXHVEQ0I1XFx1RENEMC1cXHVEQ0U5XFx1REQwNFxcdUREMDVcXHVERDA3LVxcdUREMEFcXHVERDBELVxcdUREMTRcXHVERDE2LVxcdUREMUNcXHVERDM4XFx1REQzOVxcdUREM0ItXFx1REQzRVxcdURENDAtXFx1REQ0NFxcdURENDZcXHVERDRBLVxcdURENTBcXHVERDZDLVxcdUREODVcXHVEREEwLVxcdUREQjlcXHVEREQ0LVxcdURERURcXHVERTA4LVxcdURFMjFcXHVERTNDLVxcdURFNTVcXHVERTcwLVxcdURFODlcXHVERUE4LVxcdURFQzBcXHVERUUyLVxcdURFRkFcXHVERjFDLVxcdURGMzRcXHVERjU2LVxcdURGNkVcXHVERjkwLVxcdURGQThcXHVERkNBXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ00nLFxuICAgICAgICAgICAgYWxpYXM6ICdNYXJrJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTAzMDAtXFx1MDM2RlxcdTA0ODMtXFx1MDQ4OVxcdTA1OTEtXFx1MDVCRFxcdTA1QkZcXHUwNUMxXFx1MDVDMlxcdTA1QzRcXHUwNUM1XFx1MDVDN1xcdTA2MTAtXFx1MDYxQVxcdTA2NEItXFx1MDY1RlxcdTA2NzBcXHUwNkQ2LVxcdTA2RENcXHUwNkRGLVxcdTA2RTRcXHUwNkU3XFx1MDZFOFxcdTA2RUEtXFx1MDZFRFxcdTA3MTFcXHUwNzMwLVxcdTA3NEFcXHUwN0E2LVxcdTA3QjBcXHUwN0VCLVxcdTA3RjNcXHUwODE2LVxcdTA4MTlcXHUwODFCLVxcdTA4MjNcXHUwODI1LVxcdTA4MjdcXHUwODI5LVxcdTA4MkRcXHUwODU5LVxcdTA4NUJcXHUwOEUzLVxcdTA5MDNcXHUwOTNBLVxcdTA5M0NcXHUwOTNFLVxcdTA5NEZcXHUwOTUxLVxcdTA5NTdcXHUwOTYyXFx1MDk2M1xcdTA5ODEtXFx1MDk4M1xcdTA5QkNcXHUwOUJFLVxcdTA5QzRcXHUwOUM3XFx1MDlDOFxcdTA5Q0ItXFx1MDlDRFxcdTA5RDdcXHUwOUUyXFx1MDlFM1xcdTBBMDEtXFx1MEEwM1xcdTBBM0NcXHUwQTNFLVxcdTBBNDJcXHUwQTQ3XFx1MEE0OFxcdTBBNEItXFx1MEE0RFxcdTBBNTFcXHUwQTcwXFx1MEE3MVxcdTBBNzVcXHUwQTgxLVxcdTBBODNcXHUwQUJDXFx1MEFCRS1cXHUwQUM1XFx1MEFDNy1cXHUwQUM5XFx1MEFDQi1cXHUwQUNEXFx1MEFFMlxcdTBBRTNcXHUwQjAxLVxcdTBCMDNcXHUwQjNDXFx1MEIzRS1cXHUwQjQ0XFx1MEI0N1xcdTBCNDhcXHUwQjRCLVxcdTBCNERcXHUwQjU2XFx1MEI1N1xcdTBCNjJcXHUwQjYzXFx1MEI4MlxcdTBCQkUtXFx1MEJDMlxcdTBCQzYtXFx1MEJDOFxcdTBCQ0EtXFx1MEJDRFxcdTBCRDdcXHUwQzAwLVxcdTBDMDNcXHUwQzNFLVxcdTBDNDRcXHUwQzQ2LVxcdTBDNDhcXHUwQzRBLVxcdTBDNERcXHUwQzU1XFx1MEM1NlxcdTBDNjJcXHUwQzYzXFx1MEM4MS1cXHUwQzgzXFx1MENCQ1xcdTBDQkUtXFx1MENDNFxcdTBDQzYtXFx1MENDOFxcdTBDQ0EtXFx1MENDRFxcdTBDRDVcXHUwQ0Q2XFx1MENFMlxcdTBDRTNcXHUwRDAxLVxcdTBEMDNcXHUwRDNFLVxcdTBENDRcXHUwRDQ2LVxcdTBENDhcXHUwRDRBLVxcdTBENERcXHUwRDU3XFx1MEQ2MlxcdTBENjNcXHUwRDgyXFx1MEQ4M1xcdTBEQ0FcXHUwRENGLVxcdTBERDRcXHUwREQ2XFx1MEREOC1cXHUwRERGXFx1MERGMlxcdTBERjNcXHUwRTMxXFx1MEUzNC1cXHUwRTNBXFx1MEU0Ny1cXHUwRTRFXFx1MEVCMVxcdTBFQjQtXFx1MEVCOVxcdTBFQkJcXHUwRUJDXFx1MEVDOC1cXHUwRUNEXFx1MEYxOFxcdTBGMTlcXHUwRjM1XFx1MEYzN1xcdTBGMzlcXHUwRjNFXFx1MEYzRlxcdTBGNzEtXFx1MEY4NFxcdTBGODZcXHUwRjg3XFx1MEY4RC1cXHUwRjk3XFx1MEY5OS1cXHUwRkJDXFx1MEZDNlxcdTEwMkItXFx1MTAzRVxcdTEwNTYtXFx1MTA1OVxcdTEwNUUtXFx1MTA2MFxcdTEwNjItXFx1MTA2NFxcdTEwNjctXFx1MTA2RFxcdTEwNzEtXFx1MTA3NFxcdTEwODItXFx1MTA4RFxcdTEwOEZcXHUxMDlBLVxcdTEwOURcXHUxMzVELVxcdTEzNUZcXHUxNzEyLVxcdTE3MTRcXHUxNzMyLVxcdTE3MzRcXHUxNzUyXFx1MTc1M1xcdTE3NzJcXHUxNzczXFx1MTdCNC1cXHUxN0QzXFx1MTdERFxcdTE4MEItXFx1MTgwRFxcdTE4QTlcXHUxOTIwLVxcdTE5MkJcXHUxOTMwLVxcdTE5M0JcXHUxQTE3LVxcdTFBMUJcXHUxQTU1LVxcdTFBNUVcXHUxQTYwLVxcdTFBN0NcXHUxQTdGXFx1MUFCMC1cXHUxQUJFXFx1MUIwMC1cXHUxQjA0XFx1MUIzNC1cXHUxQjQ0XFx1MUI2Qi1cXHUxQjczXFx1MUI4MC1cXHUxQjgyXFx1MUJBMS1cXHUxQkFEXFx1MUJFNi1cXHUxQkYzXFx1MUMyNC1cXHUxQzM3XFx1MUNEMC1cXHUxQ0QyXFx1MUNENC1cXHUxQ0U4XFx1MUNFRFxcdTFDRjItXFx1MUNGNFxcdTFDRjhcXHUxQ0Y5XFx1MURDMC1cXHUxREY1XFx1MURGQy1cXHUxREZGXFx1MjBEMC1cXHUyMEYwXFx1MkNFRi1cXHUyQ0YxXFx1MkQ3RlxcdTJERTAtXFx1MkRGRlxcdTMwMkEtXFx1MzAyRlxcdTMwOTlcXHUzMDlBXFx1QTY2Ri1cXHVBNjcyXFx1QTY3NC1cXHVBNjdEXFx1QTY5RVxcdUE2OUZcXHVBNkYwXFx1QTZGMVxcdUE4MDJcXHVBODA2XFx1QTgwQlxcdUE4MjMtXFx1QTgyN1xcdUE4ODBcXHVBODgxXFx1QThCNC1cXHVBOEM0XFx1QThFMC1cXHVBOEYxXFx1QTkyNi1cXHVBOTJEXFx1QTk0Ny1cXHVBOTUzXFx1QTk4MC1cXHVBOTgzXFx1QTlCMy1cXHVBOUMwXFx1QTlFNVxcdUFBMjktXFx1QUEzNlxcdUFBNDNcXHVBQTRDXFx1QUE0RFxcdUFBN0ItXFx1QUE3RFxcdUFBQjBcXHVBQUIyLVxcdUFBQjRcXHVBQUI3XFx1QUFCOFxcdUFBQkVcXHVBQUJGXFx1QUFDMVxcdUFBRUItXFx1QUFFRlxcdUFBRjVcXHVBQUY2XFx1QUJFMy1cXHVBQkVBXFx1QUJFQ1xcdUFCRURcXHVGQjFFXFx1RkUwMC1cXHVGRTBGXFx1RkUyMC1cXHVGRTJGJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDVbXFx1RENCMC1cXHVEQ0MzXFx1RERBRi1cXHVEREI1XFx1RERCOC1cXHVEREMwXFx1REREQ1xcdURERERcXHVERTMwLVxcdURFNDBcXHVERUFCLVxcdURFQjdcXHVERjFELVxcdURGMkJdfFxcdUQ4MzRbXFx1REQ2NS1cXHVERDY5XFx1REQ2RC1cXHVERDcyXFx1REQ3Qi1cXHVERDgyXFx1REQ4NS1cXHVERDhCXFx1RERBQS1cXHVEREFEXFx1REU0Mi1cXHVERTQ0XXxcXHVEODA0W1xcdURDMDAtXFx1REMwMlxcdURDMzgtXFx1REM0NlxcdURDN0YtXFx1REM4MlxcdURDQjAtXFx1RENCQVxcdUREMDAtXFx1REQwMlxcdUREMjctXFx1REQzNFxcdURENzNcXHVERDgwLVxcdUREODJcXHVEREIzLVxcdUREQzBcXHVERENBLVxcdUREQ0NcXHVERTJDLVxcdURFMzdcXHVERURGLVxcdURFRUFcXHVERjAwLVxcdURGMDNcXHVERjNDXFx1REYzRS1cXHVERjQ0XFx1REY0N1xcdURGNDhcXHVERjRCLVxcdURGNERcXHVERjU3XFx1REY2MlxcdURGNjNcXHVERjY2LVxcdURGNkNcXHVERjcwLVxcdURGNzRdfFxcdUQ4MUJbXFx1REY1MS1cXHVERjdFXFx1REY4Ri1cXHVERjkyXXxcXHVEODFBW1xcdURFRjAtXFx1REVGNFxcdURGMzAtXFx1REYzNl18XFx1RDgyRltcXHVEQzlEXFx1REM5RV18XFx1RDgwMFtcXHVEREZEXFx1REVFMFxcdURGNzYtXFx1REY3QV18XFx1RDgzNltcXHVERTAwLVxcdURFMzZcXHVERTNCLVxcdURFNkNcXHVERTc1XFx1REU4NFxcdURFOUItXFx1REU5RlxcdURFQTEtXFx1REVBRl18XFx1RDgwMltcXHVERTAxLVxcdURFMDNcXHVERTA1XFx1REUwNlxcdURFMEMtXFx1REUwRlxcdURFMzgtXFx1REUzQVxcdURFM0ZcXHVERUU1XFx1REVFNl18XFx1RDgzQVtcXHVEQ0QwLVxcdURDRDZdfFxcdURCNDBbXFx1REQwMC1cXHVEREVGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ01jJyxcbiAgICAgICAgICAgIGFsaWFzOiAnU3BhY2luZ19NYXJrJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTA5MDNcXHUwOTNCXFx1MDkzRS1cXHUwOTQwXFx1MDk0OS1cXHUwOTRDXFx1MDk0RVxcdTA5NEZcXHUwOTgyXFx1MDk4M1xcdTA5QkUtXFx1MDlDMFxcdTA5QzdcXHUwOUM4XFx1MDlDQlxcdTA5Q0NcXHUwOUQ3XFx1MEEwM1xcdTBBM0UtXFx1MEE0MFxcdTBBODNcXHUwQUJFLVxcdTBBQzBcXHUwQUM5XFx1MEFDQlxcdTBBQ0NcXHUwQjAyXFx1MEIwM1xcdTBCM0VcXHUwQjQwXFx1MEI0N1xcdTBCNDhcXHUwQjRCXFx1MEI0Q1xcdTBCNTdcXHUwQkJFXFx1MEJCRlxcdTBCQzFcXHUwQkMyXFx1MEJDNi1cXHUwQkM4XFx1MEJDQS1cXHUwQkNDXFx1MEJEN1xcdTBDMDEtXFx1MEMwM1xcdTBDNDEtXFx1MEM0NFxcdTBDODJcXHUwQzgzXFx1MENCRVxcdTBDQzAtXFx1MENDNFxcdTBDQzdcXHUwQ0M4XFx1MENDQVxcdTBDQ0JcXHUwQ0Q1XFx1MENENlxcdTBEMDJcXHUwRDAzXFx1MEQzRS1cXHUwRDQwXFx1MEQ0Ni1cXHUwRDQ4XFx1MEQ0QS1cXHUwRDRDXFx1MEQ1N1xcdTBEODJcXHUwRDgzXFx1MERDRi1cXHUwREQxXFx1MEREOC1cXHUwRERGXFx1MERGMlxcdTBERjNcXHUwRjNFXFx1MEYzRlxcdTBGN0ZcXHUxMDJCXFx1MTAyQ1xcdTEwMzFcXHUxMDM4XFx1MTAzQlxcdTEwM0NcXHUxMDU2XFx1MTA1N1xcdTEwNjItXFx1MTA2NFxcdTEwNjctXFx1MTA2RFxcdTEwODNcXHUxMDg0XFx1MTA4Ny1cXHUxMDhDXFx1MTA4RlxcdTEwOUEtXFx1MTA5Q1xcdTE3QjZcXHUxN0JFLVxcdTE3QzVcXHUxN0M3XFx1MTdDOFxcdTE5MjMtXFx1MTkyNlxcdTE5MjktXFx1MTkyQlxcdTE5MzBcXHUxOTMxXFx1MTkzMy1cXHUxOTM4XFx1MUExOVxcdTFBMUFcXHUxQTU1XFx1MUE1N1xcdTFBNjFcXHUxQTYzXFx1MUE2NFxcdTFBNkQtXFx1MUE3MlxcdTFCMDRcXHUxQjM1XFx1MUIzQlxcdTFCM0QtXFx1MUI0MVxcdTFCNDNcXHUxQjQ0XFx1MUI4MlxcdTFCQTFcXHUxQkE2XFx1MUJBN1xcdTFCQUFcXHUxQkU3XFx1MUJFQS1cXHUxQkVDXFx1MUJFRVxcdTFCRjJcXHUxQkYzXFx1MUMyNC1cXHUxQzJCXFx1MUMzNFxcdTFDMzVcXHUxQ0UxXFx1MUNGMlxcdTFDRjNcXHUzMDJFXFx1MzAyRlxcdUE4MjNcXHVBODI0XFx1QTgyN1xcdUE4ODBcXHVBODgxXFx1QThCNC1cXHVBOEMzXFx1QTk1MlxcdUE5NTNcXHVBOTgzXFx1QTlCNFxcdUE5QjVcXHVBOUJBXFx1QTlCQlxcdUE5QkQtXFx1QTlDMFxcdUFBMkZcXHVBQTMwXFx1QUEzM1xcdUFBMzRcXHVBQTREXFx1QUE3QlxcdUFBN0RcXHVBQUVCXFx1QUFFRVxcdUFBRUZcXHVBQUY1XFx1QUJFM1xcdUFCRTRcXHVBQkU2XFx1QUJFN1xcdUFCRTlcXHVBQkVBXFx1QUJFQycsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODM0W1xcdURENjVcXHVERDY2XFx1REQ2RC1cXHVERDcyXXxcXHVEODA0W1xcdURDMDBcXHVEQzAyXFx1REM4MlxcdURDQjAtXFx1RENCMlxcdURDQjdcXHVEQ0I4XFx1REQyQ1xcdUREODJcXHVEREIzLVxcdUREQjVcXHVEREJGXFx1RERDMFxcdURFMkMtXFx1REUyRVxcdURFMzJcXHVERTMzXFx1REUzNVxcdURFRTAtXFx1REVFMlxcdURGMDJcXHVERjAzXFx1REYzRVxcdURGM0ZcXHVERjQxLVxcdURGNDRcXHVERjQ3XFx1REY0OFxcdURGNEItXFx1REY0RFxcdURGNTdcXHVERjYyXFx1REY2M118XFx1RDgwNVtcXHVEQ0IwLVxcdURDQjJcXHVEQ0I5XFx1RENCQi1cXHVEQ0JFXFx1RENDMVxcdUREQUYtXFx1RERCMVxcdUREQjgtXFx1RERCQlxcdUREQkVcXHVERTMwLVxcdURFMzJcXHVERTNCXFx1REUzQ1xcdURFM0VcXHVERUFDXFx1REVBRVxcdURFQUZcXHVERUI2XFx1REYyMFxcdURGMjFcXHVERjI2XXxcXHVEODFCW1xcdURGNTEtXFx1REY3RV0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdNZScsXG4gICAgICAgICAgICBhbGlhczogJ0VuY2xvc2luZ19NYXJrJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTA0ODhcXHUwNDg5XFx1MUFCRVxcdTIwREQtXFx1MjBFMFxcdTIwRTItXFx1MjBFNFxcdUE2NzAtXFx1QTY3MidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ01uJyxcbiAgICAgICAgICAgIGFsaWFzOiAnTm9uc3BhY2luZ19NYXJrJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTAzMDAtXFx1MDM2RlxcdTA0ODMtXFx1MDQ4N1xcdTA1OTEtXFx1MDVCRFxcdTA1QkZcXHUwNUMxXFx1MDVDMlxcdTA1QzRcXHUwNUM1XFx1MDVDN1xcdTA2MTAtXFx1MDYxQVxcdTA2NEItXFx1MDY1RlxcdTA2NzBcXHUwNkQ2LVxcdTA2RENcXHUwNkRGLVxcdTA2RTRcXHUwNkU3XFx1MDZFOFxcdTA2RUEtXFx1MDZFRFxcdTA3MTFcXHUwNzMwLVxcdTA3NEFcXHUwN0E2LVxcdTA3QjBcXHUwN0VCLVxcdTA3RjNcXHUwODE2LVxcdTA4MTlcXHUwODFCLVxcdTA4MjNcXHUwODI1LVxcdTA4MjdcXHUwODI5LVxcdTA4MkRcXHUwODU5LVxcdTA4NUJcXHUwOEUzLVxcdTA5MDJcXHUwOTNBXFx1MDkzQ1xcdTA5NDEtXFx1MDk0OFxcdTA5NERcXHUwOTUxLVxcdTA5NTdcXHUwOTYyXFx1MDk2M1xcdTA5ODFcXHUwOUJDXFx1MDlDMS1cXHUwOUM0XFx1MDlDRFxcdTA5RTJcXHUwOUUzXFx1MEEwMVxcdTBBMDJcXHUwQTNDXFx1MEE0MVxcdTBBNDJcXHUwQTQ3XFx1MEE0OFxcdTBBNEItXFx1MEE0RFxcdTBBNTFcXHUwQTcwXFx1MEE3MVxcdTBBNzVcXHUwQTgxXFx1MEE4MlxcdTBBQkNcXHUwQUMxLVxcdTBBQzVcXHUwQUM3XFx1MEFDOFxcdTBBQ0RcXHUwQUUyXFx1MEFFM1xcdTBCMDFcXHUwQjNDXFx1MEIzRlxcdTBCNDEtXFx1MEI0NFxcdTBCNERcXHUwQjU2XFx1MEI2MlxcdTBCNjNcXHUwQjgyXFx1MEJDMFxcdTBCQ0RcXHUwQzAwXFx1MEMzRS1cXHUwQzQwXFx1MEM0Ni1cXHUwQzQ4XFx1MEM0QS1cXHUwQzREXFx1MEM1NVxcdTBDNTZcXHUwQzYyXFx1MEM2M1xcdTBDODFcXHUwQ0JDXFx1MENCRlxcdTBDQzZcXHUwQ0NDXFx1MENDRFxcdTBDRTJcXHUwQ0UzXFx1MEQwMVxcdTBENDEtXFx1MEQ0NFxcdTBENERcXHUwRDYyXFx1MEQ2M1xcdTBEQ0FcXHUwREQyLVxcdTBERDRcXHUwREQ2XFx1MEUzMVxcdTBFMzQtXFx1MEUzQVxcdTBFNDctXFx1MEU0RVxcdTBFQjFcXHUwRUI0LVxcdTBFQjlcXHUwRUJCXFx1MEVCQ1xcdTBFQzgtXFx1MEVDRFxcdTBGMThcXHUwRjE5XFx1MEYzNVxcdTBGMzdcXHUwRjM5XFx1MEY3MS1cXHUwRjdFXFx1MEY4MC1cXHUwRjg0XFx1MEY4NlxcdTBGODdcXHUwRjhELVxcdTBGOTdcXHUwRjk5LVxcdTBGQkNcXHUwRkM2XFx1MTAyRC1cXHUxMDMwXFx1MTAzMi1cXHUxMDM3XFx1MTAzOVxcdTEwM0FcXHUxMDNEXFx1MTAzRVxcdTEwNThcXHUxMDU5XFx1MTA1RS1cXHUxMDYwXFx1MTA3MS1cXHUxMDc0XFx1MTA4MlxcdTEwODVcXHUxMDg2XFx1MTA4RFxcdTEwOURcXHUxMzVELVxcdTEzNUZcXHUxNzEyLVxcdTE3MTRcXHUxNzMyLVxcdTE3MzRcXHUxNzUyXFx1MTc1M1xcdTE3NzJcXHUxNzczXFx1MTdCNFxcdTE3QjVcXHUxN0I3LVxcdTE3QkRcXHUxN0M2XFx1MTdDOS1cXHUxN0QzXFx1MTdERFxcdTE4MEItXFx1MTgwRFxcdTE4QTlcXHUxOTIwLVxcdTE5MjJcXHUxOTI3XFx1MTkyOFxcdTE5MzJcXHUxOTM5LVxcdTE5M0JcXHUxQTE3XFx1MUExOFxcdTFBMUJcXHUxQTU2XFx1MUE1OC1cXHUxQTVFXFx1MUE2MFxcdTFBNjJcXHUxQTY1LVxcdTFBNkNcXHUxQTczLVxcdTFBN0NcXHUxQTdGXFx1MUFCMC1cXHUxQUJEXFx1MUIwMC1cXHUxQjAzXFx1MUIzNFxcdTFCMzYtXFx1MUIzQVxcdTFCM0NcXHUxQjQyXFx1MUI2Qi1cXHUxQjczXFx1MUI4MFxcdTFCODFcXHUxQkEyLVxcdTFCQTVcXHUxQkE4XFx1MUJBOVxcdTFCQUItXFx1MUJBRFxcdTFCRTZcXHUxQkU4XFx1MUJFOVxcdTFCRURcXHUxQkVGLVxcdTFCRjFcXHUxQzJDLVxcdTFDMzNcXHUxQzM2XFx1MUMzN1xcdTFDRDAtXFx1MUNEMlxcdTFDRDQtXFx1MUNFMFxcdTFDRTItXFx1MUNFOFxcdTFDRURcXHUxQ0Y0XFx1MUNGOFxcdTFDRjlcXHUxREMwLVxcdTFERjVcXHUxREZDLVxcdTFERkZcXHUyMEQwLVxcdTIwRENcXHUyMEUxXFx1MjBFNS1cXHUyMEYwXFx1MkNFRi1cXHUyQ0YxXFx1MkQ3RlxcdTJERTAtXFx1MkRGRlxcdTMwMkEtXFx1MzAyRFxcdTMwOTlcXHUzMDlBXFx1QTY2RlxcdUE2NzQtXFx1QTY3RFxcdUE2OUVcXHVBNjlGXFx1QTZGMFxcdUE2RjFcXHVBODAyXFx1QTgwNlxcdUE4MEJcXHVBODI1XFx1QTgyNlxcdUE4QzRcXHVBOEUwLVxcdUE4RjFcXHVBOTI2LVxcdUE5MkRcXHVBOTQ3LVxcdUE5NTFcXHVBOTgwLVxcdUE5ODJcXHVBOUIzXFx1QTlCNi1cXHVBOUI5XFx1QTlCQ1xcdUE5RTVcXHVBQTI5LVxcdUFBMkVcXHVBQTMxXFx1QUEzMlxcdUFBMzVcXHVBQTM2XFx1QUE0M1xcdUFBNENcXHVBQTdDXFx1QUFCMFxcdUFBQjItXFx1QUFCNFxcdUFBQjdcXHVBQUI4XFx1QUFCRVxcdUFBQkZcXHVBQUMxXFx1QUFFQ1xcdUFBRURcXHVBQUY2XFx1QUJFNVxcdUFCRThcXHVBQkVEXFx1RkIxRVxcdUZFMDAtXFx1RkUwRlxcdUZFMjAtXFx1RkUyRicsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODA1W1xcdURDQjMtXFx1RENCOFxcdURDQkFcXHVEQ0JGXFx1RENDMFxcdURDQzJcXHVEQ0MzXFx1RERCMi1cXHVEREI1XFx1RERCQ1xcdUREQkRcXHVEREJGXFx1RERDMFxcdURERENcXHVEREREXFx1REUzMy1cXHVERTNBXFx1REUzRFxcdURFM0ZcXHVERTQwXFx1REVBQlxcdURFQURcXHVERUIwLVxcdURFQjVcXHVERUI3XFx1REYxRC1cXHVERjFGXFx1REYyMi1cXHVERjI1XFx1REYyNy1cXHVERjJCXXxcXHVEODM0W1xcdURENjctXFx1REQ2OVxcdUREN0ItXFx1REQ4MlxcdUREODUtXFx1REQ4QlxcdUREQUEtXFx1RERBRFxcdURFNDItXFx1REU0NF18XFx1RDgxQVtcXHVERUYwLVxcdURFRjRcXHVERjMwLVxcdURGMzZdfFxcdUQ4MUJbXFx1REY4Ri1cXHVERjkyXXxcXHVEODJGW1xcdURDOURcXHVEQzlFXXxcXHVEODAwW1xcdURERkRcXHVERUUwXFx1REY3Ni1cXHVERjdBXXxcXHVEODM2W1xcdURFMDAtXFx1REUzNlxcdURFM0ItXFx1REU2Q1xcdURFNzVcXHVERTg0XFx1REU5Qi1cXHVERTlGXFx1REVBMS1cXHVERUFGXXxcXHVEODAyW1xcdURFMDEtXFx1REUwM1xcdURFMDVcXHVERTA2XFx1REUwQy1cXHVERTBGXFx1REUzOC1cXHVERTNBXFx1REUzRlxcdURFRTVcXHVERUU2XXxcXHVEODA0W1xcdURDMDFcXHVEQzM4LVxcdURDNDZcXHVEQzdGLVxcdURDODFcXHVEQ0IzLVxcdURDQjZcXHVEQ0I5XFx1RENCQVxcdUREMDAtXFx1REQwMlxcdUREMjctXFx1REQyQlxcdUREMkQtXFx1REQzNFxcdURENzNcXHVERDgwXFx1REQ4MVxcdUREQjYtXFx1RERCRVxcdUREQ0EtXFx1RERDQ1xcdURFMkYtXFx1REUzMVxcdURFMzRcXHVERTM2XFx1REUzN1xcdURFREZcXHVERUUzLVxcdURFRUFcXHVERjAwXFx1REYwMVxcdURGM0NcXHVERjQwXFx1REY2Ni1cXHVERjZDXFx1REY3MC1cXHVERjc0XXxcXHVEODNBW1xcdURDRDAtXFx1RENENl18XFx1REI0MFtcXHVERDAwLVxcdURERUZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnTicsXG4gICAgICAgICAgICBhbGlhczogJ051bWJlcicsXG4gICAgICAgICAgICBibXA6ICcwLTlcXHhCMlxceEIzXFx4QjlcXHhCQy1cXHhCRVxcdTA2NjAtXFx1MDY2OVxcdTA2RjAtXFx1MDZGOVxcdTA3QzAtXFx1MDdDOVxcdTA5NjYtXFx1MDk2RlxcdTA5RTYtXFx1MDlFRlxcdTA5RjQtXFx1MDlGOVxcdTBBNjYtXFx1MEE2RlxcdTBBRTYtXFx1MEFFRlxcdTBCNjYtXFx1MEI2RlxcdTBCNzItXFx1MEI3N1xcdTBCRTYtXFx1MEJGMlxcdTBDNjYtXFx1MEM2RlxcdTBDNzgtXFx1MEM3RVxcdTBDRTYtXFx1MENFRlxcdTBENjYtXFx1MEQ3NVxcdTBERTYtXFx1MERFRlxcdTBFNTAtXFx1MEU1OVxcdTBFRDAtXFx1MEVEOVxcdTBGMjAtXFx1MEYzM1xcdTEwNDAtXFx1MTA0OVxcdTEwOTAtXFx1MTA5OVxcdTEzNjktXFx1MTM3Q1xcdTE2RUUtXFx1MTZGMFxcdTE3RTAtXFx1MTdFOVxcdTE3RjAtXFx1MTdGOVxcdTE4MTAtXFx1MTgxOVxcdTE5NDYtXFx1MTk0RlxcdTE5RDAtXFx1MTlEQVxcdTFBODAtXFx1MUE4OVxcdTFBOTAtXFx1MUE5OVxcdTFCNTAtXFx1MUI1OVxcdTFCQjAtXFx1MUJCOVxcdTFDNDAtXFx1MUM0OVxcdTFDNTAtXFx1MUM1OVxcdTIwNzBcXHUyMDc0LVxcdTIwNzlcXHUyMDgwLVxcdTIwODlcXHUyMTUwLVxcdTIxODJcXHUyMTg1LVxcdTIxODlcXHUyNDYwLVxcdTI0OUJcXHUyNEVBLVxcdTI0RkZcXHUyNzc2LVxcdTI3OTNcXHUyQ0ZEXFx1MzAwN1xcdTMwMjEtXFx1MzAyOVxcdTMwMzgtXFx1MzAzQVxcdTMxOTItXFx1MzE5NVxcdTMyMjAtXFx1MzIyOVxcdTMyNDgtXFx1MzI0RlxcdTMyNTEtXFx1MzI1RlxcdTMyODAtXFx1MzI4OVxcdTMyQjEtXFx1MzJCRlxcdUE2MjAtXFx1QTYyOVxcdUE2RTYtXFx1QTZFRlxcdUE4MzAtXFx1QTgzNVxcdUE4RDAtXFx1QThEOVxcdUE5MDAtXFx1QTkwOVxcdUE5RDAtXFx1QTlEOVxcdUE5RjAtXFx1QTlGOVxcdUFBNTAtXFx1QUE1OVxcdUFCRjAtXFx1QUJGOVxcdUZGMTAtXFx1RkYxOScsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAwW1xcdUREMDctXFx1REQzM1xcdURENDAtXFx1REQ3OFxcdUREOEFcXHVERDhCXFx1REVFMS1cXHVERUZCXFx1REYyMC1cXHVERjIzXFx1REY0MVxcdURGNEFcXHVERkQxLVxcdURGRDVdfFxcdUQ4MDFbXFx1RENBMC1cXHVEQ0E5XXxcXHVEODAzW1xcdURDRkEtXFx1RENGRlxcdURFNjAtXFx1REU3RV18XFx1RDgzNVtcXHVERkNFLVxcdURGRkZdfFxcdUQ4M0FbXFx1RENDNy1cXHVEQ0NGXXxcXHVEODFBW1xcdURFNjAtXFx1REU2OVxcdURGNTAtXFx1REY1OVxcdURGNUItXFx1REY2MV18XFx1RDgwNltcXHVEQ0UwLVxcdURDRjJdfFxcdUQ4MDRbXFx1REM1Mi1cXHVEQzZGXFx1RENGMC1cXHVEQ0Y5XFx1REQzNi1cXHVERDNGXFx1REREMC1cXHVEREQ5XFx1RERFMS1cXHVEREY0XFx1REVGMC1cXHVERUY5XXxcXHVEODM0W1xcdURGNjAtXFx1REY3MV18XFx1RDgzQ1tcXHVERDAwLVxcdUREMENdfFxcdUQ4MDlbXFx1REMwMC1cXHVEQzZFXXxcXHVEODAyW1xcdURDNTgtXFx1REM1RlxcdURDNzktXFx1REM3RlxcdURDQTctXFx1RENBRlxcdURDRkItXFx1RENGRlxcdUREMTYtXFx1REQxQlxcdUREQkNcXHVEREJEXFx1RERDMC1cXHVERENGXFx1REREMi1cXHVEREZGXFx1REU0MC1cXHVERTQ3XFx1REU3RFxcdURFN0VcXHVERTlELVxcdURFOUZcXHVERUVCLVxcdURFRUZcXHVERjU4LVxcdURGNUZcXHVERjc4LVxcdURGN0ZcXHVERkE5LVxcdURGQUZdfFxcdUQ4MDVbXFx1RENEMC1cXHVEQ0Q5XFx1REU1MC1cXHVERTU5XFx1REVDMC1cXHVERUM5XFx1REYzMC1cXHVERjNCXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ05kJyxcbiAgICAgICAgICAgIGFsaWFzOiAnRGVjaW1hbF9OdW1iZXInLFxuICAgICAgICAgICAgYm1wOiAnMC05XFx1MDY2MC1cXHUwNjY5XFx1MDZGMC1cXHUwNkY5XFx1MDdDMC1cXHUwN0M5XFx1MDk2Ni1cXHUwOTZGXFx1MDlFNi1cXHUwOUVGXFx1MEE2Ni1cXHUwQTZGXFx1MEFFNi1cXHUwQUVGXFx1MEI2Ni1cXHUwQjZGXFx1MEJFNi1cXHUwQkVGXFx1MEM2Ni1cXHUwQzZGXFx1MENFNi1cXHUwQ0VGXFx1MEQ2Ni1cXHUwRDZGXFx1MERFNi1cXHUwREVGXFx1MEU1MC1cXHUwRTU5XFx1MEVEMC1cXHUwRUQ5XFx1MEYyMC1cXHUwRjI5XFx1MTA0MC1cXHUxMDQ5XFx1MTA5MC1cXHUxMDk5XFx1MTdFMC1cXHUxN0U5XFx1MTgxMC1cXHUxODE5XFx1MTk0Ni1cXHUxOTRGXFx1MTlEMC1cXHUxOUQ5XFx1MUE4MC1cXHUxQTg5XFx1MUE5MC1cXHUxQTk5XFx1MUI1MC1cXHUxQjU5XFx1MUJCMC1cXHUxQkI5XFx1MUM0MC1cXHUxQzQ5XFx1MUM1MC1cXHUxQzU5XFx1QTYyMC1cXHVBNjI5XFx1QThEMC1cXHVBOEQ5XFx1QTkwMC1cXHVBOTA5XFx1QTlEMC1cXHVBOUQ5XFx1QTlGMC1cXHVBOUY5XFx1QUE1MC1cXHVBQTU5XFx1QUJGMC1cXHVBQkY5XFx1RkYxMC1cXHVGRjE5JyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDFbXFx1RENBMC1cXHVEQ0E5XXxcXHVEODM1W1xcdURGQ0UtXFx1REZGRl18XFx1RDgwNVtcXHVEQ0QwLVxcdURDRDlcXHVERTUwLVxcdURFNTlcXHVERUMwLVxcdURFQzlcXHVERjMwLVxcdURGMzldfFxcdUQ4MDZbXFx1RENFMC1cXHVEQ0U5XXxcXHVEODA0W1xcdURDNjYtXFx1REM2RlxcdURDRjAtXFx1RENGOVxcdUREMzYtXFx1REQzRlxcdURERDAtXFx1REREOVxcdURFRjAtXFx1REVGOV18XFx1RDgxQVtcXHVERTYwLVxcdURFNjlcXHVERjUwLVxcdURGNTldJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnTmwnLFxuICAgICAgICAgICAgYWxpYXM6ICdMZXR0ZXJfTnVtYmVyJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTE2RUUtXFx1MTZGMFxcdTIxNjAtXFx1MjE4MlxcdTIxODUtXFx1MjE4OFxcdTMwMDdcXHUzMDIxLVxcdTMwMjlcXHUzMDM4LVxcdTMwM0FcXHVBNkU2LVxcdUE2RUYnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwOVtcXHVEQzAwLVxcdURDNkVdfFxcdUQ4MDBbXFx1REQ0MC1cXHVERDc0XFx1REY0MVxcdURGNEFcXHVERkQxLVxcdURGRDVdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnTm8nLFxuICAgICAgICAgICAgYWxpYXM6ICdPdGhlcl9OdW1iZXInLFxuICAgICAgICAgICAgYm1wOiAnXFx4QjJcXHhCM1xceEI5XFx4QkMtXFx4QkVcXHUwOUY0LVxcdTA5RjlcXHUwQjcyLVxcdTBCNzdcXHUwQkYwLVxcdTBCRjJcXHUwQzc4LVxcdTBDN0VcXHUwRDcwLVxcdTBENzVcXHUwRjJBLVxcdTBGMzNcXHUxMzY5LVxcdTEzN0NcXHUxN0YwLVxcdTE3RjlcXHUxOURBXFx1MjA3MFxcdTIwNzQtXFx1MjA3OVxcdTIwODAtXFx1MjA4OVxcdTIxNTAtXFx1MjE1RlxcdTIxODlcXHUyNDYwLVxcdTI0OUJcXHUyNEVBLVxcdTI0RkZcXHUyNzc2LVxcdTI3OTNcXHUyQ0ZEXFx1MzE5Mi1cXHUzMTk1XFx1MzIyMC1cXHUzMjI5XFx1MzI0OC1cXHUzMjRGXFx1MzI1MS1cXHUzMjVGXFx1MzI4MC1cXHUzMjg5XFx1MzJCMS1cXHUzMkJGXFx1QTgzMC1cXHVBODM1JyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDRbXFx1REM1Mi1cXHVEQzY1XFx1RERFMS1cXHVEREY0XXxcXHVEODAzW1xcdURDRkEtXFx1RENGRlxcdURFNjAtXFx1REU3RV18XFx1RDgzQ1tcXHVERDAwLVxcdUREMENdfFxcdUQ4MDZbXFx1RENFQS1cXHVEQ0YyXXxcXHVEODNBW1xcdURDQzctXFx1RENDRl18XFx1RDgwMltcXHVEQzU4LVxcdURDNUZcXHVEQzc5LVxcdURDN0ZcXHVEQ0E3LVxcdURDQUZcXHVEQ0ZCLVxcdURDRkZcXHVERDE2LVxcdUREMUJcXHVEREJDXFx1RERCRFxcdUREQzAtXFx1RERDRlxcdURERDItXFx1RERGRlxcdURFNDAtXFx1REU0N1xcdURFN0RcXHVERTdFXFx1REU5RC1cXHVERTlGXFx1REVFQi1cXHVERUVGXFx1REY1OC1cXHVERjVGXFx1REY3OC1cXHVERjdGXFx1REZBOS1cXHVERkFGXXxcXHVEODA1W1xcdURGM0FcXHVERjNCXXxcXHVEODFBW1xcdURGNUItXFx1REY2MV18XFx1RDgzNFtcXHVERjYwLVxcdURGNzFdfFxcdUQ4MDBbXFx1REQwNy1cXHVERDMzXFx1REQ3NS1cXHVERDc4XFx1REQ4QVxcdUREOEJcXHVERUUxLVxcdURFRkJcXHVERjIwLVxcdURGMjNdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnUCcsXG4gICAgICAgICAgICBhbGlhczogJ1B1bmN0dWF0aW9uJyxcbiAgICAgICAgICAgIGJtcDogJ1xceDIxLVxceDIzXFx4MjUtXFxcXHgyQVxceDJDLVxceDJGXFx4M0FcXHgzQlxcXFx4M0ZcXHg0MFxcXFx4NUItXFxcXHg1RFxceDVGXFxcXHg3QlxceDdEXFx4QTFcXHhBN1xceEFCXFx4QjZcXHhCN1xceEJCXFx4QkZcXHUwMzdFXFx1MDM4N1xcdTA1NUEtXFx1MDU1RlxcdTA1ODlcXHUwNThBXFx1MDVCRVxcdTA1QzBcXHUwNUMzXFx1MDVDNlxcdTA1RjNcXHUwNUY0XFx1MDYwOVxcdTA2MEFcXHUwNjBDXFx1MDYwRFxcdTA2MUJcXHUwNjFFXFx1MDYxRlxcdTA2NkEtXFx1MDY2RFxcdTA2RDRcXHUwNzAwLVxcdTA3MERcXHUwN0Y3LVxcdTA3RjlcXHUwODMwLVxcdTA4M0VcXHUwODVFXFx1MDk2NFxcdTA5NjVcXHUwOTcwXFx1MEFGMFxcdTBERjRcXHUwRTRGXFx1MEU1QVxcdTBFNUJcXHUwRjA0LVxcdTBGMTJcXHUwRjE0XFx1MEYzQS1cXHUwRjNEXFx1MEY4NVxcdTBGRDAtXFx1MEZENFxcdTBGRDlcXHUwRkRBXFx1MTA0QS1cXHUxMDRGXFx1MTBGQlxcdTEzNjAtXFx1MTM2OFxcdTE0MDBcXHUxNjZEXFx1MTY2RVxcdTE2OUJcXHUxNjlDXFx1MTZFQi1cXHUxNkVEXFx1MTczNVxcdTE3MzZcXHUxN0Q0LVxcdTE3RDZcXHUxN0Q4LVxcdTE3REFcXHUxODAwLVxcdTE4MEFcXHUxOTQ0XFx1MTk0NVxcdTFBMUVcXHUxQTFGXFx1MUFBMC1cXHUxQUE2XFx1MUFBOC1cXHUxQUFEXFx1MUI1QS1cXHUxQjYwXFx1MUJGQy1cXHUxQkZGXFx1MUMzQi1cXHUxQzNGXFx1MUM3RVxcdTFDN0ZcXHUxQ0MwLVxcdTFDQzdcXHUxQ0QzXFx1MjAxMC1cXHUyMDI3XFx1MjAzMC1cXHUyMDQzXFx1MjA0NS1cXHUyMDUxXFx1MjA1My1cXHUyMDVFXFx1MjA3RFxcdTIwN0VcXHUyMDhEXFx1MjA4RVxcdTIzMDgtXFx1MjMwQlxcdTIzMjlcXHUyMzJBXFx1Mjc2OC1cXHUyNzc1XFx1MjdDNVxcdTI3QzZcXHUyN0U2LVxcdTI3RUZcXHUyOTgzLVxcdTI5OThcXHUyOUQ4LVxcdTI5REJcXHUyOUZDXFx1MjlGRFxcdTJDRjktXFx1MkNGQ1xcdTJDRkVcXHUyQ0ZGXFx1MkQ3MFxcdTJFMDAtXFx1MkUyRVxcdTJFMzAtXFx1MkU0MlxcdTMwMDEtXFx1MzAwM1xcdTMwMDgtXFx1MzAxMVxcdTMwMTQtXFx1MzAxRlxcdTMwMzBcXHUzMDNEXFx1MzBBMFxcdTMwRkJcXHVBNEZFXFx1QTRGRlxcdUE2MEQtXFx1QTYwRlxcdUE2NzNcXHVBNjdFXFx1QTZGMi1cXHVBNkY3XFx1QTg3NC1cXHVBODc3XFx1QThDRVxcdUE4Q0ZcXHVBOEY4LVxcdUE4RkFcXHVBOEZDXFx1QTkyRVxcdUE5MkZcXHVBOTVGXFx1QTlDMS1cXHVBOUNEXFx1QTlERVxcdUE5REZcXHVBQTVDLVxcdUFBNUZcXHVBQURFXFx1QUFERlxcdUFBRjBcXHVBQUYxXFx1QUJFQlxcdUZEM0VcXHVGRDNGXFx1RkUxMC1cXHVGRTE5XFx1RkUzMC1cXHVGRTUyXFx1RkU1NC1cXHVGRTYxXFx1RkU2M1xcdUZFNjhcXHVGRTZBXFx1RkU2QlxcdUZGMDEtXFx1RkYwM1xcdUZGMDUtXFx1RkYwQVxcdUZGMEMtXFx1RkYwRlxcdUZGMUFcXHVGRjFCXFx1RkYxRlxcdUZGMjBcXHVGRjNCLVxcdUZGM0RcXHVGRjNGXFx1RkY1QlxcdUZGNURcXHVGRjVGLVxcdUZGNjUnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMltcXHVEQzU3XFx1REQxRlxcdUREM0ZcXHVERTUwLVxcdURFNThcXHVERTdGXFx1REVGMC1cXHVERUY2XFx1REYzOS1cXHVERjNGXFx1REY5OS1cXHVERjlDXXxcXHVEODA5W1xcdURDNzAtXFx1REM3NF18XFx1RDgwNVtcXHVEQ0M2XFx1RERDMS1cXHVEREQ3XFx1REU0MS1cXHVERTQzXFx1REYzQy1cXHVERjNFXXxcXHVEODM2W1xcdURFODctXFx1REU4Ql18XFx1RDgwMVxcdURENkZ8XFx1RDgyRlxcdURDOUZ8XFx1RDgwNFtcXHVEQzQ3LVxcdURDNERcXHVEQ0JCXFx1RENCQ1xcdURDQkUtXFx1RENDMVxcdURENDAtXFx1REQ0M1xcdURENzRcXHVERDc1XFx1RERDNS1cXHVEREM5XFx1RERDRFxcdUREREJcXHVERERELVxcdUREREZcXHVERTM4LVxcdURFM0RcXHVERUE5XXxcXHVEODAwW1xcdUREMDAtXFx1REQwMlxcdURGOUZcXHVERkQwXXxcXHVEODFBW1xcdURFNkVcXHVERTZGXFx1REVGNVxcdURGMzctXFx1REYzQlxcdURGNDRdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnUGMnLFxuICAgICAgICAgICAgYWxpYXM6ICdDb25uZWN0b3JfUHVuY3R1YXRpb24nLFxuICAgICAgICAgICAgYm1wOiAnXFx4NUZcXHUyMDNGXFx1MjA0MFxcdTIwNTRcXHVGRTMzXFx1RkUzNFxcdUZFNEQtXFx1RkU0RlxcdUZGM0YnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdQZCcsXG4gICAgICAgICAgICBhbGlhczogJ0Rhc2hfUHVuY3R1YXRpb24nLFxuICAgICAgICAgICAgYm1wOiAnXFxcXHgyRFxcdTA1OEFcXHUwNUJFXFx1MTQwMFxcdTE4MDZcXHUyMDEwLVxcdTIwMTVcXHUyRTE3XFx1MkUxQVxcdTJFM0FcXHUyRTNCXFx1MkU0MFxcdTMwMUNcXHUzMDMwXFx1MzBBMFxcdUZFMzFcXHVGRTMyXFx1RkU1OFxcdUZFNjNcXHVGRjBEJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnUGUnLFxuICAgICAgICAgICAgYWxpYXM6ICdDbG9zZV9QdW5jdHVhdGlvbicsXG4gICAgICAgICAgICBibXA6ICdcXFxceDI5XFxcXHg1RFxceDdEXFx1MEYzQlxcdTBGM0RcXHUxNjlDXFx1MjA0NlxcdTIwN0VcXHUyMDhFXFx1MjMwOVxcdTIzMEJcXHUyMzJBXFx1Mjc2OVxcdTI3NkJcXHUyNzZEXFx1Mjc2RlxcdTI3NzFcXHUyNzczXFx1Mjc3NVxcdTI3QzZcXHUyN0U3XFx1MjdFOVxcdTI3RUJcXHUyN0VEXFx1MjdFRlxcdTI5ODRcXHUyOTg2XFx1Mjk4OFxcdTI5OEFcXHUyOThDXFx1Mjk4RVxcdTI5OTBcXHUyOTkyXFx1Mjk5NFxcdTI5OTZcXHUyOTk4XFx1MjlEOVxcdTI5REJcXHUyOUZEXFx1MkUyM1xcdTJFMjVcXHUyRTI3XFx1MkUyOVxcdTMwMDlcXHUzMDBCXFx1MzAwRFxcdTMwMEZcXHUzMDExXFx1MzAxNVxcdTMwMTdcXHUzMDE5XFx1MzAxQlxcdTMwMUVcXHUzMDFGXFx1RkQzRVxcdUZFMThcXHVGRTM2XFx1RkUzOFxcdUZFM0FcXHVGRTNDXFx1RkUzRVxcdUZFNDBcXHVGRTQyXFx1RkU0NFxcdUZFNDhcXHVGRTVBXFx1RkU1Q1xcdUZFNUVcXHVGRjA5XFx1RkYzRFxcdUZGNURcXHVGRjYwXFx1RkY2MydcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ1BmJyxcbiAgICAgICAgICAgIGFsaWFzOiAnRmluYWxfUHVuY3R1YXRpb24nLFxuICAgICAgICAgICAgYm1wOiAnXFx4QkJcXHUyMDE5XFx1MjAxRFxcdTIwM0FcXHUyRTAzXFx1MkUwNVxcdTJFMEFcXHUyRTBEXFx1MkUxRFxcdTJFMjEnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdQaScsXG4gICAgICAgICAgICBhbGlhczogJ0luaXRpYWxfUHVuY3R1YXRpb24nLFxuICAgICAgICAgICAgYm1wOiAnXFx4QUJcXHUyMDE4XFx1MjAxQlxcdTIwMUNcXHUyMDFGXFx1MjAzOVxcdTJFMDJcXHUyRTA0XFx1MkUwOVxcdTJFMENcXHUyRTFDXFx1MkUyMCdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ1BvJyxcbiAgICAgICAgICAgIGFsaWFzOiAnT3RoZXJfUHVuY3R1YXRpb24nLFxuICAgICAgICAgICAgYm1wOiAnXFx4MjEtXFx4MjNcXHgyNS1cXHgyN1xcXFx4MkFcXHgyQ1xcXFx4MkVcXHgyRlxceDNBXFx4M0JcXFxceDNGXFx4NDBcXFxceDVDXFx4QTFcXHhBN1xceEI2XFx4QjdcXHhCRlxcdTAzN0VcXHUwMzg3XFx1MDU1QS1cXHUwNTVGXFx1MDU4OVxcdTA1QzBcXHUwNUMzXFx1MDVDNlxcdTA1RjNcXHUwNUY0XFx1MDYwOVxcdTA2MEFcXHUwNjBDXFx1MDYwRFxcdTA2MUJcXHUwNjFFXFx1MDYxRlxcdTA2NkEtXFx1MDY2RFxcdTA2RDRcXHUwNzAwLVxcdTA3MERcXHUwN0Y3LVxcdTA3RjlcXHUwODMwLVxcdTA4M0VcXHUwODVFXFx1MDk2NFxcdTA5NjVcXHUwOTcwXFx1MEFGMFxcdTBERjRcXHUwRTRGXFx1MEU1QVxcdTBFNUJcXHUwRjA0LVxcdTBGMTJcXHUwRjE0XFx1MEY4NVxcdTBGRDAtXFx1MEZENFxcdTBGRDlcXHUwRkRBXFx1MTA0QS1cXHUxMDRGXFx1MTBGQlxcdTEzNjAtXFx1MTM2OFxcdTE2NkRcXHUxNjZFXFx1MTZFQi1cXHUxNkVEXFx1MTczNVxcdTE3MzZcXHUxN0Q0LVxcdTE3RDZcXHUxN0Q4LVxcdTE3REFcXHUxODAwLVxcdTE4MDVcXHUxODA3LVxcdTE4MEFcXHUxOTQ0XFx1MTk0NVxcdTFBMUVcXHUxQTFGXFx1MUFBMC1cXHUxQUE2XFx1MUFBOC1cXHUxQUFEXFx1MUI1QS1cXHUxQjYwXFx1MUJGQy1cXHUxQkZGXFx1MUMzQi1cXHUxQzNGXFx1MUM3RVxcdTFDN0ZcXHUxQ0MwLVxcdTFDQzdcXHUxQ0QzXFx1MjAxNlxcdTIwMTdcXHUyMDIwLVxcdTIwMjdcXHUyMDMwLVxcdTIwMzhcXHUyMDNCLVxcdTIwM0VcXHUyMDQxLVxcdTIwNDNcXHUyMDQ3LVxcdTIwNTFcXHUyMDUzXFx1MjA1NS1cXHUyMDVFXFx1MkNGOS1cXHUyQ0ZDXFx1MkNGRVxcdTJDRkZcXHUyRDcwXFx1MkUwMFxcdTJFMDFcXHUyRTA2LVxcdTJFMDhcXHUyRTBCXFx1MkUwRS1cXHUyRTE2XFx1MkUxOFxcdTJFMTlcXHUyRTFCXFx1MkUxRVxcdTJFMUZcXHUyRTJBLVxcdTJFMkVcXHUyRTMwLVxcdTJFMzlcXHUyRTNDLVxcdTJFM0ZcXHUyRTQxXFx1MzAwMS1cXHUzMDAzXFx1MzAzRFxcdTMwRkJcXHVBNEZFXFx1QTRGRlxcdUE2MEQtXFx1QTYwRlxcdUE2NzNcXHVBNjdFXFx1QTZGMi1cXHVBNkY3XFx1QTg3NC1cXHVBODc3XFx1QThDRVxcdUE4Q0ZcXHVBOEY4LVxcdUE4RkFcXHVBOEZDXFx1QTkyRVxcdUE5MkZcXHVBOTVGXFx1QTlDMS1cXHVBOUNEXFx1QTlERVxcdUE5REZcXHVBQTVDLVxcdUFBNUZcXHVBQURFXFx1QUFERlxcdUFBRjBcXHVBQUYxXFx1QUJFQlxcdUZFMTAtXFx1RkUxNlxcdUZFMTlcXHVGRTMwXFx1RkU0NVxcdUZFNDZcXHVGRTQ5LVxcdUZFNENcXHVGRTUwLVxcdUZFNTJcXHVGRTU0LVxcdUZFNTdcXHVGRTVGLVxcdUZFNjFcXHVGRTY4XFx1RkU2QVxcdUZFNkJcXHVGRjAxLVxcdUZGMDNcXHVGRjA1LVxcdUZGMDdcXHVGRjBBXFx1RkYwQ1xcdUZGMEVcXHVGRjBGXFx1RkYxQVxcdUZGMUJcXHVGRjFGXFx1RkYyMFxcdUZGM0NcXHVGRjYxXFx1RkY2NFxcdUZGNjUnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMltcXHVEQzU3XFx1REQxRlxcdUREM0ZcXHVERTUwLVxcdURFNThcXHVERTdGXFx1REVGMC1cXHVERUY2XFx1REYzOS1cXHVERjNGXFx1REY5OS1cXHVERjlDXXxcXHVEODA5W1xcdURDNzAtXFx1REM3NF18XFx1RDgwNVtcXHVEQ0M2XFx1RERDMS1cXHVEREQ3XFx1REU0MS1cXHVERTQzXFx1REYzQy1cXHVERjNFXXxcXHVEODM2W1xcdURFODctXFx1REU4Ql18XFx1RDgwMVxcdURENkZ8XFx1RDgyRlxcdURDOUZ8XFx1RDgwNFtcXHVEQzQ3LVxcdURDNERcXHVEQ0JCXFx1RENCQ1xcdURDQkUtXFx1RENDMVxcdURENDAtXFx1REQ0M1xcdURENzRcXHVERDc1XFx1RERDNS1cXHVEREM5XFx1RERDRFxcdUREREJcXHVERERELVxcdUREREZcXHVERTM4LVxcdURFM0RcXHVERUE5XXxcXHVEODAwW1xcdUREMDAtXFx1REQwMlxcdURGOUZcXHVERkQwXXxcXHVEODFBW1xcdURFNkVcXHVERTZGXFx1REVGNVxcdURGMzctXFx1REYzQlxcdURGNDRdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnUHMnLFxuICAgICAgICAgICAgYWxpYXM6ICdPcGVuX1B1bmN0dWF0aW9uJyxcbiAgICAgICAgICAgIGJtcDogJ1xcXFx4MjhcXFxceDVCXFxcXHg3QlxcdTBGM0FcXHUwRjNDXFx1MTY5QlxcdTIwMUFcXHUyMDFFXFx1MjA0NVxcdTIwN0RcXHUyMDhEXFx1MjMwOFxcdTIzMEFcXHUyMzI5XFx1Mjc2OFxcdTI3NkFcXHUyNzZDXFx1Mjc2RVxcdTI3NzBcXHUyNzcyXFx1Mjc3NFxcdTI3QzVcXHUyN0U2XFx1MjdFOFxcdTI3RUFcXHUyN0VDXFx1MjdFRVxcdTI5ODNcXHUyOTg1XFx1Mjk4N1xcdTI5ODlcXHUyOThCXFx1Mjk4RFxcdTI5OEZcXHUyOTkxXFx1Mjk5M1xcdTI5OTVcXHUyOTk3XFx1MjlEOFxcdTI5REFcXHUyOUZDXFx1MkUyMlxcdTJFMjRcXHUyRTI2XFx1MkUyOFxcdTJFNDJcXHUzMDA4XFx1MzAwQVxcdTMwMENcXHUzMDBFXFx1MzAxMFxcdTMwMTRcXHUzMDE2XFx1MzAxOFxcdTMwMUFcXHUzMDFEXFx1RkQzRlxcdUZFMTdcXHVGRTM1XFx1RkUzN1xcdUZFMzlcXHVGRTNCXFx1RkUzRFxcdUZFM0ZcXHVGRTQxXFx1RkU0M1xcdUZFNDdcXHVGRTU5XFx1RkU1QlxcdUZFNURcXHVGRjA4XFx1RkYzQlxcdUZGNUJcXHVGRjVGXFx1RkY2MidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ1MnLFxuICAgICAgICAgICAgYWxpYXM6ICdTeW1ib2wnLFxuICAgICAgICAgICAgYm1wOiAnXFxcXHgyNFxcXFx4MkJcXHgzQy1cXHgzRVxcXFx4NUVcXHg2MFxcXFx4N0NcXHg3RVxceEEyLVxceEE2XFx4QThcXHhBOVxceEFDXFx4QUUtXFx4QjFcXHhCNFxceEI4XFx4RDdcXHhGN1xcdTAyQzItXFx1MDJDNVxcdTAyRDItXFx1MDJERlxcdTAyRTUtXFx1MDJFQlxcdTAyRURcXHUwMkVGLVxcdTAyRkZcXHUwMzc1XFx1MDM4NFxcdTAzODVcXHUwM0Y2XFx1MDQ4MlxcdTA1OEQtXFx1MDU4RlxcdTA2MDYtXFx1MDYwOFxcdTA2MEJcXHUwNjBFXFx1MDYwRlxcdTA2REVcXHUwNkU5XFx1MDZGRFxcdTA2RkVcXHUwN0Y2XFx1MDlGMlxcdTA5RjNcXHUwOUZBXFx1MDlGQlxcdTBBRjFcXHUwQjcwXFx1MEJGMy1cXHUwQkZBXFx1MEM3RlxcdTBENzlcXHUwRTNGXFx1MEYwMS1cXHUwRjAzXFx1MEYxM1xcdTBGMTUtXFx1MEYxN1xcdTBGMUEtXFx1MEYxRlxcdTBGMzRcXHUwRjM2XFx1MEYzOFxcdTBGQkUtXFx1MEZDNVxcdTBGQzctXFx1MEZDQ1xcdTBGQ0VcXHUwRkNGXFx1MEZENS1cXHUwRkQ4XFx1MTA5RVxcdTEwOUZcXHUxMzkwLVxcdTEzOTlcXHUxN0RCXFx1MTk0MFxcdTE5REUtXFx1MTlGRlxcdTFCNjEtXFx1MUI2QVxcdTFCNzQtXFx1MUI3Q1xcdTFGQkRcXHUxRkJGLVxcdTFGQzFcXHUxRkNELVxcdTFGQ0ZcXHUxRkRELVxcdTFGREZcXHUxRkVELVxcdTFGRUZcXHUxRkZEXFx1MUZGRVxcdTIwNDRcXHUyMDUyXFx1MjA3QS1cXHUyMDdDXFx1MjA4QS1cXHUyMDhDXFx1MjBBMC1cXHUyMEJFXFx1MjEwMFxcdTIxMDFcXHUyMTAzLVxcdTIxMDZcXHUyMTA4XFx1MjEwOVxcdTIxMTRcXHUyMTE2LVxcdTIxMThcXHUyMTFFLVxcdTIxMjNcXHUyMTI1XFx1MjEyN1xcdTIxMjlcXHUyMTJFXFx1MjEzQVxcdTIxM0JcXHUyMTQwLVxcdTIxNDRcXHUyMTRBLVxcdTIxNERcXHUyMTRGXFx1MjE4QVxcdTIxOEJcXHUyMTkwLVxcdTIzMDdcXHUyMzBDLVxcdTIzMjhcXHUyMzJCLVxcdTIzRkFcXHUyNDAwLVxcdTI0MjZcXHUyNDQwLVxcdTI0NEFcXHUyNDlDLVxcdTI0RTlcXHUyNTAwLVxcdTI3NjdcXHUyNzk0LVxcdTI3QzRcXHUyN0M3LVxcdTI3RTVcXHUyN0YwLVxcdTI5ODJcXHUyOTk5LVxcdTI5RDdcXHUyOURDLVxcdTI5RkJcXHUyOUZFLVxcdTJCNzNcXHUyQjc2LVxcdTJCOTVcXHUyQjk4LVxcdTJCQjlcXHUyQkJELVxcdTJCQzhcXHUyQkNBLVxcdTJCRDFcXHUyQkVDLVxcdTJCRUZcXHUyQ0U1LVxcdTJDRUFcXHUyRTgwLVxcdTJFOTlcXHUyRTlCLVxcdTJFRjNcXHUyRjAwLVxcdTJGRDVcXHUyRkYwLVxcdTJGRkJcXHUzMDA0XFx1MzAxMlxcdTMwMTNcXHUzMDIwXFx1MzAzNlxcdTMwMzdcXHUzMDNFXFx1MzAzRlxcdTMwOUJcXHUzMDlDXFx1MzE5MFxcdTMxOTFcXHUzMTk2LVxcdTMxOUZcXHUzMUMwLVxcdTMxRTNcXHUzMjAwLVxcdTMyMUVcXHUzMjJBLVxcdTMyNDdcXHUzMjUwXFx1MzI2MC1cXHUzMjdGXFx1MzI4QS1cXHUzMkIwXFx1MzJDMC1cXHUzMkZFXFx1MzMwMC1cXHUzM0ZGXFx1NERDMC1cXHU0REZGXFx1QTQ5MC1cXHVBNEM2XFx1QTcwMC1cXHVBNzE2XFx1QTcyMFxcdUE3MjFcXHVBNzg5XFx1QTc4QVxcdUE4MjgtXFx1QTgyQlxcdUE4MzYtXFx1QTgzOVxcdUFBNzctXFx1QUE3OVxcdUFCNUJcXHVGQjI5XFx1RkJCMi1cXHVGQkMxXFx1RkRGQ1xcdUZERkRcXHVGRTYyXFx1RkU2NC1cXHVGRTY2XFx1RkU2OVxcdUZGMDRcXHVGRjBCXFx1RkYxQy1cXHVGRjFFXFx1RkYzRVxcdUZGNDBcXHVGRjVDXFx1RkY1RVxcdUZGRTAtXFx1RkZFNlxcdUZGRTgtXFx1RkZFRVxcdUZGRkNcXHVGRkZEJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4M0VbXFx1REMwMC1cXHVEQzBCXFx1REMxMC1cXHVEQzQ3XFx1REM1MC1cXHVEQzU5XFx1REM2MC1cXHVEQzg3XFx1REM5MC1cXHVEQ0FEXFx1REQxMC1cXHVERDE4XFx1REQ4MC1cXHVERDg0XFx1RERDMF18XFx1RDgzQ1tcXHVEQzAwLVxcdURDMkJcXHVEQzMwLVxcdURDOTNcXHVEQ0EwLVxcdURDQUVcXHVEQ0IxLVxcdURDQkZcXHVEQ0MxLVxcdURDQ0ZcXHVEQ0QxLVxcdURDRjVcXHVERDEwLVxcdUREMkVcXHVERDMwLVxcdURENkJcXHVERDcwLVxcdUREOUFcXHVEREU2LVxcdURFMDJcXHVERTEwLVxcdURFM0FcXHVERTQwLVxcdURFNDhcXHVERTUwXFx1REU1MVxcdURGMDAtXFx1REZGRl18XFx1RDgzRFtcXHVEQzAwLVxcdURENzlcXHVERDdCLVxcdUREQTNcXHVEREE1LVxcdURFRDBcXHVERUUwLVxcdURFRUNcXHVERUYwLVxcdURFRjNcXHVERjAwLVxcdURGNzNcXHVERjgwLVxcdURGRDRdfFxcdUQ4MzVbXFx1REVDMVxcdURFREJcXHVERUZCXFx1REYxNVxcdURGMzVcXHVERjRGXFx1REY2RlxcdURGODlcXHVERkE5XFx1REZDM118XFx1RDgwMFtcXHVERDM3LVxcdUREM0ZcXHVERDc5LVxcdUREODlcXHVERDhDXFx1REQ5MC1cXHVERDlCXFx1RERBMFxcdURERDAtXFx1RERGQ118XFx1RDgyRlxcdURDOUN8XFx1RDgwNVxcdURGM0Z8XFx1RDgwMltcXHVEQzc3XFx1REM3OFxcdURFQzhdfFxcdUQ4MUFbXFx1REYzQy1cXHVERjNGXFx1REY0NV18XFx1RDgzNltcXHVEQzAwLVxcdURERkZcXHVERTM3LVxcdURFM0FcXHVERTZELVxcdURFNzRcXHVERTc2LVxcdURFODNcXHVERTg1XFx1REU4Nl18XFx1RDgzNFtcXHVEQzAwLVxcdURDRjVcXHVERDAwLVxcdUREMjZcXHVERDI5LVxcdURENjRcXHVERDZBLVxcdURENkNcXHVERDgzXFx1REQ4NFxcdUREOEMtXFx1RERBOVxcdUREQUUtXFx1RERFOFxcdURFMDAtXFx1REU0MVxcdURFNDVcXHVERjAwLVxcdURGNTZdfFxcdUQ4M0JbXFx1REVGMFxcdURFRjFdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnU2MnLFxuICAgICAgICAgICAgYWxpYXM6ICdDdXJyZW5jeV9TeW1ib2wnLFxuICAgICAgICAgICAgYm1wOiAnXFxcXHgyNFxceEEyLVxceEE1XFx1MDU4RlxcdTA2MEJcXHUwOUYyXFx1MDlGM1xcdTA5RkJcXHUwQUYxXFx1MEJGOVxcdTBFM0ZcXHUxN0RCXFx1MjBBMC1cXHUyMEJFXFx1QTgzOFxcdUZERkNcXHVGRTY5XFx1RkYwNFxcdUZGRTBcXHVGRkUxXFx1RkZFNVxcdUZGRTYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdTaycsXG4gICAgICAgICAgICBhbGlhczogJ01vZGlmaWVyX1N5bWJvbCcsXG4gICAgICAgICAgICBibXA6ICdcXFxceDVFXFx4NjBcXHhBOFxceEFGXFx4QjRcXHhCOFxcdTAyQzItXFx1MDJDNVxcdTAyRDItXFx1MDJERlxcdTAyRTUtXFx1MDJFQlxcdTAyRURcXHUwMkVGLVxcdTAyRkZcXHUwMzc1XFx1MDM4NFxcdTAzODVcXHUxRkJEXFx1MUZCRi1cXHUxRkMxXFx1MUZDRC1cXHUxRkNGXFx1MUZERC1cXHUxRkRGXFx1MUZFRC1cXHUxRkVGXFx1MUZGRFxcdTFGRkVcXHUzMDlCXFx1MzA5Q1xcdUE3MDAtXFx1QTcxNlxcdUE3MjBcXHVBNzIxXFx1QTc4OVxcdUE3OEFcXHVBQjVCXFx1RkJCMi1cXHVGQkMxXFx1RkYzRVxcdUZGNDBcXHVGRkUzJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ1NtJyxcbiAgICAgICAgICAgIGFsaWFzOiAnTWF0aF9TeW1ib2wnLFxuICAgICAgICAgICAgYm1wOiAnXFxcXHgyQlxceDNDLVxceDNFXFxcXHg3Q1xceDdFXFx4QUNcXHhCMVxceEQ3XFx4RjdcXHUwM0Y2XFx1MDYwNi1cXHUwNjA4XFx1MjA0NFxcdTIwNTJcXHUyMDdBLVxcdTIwN0NcXHUyMDhBLVxcdTIwOENcXHUyMTE4XFx1MjE0MC1cXHUyMTQ0XFx1MjE0QlxcdTIxOTAtXFx1MjE5NFxcdTIxOUFcXHUyMTlCXFx1MjFBMFxcdTIxQTNcXHUyMUE2XFx1MjFBRVxcdTIxQ0VcXHUyMUNGXFx1MjFEMlxcdTIxRDRcXHUyMUY0LVxcdTIyRkZcXHUyMzIwXFx1MjMyMVxcdTIzN0NcXHUyMzlCLVxcdTIzQjNcXHUyM0RDLVxcdTIzRTFcXHUyNUI3XFx1MjVDMVxcdTI1RjgtXFx1MjVGRlxcdTI2NkZcXHUyN0MwLVxcdTI3QzRcXHUyN0M3LVxcdTI3RTVcXHUyN0YwLVxcdTI3RkZcXHUyOTAwLVxcdTI5ODJcXHUyOTk5LVxcdTI5RDdcXHUyOURDLVxcdTI5RkJcXHUyOUZFLVxcdTJBRkZcXHUyQjMwLVxcdTJCNDRcXHUyQjQ3LVxcdTJCNENcXHVGQjI5XFx1RkU2MlxcdUZFNjQtXFx1RkU2NlxcdUZGMEJcXHVGRjFDLVxcdUZGMUVcXHVGRjVDXFx1RkY1RVxcdUZGRTJcXHVGRkU5LVxcdUZGRUMnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgzQltcXHVERUYwXFx1REVGMV18XFx1RDgzNVtcXHVERUMxXFx1REVEQlxcdURFRkJcXHVERjE1XFx1REYzNVxcdURGNEZcXHVERjZGXFx1REY4OVxcdURGQTlcXHVERkMzXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ1NvJyxcbiAgICAgICAgICAgIGFsaWFzOiAnT3RoZXJfU3ltYm9sJyxcbiAgICAgICAgICAgIGJtcDogJ1xceEE2XFx4QTlcXHhBRVxceEIwXFx1MDQ4MlxcdTA1OERcXHUwNThFXFx1MDYwRVxcdTA2MEZcXHUwNkRFXFx1MDZFOVxcdTA2RkRcXHUwNkZFXFx1MDdGNlxcdTA5RkFcXHUwQjcwXFx1MEJGMy1cXHUwQkY4XFx1MEJGQVxcdTBDN0ZcXHUwRDc5XFx1MEYwMS1cXHUwRjAzXFx1MEYxM1xcdTBGMTUtXFx1MEYxN1xcdTBGMUEtXFx1MEYxRlxcdTBGMzRcXHUwRjM2XFx1MEYzOFxcdTBGQkUtXFx1MEZDNVxcdTBGQzctXFx1MEZDQ1xcdTBGQ0VcXHUwRkNGXFx1MEZENS1cXHUwRkQ4XFx1MTA5RVxcdTEwOUZcXHUxMzkwLVxcdTEzOTlcXHUxOTQwXFx1MTlERS1cXHUxOUZGXFx1MUI2MS1cXHUxQjZBXFx1MUI3NC1cXHUxQjdDXFx1MjEwMFxcdTIxMDFcXHUyMTAzLVxcdTIxMDZcXHUyMTA4XFx1MjEwOVxcdTIxMTRcXHUyMTE2XFx1MjExN1xcdTIxMUUtXFx1MjEyM1xcdTIxMjVcXHUyMTI3XFx1MjEyOVxcdTIxMkVcXHUyMTNBXFx1MjEzQlxcdTIxNEFcXHUyMTRDXFx1MjE0RFxcdTIxNEZcXHUyMThBXFx1MjE4QlxcdTIxOTUtXFx1MjE5OVxcdTIxOUMtXFx1MjE5RlxcdTIxQTFcXHUyMUEyXFx1MjFBNFxcdTIxQTVcXHUyMUE3LVxcdTIxQURcXHUyMUFGLVxcdTIxQ0RcXHUyMUQwXFx1MjFEMVxcdTIxRDNcXHUyMUQ1LVxcdTIxRjNcXHUyMzAwLVxcdTIzMDdcXHUyMzBDLVxcdTIzMUZcXHUyMzIyLVxcdTIzMjhcXHUyMzJCLVxcdTIzN0JcXHUyMzdELVxcdTIzOUFcXHUyM0I0LVxcdTIzREJcXHUyM0UyLVxcdTIzRkFcXHUyNDAwLVxcdTI0MjZcXHUyNDQwLVxcdTI0NEFcXHUyNDlDLVxcdTI0RTlcXHUyNTAwLVxcdTI1QjZcXHUyNUI4LVxcdTI1QzBcXHUyNUMyLVxcdTI1RjdcXHUyNjAwLVxcdTI2NkVcXHUyNjcwLVxcdTI3NjdcXHUyNzk0LVxcdTI3QkZcXHUyODAwLVxcdTI4RkZcXHUyQjAwLVxcdTJCMkZcXHUyQjQ1XFx1MkI0NlxcdTJCNEQtXFx1MkI3M1xcdTJCNzYtXFx1MkI5NVxcdTJCOTgtXFx1MkJCOVxcdTJCQkQtXFx1MkJDOFxcdTJCQ0EtXFx1MkJEMVxcdTJCRUMtXFx1MkJFRlxcdTJDRTUtXFx1MkNFQVxcdTJFODAtXFx1MkU5OVxcdTJFOUItXFx1MkVGM1xcdTJGMDAtXFx1MkZENVxcdTJGRjAtXFx1MkZGQlxcdTMwMDRcXHUzMDEyXFx1MzAxM1xcdTMwMjBcXHUzMDM2XFx1MzAzN1xcdTMwM0VcXHUzMDNGXFx1MzE5MFxcdTMxOTFcXHUzMTk2LVxcdTMxOUZcXHUzMUMwLVxcdTMxRTNcXHUzMjAwLVxcdTMyMUVcXHUzMjJBLVxcdTMyNDdcXHUzMjUwXFx1MzI2MC1cXHUzMjdGXFx1MzI4QS1cXHUzMkIwXFx1MzJDMC1cXHUzMkZFXFx1MzMwMC1cXHUzM0ZGXFx1NERDMC1cXHU0REZGXFx1QTQ5MC1cXHVBNEM2XFx1QTgyOC1cXHVBODJCXFx1QTgzNlxcdUE4MzdcXHVBODM5XFx1QUE3Ny1cXHVBQTc5XFx1RkRGRFxcdUZGRTRcXHVGRkU4XFx1RkZFRFxcdUZGRUVcXHVGRkZDXFx1RkZGRCcsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODNFW1xcdURDMDAtXFx1REMwQlxcdURDMTAtXFx1REM0N1xcdURDNTAtXFx1REM1OVxcdURDNjAtXFx1REM4N1xcdURDOTAtXFx1RENBRFxcdUREMTAtXFx1REQxOFxcdUREODAtXFx1REQ4NFxcdUREQzBdfFxcdUQ4M0RbXFx1REMwMC1cXHVERDc5XFx1REQ3Qi1cXHVEREEzXFx1RERBNS1cXHVERUQwXFx1REVFMC1cXHVERUVDXFx1REVGMC1cXHVERUYzXFx1REYwMC1cXHVERjczXFx1REY4MC1cXHVERkQ0XXxcXHVEODNDW1xcdURDMDAtXFx1REMyQlxcdURDMzAtXFx1REM5M1xcdURDQTAtXFx1RENBRVxcdURDQjEtXFx1RENCRlxcdURDQzEtXFx1RENDRlxcdURDRDEtXFx1RENGNVxcdUREMTAtXFx1REQyRVxcdUREMzAtXFx1REQ2QlxcdURENzAtXFx1REQ5QVxcdURERTYtXFx1REUwMlxcdURFMTAtXFx1REUzQVxcdURFNDAtXFx1REU0OFxcdURFNTBcXHVERTUxXFx1REYwMC1cXHVERkZBXXxcXHVEODAwW1xcdUREMzctXFx1REQzRlxcdURENzktXFx1REQ4OVxcdUREOENcXHVERDkwLVxcdUREOUJcXHVEREEwXFx1REREMC1cXHVEREZDXXxcXHVEODJGXFx1REM5Q3xcXHVEODA1XFx1REYzRnxcXHVEODAyW1xcdURDNzdcXHVEQzc4XFx1REVDOF18XFx1RDgxQVtcXHVERjNDLVxcdURGM0ZcXHVERjQ1XXxcXHVEODM2W1xcdURDMDAtXFx1RERGRlxcdURFMzctXFx1REUzQVxcdURFNkQtXFx1REU3NFxcdURFNzYtXFx1REU4M1xcdURFODVcXHVERTg2XXxcXHVEODM0W1xcdURDMDAtXFx1RENGNVxcdUREMDAtXFx1REQyNlxcdUREMjktXFx1REQ2NFxcdURENkEtXFx1REQ2Q1xcdUREODNcXHVERDg0XFx1REQ4Qy1cXHVEREE5XFx1RERBRS1cXHVEREU4XFx1REUwMC1cXHVERTQxXFx1REU0NVxcdURGMDAtXFx1REY1Nl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdaJyxcbiAgICAgICAgICAgIGFsaWFzOiAnU2VwYXJhdG9yJyxcbiAgICAgICAgICAgIGJtcDogJ1xceDIwXFx4QTBcXHUxNjgwXFx1MjAwMC1cXHUyMDBBXFx1MjAyOFxcdTIwMjlcXHUyMDJGXFx1MjA1RlxcdTMwMDAnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdabCcsXG4gICAgICAgICAgICBhbGlhczogJ0xpbmVfU2VwYXJhdG9yJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTIwMjgnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdacCcsXG4gICAgICAgICAgICBhbGlhczogJ1BhcmFncmFwaF9TZXBhcmF0b3InLFxuICAgICAgICAgICAgYm1wOiAnXFx1MjAyOSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ1pzJyxcbiAgICAgICAgICAgIGFsaWFzOiAnU3BhY2VfU2VwYXJhdG9yJyxcbiAgICAgICAgICAgIGJtcDogJ1xceDIwXFx4QTBcXHUxNjgwXFx1MjAwMC1cXHUyMDBBXFx1MjAyRlxcdTIwNUZcXHUzMDAwJ1xuICAgICAgICB9XG4gICAgXSk7XG5cbn0oWFJlZ0V4cCkpO1xuXG4vKiFcbiAqIFhSZWdFeHAgVW5pY29kZSBQcm9wZXJ0aWVzIDMuMC4wXG4gKiA8aHR0cDovL3hyZWdleHAuY29tLz5cbiAqIFN0ZXZlbiBMZXZpdGhhbiAoYykgMjAxMi0yMDE1IE1JVCBMaWNlbnNlXG4gKiBVbmljb2RlIGRhdGEgcHJvdmlkZWQgYnkgTWF0aGlhcyBCeW5lbnMgPGh0dHA6Ly9tYXRoaWFzYnluZW5zLmJlLz5cbiAqL1xuXG4vKipcbiAqIEFkZHMgcHJvcGVydGllcyB0byBtZWV0IHRoZSBVVFMgIzE4IExldmVsIDEgUkwxLjIgcmVxdWlyZW1lbnRzIGZvciBVbmljb2RlIHJlZ2V4IHN1cHBvcnQuIFNlZVxuICogPGh0dHA6Ly91bmljb2RlLm9yZy9yZXBvcnRzL3RyMTgvI1JMMS4yPi4gRm9sbG93aW5nIGFyZSBkZWZpbml0aW9ucyBvZiB0aGVzZSBwcm9wZXJ0aWVzIGZyb20gVUFYXG4gKiAjNDQgPGh0dHA6Ly91bmljb2RlLm9yZy9yZXBvcnRzL3RyNDQvPjpcbiAqXG4gKiAtIEFscGhhYmV0aWNcbiAqICAgQ2hhcmFjdGVycyB3aXRoIHRoZSBBbHBoYWJldGljIHByb3BlcnR5LiBHZW5lcmF0ZWQgZnJvbTogTG93ZXJjYXNlICsgVXBwZXJjYXNlICsgTHQgKyBMbSArIExvICtcbiAqICAgTmwgKyBPdGhlcl9BbHBoYWJldGljLlxuICpcbiAqIC0gRGVmYXVsdF9JZ25vcmFibGVfQ29kZV9Qb2ludFxuICogICBGb3IgcHJvZ3JhbW1hdGljIGRldGVybWluYXRpb24gb2YgZGVmYXVsdCBpZ25vcmFibGUgY29kZSBwb2ludHMuIE5ldyBjaGFyYWN0ZXJzIHRoYXQgc2hvdWxkIGJlXG4gKiAgIGlnbm9yZWQgaW4gcmVuZGVyaW5nICh1bmxlc3MgZXhwbGljaXRseSBzdXBwb3J0ZWQpIHdpbGwgYmUgYXNzaWduZWQgaW4gdGhlc2UgcmFuZ2VzLCBwZXJtaXR0aW5nXG4gKiAgIHByb2dyYW1zIHRvIGNvcnJlY3RseSBoYW5kbGUgdGhlIGRlZmF1bHQgcmVuZGVyaW5nIG9mIHN1Y2ggY2hhcmFjdGVycyB3aGVuIG5vdCBvdGhlcndpc2VcbiAqICAgc3VwcG9ydGVkLlxuICpcbiAqIC0gTG93ZXJjYXNlXG4gKiAgIENoYXJhY3RlcnMgd2l0aCB0aGUgTG93ZXJjYXNlIHByb3BlcnR5LiBHZW5lcmF0ZWQgZnJvbTogTGwgKyBPdGhlcl9Mb3dlcmNhc2UuXG4gKlxuICogLSBOb25jaGFyYWN0ZXJfQ29kZV9Qb2ludFxuICogICBDb2RlIHBvaW50cyBwZXJtYW5lbnRseSByZXNlcnZlZCBmb3IgaW50ZXJuYWwgdXNlLlxuICpcbiAqIC0gVXBwZXJjYXNlXG4gKiAgIENoYXJhY3RlcnMgd2l0aCB0aGUgVXBwZXJjYXNlIHByb3BlcnR5LiBHZW5lcmF0ZWQgZnJvbTogTHUgKyBPdGhlcl9VcHBlcmNhc2UuXG4gKlxuICogLSBXaGl0ZV9TcGFjZVxuICogICBTcGFjZXMsIHNlcGFyYXRvciBjaGFyYWN0ZXJzIGFuZCBvdGhlciBjb250cm9sIGNoYXJhY3RlcnMgd2hpY2ggc2hvdWxkIGJlIHRyZWF0ZWQgYnlcbiAqICAgcHJvZ3JhbW1pbmcgbGFuZ3VhZ2VzIGFzIFwid2hpdGUgc3BhY2VcIiBmb3IgdGhlIHB1cnBvc2Ugb2YgcGFyc2luZyBlbGVtZW50cy5cbiAqXG4gKiBUaGUgcHJvcGVydGllcyBBU0NJSSwgQW55LCBhbmQgQXNzaWduZWQgYXJlIGFsc28gaW5jbHVkZWQgYnV0IGFyZSBub3QgZGVmaW5lZCBpbiBVQVggIzQ0LiBVVFMgIzE4XG4gKiBSTDEuMiBhZGRpdGlvbmFsbHkgcmVxdWlyZXMgc3VwcG9ydCBmb3IgVW5pY29kZSBzY3JpcHRzIGFuZCBnZW5lcmFsIGNhdGVnb3JpZXMuIFRoZXNlIGFyZVxuICogaW5jbHVkZWQgaW4gWFJlZ0V4cCdzIFVuaWNvZGUgQ2F0ZWdvcmllcyBhbmQgVW5pY29kZSBTY3JpcHRzIGFkZG9ucy5cbiAqXG4gKiBUb2tlbiBuYW1lcyBhcmUgY2FzZSBpbnNlbnNpdGl2ZSwgYW5kIGFueSBzcGFjZXMsIGh5cGhlbnMsIGFuZCB1bmRlcnNjb3JlcyBhcmUgaWdub3JlZC5cbiAqXG4gKiBVc2VzIFVuaWNvZGUgOC4wLjAuXG4gKlxuICogQHJlcXVpcmVzIFhSZWdFeHAsIFVuaWNvZGUgQmFzZVxuICovXG4oZnVuY3Rpb24oWFJlZ0V4cCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGlmICghWFJlZ0V4cC5hZGRVbmljb2RlRGF0YSkge1xuICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoJ1VuaWNvZGUgQmFzZSBtdXN0IGJlIGxvYWRlZCBiZWZvcmUgVW5pY29kZSBQcm9wZXJ0aWVzJyk7XG4gICAgfVxuXG4gICAgdmFyIHVuaWNvZGVEYXRhID0gW1xuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnQVNDSUknLFxuICAgICAgICAgICAgYm1wOiAnXFwwLVxceDdGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnQWxwaGFiZXRpYycsXG4gICAgICAgICAgICBibXA6ICdBLVphLXpcXHhBQVxceEI1XFx4QkFcXHhDMC1cXHhENlxceEQ4LVxceEY2XFx4RjgtXFx1MDJDMVxcdTAyQzYtXFx1MDJEMVxcdTAyRTAtXFx1MDJFNFxcdTAyRUNcXHUwMkVFXFx1MDM0NVxcdTAzNzAtXFx1MDM3NFxcdTAzNzZcXHUwMzc3XFx1MDM3QS1cXHUwMzdEXFx1MDM3RlxcdTAzODZcXHUwMzg4LVxcdTAzOEFcXHUwMzhDXFx1MDM4RS1cXHUwM0ExXFx1MDNBMy1cXHUwM0Y1XFx1MDNGNy1cXHUwNDgxXFx1MDQ4QS1cXHUwNTJGXFx1MDUzMS1cXHUwNTU2XFx1MDU1OVxcdTA1NjEtXFx1MDU4N1xcdTA1QjAtXFx1MDVCRFxcdTA1QkZcXHUwNUMxXFx1MDVDMlxcdTA1QzRcXHUwNUM1XFx1MDVDN1xcdTA1RDAtXFx1MDVFQVxcdTA1RjAtXFx1MDVGMlxcdTA2MTAtXFx1MDYxQVxcdTA2MjAtXFx1MDY1N1xcdTA2NTktXFx1MDY1RlxcdTA2NkUtXFx1MDZEM1xcdTA2RDUtXFx1MDZEQ1xcdTA2RTEtXFx1MDZFOFxcdTA2RUQtXFx1MDZFRlxcdTA2RkEtXFx1MDZGQ1xcdTA2RkZcXHUwNzEwLVxcdTA3M0ZcXHUwNzRELVxcdTA3QjFcXHUwN0NBLVxcdTA3RUFcXHUwN0Y0XFx1MDdGNVxcdTA3RkFcXHUwODAwLVxcdTA4MTdcXHUwODFBLVxcdTA4MkNcXHUwODQwLVxcdTA4NThcXHUwOEEwLVxcdTA4QjRcXHUwOEUzLVxcdTA4RTlcXHUwOEYwLVxcdTA5M0JcXHUwOTNELVxcdTA5NENcXHUwOTRFLVxcdTA5NTBcXHUwOTU1LVxcdTA5NjNcXHUwOTcxLVxcdTA5ODNcXHUwOTg1LVxcdTA5OENcXHUwOThGXFx1MDk5MFxcdTA5OTMtXFx1MDlBOFxcdTA5QUEtXFx1MDlCMFxcdTA5QjJcXHUwOUI2LVxcdTA5QjlcXHUwOUJELVxcdTA5QzRcXHUwOUM3XFx1MDlDOFxcdTA5Q0JcXHUwOUNDXFx1MDlDRVxcdTA5RDdcXHUwOURDXFx1MDlERFxcdTA5REYtXFx1MDlFM1xcdTA5RjBcXHUwOUYxXFx1MEEwMS1cXHUwQTAzXFx1MEEwNS1cXHUwQTBBXFx1MEEwRlxcdTBBMTBcXHUwQTEzLVxcdTBBMjhcXHUwQTJBLVxcdTBBMzBcXHUwQTMyXFx1MEEzM1xcdTBBMzVcXHUwQTM2XFx1MEEzOFxcdTBBMzlcXHUwQTNFLVxcdTBBNDJcXHUwQTQ3XFx1MEE0OFxcdTBBNEJcXHUwQTRDXFx1MEE1MVxcdTBBNTktXFx1MEE1Q1xcdTBBNUVcXHUwQTcwLVxcdTBBNzVcXHUwQTgxLVxcdTBBODNcXHUwQTg1LVxcdTBBOERcXHUwQThGLVxcdTBBOTFcXHUwQTkzLVxcdTBBQThcXHUwQUFBLVxcdTBBQjBcXHUwQUIyXFx1MEFCM1xcdTBBQjUtXFx1MEFCOVxcdTBBQkQtXFx1MEFDNVxcdTBBQzctXFx1MEFDOVxcdTBBQ0JcXHUwQUNDXFx1MEFEMFxcdTBBRTAtXFx1MEFFM1xcdTBBRjlcXHUwQjAxLVxcdTBCMDNcXHUwQjA1LVxcdTBCMENcXHUwQjBGXFx1MEIxMFxcdTBCMTMtXFx1MEIyOFxcdTBCMkEtXFx1MEIzMFxcdTBCMzJcXHUwQjMzXFx1MEIzNS1cXHUwQjM5XFx1MEIzRC1cXHUwQjQ0XFx1MEI0N1xcdTBCNDhcXHUwQjRCXFx1MEI0Q1xcdTBCNTZcXHUwQjU3XFx1MEI1Q1xcdTBCNURcXHUwQjVGLVxcdTBCNjNcXHUwQjcxXFx1MEI4MlxcdTBCODNcXHUwQjg1LVxcdTBCOEFcXHUwQjhFLVxcdTBCOTBcXHUwQjkyLVxcdTBCOTVcXHUwQjk5XFx1MEI5QVxcdTBCOUNcXHUwQjlFXFx1MEI5RlxcdTBCQTNcXHUwQkE0XFx1MEJBOC1cXHUwQkFBXFx1MEJBRS1cXHUwQkI5XFx1MEJCRS1cXHUwQkMyXFx1MEJDNi1cXHUwQkM4XFx1MEJDQS1cXHUwQkNDXFx1MEJEMFxcdTBCRDdcXHUwQzAwLVxcdTBDMDNcXHUwQzA1LVxcdTBDMENcXHUwQzBFLVxcdTBDMTBcXHUwQzEyLVxcdTBDMjhcXHUwQzJBLVxcdTBDMzlcXHUwQzNELVxcdTBDNDRcXHUwQzQ2LVxcdTBDNDhcXHUwQzRBLVxcdTBDNENcXHUwQzU1XFx1MEM1NlxcdTBDNTgtXFx1MEM1QVxcdTBDNjAtXFx1MEM2M1xcdTBDODEtXFx1MEM4M1xcdTBDODUtXFx1MEM4Q1xcdTBDOEUtXFx1MEM5MFxcdTBDOTItXFx1MENBOFxcdTBDQUEtXFx1MENCM1xcdTBDQjUtXFx1MENCOVxcdTBDQkQtXFx1MENDNFxcdTBDQzYtXFx1MENDOFxcdTBDQ0EtXFx1MENDQ1xcdTBDRDVcXHUwQ0Q2XFx1MENERVxcdTBDRTAtXFx1MENFM1xcdTBDRjFcXHUwQ0YyXFx1MEQwMS1cXHUwRDAzXFx1MEQwNS1cXHUwRDBDXFx1MEQwRS1cXHUwRDEwXFx1MEQxMi1cXHUwRDNBXFx1MEQzRC1cXHUwRDQ0XFx1MEQ0Ni1cXHUwRDQ4XFx1MEQ0QS1cXHUwRDRDXFx1MEQ0RVxcdTBENTdcXHUwRDVGLVxcdTBENjNcXHUwRDdBLVxcdTBEN0ZcXHUwRDgyXFx1MEQ4M1xcdTBEODUtXFx1MEQ5NlxcdTBEOUEtXFx1MERCMVxcdTBEQjMtXFx1MERCQlxcdTBEQkRcXHUwREMwLVxcdTBEQzZcXHUwRENGLVxcdTBERDRcXHUwREQ2XFx1MEREOC1cXHUwRERGXFx1MERGMlxcdTBERjNcXHUwRTAxLVxcdTBFM0FcXHUwRTQwLVxcdTBFNDZcXHUwRTREXFx1MEU4MVxcdTBFODJcXHUwRTg0XFx1MEU4N1xcdTBFODhcXHUwRThBXFx1MEU4RFxcdTBFOTQtXFx1MEU5N1xcdTBFOTktXFx1MEU5RlxcdTBFQTEtXFx1MEVBM1xcdTBFQTVcXHUwRUE3XFx1MEVBQVxcdTBFQUJcXHUwRUFELVxcdTBFQjlcXHUwRUJCLVxcdTBFQkRcXHUwRUMwLVxcdTBFQzRcXHUwRUM2XFx1MEVDRFxcdTBFREMtXFx1MEVERlxcdTBGMDBcXHUwRjQwLVxcdTBGNDdcXHUwRjQ5LVxcdTBGNkNcXHUwRjcxLVxcdTBGODFcXHUwRjg4LVxcdTBGOTdcXHUwRjk5LVxcdTBGQkNcXHUxMDAwLVxcdTEwMzZcXHUxMDM4XFx1MTAzQi1cXHUxMDNGXFx1MTA1MC1cXHUxMDYyXFx1MTA2NS1cXHUxMDY4XFx1MTA2RS1cXHUxMDg2XFx1MTA4RVxcdTEwOUNcXHUxMDlEXFx1MTBBMC1cXHUxMEM1XFx1MTBDN1xcdTEwQ0RcXHUxMEQwLVxcdTEwRkFcXHUxMEZDLVxcdTEyNDhcXHUxMjRBLVxcdTEyNERcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1QS1cXHUxMjVEXFx1MTI2MC1cXHUxMjg4XFx1MTI4QS1cXHUxMjhEXFx1MTI5MC1cXHUxMkIwXFx1MTJCMi1cXHUxMkI1XFx1MTJCOC1cXHUxMkJFXFx1MTJDMFxcdTEyQzItXFx1MTJDNVxcdTEyQzgtXFx1MTJENlxcdTEyRDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1QVxcdTEzNUZcXHUxMzgwLVxcdTEzOEZcXHUxM0EwLVxcdTEzRjVcXHUxM0Y4LVxcdTEzRkRcXHUxNDAxLVxcdTE2NkNcXHUxNjZGLVxcdTE2N0ZcXHUxNjgxLVxcdTE2OUFcXHUxNkEwLVxcdTE2RUFcXHUxNkVFLVxcdTE2RjhcXHUxNzAwLVxcdTE3MENcXHUxNzBFLVxcdTE3MTNcXHUxNzIwLVxcdTE3MzNcXHUxNzQwLVxcdTE3NTNcXHUxNzYwLVxcdTE3NkNcXHUxNzZFLVxcdTE3NzBcXHUxNzcyXFx1MTc3M1xcdTE3ODAtXFx1MTdCM1xcdTE3QjYtXFx1MTdDOFxcdTE3RDdcXHUxN0RDXFx1MTgyMC1cXHUxODc3XFx1MTg4MC1cXHUxOEFBXFx1MThCMC1cXHUxOEY1XFx1MTkwMC1cXHUxOTFFXFx1MTkyMC1cXHUxOTJCXFx1MTkzMC1cXHUxOTM4XFx1MTk1MC1cXHUxOTZEXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOUFCXFx1MTlCMC1cXHUxOUM5XFx1MUEwMC1cXHUxQTFCXFx1MUEyMC1cXHUxQTVFXFx1MUE2MS1cXHUxQTc0XFx1MUFBN1xcdTFCMDAtXFx1MUIzM1xcdTFCMzUtXFx1MUI0M1xcdTFCNDUtXFx1MUI0QlxcdTFCODAtXFx1MUJBOVxcdTFCQUMtXFx1MUJBRlxcdTFCQkEtXFx1MUJFNVxcdTFCRTctXFx1MUJGMVxcdTFDMDAtXFx1MUMzNVxcdTFDNEQtXFx1MUM0RlxcdTFDNUEtXFx1MUM3RFxcdTFDRTktXFx1MUNFQ1xcdTFDRUUtXFx1MUNGM1xcdTFDRjVcXHUxQ0Y2XFx1MUQwMC1cXHUxREJGXFx1MURFNy1cXHUxREY0XFx1MUUwMC1cXHUxRjE1XFx1MUYxOC1cXHUxRjFEXFx1MUYyMC1cXHUxRjQ1XFx1MUY0OC1cXHUxRjREXFx1MUY1MC1cXHUxRjU3XFx1MUY1OVxcdTFGNUJcXHUxRjVEXFx1MUY1Ri1cXHUxRjdEXFx1MUY4MC1cXHUxRkI0XFx1MUZCNi1cXHUxRkJDXFx1MUZCRVxcdTFGQzItXFx1MUZDNFxcdTFGQzYtXFx1MUZDQ1xcdTFGRDAtXFx1MUZEM1xcdTFGRDYtXFx1MUZEQlxcdTFGRTAtXFx1MUZFQ1xcdTFGRjItXFx1MUZGNFxcdTFGRjYtXFx1MUZGQ1xcdTIwNzFcXHUyMDdGXFx1MjA5MC1cXHUyMDlDXFx1MjEwMlxcdTIxMDdcXHUyMTBBLVxcdTIxMTNcXHUyMTE1XFx1MjExOS1cXHUyMTFEXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyQS1cXHUyMTJEXFx1MjEyRi1cXHUyMTM5XFx1MjEzQy1cXHUyMTNGXFx1MjE0NS1cXHUyMTQ5XFx1MjE0RVxcdTIxNjAtXFx1MjE4OFxcdTI0QjYtXFx1MjRFOVxcdTJDMDAtXFx1MkMyRVxcdTJDMzAtXFx1MkM1RVxcdTJDNjAtXFx1MkNFNFxcdTJDRUItXFx1MkNFRVxcdTJDRjJcXHUyQ0YzXFx1MkQwMC1cXHUyRDI1XFx1MkQyN1xcdTJEMkRcXHUyRDMwLVxcdTJENjdcXHUyRDZGXFx1MkQ4MC1cXHUyRDk2XFx1MkRBMC1cXHUyREE2XFx1MkRBOC1cXHUyREFFXFx1MkRCMC1cXHUyREI2XFx1MkRCOC1cXHUyREJFXFx1MkRDMC1cXHUyREM2XFx1MkRDOC1cXHUyRENFXFx1MkREMC1cXHUyREQ2XFx1MkREOC1cXHUyRERFXFx1MkRFMC1cXHUyREZGXFx1MkUyRlxcdTMwMDUtXFx1MzAwN1xcdTMwMjEtXFx1MzAyOVxcdTMwMzEtXFx1MzAzNVxcdTMwMzgtXFx1MzAzQ1xcdTMwNDEtXFx1MzA5NlxcdTMwOUQtXFx1MzA5RlxcdTMwQTEtXFx1MzBGQVxcdTMwRkMtXFx1MzBGRlxcdTMxMDUtXFx1MzEyRFxcdTMxMzEtXFx1MzE4RVxcdTMxQTAtXFx1MzFCQVxcdTMxRjAtXFx1MzFGRlxcdTM0MDAtXFx1NERCNVxcdTRFMDAtXFx1OUZENVxcdUEwMDAtXFx1QTQ4Q1xcdUE0RDAtXFx1QTRGRFxcdUE1MDAtXFx1QTYwQ1xcdUE2MTAtXFx1QTYxRlxcdUE2MkFcXHVBNjJCXFx1QTY0MC1cXHVBNjZFXFx1QTY3NC1cXHVBNjdCXFx1QTY3Ri1cXHVBNkVGXFx1QTcxNy1cXHVBNzFGXFx1QTcyMi1cXHVBNzg4XFx1QTc4Qi1cXHVBN0FEXFx1QTdCMC1cXHVBN0I3XFx1QTdGNy1cXHVBODAxXFx1QTgwMy1cXHVBODA1XFx1QTgwNy1cXHVBODBBXFx1QTgwQy1cXHVBODI3XFx1QTg0MC1cXHVBODczXFx1QTg4MC1cXHVBOEMzXFx1QThGMi1cXHVBOEY3XFx1QThGQlxcdUE4RkRcXHVBOTBBLVxcdUE5MkFcXHVBOTMwLVxcdUE5NTJcXHVBOTYwLVxcdUE5N0NcXHVBOTgwLVxcdUE5QjJcXHVBOUI0LVxcdUE5QkZcXHVBOUNGXFx1QTlFMC1cXHVBOUU0XFx1QTlFNi1cXHVBOUVGXFx1QTlGQS1cXHVBOUZFXFx1QUEwMC1cXHVBQTM2XFx1QUE0MC1cXHVBQTREXFx1QUE2MC1cXHVBQTc2XFx1QUE3QVxcdUFBN0UtXFx1QUFCRVxcdUFBQzBcXHVBQUMyXFx1QUFEQi1cXHVBQUREXFx1QUFFMC1cXHVBQUVGXFx1QUFGMi1cXHVBQUY1XFx1QUIwMS1cXHVBQjA2XFx1QUIwOS1cXHVBQjBFXFx1QUIxMS1cXHVBQjE2XFx1QUIyMC1cXHVBQjI2XFx1QUIyOC1cXHVBQjJFXFx1QUIzMC1cXHVBQjVBXFx1QUI1Qy1cXHVBQjY1XFx1QUI3MC1cXHVBQkVBXFx1QUMwMC1cXHVEN0EzXFx1RDdCMC1cXHVEN0M2XFx1RDdDQi1cXHVEN0ZCXFx1RjkwMC1cXHVGQTZEXFx1RkE3MC1cXHVGQUQ5XFx1RkIwMC1cXHVGQjA2XFx1RkIxMy1cXHVGQjE3XFx1RkIxRC1cXHVGQjI4XFx1RkIyQS1cXHVGQjM2XFx1RkIzOC1cXHVGQjNDXFx1RkIzRVxcdUZCNDBcXHVGQjQxXFx1RkI0M1xcdUZCNDRcXHVGQjQ2LVxcdUZCQjFcXHVGQkQzLVxcdUZEM0RcXHVGRDUwLVxcdUZEOEZcXHVGRDkyLVxcdUZEQzdcXHVGREYwLVxcdUZERkJcXHVGRTcwLVxcdUZFNzRcXHVGRTc2LVxcdUZFRkNcXHVGRjIxLVxcdUZGM0FcXHVGRjQxLVxcdUZGNUFcXHVGRjY2LVxcdUZGQkVcXHVGRkMyLVxcdUZGQzdcXHVGRkNBLVxcdUZGQ0ZcXHVGRkQyLVxcdUZGRDdcXHVGRkRBLVxcdUZGREMnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDg2RVtcXHVEQzAwLVxcdURDMURcXHVEQzIwLVxcdURGRkZdfFxcdUQ4MDRbXFx1REMwMC1cXHVEQzQ1XFx1REM4Mi1cXHVEQ0I4XFx1RENEMC1cXHVEQ0U4XFx1REQwMC1cXHVERDMyXFx1REQ1MC1cXHVERDcyXFx1REQ3NlxcdUREODAtXFx1RERCRlxcdUREQzEtXFx1RERDNFxcdUREREFcXHVERERDXFx1REUwMC1cXHVERTExXFx1REUxMy1cXHVERTM0XFx1REUzN1xcdURFODAtXFx1REU4NlxcdURFODhcXHVERThBLVxcdURFOERcXHVERThGLVxcdURFOURcXHVERTlGLVxcdURFQThcXHVERUIwLVxcdURFRThcXHVERjAwLVxcdURGMDNcXHVERjA1LVxcdURGMENcXHVERjBGXFx1REYxMFxcdURGMTMtXFx1REYyOFxcdURGMkEtXFx1REYzMFxcdURGMzJcXHVERjMzXFx1REYzNS1cXHVERjM5XFx1REYzRC1cXHVERjQ0XFx1REY0N1xcdURGNDhcXHVERjRCXFx1REY0Q1xcdURGNTBcXHVERjU3XFx1REY1RC1cXHVERjYzXXxcXHVEODZEW1xcdURDMDAtXFx1REYzNFxcdURGNDAtXFx1REZGRl18XFx1RDg2OVtcXHVEQzAwLVxcdURFRDZcXHVERjAwLVxcdURGRkZdfFxcdUQ4MDNbXFx1REMwMC1cXHVEQzQ4XFx1REM4MC1cXHVEQ0IyXFx1RENDMC1cXHVEQ0YyXXxcXHVEODNBW1xcdURDMDAtXFx1RENDNF18XFx1RDgxQVtcXHVEQzAwLVxcdURFMzhcXHVERTQwLVxcdURFNUVcXHVERUQwLVxcdURFRURcXHVERjAwLVxcdURGMzZcXHVERjQwLVxcdURGNDNcXHVERjYzLVxcdURGNzdcXHVERjdELVxcdURGOEZdfFxcdUQ4MDFbXFx1REMwMC1cXHVEQzlEXFx1REQwMC1cXHVERDI3XFx1REQzMC1cXHVERDYzXFx1REUwMC1cXHVERjM2XFx1REY0MC1cXHVERjU1XFx1REY2MC1cXHVERjY3XXxcXHVEODNDW1xcdUREMzAtXFx1REQ0OVxcdURENTAtXFx1REQ2OVxcdURENzAtXFx1REQ4OV18XFx1RDgwRFtcXHVEQzAwLVxcdURDMkVdfFxcdUQ4N0VbXFx1REMwMC1cXHVERTFEXXxbXFx1RDgwQ1xcdUQ4NDAtXFx1RDg2OFxcdUQ4NkEtXFx1RDg2Q1xcdUQ4NkYtXFx1RDg3Ml1bXFx1REMwMC1cXHVERkZGXXxcXHVEODM1W1xcdURDMDAtXFx1REM1NFxcdURDNTYtXFx1REM5Q1xcdURDOUVcXHVEQzlGXFx1RENBMlxcdURDQTVcXHVEQ0E2XFx1RENBOS1cXHVEQ0FDXFx1RENBRS1cXHVEQ0I5XFx1RENCQlxcdURDQkQtXFx1RENDM1xcdURDQzUtXFx1REQwNVxcdUREMDctXFx1REQwQVxcdUREMEQtXFx1REQxNFxcdUREMTYtXFx1REQxQ1xcdUREMUUtXFx1REQzOVxcdUREM0ItXFx1REQzRVxcdURENDAtXFx1REQ0NFxcdURENDZcXHVERDRBLVxcdURENTBcXHVERDUyLVxcdURFQTVcXHVERUE4LVxcdURFQzBcXHVERUMyLVxcdURFREFcXHVERURDLVxcdURFRkFcXHVERUZDLVxcdURGMTRcXHVERjE2LVxcdURGMzRcXHVERjM2LVxcdURGNEVcXHVERjUwLVxcdURGNkVcXHVERjcwLVxcdURGODhcXHVERjhBLVxcdURGQThcXHVERkFBLVxcdURGQzJcXHVERkM0LVxcdURGQ0JdfFxcdUQ4MkZbXFx1REMwMC1cXHVEQzZBXFx1REM3MC1cXHVEQzdDXFx1REM4MC1cXHVEQzg4XFx1REM5MC1cXHVEQzk5XFx1REM5RV18XFx1RDgwOFtcXHVEQzAwLVxcdURGOTldfFxcdUQ4M0JbXFx1REUwMC1cXHVERTAzXFx1REUwNS1cXHVERTFGXFx1REUyMVxcdURFMjJcXHVERTI0XFx1REUyN1xcdURFMjktXFx1REUzMlxcdURFMzQtXFx1REUzN1xcdURFMzlcXHVERTNCXFx1REU0MlxcdURFNDdcXHVERTQ5XFx1REU0QlxcdURFNEQtXFx1REU0RlxcdURFNTFcXHVERTUyXFx1REU1NFxcdURFNTdcXHVERTU5XFx1REU1QlxcdURFNURcXHVERTVGXFx1REU2MVxcdURFNjJcXHVERTY0XFx1REU2Ny1cXHVERTZBXFx1REU2Qy1cXHVERTcyXFx1REU3NC1cXHVERTc3XFx1REU3OS1cXHVERTdDXFx1REU3RVxcdURFODAtXFx1REU4OVxcdURFOEItXFx1REU5QlxcdURFQTEtXFx1REVBM1xcdURFQTUtXFx1REVBOVxcdURFQUItXFx1REVCQl18XFx1RDgwNVtcXHVEQzgwLVxcdURDQzFcXHVEQ0M0XFx1RENDNVxcdURDQzdcXHVERDgwLVxcdUREQjVcXHVEREI4LVxcdUREQkVcXHVEREQ4LVxcdURERERcXHVERTAwLVxcdURFM0VcXHVERTQwXFx1REU0NFxcdURFODAtXFx1REVCNVxcdURGMDAtXFx1REYxOVxcdURGMUQtXFx1REYyQV18XFx1RDgwOVtcXHVEQzAwLVxcdURDNkVcXHVEQzgwLVxcdURENDNdfFxcdUQ4MDZbXFx1RENBMC1cXHVEQ0RGXFx1RENGRlxcdURFQzAtXFx1REVGOF18XFx1RDgwMFtcXHVEQzAwLVxcdURDMEJcXHVEQzBELVxcdURDMjZcXHVEQzI4LVxcdURDM0FcXHVEQzNDXFx1REMzRFxcdURDM0YtXFx1REM0RFxcdURDNTAtXFx1REM1RFxcdURDODAtXFx1RENGQVxcdURENDAtXFx1REQ3NFxcdURFODAtXFx1REU5Q1xcdURFQTAtXFx1REVEMFxcdURGMDAtXFx1REYxRlxcdURGMzAtXFx1REY0QVxcdURGNTAtXFx1REY3QVxcdURGODAtXFx1REY5RFxcdURGQTAtXFx1REZDM1xcdURGQzgtXFx1REZDRlxcdURGRDEtXFx1REZENV18XFx1RDgwMltcXHVEQzAwLVxcdURDMDVcXHVEQzA4XFx1REMwQS1cXHVEQzM1XFx1REMzN1xcdURDMzhcXHVEQzNDXFx1REMzRi1cXHVEQzU1XFx1REM2MC1cXHVEQzc2XFx1REM4MC1cXHVEQzlFXFx1RENFMC1cXHVEQ0YyXFx1RENGNFxcdURDRjVcXHVERDAwLVxcdUREMTVcXHVERDIwLVxcdUREMzlcXHVERDgwLVxcdUREQjdcXHVEREJFXFx1RERCRlxcdURFMDAtXFx1REUwM1xcdURFMDVcXHVERTA2XFx1REUwQy1cXHVERTEzXFx1REUxNS1cXHVERTE3XFx1REUxOS1cXHVERTMzXFx1REU2MC1cXHVERTdDXFx1REU4MC1cXHVERTlDXFx1REVDMC1cXHVERUM3XFx1REVDOS1cXHVERUU0XFx1REYwMC1cXHVERjM1XFx1REY0MC1cXHVERjU1XFx1REY2MC1cXHVERjcyXFx1REY4MC1cXHVERjkxXXxcXHVEODExW1xcdURDMDAtXFx1REU0Nl18XFx1RDgyQ1tcXHVEQzAwXFx1REMwMV18XFx1RDgxQltcXHVERjAwLVxcdURGNDRcXHVERjUwLVxcdURGN0VcXHVERjkzLVxcdURGOUZdfFxcdUQ4NzNbXFx1REMwMC1cXHVERUExXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0FueScsXG4gICAgICAgICAgICBpc0JtcExhc3Q6IHRydWUsXG4gICAgICAgICAgICBibXA6ICdcXDAtXFx1RkZGRicsXG4gICAgICAgICAgICBhc3RyYWw6ICdbXFx1RDgwMC1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnRGVmYXVsdF9JZ25vcmFibGVfQ29kZV9Qb2ludCcsXG4gICAgICAgICAgICBibXA6ICdcXHhBRFxcdTAzNEZcXHUwNjFDXFx1MTE1RlxcdTExNjBcXHUxN0I0XFx1MTdCNVxcdTE4MEItXFx1MTgwRVxcdTIwMEItXFx1MjAwRlxcdTIwMkEtXFx1MjAyRVxcdTIwNjAtXFx1MjA2RlxcdTMxNjRcXHVGRTAwLVxcdUZFMEZcXHVGRUZGXFx1RkZBMFxcdUZGRjAtXFx1RkZGOCcsXG4gICAgICAgICAgICBhc3RyYWw6ICdbXFx1REI0MC1cXHVEQjQzXVtcXHVEQzAwLVxcdURGRkZdfFxcdUQ4MzRbXFx1REQ3My1cXHVERDdBXXxcXHVEODJGW1xcdURDQTAtXFx1RENBM10nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdMb3dlcmNhc2UnLFxuICAgICAgICAgICAgYm1wOiAnYS16XFx4QUFcXHhCNVxceEJBXFx4REYtXFx4RjZcXHhGOC1cXHhGRlxcdTAxMDFcXHUwMTAzXFx1MDEwNVxcdTAxMDdcXHUwMTA5XFx1MDEwQlxcdTAxMERcXHUwMTBGXFx1MDExMVxcdTAxMTNcXHUwMTE1XFx1MDExN1xcdTAxMTlcXHUwMTFCXFx1MDExRFxcdTAxMUZcXHUwMTIxXFx1MDEyM1xcdTAxMjVcXHUwMTI3XFx1MDEyOVxcdTAxMkJcXHUwMTJEXFx1MDEyRlxcdTAxMzFcXHUwMTMzXFx1MDEzNVxcdTAxMzdcXHUwMTM4XFx1MDEzQVxcdTAxM0NcXHUwMTNFXFx1MDE0MFxcdTAxNDJcXHUwMTQ0XFx1MDE0NlxcdTAxNDhcXHUwMTQ5XFx1MDE0QlxcdTAxNERcXHUwMTRGXFx1MDE1MVxcdTAxNTNcXHUwMTU1XFx1MDE1N1xcdTAxNTlcXHUwMTVCXFx1MDE1RFxcdTAxNUZcXHUwMTYxXFx1MDE2M1xcdTAxNjVcXHUwMTY3XFx1MDE2OVxcdTAxNkJcXHUwMTZEXFx1MDE2RlxcdTAxNzFcXHUwMTczXFx1MDE3NVxcdTAxNzdcXHUwMTdBXFx1MDE3Q1xcdTAxN0UtXFx1MDE4MFxcdTAxODNcXHUwMTg1XFx1MDE4OFxcdTAxOENcXHUwMThEXFx1MDE5MlxcdTAxOTVcXHUwMTk5LVxcdTAxOUJcXHUwMTlFXFx1MDFBMVxcdTAxQTNcXHUwMUE1XFx1MDFBOFxcdTAxQUFcXHUwMUFCXFx1MDFBRFxcdTAxQjBcXHUwMUI0XFx1MDFCNlxcdTAxQjlcXHUwMUJBXFx1MDFCRC1cXHUwMUJGXFx1MDFDNlxcdTAxQzlcXHUwMUNDXFx1MDFDRVxcdTAxRDBcXHUwMUQyXFx1MDFENFxcdTAxRDZcXHUwMUQ4XFx1MDFEQVxcdTAxRENcXHUwMUREXFx1MDFERlxcdTAxRTFcXHUwMUUzXFx1MDFFNVxcdTAxRTdcXHUwMUU5XFx1MDFFQlxcdTAxRURcXHUwMUVGXFx1MDFGMFxcdTAxRjNcXHUwMUY1XFx1MDFGOVxcdTAxRkJcXHUwMUZEXFx1MDFGRlxcdTAyMDFcXHUwMjAzXFx1MDIwNVxcdTAyMDdcXHUwMjA5XFx1MDIwQlxcdTAyMERcXHUwMjBGXFx1MDIxMVxcdTAyMTNcXHUwMjE1XFx1MDIxN1xcdTAyMTlcXHUwMjFCXFx1MDIxRFxcdTAyMUZcXHUwMjIxXFx1MDIyM1xcdTAyMjVcXHUwMjI3XFx1MDIyOVxcdTAyMkJcXHUwMjJEXFx1MDIyRlxcdTAyMzFcXHUwMjMzLVxcdTAyMzlcXHUwMjNDXFx1MDIzRlxcdTAyNDBcXHUwMjQyXFx1MDI0N1xcdTAyNDlcXHUwMjRCXFx1MDI0RFxcdTAyNEYtXFx1MDI5M1xcdTAyOTUtXFx1MDJCOFxcdTAyQzBcXHUwMkMxXFx1MDJFMC1cXHUwMkU0XFx1MDM0NVxcdTAzNzFcXHUwMzczXFx1MDM3N1xcdTAzN0EtXFx1MDM3RFxcdTAzOTBcXHUwM0FDLVxcdTAzQ0VcXHUwM0QwXFx1MDNEMVxcdTAzRDUtXFx1MDNEN1xcdTAzRDlcXHUwM0RCXFx1MDNERFxcdTAzREZcXHUwM0UxXFx1MDNFM1xcdTAzRTVcXHUwM0U3XFx1MDNFOVxcdTAzRUJcXHUwM0VEXFx1MDNFRi1cXHUwM0YzXFx1MDNGNVxcdTAzRjhcXHUwM0ZCXFx1MDNGQ1xcdTA0MzAtXFx1MDQ1RlxcdTA0NjFcXHUwNDYzXFx1MDQ2NVxcdTA0NjdcXHUwNDY5XFx1MDQ2QlxcdTA0NkRcXHUwNDZGXFx1MDQ3MVxcdTA0NzNcXHUwNDc1XFx1MDQ3N1xcdTA0NzlcXHUwNDdCXFx1MDQ3RFxcdTA0N0ZcXHUwNDgxXFx1MDQ4QlxcdTA0OERcXHUwNDhGXFx1MDQ5MVxcdTA0OTNcXHUwNDk1XFx1MDQ5N1xcdTA0OTlcXHUwNDlCXFx1MDQ5RFxcdTA0OUZcXHUwNEExXFx1MDRBM1xcdTA0QTVcXHUwNEE3XFx1MDRBOVxcdTA0QUJcXHUwNEFEXFx1MDRBRlxcdTA0QjFcXHUwNEIzXFx1MDRCNVxcdTA0QjdcXHUwNEI5XFx1MDRCQlxcdTA0QkRcXHUwNEJGXFx1MDRDMlxcdTA0QzRcXHUwNEM2XFx1MDRDOFxcdTA0Q0FcXHUwNENDXFx1MDRDRVxcdTA0Q0ZcXHUwNEQxXFx1MDREM1xcdTA0RDVcXHUwNEQ3XFx1MDREOVxcdTA0REJcXHUwNEREXFx1MDRERlxcdTA0RTFcXHUwNEUzXFx1MDRFNVxcdTA0RTdcXHUwNEU5XFx1MDRFQlxcdTA0RURcXHUwNEVGXFx1MDRGMVxcdTA0RjNcXHUwNEY1XFx1MDRGN1xcdTA0RjlcXHUwNEZCXFx1MDRGRFxcdTA0RkZcXHUwNTAxXFx1MDUwM1xcdTA1MDVcXHUwNTA3XFx1MDUwOVxcdTA1MEJcXHUwNTBEXFx1MDUwRlxcdTA1MTFcXHUwNTEzXFx1MDUxNVxcdTA1MTdcXHUwNTE5XFx1MDUxQlxcdTA1MURcXHUwNTFGXFx1MDUyMVxcdTA1MjNcXHUwNTI1XFx1MDUyN1xcdTA1MjlcXHUwNTJCXFx1MDUyRFxcdTA1MkZcXHUwNTYxLVxcdTA1ODdcXHUxM0Y4LVxcdTEzRkRcXHUxRDAwLVxcdTFEQkZcXHUxRTAxXFx1MUUwM1xcdTFFMDVcXHUxRTA3XFx1MUUwOVxcdTFFMEJcXHUxRTBEXFx1MUUwRlxcdTFFMTFcXHUxRTEzXFx1MUUxNVxcdTFFMTdcXHUxRTE5XFx1MUUxQlxcdTFFMURcXHUxRTFGXFx1MUUyMVxcdTFFMjNcXHUxRTI1XFx1MUUyN1xcdTFFMjlcXHUxRTJCXFx1MUUyRFxcdTFFMkZcXHUxRTMxXFx1MUUzM1xcdTFFMzVcXHUxRTM3XFx1MUUzOVxcdTFFM0JcXHUxRTNEXFx1MUUzRlxcdTFFNDFcXHUxRTQzXFx1MUU0NVxcdTFFNDdcXHUxRTQ5XFx1MUU0QlxcdTFFNERcXHUxRTRGXFx1MUU1MVxcdTFFNTNcXHUxRTU1XFx1MUU1N1xcdTFFNTlcXHUxRTVCXFx1MUU1RFxcdTFFNUZcXHUxRTYxXFx1MUU2M1xcdTFFNjVcXHUxRTY3XFx1MUU2OVxcdTFFNkJcXHUxRTZEXFx1MUU2RlxcdTFFNzFcXHUxRTczXFx1MUU3NVxcdTFFNzdcXHUxRTc5XFx1MUU3QlxcdTFFN0RcXHUxRTdGXFx1MUU4MVxcdTFFODNcXHUxRTg1XFx1MUU4N1xcdTFFODlcXHUxRThCXFx1MUU4RFxcdTFFOEZcXHUxRTkxXFx1MUU5M1xcdTFFOTUtXFx1MUU5RFxcdTFFOUZcXHUxRUExXFx1MUVBM1xcdTFFQTVcXHUxRUE3XFx1MUVBOVxcdTFFQUJcXHUxRUFEXFx1MUVBRlxcdTFFQjFcXHUxRUIzXFx1MUVCNVxcdTFFQjdcXHUxRUI5XFx1MUVCQlxcdTFFQkRcXHUxRUJGXFx1MUVDMVxcdTFFQzNcXHUxRUM1XFx1MUVDN1xcdTFFQzlcXHUxRUNCXFx1MUVDRFxcdTFFQ0ZcXHUxRUQxXFx1MUVEM1xcdTFFRDVcXHUxRUQ3XFx1MUVEOVxcdTFFREJcXHUxRUREXFx1MUVERlxcdTFFRTFcXHUxRUUzXFx1MUVFNVxcdTFFRTdcXHUxRUU5XFx1MUVFQlxcdTFFRURcXHUxRUVGXFx1MUVGMVxcdTFFRjNcXHUxRUY1XFx1MUVGN1xcdTFFRjlcXHUxRUZCXFx1MUVGRFxcdTFFRkYtXFx1MUYwN1xcdTFGMTAtXFx1MUYxNVxcdTFGMjAtXFx1MUYyN1xcdTFGMzAtXFx1MUYzN1xcdTFGNDAtXFx1MUY0NVxcdTFGNTAtXFx1MUY1N1xcdTFGNjAtXFx1MUY2N1xcdTFGNzAtXFx1MUY3RFxcdTFGODAtXFx1MUY4N1xcdTFGOTAtXFx1MUY5N1xcdTFGQTAtXFx1MUZBN1xcdTFGQjAtXFx1MUZCNFxcdTFGQjZcXHUxRkI3XFx1MUZCRVxcdTFGQzItXFx1MUZDNFxcdTFGQzZcXHUxRkM3XFx1MUZEMC1cXHUxRkQzXFx1MUZENlxcdTFGRDdcXHUxRkUwLVxcdTFGRTdcXHUxRkYyLVxcdTFGRjRcXHUxRkY2XFx1MUZGN1xcdTIwNzFcXHUyMDdGXFx1MjA5MC1cXHUyMDlDXFx1MjEwQVxcdTIxMEVcXHUyMTBGXFx1MjExM1xcdTIxMkZcXHUyMTM0XFx1MjEzOVxcdTIxM0NcXHUyMTNEXFx1MjE0Ni1cXHUyMTQ5XFx1MjE0RVxcdTIxNzAtXFx1MjE3RlxcdTIxODRcXHUyNEQwLVxcdTI0RTlcXHUyQzMwLVxcdTJDNUVcXHUyQzYxXFx1MkM2NVxcdTJDNjZcXHUyQzY4XFx1MkM2QVxcdTJDNkNcXHUyQzcxXFx1MkM3M1xcdTJDNzRcXHUyQzc2LVxcdTJDN0RcXHUyQzgxXFx1MkM4M1xcdTJDODVcXHUyQzg3XFx1MkM4OVxcdTJDOEJcXHUyQzhEXFx1MkM4RlxcdTJDOTFcXHUyQzkzXFx1MkM5NVxcdTJDOTdcXHUyQzk5XFx1MkM5QlxcdTJDOURcXHUyQzlGXFx1MkNBMVxcdTJDQTNcXHUyQ0E1XFx1MkNBN1xcdTJDQTlcXHUyQ0FCXFx1MkNBRFxcdTJDQUZcXHUyQ0IxXFx1MkNCM1xcdTJDQjVcXHUyQ0I3XFx1MkNCOVxcdTJDQkJcXHUyQ0JEXFx1MkNCRlxcdTJDQzFcXHUyQ0MzXFx1MkNDNVxcdTJDQzdcXHUyQ0M5XFx1MkNDQlxcdTJDQ0RcXHUyQ0NGXFx1MkNEMVxcdTJDRDNcXHUyQ0Q1XFx1MkNEN1xcdTJDRDlcXHUyQ0RCXFx1MkNERFxcdTJDREZcXHUyQ0UxXFx1MkNFM1xcdTJDRTRcXHUyQ0VDXFx1MkNFRVxcdTJDRjNcXHUyRDAwLVxcdTJEMjVcXHUyRDI3XFx1MkQyRFxcdUE2NDFcXHVBNjQzXFx1QTY0NVxcdUE2NDdcXHVBNjQ5XFx1QTY0QlxcdUE2NERcXHVBNjRGXFx1QTY1MVxcdUE2NTNcXHVBNjU1XFx1QTY1N1xcdUE2NTlcXHVBNjVCXFx1QTY1RFxcdUE2NUZcXHVBNjYxXFx1QTY2M1xcdUE2NjVcXHVBNjY3XFx1QTY2OVxcdUE2NkJcXHVBNjZEXFx1QTY4MVxcdUE2ODNcXHVBNjg1XFx1QTY4N1xcdUE2ODlcXHVBNjhCXFx1QTY4RFxcdUE2OEZcXHVBNjkxXFx1QTY5M1xcdUE2OTVcXHVBNjk3XFx1QTY5OVxcdUE2OUItXFx1QTY5RFxcdUE3MjNcXHVBNzI1XFx1QTcyN1xcdUE3MjlcXHVBNzJCXFx1QTcyRFxcdUE3MkYtXFx1QTczMVxcdUE3MzNcXHVBNzM1XFx1QTczN1xcdUE3MzlcXHVBNzNCXFx1QTczRFxcdUE3M0ZcXHVBNzQxXFx1QTc0M1xcdUE3NDVcXHVBNzQ3XFx1QTc0OVxcdUE3NEJcXHVBNzREXFx1QTc0RlxcdUE3NTFcXHVBNzUzXFx1QTc1NVxcdUE3NTdcXHVBNzU5XFx1QTc1QlxcdUE3NURcXHVBNzVGXFx1QTc2MVxcdUE3NjNcXHVBNzY1XFx1QTc2N1xcdUE3NjlcXHVBNzZCXFx1QTc2RFxcdUE3NkYtXFx1QTc3OFxcdUE3N0FcXHVBNzdDXFx1QTc3RlxcdUE3ODFcXHVBNzgzXFx1QTc4NVxcdUE3ODdcXHVBNzhDXFx1QTc4RVxcdUE3OTFcXHVBNzkzLVxcdUE3OTVcXHVBNzk3XFx1QTc5OVxcdUE3OUJcXHVBNzlEXFx1QTc5RlxcdUE3QTFcXHVBN0EzXFx1QTdBNVxcdUE3QTdcXHVBN0E5XFx1QTdCNVxcdUE3QjdcXHVBN0Y4LVxcdUE3RkFcXHVBQjMwLVxcdUFCNUFcXHVBQjVDLVxcdUFCNjVcXHVBQjcwLVxcdUFCQkZcXHVGQjAwLVxcdUZCMDZcXHVGQjEzLVxcdUZCMTdcXHVGRjQxLVxcdUZGNUEnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwM1tcXHVEQ0MwLVxcdURDRjJdfFxcdUQ4MzVbXFx1REMxQS1cXHVEQzMzXFx1REM0RS1cXHVEQzU0XFx1REM1Ni1cXHVEQzY3XFx1REM4Mi1cXHVEQzlCXFx1RENCNi1cXHVEQ0I5XFx1RENCQlxcdURDQkQtXFx1RENDM1xcdURDQzUtXFx1RENDRlxcdURDRUEtXFx1REQwM1xcdUREMUUtXFx1REQzN1xcdURENTItXFx1REQ2QlxcdUREODYtXFx1REQ5RlxcdUREQkEtXFx1REREM1xcdURERUUtXFx1REUwN1xcdURFMjItXFx1REUzQlxcdURFNTYtXFx1REU2RlxcdURFOEEtXFx1REVBNVxcdURFQzItXFx1REVEQVxcdURFREMtXFx1REVFMVxcdURFRkMtXFx1REYxNFxcdURGMTYtXFx1REYxQlxcdURGMzYtXFx1REY0RVxcdURGNTAtXFx1REY1NVxcdURGNzAtXFx1REY4OFxcdURGOEEtXFx1REY4RlxcdURGQUEtXFx1REZDMlxcdURGQzQtXFx1REZDOVxcdURGQ0JdfFxcdUQ4MDFbXFx1REMyOC1cXHVEQzRGXXxcXHVEODA2W1xcdURDQzAtXFx1RENERl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdOb25jaGFyYWN0ZXJfQ29kZV9Qb2ludCcsXG4gICAgICAgICAgICBibXA6ICdcXHVGREQwLVxcdUZERUZcXHVGRkZFXFx1RkZGRicsXG4gICAgICAgICAgICBhc3RyYWw6ICdbXFx1REIzRlxcdURCN0ZcXHVEQkJGXFx1REJGRlxcdUQ4M0ZcXHVEODdGXFx1RDhCRlxcdURBRkZcXHVEOTdGXFx1RDlCRlxcdUQ5RkZcXHVEQTNGXFx1RDhGRlxcdURBQkZcXHVEQTdGXFx1RDkzRl1bXFx1REZGRVxcdURGRkZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnVXBwZXJjYXNlJyxcbiAgICAgICAgICAgIGJtcDogJ0EtWlxceEMwLVxceEQ2XFx4RDgtXFx4REVcXHUwMTAwXFx1MDEwMlxcdTAxMDRcXHUwMTA2XFx1MDEwOFxcdTAxMEFcXHUwMTBDXFx1MDEwRVxcdTAxMTBcXHUwMTEyXFx1MDExNFxcdTAxMTZcXHUwMTE4XFx1MDExQVxcdTAxMUNcXHUwMTFFXFx1MDEyMFxcdTAxMjJcXHUwMTI0XFx1MDEyNlxcdTAxMjhcXHUwMTJBXFx1MDEyQ1xcdTAxMkVcXHUwMTMwXFx1MDEzMlxcdTAxMzRcXHUwMTM2XFx1MDEzOVxcdTAxM0JcXHUwMTNEXFx1MDEzRlxcdTAxNDFcXHUwMTQzXFx1MDE0NVxcdTAxNDdcXHUwMTRBXFx1MDE0Q1xcdTAxNEVcXHUwMTUwXFx1MDE1MlxcdTAxNTRcXHUwMTU2XFx1MDE1OFxcdTAxNUFcXHUwMTVDXFx1MDE1RVxcdTAxNjBcXHUwMTYyXFx1MDE2NFxcdTAxNjZcXHUwMTY4XFx1MDE2QVxcdTAxNkNcXHUwMTZFXFx1MDE3MFxcdTAxNzJcXHUwMTc0XFx1MDE3NlxcdTAxNzhcXHUwMTc5XFx1MDE3QlxcdTAxN0RcXHUwMTgxXFx1MDE4MlxcdTAxODRcXHUwMTg2XFx1MDE4N1xcdTAxODktXFx1MDE4QlxcdTAxOEUtXFx1MDE5MVxcdTAxOTNcXHUwMTk0XFx1MDE5Ni1cXHUwMTk4XFx1MDE5Q1xcdTAxOURcXHUwMTlGXFx1MDFBMFxcdTAxQTJcXHUwMUE0XFx1MDFBNlxcdTAxQTdcXHUwMUE5XFx1MDFBQ1xcdTAxQUVcXHUwMUFGXFx1MDFCMS1cXHUwMUIzXFx1MDFCNVxcdTAxQjdcXHUwMUI4XFx1MDFCQ1xcdTAxQzRcXHUwMUM3XFx1MDFDQVxcdTAxQ0RcXHUwMUNGXFx1MDFEMVxcdTAxRDNcXHUwMUQ1XFx1MDFEN1xcdTAxRDlcXHUwMURCXFx1MDFERVxcdTAxRTBcXHUwMUUyXFx1MDFFNFxcdTAxRTZcXHUwMUU4XFx1MDFFQVxcdTAxRUNcXHUwMUVFXFx1MDFGMVxcdTAxRjRcXHUwMUY2LVxcdTAxRjhcXHUwMUZBXFx1MDFGQ1xcdTAxRkVcXHUwMjAwXFx1MDIwMlxcdTAyMDRcXHUwMjA2XFx1MDIwOFxcdTAyMEFcXHUwMjBDXFx1MDIwRVxcdTAyMTBcXHUwMjEyXFx1MDIxNFxcdTAyMTZcXHUwMjE4XFx1MDIxQVxcdTAyMUNcXHUwMjFFXFx1MDIyMFxcdTAyMjJcXHUwMjI0XFx1MDIyNlxcdTAyMjhcXHUwMjJBXFx1MDIyQ1xcdTAyMkVcXHUwMjMwXFx1MDIzMlxcdTAyM0FcXHUwMjNCXFx1MDIzRFxcdTAyM0VcXHUwMjQxXFx1MDI0My1cXHUwMjQ2XFx1MDI0OFxcdTAyNEFcXHUwMjRDXFx1MDI0RVxcdTAzNzBcXHUwMzcyXFx1MDM3NlxcdTAzN0ZcXHUwMzg2XFx1MDM4OC1cXHUwMzhBXFx1MDM4Q1xcdTAzOEVcXHUwMzhGXFx1MDM5MS1cXHUwM0ExXFx1MDNBMy1cXHUwM0FCXFx1MDNDRlxcdTAzRDItXFx1MDNENFxcdTAzRDhcXHUwM0RBXFx1MDNEQ1xcdTAzREVcXHUwM0UwXFx1MDNFMlxcdTAzRTRcXHUwM0U2XFx1MDNFOFxcdTAzRUFcXHUwM0VDXFx1MDNFRVxcdTAzRjRcXHUwM0Y3XFx1MDNGOVxcdTAzRkFcXHUwM0ZELVxcdTA0MkZcXHUwNDYwXFx1MDQ2MlxcdTA0NjRcXHUwNDY2XFx1MDQ2OFxcdTA0NkFcXHUwNDZDXFx1MDQ2RVxcdTA0NzBcXHUwNDcyXFx1MDQ3NFxcdTA0NzZcXHUwNDc4XFx1MDQ3QVxcdTA0N0NcXHUwNDdFXFx1MDQ4MFxcdTA0OEFcXHUwNDhDXFx1MDQ4RVxcdTA0OTBcXHUwNDkyXFx1MDQ5NFxcdTA0OTZcXHUwNDk4XFx1MDQ5QVxcdTA0OUNcXHUwNDlFXFx1MDRBMFxcdTA0QTJcXHUwNEE0XFx1MDRBNlxcdTA0QThcXHUwNEFBXFx1MDRBQ1xcdTA0QUVcXHUwNEIwXFx1MDRCMlxcdTA0QjRcXHUwNEI2XFx1MDRCOFxcdTA0QkFcXHUwNEJDXFx1MDRCRVxcdTA0QzBcXHUwNEMxXFx1MDRDM1xcdTA0QzVcXHUwNEM3XFx1MDRDOVxcdTA0Q0JcXHUwNENEXFx1MDREMFxcdTA0RDJcXHUwNEQ0XFx1MDRENlxcdTA0RDhcXHUwNERBXFx1MDREQ1xcdTA0REVcXHUwNEUwXFx1MDRFMlxcdTA0RTRcXHUwNEU2XFx1MDRFOFxcdTA0RUFcXHUwNEVDXFx1MDRFRVxcdTA0RjBcXHUwNEYyXFx1MDRGNFxcdTA0RjZcXHUwNEY4XFx1MDRGQVxcdTA0RkNcXHUwNEZFXFx1MDUwMFxcdTA1MDJcXHUwNTA0XFx1MDUwNlxcdTA1MDhcXHUwNTBBXFx1MDUwQ1xcdTA1MEVcXHUwNTEwXFx1MDUxMlxcdTA1MTRcXHUwNTE2XFx1MDUxOFxcdTA1MUFcXHUwNTFDXFx1MDUxRVxcdTA1MjBcXHUwNTIyXFx1MDUyNFxcdTA1MjZcXHUwNTI4XFx1MDUyQVxcdTA1MkNcXHUwNTJFXFx1MDUzMS1cXHUwNTU2XFx1MTBBMC1cXHUxMEM1XFx1MTBDN1xcdTEwQ0RcXHUxM0EwLVxcdTEzRjVcXHUxRTAwXFx1MUUwMlxcdTFFMDRcXHUxRTA2XFx1MUUwOFxcdTFFMEFcXHUxRTBDXFx1MUUwRVxcdTFFMTBcXHUxRTEyXFx1MUUxNFxcdTFFMTZcXHUxRTE4XFx1MUUxQVxcdTFFMUNcXHUxRTFFXFx1MUUyMFxcdTFFMjJcXHUxRTI0XFx1MUUyNlxcdTFFMjhcXHUxRTJBXFx1MUUyQ1xcdTFFMkVcXHUxRTMwXFx1MUUzMlxcdTFFMzRcXHUxRTM2XFx1MUUzOFxcdTFFM0FcXHUxRTNDXFx1MUUzRVxcdTFFNDBcXHUxRTQyXFx1MUU0NFxcdTFFNDZcXHUxRTQ4XFx1MUU0QVxcdTFFNENcXHUxRTRFXFx1MUU1MFxcdTFFNTJcXHUxRTU0XFx1MUU1NlxcdTFFNThcXHUxRTVBXFx1MUU1Q1xcdTFFNUVcXHUxRTYwXFx1MUU2MlxcdTFFNjRcXHUxRTY2XFx1MUU2OFxcdTFFNkFcXHUxRTZDXFx1MUU2RVxcdTFFNzBcXHUxRTcyXFx1MUU3NFxcdTFFNzZcXHUxRTc4XFx1MUU3QVxcdTFFN0NcXHUxRTdFXFx1MUU4MFxcdTFFODJcXHUxRTg0XFx1MUU4NlxcdTFFODhcXHUxRThBXFx1MUU4Q1xcdTFFOEVcXHUxRTkwXFx1MUU5MlxcdTFFOTRcXHUxRTlFXFx1MUVBMFxcdTFFQTJcXHUxRUE0XFx1MUVBNlxcdTFFQThcXHUxRUFBXFx1MUVBQ1xcdTFFQUVcXHUxRUIwXFx1MUVCMlxcdTFFQjRcXHUxRUI2XFx1MUVCOFxcdTFFQkFcXHUxRUJDXFx1MUVCRVxcdTFFQzBcXHUxRUMyXFx1MUVDNFxcdTFFQzZcXHUxRUM4XFx1MUVDQVxcdTFFQ0NcXHUxRUNFXFx1MUVEMFxcdTFFRDJcXHUxRUQ0XFx1MUVENlxcdTFFRDhcXHUxRURBXFx1MUVEQ1xcdTFFREVcXHUxRUUwXFx1MUVFMlxcdTFFRTRcXHUxRUU2XFx1MUVFOFxcdTFFRUFcXHUxRUVDXFx1MUVFRVxcdTFFRjBcXHUxRUYyXFx1MUVGNFxcdTFFRjZcXHUxRUY4XFx1MUVGQVxcdTFFRkNcXHUxRUZFXFx1MUYwOC1cXHUxRjBGXFx1MUYxOC1cXHUxRjFEXFx1MUYyOC1cXHUxRjJGXFx1MUYzOC1cXHUxRjNGXFx1MUY0OC1cXHUxRjREXFx1MUY1OVxcdTFGNUJcXHUxRjVEXFx1MUY1RlxcdTFGNjgtXFx1MUY2RlxcdTFGQjgtXFx1MUZCQlxcdTFGQzgtXFx1MUZDQlxcdTFGRDgtXFx1MUZEQlxcdTFGRTgtXFx1MUZFQ1xcdTFGRjgtXFx1MUZGQlxcdTIxMDJcXHUyMTA3XFx1MjEwQi1cXHUyMTBEXFx1MjExMC1cXHUyMTEyXFx1MjExNVxcdTIxMTktXFx1MjExRFxcdTIxMjRcXHUyMTI2XFx1MjEyOFxcdTIxMkEtXFx1MjEyRFxcdTIxMzAtXFx1MjEzM1xcdTIxM0VcXHUyMTNGXFx1MjE0NVxcdTIxNjAtXFx1MjE2RlxcdTIxODNcXHUyNEI2LVxcdTI0Q0ZcXHUyQzAwLVxcdTJDMkVcXHUyQzYwXFx1MkM2Mi1cXHUyQzY0XFx1MkM2N1xcdTJDNjlcXHUyQzZCXFx1MkM2RC1cXHUyQzcwXFx1MkM3MlxcdTJDNzVcXHUyQzdFLVxcdTJDODBcXHUyQzgyXFx1MkM4NFxcdTJDODZcXHUyQzg4XFx1MkM4QVxcdTJDOENcXHUyQzhFXFx1MkM5MFxcdTJDOTJcXHUyQzk0XFx1MkM5NlxcdTJDOThcXHUyQzlBXFx1MkM5Q1xcdTJDOUVcXHUyQ0EwXFx1MkNBMlxcdTJDQTRcXHUyQ0E2XFx1MkNBOFxcdTJDQUFcXHUyQ0FDXFx1MkNBRVxcdTJDQjBcXHUyQ0IyXFx1MkNCNFxcdTJDQjZcXHUyQ0I4XFx1MkNCQVxcdTJDQkNcXHUyQ0JFXFx1MkNDMFxcdTJDQzJcXHUyQ0M0XFx1MkNDNlxcdTJDQzhcXHUyQ0NBXFx1MkNDQ1xcdTJDQ0VcXHUyQ0QwXFx1MkNEMlxcdTJDRDRcXHUyQ0Q2XFx1MkNEOFxcdTJDREFcXHUyQ0RDXFx1MkNERVxcdTJDRTBcXHUyQ0UyXFx1MkNFQlxcdTJDRURcXHUyQ0YyXFx1QTY0MFxcdUE2NDJcXHVBNjQ0XFx1QTY0NlxcdUE2NDhcXHVBNjRBXFx1QTY0Q1xcdUE2NEVcXHVBNjUwXFx1QTY1MlxcdUE2NTRcXHVBNjU2XFx1QTY1OFxcdUE2NUFcXHVBNjVDXFx1QTY1RVxcdUE2NjBcXHVBNjYyXFx1QTY2NFxcdUE2NjZcXHVBNjY4XFx1QTY2QVxcdUE2NkNcXHVBNjgwXFx1QTY4MlxcdUE2ODRcXHVBNjg2XFx1QTY4OFxcdUE2OEFcXHVBNjhDXFx1QTY4RVxcdUE2OTBcXHVBNjkyXFx1QTY5NFxcdUE2OTZcXHVBNjk4XFx1QTY5QVxcdUE3MjJcXHVBNzI0XFx1QTcyNlxcdUE3MjhcXHVBNzJBXFx1QTcyQ1xcdUE3MkVcXHVBNzMyXFx1QTczNFxcdUE3MzZcXHVBNzM4XFx1QTczQVxcdUE3M0NcXHVBNzNFXFx1QTc0MFxcdUE3NDJcXHVBNzQ0XFx1QTc0NlxcdUE3NDhcXHVBNzRBXFx1QTc0Q1xcdUE3NEVcXHVBNzUwXFx1QTc1MlxcdUE3NTRcXHVBNzU2XFx1QTc1OFxcdUE3NUFcXHVBNzVDXFx1QTc1RVxcdUE3NjBcXHVBNzYyXFx1QTc2NFxcdUE3NjZcXHVBNzY4XFx1QTc2QVxcdUE3NkNcXHVBNzZFXFx1QTc3OVxcdUE3N0JcXHVBNzdEXFx1QTc3RVxcdUE3ODBcXHVBNzgyXFx1QTc4NFxcdUE3ODZcXHVBNzhCXFx1QTc4RFxcdUE3OTBcXHVBNzkyXFx1QTc5NlxcdUE3OThcXHVBNzlBXFx1QTc5Q1xcdUE3OUVcXHVBN0EwXFx1QTdBMlxcdUE3QTRcXHVBN0E2XFx1QTdBOFxcdUE3QUEtXFx1QTdBRFxcdUE3QjAtXFx1QTdCNFxcdUE3QjZcXHVGRjIxLVxcdUZGM0EnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwNltcXHVEQ0EwLVxcdURDQkZdfFxcdUQ4MDNbXFx1REM4MC1cXHVEQ0IyXXxcXHVEODM1W1xcdURDMDAtXFx1REMxOVxcdURDMzQtXFx1REM0RFxcdURDNjgtXFx1REM4MVxcdURDOUNcXHVEQzlFXFx1REM5RlxcdURDQTJcXHVEQ0E1XFx1RENBNlxcdURDQTktXFx1RENBQ1xcdURDQUUtXFx1RENCNVxcdURDRDAtXFx1RENFOVxcdUREMDRcXHVERDA1XFx1REQwNy1cXHVERDBBXFx1REQwRC1cXHVERDE0XFx1REQxNi1cXHVERDFDXFx1REQzOFxcdUREMzlcXHVERDNCLVxcdUREM0VcXHVERDQwLVxcdURENDRcXHVERDQ2XFx1REQ0QS1cXHVERDUwXFx1REQ2Qy1cXHVERDg1XFx1RERBMC1cXHVEREI5XFx1RERENC1cXHVEREVEXFx1REUwOC1cXHVERTIxXFx1REUzQy1cXHVERTU1XFx1REU3MC1cXHVERTg5XFx1REVBOC1cXHVERUMwXFx1REVFMi1cXHVERUZBXFx1REYxQy1cXHVERjM0XFx1REY1Ni1cXHVERjZFXFx1REY5MC1cXHVERkE4XFx1REZDQV18XFx1RDgwMVtcXHVEQzAwLVxcdURDMjddfFxcdUQ4M0NbXFx1REQzMC1cXHVERDQ5XFx1REQ1MC1cXHVERDY5XFx1REQ3MC1cXHVERDg5XSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ1doaXRlX1NwYWNlJyxcbiAgICAgICAgICAgIGJtcDogJ1xceDA5LVxceDBEXFx4MjBcXHg4NVxceEEwXFx1MTY4MFxcdTIwMDAtXFx1MjAwQVxcdTIwMjhcXHUyMDI5XFx1MjAyRlxcdTIwNUZcXHUzMDAwJ1xuICAgICAgICB9XG4gICAgXTtcblxuICAgIC8vIEFkZCBub24tZ2VuZXJhdGVkIGRhdGFcbiAgICB1bmljb2RlRGF0YS5wdXNoKHtcbiAgICAgICAgbmFtZTogJ0Fzc2lnbmVkJyxcbiAgICAgICAgLy8gU2luY2UgdGhpcyBpcyBkZWZpbmVkIGFzIHRoZSBpbnZlcnNlIG9mIFVuaWNvZGUgY2F0ZWdvcnkgQ24gKFVuYXNzaWduZWQpLCB0aGUgVW5pY29kZVxuICAgICAgICAvLyBDYXRlZ29yaWVzIGFkZG9uIGlzIHJlcXVpcmVkIHRvIHVzZSB0aGlzIHByb3BlcnR5XG4gICAgICAgIGludmVyc2VPZjogJ0NuJ1xuICAgIH0pO1xuXG4gICAgWFJlZ0V4cC5hZGRVbmljb2RlRGF0YSh1bmljb2RlRGF0YSk7XG5cbn0oWFJlZ0V4cCkpO1xuXG4vKiFcbiAqIFhSZWdFeHAgVW5pY29kZSBTY3JpcHRzIDMuMC4wXG4gKiA8aHR0cDovL3hyZWdleHAuY29tLz5cbiAqIFN0ZXZlbiBMZXZpdGhhbiAoYykgMjAxMC0yMDE1IE1JVCBMaWNlbnNlXG4gKiBVbmljb2RlIGRhdGEgcHJvdmlkZWQgYnkgTWF0aGlhcyBCeW5lbnMgPGh0dHA6Ly9tYXRoaWFzYnluZW5zLmJlLz5cbiAqL1xuXG4vKipcbiAqIEFkZHMgc3VwcG9ydCBmb3IgYWxsIFVuaWNvZGUgc2NyaXB0cy4gRS5nLiwgYFxccHtMYXRpbn1gLiBUb2tlbiBuYW1lcyBhcmUgY2FzZSBpbnNlbnNpdGl2ZSwgYW5kXG4gKiBhbnkgc3BhY2VzLCBoeXBoZW5zLCBhbmQgdW5kZXJzY29yZXMgYXJlIGlnbm9yZWQuXG4gKlxuICogVXNlcyBVbmljb2RlIDguMC4wLlxuICpcbiAqIEByZXF1aXJlcyBYUmVnRXhwLCBVbmljb2RlIEJhc2VcbiAqL1xuKGZ1bmN0aW9uKFhSZWdFeHApIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBpZiAoIVhSZWdFeHAuYWRkVW5pY29kZURhdGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKCdVbmljb2RlIEJhc2UgbXVzdCBiZSBsb2FkZWQgYmVmb3JlIFVuaWNvZGUgU2NyaXB0cycpO1xuICAgIH1cblxuICAgIFhSZWdFeHAuYWRkVW5pY29kZURhdGEoW1xuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnQWhvbScsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODA1W1xcdURGMDAtXFx1REYxOVxcdURGMUQtXFx1REYyQlxcdURGMzAtXFx1REYzRl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdBbmF0b2xpYW5fSGllcm9nbHlwaHMnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgxMVtcXHVEQzAwLVxcdURFNDZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnQXJhYmljJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTA2MDAtXFx1MDYwNFxcdTA2MDYtXFx1MDYwQlxcdTA2MEQtXFx1MDYxQVxcdTA2MUVcXHUwNjIwLVxcdTA2M0ZcXHUwNjQxLVxcdTA2NEFcXHUwNjU2LVxcdTA2NkZcXHUwNjcxLVxcdTA2RENcXHUwNkRFLVxcdTA2RkZcXHUwNzUwLVxcdTA3N0ZcXHUwOEEwLVxcdTA4QjRcXHUwOEUzLVxcdTA4RkZcXHVGQjUwLVxcdUZCQzFcXHVGQkQzLVxcdUZEM0RcXHVGRDUwLVxcdUZEOEZcXHVGRDkyLVxcdUZEQzdcXHVGREYwLVxcdUZERkRcXHVGRTcwLVxcdUZFNzRcXHVGRTc2LVxcdUZFRkMnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwM1tcXHVERTYwLVxcdURFN0VdfFxcdUQ4M0JbXFx1REUwMC1cXHVERTAzXFx1REUwNS1cXHVERTFGXFx1REUyMVxcdURFMjJcXHVERTI0XFx1REUyN1xcdURFMjktXFx1REUzMlxcdURFMzQtXFx1REUzN1xcdURFMzlcXHVERTNCXFx1REU0MlxcdURFNDdcXHVERTQ5XFx1REU0QlxcdURFNEQtXFx1REU0RlxcdURFNTFcXHVERTUyXFx1REU1NFxcdURFNTdcXHVERTU5XFx1REU1QlxcdURFNURcXHVERTVGXFx1REU2MVxcdURFNjJcXHVERTY0XFx1REU2Ny1cXHVERTZBXFx1REU2Qy1cXHVERTcyXFx1REU3NC1cXHVERTc3XFx1REU3OS1cXHVERTdDXFx1REU3RVxcdURFODAtXFx1REU4OVxcdURFOEItXFx1REU5QlxcdURFQTEtXFx1REVBM1xcdURFQTUtXFx1REVBOVxcdURFQUItXFx1REVCQlxcdURFRjBcXHVERUYxXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0FybWVuaWFuJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTA1MzEtXFx1MDU1NlxcdTA1NTktXFx1MDU1RlxcdTA1NjEtXFx1MDU4N1xcdTA1OEFcXHUwNThELVxcdTA1OEZcXHVGQjEzLVxcdUZCMTcnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdBdmVzdGFuJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDJbXFx1REYwMC1cXHVERjM1XFx1REYzOS1cXHVERjNGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0JhbGluZXNlJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTFCMDAtXFx1MUI0QlxcdTFCNTAtXFx1MUI3QydcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0JhbXVtJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdUE2QTAtXFx1QTZGNycsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODFBW1xcdURDMDAtXFx1REUzOF0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdCYXNzYV9WYWgnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgxQVtcXHVERUQwLVxcdURFRURcXHVERUYwLVxcdURFRjVdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnQmF0YWsnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MUJDMC1cXHUxQkYzXFx1MUJGQy1cXHUxQkZGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnQmVuZ2FsaScsXG4gICAgICAgICAgICBibXA6ICdcXHUwOTgwLVxcdTA5ODNcXHUwOTg1LVxcdTA5OENcXHUwOThGXFx1MDk5MFxcdTA5OTMtXFx1MDlBOFxcdTA5QUEtXFx1MDlCMFxcdTA5QjJcXHUwOUI2LVxcdTA5QjlcXHUwOUJDLVxcdTA5QzRcXHUwOUM3XFx1MDlDOFxcdTA5Q0ItXFx1MDlDRVxcdTA5RDdcXHUwOURDXFx1MDlERFxcdTA5REYtXFx1MDlFM1xcdTA5RTYtXFx1MDlGQidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0JvcG9tb2ZvJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTAyRUFcXHUwMkVCXFx1MzEwNS1cXHUzMTJEXFx1MzFBMC1cXHUzMUJBJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnQnJhaG1pJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDRbXFx1REMwMC1cXHVEQzREXFx1REM1Mi1cXHVEQzZGXFx1REM3Rl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdCcmFpbGxlJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTI4MDAtXFx1MjhGRidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0J1Z2luZXNlJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTFBMDAtXFx1MUExQlxcdTFBMUVcXHUxQTFGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnQnVoaWQnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MTc0MC1cXHUxNzUzJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnQ2FuYWRpYW5fQWJvcmlnaW5hbCcsXG4gICAgICAgICAgICBibXA6ICdcXHUxNDAwLVxcdTE2N0ZcXHUxOEIwLVxcdTE4RjUnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdDYXJpYW4nLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMFtcXHVERUEwLVxcdURFRDBdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnQ2F1Y2FzaWFuX0FsYmFuaWFuJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDFbXFx1REQzMC1cXHVERDYzXFx1REQ2Rl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdDaGFrbWEnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwNFtcXHVERDAwLVxcdUREMzRcXHVERDM2LVxcdURENDNdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnQ2hhbScsXG4gICAgICAgICAgICBibXA6ICdcXHVBQTAwLVxcdUFBMzZcXHVBQTQwLVxcdUFBNERcXHVBQTUwLVxcdUFBNTlcXHVBQTVDLVxcdUFBNUYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdDaGVyb2tlZScsXG4gICAgICAgICAgICBibXA6ICdcXHUxM0EwLVxcdTEzRjVcXHUxM0Y4LVxcdTEzRkRcXHVBQjcwLVxcdUFCQkYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdDb21tb24nLFxuICAgICAgICAgICAgYm1wOiAnXFwwLVxceDQwXFxcXHg1Qi1cXHg2MFxcXFx4N0ItXFx4QTlcXHhBQi1cXHhCOVxceEJCLVxceEJGXFx4RDdcXHhGN1xcdTAyQjktXFx1MDJERlxcdTAyRTUtXFx1MDJFOVxcdTAyRUMtXFx1MDJGRlxcdTAzNzRcXHUwMzdFXFx1MDM4NVxcdTAzODdcXHUwNTg5XFx1MDYwNVxcdTA2MENcXHUwNjFCXFx1MDYxQ1xcdTA2MUZcXHUwNjQwXFx1MDZERFxcdTA5NjRcXHUwOTY1XFx1MEUzRlxcdTBGRDUtXFx1MEZEOFxcdTEwRkJcXHUxNkVCLVxcdTE2RURcXHUxNzM1XFx1MTczNlxcdTE4MDJcXHUxODAzXFx1MTgwNVxcdTFDRDNcXHUxQ0UxXFx1MUNFOS1cXHUxQ0VDXFx1MUNFRS1cXHUxQ0YzXFx1MUNGNVxcdTFDRjZcXHUyMDAwLVxcdTIwMEJcXHUyMDBFLVxcdTIwNjRcXHUyMDY2LVxcdTIwNzBcXHUyMDc0LVxcdTIwN0VcXHUyMDgwLVxcdTIwOEVcXHUyMEEwLVxcdTIwQkVcXHUyMTAwLVxcdTIxMjVcXHUyMTI3LVxcdTIxMjlcXHUyMTJDLVxcdTIxMzFcXHUyMTMzLVxcdTIxNERcXHUyMTRGLVxcdTIxNUZcXHUyMTg5LVxcdTIxOEJcXHUyMTkwLVxcdTIzRkFcXHUyNDAwLVxcdTI0MjZcXHUyNDQwLVxcdTI0NEFcXHUyNDYwLVxcdTI3RkZcXHUyOTAwLVxcdTJCNzNcXHUyQjc2LVxcdTJCOTVcXHUyQjk4LVxcdTJCQjlcXHUyQkJELVxcdTJCQzhcXHUyQkNBLVxcdTJCRDFcXHUyQkVDLVxcdTJCRUZcXHUyRTAwLVxcdTJFNDJcXHUyRkYwLVxcdTJGRkJcXHUzMDAwLVxcdTMwMDRcXHUzMDA2XFx1MzAwOC1cXHUzMDIwXFx1MzAzMC1cXHUzMDM3XFx1MzAzQy1cXHUzMDNGXFx1MzA5QlxcdTMwOUNcXHUzMEEwXFx1MzBGQlxcdTMwRkNcXHUzMTkwLVxcdTMxOUZcXHUzMUMwLVxcdTMxRTNcXHUzMjIwLVxcdTMyNUZcXHUzMjdGLVxcdTMyQ0ZcXHUzMzU4LVxcdTMzRkZcXHU0REMwLVxcdTRERkZcXHVBNzAwLVxcdUE3MjFcXHVBNzg4LVxcdUE3OEFcXHVBODMwLVxcdUE4MzlcXHVBOTJFXFx1QTlDRlxcdUFCNUJcXHVGRDNFXFx1RkQzRlxcdUZFMTAtXFx1RkUxOVxcdUZFMzAtXFx1RkU1MlxcdUZFNTQtXFx1RkU2NlxcdUZFNjgtXFx1RkU2QlxcdUZFRkZcXHVGRjAxLVxcdUZGMjBcXHVGRjNCLVxcdUZGNDBcXHVGRjVCLVxcdUZGNjVcXHVGRjcwXFx1RkY5RVxcdUZGOUZcXHVGRkUwLVxcdUZGRTZcXHVGRkU4LVxcdUZGRUVcXHVGRkY5LVxcdUZGRkQnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgzRVtcXHVEQzAwLVxcdURDMEJcXHVEQzEwLVxcdURDNDdcXHVEQzUwLVxcdURDNTlcXHVEQzYwLVxcdURDODdcXHVEQzkwLVxcdURDQURcXHVERDEwLVxcdUREMThcXHVERDgwLVxcdUREODRcXHVEREMwXXxcXHVEODJGW1xcdURDQTAtXFx1RENBM118XFx1RDgzNVtcXHVEQzAwLVxcdURDNTRcXHVEQzU2LVxcdURDOUNcXHVEQzlFXFx1REM5RlxcdURDQTJcXHVEQ0E1XFx1RENBNlxcdURDQTktXFx1RENBQ1xcdURDQUUtXFx1RENCOVxcdURDQkJcXHVEQ0JELVxcdURDQzNcXHVEQ0M1LVxcdUREMDVcXHVERDA3LVxcdUREMEFcXHVERDBELVxcdUREMTRcXHVERDE2LVxcdUREMUNcXHVERDFFLVxcdUREMzlcXHVERDNCLVxcdUREM0VcXHVERDQwLVxcdURENDRcXHVERDQ2XFx1REQ0QS1cXHVERDUwXFx1REQ1Mi1cXHVERUE1XFx1REVBOC1cXHVERkNCXFx1REZDRS1cXHVERkZGXXxcXHVEQjQwW1xcdURDMDFcXHVEQzIwLVxcdURDN0ZdfFxcdUQ4M0RbXFx1REMwMC1cXHVERDc5XFx1REQ3Qi1cXHVEREEzXFx1RERBNS1cXHVERUQwXFx1REVFMC1cXHVERUVDXFx1REVGMC1cXHVERUYzXFx1REYwMC1cXHVERjczXFx1REY4MC1cXHVERkQ0XXxcXHVEODAwW1xcdUREMDAtXFx1REQwMlxcdUREMDctXFx1REQzM1xcdUREMzctXFx1REQzRlxcdUREOTAtXFx1REQ5QlxcdURERDAtXFx1RERGQ1xcdURFRTEtXFx1REVGQl18XFx1RDgzNFtcXHVEQzAwLVxcdURDRjVcXHVERDAwLVxcdUREMjZcXHVERDI5LVxcdURENjZcXHVERDZBLVxcdUREN0FcXHVERDgzXFx1REQ4NFxcdUREOEMtXFx1RERBOVxcdUREQUUtXFx1RERFOFxcdURGMDAtXFx1REY1NlxcdURGNjAtXFx1REY3MV18XFx1RDgzQ1tcXHVEQzAwLVxcdURDMkJcXHVEQzMwLVxcdURDOTNcXHVEQ0EwLVxcdURDQUVcXHVEQ0IxLVxcdURDQkZcXHVEQ0MxLVxcdURDQ0ZcXHVEQ0QxLVxcdURDRjVcXHVERDAwLVxcdUREMENcXHVERDEwLVxcdUREMkVcXHVERDMwLVxcdURENkJcXHVERDcwLVxcdUREOUFcXHVEREU2LVxcdURERkZcXHVERTAxXFx1REUwMlxcdURFMTAtXFx1REUzQVxcdURFNDAtXFx1REU0OFxcdURFNTBcXHVERTUxXFx1REYwMC1cXHVERkZGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0NvcHRpYycsXG4gICAgICAgICAgICBibXA6ICdcXHUwM0UyLVxcdTAzRUZcXHUyQzgwLVxcdTJDRjNcXHUyQ0Y5LVxcdTJDRkYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdDdW5laWZvcm0nLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwOVtcXHVEQzAwLVxcdURDNkVcXHVEQzcwLVxcdURDNzRcXHVEQzgwLVxcdURENDNdfFxcdUQ4MDhbXFx1REMwMC1cXHVERjk5XSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0N5cHJpb3QnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMltcXHVEQzAwLVxcdURDMDVcXHVEQzA4XFx1REMwQS1cXHVEQzM1XFx1REMzN1xcdURDMzhcXHVEQzNDXFx1REMzRl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdDeXJpbGxpYycsXG4gICAgICAgICAgICBibXA6ICdcXHUwNDAwLVxcdTA0ODRcXHUwNDg3LVxcdTA1MkZcXHUxRDJCXFx1MUQ3OFxcdTJERTAtXFx1MkRGRlxcdUE2NDAtXFx1QTY5RlxcdUZFMkVcXHVGRTJGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnRGVzZXJldCcsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAxW1xcdURDMDAtXFx1REM0Rl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdEZXZhbmFnYXJpJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTA5MDAtXFx1MDk1MFxcdTA5NTMtXFx1MDk2M1xcdTA5NjYtXFx1MDk3RlxcdUE4RTAtXFx1QThGRCdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0R1cGxveWFuJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MkZbXFx1REMwMC1cXHVEQzZBXFx1REM3MC1cXHVEQzdDXFx1REM4MC1cXHVEQzg4XFx1REM5MC1cXHVEQzk5XFx1REM5Qy1cXHVEQzlGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0VneXB0aWFuX0hpZXJvZ2x5cGhzJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MENbXFx1REMwMC1cXHVERkZGXXxcXHVEODBEW1xcdURDMDAtXFx1REMyRV0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdFbGJhc2FuJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDFbXFx1REQwMC1cXHVERDI3XSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0V0aGlvcGljJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTEyMDAtXFx1MTI0OFxcdTEyNEEtXFx1MTI0RFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVBLVxcdTEyNURcXHUxMjYwLVxcdTEyODhcXHUxMjhBLVxcdTEyOERcXHUxMjkwLVxcdTEyQjBcXHUxMkIyLVxcdTEyQjVcXHUxMkI4LVxcdTEyQkVcXHUxMkMwXFx1MTJDMi1cXHUxMkM1XFx1MTJDOC1cXHUxMkQ2XFx1MTJEOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVBXFx1MTM1RC1cXHUxMzdDXFx1MTM4MC1cXHUxMzk5XFx1MkQ4MC1cXHUyRDk2XFx1MkRBMC1cXHUyREE2XFx1MkRBOC1cXHUyREFFXFx1MkRCMC1cXHUyREI2XFx1MkRCOC1cXHUyREJFXFx1MkRDMC1cXHUyREM2XFx1MkRDOC1cXHUyRENFXFx1MkREMC1cXHUyREQ2XFx1MkREOC1cXHUyRERFXFx1QUIwMS1cXHVBQjA2XFx1QUIwOS1cXHVBQjBFXFx1QUIxMS1cXHVBQjE2XFx1QUIyMC1cXHVBQjI2XFx1QUIyOC1cXHVBQjJFJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnR2VvcmdpYW4nLFxuICAgICAgICAgICAgYm1wOiAnXFx1MTBBMC1cXHUxMEM1XFx1MTBDN1xcdTEwQ0RcXHUxMEQwLVxcdTEwRkFcXHUxMEZDLVxcdTEwRkZcXHUyRDAwLVxcdTJEMjVcXHUyRDI3XFx1MkQyRCdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0dsYWdvbGl0aWMnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MkMwMC1cXHUyQzJFXFx1MkMzMC1cXHUyQzVFJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnR290aGljJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDBbXFx1REYzMC1cXHVERjRBXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0dyYW50aGEnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwNFtcXHVERjAwLVxcdURGMDNcXHVERjA1LVxcdURGMENcXHVERjBGXFx1REYxMFxcdURGMTMtXFx1REYyOFxcdURGMkEtXFx1REYzMFxcdURGMzJcXHVERjMzXFx1REYzNS1cXHVERjM5XFx1REYzQy1cXHVERjQ0XFx1REY0N1xcdURGNDhcXHVERjRCLVxcdURGNERcXHVERjUwXFx1REY1N1xcdURGNUQtXFx1REY2M1xcdURGNjYtXFx1REY2Q1xcdURGNzAtXFx1REY3NF0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdHcmVlaycsXG4gICAgICAgICAgICBibXA6ICdcXHUwMzcwLVxcdTAzNzNcXHUwMzc1LVxcdTAzNzdcXHUwMzdBLVxcdTAzN0RcXHUwMzdGXFx1MDM4NFxcdTAzODZcXHUwMzg4LVxcdTAzOEFcXHUwMzhDXFx1MDM4RS1cXHUwM0ExXFx1MDNBMy1cXHUwM0UxXFx1MDNGMC1cXHUwM0ZGXFx1MUQyNi1cXHUxRDJBXFx1MUQ1RC1cXHUxRDYxXFx1MUQ2Ni1cXHUxRDZBXFx1MURCRlxcdTFGMDAtXFx1MUYxNVxcdTFGMTgtXFx1MUYxRFxcdTFGMjAtXFx1MUY0NVxcdTFGNDgtXFx1MUY0RFxcdTFGNTAtXFx1MUY1N1xcdTFGNTlcXHUxRjVCXFx1MUY1RFxcdTFGNUYtXFx1MUY3RFxcdTFGODAtXFx1MUZCNFxcdTFGQjYtXFx1MUZDNFxcdTFGQzYtXFx1MUZEM1xcdTFGRDYtXFx1MUZEQlxcdTFGREQtXFx1MUZFRlxcdTFGRjItXFx1MUZGNFxcdTFGRjYtXFx1MUZGRVxcdTIxMjZcXHVBQjY1JyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDBbXFx1REQ0MC1cXHVERDhDXFx1RERBMF18XFx1RDgzNFtcXHVERTAwLVxcdURFNDVdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnR3VqYXJhdGknLFxuICAgICAgICAgICAgYm1wOiAnXFx1MEE4MS1cXHUwQTgzXFx1MEE4NS1cXHUwQThEXFx1MEE4Ri1cXHUwQTkxXFx1MEE5My1cXHUwQUE4XFx1MEFBQS1cXHUwQUIwXFx1MEFCMlxcdTBBQjNcXHUwQUI1LVxcdTBBQjlcXHUwQUJDLVxcdTBBQzVcXHUwQUM3LVxcdTBBQzlcXHUwQUNCLVxcdTBBQ0RcXHUwQUQwXFx1MEFFMC1cXHUwQUUzXFx1MEFFNi1cXHUwQUYxXFx1MEFGOSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0d1cm11a2hpJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTBBMDEtXFx1MEEwM1xcdTBBMDUtXFx1MEEwQVxcdTBBMEZcXHUwQTEwXFx1MEExMy1cXHUwQTI4XFx1MEEyQS1cXHUwQTMwXFx1MEEzMlxcdTBBMzNcXHUwQTM1XFx1MEEzNlxcdTBBMzhcXHUwQTM5XFx1MEEzQ1xcdTBBM0UtXFx1MEE0MlxcdTBBNDdcXHUwQTQ4XFx1MEE0Qi1cXHUwQTREXFx1MEE1MVxcdTBBNTktXFx1MEE1Q1xcdTBBNUVcXHUwQTY2LVxcdTBBNzUnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdIYW4nLFxuICAgICAgICAgICAgYm1wOiAnXFx1MkU4MC1cXHUyRTk5XFx1MkU5Qi1cXHUyRUYzXFx1MkYwMC1cXHUyRkQ1XFx1MzAwNVxcdTMwMDdcXHUzMDIxLVxcdTMwMjlcXHUzMDM4LVxcdTMwM0JcXHUzNDAwLVxcdTREQjVcXHU0RTAwLVxcdTlGRDVcXHVGOTAwLVxcdUZBNkRcXHVGQTcwLVxcdUZBRDknLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDg2RVtcXHVEQzAwLVxcdURDMURcXHVEQzIwLVxcdURGRkZdfFtcXHVEODQwLVxcdUQ4NjhcXHVEODZBLVxcdUQ4NkNcXHVEODZGLVxcdUQ4NzJdW1xcdURDMDAtXFx1REZGRl18XFx1RDg2RFtcXHVEQzAwLVxcdURGMzRcXHVERjQwLVxcdURGRkZdfFxcdUQ4N0VbXFx1REMwMC1cXHVERTFEXXxcXHVEODY5W1xcdURDMDAtXFx1REVENlxcdURGMDAtXFx1REZGRl18XFx1RDg3M1tcXHVEQzAwLVxcdURFQTFdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSGFuZ3VsJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTExMDAtXFx1MTFGRlxcdTMwMkVcXHUzMDJGXFx1MzEzMS1cXHUzMThFXFx1MzIwMC1cXHUzMjFFXFx1MzI2MC1cXHUzMjdFXFx1QTk2MC1cXHVBOTdDXFx1QUMwMC1cXHVEN0EzXFx1RDdCMC1cXHVEN0M2XFx1RDdDQi1cXHVEN0ZCXFx1RkZBMC1cXHVGRkJFXFx1RkZDMi1cXHVGRkM3XFx1RkZDQS1cXHVGRkNGXFx1RkZEMi1cXHVGRkQ3XFx1RkZEQS1cXHVGRkRDJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSGFudW5vbycsXG4gICAgICAgICAgICBibXA6ICdcXHUxNzIwLVxcdTE3MzQnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdIYXRyYW4nLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMltcXHVEQ0UwLVxcdURDRjJcXHVEQ0Y0XFx1RENGNVxcdURDRkItXFx1RENGRl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdIZWJyZXcnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MDU5MS1cXHUwNUM3XFx1MDVEMC1cXHUwNUVBXFx1MDVGMC1cXHUwNUY0XFx1RkIxRC1cXHVGQjM2XFx1RkIzOC1cXHVGQjNDXFx1RkIzRVxcdUZCNDBcXHVGQjQxXFx1RkI0M1xcdUZCNDRcXHVGQjQ2LVxcdUZCNEYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdIaXJhZ2FuYScsXG4gICAgICAgICAgICBibXA6ICdcXHUzMDQxLVxcdTMwOTZcXHUzMDlELVxcdTMwOUYnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgyQ1xcdURDMDF8XFx1RDgzQ1xcdURFMDAnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbXBlcmlhbF9BcmFtYWljJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDJbXFx1REM0MC1cXHVEQzU1XFx1REM1Ny1cXHVEQzVGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luaGVyaXRlZCcsXG4gICAgICAgICAgICBibXA6ICdcXHUwMzAwLVxcdTAzNkZcXHUwNDg1XFx1MDQ4NlxcdTA2NEItXFx1MDY1NVxcdTA2NzBcXHUwOTUxXFx1MDk1MlxcdTFBQjAtXFx1MUFCRVxcdTFDRDAtXFx1MUNEMlxcdTFDRDQtXFx1MUNFMFxcdTFDRTItXFx1MUNFOFxcdTFDRURcXHUxQ0Y0XFx1MUNGOFxcdTFDRjlcXHUxREMwLVxcdTFERjVcXHUxREZDLVxcdTFERkZcXHUyMDBDXFx1MjAwRFxcdTIwRDAtXFx1MjBGMFxcdTMwMkEtXFx1MzAyRFxcdTMwOTlcXHUzMDlBXFx1RkUwMC1cXHVGRTBGXFx1RkUyMC1cXHVGRTJEJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MzRbXFx1REQ2Ny1cXHVERDY5XFx1REQ3Qi1cXHVERDgyXFx1REQ4NS1cXHVERDhCXFx1RERBQS1cXHVEREFEXXxcXHVEODAwW1xcdURERkRcXHVERUUwXXxcXHVEQjQwW1xcdUREMDAtXFx1RERFRl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbnNjcmlwdGlvbmFsX1BhaGxhdmknLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMltcXHVERjYwLVxcdURGNzJcXHVERjc4LVxcdURGN0ZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5zY3JpcHRpb25hbF9QYXJ0aGlhbicsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAyW1xcdURGNDAtXFx1REY1NVxcdURGNTgtXFx1REY1Rl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdKYXZhbmVzZScsXG4gICAgICAgICAgICBibXA6ICdcXHVBOTgwLVxcdUE5Q0RcXHVBOUQwLVxcdUE5RDlcXHVBOURFXFx1QTlERidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0thaXRoaScsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODA0W1xcdURDODAtXFx1RENDMV0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdLYW5uYWRhJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTBDODEtXFx1MEM4M1xcdTBDODUtXFx1MEM4Q1xcdTBDOEUtXFx1MEM5MFxcdTBDOTItXFx1MENBOFxcdTBDQUEtXFx1MENCM1xcdTBDQjUtXFx1MENCOVxcdTBDQkMtXFx1MENDNFxcdTBDQzYtXFx1MENDOFxcdTBDQ0EtXFx1MENDRFxcdTBDRDVcXHUwQ0Q2XFx1MENERVxcdTBDRTAtXFx1MENFM1xcdTBDRTYtXFx1MENFRlxcdTBDRjFcXHUwQ0YyJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnS2F0YWthbmEnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MzBBMS1cXHUzMEZBXFx1MzBGRC1cXHUzMEZGXFx1MzFGMC1cXHUzMUZGXFx1MzJEMC1cXHUzMkZFXFx1MzMwMC1cXHUzMzU3XFx1RkY2Ni1cXHVGRjZGXFx1RkY3MS1cXHVGRjlEJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MkNcXHVEQzAwJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnS2F5YWhfTGknLFxuICAgICAgICAgICAgYm1wOiAnXFx1QTkwMC1cXHVBOTJEXFx1QTkyRidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0toYXJvc2h0aGknLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMltcXHVERTAwLVxcdURFMDNcXHVERTA1XFx1REUwNlxcdURFMEMtXFx1REUxM1xcdURFMTUtXFx1REUxN1xcdURFMTktXFx1REUzM1xcdURFMzgtXFx1REUzQVxcdURFM0YtXFx1REU0N1xcdURFNTAtXFx1REU1OF0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdLaG1lcicsXG4gICAgICAgICAgICBibXA6ICdcXHUxNzgwLVxcdTE3RERcXHUxN0UwLVxcdTE3RTlcXHUxN0YwLVxcdTE3RjlcXHUxOUUwLVxcdTE5RkYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdLaG9qa2knLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwNFtcXHVERTAwLVxcdURFMTFcXHVERTEzLVxcdURFM0RdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnS2h1ZGF3YWRpJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDRbXFx1REVCMC1cXHVERUVBXFx1REVGMC1cXHVERUY5XSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0xhbycsXG4gICAgICAgICAgICBibXA6ICdcXHUwRTgxXFx1MEU4MlxcdTBFODRcXHUwRTg3XFx1MEU4OFxcdTBFOEFcXHUwRThEXFx1MEU5NC1cXHUwRTk3XFx1MEU5OS1cXHUwRTlGXFx1MEVBMS1cXHUwRUEzXFx1MEVBNVxcdTBFQTdcXHUwRUFBXFx1MEVBQlxcdTBFQUQtXFx1MEVCOVxcdTBFQkItXFx1MEVCRFxcdTBFQzAtXFx1MEVDNFxcdTBFQzZcXHUwRUM4LVxcdTBFQ0RcXHUwRUQwLVxcdTBFRDlcXHUwRURDLVxcdTBFREYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdMYXRpbicsXG4gICAgICAgICAgICBibXA6ICdBLVphLXpcXHhBQVxceEJBXFx4QzAtXFx4RDZcXHhEOC1cXHhGNlxceEY4LVxcdTAyQjhcXHUwMkUwLVxcdTAyRTRcXHUxRDAwLVxcdTFEMjVcXHUxRDJDLVxcdTFENUNcXHUxRDYyLVxcdTFENjVcXHUxRDZCLVxcdTFENzdcXHUxRDc5LVxcdTFEQkVcXHUxRTAwLVxcdTFFRkZcXHUyMDcxXFx1MjA3RlxcdTIwOTAtXFx1MjA5Q1xcdTIxMkFcXHUyMTJCXFx1MjEzMlxcdTIxNEVcXHUyMTYwLVxcdTIxODhcXHUyQzYwLVxcdTJDN0ZcXHVBNzIyLVxcdUE3ODdcXHVBNzhCLVxcdUE3QURcXHVBN0IwLVxcdUE3QjdcXHVBN0Y3LVxcdUE3RkZcXHVBQjMwLVxcdUFCNUFcXHVBQjVDLVxcdUFCNjRcXHVGQjAwLVxcdUZCMDZcXHVGRjIxLVxcdUZGM0FcXHVGRjQxLVxcdUZGNUEnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdMZXBjaGEnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MUMwMC1cXHUxQzM3XFx1MUMzQi1cXHUxQzQ5XFx1MUM0RC1cXHUxQzRGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnTGltYnUnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MTkwMC1cXHUxOTFFXFx1MTkyMC1cXHUxOTJCXFx1MTkzMC1cXHUxOTNCXFx1MTk0MFxcdTE5NDQtXFx1MTk0RidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0xpbmVhcl9BJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDFbXFx1REUwMC1cXHVERjM2XFx1REY0MC1cXHVERjU1XFx1REY2MC1cXHVERjY3XSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0xpbmVhcl9CJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDBbXFx1REMwMC1cXHVEQzBCXFx1REMwRC1cXHVEQzI2XFx1REMyOC1cXHVEQzNBXFx1REMzQ1xcdURDM0RcXHVEQzNGLVxcdURDNERcXHVEQzUwLVxcdURDNURcXHVEQzgwLVxcdURDRkFdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnTGlzdScsXG4gICAgICAgICAgICBibXA6ICdcXHVBNEQwLVxcdUE0RkYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdMeWNpYW4nLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMFtcXHVERTgwLVxcdURFOUNdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnTHlkaWFuJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDJbXFx1REQyMC1cXHVERDM5XFx1REQzRl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdNYWhhamFuaScsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODA0W1xcdURENTAtXFx1REQ3Nl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdNYWxheWFsYW0nLFxuICAgICAgICAgICAgYm1wOiAnXFx1MEQwMS1cXHUwRDAzXFx1MEQwNS1cXHUwRDBDXFx1MEQwRS1cXHUwRDEwXFx1MEQxMi1cXHUwRDNBXFx1MEQzRC1cXHUwRDQ0XFx1MEQ0Ni1cXHUwRDQ4XFx1MEQ0QS1cXHUwRDRFXFx1MEQ1N1xcdTBENUYtXFx1MEQ2M1xcdTBENjYtXFx1MEQ3NVxcdTBENzktXFx1MEQ3RidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ01hbmRhaWMnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MDg0MC1cXHUwODVCXFx1MDg1RSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ01hbmljaGFlYW4nLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMltcXHVERUMwLVxcdURFRTZcXHVERUVCLVxcdURFRjZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnTWVldGVpX01heWVrJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdUFBRTAtXFx1QUFGNlxcdUFCQzAtXFx1QUJFRFxcdUFCRjAtXFx1QUJGOSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ01lbmRlX0tpa2FrdWknLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgzQVtcXHVEQzAwLVxcdURDQzRcXHVEQ0M3LVxcdURDRDZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnTWVyb2l0aWNfQ3Vyc2l2ZScsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAyW1xcdUREQTAtXFx1RERCN1xcdUREQkMtXFx1RERDRlxcdURERDItXFx1RERGRl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdNZXJvaXRpY19IaWVyb2dseXBocycsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAyW1xcdUREODAtXFx1REQ5Rl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdNaWFvJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MUJbXFx1REYwMC1cXHVERjQ0XFx1REY1MC1cXHVERjdFXFx1REY4Ri1cXHVERjlGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ01vZGknLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwNVtcXHVERTAwLVxcdURFNDRcXHVERTUwLVxcdURFNTldJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnTW9uZ29saWFuJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTE4MDBcXHUxODAxXFx1MTgwNFxcdTE4MDYtXFx1MTgwRVxcdTE4MTAtXFx1MTgxOVxcdTE4MjAtXFx1MTg3N1xcdTE4ODAtXFx1MThBQSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ01ybycsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODFBW1xcdURFNDAtXFx1REU1RVxcdURFNjAtXFx1REU2OVxcdURFNkVcXHVERTZGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ011bHRhbmknLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwNFtcXHVERTgwLVxcdURFODZcXHVERTg4XFx1REU4QS1cXHVERThEXFx1REU4Ri1cXHVERTlEXFx1REU5Ri1cXHVERUE5XSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ015YW5tYXInLFxuICAgICAgICAgICAgYm1wOiAnXFx1MTAwMC1cXHUxMDlGXFx1QTlFMC1cXHVBOUZFXFx1QUE2MC1cXHVBQTdGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnTmFiYXRhZWFuJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDJbXFx1REM4MC1cXHVEQzlFXFx1RENBNy1cXHVEQ0FGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ05ld19UYWlfTHVlJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTE5ODAtXFx1MTlBQlxcdTE5QjAtXFx1MTlDOVxcdTE5RDAtXFx1MTlEQVxcdTE5REVcXHUxOURGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnTmtvJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTA3QzAtXFx1MDdGQSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ09naGFtJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTE2ODAtXFx1MTY5QydcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ09sX0NoaWtpJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTFDNTAtXFx1MUM3RidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ09sZF9IdW5nYXJpYW4nLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwM1tcXHVEQzgwLVxcdURDQjJcXHVEQ0MwLVxcdURDRjJcXHVEQ0ZBLVxcdURDRkZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnT2xkX0l0YWxpYycsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAwW1xcdURGMDAtXFx1REYyM10nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdPbGRfTm9ydGhfQXJhYmlhbicsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAyW1xcdURFODAtXFx1REU5Rl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdPbGRfUGVybWljJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDBbXFx1REY1MC1cXHVERjdBXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ09sZF9QZXJzaWFuJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDBbXFx1REZBMC1cXHVERkMzXFx1REZDOC1cXHVERkQ1XSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ09sZF9Tb3V0aF9BcmFiaWFuJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDJbXFx1REU2MC1cXHVERTdGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ09sZF9UdXJraWMnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwM1tcXHVEQzAwLVxcdURDNDhdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnT3JpeWEnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MEIwMS1cXHUwQjAzXFx1MEIwNS1cXHUwQjBDXFx1MEIwRlxcdTBCMTBcXHUwQjEzLVxcdTBCMjhcXHUwQjJBLVxcdTBCMzBcXHUwQjMyXFx1MEIzM1xcdTBCMzUtXFx1MEIzOVxcdTBCM0MtXFx1MEI0NFxcdTBCNDdcXHUwQjQ4XFx1MEI0Qi1cXHUwQjREXFx1MEI1NlxcdTBCNTdcXHUwQjVDXFx1MEI1RFxcdTBCNUYtXFx1MEI2M1xcdTBCNjYtXFx1MEI3NydcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ09zbWFueWEnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMVtcXHVEQzgwLVxcdURDOURcXHVEQ0EwLVxcdURDQTldJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnUGFoYXdoX0htb25nJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MUFbXFx1REYwMC1cXHVERjQ1XFx1REY1MC1cXHVERjU5XFx1REY1Qi1cXHVERjYxXFx1REY2My1cXHVERjc3XFx1REY3RC1cXHVERjhGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ1BhbG15cmVuZScsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAyW1xcdURDNjAtXFx1REM3Rl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdQYXVfQ2luX0hhdScsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODA2W1xcdURFQzAtXFx1REVGOF0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdQaGFnc19QYScsXG4gICAgICAgICAgICBibXA6ICdcXHVBODQwLVxcdUE4NzcnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdQaG9lbmljaWFuJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDJbXFx1REQwMC1cXHVERDFCXFx1REQxRl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdQc2FsdGVyX1BhaGxhdmknLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMltcXHVERjgwLVxcdURGOTFcXHVERjk5LVxcdURGOUNcXHVERkE5LVxcdURGQUZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnUmVqYW5nJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdUE5MzAtXFx1QTk1M1xcdUE5NUYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdSdW5pYycsXG4gICAgICAgICAgICBibXA6ICdcXHUxNkEwLVxcdTE2RUFcXHUxNkVFLVxcdTE2RjgnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdTYW1hcml0YW4nLFxuICAgICAgICAgICAgYm1wOiAnXFx1MDgwMC1cXHUwODJEXFx1MDgzMC1cXHUwODNFJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnU2F1cmFzaHRyYScsXG4gICAgICAgICAgICBibXA6ICdcXHVBODgwLVxcdUE4QzRcXHVBOENFLVxcdUE4RDknXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdTaGFyYWRhJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDRbXFx1REQ4MC1cXHVERENEXFx1REREMC1cXHVERERGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ1NoYXZpYW4nLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMVtcXHVEQzUwLVxcdURDN0ZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnU2lkZGhhbScsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODA1W1xcdUREODAtXFx1RERCNVxcdUREQjgtXFx1RERERF0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdTaWduV3JpdGluZycsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODM2W1xcdURDMDAtXFx1REU4QlxcdURFOUItXFx1REU5RlxcdURFQTEtXFx1REVBRl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdTaW5oYWxhJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTBEODJcXHUwRDgzXFx1MEQ4NS1cXHUwRDk2XFx1MEQ5QS1cXHUwREIxXFx1MERCMy1cXHUwREJCXFx1MERCRFxcdTBEQzAtXFx1MERDNlxcdTBEQ0FcXHUwRENGLVxcdTBERDRcXHUwREQ2XFx1MEREOC1cXHUwRERGXFx1MERFNi1cXHUwREVGXFx1MERGMi1cXHUwREY0JyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDRbXFx1RERFMS1cXHVEREY0XSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ1NvcmFfU29tcGVuZycsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODA0W1xcdURDRDAtXFx1RENFOFxcdURDRjAtXFx1RENGOV0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdTdW5kYW5lc2UnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MUI4MC1cXHUxQkJGXFx1MUNDMC1cXHUxQ0M3J1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnU3lsb3RpX05hZ3JpJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdUE4MDAtXFx1QTgyQidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ1N5cmlhYycsXG4gICAgICAgICAgICBibXA6ICdcXHUwNzAwLVxcdTA3MERcXHUwNzBGLVxcdTA3NEFcXHUwNzRELVxcdTA3NEYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdUYWdhbG9nJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTE3MDAtXFx1MTcwQ1xcdTE3MEUtXFx1MTcxNCdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ1RhZ2JhbndhJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTE3NjAtXFx1MTc2Q1xcdTE3NkUtXFx1MTc3MFxcdTE3NzJcXHUxNzczJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnVGFpX0xlJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTE5NTAtXFx1MTk2RFxcdTE5NzAtXFx1MTk3NCdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ1RhaV9UaGFtJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTFBMjAtXFx1MUE1RVxcdTFBNjAtXFx1MUE3Q1xcdTFBN0YtXFx1MUE4OVxcdTFBOTAtXFx1MUE5OVxcdTFBQTAtXFx1MUFBRCdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ1RhaV9WaWV0JyxcbiAgICAgICAgICAgIGJtcDogJ1xcdUFBODAtXFx1QUFDMlxcdUFBREItXFx1QUFERidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ1Rha3JpJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDVbXFx1REU4MC1cXHVERUI3XFx1REVDMC1cXHVERUM5XSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ1RhbWlsJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTBCODJcXHUwQjgzXFx1MEI4NS1cXHUwQjhBXFx1MEI4RS1cXHUwQjkwXFx1MEI5Mi1cXHUwQjk1XFx1MEI5OVxcdTBCOUFcXHUwQjlDXFx1MEI5RVxcdTBCOUZcXHUwQkEzXFx1MEJBNFxcdTBCQTgtXFx1MEJBQVxcdTBCQUUtXFx1MEJCOVxcdTBCQkUtXFx1MEJDMlxcdTBCQzYtXFx1MEJDOFxcdTBCQ0EtXFx1MEJDRFxcdTBCRDBcXHUwQkQ3XFx1MEJFNi1cXHUwQkZBJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnVGVsdWd1JyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTBDMDAtXFx1MEMwM1xcdTBDMDUtXFx1MEMwQ1xcdTBDMEUtXFx1MEMxMFxcdTBDMTItXFx1MEMyOFxcdTBDMkEtXFx1MEMzOVxcdTBDM0QtXFx1MEM0NFxcdTBDNDYtXFx1MEM0OFxcdTBDNEEtXFx1MEM0RFxcdTBDNTVcXHUwQzU2XFx1MEM1OC1cXHUwQzVBXFx1MEM2MC1cXHUwQzYzXFx1MEM2Ni1cXHUwQzZGXFx1MEM3OC1cXHUwQzdGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnVGhhYW5hJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTA3ODAtXFx1MDdCMSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ1RoYWknLFxuICAgICAgICAgICAgYm1wOiAnXFx1MEUwMS1cXHUwRTNBXFx1MEU0MC1cXHUwRTVCJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnVGliZXRhbicsXG4gICAgICAgICAgICBibXA6ICdcXHUwRjAwLVxcdTBGNDdcXHUwRjQ5LVxcdTBGNkNcXHUwRjcxLVxcdTBGOTdcXHUwRjk5LVxcdTBGQkNcXHUwRkJFLVxcdTBGQ0NcXHUwRkNFLVxcdTBGRDRcXHUwRkQ5XFx1MEZEQSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ1RpZmluYWdoJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTJEMzAtXFx1MkQ2N1xcdTJENkZcXHUyRDcwXFx1MkQ3RidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ1Rpcmh1dGEnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwNVtcXHVEQzgwLVxcdURDQzdcXHVEQ0QwLVxcdURDRDldJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnVWdhcml0aWMnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMFtcXHVERjgwLVxcdURGOURcXHVERjlGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ1ZhaScsXG4gICAgICAgICAgICBibXA6ICdcXHVBNTAwLVxcdUE2MkInXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdXYXJhbmdfQ2l0aScsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODA2W1xcdURDQTAtXFx1RENGMlxcdURDRkZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnWWknLFxuICAgICAgICAgICAgYm1wOiAnXFx1QTAwMC1cXHVBNDhDXFx1QTQ5MC1cXHVBNEM2J1xuICAgICAgICB9XG4gICAgXSk7XG5cbn0oWFJlZ0V4cCkpO1xuXG5yZXR1cm4gWFJlZ0V4cDtcblxufSkpO1xuXG4iLCIvLyBpbXBvcnQgXCJiYWJlbC1wb2x5ZmlsbFwiO1xyXG4vL1xyXG4vLyBpbXBvcnQge1hSZWdFeHB9IGZyb20gXCJ4cmVnZXhwXCI7XHJcbi8vIGltcG9ydCBQdWJTdWIgZnJvbSBcInB1YnN1Yi1qc1wiO1xyXG4vLyBpbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XHJcbi8vIGltcG9ydCBSZWFjdERPTSBmcm9tIFwicmVhY3QtZG9tXCI7XHJcbi8vIGltcG9ydCBDU1NUcmFuc2l0aW9uIGZyb20gXCJyZWFjdC1hZGRvbnMtY3NzLXRyYW5zaXRpb24tZ3JvdXBcIjtcclxuLy8gaW1wb3J0ICogYXMgUmVhY3RSb3V0ZXIgZnJvbSBcInJlYWN0LXJvdXRlclwiO1xyXG4vLyBpbXBvcnQge2NyZWF0ZUhhc2hIaXN0b3J5fSBmcm9tIFwiaGlzdG9yeVwiO1xyXG5cclxuXHJcbi8vIGltcG9ydCBcImxpYi1zb3VyY2UvdjIvZ2VzdHVyZVwiO1xyXG5pbXBvcnQgY2hyb25vIGZyb20gXCJsaWItc291cmNlL3YyL2Nocm9ub1wiO1xyXG5pbXBvcnQgYWpheCBmcm9tIFwibGliLXNvdXJjZS92Mi9hamF4XCI7XHJcblxyXG5pbXBvcnQgSWNvbiBmcm9tICdsaWItc291cmNlL3VpdjIvaWNvbic7XHJcbmltcG9ydCBSaXBwbGUgZnJvbSAnbGliLXNvdXJjZS91aXYyL3JpcHBsZSc7XHJcbmltcG9ydCBCdXR0b24gZnJvbSAnbGliLXNvdXJjZS91aXYyL2J1dHRvbic7XHJcbmltcG9ydCBJY29uQnV0dG9uIGZyb20gJ2xpYi1zb3VyY2UvdWl2Mi9pY29uYnV0dG9uJztcclxuaW1wb3J0IENhcmQgZnJvbSAnbGliLXNvdXJjZS91aXYyL0NhcmQnO1xyXG5pbXBvcnQgSW1hZ2UgZnJvbSAnbGliLXNvdXJjZS91aXYyL0ltYWdlJztcclxuaW1wb3J0IENlbnRlckNvbnRlbnQgZnJvbSAnbGliLXNvdXJjZS91aXYyL0NlbnRlckNvbnRlbnQnO1xyXG5pbXBvcnQgQ2hlY2tib3ggZnJvbSAnbGliLXNvdXJjZS91aXYyL0NoZWNrYm94JztcclxuaW1wb3J0IFRvZ2dsZSBmcm9tICdsaWItc291cmNlL3VpdjIvVG9nZ2xlJztcclxuaW1wb3J0IFRvdWNoYWJsZSBmcm9tICdsaWItc291cmNlL3VpdjIvVG91Y2hhYmxlJztcclxuaW1wb3J0IENvbWJvYm94IGZyb20gJ2xpYi1zb3VyY2UvdWl2Mi9Db21ib2JveCc7XHJcbmltcG9ydCBPcHRpb24gZnJvbSAnbGliLXNvdXJjZS91aXYyL09wdGlvbic7XHJcbmltcG9ydCBTcGlubmVyIGZyb20gJ2xpYi1zb3VyY2UvdWl2Mi9TcGlubmVyJztcclxuaW1wb3J0IFJhZGlvIGZyb20gJ2xpYi1zb3VyY2UvdWl2Mi9SYWRpbyc7XHJcbmltcG9ydCBDYWxlbmRhciBmcm9tICdsaWItc291cmNlL3VpdjIvQ2FsZW5kYXInO1xyXG5pbXBvcnQgSW5wdXQgZnJvbSAnbGliLXNvdXJjZS91aXYyL0lucHV0JztcclxuXHJcbmltcG9ydCBGbGV4Ym94IGZyb20gJ2xpYi1zb3VyY2UvdWl2Mi9sYXlvdXQvRmxleGJveCc7XHJcbmltcG9ydCBHcmlkIGZyb20gJ2xpYi1zb3VyY2UvdWl2Mi9sYXlvdXQvR3JpZCc7XHJcbmltcG9ydCBQaW5ib2FyZCBmcm9tICdsaWItc291cmNlL3VpdjIvbGF5b3V0L1BpbmJvYXJkJztcclxuXHJcbmltcG9ydCBGb3JtIGZyb20gJ2xpYi1zb3VyY2UvdWl2Mi9Gb3JtJztcclxuXHJcbmltcG9ydCBEaWFsb2dDb21wb25lbnQgZnJvbSBcImxpYi1zb3VyY2UvdWl2Mi9kaWFsb2dcIjtcclxuaW1wb3J0IHtkZWZpbmVDb21wb25lbnRTdHlsZSwgVGhlbWUgYXMgX1RoZW1lLCBfX3NldHVwIGFzIGNyZWF0ZVN0eWxlcywgZGVmaW5lU3R5bGVGb3JDb21wb25lbnQsIGdlbkZvbnRDU1N9IGZyb20gXCJsaWItc291cmNlL3YyL3N0eWxlXCI7XHJcblxyXG5pbXBvcnQge3dhcm5pbmdGdW5jfSBmcm9tIFwibGliLXNvdXJjZS92Mi91dGlsc1wiO1xyXG5pbXBvcnQge3NoYXJlZFJlZmVyZW5jZSwgU2hhcmVkT2JqZWN0RGlzcGxheX0gZnJvbSBcImxpYi1zb3VyY2UvdjIvc2hhcmVkXCI7XHJcblxyXG5pbXBvcnQgc2VjdXJlIGZyb20gJ2xpYi1zb3VyY2UvdjIvY3J5cHRvJztcclxuaW1wb3J0IHppcCBmcm9tICdsaWItc291cmNlL3YyL3ppcCc7XHJcbmltcG9ydCBFbnZpcm9ubWVudCBmcm9tICdsaWItc291cmNlL3YyL0Vudmlyb25tZW50JztcclxuXHJcbmltcG9ydCBSb2JvdG9VUkkgZnJvbSBcImxpYi1zb3VyY2UvZGF0YS11cmkvcm9ib3RvLWxpZ2h0LndvZmYuc291cmNlXCI7XHJcbmltcG9ydCBJb25pY1VSSSBmcm9tIFwibGliLXNvdXJjZS9kYXRhLXVyaS9pb25pY29ucy53b2ZmLnNvdXJjZVwiO1xyXG5cclxud2luZG93LmNocm9ubyA9IGNocm9ubztcclxuXHJcbmNvbnN0IHJhbmdlID0gZnVuY3Rpb24qIChhcmdzKSB7XHJcbiAgbGV0IHtzdGFydCA9IDAsIGVuZCA9IG51bGwsIGNvdW50ID0gbnVsbCwgc3RlcCA9IDEsIG1hcCA9IGkgPT4gaX0gPSBhcmdzO1xyXG5cclxuICBpZiAoZW5kID09PSBudWxsKSB7XHJcbiAgICBpZiAoY291bnQgPT09IG51bGwpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBnaXZlIHRoZSBzaXplIG9mIHRoZSByYW5nZVwiKVxyXG4gICAgfVxyXG4gICAgZW5kID0gc3RhcnQgKyBjb3VudDtcclxuICB9XHJcblxyXG4gIHdoaWxlICh0cnVlKSB7XHJcbiAgICBpZiAoc3RhcnQgPj0gZW5kKSB7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gICAgeWllbGQgbWFwKHN0YXJ0KTtcclxuICAgIHN0YXJ0ICs9IHN0ZXA7XHJcbiAgfVxyXG59O1xyXG5cclxud2luZG93LmZyYW5nZSA9IGZ1bmN0aW9uKiAoY291bnQsIG1hcCA9IGkgPT4gaSkge1xyXG4gICAgbGV0IGN1cnJlbnQgPSAwO1xyXG4gICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICBpZiAoY3VycmVudCA9PT0gY291bnQpIHtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHlpZWxkIG1hcChjdXJyZW50KTtcclxuICAgICAgICBjdXJyZW50ICs9IDE7XHJcbiAgICB9XHJcbn07XHJcbndpbmRvdy5hcmFuZ2UgPSAoY291bnQsIG1hcCkgPT4gQXJyYXkuZnJvbShmcmFuZ2UoY291bnQsIG1hcCkpO1xyXG5cclxuY29uc3Qge1JvdXRlfSA9IFJlYWN0Um91dGVyO1xyXG5cclxuY29uc3QgY29vbEJsdWUgPSBcIiMyRkIxREZcIjtcclxuXHJcblRoZW1lLmRlZmluZSh7XHJcbiAgICBhcHA6IHtcclxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICd3aGl0ZScsXHJcbiAgICAgICAgdGV4dENvbG9yOiAnIzc0NzQ3NCdcclxuICAgIH0sXHJcbiAgICBidXR0b246IHtcclxuICAgICAgICBob3ZlckNvbG9yOiAncmdiYSgwLCAwLCAwLCAwLjExKScsXHJcbiAgICAgICAgYWN0aXZlQ29sb3I6ICdyZ2JhKDAsIDAsIDAsIDAuMiknLFxyXG4gICAgICAgIHJhaXNlZDoge1xyXG4gICAgICAgICAgICBjb2xvcjogY29vbEJsdWUsXHJcbiAgICAgICAgICAgIHRleHRDb2xvcjogJ3doaXRlJ1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBjYXJkOiB7XHJcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnd2hpdGUnXHJcbiAgICB9LFxyXG4gICAgcHJvZ3Jlc3NiYXI6IHtcclxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjQjNDRUVEJyxcclxuICAgICAgICBjb2xvcjogJyMzQjhBRjMnXHJcbiAgICB9LFxyXG4gICAgcmFkaW86IHtcclxuICAgICAgICBncmlkOiB7XHJcbiAgICAgICAgICAgIHNlbGVjdGVkQ29sb3I6IGNvb2xCbHVlXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHJhbmdlSW5wdXQ6IHtcclxuICAgICAgICB0cmFjazoge1xyXG4gICAgICAgICAgICBjb2xvcjogY29vbEJsdWVcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgc3dpdGNoOiB7XHJcbiAgICAgICAgdHJhY2s6IHtcclxuICAgICAgICAgICAgY29sb3I6IGNvb2xCbHVlXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHRpdGxlOiB7XHJcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBjb29sQmx1ZSxcclxuICAgICAgICB0ZXh0Q29sb3I6ICd3aGl0ZSdcclxuICAgIH0sXHJcbiAgICB1c2VySW5wdXQ6IHtcclxuICAgICAgICBhY3RpdmVDb2xvcjogJyMyRkIxREYnLFxyXG4gICAgICAgIHRleHRDb2xvcjogJ2JsYWNrJ1xyXG4gICAgfVxyXG59KTtcclxuXHJcbmNvbnN0IFNjcmVlblRyYW5zaXRpb24gPSBSZWFjdC5jcmVhdGVDbGFzcyh7XHJcbiAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIDxkaXYgc3R5bGU9e3twb3NpdGlvbjogJ2Fic29sdXRlJywgd2lkdGg6ICcxMDAlJywgaGVpZ2h0OiAnMTAwJSd9fT57dGhpcy5wcm9wcy5jaGlsZHJlbn08L2Rpdj5cclxuICAgIH1cclxufSk7XHJcblxyXG5TdHlsZS5fX3Jhd0NTUyhcclxuICAgIFwidGVzdFwiLFxyXG4gICAge1xyXG4gICAgICAgIHNlbGVjdG9yOiBcIi50ZXN0LWVudGVyXCIsXHJcbiAgICAgICAgcnVsZXM6IHtcclxuICAgICAgICAgICAgJ3RyYW5zaXRpb24nOiAnbGVmdCAyNTBtcyBlYXNlLW91dCcsXHJcbiAgICAgICAgICAgIGxlZnQ6ICcxMDAlJ1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgICAgc2VsZWN0b3I6IFwiLnRlc3QtZW50ZXIudGVzdC1lbnRlci1hY3RpdmVcIixcclxuICAgICAgICBydWxlczoge1xyXG4gICAgICAgICAgICBsZWZ0OiAwXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgICBzZWxlY3RvcjogXCIudGVzdC1sZWF2ZVwiLFxyXG4gICAgICAgIHJ1bGVzOiB7XHJcbiAgICAgICAgICAgICd0cmFuc2l0aW9uJzogJ2xlZnQgMjUwbXMgZWFzZS1vdXQnLFxyXG4gICAgICAgICAgICBsZWZ0OiAwXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgICBzZWxlY3RvcjogXCIudGVzdC1sZWF2ZS50ZXN0LWxlYXZlLWFjdGl2ZVwiLFxyXG4gICAgICAgIHJ1bGVzOiB7XHJcbiAgICAgICAgICAgIGxlZnQ6ICctMTAwJSdcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICAgIHNlbGVjdG9yOiBcIi50ZXN0LWFwcGVhclwiLFxyXG4gICAgICAgIHJ1bGVzOiB7XHJcbiAgICAgICAgICAgICd0cmFuc2l0aW9uJzogJ3RvcCAyNTBtcyBlYXNlLW91dCcsXHJcbiAgICAgICAgICAgIHRvcDogJzEwMCUnLFxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgICAgc2VsZWN0b3I6IFwiLnRlc3QtYXBwZWFyLnRlc3QtYXBwZWFyLWFjdGl2ZVwiLFxyXG4gICAgICAgIHJ1bGVzOiB7XHJcbiAgICAgICAgICAgIHRvcDogMFxyXG4gICAgICAgIH1cclxuICAgIH1cclxuKTtcclxuXHJcbmNvbnN0IFdyYXBwZXIgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XHJcbiAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPENTU1RyYW5zaXRpb24gY29tcG9uZW50PVwiZGl2XCIgdHJhbnNpdGlvbk5hbWU9XCJ0ZXN0XCIgdHJhbnNpdGlvbkVudGVyVGltZW91dD17MjUwfSB0cmFuc2l0aW9uTGVhdmVUaW1lb3V0PXsyNTB9PlxyXG4gICAgICAgICAgICAgICAgPFNjcmVlblRyYW5zaXRpb24ga2V5PXtEYXRlLm5vdygpfT5cclxuICAgICAgICAgICAgICAgICAgICB7dGhpcy5wcm9wcy5jaGlsZHJlbn1cclxuICAgICAgICAgICAgICAgIDwvU2NyZWVuVHJhbnNpdGlvbj5cclxuICAgICAgICAgICAgPC9DU1NUcmFuc2l0aW9uPlxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxuLy8gd2luZG93LmJlbmNobWFyayA9IChpdGVyYXRpb25zLCBmaXJzdCwgc2Vjb25kKSA9PiB7XHJcbi8vICAgICBjb25zdCByID0gW107XHJcbi8vICAgICBmb3IgKGNvbnN0IHRlc3ROdW0gb2YgcmFuZ2Uoe2NvdW50OiAzMH0pKSB7XHJcbi8vICAgICAgICAgbGV0IGEgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuLy8gICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJhdGlvbnM7IGkgKz0gMSkge1xyXG4vLyAgICAgICAgICAgICBmaXJzdChpKTtcclxuLy8gICAgICAgICB9XHJcbi8vICAgICAgICAgYSA9IHBlcmZvcm1hbmNlLm5vdygpIC0gYTtcclxuLy9cclxuLy8gICAgICAgICBsZXQgYiA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG4vLyAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlcmF0aW9uczsgaSArPSAxKSB7XHJcbi8vICAgICAgICAgICAgIHNlY29uZChpKTtcclxuLy8gICAgICAgICB9XHJcbi8vICAgICAgICAgYiA9IHBlcmZvcm1hbmNlLm5vdygpIC0gYjtcclxuLy8gICAgICAgICByLnB1c2goW2EudG9GaXhlZCgzKSwgYi50b0ZpeGVkKDMpXSk7XHJcbi8vICAgICB9XHJcbi8vICAgICByZXR1cm4gcjtcclxuLy8gfTtcclxuLy9cclxuLy8gY29uc3QgY2hlY2tQcm9wID0gKG9iaiwgcHJvcCwgdmFsdWUpID0+IG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSA9PT0gdHJ1ZSAmJiBvYmpbcHJvcF0gPT09IHZhbHVlO1xyXG4vLyBjb25zdCB4ID0ge2E6IDEwLCBiOiAxMn07XHJcbi8vXHJcbi8vIGNvbnN0IHJlcyA9IGJlbmNobWFyaygxZTYsIChpKSA9PiAoaSAlIDIgPT09IDApID8gaSA+PiAxIDogMCwgKGkpID0+IChpICUgMiA9PT0gMCkgPyBpIC8gMiA6IDApO1xyXG4vLyBjb25zb2xlLmxvZyhyZXMubWFwKGkgPT4gaS5qb2luKCdcXHQnKSkuam9pbignXFxuJykpO1xyXG5cclxuLypcclxuY29uc3QgdXJsID0gXCJodHRwOi8vdmlnbmV0dGUxLndpa2lhLm5vY29va2llLm5ldC9iYXlvbmV0dGEvaW1hZ2VzL2UvZTMvQ2VyZXphX0JheW9uZXR0YV8yX3JlbmRlci5wbmcvcmV2aXNpb24vbGF0ZXN0P2NiPTIwMTQwNjE1MjEwMDI1XCI7XHJcbiovXHJcbmNvbnN0IHVybCA9IFwiaHR0cDovL2Fzc2V0czEuaWduaW1ncy5jb20vdGh1bWJzL3VzZXJVcGxvYWRlZC8yMDE0LzEwLzEyL0JheW9uZXR0YTJfMTI4MC0xNDEzMTQyNDUxMTAwLmpwZ1wiO1xyXG5cclxuLypcclxuZGVmaW5lU3R5bGVGb3JDb21wb25lbnQoXHJcbiAgICBCdXR0b24sXHJcbiAgICAnc3BlY2lhbCcsXHJcbiAgICB7XHJcbiAgICB9XHJcbik7XHJcbi4uLlxyXG48QnV0dG9uLlNwZWNpYWwgLz5cclxuKi9cclxuXHJcbmRlZmluZVN0eWxlRm9yQ29tcG9uZW50KFxyXG4gICAgQ2hlY2tib3gsICdhd2Vzb21lJyxcclxuICAgIHtcclxuICAgICAgICBub3JtYWw6IHtcclxuICAgICAgICAgICAgaWNvbkNvbG9yOiAnY3lhbidcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNoZWNrZWQ6IHtcclxuICAgICAgICAgICAgaWNvbkNvbG9yOiAnYmx1ZSdcclxuICAgICAgICB9XHJcbiAgICB9XHJcbik7XHJcbmRlZmluZVN0eWxlRm9yQ29tcG9uZW50KFxyXG4gICAgVG9nZ2xlLCAnYXdlc29tZScsXHJcbiAgICB7XHJcbiAgICAgICAgb246IHtcclxuICAgICAgICAgICAgdGh1bWJDb2xvcjogJ2JsdWUnLFxyXG4gICAgICAgICAgICB0cmFja0NvbG9yOiAnY3lhbidcclxuICAgICAgICB9XHJcbiAgICB9XHJcbik7XHJcblxyXG5pZiAoRW52aXJvbm1lbnQuYXBwID09PSBmYWxzZSkge1xyXG4gICAgZGVmaW5lQ29tcG9uZW50U3R5bGUoXHJcbiAgICAgICAgJ2dsb2JhbCcsXHJcbiAgICAgICAgJ2VsaXRlJyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFwiJCpcIjoge1xyXG4gICAgICAgICAgICAgICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCdcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXCIkaHRtbFwiOiB7XHJcbiAgICAgICAgICAgICAgICB3aWR0aDogJzEwMCUnLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAnMTAwJScsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIFwiJGJvZHlcIjoge1xyXG4gICAgICAgICAgICAgICAgZm9udEZhbWlseTogXCJSb2JvdG9cIixcclxuICAgICAgICAgICAgICAgIHBhZGRpbmc6IDAsXHJcbiAgICAgICAgICAgICAgICBtYXJnaW46IDAsXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogJzEwMCUnLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAnMTAwJScsXHJcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjZWVlJyxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXCIkaHRtbCwgJGJvZHlcIjoge1xyXG4gICAgICAgICAgICAgICAgV2Via2l0T3ZlcmZsb3dTY3JvbGxpbmc6ICd0b3VjaCdcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICk7XHJcbn0gZWxzZSB7XHJcbiAgICBkZWZpbmVDb21wb25lbnRTdHlsZShcclxuICAgICAgICAnZ2xvYmFsJyxcclxuICAgICAgICAnZWxpdGUnLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgXCIkKlwiOiB7XHJcbiAgICAgICAgICAgICAgICBib3hTaXppbmc6ICdib3JkZXItYm94J1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBcIiRib2R5XCI6IHtcclxuICAgICAgICAgICAgICAgIGZvbnRGYW1pbHk6IFwiUm9ib3RvXCIsXHJcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjZWVlJyxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXCIkaHRtbCwgJGJvZHlcIjoge1xyXG4gICAgICAgICAgICAgICAgcGFkZGluZzogMCxcclxuICAgICAgICAgICAgICAgIG1hcmdpbjogMCxcclxuICAgICAgICAgICAgICAgIHdpZHRoOiAnMTAwJScsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6ICcxMDAlJyxcclxuICAgICAgICAgICAgICAgIG92ZXJmbG93OiAnaGlkZGVuJ1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgKTtcclxufVxyXG5cclxuZGVmaW5lQ29tcG9uZW50U3R5bGUoXHJcbiAgICAnYXBwJyxcclxuICAgICdjb3JlJyxcclxuICAgIHtcclxuICAgIH1cclxuKTtcclxuZGVmaW5lQ29tcG9uZW50U3R5bGUoXHJcbiAgICAncm9ib3RvJyxcclxuICAgICdmb250JyxcclxuICAgIHtcIiRAZm9udC1mYWNlXCI6IGdlbkZvbnRDU1MoXCJSb2JvdG9cIiwgUm9ib3RvVVJJKX1cclxuKTtcclxuZGVmaW5lQ29tcG9uZW50U3R5bGUoXHJcbiAgICAnaW9uaWMnLFxyXG4gICAgJ2ZvbnQnLFxyXG4gICAge1wiJEBmb250LWZhY2VcIjogZ2VuRm9udENTUyhcIklvbmljXCIsIElvbmljVVJJKX1cclxuKTtcclxuXHJcbmNvbnN0IHRpdGxlSGVpZ2h0ID0gNDA7XHJcbmNvbnN0IHRpdGxlQ29tbW9uU3R5bGUgPSB7XHJcbiAgICB0b3A6IDAsXHJcbiAgICBsZWZ0OiAwLFxyXG4gICAgcmlnaHQ6IDAsXHJcbiAgICBoZWlnaHQ6IHRpdGxlSGVpZ2h0LFxyXG4gICAgYmFja2dyb3VuZENvbG9yOiBjb29sQmx1ZSxcclxuICAgIHpJbmRleDogJysxMCcsXHJcbiAgICBib3hTaGFkb3c6ICcwcHggNHB4IDRweCByZ2JhKDAsIDAsIDAsIDAuNCknLFxyXG4gICAgY29sb3I6ICd3aGl0ZScsXHJcbiAgICBmb250U2l6ZTogMjBcclxufTtcclxuZGVmaW5lQ29tcG9uZW50U3R5bGUoXHJcbiAgICAnYXBwLXNjcmVlbicsXHJcbiAgICAnY29yZScsXHJcbiAgICB7XHJcbiAgICAgICAgXCJjb250ZW50XCI6IHtcclxuICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXHJcbiAgICAgICAgICAgIHRvcDogdGl0bGVIZWlnaHQsXHJcbiAgICAgICAgICAgIGJvdHRvbTogMCxcclxuICAgICAgICAgICAgbGVmdDogMCxcclxuICAgICAgICAgICAgcmlnaHQ6IDAsXHJcbiAgICAgICAgICAgIG92ZXJmbG93OiAnYXV0bydcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwidGl0bGVcIjoge1xyXG4gICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcclxuICAgICAgICAgICAgLi4udGl0bGVDb21tb25TdHlsZVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuKTtcclxuZGVmaW5lQ29tcG9uZW50U3R5bGUoXHJcbiAgICAnd2ViLXNjcmVlbicsXHJcbiAgICAnY29yZScsXHJcbiAgICB7XHJcbiAgICAgICAgXCJjb250ZW50XCI6IHtcclxuICAgICAgICAgICAgbWFyZ2luVG9wOiB0aXRsZUhlaWdodFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJ0aXRsZVwiOiB7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxyXG4gICAgICAgICAgICAuLi50aXRsZUNvbW1vblN0eWxlXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4pO1xyXG5cclxuY29uc3QgdGl0bGVDbGFzc05hbWUgPSBFbnZpcm9ubWVudC5hcHAgPT09IHRydWUgPyBcImFwcC1zY3JlZW4tY29yZS10aXRsZVwiIDogXCJ3ZWItc2NyZWVuLWNvcmUtdGl0bGVcIjtcclxuY29uc3QgY29udGVudENsYXNzTmFtZSA9IEVudmlyb25tZW50LmFwcCA9PT0gdHJ1ZSA/IFwiYXBwLXNjcmVlbi1jb3JlLWNvbnRlbnRcIiA6IFwid2ViLXNjcmVlbi1jb3JlLWNvbnRlbnRcIjtcclxuY2xhc3MgU2NyZWVuIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XHJcbiAgICAgICAgc3VwZXIocHJvcHMpO1xyXG4gICAgfVxyXG5cclxuICAgIHJlbmRlciA9ICgpID0+IHtcclxuXHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPGRpdj5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjb250ZW50Q2xhc3NOYW1lfT57dGhpcy5wcm9wcy5jaGlsZHJlbn08L2Rpdj5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXt0aXRsZUNsYXNzTmFtZX0+XHJcbiAgICAgICAgICAgICAgICAgICAgPENlbnRlckNvbnRlbnQgaGVpZ2h0PVwiMTAwJVwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7dGhpcy5wcm9wcy50aXRsZX1cclxuICAgICAgICAgICAgICAgICAgICA8L0NlbnRlckNvbnRlbnQ+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDxEaWFsb2dDb21wb25lbnQgLz5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgKTtcclxuICAgIH1cclxufVxyXG5cclxuY29uc3QgTWFpbiA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcclxuICAgIGFzeW5jIGRlbW8oKSB7XHJcbiAgICAgICAgaWYgKGF3YWl0IERpYWxvZy5jb25maXJtKFwiUmVhbGx5P1wiKSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIk5vcGUhXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBnZXRJbml0aWFsU3RhdGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgY2hlY2tlZDogZmFsc2UsXHJcbiAgICAgICAgICAgIG9uOiBmYWxzZSxcclxuICAgICAgICAgICAgZGlzYWJsZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgICBidXR0b246IHtcclxuICAgICAgICAgICAgICAgIGltYWdlOiBmYWxzZVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBpbmRleDogLTEsXHJcbiAgICAgICAgICAgIHRleHQ6IFwiXCIsXHJcbiAgICAgICAgICAgIHBhc3N3b3JkOiBcIlwiLFxyXG4gICAgICAgICAgICB2YWx1ZTogbnVsbCxcclxuICAgICAgICAgICAgZGF0ZTogY2hyb25vKCksXHJcbiAgICAgICAgICAgIHJhbmdlVmFsdWU6IDEwMFxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgcmVuZGVyKCkge1xyXG4gICAgICAgIGNvbnN0IHtkaXNhYmxlZH0gPSB0aGlzLnN0YXRlO1xyXG4gICAgICAgIGNvbnN0IHRleHRIYW5kbGVyID0gKHRleHQsIHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCd2YWx1ZScsIHZhbHVlKTtcclxuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7dGV4dCwgdmFsdWV9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIDxTY3JlZW4gdGl0bGU9XCJUZXN0XCIgYmFja1RleHQ9e1widGVzdFwifSB3aWR0aD17NjAwfSBvbkJhY2s9e3RoaXMuZGVtb30+XHJcbiAgICAgICAgICAgICAgICA8SW5wdXQuVGV4dCAvPlxyXG4gICAgICAgICAgICAgICAgPElucHV0LkRhdGUgLz5cclxuICAgICAgICAgICAgICAgIDxDb21ib2JveCBzZWxlY3RlZEluZGV4PXswfT5cclxuICAgICAgICAgICAgICAgICAgICB7YXJhbmdlKDMwLCBuID0+IDxPcHRpb24+e259PC9PcHRpb24+KX1cclxuICAgICAgICAgICAgICAgIDwvQ29tYm9ib3g+XHJcbiAgICAgICAgICAgICAgICB7YXJhbmdlKDYwLCBuID0+IDxkaXY+e259PC9kaXY+KX1cclxuICAgICAgICAgICAgICAgIHsvKjxJbWFnZSBzb3VyY2U9e3VybH0gaGVpZ2h0PXsxNTB9IGNvbG9yPVwiY3lhblwiIC8+Ki99XHJcbiAgICAgICAgICAgICAgICB7Lyo8VG9nZ2xlLkF3ZXNvbWUgb249e3RoaXMuc3RhdGUub259IG9uQ2hhbmdlPXtvbiA9PiB0aGlzLnNldFN0YXRlKHtvbn0pfSBsYWJlbD17XCJUZXN0XCJ9IHN1YlRpdGxlPVwibW9yZSB0ZXh0P1wiIC8+Ki99XHJcbiAgICAgICAgICAgICAgICB7Lyo8QnV0dG9uIHRleHQ9ezxzcGFuPntkaXNhYmxlZCA/IDxTcGlubmVyIHNpemU9ezIwfSAvPiA6IG51bGx9QnV0dG9uIFRleHQ8L3NwYW4+fSBkaXNhYmxlZD17ZGlzYWJsZWR9IG9uVGFwPXsoKSA9PiB0aGlzLnNldFN0YXRlKHtkaXNhYmxlZDogdHJ1ZX0pfSAvPiovfVxyXG4gICAgICAgICAgICAgICAgey8qPEljb24gbmFtZT1cImlvbi1jYWxlbmRhclwiIHNpemU9ezIwfSAvPiovfVxyXG4gICAgICAgICAgICAgICAgey8qPFJhZGlvIHNlbGVjdGVkSW5kZXg9e3RoaXMuc3RhdGUuaW5kZXh9IG9uQ2hhbmdlPXtpbmRleCA9PiB0aGlzLnNldFN0YXRlKHtpbmRleH0pfSB0aXRsZT1cIlRlc3RcIj5cclxuICAgICAgICAgICAgICAgICAgICB7QXJyYXkuZnJvbShyYW5nZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50OiAxMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWFwOiBuID0+IDxPcHRpb24gdmFsdWU9e24gKiogbn0+e259PC9PcHRpb24+XHJcbiAgICAgICAgICAgICAgICAgICAgfSkpfVxyXG4gICAgICAgICAgICAgICAgICAgIDxPcHRpb24+PEltYWdlIHNvdXJjZT17dXJsfSBoZWlnaHQ9ezMwfSAvPjwvT3B0aW9uPlxyXG4gICAgICAgICAgICAgICAgPC9SYWRpbz4qL31cclxuICAgICAgICAgICAgICAgIHsvKjxCdXR0b24gdGV4dD1cIlRlc3RcIiAvPiovfVxyXG4gICAgICAgICAgICAgICAgey8qPGRpdiBzdHlsZT17e3dpZHRoOiAnNzUlJywgbWF4V2lkdGg6IDQ4MH19PlxyXG4gICAgICAgICAgICAgICAgICAgIDxDYWxlbmRhciBzZWxlY3RlZERhdGU9e25ldyBEYXRlKCl9IC8+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj4qL31cclxuICAgICAgICAgICAgICAgIHsvKjxJbnB1dC5EYXRlIG9uQ2hhbmdlPXtkYXRlID0+IHRoaXMuc2V0U3RhdGUoe2RhdGV9KX0gZGF0ZT17dGhpcy5zdGF0ZS5kYXRlfSBsYWJlbD1cIk15IEJpcnRoZGF5P1wiIGljb25OYW1lPVwiaW9uLWNhbGVuZGFyXCIgZm9ybWF0PXtcIkV4cGlyYXRpb24gRGF0ZToge21vbnRofS97ZGF5fS97eWVhcn1cIn0gLz4qL31cclxuICAgICAgICAgICAgICAgIHsvKjxCdXR0b24gdGV4dD1cIldhdFwiIG9uVGFwPXsoKSA9PiBkaWFsb2cuc2hvdyh7Y29udGVudDogPENhbGVuZGFyIHNlbGVjdGVkRGF0ZT17bmV3IERhdGUoKX0gb25EYXRlU2VsZWN0ZWQ9e2NibG9nfSAvPiwgdGl0bGU6IFwiU2VsZWN0IERhdGVcIiwgYnV0dG9uczogW3t0ZXh0OiBcIkNhbmNlbFwifV19KX0gLz4qL31cclxuICAgICAgICAgICAgICAgIHsvKjxpbnB1dCB0eXBlPVwiZGF0ZXRpbWVcIiAvPiovfVxyXG4gICAgICAgICAgICAgICAgey8qPGlucHV0IHR5cGU9XCJ0aW1lXCIgb25DaGFuZ2U9e2V2dCA9PiBjYmxvZyhldnQudGFyZ2V0LnZhbHVlKX0gcmVmPVwidGVzdFwiIC8+Ki99XHJcbiAgICAgICAgICAgICAgICB7Lyo8VGltZUlucHV0IC8+Ki99XHJcbiAgICAgICAgICAgICAgICB7Lyo8Q2FyZD5cclxuICAgICAgICAgICAgICAgICAgICA8UmFuZ2VJbnB1dCB2YWx1ZT17dGhpcy5zdGF0ZS5yYW5nZVZhbHVlfSBtYXg9ezI1NX0gb25DaGFuZ2U9e3JhbmdlVmFsdWUgPT4gdGhpcy5zZXRTdGF0ZSh7cmFuZ2VWYWx1ZX0pfSAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwicmFuZ2VcIiB2YWx1ZT17dGhpcy5zdGF0ZS5yYW5nZVZhbHVlfSBtYXg9ezI1NX0gb25DaGFuZ2U9e2V2dCA9PiB0aGlzLnNldFN0YXRlKHtyYW5nZVZhbHVlOiBldnQudGFyZ2V0LnZhbHVlfSl9IC8+XHJcbiAgICAgICAgICAgICAgICA8L0NhcmQ+Ki99XHJcbiAgICAgICAgICAgICAgICB7Lyo8SW5wdXQuVVJMIGxhYmVsPVwiVVJMXCIgdmFsdWU9e3RoaXMuc3RhdGUudGV4dH0gb25DaGFuZ2U9eyh0ZXh0LCB2YWxpZCkgPT4ge2NvbnNvbGUubG9nKHRleHQsIHZhbGlkKTsgdGhpcy5zZXRTdGF0ZSh7dGV4dH0pO319IC8+XHJcbiAgICAgICAgICAgICAgICA8SW5wdXQuRW1haWwgbGFiZWw9XCJFbWFpbFwiIHZhbHVlPXt0aGlzLnN0YXRlLnRleHR9IG9uQ2hhbmdlPXsodGV4dCwgdmFsaWQpID0+IHtjb25zb2xlLmxvZyh0ZXh0LCB2YWxpZCk7IHRoaXMuc2V0U3RhdGUoe3RleHR9KTt9fSAvPlxyXG4gICAgICAgICAgICAgICAgPElucHV0LlBhc3N3b3JkIGxhYmVsPVwiUGFzc3dvcmRcIiB2YWx1ZT17dGhpcy5zdGF0ZS5wYXNzd29yZH0gb25DaGFuZ2U9e3Bhc3N3b3JkID0+IHRoaXMuc2V0U3RhdGUoe3Bhc3N3b3JkfSl9IC8+XHJcbiAgICAgICAgICAgICAgICA8SW5wdXQuUmFuZ2UgdmFsdWU9e3RoaXMuc3RhdGUucmFuZ2VWYWx1ZX0gbWF4PXsyNTV9IG9uQ2hhbmdlPXtyYW5nZVZhbHVlID0+IHRoaXMuc2V0U3RhdGUoe3JhbmdlVmFsdWV9KX0gLz5cclxuICAgICAgICAgICAgICAgIDxGaWxlSW5wdXQgdGV4dD1cIlRlc3RcIiBvbkNoYW5nZT17ZmlsZXMgPT4gY29uc29sZS5sb2coZmlsZXMpfSBtdWx0aXBsZSAvPiovfVxyXG4gICAgICAgICAgICAgICAgey8qPFRpbWVTZWxlY3RvciB2YWx1ZT17dGhpcy5zdGF0ZS5kYXRlfSBvbkNoYW5nZT17ZGF0ZSA9PiB0aGlzLnNldFN0YXRlKHtkYXRlfSl9IC8+Ki99XHJcbiAgICAgICAgICAgICAgICB7Lyo8SW5wdXQuVGltZSB2YWx1ZT17dGhpcy5zdGF0ZS5kYXRlfSBvbkNoYW5nZT17ZGF0ZSA9PiB0aGlzLnNldFN0YXRlKHtkYXRlfSl9IC8+XHJcbiAgICAgICAgICAgICAgICA8SW5wdXQuRGF0ZSB2YWx1ZT17dGhpcy5zdGF0ZS5kYXRlfSBvbkNoYW5nZT17ZGF0ZSA9PiB0aGlzLnNldFN0YXRlKHtkYXRlfSl9IC8+Ki99XHJcbiAgICAgICAgICAgICAgICB7Lyo8SW5wdXQuRmlsZSBvbkNoYW5nZT17Y2Jsb2d9IHRleHQ9XCJTZWxlY3QgRmlsZVwiIC8+Ki99XHJcbiAgICAgICAgICAgICAgICB7Lyo8RmxleGJveCBjb2xDb3VudD17M30gcGFkRW5kIG1heEl0ZW1XaWR0aD17MTAwfSBhbGlnbj1cInNwYWNlLWFyb3VuZFwiPlxyXG4gICAgICAgICAgICAgICAgICAgIHthcmFuZ2UoMTEsIG4gPT4gPEJ1dHRvbiB0ZXh0PXtufSBibG9jayBmbHVzaCAvPil9XHJcbiAgICAgICAgICAgICAgICA8L0ZsZXhib3g+Ki99XHJcbiAgICAgICAgICAgICAgICB7Lyo8R3JpZCBjb2xDb3VudD17M30gcm93Q291bnQ9ezR9PlxyXG4gICAgICAgICAgICAgICAgICAgIHthcmFuZ2UoMTEsIG4gPT4gPEJ1dHRvbiB0ZXh0PXtufSBmbHVzaCBmaWxsIC8+KX1cclxuICAgICAgICAgICAgICAgIDwvR3JpZD4qL31cclxuICAgICAgICAgICAgICAgIHsvKjxQaW5ib2FyZCBoZWlnaHQ9ezIwMH0+XHJcbiAgICAgICAgICAgICAgICAgICAge2FyYW5nZSgxMixcclxuICAgICAgICAgICAgICAgICAgICAgICAgbiA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhbmdsZSA9IChuIC8gNikgKiBNYXRoLlBJO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeCA9IE1hdGguY29zKGFuZ2xlKSAqIDcwICsgMTQ1O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeSA9IE1hdGguc2luKGFuZ2xlKSAqIDcwICsgODU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwb3MgPSB7dG9wOiB5LCBsZWZ0OiB4LCB3aWR0aDogMzAsIGhlaWdodDogMzB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA8ZGl2IHBpbkluZm89e3Bvc30gc3R5bGU9e3t3aWR0aDogJzEwMCUnLCBoZWlnaHQ6ICcxMDAlJywgYmFja2dyb3VuZENvbG9yOiAnY3lhbid9fT57bn08L2Rpdj47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICApfVxyXG4gICAgICAgICAgICAgICAgPC9QaW5ib2FyZD4qL31cclxuICAgICAgICAgICAgICAgIHsvKjxJbnB1dC5TZWFyY2ggaWNvbk5hbWU9XCJpb24tc2VhcmNoXCIgcGxhY2Vob2xkZXI9XCJTZWFyY2ggU3R1ZmZzXCIgLz4qL31cclxuICAgICAgICAgICAgICAgIHsvKjxDaGVja2JveC5Bd2Vzb21lIGNoZWNrZWQ9e3RoaXMuc3RhdGUuY2hlY2tlZH0gb25DaGFuZ2U9e2NoZWNrZWQgPT4gdGhpcy5zZXRTdGF0ZSh7Y2hlY2tlZH0pfSBsYWJlbD17XCJUZXN0XCJ9IHN1YlRpdGxlPVwibW9yZSB0ZXh0P1wiIC8+Ki99XHJcbiAgICAgICAgICAgICAgICB7Lyo8QnV0dG9uIHRleHQ9XCJOb3JtYWxcIiAvPlxyXG4gICAgICAgICAgICAgICAgPEJ1dHRvbiB0ZXh0PVwiRGlzYWJsZWRcIiBkaXNhYmxlZCAvPlxyXG4gICAgICAgICAgICAgICAgPEJ1dHRvbi5DYW5jZWwgdGV4dD1cIkNhbmNlbFwiIC8+XHJcbiAgICAgICAgICAgICAgICA8QnV0dG9uLkNvbmZpcm0gdGV4dD1cIkNvbmZpcm1cIiAvPlxyXG4gICAgICAgICAgICAgICAgPElucHV0LlJhbmdlIHZhbHVlPXt0aGlzLnN0YXRlLnJhbmdlVmFsdWV9IG1heD17MjU1fSBvbkNoYW5nZT17cmFuZ2VWYWx1ZSA9PiB0aGlzLnNldFN0YXRlKHtyYW5nZVZhbHVlfSl9IC8+Ki99XHJcbiAgICAgICAgICAgICAgICB7Lyo8Rm9ybSBsYWJlbD1cIkZvcm1cIj4qL31cclxuICAgICAgICAgICAgICAgICAgICB7Lyo8UmFkaW8gbGF5b3V0PXtQaW5ib2FyZH0gbGF5b3V0LWhlaWdodD17MjAwfT5cclxuICAgICAgICAgICAgICAgICAgICAgICAge2FyYW5nZSgxMixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4gPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFuZ2xlID0gKG4gLyA2KSAqIE1hdGguUEk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeCA9IE1hdGguY29zKGFuZ2xlKSAqIDcwICsgMTQ1O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHkgPSBNYXRoLnNpbihhbmdsZSkgKiA3MCArIDg1O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvcyA9IHt0b3A6IHksIGxlZnQ6IHgsIHdpZHRoOiAzMCwgaGVpZ2h0OiAzMH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA8ZGl2IHBpbkluZm89e3Bvc30gc3R5bGU9e3t3aWR0aDogJzEwMCUnLCBoZWlnaHQ6ICcxMDAlJ319PntufTwvZGl2PjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgKX1cclxuICAgICAgICAgICAgICAgICAgICA8L1JhZGlvPiovfVxyXG4gICAgICAgICAgICAgICAgICAgIHsvKjxSYWRpbyB0aXRsZT1cIlRlc3RcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAge0FycmF5LmZyb20ocmFuZ2Uoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnQ6IDEwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwOiBuID0+IDxPcHRpb24gdmFsdWU9e24gKiogbn0+e259PC9PcHRpb24+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgPE9wdGlvbj48SW1hZ2Ugc291cmNlPXt1cmx9IGhlaWdodD17MzB9IC8+PC9PcHRpb24+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9SYWRpbz4qL31cclxuICAgICAgICAgICAgICAgICAgICB7Lyo8SW5wdXQuVGV4dCBmb3JtTmFtZT1cIlRleHRcIiBwbGFjZWhvbGRlcj1cIlRleHRcIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDxJbnB1dC5QYXNzd29yZCBmb3JtTmFtZT1cIlBhc3N3b3JkXCIgcGxhY2Vob2xkZXI9XCJQYXNzd29yZFwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPElucHV0LlNlYXJjaCBmb3JtTmFtZT1cIlNlYXJjaFwiIHBsYWNlaG9sZGVyPVwiU2VhcmNoXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICA8SW5wdXQuVVJMIGZvcm1OYW1lPVwiVVJMXCIgcGxhY2Vob2xkZXI9XCJVUkxcIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDxJbnB1dC5FbWFpbCBmb3JtTmFtZT1cIkVtYWlsXCIgcGxhY2Vob2xkZXI9XCJFbWFpbFwiIC8+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIDxJbnB1dC5EYXRlIGZvcm1OYW1lPVwiZGF0ZVwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPElucHV0LlRpbWUgZm9ybU5hbWU9XCJ0aW1lXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICA8SW5wdXQuRmlsZSBmb3JtTmFtZT1cImZpbGVcIiBtdWx0aXBsZSB2YWx1ZUZvcm1hdD17bGlzdCA9PiBgRmlsZXMgU2VsZWN0ZWQ6ICR7bGlzdC5sZW5ndGh9YH0gLz5cclxuICAgICAgICAgICAgICAgICAgICA8SW5wdXQuUmFuZ2UgZm9ybU5hbWU9XCJyYW5nZVwiIG1pbj17MH0gbWF4PXsyNTV9IC8+Ki99XHJcbiAgICAgICAgICAgICAgICB7Lyo8L0Zvcm0+Ki99XHJcbiAgICAgICAgICAgICAgICB7Lyo8ZGl2IHN0eWxlPXt7cG9zaXRpb246ICdhYnNvbHV0ZScsIGJvdHRvbTogMCwgaGVpZ2h0OiA1MCwgd2lkdGg6IDUwLCBiYWNrZ3JvdW5kQ29sb3I6ICdjeWFuJ319IC8+Ki99XHJcbiAgICAgICAgICAgICAgICB7Lyo8SW5wdXQuRmlsZSovfVxyXG4gICAgICAgICAgICAgICAgey8qPENhcmQ+XHJcbiAgICAgICAgICAgICAgICAgICAgPFBpbmJvYXJkIGhlaWdodD17NTB9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8SWNvbiBuYW1lPVwiaW9uLWhhcHB5XCIgc2l6ZT17NDB9IHBpbkluZm89e3t0b3A6IDAsIGxlZnQ6IDEwLCB3aWR0aDogNDAsIGhlaWdodDogNTB9fSAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IHBpbkluZm89e3t0b3A6IDAsIGxlZnQ6IDU1fX0+VXNlciBOYW1lIFRoaW5nPzwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IHBpbkluZm89e3t0b3A6IDMwLCBsZWZ0OiA1NSwgZm9udFNpemU6IDExfX0+VXNlciBpbmZvcm1hdGlvbiBhYm91dCBwb3NpdGlvbmQgYW5kIHN0dWZmPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgcGluSW5mbz17e3RvcDogNSwgbGVmdDogNSwgd2lkdGg6IDEwLCBoZWlnaHQ6IDEwLCBiYWNrZ3JvdW5kQ29sb3I6ICdjeWFuJ319IC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9QaW5ib2FyZD5cclxuICAgICAgICAgICAgICAgIDwvQ2FyZD4qL31cclxuICAgICAgICAgICAgPC9TY3JlZW4+XHJcbiAgICAgICAgKTtcclxuICAgIH1cclxufSk7XHJcblxyXG4vLyBBcHAuc3RhcnQoXHJcbi8vICAgICA8Um91dGUgY29tcG9uZW50PXtXcmFwcGVyfT5cclxuLy8gICAgICAgICA8Um91dGUgcGF0aD1cIi9cIiBjb21wb25lbnQ9e01haW59IC8+XHJcbi8vICAgICAgICAgPFJvdXRlIHBhdGg9XCIvdGVzdFwiIGNvbXBvbmVudD17TWFpbn0gLz5cclxuLy8gICAgIDwvUm91dGU+XHJcbi8vICk7XHJcbndpbmRvdy5xc2VsID0gKC4uLmFyZ3MpID0+IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoLi4uYXJncyk7XHJcbmNyZWF0ZVN0eWxlcygpO1xyXG4oYXN5bmMgKCkgPT4ge1xyXG4gICAgYXdhaXQgZGV2aWNlUmVhZHk7XHJcbiAgICBSZWFjdERPTS5yZW5kZXIoXHJcbiAgICAgICAgPE1haW4gLz4sXHJcbiAgICAgICAgcXNlbChcIiNhcHAtY29udGFpbmVyXCIpXHJcbiAgICApO1xyXG59KSgpO1xyXG5cclxuLy8gY29uc3QgdG9rZW4gPSBhamF4LmNhbmNlbFRva2VuKCk7XHJcbi8vIChhc3luYyAoKSA9PiB7XHJcbi8vICAgICBjb25zb2xlLmxvZyhhd2FpdCBhamF4KFwiaHR0cDovL2F4ZWw2NjkubmV0L2VjaG8vaW5kZXgyLnBocFwiLCB7cG9zdDogWzEsIDIsIDMsIDRdLCB0b2tlbn0pKTtcclxuLy8gfSkoKTtcclxuLy8gY2hyb25vLnRyaWdnZXIoMjAwMCwgdG9rZW4uY2FuY2VsKTtcclxuXHJcbi8vIGNvbnN0IGlzUG93MiA9IG4gPT4gKG4gJiAtbikgPT09IG47XHJcbi8vIHdpbmRvdy5jb2xsYXR6ID0gbiA9PiAobiAlIDIgPT09IDApID8gbiAvIDIgOiAzICogbiArIDE7XHJcbi8vIHdpbmRvdy5jaGVjayA9IHN0YXJ0ID0+IHtcclxuLy8gICAgIHdoaWxlICh0cnVlKSB7XHJcbi8vICAgICAgICAgaWYgKHN0YXJ0ID09PSAxKSB7XHJcbi8vICAgICAgICAgICAgIGJyZWFrO1xyXG4vLyAgICAgICAgIH1cclxuLy8gICAgICAgICBjb25zb2xlLmxvZyhzdGFydCk7XHJcbi8vICAgICAgICAgc3RhcnQgPSBjb2xsYXR6KHN0YXJ0KTtcclxuLy8gICAgIH1cclxuLy8gfTtcclxuLy9cclxuLy8gY29uc3QgZiA9IG4gPT4gKG4gJiAtbik7XHJcbi8vIGZvciAoY29uc3QgaSBvZiBmcmFuZ2UoMTAwKSkge1xyXG4vLyAgICAgY29uc29sZS5sb2coaSwgZihpKSk7XHJcbi8vIH1cclxuIl19
