(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
module.exports = "/*\r\n Copyright (c) 2013 Gildas Lormeau. All rights reserved.\r\n\r\n Redistribution and use in source and binary forms, with or without\r\n modification, are permitted provided that the following conditions are met:\r\n\r\n 1. Redistributions of source code must retain the above copyright notice,\r\n this list of conditions and the following disclaimer.\r\n\r\n 2. Redistributions in binary form must reproduce the above copyright\r\n notice, this list of conditions and the following disclaimer in\r\n the documentation and/or other materials provided with the distribution.\r\n\r\n 3. The names of the authors may not be used to endorse or promote products\r\n derived from this software without specific prior written permission.\r\n\r\n THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,\r\n INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\r\n FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,\r\n INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,\r\n INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\r\n LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\r\n OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\r\n LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\r\n NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\r\n EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\n/*\r\n * This program is based on JZlib 1.0.2 ymnk, JCraft,Inc.\r\n * JZlib is based on zlib-1.1.3, so all credit should go authors\r\n * Jean-loup Gailly(jloup@gzip.org) and Mark Adler(madler@alumni.caltech.edu)\r\n * and contributors of zlib.\r\n */\r\n\r\n(function(global) {\r\n    \"use strict\";\r\n\r\n    // Global\r\n\r\n    var MAX_BITS = 15;\r\n    var D_CODES = 30;\r\n    var BL_CODES = 19;\r\n\r\n    var LENGTH_CODES = 29;\r\n    var LITERALS = 256;\r\n    var L_CODES = (LITERALS + 1 + LENGTH_CODES);\r\n    var HEAP_SIZE = (2 * L_CODES + 1);\r\n\r\n    var END_BLOCK = 256;\r\n\r\n    // Bit length codes must not exceed MAX_BL_BITS bits\r\n    var MAX_BL_BITS = 7;\r\n\r\n    // repeat previous bit length 3-6 times (2 bits of repeat count)\r\n    var REP_3_6 = 16;\r\n\r\n    // repeat a zero length 3-10 times (3 bits of repeat count)\r\n    var REPZ_3_10 = 17;\r\n\r\n    // repeat a zero length 11-138 times (7 bits of repeat count)\r\n    var REPZ_11_138 = 18;\r\n\r\n    // The lengths of the bit length codes are sent in order of decreasing\r\n    // probability, to avoid transmitting the lengths for unused bit\r\n    // length codes.\r\n\r\n    var Buf_size = 8 * 2;\r\n\r\n    // JZlib version : \"1.0.2\"\r\n    var Z_DEFAULT_COMPRESSION = -1;\r\n\r\n    // compression strategy\r\n    var Z_FILTERED = 1;\r\n    var Z_HUFFMAN_ONLY = 2;\r\n    var Z_DEFAULT_STRATEGY = 0;\r\n\r\n    var Z_NO_FLUSH = 0;\r\n    var Z_PARTIAL_FLUSH = 1;\r\n    var Z_FULL_FLUSH = 3;\r\n    var Z_FINISH = 4;\r\n\r\n    var Z_OK = 0;\r\n    var Z_STREAM_END = 1;\r\n    var Z_NEED_DICT = 2;\r\n    var Z_STREAM_ERROR = -2;\r\n    var Z_DATA_ERROR = -3;\r\n    var Z_BUF_ERROR = -5;\r\n\r\n    // Tree\r\n\r\n    // see definition of array dist_code below\r\n    var _dist_code = [ 0, 1, 2, 3, 4, 4, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\r\n            10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\r\n            12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\r\n            13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\r\n            14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\r\n            14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\r\n            15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 16, 17, 18, 18, 19, 19,\r\n            20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\r\n            24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,\r\n            26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,\r\n            27, 27, 27, 27, 27, 27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,\r\n            28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 29,\r\n            29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,\r\n            29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29 ];\r\n\r\n    function Tree() {\r\n        var that = this;\r\n\r\n        // dyn_tree; // the dynamic tree\r\n        // max_code; // largest code with non zero frequency\r\n        // stat_desc; // the corresponding static tree\r\n\r\n        // Compute the optimal bit lengths for a tree and update the total bit\r\n        // length\r\n        // for the current block.\r\n        // IN assertion: the fields freq and dad are set, heap[heap_max] and\r\n        // above are the tree nodes sorted by increasing frequency.\r\n        // OUT assertions: the field len is set to the optimal bit length, the\r\n        // array bl_count contains the frequencies for each bit length.\r\n        // The length opt_len is updated; static_len is also updated if stree is\r\n        // not null.\r\n        function gen_bitlen(s) {\r\n            var tree = that.dyn_tree;\r\n            var stree = that.stat_desc.static_tree;\r\n            var extra = that.stat_desc.extra_bits;\r\n            var base = that.stat_desc.extra_base;\r\n            var max_length = that.stat_desc.max_length;\r\n            var h; // heap index\r\n            var n, m; // iterate over the tree elements\r\n            var bits; // bit length\r\n            var xbits; // extra bits\r\n            var f; // frequency\r\n            var overflow = 0; // number of elements with bit length too large\r\n\r\n            for (bits = 0; bits <= MAX_BITS; bits++)\r\n                s.bl_count[bits] = 0;\r\n\r\n            // In a first pass, compute the optimal bit lengths (which may\r\n            // overflow in the case of the bit length tree).\r\n            tree[s.heap[s.heap_max] * 2 + 1] = 0; // root of the heap\r\n\r\n            for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {\r\n                n = s.heap[h];\r\n                bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;\r\n                if (bits > max_length) {\r\n                    bits = max_length;\r\n                    overflow++;\r\n                }\r\n                tree[n * 2 + 1] = bits;\r\n                // We overwrite tree[n*2+1] which is no longer needed\r\n\r\n                if (n > that.max_code)\r\n                    continue; // not a leaf node\r\n\r\n                s.bl_count[bits]++;\r\n                xbits = 0;\r\n                if (n >= base)\r\n                    xbits = extra[n - base];\r\n                f = tree[n * 2];\r\n                s.opt_len += f * (bits + xbits);\r\n                if (stree)\r\n                    s.static_len += f * (stree[n * 2 + 1] + xbits);\r\n            }\r\n            if (overflow === 0)\r\n                return;\r\n\r\n            // This happens for example on obj2 and pic of the Calgary corpus\r\n            // Find the first bit length which could increase:\r\n            do {\r\n                bits = max_length - 1;\r\n                while (s.bl_count[bits] === 0)\r\n                    bits--;\r\n                s.bl_count[bits]--; // move one leaf down the tree\r\n                s.bl_count[bits + 1] += 2; // move one overflow item as its brother\r\n                s.bl_count[max_length]--;\r\n                // The brother of the overflow item also moves one step up,\r\n                // but this does not affect bl_count[max_length]\r\n                overflow -= 2;\r\n            } while (overflow > 0);\r\n\r\n            for (bits = max_length; bits !== 0; bits--) {\r\n                n = s.bl_count[bits];\r\n                while (n !== 0) {\r\n                    m = s.heap[--h];\r\n                    if (m > that.max_code)\r\n                        continue;\r\n                    if (tree[m * 2 + 1] != bits) {\r\n                        s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];\r\n                        tree[m * 2 + 1] = bits;\r\n                    }\r\n                    n--;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Reverse the first len bits of a code, using straightforward code (a\r\n        // faster\r\n        // method would use a table)\r\n        // IN assertion: 1 <= len <= 15\r\n        function bi_reverse(code, // the value to invert\r\n        len // its bit length\r\n        ) {\r\n            var res = 0;\r\n            do {\r\n                res |= code & 1;\r\n                code >>>= 1;\r\n                res <<= 1;\r\n            } while (--len > 0);\r\n            return res >>> 1;\r\n        }\r\n\r\n        // Generate the codes for a given tree and bit counts (which need not be\r\n        // optimal).\r\n        // IN assertion: the array bl_count contains the bit length statistics for\r\n        // the given tree and the field len is set for all tree elements.\r\n        // OUT assertion: the field code is set for all tree elements of non\r\n        // zero code length.\r\n        function gen_codes(tree, // the tree to decorate\r\n        max_code, // largest code with non zero frequency\r\n        bl_count // number of codes at each bit length\r\n        ) {\r\n            var next_code = []; // next code value for each\r\n            // bit length\r\n            var code = 0; // running code value\r\n            var bits; // bit index\r\n            var n; // code index\r\n            var len;\r\n\r\n            // The distribution counts are first used to generate the code values\r\n            // without bit reversal.\r\n            for (bits = 1; bits <= MAX_BITS; bits++) {\r\n                next_code[bits] = code = ((code + bl_count[bits - 1]) << 1);\r\n            }\r\n\r\n            // Check that the bit counts in bl_count are consistent. The last code\r\n            // must be all ones.\r\n            // Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,\r\n            // \"inconsistent bit counts\");\r\n            // Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\r\n\r\n            for (n = 0; n <= max_code; n++) {\r\n                len = tree[n * 2 + 1];\r\n                if (len === 0)\r\n                    continue;\r\n                // Now reverse the bits\r\n                tree[n * 2] = bi_reverse(next_code[len]++, len);\r\n            }\r\n        }\r\n\r\n        // Construct one Huffman tree and assigns the code bit strings and lengths.\r\n        // Update the total bit length for the current block.\r\n        // IN assertion: the field freq is set for all tree elements.\r\n        // OUT assertions: the fields len and code are set to the optimal bit length\r\n        // and corresponding code. The length opt_len is updated; static_len is\r\n        // also updated if stree is not null. The field max_code is set.\r\n        that.build_tree = function(s) {\r\n            var tree = that.dyn_tree;\r\n            var stree = that.stat_desc.static_tree;\r\n            var elems = that.stat_desc.elems;\r\n            var n, m; // iterate over heap elements\r\n            var max_code = -1; // largest code with non zero frequency\r\n            var node; // new node being created\r\n\r\n            // Construct the initial heap, with least frequent element in\r\n            // heap[1]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\r\n            // heap[0] is not used.\r\n            s.heap_len = 0;\r\n            s.heap_max = HEAP_SIZE;\r\n\r\n            for (n = 0; n < elems; n++) {\r\n                if (tree[n * 2] !== 0) {\r\n                    s.heap[++s.heap_len] = max_code = n;\r\n                    s.depth[n] = 0;\r\n                } else {\r\n                    tree[n * 2 + 1] = 0;\r\n                }\r\n            }\r\n\r\n            // The pkzip format requires that at least one distance code exists,\r\n            // and that at least one bit should be sent even if there is only one\r\n            // possible code. So to avoid special checks later on we force at least\r\n            // two codes of non zero frequency.\r\n            while (s.heap_len < 2) {\r\n                node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;\r\n                tree[node * 2] = 1;\r\n                s.depth[node] = 0;\r\n                s.opt_len--;\r\n                if (stree)\r\n                    s.static_len -= stree[node * 2 + 1];\r\n                // node is 0 or 1 so it does not have extra bits\r\n            }\r\n            that.max_code = max_code;\r\n\r\n            // The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\r\n            // establish sub-heaps of increasing lengths:\r\n\r\n            for (n = Math.floor(s.heap_len / 2); n >= 1; n--)\r\n                s.pqdownheap(tree, n);\r\n\r\n            // Construct the Huffman tree by repeatedly combining the least two\r\n            // frequent nodes.\r\n\r\n            node = elems; // next internal node of the tree\r\n            do {\r\n                // n = node of least frequency\r\n                n = s.heap[1];\r\n                s.heap[1] = s.heap[s.heap_len--];\r\n                s.pqdownheap(tree, 1);\r\n                m = s.heap[1]; // m = node of next least frequency\r\n\r\n                s.heap[--s.heap_max] = n; // keep the nodes sorted by frequency\r\n                s.heap[--s.heap_max] = m;\r\n\r\n                // Create a new node father of n and m\r\n                tree[node * 2] = (tree[n * 2] + tree[m * 2]);\r\n                s.depth[node] = Math.max(s.depth[n], s.depth[m]) + 1;\r\n                tree[n * 2 + 1] = tree[m * 2 + 1] = node;\r\n\r\n                // and insert the new node in the heap\r\n                s.heap[1] = node++;\r\n                s.pqdownheap(tree, 1);\r\n            } while (s.heap_len >= 2);\r\n\r\n            s.heap[--s.heap_max] = s.heap[1];\r\n\r\n            // At this point, the fields freq and dad are set. We can now\r\n            // generate the bit lengths.\r\n\r\n            gen_bitlen(s);\r\n\r\n            // The field len is now set, we can generate the bit codes\r\n            gen_codes(tree, that.max_code, s.bl_count);\r\n        };\r\n\r\n    }\r\n\r\n    Tree._length_code = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16,\r\n            16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20,\r\n            20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\r\n            22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\r\n            24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,\r\n            25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,\r\n            26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 28 ];\r\n\r\n    Tree.base_length = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16, 20, 24, 28, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 0 ];\r\n\r\n    Tree.base_dist = [ 0, 1, 2, 3, 4, 6, 8, 12, 16, 24, 32, 48, 64, 96, 128, 192, 256, 384, 512, 768, 1024, 1536, 2048, 3072, 4096, 6144, 8192, 12288, 16384,\r\n            24576 ];\r\n\r\n    // Mapping from a distance to a distance code. dist is the distance - 1 and\r\n    // must not have side effects. _dist_code[256] and _dist_code[257] are never\r\n    // used.\r\n    Tree.d_code = function(dist) {\r\n        return ((dist) < 256 ? _dist_code[dist] : _dist_code[256 + ((dist) >>> 7)]);\r\n    };\r\n\r\n    // extra bits for each length code\r\n    Tree.extra_lbits = [ 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0 ];\r\n\r\n    // extra bits for each distance code\r\n    Tree.extra_dbits = [ 0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13 ];\r\n\r\n    // extra bits for each bit length code\r\n    Tree.extra_blbits = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7 ];\r\n\r\n    Tree.bl_order = [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];\r\n\r\n    // StaticTree\r\n\r\n    function StaticTree(static_tree, extra_bits, extra_base, elems, max_length) {\r\n        var that = this;\r\n        that.static_tree = static_tree;\r\n        that.extra_bits = extra_bits;\r\n        that.extra_base = extra_base;\r\n        that.elems = elems;\r\n        that.max_length = max_length;\r\n    }\r\n\r\n    StaticTree.static_ltree = [ 12, 8, 140, 8, 76, 8, 204, 8, 44, 8, 172, 8, 108, 8, 236, 8, 28, 8, 156, 8, 92, 8, 220, 8, 60, 8, 188, 8, 124, 8, 252, 8, 2, 8,\r\n            130, 8, 66, 8, 194, 8, 34, 8, 162, 8, 98, 8, 226, 8, 18, 8, 146, 8, 82, 8, 210, 8, 50, 8, 178, 8, 114, 8, 242, 8, 10, 8, 138, 8, 74, 8, 202, 8, 42,\r\n            8, 170, 8, 106, 8, 234, 8, 26, 8, 154, 8, 90, 8, 218, 8, 58, 8, 186, 8, 122, 8, 250, 8, 6, 8, 134, 8, 70, 8, 198, 8, 38, 8, 166, 8, 102, 8, 230, 8,\r\n            22, 8, 150, 8, 86, 8, 214, 8, 54, 8, 182, 8, 118, 8, 246, 8, 14, 8, 142, 8, 78, 8, 206, 8, 46, 8, 174, 8, 110, 8, 238, 8, 30, 8, 158, 8, 94, 8,\r\n            222, 8, 62, 8, 190, 8, 126, 8, 254, 8, 1, 8, 129, 8, 65, 8, 193, 8, 33, 8, 161, 8, 97, 8, 225, 8, 17, 8, 145, 8, 81, 8, 209, 8, 49, 8, 177, 8, 113,\r\n            8, 241, 8, 9, 8, 137, 8, 73, 8, 201, 8, 41, 8, 169, 8, 105, 8, 233, 8, 25, 8, 153, 8, 89, 8, 217, 8, 57, 8, 185, 8, 121, 8, 249, 8, 5, 8, 133, 8,\r\n            69, 8, 197, 8, 37, 8, 165, 8, 101, 8, 229, 8, 21, 8, 149, 8, 85, 8, 213, 8, 53, 8, 181, 8, 117, 8, 245, 8, 13, 8, 141, 8, 77, 8, 205, 8, 45, 8,\r\n            173, 8, 109, 8, 237, 8, 29, 8, 157, 8, 93, 8, 221, 8, 61, 8, 189, 8, 125, 8, 253, 8, 19, 9, 275, 9, 147, 9, 403, 9, 83, 9, 339, 9, 211, 9, 467, 9,\r\n            51, 9, 307, 9, 179, 9, 435, 9, 115, 9, 371, 9, 243, 9, 499, 9, 11, 9, 267, 9, 139, 9, 395, 9, 75, 9, 331, 9, 203, 9, 459, 9, 43, 9, 299, 9, 171, 9,\r\n            427, 9, 107, 9, 363, 9, 235, 9, 491, 9, 27, 9, 283, 9, 155, 9, 411, 9, 91, 9, 347, 9, 219, 9, 475, 9, 59, 9, 315, 9, 187, 9, 443, 9, 123, 9, 379,\r\n            9, 251, 9, 507, 9, 7, 9, 263, 9, 135, 9, 391, 9, 71, 9, 327, 9, 199, 9, 455, 9, 39, 9, 295, 9, 167, 9, 423, 9, 103, 9, 359, 9, 231, 9, 487, 9, 23,\r\n            9, 279, 9, 151, 9, 407, 9, 87, 9, 343, 9, 215, 9, 471, 9, 55, 9, 311, 9, 183, 9, 439, 9, 119, 9, 375, 9, 247, 9, 503, 9, 15, 9, 271, 9, 143, 9,\r\n            399, 9, 79, 9, 335, 9, 207, 9, 463, 9, 47, 9, 303, 9, 175, 9, 431, 9, 111, 9, 367, 9, 239, 9, 495, 9, 31, 9, 287, 9, 159, 9, 415, 9, 95, 9, 351, 9,\r\n            223, 9, 479, 9, 63, 9, 319, 9, 191, 9, 447, 9, 127, 9, 383, 9, 255, 9, 511, 9, 0, 7, 64, 7, 32, 7, 96, 7, 16, 7, 80, 7, 48, 7, 112, 7, 8, 7, 72, 7,\r\n            40, 7, 104, 7, 24, 7, 88, 7, 56, 7, 120, 7, 4, 7, 68, 7, 36, 7, 100, 7, 20, 7, 84, 7, 52, 7, 116, 7, 3, 8, 131, 8, 67, 8, 195, 8, 35, 8, 163, 8,\r\n            99, 8, 227, 8 ];\r\n\r\n    StaticTree.static_dtree = [ 0, 5, 16, 5, 8, 5, 24, 5, 4, 5, 20, 5, 12, 5, 28, 5, 2, 5, 18, 5, 10, 5, 26, 5, 6, 5, 22, 5, 14, 5, 30, 5, 1, 5, 17, 5, 9, 5,\r\n            25, 5, 5, 5, 21, 5, 13, 5, 29, 5, 3, 5, 19, 5, 11, 5, 27, 5, 7, 5, 23, 5 ];\r\n\r\n    StaticTree.static_l_desc = new StaticTree(StaticTree.static_ltree, Tree.extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);\r\n\r\n    StaticTree.static_d_desc = new StaticTree(StaticTree.static_dtree, Tree.extra_dbits, 0, D_CODES, MAX_BITS);\r\n\r\n    StaticTree.static_bl_desc = new StaticTree(null, Tree.extra_blbits, 0, BL_CODES, MAX_BL_BITS);\r\n\r\n    // Deflate\r\n\r\n    var MAX_MEM_LEVEL = 9;\r\n    var DEF_MEM_LEVEL = 8;\r\n\r\n    function Config(good_length, max_lazy, nice_length, max_chain, func) {\r\n        var that = this;\r\n        that.good_length = good_length;\r\n        that.max_lazy = max_lazy;\r\n        that.nice_length = nice_length;\r\n        that.max_chain = max_chain;\r\n        that.func = func;\r\n    }\r\n\r\n    var STORED = 0;\r\n    var FAST = 1;\r\n    var SLOW = 2;\r\n    var config_table = [ new Config(0, 0, 0, 0, STORED), new Config(4, 4, 8, 4, FAST), new Config(4, 5, 16, 8, FAST), new Config(4, 6, 32, 32, FAST),\r\n            new Config(4, 4, 16, 16, SLOW), new Config(8, 16, 32, 32, SLOW), new Config(8, 16, 128, 128, SLOW), new Config(8, 32, 128, 256, SLOW),\r\n            new Config(32, 128, 258, 1024, SLOW), new Config(32, 258, 258, 4096, SLOW) ];\r\n\r\n    var z_errmsg = [ \"need dictionary\", // Z_NEED_DICT\r\n    // 2\r\n    \"stream end\", // Z_STREAM_END 1\r\n    \"\", // Z_OK 0\r\n    \"\", // Z_ERRNO (-1)\r\n    \"stream error\", // Z_STREAM_ERROR (-2)\r\n    \"data error\", // Z_DATA_ERROR (-3)\r\n    \"\", // Z_MEM_ERROR (-4)\r\n    \"buffer error\", // Z_BUF_ERROR (-5)\r\n    \"\",// Z_VERSION_ERROR (-6)\r\n    \"\" ];\r\n\r\n    // block not completed, need more input or more output\r\n    var NeedMore = 0;\r\n\r\n    // block flush performed\r\n    var BlockDone = 1;\r\n\r\n    // finish started, need only more output at next deflate\r\n    var FinishStarted = 2;\r\n\r\n    // finish done, accept no more input or output\r\n    var FinishDone = 3;\r\n\r\n    // preset dictionary flag in zlib header\r\n    var PRESET_DICT = 0x20;\r\n\r\n    var INIT_STATE = 42;\r\n    var BUSY_STATE = 113;\r\n    var FINISH_STATE = 666;\r\n\r\n    // The deflate compression method\r\n    var Z_DEFLATED = 8;\r\n\r\n    var STORED_BLOCK = 0;\r\n    var STATIC_TREES = 1;\r\n    var DYN_TREES = 2;\r\n\r\n    var MIN_MATCH = 3;\r\n    var MAX_MATCH = 258;\r\n    var MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);\r\n\r\n    function smaller(tree, n, m, depth) {\r\n        var tn2 = tree[n * 2];\r\n        var tm2 = tree[m * 2];\r\n        return (tn2 < tm2 || (tn2 == tm2 && depth[n] <= depth[m]));\r\n    }\r\n\r\n    function Deflate() {\r\n\r\n        var that = this;\r\n        var strm; // pointer back to this zlib stream\r\n        var status; // as the name implies\r\n        // pending_buf; // output still pending\r\n        var pending_buf_size; // size of pending_buf\r\n        // pending_out; // next pending byte to output to the stream\r\n        // pending; // nb of bytes in the pending buffer\r\n        var method; // STORED (for zip only) or DEFLATED\r\n        var last_flush; // value of flush param for previous deflate call\r\n\r\n        var w_size; // LZ77 window size (32K by default)\r\n        var w_bits; // log2(w_size) (8..16)\r\n        var w_mask; // w_size - 1\r\n\r\n        var window;\r\n        // Sliding window. Input bytes are read into the second half of the window,\r\n        // and move to the first half later to keep a dictionary of at least wSize\r\n        // bytes. With this organization, matches are limited to a distance of\r\n        // wSize-MAX_MATCH bytes, but this ensures that IO is always\r\n        // performed with a length multiple of the block size. Also, it limits\r\n        // the window size to 64K, which is quite useful on MSDOS.\r\n        // To do: use the user input buffer as sliding window.\r\n\r\n        var window_size;\r\n        // Actual size of window: 2*wSize, except when the user input buffer\r\n        // is directly used as sliding window.\r\n\r\n        var prev;\r\n        // Link to older string with same hash index. To limit the size of this\r\n        // array to 64K, this link is maintained only for the last 32K strings.\r\n        // An index in this array is thus a window index modulo 32K.\r\n\r\n        var head; // Heads of the hash chains or NIL.\r\n\r\n        var ins_h; // hash index of string to be inserted\r\n        var hash_size; // number of elements in hash table\r\n        var hash_bits; // log2(hash_size)\r\n        var hash_mask; // hash_size-1\r\n\r\n        // Number of bits by which ins_h must be shifted at each input\r\n        // step. It must be such that after MIN_MATCH steps, the oldest\r\n        // byte no longer takes part in the hash key, that is:\r\n        // hash_shift * MIN_MATCH >= hash_bits\r\n        var hash_shift;\r\n\r\n        // Window position at the beginning of the current output block. Gets\r\n        // negative when the window is moved backwards.\r\n\r\n        var block_start;\r\n\r\n        var match_length; // length of best match\r\n        var prev_match; // previous match\r\n        var match_available; // set if previous match exists\r\n        var strstart; // start of string to insert\r\n        var match_start; // start of matching string\r\n        var lookahead; // number of valid bytes ahead in window\r\n\r\n        // Length of the best match at previous step. Matches not greater than this\r\n        // are discarded. This is used in the lazy match evaluation.\r\n        var prev_length;\r\n\r\n        // To speed up deflation, hash chains are never searched beyond this\r\n        // length. A higher limit improves compression ratio but degrades the speed.\r\n        var max_chain_length;\r\n\r\n        // Attempt to find a better match only when the current match is strictly\r\n        // smaller than this value. This mechanism is used only for compression\r\n        // levels >= 4.\r\n        var max_lazy_match;\r\n\r\n        // Insert new strings in the hash table only if the match length is not\r\n        // greater than this length. This saves time but degrades compression.\r\n        // max_insert_length is used only for compression levels <= 3.\r\n\r\n        var level; // compression level (1..9)\r\n        var strategy; // favor or force Huffman coding\r\n\r\n        // Use a faster search when the previous match is longer than this\r\n        var good_match;\r\n\r\n        // Stop searching when current match exceeds this\r\n        var nice_match;\r\n\r\n        var dyn_ltree; // literal and length tree\r\n        var dyn_dtree; // distance tree\r\n        var bl_tree; // Huffman tree for bit lengths\r\n\r\n        var l_desc = new Tree(); // desc for literal tree\r\n        var d_desc = new Tree(); // desc for distance tree\r\n        var bl_desc = new Tree(); // desc for bit length tree\r\n\r\n        // that.heap_len; // number of elements in the heap\r\n        // that.heap_max; // element of largest frequency\r\n        // The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.\r\n        // The same heap array is used to build all trees.\r\n\r\n        // Depth of each subtree used as tie breaker for trees of equal frequency\r\n        that.depth = [];\r\n\r\n        var l_buf; // index for literals or lengths */\r\n\r\n        // Size of match buffer for literals/lengths. There are 4 reasons for\r\n        // limiting lit_bufsize to 64K:\r\n        // - frequencies can be kept in 16 bit counters\r\n        // - if compression is not successful for the first block, all input\r\n        // data is still in the window so we can still emit a stored block even\r\n        // when input comes from standard input. (This can also be done for\r\n        // all blocks if lit_bufsize is not greater than 32K.)\r\n        // - if compression is not successful for a file smaller than 64K, we can\r\n        // even emit a stored file instead of a stored block (saving 5 bytes).\r\n        // This is applicable only for zip (not gzip or zlib).\r\n        // - creating new Huffman trees less frequently may not provide fast\r\n        // adaptation to changes in the input data statistics. (Take for\r\n        // example a binary file with poorly compressible code followed by\r\n        // a highly compressible string table.) Smaller buffer sizes give\r\n        // fast adaptation but have of course the overhead of transmitting\r\n        // trees more frequently.\r\n        // - I can't count above 4\r\n        var lit_bufsize;\r\n\r\n        var last_lit; // running index in l_buf\r\n\r\n        // Buffer for distances. To simplify the code, d_buf and l_buf have\r\n        // the same number of elements. To use different lengths, an extra flag\r\n        // array would be necessary.\r\n\r\n        var d_buf; // index of pendig_buf\r\n\r\n        // that.opt_len; // bit length of current block with optimal trees\r\n        // that.static_len; // bit length of current block with static trees\r\n        var matches; // number of string matches in current block\r\n        var last_eob_len; // bit length of EOB code for last block\r\n\r\n        // Output buffer. bits are inserted starting at the bottom (least\r\n        // significant bits).\r\n        var bi_buf;\r\n\r\n        // Number of valid bits in bi_buf. All bits above the last valid bit\r\n        // are always zero.\r\n        var bi_valid;\r\n\r\n        // number of codes at each bit length for an optimal tree\r\n        that.bl_count = [];\r\n\r\n        // heap used to build the Huffman trees\r\n        that.heap = [];\r\n\r\n        dyn_ltree = [];\r\n        dyn_dtree = [];\r\n        bl_tree = [];\r\n\r\n        function lm_init() {\r\n            var i;\r\n            window_size = 2 * w_size;\r\n\r\n            head[hash_size - 1] = 0;\r\n            for (i = 0; i < hash_size - 1; i++) {\r\n                head[i] = 0;\r\n            }\r\n\r\n            // Set the default configuration parameters:\r\n            max_lazy_match = config_table[level].max_lazy;\r\n            good_match = config_table[level].good_length;\r\n            nice_match = config_table[level].nice_length;\r\n            max_chain_length = config_table[level].max_chain;\r\n\r\n            strstart = 0;\r\n            block_start = 0;\r\n            lookahead = 0;\r\n            match_length = prev_length = MIN_MATCH - 1;\r\n            match_available = 0;\r\n            ins_h = 0;\r\n        }\r\n\r\n        function init_block() {\r\n            var i;\r\n            // Initialize the trees.\r\n            for (i = 0; i < L_CODES; i++)\r\n                dyn_ltree[i * 2] = 0;\r\n            for (i = 0; i < D_CODES; i++)\r\n                dyn_dtree[i * 2] = 0;\r\n            for (i = 0; i < BL_CODES; i++)\r\n                bl_tree[i * 2] = 0;\r\n\r\n            dyn_ltree[END_BLOCK * 2] = 1;\r\n            that.opt_len = that.static_len = 0;\r\n            last_lit = matches = 0;\r\n        }\r\n\r\n        // Initialize the tree data structures for a new zlib stream.\r\n        function tr_init() {\r\n\r\n            l_desc.dyn_tree = dyn_ltree;\r\n            l_desc.stat_desc = StaticTree.static_l_desc;\r\n\r\n            d_desc.dyn_tree = dyn_dtree;\r\n            d_desc.stat_desc = StaticTree.static_d_desc;\r\n\r\n            bl_desc.dyn_tree = bl_tree;\r\n            bl_desc.stat_desc = StaticTree.static_bl_desc;\r\n\r\n            bi_buf = 0;\r\n            bi_valid = 0;\r\n            last_eob_len = 8; // enough lookahead for inflate\r\n\r\n            // Initialize the first block of the first file:\r\n            init_block();\r\n        }\r\n\r\n        // Restore the heap property by moving down the tree starting at node k,\r\n        // exchanging a node with the smallest of its two sons if necessary,\r\n        // stopping\r\n        // when the heap property is re-established (each father smaller than its\r\n        // two sons).\r\n        that.pqdownheap = function(tree, // the tree to restore\r\n        k // node to move down\r\n        ) {\r\n            var heap = that.heap;\r\n            var v = heap[k];\r\n            var j = k << 1; // left son of k\r\n            while (j <= that.heap_len) {\r\n                // Set j to the smallest of the two sons:\r\n                if (j < that.heap_len && smaller(tree, heap[j + 1], heap[j], that.depth)) {\r\n                    j++;\r\n                }\r\n                // Exit if v is smaller than both sons\r\n                if (smaller(tree, v, heap[j], that.depth))\r\n                    break;\r\n\r\n                // Exchange v with the smallest son\r\n                heap[k] = heap[j];\r\n                k = j;\r\n                // And continue down the tree, setting j to the left son of k\r\n                j <<= 1;\r\n            }\r\n            heap[k] = v;\r\n        };\r\n\r\n        // Scan a literal or distance tree to determine the frequencies of the codes\r\n        // in the bit length tree.\r\n        function scan_tree(tree,// the tree to be scanned\r\n        max_code // and its largest code of non zero frequency\r\n        ) {\r\n            var n; // iterates over all tree elements\r\n            var prevlen = -1; // last emitted length\r\n            var curlen; // length of current code\r\n            var nextlen = tree[0 * 2 + 1]; // length of next code\r\n            var count = 0; // repeat count of the current code\r\n            var max_count = 7; // max repeat count\r\n            var min_count = 4; // min repeat count\r\n\r\n            if (nextlen === 0) {\r\n                max_count = 138;\r\n                min_count = 3;\r\n            }\r\n            tree[(max_code + 1) * 2 + 1] = 0xffff; // guard\r\n\r\n            for (n = 0; n <= max_code; n++) {\r\n                curlen = nextlen;\r\n                nextlen = tree[(n + 1) * 2 + 1];\r\n                if (++count < max_count && curlen == nextlen) {\r\n                    continue;\r\n                } else if (count < min_count) {\r\n                    bl_tree[curlen * 2] += count;\r\n                } else if (curlen !== 0) {\r\n                    if (curlen != prevlen)\r\n                        bl_tree[curlen * 2]++;\r\n                    bl_tree[REP_3_6 * 2]++;\r\n                } else if (count <= 10) {\r\n                    bl_tree[REPZ_3_10 * 2]++;\r\n                } else {\r\n                    bl_tree[REPZ_11_138 * 2]++;\r\n                }\r\n                count = 0;\r\n                prevlen = curlen;\r\n                if (nextlen === 0) {\r\n                    max_count = 138;\r\n                    min_count = 3;\r\n                } else if (curlen == nextlen) {\r\n                    max_count = 6;\r\n                    min_count = 3;\r\n                } else {\r\n                    max_count = 7;\r\n                    min_count = 4;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Construct the Huffman tree for the bit lengths and return the index in\r\n        // bl_order of the last bit length code to send.\r\n        function build_bl_tree() {\r\n            var max_blindex; // index of last bit length code of non zero freq\r\n\r\n            // Determine the bit length frequencies for literal and distance trees\r\n            scan_tree(dyn_ltree, l_desc.max_code);\r\n            scan_tree(dyn_dtree, d_desc.max_code);\r\n\r\n            // Build the bit length tree:\r\n            bl_desc.build_tree(that);\r\n            // opt_len now includes the length of the tree representations, except\r\n            // the lengths of the bit lengths codes and the 5+5+4 bits for the\r\n            // counts.\r\n\r\n            // Determine the number of bit length codes to send. The pkzip format\r\n            // requires that at least 4 bit length codes be sent. (appnote.txt says\r\n            // 3 but the actual value used is 4.)\r\n            for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {\r\n                if (bl_tree[Tree.bl_order[max_blindex] * 2 + 1] !== 0)\r\n                    break;\r\n            }\r\n            // Update opt_len to include the bit length tree and counts\r\n            that.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;\r\n\r\n            return max_blindex;\r\n        }\r\n\r\n        // Output a byte on the stream.\r\n        // IN assertion: there is enough room in pending_buf.\r\n        function put_byte(p) {\r\n            that.pending_buf[that.pending++] = p;\r\n        }\r\n\r\n        function put_short(w) {\r\n            put_byte(w & 0xff);\r\n            put_byte((w >>> 8) & 0xff);\r\n        }\r\n\r\n        function putShortMSB(b) {\r\n            put_byte((b >> 8) & 0xff);\r\n            put_byte((b & 0xff) & 0xff);\r\n        }\r\n\r\n        function send_bits(value, length) {\r\n            var val, len = length;\r\n            if (bi_valid > Buf_size - len) {\r\n                val = value;\r\n                // bi_buf |= (val << bi_valid);\r\n                bi_buf |= ((val << bi_valid) & 0xffff);\r\n                put_short(bi_buf);\r\n                bi_buf = val >>> (Buf_size - bi_valid);\r\n                bi_valid += len - Buf_size;\r\n            } else {\r\n                // bi_buf |= (value) << bi_valid;\r\n                bi_buf |= (((value) << bi_valid) & 0xffff);\r\n                bi_valid += len;\r\n            }\r\n        }\r\n\r\n        function send_code(c, tree) {\r\n            var c2 = c * 2;\r\n            send_bits(tree[c2] & 0xffff, tree[c2 + 1] & 0xffff);\r\n        }\r\n\r\n        // Send a literal or distance tree in compressed form, using the codes in\r\n        // bl_tree.\r\n        function send_tree(tree,// the tree to be sent\r\n        max_code // and its largest code of non zero frequency\r\n        ) {\r\n            var n; // iterates over all tree elements\r\n            var prevlen = -1; // last emitted length\r\n            var curlen; // length of current code\r\n            var nextlen = tree[0 * 2 + 1]; // length of next code\r\n            var count = 0; // repeat count of the current code\r\n            var max_count = 7; // max repeat count\r\n            var min_count = 4; // min repeat count\r\n\r\n            if (nextlen === 0) {\r\n                max_count = 138;\r\n                min_count = 3;\r\n            }\r\n\r\n            for (n = 0; n <= max_code; n++) {\r\n                curlen = nextlen;\r\n                nextlen = tree[(n + 1) * 2 + 1];\r\n                if (++count < max_count && curlen == nextlen) {\r\n                    continue;\r\n                } else if (count < min_count) {\r\n                    do {\r\n                        send_code(curlen, bl_tree);\r\n                    } while (--count !== 0);\r\n                } else if (curlen !== 0) {\r\n                    if (curlen != prevlen) {\r\n                        send_code(curlen, bl_tree);\r\n                        count--;\r\n                    }\r\n                    send_code(REP_3_6, bl_tree);\r\n                    send_bits(count - 3, 2);\r\n                } else if (count <= 10) {\r\n                    send_code(REPZ_3_10, bl_tree);\r\n                    send_bits(count - 3, 3);\r\n                } else {\r\n                    send_code(REPZ_11_138, bl_tree);\r\n                    send_bits(count - 11, 7);\r\n                }\r\n                count = 0;\r\n                prevlen = curlen;\r\n                if (nextlen === 0) {\r\n                    max_count = 138;\r\n                    min_count = 3;\r\n                } else if (curlen == nextlen) {\r\n                    max_count = 6;\r\n                    min_count = 3;\r\n                } else {\r\n                    max_count = 7;\r\n                    min_count = 4;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Send the header for a block using dynamic Huffman trees: the counts, the\r\n        // lengths of the bit length codes, the literal tree and the distance tree.\r\n        // IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\r\n        function send_all_trees(lcodes, dcodes, blcodes) {\r\n            var rank; // index in bl_order\r\n\r\n            send_bits(lcodes - 257, 5); // not +255 as stated in appnote.txt\r\n            send_bits(dcodes - 1, 5);\r\n            send_bits(blcodes - 4, 4); // not -3 as stated in appnote.txt\r\n            for (rank = 0; rank < blcodes; rank++) {\r\n                send_bits(bl_tree[Tree.bl_order[rank] * 2 + 1], 3);\r\n            }\r\n            send_tree(dyn_ltree, lcodes - 1); // literal tree\r\n            send_tree(dyn_dtree, dcodes - 1); // distance tree\r\n        }\r\n\r\n        // Flush the bit buffer, keeping at most 7 bits in it.\r\n        function bi_flush() {\r\n            if (bi_valid == 16) {\r\n                put_short(bi_buf);\r\n                bi_buf = 0;\r\n                bi_valid = 0;\r\n            } else if (bi_valid >= 8) {\r\n                put_byte(bi_buf & 0xff);\r\n                bi_buf >>>= 8;\r\n                bi_valid -= 8;\r\n            }\r\n        }\r\n\r\n        // Send one empty static block to give enough lookahead for inflate.\r\n        // This takes 10 bits, of which 7 may remain in the bit buffer.\r\n        // The current inflate code requires 9 bits of lookahead. If the\r\n        // last two codes for the previous block (real code plus EOB) were coded\r\n        // on 5 bits or less, inflate may have only 5+3 bits of lookahead to decode\r\n        // the last real code. In this case we send two empty static blocks instead\r\n        // of one. (There are no problems if the previous block is stored or fixed.)\r\n        // To simplify the code, we assume the worst case of last real code encoded\r\n        // on one bit only.\r\n        function _tr_align() {\r\n            send_bits(STATIC_TREES << 1, 3);\r\n            send_code(END_BLOCK, StaticTree.static_ltree);\r\n\r\n            bi_flush();\r\n\r\n            // Of the 10 bits for the empty block, we have already sent\r\n            // (10 - bi_valid) bits. The lookahead for the last real code (before\r\n            // the EOB of the previous block) was thus at least one plus the length\r\n            // of the EOB plus what we have just sent of the empty static block.\r\n            if (1 + last_eob_len + 10 - bi_valid < 9) {\r\n                send_bits(STATIC_TREES << 1, 3);\r\n                send_code(END_BLOCK, StaticTree.static_ltree);\r\n                bi_flush();\r\n            }\r\n            last_eob_len = 7;\r\n        }\r\n\r\n        // Save the match info and tally the frequency counts. Return true if\r\n        // the current block must be flushed.\r\n        function _tr_tally(dist, // distance of matched string\r\n        lc // match length-MIN_MATCH or unmatched char (if dist==0)\r\n        ) {\r\n            var out_length, in_length, dcode;\r\n            that.pending_buf[d_buf + last_lit * 2] = (dist >>> 8) & 0xff;\r\n            that.pending_buf[d_buf + last_lit * 2 + 1] = dist & 0xff;\r\n\r\n            that.pending_buf[l_buf + last_lit] = lc & 0xff;\r\n            last_lit++;\r\n\r\n            if (dist === 0) {\r\n                // lc is the unmatched char\r\n                dyn_ltree[lc * 2]++;\r\n            } else {\r\n                matches++;\r\n                // Here, lc is the match length - MIN_MATCH\r\n                dist--; // dist = match distance - 1\r\n                dyn_ltree[(Tree._length_code[lc] + LITERALS + 1) * 2]++;\r\n                dyn_dtree[Tree.d_code(dist) * 2]++;\r\n            }\r\n\r\n            if ((last_lit & 0x1fff) === 0 && level > 2) {\r\n                // Compute an upper bound for the compressed length\r\n                out_length = last_lit * 8;\r\n                in_length = strstart - block_start;\r\n                for (dcode = 0; dcode < D_CODES; dcode++) {\r\n                    out_length += dyn_dtree[dcode * 2] * (5 + Tree.extra_dbits[dcode]);\r\n                }\r\n                out_length >>>= 3;\r\n                if ((matches < Math.floor(last_lit / 2)) && out_length < Math.floor(in_length / 2))\r\n                    return true;\r\n            }\r\n\r\n            return (last_lit == lit_bufsize - 1);\r\n            // We avoid equality with lit_bufsize because of wraparound at 64K\r\n            // on 16 bit machines and because stored blocks are restricted to\r\n            // 64K-1 bytes.\r\n        }\r\n\r\n        // Send the block data compressed using the given Huffman trees\r\n        function compress_block(ltree, dtree) {\r\n            var dist; // distance of matched string\r\n            var lc; // match length or unmatched char (if dist === 0)\r\n            var lx = 0; // running index in l_buf\r\n            var code; // the code to send\r\n            var extra; // number of extra bits to send\r\n\r\n            if (last_lit !== 0) {\r\n                do {\r\n                    dist = ((that.pending_buf[d_buf + lx * 2] << 8) & 0xff00) | (that.pending_buf[d_buf + lx * 2 + 1] & 0xff);\r\n                    lc = (that.pending_buf[l_buf + lx]) & 0xff;\r\n                    lx++;\r\n\r\n                    if (dist === 0) {\r\n                        send_code(lc, ltree); // send a literal byte\r\n                    } else {\r\n                        // Here, lc is the match length - MIN_MATCH\r\n                        code = Tree._length_code[lc];\r\n\r\n                        send_code(code + LITERALS + 1, ltree); // send the length\r\n                        // code\r\n                        extra = Tree.extra_lbits[code];\r\n                        if (extra !== 0) {\r\n                            lc -= Tree.base_length[code];\r\n                            send_bits(lc, extra); // send the extra length bits\r\n                        }\r\n                        dist--; // dist is now the match distance - 1\r\n                        code = Tree.d_code(dist);\r\n\r\n                        send_code(code, dtree); // send the distance code\r\n                        extra = Tree.extra_dbits[code];\r\n                        if (extra !== 0) {\r\n                            dist -= Tree.base_dist[code];\r\n                            send_bits(dist, extra); // send the extra distance bits\r\n                        }\r\n                    } // literal or match pair ?\r\n\r\n                    // Check that the overlay between pending_buf and d_buf+l_buf is\r\n                    // ok:\r\n                } while (lx < last_lit);\r\n            }\r\n\r\n            send_code(END_BLOCK, ltree);\r\n            last_eob_len = ltree[END_BLOCK * 2 + 1];\r\n        }\r\n\r\n        // Flush the bit buffer and align the output on a byte boundary\r\n        function bi_windup() {\r\n            if (bi_valid > 8) {\r\n                put_short(bi_buf);\r\n            } else if (bi_valid > 0) {\r\n                put_byte(bi_buf & 0xff);\r\n            }\r\n            bi_buf = 0;\r\n            bi_valid = 0;\r\n        }\r\n\r\n        // Copy a stored block, storing first the length and its\r\n        // one's complement if requested.\r\n        function copy_block(buf, // the input data\r\n        len, // its length\r\n        header // true if block header must be written\r\n        ) {\r\n            bi_windup(); // align on byte boundary\r\n            last_eob_len = 8; // enough lookahead for inflate\r\n\r\n            if (header) {\r\n                put_short(len);\r\n                put_short(~len);\r\n            }\r\n\r\n            that.pending_buf.set(window.subarray(buf, buf + len), that.pending);\r\n            that.pending += len;\r\n        }\r\n\r\n        // Send a stored block\r\n        function _tr_stored_block(buf, // input block\r\n        stored_len, // length of input block\r\n        eof // true if this is the last block for a file\r\n        ) {\r\n            send_bits((STORED_BLOCK << 1) + (eof ? 1 : 0), 3); // send block type\r\n            copy_block(buf, stored_len, true); // with header\r\n        }\r\n\r\n        // Determine the best encoding for the current block: dynamic trees, static\r\n        // trees or store, and output the encoded block to the zip file.\r\n        function _tr_flush_block(buf, // input block, or NULL if too old\r\n        stored_len, // length of input block\r\n        eof // true if this is the last block for a file\r\n        ) {\r\n            var opt_lenb, static_lenb;// opt_len and static_len in bytes\r\n            var max_blindex = 0; // index of last bit length code of non zero freq\r\n\r\n            // Build the Huffman trees unless a stored block is forced\r\n            if (level > 0) {\r\n                // Construct the literal and distance trees\r\n                l_desc.build_tree(that);\r\n\r\n                d_desc.build_tree(that);\r\n\r\n                // At this point, opt_len and static_len are the total bit lengths\r\n                // of\r\n                // the compressed block data, excluding the tree representations.\r\n\r\n                // Build the bit length tree for the above two trees, and get the\r\n                // index\r\n                // in bl_order of the last bit length code to send.\r\n                max_blindex = build_bl_tree();\r\n\r\n                // Determine the best encoding. Compute first the block length in\r\n                // bytes\r\n                opt_lenb = (that.opt_len + 3 + 7) >>> 3;\r\n                static_lenb = (that.static_len + 3 + 7) >>> 3;\r\n\r\n                if (static_lenb <= opt_lenb)\r\n                    opt_lenb = static_lenb;\r\n            } else {\r\n                opt_lenb = static_lenb = stored_len + 5; // force a stored block\r\n            }\r\n\r\n            if ((stored_len + 4 <= opt_lenb) && buf != -1) {\r\n                // 4: two words for the lengths\r\n                // The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\r\n                // Otherwise we can't have processed more than WSIZE input bytes\r\n                // since\r\n                // the last block flush, because compression would have been\r\n                // successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\r\n                // transform a block into a stored block.\r\n                _tr_stored_block(buf, stored_len, eof);\r\n            } else if (static_lenb == opt_lenb) {\r\n                send_bits((STATIC_TREES << 1) + (eof ? 1 : 0), 3);\r\n                compress_block(StaticTree.static_ltree, StaticTree.static_dtree);\r\n            } else {\r\n                send_bits((DYN_TREES << 1) + (eof ? 1 : 0), 3);\r\n                send_all_trees(l_desc.max_code + 1, d_desc.max_code + 1, max_blindex + 1);\r\n                compress_block(dyn_ltree, dyn_dtree);\r\n            }\r\n\r\n            // The above check is made mod 2^32, for files larger than 512 MB\r\n            // and uLong implemented on 32 bits.\r\n\r\n            init_block();\r\n\r\n            if (eof) {\r\n                bi_windup();\r\n            }\r\n        }\r\n\r\n        function flush_block_only(eof) {\r\n            _tr_flush_block(block_start >= 0 ? block_start : -1, strstart - block_start, eof);\r\n            block_start = strstart;\r\n            strm.flush_pending();\r\n        }\r\n\r\n        // Fill the window when the lookahead becomes insufficient.\r\n        // Updates strstart and lookahead.\r\n        //\r\n        // IN assertion: lookahead < MIN_LOOKAHEAD\r\n        // OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\r\n        // At least one byte has been read, or avail_in === 0; reads are\r\n        // performed for at least two bytes (required for the zip translate_eol\r\n        // option -- not supported here).\r\n        function fill_window() {\r\n            var n, m;\r\n            var p;\r\n            var more; // Amount of free space at the end of the window.\r\n\r\n            do {\r\n                more = (window_size - lookahead - strstart);\r\n\r\n                // Deal with !@#$% 64K limit:\r\n                if (more === 0 && strstart === 0 && lookahead === 0) {\r\n                    more = w_size;\r\n                } else if (more == -1) {\r\n                    // Very unlikely, but possible on 16 bit machine if strstart ==\r\n                    // 0\r\n                    // and lookahead == 1 (input done one byte at time)\r\n                    more--;\r\n\r\n                    // If the window is almost full and there is insufficient\r\n                    // lookahead,\r\n                    // move the upper half to the lower one to make room in the\r\n                    // upper half.\r\n                } else if (strstart >= w_size + w_size - MIN_LOOKAHEAD) {\r\n                    window.set(window.subarray(w_size, w_size + w_size), 0);\r\n\r\n                    match_start -= w_size;\r\n                    strstart -= w_size; // we now have strstart >= MAX_DIST\r\n                    block_start -= w_size;\r\n\r\n                    // Slide the hash table (could be avoided with 32 bit values\r\n                    // at the expense of memory usage). We slide even when level ==\r\n                    // 0\r\n                    // to keep the hash table consistent if we switch back to level\r\n                    // > 0\r\n                    // later. (Using level 0 permanently is not an optimal usage of\r\n                    // zlib, so we don't care about this pathological case.)\r\n\r\n                    n = hash_size;\r\n                    p = n;\r\n                    do {\r\n                        m = (head[--p] & 0xffff);\r\n                        head[p] = (m >= w_size ? m - w_size : 0);\r\n                    } while (--n !== 0);\r\n\r\n                    n = w_size;\r\n                    p = n;\r\n                    do {\r\n                        m = (prev[--p] & 0xffff);\r\n                        prev[p] = (m >= w_size ? m - w_size : 0);\r\n                        // If n is not on any hash chain, prev[n] is garbage but\r\n                        // its value will never be used.\r\n                    } while (--n !== 0);\r\n                    more += w_size;\r\n                }\r\n\r\n                if (strm.avail_in === 0)\r\n                    return;\r\n\r\n                // If there was no sliding:\r\n                // strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\r\n                // more == window_size - lookahead - strstart\r\n                // => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\r\n                // => more >= window_size - 2*WSIZE + 2\r\n                // In the BIG_MEM or MMAP case (not yet supported),\r\n                // window_size == input_size + MIN_LOOKAHEAD &&\r\n                // strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\r\n                // Otherwise, window_size == 2*WSIZE so more >= 2.\r\n                // If there was sliding, more >= WSIZE. So in all cases, more >= 2.\r\n\r\n                n = strm.read_buf(window, strstart + lookahead, more);\r\n                lookahead += n;\r\n\r\n                // Initialize the hash value now that we have some input:\r\n                if (lookahead >= MIN_MATCH) {\r\n                    ins_h = window[strstart] & 0xff;\r\n                    ins_h = (((ins_h) << hash_shift) ^ (window[strstart + 1] & 0xff)) & hash_mask;\r\n                }\r\n                // If the whole input has less than MIN_MATCH bytes, ins_h is\r\n                // garbage,\r\n                // but this is not important since only literal bytes will be\r\n                // emitted.\r\n            } while (lookahead < MIN_LOOKAHEAD && strm.avail_in !== 0);\r\n        }\r\n\r\n        // Copy without compression as much as possible from the input stream,\r\n        // return\r\n        // the current block state.\r\n        // This function does not insert new strings in the dictionary since\r\n        // uncompressible data is probably not useful. This function is used\r\n        // only for the level=0 compression option.\r\n        // NOTE: this function should be optimized to avoid extra copying from\r\n        // window to pending_buf.\r\n        function deflate_stored(flush) {\r\n            // Stored blocks are limited to 0xffff bytes, pending_buf is limited\r\n            // to pending_buf_size, and each stored block has a 5 byte header:\r\n\r\n            var max_block_size = 0xffff;\r\n            var max_start;\r\n\r\n            if (max_block_size > pending_buf_size - 5) {\r\n                max_block_size = pending_buf_size - 5;\r\n            }\r\n\r\n            // Copy as much as possible from input to output:\r\n            while (true) {\r\n                // Fill the window as much as possible:\r\n                if (lookahead <= 1) {\r\n                    fill_window();\r\n                    if (lookahead === 0 && flush == Z_NO_FLUSH)\r\n                        return NeedMore;\r\n                    if (lookahead === 0)\r\n                        break; // flush the current block\r\n                }\r\n\r\n                strstart += lookahead;\r\n                lookahead = 0;\r\n\r\n                // Emit a stored block if pending_buf will be full:\r\n                max_start = block_start + max_block_size;\r\n                if (strstart === 0 || strstart >= max_start) {\r\n                    // strstart === 0 is possible when wraparound on 16-bit machine\r\n                    lookahead = (strstart - max_start);\r\n                    strstart = max_start;\r\n\r\n                    flush_block_only(false);\r\n                    if (strm.avail_out === 0)\r\n                        return NeedMore;\r\n\r\n                }\r\n\r\n                // Flush if we may have to slide, otherwise block_start may become\r\n                // negative and the data will be gone:\r\n                if (strstart - block_start >= w_size - MIN_LOOKAHEAD) {\r\n                    flush_block_only(false);\r\n                    if (strm.avail_out === 0)\r\n                        return NeedMore;\r\n                }\r\n            }\r\n\r\n            flush_block_only(flush == Z_FINISH);\r\n            if (strm.avail_out === 0)\r\n                return (flush == Z_FINISH) ? FinishStarted : NeedMore;\r\n\r\n            return flush == Z_FINISH ? FinishDone : BlockDone;\r\n        }\r\n\r\n        function longest_match(cur_match) {\r\n            var chain_length = max_chain_length; // max hash chain length\r\n            var scan = strstart; // current string\r\n            var match; // matched string\r\n            var len; // length of current match\r\n            var best_len = prev_length; // best match length so far\r\n            var limit = strstart > (w_size - MIN_LOOKAHEAD) ? strstart - (w_size - MIN_LOOKAHEAD) : 0;\r\n            var _nice_match = nice_match;\r\n\r\n            // Stop when cur_match becomes <= limit. To simplify the code,\r\n            // we prevent matches with the string of window index 0.\r\n\r\n            var wmask = w_mask;\r\n\r\n            var strend = strstart + MAX_MATCH;\r\n            var scan_end1 = window[scan + best_len - 1];\r\n            var scan_end = window[scan + best_len];\r\n\r\n            // The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of\r\n            // 16.\r\n            // It is easy to get rid of this optimization if necessary.\r\n\r\n            // Do not waste too much time if we already have a good match:\r\n            if (prev_length >= good_match) {\r\n                chain_length >>= 2;\r\n            }\r\n\r\n            // Do not look for matches beyond the end of the input. This is\r\n            // necessary\r\n            // to make deflate deterministic.\r\n            if (_nice_match > lookahead)\r\n                _nice_match = lookahead;\r\n\r\n            do {\r\n                match = cur_match;\r\n\r\n                // Skip to next match if the match length cannot increase\r\n                // or if the match length is less than 2:\r\n                if (window[match + best_len] != scan_end || window[match + best_len - 1] != scan_end1 || window[match] != window[scan]\r\n                        || window[++match] != window[scan + 1])\r\n                    continue;\r\n\r\n                // The check at best_len-1 can be removed because it will be made\r\n                // again later. (This heuristic is not always a win.)\r\n                // It is not necessary to compare scan[2] and match[2] since they\r\n                // are always equal when the other bytes match, given that\r\n                // the hash keys are equal and that HASH_BITS >= 8.\r\n                scan += 2;\r\n                match++;\r\n\r\n                // We check for insufficient lookahead only every 8th comparison;\r\n                // the 256th check will be made at strstart+258.\r\n                do {\r\n                } while (window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match]\r\n                        && window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match]\r\n                        && window[++scan] == window[++match] && window[++scan] == window[++match] && scan < strend);\r\n\r\n                len = MAX_MATCH - (strend - scan);\r\n                scan = strend - MAX_MATCH;\r\n\r\n                if (len > best_len) {\r\n                    match_start = cur_match;\r\n                    best_len = len;\r\n                    if (len >= _nice_match)\r\n                        break;\r\n                    scan_end1 = window[scan + best_len - 1];\r\n                    scan_end = window[scan + best_len];\r\n                }\r\n\r\n            } while ((cur_match = (prev[cur_match & wmask] & 0xffff)) > limit && --chain_length !== 0);\r\n\r\n            if (best_len <= lookahead)\r\n                return best_len;\r\n            return lookahead;\r\n        }\r\n\r\n        // Compress as much as possible from the input stream, return the current\r\n        // block state.\r\n        // This function does not perform lazy evaluation of matches and inserts\r\n        // new strings in the dictionary only for unmatched strings or for short\r\n        // matches. It is used only for the fast compression options.\r\n        function deflate_fast(flush) {\r\n            // short hash_head = 0; // head of the hash chain\r\n            var hash_head = 0; // head of the hash chain\r\n            var bflush; // set if current block must be flushed\r\n\r\n            while (true) {\r\n                // Make sure that we always have enough lookahead, except\r\n                // at the end of the input file. We need MAX_MATCH bytes\r\n                // for the next match, plus MIN_MATCH bytes to insert the\r\n                // string following the next match.\r\n                if (lookahead < MIN_LOOKAHEAD) {\r\n                    fill_window();\r\n                    if (lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {\r\n                        return NeedMore;\r\n                    }\r\n                    if (lookahead === 0)\r\n                        break; // flush the current block\r\n                }\r\n\r\n                // Insert the string window[strstart .. strstart+2] in the\r\n                // dictionary, and set hash_head to the head of the hash chain:\r\n                if (lookahead >= MIN_MATCH) {\r\n                    ins_h = (((ins_h) << hash_shift) ^ (window[(strstart) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;\r\n\r\n                    // prev[strstart&w_mask]=hash_head=head[ins_h];\r\n                    hash_head = (head[ins_h] & 0xffff);\r\n                    prev[strstart & w_mask] = head[ins_h];\r\n                    head[ins_h] = strstart;\r\n                }\r\n\r\n                // Find the longest match, discarding those <= prev_length.\r\n                // At this point we have always match_length < MIN_MATCH\r\n\r\n                if (hash_head !== 0 && ((strstart - hash_head) & 0xffff) <= w_size - MIN_LOOKAHEAD) {\r\n                    // To simplify the code, we prevent matches with the string\r\n                    // of window index 0 (in particular we have to avoid a match\r\n                    // of the string with itself at the start of the input file).\r\n                    if (strategy != Z_HUFFMAN_ONLY) {\r\n                        match_length = longest_match(hash_head);\r\n                    }\r\n                    // longest_match() sets match_start\r\n                }\r\n                if (match_length >= MIN_MATCH) {\r\n                    // check_match(strstart, match_start, match_length);\r\n\r\n                    bflush = _tr_tally(strstart - match_start, match_length - MIN_MATCH);\r\n\r\n                    lookahead -= match_length;\r\n\r\n                    // Insert new strings in the hash table only if the match length\r\n                    // is not too large. This saves time but degrades compression.\r\n                    if (match_length <= max_lazy_match && lookahead >= MIN_MATCH) {\r\n                        match_length--; // string at strstart already in hash table\r\n                        do {\r\n                            strstart++;\r\n\r\n                            ins_h = ((ins_h << hash_shift) ^ (window[(strstart) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;\r\n                            // prev[strstart&w_mask]=hash_head=head[ins_h];\r\n                            hash_head = (head[ins_h] & 0xffff);\r\n                            prev[strstart & w_mask] = head[ins_h];\r\n                            head[ins_h] = strstart;\r\n\r\n                            // strstart never exceeds WSIZE-MAX_MATCH, so there are\r\n                            // always MIN_MATCH bytes ahead.\r\n                        } while (--match_length !== 0);\r\n                        strstart++;\r\n                    } else {\r\n                        strstart += match_length;\r\n                        match_length = 0;\r\n                        ins_h = window[strstart] & 0xff;\r\n\r\n                        ins_h = (((ins_h) << hash_shift) ^ (window[strstart + 1] & 0xff)) & hash_mask;\r\n                        // If lookahead < MIN_MATCH, ins_h is garbage, but it does\r\n                        // not\r\n                        // matter since it will be recomputed at next deflate call.\r\n                    }\r\n                } else {\r\n                    // No match, output a literal byte\r\n\r\n                    bflush = _tr_tally(0, window[strstart] & 0xff);\r\n                    lookahead--;\r\n                    strstart++;\r\n                }\r\n                if (bflush) {\r\n\r\n                    flush_block_only(false);\r\n                    if (strm.avail_out === 0)\r\n                        return NeedMore;\r\n                }\r\n            }\r\n\r\n            flush_block_only(flush == Z_FINISH);\r\n            if (strm.avail_out === 0) {\r\n                if (flush == Z_FINISH)\r\n                    return FinishStarted;\r\n                else\r\n                    return NeedMore;\r\n            }\r\n            return flush == Z_FINISH ? FinishDone : BlockDone;\r\n        }\r\n\r\n        // Same as above, but achieves better compression. We use a lazy\r\n        // evaluation for matches: a match is finally adopted only if there is\r\n        // no better match at the next window position.\r\n        function deflate_slow(flush) {\r\n            // short hash_head = 0; // head of hash chain\r\n            var hash_head = 0; // head of hash chain\r\n            var bflush; // set if current block must be flushed\r\n            var max_insert;\r\n\r\n            // Process the input block.\r\n            while (true) {\r\n                // Make sure that we always have enough lookahead, except\r\n                // at the end of the input file. We need MAX_MATCH bytes\r\n                // for the next match, plus MIN_MATCH bytes to insert the\r\n                // string following the next match.\r\n\r\n                if (lookahead < MIN_LOOKAHEAD) {\r\n                    fill_window();\r\n                    if (lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {\r\n                        return NeedMore;\r\n                    }\r\n                    if (lookahead === 0)\r\n                        break; // flush the current block\r\n                }\r\n\r\n                // Insert the string window[strstart .. strstart+2] in the\r\n                // dictionary, and set hash_head to the head of the hash chain:\r\n\r\n                if (lookahead >= MIN_MATCH) {\r\n                    ins_h = (((ins_h) << hash_shift) ^ (window[(strstart) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;\r\n                    // prev[strstart&w_mask]=hash_head=head[ins_h];\r\n                    hash_head = (head[ins_h] & 0xffff);\r\n                    prev[strstart & w_mask] = head[ins_h];\r\n                    head[ins_h] = strstart;\r\n                }\r\n\r\n                // Find the longest match, discarding those <= prev_length.\r\n                prev_length = match_length;\r\n                prev_match = match_start;\r\n                match_length = MIN_MATCH - 1;\r\n\r\n                if (hash_head !== 0 && prev_length < max_lazy_match && ((strstart - hash_head) & 0xffff) <= w_size - MIN_LOOKAHEAD) {\r\n                    // To simplify the code, we prevent matches with the string\r\n                    // of window index 0 (in particular we have to avoid a match\r\n                    // of the string with itself at the start of the input file).\r\n\r\n                    if (strategy != Z_HUFFMAN_ONLY) {\r\n                        match_length = longest_match(hash_head);\r\n                    }\r\n                    // longest_match() sets match_start\r\n\r\n                    if (match_length <= 5 && (strategy == Z_FILTERED || (match_length == MIN_MATCH && strstart - match_start > 4096))) {\r\n\r\n                        // If prev_match is also MIN_MATCH, match_start is garbage\r\n                        // but we will ignore the current match anyway.\r\n                        match_length = MIN_MATCH - 1;\r\n                    }\r\n                }\r\n\r\n                // If there was a match at the previous step and the current\r\n                // match is not better, output the previous match:\r\n                if (prev_length >= MIN_MATCH && match_length <= prev_length) {\r\n                    max_insert = strstart + lookahead - MIN_MATCH;\r\n                    // Do not insert strings in hash table beyond this.\r\n\r\n                    // check_match(strstart-1, prev_match, prev_length);\r\n\r\n                    bflush = _tr_tally(strstart - 1 - prev_match, prev_length - MIN_MATCH);\r\n\r\n                    // Insert in hash table all strings up to the end of the match.\r\n                    // strstart-1 and strstart are already inserted. If there is not\r\n                    // enough lookahead, the last two strings are not inserted in\r\n                    // the hash table.\r\n                    lookahead -= prev_length - 1;\r\n                    prev_length -= 2;\r\n                    do {\r\n                        if (++strstart <= max_insert) {\r\n                            ins_h = (((ins_h) << hash_shift) ^ (window[(strstart) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;\r\n                            // prev[strstart&w_mask]=hash_head=head[ins_h];\r\n                            hash_head = (head[ins_h] & 0xffff);\r\n                            prev[strstart & w_mask] = head[ins_h];\r\n                            head[ins_h] = strstart;\r\n                        }\r\n                    } while (--prev_length !== 0);\r\n                    match_available = 0;\r\n                    match_length = MIN_MATCH - 1;\r\n                    strstart++;\r\n\r\n                    if (bflush) {\r\n                        flush_block_only(false);\r\n                        if (strm.avail_out === 0)\r\n                            return NeedMore;\r\n                    }\r\n                } else if (match_available !== 0) {\r\n\r\n                    // If there was no match at the previous position, output a\r\n                    // single literal. If there was a match but the current match\r\n                    // is longer, truncate the previous match to a single literal.\r\n\r\n                    bflush = _tr_tally(0, window[strstart - 1] & 0xff);\r\n\r\n                    if (bflush) {\r\n                        flush_block_only(false);\r\n                    }\r\n                    strstart++;\r\n                    lookahead--;\r\n                    if (strm.avail_out === 0)\r\n                        return NeedMore;\r\n                } else {\r\n                    // There is no previous match to compare with, wait for\r\n                    // the next step to decide.\r\n\r\n                    match_available = 1;\r\n                    strstart++;\r\n                    lookahead--;\r\n                }\r\n            }\r\n\r\n            if (match_available !== 0) {\r\n                bflush = _tr_tally(0, window[strstart - 1] & 0xff);\r\n                match_available = 0;\r\n            }\r\n            flush_block_only(flush == Z_FINISH);\r\n\r\n            if (strm.avail_out === 0) {\r\n                if (flush == Z_FINISH)\r\n                    return FinishStarted;\r\n                else\r\n                    return NeedMore;\r\n            }\r\n\r\n            return flush == Z_FINISH ? FinishDone : BlockDone;\r\n        }\r\n\r\n        function deflateReset(strm) {\r\n            strm.total_in = strm.total_out = 0;\r\n            strm.msg = null; //\r\n\r\n            that.pending = 0;\r\n            that.pending_out = 0;\r\n\r\n            status = BUSY_STATE;\r\n\r\n            last_flush = Z_NO_FLUSH;\r\n\r\n            tr_init();\r\n            lm_init();\r\n            return Z_OK;\r\n        }\r\n\r\n        that.deflateInit = function(strm, _level, bits, _method, memLevel, _strategy) {\r\n            if (!_method)\r\n                _method = Z_DEFLATED;\r\n            if (!memLevel)\r\n                memLevel = DEF_MEM_LEVEL;\r\n            if (!_strategy)\r\n                _strategy = Z_DEFAULT_STRATEGY;\r\n\r\n            // byte[] my_version=ZLIB_VERSION;\r\n\r\n            //\r\n            // if (!version || version[0] != my_version[0]\r\n            // || stream_size != sizeof(z_stream)) {\r\n            // return Z_VERSION_ERROR;\r\n            // }\r\n\r\n            strm.msg = null;\r\n\r\n            if (_level == Z_DEFAULT_COMPRESSION)\r\n                _level = 6;\r\n\r\n            if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || _method != Z_DEFLATED || bits < 9 || bits > 15 || _level < 0 || _level > 9 || _strategy < 0\r\n                    || _strategy > Z_HUFFMAN_ONLY) {\r\n                return Z_STREAM_ERROR;\r\n            }\r\n\r\n            strm.dstate = that;\r\n\r\n            w_bits = bits;\r\n            w_size = 1 << w_bits;\r\n            w_mask = w_size - 1;\r\n\r\n            hash_bits = memLevel + 7;\r\n            hash_size = 1 << hash_bits;\r\n            hash_mask = hash_size - 1;\r\n            hash_shift = Math.floor((hash_bits + MIN_MATCH - 1) / MIN_MATCH);\r\n\r\n            window = new Uint8Array(w_size * 2);\r\n            prev = [];\r\n            head = [];\r\n\r\n            lit_bufsize = 1 << (memLevel + 6); // 16K elements by default\r\n\r\n            // We overlay pending_buf and d_buf+l_buf. This works since the average\r\n            // output size for (length,distance) codes is <= 24 bits.\r\n            that.pending_buf = new Uint8Array(lit_bufsize * 4);\r\n            pending_buf_size = lit_bufsize * 4;\r\n\r\n            d_buf = Math.floor(lit_bufsize / 2);\r\n            l_buf = (1 + 2) * lit_bufsize;\r\n\r\n            level = _level;\r\n\r\n            strategy = _strategy;\r\n            method = _method & 0xff;\r\n\r\n            return deflateReset(strm);\r\n        };\r\n\r\n        that.deflateEnd = function() {\r\n            if (status != INIT_STATE && status != BUSY_STATE && status != FINISH_STATE) {\r\n                return Z_STREAM_ERROR;\r\n            }\r\n            // Deallocate in reverse order of allocations:\r\n            that.pending_buf = null;\r\n            head = null;\r\n            prev = null;\r\n            window = null;\r\n            // free\r\n            that.dstate = null;\r\n            return status == BUSY_STATE ? Z_DATA_ERROR : Z_OK;\r\n        };\r\n\r\n        that.deflateParams = function(strm, _level, _strategy) {\r\n            var err = Z_OK;\r\n\r\n            if (_level == Z_DEFAULT_COMPRESSION) {\r\n                _level = 6;\r\n            }\r\n            if (_level < 0 || _level > 9 || _strategy < 0 || _strategy > Z_HUFFMAN_ONLY) {\r\n                return Z_STREAM_ERROR;\r\n            }\r\n\r\n            if (config_table[level].func != config_table[_level].func && strm.total_in !== 0) {\r\n                // Flush the last buffer:\r\n                err = strm.deflate(Z_PARTIAL_FLUSH);\r\n            }\r\n\r\n            if (level != _level) {\r\n                level = _level;\r\n                max_lazy_match = config_table[level].max_lazy;\r\n                good_match = config_table[level].good_length;\r\n                nice_match = config_table[level].nice_length;\r\n                max_chain_length = config_table[level].max_chain;\r\n            }\r\n            strategy = _strategy;\r\n            return err;\r\n        };\r\n\r\n        that.deflateSetDictionary = function(strm, dictionary, dictLength) {\r\n            var length = dictLength;\r\n            var n, index = 0;\r\n\r\n            if (!dictionary || status != INIT_STATE)\r\n                return Z_STREAM_ERROR;\r\n\r\n            if (length < MIN_MATCH)\r\n                return Z_OK;\r\n            if (length > w_size - MIN_LOOKAHEAD) {\r\n                length = w_size - MIN_LOOKAHEAD;\r\n                index = dictLength - length; // use the tail of the dictionary\r\n            }\r\n            window.set(dictionary.subarray(index, index + length), 0);\r\n\r\n            strstart = length;\r\n            block_start = length;\r\n\r\n            // Insert all strings in the hash table (except for the last two bytes).\r\n            // s->lookahead stays null, so s->ins_h will be recomputed at the next\r\n            // call of fill_window.\r\n\r\n            ins_h = window[0] & 0xff;\r\n            ins_h = (((ins_h) << hash_shift) ^ (window[1] & 0xff)) & hash_mask;\r\n\r\n            for (n = 0; n <= length - MIN_MATCH; n++) {\r\n                ins_h = (((ins_h) << hash_shift) ^ (window[(n) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;\r\n                prev[n & w_mask] = head[ins_h];\r\n                head[ins_h] = n;\r\n            }\r\n            return Z_OK;\r\n        };\r\n\r\n        that.deflate = function(_strm, flush) {\r\n            var i, header, level_flags, old_flush, bstate;\r\n\r\n            if (flush > Z_FINISH || flush < 0) {\r\n                return Z_STREAM_ERROR;\r\n            }\r\n\r\n            if (!_strm.next_out || (!_strm.next_in && _strm.avail_in !== 0) || (status == FINISH_STATE && flush != Z_FINISH)) {\r\n                _strm.msg = z_errmsg[Z_NEED_DICT - (Z_STREAM_ERROR)];\r\n                return Z_STREAM_ERROR;\r\n            }\r\n            if (_strm.avail_out === 0) {\r\n                _strm.msg = z_errmsg[Z_NEED_DICT - (Z_BUF_ERROR)];\r\n                return Z_BUF_ERROR;\r\n            }\r\n\r\n            strm = _strm; // just in case\r\n            old_flush = last_flush;\r\n            last_flush = flush;\r\n\r\n            // Write the zlib header\r\n            if (status == INIT_STATE) {\r\n                header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;\r\n                level_flags = ((level - 1) & 0xff) >> 1;\r\n\r\n                if (level_flags > 3)\r\n                    level_flags = 3;\r\n                header |= (level_flags << 6);\r\n                if (strstart !== 0)\r\n                    header |= PRESET_DICT;\r\n                header += 31 - (header % 31);\r\n\r\n                status = BUSY_STATE;\r\n                putShortMSB(header);\r\n            }\r\n\r\n            // Flush as much pending output as possible\r\n            if (that.pending !== 0) {\r\n                strm.flush_pending();\r\n                if (strm.avail_out === 0) {\r\n                    // console.log(\" avail_out==0\");\r\n                    // Since avail_out is 0, deflate will be called again with\r\n                    // more output space, but possibly with both pending and\r\n                    // avail_in equal to zero. There won't be anything to do,\r\n                    // but this is not an error situation so make sure we\r\n                    // return OK instead of BUF_ERROR at next call of deflate:\r\n                    last_flush = -1;\r\n                    return Z_OK;\r\n                }\r\n\r\n                // Make sure there is something to do and avoid duplicate\r\n                // consecutive\r\n                // flushes. For repeated and useless calls with Z_FINISH, we keep\r\n                // returning Z_STREAM_END instead of Z_BUFF_ERROR.\r\n            } else if (strm.avail_in === 0 && flush <= old_flush && flush != Z_FINISH) {\r\n                strm.msg = z_errmsg[Z_NEED_DICT - (Z_BUF_ERROR)];\r\n                return Z_BUF_ERROR;\r\n            }\r\n\r\n            // User must not provide more input after the first FINISH:\r\n            if (status == FINISH_STATE && strm.avail_in !== 0) {\r\n                _strm.msg = z_errmsg[Z_NEED_DICT - (Z_BUF_ERROR)];\r\n                return Z_BUF_ERROR;\r\n            }\r\n\r\n            // Start a new block or continue the current one.\r\n            if (strm.avail_in !== 0 || lookahead !== 0 || (flush != Z_NO_FLUSH && status != FINISH_STATE)) {\r\n                bstate = -1;\r\n                switch (config_table[level].func) {\r\n                case STORED:\r\n                    bstate = deflate_stored(flush);\r\n                    break;\r\n                case FAST:\r\n                    bstate = deflate_fast(flush);\r\n                    break;\r\n                case SLOW:\r\n                    bstate = deflate_slow(flush);\r\n                    break;\r\n                default:\r\n                }\r\n\r\n                if (bstate == FinishStarted || bstate == FinishDone) {\r\n                    status = FINISH_STATE;\r\n                }\r\n                if (bstate == NeedMore || bstate == FinishStarted) {\r\n                    if (strm.avail_out === 0) {\r\n                        last_flush = -1; // avoid BUF_ERROR next call, see above\r\n                    }\r\n                    return Z_OK;\r\n                    // If flush != Z_NO_FLUSH && avail_out === 0, the next call\r\n                    // of deflate should use the same flush parameter to make sure\r\n                    // that the flush is complete. So we don't have to output an\r\n                    // empty block here, this will be done at next call. This also\r\n                    // ensures that for a very small output buffer, we emit at most\r\n                    // one empty block.\r\n                }\r\n\r\n                if (bstate == BlockDone) {\r\n                    if (flush == Z_PARTIAL_FLUSH) {\r\n                        _tr_align();\r\n                    } else { // FULL_FLUSH or SYNC_FLUSH\r\n                        _tr_stored_block(0, 0, false);\r\n                        // For a full flush, this empty block will be recognized\r\n                        // as a special marker by inflate_sync().\r\n                        if (flush == Z_FULL_FLUSH) {\r\n                            // state.head[s.hash_size-1]=0;\r\n                            for (i = 0; i < hash_size/*-1*/; i++)\r\n                                // forget history\r\n                                head[i] = 0;\r\n                        }\r\n                    }\r\n                    strm.flush_pending();\r\n                    if (strm.avail_out === 0) {\r\n                        last_flush = -1; // avoid BUF_ERROR at next call, see above\r\n                        return Z_OK;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (flush != Z_FINISH)\r\n                return Z_OK;\r\n            return Z_STREAM_END;\r\n        };\r\n    }\r\n\r\n    // ZStream\r\n\r\n    function ZStream() {\r\n        var that = this;\r\n        that.next_in_index = 0;\r\n        that.next_out_index = 0;\r\n        // that.next_in; // next input byte\r\n        that.avail_in = 0; // number of bytes available at next_in\r\n        that.total_in = 0; // total nb of input bytes read so far\r\n        // that.next_out; // next output byte should be put there\r\n        that.avail_out = 0; // remaining free space at next_out\r\n        that.total_out = 0; // total nb of bytes output so far\r\n        // that.msg;\r\n        // that.dstate;\r\n    }\r\n\r\n    ZStream.prototype = {\r\n        deflateInit : function(level, bits) {\r\n            var that = this;\r\n            that.dstate = new Deflate();\r\n            if (!bits)\r\n                bits = MAX_BITS;\r\n            return that.dstate.deflateInit(that, level, bits);\r\n        },\r\n\r\n        deflate : function(flush) {\r\n            var that = this;\r\n            if (!that.dstate) {\r\n                return Z_STREAM_ERROR;\r\n            }\r\n            return that.dstate.deflate(that, flush);\r\n        },\r\n\r\n        deflateEnd : function() {\r\n            var that = this;\r\n            if (!that.dstate)\r\n                return Z_STREAM_ERROR;\r\n            var ret = that.dstate.deflateEnd();\r\n            that.dstate = null;\r\n            return ret;\r\n        },\r\n\r\n        deflateParams : function(level, strategy) {\r\n            var that = this;\r\n            if (!that.dstate)\r\n                return Z_STREAM_ERROR;\r\n            return that.dstate.deflateParams(that, level, strategy);\r\n        },\r\n\r\n        deflateSetDictionary : function(dictionary, dictLength) {\r\n            var that = this;\r\n            if (!that.dstate)\r\n                return Z_STREAM_ERROR;\r\n            return that.dstate.deflateSetDictionary(that, dictionary, dictLength);\r\n        },\r\n\r\n        // Read a new buffer from the current input stream, update the\r\n        // total number of bytes read. All deflate() input goes through\r\n        // this function so some applications may wish to modify it to avoid\r\n        // allocating a large strm->next_in buffer and copying from it.\r\n        // (See also flush_pending()).\r\n        read_buf : function(buf, start, size) {\r\n            var that = this;\r\n            var len = that.avail_in;\r\n            if (len > size)\r\n                len = size;\r\n            if (len === 0)\r\n                return 0;\r\n            that.avail_in -= len;\r\n            buf.set(that.next_in.subarray(that.next_in_index, that.next_in_index + len), start);\r\n            that.next_in_index += len;\r\n            that.total_in += len;\r\n            return len;\r\n        },\r\n\r\n        // Flush as much pending output as possible. All deflate() output goes\r\n        // through this function so some applications may wish to modify it\r\n        // to avoid allocating a large strm->next_out buffer and copying into it.\r\n        // (See also read_buf()).\r\n        flush_pending : function() {\r\n            var that = this;\r\n            var len = that.dstate.pending;\r\n\r\n            if (len > that.avail_out)\r\n                len = that.avail_out;\r\n            if (len === 0)\r\n                return;\r\n\r\n            // if (that.dstate.pending_buf.length <= that.dstate.pending_out || that.next_out.length <= that.next_out_index\r\n            // || that.dstate.pending_buf.length < (that.dstate.pending_out + len) || that.next_out.length < (that.next_out_index +\r\n            // len)) {\r\n            // console.log(that.dstate.pending_buf.length + \", \" + that.dstate.pending_out + \", \" + that.next_out.length + \", \" +\r\n            // that.next_out_index + \", \" + len);\r\n            // console.log(\"avail_out=\" + that.avail_out);\r\n            // }\r\n\r\n            that.next_out.set(that.dstate.pending_buf.subarray(that.dstate.pending_out, that.dstate.pending_out + len), that.next_out_index);\r\n\r\n            that.next_out_index += len;\r\n            that.dstate.pending_out += len;\r\n            that.total_out += len;\r\n            that.avail_out -= len;\r\n            that.dstate.pending -= len;\r\n            if (that.dstate.pending === 0) {\r\n                that.dstate.pending_out = 0;\r\n            }\r\n        }\r\n    };\r\n\r\n    // Deflater\r\n\r\n    function Deflater(options) {\r\n        var that = this;\r\n        var z = new ZStream();\r\n        var bufsize = 512;\r\n        var flush = Z_NO_FLUSH;\r\n        var buf = new Uint8Array(bufsize);\r\n        var level = options ? options.level : Z_DEFAULT_COMPRESSION;\r\n        if (typeof level == \"undefined\")\r\n            level = Z_DEFAULT_COMPRESSION;\r\n        z.deflateInit(level);\r\n        z.next_out = buf;\r\n\r\n        that.append = function(data, onprogress) {\r\n            var err, buffers = [], lastIndex = 0, bufferIndex = 0, bufferSize = 0, array;\r\n            if (!data.length)\r\n                return;\r\n            z.next_in_index = 0;\r\n            z.next_in = data;\r\n            z.avail_in = data.length;\r\n            do {\r\n                z.next_out_index = 0;\r\n                z.avail_out = bufsize;\r\n                err = z.deflate(flush);\r\n                if (err != Z_OK)\r\n                    throw new Error(\"deflating: \" + z.msg);\r\n                if (z.next_out_index)\r\n                    if (z.next_out_index == bufsize)\r\n                        buffers.push(new Uint8Array(buf));\r\n                    else\r\n                        buffers.push(new Uint8Array(buf.subarray(0, z.next_out_index)));\r\n                bufferSize += z.next_out_index;\r\n                if (onprogress && z.next_in_index > 0 && z.next_in_index != lastIndex) {\r\n                    onprogress(z.next_in_index);\r\n                    lastIndex = z.next_in_index;\r\n                }\r\n            } while (z.avail_in > 0 || z.avail_out === 0);\r\n            array = new Uint8Array(bufferSize);\r\n            buffers.forEach(function(chunk) {\r\n                array.set(chunk, bufferIndex);\r\n                bufferIndex += chunk.length;\r\n            });\r\n            return array;\r\n        };\r\n        that.flush = function() {\r\n            var err, buffers = [], bufferIndex = 0, bufferSize = 0, array;\r\n            do {\r\n                z.next_out_index = 0;\r\n                z.avail_out = bufsize;\r\n                err = z.deflate(Z_FINISH);\r\n                if (err != Z_STREAM_END && err != Z_OK)\r\n                    throw new Error(\"deflating: \" + z.msg);\r\n                if (bufsize - z.avail_out > 0)\r\n                    buffers.push(new Uint8Array(buf.subarray(0, z.next_out_index)));\r\n                bufferSize += z.next_out_index;\r\n            } while (z.avail_in > 0 || z.avail_out === 0);\r\n            z.deflateEnd();\r\n            array = new Uint8Array(bufferSize);\r\n            buffers.forEach(function(chunk) {\r\n                array.set(chunk, bufferIndex);\r\n                bufferIndex += chunk.length;\r\n            });\r\n            return array;\r\n        };\r\n    }\r\n\r\n    // 'zip' may not be defined in z-worker and some tests\r\n    var env = global.zip || global;\r\n    env.Deflater = env._jzlib_Deflater = Deflater;\r\n})(this);";

},{}],2:[function(require,module,exports){
module.exports = "/*\r\n Copyright (c) 2013 Gildas Lormeau. All rights reserved.\r\n\r\n Redistribution and use in source and binary forms, with or without\r\n modification, are permitted provided that the following conditions are met:\r\n\r\n 1. Redistributions of source code must retain the above copyright notice,\r\n this list of conditions and the following disclaimer.\r\n\r\n 2. Redistributions in binary form must reproduce the above copyright\r\n notice, this list of conditions and the following disclaimer in\r\n the documentation and/or other materials provided with the distribution.\r\n\r\n 3. The names of the authors may not be used to endorse or promote products\r\n derived from this software without specific prior written permission.\r\n\r\n THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,\r\n INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\r\n FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,\r\n INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,\r\n INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\r\n LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\r\n OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\r\n LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\r\n NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\r\n EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\n/*\r\n * This program is based on JZlib 1.0.2 ymnk, JCraft,Inc.\r\n * JZlib is based on zlib-1.1.3, so all credit should go authors\r\n * Jean-loup Gailly(jloup@gzip.org) and Mark Adler(madler@alumni.caltech.edu)\r\n * and contributors of zlib.\r\n */\r\n\r\n(function(global) {\r\n    \"use strict\";\r\n\r\n    // Global\r\n    var MAX_BITS = 15;\r\n\r\n    var Z_OK = 0;\r\n    var Z_STREAM_END = 1;\r\n    var Z_NEED_DICT = 2;\r\n    var Z_STREAM_ERROR = -2;\r\n    var Z_DATA_ERROR = -3;\r\n    var Z_MEM_ERROR = -4;\r\n    var Z_BUF_ERROR = -5;\r\n\r\n    var inflate_mask = [ 0x00000000, 0x00000001, 0x00000003, 0x00000007, 0x0000000f, 0x0000001f, 0x0000003f, 0x0000007f, 0x000000ff, 0x000001ff, 0x000003ff,\r\n            0x000007ff, 0x00000fff, 0x00001fff, 0x00003fff, 0x00007fff, 0x0000ffff ];\r\n\r\n    var MANY = 1440;\r\n\r\n    // JZlib version : \"1.0.2\"\r\n    var Z_NO_FLUSH = 0;\r\n    var Z_FINISH = 4;\r\n\r\n    // InfTree\r\n    var fixed_bl = 9;\r\n    var fixed_bd = 5;\r\n\r\n    var fixed_tl = [ 96, 7, 256, 0, 8, 80, 0, 8, 16, 84, 8, 115, 82, 7, 31, 0, 8, 112, 0, 8, 48, 0, 9, 192, 80, 7, 10, 0, 8, 96, 0, 8, 32, 0, 9, 160, 0, 8, 0,\r\n            0, 8, 128, 0, 8, 64, 0, 9, 224, 80, 7, 6, 0, 8, 88, 0, 8, 24, 0, 9, 144, 83, 7, 59, 0, 8, 120, 0, 8, 56, 0, 9, 208, 81, 7, 17, 0, 8, 104, 0, 8, 40,\r\n            0, 9, 176, 0, 8, 8, 0, 8, 136, 0, 8, 72, 0, 9, 240, 80, 7, 4, 0, 8, 84, 0, 8, 20, 85, 8, 227, 83, 7, 43, 0, 8, 116, 0, 8, 52, 0, 9, 200, 81, 7, 13,\r\n            0, 8, 100, 0, 8, 36, 0, 9, 168, 0, 8, 4, 0, 8, 132, 0, 8, 68, 0, 9, 232, 80, 7, 8, 0, 8, 92, 0, 8, 28, 0, 9, 152, 84, 7, 83, 0, 8, 124, 0, 8, 60,\r\n            0, 9, 216, 82, 7, 23, 0, 8, 108, 0, 8, 44, 0, 9, 184, 0, 8, 12, 0, 8, 140, 0, 8, 76, 0, 9, 248, 80, 7, 3, 0, 8, 82, 0, 8, 18, 85, 8, 163, 83, 7,\r\n            35, 0, 8, 114, 0, 8, 50, 0, 9, 196, 81, 7, 11, 0, 8, 98, 0, 8, 34, 0, 9, 164, 0, 8, 2, 0, 8, 130, 0, 8, 66, 0, 9, 228, 80, 7, 7, 0, 8, 90, 0, 8,\r\n            26, 0, 9, 148, 84, 7, 67, 0, 8, 122, 0, 8, 58, 0, 9, 212, 82, 7, 19, 0, 8, 106, 0, 8, 42, 0, 9, 180, 0, 8, 10, 0, 8, 138, 0, 8, 74, 0, 9, 244, 80,\r\n            7, 5, 0, 8, 86, 0, 8, 22, 192, 8, 0, 83, 7, 51, 0, 8, 118, 0, 8, 54, 0, 9, 204, 81, 7, 15, 0, 8, 102, 0, 8, 38, 0, 9, 172, 0, 8, 6, 0, 8, 134, 0,\r\n            8, 70, 0, 9, 236, 80, 7, 9, 0, 8, 94, 0, 8, 30, 0, 9, 156, 84, 7, 99, 0, 8, 126, 0, 8, 62, 0, 9, 220, 82, 7, 27, 0, 8, 110, 0, 8, 46, 0, 9, 188, 0,\r\n            8, 14, 0, 8, 142, 0, 8, 78, 0, 9, 252, 96, 7, 256, 0, 8, 81, 0, 8, 17, 85, 8, 131, 82, 7, 31, 0, 8, 113, 0, 8, 49, 0, 9, 194, 80, 7, 10, 0, 8, 97,\r\n            0, 8, 33, 0, 9, 162, 0, 8, 1, 0, 8, 129, 0, 8, 65, 0, 9, 226, 80, 7, 6, 0, 8, 89, 0, 8, 25, 0, 9, 146, 83, 7, 59, 0, 8, 121, 0, 8, 57, 0, 9, 210,\r\n            81, 7, 17, 0, 8, 105, 0, 8, 41, 0, 9, 178, 0, 8, 9, 0, 8, 137, 0, 8, 73, 0, 9, 242, 80, 7, 4, 0, 8, 85, 0, 8, 21, 80, 8, 258, 83, 7, 43, 0, 8, 117,\r\n            0, 8, 53, 0, 9, 202, 81, 7, 13, 0, 8, 101, 0, 8, 37, 0, 9, 170, 0, 8, 5, 0, 8, 133, 0, 8, 69, 0, 9, 234, 80, 7, 8, 0, 8, 93, 0, 8, 29, 0, 9, 154,\r\n            84, 7, 83, 0, 8, 125, 0, 8, 61, 0, 9, 218, 82, 7, 23, 0, 8, 109, 0, 8, 45, 0, 9, 186, 0, 8, 13, 0, 8, 141, 0, 8, 77, 0, 9, 250, 80, 7, 3, 0, 8, 83,\r\n            0, 8, 19, 85, 8, 195, 83, 7, 35, 0, 8, 115, 0, 8, 51, 0, 9, 198, 81, 7, 11, 0, 8, 99, 0, 8, 35, 0, 9, 166, 0, 8, 3, 0, 8, 131, 0, 8, 67, 0, 9, 230,\r\n            80, 7, 7, 0, 8, 91, 0, 8, 27, 0, 9, 150, 84, 7, 67, 0, 8, 123, 0, 8, 59, 0, 9, 214, 82, 7, 19, 0, 8, 107, 0, 8, 43, 0, 9, 182, 0, 8, 11, 0, 8, 139,\r\n            0, 8, 75, 0, 9, 246, 80, 7, 5, 0, 8, 87, 0, 8, 23, 192, 8, 0, 83, 7, 51, 0, 8, 119, 0, 8, 55, 0, 9, 206, 81, 7, 15, 0, 8, 103, 0, 8, 39, 0, 9, 174,\r\n            0, 8, 7, 0, 8, 135, 0, 8, 71, 0, 9, 238, 80, 7, 9, 0, 8, 95, 0, 8, 31, 0, 9, 158, 84, 7, 99, 0, 8, 127, 0, 8, 63, 0, 9, 222, 82, 7, 27, 0, 8, 111,\r\n            0, 8, 47, 0, 9, 190, 0, 8, 15, 0, 8, 143, 0, 8, 79, 0, 9, 254, 96, 7, 256, 0, 8, 80, 0, 8, 16, 84, 8, 115, 82, 7, 31, 0, 8, 112, 0, 8, 48, 0, 9,\r\n            193, 80, 7, 10, 0, 8, 96, 0, 8, 32, 0, 9, 161, 0, 8, 0, 0, 8, 128, 0, 8, 64, 0, 9, 225, 80, 7, 6, 0, 8, 88, 0, 8, 24, 0, 9, 145, 83, 7, 59, 0, 8,\r\n            120, 0, 8, 56, 0, 9, 209, 81, 7, 17, 0, 8, 104, 0, 8, 40, 0, 9, 177, 0, 8, 8, 0, 8, 136, 0, 8, 72, 0, 9, 241, 80, 7, 4, 0, 8, 84, 0, 8, 20, 85, 8,\r\n            227, 83, 7, 43, 0, 8, 116, 0, 8, 52, 0, 9, 201, 81, 7, 13, 0, 8, 100, 0, 8, 36, 0, 9, 169, 0, 8, 4, 0, 8, 132, 0, 8, 68, 0, 9, 233, 80, 7, 8, 0, 8,\r\n            92, 0, 8, 28, 0, 9, 153, 84, 7, 83, 0, 8, 124, 0, 8, 60, 0, 9, 217, 82, 7, 23, 0, 8, 108, 0, 8, 44, 0, 9, 185, 0, 8, 12, 0, 8, 140, 0, 8, 76, 0, 9,\r\n            249, 80, 7, 3, 0, 8, 82, 0, 8, 18, 85, 8, 163, 83, 7, 35, 0, 8, 114, 0, 8, 50, 0, 9, 197, 81, 7, 11, 0, 8, 98, 0, 8, 34, 0, 9, 165, 0, 8, 2, 0, 8,\r\n            130, 0, 8, 66, 0, 9, 229, 80, 7, 7, 0, 8, 90, 0, 8, 26, 0, 9, 149, 84, 7, 67, 0, 8, 122, 0, 8, 58, 0, 9, 213, 82, 7, 19, 0, 8, 106, 0, 8, 42, 0, 9,\r\n            181, 0, 8, 10, 0, 8, 138, 0, 8, 74, 0, 9, 245, 80, 7, 5, 0, 8, 86, 0, 8, 22, 192, 8, 0, 83, 7, 51, 0, 8, 118, 0, 8, 54, 0, 9, 205, 81, 7, 15, 0, 8,\r\n            102, 0, 8, 38, 0, 9, 173, 0, 8, 6, 0, 8, 134, 0, 8, 70, 0, 9, 237, 80, 7, 9, 0, 8, 94, 0, 8, 30, 0, 9, 157, 84, 7, 99, 0, 8, 126, 0, 8, 62, 0, 9,\r\n            221, 82, 7, 27, 0, 8, 110, 0, 8, 46, 0, 9, 189, 0, 8, 14, 0, 8, 142, 0, 8, 78, 0, 9, 253, 96, 7, 256, 0, 8, 81, 0, 8, 17, 85, 8, 131, 82, 7, 31, 0,\r\n            8, 113, 0, 8, 49, 0, 9, 195, 80, 7, 10, 0, 8, 97, 0, 8, 33, 0, 9, 163, 0, 8, 1, 0, 8, 129, 0, 8, 65, 0, 9, 227, 80, 7, 6, 0, 8, 89, 0, 8, 25, 0, 9,\r\n            147, 83, 7, 59, 0, 8, 121, 0, 8, 57, 0, 9, 211, 81, 7, 17, 0, 8, 105, 0, 8, 41, 0, 9, 179, 0, 8, 9, 0, 8, 137, 0, 8, 73, 0, 9, 243, 80, 7, 4, 0, 8,\r\n            85, 0, 8, 21, 80, 8, 258, 83, 7, 43, 0, 8, 117, 0, 8, 53, 0, 9, 203, 81, 7, 13, 0, 8, 101, 0, 8, 37, 0, 9, 171, 0, 8, 5, 0, 8, 133, 0, 8, 69, 0, 9,\r\n            235, 80, 7, 8, 0, 8, 93, 0, 8, 29, 0, 9, 155, 84, 7, 83, 0, 8, 125, 0, 8, 61, 0, 9, 219, 82, 7, 23, 0, 8, 109, 0, 8, 45, 0, 9, 187, 0, 8, 13, 0, 8,\r\n            141, 0, 8, 77, 0, 9, 251, 80, 7, 3, 0, 8, 83, 0, 8, 19, 85, 8, 195, 83, 7, 35, 0, 8, 115, 0, 8, 51, 0, 9, 199, 81, 7, 11, 0, 8, 99, 0, 8, 35, 0, 9,\r\n            167, 0, 8, 3, 0, 8, 131, 0, 8, 67, 0, 9, 231, 80, 7, 7, 0, 8, 91, 0, 8, 27, 0, 9, 151, 84, 7, 67, 0, 8, 123, 0, 8, 59, 0, 9, 215, 82, 7, 19, 0, 8,\r\n            107, 0, 8, 43, 0, 9, 183, 0, 8, 11, 0, 8, 139, 0, 8, 75, 0, 9, 247, 80, 7, 5, 0, 8, 87, 0, 8, 23, 192, 8, 0, 83, 7, 51, 0, 8, 119, 0, 8, 55, 0, 9,\r\n            207, 81, 7, 15, 0, 8, 103, 0, 8, 39, 0, 9, 175, 0, 8, 7, 0, 8, 135, 0, 8, 71, 0, 9, 239, 80, 7, 9, 0, 8, 95, 0, 8, 31, 0, 9, 159, 84, 7, 99, 0, 8,\r\n            127, 0, 8, 63, 0, 9, 223, 82, 7, 27, 0, 8, 111, 0, 8, 47, 0, 9, 191, 0, 8, 15, 0, 8, 143, 0, 8, 79, 0, 9, 255 ];\r\n    var fixed_td = [ 80, 5, 1, 87, 5, 257, 83, 5, 17, 91, 5, 4097, 81, 5, 5, 89, 5, 1025, 85, 5, 65, 93, 5, 16385, 80, 5, 3, 88, 5, 513, 84, 5, 33, 92, 5,\r\n            8193, 82, 5, 9, 90, 5, 2049, 86, 5, 129, 192, 5, 24577, 80, 5, 2, 87, 5, 385, 83, 5, 25, 91, 5, 6145, 81, 5, 7, 89, 5, 1537, 85, 5, 97, 93, 5,\r\n            24577, 80, 5, 4, 88, 5, 769, 84, 5, 49, 92, 5, 12289, 82, 5, 13, 90, 5, 3073, 86, 5, 193, 192, 5, 24577 ];\r\n\r\n    // Tables for deflate from PKZIP's appnote.txt.\r\n    var cplens = [ // Copy lengths for literal codes 257..285\r\n    3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0 ];\r\n\r\n    // see note #13 above about 258\r\n    var cplext = [ // Extra bits for literal codes 257..285\r\n    0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 112, 112 // 112==invalid\r\n    ];\r\n\r\n    var cpdist = [ // Copy offsets for distance codes 0..29\r\n    1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577 ];\r\n\r\n    var cpdext = [ // Extra bits for distance codes\r\n    0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13 ];\r\n\r\n    // If BMAX needs to be larger than 16, then h and x[] should be uLong.\r\n    var BMAX = 15; // maximum bit length of any code\r\n\r\n    function InfTree() {\r\n        var that = this;\r\n\r\n        var hn; // hufts used in space\r\n        var v; // work area for huft_build\r\n        var c; // bit length count table\r\n        var r; // table entry for structure assignment\r\n        var u; // table stack\r\n        var x; // bit offsets, then code stack\r\n\r\n        function huft_build(b, // code lengths in bits (all assumed <=\r\n        // BMAX)\r\n        bindex, n, // number of codes (assumed <= 288)\r\n        s, // number of simple-valued codes (0..s-1)\r\n        d, // list of base values for non-simple codes\r\n        e, // list of extra bits for non-simple codes\r\n        t, // result: starting table\r\n        m, // maximum lookup bits, returns actual\r\n        hp,// space for trees\r\n        hn,// hufts used in space\r\n        v // working area: values in order of bit length\r\n        ) {\r\n            // Given a list of code lengths and a maximum table size, make a set of\r\n            // tables to decode that set of codes. Return Z_OK on success,\r\n            // Z_BUF_ERROR\r\n            // if the given code set is incomplete (the tables are still built in\r\n            // this\r\n            // case), Z_DATA_ERROR if the input is invalid (an over-subscribed set\r\n            // of\r\n            // lengths), or Z_MEM_ERROR if not enough memory.\r\n\r\n            var a; // counter for codes of length k\r\n            var f; // i repeats in table every f entries\r\n            var g; // maximum code length\r\n            var h; // table level\r\n            var i; // counter, current code\r\n            var j; // counter\r\n            var k; // number of bits in current code\r\n            var l; // bits per table (returned in m)\r\n            var mask; // (1 << w) - 1, to avoid cc -O bug on HP\r\n            var p; // pointer into c[], b[], or v[]\r\n            var q; // points to current table\r\n            var w; // bits before this table == (l * h)\r\n            var xp; // pointer into x\r\n            var y; // number of dummy codes added\r\n            var z; // number of entries in current table\r\n\r\n            // Generate counts for each bit length\r\n\r\n            p = 0;\r\n            i = n;\r\n            do {\r\n                c[b[bindex + p]]++;\r\n                p++;\r\n                i--; // assume all entries <= BMAX\r\n            } while (i !== 0);\r\n\r\n            if (c[0] == n) { // null input--all zero length codes\r\n                t[0] = -1;\r\n                m[0] = 0;\r\n                return Z_OK;\r\n            }\r\n\r\n            // Find minimum and maximum length, bound *m by those\r\n            l = m[0];\r\n            for (j = 1; j <= BMAX; j++)\r\n                if (c[j] !== 0)\r\n                    break;\r\n            k = j; // minimum code length\r\n            if (l < j) {\r\n                l = j;\r\n            }\r\n            for (i = BMAX; i !== 0; i--) {\r\n                if (c[i] !== 0)\r\n                    break;\r\n            }\r\n            g = i; // maximum code length\r\n            if (l > i) {\r\n                l = i;\r\n            }\r\n            m[0] = l;\r\n\r\n            // Adjust last length count to fill out codes, if needed\r\n            for (y = 1 << j; j < i; j++, y <<= 1) {\r\n                if ((y -= c[j]) < 0) {\r\n                    return Z_DATA_ERROR;\r\n                }\r\n            }\r\n            if ((y -= c[i]) < 0) {\r\n                return Z_DATA_ERROR;\r\n            }\r\n            c[i] += y;\r\n\r\n            // Generate starting offsets into the value table for each length\r\n            x[1] = j = 0;\r\n            p = 1;\r\n            xp = 2;\r\n            while (--i !== 0) { // note that i == g from above\r\n                x[xp] = (j += c[p]);\r\n                xp++;\r\n                p++;\r\n            }\r\n\r\n            // Make a table of values in order of bit lengths\r\n            i = 0;\r\n            p = 0;\r\n            do {\r\n                if ((j = b[bindex + p]) !== 0) {\r\n                    v[x[j]++] = i;\r\n                }\r\n                p++;\r\n            } while (++i < n);\r\n            n = x[g]; // set n to length of v\r\n\r\n            // Generate the Huffman codes and for each, make the table entries\r\n            x[0] = i = 0; // first Huffman code is zero\r\n            p = 0; // grab values in bit order\r\n            h = -1; // no tables yet--level -1\r\n            w = -l; // bits decoded == (l * h)\r\n            u[0] = 0; // just to keep compilers happy\r\n            q = 0; // ditto\r\n            z = 0; // ditto\r\n\r\n            // go through the bit lengths (k already is bits in shortest code)\r\n            for (; k <= g; k++) {\r\n                a = c[k];\r\n                while (a-- !== 0) {\r\n                    // here i is the Huffman code of length k bits for value *p\r\n                    // make tables up to required level\r\n                    while (k > w + l) {\r\n                        h++;\r\n                        w += l; // previous table always l bits\r\n                        // compute minimum size table less than or equal to l bits\r\n                        z = g - w;\r\n                        z = (z > l) ? l : z; // table size upper limit\r\n                        if ((f = 1 << (j = k - w)) > a + 1) { // try a k-w bit table\r\n                            // too few codes for\r\n                            // k-w bit table\r\n                            f -= a + 1; // deduct codes from patterns left\r\n                            xp = k;\r\n                            if (j < z) {\r\n                                while (++j < z) { // try smaller tables up to z bits\r\n                                    if ((f <<= 1) <= c[++xp])\r\n                                        break; // enough codes to use up j bits\r\n                                    f -= c[xp]; // else deduct codes from patterns\r\n                                }\r\n                            }\r\n                        }\r\n                        z = 1 << j; // table entries for j-bit table\r\n\r\n                        // allocate new table\r\n                        if (hn[0] + z > MANY) { // (note: doesn't matter for fixed)\r\n                            return Z_DATA_ERROR; // overflow of MANY\r\n                        }\r\n                        u[h] = q = /* hp+ */hn[0]; // DEBUG\r\n                        hn[0] += z;\r\n\r\n                        // connect to last table, if there is one\r\n                        if (h !== 0) {\r\n                            x[h] = i; // save pattern for backing up\r\n                            r[0] = /* (byte) */j; // bits in this table\r\n                            r[1] = /* (byte) */l; // bits to dump before this table\r\n                            j = i >>> (w - l);\r\n                            r[2] = /* (int) */(q - u[h - 1] - j); // offset to this table\r\n                            hp.set(r, (u[h - 1] + j) * 3);\r\n                            // to\r\n                            // last\r\n                            // table\r\n                        } else {\r\n                            t[0] = q; // first table is returned result\r\n                        }\r\n                    }\r\n\r\n                    // set up table entry in r\r\n                    r[1] = /* (byte) */(k - w);\r\n                    if (p >= n) {\r\n                        r[0] = 128 + 64; // out of values--invalid code\r\n                    } else if (v[p] < s) {\r\n                        r[0] = /* (byte) */(v[p] < 256 ? 0 : 32 + 64); // 256 is\r\n                        // end-of-block\r\n                        r[2] = v[p++]; // simple code is just the value\r\n                    } else {\r\n                        r[0] = /* (byte) */(e[v[p] - s] + 16 + 64); // non-simple--look\r\n                        // up in lists\r\n                        r[2] = d[v[p++] - s];\r\n                    }\r\n\r\n                    // fill code-like entries with r\r\n                    f = 1 << (k - w);\r\n                    for (j = i >>> w; j < z; j += f) {\r\n                        hp.set(r, (q + j) * 3);\r\n                    }\r\n\r\n                    // backwards increment the k-bit code i\r\n                    for (j = 1 << (k - 1); (i & j) !== 0; j >>>= 1) {\r\n                        i ^= j;\r\n                    }\r\n                    i ^= j;\r\n\r\n                    // backup over finished tables\r\n                    mask = (1 << w) - 1; // needed on HP, cc -O bug\r\n                    while ((i & mask) != x[h]) {\r\n                        h--; // don't need to update q\r\n                        w -= l;\r\n                        mask = (1 << w) - 1;\r\n                    }\r\n                }\r\n            }\r\n            // Return Z_BUF_ERROR if we were given an incomplete table\r\n            return y !== 0 && g != 1 ? Z_BUF_ERROR : Z_OK;\r\n        }\r\n\r\n        function initWorkArea(vsize) {\r\n            var i;\r\n            if (!hn) {\r\n                hn = []; // []; //new Array(1);\r\n                v = []; // new Array(vsize);\r\n                c = new Int32Array(BMAX + 1); // new Array(BMAX + 1);\r\n                r = []; // new Array(3);\r\n                u = new Int32Array(BMAX); // new Array(BMAX);\r\n                x = new Int32Array(BMAX + 1); // new Array(BMAX + 1);\r\n            }\r\n            if (v.length < vsize) {\r\n                v = []; // new Array(vsize);\r\n            }\r\n            for (i = 0; i < vsize; i++) {\r\n                v[i] = 0;\r\n            }\r\n            for (i = 0; i < BMAX + 1; i++) {\r\n                c[i] = 0;\r\n            }\r\n            for (i = 0; i < 3; i++) {\r\n                r[i] = 0;\r\n            }\r\n            // for(int i=0; i<BMAX; i++){u[i]=0;}\r\n            u.set(c.subarray(0, BMAX), 0);\r\n            // for(int i=0; i<BMAX+1; i++){x[i]=0;}\r\n            x.set(c.subarray(0, BMAX + 1), 0);\r\n        }\r\n\r\n        that.inflate_trees_bits = function(c, // 19 code lengths\r\n        bb, // bits tree desired/actual depth\r\n        tb, // bits tree result\r\n        hp, // space for trees\r\n        z // for messages\r\n        ) {\r\n            var result;\r\n            initWorkArea(19);\r\n            hn[0] = 0;\r\n            result = huft_build(c, 0, 19, 19, null, null, tb, bb, hp, hn, v);\r\n\r\n            if (result == Z_DATA_ERROR) {\r\n                z.msg = \"oversubscribed dynamic bit lengths tree\";\r\n            } else if (result == Z_BUF_ERROR || bb[0] === 0) {\r\n                z.msg = \"incomplete dynamic bit lengths tree\";\r\n                result = Z_DATA_ERROR;\r\n            }\r\n            return result;\r\n        };\r\n\r\n        that.inflate_trees_dynamic = function(nl, // number of literal/length codes\r\n        nd, // number of distance codes\r\n        c, // that many (total) code lengths\r\n        bl, // literal desired/actual bit depth\r\n        bd, // distance desired/actual bit depth\r\n        tl, // literal/length tree result\r\n        td, // distance tree result\r\n        hp, // space for trees\r\n        z // for messages\r\n        ) {\r\n            var result;\r\n\r\n            // build literal/length tree\r\n            initWorkArea(288);\r\n            hn[0] = 0;\r\n            result = huft_build(c, 0, nl, 257, cplens, cplext, tl, bl, hp, hn, v);\r\n            if (result != Z_OK || bl[0] === 0) {\r\n                if (result == Z_DATA_ERROR) {\r\n                    z.msg = \"oversubscribed literal/length tree\";\r\n                } else if (result != Z_MEM_ERROR) {\r\n                    z.msg = \"incomplete literal/length tree\";\r\n                    result = Z_DATA_ERROR;\r\n                }\r\n                return result;\r\n            }\r\n\r\n            // build distance tree\r\n            initWorkArea(288);\r\n            result = huft_build(c, nl, nd, 0, cpdist, cpdext, td, bd, hp, hn, v);\r\n\r\n            if (result != Z_OK || (bd[0] === 0 && nl > 257)) {\r\n                if (result == Z_DATA_ERROR) {\r\n                    z.msg = \"oversubscribed distance tree\";\r\n                } else if (result == Z_BUF_ERROR) {\r\n                    z.msg = \"incomplete distance tree\";\r\n                    result = Z_DATA_ERROR;\r\n                } else if (result != Z_MEM_ERROR) {\r\n                    z.msg = \"empty distance tree with lengths\";\r\n                    result = Z_DATA_ERROR;\r\n                }\r\n                return result;\r\n            }\r\n\r\n            return Z_OK;\r\n        };\r\n\r\n    }\r\n\r\n    InfTree.inflate_trees_fixed = function(bl, // literal desired/actual bit depth\r\n    bd, // distance desired/actual bit depth\r\n    tl,// literal/length tree result\r\n    td// distance tree result\r\n    ) {\r\n        bl[0] = fixed_bl;\r\n        bd[0] = fixed_bd;\r\n        tl[0] = fixed_tl;\r\n        td[0] = fixed_td;\r\n        return Z_OK;\r\n    };\r\n\r\n    // InfCodes\r\n\r\n    // waiting for \"i:\"=input,\r\n    // \"o:\"=output,\r\n    // \"x:\"=nothing\r\n    var START = 0; // x: set up for LEN\r\n    var LEN = 1; // i: get length/literal/eob next\r\n    var LENEXT = 2; // i: getting length extra (have base)\r\n    var DIST = 3; // i: get distance next\r\n    var DISTEXT = 4;// i: getting distance extra\r\n    var COPY = 5; // o: copying bytes in window, waiting\r\n    // for space\r\n    var LIT = 6; // o: got literal, waiting for output\r\n    // space\r\n    var WASH = 7; // o: got eob, possibly still output\r\n    // waiting\r\n    var END = 8; // x: got eob and all data flushed\r\n    var BADCODE = 9;// x: got error\r\n\r\n    function InfCodes() {\r\n        var that = this;\r\n\r\n        var mode; // current inflate_codes mode\r\n\r\n        // mode dependent information\r\n        var len = 0;\r\n\r\n        var tree; // pointer into tree\r\n        var tree_index = 0;\r\n        var need = 0; // bits needed\r\n\r\n        var lit = 0;\r\n\r\n        // if EXT or COPY, where and how much\r\n        var get = 0; // bits to get for extra\r\n        var dist = 0; // distance back to copy from\r\n\r\n        var lbits = 0; // ltree bits decoded per branch\r\n        var dbits = 0; // dtree bits decoder per branch\r\n        var ltree; // literal/length/eob tree\r\n        var ltree_index = 0; // literal/length/eob tree\r\n        var dtree; // distance tree\r\n        var dtree_index = 0; // distance tree\r\n\r\n        // Called with number of bytes left to write in window at least 258\r\n        // (the maximum string length) and number of input bytes available\r\n        // at least ten. The ten bytes are six bytes for the longest length/\r\n        // distance pair plus four bytes for overloading the bit buffer.\r\n\r\n        function inflate_fast(bl, bd, tl, tl_index, td, td_index, s, z) {\r\n            var t; // temporary pointer\r\n            var tp; // temporary pointer\r\n            var tp_index; // temporary pointer\r\n            var e; // extra bits or operation\r\n            var b; // bit buffer\r\n            var k; // bits in bit buffer\r\n            var p; // input data pointer\r\n            var n; // bytes available there\r\n            var q; // output window write pointer\r\n            var m; // bytes to end of window or read pointer\r\n            var ml; // mask for literal/length tree\r\n            var md; // mask for distance tree\r\n            var c; // bytes to copy\r\n            var d; // distance back to copy from\r\n            var r; // copy source pointer\r\n\r\n            var tp_index_t_3; // (tp_index+t)*3\r\n\r\n            // load input, output, bit values\r\n            p = z.next_in_index;\r\n            n = z.avail_in;\r\n            b = s.bitb;\r\n            k = s.bitk;\r\n            q = s.write;\r\n            m = q < s.read ? s.read - q - 1 : s.end - q;\r\n\r\n            // initialize masks\r\n            ml = inflate_mask[bl];\r\n            md = inflate_mask[bd];\r\n\r\n            // do until not enough input or output space for fast loop\r\n            do { // assume called with m >= 258 && n >= 10\r\n                // get literal/length code\r\n                while (k < (20)) { // max bits for literal/length code\r\n                    n--;\r\n                    b |= (z.read_byte(p++) & 0xff) << k;\r\n                    k += 8;\r\n                }\r\n\r\n                t = b & ml;\r\n                tp = tl;\r\n                tp_index = tl_index;\r\n                tp_index_t_3 = (tp_index + t) * 3;\r\n                if ((e = tp[tp_index_t_3]) === 0) {\r\n                    b >>= (tp[tp_index_t_3 + 1]);\r\n                    k -= (tp[tp_index_t_3 + 1]);\r\n\r\n                    s.window[q++] = /* (byte) */tp[tp_index_t_3 + 2];\r\n                    m--;\r\n                    continue;\r\n                }\r\n                do {\r\n\r\n                    b >>= (tp[tp_index_t_3 + 1]);\r\n                    k -= (tp[tp_index_t_3 + 1]);\r\n\r\n                    if ((e & 16) !== 0) {\r\n                        e &= 15;\r\n                        c = tp[tp_index_t_3 + 2] + (/* (int) */b & inflate_mask[e]);\r\n\r\n                        b >>= e;\r\n                        k -= e;\r\n\r\n                        // decode distance base of block to copy\r\n                        while (k < (15)) { // max bits for distance code\r\n                            n--;\r\n                            b |= (z.read_byte(p++) & 0xff) << k;\r\n                            k += 8;\r\n                        }\r\n\r\n                        t = b & md;\r\n                        tp = td;\r\n                        tp_index = td_index;\r\n                        tp_index_t_3 = (tp_index + t) * 3;\r\n                        e = tp[tp_index_t_3];\r\n\r\n                        do {\r\n\r\n                            b >>= (tp[tp_index_t_3 + 1]);\r\n                            k -= (tp[tp_index_t_3 + 1]);\r\n\r\n                            if ((e & 16) !== 0) {\r\n                                // get extra bits to add to distance base\r\n                                e &= 15;\r\n                                while (k < (e)) { // get extra bits (up to 13)\r\n                                    n--;\r\n                                    b |= (z.read_byte(p++) & 0xff) << k;\r\n                                    k += 8;\r\n                                }\r\n\r\n                                d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);\r\n\r\n                                b >>= (e);\r\n                                k -= (e);\r\n\r\n                                // do the copy\r\n                                m -= c;\r\n                                if (q >= d) { // offset before dest\r\n                                    // just copy\r\n                                    r = q - d;\r\n                                    if (q - r > 0 && 2 > (q - r)) {\r\n                                        s.window[q++] = s.window[r++]; // minimum\r\n                                        // count is\r\n                                        // three,\r\n                                        s.window[q++] = s.window[r++]; // so unroll\r\n                                        // loop a\r\n                                        // little\r\n                                        c -= 2;\r\n                                    } else {\r\n                                        s.window.set(s.window.subarray(r, r + 2), q);\r\n                                        q += 2;\r\n                                        r += 2;\r\n                                        c -= 2;\r\n                                    }\r\n                                } else { // else offset after destination\r\n                                    r = q - d;\r\n                                    do {\r\n                                        r += s.end; // force pointer in window\r\n                                    } while (r < 0); // covers invalid distances\r\n                                    e = s.end - r;\r\n                                    if (c > e) { // if source crosses,\r\n                                        c -= e; // wrapped copy\r\n                                        if (q - r > 0 && e > (q - r)) {\r\n                                            do {\r\n                                                s.window[q++] = s.window[r++];\r\n                                            } while (--e !== 0);\r\n                                        } else {\r\n                                            s.window.set(s.window.subarray(r, r + e), q);\r\n                                            q += e;\r\n                                            r += e;\r\n                                            e = 0;\r\n                                        }\r\n                                        r = 0; // copy rest from start of window\r\n                                    }\r\n\r\n                                }\r\n\r\n                                // copy all or what's left\r\n                                if (q - r > 0 && c > (q - r)) {\r\n                                    do {\r\n                                        s.window[q++] = s.window[r++];\r\n                                    } while (--c !== 0);\r\n                                } else {\r\n                                    s.window.set(s.window.subarray(r, r + c), q);\r\n                                    q += c;\r\n                                    r += c;\r\n                                    c = 0;\r\n                                }\r\n                                break;\r\n                            } else if ((e & 64) === 0) {\r\n                                t += tp[tp_index_t_3 + 2];\r\n                                t += (b & inflate_mask[e]);\r\n                                tp_index_t_3 = (tp_index + t) * 3;\r\n                                e = tp[tp_index_t_3];\r\n                            } else {\r\n                                z.msg = \"invalid distance code\";\r\n\r\n                                c = z.avail_in - n;\r\n                                c = (k >> 3) < c ? k >> 3 : c;\r\n                                n += c;\r\n                                p -= c;\r\n                                k -= c << 3;\r\n\r\n                                s.bitb = b;\r\n                                s.bitk = k;\r\n                                z.avail_in = n;\r\n                                z.total_in += p - z.next_in_index;\r\n                                z.next_in_index = p;\r\n                                s.write = q;\r\n\r\n                                return Z_DATA_ERROR;\r\n                            }\r\n                        } while (true);\r\n                        break;\r\n                    }\r\n\r\n                    if ((e & 64) === 0) {\r\n                        t += tp[tp_index_t_3 + 2];\r\n                        t += (b & inflate_mask[e]);\r\n                        tp_index_t_3 = (tp_index + t) * 3;\r\n                        if ((e = tp[tp_index_t_3]) === 0) {\r\n\r\n                            b >>= (tp[tp_index_t_3 + 1]);\r\n                            k -= (tp[tp_index_t_3 + 1]);\r\n\r\n                            s.window[q++] = /* (byte) */tp[tp_index_t_3 + 2];\r\n                            m--;\r\n                            break;\r\n                        }\r\n                    } else if ((e & 32) !== 0) {\r\n\r\n                        c = z.avail_in - n;\r\n                        c = (k >> 3) < c ? k >> 3 : c;\r\n                        n += c;\r\n                        p -= c;\r\n                        k -= c << 3;\r\n\r\n                        s.bitb = b;\r\n                        s.bitk = k;\r\n                        z.avail_in = n;\r\n                        z.total_in += p - z.next_in_index;\r\n                        z.next_in_index = p;\r\n                        s.write = q;\r\n\r\n                        return Z_STREAM_END;\r\n                    } else {\r\n                        z.msg = \"invalid literal/length code\";\r\n\r\n                        c = z.avail_in - n;\r\n                        c = (k >> 3) < c ? k >> 3 : c;\r\n                        n += c;\r\n                        p -= c;\r\n                        k -= c << 3;\r\n\r\n                        s.bitb = b;\r\n                        s.bitk = k;\r\n                        z.avail_in = n;\r\n                        z.total_in += p - z.next_in_index;\r\n                        z.next_in_index = p;\r\n                        s.write = q;\r\n\r\n                        return Z_DATA_ERROR;\r\n                    }\r\n                } while (true);\r\n            } while (m >= 258 && n >= 10);\r\n\r\n            // not enough input or output--restore pointers and return\r\n            c = z.avail_in - n;\r\n            c = (k >> 3) < c ? k >> 3 : c;\r\n            n += c;\r\n            p -= c;\r\n            k -= c << 3;\r\n\r\n            s.bitb = b;\r\n            s.bitk = k;\r\n            z.avail_in = n;\r\n            z.total_in += p - z.next_in_index;\r\n            z.next_in_index = p;\r\n            s.write = q;\r\n\r\n            return Z_OK;\r\n        }\r\n\r\n        that.init = function(bl, bd, tl, tl_index, td, td_index) {\r\n            mode = START;\r\n            lbits = /* (byte) */bl;\r\n            dbits = /* (byte) */bd;\r\n            ltree = tl;\r\n            ltree_index = tl_index;\r\n            dtree = td;\r\n            dtree_index = td_index;\r\n            tree = null;\r\n        };\r\n\r\n        that.proc = function(s, z, r) {\r\n            var j; // temporary storage\r\n            var tindex; // temporary pointer\r\n            var e; // extra bits or operation\r\n            var b = 0; // bit buffer\r\n            var k = 0; // bits in bit buffer\r\n            var p = 0; // input data pointer\r\n            var n; // bytes available there\r\n            var q; // output window write pointer\r\n            var m; // bytes to end of window or read pointer\r\n            var f; // pointer to copy strings from\r\n\r\n            // copy input/output information to locals (UPDATE macro restores)\r\n            p = z.next_in_index;\r\n            n = z.avail_in;\r\n            b = s.bitb;\r\n            k = s.bitk;\r\n            q = s.write;\r\n            m = q < s.read ? s.read - q - 1 : s.end - q;\r\n\r\n            // process input and output based on current state\r\n            while (true) {\r\n                switch (mode) {\r\n                // waiting for \"i:\"=input, \"o:\"=output, \"x:\"=nothing\r\n                case START: // x: set up for LEN\r\n                    if (m >= 258 && n >= 10) {\r\n\r\n                        s.bitb = b;\r\n                        s.bitk = k;\r\n                        z.avail_in = n;\r\n                        z.total_in += p - z.next_in_index;\r\n                        z.next_in_index = p;\r\n                        s.write = q;\r\n                        r = inflate_fast(lbits, dbits, ltree, ltree_index, dtree, dtree_index, s, z);\r\n\r\n                        p = z.next_in_index;\r\n                        n = z.avail_in;\r\n                        b = s.bitb;\r\n                        k = s.bitk;\r\n                        q = s.write;\r\n                        m = q < s.read ? s.read - q - 1 : s.end - q;\r\n\r\n                        if (r != Z_OK) {\r\n                            mode = r == Z_STREAM_END ? WASH : BADCODE;\r\n                            break;\r\n                        }\r\n                    }\r\n                    need = lbits;\r\n                    tree = ltree;\r\n                    tree_index = ltree_index;\r\n\r\n                    mode = LEN;\r\n                    /* falls through */\r\n                case LEN: // i: get length/literal/eob next\r\n                    j = need;\r\n\r\n                    while (k < (j)) {\r\n                        if (n !== 0)\r\n                            r = Z_OK;\r\n                        else {\r\n\r\n                            s.bitb = b;\r\n                            s.bitk = k;\r\n                            z.avail_in = n;\r\n                            z.total_in += p - z.next_in_index;\r\n                            z.next_in_index = p;\r\n                            s.write = q;\r\n                            return s.inflate_flush(z, r);\r\n                        }\r\n                        n--;\r\n                        b |= (z.read_byte(p++) & 0xff) << k;\r\n                        k += 8;\r\n                    }\r\n\r\n                    tindex = (tree_index + (b & inflate_mask[j])) * 3;\r\n\r\n                    b >>>= (tree[tindex + 1]);\r\n                    k -= (tree[tindex + 1]);\r\n\r\n                    e = tree[tindex];\r\n\r\n                    if (e === 0) { // literal\r\n                        lit = tree[tindex + 2];\r\n                        mode = LIT;\r\n                        break;\r\n                    }\r\n                    if ((e & 16) !== 0) { // length\r\n                        get = e & 15;\r\n                        len = tree[tindex + 2];\r\n                        mode = LENEXT;\r\n                        break;\r\n                    }\r\n                    if ((e & 64) === 0) { // next table\r\n                        need = e;\r\n                        tree_index = tindex / 3 + tree[tindex + 2];\r\n                        break;\r\n                    }\r\n                    if ((e & 32) !== 0) { // end of block\r\n                        mode = WASH;\r\n                        break;\r\n                    }\r\n                    mode = BADCODE; // invalid code\r\n                    z.msg = \"invalid literal/length code\";\r\n                    r = Z_DATA_ERROR;\r\n\r\n                    s.bitb = b;\r\n                    s.bitk = k;\r\n                    z.avail_in = n;\r\n                    z.total_in += p - z.next_in_index;\r\n                    z.next_in_index = p;\r\n                    s.write = q;\r\n                    return s.inflate_flush(z, r);\r\n\r\n                case LENEXT: // i: getting length extra (have base)\r\n                    j = get;\r\n\r\n                    while (k < (j)) {\r\n                        if (n !== 0)\r\n                            r = Z_OK;\r\n                        else {\r\n\r\n                            s.bitb = b;\r\n                            s.bitk = k;\r\n                            z.avail_in = n;\r\n                            z.total_in += p - z.next_in_index;\r\n                            z.next_in_index = p;\r\n                            s.write = q;\r\n                            return s.inflate_flush(z, r);\r\n                        }\r\n                        n--;\r\n                        b |= (z.read_byte(p++) & 0xff) << k;\r\n                        k += 8;\r\n                    }\r\n\r\n                    len += (b & inflate_mask[j]);\r\n\r\n                    b >>= j;\r\n                    k -= j;\r\n\r\n                    need = dbits;\r\n                    tree = dtree;\r\n                    tree_index = dtree_index;\r\n                    mode = DIST;\r\n                    /* falls through */\r\n                case DIST: // i: get distance next\r\n                    j = need;\r\n\r\n                    while (k < (j)) {\r\n                        if (n !== 0)\r\n                            r = Z_OK;\r\n                        else {\r\n\r\n                            s.bitb = b;\r\n                            s.bitk = k;\r\n                            z.avail_in = n;\r\n                            z.total_in += p - z.next_in_index;\r\n                            z.next_in_index = p;\r\n                            s.write = q;\r\n                            return s.inflate_flush(z, r);\r\n                        }\r\n                        n--;\r\n                        b |= (z.read_byte(p++) & 0xff) << k;\r\n                        k += 8;\r\n                    }\r\n\r\n                    tindex = (tree_index + (b & inflate_mask[j])) * 3;\r\n\r\n                    b >>= tree[tindex + 1];\r\n                    k -= tree[tindex + 1];\r\n\r\n                    e = (tree[tindex]);\r\n                    if ((e & 16) !== 0) { // distance\r\n                        get = e & 15;\r\n                        dist = tree[tindex + 2];\r\n                        mode = DISTEXT;\r\n                        break;\r\n                    }\r\n                    if ((e & 64) === 0) { // next table\r\n                        need = e;\r\n                        tree_index = tindex / 3 + tree[tindex + 2];\r\n                        break;\r\n                    }\r\n                    mode = BADCODE; // invalid code\r\n                    z.msg = \"invalid distance code\";\r\n                    r = Z_DATA_ERROR;\r\n\r\n                    s.bitb = b;\r\n                    s.bitk = k;\r\n                    z.avail_in = n;\r\n                    z.total_in += p - z.next_in_index;\r\n                    z.next_in_index = p;\r\n                    s.write = q;\r\n                    return s.inflate_flush(z, r);\r\n\r\n                case DISTEXT: // i: getting distance extra\r\n                    j = get;\r\n\r\n                    while (k < (j)) {\r\n                        if (n !== 0)\r\n                            r = Z_OK;\r\n                        else {\r\n\r\n                            s.bitb = b;\r\n                            s.bitk = k;\r\n                            z.avail_in = n;\r\n                            z.total_in += p - z.next_in_index;\r\n                            z.next_in_index = p;\r\n                            s.write = q;\r\n                            return s.inflate_flush(z, r);\r\n                        }\r\n                        n--;\r\n                        b |= (z.read_byte(p++) & 0xff) << k;\r\n                        k += 8;\r\n                    }\r\n\r\n                    dist += (b & inflate_mask[j]);\r\n\r\n                    b >>= j;\r\n                    k -= j;\r\n\r\n                    mode = COPY;\r\n                    /* falls through */\r\n                case COPY: // o: copying bytes in window, waiting for space\r\n                    f = q - dist;\r\n                    while (f < 0) { // modulo window size-\"while\" instead\r\n                        f += s.end; // of \"if\" handles invalid distances\r\n                    }\r\n                    while (len !== 0) {\r\n\r\n                        if (m === 0) {\r\n                            if (q == s.end && s.read !== 0) {\r\n                                q = 0;\r\n                                m = q < s.read ? s.read - q - 1 : s.end - q;\r\n                            }\r\n                            if (m === 0) {\r\n                                s.write = q;\r\n                                r = s.inflate_flush(z, r);\r\n                                q = s.write;\r\n                                m = q < s.read ? s.read - q - 1 : s.end - q;\r\n\r\n                                if (q == s.end && s.read !== 0) {\r\n                                    q = 0;\r\n                                    m = q < s.read ? s.read - q - 1 : s.end - q;\r\n                                }\r\n\r\n                                if (m === 0) {\r\n                                    s.bitb = b;\r\n                                    s.bitk = k;\r\n                                    z.avail_in = n;\r\n                                    z.total_in += p - z.next_in_index;\r\n                                    z.next_in_index = p;\r\n                                    s.write = q;\r\n                                    return s.inflate_flush(z, r);\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        s.window[q++] = s.window[f++];\r\n                        m--;\r\n\r\n                        if (f == s.end)\r\n                            f = 0;\r\n                        len--;\r\n                    }\r\n                    mode = START;\r\n                    break;\r\n                case LIT: // o: got literal, waiting for output space\r\n                    if (m === 0) {\r\n                        if (q == s.end && s.read !== 0) {\r\n                            q = 0;\r\n                            m = q < s.read ? s.read - q - 1 : s.end - q;\r\n                        }\r\n                        if (m === 0) {\r\n                            s.write = q;\r\n                            r = s.inflate_flush(z, r);\r\n                            q = s.write;\r\n                            m = q < s.read ? s.read - q - 1 : s.end - q;\r\n\r\n                            if (q == s.end && s.read !== 0) {\r\n                                q = 0;\r\n                                m = q < s.read ? s.read - q - 1 : s.end - q;\r\n                            }\r\n                            if (m === 0) {\r\n                                s.bitb = b;\r\n                                s.bitk = k;\r\n                                z.avail_in = n;\r\n                                z.total_in += p - z.next_in_index;\r\n                                z.next_in_index = p;\r\n                                s.write = q;\r\n                                return s.inflate_flush(z, r);\r\n                            }\r\n                        }\r\n                    }\r\n                    r = Z_OK;\r\n\r\n                    s.window[q++] = /* (byte) */lit;\r\n                    m--;\r\n\r\n                    mode = START;\r\n                    break;\r\n                case WASH: // o: got eob, possibly more output\r\n                    if (k > 7) { // return unused byte, if any\r\n                        k -= 8;\r\n                        n++;\r\n                        p--; // can always return one\r\n                    }\r\n\r\n                    s.write = q;\r\n                    r = s.inflate_flush(z, r);\r\n                    q = s.write;\r\n                    m = q < s.read ? s.read - q - 1 : s.end - q;\r\n\r\n                    if (s.read != s.write) {\r\n                        s.bitb = b;\r\n                        s.bitk = k;\r\n                        z.avail_in = n;\r\n                        z.total_in += p - z.next_in_index;\r\n                        z.next_in_index = p;\r\n                        s.write = q;\r\n                        return s.inflate_flush(z, r);\r\n                    }\r\n                    mode = END;\r\n                    /* falls through */\r\n                case END:\r\n                    r = Z_STREAM_END;\r\n                    s.bitb = b;\r\n                    s.bitk = k;\r\n                    z.avail_in = n;\r\n                    z.total_in += p - z.next_in_index;\r\n                    z.next_in_index = p;\r\n                    s.write = q;\r\n                    return s.inflate_flush(z, r);\r\n\r\n                case BADCODE: // x: got error\r\n\r\n                    r = Z_DATA_ERROR;\r\n\r\n                    s.bitb = b;\r\n                    s.bitk = k;\r\n                    z.avail_in = n;\r\n                    z.total_in += p - z.next_in_index;\r\n                    z.next_in_index = p;\r\n                    s.write = q;\r\n                    return s.inflate_flush(z, r);\r\n\r\n                default:\r\n                    r = Z_STREAM_ERROR;\r\n\r\n                    s.bitb = b;\r\n                    s.bitk = k;\r\n                    z.avail_in = n;\r\n                    z.total_in += p - z.next_in_index;\r\n                    z.next_in_index = p;\r\n                    s.write = q;\r\n                    return s.inflate_flush(z, r);\r\n                }\r\n            }\r\n        };\r\n\r\n        that.free = function() {\r\n            // ZFREE(z, c);\r\n        };\r\n\r\n    }\r\n\r\n    // InfBlocks\r\n\r\n    // Table for deflate from PKZIP's appnote.txt.\r\n    var border = [ // Order of the bit length code lengths\r\n    16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];\r\n\r\n    var TYPE = 0; // get type bits (3, including end bit)\r\n    var LENS = 1; // get lengths for stored\r\n    var STORED = 2;// processing stored block\r\n    var TABLE = 3; // get table lengths\r\n    var BTREE = 4; // get bit lengths tree for a dynamic\r\n    // block\r\n    var DTREE = 5; // get length, distance trees for a\r\n    // dynamic block\r\n    var CODES = 6; // processing fixed or dynamic block\r\n    var DRY = 7; // output remaining window bytes\r\n    var DONELOCKS = 8; // finished last block, done\r\n    var BADBLOCKS = 9; // ot a data error--stuck here\r\n\r\n    function InfBlocks(z, w) {\r\n        var that = this;\r\n\r\n        var mode = TYPE; // current inflate_block mode\r\n\r\n        var left = 0; // if STORED, bytes left to copy\r\n\r\n        var table = 0; // table lengths (14 bits)\r\n        var index = 0; // index into blens (or border)\r\n        var blens; // bit lengths of codes\r\n        var bb = [ 0 ]; // bit length tree depth\r\n        var tb = [ 0 ]; // bit length decoding tree\r\n\r\n        var codes = new InfCodes(); // if CODES, current state\r\n\r\n        var last = 0; // true if this block is the last block\r\n\r\n        var hufts = new Int32Array(MANY * 3); // single malloc for tree space\r\n        var check = 0; // check on output\r\n        var inftree = new InfTree();\r\n\r\n        that.bitk = 0; // bits in bit buffer\r\n        that.bitb = 0; // bit buffer\r\n        that.window = new Uint8Array(w); // sliding window\r\n        that.end = w; // one byte after sliding window\r\n        that.read = 0; // window read pointer\r\n        that.write = 0; // window write pointer\r\n\r\n        that.reset = function(z, c) {\r\n            if (c)\r\n                c[0] = check;\r\n            // if (mode == BTREE || mode == DTREE) {\r\n            // }\r\n            if (mode == CODES) {\r\n                codes.free(z);\r\n            }\r\n            mode = TYPE;\r\n            that.bitk = 0;\r\n            that.bitb = 0;\r\n            that.read = that.write = 0;\r\n        };\r\n\r\n        that.reset(z, null);\r\n\r\n        // copy as much as possible from the sliding window to the output area\r\n        that.inflate_flush = function(z, r) {\r\n            var n;\r\n            var p;\r\n            var q;\r\n\r\n            // local copies of source and destination pointers\r\n            p = z.next_out_index;\r\n            q = that.read;\r\n\r\n            // compute number of bytes to copy as far as end of window\r\n            n = /* (int) */((q <= that.write ? that.write : that.end) - q);\r\n            if (n > z.avail_out)\r\n                n = z.avail_out;\r\n            if (n !== 0 && r == Z_BUF_ERROR)\r\n                r = Z_OK;\r\n\r\n            // update counters\r\n            z.avail_out -= n;\r\n            z.total_out += n;\r\n\r\n            // copy as far as end of window\r\n            z.next_out.set(that.window.subarray(q, q + n), p);\r\n            p += n;\r\n            q += n;\r\n\r\n            // see if more to copy at beginning of window\r\n            if (q == that.end) {\r\n                // wrap pointers\r\n                q = 0;\r\n                if (that.write == that.end)\r\n                    that.write = 0;\r\n\r\n                // compute bytes to copy\r\n                n = that.write - q;\r\n                if (n > z.avail_out)\r\n                    n = z.avail_out;\r\n                if (n !== 0 && r == Z_BUF_ERROR)\r\n                    r = Z_OK;\r\n\r\n                // update counters\r\n                z.avail_out -= n;\r\n                z.total_out += n;\r\n\r\n                // copy\r\n                z.next_out.set(that.window.subarray(q, q + n), p);\r\n                p += n;\r\n                q += n;\r\n            }\r\n\r\n            // update pointers\r\n            z.next_out_index = p;\r\n            that.read = q;\r\n\r\n            // done\r\n            return r;\r\n        };\r\n\r\n        that.proc = function(z, r) {\r\n            var t; // temporary storage\r\n            var b; // bit buffer\r\n            var k; // bits in bit buffer\r\n            var p; // input data pointer\r\n            var n; // bytes available there\r\n            var q; // output window write pointer\r\n            var m; // bytes to end of window or read pointer\r\n\r\n            var i;\r\n\r\n            // copy input/output information to locals (UPDATE macro restores)\r\n            // {\r\n            p = z.next_in_index;\r\n            n = z.avail_in;\r\n            b = that.bitb;\r\n            k = that.bitk;\r\n            // }\r\n            // {\r\n            q = that.write;\r\n            m = /* (int) */(q < that.read ? that.read - q - 1 : that.end - q);\r\n            // }\r\n\r\n            // process input based on current state\r\n            // DEBUG dtree\r\n            while (true) {\r\n                switch (mode) {\r\n                case TYPE:\r\n\r\n                    while (k < (3)) {\r\n                        if (n !== 0) {\r\n                            r = Z_OK;\r\n                        } else {\r\n                            that.bitb = b;\r\n                            that.bitk = k;\r\n                            z.avail_in = n;\r\n                            z.total_in += p - z.next_in_index;\r\n                            z.next_in_index = p;\r\n                            that.write = q;\r\n                            return that.inflate_flush(z, r);\r\n                        }\r\n                        n--;\r\n                        b |= (z.read_byte(p++) & 0xff) << k;\r\n                        k += 8;\r\n                    }\r\n                    t = /* (int) */(b & 7);\r\n                    last = t & 1;\r\n\r\n                    switch (t >>> 1) {\r\n                    case 0: // stored\r\n                        // {\r\n                        b >>>= (3);\r\n                        k -= (3);\r\n                        // }\r\n                        t = k & 7; // go to byte boundary\r\n\r\n                        // {\r\n                        b >>>= (t);\r\n                        k -= (t);\r\n                        // }\r\n                        mode = LENS; // get length of stored block\r\n                        break;\r\n                    case 1: // fixed\r\n                        // {\r\n                        var bl = []; // new Array(1);\r\n                        var bd = []; // new Array(1);\r\n                        var tl = [ [] ]; // new Array(1);\r\n                        var td = [ [] ]; // new Array(1);\r\n\r\n                        InfTree.inflate_trees_fixed(bl, bd, tl, td);\r\n                        codes.init(bl[0], bd[0], tl[0], 0, td[0], 0);\r\n                        // }\r\n\r\n                        // {\r\n                        b >>>= (3);\r\n                        k -= (3);\r\n                        // }\r\n\r\n                        mode = CODES;\r\n                        break;\r\n                    case 2: // dynamic\r\n\r\n                        // {\r\n                        b >>>= (3);\r\n                        k -= (3);\r\n                        // }\r\n\r\n                        mode = TABLE;\r\n                        break;\r\n                    case 3: // illegal\r\n\r\n                        // {\r\n                        b >>>= (3);\r\n                        k -= (3);\r\n                        // }\r\n                        mode = BADBLOCKS;\r\n                        z.msg = \"invalid block type\";\r\n                        r = Z_DATA_ERROR;\r\n\r\n                        that.bitb = b;\r\n                        that.bitk = k;\r\n                        z.avail_in = n;\r\n                        z.total_in += p - z.next_in_index;\r\n                        z.next_in_index = p;\r\n                        that.write = q;\r\n                        return that.inflate_flush(z, r);\r\n                    }\r\n                    break;\r\n                case LENS:\r\n\r\n                    while (k < (32)) {\r\n                        if (n !== 0) {\r\n                            r = Z_OK;\r\n                        } else {\r\n                            that.bitb = b;\r\n                            that.bitk = k;\r\n                            z.avail_in = n;\r\n                            z.total_in += p - z.next_in_index;\r\n                            z.next_in_index = p;\r\n                            that.write = q;\r\n                            return that.inflate_flush(z, r);\r\n                        }\r\n                        n--;\r\n                        b |= (z.read_byte(p++) & 0xff) << k;\r\n                        k += 8;\r\n                    }\r\n\r\n                    if ((((~b) >>> 16) & 0xffff) != (b & 0xffff)) {\r\n                        mode = BADBLOCKS;\r\n                        z.msg = \"invalid stored block lengths\";\r\n                        r = Z_DATA_ERROR;\r\n\r\n                        that.bitb = b;\r\n                        that.bitk = k;\r\n                        z.avail_in = n;\r\n                        z.total_in += p - z.next_in_index;\r\n                        z.next_in_index = p;\r\n                        that.write = q;\r\n                        return that.inflate_flush(z, r);\r\n                    }\r\n                    left = (b & 0xffff);\r\n                    b = k = 0; // dump bits\r\n                    mode = left !== 0 ? STORED : (last !== 0 ? DRY : TYPE);\r\n                    break;\r\n                case STORED:\r\n                    if (n === 0) {\r\n                        that.bitb = b;\r\n                        that.bitk = k;\r\n                        z.avail_in = n;\r\n                        z.total_in += p - z.next_in_index;\r\n                        z.next_in_index = p;\r\n                        that.write = q;\r\n                        return that.inflate_flush(z, r);\r\n                    }\r\n\r\n                    if (m === 0) {\r\n                        if (q == that.end && that.read !== 0) {\r\n                            q = 0;\r\n                            m = /* (int) */(q < that.read ? that.read - q - 1 : that.end - q);\r\n                        }\r\n                        if (m === 0) {\r\n                            that.write = q;\r\n                            r = that.inflate_flush(z, r);\r\n                            q = that.write;\r\n                            m = /* (int) */(q < that.read ? that.read - q - 1 : that.end - q);\r\n                            if (q == that.end && that.read !== 0) {\r\n                                q = 0;\r\n                                m = /* (int) */(q < that.read ? that.read - q - 1 : that.end - q);\r\n                            }\r\n                            if (m === 0) {\r\n                                that.bitb = b;\r\n                                that.bitk = k;\r\n                                z.avail_in = n;\r\n                                z.total_in += p - z.next_in_index;\r\n                                z.next_in_index = p;\r\n                                that.write = q;\r\n                                return that.inflate_flush(z, r);\r\n                            }\r\n                        }\r\n                    }\r\n                    r = Z_OK;\r\n\r\n                    t = left;\r\n                    if (t > n)\r\n                        t = n;\r\n                    if (t > m)\r\n                        t = m;\r\n                    that.window.set(z.read_buf(p, t), q);\r\n                    p += t;\r\n                    n -= t;\r\n                    q += t;\r\n                    m -= t;\r\n                    if ((left -= t) !== 0)\r\n                        break;\r\n                    mode = last !== 0 ? DRY : TYPE;\r\n                    break;\r\n                case TABLE:\r\n\r\n                    while (k < (14)) {\r\n                        if (n !== 0) {\r\n                            r = Z_OK;\r\n                        } else {\r\n                            that.bitb = b;\r\n                            that.bitk = k;\r\n                            z.avail_in = n;\r\n                            z.total_in += p - z.next_in_index;\r\n                            z.next_in_index = p;\r\n                            that.write = q;\r\n                            return that.inflate_flush(z, r);\r\n                        }\r\n\r\n                        n--;\r\n                        b |= (z.read_byte(p++) & 0xff) << k;\r\n                        k += 8;\r\n                    }\r\n\r\n                    table = t = (b & 0x3fff);\r\n                    if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {\r\n                        mode = BADBLOCKS;\r\n                        z.msg = \"too many length or distance symbols\";\r\n                        r = Z_DATA_ERROR;\r\n\r\n                        that.bitb = b;\r\n                        that.bitk = k;\r\n                        z.avail_in = n;\r\n                        z.total_in += p - z.next_in_index;\r\n                        z.next_in_index = p;\r\n                        that.write = q;\r\n                        return that.inflate_flush(z, r);\r\n                    }\r\n                    t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);\r\n                    if (!blens || blens.length < t) {\r\n                        blens = []; // new Array(t);\r\n                    } else {\r\n                        for (i = 0; i < t; i++) {\r\n                            blens[i] = 0;\r\n                        }\r\n                    }\r\n\r\n                    // {\r\n                    b >>>= (14);\r\n                    k -= (14);\r\n                    // }\r\n\r\n                    index = 0;\r\n                    mode = BTREE;\r\n                    /* falls through */\r\n                case BTREE:\r\n                    while (index < 4 + (table >>> 10)) {\r\n                        while (k < (3)) {\r\n                            if (n !== 0) {\r\n                                r = Z_OK;\r\n                            } else {\r\n                                that.bitb = b;\r\n                                that.bitk = k;\r\n                                z.avail_in = n;\r\n                                z.total_in += p - z.next_in_index;\r\n                                z.next_in_index = p;\r\n                                that.write = q;\r\n                                return that.inflate_flush(z, r);\r\n                            }\r\n                            n--;\r\n                            b |= (z.read_byte(p++) & 0xff) << k;\r\n                            k += 8;\r\n                        }\r\n\r\n                        blens[border[index++]] = b & 7;\r\n\r\n                        // {\r\n                        b >>>= (3);\r\n                        k -= (3);\r\n                        // }\r\n                    }\r\n\r\n                    while (index < 19) {\r\n                        blens[border[index++]] = 0;\r\n                    }\r\n\r\n                    bb[0] = 7;\r\n                    t = inftree.inflate_trees_bits(blens, bb, tb, hufts, z);\r\n                    if (t != Z_OK) {\r\n                        r = t;\r\n                        if (r == Z_DATA_ERROR) {\r\n                            blens = null;\r\n                            mode = BADBLOCKS;\r\n                        }\r\n\r\n                        that.bitb = b;\r\n                        that.bitk = k;\r\n                        z.avail_in = n;\r\n                        z.total_in += p - z.next_in_index;\r\n                        z.next_in_index = p;\r\n                        that.write = q;\r\n                        return that.inflate_flush(z, r);\r\n                    }\r\n\r\n                    index = 0;\r\n                    mode = DTREE;\r\n                    /* falls through */\r\n                case DTREE:\r\n                    while (true) {\r\n                        t = table;\r\n                        if (index >= 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {\r\n                            break;\r\n                        }\r\n\r\n                        var j, c;\r\n\r\n                        t = bb[0];\r\n\r\n                        while (k < (t)) {\r\n                            if (n !== 0) {\r\n                                r = Z_OK;\r\n                            } else {\r\n                                that.bitb = b;\r\n                                that.bitk = k;\r\n                                z.avail_in = n;\r\n                                z.total_in += p - z.next_in_index;\r\n                                z.next_in_index = p;\r\n                                that.write = q;\r\n                                return that.inflate_flush(z, r);\r\n                            }\r\n                            n--;\r\n                            b |= (z.read_byte(p++) & 0xff) << k;\r\n                            k += 8;\r\n                        }\r\n\r\n                        // if (tb[0] == -1) {\r\n                        // System.err.println(\"null...\");\r\n                        // }\r\n\r\n                        t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];\r\n                        c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];\r\n\r\n                        if (c < 16) {\r\n                            b >>>= (t);\r\n                            k -= (t);\r\n                            blens[index++] = c;\r\n                        } else { // c == 16..18\r\n                            i = c == 18 ? 7 : c - 14;\r\n                            j = c == 18 ? 11 : 3;\r\n\r\n                            while (k < (t + i)) {\r\n                                if (n !== 0) {\r\n                                    r = Z_OK;\r\n                                } else {\r\n                                    that.bitb = b;\r\n                                    that.bitk = k;\r\n                                    z.avail_in = n;\r\n                                    z.total_in += p - z.next_in_index;\r\n                                    z.next_in_index = p;\r\n                                    that.write = q;\r\n                                    return that.inflate_flush(z, r);\r\n                                }\r\n                                n--;\r\n                                b |= (z.read_byte(p++) & 0xff) << k;\r\n                                k += 8;\r\n                            }\r\n\r\n                            b >>>= (t);\r\n                            k -= (t);\r\n\r\n                            j += (b & inflate_mask[i]);\r\n\r\n                            b >>>= (i);\r\n                            k -= (i);\r\n\r\n                            i = index;\r\n                            t = table;\r\n                            if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {\r\n                                blens = null;\r\n                                mode = BADBLOCKS;\r\n                                z.msg = \"invalid bit length repeat\";\r\n                                r = Z_DATA_ERROR;\r\n\r\n                                that.bitb = b;\r\n                                that.bitk = k;\r\n                                z.avail_in = n;\r\n                                z.total_in += p - z.next_in_index;\r\n                                z.next_in_index = p;\r\n                                that.write = q;\r\n                                return that.inflate_flush(z, r);\r\n                            }\r\n\r\n                            c = c == 16 ? blens[i - 1] : 0;\r\n                            do {\r\n                                blens[i++] = c;\r\n                            } while (--j !== 0);\r\n                            index = i;\r\n                        }\r\n                    }\r\n\r\n                    tb[0] = -1;\r\n                    // {\r\n                    var bl_ = []; // new Array(1);\r\n                    var bd_ = []; // new Array(1);\r\n                    var tl_ = []; // new Array(1);\r\n                    var td_ = []; // new Array(1);\r\n                    bl_[0] = 9; // must be <= 9 for lookahead assumptions\r\n                    bd_[0] = 6; // must be <= 9 for lookahead assumptions\r\n\r\n                    t = table;\r\n                    t = inftree.inflate_trees_dynamic(257 + (t & 0x1f), 1 + ((t >> 5) & 0x1f), blens, bl_, bd_, tl_, td_, hufts, z);\r\n\r\n                    if (t != Z_OK) {\r\n                        if (t == Z_DATA_ERROR) {\r\n                            blens = null;\r\n                            mode = BADBLOCKS;\r\n                        }\r\n                        r = t;\r\n\r\n                        that.bitb = b;\r\n                        that.bitk = k;\r\n                        z.avail_in = n;\r\n                        z.total_in += p - z.next_in_index;\r\n                        z.next_in_index = p;\r\n                        that.write = q;\r\n                        return that.inflate_flush(z, r);\r\n                    }\r\n                    codes.init(bl_[0], bd_[0], hufts, tl_[0], hufts, td_[0]);\r\n                    // }\r\n                    mode = CODES;\r\n                    /* falls through */\r\n                case CODES:\r\n                    that.bitb = b;\r\n                    that.bitk = k;\r\n                    z.avail_in = n;\r\n                    z.total_in += p - z.next_in_index;\r\n                    z.next_in_index = p;\r\n                    that.write = q;\r\n\r\n                    if ((r = codes.proc(that, z, r)) != Z_STREAM_END) {\r\n                        return that.inflate_flush(z, r);\r\n                    }\r\n                    r = Z_OK;\r\n                    codes.free(z);\r\n\r\n                    p = z.next_in_index;\r\n                    n = z.avail_in;\r\n                    b = that.bitb;\r\n                    k = that.bitk;\r\n                    q = that.write;\r\n                    m = /* (int) */(q < that.read ? that.read - q - 1 : that.end - q);\r\n\r\n                    if (last === 0) {\r\n                        mode = TYPE;\r\n                        break;\r\n                    }\r\n                    mode = DRY;\r\n                    /* falls through */\r\n                case DRY:\r\n                    that.write = q;\r\n                    r = that.inflate_flush(z, r);\r\n                    q = that.write;\r\n                    m = /* (int) */(q < that.read ? that.read - q - 1 : that.end - q);\r\n                    if (that.read != that.write) {\r\n                        that.bitb = b;\r\n                        that.bitk = k;\r\n                        z.avail_in = n;\r\n                        z.total_in += p - z.next_in_index;\r\n                        z.next_in_index = p;\r\n                        that.write = q;\r\n                        return that.inflate_flush(z, r);\r\n                    }\r\n                    mode = DONELOCKS;\r\n                    /* falls through */\r\n                case DONELOCKS:\r\n                    r = Z_STREAM_END;\r\n\r\n                    that.bitb = b;\r\n                    that.bitk = k;\r\n                    z.avail_in = n;\r\n                    z.total_in += p - z.next_in_index;\r\n                    z.next_in_index = p;\r\n                    that.write = q;\r\n                    return that.inflate_flush(z, r);\r\n                case BADBLOCKS:\r\n                    r = Z_DATA_ERROR;\r\n\r\n                    that.bitb = b;\r\n                    that.bitk = k;\r\n                    z.avail_in = n;\r\n                    z.total_in += p - z.next_in_index;\r\n                    z.next_in_index = p;\r\n                    that.write = q;\r\n                    return that.inflate_flush(z, r);\r\n\r\n                default:\r\n                    r = Z_STREAM_ERROR;\r\n\r\n                    that.bitb = b;\r\n                    that.bitk = k;\r\n                    z.avail_in = n;\r\n                    z.total_in += p - z.next_in_index;\r\n                    z.next_in_index = p;\r\n                    that.write = q;\r\n                    return that.inflate_flush(z, r);\r\n                }\r\n            }\r\n        };\r\n\r\n        that.free = function(z) {\r\n            that.reset(z, null);\r\n            that.window = null;\r\n            hufts = null;\r\n            // ZFREE(z, s);\r\n        };\r\n\r\n        that.set_dictionary = function(d, start, n) {\r\n            that.window.set(d.subarray(start, start + n), 0);\r\n            that.read = that.write = n;\r\n        };\r\n\r\n        // Returns true if inflate is currently at the end of a block generated\r\n        // by Z_SYNC_FLUSH or Z_FULL_FLUSH.\r\n        that.sync_point = function() {\r\n            return mode == LENS ? 1 : 0;\r\n        };\r\n\r\n    }\r\n\r\n    // Inflate\r\n\r\n    // preset dictionary flag in zlib header\r\n    var PRESET_DICT = 0x20;\r\n\r\n    var Z_DEFLATED = 8;\r\n\r\n    var METHOD = 0; // waiting for method byte\r\n    var FLAG = 1; // waiting for flag byte\r\n    var DICT4 = 2; // four dictionary check bytes to go\r\n    var DICT3 = 3; // three dictionary check bytes to go\r\n    var DICT2 = 4; // two dictionary check bytes to go\r\n    var DICT1 = 5; // one dictionary check byte to go\r\n    var DICT0 = 6; // waiting for inflateSetDictionary\r\n    var BLOCKS = 7; // decompressing blocks\r\n    var DONE = 12; // finished check, done\r\n    var BAD = 13; // got an error--stay here\r\n\r\n    var mark = [ 0, 0, 0xff, 0xff ];\r\n\r\n    function Inflate() {\r\n        var that = this;\r\n\r\n        that.mode = 0; // current inflate mode\r\n\r\n        // mode dependent information\r\n        that.method = 0; // if FLAGS, method byte\r\n\r\n        // if CHECK, check values to compare\r\n        that.was = [ 0 ]; // new Array(1); // computed check value\r\n        that.need = 0; // stream check value\r\n\r\n        // if BAD, inflateSync's marker bytes count\r\n        that.marker = 0;\r\n\r\n        // mode independent information\r\n        that.wbits = 0; // log2(window size) (8..15, defaults to 15)\r\n\r\n        // this.blocks; // current inflate_blocks state\r\n\r\n        function inflateReset(z) {\r\n            if (!z || !z.istate)\r\n                return Z_STREAM_ERROR;\r\n\r\n            z.total_in = z.total_out = 0;\r\n            z.msg = null;\r\n            z.istate.mode = BLOCKS;\r\n            z.istate.blocks.reset(z, null);\r\n            return Z_OK;\r\n        }\r\n\r\n        that.inflateEnd = function(z) {\r\n            if (that.blocks)\r\n                that.blocks.free(z);\r\n            that.blocks = null;\r\n            // ZFREE(z, z->state);\r\n            return Z_OK;\r\n        };\r\n\r\n        that.inflateInit = function(z, w) {\r\n            z.msg = null;\r\n            that.blocks = null;\r\n\r\n            // set window size\r\n            if (w < 8 || w > 15) {\r\n                that.inflateEnd(z);\r\n                return Z_STREAM_ERROR;\r\n            }\r\n            that.wbits = w;\r\n\r\n            z.istate.blocks = new InfBlocks(z, 1 << w);\r\n\r\n            // reset state\r\n            inflateReset(z);\r\n            return Z_OK;\r\n        };\r\n\r\n        that.inflate = function(z, f) {\r\n            var r;\r\n            var b;\r\n\r\n            if (!z || !z.istate || !z.next_in)\r\n                return Z_STREAM_ERROR;\r\n            f = f == Z_FINISH ? Z_BUF_ERROR : Z_OK;\r\n            r = Z_BUF_ERROR;\r\n            while (true) {\r\n                // System.out.println(\"mode: \"+z.istate.mode);\r\n                switch (z.istate.mode) {\r\n                case METHOD:\r\n\r\n                    if (z.avail_in === 0)\r\n                        return r;\r\n                    r = f;\r\n\r\n                    z.avail_in--;\r\n                    z.total_in++;\r\n                    if (((z.istate.method = z.read_byte(z.next_in_index++)) & 0xf) != Z_DEFLATED) {\r\n                        z.istate.mode = BAD;\r\n                        z.msg = \"unknown compression method\";\r\n                        z.istate.marker = 5; // can't try inflateSync\r\n                        break;\r\n                    }\r\n                    if ((z.istate.method >> 4) + 8 > z.istate.wbits) {\r\n                        z.istate.mode = BAD;\r\n                        z.msg = \"invalid window size\";\r\n                        z.istate.marker = 5; // can't try inflateSync\r\n                        break;\r\n                    }\r\n                    z.istate.mode = FLAG;\r\n                    /* falls through */\r\n                case FLAG:\r\n\r\n                    if (z.avail_in === 0)\r\n                        return r;\r\n                    r = f;\r\n\r\n                    z.avail_in--;\r\n                    z.total_in++;\r\n                    b = (z.read_byte(z.next_in_index++)) & 0xff;\r\n\r\n                    if ((((z.istate.method << 8) + b) % 31) !== 0) {\r\n                        z.istate.mode = BAD;\r\n                        z.msg = \"incorrect header check\";\r\n                        z.istate.marker = 5; // can't try inflateSync\r\n                        break;\r\n                    }\r\n\r\n                    if ((b & PRESET_DICT) === 0) {\r\n                        z.istate.mode = BLOCKS;\r\n                        break;\r\n                    }\r\n                    z.istate.mode = DICT4;\r\n                    /* falls through */\r\n                case DICT4:\r\n\r\n                    if (z.avail_in === 0)\r\n                        return r;\r\n                    r = f;\r\n\r\n                    z.avail_in--;\r\n                    z.total_in++;\r\n                    z.istate.need = ((z.read_byte(z.next_in_index++) & 0xff) << 24) & 0xff000000;\r\n                    z.istate.mode = DICT3;\r\n                    /* falls through */\r\n                case DICT3:\r\n\r\n                    if (z.avail_in === 0)\r\n                        return r;\r\n                    r = f;\r\n\r\n                    z.avail_in--;\r\n                    z.total_in++;\r\n                    z.istate.need += ((z.read_byte(z.next_in_index++) & 0xff) << 16) & 0xff0000;\r\n                    z.istate.mode = DICT2;\r\n                    /* falls through */\r\n                case DICT2:\r\n\r\n                    if (z.avail_in === 0)\r\n                        return r;\r\n                    r = f;\r\n\r\n                    z.avail_in--;\r\n                    z.total_in++;\r\n                    z.istate.need += ((z.read_byte(z.next_in_index++) & 0xff) << 8) & 0xff00;\r\n                    z.istate.mode = DICT1;\r\n                    /* falls through */\r\n                case DICT1:\r\n\r\n                    if (z.avail_in === 0)\r\n                        return r;\r\n                    r = f;\r\n\r\n                    z.avail_in--;\r\n                    z.total_in++;\r\n                    z.istate.need += (z.read_byte(z.next_in_index++) & 0xff);\r\n                    z.istate.mode = DICT0;\r\n                    return Z_NEED_DICT;\r\n                case DICT0:\r\n                    z.istate.mode = BAD;\r\n                    z.msg = \"need dictionary\";\r\n                    z.istate.marker = 0; // can try inflateSync\r\n                    return Z_STREAM_ERROR;\r\n                case BLOCKS:\r\n\r\n                    r = z.istate.blocks.proc(z, r);\r\n                    if (r == Z_DATA_ERROR) {\r\n                        z.istate.mode = BAD;\r\n                        z.istate.marker = 0; // can try inflateSync\r\n                        break;\r\n                    }\r\n                    if (r == Z_OK) {\r\n                        r = f;\r\n                    }\r\n                    if (r != Z_STREAM_END) {\r\n                        return r;\r\n                    }\r\n                    r = f;\r\n                    z.istate.blocks.reset(z, z.istate.was);\r\n                    z.istate.mode = DONE;\r\n                    /* falls through */\r\n                case DONE:\r\n                    return Z_STREAM_END;\r\n                case BAD:\r\n                    return Z_DATA_ERROR;\r\n                default:\r\n                    return Z_STREAM_ERROR;\r\n                }\r\n            }\r\n        };\r\n\r\n        that.inflateSetDictionary = function(z, dictionary, dictLength) {\r\n            var index = 0;\r\n            var length = dictLength;\r\n            if (!z || !z.istate || z.istate.mode != DICT0)\r\n                return Z_STREAM_ERROR;\r\n\r\n            if (length >= (1 << z.istate.wbits)) {\r\n                length = (1 << z.istate.wbits) - 1;\r\n                index = dictLength - length;\r\n            }\r\n            z.istate.blocks.set_dictionary(dictionary, index, length);\r\n            z.istate.mode = BLOCKS;\r\n            return Z_OK;\r\n        };\r\n\r\n        that.inflateSync = function(z) {\r\n            var n; // number of bytes to look at\r\n            var p; // pointer to bytes\r\n            var m; // number of marker bytes found in a row\r\n            var r, w; // temporaries to save total_in and total_out\r\n\r\n            // set up\r\n            if (!z || !z.istate)\r\n                return Z_STREAM_ERROR;\r\n            if (z.istate.mode != BAD) {\r\n                z.istate.mode = BAD;\r\n                z.istate.marker = 0;\r\n            }\r\n            if ((n = z.avail_in) === 0)\r\n                return Z_BUF_ERROR;\r\n            p = z.next_in_index;\r\n            m = z.istate.marker;\r\n\r\n            // search\r\n            while (n !== 0 && m < 4) {\r\n                if (z.read_byte(p) == mark[m]) {\r\n                    m++;\r\n                } else if (z.read_byte(p) !== 0) {\r\n                    m = 0;\r\n                } else {\r\n                    m = 4 - m;\r\n                }\r\n                p++;\r\n                n--;\r\n            }\r\n\r\n            // restore\r\n            z.total_in += p - z.next_in_index;\r\n            z.next_in_index = p;\r\n            z.avail_in = n;\r\n            z.istate.marker = m;\r\n\r\n            // return no joy or set up to restart on a new block\r\n            if (m != 4) {\r\n                return Z_DATA_ERROR;\r\n            }\r\n            r = z.total_in;\r\n            w = z.total_out;\r\n            inflateReset(z);\r\n            z.total_in = r;\r\n            z.total_out = w;\r\n            z.istate.mode = BLOCKS;\r\n            return Z_OK;\r\n        };\r\n\r\n        // Returns true if inflate is currently at the end of a block generated\r\n        // by Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP\r\n        // implementation to provide an additional safety check. PPP uses\r\n        // Z_SYNC_FLUSH\r\n        // but removes the length bytes of the resulting empty stored block. When\r\n        // decompressing, PPP checks that at the end of input packet, inflate is\r\n        // waiting for these length bytes.\r\n        that.inflateSyncPoint = function(z) {\r\n            if (!z || !z.istate || !z.istate.blocks)\r\n                return Z_STREAM_ERROR;\r\n            return z.istate.blocks.sync_point();\r\n        };\r\n    }\r\n\r\n    // ZStream\r\n\r\n    function ZStream() {\r\n    }\r\n\r\n    ZStream.prototype = {\r\n        inflateInit : function(bits) {\r\n            var that = this;\r\n            that.istate = new Inflate();\r\n            if (!bits)\r\n                bits = MAX_BITS;\r\n            return that.istate.inflateInit(that, bits);\r\n        },\r\n\r\n        inflate : function(f) {\r\n            var that = this;\r\n            if (!that.istate)\r\n                return Z_STREAM_ERROR;\r\n            return that.istate.inflate(that, f);\r\n        },\r\n\r\n        inflateEnd : function() {\r\n            var that = this;\r\n            if (!that.istate)\r\n                return Z_STREAM_ERROR;\r\n            var ret = that.istate.inflateEnd(that);\r\n            that.istate = null;\r\n            return ret;\r\n        },\r\n\r\n        inflateSync : function() {\r\n            var that = this;\r\n            if (!that.istate)\r\n                return Z_STREAM_ERROR;\r\n            return that.istate.inflateSync(that);\r\n        },\r\n        inflateSetDictionary : function(dictionary, dictLength) {\r\n            var that = this;\r\n            if (!that.istate)\r\n                return Z_STREAM_ERROR;\r\n            return that.istate.inflateSetDictionary(that, dictionary, dictLength);\r\n        },\r\n        read_byte : function(start) {\r\n            var that = this;\r\n            return that.next_in.subarray(start, start + 1)[0];\r\n        },\r\n        read_buf : function(start, size) {\r\n            var that = this;\r\n            return that.next_in.subarray(start, start + size);\r\n        }\r\n    };\r\n\r\n    // Inflater\r\n\r\n    function Inflater() {\r\n        var that = this;\r\n        var z = new ZStream();\r\n        var bufsize = 512;\r\n        var flush = Z_NO_FLUSH;\r\n        var buf = new Uint8Array(bufsize);\r\n        var nomoreinput = false;\r\n\r\n        z.inflateInit();\r\n        z.next_out = buf;\r\n\r\n        that.append = function(data, onprogress) {\r\n            var err, buffers = [], lastIndex = 0, bufferIndex = 0, bufferSize = 0, array;\r\n            if (data.length === 0)\r\n                return;\r\n            z.next_in_index = 0;\r\n            z.next_in = data;\r\n            z.avail_in = data.length;\r\n            do {\r\n                z.next_out_index = 0;\r\n                z.avail_out = bufsize;\r\n                if ((z.avail_in === 0) && (!nomoreinput)) { // if buffer is empty and more input is available, refill it\r\n                    z.next_in_index = 0;\r\n                    nomoreinput = true;\r\n                }\r\n                err = z.inflate(flush);\r\n                if (nomoreinput && (err === Z_BUF_ERROR)) {\r\n                    if (z.avail_in !== 0)\r\n                        throw new Error(\"inflating: bad input\");\r\n                } else if (err !== Z_OK && err !== Z_STREAM_END)\r\n                    throw new Error(\"inflating: \" + z.msg);\r\n                if ((nomoreinput || err === Z_STREAM_END) && (z.avail_in === data.length))\r\n                    throw new Error(\"inflating: bad input\");\r\n                if (z.next_out_index)\r\n                    if (z.next_out_index === bufsize)\r\n                        buffers.push(new Uint8Array(buf));\r\n                    else\r\n                        buffers.push(new Uint8Array(buf.subarray(0, z.next_out_index)));\r\n                bufferSize += z.next_out_index;\r\n                if (onprogress && z.next_in_index > 0 && z.next_in_index != lastIndex) {\r\n                    onprogress(z.next_in_index);\r\n                    lastIndex = z.next_in_index;\r\n                }\r\n            } while (z.avail_in > 0 || z.avail_out === 0);\r\n            array = new Uint8Array(bufferSize);\r\n            buffers.forEach(function(chunk) {\r\n                array.set(chunk, bufferIndex);\r\n                bufferIndex += chunk.length;\r\n            });\r\n            return array;\r\n        };\r\n        that.flush = function() {\r\n            z.inflateEnd();\r\n        };\r\n    }\r\n\r\n    // 'zip' may not be defined in z-worker and some tests\r\n    var env = global.zip || global;\r\n    env.Inflater = env._jzlib_Inflater = Inflater;\r\n})(this);";

},{}],3:[function(require,module,exports){
module.exports = "/* jshint worker:true */\r\n(function main(global) {\r\n    \"use strict\";\r\n\r\n    if (global.zWorkerInitialized)\r\n        throw new Error('z-worker.js should be run only once');\r\n    global.zWorkerInitialized = true;\r\n\r\n    addEventListener(\"message\", function(event) {\r\n        var message = event.data, type = message.type, sn = message.sn;\r\n        var handler = handlers[type];\r\n        if (handler) {\r\n            try {\r\n                handler(message);\r\n            } catch (e) {\r\n                onError(type, sn, e);\r\n            }\r\n        }\r\n        //for debug\r\n        //postMessage({type: 'echo', originalType: type, sn: sn});\r\n    });\r\n\r\n    var handlers = {\r\n        importScripts: doImportScripts,\r\n        newTask: newTask,\r\n        append: processData,\r\n        flush: processData,\r\n    };\r\n\r\n    // deflater/inflater tasks indexed by serial numbers\r\n    var tasks = {};\r\n\r\n    function doImportScripts(msg) {\r\n        if (msg.scripts && msg.scripts.length > 0)\r\n            importScripts.apply(undefined, msg.scripts);\r\n        postMessage({type: 'importScripts'});\r\n    }\r\n\r\n    function newTask(msg) {\r\n        var CodecClass = global[msg.codecClass];\r\n        var sn = msg.sn;\r\n        if (tasks[sn])\r\n            throw Error('duplicated sn');\r\n        tasks[sn] =  {\r\n            codec: new CodecClass(msg.options),\r\n            crcInput: msg.crcType === 'input',\r\n            crcOutput: msg.crcType === 'output',\r\n            crc: new Crc32(),\r\n        };\r\n        postMessage({type: 'newTask', sn: sn});\r\n    }\r\n\r\n    // performance may not be supported\r\n    var now = global.performance ? global.performance.now.bind(global.performance) : Date.now;\r\n\r\n    function processData(msg) {\r\n        var sn = msg.sn, type = msg.type, input = msg.data;\r\n        var task = tasks[sn];\r\n        // allow creating codec on first append\r\n        if (!task && msg.codecClass) {\r\n            newTask(msg);\r\n            task = tasks[sn];\r\n        }\r\n        var isAppend = type === 'append';\r\n        var start = now();\r\n        var output;\r\n        if (isAppend) {\r\n            try {\r\n                output = task.codec.append(input, function onprogress(loaded) {\r\n                    postMessage({type: 'progress', sn: sn, loaded: loaded});\r\n                });\r\n            } catch (e) {\r\n                delete tasks[sn];\r\n                throw e;\r\n            }\r\n        } else {\r\n            delete tasks[sn];\r\n            output = task.codec.flush();\r\n        }\r\n        var codecTime = now() - start;\r\n\r\n        start = now();\r\n        if (input && task.crcInput)\r\n            task.crc.append(input);\r\n        if (output && task.crcOutput)\r\n            task.crc.append(output);\r\n        var crcTime = now() - start;\r\n\r\n        var rmsg = {type: type, sn: sn, codecTime: codecTime, crcTime: crcTime};\r\n        var transferables = [];\r\n        if (output) {\r\n            rmsg.data = output;\r\n            transferables.push(output.buffer);\r\n        }\r\n        if (!isAppend && (task.crcInput || task.crcOutput))\r\n            rmsg.crc = task.crc.get();\r\n\r\n        // posting a message with transferables will fail on IE10\r\n        try {\r\n            postMessage(rmsg, transferables);\r\n        } catch(ex) {\r\n            postMessage(rmsg); // retry without transferables\r\n        }\r\n    }\r\n\r\n    function onError(type, sn, e) {\r\n        var msg = {\r\n            type: type,\r\n            sn: sn,\r\n            error: formatError(e)\r\n        };\r\n        postMessage(msg);\r\n    }\r\n\r\n    function formatError(e) {\r\n        return { message: e.message, stack: e.stack };\r\n    }\r\n\r\n    // Crc32 code copied from file zip.js\r\n    function Crc32() {\r\n        this.crc = -1;\r\n    }\r\n    Crc32.prototype.append = function append(data) {\r\n        var crc = this.crc | 0, table = this.table;\r\n        for (var offset = 0, len = data.length | 0; offset < len; offset++)\r\n            crc = (crc >>> 8) ^ table[(crc ^ data[offset]) & 0xFF];\r\n        this.crc = crc;\r\n    };\r\n    Crc32.prototype.get = function get() {\r\n        return ~this.crc;\r\n    };\r\n    Crc32.prototype.table = (function() {\r\n        var i, j, t, table = []; // Uint32Array is actually slower than []\r\n        for (i = 0; i < 256; i++) {\r\n            t = i;\r\n            for (j = 0; j < 8; j++)\r\n                if (t & 1)\r\n                    t = (t >>> 1) ^ 0xEDB88320;\r\n                else\r\n                    t = t >>> 1;\r\n            table[i] = t;\r\n        }\r\n        return table;\r\n    })();\r\n\r\n    // \"no-op\" codec\r\n    function NOOP() {}\r\n    global.NOOP = NOOP;\r\n    NOOP.prototype.append = function append(bytes, onprogress) {\r\n        return bytes;\r\n    };\r\n    NOOP.prototype.flush = function flush() {};\r\n})(this);";

},{}],4:[function(require,module,exports){
/*
 Copyright (c) 2013 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright
 notice, this list of conditions and the following disclaimer in
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

(function() {
	"use strict";

	var ERR_HTTP_RANGE = "HTTP Range not supported.";

	var Reader = zip.Reader;
	var Writer = zip.Writer;
	
	var ZipDirectoryEntry;

	var appendABViewSupported;
	try {
		appendABViewSupported = new Blob([ new DataView(new ArrayBuffer(0)) ]).size === 0;
	} catch (e) {
	}

	function HttpReader(url) {
		var that = this;

		function getData(callback, onerror) {
			var request;
			if (!that.data) {
				request = new XMLHttpRequest();
				request.addEventListener("load", function() {
					if (!that.size)
						that.size = Number(request.getResponseHeader("Content-Length"));
					that.data = new Uint8Array(request.response);
					callback();
				}, false);
				request.addEventListener("error", onerror, false);
				request.open("GET", url);
				request.responseType = "arraybuffer";
				request.send();
			} else
				callback();
		}

		function init(callback, onerror) {
			var request = new XMLHttpRequest();
			request.addEventListener("load", function() {
				that.size = Number(request.getResponseHeader("Content-Length"));
				callback();
			}, false);
			request.addEventListener("error", onerror, false);
			request.open("HEAD", url);
			request.send();
		}

		function readUint8Array(index, length, callback, onerror) {
			getData(function() {
				callback(new Uint8Array(that.data.subarray(index, index + length)));
			}, onerror);
		}

		that.size = 0;
		that.init = init;
		that.readUint8Array = readUint8Array;
	}
	HttpReader.prototype = new Reader();
	HttpReader.prototype.constructor = HttpReader;

	function HttpRangeReader(url) {
		var that = this;

		function init(callback, onerror) {
			var request = new XMLHttpRequest();
			request.addEventListener("load", function() {
				that.size = Number(request.getResponseHeader("Content-Length"));
				if (request.getResponseHeader("Accept-Ranges") == "bytes")
					callback();
				else
					onerror(ERR_HTTP_RANGE);
			}, false);
			request.addEventListener("error", onerror, false);
			request.open("HEAD", url);
			request.send();
		}

		function readArrayBuffer(index, length, callback, onerror) {
			var request = new XMLHttpRequest();
			request.open("GET", url);
			request.responseType = "arraybuffer";
			request.setRequestHeader("Range", "bytes=" + index + "-" + (index + length - 1));
			request.addEventListener("load", function() {
				callback(request.response);
			}, false);
			request.addEventListener("error", onerror, false);
			request.send();
		}

		function readUint8Array(index, length, callback, onerror) {
			readArrayBuffer(index, length, function(arraybuffer) {
				callback(new Uint8Array(arraybuffer));
			}, onerror);
		}

		that.size = 0;
		that.init = init;
		that.readUint8Array = readUint8Array;
	}
	HttpRangeReader.prototype = new Reader();
	HttpRangeReader.prototype.constructor = HttpRangeReader;

	function ArrayBufferReader(arrayBuffer) {
		var that = this;

		function init(callback, onerror) {
			that.size = arrayBuffer.byteLength;
			callback();
		}

		function readUint8Array(index, length, callback, onerror) {
			callback(new Uint8Array(arrayBuffer.slice(index, index + length)));
		}

		that.size = 0;
		that.init = init;
		that.readUint8Array = readUint8Array;
	}
	ArrayBufferReader.prototype = new Reader();
	ArrayBufferReader.prototype.constructor = ArrayBufferReader;

	function ArrayBufferWriter() {
		var array, that = this;

		function init(callback, onerror) {
			array = new Uint8Array();
			callback();
		}

		function writeUint8Array(arr, callback, onerror) {
			var tmpArray = new Uint8Array(array.length + arr.length);
			tmpArray.set(array);
			tmpArray.set(arr, array.length);
			array = tmpArray;
			callback();
		}

		function getData(callback) {
			callback(array.buffer);
		}

		that.init = init;
		that.writeUint8Array = writeUint8Array;
		that.getData = getData;
	}
	ArrayBufferWriter.prototype = new Writer();
	ArrayBufferWriter.prototype.constructor = ArrayBufferWriter;

	function FileWriter(fileEntry, contentType) {
		var writer, that = this;

		function init(callback, onerror) {
			fileEntry.createWriter(function(fileWriter) {
				writer = fileWriter;
				callback();
			}, onerror);
		}

		function writeUint8Array(array, callback, onerror) {
			var blob = new Blob([ appendABViewSupported ? array : array.buffer ], {
				type : contentType
			});
			writer.onwrite = function() {
				writer.onwrite = null;
				callback();
			};
			writer.onerror = onerror;
			writer.write(blob);
		}

		function getData(callback) {
			fileEntry.file(callback);
		}

		that.init = init;
		that.writeUint8Array = writeUint8Array;
		that.getData = getData;
	}
	FileWriter.prototype = new Writer();
	FileWriter.prototype.constructor = FileWriter;

	zip.FileWriter = FileWriter;
	zip.HttpReader = HttpReader;
	zip.HttpRangeReader = HttpRangeReader;
	zip.ArrayBufferReader = ArrayBufferReader;
	zip.ArrayBufferWriter = ArrayBufferWriter;

	if (zip.fs) {
		ZipDirectoryEntry = zip.fs.ZipDirectoryEntry;
		ZipDirectoryEntry.prototype.addHttpContent = function(name, URL, useRangeHeader) {
			function addChild(parent, name, params, directory) {
				if (parent.directory)
					return directory ? new ZipDirectoryEntry(parent.fs, name, params, parent) : new zip.fs.ZipFileEntry(parent.fs, name, params, parent);
				else
					throw "Parent entry is not a directory.";
			}

			return addChild(this, name, {
				data : URL,
				Reader : useRangeHeader ? HttpRangeReader : HttpReader
			});
		};
		ZipDirectoryEntry.prototype.importHttpContent = function(URL, useRangeHeader, onend, onerror) {
			this.importZip(useRangeHeader ? new HttpRangeReader(URL) : new HttpReader(URL), onend, onerror);
		};
		zip.fs.FS.prototype.importHttpContent = function(URL, useRangeHeader, onend, onerror) {
			this.entries = [];
			this.root = new ZipDirectoryEntry(this);
			this.root.importHttpContent(URL, useRangeHeader, onend, onerror);
		};
	}

})();

},{}],5:[function(require,module,exports){
/*
 Copyright (c) 2013 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright
 notice, this list of conditions and the following disclaimer in
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

(function(obj) {
	"use strict";

	var ERR_BAD_FORMAT = "File format is not recognized.";
	var ERR_CRC = "CRC failed.";
	var ERR_ENCRYPTED = "File contains encrypted entry.";
	var ERR_ZIP64 = "File is using Zip64 (4gb+ file size).";
	var ERR_READ = "Error while reading zip file.";
	var ERR_WRITE = "Error while writing zip file.";
	var ERR_WRITE_DATA = "Error while writing file data.";
	var ERR_READ_DATA = "Error while reading file data.";
	var ERR_DUPLICATED_NAME = "File already exists.";
	var CHUNK_SIZE = 512 * 1024;

	var TEXT_PLAIN = "text/plain";

	var appendABViewSupported;
	try {
		appendABViewSupported = new Blob([ new DataView(new ArrayBuffer(0)) ]).size === 0;
	} catch (e) {
	}

	function Crc32() {
		this.crc = -1;
	}
	Crc32.prototype.append = function append(data) {
		var crc = this.crc | 0, table = this.table;
		for (var offset = 0, len = data.length | 0; offset < len; offset++)
			crc = (crc >>> 8) ^ table[(crc ^ data[offset]) & 0xFF];
		this.crc = crc;
	};
	Crc32.prototype.get = function get() {
		return ~this.crc;
	};
	Crc32.prototype.table = (function() {
		var i, j, t, table = []; // Uint32Array is actually slower than []
		for (i = 0; i < 256; i++) {
			t = i;
			for (j = 0; j < 8; j++)
				if (t & 1)
					t = (t >>> 1) ^ 0xEDB88320;
				else
					t = t >>> 1;
			table[i] = t;
		}
		return table;
	})();

	// "no-op" codec
	function NOOP() {}
	NOOP.prototype.append = function append(bytes, onprogress) {
		return bytes;
	};
	NOOP.prototype.flush = function flush() {};

	function blobSlice(blob, index, length) {
		if (index < 0 || length < 0 || index + length > blob.size)
			throw new RangeError('offset:' + index + ', length:' + length + ', size:' + blob.size);
		if (blob.slice)
			return blob.slice(index, index + length);
		else if (blob.webkitSlice)
			return blob.webkitSlice(index, index + length);
		else if (blob.mozSlice)
			return blob.mozSlice(index, index + length);
		else if (blob.msSlice)
			return blob.msSlice(index, index + length);
	}

	function getDataHelper(byteLength, bytes) {
		var dataBuffer, dataArray;
		dataBuffer = new ArrayBuffer(byteLength);
		dataArray = new Uint8Array(dataBuffer);
		if (bytes)
			dataArray.set(bytes, 0);
		return {
			buffer : dataBuffer,
			array : dataArray,
			view : new DataView(dataBuffer)
		};
	}

	// Readers
	function Reader() {
	}

	function TextReader(text) {
		var that = this, blobReader;

		function init(callback, onerror) {
			var blob = new Blob([ text ], {
				type : TEXT_PLAIN
			});
			blobReader = new BlobReader(blob);
			blobReader.init(function() {
				that.size = blobReader.size;
				callback();
			}, onerror);
		}

		function readUint8Array(index, length, callback, onerror) {
			blobReader.readUint8Array(index, length, callback, onerror);
		}

		that.size = 0;
		that.init = init;
		that.readUint8Array = readUint8Array;
	}
	TextReader.prototype = new Reader();
	TextReader.prototype.constructor = TextReader;

	function Data64URIReader(dataURI) {
		var that = this, dataStart;

		function init(callback) {
			var dataEnd = dataURI.length;
			while (dataURI.charAt(dataEnd - 1) == "=")
				dataEnd--;
			dataStart = dataURI.indexOf(",") + 1;
			that.size = Math.floor((dataEnd - dataStart) * 0.75);
			callback();
		}

		function readUint8Array(index, length, callback) {
			var i, data = getDataHelper(length);
			var start = Math.floor(index / 3) * 4;
			var end = Math.ceil((index + length) / 3) * 4;
			var bytes = obj.atob(dataURI.substring(start + dataStart, end + dataStart));
			var delta = index - Math.floor(start / 4) * 3;
			for (i = delta; i < delta + length; i++)
				data.array[i - delta] = bytes.charCodeAt(i);
			callback(data.array);
		}

		that.size = 0;
		that.init = init;
		that.readUint8Array = readUint8Array;
	}
	Data64URIReader.prototype = new Reader();
	Data64URIReader.prototype.constructor = Data64URIReader;

	function BlobReader(blob) {
		var that = this;

		function init(callback) {
			that.size = blob.size;
			callback();
		}

		function readUint8Array(index, length, callback, onerror) {
			var reader = new FileReader();
			reader.onload = function(e) {
				callback(new Uint8Array(e.target.result));
			};
			reader.onerror = onerror;
			try {
				reader.readAsArrayBuffer(blobSlice(blob, index, length));
			} catch (e) {
				onerror(e);
			}
		}

		that.size = 0;
		that.init = init;
		that.readUint8Array = readUint8Array;
	}
	BlobReader.prototype = new Reader();
	BlobReader.prototype.constructor = BlobReader;

	// Writers

	function Writer() {
	}
	Writer.prototype.getData = function(callback) {
		callback(this.data);
	};

	function TextWriter(encoding) {
		var that = this, blob;

		function init(callback) {
			blob = new Blob([], {
				type : TEXT_PLAIN
			});
			callback();
		}

		function writeUint8Array(array, callback) {
			blob = new Blob([ blob, appendABViewSupported ? array : array.buffer ], {
				type : TEXT_PLAIN
			});
			callback();
		}

		function getData(callback, onerror) {
			var reader = new FileReader();
			reader.onload = function(e) {
				callback(e.target.result);
			};
			reader.onerror = onerror;
			reader.readAsText(blob, encoding);
		}

		that.init = init;
		that.writeUint8Array = writeUint8Array;
		that.getData = getData;
	}
	TextWriter.prototype = new Writer();
	TextWriter.prototype.constructor = TextWriter;

	function Data64URIWriter(contentType) {
		var that = this, data = "", pending = "";

		function init(callback) {
			data += "data:" + (contentType || "") + ";base64,";
			callback();
		}

		function writeUint8Array(array, callback) {
			var i, delta = pending.length, dataString = pending;
			pending = "";
			for (i = 0; i < (Math.floor((delta + array.length) / 3) * 3) - delta; i++)
				dataString += String.fromCharCode(array[i]);
			for (; i < array.length; i++)
				pending += String.fromCharCode(array[i]);
			if (dataString.length > 2)
				data += obj.btoa(dataString);
			else
				pending = dataString;
			callback();
		}

		function getData(callback) {
			callback(data + obj.btoa(pending));
		}

		that.init = init;
		that.writeUint8Array = writeUint8Array;
		that.getData = getData;
	}
	Data64URIWriter.prototype = new Writer();
	Data64URIWriter.prototype.constructor = Data64URIWriter;

	function BlobWriter(contentType) {
		var blob, that = this;

		function init(callback) {
			blob = new Blob([], {
				type : contentType
			});
			callback();
		}

		function writeUint8Array(array, callback) {
			blob = new Blob([ blob, appendABViewSupported ? array : array.buffer ], {
				type : contentType
			});
			callback();
		}

		function getData(callback) {
			callback(blob);
		}

		that.init = init;
		that.writeUint8Array = writeUint8Array;
		that.getData = getData;
	}
	BlobWriter.prototype = new Writer();
	BlobWriter.prototype.constructor = BlobWriter;

	/**
	 * inflate/deflate core functions
	 * @param worker {Worker} web worker for the task.
	 * @param initialMessage {Object} initial message to be sent to the worker. should contain
	 *   sn(serial number for distinguishing multiple tasks sent to the worker), and codecClass.
	 *   This function may add more properties before sending.
	 */
	function launchWorkerProcess(worker, initialMessage, reader, writer, offset, size, onprogress, onend, onreaderror, onwriteerror) {
		var chunkIndex = 0, index, outputSize, sn = initialMessage.sn, crc;

		function onflush() {
			worker.removeEventListener('message', onmessage, false);
			onend(outputSize, crc);
		}

		function onmessage(event) {
			var message = event.data, data = message.data, err = message.error;
			if (err) {
				err.toString = function () { return 'Error: ' + this.message; };
				onreaderror(err);
				return;
			}
			if (message.sn !== sn)
				return;
			if (typeof message.codecTime === 'number')
				worker.codecTime += message.codecTime; // should be before onflush()
			if (typeof message.crcTime === 'number')
				worker.crcTime += message.crcTime;

			switch (message.type) {
				case 'append':
					if (data) {
						outputSize += data.length;
						writer.writeUint8Array(data, function() {
							step();
						}, onwriteerror);
					} else
						step();
					break;
				case 'flush':
					crc = message.crc;
					if (data) {
						outputSize += data.length;
						writer.writeUint8Array(data, function() {
							onflush();
						}, onwriteerror);
					} else
						onflush();
					break;
				case 'progress':
					if (onprogress)
						onprogress(index + message.loaded, size);
					break;
				case 'importScripts': //no need to handle here
				case 'newTask':
				case 'echo':
					break;
				default:
					console.warn('zip.js:launchWorkerProcess: unknown message: ', message);
			}
		}

		function step() {
			index = chunkIndex * CHUNK_SIZE;
			// use `<=` instead of `<`, because `size` may be 0.
			if (index <= size) {
				reader.readUint8Array(offset + index, Math.min(CHUNK_SIZE, size - index), function(array) {
					if (onprogress)
						onprogress(index, size);
					var msg = index === 0 ? initialMessage : {sn : sn};
					msg.type = 'append';
					msg.data = array;

					// posting a message with transferables will fail on IE10
					try {
						worker.postMessage(msg, [array.buffer]);
					} catch(ex) {
						worker.postMessage(msg); // retry without transferables
					}
					chunkIndex++;
				}, onreaderror);
			} else {
				worker.postMessage({
					sn: sn,
					type: 'flush'
				});
			}
		}

		outputSize = 0;
		worker.addEventListener('message', onmessage, false);
		step();
	}

	function launchProcess(process, reader, writer, offset, size, crcType, onprogress, onend, onreaderror, onwriteerror) {
		var chunkIndex = 0, index, outputSize = 0,
			crcInput = crcType === 'input',
			crcOutput = crcType === 'output',
			crc = new Crc32();
		function step() {
			var outputData;
			index = chunkIndex * CHUNK_SIZE;
			if (index < size)
				reader.readUint8Array(offset + index, Math.min(CHUNK_SIZE, size - index), function(inputData) {
					var outputData;
					try {
						outputData = process.append(inputData, function(loaded) {
							if (onprogress)
								onprogress(index + loaded, size);
						});
					} catch (e) {
						onreaderror(e);
						return;
					}
					if (outputData) {
						outputSize += outputData.length;
						writer.writeUint8Array(outputData, function() {
							chunkIndex++;
							setTimeout(step, 1);
						}, onwriteerror);
						if (crcOutput)
							crc.append(outputData);
					} else {
						chunkIndex++;
						setTimeout(step, 1);
					}
					if (crcInput)
						crc.append(inputData);
					if (onprogress)
						onprogress(index, size);
				}, onreaderror);
			else {
				try {
					outputData = process.flush();
				} catch (e) {
					onreaderror(e);
					return;
				}
				if (outputData) {
					if (crcOutput)
						crc.append(outputData);
					outputSize += outputData.length;
					writer.writeUint8Array(outputData, function() {
						onend(outputSize, crc.get());
					}, onwriteerror);
				} else
					onend(outputSize, crc.get());
			}
		}

		step();
	}

	function inflate(worker, sn, reader, writer, offset, size, computeCrc32, onend, onprogress, onreaderror, onwriteerror) {
		var crcType = computeCrc32 ? 'output' : 'none';
		if (obj.zip.useWebWorkers) {
			var initialMessage = {
				sn: sn,
				codecClass: 'Inflater',
				crcType: crcType,
			};
			launchWorkerProcess(worker, initialMessage, reader, writer, offset, size, onprogress, onend, onreaderror, onwriteerror);
		} else
			launchProcess(new obj.zip.Inflater(), reader, writer, offset, size, crcType, onprogress, onend, onreaderror, onwriteerror);
	}

	function deflate(worker, sn, reader, writer, level, onend, onprogress, onreaderror, onwriteerror) {
		var crcType = 'input';
		if (obj.zip.useWebWorkers) {
			var initialMessage = {
				sn: sn,
				options: {level: level},
				codecClass: 'Deflater',
				crcType: crcType,
			};
			launchWorkerProcess(worker, initialMessage, reader, writer, 0, reader.size, onprogress, onend, onreaderror, onwriteerror);
		} else
			launchProcess(new obj.zip.Deflater(), reader, writer, 0, reader.size, crcType, onprogress, onend, onreaderror, onwriteerror);
	}

	function copy(worker, sn, reader, writer, offset, size, computeCrc32, onend, onprogress, onreaderror, onwriteerror) {
		var crcType = 'input';
		if (obj.zip.useWebWorkers && computeCrc32) {
			var initialMessage = {
				sn: sn,
				codecClass: 'NOOP',
				crcType: crcType,
			};
			launchWorkerProcess(worker, initialMessage, reader, writer, offset, size, onprogress, onend, onreaderror, onwriteerror);
		} else
			launchProcess(new NOOP(), reader, writer, offset, size, crcType, onprogress, onend, onreaderror, onwriteerror);
	}

	// ZipReader

	function decodeASCII(str) {
		var i, out = "", charCode, extendedASCII = [ '\u00C7', '\u00FC', '\u00E9', '\u00E2', '\u00E4', '\u00E0', '\u00E5', '\u00E7', '\u00EA', '\u00EB',
				'\u00E8', '\u00EF', '\u00EE', '\u00EC', '\u00C4', '\u00C5', '\u00C9', '\u00E6', '\u00C6', '\u00F4', '\u00F6', '\u00F2', '\u00FB', '\u00F9',
				'\u00FF', '\u00D6', '\u00DC', '\u00F8', '\u00A3', '\u00D8', '\u00D7', '\u0192', '\u00E1', '\u00ED', '\u00F3', '\u00FA', '\u00F1', '\u00D1',
				'\u00AA', '\u00BA', '\u00BF', '\u00AE', '\u00AC', '\u00BD', '\u00BC', '\u00A1', '\u00AB', '\u00BB', '_', '_', '_', '\u00A6', '\u00A6',
				'\u00C1', '\u00C2', '\u00C0', '\u00A9', '\u00A6', '\u00A6', '+', '+', '\u00A2', '\u00A5', '+', '+', '-', '-', '+', '-', '+', '\u00E3',
				'\u00C3', '+', '+', '-', '-', '\u00A6', '-', '+', '\u00A4', '\u00F0', '\u00D0', '\u00CA', '\u00CB', '\u00C8', 'i', '\u00CD', '\u00CE',
				'\u00CF', '+', '+', '_', '_', '\u00A6', '\u00CC', '_', '\u00D3', '\u00DF', '\u00D4', '\u00D2', '\u00F5', '\u00D5', '\u00B5', '\u00FE',
				'\u00DE', '\u00DA', '\u00DB', '\u00D9', '\u00FD', '\u00DD', '\u00AF', '\u00B4', '\u00AD', '\u00B1', '_', '\u00BE', '\u00B6', '\u00A7',
				'\u00F7', '\u00B8', '\u00B0', '\u00A8', '\u00B7', '\u00B9', '\u00B3', '\u00B2', '_', ' ' ];
		for (i = 0; i < str.length; i++) {
			charCode = str.charCodeAt(i) & 0xFF;
			if (charCode > 127)
				out += extendedASCII[charCode - 128];
			else
				out += String.fromCharCode(charCode);
		}
		return out;
	}

	function decodeUTF8(string) {
		return decodeURIComponent(escape(string));
	}

	function getString(bytes) {
		var i, str = "";
		for (i = 0; i < bytes.length; i++)
			str += String.fromCharCode(bytes[i]);
		return str;
	}

	function getDate(timeRaw) {
		var date = (timeRaw & 0xffff0000) >> 16, time = timeRaw & 0x0000ffff;
		try {
			return new Date(1980 + ((date & 0xFE00) >> 9), ((date & 0x01E0) >> 5) - 1, date & 0x001F, (time & 0xF800) >> 11, (time & 0x07E0) >> 5,
					(time & 0x001F) * 2, 0);
		} catch (e) {
		}
	}

	function readCommonHeader(entry, data, index, centralDirectory, onerror) {
		entry.version = data.view.getUint16(index, true);
		entry.bitFlag = data.view.getUint16(index + 2, true);
		entry.compressionMethod = data.view.getUint16(index + 4, true);
		entry.lastModDateRaw = data.view.getUint32(index + 6, true);
		entry.lastModDate = getDate(entry.lastModDateRaw);
		if ((entry.bitFlag & 0x01) === 0x01) {
			onerror(ERR_ENCRYPTED);
			return;
		}
		if (centralDirectory || (entry.bitFlag & 0x0008) != 0x0008) {
			entry.crc32 = data.view.getUint32(index + 10, true);
			entry.compressedSize = data.view.getUint32(index + 14, true);
			entry.uncompressedSize = data.view.getUint32(index + 18, true);
		}
		if (entry.compressedSize === 0xFFFFFFFF || entry.uncompressedSize === 0xFFFFFFFF) {
			onerror(ERR_ZIP64);
			return;
		}
		entry.filenameLength = data.view.getUint16(index + 22, true);
		entry.extraFieldLength = data.view.getUint16(index + 24, true);
	}

	function createZipReader(reader, callback, onerror) {
		var inflateSN = 0;

		function Entry() {
		}

		Entry.prototype.getData = function(writer, onend, onprogress, checkCrc32) {
			var that = this;

			function testCrc32(crc32) {
				var dataCrc32 = getDataHelper(4);
				dataCrc32.view.setUint32(0, crc32);
				return that.crc32 == dataCrc32.view.getUint32(0);
			}

			function getWriterData(uncompressedSize, crc32) {
				if (checkCrc32 && !testCrc32(crc32))
					onerror(ERR_CRC);
				else
					writer.getData(function(data) {
						onend(data);
					});
			}

			function onreaderror(err) {
				onerror(err || ERR_READ_DATA);
			}

			function onwriteerror(err) {
				onerror(err || ERR_WRITE_DATA);
			}

			reader.readUint8Array(that.offset, 30, function(bytes) {
				var data = getDataHelper(bytes.length, bytes), dataOffset;
				if (data.view.getUint32(0) != 0x504b0304) {
					onerror(ERR_BAD_FORMAT);
					return;
				}
				readCommonHeader(that, data, 4, false, onerror);
				dataOffset = that.offset + 30 + that.filenameLength + that.extraFieldLength;
				writer.init(function() {
					if (that.compressionMethod === 0)
						copy(that._worker, inflateSN++, reader, writer, dataOffset, that.compressedSize, checkCrc32, getWriterData, onprogress, onreaderror, onwriteerror);
					else
						inflate(that._worker, inflateSN++, reader, writer, dataOffset, that.compressedSize, checkCrc32, getWriterData, onprogress, onreaderror, onwriteerror);
				}, onwriteerror);
			}, onreaderror);
		};

		function seekEOCDR(eocdrCallback) {
			// "End of central directory record" is the last part of a zip archive, and is at least 22 bytes long.
			// Zip file comment is the last part of EOCDR and has max length of 64KB,
			// so we only have to search the last 64K + 22 bytes of a archive for EOCDR signature (0x06054b50).
			var EOCDR_MIN = 22;
			if (reader.size < EOCDR_MIN) {
				onerror(ERR_BAD_FORMAT);
				return;
			}
			var ZIP_COMMENT_MAX = 256 * 256, EOCDR_MAX = EOCDR_MIN + ZIP_COMMENT_MAX;

			// In most cases, the EOCDR is EOCDR_MIN bytes long
			doSeek(EOCDR_MIN, function() {
				// If not found, try within EOCDR_MAX bytes
				doSeek(Math.min(EOCDR_MAX, reader.size), function() {
					onerror(ERR_BAD_FORMAT);
				});
			});

			// seek last length bytes of file for EOCDR
			function doSeek(length, eocdrNotFoundCallback) {
				reader.readUint8Array(reader.size - length, length, function(bytes) {
					for (var i = bytes.length - EOCDR_MIN; i >= 0; i--) {
						if (bytes[i] === 0x50 && bytes[i + 1] === 0x4b && bytes[i + 2] === 0x05 && bytes[i + 3] === 0x06) {
							eocdrCallback(new DataView(bytes.buffer, i, EOCDR_MIN));
							return;
						}
					}
					eocdrNotFoundCallback();
				}, function() {
					onerror(ERR_READ);
				});
			}
		}

		var zipReader = {
			getEntries : function(callback) {
				var worker = this._worker;
				// look for End of central directory record
				seekEOCDR(function(dataView) {
					var datalength, fileslength;
					datalength = dataView.getUint32(16, true);
					fileslength = dataView.getUint16(8, true);
					if (datalength < 0 || datalength >= reader.size) {
						onerror(ERR_BAD_FORMAT);
						return;
					}
					reader.readUint8Array(datalength, reader.size - datalength, function(bytes) {
						var i, index = 0, entries = [], entry, filename, comment, data = getDataHelper(bytes.length, bytes);
						for (i = 0; i < fileslength; i++) {
							entry = new Entry();
							entry._worker = worker;
							if (data.view.getUint32(index) != 0x504b0102) {
								onerror(ERR_BAD_FORMAT);
								return;
							}
							readCommonHeader(entry, data, index + 6, true, onerror);
							entry.commentLength = data.view.getUint16(index + 32, true);
							entry.directory = ((data.view.getUint8(index + 38) & 0x10) == 0x10);
							entry.offset = data.view.getUint32(index + 42, true);
							filename = getString(data.array.subarray(index + 46, index + 46 + entry.filenameLength));
							entry.filename = ((entry.bitFlag & 0x0800) === 0x0800) ? decodeUTF8(filename) : decodeASCII(filename);
							if (!entry.directory && entry.filename.charAt(entry.filename.length - 1) == "/")
								entry.directory = true;
							comment = getString(data.array.subarray(index + 46 + entry.filenameLength + entry.extraFieldLength, index + 46
									+ entry.filenameLength + entry.extraFieldLength + entry.commentLength));
							entry.comment = ((entry.bitFlag & 0x0800) === 0x0800) ? decodeUTF8(comment) : decodeASCII(comment);
							entries.push(entry);
							index += 46 + entry.filenameLength + entry.extraFieldLength + entry.commentLength;
						}
						callback(entries);
					}, function() {
						onerror(ERR_READ);
					});
				});
			},
			close : function(callback) {
				if (this._worker) {
					this._worker.terminate();
					this._worker = null;
				}
				if (callback)
					callback();
			},
			_worker: null
		};

		if (!obj.zip.useWebWorkers)
			callback(zipReader);
		else {
			createWorker('inflater',
				function(worker) {
					zipReader._worker = worker;
					callback(zipReader);
				},
				function(err) {
					onerror(err);
				}
			);
		}
	}

	// ZipWriter

	function encodeUTF8(string) {
		return unescape(encodeURIComponent(string));
	}

	function getBytes(str) {
		var i, array = [];
		for (i = 0; i < str.length; i++)
			array.push(str.charCodeAt(i));
		return array;
	}

	function createZipWriter(writer, callback, onerror, dontDeflate) {
		var files = {}, filenames = [], datalength = 0;
		var deflateSN = 0;

		function onwriteerror(err) {
			onerror(err || ERR_WRITE);
		}

		function onreaderror(err) {
			onerror(err || ERR_READ_DATA);
		}

		var zipWriter = {
			add : function(name, reader, onend, onprogress, options) {
				var header, filename, date;
				var worker = this._worker;

				function writeHeader(callback) {
					var data;
					date = options.lastModDate || new Date();
					header = getDataHelper(26);
					files[name] = {
						headerArray : header.array,
						directory : options.directory,
						filename : filename,
						offset : datalength,
						comment : getBytes(encodeUTF8(options.comment || ""))
					};
					header.view.setUint32(0, 0x14000808);
					if (options.version)
						header.view.setUint8(0, options.version);
					if (!dontDeflate && options.level !== 0 && !options.directory)
						header.view.setUint16(4, 0x0800);
					header.view.setUint16(6, (((date.getHours() << 6) | date.getMinutes()) << 5) | date.getSeconds() / 2, true);
					header.view.setUint16(8, ((((date.getFullYear() - 1980) << 4) | (date.getMonth() + 1)) << 5) | date.getDate(), true);
					header.view.setUint16(22, filename.length, true);
					data = getDataHelper(30 + filename.length);
					data.view.setUint32(0, 0x504b0304);
					data.array.set(header.array, 4);
					data.array.set(filename, 30);
					datalength += data.array.length;
					writer.writeUint8Array(data.array, callback, onwriteerror);
				}

				function writeFooter(compressedLength, crc32) {
					var footer = getDataHelper(16);
					datalength += compressedLength || 0;
					footer.view.setUint32(0, 0x504b0708);
					if (typeof crc32 != "undefined") {
						header.view.setUint32(10, crc32, true);
						footer.view.setUint32(4, crc32, true);
					}
					if (reader) {
						footer.view.setUint32(8, compressedLength, true);
						header.view.setUint32(14, compressedLength, true);
						footer.view.setUint32(12, reader.size, true);
						header.view.setUint32(18, reader.size, true);
					}
					writer.writeUint8Array(footer.array, function() {
						datalength += 16;
						onend();
					}, onwriteerror);
				}

				function writeFile() {
					options = options || {};
					name = name.trim();
					if (options.directory && name.charAt(name.length - 1) != "/")
						name += "/";
					if (files.hasOwnProperty(name)) {
						onerror(ERR_DUPLICATED_NAME);
						return;
					}
					filename = getBytes(encodeUTF8(name));
					filenames.push(name);
					writeHeader(function() {
						if (reader)
							if (dontDeflate || options.level === 0)
								copy(worker, deflateSN++, reader, writer, 0, reader.size, true, writeFooter, onprogress, onreaderror, onwriteerror);
							else
								deflate(worker, deflateSN++, reader, writer, options.level, writeFooter, onprogress, onreaderror, onwriteerror);
						else
							writeFooter();
					}, onwriteerror);
				}

				if (reader)
					reader.init(writeFile, onreaderror);
				else
					writeFile();
			},
			close : function(callback) {
				if (this._worker) {
					this._worker.terminate();
					this._worker = null;
				}

				var data, length = 0, index = 0, indexFilename, file;
				for (indexFilename = 0; indexFilename < filenames.length; indexFilename++) {
					file = files[filenames[indexFilename]];
					length += 46 + file.filename.length + file.comment.length;
				}
				data = getDataHelper(length + 22);
				for (indexFilename = 0; indexFilename < filenames.length; indexFilename++) {
					file = files[filenames[indexFilename]];
					data.view.setUint32(index, 0x504b0102);
					data.view.setUint16(index + 4, 0x1400);
					data.array.set(file.headerArray, index + 6);
					data.view.setUint16(index + 32, file.comment.length, true);
					if (file.directory)
						data.view.setUint8(index + 38, 0x10);
					data.view.setUint32(index + 42, file.offset, true);
					data.array.set(file.filename, index + 46);
					data.array.set(file.comment, index + 46 + file.filename.length);
					index += 46 + file.filename.length + file.comment.length;
				}
				data.view.setUint32(index, 0x504b0506);
				data.view.setUint16(index + 8, filenames.length, true);
				data.view.setUint16(index + 10, filenames.length, true);
				data.view.setUint32(index + 12, length, true);
				data.view.setUint32(index + 16, datalength, true);
				writer.writeUint8Array(data.array, function() {
					writer.getData(callback);
				}, onwriteerror);
			},
			_worker: null
		};

		if (!obj.zip.useWebWorkers)
			callback(zipWriter);
		else {
			createWorker('deflater',
				function(worker) {
					zipWriter._worker = worker;
					callback(zipWriter);
				},
				function(err) {
					onerror(err);
				}
			);
		}
	}

	function resolveURLs(urls) {
		var a = document.createElement('a');
		return urls.map(function(url) {
			a.href = url;
			return a.href;
		});
	}

	var DEFAULT_WORKER_SCRIPTS = {
		deflater: ['z-worker.js', 'deflate.js'],
		inflater: ['z-worker.js', 'inflate.js']
	};
	function createWorker(type, callback, onerror) {
		if (obj.zip.workerScripts !== null && obj.zip.workerScriptsPath !== null) {
			onerror(new Error('Either zip.workerScripts or zip.workerScriptsPath may be set, not both.'));
			return;
		}
		var scripts;
		if (obj.zip.workerScripts) {
			scripts = obj.zip.workerScripts[type];
			if (!Array.isArray(scripts)) {
				onerror(new Error('zip.workerScripts.' + type + ' is not an array!'));
				return;
			}
			scripts = resolveURLs(scripts);
		} else {
			scripts = DEFAULT_WORKER_SCRIPTS[type].slice(0);
			scripts[0] = (obj.zip.workerScriptsPath || '') + scripts[0];
		}
		var worker = new Worker(scripts[0]);
		// record total consumed time by inflater/deflater/crc32 in this worker
		worker.codecTime = worker.crcTime = 0;
		worker.postMessage({ type: 'importScripts', scripts: scripts.slice(1) });
		worker.addEventListener('message', onmessage);
		function onmessage(ev) {
			var msg = ev.data;
			if (msg.error) {
				worker.terminate(); // should before onerror(), because onerror() may throw.
				onerror(msg.error);
				return;
			}
			if (msg.type === 'importScripts') {
				worker.removeEventListener('message', onmessage);
				worker.removeEventListener('error', errorHandler);
				callback(worker);
			}
		}
		// catch entry script loading error and other unhandled errors
		worker.addEventListener('error', errorHandler);
		function errorHandler(err) {
			worker.terminate();
			onerror(err);
		}
	}

	function onerror_default(error) {
		console.error(error);
	}
	obj.zip = {
		Reader : Reader,
		Writer : Writer,
		BlobReader : BlobReader,
		Data64URIReader : Data64URIReader,
		TextReader : TextReader,
		BlobWriter : BlobWriter,
		Data64URIWriter : Data64URIWriter,
		TextWriter : TextWriter,
		createReader : function(reader, callback, onerror) {
			onerror = onerror || onerror_default;

			reader.init(function() {
				createZipReader(reader, callback, onerror);
			}, onerror);
		},
		createWriter : function(writer, callback, onerror, dontDeflate) {
			onerror = onerror || onerror_default;
			dontDeflate = !!dontDeflate;

			writer.init(function() {
				createZipWriter(writer, callback, onerror, dontDeflate);
			}, onerror);
		},
		useWebWorkers : true,
		/**
		 * Directory containing the default worker scripts (z-worker.js, deflate.js, and inflate.js), relative to current base url.
		 * E.g.: zip.workerScripts = './';
		 */
		workerScriptsPath : null,
		/**
		 * Advanced option to control which scripts are loaded in the Web worker. If this option is specified, then workerScriptsPath must not be set.
		 * workerScripts.deflater/workerScripts.inflater should be arrays of urls to scripts for deflater/inflater, respectively.
		 * Scripts in the array are executed in order, and the first one should be z-worker.js, which is used to start the worker.
		 * All urls are relative to current base url.
		 * E.g.:
		 * zip.workerScripts = {
		 *   deflater: ['z-worker.js', 'deflate.js'],
		 *   inflater: ['z-worker.js', 'inflate.js']
		 * };
		 */
		workerScripts : null,
	};
	window.zip = obj.zip;

})(this);

},{}],6:[function(require,module,exports){
module.exports = "data:application/font-woff;base64,d09GRgABAAAAAQlAAA0AAAAB1uQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABGRlRNAAEJJAAAABsAAAAcbYoJ9k9TLzIAAAGgAAAASgAAAGBBOWHTY21hcAAABFwAAADOAAAB+m0Cbh9jdnQgAAAFLAAAAAQAAAAEABEBRGdhc3AAAQkcAAAACAAAAAj//wADZ2x5ZgAACvQAAPGBAAGicPkiJhBoZWFkAAABMAAAAC4AAAA2AmunpWhoZWEAAAFgAAAAHQAAACQD8ASgaG10eAAAAewAAAJvAAALfkEKAElsb2NhAAAFMAAABcIAAAXClLgp1m1heHAAAAGAAAAAIAAAACADPAGjbmFtZQAA/HgAAAFbAAAChaIP3G5wb3N0AAD91AAAC0YAABzKmcLV2njaY2BkYGAAYhNVOfd4fpuvDNxMDCBwYZnxFAT9/wATA+MBIJeDASwNAPbHCXMAAHjaY2BkYGA88P8Agx4TAwgASUYGFMB0HwBRcwOWAAAAAAEAAALgAXIAGgAAAAAAAgAAAAEAAQAAAEAALgAAAAB42mNgYaxh/MLAysDA6MOYxsDA4A6lvzJIMrQwMDAxsDEzwIEAgskQkOaawnDgI8OX74wH/h9g0GM8wOAAFGZEUqLAwAgAfRQNpAAAeNqNVjtyFDEQbY33ALAR4cScQhEhRbQhpQM44gLoAAQEDohARUBRLm5AMpwAQodbZJQDH8HWpyU99bSMXX6lXkkt9ed1a+gnPaf0d01kNjLk80gmjTbiWGRKc24vtz3bI4j/eQz8O0ywDfJF1Eu6F1l2YBfamMa1YCG2J7R102QLuh5sxz0EZzJyPEI5P/lNZ77nW7QpxeKOdV5H+Xu3hwIt+TzNZrifAt+7CZ+soitj6CdnO4aNviXIM0Qcsl9a3mS8fjHkPDFuGLNzbEGK30LKHQ7yhPopv+/GuER7TYuRhJZr3/TG+G5K7J04i3lBHvTS+Ipjl+S3Cn9mMvLrrNzZc21qzHZ6HC9C7tI+DgvMZfk91MhJ8CfNvYTf1bbPkctexCRAnAPbmuQrmCt3mmbDaYzHwAMLfQL5DTFd6rqHdSf4byFn6557Kl/SWT/ApxPLVMbaA1ovoLKHboe8mnxfzWUQdiJw7QzwSr1gHuV6AJvRF9fXmh7WxCfuPW94Pu2/FLHchE3rLt/jXV/AryuGE/V4DTV+7j212fVs9HeRfC72dC7We7bd29Fr3fb+xlgqF6pM9z3XKmS//FvQ5r4yLNQG6q2CixofYD/9nttCip/Tfnvs7/cOH5T710nNOL2XNq4nfGSQgJ/0vpkPs7dKvsdBrP3hPhyeEP8V+Fxr6x/XwCXovxC+hLFm6aYA+KTnX8ZTvpueDhnYX+28Z6U3I78bmm0yrmgzfCsNPceLM7Q8SNsnbzv0X/MoNzu3Dhn17qP4npT+zDhaAbVI+G2DOcG37X81NPN7G/tx5NChxVTarHz/5DzSA/ZWhCMAeNpjYGBgZoBgGQZGBhD4AuQxgvksDDeAtBGDApAl9NH8o9VHl4/en2o/7fp09NPxT6c+Xfl089PdTw8+Pfn08tObTx8+/fj09zPbZ57P/J9lv3z//5+B4SPDR8uPth/dP/78NPXTPqCek58ufroO1vMYqOc1UM+XT38+s37mAuoR/mz//z8/Mz8TPwPfP75APis+cz4zPlM+fT5dPi0+DT41PiU+RT45Pmk+CT5BPj4+Hj5O3hdQN5MIGNkY4BoZmYAEE7oChmEPAANnVr4AAAARAUQAAAAqACoAKgBSAGQAmACoAMgA8AEAASABSAFYAXYBngGuAc4B9gKsAvYDHANIA2YDkgO8BCQEcgS0BPgFOgVaBZoF4gYKBloGlAa8BuoHDAcuB1AHcgfcCCQIUgiOCLYI8gkmCYYJugnUCfwKWAqUCs4LCgt0C4QLugvSDCQMbgzwDWYNhA3WDiIONg58DvwPLg9KD5wPyhAAEEIQZhCqEQIRKBFgEawR6hK0EvwTZBOaE7ITyhPWFA4UNhRyFKoUxBUMFTAVihYcFmgWrBbKFuoXEhcmF1YXnhewGAQYKBhCGHAYohj0GSgZWhoeGpobHhtcG/QcWBy2HOQdTh2+HggeNh52HpQfaB/CIDIgpiDIIOIhOCF+IkAi0iMkI0okHCS2JRwlUiXuJjAm8idKJ4AnnigcKKoo4ikAKW4pnim0KcoqDipSKqAq7CsiK1IrlCvIK+QsDCxaLJYs4C0mLVYtbC2CLZgtri3SLeouBi4kLlguei7OL9Qv7jAsMJYxFjF+McQx+jJiMq4yyjLmNGA0dDSgNNY1GDVsNcQ2BjYyNpQ2tDcMN5A3yjhUOQQ5sDnmOho6ejqkOuY69jswO1g7mjvQPCo8fDy0PRw9mD4+Pxw/kj/8QFpA6EFEQXRBkEG+QgxCmkM8Q3hELkRURLZF+kbCRt5H0knUSehKHEoySmJKkErCSu5LCEs0S4hLskvQTCZMTEyITK5M2E0CTQ5NOk1KTbJNxk3cTg5OXk64T05P0FAqUD5QjlCwUWJSJlLEUyJTZlOWU8hUMFSUVOxVUlWqVgBWaFZ+Vt5XGlc+V4JXwlgyWL5ZMFmKWexaUlqiWvpcLly8XOhdJF2AXapd4F4AXjZeVF6KXqBeuF7EXtxe6F8AXwxfJF8wX0Rfel+YX/BgSGBeYKxg/mEkYWhhqmHGYepiEmI6YmZioGLKYvRjLmNOY5xjwGPkZABkIGRKZGhkiGSaZLxk7mUUZVplfGW8ZeZmAGa6ZuJnHmcyZ2xnmmfUaARoHmhsaJRovGjOaRBpRmluaZpp8GosalZqcmqUarZq3Gr+ayRrQmtqa5JrqmvYbBRsTGx0bKhs6G06bWptkm24beZuHG5GbmBucG6ybt5vDm8mb0pvrnAAcIRwpHDgcWxxwHJEcrhzMnOGc6hzxHRidNZ1aHXSdeR19nYIdhp2KnZOdnJ2lna8ds53rHiMeMJ47Hnqesh7VHvSfB58Vnz6fVJ9cH2Afdh+Dn5wfrR+7H8Kf0p/hH+of76APoCKgLyA4IFUgaSB9IIyglqCdILOgwCDFINAg2CDiIOmg8yD5oQAhDKEWIS2hPCFQoWghdqGBIaAhs6HFoc2iC6IxIlcifSKNopyiqaK0Isoi3qLpovKi+6MEow2jFaMcIyYjLiNGo1YjXaNiI3Aje6OQI6MjtKPAI9cj4yP/JBWknKTfJPIk/qUhJTclVCVsJZkltqXspgOmGKYoJjKmPyZXJmImbaZ/Jo4mmqaiprWmyCbOJtmm46cApzanU6dsp30niyeWp6anr6e+p8wn4Cf0qAMoCygeKC8oQihSqF8oYqhrqHGoeSiCKI+omKirKLUovqjKqNOo2akHKRspKyk3qT4pQqliqXkpgamGKcsp7qpSqo2qvyrSKwcrHasmqyyrQatLK2Srcyt4K3urgKuLq5Orniumq7YrwavSq98r7iv8LBmsLaxGrFosZixtLHSsgiyMrJesuKzOrNas2y0HLRwtJy0xLT6tXa14rZOtnC2gramtri3irgcuMS45LkKuSC5drm+ug66Urrcuyi7gLvUvCa8WrzsvY69zL4OvoK+1r8kv2S/kr+uv+jAHMBAwF7AmsC8wPDBAMFMwYDCMsL0w8zEDMQ0xLDE3sUAxUrFrsZOxuLHFMc+x7bH6sgayELI0MkQyUbJ0spsyuDL/M08zgLOLs5Ozs7PMs94z57QINCQ0OLRHNE4AAB42qy9CZRkR3Um/CLeEm/fl9zzZWZlZu1LrtVLVWW3uqXe1KqWWo12lVqtHUFLIJDFViAdI2M4NNgCGQtTZwxGWIAbbIMwY1M2xgZsz8gyGPBawDm/PfxjW8N4PIzHk/pvxMusymqEDGf+qsx48bZYbkTc+90bNyI5zDkcx/0CupbjOcLNfgpxc/s/TQTuHxqfksS/2v9pHkOU+xRPL4v08qeJhP5t/6cRvd50mk696VScx19/553o2v4zDmpCajyHOA59Aa1zBqQecFw1JFKlVK7Xul6nEXntStCFL/ptSRCV/i2KKEj/WXRFt9frZTQiy0RDNytK/3Pz86sXLkB6mONe3OLW0QYrIxdV2s16hW+ur6/ba/Z6vNZDMX2Gi9EmWuMkLua4br3ZbgbNKLQQzXkO1VZQkzQbRdTsdvahenNrfXVt9ZTLK3y6/440HJwjk8sNAbtPu5hvLk++87Vra/eo4WW+f1modpf5mRl+GbKgNYNgHeomcVwzyWVz8/zG+c3NzeH9NURLBHT1au1Wp1lqhIFvYQlKwfMqQQWi8vhxxVceR4SXiKIQkeefUpSnhu/byEXnuRTQDchGy97qQMEhqUaYR10IfaTco5iGcq/i5pSGl/EaSs590zlFOaekXWX+W4brGt+aV9z0JeVtd4NmUAk26R8UeZhfzFG60fJ2mlBWx6e54lprBX00KZ/EY1o+dDMUv/+d7eIP3++iNXSUltejZbMQJOJLUyiCkJa+3erer2RcZWGnXFBQBfVGSw91MUzlkvJWSRvauo3Wd0q8q7xdKGit7QCNG0VMc07vomdlN7UvKWtEWwVJZVpPSKZFuwWl9H+/hI4LiptBvR+m9yVl9aJKUGlXWDFZgS/pC1XIjnZFIMcKpu2JlnZT86devi94XVpLlNAUkirXlhChpX+JroD4l6jDYBzBGNngbuPWoUQm1Lteo//Qt7odmkEBBz6R6D+lbCV5AhpwcDsKo2a3SW8HfthsdDvtVpJApZy8FfjwCPzTe9366MUCYtc6O++gXxk7u9iYmSoUbWcszs9MzU2e3D+marYLz6cKvFLLTkSRolhmKsr4ri0isZPCCMtayrJ1LQqKhcp4oRilNMMwo3Rcqs/V4tIHbcWQJFFASBRszTJURcE8QpJI5InqmGMXiuNTc/NXF3Kek5o/slDL5B1PUVOOlcnmpjKptOcauqqaqQd0YoqamclOjOXSoa8ohpHOFMqVyUIcRrpuG4XPypqmuoajSjKRVFmyTN3SDYmoRBSBUw1pbXARB1wReSWv2aa9jI7iegDx2hQqS3yJrwQha1Cgc3tXHG3E/V7cO9qUm0e3Njs1uda5CT2crthuzrU3WVhBcX8T9YTm0aNNAf5qnU7/M4gbU13ThY86thNjPLIHZepxHgesoVteQi3gTnlomTzyp6BXVeqkSboVVVXRm9SqCp9fObeUPbfUU/+rqnbUV8J369WnXp3w5O20ilC77RRK26lG7Sm0hEpBaQk10WdoYv1HWcKWFfd/DZ2KEcdSZGmv9eJ4M45Znx+m+5Kp7kppNIWfoEyVqPkSZToVL7xkkS5N9yXpxpLchyD59gj1wj+NPxVD0qP0gyR7MZWRINP+D/SPOW4vd5jyziJaKKAuTZuOMyq5AhjvVICVl3BNIgGR6iDGOm06eLpB2IF4C/grlCGJzSLd5g/xItZF4SFRJqcF4TSRHxFEHYtw3Tb5GwThesR/AE4LPF9QVRryIpq3hQMC5p/CqvCAQMgpQZBPEfKQoOKneJ6H3mWbwhlelK9FQu0qeLDAy/D2H14lqSwGGIETtvu7Bv29xS1ynEtZVCK0/HAk3m2AiIE2Aca9D2gXNjrQGIyfQMRzSs6bcy507f/EwiOy3F+V5cV8Lb9e8Ny83d9APdeMaZ8eDWbl/nlZRhfkCTuK7Ikk7F9A3IusbIANNkBmpEB2jHHTtG/QkjB+TMu1D1FU0IgWIqnRadXKkt9ptMoSlWPAYdGbTd83+x+m4eG6Yp821In3nOh0TnT+JZf77N6Jib0TaMYzv0rvf9X0xjV14i+7J7rdE6/OFSfobchf2sYnDoy9ElflJrgZVg4mb6lcWHAWQJJFZRKU2rWK0+i2S0HY7ALCIBRlwBd9WLdtvf8wDR0No3WsabgPobe5ubbRQ2tw8wf0JpJ1O9Z9X3+R01/7Wr1n27Ftz89zSTu9ALS4wPlcLqFFN6EBxSmUJtCfZ1GlAzQIB7QYPZ6Ip6djJNNQuMo0r2eN9OBIOD9R+NPC5CQEE72O+pzLLo58Erm2XYaXzv2SXHanyeRY8n6Km4UUIhMBJ7VQuzJsTehN0JzedpJ1ymprSxjy+ZcMX/BuIFLb9nNZD9cyDymvyVSrGee4YNyRqRYyV7uWw8/MR+5bvcwd6TLaU0k/na709guV9NnLM+VdNKT9aZwDukYUQFCcR0wUSEHEJGLZr0g/io7PnXnkkY8/UkJYCE8LMi8jVD34Q7RED/3K6153zb4FhJFMritijKxvvwRB0Uh5fnRJXiLHl0ifG+DtJL0M1wX61hbaVB4NZD6wo3oFErVQt+U1EhA1zAiiCXJodZdRGqUWhDuPRMHM5dkiEgReWtT//MidOYR457AEp1i2g+jIHby+tgfhymRvMtQP3y61dYzDFRHddPvhuSkEkls6loGS8YJ09rDr7DkximMI9GDOHQxTEZAFsENaCoZIAHIHPnDQKGx0H/2tR+GDrkGoiHiMXj0NUBzxaUgen4SkebTBnnARYIUUQu+ehPtwFx5FxyGaYDEENHkLlUtcAZC7ieqziIHzsIi8Dno0I6n/WS0a8qFCUUvF2u2/oaK3+SWz/7whqdLRclkvp5BxHyLGjh6xAdgxC8fQB02AgW5Ah6iTQD2KxiP0Sxj/L4kXxXfxGOOcLWFBWv0yFngBXQ3ivr8piY/zAkYCLtiSdBLqgyFtHuTVb6MlhpEXup1EjCRaUCfa+qQsF2X567zKf53F3vdRWS7I8h/z/B+zyKB8L34X5NMHWRpMGtG6wvsssTM7rxAFIh/dHEmU0FufpGnwL34XcYM0Fpjwogg2Sav7qzQNhWxnS5MoyGSnXEk5eO4yqEuPpUGkpA6NpEZz6Ifq8snvXVKZj3JUZ4T+sgb9xQHZtMwd5C7njnEnqcyFtLblUtQMo3rZbzZaAy1oCifaBeUnwEXKcA3YFFxhzASRAWeuD76r0GOCbC0b4BS/BpD07Zpta0/8vOY42lFNruoaUjS9KuufP39+Y+Otb30OxSWCRCvwslkvsEVSWsvlgIE/yRj43YAwZc3of07X0RWGJhsbDIz02GcwRv8WxsCHoHYzI2Og3u0MxsBgPBZBS6CjoLGCKCyn+KE1GA0njp+QpJDnMX/iBAR8IEknTmAcYBkfTy7w6EPs2aePH5ekgOePHWNPHT+BZBxifOI4nEJf3KUXZ6muw7QUkihX9UR/7SbKIXqd6he0Rx/VcqH2trdpYY7GC7766BILHx3c3YmPpl1laTNIRJNPlGOaA1SryfJoJl0DvRGgsCBKwqOP0rAmCI89BoBMEugVGgI8e2xJ0IWqQB+Bgy48+jZVhQff9jZ4VVXeluQ7DzReZbp4Y0eB6wB3g7FJgzBAryrPz5f7/7XaLmeFUqib5p7y/GXfWKiUFzrVwpwS5kmheniB2UVoPd6A3gBtptO60JJCg0UkstAKHibPehypDLsbeoNhxN2ioR/sfqpnPh8bav8/qYahfiV+QlORoaCbdKPYjQ1jovsJEzrHV+hN1FCNWO3/s6pyo9iMcBaMgOJOfxmKpNol58+u7tmzuueqsUxmLLPAessn7jxy5M4jqLSH3jmdoXe+z/rGN4/QO9wA43AohnbyQS5OAwY8xB2ltUyk8LBqgG6hUwY+xGDswXW4vR2P2jtXuiPxerMe+KiADeW/K6apbEjAtE//v/wVPP28AeM38Bv4F3n+F3GMP8/zn8dz+69AkST8D9U0VbSqmhjzN9kqD3ziURZeORI/efKgzm23Dy1/AC1e+hElD0F3I80Ea1RAnOhQIsuiJZLQNfzNe/9y6zLNeSuKeOmfVdtW0VWKCULlJr6z8v3nHe3qQT6rwKbnmT1L4zgHkJ44+GKuzyVfZMfxGvsM9K0YAcQDfRJ0tyrA59aAEYKop3rIQMtBc/3vOPw7FF95B6/rev+bur5uC8IXFOV3QCGO9XEdPkOdBrA053JL1FJVr3X24UaYaOzUVNdJKo8ZpooKOCJSRHUOJk87XVDogdMsY0/lsah84QuKiHn1I4KckYUtgizyuc/JtsJPH/CvASEqoLOBBLek4CxIKv5qvzeNpkRJEgRQ1W/AgoDPgL7+J8Q0yZ8oAs5PGzdT0YuuMXnADSaIbSzcbEznE9oluhjtyXUoeSMyhUp5FteX0bD3dhlQYXo0bTZp61UPZq29Y/vyY/v3l8sH7giOtdvH2je4JmhA04VCCIpD761Zc9713eli5cDKX3aOdTrHDpsuIWGxOF1UE5tmjN4C9FcBAYxR5F5AeVSiBr4ucIFKC7jBiLkRCAUwHi0RIva3FO0rmrwpEvnfXN4R/P7XfMHBkmahA2gFKWouZ0olyVBkfEwrPBsEn/NMosaJTTPBCBmaY3WXztKtURlapQKViFG9C6p7JSJddIEakfrrRDF4pPA2etAUFMHu/+pX/Oay7600vcYLivS8pEBgYCzOmMIxwZ41hUO/t3dsL3zGuBHbRYbrgazkollqfaRqaYNZciingi5CjUc8RYVUXW0MzD71bgQShhl4ygPLEPC3bqVLmq9prTx6c6WEeOTZ7WE0pRXihQkb0BiCPut2Zlpj3bgxoUuDC92Z9li1du3P1q4V8vcs3/yoBohQGcZkCY3PdOZXQ0CzAONw3B7vzHQWTgUSTs5bE7/+wC8+MMAzWzB+NjiR49oeafLdrebPbTU3ELf5Irc5GF/r0L4WG/kNaEoTU1oDmZvVqASIFlPbDVQfDuhVOkE6wqrc/6IuIwP76Drcf1oC/Ksd9yVN0913W4iT1d8iRFLVZ/2Fkt5UCOJ1QxjIlXWQKzrVfySyLDTbEdm67vYqJqWZa1sbG++r9eT8Fd2Z1Qs/zQ36AZV/U9SSNOZHEqnBaISwTGr1To0G7Va90w27HRo2umEEg5WGgxGBbqyKWjmXVkI7PBG6gTJfU6VqlSjlXEoJ3ORaKlfWxL9f3bt3de93DsGDci5d1cRqVVJr8/ShWjkMbTmXYq/CxVRODu0P7KUvjJSxzs1BX61I0Ox1iQSVdq1O6t1avdJudljvoBptGHUjEkbN7fKtT0ta3CmZqRMZvdSJNWl6CuBbJ++kT6SdfKegiVN/Ph3H0/EHPD/uxDKZnZUJRHzvRNaE51QyMUFUeNAPborpg1AcZZtnUptEBcq1j7uCu4a7lbsP+IYPfB3GETRmEP2IuPj/0zM90iDwWd91eJH78a+iOkkiO59P/xhXWL9H0O/fAv3+JMVOEqEm3UTjbkBTdECHqdMuvmPEpTqcCeAKOnqRoqqE6ZRr8GRivwUglxh50VuwTMw4kyoXw5ytYUERM6IggEDwzWypnNVCEAmCABcVAUk8b+fCYjmViU0iY6HliYZdu64GwtxuPV+/PTUfV1L3psspYpWKjgWyQeWRIxmG6CJIRZIsJ46JhnEKHktV4vnU7fXrF31elX2faMReHNWpLKZTUQzc6g6wJ3pzufzJT5bLhVcUsrnCGbRWuaPym78JQRzncvEIzyMgEbs7CCnqAF0kZp1KTNeUSkGTphsObeWEIhRqJQeJnGDrf0aOobu2brgLejpVy3m5BUEp2zKWM8DmhToIS8X0Blrn7xuunXGsdzleyXMNbyGQrFCXdUGyLCMnCJqsyIo5wPz/DRr03dw4B3jSY/kzlTugna1NYSnTHreLWWlRRMwXkIlm0TL6Vt1TioEl8mSZYIPkNE0TdM3KpC1y5XR+dulgkMG58QzOotcU2sWMljZ1W/ElcdZXU4QokmOFppvS4qvyfv8LKDOZxunJzCg+V+nIp9Mg9NtF6/Nra2vzmxsb6+sbW0N8tQnPERiPs8DJEluF3x2xgtHZHDFyWnBCnG4ys9Ng8B6dG8/lxnNjOzYwVLrd6H9Aw2+WFU3qCJJKXCLJWzn63GPw0LPsoSO6/Qf3IgGw0L89KZN90CFtkdkEk7KkuQlAqdfA2UCrr84CFYlER0UHBCxAPpHKdmBgtYoIcDTqioBMK3O4TAILBYnqgRPdiqofdVorNgeGflU1gPSm2v8MRLClGChAmoLGISL2X0CG+pd0PqP/v1XbRdeq2t78H6uYJ9KdkqyIU7wAkNIRJZnPOpYfmPBFLWQq/f+l6shGujqLkCb/V9lAKTh2VMXQikgOFfTp9J1/gGAUKgpaWSfkfoksAFrWBbF0wAf+mAu4URmvAZ7JJ7xBoigQgN/QSOW1aVPSKUN48q033/wYZuFzzPKkhwfD8IvDaxDOM3NU/39qH9c3tG07EreOLgAnBu0d1Gg6mwff2qDd1+J1wLc6a1bbfsGeZy3HypbYnxzo5206lgdYjvIsqnP5GIpJp5EGxiYKNhjT8oFrUXxaazV89PD4Ix9/5JEzhzuyangrLcuyVE0mhic4wdjJsQq9YLUqEH1mE+3rHGb2sXHRAwXrL9nlwBE8g8iaOnyOvXKKTfTu6Aoa8IsCYHg6JTAwbHeAGcAA5B3GF5i9QIGGU/rfV96WU0TzrPRnhPyZhF4Pl94LrWRKMqr0/0GSkEd5tkjT5jYZH4tAny6C7OK8gU1ioIw0Q5o2pDyJ/IbbaJW7TsV5mmo7F2iwKKQEIaXLsgwEBo4IXfDiUBWK4Wr/2djeto1z3NZgTBYBYXCdAee7NEd3iK5BolekRC07y7rCa6mN42kadPZPTu6ffBKrj+vmo8bPeBnPyyB1dCj2NybpMz/3OmDlxoPWUO+KQd9ZY9oQnfdxSoycBPQh+jWhCGir31PRx9W4v97DXPfcV8+hM/1/RZL6wnPPtUXR1jTob9RQ9yvoLYBbx6FHF5BUh3/oGEy8gaINWgwM8pB02rP8HCoI6ClZUEkwaUdu5/qxY1kThl/1rjvyE9OyOK3OXLtnWlMFu9m+6jAKXIQMT5PlML7sQ2d8ga9n7VTpVQuyrprW1GRV1yS/PTs/rM8a8MOYzVUf4LgVNLREAyROJjuAdtTyVJtC1IgYwe3KYEKQzpbsQ1T4bpuzG+Hm+dLcXOl8MyTzrnmeTnnYvA3IUtp1Os8eSk28MD9Xiktz844VD+dIzJQozlMROnLOHsoO8CX3T9AHTC5kkg+Gm4Vmhfa2PeDys1fsLxREe6KYWZstl2dLaP3yRvOxiXEpXFlajRuvLNGrQ18NtM50h0lmjWZVwFR/WKBUGAIKFNCLdeCpC8BHpVAxDIX3ziwvn2HR/v90ftHNZcfHs7nYUL6mGMXDN910uMiiqFgsUu0rjwqD/E5CfhG1w3eDZcTmlwH7Qj6UJZBgDnVBOQTg0i4iC3VNxCakCVVS2s9WF1QZWgCX0NJCZJ/ITL8ZrSz4DkT2Ibgn8XMYlX5+r7SnHkQWnkL89KLQPu3IaM9lUf32zmmHsFhzr7S3FkYGPw16y2yHles73NMMT0yxuTDG8YKk9tR0AEOrVm/T2UMJxlclYFdpa5+LgyAO/Kxti0GAoLsCHrCzfhVdG9I7hbz3oKoo6j397xi6an3kI6ammahwD732oAecnEphJtveDHy9BBrDEe40YN47uPu513OPMm7q+GRgQqPfOh3fzDYLQ4Rvk6AbtQkjYbsOSJ0AmIi6cBlgPJAR7gXNqEwdPOB2pwFAHmgMw6xOsSFoHBENST2ot2kEUiG0i4NuUqfwHx6HFNHnCKEzALfdJpPbbqM+P/dA5KxMvnfFXUcF0QIWdVTDKmh19xxFki5hAYtHCY8lhC5egUUkiCL+ASGaDImICH3UwJqs/YkliAZ/qyhpWMa8jr6mqaqmajTUUFdU+n+nChgfPCgI9CsqKK2IVyQn/W9/v/H9xsJbNaQYIn//wh0SMhD6+ML9oG1qEiJYfP3CeQs9+P2F6xDIXoR+5jEsQrEwhnEiY10W00hEuqxQg4aOFcxrSNRVVQdNkIaDfhpDf6hTHa49nBdt7NifJVKhlExcOwB9VEDr7g7vAQ/WbW35zLJm60tzGCu8buu8gvHc0mUzvdnZ3szzsqbJ5sTy8oTJYgvHdQDOe2Vdl/cClNaPL1yIp2eKF4rT00XKo/CLW9wvQXli7iB3jI36KLH+0MkiQg0/MIzKrcqQdzbyg8mdOdQCpaENmk0Eg7lJlf4GnUEl7RY11gHHmJRlidcEAsQTfA9BFxeg4Yig8ZIs36cDoM8bNsJEwaDDIyQgJfQVOCCU8320EWdTRcOSeISRKELAS5ZRTGV/Rscv6IYk8OKtb8xhnU51IHSqpGklbajfA/qno41N/CXAJfmyScBKYrNjCGTwBab0lSjex/7iqHCmEMVPsr84QhuFMFedgv/JsHDllYVwkp3kwsKu+SdtxPYOkmpgWV97kRtg+/sHPg1UK9miT1fp0xTpQt7oNuqd0/8dGm4xWekN54aS50GSUA8KtL7R643iZw2QQYVaKbZn0psIco8q5W5rGbe7+yhiokiIoN/UtP4Z6P9P9Nf/8aYKkh0FzcwgxRH0CK1r/X+BW6r2Ire1tU4wAGh+ZkLgiQo9K8nvAuT2wsBuzHUGXCy85HjFZD4/mX9gJLzAkNzoZ9sGs87GwGDmmzB4QbkecBU2ZblzxWHaDLpXMXSjUA2KxWD/c4CisRVVg0IhWEKW9hc82tCV/p/W7SA7md2s/X0EfQthF05QQfX4EtrGF8y2k9gBdrXBrvb4EW2DDr50fNBm68nhRW7QhDS/q1APzQ3tu7QNqwP7LupRfx36/TVm22UeJgMdClr9Ya5F+y+MIzbWqKGvE4UB8aVttR3uUVcqOKnXiLTNRJ7QUlEpns8Xsnnk2qYvC5rGC6LjOk55toyq+hfrqWhu4ns123HcsW/7qSj4hCDrnwgEon47raiqkv5esRQXvzjE7sx4sM5oxnWZgukwawbz30hOm2v6ER0+P08D+ofupmH/SRbbSSfps/updshGXpOOSzKFEscyKrKpyZCaIjptqoMwO7QfUkg/kNb0H71rstmEj7G5iYUrdSeSXRGDBBCBDU/fNA2hyAsyFl0Jz2H+SuFh+vDkMxnTzwugUYUC1qO8qruKjW0narcjByKKq6v5SC8I2EEo7+8uc4s7RzUjgGKt+iymBVzm96OdsrZqbVZYn1pBd0o7qNkyerla5RAdoPQ/QD/TxPgsQnwmzRug9glI55HIYx6j3P48giMvIt4Q8dgv/wcsHBhXbQFUVXobV0/WIBQwLyPBlnSDtw8I+A2eecMVkqyGKgglDCKSV5DieZKqiyATTNEeq1qiCQoi0VXJ8+VAQI8f0N20peVVLy3rtmxgUDfn5j3LxLpi63LaU23ZBG4spV29smu+D1BX6SduyfUfswl/4rajPOY5aLuLzLMFBlEYFHGd1EkXEE6rQ50ZaxULt9g8KDXh0AkU0PT/VUJSk0eHdP0Qwi04AaSwvK58VnR8R/yssr4sP34shwVUkl07jm0oXwkJOHeM55GxkJYeXWkEe/YEDzwqpRcMvE2fXmKLqoY+EXd8VSPUBqb8PUmkslkSv6HklF/hdRldJ+s8x+32b/BG5QszrATUF2goZ87H58/H26LmPD29dC42ccYdwIqBo+sAfiQ87q3As946jGyNniSRkfSo/AqYcYcNYiqXNjZ6WzTY2Bgpd5b5ycFD7Nsk7Asjnn4rXfh6cOnmm+8wbr8v7IX3hivhzXfqEF8J4Xuvfq++1jndWYe/5IDU06e54Tz+JqsX1YnrIOvnmG/ltqPPlLDjBATMlgeCUXdzIF0wnK6nX/R4VCqH47K8pYnjYbkUjSPO3traQrbzT8zXGPXymUej4vnzlewbsrler3/x4kW0Oj/fs+0Ltj3PPiN+N1AyYSALUe3j1I5gU9PDx4dtQcsMemC13pxFA2viCooYh6+36lDchTrjJUtSCxDfEuou8Z32MgKNKdpHJ9yiJlq7+5h4vNE+frw9WZKmSGflsnsslGAgZN1zmW1hfP20zx9YOz/fO37v8ZQ4K02cPgDoif7DRycUNAPf0Ok58BoaHDjN26uVyQHPm4e60DkJl81u4SKoppWg3hW7AYlAEZnqFV2Exw7uefLJ/osXrr4acVNLS0F4oHrTT1+48Pieqw7t5bjdcxvVJIEAEoMhX739uo2N1rWzRXG+V4N3VunrO/z2TUAjL/EeGEzwS5VtX6ahRQq9iZApXhT407XJA7fc8rabg9vofPTiEiHTPH8muvmxm28+ODn2a2yWmtueN6Wy36PrAqrtLvMHrTHLvAnqYCWgMzCtZZ5OwaC45vW3ZM172AhEYe9fLB0o827xwNT6+uX7iveD9v8XnuyJ0m98YHyRhIvTlf1ra9woLstx49R2jMomJiY/hdrNxjLuLvPQGSNCdSoYDo2IWiQieqFSrlOe2Q2b6GqvWHK9MDXTzM/NecUxIwzS041C/tSpf6nU5+aWm6qLyT+fOpXvtcUscPWxSaQZcZDJ56e8FaPq5HP5Cbdz6vR8tYJW5vUUrz44d/pUpy2Ogc5UH/jNMzpUAV9QENFNbPv0QFFk4lWeHBLhrsv653lRUl+HJcvixdeBLix+Hi6iNf2BR3iVrJzEDp1rPtkDvPjIAyDyx/WRfIb4lE2D0K6ehBQ1sNUMgxC9VqcZibz1evhaEn69JfKfp5nQqWvIyOmd5B1UcPDJFYdmM9Rv14DeRcAUh7hV7jqQ0w9w7+B+nnuKYow82oeoJrKE9+HEsWcfWqBnoFANPHaHtpjKNmNcwjFTX0D3Gqpc0EmEl7jWZX5uTWogrizUmxHzDIBGjAj088oyT9XcgQ048BvlNvMnQvZmyradBYunY5Y4oa3mDRXJRFkwfTOnI9u2Xd+EeP+FYezX7FCtKL+lVFQ3uAJ5URal0z4MZi/MErSFBC3leDgSFRAi8tmMIcov7L/easlyy7JaPI/heP2JEzdYTdUUid5sUgNg07rhhLwmy2spU12jF9ZUfMn5miRYE+O2IBUiRYkQH6q1jC57uTQJ8TFZVRTRMExFHPp7rA36fYtZ0W8Cvt9u/kgitzsjdBwbpSklXadbB8FMTbxRF3oHScyoyeQLjQV+b0vLmSoiCdXyWj+h2N+ww98xsggt0AG8dCYh1RsMWQT8cJdIi/0bQA2zxajRatHKtszPbFd7J7hDrWf0XhQCg2QUwEcMeF2Voe6mwfxp0EC217nLofddDyOqTNiUeDKFRjEO9V+hE2Vs1cNAh4ZjIzKBoUuJllMpMwrNJmMRKllP1ktQKBXSR+Cdf7RC3zJSoe7anu6KQjEXIsn0531TDAuK7GkOAohmhemJQsHNFTVjLI+0iuNWNFQox2pQmLdmNHVacjRZxK6q+UIYlZAYpVEowx9cyDaa8zOSqkrzpqM56WwhcnXfrju9/XrGX7TtduN8EcTd5bKpGhLo4mY9LhTyRaoHD+lQGHpivEzddmr08iVVtwtY+6Ey3DDIedj31hm+SnML3BJ3LXcb9WMZesWwtT31Lono7FG9Vo6SK9RhjEJV6hFHjxHp1glzVmMuDP/+M4SQj0m+9LHkQJ56Cpv4qacE9XfggmzLcD0rSeQNcO+nBFF411PeG9SM+gYPnviN7TezMF5Hn5ALMnsC5XiFv5qHDzt8+PhxhI4fx0/zKn9KEE7BAbQDYT/P7wOgfO64sk8U9ynHsbXzlsnzwj6e3wv3bz+u7IeH4f6Ob1NCrzq38sOU+hF1H97/YZrsosNXXrL2lZes8SW1xC9Zu4desk6jfvTU2h9Cy+/jDkLNgjqpRkGlDh2NegFHQbMegURv19t5PIXphSm8hNjwmkJRHbjTYPlSg4q7NuIP/B6aeP8PvrxSmbT46gReGXv7662qIpSQPWEDv3CdwP7QzyFe0CQpqo97aLZ914c//PqvPDVTLQR8/r6zZ09vffomNHeNIzcmbTuvEpOQN/7rHolYeXtm+vodO0RS9oCjjtsRSI8fKjTxGXAAmNa7c7tE47g39ofjnjeO5tp3vu6rHxxke/vt12CWONlu38RWU2D+d70d7aEqkTDqRLV6mR67NaAEUKBGQCfrMM4kkXItajBWRckU0ovwaHh+4zxd0rY3vV8iix3+g05YiDvpmbf2vPSBxfwj47XToiIJ+08K/lPFjKgKui4ej6ffeZDsG9eQgtbZ+6lq1nBFvr0mFvaEpapbutxpnZOXZq6oYGzLHkZPq5NVJ+b5cq+cmToqCEVS4eRL6lQE7DLL7aGrZS71X4RiA4OJylB0iDUbhPKhDnyZJxLlqyBkOolbDPxLDHl1kqq9+bFbbnnslueJNB6l+WkxKnmeqE7d7IXt/c7fS+MEI23slt545sReQVJ8ReJJOjtbKe0RBnV74RaawHHXcIO4cp1nlNNIDcdttPjqZoxjhRR5K9scmyTYk22cSqf0spafyeCkzQyo32uYnSjNrPV0XQjnRaReRN06dZMk9TbACVIPqAmesqBuMwKAQShr69YfuOrBk9nWmfbvnTz54IPwvco7e9a76oHWte1O+9rWVXChdaZ1LXrNwStW8GR79qGVZv3wIRCyVxzU/X37fP1ge7o7Pb04tQpXDrYmF9nc406ZtMTuR8sTQCGozjLImZYrorlDFhA+8AA9rpYffLDMMnvT8uUHD16+fOwPId2/PhimDx1Kh4N5pk2G86n/QpMMVUnmYw0SAypJ12e16GqcNpWlMHhRQMEcXbC13pMXr5mZmVxYLHvapDDjKFrGHZ+2LatQsJoO4nqbm72pyamebp6Jnaqv6rFrV6bs2L540d62sSX5v2TuuzIYTW7Uh3YFZP4p7heH82QEQE2LMhI28dSpQ6mpV9YUkiLmGiclwKBepp5zmLkl0jm/dssr18MIVL1afbBeshWNLI4cXTpJL1TaNUqUBTij890ruJFMhi8kM+JN6gZIFaUwj6kLypnLBECUs3siVRejcr6TL0eirkaLsxqvm2nToMs2VCRlPVPWhEPXvtd3vbRY8jSsWpKEvpDxxm2zmBkfv3p8PBMb9rjlK4KsYF8UfeQZ1YDoPEESnylnslkIeAkRXifBTWIObbz91uMPRzqacvOmNLd/LJOPU7KcivOZsf1zkuZL6RCbckbQXFzXotefuLX/d4qpSPJR2dZEByNxr5/Zc3i2NhZnXcdxs6VKbfbwnsBRdV9Eum0hvXSglisWZYxCSQoRJsU4V7vHN5ympA1szEk7/d+20E9Ox5+88hzHjfii1EF7vJy7eujbQ5evFJhfeDlZhEvD8vBsH2iv5cTPhyFkanjrMMQ8XJ47aqvZHJuyTNcyzaPL7T3j+cO2yGu4PhuX995bOoQJnwd1c2KsHrlGpRAZWrkQAJg76a6uuuhVhVq9ZCmGYupWzq7tmSzUUo4UGKKF5ov1XM7dQrI9lq0UU2769UYq3m8bqeI+85B76pR78uRo/SaAex8FpMZ1f6haw4XG1PUdKm8C66O9v+5H2wuNacUiqORopbvNnTo+b1nWsQOL+yeLHRkJk+lUpbrnp/cbkW2ZmnqfaacdTbWcyFOVn/ILSMTpdG16rFj58MmT5dXV8sd1s+CM75stjqc9wdQJn0mVJvP5UrboFUHl0CQiP5JJZzXVz2RzhvYDM/SRbOaiXOpfyqdOlU+OYizKO4HjoJJTogsaoyb1gwRZj9ao4T/ur/+Xmd74wblxdr7Wh1duffjIkYdPj/p68tSCAi+XVlCF1CsADtB6f/3PezO18bmD4zT+sYdPn374yMBfZPCOxZW5BrecWN/qC2y1AhsFUSPxMWBcFSJN0DIucbtivipwRhcevL7bzRi2k7Gd9+cq3Zwv427XfzOb+tg0fM9ESxj3fx/zvWcyjm44jqE7Ya167paqL6i3PZPKvccx+l8wfN9ABwynv4HRfnj+S/ygLyQ4lPodze9eA0mLQQ12HdadgSX7YtKjqR9Sm3mzDc2WSTnOdO2MAx/EVXIFv9vFsp9D67sy33zmmS8Nyvjn56q1XOqZ21TBr94ywBe/C2URQdItcie4G7iHuDdzj3NctQW4sFxnYdUn4XZnZfQERt3sRomPF71cp5AqWbW7s+Y90fxoNUQKsahCRKjlR+wsMX+UWby9Yo6CsEEvp3UNCQMoXbiE+F7vsV4PHcyi1159zWtRtjBudI+R/Bk972Yyrpc5nDrRNn3V1CVyTJR4UQA8pUGKvGD3L5haRlGJJAl0hdipBhKUAEsibl95sm0FigDtffLK15iuoSmZh4zC3HzBSE2MbxSLcQzfw0VTVPauru5RRbPoF4waf9bJZWqQq3klXzOIpJu/BNyaLq/RbJ4nsqTZH7O1QiTR1WmS9ER5QZH0tIskAVWrupvWJWWhXH1ScU1Xil6lFwp6aohbf5f5Nre4/Yz73cTdAS2QUH2b6M0h1fehxKJNJ6ITuodiQt7AHxussST0yDoQINp6MmlNwp1OtU1p9LtZ9NCHKV191+oew8UbzDTy0mkPORl0WXhiwfL8fP82OSCyatGlHKpqvuBlPDfn3gbkSo+7MSFG4Q525SnN1GQSfIkSbs+phHBBHgh3l5sCwkWOeUysGPmJyBUt1fplmpb6+9QfB7rzm4AauiTphVV2apgFULct0eV26boJDq4wWm37aQ0xcJ0tQ6hVomT+pR4UUMQPr4VREy4GYWm2BJ/xOJWKU/Y9719dW32Bt91Dk9XxY2eFzQ99e/Xi+ndfIc1Lf/TuN51nz66k6LPffP89q2sbE2OTh1yLnxPOHkPnv/2h9YsnXvGmd/8RPD3K+4ZzxYPStQclGB6TArCcWW5JLp+i6T9Hk9ylq46BBvN+al1honAwqpKFbExjGsoF6ulbH/oGDkZrfWTEekMZX0t4SDLzNrqBxfDeYJcLOivnD98ZONP6CT5IZrDoIoh7i1OqhPnrVkxTU2y/OCWLPD891XNlXfWCQkYNT9wnaMvTudB2IWYtf0fLRJV6xtN0megqBETWrdCiPoZCIROGqqYbkV/OWr6m0w0rNIUQQSFq4Bq6AAMXPqKftkJVt9HaVMF1Nd2ylq6jC3CmCratapazND2FMdFiG99zPLLD1PSSzt97XE9lM9NL/b8HAWhqlu0okL+ryIJInUYlmYeUFdUAiWbbigwZK5qiqwRixJSokQiGM6aLYUURLsk51x+RU1nu/uHuJrtovu2rSYbrQQaO5oOlJEkLXLKDyPYMIWuAIf3ppMnwHm009NAoVaeLGTU4cd/1OjSDb2Z90eKJEAaRTBSBEEW1JaLprpUr+ZGha2oYZgoCjNNMytIVulMItAS0g+ZlQMhm3r+bZIyMK3bKy9CmkEQEQBf4nUkkUO9FW1E1TVEkUVZs2w9NQ1VE6BDACU1XFGj7QcqKY1uaqWrDddUcugAj+AqQ0IA0pZ0+tgRCOfGvZ7PjA0q0B/cTv5VK4m5OPVp29ln53VKhbEZhPkiZAN7ng8DSZGl5bU3gNf1gOgS2Q4S1tVhQDcd15wXeMh0v64V2yz9g8SJRgG5W/p17iaNH9tT53h01RZXkSl5VFVsffyg+nw/SliUXn8roigEsSuS57TX8SV1+rJq8XClftiRDTPRN6GuT3CshxpykIDNae2BqyWEJhU3a9ZiCxES0RDpkGXXJJKrUOyvIpDAqERNFxAqa9ChIiDpbQvGpBZ+ZPoY71SyhOvqmW3j/m1YP2eSydrGh6JJql2bCcMq48hG8eHW+EKulYgkpSIDOEZgCKFBYllJ0KbcYLu2pVfFYyVjUdakcLi2pWro+U8mWQjI5udScrRR8B6Grc6F+zzPTeBJV81gAnIP0XDsd3SoRa2KxKHoVj09Dr0OiIWgIYykzX5L0APF5r6qTqXQk8UFRUAO+jHKBTpCZCuql5uysLg/nHhO6/SRU+3Hq/OOUe2du77ehDEuJ7+FgxcR2Z0nGPlsH2x2yhSjc2SuoRvW1AVsmnW1OQT1kI58kS1W22QQ9TNH1K5hEy2iHl48miX5bjby4USnHupX2XNWKRJVXADmJueDqgitnLV1yiEgkWYChHtu8qRHLMcfzNcMs+74iphUDVEVbkp0QCXYFybxi2NCZiY54JKmaIxlZFJV1DAqWKiuKLmhiRldt01G1VLXUKKKTs83JmcNxSROzqXr3KtMTFZ53s1ekcejVbkvbhioKUm1KgcIh0in4gv7G2Ym0wjtOEUVOqE9OIehmruFFR0RPrJoWDpBfUHlMkEg04rnXzYxFviCXCocnBnYPEdrgLRQ17LTADv0T6neGlNohfY3Q+cko3KHZdHZIMaIyesWuLgGzUzRzQCw3MMeDPXZ5p5Z2bVhLUWS1FLNe7R5Hdxx9u5pI7hQskEq0u8jbOvzQBuUN/ODp6pKoG9TbZHCsAi/sgm5loeSILn7zm/YP4ieftJ8diX70ifhL3xj7dfvh8Jc+lX3fN4pPfuVbnwnCN/zyr//CiF1nmBdXhXQrNG1Ij+ptaPMHkBoNPguJQAL/5Vuf4eHVEb3LgBIWEs3WHey9wSb3W5EfRnUJhhWAFQvRPhglmIMZnWhXboR0/ahUkSpRdw5Abac5vDAwB7EdNs5vnMfKTT1bWT3vdaavsb6Y0lC75AU52V52DBMoiRsHb25iGc0KgL5VdaWWdSEi5JxZQYQL7aMaDpFRR+vnV1W7d5OMz2+sNk4H347/VBAQfs9al/R/a2+cilIZS3dnrkQA6NHnHziGZEKxPfp/Jq+x5em6pOdLD+yeT7Ch5mfpHhF+VB6ObNDQuwBHm1E5GZXtVnVIlTJhey7M0hXujAHT6tW7jU4NSFAvS9ShNCKDC1NoCMgoYvtiWwFO6Ou2kknBUEu/h5eFm0GPn18REXqVi8meKbgc1g3kuBh6l2k4y74AIzvnzlCqKEq2tuIzqrhlUd9zc6XcqMAb8qfei1wMSWMJH/08ehEj/9q2ZFSn65OqPX+Vj9CBB0p5z8kiV7cyQKJ4728N6XLsgc8Dw8eKfcTwZpGItG2el/j+sFnwLglAJ2nXQ9r8IaG2DgvNIaheEdG56iWESq6xrk6r9Lu2pl73amQpN5jm9YqNXo1tG71R+PozgvDM1wVhY0P48rP4fVH0PvysIL7//eIlvkaX5nZJyrtTGrQj5piv22nuFfA+aFaErUPAUrDgR3T+PNyH6Qw69F42q7mEO+0F5rZSm8IUd0OXp80L4oW5DQMEpDIFYB70cb4dIUVRDp1DyEnzvAnQFd29rGn770XI1k2eT4MQPHrra7rFKZ6fKh69VdNuPQpxYbJ4zSuUhfegNSEPLdDstJvQLrYhCIbtI9xsd5oI+3k+5ufKnU67U54TBIi1K0fK83z/b750+6AdWN2ydIUO3WWFFnF3ATEtvtito/9Ds7/yj69M8j56m6LcBuXoP/+e96Cpzr2j6dPYP529fcTWqNC9CqM66dZBQ0WbP9t95zu7P/vxVvsHd188f/7i3U8/vduHapff7kOa1n+fplFnXHq4l/mKcwJ7dpLtbzRA1N1kmz4oLrXnVdoMLtM1W3RpX5sB77Gy30i5vuSLttc+qna18+fz2rigjkk8xsJdpo/W4viLih/KsgZfwHMAK0j8go31yYMFQc0EesbJSL6Z+XC8Y4t6Y1KO6kC3YvoViA8Y5EFiR+pQzYmOUZNOq8FtodEqo7tfriD9jTj+7R+zIOK2n0GJ7ZqVrAkDEkgWpl425Vk8xxzm28MN9gJmLYI7fBNAPbUddSsgG29UgBV6IGsM48uGISPkIV5WbvSsOyz/iXXvRlf21eCW8LTqa6gXI175b4DoMQbV6PsSz8d5ugovn7f6X2M+Yps7+GaZ+aJQWxYzYwGHo+swlwUoS4Fnm0YAeEmWlCeGC2DzaFng+8/L1D/TbhPQ4TDwqLvofgci5knb5nFJl6CEmJDnNAF7SNLRPg0rhkxN7yIgcVD0gGoSknhZbInq94nIQ6hI3KW+1peswqGgt7a98iaPBltvVXbW4Ezl1bZss9U3iO58qGyvwZkttAoOW3rTSBbjcKP7pBSH+6TQGcw6dff7EdulvGp+dXX+zku3TClXFlZPn169ZNsURmMb0j8Po7hB53q7dANFtuEF36LOjDU2YcoWF5GBMSSqDPba2ofRVQ88oPS/qCjPEf7ip7O1lnK/FQSFQDukQRhY+q2IHKxcf13lAGC17jNKjSfztUz8kaDg+wVNK9BnR2zYIkj7gK6Y7FJvrm5U77Tq3dAfHnn4Eoj/4a13333rop/N+qVyMDUVzIv+yoq/d/y69ev+za7dVLNnX3mTvee9e+yDGwhZr3j+FdZVvz+o6ziK0XUsn0vyGKSZy/mlJJ3x68YhnaE8HkcPDt4LflTpRlJISjWazrA83K71oWKyf+UKCiDFbmHoJTbcEsIbavd0o4dKfbgdBN0Jor01N3fgE3Snhz1NRPd+2NMolpoTJl+IOzNHT4yxfR8Kxe6M/3fN32ie/CDb1SGL2CHX/9Zse+FUQJAWH6sM9njQYv/Kbf/YHltjNsZxXoFPzLOJ7snAK3VtiHhmXQDQEf6aP96Obzk4eUVANxde8euugGRdNif2ycaxhRD9QtA4ectM7/pqbNjZnHD69uKsLyBJ6r9530TgLVzBttEZmb+nVvZZivWKyML1Gqgvc7grRjtx0GUWGoRGqJubhc794AZVjVXl8H88rMBRRbdraklRx8+Nq0pJ1fYcV06dUluaXixUspraRmunVQUe7/XgaUU9Ae8qcqUiwzW1yf+52lJV31fVFhNvL36b+wLQokr3gfJA62lSdTak65cr0WBZ2fAAXNCkLjjJalrgTaEzb4dCntdsPqPMTtmWatuTMyTL2xr/WFgIwwKa0kKEAv1uzRDUtY+9RVMU7S1J+LE1VTC0L7PlasN5rGS/BQn6oE99OVdQvRkA2AEkEgAkhB7SjlYQqZN2k3y611hv9HI5ejg3Ev9HFu/lksNOfGRvUIWuqYggUUgpWnr0vieeuO+W5d7G0rvOr//RfWeXBzxp+9kq5FynjwcoXr6FPv3oUm/57H1/tH7+XUsbu5/1CDxIHcbbG8NH0Y96FmQQcy2PuijeGBQDbRdjBB9EyV7GUZPUm23mEguHbkSlFNpcux+dWFs78cq1tVey4+ZInB4HPpXJPhacx+iZ0HFzvaF8FiizDve2o6O+ni48HzR3dgeis+pBff0Hstx/TpZ/sAnP9OQXZHleXu+t7X4PsSmXXa+i9fXN4auIW+utw3vwdm9nDjPZC3nQ9oi1dtdLWhsgFqUWn/QEtH41FPbqXI4e+s+PnKBz7KT/FDu7mgXoHDvZkbfJXgMBXUeXuNZWyu0qdTmklG0E8g/WoY5oPTk+LPfWoJqbySFZXz2QjYTpltN0ZQrQlfm9dger2Gp0TXVjuI3izjroWp1uUNBqlsqETluxhbzt1Rfs5+xv2vTvDupYbdQyz2VqSlSowNjv/xOPBNd83nAQt2XbR+YpvVftLeaBjTJm/2KmVsugZkrlzcy8jaRa/0/orMCIHjzFdbhD3Br3LPd73B9wXx31eE+ah25uObDgNLe/DKcFhO6sVWYwnq2ZH6hdwKCZOTEx2lIwR0EdARnaagBcGk4kk8rAPpNYw4HrDyww5UFKAP2pjtBcwgP7ytDSQtW2YNvK3tnHNyImqaGBOmOtht+gS/TXadVj+0XO9nN2reU7Gc/1oqxHJ0x8fVG2BaQink4oCRB4vij7lfFAURwLseWB+qq9XkSuaaiiJmvAxnQDcJ4kgi6HBElVbDElmrbpIl63LYBykhTKROcFGUmCRlPQo0CTBQBc8/oh16TLo/tb9gUbxbXMWqa2att/m/c6iBXHN03brmWcHG9foD1/XsToBGjcSKYrcY7EppIu8apAjUAysGv5FbxkuqqIMK8pBEGpaJEFyZYk2zVBVbSkcsXORLGGBRWBcooxjSACWg7wWmFrzXQ33F+ifWrY77lk7ww9WSFWabeaPN2B/1no2/Im4GN5cVHur6P5/nNrHLd7vWCJ7spDd95J+ksz6LIUKIKnQ2gZsb2NgvpwETrfbL/wHN1697m/l5+Ln5MfRrnwhjCHYp3cQPT1i/JFGT7rzHVYLga5XFDMIaLrUNFsluK1bRk9ar/ZWbPR5fZxK9xl1A4+qg1FwBHJ4BsNfidg+P33ztG8bUPj2TH7g8HOjkm4fdxCG3Z/DTTqDfvicDvFtWGkN7LHIo2vra2zyOrq6m5MRKDcZ3a80ITBxkZ0awu62dEsSrY8YkpaRCgEYZshAR5mGx8VULL9EVOe6owjDiZO2NZIg8U918VqVs6CyIpRABE1dmzTHp+wJ8bh6LzczYmHVMd07ZiIg6VB/+PHf/eSm5+KLbp5+KFDgsL60yLU/whXg/Y7AjLNEqYQmUL1KboR6kK5TZ2cd/1UQRRKgz0ak90fo2TR6PamkGxHyKmVwSIVjNlSFYRXNE00xYpiKhU4ah/2yXkCH98kt95K/kNyMJOLH15B238ruiaK5dcRVSWvK4ui9jB9B77wKLxAfcSTY3KZ6ZVJfRLbX44iqM6ANdHvv1/29fkU/H/yZcr39Dz7O//yRWHjOymLTfcf6/y7Ob/3ZfJcfPnMdmToEt2fsUox/cCInjhvD34SYF8C8rugRcEDTeDig/MgudAoYJ8kfkds2gSt5KpBVDN0QVNDot+pk4kgJ6l34Iqj8XW0iHO5rK/s0U9IgojcKBs6xBRk+QviTL6QyoCQNHxCxhqXTZuSlLb0QNDdWJeApVph1g/GxJi32r4dgM5uP0bNcXxcVmxh1DfPAY2AIXMvGZkjU5Fk6ITBDRRDj84dWIgtwNm6mY64bBZkkd98u+FlVCozbOodev5ix5X3ZzIsTIYTqDN+nKllsz1bzXiG23/vwEe297ZQbQXBY77SCrbx8BrgqW3bMuW8zcFu3vTXU3rx4L+3vr61RdcFX7L+z9jhMrTgFWfAHObPn18dDO7+dyHv/jrzExi85wLHpft7fwOhxOJPG7RekdqdLiAAapAYG27ysm3yBzKwDyVYvSWBqJeo7O/SBUzsVgdEeVRAQEsQ/dSqS+gEDDzRXBYh+aGlt9lo0n15gLo8XQAKvCEk5Rr9QCcJ2Wpm30T18iwazN5An5Rm6fLQqICJBJ2xgNhcBHBJavUdPFRmK0jp2oo6dYmEoVEbTh13OwDKIKyz/CSoXdBkr6PDEo8VuhWgRHcXEOT0vv4LjH7vkiXBS83UsjZPxbIsYrodNcKagfWAF+jeBNQMA4EjEIuHM0HiRSUUiYAMOkUOmEQCTMK2HSR0NwqcjgWBAMKAEx6LSOKJJSgCJthAWJVMTUSCgCBNnJUcrCE6aS+pLo8MnlCmZ0qiUpewJqAA0hGxjrGJBEAMqhiJfAkTOw1n1L9H4WVXBFIgukQYcoyVOoLsMFw4aLAVtDyPJcpKAQXtyXwk6ST/AoUlvGgoGvaxVJIl1RB5X6Jri4HxBnzEhxpGCuO/vEaxKSSdBtylIwHrCk/ZMw+5A4yh05EGsWUduLYi8KIkuQJdGwzAR1IA9MiCKkiErjCEMhEgu4mQpiHkqJgHMksaIjIQKZBwCgPpJUNAGUib7vVg8nZOj7CkptspqBsUASuyk5FDaB+e7gUheHz7jXOAueheILv2dVSG/p502L/q3Kte8d5XoI2P3nDjuXM33jAcU3R/iMR2E+z4Dc6ioY9cbWA82ujRv8nO8XuPd+47ODd3cO7Dh+iVQ9rhaboCc/pwaY5e3rXfTcD2jex0qcYAY6O8AGMjMdiG9ZEV8+heXVWyt3ePTiNsaZ55+8IU6FS2LCMVC667sJSpaNDMX9J93r3p1EfYrx+gizK363eQOMbjIppVHiWeKgvUf7LLZpZgxALOowC/C4AKRi1wnfBkoypKtiJbpqzaWpVtkqLIQF0V+rqcQlPOhANdHn3ZsAC7qubXJdGZsGrZGeUhTUUPPYRU7aH7Rum9b/sXNgBPssEdRGxLkyJKdqMDtWMFsUlEOm7rg/lY9jswdN3fXklqSbrq6pJMf/RGOi1phChGNG5WoFyoVmo1Qlu0RUWR0AbclUyVF311EbrM5ZN35POSdO+tl9PuXwBJAbhUcuymGfLIUSRplBdST0y6m+8ktWJtr6WmEI2tBBhugAxAjaovdQbOKFsJ4YSKtSEce6/dqnuB48kfXF1cXF00W/aS4nied+/w+neHVwZ8OagNLjyxSN/46uCxpX8dXr9/eGWXTQtTFNItEY/ZUfnBDwZ12wNBRtiuGIljDdvePkbc+s8Zri78G8hLk+oPeDpWTIFyh8Lc+KIIGsrmFmrKlm47mgkjXCRI0uNpoQjiV6gtjlsWDFyQFLRtN9HlaJPud92lkJX+A0mYMRuyDYv83+C2e8z1jrptfDf/YAZTBmCIuQf5VWNvVul2lexeo9K+6xOemxVFa3zzrvaw3yY+2dTvZduvr8MWO7foDzOsoDZ8OtCD2605vsb6Dtviog1AiK0IaDZG2+vCPBB1nogaZZ7AGAX4BxYiAI/lFcW0LWBfXbY52c/lO+OLi+OLOTuNCe8Dt5VlxrjhSWBvlCtDTCQivI1TgzPXE3jbP7X8D6O/WbFFd0xmawcazGE18a7ttlhVljH157NQ3BGgu/bP6a6ri2ez5pj/xAFhaB+5hc3RFUEDoiuwQp84PjCFGuB+ULoB5UGL0sH00ufuzqkDp86s68amGa9ZVuw48Rr7jY/4PAvRzfKk3P8HUHNCNVZD2/66Wlavte3T8rj8Ndu+Rh1Tv04vjqnXgM703TE1sO0AzpAHp/+wswcB5Zd5Ors7nNVmW2oFDCO22SZADCl6zFWbzQHuxKi/ayXZS7oOcGGK/RBYu8P2/NqJLaH9qMO2qwFmC00pzci8c4PDyzN0C9/fAUkGMgOriDd4LEuyr4igbRs8oqKE3RL4BwnaONpURF7lcXBjF+k66t4Y0GVlotLs/zWiEyvQqBgC1t5YpntLyyrrOryMaccB2UJ/RAE6A2YxzDbVSHwRGFYe+gfsaLKcCxqCAF+qMdQSttKh59LgS/cgvLDef2Htm/afFQqTBUA28SvmP9Z7dhXF6+sX1taetO199Ppk4dfj+Kfm57u93jjVNOVdv6Uzum8tN1wuS+UVHl0+O/SJBR5RGYlXky34qRoB4Gv79846w99moxaj+kgcccnPisyycIuaodZosLkdQxkl6yqHaPC1wfEy5QXFzUIcgrfT3yG7jMZQvP3Oi9wgsmY+OPrjJcb2w0+4WfWyJJErt9N/+3aMG7Glvob5BjPvlW3fTWqyGP4E2cCN0A93u7OM/Lc67XDn2UudYdhC3c7IL54l7p6Qt2yJFFTZfjYzFscCABBZd/xiJuW6ElVgZT/IFipj49Ux07V0QRYkXZTpz3YAyILORSRNsZV0tVyv1uJSPgBxJ4Ggk0hArUC1MdUzU5VSnI4MQf8bibcVgK4Kn8+Xw0BXaE/Vo6BYqmqRJsIIqOVjP9RUnnckg5rmRdXXbIUHaQ6wQhdE1dY9zZUDCyChoUZB3rYcO13MFcrlTCo0AXgKxHMLuYJKt0rm9B9aazcB8nIJ+t0p7kbuDu7VdGaPyvVWs8wOMGap9Ad+ZA+ODJSzLdAJDYY/98F+swPAeTSMvdRzOzcp+dlbdXTetldt+yINVlep8eZa2TxsERq8Zzv2jnHZtAgN3rod+ylTHicWDW7djn3DlIl1mAb/ezv2HDMMsfRRzA6PJwlAcHA7tjDIich/vR27Z5DCYfNt2zEjyQiCV27HRnS5iO4/4Q2WDNSpG3Hiqg5cchl5bLlGNyJUE735igdTZTO9SJXKxbRZTj0Ytr773VZ4440MWaz2iulFUPkW08Xeav+vWnEruvHG3fvGyGyvi2GaUbdpJju/UBlaqQ/X1KOrBslieaJ42yLNefG24oS8eNUqaJdXvTFJeUaepiuhWtPy4uA3I/ltzNvk9tJ9TYbSwUJUNID4Zvy9O5iJDZk8sIQKyIxEXNQo9qIGM7pB+D2fvMciviQJdDe9BrDfnGJcdvYyQ8kB525gqlGlbPP+jDqpR1PPZdQpLYU27r+x18vvMQ2qivig3oGucWCse+/hw/d2xw4gdsGnesrcwf2Hbuz/aXdKX+g6ztKUPtdEI3SiyJCjSHBnf9luvYkHFgK0uXJ47K733nXX0T0Lh1c2/urEibtPnEDcyuGFPUfvgutjh1f65+m1u0+M2FpDrkpXN6LRXzmj9lXM7KtBE8BObQrTfT6jkQ190LPJD51RO+vMTJhDG+s6mZkheqKLoHm5vwWKQDywtWazWZSYW/+Y3e/tzPknvmwc4p0S2tykG9H1e8nKR5H57G6iC0yWOSDHyom9qwzfbrKXdb3TrpdJnSHNGvHp3o3ti2traxctK52Nryr1XGu1s29/+5R1qnRVa3l9je7wPF6rZwvu426tp7yjWPhZpVdzHy+cW97dJ3X2m4OtBMaGzTyiCxWa7aGjN0KPnAGl9wszE8Lf9honHzlz+yacnnkExV94b6P3t8LEyu1nHhnisC1Ib2aAJKcQqdQT62mDTvzSdQGV2tARxKebKuaZu/9/HJOUU7qsn1KkMYw13lUR0mX1JlXWEQJNXMN/5VYN+eJFRa+6WDJeJ8oiEnWTEFOHiCy+zpDwpfszFUftM916m9l+K8ziGzBVojnUH7pnpZUV6ewVoOtdsRMd2nC+d+kNFh3OVdHfLlI5l1m39jKLDo8po2w2pEt+W6wzXBCd/DBXJZm8GfwMK91Ee58l/fy7RclaOnniA0wIXz0S/rQK+rgiHbrqxBUSIC2kXnn9dWhZMvufQT3NkHI3MLn9EbbP3RqLv5NKOE/BhQJWPMwrYmmUPnRVFd01cOe3/wpoAP6ZdE12UPfZIihWhZ2lGHD3H1mZbpyjC1o7c7JCnepBktpk7pbHbpkjNsXvomsqm/8fa28CJ9dV3onWufu+37q1r11L79VVXVVqLa1yS5ZlLaYtWS3Zlu32gmxsMM1mjAN2E9sQbDDCgCHAQCdDAsEkCPKICWHpJPMSEgiYzSHJ780oyxCGkIzzMiQkYcrzfefeqq5uiYRf3pO6bt26y7n3bN/51v/nGBvIXWwYv5K/bTeSsd235fGEhDwk0cRZDNCeReQjRsBitvUhtmmYVchA0lVr12hmlT0kaOaZsUF+gmdk+ZekpMx+FZZsUZ/TXO4OR2O+0f8lCm/4W3JS/ohEJPbrvGIwt3GePgeLOPPNKwfQh5Rm/nWEjbWHal3xiVDhORytOIDFLn1m0MoTEc+1TUYI3weFITZ8ITKSeRV6FqlGVpK+QIih38BZSkYzuRuAKpIvTEnSS1OMbnvsZ3kZxL0pQlR6jln3k05giClH+boUwN2B9EWisUpa41TyxUkpIb2MpOFGi/0cr2jMGRCotWlCZFYlc0bgJH0Q2VOh72voC8ECJclDPx8PaUkVGC+xSoH3u4EQnw+heD1KWioUd5d2cIgXF0TcFzeA7A0GmPq1Tndj/ULKC0y2UmHNwPu9kf3+922zEGh80jJNK8lrgWZImsTzZH30OKcHBXN9ff2G+YaeBIbp1VUWvu/Y9utIvVJKJhQhVatcV6mlBCWh2ErcCOK7lwcnquMTcIZXE8lSCIlIcww8FLs38qUu0byc5Sqq6Sk7U6Pq1igtFdVyCkG8XBrmTwCGtD1gjmgSsxJFjKE6T+CT5uk59KeDAeDl+XhzP0OetBgmIEytiwL32D0c1+TYqbmzalFVtVs1EFzduJn2gZywPC+LipPTNM5jURzOs3AtbiWdEzm2yCO6YJUnxB5jElkpwTYYCiM2zlJ9IUM6SiofEFKxYbLUVlmuxbLd+ds0omol5SaN53kPxlfamxAEpVGezqFqkOVVjmPzXPgkVlZMRynC5GS0CidzZKGGij5ZbOAjYEGfoJZvNtLRoEx9LPZo7C2xt8Wein0YeKRyliBYB36htTigUM4oWoroESxGcAAI7YSoABGrHoYXbe3jr3bXj2SAMK5juEfzkoRJCkJjNQXTrFE/MqqdR9toAOe7gxHpjwzOUvkzEojZ1OdXkDkWagzrhM4egEMFSzLzicBQofVEQzRmJgUBm5yRVM9Kwqj0kjqc43lVkmTLl0SGMaxsolwvjJ+WMryAoinItGbm9Dgyp4cFScAMMowmSoqmohb7PKLPwYflZMH4lCMQhWPDI405i6BpPB3opsRxqssKnKaqKRWWMELM/fuJJDtmztJ0BYi2pLp2Ou95qkKuAAYChgHPmp+icnUDft935MgDN9xwH6PImi7JbAcEGFkxbFnlSGzoQ4F9144tgJxwJUatj12mdRfJzrZt7egUzIWMCbW6fgjqHwxiwnwM9WpaIy0kp2QEZozapw4kARsaxCFszA+GDQbNJScUSdRZieX0z1WTRQfr2KN11NRfNbiohr1Bc2gqNsftR45864b7llhZSsjqb0IzKrD8MycYftt6f2S7PSbkb+eB7Yj4Ghq5LkTh+JGrBXUhqQ0voPx/GGe0ZcwBdt7JMSQrpRzDElWG8518fW5qbh/KnBwrzawcWVw+0HHygsbyTJAYtf2AlOBYrMI+YPrJomfIqZLiJK9sVmf3T6UcQWAMECPdA+3Tx+cPrFjavGJywgivuBTVCCFR9pPtb96dp7Np9M27i8zgfDyP63YQQSU8fFMp5/CWWescWF48sjIjsyxheHPf3FSznnfiHKOKluEkOYYkgdXfe4TWQC5Yi5mVA/PHT7cPuJwCryoITmpq/2y1eWXSUUop2fCKSRkW/rucRDp978Gbttnh/dgKxgq7XlCCdbSEVqkSzT2K2H6VkAVCAYv6K4bgWgHaLqnOepFFRNBuJzRbdbp7gOo2O61Q6PcwScD8VuRns9ZE+zRJVXlN5WdyUrpEHjNNVjZdk1U0xT0SVxCdnCPycaAGosiy8MuI87PF1IS7chxdTTTXsSQmbpqwuuqmaeSIsjsD072WsQymMKm29lWbrYrsGS7heckjnpIulWcJT2TgkaZKGVkhPkZncpnduZbKzTCCZblE+FRlvlXJZiut+UoxwjvcpL5iwIBXAnGYBq0assM/2U2BaruHfgrIQ5NdUg/ZPIO79bMPx8eSA68AI+GPuAz4GnAeUob6DCTH4pvSdZxB1UcP39ScmZqCi0zd8hPGqF+BoVnYCFDE1NRM86aIr0eZMgf9GQ4w6sfoh95Kc8jyIDrcImmvj2XSFeKbRLEUdE6GL2JByc1rrmm6VZGI7O+rFsLhW99g4VfFu7wttmu37HJ7yx672tvoraMxFs2wq6sbGxcvRrbl2Aa8lwmjLUltR0P9tU31cNTXvDTwRnkITUPFdD29mMvlLctaC8YxK8MELKmY6LPZNNBFhQpsW+MY+YouRjd1MakcxQj1qf9VaJivovo3SpC9dVIQcdTiKXLm+Z87/To258ZzuXiDc9x0qlJwdMMheQ8PeTnmdacLG/9TeOR6zSugV+f0m9OOW01Zlu46xpucDB4reM6ZhwRC3Y0i+h6j73Zj7JbY7bE70ZsTQUlCgyx1KAvi/kABuSOSOsqOhBEkaPHBNaDc3jqOdqJumJMhulpozpcw6XYcPtbzBsuIym5RVRjJyE5kE7IiJvMySPUsZr3XOBGEU4klJvwwGJZXamjGxVPPD3Im/tVZSyVC0U7VDbeU0AQiWY6fzfokbYqqbiiWnzQTEqs4KDnYwN7CXk77L4Ql6DsDR2WGfasIK0BBduNEoNfdDAWvFkbaZi52Rex07LbYGowKg4maBBoF5K75QQjpfBiWOEA3aQ64iFqTsnm1shCpKcNkTqXZQbaSbivuxyNQfXSjozneqgN69BFJlDVemeY548Qqx09LgipKoic4Rl4SE59KiFLecIQ9tQxC5CiflBkS59jMfRyv8MFSXFB4hmq5f56BDmcJJxFUjNPNz7Ocod5syRyj82hMho3OcJJ9swpLp8ip5lhrJZNMZk43x0yVczJCYnxpfGaxnhCY1O22ZsIDoHxTjKsTLqspfj0lSSlYxbqwbjPUmY8h27CCixEnjXbTUEMNQyNUwwZinsQ6iHNOfs1j2Kzfy6jKH+q1jPE1i08109WEt6B0+78VV+EfOe4lxrK+qYnKHxuZmv47lrF3Pssy3q5dSv+7cczFMKKnkWO92P00LpaaKDpNFNd9XJnRXwJNboiVJkSIySCthjCONDUmrOmw+MH1i4SP1s5qGXkZdM5Blwgspg3jm16C/RzeJJRDlgcuI6dlt/LSiivPnv8D+4ravkmF1Q1rzGIZwYdF0mTiCEbJaoYKCwcLkiwDXEzgUgO9gPC9R/B8HC7kkj4egHsNnVUm99WusEnIzIPY5gaK6qHYy2rAwhsauSLhVipuYv+LSlPMn7MtSTQtp+CwxLMmZ9nA8DCMsyixgs4ogafCvZgoG1jSl8OpgJ2dtDzCwg2WKUot9s+ZqRIDKzpcAs0MVwcKowusVCxwwoC+/Tb5BdjTKR6OWAMOQ8B4v0USkEAkb/iXG//13TJRpm+cVlJy/72nXkPYf73xX1Q5RQ8Ruf/5U4XYMIdt6E/YpvxmjIygG4ktGpOElGlInbfIDTCWi0wLNwNVCTOQ63uNXgOZQSvudxxLM6vz1UIBN6rFKzpbkASe/dkRkwhZw+sbjQ2+NOk46I3hBOjDOuZ+wx0LdzZ4zGTBiLzg/W6YEuvJ0IqIWCcWEyNrMTdWib079rHYb8e+Gfsu0P0s4yFdDe1qnaDZxXjJeKsT+JE71j6m4tFoLyAtVbEE4wgXAIqyia67cKhGTf8RhgX8L1VLwgBTCTMfkQysLMEis82wkWOCbrUzBFvAW0JojAqmj0T3PfStGcCRUbs4lVVzzG5YiBHWcxEHOPX8CRNw0eyw7WroWpUnzU4TyD+w8f8bvVXESYUUPJ3tA2+oewWiTIrIJf1vGED4W0wJts4xy51rGU63haSI18LYE9gASDzIJ4zAByCAsgkJBCqZSApv2txUozE3O8XZJq9IBA6CSMsrAS8w6HlrBqzQX9FZRm98v6EzbEo36q1rWnVDC1Q7X0/BsAWWEyRVjufyCNnwt7otG1q2vFTOaoZs6/4vvh9WkAQP53w+j+iVlrEgIRUjDkIXwtQiioJirWQxrC2y5JzTAFaXHsJXxtegFwFT33C6Mg+XCcAdgmwuiBx1YsZILsKmEnJKQIQNnggpGf3hPLRMigJw9qzAKBYv35oBkQRahJd2ySIKaqL4fsaSNcZSZSyJxeS61zC+YqLkz/Gm4jPs2TSjcToHryFQSyfNizkS81yKtWIHY1fFjsZeDRJ4rAKzqdhuBd1taV7LoxlgWcTUGU372r0k42uthc6ttRByitrngCgOFHt+CVMB5HEpxNGEa2I5vAilixpixcAZfBg5bPV/dEPjle2txLFkK4ns2e70343kjv3AaNrYzvTvTkwUrLplwULIJmQR2pVJpTVG1iwHsw0oAmexhQ6ctnPoyAUdyiSrPCvYSUM+jy6b/+vSfLNC/y2Fv5vubiWcvWpbttn/awJuu1FME2KD6KnZcI2ajsctxtBsgYUhaUjCeEkzJI4RbcG2cqYVN0d1kYhDFWtXWAxXcfmgK5LNtbVl64vL/S+c3Fy/8Hy/B8LereTAr+bfd2FAX1+A+x6JnY/9Z1xFQ59GL+4ZjCiES1SxU5thKKMV4iC1gMlHVnI/cv+BCCQB0zMhAgNQAyTOQSdcq6j3XZeiVc2wVGO3n8xQZ0CDg7uoVZT2/CyJ85gmEdZpIAGdoBOn5cTDBBhIFsg/GVpcy8kw72UHxBsFeASu/7wZBy4PKKWr5+2CJM0I6CcmWRyfMK0aECyclyDt88CtGBnoZYaxBTUOTBmw+AJjCpIcCAkgAbIcsOi1QZjpOQZdQgTOrDszacMxMxLHjfX/QlAZpqjyuRwROlyeYTRRFC0zk7RklyfHM3t8zYaZ6que4SsODhpXMByQr4BbgrdzFUXiYZqybJyrKKZDOMMCYsIJU4xc8GQbmSqG02RFxrVZ4HjdkjRWlTRBL8GyNgFLupq9wmOkuBtHGH7CJg2Rk5KYDFR8BOnPHp51pjN5VRRtKyMKDMdVM7kyy+SMKO/Bn5MH6fi4JfZGEAG6wFOcAzkJ4TrmoUyDHVixYSnArkdGJQwMrs3DagarHwLRd6qdash146Y2P7CSBJ4QRthTnUycaiw60K3Y7aLgUSUnzeHhgyTRosMC+Rka9IuKWxxAEVdb3RID4AmlGQZxK3O4MIQ6a1QOUfw+zDwrCnnEv8SyfBhT1FIfp+8PNcDHwHt3m2IIHDCLTmbx0LyP+jh0Iq12YZSyyLF1YPRGKx8MPgr+wfrNDlKVeBfIUBOaxsWVCoUm2DdYJG1QMKyzONKhRT7PMTzzqwF0oaCQvGJrcVVjy1OCokF3Jy2mKKno8olujbAM6KKMPkRAODAHLRNwCsPk00amDOSelyoInAREAak0+RYjKAqsCbpgo4bAtWGYiCCdMWJNlR/lBV5jxUCGKqJtQ0pzAg9SK9pVOA0VUwQYe1aSdEbATCkkrsGiIzLogcpavCRx6JEpAf2XBZEw1pgHLDxDZJU4CmYI4xlHsInOEJNJIYYZ8iaEURkWyCbMqECWFDaIu0SHZpcY0ZNTngALDiEaTEbCnKPKYYbvoucp+2ZPlhmJ5fE8i4EvCq9Cn0g8jnsoOaswJXIjTkWm/6e6zIowJ20JWFQNJhzhZehZBdtE1RwQyDgRHQ4JD/UQXFYpiGmFSYpORSrKqVI9y2bjutlQgL2C+sNsi6uHHds0OVczWNngLAZfxRcwsSkUyeiErKQlEdoIHgPcQcnJi0JuApdolpOzSUPhVMNRbYOFxZc1eVGyRFgGOBkmK4/Yoga0pWRaAsdCWzOKTgR0CvMwxxwlRBjnA0stwwnQfNAFaGEOiMiBMMpaukn8HC+oOhCf8bzOmbbjimkDhC8OliT0z2BUxceMxjC20AkWVmIRZm1/U5Ylgj5HsF7DaQ6uE/kEJylCwMhlGYgcScRi22MAK1uMb4v0Hp94HP6exs3jI7lT3VgqRD0YAVdEz8FiM2C7VD9bK9aK5Ckl7fY/56aVomKRuKX80kPXnr22QPbF+39Dzipu/7+h1oIUXaWm6/0vPDQz84vBIF+VT1bIPeitVPGLCNkB/PxK/8evzT39dP7+b0/cD9+5+7djhbARigtq1lsUKmAE+HEPwfq4mCOrsdprJKxEwuo/i9tEY+Nw/9kLq6vPFuDQ83gIpNZEodD/0re+NZrvJkPjz6OE1UMTMNplQvsKuUfWNPk939Lko7Kmc/Js46ZZ0ai9hv7+1nvw5PiYJs/e1JiVOW17DBVLvWKojau788W7rWAgUfzCg6+jL34et2cK64Unzi4tnV16yYMP/tOOd//OEp4ZxjSGeatzQ69aMcpk0+LD334N1en7CDkjir91wwILK+cTkrRww8/WPp0k69Jz8vXXC+xz0n4Z92qpj4TtggliT1HMidCfk4YbkYnXvjY3+CPdkR8jfYU5ewMaHRIUMUdJk9nCG+yW40SdXlT668ridOnE6r3Hj997/MWLTfUz6r3G7mp1t+GR6nE8+r5yJhMb5LSN5G4st4QYDt1h2dVtZQcUzbuFaexrFM47Uk93KeLr14rTcv9P5elidvHIyv79K/uvbdbld8lfT5VM3ffz2QPer+rNwsLk/v2TJhBc1UjW5buUPeXyHsV6fvHM4uKZN2Tj8bvruhZIlnfsM3syc3CUt2QuE4/0pxdpDGwyio0JOzqCMYiL5QCnD3m41tkz3v9x89DitHvVZOfERw/eccfB3l8zC/XxPYeaMwf5ytSVd95xx7HB3EWdrI1e24MMqMUoodunJz9tp1J2/yncktVGyv4s7n3fTtF5xgCP9y5Y+1E/GA/xddAoPN+uVRdJPM90oh3SbIXybhBHLSmsaSYRcL9D3pFOrOamu+M9jezmlLjHlQiJM3rcY5LAqsZtkGcCxlFVoGEsb9gTiV9LJ+50So0KrhWfV+OSqp6Bhe4XVI8z1Mc+iYl+P8Gxb4brGVf9eB6ksInEtthcM+ahl94WpmsR3osXizWRrENNn6M1nbBT/R8eIROrRyYHv1P2p1fXV3fG2uURw2Loud3yy+iDWkb/U6CBMHyAbABfF82/L1J/fWIWi+LqgYkDq+Jg5x9ff/r0608Ti3rua6Nn6M7fnsbzI1gTqO+9BJuWbyMSO3n3SIe9GFNDrcHPf6Q/FTt14+RrXjP5mlGfbhXjobf5QbQ8IaxDu4UKic/tGh/fNT5fW16YWViuHb7t8Ho9+1S2jpvy7tPSiRPS6d3NpaXYCH1HzKk4vKFB8gR4/Bbte0Q3bc2z3RrZkERC+g8I7l37VvYd7s184Gff/nZSv+UD+dzqdyb37Zu8ZgZI0PdPXRfR8qdJL/btYb7J3tMTE6P9iZ4naEuohUJEZA4Sg9JAjeLcW3yZWG/vOXly956TJfH9J3bvPrHw9nuL99pC6eR91123p13nF/DgMNchpXdAFeba06TNk4n+c2Tj3ZOT794MMQ2eJx+COu6JHcDnhmZy1I5OUleWGuUGMbhgfmhK71CfDdS/Bd3Qso6GnsGoIPfOCtwkJ3WSqsTIp4BzMP2OxE3y4jQhM9tPiabflnh66ouLU1OLk0+XBOkqYDVsritJXcH0OfkqmS+xhmSwP+kUZ+6eWJyYWIzFRuPxJYoDUBJEEMfI+saLXlIff+ZL7zwzv/D11KlBu7yL0shYV+zW9iMuYfCHbyje+46FhXfcWzx69IlV7U1v0lafiPRhoV+yHdklYB50Rz3ZgoEjGwtnPtpYr6OtcPmKdr54/5kzrz9zhll/28MPv6V9xTKaH+u5Yv/bePT1Z8i5RmNr7dugPqFZpNcDTFeQF8TaAEuXuojh4KuGAecUZp2eiYenvlhKJkvJj5Qz3vjcwblxL1O++q6rv/nxBxZm/er0rY/dOl31Zxf+LFFKJEp2ccEeCxqIENMIxuyFYuvqq9//ulO7bs6M+cemD95668Hpo/GxzM27Tm1fm+OxcYzhh7430M2QWrUo5kw34L2gG7IC+K40AjCguCAU5jFUcYhxcmZ2IeF1aruzzYnjwVW5q3vnds/MHA/637XSfC4uSaQVZCvtGyptq8nyipKLG0omIKX8lSlvNu7F4R7/+KEDwTXBr6QTadmM5xWVZ5t2Z71TySRaRBTjeSFt4zuTCJMKM4PfHvoyR6hpYT5w9Ay0a/bQfZmPEgq1qHebL5QFqm7rRjgnvhCWYJL20PcBXb7aI+7L5DwwrYKmGHFPFogoL2dm9/uqovFy/w8UZOR5WTFFVh3PxCenPcy3wgqKIzkvXyRP8IJlaE+fHVcEjl6n27dOx6VgusTLhir9MK46iioI8sMMRt2y/W+lyDnOcDVR0VTnt0DSZWieSk6b4IghKujNwCGSamXWY2BfErk9jZyBuNWY5LIwZzAEZBNejnAaYkehrdoxJTYJ4+8QZlqKDXi7VjMccAhpQhUbQ8qUp/ExrS5i5fuhZxwferx20QlnEWZVNSgJZcwFj0JkLcwvRS76lhmHz9Tu+njmAJP13Az3X1QTM886sKcb0FSTh7x0pppO989Z8bjFs5Yqc3yguso/E4GxNIXnAk2RlQScjb2Qw9LihfFMdrzhpRP2NWJ+Ih84L5LIYsZJu146XU/J8UIcJI1AVRVO9NaIwCU0KIZnPTgxGtuK/pNVyjUJPmp1AzSPCrwnztdQ/kbbfaUqdppBqHylUZ6YASkK3bmlOX2cDWY0rUoWpptOTVEnWuzx/v8Yz+96Yld2Uk+LUuqNky6z9IdLxJ3y5k1r4UtXH9p35NwBIpV0vXjgyL5DV6dmFKXpkANXu3KtJoFgKQjx35/fxR85wnc6yVlVrVwiG8B6QvOXdAkXSgZPDyUDaWSNR4yAJM3wMo5IBTt8LOJuUO7wZaRuNeqcKrZEaIOg1hKgcOj4UUeKtcSud6aJf+5wcdfcNZa4909g7ztw6CL9td1xYo2srCx+8I0TXfvxGx5k1nHnIyuLHOxv86e1KSpkyECL7SBMY042P3vXrpWVXXd99rdetndlZe/LLvaUjxUuXCh8TOmJH8Ed4MHVIZ02aORPITYVm47til0ZuyF2Z+zViJs4MFjQsC4M7qYGKcQIA54uXqMkfZbMoZZEnKMaFuowH0Q+9AKSAtdDHdAM111kEQY8cuagecQwhJfUMBeOwXzNJG7KJSanGZXTMPt8gTBzvCH3COsu6pqwgBiIf7tbULW9AkMmJUnk5wjjlGyW+aumNJXICIzkglzP1idzXPIqb2/KNguaxpd05RsKQwokbfIBZ+m3Xg98pOMYPHNWd8uCL4H0zy5JhjDLdXXiCBLjcLzEmA4jig5hGImXgBRIS4S1Sw4qWOZLfNop+4SzvLIXNMc62V0f7aUcVxC4IJXfL/jypM1l1IDDhGwyrq9AJ1Zp/oMbYudid8fujT0Ye3Ps8TCDQrc63y0DpfChaUYM1ajbLrdzpBUPWvOUqKJYPJp5JVRxt/zQflsegC77rXYTLVht6LYy9BfwXohoUoBPLfISM5kSQp7jKuTjIiiCWMvE+rHfLhZvraa8zJ9yBP2YgKgKFN0XgS05VpM41mEwfJYFasvyrIBnaeSrx3GCJAqMA6RZ+lyqemux+IpM/9U9Eut9gqMxvBIa/IQxIjG89H1sjhdiheqrq6nqcsbbwytQGMOhlhvIBsPJ2OIMg6gjLM+jlYtHBDpCyqguEeAhFEQFzwvsMhTy6qqXsdBryocLBCyIg4ImGS5F4KX/H8xizQ3xFlmQxA+hVRxbvxK6fzEjAN/U504E1ncLB3hguKKwMeVBGhPqPNCu/dRXYhOTZzmhPXZOFM+NtQWOY3fVv1HfxXJn264z6dqGCsRVFFQETa147rylBmgKN9X0JwcXqNzggqo7egHm3NicGutAoUJnbMpYCveWDK4O0g2na36QySbiqs7xvjdBTCenOhndypJ/53xsh0/TNM1o1gydHkU/yvy9n+0gFqxgskJploL97Gc6rUCM1B2zpB3lB88z5Nd5yfgEA1NMZz/OMIrEMcwzjGAIzDO4+2lVsGd0Cbr7E4bEw4h4miRE/hldJmcJEfnfNCTmekLmWAGNc7eiwWmVF3FAnuD5i5Lxm7zInCWy/gwPEsb122KwpyKUyLlBZwlBFR2tuvjqiOI8S5pU0Yyo8F0yHqTmTuWsQLF4yb6SiaeKIjDO8FxtjojqVedUlteYb9QmZ8cPi4qZyBQyEye5dCMzpiUSWjqruYf3Ela78yrHjifTGSo3hH4ZFmqCutVOV8ixPrIHM0yA7mqhtUIg0upVolEoJsgtBbU0WTrhKcq4ryj19eMfbNcXJ8b314+fNPIHiVdXlLEpur3UZzyKehHQeEt7CIfmwA8ffdvYgl+GF63OV9+tvu+td9/91rvJxmxRU9h6aqpYSUvcSTuRsE+XfkNXi9dmq9lsdXS9F+EpzdFcZyELGKWUDD3T+PCbMkBRfhycBp3B+ZFbwhXyKk6QedETEYrZUKxsylFIAxqdlXl9b6W6V0NFpSlax2ZnjhSjC/Ste6LF8wYW00Wysh4E2kFDZKRULpeUgZkq1Wtn6VGFXrFNhsjGJjDqtYuQvzXq4hEI0Dcincw0VsKjjK6IdolqN96Kd9ENnnrP0HziQLmhLp/mmJ8vlXIn86wwLqtKUoRxqQPdu1HO3mVz6CQ984ZS6aA1KZgpJIk2LG250xsnE4r/ofKLy3kmF09wSUUUUTUPLK+ksdou13upIyaFyduJ/GG46JCxV7RNMSWIHqel3cLQ/wDX8TEY5fM0l32kloI//zJOBzQHaGenw8EwoKAXOgsoNy0VBj4HcSNo9BT3q6PuBmGg5EW85MirBh4GkatBzi2k2oWNUR+Dewfxyls+SkwsEcvBeD2EntU0WW3o0BySFWrS7bJoSPIR+51FBzT0mPQFkXpJUvcjTNxZK80jauh8p7tO+NcCRWyLYqrcPgos/t7X790H3CuMI0XszR8GEsMUgW+wC6LCtIpoGz3SJhu/QC7sLnIs0a+YvUCCoP8/OZAziISbTzC9mQA60uCVFcs6JQH3QAgXzFxBYpdv+5AybrV6bcTZIxh0wljU9k7U5oNvsl5Yp40ebldX8av/1ZE4mCfDxl8dc2/qtQet3u7dNNxtNMLDwmjjk5mw9bfmsBkrxhpb1JxG5VIiHUKhlUSgHSGCXEBlZnSL28M0EYRu+2lyYqbXm/kr3BQ1KXAY2EjaAyA0a5Lve3dqUgKPJSSNbCzN/tfZJbr5s3OS7jEvJphn/nzWTibtrKQ57xw5SuXRAnmB6iYyGMvXjfIjVgeLbDyg44UuvXw8QoGjwQoCJlELzYZhxls6Vzuri4cP7Zpc6J0VCWfkcIdTCSep+/efItz1klA9+a6XPCaJlXKV0SpxgfCMnd13y9JiZ4zuJ/jfqOZzVvn0IwKfS5ZP71fyGYEnnJMem+6m7d7Mnak4z+usK4HEZXuTE1nbxD3bGNUJFCI/z9hchLSDxhLs9/VNONm/uL4+igOIecfLsd2RLzQOom0TeucA4rfOooswog4irM0QS2LgQ1RojgQ7k/1FOJZX9drqaq+Qnw4PruNw+tRgXOFO/5fDwWTQrz91qniq4nwgrmoIYMjkM/P/MBxnEW1FLMQCyMgxFxmiMJ1hJUr4NUnaLuK+UUzeZpFi8iIMkddojCUPHNTIfLLc0A8sN8rJgwe1/lcOHkiONcjBgwfhcHis0f/8ATg4NwfXH9AuwWDE7DzoSgvDuru1u764tLGaK10Mv8j60uILMNRKud5gZ4DRgbFtHPDwGItZiNUxK6oIizSMrlq3heBiLWFHoqOBGopYy73K4stOLlZ6nz/QTqfby+27jx69++gZCtCx50irdaRFNlbfNCt88pPC7JtW19Y2j+IFIR7HegsviF2CB4lxuiP65p1ZlqjayCS1ciUowxt23k8fUx55sD655JqlRmOVTJ9cbdSnC+R++qgbRx7eaXJH7l5+8snlM7fpO9b8FlLq4ZpPfTFCvQ7VA8FP9OcohVBIuLpThUfIE8yQUFU0SOUQrvmv4CVZEWSBVYxkU+YtVpS+rMuMObt71mRkneck3m34JUHgJa5h8XIzYcLyLQuKLPGsJERr/hs1lhV44Pt12XQyJnCN7AlZ50zPMzm09CY1QRSv5cyMY8JhdNpgWU1kmdign7F9sX+nYt3YqdhNVHNtMqHDyjA8Oc+g18h+Nh4b9vV8CWlPF2VfH7PYDaF+a/tJqxuBRCHUTbcz6CNyStidThXyrmRzHJ9zgmIxcE2O4WXO4av2+Uz/t+O2HbffVSgUz2hB5k2szT+NFzl5Xne1RBZt3hzhXRCTYB0yJXo1OWaulMcKek4fU1UvBZMZ6slbYkXZE2wm+6+jUZFvK8j3Z/ckP8UFhH8ZXJLyxnOODSIAIxO5IllYnr5KL6Xj7i/IIh3/SYprfg22CiO6TdoquFzQiDJqegg6VDno2x6VnnBZQDtPV2yGV8LagebOMMMx3oe2QzLD60An5zSisWkpf5hlX6Xaph//W16M/64vCalrQBZcdBVuN6uRUwojMfJRSepxIhEEVlpUxA5RSSZxaJwlxoLYst9SZh/VRWjh15vJXiBLXv+Pq/nrCaN6L7NboqhOybqgS9yYI0v7Cflrlco1YR3jQGP34UqIDh4UB32rbu4i0xWH9YuqR4NPqtGSib9Jck7jfJswvGMMa/I9YvtcCwb+FwWZOSTJRk9jZUIk4YSkOKs6QzYW7Jed4GVN33rz/v/Ln3iZLcEIF/rfYZjrFFVjpjngWCXd1gZrSIzm4+wgB/7TZuP8N5NxfrFy2QScxdLC3cWDnHS5/Jv35iuYeFPRdiTeVJSfmHgzmd89sg4WaM7NXYjV+B/IuHnZhJuYZPPoFbv2TGR3DZJs7n50R5LNXNJRoxybqWQFc2yOJNe0eUP/N5JrpjvbcmtuxxYOs9/tgl/2duOiELF6XYr6H04FBL4tx4cRFN0yVoCsZ7z+RQRAJwUv8yFqLFy2MHjOMs15rlCcnVni24pIlvv/zc1kXFKEa6+jNsP99KrnrQu6O1soLs2Y9gVR3v5+6CMwjnE36CVQAzaaBl1TfP0QRzcY4KvSrBqYTEPs4OIsYm1oli/a+msbH/LFU4blkoKbuU704a2+KvFVINCsUBVYbrmwbOhYD8O8tlCcmV3bgBtSa75uZLy1lF/karwk8TUePVd+ozB73rEMw3TPw2vHhvS4R3XKAVDkbuwNsW/BKO/6W+qVoD2iBYtictHGQBeWYYBe6HA1PI8WzVIorrWoe2g7ysk09EqGukbsYpkWgNkRqNvZVo64WnmWaYfXtIZp49plfwTbJTw7l2NagT+8K+JCEfyvHT7tDW480F0VlrgAljVJ1JUnTV4wNFdUHE9xbIFTZIMNBMnQ5athVMbTger0mFTOj6fIlYZh2OlkQZV5TtP8IBCsXiLj+ZpKruR9U+QsxWUt2wIqo0qSAO0r2oTzdVlxlLhU5TjVdhOWqBcMQwgcV1ZYVuIdLQlUh9UkLdBtmePGOEG37aypGgVTdJOeQ65nHxYk1Uq7mIH23Fme4RXJ9BX5ZjNtqboqo6vwO3hWEK+WVTjME/Ee1OYJB20tF8R1i2eYclkQLauZ81Jw/n5B8HTF0qw0zHAD7i4Wob5m3EsVDIm5myDeEa+oqn7aTepxVVZkVO0J7FsQEkvPGZKPiZ0Ik8+jF7Omm1ZC1WRN1EB+BgH6PQQ4Bd0WHF9NqDq6ZRdB3uMETR3qtHCcXRlbRvSiyv8PI6U2MjC3j0Oy5z/eh89EA+RtI0PiHf9fm/RFW933ge29FdLnEEdepNJHbADIOYrkNORnpijKQAOxBzdxE9Kt5ym6wEspW3n02RCRkBuWq1J/JeBkCYV7QX4Bptho6QPYiAE73dtEoDS6GT7Jo0++NnSqKFDedVchfOIyffze8Llb+ssJihuEEnrU016OBYGk2Ebcv8FsxXSGe9i42OKj9OaYw7WMcbLAcWzG4+PliSAgqjOe0V+I6TdKQTBVHI97zPLbCXmCYa7tvyrVSpuEaTHkHptpEdZMt8n1x6enc0klISJapq4WCjNjYkJN5KYnuqrfy5Zf1U7OrUjO7NjYLG9zK3Opoc8K2pAl9KZwA2Dt/Vq7xgdoT2Fr3eDixbOPbBQK5JzCTo7PqOrM+CQrv5msv3zvqXO/Z33ZXz7B5HPAEY7l8syJM7HIX/dy+cti+0mAqRBElMfQJIY+cy58apifu9FoPH+hceFC4YnpYOafp+PTfzkTTBu9Z+H4eThO1ns9CY4egE//7+GS+1HlHuWURH8QHEdbXjIj0DIPfPwB+CN7ViZWVibIefrzHtxfWQlln++Tj5On6Lti5pAcjdNBEacb4Fu2R3yz2uFw/Hjmtswf3Zq5df2U9eI9G694xcYrHg4dBw4UTxQLJ4snH355M73voVNrH1xb++BfnV7cd+bMA7FR35UoAnMo5USxk+Gbfg9qHL3mF+r1MyipRzYe6v+4MydcORazsT1pTqSWX4uiObstHwVeelyEz3J9+UvLy7CtLy/fj5tlEB+Xn4dv+An/vhTuwN92+6VrU+tlYG+GZktyT//H9+dh77WE29H+ykiNuuWwMs+ubkZ1eWp1YBtdJ6ETQMwuigR/rV9STiySPcWgTTai20l8UOIgvwXc28M7Xbu2DrsvQEE7yuEiCVbs1kiV3v786qpFC1RWV3eWYwcilrP+k98nqInR+8Dt0Qs9jwVtq1e7G6zjv5224G7Zpm6itc3IBuwPjMJR/O/fhPmKMBeDMOItJUQai3iTwkWGejIYjV8uXHnbweahVn4mV9AcHb7gB+n9zdzBg3P/WG42y/8Yz+eCL38Z/TrpLj04or8I44Br7aKPOVWBRLGtbvHpp8n60/e8ELvn6OZk//tPf2xy8mMP1+uEndjKxbw5xEmbiDURkSc20BTs0BbMIg5QuU3hQKh1t+VzOy4hCxnPy7jmsW732K4DnWq1UzNzk7XCPlc+DEurWtrT/+Nju3Yd6y51arVOlexz8fp378Lr76zisQ9OTxfWVqp6Rr5StvYWKiOnUL/3wvfIF8l7YyVo2T1Y22qIkhS6rVJnRFxXTRJlghDKrt8N2ixwV/gL/iapqBlvzrdYjlGrKbtnrVo9O1VVGY5tkdlabWa2Wm1Mrq9PivEF3x9r1m+oN8f8eNuyamfLj0uywOm32al2O2XfpoOcJT4+OTkxQfzrxsev6z8v+mMp308VLCs98IEqUN0SoqX5dk1EHv9HVuL8+YRF1hNW/6O9HjljJUborBXzYolYJsoOBr1BhTWKD0KDUDDEPQ9UDV3Y4qGCj/rezfPwXcQcj9LyrobVs+KpoxNP56q5/r9Uc9X1u4711rNlstrrb/ZIfFd9V1pxrrrKUbSpdP13er0OXFiFv/ix+SOVO++095Tn8xMTExNbMsEqlSFnabaDGAzdRaaZwzBhkID9gTa4PNybYeM70Jy68HLpNiy57TQv6Kwm+7L+MR22GqsL/BJVIX6DbmHyr34lXcbkEuX0VwQVuMwaDvt4HLc1VuFVeQR68SV33/2T1w6EfK2JiBsXRGvHrqNHs4O/iJz9wsihYXw9+rgloyxtMRIMa1Yc7lHJnttRzVqxViYnp+FtZe2FGP2aFhLfT/T/HvUk7v+m2++TicL3ydH7NrBCqorbjfv8iyOVuv5UuMb8A9TpbVAntBYMfdbYVoBOqB5VliD/SJWk1JmiVo5FF70EndCSywddMi/pzFE1+X6f4f/uH7wknz8yQdroyJY4lMAvcsuEJgncG+MFYPbqcU+TWu/p/yU9NeKPbl7qQUpOUd/R0AV2mzPsCF1isT9I0S7al9zdfy50lI3uw9+ntpUyqp/lKZIvOqvUeKoD3nJZ98v2S5aeyX17lSiTg/u//e3/QQ9tfOxjg+Im+89t8+u9jE+sS4fLaL3u3sz94rHcDlffb8PB47nYtjWTp5hw4fu1ho6LYghQ2Oz8TO/Xs8/eRBITOOJW6tVCPHHlrbc+duv3ep+C48oKjk2rIMCRW7fjEiLGd+WSN91DY1aDCRKOPNemYRT26Juf5stTZb7taJqjPVy/WKeOvb9H67DbTvnptA/rjO70P0x6hw/3N7fPodTIHMKRPUlCmIYQbjGaSjMIyKDOlTLTIpusVlLRdPqV3FSu3Cinq83KNh/0xOV90MMm3+mC/utvy718KrfdBf334Nh0bluZ1cuWGYSv3B5950uewCXL5WSuN1PdrRgIa7H9Wd8sN8vKTG+6DDLB0O81fOblnnhJ6dtLG8mvG/bnNHq/uVF+wUHy2NDrT9gBf7eTkG6+6BX7p6q6K8mOsby21qQU5STdvmFkn6zfcdXUoqsbkqwZztrG2iYlLAeovjb8uyu0vbA7fNeGdGbALfPAQT/nmaZnHvjMI4985hFin3rm1J+YeOS5R/DI25459cyo7ghjP2nEBbI65X0MsrPIwJZ9m3K2660WsorHj6+3jrfWj38Xvvt/BPsEjg/m/APkAShRoxyYWEY2Hl2hf7D8g2XyAHC+htkyYP8HZAJ/GC1zNFctxmXEcMEJSTWV2IBBKJBYygZyQAr9zeX03enJH/4QpgM5hGBL23wiEB1lMOMmCQXPKg+oFsb0UJ/5xyY+NvEYnU53958iGzC5vmunGoVCA46kgEhc/OEPB3OqR33cLZTJ/GH2rQ5wLLVNYAJoIM3Pra2R8+s/ojE1y8AgrIVy9TQTIydhT8bsGdgIrQCFGRqg9Mhb8299fb7/owdyZ39UeCBP5h/PP57v//PP5G/cm/+ZfDhmZ6A/TuDoA3kNbnzgu4X+vzxQeOl38/1/fSC/TWY06Mj2h8EccAOdm2QzDA/wvvIV7+LTTz/9j1/GOn85qb34xer62qlTozSaYrXuJxFWq7tFsnAcwBJALXqt93S/+rVduXvu2RjQqkl0mQfK/apdE3icDIn4qVNk4tQpXAguM7YqVEpyUVAqV6i8xNLBRXBI4Yj6bvjdgg9JbR0biVHy6dpOka4YEBJn2CjBCtuJdMYmGSYZyzNdMtNY8vfMzOdy8zN7/KXGQqWSuCVTb5QmMolEZqLUqGdu4WSZrC/NZdsHpxrpdGPqYDs7tzQ11X/mTKk5UW4Us9liozzRLJ3hJGlb/ACsRq2tNwjhtxjx2a1HLYQP3yozegrFYgjH/fbcVDGCoEDlEMDMjsCB2J+QdYok6vX6Rp1uvoRf9efpFh3FJuEfwe0LscnJlYmJU5OTTw92ojE0iAlKD/0DBjFBewgmUSrDXGwVm6PRJo9Nbqr9xzFLMBmJE2r898+q/ze1tUR5WCPbNyrRgPcqBjD/Lqz2nyeb/d4yKaB8XWi8rtncIZPXY2/YWsHcRWaeKuio8XGGoWob+DVfC5HBOt0QgXuGoj/A8tFpVWt+IM6yguhj+G1gEJGGYPidFkaEY4CvKGBBZcQECjO8RDqiTrg4fpYROd4SGYnwLGuJhs07aDbjWGZifvLrZc31EbMmYFidIzxRuMIUZ8iKYvgJ1uIYg3hEJD6RUwxR4pwhMArPoO+kUDDHtTG+aMhxXieSpkudaNXt/zMHpJ4zRMZlZFNTOM3gdCHF6FlLdBoHj8xPTpZnmYQvVxW5wIsZEZ4fCJKss4rGs4qIUaEKsVmCMa2sz/giqzqcLPEeh16URCyoOXRZFVhf9FhbUlx12Oar0OYK9H5ikLdEbEeqkJbY6oZfdz5554uPXn3nLy/m/fydi3mQac6/+KqDbx276twTJ/btq9fhM8T1DfswxO6ubPXj0Gg+YsvG7ziCUAthuz/+GHJVP045Tsr5MN1ec3hB/5YetdKPkcF67AY7Yw/+3lsrFkfnIchqrXKY0RK+Nm5bfPbZxdtWMUfyemw0x3hA/SxilVbECbRGwsOA6hFgeIfILJ8+ekW+v5m/4mi4XMC2/yi5+wuUNSuYtm2GwVZh4BVpw+i2+p/R8fROm1GkfbuEbx2dyWe2ok2/tHER/lFJk/4mDSvRf7bROEP/ov77O6AdTw41rNu9e/YMEqAJQzEuVFoQGtNKly5vz4k9ry4kEoXEubH5MSLAY+mzrQRwQHvG67+RwJMfrKfGxlL1bTx9VBeoiomQdiW0ndPQXvQVYNs1n7xGFV+3/hIWswfh3p28+Kp1TC/+BYkZnx4nDFHJEu7WGbb/dH+qP7AXAjUkvQHtQKGtAnSjAvQD6dng05ucvGdi4t2TQ7+s98LaXwTKOYf5VSpBDeXskdg2DLoIXc1q3Txb88RaFKWIWZLbQY3s3b17dylxSzFLI9/m8qmCrmXG35x4+Vt52SJvGd81fjadNk+UboLriolbXO7ECenMQvOAUeTr2eybEvfCdccl7i1JDJc7P1PNZDJ/UKT1eS/U5nvRnBjyZ2M7+DTazgki0a9Vuv1eeGzkL8r9G1sGeh2V50QzafA9yKm7fMnN5DDd6f9o5BHR3OmFMXBpzIhb29gw3/EOE9r47WavZ26jE8izT6H/HqbggFW3NYuomkiPcZihy14A7Fo3xINzqW/SJ5lEaUqWnpfkqZIdz9jTwGlvjO+ZPpwoJchhXlwYe6WuSJKiv3JsQeQPO7qpXj37ygnfn3jl7NWqqfc/gP5i0Tu8lMpqDnIqcZy2HktAZKNP7Na6vF/D53bCd/n9UuLEL5OalhjrPzdu7U+QyrOBa+MLWEnbJsf6fwKn/PFXFXO9xHtu/prBmbpDnx7xfasDuTB8UnekZtET/N+GR9wcVmdY8B1brx4WN7stfjEd8j47JGAXmR9gEMvk1JB/evTRT29M/nHuj09PPvroiBRMTm2chqORLnpEvx9SlzCv5Z5w3lBEqpFMHRWqky76/MgxVDruvI5Yq8shrLbT31heBYIWqTc2Rs6EeSyHuTWW/82flA6GPIFM7Uwo+0VhUt4wYMoz6DgqtucHTmPVWofMJcfGkkB/Poc0CPYP3XBH/yKZa960bjjid0DUG/5NVQudTiGdyXc6Piz7W/4HFyM9Kdq3tjSk9EntrQRcLXKY2pU+cP8jQF8wGV5hk1qa7mpPNhqTj+KB3jYaiGXGOjtK/N5WIaO3h/eFbUAltcpI7DWNSy62i2QzYfefRHdscq+d6J9HF8Hr8edXcfPN70RyToH6dLqRZnJEKnHtsv1PI9eTjUvLG4kHNtDWFK76JpnhttzGb37k5uV6XfS7E+WfaxSLjSLZOHvF/JOzM2Ly8MGV4hWvK84UizORz/3z0BbnaaQ1MF5+TYRpIrYH0yQg6xuN5eXGxgaIrRtrjVfm85aVz7+yUb/rFThDXnHXiG+2DnyIH61jZZhvVOTA9dGFHwQT4b4QW66mnt+8+EIMU+M+furU46nqC7H1dbIa5kZltvEgl3Afo3zGNq4itoMHDWnrT/C9+6WVfftW9jmjZdX34bFf2lYioTHcq2SNar+anZH0FzT5dKheujBxwJixbtp79Z13Xn14fv59h6qd7vHje2equw4D24UH6sfvPb6zbuo2G5s/sK09N7SrDeOmPzjUv6G3ez7CX+hgVMJiCNT06huTyZ9fKT6Ve+qp3H9uaHYqf7yh5JO9j16fvDL5rnj+Hbknn8x9qJFYTObUxtEcUONRXo+n1jqq5+pgWo/Ov8fxfWKpY37FJD+B49soZ7PE/Qn8XjjefgDj7V2xsaGtGom/MGzY0Oc6iqf1xIDAWgusDfNeN5mqVlJJ9z0MrLpVusP8/F1waiwlSGdsOGifVvhUNdxRlDNbeb7DWGgc4WJQowHRgRjMkv1klvXJu+4tviEMja7vtXizfciV0n+3+kQUJP3OsYOuNiMwTu/zO8vLXq48k80TE/YuW2xacg+1Td7aa1/uAT2HEWY09+CYMugfXMPCqGyMZ8QRQ6U7upRRyuMMOcOyHx/ZP/vRs5OF9AuxdGEy1O6vrUX6/TVyvtR6Lj+Ztqz0ZP65Vv8bdDl4cHX1/GAHq6iM6KVCK+lo3mW0jIR5FrYbRMLxHNlCeBDicHkPIrsI0NLtRpFjdx2LbCL3woE+nPmDicg34DO93tTQKoJXUoPIo/AzB39KmKdklA5mI41eGE+OrtQ25nOngytAl7ONpZuTWeOqObTRhrvk9tUDjVoulW8e3nfi2v4vw2bf6oFmhR7ZzvtrkWVoS74WMck0ClfRJ2L8v9crnKu+Cv6TULfUI2fqn6KyfD2kT39DPkbeTemTv0UBhr1I7eRvuPAG+Hviidtvf+L2T69aa+Td9Ei/f8db77jjrRdevpA68NAITxdF7W8ZOQfDozNi/BkZDxuUcfzoC7EXP9cqbQ0FhvKY69j7zFAuGWi/d0olGJZf3i6bjMgkvwFzsjqUS7bJJMgCjMglsZ8GJ6VVExGfaKeS967L4KS8nOKkhNgbBYKZmbVYzG517Vq5goJxjpy6555TpJBNJLIkttbfWOtlG+ontbmQ1sc26T3RHfRSetG2saDCaKOe3RXgbto053GtU/NrLoW8bne6sA/cCPKzKKTkCFnZO9s7lSgYT7W+k0jUx2by/i33nDol35ggPNNKZDdbJ4xp86VXdiYKuW/c1er/CC4qKtOKc8t719aVGxOfN8XWXnjFEUwdrFdiR81qOeJRsFh4ra1atnunTvVm9+yZ3VbdD5svfeyl5rRx4twJYzCPLDrXczAqB7b+WmhzFssuimHdyO78Gdqrdc9bqDYX6teO11/Oya42fZiEEsv56uLq+urBD5OetbxWJc6V9WisYr4gJiYgZfHTpBYJzBcvfqnRaMCz+6u9RmOZEh98n2dh/F2gefJiMRBQy9Ty3QoGmnjS2+duuPtw82eH7jh06A6iv6/xqlc1cHMUfx+KeMcQJ7UYm8eYlEqYuW6WiIOM3BT0A6pF043HTdIdiPa16ixDXS5Zex5+YlIOVKH9J5b1GYk5dgw2PsseOy4I8cHvuCAc/0U97fafc01dIffe61fIhMsb/ec8bXVVd8mE8WpWYOMMc/w4w8Rh99gxvB3vxpuP/aLuvRDzsrKokyfflel/ncRMa33dCsczrYcD9dhC4hq+I+rnoT5UY4re0JjeBVN6NlGPjPDQ8+QfLnmxw5e8/LFtlSO3bXudH+942WPbqjKiM7RBfl8BboVGHJjEYEJYgS6myBaHmAvxPMJBoscw+t2HmLTdYVYDENIQlSD08epSj1F03lwkm5JWlT2WZ4SkYXmYsqFenXaVk0U/X/BSp2zGTms+zzk10eEIMf/aK+T9xDGNgwcZhu/GJYa50vQk02BFYp/4Ac+IVqkVJxiUKrGsljcVji8tn17YdWYpX5B5Fr3sMSGyRBRe+NiZXQun91u8LbMig6hubEIuMSLLC4rBkfzS9pxO1PaK1lIEQrWpfGK3UE7BFBIon/Q2LzxfaDTWMfQaVsHN3k6fr22+SUjFu1u5wKgtJOi2RDcod91WUEZ/pQZZLVhWf9WyyPn+upXNZz5k9+yH89nCRmFtc/N564UYnIrB18WL68vLZLPR6J9fLqAyih3SYTY2gVEVGIheaXmBEepWjTDLdjh9Ql1tqMvttHjE0/JDcMVJhnofzwcRDqRIkaNyTCve7DYXCYJNdGpkdb3/9w+ZrMlZoiFxBitgwAAvpSSOj6tGR1cDFWEDOZmw6uFknoG+EZjf/E1ZlGQmIZbVmnGSZVj2NsEQCNxF4Ps2hKy9uL7eS/lEZiROQhRyViA89C3HMpogZiVBE4jICdwrxLng/URgJcKIkvBHCk8sPiGm5JswE+hJTkbMW5k7iQlUoDWgR8mDQHNnomjNeFRL9H1pNbNkCCuGPgGtKLsuBVyDk7B4wZiuRhSVPMhxvPTJT4k8x91nmKKsWpYqi0z5cCrp+AYxzJl2ni2iZVj3acIW6fefMoxl3oqbfJ7h9ihpO+ky7PsM46krO6KS/qA20FNuxR7lYP4txZZjN4d+sjhcMPEv6nnaVYpkJ3qh33gHU5yFniMmCdMjFKNUaKFDQytASJP9ZAgXj1QGXfhpoBB5rby/398vz835FhG0BzWemO5+g3tx0EvezgkIyMCxkvC/eJm99s4TpykyC0tgBs4JXAAzl4Rf87o7P+8YVx8vVM+qeegW6LWsdtN49g8NqP9TlebaWqP2lIQJbCoCI8iIMfD61x9CPAHoL47h9rHSGEdwM2yHME/iBMX3Pk77LAptHqaOpiGJ3TAMsVoKv/CQeOmh6g4MEXK7ITpHZmaPWaLJ8Aqn7a1W9upQy5xi8PwwLFpXnFT22UsPKaMQIx8UjVKtXjJEIidzuZS0oMthTLSiBcHI/oVtYCNRPf8F5JA3QW8jutXR2LWDDIQ09wbm8Ub4IpStRMpMoUNEgElLgcrGgy5wU6gC8yrdKgVk5SI7txuELvRiaM9b78gLk2Naef7QofmyNja5IHe8mRKfTXbUiYaiyXMTaieZ5Usz/Z+9UXczFXLDzZgkLbhRqGTcc9baKonNy/PXXDE3rUzOzU0q03NLx+FAkC02iDOv5jFaRuDy6rxDGsUsuR5obT1lfO6Rs2cfOUtuv94wUnVCzpy3BrR1UOeF/1htRerNSt7YhVpV9H+/Vp+1Lq3AFdcMK9BWtlcg96bzsF5zI1iPkYcq+uC4dtFGKo7acHKhv0o2rH6vTtb6F0iDNPoX4bMJXBPNv7wNL5JqC8jo3ZtbN/ZGbtom17vAvc/GdsXugHtzLObwK9VmWOo+GOYJq0KruXG6F3lTY6w5QgFQTKswZff2D/XluuRT65Kj+boG0zFV++Sp4d5/FwSGPDQxlluYPa65TwhqvDTYIdcOzt2X0bLByCeeVQ/sPDI4Svbkb7zuaBBwp6Jvu9O2xIf4/tdmXZZ7opjbXRrsvCI883BWywTbPwdULPEyR0M7xKDtAphTV12m5WAouWG9L9c+tR1tA4xlTbxs4/wF+4Rz+N9+oW1H/YfYJy6p/zudJ9j+Dy/XaJdvyuAtDzlPjGKEoN3pFpTm6eLt0TW7SUGdQxybgRdylKwCMaAYmgQAPT0pLlCrmePCNLvVCEICU1TRmxFUqCQQdaVaXjQsy1gsV7d2f41SwWOBK4i8YLtKhuF44ifsnKj6gccQEmQFXZFFzFolShhDYjgeYZPFnCUmFMtUCg7DkfM7Sg13C5RY/ieXx6JZpo7oN0mOyTlphinAKjRJEXBYRmKhaFEvQ0HjLFOx4wyxzWmWbOfjHIp4EKWYDJcRmhqKx6iRrYQFNMtQyx+2UXxnE1286WGWIc4D19z4MMMoD5IKGXl5weQ4YnmDZhhzVD/pbGsFmWw8fJPraPyR1fUbecm57pU/kqzJrZpPyjYWMawuPw21zcMKORXVVgv9qGLoKyBAjZBwznU3H3qosLGBvtrwFflErILsRbPTEOqxTqbdjQ33baTgP/20/9TAH2tQjt0N5uAquLvwEOnh13ps2zV89Kzu5lNPQQnk+Nve5tJHbb8mdI+njyDH6QMRszQ67yGeQJgzL8Szoonru50vMMxpArzjGWDtjlhHhAdh/0WEYZbh9wGSlaT+Xx4QhnXK0XJolhbqRw3SSbEJDFIQv/ly9922o/Ad5QADWCzNt4q1MPEFlSz/QhAO9P9Skkj2ANxES2Sk2wR6uyaEpTHb6+UKs8T2gKUPAbioHOp9YccthLlcwbGd/VWphf1FW3iVNvdAZ7kQe4FcFXtN7H3Um2MQA3c5KKTRQD08HX2hlzMmY6ZwiHGUPJBrCEM8u50tNKzyDtyrwXnEEaMROiMXeTsv+4HLiqZq665jBanAi2uKqrhWOp5PxANL0yQQAAzZSokcI0t6SlJEQQEmWS35limLglNFbwlO1EVNAf5TkQ3XSWS8uGkqiqQ4tu+lbB2j36wVkfM5dKwgHK+whmFKIkt4FlhKkDE4ReLEh4igGxSuXxJtLxWUM+nAtTRZkgw1YacD29FMQRZRdOEQ5imhmD7jSGZc5lX7nCLBhGNETtc12/HNuKSLoiybRpAMCnbCtkSR4wVJsQqStqCwPM2MIyuaCgKPYUkSL/HI27J81HckBn13X+wD0Hc/TdchOSpHXbd1WQjj1hn0Hu2i1k/ZfYPOmyTt4TUm8Xxh21V/lWFVTcWsV6O9B+tXPBFYOvSeENcdzQAJgFNsRYXGBEFIIDKnWbZvW0CukzUGs4hykirKEi9AExm27yZd3zBlWVJN0/MCFcSjxCFO8AiH6bpBooMuMaAkgljovMDJEiLfrwuWqigyh/3nZIJyLjnoPy3hJgPbykiyRDC7Cc9JoibDmCNx3oZbWFG7i5cw9bfIaapm2nHNlUGAhLFnen4i7SYNXRJBtDFneaMLNcBUm0SEPgaZlXiWgMD2MGVZLpTnYz3gKXqRf+dQnm+jN6bf8qmfWKtd5sN8KTTGCP3p0OdqudcjsWXY9p9HsX3Z2rC6FhyyLsJPkOUvXsDomAL6x1hAUoXhs0Zjm0LkuhGPs8E36tyWodDT1vWwxbCfHi0MirI2NwthvNQWT1QCGeNVsU+gnyIMsHJJmORK1X3cPEiWwDDMRVC+Ner2W/aQ/6G8ZSBubSjfgD9a850KhhJW2xRidZBAcLChIZz4zZQxA0N1+9nRDeZp2v6MkQ35kHT31ZjNBv6klQeIeOfVkgXf1tqLUG70eKABLG/LrmIZmmnB0NRYTBQnmoKnkP7Prr2IY+N8wGBKAk/2FctWbS1uGAajsLoimSInq+w3l26RdF82Jc83dSMwXNU1NV+Oy2KST3Fk6SYxLsOlgasbum9CCRaMJk8WAz7B/Aq5+k6RPLAihe/IXH23BL8MwXvRGlE9wRQNUZI0XbctUzMN1ZFtRPhnPd7FPAIvWksS0RIli5FZHdgjG18PXsWDi3g2wQcwGn9HvGmJcGk+KaiB7Bv4drZr6KadkCwpqUi3LDFMwMdF2ZUdHd/O9uA93UA0JWXEnmrHTsaeHHBBc5QJQiFrruM2oRNQ5rrsRvCbObSMdak2iH4PNqF2KOh6XQy/ja6Hft9RQvRVEuPbbx9unoX+lO9bXnng7mskT+UZBuotQvu6GvaW6Q9qI8cJq8oc1kuHToZOjGvYGQq2F5AObIX3+TrxFGx2icGMaZoTtrsr20CPOZ/3GEaFDkjxSRE62NdMaE7oct30Pckk5x9YsaRr7n5gZfk+mfRfAUUN+t3DrjF1B1pZxAHF8Cr0DYwAFnoKh5aO72I7hq6zMmNJ0KvknRzhVYZxeY9FJ0VbdlQD38aFNUWSRBykqkeUJPRjAso2oF/hZQxfDlQhyVPfki1beOj13gWZ5hrUzQ4tz/M1mqYFSDrO1Wa8BRJzkx7rdKtB9F3r0qUE9mseVQJRj02a+6cVYvN1aJ66eGTEfvuin/eyuVprCdowD6Sx6JJHj7ZvPupoV5Sd3BQ7O168WlKuvD4rnN3vfoJM7p4S8+UxZ9e1mOPKUJy5b+wRDnY9dXdkDF85udCctnT9XfVqupznZmdIXdgzfo1n732dl+geFrJHlqC42vgsd8ichIlxoJ0qiXnDfOtuUi0mgmqpdZybSmlLO23w1460BM0UEMx3aGQx1sdD5LIQ3lMoU4wqrCJq1unApggBAlK0DkW6wnmAe5EHKjme36163YOknMt6eV/iiFvk8kBfGI0RrtCcozcT+forFcl3958l5bFyXpzazYjM/JyjGDDG2Kmc0ylqUf2/e3hJS01xcCvMc2u6KQG1mJnl8uV0lZzea3vXjBOthoWZhzgYWaaRF0spRmaCapAoVsnhbsJbPCKP2o/yMBrQy87LCUFxUaYAVNSaFyfF6jA7JKzX1LmTLLKsyjpMkvTXWYvXeeCuGOac4Rnn+n9LJuqVzJlMxZbeV88xdzH/FbEKVZcFYU3jdcnU/XjWfp3NYIJVxuz/U/3clYUgyB86WrZvSTpObJs/DvU4vcxbMf/ee9z90zz7I9HzuG04Tb3Ya9HmtT2GPYji21HV6QdxjGNBJF0MFzEZODFD9pN2txMmG6OpyEASaHr0jmAuz3hRtuAoYzVlmLIkTMyHmmMgnTDpQqi4eRoa/x1Mw3iHhkm+C4yq8DKw17zG8ArD+KzLKypTALZG0O7A60AQWJakc66KfGsBWA1GhKtZXlYZVeZZwWeAEgIPUuBEkKdJaNkv0Tj766C5TL3qk48rNlHl+/OmJN3vEVv5OPGruglnC5aV8Osu+3EeU0TezwFzrKrA3vDk/v/D3JuHSXJU96IZuW+VlZWVS+2VtWb1Vl1LV1XP0t01i0ajGUlTkkaD1lFLGqEVqSUwGkYgCoQRYAGDjLFY1Wz+7Ac2g42N7Ae4bXwF+Bozz+Zi+D6w2/LyfP1sMyz2w1vpxYnMWrpnRoyu/7hvpivXyIgTJyIjT8Q553ewVMvidNPR2HiO7GPH78Q8XGiYAd/4gG9+LKl5ZA3Z0PKv+DyAlSbf7OP06kmo1h0aFovZDI1lLSwAIgtidnG0yltIEhQArc1gFrDaHZAWdVdXdUwtK6sVXBlIj5+TTiIJi/A5dBLPByBWvILJreDpAE7p9zPqBWK7EYZZKWDtdGZwUwpNoVN44sSeKBOBTTWzup5ZRbufit74VPTD65vrgY0yeZbMZyH9up+qT+6P36081cB9imjN6Yg1Q/tuUBBuV5ihWxEfW9VpM0s0CcErWBEIFd1ZgpV1gGyHuyg1u8grXKydqfImX83ssDiFX5y93DISaL5YmKdRYkf7W2yvNJ9p74qj/lQZsYN/j0yXksnStIRECZWnZmcHnxyE6Gw2m0GDfyt+V0OtXBYN/mWmuPWdM+CdizacyHYat9AfaZ/YFadHpPz1mD78Ovazg2fHBY+JQbdnx3YUH8NlZahZH5ds5N+TTyPwFRsawEEMPyxKMhECb4OTAN5E1IIABq1oZAGi10A8G96KEOAq9CYtGtXeHRfF+Lvh6H26LOt5XXq3LgmnI0ccSXK6ulurhSWdN07jLtI3tMELmok/olFTQxnNUNXBJ1FLCOuDFwQFdU9oPK+dGPwJyuhPuO4TYWHw3xVlzC+oAw/2LwjE9HnUuXg18A2n49uHdpwWqjhdR+pto5bHX3KVt2s1lAy/5jVh/rbt1Mnc4PM8j67gpadd9+lh/Jsanu/3KJEyqRTlgh0V7sN5QCpamITl6Fi+BR4KFo030Iqud3UdzDm7sNnQB3ge4b5IgX3oWdfVfbvQtd7Zs73BuY2Ns0O9oF8eQ3x/iB7S80sreDmrkCvgPM6QnGEhGmdZ29hYd91+bwJX0CbIoVXiFZMjEIpNH4sL9zF8JjQJ6yyf1EJgP4RnKGu1wWrNraXv1Iyau9mP3K4hCszHXUy16w7XvjO0a2h0Bh8YxuDXNzfP1XT8rxb4/a2P1tDz1DTu6eCrhPOHWBZ1f8qFKRhTYzW9APup5vbQes+dJGEVKMAlDjbOnYN9t+u6Qen4wDAyW2JUCcAvglyNNwimecQLC9UGZ5E7OAchYGFih0913AT4nBzUulvfT/A/I7lEQYtcgOQ9VOueI9n0B2fPUerI1x3KBGSrmZFW6DrqZogOAbX2ANDoPHvTBf89w7X3wJS51UyjrXurE+ydYC9suz+87m6e3SC9axM25/AkFf9turhnDH+9rZvRAXK7XXDew91/A55FuH8O1n1G6xs4wVrw6wdPDc9d/fQqsVUL6h/e5oU1D1IO2lZnJ7DaEsbWW1uOPbxF1Kgi34YYnr1abWJXO3uWjCQjYr/dP1tbq/Xxf3+7WtuO5wWUZQFXM9fyRu9Ay49SNnQTwz8drfZWB/1VPNPvYQ6swpS/h3pd/GLhM9d1B6dxz6O6YJzdvVAZeL5fj+TiaNixLWJyQI7A6wIyxhN8snwAJrdQGeKByZP3vI/f82TQc47gvnO+PxnktYzgXQHPshmarAzOo+GSUIBJBrYy5W1mpLCgwWMRAd0RikRCmHemqYXyoYQl3iBaiSu1ZYFjBD7CCDfQnGBIeLMb5A7M3j890GweaO7YOTW1c+qXIu/pIjeindGiZuhMyCAvfeYbZ8IMFnXwVInlLSwmS/wZQf79xoFG48A9UxAS6XgkcgcxGuQm6lkIMBVeqpYOP2FVub1KF67Kk4Tcr0TeQAhe9PFZzyP5q4S6uyIRhhC424dyDHBBfNt0hbRnFcsT1NiCGaLbj4+jAgf4b1bBj/QQxLx1uE7JOWZqWOjBA+GfDw8O6oMfcEL03LmIIjMzDCumcxqemVSUwVm3pkEqTFuwR26/lsnrmhb9e5UVdEXQnr4ze2ZSzgHZuTymbLi/CEU+Nf9EtjdckA6fAv8PZbaXvtW+W/L93aJWM/hWCDnwAvAK8KFrOi19dQ3hsQG5tVD340h/kXp/B/U39M211bVN/C5tbHQ62/ADQsM44E6QE/6orfWDDE6vrW32N7vdkb8l4FOkQcojCCEO2Frh6RJgUvhGckPgw8CgySvAmmmzkA8zM6hMFlvrDqzJIunpu5NYbg15eE4niqyMaLd8sNV48SMPP9SbcWmexV9/iGzZoBlGoiMMYjOod82OcoFGtKTwUxEWS/lyxevsuP2m7sorIJ4kbSNa3IEA6rhc7W6NGzVEm38pmh5+qbJXL1YKlPEI9Q0UJvg8oKYBOIZDrMwuGvNviLyWhf3jxkQbigSpF3RMfmp6mzEsKhpv9R+fI1PqNwEI1BoKG0+SvKgXfc/L/4eAQ22Z1+uT+EkEgsRu+NPyM2813jBvLGI++zPr9SeNx+H8JXwHjG1gwacmiHkDmDocH/qA+pR8n9g/XMyPwdjixxBUacvz5/kxXMhOmKwRT+bxu5GHt2ZzpP+eyPb1jtBWpKyh18FfRlaDZ+9+Tz8y1ClRgH2tgNf8OODj59SjR4d/yJ042U5zEucQDAvGKPLOOB9UhnJP/dKDD64/+OAnJjP16Tg1eATurD+IMpOFbMOZGZYQncCZCXL+rfFT4zy/O3ExsHHeQE/jfrgfsENA0AENpC9Bt3yYuyGMReCKHqZB52UPEV8CZRixUrbM+kc7ekc9fOg7+fla/q7b2VTZS4Z3TafqIV7Ds5I4gyQnOZO9+eZSK59kc7amajvytcv2tX/4w7Z6xRV/U9tf0712xZxazCQ0PIjqEiMWncysvlBKz0lWhs8U9tVGuukh7ZUgXhsmfQUFtBfwrO0C9H2bkKf8MdD3Vr1gHdhKSOj++4EO9TuYkCef3F7o2PcpAbipJX8UyZ1fDC9cnHHNHHoISh/8w6jo8CIuGqGkV05dgFlI/7NaId9olzExNiamdFkN0c9MLXrW9A4XuGRHMJdKsewctQ2DD9qUQISB5XIA9RE0asG71EZNo48qhw6rHf0XL96mdgratLwwycovKIcPK7hd7UYhX9e9xWlkAr0hntArVGJZ3KrlzDypU3F/jZ6knYE2BXltiFDScohdyQUaNY2+rT9JmpO0bKeQ3b2VkNVVJAINT7cJRU9vLRRNtOlLtehFGu0CTTOcL4J8labq1PW4FUAghChpvro4aAJ87i+uYgmrOZy0Bs6ZXKNDfPkBXjjQcMKaK4k3Hmgmm29IlBAjIy0qK+EPm+k0rOFrDGtE7NQ0LybL5eSHrWwqWkWqoPNivsGyKTsez9u2UA5Lkjyb0kWBUwvFxmYpruKvrqXpspKuZBCtWZqmFxLltpe1TReJbvUOVpY9XlD5KFL1Qm46ZkYrDJ2cklgkqrFUsxDEdKHmSb2zZGXVr0NhHCSqtYX+C9Ub3SvoIp9rMkLMckULz/7HZP7t1mq9iw2JZd7Q8jGbdiIKv4Wa28fUC+58QNsqwjIoaRPA2X+ZLXLJ3NZ/OjdHNgtAj+8BeX5527J1t+YwlpFXqD71Nuo91Pupj2Keh8FeRQh+YVSYRxOmWfOotQLoLZ3gt4KaWTRhrAVeTCuoNY8mjLnwvAYPEgL4MfnZhpEFDngT9l3NFTTKcrR4bOLc/QCRHWJTF6jXBdTPMUk1L0actMylLU10pZCVZpWMYwgFNUUXCnRaLQpR21XYtK1KrqTaaU7J2BG4zeRSCd51+QTjRiNcKsXxpisKkmsKXEqyOMPAmfO5HJ9kckaES6ewiJ0TRSGH7ydSnB51v0XgVnX6npQmVveuTbmH75GM3JtTOdNOfUbUzAynpJ2IkFdxDjkmhQmNOlmFG1KS4WTXjoqFUBoITakF0XAyMpexQlLPzImCmMOyfzLFR4w8nfAJyRu8ymWSnBBQyrPJNE8IFbJZAVfE0PET7FcIEGxL1FL30Hs/kjyccoxcOTtTxaTfO4r57M85QGa8AUsnVNS3dQCAUd/mWiAB/Lzyf7UbDCd8f2ObudThEJBUFR+557A7Vc0ZKPdfa8F/Jk2ApgUzV53JHn6V3xTvSx1O5ozZ/1ITvJvwEKRvSse8Ap/VKWqBWqIO4Jn8LdS9I98qgs5I3rRhqBvPdALcG8dHZnUWCF4j6PrKRMmHP+qgFINBwgYlVweQ3PkGMbgFJTyB1ASzYZ6Y5KJqsbq3Cis6eFek996y9yziZDiXObTYW1xDnMkhXTdYnobQZ7TBy5kKzdP6UZmv6figst7L2PSOaKby7d5iJRPdQdv/IO8uV/fm83ur5d2yxlf37q3yuHehfB5xamVx8ZfxMT5Kx2JLCFZxGUPNoGpENUJVtJHJFHlNXxSbOUAlzjXFRV3ji37skBG/9mNO3UDdTt33ErwCo2J4m+Hr5OULrXKe2MMQm5i8YOXrxOrBN58hgObAIrtBvmCwpi7k8QhRgHCKDaJTbLTPZ9YaYnioPLGFAc+IgHX4EOGZFzCDZyD6O2ZjT6/5vLsaJmzAzaOVjM/ECzHsv9GM6LOCkyEoN3AP/smczxCROU5YmMbMPFINAQuXEbCzniGMJPi54mh9cxt+bhQJCL9N8yiwY+kENi0ghxEBFb+AfUTlX6Q6X1O+VtF1vVd5kaoIaTVVSSupD6XUNJp+kcojyv2a8ocnKpU/qlReA2u5d+C7p1NK6mdTYKcL8T4H6Cn05vNoIBR0JkongTY7PloyeMg8RUoH7IPd3fycM/dFB2/w344uyg1exLzY1+3+Ubd70nXvmLOrjlO1T+H9LQSizPcnC2LaG8T7t9UBZC2hEAEH4AKApZFYY/PgT+agmj7YAGOdj3xK+Zz7OeVT32ZZ1VJUXuTds/o5uH3uLcGt38cX4R7LbilHIMj61AoixQAfcSHjEjb6UED/D9zPuf8wyrvfx1n3u3+NL26Mc52cOy2O54HFvK/RH8kpnVabxARuApg+j4dYW9iCkx6ot7MfWZurNBiWYyUOovxyZtQzvKjJ8QxiGDxt53i6MTMXzL3uXTtyWcvQaFEXFVO1dJWWU4lEnKETiUQK90PZMFVb1iQZhSOty45sn7c2J9CkQM8+snnzIMAb0SKSmDYQ12VsvhiYI5y9YedMgxE4TBODaZuklGU4CdeAaVR2jCbPl0XCtCTosq2aBlCG6UzQTBzopFXdUk0FV4LWjMtGa68u0QlqlAn+q/6KVMeJENSvVrRViBQipZZXiGx0e6XDtXMAzI2oPe9Gq7D2fXjw7zXUqw1Ou0gfnK39097B2S0xNwSSL0VW4CPNSNSJzKBIyyGg3K6+cc79zcO1jbNd3XVRb7CJejg/5NbW9G5v+9qwROK8gx4gjYiBmUMwvTB1ua575qx7rjboo64LmdRq59yzZ3GW1ADWAC6WTwAnyI3z0c+CXRrJCNcGMgIbtU1wOcM51SYwAhVi+UrWwXHF8NPCcP4NXbq/hty12/BsWjl0iGg54E1B+i2dH/2oox46NJGPSnD9/Hw83yYfQpQ/M9h4Bh5WOrruZ/BxeFDtfJyATDAEY3oVUedhFMFq/CqstMOvr+uL5G87rhEPHACNzArKCbmWv64B8gUJ7Pnxwe+E0Oqr99NHarUj9P5Xg2Hda16/+a0brqIPlEoH6KtGuAR+fiqsD5VyLSJ/EKEE5wU5PTHM4gnxuee6PzwxfP6E9tRTRCbq4edrVIREQ6rBamTJ8S1Dq2R8IO5MeWLg02wQM7rycKF2CGkpDMFSLf8CeiMWf1Lttnd5uYQHUq9WP3589upa255eKFzuJUql+QhB8McSEsQl08GiwFTNaCK6gR+MFvN5/NhiPKPP19taqpBPTMWzZwiw/+2A2bCQMMHUQTcSZjTg6bAOceJRfR79o9V3AgAVEMtfgMw3EroOWZoiEqL4rQRtECKWNYsnFIgTcRNo8pZRoGRO0x38nWoJEUd/rnJmg8B3lf7wrhNXJ2870e/3H3sMUY8Nsc7JszxZH4MHNkni7igRR9KskjSAmGNTOYJkjKfzHc4DXRwRmZqtMMKvEJ6K5fEoZjWR2z1zpotCc2drEKjh7Nwc0u8gWLJ3rKPu6vr66ur+/b0exJ3pqftP9wFJtj/uT1CeDKu8bUArIcD1tjeDOoEmyJlhCd7GDPoAzvGRM2ce4TrCji6o2BbxsFbBRXrSetI6fdoqrQJQwioUBOuGVAydRvdc4Js/0rINrUy3/1Cw5y507/Rg7eDi8B+qAAsr4/N7Bmf0Wq078fcidfr0Ov7behXqr/5UGi9KIXep1L00bWu6fvp8unx9AcSUzpC5N26XNIQpI1MVLDQCQqtvlN1stJ1WfnQ9uHaOkRn8l+PTlR1C1tIZeyZZ2SlIGYQyklmrxLKW6co75qM86iGkfxghRgoJ737Xx2hGkRT2w+9kFUl4Ox+SRnoAn5afQsnFi71QKUPMZOrFIGbubpx/BgkaA94yC8tMNAiYi+cJDvlgm4JGBybmxDQ9iOSL/69evipy+Zm84t6GYjlXi1f8oLqvE2r5ej0CprCOpBlVRZmLKpKphdF66yNXze/PatddVVmZml4erAWRdmF7+sA1izO7V5x4M1POxE1RdOPVqiTNzWcyvBhJpn0bphHdF6f6YmS9ZOlbsKR3UJfBeljJhkDCOShhBb8brV2IfJCt4S8MZyQmX47okObpJaJot4ROE2JDzqA8xKAS6jxZtGyAq1Yd/YyCCgDvUUIqCMyg1K3V6HB95y2GHk4gKhXipdcw+M43D77/oEzPvlD9qyf3SarxgiYJ4tV2LFkqpuzYl9+oE09CV2fYuP6BYtKxZd2KfJl9Qtff+NVHH9UjlYp+8iFNUVVBsENjf3U/Ln2eKlPTRF+5TLAWhGBNp1MnpG+pNlQVDBKE4Ier3XIW5lHBh1RvoMtFQdJeMFRp35MPT1ZuXV8jtdsj7fyMfPADlyvVF2b3hGxBUFVFe+iOyaq88SHdj8gFf1+N6I8+GtEBAzEx8u26jlql7qdeSz1BvZP6ReoT1Gep36b+G/V16jvUX1L/SP0EsSiMm6eMFtASOoxege5CDwPumW81O3KywH03TybC/NBpGI4L+QWYUHeGXsfElra10CAhfQNHDIGY1TYbpmf5PhTEuwLn4/hOGXmBXCEvigBhb4ienYTO6njE66zRId938ERjQEhv+pI8D30Xi8W+2F4OvqIBzW3cqcGaF15DG081CdACIYhUAqey2ysoqAxM9jFBoNIs2UKZD/subQKZ/gI1DWEZrSCNdoZ1XyhDaKWoTeAClmmPpMZZmLbVFsBLrkoLga+145sQF/KFUUTYeZShnUazE9jd2uj+0iJNNxK7o6zozCUytBheDIt0JjHniGx0d6JB04ul66/P7WbQQgwSxWYnEs3GIFFsATG7c9evz7gZm1MUzs6kLDtGe7YjC8Zn6JjtGYLs2G13Zj4FKUK03YP7s4oQOYNvVyKCMnsLp9AKR3N8iBwgHosSoNp/XdikGSMKTiAxDc8vZBR6hEE0SlpwI0IjFbyEXmXkVTUfMSJRTtghchER32PoEHpMnIY7OUOPmnn/WoiVpP9XSwg8TPYdnaUjMVlFgsp9OqKGEoKAcCozygocA5e/K6YkmdWmlCrO1YhzFhNiVU6H+F4nqiKLX38pKclceCoODkVwV5DVT2g8k0ksRdm5RIOwhvCvkZhjo0uJDMNrwD3X2W2ys1sTzLLmbscF9qYZGZiBuNtsD7PIiYSYV2KOekwo4tg9mSEcCu7ORkPM3fhmhQlFZxGD2T/vM1oZvN7OwknWxvX+GDFAe1tDRAXCrSXFYeWIaKEHjLyiFvSmiLrAOMURf4/GHI7FeEUXZA5zGH08EocWiMe4Ij5jOel/KElJxHxRPSSKQb0t9LNiVUpJEqfPCF7VlPF1jRV2KglRBGbHo0oE81Tl2TckojKnEmbTRUTYz0zgNV6BR/LbqVdRr6OepH6B+jgeN6hSwywEAwN/3qhwoSHhvAFhOByMxpa2b0BB3kzedoZeXx14O4cDCLyQk+9fdPzSOTY3xDuAd27LG4buv/764L0qL028L0vl894oc7ffI0iX2W0Gb9PeWHzU768LurqJu/1i0MencAueJb2aJT38v2/p0M9P9GM6Mvg+6buhoCejy7b02+/6JRPKJrsiIXyiq5ojyoOKmUFXfTxvBF3qLOlDRdybfpH0Hdxl6Gtxl5FJ5/nyRI9Bt426CRI/iPsFF/SRGyY6xmScaMAQ9wg6z/ZYEeDQ2fTyABSSazjEthBQNAgudz6wlUK/IodC8mBNDmvKmiw4NPsRieHQaY4RfkhOkScO1kSeQacFtIpTnlW0sIx6cgjf1IVDCE0L+GjwK98Xxe8z/BZdaIjMPBoTBk5Ngs5ZxmdCa0Qhek70KRDRR+UQww16HDMkBuni96HA74u9kDyN0CFSLsjcozUaH5EZvv4taonaj9+Qq8F+bLxu0252vBae5zds+JQwvABfmCzdaTmeYDnNjlP24GMHYdc5GxYRaQeWWCF8WDkvMHis9hwAEfJXdf6VZumYeZ8ZB/8Zw/ptm565dkfO5uqXX33gMuMe43U0LJN3dl7eHnyRTR+wTFT/iwNptt0w983bNWcGD/XmR2bcRXq48HOO7nrI20NzKFmpl37Onu/Szu6db965Ex08yDUqrQN1s7Jzd2y5OYW8q5D9c2iqWXWu2nR5fvA1VNIbDb2EmCAm5pgnWSwRAUdeig+EBxeq+AVretSv5ScvWLfzK/NIUJH0BckP/BOvxf2kStoP7EZ3U1dSNwDeJe4xM8gCn4YlVMgTC9kWWMmmURA9ecGDMY/ANvp7b4TnGOD2E/m0tTVc4Mc5DsslXAHvOJv7Q4geH3WiUby/lWwL+KcriRe8xVS6/EI5nVr0qnv2VF+AzVn8RGH8vKfoSnm6DFv8m1bARTiaW5iaTiSTiempBX35eLd7fHkYb8uvpxJY/XUhmi2aIIy8m4Htb8GP/UpE0SXQhTcWCNin4+tK/fgghTyuY3ADXTMicgepGKmfxRe4k6RWDVJPn8JlcgVVfepeN5GWKzBBTZTydZgLUbEF5xRZ8w5w/n37JL+1jgDSfnFkD7gVkXqrrWCgmrT54CsAlprBIQF8aDbshv+xcJaRD+BAdBoBqgP+m3DmBjP9wPEXqbhOurpItv/DdRzXMcvlv564eJPORnkhPhN1d8V2udGZOBYOWT3iuaGQsrO9UwmFXI/hRVbRiwkVz0kqCxUs9quJoq6wIk+zckjXbTuyHFuO2Lauh2T2x6RMl2yvdPKOky+W5yau5fbeKDELMUmKLTDSjXsPHJDYcJiVDnyXSV82t29FZDhZ5hhxZd/cZWkGqZqZ4jmOT5maSt4Hn89M0E9WqMsxnyn8euW5S+Aee5HIMdsjyhwtl9HxS+DM4LcIT/9ogqGTHP9Rmb9IZa8njGFI4kWfVRPHW9eHoU/dRv38+Xi7HV6wA7mDiDb+yroTeJuPJzIgygTe5e3RCj2ReIhSYTw1sh0/3Dzem6AAI6Gh8R6Cs7d9VZrXBvWaH4ke7xvvJ9ChK2SBLx4OYzE2HE1KWP4VIXaXyAmslIyGGZoOhzk1Ylq6yv20VLplRtTb3LgW0yxV1EXXxRvVwqdxV92vXuxGAE56kiwm/jEniLoZjqJRhrhYFA2bYLMxLHScYkjYlhRJUc/GNDYolNViWb/I8y9u9QkA636qeKkMnGT60Lhy9dJqPHFjkzTACz+N0NHFx/2AroGMdAK/U6nAL4Eq4dk/72MB1gmWaN30e0qh1SSdCPcn3/wIj1cBxSPKPxsOM4lkodzWTb1dLiQTDFxIFN26qOZVse7iSye7c3Pdud8l268Z+Vi8XRY1TSy347G8kUvEShlVzZTisZNzJAn589fHhnS+LBoviaaXomOybYkeE/mLQYFbQKvp45v7y7iAYYX6a2trel9fC3Z9COk0OsP/Tvf723xRCsM4LpEcao1C0wTrTkHm+Hq//yJFYjSs9nBWsAhMdn0oAV+lxpdgF2CtAm5qnETrHeHkhFFgvEVYtYzGSsZhZJ+RWpH4goPNGbq8tX+qsjs2LYmpzu7K1P5Wdkc4vOPOqCSlw4YRX05qWnI5bhjhtCRFnWJ52nWny0W0ttzuNOqebjGMUPTquN8vp+Lx1J/ayZg9n9Q4Yc5x5gROS87bsaSdcuMpRUnF3aFt9JD+l6D+IpRdrGS/Pa+l+ljeEEBTPMTQ7gB0wjDAEe8UFoiF3WFNljU5ovMoitLRmBGLo+j+RP5aGa7fG9btciJiG1bMXk7Hk5OYDDBug2f3+RbCjQAIZEth9gVsmL8cLyS2FLxEiNlqTfzFTDwR03UL02EZNqbjdwhp59kqexf4gvjFW81ygBDBC832wnIg3X6dFNZM5BP7oyiOCYimMSmsFBT/Bz4HYsl4etmO4aIjiXJICMuT3y6RRD7KkvhefrfmWp5AejTjWxwTe4CCtbG+trqGaqdP9/rdDfVzn1Pdru6iXv9sv39247nXvOY53MXX3q++5z1qfHUuNL1vS2wtYyL/zihbkuV6kFmQ1ZlhFoGdG+hQwQsJ1kML+QBAkQDngNEAGVMWfGxdMmIvBC8IXEIfT6czFS/zuJ3P2Y5j5/L2TGgaruDrXgVfx1fwdXzXv47Y9NXpVOox23a6jm1Pa1Op1HlXCF03oLOoAhqJS6OrvTBB1Wez2Ux1LvMGM5sxLcvMZE0v7sEVfH2uiq9nspUKvudfRXL2WDaTecw0rUXLNMvxciYTXKnsrJDzoY0i1UWAFhzyfYmJKp2MfGIF3AtriKpUnhHFk+IWXBImwK/f9kx52xvxnJ/HKycN74f5/fJWA/ytfTo+EUcgkN98BXxzZEH/TSKKkWXmoOMaRMj6gtgHaseYfGC9FmBSgsfIMFAlgRAdCofMcKD0TY9AmtqGyYN7Cb3dE+lU+XWffuyxY3vbsqJZCYIgmorr4bAQEkTNYg0jf20+n0yEw2E9nigUry4W3jcWq6poR3sfiYJZFq1UMURCU27GS8WyVzQMxtIA3EbTwkn8pFculuKQTxjRE9IQvCrG6H2RiEY3d54f4quon8Ezlp+l3k39IrE49meL7WEttvtXeY0hk4ZXittSlH/KeSk/DCdQ3ubhP/FEEPxxxMvDNu7f2azgWpZrPzabzc5mS3BsvdLJZquZLO/atmuhYjWDk5XPS/WGKqQq+Yl2TT7y/LZUjp31k90PaWwne7MFpweykPPu4Ngh1Ph3zmYhh10W5HDZRY7v2vJECWpSXbL9VLYzOglioY/bazj/h/55ZLJ18gHHxq2xPfbRcD/B7fGdgLtDrr6D8OCYzxZkER7eT669ivANHfZvfX50DVdnyB/CmGxQwXeQSk/+rQR37ieVDp4YYsJCzJUotQPXbw+uIYVMH5Oh4AslhG7Bf/MI+EUW5rv4K+I1HfCbbeIvCrE6qi8IQXR4+CE3k2KNflR0Mte/9vo6n6wU7ylWknhWZ+luJOtmI65uiTp6vNtbXV1F0anpspBtIlTPadnpqZ3XXfdzYqlYrxSLlXqxlBC0orfW7a7Br1zSbES/QIA9A2xPdlSPcZTBUS06BQBp9wrwkRrXiDmPVtfVXSDLDWg+s5Wyfrfbh9+YwsHPT9IgbpEpt9jeDTFOncD+Dn6AIs0HP7QGVjX6oN8HwKoN8ODG/8jVNXDqvkfXV8nfc667Sv6C9akLlUe0+e3GQn4h+E1q8El8MT++EaJIYXCl53bx/28PS5nkpxpEmwYcEF9lNnbfC6Mq3TovhMzzDxw6kIvHcwe+cPLowWJRr/VeS2xiZivJZCWJTh9q7z25I5/fcXJv+6ajuxvPNJv2ZR9v7GaJGcwVSUg1EQtIBXsoY6K40SrBMPfX+/muT+R1v5/LEPMV4pz6HqMFYktDTC99q1VwbIbswNu4PQxbXm6RFSIkLg42FpeOLW2caR5q/t1g880pI6bHcCfZPHfu4MzS0szBg6Vmc/AbZ8+uG1pMyOWEmJZxx9hgfrmObwE6WargGxNjflrNYeQ6u2GOS1yNGVBWD5d7cFzcV3D+BilpHQouHey5w7JoCpdl4X5fJZKLH4bbGwq4cLiMolg6CwCqiBwDbkeNttcUSh0HUcdOsSiG2AeurB+L0xaduv3bZLs4cV3odwfdbhfgnJwoy7Gx0JUPNGYZha3vGHyL7CZvvBUn7Qb0/Rj9T/QUiTnmo+sQ9MxOncQk8bE+PD9CsuD4OKJLKAhOgiksEaES/bmy0JJnVKQj9OBVzRviWnK1c/RRVIH9dY/S+PpD+PLgNxeUqWllQ2m1lKkpTUCCdtWDC7NibfHR647j7c9cx6Dh1a9CkgkMiwfwuxSBtiI+DX7cMi/wfwPbM/z++M50YDCEHnjta93XdvGP7OR+X++7fd3fIXb//sXL3v72yxaD/fOHDqUOvfe9eOPvRzFW/TIvUOK2/M/LcQLDAfznZ6kFsF7tFABuwyKmE2Ad0QKrKmscCKzje9gTSAcLpgKwqAsAypuuXqvpZKNDw3XX+oPVPmA7nB6CS5wL7rt+AsDq30B4MAGMhwygEkAELmoC2yJK7O8WfCvNGUxSYQkRXzOIu3tBSnzx0Z92b44IcrtbaFknZZ8ZEdyfJOOcT9kI7zxGMHhkEqWnhi+iDvJA1ePwHeh9zWGcREySEIjIVUIfMatzeCQPBhqin8lVH9aXuLfZlVy1HpMjkZ+57KNXNA5E98wlbMlx0XPi4OCjtcJrf0+8LhT+e7de+NBUPpJwe99YMYwV9opGrzfXVXR1HEMdc4iMDfOj2EVEAeUEowEIZB0IpredqEa7ddveanVv9V2lhRL+q0X2NQJSbtqD1uuFDxTqsPniB1KVSgo29/UaV7ATZHTnhvhEPg0FMgcfBcm5WKkfJaW6k8UdH5X28AXKgP79ebz5KtS4BBHgAFmB+nzkvLlx9EJ+vDlrci6+gondMu8+EIm8VNyw4dOo9+LwwdvwE+OYOgR7vAQ9DUblQiTHARLJ5pnu4MXuZ9DmoIY2ADtcR67+IjWKtzd+Nnr+01Dq1hwGPbQ+mcu5zU1/rLmK+jZq4vE6D9qkDj8M/jF0g7ObQqNDYGWJA8mXFVng8u3a/rmiqImM0p07VE7W9/HxzK6fZRRhal/NW1JoWuXt+Fy3EmMP1m1DraendhLCh2VdpKTzMz8/T6IjAvTMzVH8W9AAUO1tM4ftM4nitvNfBhAi2SXGITdMHKPKxMmfyHASIxYP7EWOh+0xSdN58eGHsvjTJNsH/ZJ8JJ8g6OPEn99fNWoDPQKRA6P4TZhHJNY1Dyv2zUgWNZwN/gpadIzlpu3cRNM0ugntEejQhhHNaIiZ9WiEIlGi6yR54e//I2BPWCKSKM6lgb9xLcEyJ7JtdVBXVpPLC1JUYX+XFm1jZcGxNvv1cCTIcd39KM1EoqkQYubw+T8WqAu9P8OoY8M6l/DHCmU+9MgjH3pk8Pf+m1BbxbLiI3DpzeR9kDf7F3t/nI7QDHwEVjf7wfvzrc3VoFyIiVjH89W+H0dDADRAP/ZF0L1w7/I1YvMAgDo89JdMBBJbo0VWVSAGjgDRhWhYVGkVvDBy6r4xRt3jBY0hSLyNFeQVyp16u+E0sfjpYGkGyy9hPJKX5VCzU2YYGrFc+tWqpBksm7NolkEMF5WWtCLDANhsLipHNPlqlee4yzhOEDkO4RtxFAohTLEkICs2q2oaL4miICBWYGlE64x4l4HwRUNAqRteKXJ3Ry6nNWbl5m/JIV0uVbIMYvnCUdHQFIFtRWjEYNHlDjvD0AxfSevykSIrAfIuLlAUMXl0BkVwcRyPDO+AFtF4nlMRr/KAzatzh2y4EtuzrjG7I4+xIvtQK2gb4PU0yHQjTk+weYFwd8jlEYs7JB4B/tBJwB5e5NKPAG84KSqa+MwEzuB9zpANzJab7k4dSDX2fUvC9SpXXE70qyWLSEuHIviU1AvvSbWO70q/Tr++vMX3MEEwrMoEQyo3svAA/wViwtFugR/DlsmPQELy9IzQ4Eshw9UlHu3lpcFZvdbvnzu3sYGrPXgWQmiiuj74C17C96+BjzyWTXrDv4nyJ72cJsrH/1tOYEQ5RPadKBSXtVE7d26irAGecuBJoL5OZkHrQawJF7/Hq8S3QaKoVokh7pGCg7pP7whPvZr+yXXPf2Cw8Wruun+lX1cc2zXDMzTQ2CoJHcZD3W996+mF5z/w1a8ONu4Z6qz7JN/h3K1E7aNe4fuPkHk0NCHx08fl8UIQPYeotfBL8fJ9x0/r6x1FdpX3Kq7yFTmrTPG8N53O2goTjjnuOy/Vj3m63b5P1+/HmSD8+yMlqyQ4wZxJT8c5JpKzS1OX5OcsXKD+Hui/Llj7C9TGc8iX0RIKvNCyfOZsr+HPbyWdRo6HENJJtS9Qj9u3EJmi2fkY4hCSIghB/Yhc69uIj2KXRAsREpfWCfYr8/P6kXOwIU5HftSS4cFWm3fIg/I7aTNy5I4jAWTbYAPLqrgk9Hrcr3Xco2vUCnUNdTv1GPVB6lPU/zmK2OOr14mhW3uITk6sDkq+Jp5YxxFlnLA80imRkRjsF8CNDXRLAsSh8HjQM4HqDmwbCrztKyMKeQhjlSdG37Bm4gRKqpF2qgnxMJp4VG6Qgok6Gw9ExD9OgxDlDm43MAEA1aCG0OvlkJgKi0JEloV0WOTDqgzKZ8bWBE6m+djgP2U5IojhlBiS+TAvhvF4wwmazYCqWg7F+Mssl2GiIYM3kwxnhMKITYUZMC2VhRBDmyFGSa327EhcDPF4moilLpUPifGI/YJWNAxjFv+Kmm7gUZ8FMQBvQyEjEw4ZHJM0hUgoyjCulWVCgsxocZrRJZkNmf+RzERjjDiXsOIMf1nMVBm6GM2xqJuYE5lYNJOM8kz8KP7EFGlGNWPuPlRJFWO4z5TSFfyNQo8aGTuLaFEv2BmEnj3eyWkqw4hIlklYNS3XeYXkzM9asqLI1uy8I8kSYlSVQdL3UNippEtYpogVUx66qqCLNMra6aiCUIaMv+N+ksOz6qsgNtl5vYPb3h2c89r/Iu3d2dae57ff4K+3N1jzvBaSLtgin9vG9S1cLk2y1tjGz/QFOPj6rZwKxhcfv4OidlOvpz5N/SH1rwi8EHFXx1PRhS3Q/jwWtcuOX10nYEvbBlWnhsA6m8zH8A18eZdvAAScwmNOqz30tiTvDn7BzAwEgvOjwFj4GTqNhjHiwNBjhiZSYKfFYxGmTSRA3EYmvE0kJgwWDvEzjl0AkI9yBybHnXI7eLsh9JCF86IFDqieRqRJOy3fkGSZBhsUMMTC5EOow4KfleXZu2gSkG6huS0zMFPZvNWKp/4tKXsxLPSwLODK4vcNpBihaJk5nsOXGAgmQCN8iF9XVUh+WWLYf+JjQgpLTHisF3FqCE7GIppj+GUjDMEHaAbLx/gcP8syNC8ZrMMrIV3i6Hgni3QVmSoW00QlOcXTEKCAU0XE0YpIM1ykKhqYApFTcY5sMs5hogwRIYMx8HtxE61FFCRyiFbCIEBxLMuwDQd/sMCLlUUqxMaTQ0z2GoXVU0zIYMM0MkRcDS6exJIdy+OSGEFCvb8QC3YxKkiMzEYZmpVFHYkhZCM2bEeiJkJ2VIvjArGASAsCj2wJiUiRZVxRV1Lwd5PFgqYiKDZ+NThVQ5yoCrRiGEnV1LM0CZXHqpgDtGBwmDjaMniRRfghV5KVjIzJ1WmwdIkWVaMkFVglhOnCTFN4wj2OjoQUIcPRalV14lJDotM6D166uqCGoE0YltEAbkwSbjBDqsvaqsHj7xVikI4wbUjOJBWOx7w3kmiUB5cR+BHW3/D9WKFeS30Sjx31/8K74TUJtrHfwWncv3H61kv38ILQbGOptnDJnRktvfy++hU8hdJk6HUZ3OtoE/rUhbudhpsR32tme5fWwx7+X+4+sqiQDsCHcAegBVqKli7SBfDMRpEzl9bg4zUKkD0pPGd4G6B32aRJ4TO8ApFC8yRcDR7+IUBlA7fJ0BqCx3Ulg1zTR+XJVxG0TKvTWkH+08sATN1pw6VlprXgDySWiVvTgrbFnznTJrqhLLJGcXLI//s+2lpfb4kuE4GBQhBw++BasghVDlQQh+dE0JaMRPMRxr3z7SwrGarGcBzt8MQwHjMdt6IIoA88wWTQ9FRaD5FDMtDQIkSkZDga8bwj82rIwK/fv3zMdF0T4giwU7LoqrzOsRwKpZNTU8lpJNEJXK4jGiXc0JzH07wAkUlEQYyZ0M48Ixt4R3OYfhnI5SVVwFKtHrIFVeKhPThW43ETYSlZVvC7Lssx/DSmkRVwbkOfQmiLGpm9vbxmQMqls+zopVc0WJ/16VIolVqi3jvEd/QNqYT/X/QY1I1r8bj2xf8dHQd5UHQ8Xv/f24HoiXbava2NXnZv8tmZunRuDpnwpy+rb22NzRgh83GC8cwAFCnBNOgSE7q1wXoP9fXBukviNOqgO0BrNbzVt+LVEd8iyAWAPgoR/+nu4Iwf3rFfG5yDmRU78j8yqQw1BX4FKI2/UcMQTMAp8kHzzfMhcIdvN1IHQCpLwCJda2GZbiJK/ZykRu3milcsLITDi/VXHDt16tj+B83n3VqpGK+qn9O/jmWeWP2GHeihb6jsXDSS0Evh8EKh6PUW686pT5/qrdTP0bqeaV9Rdqv/948XtLlwuHhgpbw1dp4EK7LRETnMmIZzwxLHJfX9bBE1mZvvV7yJ80riufMhnBvEIBkHqQXdH3x/iUU6+CkGYRqEKL63ANyAu5CoQIKXkBcwWEzYdPVQtB8N6W6UT5xK8NEvqdyXOJVmlVMK+0EkSFiU/xIW6CUB0aE+/uo1bylbe0JRRY6q+6zyLc1XlEOhcjbebMbxSza4E3+k8Kc6V7GnZ6t1LsKyEa5enZ22pnIsI6OAL6O6XHJNXpLMn0LUxFycrNNEIx0vhPQ/eYGoKfYN/u2J9YlYfEE6CtbwCED0+F4X3+vC6mlp/ILijnQy8uijkZOfh83J8zFAz9N3TOjoJvUeXzkJ+WxVfXzDz3o7Fkx0Uv8xVqMN9SDkoZEqhGQ7fG/WMd9ZYuliwTiDPOS0CoxjjCAxzAZaf5FaR9Tpt51726+RFXMAVllfH2yuI/eZtw3OvQ1VyDJ6xg30W+tE7wZIthS10DC9Js62ODQjqrk9kt9CzDRjcOquQVbrJpxTW2IVgw1joEFHTYsBRXATrdBLdIEBPHxhG5XuubiD6cS5q8p33v4D9AH9e6HHRwT3Tw/OxWKgqHyFqv7kXl0fnHv0dWv/qaKpIfHU5FgC2DU2+ESTkqNeM02H6VEtbDDcOKOfC/3jmfXvqbjURlAOKSaE5F9x9bX/VGLr6yRzGow2xrpRf71yfoSwPQO45IURynbOKuFzBtewNPSGI1ebDdQHG4Dai1QN9i6By6f0TUCCWSeWgDUd1jif1YxHHjG0Z0MGgTEfrG9svPnZcPhZ/fjxLTpafy0rC7iaOVxijkQacIY0AYK0T1Oz56vvcGluDpZLc4PNbMiMagTdYxViJIQ+ErIef9zCOyN4N3Df3MR9sxzYTAG0cn4+iPXCwK7VJPODKAnu2FxG6AzAauTUpsroDUZFIbo5x4TW7lxiVY1emGNiTLrMxT+TrKSzyvyvKipa+C3V/eeQNnj+g4pyvRYdlvsT3H5vI1YXW8qdKHWy0HXfqmIPTzs7aJXe2ab51ZuW/SOVzuyiDWhChzv4PBZMbvour/87Lww+/iWOu1nRhvivLp5LLUIEqWhgq4JLBTuLgrDlYOJCFXMVPMJ9Q+pG2/HRYQV/NY9P06AeCVZ3699NVeJmh2VFulrIwjc6XmrhHVMtuiwj0nE7kzHRXMmd4Wk808xmLT7M8JFILOmxHBc2FVV7PQpNp+2i2MN5sHtnWRGxhStZkYdDms2j3GwJi0J0seal0WPZ6RwdToa0SlKVsYSUCOuKOhzvhnX9X6/py6nMy6A6WPfp4T5XI/r+cbQHiiL9IOePFfhDB9Hohx5HQ7+kn6bNRPtv6Xarg/+odru3dFtPt37cubrdvhqxV3fwwUMkVNEhYun06YljVNtzfA/8zS/ncsvzQq/T6XW+1IHdDSTq0Cyxe7InjoP5+fZ6XLgOAe3sNizui9H8az5R5cAiC+j8a7Id09nNZrvzD/kpyN8hQpv/N8I7hrV7DWyLl8iCQcsRWiTMQSevsWks+Detjldv3LqxUZ3yiubzU3u9lMoXXnHgve+tuccaC2yv3++hqLErezaaLpbSsrSruuf228d9zM9/e+7jHLflMvEtfgCsbYlXQROe8xux1TR/877Dh1urq3MrKzetmN3D9x2e7S4u4uOVudbE99nA430erLUCE+RxFtvNptFu8/BElr8/8dXeaB2eyP8/t9pQT36zE1u8AkAQ8zGnOp41gkL/4H2HTULm6mrr8FAXe7hFCl1c7M4evm9oS7RBdHHEWs7XnPhduNlod3yzqoW19bWOdGCf1Lz3vffee2jXrYZq3rnSW0P9tV5L2r9fWjh0D76zr83svGJtPfhO+JjFGuXiWchtgLgHsPRlr9BxChkEnlNNwWuCEVdgBN/5aYEx8mQFdRQaAxaNRqEx/olW6NjeBpspe1l2aiHv+EeVZMKEO7nCG/24EiFrW4gMnsFzGpo3GOEGxClhCU+r+GGUjDfhUdyquo1GvPR2s9RsJksRuIK/WGdC5rZYGXi2yFsMmUkGwTKG6yrD2BjTZDb2EnExhI5HONT0hCbm0AqZFQN7HH8BvjAMjrG1EjO4gubCFJv1yhm2sbeKt068kIvB5USywmaRu53gT+FqRErxRsOtzjVLpmOR8yR1PoYXEhxPcJZQx+pEPMtDZ557bvPMGZ3AeN1119dOnLgted9jj71IPfZYnzoPx8t/xofxGicSiZzUJTL7HObJQepa6lbqBPUAfhzWu+F9HZnmE+9YgGJpd7TAvt+3QsH/S+BGRKZofnhTAhMq+EDXvDAMtQjXPIJ17U1cKXttlKIlul2PxoU5w5YUrfDagqZIisDzjbyYOPLmI9V5L9RsZwf/GaEhrqnGyjyj0sne3nosFFM1PpNUvmKHvLgq7SpyXIJf2clocWev9T58ixe1ZCEdNuZ0GYvFNNIdKcwm4tmqYzkh1w05VrWUzHaaM4eutxcPHlxcWEnafEyX5HydDTGYMAimjvSpcCqkq4LIRp0bDjKsCj6pspJznXCSiYSTWVpN0WGRjxT1imLaXHYshwJ/I3icBRw74Ov5vBsza4JFQ950t7Lgzybq/Mfjmn5wWMXu9nqUJgi/cUxufoJOekIPH8cjJwH9I4btPoSu/xnFrY9i7AP5B4TKzMqNNz5+477CiQMHThSK7xNelX8VF7/p8RtvXJl9U+HAiQOF4h1b8w1BNIyS4I0zDQeeN6AKR33n4akOyTP3Z96OxV5vrec4D+duhBzbU7SHz3uLOwLsUPBnU4glMNXKgUWJVcBiYa4FekwsAOPjwuR1lJTb8s03483gb2CLkoO/gSuT1w/GYm4s9ssT2wBzbYNgrikTXuljnw+KwvOV0Sdl4rg8cQwU4bl6GTMQzPFMDlM1PMeyuhkNzj3Tv4J6rpshs5Da8OD08OAIigy+j9Bt6JprUAb/8BE+jxyHw+MIjm9wa2SmMvhhcPCOYM/rNNFmsLROv3XiGBk64sg6PMuhIRbkiz/GbfYUnsW3SDS7vEYLvraAOEu3Gm2iUwQgfWYX8jX80GM6WEjvZPAAOo/FRT8wDi/gmhWqCM1laiUzggjmLyrkMtOFZgLOGGTYcztL4QXrzjutZgZvFsLHdxmJpZrWfCbRLExn8jlB9R+rRGfdLFkF5OgV03CLNRpinNO5YjM2Ez96bWz6Xdcejc/clqs2po/Viq5h7VZs0P/zYywT6Is5XK+DEE8eE6wxwtZqLbN+lRwTAkEv5FvkQ0dqAyDqUMdlBHD3UFEPTcvL1eR8oiQZuCrpYqbidZL4KKKWss1MdVk+9q8IiMSXkh2vkiluHDuGn7hpF4JFu+RKo7r8A7VpGgsRF3/62lZEL9Rx+qy1YFsL6sGj8KQCtefpekGPWD93+UF14Taok4jmms2t+gLA0wXsziYZ7AudLIoIXqS5xBz5wQ+O9ITvfOfyebT6rncNNt71rnW2j8T+U4PNx8XU45Pr3ML4eXhqmP5C5UQhtrcQwd/KeRThIoU084Mj+BlREL6DXFwSPIe677JZtj/4iYrcx1Pi49S2soZ5kCdHj+A0eA5MvYi/1e+gqI4t8PMIgLt4r4ylKts/8iwzv4QC+KGW4N9te7BbQUMMIrJGSHTlsMmitn9dcCASLiRoLTTSaAhPZIGbPwADwzlZeSQFCSP8ov+AwOhpBn8UBJrlulEIaMqpki6pnMqHontAUwhiS1pkWCEthgSaESKhPXuUqEjjd0hITzzPcHuiIV4NHofgp9Eufl6n6YnHadFUut2QAY+HxCcYUWAjqorPRFsrXsEpUL5M50QxR8ucyincFUU9KuHbqhphBZHRRY4WBZrTiqUQFq0g7pgOmeC5IGRiGJAJfnCUB84QMjEMkRXlkD6Rh6AWizgPQaQ5cYyvAPJqnLrcj8NnDP1yCbITlgzDNEgDrQWu3QGnReAlFhlJ4As8GMIXz6mHEVnHxcMgQX5rOG3PEYIoThAFPTCaCiT2J37niUVaoGWUKZSPlbH0KuOzRTz9p12X1tRkkudQMp3NTelerhjHZ8mk6t8Lm93f6Zp76MNSCqKAKyrea6Ep36S0/8StR7u0SMt0Kqzr4RQ+EOnu0Vt/LVfRK7lMhmQU0uhymdb0GJxlMqSMnNPtOn+Fjqq6mZJURYW9eHBo4MqNeFSl9lLHqDXqNRBhvgkVJpgGZQ+LneDFDFj9dYK7buErthOEAMeSprBAooT7mDNwsUnmMYF2AOdSGPJ47N1FE/UNFtZp3KVhjetNGTqkmku/tGSqITqF0kjTrLiM4mbRzWuomM3ZMSVuhjWUeVhaoa8IaaQ2ENw79U6f407rYy2H8PqxhaXdn969tCAjCcUOXnkwhvef7f5KOJ9NOjt3OslsXs+7rh3D2Uf1EJ3P0yFcmBK38m5e1tUr0R4xZeqqCi3w44Dv3a7P7xd2HDm6tHv30tEjO2QE+WcykD16qNsdr5VukBhpYYiB0+zgqQsWi6OWg4fmp576VKv1qafa73jHO+6feeCJd9/x7LN3PHvnnej+H1956vD256NEzvEEyCSLh/yCJxTA4nIDnm9DTm2cx9TUEw/M3P8DyAbn9ey3Th1+7LHDp64crY35eY1zciaeHz01YXMLXqM7Rv6x/lILfG6sdgcWnWF6RT6oBTqwBrTMju8I5JvNNdHVjYc/8nATGaIz5UiNvbS7p8ZJzpQtGd88fdddBy9/5W/GYqIYC0s6mutccfVDD119uI1Ep4IT1NlymZ/hopJdccTBn55414m7Dlx+oxBzBMMQHNlg3jTikU/r/KVQCtbAXqtgwUJXFr0EfW+JYWk0HBNfmq5fFZyY8KY3MYaMyaL8+JdD+82tPnnEft2PeDpG48/C6AOI/AEufnsbKPQvGoZx2+JgY/fn8mruk3k1/9mcmv9CXsn1u7Oz3dmFWqFQKwAW7uAnu3dDYqOFE30BJ3KCB9xZSHlzAVIGfqYXo++SqfspVF0CPbjdWCwb97BsXKNu8a3IaB+gBr55K37sPvJJ890/YSpvB275BO8DrKJ8UKSCD83nkY9kYOVNTA99VVwb9TIZ1QlrXnumMJfPqLyNDC2KJ8dSWFdDCEw7EG1KSGK4mCAbTTpEy0o1zLJpPYzwpBwxDJiD5WtIVsUwrXNy0p3NzrWyhrmWKWoaXckW53cvFqMaUg2UiWRtXWDCKAnmSKaIxDCXucwIy2qSNkJhDV9kkigqqbM7kCohWcvUd825blmEd3TMk5fNkZdby0slfYt/fxTPKeZgRCj5A/oM/mP8TiH41sABgshCuwSIuFXGg5k2HvJx4gzCeYj3XcESQVokPu6RtSM0Pte0bilXQIM3rx1hUap7MPOne2/DCbi9twrXn9wQ8Tf+boGgVBw7sobl8VJX02AR9sha5mA3hX5fuHUvd+qYeNte7iQ18sEEemF8yFDTsHbccpoM+Q7VMSl1nigZ6gudOiav3m7WeUA6BUJ5qw3BFXzULS8vfBNxx04B2byG98LdV/Dy+6FQheNOXo8+ferYkB6F+4NvovVTx3SREHuMxVTfJ6KvQ3XQ9Sc5TrnzFN4M6zpa1zSw3MhDzPaO0Cl0msIw6l1z2+r8FuPrYXy0YIX7925IL4QP6otgeyyKYE3Ngy217kwYWSsKMUp2U9P8mf5qr3Znue1F0pUM2EuHAO2L9m2oI0OD5EJiC40C8R1q4oEAU+k1hV1ICEgk/pRpFIRue3/F3gvUXH+/bmRyUUISP51yq9FU1tLOuKurPb1W89rlRKHqisg1bZjUh0c6MGELlnkHz19X8Az2chIFd3W8ekkFyzvEgBQBWgZ0vEaHxgIE/Nr45wZ7I9iz+Fee2EM6LK8T0RyE9TKWuRtYZsN/6OiypuvaMpHbxoc36mCmPzitH8Q7iCniu1r19A39uKjpPMeVWI0pS2idZDP4wfYMyCG6Rye6szPgqfUMPj6r6+fIqf93zr/0y2HhlCie4kVxReT5FVhVG/EIRm6bSlNFwqf9mDvXUjdi/pyYRMgwG3xjIQ/owjwEvvLKAm93yGFZJ2cOeB3DjQKc4dmqk6GbltloOX7iqP8oHm0hbXn8jM+kv9NxvfUiD0tcjMzyeCKg7YBJA4//wazgKK6fJnJSGV9iSxyH8MCiH/VTKFhax6n2YX7hJwUNLrI2Zo7PupsxI+6GdKLwechK5K+BBIw2+B3yABPXPyCExS6+hNkDVmyYV46fBHWAEob9e5GQ8VmcB051i75Ff22Aj3nHqzJtGEXrZpPo7ToB83xfYD+QEhb+v4h4oxynlzJpPJfFY7lKRq8ldfGh9YfuOqSfoYX4QoGesS2E50Dh/0mWzPHdI72HHuodfpC/bW27D5UJiAHDlurwWPYl60vzEPIKXKitZouEPSJeN95wZf6VaMa2kajIYZE5vr621tP33vLK03c3lcVgmd5Eu9N4lhE2Reaba0d6a6tXCyf2HXzlKw9e0VQX14M1VF8O9O0CfFy9fQRVb5v2qUTAFMGdJgCN9DVBze0+dt44WaGUGyd8zaRSauXF3Px8DlG5+ZoLYZ9epGCLzIk0v5ur+Snmc6D3HaXqT2iq2gTgZF4naCeLZy56J8D+3AjsFGAtjESXHmqrShP1GU7WioF0w5GrfkWGPLkyUFmNSU/49TpKbgzOktpM3PCJvtKnZp1Q+IfnXxrGmHaJfj6Le+QcVSe2RFaBCYxRmAJx4t9FFABe4LacRIUoAcRsAZpERyh0Ck7Bw4NpLKK+U43ErF5EPaBGHr5DO6A96XzHCb8zfKu2Q9HkOxVNQUfCg++pkYiKCmET9ib+pw1+FeUHf44/T8YP/H/BfHBIW4ByASuAFyDNxzXAV5mmVwDfp2anIJztXYgeVlO0y7XdFyZEG3wpKH2r3i8JMkeBSEOW1yGrKgtVXL7gtLDs05fNojdV3di4eaGuI6N4zeJ733vgFT03u8uIIlDZ4RH/iODsnC3tuf32PdXtOr9tOW/JbmsmW3AWwj66w3YUB2+Mu0AgTWDNGNAenh6CORz8iY+5oPsgD5NQDr0AeEEUAW5h8O2zZ0fjRpfgK5F1ZMC/vFApzgTKw+mt5QT4DqfdtS0ljAEeRuvfXeKjvS0m0DwK4reOYwL5MX0mYgJNk7A+P/rRRD7CREygZstHG3AEEhNIJyGFFP/5j/3ommtIVCCyTtNFH0NdzF2/z43tVQK7EPBYH8a2Bze0FYTbTbAchOWcqPY9zbbC/ygL3xMUFW+k+TvuuKbbRd2o9gXNsvAm+r0vCJIkfEFQlHe3Nlqvyu3NjWK2+OVGzy+T61jeRP4odccdk1lejzOiAtrx/8A/OO0jegEEJNl0ghO8xx3NK7SQPT2teV5FS6c19wjYuNjvPHBgJ+rufGqn3O63vyV7xz155j5Ftru2nDp45eLGYm8YE7qPXHhDofaF1k782N/5d4d2ehtET5YnaAiWH3/Gt7AHDfcuBPWDlWRi3eYV+ABNdgkVAmirew72egcrqpxwu103IauVJZP7EGe2OJmW7JBgr9tCyJZ+7oO6/kHHleTkLItFO5edTcqS+097stk9f0krhiw6JZYtOaJsKIHN3ZCuS6HqYjS8RKm4/pHRd1YhtlwpXNoUnlO1sSy5B0uSV1PXUzdTt1N3U68aWkTWfdRhC+IrekQrWAA1oAVgqc0CgU8VnIIPrQrblgW3mySSUwsuFJq+2tAjERptoixsE5zWNmM7EMmBZHIWTC3hJx5GcqJccuRcRC/GYkUvIaMrb6GldKbC3HwzU8nHJQ3J2Tzc0yM52Sm5rowO30LLydwoRbnSdPTUh1tlvRjeV2nGw+lnm5VYagh8dur1V1bLvEbz+RlOuoKndZovV1sFMVLbo++pGUKhVS0LNM6Tv0LiZvI8HUFiuVr3xgmuqKixhrRHrUhqbfCdipqoyV21EpIaYPEw4nEMz7EKVIWga/scvhJLozdQt2Fp9H7qEerkVi5HiKRQzxMwgKjtFFptX9fa7lhlEpwRGAbKRYjN6FhEsdjCv6bFkxsOUTwyRN+Ij5v+I7zA8BZ5wldFklTlEcNBEus9tHZkr0jvTyRylu1ebhayn4g7ml3HQlsiVWL+nRZihaO0GMsfFuj9hULBjGXrtpYyi2+2whkj/2mRPsqUUne6tpm/UbkOH4Zx4nSJaRiZsNUYBTd/GAuFD/XwTDWanduPbpf3cLTQVa6l0yFhzlbfV82L4bmd9SRP79fnsnh7ZbK+n15Vuhx9tT0nKkV00KpKcuGf89Wdc2GW5vbIiJ8t4uN7qnlBn9v5iCxVrZCPb76Bv2EbRA8KmEnvoX5hYg2sM0Qcajd8lA9jm80O1wbzzwWycL1tUyDYKTwoyrZvwHDUhPis9vbNEmqCesKDFprcEMSpbndtfQ2sYDarJ6pYAsq85fjxtxw/cfLo0ZNHEUwGuDgb50WFVbB4q4RDGstzYU03FJZntVBYDockhZUFIcbFGZ5jY2xMECRWwonlsCExAqsYuilxJLESlhWcWOLj7G98DIV3HOthWfnYjnrr8OFWAv+DBaqTx4GAPzkKBNxqKEIoIqiiLou8qImWaMpsiA5xIZ4P0YxKq6xsipYUEjlRMkRVkE1BMXB6QxI4gaRXGIVWGHrrA6Im8KIaFtXOxz7mj8s/RL+N3k6pVAlsFPFkAwY73I1xSxVBhxNGdR7GwjYe/PKt8gpqOx3utVM7Je3K9FVqvoquqhofYPgGOB0tlMGkf5cY/szgxU/unO2GuIgTKnqL/1K1P6NJOwGJAJUbsHxV55gPfH2IAwM2z+BZDl/4DgITGscTuLGWf81F0Z0ff/6ZDz/4IDq0VGwUMmHUdwf/oK5vPPPMgw+ae3PxQiEerkcmbGYNgnzawiMrrFvx/qKVv++0bY/UEi74+84yKo9m8b7FUCeI4EOgo3x06mW6kUHoIU6HyR5mu8xLPCOHY43f02QGH8uSyDGiwOic1JD8OXttDXextV+VQhwrctGaled5TmS5kESH53fOhz8RZhHNCCoD/YdmQ1LYYKQQPuJ4hlHBmYINp4w/9mfufwVZra/dGMJdK67yggBJw6YZ3mqvq+C6g129kEUryHMYwWM4ryAUkshreptf8H7hF7wvbFZ//deraDF5Klnp9/+Po9Oof9nf9np/e1dvcG51FennFhdRbPB3qzeOsXogbxrP1cLE+inItqmgZqf5W9PT00GGOLdK8tTGjTduDnOCfBYn2kUg2I/FAPPHn2vmBQfMhqrIDuwNPQgERmBHeadBQhWBPPuW596C/zZvaLX5uvtB5zrDW/S8xW/csLdtKI3k1bHfOHRv6AE3hNZJwlfsvzU7NVX7BqTx9u2/S7yVn3uy8jf3Hipl0uWYNckzgXLxl2IflmIDIDfQGPABsHm9RdwmmvAFgChLwhC/3LG9VuBOTG7ibzGAeH2YUPWvzB1XmjJ+g8VXhtwPMeAM8x0tfPVydZ8h63cnHsHzvXL7VheFVDWEdPnrbp3/BKH0XsM8cirCgnPOZ61YOS2ZpiT9PPdkqLrntlrFdn599hyaMkK1aSORMGx7Kgvr+0E94mRO2QjskK6nbqXugt4PAgxxvoWlqaXAZwbcFS1/hWoF+ejtvocIxJFt+ctYYUQUwcR2geiCyyQfq4M/fduwVtAJQTSvtUTJusYURfMaSxKt607QYlak6crPLGfxp5wWXIG5O3MFI2RFhvYewJN0PFiITNxj1FvLDCtkROaVGZb08cFfkdfnx6x4jciFFvEQprU1TuxJnNaG8WzRayOaszmaTixPWTY4tlocw+Qq5j0txOBjhBJ6wmHBKZeOJNBVywmGGSb5PfIenSYvla9/CPgn4/cmS/Dj2lSPugl8yTsQCsXz2QWDR4esMncAPIswFH9++HlEDB/a+Hj0GQs4SPiF+U/4TBJ57SwSWqQNvM7/xSxnPZoR8QaLRLcygrufvrVCY7aZFY9hvIiI+cO8OpOx/dHkfsG8Djg75vG1pniEZcq3MmJmKZM5zaDWlJVAiLN20jRrLzeh1kkatVcSmEW2nsT3EgpP84jBHeufCQveeo3IEhaHMIulnohZrAGLQ5zLMAk/C2SaE7HqdMynBOjs5iE8en0FFTw8t/aapRweFUrRXNRBhTvvEGpsq82tsa9jn2N/MPgK6hc+/GGUygyez7zxmv+vtauJkeO4zl3Vf9X//90z0/O389f7O5yd3pmmxB+NlTVFWqJEQ460AWVmIcU2wcQGAYe2pQQRKQkBIueg+GAJiBEwgYMcEgSED5YNGzYPBoLceLCDILERIggQ30wDOeQQLPNedc/uUgF9iRvTMz011W/q53XVe1Xvfa/ZfH7VcRbTfPvFg89vbdXI5YO/HjwSDw/XzGNof5HTLPpJrsIJk9EJ0u8QhGxEckL8S6D+unQd5AZpor76eZIjvd3/2c6nC8dZfb65XF9DXfUUSNhC0IMeoSU+XPVBSiCHMh7BGXqKFBtk+UFK712QQaaJWq56Q0kiPCt0NAx+ssRg3/mnFwYrbq/n4rkyeGE7k2fpThy5nxOvue6X6FfcKMlbuZxtF7lWZFu9r7K3/1C9sTLOCi0vvjmFg9xMa1PDc50JnOm0lrK+GvjrluN6Ezjp0A/UPnPNj2mtljiZTMxeC8ThGw28vHHkc4D1HeLq+GMKmh+vzru8DMOTelWGbxa5fnK41XtXffvOxCr/IIU/MG7wv6UT4ZG+Qr+ZOmJuLrv/BKl6izPIU+R43/+ehV12x371NWUizmcKuX3EAR9+fZq/32xezIA3Kj+xkn5YUSdFRbaPZPtZSdiTfmn9jTKbixPltVftO1JJkjjTrwMPZM+nzffzyt6itH1zQP96RvgsYpeUoA+ZyvesZvB0owkWrnvCA947wlR+NBtqh9uIw/kR1sBIkJXhBdLAhVqUX25PPK9j2FLs5PWW+3qnxpxavXaQd5pRtNq3/DBodTK1s3a6nXpBVq8lgdvqNPRub3sQdPtJvTH4zd2PFQNntLFTb3/642TvR+txSNtSPX3qJz95m51V2qMfs0Y8aiaRY5pe1LBtp2untawdJrZuNNzYtoyu7roLL7CdwO6eG5+OnopGbmj0djefXNoZlm1j8hW14+1Q/Ora3Tms0GOKe/WwjI8vgHgYV8UpNfGPxMnKg1lfxQi4MwSeLLhnV+mycsBdgX56cn39JJx/em795DrZ9+2HAiYTeH8o3N3dvbs/n+/DceR/eJN8A+bJzwlCjODmuM7QIfEUpFt44iEBRD4YFiBpziMblfGxMCd8hUwdviyAlv4jjt4YtUnZIujmATzB12lmPAQQbj9iq/2jz2ZMtQ1KMyKSb1AKrz8X6aofwjzWSJx4zfP+onx1tzIpkmmteSIY9AdZ71lJIqEsb64F/dXu+rArd2Uqq5QmhLxC6fckcoXSK0T6nkhqzDA/lOUP66lR08MfhPpv6/DCiyt/0KvLkme30Ps+maY5kaQk1kA7Cetp91F7JBuej4vCNdQGlqw/OkQxUCpklHnxiLdyX+ln1dZwCS/MI76UsWDmuFkcJ2KFp8Dp8dcSRQda8GuWpuuaZfua9reWpvmWo8HxRz1FMx2vrgVeQ24OFnLDC6zIc0xN6YGqYW3uxqtrUa3XtCxLfHq9YYb2+pSqLYU15JoaaPW14Uv0U39pOTCWWg0/NC3LHjQs24OrL46eXE9akOaLjEpoB8lk1wz9VrJ+amjXs7Z0QlE8F2Tzdnbwi/DMIDFFKnJ3Zi0eng38qs1UbhM5AsnrkyAzCIUN8woHm6mM4vvcUJlH/2lRHvU07xXALPyRkss4qKDAhqiHnKGli+c8PwszEAIX9fjoPdu5FTWduKeIo/TNfb/ZCHpRkK4w+SroG56HCCSSGmRv7o/z8TYmwwwPN0Qrt3ydef8gdaMNMWtbNlkt3FYUIZpDw3+i09Po6x7m2LdWk5nbWLHhWJmvdDXQ0Xr1kdj/PtD2PY6z41GBfEF4X/gr4e+EbwnfxTXqyjaQd2qlUVUhQrlORflPiGCX4SqKgroXz2eX9oUFQrJwnItl2jxP2mIel3gyJZRMgmQKjvGUxAq3kqelNWEZBbW8SrZjeZ7ZKGXxVJS88DqJMRWoQaHmVKCWLoJwZChhb6RqTg0U4xVN7ipyENdUSsyQipQpxNcDzQbty1bkUI7clq6w1Gh1FN21T6s7bdU73b10ZTRU5MS78KyBNqaiqttK3N411bi4+imaThQx9aUosURKNUWJFRYRohuSxySqWy0Z9Dooie6eHvoHv0+keIMQ13Djq8CFUQjsGH1SiYjkXwxUuE/+MrMxup9khZZqGLHpyZIVNK3aoJ5YjkQVBQMsSk4krgdNRXe0sKMqREnHTtJoeSpTrDgO23In9Va3G0Pb9/qdxGuLLcTZkGBs0ZLNmp7ONja9Zlcmhi7XiS7bKlNzxqaENmMiy1RM62sNzE+kTho1zC3FVoe+DY3m7aOYfTKQpbBGIyb5lh66DiGHPqyo339G+LFwX/gP4ecwu2z3cAe3Ch6GoCZcqHZIWGIGJZOoNJPJ+VMjTs+WkaenOPvuzIqd+c5ZqThbKiezHa618MGkj/Z/Y1JGzq1Us7gyT8ZhpkP4iNXjYa2jUr2DYagaiHrLqGY9pYx6nc16SzyHM+QQDoZDR5W4UhwSJu5xQ9gpGr7iDv4UzgfFORUaN/SpZFJG284a65omdW3NMIkoEURQqbHQlmpmrQanZEdqDdIQ+ECkimzItkvI2F9z2lSjpkxdwxKJeu71d7Ih5LElJpkeoSHVqcHkgTtyFCMVZQV0IhDzPWAVkdiaYxjicHeImWzdhiRR8RBHCIEexNRQnMwZSKoFvweUeCaTFINQNnz36UQxlWAawPtXuosuopXrfVklpgasYun1jOkI8gCMJwKxENlfo77CmOJTTSRQQ4VyQ3WsJzxCkpfVdUtDcCCiSH19/gl3a+PJWAPuc41Qw4LJEvF7NhTa0H2MTUsc0SSEKoymKWGgwxFiisBSoCb5uu4Q6vR84HhsSRYZaPJreac2PuAFx3K3QVidHPqPIP99QfiS8BZaQw9//Sww/xUct9ya5gYLPW67MF0GeyP3f43dlj2WNw7+09Y0W9s77NXkaVam/L9ae+txnfgvdmjb4WLZF8mMfz/mZ1962dc5poXaV0GaQ9xgNJvPce8Yw3930R1vsdgn1w/uXVrsdye3JyDVP7i+WJDJnXsHDxaLS7fgONJDSrpWhbdRUeW7vnAuqd07TuZ2ReBofSsXzmMM9gAGpJh7bpXC/3K9JFn2LXCAXAmNOFdXASFwtSQ5VBAqn2sV7a+/RVUVF0ZxtTD0GzAFOFRmYpfqBPT7hkbaAyMBSQN0/ZiQSGW69tYHTxQpk4MzlrkxuXiyKO5/+9aty0X+xmqXjOTQhQdJAXpKGHiWJFOPAvP4RKZKqDkwwjgwgLiuKUutVj1SXyiK53Y2LfuJQMJJ8+JzxctvfvvNNLsxO335OB6HKSyqVbllyeV5xe7lAhIX7Xh04WwHUxF/QkErnbYM7QPt9CdHpbzAYH6jXZHJUFuJgfCFa6QgPWFjSJrOcGaLRZGZrpcYgzbRGuT2YbH+PlSoDDWCocSjMNt5QajA3VBr4oayoUb1VkuSTTTmkR1JJI5wTF+s8YhKaBGvHoOUwNBsWQ76Q59b4oIGCcyRLOObQZYiBzaZXHD29i7t7dmfmFy/dP36Keu1jTfe2HjNOrUb7u1N9vai3yC370063mR/f+J1Jvd+9rP7te88ePCdmrs5cPf33eHGUgdfluXxJfm/f/dR2lVMjYf3QJ+/w/dwV4S5sCt8HPTX38J4FI/a5irTeRGqUYmjjrjloTxT1L5N0Fd1lEVVjM4zBEYi+IL+Xvlc7edFghNwrwQu4jZG/863Qn732oUL1y788J1XCHv5rZdhAKilW1Sud+sy3UqlxnA2H7Z2/niejkVzYYrjZ33yPmPui9dedBl76Z2XyKSMZ1Ef1OuDz44aK+qDdDhMH4ihxhoHlxwFF68V5xLTbdv48uUguOworZby3Ymr62GtFuqgs+IN5ThetoEoNIRCeBbU1Z1uSLGeYfVoVtvFsyjMpviO/ij4NsZgnHwAH81QnUesez7WH1WXLK6885JljzvUttEGdavd+uDpK5TIrfZYbHab4rjdYifG/8qYt7Z+dX3Nq6p38+bBPw+aN0Hr9kHqMU3LVzwvutn8r0GTSbYm70eepzhx7GDyPkNs75/XsHImHFi9WnOwxMt9eBfk67vCFO0uCQ6C3IfjONtwMHTcCsv4ENnHHa4q1mZRmrvjnHL9vdXPWKc3z5+fnD+/dcqKByuD8ep75zbg0xvl611F+/S5P+OGSeTue8/9TrN54hm2M14sxjvsmRPNJubfeu691XXMP0hk9srBf5chnLCMv+D2SxjTQAjU5CkY83Ix6xDuJdTfHqFFRrASQBHjZPq1q0Y2ovZPbTrKjKvMSnr5F293EQvWXXRvh5sb5FqnK8mjh8LDkSx1OwZz6LnJHjv4N7LC9iYcw/LIR8DE5+iIeEHuHicVkX248T7p8htX/xcpZ+fhAAAAeNp9jz1Ow0AQhZ/zpyAhlCNsQREKb9aWK3dJUESKtOkdvE4sJXZkbxSlowSugsQJOAOcgZYT0MGzsyBBEa9255s34ze7AC7wDAfH7xqPlh108W65gQ4+LTdx6Uwtt9B17iy30XOeLHeov7LTaZ0xu6//qthBD2+WGzjHh+UmbvBluUWfzHIbwnmw3KH+gjEKaEQwPGMILHDgOSRH2JBGrEfM1qxXlT1S9q5IE+TIyFUssGRdwIeEYuyzw3BtEWLAldje5LdXomQmqWrqV8C40JHRsVgcxDCONmJURPFaH8Q+NSsxyTMzyYulFr5Uor8yZhsOBgnVpFJlmchMG7pM60EpbutYUsiz9DbPSLP6hSl2fBdmOk53jKceEXL/9zuqAVx47HO5FSmg0Z8bhuJnLjFwPd/1lRecvN6cswtKaV0S9K2cZR2r22CuizLNM6GUJ5VS4pTbNxD4cKIAeNptl2O0necWRrPWapvaSt3Uzn7Xs1Vv1raNFClT20hS27bt1LZt28a9tzP/bn70G+OM7G+enT5jzrEG+ID//fl79IBBA/7PH3/nP/+xAW5uYWPZ2DaODbRxbTwb3yawCW0im9gmsUltMpvcprApbSqb2qaxaW2QTWfT2ww2o81kM9ssNqsNttlsdpvD5rS5bG6bx+a1+Wx+W8AWtIVsiFWsWJqsajWrW8OatrAtYovaYra4LWFLWsva1rGu9axvS9nStowta8vZ8raCrWgr2cq2iq1qq9nqtoataWvZ2raOrWvr2fq2gW1oG9nGtoltapvZ5raFbWlb2dY21LaxbW07296G2Q62o+1kO9sutqsNt91sd9vD9rS9bG/bx/a1/Wx/O8AOtIPsYDvEDrXD7HA7wo60o+xoG2EjbZQdY8facXa8nWAn2kl2sp1ip9ppdrqdYWfaWXa2nWPn2nl2vl1gF9pFdrFdYpfaZXa5XWFX2lV2tV1j19p1dr3dYDfaTXaz3WK32m12u91hd9pddrfdY6PtXrvP7rcH7EF7yB62R+xRe8wetyfsSXvKnrZn7Fl7zp63F+xFe8letlfsVXvNXrc37E17y962d+xde8/etw/sQ/vIPrZP7FP7zD63L+xL+8q+tm/sW/vOvrcf7Ef7yX62X+xX+81+tz/sT/vL/vb//u93Dx/Lx/ZxfKCP6+P5+D6BT+gT+cQ+iU/qk/nkPoVP6VP51D6NT+uDfDqf3mfwGX0mn9ln8Vl9sM/ms/scPqfP5XP7PD6vz+fz+wK+oC/kQ7zixdPlVa953Rve9IV9EV/UF/PFfQlf0lve9o53ved9X8qX9mV8WV/Ol/cVfEVfyVf2VXxVX81X9zV8TV/L1/Z1fF1fz9f3DXxD38g39k18U9/MN/ctfEvfyrf2ob6Nb+vb+fY+zHfwHX0n39l38V19uO/mu/sevqfv5Xv7Pr6v7+f7+wF+oB/kB/shfqgf5of7EX6kH+VH+wgf6aP8GD/Wj/Pj/QQ/0U/yk/0UP9VP89P9DD/Tz/Kz/Rw/18/z8/0Cv9Av8ov9Er/UL/PL/Qq/0q/yq/0av9av8+v9Br/Rb/Kb/Ra/1W/z2/0Ov9Pv8rv9Hh/t9/p9fr8/4A/6Q/6wP+KP+mP+uD/hT/pT/rQ/48/6c/68v+Av+kv+sr/ir/pr/rq/4W/6W/62v+Pv+nv+vn/gH/pH/rF/4p/6Z/65f+Ff+lf+tX/j3/p3/r3/4D/6T/6z/+K/+m/+u//hf/pf/ncMCAuPiLFi7BgnBsa4MV6MHxPEhDFRTByTxKQxWUweU8SUMVVMHdPEtDEopovpY4aYMWaKmWOWmDUGx2wxe8wRc8ZcMXfME/PGfDF/LBALxkIxJCpRIkNRjVrUoxHNWDgWiUVjsVg8logloxXt6EQ3etGPpWLpWCaWjeVi+VghVoyVYuVYJVaN1WL1WCPWjLVi7Vgn1o31Yv3YIDaMjWLj2CQ2jc1i89gitoytYusYGtvEtrFdbB/DYofYMXaKnWOX2DWGx26xe+wRe8ZesXfsE/vGfrF/HBAHxkFxcBwSh8ZhcXgcEUfGUXF0jIiRMSqOiWPjuDg+TogT46Q4OU6JU+O0OD3OiDPjrDg7zolz47w4Py6IC+OiuDguiUvjsrg8rogr46q4Oq6Ja+O6uD5uiBvjprg5bolb47a4Pe6IO+OuuDvuidFxb9wX98cD8WA8FA/HI/FoPBaPxxPxZDwVT8cz8Ww8F8/HC/FivBQvxyvxarwWr8cb8Wa8NXD4sKH9ypAhPCs8C8/kKZ5VnjWedZ4Nnk2eLZ5tnh2eXZ49nv1/nxX4FfgV+BX4FfgV+BX4FfgV+BX4FfgV+BX4FfgV+BX4BX6BX+AX+AV+gV/gF/gFfoFf4Bf4BX6BX+AX+Ak/4Sf8hJ/wE37CT/gJN+EmnISTcARHcARHcARHvFd8L/F+8X7xvfr8vM/P+2N+zvft83v0+T36//4ehb0V9lbYW2Fvhb0V9lbYW2Fvhb0V9lbYW2Fvhb0V9lbYW2Fvhb0V9lbYW2Fvhb0V9lbYW2Fvhb0V9lbYW2Fvhb0V9lbYW2Fvhb0V9lbYW2Fvhb0V9lbYW2Fvhb0V9lbYW2Fvhb0V9lbYW2Fvhb0V9lbYW2Fvhb0V9lbYW2FvJeGzu8LuSsJP+OywsMPCDgs7LOywsMPCDgs7LIIv+OyysMvCLgu7LOyyCL7gC77gV+FX4VfhV+FX4VfhV+FX4VfhV+FX4VfhV+FX4VfhV+HX4Nfg1+DX4Nfg1+DX4Nfg1+DX4Nfg1+DX4Nfg1+DX4Nfh1+HX4dfh1+HX4dfh1+HX4dfh1+HX4dfh1+E3eU+T9zR5T5P3NHlPk/c0eU+T9zTHvIfv0eR7tPgeLb5Hi+/R4nu0+B4t+C34Lfgt+C34Lfgt+C34Lfgt+C34bfht+G34bfht+G34bfht+G34bfht+G04bTgdOB04HTgdOB04HTgd3t/hvR3e2+XzXT7f5fNdPt/lc11+ry6f7/L9e/wePT7X43M9/l6Pf7ce/259/n6fv9fn9+vz79CH14fXH/O5f3mJ/xP/J55PPJ94PvF64u/E34m/E38n/k78nfg78Xfi78Tfib8TbyXeSryVeCvxVuKtxFuJtxJvJd5KvJV4K/FW4q3EW4m3Em8l3kq8lXgr8VbircRbibcSbyXeSryVeCvxVuKtxFuJtxJvJd5KvJV4K/FW4q3EW4m3Em8l3kq8lXgr8VbircRbibcSbyXeSryVeCvxVuKtxFuJtxJvJd5KvJV4K/FW4q3EW1mHX4ffgN+A34DfgN+A34DfgN+A34DfgN+A34DfgN+A34DfgN+E34TfhN+E34SPbxPfJr5NfJv4NvFt4tvEt4lvE98mvk18m/g28W3i28S3iW8T3ya+TXyb+DbxbeLbxLeJbxPfJr5NfJv4NvFt4tvEt4lvE98mvk18m/g28W224bfht+Hj4cTDiYcTDyceTjyceDjxcHbg4+PswMfLiZezA78DvwO/A78DvwsfjyceTzyeeDy78Lvw8Xri9cTr2YXfhd+Fj++zC78LH/9nD34PPj1IepA9+D34Pfg9+PQie/DpRtKN7MHvwe/BpyfZh9+H34dPZ5LOJJ1JOpN0JrlbkrsluVuS/uSY/nC3JHeLuFvE3SLuFnG3iLtFdEt0S9wt4m4Rd4vomeiZ6Jm4W8TdIvom7hZxt4i7RXRPdE90T3RPdE90T3RPdE90T3RPdE/cLeJuEXeLuFvE3SLuFnG3iLtF3C3ibhF3i7hbxN0i7hZxt4i7Rdwt4m4Rd4u4W8TdIu4WcbeIu0XcLeJuEXeLuFvE3SLuFnG3iLtF3C2i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/+rX/wHuf9d/AAAAAAAB//8AAnjaY2BgYGQAgjO2i86D6AvLjCdB6SkAS/0G9AA=";

},{}],7:[function(require,module,exports){
module.exports = "data:image/gif;base64,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";

},{}],8:[function(require,module,exports){
module.exports = "data:application/font-woff;base64,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";

},{}],9:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("babel-runtime/helpers/interop-require-default")["default"];

exports.__esModule = true;

var _libSourceV2StyleJs = require("lib-source/v2/style.js");

var _libSourceUiv2RippleJs = require("lib-source/uiv2/ripple.js");

var _libSourceUiv2RippleJs2 = _interopRequireDefault(_libSourceUiv2RippleJs);

var _libSourceUiv2IconJs = require('lib-source/uiv2/icon.js');

var _libSourceUiv2IconJs2 = _interopRequireDefault(_libSourceUiv2IconJs);

var _libSourceUiv2Touchable = require('lib-source/uiv2/Touchable');

var _libSourceUiv2Touchable2 = _interopRequireDefault(_libSourceUiv2Touchable);

var _libSourceUiv2Vars = require('lib-source/uiv2/vars');

var _libSourceUiv2Vars2 = _interopRequireDefault(_libSourceUiv2Vars);

var _libSourceV2Utils = require('lib-source/v2/utils');

_libSourceV2StyleJs.defineComponentStyle('button', 'core', {
    "wrapper": {
        position: 'relative',
        textAlign: 'center',
        margin: 4,
        overflow: 'hidden',
        zIndex: "+0",
        whiteSpace: 'pre',
        display: 'inline-block',
        backgroundColor: 'transparent',
        color: 'black',
        borderRadius: 3
    },
    "wrapper:focus": {
        outline: 'none'
    },
    "wrapper[disabled]": {
        backgroundColor: '#eaeaea',
        color: '#a0a0a0'
    },
    "text-wrapper": {
        display: 'table',
        width: '100%'
    },
    "text": {
        height: '100%',
        width: '100%',
        padding: 5,
        paddingLeft: 15,
        paddingRight: 15,
        textAlign: 'center',
        verticalAlign: 'middle',
        whiteSpace: 'pre',
        display: 'table-cell'
    },
    "wrapper > overlay": {
        position: 'absolute',
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        transition: 'background-color 500ms linear'
    },
    ".core-desktop overlay:hover": {
        backgroundColor: _libSourceUiv2Vars2["default"].hoverColor
    },
    "wrapper:active > overlay": {
        backgroundColor: _libSourceUiv2Vars2["default"].activeColor,
        transition: 'none'
    }
});

var Button = function Button(props) {
    var text = props.text;
    var _props$onTap = props.onTap;
    var onTap = _props$onTap === undefined ? function () {
        return console.warn("No onTap given to Button");
    } : _props$onTap;
    var _props$styleName = props.styleName;
    var styleName = _props$styleName === undefined ? "core" : _props$styleName;
    var _props$buttonColor = props.buttonColor;
    var buttonColor = _props$buttonColor === undefined ? null : _props$buttonColor;
    var _props$textColor = props.textColor;
    var textColor = _props$textColor === undefined ? null : _props$textColor;
    var flush = props.flush;
    var block = props.block;
    var fill = props.fill;
    var padding = props.padding;
    var disabled = props.disabled;
    var _props$iconName = props.iconName;
    var iconName = _props$iconName === undefined ? null : _props$iconName;
    var _props$iconSize = props.iconSize;
    var iconSize = _props$iconSize === undefined ? null : _props$iconSize;

    var wrapperName = "button-core-wrapper button-" + styleName + "-wrapper-custom";

    var wrapperStyle = { backgroundColor: buttonColor };
    var textWrapperStyle = {};
    var textStyle = { color: textColor };
    var rippleElement = undefined;
    var onTapHandler = undefined;

    if (disabled !== true) {
        // rippleElement = <Ripple />;
        onTapHandler = onTap;
    }
    if (block === true) {
        wrapperStyle.display = 'block';
    }
    if (fill === true) {
        flush = true;
        wrapperStyle.width = '100%';
        wrapperStyle.height = '100%';
        textWrapperStyle.height = '100%';
        textStyle.padding = 0;
    }
    if (flush === true) {
        wrapperStyle.margin = 0;
    }
    if (iconName !== null) {
        text = React.createElement(
            "span",
            null,
            React.createElement(_libSourceUiv2IconJs2["default"], { name: iconName, size: iconSize }),
            text
        );
    }

    return React.createElement(
        _libSourceUiv2Touchable2["default"],
        { component: "div", tabIndex: -1, className: wrapperName, onTap: onTapHandler, disabled: disabled, style: wrapperStyle },
        React.createElement(
            "div",
            { className: "button-core-text-wrapper", style: textWrapperStyle },
            React.createElement(
                "div",
                { className: "button-core-text", style: textStyle },
                text
            )
        ),
        React.createElement("div", { className: "button-core-overlay" }),
        rippleElement
    );
};
Button.componentName = 'button';

_libSourceV2StyleJs.defineCustomBase(Button, function (_ref) {
    var _ref$normal = _ref.normal;
    var normal = _ref$normal === undefined ? null : _ref$normal;
    var _ref$focus = _ref.focus;
    var focus = _ref$focus === undefined ? null : _ref$focus;
    var _ref$disabled = _ref.disabled;
    var disabled = _ref$disabled === undefined ? null : _ref$disabled;
    return _libSourceV2Utils.transferProps({
        ".button-core-wrapper/wrapper-custom": [normal, {
            textColor: 'color',
            color: 'backgroundColor',
            borderRadius: 'borderRadius',
            shadow: 'boxShadow'
        }
        // ['backgroundColor', 'color', 'borderRadius', 'boxShadow']
        ],
        ".button-core-wrapper/wrapper-custom:focus": [focus, {
            textColor: 'color',
            color: 'backgroundColor',
            borderRadius: 'borderRadius',
            shadow: 'boxShadow'
        }
        // ['backgroundColor', 'color', 'borderRadius', 'boxShadow']
        ],
        ".button-core-wrapper/wrapper-custom[disabled]": [disabled, {
            textColor: 'color',
            color: 'backgroundColor',
            borderRadius: 'borderRadius',
            shadow: 'boxShadow'
        }
        // ['backgroundColor', 'color', 'borderRadius', 'boxShadow']
        ]
    });
});

_libSourceV2StyleJs.defineStyleForComponent(Button, "cancel", {
    normal: {
        color: "#b5263e",
        textColor: 'white'
    }
});
_libSourceV2StyleJs.defineStyleForComponent(Button, "confirm", {
    normal: {
        color: "#30d5a7"
    }
});

exports["default"] = Button;
module.exports = exports["default"];

},{"babel-runtime/helpers/interop-require-default":60,"lib-source/uiv2/Touchable":24,"lib-source/uiv2/icon.js":27,"lib-source/uiv2/ripple.js":36,"lib-source/uiv2/vars":37,"lib-source/v2/style.js":42,"lib-source/v2/utils":43}],10:[function(require,module,exports){
"use strict";

var _inherits = require("babel-runtime/helpers/inherits")["default"];

var _classCallCheck = require("babel-runtime/helpers/class-call-check")["default"];

var _extends = require("babel-runtime/helpers/extends")["default"];

var _interopRequireDefault = require("babel-runtime/helpers/interop-require-default")["default"];

exports.__esModule = true;

var _libSourceV2Style = require("lib-source/v2/style");

var _libSourceUiv2Button = require("lib-source/uiv2/Button");

var _libSourceUiv2Button2 = _interopRequireDefault(_libSourceUiv2Button);

var _libSourceUiv2CenterContent = require('lib-source/uiv2/CenterContent');

var _libSourceUiv2CenterContent2 = _interopRequireDefault(_libSourceUiv2CenterContent);

var coolBlue = "#2FB1DF";
_libSourceV2Style.defineComponentStyle('calendar', 'core', {
    'day': {
        height: '100%',
        fontSize: 14,
        textAlign: 'center'
    },
    "day[data-inactive]": {
        color: 'lightgray',
        paddingTop: 4
    }
});
/*bgcolor textcolor all 3*/
// const Calendar = ({selectedDate}) =>

var Calendar = (function (_React$Component) {
    _inherits(Calendar, _React$Component);

    function Calendar(props) {
        var _this = this;

        _classCallCheck(this, Calendar);

        _React$Component.call(this, props);

        this.prevMonth = function () {
            var _state = _this.state;
            var month = _state.month;
            var year = _state.year;

            month -= 1;

            if (month === -1) {
                month = 11;
                year -= 1;
            }

            _this.setState({ month: month, year: year });
        };

        this.nextMonth = function () {
            var _state2 = _this.state;
            var month = _state2.month;
            var year = _state2.year;

            month += 1;

            if (month === 12) {
                month = 0;
                year += 1;
            }

            _this.setState({ month: month, year: year });
        };

        this.select = function (date) {
            var _props$onChange = _this.props.onChange;
            var onChange = _props$onChange === undefined ? function () {} : _props$onChange;

            // console.log(date.toString());
            onChange(date);
        };

        this.render = function () {
            var selectedDate = _this.props.selectedDate;
            var _state3 = _this.state;
            var month = _state3.month;
            var year = _state3.year;

            var baseDate = chrono({ month: month, year: year }).startOf('week');

            var current = chrono(selectedDate);

            return React.createElement(
                "div",
                { style: { color: 'black' } },
                React.createElement(
                    UI.Pinboard,
                    { height: 30 },
                    React.createElement("div", { pinInfo: { backgroundColor: coolBlue, top: 0, left: 0, bottom: 0, right: 0 } }),
                    React.createElement(_libSourceUiv2Button2["default"], { pinInfo: { top: 0, left: 0, height: '100%', width: 30 }, iconName: "ion-arrow-left-b", fill: true, flush: true, onTap: _this.prevMonth, textColor: "white" }),
                    React.createElement(
                        _libSourceUiv2CenterContent2["default"],
                        { pinInfo: { top: 0, left: 30, right: 30, bottom: 0, color: 'white' }, height: "100%" },
                        month + 1,
                        "/",
                        year
                    ),
                    React.createElement(_libSourceUiv2Button2["default"], { pinInfo: { top: 0, right: 0, height: '100%', width: 30 }, iconName: "ion-arrow-right-b", fill: true, flush: true, onTap: _this.nextMonth, textColor: "white" })
                ),
                React.createElement(
                    UI.Grid,
                    { colCount: 7, rowCount: 7, height: 195 },
                    ['s', 'm', 't', 'w', 't', 'f', 's'].map(function (letter) {
                        return React.createElement(
                            _libSourceUiv2CenterContent2["default"],
                            { key: letter },
                            letter.toUpperCase()
                        );
                    }),
                    factotum.range(42, function (n) {
                        var date = baseDate.shift(n, 'days');
                        var dateValue = selectedDate.set({ month: date.month, year: date.year, date: date.date });

                        if (date.month === month) {
                            var buttonStyle = {};

                            if (date.year === current.year && date.month === current.month && date.date === current.date) {
                                buttonStyle = {
                                    buttonColor: coolBlue,
                                    textColor: 'white'
                                };
                            }

                            return React.createElement(
                                "div",
                                { className: "calendar-core-day", key: n },
                                React.createElement(_libSourceUiv2Button2["default"], _extends({ text: date.date + 1, flush: true, fill: true, onTap: function () {
                                        return _this.select(dateValue);
                                    } }, buttonStyle))
                            );
                        } else {
                            return React.createElement(
                                "div",
                                { key: n, className: "calendar-core-day", "data-inactive": true },
                                date.date + 1
                            );
                        }
                    })
                )
            );
        };

        this.state = {
            month: props.selectedDate.month,
            year: props.selectedDate.year
        };
    }

    return Calendar;
})(React.Component);

Calendar.componentStyleName = 'calendar';

Calendar.valueProp = "selectedDate";
Calendar.valueFunction = function (date) {
    return date;
};
Calendar.defaultPropValue = function () {
    return chrono();
};

exports["default"] = Calendar;
module.exports = exports["default"];

},{"babel-runtime/helpers/class-call-check":57,"babel-runtime/helpers/extends":58,"babel-runtime/helpers/inherits":59,"babel-runtime/helpers/interop-require-default":60,"lib-source/uiv2/Button":9,"lib-source/uiv2/CenterContent":12,"lib-source/v2/style":42}],11:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _libSourceV2Style = require("lib-source/v2/style");

_libSourceV2Style.defineComponentStyle('card', 'core', {
    "container": {
        margin: 5,
        padding: 5,
        boxShadow: '1px 2px 2px rgba(120, 120, 120, 0.15)',
        border: '1px solid #e0e0e0',
        backgroundColor: 'white',
        borderRadius: 3
    },
    "title": {
        fontSize: 20,
        padding: 3,
        color: 'black'
    }
});
var Card = function Card(_ref) {
    var children = _ref.children;
    var _ref$title = _ref.title;
    var title = _ref$title === undefined ? null : _ref$title;

    var content = undefined;

    if (title === null) {
        content = children;
    } else {
        content = React.createElement(
            'div',
            null,
            React.createElement(
                'div',
                { className: 'card-core-title' },
                title
            ),
            children
        );
    }

    return React.createElement(
        'div',
        { className: 'card-core-container' },
        content
    );
};
Card.componentStyleName = 'card';

exports['default'] = Card;
module.exports = exports['default'];

},{"lib-source/v2/style":42}],12:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _libSourceV2Style = require("lib-source/v2/style");

_libSourceV2Style.defineComponentStyle('center-content', 'core', {
    'container': {
        display: 'table',
        whiteSpace: 'pre',
        textAlign: 'center',
        width: '100%'
    },
    'content': {
        display: 'table-cell',
        verticalAlign: 'middle',
        padding: 'auto'
    }
});
var CenterContent = function CenterContent(_ref) {
    var children = _ref.children;
    var width = _ref.width;
    var height = _ref.height;
    var _ref$className = _ref.className;
    var className = _ref$className === undefined ? "" : _ref$className;
    return React.createElement(
        'div',
        { className: 'center-content-core-container ' + className, style: { width: width, height: height } },
        React.createElement(
            'div',
            { className: 'center-content-core-content' },
            React.createElement(
                'div',
                { style: { margin: 'auto', display: 'inline-block' } },
                children
            )
        )
    );
};

exports['default'] = CenterContent;
module.exports = exports['default'];

},{"lib-source/v2/style":42}],13:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("babel-runtime/helpers/interop-require-default")["default"];

exports.__esModule = true;

var _libSourceV2Style = require("lib-source/v2/style");

var _libSourceUiv2CenterContent = require("lib-source/uiv2/CenterContent");

var _libSourceUiv2CenterContent2 = _interopRequireDefault(_libSourceUiv2CenterContent);

// import Ripple from "lib-source/uiv2/Ripple";

var _libSourceUiv2Icon = require("lib-source/uiv2/Icon");

var _libSourceUiv2Icon2 = _interopRequireDefault(_libSourceUiv2Icon);

var _libSourceUiv2Vars = require('lib-source/uiv2/vars');

var _libSourceUiv2Vars2 = _interopRequireDefault(_libSourceUiv2Vars);

var _libSourceV2Utils = require('lib-source/v2/utils');

_libSourceV2Style.defineComponentStyle('checkbox', 'core', {
    "container": {
        position: 'relative',
        transition: 'background-color 500ms linear',
        fontSize: 20,
        overflow: 'hidden'
    },
    "container:active": {
        backgroundColor: 'rgba(0, 0, 0, 0.075)',
        transition: 'none'
    },
    "icon": {
        position: 'absolute',
        top: 0,
        right: 0,
        bottom: 0,
        width: 30,
        color: 'black',
        fontSize: 24,
        transition: 'color 250ms linear'
    },
    "icon[data-checked='true']": {
        color: '#24b324'
    },
    "label": {
        padding: 3,
        paddingRight: 30,
        whiteSpace: 'pre',
        color: 'black'
    },
    "subtitle": {
        color: 'gray',
        fontSize: 14
    }
});
var ionOnIcon = "ion-android-checkbox";
var ionOffIcon = "ion-android-checkbox-outline-blank";

var Checkbox = function Checkbox(props) {
    var _props$checked = props.checked;
    var checked = _props$checked === undefined ? false : _props$checked;
    var _props$onIconName = props.onIconName;
    var onIconName = _props$onIconName === undefined ? ionOnIcon : _props$onIconName;
    var _props$offIconName = props.offIconName;
    var offIconName = _props$offIconName === undefined ? ionOffIcon : _props$offIconName;
    var label = props.label;
    var _props$subTitle = props.subTitle;
    var subTitle = _props$subTitle === undefined ? null : _props$subTitle;
    var _props$onChange = props.onChange;
    var onChange = _props$onChange === undefined ? function () {
        return console.warn("No onChange given to checkbox");
    } : _props$onChange;
    var _props$styleName = props.styleName;
    var styleName = _props$styleName === undefined ? "core" : _props$styleName;

    var iconName = checked === true ? onIconName : offIconName;
    var iconClassName = "checkbox-core-icon checkbox-" + styleName + "-icon-custom";
    var labelClassName = "checkbox-core-label checkbox-" + styleName + "-label-custom";
    var content = label;

    if (subTitle !== null) {
        var subtitleClassName = "checkbox-core-subtitle checkbox-" + styleName + "-subtitle-custom";
        content = React.createElement(
            "div",
            null,
            label,
            React.createElement(
                "div",
                { className: subtitleClassName },
                subTitle
            )
        );
    }

    return React.createElement(
        UI.Touchable,
        { component: "div", className: "checkbox-core-container", onTap: function () {
                return onChange(!checked);
            } },
        React.createElement(
            "div",
            { className: iconClassName, "data-checked": checked },
            React.createElement(
                _libSourceUiv2CenterContent2["default"],
                { height: "100%" },
                React.createElement(_libSourceUiv2Icon2["default"], { name: iconName })
            )
        ),
        React.createElement(
            "div",
            { className: labelClassName },
            content
        )
    );
};
Checkbox.componentName = "checkbox";

Checkbox.valueProp = "checked";
Checkbox.valueFunction = function (checked) {
    return checked;
};
Checkbox.defaultPropValue = false;

_libSourceV2Style.defineCustomBase(Checkbox, function (_ref) {
    var _ref$normal = _ref.normal;
    var normal = _ref$normal === undefined ? null : _ref$normal;
    var _ref$checked = _ref.checked;
    var checked = _ref$checked === undefined ? null : _ref$checked;
    var _ref$label = _ref.label;
    var label = _ref$label === undefined ? null : _ref$label;
    var _ref$subtitle = _ref.subtitle;
    var subtitle = _ref$subtitle === undefined ? null : _ref$subtitle;
    return _libSourceV2Utils.transferProps({
        ".checkbox-core-icon/icon-custom": [normal, { iconColor: 'color' }],
        ".checkbox-core-icon/icon-custom[data-checked='true']": [checked, { iconColor: 'color' }],
        ".checkbox-core-label/label-custom": [label, {
            textColor: 'color',
            color: 'backgroundColor'
        }],
        ".checkbox-core-subtitle/subtitle-custom": [subtitle, {
            textColor: 'color',
            color: 'backgroundColor'
        }]
    });
});

exports["default"] = Checkbox;
module.exports = exports["default"];
/*<Ripple />*/

},{"babel-runtime/helpers/interop-require-default":60,"lib-source/uiv2/CenterContent":12,"lib-source/uiv2/Icon":16,"lib-source/uiv2/vars":37,"lib-source/v2/style":42,"lib-source/v2/utils":43}],14:[function(require,module,exports){
"use strict";

var _inherits = require("babel-runtime/helpers/inherits")["default"];

var _classCallCheck = require("babel-runtime/helpers/class-call-check")["default"];

var _extends = require("babel-runtime/helpers/extends")["default"];

var _objectWithoutProperties = require("babel-runtime/helpers/object-without-properties")["default"];

var _regeneratorRuntime = require("babel-runtime/regenerator")["default"];

var _interopRequireDefault = require("babel-runtime/helpers/interop-require-default")["default"];

exports.__esModule = true;

var _libSourceV2Style = require("lib-source/v2/style");

var _libSourceUiv2Button = require("lib-source/uiv2/Button");

var _libSourceUiv2Button2 = _interopRequireDefault(_libSourceUiv2Button);

var _libSourceUiv2Icon = require("lib-source/uiv2/Icon");

var _libSourceUiv2Icon2 = _interopRequireDefault(_libSourceUiv2Icon);

var _libSourceUiv2Option = require("lib-source/uiv2/Option");

var _libSourceUiv2Option2 = _interopRequireDefault(_libSourceUiv2Option);

var _libSourceUiv2Touchable = require("lib-source/uiv2/Touchable");

var _libSourceUiv2Touchable2 = _interopRequireDefault(_libSourceUiv2Touchable);

_libSourceV2Style.defineComponentStyle('combobox', 'core', {
    'container': {
        border: '1px solid lightgray',
        borderRadius: 3,
        // padding: 3,
        position: 'relative',
        color: 'black',
        height: 30
    },
    "icon": {
        position: 'absolute',
        top: '50%',
        right: 10,
        transform: 'translateY(-50%)',
        pointerEvents: 'none'
    }
});

// const comboboxSelect = (index, value) => dialog.success([index, value]);

var Combobox = (function (_React$Component) {
    _inherits(Combobox, _React$Component);

    function Combobox(props) {
        var _this = this;

        _classCallCheck(this, Combobox);

        _React$Component.call(this, props);

        this.openOptions = function callee$2$0() {
            var _props, _props$title, title, _props$scrollToSelected, scrollToSelected, selectedIndex, children, response, _props2;

            return _regeneratorRuntime.async(function callee$2$0$(context$3$0) {
                while (1) switch (context$3$0.prev = context$3$0.next) {
                    case 0:
                        _props = this.props;
                        _props$title = _props.title;
                        title = _props$title === undefined ? "Combobox!" : _props$title;
                        _props$scrollToSelected = _props.scrollToSelected;
                        scrollToSelected = _props$scrollToSelected === undefined ? false : _props$scrollToSelected;
                        selectedIndex = _props.selectedIndex;
                        children = React.Children.toArray(this.props.children);
                        context$3$0.next = 9;
                        return _regeneratorRuntime.awrap(dialog.show({
                            title: title,
                            content: children.map(function (_ref, index) {
                                var _ref$props = _ref.props;
                                var _ref$props$value = _ref$props.value;
                                var value = _ref$props$value === undefined ? null : _ref$props$value;
                                var children = _ref$props.children;
                                var _ref$props$style = _ref$props.style;
                                var style = _ref$props$style === undefined ? null : _ref$props$style;
                                var _ref$props$className = _ref$props.className;
                                var className = _ref$props$className === undefined ? null : _ref$props$className;

                                var onTap = function onTap() {
                                    return dialog.hide(dialog.success([index, value]));
                                };
                                return React.createElement(
                                    "div",
                                    _extends({ style: style, className: className }, { key: index }),
                                    React.createElement(_libSourceUiv2Button2["default"], { text: children, block: true, flush: true, onTap: onTap })
                                );
                            }),
                            buttons: [{ text: "Cancel", cancels: true }],
                            setup: function setup(container) {
                                if (scrollToSelected === true && selectedIndex !== -1) {
                                    container.scrollTop = container.children[selectedIndex].offsetTop - container.offsetTop;
                                }
                            }
                        }));

                    case 9:
                        response = context$3$0.sent;

                        if (response.status === "success") {
                            (_props2 = this.props).onChange.apply(_props2, response.value);
                        }

                    case 11:
                    case "end":
                        return context$3$0.stop();
                }
            }, null, _this);
        };

        this.render = function () {
            var _props3 = _this.props;
            var selectedIndex = _props3.selectedIndex;
            var children = _props3.children;
            var height = _props3.height;

            var buttonProps = _objectWithoutProperties(_props3, ["selectedIndex", "children", "height"]);

            var flattenedChildren = React.Children.toArray(children);
            var currentChild = "Please select an option";

            if (selectedIndex !== -1) {
                currentChild = flattenedChildren[selectedIndex].props.children;
            }

            return React.createElement(
                "div",
                { className: "combobox-core-container", style: { height: height } },
                React.createElement(_libSourceUiv2Button2["default"], _extends({}, buttonProps, { text: currentChild, block: true, flush: true, fill: true, onTap: _this.openOptions })),
                React.createElement(
                    "div",
                    { className: "combobox-core-icon" },
                    React.createElement(_libSourceUiv2Icon2["default"], { name: "ion-arrow-down-b", size: 24 })
                )
            );
        };
    }

    return Combobox;
})(React.Component);

Combobox.valueProp = "selectedIndex";
Combobox.valueFunction = function (index, value) {
    return { index: index, value: value };
};
Combobox.defaultPropValue = 0;

exports["default"] = Combobox;
module.exports = exports["default"];

},{"babel-runtime/helpers/class-call-check":57,"babel-runtime/helpers/extends":58,"babel-runtime/helpers/inherits":59,"babel-runtime/helpers/interop-require-default":60,"babel-runtime/helpers/object-without-properties":61,"babel-runtime/regenerator":148,"lib-source/uiv2/Button":9,"lib-source/uiv2/Icon":16,"lib-source/uiv2/Option":19,"lib-source/uiv2/Touchable":24,"lib-source/v2/style":42}],15:[function(require,module,exports){
'use strict';

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _extends = require('babel-runtime/helpers/extends')['default'];

var _objectWithoutProperties = require('babel-runtime/helpers/object-without-properties')['default'];

var _Object$entries = require('babel-runtime/core-js/object/entries')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

exports.__esModule = true;

var _libSourceUiv2Button = require("lib-source/uiv2/Button");

var _libSourceUiv2Button2 = _interopRequireDefault(_libSourceUiv2Button);

var ItemContainer = (function (_React$Component) {
    _inherits(ItemContainer, _React$Component);

    function ItemContainer(props) {
        var _this = this;

        _classCallCheck(this, ItemContainer);

        _React$Component.call(this, props);

        this.change = function () {
            var _props = _this.props;
            var updateForm = _props.updateForm;
            var _props$childInfo = _props.childInfo;
            var valueFunction = _props$childInfo.valueFunction;
            var name = _props$childInfo.name;

            _this.setState({ value: arguments[0] });
            updateForm(name, valueFunction.apply(undefined, arguments));
        };

        this.render = function () {
            var _valueObj;

            var _props$childInfo2 = _this.props.childInfo;
            var Renderer = _props$childInfo2.Renderer;
            var valueProp = _props$childInfo2.valueProp;
            var children = _props$childInfo2.children;
            var props = _props$childInfo2.props;
            var value = _this.state.value;

            var valueObj = (_valueObj = {}, _valueObj[valueProp] = value, _valueObj);

            return React.createElement(
                'div',
                null,
                React.createElement(
                    Renderer,
                    _extends({}, props, { onChange: _this.change }, valueObj),
                    children
                )
            );
        };

        this.state = { value: props.childInfo.initialValue };
    }

    return ItemContainer;
})(React.Component);

var Form = (function (_React$Component2) {
    _inherits(Form, _React$Component2);

    function Form(props) {
        var _this2 = this;

        _classCallCheck(this, Form);

        _React$Component2.call(this, props);

        this.updateInternalState = function (name, value) {
            _this2.internalState[name] = value;
        };

        this.submit = function (evt) {
            evt.preventDefault();
            evt.stopPropagation();

            var _props$onSubmit = _this2.props.onSubmit;
            var onSubmit = _props$onSubmit === undefined ? function (state) {
                return console.log(state);
            } : _props$onSubmit;

            onSubmit(_this2.internalState);
        };

        this.render = function () {
            var Container = _this2.Container;
            var childList = _this2.childList;
            var containerProps = _this2.containerProps;
            var _props$submitText = _this2.props.submitText;
            var submitText = _props$submitText === undefined ? "Submit" : _props$submitText;

            return React.createElement(
                'form',
                { onSubmit: _this2.submit, ref: 'form' },
                React.createElement(
                    Container,
                    containerProps,
                    childList
                ),
                React.createElement(_libSourceUiv2Button2['default'], { text: submitText, onTap: _this2.submit, block: true })
            );
        };

        var _props$itemContainer = props.itemContainer;
        var itemContainer = _props$itemContainer === undefined ? 'div' : _props$itemContainer;
        var _props$layout = props.layout;
        var layout = _props$layout === undefined ? null : _props$layout;

        var children = React.Children.toArray(props.children);
        var ElemContainer = undefined;

        this.internalState = {};

        if (layout === null) {
            this.Container = 'div';
            ElemContainer = itemContainer;
        } else {
            this.Container = layout;
            ElemContainer = layout.FormContainer || function (_ref) {
                var children = _ref.children;
                return children;
            };
            this.containerProps = _Object$entries(props).reduce(function (props, _ref2) {
                var key = _ref2[0];
                var value = _ref2[1];

                if (key.startsWith('layout-') === true) {
                    props[key.substr(7)] = value;
                }
                return props;
            }, {});
        }

        this.childList = children.map(function (child, index) {
            var elemType = child.type.parentInfo !== undefined ? child.type.parentInfo : child.type;
            var initValue = child.props.defaultPropValue || elemType.defaultPropValue;
            var _child$props = child.props;
            var _child$props$formName = _child$props.formName;
            var formName = _child$props$formName === undefined ? index : _child$props$formName;
            var chidren = _child$props.chidren;

            var childProps = _objectWithoutProperties(_child$props, ['formName', 'chidren']);

            var childInfo = {
                Renderer: child.type,
                props: childProps,
                children: child.props.children,
                valueProp: elemType.valueProp,
                valueFunction: elemType.valueFunction,
                initialValue: typeof initValue === 'function' ? initValue() : initValue,
                name: formName
            };
            var containerProps = _Object$entries(childProps).reduce(function (props, _ref3) {
                var key = _ref3[0];
                var value = _ref3[1];

                if (key.startsWith('layout-') === true) {
                    props[key.substr(7)] = value;
                }
                return props;
            }, {});
            // console.log(child, child.type, child.type === Checkbox);
            _this2.internalState[childInfo.name] = childInfo.valueFunction(childInfo.initialValue);
            return React.createElement(
                ElemContainer,
                _extends({}, containerProps, { key: index }),
                React.createElement(ItemContainer, { childInfo: childInfo, updateForm: _this2.updateInternalState })
            );
        });
    }

    return Form;
})(React.Component);

exports['default'] = Form;
module.exports = exports['default'];

},{"babel-runtime/core-js/object/entries":50,"babel-runtime/helpers/class-call-check":57,"babel-runtime/helpers/extends":58,"babel-runtime/helpers/inherits":59,"babel-runtime/helpers/interop-require-default":60,"babel-runtime/helpers/object-without-properties":61,"lib-source/uiv2/Button":9}],16:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _libSourceV2StyleJs = require("lib-source/v2/style.js");

_libSourceV2StyleJs.defineComponentStyle('icon', 'core', {
    "content": {
        fontFamily: "Ionic",
        marginLeft: 2,
        marginRight: 2
    }
});
var Icon = function Icon(_ref) {
    var name = _ref.name;
    var _ref$styleName = _ref.styleName;
    var styleName = _ref$styleName === undefined ? 'core' : _ref$styleName;
    var size = _ref.size;
    return React.createElement(
        'span',
        { className: 'icon-' + styleName + '-content', style: { fontSize: size } },
        ionic[name]
    );
};

exports['default'] = Icon;
module.exports = exports['default'];

},{"lib-source/v2/style.js":42}],17:[function(require,module,exports){
'use strict';

exports.__esModule = true;
var Image = function Image(_ref) {
    var source = _ref.source;
    var _ref$width = _ref.width;
    var width = _ref$width === undefined ? '100%' : _ref$width;
    var _ref$height = _ref.height;
    var height = _ref$height === undefined ? null : _ref$height;
    var _ref$imageSize = _ref.imageSize;
    var imageSize = _ref$imageSize === undefined ? 'fit' : _ref$imageSize;
    var color = _ref.color;
    var _ref$block = _ref.block;
    var block = _ref$block === undefined ? false : _ref$block;

    if (height === null) {
        throw new Error("Need to give image height");
    }

    var style = {
        display: block === true ? "block" : "inline-block",
        backgroundRepeat: 'no-repeat',
        backgroundPosition: 'center center',
        backgroundImage: 'url("' + source + '")',
        position: 'relative',
        backgroundColor: color,
        width: width,
        height: height
    };

    switch (imageSize) {
        case 'fit':
            style.backgroundSize = 'contain';
            break;

        case 'clip':
            style.backgroundSize = 'cover';
            break;

        default:
            style.backgroundSize = imageSize;
    }

    return React.createElement('div', { style: style });
};

exports['default'] = Image;
module.exports = exports['default'];

},{}],18:[function(require,module,exports){
'use strict';

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _extends = require('babel-runtime/helpers/extends')['default'];

var _objectWithoutProperties = require('babel-runtime/helpers/object-without-properties')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

exports.__esModule = true;

var _libSourceV2Style = require("lib-source/v2/style");

var _libSourceUiv2InputRangeInput = require('lib-source/uiv2/input/RangeInput');

var _libSourceUiv2InputRangeInput2 = _interopRequireDefault(_libSourceUiv2InputRangeInput);

var _libSourceUiv2InputDateInput = require('lib-source/uiv2/input/DateInput');

var _libSourceUiv2InputDateInput2 = _interopRequireDefault(_libSourceUiv2InputDateInput);

var _libSourceUiv2InputTimeInput = require('lib-source/uiv2/input/TimeInput');

var _libSourceUiv2InputTimeInput2 = _interopRequireDefault(_libSourceUiv2InputTimeInput);

var _libSourceUiv2InputFileInput = require('lib-source/uiv2/input/FileInput');

var _libSourceUiv2InputFileInput2 = _interopRequireDefault(_libSourceUiv2InputFileInput);

var _libSourceUiv2CenterContent = require('lib-source/uiv2/CenterContent');

var _libSourceUiv2CenterContent2 = _interopRequireDefault(_libSourceUiv2CenterContent);

var _libSourceUiv2Icon = require('lib-source/uiv2/Icon');

var _libSourceUiv2Icon2 = _interopRequireDefault(_libSourceUiv2Icon);

var _libSourceUiv2Touchable = require('lib-source/uiv2/Touchable');

var _libSourceUiv2Touchable2 = _interopRequireDefault(_libSourceUiv2Touchable);

var coolBlue = "#2FB1DF";

_libSourceV2Style.defineComponentStyle('input', 'core', {
    "$body": {
        WebkitTapHighlightColor: 'rgba(0, 0, 0, 0)'
    },
    "wrapper": {
        position: 'relative',
        backgroundColor: 'white',
        height: 32,
        margin: 3
    },
    "field": {
        width: '100%',
        borderWidth: 0,
        borderBottom: '2px solid lightgray',
        WebkitBorderRadius: 0,
        WebkitAppearance: 'none',
        borderRadius: 0,
        backgroundColor: 'transparent',
        margin: 0,
        height: '100%',
        position: 'relative',
        zIndex: '+1'
    },
    "field:focus": {
        outline: 'none'
    },
    "icon": {
        position: 'absolute',
        top: 0,
        left: 0,
        bottom: 0,
        width: 30
    },
    "highlight-border": {
        position: 'absolute',
        bottom: 0,
        borderBottom: '2px solid ' + coolBlue,
        left: '50%',
        transform: 'translateX(-50%) scaleX(0)',
        width: '100%',
        zIndex: '+2'
    },
    "field:focus + highlight-border": {
        // width: '100%',
        WebkitTransition: '-webkit-transform 250ms linear',
        transition: 'transform 150ms linear',
        transform: 'translateX(-50%) scaleX(1)'
    },
    "label": {
        color: "black",
        fontSize: 16,
        padding: 3
    }
});

var InputWrapper = (function (_React$Component) {
    _inherits(InputWrapper, _React$Component);

    function InputWrapper(props) {
        var _this = this;

        _classCallCheck(this, InputWrapper);

        _React$Component.call(this, props);

        this.focus = function () {
            _this.refs.field.focus();
        };

        this.render = function () {
            var _props = _this.props;
            var _props$parser = _props.parser;
            var parser = _props$parser === undefined ? function (i) {
                return i;
            } : _props$parser;
            var _props$onChange = _props.onChange;
            var onChange = _props$onChange === undefined ? function () {} : _props$onChange;
            var _props$iconName = _props.iconName;
            var iconName = _props$iconName === undefined ? null : _props$iconName;
            var _props$style = _props.style;
            var style = _props$style === undefined ? {} : _props$style;
            var _props$borderRadius = _props.borderRadius;
            var borderRadius = _props$borderRadius === undefined ? null : _props$borderRadius;

            var props = _objectWithoutProperties(_props, ['parser', 'onChange', 'iconName', 'style', 'borderRadius']);

            var handler = function handler(evt) {
                // const raw = evt.target.value;
                onChange(parser(evt.target.value));
            };
            var realStyle = _extends({}, style);
            var borderStyle = {};
            var iconDisplay = null;

            if (iconName !== null) {
                iconDisplay = React.createElement(
                    _libSourceUiv2CenterContent2['default'],
                    { className: 'input-core-icon', height: '100%' },
                    React.createElement(_libSourceUiv2Icon2['default'], { name: iconName, size: 18 })
                );
                realStyle.paddingLeft = 30;
            }
            if (borderRadius !== null) {
                realStyle.borderRadius = borderRadius;
                borderStyle.borderRadius = borderRadius;
            }

            return React.createElement(
                'div',
                { className: 'input-core-wrapper' },
                React.createElement('input', _extends({}, props, { style: realStyle, onChange: handler, className: 'input-core-field', ref: 'field' })),
                React.createElement('div', { className: 'input-core-highlight-border', style: borderStyle }),
                iconDisplay
            );
        };
    }

    return InputWrapper;
})(React.Component);

var LabeledInput = (function (_React$Component2) {
    _inherits(LabeledInput, _React$Component2);

    function LabeledInput(props) {
        var _this2 = this;

        _classCallCheck(this, LabeledInput);

        _React$Component2.call(this, props);

        this.focus = function () {
            _this2.refs.wrapped.focus();
        };

        this.render = function () {
            var _props2 = _this2.props;
            var label = _props2.label;
            var _props2$Wrapper = _props2.Wrapper;
            var Wrapper = _props2$Wrapper === undefined ? InputWrapper : _props2$Wrapper;

            var props = _objectWithoutProperties(_props2, ['label', 'Wrapper']);

            return React.createElement(
                'div',
                { style: { position: 'relative' } },
                React.createElement(
                    _libSourceUiv2Touchable2['default'],
                    { component: 'div', className: 'input-core-label', onTap: function () {
                            return _this2.refs.wrapped.focus();
                        } },
                    label
                ),
                React.createElement(Wrapper, _extends({ ref: 'wrapped' }, props))
            );
        };
    }

    return LabeledInput;
})(React.Component);

var ValidatedInput = (function (_React$Component3) {
    _inherits(ValidatedInput, _React$Component3);

    function ValidatedInput(props) {
        var _this3 = this;

        _classCallCheck(this, ValidatedInput);

        _React$Component3.call(this, props);

        this.focus = function () {
            _this3.refs.input.focus();
        };

        this.render = function () {
            var _props3 = _this3.props;
            var validator = _props3.validator;
            var _props3$onChange = _props3.onChange;
            var onChange = _props3$onChange === undefined ? function () {} : _props3$onChange;

            var props = _objectWithoutProperties(_props3, ['validator', 'onChange']);

            var changeHandler = function changeHandler(value) {
                return onChange(value, validator(value));
            };
            return React.createElement(LabeledInput, _extends({}, props, { onChange: changeHandler }));
        };
    }

    return ValidatedInput;
})(React.Component);

var Input = {
    Text: function Text(props) {
        return React.createElement(LabeledInput, _extends({}, props, { type: 'text' }));
    },
    Password: function Password(props) {
        return React.createElement(LabeledInput, _extends({}, props, { type: 'password' }));
    },
    Search: function Search(props) {
        return React.createElement(LabeledInput, _extends({}, props, { type: 'search', iconName: 'ion-search' }));
    },
    Date: _libSourceUiv2InputDateInput2['default'],
    Range: _libSourceUiv2InputRangeInput2['default'],
    Time: _libSourceUiv2InputTimeInput2['default'],
    File: _libSourceUiv2InputFileInput2['default'],
    // Date: props => <DateInput {...props} />,
    // Range: props => <RangeInput {...props} />,
    // Time: props => <TimeInput {...props} />,
    // File: props => <FileInput {...props} />,
    URL: function URL(_ref) {
        var _ref$validator = _ref.validator;
        var validator = _ref$validator === undefined ? function (url) {
            return (/^(https?:\/\/)?(\w+(\.\w+)+|localhost)(\/[\w\#\-\%]+)*\/?$/.test(url)
            );
        } : _ref$validator;

        var props = _objectWithoutProperties(_ref, ['validator']);

        return React.createElement(ValidatedInput, _extends({ validator: validator }, props, { type: 'url' }));
    },
    Email: function Email(_ref2) {
        var _ref2$validator = _ref2.validator;
        var validator = _ref2$validator === undefined ? function (email) {
            return (/^([a-zA-Z]\w*)(\.([a-zA-Z]\w*))*\@([a-zA-Z]\w*)(\.([a-zA-Z]\w*))+$/.test(email)
            );
        } : _ref2$validator;

        var props = _objectWithoutProperties(_ref2, ['validator']);

        return React.createElement(ValidatedInput, _extends({ validator: validator }, props, { type: 'email' }));
    }
};

Input.Text.valueProp = 'value';
Input.Text.valueFunction = function (text) {
    return text;
};
Input.Text.defaultPropValue = "";

Input.Password.valueProp = 'value';
Input.Password.valueFunction = function (text) {
    return text;
};
Input.Password.defaultPropValue = "";

Input.Search.valueProp = 'value';
Input.Search.valueFunction = function (text) {
    return text;
};
Input.Search.defaultPropValue = "";

Input.URL.valueProp = 'value';
Input.URL.valueFunction = function (text, valid) {
    return { text: text, valid: valid };
};
Input.URL.defaultPropValue = "";

Input.Email.valueProp = 'value';
Input.Email.valueFunction = function (text, valid) {
    return { text: text, valid: valid };
};
Input.Email.defaultPropValue = "";

exports['default'] = Input;
module.exports = exports['default'];

},{"babel-runtime/helpers/class-call-check":57,"babel-runtime/helpers/extends":58,"babel-runtime/helpers/inherits":59,"babel-runtime/helpers/interop-require-default":60,"babel-runtime/helpers/object-without-properties":61,"lib-source/uiv2/CenterContent":12,"lib-source/uiv2/Icon":16,"lib-source/uiv2/Touchable":24,"lib-source/uiv2/input/DateInput":29,"lib-source/uiv2/input/FileInput":30,"lib-source/uiv2/input/RangeInput":31,"lib-source/uiv2/input/TimeInput":32,"lib-source/v2/style":42}],19:[function(require,module,exports){
"use strict";

exports.__esModule = true;
var Option = function Option() {
    throw new Error("Option is intended as a filler element and should not be rendered on its own");
};

exports["default"] = Option;
module.exports = exports["default"];

},{}],20:[function(require,module,exports){
"use strict";

var _inherits = require("babel-runtime/helpers/inherits")["default"];

var _classCallCheck = require("babel-runtime/helpers/class-call-check")["default"];

var _objectWithoutProperties = require("babel-runtime/helpers/object-without-properties")["default"];

var _extends = require("babel-runtime/helpers/extends")["default"];

var _Object$entries = require("babel-runtime/core-js/object/entries")["default"];

var _interopRequireDefault = require("babel-runtime/helpers/interop-require-default")["default"];

exports.__esModule = true;

var _libSourceV2Style = require("lib-source/v2/style");

var _libSourceUiv2CenterContent = require("lib-source/uiv2/CenterContent");

var _libSourceUiv2CenterContent2 = _interopRequireDefault(_libSourceUiv2CenterContent);

var _libSourceUiv2Touchable = require("lib-source/uiv2/Touchable");

var _libSourceUiv2Touchable2 = _interopRequireDefault(_libSourceUiv2Touchable);

var _libSourceUiv2Icon = require("lib-source/uiv2/Icon");

var _libSourceUiv2Icon2 = _interopRequireDefault(_libSourceUiv2Icon);

_libSourceV2Style.defineComponentStyle('radio', 'core', {
    "title": {
        fontSize: 22,
        padding: 3
    }
});
_libSourceV2Style.defineComponentStyle("radio-item", "core", {
    "default-item": {
        color: 'black',
        position: 'relative',
        paddingLeft: 30,
        transition: 'background-color 500ms linear'
    },
    // ".radio-item-container:active > default-item": {
    "default-item:active": {
        backgroundColor: 'rgba(0, 0, 0, 0.1)',
        transition: 'none'
    },
    "icon": {
        position: 'absolute',
        top: 0,
        left: 0,
        bottom: 0,
        width: 30
    }
});
var RadioItem = function RadioItem(_ref) {
    var checked = _ref.checked;
    var iconColor = _ref.iconColor;
    var children = _ref.children;
    var onTap = _ref.onTap;

    var iconName = "ion-android-radio-button-" + (checked === true ? 'on' : 'off');
    return React.createElement(
        _libSourceUiv2Touchable2["default"],
        { component: "div", onTap: onTap, className: "radio-item-core-default-item", "data-checked": checked },
        React.createElement(
            "div",
            { className: "radio-item-core-icon", "data-checked": checked },
            React.createElement(
                _libSourceUiv2CenterContent2["default"],
                { height: "100%" },
                React.createElement(_libSourceUiv2Icon2["default"], { size: 18, name: iconName })
            )
        ),
        children
    );
};

var Radio = (function (_React$Component) {
    _inherits(Radio, _React$Component);

    function Radio(props) {
        var _this = this;

        _classCallCheck(this, Radio);

        _React$Component.call(this, props);

        this.select = function (index, value) {
            if (index !== _this.props.selectedIndex) {
                _this.props.onChange(index, value);
            }
        };

        this.render = function () {
            var _props = _this.props;
            var _props$layout = _props.layout;
            var layout = _props$layout === undefined ? 'div' : _props$layout;
            var selectedIndex = _props.selectedIndex;
            var _props$onChange = _props.onChange;
            var onChange = _props$onChange === undefined ? function () {} : _props$onChange;
            var _props$styleName = _props.styleName;
            var styleName = _props$styleName === undefined ? 'core' : _props$styleName;
            var title = _props.title;

            var Container = layout;

            var _props2 = _this.props;
            var children = _props2.children;

            var layoutProps = _objectWithoutProperties(_props2, ["children"]);

            var Item = undefined;

            if (Container === 'div') {
                Item = RadioItem;
            } else {
                Item = Container.RadioItem;
            }

            children = React.Children.toArray(children);
            layoutProps = _Object$entries(layoutProps).reduce(function (newProps, _ref2) {
                var key = _ref2[0];
                var value = _ref2[1];

                if (key.startsWith("layout-") === true) {
                    newProps[key.slice(7)] = value;
                }
                return newProps;
            }, {});

            return React.createElement(
                "div",
                null,
                React.createElement(
                    "div",
                    { className: "radio-core-title" },
                    title
                ),
                React.createElement(
                    Container,
                    layoutProps,
                    children.map(function (child, index) {
                        var value = child.props.value;
                        return(
                            // <Touchable component="div" className="radio-item-container" key={index} onTap={() => this.select(index, value)}>
                            React.createElement(Item, _extends({ checked: selectedIndex === index }, child.props, { onTap: function () {
                                    return _this.select(index, value);
                                } }))
                            // {/*</Touchable>*/}

                        );
                    })
                )
            );
        };
    }

    return Radio;
})(React.Component);

Radio.valueProp = 'selectedIndex';
Radio.valueFunction = function (index, value) {
    return { index: index, value: value };
};
Radio.defaultPropValue = 0;

exports["default"] = Radio;
module.exports = exports["default"];

},{"babel-runtime/core-js/object/entries":50,"babel-runtime/helpers/class-call-check":57,"babel-runtime/helpers/extends":58,"babel-runtime/helpers/inherits":59,"babel-runtime/helpers/interop-require-default":60,"babel-runtime/helpers/object-without-properties":61,"lib-source/uiv2/CenterContent":12,"lib-source/uiv2/Icon":16,"lib-source/uiv2/Touchable":24,"lib-source/v2/style":42}],21:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("babel-runtime/helpers/interop-require-default")["default"];

exports.__esModule = true;

var _libSourceUiv2Image = require("lib-source/uiv2/Image");

var _libSourceUiv2Image2 = _interopRequireDefault(_libSourceUiv2Image);

var _libSourceDataUriLoadSpinnerGifSource = require("lib-source/data-uri/load-spinner.gif.source");

var _libSourceDataUriLoadSpinnerGifSource2 = _interopRequireDefault(_libSourceDataUriLoadSpinnerGifSource);

var Spinner = function Spinner(_ref) {
  var size = _ref.size;
  return React.createElement(_libSourceUiv2Image2["default"], { width: size, height: size, source: _libSourceDataUriLoadSpinnerGifSource2["default"] });
};

exports["default"] = Spinner;
module.exports = exports["default"];

},{"babel-runtime/helpers/interop-require-default":60,"lib-source/data-uri/load-spinner.gif.source":7,"lib-source/uiv2/Image":17}],22:[function(require,module,exports){
'use strict';

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

exports.__esModule = true;

var _libSourceV2Style = require("lib-source/v2/style");

var _libSourceUiv2InputRangeInput = require('lib-source/uiv2/input/RangeInput');

var _libSourceUiv2InputRangeInput2 = _interopRequireDefault(_libSourceUiv2InputRangeInput);

_libSourceV2Style.defineComponentStyle('time-selector', 'core', {
    "time-display": {
        textAlign: 'center',
        fontSize: 24,
        color: 'black'
    }
});

var TimeSelector = (function (_React$Component) {
    _inherits(TimeSelector, _React$Component);

    function TimeSelector(props) {
        var _this = this;

        _classCallCheck(this, TimeSelector);

        _React$Component.call(this, props);

        this.change = function (prop) {
            return function (newValue) {
                var _changed;

                var _props = _this.props;
                var value = _props.value;
                var _props$onChange = _props.onChange;
                var onChange = _props$onChange === undefined ? warningFunc("onChange not given to TimeSelector") : _props$onChange;

                var changed = (_changed = {}, _changed[prop] = newValue, _changed);

                onChange(value.set(changed));
            };
        };

        this.render = function () {
            var _props2 = _this.props;
            var _props2$value = _props2.value;
            var value = _props2$value === undefined ? null : _props2$value;
            var _props2$format = _props2.format;
            var format = _props2$format === undefined ? "{hour/12padded}:{minute/padded} {tod}" : _props2$format;

            if (value === null) {
                throw new Error("Must provide a value to TimeSelector");
            }
            var hours = value.hours;
            var minutes = value.minutes;

            return React.createElement(
                'div',
                null,
                React.createElement(
                    'div',
                    { className: 'time-selector-core-time-display' },
                    value.format(format)
                ),
                React.createElement(_libSourceUiv2InputRangeInput2['default'], { key: '0', value: hours, min: 0, max: 23, label: 'Hour', onChange: _this.change('hours'), showArrows: true }),
                React.createElement(_libSourceUiv2InputRangeInput2['default'], { key: '1', value: minutes, min: 0, max: 59, label: 'Minute', onChange: _this.change('minutes'), showArrows: true })
            );
        };
    }

    return TimeSelector;
})(React.Component);

exports['default'] = TimeSelector;
module.exports = exports['default'];

},{"babel-runtime/helpers/class-call-check":57,"babel-runtime/helpers/inherits":59,"babel-runtime/helpers/interop-require-default":60,"lib-source/uiv2/input/RangeInput":31,"lib-source/v2/style":42}],23:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _libSourceV2Style = require("lib-source/v2/style");

var _libSourceV2Utils = require('lib-source/v2/utils');

var animationTime = 100;
_libSourceV2Style.defineComponentStyle('toggle', 'core', {
    "container": {
        position: 'relative',
        transition: 'background-color 500ms linear',
        fontSize: 20,
        overflow: 'hidden'
    },
    "container:active": {
        backgroundColor: 'rgba(0, 0, 0, 0.075)',
        transition: 'none'
    },
    "toggle-container": {
        position: 'absolute',
        right: 13,
        width: 30,
        top: '50%',
        transform: "translateY(-50%)",
        height: 8,
        fontSize: 11,
        borderRadius: 15,
        backgroundColor: 'lightgray',
        lineHeight: '22px'
    },
    "toggle-container[data-on='true']": {
        backgroundColor: '#bed0bd'
    },
    "toggle": {
        WebkitTransition: 'background-color ' + animationTime + 'ms linear, -webkit-transform ' + animationTime + 'ms linear',
        transition: 'background-color ' + animationTime + 'ms linear, transform ' + animationTime + 'ms linear',
        position: 'absolute',
        left: -11,
        top: -7,
        height: 22,
        width: 22,
        borderRadius: 15,
        textAlign: 'center',
        border: '1px solid lightgray',
        boxShadow: '2px 2px 2px rgba(0, 0, 0, 0.15)'
    },
    "toggle[data-on='false']": {
        transform: 'translateX(0)',
        backgroundColor: 'white'
    },
    "toggle[data-on='true']": {
        transform: 'translateX(30px)',
        backgroundColor: '#24b324'
    },
    "label": {
        padding: 3,
        paddingRight: 70,
        whiteSpace: 'pre',
        color: 'black'
    },
    "subtitle": {
        color: 'gray',
        fontSize: 14
    }
});

var Toggle = function Toggle(props) {
    var _props$on = props.on;
    var on = _props$on === undefined ? false : _props$on;
    var label = props.label;
    var _props$subTitle = props.subTitle;
    var subTitle = _props$subTitle === undefined ? null : _props$subTitle;
    var _props$onChange = props.onChange;
    var onChange = _props$onChange === undefined ? function () {
        return console.warn("No onChange given to checkbox");
    } : _props$onChange;
    var _props$styleName = props.styleName;
    var styleName = _props$styleName === undefined ? 'core' : _props$styleName;

    var content = label;
    var toggleStyle = undefined;

    if (subTitle !== null) {
        content = React.createElement(
            'div',
            null,
            label,
            React.createElement(
                'div',
                { className: 'checkbox-core-subtitle' },
                subTitle
            )
        );
    }

    return React.createElement(
        UI.Touchable,
        { component: 'div', className: 'toggle-core-container', onTap: function () {
                return onChange(!on);
            } },
        React.createElement(
            'div',
            { className: 'toggle-core-label toggle-' + styleName + '-label-custom' },
            content
        ),
        React.createElement(
            'div',
            { className: 'toggle-core-toggle-container toggle-' + styleName + '-toggle-container-custom', 'data-on': on },
            React.createElement('div', { className: 'toggle-core-toggle toggle-' + styleName + '-toggle-custom', 'data-on': on })
        )
    );
};
Toggle.componentName = 'toggle';

_libSourceV2Style.defineCustomBase(Toggle, function (_ref) {
    var _ref$normal = _ref.normal;
    var normal = _ref$normal === undefined ? null : _ref$normal;
    var _ref$on = _ref.on;
    var on = _ref$on === undefined ? null : _ref$on;
    var _ref$label = _ref.label;
    var label = _ref$label === undefined ? null : _ref$label;
    var _ref$subtitle = _ref.subtitle;
    var subtitle = _ref$subtitle === undefined ? null : _ref$subtitle;
    return _libSourceV2Utils.transferProps({
        ".toggle-core-toggle-container/toggle-container-custom": [normal, { trackColor: 'backgroundColor' }],
        ".toggle-core-toggle-container/toggle-container-custom[data-on='true']": [on, { trackColor: 'backgroundColor' }],
        ".toggle-core-toggle/toggle-custom": [normal, { thumbColor: 'backgroundColor' }],
        ".toggle-core-toggle/toggle-custom[data-on='true']": [on, { thumbColor: 'backgroundColor' }],
        ".toggle-core-label/label-custom": [label, {
            textColor: 'color',
            color: 'backgroundColor'
        }],
        ".toggle-core-subtitle/subtitle-custom": [subtitle, {
            textColor: 'color',
            color: 'backgroundColor'
        }]
    });
});

exports['default'] = Toggle;
module.exports = exports['default'];
/*<Ripple />*/

},{"lib-source/v2/style":42,"lib-source/v2/utils":43}],24:[function(require,module,exports){
// import React from "react";
// import ReactDOM from "react-dom";

"use strict";

var _extends = require("babel-runtime/helpers/extends")["default"];

var _objectWithoutProperties = require("babel-runtime/helpers/object-without-properties")["default"];

exports.__esModule = true;
var forEach = Array.prototype.forEach;
var sqrt = Math.sqrt;

var Touchable = undefined;

Touchable = React.createClass({
    displayName: "Touchable",

    touchStart: function touchStart(evt) {
        var onTouchStart = this.props.onTouchStart;
        var _evt$changedTouches = evt.changedTouches;
        var touch = _evt$changedTouches[0];

        ReactDOM.findDOMNode(this).classList.add("cor-touch-active");
        if (onTouchStart !== undefined) {
            onTouchStart(evt);
        }

        this.info = {
            id: touch.identifier,
            x: touch.pageX,
            y: touch.pageY
        };
    },
    touchMove: function touchMove(evt) {
        var _context,
            _this = this;

        var onTouchMove = this.props.onTouchMove;

        if (onTouchMove !== undefined) {
            onTouchMove(evt);
        }

        (_context = evt.changedTouches, forEach).call(_context, function (touch) {
            if (touch.identifier !== _this.info.id) {
                return;
            }

            if (sqrt(Math.pow(touch.pageX - _this.info.x, 2) + Math.pow(touch.pageY - _this.info.y, 2)) > 25) {
                ReactDOM.findDOMNode(_this).classList.remove("cor-touch-active");
            }
        });
    },
    touchEnd: function touchEnd(evt) {
        var _context2,
            _this2 = this;

        var onTouchEnd = this.props.onTouchEnd;

        if (onTouchEnd !== undefined) {
            onTouchEnd(evt);
        }
        (_context2 = evt.changedTouches, forEach).call(_context2, function (touch) {
            if (touch.identifier !== _this2.info.id) {
                return;
            }

            ReactDOM.findDOMNode(_this2).classList.remove("cor-touch-active");
        });
        // this.props.onTouchEnd(evt);
    },
    getBoundingClientRect: function getBoundingClientRect() {
        return this.refs.node.getBoundingClientRect();
    },
    componentDidMount: function componentDidMount() {
        var _this3 = this;

        var node = this.refs.node;

        node.addEventListener('tap', function (evt) {
            var onTap = _this3.props.onTap;

            node.focus();
            if (onTap !== undefined) {
                onTap.call(_this3, evt);
            }
            // ::this.props.onTap(evt);
        });
        node.addEventListener('hold', function (evt) {
            var onHold = _this3.props.onHold;

            node.focus();
            if (onHold !== undefined) {
                onHold.call(_this3, evt);
            }
            // ::this.props.onHold(evt);
        });
    },
    render: function render() {
        var _props = this.props;
        var _props$component = _props.component;
        var component = _props$component === undefined ? null : _props$component;
        var children = _props.children;
        var onTap = _props.onTap;
        var onHold = _props.onHold;

        var props = _objectWithoutProperties(_props, ["component", "children", "onTap", "onHold"]);

        var Component = component;
        var componentProps = _extends({}, props, {
            onTouchStart: this.touchStart,
            onTouchMove: this.touchMove,
            onTouchEnd: this.touchEnd,
            onTouchCancel: this.touchEnd
        });

        if (Component === null) {
            throw new Error("Must pass a component into Touchable");
        }

        return React.createElement(
            Component,
            _extends({ ref: "node" }, componentProps),
            children
        );
    }
});

exports["default"] = Touchable;
module.exports = exports["default"];

},{"babel-runtime/helpers/extends":58,"babel-runtime/helpers/object-without-properties":61}],25:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("babel-runtime/helpers/interop-require-default")["default"];

exports.__esModule = true;

var _libSourceV2StyleJs = require("lib-source/v2/style.js");

var _libSourceUiv2RippleJs = require("lib-source/uiv2/ripple.js");

var _libSourceUiv2RippleJs2 = _interopRequireDefault(_libSourceUiv2RippleJs);

var _libSourceUiv2IconJs = require('lib-source/uiv2/icon.js');

var _libSourceUiv2IconJs2 = _interopRequireDefault(_libSourceUiv2IconJs);

var _libSourceUiv2Touchable = require('lib-source/uiv2/Touchable');

var _libSourceUiv2Touchable2 = _interopRequireDefault(_libSourceUiv2Touchable);

var _libSourceUiv2Vars = require('lib-source/uiv2/vars');

var _libSourceUiv2Vars2 = _interopRequireDefault(_libSourceUiv2Vars);

var _libSourceV2Utils = require('lib-source/v2/utils');

_libSourceV2StyleJs.defineComponentStyle('button', 'core', {
    "wrapper": {
        position: 'relative',
        textAlign: 'center',
        margin: 4,
        overflow: 'hidden',
        zIndex: "+0",
        whiteSpace: 'pre',
        display: 'inline-block',
        backgroundColor: 'transparent',
        color: 'black',
        borderRadius: 3
    },
    "wrapper:focus": {
        outline: 'none'
    },
    "wrapper[disabled]": {
        backgroundColor: '#eaeaea',
        color: '#a0a0a0'
    },
    "text-wrapper": {
        display: 'table',
        width: '100%'
    },
    "text": {
        height: '100%',
        width: '100%',
        padding: 5,
        paddingLeft: 15,
        paddingRight: 15,
        textAlign: 'center',
        verticalAlign: 'middle',
        whiteSpace: 'pre',
        display: 'table-cell'
    },
    "wrapper > overlay": {
        position: 'absolute',
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        transition: 'background-color 500ms linear'
    },
    ".core-desktop overlay:hover": {
        backgroundColor: _libSourceUiv2Vars2["default"].hoverColor
    },
    "wrapper:active > overlay": {
        backgroundColor: _libSourceUiv2Vars2["default"].activeColor,
        transition: 'none'
    }
});

var Button = function Button(props) {
    var text = props.text;
    var _props$onTap = props.onTap;
    var onTap = _props$onTap === undefined ? function () {
        return console.warn("No onTap given to Button");
    } : _props$onTap;
    var _props$styleName = props.styleName;
    var styleName = _props$styleName === undefined ? "core" : _props$styleName;
    var _props$buttonColor = props.buttonColor;
    var buttonColor = _props$buttonColor === undefined ? null : _props$buttonColor;
    var _props$textColor = props.textColor;
    var textColor = _props$textColor === undefined ? null : _props$textColor;
    var flush = props.flush;
    var block = props.block;
    var fill = props.fill;
    var padding = props.padding;
    var disabled = props.disabled;
    var _props$iconName = props.iconName;
    var iconName = _props$iconName === undefined ? null : _props$iconName;
    var _props$iconSize = props.iconSize;
    var iconSize = _props$iconSize === undefined ? null : _props$iconSize;

    var wrapperName = "button-core-wrapper button-" + styleName + "-wrapper-custom";

    var wrapperStyle = { backgroundColor: buttonColor };
    var textWrapperStyle = {};
    var textStyle = { color: textColor };
    var rippleElement = undefined;
    var onTapHandler = undefined;

    if (disabled !== true) {
        // rippleElement = <Ripple />;
        onTapHandler = onTap;
    }
    if (block === true) {
        wrapperStyle.display = 'block';
    }
    if (fill === true) {
        flush = true;
        wrapperStyle.width = '100%';
        wrapperStyle.height = '100%';
        textWrapperStyle.height = '100%';
        textStyle.padding = 0;
    }
    if (flush === true) {
        wrapperStyle.margin = 0;
    }
    if (iconName !== null) {
        text = React.createElement(
            "span",
            null,
            React.createElement(_libSourceUiv2IconJs2["default"], { name: iconName, size: iconSize }),
            text
        );
    }

    return React.createElement(
        _libSourceUiv2Touchable2["default"],
        { component: "div", tabIndex: -1, className: wrapperName, onTap: onTapHandler, disabled: disabled, style: wrapperStyle },
        React.createElement(
            "div",
            { className: "button-core-text-wrapper", style: textWrapperStyle },
            React.createElement(
                "div",
                { className: "button-core-text", style: textStyle },
                text
            )
        ),
        React.createElement("div", { className: "button-core-overlay" }),
        rippleElement
    );
};
Button.componentName = 'button';

_libSourceV2StyleJs.defineCustomBase(Button, function (_ref) {
    var _ref$normal = _ref.normal;
    var normal = _ref$normal === undefined ? null : _ref$normal;
    var _ref$focus = _ref.focus;
    var focus = _ref$focus === undefined ? null : _ref$focus;
    var _ref$disabled = _ref.disabled;
    var disabled = _ref$disabled === undefined ? null : _ref$disabled;
    return _libSourceV2Utils.transferProps({
        ".button-core-wrapper/wrapper-custom": [normal, {
            textColor: 'color',
            color: 'backgroundColor',
            borderRadius: 'borderRadius',
            shadow: 'boxShadow'
        }
        // ['backgroundColor', 'color', 'borderRadius', 'boxShadow']
        ],
        ".button-core-wrapper/wrapper-custom:focus": [focus, {
            textColor: 'color',
            color: 'backgroundColor',
            borderRadius: 'borderRadius',
            shadow: 'boxShadow'
        }
        // ['backgroundColor', 'color', 'borderRadius', 'boxShadow']
        ],
        ".button-core-wrapper/wrapper-custom[disabled]": [disabled, {
            textColor: 'color',
            color: 'backgroundColor',
            borderRadius: 'borderRadius',
            shadow: 'boxShadow'
        }
        // ['backgroundColor', 'color', 'borderRadius', 'boxShadow']
        ]
    });
});

_libSourceV2StyleJs.defineStyleForComponent(Button, "cancel", {
    normal: {
        color: "#b5263e",
        textColor: 'white'
    }
});
_libSourceV2StyleJs.defineStyleForComponent(Button, "confirm", {
    normal: {
        color: "#30d5a7"
    }
});

exports["default"] = Button;
module.exports = exports["default"];

},{"babel-runtime/helpers/interop-require-default":60,"lib-source/uiv2/Touchable":24,"lib-source/uiv2/icon.js":27,"lib-source/uiv2/ripple.js":36,"lib-source/uiv2/vars":37,"lib-source/v2/style.js":42,"lib-source/v2/utils":43}],26:[function(require,module,exports){
"use strict";

var _inherits = require("babel-runtime/helpers/inherits")["default"];

var _classCallCheck = require("babel-runtime/helpers/class-call-check")["default"];

var _regeneratorRuntime = require("babel-runtime/regenerator")["default"];

var _Promise = require("babel-runtime/core-js/promise")["default"];

var _interopRequireDefault = require("babel-runtime/helpers/interop-require-default")["default"];

exports.__esModule = true;

var _libSourceV2Style = require("lib-source/v2/style");

var _libSourceUiv2Button = require("lib-source/uiv2/Button");

var _libSourceUiv2Button2 = _interopRequireDefault(_libSourceUiv2Button);

var _libSourceUiv2Touchable = require("lib-source/uiv2/Touchable");

var _libSourceUiv2Touchable2 = _interopRequireDefault(_libSourceUiv2Touchable);

var animationTime = 250;
_libSourceV2Style.defineComponentStyle('dialog', 'core', {
    "overlay": {
        position: 'absolute',
        top: 0,
        left: 0,
        width: '100%',
        height: '100%',
        backgroundColor: 'rgba(0, 0, 0, 0.35)',
        zIndex: '+100',
        display: 'none',
        WebkitOverflowScrolling: 'auto',
        opacity: 0,
        transition: "opacity " + animationTime + "ms linear"
    },

    "window": {
        position: 'absolute',
        backgroundColor: 'white',
        boxShadow: '0px 0px 10px rgba(0, 0, 0, 0.6)',
        // borderRadius: 5,
        width: '75%',
        maxWidth: 480,
        padding: 0,
        overflow: 'hidden'
    },
    "window-top": {
        top: '15%',
        left: '50%',
        transform: 'translateX(-50%)'
    },
    "window-center": {
        top: '50%',
        left: '50%',
        transform: 'translate(-50%, -50%)'
    },

    "content": {
        maxHeight: '50vh',
        WebkitOverflowScrolling: 'touch',
        overflow: 'auto',
        borderBottom: '1px solid lightgray',
        borderTop: '1px solid lightgray'
    },
    "title": {
        padding: '5 15',
        fontSize: 20,
        fontWeight: 900,
        color: 'black'
    }
});

var currentDialog = null;
window.dialog = {
    show: function show(options) {
        return currentDialog.show(options);
    },
    hide: function hide(value) {
        return currentDialog.hide(value);
    },
    success: function success(value) {
        return { value: value, status: 'success' };
    },
    cancel: function cancel(value) {
        return { value: value, status: 'canceled' };
    },
    invalid: function invalid() {
        var value = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
        var reason = arguments.length <= 1 || arguments[1] === undefined ? 'invalid' : arguments[1];

        return { value: value, reason: reason };
    }
};

var Dialog = (function (_React$Component) {
    _inherits(Dialog, _React$Component);

    function Dialog(props) {
        var _this2 = this;

        _classCallCheck(this, Dialog);

        _React$Component.call(this, props);

        this.show = function callee$2$0(displayProps) {
            var _displayProps$content, content, _displayProps$closable, closable, _displayProps$buttons, buttons, _displayProps$title, title, _displayProps$setup, setup;

            return _regeneratorRuntime.async(function callee$2$0$(context$3$0) {
                var _this = this;

                while (1) switch (context$3$0.prev = context$3$0.next) {
                    case 0:
                        if (!(this.animating === true || this.resolver !== null)) {
                            context$3$0.next = 2;
                            break;
                        }

                        return context$3$0.abrupt("return", dialog.invalid());

                    case 2:
                        this.animating = true;
                        this.resolver = new _Promise(function (resolve) {
                            _this.response = function (value) {
                                return resolve(value);
                            };
                        });

                        _displayProps$content = displayProps.content;
                        content = _displayProps$content === undefined ? null : _displayProps$content;
                        _displayProps$closable = displayProps.closable;
                        closable = _displayProps$closable === undefined ? true : _displayProps$closable;
                        _displayProps$buttons = displayProps.buttons;
                        buttons = _displayProps$buttons === undefined ? [{ text: 'ok' }] : _displayProps$buttons;
                        _displayProps$title = displayProps.title;
                        title = _displayProps$title === undefined ? null : _displayProps$title;
                        _displayProps$setup = displayProps.setup;
                        setup = _displayProps$setup === undefined ? null : _displayProps$setup;

                        this.setState({ display: 'block', content: content, buttons: buttons, closable: closable, title: title });
                        context$3$0.next = 17;
                        return _regeneratorRuntime.awrap(chrono.wait(50));

                    case 17:
                        this.refs.container.scrollTop = 0;
                        if (setup !== null) {
                            setup(this.refs.container);
                        }
                        this.setState({ opacity: 1 });
                        context$3$0.next = 22;
                        return _regeneratorRuntime.awrap(chrono.wait(animationTime));

                    case 22:
                        this.animating = false;
                        context$3$0.next = 25;
                        return _regeneratorRuntime.awrap(this.resolver);

                    case 25:
                        return context$3$0.abrupt("return", context$3$0.sent);

                    case 26:
                    case "end":
                        return context$3$0.stop();
                }
            }, null, _this2);
        };

        this.hide = function callee$2$0(value) {
            return _regeneratorRuntime.async(function callee$2$0$(context$3$0) {
                var _this3 = this;

                while (1) switch (context$3$0.prev = context$3$0.next) {
                    case 0:
                        if (!(this.animating === true || this.resolve === null)) {
                            context$3$0.next = 2;
                            break;
                        }

                        return context$3$0.abrupt("return");

                    case 2:
                        this.animating = true;
                        this.setState({ opacity: null });
                        context$3$0.next = 6;
                        return _regeneratorRuntime.awrap(chrono.wait(animationTime));

                    case 6:
                        this.setState({ display: null });
                        requestAnimationFrame(function () {
                            _this3.response(value);
                            _this3.response = null;
                            _this3.resolver = null;
                        });
                        this.animating = false;

                    case 9:
                    case "end":
                        return context$3$0.stop();
                }
            }, null, _this2);
        };

        this.close = function () {
            if (_this2.state.closable === false) {
                return;
            }
            _this2.hide(dialog.cancel(null));
        };

        this.stopper = function (evt) {
            evt.stopPropagation();
        };

        this.componentDidMount = function () {
            currentDialog = _this2;
        };

        this.componentWillUnmount = function () {
            currentDialog = null;
        };

        this.render = function () {
            var _state = _this2.state;
            var display = _state.display;
            var opacity = _state.opacity;
            var pos = _state.pos;
            var content = _state.content;
            var buttons = _state.buttons;
            var title = _state.title;

            var buttonList = (buttons || []).map(function (_ref, index) {
                var text = _ref.text;
                var _ref$value = _ref.value;
                var value = _ref$value === undefined ? null : _ref$value;
                var _ref$cancels = _ref.cancels;
                var cancels = _ref$cancels === undefined ? false : _ref$cancels;

                // const valueFunc = (cancels === true) ? dialog.cancel : dialog.success;
                var onTap = function onTap() {
                    if (typeof value === 'function') {
                        value = value(_this2.refs.container);
                    }
                    var retValue = cancels === true ? dialog.cancel(value) : dialog.success(value);

                    _this2.hide(retValue);
                };
                return React.createElement(_libSourceUiv2Button2["default"], { text: text, key: index, onTap: onTap, block: true, flush: true });
            });
            var titleDisplay = null;

            if (title !== null) {
                titleDisplay = React.createElement(
                    "div",
                    { className: "dialog-core-title" },
                    title
                );
            }

            return React.createElement(
                _libSourceUiv2Touchable2["default"],
                { component: "div", onTap: _this2.close, className: "dialog-core-overlay", style: { display: display, opacity: opacity } },
                React.createElement(
                    _libSourceUiv2Touchable2["default"],
                    { component: "div", className: "dialog-core-window dialog-core-window-" + pos, onTap: _this2.stopper },
                    titleDisplay,
                    React.createElement(
                        "div",
                        { className: "dialog-core-content", ref: "container" },
                        content
                    ),
                    React.createElement(
                        UI.Flexbox,
                        { colCount: 3 },
                        buttonList
                    )
                )
            );
        };

        this.state = {
            display: null,
            opacity: null,
            name: null,
            pos: 'top',
            content: null,
            closable: !true,
            buttons: null,
            title: null
        };
        this.animating = false;
        this.resolver = null;
    }

    return Dialog;
})(React.Component);

exports["default"] = Dialog;
module.exports = exports["default"];

// console.log(this.animating, this.animating === true);
/*<Button text="demo" block onTap={() => this.hide('test')} />*/

},{"babel-runtime/core-js/promise":54,"babel-runtime/helpers/class-call-check":57,"babel-runtime/helpers/inherits":59,"babel-runtime/helpers/interop-require-default":60,"babel-runtime/regenerator":148,"lib-source/uiv2/Button":9,"lib-source/uiv2/Touchable":24,"lib-source/v2/style":42}],27:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _libSourceV2StyleJs = require("lib-source/v2/style.js");

_libSourceV2StyleJs.defineComponentStyle('icon', 'core', {
    "content": {
        fontFamily: "Ionic",
        marginLeft: 2,
        marginRight: 2
    }
});
var Icon = function Icon(_ref) {
    var name = _ref.name;
    var _ref$styleName = _ref.styleName;
    var styleName = _ref$styleName === undefined ? 'core' : _ref$styleName;
    var size = _ref.size;
    return React.createElement(
        'span',
        { className: 'icon-' + styleName + '-content', style: { fontSize: size } },
        ionic[name]
    );
};

exports['default'] = Icon;
module.exports = exports['default'];

},{"lib-source/v2/style.js":42}],28:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

exports.__esModule = true;

var _libSourceV2StyleJs = require("lib-source/v2/style.js");

// import Ripple from "lib-source/uiv2/ripple.js";

var _libSourceUiv2IconJs = require('lib-source/uiv2/icon.js');

var _libSourceUiv2IconJs2 = _interopRequireDefault(_libSourceUiv2IconJs);

_libSourceV2StyleJs.defineComponentStyle('icon-button', 'core', {
    "wrapper": {
        position: 'relative',
        textAlign: 'center',
        margin: 4,
        overflow: 'hidden',
        zIndex: "+0",
        backgroundColor: 'transparent',
        color: 'black',
        display: 'inline-block',
        borderRadius: '50%'
    }
});
var IconButton = function IconButton(props) {
    var _props$size = props.size;
    var size = _props$size === undefined ? 42 : _props$size;
    var name = props.name;
    var iconSize = props.iconSize;
    var _props$styleName = props.styleName;
    var styleName = _props$styleName === undefined ? 'core' : _props$styleName;

    var wrapperName = 'icon-button-' + styleName + '-wrapper';

    return React.createElement(
        UI.Touchable,
        { component: 'div', className: wrapperName, style: { width: size, height: size } },
        React.createElement(
            'div',
            { className: 'button-core-text-wrapper', style: { height: '100%' } },
            React.createElement(
                'div',
                { className: 'button-core-text', style: { padding: 0 } },
                React.createElement(_libSourceUiv2IconJs2['default'], { name: name, size: iconSize })
            )
        )
    );
};

exports['default'] = IconButton;
module.exports = exports['default'];

},{"babel-runtime/helpers/interop-require-default":60,"lib-source/uiv2/icon.js":27,"lib-source/v2/style.js":42}],29:[function(require,module,exports){
"use strict";

var _regeneratorRuntime = require("babel-runtime/regenerator")["default"];

var _interopRequireDefault = require("babel-runtime/helpers/interop-require-default")["default"];

exports.__esModule = true;

var _this = this;

var _libSourceV2Style = require("lib-source/v2/style");

var _libSourceUiv2Button = require("lib-source/uiv2/Button");

var _libSourceUiv2Button2 = _interopRequireDefault(_libSourceUiv2Button);

var _libSourceUiv2Calendar = require("lib-source/uiv2/Calendar");

var _libSourceUiv2Calendar2 = _interopRequireDefault(_libSourceUiv2Calendar);

var DateInput = function DateInput(_ref) {
    var _ref$value = _ref.value;
    var value = _ref$value === undefined ? chrono() : _ref$value;
    var _ref$format = _ref.format;
    var format = _ref$format === undefined ? "{month}/{day}/{year}" : _ref$format;
    var _ref$onChange = _ref.onChange;
    var onChange = _ref$onChange === undefined ? function () {} : _ref$onChange;
    var iconName = _ref.iconName;

    var changeDate = function changeDate() {
        var handler, result;
        return _regeneratorRuntime.async(function changeDate$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
                case 0:
                    handler = function handler(date) {
                        dialog.hide(dialog.success(date));
                    };

                    context$2$0.next = 3;
                    return _regeneratorRuntime.awrap(dialog.show({
                        content: React.createElement(_libSourceUiv2Calendar2["default"], { selectedDate: value, onChange: handler, key: Date.now() }),
                        buttons: [{ text: "Cancel" }]
                    }));

                case 3:
                    result = context$2$0.sent;
                    // title: "Select Date"

                    if (result.value !== null) {
                        onChange(result.value);
                    }

                case 5:
                case "end":
                    return context$2$0.stop();
            }
        }, null, _this);
    };
    return React.createElement(
        "div",
        { style: { height: 30 } },
        React.createElement(_libSourceUiv2Button2["default"], { text: value.format(format), onTap: changeDate, flush: true, fill: true, iconName: iconName })
    );
};

DateInput.valueProp = 'value';
DateInput.valueFunction = function (date) {
    return date;
};
DateInput.defaultPropValue = function () {
    return chrono();
};

exports["default"] = DateInput;
module.exports = exports["default"];

},{"babel-runtime/helpers/interop-require-default":60,"babel-runtime/regenerator":148,"lib-source/uiv2/Button":9,"lib-source/uiv2/Calendar":10,"lib-source/v2/style":42}],30:[function(require,module,exports){
"use strict";

var _inherits = require("babel-runtime/helpers/inherits")["default"];

var _classCallCheck = require("babel-runtime/helpers/class-call-check")["default"];

var _objectWithoutProperties = require("babel-runtime/helpers/object-without-properties")["default"];

var _extends = require("babel-runtime/helpers/extends")["default"];

var _Array$from = require("babel-runtime/core-js/array/from")["default"];

var _interopRequireDefault = require("babel-runtime/helpers/interop-require-default")["default"];

exports.__esModule = true;

var _libSourceV2Style = require("lib-source/v2/style");

var _libSourceUiv2Button = require('lib-source/uiv2/Button');

var _libSourceUiv2Button2 = _interopRequireDefault(_libSourceUiv2Button);

var FileInput = (function (_React$Component) {
    _inherits(FileInput, _React$Component);

    function FileInput(props) {
        var _this = this;

        _classCallCheck(this, FileInput);

        _React$Component.call(this, props);

        this.trigger = function () {
            _this.refs.file.click();
        };

        this.upload = function (evt) {
            _this.props.onChange(_Array$from(evt.target.files));
        };

        this.render = function () {
            var _props = _this.props;
            var value = _props.value;
            var _props$valueFormat = _props.valueFormat;
            var valueFormat = _props$valueFormat === undefined ? function (fileList) {
                return fileList[0].name;
            } : _props$valueFormat;
            var _props$nullText = _props.nullText;
            var nullText = _props$nullText === undefined ? "Select a file" : _props$nullText;

            var props = _objectWithoutProperties(_props, ["value", "valueFormat", "nullText"]);

            var buttonText = undefined;

            if (typeof value === 'string') {
                buttonText = value;
            }
            if (Array.isArray(value) === true) {
                buttonText = valueFormat(value);
            }

            if (value === null) {
                buttonText = nullText;
            }

            return React.createElement(
                "div",
                null,
                React.createElement("input", _extends({}, props, { type: "file", ref: "file", style: { display: 'none' }, value: "", onChange: _this.upload })),
                React.createElement(_libSourceUiv2Button2["default"], { text: buttonText, onTap: _this.trigger, block: true })
            );
        };
    }

    return FileInput;
})(React.Component);

FileInput.valueProp = "value";
FileInput.valueFunction = function (fileList) {
    return fileList;
};
FileInput.defaultPropValue = null;

exports["default"] = FileInput;
module.exports = exports["default"];

},{"babel-runtime/core-js/array/from":45,"babel-runtime/helpers/class-call-check":57,"babel-runtime/helpers/extends":58,"babel-runtime/helpers/inherits":59,"babel-runtime/helpers/interop-require-default":60,"babel-runtime/helpers/object-without-properties":61,"lib-source/uiv2/Button":9,"lib-source/v2/style":42}],31:[function(require,module,exports){
"use strict";

var _extends = require("babel-runtime/helpers/extends")["default"];

var _interopRequireDefault = require("babel-runtime/helpers/interop-require-default")["default"];

exports.__esModule = true;

var _libSourceV2Style = require("lib-source/v2/style");

var _libSourceUiv2Button = require('lib-source/uiv2/Button');

var _libSourceUiv2Button2 = _interopRequireDefault(_libSourceUiv2Button);

var coolBlue = "#2FB1DF";
var clampValue = function clampValue(value, min, max) {
    return Math.min(Math.max(value, min), max);
};
var thumbSize = {
    width: 24,
    height: 24
};
var trackBase = {
    position: 'absolute',
    left: 0,
    top: '50%',
    transform: 'translateY(-50%)',
    height: 4,
    borderRadius: 2
};
_libSourceV2Style.defineComponentStyle('range-input', 'core', {
    "wrapper": {
        height: 30,
        position: 'relative'
    },
    "focus-background": {
        position: 'absolute',
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        opacity: 0
    },
    "track-container": {
        position: 'absolute',
        top: 0,
        left: 12,
        right: 12,
        bottom: 0
    },
    "track-background": _extends({}, trackBase, {
        right: 0,
        backgroundColor: 'lightgray'
    }),
    "track": _extends({}, trackBase, {
        backgroundColor: coolBlue
    }),
    "track::after": _extends({}, thumbSize, {
        boxSizing: 'border-box',
        position: 'absolute',
        top: '50%',
        right: 0,
        transform: 'translate(50%, -50%)',
        backgroundColor: 'white',
        border: "3px solid " + coolBlue,
        borderRadius: '50%',
        content: "''"
    }),
    "arrow": {
        position: 'absolute',
        top: 0,
        bottom: 0,
        width: 30,
        color: 'black'
    },
    "wrapper > $input[type='range']": {
        WebkitAppearance: 'none',
        width: '100%',
        height: '100%',
        left: 0,
        right: 0,
        margin: 0,
        zIndex: '+10',
        position: 'absolute',
        opacity: 0
    },
    "wrapper > $input[type='range']::-webkit-slider-thumb": _extends({}, thumbSize, {
        borderRadius: '50%',
        WebkitAppearance: 'none',
        backgroundColor: 'green'
    }),
    "wrapper > $input[type='range']:focus + focus-background": {
        opacity: 1
    }
});
var RangeInput = function RangeInput(props) {
    var _props$min = props.min;
    var min = _props$min === undefined ? 0 : _props$min;
    var _props$max = props.max;
    var max = _props$max === undefined ? 10 : _props$max;
    var _props$step = props.step;
    var step = _props$step === undefined ? 1 : _props$step;
    var _props$onChange = props.onChange;
    var onChange = _props$onChange === undefined ? function () {} : _props$onChange;
    var _props$focusStyle = props.focusStyle;
    var focusStyle = _props$focusStyle === undefined ? null : _props$focusStyle;
    var label = props.label;
    var _props$showArrows = props.showArrows;
    var showArrows = _props$showArrows === undefined ? false : _props$showArrows;

    var range = max - min;
    var changeHandler = function changeHandler(evt) {
        // evt.target.focus();
        onChange(evt.target.value);
    };
    var _props$value = props.value;
    var value = _props$value === undefined ? null : _props$value;

    var adjusted = undefined;
    var inputOffset = null;
    var trackOffset = null;
    var arrows = null;

    if (value === null) {
        value = min;
    }

    adjusted = value - min;
    if (adjusted % step !== 0) {
        adjusted -= adjusted % step;
    }
    adjusted = clampValue(adjusted, min, max);

    if (showArrows === true) {
        var arrowChange = function arrowChange(adjust) {
            return function () {
                var newValue = value + adjust;
                newValue = Math.max(newValue, min);
                newValue = Math.min(newValue, max);
                if (value !== newValue) {
                    onChange(newValue);
                }
            };
        };
        inputOffset = { left: 30, width: 'calc(100% - 60px)' };
        trackOffset = { left: 42, right: 42 };
        arrows = [React.createElement(
            "div",
            { className: "range-input-core-arrow", style: { left: 0 }, key: 0 },
            React.createElement(_libSourceUiv2Button2["default"], { iconName: "ion-arrow-left-b", flush: true, fill: true, iconSize: 20, onTap: arrowChange(-1) })
        ), React.createElement(
            "div",
            { className: "range-input-core-arrow", style: { right: 0 }, key: 1 },
            React.createElement(_libSourceUiv2Button2["default"], { iconName: "ion-arrow-right-b", flush: true, fill: true, iconSize: 20, onTap: arrowChange(1) })
        )];
    }

    return React.createElement(
        "div",
        null,
        React.createElement(
            "div",
            { className: "input-core-label" },
            label
        ),
        React.createElement(
            "div",
            { className: "range-input-core-wrapper" },
            React.createElement("input", { type: "range", style: inputOffset, min: min, max: max, step: step, value: adjusted, onChange: changeHandler, onTouchStart: function (evt) {
                    return evt.target.focus();
                } }),
            React.createElement("div", { className: "range-input-core-focus-background", style: focusStyle }),
            React.createElement(
                "div",
                { className: "range-input-core-track-container", style: trackOffset },
                React.createElement("div", { className: "range-input-core-track-background" }),
                React.createElement("div", { className: "range-input-core-track", style: { width: adjusted / range * 100 + "%" } })
            ),
            arrows
        )
    );
};

RangeInput.valueProp = 'value';
RangeInput.valueFunction = function (n) {
    return n;
};
RangeInput.defaultPropValue = 0;

exports["default"] = RangeInput;
module.exports = exports["default"];

},{"babel-runtime/helpers/extends":58,"babel-runtime/helpers/interop-require-default":60,"lib-source/uiv2/Button":9,"lib-source/v2/style":42}],32:[function(require,module,exports){
'use strict';

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _objectWithoutProperties = require('babel-runtime/helpers/object-without-properties')['default'];

var _extends = require('babel-runtime/helpers/extends')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

exports.__esModule = true;

var _libSourceV2Style = require("lib-source/v2/style");

var _libSourceUiv2Button = require('lib-source/uiv2/Button');

var _libSourceUiv2Button2 = _interopRequireDefault(_libSourceUiv2Button);

var _libSourceUiv2TimeSelector = require('lib-source/uiv2/TimeSelector');

var _libSourceUiv2TimeSelector2 = _interopRequireDefault(_libSourceUiv2TimeSelector);

var _libSourceV2Shared = require("lib-source/v2/shared");

var TimeInput = (function (_React$Component) {
    _inherits(TimeInput, _React$Component);

    function TimeInput(props) {
        var _this = this;

        _classCallCheck(this, TimeInput);

        _React$Component.call(this, props);

        this.select = function callee$2$0() {
            var _props, _props$onChange, onChange, timeFormat, currentDate, result;

            return _regeneratorRuntime.async(function callee$2$0$(context$3$0) {
                while (1) switch (context$3$0.prev = context$3$0.next) {
                    case 0:
                        _props = this.props;
                        _props$onChange = _props.onChange;
                        onChange = _props$onChange === undefined ? warningFunc("onChange not given to TimeInput") : _props$onChange;
                        timeFormat = _props.timeFormat;
                        currentDate = _libSourceV2Shared.sharedReference(this.props.value);
                        context$3$0.next = 7;
                        return _regeneratorRuntime.awrap(dialog.show({
                            // content: <div style={{padding: 3}}><TimeSelector value={currentDate} onChange={date => currentDate = date} /></div>,
                            content: React.createElement(_libSourceV2Shared.SharedObjectDisplay, { key: Date.now(), reference: currentDate, component: _libSourceUiv2TimeSelector2['default'], valueProp: 'value', format: timeFormat }),
                            buttons: [{ text: "Cancel", cancels: true }, { text: "Set", value: function value() {
                                    return currentDate.value;
                                } }]
                        }));

                    case 7:
                        result = context$3$0.sent;

                        if (result.status === 'success') {
                            onChange(result.value);
                        }

                    case 9:
                    case 'end':
                        return context$3$0.stop();
                }
            }, null, _this);
        };

        this.render = function () {
            var _props2 = _this.props;
            var _props2$format = _props2.format;
            var format = _props2$format === undefined ? "{hour}:{minute/padded}" : _props2$format;
            var value = _props2.value;

            var buttonProps = _objectWithoutProperties(_props2, ['format', 'value']);

            return React.createElement(_libSourceUiv2Button2['default'], _extends({}, buttonProps, { text: value.format(format), onTap: _this.select, block: true }));
        };
    }

    return TimeInput;
})(React.Component);

TimeInput.valueProp = 'value';
TimeInput.valueFunction = function (date) {
    return date;
};
TimeInput.defaultPropValue = function () {
    return chrono();
};

exports['default'] = TimeInput;
module.exports = exports['default'];

},{"babel-runtime/helpers/class-call-check":57,"babel-runtime/helpers/extends":58,"babel-runtime/helpers/inherits":59,"babel-runtime/helpers/interop-require-default":60,"babel-runtime/helpers/object-without-properties":61,"babel-runtime/regenerator":148,"lib-source/uiv2/Button":9,"lib-source/uiv2/TimeSelector":22,"lib-source/v2/shared":41,"lib-source/v2/style":42}],33:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("babel-runtime/helpers/interop-require-default")["default"];

exports.__esModule = true;

var _libSourceV2Style = require("lib-source/v2/style");

var _libSourceUiv2Touchable = require("lib-source/uiv2/Touchable");

var _libSourceUiv2Touchable2 = _interopRequireDefault(_libSourceUiv2Touchable);

var coolBlue = "#2FB1DF";

_libSourceV2Style.defineComponentStyle('flexbox', 'core', {
    "container": {
        display: ['-webkit-flex', 'flex'],
        WebkitFlexWrap: 'wrap',
        flexWrap: 'wrap'
    }
});
// alignItems: 'center',
// justifyContent: 'center'
var Flexbox = function Flexbox(props) {
    var colCount = props.colCount;
    var _props$width = props.width;
    var width = _props$width === undefined ? '100%' : _props$width;
    var _props$padEnd = props.padEnd;
    var padEnd = _props$padEnd === undefined ? false : _props$padEnd;
    var _props$minItemWidth = props.minItemWidth;
    var minItemWidth = _props$minItemWidth === undefined ? null : _props$minItemWidth;
    var _props$maxItemWidth = props.maxItemWidth;
    var maxItemWidth = _props$maxItemWidth === undefined ? null : _props$maxItemWidth;
    var _props$align = props.align;
    var align = _props$align === undefined ? 'center' : _props$align;

    var flexWidth = 100 / colCount;
    var children = props.children;

    if (isNaN(flexWidth) === true || flexWidth <= 0) {
        throw new Error("Invalid width property for Flexbox");
    }

    children = React.Children.toArray(children);
    if (padEnd === true && minItemWidth === null && maxItemWidth === null) {
        var filler = new Array(colCount - children.length % colCount).fill(null).map(function () {
            return React.createElement("div", null);
        });
        children = [].concat(children, filler);
    }

    children = children.map(function (child, index) {
        return React.createElement(FlexboxItem, { key: index, width: flexWidth, content: child, minWidth: minItemWidth, maxWidth: maxItemWidth });
    });

    // console.trace();

    return React.createElement(
        "div",
        { style: { width: width, justifyContent: align, WebkitJustifyContent: align }, className: "flexbox-core-container" },
        children
    );
};
var FlexboxItem = function FlexboxItem(_ref) {
    var content = _ref.content;
    var width = _ref.width;
    var maxWidth = _ref.maxWidth;
    var minWidth = _ref.minWidth;

    var flexCSS = "1 0 " + width + "%";
    var itemStyle = {
        WebkitFlex: flexCSS,
        flex: flexCSS,
        maxWidth: maxWidth,
        minWidth: minWidth
    };

    return React.createElement(
        "div",
        { style: itemStyle },
        content
    );
};

_libSourceV2Style.defineComponentStyle("flexbox-radio", 'core', {
    'item': {
        transition: 'background-color 500ms linear'
    },
    "item:active": {
        backgroundColor: 'rgba(0, 0, 0, 0.1)',
        transition: 'none'
    },
    "item[data-checked='true']": {
        backgroundColor: coolBlue,
        color: 'white',
        transition: 'none'
    }
});
Flexbox.RadioItem = function (_ref2) {
    var children = _ref2.children;
    var checked = _ref2.checked;
    var onTap = _ref2.onTap;
    return React.createElement(
        _libSourceUiv2Touchable2["default"],
        { component: "div", className: "flexbox-radio-core-item", "data-checked": checked, onTap: onTap },
        children
    );
};

exports["default"] = Flexbox;
module.exports = exports["default"];

},{"babel-runtime/helpers/interop-require-default":60,"lib-source/uiv2/Touchable":24,"lib-source/v2/style":42}],34:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("babel-runtime/helpers/interop-require-default")["default"];

exports.__esModule = true;

var _libSourceV2Style = require("lib-source/v2/style");

var _libSourceUiv2Touchable = require("lib-source/uiv2/Touchable");

var _libSourceUiv2Touchable2 = _interopRequireDefault(_libSourceUiv2Touchable);

var coolBlue = "#2FB1DF";

_libSourceV2Style.defineComponentStyle('grid', 'core', {
    "item": {
        position: "absolute"
    }
});

var Grid = function Grid(_ref) {
    var children = _ref.children;
    var colCount = _ref.colCount;
    var rowCount = _ref.rowCount;
    var _ref$width = _ref.width;
    var width = _ref$width === undefined ? '100%' : _ref$width;
    var _ref$height = _ref.height;
    var height = _ref$height === undefined ? '100%' : _ref$height;

    if (height === null) {
        throw new Error("Height needs to be given to the grid");
    }
    var itemWidth = 100 / colCount;
    var itemHeight = 100 / rowCount;
    var gridStyle = {
        position: 'relative',
        width: width,
        height: height
    };

    children = React.Children.toArray(children);

    return React.createElement(
        "div",
        { style: gridStyle },
        children.map(function (child, index) {
            return React.createElement(GridItem, { key: index, width: itemWidth, height: itemHeight, x: index % colCount, y: Math.floor(index / colCount), content: child });
        })
    );
};
var GridItem = function GridItem(_ref2) {
    var width = _ref2.width;
    var height = _ref2.height;
    var x = _ref2.x;
    var y = _ref2.y;
    var content = _ref2.content;

    var style = {
        width: width + "%",
        height: height + "%",
        left: x * width + "%",
        top: y * height + "%"
    };

    return React.createElement(
        "div",
        { className: "grid-core-item", style: style },
        content
    );
};

_libSourceV2Style.defineComponentStyle("grid-radio", 'core', {
    'item': {
        width: '100%',
        height: '100%',
        transition: 'background-color 500ms linear'
    },
    "item:active": {
        backgroundColor: 'rgba(0, 0, 0, 0.1)',
        transition: 'none'
    },
    "item[data-checked='true']": {
        backgroundColor: coolBlue,
        color: 'white',
        transition: 'none'
    }
});
Grid.RadioItem = function (_ref3) {
    var children = _ref3.children;
    var checked = _ref3.checked;
    var onTap = _ref3.onTap;
    return React.createElement(
        _libSourceUiv2Touchable2["default"],
        { component: "div", className: "grid-radio-core-item", "data-checked": checked, onTap: onTap },
        children
    );
};

exports["default"] = Grid;
module.exports = exports["default"];

},{"babel-runtime/helpers/interop-require-default":60,"lib-source/uiv2/Touchable":24,"lib-source/v2/style":42}],35:[function(require,module,exports){
"use strict";

var _extends = require("babel-runtime/helpers/extends")["default"];

var _objectWithoutProperties = require("babel-runtime/helpers/object-without-properties")["default"];

var _interopRequireDefault = require("babel-runtime/helpers/interop-require-default")["default"];

exports.__esModule = true;

var _libSourceV2Style = require("lib-source/v2/style");

var _libSourceUiv2Touchable = require("lib-source/uiv2/Touchable");

var _libSourceUiv2Touchable2 = _interopRequireDefault(_libSourceUiv2Touchable);

var coolBlue = "#2FB1DF";

_libSourceV2Style.defineComponentStyle("pinboard", 'core', {
    'container': {
        position: 'relative'
    }
});
var Pinboard = function Pinboard(_ref) {
    var children = _ref.children;
    var _ref$width = _ref.width;
    var width = _ref$width === undefined ? '100%' : _ref$width;
    var _ref$height = _ref.height;
    var height = _ref$height === undefined ? '100%' : _ref$height;

    children = React.Children.toArray(children);

    children = children.map(function (child, index) {
        var _child$props = child.props;
        var pinInfo = _child$props.pinInfo;

        var props = _objectWithoutProperties(_child$props, ["pinInfo"]);

        // const {props: {pinInfo}} = child;
        var displayedChild = React.createElement(child.type, props);
        // child = React.clone
        // console.log(child.type);

        return React.createElement(
            "div",
            { key: index, style: _extends({}, pinInfo, { position: 'absolute' }) },
            displayedChild
        );
    });

    return React.createElement(
        "div",
        { style: { position: 'relative', width: width, height: height } },
        children
    );
};
_libSourceV2Style.defineComponentStyle("pinboard-radio", 'core', {
    'item': {
        width: '100%',
        height: '100%',
        transition: 'background-color 500ms linear'
    },
    "item:active": {
        backgroundColor: 'rgba(0, 0, 0, 0.1)',
        transition: 'none'
    },
    "item[data-checked='true']": {
        backgroundColor: coolBlue,
        color: 'white',
        transition: 'none'
    }
});
Pinboard.RadioItem = function (_ref2) {
    var children = _ref2.children;
    var checked = _ref2.checked;
    var onTap = _ref2.onTap;
    return React.createElement(
        _libSourceUiv2Touchable2["default"],
        { component: "div", className: "pinboard-radio-core-item", "data-checked": checked, onTap: onTap },
        children
    );
};

exports["default"] = Pinboard;
module.exports = exports["default"];

},{"babel-runtime/helpers/extends":58,"babel-runtime/helpers/interop-require-default":60,"babel-runtime/helpers/object-without-properties":61,"lib-source/uiv2/Touchable":24,"lib-source/v2/style":42}],36:[function(require,module,exports){
'use strict';

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

exports.__esModule = true;

var _libSourceV2StyleJs = require("lib-source/v2/style.js");

var animationDuration = 300;
_libSourceV2StyleJs.defineComponentStyle('ripple', 'core', {
    "wrapper": {
        position: 'absolute',
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        zIndex: '+5'
        // transform: 'translate3d(0, 0, 0)'
    },
    "dot": {
        position: 'absolute',
        transform: 'translate(-50%, -50%)',
        animation: 'ripple-core-animation-ripple-effect ' + animationDuration + 'ms linear',
        borderRadius: '50%',
        display: 'inline-block',
        width: '250%'
    },
    "dot:before": {
        paddingTop: '100%',
        content: '""',
        float: 'left'
    },
    "!ripple-effect": {
        "0%": {
            transform: 'translate(-50%, -50%) scale(0, 0)',
            // width: 0,
            backgroundColor: 'rgba(0, 0, 0, 0)'
        },
        "70%": {
            backgroundColor: 'rgba(0, 0, 0, 0.1)'
        },
        "100%": {
            transform: 'translate(-50%, -50%) scale(1, 1)',
            // width: '150%',
            backgroundColor: 'rgba(0, 0, 0, 0.0)'
        }
    }
});

var Ripple = (function (_React$Component) {
    _inherits(Ripple, _React$Component);

    function Ripple(props) {
        var _this = this;

        _classCallCheck(this, Ripple);

        _React$Component.call(this, props);

        this.touch = function (evt) {
            var position = evt.touch.position;

            var _refs$wrapper$getBoundingClientRect = _this.refs.wrapper.getBoundingClientRect();

            var top = _refs$wrapper$getBoundingClientRect.top;
            var left = _refs$wrapper$getBoundingClientRect.left;

            _this.triggerRipple(position.x - left, position.y - top);
        };

        this.triggerRipple = function (x, y) {
            if (x === undefined) x = null;
            var list = _this.state.list;

            if (x === null) {
                var _refs$wrapper$getBoundingClientRect2 = _this.refs.wrapper.getBoundingClientRect();

                var width = _refs$wrapper$getBoundingClientRect2.width;
                var height = _refs$wrapper$getBoundingClientRect2.height;

                x = width / 2;
                y = height / 2;
            }

            chrono.trigger(animationDuration, function () {
                if (_this.active === false) {
                    return;
                }
                _this.setState({
                    list: _this.state.list.slice(1)
                });
            });
            list = [].concat(list, [{ x: x, y: y, id: Date.now() }]);

            _this.setState({ list: list });
        };

        this.componentDidMount = function () {
            _this.active = true;
        };

        this.componentWillUnmount = function () {
            _this.active = false;
            // console.log('removing');
        };

        this.render = function () {
            var list = _this.state.list;

            return React.createElement(
                UI.Touchable,
                { component: 'div', className: 'ripple-core-wrapper', onTap: _this.touch, ref: 'wrapper' },
                list.map(function (_ref) {
                    var id = _ref.id;
                    var x = _ref.x;
                    var y = _ref.y;
                    return React.createElement('div', { key: id, style: { top: y, left: x }, className: 'ripple-core-dot' });
                })
            );
        };

        this.state = { list: [] };
    }

    return Ripple;
})(React.Component);

exports['default'] = Ripple;
module.exports = exports['default'];

},{"babel-runtime/helpers/class-call-check":57,"babel-runtime/helpers/inherits":59,"lib-source/v2/style.js":42}],37:[function(require,module,exports){
"use strict";

var _Object$freeze = require("babel-runtime/core-js/object/freeze")["default"];

exports.__esModule = true;
var rgb = function rgb(r, g, b) {
    return "rgba(" + r + ", " + g + ", " + b + ")";
};
var rgba = function rgba(r, g, b, a) {
    return "rgba(" + r + ", " + g + ", " + b + ", " + a + ")";
};

var hoverColor = rgba(0, 0, 0, 0.1);
var activeColor = rgba(0, 0, 0, 0.2);
var shadow = null;

exports["default"] = _Object$freeze({
    rgb: rgb, rgba: rgba,

    hoverColor: hoverColor,
    activeColor: activeColor,
    shadow: shadow
});
module.exports = exports["default"];

},{"babel-runtime/core-js/object/freeze":51}],38:[function(require,module,exports){
"use strict";

var _Promise = require("babel-runtime/core-js/promise")["default"];

var _Object$entries = require("babel-runtime/core-js/object/entries")["default"];

var _getIterator = require("babel-runtime/core-js/get-iterator")["default"];

var _Object$defineProperties = require("babel-runtime/core-js/object/define-properties")["default"];

exports.__esModule = true;
var ajax = function ajax(url) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
    return new _Promise(function (resolve, reject) {
        var _options$headers = options.headers;
        var headers = _options$headers === undefined ? {} : _options$headers;
        var _options$timeout = options.timeout;
        var timeout = _options$timeout === undefined ? 0 : _options$timeout;
        var _options$type = options.type;
        var type = _options$type === undefined ? null : _options$type;
        var _options$onProgress = options.onProgress;
        var onProgress = _options$onProgress === undefined ? function () {} : _options$onProgress;
        var _options$token = options.token;
        var token = _options$token === undefined ? null : _options$token;

        var request = new XMLHttpRequest();
        var _options$post = options.post;
        var post = _options$post === undefined ? null : _options$post;

        var contentType = null;
        var method = undefined;

        if (token !== null && token.used === false) {
            token.bindTo(request);
        }

        if (post === null) {
            method = 'GET';
        } else {
            method = "POST";
            if (FormData.prototype.isPrototypeOf(post) === false) {
                debugger;
                post = JSON.stringify(post);
                contentType = "application/json";
            }
        }

        if (type !== null) {
            request.responseType = type;
        }

        request.addEventListener('load', function () {
            if (request.status === 0 || request.status >= 200 && request.status < 300) {
                resolve({
                    status: request.status,
                    statusText: request.statusText,
                    response: request.response,
                    request: request
                });
            } else {
                reject(request);
            }
        });
        request.addEventListener("error", reject);
        request.addEventListener("timeout", reject);
        request.addEventListener("abort", function () {
            return resolve(null);
        });
        request.addEventListener("progress", onProgress);

        try {
            request.open(method, url, true);
            request.timeout = timeout;
            for (var _iterator = _Object$entries(headers), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {
                var _ref;

                if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref = _iterator[_i++];
                } else {
                    _i = _iterator.next();
                    if (_i.done) break;
                    _ref = _i.value;
                }

                var header = _ref[0];
                var value = _ref[1];

                request.setRequestHeader(header, value);
            }
            request.setRequestHeader("Accept", "");
            request.setRequestHeader("Accept", "*/*");
            if (contentType !== null) {
                request.setRequestHeader("Content-Type", contentType);
            }
            request.send(post);
        } catch (error) {
            reject(error);
        }
    });
};
ajax.cancelToken = function () {
    var request = null;

    return _Object$defineProperties({
        cancel: function cancel() {
            if (request !== null) {
                request.abort();
            }
        },

        bindTo: function bindTo(req) {
            if (request === null) {
                request = req;
            }
        }
    }, {
        used: {
            get: function get() {
                return request !== null;
            },
            configurable: true,
            enumerable: true
        }
    });
};

exports["default"] = ajax;
module.exports = exports["default"];

},{"babel-runtime/core-js/get-iterator":46,"babel-runtime/core-js/object/define-properties":49,"babel-runtime/core-js/object/entries":50,"babel-runtime/core-js/promise":54}],39:[function(require,module,exports){
'use strict';

var _Object$defineProperties = require('babel-runtime/core-js/object/define-properties')['default'];

var _Object$entries = require('babel-runtime/core-js/object/entries')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _Promise = require('babel-runtime/core-js/promise')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

exports.__esModule = true;

var _xregexp = require("xregexp");

var _xregexp2 = _interopRequireDefault(_xregexp);

var chronoSpecial = {
    'yesterday': function yesterday(date) {
        date.setDate(date.getDate() - 1);
        return date;
    },
    '1 week ago': function weekAgo(date) {
        date.setDate(date.getDate() - 7);
        return date;
    }
};
var chronoUnitRegex = _xregexp2['default']("(?<offset>(\\+|\\-)\\d+) (?<unit>\\w+)");
var unitFunction = {
    millisecond: function millisecond(date, milliseconds) {
        date.setMilliseconds(date.getMilliseconds() + milliseconds);
        return date;
    },
    second: function second(date, seconds) {
        date.setSeconds(date.getSeconds() + seconds);
        return date;
    },
    minute: function minute(date, minutes) {
        date.setMinutes(date.getMinutes() + minutes);
        return date;
    },
    hour: function hour(date, hours) {
        date.setHours(date.getHours() + hours);
        return date;
    },
    day: function day(date, days) {
        date.setDate(date.getDate() + days);
        return date;
    },
    week: function week(date, weeks) {
        date.setDate(date.getDate() + weeks * 7);
        return date;
    },
    month: function month(date, months) {
        var expected = date.getMonth() + months;
        date.setMonth(expected);
        if (date.getMonth() !== expected) {
            date.setDate(0);
        }
        return date;
    },
    year: function year(date, years) {
        date.setFullYear(date.getFullYear() + years);
        return date;
    },
    decade: function decade(date, decades) {
        date.setFullYear(date.getFullYear() + decades * 10);
        return date;
    }
};
var _startOf = {
    second: function second(date) {
        date.setMilliseconds(0);
    },
    minute: function minute(date) {
        _startOf.second(date);
        date.setSeconds(0);
    },
    hour: function hour(date) {
        _startOf.minute(date);
        date.setMinutes(0);
    },
    day: function day(date) {
        _startOf.hour(date);
        date.setHours(0);
    },
    week: function week(date) {
        _startOf.day(date);
        date.setDate(date.getDate() - date.getDay());
    },
    month: function month(date) {
        _startOf.day(date);
        date.setDate(1);
    },
    year: function year(date) {
        _startOf.month(date);
        date.setMonth(0);
    }
};
var _endOf = {
    second: function second(date) {
        date.setMilliseconds(999);
    },
    minute: function minute(date) {
        _endOf.second(date);
        date.setSeconds(59);
    },
    hour: function hour(date) {
        _endOf.minute(date);
        date.setMinutes(59);
    },
    day: function day(date) {
        _endOf.hour(date);
        date.setHours(23);
    },
    week: function week(date) {
        _endOf.day(date);
        date.setDate(date.getDate() + (6 - date.getDay()));
    },
    month: function month(date) {
        _endOf.day(date);
        date.setMonth(date.getMonth() + 1);
        date.setDate(0);
    },
    year: function year(date) {
        _endOf.month(date);
        date.setMonth(11);
    }
};
var unitConversion = {
    'millisecond': 'millisecond',
    'milliseconds': 'millisecond',
    'ms': 'millisecond',

    'second': 'second',
    'seconds': 'second',
    's': 'second',

    'minute': 'minute',
    'minutes': 'minute',
    'min': 'minute',

    'hour': 'hour',
    'hours': 'hour',
    'hr': 'hour',

    'day': 'day',
    'days': 'day',
    'ni': 'day',
    'hi': 'day',
    '日': 'day',

    'week': 'week',
    'weeks': 'week',
    'shuu': 'week',
    'しゅう': 'week',
    '週': 'week',

    'month': 'month',
    'months': 'month',

    'year': 'year',
    'years': 'year',

    'decade': 'decade',
    'decades': 'decade'
};
var chronoInfo = {
    days: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
    months: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']
};
var chronoFormat = {
    ms: {
        base: function base(date) {
            return date.getMilliseconds();
        },
        padded: function padded(date) {
            return ('00' + date.getMilliseconds()).slice(-3);
        }
    },
    second: {
        base: function base(date) {
            return date.getSeconds();
        },
        padded: function padded(date) {
            return ('0' + date.getSeconds()).slice(-2);
        }
    },
    minute: {
        base: function base(date) {
            return date.getMinutes();
        },
        padded: function padded(date) {
            return ('0' + date.getMinutes()).slice(-2);
        }
    },
    hour: {
        base: function base(date) {
            return date.getHours();
        },
        padded: function padded(date) {
            return ('0' + date.getHours()).slice(-2);
        },
        "12": function _(date) {
            var hour = date.getHours() % 12;
            if (hour === 0) {
                return 12;
            }
            return hour;
        },
        "12padded": function padded(date) {
            return ('0' + chronoFormat.hour['12'](date)).slice(-2);
        }
    },
    weekday: {
        base: function base(date) {
            return date.getDay();
        },
        short: function short(date) {
            return chronoInfo.days[date.getDay()].slice(0, 3);
        },
        full: function full(date) {
            return chronoInfo.days[date.getDay()];
        }
    },
    date: {
        base: function base(date) {
            return date.getDate();
        },
        padded: function padded(date) {
            return ('0' + date.getDate()).slice(-2);
        }
    },
    month: {
        base: function base(date) {
            return date.getMonth() + 1;
        },
        short: function short(date) {
            return chronoInfo.months[date.getDate()].slice(0, 3);
        },
        full: function full(date) {
            return chronoInfo.months[date.getDate()];
        }
    },
    year: {
        base: function base(date) {
            return date.getFullYear() % 100;
        },
        full: function full(date) {
            return date.getFullYear();
        }
    },
    tod: {
        base: function base(date) {
            return date.getHours() < 12 === true ? "AM" : "PM";
        }
    }
};
chronoFormat.day = chronoFormat.date;
var chronoCheckUnit = function chronoCheckUnit(unit) {
    if (unitConversion.hasOwnProperty(unit) === false) {
        throw new Error('Unrecognized unit: ' + unit);
    }
};

/* -AxelDoc-
module global {
    @function chrono {
        @desc Creates a new instance of {chrono}.
        @args {
            @arg dateTime [Date]
                This is some long description of the thing
                {year, month} destructuring?
                [title]year[title]
        }
        @return chrono

        @function diff {
            @desc A function that will calculate the amount of time to add to the first argument in order to get the second argument.
            @args {
                @arg startDate [chrono] The date to start from.
                @arg targetDate [chrono] The date to get to.
            }
            @return object
        }
        @function now {
            @desc Returns the current date as a chrono object.
            @args {}
            @return chrono
        }
        @function parse {
            @desc Parses a date string and returns the chrono object represented by it.
            @args {
                @arg dateString [string] The string to parse.
            }
            @return chrono
        }
        @function parseMS {
            @desc Parses a date string generated by C# code and returns the chrono object represented by it.
            @args {
                @arg dateString [string] The string to parse.
            }
            @return chrono
        }
        @function trigger {
            @desc Fires a function after a specified time.
            @args {
                @arg delay [number] The number of milliseconds to wait.
                @arg func [function] The function to call.
            }
            @return chronoTrigger
        }
    }

    object chrono {
        @prop dateObject {
            @desc Gets a copy of the internal Date object.
            @type Date
        }

        @prop unixTimestamp {
            @desc Gets the unix timestamp of the chrono object.
            @type number
        }

        @prop milliseconds {
            @desc Gets the milliseconds of the chrono object.
            @type number
        }
        @prop seconds {
            @desc Gets the seconds of the chrono object.
            @type number
        }
        @prop minutes {
            @desc Gets the minutes of the chrono object.
            @type number
        }
        @prop hours {
            @desc Gets the hours of the chrono object.
            @type number
        }
        @prop weekday {
            @desc Gets the weekday of the chrono object.
            @type number
        }
        @prop date {
            @desc Gets the date of the chrono object. This number is adjusted to the range (0-30) unlike the normal Date object.
            @type number
        }
        @prop months {
            @desc Gets the months of the chrono object.
            @type number
        }
        @prop year {
            @desc Gets the year of the chrono object.
            @type number
        }

        @function shift {
            @desc Shifts the date forward or backward in time.
            @args {
                @arg offset [Number] The amount of time to shift the date.
                @arg unit [String] The units to shift by. Valid values are: 'second', 'minute', 'hour', 'day', 'week', 'month', 'year', 'decade'.
            }
            @args {
                @arg duration [object] An object that will shift the date.
            }
            @return chrono
        }
        @function startOf {
            @desc Moves the date to the start of the specified unit.
            @args {
                @arg unit [string] The unit to move to the start of. Valid values are: 'second', 'minute', 'hour', 'day', 'week', 'month', 'year'.
            }
            @return chrono
        }
        @function format {
            @desc Formats the chrono object using the specified string.
            @args {
                @arg format [string] The string describing the format the date should be put into.
            }
            @return string
        }
    }

    object chronoTrigger {
        @prop status {
            @desc The status of the trigger.
            @type string
        }

        @function cancel {
            @desc Cancels the trigger if it hasn't fired yet.
        }
    }
}
*/
var chrono = function chrono() {
    var arg = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];

    var internalDate = (function () {
        if (arg === null) {
            return new Date();
        }

        if (Date.prototype.isPrototypeOf(arg) === true || typeof arg === 'number') {
            return new Date(arg);
        }

        if (arg.__chrono === true) {
            return arg.dateObject;
        }

        if (typeof arg === 'string') {
            arg = arg.toLowerCase();
            if (chronoSpecial.hasOwnProperty(arg) === true) {
                return chronoSpecial[arg](new Date());
            }

            var match = _xregexp2['default'].exec(arg, chronoUnitRegex);
            if (match !== null) {
                var offset = match.offset;
                var unit = match.unit;

                chronoCheckUnit(unit);

                return unitFunction[unitConversion[unit]](new Date(), parseInt(offset));
            }

            return new Date(arg);
        }

        var _arg = arg;
        var _arg$year = _arg.year;
        var year = _arg$year === undefined ? 1970 : _arg$year;
        var _arg$month = _arg.month;
        var month = _arg$month === undefined ? 0 : _arg$month;
        var _arg$date = _arg.date;
        var date = _arg$date === undefined ? 0 : _arg$date;
        var _arg$hours = _arg.hours;
        var hours = _arg$hours === undefined ? 0 : _arg$hours;
        var _arg$minutes = _arg.minutes;
        var minutes = _arg$minutes === undefined ? 0 : _arg$minutes;
        var _arg$seconds = _arg.seconds;
        var seconds = _arg$seconds === undefined ? 0 : _arg$seconds;
        var _arg$milliseconds = _arg.milliseconds;
        var milliseconds = _arg$milliseconds === undefined ? 0 : _arg$milliseconds;

        return new Date(year, month, date + 1, hours, minutes, seconds, milliseconds);
    })();

    return _Object$defineProperties({
        __chrono: true,

        set: function set(props) {
            var _props$year = props.year;
            var year = _props$year === undefined ? internalDate.getFullYear() : _props$year;
            var _props$month = props.month;
            var month = _props$month === undefined ? internalDate.getMonth() : _props$month;
            var _props$date = props.date;
            var date = _props$date === undefined ? internalDate.getDate() - 1 : _props$date;
            var _props$hours = props.hours;
            var hours = _props$hours === undefined ? internalDate.getHours() : _props$hours;
            var _props$minutes = props.minutes;
            var minutes = _props$minutes === undefined ? internalDate.getMinutes() : _props$minutes;
            var _props$seconds = props.seconds;
            var seconds = _props$seconds === undefined ? internalDate.getSeconds() : _props$seconds;
            var _props$milliseconds = props.milliseconds;
            var milliseconds = _props$milliseconds === undefined ? internalDate.getMilliseconds() : _props$milliseconds;

            return chrono(new Date(year, month, date + 1, hours, minutes, seconds, milliseconds));
        },
        shift: function shift(offset, unit) {
            var newDate = undefined;
            newDate = new Date(internalDate);

            if (typeof offset === 'object') {
                // if (offset.hasOwnProperty('__chrono_duration') && offset.__chrono_duration === true) {
                //     offset = offset.asObject();

                for (var _iterator = _Object$entries(offset), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {
                    var _ref;

                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        _i = _iterator.next();
                        if (_i.done) break;
                        _ref = _i.value;
                    }

                    var _unit = _ref[0];
                    var value = _ref[1];

                    chronoCheckUnit(_unit);
                    newDate = unitFunction[unitConversion[_unit]](newDate, value);
                }

                return chrono(newDate);
            } else {
                if (typeof offset === 'string') {
                    var match = _xregexp2['default'].exec(offset, chronoUnitRegex);

                    offset = match.offset;
                    unit = match.unit;

                    chronoCheckUnit(unit);
                    offset = parseInt(offset);
                }

                return chrono(unitFunction[unitConversion[unit]](newDate, offset));
            }
        },
        startOf: function startOf(unit) {
            var adjustedDate = new Date(internalDate);

            _startOf[unit](adjustedDate);

            return chrono(adjustedDate);
        },
        endOf: function endOf(unit) {
            var adjustedDate = new Date(internalDate);

            _endOf[unit](adjustedDate);

            return chrono(adjustedDate);
        },
        format: function format() {
            var formatString = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];

            if (formatString === null) {
                return internalDate.toString();
            }

            if (formatString === 'utc') {
                return internalDate.toUTCString();
            }
            if (formatString === 'locale') {
                return internalDate.toLocaleString();
            }

            return formatString.replace(/\{(\w+)(\/(\w+))?\}/g, function (full, prop, skip) {
                var type = arguments.length <= 3 || arguments[3] === undefined ? 'base' : arguments[3];
                return chronoFormat[prop][type](internalDate);
            });
        },
        toString: function toString() {
            return internalDate.toString();
        },
        toJSON: function toJSON() {
            return internalDate.toJSON();
        }
    }, {
        dateObject: {
            get: function get() {
                return new Date(internalDate);
            },
            configurable: true,
            enumerable: true
        },
        unixTimestamp: {
            get: function get() {
                return internalDate.getTime();
            },
            configurable: true,
            enumerable: true
        },
        milliseconds: {
            get: function get() {
                return internalDate.getMilliseconds();
            },
            configurable: true,
            enumerable: true
        },
        seconds: {
            get: function get() {
                return internalDate.getSeconds();
            },
            configurable: true,
            enumerable: true
        },
        minutes: {
            get: function get() {
                return internalDate.getMinutes();
            },
            configurable: true,
            enumerable: true
        },
        hours: {
            get: function get() {
                return internalDate.getHours();
            },
            configurable: true,
            enumerable: true
        },
        weekday: {
            get: function get() {
                return internalDate.getDay();
            },
            configurable: true,
            enumerable: true
        },
        date: {
            get: function get() {
                return internalDate.getDate() - 1;
            },
            configurable: true,
            enumerable: true
        },
        month: {
            get: function get() {
                return internalDate.getMonth();
            },
            configurable: true,
            enumerable: true
        },
        year: {
            get: function get() {
                return internalDate.getFullYear();
            },
            configurable: true,
            enumerable: true
        }
    });
};
chrono.diff = function (first, second) {
    var internalDate = new Date(second.unixTimestamp - first.unixTimestamp);
    console.log(second.unixTimestamp - first.unixTimestamp);
    console.log(internalDate);

    return {
        milliseconds: internalDate.getMilliseconds(),
        seconds: internalDate.getSeconds(),
        minutes: internalDate.getMinutes(),
        hours: internalDate.getHours(),
        days: internalDate.getDate() - 1,
        months: internalDate.getMonth(),
        years: internalDate.getFullYear() - 1970
    };
};
chrono.now = function () {
    return chrono(Date.now());
};
chrono.parse = function (string) {
    return chrono(Date.parse(string));
};
chrono.parseMS = function (string) {
    return chrono(Date.parse(string.replace("T", " ")));
};
chrono.trigger = function (delay, func) {
    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        args[_key - 2] = arguments[_key];
    }

    var id = setTimeout(function () {
        status = 'fired';
        func.apply(undefined, args);
    }, delay);
    var status = undefined;

    status = 'waiting';

    return _Object$defineProperties({
        cancel: function cancel() {
            status = 'cancelled';
            clearTimeout(id);
        }
    }, {
        status: {
            get: function get() {
                return status;
            },
            configurable: true,
            enumerable: true
        }
    });
};
chrono.wait = function (wait) {
    return new _Promise(function (resolve) {
        return setTimeout(function () {
            return resolve(null);
        }, wait);
    });
};

exports['default'] = chrono;
module.exports = exports['default'];
// }

},{"babel-runtime/core-js/get-iterator":46,"babel-runtime/core-js/object/define-properties":49,"babel-runtime/core-js/object/entries":50,"babel-runtime/core-js/promise":54,"babel-runtime/helpers/interop-require-default":60,"xregexp":369}],40:[function(require,module,exports){
(function (Buffer){
'use strict';

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

exports.__esModule = true;

var _crypto = require("crypto");

var _crypto2 = _interopRequireDefault(_crypto);

var encrypt = undefined;
var decrypt = undefined;
var hash = undefined;

encrypt = function (str, key) {
    var _ref = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

    var _ref$iv = _ref.iv;
    var iv = _ref$iv === undefined ? null : _ref$iv;
    var _ref$algorithm = _ref.algorithm;
    var algorithm = _ref$algorithm === undefined ? 'aes256' : _ref$algorithm;
    var _ref$output = _ref.output;
    var output = _ref$output === undefined ? 'hex' : _ref$output;
    var _ref$input = _ref.input;
    var input = _ref$input === undefined ? 'utf8' : _ref$input;

    var encryptor = undefined;
    var result = undefined;

    key = new Buffer(key);

    if (iv === null) {
        encryptor = _crypto2['default'].createCipher(algorithm, key);
    } else {
        iv = new Buffer(iv);
        encryptor = _crypto2['default'].createCipher(algorithm, key, iv);
    }

    result = encryptor.update(str, input, output);
    result += encryptor.final(output);
    encryptor = null;
    str = null;
    key.fill(0);

    return result;
};

decrypt = function (str, key) {
    var _ref2 = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

    var _ref2$iv = _ref2.iv;
    var iv = _ref2$iv === undefined ? null : _ref2$iv;
    var _ref2$algorithm = _ref2.algorithm;
    var algorithm = _ref2$algorithm === undefined ? 'aes256' : _ref2$algorithm;
    var _ref2$input = _ref2.input;
    var input = _ref2$input === undefined ? 'hex' : _ref2$input;
    var _ref2$output = _ref2.output;
    var output = _ref2$output === undefined ? 'utf8' : _ref2$output;

    var decryptor = undefined;
    var result = undefined;

    key = new Buffer(key);

    if (iv === null) {
        decryptor = _crypto2['default'].createDecipher(algorithm, key);
    } else {
        iv = new Buffer(iv);
        decryptor = _crypto2['default'].createDecipher(algorithm, key, iv);
    }

    result = decryptor.update(str, input, output);
    result += decryptor.final(output);
    decryptor = null;
    str = null;
    key.fill(0);

    return result;
};

hash = function (str) {
    var algorithm = arguments.length <= 1 || arguments[1] === undefined ? 'sha512' : arguments[1];

    var hasher = undefined;

    hasher = _crypto2['default'].createHash(algorithm);
    hasher.update(str, 'utf8');
    str = null;

    return hasher.digest('hex');
};

exports['default'] = {
    encrypt: encrypt,
    decrypt: decrypt,
    hash: hash
};
module.exports = exports['default'];

}).call(this,require("buffer").Buffer)

},{"babel-runtime/helpers/interop-require-default":60,"buffer":151,"crypto":155}],41:[function(require,module,exports){
"use strict";

var _inherits = require("babel-runtime/helpers/inherits")["default"];

var _classCallCheck = require("babel-runtime/helpers/class-call-check")["default"];

var _objectWithoutProperties = require("babel-runtime/helpers/object-without-properties")["default"];

var _extends = require("babel-runtime/helpers/extends")["default"];

var _Object$defineProperties = require("babel-runtime/core-js/object/define-properties")["default"];

exports.__esModule = true;
var sharedReference = function sharedReference(value) {
    return _Object$defineProperties({
        set: function set(newValue) {
            value = newValue;
        }
    }, {
        value: {
            get: function get() {
                return value;
            },
            configurable: true,
            enumerable: true
        }
    });
};

var SharedObjectDisplay = (function (_React$Component) {
    _inherits(SharedObjectDisplay, _React$Component);

    function SharedObjectDisplay(props) {
        var _this = this;

        _classCallCheck(this, SharedObjectDisplay);

        _React$Component.call(this, props);

        this.update = function (value) {
            _this.props.reference.set(value);
            _this.setState({ value: value });
        };

        this.render = function () {
            var _ref;

            var _props = _this.props;
            var Component = _props.component;
            var reference = _props.reference;
            var valueProp = _props.valueProp;
            var containerStyle = _props.containerStyle;

            var props = _objectWithoutProperties(_props, ["component", "reference", "valueProp", "containerStyle"]);

            var value = _this.state.value;

            return React.createElement(
                "div",
                { style: containerStyle },
                React.createElement(Component, _extends({}, props, (_ref = {}, _ref[valueProp] = value, _ref), { onChange: _this.update }))
            );
        };

        this.state = { value: this.props.reference.value };
    }

    return SharedObjectDisplay;
})(React.Component);

exports.sharedReference = sharedReference;
exports.SharedObjectDisplay = SharedObjectDisplay;

},{"babel-runtime/core-js/object/define-properties":49,"babel-runtime/helpers/class-call-check":57,"babel-runtime/helpers/extends":58,"babel-runtime/helpers/inherits":59,"babel-runtime/helpers/object-without-properties":61}],42:[function(require,module,exports){
"use strict";

var _extends = require("babel-runtime/helpers/extends")["default"];

var _Set = require("babel-runtime/core-js/set")["default"];

var _Object$entries = require("babel-runtime/core-js/object/entries")["default"];

var _getIterator = require("babel-runtime/core-js/get-iterator")["default"];

var _Object$defineProperties = require("babel-runtime/core-js/object/define-properties")["default"];

exports.__esModule = true;
var cssNoMeasurement = new _Set(["animationIterationCount", "boxFlex", "boxFlexGroup", "boxOrdinalGroup", "columnCount", "fillOpacity", "flex", "flexGrow", "flexPositive", "flexShrink", "flexNegative", "flexOrder", "fontWeight", "lineClamp", "lineHeight", "opacity", "order", "orphans", "stopOpacity", "strokeDashoffset", "strokeOpacity", "strokeWidth", "tabSize", "widows", "zIndex", "zoom"]);
var cssPrefixNames = new _Set(['transform', 'box-shadow', 'transition', 'animation', 'animationDelay', 'animationDirection', 'animationDuration', 'animationFillMode', 'animationIterationCount', 'animationName', 'animationPlayState', 'animationTimingFunction']);
var cssPrefixes = ['-webkit-', '-moz-', '-ms-', '-o-', ''];

var getCSSValue = function getCSSValue(prop, value) {
    if (value === null) {
        return null;
    }
    if (typeof value === 'function') {
        value = value();
    }
    if (Array.isArray(value) === true) {
        return value.map(function (value) {
            return getCSSValue(prop, value)[0];
        });
    }
    if (typeof value === 'number' && cssNoMeasurement.has(prop) === false) {
        value += "px";
    }
    return [value];
};
var processSelector = function processSelector(componentName, styleName, selector) {
    var parts = selector.split(/\s+/);
    var realParts = parts.map(function (part) {
        part = part.replace(":active", ".cor-touch-active");
        return part.split('/').map(function (part) {
            switch (true) {
                case part.charAt(0) === "$":
                    return part.slice(1);
                case /^[a-z]/i.test(part) === true:
                    return "." + componentName + "-" + styleName + "-" + part;
                default:
                    return part;
            }
        }).join('');
    });
    return realParts.join(' ');
};
var processDef = function processDef(cssLines, selector, defs) {
    cssLines = [].concat(cssLines, [selector + " {"]);

    var _loop = function () {
        if (_isArray) {
            if (_i >= _iterator.length) return "break";
            _ref = _iterator[_i++];
        } else {
            _i = _iterator.next();
            if (_i.done) return "break";
            _ref = _i.value;
        }

        var cssProp = _ref[0];
        var cssValue = _ref[1];

        var value = getCSSValue(cssProp, cssValue);
        var prop = cssProp.replace(/[A-Z]/g, function (letter) {
            return '-' + letter.toLowerCase();
        });
        if (value !== null) {
            if (cssPrefixNames.has(cssProp) === true) {
                cssLines = [].concat(cssLines, cssPrefixes.map(function (prefix) {
                    return "\t" + prefix + prop + ": " + value[0] + ";";
                }));
            } else {
                cssLines = [].concat(cssLines, value.map(function (value) {
                    return "\t" + prop + ": " + value + ";";
                }));
            }
        }
    };

    for (var _iterator = _Object$entries(defs), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {
        var _ref;

        var _ret = _loop();

        if (_ret === "break") break;
    }
    cssLines = [].concat(cssLines, ["}"]);
    return cssLines;
    // cssLines.push("}");
};

var componentStyles = {};
var createProp = function createProp(object, propName, defaultValue) {
    if (object.hasOwnProperty(propName) === false) {
        object[propName] = defaultValue;
    }
    return object[propName];
};
var defineComponentStyle = function defineComponentStyle(component, styleName, styles) {
    return createProp(createProp(componentStyles, component, {}), styleName, styles);
};
var baseStyles = {};
var defineCustomBase = function defineCustomBase(component, baseFunc) {
    if (typeof component !== 'string') {
        component = component.componentName;
    }
    baseStyles[component] = baseFunc;
};
var propStyleName = function propStyleName(name) {
    return name.replace(/(^\w)|\-\w/g, function (s) {
        return s.slice(-1).toUpperCase();
    });
};
var defineStyleForComponent = function defineStyleForComponent(component, styleName, options) {
    var Component = component;
    var styleDef = baseStyles[component.componentName](options);
    var styledComponent = null;

    if (styleDef === null || styleDef === undefined || typeof styleDef !== 'object') {
        console.warn("Improper type returned from style function for " + component.componentName + ":" + styleName + ". Did you forget to return the constructed style?");
    } else {
        defineComponentStyle(component.componentName, styleName, styleDef);
    }

    styledComponent = function (props) {
        return React.createElement(Component, _extends({}, props, { styleName: styleName }));
    };
    styledComponent.parentInfo = component;
    component[propStyleName(styleName)] = styledComponent;
};

var createStyles = function createStyles() {
    var head = document.querySelector("head");

    //  Iterate over the components that have styles defined
    for (var _iterator2 = _Object$entries(componentStyles), _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _getIterator(_iterator2);;) {
        var _ref2;

        if (_isArray2) {
            if (_i2 >= _iterator2.length) break;
            _ref2 = _iterator2[_i2++];
        } else {
            _i2 = _iterator2.next();
            if (_i2.done) break;
            _ref2 = _i2.value;
        }

        var componentName = _ref2[0];
        var styles = _ref2[1];

        //  Iterate over the various named styles for the given component
        for (var _iterator3 = _Object$entries(styles), _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _getIterator(_iterator3);;) {
            var _ref3;

            if (_isArray3) {
                if (_i3 >= _iterator3.length) break;
                _ref3 = _iterator3[_i3++];
            } else {
                _i3 = _iterator3.next();
                if (_i3.done) break;
                _ref3 = _i3.value;
            }

            var styleName = _ref3[0];
            var styleDefs = _ref3[1];

            var cssLines = [];
            //  Grab all the individual groups of styles defined in the named style
            for (var _iterator4 = _Object$entries(styleDefs), _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _getIterator(_iterator4);;) {
                var _ref4;

                if (_isArray4) {
                    if (_i4 >= _iterator4.length) break;
                    _ref4 = _iterator4[_i4++];
                } else {
                    _i4 = _iterator4.next();
                    if (_i4.done) break;
                    _ref4 = _i4.value;
                }

                var descriptor = _ref4[0];
                var defs = _ref4[1];

                if (descriptor.startsWith("!") === true) {
                    //  Repeat an extra time with prefixed keyframes because ios < 9 is pretty awful
                    cssLines.push("@-webkit-keyframes " + componentName + "-" + styleName + "-animation-" + descriptor.slice(1) + " {");
                    for (var _iterator5 = _Object$entries(defs), _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _getIterator(_iterator5);;) {
                        var _ref5;

                        if (_isArray5) {
                            if (_i5 >= _iterator5.length) break;
                            _ref5 = _iterator5[_i5++];
                        } else {
                            _i5 = _iterator5.next();
                            if (_i5.done) break;
                            _ref5 = _i5.value;
                        }

                        var selector = _ref5[0];
                        var def = _ref5[1];

                        cssLines = processDef(cssLines, selector, def);
                    }
                    cssLines.push("}");

                    //  normal @keyframes css
                    cssLines.push("@keyframes " + componentName + "-" + styleName + "-animation-" + descriptor.slice(1) + " {");
                    for (var _iterator6 = _Object$entries(defs), _isArray6 = Array.isArray(_iterator6), _i6 = 0, _iterator6 = _isArray6 ? _iterator6 : _getIterator(_iterator6);;) {
                        var _ref6;

                        if (_isArray6) {
                            if (_i6 >= _iterator6.length) break;
                            _ref6 = _iterator6[_i6++];
                        } else {
                            _i6 = _iterator6.next();
                            if (_i6.done) break;
                            _ref6 = _i6.value;
                        }

                        var selector = _ref6[0];
                        var def = _ref6[1];

                        cssLines = processDef(cssLines, selector, def);
                    }
                    cssLines.push("}");
                } else {
                    var selector = processSelector(componentName, styleName, descriptor);
                    cssLines = processDef(cssLines, selector, defs);
                }
            }
            var styleTag = document.createElement("style");
            styleTag.setAttribute("type", "text/css");
            styleTag.setAttribute("data-name", componentName + "/" + styleName);
            styleTag.innerHTML = cssLines.join('\n');
            head.appendChild(styleTag);
        }
    }
};

var themeValues = undefined;
var Theme = _Object$defineProperties({
    define: function define(theme) {
        themeValues = theme;
    }
}, {
    variable: {
        get: function get() {
            return themeValues;
        },
        configurable: true,
        enumerable: true
    }
});

exports["default"] = {
    defineComponentStyle: defineComponentStyle,
    defineCustomBase: defineCustomBase,
    defineStyleForComponent: defineStyleForComponent,
    genFontCSS: function genFontCSS(name, dataURI) {
        return {
            fontFamily: "\"" + name + "\"",
            src: "url(\"" + dataURI + "\")",
            fontWeight: "normal",
            fontStyle: "normal"
        };
    },
    Theme: Theme,
    __setup: createStyles
};
module.exports = exports["default"];

},{"babel-runtime/core-js/get-iterator":46,"babel-runtime/core-js/object/define-properties":49,"babel-runtime/core-js/object/entries":50,"babel-runtime/core-js/set":55,"babel-runtime/helpers/extends":58}],43:[function(require,module,exports){
"use strict";

var _Object$entries = require("babel-runtime/core-js/object/entries")["default"];

var _getIterator = require("babel-runtime/core-js/get-iterator")["default"];

var _Object$keys = require("babel-runtime/core-js/object/keys")["default"];

exports.__esModule = true;
var warningFunc = function warningFunc(errorMessage) {
    return function () {
        return console.warn(errorMessage);
    };
};

exports["default"] = {
    warningFunc: warningFunc,
    transferProps: function transferProps(sources) {
        var dest = {};

        for (var _iterator = _Object$entries(sources), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {
            var _ref;

            if (_isArray) {
                if (_i >= _iterator.length) break;
                _ref = _iterator[_i++];
            } else {
                _i = _iterator.next();
                if (_i.done) break;
                _ref = _i.value;
            }

            var destName = _ref[0];
            var source = _ref[1];

            // debugger;
            var sourceObj = source[0];
            var props = source[1];

            var copy = {};

            if (sourceObj !== null) {
                for (var _iterator2 = _Object$entries(props), _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _getIterator(_iterator2);;) {
                    var _ref2;

                    if (_isArray2) {
                        if (_i2 >= _iterator2.length) break;
                        _ref2 = _iterator2[_i2++];
                    } else {
                        _i2 = _iterator2.next();
                        if (_i2.done) break;
                        _ref2 = _i2.value;
                    }

                    var sourceProp = _ref2[0];
                    var destProp = _ref2[1];

                    if (sourceObj[sourceProp] !== undefined) {
                        copy[destProp] = sourceObj[sourceProp];
                    }
                }

                if (_Object$keys(copy).length > 0) {
                    dest[destName] = copy;
                }
            }
        }

        return dest;
    }
};
module.exports = exports["default"];

},{"babel-runtime/core-js/get-iterator":46,"babel-runtime/core-js/object/entries":50,"babel-runtime/core-js/object/keys":52}],44:[function(require,module,exports){
"use strict";

var _Promise = require("babel-runtime/core-js/promise")["default"];

var _Object$defineProperties = require("babel-runtime/core-js/object/define-properties")["default"];

var _regeneratorRuntime = require("babel-runtime/regenerator")["default"];

var _getIterator = require("babel-runtime/core-js/get-iterator")["default"];

var _interopRequireDefault = require("babel-runtime/helpers/interop-require-default")["default"];

exports.__esModule = true;

var _this = this;

require("external/zip.js");

require("external/zip-ext.js");

var _externalDeflateJsSource = require("external/deflate.js.source");

var _externalDeflateJsSource2 = _interopRequireDefault(_externalDeflateJsSource);

var _externalInflateJsSource = require("external/inflate.js.source");

var _externalInflateJsSource2 = _interopRequireDefault(_externalInflateJsSource);

var _externalZWorkerJsSource = require("external/z-worker.js.source");

var _externalZWorkerJsSource2 = _interopRequireDefault(_externalZWorkerJsSource);

var createURL = function createURL(source) {
    var blob = new Blob([source], { type: "application/javascript" });
    return URL.createObjectURL(blob);
};

var workerURL = createURL(_externalZWorkerJsSource2["default"]);
var inflateURL = createURL(_externalInflateJsSource2["default"]);
var deflateURL = createURL(_externalDeflateJsSource2["default"]);

zip.workerScripts = {
    inflater: [workerURL, inflateURL],
    deflater: [workerURL, deflateURL]
};

var zipLib = zip;

window.zip = null;

var readEntry = function readEntry(entry, writer) {
    return new _Promise(function (resolve) {
        return entry.getData(writer, resolve);
    });
};
var zipEntry = function zipEntry(entry) {
    return _Object$defineProperties({
        readText: function readText() {
            return readEntry(entry, new zipLib.TextWriter());
        },
        readBlob: function readBlob() {
            return readEntry(entry, new zipLib.BlobWriter());
        }
    }, {
        entry: {
            get: function get() {
                return entry;
            },
            configurable: true,
            enumerable: true
        }
    });
};

var readArrayBuffer = function readArrayBuffer(buffer) {
    return new _Promise(function (resolve, reject) {
        zipLib.createReader(new zipLib.ArrayBufferReader(buffer), function (reader) {
            reader.getEntries(function (entries) {
                return resolve([entries, reader]);
            });
        });
    });
};
var _download = function _download(url, onProgress) {
    var buffer;
    return _regeneratorRuntime.async(function _download$(context$1$0) {
        while (1) switch (context$1$0.prev = context$1$0.next) {
            case 0:
                context$1$0.next = 2;
                return _regeneratorRuntime.awrap(factotum.ajax(url, { type: 'arraybuffer', onProgress: onProgress }));

            case 2:
                buffer = context$1$0.sent;
                context$1$0.next = 5;
                return _regeneratorRuntime.awrap(readArrayBuffer(buffer.response));

            case 5:
                return context$1$0.abrupt("return", context$1$0.sent);

            case 6:
            case "end":
                return context$1$0.stop();
        }
    }, null, _this);
};

var zipFile = function zipFile(_ref2) {
    var entries = _ref2[0];
    var reader = _ref2[1];

    var entrySort = function entrySort(first, second) {
        if (first.filename < second.filename) {
            return -1;
        }
        if (first.filename > second.filename) {
            return 1;
        }
        return 0;
    };
    var files = entries.sort(entrySort).reduce(function (collection, entry) {
        collection[entry.filename] = entry;
        return collection;
    }, {});
    entries = entries.sort(entrySort);

    return {
        getFile: function getFile(name) {
            if (files.hasOwnProperty(name) === true) {
                return zipEntry(files[name]);
            }
            return null;
        },
        getEntries: function getEntries() {
            return entries.map(zipEntry);
        },
        extractTo: function extractTo(dest) {
            var onProgress = arguments.length <= 1 || arguments[1] === undefined ? function () {} : arguments[1];

            var index, _iterator, _isArray, _i, _ref, entry, filename;

            return _regeneratorRuntime.async(function extractTo$(context$2$0) {
                while (1) switch (context$2$0.prev = context$2$0.next) {
                    case 0:
                        index = undefined;

                        index = 0;
                        _iterator = entries, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);

                    case 3:
                        if (!_isArray) {
                            context$2$0.next = 9;
                            break;
                        }

                        if (!(_i >= _iterator.length)) {
                            context$2$0.next = 6;
                            break;
                        }

                        return context$2$0.abrupt("break", 33);

                    case 6:
                        _ref = _iterator[_i++];
                        context$2$0.next = 13;
                        break;

                    case 9:
                        _i = _iterator.next();

                        if (!_i.done) {
                            context$2$0.next = 12;
                            break;
                        }

                        return context$2$0.abrupt("break", 33);

                    case 12:
                        _ref = _i.value;

                    case 13:
                        entry = _ref;
                        filename = entry.filename;

                        if (!(entry.directory === true)) {
                            context$2$0.next = 20;
                            break;
                        }

                        context$2$0.next = 18;
                        return _regeneratorRuntime.awrap(fs.dirCreate("" + dest + filename));

                    case 18:
                        context$2$0.next = 29;
                        break;

                    case 20:
                        context$2$0.t0 = _regeneratorRuntime;
                        context$2$0.t1 = fs;
                        context$2$0.t2 = "" + dest + filename;
                        context$2$0.next = 25;
                        return _regeneratorRuntime.awrap(zipEntry(entry).readBlob());

                    case 25:
                        context$2$0.t3 = context$2$0.sent;
                        context$2$0.t4 = context$2$0.t1.fileWrite.call(context$2$0.t1, context$2$0.t2, context$2$0.t3);
                        context$2$0.next = 29;
                        return context$2$0.t0.awrap.call(context$2$0.t0, context$2$0.t4);

                    case 29:
                        index += 1;
                        onProgress({
                            extracted: index,
                            total: entries.length,
                            currentFile: zipEntry(entry),
                            nextFile: index < entries.length ? zipEntry(entries[index]) : null
                        });

                    case 31:
                        context$2$0.next = 3;
                        break;

                    case 33:
                        return context$2$0.abrupt("return", true);

                    case 34:
                    case "end":
                        return context$2$0.stop();
                }
            }, null, this);
        },
        close: function close() {
            reader.close();
        }
    };
};

exports["default"] = {
    download: function download(url, onProgress) {
        var zipInfo;
        return _regeneratorRuntime.async(function download$(context$1$0) {
            while (1) switch (context$1$0.prev = context$1$0.next) {
                case 0:
                    context$1$0.next = 2;
                    return _regeneratorRuntime.awrap(_download(url, onProgress));

                case 2:
                    zipInfo = context$1$0.sent;
                    return context$1$0.abrupt("return", zipFile(zipInfo));

                case 4:
                case "end":
                    return context$1$0.stop();
            }
        }, null, this);
    }
};
module.exports = exports["default"];

},{"babel-runtime/core-js/get-iterator":46,"babel-runtime/core-js/object/define-properties":49,"babel-runtime/core-js/promise":54,"babel-runtime/helpers/interop-require-default":60,"babel-runtime/regenerator":148,"external/deflate.js.source":1,"external/inflate.js.source":2,"external/z-worker.js.source":3,"external/zip-ext.js":4,"external/zip.js":5}],45:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/array/from"), __esModule: true };
},{"core-js/library/fn/array/from":62}],46:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/get-iterator"), __esModule: true };
},{"core-js/library/fn/get-iterator":63}],47:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/assign"), __esModule: true };
},{"core-js/library/fn/object/assign":64}],48:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/create"), __esModule: true };
},{"core-js/library/fn/object/create":65}],49:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/define-properties"), __esModule: true };
},{"core-js/library/fn/object/define-properties":66}],50:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/entries"), __esModule: true };
},{"core-js/library/fn/object/entries":67}],51:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/freeze"), __esModule: true };
},{"core-js/library/fn/object/freeze":68}],52:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/keys"), __esModule: true };
},{"core-js/library/fn/object/keys":69}],53:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/set-prototype-of"), __esModule: true };
},{"core-js/library/fn/object/set-prototype-of":70}],54:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/promise"), __esModule: true };
},{"core-js/library/fn/promise":71}],55:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/set"), __esModule: true };
},{"core-js/library/fn/set":72}],56:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/symbol"), __esModule: true };
},{"core-js/library/fn/symbol":73}],57:[function(require,module,exports){
"use strict";

exports["default"] = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

exports.__esModule = true;
},{}],58:[function(require,module,exports){
"use strict";

var _Object$assign = require("babel-runtime/core-js/object/assign")["default"];

exports["default"] = _Object$assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

exports.__esModule = true;
},{"babel-runtime/core-js/object/assign":47}],59:[function(require,module,exports){
"use strict";

var _Object$create = require("babel-runtime/core-js/object/create")["default"];

var _Object$setPrototypeOf = require("babel-runtime/core-js/object/set-prototype-of")["default"];

exports["default"] = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = _Object$create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _Object$setPrototypeOf ? _Object$setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};

exports.__esModule = true;
},{"babel-runtime/core-js/object/create":48,"babel-runtime/core-js/object/set-prototype-of":53}],60:[function(require,module,exports){
"use strict";

exports["default"] = function (obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
};

exports.__esModule = true;
},{}],61:[function(require,module,exports){
"use strict";

exports["default"] = function (obj, keys) {
  var target = {};

  for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue;
    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
    target[i] = obj[i];
  }

  return target;
};

exports.__esModule = true;
},{}],62:[function(require,module,exports){
require('../../modules/es6.string.iterator');
require('../../modules/es6.array.from');
module.exports = require('../../modules/$.core').Array.from;
},{"../../modules/$.core":82,"../../modules/es6.array.from":134,"../../modules/es6.string.iterator":143}],63:[function(require,module,exports){
require('../modules/web.dom.iterable');
require('../modules/es6.string.iterator');
module.exports = require('../modules/core.get-iterator');
},{"../modules/core.get-iterator":133,"../modules/es6.string.iterator":143,"../modules/web.dom.iterable":147}],64:[function(require,module,exports){
require('../../modules/es6.object.assign');
module.exports = require('../../modules/$.core').Object.assign;
},{"../../modules/$.core":82,"../../modules/es6.object.assign":136}],65:[function(require,module,exports){
var $ = require('../../modules/$');
module.exports = function create(P, D){
  return $.create(P, D);
};
},{"../../modules/$":107}],66:[function(require,module,exports){
var $ = require('../../modules/$');
module.exports = function defineProperties(T, D){
  return $.setDescs(T, D);
};
},{"../../modules/$":107}],67:[function(require,module,exports){
require('../../modules/es7.object.entries');
module.exports = require('../../modules/$.core').Object.entries;
},{"../../modules/$.core":82,"../../modules/es7.object.entries":145}],68:[function(require,module,exports){
require('../../modules/es6.object.freeze');
module.exports = require('../../modules/$.core').Object.freeze;
},{"../../modules/$.core":82,"../../modules/es6.object.freeze":137}],69:[function(require,module,exports){
require('../../modules/es6.object.keys');
module.exports = require('../../modules/$.core').Object.keys;
},{"../../modules/$.core":82,"../../modules/es6.object.keys":138}],70:[function(require,module,exports){
require('../../modules/es6.object.set-prototype-of');
module.exports = require('../../modules/$.core').Object.setPrototypeOf;
},{"../../modules/$.core":82,"../../modules/es6.object.set-prototype-of":139}],71:[function(require,module,exports){
require('../modules/es6.object.to-string');
require('../modules/es6.string.iterator');
require('../modules/web.dom.iterable');
require('../modules/es6.promise');
module.exports = require('../modules/$.core').Promise;
},{"../modules/$.core":82,"../modules/es6.object.to-string":140,"../modules/es6.promise":141,"../modules/es6.string.iterator":143,"../modules/web.dom.iterable":147}],72:[function(require,module,exports){
require('../modules/es6.object.to-string');
require('../modules/es6.string.iterator');
require('../modules/web.dom.iterable');
require('../modules/es6.set');
require('../modules/es7.set.to-json');
module.exports = require('../modules/$.core').Set;
},{"../modules/$.core":82,"../modules/es6.object.to-string":140,"../modules/es6.set":142,"../modules/es6.string.iterator":143,"../modules/es7.set.to-json":146,"../modules/web.dom.iterable":147}],73:[function(require,module,exports){
require('../../modules/es6.symbol');
require('../../modules/es6.object.to-string');
module.exports = require('../../modules/$.core').Symbol;
},{"../../modules/$.core":82,"../../modules/es6.object.to-string":140,"../../modules/es6.symbol":144}],74:[function(require,module,exports){
module.exports = function(it){
  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
  return it;
};
},{}],75:[function(require,module,exports){
module.exports = function(){ /* empty */ };
},{}],76:[function(require,module,exports){
var isObject = require('./$.is-object');
module.exports = function(it){
  if(!isObject(it))throw TypeError(it + ' is not an object!');
  return it;
};
},{"./$.is-object":100}],77:[function(require,module,exports){
// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = require('./$.cof')
  , TAG = require('./$.wks')('toStringTag')
  // ES3 wrong here
  , ARG = cof(function(){ return arguments; }()) == 'Arguments';

module.exports = function(it){
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = (O = Object(it))[TAG]) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};
},{"./$.cof":78,"./$.wks":131}],78:[function(require,module,exports){
var toString = {}.toString;

module.exports = function(it){
  return toString.call(it).slice(8, -1);
};
},{}],79:[function(require,module,exports){
'use strict';
var $            = require('./$')
  , hide         = require('./$.hide')
  , redefineAll  = require('./$.redefine-all')
  , ctx          = require('./$.ctx')
  , strictNew    = require('./$.strict-new')
  , defined      = require('./$.defined')
  , forOf        = require('./$.for-of')
  , $iterDefine  = require('./$.iter-define')
  , step         = require('./$.iter-step')
  , ID           = require('./$.uid')('id')
  , $has         = require('./$.has')
  , isObject     = require('./$.is-object')
  , setSpecies   = require('./$.set-species')
  , DESCRIPTORS  = require('./$.descriptors')
  , isExtensible = Object.isExtensible || isObject
  , SIZE         = DESCRIPTORS ? '_s' : 'size'
  , id           = 0;

var fastKey = function(it, create){
  // return primitive with prefix
  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if(!$has(it, ID)){
    // can't set id to frozen object
    if(!isExtensible(it))return 'F';
    // not necessary to add id
    if(!create)return 'E';
    // add missing object id
    hide(it, ID, ++id);
  // return object id with prefix
  } return 'O' + it[ID];
};

var getEntry = function(that, key){
  // fast case
  var index = fastKey(key), entry;
  if(index !== 'F')return that._i[index];
  // frozen object case
  for(entry = that._f; entry; entry = entry.n){
    if(entry.k == key)return entry;
  }
};

module.exports = {
  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
    var C = wrapper(function(that, iterable){
      strictNew(that, C, NAME);
      that._i = $.create(null); // index
      that._f = undefined;      // first entry
      that._l = undefined;      // last entry
      that[SIZE] = 0;           // size
      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear(){
        for(var that = this, data = that._i, entry = that._f; entry; entry = entry.n){
          entry.r = true;
          if(entry.p)entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function(key){
        var that  = this
          , entry = getEntry(that, key);
        if(entry){
          var next = entry.n
            , prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if(prev)prev.n = next;
          if(next)next.p = prev;
          if(that._f == entry)that._f = next;
          if(that._l == entry)that._l = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /*, that = undefined */){
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3)
          , entry;
        while(entry = entry ? entry.n : this._f){
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while(entry && entry.r)entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key){
        return !!getEntry(this, key);
      }
    });
    if(DESCRIPTORS)$.setDesc(C.prototype, 'size', {
      get: function(){
        return defined(this[SIZE]);
      }
    });
    return C;
  },
  def: function(that, key, value){
    var entry = getEntry(that, key)
      , prev, index;
    // change existing entry
    if(entry){
      entry.v = value;
    // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that._l,             // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if(!that._f)that._f = entry;
      if(prev)prev.n = entry;
      that[SIZE]++;
      // add to index
      if(index !== 'F')that._i[index] = entry;
    } return that;
  },
  getEntry: getEntry,
  setStrong: function(C, NAME, IS_MAP){
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function(iterated, kind){
      this._t = iterated;  // target
      this._k = kind;      // kind
      this._l = undefined; // previous
    }, function(){
      var that  = this
        , kind  = that._k
        , entry = that._l;
      // revert to the last existing entry
      while(entry && entry.r)entry = entry.p;
      // get next entry
      if(!that._t || !(that._l = entry = entry ? entry.n : that._t._f)){
        // or finish the iteration
        that._t = undefined;
        return step(1);
      }
      // return step by kind
      if(kind == 'keys'  )return step(0, entry.k);
      if(kind == 'values')return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values' , !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(NAME);
  }
};
},{"./$":107,"./$.ctx":83,"./$.defined":84,"./$.descriptors":85,"./$.for-of":90,"./$.has":93,"./$.hide":94,"./$.is-object":100,"./$.iter-define":103,"./$.iter-step":105,"./$.redefine-all":115,"./$.set-species":119,"./$.strict-new":123,"./$.uid":130}],80:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var forOf   = require('./$.for-of')
  , classof = require('./$.classof');
module.exports = function(NAME){
  return function toJSON(){
    if(classof(this) != NAME)throw TypeError(NAME + "#toJSON isn't generic");
    var arr = [];
    forOf(this, false, arr.push, arr);
    return arr;
  };
};
},{"./$.classof":77,"./$.for-of":90}],81:[function(require,module,exports){
'use strict';
var $              = require('./$')
  , global         = require('./$.global')
  , $export        = require('./$.export')
  , fails          = require('./$.fails')
  , hide           = require('./$.hide')
  , redefineAll    = require('./$.redefine-all')
  , forOf          = require('./$.for-of')
  , strictNew      = require('./$.strict-new')
  , isObject       = require('./$.is-object')
  , setToStringTag = require('./$.set-to-string-tag')
  , DESCRIPTORS    = require('./$.descriptors');

module.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK){
  var Base  = global[NAME]
    , C     = Base
    , ADDER = IS_MAP ? 'set' : 'add'
    , proto = C && C.prototype
    , O     = {};
  if(!DESCRIPTORS || typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function(){
    new C().entries().next();
  }))){
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
  } else {
    C = wrapper(function(target, iterable){
      strictNew(target, C, NAME);
      target._c = new Base;
      if(iterable != undefined)forOf(iterable, IS_MAP, target[ADDER], target);
    });
    $.each.call('add,clear,delete,forEach,get,has,set,keys,values,entries'.split(','),function(KEY){
      var IS_ADDER = KEY == 'add' || KEY == 'set';
      if(KEY in proto && !(IS_WEAK && KEY == 'clear'))hide(C.prototype, KEY, function(a, b){
        if(!IS_ADDER && IS_WEAK && !isObject(a))return KEY == 'get' ? undefined : false;
        var result = this._c[KEY](a === 0 ? 0 : a, b);
        return IS_ADDER ? this : result;
      });
    });
    if('size' in proto)$.setDesc(C.prototype, 'size', {
      get: function(){
        return this._c.size;
      }
    });
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F, O);

  if(!IS_WEAK)common.setStrong(C, NAME, IS_MAP);

  return C;
};
},{"./$":107,"./$.descriptors":85,"./$.export":88,"./$.fails":89,"./$.for-of":90,"./$.global":92,"./$.hide":94,"./$.is-object":100,"./$.redefine-all":115,"./$.set-to-string-tag":120,"./$.strict-new":123}],82:[function(require,module,exports){
var core = module.exports = {version: '1.2.6'};
if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef
},{}],83:[function(require,module,exports){
// optional / simple context binding
var aFunction = require('./$.a-function');
module.exports = function(fn, that, length){
  aFunction(fn);
  if(that === undefined)return fn;
  switch(length){
    case 1: return function(a){
      return fn.call(that, a);
    };
    case 2: return function(a, b){
      return fn.call(that, a, b);
    };
    case 3: return function(a, b, c){
      return fn.call(that, a, b, c);
    };
  }
  return function(/* ...args */){
    return fn.apply(that, arguments);
  };
};
},{"./$.a-function":74}],84:[function(require,module,exports){
// 7.2.1 RequireObjectCoercible(argument)
module.exports = function(it){
  if(it == undefined)throw TypeError("Can't call method on  " + it);
  return it;
};
},{}],85:[function(require,module,exports){
// Thank's IE8 for his funny defineProperty
module.exports = !require('./$.fails')(function(){
  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
});
},{"./$.fails":89}],86:[function(require,module,exports){
var isObject = require('./$.is-object')
  , document = require('./$.global').document
  // in old IE typeof document.createElement is 'object'
  , is = isObject(document) && isObject(document.createElement);
module.exports = function(it){
  return is ? document.createElement(it) : {};
};
},{"./$.global":92,"./$.is-object":100}],87:[function(require,module,exports){
// all enumerable object keys, includes symbols
var $ = require('./$');
module.exports = function(it){
  var keys       = $.getKeys(it)
    , getSymbols = $.getSymbols;
  if(getSymbols){
    var symbols = getSymbols(it)
      , isEnum  = $.isEnum
      , i       = 0
      , key;
    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))keys.push(key);
  }
  return keys;
};
},{"./$":107}],88:[function(require,module,exports){
var global    = require('./$.global')
  , core      = require('./$.core')
  , ctx       = require('./$.ctx')
  , PROTOTYPE = 'prototype';

var $export = function(type, name, source){
  var IS_FORCED = type & $export.F
    , IS_GLOBAL = type & $export.G
    , IS_STATIC = type & $export.S
    , IS_PROTO  = type & $export.P
    , IS_BIND   = type & $export.B
    , IS_WRAP   = type & $export.W
    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]
    , key, own, out;
  if(IS_GLOBAL)source = name;
  for(key in source){
    // contains in native
    own = !IS_FORCED && target && key in target;
    if(own && key in exports)continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function(C){
      var F = function(param){
        return this instanceof C ? new C(param) : C(param);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    if(IS_PROTO)(exports[PROTOTYPE] || (exports[PROTOTYPE] = {}))[key] = out;
  }
};
// type bitmap
$export.F = 1;  // forced
$export.G = 2;  // global
$export.S = 4;  // static
$export.P = 8;  // proto
$export.B = 16; // bind
$export.W = 32; // wrap
module.exports = $export;
},{"./$.core":82,"./$.ctx":83,"./$.global":92}],89:[function(require,module,exports){
module.exports = function(exec){
  try {
    return !!exec();
  } catch(e){
    return true;
  }
};
},{}],90:[function(require,module,exports){
var ctx         = require('./$.ctx')
  , call        = require('./$.iter-call')
  , isArrayIter = require('./$.is-array-iter')
  , anObject    = require('./$.an-object')
  , toLength    = require('./$.to-length')
  , getIterFn   = require('./core.get-iterator-method');
module.exports = function(iterable, entries, fn, that){
  var iterFn = getIterFn(iterable)
    , f      = ctx(fn, that, entries ? 2 : 1)
    , index  = 0
    , length, step, iterator;
  if(typeof iterFn != 'function')throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if(isArrayIter(iterFn))for(length = toLength(iterable.length); length > index; index++){
    entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
  } else for(iterator = iterFn.call(iterable); !(step = iterator.next()).done; ){
    call(iterator, f, step.value, entries);
  }
};
},{"./$.an-object":76,"./$.ctx":83,"./$.is-array-iter":98,"./$.iter-call":101,"./$.to-length":128,"./core.get-iterator-method":132}],91:[function(require,module,exports){
// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = require('./$.to-iobject')
  , getNames  = require('./$').getNames
  , toString  = {}.toString;

var windowNames = typeof window == 'object' && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function(it){
  try {
    return getNames(it);
  } catch(e){
    return windowNames.slice();
  }
};

module.exports.get = function getOwnPropertyNames(it){
  if(windowNames && toString.call(it) == '[object Window]')return getWindowNames(it);
  return getNames(toIObject(it));
};
},{"./$":107,"./$.to-iobject":127}],92:[function(require,module,exports){
// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef
},{}],93:[function(require,module,exports){
var hasOwnProperty = {}.hasOwnProperty;
module.exports = function(it, key){
  return hasOwnProperty.call(it, key);
};
},{}],94:[function(require,module,exports){
var $          = require('./$')
  , createDesc = require('./$.property-desc');
module.exports = require('./$.descriptors') ? function(object, key, value){
  return $.setDesc(object, key, createDesc(1, value));
} : function(object, key, value){
  object[key] = value;
  return object;
};
},{"./$":107,"./$.descriptors":85,"./$.property-desc":114}],95:[function(require,module,exports){
module.exports = require('./$.global').document && document.documentElement;
},{"./$.global":92}],96:[function(require,module,exports){
// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function(fn, args, that){
  var un = that === undefined;
  switch(args.length){
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return              fn.apply(that, args);
};
},{}],97:[function(require,module,exports){
// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = require('./$.cof');
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
  return cof(it) == 'String' ? it.split('') : Object(it);
};
},{"./$.cof":78}],98:[function(require,module,exports){
// check on default Array iterator
var Iterators  = require('./$.iterators')
  , ITERATOR   = require('./$.wks')('iterator')
  , ArrayProto = Array.prototype;

module.exports = function(it){
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};
},{"./$.iterators":106,"./$.wks":131}],99:[function(require,module,exports){
// 7.2.2 IsArray(argument)
var cof = require('./$.cof');
module.exports = Array.isArray || function(arg){
  return cof(arg) == 'Array';
};
},{"./$.cof":78}],100:[function(require,module,exports){
module.exports = function(it){
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};
},{}],101:[function(require,module,exports){
// call something on iterator step with safe closing on error
var anObject = require('./$.an-object');
module.exports = function(iterator, fn, value, entries){
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch(e){
    var ret = iterator['return'];
    if(ret !== undefined)anObject(ret.call(iterator));
    throw e;
  }
};
},{"./$.an-object":76}],102:[function(require,module,exports){
'use strict';
var $              = require('./$')
  , descriptor     = require('./$.property-desc')
  , setToStringTag = require('./$.set-to-string-tag')
  , IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
require('./$.hide')(IteratorPrototype, require('./$.wks')('iterator'), function(){ return this; });

module.exports = function(Constructor, NAME, next){
  Constructor.prototype = $.create(IteratorPrototype, {next: descriptor(1, next)});
  setToStringTag(Constructor, NAME + ' Iterator');
};
},{"./$":107,"./$.hide":94,"./$.property-desc":114,"./$.set-to-string-tag":120,"./$.wks":131}],103:[function(require,module,exports){
'use strict';
var LIBRARY        = require('./$.library')
  , $export        = require('./$.export')
  , redefine       = require('./$.redefine')
  , hide           = require('./$.hide')
  , has            = require('./$.has')
  , Iterators      = require('./$.iterators')
  , $iterCreate    = require('./$.iter-create')
  , setToStringTag = require('./$.set-to-string-tag')
  , getProto       = require('./$').getProto
  , ITERATOR       = require('./$.wks')('iterator')
  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
  , FF_ITERATOR    = '@@iterator'
  , KEYS           = 'keys'
  , VALUES         = 'values';

var returnThis = function(){ return this; };

module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){
  $iterCreate(Constructor, NAME, next);
  var getMethod = function(kind){
    if(!BUGGY && kind in proto)return proto[kind];
    switch(kind){
      case KEYS: return function keys(){ return new Constructor(this, kind); };
      case VALUES: return function values(){ return new Constructor(this, kind); };
    } return function entries(){ return new Constructor(this, kind); };
  };
  var TAG        = NAME + ' Iterator'
    , DEF_VALUES = DEFAULT == VALUES
    , VALUES_BUG = false
    , proto      = Base.prototype
    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
    , $default   = $native || getMethod(DEFAULT)
    , methods, key;
  // Fix native
  if($native){
    var IteratorPrototype = getProto($default.call(new Base));
    // Set @@toStringTag to native iterators
    setToStringTag(IteratorPrototype, TAG, true);
    // FF fix
    if(!LIBRARY && has(proto, FF_ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);
    // fix Array#{values, @@iterator}.name in V8 / FF
    if(DEF_VALUES && $native.name !== VALUES){
      VALUES_BUG = true;
      $default = function values(){ return $native.call(this); };
    }
  }
  // Define iterator
  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG]  = returnThis;
  if(DEFAULT){
    methods = {
      values:  DEF_VALUES  ? $default : getMethod(VALUES),
      keys:    IS_SET      ? $default : getMethod(KEYS),
      entries: !DEF_VALUES ? $default : getMethod('entries')
    };
    if(FORCED)for(key in methods){
      if(!(key in proto))redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};
},{"./$":107,"./$.export":88,"./$.has":93,"./$.hide":94,"./$.iter-create":102,"./$.iterators":106,"./$.library":109,"./$.redefine":116,"./$.set-to-string-tag":120,"./$.wks":131}],104:[function(require,module,exports){
var ITERATOR     = require('./$.wks')('iterator')
  , SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function(){ SAFE_CLOSING = true; };
  Array.from(riter, function(){ throw 2; });
} catch(e){ /* empty */ }

module.exports = function(exec, skipClosing){
  if(!skipClosing && !SAFE_CLOSING)return false;
  var safe = false;
  try {
    var arr  = [7]
      , iter = arr[ITERATOR]();
    iter.next = function(){ safe = true; };
    arr[ITERATOR] = function(){ return iter; };
    exec(arr);
  } catch(e){ /* empty */ }
  return safe;
};
},{"./$.wks":131}],105:[function(require,module,exports){
module.exports = function(done, value){
  return {value: value, done: !!done};
};
},{}],106:[function(require,module,exports){
module.exports = {};
},{}],107:[function(require,module,exports){
var $Object = Object;
module.exports = {
  create:     $Object.create,
  getProto:   $Object.getPrototypeOf,
  isEnum:     {}.propertyIsEnumerable,
  getDesc:    $Object.getOwnPropertyDescriptor,
  setDesc:    $Object.defineProperty,
  setDescs:   $Object.defineProperties,
  getKeys:    $Object.keys,
  getNames:   $Object.getOwnPropertyNames,
  getSymbols: $Object.getOwnPropertySymbols,
  each:       [].forEach
};
},{}],108:[function(require,module,exports){
var $         = require('./$')
  , toIObject = require('./$.to-iobject');
module.exports = function(object, el){
  var O      = toIObject(object)
    , keys   = $.getKeys(O)
    , length = keys.length
    , index  = 0
    , key;
  while(length > index)if(O[key = keys[index++]] === el)return key;
};
},{"./$":107,"./$.to-iobject":127}],109:[function(require,module,exports){
module.exports = true;
},{}],110:[function(require,module,exports){
var global    = require('./$.global')
  , macrotask = require('./$.task').set
  , Observer  = global.MutationObserver || global.WebKitMutationObserver
  , process   = global.process
  , Promise   = global.Promise
  , isNode    = require('./$.cof')(process) == 'process'
  , head, last, notify;

var flush = function(){
  var parent, domain, fn;
  if(isNode && (parent = process.domain)){
    process.domain = null;
    parent.exit();
  }
  while(head){
    domain = head.domain;
    fn     = head.fn;
    if(domain)domain.enter();
    fn(); // <- currently we use it only for Promise - try / catch not required
    if(domain)domain.exit();
    head = head.next;
  } last = undefined;
  if(parent)parent.enter();
};

// Node.js
if(isNode){
  notify = function(){
    process.nextTick(flush);
  };
// browsers with MutationObserver
} else if(Observer){
  var toggle = 1
    , node   = document.createTextNode('');
  new Observer(flush).observe(node, {characterData: true}); // eslint-disable-line no-new
  notify = function(){
    node.data = toggle = -toggle;
  };
// environments with maybe non-completely correct, but existent Promise
} else if(Promise && Promise.resolve){
  notify = function(){
    Promise.resolve().then(flush);
  };
// for other environments - macrotask based on:
// - setImmediate
// - MessageChannel
// - window.postMessag
// - onreadystatechange
// - setTimeout
} else {
  notify = function(){
    // strange IE + webpack dev server bug - use .call(global)
    macrotask.call(global, flush);
  };
}

module.exports = function asap(fn){
  var task = {fn: fn, next: undefined, domain: isNode && process.domain};
  if(last)last.next = task;
  if(!head){
    head = task;
    notify();
  } last = task;
};
},{"./$.cof":78,"./$.global":92,"./$.task":125}],111:[function(require,module,exports){
// 19.1.2.1 Object.assign(target, source, ...)
var $        = require('./$')
  , toObject = require('./$.to-object')
  , IObject  = require('./$.iobject');

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = require('./$.fails')(function(){
  var a = Object.assign
    , A = {}
    , B = {}
    , S = Symbol()
    , K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function(k){ B[k] = k; });
  return a({}, A)[S] != 7 || Object.keys(a({}, B)).join('') != K;
}) ? function assign(target, source){ // eslint-disable-line no-unused-vars
  var T     = toObject(target)
    , $$    = arguments
    , $$len = $$.length
    , index = 1
    , getKeys    = $.getKeys
    , getSymbols = $.getSymbols
    , isEnum     = $.isEnum;
  while($$len > index){
    var S      = IObject($$[index++])
      , keys   = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)
      , length = keys.length
      , j      = 0
      , key;
    while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];
  }
  return T;
} : Object.assign;
},{"./$":107,"./$.fails":89,"./$.iobject":97,"./$.to-object":129}],112:[function(require,module,exports){
// most Object methods by ES6 should accept primitives
var $export = require('./$.export')
  , core    = require('./$.core')
  , fails   = require('./$.fails');
module.exports = function(KEY, exec){
  var fn  = (core.Object || {})[KEY] || Object[KEY]
    , exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);
};
},{"./$.core":82,"./$.export":88,"./$.fails":89}],113:[function(require,module,exports){
var $         = require('./$')
  , toIObject = require('./$.to-iobject')
  , isEnum    = $.isEnum;
module.exports = function(isEntries){
  return function(it){
    var O      = toIObject(it)
      , keys   = $.getKeys(O)
      , length = keys.length
      , i      = 0
      , result = []
      , key;
    while(length > i)if(isEnum.call(O, key = keys[i++])){
      result.push(isEntries ? [key, O[key]] : O[key]);
    } return result;
  };
};
},{"./$":107,"./$.to-iobject":127}],114:[function(require,module,exports){
module.exports = function(bitmap, value){
  return {
    enumerable  : !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable    : !(bitmap & 4),
    value       : value
  };
};
},{}],115:[function(require,module,exports){
var redefine = require('./$.redefine');
module.exports = function(target, src){
  for(var key in src)redefine(target, key, src[key]);
  return target;
};
},{"./$.redefine":116}],116:[function(require,module,exports){
module.exports = require('./$.hide');
},{"./$.hide":94}],117:[function(require,module,exports){
// 7.2.9 SameValue(x, y)
module.exports = Object.is || function is(x, y){
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};
},{}],118:[function(require,module,exports){
// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var getDesc  = require('./$').getDesc
  , isObject = require('./$.is-object')
  , anObject = require('./$.an-object');
var check = function(O, proto){
  anObject(O);
  if(!isObject(proto) && proto !== null)throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function(test, buggy, set){
      try {
        set = require('./$.ctx')(Function.call, getDesc(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch(e){ buggy = true; }
      return function setPrototypeOf(O, proto){
        check(O, proto);
        if(buggy)O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};
},{"./$":107,"./$.an-object":76,"./$.ctx":83,"./$.is-object":100}],119:[function(require,module,exports){
'use strict';
var core        = require('./$.core')
  , $           = require('./$')
  , DESCRIPTORS = require('./$.descriptors')
  , SPECIES     = require('./$.wks')('species');

module.exports = function(KEY){
  var C = core[KEY];
  if(DESCRIPTORS && C && !C[SPECIES])$.setDesc(C, SPECIES, {
    configurable: true,
    get: function(){ return this; }
  });
};
},{"./$":107,"./$.core":82,"./$.descriptors":85,"./$.wks":131}],120:[function(require,module,exports){
var def = require('./$').setDesc
  , has = require('./$.has')
  , TAG = require('./$.wks')('toStringTag');

module.exports = function(it, tag, stat){
  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});
};
},{"./$":107,"./$.has":93,"./$.wks":131}],121:[function(require,module,exports){
var global = require('./$.global')
  , SHARED = '__core-js_shared__'
  , store  = global[SHARED] || (global[SHARED] = {});
module.exports = function(key){
  return store[key] || (store[key] = {});
};
},{"./$.global":92}],122:[function(require,module,exports){
// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject  = require('./$.an-object')
  , aFunction = require('./$.a-function')
  , SPECIES   = require('./$.wks')('species');
module.exports = function(O, D){
  var C = anObject(O).constructor, S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};
},{"./$.a-function":74,"./$.an-object":76,"./$.wks":131}],123:[function(require,module,exports){
module.exports = function(it, Constructor, name){
  if(!(it instanceof Constructor))throw TypeError(name + ": use the 'new' operator!");
  return it;
};
},{}],124:[function(require,module,exports){
var toInteger = require('./$.to-integer')
  , defined   = require('./$.defined');
// true  -> String#at
// false -> String#codePointAt
module.exports = function(TO_STRING){
  return function(that, pos){
    var s = String(defined(that))
      , i = toInteger(pos)
      , l = s.length
      , a, b;
    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};
},{"./$.defined":84,"./$.to-integer":126}],125:[function(require,module,exports){
var ctx                = require('./$.ctx')
  , invoke             = require('./$.invoke')
  , html               = require('./$.html')
  , cel                = require('./$.dom-create')
  , global             = require('./$.global')
  , process            = global.process
  , setTask            = global.setImmediate
  , clearTask          = global.clearImmediate
  , MessageChannel     = global.MessageChannel
  , counter            = 0
  , queue              = {}
  , ONREADYSTATECHANGE = 'onreadystatechange'
  , defer, channel, port;
var run = function(){
  var id = +this;
  if(queue.hasOwnProperty(id)){
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listner = function(event){
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if(!setTask || !clearTask){
  setTask = function setImmediate(fn){
    var args = [], i = 1;
    while(arguments.length > i)args.push(arguments[i++]);
    queue[++counter] = function(){
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id){
    delete queue[id];
  };
  // Node.js 0.8-
  if(require('./$.cof')(process) == 'process'){
    defer = function(id){
      process.nextTick(ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if(MessageChannel){
    channel = new MessageChannel;
    port    = channel.port2;
    channel.port1.onmessage = listner;
    defer = ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if(global.addEventListener && typeof postMessage == 'function' && !global.importScripts){
    defer = function(id){
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listner, false);
  // IE8-
  } else if(ONREADYSTATECHANGE in cel('script')){
    defer = function(id){
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function(){
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function(id){
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set:   setTask,
  clear: clearTask
};
},{"./$.cof":78,"./$.ctx":83,"./$.dom-create":86,"./$.global":92,"./$.html":95,"./$.invoke":96}],126:[function(require,module,exports){
// 7.1.4 ToInteger
var ceil  = Math.ceil
  , floor = Math.floor;
module.exports = function(it){
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};
},{}],127:[function(require,module,exports){
// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = require('./$.iobject')
  , defined = require('./$.defined');
module.exports = function(it){
  return IObject(defined(it));
};
},{"./$.defined":84,"./$.iobject":97}],128:[function(require,module,exports){
// 7.1.15 ToLength
var toInteger = require('./$.to-integer')
  , min       = Math.min;
module.exports = function(it){
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};
},{"./$.to-integer":126}],129:[function(require,module,exports){
// 7.1.13 ToObject(argument)
var defined = require('./$.defined');
module.exports = function(it){
  return Object(defined(it));
};
},{"./$.defined":84}],130:[function(require,module,exports){
var id = 0
  , px = Math.random();
module.exports = function(key){
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};
},{}],131:[function(require,module,exports){
var store  = require('./$.shared')('wks')
  , uid    = require('./$.uid')
  , Symbol = require('./$.global').Symbol;
module.exports = function(name){
  return store[name] || (store[name] =
    Symbol && Symbol[name] || (Symbol || uid)('Symbol.' + name));
};
},{"./$.global":92,"./$.shared":121,"./$.uid":130}],132:[function(require,module,exports){
var classof   = require('./$.classof')
  , ITERATOR  = require('./$.wks')('iterator')
  , Iterators = require('./$.iterators');
module.exports = require('./$.core').getIteratorMethod = function(it){
  if(it != undefined)return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};
},{"./$.classof":77,"./$.core":82,"./$.iterators":106,"./$.wks":131}],133:[function(require,module,exports){
var anObject = require('./$.an-object')
  , get      = require('./core.get-iterator-method');
module.exports = require('./$.core').getIterator = function(it){
  var iterFn = get(it);
  if(typeof iterFn != 'function')throw TypeError(it + ' is not iterable!');
  return anObject(iterFn.call(it));
};
},{"./$.an-object":76,"./$.core":82,"./core.get-iterator-method":132}],134:[function(require,module,exports){
'use strict';
var ctx         = require('./$.ctx')
  , $export     = require('./$.export')
  , toObject    = require('./$.to-object')
  , call        = require('./$.iter-call')
  , isArrayIter = require('./$.is-array-iter')
  , toLength    = require('./$.to-length')
  , getIterFn   = require('./core.get-iterator-method');
$export($export.S + $export.F * !require('./$.iter-detect')(function(iter){ Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike/*, mapfn = undefined, thisArg = undefined*/){
    var O       = toObject(arrayLike)
      , C       = typeof this == 'function' ? this : Array
      , $$      = arguments
      , $$len   = $$.length
      , mapfn   = $$len > 1 ? $$[1] : undefined
      , mapping = mapfn !== undefined
      , index   = 0
      , iterFn  = getIterFn(O)
      , length, result, step, iterator;
    if(mapping)mapfn = ctx(mapfn, $$len > 2 ? $$[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if(iterFn != undefined && !(C == Array && isArrayIter(iterFn))){
      for(iterator = iterFn.call(O), result = new C; !(step = iterator.next()).done; index++){
        result[index] = mapping ? call(iterator, mapfn, [step.value, index], true) : step.value;
      }
    } else {
      length = toLength(O.length);
      for(result = new C(length); length > index; index++){
        result[index] = mapping ? mapfn(O[index], index) : O[index];
      }
    }
    result.length = index;
    return result;
  }
});

},{"./$.ctx":83,"./$.export":88,"./$.is-array-iter":98,"./$.iter-call":101,"./$.iter-detect":104,"./$.to-length":128,"./$.to-object":129,"./core.get-iterator-method":132}],135:[function(require,module,exports){
'use strict';
var addToUnscopables = require('./$.add-to-unscopables')
  , step             = require('./$.iter-step')
  , Iterators        = require('./$.iterators')
  , toIObject        = require('./$.to-iobject');

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = require('./$.iter-define')(Array, 'Array', function(iterated, kind){
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function(){
  var O     = this._t
    , kind  = this._k
    , index = this._i++;
  if(!O || index >= O.length){
    this._t = undefined;
    return step(1);
  }
  if(kind == 'keys'  )return step(0, index);
  if(kind == 'values')return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');
},{"./$.add-to-unscopables":75,"./$.iter-define":103,"./$.iter-step":105,"./$.iterators":106,"./$.to-iobject":127}],136:[function(require,module,exports){
// 19.1.3.1 Object.assign(target, source)
var $export = require('./$.export');

$export($export.S + $export.F, 'Object', {assign: require('./$.object-assign')});
},{"./$.export":88,"./$.object-assign":111}],137:[function(require,module,exports){
// 19.1.2.5 Object.freeze(O)
var isObject = require('./$.is-object');

require('./$.object-sap')('freeze', function($freeze){
  return function freeze(it){
    return $freeze && isObject(it) ? $freeze(it) : it;
  };
});
},{"./$.is-object":100,"./$.object-sap":112}],138:[function(require,module,exports){
// 19.1.2.14 Object.keys(O)
var toObject = require('./$.to-object');

require('./$.object-sap')('keys', function($keys){
  return function keys(it){
    return $keys(toObject(it));
  };
});
},{"./$.object-sap":112,"./$.to-object":129}],139:[function(require,module,exports){
// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = require('./$.export');
$export($export.S, 'Object', {setPrototypeOf: require('./$.set-proto').set});
},{"./$.export":88,"./$.set-proto":118}],140:[function(require,module,exports){

},{}],141:[function(require,module,exports){
'use strict';
var $          = require('./$')
  , LIBRARY    = require('./$.library')
  , global     = require('./$.global')
  , ctx        = require('./$.ctx')
  , classof    = require('./$.classof')
  , $export    = require('./$.export')
  , isObject   = require('./$.is-object')
  , anObject   = require('./$.an-object')
  , aFunction  = require('./$.a-function')
  , strictNew  = require('./$.strict-new')
  , forOf      = require('./$.for-of')
  , setProto   = require('./$.set-proto').set
  , same       = require('./$.same-value')
  , SPECIES    = require('./$.wks')('species')
  , speciesConstructor = require('./$.species-constructor')
  , asap       = require('./$.microtask')
  , PROMISE    = 'Promise'
  , process    = global.process
  , isNode     = classof(process) == 'process'
  , P          = global[PROMISE]
  , Wrapper;

var testResolve = function(sub){
  var test = new P(function(){});
  if(sub)test.constructor = Object;
  return P.resolve(test) === test;
};

var USE_NATIVE = function(){
  var works = false;
  function P2(x){
    var self = new P(x);
    setProto(self, P2.prototype);
    return self;
  }
  try {
    works = P && P.resolve && testResolve();
    setProto(P2, P);
    P2.prototype = $.create(P.prototype, {constructor: {value: P2}});
    // actual Firefox has broken subclass support, test that
    if(!(P2.resolve(5).then(function(){}) instanceof P2)){
      works = false;
    }
    // actual V8 bug, https://code.google.com/p/v8/issues/detail?id=4162
    if(works && require('./$.descriptors')){
      var thenableThenGotten = false;
      P.resolve($.setDesc({}, 'then', {
        get: function(){ thenableThenGotten = true; }
      }));
      works = thenableThenGotten;
    }
  } catch(e){ works = false; }
  return works;
}();

// helpers
var sameConstructor = function(a, b){
  // library wrapper special case
  if(LIBRARY && a === P && b === Wrapper)return true;
  return same(a, b);
};
var getConstructor = function(C){
  var S = anObject(C)[SPECIES];
  return S != undefined ? S : C;
};
var isThenable = function(it){
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var PromiseCapability = function(C){
  var resolve, reject;
  this.promise = new C(function($$resolve, $$reject){
    if(resolve !== undefined || reject !== undefined)throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject  = $$reject;
  });
  this.resolve = aFunction(resolve),
  this.reject  = aFunction(reject)
};
var perform = function(exec){
  try {
    exec();
  } catch(e){
    return {error: e};
  }
};
var notify = function(record, isReject){
  if(record.n)return;
  record.n = true;
  var chain = record.c;
  asap(function(){
    var value = record.v
      , ok    = record.s == 1
      , i     = 0;
    var run = function(reaction){
      var handler = ok ? reaction.ok : reaction.fail
        , resolve = reaction.resolve
        , reject  = reaction.reject
        , result, then;
      try {
        if(handler){
          if(!ok)record.h = true;
          result = handler === true ? value : handler(value);
          if(result === reaction.promise){
            reject(TypeError('Promise-chain cycle'));
          } else if(then = isThenable(result)){
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch(e){
        reject(e);
      }
    };
    while(chain.length > i)run(chain[i++]); // variable length - can't use forEach
    chain.length = 0;
    record.n = false;
    if(isReject)setTimeout(function(){
      var promise = record.p
        , handler, console;
      if(isUnhandled(promise)){
        if(isNode){
          process.emit('unhandledRejection', value, promise);
        } else if(handler = global.onunhandledrejection){
          handler({promise: promise, reason: value});
        } else if((console = global.console) && console.error){
          console.error('Unhandled promise rejection', value);
        }
      } record.a = undefined;
    }, 1);
  });
};
var isUnhandled = function(promise){
  var record = promise._d
    , chain  = record.a || record.c
    , i      = 0
    , reaction;
  if(record.h)return false;
  while(chain.length > i){
    reaction = chain[i++];
    if(reaction.fail || !isUnhandled(reaction.promise))return false;
  } return true;
};
var $reject = function(value){
  var record = this;
  if(record.d)return;
  record.d = true;
  record = record.r || record; // unwrap
  record.v = value;
  record.s = 2;
  record.a = record.c.slice();
  notify(record, true);
};
var $resolve = function(value){
  var record = this
    , then;
  if(record.d)return;
  record.d = true;
  record = record.r || record; // unwrap
  try {
    if(record.p === value)throw TypeError("Promise can't be resolved itself");
    if(then = isThenable(value)){
      asap(function(){
        var wrapper = {r: record, d: false}; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch(e){
          $reject.call(wrapper, e);
        }
      });
    } else {
      record.v = value;
      record.s = 1;
      notify(record, false);
    }
  } catch(e){
    $reject.call({r: record, d: false}, e); // wrap
  }
};

// constructor polyfill
if(!USE_NATIVE){
  // 25.4.3.1 Promise(executor)
  P = function Promise(executor){
    aFunction(executor);
    var record = this._d = {
      p: strictNew(this, P, PROMISE),         // <- promise
      c: [],                                  // <- awaiting reactions
      a: undefined,                           // <- checked in isUnhandled reactions
      s: 0,                                   // <- state
      d: false,                               // <- done
      v: undefined,                           // <- value
      h: false,                               // <- handled rejection
      n: false                                // <- notify
    };
    try {
      executor(ctx($resolve, record, 1), ctx($reject, record, 1));
    } catch(err){
      $reject.call(record, err);
    }
  };
  require('./$.redefine-all')(P.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected){
      var reaction = new PromiseCapability(speciesConstructor(this, P))
        , promise  = reaction.promise
        , record   = this._d;
      reaction.ok   = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      record.c.push(reaction);
      if(record.a)record.a.push(reaction);
      if(record.s)notify(record, false);
      return promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function(onRejected){
      return this.then(undefined, onRejected);
    }
  });
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, {Promise: P});
require('./$.set-to-string-tag')(P, PROMISE);
require('./$.set-species')(PROMISE);
Wrapper = require('./$.core')[PROMISE];

// statics
$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r){
    var capability = new PromiseCapability(this)
      , $$reject   = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (!USE_NATIVE || testResolve(true)), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x){
    // instanceof instead of internal slot check because we should fix it without replacement native Promise core
    if(x instanceof P && sameConstructor(x.constructor, this))return x;
    var capability = new PromiseCapability(this)
      , $$resolve  = capability.resolve;
    $$resolve(x);
    return capability.promise;
  }
});
$export($export.S + $export.F * !(USE_NATIVE && require('./$.iter-detect')(function(iter){
  P.all(iter)['catch'](function(){});
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable){
    var C          = getConstructor(this)
      , capability = new PromiseCapability(C)
      , resolve    = capability.resolve
      , reject     = capability.reject
      , values     = [];
    var abrupt = perform(function(){
      forOf(iterable, false, values.push, values);
      var remaining = values.length
        , results   = Array(remaining);
      if(remaining)$.each.call(values, function(promise, index){
        var alreadyCalled = false;
        C.resolve(promise).then(function(value){
          if(alreadyCalled)return;
          alreadyCalled = true;
          results[index] = value;
          --remaining || resolve(results);
        }, reject);
      });
      else resolve(results);
    });
    if(abrupt)reject(abrupt.error);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable){
    var C          = getConstructor(this)
      , capability = new PromiseCapability(C)
      , reject     = capability.reject;
    var abrupt = perform(function(){
      forOf(iterable, false, function(promise){
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if(abrupt)reject(abrupt.error);
    return capability.promise;
  }
});
},{"./$":107,"./$.a-function":74,"./$.an-object":76,"./$.classof":77,"./$.core":82,"./$.ctx":83,"./$.descriptors":85,"./$.export":88,"./$.for-of":90,"./$.global":92,"./$.is-object":100,"./$.iter-detect":104,"./$.library":109,"./$.microtask":110,"./$.redefine-all":115,"./$.same-value":117,"./$.set-proto":118,"./$.set-species":119,"./$.set-to-string-tag":120,"./$.species-constructor":122,"./$.strict-new":123,"./$.wks":131}],142:[function(require,module,exports){
'use strict';
var strong = require('./$.collection-strong');

// 23.2 Set Objects
require('./$.collection')('Set', function(get){
  return function Set(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value){
    return strong.def(this, value = value === 0 ? 0 : value, value);
  }
}, strong);
},{"./$.collection":81,"./$.collection-strong":79}],143:[function(require,module,exports){
'use strict';
var $at  = require('./$.string-at')(true);

// 21.1.3.27 String.prototype[@@iterator]()
require('./$.iter-define')(String, 'String', function(iterated){
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function(){
  var O     = this._t
    , index = this._i
    , point;
  if(index >= O.length)return {value: undefined, done: true};
  point = $at(O, index);
  this._i += point.length;
  return {value: point, done: false};
});
},{"./$.iter-define":103,"./$.string-at":124}],144:[function(require,module,exports){
'use strict';
// ECMAScript 6 symbols shim
var $              = require('./$')
  , global         = require('./$.global')
  , has            = require('./$.has')
  , DESCRIPTORS    = require('./$.descriptors')
  , $export        = require('./$.export')
  , redefine       = require('./$.redefine')
  , $fails         = require('./$.fails')
  , shared         = require('./$.shared')
  , setToStringTag = require('./$.set-to-string-tag')
  , uid            = require('./$.uid')
  , wks            = require('./$.wks')
  , keyOf          = require('./$.keyof')
  , $names         = require('./$.get-names')
  , enumKeys       = require('./$.enum-keys')
  , isArray        = require('./$.is-array')
  , anObject       = require('./$.an-object')
  , toIObject      = require('./$.to-iobject')
  , createDesc     = require('./$.property-desc')
  , getDesc        = $.getDesc
  , setDesc        = $.setDesc
  , _create        = $.create
  , getNames       = $names.get
  , $Symbol        = global.Symbol
  , $JSON          = global.JSON
  , _stringify     = $JSON && $JSON.stringify
  , setter         = false
  , HIDDEN         = wks('_hidden')
  , isEnum         = $.isEnum
  , SymbolRegistry = shared('symbol-registry')
  , AllSymbols     = shared('symbols')
  , useNative      = typeof $Symbol == 'function'
  , ObjectProto    = Object.prototype;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function(){
  return _create(setDesc({}, 'a', {
    get: function(){ return setDesc(this, 'a', {value: 7}).a; }
  })).a != 7;
}) ? function(it, key, D){
  var protoDesc = getDesc(ObjectProto, key);
  if(protoDesc)delete ObjectProto[key];
  setDesc(it, key, D);
  if(protoDesc && it !== ObjectProto)setDesc(ObjectProto, key, protoDesc);
} : setDesc;

var wrap = function(tag){
  var sym = AllSymbols[tag] = _create($Symbol.prototype);
  sym._k = tag;
  DESCRIPTORS && setter && setSymbolDesc(ObjectProto, tag, {
    configurable: true,
    set: function(value){
      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    }
  });
  return sym;
};

var isSymbol = function(it){
  return typeof it == 'symbol';
};

var $defineProperty = function defineProperty(it, key, D){
  if(D && has(AllSymbols, key)){
    if(!D.enumerable){
      if(!has(it, HIDDEN))setDesc(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
      D = _create(D, {enumerable: createDesc(0, false)});
    } return setSymbolDesc(it, key, D);
  } return setDesc(it, key, D);
};
var $defineProperties = function defineProperties(it, P){
  anObject(it);
  var keys = enumKeys(P = toIObject(P))
    , i    = 0
    , l = keys.length
    , key;
  while(l > i)$defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P){
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key){
  var E = isEnum.call(this, key);
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key]
    ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){
  var D = getDesc(it = toIObject(it), key);
  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it){
  var names  = getNames(toIObject(it))
    , result = []
    , i      = 0
    , key;
  while(names.length > i)if(!has(AllSymbols, key = names[i++]) && key != HIDDEN)result.push(key);
  return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it){
  var names  = getNames(toIObject(it))
    , result = []
    , i      = 0
    , key;
  while(names.length > i)if(has(AllSymbols, key = names[i++]))result.push(AllSymbols[key]);
  return result;
};
var $stringify = function stringify(it){
  if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined
  var args = [it]
    , i    = 1
    , $$   = arguments
    , replacer, $replacer;
  while($$.length > i)args.push($$[i++]);
  replacer = args[1];
  if(typeof replacer == 'function')$replacer = replacer;
  if($replacer || !isArray(replacer))replacer = function(key, value){
    if($replacer)value = $replacer.call(this, key, value);
    if(!isSymbol(value))return value;
  };
  args[1] = replacer;
  return _stringify.apply($JSON, args);
};
var buggyJSON = $fails(function(){
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
});

// 19.4.1.1 Symbol([description])
if(!useNative){
  $Symbol = function Symbol(){
    if(isSymbol(this))throw TypeError('Symbol is not a constructor');
    return wrap(uid(arguments.length > 0 ? arguments[0] : undefined));
  };
  redefine($Symbol.prototype, 'toString', function toString(){
    return this._k;
  });

  isSymbol = function(it){
    return it instanceof $Symbol;
  };

  $.create     = $create;
  $.isEnum     = $propertyIsEnumerable;
  $.getDesc    = $getOwnPropertyDescriptor;
  $.setDesc    = $defineProperty;
  $.setDescs   = $defineProperties;
  $.getNames   = $names.get = $getOwnPropertyNames;
  $.getSymbols = $getOwnPropertySymbols;

  if(DESCRIPTORS && !require('./$.library')){
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }
}

var symbolStatics = {
  // 19.4.2.1 Symbol.for(key)
  'for': function(key){
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(key){
    return keyOf(SymbolRegistry, key);
  },
  useSetter: function(){ setter = true; },
  useSimple: function(){ setter = false; }
};
// 19.4.2.2 Symbol.hasInstance
// 19.4.2.3 Symbol.isConcatSpreadable
// 19.4.2.4 Symbol.iterator
// 19.4.2.6 Symbol.match
// 19.4.2.8 Symbol.replace
// 19.4.2.9 Symbol.search
// 19.4.2.10 Symbol.species
// 19.4.2.11 Symbol.split
// 19.4.2.12 Symbol.toPrimitive
// 19.4.2.13 Symbol.toStringTag
// 19.4.2.14 Symbol.unscopables
$.each.call((
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,' +
  'species,split,toPrimitive,toStringTag,unscopables'
).split(','), function(it){
  var sym = wks(it);
  symbolStatics[it] = useNative ? sym : wrap(sym);
});

setter = true;

$export($export.G + $export.W, {Symbol: $Symbol});

$export($export.S, 'Symbol', symbolStatics);

$export($export.S + $export.F * !useNative, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!useNative || buggyJSON), 'JSON', {stringify: $stringify});

// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);
},{"./$":107,"./$.an-object":76,"./$.descriptors":85,"./$.enum-keys":87,"./$.export":88,"./$.fails":89,"./$.get-names":91,"./$.global":92,"./$.has":93,"./$.is-array":99,"./$.keyof":108,"./$.library":109,"./$.property-desc":114,"./$.redefine":116,"./$.set-to-string-tag":120,"./$.shared":121,"./$.to-iobject":127,"./$.uid":130,"./$.wks":131}],145:[function(require,module,exports){
// http://goo.gl/XkBrjD
var $export  = require('./$.export')
  , $entries = require('./$.object-to-array')(true);

$export($export.S, 'Object', {
  entries: function entries(it){
    return $entries(it);
  }
});
},{"./$.export":88,"./$.object-to-array":113}],146:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export  = require('./$.export');

$export($export.P, 'Set', {toJSON: require('./$.collection-to-json')('Set')});
},{"./$.collection-to-json":80,"./$.export":88}],147:[function(require,module,exports){
require('./es6.array.iterator');
var Iterators = require('./$.iterators');
Iterators.NodeList = Iterators.HTMLCollection = Iterators.Array;
},{"./$.iterators":106,"./es6.array.iterator":135}],148:[function(require,module,exports){
(function (global){
// This method of obtaining a reference to the global object needs to be
// kept identical to the way it is obtained in runtime.js
var g =
  typeof global === "object" ? global :
  typeof window === "object" ? window :
  typeof self === "object" ? self : this;

// Use `getOwnPropertyNames` because not all browsers support calling
// `hasOwnProperty` on the global `self` object in a worker. See #183.
var hadRuntime = g.regeneratorRuntime &&
  Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;

// Save the old regeneratorRuntime in case it needs to be restored later.
var oldRuntime = hadRuntime && g.regeneratorRuntime;

// Force reevalutation of runtime.js.
g.regeneratorRuntime = undefined;

module.exports = require("./runtime");

if (hadRuntime) {
  // Restore the original runtime.
  g.regeneratorRuntime = oldRuntime;
} else {
  // Remove the global property added by runtime.js.
  try {
    delete g.regeneratorRuntime;
  } catch(e) {
    g.regeneratorRuntime = undefined;
  }
}

module.exports = { "default": module.exports, __esModule: true };

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./runtime":149}],149:[function(require,module,exports){
(function (process,global){
/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */

"use strict";

var _Symbol = require("babel-runtime/core-js/symbol")["default"];

var _Object$create = require("babel-runtime/core-js/object/create")["default"];

var _Object$setPrototypeOf = require("babel-runtime/core-js/object/set-prototype-of")["default"];

var _Promise = require("babel-runtime/core-js/promise")["default"];

!(function (global) {
  "use strict";

  var hasOwn = Object.prototype.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof _Symbol === "function" ? _Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided, then outerFn.prototype instanceof Generator.
    var generator = _Object$create((outerFn || Generator).prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype;
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      prototype[method] = function (arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function (genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor ? ctor === GeneratorFunction ||
    // For the native GeneratorFunction constructor, the best we can
    // do is to check its .name property.
    (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
  };

  runtime.mark = function (genFun) {
    if (_Object$setPrototypeOf) {
      _Object$setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = _Object$create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `value instanceof AwaitArgument` to determine if the yielded value is
  // meant to be awaited. Some may consider the name of this method too
  // cutesy, but they are curmudgeons.
  runtime.awrap = function (arg) {
    return new AwaitArgument(arg);
  };

  function AwaitArgument(arg) {
    this.arg = arg;
  }

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value instanceof AwaitArgument) {
          return _Promise.resolve(value.arg).then(function (value) {
            invoke("next", value, resolve, reject);
          }, function (err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return _Promise.resolve(value).then(function (unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    if (typeof process === "object" && process.domain) {
      invoke = process.domain.bind(invoke);
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new _Promise(function (resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
      // If enqueue has been called before, then we want to wait until
      // all previous Promises have been resolved before calling invoke,
      // so that results are always delivered in the correct order. If
      // enqueue has not been called before, then it is important to
      // call invoke immediately, without waiting on a callback to fire,
      // so that the async generator function has the opportunity to do
      // any necessary setup in a predictable way. This predictability
      // is why the Promise constructor synchronously invokes its
      // executor callback, and why async functions synchronously
      // execute code before the first await. Since we implement simple
      // async functions in terms of async generators, it is especially
      // important to get this right, even though it requires care.
      previousPromise ? previousPromise.then(callInvokeWithMethodAndArg,
      // Avoid propagating failures to Promises returned by later
      // invocations of the iterator.
      callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function (innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList));

    return runtime.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
    : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          if (method === "return" || method === "throw" && delegate.iterator[method] === undefined) {
            // A return or throw (when the delegate iterator has no throw
            // method) always terminates the yield* loop.
            context.delegate = null;

            // If the delegate iterator has a return method, give it a
            // chance to clean up.
            var returnMethod = delegate.iterator["return"];
            if (returnMethod) {
              var record = tryCatch(returnMethod, delegate.iterator, arg);
              if (record.type === "throw") {
                // If the return method threw an exception, let that
                // exception prevail over the original return or throw.
                method = "throw";
                arg = record.arg;
                continue;
              }
            }

            if (method === "return") {
              // Continue with the outer return, now that the delegate
              // iterator has been terminated.
              continue;
            }
          }

          var record = tryCatch(delegate.iterator[method], delegate.iterator, arg);

          if (record.type === "throw") {
            context.delegate = null;

            // Like returning generator.throw(uncaught), but without the
            // overhead of an extra function call.
            method = "throw";
            arg = record.arg;
            continue;
          }

          // Delegate generator ran and handled its own exceptions so
          // regardless of what the method was, we continue as if it is
          // "next" with an undefined arg.
          method = "next";
          arg = undefined;

          var info = record.arg;
          if (info.done) {
            context[delegate.resultName] = info.value;
            context.next = delegate.nextLoc;
          } else {
            state = GenStateSuspendedYield;
            return info;
          }

          context.delegate = null;
        }

        if (method === "next") {
          if (state === GenStateSuspendedYield) {
            context.sent = arg;
          } else {
            context.sent = undefined;
          }
        } else if (method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw arg;
          }

          if (context.dispatchException(arg)) {
            // If the dispatched exception was caught by a catch block,
            // then let that catch block handle the exception normally.
            method = "next";
            arg = undefined;
          }
        } else if (method === "return") {
          context.abrupt("return", arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done ? GenStateCompleted : GenStateSuspendedYield;

          var info = {
            value: record.arg,
            done: context.done
          };

          if (record.arg === ContinueSentinel) {
            if (context.delegate && method === "next") {
              // Deliberately forget the last sent value so that we don't
              // accidentally pass it on to the delegate.
              arg = undefined;
            }
          } else {
            return info;
          }
        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(arg) call above.
          method = "throw";
          arg = record.arg;
        }
      }
    };
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[iteratorSymbol] = function () {
    return this;
  };

  Gp[toStringTagSymbol] = "Generator";

  Gp.toString = function () {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function (object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1,
            next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function reset(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      this.sent = undefined;
      this.done = false;
      this.delegate = null;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function stop() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function dispatchException(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;
        return !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }
          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function abrupt(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.next = finallyEntry.finallyLoc;
      } else {
        this.complete(record);
      }

      return ContinueSentinel;
    },

    complete: function complete(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" || record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = record.arg;
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }
    },

    finish: function finish(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function _catch(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function delegateYield(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      return ContinueSentinel;
    }
  };
})(
// Among the various tricks for obtaining a reference to the global
// object, this seems to be the most reliable technique that does not
// use indirect eval (which violates Content Security Policy).
typeof global === "object" ? global : typeof window === "object" ? window : typeof self === "object" ? self : undefined);
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"_process":351,"babel-runtime/core-js/object/create":48,"babel-runtime/core-js/object/set-prototype-of":53,"babel-runtime/core-js/promise":54,"babel-runtime/core-js/symbol":56}],150:[function(require,module,exports){
arguments[4][140][0].apply(exports,arguments)
},{"dup":140}],151:[function(require,module,exports){
(function (global){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('isarray')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192 // not used by this implementation

var rootParent = {}

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property
 *     on objects.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

function typedArraySupport () {
  function Bar () {}
  try {
    var arr = new Uint8Array(1)
    arr.foo = function () { return 42 }
    arr.constructor = Bar
    return arr.foo() === 42 && // typed array instances can be augmented
        arr.constructor === Bar && // constructor can be set
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (arg) {
  if (!(this instanceof Buffer)) {
    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.
    if (arguments.length > 1) return new Buffer(arg, arguments[1])
    return new Buffer(arg)
  }

  this.length = 0
  this.parent = undefined

  // Common case.
  if (typeof arg === 'number') {
    return fromNumber(this, arg)
  }

  // Slightly less common case.
  if (typeof arg === 'string') {
    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')
  }

  // Unusual.
  return fromObject(this, arg)
}

function fromNumber (that, length) {
  that = allocate(that, length < 0 ? 0 : checked(length) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < length; i++) {
      that[i] = 0
    }
  }
  return that
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'

  // Assumption: byteLength() return value is always < kMaxLength.
  var length = byteLength(string, encoding) | 0
  that = allocate(that, length)

  that.write(string, encoding)
  return that
}

function fromObject (that, object) {
  if (Buffer.isBuffer(object)) return fromBuffer(that, object)

  if (isArray(object)) return fromArray(that, object)

  if (object == null) {
    throw new TypeError('must start with number, buffer, array or string')
  }

  if (typeof ArrayBuffer !== 'undefined') {
    if (object.buffer instanceof ArrayBuffer) {
      return fromTypedArray(that, object)
    }
    if (object instanceof ArrayBuffer) {
      return fromArrayBuffer(that, object)
    }
  }

  if (object.length) return fromArrayLike(that, object)

  return fromJsonObject(that, object)
}

function fromBuffer (that, buffer) {
  var length = checked(buffer.length) | 0
  that = allocate(that, length)
  buffer.copy(that, 0, 0, length)
  return that
}

function fromArray (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

// Duplicate of fromArray() to keep fromArray() monomorphic.
function fromTypedArray (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  // Truncating the elements is probably not what people expect from typed
  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior
  // of the old Buffer constructor.
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array) {
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    array.byteLength
    that = Buffer._augment(new Uint8Array(array))
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromTypedArray(that, new Uint8Array(array))
  }
  return that
}

function fromArrayLike (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.
// Returns a zero-length buffer for inputs that don't conform to the spec.
function fromJsonObject (that, object) {
  var array
  var length = 0

  if (object.type === 'Buffer' && isArray(object.data)) {
    array = object.data
    length = checked(array.length) | 0
  }
  that = allocate(that, length)

  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
}

function allocate (that, length) {
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = Buffer._augment(new Uint8Array(length))
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that.length = length
    that._isBuffer = true
  }

  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1
  if (fromPool) that.parent = rootParent

  return that
}

function checked (length) {
  // Note: cannot use `length < kMaxLength` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (subject, encoding) {
  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)

  var buf = new Buffer(subject, encoding)
  delete buf.parent
  return buf
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  var i = 0
  var len = Math.min(x, y)
  while (i < len) {
    if (a[i] !== b[i]) break

    ++i
  }

  if (i !== len) {
    x = a[i]
    y = b[i]
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')

  if (list.length === 0) {
    return new Buffer(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; i++) {
      length += list[i].length
    }
  }

  var buf = new Buffer(length)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

function byteLength (string, encoding) {
  if (typeof string !== 'string') string = '' + string

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'binary':
      // Deprecated
      case 'raw':
      case 'raws':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

// pre-set for values that may exist in the future
Buffer.prototype.length = undefined
Buffer.prototype.parent = undefined

function slowToString (encoding, start, end) {
  var loweredCase = false

  start = start | 0
  end = end === undefined || end === Infinity ? this.length : end | 0

  if (!encoding) encoding = 'utf8'
  if (start < 0) start = 0
  if (end > this.length) end = this.length
  if (end <= start) return ''

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'binary':
        return binarySlice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return 0
  return Buffer.compare(this, b)
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset) {
  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff
  else if (byteOffset < -0x80000000) byteOffset = -0x80000000
  byteOffset >>= 0

  if (this.length === 0) return -1
  if (byteOffset >= this.length) return -1

  // Negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)

  if (typeof val === 'string') {
    if (val.length === 0) return -1 // special case: looking for empty string always fails
    return String.prototype.indexOf.call(this, val, byteOffset)
  }
  if (Buffer.isBuffer(val)) {
    return arrayIndexOf(this, val, byteOffset)
  }
  if (typeof val === 'number') {
    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
    }
    return arrayIndexOf(this, [ val ], byteOffset)
  }

  function arrayIndexOf (arr, val, byteOffset) {
    var foundIndex = -1
    for (var i = 0; byteOffset + i < arr.length; i++) {
      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex
      } else {
        foundIndex = -1
      }
    }
    return -1
  }

  throw new TypeError('val must be string, number or Buffer')
}

// `get` is deprecated
Buffer.prototype.get = function get (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` is deprecated
Buffer.prototype.set = function set (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) throw new Error('Invalid hex string')
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function binaryWrite (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    var swap = encoding
    encoding = offset
    offset = length | 0
    length = swap
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'binary':
        return binaryWrite(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function binarySlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
  }

  if (newBuf.length) newBuf.parent = this.parent || this

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('value is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = value < 0 ? 1 : 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = value < 0 ? 1 : 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (value > max || value < min) throw new RangeError('value is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('index out of range')
  if (offset < 0) throw new RangeError('index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; i--) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; i++) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    target._set(this.subarray(start, start + len), targetStart)
  }

  return len
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function fill (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (end < start) throw new RangeError('end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')
  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')

  var i
  if (typeof value === 'number') {
    for (i = start; i < end; i++) {
      this[i] = value
    }
  } else {
    var bytes = utf8ToBytes(value.toString())
    var len = bytes.length
    for (i = start; i < end; i++) {
      this[i] = bytes[i % len]
    }
  }

  return this
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function toArrayBuffer () {
  if (typeof Uint8Array !== 'undefined') {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1) {
        buf[i] = this[i]
      }
      return buf.buffer
    }
  } else {
    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function _augment (arr) {
  arr.constructor = Buffer
  arr._isBuffer = true

  // save reference to original Uint8Array set method before overwriting
  arr._set = arr.set

  // deprecated
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.equals = BP.equals
  arr.compare = BP.compare
  arr.indexOf = BP.indexOf
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUIntLE = BP.readUIntLE
  arr.readUIntBE = BP.readUIntBE
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readIntLE = BP.readIntLE
  arr.readIntBE = BP.readIntBE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUIntLE = BP.writeUIntLE
  arr.writeUIntBE = BP.writeUIntBE
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeIntLE = BP.writeIntLE
  arr.writeIntBE = BP.writeIntBE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; i++) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"base64-js":152,"ieee754":153,"isarray":154}],152:[function(require,module,exports){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)
	var PLUS_URL_SAFE = '-'.charCodeAt(0)
	var SLASH_URL_SAFE = '_'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS ||
		    code === PLUS_URL_SAFE)
			return 62 // '+'
		if (code === SLASH ||
		    code === SLASH_URL_SAFE)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

},{}],153:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],154:[function(require,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],155:[function(require,module,exports){
'use strict'

exports.randomBytes = exports.rng = exports.pseudoRandomBytes = exports.prng = require('randombytes')
exports.createHash = exports.Hash = require('create-hash')
exports.createHmac = exports.Hmac = require('create-hmac')

var hashes = ['sha1', 'sha224', 'sha256', 'sha384', 'sha512', 'md5', 'rmd160'].concat(Object.keys(require('browserify-sign/algos')))
exports.getHashes = function () {
  return hashes
}

var p = require('pbkdf2')
exports.pbkdf2 = p.pbkdf2
exports.pbkdf2Sync = p.pbkdf2Sync

var aes = require('browserify-cipher')
;[
  'Cipher',
  'createCipher',
  'Cipheriv',
  'createCipheriv',
  'Decipher',
  'createDecipher',
  'Decipheriv',
  'createDecipheriv',
  'getCiphers',
  'listCiphers'
].forEach(function (key) {
  exports[key] = aes[key]
})

var dh = require('diffie-hellman')
;[
  'DiffieHellmanGroup',
  'createDiffieHellmanGroup',
  'getDiffieHellman',
  'createDiffieHellman',
  'DiffieHellman'
].forEach(function (key) {
  exports[key] = dh[key]
})

var sign = require('browserify-sign')
;[
  'createSign',
  'Sign',
  'createVerify',
  'Verify'
].forEach(function (key) {
  exports[key] = sign[key]
})

exports.createECDH = require('create-ecdh')

var publicEncrypt = require('public-encrypt')

;[
  'publicEncrypt',
  'privateEncrypt',
  'publicDecrypt',
  'privateDecrypt'
].forEach(function (key) {
  exports[key] = publicEncrypt[key]
})

// the least I can do is make error messages for the rest of the node.js/crypto api.
;[
  'createCredentials'
].forEach(function (name) {
  exports[name] = function () {
    throw new Error([
      'sorry, ' + name + ' is not implemented yet',
      'we accept pull requests',
      'https://github.com/crypto-browserify/crypto-browserify'
    ].join('\n'))
  }
})

},{"browserify-cipher":156,"browserify-sign":186,"browserify-sign/algos":185,"create-ecdh":253,"create-hash":279,"create-hmac":292,"diffie-hellman":293,"pbkdf2":300,"public-encrypt":301,"randombytes":346}],156:[function(require,module,exports){
var ebtk = require('evp_bytestokey')
var aes = require('browserify-aes/browser')
var DES = require('browserify-des')
var desModes = require('browserify-des/modes')
var aesModes = require('browserify-aes/modes')
function createCipher (suite, password) {
  var keyLen, ivLen
  suite = suite.toLowerCase()
  if (aesModes[suite]) {
    keyLen = aesModes[suite].key
    ivLen = aesModes[suite].iv
  } else if (desModes[suite]) {
    keyLen = desModes[suite].key * 8
    ivLen = desModes[suite].iv
  } else {
    throw new TypeError('invalid suite type')
  }
  var keys = ebtk(password, false, keyLen, ivLen)
  return createCipheriv(suite, keys.key, keys.iv)
}
function createDecipher (suite, password) {
  var keyLen, ivLen
  suite = suite.toLowerCase()
  if (aesModes[suite]) {
    keyLen = aesModes[suite].key
    ivLen = aesModes[suite].iv
  } else if (desModes[suite]) {
    keyLen = desModes[suite].key * 8
    ivLen = desModes[suite].iv
  } else {
    throw new TypeError('invalid suite type')
  }
  var keys = ebtk(password, false, keyLen, ivLen)
  return createDecipheriv(suite, keys.key, keys.iv)
}

function createCipheriv (suite, key, iv) {
  suite = suite.toLowerCase()
  if (aesModes[suite]) {
    return aes.createCipheriv(suite, key, iv)
  } else if (desModes[suite]) {
    return new DES({
      key: key,
      iv: iv,
      mode: suite
    })
  } else {
    throw new TypeError('invalid suite type')
  }
}
function createDecipheriv (suite, key, iv) {
  suite = suite.toLowerCase()
  if (aesModes[suite]) {
    return aes.createDecipheriv(suite, key, iv)
  } else if (desModes[suite]) {
    return new DES({
      key: key,
      iv: iv,
      mode: suite,
      decrypt: true
    })
  } else {
    throw new TypeError('invalid suite type')
  }
}
exports.createCipher = exports.Cipher = createCipher
exports.createCipheriv = exports.Cipheriv = createCipheriv
exports.createDecipher = exports.Decipher = createDecipher
exports.createDecipheriv = exports.Decipheriv = createDecipheriv
function getCiphers () {
  return Object.keys(desModes).concat(aes.getCiphers())
}
exports.listCiphers = exports.getCiphers = getCiphers

},{"browserify-aes/browser":159,"browserify-aes/modes":163,"browserify-des":174,"browserify-des/modes":175,"evp_bytestokey":184}],157:[function(require,module,exports){
(function (Buffer){
// based on the aes implimentation in triple sec
// https://github.com/keybase/triplesec

// which is in turn based on the one from crypto-js
// https://code.google.com/p/crypto-js/

var uint_max = Math.pow(2, 32)
function fixup_uint32 (x) {
  var ret, x_pos
  ret = x > uint_max || x < 0 ? (x_pos = Math.abs(x) % uint_max, x < 0 ? uint_max - x_pos : x_pos) : x
  return ret
}
function scrub_vec (v) {
  for (var i = 0; i < v.length; v++) {
    v[i] = 0
  }
  return false
}

function Global () {
  this.SBOX = []
  this.INV_SBOX = []
  this.SUB_MIX = [[], [], [], []]
  this.INV_SUB_MIX = [[], [], [], []]
  this.init()
  this.RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36]
}

Global.prototype.init = function () {
  var d, i, sx, t, x, x2, x4, x8, xi, _i
  d = (function () {
    var _i, _results
    _results = []
    for (i = _i = 0; _i < 256; i = ++_i) {
      if (i < 128) {
        _results.push(i << 1)
      } else {
        _results.push((i << 1) ^ 0x11b)
      }
    }
    return _results
  })()
  x = 0
  xi = 0
  for (i = _i = 0; _i < 256; i = ++_i) {
    sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4)
    sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63
    this.SBOX[x] = sx
    this.INV_SBOX[sx] = x
    x2 = d[x]
    x4 = d[x2]
    x8 = d[x4]
    t = (d[sx] * 0x101) ^ (sx * 0x1010100)
    this.SUB_MIX[0][x] = (t << 24) | (t >>> 8)
    this.SUB_MIX[1][x] = (t << 16) | (t >>> 16)
    this.SUB_MIX[2][x] = (t << 8) | (t >>> 24)
    this.SUB_MIX[3][x] = t
    t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100)
    this.INV_SUB_MIX[0][sx] = (t << 24) | (t >>> 8)
    this.INV_SUB_MIX[1][sx] = (t << 16) | (t >>> 16)
    this.INV_SUB_MIX[2][sx] = (t << 8) | (t >>> 24)
    this.INV_SUB_MIX[3][sx] = t
    if (x === 0) {
      x = xi = 1
    } else {
      x = x2 ^ d[d[d[x8 ^ x2]]]
      xi ^= d[d[xi]]
    }
  }
  return true
}

var G = new Global()

AES.blockSize = 4 * 4

AES.prototype.blockSize = AES.blockSize

AES.keySize = 256 / 8

AES.prototype.keySize = AES.keySize

function bufferToArray (buf) {
  var len = buf.length / 4
  var out = new Array(len)
  var i = -1
  while (++i < len) {
    out[i] = buf.readUInt32BE(i * 4)
  }
  return out
}
function AES (key) {
  this._key = bufferToArray(key)
  this._doReset()
}

AES.prototype._doReset = function () {
  var invKsRow, keySize, keyWords, ksRow, ksRows, t
  keyWords = this._key
  keySize = keyWords.length
  this._nRounds = keySize + 6
  ksRows = (this._nRounds + 1) * 4
  this._keySchedule = []
  for (ksRow = 0; ksRow < ksRows; ksRow++) {
    this._keySchedule[ksRow] = ksRow < keySize ? keyWords[ksRow] : (t = this._keySchedule[ksRow - 1], (ksRow % keySize) === 0 ? (t = (t << 8) | (t >>> 24), t = (G.SBOX[t >>> 24] << 24) | (G.SBOX[(t >>> 16) & 0xff] << 16) | (G.SBOX[(t >>> 8) & 0xff] << 8) | G.SBOX[t & 0xff], t ^= G.RCON[(ksRow / keySize) | 0] << 24) : keySize > 6 && ksRow % keySize === 4 ? t = (G.SBOX[t >>> 24] << 24) | (G.SBOX[(t >>> 16) & 0xff] << 16) | (G.SBOX[(t >>> 8) & 0xff] << 8) | G.SBOX[t & 0xff] : void 0, this._keySchedule[ksRow - keySize] ^ t)
  }
  this._invKeySchedule = []
  for (invKsRow = 0; invKsRow < ksRows; invKsRow++) {
    ksRow = ksRows - invKsRow
    t = this._keySchedule[ksRow - (invKsRow % 4 ? 0 : 4)]
    this._invKeySchedule[invKsRow] = invKsRow < 4 || ksRow <= 4 ? t : G.INV_SUB_MIX[0][G.SBOX[t >>> 24]] ^ G.INV_SUB_MIX[1][G.SBOX[(t >>> 16) & 0xff]] ^ G.INV_SUB_MIX[2][G.SBOX[(t >>> 8) & 0xff]] ^ G.INV_SUB_MIX[3][G.SBOX[t & 0xff]]
  }
  return true
}

AES.prototype.encryptBlock = function (M) {
  M = bufferToArray(new Buffer(M))
  var out = this._doCryptBlock(M, this._keySchedule, G.SUB_MIX, G.SBOX)
  var buf = new Buffer(16)
  buf.writeUInt32BE(out[0], 0)
  buf.writeUInt32BE(out[1], 4)
  buf.writeUInt32BE(out[2], 8)
  buf.writeUInt32BE(out[3], 12)
  return buf
}

AES.prototype.decryptBlock = function (M) {
  M = bufferToArray(new Buffer(M))
  var temp = [M[3], M[1]]
  M[1] = temp[0]
  M[3] = temp[1]
  var out = this._doCryptBlock(M, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX)
  var buf = new Buffer(16)
  buf.writeUInt32BE(out[0], 0)
  buf.writeUInt32BE(out[3], 4)
  buf.writeUInt32BE(out[2], 8)
  buf.writeUInt32BE(out[1], 12)
  return buf
}

AES.prototype.scrub = function () {
  scrub_vec(this._keySchedule)
  scrub_vec(this._invKeySchedule)
  scrub_vec(this._key)
}

AES.prototype._doCryptBlock = function (M, keySchedule, SUB_MIX, SBOX) {
  var ksRow, s0, s1, s2, s3, t0, t1, t2, t3

  s0 = M[0] ^ keySchedule[0]
  s1 = M[1] ^ keySchedule[1]
  s2 = M[2] ^ keySchedule[2]
  s3 = M[3] ^ keySchedule[3]
  ksRow = 4
  for (var round = 1; round < this._nRounds; round++) {
    t0 = SUB_MIX[0][s0 >>> 24] ^ SUB_MIX[1][(s1 >>> 16) & 0xff] ^ SUB_MIX[2][(s2 >>> 8) & 0xff] ^ SUB_MIX[3][s3 & 0xff] ^ keySchedule[ksRow++]
    t1 = SUB_MIX[0][s1 >>> 24] ^ SUB_MIX[1][(s2 >>> 16) & 0xff] ^ SUB_MIX[2][(s3 >>> 8) & 0xff] ^ SUB_MIX[3][s0 & 0xff] ^ keySchedule[ksRow++]
    t2 = SUB_MIX[0][s2 >>> 24] ^ SUB_MIX[1][(s3 >>> 16) & 0xff] ^ SUB_MIX[2][(s0 >>> 8) & 0xff] ^ SUB_MIX[3][s1 & 0xff] ^ keySchedule[ksRow++]
    t3 = SUB_MIX[0][s3 >>> 24] ^ SUB_MIX[1][(s0 >>> 16) & 0xff] ^ SUB_MIX[2][(s1 >>> 8) & 0xff] ^ SUB_MIX[3][s2 & 0xff] ^ keySchedule[ksRow++]
    s0 = t0
    s1 = t1
    s2 = t2
    s3 = t3
  }
  t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++]
  t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++]
  t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++]
  t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++]
  return [
    fixup_uint32(t0),
    fixup_uint32(t1),
    fixup_uint32(t2),
    fixup_uint32(t3)
  ]
}

exports.AES = AES

}).call(this,require("buffer").Buffer)

},{"buffer":151}],158:[function(require,module,exports){
(function (Buffer){
var aes = require('./aes')
var Transform = require('cipher-base')
var inherits = require('inherits')
var GHASH = require('./ghash')
var xor = require('buffer-xor')
inherits(StreamCipher, Transform)
module.exports = StreamCipher

function StreamCipher (mode, key, iv, decrypt) {
  if (!(this instanceof StreamCipher)) {
    return new StreamCipher(mode, key, iv)
  }
  Transform.call(this)
  this._finID = Buffer.concat([iv, new Buffer([0, 0, 0, 1])])
  iv = Buffer.concat([iv, new Buffer([0, 0, 0, 2])])
  this._cipher = new aes.AES(key)
  this._prev = new Buffer(iv.length)
  this._cache = new Buffer('')
  this._secCache = new Buffer('')
  this._decrypt = decrypt
  this._alen = 0
  this._len = 0
  iv.copy(this._prev)
  this._mode = mode
  var h = new Buffer(4)
  h.fill(0)
  this._ghash = new GHASH(this._cipher.encryptBlock(h))
  this._authTag = null
  this._called = false
}
StreamCipher.prototype._update = function (chunk) {
  if (!this._called && this._alen) {
    var rump = 16 - (this._alen % 16)
    if (rump < 16) {
      rump = new Buffer(rump)
      rump.fill(0)
      this._ghash.update(rump)
    }
  }
  this._called = true
  var out = this._mode.encrypt(this, chunk)
  if (this._decrypt) {
    this._ghash.update(chunk)
  } else {
    this._ghash.update(out)
  }
  this._len += chunk.length
  return out
}
StreamCipher.prototype._final = function () {
  if (this._decrypt && !this._authTag) {
    throw new Error('Unsupported state or unable to authenticate data')
  }
  var tag = xor(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID))
  if (this._decrypt) {
    if (xorTest(tag, this._authTag)) {
      throw new Error('Unsupported state or unable to authenticate data')
    }
  } else {
    this._authTag = tag
  }
  this._cipher.scrub()
}
StreamCipher.prototype.getAuthTag = function getAuthTag () {
  if (!this._decrypt && Buffer.isBuffer(this._authTag)) {
    return this._authTag
  } else {
    throw new Error('Attempting to get auth tag in unsupported state')
  }
}
StreamCipher.prototype.setAuthTag = function setAuthTag (tag) {
  if (this._decrypt) {
    this._authTag = tag
  } else {
    throw new Error('Attempting to set auth tag in unsupported state')
  }
}
StreamCipher.prototype.setAAD = function setAAD (buf) {
  if (!this._called) {
    this._ghash.update(buf)
    this._alen += buf.length
  } else {
    throw new Error('Attempting to set AAD in unsupported state')
  }
}
function xorTest (a, b) {
  var out = 0
  if (a.length !== b.length) {
    out++
  }
  var len = Math.min(a.length, b.length)
  var i = -1
  while (++i < len) {
    out += (a[i] ^ b[i])
  }
  return out
}

}).call(this,require("buffer").Buffer)

},{"./aes":157,"./ghash":162,"buffer":151,"buffer-xor":171,"cipher-base":172,"inherits":348}],159:[function(require,module,exports){
var ciphers = require('./encrypter')
exports.createCipher = exports.Cipher = ciphers.createCipher
exports.createCipheriv = exports.Cipheriv = ciphers.createCipheriv
var deciphers = require('./decrypter')
exports.createDecipher = exports.Decipher = deciphers.createDecipher
exports.createDecipheriv = exports.Decipheriv = deciphers.createDecipheriv
var modes = require('./modes')
function getCiphers () {
  return Object.keys(modes)
}
exports.listCiphers = exports.getCiphers = getCiphers

},{"./decrypter":160,"./encrypter":161,"./modes":163}],160:[function(require,module,exports){
(function (Buffer){
var aes = require('./aes')
var Transform = require('cipher-base')
var inherits = require('inherits')
var modes = require('./modes')
var StreamCipher = require('./streamCipher')
var AuthCipher = require('./authCipher')
var ebtk = require('evp_bytestokey')

inherits(Decipher, Transform)
function Decipher (mode, key, iv) {
  if (!(this instanceof Decipher)) {
    return new Decipher(mode, key, iv)
  }
  Transform.call(this)
  this._cache = new Splitter()
  this._last = void 0
  this._cipher = new aes.AES(key)
  this._prev = new Buffer(iv.length)
  iv.copy(this._prev)
  this._mode = mode
  this._autopadding = true
}
Decipher.prototype._update = function (data) {
  this._cache.add(data)
  var chunk
  var thing
  var out = []
  while ((chunk = this._cache.get(this._autopadding))) {
    thing = this._mode.decrypt(this, chunk)
    out.push(thing)
  }
  return Buffer.concat(out)
}
Decipher.prototype._final = function () {
  var chunk = this._cache.flush()
  if (this._autopadding) {
    return unpad(this._mode.decrypt(this, chunk))
  } else if (chunk) {
    throw new Error('data not multiple of block length')
  }
}
Decipher.prototype.setAutoPadding = function (setTo) {
  this._autopadding = !!setTo
}
function Splitter () {
  if (!(this instanceof Splitter)) {
    return new Splitter()
  }
  this.cache = new Buffer('')
}
Splitter.prototype.add = function (data) {
  this.cache = Buffer.concat([this.cache, data])
}

Splitter.prototype.get = function (autoPadding) {
  var out
  if (autoPadding) {
    if (this.cache.length > 16) {
      out = this.cache.slice(0, 16)
      this.cache = this.cache.slice(16)
      return out
    }
  } else {
    if (this.cache.length >= 16) {
      out = this.cache.slice(0, 16)
      this.cache = this.cache.slice(16)
      return out
    }
  }
  return null
}
Splitter.prototype.flush = function () {
  if (this.cache.length) {
    return this.cache
  }
}
function unpad (last) {
  var padded = last[15]
  var i = -1
  while (++i < padded) {
    if (last[(i + (16 - padded))] !== padded) {
      throw new Error('unable to decrypt data')
    }
  }
  if (padded === 16) {
    return
  }
  return last.slice(0, 16 - padded)
}

var modelist = {
  ECB: require('./modes/ecb'),
  CBC: require('./modes/cbc'),
  CFB: require('./modes/cfb'),
  CFB8: require('./modes/cfb8'),
  CFB1: require('./modes/cfb1'),
  OFB: require('./modes/ofb'),
  CTR: require('./modes/ctr'),
  GCM: require('./modes/ctr')
}

function createDecipheriv (suite, password, iv) {
  var config = modes[suite.toLowerCase()]
  if (!config) {
    throw new TypeError('invalid suite type')
  }
  if (typeof iv === 'string') {
    iv = new Buffer(iv)
  }
  if (typeof password === 'string') {
    password = new Buffer(password)
  }
  if (password.length !== config.key / 8) {
    throw new TypeError('invalid key length ' + password.length)
  }
  if (iv.length !== config.iv) {
    throw new TypeError('invalid iv length ' + iv.length)
  }
  if (config.type === 'stream') {
    return new StreamCipher(modelist[config.mode], password, iv, true)
  } else if (config.type === 'auth') {
    return new AuthCipher(modelist[config.mode], password, iv, true)
  }
  return new Decipher(modelist[config.mode], password, iv)
}

function createDecipher (suite, password) {
  var config = modes[suite.toLowerCase()]
  if (!config) {
    throw new TypeError('invalid suite type')
  }
  var keys = ebtk(password, false, config.key, config.iv)
  return createDecipheriv(suite, keys.key, keys.iv)
}
exports.createDecipher = createDecipher
exports.createDecipheriv = createDecipheriv

}).call(this,require("buffer").Buffer)

},{"./aes":157,"./authCipher":158,"./modes":163,"./modes/cbc":164,"./modes/cfb":165,"./modes/cfb1":166,"./modes/cfb8":167,"./modes/ctr":168,"./modes/ecb":169,"./modes/ofb":170,"./streamCipher":173,"buffer":151,"cipher-base":172,"evp_bytestokey":184,"inherits":348}],161:[function(require,module,exports){
(function (Buffer){
var aes = require('./aes')
var Transform = require('cipher-base')
var inherits = require('inherits')
var modes = require('./modes')
var ebtk = require('evp_bytestokey')
var StreamCipher = require('./streamCipher')
var AuthCipher = require('./authCipher')
inherits(Cipher, Transform)
function Cipher (mode, key, iv) {
  if (!(this instanceof Cipher)) {
    return new Cipher(mode, key, iv)
  }
  Transform.call(this)
  this._cache = new Splitter()
  this._cipher = new aes.AES(key)
  this._prev = new Buffer(iv.length)
  iv.copy(this._prev)
  this._mode = mode
  this._autopadding = true
}
Cipher.prototype._update = function (data) {
  this._cache.add(data)
  var chunk
  var thing
  var out = []
  while ((chunk = this._cache.get())) {
    thing = this._mode.encrypt(this, chunk)
    out.push(thing)
  }
  return Buffer.concat(out)
}
Cipher.prototype._final = function () {
  var chunk = this._cache.flush()
  if (this._autopadding) {
    chunk = this._mode.encrypt(this, chunk)
    this._cipher.scrub()
    return chunk
  } else if (chunk.toString('hex') !== '10101010101010101010101010101010') {
    this._cipher.scrub()
    throw new Error('data not multiple of block length')
  }
}
Cipher.prototype.setAutoPadding = function (setTo) {
  this._autopadding = !!setTo
}

function Splitter () {
  if (!(this instanceof Splitter)) {
    return new Splitter()
  }
  this.cache = new Buffer('')
}
Splitter.prototype.add = function (data) {
  this.cache = Buffer.concat([this.cache, data])
}

Splitter.prototype.get = function () {
  if (this.cache.length > 15) {
    var out = this.cache.slice(0, 16)
    this.cache = this.cache.slice(16)
    return out
  }
  return null
}
Splitter.prototype.flush = function () {
  var len = 16 - this.cache.length
  var padBuff = new Buffer(len)

  var i = -1
  while (++i < len) {
    padBuff.writeUInt8(len, i)
  }
  var out = Buffer.concat([this.cache, padBuff])
  return out
}
var modelist = {
  ECB: require('./modes/ecb'),
  CBC: require('./modes/cbc'),
  CFB: require('./modes/cfb'),
  CFB8: require('./modes/cfb8'),
  CFB1: require('./modes/cfb1'),
  OFB: require('./modes/ofb'),
  CTR: require('./modes/ctr'),
  GCM: require('./modes/ctr')
}

function createCipheriv (suite, password, iv) {
  var config = modes[suite.toLowerCase()]
  if (!config) {
    throw new TypeError('invalid suite type')
  }
  if (typeof iv === 'string') {
    iv = new Buffer(iv)
  }
  if (typeof password === 'string') {
    password = new Buffer(password)
  }
  if (password.length !== config.key / 8) {
    throw new TypeError('invalid key length ' + password.length)
  }
  if (iv.length !== config.iv) {
    throw new TypeError('invalid iv length ' + iv.length)
  }
  if (config.type === 'stream') {
    return new StreamCipher(modelist[config.mode], password, iv)
  } else if (config.type === 'auth') {
    return new AuthCipher(modelist[config.mode], password, iv)
  }
  return new Cipher(modelist[config.mode], password, iv)
}
function createCipher (suite, password) {
  var config = modes[suite.toLowerCase()]
  if (!config) {
    throw new TypeError('invalid suite type')
  }
  var keys = ebtk(password, false, config.key, config.iv)
  return createCipheriv(suite, keys.key, keys.iv)
}

exports.createCipheriv = createCipheriv
exports.createCipher = createCipher

}).call(this,require("buffer").Buffer)

},{"./aes":157,"./authCipher":158,"./modes":163,"./modes/cbc":164,"./modes/cfb":165,"./modes/cfb1":166,"./modes/cfb8":167,"./modes/ctr":168,"./modes/ecb":169,"./modes/ofb":170,"./streamCipher":173,"buffer":151,"cipher-base":172,"evp_bytestokey":184,"inherits":348}],162:[function(require,module,exports){
(function (Buffer){
var zeros = new Buffer(16)
zeros.fill(0)
module.exports = GHASH
function GHASH (key) {
  this.h = key
  this.state = new Buffer(16)
  this.state.fill(0)
  this.cache = new Buffer('')
}
// from http://bitwiseshiftleft.github.io/sjcl/doc/symbols/src/core_gcm.js.html
// by Juho Vähä-Herttua
GHASH.prototype.ghash = function (block) {
  var i = -1
  while (++i < block.length) {
    this.state[i] ^= block[i]
  }
  this._multiply()
}

GHASH.prototype._multiply = function () {
  var Vi = toArray(this.h)
  var Zi = [0, 0, 0, 0]
  var j, xi, lsb_Vi
  var i = -1
  while (++i < 128) {
    xi = (this.state[~~(i / 8)] & (1 << (7 - i % 8))) !== 0
    if (xi) {
      // Z_i+1 = Z_i ^ V_i
      Zi = xor(Zi, Vi)
    }

    // Store the value of LSB(V_i)
    lsb_Vi = (Vi[3] & 1) !== 0

    // V_i+1 = V_i >> 1
    for (j = 3; j > 0; j--) {
      Vi[j] = (Vi[j] >>> 1) | ((Vi[j - 1] & 1) << 31)
    }
    Vi[0] = Vi[0] >>> 1

    // If LSB(V_i) is 1, V_i+1 = (V_i >> 1) ^ R
    if (lsb_Vi) {
      Vi[0] = Vi[0] ^ (0xe1 << 24)
    }
  }
  this.state = fromArray(Zi)
}
GHASH.prototype.update = function (buf) {
  this.cache = Buffer.concat([this.cache, buf])
  var chunk
  while (this.cache.length >= 16) {
    chunk = this.cache.slice(0, 16)
    this.cache = this.cache.slice(16)
    this.ghash(chunk)
  }
}
GHASH.prototype.final = function (abl, bl) {
  if (this.cache.length) {
    this.ghash(Buffer.concat([this.cache, zeros], 16))
  }
  this.ghash(fromArray([
    0, abl,
    0, bl
  ]))
  return this.state
}

function toArray (buf) {
  return [
    buf.readUInt32BE(0),
    buf.readUInt32BE(4),
    buf.readUInt32BE(8),
    buf.readUInt32BE(12)
  ]
}
function fromArray (out) {
  out = out.map(fixup_uint32)
  var buf = new Buffer(16)
  buf.writeUInt32BE(out[0], 0)
  buf.writeUInt32BE(out[1], 4)
  buf.writeUInt32BE(out[2], 8)
  buf.writeUInt32BE(out[3], 12)
  return buf
}
var uint_max = Math.pow(2, 32)
function fixup_uint32 (x) {
  var ret, x_pos
  ret = x > uint_max || x < 0 ? (x_pos = Math.abs(x) % uint_max, x < 0 ? uint_max - x_pos : x_pos) : x
  return ret
}
function xor (a, b) {
  return [
    a[0] ^ b[0],
    a[1] ^ b[1],
    a[2] ^ b[2],
    a[3] ^ b[3]
  ]
}

}).call(this,require("buffer").Buffer)

},{"buffer":151}],163:[function(require,module,exports){
exports['aes-128-ecb'] = {
  cipher: 'AES',
  key: 128,
  iv: 0,
  mode: 'ECB',
  type: 'block'
}
exports['aes-192-ecb'] = {
  cipher: 'AES',
  key: 192,
  iv: 0,
  mode: 'ECB',
  type: 'block'
}
exports['aes-256-ecb'] = {
  cipher: 'AES',
  key: 256,
  iv: 0,
  mode: 'ECB',
  type: 'block'
}
exports['aes-128-cbc'] = {
  cipher: 'AES',
  key: 128,
  iv: 16,
  mode: 'CBC',
  type: 'block'
}
exports['aes-192-cbc'] = {
  cipher: 'AES',
  key: 192,
  iv: 16,
  mode: 'CBC',
  type: 'block'
}
exports['aes-256-cbc'] = {
  cipher: 'AES',
  key: 256,
  iv: 16,
  mode: 'CBC',
  type: 'block'
}
exports['aes128'] = exports['aes-128-cbc']
exports['aes192'] = exports['aes-192-cbc']
exports['aes256'] = exports['aes-256-cbc']
exports['aes-128-cfb'] = {
  cipher: 'AES',
  key: 128,
  iv: 16,
  mode: 'CFB',
  type: 'stream'
}
exports['aes-192-cfb'] = {
  cipher: 'AES',
  key: 192,
  iv: 16,
  mode: 'CFB',
  type: 'stream'
}
exports['aes-256-cfb'] = {
  cipher: 'AES',
  key: 256,
  iv: 16,
  mode: 'CFB',
  type: 'stream'
}
exports['aes-128-cfb8'] = {
  cipher: 'AES',
  key: 128,
  iv: 16,
  mode: 'CFB8',
  type: 'stream'
}
exports['aes-192-cfb8'] = {
  cipher: 'AES',
  key: 192,
  iv: 16,
  mode: 'CFB8',
  type: 'stream'
}
exports['aes-256-cfb8'] = {
  cipher: 'AES',
  key: 256,
  iv: 16,
  mode: 'CFB8',
  type: 'stream'
}
exports['aes-128-cfb1'] = {
  cipher: 'AES',
  key: 128,
  iv: 16,
  mode: 'CFB1',
  type: 'stream'
}
exports['aes-192-cfb1'] = {
  cipher: 'AES',
  key: 192,
  iv: 16,
  mode: 'CFB1',
  type: 'stream'
}
exports['aes-256-cfb1'] = {
  cipher: 'AES',
  key: 256,
  iv: 16,
  mode: 'CFB1',
  type: 'stream'
}
exports['aes-128-ofb'] = {
  cipher: 'AES',
  key: 128,
  iv: 16,
  mode: 'OFB',
  type: 'stream'
}
exports['aes-192-ofb'] = {
  cipher: 'AES',
  key: 192,
  iv: 16,
  mode: 'OFB',
  type: 'stream'
}
exports['aes-256-ofb'] = {
  cipher: 'AES',
  key: 256,
  iv: 16,
  mode: 'OFB',
  type: 'stream'
}
exports['aes-128-ctr'] = {
  cipher: 'AES',
  key: 128,
  iv: 16,
  mode: 'CTR',
  type: 'stream'
}
exports['aes-192-ctr'] = {
  cipher: 'AES',
  key: 192,
  iv: 16,
  mode: 'CTR',
  type: 'stream'
}
exports['aes-256-ctr'] = {
  cipher: 'AES',
  key: 256,
  iv: 16,
  mode: 'CTR',
  type: 'stream'
}
exports['aes-128-gcm'] = {
  cipher: 'AES',
  key: 128,
  iv: 12,
  mode: 'GCM',
  type: 'auth'
}
exports['aes-192-gcm'] = {
  cipher: 'AES',
  key: 192,
  iv: 12,
  mode: 'GCM',
  type: 'auth'
}
exports['aes-256-gcm'] = {
  cipher: 'AES',
  key: 256,
  iv: 12,
  mode: 'GCM',
  type: 'auth'
}

},{}],164:[function(require,module,exports){
var xor = require('buffer-xor')

exports.encrypt = function (self, block) {
  var data = xor(block, self._prev)

  self._prev = self._cipher.encryptBlock(data)
  return self._prev
}

exports.decrypt = function (self, block) {
  var pad = self._prev

  self._prev = block
  var out = self._cipher.decryptBlock(block)

  return xor(out, pad)
}

},{"buffer-xor":171}],165:[function(require,module,exports){
(function (Buffer){
var xor = require('buffer-xor')

exports.encrypt = function (self, data, decrypt) {
  var out = new Buffer('')
  var len

  while (data.length) {
    if (self._cache.length === 0) {
      self._cache = self._cipher.encryptBlock(self._prev)
      self._prev = new Buffer('')
    }

    if (self._cache.length <= data.length) {
      len = self._cache.length
      out = Buffer.concat([out, encryptStart(self, data.slice(0, len), decrypt)])
      data = data.slice(len)
    } else {
      out = Buffer.concat([out, encryptStart(self, data, decrypt)])
      break
    }
  }

  return out
}
function encryptStart (self, data, decrypt) {
  var len = data.length
  var out = xor(data, self._cache)
  self._cache = self._cache.slice(len)
  self._prev = Buffer.concat([self._prev, decrypt ? data : out])
  return out
}

}).call(this,require("buffer").Buffer)

},{"buffer":151,"buffer-xor":171}],166:[function(require,module,exports){
(function (Buffer){
function encryptByte (self, byteParam, decrypt) {
  var pad
  var i = -1
  var len = 8
  var out = 0
  var bit, value
  while (++i < len) {
    pad = self._cipher.encryptBlock(self._prev)
    bit = (byteParam & (1 << (7 - i))) ? 0x80 : 0
    value = pad[0] ^ bit
    out += ((value & 0x80) >> (i % 8))
    self._prev = shiftIn(self._prev, decrypt ? bit : value)
  }
  return out
}
exports.encrypt = function (self, chunk, decrypt) {
  var len = chunk.length
  var out = new Buffer(len)
  var i = -1
  while (++i < len) {
    out[i] = encryptByte(self, chunk[i], decrypt)
  }
  return out
}
function shiftIn (buffer, value) {
  var len = buffer.length
  var i = -1
  var out = new Buffer(buffer.length)
  buffer = Buffer.concat([buffer, new Buffer([value])])
  while (++i < len) {
    out[i] = buffer[i] << 1 | buffer[i + 1] >> (7)
  }
  return out
}

}).call(this,require("buffer").Buffer)

},{"buffer":151}],167:[function(require,module,exports){
(function (Buffer){
function encryptByte (self, byteParam, decrypt) {
  var pad = self._cipher.encryptBlock(self._prev)
  var out = pad[0] ^ byteParam
  self._prev = Buffer.concat([self._prev.slice(1), new Buffer([decrypt ? byteParam : out])])
  return out
}
exports.encrypt = function (self, chunk, decrypt) {
  var len = chunk.length
  var out = new Buffer(len)
  var i = -1
  while (++i < len) {
    out[i] = encryptByte(self, chunk[i], decrypt)
  }
  return out
}

}).call(this,require("buffer").Buffer)

},{"buffer":151}],168:[function(require,module,exports){
(function (Buffer){
var xor = require('buffer-xor')

function incr32 (iv) {
  var len = iv.length
  var item
  while (len--) {
    item = iv.readUInt8(len)
    if (item === 255) {
      iv.writeUInt8(0, len)
    } else {
      item++
      iv.writeUInt8(item, len)
      break
    }
  }
}

function getBlock (self) {
  var out = self._cipher.encryptBlock(self._prev)
  incr32(self._prev)
  return out
}

exports.encrypt = function (self, chunk) {
  while (self._cache.length < chunk.length) {
    self._cache = Buffer.concat([self._cache, getBlock(self)])
  }
  var pad = self._cache.slice(0, chunk.length)
  self._cache = self._cache.slice(chunk.length)
  return xor(chunk, pad)
}

}).call(this,require("buffer").Buffer)

},{"buffer":151,"buffer-xor":171}],169:[function(require,module,exports){
exports.encrypt = function (self, block) {
  return self._cipher.encryptBlock(block)
}
exports.decrypt = function (self, block) {
  return self._cipher.decryptBlock(block)
}

},{}],170:[function(require,module,exports){
(function (Buffer){
var xor = require('buffer-xor')

function getBlock (self) {
  self._prev = self._cipher.encryptBlock(self._prev)
  return self._prev
}

exports.encrypt = function (self, chunk) {
  while (self._cache.length < chunk.length) {
    self._cache = Buffer.concat([self._cache, getBlock(self)])
  }

  var pad = self._cache.slice(0, chunk.length)
  self._cache = self._cache.slice(chunk.length)
  return xor(chunk, pad)
}

}).call(this,require("buffer").Buffer)

},{"buffer":151,"buffer-xor":171}],171:[function(require,module,exports){
(function (Buffer){
module.exports = function xor (a, b) {
  var length = Math.min(a.length, b.length)
  var buffer = new Buffer(length)

  for (var i = 0; i < length; ++i) {
    buffer[i] = a[i] ^ b[i]
  }

  return buffer
}

}).call(this,require("buffer").Buffer)

},{"buffer":151}],172:[function(require,module,exports){
(function (Buffer){
var Transform = require('stream').Transform
var inherits = require('inherits')
var StringDecoder = require('string_decoder').StringDecoder
module.exports = CipherBase
inherits(CipherBase, Transform)
function CipherBase (hashMode) {
  Transform.call(this)
  this.hashMode = typeof hashMode === 'string'
  if (this.hashMode) {
    this[hashMode] = this._finalOrDigest
  } else {
    this.final = this._finalOrDigest
  }
  this._decoder = null
  this._encoding = null
}
CipherBase.prototype.update = function (data, inputEnc, outputEnc) {
  if (typeof data === 'string') {
    data = new Buffer(data, inputEnc)
  }
  var outData = this._update(data)
  if (this.hashMode) {
    return this
  }
  if (outputEnc) {
    outData = this._toString(outData, outputEnc)
  }
  return outData
}

CipherBase.prototype.setAutoPadding = function () {}

CipherBase.prototype.getAuthTag = function () {
  throw new Error('trying to get auth tag in unsupported state')
}

CipherBase.prototype.setAuthTag = function () {
  throw new Error('trying to set auth tag in unsupported state')
}

CipherBase.prototype.setAAD = function () {
  throw new Error('trying to set aad in unsupported state')
}

CipherBase.prototype._transform = function (data, _, next) {
  var err
  try {
    if (this.hashMode) {
      this._update(data)
    } else {
      this.push(this._update(data))
    }
  } catch (e) {
    err = e
  } finally {
    next(err)
  }
}
CipherBase.prototype._flush = function (done) {
  var err
  try {
    this.push(this._final())
  } catch (e) {
    err = e
  } finally {
    done(err)
  }
}
CipherBase.prototype._finalOrDigest = function (outputEnc) {
  var outData = this._final() || new Buffer('')
  if (outputEnc) {
    outData = this._toString(outData, outputEnc, true)
  }
  return outData
}

CipherBase.prototype._toString = function (value, enc, final) {
  if (!this._decoder) {
    this._decoder = new StringDecoder(enc)
    this._encoding = enc
  }
  if (this._encoding !== enc) {
    throw new Error('can\'t switch encodings')
  }
  var out = this._decoder.write(value)
  if (final) {
    out += this._decoder.end()
  }
  return out
}

}).call(this,require("buffer").Buffer)

},{"buffer":151,"inherits":348,"stream":365,"string_decoder":366}],173:[function(require,module,exports){
(function (Buffer){
var aes = require('./aes')
var Transform = require('cipher-base')
var inherits = require('inherits')

inherits(StreamCipher, Transform)
module.exports = StreamCipher
function StreamCipher (mode, key, iv, decrypt) {
  if (!(this instanceof StreamCipher)) {
    return new StreamCipher(mode, key, iv)
  }
  Transform.call(this)
  this._cipher = new aes.AES(key)
  this._prev = new Buffer(iv.length)
  this._cache = new Buffer('')
  this._secCache = new Buffer('')
  this._decrypt = decrypt
  iv.copy(this._prev)
  this._mode = mode
}
StreamCipher.prototype._update = function (chunk) {
  return this._mode.encrypt(this, chunk, this._decrypt)
}
StreamCipher.prototype._final = function () {
  this._cipher.scrub()
}

}).call(this,require("buffer").Buffer)

},{"./aes":157,"buffer":151,"cipher-base":172,"inherits":348}],174:[function(require,module,exports){
(function (Buffer){
var CipherBase = require('cipher-base')
var des = require('des.js')
var inherits = require('inherits')

var modes = {
  'des-ede3-cbc': des.CBC.instantiate(des.EDE),
  'des-ede3': des.EDE,
  'des-ede-cbc': des.CBC.instantiate(des.EDE),
  'des-ede': des.EDE,
  'des-cbc': des.CBC.instantiate(des.DES),
  'des-ecb': des.DES
}
modes.des = modes['des-cbc']
modes.des3 = modes['des-ede3-cbc']
module.exports = DES
inherits(DES, CipherBase)
function DES (opts) {
  CipherBase.call(this)
  var modeName = opts.mode.toLowerCase()
  var mode = modes[modeName]
  var type
  if (opts.decrypt) {
    type = 'decrypt'
  } else {
    type = 'encrypt'
  }
  var key = opts.key
  if (modeName === 'des-ede' || modeName === 'des-ede-cbc') {
    key = Buffer.concat([key, key.slice(0, 8)])
  }
  var iv = opts.iv
  this._des = mode.create({
    key: key,
    iv: iv,
    type: type
  })
}
DES.prototype._update = function (data) {
  return new Buffer(this._des.update(data))
}
DES.prototype._final = function () {
  return new Buffer(this._des.final())
}

}).call(this,require("buffer").Buffer)

},{"buffer":151,"cipher-base":176,"des.js":177,"inherits":348}],175:[function(require,module,exports){
exports['des-ecb'] = {
  key: 8,
  iv: 0
}
exports['des-cbc'] = exports.des = {
  key: 8,
  iv: 8
}
exports['des-ede3-cbc'] = exports.des3 = {
  key: 24,
  iv: 8
}
exports['des-ede3'] = {
  key: 24,
  iv: 0
}
exports['des-ede-cbc'] = {
  key: 16,
  iv: 8
}
exports['des-ede'] = {
  key: 16,
  iv: 0
}

},{}],176:[function(require,module,exports){
(function (Buffer){
var Transform = require('stream').Transform
var inherits = require('inherits')
var StringDecoder = require('string_decoder').StringDecoder
module.exports = CipherBase
inherits(CipherBase, Transform)
function CipherBase (hashMode) {
  Transform.call(this)
  this.hashMode = typeof hashMode === 'string'
  if (this.hashMode) {
    this[hashMode] = this._finalOrDigest
  } else {
    this.final = this._finalOrDigest
  }
  this._decoder = null
  this._encoding = null
}
CipherBase.prototype.update = function (data, inputEnc, outputEnc) {
  if (typeof data === 'string') {
    data = new Buffer(data, inputEnc)
  }
  var outData = this._update(data)
  if (this.hashMode) {
    return this
  }
  if (outputEnc) {
    outData = this._toString(outData, outputEnc)
  }
  return outData
}

CipherBase.prototype.setAutoPadding = function () {}

CipherBase.prototype.getAuthTag = function () {
  throw new Error('trying to get auth tag in unsupported state')
}

CipherBase.prototype.setAuthTag = function () {
  throw new Error('trying to set auth tag in unsupported state')
}

CipherBase.prototype.setAAD = function () {
  throw new Error('trying to set aad in unsupported state')
}

CipherBase.prototype._transform = function (data, _, next) {
  var err
  try {
    if (this.hashMode) {
      this._update(data)
    } else {
      this.push(this._update(data))
    }
  } catch (e) {
    err = e
  } finally {
    next(err)
  }
}
CipherBase.prototype._flush = function (done) {
  var err
  try {
    this.push(this._final())
  } catch (e) {
    err = e
  } finally {
    done(err)
  }
}
CipherBase.prototype._finalOrDigest = function (outputEnc) {
  var outData = this._final() || new Buffer('')
  if (outputEnc) {
    outData = this._toString(outData, outputEnc, true)
  }
  return outData
}

CipherBase.prototype._toString = function (value, enc, final) {
  if (!this._decoder) {
    this._decoder = new StringDecoder(enc)
    this._encoding = enc
  }
  if (this._encoding !== enc) {
    throw new Error('can\'t switch encodings')
  }
  var out = this._decoder.write(value)
  if (final) {
    out += this._decoder.end()
  }
  return out
}

}).call(this,require("buffer").Buffer)

},{"buffer":151,"inherits":348,"stream":365,"string_decoder":366}],177:[function(require,module,exports){
'use strict';

exports.utils = require('./des/utils');
exports.Cipher = require('./des/cipher');
exports.DES = require('./des/des');
exports.CBC = require('./des/cbc');
exports.EDE = require('./des/ede');

},{"./des/cbc":178,"./des/cipher":179,"./des/des":180,"./des/ede":181,"./des/utils":182}],178:[function(require,module,exports){
'use strict';

var assert = require('minimalistic-assert');
var inherits = require('inherits');

var proto = {};

function CBCState(iv) {
  assert.equal(iv.length, 8, 'Invalid IV length');

  this.iv = new Array(8);
  for (var i = 0; i < this.iv.length; i++)
    this.iv[i] = iv[i];
}

function instantiate(Base) {
  function CBC(options) {
    Base.call(this, options);
    this._cbcInit();
  }
  inherits(CBC, Base);

  var keys = Object.keys(proto);
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    CBC.prototype[key] = proto[key];
  }

  CBC.create = function create(options) {
    return new CBC(options);
  };

  return CBC;
}

exports.instantiate = instantiate;

proto._cbcInit = function _cbcInit() {
  var state = new CBCState(this.options.iv);
  this._cbcState = state;
};

proto._update = function _update(inp, inOff, out, outOff) {
  var state = this._cbcState;
  var superProto = this.constructor.super_.prototype;

  var iv = state.iv;
  if (this.type === 'encrypt') {
    for (var i = 0; i < this.blockSize; i++)
      iv[i] ^= inp[inOff + i];

    superProto._update.call(this, iv, 0, out, outOff);

    for (var i = 0; i < this.blockSize; i++)
      iv[i] = out[outOff + i];
  } else {
    superProto._update.call(this, inp, inOff, out, outOff);

    for (var i = 0; i < this.blockSize; i++)
      out[outOff + i] ^= iv[i];

    for (var i = 0; i < this.blockSize; i++)
      iv[i] = inp[inOff + i];
  }
};

},{"inherits":348,"minimalistic-assert":183}],179:[function(require,module,exports){
'use strict';

var assert = require('minimalistic-assert');

function Cipher(options) {
  this.options = options;

  this.type = this.options.type;
  this.blockSize = 8;
  this._init();

  this.buffer = new Array(this.blockSize);
  this.bufferOff = 0;
}
module.exports = Cipher;

Cipher.prototype._init = function _init() {
  // Might be overrided
};

Cipher.prototype.update = function update(data) {
  if (data.length === 0)
    return [];

  if (this.type === 'decrypt')
    return this._updateDecrypt(data);
  else
    return this._updateEncrypt(data);
};

Cipher.prototype._buffer = function _buffer(data, off) {
  // Append data to buffer
  var min = Math.min(this.buffer.length - this.bufferOff, data.length - off);
  for (var i = 0; i < min; i++)
    this.buffer[this.bufferOff + i] = data[off + i];
  this.bufferOff += min;

  // Shift next
  return min;
};

Cipher.prototype._flushBuffer = function _flushBuffer(out, off) {
  this._update(this.buffer, 0, out, off);
  this.bufferOff = 0;
  return this.blockSize;
};

Cipher.prototype._updateEncrypt = function _updateEncrypt(data) {
  var inputOff = 0;
  var outputOff = 0;

  var count = ((this.bufferOff + data.length) / this.blockSize) | 0;
  var out = new Array(count * this.blockSize);

  if (this.bufferOff !== 0) {
    inputOff += this._buffer(data, inputOff);

    if (this.bufferOff === this.buffer.length)
      outputOff += this._flushBuffer(out, outputOff);
  }

  // Write blocks
  var max = data.length - ((data.length - inputOff) % this.blockSize);
  for (; inputOff < max; inputOff += this.blockSize) {
    this._update(data, inputOff, out, outputOff);
    outputOff += this.blockSize;
  }

  // Queue rest
  for (; inputOff < data.length; inputOff++, this.bufferOff++)
    this.buffer[this.bufferOff] = data[inputOff];

  return out;
};

Cipher.prototype._updateDecrypt = function _updateDecrypt(data) {
  var inputOff = 0;
  var outputOff = 0;

  var count = Math.ceil((this.bufferOff + data.length) / this.blockSize) - 1;
  var out = new Array(count * this.blockSize);

  // TODO(indutny): optimize it, this is far from optimal
  for (; count > 0; count--) {
    inputOff += this._buffer(data, inputOff);
    outputOff += this._flushBuffer(out, outputOff);
  }

  // Buffer rest of the input
  inputOff += this._buffer(data, inputOff);

  return out;
};

Cipher.prototype.final = function final(buffer) {
  var first;
  if (buffer)
    first = this.update(buffer);

  var last;
  if (this.type === 'encrypt')
    last = this._finalEncrypt();
  else
    last = this._finalDecrypt();

  if (first)
    return first.concat(last);
  else
    return last;
};

Cipher.prototype._pad = function _pad(buffer, off) {
  if (off === 0)
    return false;

  while (off < buffer.length)
    buffer[off++] = 0;

  return true;
};

Cipher.prototype._finalEncrypt = function _finalEncrypt() {
  if (!this._pad(this.buffer, this.bufferOff))
    return [];

  var out = new Array(this.blockSize);
  this._update(this.buffer, 0, out, 0);
  return out;
};

Cipher.prototype._unpad = function _unpad(buffer) {
  return buffer;
};

Cipher.prototype._finalDecrypt = function _finalDecrypt() {
  assert.equal(this.bufferOff, this.blockSize, 'Not enough data to decrypt');
  var out = new Array(this.blockSize);
  this._flushBuffer(out, 0);

  return this._unpad(out);
};

},{"minimalistic-assert":183}],180:[function(require,module,exports){
'use strict';

var assert = require('minimalistic-assert');
var inherits = require('inherits');

var des = require('../des');
var utils = des.utils;
var Cipher = des.Cipher;

function DESState() {
  this.tmp = new Array(2);
  this.keys = null;
}

function DES(options) {
  Cipher.call(this, options);

  var state = new DESState();
  this._desState = state;

  this.deriveKeys(state, options.key);
}
inherits(DES, Cipher);
module.exports = DES;

DES.create = function create(options) {
  return new DES(options);
};

var shiftTable = [
  1, 1, 2, 2, 2, 2, 2, 2,
  1, 2, 2, 2, 2, 2, 2, 1
];

DES.prototype.deriveKeys = function deriveKeys(state, key) {
  state.keys = new Array(16 * 2);

  assert.equal(key.length, this.blockSize, 'Invalid key length');

  var kL = utils.readUInt32BE(key, 0);
  var kR = utils.readUInt32BE(key, 4);

  utils.pc1(kL, kR, state.tmp, 0);
  kL = state.tmp[0];
  kR = state.tmp[1];
  for (var i = 0; i < state.keys.length; i += 2) {
    var shift = shiftTable[i >>> 1];
    kL = utils.r28shl(kL, shift);
    kR = utils.r28shl(kR, shift);
    utils.pc2(kL, kR, state.keys, i);
  }
};

DES.prototype._update = function _update(inp, inOff, out, outOff) {
  var state = this._desState;

  var l = utils.readUInt32BE(inp, inOff);
  var r = utils.readUInt32BE(inp, inOff + 4);

  // Initial Permutation
  utils.ip(l, r, state.tmp, 0);
  l = state.tmp[0];
  r = state.tmp[1];

  if (this.type === 'encrypt')
    this._encrypt(state, l, r, state.tmp, 0);
  else
    this._decrypt(state, l, r, state.tmp, 0);

  l = state.tmp[0];
  r = state.tmp[1];

  utils.writeUInt32BE(out, l, outOff);
  utils.writeUInt32BE(out, r, outOff + 4);
};

DES.prototype._pad = function _pad(buffer, off) {
  var value = buffer.length - off;
  for (var i = off; i < buffer.length; i++)
    buffer[i] = value;

  return true;
};

DES.prototype._unpad = function _unpad(buffer) {
  var pad = buffer[buffer.length - 1];
  for (var i = buffer.length - pad; i < buffer.length; i++)
    assert.equal(buffer[i], pad);

  return buffer.slice(0, buffer.length - pad);
};

DES.prototype._encrypt = function _encrypt(state, lStart, rStart, out, off) {
  var l = lStart;
  var r = rStart;

  // Apply f() x16 times
  for (var i = 0; i < state.keys.length; i += 2) {
    var keyL = state.keys[i];
    var keyR = state.keys[i + 1];

    // f(r, k)
    utils.expand(r, state.tmp, 0);

    keyL ^= state.tmp[0];
    keyR ^= state.tmp[1];
    var s = utils.substitute(keyL, keyR);
    var f = utils.permute(s);

    var t = r;
    r = (l ^ f) >>> 0;
    l = t;
  }

  // Reverse Initial Permutation
  utils.rip(r, l, out, off);
};

DES.prototype._decrypt = function _decrypt(state, lStart, rStart, out, off) {
  var l = rStart;
  var r = lStart;

  // Apply f() x16 times
  for (var i = state.keys.length - 2; i >= 0; i -= 2) {
    var keyL = state.keys[i];
    var keyR = state.keys[i + 1];

    // f(r, k)
    utils.expand(l, state.tmp, 0);

    keyL ^= state.tmp[0];
    keyR ^= state.tmp[1];
    var s = utils.substitute(keyL, keyR);
    var f = utils.permute(s);

    var t = l;
    l = (r ^ f) >>> 0;
    r = t;
  }

  // Reverse Initial Permutation
  utils.rip(l, r, out, off);
};

},{"../des":177,"inherits":348,"minimalistic-assert":183}],181:[function(require,module,exports){
'use strict';

var assert = require('minimalistic-assert');
var inherits = require('inherits');

var des = require('../des');
var Cipher = des.Cipher;
var DES = des.DES;

function EDEState(type, key) {
  assert.equal(key.length, 24, 'Invalid key length');

  var k1 = key.slice(0, 8);
  var k2 = key.slice(8, 16);
  var k3 = key.slice(16, 24);

  if (type === 'encrypt') {
    this.ciphers = [
      DES.create({ type: 'encrypt', key: k1 }),
      DES.create({ type: 'decrypt', key: k2 }),
      DES.create({ type: 'encrypt', key: k3 })
    ];
  } else {
    this.ciphers = [
      DES.create({ type: 'decrypt', key: k3 }),
      DES.create({ type: 'encrypt', key: k2 }),
      DES.create({ type: 'decrypt', key: k1 })
    ];
  }
}

function EDE(options) {
  Cipher.call(this, options);

  var state = new EDEState(this.type, this.options.key);
  this._edeState = state;
}
inherits(EDE, Cipher);

module.exports = EDE;

EDE.create = function create(options) {
  return new EDE(options);
};

EDE.prototype._update = function _update(inp, inOff, out, outOff) {
  var state = this._edeState;

  state.ciphers[0]._update(inp, inOff, out, outOff);
  state.ciphers[1]._update(out, outOff, out, outOff);
  state.ciphers[2]._update(out, outOff, out, outOff);
};

EDE.prototype._pad = DES.prototype._pad;
EDE.prototype._unpad = DES.prototype._unpad;

},{"../des":177,"inherits":348,"minimalistic-assert":183}],182:[function(require,module,exports){
'use strict';

exports.readUInt32BE = function readUInt32BE(bytes, off) {
  var res =  (bytes[0 + off] << 24) |
             (bytes[1 + off] << 16) |
             (bytes[2 + off] << 8) |
             bytes[3 + off];
  return res >>> 0;
};

exports.writeUInt32BE = function writeUInt32BE(bytes, value, off) {
  bytes[0 + off] = value >>> 24;
  bytes[1 + off] = (value >>> 16) & 0xff;
  bytes[2 + off] = (value >>> 8) & 0xff;
  bytes[3 + off] = value & 0xff;
};

exports.ip = function ip(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  for (var i = 6; i >= 0; i -= 2) {
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inR >>> (j + i)) & 1;
    }
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inL >>> (j + i)) & 1;
    }
  }

  for (var i = 6; i >= 0; i -= 2) {
    for (var j = 1; j <= 25; j += 8) {
      outR <<= 1;
      outR |= (inR >>> (j + i)) & 1;
    }
    for (var j = 1; j <= 25; j += 8) {
      outR <<= 1;
      outR |= (inL >>> (j + i)) & 1;
    }
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.rip = function rip(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  for (var i = 0; i < 4; i++) {
    for (var j = 24; j >= 0; j -= 8) {
      outL <<= 1;
      outL |= (inR >>> (j + i)) & 1;
      outL <<= 1;
      outL |= (inL >>> (j + i)) & 1;
    }
  }
  for (var i = 4; i < 8; i++) {
    for (var j = 24; j >= 0; j -= 8) {
      outR <<= 1;
      outR |= (inR >>> (j + i)) & 1;
      outR <<= 1;
      outR |= (inL >>> (j + i)) & 1;
    }
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.pc1 = function pc1(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  // 7, 15, 23, 31, 39, 47, 55, 63
  // 6, 14, 22, 30, 39, 47, 55, 63
  // 5, 13, 21, 29, 39, 47, 55, 63
  // 4, 12, 20, 28
  for (var i = 7; i >= 5; i--) {
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inR >> (j + i)) & 1;
    }
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inL >> (j + i)) & 1;
    }
  }
  for (var j = 0; j <= 24; j += 8) {
    outL <<= 1;
    outL |= (inR >> (j + i)) & 1;
  }

  // 1, 9, 17, 25, 33, 41, 49, 57
  // 2, 10, 18, 26, 34, 42, 50, 58
  // 3, 11, 19, 27, 35, 43, 51, 59
  // 36, 44, 52, 60
  for (var i = 1; i <= 3; i++) {
    for (var j = 0; j <= 24; j += 8) {
      outR <<= 1;
      outR |= (inR >> (j + i)) & 1;
    }
    for (var j = 0; j <= 24; j += 8) {
      outR <<= 1;
      outR |= (inL >> (j + i)) & 1;
    }
  }
  for (var j = 0; j <= 24; j += 8) {
    outR <<= 1;
    outR |= (inL >> (j + i)) & 1;
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.r28shl = function r28shl(num, shift) {
  return ((num << shift) & 0xfffffff) | (num >>> (28 - shift));
};

var pc2table = [
  // inL => outL
  14, 11, 17, 4, 27, 23, 25, 0,
  13, 22, 7, 18, 5, 9, 16, 24,
  2, 20, 12, 21, 1, 8, 15, 26,

  // inR => outR
  15, 4, 25, 19, 9, 1, 26, 16,
  5, 11, 23, 8, 12, 7, 17, 0,
  22, 3, 10, 14, 6, 20, 27, 24
];

exports.pc2 = function pc2(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  var len = pc2table.length >>> 1;
  for (var i = 0; i < len; i++) {
    outL <<= 1;
    outL |= (inL >>> pc2table[i]) & 0x1;
  }
  for (var i = len; i < pc2table.length; i++) {
    outR <<= 1;
    outR |= (inR >>> pc2table[i]) & 0x1;
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.expand = function expand(r, out, off) {
  var outL = 0;
  var outR = 0;

  outL = ((r & 1) << 5) | (r >>> 27);
  for (var i = 23; i >= 15; i -= 4) {
    outL <<= 6;
    outL |= (r >>> i) & 0x3f;
  }
  for (var i = 11; i >= 3; i -= 4) {
    outR |= (r >>> i) & 0x3f;
    outR <<= 6;
  }
  outR |= ((r & 0x1f) << 1) | (r >>> 31);

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

var sTable = [
  14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1,
  3, 10, 10, 6, 6, 12, 12, 11, 5, 9, 9, 5, 0, 3, 7, 8,
  4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7,
  15, 5, 12, 11, 9, 3, 7, 14, 3, 10, 10, 0, 5, 6, 0, 13,

  15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14,
  9, 12, 7, 0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5,
  0, 13, 14, 8, 7, 10, 11, 1, 10, 3, 4, 15, 13, 4, 1, 2,
  5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14, 15, 9,

  10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5, 10,
  1, 2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1,
  13, 1, 6, 10, 4, 13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7,
  11, 4, 1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7, 12,

  7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6, 15, 9, 0, 10, 3,
  1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9,
  10, 3, 6, 15, 9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8,
  15, 9, 1, 4, 3, 5, 14, 11, 5, 12, 2, 7, 8, 2, 4, 14,

  2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1,
  8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14, 8, 9, 6,
  4, 11, 2, 8, 1, 12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13,
  15, 6, 9, 15, 12, 0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3,

  12, 10, 1, 15, 10, 4, 15, 2, 9, 7, 2, 12, 6, 9, 8, 5,
  0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11, 8,
  9, 4, 14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10,
  7, 11, 0, 14, 4, 1, 10, 7, 1, 6, 13, 0, 11, 8, 6, 13,

  4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1, 13, 10,
  3, 14, 12, 3, 9, 5, 7, 12, 5, 2, 10, 15, 6, 8, 1, 6,
  1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10, 14, 7,
  10, 9, 15, 5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12,

  13, 1, 2, 15, 8, 13, 4, 8, 6, 10, 15, 3, 11, 7, 1, 4,
  10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2,
  7, 2, 11, 1, 4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13,
  0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11
];

exports.substitute = function substitute(inL, inR) {
  var out = 0;
  for (var i = 0; i < 4; i++) {
    var b = (inL >>> (18 - i * 6)) & 0x3f;
    var sb = sTable[i * 0x40 + b];

    out <<= 4;
    out |= sb;
  }
  for (var i = 0; i < 4; i++) {
    var b = (inR >>> (18 - i * 6)) & 0x3f;
    var sb = sTable[4 * 0x40 + i * 0x40 + b];

    out <<= 4;
    out |= sb;
  }
  return out >>> 0;
};

var permuteTable = [
  16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22,
  30, 24, 8, 18, 0, 5, 29, 23, 13, 19, 2, 26, 10, 21, 28, 7
];

exports.permute = function permute(num) {
  var out = 0;
  for (var i = 0; i < permuteTable.length; i++) {
    out <<= 1;
    out |= (num >>> permuteTable[i]) & 0x1;
  }
  return out >>> 0;
};

exports.padSplit = function padSplit(num, size, group) {
  var str = num.toString(2);
  while (str.length < size)
    str = '0' + str;

  var out = [];
  for (var i = 0; i < size; i += group)
    out.push(str.slice(i, i + group));
  return out.join(' ');
};

},{}],183:[function(require,module,exports){
module.exports = assert;

function assert(val, msg) {
  if (!val)
    throw new Error(msg || 'Assertion failed');
}

assert.equal = function assertEqual(l, r, msg) {
  if (l != r)
    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));
};

},{}],184:[function(require,module,exports){
(function (Buffer){
var md5 = require('create-hash/md5')
module.exports = EVP_BytesToKey
function EVP_BytesToKey (password, salt, keyLen, ivLen) {
  if (!Buffer.isBuffer(password)) {
    password = new Buffer(password, 'binary')
  }
  if (salt && !Buffer.isBuffer(salt)) {
    salt = new Buffer(salt, 'binary')
  }
  keyLen = keyLen / 8
  ivLen = ivLen || 0
  var ki = 0
  var ii = 0
  var key = new Buffer(keyLen)
  var iv = new Buffer(ivLen)
  var addmd = 0
  var md_buf
  var i
  var bufs = []
  while (true) {
    if (addmd++ > 0) {
      bufs.push(md_buf)
    }
    bufs.push(password)
    if (salt) {
      bufs.push(salt)
    }
    md_buf = md5(Buffer.concat(bufs))
    bufs = []
    i = 0
    if (keyLen > 0) {
      while (true) {
        if (keyLen === 0) {
          break
        }
        if (i === md_buf.length) {
          break
        }
        key[ki++] = md_buf[i]
        keyLen--
        i++
      }
    }
    if (ivLen > 0 && i !== md_buf.length) {
      while (true) {
        if (ivLen === 0) {
          break
        }
        if (i === md_buf.length) {
          break
        }
        iv[ii++] = md_buf[i]
        ivLen--
        i++
      }
    }
    if (keyLen === 0 && ivLen === 0) {
      break
    }
  }
  for (i = 0; i < md_buf.length; i++) {
    md_buf[i] = 0
  }
  return {
    key: key,
    iv: iv
  }
}

}).call(this,require("buffer").Buffer)

},{"buffer":151,"create-hash/md5":281}],185:[function(require,module,exports){
(function (Buffer){
'use strict'
exports['RSA-SHA224'] = exports.sha224WithRSAEncryption = {
  sign: 'rsa',
  hash: 'sha224',
  id: new Buffer('302d300d06096086480165030402040500041c', 'hex')
}
exports['RSA-SHA256'] = exports.sha256WithRSAEncryption = {
  sign: 'rsa',
  hash: 'sha256',
  id: new Buffer('3031300d060960864801650304020105000420', 'hex')
}
exports['RSA-SHA384'] = exports.sha384WithRSAEncryption = {
  sign: 'rsa',
  hash: 'sha384',
  id: new Buffer('3041300d060960864801650304020205000430', 'hex')
}
exports['RSA-SHA512'] = exports.sha512WithRSAEncryption = {
  sign: 'rsa',
  hash: 'sha512',
  id: new Buffer('3051300d060960864801650304020305000440', 'hex')
}
exports['RSA-SHA1'] = {
  sign: 'rsa',
  hash: 'sha1',
  id: new Buffer('3021300906052b0e03021a05000414', 'hex')
}
exports['ecdsa-with-SHA1'] = {
  sign: 'ecdsa',
  hash: 'sha1',
  id: new Buffer('', 'hex')
}

exports.DSA = exports['DSA-SHA1'] = exports['DSA-SHA'] = {
  sign: 'dsa',
  hash: 'sha1',
  id: new Buffer('', 'hex')
}
exports['DSA-SHA224'] = exports['DSA-WITH-SHA224'] = {
  sign: 'dsa',
  hash: 'sha224',
  id: new Buffer('', 'hex')
}
exports['DSA-SHA256'] = exports['DSA-WITH-SHA256'] = {
  sign: 'dsa',
  hash: 'sha256',
  id: new Buffer('', 'hex')
}
exports['DSA-SHA384'] = exports['DSA-WITH-SHA384'] = {
  sign: 'dsa',
  hash: 'sha384',
  id: new Buffer('', 'hex')
}
exports['DSA-SHA512'] = exports['DSA-WITH-SHA512'] = {
  sign: 'dsa',
  hash: 'sha512',
  id: new Buffer('', 'hex')
}
exports['DSA-RIPEMD160'] = {
  sign: 'dsa',
  hash: 'rmd160',
  id: new Buffer('', 'hex')
}
exports['RSA-RIPEMD160'] = exports.ripemd160WithRSA = {
  sign: 'rsa',
  hash: 'rmd160',
  id: new Buffer('3021300906052b2403020105000414', 'hex')
}
exports['RSA-MD5'] = exports.md5WithRSAEncryption = {
  sign: 'rsa',
  hash: 'md5',
  id: new Buffer('3020300c06082a864886f70d020505000410', 'hex')
}

}).call(this,require("buffer").Buffer)

},{"buffer":151}],186:[function(require,module,exports){
(function (Buffer){
var _algos = require('./algos')
var createHash = require('create-hash')
var inherits = require('inherits')
var sign = require('./sign')
var stream = require('stream')
var verify = require('./verify')

var algos = {}
Object.keys(_algos).forEach(function (key) {
  algos[key] = algos[key.toLowerCase()] = _algos[key]
})

function Sign (algorithm) {
  stream.Writable.call(this)

  var data = algos[algorithm]
  if (!data) {
    throw new Error('Unknown message digest')
  }

  this._hashType = data.hash
  this._hash = createHash(data.hash)
  this._tag = data.id
  this._signType = data.sign
}
inherits(Sign, stream.Writable)

Sign.prototype._write = function _write (data, _, done) {
  this._hash.update(data)
  done()
}

Sign.prototype.update = function update (data, enc) {
  if (typeof data === 'string') {
    data = new Buffer(data, enc)
  }

  this._hash.update(data)
  return this
}

Sign.prototype.sign = function signMethod (key, enc) {
  this.end()
  var hash = this._hash.digest()
  var sig = sign(Buffer.concat([this._tag, hash]), key, this._hashType, this._signType)

  return enc ? sig.toString(enc) : sig
}

function Verify (algorithm) {
  stream.Writable.call(this)

  var data = algos[algorithm]
  if (!data) {
    throw new Error('Unknown message digest')
  }

  this._hash = createHash(data.hash)
  this._tag = data.id
  this._signType = data.sign
}
inherits(Verify, stream.Writable)

Verify.prototype._write = function _write (data, _, done) {
  this._hash.update(data)

  done()
}

Verify.prototype.update = function update (data, enc) {
  if (typeof data === 'string') {
    data = new Buffer(data, enc)
  }

  this._hash.update(data)
  return this
}

Verify.prototype.verify = function verifyMethod (key, sig, enc) {
  if (typeof sig === 'string') {
    sig = new Buffer(sig, enc)
  }

  this.end()
  var hash = this._hash.digest()

  return verify(sig, Buffer.concat([this._tag, hash]), key, this._signType)
}

function createSign (algorithm) {
  return new Sign(algorithm)
}

function createVerify (algorithm) {
  return new Verify(algorithm)
}

module.exports = {
  Sign: createSign,
  Verify: createVerify,
  createSign: createSign,
  createVerify: createVerify
}

}).call(this,require("buffer").Buffer)

},{"./algos":185,"./sign":251,"./verify":252,"buffer":151,"create-hash":279,"inherits":348,"stream":365}],187:[function(require,module,exports){
'use strict'
exports['1.3.132.0.10'] = 'secp256k1'

exports['1.3.132.0.33'] = 'p224'

exports['1.2.840.10045.3.1.1'] = 'p192'

exports['1.2.840.10045.3.1.7'] = 'p256'

exports['1.3.132.0.34'] = 'p384'

exports['1.3.132.0.35'] = 'p521'

},{}],188:[function(require,module,exports){
(function (module, exports) {

'use strict';

// Utils

function assert(val, msg) {
  if (!val)
    throw new Error(msg || 'Assertion failed');
}

// Could use `inherits` module, but don't want to move from single file
// architecture yet.
function inherits(ctor, superCtor) {
  ctor.super_ = superCtor;
  var TempCtor = function () {};
  TempCtor.prototype = superCtor.prototype;
  ctor.prototype = new TempCtor();
  ctor.prototype.constructor = ctor;
}

// BN

function BN(number, base, endian) {
  // May be `new BN(bn)` ?
  if (number !== null &&
      typeof number === 'object' &&
      Array.isArray(number.words)) {
    return number;
  }

  this.negative = 0;
  this.words = null;
  this.length = 0;

  // Reduction context
  this.red = null;

  if (number !== null) {
    if (base === 'le' || base === 'be') {
      endian = base;
      base = 10;
    }

    this._init(number || 0, base || 10, endian || 'be');
  }
}
if (typeof module === 'object')
  module.exports = BN;
else
  exports.BN = BN;

BN.BN = BN;
BN.wordSize = 26;

BN.max = function max(left, right) {
  if (left.cmp(right) > 0)
    return left;
  else
    return right;
};

BN.min = function min(left, right) {
  if (left.cmp(right) < 0)
    return left;
  else
    return right;
};

BN.prototype._init = function init(number, base, endian) {
  if (typeof number === 'number') {
    return this._initNumber(number, base, endian);
  } else if (typeof number === 'object') {
    return this._initArray(number, base, endian);
  }
  if (base === 'hex')
    base = 16;
  assert(base === (base | 0) && base >= 2 && base <= 36);

  number = number.toString().replace(/\s+/g, '');
  var start = 0;
  if (number[0] === '-')
    start++;

  if (base === 16)
    this._parseHex(number, start);
  else
    this._parseBase(number, base, start);

  if (number[0] === '-')
    this.negative = 1;

  this.strip();

  if (endian !== 'le')
    return;

  this._initArray(this.toArray(), base, endian);
};

BN.prototype._initNumber = function _initNumber(number, base, endian) {
  if (number < 0) {
    this.negative = 1;
    number = -number;
  }
  if (number < 0x4000000) {
    this.words = [ number & 0x3ffffff ];
    this.length = 1;
  } else if (number < 0x10000000000000) {
    this.words = [
      number & 0x3ffffff,
      (number / 0x4000000) & 0x3ffffff
    ];
    this.length = 2;
  } else {
    assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
    this.words = [
      number & 0x3ffffff,
      (number / 0x4000000) & 0x3ffffff,
      1
    ];
    this.length = 3;
  }

  if (endian !== 'le')
    return;

  // Reverse the bytes
  this._initArray(this.toArray(), base, endian);
};

BN.prototype._initArray = function _initArray(number, base, endian) {
  // Perhaps a Uint8Array
  assert(typeof number.length === 'number');
  if (number.length <= 0) {
    this.words = [ 0 ];
    this.length = 1;
    return this;
  }

  this.length = Math.ceil(number.length / 3);
  this.words = new Array(this.length);
  for (var i = 0; i < this.length; i++)
    this.words[i] = 0;

  var off = 0;
  if (endian === 'be') {
    for (var i = number.length - 1, j = 0; i >= 0; i -= 3) {
      var w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
      this.words[j] |= (w << off) & 0x3ffffff;
      this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
      off += 24;
      if (off >= 26) {
        off -= 26;
        j++;
      }
    }
  } else if (endian === 'le') {
    for (var i = 0, j = 0; i < number.length; i += 3) {
      var w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
      this.words[j] |= (w << off) & 0x3ffffff;
      this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
      off += 24;
      if (off >= 26) {
        off -= 26;
        j++;
      }
    }
  }
  return this.strip();
};

function parseHex(str, start, end) {
  var r = 0;
  var len = Math.min(str.length, end);
  for (var i = start; i < len; i++) {
    var c = str.charCodeAt(i) - 48;

    r <<= 4;

    // 'a' - 'f'
    if (c >= 49 && c <= 54)
      r |= c - 49 + 0xa;

    // 'A' - 'F'
    else if (c >= 17 && c <= 22)
      r |= c - 17 + 0xa;

    // '0' - '9'
    else
      r |= c & 0xf;
  }
  return r;
}

BN.prototype._parseHex = function _parseHex(number, start) {
  // Create possibly bigger array to ensure that it fits the number
  this.length = Math.ceil((number.length - start) / 6);
  this.words = new Array(this.length);
  for (var i = 0; i < this.length; i++)
    this.words[i] = 0;

  // Scan 24-bit chunks and add them to the number
  var off = 0;
  for (var i = number.length - 6, j = 0; i >= start; i -= 6) {
    var w = parseHex(number, i, i + 6);
    this.words[j] |= (w << off) & 0x3ffffff;
    this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
    off += 24;
    if (off >= 26) {
      off -= 26;
      j++;
    }
  }
  if (i + 6 !== start) {
    var w = parseHex(number, start, i + 6);
    this.words[j] |= (w << off) & 0x3ffffff;
    this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
  }
  this.strip();
};

function parseBase(str, start, end, mul) {
  var r = 0;
  var len = Math.min(str.length, end);
  for (var i = start; i < len; i++) {
    var c = str.charCodeAt(i) - 48;

    r *= mul;

    // 'a'
    if (c >= 49)
      r += c - 49 + 0xa;

    // 'A'
    else if (c >= 17)
      r += c - 17 + 0xa;

    // '0' - '9'
    else
      r += c;
  }
  return r;
}

BN.prototype._parseBase = function _parseBase(number, base, start) {
  // Initialize as zero
  this.words = [ 0 ];
  this.length = 1;

  // Find length of limb in base
  for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base)
    limbLen++;
  limbLen--;
  limbPow = (limbPow / base) | 0;

  var total = number.length - start;
  var mod = total % limbLen;
  var end = Math.min(total, total - mod) + start;

  var word = 0;
  for (var i = start; i < end; i += limbLen) {
    word = parseBase(number, i, i + limbLen, base);

    this.imuln(limbPow);
    if (this.words[0] + word < 0x4000000)
      this.words[0] += word;
    else
      this._iaddn(word);
  }

  if (mod !== 0) {
    var pow = 1;
    var word = parseBase(number, i, number.length, base);

    for (var i = 0; i < mod; i++)
      pow *= base;
    this.imuln(pow);
    if (this.words[0] + word < 0x4000000)
      this.words[0] += word;
    else
      this._iaddn(word);
  }
};

BN.prototype.copy = function copy(dest) {
  dest.words = new Array(this.length);
  for (var i = 0; i < this.length; i++)
    dest.words[i] = this.words[i];
  dest.length = this.length;
  dest.negative = this.negative;
  dest.red = this.red;
};

BN.prototype.clone = function clone() {
  var r = new BN(null);
  this.copy(r);
  return r;
};

// Remove leading `0` from `this`
BN.prototype.strip = function strip() {
  while (this.length > 1 && this.words[this.length - 1] === 0)
    this.length--;
  return this._normSign();
};

BN.prototype._normSign = function _normSign() {
  // -0 = 0
  if (this.length === 1 && this.words[0] === 0)
    this.negative = 0;
  return this;
};

BN.prototype.inspect = function inspect() {
  return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
};

/*

var zeros = [];
var groupSizes = [];
var groupBases = [];

var s = '';
var i = -1;
while (++i < BN.wordSize) {
  zeros[i] = s;
  s += '0';
}
groupSizes[0] = 0;
groupSizes[1] = 0;
groupBases[0] = 0;
groupBases[1] = 0;
var base = 2 - 1;
while (++base < 36 + 1) {
  var groupSize = 0;
  var groupBase = 1;
  while (groupBase < (1 << BN.wordSize) / base) {
    groupBase *= base;
    groupSize += 1;
  }
  groupSizes[base] = groupSize;
  groupBases[base] = groupBase;
}

*/

var zeros = [
  '',
  '0',
  '00',
  '000',
  '0000',
  '00000',
  '000000',
  '0000000',
  '00000000',
  '000000000',
  '0000000000',
  '00000000000',
  '000000000000',
  '0000000000000',
  '00000000000000',
  '000000000000000',
  '0000000000000000',
  '00000000000000000',
  '000000000000000000',
  '0000000000000000000',
  '00000000000000000000',
  '000000000000000000000',
  '0000000000000000000000',
  '00000000000000000000000',
  '000000000000000000000000',
  '0000000000000000000000000'
];

var groupSizes = [
  0, 0,
  25, 16, 12, 11, 10, 9, 8,
  8, 7, 7, 7, 7, 6, 6,
  6, 6, 6, 6, 6, 5, 5,
  5, 5, 5, 5, 5, 5, 5,
  5, 5, 5, 5, 5, 5, 5
];

var groupBases = [
  0, 0,
  33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
  43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
  16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
  6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
  24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
];

BN.prototype.toString = function toString(base, padding) {
  base = base || 10;
  var padding = padding | 0 || 1;
  if (base === 16 || base === 'hex') {
    var out = '';
    var off = 0;
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = this.words[i];
      var word = (((w << off) | carry) & 0xffffff).toString(16);
      carry = (w >>> (24 - off)) & 0xffffff;
      if (carry !== 0 || i !== this.length - 1)
        out = zeros[6 - word.length] + word + out;
      else
        out = word + out;
      off += 2;
      if (off >= 26) {
        off -= 26;
        i--;
      }
    }
    if (carry !== 0)
      out = carry.toString(16) + out;
    while (out.length % padding !== 0)
      out = '0' + out;
    if (this.negative !== 0)
      out = '-' + out;
    return out;
  } else if (base === (base | 0) && base >= 2 && base <= 36) {
    // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
    var groupSize = groupSizes[base];
    // var groupBase = Math.pow(base, groupSize);
    var groupBase = groupBases[base];
    var out = '';
    var c = this.clone();
    c.negative = 0;
    while (c.cmpn(0) !== 0) {
      var r = c.modn(groupBase).toString(base);
      c = c.idivn(groupBase);

      if (c.cmpn(0) !== 0)
        out = zeros[groupSize - r.length] + r + out;
      else
        out = r + out;
    }
    if (this.cmpn(0) === 0)
      out = '0' + out;
    while (out.length % padding !== 0)
      out = '0' + out;
    if (this.negative !== 0)
      out = '-' + out;
    return out;
  } else {
    assert(false, 'Base should be between 2 and 36');
  }
};

BN.prototype.toNumber = function toNumber() {
  assert(this.bitLength() <= 53, 'Number can only safely store up to 53 bits');
  return parseInt(this.toString(), 10);
};

BN.prototype.toJSON = function toJSON() {
  return this.toString(16);
};

BN.prototype.toArray = function toArray(endian, length) {
  var byteLength = this.byteLength();
  var reqLength = length || byteLength;
  assert(byteLength <= reqLength, 'byte array longer than desired length');

  this.strip();
  var littleEndian = endian === 'le';
  var res = new Array(reqLength);

  var q = this.clone();
  if (!littleEndian) {
    // Assume big-endian
    for (var i = 0; i < reqLength - byteLength; i++)
      res[i] = 0;
    for (i = 0; q.cmpn(0) !== 0; i++) {
      var b = q.andln(0xff);
      q.iushrn(8);

      res[reqLength - i - 1] = b;
    }
  } else {
    for (var i = 0; q.cmpn(0) !== 0; i++) {
      var b = q.andln(0xff);
      q.iushrn(8);

      res[i] = b;
    }
    for (; i < reqLength; i++)
      res[i] = 0;
  }

  return res;
};

if (Math.clz32) {
  BN.prototype._countBits = function _countBits(w) {
    return 32 - Math.clz32(w);
  };
} else {
  BN.prototype._countBits = function _countBits(w) {
    var t = w;
    var r = 0;
    if (t >= 0x1000) {
      r += 13;
      t >>>= 13;
    }
    if (t >= 0x40) {
      r += 7;
      t >>>= 7;
    }
    if (t >= 0x8) {
      r += 4;
      t >>>= 4;
    }
    if (t >= 0x02) {
      r += 2;
      t >>>= 2;
    }
    return r + t;
  };
}

BN.prototype._zeroBits = function _zeroBits(w) {
  // Short-cut
  if (w === 0)
    return 26;

  var t = w;
  var r = 0;
  if ((t & 0x1fff) === 0) {
    r += 13;
    t >>>= 13;
  }
  if ((t & 0x7f) === 0) {
    r += 7;
    t >>>= 7;
  }
  if ((t & 0xf) === 0) {
    r += 4;
    t >>>= 4;
  }
  if ((t & 0x3) === 0) {
    r += 2;
    t >>>= 2;
  }
  if ((t & 0x1) === 0)
    r++;
  return r;
};

// Return number of used bits in a BN
BN.prototype.bitLength = function bitLength() {
  var hi = 0;
  var w = this.words[this.length - 1];
  var hi = this._countBits(w);
  return (this.length - 1) * 26 + hi;
};

function toBitArray(num) {
  var w = new Array(num.bitLength());

  for (var bit = 0; bit < w.length; bit++) {
    var off = (bit / 26) | 0;
    var wbit = bit % 26;

    w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;
  }

  return w;
}

// Number of trailing zero bits
BN.prototype.zeroBits = function zeroBits() {
  if (this.cmpn(0) === 0)
    return 0;

  var r = 0;
  for (var i = 0; i < this.length; i++) {
    var b = this._zeroBits(this.words[i]);
    r += b;
    if (b !== 26)
      break;
  }
  return r;
};

BN.prototype.byteLength = function byteLength() {
  return Math.ceil(this.bitLength() / 8);
};

BN.prototype.isNeg = function isNeg() {
  return this.negative !== 0;
};

// Return negative clone of `this`
BN.prototype.neg = function neg() {
  if (this.cmpn(0) === 0)
    return this.clone();

  var r = this.clone();
  r.negative = this.negative ^ 1;
  return r;
};

BN.prototype.ineg = function ineg() {
  this.negative ^= 1;
  return this;
};

// Or `num` with `this` in-place
BN.prototype.iuor = function iuor(num) {
  while (this.length < num.length)
    this.words[this.length++] = 0;

  for (var i = 0; i < num.length; i++)
    this.words[i] = this.words[i] | num.words[i];

  return this.strip();
};

BN.prototype.ior = function ior(num) {
  assert((this.negative | num.negative) === 0);
  return this.iuor(num);
};


// Or `num` with `this`
BN.prototype.or = function or(num) {
  if (this.length > num.length)
    return this.clone().ior(num);
  else
    return num.clone().ior(this);
};

BN.prototype.uor = function uor(num) {
  if (this.length > num.length)
    return this.clone().iuor(num);
  else
    return num.clone().iuor(this);
};


// And `num` with `this` in-place
BN.prototype.iuand = function iuand(num) {
  // b = min-length(num, this)
  var b;
  if (this.length > num.length)
    b = num;
  else
    b = this;

  for (var i = 0; i < b.length; i++)
    this.words[i] = this.words[i] & num.words[i];

  this.length = b.length;

  return this.strip();
};

BN.prototype.iand = function iand(num) {
  assert((this.negative | num.negative) === 0);
  return this.iuand(num);
};


// And `num` with `this`
BN.prototype.and = function and(num) {
  if (this.length > num.length)
    return this.clone().iand(num);
  else
    return num.clone().iand(this);
};

BN.prototype.uand = function uand(num) {
  if (this.length > num.length)
    return this.clone().iuand(num);
  else
    return num.clone().iuand(this);
};


// Xor `num` with `this` in-place
BN.prototype.iuxor = function iuxor(num) {
  // a.length > b.length
  var a;
  var b;
  if (this.length > num.length) {
    a = this;
    b = num;
  } else {
    a = num;
    b = this;
  }

  for (var i = 0; i < b.length; i++)
    this.words[i] = a.words[i] ^ b.words[i];

  if (this !== a)
    for (; i < a.length; i++)
      this.words[i] = a.words[i];

  this.length = a.length;

  return this.strip();
};

BN.prototype.ixor = function ixor(num) {
  assert((this.negative | num.negative) === 0);
  return this.iuxor(num);
};


// Xor `num` with `this`
BN.prototype.xor = function xor(num) {
  if (this.length > num.length)
    return this.clone().ixor(num);
  else
    return num.clone().ixor(this);
};

BN.prototype.uxor = function uxor(num) {
  if (this.length > num.length)
    return this.clone().iuxor(num);
  else
    return num.clone().iuxor(this);
};


// Set `bit` of `this`
BN.prototype.setn = function setn(bit, val) {
  assert(typeof bit === 'number' && bit >= 0);

  var off = (bit / 26) | 0;
  var wbit = bit % 26;

  while (this.length <= off)
    this.words[this.length++] = 0;

  if (val)
    this.words[off] = this.words[off] | (1 << wbit);
  else
    this.words[off] = this.words[off] & ~(1 << wbit);

  return this.strip();
};


// Add `num` to `this` in-place
BN.prototype.iadd = function iadd(num) {
  // negative + positive
  if (this.negative !== 0 && num.negative === 0) {
    this.negative = 0;
    var r = this.isub(num);
    this.negative ^= 1;
    return this._normSign();

  // positive + negative
  } else if (this.negative === 0 && num.negative !== 0) {
    num.negative = 0;
    var r = this.isub(num);
    num.negative = 1;
    return r._normSign();
  }

  // a.length > b.length
  var a;
  var b;
  if (this.length > num.length) {
    a = this;
    b = num;
  } else {
    a = num;
    b = this;
  }

  var carry = 0;
  for (var i = 0; i < b.length; i++) {
    var r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
    this.words[i] = r & 0x3ffffff;
    carry = r >>> 26;
  }
  for (; carry !== 0 && i < a.length; i++) {
    var r = (a.words[i] | 0) + carry;
    this.words[i] = r & 0x3ffffff;
    carry = r >>> 26;
  }

  this.length = a.length;
  if (carry !== 0) {
    this.words[this.length] = carry;
    this.length++;
  // Copy the rest of the words
  } else if (a !== this) {
    for (; i < a.length; i++)
      this.words[i] = a.words[i];
  }

  return this;
};

// Add `num` to `this`
BN.prototype.add = function add(num) {
  if (num.negative !== 0 && this.negative === 0) {
    num.negative = 0;
    var res = this.sub(num);
    num.negative ^= 1;
    return res;
  } else if (num.negative === 0 && this.negative !== 0) {
    this.negative = 0;
    var res = num.sub(this);
    this.negative = 1;
    return res;
  }

  if (this.length > num.length)
    return this.clone().iadd(num);
  else
    return num.clone().iadd(this);
};

// Subtract `num` from `this` in-place
BN.prototype.isub = function isub(num) {
  // this - (-num) = this + num
  if (num.negative !== 0) {
    num.negative = 0;
    var r = this.iadd(num);
    num.negative = 1;
    return r._normSign();

  // -this - num = -(this + num)
  } else if (this.negative !== 0) {
    this.negative = 0;
    this.iadd(num);
    this.negative = 1;
    return this._normSign();
  }

  // At this point both numbers are positive
  var cmp = this.cmp(num);

  // Optimization - zeroify
  if (cmp === 0) {
    this.negative = 0;
    this.length = 1;
    this.words[0] = 0;
    return this;
  }

  // a > b
  var a;
  var b;
  if (cmp > 0) {
    a = this;
    b = num;
  } else {
    a = num;
    b = this;
  }

  var carry = 0;
  for (var i = 0; i < b.length; i++) {
    var r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
    carry = r >> 26;
    this.words[i] = r & 0x3ffffff;
  }
  for (; carry !== 0 && i < a.length; i++) {
    var r = (a.words[i] | 0) + carry;
    carry = r >> 26;
    this.words[i] = r & 0x3ffffff;
  }

  // Copy rest of the words
  if (carry === 0 && i < a.length && a !== this)
    for (; i < a.length; i++)
      this.words[i] = a.words[i];
  this.length = Math.max(this.length, i);

  if (a !== this)
    this.negative = 1;

  return this.strip();
};

// Subtract `num` from `this`
BN.prototype.sub = function sub(num) {
  return this.clone().isub(num);
};

/*
// NOTE: This could be potentionally used to generate loop-less multiplications
function _genCombMulTo(alen, blen) {
  var len = alen + blen - 1;
  var src = [
    'var a = self.words;',
    'var b = num.words;',
    'var o = out.words;',
    'var c = 0;',
    'var lo;',
    'var mid;',
    'var hi;'
  ];
  for (var i = 0; i < alen; i++) {
    src.push('var a' + i + ' = a[' + i + '] | 0;');
    src.push('var al' + i + ' = a' + i + ' & 0x1fff;');
    src.push('var ah' + i + ' = a' + i + ' >>> 13;');
  }
  for (var i = 0; i < blen; i++) {
    src.push('var b' + i + ' = b[' + i + '] | 0;');
    src.push('var bl' + i + ' = b' + i + ' & 0x1fff;');
    src.push('var bh' + i + ' = b' + i + ' >>> 13;');
  }
  src.push('');
  src.push('out.length = ' + len + ';');

  for (var k = 0; k < len; k++) {
    var minJ = Math.max(0, k - alen + 1);
    var maxJ = Math.min(k, blen - 1);

    src.push('\/* k = ' + k + ' *\/');
    src.push('var w' + k + ' = c;');
    src.push('c = 0;');
    for (var j = minJ; j <= maxJ; j++) {
      var i = k - j;

      src.push('lo = Math.imul(al' + i + ', bl' + j + ');');
      src.push('mid = Math.imul(al' + i + ', bh' + j + ');');
      src.push('mid = (mid + Math.imul(ah' + i + ', bl' + j + ')) | 0;');
      src.push('hi = Math.imul(ah' + i + ', bh' + j + ');');

      src.push('w' + k + ' = (w' + k + ' + lo) | 0;');
      src.push('w' + k + ' = (w' + k + ' + ((mid & 0x1fff) << 13)) | 0;');
      src.push('c = (c + hi) | 0;');
      src.push('c = (c + (mid >>> 13)) | 0;');
      src.push('c = (c + (w' + k + ' >>> 26)) | 0;');
      src.push('w' + k + ' &= 0x3ffffff;');
    }
  }
  // Store in separate step for better memory access
  for (var k = 0; k < len; k++)
    src.push('o[' + k + '] = w' + k + ';');
  src.push('if (c !== 0) {',
           '  o[' + k + '] = c;',
           '  out.length++;',
           '}',
           'return out;');

  return src.join('\n');
}
console.log(_genCombMulTo(10, 10));
*/

function smallMulTo(self, num, out) {
  out.negative = num.negative ^ self.negative;
  var len = (self.length + num.length) | 0;
  out.length = len;
  len = (len - 1) | 0;

  // Peel one iteration (compiler can't do it, because of code complexity)
  var a = self.words[0] | 0;
  var b = num.words[0] | 0;
  var r = a * b;

  var lo = r & 0x3ffffff;
  var carry = (r / 0x4000000) | 0;
  out.words[0] = lo;

  for (var k = 1; k < len; k++) {
    // Sum all words with the same `i + j = k` and accumulate `ncarry`,
    // note that ncarry could be >= 0x3ffffff
    var ncarry = carry >>> 26;
    var rword = carry & 0x3ffffff;
    var maxJ = Math.min(k, num.length - 1);
    for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
      var i = (k - j) | 0;
      var a = self.words[i] | 0;
      var b = num.words[j] | 0;
      var r = a * b;

      var lo = r & 0x3ffffff;
      ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
      lo = (lo + rword) | 0;
      rword = lo & 0x3ffffff;
      ncarry = (ncarry + (lo >>> 26)) | 0;
    }
    out.words[k] = rword | 0;
    carry = ncarry | 0;
  }
  if (carry !== 0) {
    out.words[k] = carry | 0;
  } else {
    out.length--;
  }

  return out.strip();
}

// TODO(indutny): it may be reasonable to omit it for users who don't need
// to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
// multiplication (like elliptic secp256k1).
var comb10MulTo = function comb10MulTo(self, num, out) {
  var a = self.words;
  var b = num.words;
  var o = out.words;
  var c = 0;
  var lo;
  var mid;
  var hi;
  var a0 = a[0] | 0;
  var al0 = a0 & 0x1fff;
  var ah0 = a0 >>> 13;
  var a1 = a[1] | 0;
  var al1 = a1 & 0x1fff;
  var ah1 = a1 >>> 13;
  var a2 = a[2] | 0;
  var al2 = a2 & 0x1fff;
  var ah2 = a2 >>> 13;
  var a3 = a[3] | 0;
  var al3 = a3 & 0x1fff;
  var ah3 = a3 >>> 13;
  var a4 = a[4] | 0;
  var al4 = a4 & 0x1fff;
  var ah4 = a4 >>> 13;
  var a5 = a[5] | 0;
  var al5 = a5 & 0x1fff;
  var ah5 = a5 >>> 13;
  var a6 = a[6] | 0;
  var al6 = a6 & 0x1fff;
  var ah6 = a6 >>> 13;
  var a7 = a[7] | 0;
  var al7 = a7 & 0x1fff;
  var ah7 = a7 >>> 13;
  var a8 = a[8] | 0;
  var al8 = a8 & 0x1fff;
  var ah8 = a8 >>> 13;
  var a9 = a[9] | 0;
  var al9 = a9 & 0x1fff;
  var ah9 = a9 >>> 13;
  var b0 = b[0] | 0;
  var bl0 = b0 & 0x1fff;
  var bh0 = b0 >>> 13;
  var b1 = b[1] | 0;
  var bl1 = b1 & 0x1fff;
  var bh1 = b1 >>> 13;
  var b2 = b[2] | 0;
  var bl2 = b2 & 0x1fff;
  var bh2 = b2 >>> 13;
  var b3 = b[3] | 0;
  var bl3 = b3 & 0x1fff;
  var bh3 = b3 >>> 13;
  var b4 = b[4] | 0;
  var bl4 = b4 & 0x1fff;
  var bh4 = b4 >>> 13;
  var b5 = b[5] | 0;
  var bl5 = b5 & 0x1fff;
  var bh5 = b5 >>> 13;
  var b6 = b[6] | 0;
  var bl6 = b6 & 0x1fff;
  var bh6 = b6 >>> 13;
  var b7 = b[7] | 0;
  var bl7 = b7 & 0x1fff;
  var bh7 = b7 >>> 13;
  var b8 = b[8] | 0;
  var bl8 = b8 & 0x1fff;
  var bh8 = b8 >>> 13;
  var b9 = b[9] | 0;
  var bl9 = b9 & 0x1fff;
  var bh9 = b9 >>> 13;

  out.length = 19;
  /* k = 0 */
  var w0 = c;
  c = 0;
  lo = Math.imul(al0, bl0);
  mid = Math.imul(al0, bh0);
  mid = (mid + Math.imul(ah0, bl0)) | 0;
  hi = Math.imul(ah0, bh0);
  w0 = (w0 + lo) | 0;
  w0 = (w0 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w0 >>> 26)) | 0;
  w0 &= 0x3ffffff;
  /* k = 1 */
  var w1 = c;
  c = 0;
  lo = Math.imul(al1, bl0);
  mid = Math.imul(al1, bh0);
  mid = (mid + Math.imul(ah1, bl0)) | 0;
  hi = Math.imul(ah1, bh0);
  w1 = (w1 + lo) | 0;
  w1 = (w1 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w1 >>> 26)) | 0;
  w1 &= 0x3ffffff;
  lo = Math.imul(al0, bl1);
  mid = Math.imul(al0, bh1);
  mid = (mid + Math.imul(ah0, bl1)) | 0;
  hi = Math.imul(ah0, bh1);
  w1 = (w1 + lo) | 0;
  w1 = (w1 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w1 >>> 26)) | 0;
  w1 &= 0x3ffffff;
  /* k = 2 */
  var w2 = c;
  c = 0;
  lo = Math.imul(al2, bl0);
  mid = Math.imul(al2, bh0);
  mid = (mid + Math.imul(ah2, bl0)) | 0;
  hi = Math.imul(ah2, bh0);
  w2 = (w2 + lo) | 0;
  w2 = (w2 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w2 >>> 26)) | 0;
  w2 &= 0x3ffffff;
  lo = Math.imul(al1, bl1);
  mid = Math.imul(al1, bh1);
  mid = (mid + Math.imul(ah1, bl1)) | 0;
  hi = Math.imul(ah1, bh1);
  w2 = (w2 + lo) | 0;
  w2 = (w2 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w2 >>> 26)) | 0;
  w2 &= 0x3ffffff;
  lo = Math.imul(al0, bl2);
  mid = Math.imul(al0, bh2);
  mid = (mid + Math.imul(ah0, bl2)) | 0;
  hi = Math.imul(ah0, bh2);
  w2 = (w2 + lo) | 0;
  w2 = (w2 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w2 >>> 26)) | 0;
  w2 &= 0x3ffffff;
  /* k = 3 */
  var w3 = c;
  c = 0;
  lo = Math.imul(al3, bl0);
  mid = Math.imul(al3, bh0);
  mid = (mid + Math.imul(ah3, bl0)) | 0;
  hi = Math.imul(ah3, bh0);
  w3 = (w3 + lo) | 0;
  w3 = (w3 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w3 >>> 26)) | 0;
  w3 &= 0x3ffffff;
  lo = Math.imul(al2, bl1);
  mid = Math.imul(al2, bh1);
  mid = (mid + Math.imul(ah2, bl1)) | 0;
  hi = Math.imul(ah2, bh1);
  w3 = (w3 + lo) | 0;
  w3 = (w3 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w3 >>> 26)) | 0;
  w3 &= 0x3ffffff;
  lo = Math.imul(al1, bl2);
  mid = Math.imul(al1, bh2);
  mid = (mid + Math.imul(ah1, bl2)) | 0;
  hi = Math.imul(ah1, bh2);
  w3 = (w3 + lo) | 0;
  w3 = (w3 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w3 >>> 26)) | 0;
  w3 &= 0x3ffffff;
  lo = Math.imul(al0, bl3);
  mid = Math.imul(al0, bh3);
  mid = (mid + Math.imul(ah0, bl3)) | 0;
  hi = Math.imul(ah0, bh3);
  w3 = (w3 + lo) | 0;
  w3 = (w3 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w3 >>> 26)) | 0;
  w3 &= 0x3ffffff;
  /* k = 4 */
  var w4 = c;
  c = 0;
  lo = Math.imul(al4, bl0);
  mid = Math.imul(al4, bh0);
  mid = (mid + Math.imul(ah4, bl0)) | 0;
  hi = Math.imul(ah4, bh0);
  w4 = (w4 + lo) | 0;
  w4 = (w4 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w4 >>> 26)) | 0;
  w4 &= 0x3ffffff;
  lo = Math.imul(al3, bl1);
  mid = Math.imul(al3, bh1);
  mid = (mid + Math.imul(ah3, bl1)) | 0;
  hi = Math.imul(ah3, bh1);
  w4 = (w4 + lo) | 0;
  w4 = (w4 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w4 >>> 26)) | 0;
  w4 &= 0x3ffffff;
  lo = Math.imul(al2, bl2);
  mid = Math.imul(al2, bh2);
  mid = (mid + Math.imul(ah2, bl2)) | 0;
  hi = Math.imul(ah2, bh2);
  w4 = (w4 + lo) | 0;
  w4 = (w4 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w4 >>> 26)) | 0;
  w4 &= 0x3ffffff;
  lo = Math.imul(al1, bl3);
  mid = Math.imul(al1, bh3);
  mid = (mid + Math.imul(ah1, bl3)) | 0;
  hi = Math.imul(ah1, bh3);
  w4 = (w4 + lo) | 0;
  w4 = (w4 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w4 >>> 26)) | 0;
  w4 &= 0x3ffffff;
  lo = Math.imul(al0, bl4);
  mid = Math.imul(al0, bh4);
  mid = (mid + Math.imul(ah0, bl4)) | 0;
  hi = Math.imul(ah0, bh4);
  w4 = (w4 + lo) | 0;
  w4 = (w4 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w4 >>> 26)) | 0;
  w4 &= 0x3ffffff;
  /* k = 5 */
  var w5 = c;
  c = 0;
  lo = Math.imul(al5, bl0);
  mid = Math.imul(al5, bh0);
  mid = (mid + Math.imul(ah5, bl0)) | 0;
  hi = Math.imul(ah5, bh0);
  w5 = (w5 + lo) | 0;
  w5 = (w5 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w5 >>> 26)) | 0;
  w5 &= 0x3ffffff;
  lo = Math.imul(al4, bl1);
  mid = Math.imul(al4, bh1);
  mid = (mid + Math.imul(ah4, bl1)) | 0;
  hi = Math.imul(ah4, bh1);
  w5 = (w5 + lo) | 0;
  w5 = (w5 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w5 >>> 26)) | 0;
  w5 &= 0x3ffffff;
  lo = Math.imul(al3, bl2);
  mid = Math.imul(al3, bh2);
  mid = (mid + Math.imul(ah3, bl2)) | 0;
  hi = Math.imul(ah3, bh2);
  w5 = (w5 + lo) | 0;
  w5 = (w5 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w5 >>> 26)) | 0;
  w5 &= 0x3ffffff;
  lo = Math.imul(al2, bl3);
  mid = Math.imul(al2, bh3);
  mid = (mid + Math.imul(ah2, bl3)) | 0;
  hi = Math.imul(ah2, bh3);
  w5 = (w5 + lo) | 0;
  w5 = (w5 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w5 >>> 26)) | 0;
  w5 &= 0x3ffffff;
  lo = Math.imul(al1, bl4);
  mid = Math.imul(al1, bh4);
  mid = (mid + Math.imul(ah1, bl4)) | 0;
  hi = Math.imul(ah1, bh4);
  w5 = (w5 + lo) | 0;
  w5 = (w5 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w5 >>> 26)) | 0;
  w5 &= 0x3ffffff;
  lo = Math.imul(al0, bl5);
  mid = Math.imul(al0, bh5);
  mid = (mid + Math.imul(ah0, bl5)) | 0;
  hi = Math.imul(ah0, bh5);
  w5 = (w5 + lo) | 0;
  w5 = (w5 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w5 >>> 26)) | 0;
  w5 &= 0x3ffffff;
  /* k = 6 */
  var w6 = c;
  c = 0;
  lo = Math.imul(al6, bl0);
  mid = Math.imul(al6, bh0);
  mid = (mid + Math.imul(ah6, bl0)) | 0;
  hi = Math.imul(ah6, bh0);
  w6 = (w6 + lo) | 0;
  w6 = (w6 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w6 >>> 26)) | 0;
  w6 &= 0x3ffffff;
  lo = Math.imul(al5, bl1);
  mid = Math.imul(al5, bh1);
  mid = (mid + Math.imul(ah5, bl1)) | 0;
  hi = Math.imul(ah5, bh1);
  w6 = (w6 + lo) | 0;
  w6 = (w6 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w6 >>> 26)) | 0;
  w6 &= 0x3ffffff;
  lo = Math.imul(al4, bl2);
  mid = Math.imul(al4, bh2);
  mid = (mid + Math.imul(ah4, bl2)) | 0;
  hi = Math.imul(ah4, bh2);
  w6 = (w6 + lo) | 0;
  w6 = (w6 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w6 >>> 26)) | 0;
  w6 &= 0x3ffffff;
  lo = Math.imul(al3, bl3);
  mid = Math.imul(al3, bh3);
  mid = (mid + Math.imul(ah3, bl3)) | 0;
  hi = Math.imul(ah3, bh3);
  w6 = (w6 + lo) | 0;
  w6 = (w6 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w6 >>> 26)) | 0;
  w6 &= 0x3ffffff;
  lo = Math.imul(al2, bl4);
  mid = Math.imul(al2, bh4);
  mid = (mid + Math.imul(ah2, bl4)) | 0;
  hi = Math.imul(ah2, bh4);
  w6 = (w6 + lo) | 0;
  w6 = (w6 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w6 >>> 26)) | 0;
  w6 &= 0x3ffffff;
  lo = Math.imul(al1, bl5);
  mid = Math.imul(al1, bh5);
  mid = (mid + Math.imul(ah1, bl5)) | 0;
  hi = Math.imul(ah1, bh5);
  w6 = (w6 + lo) | 0;
  w6 = (w6 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w6 >>> 26)) | 0;
  w6 &= 0x3ffffff;
  lo = Math.imul(al0, bl6);
  mid = Math.imul(al0, bh6);
  mid = (mid + Math.imul(ah0, bl6)) | 0;
  hi = Math.imul(ah0, bh6);
  w6 = (w6 + lo) | 0;
  w6 = (w6 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w6 >>> 26)) | 0;
  w6 &= 0x3ffffff;
  /* k = 7 */
  var w7 = c;
  c = 0;
  lo = Math.imul(al7, bl0);
  mid = Math.imul(al7, bh0);
  mid = (mid + Math.imul(ah7, bl0)) | 0;
  hi = Math.imul(ah7, bh0);
  w7 = (w7 + lo) | 0;
  w7 = (w7 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w7 >>> 26)) | 0;
  w7 &= 0x3ffffff;
  lo = Math.imul(al6, bl1);
  mid = Math.imul(al6, bh1);
  mid = (mid + Math.imul(ah6, bl1)) | 0;
  hi = Math.imul(ah6, bh1);
  w7 = (w7 + lo) | 0;
  w7 = (w7 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w7 >>> 26)) | 0;
  w7 &= 0x3ffffff;
  lo = Math.imul(al5, bl2);
  mid = Math.imul(al5, bh2);
  mid = (mid + Math.imul(ah5, bl2)) | 0;
  hi = Math.imul(ah5, bh2);
  w7 = (w7 + lo) | 0;
  w7 = (w7 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w7 >>> 26)) | 0;
  w7 &= 0x3ffffff;
  lo = Math.imul(al4, bl3);
  mid = Math.imul(al4, bh3);
  mid = (mid + Math.imul(ah4, bl3)) | 0;
  hi = Math.imul(ah4, bh3);
  w7 = (w7 + lo) | 0;
  w7 = (w7 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w7 >>> 26)) | 0;
  w7 &= 0x3ffffff;
  lo = Math.imul(al3, bl4);
  mid = Math.imul(al3, bh4);
  mid = (mid + Math.imul(ah3, bl4)) | 0;
  hi = Math.imul(ah3, bh4);
  w7 = (w7 + lo) | 0;
  w7 = (w7 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w7 >>> 26)) | 0;
  w7 &= 0x3ffffff;
  lo = Math.imul(al2, bl5);
  mid = Math.imul(al2, bh5);
  mid = (mid + Math.imul(ah2, bl5)) | 0;
  hi = Math.imul(ah2, bh5);
  w7 = (w7 + lo) | 0;
  w7 = (w7 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w7 >>> 26)) | 0;
  w7 &= 0x3ffffff;
  lo = Math.imul(al1, bl6);
  mid = Math.imul(al1, bh6);
  mid = (mid + Math.imul(ah1, bl6)) | 0;
  hi = Math.imul(ah1, bh6);
  w7 = (w7 + lo) | 0;
  w7 = (w7 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w7 >>> 26)) | 0;
  w7 &= 0x3ffffff;
  lo = Math.imul(al0, bl7);
  mid = Math.imul(al0, bh7);
  mid = (mid + Math.imul(ah0, bl7)) | 0;
  hi = Math.imul(ah0, bh7);
  w7 = (w7 + lo) | 0;
  w7 = (w7 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w7 >>> 26)) | 0;
  w7 &= 0x3ffffff;
  /* k = 8 */
  var w8 = c;
  c = 0;
  lo = Math.imul(al8, bl0);
  mid = Math.imul(al8, bh0);
  mid = (mid + Math.imul(ah8, bl0)) | 0;
  hi = Math.imul(ah8, bh0);
  w8 = (w8 + lo) | 0;
  w8 = (w8 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w8 >>> 26)) | 0;
  w8 &= 0x3ffffff;
  lo = Math.imul(al7, bl1);
  mid = Math.imul(al7, bh1);
  mid = (mid + Math.imul(ah7, bl1)) | 0;
  hi = Math.imul(ah7, bh1);
  w8 = (w8 + lo) | 0;
  w8 = (w8 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w8 >>> 26)) | 0;
  w8 &= 0x3ffffff;
  lo = Math.imul(al6, bl2);
  mid = Math.imul(al6, bh2);
  mid = (mid + Math.imul(ah6, bl2)) | 0;
  hi = Math.imul(ah6, bh2);
  w8 = (w8 + lo) | 0;
  w8 = (w8 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w8 >>> 26)) | 0;
  w8 &= 0x3ffffff;
  lo = Math.imul(al5, bl3);
  mid = Math.imul(al5, bh3);
  mid = (mid + Math.imul(ah5, bl3)) | 0;
  hi = Math.imul(ah5, bh3);
  w8 = (w8 + lo) | 0;
  w8 = (w8 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w8 >>> 26)) | 0;
  w8 &= 0x3ffffff;
  lo = Math.imul(al4, bl4);
  mid = Math.imul(al4, bh4);
  mid = (mid + Math.imul(ah4, bl4)) | 0;
  hi = Math.imul(ah4, bh4);
  w8 = (w8 + lo) | 0;
  w8 = (w8 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w8 >>> 26)) | 0;
  w8 &= 0x3ffffff;
  lo = Math.imul(al3, bl5);
  mid = Math.imul(al3, bh5);
  mid = (mid + Math.imul(ah3, bl5)) | 0;
  hi = Math.imul(ah3, bh5);
  w8 = (w8 + lo) | 0;
  w8 = (w8 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w8 >>> 26)) | 0;
  w8 &= 0x3ffffff;
  lo = Math.imul(al2, bl6);
  mid = Math.imul(al2, bh6);
  mid = (mid + Math.imul(ah2, bl6)) | 0;
  hi = Math.imul(ah2, bh6);
  w8 = (w8 + lo) | 0;
  w8 = (w8 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w8 >>> 26)) | 0;
  w8 &= 0x3ffffff;
  lo = Math.imul(al1, bl7);
  mid = Math.imul(al1, bh7);
  mid = (mid + Math.imul(ah1, bl7)) | 0;
  hi = Math.imul(ah1, bh7);
  w8 = (w8 + lo) | 0;
  w8 = (w8 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w8 >>> 26)) | 0;
  w8 &= 0x3ffffff;
  lo = Math.imul(al0, bl8);
  mid = Math.imul(al0, bh8);
  mid = (mid + Math.imul(ah0, bl8)) | 0;
  hi = Math.imul(ah0, bh8);
  w8 = (w8 + lo) | 0;
  w8 = (w8 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w8 >>> 26)) | 0;
  w8 &= 0x3ffffff;
  /* k = 9 */
  var w9 = c;
  c = 0;
  lo = Math.imul(al9, bl0);
  mid = Math.imul(al9, bh0);
  mid = (mid + Math.imul(ah9, bl0)) | 0;
  hi = Math.imul(ah9, bh0);
  w9 = (w9 + lo) | 0;
  w9 = (w9 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w9 >>> 26)) | 0;
  w9 &= 0x3ffffff;
  lo = Math.imul(al8, bl1);
  mid = Math.imul(al8, bh1);
  mid = (mid + Math.imul(ah8, bl1)) | 0;
  hi = Math.imul(ah8, bh1);
  w9 = (w9 + lo) | 0;
  w9 = (w9 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w9 >>> 26)) | 0;
  w9 &= 0x3ffffff;
  lo = Math.imul(al7, bl2);
  mid = Math.imul(al7, bh2);
  mid = (mid + Math.imul(ah7, bl2)) | 0;
  hi = Math.imul(ah7, bh2);
  w9 = (w9 + lo) | 0;
  w9 = (w9 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w9 >>> 26)) | 0;
  w9 &= 0x3ffffff;
  lo = Math.imul(al6, bl3);
  mid = Math.imul(al6, bh3);
  mid = (mid + Math.imul(ah6, bl3)) | 0;
  hi = Math.imul(ah6, bh3);
  w9 = (w9 + lo) | 0;
  w9 = (w9 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w9 >>> 26)) | 0;
  w9 &= 0x3ffffff;
  lo = Math.imul(al5, bl4);
  mid = Math.imul(al5, bh4);
  mid = (mid + Math.imul(ah5, bl4)) | 0;
  hi = Math.imul(ah5, bh4);
  w9 = (w9 + lo) | 0;
  w9 = (w9 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w9 >>> 26)) | 0;
  w9 &= 0x3ffffff;
  lo = Math.imul(al4, bl5);
  mid = Math.imul(al4, bh5);
  mid = (mid + Math.imul(ah4, bl5)) | 0;
  hi = Math.imul(ah4, bh5);
  w9 = (w9 + lo) | 0;
  w9 = (w9 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w9 >>> 26)) | 0;
  w9 &= 0x3ffffff;
  lo = Math.imul(al3, bl6);
  mid = Math.imul(al3, bh6);
  mid = (mid + Math.imul(ah3, bl6)) | 0;
  hi = Math.imul(ah3, bh6);
  w9 = (w9 + lo) | 0;
  w9 = (w9 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w9 >>> 26)) | 0;
  w9 &= 0x3ffffff;
  lo = Math.imul(al2, bl7);
  mid = Math.imul(al2, bh7);
  mid = (mid + Math.imul(ah2, bl7)) | 0;
  hi = Math.imul(ah2, bh7);
  w9 = (w9 + lo) | 0;
  w9 = (w9 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w9 >>> 26)) | 0;
  w9 &= 0x3ffffff;
  lo = Math.imul(al1, bl8);
  mid = Math.imul(al1, bh8);
  mid = (mid + Math.imul(ah1, bl8)) | 0;
  hi = Math.imul(ah1, bh8);
  w9 = (w9 + lo) | 0;
  w9 = (w9 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w9 >>> 26)) | 0;
  w9 &= 0x3ffffff;
  lo = Math.imul(al0, bl9);
  mid = Math.imul(al0, bh9);
  mid = (mid + Math.imul(ah0, bl9)) | 0;
  hi = Math.imul(ah0, bh9);
  w9 = (w9 + lo) | 0;
  w9 = (w9 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w9 >>> 26)) | 0;
  w9 &= 0x3ffffff;
  /* k = 10 */
  var w10 = c;
  c = 0;
  lo = Math.imul(al9, bl1);
  mid = Math.imul(al9, bh1);
  mid = (mid + Math.imul(ah9, bl1)) | 0;
  hi = Math.imul(ah9, bh1);
  w10 = (w10 + lo) | 0;
  w10 = (w10 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w10 >>> 26)) | 0;
  w10 &= 0x3ffffff;
  lo = Math.imul(al8, bl2);
  mid = Math.imul(al8, bh2);
  mid = (mid + Math.imul(ah8, bl2)) | 0;
  hi = Math.imul(ah8, bh2);
  w10 = (w10 + lo) | 0;
  w10 = (w10 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w10 >>> 26)) | 0;
  w10 &= 0x3ffffff;
  lo = Math.imul(al7, bl3);
  mid = Math.imul(al7, bh3);
  mid = (mid + Math.imul(ah7, bl3)) | 0;
  hi = Math.imul(ah7, bh3);
  w10 = (w10 + lo) | 0;
  w10 = (w10 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w10 >>> 26)) | 0;
  w10 &= 0x3ffffff;
  lo = Math.imul(al6, bl4);
  mid = Math.imul(al6, bh4);
  mid = (mid + Math.imul(ah6, bl4)) | 0;
  hi = Math.imul(ah6, bh4);
  w10 = (w10 + lo) | 0;
  w10 = (w10 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w10 >>> 26)) | 0;
  w10 &= 0x3ffffff;
  lo = Math.imul(al5, bl5);
  mid = Math.imul(al5, bh5);
  mid = (mid + Math.imul(ah5, bl5)) | 0;
  hi = Math.imul(ah5, bh5);
  w10 = (w10 + lo) | 0;
  w10 = (w10 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w10 >>> 26)) | 0;
  w10 &= 0x3ffffff;
  lo = Math.imul(al4, bl6);
  mid = Math.imul(al4, bh6);
  mid = (mid + Math.imul(ah4, bl6)) | 0;
  hi = Math.imul(ah4, bh6);
  w10 = (w10 + lo) | 0;
  w10 = (w10 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w10 >>> 26)) | 0;
  w10 &= 0x3ffffff;
  lo = Math.imul(al3, bl7);
  mid = Math.imul(al3, bh7);
  mid = (mid + Math.imul(ah3, bl7)) | 0;
  hi = Math.imul(ah3, bh7);
  w10 = (w10 + lo) | 0;
  w10 = (w10 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w10 >>> 26)) | 0;
  w10 &= 0x3ffffff;
  lo = Math.imul(al2, bl8);
  mid = Math.imul(al2, bh8);
  mid = (mid + Math.imul(ah2, bl8)) | 0;
  hi = Math.imul(ah2, bh8);
  w10 = (w10 + lo) | 0;
  w10 = (w10 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w10 >>> 26)) | 0;
  w10 &= 0x3ffffff;
  lo = Math.imul(al1, bl9);
  mid = Math.imul(al1, bh9);
  mid = (mid + Math.imul(ah1, bl9)) | 0;
  hi = Math.imul(ah1, bh9);
  w10 = (w10 + lo) | 0;
  w10 = (w10 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w10 >>> 26)) | 0;
  w10 &= 0x3ffffff;
  /* k = 11 */
  var w11 = c;
  c = 0;
  lo = Math.imul(al9, bl2);
  mid = Math.imul(al9, bh2);
  mid = (mid + Math.imul(ah9, bl2)) | 0;
  hi = Math.imul(ah9, bh2);
  w11 = (w11 + lo) | 0;
  w11 = (w11 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w11 >>> 26)) | 0;
  w11 &= 0x3ffffff;
  lo = Math.imul(al8, bl3);
  mid = Math.imul(al8, bh3);
  mid = (mid + Math.imul(ah8, bl3)) | 0;
  hi = Math.imul(ah8, bh3);
  w11 = (w11 + lo) | 0;
  w11 = (w11 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w11 >>> 26)) | 0;
  w11 &= 0x3ffffff;
  lo = Math.imul(al7, bl4);
  mid = Math.imul(al7, bh4);
  mid = (mid + Math.imul(ah7, bl4)) | 0;
  hi = Math.imul(ah7, bh4);
  w11 = (w11 + lo) | 0;
  w11 = (w11 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w11 >>> 26)) | 0;
  w11 &= 0x3ffffff;
  lo = Math.imul(al6, bl5);
  mid = Math.imul(al6, bh5);
  mid = (mid + Math.imul(ah6, bl5)) | 0;
  hi = Math.imul(ah6, bh5);
  w11 = (w11 + lo) | 0;
  w11 = (w11 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w11 >>> 26)) | 0;
  w11 &= 0x3ffffff;
  lo = Math.imul(al5, bl6);
  mid = Math.imul(al5, bh6);
  mid = (mid + Math.imul(ah5, bl6)) | 0;
  hi = Math.imul(ah5, bh6);
  w11 = (w11 + lo) | 0;
  w11 = (w11 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w11 >>> 26)) | 0;
  w11 &= 0x3ffffff;
  lo = Math.imul(al4, bl7);
  mid = Math.imul(al4, bh7);
  mid = (mid + Math.imul(ah4, bl7)) | 0;
  hi = Math.imul(ah4, bh7);
  w11 = (w11 + lo) | 0;
  w11 = (w11 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w11 >>> 26)) | 0;
  w11 &= 0x3ffffff;
  lo = Math.imul(al3, bl8);
  mid = Math.imul(al3, bh8);
  mid = (mid + Math.imul(ah3, bl8)) | 0;
  hi = Math.imul(ah3, bh8);
  w11 = (w11 + lo) | 0;
  w11 = (w11 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w11 >>> 26)) | 0;
  w11 &= 0x3ffffff;
  lo = Math.imul(al2, bl9);
  mid = Math.imul(al2, bh9);
  mid = (mid + Math.imul(ah2, bl9)) | 0;
  hi = Math.imul(ah2, bh9);
  w11 = (w11 + lo) | 0;
  w11 = (w11 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w11 >>> 26)) | 0;
  w11 &= 0x3ffffff;
  /* k = 12 */
  var w12 = c;
  c = 0;
  lo = Math.imul(al9, bl3);
  mid = Math.imul(al9, bh3);
  mid = (mid + Math.imul(ah9, bl3)) | 0;
  hi = Math.imul(ah9, bh3);
  w12 = (w12 + lo) | 0;
  w12 = (w12 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w12 >>> 26)) | 0;
  w12 &= 0x3ffffff;
  lo = Math.imul(al8, bl4);
  mid = Math.imul(al8, bh4);
  mid = (mid + Math.imul(ah8, bl4)) | 0;
  hi = Math.imul(ah8, bh4);
  w12 = (w12 + lo) | 0;
  w12 = (w12 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w12 >>> 26)) | 0;
  w12 &= 0x3ffffff;
  lo = Math.imul(al7, bl5);
  mid = Math.imul(al7, bh5);
  mid = (mid + Math.imul(ah7, bl5)) | 0;
  hi = Math.imul(ah7, bh5);
  w12 = (w12 + lo) | 0;
  w12 = (w12 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w12 >>> 26)) | 0;
  w12 &= 0x3ffffff;
  lo = Math.imul(al6, bl6);
  mid = Math.imul(al6, bh6);
  mid = (mid + Math.imul(ah6, bl6)) | 0;
  hi = Math.imul(ah6, bh6);
  w12 = (w12 + lo) | 0;
  w12 = (w12 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w12 >>> 26)) | 0;
  w12 &= 0x3ffffff;
  lo = Math.imul(al5, bl7);
  mid = Math.imul(al5, bh7);
  mid = (mid + Math.imul(ah5, bl7)) | 0;
  hi = Math.imul(ah5, bh7);
  w12 = (w12 + lo) | 0;
  w12 = (w12 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w12 >>> 26)) | 0;
  w12 &= 0x3ffffff;
  lo = Math.imul(al4, bl8);
  mid = Math.imul(al4, bh8);
  mid = (mid + Math.imul(ah4, bl8)) | 0;
  hi = Math.imul(ah4, bh8);
  w12 = (w12 + lo) | 0;
  w12 = (w12 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w12 >>> 26)) | 0;
  w12 &= 0x3ffffff;
  lo = Math.imul(al3, bl9);
  mid = Math.imul(al3, bh9);
  mid = (mid + Math.imul(ah3, bl9)) | 0;
  hi = Math.imul(ah3, bh9);
  w12 = (w12 + lo) | 0;
  w12 = (w12 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w12 >>> 26)) | 0;
  w12 &= 0x3ffffff;
  /* k = 13 */
  var w13 = c;
  c = 0;
  lo = Math.imul(al9, bl4);
  mid = Math.imul(al9, bh4);
  mid = (mid + Math.imul(ah9, bl4)) | 0;
  hi = Math.imul(ah9, bh4);
  w13 = (w13 + lo) | 0;
  w13 = (w13 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w13 >>> 26)) | 0;
  w13 &= 0x3ffffff;
  lo = Math.imul(al8, bl5);
  mid = Math.imul(al8, bh5);
  mid = (mid + Math.imul(ah8, bl5)) | 0;
  hi = Math.imul(ah8, bh5);
  w13 = (w13 + lo) | 0;
  w13 = (w13 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w13 >>> 26)) | 0;
  w13 &= 0x3ffffff;
  lo = Math.imul(al7, bl6);
  mid = Math.imul(al7, bh6);
  mid = (mid + Math.imul(ah7, bl6)) | 0;
  hi = Math.imul(ah7, bh6);
  w13 = (w13 + lo) | 0;
  w13 = (w13 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w13 >>> 26)) | 0;
  w13 &= 0x3ffffff;
  lo = Math.imul(al6, bl7);
  mid = Math.imul(al6, bh7);
  mid = (mid + Math.imul(ah6, bl7)) | 0;
  hi = Math.imul(ah6, bh7);
  w13 = (w13 + lo) | 0;
  w13 = (w13 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w13 >>> 26)) | 0;
  w13 &= 0x3ffffff;
  lo = Math.imul(al5, bl8);
  mid = Math.imul(al5, bh8);
  mid = (mid + Math.imul(ah5, bl8)) | 0;
  hi = Math.imul(ah5, bh8);
  w13 = (w13 + lo) | 0;
  w13 = (w13 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w13 >>> 26)) | 0;
  w13 &= 0x3ffffff;
  lo = Math.imul(al4, bl9);
  mid = Math.imul(al4, bh9);
  mid = (mid + Math.imul(ah4, bl9)) | 0;
  hi = Math.imul(ah4, bh9);
  w13 = (w13 + lo) | 0;
  w13 = (w13 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w13 >>> 26)) | 0;
  w13 &= 0x3ffffff;
  /* k = 14 */
  var w14 = c;
  c = 0;
  lo = Math.imul(al9, bl5);
  mid = Math.imul(al9, bh5);
  mid = (mid + Math.imul(ah9, bl5)) | 0;
  hi = Math.imul(ah9, bh5);
  w14 = (w14 + lo) | 0;
  w14 = (w14 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w14 >>> 26)) | 0;
  w14 &= 0x3ffffff;
  lo = Math.imul(al8, bl6);
  mid = Math.imul(al8, bh6);
  mid = (mid + Math.imul(ah8, bl6)) | 0;
  hi = Math.imul(ah8, bh6);
  w14 = (w14 + lo) | 0;
  w14 = (w14 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w14 >>> 26)) | 0;
  w14 &= 0x3ffffff;
  lo = Math.imul(al7, bl7);
  mid = Math.imul(al7, bh7);
  mid = (mid + Math.imul(ah7, bl7)) | 0;
  hi = Math.imul(ah7, bh7);
  w14 = (w14 + lo) | 0;
  w14 = (w14 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w14 >>> 26)) | 0;
  w14 &= 0x3ffffff;
  lo = Math.imul(al6, bl8);
  mid = Math.imul(al6, bh8);
  mid = (mid + Math.imul(ah6, bl8)) | 0;
  hi = Math.imul(ah6, bh8);
  w14 = (w14 + lo) | 0;
  w14 = (w14 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w14 >>> 26)) | 0;
  w14 &= 0x3ffffff;
  lo = Math.imul(al5, bl9);
  mid = Math.imul(al5, bh9);
  mid = (mid + Math.imul(ah5, bl9)) | 0;
  hi = Math.imul(ah5, bh9);
  w14 = (w14 + lo) | 0;
  w14 = (w14 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w14 >>> 26)) | 0;
  w14 &= 0x3ffffff;
  /* k = 15 */
  var w15 = c;
  c = 0;
  lo = Math.imul(al9, bl6);
  mid = Math.imul(al9, bh6);
  mid = (mid + Math.imul(ah9, bl6)) | 0;
  hi = Math.imul(ah9, bh6);
  w15 = (w15 + lo) | 0;
  w15 = (w15 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w15 >>> 26)) | 0;
  w15 &= 0x3ffffff;
  lo = Math.imul(al8, bl7);
  mid = Math.imul(al8, bh7);
  mid = (mid + Math.imul(ah8, bl7)) | 0;
  hi = Math.imul(ah8, bh7);
  w15 = (w15 + lo) | 0;
  w15 = (w15 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w15 >>> 26)) | 0;
  w15 &= 0x3ffffff;
  lo = Math.imul(al7, bl8);
  mid = Math.imul(al7, bh8);
  mid = (mid + Math.imul(ah7, bl8)) | 0;
  hi = Math.imul(ah7, bh8);
  w15 = (w15 + lo) | 0;
  w15 = (w15 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w15 >>> 26)) | 0;
  w15 &= 0x3ffffff;
  lo = Math.imul(al6, bl9);
  mid = Math.imul(al6, bh9);
  mid = (mid + Math.imul(ah6, bl9)) | 0;
  hi = Math.imul(ah6, bh9);
  w15 = (w15 + lo) | 0;
  w15 = (w15 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w15 >>> 26)) | 0;
  w15 &= 0x3ffffff;
  /* k = 16 */
  var w16 = c;
  c = 0;
  lo = Math.imul(al9, bl7);
  mid = Math.imul(al9, bh7);
  mid = (mid + Math.imul(ah9, bl7)) | 0;
  hi = Math.imul(ah9, bh7);
  w16 = (w16 + lo) | 0;
  w16 = (w16 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w16 >>> 26)) | 0;
  w16 &= 0x3ffffff;
  lo = Math.imul(al8, bl8);
  mid = Math.imul(al8, bh8);
  mid = (mid + Math.imul(ah8, bl8)) | 0;
  hi = Math.imul(ah8, bh8);
  w16 = (w16 + lo) | 0;
  w16 = (w16 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w16 >>> 26)) | 0;
  w16 &= 0x3ffffff;
  lo = Math.imul(al7, bl9);
  mid = Math.imul(al7, bh9);
  mid = (mid + Math.imul(ah7, bl9)) | 0;
  hi = Math.imul(ah7, bh9);
  w16 = (w16 + lo) | 0;
  w16 = (w16 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w16 >>> 26)) | 0;
  w16 &= 0x3ffffff;
  /* k = 17 */
  var w17 = c;
  c = 0;
  lo = Math.imul(al9, bl8);
  mid = Math.imul(al9, bh8);
  mid = (mid + Math.imul(ah9, bl8)) | 0;
  hi = Math.imul(ah9, bh8);
  w17 = (w17 + lo) | 0;
  w17 = (w17 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w17 >>> 26)) | 0;
  w17 &= 0x3ffffff;
  lo = Math.imul(al8, bl9);
  mid = Math.imul(al8, bh9);
  mid = (mid + Math.imul(ah8, bl9)) | 0;
  hi = Math.imul(ah8, bh9);
  w17 = (w17 + lo) | 0;
  w17 = (w17 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w17 >>> 26)) | 0;
  w17 &= 0x3ffffff;
  /* k = 18 */
  var w18 = c;
  c = 0;
  lo = Math.imul(al9, bl9);
  mid = Math.imul(al9, bh9);
  mid = (mid + Math.imul(ah9, bl9)) | 0;
  hi = Math.imul(ah9, bh9);
  w18 = (w18 + lo) | 0;
  w18 = (w18 + ((mid & 0x1fff) << 13)) | 0;
  c = (c + hi) | 0;
  c = (c + (mid >>> 13)) | 0;
  c = (c + (w18 >>> 26)) | 0;
  w18 &= 0x3ffffff;
  o[0] = w0;
  o[1] = w1;
  o[2] = w2;
  o[3] = w3;
  o[4] = w4;
  o[5] = w5;
  o[6] = w6;
  o[7] = w7;
  o[8] = w8;
  o[9] = w9;
  o[10] = w10;
  o[11] = w11;
  o[12] = w12;
  o[13] = w13;
  o[14] = w14;
  o[15] = w15;
  o[16] = w16;
  o[17] = w17;
  o[18] = w18;
  if (c !== 0) {
    o[19] = c;
    out.length++;
  }
  return out;
};

// Polyfill comb
if (!Math.imul)
  comb10MulTo = smallMulTo;

function bigMulTo(self, num, out) {
  out.negative = num.negative ^ self.negative;
  out.length = self.length + num.length;

  var carry = 0;
  var hncarry = 0;
  for (var k = 0; k < out.length - 1; k++) {
    // Sum all words with the same `i + j = k` and accumulate `ncarry`,
    // note that ncarry could be >= 0x3ffffff
    var ncarry = hncarry;
    hncarry = 0;
    var rword = carry & 0x3ffffff;
    var maxJ = Math.min(k, num.length - 1);
    for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
      var i = k - j;
      var a = self.words[i] | 0;
      var b = num.words[j] | 0;
      var r = a * b;

      var lo = r & 0x3ffffff;
      ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
      lo = (lo + rword) | 0;
      rword = lo & 0x3ffffff;
      ncarry = (ncarry + (lo >>> 26)) | 0;

      hncarry += ncarry >>> 26;
      ncarry &= 0x3ffffff;
    }
    out.words[k] = rword;
    carry = ncarry;
    ncarry = hncarry;
  }
  if (carry !== 0) {
    out.words[k] = carry;
  } else {
    out.length--;
  }

  return out.strip();
}

function jumboMulTo(self, num, out) {
  var fftm = new FFTM();
  return fftm.mulp(self, num, out);
}

BN.prototype.mulTo = function mulTo(num, out) {
  var res;
  var len = this.length + num.length;
  if (this.length === 10 && num.length === 10)
    res = comb10MulTo(this, num, out);
  else if (len < 63)
    res = smallMulTo(this, num, out);
  else if (len < 1024)
    res = bigMulTo(this, num, out);
  else
    res = jumboMulTo(this, num, out);
  return res;
};

// Cooley-Tukey algorithm for FFT
// slightly revisited to rely on looping instead of recursion

function FFTM(x, y) {
  this.x = x;
  this.y = y;
}

FFTM.prototype.makeRBT = function makeRBT(N) {
  var t = new Array(N);
  var l = BN.prototype._countBits(N) - 1;
  for (var i = 0; i < N; i++) {
    t[i] = this.revBin(i, l, N);
  }

  return t;
};

// Returns binary-reversed representation of `x`
FFTM.prototype.revBin = function revBin(x, l, N) {
  if (x === 0 || x === N - 1)
    return x;

  var rb = 0;
  for (var i = 0; i < l; i++) {
    rb |= (x & 1) << (l - i - 1);
    x >>= 1;
  }

  return rb;
};

// Performs "tweedling" phase, therefore 'emulating'
// behaviour of the recursive algorithm
FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
  for (var i = 0; i < N; i++) {
    rtws[i] = rws[rbt[i]];
    itws[i] = iws[rbt[i]];
  }
};

FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
  this.permute(rbt, rws, iws, rtws, itws, N);

  for (var s = 1; s < N; s <<= 1) {
    var l = s << 1;

    var rtwdf = Math.cos(2 * Math.PI / l);
    var itwdf = Math.sin(2 * Math.PI / l);

    for (var p = 0; p < N; p += l) {
      var rtwdf_ = rtwdf;
      var itwdf_ = itwdf;

      for (var j = 0; j < s; j++) {
        var re = rtws[p + j];
        var ie = itws[p + j];

        var ro = rtws[p + j + s];
        var io = itws[p + j + s];

        var rx = rtwdf_ * ro - itwdf_ * io;

        io = rtwdf_ * io + itwdf_ * ro;
        ro = rx;

        rtws[p + j] = re + ro;
        itws[p + j] = ie + io;

        rtws[p + j + s] = re - ro;
        itws[p + j + s] = ie - io;

        /* jshint maxdepth : false */
        if (j !== l) {
          rx = rtwdf * rtwdf_ - itwdf * itwdf_;

          itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
          rtwdf_ = rx;
        }
      }
    }
  }
};

FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
  var N = Math.max(m, n) | 1;
  var odd = N & 1;
  var i = 0;
  for (N = N / 2 | 0; N; N = N >>> 1) {
    i++;
  }

  return 1 << i + 1 + odd;
};

FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
  if (N <= 1)
    return;

  for (var i = 0; i < N / 2; i++) {
    var t = rws[i];

    rws[i] = rws[N - i - 1];
    rws[N - i - 1] = t;

    t = iws[i];

    iws[i] = -iws[N - i - 1];
    iws[N - i - 1] = -t;
  }
};

FFTM.prototype.normalize13b = function normalize13b(ws, N) {
  var carry = 0;
  for (var i = 0; i < N / 2; i++) {
    var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
            Math.round(ws[2 * i] / N) +
            carry;

    ws[i] = w & 0x3ffffff;

    if (w < 0x4000000) {
      carry = 0;
    } else {
      carry = w / 0x4000000 | 0;
    }
  }

  return ws;
};

FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
  var carry = 0;
  for (var i = 0; i < len; i++) {
    var carry = carry + (ws[i] | 0);

    rws[2 * i]     = carry & 0x1fff; carry = carry >>> 13;
    rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
  }

  // Pad with zeroes
  for (var i = 2 * len; i < N; ++i)
    rws[i] = 0;

  assert(carry === 0);
  assert((carry & ~0x1fff) === 0);
};

FFTM.prototype.stub = function stub(N) {
  var ph = new Array(N);
  for (var i = 0; i < N; i++)
    ph[i] = 0;

  return ph;
};

FFTM.prototype.mulp = function mulp(x, y, out) {
  var N = 2 * this.guessLen13b(x.length, y.length);

  var rbt = this.makeRBT(N);

  var _ = this.stub(N);

  var rws   = new Array(N);
  var rwst  = new Array(N);
  var iwst  = new Array(N);

  var nrws  = new Array(N);
  var nrwst = new Array(N);
  var niwst = new Array(N);

  var rmws = out.words;
  rmws.length = N;

  this.convert13b(x.words, x.length, rws, N);
  this.convert13b(y.words, y.length, nrws, N);

  this.transform(rws, _, rwst, iwst, N, rbt);
  this.transform(nrws, _, nrwst, niwst, N, rbt);

  for (var i = 0; i < N; i++) {
    var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
    iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
    rwst[i] = rx;
  }

  this.conjugate(rwst, iwst, N);

  this.transform(rwst, iwst, rmws, _, N, rbt);

  this.conjugate(rmws, _, N);

  this.normalize13b(rmws, N);

  out.negative = x.negative ^ y.negative;
  out.length = x.length + y.length;
  return out.strip();
};

// Multiply `this` by `num`
BN.prototype.mul = function mul(num) {
  var out = new BN(null);
  out.words = new Array(this.length + num.length);
  return this.mulTo(num, out);
};

// Multiply employing FFT
BN.prototype.mulf = function mulf(num) {
  var out = new BN(null);
  out.words = new Array(this.length + num.length);
  return jumboMulTo(this, num, out);
};

// In-place Multiplication
BN.prototype.imul = function imul(num) {
  return this.clone().mulTo(num, this);
};

BN.prototype.imuln = function imuln(num) {
  assert(typeof num === 'number');

  // Carry
  var carry = 0;
  for (var i = 0; i < this.length; i++) {
    var w = (this.words[i] | 0) * num;
    var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
    carry >>= 26;
    carry += (w / 0x4000000) | 0;
    // NOTE: lo is 27bit maximum
    carry += lo >>> 26;
    this.words[i] = lo & 0x3ffffff;
  }

  if (carry !== 0) {
    this.words[i] = carry;
    this.length++;
  }

  return this;
};

BN.prototype.muln = function muln(num) {
  return this.clone().imuln(num);
};

// `this` * `this`
BN.prototype.sqr = function sqr() {
  return this.mul(this);
};

// `this` * `this` in-place
BN.prototype.isqr = function isqr() {
  return this.imul(this.clone());
};

// Math.pow(`this`, `num`)
BN.prototype.pow = function pow(num) {
  var w = toBitArray(num);
  if (w.length === 0)
    return new BN(1);

  // Skip leading zeroes
  var res = this;
  for (var i = 0; i < w.length; i++, res = res.sqr())
    if (w[i] !== 0)
      break;

  if (++i < w.length) {
    for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
      if (w[i] === 0)
        continue;
      res = res.mul(q);
    }
  }

  return res;
};

// Shift-left in-place
BN.prototype.iushln = function iushln(bits) {
  assert(typeof bits === 'number' && bits >= 0);
  var r = bits % 26;
  var s = (bits - r) / 26;
  var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);

  if (r !== 0) {
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var newCarry = this.words[i] & carryMask;
      var c = ((this.words[i] | 0) - newCarry) << r;
      this.words[i] = c | carry;
      carry = newCarry >>> (26 - r);
    }
    if (carry) {
      this.words[i] = carry;
      this.length++;
    }
  }

  if (s !== 0) {
    for (var i = this.length - 1; i >= 0; i--)
      this.words[i + s] = this.words[i];
    for (var i = 0; i < s; i++)
      this.words[i] = 0;
    this.length += s;
  }

  return this.strip();
};

BN.prototype.ishln = function ishln(bits) {
  // TODO(indutny): implement me
  assert(this.negative === 0);
  return this.iushln(bits);
};

// Shift-right in-place
// NOTE: `hint` is a lowest bit before trailing zeroes
// NOTE: if `extended` is present - it will be filled with destroyed bits
BN.prototype.iushrn = function iushrn(bits, hint, extended) {
  assert(typeof bits === 'number' && bits >= 0);
  var h;
  if (hint)
    h = (hint - (hint % 26)) / 26;
  else
    h = 0;

  var r = bits % 26;
  var s = Math.min((bits - r) / 26, this.length);
  var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
  var maskedWords = extended;

  h -= s;
  h = Math.max(0, h);

  // Extended mode, copy masked part
  if (maskedWords) {
    for (var i = 0; i < s; i++)
      maskedWords.words[i] = this.words[i];
    maskedWords.length = s;
  }

  if (s === 0) {
    // No-op, we should not move anything at all
  } else if (this.length > s) {
    this.length -= s;
    for (var i = 0; i < this.length; i++)
      this.words[i] = this.words[i + s];
  } else {
    this.words[0] = 0;
    this.length = 1;
  }

  var carry = 0;
  for (var i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
    var word = this.words[i] | 0;
    this.words[i] = (carry << (26 - r)) | (word >>> r);
    carry = word & mask;
  }

  // Push carried bits as a mask
  if (maskedWords && carry !== 0)
    maskedWords.words[maskedWords.length++] = carry;

  if (this.length === 0) {
    this.words[0] = 0;
    this.length = 1;
  }

  return this.strip();
};

BN.prototype.ishrn = function ishrn(bits, hint, extended) {
  // TODO(indutny): implement me
  assert(this.negative === 0);
  return this.iushrn(bits, hint, extended);
};

// Shift-left
BN.prototype.shln = function shln(bits) {
  return this.clone().ishln(bits);
};

BN.prototype.ushln = function ushln(bits) {
  return this.clone().iushln(bits);
};

// Shift-right
BN.prototype.shrn = function shrn(bits) {
  return this.clone().ishrn(bits);
};

BN.prototype.ushrn = function ushrn(bits) {
  return this.clone().iushrn(bits);
};

// Test if n bit is set
BN.prototype.testn = function testn(bit) {
  assert(typeof bit === 'number' && bit >= 0);
  var r = bit % 26;
  var s = (bit - r) / 26;
  var q = 1 << r;

  // Fast case: bit is much higher than all existing words
  if (this.length <= s) {
    return false;
  }

  // Check bit and return
  var w = this.words[s];

  return !!(w & q);
};

// Return only lowers bits of number (in-place)
BN.prototype.imaskn = function imaskn(bits) {
  assert(typeof bits === 'number' && bits >= 0);
  var r = bits % 26;
  var s = (bits - r) / 26;

  assert(this.negative === 0, 'imaskn works only with positive numbers');

  if (r !== 0)
    s++;
  this.length = Math.min(s, this.length);

  if (r !== 0) {
    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    this.words[this.length - 1] &= mask;
  }

  return this.strip();
};

// Return only lowers bits of number
BN.prototype.maskn = function maskn(bits) {
  return this.clone().imaskn(bits);
};

// Add plain number `num` to `this`
BN.prototype.iaddn = function iaddn(num) {
  assert(typeof num === 'number');
  if (num < 0)
    return this.isubn(-num);

  // Possible sign change
  if (this.negative !== 0) {
    if (this.length === 1 && (this.words[0] | 0) < num) {
      this.words[0] = num - (this.words[0] | 0);
      this.negative = 0;
      return this;
    }

    this.negative = 0;
    this.isubn(num);
    this.negative = 1;
    return this;
  }

  // Add without checks
  return this._iaddn(num);
};

BN.prototype._iaddn = function _iaddn(num) {
  this.words[0] += num;

  // Carry
  for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
    this.words[i] -= 0x4000000;
    if (i === this.length - 1)
      this.words[i + 1] = 1;
    else
      this.words[i + 1]++;
  }
  this.length = Math.max(this.length, i + 1);

  return this;
};

// Subtract plain number `num` from `this`
BN.prototype.isubn = function isubn(num) {
  assert(typeof num === 'number');
  if (num < 0)
    return this.iaddn(-num);

  if (this.negative !== 0) {
    this.negative = 0;
    this.iaddn(num);
    this.negative = 1;
    return this;
  }

  this.words[0] -= num;

  if (this.length === 1 && this.words[0] < 0) {
    this.words[0] = -this.words[0];
    this.negative = 1;
  } else {
    // Carry
    for (var i = 0; i < this.length && this.words[i] < 0; i++) {
      this.words[i] += 0x4000000;
      this.words[i + 1] -= 1;
    }
  }

  return this.strip();
};

BN.prototype.addn = function addn(num) {
  return this.clone().iaddn(num);
};

BN.prototype.subn = function subn(num) {
  return this.clone().isubn(num);
};

BN.prototype.iabs = function iabs() {
  this.negative = 0;

  return this;
};

BN.prototype.abs = function abs() {
  return this.clone().iabs();
};

BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
  // Bigger storage is needed
  var len = num.length + shift;
  var i;
  if (this.words.length < len) {
    var t = new Array(len);
    for (var i = 0; i < this.length; i++)
      t[i] = this.words[i];
    this.words = t;
  } else {
    i = this.length;
  }

  // Zeroify rest
  this.length = Math.max(this.length, len);
  for (; i < this.length; i++)
    this.words[i] = 0;

  var carry = 0;
  for (var i = 0; i < num.length; i++) {
    var w = (this.words[i + shift] | 0) + carry;
    var right = (num.words[i] | 0) * mul;
    w -= right & 0x3ffffff;
    carry = (w >> 26) - ((right / 0x4000000) | 0);
    this.words[i + shift] = w & 0x3ffffff;
  }
  for (; i < this.length - shift; i++) {
    var w = (this.words[i + shift] | 0) + carry;
    carry = w >> 26;
    this.words[i + shift] = w & 0x3ffffff;
  }

  if (carry === 0)
    return this.strip();

  // Subtraction overflow
  assert(carry === -1);
  carry = 0;
  for (var i = 0; i < this.length; i++) {
    var w = -(this.words[i] | 0) + carry;
    carry = w >> 26;
    this.words[i] = w & 0x3ffffff;
  }
  this.negative = 1;

  return this.strip();
};

BN.prototype._wordDiv = function _wordDiv(num, mode) {
  var shift = this.length - num.length;

  var a = this.clone();
  var b = num;

  // Normalize
  var bhi = b.words[b.length - 1] | 0;
  var bhiBits = this._countBits(bhi);
  shift = 26 - bhiBits;
  if (shift !== 0) {
    b = b.ushln(shift);
    a.iushln(shift);
    bhi = b.words[b.length - 1] | 0;
  }

  // Initialize quotient
  var m = a.length - b.length;
  var q;

  if (mode !== 'mod') {
    q = new BN(null);
    q.length = m + 1;
    q.words = new Array(q.length);
    for (var i = 0; i < q.length; i++)
      q.words[i] = 0;
  }

  var diff = a.clone()._ishlnsubmul(b, 1, m);
  if (diff.negative === 0) {
    a = diff;
    if (q)
      q.words[m] = 1;
  }

  for (var j = m - 1; j >= 0; j--) {
    var qj = (a.words[b.length + j] | 0) * 0x4000000 +
             (a.words[b.length + j - 1] | 0);

    // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
    // (0x7ffffff)
    qj = Math.min((qj / bhi) | 0, 0x3ffffff);

    a._ishlnsubmul(b, qj, j);
    while (a.negative !== 0) {
      qj--;
      a.negative = 0;
      a._ishlnsubmul(b, 1, j);
      if (a.cmpn(0) !== 0)
        a.negative ^= 1;
    }
    if (q)
      q.words[j] = qj;
  }
  if (q)
    q.strip();
  a.strip();

  // Denormalize
  if (mode !== 'div' && shift !== 0)
    a.iushrn(shift);
  return { div: q ? q : null, mod: a };
};

BN.prototype.divmod = function divmod(num, mode, positive) {
  assert(num.cmpn(0) !== 0);

  if (this.negative !== 0 && num.negative === 0) {
    var res = this.neg().divmod(num, mode);
    var div;
    var mod;
    if (mode !== 'mod')
      div = res.div.neg();
    if (mode !== 'div') {
      mod = res.mod.neg();
      if (positive && mod.neg)
        mod = mod.add(num);
    }
    return {
      div: div,
      mod: mod
    };
  } else if (this.negative === 0 && num.negative !== 0) {
    var res = this.divmod(num.neg(), mode);
    var div;
    if (mode !== 'mod')
      div = res.div.neg();
    return { div: div, mod: res.mod };
  } else if ((this.negative & num.negative) !== 0) {
    var res = this.neg().divmod(num.neg(), mode);
    var mod;
    if (mode !== 'div') {
      mod = res.mod.neg();
      if (positive && mod.neg)
        mod = mod.isub(num);
    }
    return {
      div: res.div,
      mod: mod
    };
  }

  // Both numbers are positive at this point

  // Strip both numbers to approximate shift value
  if (num.length > this.length || this.cmp(num) < 0)
    return { div: new BN(0), mod: this };

  // Very short reduction
  if (num.length === 1) {
    if (mode === 'div')
      return { div: this.divn(num.words[0]), mod: null };
    else if (mode === 'mod')
      return { div: null, mod: new BN(this.modn(num.words[0])) };
    return {
      div: this.divn(num.words[0]),
      mod: new BN(this.modn(num.words[0]))
    };
  }

  return this._wordDiv(num, mode);
};

// Find `this` / `num`
BN.prototype.div = function div(num) {
  return this.divmod(num, 'div', false).div;
};

// Find `this` % `num`
BN.prototype.mod = function mod(num) {
  return this.divmod(num, 'mod', false).mod;
};

BN.prototype.umod = function umod(num) {
  return this.divmod(num, 'mod', true).mod;
};

// Find Round(`this` / `num`)
BN.prototype.divRound = function divRound(num) {
  var dm = this.divmod(num);

  // Fast case - exact division
  if (dm.mod.cmpn(0) === 0)
    return dm.div;

  var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

  var half = num.ushrn(1);
  var r2 = num.andln(1);
  var cmp = mod.cmp(half);

  // Round down
  if (cmp < 0 || r2 === 1 && cmp === 0)
    return dm.div;

  // Round up
  return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
};

BN.prototype.modn = function modn(num) {
  assert(num <= 0x3ffffff);
  var p = (1 << 26) % num;

  var acc = 0;
  for (var i = this.length - 1; i >= 0; i--)
    acc = (p * acc + (this.words[i] | 0)) % num;

  return acc;
};

// In-place division by number
BN.prototype.idivn = function idivn(num) {
  assert(num <= 0x3ffffff);

  var carry = 0;
  for (var i = this.length - 1; i >= 0; i--) {
    var w = (this.words[i] | 0) + carry * 0x4000000;
    this.words[i] = (w / num) | 0;
    carry = w % num;
  }

  return this.strip();
};

BN.prototype.divn = function divn(num) {
  return this.clone().idivn(num);
};

BN.prototype.egcd = function egcd(p) {
  assert(p.negative === 0);
  assert(p.cmpn(0) !== 0);

  var x = this;
  var y = p.clone();

  if (x.negative !== 0)
    x = x.umod(p);
  else
    x = x.clone();

  // A * x + B * y = x
  var A = new BN(1);
  var B = new BN(0);

  // C * x + D * y = y
  var C = new BN(0);
  var D = new BN(1);

  var g = 0;

  while (x.isEven() && y.isEven()) {
    x.iushrn(1);
    y.iushrn(1);
    ++g;
  }

  var yp = y.clone();
  var xp = x.clone();

  while (x.cmpn(0) !== 0) {
    while (x.isEven()) {
      x.iushrn(1);
      if (A.isEven() && B.isEven()) {
        A.iushrn(1);
        B.iushrn(1);
      } else {
        A.iadd(yp).iushrn(1);
        B.isub(xp).iushrn(1);
      }
    }

    while (y.isEven()) {
      y.iushrn(1);
      if (C.isEven() && D.isEven()) {
        C.iushrn(1);
        D.iushrn(1);
      } else {
        C.iadd(yp).iushrn(1);
        D.isub(xp).iushrn(1);
      }
    }

    if (x.cmp(y) >= 0) {
      x.isub(y);
      A.isub(C);
      B.isub(D);
    } else {
      y.isub(x);
      C.isub(A);
      D.isub(B);
    }
  }

  return {
    a: C,
    b: D,
    gcd: y.iushln(g)
  };
};

// This is reduced incarnation of the binary EEA
// above, designated to invert members of the
// _prime_ fields F(p) at a maximal speed
BN.prototype._invmp = function _invmp(p) {
  assert(p.negative === 0);
  assert(p.cmpn(0) !== 0);

  var a = this;
  var b = p.clone();

  if (a.negative !== 0)
    a = a.umod(p);
  else
    a = a.clone();

  var x1 = new BN(1);
  var x2 = new BN(0);

  var delta = b.clone();

  while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
    while (a.isEven()) {
      a.iushrn(1);
      if (x1.isEven())
        x1.iushrn(1);
      else
        x1.iadd(delta).iushrn(1);
    }
    while (b.isEven()) {
      b.iushrn(1);
      if (x2.isEven())
        x2.iushrn(1);
      else
        x2.iadd(delta).iushrn(1);
    }
    if (a.cmp(b) >= 0) {
      a.isub(b);
      x1.isub(x2);
    } else {
      b.isub(a);
      x2.isub(x1);
    }
  }

  var res;
  if (a.cmpn(1) === 0)
    res = x1;
  else
    res = x2;

  if (res.cmpn(0) < 0)
    res.iadd(p);

  return res;
};

BN.prototype.gcd = function gcd(num) {
  if (this.cmpn(0) === 0)
    return num.clone();
  if (num.cmpn(0) === 0)
    return this.clone();

  var a = this.clone();
  var b = num.clone();
  a.negative = 0;
  b.negative = 0;

  // Remove common factor of two
  for (var shift = 0; a.isEven() && b.isEven(); shift++) {
    a.iushrn(1);
    b.iushrn(1);
  }

  do {
    while (a.isEven())
      a.iushrn(1);
    while (b.isEven())
      b.iushrn(1);

    var r = a.cmp(b);
    if (r < 0) {
      // Swap `a` and `b` to make `a` always bigger than `b`
      var t = a;
      a = b;
      b = t;
    } else if (r === 0 || b.cmpn(1) === 0) {
      break;
    }

    a.isub(b);
  } while (true);

  return b.iushln(shift);
};

// Invert number in the field F(num)
BN.prototype.invm = function invm(num) {
  return this.egcd(num).a.umod(num);
};

BN.prototype.isEven = function isEven() {
  return (this.words[0] & 1) === 0;
};

BN.prototype.isOdd = function isOdd() {
  return (this.words[0] & 1) === 1;
};

// And first word and num
BN.prototype.andln = function andln(num) {
  return this.words[0] & num;
};

// Increment at the bit position in-line
BN.prototype.bincn = function bincn(bit) {
  assert(typeof bit === 'number');
  var r = bit % 26;
  var s = (bit - r) / 26;
  var q = 1 << r;

  // Fast case: bit is much higher than all existing words
  if (this.length <= s) {
    for (var i = this.length; i < s + 1; i++)
      this.words[i] = 0;
    this.words[s] |= q;
    this.length = s + 1;
    return this;
  }

  // Add bit and propagate, if needed
  var carry = q;
  for (var i = s; carry !== 0 && i < this.length; i++) {
    var w = this.words[i] | 0;
    w += carry;
    carry = w >>> 26;
    w &= 0x3ffffff;
    this.words[i] = w;
  }
  if (carry !== 0) {
    this.words[i] = carry;
    this.length++;
  }
  return this;
};

BN.prototype.isZero = function isZero() {
  return this.length === 1 && this.words[0] === 0;
};

BN.prototype.cmpn = function cmpn(num) {
  var negative = num < 0;

  if (this.negative !== 0 && !negative)
    return -1;
  else if (this.negative === 0 && negative)
    return 1;

  this.strip();

  var res;
  if (this.length > 1) {
    res = 1;
  } else {
    if (negative)
      num = -num;
    assert(num <= 0x3ffffff, 'Number is too big');

    var w = this.words[0] | 0;
    res = w === num ? 0 : w < num ? -1 : 1;
  }
  if (this.negative !== 0)
    res = -res;
  return res;
};

// Compare two numbers and return:
// 1 - if `this` > `num`
// 0 - if `this` == `num`
// -1 - if `this` < `num`
BN.prototype.cmp = function cmp(num) {
  if (this.negative !== 0 && num.negative === 0)
    return -1;
  else if (this.negative === 0 && num.negative !== 0)
    return 1;

  var res = this.ucmp(num);
  if (this.negative !== 0)
    return -res;
  else
    return res;
};

// Unsigned comparison
BN.prototype.ucmp = function ucmp(num) {
  // At this point both numbers have the same sign
  if (this.length > num.length)
    return 1;
  else if (this.length < num.length)
    return -1;

  var res = 0;
  for (var i = this.length - 1; i >= 0; i--) {
    var a = this.words[i] | 0;
    var b = num.words[i] | 0;

    if (a === b)
      continue;
    if (a < b)
      res = -1;
    else if (a > b)
      res = 1;
    break;
  }
  return res;
};

//
// A reduce context, could be using montgomery or something better, depending
// on the `m` itself.
//
BN.red = function red(num) {
  return new Red(num);
};

BN.prototype.toRed = function toRed(ctx) {
  assert(!this.red, 'Already a number in reduction context');
  assert(this.negative === 0, 'red works only with positives');
  return ctx.convertTo(this)._forceRed(ctx);
};

BN.prototype.fromRed = function fromRed() {
  assert(this.red, 'fromRed works only with numbers in reduction context');
  return this.red.convertFrom(this);
};

BN.prototype._forceRed = function _forceRed(ctx) {
  this.red = ctx;
  return this;
};

BN.prototype.forceRed = function forceRed(ctx) {
  assert(!this.red, 'Already a number in reduction context');
  return this._forceRed(ctx);
};

BN.prototype.redAdd = function redAdd(num) {
  assert(this.red, 'redAdd works only with red numbers');
  return this.red.add(this, num);
};

BN.prototype.redIAdd = function redIAdd(num) {
  assert(this.red, 'redIAdd works only with red numbers');
  return this.red.iadd(this, num);
};

BN.prototype.redSub = function redSub(num) {
  assert(this.red, 'redSub works only with red numbers');
  return this.red.sub(this, num);
};

BN.prototype.redISub = function redISub(num) {
  assert(this.red, 'redISub works only with red numbers');
  return this.red.isub(this, num);
};

BN.prototype.redShl = function redShl(num) {
  assert(this.red, 'redShl works only with red numbers');
  return this.red.ushl(this, num);
};

BN.prototype.redMul = function redMul(num) {
  assert(this.red, 'redMul works only with red numbers');
  this.red._verify2(this, num);
  return this.red.mul(this, num);
};

BN.prototype.redIMul = function redIMul(num) {
  assert(this.red, 'redMul works only with red numbers');
  this.red._verify2(this, num);
  return this.red.imul(this, num);
};

BN.prototype.redSqr = function redSqr() {
  assert(this.red, 'redSqr works only with red numbers');
  this.red._verify1(this);
  return this.red.sqr(this);
};

BN.prototype.redISqr = function redISqr() {
  assert(this.red, 'redISqr works only with red numbers');
  this.red._verify1(this);
  return this.red.isqr(this);
};

// Square root over p
BN.prototype.redSqrt = function redSqrt() {
  assert(this.red, 'redSqrt works only with red numbers');
  this.red._verify1(this);
  return this.red.sqrt(this);
};

BN.prototype.redInvm = function redInvm() {
  assert(this.red, 'redInvm works only with red numbers');
  this.red._verify1(this);
  return this.red.invm(this);
};

// Return negative clone of `this` % `red modulo`
BN.prototype.redNeg = function redNeg() {
  assert(this.red, 'redNeg works only with red numbers');
  this.red._verify1(this);
  return this.red.neg(this);
};

BN.prototype.redPow = function redPow(num) {
  assert(this.red && !num.red, 'redPow(normalNum)');
  this.red._verify1(this);
  return this.red.pow(this, num);
};

// Prime numbers with efficient reduction
var primes = {
  k256: null,
  p224: null,
  p192: null,
  p25519: null
};

// Pseudo-Mersenne prime
function MPrime(name, p) {
  // P = 2 ^ N - K
  this.name = name;
  this.p = new BN(p, 16);
  this.n = this.p.bitLength();
  this.k = new BN(1).iushln(this.n).isub(this.p);

  this.tmp = this._tmp();
}

MPrime.prototype._tmp = function _tmp() {
  var tmp = new BN(null);
  tmp.words = new Array(Math.ceil(this.n / 13));
  return tmp;
};

MPrime.prototype.ireduce = function ireduce(num) {
  // Assumes that `num` is less than `P^2`
  // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
  var r = num;
  var rlen;

  do {
    this.split(r, this.tmp);
    r = this.imulK(r);
    r = r.iadd(this.tmp);
    rlen = r.bitLength();
  } while (rlen > this.n);

  var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
  if (cmp === 0) {
    r.words[0] = 0;
    r.length = 1;
  } else if (cmp > 0) {
    r.isub(this.p);
  } else {
    r.strip();
  }

  return r;
};

MPrime.prototype.split = function split(input, out) {
  input.iushrn(this.n, 0, out);
};

MPrime.prototype.imulK = function imulK(num) {
  return num.imul(this.k);
};

function K256() {
  MPrime.call(
    this,
    'k256',
    'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
}
inherits(K256, MPrime);

K256.prototype.split = function split(input, output) {
  // 256 = 9 * 26 + 22
  var mask = 0x3fffff;

  var outLen = Math.min(input.length, 9);
  for (var i = 0; i < outLen; i++)
    output.words[i] = input.words[i];
  output.length = outLen;

  if (input.length <= 9) {
    input.words[0] = 0;
    input.length = 1;
    return;
  }

  // Shift by 9 limbs
  var prev = input.words[9];
  output.words[output.length++] = prev & mask;

  for (var i = 10; i < input.length; i++) {
    var next = input.words[i] | 0;
    input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
    prev = next;
  }
  input.words[i - 10] = prev >>> 22;
  input.length -= 9;
};

K256.prototype.imulK = function imulK(num) {
  // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
  num.words[num.length] = 0;
  num.words[num.length + 1] = 0;
  num.length += 2;

  // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
  var hi;
  var lo = 0;
  for (var i = 0; i < num.length; i++) {
    var w = num.words[i] | 0;
    hi = w * 0x40;
    lo += w * 0x3d1;
    hi += (lo / 0x4000000) | 0;
    lo &= 0x3ffffff;

    num.words[i] = lo;

    lo = hi;
  }

  // Fast length reduction
  if (num.words[num.length - 1] === 0) {
    num.length--;
    if (num.words[num.length - 1] === 0)
      num.length--;
  }
  return num;
};

function P224() {
  MPrime.call(
    this,
    'p224',
    'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
}
inherits(P224, MPrime);

function P192() {
  MPrime.call(
    this,
    'p192',
    'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
}
inherits(P192, MPrime);

function P25519() {
  // 2 ^ 255 - 19
  MPrime.call(
    this,
    '25519',
    '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
}
inherits(P25519, MPrime);

P25519.prototype.imulK = function imulK(num) {
  // K = 0x13
  var carry = 0;
  for (var i = 0; i < num.length; i++) {
    var hi = (num.words[i] | 0) * 0x13 + carry;
    var lo = hi & 0x3ffffff;
    hi >>>= 26;

    num.words[i] = lo;
    carry = hi;
  }
  if (carry !== 0)
    num.words[num.length++] = carry;
  return num;
};

// Exported mostly for testing purposes, use plain name instead
BN._prime = function prime(name) {
  // Cached version of prime
  if (primes[name])
    return primes[name];

  var prime;
  if (name === 'k256')
    prime = new K256();
  else if (name === 'p224')
    prime = new P224();
  else if (name === 'p192')
    prime = new P192();
  else if (name === 'p25519')
    prime = new P25519();
  else
    throw new Error('Unknown prime ' + name);
  primes[name] = prime;

  return prime;
};

//
// Base reduction engine
//
function Red(m) {
  if (typeof m === 'string') {
    var prime = BN._prime(m);
    this.m = prime.p;
    this.prime = prime;
  } else {
    this.m = m;
    this.prime = null;
  }
}

Red.prototype._verify1 = function _verify1(a) {
  assert(a.negative === 0, 'red works only with positives');
  assert(a.red, 'red works only with red numbers');
};

Red.prototype._verify2 = function _verify2(a, b) {
  assert((a.negative | b.negative) === 0, 'red works only with positives');
  assert(a.red && a.red === b.red,
         'red works only with red numbers');
};

Red.prototype.imod = function imod(a) {
  if (this.prime)
    return this.prime.ireduce(a)._forceRed(this);
  return a.umod(this.m)._forceRed(this);
};

Red.prototype.neg = function neg(a) {
  var r = a.clone();
  r.negative ^= 1;
  return r.iadd(this.m)._forceRed(this);
};

Red.prototype.add = function add(a, b) {
  this._verify2(a, b);

  var res = a.add(b);
  if (res.cmp(this.m) >= 0)
    res.isub(this.m);
  return res._forceRed(this);
};

Red.prototype.iadd = function iadd(a, b) {
  this._verify2(a, b);

  var res = a.iadd(b);
  if (res.cmp(this.m) >= 0)
    res.isub(this.m);
  return res;
};

Red.prototype.sub = function sub(a, b) {
  this._verify2(a, b);

  var res = a.sub(b);
  if (res.cmpn(0) < 0)
    res.iadd(this.m);
  return res._forceRed(this);
};

Red.prototype.isub = function isub(a, b) {
  this._verify2(a, b);

  var res = a.isub(b);
  if (res.cmpn(0) < 0)
    res.iadd(this.m);
  return res;
};

Red.prototype.shl = function shl(a, num) {
  this._verify1(a);
  return this.imod(a.ushln(num));
};

Red.prototype.imul = function imul(a, b) {
  this._verify2(a, b);
  return this.imod(a.imul(b));
};

Red.prototype.mul = function mul(a, b) {
  this._verify2(a, b);
  return this.imod(a.mul(b));
};

Red.prototype.isqr = function isqr(a) {
  return this.imul(a, a);
};

Red.prototype.sqr = function sqr(a) {
  return this.mul(a, a);
};

Red.prototype.sqrt = function sqrt(a) {
  if (a.cmpn(0) === 0)
    return a.clone();

  var mod3 = this.m.andln(3);
  assert(mod3 % 2 === 1);

  // Fast case
  if (mod3 === 3) {
    var pow = this.m.add(new BN(1)).iushrn(2);
    var r = this.pow(a, pow);
    return r;
  }

  // Tonelli-Shanks algorithm (Totally unoptimized and slow)
  //
  // Find Q and S, that Q * 2 ^ S = (P - 1)
  var q = this.m.subn(1);
  var s = 0;
  while (q.cmpn(0) !== 0 && q.andln(1) === 0) {
    s++;
    q.iushrn(1);
  }
  assert(q.cmpn(0) !== 0);

  var one = new BN(1).toRed(this);
  var nOne = one.redNeg();

  // Find quadratic non-residue
  // NOTE: Max is such because of generalized Riemann hypothesis.
  var lpow = this.m.subn(1).iushrn(1);
  var z = this.m.bitLength();
  z = new BN(2 * z * z).toRed(this);
  while (this.pow(z, lpow).cmp(nOne) !== 0)
    z.redIAdd(nOne);

  var c = this.pow(z, q);
  var r = this.pow(a, q.addn(1).iushrn(1));
  var t = this.pow(a, q);
  var m = s;
  while (t.cmp(one) !== 0) {
    var tmp = t;
    for (var i = 0; tmp.cmp(one) !== 0; i++)
      tmp = tmp.redSqr();
    assert(i < m);
    var b = this.pow(c, new BN(1).iushln(m - i - 1));

    r = r.redMul(b);
    c = b.redSqr();
    t = t.redMul(c);
    m = i;
  }

  return r;
};

Red.prototype.invm = function invm(a) {
  var inv = a._invmp(this.m);
  if (inv.negative !== 0) {
    inv.negative = 0;
    return this.imod(inv).redNeg();
  } else {
    return this.imod(inv);
  }
};

Red.prototype.pow = function pow(a, num) {
  if (num.cmpn(0) === 0)
    return new BN(1);
  if (num.cmpn(1) === 0)
    return a.clone();

  var windowSize = 4;
  var wnd = new Array(1 << windowSize);
  wnd[0] = new BN(1).toRed(this);
  wnd[1] = a;
  for (var i = 2; i < wnd.length; i++)
    wnd[i] = this.mul(wnd[i - 1], a);

  var res = wnd[0];
  var current = 0;
  var currentLen = 0;
  var start = num.bitLength() % 26;
  if (start === 0)
    start = 26;
  for (var i = num.length - 1; i >= 0; i--) {
    var word = num.words[i];
    for (var j = start - 1; j >= 0; j--) {
      var bit = (word >> j) & 1;
      if (res !== wnd[0])
        res = this.sqr(res);
      if (bit === 0 && current === 0) {
        currentLen = 0;
        continue;
      }

      current <<= 1;
      current |= bit;
      currentLen++;
      if (currentLen !== windowSize && (i !== 0 || j !== 0))
        continue;

      res = this.mul(res, wnd[current]);
      currentLen = 0;
      current = 0;
    }
    start = 26;
  }

  return res;
};

Red.prototype.convertTo = function convertTo(num) {
  var r = num.umod(this.m);
  if (r === num)
    return r.clone();
  else
    return r;
};

Red.prototype.convertFrom = function convertFrom(num) {
  var res = num.clone();
  res.red = null;
  return res;
};

//
// Montgomery method engine
//

BN.mont = function mont(num) {
  return new Mont(num);
};

function Mont(m) {
  Red.call(this, m);

  this.shift = this.m.bitLength();
  if (this.shift % 26 !== 0)
    this.shift += 26 - (this.shift % 26);
  this.r = new BN(1).iushln(this.shift);
  this.r2 = this.imod(this.r.sqr());
  this.rinv = this.r._invmp(this.m);

  this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
  this.minv = this.minv.umod(this.r);
  this.minv = this.r.sub(this.minv);
}
inherits(Mont, Red);

Mont.prototype.convertTo = function convertTo(num) {
  return this.imod(num.ushln(this.shift));
};

Mont.prototype.convertFrom = function convertFrom(num) {
  var r = this.imod(num.mul(this.rinv));
  r.red = null;
  return r;
};

Mont.prototype.imul = function imul(a, b) {
  if (a.cmpn(0) === 0 || b.cmpn(0) === 0) {
    a.words[0] = 0;
    a.length = 1;
    return a;
  }

  var t = a.imul(b);
  var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
  var u = t.isub(c).iushrn(this.shift);
  var res = u;
  if (u.cmp(this.m) >= 0)
    res = u.isub(this.m);
  else if (u.cmpn(0) < 0)
    res = u.iadd(this.m);

  return res._forceRed(this);
};

Mont.prototype.mul = function mul(a, b) {
  if (a.cmpn(0) === 0 || b.cmpn(0) === 0)
    return new BN(0)._forceRed(this);

  var t = a.mul(b);
  var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
  var u = t.isub(c).iushrn(this.shift);
  var res = u;
  if (u.cmp(this.m) >= 0)
    res = u.isub(this.m);
  else if (u.cmpn(0) < 0)
    res = u.iadd(this.m);

  return res._forceRed(this);
};

Mont.prototype.invm = function invm(a) {
  // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
  var res = this.imod(a._invmp(this.m).mul(this.r2));
  return res._forceRed(this);
};

})(typeof module === 'undefined' || module, this);

},{}],189:[function(require,module,exports){
(function (Buffer){
var bn = require('bn.js');
var randomBytes = require('randombytes');
module.exports = crt;
function blind(priv) {
  var r = getr(priv);
  var blinder = r.toRed(bn.mont(priv.modulus))
  .redPow(new bn(priv.publicExponent)).fromRed();
  return {
    blinder: blinder,
    unblinder:r.invm(priv.modulus)
  };
}
function crt(msg, priv) {
  var blinds = blind(priv);
  var len = priv.modulus.byteLength();
  var mod = bn.mont(priv.modulus);
  var blinded = new bn(msg).mul(blinds.blinder).umod(priv.modulus);
  var c1 = blinded.toRed(bn.mont(priv.prime1));
  var c2 = blinded.toRed(bn.mont(priv.prime2));
  var qinv = priv.coefficient;
  var p = priv.prime1;
  var q = priv.prime2;
  var m1 = c1.redPow(priv.exponent1);
  var m2 = c2.redPow(priv.exponent2);
  m1 = m1.fromRed();
  m2 = m2.fromRed();
  var h = m1.isub(m2).imul(qinv).umod(p);
  h.imul(q);
  m2.iadd(h);
  return new Buffer(m2.imul(blinds.unblinder).umod(priv.modulus).toArray(false, len));
}
crt.getr = getr;
function getr(priv) {
  var len = priv.modulus.byteLength();
  var r = new bn(randomBytes(len));
  while (r.cmp(priv.modulus) >=  0 || !r.umod(priv.prime1) || !r.umod(priv.prime2)) {
    r = new bn(randomBytes(len));
  }
  return r;
}

}).call(this,require("buffer").Buffer)

},{"bn.js":188,"buffer":151,"randombytes":346}],190:[function(require,module,exports){
'use strict';

var elliptic = exports;

elliptic.version = require('../package.json').version;
elliptic.utils = require('./elliptic/utils');
elliptic.rand = require('brorand');
elliptic.hmacDRBG = require('./elliptic/hmac-drbg');
elliptic.curve = require('./elliptic/curve');
elliptic.curves = require('./elliptic/curves');

// Protocols
elliptic.ec = require('./elliptic/ec');
elliptic.eddsa = require('./elliptic/eddsa');

},{"../package.json":213,"./elliptic/curve":193,"./elliptic/curves":196,"./elliptic/ec":197,"./elliptic/eddsa":200,"./elliptic/hmac-drbg":203,"./elliptic/utils":205,"brorand":206}],191:[function(require,module,exports){
'use strict';

var bn = require('bn.js');
var elliptic = require('../../elliptic');
var utils = elliptic.utils;
var getNAF = utils.getNAF;
var getJSF = utils.getJSF;
var assert = utils.assert;

function BaseCurve(type, conf) {
  this.type = type;
  this.p = new bn(conf.p, 16);

  // Use Montgomery, when there is no fast reduction for the prime
  this.red = conf.prime ? bn.red(conf.prime) : bn.mont(this.p);

  // Useful for many curves
  this.zero = new bn(0).toRed(this.red);
  this.one = new bn(1).toRed(this.red);
  this.two = new bn(2).toRed(this.red);

  // Curve configuration, optional
  this.n = conf.n && new bn(conf.n, 16);
  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);

  // Temporary arrays
  this._wnafT1 = new Array(4);
  this._wnafT2 = new Array(4);
  this._wnafT3 = new Array(4);
  this._wnafT4 = new Array(4);
}
module.exports = BaseCurve;

BaseCurve.prototype.point = function point() {
  throw new Error('Not implemented');
};

BaseCurve.prototype.validate = function validate() {
  throw new Error('Not implemented');
};

BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
  assert(p.precomputed);
  var doubles = p._getDoubles();

  var naf = getNAF(k, 1);
  var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);
  I /= 3;

  // Translate into more windowed form
  var repr = [];
  for (var j = 0; j < naf.length; j += doubles.step) {
    var nafW = 0;
    for (var k = j + doubles.step - 1; k >= j; k--)
      nafW = (nafW << 1) + naf[k];
    repr.push(nafW);
  }

  var a = this.jpoint(null, null, null);
  var b = this.jpoint(null, null, null);
  for (var i = I; i > 0; i--) {
    for (var j = 0; j < repr.length; j++) {
      var nafW = repr[j];
      if (nafW === i)
        b = b.mixedAdd(doubles.points[j]);
      else if (nafW === -i)
        b = b.mixedAdd(doubles.points[j].neg());
    }
    a = a.add(b);
  }
  return a.toP();
};

BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
  var w = 4;

  // Precompute window
  var nafPoints = p._getNAFPoints(w);
  w = nafPoints.wnd;
  var wnd = nafPoints.points;

  // Get NAF form
  var naf = getNAF(k, w);

  // Add `this`*(N+1) for every w-NAF index
  var acc = this.jpoint(null, null, null);
  for (var i = naf.length - 1; i >= 0; i--) {
    // Count zeroes
    for (var k = 0; i >= 0 && naf[i] === 0; i--)
      k++;
    if (i >= 0)
      k++;
    acc = acc.dblp(k);

    if (i < 0)
      break;
    var z = naf[i];
    assert(z !== 0);
    if (p.type === 'affine') {
      // J +- P
      if (z > 0)
        acc = acc.mixedAdd(wnd[(z - 1) >> 1]);
      else
        acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());
    } else {
      // J +- J
      if (z > 0)
        acc = acc.add(wnd[(z - 1) >> 1]);
      else
        acc = acc.add(wnd[(-z - 1) >> 1].neg());
    }
  }
  return p.type === 'affine' ? acc.toP() : acc;
};

BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,
                                                       points,
                                                       coeffs,
                                                       len) {
  var wndWidth = this._wnafT1;
  var wnd = this._wnafT2;
  var naf = this._wnafT3;

  // Fill all arrays
  var max = 0;
  for (var i = 0; i < len; i++) {
    var p = points[i];
    var nafPoints = p._getNAFPoints(defW);
    wndWidth[i] = nafPoints.wnd;
    wnd[i] = nafPoints.points;
  }

  // Comb small window NAFs
  for (var i = len - 1; i >= 1; i -= 2) {
    var a = i - 1;
    var b = i;
    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
      naf[a] = getNAF(coeffs[a], wndWidth[a]);
      naf[b] = getNAF(coeffs[b], wndWidth[b]);
      max = Math.max(naf[a].length, max);
      max = Math.max(naf[b].length, max);
      continue;
    }

    var comb = [
      points[a], /* 1 */
      null, /* 3 */
      null, /* 5 */
      points[b] /* 7 */
    ];

    // Try to avoid Projective points, if possible
    if (points[a].y.cmp(points[b].y) === 0) {
      comb[1] = points[a].add(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].add(points[b].neg());
    } else {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    }

    var index = [
      -3, /* -1 -1 */
      -1, /* -1 0 */
      -5, /* -1 1 */
      -7, /* 0 -1 */
      0, /* 0 0 */
      7, /* 0 1 */
      5, /* 1 -1 */
      1, /* 1 0 */
      3  /* 1 1 */
    ];

    var jsf = getJSF(coeffs[a], coeffs[b]);
    max = Math.max(jsf[0].length, max);
    naf[a] = new Array(max);
    naf[b] = new Array(max);
    for (var j = 0; j < max; j++) {
      var ja = jsf[0][j] | 0;
      var jb = jsf[1][j] | 0;

      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
      naf[b][j] = 0;
      wnd[a] = comb;
    }
  }

  var acc = this.jpoint(null, null, null);
  var tmp = this._wnafT4;
  for (var i = max; i >= 0; i--) {
    var k = 0;

    while (i >= 0) {
      var zero = true;
      for (var j = 0; j < len; j++) {
        tmp[j] = naf[j][i] | 0;
        if (tmp[j] !== 0)
          zero = false;
      }
      if (!zero)
        break;
      k++;
      i--;
    }
    if (i >= 0)
      k++;
    acc = acc.dblp(k);
    if (i < 0)
      break;

    for (var j = 0; j < len; j++) {
      var z = tmp[j];
      var p;
      if (z === 0)
        continue;
      else if (z > 0)
        p = wnd[j][(z - 1) >> 1];
      else if (z < 0)
        p = wnd[j][(-z - 1) >> 1].neg();

      if (p.type === 'affine')
        acc = acc.mixedAdd(p);
      else
        acc = acc.add(p);
    }
  }
  // Zeroify references
  for (var i = 0; i < len; i++)
    wnd[i] = null;
  return acc.toP();
};

function BasePoint(curve, type) {
  this.curve = curve;
  this.type = type;
  this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;

BasePoint.prototype.eq = function eq(/*other*/) {
  throw new Error('Not implemented');
};

BasePoint.prototype.validate = function validate() {
  return this.curve.validate(this);
};

BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  bytes = utils.toArray(bytes, enc);

  var len = this.p.byteLength();
  if (bytes[0] === 0x04 && bytes.length - 1 === 2 * len) {
    return this.point(bytes.slice(1, 1 + len),
                      bytes.slice(1 + len, 1 + 2 * len));
  } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&
              bytes.length - 1 === len) {
    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);
  }
  throw new Error('Unknown point format');
};

BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
  return this.encode(enc, true);
};

BasePoint.prototype._encode = function _encode(compact) {
  var len = this.curve.p.byteLength();
  var x = this.getX().toArray('be', len);

  if (compact)
    return [ this.getY().isEven() ? 0x02 : 0x03 ].concat(x);

  return [ 0x04 ].concat(x, this.getY().toArray('be', len)) ;
};

BasePoint.prototype.encode = function encode(enc, compact) {
  return utils.encode(this._encode(compact), enc);
};

BasePoint.prototype.precompute = function precompute(power) {
  if (this.precomputed)
    return this;

  var precomputed = {
    doubles: null,
    naf: null,
    beta: null
  };
  precomputed.naf = this._getNAFPoints(8);
  precomputed.doubles = this._getDoubles(4, power);
  precomputed.beta = this._getBeta();
  this.precomputed = precomputed;

  return this;
};

BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
  if (!this.precomputed)
    return false;

  var doubles = this.precomputed.doubles;
  if (!doubles)
    return false;

  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
};

BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;

  var doubles = [ this ];
  var acc = this;
  for (var i = 0; i < power; i += step) {
    for (var j = 0; j < step; j++)
      acc = acc.dbl();
    doubles.push(acc);
  }
  return {
    step: step,
    points: doubles
  };
};

BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;

  var res = [ this ];
  var max = (1 << wnd) - 1;
  var dbl = max === 1 ? null : this.dbl();
  for (var i = 1; i < max; i++)
    res[i] = res[i - 1].add(dbl);
  return {
    wnd: wnd,
    points: res
  };
};

BasePoint.prototype._getBeta = function _getBeta() {
  return null;
};

BasePoint.prototype.dblp = function dblp(k) {
  var r = this;
  for (var i = 0; i < k; i++)
    r = r.dbl();
  return r;
};

},{"../../elliptic":190,"bn.js":188}],192:[function(require,module,exports){
'use strict';

var curve = require('../curve');
var elliptic = require('../../elliptic');
var bn = require('bn.js');
var inherits = require('inherits');
var Base = curve.base;

var assert = elliptic.utils.assert;

function EdwardsCurve(conf) {
  // NOTE: Important as we are creating point in Base.call()
  this.twisted = (conf.a | 0) !== 1;
  this.mOneA = this.twisted && (conf.a | 0) === -1;
  this.extended = this.mOneA;

  Base.call(this, 'edwards', conf);

  this.a = new bn(conf.a, 16).umod(this.red.m);
  this.a = this.a.toRed(this.red);
  this.c = new bn(conf.c, 16).toRed(this.red);
  this.c2 = this.c.redSqr();
  this.d = new bn(conf.d, 16).toRed(this.red);
  this.dd = this.d.redAdd(this.d);

  assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
  this.oneC = (conf.c | 0) === 1;
}
inherits(EdwardsCurve, Base);
module.exports = EdwardsCurve;

EdwardsCurve.prototype._mulA = function _mulA(num) {
  if (this.mOneA)
    return num.redNeg();
  else
    return this.a.redMul(num);
};

EdwardsCurve.prototype._mulC = function _mulC(num) {
  if (this.oneC)
    return num;
  else
    return this.c.redMul(num);
};

// Just for compatibility with Short curve
EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
  return this.point(x, y, z, t);
};

EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new bn(x, 16);
  if (!x.red)
    x = x.toRed(this.red);

  var x2 = x.redSqr();
  var rhs = this.c2.redSub(this.a.redMul(x2));
  var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));

  var y = rhs.redMul(lhs.redInvm()).redSqrt();
  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();

  return this.point(x, y);
};

EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
  y = new bn(y, 16);
  if (!y.red)
    y = y.toRed(this.red);

  // x^2 = (y^2 - 1) / (d y^2 + 1)
  var y2 = y.redSqr();
  var lhs = y2.redSub(this.one);
  var rhs = y2.redMul(this.d).redAdd(this.one);
  var x2 = lhs.redMul(rhs.redInvm());

  if (x2.cmp(this.zero) === 0) {
    if (odd)
      throw new Error('invalid point');
    else
      return this.point(this.zero, y);
  }

  var x = x2.redSqrt();
  if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  if (x.isOdd() !== odd)
    x = x.redNeg();

  return this.point(x, y);
};

EdwardsCurve.prototype.validate = function validate(point) {
  if (point.isInfinity())
    return true;

  // Curve: A * X^2 + Y^2 = C^2 * (1 + D * X^2 * Y^2)
  point.normalize();

  var x2 = point.x.redSqr();
  var y2 = point.y.redSqr();
  var lhs = x2.redMul(this.a).redAdd(y2);
  var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));

  return lhs.cmp(rhs) === 0;
};

function Point(curve, x, y, z, t) {
  Base.BasePoint.call(this, curve, 'projective');
  if (x === null && y === null && z === null) {
    this.x = this.curve.zero;
    this.y = this.curve.one;
    this.z = this.curve.one;
    this.t = this.curve.zero;
    this.zOne = true;
  } else {
    this.x = new bn(x, 16);
    this.y = new bn(y, 16);
    this.z = z ? new bn(z, 16) : this.curve.one;
    this.t = t && new bn(t, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
    if (this.t && !this.t.red)
      this.t = this.t.toRed(this.curve.red);
    this.zOne = this.z === this.curve.one;

    // Use extended coordinates
    if (this.curve.extended && !this.t) {
      this.t = this.x.redMul(this.y);
      if (!this.zOne)
        this.t = this.t.redMul(this.z.redInvm());
    }
  }
}
inherits(Point, Base.BasePoint);

EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
  return Point.fromJSON(this, obj);
};

EdwardsCurve.prototype.point = function point(x, y, z, t) {
  return new Point(this, x, y, z, t);
};

Point.fromJSON = function fromJSON(curve, obj) {
  return new Point(curve, obj[0], obj[1], obj[2]);
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' y: ' + this.y.fromRed().toString(16, 2) +
      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.x.cmpn(0) === 0 &&
         this.y.cmp(this.z) === 0;
};

Point.prototype._extDbl = function _extDbl() {
  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
  //     #doubling-dbl-2008-hwcd
  // 4M + 4S

  // A = X1^2
  var a = this.x.redSqr();
  // B = Y1^2
  var b = this.y.redSqr();
  // C = 2 * Z1^2
  var c = this.z.redSqr();
  c = c.redIAdd(c);
  // D = a * A
  var d = this.curve._mulA(a);
  // E = (X1 + Y1)^2 - A - B
  var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
  // G = D + B
  var g = d.redAdd(b);
  // F = G - C
  var f = g.redSub(c);
  // H = D - B
  var h = d.redSub(b);
  // X3 = E * F
  var nx = e.redMul(f);
  // Y3 = G * H
  var ny = g.redMul(h);
  // T3 = E * H
  var nt = e.redMul(h);
  // Z3 = F * G
  var nz = f.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};

Point.prototype._projDbl = function _projDbl() {
  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
  //     #doubling-dbl-2008-bbjlp
  //     #doubling-dbl-2007-bl
  // and others
  // Generally 3M + 4S or 2M + 4S

  // B = (X1 + Y1)^2
  var b = this.x.redAdd(this.y).redSqr();
  // C = X1^2
  var c = this.x.redSqr();
  // D = Y1^2
  var d = this.y.redSqr();

  var nx;
  var ny;
  var nz;
  if (this.curve.twisted) {
    // E = a * C
    var e = this.curve._mulA(c);
    // F = E + D
    var f = e.redAdd(d);
    if (this.zOne) {
      // X3 = (B - C - D) * (F - 2)
      nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
      // Y3 = F * (E - D)
      ny = f.redMul(e.redSub(d));
      // Z3 = F^2 - 2 * F
      nz = f.redSqr().redSub(f).redSub(f);
    } else {
      // H = Z1^2
      var h = this.z.redSqr();
      // J = F - 2 * H
      var j = f.redSub(h).redISub(h);
      // X3 = (B-C-D)*J
      nx = b.redSub(c).redISub(d).redMul(j);
      // Y3 = F * (E - D)
      ny = f.redMul(e.redSub(d));
      // Z3 = F * J
      nz = f.redMul(j);
    }
  } else {
    // E = C + D
    var e = c.redAdd(d);
    // H = (c * Z1)^2
    var h = this.curve._mulC(this.c.redMul(this.z)).redSqr();
    // J = E - 2 * H
    var j = e.redSub(h).redSub(h);
    // X3 = c * (B - E) * J
    nx = this.curve._mulC(b.redISub(e)).redMul(j);
    // Y3 = c * E * (C - D)
    ny = this.curve._mulC(e).redMul(c.redISub(d));
    // Z3 = E * J
    nz = e.redMul(j);
  }
  return this.curve.point(nx, ny, nz);
};

Point.prototype.dbl = function dbl() {
  if (this.isInfinity())
    return this;

  // Double in extended coordinates
  if (this.curve.extended)
    return this._extDbl();
  else
    return this._projDbl();
};

Point.prototype._extAdd = function _extAdd(p) {
  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
  //     #addition-add-2008-hwcd-3
  // 8M

  // A = (Y1 - X1) * (Y2 - X2)
  var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
  // B = (Y1 + X1) * (Y2 + X2)
  var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
  // C = T1 * k * T2
  var c = this.t.redMul(this.curve.dd).redMul(p.t);
  // D = Z1 * 2 * Z2
  var d = this.z.redMul(p.z.redAdd(p.z));
  // E = B - A
  var e = b.redSub(a);
  // F = D - C
  var f = d.redSub(c);
  // G = D + C
  var g = d.redAdd(c);
  // H = B + A
  var h = b.redAdd(a);
  // X3 = E * F
  var nx = e.redMul(f);
  // Y3 = G * H
  var ny = g.redMul(h);
  // T3 = E * H
  var nt = e.redMul(h);
  // Z3 = F * G
  var nz = f.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};

Point.prototype._projAdd = function _projAdd(p) {
  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
  //     #addition-add-2008-bbjlp
  //     #addition-add-2007-bl
  // 10M + 1S

  // A = Z1 * Z2
  var a = this.z.redMul(p.z);
  // B = A^2
  var b = a.redSqr();
  // C = X1 * X2
  var c = this.x.redMul(p.x);
  // D = Y1 * Y2
  var d = this.y.redMul(p.y);
  // E = d * C * D
  var e = this.curve.d.redMul(c).redMul(d);
  // F = B - E
  var f = b.redSub(e);
  // G = B + E
  var g = b.redAdd(e);
  // X3 = A * F * ((X1 + Y1) * (X2 + Y2) - C - D)
  var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
  var nx = a.redMul(f).redMul(tmp);
  var ny;
  var nz;
  if (this.curve.twisted) {
    // Y3 = A * G * (D - a * C)
    ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
    // Z3 = F * G
    nz = f.redMul(g);
  } else {
    // Y3 = A * G * (D - C)
    ny = a.redMul(g).redMul(d.redSub(c));
    // Z3 = c * F * G
    nz = this.curve._mulC(f).redMul(g);
  }
  return this.curve.point(nx, ny, nz);
};

Point.prototype.add = function add(p) {
  if (this.isInfinity())
    return p;
  if (p.isInfinity())
    return this;

  if (this.curve.extended)
    return this._extAdd(p);
  else
    return this._projAdd(p);
};

Point.prototype.mul = function mul(k) {
  if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else
    return this.curve._wnafMul(this, k);
};

Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2);
};

Point.prototype.normalize = function normalize() {
  if (this.zOne)
    return this;

  // Normalize coordinates
  var zi = this.z.redInvm();
  this.x = this.x.redMul(zi);
  this.y = this.y.redMul(zi);
  if (this.t)
    this.t = this.t.redMul(zi);
  this.z = this.curve.one;
  this.zOne = true;
  return this;
};

Point.prototype.neg = function neg() {
  return this.curve.point(this.x.redNeg(),
                          this.y,
                          this.z,
                          this.t && this.t.redNeg());
};

Point.prototype.getX = function getX() {
  this.normalize();
  return this.x.fromRed();
};

Point.prototype.getY = function getY() {
  this.normalize();
  return this.y.fromRed();
};

Point.prototype.eq = function eq(other) {
  return this === other ||
         this.getX().cmp(other.getX()) === 0 &&
         this.getY().cmp(other.getY()) === 0;
};

// Compatibility with BaseCurve
Point.prototype.toP = Point.prototype.normalize;
Point.prototype.mixedAdd = Point.prototype.add;

},{"../../elliptic":190,"../curve":193,"bn.js":188,"inherits":348}],193:[function(require,module,exports){
'use strict';

var curve = exports;

curve.base = require('./base');
curve.short = require('./short');
curve.mont = require('./mont');
curve.edwards = require('./edwards');

},{"./base":191,"./edwards":192,"./mont":194,"./short":195}],194:[function(require,module,exports){
'use strict';

var curve = require('../curve');
var bn = require('bn.js');
var inherits = require('inherits');
var Base = curve.base;

var elliptic = require('../../elliptic');
var utils = elliptic.utils;

function MontCurve(conf) {
  Base.call(this, 'mont', conf);

  this.a = new bn(conf.a, 16).toRed(this.red);
  this.b = new bn(conf.b, 16).toRed(this.red);
  this.i4 = new bn(4).toRed(this.red).redInvm();
  this.two = new bn(2).toRed(this.red);
  this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}
inherits(MontCurve, Base);
module.exports = MontCurve;

MontCurve.prototype.validate = function validate(point) {
  var x = point.normalize().x;
  var x2 = x.redSqr();
  var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
  var y = rhs.redSqrt();

  return y.redSqr().cmp(rhs) === 0;
};

function Point(curve, x, z) {
  Base.BasePoint.call(this, curve, 'projective');
  if (x === null && z === null) {
    this.x = this.curve.one;
    this.z = this.curve.zero;
  } else {
    this.x = new bn(x, 16);
    this.z = new bn(z, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
  }
}
inherits(Point, Base.BasePoint);

MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  return this.point(utils.toArray(bytes, enc), 1);
};

MontCurve.prototype.point = function point(x, z) {
  return new Point(this, x, z);
};

MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
  return Point.fromJSON(this, obj);
};

Point.prototype.precompute = function precompute() {
  // No-op
};

Point.prototype._encode = function _encode() {
  return this.getX().toArray('be', this.curve.p.byteLength());
};

Point.fromJSON = function fromJSON(curve, obj) {
  return new Point(curve, obj[0], obj[1] || curve.one);
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};

Point.prototype.dbl = function dbl() {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#doubling-dbl-1987-m-3
  // 2M + 2S + 4A

  // A = X1 + Z1
  var a = this.x.redAdd(this.z);
  // AA = A^2
  var aa = a.redSqr();
  // B = X1 - Z1
  var b = this.x.redSub(this.z);
  // BB = B^2
  var bb = b.redSqr();
  // C = AA - BB
  var c = aa.redSub(bb);
  // X3 = AA * BB
  var nx = aa.redMul(bb);
  // Z3 = C * (BB + A24 * C)
  var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
  return this.curve.point(nx, nz);
};

Point.prototype.add = function add() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.diffAdd = function diffAdd(p, diff) {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#diffadd-dadd-1987-m-3
  // 4M + 2S + 6A

  // A = X2 + Z2
  var a = this.x.redAdd(this.z);
  // B = X2 - Z2
  var b = this.x.redSub(this.z);
  // C = X3 + Z3
  var c = p.x.redAdd(p.z);
  // D = X3 - Z3
  var d = p.x.redSub(p.z);
  // DA = D * A
  var da = d.redMul(a);
  // CB = C * B
  var cb = c.redMul(b);
  // X5 = Z1 * (DA + CB)^2
  var nx = diff.z.redMul(da.redAdd(cb).redSqr());
  // Z5 = X1 * (DA - CB)^2
  var nz = diff.x.redMul(da.redISub(cb).redSqr());
  return this.curve.point(nx, nz);
};

Point.prototype.mul = function mul(k) {
  var t = k.clone();
  var a = this; // (N / 2) * Q + Q
  var b = this.curve.point(null, null); // (N / 2) * Q
  var c = this; // Q

  for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
    bits.push(t.andln(1));

  for (var i = bits.length - 1; i >= 0; i--) {
    if (bits[i] === 0) {
      // N * Q + Q = ((N / 2) * Q + Q)) + (N / 2) * Q
      a = a.diffAdd(b, c);
      // N * Q = 2 * ((N / 2) * Q + Q))
      b = b.dbl();
    } else {
      // N * Q = ((N / 2) * Q + Q) + ((N / 2) * Q)
      b = a.diffAdd(b, c);
      // N * Q + Q = 2 * ((N / 2) * Q + Q)
      a = a.dbl();
    }
  }
  return b;
};

Point.prototype.mulAdd = function mulAdd() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.eq = function eq(other) {
  return this.getX().cmp(other.getX()) === 0;
};

Point.prototype.normalize = function normalize() {
  this.x = this.x.redMul(this.z.redInvm());
  this.z = this.curve.one;
  return this;
};

Point.prototype.getX = function getX() {
  // Normalize coordinates
  this.normalize();

  return this.x.fromRed();
};

},{"../../elliptic":190,"../curve":193,"bn.js":188,"inherits":348}],195:[function(require,module,exports){
'use strict';

var curve = require('../curve');
var elliptic = require('../../elliptic');
var bn = require('bn.js');
var inherits = require('inherits');
var Base = curve.base;

var assert = elliptic.utils.assert;

function ShortCurve(conf) {
  Base.call(this, 'short', conf);

  this.a = new bn(conf.a, 16).toRed(this.red);
  this.b = new bn(conf.b, 16).toRed(this.red);
  this.tinv = this.two.redInvm();

  this.zeroA = this.a.fromRed().cmpn(0) === 0;
  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;

  // If the curve is endomorphic, precalculate beta and lambda
  this.endo = this._getEndomorphism(conf);
  this._endoWnafT1 = new Array(4);
  this._endoWnafT2 = new Array(4);
}
inherits(ShortCurve, Base);
module.exports = ShortCurve;

ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
  // No efficient endomorphism
  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
    return;

  // Compute beta and lambda, that lambda * P = (beta * Px; Py)
  var beta;
  var lambda;
  if (conf.beta) {
    beta = new bn(conf.beta, 16).toRed(this.red);
  } else {
    var betas = this._getEndoRoots(this.p);
    // Choose the smallest beta
    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
    beta = beta.toRed(this.red);
  }
  if (conf.lambda) {
    lambda = new bn(conf.lambda, 16);
  } else {
    // Choose the lambda that is matching selected beta
    var lambdas = this._getEndoRoots(this.n);
    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
      lambda = lambdas[0];
    } else {
      lambda = lambdas[1];
      assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
    }
  }

  // Get basis vectors, used for balanced length-two representation
  var basis;
  if (conf.basis) {
    basis = conf.basis.map(function(vec) {
      return {
        a: new bn(vec.a, 16),
        b: new bn(vec.b, 16)
      };
    });
  } else {
    basis = this._getEndoBasis(lambda);
  }

  return {
    beta: beta,
    lambda: lambda,
    basis: basis
  };
};

ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
  // Find roots of for x^2 + x + 1 in F
  // Root = (-1 +- Sqrt(-3)) / 2
  //
  var red = num === this.p ? this.red : bn.mont(num);
  var tinv = new bn(2).toRed(red).redInvm();
  var ntinv = tinv.redNeg();

  var s = new bn(3).toRed(red).redNeg().redSqrt().redMul(tinv);

  var l1 = ntinv.redAdd(s).fromRed();
  var l2 = ntinv.redSub(s).fromRed();
  return [ l1, l2 ];
};

ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
  // aprxSqrt >= sqrt(this.n)
  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));

  // 3.74
  // Run EGCD, until r(L + 1) < aprxSqrt
  var u = lambda;
  var v = this.n.clone();
  var x1 = new bn(1);
  var y1 = new bn(0);
  var x2 = new bn(0);
  var y2 = new bn(1);

  // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)
  var a0;
  var b0;
  // First vector
  var a1;
  var b1;
  // Second vector
  var a2;
  var b2;

  var prevR;
  var i = 0;
  var r;
  var x;
  while (u.cmpn(0) !== 0) {
    var q = v.div(u);
    r = v.sub(q.mul(u));
    x = x2.sub(q.mul(x1));
    var y = y2.sub(q.mul(y1));

    if (!a1 && r.cmp(aprxSqrt) < 0) {
      a0 = prevR.neg();
      b0 = x1;
      a1 = r.neg();
      b1 = x;
    } else if (a1 && ++i === 2) {
      break;
    }
    prevR = r;

    v = u;
    u = r;
    x2 = x1;
    x1 = x;
    y2 = y1;
    y1 = y;
  }
  a2 = r.neg();
  b2 = x;

  var len1 = a1.sqr().add(b1.sqr());
  var len2 = a2.sqr().add(b2.sqr());
  if (len2.cmp(len1) >= 0) {
    a2 = a0;
    b2 = b0;
  }

  // Normalize signs
  if (a1.negative) {
    a1 = a1.neg();
    b1 = b1.neg();
  }
  if (a2.negative) {
    a2 = a2.neg();
    b2 = b2.neg();
  }

  return [
    { a: a1, b: b1 },
    { a: a2, b: b2 }
  ];
};

ShortCurve.prototype._endoSplit = function _endoSplit(k) {
  var basis = this.endo.basis;
  var v1 = basis[0];
  var v2 = basis[1];

  var c1 = v2.b.mul(k).divRound(this.n);
  var c2 = v1.b.neg().mul(k).divRound(this.n);

  var p1 = c1.mul(v1.a);
  var p2 = c2.mul(v2.a);
  var q1 = c1.mul(v1.b);
  var q2 = c2.mul(v2.b);

  // Calculate answer
  var k1 = k.sub(p1).sub(p2);
  var k2 = q1.add(q2).neg();
  return { k1: k1, k2: k2 };
};

ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new bn(x, 16);
  if (!x.red)
    x = x.toRed(this.red);

  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
  var y = y2.redSqrt();

  // XXX Is there any way to tell if the number is odd without converting it
  // to non-red form?
  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();

  return this.point(x, y);
};

ShortCurve.prototype.validate = function validate(point) {
  if (point.inf)
    return true;

  var x = point.x;
  var y = point.y;

  var ax = this.a.redMul(x);
  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
  return y.redSqr().redISub(rhs).cmpn(0) === 0;
};

ShortCurve.prototype._endoWnafMulAdd =
    function _endoWnafMulAdd(points, coeffs) {
  var npoints = this._endoWnafT1;
  var ncoeffs = this._endoWnafT2;
  for (var i = 0; i < points.length; i++) {
    var split = this._endoSplit(coeffs[i]);
    var p = points[i];
    var beta = p._getBeta();

    if (split.k1.negative) {
      split.k1.ineg();
      p = p.neg(true);
    }
    if (split.k2.negative) {
      split.k2.ineg();
      beta = beta.neg(true);
    }

    npoints[i * 2] = p;
    npoints[i * 2 + 1] = beta;
    ncoeffs[i * 2] = split.k1;
    ncoeffs[i * 2 + 1] = split.k2;
  }
  var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2);

  // Clean-up references to points and coefficients
  for (var j = 0; j < i * 2; j++) {
    npoints[j] = null;
    ncoeffs[j] = null;
  }
  return res;
};

function Point(curve, x, y, isRed) {
  Base.BasePoint.call(this, curve, 'affine');
  if (x === null && y === null) {
    this.x = null;
    this.y = null;
    this.inf = true;
  } else {
    this.x = new bn(x, 16);
    this.y = new bn(y, 16);
    // Force redgomery representation when loading from JSON
    if (isRed) {
      this.x.forceRed(this.curve.red);
      this.y.forceRed(this.curve.red);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    this.inf = false;
  }
}
inherits(Point, Base.BasePoint);

ShortCurve.prototype.point = function point(x, y, isRed) {
  return new Point(this, x, y, isRed);
};

ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
  return Point.fromJSON(this, obj, red);
};

Point.prototype._getBeta = function _getBeta() {
  if (!this.curve.endo)
    return;

  var pre = this.precomputed;
  if (pre && pre.beta)
    return pre.beta;

  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
  if (pre) {
    var curve = this.curve;
    var endoMul = function(p) {
      return curve.point(p.x.redMul(curve.endo.beta), p.y);
    };
    pre.beta = beta;
    beta.precomputed = {
      beta: null,
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(endoMul)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(endoMul)
      }
    };
  }
  return beta;
};

Point.prototype.toJSON = function toJSON() {
  if (!this.precomputed)
    return [ this.x, this.y ];

  return [ this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  } ];
};

Point.fromJSON = function fromJSON(curve, obj, red) {
  if (typeof obj === 'string')
    obj = JSON.parse(obj);
  var res = curve.point(obj[0], obj[1], red);
  if (!obj[2])
    return res;

  function obj2point(obj) {
    return curve.point(obj[0], obj[1], red);
  }

  var pre = obj[2];
  res.precomputed = {
    beta: null,
    doubles: pre.doubles && {
      step: pre.doubles.step,
      points: [ res ].concat(pre.doubles.points.map(obj2point))
    },
    naf: pre.naf && {
      wnd: pre.naf.wnd,
      points: [ res ].concat(pre.naf.points.map(obj2point))
    }
  };
  return res;
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' y: ' + this.y.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  return this.inf;
};

Point.prototype.add = function add(p) {
  // O + P = P
  if (this.inf)
    return p;

  // P + O = P
  if (p.inf)
    return this;

  // P + P = 2P
  if (this.eq(p))
    return this.dbl();

  // P + (-P) = O
  if (this.neg().eq(p))
    return this.curve.point(null, null);

  // P + Q = O
  if (this.x.cmp(p.x) === 0)
    return this.curve.point(null, null);

  var c = this.y.redSub(p.y);
  if (c.cmpn(0) !== 0)
    c = c.redMul(this.x.redSub(p.x).redInvm());
  var nx = c.redSqr().redISub(this.x).redISub(p.x);
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point.prototype.dbl = function dbl() {
  if (this.inf)
    return this;

  // 2P = O
  var ys1 = this.y.redAdd(this.y);
  if (ys1.cmpn(0) === 0)
    return this.curve.point(null, null);

  var a = this.curve.a;

  var x2 = this.x.redSqr();
  var dyinv = ys1.redInvm();
  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);

  var nx = c.redSqr().redISub(this.x.redAdd(this.x));
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point.prototype.getX = function getX() {
  return this.x.fromRed();
};

Point.prototype.getY = function getY() {
  return this.y.fromRed();
};

Point.prototype.mul = function mul(k) {
  k = new bn(k, 16);

  if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else if (this.curve.endo)
    return this.curve._endoWnafMulAdd([ this ], [ k ]);
  else
    return this.curve._wnafMul(this, k);
};

Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
  var points = [ this, p2 ];
  var coeffs = [ k1, k2 ];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2);
};

Point.prototype.eq = function eq(p) {
  return this === p ||
         this.inf === p.inf &&
             (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
};

Point.prototype.neg = function neg(_precompute) {
  if (this.inf)
    return this;

  var res = this.curve.point(this.x, this.y.redNeg());
  if (_precompute && this.precomputed) {
    var pre = this.precomputed;
    var negate = function(p) {
      return p.neg();
    };
    res.precomputed = {
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(negate)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(negate)
      }
    };
  }
  return res;
};

Point.prototype.toJ = function toJ() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);

  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
  return res;
};

function JPoint(curve, x, y, z) {
  Base.BasePoint.call(this, curve, 'jacobian');
  if (x === null && y === null && z === null) {
    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = new bn(0);
  } else {
    this.x = new bn(x, 16);
    this.y = new bn(y, 16);
    this.z = new bn(z, 16);
  }
  if (!this.x.red)
    this.x = this.x.toRed(this.curve.red);
  if (!this.y.red)
    this.y = this.y.toRed(this.curve.red);
  if (!this.z.red)
    this.z = this.z.toRed(this.curve.red);

  this.zOne = this.z === this.curve.one;
}
inherits(JPoint, Base.BasePoint);

ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
  return new JPoint(this, x, y, z);
};

JPoint.prototype.toP = function toP() {
  if (this.isInfinity())
    return this.curve.point(null, null);

  var zinv = this.z.redInvm();
  var zinv2 = zinv.redSqr();
  var ax = this.x.redMul(zinv2);
  var ay = this.y.redMul(zinv2).redMul(zinv);

  return this.curve.point(ax, ay);
};

JPoint.prototype.neg = function neg() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};

JPoint.prototype.add = function add(p) {
  // O + P = P
  if (this.isInfinity())
    return p;

  // P + O = P
  if (p.isInfinity())
    return this;

  // 12M + 4S + 7A
  var pz2 = p.z.redSqr();
  var z2 = this.z.redSqr();
  var u1 = this.x.redMul(pz2);
  var u2 = p.x.redMul(z2);
  var s1 = this.y.redMul(pz2.redMul(p.z));
  var s2 = p.y.redMul(z2.redMul(this.z));

  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(p.z).redMul(h);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mixedAdd = function mixedAdd(p) {
  // O + P = P
  if (this.isInfinity())
    return p.toJ();

  // P + O = P
  if (p.isInfinity())
    return this;

  // 8M + 3S + 7A
  var z2 = this.z.redSqr();
  var u1 = this.x;
  var u2 = p.x.redMul(z2);
  var s1 = this.y;
  var s2 = p.y.redMul(z2).redMul(this.z);

  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(h);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.dblp = function dblp(pow) {
  if (pow === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!pow)
    return this.dbl();

  if (this.curve.zeroA || this.curve.threeA) {
    var r = this;
    for (var i = 0; i < pow; i++)
      r = r.dbl();
    return r;
  }

  // 1M + 2S + 1A + N * (4S + 5M + 8A)
  // N = 1 => 6M + 6S + 9A
  var a = this.curve.a;
  var tinv = this.curve.tinv;

  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();

  // Reuse results
  var jyd = jy.redAdd(jy);
  for (var i = 0; i < pow; i++) {
    var jx2 = jx.redSqr();
    var jyd2 = jyd.redSqr();
    var jyd4 = jyd2.redSqr();
    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

    var t1 = jx.redMul(jyd2);
    var nx = c.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var dny = c.redMul(t2);
    dny = dny.redIAdd(dny).redISub(jyd4);
    var nz = jyd.redMul(jz);
    if (i + 1 < pow)
      jz4 = jz4.redMul(jyd4);

    jx = nx;
    jz = nz;
    jyd = dny;
  }

  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
};

JPoint.prototype.dbl = function dbl() {
  if (this.isInfinity())
    return this;

  if (this.curve.zeroA)
    return this._zeroDbl();
  else if (this.curve.threeA)
    return this._threeDbl();
  else
    return this._dbl();
};

JPoint.prototype._zeroDbl = function _zeroDbl() {
  var nx;
  var ny;
  var nz;
  // Z = 1
  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 14A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a; a = 0
    var m = xx.redAdd(xx).redIAdd(xx);
    // T = M ^ 2 - 2*S
    var t = m.redSqr().redISub(s).redISub(s);

    // 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);

    // X3 = T
    nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2*Y1
    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-dbl-2009-l
    // 2M + 5S + 13A

    // A = X1^2
    var a = this.x.redSqr();
    // B = Y1^2
    var b = this.y.redSqr();
    // C = B^2
    var c = b.redSqr();
    // D = 2 * ((X1 + B)^2 - A - C)
    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
    d = d.redIAdd(d);
    // E = 3 * A
    var e = a.redAdd(a).redIAdd(a);
    // F = E^2
    var f = e.redSqr();

    // 8 * C
    var c8 = c.redIAdd(c);
    c8 = c8.redIAdd(c8);
    c8 = c8.redIAdd(c8);

    // X3 = F - 2 * D
    nx = f.redISub(d).redISub(d);
    // Y3 = E * (D - X3) - 8 * C
    ny = e.redMul(d.redISub(nx)).redISub(c8);
    // Z3 = 2 * Y1 * Z1
    nz = this.y.redMul(this.z);
    nz = nz.redIAdd(nz);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._threeDbl = function _threeDbl() {
  var nx;
  var ny;
  var nz;
  // Z = 1
  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 15A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a
    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
    // T = M^2 - 2 * S
    var t = m.redSqr().redISub(s).redISub(s);
    // X3 = T
    nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2 * Y1
    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b
    // 3M + 5S

    // delta = Z1^2
    var delta = this.z.redSqr();
    // gamma = Y1^2
    var gamma = this.y.redSqr();
    // beta = X1 * gamma
    var beta = this.x.redMul(gamma);
    // alpha = 3 * (X1 - delta) * (X1 + delta)
    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
    alpha = alpha.redAdd(alpha).redIAdd(alpha);
    // X3 = alpha^2 - 8 * beta
    var beta4 = beta.redIAdd(beta);
    beta4 = beta4.redIAdd(beta4);
    var beta8 = beta4.redAdd(beta4);
    nx = alpha.redSqr().redISub(beta8);
    // Z3 = (Y1 + Z1)^2 - gamma - delta
    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2
    var ggamma8 = gamma.redSqr();
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._dbl = function _dbl() {
  var a = this.curve.a;

  // 4M + 6S + 10A
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();

  var jx2 = jx.redSqr();
  var jy2 = jy.redSqr();

  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

  var jxd4 = jx.redAdd(jx);
  jxd4 = jxd4.redIAdd(jxd4);
  var t1 = jxd4.redMul(jy2);
  var nx = c.redSqr().redISub(t1.redAdd(t1));
  var t2 = t1.redISub(nx);

  var jyd8 = jy2.redSqr();
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  var ny = c.redMul(t2).redISub(jyd8);
  var nz = jy.redAdd(jy).redMul(jz);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.trpl = function trpl() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);

  // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl
  // 5M + 10S + ...

  // XX = X1^2
  var xx = this.x.redSqr();
  // YY = Y1^2
  var yy = this.y.redSqr();
  // ZZ = Z1^2
  var zz = this.z.redSqr();
  // YYYY = YY^2
  var yyyy = yy.redSqr();
  // M = 3 * XX + a * ZZ2; a = 0
  var m = xx.redAdd(xx).redIAdd(xx);
  // MM = M^2
  var mm = m.redSqr();
  // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM
  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
  e = e.redIAdd(e);
  e = e.redAdd(e).redIAdd(e);
  e = e.redISub(mm);
  // EE = E^2
  var ee = e.redSqr();
  // T = 16*YYYY
  var t = yyyy.redIAdd(yyyy);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  // U = (M + E)^2 - MM - EE - T
  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
  // X3 = 4 * (X1 * EE - 4 * YY * U)
  var yyu4 = yy.redMul(u);
  yyu4 = yyu4.redIAdd(yyu4);
  yyu4 = yyu4.redIAdd(yyu4);
  var nx = this.x.redMul(ee).redISub(yyu4);
  nx = nx.redIAdd(nx);
  nx = nx.redIAdd(nx);
  // Y3 = 8 * Y1 * (U * (T - U) - E * EE)
  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  // Z3 = (Z1 + E)^2 - ZZ - EE
  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mul = function mul(k, kbase) {
  k = new bn(k, kbase);

  return this.curve._wnafMul(this, k);
};

JPoint.prototype.eq = function eq(p) {
  if (p.type === 'affine')
    return this.eq(p.toJ());

  if (this === p)
    return true;

  // x1 * z2^2 == x2 * z1^2
  var z2 = this.z.redSqr();
  var pz2 = p.z.redSqr();
  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
    return false;

  // y1 * z2^3 == y2 * z1^3
  var z3 = z2.redMul(this.z);
  var pz3 = pz2.redMul(p.z);
  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
};

JPoint.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC JPoint Infinity>';
  return '<EC JPoint x: ' + this.x.toString(16, 2) +
      ' y: ' + this.y.toString(16, 2) +
      ' z: ' + this.z.toString(16, 2) + '>';
};

JPoint.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};

},{"../../elliptic":190,"../curve":193,"bn.js":188,"inherits":348}],196:[function(require,module,exports){
'use strict';

var curves = exports;

var hash = require('hash.js');
var elliptic = require('../elliptic');

var assert = elliptic.utils.assert;

function PresetCurve(options) {
  if (options.type === 'short')
    this.curve = new elliptic.curve.short(options);
  else if (options.type === 'edwards')
    this.curve = new elliptic.curve.edwards(options);
  else
    this.curve = new elliptic.curve.mont(options);
  this.g = this.curve.g;
  this.n = this.curve.n;
  this.hash = options.hash;

  assert(this.g.validate(), 'Invalid curve');
  assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');
}
curves.PresetCurve = PresetCurve;

function defineCurve(name, options) {
  Object.defineProperty(curves, name, {
    configurable: true,
    enumerable: true,
    get: function() {
      var curve = new PresetCurve(options);
      Object.defineProperty(curves, name, {
        configurable: true,
        enumerable: true,
        value: curve
      });
      return curve;
    }
  });
}

defineCurve('p192', {
  type: 'short',
  prime: 'p192',
  p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',
  b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',
  n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',
  hash: hash.sha256,
  gRed: false,
  g: [
    '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',
    '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811'
  ]
});

defineCurve('p224', {
  type: 'short',
  prime: 'p224',
  p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',
  b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',
  n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',
  hash: hash.sha256,
  gRed: false,
  g: [
    'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',
    'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34'
  ]
});

defineCurve('p256', {
  type: 'short',
  prime: null,
  p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',
  a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',
  b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',
  n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',
  hash: hash.sha256,
  gRed: false,
  g: [
    '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',
    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5'
  ]
});

defineCurve('p384', {
  type: 'short',
  prime: null,
  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'fffffffe ffffffff 00000000 00000000 ffffffff',
  a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'fffffffe ffffffff 00000000 00000000 fffffffc',
  b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' +
     '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',
  n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' +
     'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',
  hash: hash.sha384,
  gRed: false,
  g: [
    'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' +
    '5502f25d bf55296c 3a545e38 72760ab7',
    '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' +
    '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f'
  ]
});

defineCurve('p521', {
  type: 'short',
  prime: null,
  p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff',
  a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff fffffffc',
  b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' +
     '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' +
     '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',
  n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' +
     'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',
  hash: hash.sha512,
  gRed: false,
  g: [
    '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' +
    '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' +
    'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',
    '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' +
    '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' +
    '3fad0761 353c7086 a272c240 88be9476 9fd16650'
  ]
});

defineCurve('curve25519', {
  type: 'mont',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '76d06',
  b: '0',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: hash.sha256,
  gRed: false,
  g: [
    '9'
  ]
});

defineCurve('ed25519', {
  type: 'edwards',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '-1',
  c: '1',
  // -121665 * (121666^(-1)) (mod P)
  d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: hash.sha256,
  gRed: false,
  g: [
    '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',

    // 4/5
    '6666666666666666666666666666666666666666666666666666666666666658'
  ]
});

var pre;
try {
  pre = require('./precomputed/secp256k1');
} catch (e) {
  pre = undefined;
}

defineCurve('secp256k1', {
  type: 'short',
  prime: 'k256',
  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',
  a: '0',
  b: '7',
  n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',
  h: '1',
  hash: hash.sha256,

  // Precomputed endomorphism
  beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',
  lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',
  basis: [
    {
      a: '3086d221a7d46bcde86c90e49284eb15',
      b: '-e4437ed6010e88286f547fa90abfe4c3'
    },
    {
      a: '114ca50f7a8e2f3f657c1108d9d44cfd8',
      b: '3086d221a7d46bcde86c90e49284eb15'
    }
  ],

  gRed: false,
  g: [
    '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',
    '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
    pre
  ]
});

},{"../elliptic":190,"./precomputed/secp256k1":204,"hash.js":207}],197:[function(require,module,exports){
'use strict';

var bn = require('bn.js');
var elliptic = require('../../elliptic');
var utils = elliptic.utils;
var assert = utils.assert;

var KeyPair = require('./key');
var Signature = require('./signature');

function EC(options) {
  if (!(this instanceof EC))
    return new EC(options);

  // Shortcut `elliptic.ec(curve-name)`
  if (typeof options === 'string') {
    assert(elliptic.curves.hasOwnProperty(options), 'Unknown curve ' + options);

    options = elliptic.curves[options];
  }

  // Shortcut for `elliptic.ec(elliptic.curves.curveName)`
  if (options instanceof elliptic.curves.PresetCurve)
    options = { curve: options };

  this.curve = options.curve.curve;
  this.n = this.curve.n;
  this.nh = this.n.ushrn(1);
  this.g = this.curve.g;

  // Point on curve
  this.g = options.curve.g;
  this.g.precompute(options.curve.n.bitLength() + 1);

  // Hash for function for DRBG
  this.hash = options.hash || options.curve.hash;
}
module.exports = EC;

EC.prototype.keyPair = function keyPair(options) {
  return new KeyPair(this, options);
};

EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
  return KeyPair.fromPrivate(this, priv, enc);
};

EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
  return KeyPair.fromPublic(this, pub, enc);
};

EC.prototype.genKeyPair = function genKeyPair(options) {
  if (!options)
    options = {};

  // Instantiate Hmac_DRBG
  var drbg = new elliptic.hmacDRBG({
    hash: this.hash,
    pers: options.pers,
    entropy: options.entropy || elliptic.rand(this.hash.hmacStrength),
    nonce: this.n.toArray()
  });

  var bytes = this.n.byteLength();
  var ns2 = this.n.sub(new bn(2));
  do {
    var priv = new bn(drbg.generate(bytes));
    if (priv.cmp(ns2) > 0)
      continue;

    priv.iaddn(1);
    return this.keyFromPrivate(priv);
  } while (true);
};

EC.prototype._truncateToN = function truncateToN(msg, truncOnly) {
  var delta = msg.byteLength() * 8 - this.n.bitLength();
  if (delta > 0)
    msg = msg.ushrn(delta);
  if (!truncOnly && msg.cmp(this.n) >= 0)
    return msg.sub(this.n);
  else
    return msg;
};

EC.prototype.sign = function sign(msg, key, enc, options) {
  if (typeof enc === 'object') {
    options = enc;
    enc = null;
  }
  if (!options)
    options = {};

  key = this.keyFromPrivate(key, enc);
  msg = this._truncateToN(new bn(msg, 16));

  // Zero-extend key to provide enough entropy
  var bytes = this.n.byteLength();
  var bkey = key.getPrivate().toArray();
  for (var i = bkey.length; i < bytes; i++)
    bkey.unshift(0);

  // Zero-extend nonce to have the same byte size as N
  var nonce = msg.toArray();
  for (var i = nonce.length; i < bytes; i++)
    nonce.unshift(0);

  // Instantiate Hmac_DRBG
  var drbg = new elliptic.hmacDRBG({
    hash: this.hash,
    entropy: bkey,
    nonce: nonce
  });

  // Number of bytes to generate
  var ns1 = this.n.sub(new bn(1));
  do {
    var k = new bn(drbg.generate(this.n.byteLength()));
    k = this._truncateToN(k, true);
    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
      continue;

    var kp = this.g.mul(k);
    if (kp.isInfinity())
      continue;

    var kpX = kp.getX();
    var r = kpX.umod(this.n);
    if (r.cmpn(0) === 0)
      continue;

    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
    s = s.umod(this.n);
    if (s.cmpn(0) === 0)
      continue;

    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |
                        (kpX.cmp(r) !== 0 ? 2 : 0);

    // Use complement of `s`, if it is > `n / 2`
    if (options.canonical && s.cmp(this.nh) > 0) {
      s = this.n.sub(s);
      recoveryParam ^= 1;
    }

    return new Signature({ r: r, s: s, recoveryParam: recoveryParam });
  } while (true);
};

EC.prototype.verify = function verify(msg, signature, key, enc) {
  msg = this._truncateToN(new bn(msg, 16));
  key = this.keyFromPublic(key, enc);
  signature = new Signature(signature, 'hex');

  // Perform primitive values validation
  var r = signature.r;
  var s = signature.s;
  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
    return false;
  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
    return false;

  // Validate signature
  var sinv = s.invm(this.n);
  var u1 = sinv.mul(msg).umod(this.n);
  var u2 = sinv.mul(r).umod(this.n);

  var p = this.g.mulAdd(u1, key.getPublic(), u2);
  if (p.isInfinity())
    return false;

  return p.getX().umod(this.n).cmp(r) === 0;
};

EC.prototype.recoverPubKey = function(msg, signature, j, enc) {
  assert((3 & j) === j, 'The recovery param is more than two bits');
  signature = new Signature(signature, enc);

  var n = this.n;
  var e = new bn(msg);
  var r = signature.r;
  var s = signature.s;

  // A set LSB signifies that the y-coordinate is odd
  var isYOdd = j & 1;
  var isSecondKey = j >> 1;
  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
    throw new Error('Unable to find sencond key candinate');

  // 1.1. Let x = r + jn.
  if (isSecondKey)
    r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
  else
    r = this.curve.pointFromX(r, isYOdd);

  var eNeg = n.sub(e);

  // 1.6.1 Compute Q = r^-1 (sR -  eG)
  //               Q = r^-1 (sR + -eG)
  var rInv = signature.r.invm(n);
  return r.mul(s).add(this.g.mul(eNeg)).mul(rInv);
};

EC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
  signature = new Signature(signature, enc);
  if (signature.recoveryParam !== null)
    return signature.recoveryParam;

  for (var i = 0; i < 4; i++) {
    var Qprime = this.recoverPubKey(e, signature, i);

    if (Qprime.eq(Q))
      return i;
  }
  throw new Error('Unable to find valid recovery factor');
};

},{"../../elliptic":190,"./key":198,"./signature":199,"bn.js":188}],198:[function(require,module,exports){
'use strict';

var bn = require('bn.js');

function KeyPair(ec, options) {
  this.ec = ec;
  this.priv = null;
  this.pub = null;

  // KeyPair(ec, { priv: ..., pub: ... })
  if (options.priv)
    this._importPrivate(options.priv, options.privEnc);
  if (options.pub)
    this._importPublic(options.pub, options.pubEnc);
}
module.exports = KeyPair;

KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
  if (pub instanceof KeyPair)
    return pub;

  return new KeyPair(ec, {
    pub: pub,
    pubEnc: enc
  });
};

KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
  if (priv instanceof KeyPair)
    return priv;

  return new KeyPair(ec, {
    priv: priv,
    privEnc: enc
  });
};

KeyPair.prototype.validate = function validate() {
  var pub = this.getPublic();

  if (pub.isInfinity())
    return { result: false, reason: 'Invalid public key' };
  if (!pub.validate())
    return { result: false, reason: 'Public key is not a point' };
  if (!pub.mul(this.ec.curve.n).isInfinity())
    return { result: false, reason: 'Public key * N != O' };

  return { result: true, reason: null };
};

KeyPair.prototype.getPublic = function getPublic(compact, enc) {
  // compact is optional argument
  if (typeof compact === 'string') {
    enc = compact;
    compact = null;
  }

  if (!this.pub)
    this.pub = this.ec.g.mul(this.priv);

  if (!enc)
    return this.pub;

  return this.pub.encode(enc, compact);
};

KeyPair.prototype.getPrivate = function getPrivate(enc) {
  if (enc === 'hex')
    return this.priv.toString(16, 2);
  else
    return this.priv;
};

KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
  this.priv = new bn(key, enc || 16);

  // Ensure that the priv won't be bigger than n, otherwise we may fail
  // in fixed multiplication method
  this.priv = this.priv.umod(this.ec.curve.n);
};

KeyPair.prototype._importPublic = function _importPublic(key, enc) {
  if (key.x || key.y) {
    this.pub = this.ec.curve.point(key.x, key.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(key, enc);
};

// ECDH
KeyPair.prototype.derive = function derive(pub) {
  return pub.mul(this.priv).getX();
};

// ECDSA
KeyPair.prototype.sign = function sign(msg, enc, options) {
  return this.ec.sign(msg, this, enc, options);
};

KeyPair.prototype.verify = function verify(msg, signature) {
  return this.ec.verify(msg, signature, this);
};

KeyPair.prototype.inspect = function inspect() {
  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +
         ' pub: ' + (this.pub && this.pub.inspect()) + ' >';
};

},{"bn.js":188}],199:[function(require,module,exports){
'use strict';

var bn = require('bn.js');

var elliptic = require('../../elliptic');
var utils = elliptic.utils;
var assert = utils.assert;

function Signature(options, enc) {
  if (options instanceof Signature)
    return options;

  if (this._importDER(options, enc))
    return;

  assert(options.r && options.s, 'Signature without r or s');
  this.r = new bn(options.r, 16);
  this.s = new bn(options.s, 16);
  if (options.recoveryParam !== null)
    this.recoveryParam = options.recoveryParam;
  else
    this.recoveryParam = null;
}
module.exports = Signature;

function Position() {
  this.place = 0;
}

function getLength(buf, p) {
  var initial = buf[p.place++];
  if (!(initial & 0x80)) {
    return initial;
  }
  var octetLen = initial & 0xf;
  var val = 0;
  for (var i = 0, off = p.place; i < octetLen; i++, off++) {
    val <<= 8;
    val |= buf[off];
  }
  p.place = off;
  return val;
}

function rmPadding(buf) {
  var i = 0;
  var len = buf.length - 1;
  while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {
    i++;
  }
  if (i === 0) {
    return buf;
  }
  return buf.slice(i);
}

Signature.prototype._importDER = function _importDER(data, enc) {
  data = utils.toArray(data, enc);
  var p = new Position();
  if (data[p.place++] !== 0x30) {
    return false;
  }
  var len = getLength(data, p);
  if ((len + p.place) !== data.length) {
    return false;
  }
  if (data[p.place++] !== 0x02) {
    return false;
  }
  var rlen = getLength(data, p);
  var r = data.slice(p.place, rlen + p.place);
  p.place += rlen;
  if (data[p.place++] !== 0x02) {
    return false;
  }
  var slen = getLength(data, p);
  if (data.length !== slen + p.place) {
    return false;
  }
  var s = data.slice(p.place, slen + p.place);
  if (r[0] === 0 && (r[1] & 0x80)) {
    r = r.slice(1);
  }
  if (s[0] === 0 && (s[1] & 0x80)) {
    s = s.slice(1);
  }

  this.r = new bn(r);
  this.s = new bn(s);
  this.recoveryParam = null;

  return true;
};

function constructLength(arr, len) {
  if (len < 0x80) {
    arr.push(len);
    return;
  }
  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
  arr.push(octets | 0x80);
  while (--octets) {
    arr.push((len >>> (octets << 3)) & 0xff);
  }
  arr.push(len);
}

Signature.prototype.toDER = function toDER(enc) {
  var r = this.r.toArray();
  var s = this.s.toArray();

  // Pad values
  if (r[0] & 0x80)
    r = [ 0 ].concat(r);
  // Pad values
  if (s[0] & 0x80)
    s = [ 0 ].concat(s);

  r = rmPadding(r);
  s = rmPadding(s);

  while (!s[0] && !(s[1] & 0x80)) {
    s = s.slice(1);
  }
  var arr = [ 0x02 ];
  constructLength(arr, r.length);
  arr = arr.concat(r);
  arr.push(0x02);
  constructLength(arr, s.length);
  var backHalf = arr.concat(s);
  var res = [ 0x30 ];
  constructLength(res, backHalf.length);
  res = res.concat(backHalf);
  return utils.encode(res, enc);
};

},{"../../elliptic":190,"bn.js":188}],200:[function(require,module,exports){
'use strict';

var hash = require('hash.js');
var elliptic = require('../../elliptic');
var utils = elliptic.utils;
var assert = utils.assert;
var parseBytes = utils.parseBytes;
var KeyPair = require('./key');
var Signature = require('./signature');

function EDDSA(curve) {
  assert(curve === 'ed25519', 'only tested with ed25519 so far');

  if (!(this instanceof EDDSA))
    return new EDDSA(curve);

  var curve = elliptic.curves[curve].curve;
  this.curve = curve;
  this.g = curve.g;
  this.g.precompute(curve.n.bitLength() + 1);

  this.pointClass = curve.point().constructor;
  this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
  this.hash = hash.sha512;
}

module.exports = EDDSA;

/**
* @param {Array|String} message - message bytes
* @param {Array|String|KeyPair} secret - secret bytes or a keypair
* @returns {Signature} - signature
*/
EDDSA.prototype.sign = function sign(message, secret) {
  message = parseBytes(message);
  var key = this.keyFromSecret(secret);
  var r = this.hashInt(key.messagePrefix(), message);
  var R = this.g.mul(r);
  var Rencoded = this.encodePoint(R);
  var s_ = this.hashInt(Rencoded, key.pubBytes(), message)
               .mul(key.priv());
  var S = r.add(s_).umod(this.curve.n);
  return this.makeSignature({ R: R, S: S, Rencoded: Rencoded });
};

/**
* @param {Array} message - message bytes
* @param {Array|String|Signature} sig - sig bytes
* @param {Array|String|Point|KeyPair} pub - public key
* @returns {Boolean} - true if public key matches sig of message
*/
EDDSA.prototype.verify = function verify(message, sig, pub) {
  message = parseBytes(message);
  sig = this.makeSignature(sig);
  var key = this.keyFromPublic(pub);
  var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
  var SG = this.g.mul(sig.S());
  var RplusAh = sig.R().add(key.pub().mul(h));
  return RplusAh.eq(SG);
};

EDDSA.prototype.hashInt = function hashInt() {
  var hash = this.hash();
  for (var i = 0; i < arguments.length; i++)
    hash.update(arguments[i]);
  return utils.intFromLE(hash.digest()).umod(this.curve.n);
};

EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
  return KeyPair.fromPublic(this, pub);
};

EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
  return KeyPair.fromSecret(this, secret);
};

EDDSA.prototype.makeSignature = function makeSignature(sig) {
  if (sig instanceof Signature)
    return sig;
  return new Signature(this, sig);
};

/**
* * https://tools.ietf.org/html/draft-josefsson-eddsa-ed25519-03#section-5.2
*
* EDDSA defines methods for encoding and decoding points and integers. These are
* helper convenience methods, that pass along to utility functions implied
* parameters.
*
*/
EDDSA.prototype.encodePoint = function encodePoint(point) {
  var enc = point.getY().toArray('le', this.encodingLength);
  enc[this.encodingLength - 1] |= point.getX().isOdd() ? 0x80 : 0;
  return enc;
};

EDDSA.prototype.decodePoint = function decodePoint(bytes) {
  bytes = utils.parseBytes(bytes);

  var lastIx = bytes.length - 1;
  var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~0x80);
  var xIsOdd = (bytes[lastIx] & 0x80) !== 0;

  var y = utils.intFromLE(normed);
  return this.curve.pointFromY(y, xIsOdd);
};

EDDSA.prototype.encodeInt = function encodeInt(num) {
  return num.toArray('le', this.encodingLength);
};

EDDSA.prototype.decodeInt = function decodeInt(bytes) {
  return utils.intFromLE(bytes);
};

EDDSA.prototype.isPoint = function isPoint(val) {
  return val instanceof this.pointClass;
};

},{"../../elliptic":190,"./key":201,"./signature":202,"hash.js":207}],201:[function(require,module,exports){
'use strict';

var elliptic = require('../../elliptic');
var utils = elliptic.utils;
var assert = utils.assert;
var parseBytes = utils.parseBytes;
var cachedProperty = utils.cachedProperty;

/**
* @param {EDDSA} eddsa - instance
* @param {Object} params - public/private key parameters
*
* @param {Array<Byte>} [params.secret] - secret seed bytes
* @param {Point} [params.pub] - public key point (aka `A` in eddsa terms)
* @param {Array<Byte>} [params.pub] - public key point encoded as bytes
*
*/
function KeyPair(eddsa, params) {
  this.eddsa = eddsa;
  this._secret = parseBytes(params.secret);
  if (eddsa.isPoint(params.pub))
    this._pub = params.pub;
  else
    this._pubBytes = parseBytes(params.pub);
}

KeyPair.fromPublic = function fromPublic(eddsa, pub) {
  if (pub instanceof KeyPair)
    return pub;
  return new KeyPair(eddsa, { pub: pub });
};

KeyPair.fromSecret = function fromSecret(eddsa, secret) {
  if (secret instanceof KeyPair)
    return secret;
  return new KeyPair(eddsa, { secret: secret });
};

KeyPair.prototype.secret = function secret() {
  return this._secret;
};

cachedProperty(KeyPair, function pubBytes() {
  return this.eddsa.encodePoint(this.pub());
});

cachedProperty(KeyPair, function pub() {
  if (this._pubBytes)
    return this.eddsa.decodePoint(this._pubBytes);
  return this.eddsa.g.mul(this.priv());
});

cachedProperty(KeyPair, function privBytes() {
  var eddsa = this.eddsa;
  var hash = this.hash();
  var lastIx = eddsa.encodingLength - 1;

  var a = hash.slice(0, eddsa.encodingLength);
  a[0] &= 248;
  a[lastIx] &= 127;
  a[lastIx] |= 64;

  return a;
});

cachedProperty(KeyPair, function priv() {
  return this.eddsa.decodeInt(this.privBytes());
});

cachedProperty(KeyPair, function hash() {
  return this.eddsa.hash().update(this.secret()).digest();
});

cachedProperty(KeyPair, function messagePrefix() {
  return this.hash().slice(this.eddsa.encodingLength);
});

KeyPair.prototype.sign = function sign(message) {
  assert(this._secret, 'KeyPair can only verify');
  return this.eddsa.sign(message, this);
};

KeyPair.prototype.verify = function verify(message, sig) {
  return this.eddsa.verify(message, sig, this);
};

KeyPair.prototype.getSecret = function getSecret(enc) {
  assert(this._secret, 'KeyPair is public only');
  return utils.encode(this.secret(), enc);
};

KeyPair.prototype.getPublic = function getPublic(enc) {
  return utils.encode(this.pubBytes(), enc);
};

module.exports = KeyPair;

},{"../../elliptic":190}],202:[function(require,module,exports){
'use strict';

var bn = require('bn.js');
var elliptic = require('../../elliptic');
var utils = elliptic.utils;
var assert = utils.assert;
var cachedProperty = utils.cachedProperty;
var parseBytes = utils.parseBytes;

/**
* @param {EDDSA} eddsa - eddsa instance
* @param {Array<Bytes>|Object} sig -
* @param {Array<Bytes>|Point} [sig.R] - R point as Point or bytes
* @param {Array<Bytes>|bn} [sig.S] - S scalar as bn or bytes
* @param {Array<Bytes>} [sig.Rencoded] - R point encoded
* @param {Array<Bytes>} [sig.Sencoded] - S scalar encoded
*/
function Signature(eddsa, sig) {
  this.eddsa = eddsa;

  if (typeof sig !== 'object')
    sig = parseBytes(sig);

  if (Array.isArray(sig)) {
    sig = {
      R: sig.slice(0, eddsa.encodingLength),
      S: sig.slice(eddsa.encodingLength)
    };
  }

  assert(sig.R && sig.S, 'Signature without R or S');

  if (eddsa.isPoint(sig.R))
    this._R = sig.R;
  if (sig.S instanceof bn)
    this._S = sig.S;

  this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
  this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
}

cachedProperty(Signature, function S() {
  return this.eddsa.decodeInt(this.Sencoded());
});

cachedProperty(Signature, function R() {
  return this.eddsa.decodePoint(this.Rencoded());
});

cachedProperty(Signature, function Rencoded() {
  return this.eddsa.encodePoint(this.R());
});

cachedProperty(Signature, function Sencoded() {
  return this.eddsa.encodeInt(this.S());
});

Signature.prototype.toBytes = function toBytes() {
  return this.Rencoded().concat(this.Sencoded());
};

Signature.prototype.toHex = function toHex() {
  return utils.encode(this.toBytes(), 'hex').toUpperCase();
};

module.exports = Signature;

},{"../../elliptic":190,"bn.js":188}],203:[function(require,module,exports){
'use strict';

var hash = require('hash.js');
var elliptic = require('../elliptic');
var utils = elliptic.utils;
var assert = utils.assert;

function HmacDRBG(options) {
  if (!(this instanceof HmacDRBG))
    return new HmacDRBG(options);
  this.hash = options.hash;
  this.predResist = !!options.predResist;

  this.outLen = this.hash.outSize;
  this.minEntropy = options.minEntropy || this.hash.hmacStrength;

  this.reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;

  var entropy = utils.toArray(options.entropy, options.entropyEnc);
  var nonce = utils.toArray(options.nonce, options.nonceEnc);
  var pers = utils.toArray(options.pers, options.persEnc);
  assert(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');
  this._init(entropy, nonce, pers);
}
module.exports = HmacDRBG;

HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
  var seed = entropy.concat(nonce).concat(pers);

  this.K = new Array(this.outLen / 8);
  this.V = new Array(this.outLen / 8);
  for (var i = 0; i < this.V.length; i++) {
    this.K[i] = 0x00;
    this.V[i] = 0x01;
  }

  this._update(seed);
  this.reseed = 1;
  this.reseedInterval = 0x1000000000000;  // 2^48
};

HmacDRBG.prototype._hmac = function hmac() {
  return new hash.hmac(this.hash, this.K);
};

HmacDRBG.prototype._update = function update(seed) {
  var kmac = this._hmac()
                 .update(this.V)
                 .update([ 0x00 ]);
  if (seed)
    kmac = kmac.update(seed);
  this.K = kmac.digest();
  this.V = this._hmac().update(this.V).digest();
  if (!seed)
    return;

  this.K = this._hmac()
               .update(this.V)
               .update([ 0x01 ])
               .update(seed)
               .digest();
  this.V = this._hmac().update(this.V).digest();
};

HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
  // Optional entropy enc
  if (typeof entropyEnc !== 'string') {
    addEnc = add;
    add = entropyEnc;
    entropyEnc = null;
  }

  entropy = utils.toBuffer(entropy, entropyEnc);
  add = utils.toBuffer(add, addEnc);

  assert(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');

  this._update(entropy.concat(add || []));
  this.reseed = 1;
};

HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
  if (this.reseed > this.reseedInterval)
    throw new Error('Reseed is required');

  // Optional encoding
  if (typeof enc !== 'string') {
    addEnc = add;
    add = enc;
    enc = null;
  }

  // Optional additional data
  if (add) {
    add = utils.toArray(add, addEnc);
    this._update(add);
  }

  var temp = [];
  while (temp.length < len) {
    this.V = this._hmac().update(this.V).digest();
    temp = temp.concat(this.V);
  }

  var res = temp.slice(0, len);
  this._update(add);
  this.reseed++;
  return utils.encode(res, enc);
};

},{"../elliptic":190,"hash.js":207}],204:[function(require,module,exports){
module.exports = {
  doubles: {
    step: 4,
    points: [
      [
        'e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a',
        'f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821'
      ],
      [
        '8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508',
        '11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf'
      ],
      [
        '175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739',
        'd3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695'
      ],
      [
        '363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640',
        '4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9'
      ],
      [
        '8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c',
        '4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36'
      ],
      [
        '723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda',
        '96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f'
      ],
      [
        'eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa',
        '5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999'
      ],
      [
        '100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0',
        'cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09'
      ],
      [
        'e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d',
        '9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d'
      ],
      [
        'feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d',
        'e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088'
      ],
      [
        'da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1',
        '9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d'
      ],
      [
        '53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0',
        '5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8'
      ],
      [
        '8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047',
        '10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a'
      ],
      [
        '385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862',
        '283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453'
      ],
      [
        '6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7',
        '7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160'
      ],
      [
        '3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd',
        '56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0'
      ],
      [
        '85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83',
        '7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6'
      ],
      [
        '948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a',
        '53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589'
      ],
      [
        '6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8',
        'bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17'
      ],
      [
        'e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d',
        '4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda'
      ],
      [
        'e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725',
        '7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd'
      ],
      [
        '213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754',
        '4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2'
      ],
      [
        '4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c',
        '17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6'
      ],
      [
        'fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6',
        '6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f'
      ],
      [
        '76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39',
        'c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01'
      ],
      [
        'c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891',
        '893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3'
      ],
      [
        'd895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b',
        'febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f'
      ],
      [
        'b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03',
        '2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7'
      ],
      [
        'e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d',
        'eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78'
      ],
      [
        'a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070',
        '7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1'
      ],
      [
        '90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4',
        'e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150'
      ],
      [
        '8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da',
        '662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82'
      ],
      [
        'e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11',
        '1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc'
      ],
      [
        '8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e',
        'efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b'
      ],
      [
        'e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41',
        '2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51'
      ],
      [
        'b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef',
        '67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45'
      ],
      [
        'd68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8',
        'db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120'
      ],
      [
        '324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d',
        '648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84'
      ],
      [
        '4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96',
        '35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d'
      ],
      [
        '9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd',
        'ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d'
      ],
      [
        '6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5',
        '9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8'
      ],
      [
        'a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266',
        '40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8'
      ],
      [
        '7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71',
        '34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac'
      ],
      [
        '928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac',
        'c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f'
      ],
      [
        '85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751',
        '1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962'
      ],
      [
        'ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e',
        '493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907'
      ],
      [
        '827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241',
        'c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec'
      ],
      [
        'eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3',
        'be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d'
      ],
      [
        'e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f',
        '4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414'
      ],
      [
        '1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19',
        'aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd'
      ],
      [
        '146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be',
        'b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0'
      ],
      [
        'fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9',
        '6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811'
      ],
      [
        'da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2',
        '8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1'
      ],
      [
        'a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13',
        '7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c'
      ],
      [
        '174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c',
        'ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73'
      ],
      [
        '959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba',
        '2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd'
      ],
      [
        'd2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151',
        'e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405'
      ],
      [
        '64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073',
        'd99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589'
      ],
      [
        '8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458',
        '38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e'
      ],
      [
        '13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b',
        '69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27'
      ],
      [
        'bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366',
        'd3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1'
      ],
      [
        '8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa',
        '40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482'
      ],
      [
        '8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0',
        '620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945'
      ],
      [
        'dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787',
        '7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573'
      ],
      [
        'f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e',
        'ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82'
      ]
    ]
  },
  naf: {
    wnd: 7,
    points: [
      [
        'f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9',
        '388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672'
      ],
      [
        '2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4',
        'd8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6'
      ],
      [
        '5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc',
        '6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da'
      ],
      [
        'acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe',
        'cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37'
      ],
      [
        '774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb',
        'd984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b'
      ],
      [
        'f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8',
        'ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81'
      ],
      [
        'd7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e',
        '581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58'
      ],
      [
        'defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34',
        '4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77'
      ],
      [
        '2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c',
        '85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a'
      ],
      [
        '352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5',
        '321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c'
      ],
      [
        '2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f',
        '2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67'
      ],
      [
        '9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714',
        '73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402'
      ],
      [
        'daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729',
        'a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55'
      ],
      [
        'c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db',
        '2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482'
      ],
      [
        '6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4',
        'e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82'
      ],
      [
        '1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5',
        'b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396'
      ],
      [
        '605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479',
        '2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49'
      ],
      [
        '62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d',
        '80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf'
      ],
      [
        '80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f',
        '1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a'
      ],
      [
        '7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb',
        'd0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7'
      ],
      [
        'd528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9',
        'eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933'
      ],
      [
        '49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963',
        '758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a'
      ],
      [
        '77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74',
        '958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6'
      ],
      [
        'f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530',
        'e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37'
      ],
      [
        '463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b',
        '5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e'
      ],
      [
        'f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247',
        'cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6'
      ],
      [
        'caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1',
        'cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476'
      ],
      [
        '2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120',
        '4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40'
      ],
      [
        '7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435',
        '91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61'
      ],
      [
        '754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18',
        '673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683'
      ],
      [
        'e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8',
        '59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5'
      ],
      [
        '186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb',
        '3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b'
      ],
      [
        'df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f',
        '55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417'
      ],
      [
        '5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143',
        'efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868'
      ],
      [
        '290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba',
        'e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a'
      ],
      [
        'af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45',
        'f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6'
      ],
      [
        '766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a',
        '744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996'
      ],
      [
        '59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e',
        'c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e'
      ],
      [
        'f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8',
        'e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d'
      ],
      [
        '7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c',
        '30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2'
      ],
      [
        '948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519',
        'e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e'
      ],
      [
        '7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab',
        '100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437'
      ],
      [
        '3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca',
        'ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311'
      ],
      [
        'd3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf',
        '8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4'
      ],
      [
        '1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610',
        '68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575'
      ],
      [
        '733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4',
        'f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d'
      ],
      [
        '15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c',
        'd56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d'
      ],
      [
        'a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940',
        'edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629'
      ],
      [
        'e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980',
        'a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06'
      ],
      [
        '311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3',
        '66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374'
      ],
      [
        '34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf',
        '9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee'
      ],
      [
        'f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63',
        '4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1'
      ],
      [
        'd7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448',
        'fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b'
      ],
      [
        '32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf',
        '5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661'
      ],
      [
        '7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5',
        '8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6'
      ],
      [
        'ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6',
        '8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e'
      ],
      [
        '16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5',
        '5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d'
      ],
      [
        'eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99',
        'f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc'
      ],
      [
        '78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51',
        'f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4'
      ],
      [
        '494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5',
        '42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c'
      ],
      [
        'a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5',
        '204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b'
      ],
      [
        'c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997',
        '4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913'
      ],
      [
        '841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881',
        '73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154'
      ],
      [
        '5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5',
        '39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865'
      ],
      [
        '36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66',
        'd2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc'
      ],
      [
        '336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726',
        'ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224'
      ],
      [
        '8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede',
        '6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e'
      ],
      [
        '1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94',
        '60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6'
      ],
      [
        '85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31',
        '3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511'
      ],
      [
        '29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51',
        'b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b'
      ],
      [
        'a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252',
        'ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2'
      ],
      [
        '4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5',
        'cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c'
      ],
      [
        'd24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b',
        '6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3'
      ],
      [
        'ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4',
        '322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d'
      ],
      [
        'af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f',
        '6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700'
      ],
      [
        'e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889',
        '2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4'
      ],
      [
        '591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246',
        'b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196'
      ],
      [
        '11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984',
        '998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4'
      ],
      [
        '3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a',
        'b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257'
      ],
      [
        'cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030',
        'bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13'
      ],
      [
        'c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197',
        '6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096'
      ],
      [
        'c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593',
        'c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38'
      ],
      [
        'a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef',
        '21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f'
      ],
      [
        '347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38',
        '60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448'
      ],
      [
        'da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a',
        '49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a'
      ],
      [
        'c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111',
        '5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4'
      ],
      [
        '4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502',
        '7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437'
      ],
      [
        '3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea',
        'be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7'
      ],
      [
        'cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26',
        '8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d'
      ],
      [
        'b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986',
        '39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a'
      ],
      [
        'd4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e',
        '62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54'
      ],
      [
        '48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4',
        '25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77'
      ],
      [
        'dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda',
        'ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517'
      ],
      [
        '6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859',
        'cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10'
      ],
      [
        'e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f',
        'f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125'
      ],
      [
        'eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c',
        '6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e'
      ],
      [
        '13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942',
        'fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1'
      ],
      [
        'ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a',
        '1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2'
      ],
      [
        'b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80',
        '5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423'
      ],
      [
        'ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d',
        '438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8'
      ],
      [
        '8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1',
        'cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758'
      ],
      [
        '52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63',
        'c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375'
      ],
      [
        'e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352',
        '6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d'
      ],
      [
        '7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193',
        'ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec'
      ],
      [
        '5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00',
        '9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0'
      ],
      [
        '32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58',
        'ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c'
      ],
      [
        'e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7',
        'd3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4'
      ],
      [
        '8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8',
        'c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f'
      ],
      [
        '4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e',
        '67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649'
      ],
      [
        '3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d',
        'cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826'
      ],
      [
        '674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b',
        '299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5'
      ],
      [
        'd32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f',
        'f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87'
      ],
      [
        '30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6',
        '462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b'
      ],
      [
        'be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297',
        '62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc'
      ],
      [
        '93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a',
        '7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c'
      ],
      [
        'b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c',
        'ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f'
      ],
      [
        'd5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52',
        '4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a'
      ],
      [
        'd3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb',
        'bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46'
      ],
      [
        '463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065',
        'bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f'
      ],
      [
        '7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917',
        '603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03'
      ],
      [
        '74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9',
        'cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08'
      ],
      [
        '30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3',
        '553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8'
      ],
      [
        '9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57',
        '712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373'
      ],
      [
        '176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66',
        'ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3'
      ],
      [
        '75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8',
        '9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8'
      ],
      [
        '809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721',
        '9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1'
      ],
      [
        '1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180',
        '4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9'
      ]
    ]
  }
};

},{}],205:[function(require,module,exports){
'use strict';

var utils = exports;
var bn = require('bn.js');

utils.assert = function assert(val, msg) {
  if (!val)
    throw new Error(msg || 'Assertion failed');
};

function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg !== 'string') {
    for (var i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
    return res;
  }
  if (!enc) {
    for (var i = 0; i < msg.length; i++) {
      var c = msg.charCodeAt(i);
      var hi = c >> 8;
      var lo = c & 0xff;
      if (hi)
        res.push(hi, lo);
      else
        res.push(lo);
    }
  } else if (enc === 'hex') {
    msg = msg.replace(/[^a-z0-9]+/ig, '');
    if (msg.length % 2 !== 0)
      msg = '0' + msg;
    for (var i = 0; i < msg.length; i += 2)
      res.push(parseInt(msg[i] + msg[i + 1], 16));
  }
  return res;
}
utils.toArray = toArray;

function zero2(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
utils.zero2 = zero2;

function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
utils.toHex = toHex;

utils.encode = function encode(arr, enc) {
  if (enc === 'hex')
    return toHex(arr);
  else
    return arr;
};

// Represent num in a w-NAF form
function getNAF(num, w) {
  var naf = [];
  var ws = 1 << (w + 1);
  var k = num.clone();
  while (k.cmpn(1) >= 0) {
    var z;
    if (k.isOdd()) {
      var mod = k.andln(ws - 1);
      if (mod > (ws >> 1) - 1)
        z = (ws >> 1) - mod;
      else
        z = mod;
      k.isubn(z);
    } else {
      z = 0;
    }
    naf.push(z);

    // Optimization, shift by word if possible
    var shift = (k.cmpn(0) !== 0 && k.andln(ws - 1) === 0) ? (w + 1) : 1;
    for (var i = 1; i < shift; i++)
      naf.push(0);
    k.iushrn(shift);
  }

  return naf;
}
utils.getNAF = getNAF;

// Represent k1, k2 in a Joint Sparse Form
function getJSF(k1, k2) {
  var jsf = [
    [],
    []
  ];

  k1 = k1.clone();
  k2 = k2.clone();
  var d1 = 0;
  var d2 = 0;
  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {

    // First phase
    var m14 = (k1.andln(3) + d1) & 3;
    var m24 = (k2.andln(3) + d2) & 3;
    if (m14 === 3)
      m14 = -1;
    if (m24 === 3)
      m24 = -1;
    var u1;
    if ((m14 & 1) === 0) {
      u1 = 0;
    } else {
      var m8 = (k1.andln(7) + d1) & 7;
      if ((m8 === 3 || m8 === 5) && m24 === 2)
        u1 = -m14;
      else
        u1 = m14;
    }
    jsf[0].push(u1);

    var u2;
    if ((m24 & 1) === 0) {
      u2 = 0;
    } else {
      var m8 = (k2.andln(7) + d2) & 7;
      if ((m8 === 3 || m8 === 5) && m14 === 2)
        u2 = -m24;
      else
        u2 = m24;
    }
    jsf[1].push(u2);

    // Second phase
    if (2 * d1 === u1 + 1)
      d1 = 1 - d1;
    if (2 * d2 === u2 + 1)
      d2 = 1 - d2;
    k1.iushrn(1);
    k2.iushrn(1);
  }

  return jsf;
}
utils.getJSF = getJSF;

function cachedProperty(obj, computer) {
  var name = computer.name;
  var key = '_' + name;
  obj.prototype[name] = function cachedProperty() {
    return this[key] !== undefined ? this[key] :
           this[key] = computer.call(this);
  };
}
utils.cachedProperty = cachedProperty;

function parseBytes(bytes) {
  return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') :
                                     bytes;
}
utils.parseBytes = parseBytes;

function intFromLE(bytes) {
  return new bn(bytes, 'hex', 'le');
}
utils.intFromLE = intFromLE;


},{"bn.js":188}],206:[function(require,module,exports){
var r;

module.exports = function rand(len) {
  if (!r)
    r = new Rand(null);

  return r.generate(len);
};

function Rand(rand) {
  this.rand = rand;
}
module.exports.Rand = Rand;

Rand.prototype.generate = function generate(len) {
  return this._rand(len);
};

if (typeof window === 'object') {
  if (window.crypto && window.crypto.getRandomValues) {
    // Modern browsers
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      window.crypto.getRandomValues(arr);
      return arr;
    };
  } else if (window.msCrypto && window.msCrypto.getRandomValues) {
    // IE
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      window.msCrypto.getRandomValues(arr);
      return arr;
    };
  } else {
    // Old junk
    Rand.prototype._rand = function() {
      throw new Error('Not implemented yet');
    };
  }
} else {
  // Node.js or Web worker
  try {
    var crypto = require('cry' + 'pto');

    Rand.prototype._rand = function _rand(n) {
      return crypto.randomBytes(n);
    };
  } catch (e) {
    // Emulate crypto API using randy
    Rand.prototype._rand = function _rand(n) {
      var res = new Uint8Array(n);
      for (var i = 0; i < res.length; i++)
        res[i] = this.rand.getByte();
      return res;
    };
  }
}

},{}],207:[function(require,module,exports){
var hash = exports;

hash.utils = require('./hash/utils');
hash.common = require('./hash/common');
hash.sha = require('./hash/sha');
hash.ripemd = require('./hash/ripemd');
hash.hmac = require('./hash/hmac');

// Proxy hash functions to the main object
hash.sha1 = hash.sha.sha1;
hash.sha256 = hash.sha.sha256;
hash.sha224 = hash.sha.sha224;
hash.sha384 = hash.sha.sha384;
hash.sha512 = hash.sha.sha512;
hash.ripemd160 = hash.ripemd.ripemd160;

},{"./hash/common":208,"./hash/hmac":209,"./hash/ripemd":210,"./hash/sha":211,"./hash/utils":212}],208:[function(require,module,exports){
var hash = require('../hash');
var utils = hash.utils;
var assert = utils.assert;

function BlockHash() {
  this.pending = null;
  this.pendingTotal = 0;
  this.blockSize = this.constructor.blockSize;
  this.outSize = this.constructor.outSize;
  this.hmacStrength = this.constructor.hmacStrength;
  this.padLength = this.constructor.padLength / 8;
  this.endian = 'big';

  this._delta8 = this.blockSize / 8;
  this._delta32 = this.blockSize / 32;
}
exports.BlockHash = BlockHash;

BlockHash.prototype.update = function update(msg, enc) {
  // Convert message to array, pad it, and join into 32bit blocks
  msg = utils.toArray(msg, enc);
  if (!this.pending)
    this.pending = msg;
  else
    this.pending = this.pending.concat(msg);
  this.pendingTotal += msg.length;

  // Enough data, try updating
  if (this.pending.length >= this._delta8) {
    msg = this.pending;

    // Process pending data in blocks
    var r = msg.length % this._delta8;
    this.pending = msg.slice(msg.length - r, msg.length);
    if (this.pending.length === 0)
      this.pending = null;

    msg = utils.join32(msg, 0, msg.length - r, this.endian);
    for (var i = 0; i < msg.length; i += this._delta32)
      this._update(msg, i, i + this._delta32);
  }

  return this;
};

BlockHash.prototype.digest = function digest(enc) {
  this.update(this._pad());
  assert(this.pending === null);

  return this._digest(enc);
};

BlockHash.prototype._pad = function pad() {
  var len = this.pendingTotal;
  var bytes = this._delta8;
  var k = bytes - ((len + this.padLength) % bytes);
  var res = new Array(k + this.padLength);
  res[0] = 0x80;
  for (var i = 1; i < k; i++)
    res[i] = 0;

  // Append length
  len <<= 3;
  if (this.endian === 'big') {
    for (var t = 8; t < this.padLength; t++)
      res[i++] = 0;

    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = len & 0xff;
  } else {
    res[i++] = len & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;

    for (var t = 8; t < this.padLength; t++)
      res[i++] = 0;
  }

  return res;
};

},{"../hash":207}],209:[function(require,module,exports){
var hmac = exports;

var hash = require('../hash');
var utils = hash.utils;
var assert = utils.assert;

function Hmac(hash, key, enc) {
  if (!(this instanceof Hmac))
    return new Hmac(hash, key, enc);
  this.Hash = hash;
  this.blockSize = hash.blockSize / 8;
  this.outSize = hash.outSize / 8;
  this.inner = null;
  this.outer = null;

  this._init(utils.toArray(key, enc));
}
module.exports = Hmac;

Hmac.prototype._init = function init(key) {
  // Shorten key, if needed
  if (key.length > this.blockSize)
    key = new this.Hash().update(key).digest();
  assert(key.length <= this.blockSize);

  // Add padding to key
  for (var i = key.length; i < this.blockSize; i++)
    key.push(0);

  for (var i = 0; i < key.length; i++)
    key[i] ^= 0x36;
  this.inner = new this.Hash().update(key);

  // 0x36 ^ 0x5c = 0x6a
  for (var i = 0; i < key.length; i++)
    key[i] ^= 0x6a;
  this.outer = new this.Hash().update(key);
};

Hmac.prototype.update = function update(msg, enc) {
  this.inner.update(msg, enc);
  return this;
};

Hmac.prototype.digest = function digest(enc) {
  this.outer.update(this.inner.digest());
  return this.outer.digest(enc);
};

},{"../hash":207}],210:[function(require,module,exports){
var hash = require('../hash');
var utils = hash.utils;

var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_3 = utils.sum32_3;
var sum32_4 = utils.sum32_4;
var BlockHash = hash.common.BlockHash;

function RIPEMD160() {
  if (!(this instanceof RIPEMD160))
    return new RIPEMD160();

  BlockHash.call(this);

  this.h = [ 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0 ];
  this.endian = 'little';
}
utils.inherits(RIPEMD160, BlockHash);
exports.ripemd160 = RIPEMD160;

RIPEMD160.blockSize = 512;
RIPEMD160.outSize = 160;
RIPEMD160.hmacStrength = 192;
RIPEMD160.padLength = 64;

RIPEMD160.prototype._update = function update(msg, start) {
  var A = this.h[0];
  var B = this.h[1];
  var C = this.h[2];
  var D = this.h[3];
  var E = this.h[4];
  var Ah = A;
  var Bh = B;
  var Ch = C;
  var Dh = D;
  var Eh = E;
  for (var j = 0; j < 80; j++) {
    var T = sum32(
      rotl32(
        sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)),
        s[j]),
      E);
    A = E;
    E = D;
    D = rotl32(C, 10);
    C = B;
    B = T;
    T = sum32(
      rotl32(
        sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),
        sh[j]),
      Eh);
    Ah = Eh;
    Eh = Dh;
    Dh = rotl32(Ch, 10);
    Ch = Bh;
    Bh = T;
  }
  T = sum32_3(this.h[1], C, Dh);
  this.h[1] = sum32_3(this.h[2], D, Eh);
  this.h[2] = sum32_3(this.h[3], E, Ah);
  this.h[3] = sum32_3(this.h[4], A, Bh);
  this.h[4] = sum32_3(this.h[0], B, Ch);
  this.h[0] = T;
};

RIPEMD160.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'little');
  else
    return utils.split32(this.h, 'little');
};

function f(j, x, y, z) {
  if (j <= 15)
    return x ^ y ^ z;
  else if (j <= 31)
    return (x & y) | ((~x) & z);
  else if (j <= 47)
    return (x | (~y)) ^ z;
  else if (j <= 63)
    return (x & z) | (y & (~z));
  else
    return x ^ (y | (~z));
}

function K(j) {
  if (j <= 15)
    return 0x00000000;
  else if (j <= 31)
    return 0x5a827999;
  else if (j <= 47)
    return 0x6ed9eba1;
  else if (j <= 63)
    return 0x8f1bbcdc;
  else
    return 0xa953fd4e;
}

function Kh(j) {
  if (j <= 15)
    return 0x50a28be6;
  else if (j <= 31)
    return 0x5c4dd124;
  else if (j <= 47)
    return 0x6d703ef3;
  else if (j <= 63)
    return 0x7a6d76e9;
  else
    return 0x00000000;
}

var r = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
];

var rh = [
  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
];

var s = [
  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
];

var sh = [
  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
];

},{"../hash":207}],211:[function(require,module,exports){
var hash = require('../hash');
var utils = hash.utils;
var assert = utils.assert;

var rotr32 = utils.rotr32;
var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_4 = utils.sum32_4;
var sum32_5 = utils.sum32_5;
var rotr64_hi = utils.rotr64_hi;
var rotr64_lo = utils.rotr64_lo;
var shr64_hi = utils.shr64_hi;
var shr64_lo = utils.shr64_lo;
var sum64 = utils.sum64;
var sum64_hi = utils.sum64_hi;
var sum64_lo = utils.sum64_lo;
var sum64_4_hi = utils.sum64_4_hi;
var sum64_4_lo = utils.sum64_4_lo;
var sum64_5_hi = utils.sum64_5_hi;
var sum64_5_lo = utils.sum64_5_lo;
var BlockHash = hash.common.BlockHash;

var sha256_K = [
  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
  0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
  0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
  0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
  0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
  0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
  0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
  0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
  0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
];

var sha512_K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
];

var sha1_K = [
  0x5A827999, 0x6ED9EBA1,
  0x8F1BBCDC, 0xCA62C1D6
];

function SHA256() {
  if (!(this instanceof SHA256))
    return new SHA256();

  BlockHash.call(this);
  this.h = [ 0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
             0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19 ];
  this.k = sha256_K;
  this.W = new Array(64);
}
utils.inherits(SHA256, BlockHash);
exports.sha256 = SHA256;

SHA256.blockSize = 512;
SHA256.outSize = 256;
SHA256.hmacStrength = 192;
SHA256.padLength = 64;

SHA256.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];
  for (; i < W.length; i++)
    W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];
  var f = this.h[5];
  var g = this.h[6];
  var h = this.h[7];

  assert(this.k.length === W.length);
  for (var i = 0; i < W.length; i++) {
    var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
    var T2 = sum32(s0_256(a), maj32(a, b, c));
    h = g;
    g = f;
    f = e;
    e = sum32(d, T1);
    d = c;
    c = b;
    b = a;
    a = sum32(T1, T2);
  }

  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
  this.h[5] = sum32(this.h[5], f);
  this.h[6] = sum32(this.h[6], g);
  this.h[7] = sum32(this.h[7], h);
};

SHA256.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};

function SHA224() {
  if (!(this instanceof SHA224))
    return new SHA224();

  SHA256.call(this);
  this.h = [ 0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
             0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4 ];
}
utils.inherits(SHA224, SHA256);
exports.sha224 = SHA224;

SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;

SHA224.prototype._digest = function digest(enc) {
  // Just truncate output
  if (enc === 'hex')
    return utils.toHex32(this.h.slice(0, 7), 'big');
  else
    return utils.split32(this.h.slice(0, 7), 'big');
};

function SHA512() {
  if (!(this instanceof SHA512))
    return new SHA512();

  BlockHash.call(this);
  this.h = [ 0x6a09e667, 0xf3bcc908,
             0xbb67ae85, 0x84caa73b,
             0x3c6ef372, 0xfe94f82b,
             0xa54ff53a, 0x5f1d36f1,
             0x510e527f, 0xade682d1,
             0x9b05688c, 0x2b3e6c1f,
             0x1f83d9ab, 0xfb41bd6b,
             0x5be0cd19, 0x137e2179 ];
  this.k = sha512_K;
  this.W = new Array(160);
}
utils.inherits(SHA512, BlockHash);
exports.sha512 = SHA512;

SHA512.blockSize = 1024;
SHA512.outSize = 512;
SHA512.hmacStrength = 192;
SHA512.padLength = 128;

SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
  var W = this.W;

  // 32 x 32bit words
  for (var i = 0; i < 32; i++)
    W[i] = msg[start + i];
  for (; i < W.length; i += 2) {
    var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);  // i - 2
    var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
    var c1_hi = W[i - 14];  // i - 7
    var c1_lo = W[i - 13];
    var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);  // i - 15
    var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
    var c3_hi = W[i - 32];  // i - 16
    var c3_lo = W[i - 31];

    W[i] = sum64_4_hi(c0_hi, c0_lo,
                      c1_hi, c1_lo,
                      c2_hi, c2_lo,
                      c3_hi, c3_lo);
    W[i + 1] = sum64_4_lo(c0_hi, c0_lo,
                          c1_hi, c1_lo,
                          c2_hi, c2_lo,
                          c3_hi, c3_lo);
  }
};

SHA512.prototype._update = function _update(msg, start) {
  this._prepareBlock(msg, start);

  var W = this.W;

  var ah = this.h[0];
  var al = this.h[1];
  var bh = this.h[2];
  var bl = this.h[3];
  var ch = this.h[4];
  var cl = this.h[5];
  var dh = this.h[6];
  var dl = this.h[7];
  var eh = this.h[8];
  var el = this.h[9];
  var fh = this.h[10];
  var fl = this.h[11];
  var gh = this.h[12];
  var gl = this.h[13];
  var hh = this.h[14];
  var hl = this.h[15];

  assert(this.k.length === W.length);
  for (var i = 0; i < W.length; i += 2) {
    var c0_hi = hh;
    var c0_lo = hl;
    var c1_hi = s1_512_hi(eh, el);
    var c1_lo = s1_512_lo(eh, el);
    var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
    var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
    var c3_hi = this.k[i];
    var c3_lo = this.k[i + 1];
    var c4_hi = W[i];
    var c4_lo = W[i + 1];

    var T1_hi = sum64_5_hi(c0_hi, c0_lo,
                           c1_hi, c1_lo,
                           c2_hi, c2_lo,
                           c3_hi, c3_lo,
                           c4_hi, c4_lo);
    var T1_lo = sum64_5_lo(c0_hi, c0_lo,
                           c1_hi, c1_lo,
                           c2_hi, c2_lo,
                           c3_hi, c3_lo,
                           c4_hi, c4_lo);

    var c0_hi = s0_512_hi(ah, al);
    var c0_lo = s0_512_lo(ah, al);
    var c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
    var c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);

    var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
    var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);

    hh = gh;
    hl = gl;

    gh = fh;
    gl = fl;

    fh = eh;
    fl = el;

    eh = sum64_hi(dh, dl, T1_hi, T1_lo);
    el = sum64_lo(dl, dl, T1_hi, T1_lo);

    dh = ch;
    dl = cl;

    ch = bh;
    cl = bl;

    bh = ah;
    bl = al;

    ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
    al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
  }

  sum64(this.h, 0, ah, al);
  sum64(this.h, 2, bh, bl);
  sum64(this.h, 4, ch, cl);
  sum64(this.h, 6, dh, dl);
  sum64(this.h, 8, eh, el);
  sum64(this.h, 10, fh, fl);
  sum64(this.h, 12, gh, gl);
  sum64(this.h, 14, hh, hl);
};

SHA512.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};

function SHA384() {
  if (!(this instanceof SHA384))
    return new SHA384();

  SHA512.call(this);
  this.h = [ 0xcbbb9d5d, 0xc1059ed8,
             0x629a292a, 0x367cd507,
             0x9159015a, 0x3070dd17,
             0x152fecd8, 0xf70e5939,
             0x67332667, 0xffc00b31,
             0x8eb44a87, 0x68581511,
             0xdb0c2e0d, 0x64f98fa7,
             0x47b5481d, 0xbefa4fa4 ];
}
utils.inherits(SHA384, SHA512);
exports.sha384 = SHA384;

SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;

SHA384.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h.slice(0, 12), 'big');
  else
    return utils.split32(this.h.slice(0, 12), 'big');
};

function SHA1() {
  if (!(this instanceof SHA1))
    return new SHA1();

  BlockHash.call(this);
  this.h = [ 0x67452301, 0xefcdab89, 0x98badcfe,
             0x10325476, 0xc3d2e1f0 ];
  this.W = new Array(80);
}

utils.inherits(SHA1, BlockHash);
exports.sha1 = SHA1;

SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;

SHA1.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];

  for(; i < W.length; i++)
    W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];

  for (var i = 0; i < W.length; i++) {
    var s = ~~(i / 20);
    var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
    e = d;
    d = c;
    c = rotl32(b, 30);
    b = a;
    a = t;
  }

  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
};

SHA1.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};

function ch32(x, y, z) {
  return (x & y) ^ ((~x) & z);
}

function maj32(x, y, z) {
  return (x & y) ^ (x & z) ^ (y & z);
}

function p32(x, y, z) {
  return x ^ y ^ z;
}

function s0_256(x) {
  return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
}

function s1_256(x) {
  return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
}

function g0_256(x) {
  return rotr32(x, 7) ^ rotr32(x, 18) ^ (x >>> 3);
}

function g1_256(x) {
  return rotr32(x, 17) ^ rotr32(x, 19) ^ (x >>> 10);
}

function ft_1(s, x, y, z) {
  if (s === 0)
    return ch32(x, y, z);
  if (s === 1 || s === 3)
    return p32(x, y, z);
  if (s === 2)
    return maj32(x, y, z);
}

function ch64_hi(xh, xl, yh, yl, zh, zl) {
  var r = (xh & yh) ^ ((~xh) & zh);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function ch64_lo(xh, xl, yh, yl, zh, zl) {
  var r = (xl & yl) ^ ((~xl) & zl);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function maj64_hi(xh, xl, yh, yl, zh, zl) {
  var r = (xh & yh) ^ (xh & zh) ^ (yh & zh);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function maj64_lo(xh, xl, yh, yl, zh, zl) {
  var r = (xl & yl) ^ (xl & zl) ^ (yl & zl);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 28);
  var c1_hi = rotr64_hi(xl, xh, 2);  // 34
  var c2_hi = rotr64_hi(xl, xh, 7);  // 39

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 28);
  var c1_lo = rotr64_lo(xl, xh, 2);  // 34
  var c2_lo = rotr64_lo(xl, xh, 7);  // 39

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 14);
  var c1_hi = rotr64_hi(xh, xl, 18);
  var c2_hi = rotr64_hi(xl, xh, 9);  // 41

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 14);
  var c1_lo = rotr64_lo(xh, xl, 18);
  var c2_lo = rotr64_lo(xl, xh, 9);  // 41

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 1);
  var c1_hi = rotr64_hi(xh, xl, 8);
  var c2_hi = shr64_hi(xh, xl, 7);

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 1);
  var c1_lo = rotr64_lo(xh, xl, 8);
  var c2_lo = shr64_lo(xh, xl, 7);

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 19);
  var c1_hi = rotr64_hi(xl, xh, 29);  // 61
  var c2_hi = shr64_hi(xh, xl, 6);

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 19);
  var c1_lo = rotr64_lo(xl, xh, 29);  // 61
  var c2_lo = shr64_lo(xh, xl, 6);

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

},{"../hash":207}],212:[function(require,module,exports){
var utils = exports;
var inherits = require('inherits');

function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg === 'string') {
    if (!enc) {
      for (var i = 0; i < msg.length; i++) {
        var c = msg.charCodeAt(i);
        var hi = c >> 8;
        var lo = c & 0xff;
        if (hi)
          res.push(hi, lo);
        else
          res.push(lo);
      }
    } else if (enc === 'hex') {
      msg = msg.replace(/[^a-z0-9]+/ig, '');
      if (msg.length % 2 !== 0)
        msg = '0' + msg;
      for (var i = 0; i < msg.length; i += 2)
        res.push(parseInt(msg[i] + msg[i + 1], 16));
    }
  } else {
    for (var i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
  }
  return res;
}
utils.toArray = toArray;

function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
utils.toHex = toHex;

function htonl(w) {
  var res = (w >>> 24) |
            ((w >>> 8) & 0xff00) |
            ((w << 8) & 0xff0000) |
            ((w & 0xff) << 24);
  return res >>> 0;
}
utils.htonl = htonl;

function toHex32(msg, endian) {
  var res = '';
  for (var i = 0; i < msg.length; i++) {
    var w = msg[i];
    if (endian === 'little')
      w = htonl(w);
    res += zero8(w.toString(16));
  }
  return res;
}
utils.toHex32 = toHex32;

function zero2(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
utils.zero2 = zero2;

function zero8(word) {
  if (word.length === 7)
    return '0' + word;
  else if (word.length === 6)
    return '00' + word;
  else if (word.length === 5)
    return '000' + word;
  else if (word.length === 4)
    return '0000' + word;
  else if (word.length === 3)
    return '00000' + word;
  else if (word.length === 2)
    return '000000' + word;
  else if (word.length === 1)
    return '0000000' + word;
  else
    return word;
}
utils.zero8 = zero8;

function join32(msg, start, end, endian) {
  var len = end - start;
  assert(len % 4 === 0);
  var res = new Array(len / 4);
  for (var i = 0, k = start; i < res.length; i++, k += 4) {
    var w;
    if (endian === 'big')
      w = (msg[k] << 24) | (msg[k + 1] << 16) | (msg[k + 2] << 8) | msg[k + 3];
    else
      w = (msg[k + 3] << 24) | (msg[k + 2] << 16) | (msg[k + 1] << 8) | msg[k];
    res[i] = w >>> 0;
  }
  return res;
}
utils.join32 = join32;

function split32(msg, endian) {
  var res = new Array(msg.length * 4);
  for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
    var m = msg[i];
    if (endian === 'big') {
      res[k] = m >>> 24;
      res[k + 1] = (m >>> 16) & 0xff;
      res[k + 2] = (m >>> 8) & 0xff;
      res[k + 3] = m & 0xff;
    } else {
      res[k + 3] = m >>> 24;
      res[k + 2] = (m >>> 16) & 0xff;
      res[k + 1] = (m >>> 8) & 0xff;
      res[k] = m & 0xff;
    }
  }
  return res;
}
utils.split32 = split32;

function rotr32(w, b) {
  return (w >>> b) | (w << (32 - b));
}
utils.rotr32 = rotr32;

function rotl32(w, b) {
  return (w << b) | (w >>> (32 - b));
}
utils.rotl32 = rotl32;

function sum32(a, b) {
  return (a + b) >>> 0;
}
utils.sum32 = sum32;

function sum32_3(a, b, c) {
  return (a + b + c) >>> 0;
}
utils.sum32_3 = sum32_3;

function sum32_4(a, b, c, d) {
  return (a + b + c + d) >>> 0;
}
utils.sum32_4 = sum32_4;

function sum32_5(a, b, c, d, e) {
  return (a + b + c + d + e) >>> 0;
}
utils.sum32_5 = sum32_5;

function assert(cond, msg) {
  if (!cond)
    throw new Error(msg || 'Assertion failed');
}
utils.assert = assert;

utils.inherits = inherits;

function sum64(buf, pos, ah, al) {
  var bh = buf[pos];
  var bl = buf[pos + 1];

  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  buf[pos] = hi >>> 0;
  buf[pos + 1] = lo;
}
exports.sum64 = sum64;

function sum64_hi(ah, al, bh, bl) {
  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  return hi >>> 0;
};
exports.sum64_hi = sum64_hi;

function sum64_lo(ah, al, bh, bl) {
  var lo = al + bl;
  return lo >>> 0;
};
exports.sum64_lo = sum64_lo;

function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;

  var hi = ah + bh + ch + dh + carry;
  return hi >>> 0;
};
exports.sum64_4_hi = sum64_4_hi;

function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
  var lo = al + bl + cl + dl;
  return lo >>> 0;
};
exports.sum64_4_lo = sum64_4_lo;

function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;
  lo = (lo + el) >>> 0;
  carry += lo < el ? 1 : 0;

  var hi = ah + bh + ch + dh + eh + carry;
  return hi >>> 0;
};
exports.sum64_5_hi = sum64_5_hi;

function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var lo = al + bl + cl + dl + el;

  return lo >>> 0;
};
exports.sum64_5_lo = sum64_5_lo;

function rotr64_hi(ah, al, num) {
  var r = (al << (32 - num)) | (ah >>> num);
  return r >>> 0;
};
exports.rotr64_hi = rotr64_hi;

function rotr64_lo(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
};
exports.rotr64_lo = rotr64_lo;

function shr64_hi(ah, al, num) {
  return ah >>> num;
};
exports.shr64_hi = shr64_hi;

function shr64_lo(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
};
exports.shr64_lo = shr64_lo;

},{"inherits":348}],213:[function(require,module,exports){
module.exports={
  "name": "elliptic",
  "version": "6.0.2",
  "description": "EC cryptography",
  "main": "lib/elliptic.js",
  "files": [
    "lib"
  ],
  "scripts": {
    "test": "make lint && istanbul test _mocha --reporter=spec test/*-test.js",
    "coveralls": "cat ./coverage/lcov.info | coveralls"
  },
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/indutny/elliptic.git"
  },
  "keywords": [
    "EC",
    "Elliptic",
    "curve",
    "Cryptography"
  ],
  "author": {
    "name": "Fedor Indutny",
    "email": "fedor@indutny.com"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/indutny/elliptic/issues"
  },
  "homepage": "https://github.com/indutny/elliptic",
  "devDependencies": {
    "browserify": "^3.44.2",
    "coveralls": "^2.11.3",
    "istanbul": "^0.3.17",
    "jscs": "^1.11.3",
    "jshint": "^2.6.0",
    "mocha": "^2.1.0",
    "uglify-js": "^2.4.13"
  },
  "dependencies": {
    "bn.js": "^4.0.0",
    "brorand": "^1.0.1",
    "hash.js": "^1.0.0",
    "inherits": "^2.0.1"
  },
  "gitHead": "330106da186712d228d79bc71ae8e7e68565fa9d",
  "_id": "elliptic@6.0.2",
  "_shasum": "219b96cd92aa9885d91d31c1fd42eaa5eb4483a9",
  "_from": "elliptic@>=6.0.0 <7.0.0",
  "_npmVersion": "3.3.6",
  "_nodeVersion": "5.0.0",
  "_npmUser": {
    "name": "indutny",
    "email": "fedor@indutny.com"
  },
  "dist": {
    "shasum": "219b96cd92aa9885d91d31c1fd42eaa5eb4483a9",
    "tarball": "http://registry.npmjs.org/elliptic/-/elliptic-6.0.2.tgz"
  },
  "maintainers": [
    {
      "name": "indutny",
      "email": "fedor@indutny.com"
    }
  ],
  "directories": {},
  "_resolved": "https://registry.npmjs.org/elliptic/-/elliptic-6.0.2.tgz",
  "readme": "ERROR: No README data found!"
}

},{}],214:[function(require,module,exports){
module.exports={"2.16.840.1.101.3.4.1.1": "aes-128-ecb",
"2.16.840.1.101.3.4.1.2": "aes-128-cbc",
"2.16.840.1.101.3.4.1.3": "aes-128-ofb",
"2.16.840.1.101.3.4.1.4": "aes-128-cfb",
"2.16.840.1.101.3.4.1.21": "aes-192-ecb",
"2.16.840.1.101.3.4.1.22": "aes-192-cbc",
"2.16.840.1.101.3.4.1.23": "aes-192-ofb",
"2.16.840.1.101.3.4.1.24": "aes-192-cfb",
"2.16.840.1.101.3.4.1.41": "aes-256-ecb",
"2.16.840.1.101.3.4.1.42": "aes-256-cbc",
"2.16.840.1.101.3.4.1.43": "aes-256-ofb",
"2.16.840.1.101.3.4.1.44": "aes-256-cfb"
}
},{}],215:[function(require,module,exports){
// from https://github.com/indutny/self-signed/blob/gh-pages/lib/asn1.js
// Fedor, you are amazing.

var asn1 = require('asn1.js')

var RSAPrivateKey = asn1.define('RSAPrivateKey', function () {
  this.seq().obj(
    this.key('version').int(),
    this.key('modulus').int(),
    this.key('publicExponent').int(),
    this.key('privateExponent').int(),
    this.key('prime1').int(),
    this.key('prime2').int(),
    this.key('exponent1').int(),
    this.key('exponent2').int(),
    this.key('coefficient').int()
  )
})
exports.RSAPrivateKey = RSAPrivateKey

var RSAPublicKey = asn1.define('RSAPublicKey', function () {
  this.seq().obj(
    this.key('modulus').int(),
    this.key('publicExponent').int()
  )
})
exports.RSAPublicKey = RSAPublicKey

var PublicKey = asn1.define('SubjectPublicKeyInfo', function () {
  this.seq().obj(
    this.key('algorithm').use(AlgorithmIdentifier),
    this.key('subjectPublicKey').bitstr()
  )
})
exports.PublicKey = PublicKey

var AlgorithmIdentifier = asn1.define('AlgorithmIdentifier', function () {
  this.seq().obj(
    this.key('algorithm').objid(),
    this.key('none').null_().optional(),
    this.key('curve').objid().optional(),
    this.key('params').seq().obj(
      this.key('p').int(),
      this.key('q').int(),
      this.key('g').int()
    ).optional()
  )
})

var PrivateKeyInfo = asn1.define('PrivateKeyInfo', function () {
  this.seq().obj(
    this.key('version').int(),
    this.key('algorithm').use(AlgorithmIdentifier),
    this.key('subjectPrivateKey').octstr()
  )
})
exports.PrivateKey = PrivateKeyInfo
var EncryptedPrivateKeyInfo = asn1.define('EncryptedPrivateKeyInfo', function () {
  this.seq().obj(
    this.key('algorithm').seq().obj(
      this.key('id').objid(),
      this.key('decrypt').seq().obj(
        this.key('kde').seq().obj(
          this.key('id').objid(),
          this.key('kdeparams').seq().obj(
            this.key('salt').octstr(),
            this.key('iters').int()
          )
        ),
        this.key('cipher').seq().obj(
          this.key('algo').objid(),
          this.key('iv').octstr()
        )
      )
    ),
    this.key('subjectPrivateKey').octstr()
  )
})

exports.EncryptedPrivateKey = EncryptedPrivateKeyInfo

var DSAPrivateKey = asn1.define('DSAPrivateKey', function () {
  this.seq().obj(
    this.key('version').int(),
    this.key('p').int(),
    this.key('q').int(),
    this.key('g').int(),
    this.key('pub_key').int(),
    this.key('priv_key').int()
  )
})
exports.DSAPrivateKey = DSAPrivateKey

exports.DSAparam = asn1.define('DSAparam', function () {
  this.int()
})
var ECPrivateKey = asn1.define('ECPrivateKey', function () {
  this.seq().obj(
    this.key('version').int(),
    this.key('privateKey').octstr(),
    this.key('parameters').optional().explicit(0).use(ECParameters),
    this.key('publicKey').optional().explicit(1).bitstr()
  )
})
exports.ECPrivateKey = ECPrivateKey
var ECParameters = asn1.define('ECParameters', function () {
  this.choice({
    namedCurve: this.objid()
  })
})

exports.signature = asn1.define('signature', function () {
  this.seq().obj(
    this.key('r').int(),
    this.key('s').int()
  )
})

},{"asn1.js":218}],216:[function(require,module,exports){
(function (Buffer){
// adapted from https://github.com/apatil/pemstrip
var findProc = /Proc-Type: 4,ENCRYPTED\r?\nDEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)\r?\n\r?\n([0-9A-z\n\r\+\/\=]+)\r?\n/m
var startRegex = /^-----BEGIN (.*) KEY-----\r?\n/m
var fullRegex = /^-----BEGIN (.*) KEY-----\r?\n([0-9A-z\n\r\+\/\=]+)\r?\n-----END \1 KEY-----$/m
var evp = require('evp_bytestokey')
var ciphers = require('browserify-aes')
module.exports = function (okey, password) {
  var key = okey.toString()
  var match = key.match(findProc)
  var decrypted
  if (!match) {
    var match2 = key.match(fullRegex)
    decrypted = new Buffer(match2[2].replace(/\r?\n/g, ''), 'base64')
  } else {
    var suite = 'aes' + match[1]
    var iv = new Buffer(match[2], 'hex')
    var cipherText = new Buffer(match[3].replace(/\r?\n/g, ''), 'base64')
    var cipherKey = evp(password, iv.slice(0, 8), parseInt(match[1], 10)).key
    var out = []
    var cipher = ciphers.createDecipheriv(suite, cipherKey, iv)
    out.push(cipher.update(cipherText))
    out.push(cipher.final())
    decrypted = Buffer.concat(out)
  }
  var tag = key.match(startRegex)[1] + ' KEY'
  return {
    tag: tag,
    data: decrypted
  }
}

}).call(this,require("buffer").Buffer)

},{"browserify-aes":235,"buffer":151,"evp_bytestokey":250}],217:[function(require,module,exports){
(function (Buffer){
var asn1 = require('./asn1')
var aesid = require('./aesid.json')
var fixProc = require('./fixProc')
var ciphers = require('browserify-aes')
var compat = require('pbkdf2')
module.exports = parseKeys

function parseKeys (buffer) {
  var password
  if (typeof buffer === 'object' && !Buffer.isBuffer(buffer)) {
    password = buffer.passphrase
    buffer = buffer.key
  }
  if (typeof buffer === 'string') {
    buffer = new Buffer(buffer)
  }

  var stripped = fixProc(buffer, password)

  var type = stripped.tag
  var data = stripped.data
  var subtype, ndata
  switch (type) {
    case 'PUBLIC KEY':
      ndata = asn1.PublicKey.decode(data, 'der')
      subtype = ndata.algorithm.algorithm.join('.')
      switch (subtype) {
        case '1.2.840.113549.1.1.1':
          return asn1.RSAPublicKey.decode(ndata.subjectPublicKey.data, 'der')
        case '1.2.840.10045.2.1':
          ndata.subjectPrivateKey = ndata.subjectPublicKey
          return {
            type: 'ec',
            data: ndata
          }
        case '1.2.840.10040.4.1':
          ndata.algorithm.params.pub_key = asn1.DSAparam.decode(ndata.subjectPublicKey.data, 'der')
          return {
            type: 'dsa',
            data: ndata.algorithm.params
          }
        default: throw new Error('unknown key id ' + subtype)
      }
      throw new Error('unknown key type ' + type)
    case 'ENCRYPTED PRIVATE KEY':
      data = asn1.EncryptedPrivateKey.decode(data, 'der')
      data = decrypt(data, password)
      // falls through
    case 'PRIVATE KEY':
      ndata = asn1.PrivateKey.decode(data, 'der')
      subtype = ndata.algorithm.algorithm.join('.')
      switch (subtype) {
        case '1.2.840.113549.1.1.1':
          return asn1.RSAPrivateKey.decode(ndata.subjectPrivateKey, 'der')
        case '1.2.840.10045.2.1':
          return {
            curve: ndata.algorithm.curve,
            privateKey: asn1.ECPrivateKey.decode(ndata.subjectPrivateKey, 'der').privateKey
          }
        case '1.2.840.10040.4.1':
          ndata.algorithm.params.priv_key = asn1.DSAparam.decode(ndata.subjectPrivateKey, 'der')
          return {
            type: 'dsa',
            params: ndata.algorithm.params
          }
        default: throw new Error('unknown key id ' + subtype)
      }
      throw new Error('unknown key type ' + type)
    case 'RSA PUBLIC KEY':
      return asn1.RSAPublicKey.decode(data, 'der')
    case 'RSA PRIVATE KEY':
      return asn1.RSAPrivateKey.decode(data, 'der')
    case 'DSA PRIVATE KEY':
      return {
        type: 'dsa',
        params: asn1.DSAPrivateKey.decode(data, 'der')
      }
    case 'EC PRIVATE KEY':
      data = asn1.ECPrivateKey.decode(data, 'der')
      return {
        curve: data.parameters.value,
        privateKey: data.privateKey
      }
    default: throw new Error('unknown key type ' + type)
  }
}
parseKeys.signature = asn1.signature
function decrypt (data, password) {
  var salt = data.algorithm.decrypt.kde.kdeparams.salt
  var iters = parseInt(data.algorithm.decrypt.kde.kdeparams.iters.toString(), 10)
  var algo = aesid[data.algorithm.decrypt.cipher.algo.join('.')]
  var iv = data.algorithm.decrypt.cipher.iv
  var cipherText = data.subjectPrivateKey
  var keylen = parseInt(algo.split('-')[1], 10) / 8
  var key = compat.pbkdf2Sync(password, salt, iters, keylen)
  var cipher = ciphers.createDecipheriv(algo, key, iv)
  var out = []
  out.push(cipher.update(cipherText))
  out.push(cipher.final())
  return Buffer.concat(out)
}

}).call(this,require("buffer").Buffer)

},{"./aesid.json":214,"./asn1":215,"./fixProc":216,"browserify-aes":235,"buffer":151,"pbkdf2":300}],218:[function(require,module,exports){
var asn1 = exports;

asn1.bignum = require('bn.js');

asn1.define = require('./asn1/api').define;
asn1.base = require('./asn1/base');
asn1.constants = require('./asn1/constants');
asn1.decoders = require('./asn1/decoders');
asn1.encoders = require('./asn1/encoders');

},{"./asn1/api":219,"./asn1/base":221,"./asn1/constants":225,"./asn1/decoders":227,"./asn1/encoders":230,"bn.js":188}],219:[function(require,module,exports){
var asn1 = require('../asn1');
var inherits = require('inherits');

var api = exports;

api.define = function define(name, body) {
  return new Entity(name, body);
};

function Entity(name, body) {
  this.name = name;
  this.body = body;

  this.decoders = {};
  this.encoders = {};
};

Entity.prototype._createNamed = function createNamed(base) {
  var named;
  try {
    named = require('vm').runInThisContext(
      '(function ' + this.name + '(entity) {\n' +
      '  this._initNamed(entity);\n' +
      '})'
    );
  } catch (e) {
    named = function (entity) {
      this._initNamed(entity);
    };
  }
  inherits(named, base);
  named.prototype._initNamed = function initnamed(entity) {
    base.call(this, entity);
  };

  return new named(this);
};

Entity.prototype._getDecoder = function _getDecoder(enc) {
  // Lazily create decoder
  if (!this.decoders.hasOwnProperty(enc))
    this.decoders[enc] = this._createNamed(asn1.decoders[enc]);
  return this.decoders[enc];
};

Entity.prototype.decode = function decode(data, enc, options) {
  return this._getDecoder(enc).decode(data, options);
};

Entity.prototype._getEncoder = function _getEncoder(enc) {
  // Lazily create encoder
  if (!this.encoders.hasOwnProperty(enc))
    this.encoders[enc] = this._createNamed(asn1.encoders[enc]);
  return this.encoders[enc];
};

Entity.prototype.encode = function encode(data, enc, /* internal */ reporter) {
  return this._getEncoder(enc).encode(data, reporter);
};

},{"../asn1":218,"inherits":348,"vm":367}],220:[function(require,module,exports){
var inherits = require('inherits');
var Reporter = require('../base').Reporter;
var Buffer = require('buffer').Buffer;

function DecoderBuffer(base, options) {
  Reporter.call(this, options);
  if (!Buffer.isBuffer(base)) {
    this.error('Input not Buffer');
    return;
  }

  this.base = base;
  this.offset = 0;
  this.length = base.length;
}
inherits(DecoderBuffer, Reporter);
exports.DecoderBuffer = DecoderBuffer;

DecoderBuffer.prototype.save = function save() {
  return { offset: this.offset, reporter: Reporter.prototype.save.call(this) };
};

DecoderBuffer.prototype.restore = function restore(save) {
  // Return skipped data
  var res = new DecoderBuffer(this.base);
  res.offset = save.offset;
  res.length = this.offset;

  this.offset = save.offset;
  Reporter.prototype.restore.call(this, save.reporter);

  return res;
};

DecoderBuffer.prototype.isEmpty = function isEmpty() {
  return this.offset === this.length;
};

DecoderBuffer.prototype.readUInt8 = function readUInt8(fail) {
  if (this.offset + 1 <= this.length)
    return this.base.readUInt8(this.offset++, true);
  else
    return this.error(fail || 'DecoderBuffer overrun');
}

DecoderBuffer.prototype.skip = function skip(bytes, fail) {
  if (!(this.offset + bytes <= this.length))
    return this.error(fail || 'DecoderBuffer overrun');

  var res = new DecoderBuffer(this.base);

  // Share reporter state
  res._reporterState = this._reporterState;

  res.offset = this.offset;
  res.length = this.offset + bytes;
  this.offset += bytes;
  return res;
}

DecoderBuffer.prototype.raw = function raw(save) {
  return this.base.slice(save ? save.offset : this.offset, this.length);
}

function EncoderBuffer(value, reporter) {
  if (Array.isArray(value)) {
    this.length = 0;
    this.value = value.map(function(item) {
      if (!(item instanceof EncoderBuffer))
        item = new EncoderBuffer(item, reporter);
      this.length += item.length;
      return item;
    }, this);
  } else if (typeof value === 'number') {
    if (!(0 <= value && value <= 0xff))
      return reporter.error('non-byte EncoderBuffer value');
    this.value = value;
    this.length = 1;
  } else if (typeof value === 'string') {
    this.value = value;
    this.length = Buffer.byteLength(value);
  } else if (Buffer.isBuffer(value)) {
    this.value = value;
    this.length = value.length;
  } else {
    return reporter.error('Unsupported type: ' + typeof value);
  }
}
exports.EncoderBuffer = EncoderBuffer;

EncoderBuffer.prototype.join = function join(out, offset) {
  if (!out)
    out = new Buffer(this.length);
  if (!offset)
    offset = 0;

  if (this.length === 0)
    return out;

  if (Array.isArray(this.value)) {
    this.value.forEach(function(item) {
      item.join(out, offset);
      offset += item.length;
    });
  } else {
    if (typeof this.value === 'number')
      out[offset] = this.value;
    else if (typeof this.value === 'string')
      out.write(this.value, offset);
    else if (Buffer.isBuffer(this.value))
      this.value.copy(out, offset);
    offset += this.length;
  }

  return out;
};

},{"../base":221,"buffer":151,"inherits":348}],221:[function(require,module,exports){
var base = exports;

base.Reporter = require('./reporter').Reporter;
base.DecoderBuffer = require('./buffer').DecoderBuffer;
base.EncoderBuffer = require('./buffer').EncoderBuffer;
base.Node = require('./node');

},{"./buffer":220,"./node":222,"./reporter":223}],222:[function(require,module,exports){
var Reporter = require('../base').Reporter;
var EncoderBuffer = require('../base').EncoderBuffer;
var assert = require('minimalistic-assert');

// Supported tags
var tags = [
  'seq', 'seqof', 'set', 'setof', 'octstr', 'bitstr', 'objid', 'bool',
  'gentime', 'utctime', 'null_', 'enum', 'int', 'ia5str', 'utf8str', 'bmpstr',
  'numstr', 'printstr'
];

// Public methods list
var methods = [
  'key', 'obj', 'use', 'optional', 'explicit', 'implicit', 'def', 'choice',
  'any'
].concat(tags);

// Overrided methods list
var overrided = [
  '_peekTag', '_decodeTag', '_use',
  '_decodeStr', '_decodeObjid', '_decodeTime',
  '_decodeNull', '_decodeInt', '_decodeBool', '_decodeList',

  '_encodeComposite', '_encodeStr', '_encodeObjid', '_encodeTime',
  '_encodeNull', '_encodeInt', '_encodeBool'
];

function Node(enc, parent) {
  var state = {};
  this._baseState = state;

  state.enc = enc;

  state.parent = parent || null;
  state.children = null;

  // State
  state.tag = null;
  state.args = null;
  state.reverseArgs = null;
  state.choice = null;
  state.optional = false;
  state.any = false;
  state.obj = false;
  state.use = null;
  state.useDecoder = null;
  state.key = null;
  state['default'] = null;
  state.explicit = null;
  state.implicit = null;

  // Should create new instance on each method
  if (!state.parent) {
    state.children = [];
    this._wrap();
  }
}
module.exports = Node;

var stateProps = [
  'enc', 'parent', 'children', 'tag', 'args', 'reverseArgs', 'choice',
  'optional', 'any', 'obj', 'use', 'alteredUse', 'key', 'default', 'explicit',
  'implicit'
];

Node.prototype.clone = function clone() {
  var state = this._baseState;
  var cstate = {};
  stateProps.forEach(function(prop) {
    cstate[prop] = state[prop];
  });
  var res = new this.constructor(cstate.parent);
  res._baseState = cstate;
  return res;
};

Node.prototype._wrap = function wrap() {
  var state = this._baseState;
  methods.forEach(function(method) {
    this[method] = function _wrappedMethod() {
      var clone = new this.constructor(this);
      state.children.push(clone);
      return clone[method].apply(clone, arguments);
    };
  }, this);
};

Node.prototype._init = function init(body) {
  var state = this._baseState;

  assert(state.parent === null);
  body.call(this);

  // Filter children
  state.children = state.children.filter(function(child) {
    return child._baseState.parent === this;
  }, this);
  assert.equal(state.children.length, 1, 'Root node can have only one child');
};

Node.prototype._useArgs = function useArgs(args) {
  var state = this._baseState;

  // Filter children and args
  var children = args.filter(function(arg) {
    return arg instanceof this.constructor;
  }, this);
  args = args.filter(function(arg) {
    return !(arg instanceof this.constructor);
  }, this);

  if (children.length !== 0) {
    assert(state.children === null);
    state.children = children;

    // Replace parent to maintain backward link
    children.forEach(function(child) {
      child._baseState.parent = this;
    }, this);
  }
  if (args.length !== 0) {
    assert(state.args === null);
    state.args = args;
    state.reverseArgs = args.map(function(arg) {
      if (typeof arg !== 'object' || arg.constructor !== Object)
        return arg;

      var res = {};
      Object.keys(arg).forEach(function(key) {
        if (key == (key | 0))
          key |= 0;
        var value = arg[key];
        res[value] = key;
      });
      return res;
    });
  }
};

//
// Overrided methods
//

overrided.forEach(function(method) {
  Node.prototype[method] = function _overrided() {
    var state = this._baseState;
    throw new Error(method + ' not implemented for encoding: ' + state.enc);
  };
});

//
// Public methods
//

tags.forEach(function(tag) {
  Node.prototype[tag] = function _tagMethod() {
    var state = this._baseState;
    var args = Array.prototype.slice.call(arguments);

    assert(state.tag === null);
    state.tag = tag;

    this._useArgs(args);

    return this;
  };
});

Node.prototype.use = function use(item) {
  var state = this._baseState;

  assert(state.use === null);
  state.use = item;

  return this;
};

Node.prototype.optional = function optional() {
  var state = this._baseState;

  state.optional = true;

  return this;
};

Node.prototype.def = function def(val) {
  var state = this._baseState;

  assert(state['default'] === null);
  state['default'] = val;
  state.optional = true;

  return this;
};

Node.prototype.explicit = function explicit(num) {
  var state = this._baseState;

  assert(state.explicit === null && state.implicit === null);
  state.explicit = num;

  return this;
};

Node.prototype.implicit = function implicit(num) {
  var state = this._baseState;

  assert(state.explicit === null && state.implicit === null);
  state.implicit = num;

  return this;
};

Node.prototype.obj = function obj() {
  var state = this._baseState;
  var args = Array.prototype.slice.call(arguments);

  state.obj = true;

  if (args.length !== 0)
    this._useArgs(args);

  return this;
};

Node.prototype.key = function key(newKey) {
  var state = this._baseState;

  assert(state.key === null);
  state.key = newKey;

  return this;
};

Node.prototype.any = function any() {
  var state = this._baseState;

  state.any = true;

  return this;
};

Node.prototype.choice = function choice(obj) {
  var state = this._baseState;

  assert(state.choice === null);
  state.choice = obj;
  this._useArgs(Object.keys(obj).map(function(key) {
    return obj[key];
  }));

  return this;
};

//
// Decoding
//

Node.prototype._decode = function decode(input) {
  var state = this._baseState;

  // Decode root node
  if (state.parent === null)
    return input.wrapResult(state.children[0]._decode(input));

  var result = state['default'];
  var present = true;

  var prevKey;
  if (state.key !== null)
    prevKey = input.enterKey(state.key);

  // Check if tag is there
  if (state.optional) {
    var tag = null;
    if (state.explicit !== null)
      tag = state.explicit;
    else if (state.implicit !== null)
      tag = state.implicit;
    else if (state.tag !== null)
      tag = state.tag;

    if (tag === null && !state.any) {
      // Trial and Error
      var save = input.save();
      try {
        if (state.choice === null)
          this._decodeGeneric(state.tag, input);
        else
          this._decodeChoice(input);
        present = true;
      } catch (e) {
        present = false;
      }
      input.restore(save);
    } else {
      present = this._peekTag(input, tag, state.any);

      if (input.isError(present))
        return present;
    }
  }

  // Push object on stack
  var prevObj;
  if (state.obj && present)
    prevObj = input.enterObject();

  if (present) {
    // Unwrap explicit values
    if (state.explicit !== null) {
      var explicit = this._decodeTag(input, state.explicit);
      if (input.isError(explicit))
        return explicit;
      input = explicit;
    }

    // Unwrap implicit and normal values
    if (state.use === null && state.choice === null) {
      if (state.any)
        var save = input.save();
      var body = this._decodeTag(
        input,
        state.implicit !== null ? state.implicit : state.tag,
        state.any
      );
      if (input.isError(body))
        return body;

      if (state.any)
        result = input.raw(save);
      else
        input = body;
    }

    // Select proper method for tag
    if (state.any)
      result = result;
    else if (state.choice === null)
      result = this._decodeGeneric(state.tag, input);
    else
      result = this._decodeChoice(input);

    if (input.isError(result))
      return result;

    // Decode children
    if (!state.any && state.choice === null && state.children !== null) {
      var fail = state.children.some(function decodeChildren(child) {
        // NOTE: We are ignoring errors here, to let parser continue with other
        // parts of encoded data
        child._decode(input);
      });
      if (fail)
        return err;
    }
  }

  // Pop object
  if (state.obj && present)
    result = input.leaveObject(prevObj);

  // Set key
  if (state.key !== null && (result !== null || present === true))
    input.leaveKey(prevKey, state.key, result);

  return result;
};

Node.prototype._decodeGeneric = function decodeGeneric(tag, input) {
  var state = this._baseState;

  if (tag === 'seq' || tag === 'set')
    return null;
  if (tag === 'seqof' || tag === 'setof')
    return this._decodeList(input, tag, state.args[0]);
  else if (tag === 'octstr' || tag === 'bitstr')
    return this._decodeStr(input, tag);
  else if (tag === 'ia5str' || tag === 'utf8str' || tag === 'bmpstr')
    return this._decodeStr(input, tag);
  else if (tag === 'numstr' || tag === 'printstr')
    return this._decodeStr(input, tag);
  else if (tag === 'objid' && state.args)
    return this._decodeObjid(input, state.args[0], state.args[1]);
  else if (tag === 'objid')
    return this._decodeObjid(input, null, null);
  else if (tag === 'gentime' || tag === 'utctime')
    return this._decodeTime(input, tag);
  else if (tag === 'null_')
    return this._decodeNull(input);
  else if (tag === 'bool')
    return this._decodeBool(input);
  else if (tag === 'int' || tag === 'enum')
    return this._decodeInt(input, state.args && state.args[0]);
  else if (state.use !== null)
    return this._getUse(state.use, input._reporterState.obj)._decode(input);
  else
    return input.error('unknown tag: ' + tag);

  return null;
};

Node.prototype._getUse = function _getUse(entity, obj) {

  var state = this._baseState;
  // Create altered use decoder if implicit is set
  state.useDecoder = this._use(entity, obj);
  assert(state.useDecoder._baseState.parent === null);
  state.useDecoder = state.useDecoder._baseState.children[0];
  if (state.implicit !== state.useDecoder._baseState.implicit) {
    state.useDecoder = state.useDecoder.clone();
    state.useDecoder._baseState.implicit = state.implicit;
  }
  return state.useDecoder;
};

Node.prototype._decodeChoice = function decodeChoice(input) {
  var state = this._baseState;
  var result = null;
  var match = false;

  Object.keys(state.choice).some(function(key) {
    var save = input.save();
    var node = state.choice[key];
    try {
      var value = node._decode(input);
      if (input.isError(value))
        return false;

      result = { type: key, value: value };
      match = true;
    } catch (e) {
      input.restore(save);
      return false;
    }
    return true;
  }, this);

  if (!match)
    return input.error('Choice not matched');

  return result;
};

//
// Encoding
//

Node.prototype._createEncoderBuffer = function createEncoderBuffer(data) {
  return new EncoderBuffer(data, this.reporter);
};

Node.prototype._encode = function encode(data, reporter, parent) {
  var state = this._baseState;
  if (state['default'] !== null && state['default'] === data)
    return;

  var result = this._encodeValue(data, reporter, parent);
  if (result === undefined)
    return;

  if (this._skipDefault(result, reporter, parent))
    return;

  return result;
};

Node.prototype._encodeValue = function encode(data, reporter, parent) {
  var state = this._baseState;

  // Decode root node
  if (state.parent === null)
    return state.children[0]._encode(data, reporter || new Reporter());

  var result = null;
  var present = true;

  // Set reporter to share it with a child class
  this.reporter = reporter;

  // Check if data is there
  if (state.optional && data === undefined) {
    if (state['default'] !== null)
      data = state['default']
    else
      return;
  }

  // For error reporting
  var prevKey;

  // Encode children first
  var content = null;
  var primitive = false;
  if (state.any) {
    // Anything that was given is translated to buffer
    result = this._createEncoderBuffer(data);
  } else if (state.choice) {
    result = this._encodeChoice(data, reporter);
  } else if (state.children) {
    content = state.children.map(function(child) {
      if (child._baseState.tag === 'null_')
        return child._encode(null, reporter, data);

      if (child._baseState.key === null)
        return reporter.error('Child should have a key');
      var prevKey = reporter.enterKey(child._baseState.key);

      if (typeof data !== 'object')
        return reporter.error('Child expected, but input is not object');

      var res = child._encode(data[child._baseState.key], reporter, data);
      reporter.leaveKey(prevKey);

      return res;
    }, this).filter(function(child) {
      return child;
    });

    content = this._createEncoderBuffer(content);
  } else {
    if (state.tag === 'seqof' || state.tag === 'setof') {
      // TODO(indutny): this should be thrown on DSL level
      if (!(state.args && state.args.length === 1))
        return reporter.error('Too many args for : ' + state.tag);

      if (!Array.isArray(data))
        return reporter.error('seqof/setof, but data is not Array');

      var child = this.clone();
      child._baseState.implicit = null;
      content = this._createEncoderBuffer(data.map(function(item) {
        var state = this._baseState;

        return this._getUse(state.args[0], data)._encode(item, reporter);
      }, child));
    } else if (state.use !== null) {
      result = this._getUse(state.use, parent)._encode(data, reporter);
    } else {
      content = this._encodePrimitive(state.tag, data);
      primitive = true;
    }
  }

  // Encode data itself
  var result;
  if (!state.any && state.choice === null) {
    var tag = state.implicit !== null ? state.implicit : state.tag;
    var cls = state.implicit === null ? 'universal' : 'context';

    if (tag === null) {
      if (state.use === null)
        reporter.error('Tag could be ommited only for .use()');
    } else {
      if (state.use === null)
        result = this._encodeComposite(tag, primitive, cls, content);
    }
  }

  // Wrap in explicit
  if (state.explicit !== null)
    result = this._encodeComposite(state.explicit, false, 'context', result);

  return result;
};

Node.prototype._encodeChoice = function encodeChoice(data, reporter) {
  var state = this._baseState;

  var node = state.choice[data.type];
  if (!node) {
    assert(
        false,
        data.type + ' not found in ' +
            JSON.stringify(Object.keys(state.choice)));
  }
  return node._encode(data.value, reporter);
};

Node.prototype._encodePrimitive = function encodePrimitive(tag, data) {
  var state = this._baseState;

  if (tag === 'octstr' || tag === 'bitstr' || tag === 'ia5str')
    return this._encodeStr(data, tag);
  else if (tag === 'utf8str' || tag === 'bmpstr')
    return this._encodeStr(data, tag);
  else if (tag === 'numstr' || tag === 'printstr')
    return this._encodeStr(data, tag);
  else if (tag === 'objid' && state.args)
    return this._encodeObjid(data, state.reverseArgs[0], state.args[1]);
  else if (tag === 'objid')
    return this._encodeObjid(data, null, null);
  else if (tag === 'gentime' || tag === 'utctime')
    return this._encodeTime(data, tag);
  else if (tag === 'null_')
    return this._encodeNull();
  else if (tag === 'int' || tag === 'enum')
    return this._encodeInt(data, state.args && state.reverseArgs[0]);
  else if (tag === 'bool')
    return this._encodeBool(data);
  else
    throw new Error('Unsupported tag: ' + tag);
};

Node.prototype._isNumstr = function isNumstr(str) {
  return /^[0-9 ]*$/.test(str);
};

Node.prototype._isPrintstr = function isPrintstr(str) {
  return /^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(str);
};
},{"../base":221,"minimalistic-assert":232}],223:[function(require,module,exports){
var inherits = require('inherits');

function Reporter(options) {
  this._reporterState = {
    obj: null,
    path: [],
    options: options || {},
    errors: []
  };
}
exports.Reporter = Reporter;

Reporter.prototype.isError = function isError(obj) {
  return obj instanceof ReporterError;
};

Reporter.prototype.save = function save() {
  var state = this._reporterState;

  return { obj: state.obj, pathLen: state.path.length };
};

Reporter.prototype.restore = function restore(data) {
  var state = this._reporterState;

  state.obj = data.obj;
  state.path = state.path.slice(0, data.pathLen);
};

Reporter.prototype.enterKey = function enterKey(key) {
  return this._reporterState.path.push(key);
};

Reporter.prototype.leaveKey = function leaveKey(index, key, value) {
  var state = this._reporterState;

  state.path = state.path.slice(0, index - 1);
  if (state.obj !== null)
    state.obj[key] = value;
};

Reporter.prototype.enterObject = function enterObject() {
  var state = this._reporterState;

  var prev = state.obj;
  state.obj = {};
  return prev;
};

Reporter.prototype.leaveObject = function leaveObject(prev) {
  var state = this._reporterState;

  var now = state.obj;
  state.obj = prev;
  return now;
};

Reporter.prototype.error = function error(msg) {
  var err;
  var state = this._reporterState;

  var inherited = msg instanceof ReporterError;
  if (inherited) {
    err = msg;
  } else {
    err = new ReporterError(state.path.map(function(elem) {
      return '[' + JSON.stringify(elem) + ']';
    }).join(''), msg.message || msg, msg.stack);
  }

  if (!state.options.partial)
    throw err;

  if (!inherited)
    state.errors.push(err);

  return err;
};

Reporter.prototype.wrapResult = function wrapResult(result) {
  var state = this._reporterState;
  if (!state.options.partial)
    return result;

  return {
    result: this.isError(result) ? null : result,
    errors: state.errors
  };
};

function ReporterError(path, msg) {
  this.path = path;
  this.rethrow(msg);
};
inherits(ReporterError, Error);

ReporterError.prototype.rethrow = function rethrow(msg) {
  this.message = msg + ' at: ' + (this.path || '(shallow)');
  Error.captureStackTrace(this, ReporterError);

  return this;
};

},{"inherits":348}],224:[function(require,module,exports){
var constants = require('../constants');

exports.tagClass = {
  0: 'universal',
  1: 'application',
  2: 'context',
  3: 'private'
};
exports.tagClassByName = constants._reverse(exports.tagClass);

exports.tag = {
  0x00: 'end',
  0x01: 'bool',
  0x02: 'int',
  0x03: 'bitstr',
  0x04: 'octstr',
  0x05: 'null_',
  0x06: 'objid',
  0x07: 'objDesc',
  0x08: 'external',
  0x09: 'real',
  0x0a: 'enum',
  0x0b: 'embed',
  0x0c: 'utf8str',
  0x0d: 'relativeOid',
  0x10: 'seq',
  0x11: 'set',
  0x12: 'numstr',
  0x13: 'printstr',
  0x14: 't61str',
  0x15: 'videostr',
  0x16: 'ia5str',
  0x17: 'utctime',
  0x18: 'gentime',
  0x19: 'graphstr',
  0x1a: 'iso646str',
  0x1b: 'genstr',
  0x1c: 'unistr',
  0x1d: 'charstr',
  0x1e: 'bmpstr'
};
exports.tagByName = constants._reverse(exports.tag);

},{"../constants":225}],225:[function(require,module,exports){
var constants = exports;

// Helper
constants._reverse = function reverse(map) {
  var res = {};

  Object.keys(map).forEach(function(key) {
    // Convert key to integer if it is stringified
    if ((key | 0) == key)
      key = key | 0;

    var value = map[key];
    res[value] = key;
  });

  return res;
};

constants.der = require('./der');

},{"./der":224}],226:[function(require,module,exports){
var inherits = require('inherits');

var asn1 = require('../../asn1');
var base = asn1.base;
var bignum = asn1.bignum;

// Import DER constants
var der = asn1.constants.der;

function DERDecoder(entity) {
  this.enc = 'der';
  this.name = entity.name;
  this.entity = entity;

  // Construct base tree
  this.tree = new DERNode();
  this.tree._init(entity.body);
};
module.exports = DERDecoder;

DERDecoder.prototype.decode = function decode(data, options) {
  if (!(data instanceof base.DecoderBuffer))
    data = new base.DecoderBuffer(data, options);

  return this.tree._decode(data, options);
};

// Tree methods

function DERNode(parent) {
  base.Node.call(this, 'der', parent);
}
inherits(DERNode, base.Node);

DERNode.prototype._peekTag = function peekTag(buffer, tag, any) {
  if (buffer.isEmpty())
    return false;

  var state = buffer.save();
  var decodedTag = derDecodeTag(buffer, 'Failed to peek tag: "' + tag + '"');
  if (buffer.isError(decodedTag))
    return decodedTag;

  buffer.restore(state);

  return decodedTag.tag === tag || decodedTag.tagStr === tag || any;
};

DERNode.prototype._decodeTag = function decodeTag(buffer, tag, any) {
  var decodedTag = derDecodeTag(buffer,
                                'Failed to decode tag of "' + tag + '"');
  if (buffer.isError(decodedTag))
    return decodedTag;

  var len = derDecodeLen(buffer,
                         decodedTag.primitive,
                         'Failed to get length of "' + tag + '"');

  // Failure
  if (buffer.isError(len))
    return len;

  if (!any &&
      decodedTag.tag !== tag &&
      decodedTag.tagStr !== tag &&
      decodedTag.tagStr + 'of' !== tag) {
    return buffer.error('Failed to match tag: "' + tag + '"');
  }

  if (decodedTag.primitive || len !== null)
    return buffer.skip(len, 'Failed to match body of: "' + tag + '"');

  // Indefinite length... find END tag
  var state = buffer.save();
  var res = this._skipUntilEnd(
      buffer,
      'Failed to skip indefinite length body: "' + this.tag + '"');
  if (buffer.isError(res))
    return res;

  len = buffer.offset - state.offset;
  buffer.restore(state);
  return buffer.skip(len, 'Failed to match body of: "' + tag + '"');
};

DERNode.prototype._skipUntilEnd = function skipUntilEnd(buffer, fail) {
  while (true) {
    var tag = derDecodeTag(buffer, fail);
    if (buffer.isError(tag))
      return tag;
    var len = derDecodeLen(buffer, tag.primitive, fail);
    if (buffer.isError(len))
      return len;

    var res;
    if (tag.primitive || len !== null)
      res = buffer.skip(len)
    else
      res = this._skipUntilEnd(buffer, fail);

    // Failure
    if (buffer.isError(res))
      return res;

    if (tag.tagStr === 'end')
      break;
  }
};

DERNode.prototype._decodeList = function decodeList(buffer, tag, decoder) {
  var result = [];
  while (!buffer.isEmpty()) {
    var possibleEnd = this._peekTag(buffer, 'end');
    if (buffer.isError(possibleEnd))
      return possibleEnd;

    var res = decoder.decode(buffer, 'der');
    if (buffer.isError(res) && possibleEnd)
      break;
    result.push(res);
  }
  return result;
};

DERNode.prototype._decodeStr = function decodeStr(buffer, tag) {
  if (tag === 'octstr') {
    return buffer.raw();
  } else if (tag === 'bitstr') {
    var unused = buffer.readUInt8();
    if (buffer.isError(unused))
      return unused;

    return { unused: unused, data: buffer.raw() };
  } else if (tag === 'ia5str' || tag === 'utf8str') {
    return buffer.raw().toString();
  } else if(tag === 'numstr') {
    var numstr = buffer.raw().toString('ascii');
    if (!this._isNumstr(numstr)) {
      return buffer.error('Decoding of string type: ' +
                          'numstr unsupported characters');
    }

    return numstr;
  } else if (tag === 'printstr') {
    var printstr = buffer.raw().toString('ascii');
    if (!this._isPrintstr(printstr)) {
      return buffer.error('Decoding of string type: ' +
                          'printstr unsupported characters');
    }

    return printstr;
  } else if(tag === 'bmpstr') {
    var raw = buffer.raw();
    if (raw.length % 2 === 1)
      return buffer.error('Decoding of string type: bmpstr length mismatch');

    var str = '';
    for (var i = 0; i < raw.length / 2; i++) {
      str += String.fromCharCode(raw.readUInt16BE(i * 2));
    }
    return str;
  } else {
    return buffer.error('Decoding of string type: ' + tag + ' unsupported');
  }
};

DERNode.prototype._decodeObjid = function decodeObjid(buffer, values, relative) {
  var identifiers = [];
  var ident = 0;
  while (!buffer.isEmpty()) {
    var subident = buffer.readUInt8();
    ident <<= 7;
    ident |= subident & 0x7f;
    if ((subident & 0x80) === 0) {
      identifiers.push(ident);
      ident = 0;
    }
  }
  if (subident & 0x80)
    identifiers.push(ident);

  var first = (identifiers[0] / 40) | 0;
  var second = identifiers[0] % 40;

  if (relative)
    result = identifiers;
  else
    result = [first, second].concat(identifiers.slice(1));

  if (values)
    result = values[result.join(' ')];

  return result;
};

DERNode.prototype._decodeTime = function decodeTime(buffer, tag) {
  var str = buffer.raw().toString();
  if (tag === 'gentime') {
    var year = str.slice(0, 4) | 0;
    var mon = str.slice(4, 6) | 0;
    var day = str.slice(6, 8) | 0;
    var hour = str.slice(8, 10) | 0;
    var min = str.slice(10, 12) | 0;
    var sec = str.slice(12, 14) | 0;
  } else if (tag === 'utctime') {
    var year = str.slice(0, 2) | 0;
    var mon = str.slice(2, 4) | 0;
    var day = str.slice(4, 6) | 0;
    var hour = str.slice(6, 8) | 0;
    var min = str.slice(8, 10) | 0;
    var sec = str.slice(10, 12) | 0;
    if (year < 70)
      year = 2000 + year;
    else
      year = 1900 + year;
  } else {
    return buffer.error('Decoding ' + tag + ' time is not supported yet');
  }

  return Date.UTC(year, mon - 1, day, hour, min, sec, 0);
};

DERNode.prototype._decodeNull = function decodeNull(buffer) {
  return null;
};

DERNode.prototype._decodeBool = function decodeBool(buffer) {
  var res = buffer.readUInt8();
  if (buffer.isError(res))
    return res;
  else
    return res !== 0;
};

DERNode.prototype._decodeInt = function decodeInt(buffer, values) {
  // Bigint, return as it is (assume big endian)
  var raw = buffer.raw();
  var res = new bignum(raw);

  if (values)
    res = values[res.toString(10)] || res;

  return res;
};

DERNode.prototype._use = function use(entity, obj) {
  if (typeof entity === 'function')
    entity = entity(obj);
  return entity._getDecoder('der').tree;
};

// Utility methods

function derDecodeTag(buf, fail) {
  var tag = buf.readUInt8(fail);
  if (buf.isError(tag))
    return tag;

  var cls = der.tagClass[tag >> 6];
  var primitive = (tag & 0x20) === 0;

  // Multi-octet tag - load
  if ((tag & 0x1f) === 0x1f) {
    var oct = tag;
    tag = 0;
    while ((oct & 0x80) === 0x80) {
      oct = buf.readUInt8(fail);
      if (buf.isError(oct))
        return oct;

      tag <<= 7;
      tag |= oct & 0x7f;
    }
  } else {
    tag &= 0x1f;
  }
  var tagStr = der.tag[tag];

  return {
    cls: cls,
    primitive: primitive,
    tag: tag,
    tagStr: tagStr
  };
}

function derDecodeLen(buf, primitive, fail) {
  var len = buf.readUInt8(fail);
  if (buf.isError(len))
    return len;

  // Indefinite form
  if (!primitive && len === 0x80)
    return null;

  // Definite form
  if ((len & 0x80) === 0) {
    // Short form
    return len;
  }

  // Long form
  var num = len & 0x7f;
  if (num >= 4)
    return buf.error('length octect is too long');

  len = 0;
  for (var i = 0; i < num; i++) {
    len <<= 8;
    var j = buf.readUInt8(fail);
    if (buf.isError(j))
      return j;
    len |= j;
  }

  return len;
}

},{"../../asn1":218,"inherits":348}],227:[function(require,module,exports){
var decoders = exports;

decoders.der = require('./der');
decoders.pem = require('./pem');

},{"./der":226,"./pem":228}],228:[function(require,module,exports){
var inherits = require('inherits');
var Buffer = require('buffer').Buffer;

var asn1 = require('../../asn1');
var DERDecoder = require('./der');

function PEMDecoder(entity) {
  DERDecoder.call(this, entity);
  this.enc = 'pem';
};
inherits(PEMDecoder, DERDecoder);
module.exports = PEMDecoder;

PEMDecoder.prototype.decode = function decode(data, options) {
  var lines = data.toString().split(/[\r\n]+/g);

  var label = options.label.toUpperCase();

  var re = /^-----(BEGIN|END) ([^-]+)-----$/;
  var start = -1;
  var end = -1;
  for (var i = 0; i < lines.length; i++) {
    var match = lines[i].match(re);
    if (match === null)
      continue;

    if (match[2] !== label)
      continue;

    if (start === -1) {
      if (match[1] !== 'BEGIN')
        break;
      start = i;
    } else {
      if (match[1] !== 'END')
        break;
      end = i;
      break;
    }
  }
  if (start === -1 || end === -1)
    throw new Error('PEM section not found for: ' + label);

  var base64 = lines.slice(start + 1, end).join('');
  // Remove excessive symbols
  base64.replace(/[^a-z0-9\+\/=]+/gi, '');

  var input = new Buffer(base64, 'base64');
  return DERDecoder.prototype.decode.call(this, input, options);
};

},{"../../asn1":218,"./der":226,"buffer":151,"inherits":348}],229:[function(require,module,exports){
var inherits = require('inherits');
var Buffer = require('buffer').Buffer;

var asn1 = require('../../asn1');
var base = asn1.base;
var bignum = asn1.bignum;

// Import DER constants
var der = asn1.constants.der;

function DEREncoder(entity) {
  this.enc = 'der';
  this.name = entity.name;
  this.entity = entity;

  // Construct base tree
  this.tree = new DERNode();
  this.tree._init(entity.body);
};
module.exports = DEREncoder;

DEREncoder.prototype.encode = function encode(data, reporter) {
  return this.tree._encode(data, reporter).join();
};

// Tree methods

function DERNode(parent) {
  base.Node.call(this, 'der', parent);
}
inherits(DERNode, base.Node);

DERNode.prototype._encodeComposite = function encodeComposite(tag,
                                                              primitive,
                                                              cls,
                                                              content) {
  var encodedTag = encodeTag(tag, primitive, cls, this.reporter);

  // Short form
  if (content.length < 0x80) {
    var header = new Buffer(2);
    header[0] = encodedTag;
    header[1] = content.length;
    return this._createEncoderBuffer([ header, content ]);
  }

  // Long form
  // Count octets required to store length
  var lenOctets = 1;
  for (var i = content.length; i >= 0x100; i >>= 8)
    lenOctets++;

  var header = new Buffer(1 + 1 + lenOctets);
  header[0] = encodedTag;
  header[1] = 0x80 | lenOctets;

  for (var i = 1 + lenOctets, j = content.length; j > 0; i--, j >>= 8)
    header[i] = j & 0xff;

  return this._createEncoderBuffer([ header, content ]);
};

DERNode.prototype._encodeStr = function encodeStr(str, tag) {
  if (tag === 'octstr') {
    return this._createEncoderBuffer(str);
  } else if (tag === 'bitstr') {
    return this._createEncoderBuffer([ str.unused | 0, str.data ]);
  } else if (tag === 'ia5str' || tag === 'utf8str') {
    return this._createEncoderBuffer(str);
  } else if (tag === 'bmpstr') {
    var buf = new Buffer(str.length * 2);
    for (var i = 0; i < str.length; i++) {
      buf.writeUInt16BE(str.charCodeAt(i), i * 2);
    }
    return this._createEncoderBuffer(buf);
  } else if (tag === 'numstr') {
    if (!this._isNumstr(str)) {
      return this.reporter.error('Encoding of string type: numstr supports ' +
                                 'only digits and space');
    }

    return this._createEncoderBuffer(str);
  } else if (tag === 'printstr') {
    if (!this._isPrintstr(str)) {
      return this.reporter.error('Encoding of string type: printstr supports ' +
                                 'only latin upper and lower case letters, ' +
                                 'digits, space, apostrophe, left and rigth ' +
                                 'parenthesis, plus sign, comma, hyphen, ' +
                                 'dot, slash, colon, equal sign, ' +
                                 'question mark');
    }

    return this._createEncoderBuffer(str);
  } else {
    return this.reporter.error('Encoding of string type: ' + tag +
                               ' unsupported');
  }
};

DERNode.prototype._encodeObjid = function encodeObjid(id, values, relative) {
  if (typeof id === 'string') {
    if (!values)
      return this.reporter.error('string objid given, but no values map found');
    if (!values.hasOwnProperty(id))
      return this.reporter.error('objid not found in values map');
    id = values[id].split(/[\s\.]+/g);
    for (var i = 0; i < id.length; i++)
      id[i] |= 0;
  } else if (Array.isArray(id)) {
    id = id.slice();
    for (var i = 0; i < id.length; i++)
      id[i] |= 0;
  }

  if (!Array.isArray(id)) {
    return this.reporter.error('objid() should be either array or string, ' +
                               'got: ' + JSON.stringify(id));
  }

  if (!relative) {
    if (id[1] >= 40)
      return this.reporter.error('Second objid identifier OOB');
    id.splice(0, 2, id[0] * 40 + id[1]);
  }

  // Count number of octets
  var size = 0;
  for (var i = 0; i < id.length; i++) {
    var ident = id[i];
    for (size++; ident >= 0x80; ident >>= 7)
      size++;
  }

  var objid = new Buffer(size);
  var offset = objid.length - 1;
  for (var i = id.length - 1; i >= 0; i--) {
    var ident = id[i];
    objid[offset--] = ident & 0x7f;
    while ((ident >>= 7) > 0)
      objid[offset--] = 0x80 | (ident & 0x7f);
  }

  return this._createEncoderBuffer(objid);
};

function two(num) {
  if (num < 10)
    return '0' + num;
  else
    return num;
}

DERNode.prototype._encodeTime = function encodeTime(time, tag) {
  var str;
  var date = new Date(time);

  if (tag === 'gentime') {
    str = [
      two(date.getFullYear()),
      two(date.getUTCMonth() + 1),
      two(date.getUTCDate()),
      two(date.getUTCHours()),
      two(date.getUTCMinutes()),
      two(date.getUTCSeconds()),
      'Z'
    ].join('');
  } else if (tag === 'utctime') {
    str = [
      two(date.getFullYear() % 100),
      two(date.getUTCMonth() + 1),
      two(date.getUTCDate()),
      two(date.getUTCHours()),
      two(date.getUTCMinutes()),
      two(date.getUTCSeconds()),
      'Z'
    ].join('');
  } else {
    this.reporter.error('Encoding ' + tag + ' time is not supported yet');
  }

  return this._encodeStr(str, 'octstr');
};

DERNode.prototype._encodeNull = function encodeNull() {
  return this._createEncoderBuffer('');
};

DERNode.prototype._encodeInt = function encodeInt(num, values) {
  if (typeof num === 'string') {
    if (!values)
      return this.reporter.error('String int or enum given, but no values map');
    if (!values.hasOwnProperty(num)) {
      return this.reporter.error('Values map doesn\'t contain: ' +
                                 JSON.stringify(num));
    }
    num = values[num];
  }

  // Bignum, assume big endian
  if (typeof num !== 'number' && !Buffer.isBuffer(num)) {
    var numArray = num.toArray();
    if (!num.sign && numArray[0] & 0x80) {
      numArray.unshift(0);
    }
    num = new Buffer(numArray);
  }

  if (Buffer.isBuffer(num)) {
    var size = num.length;
    if (num.length === 0)
      size++;

    var out = new Buffer(size);
    num.copy(out);
    if (num.length === 0)
      out[0] = 0
    return this._createEncoderBuffer(out);
  }

  if (num < 0x80)
    return this._createEncoderBuffer(num);

  if (num < 0x100)
    return this._createEncoderBuffer([0, num]);

  var size = 1;
  for (var i = num; i >= 0x100; i >>= 8)
    size++;

  var out = new Array(size);
  for (var i = out.length - 1; i >= 0; i--) {
    out[i] = num & 0xff;
    num >>= 8;
  }
  if(out[0] & 0x80) {
    out.unshift(0);
  }

  return this._createEncoderBuffer(new Buffer(out));
};

DERNode.prototype._encodeBool = function encodeBool(value) {
  return this._createEncoderBuffer(value ? 0xff : 0);
};

DERNode.prototype._use = function use(entity, obj) {
  if (typeof entity === 'function')
    entity = entity(obj);
  return entity._getEncoder('der').tree;
};

DERNode.prototype._skipDefault = function skipDefault(dataBuffer, reporter, parent) {
  var state = this._baseState;
  var i;
  if (state['default'] === null)
    return false;

  var data = dataBuffer.join();
  if (state.defaultBuffer === undefined)
    state.defaultBuffer = this._encodeValue(state['default'], reporter, parent).join();

  if (data.length !== state.defaultBuffer.length)
    return false;

  for (i=0; i < data.length; i++)
    if (data[i] !== state.defaultBuffer[i])
      return false;

  return true;
};

// Utility methods

function encodeTag(tag, primitive, cls, reporter) {
  var res;

  if (tag === 'seqof')
    tag = 'seq';
  else if (tag === 'setof')
    tag = 'set';

  if (der.tagByName.hasOwnProperty(tag))
    res = der.tagByName[tag];
  else if (typeof tag === 'number' && (tag | 0) === tag)
    res = tag;
  else
    return reporter.error('Unknown tag: ' + tag);

  if (res >= 0x1f)
    return reporter.error('Multi-octet tag encoding unsupported');

  if (!primitive)
    res |= 0x20;

  res |= (der.tagClassByName[cls || 'universal'] << 6);

  return res;
}

},{"../../asn1":218,"buffer":151,"inherits":348}],230:[function(require,module,exports){
var encoders = exports;

encoders.der = require('./der');
encoders.pem = require('./pem');

},{"./der":229,"./pem":231}],231:[function(require,module,exports){
var inherits = require('inherits');
var Buffer = require('buffer').Buffer;

var asn1 = require('../../asn1');
var DEREncoder = require('./der');

function PEMEncoder(entity) {
  DEREncoder.call(this, entity);
  this.enc = 'pem';
};
inherits(PEMEncoder, DEREncoder);
module.exports = PEMEncoder;

PEMEncoder.prototype.encode = function encode(data, options) {
  var buf = DEREncoder.prototype.encode.call(this, data);

  var p = buf.toString('base64');
  var out = [ '-----BEGIN ' + options.label + '-----' ];
  for (var i = 0; i < p.length; i += 64)
    out.push(p.slice(i, i + 64));
  out.push('-----END ' + options.label + '-----');
  return out.join('\n');
};

},{"../../asn1":218,"./der":229,"buffer":151,"inherits":348}],232:[function(require,module,exports){
arguments[4][183][0].apply(exports,arguments)
},{"dup":183}],233:[function(require,module,exports){
(function (Buffer){
// based on the aes implimentation in triple sec
// https://github.com/keybase/triplesec

// which is in turn based on the one from crypto-js
// https://code.google.com/p/crypto-js/

var uint_max = Math.pow(2, 32)
function fixup_uint32 (x) {
  var ret, x_pos
  ret = x > uint_max || x < 0 ? (x_pos = Math.abs(x) % uint_max, x < 0 ? uint_max - x_pos : x_pos) : x
  return ret
}
function scrub_vec (v) {
  for (var i = 0; i < v.length; v++) {
    v[i] = 0
  }
  return false
}

function Global () {
  this.SBOX = []
  this.INV_SBOX = []
  this.SUB_MIX = [[], [], [], []]
  this.INV_SUB_MIX = [[], [], [], []]
  this.init()
  this.RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36]
}

Global.prototype.init = function () {
  var d, i, sx, t, x, x2, x4, x8, xi, _i
  d = (function () {
    var _i, _results
    _results = []
    for (i = _i = 0; _i < 256; i = ++_i) {
      if (i < 128) {
        _results.push(i << 1)
      } else {
        _results.push((i << 1) ^ 0x11b)
      }
    }
    return _results
  })()
  x = 0
  xi = 0
  for (i = _i = 0; _i < 256; i = ++_i) {
    sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4)
    sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63
    this.SBOX[x] = sx
    this.INV_SBOX[sx] = x
    x2 = d[x]
    x4 = d[x2]
    x8 = d[x4]
    t = (d[sx] * 0x101) ^ (sx * 0x1010100)
    this.SUB_MIX[0][x] = (t << 24) | (t >>> 8)
    this.SUB_MIX[1][x] = (t << 16) | (t >>> 16)
    this.SUB_MIX[2][x] = (t << 8) | (t >>> 24)
    this.SUB_MIX[3][x] = t
    t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100)
    this.INV_SUB_MIX[0][sx] = (t << 24) | (t >>> 8)
    this.INV_SUB_MIX[1][sx] = (t << 16) | (t >>> 16)
    this.INV_SUB_MIX[2][sx] = (t << 8) | (t >>> 24)
    this.INV_SUB_MIX[3][sx] = t
    if (x === 0) {
      x = xi = 1
    } else {
      x = x2 ^ d[d[d[x8 ^ x2]]]
      xi ^= d[d[xi]]
    }
  }
  return true
}

var G = new Global()

AES.blockSize = 4 * 4

AES.prototype.blockSize = AES.blockSize

AES.keySize = 256 / 8

AES.prototype.keySize = AES.keySize

function bufferToArray (buf) {
  var len = buf.length / 4
  var out = new Array(len)
  var i = -1
  while (++i < len) {
    out[i] = buf.readUInt32BE(i * 4)
  }
  return out
}
function AES (key) {
  this._key = bufferToArray(key)
  this._doReset()
}

AES.prototype._doReset = function () {
  var invKsRow, keySize, keyWords, ksRow, ksRows, t
  keyWords = this._key
  keySize = keyWords.length
  this._nRounds = keySize + 6
  ksRows = (this._nRounds + 1) * 4
  this._keySchedule = []
  for (ksRow = 0; ksRow < ksRows; ksRow++) {
    this._keySchedule[ksRow] = ksRow < keySize ? keyWords[ksRow] : (t = this._keySchedule[ksRow - 1], (ksRow % keySize) === 0 ? (t = (t << 8) | (t >>> 24), t = (G.SBOX[t >>> 24] << 24) | (G.SBOX[(t >>> 16) & 0xff] << 16) | (G.SBOX[(t >>> 8) & 0xff] << 8) | G.SBOX[t & 0xff], t ^= G.RCON[(ksRow / keySize) | 0] << 24) : keySize > 6 && ksRow % keySize === 4 ? t = (G.SBOX[t >>> 24] << 24) | (G.SBOX[(t >>> 16) & 0xff] << 16) | (G.SBOX[(t >>> 8) & 0xff] << 8) | G.SBOX[t & 0xff] : void 0, this._keySchedule[ksRow - keySize] ^ t)
  }
  this._invKeySchedule = []
  for (invKsRow = 0; invKsRow < ksRows; invKsRow++) {
    ksRow = ksRows - invKsRow
    t = this._keySchedule[ksRow - (invKsRow % 4 ? 0 : 4)]
    this._invKeySchedule[invKsRow] = invKsRow < 4 || ksRow <= 4 ? t : G.INV_SUB_MIX[0][G.SBOX[t >>> 24]] ^ G.INV_SUB_MIX[1][G.SBOX[(t >>> 16) & 0xff]] ^ G.INV_SUB_MIX[2][G.SBOX[(t >>> 8) & 0xff]] ^ G.INV_SUB_MIX[3][G.SBOX[t & 0xff]]
  }
  return true
}

AES.prototype.encryptBlock = function (M) {
  M = bufferToArray(new Buffer(M))
  var out = this._doCryptBlock(M, this._keySchedule, G.SUB_MIX, G.SBOX)
  var buf = new Buffer(16)
  buf.writeUInt32BE(out[0], 0)
  buf.writeUInt32BE(out[1], 4)
  buf.writeUInt32BE(out[2], 8)
  buf.writeUInt32BE(out[3], 12)
  return buf
}

AES.prototype.decryptBlock = function (M) {
  M = bufferToArray(new Buffer(M))
  var temp = [M[3], M[1]]
  M[1] = temp[0]
  M[3] = temp[1]
  var out = this._doCryptBlock(M, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX)
  var buf = new Buffer(16)
  buf.writeUInt32BE(out[0], 0)
  buf.writeUInt32BE(out[3], 4)
  buf.writeUInt32BE(out[2], 8)
  buf.writeUInt32BE(out[1], 12)
  return buf
}

AES.prototype.scrub = function () {
  scrub_vec(this._keySchedule)
  scrub_vec(this._invKeySchedule)
  scrub_vec(this._key)
}

AES.prototype._doCryptBlock = function (M, keySchedule, SUB_MIX, SBOX) {
  var ksRow, s0, s1, s2, s3, t0, t1, t2, t3

  s0 = M[0] ^ keySchedule[0]
  s1 = M[1] ^ keySchedule[1]
  s2 = M[2] ^ keySchedule[2]
  s3 = M[3] ^ keySchedule[3]
  ksRow = 4
  for (var round = 1; round < this._nRounds; round++) {
    t0 = SUB_MIX[0][s0 >>> 24] ^ SUB_MIX[1][(s1 >>> 16) & 0xff] ^ SUB_MIX[2][(s2 >>> 8) & 0xff] ^ SUB_MIX[3][s3 & 0xff] ^ keySchedule[ksRow++]
    t1 = SUB_MIX[0][s1 >>> 24] ^ SUB_MIX[1][(s2 >>> 16) & 0xff] ^ SUB_MIX[2][(s3 >>> 8) & 0xff] ^ SUB_MIX[3][s0 & 0xff] ^ keySchedule[ksRow++]
    t2 = SUB_MIX[0][s2 >>> 24] ^ SUB_MIX[1][(s3 >>> 16) & 0xff] ^ SUB_MIX[2][(s0 >>> 8) & 0xff] ^ SUB_MIX[3][s1 & 0xff] ^ keySchedule[ksRow++]
    t3 = SUB_MIX[0][s3 >>> 24] ^ SUB_MIX[1][(s0 >>> 16) & 0xff] ^ SUB_MIX[2][(s1 >>> 8) & 0xff] ^ SUB_MIX[3][s2 & 0xff] ^ keySchedule[ksRow++]
    s0 = t0
    s1 = t1
    s2 = t2
    s3 = t3
  }
  t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++]
  t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++]
  t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++]
  t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++]
  return [
    fixup_uint32(t0),
    fixup_uint32(t1),
    fixup_uint32(t2),
    fixup_uint32(t3)
  ]
}

exports.AES = AES

}).call(this,require("buffer").Buffer)

},{"buffer":151}],234:[function(require,module,exports){
(function (Buffer){
var aes = require('./aes')
var Transform = require('cipher-base')
var inherits = require('inherits')
var GHASH = require('./ghash')
var xor = require('buffer-xor')
inherits(StreamCipher, Transform)
module.exports = StreamCipher

function StreamCipher (mode, key, iv, decrypt) {
  if (!(this instanceof StreamCipher)) {
    return new StreamCipher(mode, key, iv)
  }
  Transform.call(this)
  this._finID = Buffer.concat([iv, new Buffer([0, 0, 0, 1])])
  iv = Buffer.concat([iv, new Buffer([0, 0, 0, 2])])
  this._cipher = new aes.AES(key)
  this._prev = new Buffer(iv.length)
  this._cache = new Buffer('')
  this._secCache = new Buffer('')
  this._decrypt = decrypt
  this._alen = 0
  this._len = 0
  iv.copy(this._prev)
  this._mode = mode
  var h = new Buffer(4)
  h.fill(0)
  this._ghash = new GHASH(this._cipher.encryptBlock(h))
  this._authTag = null
  this._called = false
}
StreamCipher.prototype._update = function (chunk) {
  if (!this._called && this._alen) {
    var rump = 16 - (this._alen % 16)
    if (rump < 16) {
      rump = new Buffer(rump)
      rump.fill(0)
      this._ghash.update(rump)
    }
  }
  this._called = true
  var out = this._mode.encrypt(this, chunk)
  if (this._decrypt) {
    this._ghash.update(chunk)
  } else {
    this._ghash.update(out)
  }
  this._len += chunk.length
  return out
}
StreamCipher.prototype._final = function () {
  if (this._decrypt && !this._authTag) {
    throw new Error('Unsupported state or unable to authenticate data')
  }
  var tag = xor(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID))
  if (this._decrypt) {
    if (xorTest(tag, this._authTag)) {
      throw new Error('Unsupported state or unable to authenticate data')
    }
  } else {
    this._authTag = tag
  }
  this._cipher.scrub()
}
StreamCipher.prototype.getAuthTag = function getAuthTag () {
  if (!this._decrypt && Buffer.isBuffer(this._authTag)) {
    return this._authTag
  } else {
    throw new Error('Attempting to get auth tag in unsupported state')
  }
}
StreamCipher.prototype.setAuthTag = function setAuthTag (tag) {
  if (this._decrypt) {
    this._authTag = tag
  } else {
    throw new Error('Attempting to set auth tag in unsupported state')
  }
}
StreamCipher.prototype.setAAD = function setAAD (buf) {
  if (!this._called) {
    this._ghash.update(buf)
    this._alen += buf.length
  } else {
    throw new Error('Attempting to set AAD in unsupported state')
  }
}
function xorTest (a, b) {
  var out = 0
  if (a.length !== b.length) {
    out++
  }
  var len = Math.min(a.length, b.length)
  var i = -1
  while (++i < len) {
    out += (a[i] ^ b[i])
  }
  return out
}

}).call(this,require("buffer").Buffer)

},{"./aes":233,"./ghash":238,"buffer":151,"buffer-xor":247,"cipher-base":248,"inherits":348}],235:[function(require,module,exports){
arguments[4][159][0].apply(exports,arguments)
},{"./decrypter":236,"./encrypter":237,"./modes":239,"dup":159}],236:[function(require,module,exports){
(function (Buffer){
var aes = require('./aes')
var Transform = require('cipher-base')
var inherits = require('inherits')
var modes = require('./modes')
var StreamCipher = require('./streamCipher')
var AuthCipher = require('./authCipher')
var ebtk = require('evp_bytestokey')

inherits(Decipher, Transform)
function Decipher (mode, key, iv) {
  if (!(this instanceof Decipher)) {
    return new Decipher(mode, key, iv)
  }
  Transform.call(this)
  this._cache = new Splitter()
  this._last = void 0
  this._cipher = new aes.AES(key)
  this._prev = new Buffer(iv.length)
  iv.copy(this._prev)
  this._mode = mode
  this._autopadding = true
}
Decipher.prototype._update = function (data) {
  this._cache.add(data)
  var chunk
  var thing
  var out = []
  while ((chunk = this._cache.get(this._autopadding))) {
    thing = this._mode.decrypt(this, chunk)
    out.push(thing)
  }
  return Buffer.concat(out)
}
Decipher.prototype._final = function () {
  var chunk = this._cache.flush()
  if (this._autopadding) {
    return unpad(this._mode.decrypt(this, chunk))
  } else if (chunk) {
    throw new Error('data not multiple of block length')
  }
}
Decipher.prototype.setAutoPadding = function (setTo) {
  this._autopadding = !!setTo
}
function Splitter () {
  if (!(this instanceof Splitter)) {
    return new Splitter()
  }
  this.cache = new Buffer('')
}
Splitter.prototype.add = function (data) {
  this.cache = Buffer.concat([this.cache, data])
}

Splitter.prototype.get = function (autoPadding) {
  var out
  if (autoPadding) {
    if (this.cache.length > 16) {
      out = this.cache.slice(0, 16)
      this.cache = this.cache.slice(16)
      return out
    }
  } else {
    if (this.cache.length >= 16) {
      out = this.cache.slice(0, 16)
      this.cache = this.cache.slice(16)
      return out
    }
  }
  return null
}
Splitter.prototype.flush = function () {
  if (this.cache.length) {
    return this.cache
  }
}
function unpad (last) {
  var padded = last[15]
  var i = -1
  while (++i < padded) {
    if (last[(i + (16 - padded))] !== padded) {
      throw new Error('unable to decrypt data')
    }
  }
  if (padded === 16) {
    return
  }
  return last.slice(0, 16 - padded)
}

var modelist = {
  ECB: require('./modes/ecb'),
  CBC: require('./modes/cbc'),
  CFB: require('./modes/cfb'),
  CFB8: require('./modes/cfb8'),
  CFB1: require('./modes/cfb1'),
  OFB: require('./modes/ofb'),
  CTR: require('./modes/ctr'),
  GCM: require('./modes/ctr')
}

function createDecipheriv (suite, password, iv) {
  var config = modes[suite.toLowerCase()]
  if (!config) {
    throw new TypeError('invalid suite type')
  }
  if (typeof iv === 'string') {
    iv = new Buffer(iv)
  }
  if (typeof password === 'string') {
    password = new Buffer(password)
  }
  if (password.length !== config.key / 8) {
    throw new TypeError('invalid key length ' + password.length)
  }
  if (iv.length !== config.iv) {
    throw new TypeError('invalid iv length ' + iv.length)
  }
  if (config.type === 'stream') {
    return new StreamCipher(modelist[config.mode], password, iv, true)
  } else if (config.type === 'auth') {
    return new AuthCipher(modelist[config.mode], password, iv, true)
  }
  return new Decipher(modelist[config.mode], password, iv)
}

function createDecipher (suite, password) {
  var config = modes[suite.toLowerCase()]
  if (!config) {
    throw new TypeError('invalid suite type')
  }
  var keys = ebtk(password, false, config.key, config.iv)
  return createDecipheriv(suite, keys.key, keys.iv)
}
exports.createDecipher = createDecipher
exports.createDecipheriv = createDecipheriv

}).call(this,require("buffer").Buffer)

},{"./aes":233,"./authCipher":234,"./modes":239,"./modes/cbc":240,"./modes/cfb":241,"./modes/cfb1":242,"./modes/cfb8":243,"./modes/ctr":244,"./modes/ecb":245,"./modes/ofb":246,"./streamCipher":249,"buffer":151,"cipher-base":248,"evp_bytestokey":250,"inherits":348}],237:[function(require,module,exports){
(function (Buffer){
var aes = require('./aes')
var Transform = require('cipher-base')
var inherits = require('inherits')
var modes = require('./modes')
var ebtk = require('evp_bytestokey')
var StreamCipher = require('./streamCipher')
var AuthCipher = require('./authCipher')
inherits(Cipher, Transform)
function Cipher (mode, key, iv) {
  if (!(this instanceof Cipher)) {
    return new Cipher(mode, key, iv)
  }
  Transform.call(this)
  this._cache = new Splitter()
  this._cipher = new aes.AES(key)
  this._prev = new Buffer(iv.length)
  iv.copy(this._prev)
  this._mode = mode
  this._autopadding = true
}
Cipher.prototype._update = function (data) {
  this._cache.add(data)
  var chunk
  var thing
  var out = []
  while ((chunk = this._cache.get())) {
    thing = this._mode.encrypt(this, chunk)
    out.push(thing)
  }
  return Buffer.concat(out)
}
Cipher.prototype._final = function () {
  var chunk = this._cache.flush()
  if (this._autopadding) {
    chunk = this._mode.encrypt(this, chunk)
    this._cipher.scrub()
    return chunk
  } else if (chunk.toString('hex') !== '10101010101010101010101010101010') {
    this._cipher.scrub()
    throw new Error('data not multiple of block length')
  }
}
Cipher.prototype.setAutoPadding = function (setTo) {
  this._autopadding = !!setTo
}

function Splitter () {
  if (!(this instanceof Splitter)) {
    return new Splitter()
  }
  this.cache = new Buffer('')
}
Splitter.prototype.add = function (data) {
  this.cache = Buffer.concat([this.cache, data])
}

Splitter.prototype.get = function () {
  if (this.cache.length > 15) {
    var out = this.cache.slice(0, 16)
    this.cache = this.cache.slice(16)
    return out
  }
  return null
}
Splitter.prototype.flush = function () {
  var len = 16 - this.cache.length
  var padBuff = new Buffer(len)

  var i = -1
  while (++i < len) {
    padBuff.writeUInt8(len, i)
  }
  var out = Buffer.concat([this.cache, padBuff])
  return out
}
var modelist = {
  ECB: require('./modes/ecb'),
  CBC: require('./modes/cbc'),
  CFB: require('./modes/cfb'),
  CFB8: require('./modes/cfb8'),
  CFB1: require('./modes/cfb1'),
  OFB: require('./modes/ofb'),
  CTR: require('./modes/ctr'),
  GCM: require('./modes/ctr')
}

function createCipheriv (suite, password, iv) {
  var config = modes[suite.toLowerCase()]
  if (!config) {
    throw new TypeError('invalid suite type')
  }
  if (typeof iv === 'string') {
    iv = new Buffer(iv)
  }
  if (typeof password === 'string') {
    password = new Buffer(password)
  }
  if (password.length !== config.key / 8) {
    throw new TypeError('invalid key length ' + password.length)
  }
  if (iv.length !== config.iv) {
    throw new TypeError('invalid iv length ' + iv.length)
  }
  if (config.type === 'stream') {
    return new StreamCipher(modelist[config.mode], password, iv)
  } else if (config.type === 'auth') {
    return new AuthCipher(modelist[config.mode], password, iv)
  }
  return new Cipher(modelist[config.mode], password, iv)
}
function createCipher (suite, password) {
  var config = modes[suite.toLowerCase()]
  if (!config) {
    throw new TypeError('invalid suite type')
  }
  var keys = ebtk(password, false, config.key, config.iv)
  return createCipheriv(suite, keys.key, keys.iv)
}

exports.createCipheriv = createCipheriv
exports.createCipher = createCipher

}).call(this,require("buffer").Buffer)

},{"./aes":233,"./authCipher":234,"./modes":239,"./modes/cbc":240,"./modes/cfb":241,"./modes/cfb1":242,"./modes/cfb8":243,"./modes/ctr":244,"./modes/ecb":245,"./modes/ofb":246,"./streamCipher":249,"buffer":151,"cipher-base":248,"evp_bytestokey":250,"inherits":348}],238:[function(require,module,exports){
(function (Buffer){
var zeros = new Buffer(16)
zeros.fill(0)
module.exports = GHASH
function GHASH (key) {
  this.h = key
  this.state = new Buffer(16)
  this.state.fill(0)
  this.cache = new Buffer('')
}
// from http://bitwiseshiftleft.github.io/sjcl/doc/symbols/src/core_gcm.js.html
// by Juho Vähä-Herttua
GHASH.prototype.ghash = function (block) {
  var i = -1
  while (++i < block.length) {
    this.state[i] ^= block[i]
  }
  this._multiply()
}

GHASH.prototype._multiply = function () {
  var Vi = toArray(this.h)
  var Zi = [0, 0, 0, 0]
  var j, xi, lsb_Vi
  var i = -1
  while (++i < 128) {
    xi = (this.state[~~(i / 8)] & (1 << (7 - i % 8))) !== 0
    if (xi) {
      // Z_i+1 = Z_i ^ V_i
      Zi = xor(Zi, Vi)
    }

    // Store the value of LSB(V_i)
    lsb_Vi = (Vi[3] & 1) !== 0

    // V_i+1 = V_i >> 1
    for (j = 3; j > 0; j--) {
      Vi[j] = (Vi[j] >>> 1) | ((Vi[j - 1] & 1) << 31)
    }
    Vi[0] = Vi[0] >>> 1

    // If LSB(V_i) is 1, V_i+1 = (V_i >> 1) ^ R
    if (lsb_Vi) {
      Vi[0] = Vi[0] ^ (0xe1 << 24)
    }
  }
  this.state = fromArray(Zi)
}
GHASH.prototype.update = function (buf) {
  this.cache = Buffer.concat([this.cache, buf])
  var chunk
  while (this.cache.length >= 16) {
    chunk = this.cache.slice(0, 16)
    this.cache = this.cache.slice(16)
    this.ghash(chunk)
  }
}
GHASH.prototype.final = function (abl, bl) {
  if (this.cache.length) {
    this.ghash(Buffer.concat([this.cache, zeros], 16))
  }
  this.ghash(fromArray([
    0, abl,
    0, bl
  ]))
  return this.state
}

function toArray (buf) {
  return [
    buf.readUInt32BE(0),
    buf.readUInt32BE(4),
    buf.readUInt32BE(8),
    buf.readUInt32BE(12)
  ]
}
function fromArray (out) {
  out = out.map(fixup_uint32)
  var buf = new Buffer(16)
  buf.writeUInt32BE(out[0], 0)
  buf.writeUInt32BE(out[1], 4)
  buf.writeUInt32BE(out[2], 8)
  buf.writeUInt32BE(out[3], 12)
  return buf
}
var uint_max = Math.pow(2, 32)
function fixup_uint32 (x) {
  var ret, x_pos
  ret = x > uint_max || x < 0 ? (x_pos = Math.abs(x) % uint_max, x < 0 ? uint_max - x_pos : x_pos) : x
  return ret
}
function xor (a, b) {
  return [
    a[0] ^ b[0],
    a[1] ^ b[1],
    a[2] ^ b[2],
    a[3] ^ b[3]
  ]
}

}).call(this,require("buffer").Buffer)

},{"buffer":151}],239:[function(require,module,exports){
arguments[4][163][0].apply(exports,arguments)
},{"dup":163}],240:[function(require,module,exports){
arguments[4][164][0].apply(exports,arguments)
},{"buffer-xor":247,"dup":164}],241:[function(require,module,exports){
(function (Buffer){
var xor = require('buffer-xor')

exports.encrypt = function (self, data, decrypt) {
  var out = new Buffer('')
  var len

  while (data.length) {
    if (self._cache.length === 0) {
      self._cache = self._cipher.encryptBlock(self._prev)
      self._prev = new Buffer('')
    }

    if (self._cache.length <= data.length) {
      len = self._cache.length
      out = Buffer.concat([out, encryptStart(self, data.slice(0, len), decrypt)])
      data = data.slice(len)
    } else {
      out = Buffer.concat([out, encryptStart(self, data, decrypt)])
      break
    }
  }

  return out
}
function encryptStart (self, data, decrypt) {
  var len = data.length
  var out = xor(data, self._cache)
  self._cache = self._cache.slice(len)
  self._prev = Buffer.concat([self._prev, decrypt ? data : out])
  return out
}

}).call(this,require("buffer").Buffer)

},{"buffer":151,"buffer-xor":247}],242:[function(require,module,exports){
(function (Buffer){
function encryptByte (self, byteParam, decrypt) {
  var pad
  var i = -1
  var len = 8
  var out = 0
  var bit, value
  while (++i < len) {
    pad = self._cipher.encryptBlock(self._prev)
    bit = (byteParam & (1 << (7 - i))) ? 0x80 : 0
    value = pad[0] ^ bit
    out += ((value & 0x80) >> (i % 8))
    self._prev = shiftIn(self._prev, decrypt ? bit : value)
  }
  return out
}
exports.encrypt = function (self, chunk, decrypt) {
  var len = chunk.length
  var out = new Buffer(len)
  var i = -1
  while (++i < len) {
    out[i] = encryptByte(self, chunk[i], decrypt)
  }
  return out
}
function shiftIn (buffer, value) {
  var len = buffer.length
  var i = -1
  var out = new Buffer(buffer.length)
  buffer = Buffer.concat([buffer, new Buffer([value])])
  while (++i < len) {
    out[i] = buffer[i] << 1 | buffer[i + 1] >> (7)
  }
  return out
}

}).call(this,require("buffer").Buffer)

},{"buffer":151}],243:[function(require,module,exports){
(function (Buffer){
function encryptByte (self, byteParam, decrypt) {
  var pad = self._cipher.encryptBlock(self._prev)
  var out = pad[0] ^ byteParam
  self._prev = Buffer.concat([self._prev.slice(1), new Buffer([decrypt ? byteParam : out])])
  return out
}
exports.encrypt = function (self, chunk, decrypt) {
  var len = chunk.length
  var out = new Buffer(len)
  var i = -1
  while (++i < len) {
    out[i] = encryptByte(self, chunk[i], decrypt)
  }
  return out
}

}).call(this,require("buffer").Buffer)

},{"buffer":151}],244:[function(require,module,exports){
(function (Buffer){
var xor = require('buffer-xor')

function incr32 (iv) {
  var len = iv.length
  var item
  while (len--) {
    item = iv.readUInt8(len)
    if (item === 255) {
      iv.writeUInt8(0, len)
    } else {
      item++
      iv.writeUInt8(item, len)
      break
    }
  }
}

function getBlock (self) {
  var out = self._cipher.encryptBlock(self._prev)
  incr32(self._prev)
  return out
}

exports.encrypt = function (self, chunk) {
  while (self._cache.length < chunk.length) {
    self._cache = Buffer.concat([self._cache, getBlock(self)])
  }
  var pad = self._cache.slice(0, chunk.length)
  self._cache = self._cache.slice(chunk.length)
  return xor(chunk, pad)
}

}).call(this,require("buffer").Buffer)

},{"buffer":151,"buffer-xor":247}],245:[function(require,module,exports){
arguments[4][169][0].apply(exports,arguments)
},{"dup":169}],246:[function(require,module,exports){
(function (Buffer){
var xor = require('buffer-xor')

function getBlock (self) {
  self._prev = self._cipher.encryptBlock(self._prev)
  return self._prev
}

exports.encrypt = function (self, chunk) {
  while (self._cache.length < chunk.length) {
    self._cache = Buffer.concat([self._cache, getBlock(self)])
  }

  var pad = self._cache.slice(0, chunk.length)
  self._cache = self._cache.slice(chunk.length)
  return xor(chunk, pad)
}

}).call(this,require("buffer").Buffer)

},{"buffer":151,"buffer-xor":247}],247:[function(require,module,exports){
(function (Buffer){
module.exports = function xor (a, b) {
  var length = Math.min(a.length, b.length)
  var buffer = new Buffer(length)

  for (var i = 0; i < length; ++i) {
    buffer[i] = a[i] ^ b[i]
  }

  return buffer
}

}).call(this,require("buffer").Buffer)

},{"buffer":151}],248:[function(require,module,exports){
(function (Buffer){
var Transform = require('stream').Transform
var inherits = require('inherits')
var StringDecoder = require('string_decoder').StringDecoder
module.exports = CipherBase
inherits(CipherBase, Transform)
function CipherBase (hashMode) {
  Transform.call(this)
  this.hashMode = typeof hashMode === 'string'
  if (this.hashMode) {
    this[hashMode] = this._finalOrDigest
  } else {
    this.final = this._finalOrDigest
  }
  this._decoder = null
  this._encoding = null
}
CipherBase.prototype.update = function (data, inputEnc, outputEnc) {
  if (typeof data === 'string') {
    data = new Buffer(data, inputEnc)
  }
  var outData = this._update(data)
  if (this.hashMode) {
    return this
  }
  if (outputEnc) {
    outData = this._toString(outData, outputEnc)
  }
  return outData
}

CipherBase.prototype.setAutoPadding = function () {}

CipherBase.prototype.getAuthTag = function () {
  throw new Error('trying to get auth tag in unsupported state')
}

CipherBase.prototype.setAuthTag = function () {
  throw new Error('trying to set auth tag in unsupported state')
}

CipherBase.prototype.setAAD = function () {
  throw new Error('trying to set aad in unsupported state')
}

CipherBase.prototype._transform = function (data, _, next) {
  var err
  try {
    if (this.hashMode) {
      this._update(data)
    } else {
      this.push(this._update(data))
    }
  } catch (e) {
    err = e
  } finally {
    next(err)
  }
}
CipherBase.prototype._flush = function (done) {
  var err
  try {
    this.push(this._final())
  } catch (e) {
    err = e
  } finally {
    done(err)
  }
}
CipherBase.prototype._finalOrDigest = function (outputEnc) {
  var outData = this._final() || new Buffer('')
  if (outputEnc) {
    outData = this._toString(outData, outputEnc, true)
  }
  return outData
}

CipherBase.prototype._toString = function (value, enc, final) {
  if (!this._decoder) {
    this._decoder = new StringDecoder(enc)
    this._encoding = enc
  }
  if (this._encoding !== enc) {
    throw new Error('can\'t switch encodings')
  }
  var out = this._decoder.write(value)
  if (final) {
    out += this._decoder.end()
  }
  return out
}

}).call(this,require("buffer").Buffer)

},{"buffer":151,"inherits":348,"stream":365,"string_decoder":366}],249:[function(require,module,exports){
(function (Buffer){
var aes = require('./aes')
var Transform = require('cipher-base')
var inherits = require('inherits')

inherits(StreamCipher, Transform)
module.exports = StreamCipher
function StreamCipher (mode, key, iv, decrypt) {
  if (!(this instanceof StreamCipher)) {
    return new StreamCipher(mode, key, iv)
  }
  Transform.call(this)
  this._cipher = new aes.AES(key)
  this._prev = new Buffer(iv.length)
  this._cache = new Buffer('')
  this._secCache = new Buffer('')
  this._decrypt = decrypt
  iv.copy(this._prev)
  this._mode = mode
}
StreamCipher.prototype._update = function (chunk) {
  return this._mode.encrypt(this, chunk, this._decrypt)
}
StreamCipher.prototype._final = function () {
  this._cipher.scrub()
}

}).call(this,require("buffer").Buffer)

},{"./aes":233,"buffer":151,"cipher-base":248,"inherits":348}],250:[function(require,module,exports){
(function (Buffer){
var md5 = require('create-hash/md5')
module.exports = EVP_BytesToKey
function EVP_BytesToKey (password, salt, keyLen, ivLen) {
  if (!Buffer.isBuffer(password)) {
    password = new Buffer(password, 'binary')
  }
  if (salt && !Buffer.isBuffer(salt)) {
    salt = new Buffer(salt, 'binary')
  }
  keyLen = keyLen / 8
  ivLen = ivLen || 0
  var ki = 0
  var ii = 0
  var key = new Buffer(keyLen)
  var iv = new Buffer(ivLen)
  var addmd = 0
  var md_buf
  var i
  var bufs = []
  while (true) {
    if (addmd++ > 0) {
      bufs.push(md_buf)
    }
    bufs.push(password)
    if (salt) {
      bufs.push(salt)
    }
    md_buf = md5(Buffer.concat(bufs))
    bufs = []
    i = 0
    if (keyLen > 0) {
      while (true) {
        if (keyLen === 0) {
          break
        }
        if (i === md_buf.length) {
          break
        }
        key[ki++] = md_buf[i]
        keyLen--
        i++
      }
    }
    if (ivLen > 0 && i !== md_buf.length) {
      while (true) {
        if (ivLen === 0) {
          break
        }
        if (i === md_buf.length) {
          break
        }
        iv[ii++] = md_buf[i]
        ivLen--
        i++
      }
    }
    if (keyLen === 0 && ivLen === 0) {
      break
    }
  }
  for (i = 0; i < md_buf.length; i++) {
    md_buf[i] = 0
  }
  return {
    key: key,
    iv: iv
  }
}

}).call(this,require("buffer").Buffer)

},{"buffer":151,"create-hash/md5":281}],251:[function(require,module,exports){
(function (Buffer){
// much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js
var createHmac = require('create-hmac')
var crt = require('browserify-rsa')
var curves = require('./curves')
var elliptic = require('elliptic')
var parseKeys = require('parse-asn1')

var BN = require('bn.js')
var EC = elliptic.ec

function sign (hash, key, hashType, signType) {
  var priv = parseKeys(key)
  if (priv.curve) {
    if (signType !== 'ecdsa') throw new Error('wrong private key type')

    return ecSign(hash, priv)
  } else if (priv.type === 'dsa') {
    if (signType !== 'dsa') {
      throw new Error('wrong private key type')
    }
    return dsaSign(hash, priv, hashType)
  } else {
    if (signType !== 'rsa') throw new Error('wrong private key type')
  }

  var len = priv.modulus.byteLength()
  var pad = [ 0, 1 ]
  while (hash.length + pad.length + 1 < len) {
    pad.push(0xff)
  }
  pad.push(0x00)
  var i = -1
  while (++i < hash.length) {
    pad.push(hash[i])
  }

  var out = crt(pad, priv)
  return out
}

function ecSign (hash, priv) {
  var curveId = curves[priv.curve.join('.')]
  if (!curveId) throw new Error('unknown curve ' + priv.curve.join('.'))

  var curve = new EC(curveId)
  var key = curve.genKeyPair()

  key._importPrivate(priv.privateKey)
  var out = key.sign(hash)

  return new Buffer(out.toDER())
}

function dsaSign (hash, priv, algo) {
  var x = priv.params.priv_key
  var p = priv.params.p
  var q = priv.params.q
  var g = priv.params.g
  var r = new BN(0)
  var k
  var H = bits2int(hash, q).mod(q)
  var s = false
  var kv = getKey(x, q, hash, algo)
  while (s === false) {
    k = makeKey(q, kv, algo)
    r = makeR(g, k, p, q)
    s = k.invm(q).imul(H.add(x.mul(r))).mod(q)
    if (!s.cmpn(0)) {
      s = false
      r = new BN(0)
    }
  }
  return toDER(r, s)
}

function toDER (r, s) {
  r = r.toArray()
  s = s.toArray()

  // Pad values
  if (r[0] & 0x80) {
    r = [ 0 ].concat(r)
  }
  // Pad values
  if (s[0] & 0x80) {
    s = [0].concat(s)
  }

  var total = r.length + s.length + 4
  var res = [ 0x30, total, 0x02, r.length ]
  res = res.concat(r, [ 0x02, s.length ], s)
  return new Buffer(res)
}

function getKey (x, q, hash, algo) {
  x = new Buffer(x.toArray())
  if (x.length < q.byteLength()) {
    var zeros = new Buffer(q.byteLength() - x.length)
    zeros.fill(0)
    x = Buffer.concat([zeros, x])
  }
  var hlen = hash.length
  var hbits = bits2octets(hash, q)
  var v = new Buffer(hlen)
  v.fill(1)
  var k = new Buffer(hlen)
  k.fill(0)
  k = createHmac(algo, k)
    .update(v)
    .update(new Buffer([0]))
    .update(x)
    .update(hbits)
    .digest()
  v = createHmac(algo, k)
    .update(v)
    .digest()
  k = createHmac(algo, k)
    .update(v)
    .update(new Buffer([1]))
    .update(x)
    .update(hbits)
    .digest()
  v = createHmac(algo, k)
    .update(v)
    .digest()
  return {
    k: k,
    v: v
  }
}

function bits2int (obits, q) {
  var bits = new BN(obits)
  var shift = (obits.length << 3) - q.bitLength()
  if (shift > 0) {
    bits.ishrn(shift)
  }
  return bits
}

function bits2octets (bits, q) {
  bits = bits2int(bits, q)
  bits = bits.mod(q)
  var out = new Buffer(bits.toArray())
  if (out.length < q.byteLength()) {
    var zeros = new Buffer(q.byteLength() - out.length)
    zeros.fill(0)
    out = Buffer.concat([zeros, out])
  }
  return out
}

function makeKey (q, kv, algo) {
  var t, k

  do {
    t = new Buffer('')

    while (t.length * 8 < q.bitLength()) {
      kv.v = createHmac(algo, kv.k)
        .update(kv.v)
        .digest()
      t = Buffer.concat([t, kv.v])
    }

    k = bits2int(t, q)
    kv.k = createHmac(algo, kv.k)
      .update(kv.v)
      .update(new Buffer([0]))
      .digest()
    kv.v = createHmac(algo, kv.k)
      .update(kv.v)
      .digest()
  } while (k.cmp(q) !== -1)

  return k
}

function makeR (g, k, p, q) {
  return g.toRed(BN.mont(p)).redPow(k).fromRed().mod(q)
}

module.exports = sign
module.exports.getKey = getKey
module.exports.makeKey = makeKey

}).call(this,require("buffer").Buffer)

},{"./curves":187,"bn.js":188,"browserify-rsa":189,"buffer":151,"create-hmac":292,"elliptic":190,"parse-asn1":217}],252:[function(require,module,exports){
(function (Buffer){
// much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js
var curves = require('./curves')
var elliptic = require('elliptic')
var parseKeys = require('parse-asn1')

var BN = require('bn.js')
var EC = elliptic.ec

function verify (sig, hash, key, signType) {
  var pub = parseKeys(key)
  if (pub.type === 'ec') {
    if (signType !== 'ecdsa') {
      throw new Error('wrong public key type')
    }
    return ecVerify(sig, hash, pub)
  } else if (pub.type === 'dsa') {
    if (signType !== 'dsa') {
      throw new Error('wrong public key type')
    }
    return dsaVerify(sig, hash, pub)
  } else {
    if (signType !== 'rsa') {
      throw new Error('wrong public key type')
    }
  }
  var len = pub.modulus.byteLength()
  var pad = [ 1 ]
  var padNum = 0
  while (hash.length + pad.length + 2 < len) {
    pad.push(0xff)
    padNum++
  }
  pad.push(0x00)
  var i = -1
  while (++i < hash.length) {
    pad.push(hash[i])
  }
  pad = new Buffer(pad)
  var red = BN.mont(pub.modulus)
  sig = new BN(sig).toRed(red)

  sig = sig.redPow(new BN(pub.publicExponent))

  sig = new Buffer(sig.fromRed().toArray())
  var out = 0
  if (padNum < 8) {
    out = 1
  }
  len = Math.min(sig.length, pad.length)
  if (sig.length !== pad.length) {
    out = 1
  }

  i = -1
  while (++i < len) {
    out |= (sig[i] ^ pad[i])
  }
  return out === 0
}

function ecVerify (sig, hash, pub) {
  var curveId = curves[pub.data.algorithm.curve.join('.')]
  if (!curveId) throw new Error('unknown curve ' + pub.data.algorithm.curve.join('.'))

  var curve = new EC(curveId)
  var pubkey = pub.data.subjectPrivateKey.data

  return curve.verify(hash, sig, pubkey)
}

function dsaVerify (sig, hash, pub) {
  var p = pub.data.p
  var q = pub.data.q
  var g = pub.data.g
  var y = pub.data.pub_key
  var unpacked = parseKeys.signature.decode(sig, 'der')
  var s = unpacked.s
  var r = unpacked.r
  checkValue(s, q)
  checkValue(r, q)
  var montp = BN.mont(p)
  var w = s.invm(q)
  var v = g.toRed(montp)
    .redPow(new BN(hash).mul(w).mod(q))
    .fromRed()
    .mul(
      y.toRed(montp)
        .redPow(r.mul(w).mod(q))
        .fromRed()
  ).mod(p).mod(q)
  return !v.cmp(r)
}

function checkValue (b, q) {
  if (b.cmpn(0) <= 0) {
    throw new Error('invalid sig')
  }
  if (b.cmp(q) >= q) {
    throw new Error('invalid sig')
  }
}

module.exports = verify

}).call(this,require("buffer").Buffer)

},{"./curves":187,"bn.js":188,"buffer":151,"elliptic":190,"parse-asn1":217}],253:[function(require,module,exports){
(function (Buffer){
var elliptic = require('elliptic');
var BN = require('bn.js');

module.exports = function createECDH(curve) {
	return new ECDH(curve);
};

var aliases = {
	secp256k1: {
		name: 'secp256k1',
		byteLength: 32
	},
	secp224r1: {
		name: 'p224',
		byteLength: 28
	},
	prime256v1: {
		name: 'p256',
		byteLength: 32
	},
	prime192v1: {
		name: 'p192',
		byteLength: 24
	},
	ed25519: {
		name: 'ed25519',
		byteLength: 32
	},
	secp384r1: {
		name: 'p384',
		byteLength: 48
	},
	secp521r1: {
		name: 'p521',
		byteLength: 66
	}
};

aliases.p224 = aliases.secp224r1;
aliases.p256 = aliases.secp256r1 = aliases.prime256v1;
aliases.p192 = aliases.secp192r1 = aliases.prime192v1;
aliases.p384 = aliases.secp384r1;
aliases.p521 = aliases.secp521r1;

function ECDH(curve) {
	this.curveType = aliases[curve];
	if (!this.curveType ) {
		this.curveType = {
			name: curve
		};
	}
	this.curve = new elliptic.ec(this.curveType.name);
	this.keys = void 0;
}

ECDH.prototype.generateKeys = function (enc, format) {
	this.keys = this.curve.genKeyPair();
	return this.getPublicKey(enc, format);
};

ECDH.prototype.computeSecret = function (other, inenc, enc) {
	inenc = inenc || 'utf8';
	if (!Buffer.isBuffer(other)) {
		other = new Buffer(other, inenc);
	}
	var otherPub = this.curve.keyFromPublic(other).getPublic();
	var out = otherPub.mul(this.keys.getPrivate()).getX();
	return formatReturnValue(out, enc, this.curveType.byteLength);
};

ECDH.prototype.getPublicKey = function (enc, format) {
	var key = this.keys.getPublic(format === 'compressed', true);
	if (format === 'hybrid') {
		if (key[key.length - 1] % 2) {
			key[0] = 7;
		} else {
			key [0] = 6;
		}
	}
	return formatReturnValue(key, enc);
};

ECDH.prototype.getPrivateKey = function (enc) {
	return formatReturnValue(this.keys.getPrivate(), enc);
};

ECDH.prototype.setPublicKey = function (pub, enc) {
	enc = enc || 'utf8';
	if (!Buffer.isBuffer(pub)) {
		pub = new Buffer(pub, enc);
	}
	this.keys._importPublic(pub);
	return this;
};

ECDH.prototype.setPrivateKey = function (priv, enc) {
	enc = enc || 'utf8';
	if (!Buffer.isBuffer(priv)) {
		priv = new Buffer(priv, enc);
	}
	var _priv = new BN(priv);
	_priv = _priv.toString(16);
	this.keys._importPrivate(_priv);
	return this;
};

function formatReturnValue(bn, enc, len) {
	if (!Array.isArray(bn)) {
		bn = bn.toArray();
	}
	var buf = new Buffer(bn);
	if (len && buf.length < len) {
		var zeros = new Buffer(len - buf.length);
		zeros.fill(0);
		buf = Buffer.concat([zeros, buf]);
	}
	if (!enc) {
		return buf;
	} else {
		return buf.toString(enc);
	}
}

}).call(this,require("buffer").Buffer)

},{"bn.js":254,"buffer":151,"elliptic":255}],254:[function(require,module,exports){
arguments[4][188][0].apply(exports,arguments)
},{"dup":188}],255:[function(require,module,exports){
arguments[4][190][0].apply(exports,arguments)
},{"../package.json":278,"./elliptic/curve":258,"./elliptic/curves":261,"./elliptic/ec":262,"./elliptic/eddsa":265,"./elliptic/hmac-drbg":268,"./elliptic/utils":270,"brorand":271,"dup":190}],256:[function(require,module,exports){
arguments[4][191][0].apply(exports,arguments)
},{"../../elliptic":255,"bn.js":254,"dup":191}],257:[function(require,module,exports){
arguments[4][192][0].apply(exports,arguments)
},{"../../elliptic":255,"../curve":258,"bn.js":254,"dup":192,"inherits":348}],258:[function(require,module,exports){
arguments[4][193][0].apply(exports,arguments)
},{"./base":256,"./edwards":257,"./mont":259,"./short":260,"dup":193}],259:[function(require,module,exports){
arguments[4][194][0].apply(exports,arguments)
},{"../../elliptic":255,"../curve":258,"bn.js":254,"dup":194,"inherits":348}],260:[function(require,module,exports){
arguments[4][195][0].apply(exports,arguments)
},{"../../elliptic":255,"../curve":258,"bn.js":254,"dup":195,"inherits":348}],261:[function(require,module,exports){
arguments[4][196][0].apply(exports,arguments)
},{"../elliptic":255,"./precomputed/secp256k1":269,"dup":196,"hash.js":272}],262:[function(require,module,exports){
arguments[4][197][0].apply(exports,arguments)
},{"../../elliptic":255,"./key":263,"./signature":264,"bn.js":254,"dup":197}],263:[function(require,module,exports){
arguments[4][198][0].apply(exports,arguments)
},{"bn.js":254,"dup":198}],264:[function(require,module,exports){
arguments[4][199][0].apply(exports,arguments)
},{"../../elliptic":255,"bn.js":254,"dup":199}],265:[function(require,module,exports){
arguments[4][200][0].apply(exports,arguments)
},{"../../elliptic":255,"./key":266,"./signature":267,"dup":200,"hash.js":272}],266:[function(require,module,exports){
arguments[4][201][0].apply(exports,arguments)
},{"../../elliptic":255,"dup":201}],267:[function(require,module,exports){
arguments[4][202][0].apply(exports,arguments)
},{"../../elliptic":255,"bn.js":254,"dup":202}],268:[function(require,module,exports){
arguments[4][203][0].apply(exports,arguments)
},{"../elliptic":255,"dup":203,"hash.js":272}],269:[function(require,module,exports){
arguments[4][204][0].apply(exports,arguments)
},{"dup":204}],270:[function(require,module,exports){
arguments[4][205][0].apply(exports,arguments)
},{"bn.js":254,"dup":205}],271:[function(require,module,exports){
arguments[4][206][0].apply(exports,arguments)
},{"dup":206}],272:[function(require,module,exports){
arguments[4][207][0].apply(exports,arguments)
},{"./hash/common":273,"./hash/hmac":274,"./hash/ripemd":275,"./hash/sha":276,"./hash/utils":277,"dup":207}],273:[function(require,module,exports){
arguments[4][208][0].apply(exports,arguments)
},{"../hash":272,"dup":208}],274:[function(require,module,exports){
arguments[4][209][0].apply(exports,arguments)
},{"../hash":272,"dup":209}],275:[function(require,module,exports){
arguments[4][210][0].apply(exports,arguments)
},{"../hash":272,"dup":210}],276:[function(require,module,exports){
arguments[4][211][0].apply(exports,arguments)
},{"../hash":272,"dup":211}],277:[function(require,module,exports){
arguments[4][212][0].apply(exports,arguments)
},{"dup":212,"inherits":348}],278:[function(require,module,exports){
arguments[4][213][0].apply(exports,arguments)
},{"dup":213}],279:[function(require,module,exports){
(function (Buffer){
'use strict';
var inherits = require('inherits')
var md5 = require('./md5')
var rmd160 = require('ripemd160')
var sha = require('sha.js')

var Base = require('cipher-base')

function HashNoConstructor(hash) {
  Base.call(this, 'digest')

  this._hash = hash
  this.buffers = []
}

inherits(HashNoConstructor, Base)

HashNoConstructor.prototype._update = function (data) {
  this.buffers.push(data)
}

HashNoConstructor.prototype._final = function () {
  var buf = Buffer.concat(this.buffers)
  var r = this._hash(buf)
  this.buffers = null

  return r
}

function Hash(hash) {
  Base.call(this, 'digest')

  this._hash = hash
}

inherits(Hash, Base)

Hash.prototype._update = function (data) {
  this._hash.update(data)
}

Hash.prototype._final = function () {
  return this._hash.digest()
}

module.exports = function createHash (alg) {
  alg = alg.toLowerCase()
  if ('md5' === alg) return new HashNoConstructor(md5)
  if ('rmd160' === alg || 'ripemd160' === alg) return new HashNoConstructor(rmd160)

  return new Hash(sha(alg))
}

}).call(this,require("buffer").Buffer)

},{"./md5":281,"buffer":151,"cipher-base":282,"inherits":348,"ripemd160":283,"sha.js":285}],280:[function(require,module,exports){
(function (Buffer){
'use strict';
var intSize = 4;
var zeroBuffer = new Buffer(intSize); zeroBuffer.fill(0);
var chrsz = 8;

function toArray(buf, bigEndian) {
  if ((buf.length % intSize) !== 0) {
    var len = buf.length + (intSize - (buf.length % intSize));
    buf = Buffer.concat([buf, zeroBuffer], len);
  }

  var arr = [];
  var fn = bigEndian ? buf.readInt32BE : buf.readInt32LE;
  for (var i = 0; i < buf.length; i += intSize) {
    arr.push(fn.call(buf, i));
  }
  return arr;
}

function toBuffer(arr, size, bigEndian) {
  var buf = new Buffer(size);
  var fn = bigEndian ? buf.writeInt32BE : buf.writeInt32LE;
  for (var i = 0; i < arr.length; i++) {
    fn.call(buf, arr[i], i * 4, true);
  }
  return buf;
}

function hash(buf, fn, hashSize, bigEndian) {
  if (!Buffer.isBuffer(buf)) buf = new Buffer(buf);
  var arr = fn(toArray(buf, bigEndian), buf.length * chrsz);
  return toBuffer(arr, hashSize, bigEndian);
}
exports.hash = hash;
}).call(this,require("buffer").Buffer)

},{"buffer":151}],281:[function(require,module,exports){
'use strict';
/*
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */

var helpers = require('./helpers');

/*
 * Calculate the MD5 of an array of little-endian words, and a bit length
 */
function core_md5(x, len)
{
  /* append padding */
  x[len >> 5] |= 0x80 << ((len) % 32);
  x[(((len + 64) >>> 9) << 4) + 14] = len;

  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;

  for(var i = 0; i < x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;

    a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);
    d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);
    c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);
    b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);
    a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);
    d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);
    c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);
    b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);
    a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);
    d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);
    c = md5_ff(c, d, a, b, x[i+10], 17, -42063);
    b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);
    a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);
    d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);
    c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);
    b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);

    a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);
    d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);
    c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);
    b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);
    a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);
    d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);
    c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);
    b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);
    a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);
    d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);
    c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);
    b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);
    a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);
    d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);
    c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);
    b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);

    a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);
    d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);
    c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);
    b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);
    a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);
    d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);
    c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);
    b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);
    a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);
    d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);
    c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);
    b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);
    a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);
    d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);
    c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);
    b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);

    a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);
    d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);
    c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);
    b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);
    a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);
    d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);
    c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);
    b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);
    a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);
    d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);
    c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);
    b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);
    a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);
    d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);
    c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);
    b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
  }
  return Array(a, b, c, d);

}

/*
 * These functions implement the four basic operations the algorithm uses.
 */
function md5_cmn(q, a, b, x, s, t)
{
  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);
}
function md5_ff(a, b, c, d, x, s, t)
{
  return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
}
function md5_gg(a, b, c, d, x, s, t)
{
  return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
}
function md5_hh(a, b, c, d, x, s, t)
{
  return md5_cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5_ii(a, b, c, d, x, s, t)
{
  return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function bit_rol(num, cnt)
{
  return (num << cnt) | (num >>> (32 - cnt));
}

module.exports = function md5(buf) {
  return helpers.hash(buf, core_md5, 16);
};
},{"./helpers":280}],282:[function(require,module,exports){
(function (Buffer){
var Transform = require('stream').Transform
var inherits = require('inherits')
var StringDecoder = require('string_decoder').StringDecoder
module.exports = CipherBase
inherits(CipherBase, Transform)
function CipherBase (hashMode) {
  Transform.call(this)
  this.hashMode = typeof hashMode === 'string'
  if (this.hashMode) {
    this[hashMode] = this._finalOrDigest
  } else {
    this.final = this._finalOrDigest
  }
  this._decoder = null
  this._encoding = null
}
CipherBase.prototype.update = function (data, inputEnc, outputEnc) {
  if (typeof data === 'string') {
    data = new Buffer(data, inputEnc)
  }
  var outData = this._update(data)
  if (this.hashMode) {
    return this
  }
  if (outputEnc) {
    outData = this._toString(outData, outputEnc)
  }
  return outData
}

CipherBase.prototype.setAutoPadding = function () {}

CipherBase.prototype.getAuthTag = function () {
  throw new Error('trying to get auth tag in unsupported state')
}

CipherBase.prototype.setAuthTag = function () {
  throw new Error('trying to set auth tag in unsupported state')
}

CipherBase.prototype.setAAD = function () {
  throw new Error('trying to set aad in unsupported state')
}

CipherBase.prototype._transform = function (data, _, next) {
  var err
  try {
    if (this.hashMode) {
      this._update(data)
    } else {
      this.push(this._update(data))
    }
  } catch (e) {
    err = e
  } finally {
    next(err)
  }
}
CipherBase.prototype._flush = function (done) {
  var err
  try {
    this.push(this._final())
  } catch (e) {
    err = e
  } finally {
    done(err)
  }
}
CipherBase.prototype._finalOrDigest = function (outputEnc) {
  var outData = this._final() || new Buffer('')
  if (outputEnc) {
    outData = this._toString(outData, outputEnc, true)
  }
  return outData
}

CipherBase.prototype._toString = function (value, enc, final) {
  if (!this._decoder) {
    this._decoder = new StringDecoder(enc)
    this._encoding = enc
  }
  if (this._encoding !== enc) {
    throw new Error('can\'t switch encodings')
  }
  var out = this._decoder.write(value)
  if (final) {
    out += this._decoder.end()
  }
  return out
}

}).call(this,require("buffer").Buffer)

},{"buffer":151,"inherits":348,"stream":365,"string_decoder":366}],283:[function(require,module,exports){
(function (Buffer){
/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
/** @preserve
(c) 2012 by Cédric Mesnil. All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// constants table
var zl = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
]

var zr = [
  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
]

var sl = [
  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
]

var sr = [
  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
]

var hl = [0x00000000, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xA953FD4E]
var hr = [0x50A28BE6, 0x5C4DD124, 0x6D703EF3, 0x7A6D76E9, 0x00000000]

function bytesToWords (bytes) {
  var words = []
  for (var i = 0, b = 0; i < bytes.length; i++, b += 8) {
    words[b >>> 5] |= bytes[i] << (24 - b % 32)
  }
  return words
}

function wordsToBytes (words) {
  var bytes = []
  for (var b = 0; b < words.length * 32; b += 8) {
    bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF)
  }
  return bytes
}

function processBlock (H, M, offset) {
  // swap endian
  for (var i = 0; i < 16; i++) {
    var offset_i = offset + i
    var M_offset_i = M[offset_i]

    // Swap
    M[offset_i] = (
      (((M_offset_i << 8) | (M_offset_i >>> 24)) & 0x00ff00ff) |
      (((M_offset_i << 24) | (M_offset_i >>> 8)) & 0xff00ff00)
    )
  }

  // Working variables
  var al, bl, cl, dl, el
  var ar, br, cr, dr, er

  ar = al = H[0]
  br = bl = H[1]
  cr = cl = H[2]
  dr = dl = H[3]
  er = el = H[4]

  // computation
  var t
  for (i = 0; i < 80; i += 1) {
    t = (al + M[offset + zl[i]]) | 0
    if (i < 16) {
      t += f1(bl, cl, dl) + hl[0]
    } else if (i < 32) {
      t += f2(bl, cl, dl) + hl[1]
    } else if (i < 48) {
      t += f3(bl, cl, dl) + hl[2]
    } else if (i < 64) {
      t += f4(bl, cl, dl) + hl[3]
    } else {// if (i<80) {
      t += f5(bl, cl, dl) + hl[4]
    }
    t = t | 0
    t = rotl(t, sl[i])
    t = (t + el) | 0
    al = el
    el = dl
    dl = rotl(cl, 10)
    cl = bl
    bl = t

    t = (ar + M[offset + zr[i]]) | 0
    if (i < 16) {
      t += f5(br, cr, dr) + hr[0]
    } else if (i < 32) {
      t += f4(br, cr, dr) + hr[1]
    } else if (i < 48) {
      t += f3(br, cr, dr) + hr[2]
    } else if (i < 64) {
      t += f2(br, cr, dr) + hr[3]
    } else {// if (i<80) {
      t += f1(br, cr, dr) + hr[4]
    }

    t = t | 0
    t = rotl(t, sr[i])
    t = (t + er) | 0
    ar = er
    er = dr
    dr = rotl(cr, 10)
    cr = br
    br = t
  }

  // intermediate hash value
  t = (H[1] + cl + dr) | 0
  H[1] = (H[2] + dl + er) | 0
  H[2] = (H[3] + el + ar) | 0
  H[3] = (H[4] + al + br) | 0
  H[4] = (H[0] + bl + cr) | 0
  H[0] = t
}

function f1 (x, y, z) {
  return ((x) ^ (y) ^ (z))
}

function f2 (x, y, z) {
  return (((x) & (y)) | ((~x) & (z)))
}

function f3 (x, y, z) {
  return (((x) | (~(y))) ^ (z))
}

function f4 (x, y, z) {
  return (((x) & (z)) | ((y) & (~(z))))
}

function f5 (x, y, z) {
  return ((x) ^ ((y) | (~(z))))
}

function rotl (x, n) {
  return (x << n) | (x >>> (32 - n))
}

function ripemd160 (message) {
  var H = [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0]

  if (typeof message === 'string') {
    message = new Buffer(message, 'utf8')
  }

  var m = bytesToWords(message)

  var nBitsLeft = message.length * 8
  var nBitsTotal = message.length * 8

  // Add padding
  m[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32)
  m[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
    (((nBitsTotal << 8) | (nBitsTotal >>> 24)) & 0x00ff00ff) |
    (((nBitsTotal << 24) | (nBitsTotal >>> 8)) & 0xff00ff00)
  )

  for (var i = 0; i < m.length; i += 16) {
    processBlock(H, m, i)
  }

  // swap endian
  for (i = 0; i < 5; i++) {
    // shortcut
    var H_i = H[i]

    // Swap
    H[i] = (((H_i << 8) | (H_i >>> 24)) & 0x00ff00ff) |
      (((H_i << 24) | (H_i >>> 8)) & 0xff00ff00)
  }

  var digestbytes = wordsToBytes(H)
  return new Buffer(digestbytes)
}

module.exports = ripemd160

}).call(this,require("buffer").Buffer)

},{"buffer":151}],284:[function(require,module,exports){
(function (Buffer){
// prototype class for hash functions
function Hash (blockSize, finalSize) {
  this._block = new Buffer(blockSize)
  this._finalSize = finalSize
  this._blockSize = blockSize
  this._len = 0
  this._s = 0
}

Hash.prototype.update = function (data, enc) {
  if (typeof data === 'string') {
    enc = enc || 'utf8'
    data = new Buffer(data, enc)
  }

  var l = this._len += data.length
  var s = this._s || 0
  var f = 0
  var buffer = this._block

  while (s < l) {
    var t = Math.min(data.length, f + this._blockSize - (s % this._blockSize))
    var ch = (t - f)

    for (var i = 0; i < ch; i++) {
      buffer[(s % this._blockSize) + i] = data[i + f]
    }

    s += ch
    f += ch

    if ((s % this._blockSize) === 0) {
      this._update(buffer)
    }
  }
  this._s = s

  return this
}

Hash.prototype.digest = function (enc) {
  // Suppose the length of the message M, in bits, is l
  var l = this._len * 8

  // Append the bit 1 to the end of the message
  this._block[this._len % this._blockSize] = 0x80

  // and then k zero bits, where k is the smallest non-negative solution to the equation (l + 1 + k) === finalSize mod blockSize
  this._block.fill(0, this._len % this._blockSize + 1)

  if (l % (this._blockSize * 8) >= this._finalSize * 8) {
    this._update(this._block)
    this._block.fill(0)
  }

  // to this append the block which is equal to the number l written in binary
  // TODO: handle case where l is > Math.pow(2, 29)
  this._block.writeInt32BE(l, this._blockSize - 4)

  var hash = this._update(this._block) || this._hash()

  return enc ? hash.toString(enc) : hash
}

Hash.prototype._update = function () {
  throw new Error('_update must be implemented by subclass')
}

module.exports = Hash

}).call(this,require("buffer").Buffer)

},{"buffer":151}],285:[function(require,module,exports){
var exports = module.exports = function SHA (algorithm) {
  algorithm = algorithm.toLowerCase()

  var Algorithm = exports[algorithm]
  if (!Algorithm) throw new Error(algorithm + ' is not supported (we accept pull requests)')

  return new Algorithm()
}

exports.sha = require('./sha')
exports.sha1 = require('./sha1')
exports.sha224 = require('./sha224')
exports.sha256 = require('./sha256')
exports.sha384 = require('./sha384')
exports.sha512 = require('./sha512')

},{"./sha":286,"./sha1":287,"./sha224":288,"./sha256":289,"./sha384":290,"./sha512":291}],286:[function(require,module,exports){
(function (Buffer){
/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-0, as defined
 * in FIPS PUB 180-1
 * This source code is derived from sha1.js of the same repository.
 * The difference between SHA-0 and SHA-1 is just a bitwise rotate left
 * operation was added.
 */

var inherits = require('inherits')
var Hash = require('./hash')

var W = new Array(80)

function Sha () {
  this.init()
  this._w = W

  Hash.call(this, 64, 56)
}

inherits(Sha, Hash)

Sha.prototype.init = function () {
  this._a = 0x67452301 | 0
  this._b = 0xefcdab89 | 0
  this._c = 0x98badcfe | 0
  this._d = 0x10325476 | 0
  this._e = 0xc3d2e1f0 | 0

  return this
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function rol (num, cnt) {
  return (num << cnt) | (num >>> (32 - cnt))
}

Sha.prototype._update = function (M) {
  var W = this._w

  var a = this._a
  var b = this._b
  var c = this._c
  var d = this._d
  var e = this._e

  var j = 0
  var k

  /*
   * SHA-1 has a bitwise rotate left operation. But, SHA is not
   * function calcW() { return rol(W[j - 3] ^ W[j -  8] ^ W[j - 14] ^ W[j - 16], 1) }
   */
  function calcW () { return W[j - 3] ^ W[j - 8] ^ W[j - 14] ^ W[j - 16] }
  function loop (w, f) {
    W[j] = w

    var t = rol(a, 5) + f + e + w + k

    e = d
    d = c
    c = rol(b, 30)
    b = a
    a = t
    j++
  }

  k = 1518500249
  while (j < 16) loop(M.readInt32BE(j * 4), (b & c) | ((~b) & d))
  while (j < 20) loop(calcW(), (b & c) | ((~b) & d))
  k = 1859775393
  while (j < 40) loop(calcW(), b ^ c ^ d)
  k = -1894007588
  while (j < 60) loop(calcW(), (b & c) | (b & d) | (c & d))
  k = -899497514
  while (j < 80) loop(calcW(), b ^ c ^ d)

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
}

Sha.prototype._hash = function () {
  var H = new Buffer(20)

  H.writeInt32BE(this._a | 0, 0)
  H.writeInt32BE(this._b | 0, 4)
  H.writeInt32BE(this._c | 0, 8)
  H.writeInt32BE(this._d | 0, 12)
  H.writeInt32BE(this._e | 0, 16)

  return H
}

module.exports = Sha


}).call(this,require("buffer").Buffer)

},{"./hash":284,"buffer":151,"inherits":348}],287:[function(require,module,exports){
(function (Buffer){
/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

var inherits = require('inherits')
var Hash = require('./hash')

var W = new Array(80)

function Sha1 () {
  this.init()
  this._w = W

  Hash.call(this, 64, 56)
}

inherits(Sha1, Hash)

Sha1.prototype.init = function () {
  this._a = 0x67452301 | 0
  this._b = 0xefcdab89 | 0
  this._c = 0x98badcfe | 0
  this._d = 0x10325476 | 0
  this._e = 0xc3d2e1f0 | 0

  return this
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function rol (num, cnt) {
  return (num << cnt) | (num >>> (32 - cnt))
}

Sha1.prototype._update = function (M) {
  var W = this._w

  var a = this._a
  var b = this._b
  var c = this._c
  var d = this._d
  var e = this._e

  var j = 0
  var k

  function calcW () { return rol(W[j - 3] ^ W[j - 8] ^ W[j - 14] ^ W[j - 16], 1) }
  function loop (w, f) {
    W[j] = w

    var t = rol(a, 5) + f + e + w + k

    e = d
    d = c
    c = rol(b, 30)
    b = a
    a = t
    j++
  }

  k = 1518500249
  while (j < 16) loop(M.readInt32BE(j * 4), (b & c) | ((~b) & d))
  while (j < 20) loop(calcW(), (b & c) | ((~b) & d))
  k = 1859775393
  while (j < 40) loop(calcW(), b ^ c ^ d)
  k = -1894007588
  while (j < 60) loop(calcW(), (b & c) | (b & d) | (c & d))
  k = -899497514
  while (j < 80) loop(calcW(), b ^ c ^ d)

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
}

Sha1.prototype._hash = function () {
  var H = new Buffer(20)

  H.writeInt32BE(this._a | 0, 0)
  H.writeInt32BE(this._b | 0, 4)
  H.writeInt32BE(this._c | 0, 8)
  H.writeInt32BE(this._d | 0, 12)
  H.writeInt32BE(this._e | 0, 16)

  return H
}

module.exports = Sha1

}).call(this,require("buffer").Buffer)

},{"./hash":284,"buffer":151,"inherits":348}],288:[function(require,module,exports){
(function (Buffer){
/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = require('inherits')
var Sha256 = require('./sha256')
var Hash = require('./hash')

var W = new Array(64)

function Sha224 () {
  this.init()

  this._w = W // new Array(64)

  Hash.call(this, 64, 56)
}

inherits(Sha224, Sha256)

Sha224.prototype.init = function () {
  this._a = 0xc1059ed8 | 0
  this._b = 0x367cd507 | 0
  this._c = 0x3070dd17 | 0
  this._d = 0xf70e5939 | 0
  this._e = 0xffc00b31 | 0
  this._f = 0x68581511 | 0
  this._g = 0x64f98fa7 | 0
  this._h = 0xbefa4fa4 | 0

  return this
}

Sha224.prototype._hash = function () {
  var H = new Buffer(28)

  H.writeInt32BE(this._a, 0)
  H.writeInt32BE(this._b, 4)
  H.writeInt32BE(this._c, 8)
  H.writeInt32BE(this._d, 12)
  H.writeInt32BE(this._e, 16)
  H.writeInt32BE(this._f, 20)
  H.writeInt32BE(this._g, 24)

  return H
}

module.exports = Sha224

}).call(this,require("buffer").Buffer)

},{"./hash":284,"./sha256":289,"buffer":151,"inherits":348}],289:[function(require,module,exports){
(function (Buffer){
/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = require('inherits')
var Hash = require('./hash')

var K = [
  0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
  0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
  0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
  0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
  0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
  0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
  0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
  0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
  0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
  0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
  0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
  0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
  0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
  0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
  0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
  0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
]

var W = new Array(64)

function Sha256 () {
  this.init()

  this._w = W // new Array(64)

  Hash.call(this, 64, 56)
}

inherits(Sha256, Hash)

Sha256.prototype.init = function () {
  this._a = 0x6a09e667 | 0
  this._b = 0xbb67ae85 | 0
  this._c = 0x3c6ef372 | 0
  this._d = 0xa54ff53a | 0
  this._e = 0x510e527f | 0
  this._f = 0x9b05688c | 0
  this._g = 0x1f83d9ab | 0
  this._h = 0x5be0cd19 | 0

  return this
}

function Ch (x, y, z) {
  return z ^ (x & (y ^ z))
}

function Maj (x, y, z) {
  return (x & y) | (z & (x | y))
}

function Sigma0 (x) {
  return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10)
}

function Sigma1 (x) {
  return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7)
}

function Gamma0 (x) {
  return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ (x >>> 3)
}

function Gamma1 (x) {
  return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ (x >>> 10)
}

Sha256.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0
  var f = this._f | 0
  var g = this._g | 0
  var h = this._h | 0

  var j = 0

  function calcW () { return Gamma1(W[j - 2]) + W[j - 7] + Gamma0(W[j - 15]) + W[j - 16] }
  function loop (w) {
    W[j] = w

    var T1 = h + Sigma1(e) + Ch(e, f, g) + K[j] + w
    var T2 = Sigma0(a) + Maj(a, b, c)

    h = g
    g = f
    f = e
    e = d + T1
    d = c
    c = b
    b = a
    a = T1 + T2

    j++
  }

  while (j < 16) loop(M.readInt32BE(j * 4))
  while (j < 64) loop(calcW())

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
  this._f = (f + this._f) | 0
  this._g = (g + this._g) | 0
  this._h = (h + this._h) | 0
}

Sha256.prototype._hash = function () {
  var H = new Buffer(32)

  H.writeInt32BE(this._a, 0)
  H.writeInt32BE(this._b, 4)
  H.writeInt32BE(this._c, 8)
  H.writeInt32BE(this._d, 12)
  H.writeInt32BE(this._e, 16)
  H.writeInt32BE(this._f, 20)
  H.writeInt32BE(this._g, 24)
  H.writeInt32BE(this._h, 28)

  return H
}

module.exports = Sha256

}).call(this,require("buffer").Buffer)

},{"./hash":284,"buffer":151,"inherits":348}],290:[function(require,module,exports){
(function (Buffer){
var inherits = require('inherits')
var SHA512 = require('./sha512')
var Hash = require('./hash')

var W = new Array(160)

function Sha384 () {
  this.init()
  this._w = W

  Hash.call(this, 128, 112)
}

inherits(Sha384, SHA512)

Sha384.prototype.init = function () {
  this._a = 0xcbbb9d5d | 0
  this._b = 0x629a292a | 0
  this._c = 0x9159015a | 0
  this._d = 0x152fecd8 | 0
  this._e = 0x67332667 | 0
  this._f = 0x8eb44a87 | 0
  this._g = 0xdb0c2e0d | 0
  this._h = 0x47b5481d | 0

  this._al = 0xc1059ed8 | 0
  this._bl = 0x367cd507 | 0
  this._cl = 0x3070dd17 | 0
  this._dl = 0xf70e5939 | 0
  this._el = 0xffc00b31 | 0
  this._fl = 0x68581511 | 0
  this._gl = 0x64f98fa7 | 0
  this._hl = 0xbefa4fa4 | 0

  return this
}

Sha384.prototype._hash = function () {
  var H = new Buffer(48)

  function writeInt64BE (h, l, offset) {
    H.writeInt32BE(h, offset)
    H.writeInt32BE(l, offset + 4)
  }

  writeInt64BE(this._a, this._al, 0)
  writeInt64BE(this._b, this._bl, 8)
  writeInt64BE(this._c, this._cl, 16)
  writeInt64BE(this._d, this._dl, 24)
  writeInt64BE(this._e, this._el, 32)
  writeInt64BE(this._f, this._fl, 40)

  return H
}

module.exports = Sha384

}).call(this,require("buffer").Buffer)

},{"./hash":284,"./sha512":291,"buffer":151,"inherits":348}],291:[function(require,module,exports){
(function (Buffer){
var inherits = require('inherits')
var Hash = require('./hash')

var K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
]

var W = new Array(160)

function Sha512 () {
  this.init()
  this._w = W

  Hash.call(this, 128, 112)
}

inherits(Sha512, Hash)

Sha512.prototype.init = function () {
  this._a = 0x6a09e667 | 0
  this._b = 0xbb67ae85 | 0
  this._c = 0x3c6ef372 | 0
  this._d = 0xa54ff53a | 0
  this._e = 0x510e527f | 0
  this._f = 0x9b05688c | 0
  this._g = 0x1f83d9ab | 0
  this._h = 0x5be0cd19 | 0

  this._al = 0xf3bcc908 | 0
  this._bl = 0x84caa73b | 0
  this._cl = 0xfe94f82b | 0
  this._dl = 0x5f1d36f1 | 0
  this._el = 0xade682d1 | 0
  this._fl = 0x2b3e6c1f | 0
  this._gl = 0xfb41bd6b | 0
  this._hl = 0x137e2179 | 0

  return this
}

function Ch (x, y, z) {
  return z ^ (x & (y ^ z))
}

function Maj (x, y, z) {
  return (x & y) | (z & (x | y))
}

function Sigma0 (x, xl) {
  return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25)
}

function Sigma1 (x, xl) {
  return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23)
}

function Gamma0 (x, xl) {
  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7)
}

function Gamma0l (x, xl) {
  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25)
}

function Gamma1 (x, xl) {
  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6)
}

function Gamma1l (x, xl) {
  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26)
}

Sha512.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0
  var f = this._f | 0
  var g = this._g | 0
  var h = this._h | 0

  var al = this._al | 0
  var bl = this._bl | 0
  var cl = this._cl | 0
  var dl = this._dl | 0
  var el = this._el | 0
  var fl = this._fl | 0
  var gl = this._gl | 0
  var hl = this._hl | 0

  var i = 0
  var j = 0
  var Wi, Wil
  function calcW () {
    var x = W[j - 15 * 2]
    var xl = W[j - 15 * 2 + 1]
    var gamma0 = Gamma0(x, xl)
    var gamma0l = Gamma0l(xl, x)

    x = W[j - 2 * 2]
    xl = W[j - 2 * 2 + 1]
    var gamma1 = Gamma1(x, xl)
    var gamma1l = Gamma1l(xl, x)

    // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
    var Wi7 = W[j - 7 * 2]
    var Wi7l = W[j - 7 * 2 + 1]

    var Wi16 = W[j - 16 * 2]
    var Wi16l = W[j - 16 * 2 + 1]

    Wil = gamma0l + Wi7l
    Wi = gamma0 + Wi7 + ((Wil >>> 0) < (gamma0l >>> 0) ? 1 : 0)
    Wil = Wil + gamma1l
    Wi = Wi + gamma1 + ((Wil >>> 0) < (gamma1l >>> 0) ? 1 : 0)
    Wil = Wil + Wi16l
    Wi = Wi + Wi16 + ((Wil >>> 0) < (Wi16l >>> 0) ? 1 : 0)
  }

  function loop () {
    W[j] = Wi
    W[j + 1] = Wil

    var maj = Maj(a, b, c)
    var majl = Maj(al, bl, cl)

    var sigma0h = Sigma0(a, al)
    var sigma0l = Sigma0(al, a)
    var sigma1h = Sigma1(e, el)
    var sigma1l = Sigma1(el, e)

    // t1 = h + sigma1 + ch + K[i] + W[i]
    var Ki = K[j]
    var Kil = K[j + 1]

    var ch = Ch(e, f, g)
    var chl = Ch(el, fl, gl)

    var t1l = hl + sigma1l
    var t1 = h + sigma1h + ((t1l >>> 0) < (hl >>> 0) ? 1 : 0)
    t1l = t1l + chl
    t1 = t1 + ch + ((t1l >>> 0) < (chl >>> 0) ? 1 : 0)
    t1l = t1l + Kil
    t1 = t1 + Ki + ((t1l >>> 0) < (Kil >>> 0) ? 1 : 0)
    t1l = t1l + Wil
    t1 = t1 + Wi + ((t1l >>> 0) < (Wil >>> 0) ? 1 : 0)

    // t2 = sigma0 + maj
    var t2l = sigma0l + majl
    var t2 = sigma0h + maj + ((t2l >>> 0) < (sigma0l >>> 0) ? 1 : 0)

    h = g
    hl = gl
    g = f
    gl = fl
    f = e
    fl = el
    el = (dl + t1l) | 0
    e = (d + t1 + ((el >>> 0) < (dl >>> 0) ? 1 : 0)) | 0
    d = c
    dl = cl
    c = b
    cl = bl
    b = a
    bl = al
    al = (t1l + t2l) | 0
    a = (t1 + t2 + ((al >>> 0) < (t1l >>> 0) ? 1 : 0)) | 0

    i++
    j += 2
  }

  while (i < 16) {
    Wi = M.readInt32BE(j * 4)
    Wil = M.readInt32BE(j * 4 + 4)

    loop()
  }

  while (i < 80) {
    calcW()
    loop()
  }

  this._al = (this._al + al) | 0
  this._bl = (this._bl + bl) | 0
  this._cl = (this._cl + cl) | 0
  this._dl = (this._dl + dl) | 0
  this._el = (this._el + el) | 0
  this._fl = (this._fl + fl) | 0
  this._gl = (this._gl + gl) | 0
  this._hl = (this._hl + hl) | 0

  this._a = (this._a + a + ((this._al >>> 0) < (al >>> 0) ? 1 : 0)) | 0
  this._b = (this._b + b + ((this._bl >>> 0) < (bl >>> 0) ? 1 : 0)) | 0
  this._c = (this._c + c + ((this._cl >>> 0) < (cl >>> 0) ? 1 : 0)) | 0
  this._d = (this._d + d + ((this._dl >>> 0) < (dl >>> 0) ? 1 : 0)) | 0
  this._e = (this._e + e + ((this._el >>> 0) < (el >>> 0) ? 1 : 0)) | 0
  this._f = (this._f + f + ((this._fl >>> 0) < (fl >>> 0) ? 1 : 0)) | 0
  this._g = (this._g + g + ((this._gl >>> 0) < (gl >>> 0) ? 1 : 0)) | 0
  this._h = (this._h + h + ((this._hl >>> 0) < (hl >>> 0) ? 1 : 0)) | 0
}

Sha512.prototype._hash = function () {
  var H = new Buffer(64)

  function writeInt64BE (h, l, offset) {
    H.writeInt32BE(h, offset)
    H.writeInt32BE(l, offset + 4)
  }

  writeInt64BE(this._a, this._al, 0)
  writeInt64BE(this._b, this._bl, 8)
  writeInt64BE(this._c, this._cl, 16)
  writeInt64BE(this._d, this._dl, 24)
  writeInt64BE(this._e, this._el, 32)
  writeInt64BE(this._f, this._fl, 40)
  writeInt64BE(this._g, this._gl, 48)
  writeInt64BE(this._h, this._hl, 56)

  return H
}

module.exports = Sha512

}).call(this,require("buffer").Buffer)

},{"./hash":284,"buffer":151,"inherits":348}],292:[function(require,module,exports){
(function (Buffer){
'use strict';
var createHash = require('create-hash/browser');
var inherits = require('inherits')

var Transform = require('stream').Transform

var ZEROS = new Buffer(128)
ZEROS.fill(0)

function Hmac(alg, key) {
  Transform.call(this)
  alg = alg.toLowerCase()
  if (typeof key === 'string') {
    key = new Buffer(key)
  }

  var blocksize = (alg === 'sha512' || alg === 'sha384') ? 128 : 64

  this._alg = alg
  this._key = key

  if (key.length > blocksize) {
    key = createHash(alg).update(key).digest()

  } else if (key.length < blocksize) {
    key = Buffer.concat([key, ZEROS], blocksize)
  }

  var ipad = this._ipad = new Buffer(blocksize)
  var opad = this._opad = new Buffer(blocksize)

  for (var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36
    opad[i] = key[i] ^ 0x5C
  }

  this._hash = createHash(alg).update(ipad)
}

inherits(Hmac, Transform)

Hmac.prototype.update = function (data, enc) {
  this._hash.update(data, enc)

  return this
}

Hmac.prototype._transform = function (data, _, next) {
  this._hash.update(data)

  next()
}

Hmac.prototype._flush = function (next) {
  this.push(this.digest())

  next()
}

Hmac.prototype.digest = function (enc) {
  var h = this._hash.digest()

  return createHash(this._alg).update(this._opad).update(h).digest(enc)
}

module.exports = function createHmac(alg, key) {
  return new Hmac(alg, key)
}

}).call(this,require("buffer").Buffer)

},{"buffer":151,"create-hash/browser":279,"inherits":348,"stream":365}],293:[function(require,module,exports){
(function (Buffer){
var generatePrime = require('./lib/generatePrime');
var primes = require('./lib/primes');

var DH = require('./lib/dh');

function getDiffieHellman(mod) {
  var prime = new Buffer(primes[mod].prime, 'hex');
  var gen = new Buffer(primes[mod].gen, 'hex');

  return new DH(prime, gen);
}

function createDiffieHellman(prime, enc, generator, genc) {
  if (Buffer.isBuffer(enc) || (typeof enc === 'string' && ['hex', 'binary', 'base64'].indexOf(enc) === -1)) {
    genc = generator;
    generator = enc;
    enc = undefined;
  }

  enc = enc || 'binary';
  genc = genc || 'binary';
  generator = generator || new Buffer([2]);

  if (!Buffer.isBuffer(generator)) {
    generator = new Buffer(generator, genc);
  }

  if (typeof prime === 'number') {
    return new DH(generatePrime(prime, generator), generator, true);
  }

  if (!Buffer.isBuffer(prime)) {
    prime = new Buffer(prime, enc);
  }

  return new DH(prime, generator, true);
}

exports.DiffieHellmanGroup = exports.createDiffieHellmanGroup = exports.getDiffieHellman = getDiffieHellman;
exports.createDiffieHellman = exports.DiffieHellman = createDiffieHellman;

}).call(this,require("buffer").Buffer)

},{"./lib/dh":294,"./lib/generatePrime":295,"./lib/primes":296,"buffer":151}],294:[function(require,module,exports){
(function (Buffer){
var BN = require('bn.js');
var MillerRabin = require('miller-rabin');
var millerRabin = new MillerRabin();
var TWENTYFOUR = new BN(24);
var ELEVEN = new BN(11);
var TEN = new BN(10);
var THREE = new BN(3);
var SEVEN = new BN(7);
var primes = require('./generatePrime');
var randomBytes = require('randombytes');
module.exports = DH;

function setPublicKey(pub, enc) {
  enc = enc || 'utf8';
  if (!Buffer.isBuffer(pub)) {
    pub = new Buffer(pub, enc);
  }
  this._pub = new BN(pub);
  return this;
}

function setPrivateKey(priv, enc) {
  enc = enc || 'utf8';
  if (!Buffer.isBuffer(priv)) {
    priv = new Buffer(priv, enc);
  }
  this._priv = new BN(priv);
  return this;
}

var primeCache = {};
function checkPrime(prime, generator) {
  var gen = generator.toString('hex');
  var hex = [gen, prime.toString(16)].join('_');
  if (hex in primeCache) {
    return primeCache[hex];
  }
  var error = 0;

  if (prime.isEven() ||
    !primes.simpleSieve ||
    !primes.fermatTest(prime) ||
    !millerRabin.test(prime)) {
    //not a prime so +1
    error += 1;

    if (gen === '02' || gen === '05') {
      // we'd be able to check the generator
      // it would fail so +8
      error += 8;
    } else {
      //we wouldn't be able to test the generator
      // so +4
      error += 4;
    }
    primeCache[hex] = error;
    return error;
  }
  if (!millerRabin.test(prime.shrn(1))) {
    //not a safe prime
    error += 2;
  }
  var rem;
  switch (gen) {
    case '02':
      if (prime.mod(TWENTYFOUR).cmp(ELEVEN)) {
        // unsuidable generator
        error += 8;
      }
      break;
    case '05':
      rem = prime.mod(TEN);
      if (rem.cmp(THREE) && rem.cmp(SEVEN)) {
        // prime mod 10 needs to equal 3 or 7
        error += 8;
      }
      break;
    default:
      error += 4;
  }
  primeCache[hex] = error;
  return error;
}

function DH(prime, generator, malleable) {
  this.setGenerator(generator);
  this.__prime = new BN(prime);
  this._prime = BN.mont(this.__prime);
  this._primeLen = prime.length;
  this._pub = undefined;
  this._priv = undefined;
  this._primeCode = undefined;
  if (malleable) {
    this.setPublicKey = setPublicKey;
    this.setPrivateKey = setPrivateKey;
  } else {
    this._primeCode = 8;
  }
}
Object.defineProperty(DH.prototype, 'verifyError', {
  enumerable: true,
  get: function () {
    if (typeof this._primeCode !== 'number') {
      this._primeCode = checkPrime(this.__prime, this.__gen);
    }
    return this._primeCode;
  }
});
DH.prototype.generateKeys = function () {
  if (!this._priv) {
    this._priv = new BN(randomBytes(this._primeLen));
  }
  this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed();
  return this.getPublicKey();
};

DH.prototype.computeSecret = function (other) {
  other = new BN(other);
  other = other.toRed(this._prime);
  var secret = other.redPow(this._priv).fromRed();
  var out = new Buffer(secret.toArray());
  var prime = this.getPrime();
  if (out.length < prime.length) {
    var front = new Buffer(prime.length - out.length);
    front.fill(0);
    out = Buffer.concat([front, out]);
  }
  return out;
};

DH.prototype.getPublicKey = function getPublicKey(enc) {
  return formatReturnValue(this._pub, enc);
};

DH.prototype.getPrivateKey = function getPrivateKey(enc) {
  return formatReturnValue(this._priv, enc);
};

DH.prototype.getPrime = function (enc) {
  return formatReturnValue(this.__prime, enc);
};

DH.prototype.getGenerator = function (enc) {
  return formatReturnValue(this._gen, enc);
};

DH.prototype.setGenerator = function (gen, enc) {
  enc = enc || 'utf8';
  if (!Buffer.isBuffer(gen)) {
    gen = new Buffer(gen, enc);
  }
  this.__gen = gen;
  this._gen = new BN(gen);
  return this;
};

function formatReturnValue(bn, enc) {
  var buf = new Buffer(bn.toArray());
  if (!enc) {
    return buf;
  } else {
    return buf.toString(enc);
  }
}

}).call(this,require("buffer").Buffer)

},{"./generatePrime":295,"bn.js":297,"buffer":151,"miller-rabin":298,"randombytes":346}],295:[function(require,module,exports){
var randomBytes = require('randombytes');
module.exports = findPrime;
findPrime.simpleSieve = simpleSieve;
findPrime.fermatTest = fermatTest;
var BN = require('bn.js');
var TWENTYFOUR = new BN(24);
var MillerRabin = require('miller-rabin');
var millerRabin = new MillerRabin();
var ONE = new BN(1);
var TWO = new BN(2);
var FIVE = new BN(5);
var SIXTEEN = new BN(16);
var EIGHT = new BN(8);
var TEN = new BN(10);
var THREE = new BN(3);
var SEVEN = new BN(7);
var ELEVEN = new BN(11);
var FOUR = new BN(4);
var TWELVE = new BN(12);
var primes = null;

function _getPrimes() {
  if (primes !== null)
    return primes;

  var limit = 0x100000;
  var res = [];
  res[0] = 2;
  for (var i = 1, k = 3; k < limit; k += 2) {
    var sqrt = Math.ceil(Math.sqrt(k));
    for (var j = 0; j < i && res[j] <= sqrt; j++)
      if (k % res[j] === 0)
        break;

    if (i !== j && res[j] <= sqrt)
      continue;

    res[i++] = k;
  }
  primes = res;
  return res;
}

function simpleSieve(p) {
  var primes = _getPrimes();

  for (var i = 0; i < primes.length; i++)
    if (p.modn(primes[i]) === 0) {
      if (p.cmpn(primes[i]) === 0) {
        return true;
      } else {
        return false;
      }
    }

  return true;
}

function fermatTest(p) {
  var red = BN.mont(p);
  return TWO.toRed(red).redPow(p.subn(1)).fromRed().cmpn(1) === 0;
}

function findPrime(bits, gen) {
  if (bits < 16) {
    // this is what openssl does
    if (gen === 2 || gen === 5) {
      return new BN([0x8c, 0x7b]);
    } else {
      return new BN([0x8c, 0x27]);
    }
  }
  gen = new BN(gen);

  var num, n2;

  while (true) {
    num = new BN(randomBytes(Math.ceil(bits / 8)));
    while (num.bitLength() > bits) {
      num.ishrn(1);
    }
    if (num.isEven()) {
      num.iadd(ONE);
    }
    if (!num.testn(1)) {
      num.iadd(TWO);
    }
    if (!gen.cmp(TWO)) {
      while (num.mod(TWENTYFOUR).cmp(ELEVEN)) {
        num.iadd(FOUR);
      }
    } else if (!gen.cmp(FIVE)) {
      while (num.mod(TEN).cmp(THREE)) {
        num.iadd(FOUR);
      }
    }
    n2 = num.shrn(1);
    if (simpleSieve(n2) && simpleSieve(num) &&
      fermatTest(n2) && fermatTest(num) &&
      millerRabin.test(n2) && millerRabin.test(num)) {
      return num;
    }
  }

}

},{"bn.js":297,"miller-rabin":298,"randombytes":346}],296:[function(require,module,exports){
module.exports={
    "modp1": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
    },
    "modp2": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
    },
    "modp5": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
    },
    "modp14": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
    },
    "modp15": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
    },
    "modp16": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
    },
    "modp17": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
    },
    "modp18": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
    }
}
},{}],297:[function(require,module,exports){
arguments[4][188][0].apply(exports,arguments)
},{"dup":188}],298:[function(require,module,exports){
var bn = require('bn.js');
var brorand = require('brorand');

function MillerRabin(rand) {
  this.rand = rand || new brorand.Rand();
}
module.exports = MillerRabin;

MillerRabin.create = function create(rand) {
  return new MillerRabin(rand);
};

MillerRabin.prototype._rand = function _rand(n) {
  var len = n.bitLength();
  var buf = this.rand.generate(Math.ceil(len / 8));

  // Set low bits
  buf[0] |= 3;

  // Mask high bits
  var mask = len & 0x7;
  if (mask !== 0)
    buf[buf.length - 1] >>= 7 - mask;

  return new bn(buf);
}

MillerRabin.prototype.test = function test(n, k, cb) {
  var len = n.bitLength();
  var red = bn.mont(n);
  var rone = new bn(1).toRed(red);

  if (!k)
    k = Math.max(1, (len / 48) | 0);

  // Find d and s, (n - 1) = (2 ^ s) * d;
  var n1 = n.subn(1);
  var n2 = n1.subn(1);
  for (var s = 0; !n1.testn(s); s++) {}
  var d = n.shrn(s);

  var rn1 = n1.toRed(red);

  var prime = true;
  for (; k > 0; k--) {
    var a = this._rand(n2);
    if (cb)
      cb(a);

    var x = a.toRed(red).redPow(d);
    if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
      continue;

    for (var i = 1; i < s; i++) {
      x = x.redSqr();

      if (x.cmp(rone) === 0)
        return false;
      if (x.cmp(rn1) === 0)
        break;
    }

    if (i === s)
      return false;
  }

  return prime;
};

MillerRabin.prototype.getDivisor = function getDivisor(n, k) {
  var len = n.bitLength();
  var red = bn.mont(n);
  var rone = new bn(1).toRed(red);

  if (!k)
    k = Math.max(1, (len / 48) | 0);

  // Find d and s, (n - 1) = (2 ^ s) * d;
  var n1 = n.subn(1);
  var n2 = n1.subn(1);
  for (var s = 0; !n1.testn(s); s++) {}
  var d = n.shrn(s);

  var rn1 = n1.toRed(red);

  for (; k > 0; k--) {
    var a = this._rand(n2);

    var g = n.gcd(a);
    if (g.cmpn(1) !== 0)
      return g;

    var x = a.toRed(red).redPow(d);
    if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
      continue;

    for (var i = 1; i < s; i++) {
      x = x.redSqr();

      if (x.cmp(rone) === 0)
        return x.fromRed().subn(1).gcd(n);
      if (x.cmp(rn1) === 0)
        break;
    }

    if (i === s) {
      x = x.redSqr();
      return x.fromRed().subn(1).gcd(n);
    }
  }

  return false;
};

},{"bn.js":297,"brorand":299}],299:[function(require,module,exports){
arguments[4][206][0].apply(exports,arguments)
},{"dup":206}],300:[function(require,module,exports){
(function (Buffer){
var createHmac = require('create-hmac')
var MAX_ALLOC = Math.pow(2, 30) - 1 // default in iojs

exports.pbkdf2 = pbkdf2
function pbkdf2 (password, salt, iterations, keylen, digest, callback) {
  if (typeof digest === 'function') {
    callback = digest
    digest = undefined
  }

  if (typeof callback !== 'function') {
    throw new Error('No callback provided to pbkdf2')
  }

  var result = pbkdf2Sync(password, salt, iterations, keylen, digest)
  setTimeout(function () {
    callback(undefined, result)
  })
}

exports.pbkdf2Sync = pbkdf2Sync
function pbkdf2Sync (password, salt, iterations, keylen, digest) {
  if (typeof iterations !== 'number') {
    throw new TypeError('Iterations not a number')
  }

  if (iterations < 0) {
    throw new TypeError('Bad iterations')
  }

  if (typeof keylen !== 'number') {
    throw new TypeError('Key length not a number')
  }

  if (keylen < 0 || keylen > MAX_ALLOC) {
    throw new TypeError('Bad key length')
  }

  digest = digest || 'sha1'

  if (!Buffer.isBuffer(password)) password = new Buffer(password, 'binary')
  if (!Buffer.isBuffer(salt)) salt = new Buffer(salt, 'binary')

  var hLen
  var l = 1
  var DK = new Buffer(keylen)
  var block1 = new Buffer(salt.length + 4)
  salt.copy(block1, 0, 0, salt.length)

  var r
  var T

  for (var i = 1; i <= l; i++) {
    block1.writeUInt32BE(i, salt.length)
    var U = createHmac(digest, password).update(block1).digest()

    if (!hLen) {
      hLen = U.length
      T = new Buffer(hLen)
      l = Math.ceil(keylen / hLen)
      r = keylen - (l - 1) * hLen
    }

    U.copy(T, 0, 0, hLen)

    for (var j = 1; j < iterations; j++) {
      U = createHmac(digest, password).update(U).digest()

      for (var k = 0; k < hLen; k++) {
        T[k] ^= U[k]
      }
    }

    var destPos = (i - 1) * hLen
    var len = (i === l ? r : hLen)
    T.copy(DK, destPos, 0, len)
  }

  return DK
}

}).call(this,require("buffer").Buffer)

},{"buffer":151,"create-hmac":292}],301:[function(require,module,exports){
exports.publicEncrypt = require('./publicEncrypt');
exports.privateDecrypt = require('./privateDecrypt');

exports.privateEncrypt = function privateEncrypt(key, buf) {
  return exports.publicEncrypt(key, buf, true);
};

exports.publicDecrypt = function publicDecrypt(key, buf) {
  return exports.privateDecrypt(key, buf, true);
};
},{"./privateDecrypt":342,"./publicEncrypt":343}],302:[function(require,module,exports){
(function (Buffer){
var createHash = require('create-hash');
module.exports = function (seed, len) {
  var t = new Buffer('');
  var  i = 0, c;
  while (t.length < len) {
    c = i2ops(i++);
    t = Buffer.concat([t, createHash('sha1').update(seed).update(c).digest()]);
  }
  return t.slice(0, len);
};

function i2ops(c) {
  var out = new Buffer(4);
  out.writeUInt32BE(c,0);
  return out;
}
}).call(this,require("buffer").Buffer)

},{"buffer":151,"create-hash":279}],303:[function(require,module,exports){
arguments[4][188][0].apply(exports,arguments)
},{"dup":188}],304:[function(require,module,exports){
(function (Buffer){
var bn = require('bn.js');
var randomBytes = require('randombytes');
module.exports = crt;
function blind(priv) {
  var r = getr(priv);
  var blinder = r.toRed(bn.mont(priv.modulus))
  .redPow(new bn(priv.publicExponent)).fromRed();
  return {
    blinder: blinder,
    unblinder:r.invm(priv.modulus)
  };
}
function crt(msg, priv) {
  var blinds = blind(priv);
  var len = priv.modulus.byteLength();
  var mod = bn.mont(priv.modulus);
  var blinded = new bn(msg).mul(blinds.blinder).umod(priv.modulus);
  var c1 = blinded.toRed(bn.mont(priv.prime1));
  var c2 = blinded.toRed(bn.mont(priv.prime2));
  var qinv = priv.coefficient;
  var p = priv.prime1;
  var q = priv.prime2;
  var m1 = c1.redPow(priv.exponent1);
  var m2 = c2.redPow(priv.exponent2);
  m1 = m1.fromRed();
  m2 = m2.fromRed();
  var h = m1.isub(m2).imul(qinv).umod(p);
  h.imul(q);
  m2.iadd(h);
  return new Buffer(m2.imul(blinds.unblinder).umod(priv.modulus).toArray(false, len));
}
crt.getr = getr;
function getr(priv) {
  var len = priv.modulus.byteLength();
  var r = new bn(randomBytes(len));
  while (r.cmp(priv.modulus) >=  0 || !r.umod(priv.prime1) || !r.umod(priv.prime2)) {
    r = new bn(randomBytes(len));
  }
  return r;
}

}).call(this,require("buffer").Buffer)

},{"bn.js":303,"buffer":151,"randombytes":346}],305:[function(require,module,exports){
arguments[4][214][0].apply(exports,arguments)
},{"dup":214}],306:[function(require,module,exports){
arguments[4][215][0].apply(exports,arguments)
},{"asn1.js":309,"dup":215}],307:[function(require,module,exports){
(function (Buffer){
// adapted from https://github.com/apatil/pemstrip
var findProc = /Proc-Type: 4,ENCRYPTED\r?\nDEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)\r?\n\r?\n([0-9A-z\n\r\+\/\=]+)\r?\n/m
var startRegex = /^-----BEGIN (.*) KEY-----\r?\n/m
var fullRegex = /^-----BEGIN (.*) KEY-----\r?\n([0-9A-z\n\r\+\/\=]+)\r?\n-----END \1 KEY-----$/m
var evp = require('evp_bytestokey')
var ciphers = require('browserify-aes')
module.exports = function (okey, password) {
  var key = okey.toString()
  var match = key.match(findProc)
  var decrypted
  if (!match) {
    var match2 = key.match(fullRegex)
    decrypted = new Buffer(match2[2].replace(/\r?\n/g, ''), 'base64')
  } else {
    var suite = 'aes' + match[1]
    var iv = new Buffer(match[2], 'hex')
    var cipherText = new Buffer(match[3].replace(/\r?\n/g, ''), 'base64')
    var cipherKey = evp(password, iv.slice(0, 8), parseInt(match[1], 10)).key
    var out = []
    var cipher = ciphers.createDecipheriv(suite, cipherKey, iv)
    out.push(cipher.update(cipherText))
    out.push(cipher.final())
    decrypted = Buffer.concat(out)
  }
  var tag = key.match(startRegex)[1] + ' KEY'
  return {
    tag: tag,
    data: decrypted
  }
}

}).call(this,require("buffer").Buffer)

},{"browserify-aes":326,"buffer":151,"evp_bytestokey":341}],308:[function(require,module,exports){
(function (Buffer){
var asn1 = require('./asn1')
var aesid = require('./aesid.json')
var fixProc = require('./fixProc')
var ciphers = require('browserify-aes')
var compat = require('pbkdf2')
module.exports = parseKeys

function parseKeys (buffer) {
  var password
  if (typeof buffer === 'object' && !Buffer.isBuffer(buffer)) {
    password = buffer.passphrase
    buffer = buffer.key
  }
  if (typeof buffer === 'string') {
    buffer = new Buffer(buffer)
  }

  var stripped = fixProc(buffer, password)

  var type = stripped.tag
  var data = stripped.data
  var subtype, ndata
  switch (type) {
    case 'PUBLIC KEY':
      ndata = asn1.PublicKey.decode(data, 'der')
      subtype = ndata.algorithm.algorithm.join('.')
      switch (subtype) {
        case '1.2.840.113549.1.1.1':
          return asn1.RSAPublicKey.decode(ndata.subjectPublicKey.data, 'der')
        case '1.2.840.10045.2.1':
          ndata.subjectPrivateKey = ndata.subjectPublicKey
          return {
            type: 'ec',
            data: ndata
          }
        case '1.2.840.10040.4.1':
          ndata.algorithm.params.pub_key = asn1.DSAparam.decode(ndata.subjectPublicKey.data, 'der')
          return {
            type: 'dsa',
            data: ndata.algorithm.params
          }
        default: throw new Error('unknown key id ' + subtype)
      }
      throw new Error('unknown key type ' + type)
    case 'ENCRYPTED PRIVATE KEY':
      data = asn1.EncryptedPrivateKey.decode(data, 'der')
      data = decrypt(data, password)
      // falls through
    case 'PRIVATE KEY':
      ndata = asn1.PrivateKey.decode(data, 'der')
      subtype = ndata.algorithm.algorithm.join('.')
      switch (subtype) {
        case '1.2.840.113549.1.1.1':
          return asn1.RSAPrivateKey.decode(ndata.subjectPrivateKey, 'der')
        case '1.2.840.10045.2.1':
          return {
            curve: ndata.algorithm.curve,
            privateKey: asn1.ECPrivateKey.decode(ndata.subjectPrivateKey, 'der').privateKey
          }
        case '1.2.840.10040.4.1':
          ndata.algorithm.params.priv_key = asn1.DSAparam.decode(ndata.subjectPrivateKey, 'der')
          return {
            type: 'dsa',
            params: ndata.algorithm.params
          }
        default: throw new Error('unknown key id ' + subtype)
      }
      throw new Error('unknown key type ' + type)
    case 'RSA PUBLIC KEY':
      return asn1.RSAPublicKey.decode(data, 'der')
    case 'RSA PRIVATE KEY':
      return asn1.RSAPrivateKey.decode(data, 'der')
    case 'DSA PRIVATE KEY':
      return {
        type: 'dsa',
        params: asn1.DSAPrivateKey.decode(data, 'der')
      }
    case 'EC PRIVATE KEY':
      data = asn1.ECPrivateKey.decode(data, 'der')
      return {
        curve: data.parameters.value,
        privateKey: data.privateKey
      }
    default: throw new Error('unknown key type ' + type)
  }
}
parseKeys.signature = asn1.signature
function decrypt (data, password) {
  var salt = data.algorithm.decrypt.kde.kdeparams.salt
  var iters = parseInt(data.algorithm.decrypt.kde.kdeparams.iters.toString(), 10)
  var algo = aesid[data.algorithm.decrypt.cipher.algo.join('.')]
  var iv = data.algorithm.decrypt.cipher.iv
  var cipherText = data.subjectPrivateKey
  var keylen = parseInt(algo.split('-')[1], 10) / 8
  var key = compat.pbkdf2Sync(password, salt, iters, keylen)
  var cipher = ciphers.createDecipheriv(algo, key, iv)
  var out = []
  out.push(cipher.update(cipherText))
  out.push(cipher.final())
  return Buffer.concat(out)
}

}).call(this,require("buffer").Buffer)

},{"./aesid.json":305,"./asn1":306,"./fixProc":307,"browserify-aes":326,"buffer":151,"pbkdf2":300}],309:[function(require,module,exports){
arguments[4][218][0].apply(exports,arguments)
},{"./asn1/api":310,"./asn1/base":312,"./asn1/constants":316,"./asn1/decoders":318,"./asn1/encoders":321,"bn.js":303,"dup":218}],310:[function(require,module,exports){
arguments[4][219][0].apply(exports,arguments)
},{"../asn1":309,"dup":219,"inherits":348,"vm":367}],311:[function(require,module,exports){
arguments[4][220][0].apply(exports,arguments)
},{"../base":312,"buffer":151,"dup":220,"inherits":348}],312:[function(require,module,exports){
arguments[4][221][0].apply(exports,arguments)
},{"./buffer":311,"./node":313,"./reporter":314,"dup":221}],313:[function(require,module,exports){
arguments[4][222][0].apply(exports,arguments)
},{"../base":312,"dup":222,"minimalistic-assert":323}],314:[function(require,module,exports){
arguments[4][223][0].apply(exports,arguments)
},{"dup":223,"inherits":348}],315:[function(require,module,exports){
arguments[4][224][0].apply(exports,arguments)
},{"../constants":316,"dup":224}],316:[function(require,module,exports){
arguments[4][225][0].apply(exports,arguments)
},{"./der":315,"dup":225}],317:[function(require,module,exports){
arguments[4][226][0].apply(exports,arguments)
},{"../../asn1":309,"dup":226,"inherits":348}],318:[function(require,module,exports){
arguments[4][227][0].apply(exports,arguments)
},{"./der":317,"./pem":319,"dup":227}],319:[function(require,module,exports){
arguments[4][228][0].apply(exports,arguments)
},{"../../asn1":309,"./der":317,"buffer":151,"dup":228,"inherits":348}],320:[function(require,module,exports){
arguments[4][229][0].apply(exports,arguments)
},{"../../asn1":309,"buffer":151,"dup":229,"inherits":348}],321:[function(require,module,exports){
arguments[4][230][0].apply(exports,arguments)
},{"./der":320,"./pem":322,"dup":230}],322:[function(require,module,exports){
arguments[4][231][0].apply(exports,arguments)
},{"../../asn1":309,"./der":320,"buffer":151,"dup":231,"inherits":348}],323:[function(require,module,exports){
arguments[4][183][0].apply(exports,arguments)
},{"dup":183}],324:[function(require,module,exports){
(function (Buffer){
// based on the aes implimentation in triple sec
// https://github.com/keybase/triplesec

// which is in turn based on the one from crypto-js
// https://code.google.com/p/crypto-js/

var uint_max = Math.pow(2, 32)
function fixup_uint32 (x) {
  var ret, x_pos
  ret = x > uint_max || x < 0 ? (x_pos = Math.abs(x) % uint_max, x < 0 ? uint_max - x_pos : x_pos) : x
  return ret
}
function scrub_vec (v) {
  for (var i = 0; i < v.length; v++) {
    v[i] = 0
  }
  return false
}

function Global () {
  this.SBOX = []
  this.INV_SBOX = []
  this.SUB_MIX = [[], [], [], []]
  this.INV_SUB_MIX = [[], [], [], []]
  this.init()
  this.RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36]
}

Global.prototype.init = function () {
  var d, i, sx, t, x, x2, x4, x8, xi, _i
  d = (function () {
    var _i, _results
    _results = []
    for (i = _i = 0; _i < 256; i = ++_i) {
      if (i < 128) {
        _results.push(i << 1)
      } else {
        _results.push((i << 1) ^ 0x11b)
      }
    }
    return _results
  })()
  x = 0
  xi = 0
  for (i = _i = 0; _i < 256; i = ++_i) {
    sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4)
    sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63
    this.SBOX[x] = sx
    this.INV_SBOX[sx] = x
    x2 = d[x]
    x4 = d[x2]
    x8 = d[x4]
    t = (d[sx] * 0x101) ^ (sx * 0x1010100)
    this.SUB_MIX[0][x] = (t << 24) | (t >>> 8)
    this.SUB_MIX[1][x] = (t << 16) | (t >>> 16)
    this.SUB_MIX[2][x] = (t << 8) | (t >>> 24)
    this.SUB_MIX[3][x] = t
    t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100)
    this.INV_SUB_MIX[0][sx] = (t << 24) | (t >>> 8)
    this.INV_SUB_MIX[1][sx] = (t << 16) | (t >>> 16)
    this.INV_SUB_MIX[2][sx] = (t << 8) | (t >>> 24)
    this.INV_SUB_MIX[3][sx] = t
    if (x === 0) {
      x = xi = 1
    } else {
      x = x2 ^ d[d[d[x8 ^ x2]]]
      xi ^= d[d[xi]]
    }
  }
  return true
}

var G = new Global()

AES.blockSize = 4 * 4

AES.prototype.blockSize = AES.blockSize

AES.keySize = 256 / 8

AES.prototype.keySize = AES.keySize

function bufferToArray (buf) {
  var len = buf.length / 4
  var out = new Array(len)
  var i = -1
  while (++i < len) {
    out[i] = buf.readUInt32BE(i * 4)
  }
  return out
}
function AES (key) {
  this._key = bufferToArray(key)
  this._doReset()
}

AES.prototype._doReset = function () {
  var invKsRow, keySize, keyWords, ksRow, ksRows, t
  keyWords = this._key
  keySize = keyWords.length
  this._nRounds = keySize + 6
  ksRows = (this._nRounds + 1) * 4
  this._keySchedule = []
  for (ksRow = 0; ksRow < ksRows; ksRow++) {
    this._keySchedule[ksRow] = ksRow < keySize ? keyWords[ksRow] : (t = this._keySchedule[ksRow - 1], (ksRow % keySize) === 0 ? (t = (t << 8) | (t >>> 24), t = (G.SBOX[t >>> 24] << 24) | (G.SBOX[(t >>> 16) & 0xff] << 16) | (G.SBOX[(t >>> 8) & 0xff] << 8) | G.SBOX[t & 0xff], t ^= G.RCON[(ksRow / keySize) | 0] << 24) : keySize > 6 && ksRow % keySize === 4 ? t = (G.SBOX[t >>> 24] << 24) | (G.SBOX[(t >>> 16) & 0xff] << 16) | (G.SBOX[(t >>> 8) & 0xff] << 8) | G.SBOX[t & 0xff] : void 0, this._keySchedule[ksRow - keySize] ^ t)
  }
  this._invKeySchedule = []
  for (invKsRow = 0; invKsRow < ksRows; invKsRow++) {
    ksRow = ksRows - invKsRow
    t = this._keySchedule[ksRow - (invKsRow % 4 ? 0 : 4)]
    this._invKeySchedule[invKsRow] = invKsRow < 4 || ksRow <= 4 ? t : G.INV_SUB_MIX[0][G.SBOX[t >>> 24]] ^ G.INV_SUB_MIX[1][G.SBOX[(t >>> 16) & 0xff]] ^ G.INV_SUB_MIX[2][G.SBOX[(t >>> 8) & 0xff]] ^ G.INV_SUB_MIX[3][G.SBOX[t & 0xff]]
  }
  return true
}

AES.prototype.encryptBlock = function (M) {
  M = bufferToArray(new Buffer(M))
  var out = this._doCryptBlock(M, this._keySchedule, G.SUB_MIX, G.SBOX)
  var buf = new Buffer(16)
  buf.writeUInt32BE(out[0], 0)
  buf.writeUInt32BE(out[1], 4)
  buf.writeUInt32BE(out[2], 8)
  buf.writeUInt32BE(out[3], 12)
  return buf
}

AES.prototype.decryptBlock = function (M) {
  M = bufferToArray(new Buffer(M))
  var temp = [M[3], M[1]]
  M[1] = temp[0]
  M[3] = temp[1]
  var out = this._doCryptBlock(M, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX)
  var buf = new Buffer(16)
  buf.writeUInt32BE(out[0], 0)
  buf.writeUInt32BE(out[3], 4)
  buf.writeUInt32BE(out[2], 8)
  buf.writeUInt32BE(out[1], 12)
  return buf
}

AES.prototype.scrub = function () {
  scrub_vec(this._keySchedule)
  scrub_vec(this._invKeySchedule)
  scrub_vec(this._key)
}

AES.prototype._doCryptBlock = function (M, keySchedule, SUB_MIX, SBOX) {
  var ksRow, s0, s1, s2, s3, t0, t1, t2, t3

  s0 = M[0] ^ keySchedule[0]
  s1 = M[1] ^ keySchedule[1]
  s2 = M[2] ^ keySchedule[2]
  s3 = M[3] ^ keySchedule[3]
  ksRow = 4
  for (var round = 1; round < this._nRounds; round++) {
    t0 = SUB_MIX[0][s0 >>> 24] ^ SUB_MIX[1][(s1 >>> 16) & 0xff] ^ SUB_MIX[2][(s2 >>> 8) & 0xff] ^ SUB_MIX[3][s3 & 0xff] ^ keySchedule[ksRow++]
    t1 = SUB_MIX[0][s1 >>> 24] ^ SUB_MIX[1][(s2 >>> 16) & 0xff] ^ SUB_MIX[2][(s3 >>> 8) & 0xff] ^ SUB_MIX[3][s0 & 0xff] ^ keySchedule[ksRow++]
    t2 = SUB_MIX[0][s2 >>> 24] ^ SUB_MIX[1][(s3 >>> 16) & 0xff] ^ SUB_MIX[2][(s0 >>> 8) & 0xff] ^ SUB_MIX[3][s1 & 0xff] ^ keySchedule[ksRow++]
    t3 = SUB_MIX[0][s3 >>> 24] ^ SUB_MIX[1][(s0 >>> 16) & 0xff] ^ SUB_MIX[2][(s1 >>> 8) & 0xff] ^ SUB_MIX[3][s2 & 0xff] ^ keySchedule[ksRow++]
    s0 = t0
    s1 = t1
    s2 = t2
    s3 = t3
  }
  t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++]
  t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++]
  t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++]
  t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++]
  return [
    fixup_uint32(t0),
    fixup_uint32(t1),
    fixup_uint32(t2),
    fixup_uint32(t3)
  ]
}

exports.AES = AES

}).call(this,require("buffer").Buffer)

},{"buffer":151}],325:[function(require,module,exports){
(function (Buffer){
var aes = require('./aes')
var Transform = require('cipher-base')
var inherits = require('inherits')
var GHASH = require('./ghash')
var xor = require('buffer-xor')
inherits(StreamCipher, Transform)
module.exports = StreamCipher

function StreamCipher (mode, key, iv, decrypt) {
  if (!(this instanceof StreamCipher)) {
    return new StreamCipher(mode, key, iv)
  }
  Transform.call(this)
  this._finID = Buffer.concat([iv, new Buffer([0, 0, 0, 1])])
  iv = Buffer.concat([iv, new Buffer([0, 0, 0, 2])])
  this._cipher = new aes.AES(key)
  this._prev = new Buffer(iv.length)
  this._cache = new Buffer('')
  this._secCache = new Buffer('')
  this._decrypt = decrypt
  this._alen = 0
  this._len = 0
  iv.copy(this._prev)
  this._mode = mode
  var h = new Buffer(4)
  h.fill(0)
  this._ghash = new GHASH(this._cipher.encryptBlock(h))
  this._authTag = null
  this._called = false
}
StreamCipher.prototype._update = function (chunk) {
  if (!this._called && this._alen) {
    var rump = 16 - (this._alen % 16)
    if (rump < 16) {
      rump = new Buffer(rump)
      rump.fill(0)
      this._ghash.update(rump)
    }
  }
  this._called = true
  var out = this._mode.encrypt(this, chunk)
  if (this._decrypt) {
    this._ghash.update(chunk)
  } else {
    this._ghash.update(out)
  }
  this._len += chunk.length
  return out
}
StreamCipher.prototype._final = function () {
  if (this._decrypt && !this._authTag) {
    throw new Error('Unsupported state or unable to authenticate data')
  }
  var tag = xor(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID))
  if (this._decrypt) {
    if (xorTest(tag, this._authTag)) {
      throw new Error('Unsupported state or unable to authenticate data')
    }
  } else {
    this._authTag = tag
  }
  this._cipher.scrub()
}
StreamCipher.prototype.getAuthTag = function getAuthTag () {
  if (!this._decrypt && Buffer.isBuffer(this._authTag)) {
    return this._authTag
  } else {
    throw new Error('Attempting to get auth tag in unsupported state')
  }
}
StreamCipher.prototype.setAuthTag = function setAuthTag (tag) {
  if (this._decrypt) {
    this._authTag = tag
  } else {
    throw new Error('Attempting to set auth tag in unsupported state')
  }
}
StreamCipher.prototype.setAAD = function setAAD (buf) {
  if (!this._called) {
    this._ghash.update(buf)
    this._alen += buf.length
  } else {
    throw new Error('Attempting to set AAD in unsupported state')
  }
}
function xorTest (a, b) {
  var out = 0
  if (a.length !== b.length) {
    out++
  }
  var len = Math.min(a.length, b.length)
  var i = -1
  while (++i < len) {
    out += (a[i] ^ b[i])
  }
  return out
}

}).call(this,require("buffer").Buffer)

},{"./aes":324,"./ghash":329,"buffer":151,"buffer-xor":338,"cipher-base":339,"inherits":348}],326:[function(require,module,exports){
arguments[4][159][0].apply(exports,arguments)
},{"./decrypter":327,"./encrypter":328,"./modes":330,"dup":159}],327:[function(require,module,exports){
(function (Buffer){
var aes = require('./aes')
var Transform = require('cipher-base')
var inherits = require('inherits')
var modes = require('./modes')
var StreamCipher = require('./streamCipher')
var AuthCipher = require('./authCipher')
var ebtk = require('evp_bytestokey')

inherits(Decipher, Transform)
function Decipher (mode, key, iv) {
  if (!(this instanceof Decipher)) {
    return new Decipher(mode, key, iv)
  }
  Transform.call(this)
  this._cache = new Splitter()
  this._last = void 0
  this._cipher = new aes.AES(key)
  this._prev = new Buffer(iv.length)
  iv.copy(this._prev)
  this._mode = mode
  this._autopadding = true
}
Decipher.prototype._update = function (data) {
  this._cache.add(data)
  var chunk
  var thing
  var out = []
  while ((chunk = this._cache.get(this._autopadding))) {
    thing = this._mode.decrypt(this, chunk)
    out.push(thing)
  }
  return Buffer.concat(out)
}
Decipher.prototype._final = function () {
  var chunk = this._cache.flush()
  if (this._autopadding) {
    return unpad(this._mode.decrypt(this, chunk))
  } else if (chunk) {
    throw new Error('data not multiple of block length')
  }
}
Decipher.prototype.setAutoPadding = function (setTo) {
  this._autopadding = !!setTo
}
function Splitter () {
  if (!(this instanceof Splitter)) {
    return new Splitter()
  }
  this.cache = new Buffer('')
}
Splitter.prototype.add = function (data) {
  this.cache = Buffer.concat([this.cache, data])
}

Splitter.prototype.get = function (autoPadding) {
  var out
  if (autoPadding) {
    if (this.cache.length > 16) {
      out = this.cache.slice(0, 16)
      this.cache = this.cache.slice(16)
      return out
    }
  } else {
    if (this.cache.length >= 16) {
      out = this.cache.slice(0, 16)
      this.cache = this.cache.slice(16)
      return out
    }
  }
  return null
}
Splitter.prototype.flush = function () {
  if (this.cache.length) {
    return this.cache
  }
}
function unpad (last) {
  var padded = last[15]
  var i = -1
  while (++i < padded) {
    if (last[(i + (16 - padded))] !== padded) {
      throw new Error('unable to decrypt data')
    }
  }
  if (padded === 16) {
    return
  }
  return last.slice(0, 16 - padded)
}

var modelist = {
  ECB: require('./modes/ecb'),
  CBC: require('./modes/cbc'),
  CFB: require('./modes/cfb'),
  CFB8: require('./modes/cfb8'),
  CFB1: require('./modes/cfb1'),
  OFB: require('./modes/ofb'),
  CTR: require('./modes/ctr'),
  GCM: require('./modes/ctr')
}

function createDecipheriv (suite, password, iv) {
  var config = modes[suite.toLowerCase()]
  if (!config) {
    throw new TypeError('invalid suite type')
  }
  if (typeof iv === 'string') {
    iv = new Buffer(iv)
  }
  if (typeof password === 'string') {
    password = new Buffer(password)
  }
  if (password.length !== config.key / 8) {
    throw new TypeError('invalid key length ' + password.length)
  }
  if (iv.length !== config.iv) {
    throw new TypeError('invalid iv length ' + iv.length)
  }
  if (config.type === 'stream') {
    return new StreamCipher(modelist[config.mode], password, iv, true)
  } else if (config.type === 'auth') {
    return new AuthCipher(modelist[config.mode], password, iv, true)
  }
  return new Decipher(modelist[config.mode], password, iv)
}

function createDecipher (suite, password) {
  var config = modes[suite.toLowerCase()]
  if (!config) {
    throw new TypeError('invalid suite type')
  }
  var keys = ebtk(password, false, config.key, config.iv)
  return createDecipheriv(suite, keys.key, keys.iv)
}
exports.createDecipher = createDecipher
exports.createDecipheriv = createDecipheriv

}).call(this,require("buffer").Buffer)

},{"./aes":324,"./authCipher":325,"./modes":330,"./modes/cbc":331,"./modes/cfb":332,"./modes/cfb1":333,"./modes/cfb8":334,"./modes/ctr":335,"./modes/ecb":336,"./modes/ofb":337,"./streamCipher":340,"buffer":151,"cipher-base":339,"evp_bytestokey":341,"inherits":348}],328:[function(require,module,exports){
(function (Buffer){
var aes = require('./aes')
var Transform = require('cipher-base')
var inherits = require('inherits')
var modes = require('./modes')
var ebtk = require('evp_bytestokey')
var StreamCipher = require('./streamCipher')
var AuthCipher = require('./authCipher')
inherits(Cipher, Transform)
function Cipher (mode, key, iv) {
  if (!(this instanceof Cipher)) {
    return new Cipher(mode, key, iv)
  }
  Transform.call(this)
  this._cache = new Splitter()
  this._cipher = new aes.AES(key)
  this._prev = new Buffer(iv.length)
  iv.copy(this._prev)
  this._mode = mode
  this._autopadding = true
}
Cipher.prototype._update = function (data) {
  this._cache.add(data)
  var chunk
  var thing
  var out = []
  while ((chunk = this._cache.get())) {
    thing = this._mode.encrypt(this, chunk)
    out.push(thing)
  }
  return Buffer.concat(out)
}
Cipher.prototype._final = function () {
  var chunk = this._cache.flush()
  if (this._autopadding) {
    chunk = this._mode.encrypt(this, chunk)
    this._cipher.scrub()
    return chunk
  } else if (chunk.toString('hex') !== '10101010101010101010101010101010') {
    this._cipher.scrub()
    throw new Error('data not multiple of block length')
  }
}
Cipher.prototype.setAutoPadding = function (setTo) {
  this._autopadding = !!setTo
}

function Splitter () {
  if (!(this instanceof Splitter)) {
    return new Splitter()
  }
  this.cache = new Buffer('')
}
Splitter.prototype.add = function (data) {
  this.cache = Buffer.concat([this.cache, data])
}

Splitter.prototype.get = function () {
  if (this.cache.length > 15) {
    var out = this.cache.slice(0, 16)
    this.cache = this.cache.slice(16)
    return out
  }
  return null
}
Splitter.prototype.flush = function () {
  var len = 16 - this.cache.length
  var padBuff = new Buffer(len)

  var i = -1
  while (++i < len) {
    padBuff.writeUInt8(len, i)
  }
  var out = Buffer.concat([this.cache, padBuff])
  return out
}
var modelist = {
  ECB: require('./modes/ecb'),
  CBC: require('./modes/cbc'),
  CFB: require('./modes/cfb'),
  CFB8: require('./modes/cfb8'),
  CFB1: require('./modes/cfb1'),
  OFB: require('./modes/ofb'),
  CTR: require('./modes/ctr'),
  GCM: require('./modes/ctr')
}

function createCipheriv (suite, password, iv) {
  var config = modes[suite.toLowerCase()]
  if (!config) {
    throw new TypeError('invalid suite type')
  }
  if (typeof iv === 'string') {
    iv = new Buffer(iv)
  }
  if (typeof password === 'string') {
    password = new Buffer(password)
  }
  if (password.length !== config.key / 8) {
    throw new TypeError('invalid key length ' + password.length)
  }
  if (iv.length !== config.iv) {
    throw new TypeError('invalid iv length ' + iv.length)
  }
  if (config.type === 'stream') {
    return new StreamCipher(modelist[config.mode], password, iv)
  } else if (config.type === 'auth') {
    return new AuthCipher(modelist[config.mode], password, iv)
  }
  return new Cipher(modelist[config.mode], password, iv)
}
function createCipher (suite, password) {
  var config = modes[suite.toLowerCase()]
  if (!config) {
    throw new TypeError('invalid suite type')
  }
  var keys = ebtk(password, false, config.key, config.iv)
  return createCipheriv(suite, keys.key, keys.iv)
}

exports.createCipheriv = createCipheriv
exports.createCipher = createCipher

}).call(this,require("buffer").Buffer)

},{"./aes":324,"./authCipher":325,"./modes":330,"./modes/cbc":331,"./modes/cfb":332,"./modes/cfb1":333,"./modes/cfb8":334,"./modes/ctr":335,"./modes/ecb":336,"./modes/ofb":337,"./streamCipher":340,"buffer":151,"cipher-base":339,"evp_bytestokey":341,"inherits":348}],329:[function(require,module,exports){
(function (Buffer){
var zeros = new Buffer(16)
zeros.fill(0)
module.exports = GHASH
function GHASH (key) {
  this.h = key
  this.state = new Buffer(16)
  this.state.fill(0)
  this.cache = new Buffer('')
}
// from http://bitwiseshiftleft.github.io/sjcl/doc/symbols/src/core_gcm.js.html
// by Juho Vähä-Herttua
GHASH.prototype.ghash = function (block) {
  var i = -1
  while (++i < block.length) {
    this.state[i] ^= block[i]
  }
  this._multiply()
}

GHASH.prototype._multiply = function () {
  var Vi = toArray(this.h)
  var Zi = [0, 0, 0, 0]
  var j, xi, lsb_Vi
  var i = -1
  while (++i < 128) {
    xi = (this.state[~~(i / 8)] & (1 << (7 - i % 8))) !== 0
    if (xi) {
      // Z_i+1 = Z_i ^ V_i
      Zi = xor(Zi, Vi)
    }

    // Store the value of LSB(V_i)
    lsb_Vi = (Vi[3] & 1) !== 0

    // V_i+1 = V_i >> 1
    for (j = 3; j > 0; j--) {
      Vi[j] = (Vi[j] >>> 1) | ((Vi[j - 1] & 1) << 31)
    }
    Vi[0] = Vi[0] >>> 1

    // If LSB(V_i) is 1, V_i+1 = (V_i >> 1) ^ R
    if (lsb_Vi) {
      Vi[0] = Vi[0] ^ (0xe1 << 24)
    }
  }
  this.state = fromArray(Zi)
}
GHASH.prototype.update = function (buf) {
  this.cache = Buffer.concat([this.cache, buf])
  var chunk
  while (this.cache.length >= 16) {
    chunk = this.cache.slice(0, 16)
    this.cache = this.cache.slice(16)
    this.ghash(chunk)
  }
}
GHASH.prototype.final = function (abl, bl) {
  if (this.cache.length) {
    this.ghash(Buffer.concat([this.cache, zeros], 16))
  }
  this.ghash(fromArray([
    0, abl,
    0, bl
  ]))
  return this.state
}

function toArray (buf) {
  return [
    buf.readUInt32BE(0),
    buf.readUInt32BE(4),
    buf.readUInt32BE(8),
    buf.readUInt32BE(12)
  ]
}
function fromArray (out) {
  out = out.map(fixup_uint32)
  var buf = new Buffer(16)
  buf.writeUInt32BE(out[0], 0)
  buf.writeUInt32BE(out[1], 4)
  buf.writeUInt32BE(out[2], 8)
  buf.writeUInt32BE(out[3], 12)
  return buf
}
var uint_max = Math.pow(2, 32)
function fixup_uint32 (x) {
  var ret, x_pos
  ret = x > uint_max || x < 0 ? (x_pos = Math.abs(x) % uint_max, x < 0 ? uint_max - x_pos : x_pos) : x
  return ret
}
function xor (a, b) {
  return [
    a[0] ^ b[0],
    a[1] ^ b[1],
    a[2] ^ b[2],
    a[3] ^ b[3]
  ]
}

}).call(this,require("buffer").Buffer)

},{"buffer":151}],330:[function(require,module,exports){
arguments[4][163][0].apply(exports,arguments)
},{"dup":163}],331:[function(require,module,exports){
arguments[4][164][0].apply(exports,arguments)
},{"buffer-xor":338,"dup":164}],332:[function(require,module,exports){
(function (Buffer){
var xor = require('buffer-xor')

exports.encrypt = function (self, data, decrypt) {
  var out = new Buffer('')
  var len

  while (data.length) {
    if (self._cache.length === 0) {
      self._cache = self._cipher.encryptBlock(self._prev)
      self._prev = new Buffer('')
    }

    if (self._cache.length <= data.length) {
      len = self._cache.length
      out = Buffer.concat([out, encryptStart(self, data.slice(0, len), decrypt)])
      data = data.slice(len)
    } else {
      out = Buffer.concat([out, encryptStart(self, data, decrypt)])
      break
    }
  }

  return out
}
function encryptStart (self, data, decrypt) {
  var len = data.length
  var out = xor(data, self._cache)
  self._cache = self._cache.slice(len)
  self._prev = Buffer.concat([self._prev, decrypt ? data : out])
  return out
}

}).call(this,require("buffer").Buffer)

},{"buffer":151,"buffer-xor":338}],333:[function(require,module,exports){
(function (Buffer){
function encryptByte (self, byteParam, decrypt) {
  var pad
  var i = -1
  var len = 8
  var out = 0
  var bit, value
  while (++i < len) {
    pad = self._cipher.encryptBlock(self._prev)
    bit = (byteParam & (1 << (7 - i))) ? 0x80 : 0
    value = pad[0] ^ bit
    out += ((value & 0x80) >> (i % 8))
    self._prev = shiftIn(self._prev, decrypt ? bit : value)
  }
  return out
}
exports.encrypt = function (self, chunk, decrypt) {
  var len = chunk.length
  var out = new Buffer(len)
  var i = -1
  while (++i < len) {
    out[i] = encryptByte(self, chunk[i], decrypt)
  }
  return out
}
function shiftIn (buffer, value) {
  var len = buffer.length
  var i = -1
  var out = new Buffer(buffer.length)
  buffer = Buffer.concat([buffer, new Buffer([value])])
  while (++i < len) {
    out[i] = buffer[i] << 1 | buffer[i + 1] >> (7)
  }
  return out
}

}).call(this,require("buffer").Buffer)

},{"buffer":151}],334:[function(require,module,exports){
(function (Buffer){
function encryptByte (self, byteParam, decrypt) {
  var pad = self._cipher.encryptBlock(self._prev)
  var out = pad[0] ^ byteParam
  self._prev = Buffer.concat([self._prev.slice(1), new Buffer([decrypt ? byteParam : out])])
  return out
}
exports.encrypt = function (self, chunk, decrypt) {
  var len = chunk.length
  var out = new Buffer(len)
  var i = -1
  while (++i < len) {
    out[i] = encryptByte(self, chunk[i], decrypt)
  }
  return out
}

}).call(this,require("buffer").Buffer)

},{"buffer":151}],335:[function(require,module,exports){
(function (Buffer){
var xor = require('buffer-xor')

function incr32 (iv) {
  var len = iv.length
  var item
  while (len--) {
    item = iv.readUInt8(len)
    if (item === 255) {
      iv.writeUInt8(0, len)
    } else {
      item++
      iv.writeUInt8(item, len)
      break
    }
  }
}

function getBlock (self) {
  var out = self._cipher.encryptBlock(self._prev)
  incr32(self._prev)
  return out
}

exports.encrypt = function (self, chunk) {
  while (self._cache.length < chunk.length) {
    self._cache = Buffer.concat([self._cache, getBlock(self)])
  }
  var pad = self._cache.slice(0, chunk.length)
  self._cache = self._cache.slice(chunk.length)
  return xor(chunk, pad)
}

}).call(this,require("buffer").Buffer)

},{"buffer":151,"buffer-xor":338}],336:[function(require,module,exports){
arguments[4][169][0].apply(exports,arguments)
},{"dup":169}],337:[function(require,module,exports){
(function (Buffer){
var xor = require('buffer-xor')

function getBlock (self) {
  self._prev = self._cipher.encryptBlock(self._prev)
  return self._prev
}

exports.encrypt = function (self, chunk) {
  while (self._cache.length < chunk.length) {
    self._cache = Buffer.concat([self._cache, getBlock(self)])
  }

  var pad = self._cache.slice(0, chunk.length)
  self._cache = self._cache.slice(chunk.length)
  return xor(chunk, pad)
}

}).call(this,require("buffer").Buffer)

},{"buffer":151,"buffer-xor":338}],338:[function(require,module,exports){
(function (Buffer){
module.exports = function xor (a, b) {
  var length = Math.min(a.length, b.length)
  var buffer = new Buffer(length)

  for (var i = 0; i < length; ++i) {
    buffer[i] = a[i] ^ b[i]
  }

  return buffer
}

}).call(this,require("buffer").Buffer)

},{"buffer":151}],339:[function(require,module,exports){
(function (Buffer){
var Transform = require('stream').Transform
var inherits = require('inherits')
var StringDecoder = require('string_decoder').StringDecoder
module.exports = CipherBase
inherits(CipherBase, Transform)
function CipherBase (hashMode) {
  Transform.call(this)
  this.hashMode = typeof hashMode === 'string'
  if (this.hashMode) {
    this[hashMode] = this._finalOrDigest
  } else {
    this.final = this._finalOrDigest
  }
  this._decoder = null
  this._encoding = null
}
CipherBase.prototype.update = function (data, inputEnc, outputEnc) {
  if (typeof data === 'string') {
    data = new Buffer(data, inputEnc)
  }
  var outData = this._update(data)
  if (this.hashMode) {
    return this
  }
  if (outputEnc) {
    outData = this._toString(outData, outputEnc)
  }
  return outData
}

CipherBase.prototype.setAutoPadding = function () {}

CipherBase.prototype.getAuthTag = function () {
  throw new Error('trying to get auth tag in unsupported state')
}

CipherBase.prototype.setAuthTag = function () {
  throw new Error('trying to set auth tag in unsupported state')
}

CipherBase.prototype.setAAD = function () {
  throw new Error('trying to set aad in unsupported state')
}

CipherBase.prototype._transform = function (data, _, next) {
  var err
  try {
    if (this.hashMode) {
      this._update(data)
    } else {
      this.push(this._update(data))
    }
  } catch (e) {
    err = e
  } finally {
    next(err)
  }
}
CipherBase.prototype._flush = function (done) {
  var err
  try {
    this.push(this._final())
  } catch (e) {
    err = e
  } finally {
    done(err)
  }
}
CipherBase.prototype._finalOrDigest = function (outputEnc) {
  var outData = this._final() || new Buffer('')
  if (outputEnc) {
    outData = this._toString(outData, outputEnc, true)
  }
  return outData
}

CipherBase.prototype._toString = function (value, enc, final) {
  if (!this._decoder) {
    this._decoder = new StringDecoder(enc)
    this._encoding = enc
  }
  if (this._encoding !== enc) {
    throw new Error('can\'t switch encodings')
  }
  var out = this._decoder.write(value)
  if (final) {
    out += this._decoder.end()
  }
  return out
}

}).call(this,require("buffer").Buffer)

},{"buffer":151,"inherits":348,"stream":365,"string_decoder":366}],340:[function(require,module,exports){
(function (Buffer){
var aes = require('./aes')
var Transform = require('cipher-base')
var inherits = require('inherits')

inherits(StreamCipher, Transform)
module.exports = StreamCipher
function StreamCipher (mode, key, iv, decrypt) {
  if (!(this instanceof StreamCipher)) {
    return new StreamCipher(mode, key, iv)
  }
  Transform.call(this)
  this._cipher = new aes.AES(key)
  this._prev = new Buffer(iv.length)
  this._cache = new Buffer('')
  this._secCache = new Buffer('')
  this._decrypt = decrypt
  iv.copy(this._prev)
  this._mode = mode
}
StreamCipher.prototype._update = function (chunk) {
  return this._mode.encrypt(this, chunk, this._decrypt)
}
StreamCipher.prototype._final = function () {
  this._cipher.scrub()
}

}).call(this,require("buffer").Buffer)

},{"./aes":324,"buffer":151,"cipher-base":339,"inherits":348}],341:[function(require,module,exports){
(function (Buffer){
var md5 = require('create-hash/md5')
module.exports = EVP_BytesToKey
function EVP_BytesToKey (password, salt, keyLen, ivLen) {
  if (!Buffer.isBuffer(password)) {
    password = new Buffer(password, 'binary')
  }
  if (salt && !Buffer.isBuffer(salt)) {
    salt = new Buffer(salt, 'binary')
  }
  keyLen = keyLen / 8
  ivLen = ivLen || 0
  var ki = 0
  var ii = 0
  var key = new Buffer(keyLen)
  var iv = new Buffer(ivLen)
  var addmd = 0
  var md_buf
  var i
  var bufs = []
  while (true) {
    if (addmd++ > 0) {
      bufs.push(md_buf)
    }
    bufs.push(password)
    if (salt) {
      bufs.push(salt)
    }
    md_buf = md5(Buffer.concat(bufs))
    bufs = []
    i = 0
    if (keyLen > 0) {
      while (true) {
        if (keyLen === 0) {
          break
        }
        if (i === md_buf.length) {
          break
        }
        key[ki++] = md_buf[i]
        keyLen--
        i++
      }
    }
    if (ivLen > 0 && i !== md_buf.length) {
      while (true) {
        if (ivLen === 0) {
          break
        }
        if (i === md_buf.length) {
          break
        }
        iv[ii++] = md_buf[i]
        ivLen--
        i++
      }
    }
    if (keyLen === 0 && ivLen === 0) {
      break
    }
  }
  for (i = 0; i < md_buf.length; i++) {
    md_buf[i] = 0
  }
  return {
    key: key,
    iv: iv
  }
}

}).call(this,require("buffer").Buffer)

},{"buffer":151,"create-hash/md5":281}],342:[function(require,module,exports){
(function (Buffer){
var parseKeys = require('parse-asn1');
var mgf = require('./mgf');
var xor = require('./xor');
var bn = require('bn.js');
var crt = require('browserify-rsa');
var createHash = require('create-hash');
var withPublic = require('./withPublic');
module.exports = function privateDecrypt(private_key, enc, reverse) {
  var padding;
  if (private_key.padding) {
    padding = private_key.padding;
  } else if (reverse) {
    padding = 1;
  } else {
    padding = 4;
  }
  
  var key = parseKeys(private_key);
  var k = key.modulus.byteLength();
  if (enc.length > k || new bn(enc).cmp(key.modulus) >= 0) {
    throw new Error('decryption error');
  }
  var msg;
  if (reverse) {
    msg = withPublic(new bn(enc), key);
  } else {
    msg = crt(enc, key);
  }
  var zBuffer = new Buffer(k - msg.length);
  zBuffer.fill(0);
  msg = Buffer.concat([zBuffer, msg], k);
  if (padding === 4) {
    return oaep(key, msg);
  } else if (padding === 1) {
    return pkcs1(key, msg, reverse);
  } else if (padding === 3) {
    return msg;
  } else {
    throw new Error('unknown padding');
  }
};

function oaep(key, msg){
  var n = key.modulus;
  var k = key.modulus.byteLength();
  var mLen = msg.length;
  var iHash = createHash('sha1').update(new Buffer('')).digest();
  var hLen = iHash.length;
  var hLen2 = 2 * hLen;
  if (msg[0] !== 0) {
    throw new Error('decryption error');
  }
  var maskedSeed = msg.slice(1, hLen + 1);
  var maskedDb =  msg.slice(hLen + 1);
  var seed = xor(maskedSeed, mgf(maskedDb, hLen));
  var db = xor(maskedDb, mgf(seed, k - hLen - 1));
  if (compare(iHash, db.slice(0, hLen))) {
    throw new Error('decryption error');
  }
  var i = hLen;
  while (db[i] === 0) {
    i++;
  }
  if (db[i++] !== 1) {
    throw new Error('decryption error');
  }
  return db.slice(i);
}

function pkcs1(key, msg, reverse){
  var p1 = msg.slice(0, 2);
  var i = 2;
  var status = 0;
  while (msg[i++] !== 0) {
    if (i >= msg.length) {
      status++;
      break;
    }
  }
  var ps = msg.slice(2, i - 1);
  var p2 = msg.slice(i - 1, i);

  if ((p1.toString('hex') !== '0002' && !reverse) || (p1.toString('hex') !== '0001' && reverse)){
    status++;
  }
  if (ps.length < 8) {
    status++;
  }
  if (status) {
    throw new Error('decryption error');
  }
  return  msg.slice(i);
}
function compare(a, b){
  a = new Buffer(a);
  b = new Buffer(b);
  var dif = 0;
  var len = a.length;
  if (a.length !== b.length) {
    dif++;
    len = Math.min(a.length, b.length);
  }
  var i = -1;
  while (++i < len) {
    dif += (a[i] ^ b[i]);
  }
  return dif;
}
}).call(this,require("buffer").Buffer)

},{"./mgf":302,"./withPublic":344,"./xor":345,"bn.js":303,"browserify-rsa":304,"buffer":151,"create-hash":279,"parse-asn1":308}],343:[function(require,module,exports){
(function (Buffer){
var parseKeys = require('parse-asn1');
var randomBytes = require('randombytes');
var createHash = require('create-hash');
var mgf = require('./mgf');
var xor = require('./xor');
var bn = require('bn.js');
var withPublic = require('./withPublic');
var crt = require('browserify-rsa');

var constants = {
  RSA_PKCS1_OAEP_PADDING: 4,
  RSA_PKCS1_PADDIN: 1,
  RSA_NO_PADDING: 3
};

module.exports = function publicEncrypt(public_key, msg, reverse) {
  var padding;
  if (public_key.padding) {
    padding = public_key.padding;
  } else if (reverse) {
    padding = 1;
  } else {
    padding = 4;
  }
  var key = parseKeys(public_key);
  var paddedMsg;
  if (padding === 4) {
    paddedMsg = oaep(key, msg);
  } else if (padding === 1) {
    paddedMsg = pkcs1(key, msg, reverse);
  } else if (padding === 3) {
    paddedMsg = new bn(msg);
    if (paddedMsg.cmp(key.modulus) >= 0) {
      throw new Error('data too long for modulus');
    }
  } else {
    throw new Error('unknown padding');
  }
  if (reverse) {
    return crt(paddedMsg, key);
  } else {
    return withPublic(paddedMsg, key);
  }
};

function oaep(key, msg){
  var k = key.modulus.byteLength();
  var mLen = msg.length;
  var iHash = createHash('sha1').update(new Buffer('')).digest();
  var hLen = iHash.length;
  var hLen2 = 2 * hLen;
  if (mLen > k - hLen2 - 2) {
    throw new Error('message too long');
  }
  var ps = new Buffer(k - mLen - hLen2 - 2);
  ps.fill(0);
  var dblen = k - hLen - 1;
  var seed = randomBytes(hLen);
  var maskedDb = xor(Buffer.concat([iHash, ps, new Buffer([1]), msg], dblen), mgf(seed, dblen));
  var maskedSeed = xor(seed, mgf(maskedDb, hLen));
  return new bn(Buffer.concat([new Buffer([0]), maskedSeed, maskedDb], k));
}
function pkcs1(key, msg, reverse){
  var mLen = msg.length;
  var k = key.modulus.byteLength();
  if (mLen > k - 11) {
    throw new Error('message too long');
  }
  var ps;
  if (reverse) {
    ps = new Buffer(k - mLen - 3);
    ps.fill(0xff);
  } else {
    ps = nonZero(k - mLen - 3);
  }
  return new bn(Buffer.concat([new Buffer([0, reverse?1:2]), ps, new Buffer([0]), msg], k));
}
function nonZero(len, crypto) {
  var out = new Buffer(len);
  var i = 0;
  var cache = randomBytes(len*2);
  var cur = 0;
  var num;
  while (i < len) {
    if (cur === cache.length) {
      cache = randomBytes(len*2);
      cur = 0;
    }
    num = cache[cur++];
    if (num) {
      out[i++] = num;
    }
  }
  return out;
}
}).call(this,require("buffer").Buffer)

},{"./mgf":302,"./withPublic":344,"./xor":345,"bn.js":303,"browserify-rsa":304,"buffer":151,"create-hash":279,"parse-asn1":308,"randombytes":346}],344:[function(require,module,exports){
(function (Buffer){
var bn = require('bn.js');
function withPublic(paddedMsg, key) {
  return new Buffer(paddedMsg
    .toRed(bn.mont(key.modulus))
    .redPow(new bn(key.publicExponent))
    .fromRed()
    .toArray());
}

module.exports = withPublic;
}).call(this,require("buffer").Buffer)

},{"bn.js":303,"buffer":151}],345:[function(require,module,exports){
module.exports = function xor(a, b) {
  var len = a.length;
  var i = -1;
  while (++i < len) {
    a[i] ^= b[i];
  }
  return a
};
},{}],346:[function(require,module,exports){
(function (process,global,Buffer){
'use strict';

var crypto = global.crypto || global.msCrypto
if(crypto && crypto.getRandomValues) {
  module.exports = randomBytes;
} else {
  module.exports = oldBrowser;
}
function randomBytes(size, cb) {
  var bytes = new Buffer(size); //in browserify, this is an extended Uint8Array
    /* This will not work in older browsers.
     * See https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues
     */

  crypto.getRandomValues(bytes);
  if (typeof cb === 'function') {
    return process.nextTick(function () {
      cb(null, bytes);
    });
  }
  return bytes;
}
function oldBrowser() {
  throw new Error(
      'secure random number generation not supported by this browser\n'+
      'use chrome, FireFox or Internet Explorer 11'
    )
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)

},{"_process":351,"buffer":151}],347:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],348:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],349:[function(require,module,exports){
/**
 * Determine if an object is Buffer
 *
 * Author:   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * License:  MIT
 *
 * `npm install is-buffer`
 */

module.exports = function (obj) {
  return !!(obj != null &&
    (obj._isBuffer || // For Safari 5-7 (missing Object.prototype.constructor)
      (obj.constructor &&
      typeof obj.constructor.isBuffer === 'function' &&
      obj.constructor.isBuffer(obj))
    ))
}

},{}],350:[function(require,module,exports){
module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

},{}],351:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],352:[function(require,module,exports){
module.exports = require("./lib/_stream_duplex.js")

},{"./lib/_stream_duplex.js":353}],353:[function(require,module,exports){
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) keys.push(key);
  return keys;
}
/*</replacement>*/


module.exports = Duplex;

/*<replacement>*/
var processNextTick = require('process-nextick-args');
/*</replacement>*/



/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

var keys = objectKeys(Writable.prototype);
for (var v = 0; v < keys.length; v++) {
  var method = keys[v];
  if (!Duplex.prototype[method])
    Duplex.prototype[method] = Writable.prototype[method];
}

function Duplex(options) {
  if (!(this instanceof Duplex))
    return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false)
    this.readable = false;

  if (options && options.writable === false)
    this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false)
    this.allowHalfOpen = false;

  this.once('end', onend);
}

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended)
    return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  processNextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

function forEach (xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

},{"./_stream_readable":355,"./_stream_writable":357,"core-util-is":358,"inherits":348,"process-nextick-args":359}],354:[function(require,module,exports){
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough))
    return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function(chunk, encoding, cb) {
  cb(null, chunk);
};

},{"./_stream_transform":356,"core-util-is":358,"inherits":348}],355:[function(require,module,exports){
(function (process){
'use strict';

module.exports = Readable;

/*<replacement>*/
var processNextTick = require('process-nextick-args');
/*</replacement>*/


/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/


/*<replacement>*/
var Buffer = require('buffer').Buffer;
/*</replacement>*/

Readable.ReadableState = ReadableState;

var EE = require('events');

/*<replacement>*/
var EElistenerCount = function(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/



/*<replacement>*/
var Stream;
(function (){try{
  Stream = require('st' + 'ream');
}catch(_){}finally{
  if (!Stream)
    Stream = require('events').EventEmitter;
}}())
/*</replacement>*/

var Buffer = require('buffer').Buffer;

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/



/*<replacement>*/
var debugUtil = require('util');
var debug;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var StringDecoder;

util.inherits(Readable, Stream);

var Duplex;
function ReadableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex)
    this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.buffer = [];
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // when piping, we only care about 'readable' events that happen
  // after read()ing all the bytes and not getting any pushback.
  this.ranOut = false;

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder)
      StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

var Duplex;
function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  if (!(this instanceof Readable))
    return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options && typeof options.read === 'function')
    this._read = options.read;

  Stream.call(this);
}

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function(chunk, encoding) {
  var state = this._readableState;

  if (!state.objectMode && typeof chunk === 'string') {
    encoding = encoding || state.defaultEncoding;
    if (encoding !== state.encoding) {
      chunk = new Buffer(chunk, encoding);
      encoding = '';
    }
  }

  return readableAddChunk(this, state, chunk, encoding, false);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function(chunk) {
  var state = this._readableState;
  return readableAddChunk(this, state, chunk, '', true);
};

Readable.prototype.isPaused = function() {
  return this._readableState.flowing === false;
};

function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er) {
    stream.emit('error', er);
  } else if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e = new Error('stream.push() after EOF');
      stream.emit('error', e);
    } else if (state.endEmitted && addToFront) {
      var e = new Error('stream.unshift() after end event');
      stream.emit('error', e);
    } else {
      if (state.decoder && !addToFront && !encoding)
        chunk = state.decoder.write(chunk);

      if (!addToFront)
        state.reading = false;

      // if we want the data now, just emit it.
      if (state.flowing && state.length === 0 && !state.sync) {
        stream.emit('data', chunk);
        stream.read(0);
      } else {
        // update the buffer info.
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);

        if (state.needReadable)
          emitReadable(stream);
      }

      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }

  return needMoreData(state);
}


// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended &&
         (state.needReadable ||
          state.length < state.highWaterMark ||
          state.length === 0);
}

// backwards compatibility.
Readable.prototype.setEncoding = function(enc) {
  if (!StringDecoder)
    StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

function howMuchToRead(n, state) {
  if (state.length === 0 && state.ended)
    return 0;

  if (state.objectMode)
    return n === 0 ? 0 : 1;

  if (n === null || isNaN(n)) {
    // only flow one buffer at a time
    if (state.flowing && state.buffer.length)
      return state.buffer[0].length;
    else
      return state.length;
  }

  if (n <= 0)
    return 0;

  // If we're asking for more than the target buffer level,
  // then raise the water mark.  Bump up to the next highest
  // power of 2, to prevent increasing it excessively in tiny
  // amounts.
  if (n > state.highWaterMark)
    state.highWaterMark = computeNewHighWaterMark(n);

  // don't have that much.  return null, unless we've ended.
  if (n > state.length) {
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    } else {
      return state.length;
    }
  }

  return n;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function(n) {
  debug('read', n);
  var state = this._readableState;
  var nOrig = n;

  if (typeof n !== 'number' || n > 0)
    state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 &&
      state.needReadable &&
      (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended)
      endReadable(this);
    else
      emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0)
      endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  }

  if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0)
      state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
  }

  // If _read pushed data synchronously, then `reading` will be false,
  // and we need to re-evaluate how much data we can return to the user.
  if (doRead && !state.reading)
    n = howMuchToRead(nOrig, state);

  var ret;
  if (n > 0)
    ret = fromList(n, state);
  else
    ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  }

  state.length -= n;

  // If we have nothing in the buffer, then we want to know
  // as soon as we *do* get something into the buffer.
  if (state.length === 0 && !state.ended)
    state.needReadable = true;

  // If we tried to read() past the EOF, then emit end on the next tick.
  if (nOrig !== n && state.ended && state.length === 0)
    endReadable(this);

  if (ret !== null)
    this.emit('data', ret);

  return ret;
};

function chunkInvalid(state, chunk) {
  var er = null;
  if (!(Buffer.isBuffer(chunk)) &&
      typeof chunk !== 'string' &&
      chunk !== null &&
      chunk !== undefined &&
      !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}


function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync)
      processNextTick(emitReadable_, stream);
    else
      emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}


// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    processNextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended &&
         state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;
    else
      len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function(n) {
  this.emit('error', new Error('not implemented'));
};

Readable.prototype.pipe = function(dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
              dest !== process.stdout &&
              dest !== process.stderr;

  var endFn = doEnd ? onend : cleanup;
  if (state.endEmitted)
    processNextTick(endFn);
  else
    src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable) {
    debug('onunpipe');
    if (readable === src) {
      cleanup();
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', cleanup);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain &&
        (!dest._writableState || dest._writableState.needDrain))
      ondrain();
  }

  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    if (false === ret) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      if (state.pipesCount === 1 &&
          state.pipes[0] === dest &&
          src.listenerCount('data') === 1 &&
          !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0)
      dest.emit('error', er);
  }
  // This is a brutally ugly hack to make sure that our error handler
  // is attached before any userland ones.  NEVER DO THIS.
  if (!dest._events || !dest._events.error)
    dest.on('error', onerror);
  else if (isArray(dest._events.error))
    dest._events.error.unshift(onerror);
  else
    dest._events.error = [onerror, dest._events.error];


  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain)
      state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}


Readable.prototype.unpipe = function(dest) {
  var state = this._readableState;

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0)
    return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes)
      return this;

    if (!dest)
      dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest)
      dest.emit('unpipe', this);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++)
      dests[i].emit('unpipe', this);
    return this;
  }

  // try to find the right one.
  var i = indexOf(state.pipes, dest);
  if (i === -1)
    return this;

  state.pipes.splice(i, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1)
    state.pipes = state.pipes[0];

  dest.emit('unpipe', this);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function(ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  // If listening to data, and it has not explicitly been paused,
  // then call resume to start the flow of data on the next tick.
  if (ev === 'data' && false !== this._readableState.flowing) {
    this.resume();
  }

  if (ev === 'readable' && this.readable) {
    var state = this._readableState;
    if (!state.readableListening) {
      state.readableListening = true;
      state.emittedReadable = false;
      state.needReadable = true;
      if (!state.reading) {
        processNextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this, state);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function() {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    processNextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading)
    stream.read(0);
}

Readable.prototype.pause = function() {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  if (state.flowing) {
    do {
      var chunk = stream.read();
    } while (null !== chunk && state.flowing);
  }
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function(stream) {
  var state = this._readableState;
  var paused = false;

  var self = this;
  stream.on('end', function() {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length)
        self.push(chunk);
    }

    self.push(null);
  });

  stream.on('data', function(chunk) {
    debug('wrapped data');
    if (state.decoder)
      chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined))
      return;
    else if (!state.objectMode && (!chunk || !chunk.length))
      return;

    var ret = self.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function(method) { return function() {
        return stream[method].apply(stream, arguments);
      }; }(i);
    }
  }

  // proxy certain important events.
  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
  forEach(events, function(ev) {
    stream.on(ev, self.emit.bind(self, ev));
  });

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  self._read = function(n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return self;
};


// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
function fromList(n, state) {
  var list = state.buffer;
  var length = state.length;
  var stringMode = !!state.decoder;
  var objectMode = !!state.objectMode;
  var ret;

  // nothing in the list, definitely empty.
  if (list.length === 0)
    return null;

  if (length === 0)
    ret = null;
  else if (objectMode)
    ret = list.shift();
  else if (!n || n >= length) {
    // read it all, truncate the array.
    if (stringMode)
      ret = list.join('');
    else if (list.length === 1)
      ret = list[0];
    else
      ret = Buffer.concat(list, length);
    list.length = 0;
  } else {
    // read just some of it.
    if (n < list[0].length) {
      // just take a part of the first list item.
      // slice is the same for buffers and strings.
      var buf = list[0];
      ret = buf.slice(0, n);
      list[0] = buf.slice(n);
    } else if (n === list[0].length) {
      // first list is a perfect match
      ret = list.shift();
    } else {
      // complex case.
      // we have enough to cover it, but it spans past the first buffer.
      if (stringMode)
        ret = '';
      else
        ret = new Buffer(n);

      var c = 0;
      for (var i = 0, l = list.length; i < l && c < n; i++) {
        var buf = list[0];
        var cpy = Math.min(n - c, buf.length);

        if (stringMode)
          ret += buf.slice(0, cpy);
        else
          buf.copy(ret, c, 0, cpy);

        if (cpy < buf.length)
          list[0] = buf.slice(cpy);
        else
          list.shift();

        c += cpy;
      }
    }
  }

  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0)
    throw new Error('endReadable called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    processNextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function forEach (xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

function indexOf (xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}

}).call(this,require('_process'))

},{"./_stream_duplex":353,"_process":351,"buffer":151,"core-util-is":358,"events":347,"inherits":348,"isarray":350,"process-nextick-args":359,"string_decoder/":366,"util":150}],356:[function(require,module,exports){
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);


function TransformState(stream) {
  this.afterTransform = function(er, data) {
    return afterTransform(stream, er, data);
  };

  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
}

function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb)
    return stream.emit('error', new Error('no writecb in Transform class'));

  ts.writechunk = null;
  ts.writecb = null;

  if (data !== null && data !== undefined)
    stream.push(data);

  if (cb)
    cb(er);

  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}


function Transform(options) {
  if (!(this instanceof Transform))
    return new Transform(options);

  Duplex.call(this, options);

  this._transformState = new TransformState(this);

  // when the writable side finishes, then flush out anything remaining.
  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function')
      this._transform = options.transform;

    if (typeof options.flush === 'function')
      this._flush = options.flush;
  }

  this.once('prefinish', function() {
    if (typeof this._flush === 'function')
      this._flush(function(er) {
        done(stream, er);
      });
    else
      done(stream);
  });
}

Transform.prototype.push = function(chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function(chunk, encoding, cb) {
  throw new Error('not implemented');
};

Transform.prototype._write = function(chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform ||
        rs.needReadable ||
        rs.length < rs.highWaterMark)
      this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function(n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};


function done(stream, er) {
  if (er)
    return stream.emit('error', er);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  var ws = stream._writableState;
  var ts = stream._transformState;

  if (ws.length)
    throw new Error('calling transform done when ws.length != 0');

  if (ts.transforming)
    throw new Error('calling transform done when still transforming');

  return stream.push(null);
}

},{"./_stream_duplex":353,"core-util-is":358,"inherits":348}],357:[function(require,module,exports){
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

'use strict';

module.exports = Writable;

/*<replacement>*/
var processNextTick = require('process-nextick-args');
/*</replacement>*/


/*<replacement>*/
var Buffer = require('buffer').Buffer;
/*</replacement>*/

Writable.WritableState = WritableState;


/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/


/*<replacement>*/
var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/



/*<replacement>*/
var Stream;
(function (){try{
  Stream = require('st' + 'ream');
}catch(_){}finally{
  if (!Stream)
    Stream = require('events').EventEmitter;
}}())
/*</replacement>*/

var Buffer = require('buffer').Buffer;

util.inherits(Writable, Stream);

function nop() {}

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

var Duplex;
function WritableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex)
    this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function(er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;
}

WritableState.prototype.getBuffer = function writableStateGetBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function (){try {
Object.defineProperty(WritableState.prototype, 'buffer', {
  get: internalUtil.deprecate(function() {
    return this.getBuffer();
  }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' +
     'instead.')
});
}catch(_){}}());


var Duplex;
function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, though they're not
  // instanceof Writable, they're instanceof Readable.
  if (!(this instanceof Writable) && !(this instanceof Duplex))
    return new Writable(options);

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function')
      this._write = options.write;

    if (typeof options.writev === 'function')
      this._writev = options.writev;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function() {
  this.emit('error', new Error('Cannot pipe. Not readable.'));
};


function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  processNextTick(cb, er);
}

// If we get something that is not a buffer, string, null, or undefined,
// and we're not in objectMode, then that's an error.
// Otherwise stream chunks are all considered to be of length=1, and the
// watermarks determine how many objects to keep in the buffer, rather than
// how many bytes or characters.
function validChunk(stream, state, chunk, cb) {
  var valid = true;

  if (!(Buffer.isBuffer(chunk)) &&
      typeof chunk !== 'string' &&
      chunk !== null &&
      chunk !== undefined &&
      !state.objectMode) {
    var er = new TypeError('Invalid non-string/buffer chunk');
    stream.emit('error', er);
    processNextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function(chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (Buffer.isBuffer(chunk))
    encoding = 'buffer';
  else if (!encoding)
    encoding = state.defaultEncoding;

  if (typeof cb !== 'function')
    cb = nop;

  if (state.ended)
    writeAfterEnd(this, cb);
  else if (validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function() {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function() {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing &&
        !state.corked &&
        !state.finished &&
        !state.bufferProcessing &&
        state.bufferedRequest)
      clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string')
    encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64',
'ucs2', 'ucs-2','utf16le', 'utf-16le', 'raw']
.indexOf((encoding + '').toLowerCase()) > -1))
    throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode &&
      state.decodeStrings !== false &&
      typeof chunk === 'string') {
    chunk = new Buffer(chunk, encoding);
  }
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, chunk, encoding, cb) {
  chunk = decodeChunk(state, chunk, encoding);

  if (Buffer.isBuffer(chunk))
    encoding = 'buffer';
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret)
    state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev)
    stream._writev(chunk, state.onwrite);
  else
    stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;
  if (sync)
    processNextTick(cb, er);
  else
    cb(er);

  stream._writableState.errorEmitted = true;
  stream.emit('error', er);
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er)
    onwriteError(stream, state, sync, er, cb);
  else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished &&
        !state.corked &&
        !state.bufferProcessing &&
        state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      processNextTick(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished)
    onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}


// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var buffer = [];
    var cbs = [];
    while (entry) {
      cbs.push(entry.callback);
      buffer.push(entry);
      entry = entry.next;
    }

    // count the one we are adding, as well.
    // TODO(isaacs) clean this up
    state.pendingcb++;
    state.lastBufferedRequest = null;
    doWrite(stream, state, true, state.length, buffer, '', function(err) {
      for (var i = 0; i < cbs.length; i++) {
        state.pendingcb--;
        cbs[i](err);
      }
    });

    // Clear buffer
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null)
      state.lastBufferedRequest = null;
  }
  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function(chunk, encoding, cb) {
  cb(new Error('not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function(chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined)
    this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished)
    endWritable(this, state, cb);
};


function needFinish(state) {
  return (state.ending &&
          state.length === 0 &&
          state.bufferedRequest === null &&
          !state.finished &&
          !state.writing);
}

function prefinish(stream, state) {
  if (!state.prefinished) {
    state.prefinished = true;
    stream.emit('prefinish');
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    if (state.pendingcb === 0) {
      prefinish(stream, state);
      state.finished = true;
      stream.emit('finish');
    } else {
      prefinish(stream, state);
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished)
      processNextTick(cb);
    else
      stream.once('finish', cb);
  }
  state.ended = true;
}

},{"./_stream_duplex":353,"buffer":151,"core-util-is":358,"events":347,"inherits":348,"process-nextick-args":359,"util-deprecate":360}],358:[function(require,module,exports){
(function (Buffer){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

}).call(this,{"isBuffer":require("../../../../insert-module-globals/node_modules/is-buffer/index.js")})

},{"../../../../insert-module-globals/node_modules/is-buffer/index.js":349}],359:[function(require,module,exports){
(function (process){
'use strict';

if (!process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = nextTick;
} else {
  module.exports = process.nextTick;
}

function nextTick(fn) {
  var args = new Array(arguments.length - 1);
  var i = 0;
  while (i < args.length) {
    args[i++] = arguments[i];
  }
  process.nextTick(function afterTick() {
    fn.apply(null, args);
  });
}

}).call(this,require('_process'))

},{"_process":351}],360:[function(require,module,exports){
(function (global){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],361:[function(require,module,exports){
module.exports = require("./lib/_stream_passthrough.js")

},{"./lib/_stream_passthrough.js":354}],362:[function(require,module,exports){
var Stream = (function (){
  try {
    return require('st' + 'ream'); // hack to fix a circular dependency issue when used with browserify
  } catch(_){}
}());
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = Stream || exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

},{"./lib/_stream_duplex.js":353,"./lib/_stream_passthrough.js":354,"./lib/_stream_readable.js":355,"./lib/_stream_transform.js":356,"./lib/_stream_writable.js":357}],363:[function(require,module,exports){
module.exports = require("./lib/_stream_transform.js")

},{"./lib/_stream_transform.js":356}],364:[function(require,module,exports){
module.exports = require("./lib/_stream_writable.js")

},{"./lib/_stream_writable.js":357}],365:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('readable-stream/readable.js');
Stream.Writable = require('readable-stream/writable.js');
Stream.Duplex = require('readable-stream/duplex.js');
Stream.Transform = require('readable-stream/transform.js');
Stream.PassThrough = require('readable-stream/passthrough.js');

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":347,"inherits":348,"readable-stream/duplex.js":352,"readable-stream/passthrough.js":361,"readable-stream/readable.js":362,"readable-stream/transform.js":363,"readable-stream/writable.js":364}],366:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var Buffer = require('buffer').Buffer;

var isBufferEncoding = Buffer.isEncoding
  || function(encoding) {
       switch (encoding && encoding.toLowerCase()) {
         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
         default: return false;
       }
     }


function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error('Unknown encoding: ' + encoding);
  }
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters. CESU-8 is handled as part of the UTF-8 encoding.
//
// @TODO Handling all encodings inside a single object makes it very difficult
// to reason about this code, so it should be split up in the future.
// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
// points as used by CESU-8.
var StringDecoder = exports.StringDecoder = function(encoding) {
  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
  assertEncoding(encoding);
  switch (this.encoding) {
    case 'utf8':
      // CESU-8 represents each of Surrogate Pair by 3-bytes
      this.surrogateSize = 3;
      break;
    case 'ucs2':
    case 'utf16le':
      // UTF-16 represents each of Surrogate Pair by 2-bytes
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case 'base64':
      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }

  // Enough space to store all bytes of a single character. UTF-8 needs 4
  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
  this.charBuffer = new Buffer(6);
  // Number of bytes received for the current incomplete multi-byte character.
  this.charReceived = 0;
  // Number of bytes expected for the current incomplete multi-byte character.
  this.charLength = 0;
};


// write decodes the given buffer and returns it as JS string that is
// guaranteed to not contain any partial multi-byte characters. Any partial
// character found at the end of the buffer is buffered up, and will be
// returned when calling write again with the remaining bytes.
//
// Note: Converting a Buffer containing an orphan surrogate to a String
// currently works, but converting a String to a Buffer (via `new Buffer`, or
// Buffer#write) will replace incomplete surrogates with the unicode
// replacement character. See https://codereview.chromium.org/121173009/ .
StringDecoder.prototype.write = function(buffer) {
  var charStr = '';
  // if our last write ended with an incomplete multibyte character
  while (this.charLength) {
    // determine how many remaining bytes this buffer has to offer for this char
    var available = (buffer.length >= this.charLength - this.charReceived) ?
        this.charLength - this.charReceived :
        buffer.length;

    // add the new bytes to the char buffer
    buffer.copy(this.charBuffer, this.charReceived, 0, available);
    this.charReceived += available;

    if (this.charReceived < this.charLength) {
      // still not enough chars in this buffer? wait for more ...
      return '';
    }

    // remove bytes belonging to the current character from the buffer
    buffer = buffer.slice(available, buffer.length);

    // get the character that was split
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      this.charLength += this.surrogateSize;
      charStr = '';
      continue;
    }
    this.charReceived = this.charLength = 0;

    // if there are no more bytes in this buffer, just emit our char
    if (buffer.length === 0) {
      return charStr;
    }
    break;
  }

  // determine and set charLength / charReceived
  this.detectIncompleteChar(buffer);

  var end = buffer.length;
  if (this.charLength) {
    // buffer the incomplete character bytes we got
    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
    end -= this.charReceived;
  }

  charStr += buffer.toString(this.encoding, 0, end);

  var end = charStr.length - 1;
  var charCode = charStr.charCodeAt(end);
  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    buffer.copy(this.charBuffer, 0, 0, size);
    return charStr.substring(0, end);
  }

  // or just emit the charStr
  return charStr;
};

// detectIncompleteChar determines if there is an incomplete UTF-8 character at
// the end of the given buffer. If so, it sets this.charLength to the byte
// length that character, and sets this.charReceived to the number of bytes
// that are available for this character.
StringDecoder.prototype.detectIncompleteChar = function(buffer) {
  // determine how many bytes we have to check at the end of this buffer
  var i = (buffer.length >= 3) ? 3 : buffer.length;

  // Figure out if one of the last i bytes of our buffer announces an
  // incomplete char.
  for (; i > 0; i--) {
    var c = buffer[buffer.length - i];

    // See http://en.wikipedia.org/wiki/UTF-8#Description

    // 110XXXXX
    if (i == 1 && c >> 5 == 0x06) {
      this.charLength = 2;
      break;
    }

    // 1110XXXX
    if (i <= 2 && c >> 4 == 0x0E) {
      this.charLength = 3;
      break;
    }

    // 11110XXX
    if (i <= 3 && c >> 3 == 0x1E) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = i;
};

StringDecoder.prototype.end = function(buffer) {
  var res = '';
  if (buffer && buffer.length)
    res = this.write(buffer);

  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }

  return res;
};

function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}

function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}

function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}

},{"buffer":151}],367:[function(require,module,exports){
var indexOf = require('indexof');

var Object_keys = function (obj) {
    if (Object.keys) return Object.keys(obj)
    else {
        var res = [];
        for (var key in obj) res.push(key)
        return res;
    }
};

var forEach = function (xs, fn) {
    if (xs.forEach) return xs.forEach(fn)
    else for (var i = 0; i < xs.length; i++) {
        fn(xs[i], i, xs);
    }
};

var defineProp = (function() {
    try {
        Object.defineProperty({}, '_', {});
        return function(obj, name, value) {
            Object.defineProperty(obj, name, {
                writable: true,
                enumerable: false,
                configurable: true,
                value: value
            })
        };
    } catch(e) {
        return function(obj, name, value) {
            obj[name] = value;
        };
    }
}());

var globals = ['Array', 'Boolean', 'Date', 'Error', 'EvalError', 'Function',
'Infinity', 'JSON', 'Math', 'NaN', 'Number', 'Object', 'RangeError',
'ReferenceError', 'RegExp', 'String', 'SyntaxError', 'TypeError', 'URIError',
'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'escape',
'eval', 'isFinite', 'isNaN', 'parseFloat', 'parseInt', 'undefined', 'unescape'];

function Context() {}
Context.prototype = {};

var Script = exports.Script = function NodeScript (code) {
    if (!(this instanceof Script)) return new Script(code);
    this.code = code;
};

Script.prototype.runInContext = function (context) {
    if (!(context instanceof Context)) {
        throw new TypeError("needs a 'context' argument.");
    }
    
    var iframe = document.createElement('iframe');
    if (!iframe.style) iframe.style = {};
    iframe.style.display = 'none';
    
    document.body.appendChild(iframe);
    
    var win = iframe.contentWindow;
    var wEval = win.eval, wExecScript = win.execScript;

    if (!wEval && wExecScript) {
        // win.eval() magically appears when this is called in IE:
        wExecScript.call(win, 'null');
        wEval = win.eval;
    }
    
    forEach(Object_keys(context), function (key) {
        win[key] = context[key];
    });
    forEach(globals, function (key) {
        if (context[key]) {
            win[key] = context[key];
        }
    });
    
    var winKeys = Object_keys(win);

    var res = wEval.call(win, this.code);
    
    forEach(Object_keys(win), function (key) {
        // Avoid copying circular objects like `top` and `window` by only
        // updating existing context properties or new properties in the `win`
        // that was only introduced after the eval.
        if (key in context || indexOf(winKeys, key) === -1) {
            context[key] = win[key];
        }
    });

    forEach(globals, function (key) {
        if (!(key in context)) {
            defineProp(context, key, win[key]);
        }
    });
    
    document.body.removeChild(iframe);
    
    return res;
};

Script.prototype.runInThisContext = function () {
    return eval(this.code); // maybe...
};

Script.prototype.runInNewContext = function (context) {
    var ctx = Script.createContext(context);
    var res = this.runInContext(ctx);

    forEach(Object_keys(ctx), function (key) {
        context[key] = ctx[key];
    });

    return res;
};

forEach(Object_keys(Script.prototype), function (name) {
    exports[name] = Script[name] = function (code) {
        var s = Script(code);
        return s[name].apply(s, [].slice.call(arguments, 1));
    };
});

exports.createScript = function (code) {
    return exports.Script(code);
};

exports.createContext = Script.createContext = function (context) {
    var copy = new Context();
    if(typeof context === 'object') {
        forEach(Object_keys(context), function (key) {
            copy[key] = context[key];
        });
    }
    return copy;
};

},{"indexof":368}],368:[function(require,module,exports){

var indexOf = [].indexOf;

module.exports = function(arr, obj){
  if (indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};
},{}],369:[function(require,module,exports){
/*!
 * XRegExp-All 3.0.0
 * <http://xregexp.com/>
 * Steven Levithan (c) 2012-2015 MIT License
 */

// Module systems magic dance. Don't use strict mode for this function, so it can assign to global.
;(function(root, definition) {
    var self;

    // RequireJS
    if (typeof define === 'function') {
        define(definition);
    // CommonJS
    } else if (typeof exports === 'object') {
        self = definition();
        // Use Node.js's `module.exports`. This supports both `require('xregexp')` and
        // `require('xregexp').XRegExp`
        (typeof module === 'object' ? (module.exports = self) : exports).XRegExp = self;
    // <script>
    } else {
        // Create global
        root.XRegExp = definition();
    }
}(this, function() {

/*!
 * XRegExp 3.0.0
 * <http://xregexp.com/>
 * Steven Levithan (c) 2007-2015 MIT License
 */

/**
 * XRegExp provides augmented, extensible regular expressions. You get additional regex syntax and
 * flags, beyond what browsers support natively. XRegExp is also a regex utility belt with tools to
 * make your client-side grepping simpler and more powerful, while freeing you from related
 * cross-browser inconsistencies.
 */
var XRegExp = (function(undefined) {
    'use strict';

/* ==============================
 * Private variables
 * ============================== */

    var // Internal reference to the `XRegExp` object
        self,
        // Property name used for extended regex instance data
        REGEX_DATA = 'xregexp',
        // Optional features that can be installed and uninstalled
        features = {
            astral: false,
            natives: false
        },
        // Native methods to use and restore ('native' is an ES3 reserved keyword)
        nativ = {
            exec: RegExp.prototype.exec,
            test: RegExp.prototype.test,
            match: String.prototype.match,
            replace: String.prototype.replace,
            split: String.prototype.split
        },
        // Storage for fixed/extended native methods
        fixed = {},
        // Storage for regexes cached by `XRegExp.cache`
        regexCache = {},
        // Storage for pattern details cached by the `XRegExp` constructor
        patternCache = {},
        // Storage for regex syntax tokens added internally or by `XRegExp.addToken`
        tokens = [],
        // Token scopes
        defaultScope = 'default',
        classScope = 'class',
        // Regexes that match native regex syntax, including octals
        nativeTokens = {
            // Any native multicharacter token in default scope, or any single character
            'default': /\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9]\d*|x[\dA-Fa-f]{2}|u(?:[\dA-Fa-f]{4}|{[\dA-Fa-f]+})|c[A-Za-z]|[\s\S])|\(\?[:=!]|[?*+]\?|{\d+(?:,\d*)?}\??|[\s\S]/,
            // Any native multicharacter token in character class scope, or any single character
            'class': /\\(?:[0-3][0-7]{0,2}|[4-7][0-7]?|x[\dA-Fa-f]{2}|u(?:[\dA-Fa-f]{4}|{[\dA-Fa-f]+})|c[A-Za-z]|[\s\S])|[\s\S]/
        },
        // Any backreference or dollar-prefixed character in replacement strings
        replacementToken = /\$(?:{([\w$]+)}|(\d\d?|[\s\S]))/g,
        // Check for correct `exec` handling of nonparticipating capturing groups
        correctExecNpcg = nativ.exec.call(/()??/, '')[1] === undefined,
        // Check for ES6 `u` flag support
        hasNativeU = (function() {
            var isSupported = true;
            try {
                new RegExp('', 'u');
            } catch (exception) {
                isSupported = false;
            }
            return isSupported;
        }()),
        // Check for ES6 `y` flag support
        hasNativeY = (function() {
            var isSupported = true;
            try {
                new RegExp('', 'y');
            } catch (exception) {
                isSupported = false;
            }
            return isSupported;
        }()),
        // Check for ES6 `flags` prop support
        hasFlagsProp = /a/.flags !== undefined,
        // Tracker for known flags, including addon flags
        registeredFlags = {
            g: true,
            i: true,
            m: true,
            u: hasNativeU,
            y: hasNativeY
        },
        // Shortcut to `Object.prototype.toString`
        toString = {}.toString,
        // Shortcut to `XRegExp.addToken`
        add;

/* ==============================
 * Private functions
 * ============================== */

/**
 * Attaches extended data and `XRegExp.prototype` properties to a regex object.
 *
 * @private
 * @param {RegExp} regex Regex to augment.
 * @param {Array} captureNames Array with capture names, or `null`.
 * @param {String} xSource XRegExp pattern used to generate `regex`, or `null` if N/A.
 * @param {String} xFlags XRegExp flags used to generate `regex`, or `null` if N/A.
 * @param {Boolean} [isInternalOnly=false] Whether the regex will be used only for internal
 *   operations, and never exposed to users. For internal-only regexes, we can improve perf by
 *   skipping some operations like attaching `XRegExp.prototype` properties.
 * @returns {RegExp} Augmented regex.
 */
    function augment(regex, captureNames, xSource, xFlags, isInternalOnly) {
        var p;

        regex[REGEX_DATA] = {
            captureNames: captureNames
        };

        if (isInternalOnly) {
            return regex;
        }

        // Can't auto-inherit these since the XRegExp constructor returns a nonprimitive value
        if (regex.__proto__) {
            regex.__proto__ = self.prototype;
        } else {
            for (p in self.prototype) {
                // A `self.prototype.hasOwnProperty(p)` check wouldn't be worth it here, since this
                // is performance sensitive, and enumerable `Object.prototype` or `RegExp.prototype`
                // extensions exist on `regex.prototype` anyway
                regex[p] = self.prototype[p];
            }
        }

        regex[REGEX_DATA].source = xSource;
        // Emulate the ES6 `flags` prop by ensuring flags are in alphabetical order
        regex[REGEX_DATA].flags = xFlags ? xFlags.split('').sort().join('') : xFlags;

        return regex;
    }

/**
 * Removes any duplicate characters from the provided string.
 *
 * @private
 * @param {String} str String to remove duplicate characters from.
 * @returns {String} String with any duplicate characters removed.
 */
    function clipDuplicates(str) {
        return nativ.replace.call(str, /([\s\S])(?=[\s\S]*\1)/g, '');
    }

/**
 * Copies a regex object while preserving extended data and augmenting with `XRegExp.prototype`
 * properties. The copy has a fresh `lastIndex` property (set to zero). Allows adding and removing
 * flags g and y while copying the regex.
 *
 * @private
 * @param {RegExp} regex Regex to copy.
 * @param {Object} [options] Options object with optional properties:
 *   <li>`addG` {Boolean} Add flag g while copying the regex.
 *   <li>`addY` {Boolean} Add flag y while copying the regex.
 *   <li>`removeG` {Boolean} Remove flag g while copying the regex.
 *   <li>`removeY` {Boolean} Remove flag y while copying the regex.
 *   <li>`isInternalOnly` {Boolean} Whether the copied regex will be used only for internal
 *     operations, and never exposed to users. For internal-only regexes, we can improve perf by
 *     skipping some operations like attaching `XRegExp.prototype` properties.
 * @returns {RegExp} Copy of the provided regex, possibly with modified flags.
 */
    function copyRegex(regex, options) {
        if (!self.isRegExp(regex)) {
            throw new TypeError('Type RegExp expected');
        }

        var xData = regex[REGEX_DATA] || {},
            flags = getNativeFlags(regex),
            flagsToAdd = '',
            flagsToRemove = '',
            xregexpSource = null,
            xregexpFlags = null;

        options = options || {};

        if (options.removeG) {flagsToRemove += 'g';}
        if (options.removeY) {flagsToRemove += 'y';}
        if (flagsToRemove) {
            flags = nativ.replace.call(flags, new RegExp('[' + flagsToRemove + ']+', 'g'), '');
        }

        if (options.addG) {flagsToAdd += 'g';}
        if (options.addY) {flagsToAdd += 'y';}
        if (flagsToAdd) {
            flags = clipDuplicates(flags + flagsToAdd);
        }

        if (!options.isInternalOnly) {
            if (xData.source !== undefined) {
                xregexpSource = xData.source;
            }
            // null or undefined; don't want to add to `flags` if the previous value was null, since
            // that indicates we're not tracking original precompilation flags
            if (xData.flags != null) {
                // Flags are only added for non-internal regexes by `XRegExp.globalize`. Flags are
                // never removed for non-internal regexes, so don't need to handle it
                xregexpFlags = flagsToAdd ? clipDuplicates(xData.flags + flagsToAdd) : xData.flags;
            }
        }

        // Augment with `XRegExp.prototype` properties, but use the native `RegExp` constructor to
        // avoid searching for special tokens. That would be wrong for regexes constructed by
        // `RegExp`, and unnecessary for regexes constructed by `XRegExp` because the regex has
        // already undergone the translation to native regex syntax
        regex = augment(
            new RegExp(regex.source, flags),
            hasNamedCapture(regex) ? xData.captureNames.slice(0) : null,
            xregexpSource,
            xregexpFlags,
            options.isInternalOnly
        );

        return regex;
    }

/**
 * Converts hexadecimal to decimal.
 *
 * @private
 * @param {String} hex
 * @returns {Number}
 */
    function dec(hex) {
        return parseInt(hex, 16);
    }

/**
 * Returns native `RegExp` flags used by a regex object.
 *
 * @private
 * @param {RegExp} regex Regex to check.
 * @returns {String} Native flags in use.
 */
    function getNativeFlags(regex) {
        return hasFlagsProp ?
            regex.flags :
            // Explicitly using `RegExp.prototype.toString` (rather than e.g. `String` or
            // concatenation with an empty string) allows this to continue working predictably when
            // `XRegExp.proptotype.toString` is overriden
            nativ.exec.call(/\/([a-z]*)$/i, RegExp.prototype.toString.call(regex))[1];
    }

/**
 * Determines whether a regex has extended instance data used to track capture names.
 *
 * @private
 * @param {RegExp} regex Regex to check.
 * @returns {Boolean} Whether the regex uses named capture.
 */
    function hasNamedCapture(regex) {
        return !!(regex[REGEX_DATA] && regex[REGEX_DATA].captureNames);
    }

/**
 * Converts decimal to hexadecimal.
 *
 * @private
 * @param {Number|String} dec
 * @returns {String}
 */
    function hex(dec) {
        return parseInt(dec, 10).toString(16);
    }

/**
 * Returns the first index at which a given value can be found in an array.
 *
 * @private
 * @param {Array} array Array to search.
 * @param {*} value Value to locate in the array.
 * @returns {Number} Zero-based index at which the item is found, or -1.
 */
    function indexOf(array, value) {
        var len = array.length, i;

        for (i = 0; i < len; ++i) {
            if (array[i] === value) {
                return i;
            }
        }

        return -1;
    }

/**
 * Determines whether a value is of the specified type, by resolving its internal [[Class]].
 *
 * @private
 * @param {*} value Object to check.
 * @param {String} type Type to check for, in TitleCase.
 * @returns {Boolean} Whether the object matches the type.
 */
    function isType(value, type) {
        return toString.call(value) === '[object ' + type + ']';
    }

/**
 * Checks whether the next nonignorable token after the specified position is a quantifier.
 *
 * @private
 * @param {String} pattern Pattern to search within.
 * @param {Number} pos Index in `pattern` to search at.
 * @param {String} flags Flags used by the pattern.
 * @returns {Boolean} Whether the next token is a quantifier.
 */
    function isQuantifierNext(pattern, pos, flags) {
        return nativ.test.call(
            flags.indexOf('x') > -1 ?
                // Ignore any leading whitespace, line comments, and inline comments
                /^(?:\s+|#.*|\(\?#[^)]*\))*(?:[?*+]|{\d+(?:,\d*)?})/ :
                // Ignore any leading inline comments
                /^(?:\(\?#[^)]*\))*(?:[?*+]|{\d+(?:,\d*)?})/,
            pattern.slice(pos)
        );
    }

/**
 * Pads the provided string with as many leading zeros as needed to get to length 4. Used to produce
 * fixed-length hexadecimal values.
 *
 * @private
 * @param {String} str
 * @returns {String}
 */
    function pad4(str) {
        while (str.length < 4) {
            str = '0' + str;
        }
        return str;
    }

/**
 * Checks for flag-related errors, and strips/applies flags in a leading mode modifier. Offloads
 * the flag preparation logic from the `XRegExp` constructor.
 *
 * @private
 * @param {String} pattern Regex pattern, possibly with a leading mode modifier.
 * @param {String} flags Any combination of flags.
 * @returns {Object} Object with properties `pattern` and `flags`.
 */
    function prepareFlags(pattern, flags) {
        var i;

        // Recent browsers throw on duplicate flags, so copy this behavior for nonnative flags
        if (clipDuplicates(flags) !== flags) {
            throw new SyntaxError('Invalid duplicate regex flag ' + flags);
        }

        // Strip and apply a leading mode modifier with any combination of flags except g or y
        pattern = nativ.replace.call(pattern, /^\(\?([\w$]+)\)/, function($0, $1) {
            if (nativ.test.call(/[gy]/, $1)) {
                throw new SyntaxError('Cannot use flag g or y in mode modifier ' + $0);
            }
            // Allow duplicate flags within the mode modifier
            flags = clipDuplicates(flags + $1);
            return '';
        });

        // Throw on unknown native or nonnative flags
        for (i = 0; i < flags.length; ++i) {
            if (!registeredFlags[flags.charAt(i)]) {
                throw new SyntaxError('Unknown regex flag ' + flags.charAt(i));
            }
        }

        return {
            pattern: pattern,
            flags: flags
        };
    }

/**
 * Prepares an options object from the given value.
 *
 * @private
 * @param {String|Object} value Value to convert to an options object.
 * @returns {Object} Options object.
 */
    function prepareOptions(value) {
        var options = {};

        if (isType(value, 'String')) {
            self.forEach(value, /[^\s,]+/, function(match) {
                options[match] = true;
            });

            return options;
        }

        return value;
    }

/**
 * Registers a flag so it doesn't throw an 'unknown flag' error.
 *
 * @private
 * @param {String} flag Single-character flag to register.
 */
    function registerFlag(flag) {
        if (!/^[\w$]$/.test(flag)) {
            throw new Error('Flag must be a single character A-Za-z0-9_$');
        }

        registeredFlags[flag] = true;
    }

/**
 * Runs built-in and custom regex syntax tokens in reverse insertion order at the specified
 * position, until a match is found.
 *
 * @private
 * @param {String} pattern Original pattern from which an XRegExp object is being built.
 * @param {String} flags Flags being used to construct the regex.
 * @param {Number} pos Position to search for tokens within `pattern`.
 * @param {Number} scope Regex scope to apply: 'default' or 'class'.
 * @param {Object} context Context object to use for token handler functions.
 * @returns {Object} Object with properties `matchLength`, `output`, and `reparse`; or `null`.
 */
    function runTokens(pattern, flags, pos, scope, context) {
        var i = tokens.length,
            leadChar = pattern.charAt(pos),
            result = null,
            match,
            t;

        // Run in reverse insertion order
        while (i--) {
            t = tokens[i];
            if (
                (t.leadChar && t.leadChar !== leadChar) ||
                (t.scope !== scope && t.scope !== 'all') ||
                (t.flag && flags.indexOf(t.flag) === -1)
            ) {
                continue;
            }

            match = self.exec(pattern, t.regex, pos, 'sticky');
            if (match) {
                result = {
                    matchLength: match[0].length,
                    output: t.handler.call(context, match, scope, flags),
                    reparse: t.reparse
                };
                // Finished with token tests
                break;
            }
        }

        return result;
    }

/**
 * Enables or disables implicit astral mode opt-in. When enabled, flag A is automatically added to
 * all new regexes created by XRegExp. This causes an error to be thrown when creating regexes if
 * the Unicode Base addon is not available, since flag A is registered by that addon.
 *
 * @private
 * @param {Boolean} on `true` to enable; `false` to disable.
 */
    function setAstral(on) {
        features.astral = on;
    }

/**
 * Enables or disables native method overrides.
 *
 * @private
 * @param {Boolean} on `true` to enable; `false` to disable.
 */
    function setNatives(on) {
        RegExp.prototype.exec = (on ? fixed : nativ).exec;
        RegExp.prototype.test = (on ? fixed : nativ).test;
        String.prototype.match = (on ? fixed : nativ).match;
        String.prototype.replace = (on ? fixed : nativ).replace;
        String.prototype.split = (on ? fixed : nativ).split;

        features.natives = on;
    }

/**
 * Returns the object, or throws an error if it is `null` or `undefined`. This is used to follow
 * the ES5 abstract operation `ToObject`.
 *
 * @private
 * @param {*} value Object to check and return.
 * @returns {*} The provided object.
 */
    function toObject(value) {
        // null or undefined
        if (value == null) {
            throw new TypeError('Cannot convert null or undefined to object');
        }

        return value;
    }

/* ==============================
 * Constructor
 * ============================== */

/**
 * Creates an extended regular expression object for matching text with a pattern. Differs from a
 * native regular expression in that additional syntax and flags are supported. The returned object
 * is in fact a native `RegExp` and works with all native methods.
 *
 * @class XRegExp
 * @constructor
 * @param {String|RegExp} pattern Regex pattern string, or an existing regex object to copy.
 * @param {String} [flags] Any combination of flags.
 *   Native flags:
 *     <li>`g` - global
 *     <li>`i` - ignore case
 *     <li>`m` - multiline anchors
 *     <li>`u` - unicode (ES6)
 *     <li>`y` - sticky (Firefox 3+, ES6)
 *   Additional XRegExp flags:
 *     <li>`n` - explicit capture
 *     <li>`s` - dot matches all (aka singleline)
 *     <li>`x` - free-spacing and line comments (aka extended)
 *     <li>`A` - astral (requires the Unicode Base addon)
 *   Flags cannot be provided when constructing one `RegExp` from another.
 * @returns {RegExp} Extended regular expression object.
 * @example
 *
 * // With named capture and flag x
 * XRegExp('(?<year>  [0-9]{4} ) -?  # year  \n\
 *          (?<month> [0-9]{2} ) -?  # month \n\
 *          (?<day>   [0-9]{2} )     # day   ', 'x');
 *
 * // Providing a regex object copies it. Native regexes are recompiled using native (not XRegExp)
 * // syntax. Copies maintain extended data, are augmented with `XRegExp.prototype` properties, and
 * // have fresh `lastIndex` properties (set to zero).
 * XRegExp(/regex/);
 */
    self = function(pattern, flags) {
        var context = {
                hasNamedCapture: false,
                captureNames: []
            },
            scope = defaultScope,
            output = '',
            pos = 0,
            result,
            token,
            generated,
            appliedPattern,
            appliedFlags;

        if (self.isRegExp(pattern)) {
            if (flags !== undefined) {
                throw new TypeError('Cannot supply flags when copying a RegExp');
            }
            return copyRegex(pattern);
        }

        // Copy the argument behavior of `RegExp`
        pattern = pattern === undefined ? '' : String(pattern);
        flags = flags === undefined ? '' : String(flags);

        if (self.isInstalled('astral') && flags.indexOf('A') === -1) {
            // This causes an error to be thrown if the Unicode Base addon is not available
            flags += 'A';
        }

        if (!patternCache[pattern]) {
            patternCache[pattern] = {};
        }

        if (!patternCache[pattern][flags]) {
            // Check for flag-related errors, and strip/apply flags in a leading mode modifier
            result = prepareFlags(pattern, flags);
            appliedPattern = result.pattern;
            appliedFlags = result.flags;

            // Use XRegExp's tokens to translate the pattern to a native regex pattern.
            // `appliedPattern.length` may change on each iteration if tokens use `reparse`
            while (pos < appliedPattern.length) {
                do {
                    // Check for custom tokens at the current position
                    result = runTokens(appliedPattern, appliedFlags, pos, scope, context);
                    // If the matched token used the `reparse` option, splice its output into the
                    // pattern before running tokens again at the same position
                    if (result && result.reparse) {
                        appliedPattern = appliedPattern.slice(0, pos) +
                            result.output +
                            appliedPattern.slice(pos + result.matchLength);
                    }
                } while (result && result.reparse);

                if (result) {
                    output += result.output;
                    pos += (result.matchLength || 1);
                } else {
                    // Get the native token at the current position
                    token = self.exec(appliedPattern, nativeTokens[scope], pos, 'sticky')[0];
                    output += token;
                    pos += token.length;
                    if (token === '[' && scope === defaultScope) {
                        scope = classScope;
                    } else if (token === ']' && scope === classScope) {
                        scope = defaultScope;
                    }
                }
            }

            patternCache[pattern][flags] = {
                // Cleanup token cruft: repeated `(?:)(?:)` and leading/trailing `(?:)`
                pattern: nativ.replace.call(output, /\(\?:\)(?=\(\?:\))|^\(\?:\)|\(\?:\)$/g, ''),
                // Strip all but native flags
                flags: nativ.replace.call(appliedFlags, /[^gimuy]+/g, ''),
                // `context.captureNames` has an item for each capturing group, even if unnamed
                captures: context.hasNamedCapture ? context.captureNames : null
            };
        }

        generated = patternCache[pattern][flags];
        return augment(
            new RegExp(generated.pattern, generated.flags),
            generated.captures,
            pattern,
            flags
        );
    };

// Add `RegExp.prototype` to the prototype chain
    self.prototype = new RegExp();

/* ==============================
 * Public properties
 * ============================== */

/**
 * The XRegExp version number.
 *
 * @static
 * @memberOf XRegExp
 * @type String
 */
    self.version = '3.0.0';

/* ==============================
 * Public methods
 * ============================== */

/**
 * Extends XRegExp syntax and allows custom flags. This is used internally and can be used to
 * create XRegExp addons. If more than one token can match the same string, the last added wins.
 *
 * @memberOf XRegExp
 * @param {RegExp} regex Regex object that matches the new token.
 * @param {Function} handler Function that returns a new pattern string (using native regex syntax)
 *   to replace the matched token within all future XRegExp regexes. Has access to persistent
 *   properties of the regex being built, through `this`. Invoked with three arguments:
 *   <li>The match array, with named backreference properties.
 *   <li>The regex scope where the match was found: 'default' or 'class'.
 *   <li>The flags used by the regex, including any flags in a leading mode modifier.
 *   The handler function becomes part of the XRegExp construction process, so be careful not to
 *   construct XRegExps within the function or you will trigger infinite recursion.
 * @param {Object} [options] Options object with optional properties:
 *   <li>`scope` {String} Scope where the token applies: 'default', 'class', or 'all'.
 *   <li>`flag` {String} Single-character flag that triggers the token. This also registers the
 *     flag, which prevents XRegExp from throwing an 'unknown flag' error when the flag is used.
 *   <li>`optionalFlags` {String} Any custom flags checked for within the token `handler` that are
 *     not required to trigger the token. This registers the flags, to prevent XRegExp from
 *     throwing an 'unknown flag' error when any of the flags are used.
 *   <li>`reparse` {Boolean} Whether the `handler` function's output should not be treated as
 *     final, and instead be reparseable by other tokens (including the current token). Allows
 *     token chaining or deferring.
 *   <li>`leadChar` {String} Single character that occurs at the beginning of any successful match
 *     of the token (not always applicable). This doesn't change the behavior of the token unless
 *     you provide an erroneous value. However, providing it can increase the token's performance.
 * @example
 *
 * // Basic usage: Add \a for the ALERT control code
 * XRegExp.addToken(
 *   /\\a/,
 *   function() {return '\\x07';},
 *   {scope: 'all'}
 * );
 * XRegExp('\\a[\\a-\\n]+').test('\x07\n\x07'); // -> true
 *
 * // Add the U (ungreedy) flag from PCRE and RE2, which reverses greedy and lazy quantifiers
 * XRegExp.addToken(
 *   /([?*+]|{\d+(?:,\d*)?})(\??)/,
 *   function(match) {return match[1] + (match[2] ? '' : '?');},
 *   {flag: 'U'}
 * );
 * XRegExp('a+', 'U').exec('aaa')[0]; // -> 'a'
 * XRegExp('a+?', 'U').exec('aaa')[0]; // -> 'aaa'
 */
    self.addToken = function(regex, handler, options) {
        options = options || {};
        var optionalFlags = options.optionalFlags, i;

        if (options.flag) {
            registerFlag(options.flag);
        }

        if (optionalFlags) {
            optionalFlags = nativ.split.call(optionalFlags, '');
            for (i = 0; i < optionalFlags.length; ++i) {
                registerFlag(optionalFlags[i]);
            }
        }

        // Add to the private list of syntax tokens
        tokens.push({
            regex: copyRegex(regex, {
                addG: true,
                addY: hasNativeY,
                isInternalOnly: true
            }),
            handler: handler,
            scope: options.scope || defaultScope,
            flag: options.flag,
            reparse: options.reparse,
            leadChar: options.leadChar
        });

        // Reset the pattern cache used by the `XRegExp` constructor, since the same pattern and
        // flags might now produce different results
        self.cache.flush('patterns');
    };

/**
 * Caches and returns the result of calling `XRegExp(pattern, flags)`. On any subsequent call with
 * the same pattern and flag combination, the cached copy of the regex is returned.
 *
 * @memberOf XRegExp
 * @param {String} pattern Regex pattern string.
 * @param {String} [flags] Any combination of XRegExp flags.
 * @returns {RegExp} Cached XRegExp object.
 * @example
 *
 * while (match = XRegExp.cache('.', 'gs').exec(str)) {
 *   // The regex is compiled once only
 * }
 */
    self.cache = function(pattern, flags) {
        if (!regexCache[pattern]) {
            regexCache[pattern] = {};
        }
        return regexCache[pattern][flags] || (
            regexCache[pattern][flags] = self(pattern, flags)
        );
    };

// Intentionally undocumented
    self.cache.flush = function(cacheName) {
        if (cacheName === 'patterns') {
            // Flush the pattern cache used by the `XRegExp` constructor
            patternCache = {};
        } else {
            // Flush the regex cache populated by `XRegExp.cache`
            regexCache = {};
        }
    };

/**
 * Escapes any regular expression metacharacters, for use when matching literal strings. The result
 * can safely be used at any point within a regex that uses any flags.
 *
 * @memberOf XRegExp
 * @param {String} str String to escape.
 * @returns {String} String with regex metacharacters escaped.
 * @example
 *
 * XRegExp.escape('Escaped? <.>');
 * // -> 'Escaped\?\ <\.>'
 */
    self.escape = function(str) {
        return nativ.replace.call(toObject(str), /[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
    };

/**
 * Executes a regex search in a specified string. Returns a match array or `null`. If the provided
 * regex uses named capture, named backreference properties are included on the match array.
 * Optional `pos` and `sticky` arguments specify the search start position, and whether the match
 * must start at the specified position only. The `lastIndex` property of the provided regex is not
 * used, but is updated for compatibility. Also fixes browser bugs compared to the native
 * `RegExp.prototype.exec` and can be used reliably cross-browser.
 *
 * @memberOf XRegExp
 * @param {String} str String to search.
 * @param {RegExp} regex Regex to search with.
 * @param {Number} [pos=0] Zero-based index at which to start the search.
 * @param {Boolean|String} [sticky=false] Whether the match must start at the specified position
 *   only. The string `'sticky'` is accepted as an alternative to `true`.
 * @returns {Array} Match array with named backreference properties, or `null`.
 * @example
 *
 * // Basic use, with named backreference
 * var match = XRegExp.exec('U+2620', XRegExp('U\\+(?<hex>[0-9A-F]{4})'));
 * match.hex; // -> '2620'
 *
 * // With pos and sticky, in a loop
 * var pos = 2, result = [], match;
 * while (match = XRegExp.exec('<1><2><3><4>5<6>', /<(\d)>/, pos, 'sticky')) {
 *   result.push(match[1]);
 *   pos = match.index + match[0].length;
 * }
 * // result -> ['2', '3', '4']
 */
    self.exec = function(str, regex, pos, sticky) {
        var cacheKey = 'g',
            addY = false,
            match,
            r2;

        addY = hasNativeY && !!(sticky || (regex.sticky && sticky !== false));
        if (addY) {
            cacheKey += 'y';
        }

        regex[REGEX_DATA] = regex[REGEX_DATA] || {};

        // Shares cached copies with `XRegExp.match`/`replace`
        r2 = regex[REGEX_DATA][cacheKey] || (
            regex[REGEX_DATA][cacheKey] = copyRegex(regex, {
                addG: true,
                addY: addY,
                removeY: sticky === false,
                isInternalOnly: true
            })
        );

        r2.lastIndex = pos = pos || 0;

        // Fixed `exec` required for `lastIndex` fix, named backreferences, etc.
        match = fixed.exec.call(r2, str);

        if (sticky && match && match.index !== pos) {
            match = null;
        }

        if (regex.global) {
            regex.lastIndex = match ? r2.lastIndex : 0;
        }

        return match;
    };

/**
 * Executes a provided function once per regex match.
 *
 * @memberOf XRegExp
 * @param {String} str String to search.
 * @param {RegExp} regex Regex to search with.
 * @param {Function} callback Function to execute for each match. Invoked with four arguments:
 *   <li>The match array, with named backreference properties.
 *   <li>The zero-based match index.
 *   <li>The string being traversed.
 *   <li>The regex object being used to traverse the string.
 * @example
 *
 * // Extracts every other digit from a string
 * XRegExp.forEach('1a2345', /\d/, function(match, i) {
 *   if (i % 2) this.push(+match[0]);
 * }, []);
 * // -> [2, 4]
 */
    self.forEach = function(str, regex, callback) {
        var pos = 0,
            i = -1,
            match;

        while ((match = self.exec(str, regex, pos))) {
            // Because `regex` is provided to `callback`, the function could use the deprecated/
            // nonstandard `RegExp.prototype.compile` to mutate the regex. However, since
            // `XRegExp.exec` doesn't use `lastIndex` to set the search position, this can't lead
            // to an infinite loop, at least. Actually, because of the way `XRegExp.exec` caches
            // globalized versions of regexes, mutating the regex will not have any effect on the
            // iteration or matched strings, which is a nice side effect that brings extra safety
            callback(match, ++i, str, regex);

            pos = match.index + (match[0].length || 1);
        }
    };

/**
 * Copies a regex object and adds flag `g`. The copy maintains extended data, is augmented with
 * `XRegExp.prototype` properties, and has a fresh `lastIndex` property (set to zero). Native
 * regexes are not recompiled using XRegExp syntax.
 *
 * @memberOf XRegExp
 * @param {RegExp} regex Regex to globalize.
 * @returns {RegExp} Copy of the provided regex with flag `g` added.
 * @example
 *
 * var globalCopy = XRegExp.globalize(/regex/);
 * globalCopy.global; // -> true
 */
    self.globalize = function(regex) {
        return copyRegex(regex, {addG: true});
    };

/**
 * Installs optional features according to the specified options. Can be undone using
 * {@link #XRegExp.uninstall}.
 *
 * @memberOf XRegExp
 * @param {Object|String} options Options object or string.
 * @example
 *
 * // With an options object
 * XRegExp.install({
 *   // Enables support for astral code points in Unicode addons (implicitly sets flag A)
 *   astral: true,
 *
 *   // Overrides native regex methods with fixed/extended versions that support named
 *   // backreferences and fix numerous cross-browser bugs
 *   natives: true
 * });
 *
 * // With an options string
 * XRegExp.install('astral natives');
 */
    self.install = function(options) {
        options = prepareOptions(options);

        if (!features.astral && options.astral) {
            setAstral(true);
        }

        if (!features.natives && options.natives) {
            setNatives(true);
        }
    };

/**
 * Checks whether an individual optional feature is installed.
 *
 * @memberOf XRegExp
 * @param {String} feature Name of the feature to check. One of:
 *   <li>`natives`
 *   <li>`astral`
 * @returns {Boolean} Whether the feature is installed.
 * @example
 *
 * XRegExp.isInstalled('natives');
 */
    self.isInstalled = function(feature) {
        return !!(features[feature]);
    };

/**
 * Returns `true` if an object is a regex; `false` if it isn't. This works correctly for regexes
 * created in another frame, when `instanceof` and `constructor` checks would fail.
 *
 * @memberOf XRegExp
 * @param {*} value Object to check.
 * @returns {Boolean} Whether the object is a `RegExp` object.
 * @example
 *
 * XRegExp.isRegExp('string'); // -> false
 * XRegExp.isRegExp(/regex/i); // -> true
 * XRegExp.isRegExp(RegExp('^', 'm')); // -> true
 * XRegExp.isRegExp(XRegExp('(?s).')); // -> true
 */
    self.isRegExp = function(value) {
        return toString.call(value) === '[object RegExp]';
        //return isType(value, 'RegExp');
    };

/**
 * Returns the first matched string, or in global mode, an array containing all matched strings.
 * This is essentially a more convenient re-implementation of `String.prototype.match` that gives
 * the result types you actually want (string instead of `exec`-style array in match-first mode,
 * and an empty array instead of `null` when no matches are found in match-all mode). It also lets
 * you override flag g and ignore `lastIndex`, and fixes browser bugs.
 *
 * @memberOf XRegExp
 * @param {String} str String to search.
 * @param {RegExp} regex Regex to search with.
 * @param {String} [scope='one'] Use 'one' to return the first match as a string. Use 'all' to
 *   return an array of all matched strings. If not explicitly specified and `regex` uses flag g,
 *   `scope` is 'all'.
 * @returns {String|Array} In match-first mode: First match as a string, or `null`. In match-all
 *   mode: Array of all matched strings, or an empty array.
 * @example
 *
 * // Match first
 * XRegExp.match('abc', /\w/); // -> 'a'
 * XRegExp.match('abc', /\w/g, 'one'); // -> 'a'
 * XRegExp.match('abc', /x/g, 'one'); // -> null
 *
 * // Match all
 * XRegExp.match('abc', /\w/g); // -> ['a', 'b', 'c']
 * XRegExp.match('abc', /\w/, 'all'); // -> ['a', 'b', 'c']
 * XRegExp.match('abc', /x/, 'all'); // -> []
 */
    self.match = function(str, regex, scope) {
        var global = (regex.global && scope !== 'one') || scope === 'all',
            cacheKey = ((global ? 'g' : '') + (regex.sticky ? 'y' : '')) || 'noGY',
            result,
            r2;

        regex[REGEX_DATA] = regex[REGEX_DATA] || {};

        // Shares cached copies with `XRegExp.exec`/`replace`
        r2 = regex[REGEX_DATA][cacheKey] || (
            regex[REGEX_DATA][cacheKey] = copyRegex(regex, {
                addG: !!global,
                addY: !!regex.sticky,
                removeG: scope === 'one',
                isInternalOnly: true
            })
        );

        result = nativ.match.call(toObject(str), r2);

        if (regex.global) {
            regex.lastIndex = (
                (scope === 'one' && result) ?
                    // Can't use `r2.lastIndex` since `r2` is nonglobal in this case
                    (result.index + result[0].length) : 0
            );
        }

        return global ? (result || []) : (result && result[0]);
    };

/**
 * Retrieves the matches from searching a string using a chain of regexes that successively search
 * within previous matches. The provided `chain` array can contain regexes and objects with `regex`
 * and `backref` properties. When a backreference is specified, the named or numbered backreference
 * is passed forward to the next regex or returned.
 *
 * @memberOf XRegExp
 * @param {String} str String to search.
 * @param {Array} chain Regexes that each search for matches within preceding results.
 * @returns {Array} Matches by the last regex in the chain, or an empty array.
 * @example
 *
 * // Basic usage; matches numbers within <b> tags
 * XRegExp.matchChain('1 <b>2</b> 3 <b>4 a 56</b>', [
 *   XRegExp('(?is)<b>.*?</b>'),
 *   /\d+/
 * ]);
 * // -> ['2', '4', '56']
 *
 * // Passing forward and returning specific backreferences
 * html = '<a href="http://xregexp.com/api/">XRegExp</a>\
 *         <a href="http://www.google.com/">Google</a>';
 * XRegExp.matchChain(html, [
 *   {regex: /<a href="([^"]+)">/i, backref: 1},
 *   {regex: XRegExp('(?i)^https?://(?<domain>[^/?#]+)'), backref: 'domain'}
 * ]);
 * // -> ['xregexp.com', 'www.google.com']
 */
    self.matchChain = function(str, chain) {
        return (function recurseChain(values, level) {
            var item = chain[level].regex ? chain[level] : {regex: chain[level]},
                matches = [],
                addMatch = function(match) {
                    if (item.backref) {
                        /* Safari 4.0.5 (but not 5.0.5+) inappropriately uses sparse arrays to hold
                         * the `undefined`s for backreferences to nonparticipating capturing
                         * groups. In such cases, a `hasOwnProperty` or `in` check on its own would
                         * inappropriately throw the exception, so also check if the backreference
                         * is a number that is within the bounds of the array.
                         */
                        if (!(match.hasOwnProperty(item.backref) || +item.backref < match.length)) {
                            throw new ReferenceError('Backreference to undefined group: ' + item.backref);
                        }

                        matches.push(match[item.backref] || '');
                    } else {
                        matches.push(match[0]);
                    }
                },
                i;

            for (i = 0; i < values.length; ++i) {
                self.forEach(values[i], item.regex, addMatch);
            }

            return ((level === chain.length - 1) || !matches.length) ?
                matches :
                recurseChain(matches, level + 1);
        }([str], 0));
    };

/**
 * Returns a new string with one or all matches of a pattern replaced. The pattern can be a string
 * or regex, and the replacement can be a string or a function to be called for each match. To
 * perform a global search and replace, use the optional `scope` argument or include flag g if using
 * a regex. Replacement strings can use `${n}` for named and numbered backreferences. Replacement
 * functions can use named backreferences via `arguments[0].name`. Also fixes browser bugs compared
 * to the native `String.prototype.replace` and can be used reliably cross-browser.
 *
 * @memberOf XRegExp
 * @param {String} str String to search.
 * @param {RegExp|String} search Search pattern to be replaced.
 * @param {String|Function} replacement Replacement string or a function invoked to create it.
 *   Replacement strings can include special replacement syntax:
 *     <li>$$ - Inserts a literal $ character.
 *     <li>$&, $0 - Inserts the matched substring.
 *     <li>$` - Inserts the string that precedes the matched substring (left context).
 *     <li>$' - Inserts the string that follows the matched substring (right context).
 *     <li>$n, $nn - Where n/nn are digits referencing an existent capturing group, inserts
 *       backreference n/nn.
 *     <li>${n} - Where n is a name or any number of digits that reference an existent capturing
 *       group, inserts backreference n.
 *   Replacement functions are invoked with three or more arguments:
 *     <li>The matched substring (corresponds to $& above). Named backreferences are accessible as
 *       properties of this first argument.
 *     <li>0..n arguments, one for each backreference (corresponding to $1, $2, etc. above).
 *     <li>The zero-based index of the match within the total search string.
 *     <li>The total string being searched.
 * @param {String} [scope='one'] Use 'one' to replace the first match only, or 'all'. If not
 *   explicitly specified and using a regex with flag g, `scope` is 'all'.
 * @returns {String} New string with one or all matches replaced.
 * @example
 *
 * // Regex search, using named backreferences in replacement string
 * var name = XRegExp('(?<first>\\w+) (?<last>\\w+)');
 * XRegExp.replace('John Smith', name, '${last}, ${first}');
 * // -> 'Smith, John'
 *
 * // Regex search, using named backreferences in replacement function
 * XRegExp.replace('John Smith', name, function(match) {
 *   return match.last + ', ' + match.first;
 * });
 * // -> 'Smith, John'
 *
 * // String search, with replace-all
 * XRegExp.replace('RegExp builds RegExps', 'RegExp', 'XRegExp', 'all');
 * // -> 'XRegExp builds XRegExps'
 */
    self.replace = function(str, search, replacement, scope) {
        var isRegex = self.isRegExp(search),
            global = (search.global && scope !== 'one') || scope === 'all',
            cacheKey = ((global ? 'g' : '') + (search.sticky ? 'y' : '')) || 'noGY',
            s2 = search,
            result;

        if (isRegex) {
            search[REGEX_DATA] = search[REGEX_DATA] || {};

            // Shares cached copies with `XRegExp.exec`/`match`. Since a copy is used, `search`'s
            // `lastIndex` isn't updated *during* replacement iterations
            s2 = search[REGEX_DATA][cacheKey] || (
                search[REGEX_DATA][cacheKey] = copyRegex(search, {
                    addG: !!global,
                    addY: !!search.sticky,
                    removeG: scope === 'one',
                    isInternalOnly: true
                })
            );
        } else if (global) {
            s2 = new RegExp(self.escape(String(search)), 'g');
        }

        // Fixed `replace` required for named backreferences, etc.
        result = fixed.replace.call(toObject(str), s2, replacement);

        if (isRegex && search.global) {
            // Fixes IE, Safari bug (last tested IE 9, Safari 5.1)
            search.lastIndex = 0;
        }

        return result;
    };

/**
 * Performs batch processing of string replacements. Used like {@link #XRegExp.replace}, but
 * accepts an array of replacement details. Later replacements operate on the output of earlier
 * replacements. Replacement details are accepted as an array with a regex or string to search for,
 * the replacement string or function, and an optional scope of 'one' or 'all'. Uses the XRegExp
 * replacement text syntax, which supports named backreference properties via `${name}`.
 *
 * @memberOf XRegExp
 * @param {String} str String to search.
 * @param {Array} replacements Array of replacement detail arrays.
 * @returns {String} New string with all replacements.
 * @example
 *
 * str = XRegExp.replaceEach(str, [
 *   [XRegExp('(?<name>a)'), 'z${name}'],
 *   [/b/gi, 'y'],
 *   [/c/g, 'x', 'one'], // scope 'one' overrides /g
 *   [/d/, 'w', 'all'],  // scope 'all' overrides lack of /g
 *   ['e', 'v', 'all'],  // scope 'all' allows replace-all for strings
 *   [/f/g, function($0) {
 *     return $0.toUpperCase();
 *   }]
 * ]);
 */
    self.replaceEach = function(str, replacements) {
        var i, r;

        for (i = 0; i < replacements.length; ++i) {
            r = replacements[i];
            str = self.replace(str, r[0], r[1], r[2]);
        }

        return str;
    };

/**
 * Splits a string into an array of strings using a regex or string separator. Matches of the
 * separator are not included in the result array. However, if `separator` is a regex that contains
 * capturing groups, backreferences are spliced into the result each time `separator` is matched.
 * Fixes browser bugs compared to the native `String.prototype.split` and can be used reliably
 * cross-browser.
 *
 * @memberOf XRegExp
 * @param {String} str String to split.
 * @param {RegExp|String} separator Regex or string to use for separating the string.
 * @param {Number} [limit] Maximum number of items to include in the result array.
 * @returns {Array} Array of substrings.
 * @example
 *
 * // Basic use
 * XRegExp.split('a b c', ' ');
 * // -> ['a', 'b', 'c']
 *
 * // With limit
 * XRegExp.split('a b c', ' ', 2);
 * // -> ['a', 'b']
 *
 * // Backreferences in result array
 * XRegExp.split('..word1..', /([a-z]+)(\d+)/i);
 * // -> ['..', 'word', '1', '..']
 */
    self.split = function(str, separator, limit) {
        return fixed.split.call(toObject(str), separator, limit);
    };

/**
 * Executes a regex search in a specified string. Returns `true` or `false`. Optional `pos` and
 * `sticky` arguments specify the search start position, and whether the match must start at the
 * specified position only. The `lastIndex` property of the provided regex is not used, but is
 * updated for compatibility. Also fixes browser bugs compared to the native
 * `RegExp.prototype.test` and can be used reliably cross-browser.
 *
 * @memberOf XRegExp
 * @param {String} str String to search.
 * @param {RegExp} regex Regex to search with.
 * @param {Number} [pos=0] Zero-based index at which to start the search.
 * @param {Boolean|String} [sticky=false] Whether the match must start at the specified position
 *   only. The string `'sticky'` is accepted as an alternative to `true`.
 * @returns {Boolean} Whether the regex matched the provided value.
 * @example
 *
 * // Basic use
 * XRegExp.test('abc', /c/); // -> true
 *
 * // With pos and sticky
 * XRegExp.test('abc', /c/, 0, 'sticky'); // -> false
 */
    self.test = function(str, regex, pos, sticky) {
        // Do this the easy way :-)
        return !!self.exec(str, regex, pos, sticky);
    };

/**
 * Uninstalls optional features according to the specified options. All optional features start out
 * uninstalled, so this is used to undo the actions of {@link #XRegExp.install}.
 *
 * @memberOf XRegExp
 * @param {Object|String} options Options object or string.
 * @example
 *
 * // With an options object
 * XRegExp.uninstall({
 *   // Disables support for astral code points in Unicode addons
 *   astral: true,
 *
 *   // Restores native regex methods
 *   natives: true
 * });
 *
 * // With an options string
 * XRegExp.uninstall('astral natives');
 */
    self.uninstall = function(options) {
        options = prepareOptions(options);

        if (features.astral && options.astral) {
            setAstral(false);
        }

        if (features.natives && options.natives) {
            setNatives(false);
        }
    };

/**
 * Returns an XRegExp object that is the union of the given patterns. Patterns can be provided as
 * regex objects or strings. Metacharacters are escaped in patterns provided as strings.
 * Backreferences in provided regex objects are automatically renumbered to work correctly within
 * the larger combined pattern. Native flags used by provided regexes are ignored in favor of the
 * `flags` argument.
 *
 * @memberOf XRegExp
 * @param {Array} patterns Regexes and strings to combine.
 * @param {String} [flags] Any combination of XRegExp flags.
 * @returns {RegExp} Union of the provided regexes and strings.
 * @example
 *
 * XRegExp.union(['a+b*c', /(dogs)\1/, /(cats)\1/], 'i');
 * // -> /a\+b\*c|(dogs)\1|(cats)\2/i
 */
    self.union = function(patterns, flags) {
        var parts = /(\()(?!\?)|\\([1-9]\d*)|\\[\s\S]|\[(?:[^\\\]]|\\[\s\S])*]/g,
            output = [],
            numCaptures = 0,
            numPriorCaptures,
            captureNames,
            pattern,
            rewrite = function(match, paren, backref) {
                var name = captureNames[numCaptures - numPriorCaptures];

                // Capturing group
                if (paren) {
                    ++numCaptures;
                    // If the current capture has a name, preserve the name
                    if (name) {
                        return '(?<' + name + '>';
                    }
                // Backreference
                } else if (backref) {
                    // Rewrite the backreference
                    return '\\' + (+backref + numPriorCaptures);
                }

                return match;
            },
            i;

        if (!(isType(patterns, 'Array') && patterns.length)) {
            throw new TypeError('Must provide a nonempty array of patterns to merge');
        }

        for (i = 0; i < patterns.length; ++i) {
            pattern = patterns[i];

            if (self.isRegExp(pattern)) {
                numPriorCaptures = numCaptures;
                captureNames = (pattern[REGEX_DATA] && pattern[REGEX_DATA].captureNames) || [];

                // Rewrite backreferences. Passing to XRegExp dies on octals and ensures patterns
                // are independently valid; helps keep this simple. Named captures are put back
                output.push(nativ.replace.call(self(pattern.source).source, parts, rewrite));
            } else {
                output.push(self.escape(pattern));
            }
        }

        return self(output.join('|'), flags);
    };

/* ==============================
 * Fixed/extended native methods
 * ============================== */

/**
 * Adds named capture support (with backreferences returned as `result.name`), and fixes browser
 * bugs in the native `RegExp.prototype.exec`. Calling `XRegExp.install('natives')` uses this to
 * override the native method. Use via `XRegExp.exec` without overriding natives.
 *
 * @private
 * @param {String} str String to search.
 * @returns {Array} Match array with named backreference properties, or `null`.
 */
    fixed.exec = function(str) {
        var origLastIndex = this.lastIndex,
            match = nativ.exec.apply(this, arguments),
            name,
            r2,
            i;

        if (match) {
            // Fix browsers whose `exec` methods don't return `undefined` for nonparticipating
            // capturing groups. This fixes IE 5.5-8, but not IE 9's quirks mode or emulation of
            // older IEs. IE 9 in standards mode follows the spec
            if (!correctExecNpcg && match.length > 1 && indexOf(match, '') > -1) {
                r2 = copyRegex(this, {
                    removeG: true,
                    isInternalOnly: true
                });
                // Using `str.slice(match.index)` rather than `match[0]` in case lookahead allowed
                // matching due to characters outside the match
                nativ.replace.call(String(str).slice(match.index), r2, function() {
                    var len = arguments.length, i;
                    // Skip index 0 and the last 2
                    for (i = 1; i < len - 2; ++i) {
                        if (arguments[i] === undefined) {
                            match[i] = undefined;
                        }
                    }
                });
            }

            // Attach named capture properties
            if (this[REGEX_DATA] && this[REGEX_DATA].captureNames) {
                // Skip index 0
                for (i = 1; i < match.length; ++i) {
                    name = this[REGEX_DATA].captureNames[i - 1];
                    if (name) {
                        match[name] = match[i];
                    }
                }
            }

            // Fix browsers that increment `lastIndex` after zero-length matches
            if (this.global && !match[0].length && (this.lastIndex > match.index)) {
                this.lastIndex = match.index;
            }
        }

        if (!this.global) {
            // Fixes IE, Opera bug (last tested IE 9, Opera 11.6)
            this.lastIndex = origLastIndex;
        }

        return match;
    };

/**
 * Fixes browser bugs in the native `RegExp.prototype.test`. Calling `XRegExp.install('natives')`
 * uses this to override the native method.
 *
 * @private
 * @param {String} str String to search.
 * @returns {Boolean} Whether the regex matched the provided value.
 */
    fixed.test = function(str) {
        // Do this the easy way :-)
        return !!fixed.exec.call(this, str);
    };

/**
 * Adds named capture support (with backreferences returned as `result.name`), and fixes browser
 * bugs in the native `String.prototype.match`. Calling `XRegExp.install('natives')` uses this to
 * override the native method.
 *
 * @private
 * @param {RegExp|*} regex Regex to search with. If not a regex object, it is passed to `RegExp`.
 * @returns {Array} If `regex` uses flag g, an array of match strings or `null`. Without flag g,
 *   the result of calling `regex.exec(this)`.
 */
    fixed.match = function(regex) {
        var result;

        if (!self.isRegExp(regex)) {
            // Use the native `RegExp` rather than `XRegExp`
            regex = new RegExp(regex);
        } else if (regex.global) {
            result = nativ.match.apply(this, arguments);
            // Fixes IE bug
            regex.lastIndex = 0;

            return result;
        }

        return fixed.exec.call(regex, toObject(this));
    };

/**
 * Adds support for `${n}` tokens for named and numbered backreferences in replacement text, and
 * provides named backreferences to replacement functions as `arguments[0].name`. Also fixes browser
 * bugs in replacement text syntax when performing a replacement using a nonregex search value, and
 * the value of a replacement regex's `lastIndex` property during replacement iterations and upon
 * completion. Calling `XRegExp.install('natives')` uses this to override the native method. Note
 * that this doesn't support SpiderMonkey's proprietary third (`flags`) argument. Use via
 * `XRegExp.replace` without overriding natives.
 *
 * @private
 * @param {RegExp|String} search Search pattern to be replaced.
 * @param {String|Function} replacement Replacement string or a function invoked to create it.
 * @returns {String} New string with one or all matches replaced.
 */
    fixed.replace = function(search, replacement) {
        var isRegex = self.isRegExp(search),
            origLastIndex,
            captureNames,
            result;

        if (isRegex) {
            if (search[REGEX_DATA]) {
                captureNames = search[REGEX_DATA].captureNames;
            }
            // Only needed if `search` is nonglobal
            origLastIndex = search.lastIndex;
        } else {
            search += ''; // Type-convert
        }

        // Don't use `typeof`; some older browsers return 'function' for regex objects
        if (isType(replacement, 'Function')) {
            // Stringifying `this` fixes a bug in IE < 9 where the last argument in replacement
            // functions isn't type-converted to a string
            result = nativ.replace.call(String(this), search, function() {
                var args = arguments, i;
                if (captureNames) {
                    // Change the `arguments[0]` string primitive to a `String` object that can
                    // store properties. This really does need to use `String` as a constructor
                    args[0] = new String(args[0]);
                    // Store named backreferences on the first argument
                    for (i = 0; i < captureNames.length; ++i) {
                        if (captureNames[i]) {
                            args[0][captureNames[i]] = args[i + 1];
                        }
                    }
                }
                // Update `lastIndex` before calling `replacement`. Fixes IE, Chrome, Firefox,
                // Safari bug (last tested IE 9, Chrome 17, Firefox 11, Safari 5.1)
                if (isRegex && search.global) {
                    search.lastIndex = args[args.length - 2] + args[0].length;
                }
                // ES6 specs the context for replacement functions as `undefined`
                return replacement.apply(undefined, args);
            });
        } else {
            // Ensure that the last value of `args` will be a string when given nonstring `this`,
            // while still throwing on null or undefined context
            result = nativ.replace.call(this == null ? this : String(this), search, function() {
                // Keep this function's `arguments` available through closure
                var args = arguments;
                return nativ.replace.call(String(replacement), replacementToken, function($0, $1, $2) {
                    var n;
                    // Named or numbered backreference with curly braces
                    if ($1) {
                        // XRegExp behavior for `${n}`:
                        // 1. Backreference to numbered capture, if `n` is an integer. Use `0` for
                        //    for the entire match. Any number of leading zeros may be used.
                        // 2. Backreference to named capture `n`, if it exists and is not an
                        //    integer overridden by numbered capture. In practice, this does not
                        //    overlap with numbered capture since XRegExp does not allow named
                        //    capture to use a bare integer as the name.
                        // 3. If the name or number does not refer to an existing capturing group,
                        //    it's an error.
                        n = +$1; // Type-convert; drop leading zeros
                        if (n <= args.length - 3) {
                            return args[n] || '';
                        }
                        // Groups with the same name is an error, else would need `lastIndexOf`
                        n = captureNames ? indexOf(captureNames, $1) : -1;
                        if (n < 0) {
                            throw new SyntaxError('Backreference to undefined group ' + $0);
                        }
                        return args[n + 1] || '';
                    }
                    // Else, special variable or numbered backreference without curly braces
                    if ($2 === '$') { // $$
                        return '$';
                    }
                    if ($2 === '&' || +$2 === 0) { // $&, $0 (not followed by 1-9), $00
                        return args[0];
                    }
                    if ($2 === '`') { // $` (left context)
                        return args[args.length - 1].slice(0, args[args.length - 2]);
                    }
                    if ($2 === "'") { // $' (right context)
                        return args[args.length - 1].slice(args[args.length - 2] + args[0].length);
                    }
                    // Else, numbered backreference without curly braces
                    $2 = +$2; // Type-convert; drop leading zero
                    // XRegExp behavior for `$n` and `$nn`:
                    // - Backrefs end after 1 or 2 digits. Use `${..}` for more digits.
                    // - `$1` is an error if no capturing groups.
                    // - `$10` is an error if less than 10 capturing groups. Use `${1}0` instead.
                    // - `$01` is `$1` if at least one capturing group, else it's an error.
                    // - `$0` (not followed by 1-9) and `$00` are the entire match.
                    // Native behavior, for comparison:
                    // - Backrefs end after 1 or 2 digits. Cannot reference capturing group 100+.
                    // - `$1` is a literal `$1` if no capturing groups.
                    // - `$10` is `$1` followed by a literal `0` if less than 10 capturing groups.
                    // - `$01` is `$1` if at least one capturing group, else it's a literal `$01`.
                    // - `$0` is a literal `$0`.
                    if (!isNaN($2)) {
                        if ($2 > args.length - 3) {
                            throw new SyntaxError('Backreference to undefined group ' + $0);
                        }
                        return args[$2] || '';
                    }
                    // `$` followed by an unsupported char is an error, unlike native JS
                    throw new SyntaxError('Invalid token ' + $0);
                });
            });
        }

        if (isRegex) {
            if (search.global) {
                // Fixes IE, Safari bug (last tested IE 9, Safari 5.1)
                search.lastIndex = 0;
            } else {
                // Fixes IE, Opera bug (last tested IE 9, Opera 11.6)
                search.lastIndex = origLastIndex;
            }
        }

        return result;
    };

/**
 * Fixes browser bugs in the native `String.prototype.split`. Calling `XRegExp.install('natives')`
 * uses this to override the native method. Use via `XRegExp.split` without overriding natives.
 *
 * @private
 * @param {RegExp|String} separator Regex or string to use for separating the string.
 * @param {Number} [limit] Maximum number of items to include in the result array.
 * @returns {Array} Array of substrings.
 */
    fixed.split = function(separator, limit) {
        if (!self.isRegExp(separator)) {
            // Browsers handle nonregex split correctly, so use the faster native method
            return nativ.split.apply(this, arguments);
        }

        var str = String(this),
            output = [],
            origLastIndex = separator.lastIndex,
            lastLastIndex = 0,
            lastLength;

        // Values for `limit`, per the spec:
        // If undefined: pow(2,32) - 1
        // If 0, Infinity, or NaN: 0
        // If positive number: limit = floor(limit); if (limit >= pow(2,32)) limit -= pow(2,32);
        // If negative number: pow(2,32) - floor(abs(limit))
        // If other: Type-convert, then use the above rules
        // This line fails in very strange ways for some values of `limit` in Opera 10.5-10.63,
        // unless Opera Dragonfly is open (go figure). It works in at least Opera 9.5-10.1 and 11+
        limit = (limit === undefined ? -1 : limit) >>> 0;

        self.forEach(str, separator, function(match) {
            // This condition is not the same as `if (match[0].length)`
            if ((match.index + match[0].length) > lastLastIndex) {
                output.push(str.slice(lastLastIndex, match.index));
                if (match.length > 1 && match.index < str.length) {
                    Array.prototype.push.apply(output, match.slice(1));
                }
                lastLength = match[0].length;
                lastLastIndex = match.index + lastLength;
            }
        });

        if (lastLastIndex === str.length) {
            if (!nativ.test.call(separator, '') || lastLength) {
                output.push('');
            }
        } else {
            output.push(str.slice(lastLastIndex));
        }

        separator.lastIndex = origLastIndex;
        return output.length > limit ? output.slice(0, limit) : output;
    };

/* ==============================
 * Built-in syntax/flag tokens
 * ============================== */

    add = self.addToken;

/*
 * Letter escapes that natively match literal characters: `\a`, `\A`, etc. These should be
 * SyntaxErrors but are allowed in web reality. XRegExp makes them errors for cross-browser
 * consistency and to reserve their syntax, but lets them be superseded by addons.
 */
    add(
        /\\([ABCE-RTUVXYZaeg-mopqyz]|c(?![A-Za-z])|u(?![\dA-Fa-f]{4}|{[\dA-Fa-f]+})|x(?![\dA-Fa-f]{2}))/,
        function(match, scope) {
            // \B is allowed in default scope only
            if (match[1] === 'B' && scope === defaultScope) {
                return match[0];
            }
            throw new SyntaxError('Invalid escape ' + match[0]);
        },
        {
            scope: 'all',
            leadChar: '\\'
        }
    );

/*
 * Unicode code point escape with curly braces: `\u{N..}`. `N..` is any one or more digit
 * hexadecimal number from 0-10FFFF, and can include leading zeros. Requires the native ES6 `u` flag
 * to support code points greater than U+FFFF. Avoids converting code points above U+FFFF to
 * surrogate pairs (which could be done without flag `u`), since that could lead to broken behavior
 * if you follow a `\u{N..}` token that references a code point above U+FFFF with a quantifier, or
 * if you use the same in a character class.
 */
    add(
        /\\u{([\dA-Fa-f]+)}/,
        function(match, scope, flags) {
            var code = dec(match[1]);
            if (code > 0x10FFFF) {
                throw new SyntaxError('Invalid Unicode code point ' + match[0]);
            }
            if (code <= 0xFFFF) {
                // Converting to \uNNNN avoids needing to escape the literal character and keep it
                // separate from preceding tokens
                return '\\u' + pad4(hex(code));
            }
            // If `code` is between 0xFFFF and 0x10FFFF, require and defer to native handling
            if (hasNativeU && flags.indexOf('u') > -1) {
                return match[0];
            }
            throw new SyntaxError('Cannot use Unicode code point above \\u{FFFF} without flag u');
        },
        {
            scope: 'all',
            leadChar: '\\'
        }
    );

/*
 * Empty character class: `[]` or `[^]`. This fixes a critical cross-browser syntax inconsistency.
 * Unless this is standardized (per the ES spec), regex syntax can't be accurately parsed because
 * character class endings can't be determined.
 */
    add(
        /\[(\^?)]/,
        function(match) {
            // For cross-browser compatibility with ES3, convert [] to \b\B and [^] to [\s\S].
            // (?!) should work like \b\B, but is unreliable in some versions of Firefox
            return match[1] ? '[\\s\\S]' : '\\b\\B';
        },
        {leadChar: '['}
    );

/*
 * Comment pattern: `(?# )`. Inline comments are an alternative to the line comments allowed in
 * free-spacing mode (flag x).
 */
    add(
        /\(\?#[^)]*\)/,
        function(match, scope, flags) {
            // Keep tokens separated unless the following token is a quantifier
            return isQuantifierNext(match.input, match.index + match[0].length, flags) ?
                '' : '(?:)';
        },
        {leadChar: '('}
    );

/*
 * Whitespace and line comments, in free-spacing mode (aka extended mode, flag x) only.
 */
    add(
        /\s+|#.*/,
        function(match, scope, flags) {
            // Keep tokens separated unless the following token is a quantifier
            return isQuantifierNext(match.input, match.index + match[0].length, flags) ?
                '' : '(?:)';
        },
        {flag: 'x'}
    );

/*
 * Dot, in dotall mode (aka singleline mode, flag s) only.
 */
    add(
        /\./,
        function() {
            return '[\\s\\S]';
        },
        {
            flag: 's',
            leadChar: '.'
        }
    );

/*
 * Named backreference: `\k<name>`. Backreference names can use the characters A-Z, a-z, 0-9, _,
 * and $ only. Also allows numbered backreferences as `\k<n>`.
 */
    add(
        /\\k<([\w$]+)>/,
        function(match) {
            // Groups with the same name is an error, else would need `lastIndexOf`
            var index = isNaN(match[1]) ? (indexOf(this.captureNames, match[1]) + 1) : +match[1],
                endIndex = match.index + match[0].length;
            if (!index || index > this.captureNames.length) {
                throw new SyntaxError('Backreference to undefined group ' + match[0]);
            }
            // Keep backreferences separate from subsequent literal numbers
            return '\\' + index + (
                endIndex === match.input.length || isNaN(match.input.charAt(endIndex)) ?
                    '' : '(?:)'
            );
        },
        {leadChar: '\\'}
    );

/*
 * Numbered backreference or octal, plus any following digits: `\0`, `\11`, etc. Octals except `\0`
 * not followed by 0-9 and backreferences to unopened capture groups throw an error. Other matches
 * are returned unaltered. IE < 9 doesn't support backreferences above `\99` in regex syntax.
 */
    add(
        /\\(\d+)/,
        function(match, scope) {
            if (
                !(
                    scope === defaultScope &&
                    /^[1-9]/.test(match[1]) &&
                    +match[1] <= this.captureNames.length
                ) &&
                match[1] !== '0'
            ) {
                throw new SyntaxError('Cannot use octal escape or backreference to undefined group ' +
                    match[0]);
            }
            return match[0];
        },
        {
            scope: 'all',
            leadChar: '\\'
        }
    );

/*
 * Named capturing group; match the opening delimiter only: `(?<name>`. Capture names can use the
 * characters A-Z, a-z, 0-9, _, and $ only. Names can't be integers. Supports Python-style
 * `(?P<name>` as an alternate syntax to avoid issues in some older versions of Opera which natively
 * supported the Python-style syntax. Otherwise, XRegExp might treat numbered backreferences to
 * Python-style named capture as octals.
 */
    add(
        /\(\?P?<([\w$]+)>/,
        function(match) {
            // Disallow bare integers as names because named backreferences are added to match
            // arrays and therefore numeric properties may lead to incorrect lookups
            if (!isNaN(match[1])) {
                throw new SyntaxError('Cannot use integer as capture name ' + match[0]);
            }
            if (match[1] === 'length' || match[1] === '__proto__') {
                throw new SyntaxError('Cannot use reserved word as capture name ' + match[0]);
            }
            if (indexOf(this.captureNames, match[1]) > -1) {
                throw new SyntaxError('Cannot use same name for multiple groups ' + match[0]);
            }
            this.captureNames.push(match[1]);
            this.hasNamedCapture = true;
            return '(';
        },
        {leadChar: '('}
    );

/*
 * Capturing group; match the opening parenthesis only. Required for support of named capturing
 * groups. Also adds explicit capture mode (flag n).
 */
    add(
        /\((?!\?)/,
        function(match, scope, flags) {
            if (flags.indexOf('n') > -1) {
                return '(?:';
            }
            this.captureNames.push(null);
            return '(';
        },
        {
            optionalFlags: 'n',
            leadChar: '('
        }
    );

/* ==============================
 * Expose XRegExp
 * ============================== */

    return self;

}());

/*!
 * XRegExp.build 3.0.0
 * <http://xregexp.com/>
 * Steven Levithan (c) 2012-2015 MIT License
 * Inspired by Lea Verou's RegExp.create <http://lea.verou.me/>
 */

(function(XRegExp) {
    'use strict';

    var REGEX_DATA = 'xregexp',
        subParts = /(\()(?!\?)|\\([1-9]\d*)|\\[\s\S]|\[(?:[^\\\]]|\\[\s\S])*]/g,
        parts = XRegExp.union([/\({{([\w$]+)}}\)|{{([\w$]+)}}/, subParts], 'g');

/**
 * Strips a leading `^` and trailing unescaped `$`, if both are present.
 *
 * @private
 * @param {String} pattern Pattern to process.
 * @returns {String} Pattern with edge anchors removed.
 */
    function deanchor(pattern) {
        var leadingAnchor = /^\^/,
            trailingAnchor = /\$$/;

        // Ensure that the trailing `$` isn't escaped
        if (leadingAnchor.test(pattern) && trailingAnchor.test(pattern.replace(/\\[\s\S]/g, ''))) {
            return pattern.replace(leadingAnchor, '').replace(trailingAnchor, '');
        }

        return pattern;
    }

/**
 * Converts the provided value to an XRegExp. Native RegExp flags are not preserved.
 *
 * @private
 * @param {String|RegExp} value Value to convert.
 * @returns {RegExp} XRegExp object with XRegExp syntax applied.
 */
    function asXRegExp(value) {
        return XRegExp.isRegExp(value) ?
            (value[REGEX_DATA] && value[REGEX_DATA].captureNames ?
                // Don't recompile, to preserve capture names
                value :
                // Recompile as XRegExp
                XRegExp(value.source)
            ) :
            // Compile string as XRegExp
            XRegExp(value);
    }

/**
 * Builds regexes using named subpatterns, for readability and pattern reuse. Backreferences in the
 * outer pattern and provided subpatterns are automatically renumbered to work correctly. Native
 * flags used by provided subpatterns are ignored in favor of the `flags` argument.
 *
 * @memberOf XRegExp
 * @param {String} pattern XRegExp pattern using `{{name}}` for embedded subpatterns. Allows
 *   `({{name}})` as shorthand for `(?<name>{{name}})`. Patterns cannot be embedded within
 *   character classes.
 * @param {Object} subs Lookup object for named subpatterns. Values can be strings or regexes. A
 *   leading `^` and trailing unescaped `$` are stripped from subpatterns, if both are present.
 * @param {String} [flags] Any combination of XRegExp flags.
 * @returns {RegExp} Regex with interpolated subpatterns.
 * @example
 *
 * var time = XRegExp.build('(?x)^ {{hours}} ({{minutes}}) $', {
 *   hours: XRegExp.build('{{h12}} : | {{h24}}', {
 *     h12: /1[0-2]|0?[1-9]/,
 *     h24: /2[0-3]|[01][0-9]/
 *   }, 'x'),
 *   minutes: /^[0-5][0-9]$/
 * });
 * time.test('10:59'); // -> true
 * XRegExp.exec('10:59', time).minutes; // -> '59'
 */
    XRegExp.build = function(pattern, subs, flags) {
        var inlineFlags = /^\(\?([\w$]+)\)/.exec(pattern),
            data = {},
            numCaps = 0, // 'Caps' is short for captures
            numPriorCaps,
            numOuterCaps = 0,
            outerCapsMap = [0],
            outerCapNames,
            sub,
            p;

        // Add flags within a leading mode modifier to the overall pattern's flags
        if (inlineFlags) {
            flags = flags || '';
            inlineFlags[1].replace(/./g, function(flag) {
                // Don't add duplicates
                flags += (flags.indexOf(flag) > -1 ? '' : flag);
            });
        }

        for (p in subs) {
            if (subs.hasOwnProperty(p)) {
                // Passing to XRegExp enables extended syntax and ensures independent validity,
                // lest an unescaped `(`, `)`, `[`, or trailing `\` breaks the `(?:)` wrapper. For
                // subpatterns provided as native regexes, it dies on octals and adds the property
                // used to hold extended regex instance data, for simplicity
                sub = asXRegExp(subs[p]);
                data[p] = {
                    // Deanchoring allows embedding independently useful anchored regexes. If you
                    // really need to keep your anchors, double them (i.e., `^^...$$`)
                    pattern: deanchor(sub.source),
                    names: sub[REGEX_DATA].captureNames || []
                };
            }
        }

        // Passing to XRegExp dies on octals and ensures the outer pattern is independently valid;
        // helps keep this simple. Named captures will be put back
        pattern = asXRegExp(pattern);
        outerCapNames = pattern[REGEX_DATA].captureNames || [];
        pattern = pattern.source.replace(parts, function($0, $1, $2, $3, $4) {
            var subName = $1 || $2, capName, intro;
            // Named subpattern
            if (subName) {
                if (!data.hasOwnProperty(subName)) {
                    throw new ReferenceError('Undefined property ' + $0);
                }
                // Named subpattern was wrapped in a capturing group
                if ($1) {
                    capName = outerCapNames[numOuterCaps];
                    outerCapsMap[++numOuterCaps] = ++numCaps;
                    // If it's a named group, preserve the name. Otherwise, use the subpattern name
                    // as the capture name
                    intro = '(?<' + (capName || subName) + '>';
                } else {
                    intro = '(?:';
                }
                numPriorCaps = numCaps;
                return intro + data[subName].pattern.replace(subParts, function(match, paren, backref) {
                    // Capturing group
                    if (paren) {
                        capName = data[subName].names[numCaps - numPriorCaps];
                        ++numCaps;
                        // If the current capture has a name, preserve the name
                        if (capName) {
                            return '(?<' + capName + '>';
                        }
                    // Backreference
                    } else if (backref) {
                        // Rewrite the backreference
                        return '\\' + (+backref + numPriorCaps);
                    }
                    return match;
                }) + ')';
            }
            // Capturing group
            if ($3) {
                capName = outerCapNames[numOuterCaps];
                outerCapsMap[++numOuterCaps] = ++numCaps;
                // If the current capture has a name, preserve the name
                if (capName) {
                    return '(?<' + capName + '>';
                }
            // Backreference
            } else if ($4) {
                // Rewrite the backreference
                return '\\' + outerCapsMap[+$4];
            }
            return $0;
        });

        return XRegExp(pattern, flags);
    };

}(XRegExp));

/*!
 * XRegExp.matchRecursive 3.0.0
 * <http://xregexp.com/>
 * Steven Levithan (c) 2009-2015 MIT License
 */

(function(XRegExp) {
    'use strict';

/**
 * Returns a match detail object composed of the provided values.
 *
 * @private
 */
    function row(name, value, start, end) {
        return {
            name: name,
            value: value,
            start: start,
            end: end
        };
    }

/**
 * Returns an array of match strings between outermost left and right delimiters, or an array of
 * objects with detailed match parts and position data. An error is thrown if delimiters are
 * unbalanced within the data.
 *
 * @memberOf XRegExp
 * @param {String} str String to search.
 * @param {String} left Left delimiter as an XRegExp pattern.
 * @param {String} right Right delimiter as an XRegExp pattern.
 * @param {String} [flags] Any native or XRegExp flags, used for the left and right delimiters.
 * @param {Object} [options] Lets you specify `valueNames` and `escapeChar` options.
 * @returns {Array} Array of matches, or an empty array.
 * @example
 *
 * // Basic usage
 * var str = '(t((e))s)t()(ing)';
 * XRegExp.matchRecursive(str, '\\(', '\\)', 'g');
 * // -> ['t((e))s', '', 'ing']
 *
 * // Extended information mode with valueNames
 * str = 'Here is <div> <div>an</div></div> example';
 * XRegExp.matchRecursive(str, '<div\\s*>', '</div>', 'gi', {
 *   valueNames: ['between', 'left', 'match', 'right']
 * });
 * // -> [
 * // {name: 'between', value: 'Here is ',       start: 0,  end: 8},
 * // {name: 'left',    value: '<div>',          start: 8,  end: 13},
 * // {name: 'match',   value: ' <div>an</div>', start: 13, end: 27},
 * // {name: 'right',   value: '</div>',         start: 27, end: 33},
 * // {name: 'between', value: ' example',       start: 33, end: 41}
 * // ]
 *
 * // Omitting unneeded parts with null valueNames, and using escapeChar
 * str = '...{1}\\{{function(x,y){return y+x;}}';
 * XRegExp.matchRecursive(str, '{', '}', 'g', {
 *   valueNames: ['literal', null, 'value', null],
 *   escapeChar: '\\'
 * });
 * // -> [
 * // {name: 'literal', value: '...', start: 0, end: 3},
 * // {name: 'value',   value: '1',   start: 4, end: 5},
 * // {name: 'literal', value: '\\{', start: 6, end: 8},
 * // {name: 'value',   value: 'function(x,y){return y+x;}', start: 9, end: 35}
 * // ]
 *
 * // Sticky mode via flag y
 * str = '<1><<<2>>><3>4<5>';
 * XRegExp.matchRecursive(str, '<', '>', 'gy');
 * // -> ['1', '<<2>>', '3']
 */
    XRegExp.matchRecursive = function(str, left, right, flags, options) {
        flags = flags || '';
        options = options || {};
        var global = flags.indexOf('g') > -1,
            sticky = flags.indexOf('y') > -1,
            // Flag `y` is controlled internally
            basicFlags = flags.replace(/y/g, ''),
            escapeChar = options.escapeChar,
            vN = options.valueNames,
            output = [],
            openTokens = 0,
            delimStart = 0,
            delimEnd = 0,
            lastOuterEnd = 0,
            outerStart,
            innerStart,
            leftMatch,
            rightMatch,
            esc;
        left = XRegExp(left, basicFlags);
        right = XRegExp(right, basicFlags);

        if (escapeChar) {
            if (escapeChar.length > 1) {
                throw new Error('Cannot use more than one escape character');
            }
            escapeChar = XRegExp.escape(escapeChar);
            // Using `XRegExp.union` safely rewrites backreferences in `left` and `right`
            esc = new RegExp(
                '(?:' + escapeChar + '[\\S\\s]|(?:(?!' +
                    XRegExp.union([left, right]).source +
                    ')[^' + escapeChar + '])+)+',
                // Flags `gy` not needed here
                flags.replace(/[^imu]+/g, '')
            );
        }

        while (true) {
            // If using an escape character, advance to the delimiter's next starting position,
            // skipping any escaped characters in between
            if (escapeChar) {
                delimEnd += (XRegExp.exec(str, esc, delimEnd, 'sticky') || [''])[0].length;
            }
            leftMatch = XRegExp.exec(str, left, delimEnd);
            rightMatch = XRegExp.exec(str, right, delimEnd);
            // Keep the leftmost match only
            if (leftMatch && rightMatch) {
                if (leftMatch.index <= rightMatch.index) {
                    rightMatch = null;
                } else {
                    leftMatch = null;
                }
            }
            // Paths (LM: leftMatch, RM: rightMatch, OT: openTokens):
            // LM | RM | OT | Result
            // 1  | 0  | 1  | loop
            // 1  | 0  | 0  | loop
            // 0  | 1  | 1  | loop
            // 0  | 1  | 0  | throw
            // 0  | 0  | 1  | throw
            // 0  | 0  | 0  | break
            // The paths above don't include the sticky mode special case. The loop ends after the
            // first completed match if not `global`.
            if (leftMatch || rightMatch) {
                delimStart = (leftMatch || rightMatch).index;
                delimEnd = delimStart + (leftMatch || rightMatch)[0].length;
            } else if (!openTokens) {
                break;
            }
            if (sticky && !openTokens && delimStart > lastOuterEnd) {
                break;
            }
            if (leftMatch) {
                if (!openTokens) {
                    outerStart = delimStart;
                    innerStart = delimEnd;
                }
                ++openTokens;
            } else if (rightMatch && openTokens) {
                if (!--openTokens) {
                    if (vN) {
                        if (vN[0] && outerStart > lastOuterEnd) {
                            output.push(row(vN[0], str.slice(lastOuterEnd, outerStart), lastOuterEnd, outerStart));
                        }
                        if (vN[1]) {
                            output.push(row(vN[1], str.slice(outerStart, innerStart), outerStart, innerStart));
                        }
                        if (vN[2]) {
                            output.push(row(vN[2], str.slice(innerStart, delimStart), innerStart, delimStart));
                        }
                        if (vN[3]) {
                            output.push(row(vN[3], str.slice(delimStart, delimEnd), delimStart, delimEnd));
                        }
                    } else {
                        output.push(str.slice(innerStart, delimStart));
                    }
                    lastOuterEnd = delimEnd;
                    if (!global) {
                        break;
                    }
                }
            } else {
                throw new Error('Unbalanced delimiter found in string');
            }
            // If the delimiter matched an empty string, avoid an infinite loop
            if (delimStart === delimEnd) {
                ++delimEnd;
            }
        }

        if (global && !sticky && vN && vN[0] && str.length > lastOuterEnd) {
            output.push(row(vN[0], str.slice(lastOuterEnd), lastOuterEnd, str.length));
        }

        return output;
    };

}(XRegExp));

/*!
 * XRegExp Unicode Base 3.0.0
 * <http://xregexp.com/>
 * Steven Levithan (c) 2008-2015 MIT License
 */

/**
 * Adds base support for Unicode matching:
 * - Adds syntax `\p{..}` for matching Unicode tokens. Tokens can be inverted using `\P{..}` or
 *   `\p{^..}`. Token names ignore case, spaces, hyphens, and underscores. You can omit the brackets
 *   for token names that are a single letter (e.g. `\pL` or `PL`).
 * - Adds flag A (astral), which enables 21-bit Unicode support.
 * - Adds the `XRegExp.addUnicodeData` method used by other addons to provide character data.
 *
 * Unicode Base relies on externally provided Unicode character data. Official addons are available
 * to provide data for Unicode categories, scripts, blocks, and properties.
 *
 * @requires XRegExp
 */
(function(XRegExp) {
    'use strict';

// Storage for Unicode data
    var unicode = {};

/* ==============================
 * Private functions
 * ============================== */

// Generates a token lookup name: lowercase, with hyphens, spaces, and underscores removed
    function normalize(name) {
        return name.replace(/[- _]+/g, '').toLowerCase();
    }

// Adds leading zeros if shorter than four characters
    function pad4(str) {
        while (str.length < 4) {
            str = '0' + str;
        }
        return str;
    }

// Converts a hexadecimal number to decimal
    function dec(hex) {
        return parseInt(hex, 16);
    }

// Converts a decimal number to hexadecimal
    function hex(dec) {
        return parseInt(dec, 10).toString(16);
    }

// Gets the decimal code of a literal code unit, \xHH, \uHHHH, or a backslash-escaped literal
    function charCode(chr) {
        var esc = /^\\[xu](.+)/.exec(chr);
        return esc ?
            dec(esc[1]) :
            chr.charCodeAt(chr.charAt(0) === '\\' ? 1 : 0);
    }

// Inverts a list of ordered BMP characters and ranges
    function invertBmp(range) {
        var output = '',
            lastEnd = -1,
            start;
        XRegExp.forEach(range, /(\\x..|\\u....|\\?[\s\S])(?:-(\\x..|\\u....|\\?[\s\S]))?/, function(m) {
            start = charCode(m[1]);
            if (start > (lastEnd + 1)) {
                output += '\\u' + pad4(hex(lastEnd + 1));
                if (start > (lastEnd + 2)) {
                    output += '-\\u' + pad4(hex(start - 1));
                }
            }
            lastEnd = charCode(m[2] || m[1]);
        });
        if (lastEnd < 0xFFFF) {
            output += '\\u' + pad4(hex(lastEnd + 1));
            if (lastEnd < 0xFFFE) {
                output += '-\\uFFFF';
            }
        }
        return output;
    }

// Generates an inverted BMP range on first use
    function cacheInvertedBmp(slug) {
        var prop = 'b!';
        return unicode[slug][prop] || (
            unicode[slug][prop] = invertBmp(unicode[slug].bmp)
        );
    }

// Combines and optionally negates BMP and astral data
    function buildAstral(slug, isNegated) {
        var item = unicode[slug],
            combined = '';
        if (item.bmp && !item.isBmpLast) {
            combined = '[' + item.bmp + ']' + (item.astral ? '|' : '');
        }
        if (item.astral) {
            combined += item.astral;
        }
        if (item.isBmpLast && item.bmp) {
            combined += (item.astral ? '|' : '') + '[' + item.bmp + ']';
        }
        // Astral Unicode tokens always match a code point, never a code unit
        return isNegated ?
            '(?:(?!' + combined + ')(?:[\uD800-\uDBFF][\uDC00-\uDFFF]|[\0-\uFFFF]))' :
            '(?:' + combined + ')';
    }

// Builds a complete astral pattern on first use
    function cacheAstral(slug, isNegated) {
        var prop = isNegated ? 'a!' : 'a=';
        return unicode[slug][prop] || (
            unicode[slug][prop] = buildAstral(slug, isNegated)
        );
    }

/* ==============================
 * Core functionality
 * ============================== */

/*
 * Add Unicode token syntax: \p{..}, \P{..}, \p{^..}. Also add astral mode (flag A).
 */
    XRegExp.addToken(
        // Use `*` instead of `+` to avoid capturing `^` as the token name in `\p{^}`
        /\\([pP])(?:{(\^?)([^}]*)}|([A-Za-z]))/,
        function(match, scope, flags) {
            var ERR_DOUBLE_NEG = 'Invalid double negation ',
                ERR_UNKNOWN_NAME = 'Unknown Unicode token ',
                ERR_UNKNOWN_REF = 'Unicode token missing data ',
                ERR_ASTRAL_ONLY = 'Astral mode required for Unicode token ',
                ERR_ASTRAL_IN_CLASS = 'Astral mode does not support Unicode tokens within character classes',
                // Negated via \P{..} or \p{^..}
                isNegated = match[1] === 'P' || !!match[2],
                // Switch from BMP (0-FFFF) to astral (0-10FFFF) mode via flag A
                isAstralMode = flags.indexOf('A') > -1,
                // Token lookup name. Check `[4]` first to avoid passing `undefined` via `\p{}`
                slug = normalize(match[4] || match[3]),
                // Token data object
                item = unicode[slug];

            if (match[1] === 'P' && match[2]) {
                throw new SyntaxError(ERR_DOUBLE_NEG + match[0]);
            }
            if (!unicode.hasOwnProperty(slug)) {
                throw new SyntaxError(ERR_UNKNOWN_NAME + match[0]);
            }

            // Switch to the negated form of the referenced Unicode token
            if (item.inverseOf) {
                slug = normalize(item.inverseOf);
                if (!unicode.hasOwnProperty(slug)) {
                    throw new ReferenceError(ERR_UNKNOWN_REF + match[0] + ' -> ' + item.inverseOf);
                }
                item = unicode[slug];
                isNegated = !isNegated;
            }

            if (!(item.bmp || isAstralMode)) {
                throw new SyntaxError(ERR_ASTRAL_ONLY + match[0]);
            }
            if (isAstralMode) {
                if (scope === 'class') {
                    throw new SyntaxError(ERR_ASTRAL_IN_CLASS);
                }

                return cacheAstral(slug, isNegated);
            }

            return scope === 'class' ?
                (isNegated ? cacheInvertedBmp(slug) : item.bmp) :
                (isNegated ? '[^' : '[') + item.bmp + ']';
        },
        {
            scope: 'all',
            optionalFlags: 'A',
            leadChar: '\\'
        }
    );

/**
 * Adds to the list of Unicode tokens that XRegExp regexes can match via `\p` or `\P`.
 *
 * @memberOf XRegExp
 * @param {Array} data Objects with named character ranges. Each object may have properties `name`,
 *   `alias`, `isBmpLast`, `inverseOf`, `bmp`, and `astral`. All but `name` are optional, although
 *   one of `bmp` or `astral` is required (unless `inverseOf` is set). If `astral` is absent, the
 *   `bmp` data is used for BMP and astral modes. If `bmp` is absent, the name errors in BMP mode
 *   but works in astral mode. If both `bmp` and `astral` are provided, the `bmp` data only is used
 *   in BMP mode, and the combination of `bmp` and `astral` data is used in astral mode.
 *   `isBmpLast` is needed when a token matches orphan high surrogates *and* uses surrogate pairs
 *   to match astral code points. The `bmp` and `astral` data should be a combination of literal
 *   characters and `\xHH` or `\uHHHH` escape sequences, with hyphens to create ranges. Any regex
 *   metacharacters in the data should be escaped, apart from range-creating hyphens. The `astral`
 *   data can additionally use character classes and alternation, and should use surrogate pairs to
 *   represent astral code points. `inverseOf` can be used to avoid duplicating character data if a
 *   Unicode token is defined as the exact inverse of another token.
 * @example
 *
 * // Basic use
 * XRegExp.addUnicodeData([{
 *   name: 'XDigit',
 *   alias: 'Hexadecimal',
 *   bmp: '0-9A-Fa-f'
 * }]);
 * XRegExp('\\p{XDigit}:\\p{Hexadecimal}+').test('0:3D'); // -> true
 */
    XRegExp.addUnicodeData = function(data) {
        var ERR_NO_NAME = 'Unicode token requires name',
            ERR_NO_DATA = 'Unicode token has no character data ',
            item,
            i;

        for (i = 0; i < data.length; ++i) {
            item = data[i];
            if (!item.name) {
                throw new Error(ERR_NO_NAME);
            }
            if (!(item.inverseOf || item.bmp || item.astral)) {
                throw new Error(ERR_NO_DATA + item.name);
            }
            unicode[normalize(item.name)] = item;
            if (item.alias) {
                unicode[normalize(item.alias)] = item;
            }
        }

        // Reset the pattern cache used by the `XRegExp` constructor, since the same pattern and
        // flags might now produce different results
        XRegExp.cache.flush('patterns');
    };

}(XRegExp));

/*!
 * XRegExp Unicode Blocks 3.0.0
 * <http://xregexp.com/>
 * Steven Levithan (c) 2010-2015 MIT License
 * Unicode data provided by Mathias Bynens <http://mathiasbynens.be/>
 */

/**
 * Adds support for all Unicode blocks. Block names use the prefix 'In'. E.g., `\p{InBasicLatin}`.
 * Token names are case insensitive, and any spaces, hyphens, and underscores are ignored.
 *
 * Uses Unicode 8.0.0.
 *
 * @requires XRegExp, Unicode Base
 */
(function(XRegExp) {
    'use strict';

    if (!XRegExp.addUnicodeData) {
        throw new ReferenceError('Unicode Base must be loaded before Unicode Blocks');
    }

    XRegExp.addUnicodeData([
        {
            name: 'InAegean_Numbers',
            astral: '\uD800[\uDD00-\uDD3F]'
        },
        {
            name: 'InAhom',
            astral: '\uD805[\uDF00-\uDF3F]'
        },
        {
            name: 'InAlchemical_Symbols',
            astral: '\uD83D[\uDF00-\uDF7F]'
        },
        {
            name: 'InAlphabetic_Presentation_Forms',
            bmp: '\uFB00-\uFB4F'
        },
        {
            name: 'InAnatolian_Hieroglyphs',
            astral: '\uD811[\uDC00-\uDE7F]'
        },
        {
            name: 'InAncient_Greek_Musical_Notation',
            astral: '\uD834[\uDE00-\uDE4F]'
        },
        {
            name: 'InAncient_Greek_Numbers',
            astral: '\uD800[\uDD40-\uDD8F]'
        },
        {
            name: 'InAncient_Symbols',
            astral: '\uD800[\uDD90-\uDDCF]'
        },
        {
            name: 'InArabic',
            bmp: '\u0600-\u06FF'
        },
        {
            name: 'InArabic_Extended_A',
            bmp: '\u08A0-\u08FF'
        },
        {
            name: 'InArabic_Mathematical_Alphabetic_Symbols',
            astral: '\uD83B[\uDE00-\uDEFF]'
        },
        {
            name: 'InArabic_Presentation_Forms_A',
            bmp: '\uFB50-\uFDFF'
        },
        {
            name: 'InArabic_Presentation_Forms_B',
            bmp: '\uFE70-\uFEFF'
        },
        {
            name: 'InArabic_Supplement',
            bmp: '\u0750-\u077F'
        },
        {
            name: 'InArmenian',
            bmp: '\u0530-\u058F'
        },
        {
            name: 'InArrows',
            bmp: '\u2190-\u21FF'
        },
        {
            name: 'InAvestan',
            astral: '\uD802[\uDF00-\uDF3F]'
        },
        {
            name: 'InBalinese',
            bmp: '\u1B00-\u1B7F'
        },
        {
            name: 'InBamum',
            bmp: '\uA6A0-\uA6FF'
        },
        {
            name: 'InBamum_Supplement',
            astral: '\uD81A[\uDC00-\uDE3F]'
        },
        {
            name: 'InBasic_Latin',
            bmp: '\0-\x7F'
        },
        {
            name: 'InBassa_Vah',
            astral: '\uD81A[\uDED0-\uDEFF]'
        },
        {
            name: 'InBatak',
            bmp: '\u1BC0-\u1BFF'
        },
        {
            name: 'InBengali',
            bmp: '\u0980-\u09FF'
        },
        {
            name: 'InBlock_Elements',
            bmp: '\u2580-\u259F'
        },
        {
            name: 'InBopomofo',
            bmp: '\u3100-\u312F'
        },
        {
            name: 'InBopomofo_Extended',
            bmp: '\u31A0-\u31BF'
        },
        {
            name: 'InBox_Drawing',
            bmp: '\u2500-\u257F'
        },
        {
            name: 'InBrahmi',
            astral: '\uD804[\uDC00-\uDC7F]'
        },
        {
            name: 'InBraille_Patterns',
            bmp: '\u2800-\u28FF'
        },
        {
            name: 'InBuginese',
            bmp: '\u1A00-\u1A1F'
        },
        {
            name: 'InBuhid',
            bmp: '\u1740-\u175F'
        },
        {
            name: 'InByzantine_Musical_Symbols',
            astral: '\uD834[\uDC00-\uDCFF]'
        },
        {
            name: 'InCJK_Compatibility',
            bmp: '\u3300-\u33FF'
        },
        {
            name: 'InCJK_Compatibility_Forms',
            bmp: '\uFE30-\uFE4F'
        },
        {
            name: 'InCJK_Compatibility_Ideographs',
            bmp: '\uF900-\uFAFF'
        },
        {
            name: 'InCJK_Compatibility_Ideographs_Supplement',
            astral: '\uD87E[\uDC00-\uDE1F]'
        },
        {
            name: 'InCJK_Radicals_Supplement',
            bmp: '\u2E80-\u2EFF'
        },
        {
            name: 'InCJK_Strokes',
            bmp: '\u31C0-\u31EF'
        },
        {
            name: 'InCJK_Symbols_and_Punctuation',
            bmp: '\u3000-\u303F'
        },
        {
            name: 'InCJK_Unified_Ideographs',
            bmp: '\u4E00-\u9FFF'
        },
        {
            name: 'InCJK_Unified_Ideographs_Extension_A',
            bmp: '\u3400-\u4DBF'
        },
        {
            name: 'InCJK_Unified_Ideographs_Extension_B',
            astral: '[\uD840-\uD868][\uDC00-\uDFFF]|\uD869[\uDC00-\uDEDF]'
        },
        {
            name: 'InCJK_Unified_Ideographs_Extension_C',
            astral: '\uD86D[\uDC00-\uDF3F]|[\uD86A-\uD86C][\uDC00-\uDFFF]|\uD869[\uDF00-\uDFFF]'
        },
        {
            name: 'InCJK_Unified_Ideographs_Extension_D',
            astral: '\uD86D[\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1F]'
        },
        {
            name: 'InCJK_Unified_Ideographs_Extension_E',
            astral: '[\uD86F-\uD872][\uDC00-\uDFFF]|\uD873[\uDC00-\uDEAF]|\uD86E[\uDC20-\uDFFF]'
        },
        {
            name: 'InCarian',
            astral: '\uD800[\uDEA0-\uDEDF]'
        },
        {
            name: 'InCaucasian_Albanian',
            astral: '\uD801[\uDD30-\uDD6F]'
        },
        {
            name: 'InChakma',
            astral: '\uD804[\uDD00-\uDD4F]'
        },
        {
            name: 'InCham',
            bmp: '\uAA00-\uAA5F'
        },
        {
            name: 'InCherokee',
            bmp: '\u13A0-\u13FF'
        },
        {
            name: 'InCherokee_Supplement',
            bmp: '\uAB70-\uABBF'
        },
        {
            name: 'InCombining_Diacritical_Marks',
            bmp: '\u0300-\u036F'
        },
        {
            name: 'InCombining_Diacritical_Marks_Extended',
            bmp: '\u1AB0-\u1AFF'
        },
        {
            name: 'InCombining_Diacritical_Marks_Supplement',
            bmp: '\u1DC0-\u1DFF'
        },
        {
            name: 'InCombining_Diacritical_Marks_for_Symbols',
            bmp: '\u20D0-\u20FF'
        },
        {
            name: 'InCombining_Half_Marks',
            bmp: '\uFE20-\uFE2F'
        },
        {
            name: 'InCommon_Indic_Number_Forms',
            bmp: '\uA830-\uA83F'
        },
        {
            name: 'InControl_Pictures',
            bmp: '\u2400-\u243F'
        },
        {
            name: 'InCoptic',
            bmp: '\u2C80-\u2CFF'
        },
        {
            name: 'InCoptic_Epact_Numbers',
            astral: '\uD800[\uDEE0-\uDEFF]'
        },
        {
            name: 'InCounting_Rod_Numerals',
            astral: '\uD834[\uDF60-\uDF7F]'
        },
        {
            name: 'InCuneiform',
            astral: '\uD808[\uDC00-\uDFFF]'
        },
        {
            name: 'InCuneiform_Numbers_and_Punctuation',
            astral: '\uD809[\uDC00-\uDC7F]'
        },
        {
            name: 'InCurrency_Symbols',
            bmp: '\u20A0-\u20CF'
        },
        {
            name: 'InCypriot_Syllabary',
            astral: '\uD802[\uDC00-\uDC3F]'
        },
        {
            name: 'InCyrillic',
            bmp: '\u0400-\u04FF'
        },
        {
            name: 'InCyrillic_Extended_A',
            bmp: '\u2DE0-\u2DFF'
        },
        {
            name: 'InCyrillic_Extended_B',
            bmp: '\uA640-\uA69F'
        },
        {
            name: 'InCyrillic_Supplement',
            bmp: '\u0500-\u052F'
        },
        {
            name: 'InDeseret',
            astral: '\uD801[\uDC00-\uDC4F]'
        },
        {
            name: 'InDevanagari',
            bmp: '\u0900-\u097F'
        },
        {
            name: 'InDevanagari_Extended',
            bmp: '\uA8E0-\uA8FF'
        },
        {
            name: 'InDingbats',
            bmp: '\u2700-\u27BF'
        },
        {
            name: 'InDomino_Tiles',
            astral: '\uD83C[\uDC30-\uDC9F]'
        },
        {
            name: 'InDuployan',
            astral: '\uD82F[\uDC00-\uDC9F]'
        },
        {
            name: 'InEarly_Dynastic_Cuneiform',
            astral: '\uD809[\uDC80-\uDD4F]'
        },
        {
            name: 'InEgyptian_Hieroglyphs',
            astral: '\uD80C[\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2F]'
        },
        {
            name: 'InElbasan',
            astral: '\uD801[\uDD00-\uDD2F]'
        },
        {
            name: 'InEmoticons',
            astral: '\uD83D[\uDE00-\uDE4F]'
        },
        {
            name: 'InEnclosed_Alphanumeric_Supplement',
            astral: '\uD83C[\uDD00-\uDDFF]'
        },
        {
            name: 'InEnclosed_Alphanumerics',
            bmp: '\u2460-\u24FF'
        },
        {
            name: 'InEnclosed_CJK_Letters_and_Months',
            bmp: '\u3200-\u32FF'
        },
        {
            name: 'InEnclosed_Ideographic_Supplement',
            astral: '\uD83C[\uDE00-\uDEFF]'
        },
        {
            name: 'InEthiopic',
            bmp: '\u1200-\u137F'
        },
        {
            name: 'InEthiopic_Extended',
            bmp: '\u2D80-\u2DDF'
        },
        {
            name: 'InEthiopic_Extended_A',
            bmp: '\uAB00-\uAB2F'
        },
        {
            name: 'InEthiopic_Supplement',
            bmp: '\u1380-\u139F'
        },
        {
            name: 'InGeneral_Punctuation',
            bmp: '\u2000-\u206F'
        },
        {
            name: 'InGeometric_Shapes',
            bmp: '\u25A0-\u25FF'
        },
        {
            name: 'InGeometric_Shapes_Extended',
            astral: '\uD83D[\uDF80-\uDFFF]'
        },
        {
            name: 'InGeorgian',
            bmp: '\u10A0-\u10FF'
        },
        {
            name: 'InGeorgian_Supplement',
            bmp: '\u2D00-\u2D2F'
        },
        {
            name: 'InGlagolitic',
            bmp: '\u2C00-\u2C5F'
        },
        {
            name: 'InGothic',
            astral: '\uD800[\uDF30-\uDF4F]'
        },
        {
            name: 'InGrantha',
            astral: '\uD804[\uDF00-\uDF7F]'
        },
        {
            name: 'InGreek_Extended',
            bmp: '\u1F00-\u1FFF'
        },
        {
            name: 'InGreek_and_Coptic',
            bmp: '\u0370-\u03FF'
        },
        {
            name: 'InGujarati',
            bmp: '\u0A80-\u0AFF'
        },
        {
            name: 'InGurmukhi',
            bmp: '\u0A00-\u0A7F'
        },
        {
            name: 'InHalfwidth_and_Fullwidth_Forms',
            bmp: '\uFF00-\uFFEF'
        },
        {
            name: 'InHangul_Compatibility_Jamo',
            bmp: '\u3130-\u318F'
        },
        {
            name: 'InHangul_Jamo',
            bmp: '\u1100-\u11FF'
        },
        {
            name: 'InHangul_Jamo_Extended_A',
            bmp: '\uA960-\uA97F'
        },
        {
            name: 'InHangul_Jamo_Extended_B',
            bmp: '\uD7B0-\uD7FF'
        },
        {
            name: 'InHangul_Syllables',
            bmp: '\uAC00-\uD7AF'
        },
        {
            name: 'InHanunoo',
            bmp: '\u1720-\u173F'
        },
        {
            name: 'InHatran',
            astral: '\uD802[\uDCE0-\uDCFF]'
        },
        {
            name: 'InHebrew',
            bmp: '\u0590-\u05FF'
        },
        {
            name: 'InHigh_Private_Use_Surrogates',
            bmp: '\uDB80-\uDBFF'
        },
        {
            name: 'InHigh_Surrogates',
            bmp: '\uD800-\uDB7F'
        },
        {
            name: 'InHiragana',
            bmp: '\u3040-\u309F'
        },
        {
            name: 'InIPA_Extensions',
            bmp: '\u0250-\u02AF'
        },
        {
            name: 'InIdeographic_Description_Characters',
            bmp: '\u2FF0-\u2FFF'
        },
        {
            name: 'InImperial_Aramaic',
            astral: '\uD802[\uDC40-\uDC5F]'
        },
        {
            name: 'InInscriptional_Pahlavi',
            astral: '\uD802[\uDF60-\uDF7F]'
        },
        {
            name: 'InInscriptional_Parthian',
            astral: '\uD802[\uDF40-\uDF5F]'
        },
        {
            name: 'InJavanese',
            bmp: '\uA980-\uA9DF'
        },
        {
            name: 'InKaithi',
            astral: '\uD804[\uDC80-\uDCCF]'
        },
        {
            name: 'InKana_Supplement',
            astral: '\uD82C[\uDC00-\uDCFF]'
        },
        {
            name: 'InKanbun',
            bmp: '\u3190-\u319F'
        },
        {
            name: 'InKangxi_Radicals',
            bmp: '\u2F00-\u2FDF'
        },
        {
            name: 'InKannada',
            bmp: '\u0C80-\u0CFF'
        },
        {
            name: 'InKatakana',
            bmp: '\u30A0-\u30FF'
        },
        {
            name: 'InKatakana_Phonetic_Extensions',
            bmp: '\u31F0-\u31FF'
        },
        {
            name: 'InKayah_Li',
            bmp: '\uA900-\uA92F'
        },
        {
            name: 'InKharoshthi',
            astral: '\uD802[\uDE00-\uDE5F]'
        },
        {
            name: 'InKhmer',
            bmp: '\u1780-\u17FF'
        },
        {
            name: 'InKhmer_Symbols',
            bmp: '\u19E0-\u19FF'
        },
        {
            name: 'InKhojki',
            astral: '\uD804[\uDE00-\uDE4F]'
        },
        {
            name: 'InKhudawadi',
            astral: '\uD804[\uDEB0-\uDEFF]'
        },
        {
            name: 'InLao',
            bmp: '\u0E80-\u0EFF'
        },
        {
            name: 'InLatin_Extended_Additional',
            bmp: '\u1E00-\u1EFF'
        },
        {
            name: 'InLatin_Extended_A',
            bmp: '\u0100-\u017F'
        },
        {
            name: 'InLatin_Extended_B',
            bmp: '\u0180-\u024F'
        },
        {
            name: 'InLatin_Extended_C',
            bmp: '\u2C60-\u2C7F'
        },
        {
            name: 'InLatin_Extended_D',
            bmp: '\uA720-\uA7FF'
        },
        {
            name: 'InLatin_Extended_E',
            bmp: '\uAB30-\uAB6F'
        },
        {
            name: 'InLatin_1_Supplement',
            bmp: '\x80-\xFF'
        },
        {
            name: 'InLepcha',
            bmp: '\u1C00-\u1C4F'
        },
        {
            name: 'InLetterlike_Symbols',
            bmp: '\u2100-\u214F'
        },
        {
            name: 'InLimbu',
            bmp: '\u1900-\u194F'
        },
        {
            name: 'InLinear_A',
            astral: '\uD801[\uDE00-\uDF7F]'
        },
        {
            name: 'InLinear_B_Ideograms',
            astral: '\uD800[\uDC80-\uDCFF]'
        },
        {
            name: 'InLinear_B_Syllabary',
            astral: '\uD800[\uDC00-\uDC7F]'
        },
        {
            name: 'InLisu',
            bmp: '\uA4D0-\uA4FF'
        },
        {
            name: 'InLow_Surrogates',
            bmp: '\uDC00-\uDFFF'
        },
        {
            name: 'InLycian',
            astral: '\uD800[\uDE80-\uDE9F]'
        },
        {
            name: 'InLydian',
            astral: '\uD802[\uDD20-\uDD3F]'
        },
        {
            name: 'InMahajani',
            astral: '\uD804[\uDD50-\uDD7F]'
        },
        {
            name: 'InMahjong_Tiles',
            astral: '\uD83C[\uDC00-\uDC2F]'
        },
        {
            name: 'InMalayalam',
            bmp: '\u0D00-\u0D7F'
        },
        {
            name: 'InMandaic',
            bmp: '\u0840-\u085F'
        },
        {
            name: 'InManichaean',
            astral: '\uD802[\uDEC0-\uDEFF]'
        },
        {
            name: 'InMathematical_Alphanumeric_Symbols',
            astral: '\uD835[\uDC00-\uDFFF]'
        },
        {
            name: 'InMathematical_Operators',
            bmp: '\u2200-\u22FF'
        },
        {
            name: 'InMeetei_Mayek',
            bmp: '\uABC0-\uABFF'
        },
        {
            name: 'InMeetei_Mayek_Extensions',
            bmp: '\uAAE0-\uAAFF'
        },
        {
            name: 'InMende_Kikakui',
            astral: '\uD83A[\uDC00-\uDCDF]'
        },
        {
            name: 'InMeroitic_Cursive',
            astral: '\uD802[\uDDA0-\uDDFF]'
        },
        {
            name: 'InMeroitic_Hieroglyphs',
            astral: '\uD802[\uDD80-\uDD9F]'
        },
        {
            name: 'InMiao',
            astral: '\uD81B[\uDF00-\uDF9F]'
        },
        {
            name: 'InMiscellaneous_Mathematical_Symbols_A',
            bmp: '\u27C0-\u27EF'
        },
        {
            name: 'InMiscellaneous_Mathematical_Symbols_B',
            bmp: '\u2980-\u29FF'
        },
        {
            name: 'InMiscellaneous_Symbols',
            bmp: '\u2600-\u26FF'
        },
        {
            name: 'InMiscellaneous_Symbols_and_Arrows',
            bmp: '\u2B00-\u2BFF'
        },
        {
            name: 'InMiscellaneous_Symbols_and_Pictographs',
            astral: '\uD83D[\uDC00-\uDDFF]|\uD83C[\uDF00-\uDFFF]'
        },
        {
            name: 'InMiscellaneous_Technical',
            bmp: '\u2300-\u23FF'
        },
        {
            name: 'InModi',
            astral: '\uD805[\uDE00-\uDE5F]'
        },
        {
            name: 'InModifier_Tone_Letters',
            bmp: '\uA700-\uA71F'
        },
        {
            name: 'InMongolian',
            bmp: '\u1800-\u18AF'
        },
        {
            name: 'InMro',
            astral: '\uD81A[\uDE40-\uDE6F]'
        },
        {
            name: 'InMultani',
            astral: '\uD804[\uDE80-\uDEAF]'
        },
        {
            name: 'InMusical_Symbols',
            astral: '\uD834[\uDD00-\uDDFF]'
        },
        {
            name: 'InMyanmar',
            bmp: '\u1000-\u109F'
        },
        {
            name: 'InMyanmar_Extended_A',
            bmp: '\uAA60-\uAA7F'
        },
        {
            name: 'InMyanmar_Extended_B',
            bmp: '\uA9E0-\uA9FF'
        },
        {
            name: 'InNKo',
            bmp: '\u07C0-\u07FF'
        },
        {
            name: 'InNabataean',
            astral: '\uD802[\uDC80-\uDCAF]'
        },
        {
            name: 'InNew_Tai_Lue',
            bmp: '\u1980-\u19DF'
        },
        {
            name: 'InNumber_Forms',
            bmp: '\u2150-\u218F'
        },
        {
            name: 'InOgham',
            bmp: '\u1680-\u169F'
        },
        {
            name: 'InOl_Chiki',
            bmp: '\u1C50-\u1C7F'
        },
        {
            name: 'InOld_Hungarian',
            astral: '\uD803[\uDC80-\uDCFF]'
        },
        {
            name: 'InOld_Italic',
            astral: '\uD800[\uDF00-\uDF2F]'
        },
        {
            name: 'InOld_North_Arabian',
            astral: '\uD802[\uDE80-\uDE9F]'
        },
        {
            name: 'InOld_Permic',
            astral: '\uD800[\uDF50-\uDF7F]'
        },
        {
            name: 'InOld_Persian',
            astral: '\uD800[\uDFA0-\uDFDF]'
        },
        {
            name: 'InOld_South_Arabian',
            astral: '\uD802[\uDE60-\uDE7F]'
        },
        {
            name: 'InOld_Turkic',
            astral: '\uD803[\uDC00-\uDC4F]'
        },
        {
            name: 'InOptical_Character_Recognition',
            bmp: '\u2440-\u245F'
        },
        {
            name: 'InOriya',
            bmp: '\u0B00-\u0B7F'
        },
        {
            name: 'InOrnamental_Dingbats',
            astral: '\uD83D[\uDE50-\uDE7F]'
        },
        {
            name: 'InOsmanya',
            astral: '\uD801[\uDC80-\uDCAF]'
        },
        {
            name: 'InPahawh_Hmong',
            astral: '\uD81A[\uDF00-\uDF8F]'
        },
        {
            name: 'InPalmyrene',
            astral: '\uD802[\uDC60-\uDC7F]'
        },
        {
            name: 'InPau_Cin_Hau',
            astral: '\uD806[\uDEC0-\uDEFF]'
        },
        {
            name: 'InPhags_pa',
            bmp: '\uA840-\uA87F'
        },
        {
            name: 'InPhaistos_Disc',
            astral: '\uD800[\uDDD0-\uDDFF]'
        },
        {
            name: 'InPhoenician',
            astral: '\uD802[\uDD00-\uDD1F]'
        },
        {
            name: 'InPhonetic_Extensions',
            bmp: '\u1D00-\u1D7F'
        },
        {
            name: 'InPhonetic_Extensions_Supplement',
            bmp: '\u1D80-\u1DBF'
        },
        {
            name: 'InPlaying_Cards',
            astral: '\uD83C[\uDCA0-\uDCFF]'
        },
        {
            name: 'InPrivate_Use_Area',
            bmp: '\uE000-\uF8FF'
        },
        {
            name: 'InPsalter_Pahlavi',
            astral: '\uD802[\uDF80-\uDFAF]'
        },
        {
            name: 'InRejang',
            bmp: '\uA930-\uA95F'
        },
        {
            name: 'InRumi_Numeral_Symbols',
            astral: '\uD803[\uDE60-\uDE7F]'
        },
        {
            name: 'InRunic',
            bmp: '\u16A0-\u16FF'
        },
        {
            name: 'InSamaritan',
            bmp: '\u0800-\u083F'
        },
        {
            name: 'InSaurashtra',
            bmp: '\uA880-\uA8DF'
        },
        {
            name: 'InSharada',
            astral: '\uD804[\uDD80-\uDDDF]'
        },
        {
            name: 'InShavian',
            astral: '\uD801[\uDC50-\uDC7F]'
        },
        {
            name: 'InShorthand_Format_Controls',
            astral: '\uD82F[\uDCA0-\uDCAF]'
        },
        {
            name: 'InSiddham',
            astral: '\uD805[\uDD80-\uDDFF]'
        },
        {
            name: 'InSinhala',
            bmp: '\u0D80-\u0DFF'
        },
        {
            name: 'InSinhala_Archaic_Numbers',
            astral: '\uD804[\uDDE0-\uDDFF]'
        },
        {
            name: 'InSmall_Form_Variants',
            bmp: '\uFE50-\uFE6F'
        },
        {
            name: 'InSora_Sompeng',
            astral: '\uD804[\uDCD0-\uDCFF]'
        },
        {
            name: 'InSpacing_Modifier_Letters',
            bmp: '\u02B0-\u02FF'
        },
        {
            name: 'InSpecials',
            bmp: '\uFFF0-\uFFFF'
        },
        {
            name: 'InSundanese',
            bmp: '\u1B80-\u1BBF'
        },
        {
            name: 'InSundanese_Supplement',
            bmp: '\u1CC0-\u1CCF'
        },
        {
            name: 'InSuperscripts_and_Subscripts',
            bmp: '\u2070-\u209F'
        },
        {
            name: 'InSupplemental_Arrows_A',
            bmp: '\u27F0-\u27FF'
        },
        {
            name: 'InSupplemental_Arrows_B',
            bmp: '\u2900-\u297F'
        },
        {
            name: 'InSupplemental_Arrows_C',
            astral: '\uD83E[\uDC00-\uDCFF]'
        },
        {
            name: 'InSupplemental_Mathematical_Operators',
            bmp: '\u2A00-\u2AFF'
        },
        {
            name: 'InSupplemental_Punctuation',
            bmp: '\u2E00-\u2E7F'
        },
        {
            name: 'InSupplemental_Symbols_and_Pictographs',
            astral: '\uD83E[\uDD00-\uDDFF]'
        },
        {
            name: 'InSupplementary_Private_Use_Area_A',
            astral: '[\uDB80-\uDBBF][\uDC00-\uDFFF]'
        },
        {
            name: 'InSupplementary_Private_Use_Area_B',
            astral: '[\uDBC0-\uDBFF][\uDC00-\uDFFF]'
        },
        {
            name: 'InSutton_SignWriting',
            astral: '\uD836[\uDC00-\uDEAF]'
        },
        {
            name: 'InSyloti_Nagri',
            bmp: '\uA800-\uA82F'
        },
        {
            name: 'InSyriac',
            bmp: '\u0700-\u074F'
        },
        {
            name: 'InTagalog',
            bmp: '\u1700-\u171F'
        },
        {
            name: 'InTagbanwa',
            bmp: '\u1760-\u177F'
        },
        {
            name: 'InTags',
            astral: '\uDB40[\uDC00-\uDC7F]'
        },
        {
            name: 'InTai_Le',
            bmp: '\u1950-\u197F'
        },
        {
            name: 'InTai_Tham',
            bmp: '\u1A20-\u1AAF'
        },
        {
            name: 'InTai_Viet',
            bmp: '\uAA80-\uAADF'
        },
        {
            name: 'InTai_Xuan_Jing_Symbols',
            astral: '\uD834[\uDF00-\uDF5F]'
        },
        {
            name: 'InTakri',
            astral: '\uD805[\uDE80-\uDECF]'
        },
        {
            name: 'InTamil',
            bmp: '\u0B80-\u0BFF'
        },
        {
            name: 'InTelugu',
            bmp: '\u0C00-\u0C7F'
        },
        {
            name: 'InThaana',
            bmp: '\u0780-\u07BF'
        },
        {
            name: 'InThai',
            bmp: '\u0E00-\u0E7F'
        },
        {
            name: 'InTibetan',
            bmp: '\u0F00-\u0FFF'
        },
        {
            name: 'InTifinagh',
            bmp: '\u2D30-\u2D7F'
        },
        {
            name: 'InTirhuta',
            astral: '\uD805[\uDC80-\uDCDF]'
        },
        {
            name: 'InTransport_and_Map_Symbols',
            astral: '\uD83D[\uDE80-\uDEFF]'
        },
        {
            name: 'InUgaritic',
            astral: '\uD800[\uDF80-\uDF9F]'
        },
        {
            name: 'InUnified_Canadian_Aboriginal_Syllabics',
            bmp: '\u1400-\u167F'
        },
        {
            name: 'InUnified_Canadian_Aboriginal_Syllabics_Extended',
            bmp: '\u18B0-\u18FF'
        },
        {
            name: 'InVai',
            bmp: '\uA500-\uA63F'
        },
        {
            name: 'InVariation_Selectors',
            bmp: '\uFE00-\uFE0F'
        },
        {
            name: 'InVariation_Selectors_Supplement',
            astral: '\uDB40[\uDD00-\uDDEF]'
        },
        {
            name: 'InVedic_Extensions',
            bmp: '\u1CD0-\u1CFF'
        },
        {
            name: 'InVertical_Forms',
            bmp: '\uFE10-\uFE1F'
        },
        {
            name: 'InWarang_Citi',
            astral: '\uD806[\uDCA0-\uDCFF]'
        },
        {
            name: 'InYi_Radicals',
            bmp: '\uA490-\uA4CF'
        },
        {
            name: 'InYi_Syllables',
            bmp: '\uA000-\uA48F'
        },
        {
            name: 'InYijing_Hexagram_Symbols',
            bmp: '\u4DC0-\u4DFF'
        }
    ]);

}(XRegExp));

/*!
 * XRegExp Unicode Categories 3.0.0
 * <http://xregexp.com/>
 * Steven Levithan (c) 2010-2015 MIT License
 * Unicode data provided by Mathias Bynens <http://mathiasbynens.be/>
 */

/**
 * Adds support for Unicode's general categories. E.g., `\p{Lu}` or `\p{Uppercase Letter}`. See
 * category descriptions in UAX #44 <http://unicode.org/reports/tr44/#GC_Values_Table>. Token names
 * are case insensitive, and any spaces, hyphens, and underscores are ignored.
 *
 * Uses Unicode 8.0.0.
 *
 * @requires XRegExp, Unicode Base
 */
(function(XRegExp) {
    'use strict';

    if (!XRegExp.addUnicodeData) {
        throw new ReferenceError('Unicode Base must be loaded before Unicode Categories');
    }

    XRegExp.addUnicodeData([
        {
            name: 'C',
            alias: 'Other',
            isBmpLast: true,
            bmp: '\0-\x1F\x7F-\x9F\xAD\u0378\u0379\u0380-\u0383\u038B\u038D\u03A2\u0530\u0557\u0558\u0560\u0588\u058B\u058C\u0590\u05C8-\u05CF\u05EB-\u05EF\u05F5-\u0605\u061C\u061D\u06DD\u070E\u070F\u074B\u074C\u07B2-\u07BF\u07FB-\u07FF\u082E\u082F\u083F\u085C\u085D\u085F-\u089F\u08B5-\u08E2\u0984\u098D\u098E\u0991\u0992\u09A9\u09B1\u09B3-\u09B5\u09BA\u09BB\u09C5\u09C6\u09C9\u09CA\u09CF-\u09D6\u09D8-\u09DB\u09DE\u09E4\u09E5\u09FC-\u0A00\u0A04\u0A0B-\u0A0E\u0A11\u0A12\u0A29\u0A31\u0A34\u0A37\u0A3A\u0A3B\u0A3D\u0A43-\u0A46\u0A49\u0A4A\u0A4E-\u0A50\u0A52-\u0A58\u0A5D\u0A5F-\u0A65\u0A76-\u0A80\u0A84\u0A8E\u0A92\u0AA9\u0AB1\u0AB4\u0ABA\u0ABB\u0AC6\u0ACA\u0ACE\u0ACF\u0AD1-\u0ADF\u0AE4\u0AE5\u0AF2-\u0AF8\u0AFA-\u0B00\u0B04\u0B0D\u0B0E\u0B11\u0B12\u0B29\u0B31\u0B34\u0B3A\u0B3B\u0B45\u0B46\u0B49\u0B4A\u0B4E-\u0B55\u0B58-\u0B5B\u0B5E\u0B64\u0B65\u0B78-\u0B81\u0B84\u0B8B-\u0B8D\u0B91\u0B96-\u0B98\u0B9B\u0B9D\u0BA0-\u0BA2\u0BA5-\u0BA7\u0BAB-\u0BAD\u0BBA-\u0BBD\u0BC3-\u0BC5\u0BC9\u0BCE\u0BCF\u0BD1-\u0BD6\u0BD8-\u0BE5\u0BFB-\u0BFF\u0C04\u0C0D\u0C11\u0C29\u0C3A-\u0C3C\u0C45\u0C49\u0C4E-\u0C54\u0C57\u0C5B-\u0C5F\u0C64\u0C65\u0C70-\u0C77\u0C80\u0C84\u0C8D\u0C91\u0CA9\u0CB4\u0CBA\u0CBB\u0CC5\u0CC9\u0CCE-\u0CD4\u0CD7-\u0CDD\u0CDF\u0CE4\u0CE5\u0CF0\u0CF3-\u0D00\u0D04\u0D0D\u0D11\u0D3B\u0D3C\u0D45\u0D49\u0D4F-\u0D56\u0D58-\u0D5E\u0D64\u0D65\u0D76-\u0D78\u0D80\u0D81\u0D84\u0D97-\u0D99\u0DB2\u0DBC\u0DBE\u0DBF\u0DC7-\u0DC9\u0DCB-\u0DCE\u0DD5\u0DD7\u0DE0-\u0DE5\u0DF0\u0DF1\u0DF5-\u0E00\u0E3B-\u0E3E\u0E5C-\u0E80\u0E83\u0E85\u0E86\u0E89\u0E8B\u0E8C\u0E8E-\u0E93\u0E98\u0EA0\u0EA4\u0EA6\u0EA8\u0EA9\u0EAC\u0EBA\u0EBE\u0EBF\u0EC5\u0EC7\u0ECE\u0ECF\u0EDA\u0EDB\u0EE0-\u0EFF\u0F48\u0F6D-\u0F70\u0F98\u0FBD\u0FCD\u0FDB-\u0FFF\u10C6\u10C8-\u10CC\u10CE\u10CF\u1249\u124E\u124F\u1257\u1259\u125E\u125F\u1289\u128E\u128F\u12B1\u12B6\u12B7\u12BF\u12C1\u12C6\u12C7\u12D7\u1311\u1316\u1317\u135B\u135C\u137D-\u137F\u139A-\u139F\u13F6\u13F7\u13FE\u13FF\u169D-\u169F\u16F9-\u16FF\u170D\u1715-\u171F\u1737-\u173F\u1754-\u175F\u176D\u1771\u1774-\u177F\u17DE\u17DF\u17EA-\u17EF\u17FA-\u17FF\u180E\u180F\u181A-\u181F\u1878-\u187F\u18AB-\u18AF\u18F6-\u18FF\u191F\u192C-\u192F\u193C-\u193F\u1941-\u1943\u196E\u196F\u1975-\u197F\u19AC-\u19AF\u19CA-\u19CF\u19DB-\u19DD\u1A1C\u1A1D\u1A5F\u1A7D\u1A7E\u1A8A-\u1A8F\u1A9A-\u1A9F\u1AAE\u1AAF\u1ABF-\u1AFF\u1B4C-\u1B4F\u1B7D-\u1B7F\u1BF4-\u1BFB\u1C38-\u1C3A\u1C4A-\u1C4C\u1C80-\u1CBF\u1CC8-\u1CCF\u1CF7\u1CFA-\u1CFF\u1DF6-\u1DFB\u1F16\u1F17\u1F1E\u1F1F\u1F46\u1F47\u1F4E\u1F4F\u1F58\u1F5A\u1F5C\u1F5E\u1F7E\u1F7F\u1FB5\u1FC5\u1FD4\u1FD5\u1FDC\u1FF0\u1FF1\u1FF5\u1FFF\u200B-\u200F\u202A-\u202E\u2060-\u206F\u2072\u2073\u208F\u209D-\u209F\u20BF-\u20CF\u20F1-\u20FF\u218C-\u218F\u23FB-\u23FF\u2427-\u243F\u244B-\u245F\u2B74\u2B75\u2B96\u2B97\u2BBA-\u2BBC\u2BC9\u2BD2-\u2BEB\u2BF0-\u2BFF\u2C2F\u2C5F\u2CF4-\u2CF8\u2D26\u2D28-\u2D2C\u2D2E\u2D2F\u2D68-\u2D6E\u2D71-\u2D7E\u2D97-\u2D9F\u2DA7\u2DAF\u2DB7\u2DBF\u2DC7\u2DCF\u2DD7\u2DDF\u2E43-\u2E7F\u2E9A\u2EF4-\u2EFF\u2FD6-\u2FEF\u2FFC-\u2FFF\u3040\u3097\u3098\u3100-\u3104\u312E-\u3130\u318F\u31BB-\u31BF\u31E4-\u31EF\u321F\u32FF\u4DB6-\u4DBF\u9FD6-\u9FFF\uA48D-\uA48F\uA4C7-\uA4CF\uA62C-\uA63F\uA6F8-\uA6FF\uA7AE\uA7AF\uA7B8-\uA7F6\uA82C-\uA82F\uA83A-\uA83F\uA878-\uA87F\uA8C5-\uA8CD\uA8DA-\uA8DF\uA8FE\uA8FF\uA954-\uA95E\uA97D-\uA97F\uA9CE\uA9DA-\uA9DD\uA9FF\uAA37-\uAA3F\uAA4E\uAA4F\uAA5A\uAA5B\uAAC3-\uAADA\uAAF7-\uAB00\uAB07\uAB08\uAB0F\uAB10\uAB17-\uAB1F\uAB27\uAB2F\uAB66-\uAB6F\uABEE\uABEF\uABFA-\uABFF\uD7A4-\uD7AF\uD7C7-\uD7CA\uD7FC-\uF8FF\uFA6E\uFA6F\uFADA-\uFAFF\uFB07-\uFB12\uFB18-\uFB1C\uFB37\uFB3D\uFB3F\uFB42\uFB45\uFBC2-\uFBD2\uFD40-\uFD4F\uFD90\uFD91\uFDC8-\uFDEF\uFDFE\uFDFF\uFE1A-\uFE1F\uFE53\uFE67\uFE6C-\uFE6F\uFE75\uFEFD-\uFF00\uFFBF-\uFFC1\uFFC8\uFFC9\uFFD0\uFFD1\uFFD8\uFFD9\uFFDD-\uFFDF\uFFE7\uFFEF-\uFFFB\uFFFE\uFFFF',
            astral: '\uD834[\uDCF6-\uDCFF\uDD27\uDD28\uDD73-\uDD7A\uDDE9-\uDDFF\uDE46-\uDEFF\uDF57-\uDF5F\uDF72-\uDFFF]|\uD836[\uDE8C-\uDE9A\uDEA0\uDEB0-\uDFFF]|\uD83C[\uDC2C-\uDC2F\uDC94-\uDC9F\uDCAF\uDCB0\uDCC0\uDCD0\uDCF6-\uDCFF\uDD0D-\uDD0F\uDD2F\uDD6C-\uDD6F\uDD9B-\uDDE5\uDE03-\uDE0F\uDE3B-\uDE3F\uDE49-\uDE4F\uDE52-\uDEFF]|\uD81A[\uDE39-\uDE3F\uDE5F\uDE6A-\uDE6D\uDE70-\uDECF\uDEEE\uDEEF\uDEF6-\uDEFF\uDF46-\uDF4F\uDF5A\uDF62\uDF78-\uDF7C\uDF90-\uDFFF]|\uD809[\uDC6F\uDC75-\uDC7F\uDD44-\uDFFF]|\uD81B[\uDC00-\uDEFF\uDF45-\uDF4F\uDF7F-\uDF8E\uDFA0-\uDFFF]|\uD86E[\uDC1E\uDC1F]|\uD83D[\uDD7A\uDDA4\uDED1-\uDEDF\uDEED-\uDEEF\uDEF4-\uDEFF\uDF74-\uDF7F\uDFD5-\uDFFF]|\uD801[\uDC9E\uDC9F\uDCAA-\uDCFF\uDD28-\uDD2F\uDD64-\uDD6E\uDD70-\uDDFF\uDF37-\uDF3F\uDF56-\uDF5F\uDF68-\uDFFF]|\uD800[\uDC0C\uDC27\uDC3B\uDC3E\uDC4E\uDC4F\uDC5E-\uDC7F\uDCFB-\uDCFF\uDD03-\uDD06\uDD34-\uDD36\uDD8D-\uDD8F\uDD9C-\uDD9F\uDDA1-\uDDCF\uDDFE-\uDE7F\uDE9D-\uDE9F\uDED1-\uDEDF\uDEFC-\uDEFF\uDF24-\uDF2F\uDF4B-\uDF4F\uDF7B-\uDF7F\uDF9E\uDFC4-\uDFC7\uDFD6-\uDFFF]|\uD869[\uDED7-\uDEFF]|\uD83B[\uDC00-\uDDFF\uDE04\uDE20\uDE23\uDE25\uDE26\uDE28\uDE33\uDE38\uDE3A\uDE3C-\uDE41\uDE43-\uDE46\uDE48\uDE4A\uDE4C\uDE50\uDE53\uDE55\uDE56\uDE58\uDE5A\uDE5C\uDE5E\uDE60\uDE63\uDE65\uDE66\uDE6B\uDE73\uDE78\uDE7D\uDE7F\uDE8A\uDE9C-\uDEA0\uDEA4\uDEAA\uDEBC-\uDEEF\uDEF2-\uDFFF]|\uD87E[\uDE1E-\uDFFF]|\uDB40[\uDC00-\uDCFF\uDDF0-\uDFFF]|\uD804[\uDC4E-\uDC51\uDC70-\uDC7E\uDCBD\uDCC2-\uDCCF\uDCE9-\uDCEF\uDCFA-\uDCFF\uDD35\uDD44-\uDD4F\uDD77-\uDD7F\uDDCE\uDDCF\uDDE0\uDDF5-\uDDFF\uDE12\uDE3E-\uDE7F\uDE87\uDE89\uDE8E\uDE9E\uDEAA-\uDEAF\uDEEB-\uDEEF\uDEFA-\uDEFF\uDF04\uDF0D\uDF0E\uDF11\uDF12\uDF29\uDF31\uDF34\uDF3A\uDF3B\uDF45\uDF46\uDF49\uDF4A\uDF4E\uDF4F\uDF51-\uDF56\uDF58-\uDF5C\uDF64\uDF65\uDF6D-\uDF6F\uDF75-\uDFFF]|\uD83A[\uDCC5\uDCC6\uDCD7-\uDFFF]|\uD80D[\uDC2F-\uDFFF]|\uD86D[\uDF35-\uDF3F]|[\uD807\uD80A\uD80B\uD80E-\uD810\uD812-\uD819\uD81C-\uD82B\uD82D\uD82E\uD830-\uD833\uD837-\uD839\uD83F\uD874-\uD87D\uD87F-\uDB3F\uDB41-\uDBFF][\uDC00-\uDFFF]|\uD806[\uDC00-\uDC9F\uDCF3-\uDCFE\uDD00-\uDEBF\uDEF9-\uDFFF]|\uD803[\uDC49-\uDC7F\uDCB3-\uDCBF\uDCF3-\uDCF9\uDD00-\uDE5F\uDE7F-\uDFFF]|\uD835[\uDC55\uDC9D\uDCA0\uDCA1\uDCA3\uDCA4\uDCA7\uDCA8\uDCAD\uDCBA\uDCBC\uDCC4\uDD06\uDD0B\uDD0C\uDD15\uDD1D\uDD3A\uDD3F\uDD45\uDD47-\uDD49\uDD51\uDEA6\uDEA7\uDFCC\uDFCD]|\uD805[\uDC00-\uDC7F\uDCC8-\uDCCF\uDCDA-\uDD7F\uDDB6\uDDB7\uDDDE-\uDDFF\uDE45-\uDE4F\uDE5A-\uDE7F\uDEB8-\uDEBF\uDECA-\uDEFF\uDF1A-\uDF1C\uDF2C-\uDF2F\uDF40-\uDFFF]|\uD802[\uDC06\uDC07\uDC09\uDC36\uDC39-\uDC3B\uDC3D\uDC3E\uDC56\uDC9F-\uDCA6\uDCB0-\uDCDF\uDCF3\uDCF6-\uDCFA\uDD1C-\uDD1E\uDD3A-\uDD3E\uDD40-\uDD7F\uDDB8-\uDDBB\uDDD0\uDDD1\uDE04\uDE07-\uDE0B\uDE14\uDE18\uDE34-\uDE37\uDE3B-\uDE3E\uDE48-\uDE4F\uDE59-\uDE5F\uDEA0-\uDEBF\uDEE7-\uDEEA\uDEF7-\uDEFF\uDF36-\uDF38\uDF56\uDF57\uDF73-\uDF77\uDF92-\uDF98\uDF9D-\uDFA8\uDFB0-\uDFFF]|\uD808[\uDF9A-\uDFFF]|\uD82F[\uDC6B-\uDC6F\uDC7D-\uDC7F\uDC89-\uDC8F\uDC9A\uDC9B\uDCA0-\uDFFF]|\uD82C[\uDC02-\uDFFF]|\uD811[\uDE47-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE-\uDD0F\uDD19-\uDD7F\uDD85-\uDDBF\uDDC1-\uDFFF]|\uD873[\uDEA2-\uDFFF]'
        },
        {
            name: 'Cc',
            alias: 'Control',
            bmp: '\0-\x1F\x7F-\x9F'
        },
        {
            name: 'Cf',
            alias: 'Format',
            bmp: '\xAD\u0600-\u0605\u061C\u06DD\u070F\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB',
            astral: '\uDB40[\uDC01\uDC20-\uDC7F]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uD804\uDCBD'
        },
        {
            name: 'Cn',
            alias: 'Unassigned',
            bmp: '\u0378\u0379\u0380-\u0383\u038B\u038D\u03A2\u0530\u0557\u0558\u0560\u0588\u058B\u058C\u0590\u05C8-\u05CF\u05EB-\u05EF\u05F5-\u05FF\u061D\u070E\u074B\u074C\u07B2-\u07BF\u07FB-\u07FF\u082E\u082F\u083F\u085C\u085D\u085F-\u089F\u08B5-\u08E2\u0984\u098D\u098E\u0991\u0992\u09A9\u09B1\u09B3-\u09B5\u09BA\u09BB\u09C5\u09C6\u09C9\u09CA\u09CF-\u09D6\u09D8-\u09DB\u09DE\u09E4\u09E5\u09FC-\u0A00\u0A04\u0A0B-\u0A0E\u0A11\u0A12\u0A29\u0A31\u0A34\u0A37\u0A3A\u0A3B\u0A3D\u0A43-\u0A46\u0A49\u0A4A\u0A4E-\u0A50\u0A52-\u0A58\u0A5D\u0A5F-\u0A65\u0A76-\u0A80\u0A84\u0A8E\u0A92\u0AA9\u0AB1\u0AB4\u0ABA\u0ABB\u0AC6\u0ACA\u0ACE\u0ACF\u0AD1-\u0ADF\u0AE4\u0AE5\u0AF2-\u0AF8\u0AFA-\u0B00\u0B04\u0B0D\u0B0E\u0B11\u0B12\u0B29\u0B31\u0B34\u0B3A\u0B3B\u0B45\u0B46\u0B49\u0B4A\u0B4E-\u0B55\u0B58-\u0B5B\u0B5E\u0B64\u0B65\u0B78-\u0B81\u0B84\u0B8B-\u0B8D\u0B91\u0B96-\u0B98\u0B9B\u0B9D\u0BA0-\u0BA2\u0BA5-\u0BA7\u0BAB-\u0BAD\u0BBA-\u0BBD\u0BC3-\u0BC5\u0BC9\u0BCE\u0BCF\u0BD1-\u0BD6\u0BD8-\u0BE5\u0BFB-\u0BFF\u0C04\u0C0D\u0C11\u0C29\u0C3A-\u0C3C\u0C45\u0C49\u0C4E-\u0C54\u0C57\u0C5B-\u0C5F\u0C64\u0C65\u0C70-\u0C77\u0C80\u0C84\u0C8D\u0C91\u0CA9\u0CB4\u0CBA\u0CBB\u0CC5\u0CC9\u0CCE-\u0CD4\u0CD7-\u0CDD\u0CDF\u0CE4\u0CE5\u0CF0\u0CF3-\u0D00\u0D04\u0D0D\u0D11\u0D3B\u0D3C\u0D45\u0D49\u0D4F-\u0D56\u0D58-\u0D5E\u0D64\u0D65\u0D76-\u0D78\u0D80\u0D81\u0D84\u0D97-\u0D99\u0DB2\u0DBC\u0DBE\u0DBF\u0DC7-\u0DC9\u0DCB-\u0DCE\u0DD5\u0DD7\u0DE0-\u0DE5\u0DF0\u0DF1\u0DF5-\u0E00\u0E3B-\u0E3E\u0E5C-\u0E80\u0E83\u0E85\u0E86\u0E89\u0E8B\u0E8C\u0E8E-\u0E93\u0E98\u0EA0\u0EA4\u0EA6\u0EA8\u0EA9\u0EAC\u0EBA\u0EBE\u0EBF\u0EC5\u0EC7\u0ECE\u0ECF\u0EDA\u0EDB\u0EE0-\u0EFF\u0F48\u0F6D-\u0F70\u0F98\u0FBD\u0FCD\u0FDB-\u0FFF\u10C6\u10C8-\u10CC\u10CE\u10CF\u1249\u124E\u124F\u1257\u1259\u125E\u125F\u1289\u128E\u128F\u12B1\u12B6\u12B7\u12BF\u12C1\u12C6\u12C7\u12D7\u1311\u1316\u1317\u135B\u135C\u137D-\u137F\u139A-\u139F\u13F6\u13F7\u13FE\u13FF\u169D-\u169F\u16F9-\u16FF\u170D\u1715-\u171F\u1737-\u173F\u1754-\u175F\u176D\u1771\u1774-\u177F\u17DE\u17DF\u17EA-\u17EF\u17FA-\u17FF\u180F\u181A-\u181F\u1878-\u187F\u18AB-\u18AF\u18F6-\u18FF\u191F\u192C-\u192F\u193C-\u193F\u1941-\u1943\u196E\u196F\u1975-\u197F\u19AC-\u19AF\u19CA-\u19CF\u19DB-\u19DD\u1A1C\u1A1D\u1A5F\u1A7D\u1A7E\u1A8A-\u1A8F\u1A9A-\u1A9F\u1AAE\u1AAF\u1ABF-\u1AFF\u1B4C-\u1B4F\u1B7D-\u1B7F\u1BF4-\u1BFB\u1C38-\u1C3A\u1C4A-\u1C4C\u1C80-\u1CBF\u1CC8-\u1CCF\u1CF7\u1CFA-\u1CFF\u1DF6-\u1DFB\u1F16\u1F17\u1F1E\u1F1F\u1F46\u1F47\u1F4E\u1F4F\u1F58\u1F5A\u1F5C\u1F5E\u1F7E\u1F7F\u1FB5\u1FC5\u1FD4\u1FD5\u1FDC\u1FF0\u1FF1\u1FF5\u1FFF\u2065\u2072\u2073\u208F\u209D-\u209F\u20BF-\u20CF\u20F1-\u20FF\u218C-\u218F\u23FB-\u23FF\u2427-\u243F\u244B-\u245F\u2B74\u2B75\u2B96\u2B97\u2BBA-\u2BBC\u2BC9\u2BD2-\u2BEB\u2BF0-\u2BFF\u2C2F\u2C5F\u2CF4-\u2CF8\u2D26\u2D28-\u2D2C\u2D2E\u2D2F\u2D68-\u2D6E\u2D71-\u2D7E\u2D97-\u2D9F\u2DA7\u2DAF\u2DB7\u2DBF\u2DC7\u2DCF\u2DD7\u2DDF\u2E43-\u2E7F\u2E9A\u2EF4-\u2EFF\u2FD6-\u2FEF\u2FFC-\u2FFF\u3040\u3097\u3098\u3100-\u3104\u312E-\u3130\u318F\u31BB-\u31BF\u31E4-\u31EF\u321F\u32FF\u4DB6-\u4DBF\u9FD6-\u9FFF\uA48D-\uA48F\uA4C7-\uA4CF\uA62C-\uA63F\uA6F8-\uA6FF\uA7AE\uA7AF\uA7B8-\uA7F6\uA82C-\uA82F\uA83A-\uA83F\uA878-\uA87F\uA8C5-\uA8CD\uA8DA-\uA8DF\uA8FE\uA8FF\uA954-\uA95E\uA97D-\uA97F\uA9CE\uA9DA-\uA9DD\uA9FF\uAA37-\uAA3F\uAA4E\uAA4F\uAA5A\uAA5B\uAAC3-\uAADA\uAAF7-\uAB00\uAB07\uAB08\uAB0F\uAB10\uAB17-\uAB1F\uAB27\uAB2F\uAB66-\uAB6F\uABEE\uABEF\uABFA-\uABFF\uD7A4-\uD7AF\uD7C7-\uD7CA\uD7FC-\uD7FF\uFA6E\uFA6F\uFADA-\uFAFF\uFB07-\uFB12\uFB18-\uFB1C\uFB37\uFB3D\uFB3F\uFB42\uFB45\uFBC2-\uFBD2\uFD40-\uFD4F\uFD90\uFD91\uFDC8-\uFDEF\uFDFE\uFDFF\uFE1A-\uFE1F\uFE53\uFE67\uFE6C-\uFE6F\uFE75\uFEFD\uFEFE\uFF00\uFFBF-\uFFC1\uFFC8\uFFC9\uFFD0\uFFD1\uFFD8\uFFD9\uFFDD-\uFFDF\uFFE7\uFFEF-\uFFF8\uFFFE\uFFFF',
            astral: '\uDB40[\uDC00\uDC02-\uDC1F\uDC80-\uDCFF\uDDF0-\uDFFF]|\uD834[\uDCF6-\uDCFF\uDD27\uDD28\uDDE9-\uDDFF\uDE46-\uDEFF\uDF57-\uDF5F\uDF72-\uDFFF]|\uD83C[\uDC2C-\uDC2F\uDC94-\uDC9F\uDCAF\uDCB0\uDCC0\uDCD0\uDCF6-\uDCFF\uDD0D-\uDD0F\uDD2F\uDD6C-\uDD6F\uDD9B-\uDDE5\uDE03-\uDE0F\uDE3B-\uDE3F\uDE49-\uDE4F\uDE52-\uDEFF]|\uD81A[\uDE39-\uDE3F\uDE5F\uDE6A-\uDE6D\uDE70-\uDECF\uDEEE\uDEEF\uDEF6-\uDEFF\uDF46-\uDF4F\uDF5A\uDF62\uDF78-\uDF7C\uDF90-\uDFFF]|\uD809[\uDC6F\uDC75-\uDC7F\uDD44-\uDFFF]|\uD81B[\uDC00-\uDEFF\uDF45-\uDF4F\uDF7F-\uDF8E\uDFA0-\uDFFF]|\uD86E[\uDC1E\uDC1F]|\uD83D[\uDD7A\uDDA4\uDED1-\uDEDF\uDEED-\uDEEF\uDEF4-\uDEFF\uDF74-\uDF7F\uDFD5-\uDFFF]|\uD801[\uDC9E\uDC9F\uDCAA-\uDCFF\uDD28-\uDD2F\uDD64-\uDD6E\uDD70-\uDDFF\uDF37-\uDF3F\uDF56-\uDF5F\uDF68-\uDFFF]|\uD800[\uDC0C\uDC27\uDC3B\uDC3E\uDC4E\uDC4F\uDC5E-\uDC7F\uDCFB-\uDCFF\uDD03-\uDD06\uDD34-\uDD36\uDD8D-\uDD8F\uDD9C-\uDD9F\uDDA1-\uDDCF\uDDFE-\uDE7F\uDE9D-\uDE9F\uDED1-\uDEDF\uDEFC-\uDEFF\uDF24-\uDF2F\uDF4B-\uDF4F\uDF7B-\uDF7F\uDF9E\uDFC4-\uDFC7\uDFD6-\uDFFF]|\uD869[\uDED7-\uDEFF]|\uD83B[\uDC00-\uDDFF\uDE04\uDE20\uDE23\uDE25\uDE26\uDE28\uDE33\uDE38\uDE3A\uDE3C-\uDE41\uDE43-\uDE46\uDE48\uDE4A\uDE4C\uDE50\uDE53\uDE55\uDE56\uDE58\uDE5A\uDE5C\uDE5E\uDE60\uDE63\uDE65\uDE66\uDE6B\uDE73\uDE78\uDE7D\uDE7F\uDE8A\uDE9C-\uDEA0\uDEA4\uDEAA\uDEBC-\uDEEF\uDEF2-\uDFFF]|[\uDBBF\uDBFF][\uDFFE\uDFFF]|\uD87E[\uDE1E-\uDFFF]|\uD82F[\uDC6B-\uDC6F\uDC7D-\uDC7F\uDC89-\uDC8F\uDC9A\uDC9B\uDCA4-\uDFFF]|\uD83A[\uDCC5\uDCC6\uDCD7-\uDFFF]|\uD80D[\uDC2F-\uDFFF]|\uD86D[\uDF35-\uDF3F]|[\uD807\uD80A\uD80B\uD80E-\uD810\uD812-\uD819\uD81C-\uD82B\uD82D\uD82E\uD830-\uD833\uD837-\uD839\uD83F\uD874-\uD87D\uD87F-\uDB3F\uDB41-\uDB7F][\uDC00-\uDFFF]|\uD806[\uDC00-\uDC9F\uDCF3-\uDCFE\uDD00-\uDEBF\uDEF9-\uDFFF]|\uD803[\uDC49-\uDC7F\uDCB3-\uDCBF\uDCF3-\uDCF9\uDD00-\uDE5F\uDE7F-\uDFFF]|\uD835[\uDC55\uDC9D\uDCA0\uDCA1\uDCA3\uDCA4\uDCA7\uDCA8\uDCAD\uDCBA\uDCBC\uDCC4\uDD06\uDD0B\uDD0C\uDD15\uDD1D\uDD3A\uDD3F\uDD45\uDD47-\uDD49\uDD51\uDEA6\uDEA7\uDFCC\uDFCD]|\uD836[\uDE8C-\uDE9A\uDEA0\uDEB0-\uDFFF]|\uD805[\uDC00-\uDC7F\uDCC8-\uDCCF\uDCDA-\uDD7F\uDDB6\uDDB7\uDDDE-\uDDFF\uDE45-\uDE4F\uDE5A-\uDE7F\uDEB8-\uDEBF\uDECA-\uDEFF\uDF1A-\uDF1C\uDF2C-\uDF2F\uDF40-\uDFFF]|\uD802[\uDC06\uDC07\uDC09\uDC36\uDC39-\uDC3B\uDC3D\uDC3E\uDC56\uDC9F-\uDCA6\uDCB0-\uDCDF\uDCF3\uDCF6-\uDCFA\uDD1C-\uDD1E\uDD3A-\uDD3E\uDD40-\uDD7F\uDDB8-\uDDBB\uDDD0\uDDD1\uDE04\uDE07-\uDE0B\uDE14\uDE18\uDE34-\uDE37\uDE3B-\uDE3E\uDE48-\uDE4F\uDE59-\uDE5F\uDEA0-\uDEBF\uDEE7-\uDEEA\uDEF7-\uDEFF\uDF36-\uDF38\uDF56\uDF57\uDF73-\uDF77\uDF92-\uDF98\uDF9D-\uDFA8\uDFB0-\uDFFF]|\uD808[\uDF9A-\uDFFF]|\uD804[\uDC4E-\uDC51\uDC70-\uDC7E\uDCC2-\uDCCF\uDCE9-\uDCEF\uDCFA-\uDCFF\uDD35\uDD44-\uDD4F\uDD77-\uDD7F\uDDCE\uDDCF\uDDE0\uDDF5-\uDDFF\uDE12\uDE3E-\uDE7F\uDE87\uDE89\uDE8E\uDE9E\uDEAA-\uDEAF\uDEEB-\uDEEF\uDEFA-\uDEFF\uDF04\uDF0D\uDF0E\uDF11\uDF12\uDF29\uDF31\uDF34\uDF3A\uDF3B\uDF45\uDF46\uDF49\uDF4A\uDF4E\uDF4F\uDF51-\uDF56\uDF58-\uDF5C\uDF64\uDF65\uDF6D-\uDF6F\uDF75-\uDFFF]|\uD82C[\uDC02-\uDFFF]|\uD811[\uDE47-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE-\uDD0F\uDD19-\uDD7F\uDD85-\uDDBF\uDDC1-\uDFFF]|\uD873[\uDEA2-\uDFFF]'
        },
        {
            name: 'Co',
            alias: 'Private_Use',
            bmp: '\uE000-\uF8FF',
            astral: '[\uDB80-\uDBBE\uDBC0-\uDBFE][\uDC00-\uDFFF]|[\uDBBF\uDBFF][\uDC00-\uDFFD]'
        },
        {
            name: 'Cs',
            alias: 'Surrogate',
            bmp: '\uD800-\uDFFF'
        },
        {
            name: 'L',
            alias: 'Letter',
            bmp: 'A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC',
            astral: '\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD83A[\uDC00-\uDCC4]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD80D[\uDC00-\uDC2E]|\uD87E[\uDC00-\uDE1D]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD809[\uDC80-\uDD43]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD808[\uDC00-\uDF99]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD811[\uDC00-\uDE46]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD82C[\uDC00\uDC01]|\uD873[\uDC00-\uDEA1]'
        },
        {
            name: 'Ll',
            alias: 'Lowercase_Letter',
            bmp: 'a-z\xB5\xDF-\xF6\xF8-\xFF\u0101\u0103\u0105\u0107\u0109\u010B\u010D\u010F\u0111\u0113\u0115\u0117\u0119\u011B\u011D\u011F\u0121\u0123\u0125\u0127\u0129\u012B\u012D\u012F\u0131\u0133\u0135\u0137\u0138\u013A\u013C\u013E\u0140\u0142\u0144\u0146\u0148\u0149\u014B\u014D\u014F\u0151\u0153\u0155\u0157\u0159\u015B\u015D\u015F\u0161\u0163\u0165\u0167\u0169\u016B\u016D\u016F\u0171\u0173\u0175\u0177\u017A\u017C\u017E-\u0180\u0183\u0185\u0188\u018C\u018D\u0192\u0195\u0199-\u019B\u019E\u01A1\u01A3\u01A5\u01A8\u01AA\u01AB\u01AD\u01B0\u01B4\u01B6\u01B9\u01BA\u01BD-\u01BF\u01C6\u01C9\u01CC\u01CE\u01D0\u01D2\u01D4\u01D6\u01D8\u01DA\u01DC\u01DD\u01DF\u01E1\u01E3\u01E5\u01E7\u01E9\u01EB\u01ED\u01EF\u01F0\u01F3\u01F5\u01F9\u01FB\u01FD\u01FF\u0201\u0203\u0205\u0207\u0209\u020B\u020D\u020F\u0211\u0213\u0215\u0217\u0219\u021B\u021D\u021F\u0221\u0223\u0225\u0227\u0229\u022B\u022D\u022F\u0231\u0233-\u0239\u023C\u023F\u0240\u0242\u0247\u0249\u024B\u024D\u024F-\u0293\u0295-\u02AF\u0371\u0373\u0377\u037B-\u037D\u0390\u03AC-\u03CE\u03D0\u03D1\u03D5-\u03D7\u03D9\u03DB\u03DD\u03DF\u03E1\u03E3\u03E5\u03E7\u03E9\u03EB\u03ED\u03EF-\u03F3\u03F5\u03F8\u03FB\u03FC\u0430-\u045F\u0461\u0463\u0465\u0467\u0469\u046B\u046D\u046F\u0471\u0473\u0475\u0477\u0479\u047B\u047D\u047F\u0481\u048B\u048D\u048F\u0491\u0493\u0495\u0497\u0499\u049B\u049D\u049F\u04A1\u04A3\u04A5\u04A7\u04A9\u04AB\u04AD\u04AF\u04B1\u04B3\u04B5\u04B7\u04B9\u04BB\u04BD\u04BF\u04C2\u04C4\u04C6\u04C8\u04CA\u04CC\u04CE\u04CF\u04D1\u04D3\u04D5\u04D7\u04D9\u04DB\u04DD\u04DF\u04E1\u04E3\u04E5\u04E7\u04E9\u04EB\u04ED\u04EF\u04F1\u04F3\u04F5\u04F7\u04F9\u04FB\u04FD\u04FF\u0501\u0503\u0505\u0507\u0509\u050B\u050D\u050F\u0511\u0513\u0515\u0517\u0519\u051B\u051D\u051F\u0521\u0523\u0525\u0527\u0529\u052B\u052D\u052F\u0561-\u0587\u13F8-\u13FD\u1D00-\u1D2B\u1D6B-\u1D77\u1D79-\u1D9A\u1E01\u1E03\u1E05\u1E07\u1E09\u1E0B\u1E0D\u1E0F\u1E11\u1E13\u1E15\u1E17\u1E19\u1E1B\u1E1D\u1E1F\u1E21\u1E23\u1E25\u1E27\u1E29\u1E2B\u1E2D\u1E2F\u1E31\u1E33\u1E35\u1E37\u1E39\u1E3B\u1E3D\u1E3F\u1E41\u1E43\u1E45\u1E47\u1E49\u1E4B\u1E4D\u1E4F\u1E51\u1E53\u1E55\u1E57\u1E59\u1E5B\u1E5D\u1E5F\u1E61\u1E63\u1E65\u1E67\u1E69\u1E6B\u1E6D\u1E6F\u1E71\u1E73\u1E75\u1E77\u1E79\u1E7B\u1E7D\u1E7F\u1E81\u1E83\u1E85\u1E87\u1E89\u1E8B\u1E8D\u1E8F\u1E91\u1E93\u1E95-\u1E9D\u1E9F\u1EA1\u1EA3\u1EA5\u1EA7\u1EA9\u1EAB\u1EAD\u1EAF\u1EB1\u1EB3\u1EB5\u1EB7\u1EB9\u1EBB\u1EBD\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7\u1EC9\u1ECB\u1ECD\u1ECF\u1ED1\u1ED3\u1ED5\u1ED7\u1ED9\u1EDB\u1EDD\u1EDF\u1EE1\u1EE3\u1EE5\u1EE7\u1EE9\u1EEB\u1EED\u1EEF\u1EF1\u1EF3\u1EF5\u1EF7\u1EF9\u1EFB\u1EFD\u1EFF-\u1F07\u1F10-\u1F15\u1F20-\u1F27\u1F30-\u1F37\u1F40-\u1F45\u1F50-\u1F57\u1F60-\u1F67\u1F70-\u1F7D\u1F80-\u1F87\u1F90-\u1F97\u1FA0-\u1FA7\u1FB0-\u1FB4\u1FB6\u1FB7\u1FBE\u1FC2-\u1FC4\u1FC6\u1FC7\u1FD0-\u1FD3\u1FD6\u1FD7\u1FE0-\u1FE7\u1FF2-\u1FF4\u1FF6\u1FF7\u210A\u210E\u210F\u2113\u212F\u2134\u2139\u213C\u213D\u2146-\u2149\u214E\u2184\u2C30-\u2C5E\u2C61\u2C65\u2C66\u2C68\u2C6A\u2C6C\u2C71\u2C73\u2C74\u2C76-\u2C7B\u2C81\u2C83\u2C85\u2C87\u2C89\u2C8B\u2C8D\u2C8F\u2C91\u2C93\u2C95\u2C97\u2C99\u2C9B\u2C9D\u2C9F\u2CA1\u2CA3\u2CA5\u2CA7\u2CA9\u2CAB\u2CAD\u2CAF\u2CB1\u2CB3\u2CB5\u2CB7\u2CB9\u2CBB\u2CBD\u2CBF\u2CC1\u2CC3\u2CC5\u2CC7\u2CC9\u2CCB\u2CCD\u2CCF\u2CD1\u2CD3\u2CD5\u2CD7\u2CD9\u2CDB\u2CDD\u2CDF\u2CE1\u2CE3\u2CE4\u2CEC\u2CEE\u2CF3\u2D00-\u2D25\u2D27\u2D2D\uA641\uA643\uA645\uA647\uA649\uA64B\uA64D\uA64F\uA651\uA653\uA655\uA657\uA659\uA65B\uA65D\uA65F\uA661\uA663\uA665\uA667\uA669\uA66B\uA66D\uA681\uA683\uA685\uA687\uA689\uA68B\uA68D\uA68F\uA691\uA693\uA695\uA697\uA699\uA69B\uA723\uA725\uA727\uA729\uA72B\uA72D\uA72F-\uA731\uA733\uA735\uA737\uA739\uA73B\uA73D\uA73F\uA741\uA743\uA745\uA747\uA749\uA74B\uA74D\uA74F\uA751\uA753\uA755\uA757\uA759\uA75B\uA75D\uA75F\uA761\uA763\uA765\uA767\uA769\uA76B\uA76D\uA76F\uA771-\uA778\uA77A\uA77C\uA77F\uA781\uA783\uA785\uA787\uA78C\uA78E\uA791\uA793-\uA795\uA797\uA799\uA79B\uA79D\uA79F\uA7A1\uA7A3\uA7A5\uA7A7\uA7A9\uA7B5\uA7B7\uA7FA\uAB30-\uAB5A\uAB60-\uAB65\uAB70-\uABBF\uFB00-\uFB06\uFB13-\uFB17\uFF41-\uFF5A',
            astral: '\uD803[\uDCC0-\uDCF2]|\uD835[\uDC1A-\uDC33\uDC4E-\uDC54\uDC56-\uDC67\uDC82-\uDC9B\uDCB6-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDCEA-\uDD03\uDD1E-\uDD37\uDD52-\uDD6B\uDD86-\uDD9F\uDDBA-\uDDD3\uDDEE-\uDE07\uDE22-\uDE3B\uDE56-\uDE6F\uDE8A-\uDEA5\uDEC2-\uDEDA\uDEDC-\uDEE1\uDEFC-\uDF14\uDF16-\uDF1B\uDF36-\uDF4E\uDF50-\uDF55\uDF70-\uDF88\uDF8A-\uDF8F\uDFAA-\uDFC2\uDFC4-\uDFC9\uDFCB]|\uD801[\uDC28-\uDC4F]|\uD806[\uDCC0-\uDCDF]'
        },
        {
            name: 'Lm',
            alias: 'Modifier_Letter',
            bmp: '\u02B0-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0374\u037A\u0559\u0640\u06E5\u06E6\u07F4\u07F5\u07FA\u081A\u0824\u0828\u0971\u0E46\u0EC6\u10FC\u17D7\u1843\u1AA7\u1C78-\u1C7D\u1D2C-\u1D6A\u1D78\u1D9B-\u1DBF\u2071\u207F\u2090-\u209C\u2C7C\u2C7D\u2D6F\u2E2F\u3005\u3031-\u3035\u303B\u309D\u309E\u30FC-\u30FE\uA015\uA4F8-\uA4FD\uA60C\uA67F\uA69C\uA69D\uA717-\uA71F\uA770\uA788\uA7F8\uA7F9\uA9CF\uA9E6\uAA70\uAADD\uAAF3\uAAF4\uAB5C-\uAB5F\uFF70\uFF9E\uFF9F',
            astral: '\uD81A[\uDF40-\uDF43]|\uD81B[\uDF93-\uDF9F]'
        },
        {
            name: 'Lo',
            alias: 'Other_Letter',
            bmp: '\xAA\xBA\u01BB\u01C0-\u01C3\u0294\u05D0-\u05EA\u05F0-\u05F2\u0620-\u063F\u0641-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u0800-\u0815\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0972-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E45\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10D0-\u10FA\u10FD-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17DC\u1820-\u1842\u1844-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C77\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u2135-\u2138\u2D30-\u2D67\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3006\u303C\u3041-\u3096\u309F\u30A1-\u30FA\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA014\uA016-\uA48C\uA4D0-\uA4F7\uA500-\uA60B\uA610-\uA61F\uA62A\uA62B\uA66E\uA6A0-\uA6E5\uA78F\uA7F7\uA7FB-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9E0-\uA9E4\uA9E7-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA6F\uAA71-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB\uAADC\uAAE0-\uAAEA\uAAF2\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF66-\uFF6F\uFF71-\uFF9D\uFFA0-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC',
            astral: '\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD83A[\uDC00-\uDCC4]|\uD803[\uDC00-\uDC48]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD80D[\uDC00-\uDC2E]|\uD87E[\uDC00-\uDE1D]|\uD81B[\uDF00-\uDF44\uDF50]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCFF\uDEC0-\uDEF8]|\uD809[\uDC80-\uDD43]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD808[\uDC00-\uDF99]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF63-\uDF77\uDF7D-\uDF8F]|\uD801[\uDC50-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD811[\uDC00-\uDE46]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD82C[\uDC00\uDC01]|\uD873[\uDC00-\uDEA1]'
        },
        {
            name: 'Lt',
            alias: 'Titlecase_Letter',
            bmp: '\u01C5\u01C8\u01CB\u01F2\u1F88-\u1F8F\u1F98-\u1F9F\u1FA8-\u1FAF\u1FBC\u1FCC\u1FFC'
        },
        {
            name: 'Lu',
            alias: 'Uppercase_Letter',
            bmp: 'A-Z\xC0-\xD6\xD8-\xDE\u0100\u0102\u0104\u0106\u0108\u010A\u010C\u010E\u0110\u0112\u0114\u0116\u0118\u011A\u011C\u011E\u0120\u0122\u0124\u0126\u0128\u012A\u012C\u012E\u0130\u0132\u0134\u0136\u0139\u013B\u013D\u013F\u0141\u0143\u0145\u0147\u014A\u014C\u014E\u0150\u0152\u0154\u0156\u0158\u015A\u015C\u015E\u0160\u0162\u0164\u0166\u0168\u016A\u016C\u016E\u0170\u0172\u0174\u0176\u0178\u0179\u017B\u017D\u0181\u0182\u0184\u0186\u0187\u0189-\u018B\u018E-\u0191\u0193\u0194\u0196-\u0198\u019C\u019D\u019F\u01A0\u01A2\u01A4\u01A6\u01A7\u01A9\u01AC\u01AE\u01AF\u01B1-\u01B3\u01B5\u01B7\u01B8\u01BC\u01C4\u01C7\u01CA\u01CD\u01CF\u01D1\u01D3\u01D5\u01D7\u01D9\u01DB\u01DE\u01E0\u01E2\u01E4\u01E6\u01E8\u01EA\u01EC\u01EE\u01F1\u01F4\u01F6-\u01F8\u01FA\u01FC\u01FE\u0200\u0202\u0204\u0206\u0208\u020A\u020C\u020E\u0210\u0212\u0214\u0216\u0218\u021A\u021C\u021E\u0220\u0222\u0224\u0226\u0228\u022A\u022C\u022E\u0230\u0232\u023A\u023B\u023D\u023E\u0241\u0243-\u0246\u0248\u024A\u024C\u024E\u0370\u0372\u0376\u037F\u0386\u0388-\u038A\u038C\u038E\u038F\u0391-\u03A1\u03A3-\u03AB\u03CF\u03D2-\u03D4\u03D8\u03DA\u03DC\u03DE\u03E0\u03E2\u03E4\u03E6\u03E8\u03EA\u03EC\u03EE\u03F4\u03F7\u03F9\u03FA\u03FD-\u042F\u0460\u0462\u0464\u0466\u0468\u046A\u046C\u046E\u0470\u0472\u0474\u0476\u0478\u047A\u047C\u047E\u0480\u048A\u048C\u048E\u0490\u0492\u0494\u0496\u0498\u049A\u049C\u049E\u04A0\u04A2\u04A4\u04A6\u04A8\u04AA\u04AC\u04AE\u04B0\u04B2\u04B4\u04B6\u04B8\u04BA\u04BC\u04BE\u04C0\u04C1\u04C3\u04C5\u04C7\u04C9\u04CB\u04CD\u04D0\u04D2\u04D4\u04D6\u04D8\u04DA\u04DC\u04DE\u04E0\u04E2\u04E4\u04E6\u04E8\u04EA\u04EC\u04EE\u04F0\u04F2\u04F4\u04F6\u04F8\u04FA\u04FC\u04FE\u0500\u0502\u0504\u0506\u0508\u050A\u050C\u050E\u0510\u0512\u0514\u0516\u0518\u051A\u051C\u051E\u0520\u0522\u0524\u0526\u0528\u052A\u052C\u052E\u0531-\u0556\u10A0-\u10C5\u10C7\u10CD\u13A0-\u13F5\u1E00\u1E02\u1E04\u1E06\u1E08\u1E0A\u1E0C\u1E0E\u1E10\u1E12\u1E14\u1E16\u1E18\u1E1A\u1E1C\u1E1E\u1E20\u1E22\u1E24\u1E26\u1E28\u1E2A\u1E2C\u1E2E\u1E30\u1E32\u1E34\u1E36\u1E38\u1E3A\u1E3C\u1E3E\u1E40\u1E42\u1E44\u1E46\u1E48\u1E4A\u1E4C\u1E4E\u1E50\u1E52\u1E54\u1E56\u1E58\u1E5A\u1E5C\u1E5E\u1E60\u1E62\u1E64\u1E66\u1E68\u1E6A\u1E6C\u1E6E\u1E70\u1E72\u1E74\u1E76\u1E78\u1E7A\u1E7C\u1E7E\u1E80\u1E82\u1E84\u1E86\u1E88\u1E8A\u1E8C\u1E8E\u1E90\u1E92\u1E94\u1E9E\u1EA0\u1EA2\u1EA4\u1EA6\u1EA8\u1EAA\u1EAC\u1EAE\u1EB0\u1EB2\u1EB4\u1EB6\u1EB8\u1EBA\u1EBC\u1EBE\u1EC0\u1EC2\u1EC4\u1EC6\u1EC8\u1ECA\u1ECC\u1ECE\u1ED0\u1ED2\u1ED4\u1ED6\u1ED8\u1EDA\u1EDC\u1EDE\u1EE0\u1EE2\u1EE4\u1EE6\u1EE8\u1EEA\u1EEC\u1EEE\u1EF0\u1EF2\u1EF4\u1EF6\u1EF8\u1EFA\u1EFC\u1EFE\u1F08-\u1F0F\u1F18-\u1F1D\u1F28-\u1F2F\u1F38-\u1F3F\u1F48-\u1F4D\u1F59\u1F5B\u1F5D\u1F5F\u1F68-\u1F6F\u1FB8-\u1FBB\u1FC8-\u1FCB\u1FD8-\u1FDB\u1FE8-\u1FEC\u1FF8-\u1FFB\u2102\u2107\u210B-\u210D\u2110-\u2112\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u2130-\u2133\u213E\u213F\u2145\u2183\u2C00-\u2C2E\u2C60\u2C62-\u2C64\u2C67\u2C69\u2C6B\u2C6D-\u2C70\u2C72\u2C75\u2C7E-\u2C80\u2C82\u2C84\u2C86\u2C88\u2C8A\u2C8C\u2C8E\u2C90\u2C92\u2C94\u2C96\u2C98\u2C9A\u2C9C\u2C9E\u2CA0\u2CA2\u2CA4\u2CA6\u2CA8\u2CAA\u2CAC\u2CAE\u2CB0\u2CB2\u2CB4\u2CB6\u2CB8\u2CBA\u2CBC\u2CBE\u2CC0\u2CC2\u2CC4\u2CC6\u2CC8\u2CCA\u2CCC\u2CCE\u2CD0\u2CD2\u2CD4\u2CD6\u2CD8\u2CDA\u2CDC\u2CDE\u2CE0\u2CE2\u2CEB\u2CED\u2CF2\uA640\uA642\uA644\uA646\uA648\uA64A\uA64C\uA64E\uA650\uA652\uA654\uA656\uA658\uA65A\uA65C\uA65E\uA660\uA662\uA664\uA666\uA668\uA66A\uA66C\uA680\uA682\uA684\uA686\uA688\uA68A\uA68C\uA68E\uA690\uA692\uA694\uA696\uA698\uA69A\uA722\uA724\uA726\uA728\uA72A\uA72C\uA72E\uA732\uA734\uA736\uA738\uA73A\uA73C\uA73E\uA740\uA742\uA744\uA746\uA748\uA74A\uA74C\uA74E\uA750\uA752\uA754\uA756\uA758\uA75A\uA75C\uA75E\uA760\uA762\uA764\uA766\uA768\uA76A\uA76C\uA76E\uA779\uA77B\uA77D\uA77E\uA780\uA782\uA784\uA786\uA78B\uA78D\uA790\uA792\uA796\uA798\uA79A\uA79C\uA79E\uA7A0\uA7A2\uA7A4\uA7A6\uA7A8\uA7AA-\uA7AD\uA7B0-\uA7B4\uA7B6\uFF21-\uFF3A',
            astral: '\uD806[\uDCA0-\uDCBF]|\uD803[\uDC80-\uDCB2]|\uD801[\uDC00-\uDC27]|\uD835[\uDC00-\uDC19\uDC34-\uDC4D\uDC68-\uDC81\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB5\uDCD0-\uDCE9\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD38\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD6C-\uDD85\uDDA0-\uDDB9\uDDD4-\uDDED\uDE08-\uDE21\uDE3C-\uDE55\uDE70-\uDE89\uDEA8-\uDEC0\uDEE2-\uDEFA\uDF1C-\uDF34\uDF56-\uDF6E\uDF90-\uDFA8\uDFCA]'
        },
        {
            name: 'M',
            alias: 'Mark',
            bmp: '\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D01-\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u192B\u1930-\u193B\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFC-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F',
            astral: '\uD805[\uDCB0-\uDCC3\uDDAF-\uDDB5\uDDB8-\uDDC0\uDDDC\uDDDD\uDE30-\uDE40\uDEAB-\uDEB7\uDF1D-\uDF2B]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD804[\uDC00-\uDC02\uDC38-\uDC46\uDC7F-\uDC82\uDCB0-\uDCBA\uDD00-\uDD02\uDD27-\uDD34\uDD73\uDD80-\uDD82\uDDB3-\uDDC0\uDDCA-\uDDCC\uDE2C-\uDE37\uDEDF-\uDEEA\uDF00-\uDF03\uDF3C\uDF3E-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD81B[\uDF51-\uDF7E\uDF8F-\uDF92]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD82F[\uDC9D\uDC9E]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD83A[\uDCD0-\uDCD6]|\uDB40[\uDD00-\uDDEF]'
        },
        {
            name: 'Mc',
            alias: 'Spacing_Mark',
            bmp: '\u0903\u093B\u093E-\u0940\u0949-\u094C\u094E\u094F\u0982\u0983\u09BE-\u09C0\u09C7\u09C8\u09CB\u09CC\u09D7\u0A03\u0A3E-\u0A40\u0A83\u0ABE-\u0AC0\u0AC9\u0ACB\u0ACC\u0B02\u0B03\u0B3E\u0B40\u0B47\u0B48\u0B4B\u0B4C\u0B57\u0BBE\u0BBF\u0BC1\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0BD7\u0C01-\u0C03\u0C41-\u0C44\u0C82\u0C83\u0CBE\u0CC0-\u0CC4\u0CC7\u0CC8\u0CCA\u0CCB\u0CD5\u0CD6\u0D02\u0D03\u0D3E-\u0D40\u0D46-\u0D48\u0D4A-\u0D4C\u0D57\u0D82\u0D83\u0DCF-\u0DD1\u0DD8-\u0DDF\u0DF2\u0DF3\u0F3E\u0F3F\u0F7F\u102B\u102C\u1031\u1038\u103B\u103C\u1056\u1057\u1062-\u1064\u1067-\u106D\u1083\u1084\u1087-\u108C\u108F\u109A-\u109C\u17B6\u17BE-\u17C5\u17C7\u17C8\u1923-\u1926\u1929-\u192B\u1930\u1931\u1933-\u1938\u1A19\u1A1A\u1A55\u1A57\u1A61\u1A63\u1A64\u1A6D-\u1A72\u1B04\u1B35\u1B3B\u1B3D-\u1B41\u1B43\u1B44\u1B82\u1BA1\u1BA6\u1BA7\u1BAA\u1BE7\u1BEA-\u1BEC\u1BEE\u1BF2\u1BF3\u1C24-\u1C2B\u1C34\u1C35\u1CE1\u1CF2\u1CF3\u302E\u302F\uA823\uA824\uA827\uA880\uA881\uA8B4-\uA8C3\uA952\uA953\uA983\uA9B4\uA9B5\uA9BA\uA9BB\uA9BD-\uA9C0\uAA2F\uAA30\uAA33\uAA34\uAA4D\uAA7B\uAA7D\uAAEB\uAAEE\uAAEF\uAAF5\uABE3\uABE4\uABE6\uABE7\uABE9\uABEA\uABEC',
            astral: '\uD834[\uDD65\uDD66\uDD6D-\uDD72]|\uD804[\uDC00\uDC02\uDC82\uDCB0-\uDCB2\uDCB7\uDCB8\uDD2C\uDD82\uDDB3-\uDDB5\uDDBF\uDDC0\uDE2C-\uDE2E\uDE32\uDE33\uDE35\uDEE0-\uDEE2\uDF02\uDF03\uDF3E\uDF3F\uDF41-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63]|\uD805[\uDCB0-\uDCB2\uDCB9\uDCBB-\uDCBE\uDCC1\uDDAF-\uDDB1\uDDB8-\uDDBB\uDDBE\uDE30-\uDE32\uDE3B\uDE3C\uDE3E\uDEAC\uDEAE\uDEAF\uDEB6\uDF20\uDF21\uDF26]|\uD81B[\uDF51-\uDF7E]'
        },
        {
            name: 'Me',
            alias: 'Enclosing_Mark',
            bmp: '\u0488\u0489\u1ABE\u20DD-\u20E0\u20E2-\u20E4\uA670-\uA672'
        },
        {
            name: 'Mn',
            alias: 'Nonspacing_Mark',
            bmp: '\u0300-\u036F\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0C00\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC6\u0CCC\u0CCD\u0CE2\u0CE3\u0D01\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ABD\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFC-\u1DFF\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u3099\u309A\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F',
            astral: '\uD805[\uDCB3-\uDCB8\uDCBA\uDCBF\uDCC0\uDCC2\uDCC3\uDDB2-\uDDB5\uDDBC\uDDBD\uDDBF\uDDC0\uDDDC\uDDDD\uDE33-\uDE3A\uDE3D\uDE3F\uDE40\uDEAB\uDEAD\uDEB0-\uDEB5\uDEB7\uDF1D-\uDF1F\uDF22-\uDF25\uDF27-\uDF2B]|\uD834[\uDD67-\uDD69\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF8F-\uDF92]|\uD82F[\uDC9D\uDC9E]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD804[\uDC01\uDC38-\uDC46\uDC7F-\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDD00-\uDD02\uDD27-\uDD2B\uDD2D-\uDD34\uDD73\uDD80\uDD81\uDDB6-\uDDBE\uDDCA-\uDDCC\uDE2F-\uDE31\uDE34\uDE36\uDE37\uDEDF\uDEE3-\uDEEA\uDF00\uDF01\uDF3C\uDF40\uDF66-\uDF6C\uDF70-\uDF74]|\uD83A[\uDCD0-\uDCD6]|\uDB40[\uDD00-\uDDEF]'
        },
        {
            name: 'N',
            alias: 'Number',
            bmp: '0-9\xB2\xB3\xB9\xBC-\xBE\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u09F4-\u09F9\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0B72-\u0B77\u0BE6-\u0BF2\u0C66-\u0C6F\u0C78-\u0C7E\u0CE6-\u0CEF\u0D66-\u0D75\u0DE6-\u0DEF\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F33\u1040-\u1049\u1090-\u1099\u1369-\u137C\u16EE-\u16F0\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1946-\u194F\u19D0-\u19DA\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\u2070\u2074-\u2079\u2080-\u2089\u2150-\u2182\u2185-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2CFD\u3007\u3021-\u3029\u3038-\u303A\u3192-\u3195\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\uA620-\uA629\uA6E6-\uA6EF\uA830-\uA835\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uA9F0-\uA9F9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19',
            astral: '\uD800[\uDD07-\uDD33\uDD40-\uDD78\uDD8A\uDD8B\uDEE1-\uDEFB\uDF20-\uDF23\uDF41\uDF4A\uDFD1-\uDFD5]|\uD801[\uDCA0-\uDCA9]|\uD803[\uDCFA-\uDCFF\uDE60-\uDE7E]|\uD835[\uDFCE-\uDFFF]|\uD83A[\uDCC7-\uDCCF]|\uD81A[\uDE60-\uDE69\uDF50-\uDF59\uDF5B-\uDF61]|\uD806[\uDCE0-\uDCF2]|\uD804[\uDC52-\uDC6F\uDCF0-\uDCF9\uDD36-\uDD3F\uDDD0-\uDDD9\uDDE1-\uDDF4\uDEF0-\uDEF9]|\uD834[\uDF60-\uDF71]|\uD83C[\uDD00-\uDD0C]|\uD809[\uDC00-\uDC6E]|\uD802[\uDC58-\uDC5F\uDC79-\uDC7F\uDCA7-\uDCAF\uDCFB-\uDCFF\uDD16-\uDD1B\uDDBC\uDDBD\uDDC0-\uDDCF\uDDD2-\uDDFF\uDE40-\uDE47\uDE7D\uDE7E\uDE9D-\uDE9F\uDEEB-\uDEEF\uDF58-\uDF5F\uDF78-\uDF7F\uDFA9-\uDFAF]|\uD805[\uDCD0-\uDCD9\uDE50-\uDE59\uDEC0-\uDEC9\uDF30-\uDF3B]'
        },
        {
            name: 'Nd',
            alias: 'Decimal_Number',
            bmp: '0-9\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0BE6-\u0BEF\u0C66-\u0C6F\u0CE6-\u0CEF\u0D66-\u0D6F\u0DE6-\u0DEF\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F29\u1040-\u1049\u1090-\u1099\u17E0-\u17E9\u1810-\u1819\u1946-\u194F\u19D0-\u19D9\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\uA620-\uA629\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uA9F0-\uA9F9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19',
            astral: '\uD801[\uDCA0-\uDCA9]|\uD835[\uDFCE-\uDFFF]|\uD805[\uDCD0-\uDCD9\uDE50-\uDE59\uDEC0-\uDEC9\uDF30-\uDF39]|\uD806[\uDCE0-\uDCE9]|\uD804[\uDC66-\uDC6F\uDCF0-\uDCF9\uDD36-\uDD3F\uDDD0-\uDDD9\uDEF0-\uDEF9]|\uD81A[\uDE60-\uDE69\uDF50-\uDF59]'
        },
        {
            name: 'Nl',
            alias: 'Letter_Number',
            bmp: '\u16EE-\u16F0\u2160-\u2182\u2185-\u2188\u3007\u3021-\u3029\u3038-\u303A\uA6E6-\uA6EF',
            astral: '\uD809[\uDC00-\uDC6E]|\uD800[\uDD40-\uDD74\uDF41\uDF4A\uDFD1-\uDFD5]'
        },
        {
            name: 'No',
            alias: 'Other_Number',
            bmp: '\xB2\xB3\xB9\xBC-\xBE\u09F4-\u09F9\u0B72-\u0B77\u0BF0-\u0BF2\u0C78-\u0C7E\u0D70-\u0D75\u0F2A-\u0F33\u1369-\u137C\u17F0-\u17F9\u19DA\u2070\u2074-\u2079\u2080-\u2089\u2150-\u215F\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2CFD\u3192-\u3195\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\uA830-\uA835',
            astral: '\uD804[\uDC52-\uDC65\uDDE1-\uDDF4]|\uD803[\uDCFA-\uDCFF\uDE60-\uDE7E]|\uD83C[\uDD00-\uDD0C]|\uD806[\uDCEA-\uDCF2]|\uD83A[\uDCC7-\uDCCF]|\uD802[\uDC58-\uDC5F\uDC79-\uDC7F\uDCA7-\uDCAF\uDCFB-\uDCFF\uDD16-\uDD1B\uDDBC\uDDBD\uDDC0-\uDDCF\uDDD2-\uDDFF\uDE40-\uDE47\uDE7D\uDE7E\uDE9D-\uDE9F\uDEEB-\uDEEF\uDF58-\uDF5F\uDF78-\uDF7F\uDFA9-\uDFAF]|\uD805[\uDF3A\uDF3B]|\uD81A[\uDF5B-\uDF61]|\uD834[\uDF60-\uDF71]|\uD800[\uDD07-\uDD33\uDD75-\uDD78\uDD8A\uDD8B\uDEE1-\uDEFB\uDF20-\uDF23]'
        },
        {
            name: 'P',
            alias: 'Punctuation',
            bmp: '\x21-\x23\x25-\\x2A\x2C-\x2F\x3A\x3B\\x3F\x40\\x5B-\\x5D\x5F\\x7B\x7D\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E42\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65',
            astral: '\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD809[\uDC70-\uDC74]|\uD805[\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDF3C-\uDF3E]|\uD836[\uDE87-\uDE8B]|\uD801\uDD6F|\uD82F\uDC9F|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC9\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]'
        },
        {
            name: 'Pc',
            alias: 'Connector_Punctuation',
            bmp: '\x5F\u203F\u2040\u2054\uFE33\uFE34\uFE4D-\uFE4F\uFF3F'
        },
        {
            name: 'Pd',
            alias: 'Dash_Punctuation',
            bmp: '\\x2D\u058A\u05BE\u1400\u1806\u2010-\u2015\u2E17\u2E1A\u2E3A\u2E3B\u2E40\u301C\u3030\u30A0\uFE31\uFE32\uFE58\uFE63\uFF0D'
        },
        {
            name: 'Pe',
            alias: 'Close_Punctuation',
            bmp: '\\x29\\x5D\x7D\u0F3B\u0F3D\u169C\u2046\u207E\u208E\u2309\u230B\u232A\u2769\u276B\u276D\u276F\u2771\u2773\u2775\u27C6\u27E7\u27E9\u27EB\u27ED\u27EF\u2984\u2986\u2988\u298A\u298C\u298E\u2990\u2992\u2994\u2996\u2998\u29D9\u29DB\u29FD\u2E23\u2E25\u2E27\u2E29\u3009\u300B\u300D\u300F\u3011\u3015\u3017\u3019\u301B\u301E\u301F\uFD3E\uFE18\uFE36\uFE38\uFE3A\uFE3C\uFE3E\uFE40\uFE42\uFE44\uFE48\uFE5A\uFE5C\uFE5E\uFF09\uFF3D\uFF5D\uFF60\uFF63'
        },
        {
            name: 'Pf',
            alias: 'Final_Punctuation',
            bmp: '\xBB\u2019\u201D\u203A\u2E03\u2E05\u2E0A\u2E0D\u2E1D\u2E21'
        },
        {
            name: 'Pi',
            alias: 'Initial_Punctuation',
            bmp: '\xAB\u2018\u201B\u201C\u201F\u2039\u2E02\u2E04\u2E09\u2E0C\u2E1C\u2E20'
        },
        {
            name: 'Po',
            alias: 'Other_Punctuation',
            bmp: '\x21-\x23\x25-\x27\\x2A\x2C\\x2E\x2F\x3A\x3B\\x3F\x40\\x5C\xA1\xA7\xB6\xB7\xBF\u037E\u0387\u055A-\u055F\u0589\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u166D\u166E\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u1805\u1807-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2016\u2017\u2020-\u2027\u2030-\u2038\u203B-\u203E\u2041-\u2043\u2047-\u2051\u2053\u2055-\u205E\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00\u2E01\u2E06-\u2E08\u2E0B\u2E0E-\u2E16\u2E18\u2E19\u2E1B\u2E1E\u2E1F\u2E2A-\u2E2E\u2E30-\u2E39\u2E3C-\u2E3F\u2E41\u3001-\u3003\u303D\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFE10-\uFE16\uFE19\uFE30\uFE45\uFE46\uFE49-\uFE4C\uFE50-\uFE52\uFE54-\uFE57\uFE5F-\uFE61\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF07\uFF0A\uFF0C\uFF0E\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3C\uFF61\uFF64\uFF65',
            astral: '\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD809[\uDC70-\uDC74]|\uD805[\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDF3C-\uDF3E]|\uD836[\uDE87-\uDE8B]|\uD801\uDD6F|\uD82F\uDC9F|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC9\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]'
        },
        {
            name: 'Ps',
            alias: 'Open_Punctuation',
            bmp: '\\x28\\x5B\\x7B\u0F3A\u0F3C\u169B\u201A\u201E\u2045\u207D\u208D\u2308\u230A\u2329\u2768\u276A\u276C\u276E\u2770\u2772\u2774\u27C5\u27E6\u27E8\u27EA\u27EC\u27EE\u2983\u2985\u2987\u2989\u298B\u298D\u298F\u2991\u2993\u2995\u2997\u29D8\u29DA\u29FC\u2E22\u2E24\u2E26\u2E28\u2E42\u3008\u300A\u300C\u300E\u3010\u3014\u3016\u3018\u301A\u301D\uFD3F\uFE17\uFE35\uFE37\uFE39\uFE3B\uFE3D\uFE3F\uFE41\uFE43\uFE47\uFE59\uFE5B\uFE5D\uFF08\uFF3B\uFF5B\uFF5F\uFF62'
        },
        {
            name: 'S',
            alias: 'Symbol',
            bmp: '\\x24\\x2B\x3C-\x3E\\x5E\x60\\x7C\x7E\xA2-\xA6\xA8\xA9\xAC\xAE-\xB1\xB4\xB8\xD7\xF7\u02C2-\u02C5\u02D2-\u02DF\u02E5-\u02EB\u02ED\u02EF-\u02FF\u0375\u0384\u0385\u03F6\u0482\u058D-\u058F\u0606-\u0608\u060B\u060E\u060F\u06DE\u06E9\u06FD\u06FE\u07F6\u09F2\u09F3\u09FA\u09FB\u0AF1\u0B70\u0BF3-\u0BFA\u0C7F\u0D79\u0E3F\u0F01-\u0F03\u0F13\u0F15-\u0F17\u0F1A-\u0F1F\u0F34\u0F36\u0F38\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE\u0FCF\u0FD5-\u0FD8\u109E\u109F\u1390-\u1399\u17DB\u1940\u19DE-\u19FF\u1B61-\u1B6A\u1B74-\u1B7C\u1FBD\u1FBF-\u1FC1\u1FCD-\u1FCF\u1FDD-\u1FDF\u1FED-\u1FEF\u1FFD\u1FFE\u2044\u2052\u207A-\u207C\u208A-\u208C\u20A0-\u20BE\u2100\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u2140-\u2144\u214A-\u214D\u214F\u218A\u218B\u2190-\u2307\u230C-\u2328\u232B-\u23FA\u2400-\u2426\u2440-\u244A\u249C-\u24E9\u2500-\u2767\u2794-\u27C4\u27C7-\u27E5\u27F0-\u2982\u2999-\u29D7\u29DC-\u29FB\u29FE-\u2B73\u2B76-\u2B95\u2B98-\u2BB9\u2BBD-\u2BC8\u2BCA-\u2BD1\u2BEC-\u2BEF\u2CE5-\u2CEA\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFB\u3004\u3012\u3013\u3020\u3036\u3037\u303E\u303F\u309B\u309C\u3190\u3191\u3196-\u319F\u31C0-\u31E3\u3200-\u321E\u322A-\u3247\u3250\u3260-\u327F\u328A-\u32B0\u32C0-\u32FE\u3300-\u33FF\u4DC0-\u4DFF\uA490-\uA4C6\uA700-\uA716\uA720\uA721\uA789\uA78A\uA828-\uA82B\uA836-\uA839\uAA77-\uAA79\uAB5B\uFB29\uFBB2-\uFBC1\uFDFC\uFDFD\uFE62\uFE64-\uFE66\uFE69\uFF04\uFF0B\uFF1C-\uFF1E\uFF3E\uFF40\uFF5C\uFF5E\uFFE0-\uFFE6\uFFE8-\uFFEE\uFFFC\uFFFD',
            astral: '\uD83E[\uDC00-\uDC0B\uDC10-\uDC47\uDC50-\uDC59\uDC60-\uDC87\uDC90-\uDCAD\uDD10-\uDD18\uDD80-\uDD84\uDDC0]|\uD83C[\uDC00-\uDC2B\uDC30-\uDC93\uDCA0-\uDCAE\uDCB1-\uDCBF\uDCC1-\uDCCF\uDCD1-\uDCF5\uDD10-\uDD2E\uDD30-\uDD6B\uDD70-\uDD9A\uDDE6-\uDE02\uDE10-\uDE3A\uDE40-\uDE48\uDE50\uDE51\uDF00-\uDFFF]|\uD83D[\uDC00-\uDD79\uDD7B-\uDDA3\uDDA5-\uDED0\uDEE0-\uDEEC\uDEF0-\uDEF3\uDF00-\uDF73\uDF80-\uDFD4]|\uD835[\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3]|\uD800[\uDD37-\uDD3F\uDD79-\uDD89\uDD8C\uDD90-\uDD9B\uDDA0\uDDD0-\uDDFC]|\uD82F\uDC9C|\uD805\uDF3F|\uD802[\uDC77\uDC78\uDEC8]|\uD81A[\uDF3C-\uDF3F\uDF45]|\uD836[\uDC00-\uDDFF\uDE37-\uDE3A\uDE6D-\uDE74\uDE76-\uDE83\uDE85\uDE86]|\uD834[\uDC00-\uDCF5\uDD00-\uDD26\uDD29-\uDD64\uDD6A-\uDD6C\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDDE8\uDE00-\uDE41\uDE45\uDF00-\uDF56]|\uD83B[\uDEF0\uDEF1]'
        },
        {
            name: 'Sc',
            alias: 'Currency_Symbol',
            bmp: '\\x24\xA2-\xA5\u058F\u060B\u09F2\u09F3\u09FB\u0AF1\u0BF9\u0E3F\u17DB\u20A0-\u20BE\uA838\uFDFC\uFE69\uFF04\uFFE0\uFFE1\uFFE5\uFFE6'
        },
        {
            name: 'Sk',
            alias: 'Modifier_Symbol',
            bmp: '\\x5E\x60\xA8\xAF\xB4\xB8\u02C2-\u02C5\u02D2-\u02DF\u02E5-\u02EB\u02ED\u02EF-\u02FF\u0375\u0384\u0385\u1FBD\u1FBF-\u1FC1\u1FCD-\u1FCF\u1FDD-\u1FDF\u1FED-\u1FEF\u1FFD\u1FFE\u309B\u309C\uA700-\uA716\uA720\uA721\uA789\uA78A\uAB5B\uFBB2-\uFBC1\uFF3E\uFF40\uFFE3',
            astral: '\uD83C[\uDFFB-\uDFFF]'
        },
        {
            name: 'Sm',
            alias: 'Math_Symbol',
            bmp: '\\x2B\x3C-\x3E\\x7C\x7E\xAC\xB1\xD7\xF7\u03F6\u0606-\u0608\u2044\u2052\u207A-\u207C\u208A-\u208C\u2118\u2140-\u2144\u214B\u2190-\u2194\u219A\u219B\u21A0\u21A3\u21A6\u21AE\u21CE\u21CF\u21D2\u21D4\u21F4-\u22FF\u2320\u2321\u237C\u239B-\u23B3\u23DC-\u23E1\u25B7\u25C1\u25F8-\u25FF\u266F\u27C0-\u27C4\u27C7-\u27E5\u27F0-\u27FF\u2900-\u2982\u2999-\u29D7\u29DC-\u29FB\u29FE-\u2AFF\u2B30-\u2B44\u2B47-\u2B4C\uFB29\uFE62\uFE64-\uFE66\uFF0B\uFF1C-\uFF1E\uFF5C\uFF5E\uFFE2\uFFE9-\uFFEC',
            astral: '\uD83B[\uDEF0\uDEF1]|\uD835[\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3]'
        },
        {
            name: 'So',
            alias: 'Other_Symbol',
            bmp: '\xA6\xA9\xAE\xB0\u0482\u058D\u058E\u060E\u060F\u06DE\u06E9\u06FD\u06FE\u07F6\u09FA\u0B70\u0BF3-\u0BF8\u0BFA\u0C7F\u0D79\u0F01-\u0F03\u0F13\u0F15-\u0F17\u0F1A-\u0F1F\u0F34\u0F36\u0F38\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE\u0FCF\u0FD5-\u0FD8\u109E\u109F\u1390-\u1399\u1940\u19DE-\u19FF\u1B61-\u1B6A\u1B74-\u1B7C\u2100\u2101\u2103-\u2106\u2108\u2109\u2114\u2116\u2117\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u214A\u214C\u214D\u214F\u218A\u218B\u2195-\u2199\u219C-\u219F\u21A1\u21A2\u21A4\u21A5\u21A7-\u21AD\u21AF-\u21CD\u21D0\u21D1\u21D3\u21D5-\u21F3\u2300-\u2307\u230C-\u231F\u2322-\u2328\u232B-\u237B\u237D-\u239A\u23B4-\u23DB\u23E2-\u23FA\u2400-\u2426\u2440-\u244A\u249C-\u24E9\u2500-\u25B6\u25B8-\u25C0\u25C2-\u25F7\u2600-\u266E\u2670-\u2767\u2794-\u27BF\u2800-\u28FF\u2B00-\u2B2F\u2B45\u2B46\u2B4D-\u2B73\u2B76-\u2B95\u2B98-\u2BB9\u2BBD-\u2BC8\u2BCA-\u2BD1\u2BEC-\u2BEF\u2CE5-\u2CEA\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFB\u3004\u3012\u3013\u3020\u3036\u3037\u303E\u303F\u3190\u3191\u3196-\u319F\u31C0-\u31E3\u3200-\u321E\u322A-\u3247\u3250\u3260-\u327F\u328A-\u32B0\u32C0-\u32FE\u3300-\u33FF\u4DC0-\u4DFF\uA490-\uA4C6\uA828-\uA82B\uA836\uA837\uA839\uAA77-\uAA79\uFDFD\uFFE4\uFFE8\uFFED\uFFEE\uFFFC\uFFFD',
            astral: '\uD83E[\uDC00-\uDC0B\uDC10-\uDC47\uDC50-\uDC59\uDC60-\uDC87\uDC90-\uDCAD\uDD10-\uDD18\uDD80-\uDD84\uDDC0]|\uD83D[\uDC00-\uDD79\uDD7B-\uDDA3\uDDA5-\uDED0\uDEE0-\uDEEC\uDEF0-\uDEF3\uDF00-\uDF73\uDF80-\uDFD4]|\uD83C[\uDC00-\uDC2B\uDC30-\uDC93\uDCA0-\uDCAE\uDCB1-\uDCBF\uDCC1-\uDCCF\uDCD1-\uDCF5\uDD10-\uDD2E\uDD30-\uDD6B\uDD70-\uDD9A\uDDE6-\uDE02\uDE10-\uDE3A\uDE40-\uDE48\uDE50\uDE51\uDF00-\uDFFA]|\uD800[\uDD37-\uDD3F\uDD79-\uDD89\uDD8C\uDD90-\uDD9B\uDDA0\uDDD0-\uDDFC]|\uD82F\uDC9C|\uD805\uDF3F|\uD802[\uDC77\uDC78\uDEC8]|\uD81A[\uDF3C-\uDF3F\uDF45]|\uD836[\uDC00-\uDDFF\uDE37-\uDE3A\uDE6D-\uDE74\uDE76-\uDE83\uDE85\uDE86]|\uD834[\uDC00-\uDCF5\uDD00-\uDD26\uDD29-\uDD64\uDD6A-\uDD6C\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDDE8\uDE00-\uDE41\uDE45\uDF00-\uDF56]'
        },
        {
            name: 'Z',
            alias: 'Separator',
            bmp: '\x20\xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000'
        },
        {
            name: 'Zl',
            alias: 'Line_Separator',
            bmp: '\u2028'
        },
        {
            name: 'Zp',
            alias: 'Paragraph_Separator',
            bmp: '\u2029'
        },
        {
            name: 'Zs',
            alias: 'Space_Separator',
            bmp: '\x20\xA0\u1680\u2000-\u200A\u202F\u205F\u3000'
        }
    ]);

}(XRegExp));

/*!
 * XRegExp Unicode Properties 3.0.0
 * <http://xregexp.com/>
 * Steven Levithan (c) 2012-2015 MIT License
 * Unicode data provided by Mathias Bynens <http://mathiasbynens.be/>
 */

/**
 * Adds properties to meet the UTS #18 Level 1 RL1.2 requirements for Unicode regex support. See
 * <http://unicode.org/reports/tr18/#RL1.2>. Following are definitions of these properties from UAX
 * #44 <http://unicode.org/reports/tr44/>:
 *
 * - Alphabetic
 *   Characters with the Alphabetic property. Generated from: Lowercase + Uppercase + Lt + Lm + Lo +
 *   Nl + Other_Alphabetic.
 *
 * - Default_Ignorable_Code_Point
 *   For programmatic determination of default ignorable code points. New characters that should be
 *   ignored in rendering (unless explicitly supported) will be assigned in these ranges, permitting
 *   programs to correctly handle the default rendering of such characters when not otherwise
 *   supported.
 *
 * - Lowercase
 *   Characters with the Lowercase property. Generated from: Ll + Other_Lowercase.
 *
 * - Noncharacter_Code_Point
 *   Code points permanently reserved for internal use.
 *
 * - Uppercase
 *   Characters with the Uppercase property. Generated from: Lu + Other_Uppercase.
 *
 * - White_Space
 *   Spaces, separator characters and other control characters which should be treated by
 *   programming languages as "white space" for the purpose of parsing elements.
 *
 * The properties ASCII, Any, and Assigned are also included but are not defined in UAX #44. UTS #18
 * RL1.2 additionally requires support for Unicode scripts and general categories. These are
 * included in XRegExp's Unicode Categories and Unicode Scripts addons.
 *
 * Token names are case insensitive, and any spaces, hyphens, and underscores are ignored.
 *
 * Uses Unicode 8.0.0.
 *
 * @requires XRegExp, Unicode Base
 */
(function(XRegExp) {
    'use strict';

    if (!XRegExp.addUnicodeData) {
        throw new ReferenceError('Unicode Base must be loaded before Unicode Properties');
    }

    var unicodeData = [
        {
            name: 'ASCII',
            bmp: '\0-\x7F'
        },
        {
            name: 'Alphabetic',
            bmp: 'A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0345\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05B0-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0657\u0659-\u065F\u066E-\u06D3\u06D5-\u06DC\u06E1-\u06E8\u06ED-\u06EF\u06FA-\u06FC\u06FF\u0710-\u073F\u074D-\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0817\u081A-\u082C\u0840-\u0858\u08A0-\u08B4\u08E3-\u08E9\u08F0-\u093B\u093D-\u094C\u094E-\u0950\u0955-\u0963\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD-\u09C4\u09C7\u09C8\u09CB\u09CC\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09F0\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3E-\u0A42\u0A47\u0A48\u0A4B\u0A4C\u0A51\u0A59-\u0A5C\u0A5E\u0A70-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD-\u0AC5\u0AC7-\u0AC9\u0ACB\u0ACC\u0AD0\u0AE0-\u0AE3\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D-\u0B44\u0B47\u0B48\u0B4B\u0B4C\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0BD0\u0BD7\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4C\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCC\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4C\u0D4E\u0D57\u0D5F-\u0D63\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E46\u0E4D\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0ECD\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F71-\u0F81\u0F88-\u0F97\u0F99-\u0FBC\u1000-\u1036\u1038\u103B-\u103F\u1050-\u1062\u1065-\u1068\u106E-\u1086\u108E\u109C\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1713\u1720-\u1733\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17B3\u17B6-\u17C8\u17D7\u17DC\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u1938\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A1B\u1A20-\u1A5E\u1A61-\u1A74\u1AA7\u1B00-\u1B33\u1B35-\u1B43\u1B45-\u1B4B\u1B80-\u1BA9\u1BAC-\u1BAF\u1BBA-\u1BE5\u1BE7-\u1BF1\u1C00-\u1C35\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1D00-\u1DBF\u1DE7-\u1DF4\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u24B6-\u24E9\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA674-\uA67B\uA67F-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA827\uA840-\uA873\uA880-\uA8C3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA92A\uA930-\uA952\uA960-\uA97C\uA980-\uA9B2\uA9B4-\uA9BF\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA60-\uAA76\uAA7A\uAA7E-\uAABE\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF5\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC',
            astral: '\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD804[\uDC00-\uDC45\uDC82-\uDCB8\uDCD0-\uDCE8\uDD00-\uDD32\uDD50-\uDD72\uDD76\uDD80-\uDDBF\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE34\uDE37\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEE8\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D-\uDF44\uDF47\uDF48\uDF4B\uDF4C\uDF50\uDF57\uDF5D-\uDF63]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD83A[\uDC00-\uDCC4]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF36\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD83C[\uDD30-\uDD49\uDD50-\uDD69\uDD70-\uDD89]|\uD80D[\uDC00-\uDC2E]|\uD87E[\uDC00-\uDE1D]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9E]|\uD808[\uDC00-\uDF99]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD805[\uDC80-\uDCC1\uDCC4\uDCC5\uDCC7\uDD80-\uDDB5\uDDB8-\uDDBE\uDDD8-\uDDDD\uDE00-\uDE3E\uDE40\uDE44\uDE80-\uDEB5\uDF00-\uDF19\uDF1D-\uDF2A]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD811[\uDC00-\uDE46]|\uD82C[\uDC00\uDC01]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF93-\uDF9F]|\uD873[\uDC00-\uDEA1]'
        },
        {
            name: 'Any',
            isBmpLast: true,
            bmp: '\0-\uFFFF',
            astral: '[\uD800-\uDBFF][\uDC00-\uDFFF]'
        },
        {
            name: 'Default_Ignorable_Code_Point',
            bmp: '\xAD\u034F\u061C\u115F\u1160\u17B4\u17B5\u180B-\u180E\u200B-\u200F\u202A-\u202E\u2060-\u206F\u3164\uFE00-\uFE0F\uFEFF\uFFA0\uFFF0-\uFFF8',
            astral: '[\uDB40-\uDB43][\uDC00-\uDFFF]|\uD834[\uDD73-\uDD7A]|\uD82F[\uDCA0-\uDCA3]'
        },
        {
            name: 'Lowercase',
            bmp: 'a-z\xAA\xB5\xBA\xDF-\xF6\xF8-\xFF\u0101\u0103\u0105\u0107\u0109\u010B\u010D\u010F\u0111\u0113\u0115\u0117\u0119\u011B\u011D\u011F\u0121\u0123\u0125\u0127\u0129\u012B\u012D\u012F\u0131\u0133\u0135\u0137\u0138\u013A\u013C\u013E\u0140\u0142\u0144\u0146\u0148\u0149\u014B\u014D\u014F\u0151\u0153\u0155\u0157\u0159\u015B\u015D\u015F\u0161\u0163\u0165\u0167\u0169\u016B\u016D\u016F\u0171\u0173\u0175\u0177\u017A\u017C\u017E-\u0180\u0183\u0185\u0188\u018C\u018D\u0192\u0195\u0199-\u019B\u019E\u01A1\u01A3\u01A5\u01A8\u01AA\u01AB\u01AD\u01B0\u01B4\u01B6\u01B9\u01BA\u01BD-\u01BF\u01C6\u01C9\u01CC\u01CE\u01D0\u01D2\u01D4\u01D6\u01D8\u01DA\u01DC\u01DD\u01DF\u01E1\u01E3\u01E5\u01E7\u01E9\u01EB\u01ED\u01EF\u01F0\u01F3\u01F5\u01F9\u01FB\u01FD\u01FF\u0201\u0203\u0205\u0207\u0209\u020B\u020D\u020F\u0211\u0213\u0215\u0217\u0219\u021B\u021D\u021F\u0221\u0223\u0225\u0227\u0229\u022B\u022D\u022F\u0231\u0233-\u0239\u023C\u023F\u0240\u0242\u0247\u0249\u024B\u024D\u024F-\u0293\u0295-\u02B8\u02C0\u02C1\u02E0-\u02E4\u0345\u0371\u0373\u0377\u037A-\u037D\u0390\u03AC-\u03CE\u03D0\u03D1\u03D5-\u03D7\u03D9\u03DB\u03DD\u03DF\u03E1\u03E3\u03E5\u03E7\u03E9\u03EB\u03ED\u03EF-\u03F3\u03F5\u03F8\u03FB\u03FC\u0430-\u045F\u0461\u0463\u0465\u0467\u0469\u046B\u046D\u046F\u0471\u0473\u0475\u0477\u0479\u047B\u047D\u047F\u0481\u048B\u048D\u048F\u0491\u0493\u0495\u0497\u0499\u049B\u049D\u049F\u04A1\u04A3\u04A5\u04A7\u04A9\u04AB\u04AD\u04AF\u04B1\u04B3\u04B5\u04B7\u04B9\u04BB\u04BD\u04BF\u04C2\u04C4\u04C6\u04C8\u04CA\u04CC\u04CE\u04CF\u04D1\u04D3\u04D5\u04D7\u04D9\u04DB\u04DD\u04DF\u04E1\u04E3\u04E5\u04E7\u04E9\u04EB\u04ED\u04EF\u04F1\u04F3\u04F5\u04F7\u04F9\u04FB\u04FD\u04FF\u0501\u0503\u0505\u0507\u0509\u050B\u050D\u050F\u0511\u0513\u0515\u0517\u0519\u051B\u051D\u051F\u0521\u0523\u0525\u0527\u0529\u052B\u052D\u052F\u0561-\u0587\u13F8-\u13FD\u1D00-\u1DBF\u1E01\u1E03\u1E05\u1E07\u1E09\u1E0B\u1E0D\u1E0F\u1E11\u1E13\u1E15\u1E17\u1E19\u1E1B\u1E1D\u1E1F\u1E21\u1E23\u1E25\u1E27\u1E29\u1E2B\u1E2D\u1E2F\u1E31\u1E33\u1E35\u1E37\u1E39\u1E3B\u1E3D\u1E3F\u1E41\u1E43\u1E45\u1E47\u1E49\u1E4B\u1E4D\u1E4F\u1E51\u1E53\u1E55\u1E57\u1E59\u1E5B\u1E5D\u1E5F\u1E61\u1E63\u1E65\u1E67\u1E69\u1E6B\u1E6D\u1E6F\u1E71\u1E73\u1E75\u1E77\u1E79\u1E7B\u1E7D\u1E7F\u1E81\u1E83\u1E85\u1E87\u1E89\u1E8B\u1E8D\u1E8F\u1E91\u1E93\u1E95-\u1E9D\u1E9F\u1EA1\u1EA3\u1EA5\u1EA7\u1EA9\u1EAB\u1EAD\u1EAF\u1EB1\u1EB3\u1EB5\u1EB7\u1EB9\u1EBB\u1EBD\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7\u1EC9\u1ECB\u1ECD\u1ECF\u1ED1\u1ED3\u1ED5\u1ED7\u1ED9\u1EDB\u1EDD\u1EDF\u1EE1\u1EE3\u1EE5\u1EE7\u1EE9\u1EEB\u1EED\u1EEF\u1EF1\u1EF3\u1EF5\u1EF7\u1EF9\u1EFB\u1EFD\u1EFF-\u1F07\u1F10-\u1F15\u1F20-\u1F27\u1F30-\u1F37\u1F40-\u1F45\u1F50-\u1F57\u1F60-\u1F67\u1F70-\u1F7D\u1F80-\u1F87\u1F90-\u1F97\u1FA0-\u1FA7\u1FB0-\u1FB4\u1FB6\u1FB7\u1FBE\u1FC2-\u1FC4\u1FC6\u1FC7\u1FD0-\u1FD3\u1FD6\u1FD7\u1FE0-\u1FE7\u1FF2-\u1FF4\u1FF6\u1FF7\u2071\u207F\u2090-\u209C\u210A\u210E\u210F\u2113\u212F\u2134\u2139\u213C\u213D\u2146-\u2149\u214E\u2170-\u217F\u2184\u24D0-\u24E9\u2C30-\u2C5E\u2C61\u2C65\u2C66\u2C68\u2C6A\u2C6C\u2C71\u2C73\u2C74\u2C76-\u2C7D\u2C81\u2C83\u2C85\u2C87\u2C89\u2C8B\u2C8D\u2C8F\u2C91\u2C93\u2C95\u2C97\u2C99\u2C9B\u2C9D\u2C9F\u2CA1\u2CA3\u2CA5\u2CA7\u2CA9\u2CAB\u2CAD\u2CAF\u2CB1\u2CB3\u2CB5\u2CB7\u2CB9\u2CBB\u2CBD\u2CBF\u2CC1\u2CC3\u2CC5\u2CC7\u2CC9\u2CCB\u2CCD\u2CCF\u2CD1\u2CD3\u2CD5\u2CD7\u2CD9\u2CDB\u2CDD\u2CDF\u2CE1\u2CE3\u2CE4\u2CEC\u2CEE\u2CF3\u2D00-\u2D25\u2D27\u2D2D\uA641\uA643\uA645\uA647\uA649\uA64B\uA64D\uA64F\uA651\uA653\uA655\uA657\uA659\uA65B\uA65D\uA65F\uA661\uA663\uA665\uA667\uA669\uA66B\uA66D\uA681\uA683\uA685\uA687\uA689\uA68B\uA68D\uA68F\uA691\uA693\uA695\uA697\uA699\uA69B-\uA69D\uA723\uA725\uA727\uA729\uA72B\uA72D\uA72F-\uA731\uA733\uA735\uA737\uA739\uA73B\uA73D\uA73F\uA741\uA743\uA745\uA747\uA749\uA74B\uA74D\uA74F\uA751\uA753\uA755\uA757\uA759\uA75B\uA75D\uA75F\uA761\uA763\uA765\uA767\uA769\uA76B\uA76D\uA76F-\uA778\uA77A\uA77C\uA77F\uA781\uA783\uA785\uA787\uA78C\uA78E\uA791\uA793-\uA795\uA797\uA799\uA79B\uA79D\uA79F\uA7A1\uA7A3\uA7A5\uA7A7\uA7A9\uA7B5\uA7B7\uA7F8-\uA7FA\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABBF\uFB00-\uFB06\uFB13-\uFB17\uFF41-\uFF5A',
            astral: '\uD803[\uDCC0-\uDCF2]|\uD835[\uDC1A-\uDC33\uDC4E-\uDC54\uDC56-\uDC67\uDC82-\uDC9B\uDCB6-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDCEA-\uDD03\uDD1E-\uDD37\uDD52-\uDD6B\uDD86-\uDD9F\uDDBA-\uDDD3\uDDEE-\uDE07\uDE22-\uDE3B\uDE56-\uDE6F\uDE8A-\uDEA5\uDEC2-\uDEDA\uDEDC-\uDEE1\uDEFC-\uDF14\uDF16-\uDF1B\uDF36-\uDF4E\uDF50-\uDF55\uDF70-\uDF88\uDF8A-\uDF8F\uDFAA-\uDFC2\uDFC4-\uDFC9\uDFCB]|\uD801[\uDC28-\uDC4F]|\uD806[\uDCC0-\uDCDF]'
        },
        {
            name: 'Noncharacter_Code_Point',
            bmp: '\uFDD0-\uFDEF\uFFFE\uFFFF',
            astral: '[\uDB3F\uDB7F\uDBBF\uDBFF\uD83F\uD87F\uD8BF\uDAFF\uD97F\uD9BF\uD9FF\uDA3F\uD8FF\uDABF\uDA7F\uD93F][\uDFFE\uDFFF]'
        },
        {
            name: 'Uppercase',
            bmp: 'A-Z\xC0-\xD6\xD8-\xDE\u0100\u0102\u0104\u0106\u0108\u010A\u010C\u010E\u0110\u0112\u0114\u0116\u0118\u011A\u011C\u011E\u0120\u0122\u0124\u0126\u0128\u012A\u012C\u012E\u0130\u0132\u0134\u0136\u0139\u013B\u013D\u013F\u0141\u0143\u0145\u0147\u014A\u014C\u014E\u0150\u0152\u0154\u0156\u0158\u015A\u015C\u015E\u0160\u0162\u0164\u0166\u0168\u016A\u016C\u016E\u0170\u0172\u0174\u0176\u0178\u0179\u017B\u017D\u0181\u0182\u0184\u0186\u0187\u0189-\u018B\u018E-\u0191\u0193\u0194\u0196-\u0198\u019C\u019D\u019F\u01A0\u01A2\u01A4\u01A6\u01A7\u01A9\u01AC\u01AE\u01AF\u01B1-\u01B3\u01B5\u01B7\u01B8\u01BC\u01C4\u01C7\u01CA\u01CD\u01CF\u01D1\u01D3\u01D5\u01D7\u01D9\u01DB\u01DE\u01E0\u01E2\u01E4\u01E6\u01E8\u01EA\u01EC\u01EE\u01F1\u01F4\u01F6-\u01F8\u01FA\u01FC\u01FE\u0200\u0202\u0204\u0206\u0208\u020A\u020C\u020E\u0210\u0212\u0214\u0216\u0218\u021A\u021C\u021E\u0220\u0222\u0224\u0226\u0228\u022A\u022C\u022E\u0230\u0232\u023A\u023B\u023D\u023E\u0241\u0243-\u0246\u0248\u024A\u024C\u024E\u0370\u0372\u0376\u037F\u0386\u0388-\u038A\u038C\u038E\u038F\u0391-\u03A1\u03A3-\u03AB\u03CF\u03D2-\u03D4\u03D8\u03DA\u03DC\u03DE\u03E0\u03E2\u03E4\u03E6\u03E8\u03EA\u03EC\u03EE\u03F4\u03F7\u03F9\u03FA\u03FD-\u042F\u0460\u0462\u0464\u0466\u0468\u046A\u046C\u046E\u0470\u0472\u0474\u0476\u0478\u047A\u047C\u047E\u0480\u048A\u048C\u048E\u0490\u0492\u0494\u0496\u0498\u049A\u049C\u049E\u04A0\u04A2\u04A4\u04A6\u04A8\u04AA\u04AC\u04AE\u04B0\u04B2\u04B4\u04B6\u04B8\u04BA\u04BC\u04BE\u04C0\u04C1\u04C3\u04C5\u04C7\u04C9\u04CB\u04CD\u04D0\u04D2\u04D4\u04D6\u04D8\u04DA\u04DC\u04DE\u04E0\u04E2\u04E4\u04E6\u04E8\u04EA\u04EC\u04EE\u04F0\u04F2\u04F4\u04F6\u04F8\u04FA\u04FC\u04FE\u0500\u0502\u0504\u0506\u0508\u050A\u050C\u050E\u0510\u0512\u0514\u0516\u0518\u051A\u051C\u051E\u0520\u0522\u0524\u0526\u0528\u052A\u052C\u052E\u0531-\u0556\u10A0-\u10C5\u10C7\u10CD\u13A0-\u13F5\u1E00\u1E02\u1E04\u1E06\u1E08\u1E0A\u1E0C\u1E0E\u1E10\u1E12\u1E14\u1E16\u1E18\u1E1A\u1E1C\u1E1E\u1E20\u1E22\u1E24\u1E26\u1E28\u1E2A\u1E2C\u1E2E\u1E30\u1E32\u1E34\u1E36\u1E38\u1E3A\u1E3C\u1E3E\u1E40\u1E42\u1E44\u1E46\u1E48\u1E4A\u1E4C\u1E4E\u1E50\u1E52\u1E54\u1E56\u1E58\u1E5A\u1E5C\u1E5E\u1E60\u1E62\u1E64\u1E66\u1E68\u1E6A\u1E6C\u1E6E\u1E70\u1E72\u1E74\u1E76\u1E78\u1E7A\u1E7C\u1E7E\u1E80\u1E82\u1E84\u1E86\u1E88\u1E8A\u1E8C\u1E8E\u1E90\u1E92\u1E94\u1E9E\u1EA0\u1EA2\u1EA4\u1EA6\u1EA8\u1EAA\u1EAC\u1EAE\u1EB0\u1EB2\u1EB4\u1EB6\u1EB8\u1EBA\u1EBC\u1EBE\u1EC0\u1EC2\u1EC4\u1EC6\u1EC8\u1ECA\u1ECC\u1ECE\u1ED0\u1ED2\u1ED4\u1ED6\u1ED8\u1EDA\u1EDC\u1EDE\u1EE0\u1EE2\u1EE4\u1EE6\u1EE8\u1EEA\u1EEC\u1EEE\u1EF0\u1EF2\u1EF4\u1EF6\u1EF8\u1EFA\u1EFC\u1EFE\u1F08-\u1F0F\u1F18-\u1F1D\u1F28-\u1F2F\u1F38-\u1F3F\u1F48-\u1F4D\u1F59\u1F5B\u1F5D\u1F5F\u1F68-\u1F6F\u1FB8-\u1FBB\u1FC8-\u1FCB\u1FD8-\u1FDB\u1FE8-\u1FEC\u1FF8-\u1FFB\u2102\u2107\u210B-\u210D\u2110-\u2112\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u2130-\u2133\u213E\u213F\u2145\u2160-\u216F\u2183\u24B6-\u24CF\u2C00-\u2C2E\u2C60\u2C62-\u2C64\u2C67\u2C69\u2C6B\u2C6D-\u2C70\u2C72\u2C75\u2C7E-\u2C80\u2C82\u2C84\u2C86\u2C88\u2C8A\u2C8C\u2C8E\u2C90\u2C92\u2C94\u2C96\u2C98\u2C9A\u2C9C\u2C9E\u2CA0\u2CA2\u2CA4\u2CA6\u2CA8\u2CAA\u2CAC\u2CAE\u2CB0\u2CB2\u2CB4\u2CB6\u2CB8\u2CBA\u2CBC\u2CBE\u2CC0\u2CC2\u2CC4\u2CC6\u2CC8\u2CCA\u2CCC\u2CCE\u2CD0\u2CD2\u2CD4\u2CD6\u2CD8\u2CDA\u2CDC\u2CDE\u2CE0\u2CE2\u2CEB\u2CED\u2CF2\uA640\uA642\uA644\uA646\uA648\uA64A\uA64C\uA64E\uA650\uA652\uA654\uA656\uA658\uA65A\uA65C\uA65E\uA660\uA662\uA664\uA666\uA668\uA66A\uA66C\uA680\uA682\uA684\uA686\uA688\uA68A\uA68C\uA68E\uA690\uA692\uA694\uA696\uA698\uA69A\uA722\uA724\uA726\uA728\uA72A\uA72C\uA72E\uA732\uA734\uA736\uA738\uA73A\uA73C\uA73E\uA740\uA742\uA744\uA746\uA748\uA74A\uA74C\uA74E\uA750\uA752\uA754\uA756\uA758\uA75A\uA75C\uA75E\uA760\uA762\uA764\uA766\uA768\uA76A\uA76C\uA76E\uA779\uA77B\uA77D\uA77E\uA780\uA782\uA784\uA786\uA78B\uA78D\uA790\uA792\uA796\uA798\uA79A\uA79C\uA79E\uA7A0\uA7A2\uA7A4\uA7A6\uA7A8\uA7AA-\uA7AD\uA7B0-\uA7B4\uA7B6\uFF21-\uFF3A',
            astral: '\uD806[\uDCA0-\uDCBF]|\uD803[\uDC80-\uDCB2]|\uD835[\uDC00-\uDC19\uDC34-\uDC4D\uDC68-\uDC81\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB5\uDCD0-\uDCE9\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD38\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD6C-\uDD85\uDDA0-\uDDB9\uDDD4-\uDDED\uDE08-\uDE21\uDE3C-\uDE55\uDE70-\uDE89\uDEA8-\uDEC0\uDEE2-\uDEFA\uDF1C-\uDF34\uDF56-\uDF6E\uDF90-\uDFA8\uDFCA]|\uD801[\uDC00-\uDC27]|\uD83C[\uDD30-\uDD49\uDD50-\uDD69\uDD70-\uDD89]'
        },
        {
            name: 'White_Space',
            bmp: '\x09-\x0D\x20\x85\xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000'
        }
    ];

    // Add non-generated data
    unicodeData.push({
        name: 'Assigned',
        // Since this is defined as the inverse of Unicode category Cn (Unassigned), the Unicode
        // Categories addon is required to use this property
        inverseOf: 'Cn'
    });

    XRegExp.addUnicodeData(unicodeData);

}(XRegExp));

/*!
 * XRegExp Unicode Scripts 3.0.0
 * <http://xregexp.com/>
 * Steven Levithan (c) 2010-2015 MIT License
 * Unicode data provided by Mathias Bynens <http://mathiasbynens.be/>
 */

/**
 * Adds support for all Unicode scripts. E.g., `\p{Latin}`. Token names are case insensitive, and
 * any spaces, hyphens, and underscores are ignored.
 *
 * Uses Unicode 8.0.0.
 *
 * @requires XRegExp, Unicode Base
 */
(function(XRegExp) {
    'use strict';

    if (!XRegExp.addUnicodeData) {
        throw new ReferenceError('Unicode Base must be loaded before Unicode Scripts');
    }

    XRegExp.addUnicodeData([
        {
            name: 'Ahom',
            astral: '\uD805[\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF3F]'
        },
        {
            name: 'Anatolian_Hieroglyphs',
            astral: '\uD811[\uDC00-\uDE46]'
        },
        {
            name: 'Arabic',
            bmp: '\u0600-\u0604\u0606-\u060B\u060D-\u061A\u061E\u0620-\u063F\u0641-\u064A\u0656-\u066F\u0671-\u06DC\u06DE-\u06FF\u0750-\u077F\u08A0-\u08B4\u08E3-\u08FF\uFB50-\uFBC1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFD\uFE70-\uFE74\uFE76-\uFEFC',
            astral: '\uD803[\uDE60-\uDE7E]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB\uDEF0\uDEF1]'
        },
        {
            name: 'Armenian',
            bmp: '\u0531-\u0556\u0559-\u055F\u0561-\u0587\u058A\u058D-\u058F\uFB13-\uFB17'
        },
        {
            name: 'Avestan',
            astral: '\uD802[\uDF00-\uDF35\uDF39-\uDF3F]'
        },
        {
            name: 'Balinese',
            bmp: '\u1B00-\u1B4B\u1B50-\u1B7C'
        },
        {
            name: 'Bamum',
            bmp: '\uA6A0-\uA6F7',
            astral: '\uD81A[\uDC00-\uDE38]'
        },
        {
            name: 'Bassa_Vah',
            astral: '\uD81A[\uDED0-\uDEED\uDEF0-\uDEF5]'
        },
        {
            name: 'Batak',
            bmp: '\u1BC0-\u1BF3\u1BFC-\u1BFF'
        },
        {
            name: 'Bengali',
            bmp: '\u0980-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09FB'
        },
        {
            name: 'Bopomofo',
            bmp: '\u02EA\u02EB\u3105-\u312D\u31A0-\u31BA'
        },
        {
            name: 'Brahmi',
            astral: '\uD804[\uDC00-\uDC4D\uDC52-\uDC6F\uDC7F]'
        },
        {
            name: 'Braille',
            bmp: '\u2800-\u28FF'
        },
        {
            name: 'Buginese',
            bmp: '\u1A00-\u1A1B\u1A1E\u1A1F'
        },
        {
            name: 'Buhid',
            bmp: '\u1740-\u1753'
        },
        {
            name: 'Canadian_Aboriginal',
            bmp: '\u1400-\u167F\u18B0-\u18F5'
        },
        {
            name: 'Carian',
            astral: '\uD800[\uDEA0-\uDED0]'
        },
        {
            name: 'Caucasian_Albanian',
            astral: '\uD801[\uDD30-\uDD63\uDD6F]'
        },
        {
            name: 'Chakma',
            astral: '\uD804[\uDD00-\uDD34\uDD36-\uDD43]'
        },
        {
            name: 'Cham',
            bmp: '\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA5C-\uAA5F'
        },
        {
            name: 'Cherokee',
            bmp: '\u13A0-\u13F5\u13F8-\u13FD\uAB70-\uABBF'
        },
        {
            name: 'Common',
            bmp: '\0-\x40\\x5B-\x60\\x7B-\xA9\xAB-\xB9\xBB-\xBF\xD7\xF7\u02B9-\u02DF\u02E5-\u02E9\u02EC-\u02FF\u0374\u037E\u0385\u0387\u0589\u0605\u060C\u061B\u061C\u061F\u0640\u06DD\u0964\u0965\u0E3F\u0FD5-\u0FD8\u10FB\u16EB-\u16ED\u1735\u1736\u1802\u1803\u1805\u1CD3\u1CE1\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u2000-\u200B\u200E-\u2064\u2066-\u2070\u2074-\u207E\u2080-\u208E\u20A0-\u20BE\u2100-\u2125\u2127-\u2129\u212C-\u2131\u2133-\u214D\u214F-\u215F\u2189-\u218B\u2190-\u23FA\u2400-\u2426\u2440-\u244A\u2460-\u27FF\u2900-\u2B73\u2B76-\u2B95\u2B98-\u2BB9\u2BBD-\u2BC8\u2BCA-\u2BD1\u2BEC-\u2BEF\u2E00-\u2E42\u2FF0-\u2FFB\u3000-\u3004\u3006\u3008-\u3020\u3030-\u3037\u303C-\u303F\u309B\u309C\u30A0\u30FB\u30FC\u3190-\u319F\u31C0-\u31E3\u3220-\u325F\u327F-\u32CF\u3358-\u33FF\u4DC0-\u4DFF\uA700-\uA721\uA788-\uA78A\uA830-\uA839\uA92E\uA9CF\uAB5B\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE66\uFE68-\uFE6B\uFEFF\uFF01-\uFF20\uFF3B-\uFF40\uFF5B-\uFF65\uFF70\uFF9E\uFF9F\uFFE0-\uFFE6\uFFE8-\uFFEE\uFFF9-\uFFFD',
            astral: '\uD83E[\uDC00-\uDC0B\uDC10-\uDC47\uDC50-\uDC59\uDC60-\uDC87\uDC90-\uDCAD\uDD10-\uDD18\uDD80-\uDD84\uDDC0]|\uD82F[\uDCA0-\uDCA3]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDFCB\uDFCE-\uDFFF]|\uDB40[\uDC01\uDC20-\uDC7F]|\uD83D[\uDC00-\uDD79\uDD7B-\uDDA3\uDDA5-\uDED0\uDEE0-\uDEEC\uDEF0-\uDEF3\uDF00-\uDF73\uDF80-\uDFD4]|\uD800[\uDD00-\uDD02\uDD07-\uDD33\uDD37-\uDD3F\uDD90-\uDD9B\uDDD0-\uDDFC\uDEE1-\uDEFB]|\uD834[\uDC00-\uDCF5\uDD00-\uDD26\uDD29-\uDD66\uDD6A-\uDD7A\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDDE8\uDF00-\uDF56\uDF60-\uDF71]|\uD83C[\uDC00-\uDC2B\uDC30-\uDC93\uDCA0-\uDCAE\uDCB1-\uDCBF\uDCC1-\uDCCF\uDCD1-\uDCF5\uDD00-\uDD0C\uDD10-\uDD2E\uDD30-\uDD6B\uDD70-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE10-\uDE3A\uDE40-\uDE48\uDE50\uDE51\uDF00-\uDFFF]'
        },
        {
            name: 'Coptic',
            bmp: '\u03E2-\u03EF\u2C80-\u2CF3\u2CF9-\u2CFF'
        },
        {
            name: 'Cuneiform',
            astral: '\uD809[\uDC00-\uDC6E\uDC70-\uDC74\uDC80-\uDD43]|\uD808[\uDC00-\uDF99]'
        },
        {
            name: 'Cypriot',
            astral: '\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F]'
        },
        {
            name: 'Cyrillic',
            bmp: '\u0400-\u0484\u0487-\u052F\u1D2B\u1D78\u2DE0-\u2DFF\uA640-\uA69F\uFE2E\uFE2F'
        },
        {
            name: 'Deseret',
            astral: '\uD801[\uDC00-\uDC4F]'
        },
        {
            name: 'Devanagari',
            bmp: '\u0900-\u0950\u0953-\u0963\u0966-\u097F\uA8E0-\uA8FD'
        },
        {
            name: 'Duployan',
            astral: '\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9C-\uDC9F]'
        },
        {
            name: 'Egyptian_Hieroglyphs',
            astral: '\uD80C[\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]'
        },
        {
            name: 'Elbasan',
            astral: '\uD801[\uDD00-\uDD27]'
        },
        {
            name: 'Ethiopic',
            bmp: '\u1200-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u137C\u1380-\u1399\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E'
        },
        {
            name: 'Georgian',
            bmp: '\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u10FF\u2D00-\u2D25\u2D27\u2D2D'
        },
        {
            name: 'Glagolitic',
            bmp: '\u2C00-\u2C2E\u2C30-\u2C5E'
        },
        {
            name: 'Gothic',
            astral: '\uD800[\uDF30-\uDF4A]'
        },
        {
            name: 'Grantha',
            astral: '\uD804[\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]'
        },
        {
            name: 'Greek',
            bmp: '\u0370-\u0373\u0375-\u0377\u037A-\u037D\u037F\u0384\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03E1\u03F0-\u03FF\u1D26-\u1D2A\u1D5D-\u1D61\u1D66-\u1D6A\u1DBF\u1F00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FC4\u1FC6-\u1FD3\u1FD6-\u1FDB\u1FDD-\u1FEF\u1FF2-\u1FF4\u1FF6-\u1FFE\u2126\uAB65',
            astral: '\uD800[\uDD40-\uDD8C\uDDA0]|\uD834[\uDE00-\uDE45]'
        },
        {
            name: 'Gujarati',
            bmp: '\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AF1\u0AF9'
        },
        {
            name: 'Gurmukhi',
            bmp: '\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75'
        },
        {
            name: 'Han',
            bmp: '\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u3005\u3007\u3021-\u3029\u3038-\u303B\u3400-\u4DB5\u4E00-\u9FD5\uF900-\uFA6D\uFA70-\uFAD9',
            astral: '\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|[\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD87E[\uDC00-\uDE1D]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD873[\uDC00-\uDEA1]'
        },
        {
            name: 'Hangul',
            bmp: '\u1100-\u11FF\u302E\u302F\u3131-\u318E\u3200-\u321E\u3260-\u327E\uA960-\uA97C\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uFFA0-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC'
        },
        {
            name: 'Hanunoo',
            bmp: '\u1720-\u1734'
        },
        {
            name: 'Hatran',
            astral: '\uD802[\uDCE0-\uDCF2\uDCF4\uDCF5\uDCFB-\uDCFF]'
        },
        {
            name: 'Hebrew',
            bmp: '\u0591-\u05C7\u05D0-\u05EA\u05F0-\u05F4\uFB1D-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFB4F'
        },
        {
            name: 'Hiragana',
            bmp: '\u3041-\u3096\u309D-\u309F',
            astral: '\uD82C\uDC01|\uD83C\uDE00'
        },
        {
            name: 'Imperial_Aramaic',
            astral: '\uD802[\uDC40-\uDC55\uDC57-\uDC5F]'
        },
        {
            name: 'Inherited',
            bmp: '\u0300-\u036F\u0485\u0486\u064B-\u0655\u0670\u0951\u0952\u1AB0-\u1ABE\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFC-\u1DFF\u200C\u200D\u20D0-\u20F0\u302A-\u302D\u3099\u309A\uFE00-\uFE0F\uFE20-\uFE2D',
            astral: '\uD834[\uDD67-\uDD69\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD]|\uD800[\uDDFD\uDEE0]|\uDB40[\uDD00-\uDDEF]'
        },
        {
            name: 'Inscriptional_Pahlavi',
            astral: '\uD802[\uDF60-\uDF72\uDF78-\uDF7F]'
        },
        {
            name: 'Inscriptional_Parthian',
            astral: '\uD802[\uDF40-\uDF55\uDF58-\uDF5F]'
        },
        {
            name: 'Javanese',
            bmp: '\uA980-\uA9CD\uA9D0-\uA9D9\uA9DE\uA9DF'
        },
        {
            name: 'Kaithi',
            astral: '\uD804[\uDC80-\uDCC1]'
        },
        {
            name: 'Kannada',
            bmp: '\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2'
        },
        {
            name: 'Katakana',
            bmp: '\u30A1-\u30FA\u30FD-\u30FF\u31F0-\u31FF\u32D0-\u32FE\u3300-\u3357\uFF66-\uFF6F\uFF71-\uFF9D',
            astral: '\uD82C\uDC00'
        },
        {
            name: 'Kayah_Li',
            bmp: '\uA900-\uA92D\uA92F'
        },
        {
            name: 'Kharoshthi',
            astral: '\uD802[\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F-\uDE47\uDE50-\uDE58]'
        },
        {
            name: 'Khmer',
            bmp: '\u1780-\u17DD\u17E0-\u17E9\u17F0-\u17F9\u19E0-\u19FF'
        },
        {
            name: 'Khojki',
            astral: '\uD804[\uDE00-\uDE11\uDE13-\uDE3D]'
        },
        {
            name: 'Khudawadi',
            astral: '\uD804[\uDEB0-\uDEEA\uDEF0-\uDEF9]'
        },
        {
            name: 'Lao',
            bmp: '\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF'
        },
        {
            name: 'Latin',
            bmp: 'A-Za-z\xAA\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02B8\u02E0-\u02E4\u1D00-\u1D25\u1D2C-\u1D5C\u1D62-\u1D65\u1D6B-\u1D77\u1D79-\u1DBE\u1E00-\u1EFF\u2071\u207F\u2090-\u209C\u212A\u212B\u2132\u214E\u2160-\u2188\u2C60-\u2C7F\uA722-\uA787\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA7FF\uAB30-\uAB5A\uAB5C-\uAB64\uFB00-\uFB06\uFF21-\uFF3A\uFF41-\uFF5A'
        },
        {
            name: 'Lepcha',
            bmp: '\u1C00-\u1C37\u1C3B-\u1C49\u1C4D-\u1C4F'
        },
        {
            name: 'Limbu',
            bmp: '\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1940\u1944-\u194F'
        },
        {
            name: 'Linear_A',
            astral: '\uD801[\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]'
        },
        {
            name: 'Linear_B',
            astral: '\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA]'
        },
        {
            name: 'Lisu',
            bmp: '\uA4D0-\uA4FF'
        },
        {
            name: 'Lycian',
            astral: '\uD800[\uDE80-\uDE9C]'
        },
        {
            name: 'Lydian',
            astral: '\uD802[\uDD20-\uDD39\uDD3F]'
        },
        {
            name: 'Mahajani',
            astral: '\uD804[\uDD50-\uDD76]'
        },
        {
            name: 'Malayalam',
            bmp: '\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D5F-\u0D63\u0D66-\u0D75\u0D79-\u0D7F'
        },
        {
            name: 'Mandaic',
            bmp: '\u0840-\u085B\u085E'
        },
        {
            name: 'Manichaean',
            astral: '\uD802[\uDEC0-\uDEE6\uDEEB-\uDEF6]'
        },
        {
            name: 'Meetei_Mayek',
            bmp: '\uAAE0-\uAAF6\uABC0-\uABED\uABF0-\uABF9'
        },
        {
            name: 'Mende_Kikakui',
            astral: '\uD83A[\uDC00-\uDCC4\uDCC7-\uDCD6]'
        },
        {
            name: 'Meroitic_Cursive',
            astral: '\uD802[\uDDA0-\uDDB7\uDDBC-\uDDCF\uDDD2-\uDDFF]'
        },
        {
            name: 'Meroitic_Hieroglyphs',
            astral: '\uD802[\uDD80-\uDD9F]'
        },
        {
            name: 'Miao',
            astral: '\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]'
        },
        {
            name: 'Modi',
            astral: '\uD805[\uDE00-\uDE44\uDE50-\uDE59]'
        },
        {
            name: 'Mongolian',
            bmp: '\u1800\u1801\u1804\u1806-\u180E\u1810-\u1819\u1820-\u1877\u1880-\u18AA'
        },
        {
            name: 'Mro',
            astral: '\uD81A[\uDE40-\uDE5E\uDE60-\uDE69\uDE6E\uDE6F]'
        },
        {
            name: 'Multani',
            astral: '\uD804[\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA9]'
        },
        {
            name: 'Myanmar',
            bmp: '\u1000-\u109F\uA9E0-\uA9FE\uAA60-\uAA7F'
        },
        {
            name: 'Nabataean',
            astral: '\uD802[\uDC80-\uDC9E\uDCA7-\uDCAF]'
        },
        {
            name: 'New_Tai_Lue',
            bmp: '\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u19DE\u19DF'
        },
        {
            name: 'Nko',
            bmp: '\u07C0-\u07FA'
        },
        {
            name: 'Ogham',
            bmp: '\u1680-\u169C'
        },
        {
            name: 'Ol_Chiki',
            bmp: '\u1C50-\u1C7F'
        },
        {
            name: 'Old_Hungarian',
            astral: '\uD803[\uDC80-\uDCB2\uDCC0-\uDCF2\uDCFA-\uDCFF]'
        },
        {
            name: 'Old_Italic',
            astral: '\uD800[\uDF00-\uDF23]'
        },
        {
            name: 'Old_North_Arabian',
            astral: '\uD802[\uDE80-\uDE9F]'
        },
        {
            name: 'Old_Permic',
            astral: '\uD800[\uDF50-\uDF7A]'
        },
        {
            name: 'Old_Persian',
            astral: '\uD800[\uDFA0-\uDFC3\uDFC8-\uDFD5]'
        },
        {
            name: 'Old_South_Arabian',
            astral: '\uD802[\uDE60-\uDE7F]'
        },
        {
            name: 'Old_Turkic',
            astral: '\uD803[\uDC00-\uDC48]'
        },
        {
            name: 'Oriya',
            bmp: '\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B77'
        },
        {
            name: 'Osmanya',
            astral: '\uD801[\uDC80-\uDC9D\uDCA0-\uDCA9]'
        },
        {
            name: 'Pahawh_Hmong',
            astral: '\uD81A[\uDF00-\uDF45\uDF50-\uDF59\uDF5B-\uDF61\uDF63-\uDF77\uDF7D-\uDF8F]'
        },
        {
            name: 'Palmyrene',
            astral: '\uD802[\uDC60-\uDC7F]'
        },
        {
            name: 'Pau_Cin_Hau',
            astral: '\uD806[\uDEC0-\uDEF8]'
        },
        {
            name: 'Phags_Pa',
            bmp: '\uA840-\uA877'
        },
        {
            name: 'Phoenician',
            astral: '\uD802[\uDD00-\uDD1B\uDD1F]'
        },
        {
            name: 'Psalter_Pahlavi',
            astral: '\uD802[\uDF80-\uDF91\uDF99-\uDF9C\uDFA9-\uDFAF]'
        },
        {
            name: 'Rejang',
            bmp: '\uA930-\uA953\uA95F'
        },
        {
            name: 'Runic',
            bmp: '\u16A0-\u16EA\u16EE-\u16F8'
        },
        {
            name: 'Samaritan',
            bmp: '\u0800-\u082D\u0830-\u083E'
        },
        {
            name: 'Saurashtra',
            bmp: '\uA880-\uA8C4\uA8CE-\uA8D9'
        },
        {
            name: 'Sharada',
            astral: '\uD804[\uDD80-\uDDCD\uDDD0-\uDDDF]'
        },
        {
            name: 'Shavian',
            astral: '\uD801[\uDC50-\uDC7F]'
        },
        {
            name: 'Siddham',
            astral: '\uD805[\uDD80-\uDDB5\uDDB8-\uDDDD]'
        },
        {
            name: 'SignWriting',
            astral: '\uD836[\uDC00-\uDE8B\uDE9B-\uDE9F\uDEA1-\uDEAF]'
        },
        {
            name: 'Sinhala',
            bmp: '\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2-\u0DF4',
            astral: '\uD804[\uDDE1-\uDDF4]'
        },
        {
            name: 'Sora_Sompeng',
            astral: '\uD804[\uDCD0-\uDCE8\uDCF0-\uDCF9]'
        },
        {
            name: 'Sundanese',
            bmp: '\u1B80-\u1BBF\u1CC0-\u1CC7'
        },
        {
            name: 'Syloti_Nagri',
            bmp: '\uA800-\uA82B'
        },
        {
            name: 'Syriac',
            bmp: '\u0700-\u070D\u070F-\u074A\u074D-\u074F'
        },
        {
            name: 'Tagalog',
            bmp: '\u1700-\u170C\u170E-\u1714'
        },
        {
            name: 'Tagbanwa',
            bmp: '\u1760-\u176C\u176E-\u1770\u1772\u1773'
        },
        {
            name: 'Tai_Le',
            bmp: '\u1950-\u196D\u1970-\u1974'
        },
        {
            name: 'Tai_Tham',
            bmp: '\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA0-\u1AAD'
        },
        {
            name: 'Tai_Viet',
            bmp: '\uAA80-\uAAC2\uAADB-\uAADF'
        },
        {
            name: 'Takri',
            astral: '\uD805[\uDE80-\uDEB7\uDEC0-\uDEC9]'
        },
        {
            name: 'Tamil',
            bmp: '\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BFA'
        },
        {
            name: 'Telugu',
            bmp: '\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C78-\u0C7F'
        },
        {
            name: 'Thaana',
            bmp: '\u0780-\u07B1'
        },
        {
            name: 'Thai',
            bmp: '\u0E01-\u0E3A\u0E40-\u0E5B'
        },
        {
            name: 'Tibetan',
            bmp: '\u0F00-\u0F47\u0F49-\u0F6C\u0F71-\u0F97\u0F99-\u0FBC\u0FBE-\u0FCC\u0FCE-\u0FD4\u0FD9\u0FDA'
        },
        {
            name: 'Tifinagh',
            bmp: '\u2D30-\u2D67\u2D6F\u2D70\u2D7F'
        },
        {
            name: 'Tirhuta',
            astral: '\uD805[\uDC80-\uDCC7\uDCD0-\uDCD9]'
        },
        {
            name: 'Ugaritic',
            astral: '\uD800[\uDF80-\uDF9D\uDF9F]'
        },
        {
            name: 'Vai',
            bmp: '\uA500-\uA62B'
        },
        {
            name: 'Warang_Citi',
            astral: '\uD806[\uDCA0-\uDCF2\uDCFF]'
        },
        {
            name: 'Yi',
            bmp: '\uA000-\uA48C\uA490-\uA4C6'
        }
    ]);

}(XRegExp));

return XRegExp;

}));


},{}],370:[function(require,module,exports){
// import "babel-polyfill";
//
// import {XRegExp} from "xregexp";
// import PubSub from "pubsub-js";
// import React from "react";
// import ReactDOM from "react-dom";
// import CSSTransition from "react-addons-css-transition-group";
// import * as ReactRouter from "react-router";
// import {createHashHistory} from "history";

// import "lib-source/v2/gesture";
"use strict";

var _inherits = require("babel-runtime/helpers/inherits")["default"];

var _classCallCheck = require("babel-runtime/helpers/class-call-check")["default"];

var _regeneratorRuntime = require("babel-runtime/regenerator")["default"];

var _Array$from = require("babel-runtime/core-js/array/from")["default"];

var _interopRequireDefault = require("babel-runtime/helpers/interop-require-default")["default"];

var _this3 = this;

var _libSourceV2Chrono = require("lib-source/v2/chrono");

var _libSourceV2Chrono2 = _interopRequireDefault(_libSourceV2Chrono);

var _libSourceV2Ajax = require("lib-source/v2/ajax");

var _libSourceV2Ajax2 = _interopRequireDefault(_libSourceV2Ajax);

var _libSourceUiv2Icon = require('lib-source/uiv2/icon');

var _libSourceUiv2Icon2 = _interopRequireDefault(_libSourceUiv2Icon);

var _libSourceUiv2Ripple = require('lib-source/uiv2/ripple');

var _libSourceUiv2Ripple2 = _interopRequireDefault(_libSourceUiv2Ripple);

var _libSourceUiv2Button = require('lib-source/uiv2/button');

var _libSourceUiv2Button2 = _interopRequireDefault(_libSourceUiv2Button);

var _libSourceUiv2Iconbutton = require('lib-source/uiv2/iconbutton');

var _libSourceUiv2Iconbutton2 = _interopRequireDefault(_libSourceUiv2Iconbutton);

var _libSourceUiv2Card = require('lib-source/uiv2/Card');

var _libSourceUiv2Card2 = _interopRequireDefault(_libSourceUiv2Card);

var _libSourceUiv2Image = require('lib-source/uiv2/Image');

var _libSourceUiv2Image2 = _interopRequireDefault(_libSourceUiv2Image);

var _libSourceUiv2CenterContent = require('lib-source/uiv2/CenterContent');

var _libSourceUiv2CenterContent2 = _interopRequireDefault(_libSourceUiv2CenterContent);

var _libSourceUiv2Checkbox = require('lib-source/uiv2/Checkbox');

var _libSourceUiv2Checkbox2 = _interopRequireDefault(_libSourceUiv2Checkbox);

var _libSourceUiv2Toggle = require('lib-source/uiv2/Toggle');

var _libSourceUiv2Toggle2 = _interopRequireDefault(_libSourceUiv2Toggle);

var _libSourceUiv2Touchable = require('lib-source/uiv2/Touchable');

var _libSourceUiv2Touchable2 = _interopRequireDefault(_libSourceUiv2Touchable);

var _libSourceUiv2Combobox = require('lib-source/uiv2/Combobox');

var _libSourceUiv2Combobox2 = _interopRequireDefault(_libSourceUiv2Combobox);

var _libSourceUiv2Option = require('lib-source/uiv2/Option');

var _libSourceUiv2Option2 = _interopRequireDefault(_libSourceUiv2Option);

var _libSourceUiv2Spinner = require('lib-source/uiv2/Spinner');

var _libSourceUiv2Spinner2 = _interopRequireDefault(_libSourceUiv2Spinner);

var _libSourceUiv2Radio = require('lib-source/uiv2/Radio');

var _libSourceUiv2Radio2 = _interopRequireDefault(_libSourceUiv2Radio);

var _libSourceUiv2Calendar = require('lib-source/uiv2/Calendar');

var _libSourceUiv2Calendar2 = _interopRequireDefault(_libSourceUiv2Calendar);

var _libSourceUiv2Input = require('lib-source/uiv2/Input');

var _libSourceUiv2Input2 = _interopRequireDefault(_libSourceUiv2Input);

var _libSourceUiv2LayoutFlexbox = require('lib-source/uiv2/layout/Flexbox');

var _libSourceUiv2LayoutFlexbox2 = _interopRequireDefault(_libSourceUiv2LayoutFlexbox);

var _libSourceUiv2LayoutGrid = require('lib-source/uiv2/layout/Grid');

var _libSourceUiv2LayoutGrid2 = _interopRequireDefault(_libSourceUiv2LayoutGrid);

var _libSourceUiv2LayoutPinboard = require('lib-source/uiv2/layout/Pinboard');

var _libSourceUiv2LayoutPinboard2 = _interopRequireDefault(_libSourceUiv2LayoutPinboard);

var _libSourceUiv2Form = require('lib-source/uiv2/Form');

var _libSourceUiv2Form2 = _interopRequireDefault(_libSourceUiv2Form);

var _libSourceUiv2Dialog = require("lib-source/uiv2/dialog");

var _libSourceUiv2Dialog2 = _interopRequireDefault(_libSourceUiv2Dialog);

var _libSourceV2Style = require("lib-source/v2/style");

var _libSourceV2Utils = require("lib-source/v2/utils");

var _libSourceV2Shared = require("lib-source/v2/shared");

var _libSourceV2Crypto = require('lib-source/v2/crypto');

var _libSourceV2Crypto2 = _interopRequireDefault(_libSourceV2Crypto);

var _libSourceV2Zip = require('lib-source/v2/zip');

var _libSourceV2Zip2 = _interopRequireDefault(_libSourceV2Zip);

var _libSourceDataUriRobotoLightWoffSource = require("lib-source/data-uri/roboto-light.woff.source");

var _libSourceDataUriRobotoLightWoffSource2 = _interopRequireDefault(_libSourceDataUriRobotoLightWoffSource);

var _libSourceDataUriIoniconsWoffSource = require("lib-source/data-uri/ionicons.woff.source");

var _libSourceDataUriIoniconsWoffSource2 = _interopRequireDefault(_libSourceDataUriIoniconsWoffSource);

window.chrono = _libSourceV2Chrono2["default"];

var range = _regeneratorRuntime.mark(function range(args) {
    var _args$start, start, _args$end, end, _args$count, count, _args$step, step, _args$map, map;

    return _regeneratorRuntime.wrap(function range$(context$1$0) {
        while (1) switch (context$1$0.prev = context$1$0.next) {
            case 0:
                _args$start = args.start;
                start = _args$start === undefined ? 0 : _args$start;
                _args$end = args.end;
                end = _args$end === undefined ? null : _args$end;
                _args$count = args.count;
                count = _args$count === undefined ? null : _args$count;
                _args$step = args.step;
                step = _args$step === undefined ? 1 : _args$step;
                _args$map = args.map;
                map = _args$map === undefined ? function (i) {
                    return i;
                } : _args$map;

                if (!(end === null)) {
                    context$1$0.next = 14;
                    break;
                }

                if (!(count === null)) {
                    context$1$0.next = 13;
                    break;
                }

                throw new Error("Must give the size of the range");

            case 13:
                end = start + count;

            case 14:
                if (!true) {
                    context$1$0.next = 22;
                    break;
                }

                if (!(start >= end)) {
                    context$1$0.next = 17;
                    break;
                }

                return context$1$0.abrupt("break", 22);

            case 17:
                context$1$0.next = 19;
                return map(start);

            case 19:
                start += step;
                context$1$0.next = 14;
                break;

            case 22:
            case "end":
                return context$1$0.stop();
        }
    }, range, this);
});

window.frange = _regeneratorRuntime.mark(function callee$0$0(count) {
    var map = arguments.length <= 1 || arguments[1] === undefined ? function (i) {
        return i;
    } : arguments[1];
    var current;
    return _regeneratorRuntime.wrap(function callee$0$0$(context$1$0) {
        while (1) switch (context$1$0.prev = context$1$0.next) {
            case 0:
                current = 0;

            case 1:
                if (!true) {
                    context$1$0.next = 9;
                    break;
                }

                if (!(current === count)) {
                    context$1$0.next = 4;
                    break;
                }

                return context$1$0.abrupt("break", 9);

            case 4:
                context$1$0.next = 6;
                return map(current);

            case 6:
                current += 1;
                context$1$0.next = 1;
                break;

            case 9:
            case "end":
                return context$1$0.stop();
        }
    }, callee$0$0, this);
});
window.arange = function (count, map) {
    return _Array$from(frange(count, map));
};

var _ReactRouter = ReactRouter;
var Route = _ReactRouter.Route;

var coolBlue = "#2FB1DF";

Theme.define({
    app: {
        backgroundColor: 'white',
        textColor: '#747474'
    },
    button: {
        hoverColor: 'rgba(0, 0, 0, 0.11)',
        activeColor: 'rgba(0, 0, 0, 0.2)',
        raised: {
            color: coolBlue,
            textColor: 'white'
        }
    },
    card: {
        backgroundColor: 'white'
    },
    progressbar: {
        backgroundColor: '#B3CEED',
        color: '#3B8AF3'
    },
    radio: {
        grid: {
            selectedColor: coolBlue
        }
    },
    rangeInput: {
        track: {
            color: coolBlue
        }
    },
    "switch": {
        track: {
            color: coolBlue
        }
    },
    title: {
        backgroundColor: coolBlue,
        textColor: 'white'
    },
    userInput: {
        activeColor: '#2FB1DF',
        textColor: 'black'
    }
});

var ScreenTransition = React.createClass({
    displayName: "ScreenTransition",

    render: function render() {
        return React.createElement(
            "div",
            { style: { position: 'absolute', width: '100%', height: '100%' } },
            this.props.children
        );
    }
});

Style.__rawCSS("test", {
    selector: ".test-enter",
    rules: {
        'transition': 'left 250ms ease-out',
        left: '100%'
    }
}, {
    selector: ".test-enter.test-enter-active",
    rules: {
        left: 0
    }
}, {
    selector: ".test-leave",
    rules: {
        'transition': 'left 250ms ease-out',
        left: 0
    }
}, {
    selector: ".test-leave.test-leave-active",
    rules: {
        left: '-100%'
    }
}, {
    selector: ".test-appear",
    rules: {
        'transition': 'top 250ms ease-out',
        top: '100%'
    }
}, {
    selector: ".test-appear.test-appear-active",
    rules: {
        top: 0
    }
});

var Wrapper = React.createClass({
    displayName: "Wrapper",

    render: function render() {
        return React.createElement(
            CSSTransition,
            { component: "div", transitionName: "test", transitionEnterTimeout: 250, transitionLeaveTimeout: 250 },
            React.createElement(
                ScreenTransition,
                { key: Date.now() },
                this.props.children
            )
        );
    }
});

// window.benchmark = (iterations, first, second) => {
//     const r = [];
//     for (const testNum of range({count: 30})) {
//         let a = performance.now();
//         for (let i = 0; i < iterations; i += 1) {
//             first(i);
//         }
//         a = performance.now() - a;
//
//         let b = performance.now();
//         for (let i = 0; i < iterations; i += 1) {
//             second(i);
//         }
//         b = performance.now() - b;
//         r.push([a.toFixed(3), b.toFixed(3)]);
//     }
//     return r;
// };
//
// const checkProp = (obj, prop, value) => obj.hasOwnProperty(prop) === true && obj[prop] === value;
// const x = {a: 10, b: 12};
//
// const res = benchmark(1e6, (i) => (i % 2 === 0) ? i >> 1 : 0, (i) => (i % 2 === 0) ? i / 2 : 0);
// console.log(res.map(i => i.join('\t')).join('\n'));

/*
const url = "http://vignette1.wikia.nocookie.net/bayonetta/images/e/e3/Cereza_Bayonetta_2_render.png/revision/latest?cb=20140615210025";
*/
var url = "http://assets1.ignimgs.com/thumbs/userUploaded/2014/10/12/Bayonetta2_1280-1413142451100.jpg";

/*
defineStyleForComponent(
    Button,
    'special',
    {
    }
);
...
<Button.Special />
*/

_libSourceV2Style.defineStyleForComponent(_libSourceUiv2Checkbox2["default"], 'awesome', {
    normal: {
        iconColor: 'cyan'
    },
    checked: {
        iconColor: 'blue'
    }
});
_libSourceV2Style.defineStyleForComponent(_libSourceUiv2Toggle2["default"], 'awesome', {
    on: {
        thumbColor: 'blue',
        trackColor: 'cyan'
    }
});

_libSourceV2Style.defineComponentStyle('app', 'core', {
    "$html": {
        width: '100%',
        height: '100%',
        overflow: 'hidden'
    },
    "$body": {
        fontFamily: "Roboto",
        padding: 0,
        margin: 0,
        width: '100%'
    }
});
_libSourceV2Style.defineComponentStyle('roboto', 'font', { "$@font-face": _libSourceV2Style.genFontCSS("Roboto", _libSourceDataUriRobotoLightWoffSource2["default"]) });
_libSourceV2Style.defineComponentStyle('ionic', 'font', { "$@font-face": _libSourceV2Style.genFontCSS("Ionic", _libSourceDataUriIoniconsWoffSource2["default"]) });

var Screen = (function (_React$Component) {
    _inherits(Screen, _React$Component);

    function Screen(props) {
        var _this = this;

        _classCallCheck(this, Screen);

        _React$Component.call(this, props);

        this.render = function () {
            return React.createElement(
                "div",
                null,
                _this.props.children
            );
        };
    }

    return Screen;
})(React.Component);

var Main = React.createClass({
    displayName: "Main",

    demo: function demo() {
        return _regeneratorRuntime.async(function demo$(context$1$0) {
            while (1) switch (context$1$0.prev = context$1$0.next) {
                case 0:
                    context$1$0.next = 2;
                    return _regeneratorRuntime.awrap(Dialog.confirm("Really?"));

                case 2:
                    context$1$0.t0 = context$1$0.sent;

                    if (!(context$1$0.t0 === true)) {
                        context$1$0.next = 5;
                        break;
                    }

                    console.log("Nope!");

                case 5:
                case "end":
                    return context$1$0.stop();
            }
        }, null, this);
    },
    getInitialState: function getInitialState() {
        return {
            checked: false,
            on: false,
            disabled: false,
            button: {
                image: false
            },
            index: -1,
            text: "",
            password: "",
            value: null,
            date: _libSourceV2Chrono2["default"](),
            rangeValue: 100
        };
    },
    render: function render() {
        var _this2 = this;

        var disabled = this.state.disabled;

        var textHandler = function textHandler(text, value) {
            // console.log('value', value);
            _this2.setState({ text: text, value: value });
        };

        return React.createElement(
            Screen,
            { title: "Test", backText: "test", width: 600, onBack: this.demo },
            React.createElement(
                _libSourceUiv2Form2["default"],
                { label: "Form" },
                React.createElement(
                    _libSourceUiv2Radio2["default"],
                    { title: "Test" },
                    _Array$from(range({
                        count: 10,
                        map: function map(n) {
                            return React.createElement(
                                _libSourceUiv2Option2["default"],
                                { value: Math.pow(n, n) },
                                n
                            );
                        }
                    })),
                    React.createElement(
                        _libSourceUiv2Option2["default"],
                        null,
                        React.createElement(_libSourceUiv2Image2["default"], { source: url, height: 30 })
                    )
                )
            ),
            React.createElement(_libSourceUiv2Dialog2["default"], null)
        );
    }
});

// App.start(
//     <Route component={Wrapper}>
//         <Route path="/" component={Main} />
//         <Route path="/test" component={Main} />
//     </Route>
// );
window.qsel = function () {
    return document.querySelector.apply(document, arguments);
};
_libSourceV2Style.__setup();
(function callee$0$0() {
    return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
        while (1) switch (context$1$0.prev = context$1$0.next) {
            case 0:
                context$1$0.next = 2;
                return _regeneratorRuntime.awrap(deviceReady);

            case 2:
                ReactDOM.render(React.createElement(Main, null), qsel("#app-container"));

            case 3:
            case "end":
                return context$1$0.stop();
        }
    }, null, _this3);
})();

// const token = ajax.cancelToken();
// (async () => {
//     console.log(await ajax("http://axel669.net/echo/index2.php", {post: [1, 2, 3, 4], token}));
// })();
// chrono.trigger(2000, token.cancel);

// const isPow2 = n => (n & -n) === n;
// window.collatz = n => (n % 2 === 0) ? n / 2 : 3 * n + 1;
// window.check = start => {
//     while (true) {
//         if (start === 1) {
//             break;
//         }
//         console.log(start);
//         start = collatz(start);
//     }
// };
//
// const f = n => (n & -n);
// for (const i of frange(100)) {
//     console.log(i, f(i));
// }
/*<Image source={url} height={150} color="cyan" />*/ /*<Toggle.Awesome on={this.state.on} onChange={on => this.setState({on})} label={"Test"} subTitle="more text?" />*/ /*<Button text={<span>{disabled ? <Spinner size={20} /> : null}Button Text</span>} disabled={disabled} onTap={() => this.setState({disabled: true})} />*/ /*<Icon name="ion-calendar" size={20} />*/ /*<Radio selectedIndex={this.state.index} onChange={index => this.setState({index})} title="Test">
                                                                                                                                                                                                                                                                                                                                                                                 {Array.from(range({
                                                                                                                                                                                                                                                                                                                                                                                     count: 10,
                                                                                                                                                                                                                                                                                                                                                                                     map: n => <Option value={n ** n}>{n}</Option>
                                                                                                                                                                                                                                                                                                                                                                                 }))}
                                                                                                                                                                                                                                                                                                                                                                                 <Option><Image source={url} height={30} /></Option>
                                                                                                                                                                                                                                                                                                                                                                              </Radio>*/ /*<Button text="Test" />*/ /*<div style={{width: '75%', maxWidth: 480}}>
                                                                                                                                                                                                                                                                                                                                                                                                                       <Calendar selectedDate={new Date()} />
                                                                                                                                                                                                                                                                                                                                                                                                                    </div>*/ /*<Input.Date onChange={date => this.setState({date})} date={this.state.date} label="My Birthday?" iconName="ion-calendar" format={"Expiration Date: {month}/{day}/{year}"} />*/ /*<Button text="Wat" onTap={() => dialog.show({content: <Calendar selectedDate={new Date()} onDateSelected={cblog} />, title: "Select Date", buttons: [{text: "Cancel"}]})} />*/ /*<input type="datetime" />*/ /*<input type="time" onChange={evt => cblog(evt.target.value)} ref="test" />*/ /*<TimeInput />*/ /*<Card>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 <RangeInput value={this.state.rangeValue} max={255} onChange={rangeValue => this.setState({rangeValue})} />
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 <input type="range" value={this.state.rangeValue} max={255} onChange={evt => this.setState({rangeValue: evt.target.value})} />
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              </Card>*/ /*<Input.URL label="URL" value={this.state.text} onChange={(text, valid) => {console.log(text, valid); this.setState({text});}} />
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <Input.Email label="Email" value={this.state.text} onChange={(text, valid) => {console.log(text, valid); this.setState({text});}} />
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <Input.Password label="Password" value={this.state.password} onChange={password => this.setState({password})} />
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <Input.Range value={this.state.rangeValue} max={255} onChange={rangeValue => this.setState({rangeValue})} />
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <FileInput text="Test" onChange={files => console.log(files)} multiple />*/ /*<TimeSelector value={this.state.date} onChange={date => this.setState({date})} />*/ /*<Input.Time value={this.state.date} onChange={date => this.setState({date})} />
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          <Input.Date value={this.state.date} onChange={date => this.setState({date})} />*/ /*<Input.File onChange={cblog} text="Select File" />*/ /*<Flexbox colCount={3} padEnd maxItemWidth={100} align="space-around">
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      {arange(11, n => <Button text={n} block flush />)}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   </Flexbox>*/ /*<Grid colCount={3} rowCount={4}>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   {arange(11, n => <Button text={n} flush fill />)}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                </Grid>*/ /*<Pinboard height={200}>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             {arange(12,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 n => {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     const angle = (n / 6) * Math.PI;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     const x = Math.cos(angle) * 70 + 145;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     const y = Math.sin(angle) * 70 + 85;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     const pos = {top: y, left: x, width: 30, height: 30};
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       return <div pinInfo={pos} style={{width: '100%', height: '100%', backgroundColor: 'cyan'}}>{n}</div>;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             )}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          </Pinboard>*/ /*<Input.Search iconName="ion-search" placeholder="Search Stuffs" />*/ /*<Checkbox.Awesome checked={this.state.checked} onChange={checked => this.setState({checked})} label={"Test"} subTitle="more text?" />*/ /*<Button text="Normal" />
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         <Button text="Disabled" disabled />
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         <Button.Cancel text="Cancel" />
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         <Button.Confirm text="Confirm" />
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         <Input.Range value={this.state.rangeValue} max={255} onChange={rangeValue => this.setState({rangeValue})} />*/ /*<Radio layout={Pinboard} layout-height={200}>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           {arange(12,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               n => {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   const angle = (n / 6) * Math.PI;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   const x = Math.cos(angle) * 70 + 145;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   const y = Math.sin(angle) * 70 + 85;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   const pos = {top: y, left: x, width: 30, height: 30};
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     return <div pinInfo={pos} style={{width: '100%', height: '100%'}}>{n}</div>;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           )}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </Radio>*/ /*<Input.Text formName="Text" placeholder="Text" />
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   <Input.Password formName="Password" placeholder="Password" />
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   <Input.Search formName="Search" placeholder="Search" />
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   <Input.URL formName="URL" placeholder="URL" />
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   <Input.Email formName="Email" placeholder="Email" />
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <Input.Date formName="date" />
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   <Input.Time formName="time" />
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   <Input.File formName="file" multiple valueFormat={list => `Files Selected: ${list.length}`} />
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   <Input.Range formName="range" min={0} max={255} />*/ /*<div style={{position: 'absolute', bottom: 0, height: 50, width: 50, backgroundColor: 'cyan'}} />*/ /*<Input.File*/ /*<Card>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 <Pinboard height={50}>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     <Icon name="ion-happy" size={40} pinInfo={{top: 0, left: 10, width: 40, height: 50}} />
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     <div pinInfo={{top: 0, left: 55}}>User Name Thing?</div>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     <div pinInfo={{top: 30, left: 55, fontSize: 11}}>User information about positiond and stuff</div>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     <div pinInfo={{top: 5, left: 5, width: 10, height: 10, backgroundColor: 'cyan'}} />
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 </Pinboard>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              </Card>*/

},{"babel-runtime/core-js/array/from":45,"babel-runtime/helpers/class-call-check":57,"babel-runtime/helpers/inherits":59,"babel-runtime/helpers/interop-require-default":60,"babel-runtime/regenerator":148,"lib-source/data-uri/ionicons.woff.source":6,"lib-source/data-uri/roboto-light.woff.source":8,"lib-source/uiv2/Calendar":10,"lib-source/uiv2/Card":11,"lib-source/uiv2/CenterContent":12,"lib-source/uiv2/Checkbox":13,"lib-source/uiv2/Combobox":14,"lib-source/uiv2/Form":15,"lib-source/uiv2/Image":17,"lib-source/uiv2/Input":18,"lib-source/uiv2/Option":19,"lib-source/uiv2/Radio":20,"lib-source/uiv2/Spinner":21,"lib-source/uiv2/Toggle":23,"lib-source/uiv2/Touchable":24,"lib-source/uiv2/button":25,"lib-source/uiv2/dialog":26,"lib-source/uiv2/icon":27,"lib-source/uiv2/iconbutton":28,"lib-source/uiv2/layout/Flexbox":33,"lib-source/uiv2/layout/Grid":34,"lib-source/uiv2/layout/Pinboard":35,"lib-source/uiv2/ripple":36,"lib-source/v2/ajax":38,"lib-source/v2/chrono":39,"lib-source/v2/crypto":40,"lib-source/v2/shared":41,"lib-source/v2/style":42,"lib-source/v2/utils":43,"lib-source/v2/zip":44}]},{},[370])
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJleHRlcm5hbC9kZWZsYXRlLmpzLnNvdXJjZSIsImV4dGVybmFsL2luZmxhdGUuanMuc291cmNlIiwiZXh0ZXJuYWwvei13b3JrZXIuanMuc291cmNlIiwiZXh0ZXJuYWwvemlwLWV4dC5qcyIsImV4dGVybmFsL3ppcC5qcyIsImxpYi1zb3VyY2UvZGF0YS11cmkvaW9uaWNvbnMud29mZi5zb3VyY2UiLCJsaWItc291cmNlL2RhdGEtdXJpL2xvYWQtc3Bpbm5lci5naWYuc291cmNlIiwibGliLXNvdXJjZS9kYXRhLXVyaS9yb2JvdG8tbGlnaHQud29mZi5zb3VyY2UiLCJDOi9Vc2Vycy9BeGVsMS9Eb2N1bWVudHMvcHJvZ3JhbW1pbmcvZ2l0aHViL0NvcmludGhpYW4vbGliLXNvdXJjZS91aXYyL0J1dHRvbi5qcyIsIkM6L1VzZXJzL0F4ZWwxL0RvY3VtZW50cy9wcm9ncmFtbWluZy9naXRodWIvQ29yaW50aGlhbi9saWItc291cmNlL3VpdjIvQ2FsZW5kYXIuanMiLCJDOi9Vc2Vycy9BeGVsMS9Eb2N1bWVudHMvcHJvZ3JhbW1pbmcvZ2l0aHViL0NvcmludGhpYW4vbGliLXNvdXJjZS91aXYyL0NhcmQuanMiLCJDOi9Vc2Vycy9BeGVsMS9Eb2N1bWVudHMvcHJvZ3JhbW1pbmcvZ2l0aHViL0NvcmludGhpYW4vbGliLXNvdXJjZS91aXYyL0NlbnRlckNvbnRlbnQuanMiLCJDOi9Vc2Vycy9BeGVsMS9Eb2N1bWVudHMvcHJvZ3JhbW1pbmcvZ2l0aHViL0NvcmludGhpYW4vbGliLXNvdXJjZS91aXYyL0NoZWNrYm94LmpzIiwiQzovVXNlcnMvQXhlbDEvRG9jdW1lbnRzL3Byb2dyYW1taW5nL2dpdGh1Yi9Db3JpbnRoaWFuL2xpYi1zb3VyY2UvdWl2Mi9Db21ib2JveC5qcyIsIkM6L1VzZXJzL0F4ZWwxL0RvY3VtZW50cy9wcm9ncmFtbWluZy9naXRodWIvQ29yaW50aGlhbi9saWItc291cmNlL3VpdjIvRm9ybS5qcyIsIkM6L1VzZXJzL0F4ZWwxL0RvY3VtZW50cy9wcm9ncmFtbWluZy9naXRodWIvQ29yaW50aGlhbi9saWItc291cmNlL3VpdjIvSWNvbi5qcyIsIkM6L1VzZXJzL0F4ZWwxL0RvY3VtZW50cy9wcm9ncmFtbWluZy9naXRodWIvQ29yaW50aGlhbi9saWItc291cmNlL3VpdjIvSW1hZ2UuanMiLCJDOi9Vc2Vycy9BeGVsMS9Eb2N1bWVudHMvcHJvZ3JhbW1pbmcvZ2l0aHViL0NvcmludGhpYW4vbGliLXNvdXJjZS91aXYyL0lucHV0LmpzIiwiQzovVXNlcnMvQXhlbDEvRG9jdW1lbnRzL3Byb2dyYW1taW5nL2dpdGh1Yi9Db3JpbnRoaWFuL2xpYi1zb3VyY2UvdWl2Mi9PcHRpb24uanMiLCJDOi9Vc2Vycy9BeGVsMS9Eb2N1bWVudHMvcHJvZ3JhbW1pbmcvZ2l0aHViL0NvcmludGhpYW4vbGliLXNvdXJjZS91aXYyL1JhZGlvLmpzIiwiQzovVXNlcnMvQXhlbDEvRG9jdW1lbnRzL3Byb2dyYW1taW5nL2dpdGh1Yi9Db3JpbnRoaWFuL2xpYi1zb3VyY2UvdWl2Mi9TcGlubmVyLmpzIiwiQzovVXNlcnMvQXhlbDEvRG9jdW1lbnRzL3Byb2dyYW1taW5nL2dpdGh1Yi9Db3JpbnRoaWFuL2xpYi1zb3VyY2UvdWl2Mi9UaW1lU2VsZWN0b3IuanMiLCJDOi9Vc2Vycy9BeGVsMS9Eb2N1bWVudHMvcHJvZ3JhbW1pbmcvZ2l0aHViL0NvcmludGhpYW4vbGliLXNvdXJjZS91aXYyL1RvZ2dsZS5qcyIsIkM6L1VzZXJzL0F4ZWwxL0RvY3VtZW50cy9wcm9ncmFtbWluZy9naXRodWIvQ29yaW50aGlhbi9saWItc291cmNlL3VpdjIvVG91Y2hhYmxlLmpzIiwiQzovVXNlcnMvQXhlbDEvRG9jdW1lbnRzL3Byb2dyYW1taW5nL2dpdGh1Yi9Db3JpbnRoaWFuL2xpYi1zb3VyY2UvdWl2Mi9idXR0b24uanMiLCJDOi9Vc2Vycy9BeGVsMS9Eb2N1bWVudHMvcHJvZ3JhbW1pbmcvZ2l0aHViL0NvcmludGhpYW4vbGliLXNvdXJjZS91aXYyL2RpYWxvZy5qcyIsIkM6L1VzZXJzL0F4ZWwxL0RvY3VtZW50cy9wcm9ncmFtbWluZy9naXRodWIvQ29yaW50aGlhbi9saWItc291cmNlL3VpdjIvaWNvbi5qcyIsIkM6L1VzZXJzL0F4ZWwxL0RvY3VtZW50cy9wcm9ncmFtbWluZy9naXRodWIvQ29yaW50aGlhbi9saWItc291cmNlL3VpdjIvaWNvbmJ1dHRvbi5qcyIsIkM6L1VzZXJzL0F4ZWwxL0RvY3VtZW50cy9wcm9ncmFtbWluZy9naXRodWIvQ29yaW50aGlhbi9saWItc291cmNlL3VpdjIvaW5wdXQvRGF0ZUlucHV0LmpzIiwiQzovVXNlcnMvQXhlbDEvRG9jdW1lbnRzL3Byb2dyYW1taW5nL2dpdGh1Yi9Db3JpbnRoaWFuL2xpYi1zb3VyY2UvdWl2Mi9pbnB1dC9GaWxlSW5wdXQuanMiLCJDOi9Vc2Vycy9BeGVsMS9Eb2N1bWVudHMvcHJvZ3JhbW1pbmcvZ2l0aHViL0NvcmludGhpYW4vbGliLXNvdXJjZS91aXYyL2lucHV0L1JhbmdlSW5wdXQuanMiLCJDOi9Vc2Vycy9BeGVsMS9Eb2N1bWVudHMvcHJvZ3JhbW1pbmcvZ2l0aHViL0NvcmludGhpYW4vbGliLXNvdXJjZS91aXYyL2lucHV0L1RpbWVJbnB1dC5qcyIsIkM6L1VzZXJzL0F4ZWwxL0RvY3VtZW50cy9wcm9ncmFtbWluZy9naXRodWIvQ29yaW50aGlhbi9saWItc291cmNlL3VpdjIvbGF5b3V0L0ZsZXhib3guanMiLCJDOi9Vc2Vycy9BeGVsMS9Eb2N1bWVudHMvcHJvZ3JhbW1pbmcvZ2l0aHViL0NvcmludGhpYW4vbGliLXNvdXJjZS91aXYyL2xheW91dC9HcmlkLmpzIiwiQzovVXNlcnMvQXhlbDEvRG9jdW1lbnRzL3Byb2dyYW1taW5nL2dpdGh1Yi9Db3JpbnRoaWFuL2xpYi1zb3VyY2UvdWl2Mi9sYXlvdXQvUGluYm9hcmQuanMiLCJDOi9Vc2Vycy9BeGVsMS9Eb2N1bWVudHMvcHJvZ3JhbW1pbmcvZ2l0aHViL0NvcmludGhpYW4vbGliLXNvdXJjZS91aXYyL3JpcHBsZS5qcyIsIkM6L1VzZXJzL0F4ZWwxL0RvY3VtZW50cy9wcm9ncmFtbWluZy9naXRodWIvQ29yaW50aGlhbi9saWItc291cmNlL3VpdjIvdmFycy5qcyIsIkM6L1VzZXJzL0F4ZWwxL0RvY3VtZW50cy9wcm9ncmFtbWluZy9naXRodWIvQ29yaW50aGlhbi9saWItc291cmNlL3YyL2FqYXguanMiLCJDOi9Vc2Vycy9BeGVsMS9Eb2N1bWVudHMvcHJvZ3JhbW1pbmcvZ2l0aHViL0NvcmludGhpYW4vbGliLXNvdXJjZS92Mi9jaHJvbm8uanMiLCJDOi9Vc2Vycy9BeGVsMS9Eb2N1bWVudHMvcHJvZ3JhbW1pbmcvZ2l0aHViL0NvcmludGhpYW4vbGliLXNvdXJjZS92Mi9jcnlwdG8uanMiLCJDOi9Vc2Vycy9BeGVsMS9Eb2N1bWVudHMvcHJvZ3JhbW1pbmcvZ2l0aHViL0NvcmludGhpYW4vbGliLXNvdXJjZS92Mi9zaGFyZWQuanMiLCJDOi9Vc2Vycy9BeGVsMS9Eb2N1bWVudHMvcHJvZ3JhbW1pbmcvZ2l0aHViL0NvcmludGhpYW4vbGliLXNvdXJjZS92Mi9zdHlsZS5qcyIsIkM6L1VzZXJzL0F4ZWwxL0RvY3VtZW50cy9wcm9ncmFtbWluZy9naXRodWIvQ29yaW50aGlhbi9saWItc291cmNlL3YyL3V0aWxzLmpzIiwiQzovVXNlcnMvQXhlbDEvRG9jdW1lbnRzL3Byb2dyYW1taW5nL2dpdGh1Yi9Db3JpbnRoaWFuL2xpYi1zb3VyY2UvdjIvemlwLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9hcnJheS9mcm9tLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9nZXQtaXRlcmF0b3IuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9hc3NpZ24uanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9jcmVhdGUuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9kZWZpbmUtcHJvcGVydGllcy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2VudHJpZXMuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9mcmVlemUuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvcHJvbWlzZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvc2V0LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9zeW1ib2wuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL2NsYXNzLWNhbGwtY2hlY2suanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL2V4dGVuZHMuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL2luaGVyaXRzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvaGVscGVycy9pbnRlcm9wLXJlcXVpcmUtZGVmYXVsdC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvb2JqZWN0LXdpdGhvdXQtcHJvcGVydGllcy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vYXJyYXkvZnJvbS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vZ2V0LWl0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvYXNzaWduLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvY3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZGVmaW5lLXByb3BlcnRpZXMuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9lbnRyaWVzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZnJlZXplLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3Qva2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L3NldC1wcm90b3R5cGUtb2YuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL3Byb21pc2UuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL3NldC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vc3ltYm9sL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuYS1mdW5jdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmFkZC10by11bnNjb3BhYmxlcy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmFuLW9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmNsYXNzb2YuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5jb2YuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5jb2xsZWN0aW9uLXN0cm9uZy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmNvbGxlY3Rpb24tdG8tanNvbi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmNvbGxlY3Rpb24uanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5jb3JlLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuY3R4LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuZGVmaW5lZC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmRlc2NyaXB0b3JzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuZG9tLWNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmVudW0ta2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmV4cG9ydC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmZhaWxzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuZm9yLW9mLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuZ2V0LW5hbWVzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuZ2xvYmFsLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuaGFzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuaGlkZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmh0bWwuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5pbnZva2UuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5pb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuaXMtYXJyYXktaXRlci5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmlzLWFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuaXMtb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuaXRlci1jYWxsLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuaXRlci1jcmVhdGUuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5pdGVyLWRlZmluZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLml0ZXItZGV0ZWN0LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuaXRlci1zdGVwLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuaXRlcmF0b3JzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5rZXlvZi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmxpYnJhcnkuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5taWNyb3Rhc2suanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5vYmplY3QtYXNzaWduLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQub2JqZWN0LXNhcC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLm9iamVjdC10by1hcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLnByb3BlcnR5LWRlc2MuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5yZWRlZmluZS1hbGwuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5yZWRlZmluZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLnNhbWUtdmFsdWUuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5zZXQtcHJvdG8uanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5zZXQtc3BlY2llcy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLnNldC10by1zdHJpbmctdGFnLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuc2hhcmVkLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuc3BlY2llcy1jb25zdHJ1Y3Rvci5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLnN0cmljdC1uZXcuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5zdHJpbmctYXQuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC50YXNrLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQudG8taW50ZWdlci5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLnRvLWlvYmplY3QuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC50by1sZW5ndGguanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC50by1vYmplY3QuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC51aWQuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC53a3MuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2NvcmUuZ2V0LWl0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5hcnJheS5mcm9tLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5hcnJheS5pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmZyZWV6ZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmtleXMuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5zZXQtcHJvdG90eXBlLW9mLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5wcm9taXNlLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5zZXQuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuc3ltYm9sLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5vYmplY3QuZW50cmllcy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcuc2V0LnRvLWpzb24uanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL3JlZ2VuZXJhdG9yL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvcmVnZW5lcmF0b3IvcnVudGltZS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnVmZmVyL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvbGliL2I2NC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvbm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnVmZmVyL25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWNpcGhlci9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWNpcGhlci9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1hZXMvYWVzLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWNpcGhlci9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1hZXMvYXV0aENpcGhlci5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1jaXBoZXIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktYWVzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktY2lwaGVyL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWFlcy9kZWNyeXB0ZXIuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktY2lwaGVyL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWFlcy9lbmNyeXB0ZXIuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktY2lwaGVyL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWFlcy9naGFzaC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1jaXBoZXIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktYWVzL21vZGVzLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWNpcGhlci9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1hZXMvbW9kZXMvY2JjLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWNpcGhlci9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1hZXMvbW9kZXMvY2ZiLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWNpcGhlci9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1hZXMvbW9kZXMvY2ZiMS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1jaXBoZXIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktYWVzL21vZGVzL2NmYjguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktY2lwaGVyL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWFlcy9tb2Rlcy9jdHIuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktY2lwaGVyL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWFlcy9tb2Rlcy9lY2IuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktY2lwaGVyL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWFlcy9tb2Rlcy9vZmIuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktY2lwaGVyL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWFlcy9ub2RlX21vZHVsZXMvYnVmZmVyLXhvci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1jaXBoZXIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktYWVzL25vZGVfbW9kdWxlcy9jaXBoZXItYmFzZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1jaXBoZXIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktYWVzL3N0cmVhbUNpcGhlci5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1jaXBoZXIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktZGVzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWNpcGhlci9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1kZXMvbW9kZXMuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktY2lwaGVyL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWRlcy9ub2RlX21vZHVsZXMvY2lwaGVyLWJhc2UvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktY2lwaGVyL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWRlcy9ub2RlX21vZHVsZXMvZGVzLmpzL2xpYi9kZXMuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktY2lwaGVyL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWRlcy9ub2RlX21vZHVsZXMvZGVzLmpzL2xpYi9kZXMvY2JjLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWNpcGhlci9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1kZXMvbm9kZV9tb2R1bGVzL2Rlcy5qcy9saWIvZGVzL2NpcGhlci5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1jaXBoZXIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktZGVzL25vZGVfbW9kdWxlcy9kZXMuanMvbGliL2Rlcy9kZXMuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktY2lwaGVyL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWRlcy9ub2RlX21vZHVsZXMvZGVzLmpzL2xpYi9kZXMvZWRlLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWNpcGhlci9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1kZXMvbm9kZV9tb2R1bGVzL2Rlcy5qcy9saWIvZGVzL3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWNpcGhlci9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1kZXMvbm9kZV9tb2R1bGVzL2Rlcy5qcy9ub2RlX21vZHVsZXMvbWluaW1hbGlzdGljLWFzc2VydC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1jaXBoZXIvbm9kZV9tb2R1bGVzL2V2cF9ieXRlc3Rva2V5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vYWxnb3MuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktc2lnbi9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vY3VydmVzLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vbm9kZV9tb2R1bGVzL2JuLmpzL2xpYi9ibi5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXJzYS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL25vZGVfbW9kdWxlcy9lbGxpcHRpYy9saWIvZWxsaXB0aWMuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktc2lnbi9ub2RlX21vZHVsZXMvZWxsaXB0aWMvbGliL2VsbGlwdGljL2N1cnZlL2Jhc2UuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktc2lnbi9ub2RlX21vZHVsZXMvZWxsaXB0aWMvbGliL2VsbGlwdGljL2N1cnZlL2Vkd2FyZHMuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktc2lnbi9ub2RlX21vZHVsZXMvZWxsaXB0aWMvbGliL2VsbGlwdGljL2N1cnZlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vbm9kZV9tb2R1bGVzL2VsbGlwdGljL2xpYi9lbGxpcHRpYy9jdXJ2ZS9tb250LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vbm9kZV9tb2R1bGVzL2VsbGlwdGljL2xpYi9lbGxpcHRpYy9jdXJ2ZS9zaG9ydC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL25vZGVfbW9kdWxlcy9lbGxpcHRpYy9saWIvZWxsaXB0aWMvY3VydmVzLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vbm9kZV9tb2R1bGVzL2VsbGlwdGljL2xpYi9lbGxpcHRpYy9lYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL25vZGVfbW9kdWxlcy9lbGxpcHRpYy9saWIvZWxsaXB0aWMvZWMva2V5LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vbm9kZV9tb2R1bGVzL2VsbGlwdGljL2xpYi9lbGxpcHRpYy9lYy9zaWduYXR1cmUuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktc2lnbi9ub2RlX21vZHVsZXMvZWxsaXB0aWMvbGliL2VsbGlwdGljL2VkZHNhL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vbm9kZV9tb2R1bGVzL2VsbGlwdGljL2xpYi9lbGxpcHRpYy9lZGRzYS9rZXkuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktc2lnbi9ub2RlX21vZHVsZXMvZWxsaXB0aWMvbGliL2VsbGlwdGljL2VkZHNhL3NpZ25hdHVyZS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL25vZGVfbW9kdWxlcy9lbGxpcHRpYy9saWIvZWxsaXB0aWMvaG1hYy1kcmJnLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vbm9kZV9tb2R1bGVzL2VsbGlwdGljL2xpYi9lbGxpcHRpYy9wcmVjb21wdXRlZC9zZWNwMjU2azEuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktc2lnbi9ub2RlX21vZHVsZXMvZWxsaXB0aWMvbGliL2VsbGlwdGljL3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vbm9kZV9tb2R1bGVzL2VsbGlwdGljL25vZGVfbW9kdWxlcy9icm9yYW5kL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vbm9kZV9tb2R1bGVzL2VsbGlwdGljL25vZGVfbW9kdWxlcy9oYXNoLmpzL2xpYi9oYXNoLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vbm9kZV9tb2R1bGVzL2VsbGlwdGljL25vZGVfbW9kdWxlcy9oYXNoLmpzL2xpYi9oYXNoL2NvbW1vbi5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL25vZGVfbW9kdWxlcy9lbGxpcHRpYy9ub2RlX21vZHVsZXMvaGFzaC5qcy9saWIvaGFzaC9obWFjLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vbm9kZV9tb2R1bGVzL2VsbGlwdGljL25vZGVfbW9kdWxlcy9oYXNoLmpzL2xpYi9oYXNoL3JpcGVtZC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL25vZGVfbW9kdWxlcy9lbGxpcHRpYy9ub2RlX21vZHVsZXMvaGFzaC5qcy9saWIvaGFzaC9zaGEuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktc2lnbi9ub2RlX21vZHVsZXMvZWxsaXB0aWMvbm9kZV9tb2R1bGVzL2hhc2guanMvbGliL2hhc2gvdXRpbHMuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktc2lnbi9ub2RlX21vZHVsZXMvZWxsaXB0aWMvcGFja2FnZS5qc29uIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vbm9kZV9tb2R1bGVzL3BhcnNlLWFzbjEvYWVzaWQuanNvbiIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL25vZGVfbW9kdWxlcy9wYXJzZS1hc24xL2FzbjEuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktc2lnbi9ub2RlX21vZHVsZXMvcGFyc2UtYXNuMS9maXhQcm9jLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vbm9kZV9tb2R1bGVzL3BhcnNlLWFzbjEvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktc2lnbi9ub2RlX21vZHVsZXMvcGFyc2UtYXNuMS9ub2RlX21vZHVsZXMvYXNuMS5qcy9saWIvYXNuMS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL25vZGVfbW9kdWxlcy9wYXJzZS1hc24xL25vZGVfbW9kdWxlcy9hc24xLmpzL2xpYi9hc24xL2FwaS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL25vZGVfbW9kdWxlcy9wYXJzZS1hc24xL25vZGVfbW9kdWxlcy9hc24xLmpzL2xpYi9hc24xL2Jhc2UvYnVmZmVyLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vbm9kZV9tb2R1bGVzL3BhcnNlLWFzbjEvbm9kZV9tb2R1bGVzL2FzbjEuanMvbGliL2FzbjEvYmFzZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL25vZGVfbW9kdWxlcy9wYXJzZS1hc24xL25vZGVfbW9kdWxlcy9hc24xLmpzL2xpYi9hc24xL2Jhc2Uvbm9kZS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL25vZGVfbW9kdWxlcy9wYXJzZS1hc24xL25vZGVfbW9kdWxlcy9hc24xLmpzL2xpYi9hc24xL2Jhc2UvcmVwb3J0ZXIuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktc2lnbi9ub2RlX21vZHVsZXMvcGFyc2UtYXNuMS9ub2RlX21vZHVsZXMvYXNuMS5qcy9saWIvYXNuMS9jb25zdGFudHMvZGVyLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vbm9kZV9tb2R1bGVzL3BhcnNlLWFzbjEvbm9kZV9tb2R1bGVzL2FzbjEuanMvbGliL2FzbjEvY29uc3RhbnRzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vbm9kZV9tb2R1bGVzL3BhcnNlLWFzbjEvbm9kZV9tb2R1bGVzL2FzbjEuanMvbGliL2FzbjEvZGVjb2RlcnMvZGVyLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vbm9kZV9tb2R1bGVzL3BhcnNlLWFzbjEvbm9kZV9tb2R1bGVzL2FzbjEuanMvbGliL2FzbjEvZGVjb2RlcnMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktc2lnbi9ub2RlX21vZHVsZXMvcGFyc2UtYXNuMS9ub2RlX21vZHVsZXMvYXNuMS5qcy9saWIvYXNuMS9kZWNvZGVycy9wZW0uanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktc2lnbi9ub2RlX21vZHVsZXMvcGFyc2UtYXNuMS9ub2RlX21vZHVsZXMvYXNuMS5qcy9saWIvYXNuMS9lbmNvZGVycy9kZXIuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktc2lnbi9ub2RlX21vZHVsZXMvcGFyc2UtYXNuMS9ub2RlX21vZHVsZXMvYXNuMS5qcy9saWIvYXNuMS9lbmNvZGVycy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL25vZGVfbW9kdWxlcy9wYXJzZS1hc24xL25vZGVfbW9kdWxlcy9hc24xLmpzL2xpYi9hc24xL2VuY29kZXJzL3BlbS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL25vZGVfbW9kdWxlcy9wYXJzZS1hc24xL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWFlcy9hZXMuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktc2lnbi9ub2RlX21vZHVsZXMvcGFyc2UtYXNuMS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1hZXMvYXV0aENpcGhlci5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL25vZGVfbW9kdWxlcy9wYXJzZS1hc24xL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWFlcy9kZWNyeXB0ZXIuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktc2lnbi9ub2RlX21vZHVsZXMvcGFyc2UtYXNuMS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1hZXMvZW5jcnlwdGVyLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vbm9kZV9tb2R1bGVzL3BhcnNlLWFzbjEvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktYWVzL2doYXNoLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vbm9kZV9tb2R1bGVzL3BhcnNlLWFzbjEvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktYWVzL21vZGVzL2NmYi5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL25vZGVfbW9kdWxlcy9wYXJzZS1hc24xL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWFlcy9tb2Rlcy9jZmIxLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vbm9kZV9tb2R1bGVzL3BhcnNlLWFzbjEvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktYWVzL21vZGVzL2NmYjguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktc2lnbi9ub2RlX21vZHVsZXMvcGFyc2UtYXNuMS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1hZXMvbW9kZXMvY3RyLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vbm9kZV9tb2R1bGVzL3BhcnNlLWFzbjEvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktYWVzL21vZGVzL29mYi5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL25vZGVfbW9kdWxlcy9wYXJzZS1hc24xL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWFlcy9ub2RlX21vZHVsZXMvYnVmZmVyLXhvci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL25vZGVfbW9kdWxlcy9wYXJzZS1hc24xL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWFlcy9ub2RlX21vZHVsZXMvY2lwaGVyLWJhc2UvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktc2lnbi9ub2RlX21vZHVsZXMvcGFyc2UtYXNuMS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1hZXMvc3RyZWFtQ2lwaGVyLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vbm9kZV9tb2R1bGVzL3BhcnNlLWFzbjEvbm9kZV9tb2R1bGVzL2V2cF9ieXRlc3Rva2V5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL3ZlcmlmeS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3JlYXRlLWVjZGgvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3JlYXRlLWhhc2gvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3JlYXRlLWhhc2gvaGVscGVycy5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3JlYXRlLWhhc2gvbWQ1LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcmVhdGUtaGFzaC9ub2RlX21vZHVsZXMvY2lwaGVyLWJhc2UvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyZWF0ZS1oYXNoL25vZGVfbW9kdWxlcy9yaXBlbWQxNjAvbGliL3JpcGVtZDE2MC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3JlYXRlLWhhc2gvbm9kZV9tb2R1bGVzL3NoYS5qcy9oYXNoLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcmVhdGUtaGFzaC9ub2RlX21vZHVsZXMvc2hhLmpzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcmVhdGUtaGFzaC9ub2RlX21vZHVsZXMvc2hhLmpzL3NoYS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3JlYXRlLWhhc2gvbm9kZV9tb2R1bGVzL3NoYS5qcy9zaGExLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcmVhdGUtaGFzaC9ub2RlX21vZHVsZXMvc2hhLmpzL3NoYTIyNC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3JlYXRlLWhhc2gvbm9kZV9tb2R1bGVzL3NoYS5qcy9zaGEyNTYuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyZWF0ZS1oYXNoL25vZGVfbW9kdWxlcy9zaGEuanMvc2hhMzg0LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcmVhdGUtaGFzaC9ub2RlX21vZHVsZXMvc2hhLmpzL3NoYTUxMi5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3JlYXRlLWhtYWMvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvZGlmZmllLWhlbGxtYW4vYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvZGlmZmllLWhlbGxtYW4vbGliL2RoLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9kaWZmaWUtaGVsbG1hbi9saWIvZ2VuZXJhdGVQcmltZS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvZGlmZmllLWhlbGxtYW4vbGliL3ByaW1lcy5qc29uIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9kaWZmaWUtaGVsbG1hbi9ub2RlX21vZHVsZXMvbWlsbGVyLXJhYmluL2xpYi9tci5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcGJrZGYyL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3B1YmxpYy1lbmNyeXB0L2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3B1YmxpYy1lbmNyeXB0L21nZi5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHVibGljLWVuY3J5cHQvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktcnNhL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wdWJsaWMtZW5jcnlwdC9ub2RlX21vZHVsZXMvcGFyc2UtYXNuMS9maXhQcm9jLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wdWJsaWMtZW5jcnlwdC9ub2RlX21vZHVsZXMvcGFyc2UtYXNuMS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHVibGljLWVuY3J5cHQvbm9kZV9tb2R1bGVzL3BhcnNlLWFzbjEvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktYWVzL2Flcy5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHVibGljLWVuY3J5cHQvbm9kZV9tb2R1bGVzL3BhcnNlLWFzbjEvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktYWVzL2F1dGhDaXBoZXIuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3B1YmxpYy1lbmNyeXB0L25vZGVfbW9kdWxlcy9wYXJzZS1hc24xL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWFlcy9kZWNyeXB0ZXIuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3B1YmxpYy1lbmNyeXB0L25vZGVfbW9kdWxlcy9wYXJzZS1hc24xL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWFlcy9lbmNyeXB0ZXIuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3B1YmxpYy1lbmNyeXB0L25vZGVfbW9kdWxlcy9wYXJzZS1hc24xL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWFlcy9naGFzaC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHVibGljLWVuY3J5cHQvbm9kZV9tb2R1bGVzL3BhcnNlLWFzbjEvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktYWVzL21vZGVzL2NmYi5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHVibGljLWVuY3J5cHQvbm9kZV9tb2R1bGVzL3BhcnNlLWFzbjEvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktYWVzL21vZGVzL2NmYjEuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3B1YmxpYy1lbmNyeXB0L25vZGVfbW9kdWxlcy9wYXJzZS1hc24xL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWFlcy9tb2Rlcy9jZmI4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wdWJsaWMtZW5jcnlwdC9ub2RlX21vZHVsZXMvcGFyc2UtYXNuMS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1hZXMvbW9kZXMvY3RyLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wdWJsaWMtZW5jcnlwdC9ub2RlX21vZHVsZXMvcGFyc2UtYXNuMS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1hZXMvbW9kZXMvb2ZiLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wdWJsaWMtZW5jcnlwdC9ub2RlX21vZHVsZXMvcGFyc2UtYXNuMS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1hZXMvbm9kZV9tb2R1bGVzL2J1ZmZlci14b3IvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3B1YmxpYy1lbmNyeXB0L25vZGVfbW9kdWxlcy9wYXJzZS1hc24xL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWFlcy9ub2RlX21vZHVsZXMvY2lwaGVyLWJhc2UvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3B1YmxpYy1lbmNyeXB0L25vZGVfbW9kdWxlcy9wYXJzZS1hc24xL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWFlcy9zdHJlYW1DaXBoZXIuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3B1YmxpYy1lbmNyeXB0L25vZGVfbW9kdWxlcy9wYXJzZS1hc24xL25vZGVfbW9kdWxlcy9ldnBfYnl0ZXN0b2tleS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHVibGljLWVuY3J5cHQvcHJpdmF0ZURlY3J5cHQuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3B1YmxpYy1lbmNyeXB0L3B1YmxpY0VuY3J5cHQuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3B1YmxpYy1lbmNyeXB0L3dpdGhQdWJsaWMuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3B1YmxpYy1lbmNyeXB0L3hvci5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmFuZG9tYnl0ZXMvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvaW5zZXJ0LW1vZHVsZS1nbG9iYWxzL25vZGVfbW9kdWxlcy9pcy1idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvaXNhcnJheS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2R1cGxleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fZHVwbGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcmVhZGFibGUuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fd3JpdGFibGUuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL25vZGVfbW9kdWxlcy9jb3JlLXV0aWwtaXMvbGliL3V0aWwuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL25vZGVfbW9kdWxlcy9wcm9jZXNzLW5leHRpY2stYXJncy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbm9kZV9tb2R1bGVzL3V0aWwtZGVwcmVjYXRlL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9yZWFkYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vdHJhbnNmb3JtLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS93cml0YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9zdHJlYW0tYnJvd3NlcmlmeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9zdHJpbmdfZGVjb2Rlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy92bS1icm93c2VyaWZ5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3ZtLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2luZGV4b2YvaW5kZXguanMiLCJub2RlX21vZHVsZXMveHJlZ2V4cC94cmVnZXhwLWFsbC5qcyIsIkM6L1VzZXJzL0F4ZWwxL0RvY3VtZW50cy9wcm9ncmFtbWluZy9naXRodWIvQ29yaW50aGlhbi90ZXN0LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTs7QUNEQTtBQUNBOztBQ0RBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3Y4QkE7QUFDQTs7QUNEQTtBQUNBOztBQ0RBO0FBQ0E7Ozs7Ozs7O2tDQ0Q4RSx3QkFBd0I7O3FDQUNuRiwyQkFBMkI7Ozs7bUNBQzdC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Q0FBOztBQ0FBOztBQ0FBOztBQ0FBOztBQ0FBOztBQ0FBOztBQ0FBOztBQ0FBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTs7QUNEQTtBQUNBOztBQ0RBO0FBQ0E7O0FDREE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTs7QUNGQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7O0FDRkE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaFNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBOzs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3RvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDeGdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2pMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDakdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN4SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN6SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzFGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMxRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaFFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3ZHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2p4SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdFpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMzRCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNXdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0tBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDckhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNyR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbG1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3VEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNqTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ2pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3hJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQ2xHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDMUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3pMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3ZHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMxSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMzSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDMUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2xOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNwR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDaEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzdJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMxUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNwS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNqSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDaEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3JHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNqTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ2pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3hJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQ2xHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDMUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzNHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzlGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0ZBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQy84QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNqaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMzR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbkVBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTs7QUNEQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2lDQzMzSW1CLHNCQUFzQjs7OzsrQkFDeEIsb0JBQW9COzs7O2lDQUVwQixzQkFBc0I7Ozs7bUNBQ3BCLHdCQUF3Qjs7Oztt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Q1gsb0JBQUMsSUFBSSxPQUFHLEVBQ1IsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQ3pCLENBQUM7Ozs7Ozs7RUFDTCxFQUFHLENBQUMiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwibW9kdWxlLmV4cG9ydHMgPSBcIi8qXFxyXFxuIENvcHlyaWdodCAoYykgMjAxMyBHaWxkYXMgTG9ybWVhdS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cXHJcXG5cXHJcXG4gUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XFxyXFxuIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxcclxcblxcclxcbiAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXFxyXFxuIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXFxyXFxuXFxyXFxuIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XFxyXFxuIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpblxcclxcbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cXHJcXG5cXHJcXG4gMy4gVGhlIG5hbWVzIG9mIHRoZSBhdXRob3JzIG1heSBub3QgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHNcXHJcXG4gZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXFxyXFxuXFxyXFxuIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgYGBBUyBJUycnIEFORCBBTlkgRVhQUkVTU0VEIE9SIElNUExJRUQgV0FSUkFOVElFUyxcXHJcXG4gSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORFxcclxcbiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgSkNSQUZULFxcclxcbiBJTkMuIE9SIEFOWSBDT05UUklCVVRPUlMgVE8gVEhJUyBTT0ZUV0FSRSBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULFxcclxcbiBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UXFxyXFxuIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLFxcclxcbiBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GXFxyXFxuIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HXFxyXFxuIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSxcXHJcXG4gRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cXHJcXG4gKi9cXHJcXG5cXHJcXG4vKlxcclxcbiAqIFRoaXMgcHJvZ3JhbSBpcyBiYXNlZCBvbiBKWmxpYiAxLjAuMiB5bW5rLCBKQ3JhZnQsSW5jLlxcclxcbiAqIEpabGliIGlzIGJhc2VkIG9uIHpsaWItMS4xLjMsIHNvIGFsbCBjcmVkaXQgc2hvdWxkIGdvIGF1dGhvcnNcXHJcXG4gKiBKZWFuLWxvdXAgR2FpbGx5KGpsb3VwQGd6aXAub3JnKSBhbmQgTWFyayBBZGxlcihtYWRsZXJAYWx1bW5pLmNhbHRlY2guZWR1KVxcclxcbiAqIGFuZCBjb250cmlidXRvcnMgb2YgemxpYi5cXHJcXG4gKi9cXHJcXG5cXHJcXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XFxyXFxuICAgIFxcXCJ1c2Ugc3RyaWN0XFxcIjtcXHJcXG5cXHJcXG4gICAgLy8gR2xvYmFsXFxyXFxuXFxyXFxuICAgIHZhciBNQVhfQklUUyA9IDE1O1xcclxcbiAgICB2YXIgRF9DT0RFUyA9IDMwO1xcclxcbiAgICB2YXIgQkxfQ09ERVMgPSAxOTtcXHJcXG5cXHJcXG4gICAgdmFyIExFTkdUSF9DT0RFUyA9IDI5O1xcclxcbiAgICB2YXIgTElURVJBTFMgPSAyNTY7XFxyXFxuICAgIHZhciBMX0NPREVTID0gKExJVEVSQUxTICsgMSArIExFTkdUSF9DT0RFUyk7XFxyXFxuICAgIHZhciBIRUFQX1NJWkUgPSAoMiAqIExfQ09ERVMgKyAxKTtcXHJcXG5cXHJcXG4gICAgdmFyIEVORF9CTE9DSyA9IDI1NjtcXHJcXG5cXHJcXG4gICAgLy8gQml0IGxlbmd0aCBjb2RlcyBtdXN0IG5vdCBleGNlZWQgTUFYX0JMX0JJVFMgYml0c1xcclxcbiAgICB2YXIgTUFYX0JMX0JJVFMgPSA3O1xcclxcblxcclxcbiAgICAvLyByZXBlYXQgcHJldmlvdXMgYml0IGxlbmd0aCAzLTYgdGltZXMgKDIgYml0cyBvZiByZXBlYXQgY291bnQpXFxyXFxuICAgIHZhciBSRVBfM182ID0gMTY7XFxyXFxuXFxyXFxuICAgIC8vIHJlcGVhdCBhIHplcm8gbGVuZ3RoIDMtMTAgdGltZXMgKDMgYml0cyBvZiByZXBlYXQgY291bnQpXFxyXFxuICAgIHZhciBSRVBaXzNfMTAgPSAxNztcXHJcXG5cXHJcXG4gICAgLy8gcmVwZWF0IGEgemVybyBsZW5ndGggMTEtMTM4IHRpbWVzICg3IGJpdHMgb2YgcmVwZWF0IGNvdW50KVxcclxcbiAgICB2YXIgUkVQWl8xMV8xMzggPSAxODtcXHJcXG5cXHJcXG4gICAgLy8gVGhlIGxlbmd0aHMgb2YgdGhlIGJpdCBsZW5ndGggY29kZXMgYXJlIHNlbnQgaW4gb3JkZXIgb2YgZGVjcmVhc2luZ1xcclxcbiAgICAvLyBwcm9iYWJpbGl0eSwgdG8gYXZvaWQgdHJhbnNtaXR0aW5nIHRoZSBsZW5ndGhzIGZvciB1bnVzZWQgYml0XFxyXFxuICAgIC8vIGxlbmd0aCBjb2Rlcy5cXHJcXG5cXHJcXG4gICAgdmFyIEJ1Zl9zaXplID0gOCAqIDI7XFxyXFxuXFxyXFxuICAgIC8vIEpabGliIHZlcnNpb24gOiBcXFwiMS4wLjJcXFwiXFxyXFxuICAgIHZhciBaX0RFRkFVTFRfQ09NUFJFU1NJT04gPSAtMTtcXHJcXG5cXHJcXG4gICAgLy8gY29tcHJlc3Npb24gc3RyYXRlZ3lcXHJcXG4gICAgdmFyIFpfRklMVEVSRUQgPSAxO1xcclxcbiAgICB2YXIgWl9IVUZGTUFOX09OTFkgPSAyO1xcclxcbiAgICB2YXIgWl9ERUZBVUxUX1NUUkFURUdZID0gMDtcXHJcXG5cXHJcXG4gICAgdmFyIFpfTk9fRkxVU0ggPSAwO1xcclxcbiAgICB2YXIgWl9QQVJUSUFMX0ZMVVNIID0gMTtcXHJcXG4gICAgdmFyIFpfRlVMTF9GTFVTSCA9IDM7XFxyXFxuICAgIHZhciBaX0ZJTklTSCA9IDQ7XFxyXFxuXFxyXFxuICAgIHZhciBaX09LID0gMDtcXHJcXG4gICAgdmFyIFpfU1RSRUFNX0VORCA9IDE7XFxyXFxuICAgIHZhciBaX05FRURfRElDVCA9IDI7XFxyXFxuICAgIHZhciBaX1NUUkVBTV9FUlJPUiA9IC0yO1xcclxcbiAgICB2YXIgWl9EQVRBX0VSUk9SID0gLTM7XFxyXFxuICAgIHZhciBaX0JVRl9FUlJPUiA9IC01O1xcclxcblxcclxcbiAgICAvLyBUcmVlXFxyXFxuXFxyXFxuICAgIC8vIHNlZSBkZWZpbml0aW9uIG9mIGFycmF5IGRpc3RfY29kZSBiZWxvd1xcclxcbiAgICB2YXIgX2Rpc3RfY29kZSA9IFsgMCwgMSwgMiwgMywgNCwgNCwgNSwgNSwgNiwgNiwgNiwgNiwgNywgNywgNywgNywgOCwgOCwgOCwgOCwgOCwgOCwgOCwgOCwgOSwgOSwgOSwgOSwgOSwgOSwgOSwgOSwgMTAsIDEwLCAxMCwgMTAsIDEwLCAxMCwgMTAsIDEwLCAxMCwgMTAsXFxyXFxuICAgICAgICAgICAgMTAsIDEwLCAxMCwgMTAsIDEwLCAxMCwgMTEsIDExLCAxMSwgMTEsIDExLCAxMSwgMTEsIDExLCAxMSwgMTEsIDExLCAxMSwgMTEsIDExLCAxMSwgMTEsIDEyLCAxMiwgMTIsIDEyLCAxMiwgMTIsIDEyLCAxMiwgMTIsIDEyLCAxMiwgMTIsIDEyLCAxMiwgMTIsXFxyXFxuICAgICAgICAgICAgMTIsIDEyLCAxMiwgMTIsIDEyLCAxMiwgMTIsIDEyLCAxMiwgMTIsIDEyLCAxMiwgMTIsIDEyLCAxMiwgMTIsIDEyLCAxMywgMTMsIDEzLCAxMywgMTMsIDEzLCAxMywgMTMsIDEzLCAxMywgMTMsIDEzLCAxMywgMTMsIDEzLCAxMywgMTMsIDEzLCAxMywgMTMsXFxyXFxuICAgICAgICAgICAgMTMsIDEzLCAxMywgMTMsIDEzLCAxMywgMTMsIDEzLCAxMywgMTMsIDEzLCAxMywgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsXFxyXFxuICAgICAgICAgICAgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsXFxyXFxuICAgICAgICAgICAgMTQsIDE0LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsXFxyXFxuICAgICAgICAgICAgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAwLCAwLCAxNiwgMTcsIDE4LCAxOCwgMTksIDE5LFxcclxcbiAgICAgICAgICAgIDIwLCAyMCwgMjAsIDIwLCAyMSwgMjEsIDIxLCAyMSwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LFxcclxcbiAgICAgICAgICAgIDI0LCAyNCwgMjQsIDI1LCAyNSwgMjUsIDI1LCAyNSwgMjUsIDI1LCAyNSwgMjUsIDI1LCAyNSwgMjUsIDI1LCAyNSwgMjUsIDI1LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LFxcclxcbiAgICAgICAgICAgIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LFxcclxcbiAgICAgICAgICAgIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LFxcclxcbiAgICAgICAgICAgIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI5LFxcclxcbiAgICAgICAgICAgIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LFxcclxcbiAgICAgICAgICAgIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSBdO1xcclxcblxcclxcbiAgICBmdW5jdGlvbiBUcmVlKCkge1xcclxcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xcclxcblxcclxcbiAgICAgICAgLy8gZHluX3RyZWU7IC8vIHRoZSBkeW5hbWljIHRyZWVcXHJcXG4gICAgICAgIC8vIG1heF9jb2RlOyAvLyBsYXJnZXN0IGNvZGUgd2l0aCBub24gemVybyBmcmVxdWVuY3lcXHJcXG4gICAgICAgIC8vIHN0YXRfZGVzYzsgLy8gdGhlIGNvcnJlc3BvbmRpbmcgc3RhdGljIHRyZWVcXHJcXG5cXHJcXG4gICAgICAgIC8vIENvbXB1dGUgdGhlIG9wdGltYWwgYml0IGxlbmd0aHMgZm9yIGEgdHJlZSBhbmQgdXBkYXRlIHRoZSB0b3RhbCBiaXRcXHJcXG4gICAgICAgIC8vIGxlbmd0aFxcclxcbiAgICAgICAgLy8gZm9yIHRoZSBjdXJyZW50IGJsb2NrLlxcclxcbiAgICAgICAgLy8gSU4gYXNzZXJ0aW9uOiB0aGUgZmllbGRzIGZyZXEgYW5kIGRhZCBhcmUgc2V0LCBoZWFwW2hlYXBfbWF4XSBhbmRcXHJcXG4gICAgICAgIC8vIGFib3ZlIGFyZSB0aGUgdHJlZSBub2RlcyBzb3J0ZWQgYnkgaW5jcmVhc2luZyBmcmVxdWVuY3kuXFxyXFxuICAgICAgICAvLyBPVVQgYXNzZXJ0aW9uczogdGhlIGZpZWxkIGxlbiBpcyBzZXQgdG8gdGhlIG9wdGltYWwgYml0IGxlbmd0aCwgdGhlXFxyXFxuICAgICAgICAvLyBhcnJheSBibF9jb3VudCBjb250YWlucyB0aGUgZnJlcXVlbmNpZXMgZm9yIGVhY2ggYml0IGxlbmd0aC5cXHJcXG4gICAgICAgIC8vIFRoZSBsZW5ndGggb3B0X2xlbiBpcyB1cGRhdGVkOyBzdGF0aWNfbGVuIGlzIGFsc28gdXBkYXRlZCBpZiBzdHJlZSBpc1xcclxcbiAgICAgICAgLy8gbm90IG51bGwuXFxyXFxuICAgICAgICBmdW5jdGlvbiBnZW5fYml0bGVuKHMpIHtcXHJcXG4gICAgICAgICAgICB2YXIgdHJlZSA9IHRoYXQuZHluX3RyZWU7XFxyXFxuICAgICAgICAgICAgdmFyIHN0cmVlID0gdGhhdC5zdGF0X2Rlc2Muc3RhdGljX3RyZWU7XFxyXFxuICAgICAgICAgICAgdmFyIGV4dHJhID0gdGhhdC5zdGF0X2Rlc2MuZXh0cmFfYml0cztcXHJcXG4gICAgICAgICAgICB2YXIgYmFzZSA9IHRoYXQuc3RhdF9kZXNjLmV4dHJhX2Jhc2U7XFxyXFxuICAgICAgICAgICAgdmFyIG1heF9sZW5ndGggPSB0aGF0LnN0YXRfZGVzYy5tYXhfbGVuZ3RoO1xcclxcbiAgICAgICAgICAgIHZhciBoOyAvLyBoZWFwIGluZGV4XFxyXFxuICAgICAgICAgICAgdmFyIG4sIG07IC8vIGl0ZXJhdGUgb3ZlciB0aGUgdHJlZSBlbGVtZW50c1xcclxcbiAgICAgICAgICAgIHZhciBiaXRzOyAvLyBiaXQgbGVuZ3RoXFxyXFxuICAgICAgICAgICAgdmFyIHhiaXRzOyAvLyBleHRyYSBiaXRzXFxyXFxuICAgICAgICAgICAgdmFyIGY7IC8vIGZyZXF1ZW5jeVxcclxcbiAgICAgICAgICAgIHZhciBvdmVyZmxvdyA9IDA7IC8vIG51bWJlciBvZiBlbGVtZW50cyB3aXRoIGJpdCBsZW5ndGggdG9vIGxhcmdlXFxyXFxuXFxyXFxuICAgICAgICAgICAgZm9yIChiaXRzID0gMDsgYml0cyA8PSBNQVhfQklUUzsgYml0cysrKVxcclxcbiAgICAgICAgICAgICAgICBzLmJsX2NvdW50W2JpdHNdID0gMDtcXHJcXG5cXHJcXG4gICAgICAgICAgICAvLyBJbiBhIGZpcnN0IHBhc3MsIGNvbXB1dGUgdGhlIG9wdGltYWwgYml0IGxlbmd0aHMgKHdoaWNoIG1heVxcclxcbiAgICAgICAgICAgIC8vIG92ZXJmbG93IGluIHRoZSBjYXNlIG9mIHRoZSBiaXQgbGVuZ3RoIHRyZWUpLlxcclxcbiAgICAgICAgICAgIHRyZWVbcy5oZWFwW3MuaGVhcF9tYXhdICogMiArIDFdID0gMDsgLy8gcm9vdCBvZiB0aGUgaGVhcFxcclxcblxcclxcbiAgICAgICAgICAgIGZvciAoaCA9IHMuaGVhcF9tYXggKyAxOyBoIDwgSEVBUF9TSVpFOyBoKyspIHtcXHJcXG4gICAgICAgICAgICAgICAgbiA9IHMuaGVhcFtoXTtcXHJcXG4gICAgICAgICAgICAgICAgYml0cyA9IHRyZWVbdHJlZVtuICogMiArIDFdICogMiArIDFdICsgMTtcXHJcXG4gICAgICAgICAgICAgICAgaWYgKGJpdHMgPiBtYXhfbGVuZ3RoKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICBiaXRzID0gbWF4X2xlbmd0aDtcXHJcXG4gICAgICAgICAgICAgICAgICAgIG92ZXJmbG93Kys7XFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgdHJlZVtuICogMiArIDFdID0gYml0cztcXHJcXG4gICAgICAgICAgICAgICAgLy8gV2Ugb3ZlcndyaXRlIHRyZWVbbioyKzFdIHdoaWNoIGlzIG5vIGxvbmdlciBuZWVkZWRcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgaWYgKG4gPiB0aGF0Lm1heF9jb2RlKVxcclxcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7IC8vIG5vdCBhIGxlYWYgbm9kZVxcclxcblxcclxcbiAgICAgICAgICAgICAgICBzLmJsX2NvdW50W2JpdHNdKys7XFxyXFxuICAgICAgICAgICAgICAgIHhiaXRzID0gMDtcXHJcXG4gICAgICAgICAgICAgICAgaWYgKG4gPj0gYmFzZSlcXHJcXG4gICAgICAgICAgICAgICAgICAgIHhiaXRzID0gZXh0cmFbbiAtIGJhc2VdO1xcclxcbiAgICAgICAgICAgICAgICBmID0gdHJlZVtuICogMl07XFxyXFxuICAgICAgICAgICAgICAgIHMub3B0X2xlbiArPSBmICogKGJpdHMgKyB4Yml0cyk7XFxyXFxuICAgICAgICAgICAgICAgIGlmIChzdHJlZSlcXHJcXG4gICAgICAgICAgICAgICAgICAgIHMuc3RhdGljX2xlbiArPSBmICogKHN0cmVlW24gKiAyICsgMV0gKyB4Yml0cyk7XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIGlmIChvdmVyZmxvdyA9PT0gMClcXHJcXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xcclxcblxcclxcbiAgICAgICAgICAgIC8vIFRoaXMgaGFwcGVucyBmb3IgZXhhbXBsZSBvbiBvYmoyIGFuZCBwaWMgb2YgdGhlIENhbGdhcnkgY29ycHVzXFxyXFxuICAgICAgICAgICAgLy8gRmluZCB0aGUgZmlyc3QgYml0IGxlbmd0aCB3aGljaCBjb3VsZCBpbmNyZWFzZTpcXHJcXG4gICAgICAgICAgICBkbyB7XFxyXFxuICAgICAgICAgICAgICAgIGJpdHMgPSBtYXhfbGVuZ3RoIC0gMTtcXHJcXG4gICAgICAgICAgICAgICAgd2hpbGUgKHMuYmxfY291bnRbYml0c10gPT09IDApXFxyXFxuICAgICAgICAgICAgICAgICAgICBiaXRzLS07XFxyXFxuICAgICAgICAgICAgICAgIHMuYmxfY291bnRbYml0c10tLTsgLy8gbW92ZSBvbmUgbGVhZiBkb3duIHRoZSB0cmVlXFxyXFxuICAgICAgICAgICAgICAgIHMuYmxfY291bnRbYml0cyArIDFdICs9IDI7IC8vIG1vdmUgb25lIG92ZXJmbG93IGl0ZW0gYXMgaXRzIGJyb3RoZXJcXHJcXG4gICAgICAgICAgICAgICAgcy5ibF9jb3VudFttYXhfbGVuZ3RoXS0tO1xcclxcbiAgICAgICAgICAgICAgICAvLyBUaGUgYnJvdGhlciBvZiB0aGUgb3ZlcmZsb3cgaXRlbSBhbHNvIG1vdmVzIG9uZSBzdGVwIHVwLFxcclxcbiAgICAgICAgICAgICAgICAvLyBidXQgdGhpcyBkb2VzIG5vdCBhZmZlY3QgYmxfY291bnRbbWF4X2xlbmd0aF1cXHJcXG4gICAgICAgICAgICAgICAgb3ZlcmZsb3cgLT0gMjtcXHJcXG4gICAgICAgICAgICB9IHdoaWxlIChvdmVyZmxvdyA+IDApO1xcclxcblxcclxcbiAgICAgICAgICAgIGZvciAoYml0cyA9IG1heF9sZW5ndGg7IGJpdHMgIT09IDA7IGJpdHMtLSkge1xcclxcbiAgICAgICAgICAgICAgICBuID0gcy5ibF9jb3VudFtiaXRzXTtcXHJcXG4gICAgICAgICAgICAgICAgd2hpbGUgKG4gIT09IDApIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIG0gPSBzLmhlYXBbLS1oXTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGlmIChtID4gdGhhdC5tYXhfY29kZSlcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGlmICh0cmVlW20gKiAyICsgMV0gIT0gYml0cykge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHMub3B0X2xlbiArPSAoYml0cyAtIHRyZWVbbSAqIDIgKyAxXSkgKiB0cmVlW20gKiAyXTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmVlW20gKiAyICsgMV0gPSBiaXRzO1xcclxcbiAgICAgICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICAgICAgbi0tO1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgLy8gUmV2ZXJzZSB0aGUgZmlyc3QgbGVuIGJpdHMgb2YgYSBjb2RlLCB1c2luZyBzdHJhaWdodGZvcndhcmQgY29kZSAoYVxcclxcbiAgICAgICAgLy8gZmFzdGVyXFxyXFxuICAgICAgICAvLyBtZXRob2Qgd291bGQgdXNlIGEgdGFibGUpXFxyXFxuICAgICAgICAvLyBJTiBhc3NlcnRpb246IDEgPD0gbGVuIDw9IDE1XFxyXFxuICAgICAgICBmdW5jdGlvbiBiaV9yZXZlcnNlKGNvZGUsIC8vIHRoZSB2YWx1ZSB0byBpbnZlcnRcXHJcXG4gICAgICAgIGxlbiAvLyBpdHMgYml0IGxlbmd0aFxcclxcbiAgICAgICAgKSB7XFxyXFxuICAgICAgICAgICAgdmFyIHJlcyA9IDA7XFxyXFxuICAgICAgICAgICAgZG8ge1xcclxcbiAgICAgICAgICAgICAgICByZXMgfD0gY29kZSAmIDE7XFxyXFxuICAgICAgICAgICAgICAgIGNvZGUgPj4+PSAxO1xcclxcbiAgICAgICAgICAgICAgICByZXMgPDw9IDE7XFxyXFxuICAgICAgICAgICAgfSB3aGlsZSAoLS1sZW4gPiAwKTtcXHJcXG4gICAgICAgICAgICByZXR1cm4gcmVzID4+PiAxO1xcclxcbiAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgLy8gR2VuZXJhdGUgdGhlIGNvZGVzIGZvciBhIGdpdmVuIHRyZWUgYW5kIGJpdCBjb3VudHMgKHdoaWNoIG5lZWQgbm90IGJlXFxyXFxuICAgICAgICAvLyBvcHRpbWFsKS5cXHJcXG4gICAgICAgIC8vIElOIGFzc2VydGlvbjogdGhlIGFycmF5IGJsX2NvdW50IGNvbnRhaW5zIHRoZSBiaXQgbGVuZ3RoIHN0YXRpc3RpY3MgZm9yXFxyXFxuICAgICAgICAvLyB0aGUgZ2l2ZW4gdHJlZSBhbmQgdGhlIGZpZWxkIGxlbiBpcyBzZXQgZm9yIGFsbCB0cmVlIGVsZW1lbnRzLlxcclxcbiAgICAgICAgLy8gT1VUIGFzc2VydGlvbjogdGhlIGZpZWxkIGNvZGUgaXMgc2V0IGZvciBhbGwgdHJlZSBlbGVtZW50cyBvZiBub25cXHJcXG4gICAgICAgIC8vIHplcm8gY29kZSBsZW5ndGguXFxyXFxuICAgICAgICBmdW5jdGlvbiBnZW5fY29kZXModHJlZSwgLy8gdGhlIHRyZWUgdG8gZGVjb3JhdGVcXHJcXG4gICAgICAgIG1heF9jb2RlLCAvLyBsYXJnZXN0IGNvZGUgd2l0aCBub24gemVybyBmcmVxdWVuY3lcXHJcXG4gICAgICAgIGJsX2NvdW50IC8vIG51bWJlciBvZiBjb2RlcyBhdCBlYWNoIGJpdCBsZW5ndGhcXHJcXG4gICAgICAgICkge1xcclxcbiAgICAgICAgICAgIHZhciBuZXh0X2NvZGUgPSBbXTsgLy8gbmV4dCBjb2RlIHZhbHVlIGZvciBlYWNoXFxyXFxuICAgICAgICAgICAgLy8gYml0IGxlbmd0aFxcclxcbiAgICAgICAgICAgIHZhciBjb2RlID0gMDsgLy8gcnVubmluZyBjb2RlIHZhbHVlXFxyXFxuICAgICAgICAgICAgdmFyIGJpdHM7IC8vIGJpdCBpbmRleFxcclxcbiAgICAgICAgICAgIHZhciBuOyAvLyBjb2RlIGluZGV4XFxyXFxuICAgICAgICAgICAgdmFyIGxlbjtcXHJcXG5cXHJcXG4gICAgICAgICAgICAvLyBUaGUgZGlzdHJpYnV0aW9uIGNvdW50cyBhcmUgZmlyc3QgdXNlZCB0byBnZW5lcmF0ZSB0aGUgY29kZSB2YWx1ZXNcXHJcXG4gICAgICAgICAgICAvLyB3aXRob3V0IGJpdCByZXZlcnNhbC5cXHJcXG4gICAgICAgICAgICBmb3IgKGJpdHMgPSAxOyBiaXRzIDw9IE1BWF9CSVRTOyBiaXRzKyspIHtcXHJcXG4gICAgICAgICAgICAgICAgbmV4dF9jb2RlW2JpdHNdID0gY29kZSA9ICgoY29kZSArIGJsX2NvdW50W2JpdHMgLSAxXSkgPDwgMSk7XFxyXFxuICAgICAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgICAgIC8vIENoZWNrIHRoYXQgdGhlIGJpdCBjb3VudHMgaW4gYmxfY291bnQgYXJlIGNvbnNpc3RlbnQuIFRoZSBsYXN0IGNvZGVcXHJcXG4gICAgICAgICAgICAvLyBtdXN0IGJlIGFsbCBvbmVzLlxcclxcbiAgICAgICAgICAgIC8vIEFzc2VydCAoY29kZSArIGJsX2NvdW50W01BWF9CSVRTXS0xID09ICgxPDxNQVhfQklUUyktMSxcXHJcXG4gICAgICAgICAgICAvLyBcXFwiaW5jb25zaXN0ZW50IGJpdCBjb3VudHNcXFwiKTtcXHJcXG4gICAgICAgICAgICAvLyBUcmFjZXYoKHN0ZGVycixcXFwiXFxcXG5nZW5fY29kZXM6IG1heF9jb2RlICVkIFxcXCIsIG1heF9jb2RlKSk7XFxyXFxuXFxyXFxuICAgICAgICAgICAgZm9yIChuID0gMDsgbiA8PSBtYXhfY29kZTsgbisrKSB7XFxyXFxuICAgICAgICAgICAgICAgIGxlbiA9IHRyZWVbbiAqIDIgKyAxXTtcXHJcXG4gICAgICAgICAgICAgICAgaWYgKGxlbiA9PT0gMClcXHJcXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcclxcbiAgICAgICAgICAgICAgICAvLyBOb3cgcmV2ZXJzZSB0aGUgYml0c1xcclxcbiAgICAgICAgICAgICAgICB0cmVlW24gKiAyXSA9IGJpX3JldmVyc2UobmV4dF9jb2RlW2xlbl0rKywgbGVuKTtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAvLyBDb25zdHJ1Y3Qgb25lIEh1ZmZtYW4gdHJlZSBhbmQgYXNzaWducyB0aGUgY29kZSBiaXQgc3RyaW5ncyBhbmQgbGVuZ3Rocy5cXHJcXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgdG90YWwgYml0IGxlbmd0aCBmb3IgdGhlIGN1cnJlbnQgYmxvY2suXFxyXFxuICAgICAgICAvLyBJTiBhc3NlcnRpb246IHRoZSBmaWVsZCBmcmVxIGlzIHNldCBmb3IgYWxsIHRyZWUgZWxlbWVudHMuXFxyXFxuICAgICAgICAvLyBPVVQgYXNzZXJ0aW9uczogdGhlIGZpZWxkcyBsZW4gYW5kIGNvZGUgYXJlIHNldCB0byB0aGUgb3B0aW1hbCBiaXQgbGVuZ3RoXFxyXFxuICAgICAgICAvLyBhbmQgY29ycmVzcG9uZGluZyBjb2RlLiBUaGUgbGVuZ3RoIG9wdF9sZW4gaXMgdXBkYXRlZDsgc3RhdGljX2xlbiBpc1xcclxcbiAgICAgICAgLy8gYWxzbyB1cGRhdGVkIGlmIHN0cmVlIGlzIG5vdCBudWxsLiBUaGUgZmllbGQgbWF4X2NvZGUgaXMgc2V0LlxcclxcbiAgICAgICAgdGhhdC5idWlsZF90cmVlID0gZnVuY3Rpb24ocykge1xcclxcbiAgICAgICAgICAgIHZhciB0cmVlID0gdGhhdC5keW5fdHJlZTtcXHJcXG4gICAgICAgICAgICB2YXIgc3RyZWUgPSB0aGF0LnN0YXRfZGVzYy5zdGF0aWNfdHJlZTtcXHJcXG4gICAgICAgICAgICB2YXIgZWxlbXMgPSB0aGF0LnN0YXRfZGVzYy5lbGVtcztcXHJcXG4gICAgICAgICAgICB2YXIgbiwgbTsgLy8gaXRlcmF0ZSBvdmVyIGhlYXAgZWxlbWVudHNcXHJcXG4gICAgICAgICAgICB2YXIgbWF4X2NvZGUgPSAtMTsgLy8gbGFyZ2VzdCBjb2RlIHdpdGggbm9uIHplcm8gZnJlcXVlbmN5XFxyXFxuICAgICAgICAgICAgdmFyIG5vZGU7IC8vIG5ldyBub2RlIGJlaW5nIGNyZWF0ZWRcXHJcXG5cXHJcXG4gICAgICAgICAgICAvLyBDb25zdHJ1Y3QgdGhlIGluaXRpYWwgaGVhcCwgd2l0aCBsZWFzdCBmcmVxdWVudCBlbGVtZW50IGluXFxyXFxuICAgICAgICAgICAgLy8gaGVhcFsxXS4gVGhlIHNvbnMgb2YgaGVhcFtuXSBhcmUgaGVhcFsyKm5dIGFuZCBoZWFwWzIqbisxXS5cXHJcXG4gICAgICAgICAgICAvLyBoZWFwWzBdIGlzIG5vdCB1c2VkLlxcclxcbiAgICAgICAgICAgIHMuaGVhcF9sZW4gPSAwO1xcclxcbiAgICAgICAgICAgIHMuaGVhcF9tYXggPSBIRUFQX1NJWkU7XFxyXFxuXFxyXFxuICAgICAgICAgICAgZm9yIChuID0gMDsgbiA8IGVsZW1zOyBuKyspIHtcXHJcXG4gICAgICAgICAgICAgICAgaWYgKHRyZWVbbiAqIDJdICE9PSAwKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICBzLmhlYXBbKytzLmhlYXBfbGVuXSA9IG1heF9jb2RlID0gbjtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHMuZGVwdGhbbl0gPSAwO1xcclxcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgICAgICAgICAgICAgdHJlZVtuICogMiArIDFdID0gMDtcXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICAvLyBUaGUgcGt6aXAgZm9ybWF0IHJlcXVpcmVzIHRoYXQgYXQgbGVhc3Qgb25lIGRpc3RhbmNlIGNvZGUgZXhpc3RzLFxcclxcbiAgICAgICAgICAgIC8vIGFuZCB0aGF0IGF0IGxlYXN0IG9uZSBiaXQgc2hvdWxkIGJlIHNlbnQgZXZlbiBpZiB0aGVyZSBpcyBvbmx5IG9uZVxcclxcbiAgICAgICAgICAgIC8vIHBvc3NpYmxlIGNvZGUuIFNvIHRvIGF2b2lkIHNwZWNpYWwgY2hlY2tzIGxhdGVyIG9uIHdlIGZvcmNlIGF0IGxlYXN0XFxyXFxuICAgICAgICAgICAgLy8gdHdvIGNvZGVzIG9mIG5vbiB6ZXJvIGZyZXF1ZW5jeS5cXHJcXG4gICAgICAgICAgICB3aGlsZSAocy5oZWFwX2xlbiA8IDIpIHtcXHJcXG4gICAgICAgICAgICAgICAgbm9kZSA9IHMuaGVhcFsrK3MuaGVhcF9sZW5dID0gbWF4X2NvZGUgPCAyID8gKyttYXhfY29kZSA6IDA7XFxyXFxuICAgICAgICAgICAgICAgIHRyZWVbbm9kZSAqIDJdID0gMTtcXHJcXG4gICAgICAgICAgICAgICAgcy5kZXB0aFtub2RlXSA9IDA7XFxyXFxuICAgICAgICAgICAgICAgIHMub3B0X2xlbi0tO1xcclxcbiAgICAgICAgICAgICAgICBpZiAoc3RyZWUpXFxyXFxuICAgICAgICAgICAgICAgICAgICBzLnN0YXRpY19sZW4gLT0gc3RyZWVbbm9kZSAqIDIgKyAxXTtcXHJcXG4gICAgICAgICAgICAgICAgLy8gbm9kZSBpcyAwIG9yIDEgc28gaXQgZG9lcyBub3QgaGF2ZSBleHRyYSBiaXRzXFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIHRoYXQubWF4X2NvZGUgPSBtYXhfY29kZTtcXHJcXG5cXHJcXG4gICAgICAgICAgICAvLyBUaGUgZWxlbWVudHMgaGVhcFtoZWFwX2xlbi8yKzEgLi4gaGVhcF9sZW5dIGFyZSBsZWF2ZXMgb2YgdGhlIHRyZWUsXFxyXFxuICAgICAgICAgICAgLy8gZXN0YWJsaXNoIHN1Yi1oZWFwcyBvZiBpbmNyZWFzaW5nIGxlbmd0aHM6XFxyXFxuXFxyXFxuICAgICAgICAgICAgZm9yIChuID0gTWF0aC5mbG9vcihzLmhlYXBfbGVuIC8gMik7IG4gPj0gMTsgbi0tKVxcclxcbiAgICAgICAgICAgICAgICBzLnBxZG93bmhlYXAodHJlZSwgbik7XFxyXFxuXFxyXFxuICAgICAgICAgICAgLy8gQ29uc3RydWN0IHRoZSBIdWZmbWFuIHRyZWUgYnkgcmVwZWF0ZWRseSBjb21iaW5pbmcgdGhlIGxlYXN0IHR3b1xcclxcbiAgICAgICAgICAgIC8vIGZyZXF1ZW50IG5vZGVzLlxcclxcblxcclxcbiAgICAgICAgICAgIG5vZGUgPSBlbGVtczsgLy8gbmV4dCBpbnRlcm5hbCBub2RlIG9mIHRoZSB0cmVlXFxyXFxuICAgICAgICAgICAgZG8ge1xcclxcbiAgICAgICAgICAgICAgICAvLyBuID0gbm9kZSBvZiBsZWFzdCBmcmVxdWVuY3lcXHJcXG4gICAgICAgICAgICAgICAgbiA9IHMuaGVhcFsxXTtcXHJcXG4gICAgICAgICAgICAgICAgcy5oZWFwWzFdID0gcy5oZWFwW3MuaGVhcF9sZW4tLV07XFxyXFxuICAgICAgICAgICAgICAgIHMucHFkb3duaGVhcCh0cmVlLCAxKTtcXHJcXG4gICAgICAgICAgICAgICAgbSA9IHMuaGVhcFsxXTsgLy8gbSA9IG5vZGUgb2YgbmV4dCBsZWFzdCBmcmVxdWVuY3lcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgcy5oZWFwWy0tcy5oZWFwX21heF0gPSBuOyAvLyBrZWVwIHRoZSBub2RlcyBzb3J0ZWQgYnkgZnJlcXVlbmN5XFxyXFxuICAgICAgICAgICAgICAgIHMuaGVhcFstLXMuaGVhcF9tYXhdID0gbTtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IG5vZGUgZmF0aGVyIG9mIG4gYW5kIG1cXHJcXG4gICAgICAgICAgICAgICAgdHJlZVtub2RlICogMl0gPSAodHJlZVtuICogMl0gKyB0cmVlW20gKiAyXSk7XFxyXFxuICAgICAgICAgICAgICAgIHMuZGVwdGhbbm9kZV0gPSBNYXRoLm1heChzLmRlcHRoW25dLCBzLmRlcHRoW21dKSArIDE7XFxyXFxuICAgICAgICAgICAgICAgIHRyZWVbbiAqIDIgKyAxXSA9IHRyZWVbbSAqIDIgKyAxXSA9IG5vZGU7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgIC8vIGFuZCBpbnNlcnQgdGhlIG5ldyBub2RlIGluIHRoZSBoZWFwXFxyXFxuICAgICAgICAgICAgICAgIHMuaGVhcFsxXSA9IG5vZGUrKztcXHJcXG4gICAgICAgICAgICAgICAgcy5wcWRvd25oZWFwKHRyZWUsIDEpO1xcclxcbiAgICAgICAgICAgIH0gd2hpbGUgKHMuaGVhcF9sZW4gPj0gMik7XFxyXFxuXFxyXFxuICAgICAgICAgICAgcy5oZWFwWy0tcy5oZWFwX21heF0gPSBzLmhlYXBbMV07XFxyXFxuXFxyXFxuICAgICAgICAgICAgLy8gQXQgdGhpcyBwb2ludCwgdGhlIGZpZWxkcyBmcmVxIGFuZCBkYWQgYXJlIHNldC4gV2UgY2FuIG5vd1xcclxcbiAgICAgICAgICAgIC8vIGdlbmVyYXRlIHRoZSBiaXQgbGVuZ3Rocy5cXHJcXG5cXHJcXG4gICAgICAgICAgICBnZW5fYml0bGVuKHMpO1xcclxcblxcclxcbiAgICAgICAgICAgIC8vIFRoZSBmaWVsZCBsZW4gaXMgbm93IHNldCwgd2UgY2FuIGdlbmVyYXRlIHRoZSBiaXQgY29kZXNcXHJcXG4gICAgICAgICAgICBnZW5fY29kZXModHJlZSwgdGhhdC5tYXhfY29kZSwgcy5ibF9jb3VudCk7XFxyXFxuICAgICAgICB9O1xcclxcblxcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgIFRyZWUuX2xlbmd0aF9jb2RlID0gWyAwLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA4LCA5LCA5LCAxMCwgMTAsIDExLCAxMSwgMTIsIDEyLCAxMiwgMTIsIDEzLCAxMywgMTMsIDEzLCAxNCwgMTQsIDE0LCAxNCwgMTUsIDE1LCAxNSwgMTUsIDE2LCAxNiwgMTYsIDE2LFxcclxcbiAgICAgICAgICAgIDE2LCAxNiwgMTYsIDE2LCAxNywgMTcsIDE3LCAxNywgMTcsIDE3LCAxNywgMTcsIDE4LCAxOCwgMTgsIDE4LCAxOCwgMTgsIDE4LCAxOCwgMTksIDE5LCAxOSwgMTksIDE5LCAxOSwgMTksIDE5LCAyMCwgMjAsIDIwLCAyMCwgMjAsIDIwLCAyMCwgMjAsIDIwLFxcclxcbiAgICAgICAgICAgIDIwLCAyMCwgMjAsIDIwLCAyMCwgMjAsIDIwLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLFxcclxcbiAgICAgICAgICAgIDIyLCAyMiwgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LFxcclxcbiAgICAgICAgICAgIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNSwgMjUsIDI1LCAyNSwgMjUsIDI1LCAyNSwgMjUsIDI1LCAyNSwgMjUsIDI1LCAyNSwgMjUsIDI1LCAyNSwgMjUsIDI1LCAyNSwgMjUsIDI1LCAyNSwgMjUsIDI1LFxcclxcbiAgICAgICAgICAgIDI1LCAyNSwgMjUsIDI1LCAyNSwgMjUsIDI1LCAyNSwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LFxcclxcbiAgICAgICAgICAgIDI2LCAyNiwgMjYsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyOCBdO1xcclxcblxcclxcbiAgICBUcmVlLmJhc2VfbGVuZ3RoID0gWyAwLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCAxMCwgMTIsIDE0LCAxNiwgMjAsIDI0LCAyOCwgMzIsIDQwLCA0OCwgNTYsIDY0LCA4MCwgOTYsIDExMiwgMTI4LCAxNjAsIDE5MiwgMjI0LCAwIF07XFxyXFxuXFxyXFxuICAgIFRyZWUuYmFzZV9kaXN0ID0gWyAwLCAxLCAyLCAzLCA0LCA2LCA4LCAxMiwgMTYsIDI0LCAzMiwgNDgsIDY0LCA5NiwgMTI4LCAxOTIsIDI1NiwgMzg0LCA1MTIsIDc2OCwgMTAyNCwgMTUzNiwgMjA0OCwgMzA3MiwgNDA5NiwgNjE0NCwgODE5MiwgMTIyODgsIDE2Mzg0LFxcclxcbiAgICAgICAgICAgIDI0NTc2IF07XFxyXFxuXFxyXFxuICAgIC8vIE1hcHBpbmcgZnJvbSBhIGRpc3RhbmNlIHRvIGEgZGlzdGFuY2UgY29kZS4gZGlzdCBpcyB0aGUgZGlzdGFuY2UgLSAxIGFuZFxcclxcbiAgICAvLyBtdXN0IG5vdCBoYXZlIHNpZGUgZWZmZWN0cy4gX2Rpc3RfY29kZVsyNTZdIGFuZCBfZGlzdF9jb2RlWzI1N10gYXJlIG5ldmVyXFxyXFxuICAgIC8vIHVzZWQuXFxyXFxuICAgIFRyZWUuZF9jb2RlID0gZnVuY3Rpb24oZGlzdCkge1xcclxcbiAgICAgICAgcmV0dXJuICgoZGlzdCkgPCAyNTYgPyBfZGlzdF9jb2RlW2Rpc3RdIDogX2Rpc3RfY29kZVsyNTYgKyAoKGRpc3QpID4+PiA3KV0pO1xcclxcbiAgICB9O1xcclxcblxcclxcbiAgICAvLyBleHRyYSBiaXRzIGZvciBlYWNoIGxlbmd0aCBjb2RlXFxyXFxuICAgIFRyZWUuZXh0cmFfbGJpdHMgPSBbIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDEsIDEsIDEsIDEsIDIsIDIsIDIsIDIsIDMsIDMsIDMsIDMsIDQsIDQsIDQsIDQsIDUsIDUsIDUsIDUsIDAgXTtcXHJcXG5cXHJcXG4gICAgLy8gZXh0cmEgYml0cyBmb3IgZWFjaCBkaXN0YW5jZSBjb2RlXFxyXFxuICAgIFRyZWUuZXh0cmFfZGJpdHMgPSBbIDAsIDAsIDAsIDAsIDEsIDEsIDIsIDIsIDMsIDMsIDQsIDQsIDUsIDUsIDYsIDYsIDcsIDcsIDgsIDgsIDksIDksIDEwLCAxMCwgMTEsIDExLCAxMiwgMTIsIDEzLCAxMyBdO1xcclxcblxcclxcbiAgICAvLyBleHRyYSBiaXRzIGZvciBlYWNoIGJpdCBsZW5ndGggY29kZVxcclxcbiAgICBUcmVlLmV4dHJhX2JsYml0cyA9IFsgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMiwgMywgNyBdO1xcclxcblxcclxcbiAgICBUcmVlLmJsX29yZGVyID0gWyAxNiwgMTcsIDE4LCAwLCA4LCA3LCA5LCA2LCAxMCwgNSwgMTEsIDQsIDEyLCAzLCAxMywgMiwgMTQsIDEsIDE1IF07XFxyXFxuXFxyXFxuICAgIC8vIFN0YXRpY1RyZWVcXHJcXG5cXHJcXG4gICAgZnVuY3Rpb24gU3RhdGljVHJlZShzdGF0aWNfdHJlZSwgZXh0cmFfYml0cywgZXh0cmFfYmFzZSwgZWxlbXMsIG1heF9sZW5ndGgpIHtcXHJcXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcXHJcXG4gICAgICAgIHRoYXQuc3RhdGljX3RyZWUgPSBzdGF0aWNfdHJlZTtcXHJcXG4gICAgICAgIHRoYXQuZXh0cmFfYml0cyA9IGV4dHJhX2JpdHM7XFxyXFxuICAgICAgICB0aGF0LmV4dHJhX2Jhc2UgPSBleHRyYV9iYXNlO1xcclxcbiAgICAgICAgdGhhdC5lbGVtcyA9IGVsZW1zO1xcclxcbiAgICAgICAgdGhhdC5tYXhfbGVuZ3RoID0gbWF4X2xlbmd0aDtcXHJcXG4gICAgfVxcclxcblxcclxcbiAgICBTdGF0aWNUcmVlLnN0YXRpY19sdHJlZSA9IFsgMTIsIDgsIDE0MCwgOCwgNzYsIDgsIDIwNCwgOCwgNDQsIDgsIDE3MiwgOCwgMTA4LCA4LCAyMzYsIDgsIDI4LCA4LCAxNTYsIDgsIDkyLCA4LCAyMjAsIDgsIDYwLCA4LCAxODgsIDgsIDEyNCwgOCwgMjUyLCA4LCAyLCA4LFxcclxcbiAgICAgICAgICAgIDEzMCwgOCwgNjYsIDgsIDE5NCwgOCwgMzQsIDgsIDE2MiwgOCwgOTgsIDgsIDIyNiwgOCwgMTgsIDgsIDE0NiwgOCwgODIsIDgsIDIxMCwgOCwgNTAsIDgsIDE3OCwgOCwgMTE0LCA4LCAyNDIsIDgsIDEwLCA4LCAxMzgsIDgsIDc0LCA4LCAyMDIsIDgsIDQyLFxcclxcbiAgICAgICAgICAgIDgsIDE3MCwgOCwgMTA2LCA4LCAyMzQsIDgsIDI2LCA4LCAxNTQsIDgsIDkwLCA4LCAyMTgsIDgsIDU4LCA4LCAxODYsIDgsIDEyMiwgOCwgMjUwLCA4LCA2LCA4LCAxMzQsIDgsIDcwLCA4LCAxOTgsIDgsIDM4LCA4LCAxNjYsIDgsIDEwMiwgOCwgMjMwLCA4LFxcclxcbiAgICAgICAgICAgIDIyLCA4LCAxNTAsIDgsIDg2LCA4LCAyMTQsIDgsIDU0LCA4LCAxODIsIDgsIDExOCwgOCwgMjQ2LCA4LCAxNCwgOCwgMTQyLCA4LCA3OCwgOCwgMjA2LCA4LCA0NiwgOCwgMTc0LCA4LCAxMTAsIDgsIDIzOCwgOCwgMzAsIDgsIDE1OCwgOCwgOTQsIDgsXFxyXFxuICAgICAgICAgICAgMjIyLCA4LCA2MiwgOCwgMTkwLCA4LCAxMjYsIDgsIDI1NCwgOCwgMSwgOCwgMTI5LCA4LCA2NSwgOCwgMTkzLCA4LCAzMywgOCwgMTYxLCA4LCA5NywgOCwgMjI1LCA4LCAxNywgOCwgMTQ1LCA4LCA4MSwgOCwgMjA5LCA4LCA0OSwgOCwgMTc3LCA4LCAxMTMsXFxyXFxuICAgICAgICAgICAgOCwgMjQxLCA4LCA5LCA4LCAxMzcsIDgsIDczLCA4LCAyMDEsIDgsIDQxLCA4LCAxNjksIDgsIDEwNSwgOCwgMjMzLCA4LCAyNSwgOCwgMTUzLCA4LCA4OSwgOCwgMjE3LCA4LCA1NywgOCwgMTg1LCA4LCAxMjEsIDgsIDI0OSwgOCwgNSwgOCwgMTMzLCA4LFxcclxcbiAgICAgICAgICAgIDY5LCA4LCAxOTcsIDgsIDM3LCA4LCAxNjUsIDgsIDEwMSwgOCwgMjI5LCA4LCAyMSwgOCwgMTQ5LCA4LCA4NSwgOCwgMjEzLCA4LCA1MywgOCwgMTgxLCA4LCAxMTcsIDgsIDI0NSwgOCwgMTMsIDgsIDE0MSwgOCwgNzcsIDgsIDIwNSwgOCwgNDUsIDgsXFxyXFxuICAgICAgICAgICAgMTczLCA4LCAxMDksIDgsIDIzNywgOCwgMjksIDgsIDE1NywgOCwgOTMsIDgsIDIyMSwgOCwgNjEsIDgsIDE4OSwgOCwgMTI1LCA4LCAyNTMsIDgsIDE5LCA5LCAyNzUsIDksIDE0NywgOSwgNDAzLCA5LCA4MywgOSwgMzM5LCA5LCAyMTEsIDksIDQ2NywgOSxcXHJcXG4gICAgICAgICAgICA1MSwgOSwgMzA3LCA5LCAxNzksIDksIDQzNSwgOSwgMTE1LCA5LCAzNzEsIDksIDI0MywgOSwgNDk5LCA5LCAxMSwgOSwgMjY3LCA5LCAxMzksIDksIDM5NSwgOSwgNzUsIDksIDMzMSwgOSwgMjAzLCA5LCA0NTksIDksIDQzLCA5LCAyOTksIDksIDE3MSwgOSxcXHJcXG4gICAgICAgICAgICA0MjcsIDksIDEwNywgOSwgMzYzLCA5LCAyMzUsIDksIDQ5MSwgOSwgMjcsIDksIDI4MywgOSwgMTU1LCA5LCA0MTEsIDksIDkxLCA5LCAzNDcsIDksIDIxOSwgOSwgNDc1LCA5LCA1OSwgOSwgMzE1LCA5LCAxODcsIDksIDQ0MywgOSwgMTIzLCA5LCAzNzksXFxyXFxuICAgICAgICAgICAgOSwgMjUxLCA5LCA1MDcsIDksIDcsIDksIDI2MywgOSwgMTM1LCA5LCAzOTEsIDksIDcxLCA5LCAzMjcsIDksIDE5OSwgOSwgNDU1LCA5LCAzOSwgOSwgMjk1LCA5LCAxNjcsIDksIDQyMywgOSwgMTAzLCA5LCAzNTksIDksIDIzMSwgOSwgNDg3LCA5LCAyMyxcXHJcXG4gICAgICAgICAgICA5LCAyNzksIDksIDE1MSwgOSwgNDA3LCA5LCA4NywgOSwgMzQzLCA5LCAyMTUsIDksIDQ3MSwgOSwgNTUsIDksIDMxMSwgOSwgMTgzLCA5LCA0MzksIDksIDExOSwgOSwgMzc1LCA5LCAyNDcsIDksIDUwMywgOSwgMTUsIDksIDI3MSwgOSwgMTQzLCA5LFxcclxcbiAgICAgICAgICAgIDM5OSwgOSwgNzksIDksIDMzNSwgOSwgMjA3LCA5LCA0NjMsIDksIDQ3LCA5LCAzMDMsIDksIDE3NSwgOSwgNDMxLCA5LCAxMTEsIDksIDM2NywgOSwgMjM5LCA5LCA0OTUsIDksIDMxLCA5LCAyODcsIDksIDE1OSwgOSwgNDE1LCA5LCA5NSwgOSwgMzUxLCA5LFxcclxcbiAgICAgICAgICAgIDIyMywgOSwgNDc5LCA5LCA2MywgOSwgMzE5LCA5LCAxOTEsIDksIDQ0NywgOSwgMTI3LCA5LCAzODMsIDksIDI1NSwgOSwgNTExLCA5LCAwLCA3LCA2NCwgNywgMzIsIDcsIDk2LCA3LCAxNiwgNywgODAsIDcsIDQ4LCA3LCAxMTIsIDcsIDgsIDcsIDcyLCA3LFxcclxcbiAgICAgICAgICAgIDQwLCA3LCAxMDQsIDcsIDI0LCA3LCA4OCwgNywgNTYsIDcsIDEyMCwgNywgNCwgNywgNjgsIDcsIDM2LCA3LCAxMDAsIDcsIDIwLCA3LCA4NCwgNywgNTIsIDcsIDExNiwgNywgMywgOCwgMTMxLCA4LCA2NywgOCwgMTk1LCA4LCAzNSwgOCwgMTYzLCA4LFxcclxcbiAgICAgICAgICAgIDk5LCA4LCAyMjcsIDggXTtcXHJcXG5cXHJcXG4gICAgU3RhdGljVHJlZS5zdGF0aWNfZHRyZWUgPSBbIDAsIDUsIDE2LCA1LCA4LCA1LCAyNCwgNSwgNCwgNSwgMjAsIDUsIDEyLCA1LCAyOCwgNSwgMiwgNSwgMTgsIDUsIDEwLCA1LCAyNiwgNSwgNiwgNSwgMjIsIDUsIDE0LCA1LCAzMCwgNSwgMSwgNSwgMTcsIDUsIDksIDUsXFxyXFxuICAgICAgICAgICAgMjUsIDUsIDUsIDUsIDIxLCA1LCAxMywgNSwgMjksIDUsIDMsIDUsIDE5LCA1LCAxMSwgNSwgMjcsIDUsIDcsIDUsIDIzLCA1IF07XFxyXFxuXFxyXFxuICAgIFN0YXRpY1RyZWUuc3RhdGljX2xfZGVzYyA9IG5ldyBTdGF0aWNUcmVlKFN0YXRpY1RyZWUuc3RhdGljX2x0cmVlLCBUcmVlLmV4dHJhX2xiaXRzLCBMSVRFUkFMUyArIDEsIExfQ09ERVMsIE1BWF9CSVRTKTtcXHJcXG5cXHJcXG4gICAgU3RhdGljVHJlZS5zdGF0aWNfZF9kZXNjID0gbmV3IFN0YXRpY1RyZWUoU3RhdGljVHJlZS5zdGF0aWNfZHRyZWUsIFRyZWUuZXh0cmFfZGJpdHMsIDAsIERfQ09ERVMsIE1BWF9CSVRTKTtcXHJcXG5cXHJcXG4gICAgU3RhdGljVHJlZS5zdGF0aWNfYmxfZGVzYyA9IG5ldyBTdGF0aWNUcmVlKG51bGwsIFRyZWUuZXh0cmFfYmxiaXRzLCAwLCBCTF9DT0RFUywgTUFYX0JMX0JJVFMpO1xcclxcblxcclxcbiAgICAvLyBEZWZsYXRlXFxyXFxuXFxyXFxuICAgIHZhciBNQVhfTUVNX0xFVkVMID0gOTtcXHJcXG4gICAgdmFyIERFRl9NRU1fTEVWRUwgPSA4O1xcclxcblxcclxcbiAgICBmdW5jdGlvbiBDb25maWcoZ29vZF9sZW5ndGgsIG1heF9sYXp5LCBuaWNlX2xlbmd0aCwgbWF4X2NoYWluLCBmdW5jKSB7XFxyXFxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XFxyXFxuICAgICAgICB0aGF0Lmdvb2RfbGVuZ3RoID0gZ29vZF9sZW5ndGg7XFxyXFxuICAgICAgICB0aGF0Lm1heF9sYXp5ID0gbWF4X2xhenk7XFxyXFxuICAgICAgICB0aGF0Lm5pY2VfbGVuZ3RoID0gbmljZV9sZW5ndGg7XFxyXFxuICAgICAgICB0aGF0Lm1heF9jaGFpbiA9IG1heF9jaGFpbjtcXHJcXG4gICAgICAgIHRoYXQuZnVuYyA9IGZ1bmM7XFxyXFxuICAgIH1cXHJcXG5cXHJcXG4gICAgdmFyIFNUT1JFRCA9IDA7XFxyXFxuICAgIHZhciBGQVNUID0gMTtcXHJcXG4gICAgdmFyIFNMT1cgPSAyO1xcclxcbiAgICB2YXIgY29uZmlnX3RhYmxlID0gWyBuZXcgQ29uZmlnKDAsIDAsIDAsIDAsIFNUT1JFRCksIG5ldyBDb25maWcoNCwgNCwgOCwgNCwgRkFTVCksIG5ldyBDb25maWcoNCwgNSwgMTYsIDgsIEZBU1QpLCBuZXcgQ29uZmlnKDQsIDYsIDMyLCAzMiwgRkFTVCksXFxyXFxuICAgICAgICAgICAgbmV3IENvbmZpZyg0LCA0LCAxNiwgMTYsIFNMT1cpLCBuZXcgQ29uZmlnKDgsIDE2LCAzMiwgMzIsIFNMT1cpLCBuZXcgQ29uZmlnKDgsIDE2LCAxMjgsIDEyOCwgU0xPVyksIG5ldyBDb25maWcoOCwgMzIsIDEyOCwgMjU2LCBTTE9XKSxcXHJcXG4gICAgICAgICAgICBuZXcgQ29uZmlnKDMyLCAxMjgsIDI1OCwgMTAyNCwgU0xPVyksIG5ldyBDb25maWcoMzIsIDI1OCwgMjU4LCA0MDk2LCBTTE9XKSBdO1xcclxcblxcclxcbiAgICB2YXIgel9lcnJtc2cgPSBbIFxcXCJuZWVkIGRpY3Rpb25hcnlcXFwiLCAvLyBaX05FRURfRElDVFxcclxcbiAgICAvLyAyXFxyXFxuICAgIFxcXCJzdHJlYW0gZW5kXFxcIiwgLy8gWl9TVFJFQU1fRU5EIDFcXHJcXG4gICAgXFxcIlxcXCIsIC8vIFpfT0sgMFxcclxcbiAgICBcXFwiXFxcIiwgLy8gWl9FUlJOTyAoLTEpXFxyXFxuICAgIFxcXCJzdHJlYW0gZXJyb3JcXFwiLCAvLyBaX1NUUkVBTV9FUlJPUiAoLTIpXFxyXFxuICAgIFxcXCJkYXRhIGVycm9yXFxcIiwgLy8gWl9EQVRBX0VSUk9SICgtMylcXHJcXG4gICAgXFxcIlxcXCIsIC8vIFpfTUVNX0VSUk9SICgtNClcXHJcXG4gICAgXFxcImJ1ZmZlciBlcnJvclxcXCIsIC8vIFpfQlVGX0VSUk9SICgtNSlcXHJcXG4gICAgXFxcIlxcXCIsLy8gWl9WRVJTSU9OX0VSUk9SICgtNilcXHJcXG4gICAgXFxcIlxcXCIgXTtcXHJcXG5cXHJcXG4gICAgLy8gYmxvY2sgbm90IGNvbXBsZXRlZCwgbmVlZCBtb3JlIGlucHV0IG9yIG1vcmUgb3V0cHV0XFxyXFxuICAgIHZhciBOZWVkTW9yZSA9IDA7XFxyXFxuXFxyXFxuICAgIC8vIGJsb2NrIGZsdXNoIHBlcmZvcm1lZFxcclxcbiAgICB2YXIgQmxvY2tEb25lID0gMTtcXHJcXG5cXHJcXG4gICAgLy8gZmluaXNoIHN0YXJ0ZWQsIG5lZWQgb25seSBtb3JlIG91dHB1dCBhdCBuZXh0IGRlZmxhdGVcXHJcXG4gICAgdmFyIEZpbmlzaFN0YXJ0ZWQgPSAyO1xcclxcblxcclxcbiAgICAvLyBmaW5pc2ggZG9uZSwgYWNjZXB0IG5vIG1vcmUgaW5wdXQgb3Igb3V0cHV0XFxyXFxuICAgIHZhciBGaW5pc2hEb25lID0gMztcXHJcXG5cXHJcXG4gICAgLy8gcHJlc2V0IGRpY3Rpb25hcnkgZmxhZyBpbiB6bGliIGhlYWRlclxcclxcbiAgICB2YXIgUFJFU0VUX0RJQ1QgPSAweDIwO1xcclxcblxcclxcbiAgICB2YXIgSU5JVF9TVEFURSA9IDQyO1xcclxcbiAgICB2YXIgQlVTWV9TVEFURSA9IDExMztcXHJcXG4gICAgdmFyIEZJTklTSF9TVEFURSA9IDY2NjtcXHJcXG5cXHJcXG4gICAgLy8gVGhlIGRlZmxhdGUgY29tcHJlc3Npb24gbWV0aG9kXFxyXFxuICAgIHZhciBaX0RFRkxBVEVEID0gODtcXHJcXG5cXHJcXG4gICAgdmFyIFNUT1JFRF9CTE9DSyA9IDA7XFxyXFxuICAgIHZhciBTVEFUSUNfVFJFRVMgPSAxO1xcclxcbiAgICB2YXIgRFlOX1RSRUVTID0gMjtcXHJcXG5cXHJcXG4gICAgdmFyIE1JTl9NQVRDSCA9IDM7XFxyXFxuICAgIHZhciBNQVhfTUFUQ0ggPSAyNTg7XFxyXFxuICAgIHZhciBNSU5fTE9PS0FIRUFEID0gKE1BWF9NQVRDSCArIE1JTl9NQVRDSCArIDEpO1xcclxcblxcclxcbiAgICBmdW5jdGlvbiBzbWFsbGVyKHRyZWUsIG4sIG0sIGRlcHRoKSB7XFxyXFxuICAgICAgICB2YXIgdG4yID0gdHJlZVtuICogMl07XFxyXFxuICAgICAgICB2YXIgdG0yID0gdHJlZVttICogMl07XFxyXFxuICAgICAgICByZXR1cm4gKHRuMiA8IHRtMiB8fCAodG4yID09IHRtMiAmJiBkZXB0aFtuXSA8PSBkZXB0aFttXSkpO1xcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgIGZ1bmN0aW9uIERlZmxhdGUoKSB7XFxyXFxuXFxyXFxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XFxyXFxuICAgICAgICB2YXIgc3RybTsgLy8gcG9pbnRlciBiYWNrIHRvIHRoaXMgemxpYiBzdHJlYW1cXHJcXG4gICAgICAgIHZhciBzdGF0dXM7IC8vIGFzIHRoZSBuYW1lIGltcGxpZXNcXHJcXG4gICAgICAgIC8vIHBlbmRpbmdfYnVmOyAvLyBvdXRwdXQgc3RpbGwgcGVuZGluZ1xcclxcbiAgICAgICAgdmFyIHBlbmRpbmdfYnVmX3NpemU7IC8vIHNpemUgb2YgcGVuZGluZ19idWZcXHJcXG4gICAgICAgIC8vIHBlbmRpbmdfb3V0OyAvLyBuZXh0IHBlbmRpbmcgYnl0ZSB0byBvdXRwdXQgdG8gdGhlIHN0cmVhbVxcclxcbiAgICAgICAgLy8gcGVuZGluZzsgLy8gbmIgb2YgYnl0ZXMgaW4gdGhlIHBlbmRpbmcgYnVmZmVyXFxyXFxuICAgICAgICB2YXIgbWV0aG9kOyAvLyBTVE9SRUQgKGZvciB6aXAgb25seSkgb3IgREVGTEFURURcXHJcXG4gICAgICAgIHZhciBsYXN0X2ZsdXNoOyAvLyB2YWx1ZSBvZiBmbHVzaCBwYXJhbSBmb3IgcHJldmlvdXMgZGVmbGF0ZSBjYWxsXFxyXFxuXFxyXFxuICAgICAgICB2YXIgd19zaXplOyAvLyBMWjc3IHdpbmRvdyBzaXplICgzMksgYnkgZGVmYXVsdClcXHJcXG4gICAgICAgIHZhciB3X2JpdHM7IC8vIGxvZzIod19zaXplKSAoOC4uMTYpXFxyXFxuICAgICAgICB2YXIgd19tYXNrOyAvLyB3X3NpemUgLSAxXFxyXFxuXFxyXFxuICAgICAgICB2YXIgd2luZG93O1xcclxcbiAgICAgICAgLy8gU2xpZGluZyB3aW5kb3cuIElucHV0IGJ5dGVzIGFyZSByZWFkIGludG8gdGhlIHNlY29uZCBoYWxmIG9mIHRoZSB3aW5kb3csXFxyXFxuICAgICAgICAvLyBhbmQgbW92ZSB0byB0aGUgZmlyc3QgaGFsZiBsYXRlciB0byBrZWVwIGEgZGljdGlvbmFyeSBvZiBhdCBsZWFzdCB3U2l6ZVxcclxcbiAgICAgICAgLy8gYnl0ZXMuIFdpdGggdGhpcyBvcmdhbml6YXRpb24sIG1hdGNoZXMgYXJlIGxpbWl0ZWQgdG8gYSBkaXN0YW5jZSBvZlxcclxcbiAgICAgICAgLy8gd1NpemUtTUFYX01BVENIIGJ5dGVzLCBidXQgdGhpcyBlbnN1cmVzIHRoYXQgSU8gaXMgYWx3YXlzXFxyXFxuICAgICAgICAvLyBwZXJmb3JtZWQgd2l0aCBhIGxlbmd0aCBtdWx0aXBsZSBvZiB0aGUgYmxvY2sgc2l6ZS4gQWxzbywgaXQgbGltaXRzXFxyXFxuICAgICAgICAvLyB0aGUgd2luZG93IHNpemUgdG8gNjRLLCB3aGljaCBpcyBxdWl0ZSB1c2VmdWwgb24gTVNET1MuXFxyXFxuICAgICAgICAvLyBUbyBkbzogdXNlIHRoZSB1c2VyIGlucHV0IGJ1ZmZlciBhcyBzbGlkaW5nIHdpbmRvdy5cXHJcXG5cXHJcXG4gICAgICAgIHZhciB3aW5kb3dfc2l6ZTtcXHJcXG4gICAgICAgIC8vIEFjdHVhbCBzaXplIG9mIHdpbmRvdzogMip3U2l6ZSwgZXhjZXB0IHdoZW4gdGhlIHVzZXIgaW5wdXQgYnVmZmVyXFxyXFxuICAgICAgICAvLyBpcyBkaXJlY3RseSB1c2VkIGFzIHNsaWRpbmcgd2luZG93LlxcclxcblxcclxcbiAgICAgICAgdmFyIHByZXY7XFxyXFxuICAgICAgICAvLyBMaW5rIHRvIG9sZGVyIHN0cmluZyB3aXRoIHNhbWUgaGFzaCBpbmRleC4gVG8gbGltaXQgdGhlIHNpemUgb2YgdGhpc1xcclxcbiAgICAgICAgLy8gYXJyYXkgdG8gNjRLLCB0aGlzIGxpbmsgaXMgbWFpbnRhaW5lZCBvbmx5IGZvciB0aGUgbGFzdCAzMksgc3RyaW5ncy5cXHJcXG4gICAgICAgIC8vIEFuIGluZGV4IGluIHRoaXMgYXJyYXkgaXMgdGh1cyBhIHdpbmRvdyBpbmRleCBtb2R1bG8gMzJLLlxcclxcblxcclxcbiAgICAgICAgdmFyIGhlYWQ7IC8vIEhlYWRzIG9mIHRoZSBoYXNoIGNoYWlucyBvciBOSUwuXFxyXFxuXFxyXFxuICAgICAgICB2YXIgaW5zX2g7IC8vIGhhc2ggaW5kZXggb2Ygc3RyaW5nIHRvIGJlIGluc2VydGVkXFxyXFxuICAgICAgICB2YXIgaGFzaF9zaXplOyAvLyBudW1iZXIgb2YgZWxlbWVudHMgaW4gaGFzaCB0YWJsZVxcclxcbiAgICAgICAgdmFyIGhhc2hfYml0czsgLy8gbG9nMihoYXNoX3NpemUpXFxyXFxuICAgICAgICB2YXIgaGFzaF9tYXNrOyAvLyBoYXNoX3NpemUtMVxcclxcblxcclxcbiAgICAgICAgLy8gTnVtYmVyIG9mIGJpdHMgYnkgd2hpY2ggaW5zX2ggbXVzdCBiZSBzaGlmdGVkIGF0IGVhY2ggaW5wdXRcXHJcXG4gICAgICAgIC8vIHN0ZXAuIEl0IG11c3QgYmUgc3VjaCB0aGF0IGFmdGVyIE1JTl9NQVRDSCBzdGVwcywgdGhlIG9sZGVzdFxcclxcbiAgICAgICAgLy8gYnl0ZSBubyBsb25nZXIgdGFrZXMgcGFydCBpbiB0aGUgaGFzaCBrZXksIHRoYXQgaXM6XFxyXFxuICAgICAgICAvLyBoYXNoX3NoaWZ0ICogTUlOX01BVENIID49IGhhc2hfYml0c1xcclxcbiAgICAgICAgdmFyIGhhc2hfc2hpZnQ7XFxyXFxuXFxyXFxuICAgICAgICAvLyBXaW5kb3cgcG9zaXRpb24gYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgY3VycmVudCBvdXRwdXQgYmxvY2suIEdldHNcXHJcXG4gICAgICAgIC8vIG5lZ2F0aXZlIHdoZW4gdGhlIHdpbmRvdyBpcyBtb3ZlZCBiYWNrd2FyZHMuXFxyXFxuXFxyXFxuICAgICAgICB2YXIgYmxvY2tfc3RhcnQ7XFxyXFxuXFxyXFxuICAgICAgICB2YXIgbWF0Y2hfbGVuZ3RoOyAvLyBsZW5ndGggb2YgYmVzdCBtYXRjaFxcclxcbiAgICAgICAgdmFyIHByZXZfbWF0Y2g7IC8vIHByZXZpb3VzIG1hdGNoXFxyXFxuICAgICAgICB2YXIgbWF0Y2hfYXZhaWxhYmxlOyAvLyBzZXQgaWYgcHJldmlvdXMgbWF0Y2ggZXhpc3RzXFxyXFxuICAgICAgICB2YXIgc3Ryc3RhcnQ7IC8vIHN0YXJ0IG9mIHN0cmluZyB0byBpbnNlcnRcXHJcXG4gICAgICAgIHZhciBtYXRjaF9zdGFydDsgLy8gc3RhcnQgb2YgbWF0Y2hpbmcgc3RyaW5nXFxyXFxuICAgICAgICB2YXIgbG9va2FoZWFkOyAvLyBudW1iZXIgb2YgdmFsaWQgYnl0ZXMgYWhlYWQgaW4gd2luZG93XFxyXFxuXFxyXFxuICAgICAgICAvLyBMZW5ndGggb2YgdGhlIGJlc3QgbWF0Y2ggYXQgcHJldmlvdXMgc3RlcC4gTWF0Y2hlcyBub3QgZ3JlYXRlciB0aGFuIHRoaXNcXHJcXG4gICAgICAgIC8vIGFyZSBkaXNjYXJkZWQuIFRoaXMgaXMgdXNlZCBpbiB0aGUgbGF6eSBtYXRjaCBldmFsdWF0aW9uLlxcclxcbiAgICAgICAgdmFyIHByZXZfbGVuZ3RoO1xcclxcblxcclxcbiAgICAgICAgLy8gVG8gc3BlZWQgdXAgZGVmbGF0aW9uLCBoYXNoIGNoYWlucyBhcmUgbmV2ZXIgc2VhcmNoZWQgYmV5b25kIHRoaXNcXHJcXG4gICAgICAgIC8vIGxlbmd0aC4gQSBoaWdoZXIgbGltaXQgaW1wcm92ZXMgY29tcHJlc3Npb24gcmF0aW8gYnV0IGRlZ3JhZGVzIHRoZSBzcGVlZC5cXHJcXG4gICAgICAgIHZhciBtYXhfY2hhaW5fbGVuZ3RoO1xcclxcblxcclxcbiAgICAgICAgLy8gQXR0ZW1wdCB0byBmaW5kIGEgYmV0dGVyIG1hdGNoIG9ubHkgd2hlbiB0aGUgY3VycmVudCBtYXRjaCBpcyBzdHJpY3RseVxcclxcbiAgICAgICAgLy8gc21hbGxlciB0aGFuIHRoaXMgdmFsdWUuIFRoaXMgbWVjaGFuaXNtIGlzIHVzZWQgb25seSBmb3IgY29tcHJlc3Npb25cXHJcXG4gICAgICAgIC8vIGxldmVscyA+PSA0LlxcclxcbiAgICAgICAgdmFyIG1heF9sYXp5X21hdGNoO1xcclxcblxcclxcbiAgICAgICAgLy8gSW5zZXJ0IG5ldyBzdHJpbmdzIGluIHRoZSBoYXNoIHRhYmxlIG9ubHkgaWYgdGhlIG1hdGNoIGxlbmd0aCBpcyBub3RcXHJcXG4gICAgICAgIC8vIGdyZWF0ZXIgdGhhbiB0aGlzIGxlbmd0aC4gVGhpcyBzYXZlcyB0aW1lIGJ1dCBkZWdyYWRlcyBjb21wcmVzc2lvbi5cXHJcXG4gICAgICAgIC8vIG1heF9pbnNlcnRfbGVuZ3RoIGlzIHVzZWQgb25seSBmb3IgY29tcHJlc3Npb24gbGV2ZWxzIDw9IDMuXFxyXFxuXFxyXFxuICAgICAgICB2YXIgbGV2ZWw7IC8vIGNvbXByZXNzaW9uIGxldmVsICgxLi45KVxcclxcbiAgICAgICAgdmFyIHN0cmF0ZWd5OyAvLyBmYXZvciBvciBmb3JjZSBIdWZmbWFuIGNvZGluZ1xcclxcblxcclxcbiAgICAgICAgLy8gVXNlIGEgZmFzdGVyIHNlYXJjaCB3aGVuIHRoZSBwcmV2aW91cyBtYXRjaCBpcyBsb25nZXIgdGhhbiB0aGlzXFxyXFxuICAgICAgICB2YXIgZ29vZF9tYXRjaDtcXHJcXG5cXHJcXG4gICAgICAgIC8vIFN0b3Agc2VhcmNoaW5nIHdoZW4gY3VycmVudCBtYXRjaCBleGNlZWRzIHRoaXNcXHJcXG4gICAgICAgIHZhciBuaWNlX21hdGNoO1xcclxcblxcclxcbiAgICAgICAgdmFyIGR5bl9sdHJlZTsgLy8gbGl0ZXJhbCBhbmQgbGVuZ3RoIHRyZWVcXHJcXG4gICAgICAgIHZhciBkeW5fZHRyZWU7IC8vIGRpc3RhbmNlIHRyZWVcXHJcXG4gICAgICAgIHZhciBibF90cmVlOyAvLyBIdWZmbWFuIHRyZWUgZm9yIGJpdCBsZW5ndGhzXFxyXFxuXFxyXFxuICAgICAgICB2YXIgbF9kZXNjID0gbmV3IFRyZWUoKTsgLy8gZGVzYyBmb3IgbGl0ZXJhbCB0cmVlXFxyXFxuICAgICAgICB2YXIgZF9kZXNjID0gbmV3IFRyZWUoKTsgLy8gZGVzYyBmb3IgZGlzdGFuY2UgdHJlZVxcclxcbiAgICAgICAgdmFyIGJsX2Rlc2MgPSBuZXcgVHJlZSgpOyAvLyBkZXNjIGZvciBiaXQgbGVuZ3RoIHRyZWVcXHJcXG5cXHJcXG4gICAgICAgIC8vIHRoYXQuaGVhcF9sZW47IC8vIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgaGVhcFxcclxcbiAgICAgICAgLy8gdGhhdC5oZWFwX21heDsgLy8gZWxlbWVudCBvZiBsYXJnZXN0IGZyZXF1ZW5jeVxcclxcbiAgICAgICAgLy8gVGhlIHNvbnMgb2YgaGVhcFtuXSBhcmUgaGVhcFsyKm5dIGFuZCBoZWFwWzIqbisxXS4gaGVhcFswXSBpcyBub3QgdXNlZC5cXHJcXG4gICAgICAgIC8vIFRoZSBzYW1lIGhlYXAgYXJyYXkgaXMgdXNlZCB0byBidWlsZCBhbGwgdHJlZXMuXFxyXFxuXFxyXFxuICAgICAgICAvLyBEZXB0aCBvZiBlYWNoIHN1YnRyZWUgdXNlZCBhcyB0aWUgYnJlYWtlciBmb3IgdHJlZXMgb2YgZXF1YWwgZnJlcXVlbmN5XFxyXFxuICAgICAgICB0aGF0LmRlcHRoID0gW107XFxyXFxuXFxyXFxuICAgICAgICB2YXIgbF9idWY7IC8vIGluZGV4IGZvciBsaXRlcmFscyBvciBsZW5ndGhzICovXFxyXFxuXFxyXFxuICAgICAgICAvLyBTaXplIG9mIG1hdGNoIGJ1ZmZlciBmb3IgbGl0ZXJhbHMvbGVuZ3Rocy4gVGhlcmUgYXJlIDQgcmVhc29ucyBmb3JcXHJcXG4gICAgICAgIC8vIGxpbWl0aW5nIGxpdF9idWZzaXplIHRvIDY0SzpcXHJcXG4gICAgICAgIC8vIC0gZnJlcXVlbmNpZXMgY2FuIGJlIGtlcHQgaW4gMTYgYml0IGNvdW50ZXJzXFxyXFxuICAgICAgICAvLyAtIGlmIGNvbXByZXNzaW9uIGlzIG5vdCBzdWNjZXNzZnVsIGZvciB0aGUgZmlyc3QgYmxvY2ssIGFsbCBpbnB1dFxcclxcbiAgICAgICAgLy8gZGF0YSBpcyBzdGlsbCBpbiB0aGUgd2luZG93IHNvIHdlIGNhbiBzdGlsbCBlbWl0IGEgc3RvcmVkIGJsb2NrIGV2ZW5cXHJcXG4gICAgICAgIC8vIHdoZW4gaW5wdXQgY29tZXMgZnJvbSBzdGFuZGFyZCBpbnB1dC4gKFRoaXMgY2FuIGFsc28gYmUgZG9uZSBmb3JcXHJcXG4gICAgICAgIC8vIGFsbCBibG9ja3MgaWYgbGl0X2J1ZnNpemUgaXMgbm90IGdyZWF0ZXIgdGhhbiAzMksuKVxcclxcbiAgICAgICAgLy8gLSBpZiBjb21wcmVzc2lvbiBpcyBub3Qgc3VjY2Vzc2Z1bCBmb3IgYSBmaWxlIHNtYWxsZXIgdGhhbiA2NEssIHdlIGNhblxcclxcbiAgICAgICAgLy8gZXZlbiBlbWl0IGEgc3RvcmVkIGZpbGUgaW5zdGVhZCBvZiBhIHN0b3JlZCBibG9jayAoc2F2aW5nIDUgYnl0ZXMpLlxcclxcbiAgICAgICAgLy8gVGhpcyBpcyBhcHBsaWNhYmxlIG9ubHkgZm9yIHppcCAobm90IGd6aXAgb3IgemxpYikuXFxyXFxuICAgICAgICAvLyAtIGNyZWF0aW5nIG5ldyBIdWZmbWFuIHRyZWVzIGxlc3MgZnJlcXVlbnRseSBtYXkgbm90IHByb3ZpZGUgZmFzdFxcclxcbiAgICAgICAgLy8gYWRhcHRhdGlvbiB0byBjaGFuZ2VzIGluIHRoZSBpbnB1dCBkYXRhIHN0YXRpc3RpY3MuIChUYWtlIGZvclxcclxcbiAgICAgICAgLy8gZXhhbXBsZSBhIGJpbmFyeSBmaWxlIHdpdGggcG9vcmx5IGNvbXByZXNzaWJsZSBjb2RlIGZvbGxvd2VkIGJ5XFxyXFxuICAgICAgICAvLyBhIGhpZ2hseSBjb21wcmVzc2libGUgc3RyaW5nIHRhYmxlLikgU21hbGxlciBidWZmZXIgc2l6ZXMgZ2l2ZVxcclxcbiAgICAgICAgLy8gZmFzdCBhZGFwdGF0aW9uIGJ1dCBoYXZlIG9mIGNvdXJzZSB0aGUgb3ZlcmhlYWQgb2YgdHJhbnNtaXR0aW5nXFxyXFxuICAgICAgICAvLyB0cmVlcyBtb3JlIGZyZXF1ZW50bHkuXFxyXFxuICAgICAgICAvLyAtIEkgY2FuJ3QgY291bnQgYWJvdmUgNFxcclxcbiAgICAgICAgdmFyIGxpdF9idWZzaXplO1xcclxcblxcclxcbiAgICAgICAgdmFyIGxhc3RfbGl0OyAvLyBydW5uaW5nIGluZGV4IGluIGxfYnVmXFxyXFxuXFxyXFxuICAgICAgICAvLyBCdWZmZXIgZm9yIGRpc3RhbmNlcy4gVG8gc2ltcGxpZnkgdGhlIGNvZGUsIGRfYnVmIGFuZCBsX2J1ZiBoYXZlXFxyXFxuICAgICAgICAvLyB0aGUgc2FtZSBudW1iZXIgb2YgZWxlbWVudHMuIFRvIHVzZSBkaWZmZXJlbnQgbGVuZ3RocywgYW4gZXh0cmEgZmxhZ1xcclxcbiAgICAgICAgLy8gYXJyYXkgd291bGQgYmUgbmVjZXNzYXJ5LlxcclxcblxcclxcbiAgICAgICAgdmFyIGRfYnVmOyAvLyBpbmRleCBvZiBwZW5kaWdfYnVmXFxyXFxuXFxyXFxuICAgICAgICAvLyB0aGF0Lm9wdF9sZW47IC8vIGJpdCBsZW5ndGggb2YgY3VycmVudCBibG9jayB3aXRoIG9wdGltYWwgdHJlZXNcXHJcXG4gICAgICAgIC8vIHRoYXQuc3RhdGljX2xlbjsgLy8gYml0IGxlbmd0aCBvZiBjdXJyZW50IGJsb2NrIHdpdGggc3RhdGljIHRyZWVzXFxyXFxuICAgICAgICB2YXIgbWF0Y2hlczsgLy8gbnVtYmVyIG9mIHN0cmluZyBtYXRjaGVzIGluIGN1cnJlbnQgYmxvY2tcXHJcXG4gICAgICAgIHZhciBsYXN0X2VvYl9sZW47IC8vIGJpdCBsZW5ndGggb2YgRU9CIGNvZGUgZm9yIGxhc3QgYmxvY2tcXHJcXG5cXHJcXG4gICAgICAgIC8vIE91dHB1dCBidWZmZXIuIGJpdHMgYXJlIGluc2VydGVkIHN0YXJ0aW5nIGF0IHRoZSBib3R0b20gKGxlYXN0XFxyXFxuICAgICAgICAvLyBzaWduaWZpY2FudCBiaXRzKS5cXHJcXG4gICAgICAgIHZhciBiaV9idWY7XFxyXFxuXFxyXFxuICAgICAgICAvLyBOdW1iZXIgb2YgdmFsaWQgYml0cyBpbiBiaV9idWYuIEFsbCBiaXRzIGFib3ZlIHRoZSBsYXN0IHZhbGlkIGJpdFxcclxcbiAgICAgICAgLy8gYXJlIGFsd2F5cyB6ZXJvLlxcclxcbiAgICAgICAgdmFyIGJpX3ZhbGlkO1xcclxcblxcclxcbiAgICAgICAgLy8gbnVtYmVyIG9mIGNvZGVzIGF0IGVhY2ggYml0IGxlbmd0aCBmb3IgYW4gb3B0aW1hbCB0cmVlXFxyXFxuICAgICAgICB0aGF0LmJsX2NvdW50ID0gW107XFxyXFxuXFxyXFxuICAgICAgICAvLyBoZWFwIHVzZWQgdG8gYnVpbGQgdGhlIEh1ZmZtYW4gdHJlZXNcXHJcXG4gICAgICAgIHRoYXQuaGVhcCA9IFtdO1xcclxcblxcclxcbiAgICAgICAgZHluX2x0cmVlID0gW107XFxyXFxuICAgICAgICBkeW5fZHRyZWUgPSBbXTtcXHJcXG4gICAgICAgIGJsX3RyZWUgPSBbXTtcXHJcXG5cXHJcXG4gICAgICAgIGZ1bmN0aW9uIGxtX2luaXQoKSB7XFxyXFxuICAgICAgICAgICAgdmFyIGk7XFxyXFxuICAgICAgICAgICAgd2luZG93X3NpemUgPSAyICogd19zaXplO1xcclxcblxcclxcbiAgICAgICAgICAgIGhlYWRbaGFzaF9zaXplIC0gMV0gPSAwO1xcclxcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBoYXNoX3NpemUgLSAxOyBpKyspIHtcXHJcXG4gICAgICAgICAgICAgICAgaGVhZFtpXSA9IDA7XFxyXFxuICAgICAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgICAgIC8vIFNldCB0aGUgZGVmYXVsdCBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnM6XFxyXFxuICAgICAgICAgICAgbWF4X2xhenlfbWF0Y2ggPSBjb25maWdfdGFibGVbbGV2ZWxdLm1heF9sYXp5O1xcclxcbiAgICAgICAgICAgIGdvb2RfbWF0Y2ggPSBjb25maWdfdGFibGVbbGV2ZWxdLmdvb2RfbGVuZ3RoO1xcclxcbiAgICAgICAgICAgIG5pY2VfbWF0Y2ggPSBjb25maWdfdGFibGVbbGV2ZWxdLm5pY2VfbGVuZ3RoO1xcclxcbiAgICAgICAgICAgIG1heF9jaGFpbl9sZW5ndGggPSBjb25maWdfdGFibGVbbGV2ZWxdLm1heF9jaGFpbjtcXHJcXG5cXHJcXG4gICAgICAgICAgICBzdHJzdGFydCA9IDA7XFxyXFxuICAgICAgICAgICAgYmxvY2tfc3RhcnQgPSAwO1xcclxcbiAgICAgICAgICAgIGxvb2thaGVhZCA9IDA7XFxyXFxuICAgICAgICAgICAgbWF0Y2hfbGVuZ3RoID0gcHJldl9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xcclxcbiAgICAgICAgICAgIG1hdGNoX2F2YWlsYWJsZSA9IDA7XFxyXFxuICAgICAgICAgICAgaW5zX2ggPSAwO1xcclxcbiAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgZnVuY3Rpb24gaW5pdF9ibG9jaygpIHtcXHJcXG4gICAgICAgICAgICB2YXIgaTtcXHJcXG4gICAgICAgICAgICAvLyBJbml0aWFsaXplIHRoZSB0cmVlcy5cXHJcXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgTF9DT0RFUzsgaSsrKVxcclxcbiAgICAgICAgICAgICAgICBkeW5fbHRyZWVbaSAqIDJdID0gMDtcXHJcXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgRF9DT0RFUzsgaSsrKVxcclxcbiAgICAgICAgICAgICAgICBkeW5fZHRyZWVbaSAqIDJdID0gMDtcXHJcXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgQkxfQ09ERVM7IGkrKylcXHJcXG4gICAgICAgICAgICAgICAgYmxfdHJlZVtpICogMl0gPSAwO1xcclxcblxcclxcbiAgICAgICAgICAgIGR5bl9sdHJlZVtFTkRfQkxPQ0sgKiAyXSA9IDE7XFxyXFxuICAgICAgICAgICAgdGhhdC5vcHRfbGVuID0gdGhhdC5zdGF0aWNfbGVuID0gMDtcXHJcXG4gICAgICAgICAgICBsYXN0X2xpdCA9IG1hdGNoZXMgPSAwO1xcclxcbiAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgdHJlZSBkYXRhIHN0cnVjdHVyZXMgZm9yIGEgbmV3IHpsaWIgc3RyZWFtLlxcclxcbiAgICAgICAgZnVuY3Rpb24gdHJfaW5pdCgpIHtcXHJcXG5cXHJcXG4gICAgICAgICAgICBsX2Rlc2MuZHluX3RyZWUgPSBkeW5fbHRyZWU7XFxyXFxuICAgICAgICAgICAgbF9kZXNjLnN0YXRfZGVzYyA9IFN0YXRpY1RyZWUuc3RhdGljX2xfZGVzYztcXHJcXG5cXHJcXG4gICAgICAgICAgICBkX2Rlc2MuZHluX3RyZWUgPSBkeW5fZHRyZWU7XFxyXFxuICAgICAgICAgICAgZF9kZXNjLnN0YXRfZGVzYyA9IFN0YXRpY1RyZWUuc3RhdGljX2RfZGVzYztcXHJcXG5cXHJcXG4gICAgICAgICAgICBibF9kZXNjLmR5bl90cmVlID0gYmxfdHJlZTtcXHJcXG4gICAgICAgICAgICBibF9kZXNjLnN0YXRfZGVzYyA9IFN0YXRpY1RyZWUuc3RhdGljX2JsX2Rlc2M7XFxyXFxuXFxyXFxuICAgICAgICAgICAgYmlfYnVmID0gMDtcXHJcXG4gICAgICAgICAgICBiaV92YWxpZCA9IDA7XFxyXFxuICAgICAgICAgICAgbGFzdF9lb2JfbGVuID0gODsgLy8gZW5vdWdoIGxvb2thaGVhZCBmb3IgaW5mbGF0ZVxcclxcblxcclxcbiAgICAgICAgICAgIC8vIEluaXRpYWxpemUgdGhlIGZpcnN0IGJsb2NrIG9mIHRoZSBmaXJzdCBmaWxlOlxcclxcbiAgICAgICAgICAgIGluaXRfYmxvY2soKTtcXHJcXG4gICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgIC8vIFJlc3RvcmUgdGhlIGhlYXAgcHJvcGVydHkgYnkgbW92aW5nIGRvd24gdGhlIHRyZWUgc3RhcnRpbmcgYXQgbm9kZSBrLFxcclxcbiAgICAgICAgLy8gZXhjaGFuZ2luZyBhIG5vZGUgd2l0aCB0aGUgc21hbGxlc3Qgb2YgaXRzIHR3byBzb25zIGlmIG5lY2Vzc2FyeSxcXHJcXG4gICAgICAgIC8vIHN0b3BwaW5nXFxyXFxuICAgICAgICAvLyB3aGVuIHRoZSBoZWFwIHByb3BlcnR5IGlzIHJlLWVzdGFibGlzaGVkIChlYWNoIGZhdGhlciBzbWFsbGVyIHRoYW4gaXRzXFxyXFxuICAgICAgICAvLyB0d28gc29ucykuXFxyXFxuICAgICAgICB0aGF0LnBxZG93bmhlYXAgPSBmdW5jdGlvbih0cmVlLCAvLyB0aGUgdHJlZSB0byByZXN0b3JlXFxyXFxuICAgICAgICBrIC8vIG5vZGUgdG8gbW92ZSBkb3duXFxyXFxuICAgICAgICApIHtcXHJcXG4gICAgICAgICAgICB2YXIgaGVhcCA9IHRoYXQuaGVhcDtcXHJcXG4gICAgICAgICAgICB2YXIgdiA9IGhlYXBba107XFxyXFxuICAgICAgICAgICAgdmFyIGogPSBrIDw8IDE7IC8vIGxlZnQgc29uIG9mIGtcXHJcXG4gICAgICAgICAgICB3aGlsZSAoaiA8PSB0aGF0LmhlYXBfbGVuKSB7XFxyXFxuICAgICAgICAgICAgICAgIC8vIFNldCBqIHRvIHRoZSBzbWFsbGVzdCBvZiB0aGUgdHdvIHNvbnM6XFxyXFxuICAgICAgICAgICAgICAgIGlmIChqIDwgdGhhdC5oZWFwX2xlbiAmJiBzbWFsbGVyKHRyZWUsIGhlYXBbaiArIDFdLCBoZWFwW2pdLCB0aGF0LmRlcHRoKSkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgaisrO1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgIC8vIEV4aXQgaWYgdiBpcyBzbWFsbGVyIHRoYW4gYm90aCBzb25zXFxyXFxuICAgICAgICAgICAgICAgIGlmIChzbWFsbGVyKHRyZWUsIHYsIGhlYXBbal0sIHRoYXQuZGVwdGgpKVxcclxcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgIC8vIEV4Y2hhbmdlIHYgd2l0aCB0aGUgc21hbGxlc3Qgc29uXFxyXFxuICAgICAgICAgICAgICAgIGhlYXBba10gPSBoZWFwW2pdO1xcclxcbiAgICAgICAgICAgICAgICBrID0gajtcXHJcXG4gICAgICAgICAgICAgICAgLy8gQW5kIGNvbnRpbnVlIGRvd24gdGhlIHRyZWUsIHNldHRpbmcgaiB0byB0aGUgbGVmdCBzb24gb2Yga1xcclxcbiAgICAgICAgICAgICAgICBqIDw8PSAxO1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICBoZWFwW2tdID0gdjtcXHJcXG4gICAgICAgIH07XFxyXFxuXFxyXFxuICAgICAgICAvLyBTY2FuIGEgbGl0ZXJhbCBvciBkaXN0YW5jZSB0cmVlIHRvIGRldGVybWluZSB0aGUgZnJlcXVlbmNpZXMgb2YgdGhlIGNvZGVzXFxyXFxuICAgICAgICAvLyBpbiB0aGUgYml0IGxlbmd0aCB0cmVlLlxcclxcbiAgICAgICAgZnVuY3Rpb24gc2Nhbl90cmVlKHRyZWUsLy8gdGhlIHRyZWUgdG8gYmUgc2Nhbm5lZFxcclxcbiAgICAgICAgbWF4X2NvZGUgLy8gYW5kIGl0cyBsYXJnZXN0IGNvZGUgb2Ygbm9uIHplcm8gZnJlcXVlbmN5XFxyXFxuICAgICAgICApIHtcXHJcXG4gICAgICAgICAgICB2YXIgbjsgLy8gaXRlcmF0ZXMgb3ZlciBhbGwgdHJlZSBlbGVtZW50c1xcclxcbiAgICAgICAgICAgIHZhciBwcmV2bGVuID0gLTE7IC8vIGxhc3QgZW1pdHRlZCBsZW5ndGhcXHJcXG4gICAgICAgICAgICB2YXIgY3VybGVuOyAvLyBsZW5ndGggb2YgY3VycmVudCBjb2RlXFxyXFxuICAgICAgICAgICAgdmFyIG5leHRsZW4gPSB0cmVlWzAgKiAyICsgMV07IC8vIGxlbmd0aCBvZiBuZXh0IGNvZGVcXHJcXG4gICAgICAgICAgICB2YXIgY291bnQgPSAwOyAvLyByZXBlYXQgY291bnQgb2YgdGhlIGN1cnJlbnQgY29kZVxcclxcbiAgICAgICAgICAgIHZhciBtYXhfY291bnQgPSA3OyAvLyBtYXggcmVwZWF0IGNvdW50XFxyXFxuICAgICAgICAgICAgdmFyIG1pbl9jb3VudCA9IDQ7IC8vIG1pbiByZXBlYXQgY291bnRcXHJcXG5cXHJcXG4gICAgICAgICAgICBpZiAobmV4dGxlbiA9PT0gMCkge1xcclxcbiAgICAgICAgICAgICAgICBtYXhfY291bnQgPSAxMzg7XFxyXFxuICAgICAgICAgICAgICAgIG1pbl9jb3VudCA9IDM7XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIHRyZWVbKG1heF9jb2RlICsgMSkgKiAyICsgMV0gPSAweGZmZmY7IC8vIGd1YXJkXFxyXFxuXFxyXFxuICAgICAgICAgICAgZm9yIChuID0gMDsgbiA8PSBtYXhfY29kZTsgbisrKSB7XFxyXFxuICAgICAgICAgICAgICAgIGN1cmxlbiA9IG5leHRsZW47XFxyXFxuICAgICAgICAgICAgICAgIG5leHRsZW4gPSB0cmVlWyhuICsgMSkgKiAyICsgMV07XFxyXFxuICAgICAgICAgICAgICAgIGlmICgrK2NvdW50IDwgbWF4X2NvdW50ICYmIGN1cmxlbiA9PSBuZXh0bGVuKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcXHJcXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb3VudCA8IG1pbl9jb3VudCkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgYmxfdHJlZVtjdXJsZW4gKiAyXSArPSBjb3VudDtcXHJcXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJsZW4gIT09IDApIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJsZW4gIT0gcHJldmxlbilcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBibF90cmVlW2N1cmxlbiAqIDJdKys7XFxyXFxuICAgICAgICAgICAgICAgICAgICBibF90cmVlW1JFUF8zXzYgKiAyXSsrO1xcclxcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvdW50IDw9IDEwKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICBibF90cmVlW1JFUFpfM18xMCAqIDJdKys7XFxyXFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICBibF90cmVlW1JFUFpfMTFfMTM4ICogMl0rKztcXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICBjb3VudCA9IDA7XFxyXFxuICAgICAgICAgICAgICAgIHByZXZsZW4gPSBjdXJsZW47XFxyXFxuICAgICAgICAgICAgICAgIGlmIChuZXh0bGVuID09PSAwKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICBtYXhfY291bnQgPSAxMzg7XFxyXFxuICAgICAgICAgICAgICAgICAgICBtaW5fY291bnQgPSAzO1xcclxcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGN1cmxlbiA9PSBuZXh0bGVuKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICBtYXhfY291bnQgPSA2O1xcclxcbiAgICAgICAgICAgICAgICAgICAgbWluX2NvdW50ID0gMztcXHJcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIG1heF9jb3VudCA9IDc7XFxyXFxuICAgICAgICAgICAgICAgICAgICBtaW5fY291bnQgPSA0O1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgLy8gQ29uc3RydWN0IHRoZSBIdWZmbWFuIHRyZWUgZm9yIHRoZSBiaXQgbGVuZ3RocyBhbmQgcmV0dXJuIHRoZSBpbmRleCBpblxcclxcbiAgICAgICAgLy8gYmxfb3JkZXIgb2YgdGhlIGxhc3QgYml0IGxlbmd0aCBjb2RlIHRvIHNlbmQuXFxyXFxuICAgICAgICBmdW5jdGlvbiBidWlsZF9ibF90cmVlKCkge1xcclxcbiAgICAgICAgICAgIHZhciBtYXhfYmxpbmRleDsgLy8gaW5kZXggb2YgbGFzdCBiaXQgbGVuZ3RoIGNvZGUgb2Ygbm9uIHplcm8gZnJlcVxcclxcblxcclxcbiAgICAgICAgICAgIC8vIERldGVybWluZSB0aGUgYml0IGxlbmd0aCBmcmVxdWVuY2llcyBmb3IgbGl0ZXJhbCBhbmQgZGlzdGFuY2UgdHJlZXNcXHJcXG4gICAgICAgICAgICBzY2FuX3RyZWUoZHluX2x0cmVlLCBsX2Rlc2MubWF4X2NvZGUpO1xcclxcbiAgICAgICAgICAgIHNjYW5fdHJlZShkeW5fZHRyZWUsIGRfZGVzYy5tYXhfY29kZSk7XFxyXFxuXFxyXFxuICAgICAgICAgICAgLy8gQnVpbGQgdGhlIGJpdCBsZW5ndGggdHJlZTpcXHJcXG4gICAgICAgICAgICBibF9kZXNjLmJ1aWxkX3RyZWUodGhhdCk7XFxyXFxuICAgICAgICAgICAgLy8gb3B0X2xlbiBub3cgaW5jbHVkZXMgdGhlIGxlbmd0aCBvZiB0aGUgdHJlZSByZXByZXNlbnRhdGlvbnMsIGV4Y2VwdFxcclxcbiAgICAgICAgICAgIC8vIHRoZSBsZW5ndGhzIG9mIHRoZSBiaXQgbGVuZ3RocyBjb2RlcyBhbmQgdGhlIDUrNSs0IGJpdHMgZm9yIHRoZVxcclxcbiAgICAgICAgICAgIC8vIGNvdW50cy5cXHJcXG5cXHJcXG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIG51bWJlciBvZiBiaXQgbGVuZ3RoIGNvZGVzIHRvIHNlbmQuIFRoZSBwa3ppcCBmb3JtYXRcXHJcXG4gICAgICAgICAgICAvLyByZXF1aXJlcyB0aGF0IGF0IGxlYXN0IDQgYml0IGxlbmd0aCBjb2RlcyBiZSBzZW50LiAoYXBwbm90ZS50eHQgc2F5c1xcclxcbiAgICAgICAgICAgIC8vIDMgYnV0IHRoZSBhY3R1YWwgdmFsdWUgdXNlZCBpcyA0LilcXHJcXG4gICAgICAgICAgICBmb3IgKG1heF9ibGluZGV4ID0gQkxfQ09ERVMgLSAxOyBtYXhfYmxpbmRleCA+PSAzOyBtYXhfYmxpbmRleC0tKSB7XFxyXFxuICAgICAgICAgICAgICAgIGlmIChibF90cmVlW1RyZWUuYmxfb3JkZXJbbWF4X2JsaW5kZXhdICogMiArIDFdICE9PSAwKVxcclxcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBvcHRfbGVuIHRvIGluY2x1ZGUgdGhlIGJpdCBsZW5ndGggdHJlZSBhbmQgY291bnRzXFxyXFxuICAgICAgICAgICAgdGhhdC5vcHRfbGVuICs9IDMgKiAobWF4X2JsaW5kZXggKyAxKSArIDUgKyA1ICsgNDtcXHJcXG5cXHJcXG4gICAgICAgICAgICByZXR1cm4gbWF4X2JsaW5kZXg7XFxyXFxuICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAvLyBPdXRwdXQgYSBieXRlIG9uIHRoZSBzdHJlYW0uXFxyXFxuICAgICAgICAvLyBJTiBhc3NlcnRpb246IHRoZXJlIGlzIGVub3VnaCByb29tIGluIHBlbmRpbmdfYnVmLlxcclxcbiAgICAgICAgZnVuY3Rpb24gcHV0X2J5dGUocCkge1xcclxcbiAgICAgICAgICAgIHRoYXQucGVuZGluZ19idWZbdGhhdC5wZW5kaW5nKytdID0gcDtcXHJcXG4gICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgIGZ1bmN0aW9uIHB1dF9zaG9ydCh3KSB7XFxyXFxuICAgICAgICAgICAgcHV0X2J5dGUodyAmIDB4ZmYpO1xcclxcbiAgICAgICAgICAgIHB1dF9ieXRlKCh3ID4+PiA4KSAmIDB4ZmYpO1xcclxcbiAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgZnVuY3Rpb24gcHV0U2hvcnRNU0IoYikge1xcclxcbiAgICAgICAgICAgIHB1dF9ieXRlKChiID4+IDgpICYgMHhmZik7XFxyXFxuICAgICAgICAgICAgcHV0X2J5dGUoKGIgJiAweGZmKSAmIDB4ZmYpO1xcclxcbiAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgZnVuY3Rpb24gc2VuZF9iaXRzKHZhbHVlLCBsZW5ndGgpIHtcXHJcXG4gICAgICAgICAgICB2YXIgdmFsLCBsZW4gPSBsZW5ndGg7XFxyXFxuICAgICAgICAgICAgaWYgKGJpX3ZhbGlkID4gQnVmX3NpemUgLSBsZW4pIHtcXHJcXG4gICAgICAgICAgICAgICAgdmFsID0gdmFsdWU7XFxyXFxuICAgICAgICAgICAgICAgIC8vIGJpX2J1ZiB8PSAodmFsIDw8IGJpX3ZhbGlkKTtcXHJcXG4gICAgICAgICAgICAgICAgYmlfYnVmIHw9ICgodmFsIDw8IGJpX3ZhbGlkKSAmIDB4ZmZmZik7XFxyXFxuICAgICAgICAgICAgICAgIHB1dF9zaG9ydChiaV9idWYpO1xcclxcbiAgICAgICAgICAgICAgICBiaV9idWYgPSB2YWwgPj4+IChCdWZfc2l6ZSAtIGJpX3ZhbGlkKTtcXHJcXG4gICAgICAgICAgICAgICAgYmlfdmFsaWQgKz0gbGVuIC0gQnVmX3NpemU7XFxyXFxuICAgICAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgICAgICAgLy8gYmlfYnVmIHw9ICh2YWx1ZSkgPDwgYmlfdmFsaWQ7XFxyXFxuICAgICAgICAgICAgICAgIGJpX2J1ZiB8PSAoKCh2YWx1ZSkgPDwgYmlfdmFsaWQpICYgMHhmZmZmKTtcXHJcXG4gICAgICAgICAgICAgICAgYmlfdmFsaWQgKz0gbGVuO1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgIGZ1bmN0aW9uIHNlbmRfY29kZShjLCB0cmVlKSB7XFxyXFxuICAgICAgICAgICAgdmFyIGMyID0gYyAqIDI7XFxyXFxuICAgICAgICAgICAgc2VuZF9iaXRzKHRyZWVbYzJdICYgMHhmZmZmLCB0cmVlW2MyICsgMV0gJiAweGZmZmYpO1xcclxcbiAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgLy8gU2VuZCBhIGxpdGVyYWwgb3IgZGlzdGFuY2UgdHJlZSBpbiBjb21wcmVzc2VkIGZvcm0sIHVzaW5nIHRoZSBjb2RlcyBpblxcclxcbiAgICAgICAgLy8gYmxfdHJlZS5cXHJcXG4gICAgICAgIGZ1bmN0aW9uIHNlbmRfdHJlZSh0cmVlLC8vIHRoZSB0cmVlIHRvIGJlIHNlbnRcXHJcXG4gICAgICAgIG1heF9jb2RlIC8vIGFuZCBpdHMgbGFyZ2VzdCBjb2RlIG9mIG5vbiB6ZXJvIGZyZXF1ZW5jeVxcclxcbiAgICAgICAgKSB7XFxyXFxuICAgICAgICAgICAgdmFyIG47IC8vIGl0ZXJhdGVzIG92ZXIgYWxsIHRyZWUgZWxlbWVudHNcXHJcXG4gICAgICAgICAgICB2YXIgcHJldmxlbiA9IC0xOyAvLyBsYXN0IGVtaXR0ZWQgbGVuZ3RoXFxyXFxuICAgICAgICAgICAgdmFyIGN1cmxlbjsgLy8gbGVuZ3RoIG9mIGN1cnJlbnQgY29kZVxcclxcbiAgICAgICAgICAgIHZhciBuZXh0bGVuID0gdHJlZVswICogMiArIDFdOyAvLyBsZW5ndGggb2YgbmV4dCBjb2RlXFxyXFxuICAgICAgICAgICAgdmFyIGNvdW50ID0gMDsgLy8gcmVwZWF0IGNvdW50IG9mIHRoZSBjdXJyZW50IGNvZGVcXHJcXG4gICAgICAgICAgICB2YXIgbWF4X2NvdW50ID0gNzsgLy8gbWF4IHJlcGVhdCBjb3VudFxcclxcbiAgICAgICAgICAgIHZhciBtaW5fY291bnQgPSA0OyAvLyBtaW4gcmVwZWF0IGNvdW50XFxyXFxuXFxyXFxuICAgICAgICAgICAgaWYgKG5leHRsZW4gPT09IDApIHtcXHJcXG4gICAgICAgICAgICAgICAgbWF4X2NvdW50ID0gMTM4O1xcclxcbiAgICAgICAgICAgICAgICBtaW5fY291bnQgPSAzO1xcclxcbiAgICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICBmb3IgKG4gPSAwOyBuIDw9IG1heF9jb2RlOyBuKyspIHtcXHJcXG4gICAgICAgICAgICAgICAgY3VybGVuID0gbmV4dGxlbjtcXHJcXG4gICAgICAgICAgICAgICAgbmV4dGxlbiA9IHRyZWVbKG4gKyAxKSAqIDIgKyAxXTtcXHJcXG4gICAgICAgICAgICAgICAgaWYgKCsrY291bnQgPCBtYXhfY291bnQgJiYgY3VybGVuID09IG5leHRsZW4pIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcclxcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvdW50IDwgbWluX2NvdW50KSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICBkbyB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VuZF9jb2RlKGN1cmxlbiwgYmxfdHJlZSk7XFxyXFxuICAgICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLWNvdW50ICE9PSAwKTtcXHJcXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJsZW4gIT09IDApIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJsZW4gIT0gcHJldmxlbikge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbmRfY29kZShjdXJsZW4sIGJsX3RyZWUpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50LS07XFxyXFxuICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgICAgICBzZW5kX2NvZGUoUkVQXzNfNiwgYmxfdHJlZSk7XFxyXFxuICAgICAgICAgICAgICAgICAgICBzZW5kX2JpdHMoY291bnQgLSAzLCAyKTtcXHJcXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb3VudCA8PSAxMCkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgc2VuZF9jb2RlKFJFUFpfM18xMCwgYmxfdHJlZSk7XFxyXFxuICAgICAgICAgICAgICAgICAgICBzZW5kX2JpdHMoY291bnQgLSAzLCAzKTtcXHJcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHNlbmRfY29kZShSRVBaXzExXzEzOCwgYmxfdHJlZSk7XFxyXFxuICAgICAgICAgICAgICAgICAgICBzZW5kX2JpdHMoY291bnQgLSAxMSwgNyk7XFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgY291bnQgPSAwO1xcclxcbiAgICAgICAgICAgICAgICBwcmV2bGVuID0gY3VybGVuO1xcclxcbiAgICAgICAgICAgICAgICBpZiAobmV4dGxlbiA9PT0gMCkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgbWF4X2NvdW50ID0gMTM4O1xcclxcbiAgICAgICAgICAgICAgICAgICAgbWluX2NvdW50ID0gMztcXHJcXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJsZW4gPT0gbmV4dGxlbikge1xcclxcbiAgICAgICAgICAgICAgICAgICAgbWF4X2NvdW50ID0gNjtcXHJcXG4gICAgICAgICAgICAgICAgICAgIG1pbl9jb3VudCA9IDM7XFxyXFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICBtYXhfY291bnQgPSA3O1xcclxcbiAgICAgICAgICAgICAgICAgICAgbWluX2NvdW50ID0gNDtcXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgIC8vIFNlbmQgdGhlIGhlYWRlciBmb3IgYSBibG9jayB1c2luZyBkeW5hbWljIEh1ZmZtYW4gdHJlZXM6IHRoZSBjb3VudHMsIHRoZVxcclxcbiAgICAgICAgLy8gbGVuZ3RocyBvZiB0aGUgYml0IGxlbmd0aCBjb2RlcywgdGhlIGxpdGVyYWwgdHJlZSBhbmQgdGhlIGRpc3RhbmNlIHRyZWUuXFxyXFxuICAgICAgICAvLyBJTiBhc3NlcnRpb246IGxjb2RlcyA+PSAyNTcsIGRjb2RlcyA+PSAxLCBibGNvZGVzID49IDQuXFxyXFxuICAgICAgICBmdW5jdGlvbiBzZW5kX2FsbF90cmVlcyhsY29kZXMsIGRjb2RlcywgYmxjb2Rlcykge1xcclxcbiAgICAgICAgICAgIHZhciByYW5rOyAvLyBpbmRleCBpbiBibF9vcmRlclxcclxcblxcclxcbiAgICAgICAgICAgIHNlbmRfYml0cyhsY29kZXMgLSAyNTcsIDUpOyAvLyBub3QgKzI1NSBhcyBzdGF0ZWQgaW4gYXBwbm90ZS50eHRcXHJcXG4gICAgICAgICAgICBzZW5kX2JpdHMoZGNvZGVzIC0gMSwgNSk7XFxyXFxuICAgICAgICAgICAgc2VuZF9iaXRzKGJsY29kZXMgLSA0LCA0KTsgLy8gbm90IC0zIGFzIHN0YXRlZCBpbiBhcHBub3RlLnR4dFxcclxcbiAgICAgICAgICAgIGZvciAocmFuayA9IDA7IHJhbmsgPCBibGNvZGVzOyByYW5rKyspIHtcXHJcXG4gICAgICAgICAgICAgICAgc2VuZF9iaXRzKGJsX3RyZWVbVHJlZS5ibF9vcmRlcltyYW5rXSAqIDIgKyAxXSwgMyk7XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIHNlbmRfdHJlZShkeW5fbHRyZWUsIGxjb2RlcyAtIDEpOyAvLyBsaXRlcmFsIHRyZWVcXHJcXG4gICAgICAgICAgICBzZW5kX3RyZWUoZHluX2R0cmVlLCBkY29kZXMgLSAxKTsgLy8gZGlzdGFuY2UgdHJlZVxcclxcbiAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgLy8gRmx1c2ggdGhlIGJpdCBidWZmZXIsIGtlZXBpbmcgYXQgbW9zdCA3IGJpdHMgaW4gaXQuXFxyXFxuICAgICAgICBmdW5jdGlvbiBiaV9mbHVzaCgpIHtcXHJcXG4gICAgICAgICAgICBpZiAoYmlfdmFsaWQgPT0gMTYpIHtcXHJcXG4gICAgICAgICAgICAgICAgcHV0X3Nob3J0KGJpX2J1Zik7XFxyXFxuICAgICAgICAgICAgICAgIGJpX2J1ZiA9IDA7XFxyXFxuICAgICAgICAgICAgICAgIGJpX3ZhbGlkID0gMDtcXHJcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGJpX3ZhbGlkID49IDgpIHtcXHJcXG4gICAgICAgICAgICAgICAgcHV0X2J5dGUoYmlfYnVmICYgMHhmZik7XFxyXFxuICAgICAgICAgICAgICAgIGJpX2J1ZiA+Pj49IDg7XFxyXFxuICAgICAgICAgICAgICAgIGJpX3ZhbGlkIC09IDg7XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgLy8gU2VuZCBvbmUgZW1wdHkgc3RhdGljIGJsb2NrIHRvIGdpdmUgZW5vdWdoIGxvb2thaGVhZCBmb3IgaW5mbGF0ZS5cXHJcXG4gICAgICAgIC8vIFRoaXMgdGFrZXMgMTAgYml0cywgb2Ygd2hpY2ggNyBtYXkgcmVtYWluIGluIHRoZSBiaXQgYnVmZmVyLlxcclxcbiAgICAgICAgLy8gVGhlIGN1cnJlbnQgaW5mbGF0ZSBjb2RlIHJlcXVpcmVzIDkgYml0cyBvZiBsb29rYWhlYWQuIElmIHRoZVxcclxcbiAgICAgICAgLy8gbGFzdCB0d28gY29kZXMgZm9yIHRoZSBwcmV2aW91cyBibG9jayAocmVhbCBjb2RlIHBsdXMgRU9CKSB3ZXJlIGNvZGVkXFxyXFxuICAgICAgICAvLyBvbiA1IGJpdHMgb3IgbGVzcywgaW5mbGF0ZSBtYXkgaGF2ZSBvbmx5IDUrMyBiaXRzIG9mIGxvb2thaGVhZCB0byBkZWNvZGVcXHJcXG4gICAgICAgIC8vIHRoZSBsYXN0IHJlYWwgY29kZS4gSW4gdGhpcyBjYXNlIHdlIHNlbmQgdHdvIGVtcHR5IHN0YXRpYyBibG9ja3MgaW5zdGVhZFxcclxcbiAgICAgICAgLy8gb2Ygb25lLiAoVGhlcmUgYXJlIG5vIHByb2JsZW1zIGlmIHRoZSBwcmV2aW91cyBibG9jayBpcyBzdG9yZWQgb3IgZml4ZWQuKVxcclxcbiAgICAgICAgLy8gVG8gc2ltcGxpZnkgdGhlIGNvZGUsIHdlIGFzc3VtZSB0aGUgd29yc3QgY2FzZSBvZiBsYXN0IHJlYWwgY29kZSBlbmNvZGVkXFxyXFxuICAgICAgICAvLyBvbiBvbmUgYml0IG9ubHkuXFxyXFxuICAgICAgICBmdW5jdGlvbiBfdHJfYWxpZ24oKSB7XFxyXFxuICAgICAgICAgICAgc2VuZF9iaXRzKFNUQVRJQ19UUkVFUyA8PCAxLCAzKTtcXHJcXG4gICAgICAgICAgICBzZW5kX2NvZGUoRU5EX0JMT0NLLCBTdGF0aWNUcmVlLnN0YXRpY19sdHJlZSk7XFxyXFxuXFxyXFxuICAgICAgICAgICAgYmlfZmx1c2goKTtcXHJcXG5cXHJcXG4gICAgICAgICAgICAvLyBPZiB0aGUgMTAgYml0cyBmb3IgdGhlIGVtcHR5IGJsb2NrLCB3ZSBoYXZlIGFscmVhZHkgc2VudFxcclxcbiAgICAgICAgICAgIC8vICgxMCAtIGJpX3ZhbGlkKSBiaXRzLiBUaGUgbG9va2FoZWFkIGZvciB0aGUgbGFzdCByZWFsIGNvZGUgKGJlZm9yZVxcclxcbiAgICAgICAgICAgIC8vIHRoZSBFT0Igb2YgdGhlIHByZXZpb3VzIGJsb2NrKSB3YXMgdGh1cyBhdCBsZWFzdCBvbmUgcGx1cyB0aGUgbGVuZ3RoXFxyXFxuICAgICAgICAgICAgLy8gb2YgdGhlIEVPQiBwbHVzIHdoYXQgd2UgaGF2ZSBqdXN0IHNlbnQgb2YgdGhlIGVtcHR5IHN0YXRpYyBibG9jay5cXHJcXG4gICAgICAgICAgICBpZiAoMSArIGxhc3RfZW9iX2xlbiArIDEwIC0gYmlfdmFsaWQgPCA5KSB7XFxyXFxuICAgICAgICAgICAgICAgIHNlbmRfYml0cyhTVEFUSUNfVFJFRVMgPDwgMSwgMyk7XFxyXFxuICAgICAgICAgICAgICAgIHNlbmRfY29kZShFTkRfQkxPQ0ssIFN0YXRpY1RyZWUuc3RhdGljX2x0cmVlKTtcXHJcXG4gICAgICAgICAgICAgICAgYmlfZmx1c2goKTtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgbGFzdF9lb2JfbGVuID0gNztcXHJcXG4gICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgIC8vIFNhdmUgdGhlIG1hdGNoIGluZm8gYW5kIHRhbGx5IHRoZSBmcmVxdWVuY3kgY291bnRzLiBSZXR1cm4gdHJ1ZSBpZlxcclxcbiAgICAgICAgLy8gdGhlIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkLlxcclxcbiAgICAgICAgZnVuY3Rpb24gX3RyX3RhbGx5KGRpc3QsIC8vIGRpc3RhbmNlIG9mIG1hdGNoZWQgc3RyaW5nXFxyXFxuICAgICAgICBsYyAvLyBtYXRjaCBsZW5ndGgtTUlOX01BVENIIG9yIHVubWF0Y2hlZCBjaGFyIChpZiBkaXN0PT0wKVxcclxcbiAgICAgICAgKSB7XFxyXFxuICAgICAgICAgICAgdmFyIG91dF9sZW5ndGgsIGluX2xlbmd0aCwgZGNvZGU7XFxyXFxuICAgICAgICAgICAgdGhhdC5wZW5kaW5nX2J1ZltkX2J1ZiArIGxhc3RfbGl0ICogMl0gPSAoZGlzdCA+Pj4gOCkgJiAweGZmO1xcclxcbiAgICAgICAgICAgIHRoYXQucGVuZGluZ19idWZbZF9idWYgKyBsYXN0X2xpdCAqIDIgKyAxXSA9IGRpc3QgJiAweGZmO1xcclxcblxcclxcbiAgICAgICAgICAgIHRoYXQucGVuZGluZ19idWZbbF9idWYgKyBsYXN0X2xpdF0gPSBsYyAmIDB4ZmY7XFxyXFxuICAgICAgICAgICAgbGFzdF9saXQrKztcXHJcXG5cXHJcXG4gICAgICAgICAgICBpZiAoZGlzdCA9PT0gMCkge1xcclxcbiAgICAgICAgICAgICAgICAvLyBsYyBpcyB0aGUgdW5tYXRjaGVkIGNoYXJcXHJcXG4gICAgICAgICAgICAgICAgZHluX2x0cmVlW2xjICogMl0rKztcXHJcXG4gICAgICAgICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgICAgICAgICBtYXRjaGVzKys7XFxyXFxuICAgICAgICAgICAgICAgIC8vIEhlcmUsIGxjIGlzIHRoZSBtYXRjaCBsZW5ndGggLSBNSU5fTUFUQ0hcXHJcXG4gICAgICAgICAgICAgICAgZGlzdC0tOyAvLyBkaXN0ID0gbWF0Y2ggZGlzdGFuY2UgLSAxXFxyXFxuICAgICAgICAgICAgICAgIGR5bl9sdHJlZVsoVHJlZS5fbGVuZ3RoX2NvZGVbbGNdICsgTElURVJBTFMgKyAxKSAqIDJdKys7XFxyXFxuICAgICAgICAgICAgICAgIGR5bl9kdHJlZVtUcmVlLmRfY29kZShkaXN0KSAqIDJdKys7XFxyXFxuICAgICAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgICAgIGlmICgobGFzdF9saXQgJiAweDFmZmYpID09PSAwICYmIGxldmVsID4gMikge1xcclxcbiAgICAgICAgICAgICAgICAvLyBDb21wdXRlIGFuIHVwcGVyIGJvdW5kIGZvciB0aGUgY29tcHJlc3NlZCBsZW5ndGhcXHJcXG4gICAgICAgICAgICAgICAgb3V0X2xlbmd0aCA9IGxhc3RfbGl0ICogODtcXHJcXG4gICAgICAgICAgICAgICAgaW5fbGVuZ3RoID0gc3Ryc3RhcnQgLSBibG9ja19zdGFydDtcXHJcXG4gICAgICAgICAgICAgICAgZm9yIChkY29kZSA9IDA7IGRjb2RlIDwgRF9DT0RFUzsgZGNvZGUrKykge1xcclxcbiAgICAgICAgICAgICAgICAgICAgb3V0X2xlbmd0aCArPSBkeW5fZHRyZWVbZGNvZGUgKiAyXSAqICg1ICsgVHJlZS5leHRyYV9kYml0c1tkY29kZV0pO1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgIG91dF9sZW5ndGggPj4+PSAzO1xcclxcbiAgICAgICAgICAgICAgICBpZiAoKG1hdGNoZXMgPCBNYXRoLmZsb29yKGxhc3RfbGl0IC8gMikpICYmIG91dF9sZW5ndGggPCBNYXRoLmZsb29yKGluX2xlbmd0aCAvIDIpKVxcclxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XFxyXFxuICAgICAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgICAgIHJldHVybiAobGFzdF9saXQgPT0gbGl0X2J1ZnNpemUgLSAxKTtcXHJcXG4gICAgICAgICAgICAvLyBXZSBhdm9pZCBlcXVhbGl0eSB3aXRoIGxpdF9idWZzaXplIGJlY2F1c2Ugb2Ygd3JhcGFyb3VuZCBhdCA2NEtcXHJcXG4gICAgICAgICAgICAvLyBvbiAxNiBiaXQgbWFjaGluZXMgYW5kIGJlY2F1c2Ugc3RvcmVkIGJsb2NrcyBhcmUgcmVzdHJpY3RlZCB0b1xcclxcbiAgICAgICAgICAgIC8vIDY0Sy0xIGJ5dGVzLlxcclxcbiAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgLy8gU2VuZCB0aGUgYmxvY2sgZGF0YSBjb21wcmVzc2VkIHVzaW5nIHRoZSBnaXZlbiBIdWZmbWFuIHRyZWVzXFxyXFxuICAgICAgICBmdW5jdGlvbiBjb21wcmVzc19ibG9jayhsdHJlZSwgZHRyZWUpIHtcXHJcXG4gICAgICAgICAgICB2YXIgZGlzdDsgLy8gZGlzdGFuY2Ugb2YgbWF0Y2hlZCBzdHJpbmdcXHJcXG4gICAgICAgICAgICB2YXIgbGM7IC8vIG1hdGNoIGxlbmd0aCBvciB1bm1hdGNoZWQgY2hhciAoaWYgZGlzdCA9PT0gMClcXHJcXG4gICAgICAgICAgICB2YXIgbHggPSAwOyAvLyBydW5uaW5nIGluZGV4IGluIGxfYnVmXFxyXFxuICAgICAgICAgICAgdmFyIGNvZGU7IC8vIHRoZSBjb2RlIHRvIHNlbmRcXHJcXG4gICAgICAgICAgICB2YXIgZXh0cmE7IC8vIG51bWJlciBvZiBleHRyYSBiaXRzIHRvIHNlbmRcXHJcXG5cXHJcXG4gICAgICAgICAgICBpZiAobGFzdF9saXQgIT09IDApIHtcXHJcXG4gICAgICAgICAgICAgICAgZG8ge1xcclxcbiAgICAgICAgICAgICAgICAgICAgZGlzdCA9ICgodGhhdC5wZW5kaW5nX2J1ZltkX2J1ZiArIGx4ICogMl0gPDwgOCkgJiAweGZmMDApIHwgKHRoYXQucGVuZGluZ19idWZbZF9idWYgKyBseCAqIDIgKyAxXSAmIDB4ZmYpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgbGMgPSAodGhhdC5wZW5kaW5nX2J1ZltsX2J1ZiArIGx4XSkgJiAweGZmO1xcclxcbiAgICAgICAgICAgICAgICAgICAgbHgrKztcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgIGlmIChkaXN0ID09PSAwKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VuZF9jb2RlKGxjLCBsdHJlZSk7IC8vIHNlbmQgYSBsaXRlcmFsIGJ5dGVcXHJcXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGVyZSwgbGMgaXMgdGhlIG1hdGNoIGxlbmd0aCAtIE1JTl9NQVRDSFxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUgPSBUcmVlLl9sZW5ndGhfY29kZVtsY107XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VuZF9jb2RlKGNvZGUgKyBMSVRFUkFMUyArIDEsIGx0cmVlKTsgLy8gc2VuZCB0aGUgbGVuZ3RoXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29kZVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhID0gVHJlZS5leHRyYV9sYml0c1tjb2RlXTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXh0cmEgIT09IDApIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGMgLT0gVHJlZS5iYXNlX2xlbmd0aFtjb2RlXTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VuZF9iaXRzKGxjLCBleHRyYSk7IC8vIHNlbmQgdGhlIGV4dHJhIGxlbmd0aCBiaXRzXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3QtLTsgLy8gZGlzdCBpcyBub3cgdGhlIG1hdGNoIGRpc3RhbmNlIC0gMVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUgPSBUcmVlLmRfY29kZShkaXN0KTtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBzZW5kX2NvZGUoY29kZSwgZHRyZWUpOyAvLyBzZW5kIHRoZSBkaXN0YW5jZSBjb2RlXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmEgPSBUcmVlLmV4dHJhX2RiaXRzW2NvZGVdO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHRyYSAhPT0gMCkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXN0IC09IFRyZWUuYmFzZV9kaXN0W2NvZGVdO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZW5kX2JpdHMoZGlzdCwgZXh0cmEpOyAvLyBzZW5kIHRoZSBleHRyYSBkaXN0YW5jZSBiaXRzXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICAgICAgfSAvLyBsaXRlcmFsIG9yIG1hdGNoIHBhaXIgP1xcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgdGhhdCB0aGUgb3ZlcmxheSBiZXR3ZWVuIHBlbmRpbmdfYnVmIGFuZCBkX2J1ZitsX2J1ZiBpc1xcclxcbiAgICAgICAgICAgICAgICAgICAgLy8gb2s6XFxyXFxuICAgICAgICAgICAgICAgIH0gd2hpbGUgKGx4IDwgbGFzdF9saXQpO1xcclxcbiAgICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICBzZW5kX2NvZGUoRU5EX0JMT0NLLCBsdHJlZSk7XFxyXFxuICAgICAgICAgICAgbGFzdF9lb2JfbGVuID0gbHRyZWVbRU5EX0JMT0NLICogMiArIDFdO1xcclxcbiAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgLy8gRmx1c2ggdGhlIGJpdCBidWZmZXIgYW5kIGFsaWduIHRoZSBvdXRwdXQgb24gYSBieXRlIGJvdW5kYXJ5XFxyXFxuICAgICAgICBmdW5jdGlvbiBiaV93aW5kdXAoKSB7XFxyXFxuICAgICAgICAgICAgaWYgKGJpX3ZhbGlkID4gOCkge1xcclxcbiAgICAgICAgICAgICAgICBwdXRfc2hvcnQoYmlfYnVmKTtcXHJcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGJpX3ZhbGlkID4gMCkge1xcclxcbiAgICAgICAgICAgICAgICBwdXRfYnl0ZShiaV9idWYgJiAweGZmKTtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgYmlfYnVmID0gMDtcXHJcXG4gICAgICAgICAgICBiaV92YWxpZCA9IDA7XFxyXFxuICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAvLyBDb3B5IGEgc3RvcmVkIGJsb2NrLCBzdG9yaW5nIGZpcnN0IHRoZSBsZW5ndGggYW5kIGl0c1xcclxcbiAgICAgICAgLy8gb25lJ3MgY29tcGxlbWVudCBpZiByZXF1ZXN0ZWQuXFxyXFxuICAgICAgICBmdW5jdGlvbiBjb3B5X2Jsb2NrKGJ1ZiwgLy8gdGhlIGlucHV0IGRhdGFcXHJcXG4gICAgICAgIGxlbiwgLy8gaXRzIGxlbmd0aFxcclxcbiAgICAgICAgaGVhZGVyIC8vIHRydWUgaWYgYmxvY2sgaGVhZGVyIG11c3QgYmUgd3JpdHRlblxcclxcbiAgICAgICAgKSB7XFxyXFxuICAgICAgICAgICAgYmlfd2luZHVwKCk7IC8vIGFsaWduIG9uIGJ5dGUgYm91bmRhcnlcXHJcXG4gICAgICAgICAgICBsYXN0X2VvYl9sZW4gPSA4OyAvLyBlbm91Z2ggbG9va2FoZWFkIGZvciBpbmZsYXRlXFxyXFxuXFxyXFxuICAgICAgICAgICAgaWYgKGhlYWRlcikge1xcclxcbiAgICAgICAgICAgICAgICBwdXRfc2hvcnQobGVuKTtcXHJcXG4gICAgICAgICAgICAgICAgcHV0X3Nob3J0KH5sZW4pO1xcclxcbiAgICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICB0aGF0LnBlbmRpbmdfYnVmLnNldCh3aW5kb3cuc3ViYXJyYXkoYnVmLCBidWYgKyBsZW4pLCB0aGF0LnBlbmRpbmcpO1xcclxcbiAgICAgICAgICAgIHRoYXQucGVuZGluZyArPSBsZW47XFxyXFxuICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAvLyBTZW5kIGEgc3RvcmVkIGJsb2NrXFxyXFxuICAgICAgICBmdW5jdGlvbiBfdHJfc3RvcmVkX2Jsb2NrKGJ1ZiwgLy8gaW5wdXQgYmxvY2tcXHJcXG4gICAgICAgIHN0b3JlZF9sZW4sIC8vIGxlbmd0aCBvZiBpbnB1dCBibG9ja1xcclxcbiAgICAgICAgZW9mIC8vIHRydWUgaWYgdGhpcyBpcyB0aGUgbGFzdCBibG9jayBmb3IgYSBmaWxlXFxyXFxuICAgICAgICApIHtcXHJcXG4gICAgICAgICAgICBzZW5kX2JpdHMoKFNUT1JFRF9CTE9DSyA8PCAxKSArIChlb2YgPyAxIDogMCksIDMpOyAvLyBzZW5kIGJsb2NrIHR5cGVcXHJcXG4gICAgICAgICAgICBjb3B5X2Jsb2NrKGJ1Ziwgc3RvcmVkX2xlbiwgdHJ1ZSk7IC8vIHdpdGggaGVhZGVyXFxyXFxuICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIGJlc3QgZW5jb2RpbmcgZm9yIHRoZSBjdXJyZW50IGJsb2NrOiBkeW5hbWljIHRyZWVzLCBzdGF0aWNcXHJcXG4gICAgICAgIC8vIHRyZWVzIG9yIHN0b3JlLCBhbmQgb3V0cHV0IHRoZSBlbmNvZGVkIGJsb2NrIHRvIHRoZSB6aXAgZmlsZS5cXHJcXG4gICAgICAgIGZ1bmN0aW9uIF90cl9mbHVzaF9ibG9jayhidWYsIC8vIGlucHV0IGJsb2NrLCBvciBOVUxMIGlmIHRvbyBvbGRcXHJcXG4gICAgICAgIHN0b3JlZF9sZW4sIC8vIGxlbmd0aCBvZiBpbnB1dCBibG9ja1xcclxcbiAgICAgICAgZW9mIC8vIHRydWUgaWYgdGhpcyBpcyB0aGUgbGFzdCBibG9jayBmb3IgYSBmaWxlXFxyXFxuICAgICAgICApIHtcXHJcXG4gICAgICAgICAgICB2YXIgb3B0X2xlbmIsIHN0YXRpY19sZW5iOy8vIG9wdF9sZW4gYW5kIHN0YXRpY19sZW4gaW4gYnl0ZXNcXHJcXG4gICAgICAgICAgICB2YXIgbWF4X2JsaW5kZXggPSAwOyAvLyBpbmRleCBvZiBsYXN0IGJpdCBsZW5ndGggY29kZSBvZiBub24gemVybyBmcmVxXFxyXFxuXFxyXFxuICAgICAgICAgICAgLy8gQnVpbGQgdGhlIEh1ZmZtYW4gdHJlZXMgdW5sZXNzIGEgc3RvcmVkIGJsb2NrIGlzIGZvcmNlZFxcclxcbiAgICAgICAgICAgIGlmIChsZXZlbCA+IDApIHtcXHJcXG4gICAgICAgICAgICAgICAgLy8gQ29uc3RydWN0IHRoZSBsaXRlcmFsIGFuZCBkaXN0YW5jZSB0cmVlc1xcclxcbiAgICAgICAgICAgICAgICBsX2Rlc2MuYnVpbGRfdHJlZSh0aGF0KTtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgZF9kZXNjLmJ1aWxkX3RyZWUodGhhdCk7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgIC8vIEF0IHRoaXMgcG9pbnQsIG9wdF9sZW4gYW5kIHN0YXRpY19sZW4gYXJlIHRoZSB0b3RhbCBiaXQgbGVuZ3Roc1xcclxcbiAgICAgICAgICAgICAgICAvLyBvZlxcclxcbiAgICAgICAgICAgICAgICAvLyB0aGUgY29tcHJlc3NlZCBibG9jayBkYXRhLCBleGNsdWRpbmcgdGhlIHRyZWUgcmVwcmVzZW50YXRpb25zLlxcclxcblxcclxcbiAgICAgICAgICAgICAgICAvLyBCdWlsZCB0aGUgYml0IGxlbmd0aCB0cmVlIGZvciB0aGUgYWJvdmUgdHdvIHRyZWVzLCBhbmQgZ2V0IHRoZVxcclxcbiAgICAgICAgICAgICAgICAvLyBpbmRleFxcclxcbiAgICAgICAgICAgICAgICAvLyBpbiBibF9vcmRlciBvZiB0aGUgbGFzdCBiaXQgbGVuZ3RoIGNvZGUgdG8gc2VuZC5cXHJcXG4gICAgICAgICAgICAgICAgbWF4X2JsaW5kZXggPSBidWlsZF9ibF90cmVlKCk7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgIC8vIERldGVybWluZSB0aGUgYmVzdCBlbmNvZGluZy4gQ29tcHV0ZSBmaXJzdCB0aGUgYmxvY2sgbGVuZ3RoIGluXFxyXFxuICAgICAgICAgICAgICAgIC8vIGJ5dGVzXFxyXFxuICAgICAgICAgICAgICAgIG9wdF9sZW5iID0gKHRoYXQub3B0X2xlbiArIDMgKyA3KSA+Pj4gMztcXHJcXG4gICAgICAgICAgICAgICAgc3RhdGljX2xlbmIgPSAodGhhdC5zdGF0aWNfbGVuICsgMyArIDcpID4+PiAzO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGljX2xlbmIgPD0gb3B0X2xlbmIpXFxyXFxuICAgICAgICAgICAgICAgICAgICBvcHRfbGVuYiA9IHN0YXRpY19sZW5iO1xcclxcbiAgICAgICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgICAgICAgIG9wdF9sZW5iID0gc3RhdGljX2xlbmIgPSBzdG9yZWRfbGVuICsgNTsgLy8gZm9yY2UgYSBzdG9yZWQgYmxvY2tcXHJcXG4gICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgaWYgKChzdG9yZWRfbGVuICsgNCA8PSBvcHRfbGVuYikgJiYgYnVmICE9IC0xKSB7XFxyXFxuICAgICAgICAgICAgICAgIC8vIDQ6IHR3byB3b3JkcyBmb3IgdGhlIGxlbmd0aHNcXHJcXG4gICAgICAgICAgICAgICAgLy8gVGhlIHRlc3QgYnVmICE9IE5VTEwgaXMgb25seSBuZWNlc3NhcnkgaWYgTElUX0JVRlNJWkUgPiBXU0laRS5cXHJcXG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIHdlIGNhbid0IGhhdmUgcHJvY2Vzc2VkIG1vcmUgdGhhbiBXU0laRSBpbnB1dCBieXRlc1xcclxcbiAgICAgICAgICAgICAgICAvLyBzaW5jZVxcclxcbiAgICAgICAgICAgICAgICAvLyB0aGUgbGFzdCBibG9jayBmbHVzaCwgYmVjYXVzZSBjb21wcmVzc2lvbiB3b3VsZCBoYXZlIGJlZW5cXHJcXG4gICAgICAgICAgICAgICAgLy8gc3VjY2Vzc2Z1bC4gSWYgTElUX0JVRlNJWkUgPD0gV1NJWkUsIGl0IGlzIG5ldmVyIHRvbyBsYXRlIHRvXFxyXFxuICAgICAgICAgICAgICAgIC8vIHRyYW5zZm9ybSBhIGJsb2NrIGludG8gYSBzdG9yZWQgYmxvY2suXFxyXFxuICAgICAgICAgICAgICAgIF90cl9zdG9yZWRfYmxvY2soYnVmLCBzdG9yZWRfbGVuLCBlb2YpO1xcclxcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdGljX2xlbmIgPT0gb3B0X2xlbmIpIHtcXHJcXG4gICAgICAgICAgICAgICAgc2VuZF9iaXRzKChTVEFUSUNfVFJFRVMgPDwgMSkgKyAoZW9mID8gMSA6IDApLCAzKTtcXHJcXG4gICAgICAgICAgICAgICAgY29tcHJlc3NfYmxvY2soU3RhdGljVHJlZS5zdGF0aWNfbHRyZWUsIFN0YXRpY1RyZWUuc3RhdGljX2R0cmVlKTtcXHJcXG4gICAgICAgICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgICAgICAgICBzZW5kX2JpdHMoKERZTl9UUkVFUyA8PCAxKSArIChlb2YgPyAxIDogMCksIDMpO1xcclxcbiAgICAgICAgICAgICAgICBzZW5kX2FsbF90cmVlcyhsX2Rlc2MubWF4X2NvZGUgKyAxLCBkX2Rlc2MubWF4X2NvZGUgKyAxLCBtYXhfYmxpbmRleCArIDEpO1xcclxcbiAgICAgICAgICAgICAgICBjb21wcmVzc19ibG9jayhkeW5fbHRyZWUsIGR5bl9kdHJlZSk7XFxyXFxuICAgICAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgICAgIC8vIFRoZSBhYm92ZSBjaGVjayBpcyBtYWRlIG1vZCAyXjMyLCBmb3IgZmlsZXMgbGFyZ2VyIHRoYW4gNTEyIE1CXFxyXFxuICAgICAgICAgICAgLy8gYW5kIHVMb25nIGltcGxlbWVudGVkIG9uIDMyIGJpdHMuXFxyXFxuXFxyXFxuICAgICAgICAgICAgaW5pdF9ibG9jaygpO1xcclxcblxcclxcbiAgICAgICAgICAgIGlmIChlb2YpIHtcXHJcXG4gICAgICAgICAgICAgICAgYmlfd2luZHVwKCk7XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgZnVuY3Rpb24gZmx1c2hfYmxvY2tfb25seShlb2YpIHtcXHJcXG4gICAgICAgICAgICBfdHJfZmx1c2hfYmxvY2soYmxvY2tfc3RhcnQgPj0gMCA/IGJsb2NrX3N0YXJ0IDogLTEsIHN0cnN0YXJ0IC0gYmxvY2tfc3RhcnQsIGVvZik7XFxyXFxuICAgICAgICAgICAgYmxvY2tfc3RhcnQgPSBzdHJzdGFydDtcXHJcXG4gICAgICAgICAgICBzdHJtLmZsdXNoX3BlbmRpbmcoKTtcXHJcXG4gICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgIC8vIEZpbGwgdGhlIHdpbmRvdyB3aGVuIHRoZSBsb29rYWhlYWQgYmVjb21lcyBpbnN1ZmZpY2llbnQuXFxyXFxuICAgICAgICAvLyBVcGRhdGVzIHN0cnN0YXJ0IGFuZCBsb29rYWhlYWQuXFxyXFxuICAgICAgICAvL1xcclxcbiAgICAgICAgLy8gSU4gYXNzZXJ0aW9uOiBsb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEXFxyXFxuICAgICAgICAvLyBPVVQgYXNzZXJ0aW9uczogc3Ryc3RhcnQgPD0gd2luZG93X3NpemUtTUlOX0xPT0tBSEVBRFxcclxcbiAgICAgICAgLy8gQXQgbGVhc3Qgb25lIGJ5dGUgaGFzIGJlZW4gcmVhZCwgb3IgYXZhaWxfaW4gPT09IDA7IHJlYWRzIGFyZVxcclxcbiAgICAgICAgLy8gcGVyZm9ybWVkIGZvciBhdCBsZWFzdCB0d28gYnl0ZXMgKHJlcXVpcmVkIGZvciB0aGUgemlwIHRyYW5zbGF0ZV9lb2xcXHJcXG4gICAgICAgIC8vIG9wdGlvbiAtLSBub3Qgc3VwcG9ydGVkIGhlcmUpLlxcclxcbiAgICAgICAgZnVuY3Rpb24gZmlsbF93aW5kb3coKSB7XFxyXFxuICAgICAgICAgICAgdmFyIG4sIG07XFxyXFxuICAgICAgICAgICAgdmFyIHA7XFxyXFxuICAgICAgICAgICAgdmFyIG1vcmU7IC8vIEFtb3VudCBvZiBmcmVlIHNwYWNlIGF0IHRoZSBlbmQgb2YgdGhlIHdpbmRvdy5cXHJcXG5cXHJcXG4gICAgICAgICAgICBkbyB7XFxyXFxuICAgICAgICAgICAgICAgIG1vcmUgPSAod2luZG93X3NpemUgLSBsb29rYWhlYWQgLSBzdHJzdGFydCk7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgIC8vIERlYWwgd2l0aCAhQCMkJSA2NEsgbGltaXQ6XFxyXFxuICAgICAgICAgICAgICAgIGlmIChtb3JlID09PSAwICYmIHN0cnN0YXJ0ID09PSAwICYmIGxvb2thaGVhZCA9PT0gMCkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgbW9yZSA9IHdfc2l6ZTtcXHJcXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtb3JlID09IC0xKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAvLyBWZXJ5IHVubGlrZWx5LCBidXQgcG9zc2libGUgb24gMTYgYml0IG1hY2hpbmUgaWYgc3Ryc3RhcnQgPT1cXHJcXG4gICAgICAgICAgICAgICAgICAgIC8vIDBcXHJcXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCBsb29rYWhlYWQgPT0gMSAoaW5wdXQgZG9uZSBvbmUgYnl0ZSBhdCB0aW1lKVxcclxcbiAgICAgICAgICAgICAgICAgICAgbW9yZS0tO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHdpbmRvdyBpcyBhbG1vc3QgZnVsbCBhbmQgdGhlcmUgaXMgaW5zdWZmaWNpZW50XFxyXFxuICAgICAgICAgICAgICAgICAgICAvLyBsb29rYWhlYWQsXFxyXFxuICAgICAgICAgICAgICAgICAgICAvLyBtb3ZlIHRoZSB1cHBlciBoYWxmIHRvIHRoZSBsb3dlciBvbmUgdG8gbWFrZSByb29tIGluIHRoZVxcclxcbiAgICAgICAgICAgICAgICAgICAgLy8gdXBwZXIgaGFsZi5cXHJcXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdHJzdGFydCA+PSB3X3NpemUgKyB3X3NpemUgLSBNSU5fTE9PS0FIRUFEKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuc2V0KHdpbmRvdy5zdWJhcnJheSh3X3NpemUsIHdfc2l6ZSArIHdfc2l6ZSksIDApO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hfc3RhcnQgLT0gd19zaXplO1xcclxcbiAgICAgICAgICAgICAgICAgICAgc3Ryc3RhcnQgLT0gd19zaXplOyAvLyB3ZSBub3cgaGF2ZSBzdHJzdGFydCA+PSBNQVhfRElTVFxcclxcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tfc3RhcnQgLT0gd19zaXplO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgLy8gU2xpZGUgdGhlIGhhc2ggdGFibGUgKGNvdWxkIGJlIGF2b2lkZWQgd2l0aCAzMiBiaXQgdmFsdWVzXFxyXFxuICAgICAgICAgICAgICAgICAgICAvLyBhdCB0aGUgZXhwZW5zZSBvZiBtZW1vcnkgdXNhZ2UpLiBXZSBzbGlkZSBldmVuIHdoZW4gbGV2ZWwgPT1cXHJcXG4gICAgICAgICAgICAgICAgICAgIC8vIDBcXHJcXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIGtlZXAgdGhlIGhhc2ggdGFibGUgY29uc2lzdGVudCBpZiB3ZSBzd2l0Y2ggYmFjayB0byBsZXZlbFxcclxcbiAgICAgICAgICAgICAgICAgICAgLy8gPiAwXFxyXFxuICAgICAgICAgICAgICAgICAgICAvLyBsYXRlci4gKFVzaW5nIGxldmVsIDAgcGVybWFuZW50bHkgaXMgbm90IGFuIG9wdGltYWwgdXNhZ2Ugb2ZcXHJcXG4gICAgICAgICAgICAgICAgICAgIC8vIHpsaWIsIHNvIHdlIGRvbid0IGNhcmUgYWJvdXQgdGhpcyBwYXRob2xvZ2ljYWwgY2FzZS4pXFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICBuID0gaGFzaF9zaXplO1xcclxcbiAgICAgICAgICAgICAgICAgICAgcCA9IG47XFxyXFxuICAgICAgICAgICAgICAgICAgICBkbyB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgbSA9IChoZWFkWy0tcF0gJiAweGZmZmYpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRbcF0gPSAobSA+PSB3X3NpemUgPyBtIC0gd19zaXplIDogMCk7XFxyXFxuICAgICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW4gIT09IDApO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgbiA9IHdfc2l6ZTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHAgPSBuO1xcclxcbiAgICAgICAgICAgICAgICAgICAgZG8ge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIG0gPSAocHJldlstLXBdICYgMHhmZmZmKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2W3BdID0gKG0gPj0gd19zaXplID8gbSAtIHdfc2l6ZSA6IDApO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIG4gaXMgbm90IG9uIGFueSBoYXNoIGNoYWluLCBwcmV2W25dIGlzIGdhcmJhZ2UgYnV0XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXRzIHZhbHVlIHdpbGwgbmV2ZXIgYmUgdXNlZC5cXHJcXG4gICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tbiAhPT0gMCk7XFxyXFxuICAgICAgICAgICAgICAgICAgICBtb3JlICs9IHdfc2l6ZTtcXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgICAgICAgICBpZiAoc3RybS5hdmFpbF9pbiA9PT0gMClcXHJcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgd2FzIG5vIHNsaWRpbmc6XFxyXFxuICAgICAgICAgICAgICAgIC8vIHN0cnN0YXJ0IDw9IFdTSVpFK01BWF9ESVNULTEgJiYgbG9va2FoZWFkIDw9IE1JTl9MT09LQUhFQUQgLSAxICYmXFxyXFxuICAgICAgICAgICAgICAgIC8vIG1vcmUgPT0gd2luZG93X3NpemUgLSBsb29rYWhlYWQgLSBzdHJzdGFydFxcclxcbiAgICAgICAgICAgICAgICAvLyA9PiBtb3JlID49IHdpbmRvd19zaXplIC0gKE1JTl9MT09LQUhFQUQtMSArIFdTSVpFICsgTUFYX0RJU1QtMSlcXHJcXG4gICAgICAgICAgICAgICAgLy8gPT4gbW9yZSA+PSB3aW5kb3dfc2l6ZSAtIDIqV1NJWkUgKyAyXFxyXFxuICAgICAgICAgICAgICAgIC8vIEluIHRoZSBCSUdfTUVNIG9yIE1NQVAgY2FzZSAobm90IHlldCBzdXBwb3J0ZWQpLFxcclxcbiAgICAgICAgICAgICAgICAvLyB3aW5kb3dfc2l6ZSA9PSBpbnB1dF9zaXplICsgTUlOX0xPT0tBSEVBRCAmJlxcclxcbiAgICAgICAgICAgICAgICAvLyBzdHJzdGFydCArIHMtPmxvb2thaGVhZCA8PSBpbnB1dF9zaXplID0+IG1vcmUgPj0gTUlOX0xPT0tBSEVBRC5cXHJcXG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCB3aW5kb3dfc2l6ZSA9PSAyKldTSVpFIHNvIG1vcmUgPj0gMi5cXHJcXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgd2FzIHNsaWRpbmcsIG1vcmUgPj0gV1NJWkUuIFNvIGluIGFsbCBjYXNlcywgbW9yZSA+PSAyLlxcclxcblxcclxcbiAgICAgICAgICAgICAgICBuID0gc3RybS5yZWFkX2J1Zih3aW5kb3csIHN0cnN0YXJ0ICsgbG9va2FoZWFkLCBtb3JlKTtcXHJcXG4gICAgICAgICAgICAgICAgbG9va2FoZWFkICs9IG47XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgIC8vIEluaXRpYWxpemUgdGhlIGhhc2ggdmFsdWUgbm93IHRoYXQgd2UgaGF2ZSBzb21lIGlucHV0OlxcclxcbiAgICAgICAgICAgICAgICBpZiAobG9va2FoZWFkID49IE1JTl9NQVRDSCkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgaW5zX2ggPSB3aW5kb3dbc3Ryc3RhcnRdICYgMHhmZjtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGluc19oID0gKCgoaW5zX2gpIDw8IGhhc2hfc2hpZnQpIF4gKHdpbmRvd1tzdHJzdGFydCArIDFdICYgMHhmZikpICYgaGFzaF9tYXNrO1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSB3aG9sZSBpbnB1dCBoYXMgbGVzcyB0aGFuIE1JTl9NQVRDSCBieXRlcywgaW5zX2ggaXNcXHJcXG4gICAgICAgICAgICAgICAgLy8gZ2FyYmFnZSxcXHJcXG4gICAgICAgICAgICAgICAgLy8gYnV0IHRoaXMgaXMgbm90IGltcG9ydGFudCBzaW5jZSBvbmx5IGxpdGVyYWwgYnl0ZXMgd2lsbCBiZVxcclxcbiAgICAgICAgICAgICAgICAvLyBlbWl0dGVkLlxcclxcbiAgICAgICAgICAgIH0gd2hpbGUgKGxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQgJiYgc3RybS5hdmFpbF9pbiAhPT0gMCk7XFxyXFxuICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAvLyBDb3B5IHdpdGhvdXQgY29tcHJlc3Npb24gYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIHRoZSBpbnB1dCBzdHJlYW0sXFxyXFxuICAgICAgICAvLyByZXR1cm5cXHJcXG4gICAgICAgIC8vIHRoZSBjdXJyZW50IGJsb2NrIHN0YXRlLlxcclxcbiAgICAgICAgLy8gVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBpbnNlcnQgbmV3IHN0cmluZ3MgaW4gdGhlIGRpY3Rpb25hcnkgc2luY2VcXHJcXG4gICAgICAgIC8vIHVuY29tcHJlc3NpYmxlIGRhdGEgaXMgcHJvYmFibHkgbm90IHVzZWZ1bC4gVGhpcyBmdW5jdGlvbiBpcyB1c2VkXFxyXFxuICAgICAgICAvLyBvbmx5IGZvciB0aGUgbGV2ZWw9MCBjb21wcmVzc2lvbiBvcHRpb24uXFxyXFxuICAgICAgICAvLyBOT1RFOiB0aGlzIGZ1bmN0aW9uIHNob3VsZCBiZSBvcHRpbWl6ZWQgdG8gYXZvaWQgZXh0cmEgY29weWluZyBmcm9tXFxyXFxuICAgICAgICAvLyB3aW5kb3cgdG8gcGVuZGluZ19idWYuXFxyXFxuICAgICAgICBmdW5jdGlvbiBkZWZsYXRlX3N0b3JlZChmbHVzaCkge1xcclxcbiAgICAgICAgICAgIC8vIFN0b3JlZCBibG9ja3MgYXJlIGxpbWl0ZWQgdG8gMHhmZmZmIGJ5dGVzLCBwZW5kaW5nX2J1ZiBpcyBsaW1pdGVkXFxyXFxuICAgICAgICAgICAgLy8gdG8gcGVuZGluZ19idWZfc2l6ZSwgYW5kIGVhY2ggc3RvcmVkIGJsb2NrIGhhcyBhIDUgYnl0ZSBoZWFkZXI6XFxyXFxuXFxyXFxuICAgICAgICAgICAgdmFyIG1heF9ibG9ja19zaXplID0gMHhmZmZmO1xcclxcbiAgICAgICAgICAgIHZhciBtYXhfc3RhcnQ7XFxyXFxuXFxyXFxuICAgICAgICAgICAgaWYgKG1heF9ibG9ja19zaXplID4gcGVuZGluZ19idWZfc2l6ZSAtIDUpIHtcXHJcXG4gICAgICAgICAgICAgICAgbWF4X2Jsb2NrX3NpemUgPSBwZW5kaW5nX2J1Zl9zaXplIC0gNTtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgLy8gQ29weSBhcyBtdWNoIGFzIHBvc3NpYmxlIGZyb20gaW5wdXQgdG8gb3V0cHV0OlxcclxcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XFxyXFxuICAgICAgICAgICAgICAgIC8vIEZpbGwgdGhlIHdpbmRvdyBhcyBtdWNoIGFzIHBvc3NpYmxlOlxcclxcbiAgICAgICAgICAgICAgICBpZiAobG9va2FoZWFkIDw9IDEpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGZpbGxfd2luZG93KCk7XFxyXFxuICAgICAgICAgICAgICAgICAgICBpZiAobG9va2FoZWFkID09PSAwICYmIGZsdXNoID09IFpfTk9fRkxVU0gpXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE5lZWRNb3JlO1xcclxcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvb2thaGVhZCA9PT0gMClcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2tcXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgICAgICAgICBzdHJzdGFydCArPSBsb29rYWhlYWQ7XFxyXFxuICAgICAgICAgICAgICAgIGxvb2thaGVhZCA9IDA7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgIC8vIEVtaXQgYSBzdG9yZWQgYmxvY2sgaWYgcGVuZGluZ19idWYgd2lsbCBiZSBmdWxsOlxcclxcbiAgICAgICAgICAgICAgICBtYXhfc3RhcnQgPSBibG9ja19zdGFydCArIG1heF9ibG9ja19zaXplO1xcclxcbiAgICAgICAgICAgICAgICBpZiAoc3Ryc3RhcnQgPT09IDAgfHwgc3Ryc3RhcnQgPj0gbWF4X3N0YXJ0KSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAvLyBzdHJzdGFydCA9PT0gMCBpcyBwb3NzaWJsZSB3aGVuIHdyYXBhcm91bmQgb24gMTYtYml0IG1hY2hpbmVcXHJcXG4gICAgICAgICAgICAgICAgICAgIGxvb2thaGVhZCA9IChzdHJzdGFydCAtIG1heF9zdGFydCk7XFxyXFxuICAgICAgICAgICAgICAgICAgICBzdHJzdGFydCA9IG1heF9zdGFydDtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgIGZsdXNoX2Jsb2NrX29ubHkoZmFsc2UpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBOZWVkTW9yZTtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgICAgICAgICAvLyBGbHVzaCBpZiB3ZSBtYXkgaGF2ZSB0byBzbGlkZSwgb3RoZXJ3aXNlIGJsb2NrX3N0YXJ0IG1heSBiZWNvbWVcXHJcXG4gICAgICAgICAgICAgICAgLy8gbmVnYXRpdmUgYW5kIHRoZSBkYXRhIHdpbGwgYmUgZ29uZTpcXHJcXG4gICAgICAgICAgICAgICAgaWYgKHN0cnN0YXJ0IC0gYmxvY2tfc3RhcnQgPj0gd19zaXplIC0gTUlOX0xPT0tBSEVBRCkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgZmx1c2hfYmxvY2tfb25seShmYWxzZSk7XFxyXFxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE5lZWRNb3JlO1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgICAgIGZsdXNoX2Jsb2NrX29ubHkoZmx1c2ggPT0gWl9GSU5JU0gpO1xcclxcbiAgICAgICAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMClcXHJcXG4gICAgICAgICAgICAgICAgcmV0dXJuIChmbHVzaCA9PSBaX0ZJTklTSCkgPyBGaW5pc2hTdGFydGVkIDogTmVlZE1vcmU7XFxyXFxuXFxyXFxuICAgICAgICAgICAgcmV0dXJuIGZsdXNoID09IFpfRklOSVNIID8gRmluaXNoRG9uZSA6IEJsb2NrRG9uZTtcXHJcXG4gICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgIGZ1bmN0aW9uIGxvbmdlc3RfbWF0Y2goY3VyX21hdGNoKSB7XFxyXFxuICAgICAgICAgICAgdmFyIGNoYWluX2xlbmd0aCA9IG1heF9jaGFpbl9sZW5ndGg7IC8vIG1heCBoYXNoIGNoYWluIGxlbmd0aFxcclxcbiAgICAgICAgICAgIHZhciBzY2FuID0gc3Ryc3RhcnQ7IC8vIGN1cnJlbnQgc3RyaW5nXFxyXFxuICAgICAgICAgICAgdmFyIG1hdGNoOyAvLyBtYXRjaGVkIHN0cmluZ1xcclxcbiAgICAgICAgICAgIHZhciBsZW47IC8vIGxlbmd0aCBvZiBjdXJyZW50IG1hdGNoXFxyXFxuICAgICAgICAgICAgdmFyIGJlc3RfbGVuID0gcHJldl9sZW5ndGg7IC8vIGJlc3QgbWF0Y2ggbGVuZ3RoIHNvIGZhclxcclxcbiAgICAgICAgICAgIHZhciBsaW1pdCA9IHN0cnN0YXJ0ID4gKHdfc2l6ZSAtIE1JTl9MT09LQUhFQUQpID8gc3Ryc3RhcnQgLSAod19zaXplIC0gTUlOX0xPT0tBSEVBRCkgOiAwO1xcclxcbiAgICAgICAgICAgIHZhciBfbmljZV9tYXRjaCA9IG5pY2VfbWF0Y2g7XFxyXFxuXFxyXFxuICAgICAgICAgICAgLy8gU3RvcCB3aGVuIGN1cl9tYXRjaCBiZWNvbWVzIDw9IGxpbWl0LiBUbyBzaW1wbGlmeSB0aGUgY29kZSxcXHJcXG4gICAgICAgICAgICAvLyB3ZSBwcmV2ZW50IG1hdGNoZXMgd2l0aCB0aGUgc3RyaW5nIG9mIHdpbmRvdyBpbmRleCAwLlxcclxcblxcclxcbiAgICAgICAgICAgIHZhciB3bWFzayA9IHdfbWFzaztcXHJcXG5cXHJcXG4gICAgICAgICAgICB2YXIgc3RyZW5kID0gc3Ryc3RhcnQgKyBNQVhfTUFUQ0g7XFxyXFxuICAgICAgICAgICAgdmFyIHNjYW5fZW5kMSA9IHdpbmRvd1tzY2FuICsgYmVzdF9sZW4gLSAxXTtcXHJcXG4gICAgICAgICAgICB2YXIgc2Nhbl9lbmQgPSB3aW5kb3dbc2NhbiArIGJlc3RfbGVuXTtcXHJcXG5cXHJcXG4gICAgICAgICAgICAvLyBUaGUgY29kZSBpcyBvcHRpbWl6ZWQgZm9yIEhBU0hfQklUUyA+PSA4IGFuZCBNQVhfTUFUQ0gtMiBtdWx0aXBsZSBvZlxcclxcbiAgICAgICAgICAgIC8vIDE2LlxcclxcbiAgICAgICAgICAgIC8vIEl0IGlzIGVhc3kgdG8gZ2V0IHJpZCBvZiB0aGlzIG9wdGltaXphdGlvbiBpZiBuZWNlc3NhcnkuXFxyXFxuXFxyXFxuICAgICAgICAgICAgLy8gRG8gbm90IHdhc3RlIHRvbyBtdWNoIHRpbWUgaWYgd2UgYWxyZWFkeSBoYXZlIGEgZ29vZCBtYXRjaDpcXHJcXG4gICAgICAgICAgICBpZiAocHJldl9sZW5ndGggPj0gZ29vZF9tYXRjaCkge1xcclxcbiAgICAgICAgICAgICAgICBjaGFpbl9sZW5ndGggPj49IDI7XFxyXFxuICAgICAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgICAgIC8vIERvIG5vdCBsb29rIGZvciBtYXRjaGVzIGJleW9uZCB0aGUgZW5kIG9mIHRoZSBpbnB1dC4gVGhpcyBpc1xcclxcbiAgICAgICAgICAgIC8vIG5lY2Vzc2FyeVxcclxcbiAgICAgICAgICAgIC8vIHRvIG1ha2UgZGVmbGF0ZSBkZXRlcm1pbmlzdGljLlxcclxcbiAgICAgICAgICAgIGlmIChfbmljZV9tYXRjaCA+IGxvb2thaGVhZClcXHJcXG4gICAgICAgICAgICAgICAgX25pY2VfbWF0Y2ggPSBsb29rYWhlYWQ7XFxyXFxuXFxyXFxuICAgICAgICAgICAgZG8ge1xcclxcbiAgICAgICAgICAgICAgICBtYXRjaCA9IGN1cl9tYXRjaDtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgLy8gU2tpcCB0byBuZXh0IG1hdGNoIGlmIHRoZSBtYXRjaCBsZW5ndGggY2Fubm90IGluY3JlYXNlXFxyXFxuICAgICAgICAgICAgICAgIC8vIG9yIGlmIHRoZSBtYXRjaCBsZW5ndGggaXMgbGVzcyB0aGFuIDI6XFxyXFxuICAgICAgICAgICAgICAgIGlmICh3aW5kb3dbbWF0Y2ggKyBiZXN0X2xlbl0gIT0gc2Nhbl9lbmQgfHwgd2luZG93W21hdGNoICsgYmVzdF9sZW4gLSAxXSAhPSBzY2FuX2VuZDEgfHwgd2luZG93W21hdGNoXSAhPSB3aW5kb3dbc2Nhbl1cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB8fCB3aW5kb3dbKyttYXRjaF0gIT0gd2luZG93W3NjYW4gKyAxXSlcXHJcXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICAvLyBUaGUgY2hlY2sgYXQgYmVzdF9sZW4tMSBjYW4gYmUgcmVtb3ZlZCBiZWNhdXNlIGl0IHdpbGwgYmUgbWFkZVxcclxcbiAgICAgICAgICAgICAgICAvLyBhZ2FpbiBsYXRlci4gKFRoaXMgaGV1cmlzdGljIGlzIG5vdCBhbHdheXMgYSB3aW4uKVxcclxcbiAgICAgICAgICAgICAgICAvLyBJdCBpcyBub3QgbmVjZXNzYXJ5IHRvIGNvbXBhcmUgc2NhblsyXSBhbmQgbWF0Y2hbMl0gc2luY2UgdGhleVxcclxcbiAgICAgICAgICAgICAgICAvLyBhcmUgYWx3YXlzIGVxdWFsIHdoZW4gdGhlIG90aGVyIGJ5dGVzIG1hdGNoLCBnaXZlbiB0aGF0XFxyXFxuICAgICAgICAgICAgICAgIC8vIHRoZSBoYXNoIGtleXMgYXJlIGVxdWFsIGFuZCB0aGF0IEhBU0hfQklUUyA+PSA4LlxcclxcbiAgICAgICAgICAgICAgICBzY2FuICs9IDI7XFxyXFxuICAgICAgICAgICAgICAgIG1hdGNoKys7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgIC8vIFdlIGNoZWNrIGZvciBpbnN1ZmZpY2llbnQgbG9va2FoZWFkIG9ubHkgZXZlcnkgOHRoIGNvbXBhcmlzb247XFxyXFxuICAgICAgICAgICAgICAgIC8vIHRoZSAyNTZ0aCBjaGVjayB3aWxsIGJlIG1hZGUgYXQgc3Ryc3RhcnQrMjU4LlxcclxcbiAgICAgICAgICAgICAgICBkbyB7XFxyXFxuICAgICAgICAgICAgICAgIH0gd2hpbGUgKHdpbmRvd1srK3NjYW5dID09IHdpbmRvd1srK21hdGNoXSAmJiB3aW5kb3dbKytzY2FuXSA9PSB3aW5kb3dbKyttYXRjaF0gJiYgd2luZG93Wysrc2Nhbl0gPT0gd2luZG93WysrbWF0Y2hdXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgd2luZG93Wysrc2Nhbl0gPT0gd2luZG93WysrbWF0Y2hdICYmIHdpbmRvd1srK3NjYW5dID09IHdpbmRvd1srK21hdGNoXSAmJiB3aW5kb3dbKytzY2FuXSA9PSB3aW5kb3dbKyttYXRjaF1cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiB3aW5kb3dbKytzY2FuXSA9PSB3aW5kb3dbKyttYXRjaF0gJiYgd2luZG93Wysrc2Nhbl0gPT0gd2luZG93WysrbWF0Y2hdICYmIHNjYW4gPCBzdHJlbmQpO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICBsZW4gPSBNQVhfTUFUQ0ggLSAoc3RyZW5kIC0gc2Nhbik7XFxyXFxuICAgICAgICAgICAgICAgIHNjYW4gPSBzdHJlbmQgLSBNQVhfTUFUQ0g7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgIGlmIChsZW4gPiBiZXN0X2xlbikge1xcclxcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hfc3RhcnQgPSBjdXJfbWF0Y2g7XFxyXFxuICAgICAgICAgICAgICAgICAgICBiZXN0X2xlbiA9IGxlbjtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGlmIChsZW4gPj0gX25pY2VfbWF0Y2gpXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxyXFxuICAgICAgICAgICAgICAgICAgICBzY2FuX2VuZDEgPSB3aW5kb3dbc2NhbiArIGJlc3RfbGVuIC0gMV07XFxyXFxuICAgICAgICAgICAgICAgICAgICBzY2FuX2VuZCA9IHdpbmRvd1tzY2FuICsgYmVzdF9sZW5dO1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgfSB3aGlsZSAoKGN1cl9tYXRjaCA9IChwcmV2W2N1cl9tYXRjaCAmIHdtYXNrXSAmIDB4ZmZmZikpID4gbGltaXQgJiYgLS1jaGFpbl9sZW5ndGggIT09IDApO1xcclxcblxcclxcbiAgICAgICAgICAgIGlmIChiZXN0X2xlbiA8PSBsb29rYWhlYWQpXFxyXFxuICAgICAgICAgICAgICAgIHJldHVybiBiZXN0X2xlbjtcXHJcXG4gICAgICAgICAgICByZXR1cm4gbG9va2FoZWFkO1xcclxcbiAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgLy8gQ29tcHJlc3MgYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIHRoZSBpbnB1dCBzdHJlYW0sIHJldHVybiB0aGUgY3VycmVudFxcclxcbiAgICAgICAgLy8gYmxvY2sgc3RhdGUuXFxyXFxuICAgICAgICAvLyBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IHBlcmZvcm0gbGF6eSBldmFsdWF0aW9uIG9mIG1hdGNoZXMgYW5kIGluc2VydHNcXHJcXG4gICAgICAgIC8vIG5ldyBzdHJpbmdzIGluIHRoZSBkaWN0aW9uYXJ5IG9ubHkgZm9yIHVubWF0Y2hlZCBzdHJpbmdzIG9yIGZvciBzaG9ydFxcclxcbiAgICAgICAgLy8gbWF0Y2hlcy4gSXQgaXMgdXNlZCBvbmx5IGZvciB0aGUgZmFzdCBjb21wcmVzc2lvbiBvcHRpb25zLlxcclxcbiAgICAgICAgZnVuY3Rpb24gZGVmbGF0ZV9mYXN0KGZsdXNoKSB7XFxyXFxuICAgICAgICAgICAgLy8gc2hvcnQgaGFzaF9oZWFkID0gMDsgLy8gaGVhZCBvZiB0aGUgaGFzaCBjaGFpblxcclxcbiAgICAgICAgICAgIHZhciBoYXNoX2hlYWQgPSAwOyAvLyBoZWFkIG9mIHRoZSBoYXNoIGNoYWluXFxyXFxuICAgICAgICAgICAgdmFyIGJmbHVzaDsgLy8gc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkXFxyXFxuXFxyXFxuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcXHJcXG4gICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgd2UgYWx3YXlzIGhhdmUgZW5vdWdoIGxvb2thaGVhZCwgZXhjZXB0XFxyXFxuICAgICAgICAgICAgICAgIC8vIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0IGZpbGUuIFdlIG5lZWQgTUFYX01BVENIIGJ5dGVzXFxyXFxuICAgICAgICAgICAgICAgIC8vIGZvciB0aGUgbmV4dCBtYXRjaCwgcGx1cyBNSU5fTUFUQ0ggYnl0ZXMgdG8gaW5zZXJ0IHRoZVxcclxcbiAgICAgICAgICAgICAgICAvLyBzdHJpbmcgZm9sbG93aW5nIHRoZSBuZXh0IG1hdGNoLlxcclxcbiAgICAgICAgICAgICAgICBpZiAobG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgZmlsbF93aW5kb3coKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGlmIChsb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEICYmIGZsdXNoID09IFpfTk9fRkxVU0gpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTmVlZE1vcmU7XFxyXFxuICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgICAgICBpZiAobG9va2FoZWFkID09PSAwKVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBmbHVzaCB0aGUgY3VycmVudCBibG9ja1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgIC8vIEluc2VydCB0aGUgc3RyaW5nIHdpbmRvd1tzdHJzdGFydCAuLiBzdHJzdGFydCsyXSBpbiB0aGVcXHJcXG4gICAgICAgICAgICAgICAgLy8gZGljdGlvbmFyeSwgYW5kIHNldCBoYXNoX2hlYWQgdG8gdGhlIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW46XFxyXFxuICAgICAgICAgICAgICAgIGlmIChsb29rYWhlYWQgPj0gTUlOX01BVENIKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICBpbnNfaCA9ICgoKGluc19oKSA8PCBoYXNoX3NoaWZ0KSBeICh3aW5kb3dbKHN0cnN0YXJ0KSArIChNSU5fTUFUQ0ggLSAxKV0gJiAweGZmKSkgJiBoYXNoX21hc2s7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICAvLyBwcmV2W3N0cnN0YXJ0JndfbWFza109aGFzaF9oZWFkPWhlYWRbaW5zX2hdO1xcclxcbiAgICAgICAgICAgICAgICAgICAgaGFzaF9oZWFkID0gKGhlYWRbaW5zX2hdICYgMHhmZmZmKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHByZXZbc3Ryc3RhcnQgJiB3X21hc2tdID0gaGVhZFtpbnNfaF07XFxyXFxuICAgICAgICAgICAgICAgICAgICBoZWFkW2luc19oXSA9IHN0cnN0YXJ0O1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgIC8vIEZpbmQgdGhlIGxvbmdlc3QgbWF0Y2gsIGRpc2NhcmRpbmcgdGhvc2UgPD0gcHJldl9sZW5ndGguXFxyXFxuICAgICAgICAgICAgICAgIC8vIEF0IHRoaXMgcG9pbnQgd2UgaGF2ZSBhbHdheXMgbWF0Y2hfbGVuZ3RoIDwgTUlOX01BVENIXFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgIGlmIChoYXNoX2hlYWQgIT09IDAgJiYgKChzdHJzdGFydCAtIGhhc2hfaGVhZCkgJiAweGZmZmYpIDw9IHdfc2l6ZSAtIE1JTl9MT09LQUhFQUQpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIC8vIFRvIHNpbXBsaWZ5IHRoZSBjb2RlLCB3ZSBwcmV2ZW50IG1hdGNoZXMgd2l0aCB0aGUgc3RyaW5nXFxyXFxuICAgICAgICAgICAgICAgICAgICAvLyBvZiB3aW5kb3cgaW5kZXggMCAoaW4gcGFydGljdWxhciB3ZSBoYXZlIHRvIGF2b2lkIGEgbWF0Y2hcXHJcXG4gICAgICAgICAgICAgICAgICAgIC8vIG9mIHRoZSBzdHJpbmcgd2l0aCBpdHNlbGYgYXQgdGhlIHN0YXJ0IG9mIHRoZSBpbnB1dCBmaWxlKS5cXHJcXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHJhdGVneSAhPSBaX0hVRkZNQU5fT05MWSkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoX2xlbmd0aCA9IGxvbmdlc3RfbWF0Y2goaGFzaF9oZWFkKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgICAgIC8vIGxvbmdlc3RfbWF0Y2goKSBzZXRzIG1hdGNoX3N0YXJ0XFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoX2xlbmd0aCA+PSBNSU5fTUFUQ0gpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrX21hdGNoKHN0cnN0YXJ0LCBtYXRjaF9zdGFydCwgbWF0Y2hfbGVuZ3RoKTtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgIGJmbHVzaCA9IF90cl90YWxseShzdHJzdGFydCAtIG1hdGNoX3N0YXJ0LCBtYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gpO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgbG9va2FoZWFkIC09IG1hdGNoX2xlbmd0aDtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgIC8vIEluc2VydCBuZXcgc3RyaW5ncyBpbiB0aGUgaGFzaCB0YWJsZSBvbmx5IGlmIHRoZSBtYXRjaCBsZW5ndGhcXHJcXG4gICAgICAgICAgICAgICAgICAgIC8vIGlzIG5vdCB0b28gbGFyZ2UuIFRoaXMgc2F2ZXMgdGltZSBidXQgZGVncmFkZXMgY29tcHJlc3Npb24uXFxyXFxuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hfbGVuZ3RoIDw9IG1heF9sYXp5X21hdGNoICYmIGxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaF9sZW5ndGgtLTsgLy8gc3RyaW5nIGF0IHN0cnN0YXJ0IGFscmVhZHkgaW4gaGFzaCB0YWJsZVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Ryc3RhcnQrKztcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zX2ggPSAoKGluc19oIDw8IGhhc2hfc2hpZnQpIF4gKHdpbmRvd1soc3Ryc3RhcnQpICsgKE1JTl9NQVRDSCAtIDEpXSAmIDB4ZmYpKSAmIGhhc2hfbWFzaztcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJldltzdHJzdGFydCZ3X21hc2tdPWhhc2hfaGVhZD1oZWFkW2luc19oXTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzaF9oZWFkID0gKGhlYWRbaW5zX2hdICYgMHhmZmZmKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldltzdHJzdGFydCAmIHdfbWFza10gPSBoZWFkW2luc19oXTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZFtpbnNfaF0gPSBzdHJzdGFydDtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3Ryc3RhcnQgbmV2ZXIgZXhjZWVkcyBXU0laRS1NQVhfTUFUQ0gsIHNvIHRoZXJlIGFyZVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbHdheXMgTUlOX01BVENIIGJ5dGVzIGFoZWFkLlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tbWF0Y2hfbGVuZ3RoICE9PSAwKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJzdGFydCsrO1xcclxcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJzdGFydCArPSBtYXRjaF9sZW5ndGg7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hfbGVuZ3RoID0gMDtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnNfaCA9IHdpbmRvd1tzdHJzdGFydF0gJiAweGZmO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc19oID0gKCgoaW5zX2gpIDw8IGhhc2hfc2hpZnQpIF4gKHdpbmRvd1tzdHJzdGFydCArIDFdICYgMHhmZikpICYgaGFzaF9tYXNrO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGxvb2thaGVhZCA8IE1JTl9NQVRDSCwgaW5zX2ggaXMgZ2FyYmFnZSwgYnV0IGl0IGRvZXNcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBub3RcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtYXR0ZXIgc2luY2UgaXQgd2lsbCBiZSByZWNvbXB1dGVkIGF0IG5leHQgZGVmbGF0ZSBjYWxsLlxcclxcbiAgICAgICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgICAgICAgICAgICAgLy8gTm8gbWF0Y2gsIG91dHB1dCBhIGxpdGVyYWwgYnl0ZVxcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgYmZsdXNoID0gX3RyX3RhbGx5KDAsIHdpbmRvd1tzdHJzdGFydF0gJiAweGZmKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGxvb2thaGVhZC0tO1xcclxcbiAgICAgICAgICAgICAgICAgICAgc3Ryc3RhcnQrKztcXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICBpZiAoYmZsdXNoKSB7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICBmbHVzaF9ibG9ja19vbmx5KGZhbHNlKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMClcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTmVlZE1vcmU7XFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgZmx1c2hfYmxvY2tfb25seShmbHVzaCA9PSBaX0ZJTklTSCk7XFxyXFxuICAgICAgICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XFxyXFxuICAgICAgICAgICAgICAgIGlmIChmbHVzaCA9PSBaX0ZJTklTSClcXHJcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBGaW5pc2hTdGFydGVkO1xcclxcbiAgICAgICAgICAgICAgICBlbHNlXFxyXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTmVlZE1vcmU7XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIHJldHVybiBmbHVzaCA9PSBaX0ZJTklTSCA/IEZpbmlzaERvbmUgOiBCbG9ja0RvbmU7XFxyXFxuICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAvLyBTYW1lIGFzIGFib3ZlLCBidXQgYWNoaWV2ZXMgYmV0dGVyIGNvbXByZXNzaW9uLiBXZSB1c2UgYSBsYXp5XFxyXFxuICAgICAgICAvLyBldmFsdWF0aW9uIGZvciBtYXRjaGVzOiBhIG1hdGNoIGlzIGZpbmFsbHkgYWRvcHRlZCBvbmx5IGlmIHRoZXJlIGlzXFxyXFxuICAgICAgICAvLyBubyBiZXR0ZXIgbWF0Y2ggYXQgdGhlIG5leHQgd2luZG93IHBvc2l0aW9uLlxcclxcbiAgICAgICAgZnVuY3Rpb24gZGVmbGF0ZV9zbG93KGZsdXNoKSB7XFxyXFxuICAgICAgICAgICAgLy8gc2hvcnQgaGFzaF9oZWFkID0gMDsgLy8gaGVhZCBvZiBoYXNoIGNoYWluXFxyXFxuICAgICAgICAgICAgdmFyIGhhc2hfaGVhZCA9IDA7IC8vIGhlYWQgb2YgaGFzaCBjaGFpblxcclxcbiAgICAgICAgICAgIHZhciBiZmx1c2g7IC8vIHNldCBpZiBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZFxcclxcbiAgICAgICAgICAgIHZhciBtYXhfaW5zZXJ0O1xcclxcblxcclxcbiAgICAgICAgICAgIC8vIFByb2Nlc3MgdGhlIGlucHV0IGJsb2NrLlxcclxcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XFxyXFxuICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHdlIGFsd2F5cyBoYXZlIGVub3VnaCBsb29rYWhlYWQsIGV4Y2VwdFxcclxcbiAgICAgICAgICAgICAgICAvLyBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dCBmaWxlLiBXZSBuZWVkIE1BWF9NQVRDSCBieXRlc1xcclxcbiAgICAgICAgICAgICAgICAvLyBmb3IgdGhlIG5leHQgbWF0Y2gsIHBsdXMgTUlOX01BVENIIGJ5dGVzIHRvIGluc2VydCB0aGVcXHJcXG4gICAgICAgICAgICAgICAgLy8gc3RyaW5nIGZvbGxvd2luZyB0aGUgbmV4dCBtYXRjaC5cXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgaWYgKGxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGZpbGxfd2luZG93KCk7XFxyXFxuICAgICAgICAgICAgICAgICAgICBpZiAobG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCAmJiBmbHVzaCA9PSBaX05PX0ZMVVNIKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE5lZWRNb3JlO1xcclxcbiAgICAgICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvb2thaGVhZCA9PT0gMClcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2tcXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgICAgICAgICAvLyBJbnNlcnQgdGhlIHN0cmluZyB3aW5kb3dbc3Ryc3RhcnQgLi4gc3Ryc3RhcnQrMl0gaW4gdGhlXFxyXFxuICAgICAgICAgICAgICAgIC8vIGRpY3Rpb25hcnksIGFuZCBzZXQgaGFzaF9oZWFkIHRvIHRoZSBoZWFkIG9mIHRoZSBoYXNoIGNoYWluOlxcclxcblxcclxcbiAgICAgICAgICAgICAgICBpZiAobG9va2FoZWFkID49IE1JTl9NQVRDSCkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgaW5zX2ggPSAoKChpbnNfaCkgPDwgaGFzaF9zaGlmdCkgXiAod2luZG93WyhzdHJzdGFydCkgKyAoTUlOX01BVENIIC0gMSldICYgMHhmZikpICYgaGFzaF9tYXNrO1xcclxcbiAgICAgICAgICAgICAgICAgICAgLy8gcHJldltzdHJzdGFydCZ3X21hc2tdPWhhc2hfaGVhZD1oZWFkW2luc19oXTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGhhc2hfaGVhZCA9IChoZWFkW2luc19oXSAmIDB4ZmZmZik7XFxyXFxuICAgICAgICAgICAgICAgICAgICBwcmV2W3N0cnN0YXJ0ICYgd19tYXNrXSA9IGhlYWRbaW5zX2hdO1xcclxcbiAgICAgICAgICAgICAgICAgICAgaGVhZFtpbnNfaF0gPSBzdHJzdGFydDtcXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgICAgICAgICAvLyBGaW5kIHRoZSBsb25nZXN0IG1hdGNoLCBkaXNjYXJkaW5nIHRob3NlIDw9IHByZXZfbGVuZ3RoLlxcclxcbiAgICAgICAgICAgICAgICBwcmV2X2xlbmd0aCA9IG1hdGNoX2xlbmd0aDtcXHJcXG4gICAgICAgICAgICAgICAgcHJldl9tYXRjaCA9IG1hdGNoX3N0YXJ0O1xcclxcbiAgICAgICAgICAgICAgICBtYXRjaF9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICBpZiAoaGFzaF9oZWFkICE9PSAwICYmIHByZXZfbGVuZ3RoIDwgbWF4X2xhenlfbWF0Y2ggJiYgKChzdHJzdGFydCAtIGhhc2hfaGVhZCkgJiAweGZmZmYpIDw9IHdfc2l6ZSAtIE1JTl9MT09LQUhFQUQpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIC8vIFRvIHNpbXBsaWZ5IHRoZSBjb2RlLCB3ZSBwcmV2ZW50IG1hdGNoZXMgd2l0aCB0aGUgc3RyaW5nXFxyXFxuICAgICAgICAgICAgICAgICAgICAvLyBvZiB3aW5kb3cgaW5kZXggMCAoaW4gcGFydGljdWxhciB3ZSBoYXZlIHRvIGF2b2lkIGEgbWF0Y2hcXHJcXG4gICAgICAgICAgICAgICAgICAgIC8vIG9mIHRoZSBzdHJpbmcgd2l0aCBpdHNlbGYgYXQgdGhlIHN0YXJ0IG9mIHRoZSBpbnB1dCBmaWxlKS5cXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHJhdGVneSAhPSBaX0hVRkZNQU5fT05MWSkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoX2xlbmd0aCA9IGxvbmdlc3RfbWF0Y2goaGFzaF9oZWFkKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgICAgIC8vIGxvbmdlc3RfbWF0Y2goKSBzZXRzIG1hdGNoX3N0YXJ0XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hfbGVuZ3RoIDw9IDUgJiYgKHN0cmF0ZWd5ID09IFpfRklMVEVSRUQgfHwgKG1hdGNoX2xlbmd0aCA9PSBNSU5fTUFUQ0ggJiYgc3Ryc3RhcnQgLSBtYXRjaF9zdGFydCA+IDQwOTYpKSkge1xcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHByZXZfbWF0Y2ggaXMgYWxzbyBNSU5fTUFUQ0gsIG1hdGNoX3N0YXJ0IGlzIGdhcmJhZ2VcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBidXQgd2Ugd2lsbCBpZ25vcmUgdGhlIGN1cnJlbnQgbWF0Y2ggYW55d2F5LlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoX2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XFxyXFxuICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgd2FzIGEgbWF0Y2ggYXQgdGhlIHByZXZpb3VzIHN0ZXAgYW5kIHRoZSBjdXJyZW50XFxyXFxuICAgICAgICAgICAgICAgIC8vIG1hdGNoIGlzIG5vdCBiZXR0ZXIsIG91dHB1dCB0aGUgcHJldmlvdXMgbWF0Y2g6XFxyXFxuICAgICAgICAgICAgICAgIGlmIChwcmV2X2xlbmd0aCA+PSBNSU5fTUFUQ0ggJiYgbWF0Y2hfbGVuZ3RoIDw9IHByZXZfbGVuZ3RoKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICBtYXhfaW5zZXJ0ID0gc3Ryc3RhcnQgKyBsb29rYWhlYWQgLSBNSU5fTUFUQ0g7XFxyXFxuICAgICAgICAgICAgICAgICAgICAvLyBEbyBub3QgaW5zZXJ0IHN0cmluZ3MgaW4gaGFzaCB0YWJsZSBiZXlvbmQgdGhpcy5cXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrX21hdGNoKHN0cnN0YXJ0LTEsIHByZXZfbWF0Y2gsIHByZXZfbGVuZ3RoKTtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgIGJmbHVzaCA9IF90cl90YWxseShzdHJzdGFydCAtIDEgLSBwcmV2X21hdGNoLCBwcmV2X2xlbmd0aCAtIE1JTl9NQVRDSCk7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICAvLyBJbnNlcnQgaW4gaGFzaCB0YWJsZSBhbGwgc3RyaW5ncyB1cCB0byB0aGUgZW5kIG9mIHRoZSBtYXRjaC5cXHJcXG4gICAgICAgICAgICAgICAgICAgIC8vIHN0cnN0YXJ0LTEgYW5kIHN0cnN0YXJ0IGFyZSBhbHJlYWR5IGluc2VydGVkLiBJZiB0aGVyZSBpcyBub3RcXHJcXG4gICAgICAgICAgICAgICAgICAgIC8vIGVub3VnaCBsb29rYWhlYWQsIHRoZSBsYXN0IHR3byBzdHJpbmdzIGFyZSBub3QgaW5zZXJ0ZWQgaW5cXHJcXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBoYXNoIHRhYmxlLlxcclxcbiAgICAgICAgICAgICAgICAgICAgbG9va2FoZWFkIC09IHByZXZfbGVuZ3RoIC0gMTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHByZXZfbGVuZ3RoIC09IDI7XFxyXFxuICAgICAgICAgICAgICAgICAgICBkbyB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCsrc3Ryc3RhcnQgPD0gbWF4X2luc2VydCkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnNfaCA9ICgoKGluc19oKSA8PCBoYXNoX3NoaWZ0KSBeICh3aW5kb3dbKHN0cnN0YXJ0KSArIChNSU5fTUFUQ0ggLSAxKV0gJiAweGZmKSkgJiBoYXNoX21hc2s7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByZXZbc3Ryc3RhcnQmd19tYXNrXT1oYXNoX2hlYWQ9aGVhZFtpbnNfaF07XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc2hfaGVhZCA9IChoZWFkW2luc19oXSAmIDB4ZmZmZik7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZbc3Ryc3RhcnQgJiB3X21hc2tdID0gaGVhZFtpbnNfaF07XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRbaW5zX2hdID0gc3Ryc3RhcnQ7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1wcmV2X2xlbmd0aCAhPT0gMCk7XFxyXFxuICAgICAgICAgICAgICAgICAgICBtYXRjaF9hdmFpbGFibGUgPSAwO1xcclxcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHN0cnN0YXJ0Kys7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICBpZiAoYmZsdXNoKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgZmx1c2hfYmxvY2tfb25seShmYWxzZSk7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTmVlZE1vcmU7XFxyXFxuICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobWF0Y2hfYXZhaWxhYmxlICE9PSAwKSB7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSB3YXMgbm8gbWF0Y2ggYXQgdGhlIHByZXZpb3VzIHBvc2l0aW9uLCBvdXRwdXQgYVxcclxcbiAgICAgICAgICAgICAgICAgICAgLy8gc2luZ2xlIGxpdGVyYWwuIElmIHRoZXJlIHdhcyBhIG1hdGNoIGJ1dCB0aGUgY3VycmVudCBtYXRjaFxcclxcbiAgICAgICAgICAgICAgICAgICAgLy8gaXMgbG9uZ2VyLCB0cnVuY2F0ZSB0aGUgcHJldmlvdXMgbWF0Y2ggdG8gYSBzaW5nbGUgbGl0ZXJhbC5cXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgIGJmbHVzaCA9IF90cl90YWxseSgwLCB3aW5kb3dbc3Ryc3RhcnQgLSAxXSAmIDB4ZmYpO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJmbHVzaCkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsdXNoX2Jsb2NrX29ubHkoZmFsc2UpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICAgICAgc3Ryc3RhcnQrKztcXHJcXG4gICAgICAgICAgICAgICAgICAgIGxvb2thaGVhZC0tO1xcclxcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBOZWVkTW9yZTtcXHJcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZXJlIGlzIG5vIHByZXZpb3VzIG1hdGNoIHRvIGNvbXBhcmUgd2l0aCwgd2FpdCBmb3JcXHJcXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBuZXh0IHN0ZXAgdG8gZGVjaWRlLlxcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hfYXZhaWxhYmxlID0gMTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHN0cnN0YXJ0Kys7XFxyXFxuICAgICAgICAgICAgICAgICAgICBsb29rYWhlYWQtLTtcXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICBpZiAobWF0Y2hfYXZhaWxhYmxlICE9PSAwKSB7XFxyXFxuICAgICAgICAgICAgICAgIGJmbHVzaCA9IF90cl90YWxseSgwLCB3aW5kb3dbc3Ryc3RhcnQgLSAxXSAmIDB4ZmYpO1xcclxcbiAgICAgICAgICAgICAgICBtYXRjaF9hdmFpbGFibGUgPSAwO1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICBmbHVzaF9ibG9ja19vbmx5KGZsdXNoID09IFpfRklOSVNIKTtcXHJcXG5cXHJcXG4gICAgICAgICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcXHJcXG4gICAgICAgICAgICAgICAgaWYgKGZsdXNoID09IFpfRklOSVNIKVxcclxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEZpbmlzaFN0YXJ0ZWQ7XFxyXFxuICAgICAgICAgICAgICAgIGVsc2VcXHJcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBOZWVkTW9yZTtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgcmV0dXJuIGZsdXNoID09IFpfRklOSVNIID8gRmluaXNoRG9uZSA6IEJsb2NrRG9uZTtcXHJcXG4gICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgIGZ1bmN0aW9uIGRlZmxhdGVSZXNldChzdHJtKSB7XFxyXFxuICAgICAgICAgICAgc3RybS50b3RhbF9pbiA9IHN0cm0udG90YWxfb3V0ID0gMDtcXHJcXG4gICAgICAgICAgICBzdHJtLm1zZyA9IG51bGw7IC8vXFxyXFxuXFxyXFxuICAgICAgICAgICAgdGhhdC5wZW5kaW5nID0gMDtcXHJcXG4gICAgICAgICAgICB0aGF0LnBlbmRpbmdfb3V0ID0gMDtcXHJcXG5cXHJcXG4gICAgICAgICAgICBzdGF0dXMgPSBCVVNZX1NUQVRFO1xcclxcblxcclxcbiAgICAgICAgICAgIGxhc3RfZmx1c2ggPSBaX05PX0ZMVVNIO1xcclxcblxcclxcbiAgICAgICAgICAgIHRyX2luaXQoKTtcXHJcXG4gICAgICAgICAgICBsbV9pbml0KCk7XFxyXFxuICAgICAgICAgICAgcmV0dXJuIFpfT0s7XFxyXFxuICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICB0aGF0LmRlZmxhdGVJbml0ID0gZnVuY3Rpb24oc3RybSwgX2xldmVsLCBiaXRzLCBfbWV0aG9kLCBtZW1MZXZlbCwgX3N0cmF0ZWd5KSB7XFxyXFxuICAgICAgICAgICAgaWYgKCFfbWV0aG9kKVxcclxcbiAgICAgICAgICAgICAgICBfbWV0aG9kID0gWl9ERUZMQVRFRDtcXHJcXG4gICAgICAgICAgICBpZiAoIW1lbUxldmVsKVxcclxcbiAgICAgICAgICAgICAgICBtZW1MZXZlbCA9IERFRl9NRU1fTEVWRUw7XFxyXFxuICAgICAgICAgICAgaWYgKCFfc3RyYXRlZ3kpXFxyXFxuICAgICAgICAgICAgICAgIF9zdHJhdGVneSA9IFpfREVGQVVMVF9TVFJBVEVHWTtcXHJcXG5cXHJcXG4gICAgICAgICAgICAvLyBieXRlW10gbXlfdmVyc2lvbj1aTElCX1ZFUlNJT047XFxyXFxuXFxyXFxuICAgICAgICAgICAgLy9cXHJcXG4gICAgICAgICAgICAvLyBpZiAoIXZlcnNpb24gfHwgdmVyc2lvblswXSAhPSBteV92ZXJzaW9uWzBdXFxyXFxuICAgICAgICAgICAgLy8gfHwgc3RyZWFtX3NpemUgIT0gc2l6ZW9mKHpfc3RyZWFtKSkge1xcclxcbiAgICAgICAgICAgIC8vIHJldHVybiBaX1ZFUlNJT05fRVJST1I7XFxyXFxuICAgICAgICAgICAgLy8gfVxcclxcblxcclxcbiAgICAgICAgICAgIHN0cm0ubXNnID0gbnVsbDtcXHJcXG5cXHJcXG4gICAgICAgICAgICBpZiAoX2xldmVsID09IFpfREVGQVVMVF9DT01QUkVTU0lPTilcXHJcXG4gICAgICAgICAgICAgICAgX2xldmVsID0gNjtcXHJcXG5cXHJcXG4gICAgICAgICAgICBpZiAobWVtTGV2ZWwgPCAxIHx8IG1lbUxldmVsID4gTUFYX01FTV9MRVZFTCB8fCBfbWV0aG9kICE9IFpfREVGTEFURUQgfHwgYml0cyA8IDkgfHwgYml0cyA+IDE1IHx8IF9sZXZlbCA8IDAgfHwgX2xldmVsID4gOSB8fCBfc3RyYXRlZ3kgPCAwXFxyXFxuICAgICAgICAgICAgICAgICAgICB8fCBfc3RyYXRlZ3kgPiBaX0hVRkZNQU5fT05MWSkge1xcclxcbiAgICAgICAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XFxyXFxuICAgICAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgICAgIHN0cm0uZHN0YXRlID0gdGhhdDtcXHJcXG5cXHJcXG4gICAgICAgICAgICB3X2JpdHMgPSBiaXRzO1xcclxcbiAgICAgICAgICAgIHdfc2l6ZSA9IDEgPDwgd19iaXRzO1xcclxcbiAgICAgICAgICAgIHdfbWFzayA9IHdfc2l6ZSAtIDE7XFxyXFxuXFxyXFxuICAgICAgICAgICAgaGFzaF9iaXRzID0gbWVtTGV2ZWwgKyA3O1xcclxcbiAgICAgICAgICAgIGhhc2hfc2l6ZSA9IDEgPDwgaGFzaF9iaXRzO1xcclxcbiAgICAgICAgICAgIGhhc2hfbWFzayA9IGhhc2hfc2l6ZSAtIDE7XFxyXFxuICAgICAgICAgICAgaGFzaF9zaGlmdCA9IE1hdGguZmxvb3IoKGhhc2hfYml0cyArIE1JTl9NQVRDSCAtIDEpIC8gTUlOX01BVENIKTtcXHJcXG5cXHJcXG4gICAgICAgICAgICB3aW5kb3cgPSBuZXcgVWludDhBcnJheSh3X3NpemUgKiAyKTtcXHJcXG4gICAgICAgICAgICBwcmV2ID0gW107XFxyXFxuICAgICAgICAgICAgaGVhZCA9IFtdO1xcclxcblxcclxcbiAgICAgICAgICAgIGxpdF9idWZzaXplID0gMSA8PCAobWVtTGV2ZWwgKyA2KTsgLy8gMTZLIGVsZW1lbnRzIGJ5IGRlZmF1bHRcXHJcXG5cXHJcXG4gICAgICAgICAgICAvLyBXZSBvdmVybGF5IHBlbmRpbmdfYnVmIGFuZCBkX2J1ZitsX2J1Zi4gVGhpcyB3b3JrcyBzaW5jZSB0aGUgYXZlcmFnZVxcclxcbiAgICAgICAgICAgIC8vIG91dHB1dCBzaXplIGZvciAobGVuZ3RoLGRpc3RhbmNlKSBjb2RlcyBpcyA8PSAyNCBiaXRzLlxcclxcbiAgICAgICAgICAgIHRoYXQucGVuZGluZ19idWYgPSBuZXcgVWludDhBcnJheShsaXRfYnVmc2l6ZSAqIDQpO1xcclxcbiAgICAgICAgICAgIHBlbmRpbmdfYnVmX3NpemUgPSBsaXRfYnVmc2l6ZSAqIDQ7XFxyXFxuXFxyXFxuICAgICAgICAgICAgZF9idWYgPSBNYXRoLmZsb29yKGxpdF9idWZzaXplIC8gMik7XFxyXFxuICAgICAgICAgICAgbF9idWYgPSAoMSArIDIpICogbGl0X2J1ZnNpemU7XFxyXFxuXFxyXFxuICAgICAgICAgICAgbGV2ZWwgPSBfbGV2ZWw7XFxyXFxuXFxyXFxuICAgICAgICAgICAgc3RyYXRlZ3kgPSBfc3RyYXRlZ3k7XFxyXFxuICAgICAgICAgICAgbWV0aG9kID0gX21ldGhvZCAmIDB4ZmY7XFxyXFxuXFxyXFxuICAgICAgICAgICAgcmV0dXJuIGRlZmxhdGVSZXNldChzdHJtKTtcXHJcXG4gICAgICAgIH07XFxyXFxuXFxyXFxuICAgICAgICB0aGF0LmRlZmxhdGVFbmQgPSBmdW5jdGlvbigpIHtcXHJcXG4gICAgICAgICAgICBpZiAoc3RhdHVzICE9IElOSVRfU1RBVEUgJiYgc3RhdHVzICE9IEJVU1lfU1RBVEUgJiYgc3RhdHVzICE9IEZJTklTSF9TVEFURSkge1xcclxcbiAgICAgICAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIC8vIERlYWxsb2NhdGUgaW4gcmV2ZXJzZSBvcmRlciBvZiBhbGxvY2F0aW9uczpcXHJcXG4gICAgICAgICAgICB0aGF0LnBlbmRpbmdfYnVmID0gbnVsbDtcXHJcXG4gICAgICAgICAgICBoZWFkID0gbnVsbDtcXHJcXG4gICAgICAgICAgICBwcmV2ID0gbnVsbDtcXHJcXG4gICAgICAgICAgICB3aW5kb3cgPSBudWxsO1xcclxcbiAgICAgICAgICAgIC8vIGZyZWVcXHJcXG4gICAgICAgICAgICB0aGF0LmRzdGF0ZSA9IG51bGw7XFxyXFxuICAgICAgICAgICAgcmV0dXJuIHN0YXR1cyA9PSBCVVNZX1NUQVRFID8gWl9EQVRBX0VSUk9SIDogWl9PSztcXHJcXG4gICAgICAgIH07XFxyXFxuXFxyXFxuICAgICAgICB0aGF0LmRlZmxhdGVQYXJhbXMgPSBmdW5jdGlvbihzdHJtLCBfbGV2ZWwsIF9zdHJhdGVneSkge1xcclxcbiAgICAgICAgICAgIHZhciBlcnIgPSBaX09LO1xcclxcblxcclxcbiAgICAgICAgICAgIGlmIChfbGV2ZWwgPT0gWl9ERUZBVUxUX0NPTVBSRVNTSU9OKSB7XFxyXFxuICAgICAgICAgICAgICAgIF9sZXZlbCA9IDY7XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIGlmIChfbGV2ZWwgPCAwIHx8IF9sZXZlbCA+IDkgfHwgX3N0cmF0ZWd5IDwgMCB8fCBfc3RyYXRlZ3kgPiBaX0hVRkZNQU5fT05MWSkge1xcclxcbiAgICAgICAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XFxyXFxuICAgICAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgICAgIGlmIChjb25maWdfdGFibGVbbGV2ZWxdLmZ1bmMgIT0gY29uZmlnX3RhYmxlW19sZXZlbF0uZnVuYyAmJiBzdHJtLnRvdGFsX2luICE9PSAwKSB7XFxyXFxuICAgICAgICAgICAgICAgIC8vIEZsdXNoIHRoZSBsYXN0IGJ1ZmZlcjpcXHJcXG4gICAgICAgICAgICAgICAgZXJyID0gc3RybS5kZWZsYXRlKFpfUEFSVElBTF9GTFVTSCk7XFxyXFxuICAgICAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgICAgIGlmIChsZXZlbCAhPSBfbGV2ZWwpIHtcXHJcXG4gICAgICAgICAgICAgICAgbGV2ZWwgPSBfbGV2ZWw7XFxyXFxuICAgICAgICAgICAgICAgIG1heF9sYXp5X21hdGNoID0gY29uZmlnX3RhYmxlW2xldmVsXS5tYXhfbGF6eTtcXHJcXG4gICAgICAgICAgICAgICAgZ29vZF9tYXRjaCA9IGNvbmZpZ190YWJsZVtsZXZlbF0uZ29vZF9sZW5ndGg7XFxyXFxuICAgICAgICAgICAgICAgIG5pY2VfbWF0Y2ggPSBjb25maWdfdGFibGVbbGV2ZWxdLm5pY2VfbGVuZ3RoO1xcclxcbiAgICAgICAgICAgICAgICBtYXhfY2hhaW5fbGVuZ3RoID0gY29uZmlnX3RhYmxlW2xldmVsXS5tYXhfY2hhaW47XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIHN0cmF0ZWd5ID0gX3N0cmF0ZWd5O1xcclxcbiAgICAgICAgICAgIHJldHVybiBlcnI7XFxyXFxuICAgICAgICB9O1xcclxcblxcclxcbiAgICAgICAgdGhhdC5kZWZsYXRlU2V0RGljdGlvbmFyeSA9IGZ1bmN0aW9uKHN0cm0sIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgpIHtcXHJcXG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gZGljdExlbmd0aDtcXHJcXG4gICAgICAgICAgICB2YXIgbiwgaW5kZXggPSAwO1xcclxcblxcclxcbiAgICAgICAgICAgIGlmICghZGljdGlvbmFyeSB8fCBzdGF0dXMgIT0gSU5JVF9TVEFURSlcXHJcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xcclxcblxcclxcbiAgICAgICAgICAgIGlmIChsZW5ndGggPCBNSU5fTUFUQ0gpXFxyXFxuICAgICAgICAgICAgICAgIHJldHVybiBaX09LO1xcclxcbiAgICAgICAgICAgIGlmIChsZW5ndGggPiB3X3NpemUgLSBNSU5fTE9PS0FIRUFEKSB7XFxyXFxuICAgICAgICAgICAgICAgIGxlbmd0aCA9IHdfc2l6ZSAtIE1JTl9MT09LQUhFQUQ7XFxyXFxuICAgICAgICAgICAgICAgIGluZGV4ID0gZGljdExlbmd0aCAtIGxlbmd0aDsgLy8gdXNlIHRoZSB0YWlsIG9mIHRoZSBkaWN0aW9uYXJ5XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIHdpbmRvdy5zZXQoZGljdGlvbmFyeS5zdWJhcnJheShpbmRleCwgaW5kZXggKyBsZW5ndGgpLCAwKTtcXHJcXG5cXHJcXG4gICAgICAgICAgICBzdHJzdGFydCA9IGxlbmd0aDtcXHJcXG4gICAgICAgICAgICBibG9ja19zdGFydCA9IGxlbmd0aDtcXHJcXG5cXHJcXG4gICAgICAgICAgICAvLyBJbnNlcnQgYWxsIHN0cmluZ3MgaW4gdGhlIGhhc2ggdGFibGUgKGV4Y2VwdCBmb3IgdGhlIGxhc3QgdHdvIGJ5dGVzKS5cXHJcXG4gICAgICAgICAgICAvLyBzLT5sb29rYWhlYWQgc3RheXMgbnVsbCwgc28gcy0+aW5zX2ggd2lsbCBiZSByZWNvbXB1dGVkIGF0IHRoZSBuZXh0XFxyXFxuICAgICAgICAgICAgLy8gY2FsbCBvZiBmaWxsX3dpbmRvdy5cXHJcXG5cXHJcXG4gICAgICAgICAgICBpbnNfaCA9IHdpbmRvd1swXSAmIDB4ZmY7XFxyXFxuICAgICAgICAgICAgaW5zX2ggPSAoKChpbnNfaCkgPDwgaGFzaF9zaGlmdCkgXiAod2luZG93WzFdICYgMHhmZikpICYgaGFzaF9tYXNrO1xcclxcblxcclxcbiAgICAgICAgICAgIGZvciAobiA9IDA7IG4gPD0gbGVuZ3RoIC0gTUlOX01BVENIOyBuKyspIHtcXHJcXG4gICAgICAgICAgICAgICAgaW5zX2ggPSAoKChpbnNfaCkgPDwgaGFzaF9zaGlmdCkgXiAod2luZG93WyhuKSArIChNSU5fTUFUQ0ggLSAxKV0gJiAweGZmKSkgJiBoYXNoX21hc2s7XFxyXFxuICAgICAgICAgICAgICAgIHByZXZbbiAmIHdfbWFza10gPSBoZWFkW2luc19oXTtcXHJcXG4gICAgICAgICAgICAgICAgaGVhZFtpbnNfaF0gPSBuO1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICByZXR1cm4gWl9PSztcXHJcXG4gICAgICAgIH07XFxyXFxuXFxyXFxuICAgICAgICB0aGF0LmRlZmxhdGUgPSBmdW5jdGlvbihfc3RybSwgZmx1c2gpIHtcXHJcXG4gICAgICAgICAgICB2YXIgaSwgaGVhZGVyLCBsZXZlbF9mbGFncywgb2xkX2ZsdXNoLCBic3RhdGU7XFxyXFxuXFxyXFxuICAgICAgICAgICAgaWYgKGZsdXNoID4gWl9GSU5JU0ggfHwgZmx1c2ggPCAwKSB7XFxyXFxuICAgICAgICAgICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgaWYgKCFfc3RybS5uZXh0X291dCB8fCAoIV9zdHJtLm5leHRfaW4gJiYgX3N0cm0uYXZhaWxfaW4gIT09IDApIHx8IChzdGF0dXMgPT0gRklOSVNIX1NUQVRFICYmIGZsdXNoICE9IFpfRklOSVNIKSkge1xcclxcbiAgICAgICAgICAgICAgICBfc3RybS5tc2cgPSB6X2Vycm1zZ1taX05FRURfRElDVCAtIChaX1NUUkVBTV9FUlJPUildO1xcclxcbiAgICAgICAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIGlmIChfc3RybS5hdmFpbF9vdXQgPT09IDApIHtcXHJcXG4gICAgICAgICAgICAgICAgX3N0cm0ubXNnID0gel9lcnJtc2dbWl9ORUVEX0RJQ1QgLSAoWl9CVUZfRVJST1IpXTtcXHJcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFpfQlVGX0VSUk9SO1xcclxcbiAgICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICBzdHJtID0gX3N0cm07IC8vIGp1c3QgaW4gY2FzZVxcclxcbiAgICAgICAgICAgIG9sZF9mbHVzaCA9IGxhc3RfZmx1c2g7XFxyXFxuICAgICAgICAgICAgbGFzdF9mbHVzaCA9IGZsdXNoO1xcclxcblxcclxcbiAgICAgICAgICAgIC8vIFdyaXRlIHRoZSB6bGliIGhlYWRlclxcclxcbiAgICAgICAgICAgIGlmIChzdGF0dXMgPT0gSU5JVF9TVEFURSkge1xcclxcbiAgICAgICAgICAgICAgICBoZWFkZXIgPSAoWl9ERUZMQVRFRCArICgod19iaXRzIC0gOCkgPDwgNCkpIDw8IDg7XFxyXFxuICAgICAgICAgICAgICAgIGxldmVsX2ZsYWdzID0gKChsZXZlbCAtIDEpICYgMHhmZikgPj4gMTtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgaWYgKGxldmVsX2ZsYWdzID4gMylcXHJcXG4gICAgICAgICAgICAgICAgICAgIGxldmVsX2ZsYWdzID0gMztcXHJcXG4gICAgICAgICAgICAgICAgaGVhZGVyIHw9IChsZXZlbF9mbGFncyA8PCA2KTtcXHJcXG4gICAgICAgICAgICAgICAgaWYgKHN0cnN0YXJ0ICE9PSAwKVxcclxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyIHw9IFBSRVNFVF9ESUNUO1xcclxcbiAgICAgICAgICAgICAgICBoZWFkZXIgKz0gMzEgLSAoaGVhZGVyICUgMzEpO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICBzdGF0dXMgPSBCVVNZX1NUQVRFO1xcclxcbiAgICAgICAgICAgICAgICBwdXRTaG9ydE1TQihoZWFkZXIpO1xcclxcbiAgICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICAvLyBGbHVzaCBhcyBtdWNoIHBlbmRpbmcgb3V0cHV0IGFzIHBvc3NpYmxlXFxyXFxuICAgICAgICAgICAgaWYgKHRoYXQucGVuZGluZyAhPT0gMCkge1xcclxcbiAgICAgICAgICAgICAgICBzdHJtLmZsdXNoX3BlbmRpbmcoKTtcXHJcXG4gICAgICAgICAgICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcXFwiIGF2YWlsX291dD09MFxcXCIpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgLy8gU2luY2UgYXZhaWxfb3V0IGlzIDAsIGRlZmxhdGUgd2lsbCBiZSBjYWxsZWQgYWdhaW4gd2l0aFxcclxcbiAgICAgICAgICAgICAgICAgICAgLy8gbW9yZSBvdXRwdXQgc3BhY2UsIGJ1dCBwb3NzaWJseSB3aXRoIGJvdGggcGVuZGluZyBhbmRcXHJcXG4gICAgICAgICAgICAgICAgICAgIC8vIGF2YWlsX2luIGVxdWFsIHRvIHplcm8uIFRoZXJlIHdvbid0IGJlIGFueXRoaW5nIHRvIGRvLFxcclxcbiAgICAgICAgICAgICAgICAgICAgLy8gYnV0IHRoaXMgaXMgbm90IGFuIGVycm9yIHNpdHVhdGlvbiBzbyBtYWtlIHN1cmUgd2VcXHJcXG4gICAgICAgICAgICAgICAgICAgIC8vIHJldHVybiBPSyBpbnN0ZWFkIG9mIEJVRl9FUlJPUiBhdCBuZXh0IGNhbGwgb2YgZGVmbGF0ZTpcXHJcXG4gICAgICAgICAgICAgICAgICAgIGxhc3RfZmx1c2ggPSAtMTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBaX09LO1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGVyZSBpcyBzb21ldGhpbmcgdG8gZG8gYW5kIGF2b2lkIGR1cGxpY2F0ZVxcclxcbiAgICAgICAgICAgICAgICAvLyBjb25zZWN1dGl2ZVxcclxcbiAgICAgICAgICAgICAgICAvLyBmbHVzaGVzLiBGb3IgcmVwZWF0ZWQgYW5kIHVzZWxlc3MgY2FsbHMgd2l0aCBaX0ZJTklTSCwgd2Uga2VlcFxcclxcbiAgICAgICAgICAgICAgICAvLyByZXR1cm5pbmcgWl9TVFJFQU1fRU5EIGluc3RlYWQgb2YgWl9CVUZGX0VSUk9SLlxcclxcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RybS5hdmFpbF9pbiA9PT0gMCAmJiBmbHVzaCA8PSBvbGRfZmx1c2ggJiYgZmx1c2ggIT0gWl9GSU5JU0gpIHtcXHJcXG4gICAgICAgICAgICAgICAgc3RybS5tc2cgPSB6X2Vycm1zZ1taX05FRURfRElDVCAtIChaX0JVRl9FUlJPUildO1xcclxcbiAgICAgICAgICAgICAgICByZXR1cm4gWl9CVUZfRVJST1I7XFxyXFxuICAgICAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgICAgIC8vIFVzZXIgbXVzdCBub3QgcHJvdmlkZSBtb3JlIGlucHV0IGFmdGVyIHRoZSBmaXJzdCBGSU5JU0g6XFxyXFxuICAgICAgICAgICAgaWYgKHN0YXR1cyA9PSBGSU5JU0hfU1RBVEUgJiYgc3RybS5hdmFpbF9pbiAhPT0gMCkge1xcclxcbiAgICAgICAgICAgICAgICBfc3RybS5tc2cgPSB6X2Vycm1zZ1taX05FRURfRElDVCAtIChaX0JVRl9FUlJPUildO1xcclxcbiAgICAgICAgICAgICAgICByZXR1cm4gWl9CVUZfRVJST1I7XFxyXFxuICAgICAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgICAgIC8vIFN0YXJ0IGEgbmV3IGJsb2NrIG9yIGNvbnRpbnVlIHRoZSBjdXJyZW50IG9uZS5cXHJcXG4gICAgICAgICAgICBpZiAoc3RybS5hdmFpbF9pbiAhPT0gMCB8fCBsb29rYWhlYWQgIT09IDAgfHwgKGZsdXNoICE9IFpfTk9fRkxVU0ggJiYgc3RhdHVzICE9IEZJTklTSF9TVEFURSkpIHtcXHJcXG4gICAgICAgICAgICAgICAgYnN0YXRlID0gLTE7XFxyXFxuICAgICAgICAgICAgICAgIHN3aXRjaCAoY29uZmlnX3RhYmxlW2xldmVsXS5mdW5jKSB7XFxyXFxuICAgICAgICAgICAgICAgIGNhc2UgU1RPUkVEOlxcclxcbiAgICAgICAgICAgICAgICAgICAgYnN0YXRlID0gZGVmbGF0ZV9zdG9yZWQoZmx1c2gpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxyXFxuICAgICAgICAgICAgICAgIGNhc2UgRkFTVDpcXHJcXG4gICAgICAgICAgICAgICAgICAgIGJzdGF0ZSA9IGRlZmxhdGVfZmFzdChmbHVzaCk7XFxyXFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcXHJcXG4gICAgICAgICAgICAgICAgY2FzZSBTTE9XOlxcclxcbiAgICAgICAgICAgICAgICAgICAgYnN0YXRlID0gZGVmbGF0ZV9zbG93KGZsdXNoKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcclxcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgIGlmIChic3RhdGUgPT0gRmluaXNoU3RhcnRlZCB8fCBic3RhdGUgPT0gRmluaXNoRG9uZSkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzID0gRklOSVNIX1NUQVRFO1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgIGlmIChic3RhdGUgPT0gTmVlZE1vcmUgfHwgYnN0YXRlID09IEZpbmlzaFN0YXJ0ZWQpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RfZmx1c2ggPSAtMTsgLy8gYXZvaWQgQlVGX0VSUk9SIG5leHQgY2FsbCwgc2VlIGFib3ZlXFxyXFxuICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWl9PSztcXHJcXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGZsdXNoICE9IFpfTk9fRkxVU0ggJiYgYXZhaWxfb3V0ID09PSAwLCB0aGUgbmV4dCBjYWxsXFxyXFxuICAgICAgICAgICAgICAgICAgICAvLyBvZiBkZWZsYXRlIHNob3VsZCB1c2UgdGhlIHNhbWUgZmx1c2ggcGFyYW1ldGVyIHRvIG1ha2Ugc3VyZVxcclxcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhhdCB0aGUgZmx1c2ggaXMgY29tcGxldGUuIFNvIHdlIGRvbid0IGhhdmUgdG8gb3V0cHV0IGFuXFxyXFxuICAgICAgICAgICAgICAgICAgICAvLyBlbXB0eSBibG9jayBoZXJlLCB0aGlzIHdpbGwgYmUgZG9uZSBhdCBuZXh0IGNhbGwuIFRoaXMgYWxzb1xcclxcbiAgICAgICAgICAgICAgICAgICAgLy8gZW5zdXJlcyB0aGF0IGZvciBhIHZlcnkgc21hbGwgb3V0cHV0IGJ1ZmZlciwgd2UgZW1pdCBhdCBtb3N0XFxyXFxuICAgICAgICAgICAgICAgICAgICAvLyBvbmUgZW1wdHkgYmxvY2suXFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgaWYgKGJzdGF0ZSA9PSBCbG9ja0RvbmUpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGlmIChmbHVzaCA9PSBaX1BBUlRJQUxfRkxVU0gpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBfdHJfYWxpZ24oKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8vIEZVTExfRkxVU0ggb3IgU1lOQ19GTFVTSFxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIF90cl9zdG9yZWRfYmxvY2soMCwgMCwgZmFsc2UpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZvciBhIGZ1bGwgZmx1c2gsIHRoaXMgZW1wdHkgYmxvY2sgd2lsbCBiZSByZWNvZ25pemVkXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXMgYSBzcGVjaWFsIG1hcmtlciBieSBpbmZsYXRlX3N5bmMoKS5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmx1c2ggPT0gWl9GVUxMX0ZMVVNIKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0YXRlLmhlYWRbcy5oYXNoX3NpemUtMV09MDtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGhhc2hfc2l6ZS8qLTEqLzsgaSsrKVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm9yZ2V0IGhpc3RvcnlcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRbaV0gPSAwO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgICAgIHN0cm0uZmx1c2hfcGVuZGluZygpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdF9mbHVzaCA9IC0xOyAvLyBhdm9pZCBCVUZfRVJST1IgYXQgbmV4dCBjYWxsLCBzZWUgYWJvdmVcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWl9PSztcXHJcXG4gICAgICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICBpZiAoZmx1c2ggIT0gWl9GSU5JU0gpXFxyXFxuICAgICAgICAgICAgICAgIHJldHVybiBaX09LO1xcclxcbiAgICAgICAgICAgIHJldHVybiBaX1NUUkVBTV9FTkQ7XFxyXFxuICAgICAgICB9O1xcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgIC8vIFpTdHJlYW1cXHJcXG5cXHJcXG4gICAgZnVuY3Rpb24gWlN0cmVhbSgpIHtcXHJcXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcXHJcXG4gICAgICAgIHRoYXQubmV4dF9pbl9pbmRleCA9IDA7XFxyXFxuICAgICAgICB0aGF0Lm5leHRfb3V0X2luZGV4ID0gMDtcXHJcXG4gICAgICAgIC8vIHRoYXQubmV4dF9pbjsgLy8gbmV4dCBpbnB1dCBieXRlXFxyXFxuICAgICAgICB0aGF0LmF2YWlsX2luID0gMDsgLy8gbnVtYmVyIG9mIGJ5dGVzIGF2YWlsYWJsZSBhdCBuZXh0X2luXFxyXFxuICAgICAgICB0aGF0LnRvdGFsX2luID0gMDsgLy8gdG90YWwgbmIgb2YgaW5wdXQgYnl0ZXMgcmVhZCBzbyBmYXJcXHJcXG4gICAgICAgIC8vIHRoYXQubmV4dF9vdXQ7IC8vIG5leHQgb3V0cHV0IGJ5dGUgc2hvdWxkIGJlIHB1dCB0aGVyZVxcclxcbiAgICAgICAgdGhhdC5hdmFpbF9vdXQgPSAwOyAvLyByZW1haW5pbmcgZnJlZSBzcGFjZSBhdCBuZXh0X291dFxcclxcbiAgICAgICAgdGhhdC50b3RhbF9vdXQgPSAwOyAvLyB0b3RhbCBuYiBvZiBieXRlcyBvdXRwdXQgc28gZmFyXFxyXFxuICAgICAgICAvLyB0aGF0Lm1zZztcXHJcXG4gICAgICAgIC8vIHRoYXQuZHN0YXRlO1xcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgIFpTdHJlYW0ucHJvdG90eXBlID0ge1xcclxcbiAgICAgICAgZGVmbGF0ZUluaXQgOiBmdW5jdGlvbihsZXZlbCwgYml0cykge1xcclxcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcXHJcXG4gICAgICAgICAgICB0aGF0LmRzdGF0ZSA9IG5ldyBEZWZsYXRlKCk7XFxyXFxuICAgICAgICAgICAgaWYgKCFiaXRzKVxcclxcbiAgICAgICAgICAgICAgICBiaXRzID0gTUFYX0JJVFM7XFxyXFxuICAgICAgICAgICAgcmV0dXJuIHRoYXQuZHN0YXRlLmRlZmxhdGVJbml0KHRoYXQsIGxldmVsLCBiaXRzKTtcXHJcXG4gICAgICAgIH0sXFxyXFxuXFxyXFxuICAgICAgICBkZWZsYXRlIDogZnVuY3Rpb24oZmx1c2gpIHtcXHJcXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XFxyXFxuICAgICAgICAgICAgaWYgKCF0aGF0LmRzdGF0ZSkge1xcclxcbiAgICAgICAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIHJldHVybiB0aGF0LmRzdGF0ZS5kZWZsYXRlKHRoYXQsIGZsdXNoKTtcXHJcXG4gICAgICAgIH0sXFxyXFxuXFxyXFxuICAgICAgICBkZWZsYXRlRW5kIDogZnVuY3Rpb24oKSB7XFxyXFxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xcclxcbiAgICAgICAgICAgIGlmICghdGhhdC5kc3RhdGUpXFxyXFxuICAgICAgICAgICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcXHJcXG4gICAgICAgICAgICB2YXIgcmV0ID0gdGhhdC5kc3RhdGUuZGVmbGF0ZUVuZCgpO1xcclxcbiAgICAgICAgICAgIHRoYXQuZHN0YXRlID0gbnVsbDtcXHJcXG4gICAgICAgICAgICByZXR1cm4gcmV0O1xcclxcbiAgICAgICAgfSxcXHJcXG5cXHJcXG4gICAgICAgIGRlZmxhdGVQYXJhbXMgOiBmdW5jdGlvbihsZXZlbCwgc3RyYXRlZ3kpIHtcXHJcXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XFxyXFxuICAgICAgICAgICAgaWYgKCF0aGF0LmRzdGF0ZSlcXHJcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xcclxcbiAgICAgICAgICAgIHJldHVybiB0aGF0LmRzdGF0ZS5kZWZsYXRlUGFyYW1zKHRoYXQsIGxldmVsLCBzdHJhdGVneSk7XFxyXFxuICAgICAgICB9LFxcclxcblxcclxcbiAgICAgICAgZGVmbGF0ZVNldERpY3Rpb25hcnkgOiBmdW5jdGlvbihkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoKSB7XFxyXFxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xcclxcbiAgICAgICAgICAgIGlmICghdGhhdC5kc3RhdGUpXFxyXFxuICAgICAgICAgICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcXHJcXG4gICAgICAgICAgICByZXR1cm4gdGhhdC5kc3RhdGUuZGVmbGF0ZVNldERpY3Rpb25hcnkodGhhdCwgZGljdGlvbmFyeSwgZGljdExlbmd0aCk7XFxyXFxuICAgICAgICB9LFxcclxcblxcclxcbiAgICAgICAgLy8gUmVhZCBhIG5ldyBidWZmZXIgZnJvbSB0aGUgY3VycmVudCBpbnB1dCBzdHJlYW0sIHVwZGF0ZSB0aGVcXHJcXG4gICAgICAgIC8vIHRvdGFsIG51bWJlciBvZiBieXRlcyByZWFkLiBBbGwgZGVmbGF0ZSgpIGlucHV0IGdvZXMgdGhyb3VnaFxcclxcbiAgICAgICAgLy8gdGhpcyBmdW5jdGlvbiBzbyBzb21lIGFwcGxpY2F0aW9ucyBtYXkgd2lzaCB0byBtb2RpZnkgaXQgdG8gYXZvaWRcXHJcXG4gICAgICAgIC8vIGFsbG9jYXRpbmcgYSBsYXJnZSBzdHJtLT5uZXh0X2luIGJ1ZmZlciBhbmQgY29weWluZyBmcm9tIGl0LlxcclxcbiAgICAgICAgLy8gKFNlZSBhbHNvIGZsdXNoX3BlbmRpbmcoKSkuXFxyXFxuICAgICAgICByZWFkX2J1ZiA6IGZ1bmN0aW9uKGJ1Ziwgc3RhcnQsIHNpemUpIHtcXHJcXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XFxyXFxuICAgICAgICAgICAgdmFyIGxlbiA9IHRoYXQuYXZhaWxfaW47XFxyXFxuICAgICAgICAgICAgaWYgKGxlbiA+IHNpemUpXFxyXFxuICAgICAgICAgICAgICAgIGxlbiA9IHNpemU7XFxyXFxuICAgICAgICAgICAgaWYgKGxlbiA9PT0gMClcXHJcXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XFxyXFxuICAgICAgICAgICAgdGhhdC5hdmFpbF9pbiAtPSBsZW47XFxyXFxuICAgICAgICAgICAgYnVmLnNldCh0aGF0Lm5leHRfaW4uc3ViYXJyYXkodGhhdC5uZXh0X2luX2luZGV4LCB0aGF0Lm5leHRfaW5faW5kZXggKyBsZW4pLCBzdGFydCk7XFxyXFxuICAgICAgICAgICAgdGhhdC5uZXh0X2luX2luZGV4ICs9IGxlbjtcXHJcXG4gICAgICAgICAgICB0aGF0LnRvdGFsX2luICs9IGxlbjtcXHJcXG4gICAgICAgICAgICByZXR1cm4gbGVuO1xcclxcbiAgICAgICAgfSxcXHJcXG5cXHJcXG4gICAgICAgIC8vIEZsdXNoIGFzIG11Y2ggcGVuZGluZyBvdXRwdXQgYXMgcG9zc2libGUuIEFsbCBkZWZsYXRlKCkgb3V0cHV0IGdvZXNcXHJcXG4gICAgICAgIC8vIHRocm91Z2ggdGhpcyBmdW5jdGlvbiBzbyBzb21lIGFwcGxpY2F0aW9ucyBtYXkgd2lzaCB0byBtb2RpZnkgaXRcXHJcXG4gICAgICAgIC8vIHRvIGF2b2lkIGFsbG9jYXRpbmcgYSBsYXJnZSBzdHJtLT5uZXh0X291dCBidWZmZXIgYW5kIGNvcHlpbmcgaW50byBpdC5cXHJcXG4gICAgICAgIC8vIChTZWUgYWxzbyByZWFkX2J1ZigpKS5cXHJcXG4gICAgICAgIGZsdXNoX3BlbmRpbmcgOiBmdW5jdGlvbigpIHtcXHJcXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XFxyXFxuICAgICAgICAgICAgdmFyIGxlbiA9IHRoYXQuZHN0YXRlLnBlbmRpbmc7XFxyXFxuXFxyXFxuICAgICAgICAgICAgaWYgKGxlbiA+IHRoYXQuYXZhaWxfb3V0KVxcclxcbiAgICAgICAgICAgICAgICBsZW4gPSB0aGF0LmF2YWlsX291dDtcXHJcXG4gICAgICAgICAgICBpZiAobGVuID09PSAwKVxcclxcbiAgICAgICAgICAgICAgICByZXR1cm47XFxyXFxuXFxyXFxuICAgICAgICAgICAgLy8gaWYgKHRoYXQuZHN0YXRlLnBlbmRpbmdfYnVmLmxlbmd0aCA8PSB0aGF0LmRzdGF0ZS5wZW5kaW5nX291dCB8fCB0aGF0Lm5leHRfb3V0Lmxlbmd0aCA8PSB0aGF0Lm5leHRfb3V0X2luZGV4XFxyXFxuICAgICAgICAgICAgLy8gfHwgdGhhdC5kc3RhdGUucGVuZGluZ19idWYubGVuZ3RoIDwgKHRoYXQuZHN0YXRlLnBlbmRpbmdfb3V0ICsgbGVuKSB8fCB0aGF0Lm5leHRfb3V0Lmxlbmd0aCA8ICh0aGF0Lm5leHRfb3V0X2luZGV4ICtcXHJcXG4gICAgICAgICAgICAvLyBsZW4pKSB7XFxyXFxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2codGhhdC5kc3RhdGUucGVuZGluZ19idWYubGVuZ3RoICsgXFxcIiwgXFxcIiArIHRoYXQuZHN0YXRlLnBlbmRpbmdfb3V0ICsgXFxcIiwgXFxcIiArIHRoYXQubmV4dF9vdXQubGVuZ3RoICsgXFxcIiwgXFxcIiArXFxyXFxuICAgICAgICAgICAgLy8gdGhhdC5uZXh0X291dF9pbmRleCArIFxcXCIsIFxcXCIgKyBsZW4pO1xcclxcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFxcXCJhdmFpbF9vdXQ9XFxcIiArIHRoYXQuYXZhaWxfb3V0KTtcXHJcXG4gICAgICAgICAgICAvLyB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgdGhhdC5uZXh0X291dC5zZXQodGhhdC5kc3RhdGUucGVuZGluZ19idWYuc3ViYXJyYXkodGhhdC5kc3RhdGUucGVuZGluZ19vdXQsIHRoYXQuZHN0YXRlLnBlbmRpbmdfb3V0ICsgbGVuKSwgdGhhdC5uZXh0X291dF9pbmRleCk7XFxyXFxuXFxyXFxuICAgICAgICAgICAgdGhhdC5uZXh0X291dF9pbmRleCArPSBsZW47XFxyXFxuICAgICAgICAgICAgdGhhdC5kc3RhdGUucGVuZGluZ19vdXQgKz0gbGVuO1xcclxcbiAgICAgICAgICAgIHRoYXQudG90YWxfb3V0ICs9IGxlbjtcXHJcXG4gICAgICAgICAgICB0aGF0LmF2YWlsX291dCAtPSBsZW47XFxyXFxuICAgICAgICAgICAgdGhhdC5kc3RhdGUucGVuZGluZyAtPSBsZW47XFxyXFxuICAgICAgICAgICAgaWYgKHRoYXQuZHN0YXRlLnBlbmRpbmcgPT09IDApIHtcXHJcXG4gICAgICAgICAgICAgICAgdGhhdC5kc3RhdGUucGVuZGluZ19vdXQgPSAwO1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH1cXHJcXG4gICAgfTtcXHJcXG5cXHJcXG4gICAgLy8gRGVmbGF0ZXJcXHJcXG5cXHJcXG4gICAgZnVuY3Rpb24gRGVmbGF0ZXIob3B0aW9ucykge1xcclxcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xcclxcbiAgICAgICAgdmFyIHogPSBuZXcgWlN0cmVhbSgpO1xcclxcbiAgICAgICAgdmFyIGJ1ZnNpemUgPSA1MTI7XFxyXFxuICAgICAgICB2YXIgZmx1c2ggPSBaX05PX0ZMVVNIO1xcclxcbiAgICAgICAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGJ1ZnNpemUpO1xcclxcbiAgICAgICAgdmFyIGxldmVsID0gb3B0aW9ucyA/IG9wdGlvbnMubGV2ZWwgOiBaX0RFRkFVTFRfQ09NUFJFU1NJT047XFxyXFxuICAgICAgICBpZiAodHlwZW9mIGxldmVsID09IFxcXCJ1bmRlZmluZWRcXFwiKVxcclxcbiAgICAgICAgICAgIGxldmVsID0gWl9ERUZBVUxUX0NPTVBSRVNTSU9OO1xcclxcbiAgICAgICAgei5kZWZsYXRlSW5pdChsZXZlbCk7XFxyXFxuICAgICAgICB6Lm5leHRfb3V0ID0gYnVmO1xcclxcblxcclxcbiAgICAgICAgdGhhdC5hcHBlbmQgPSBmdW5jdGlvbihkYXRhLCBvbnByb2dyZXNzKSB7XFxyXFxuICAgICAgICAgICAgdmFyIGVyciwgYnVmZmVycyA9IFtdLCBsYXN0SW5kZXggPSAwLCBidWZmZXJJbmRleCA9IDAsIGJ1ZmZlclNpemUgPSAwLCBhcnJheTtcXHJcXG4gICAgICAgICAgICBpZiAoIWRhdGEubGVuZ3RoKVxcclxcbiAgICAgICAgICAgICAgICByZXR1cm47XFxyXFxuICAgICAgICAgICAgei5uZXh0X2luX2luZGV4ID0gMDtcXHJcXG4gICAgICAgICAgICB6Lm5leHRfaW4gPSBkYXRhO1xcclxcbiAgICAgICAgICAgIHouYXZhaWxfaW4gPSBkYXRhLmxlbmd0aDtcXHJcXG4gICAgICAgICAgICBkbyB7XFxyXFxuICAgICAgICAgICAgICAgIHoubmV4dF9vdXRfaW5kZXggPSAwO1xcclxcbiAgICAgICAgICAgICAgICB6LmF2YWlsX291dCA9IGJ1ZnNpemU7XFxyXFxuICAgICAgICAgICAgICAgIGVyciA9IHouZGVmbGF0ZShmbHVzaCk7XFxyXFxuICAgICAgICAgICAgICAgIGlmIChlcnIgIT0gWl9PSylcXHJcXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcXFwiZGVmbGF0aW5nOiBcXFwiICsgei5tc2cpO1xcclxcbiAgICAgICAgICAgICAgICBpZiAoei5uZXh0X291dF9pbmRleClcXHJcXG4gICAgICAgICAgICAgICAgICAgIGlmICh6Lm5leHRfb3V0X2luZGV4ID09IGJ1ZnNpemUpXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVycy5wdXNoKG5ldyBVaW50OEFycmF5KGJ1ZikpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlcnMucHVzaChuZXcgVWludDhBcnJheShidWYuc3ViYXJyYXkoMCwgei5uZXh0X291dF9pbmRleCkpKTtcXHJcXG4gICAgICAgICAgICAgICAgYnVmZmVyU2l6ZSArPSB6Lm5leHRfb3V0X2luZGV4O1xcclxcbiAgICAgICAgICAgICAgICBpZiAob25wcm9ncmVzcyAmJiB6Lm5leHRfaW5faW5kZXggPiAwICYmIHoubmV4dF9pbl9pbmRleCAhPSBsYXN0SW5kZXgpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIG9ucHJvZ3Jlc3Moei5uZXh0X2luX2luZGV4KTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGxhc3RJbmRleCA9IHoubmV4dF9pbl9pbmRleDtcXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIH0gd2hpbGUgKHouYXZhaWxfaW4gPiAwIHx8IHouYXZhaWxfb3V0ID09PSAwKTtcXHJcXG4gICAgICAgICAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlclNpemUpO1xcclxcbiAgICAgICAgICAgIGJ1ZmZlcnMuZm9yRWFjaChmdW5jdGlvbihjaHVuaykge1xcclxcbiAgICAgICAgICAgICAgICBhcnJheS5zZXQoY2h1bmssIGJ1ZmZlckluZGV4KTtcXHJcXG4gICAgICAgICAgICAgICAgYnVmZmVySW5kZXggKz0gY2h1bmsubGVuZ3RoO1xcclxcbiAgICAgICAgICAgIH0pO1xcclxcbiAgICAgICAgICAgIHJldHVybiBhcnJheTtcXHJcXG4gICAgICAgIH07XFxyXFxuICAgICAgICB0aGF0LmZsdXNoID0gZnVuY3Rpb24oKSB7XFxyXFxuICAgICAgICAgICAgdmFyIGVyciwgYnVmZmVycyA9IFtdLCBidWZmZXJJbmRleCA9IDAsIGJ1ZmZlclNpemUgPSAwLCBhcnJheTtcXHJcXG4gICAgICAgICAgICBkbyB7XFxyXFxuICAgICAgICAgICAgICAgIHoubmV4dF9vdXRfaW5kZXggPSAwO1xcclxcbiAgICAgICAgICAgICAgICB6LmF2YWlsX291dCA9IGJ1ZnNpemU7XFxyXFxuICAgICAgICAgICAgICAgIGVyciA9IHouZGVmbGF0ZShaX0ZJTklTSCk7XFxyXFxuICAgICAgICAgICAgICAgIGlmIChlcnIgIT0gWl9TVFJFQU1fRU5EICYmIGVyciAhPSBaX09LKVxcclxcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxcXCJkZWZsYXRpbmc6IFxcXCIgKyB6Lm1zZyk7XFxyXFxuICAgICAgICAgICAgICAgIGlmIChidWZzaXplIC0gei5hdmFpbF9vdXQgPiAwKVxcclxcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVycy5wdXNoKG5ldyBVaW50OEFycmF5KGJ1Zi5zdWJhcnJheSgwLCB6Lm5leHRfb3V0X2luZGV4KSkpO1xcclxcbiAgICAgICAgICAgICAgICBidWZmZXJTaXplICs9IHoubmV4dF9vdXRfaW5kZXg7XFxyXFxuICAgICAgICAgICAgfSB3aGlsZSAoei5hdmFpbF9pbiA+IDAgfHwgei5hdmFpbF9vdXQgPT09IDApO1xcclxcbiAgICAgICAgICAgIHouZGVmbGF0ZUVuZCgpO1xcclxcbiAgICAgICAgICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyU2l6ZSk7XFxyXFxuICAgICAgICAgICAgYnVmZmVycy5mb3JFYWNoKGZ1bmN0aW9uKGNodW5rKSB7XFxyXFxuICAgICAgICAgICAgICAgIGFycmF5LnNldChjaHVuaywgYnVmZmVySW5kZXgpO1xcclxcbiAgICAgICAgICAgICAgICBidWZmZXJJbmRleCArPSBjaHVuay5sZW5ndGg7XFxyXFxuICAgICAgICAgICAgfSk7XFxyXFxuICAgICAgICAgICAgcmV0dXJuIGFycmF5O1xcclxcbiAgICAgICAgfTtcXHJcXG4gICAgfVxcclxcblxcclxcbiAgICAvLyAnemlwJyBtYXkgbm90IGJlIGRlZmluZWQgaW4gei13b3JrZXIgYW5kIHNvbWUgdGVzdHNcXHJcXG4gICAgdmFyIGVudiA9IGdsb2JhbC56aXAgfHwgZ2xvYmFsO1xcclxcbiAgICBlbnYuRGVmbGF0ZXIgPSBlbnYuX2p6bGliX0RlZmxhdGVyID0gRGVmbGF0ZXI7XFxyXFxufSkodGhpcyk7XCI7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFwiLypcXHJcXG4gQ29weXJpZ2h0IChjKSAyMDEzIEdpbGRhcyBMb3JtZWF1LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxcclxcblxcclxcbiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcXHJcXG4gbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XFxyXFxuXFxyXFxuIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcXHJcXG4gdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cXHJcXG5cXHJcXG4gMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcXHJcXG4gbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluXFxyXFxuIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxcclxcblxcclxcbiAzLiBUaGUgbmFtZXMgb2YgdGhlIGF1dGhvcnMgbWF5IG5vdCBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0c1xcclxcbiBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cXHJcXG5cXHJcXG4gVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBgYEFTIElTJycgQU5EIEFOWSBFWFBSRVNTRUQgT1IgSU1QTElFRCBXQVJSQU5USUVTLFxcclxcbiBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EXFxyXFxuIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBKQ1JBRlQsXFxyXFxuIElOQy4gT1IgQU5ZIENPTlRSSUJVVE9SUyBUTyBUSElTIFNPRlRXQVJFIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsXFxyXFxuIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1RcXHJcXG4gTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsXFxyXFxuIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0ZcXHJcXG4gTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkdcXHJcXG4gTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLFxcclxcbiBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxcclxcbiAqL1xcclxcblxcclxcbi8qXFxyXFxuICogVGhpcyBwcm9ncmFtIGlzIGJhc2VkIG9uIEpabGliIDEuMC4yIHltbmssIEpDcmFmdCxJbmMuXFxyXFxuICogSlpsaWIgaXMgYmFzZWQgb24gemxpYi0xLjEuMywgc28gYWxsIGNyZWRpdCBzaG91bGQgZ28gYXV0aG9yc1xcclxcbiAqIEplYW4tbG91cCBHYWlsbHkoamxvdXBAZ3ppcC5vcmcpIGFuZCBNYXJrIEFkbGVyKG1hZGxlckBhbHVtbmkuY2FsdGVjaC5lZHUpXFxyXFxuICogYW5kIGNvbnRyaWJ1dG9ycyBvZiB6bGliLlxcclxcbiAqL1xcclxcblxcclxcbihmdW5jdGlvbihnbG9iYWwpIHtcXHJcXG4gICAgXFxcInVzZSBzdHJpY3RcXFwiO1xcclxcblxcclxcbiAgICAvLyBHbG9iYWxcXHJcXG4gICAgdmFyIE1BWF9CSVRTID0gMTU7XFxyXFxuXFxyXFxuICAgIHZhciBaX09LID0gMDtcXHJcXG4gICAgdmFyIFpfU1RSRUFNX0VORCA9IDE7XFxyXFxuICAgIHZhciBaX05FRURfRElDVCA9IDI7XFxyXFxuICAgIHZhciBaX1NUUkVBTV9FUlJPUiA9IC0yO1xcclxcbiAgICB2YXIgWl9EQVRBX0VSUk9SID0gLTM7XFxyXFxuICAgIHZhciBaX01FTV9FUlJPUiA9IC00O1xcclxcbiAgICB2YXIgWl9CVUZfRVJST1IgPSAtNTtcXHJcXG5cXHJcXG4gICAgdmFyIGluZmxhdGVfbWFzayA9IFsgMHgwMDAwMDAwMCwgMHgwMDAwMDAwMSwgMHgwMDAwMDAwMywgMHgwMDAwMDAwNywgMHgwMDAwMDAwZiwgMHgwMDAwMDAxZiwgMHgwMDAwMDAzZiwgMHgwMDAwMDA3ZiwgMHgwMDAwMDBmZiwgMHgwMDAwMDFmZiwgMHgwMDAwMDNmZixcXHJcXG4gICAgICAgICAgICAweDAwMDAwN2ZmLCAweDAwMDAwZmZmLCAweDAwMDAxZmZmLCAweDAwMDAzZmZmLCAweDAwMDA3ZmZmLCAweDAwMDBmZmZmIF07XFxyXFxuXFxyXFxuICAgIHZhciBNQU5ZID0gMTQ0MDtcXHJcXG5cXHJcXG4gICAgLy8gSlpsaWIgdmVyc2lvbiA6IFxcXCIxLjAuMlxcXCJcXHJcXG4gICAgdmFyIFpfTk9fRkxVU0ggPSAwO1xcclxcbiAgICB2YXIgWl9GSU5JU0ggPSA0O1xcclxcblxcclxcbiAgICAvLyBJbmZUcmVlXFxyXFxuICAgIHZhciBmaXhlZF9ibCA9IDk7XFxyXFxuICAgIHZhciBmaXhlZF9iZCA9IDU7XFxyXFxuXFxyXFxuICAgIHZhciBmaXhlZF90bCA9IFsgOTYsIDcsIDI1NiwgMCwgOCwgODAsIDAsIDgsIDE2LCA4NCwgOCwgMTE1LCA4MiwgNywgMzEsIDAsIDgsIDExMiwgMCwgOCwgNDgsIDAsIDksIDE5MiwgODAsIDcsIDEwLCAwLCA4LCA5NiwgMCwgOCwgMzIsIDAsIDksIDE2MCwgMCwgOCwgMCxcXHJcXG4gICAgICAgICAgICAwLCA4LCAxMjgsIDAsIDgsIDY0LCAwLCA5LCAyMjQsIDgwLCA3LCA2LCAwLCA4LCA4OCwgMCwgOCwgMjQsIDAsIDksIDE0NCwgODMsIDcsIDU5LCAwLCA4LCAxMjAsIDAsIDgsIDU2LCAwLCA5LCAyMDgsIDgxLCA3LCAxNywgMCwgOCwgMTA0LCAwLCA4LCA0MCxcXHJcXG4gICAgICAgICAgICAwLCA5LCAxNzYsIDAsIDgsIDgsIDAsIDgsIDEzNiwgMCwgOCwgNzIsIDAsIDksIDI0MCwgODAsIDcsIDQsIDAsIDgsIDg0LCAwLCA4LCAyMCwgODUsIDgsIDIyNywgODMsIDcsIDQzLCAwLCA4LCAxMTYsIDAsIDgsIDUyLCAwLCA5LCAyMDAsIDgxLCA3LCAxMyxcXHJcXG4gICAgICAgICAgICAwLCA4LCAxMDAsIDAsIDgsIDM2LCAwLCA5LCAxNjgsIDAsIDgsIDQsIDAsIDgsIDEzMiwgMCwgOCwgNjgsIDAsIDksIDIzMiwgODAsIDcsIDgsIDAsIDgsIDkyLCAwLCA4LCAyOCwgMCwgOSwgMTUyLCA4NCwgNywgODMsIDAsIDgsIDEyNCwgMCwgOCwgNjAsXFxyXFxuICAgICAgICAgICAgMCwgOSwgMjE2LCA4MiwgNywgMjMsIDAsIDgsIDEwOCwgMCwgOCwgNDQsIDAsIDksIDE4NCwgMCwgOCwgMTIsIDAsIDgsIDE0MCwgMCwgOCwgNzYsIDAsIDksIDI0OCwgODAsIDcsIDMsIDAsIDgsIDgyLCAwLCA4LCAxOCwgODUsIDgsIDE2MywgODMsIDcsXFxyXFxuICAgICAgICAgICAgMzUsIDAsIDgsIDExNCwgMCwgOCwgNTAsIDAsIDksIDE5NiwgODEsIDcsIDExLCAwLCA4LCA5OCwgMCwgOCwgMzQsIDAsIDksIDE2NCwgMCwgOCwgMiwgMCwgOCwgMTMwLCAwLCA4LCA2NiwgMCwgOSwgMjI4LCA4MCwgNywgNywgMCwgOCwgOTAsIDAsIDgsXFxyXFxuICAgICAgICAgICAgMjYsIDAsIDksIDE0OCwgODQsIDcsIDY3LCAwLCA4LCAxMjIsIDAsIDgsIDU4LCAwLCA5LCAyMTIsIDgyLCA3LCAxOSwgMCwgOCwgMTA2LCAwLCA4LCA0MiwgMCwgOSwgMTgwLCAwLCA4LCAxMCwgMCwgOCwgMTM4LCAwLCA4LCA3NCwgMCwgOSwgMjQ0LCA4MCxcXHJcXG4gICAgICAgICAgICA3LCA1LCAwLCA4LCA4NiwgMCwgOCwgMjIsIDE5MiwgOCwgMCwgODMsIDcsIDUxLCAwLCA4LCAxMTgsIDAsIDgsIDU0LCAwLCA5LCAyMDQsIDgxLCA3LCAxNSwgMCwgOCwgMTAyLCAwLCA4LCAzOCwgMCwgOSwgMTcyLCAwLCA4LCA2LCAwLCA4LCAxMzQsIDAsXFxyXFxuICAgICAgICAgICAgOCwgNzAsIDAsIDksIDIzNiwgODAsIDcsIDksIDAsIDgsIDk0LCAwLCA4LCAzMCwgMCwgOSwgMTU2LCA4NCwgNywgOTksIDAsIDgsIDEyNiwgMCwgOCwgNjIsIDAsIDksIDIyMCwgODIsIDcsIDI3LCAwLCA4LCAxMTAsIDAsIDgsIDQ2LCAwLCA5LCAxODgsIDAsXFxyXFxuICAgICAgICAgICAgOCwgMTQsIDAsIDgsIDE0MiwgMCwgOCwgNzgsIDAsIDksIDI1MiwgOTYsIDcsIDI1NiwgMCwgOCwgODEsIDAsIDgsIDE3LCA4NSwgOCwgMTMxLCA4MiwgNywgMzEsIDAsIDgsIDExMywgMCwgOCwgNDksIDAsIDksIDE5NCwgODAsIDcsIDEwLCAwLCA4LCA5NyxcXHJcXG4gICAgICAgICAgICAwLCA4LCAzMywgMCwgOSwgMTYyLCAwLCA4LCAxLCAwLCA4LCAxMjksIDAsIDgsIDY1LCAwLCA5LCAyMjYsIDgwLCA3LCA2LCAwLCA4LCA4OSwgMCwgOCwgMjUsIDAsIDksIDE0NiwgODMsIDcsIDU5LCAwLCA4LCAxMjEsIDAsIDgsIDU3LCAwLCA5LCAyMTAsXFxyXFxuICAgICAgICAgICAgODEsIDcsIDE3LCAwLCA4LCAxMDUsIDAsIDgsIDQxLCAwLCA5LCAxNzgsIDAsIDgsIDksIDAsIDgsIDEzNywgMCwgOCwgNzMsIDAsIDksIDI0MiwgODAsIDcsIDQsIDAsIDgsIDg1LCAwLCA4LCAyMSwgODAsIDgsIDI1OCwgODMsIDcsIDQzLCAwLCA4LCAxMTcsXFxyXFxuICAgICAgICAgICAgMCwgOCwgNTMsIDAsIDksIDIwMiwgODEsIDcsIDEzLCAwLCA4LCAxMDEsIDAsIDgsIDM3LCAwLCA5LCAxNzAsIDAsIDgsIDUsIDAsIDgsIDEzMywgMCwgOCwgNjksIDAsIDksIDIzNCwgODAsIDcsIDgsIDAsIDgsIDkzLCAwLCA4LCAyOSwgMCwgOSwgMTU0LFxcclxcbiAgICAgICAgICAgIDg0LCA3LCA4MywgMCwgOCwgMTI1LCAwLCA4LCA2MSwgMCwgOSwgMjE4LCA4MiwgNywgMjMsIDAsIDgsIDEwOSwgMCwgOCwgNDUsIDAsIDksIDE4NiwgMCwgOCwgMTMsIDAsIDgsIDE0MSwgMCwgOCwgNzcsIDAsIDksIDI1MCwgODAsIDcsIDMsIDAsIDgsIDgzLFxcclxcbiAgICAgICAgICAgIDAsIDgsIDE5LCA4NSwgOCwgMTk1LCA4MywgNywgMzUsIDAsIDgsIDExNSwgMCwgOCwgNTEsIDAsIDksIDE5OCwgODEsIDcsIDExLCAwLCA4LCA5OSwgMCwgOCwgMzUsIDAsIDksIDE2NiwgMCwgOCwgMywgMCwgOCwgMTMxLCAwLCA4LCA2NywgMCwgOSwgMjMwLFxcclxcbiAgICAgICAgICAgIDgwLCA3LCA3LCAwLCA4LCA5MSwgMCwgOCwgMjcsIDAsIDksIDE1MCwgODQsIDcsIDY3LCAwLCA4LCAxMjMsIDAsIDgsIDU5LCAwLCA5LCAyMTQsIDgyLCA3LCAxOSwgMCwgOCwgMTA3LCAwLCA4LCA0MywgMCwgOSwgMTgyLCAwLCA4LCAxMSwgMCwgOCwgMTM5LFxcclxcbiAgICAgICAgICAgIDAsIDgsIDc1LCAwLCA5LCAyNDYsIDgwLCA3LCA1LCAwLCA4LCA4NywgMCwgOCwgMjMsIDE5MiwgOCwgMCwgODMsIDcsIDUxLCAwLCA4LCAxMTksIDAsIDgsIDU1LCAwLCA5LCAyMDYsIDgxLCA3LCAxNSwgMCwgOCwgMTAzLCAwLCA4LCAzOSwgMCwgOSwgMTc0LFxcclxcbiAgICAgICAgICAgIDAsIDgsIDcsIDAsIDgsIDEzNSwgMCwgOCwgNzEsIDAsIDksIDIzOCwgODAsIDcsIDksIDAsIDgsIDk1LCAwLCA4LCAzMSwgMCwgOSwgMTU4LCA4NCwgNywgOTksIDAsIDgsIDEyNywgMCwgOCwgNjMsIDAsIDksIDIyMiwgODIsIDcsIDI3LCAwLCA4LCAxMTEsXFxyXFxuICAgICAgICAgICAgMCwgOCwgNDcsIDAsIDksIDE5MCwgMCwgOCwgMTUsIDAsIDgsIDE0MywgMCwgOCwgNzksIDAsIDksIDI1NCwgOTYsIDcsIDI1NiwgMCwgOCwgODAsIDAsIDgsIDE2LCA4NCwgOCwgMTE1LCA4MiwgNywgMzEsIDAsIDgsIDExMiwgMCwgOCwgNDgsIDAsIDksXFxyXFxuICAgICAgICAgICAgMTkzLCA4MCwgNywgMTAsIDAsIDgsIDk2LCAwLCA4LCAzMiwgMCwgOSwgMTYxLCAwLCA4LCAwLCAwLCA4LCAxMjgsIDAsIDgsIDY0LCAwLCA5LCAyMjUsIDgwLCA3LCA2LCAwLCA4LCA4OCwgMCwgOCwgMjQsIDAsIDksIDE0NSwgODMsIDcsIDU5LCAwLCA4LFxcclxcbiAgICAgICAgICAgIDEyMCwgMCwgOCwgNTYsIDAsIDksIDIwOSwgODEsIDcsIDE3LCAwLCA4LCAxMDQsIDAsIDgsIDQwLCAwLCA5LCAxNzcsIDAsIDgsIDgsIDAsIDgsIDEzNiwgMCwgOCwgNzIsIDAsIDksIDI0MSwgODAsIDcsIDQsIDAsIDgsIDg0LCAwLCA4LCAyMCwgODUsIDgsXFxyXFxuICAgICAgICAgICAgMjI3LCA4MywgNywgNDMsIDAsIDgsIDExNiwgMCwgOCwgNTIsIDAsIDksIDIwMSwgODEsIDcsIDEzLCAwLCA4LCAxMDAsIDAsIDgsIDM2LCAwLCA5LCAxNjksIDAsIDgsIDQsIDAsIDgsIDEzMiwgMCwgOCwgNjgsIDAsIDksIDIzMywgODAsIDcsIDgsIDAsIDgsXFxyXFxuICAgICAgICAgICAgOTIsIDAsIDgsIDI4LCAwLCA5LCAxNTMsIDg0LCA3LCA4MywgMCwgOCwgMTI0LCAwLCA4LCA2MCwgMCwgOSwgMjE3LCA4MiwgNywgMjMsIDAsIDgsIDEwOCwgMCwgOCwgNDQsIDAsIDksIDE4NSwgMCwgOCwgMTIsIDAsIDgsIDE0MCwgMCwgOCwgNzYsIDAsIDksXFxyXFxuICAgICAgICAgICAgMjQ5LCA4MCwgNywgMywgMCwgOCwgODIsIDAsIDgsIDE4LCA4NSwgOCwgMTYzLCA4MywgNywgMzUsIDAsIDgsIDExNCwgMCwgOCwgNTAsIDAsIDksIDE5NywgODEsIDcsIDExLCAwLCA4LCA5OCwgMCwgOCwgMzQsIDAsIDksIDE2NSwgMCwgOCwgMiwgMCwgOCxcXHJcXG4gICAgICAgICAgICAxMzAsIDAsIDgsIDY2LCAwLCA5LCAyMjksIDgwLCA3LCA3LCAwLCA4LCA5MCwgMCwgOCwgMjYsIDAsIDksIDE0OSwgODQsIDcsIDY3LCAwLCA4LCAxMjIsIDAsIDgsIDU4LCAwLCA5LCAyMTMsIDgyLCA3LCAxOSwgMCwgOCwgMTA2LCAwLCA4LCA0MiwgMCwgOSxcXHJcXG4gICAgICAgICAgICAxODEsIDAsIDgsIDEwLCAwLCA4LCAxMzgsIDAsIDgsIDc0LCAwLCA5LCAyNDUsIDgwLCA3LCA1LCAwLCA4LCA4NiwgMCwgOCwgMjIsIDE5MiwgOCwgMCwgODMsIDcsIDUxLCAwLCA4LCAxMTgsIDAsIDgsIDU0LCAwLCA5LCAyMDUsIDgxLCA3LCAxNSwgMCwgOCxcXHJcXG4gICAgICAgICAgICAxMDIsIDAsIDgsIDM4LCAwLCA5LCAxNzMsIDAsIDgsIDYsIDAsIDgsIDEzNCwgMCwgOCwgNzAsIDAsIDksIDIzNywgODAsIDcsIDksIDAsIDgsIDk0LCAwLCA4LCAzMCwgMCwgOSwgMTU3LCA4NCwgNywgOTksIDAsIDgsIDEyNiwgMCwgOCwgNjIsIDAsIDksXFxyXFxuICAgICAgICAgICAgMjIxLCA4MiwgNywgMjcsIDAsIDgsIDExMCwgMCwgOCwgNDYsIDAsIDksIDE4OSwgMCwgOCwgMTQsIDAsIDgsIDE0MiwgMCwgOCwgNzgsIDAsIDksIDI1MywgOTYsIDcsIDI1NiwgMCwgOCwgODEsIDAsIDgsIDE3LCA4NSwgOCwgMTMxLCA4MiwgNywgMzEsIDAsXFxyXFxuICAgICAgICAgICAgOCwgMTEzLCAwLCA4LCA0OSwgMCwgOSwgMTk1LCA4MCwgNywgMTAsIDAsIDgsIDk3LCAwLCA4LCAzMywgMCwgOSwgMTYzLCAwLCA4LCAxLCAwLCA4LCAxMjksIDAsIDgsIDY1LCAwLCA5LCAyMjcsIDgwLCA3LCA2LCAwLCA4LCA4OSwgMCwgOCwgMjUsIDAsIDksXFxyXFxuICAgICAgICAgICAgMTQ3LCA4MywgNywgNTksIDAsIDgsIDEyMSwgMCwgOCwgNTcsIDAsIDksIDIxMSwgODEsIDcsIDE3LCAwLCA4LCAxMDUsIDAsIDgsIDQxLCAwLCA5LCAxNzksIDAsIDgsIDksIDAsIDgsIDEzNywgMCwgOCwgNzMsIDAsIDksIDI0MywgODAsIDcsIDQsIDAsIDgsXFxyXFxuICAgICAgICAgICAgODUsIDAsIDgsIDIxLCA4MCwgOCwgMjU4LCA4MywgNywgNDMsIDAsIDgsIDExNywgMCwgOCwgNTMsIDAsIDksIDIwMywgODEsIDcsIDEzLCAwLCA4LCAxMDEsIDAsIDgsIDM3LCAwLCA5LCAxNzEsIDAsIDgsIDUsIDAsIDgsIDEzMywgMCwgOCwgNjksIDAsIDksXFxyXFxuICAgICAgICAgICAgMjM1LCA4MCwgNywgOCwgMCwgOCwgOTMsIDAsIDgsIDI5LCAwLCA5LCAxNTUsIDg0LCA3LCA4MywgMCwgOCwgMTI1LCAwLCA4LCA2MSwgMCwgOSwgMjE5LCA4MiwgNywgMjMsIDAsIDgsIDEwOSwgMCwgOCwgNDUsIDAsIDksIDE4NywgMCwgOCwgMTMsIDAsIDgsXFxyXFxuICAgICAgICAgICAgMTQxLCAwLCA4LCA3NywgMCwgOSwgMjUxLCA4MCwgNywgMywgMCwgOCwgODMsIDAsIDgsIDE5LCA4NSwgOCwgMTk1LCA4MywgNywgMzUsIDAsIDgsIDExNSwgMCwgOCwgNTEsIDAsIDksIDE5OSwgODEsIDcsIDExLCAwLCA4LCA5OSwgMCwgOCwgMzUsIDAsIDksXFxyXFxuICAgICAgICAgICAgMTY3LCAwLCA4LCAzLCAwLCA4LCAxMzEsIDAsIDgsIDY3LCAwLCA5LCAyMzEsIDgwLCA3LCA3LCAwLCA4LCA5MSwgMCwgOCwgMjcsIDAsIDksIDE1MSwgODQsIDcsIDY3LCAwLCA4LCAxMjMsIDAsIDgsIDU5LCAwLCA5LCAyMTUsIDgyLCA3LCAxOSwgMCwgOCxcXHJcXG4gICAgICAgICAgICAxMDcsIDAsIDgsIDQzLCAwLCA5LCAxODMsIDAsIDgsIDExLCAwLCA4LCAxMzksIDAsIDgsIDc1LCAwLCA5LCAyNDcsIDgwLCA3LCA1LCAwLCA4LCA4NywgMCwgOCwgMjMsIDE5MiwgOCwgMCwgODMsIDcsIDUxLCAwLCA4LCAxMTksIDAsIDgsIDU1LCAwLCA5LFxcclxcbiAgICAgICAgICAgIDIwNywgODEsIDcsIDE1LCAwLCA4LCAxMDMsIDAsIDgsIDM5LCAwLCA5LCAxNzUsIDAsIDgsIDcsIDAsIDgsIDEzNSwgMCwgOCwgNzEsIDAsIDksIDIzOSwgODAsIDcsIDksIDAsIDgsIDk1LCAwLCA4LCAzMSwgMCwgOSwgMTU5LCA4NCwgNywgOTksIDAsIDgsXFxyXFxuICAgICAgICAgICAgMTI3LCAwLCA4LCA2MywgMCwgOSwgMjIzLCA4MiwgNywgMjcsIDAsIDgsIDExMSwgMCwgOCwgNDcsIDAsIDksIDE5MSwgMCwgOCwgMTUsIDAsIDgsIDE0MywgMCwgOCwgNzksIDAsIDksIDI1NSBdO1xcclxcbiAgICB2YXIgZml4ZWRfdGQgPSBbIDgwLCA1LCAxLCA4NywgNSwgMjU3LCA4MywgNSwgMTcsIDkxLCA1LCA0MDk3LCA4MSwgNSwgNSwgODksIDUsIDEwMjUsIDg1LCA1LCA2NSwgOTMsIDUsIDE2Mzg1LCA4MCwgNSwgMywgODgsIDUsIDUxMywgODQsIDUsIDMzLCA5MiwgNSxcXHJcXG4gICAgICAgICAgICA4MTkzLCA4MiwgNSwgOSwgOTAsIDUsIDIwNDksIDg2LCA1LCAxMjksIDE5MiwgNSwgMjQ1NzcsIDgwLCA1LCAyLCA4NywgNSwgMzg1LCA4MywgNSwgMjUsIDkxLCA1LCA2MTQ1LCA4MSwgNSwgNywgODksIDUsIDE1MzcsIDg1LCA1LCA5NywgOTMsIDUsXFxyXFxuICAgICAgICAgICAgMjQ1NzcsIDgwLCA1LCA0LCA4OCwgNSwgNzY5LCA4NCwgNSwgNDksIDkyLCA1LCAxMjI4OSwgODIsIDUsIDEzLCA5MCwgNSwgMzA3MywgODYsIDUsIDE5MywgMTkyLCA1LCAyNDU3NyBdO1xcclxcblxcclxcbiAgICAvLyBUYWJsZXMgZm9yIGRlZmxhdGUgZnJvbSBQS1pJUCdzIGFwcG5vdGUudHh0LlxcclxcbiAgICB2YXIgY3BsZW5zID0gWyAvLyBDb3B5IGxlbmd0aHMgZm9yIGxpdGVyYWwgY29kZXMgMjU3Li4yODVcXHJcXG4gICAgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMywgMTUsIDE3LCAxOSwgMjMsIDI3LCAzMSwgMzUsIDQzLCA1MSwgNTksIDY3LCA4MywgOTksIDExNSwgMTMxLCAxNjMsIDE5NSwgMjI3LCAyNTgsIDAsIDAgXTtcXHJcXG5cXHJcXG4gICAgLy8gc2VlIG5vdGUgIzEzIGFib3ZlIGFib3V0IDI1OFxcclxcbiAgICB2YXIgY3BsZXh0ID0gWyAvLyBFeHRyYSBiaXRzIGZvciBsaXRlcmFsIGNvZGVzIDI1Ny4uMjg1XFxyXFxuICAgIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDEsIDEsIDEsIDEsIDIsIDIsIDIsIDIsIDMsIDMsIDMsIDMsIDQsIDQsIDQsIDQsIDUsIDUsIDUsIDUsIDAsIDExMiwgMTEyIC8vIDExMj09aW52YWxpZFxcclxcbiAgICBdO1xcclxcblxcclxcbiAgICB2YXIgY3BkaXN0ID0gWyAvLyBDb3B5IG9mZnNldHMgZm9yIGRpc3RhbmNlIGNvZGVzIDAuLjI5XFxyXFxuICAgIDEsIDIsIDMsIDQsIDUsIDcsIDksIDEzLCAxNywgMjUsIDMzLCA0OSwgNjUsIDk3LCAxMjksIDE5MywgMjU3LCAzODUsIDUxMywgNzY5LCAxMDI1LCAxNTM3LCAyMDQ5LCAzMDczLCA0MDk3LCA2MTQ1LCA4MTkzLCAxMjI4OSwgMTYzODUsIDI0NTc3IF07XFxyXFxuXFxyXFxuICAgIHZhciBjcGRleHQgPSBbIC8vIEV4dHJhIGJpdHMgZm9yIGRpc3RhbmNlIGNvZGVzXFxyXFxuICAgIDAsIDAsIDAsIDAsIDEsIDEsIDIsIDIsIDMsIDMsIDQsIDQsIDUsIDUsIDYsIDYsIDcsIDcsIDgsIDgsIDksIDksIDEwLCAxMCwgMTEsIDExLCAxMiwgMTIsIDEzLCAxMyBdO1xcclxcblxcclxcbiAgICAvLyBJZiBCTUFYIG5lZWRzIHRvIGJlIGxhcmdlciB0aGFuIDE2LCB0aGVuIGggYW5kIHhbXSBzaG91bGQgYmUgdUxvbmcuXFxyXFxuICAgIHZhciBCTUFYID0gMTU7IC8vIG1heGltdW0gYml0IGxlbmd0aCBvZiBhbnkgY29kZVxcclxcblxcclxcbiAgICBmdW5jdGlvbiBJbmZUcmVlKCkge1xcclxcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xcclxcblxcclxcbiAgICAgICAgdmFyIGhuOyAvLyBodWZ0cyB1c2VkIGluIHNwYWNlXFxyXFxuICAgICAgICB2YXIgdjsgLy8gd29yayBhcmVhIGZvciBodWZ0X2J1aWxkXFxyXFxuICAgICAgICB2YXIgYzsgLy8gYml0IGxlbmd0aCBjb3VudCB0YWJsZVxcclxcbiAgICAgICAgdmFyIHI7IC8vIHRhYmxlIGVudHJ5IGZvciBzdHJ1Y3R1cmUgYXNzaWdubWVudFxcclxcbiAgICAgICAgdmFyIHU7IC8vIHRhYmxlIHN0YWNrXFxyXFxuICAgICAgICB2YXIgeDsgLy8gYml0IG9mZnNldHMsIHRoZW4gY29kZSBzdGFja1xcclxcblxcclxcbiAgICAgICAgZnVuY3Rpb24gaHVmdF9idWlsZChiLCAvLyBjb2RlIGxlbmd0aHMgaW4gYml0cyAoYWxsIGFzc3VtZWQgPD1cXHJcXG4gICAgICAgIC8vIEJNQVgpXFxyXFxuICAgICAgICBiaW5kZXgsIG4sIC8vIG51bWJlciBvZiBjb2RlcyAoYXNzdW1lZCA8PSAyODgpXFxyXFxuICAgICAgICBzLCAvLyBudW1iZXIgb2Ygc2ltcGxlLXZhbHVlZCBjb2RlcyAoMC4ucy0xKVxcclxcbiAgICAgICAgZCwgLy8gbGlzdCBvZiBiYXNlIHZhbHVlcyBmb3Igbm9uLXNpbXBsZSBjb2Rlc1xcclxcbiAgICAgICAgZSwgLy8gbGlzdCBvZiBleHRyYSBiaXRzIGZvciBub24tc2ltcGxlIGNvZGVzXFxyXFxuICAgICAgICB0LCAvLyByZXN1bHQ6IHN0YXJ0aW5nIHRhYmxlXFxyXFxuICAgICAgICBtLCAvLyBtYXhpbXVtIGxvb2t1cCBiaXRzLCByZXR1cm5zIGFjdHVhbFxcclxcbiAgICAgICAgaHAsLy8gc3BhY2UgZm9yIHRyZWVzXFxyXFxuICAgICAgICBobiwvLyBodWZ0cyB1c2VkIGluIHNwYWNlXFxyXFxuICAgICAgICB2IC8vIHdvcmtpbmcgYXJlYTogdmFsdWVzIGluIG9yZGVyIG9mIGJpdCBsZW5ndGhcXHJcXG4gICAgICAgICkge1xcclxcbiAgICAgICAgICAgIC8vIEdpdmVuIGEgbGlzdCBvZiBjb2RlIGxlbmd0aHMgYW5kIGEgbWF4aW11bSB0YWJsZSBzaXplLCBtYWtlIGEgc2V0IG9mXFxyXFxuICAgICAgICAgICAgLy8gdGFibGVzIHRvIGRlY29kZSB0aGF0IHNldCBvZiBjb2Rlcy4gUmV0dXJuIFpfT0sgb24gc3VjY2VzcyxcXHJcXG4gICAgICAgICAgICAvLyBaX0JVRl9FUlJPUlxcclxcbiAgICAgICAgICAgIC8vIGlmIHRoZSBnaXZlbiBjb2RlIHNldCBpcyBpbmNvbXBsZXRlICh0aGUgdGFibGVzIGFyZSBzdGlsbCBidWlsdCBpblxcclxcbiAgICAgICAgICAgIC8vIHRoaXNcXHJcXG4gICAgICAgICAgICAvLyBjYXNlKSwgWl9EQVRBX0VSUk9SIGlmIHRoZSBpbnB1dCBpcyBpbnZhbGlkIChhbiBvdmVyLXN1YnNjcmliZWQgc2V0XFxyXFxuICAgICAgICAgICAgLy8gb2ZcXHJcXG4gICAgICAgICAgICAvLyBsZW5ndGhzKSwgb3IgWl9NRU1fRVJST1IgaWYgbm90IGVub3VnaCBtZW1vcnkuXFxyXFxuXFxyXFxuICAgICAgICAgICAgdmFyIGE7IC8vIGNvdW50ZXIgZm9yIGNvZGVzIG9mIGxlbmd0aCBrXFxyXFxuICAgICAgICAgICAgdmFyIGY7IC8vIGkgcmVwZWF0cyBpbiB0YWJsZSBldmVyeSBmIGVudHJpZXNcXHJcXG4gICAgICAgICAgICB2YXIgZzsgLy8gbWF4aW11bSBjb2RlIGxlbmd0aFxcclxcbiAgICAgICAgICAgIHZhciBoOyAvLyB0YWJsZSBsZXZlbFxcclxcbiAgICAgICAgICAgIHZhciBpOyAvLyBjb3VudGVyLCBjdXJyZW50IGNvZGVcXHJcXG4gICAgICAgICAgICB2YXIgajsgLy8gY291bnRlclxcclxcbiAgICAgICAgICAgIHZhciBrOyAvLyBudW1iZXIgb2YgYml0cyBpbiBjdXJyZW50IGNvZGVcXHJcXG4gICAgICAgICAgICB2YXIgbDsgLy8gYml0cyBwZXIgdGFibGUgKHJldHVybmVkIGluIG0pXFxyXFxuICAgICAgICAgICAgdmFyIG1hc2s7IC8vICgxIDw8IHcpIC0gMSwgdG8gYXZvaWQgY2MgLU8gYnVnIG9uIEhQXFxyXFxuICAgICAgICAgICAgdmFyIHA7IC8vIHBvaW50ZXIgaW50byBjW10sIGJbXSwgb3IgdltdXFxyXFxuICAgICAgICAgICAgdmFyIHE7IC8vIHBvaW50cyB0byBjdXJyZW50IHRhYmxlXFxyXFxuICAgICAgICAgICAgdmFyIHc7IC8vIGJpdHMgYmVmb3JlIHRoaXMgdGFibGUgPT0gKGwgKiBoKVxcclxcbiAgICAgICAgICAgIHZhciB4cDsgLy8gcG9pbnRlciBpbnRvIHhcXHJcXG4gICAgICAgICAgICB2YXIgeTsgLy8gbnVtYmVyIG9mIGR1bW15IGNvZGVzIGFkZGVkXFxyXFxuICAgICAgICAgICAgdmFyIHo7IC8vIG51bWJlciBvZiBlbnRyaWVzIGluIGN1cnJlbnQgdGFibGVcXHJcXG5cXHJcXG4gICAgICAgICAgICAvLyBHZW5lcmF0ZSBjb3VudHMgZm9yIGVhY2ggYml0IGxlbmd0aFxcclxcblxcclxcbiAgICAgICAgICAgIHAgPSAwO1xcclxcbiAgICAgICAgICAgIGkgPSBuO1xcclxcbiAgICAgICAgICAgIGRvIHtcXHJcXG4gICAgICAgICAgICAgICAgY1tiW2JpbmRleCArIHBdXSsrO1xcclxcbiAgICAgICAgICAgICAgICBwKys7XFxyXFxuICAgICAgICAgICAgICAgIGktLTsgLy8gYXNzdW1lIGFsbCBlbnRyaWVzIDw9IEJNQVhcXHJcXG4gICAgICAgICAgICB9IHdoaWxlIChpICE9PSAwKTtcXHJcXG5cXHJcXG4gICAgICAgICAgICBpZiAoY1swXSA9PSBuKSB7IC8vIG51bGwgaW5wdXQtLWFsbCB6ZXJvIGxlbmd0aCBjb2Rlc1xcclxcbiAgICAgICAgICAgICAgICB0WzBdID0gLTE7XFxyXFxuICAgICAgICAgICAgICAgIG1bMF0gPSAwO1xcclxcbiAgICAgICAgICAgICAgICByZXR1cm4gWl9PSztcXHJcXG4gICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgLy8gRmluZCBtaW5pbXVtIGFuZCBtYXhpbXVtIGxlbmd0aCwgYm91bmQgKm0gYnkgdGhvc2VcXHJcXG4gICAgICAgICAgICBsID0gbVswXTtcXHJcXG4gICAgICAgICAgICBmb3IgKGogPSAxOyBqIDw9IEJNQVg7IGorKylcXHJcXG4gICAgICAgICAgICAgICAgaWYgKGNbal0gIT09IDApXFxyXFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcXHJcXG4gICAgICAgICAgICBrID0gajsgLy8gbWluaW11bSBjb2RlIGxlbmd0aFxcclxcbiAgICAgICAgICAgIGlmIChsIDwgaikge1xcclxcbiAgICAgICAgICAgICAgICBsID0gajtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgZm9yIChpID0gQk1BWDsgaSAhPT0gMDsgaS0tKSB7XFxyXFxuICAgICAgICAgICAgICAgIGlmIChjW2ldICE9PSAwKVxcclxcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIGcgPSBpOyAvLyBtYXhpbXVtIGNvZGUgbGVuZ3RoXFxyXFxuICAgICAgICAgICAgaWYgKGwgPiBpKSB7XFxyXFxuICAgICAgICAgICAgICAgIGwgPSBpO1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICBtWzBdID0gbDtcXHJcXG5cXHJcXG4gICAgICAgICAgICAvLyBBZGp1c3QgbGFzdCBsZW5ndGggY291bnQgdG8gZmlsbCBvdXQgY29kZXMsIGlmIG5lZWRlZFxcclxcbiAgICAgICAgICAgIGZvciAoeSA9IDEgPDwgajsgaiA8IGk7IGorKywgeSA8PD0gMSkge1xcclxcbiAgICAgICAgICAgICAgICBpZiAoKHkgLT0gY1tqXSkgPCAwKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWl9EQVRBX0VSUk9SO1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIGlmICgoeSAtPSBjW2ldKSA8IDApIHtcXHJcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFpfREFUQV9FUlJPUjtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgY1tpXSArPSB5O1xcclxcblxcclxcbiAgICAgICAgICAgIC8vIEdlbmVyYXRlIHN0YXJ0aW5nIG9mZnNldHMgaW50byB0aGUgdmFsdWUgdGFibGUgZm9yIGVhY2ggbGVuZ3RoXFxyXFxuICAgICAgICAgICAgeFsxXSA9IGogPSAwO1xcclxcbiAgICAgICAgICAgIHAgPSAxO1xcclxcbiAgICAgICAgICAgIHhwID0gMjtcXHJcXG4gICAgICAgICAgICB3aGlsZSAoLS1pICE9PSAwKSB7IC8vIG5vdGUgdGhhdCBpID09IGcgZnJvbSBhYm92ZVxcclxcbiAgICAgICAgICAgICAgICB4W3hwXSA9IChqICs9IGNbcF0pO1xcclxcbiAgICAgICAgICAgICAgICB4cCsrO1xcclxcbiAgICAgICAgICAgICAgICBwKys7XFxyXFxuICAgICAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgICAgIC8vIE1ha2UgYSB0YWJsZSBvZiB2YWx1ZXMgaW4gb3JkZXIgb2YgYml0IGxlbmd0aHNcXHJcXG4gICAgICAgICAgICBpID0gMDtcXHJcXG4gICAgICAgICAgICBwID0gMDtcXHJcXG4gICAgICAgICAgICBkbyB7XFxyXFxuICAgICAgICAgICAgICAgIGlmICgoaiA9IGJbYmluZGV4ICsgcF0pICE9PSAwKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICB2W3hbal0rK10gPSBpO1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgIHArKztcXHJcXG4gICAgICAgICAgICB9IHdoaWxlICgrK2kgPCBuKTtcXHJcXG4gICAgICAgICAgICBuID0geFtnXTsgLy8gc2V0IG4gdG8gbGVuZ3RoIG9mIHZcXHJcXG5cXHJcXG4gICAgICAgICAgICAvLyBHZW5lcmF0ZSB0aGUgSHVmZm1hbiBjb2RlcyBhbmQgZm9yIGVhY2gsIG1ha2UgdGhlIHRhYmxlIGVudHJpZXNcXHJcXG4gICAgICAgICAgICB4WzBdID0gaSA9IDA7IC8vIGZpcnN0IEh1ZmZtYW4gY29kZSBpcyB6ZXJvXFxyXFxuICAgICAgICAgICAgcCA9IDA7IC8vIGdyYWIgdmFsdWVzIGluIGJpdCBvcmRlclxcclxcbiAgICAgICAgICAgIGggPSAtMTsgLy8gbm8gdGFibGVzIHlldC0tbGV2ZWwgLTFcXHJcXG4gICAgICAgICAgICB3ID0gLWw7IC8vIGJpdHMgZGVjb2RlZCA9PSAobCAqIGgpXFxyXFxuICAgICAgICAgICAgdVswXSA9IDA7IC8vIGp1c3QgdG8ga2VlcCBjb21waWxlcnMgaGFwcHlcXHJcXG4gICAgICAgICAgICBxID0gMDsgLy8gZGl0dG9cXHJcXG4gICAgICAgICAgICB6ID0gMDsgLy8gZGl0dG9cXHJcXG5cXHJcXG4gICAgICAgICAgICAvLyBnbyB0aHJvdWdoIHRoZSBiaXQgbGVuZ3RocyAoayBhbHJlYWR5IGlzIGJpdHMgaW4gc2hvcnRlc3QgY29kZSlcXHJcXG4gICAgICAgICAgICBmb3IgKDsgayA8PSBnOyBrKyspIHtcXHJcXG4gICAgICAgICAgICAgICAgYSA9IGNba107XFxyXFxuICAgICAgICAgICAgICAgIHdoaWxlIChhLS0gIT09IDApIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIC8vIGhlcmUgaSBpcyB0aGUgSHVmZm1hbiBjb2RlIG9mIGxlbmd0aCBrIGJpdHMgZm9yIHZhbHVlICpwXFxyXFxuICAgICAgICAgICAgICAgICAgICAvLyBtYWtlIHRhYmxlcyB1cCB0byByZXF1aXJlZCBsZXZlbFxcclxcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGsgPiB3ICsgbCkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGgrKztcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB3ICs9IGw7IC8vIHByZXZpb3VzIHRhYmxlIGFsd2F5cyBsIGJpdHNcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb21wdXRlIG1pbmltdW0gc2l6ZSB0YWJsZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gbCBiaXRzXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgeiA9IGcgLSB3O1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHogPSAoeiA+IGwpID8gbCA6IHo7IC8vIHRhYmxlIHNpemUgdXBwZXIgbGltaXRcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGYgPSAxIDw8IChqID0gayAtIHcpKSA+IGEgKyAxKSB7IC8vIHRyeSBhIGstdyBiaXQgdGFibGVcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG9vIGZldyBjb2RlcyBmb3JcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gay13IGJpdCB0YWJsZVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmIC09IGEgKyAxOyAvLyBkZWR1Y3QgY29kZXMgZnJvbSBwYXR0ZXJucyBsZWZ0XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhwID0gaztcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGogPCB6KSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKytqIDwgeikgeyAvLyB0cnkgc21hbGxlciB0YWJsZXMgdXAgdG8geiBiaXRzXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChmIDw8PSAxKSA8PSBjWysreHBdKVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gZW5vdWdoIGNvZGVzIHRvIHVzZSB1cCBqIGJpdHNcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmIC09IGNbeHBdOyAvLyBlbHNlIGRlZHVjdCBjb2RlcyBmcm9tIHBhdHRlcm5zXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgeiA9IDEgPDwgajsgLy8gdGFibGUgZW50cmllcyBmb3Igai1iaXQgdGFibGVcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbGxvY2F0ZSBuZXcgdGFibGVcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaG5bMF0gKyB6ID4gTUFOWSkgeyAvLyAobm90ZTogZG9lc24ndCBtYXR0ZXIgZm9yIGZpeGVkKVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWl9EQVRBX0VSUk9SOyAvLyBvdmVyZmxvdyBvZiBNQU5ZXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVbaF0gPSBxID0gLyogaHArICovaG5bMF07IC8vIERFQlVHXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgaG5bMF0gKz0gejtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25uZWN0IHRvIGxhc3QgdGFibGUsIGlmIHRoZXJlIGlzIG9uZVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoICE9PSAwKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhbaF0gPSBpOyAvLyBzYXZlIHBhdHRlcm4gZm9yIGJhY2tpbmcgdXBcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgclswXSA9IC8qIChieXRlKSAqL2o7IC8vIGJpdHMgaW4gdGhpcyB0YWJsZVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByWzFdID0gLyogKGJ5dGUpICovbDsgLy8gYml0cyB0byBkdW1wIGJlZm9yZSB0aGlzIHRhYmxlXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGogPSBpID4+PiAodyAtIGwpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByWzJdID0gLyogKGludCkgKi8ocSAtIHVbaCAtIDFdIC0gaik7IC8vIG9mZnNldCB0byB0aGlzIHRhYmxlXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhwLnNldChyLCAodVtoIC0gMV0gKyBqKSAqIDMpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0b1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBsYXN0XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRhYmxlXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdFswXSA9IHE7IC8vIGZpcnN0IHRhYmxlIGlzIHJldHVybmVkIHJlc3VsdFxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgIC8vIHNldCB1cCB0YWJsZSBlbnRyeSBpbiByXFxyXFxuICAgICAgICAgICAgICAgICAgICByWzFdID0gLyogKGJ5dGUpICovKGsgLSB3KTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGlmIChwID49IG4pIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICByWzBdID0gMTI4ICsgNjQ7IC8vIG91dCBvZiB2YWx1ZXMtLWludmFsaWQgY29kZVxcclxcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2W3BdIDwgcykge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJbMF0gPSAvKiAoYnl0ZSkgKi8odltwXSA8IDI1NiA/IDAgOiAzMiArIDY0KTsgLy8gMjU2IGlzXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZW5kLW9mLWJsb2NrXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgclsyXSA9IHZbcCsrXTsgLy8gc2ltcGxlIGNvZGUgaXMganVzdCB0aGUgdmFsdWVcXHJcXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgclswXSA9IC8qIChieXRlKSAqLyhlW3ZbcF0gLSBzXSArIDE2ICsgNjQpOyAvLyBub24tc2ltcGxlLS1sb29rXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXAgaW4gbGlzdHNcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICByWzJdID0gZFt2W3ArK10gLSBzXTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgIC8vIGZpbGwgY29kZS1saWtlIGVudHJpZXMgd2l0aCByXFxyXFxuICAgICAgICAgICAgICAgICAgICBmID0gMSA8PCAoayAtIHcpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gaSA+Pj4gdzsgaiA8IHo7IGogKz0gZikge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhwLnNldChyLCAocSArIGopICogMyk7XFxyXFxuICAgICAgICAgICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICAvLyBiYWNrd2FyZHMgaW5jcmVtZW50IHRoZSBrLWJpdCBjb2RlIGlcXHJcXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDEgPDwgKGsgLSAxKTsgKGkgJiBqKSAhPT0gMDsgaiA+Pj49IDEpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBpIF49IGo7XFxyXFxuICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgICAgICBpIF49IGo7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICAvLyBiYWNrdXAgb3ZlciBmaW5pc2hlZCB0YWJsZXNcXHJcXG4gICAgICAgICAgICAgICAgICAgIG1hc2sgPSAoMSA8PCB3KSAtIDE7IC8vIG5lZWRlZCBvbiBIUCwgY2MgLU8gYnVnXFxyXFxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKGkgJiBtYXNrKSAhPSB4W2hdKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgaC0tOyAvLyBkb24ndCBuZWVkIHRvIHVwZGF0ZSBxXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgdyAtPSBsO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hc2sgPSAoMSA8PCB3KSAtIDE7XFxyXFxuICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgLy8gUmV0dXJuIFpfQlVGX0VSUk9SIGlmIHdlIHdlcmUgZ2l2ZW4gYW4gaW5jb21wbGV0ZSB0YWJsZVxcclxcbiAgICAgICAgICAgIHJldHVybiB5ICE9PSAwICYmIGcgIT0gMSA/IFpfQlVGX0VSUk9SIDogWl9PSztcXHJcXG4gICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgIGZ1bmN0aW9uIGluaXRXb3JrQXJlYSh2c2l6ZSkge1xcclxcbiAgICAgICAgICAgIHZhciBpO1xcclxcbiAgICAgICAgICAgIGlmICghaG4pIHtcXHJcXG4gICAgICAgICAgICAgICAgaG4gPSBbXTsgLy8gW107IC8vbmV3IEFycmF5KDEpO1xcclxcbiAgICAgICAgICAgICAgICB2ID0gW107IC8vIG5ldyBBcnJheSh2c2l6ZSk7XFxyXFxuICAgICAgICAgICAgICAgIGMgPSBuZXcgSW50MzJBcnJheShCTUFYICsgMSk7IC8vIG5ldyBBcnJheShCTUFYICsgMSk7XFxyXFxuICAgICAgICAgICAgICAgIHIgPSBbXTsgLy8gbmV3IEFycmF5KDMpO1xcclxcbiAgICAgICAgICAgICAgICB1ID0gbmV3IEludDMyQXJyYXkoQk1BWCk7IC8vIG5ldyBBcnJheShCTUFYKTtcXHJcXG4gICAgICAgICAgICAgICAgeCA9IG5ldyBJbnQzMkFycmF5KEJNQVggKyAxKTsgLy8gbmV3IEFycmF5KEJNQVggKyAxKTtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgaWYgKHYubGVuZ3RoIDwgdnNpemUpIHtcXHJcXG4gICAgICAgICAgICAgICAgdiA9IFtdOyAvLyBuZXcgQXJyYXkodnNpemUpO1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdnNpemU7IGkrKykge1xcclxcbiAgICAgICAgICAgICAgICB2W2ldID0gMDtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IEJNQVggKyAxOyBpKyspIHtcXHJcXG4gICAgICAgICAgICAgICAgY1tpXSA9IDA7XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCAzOyBpKyspIHtcXHJcXG4gICAgICAgICAgICAgICAgcltpXSA9IDA7XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIC8vIGZvcihpbnQgaT0wOyBpPEJNQVg7IGkrKyl7dVtpXT0wO31cXHJcXG4gICAgICAgICAgICB1LnNldChjLnN1YmFycmF5KDAsIEJNQVgpLCAwKTtcXHJcXG4gICAgICAgICAgICAvLyBmb3IoaW50IGk9MDsgaTxCTUFYKzE7IGkrKyl7eFtpXT0wO31cXHJcXG4gICAgICAgICAgICB4LnNldChjLnN1YmFycmF5KDAsIEJNQVggKyAxKSwgMCk7XFxyXFxuICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICB0aGF0LmluZmxhdGVfdHJlZXNfYml0cyA9IGZ1bmN0aW9uKGMsIC8vIDE5IGNvZGUgbGVuZ3Roc1xcclxcbiAgICAgICAgYmIsIC8vIGJpdHMgdHJlZSBkZXNpcmVkL2FjdHVhbCBkZXB0aFxcclxcbiAgICAgICAgdGIsIC8vIGJpdHMgdHJlZSByZXN1bHRcXHJcXG4gICAgICAgIGhwLCAvLyBzcGFjZSBmb3IgdHJlZXNcXHJcXG4gICAgICAgIHogLy8gZm9yIG1lc3NhZ2VzXFxyXFxuICAgICAgICApIHtcXHJcXG4gICAgICAgICAgICB2YXIgcmVzdWx0O1xcclxcbiAgICAgICAgICAgIGluaXRXb3JrQXJlYSgxOSk7XFxyXFxuICAgICAgICAgICAgaG5bMF0gPSAwO1xcclxcbiAgICAgICAgICAgIHJlc3VsdCA9IGh1ZnRfYnVpbGQoYywgMCwgMTksIDE5LCBudWxsLCBudWxsLCB0YiwgYmIsIGhwLCBobiwgdik7XFxyXFxuXFxyXFxuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PSBaX0RBVEFfRVJST1IpIHtcXHJcXG4gICAgICAgICAgICAgICAgei5tc2cgPSBcXFwib3ZlcnN1YnNjcmliZWQgZHluYW1pYyBiaXQgbGVuZ3RocyB0cmVlXFxcIjtcXHJcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdCA9PSBaX0JVRl9FUlJPUiB8fCBiYlswXSA9PT0gMCkge1xcclxcbiAgICAgICAgICAgICAgICB6Lm1zZyA9IFxcXCJpbmNvbXBsZXRlIGR5bmFtaWMgYml0IGxlbmd0aHMgdHJlZVxcXCI7XFxyXFxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFpfREFUQV9FUlJPUjtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcXHJcXG4gICAgICAgIH07XFxyXFxuXFxyXFxuICAgICAgICB0aGF0LmluZmxhdGVfdHJlZXNfZHluYW1pYyA9IGZ1bmN0aW9uKG5sLCAvLyBudW1iZXIgb2YgbGl0ZXJhbC9sZW5ndGggY29kZXNcXHJcXG4gICAgICAgIG5kLCAvLyBudW1iZXIgb2YgZGlzdGFuY2UgY29kZXNcXHJcXG4gICAgICAgIGMsIC8vIHRoYXQgbWFueSAodG90YWwpIGNvZGUgbGVuZ3Roc1xcclxcbiAgICAgICAgYmwsIC8vIGxpdGVyYWwgZGVzaXJlZC9hY3R1YWwgYml0IGRlcHRoXFxyXFxuICAgICAgICBiZCwgLy8gZGlzdGFuY2UgZGVzaXJlZC9hY3R1YWwgYml0IGRlcHRoXFxyXFxuICAgICAgICB0bCwgLy8gbGl0ZXJhbC9sZW5ndGggdHJlZSByZXN1bHRcXHJcXG4gICAgICAgIHRkLCAvLyBkaXN0YW5jZSB0cmVlIHJlc3VsdFxcclxcbiAgICAgICAgaHAsIC8vIHNwYWNlIGZvciB0cmVlc1xcclxcbiAgICAgICAgeiAvLyBmb3IgbWVzc2FnZXNcXHJcXG4gICAgICAgICkge1xcclxcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XFxyXFxuXFxyXFxuICAgICAgICAgICAgLy8gYnVpbGQgbGl0ZXJhbC9sZW5ndGggdHJlZVxcclxcbiAgICAgICAgICAgIGluaXRXb3JrQXJlYSgyODgpO1xcclxcbiAgICAgICAgICAgIGhuWzBdID0gMDtcXHJcXG4gICAgICAgICAgICByZXN1bHQgPSBodWZ0X2J1aWxkKGMsIDAsIG5sLCAyNTcsIGNwbGVucywgY3BsZXh0LCB0bCwgYmwsIGhwLCBobiwgdik7XFxyXFxuICAgICAgICAgICAgaWYgKHJlc3VsdCAhPSBaX09LIHx8IGJsWzBdID09PSAwKSB7XFxyXFxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPT0gWl9EQVRBX0VSUk9SKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICB6Lm1zZyA9IFxcXCJvdmVyc3Vic2NyaWJlZCBsaXRlcmFsL2xlbmd0aCB0cmVlXFxcIjtcXHJcXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChyZXN1bHQgIT0gWl9NRU1fRVJST1IpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHoubXNnID0gXFxcImluY29tcGxldGUgbGl0ZXJhbC9sZW5ndGggdHJlZVxcXCI7XFxyXFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBaX0RBVEFfRVJST1I7XFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgLy8gYnVpbGQgZGlzdGFuY2UgdHJlZVxcclxcbiAgICAgICAgICAgIGluaXRXb3JrQXJlYSgyODgpO1xcclxcbiAgICAgICAgICAgIHJlc3VsdCA9IGh1ZnRfYnVpbGQoYywgbmwsIG5kLCAwLCBjcGRpc3QsIGNwZGV4dCwgdGQsIGJkLCBocCwgaG4sIHYpO1xcclxcblxcclxcbiAgICAgICAgICAgIGlmIChyZXN1bHQgIT0gWl9PSyB8fCAoYmRbMF0gPT09IDAgJiYgbmwgPiAyNTcpKSB7XFxyXFxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPT0gWl9EQVRBX0VSUk9SKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICB6Lm1zZyA9IFxcXCJvdmVyc3Vic2NyaWJlZCBkaXN0YW5jZSB0cmVlXFxcIjtcXHJcXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChyZXN1bHQgPT0gWl9CVUZfRVJST1IpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHoubXNnID0gXFxcImluY29tcGxldGUgZGlzdGFuY2UgdHJlZVxcXCI7XFxyXFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBaX0RBVEFfRVJST1I7XFxyXFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzdWx0ICE9IFpfTUVNX0VSUk9SKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICB6Lm1zZyA9IFxcXCJlbXB0eSBkaXN0YW5jZSB0cmVlIHdpdGggbGVuZ3Roc1xcXCI7XFxyXFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBaX0RBVEFfRVJST1I7XFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgcmV0dXJuIFpfT0s7XFxyXFxuICAgICAgICB9O1xcclxcblxcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgIEluZlRyZWUuaW5mbGF0ZV90cmVlc19maXhlZCA9IGZ1bmN0aW9uKGJsLCAvLyBsaXRlcmFsIGRlc2lyZWQvYWN0dWFsIGJpdCBkZXB0aFxcclxcbiAgICBiZCwgLy8gZGlzdGFuY2UgZGVzaXJlZC9hY3R1YWwgYml0IGRlcHRoXFxyXFxuICAgIHRsLC8vIGxpdGVyYWwvbGVuZ3RoIHRyZWUgcmVzdWx0XFxyXFxuICAgIHRkLy8gZGlzdGFuY2UgdHJlZSByZXN1bHRcXHJcXG4gICAgKSB7XFxyXFxuICAgICAgICBibFswXSA9IGZpeGVkX2JsO1xcclxcbiAgICAgICAgYmRbMF0gPSBmaXhlZF9iZDtcXHJcXG4gICAgICAgIHRsWzBdID0gZml4ZWRfdGw7XFxyXFxuICAgICAgICB0ZFswXSA9IGZpeGVkX3RkO1xcclxcbiAgICAgICAgcmV0dXJuIFpfT0s7XFxyXFxuICAgIH07XFxyXFxuXFxyXFxuICAgIC8vIEluZkNvZGVzXFxyXFxuXFxyXFxuICAgIC8vIHdhaXRpbmcgZm9yIFxcXCJpOlxcXCI9aW5wdXQsXFxyXFxuICAgIC8vIFxcXCJvOlxcXCI9b3V0cHV0LFxcclxcbiAgICAvLyBcXFwieDpcXFwiPW5vdGhpbmdcXHJcXG4gICAgdmFyIFNUQVJUID0gMDsgLy8geDogc2V0IHVwIGZvciBMRU5cXHJcXG4gICAgdmFyIExFTiA9IDE7IC8vIGk6IGdldCBsZW5ndGgvbGl0ZXJhbC9lb2IgbmV4dFxcclxcbiAgICB2YXIgTEVORVhUID0gMjsgLy8gaTogZ2V0dGluZyBsZW5ndGggZXh0cmEgKGhhdmUgYmFzZSlcXHJcXG4gICAgdmFyIERJU1QgPSAzOyAvLyBpOiBnZXQgZGlzdGFuY2UgbmV4dFxcclxcbiAgICB2YXIgRElTVEVYVCA9IDQ7Ly8gaTogZ2V0dGluZyBkaXN0YW5jZSBleHRyYVxcclxcbiAgICB2YXIgQ09QWSA9IDU7IC8vIG86IGNvcHlpbmcgYnl0ZXMgaW4gd2luZG93LCB3YWl0aW5nXFxyXFxuICAgIC8vIGZvciBzcGFjZVxcclxcbiAgICB2YXIgTElUID0gNjsgLy8gbzogZ290IGxpdGVyYWwsIHdhaXRpbmcgZm9yIG91dHB1dFxcclxcbiAgICAvLyBzcGFjZVxcclxcbiAgICB2YXIgV0FTSCA9IDc7IC8vIG86IGdvdCBlb2IsIHBvc3NpYmx5IHN0aWxsIG91dHB1dFxcclxcbiAgICAvLyB3YWl0aW5nXFxyXFxuICAgIHZhciBFTkQgPSA4OyAvLyB4OiBnb3QgZW9iIGFuZCBhbGwgZGF0YSBmbHVzaGVkXFxyXFxuICAgIHZhciBCQURDT0RFID0gOTsvLyB4OiBnb3QgZXJyb3JcXHJcXG5cXHJcXG4gICAgZnVuY3Rpb24gSW5mQ29kZXMoKSB7XFxyXFxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XFxyXFxuXFxyXFxuICAgICAgICB2YXIgbW9kZTsgLy8gY3VycmVudCBpbmZsYXRlX2NvZGVzIG1vZGVcXHJcXG5cXHJcXG4gICAgICAgIC8vIG1vZGUgZGVwZW5kZW50IGluZm9ybWF0aW9uXFxyXFxuICAgICAgICB2YXIgbGVuID0gMDtcXHJcXG5cXHJcXG4gICAgICAgIHZhciB0cmVlOyAvLyBwb2ludGVyIGludG8gdHJlZVxcclxcbiAgICAgICAgdmFyIHRyZWVfaW5kZXggPSAwO1xcclxcbiAgICAgICAgdmFyIG5lZWQgPSAwOyAvLyBiaXRzIG5lZWRlZFxcclxcblxcclxcbiAgICAgICAgdmFyIGxpdCA9IDA7XFxyXFxuXFxyXFxuICAgICAgICAvLyBpZiBFWFQgb3IgQ09QWSwgd2hlcmUgYW5kIGhvdyBtdWNoXFxyXFxuICAgICAgICB2YXIgZ2V0ID0gMDsgLy8gYml0cyB0byBnZXQgZm9yIGV4dHJhXFxyXFxuICAgICAgICB2YXIgZGlzdCA9IDA7IC8vIGRpc3RhbmNlIGJhY2sgdG8gY29weSBmcm9tXFxyXFxuXFxyXFxuICAgICAgICB2YXIgbGJpdHMgPSAwOyAvLyBsdHJlZSBiaXRzIGRlY29kZWQgcGVyIGJyYW5jaFxcclxcbiAgICAgICAgdmFyIGRiaXRzID0gMDsgLy8gZHRyZWUgYml0cyBkZWNvZGVyIHBlciBicmFuY2hcXHJcXG4gICAgICAgIHZhciBsdHJlZTsgLy8gbGl0ZXJhbC9sZW5ndGgvZW9iIHRyZWVcXHJcXG4gICAgICAgIHZhciBsdHJlZV9pbmRleCA9IDA7IC8vIGxpdGVyYWwvbGVuZ3RoL2VvYiB0cmVlXFxyXFxuICAgICAgICB2YXIgZHRyZWU7IC8vIGRpc3RhbmNlIHRyZWVcXHJcXG4gICAgICAgIHZhciBkdHJlZV9pbmRleCA9IDA7IC8vIGRpc3RhbmNlIHRyZWVcXHJcXG5cXHJcXG4gICAgICAgIC8vIENhbGxlZCB3aXRoIG51bWJlciBvZiBieXRlcyBsZWZ0IHRvIHdyaXRlIGluIHdpbmRvdyBhdCBsZWFzdCAyNThcXHJcXG4gICAgICAgIC8vICh0aGUgbWF4aW11bSBzdHJpbmcgbGVuZ3RoKSBhbmQgbnVtYmVyIG9mIGlucHV0IGJ5dGVzIGF2YWlsYWJsZVxcclxcbiAgICAgICAgLy8gYXQgbGVhc3QgdGVuLiBUaGUgdGVuIGJ5dGVzIGFyZSBzaXggYnl0ZXMgZm9yIHRoZSBsb25nZXN0IGxlbmd0aC9cXHJcXG4gICAgICAgIC8vIGRpc3RhbmNlIHBhaXIgcGx1cyBmb3VyIGJ5dGVzIGZvciBvdmVybG9hZGluZyB0aGUgYml0IGJ1ZmZlci5cXHJcXG5cXHJcXG4gICAgICAgIGZ1bmN0aW9uIGluZmxhdGVfZmFzdChibCwgYmQsIHRsLCB0bF9pbmRleCwgdGQsIHRkX2luZGV4LCBzLCB6KSB7XFxyXFxuICAgICAgICAgICAgdmFyIHQ7IC8vIHRlbXBvcmFyeSBwb2ludGVyXFxyXFxuICAgICAgICAgICAgdmFyIHRwOyAvLyB0ZW1wb3JhcnkgcG9pbnRlclxcclxcbiAgICAgICAgICAgIHZhciB0cF9pbmRleDsgLy8gdGVtcG9yYXJ5IHBvaW50ZXJcXHJcXG4gICAgICAgICAgICB2YXIgZTsgLy8gZXh0cmEgYml0cyBvciBvcGVyYXRpb25cXHJcXG4gICAgICAgICAgICB2YXIgYjsgLy8gYml0IGJ1ZmZlclxcclxcbiAgICAgICAgICAgIHZhciBrOyAvLyBiaXRzIGluIGJpdCBidWZmZXJcXHJcXG4gICAgICAgICAgICB2YXIgcDsgLy8gaW5wdXQgZGF0YSBwb2ludGVyXFxyXFxuICAgICAgICAgICAgdmFyIG47IC8vIGJ5dGVzIGF2YWlsYWJsZSB0aGVyZVxcclxcbiAgICAgICAgICAgIHZhciBxOyAvLyBvdXRwdXQgd2luZG93IHdyaXRlIHBvaW50ZXJcXHJcXG4gICAgICAgICAgICB2YXIgbTsgLy8gYnl0ZXMgdG8gZW5kIG9mIHdpbmRvdyBvciByZWFkIHBvaW50ZXJcXHJcXG4gICAgICAgICAgICB2YXIgbWw7IC8vIG1hc2sgZm9yIGxpdGVyYWwvbGVuZ3RoIHRyZWVcXHJcXG4gICAgICAgICAgICB2YXIgbWQ7IC8vIG1hc2sgZm9yIGRpc3RhbmNlIHRyZWVcXHJcXG4gICAgICAgICAgICB2YXIgYzsgLy8gYnl0ZXMgdG8gY29weVxcclxcbiAgICAgICAgICAgIHZhciBkOyAvLyBkaXN0YW5jZSBiYWNrIHRvIGNvcHkgZnJvbVxcclxcbiAgICAgICAgICAgIHZhciByOyAvLyBjb3B5IHNvdXJjZSBwb2ludGVyXFxyXFxuXFxyXFxuICAgICAgICAgICAgdmFyIHRwX2luZGV4X3RfMzsgLy8gKHRwX2luZGV4K3QpKjNcXHJcXG5cXHJcXG4gICAgICAgICAgICAvLyBsb2FkIGlucHV0LCBvdXRwdXQsIGJpdCB2YWx1ZXNcXHJcXG4gICAgICAgICAgICBwID0gei5uZXh0X2luX2luZGV4O1xcclxcbiAgICAgICAgICAgIG4gPSB6LmF2YWlsX2luO1xcclxcbiAgICAgICAgICAgIGIgPSBzLmJpdGI7XFxyXFxuICAgICAgICAgICAgayA9IHMuYml0aztcXHJcXG4gICAgICAgICAgICBxID0gcy53cml0ZTtcXHJcXG4gICAgICAgICAgICBtID0gcSA8IHMucmVhZCA/IHMucmVhZCAtIHEgLSAxIDogcy5lbmQgLSBxO1xcclxcblxcclxcbiAgICAgICAgICAgIC8vIGluaXRpYWxpemUgbWFza3NcXHJcXG4gICAgICAgICAgICBtbCA9IGluZmxhdGVfbWFza1tibF07XFxyXFxuICAgICAgICAgICAgbWQgPSBpbmZsYXRlX21hc2tbYmRdO1xcclxcblxcclxcbiAgICAgICAgICAgIC8vIGRvIHVudGlsIG5vdCBlbm91Z2ggaW5wdXQgb3Igb3V0cHV0IHNwYWNlIGZvciBmYXN0IGxvb3BcXHJcXG4gICAgICAgICAgICBkbyB7IC8vIGFzc3VtZSBjYWxsZWQgd2l0aCBtID49IDI1OCAmJiBuID49IDEwXFxyXFxuICAgICAgICAgICAgICAgIC8vIGdldCBsaXRlcmFsL2xlbmd0aCBjb2RlXFxyXFxuICAgICAgICAgICAgICAgIHdoaWxlIChrIDwgKDIwKSkgeyAvLyBtYXggYml0cyBmb3IgbGl0ZXJhbC9sZW5ndGggY29kZVxcclxcbiAgICAgICAgICAgICAgICAgICAgbi0tO1xcclxcbiAgICAgICAgICAgICAgICAgICAgYiB8PSAoei5yZWFkX2J5dGUocCsrKSAmIDB4ZmYpIDw8IGs7XFxyXFxuICAgICAgICAgICAgICAgICAgICBrICs9IDg7XFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgdCA9IGIgJiBtbDtcXHJcXG4gICAgICAgICAgICAgICAgdHAgPSB0bDtcXHJcXG4gICAgICAgICAgICAgICAgdHBfaW5kZXggPSB0bF9pbmRleDtcXHJcXG4gICAgICAgICAgICAgICAgdHBfaW5kZXhfdF8zID0gKHRwX2luZGV4ICsgdCkgKiAzO1xcclxcbiAgICAgICAgICAgICAgICBpZiAoKGUgPSB0cFt0cF9pbmRleF90XzNdKSA9PT0gMCkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgYiA+Pj0gKHRwW3RwX2luZGV4X3RfMyArIDFdKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGsgLT0gKHRwW3RwX2luZGV4X3RfMyArIDFdKTtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgIHMud2luZG93W3ErK10gPSAvKiAoYnl0ZSkgKi90cFt0cF9pbmRleF90XzMgKyAyXTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIG0tLTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgIGRvIHtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgIGIgPj49ICh0cFt0cF9pbmRleF90XzMgKyAxXSk7XFxyXFxuICAgICAgICAgICAgICAgICAgICBrIC09ICh0cFt0cF9pbmRleF90XzMgKyAxXSk7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICBpZiAoKGUgJiAxNikgIT09IDApIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBlICY9IDE1O1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGMgPSB0cFt0cF9pbmRleF90XzMgKyAyXSArICgvKiAoaW50KSAqL2IgJiBpbmZsYXRlX21hc2tbZV0pO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGIgPj49IGU7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgayAtPSBlO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRlY29kZSBkaXN0YW5jZSBiYXNlIG9mIGJsb2NrIHRvIGNvcHlcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoayA8ICgxNSkpIHsgLy8gbWF4IGJpdHMgZm9yIGRpc3RhbmNlIGNvZGVcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbi0tO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiIHw9ICh6LnJlYWRfYnl0ZShwKyspICYgMHhmZikgPDwgaztcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgayArPSA4O1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB0ID0gYiAmIG1kO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRwID0gdGQ7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgdHBfaW5kZXggPSB0ZF9pbmRleDtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB0cF9pbmRleF90XzMgPSAodHBfaW5kZXggKyB0KSAqIDM7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgZSA9IHRwW3RwX2luZGV4X3RfM107XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgZG8ge1xcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiID4+PSAodHBbdHBfaW5kZXhfdF8zICsgMV0pO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrIC09ICh0cFt0cF9pbmRleF90XzMgKyAxXSk7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoZSAmIDE2KSAhPT0gMCkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IGV4dHJhIGJpdHMgdG8gYWRkIHRvIGRpc3RhbmNlIGJhc2VcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUgJj0gMTU7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoayA8IChlKSkgeyAvLyBnZXQgZXh0cmEgYml0cyAodXAgdG8gMTMpXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbi0tO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIgfD0gKHoucmVhZF9ieXRlKHArKykgJiAweGZmKSA8PCBrO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGsgKz0gODtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQgPSB0cFt0cF9pbmRleF90XzMgKyAyXSArIChiICYgaW5mbGF0ZV9tYXNrW2VdKTtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIgPj49IChlKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGsgLT0gKGUpO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG8gdGhlIGNvcHlcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0gLT0gYztcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChxID49IGQpIHsgLy8gb2Zmc2V0IGJlZm9yZSBkZXN0XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8ganVzdCBjb3B5XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgciA9IHEgLSBkO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChxIC0gciA+IDAgJiYgMiA+IChxIC0gcikpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcy53aW5kb3dbcSsrXSA9IHMud2luZG93W3IrK107IC8vIG1pbmltdW1cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY291bnQgaXNcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhyZWUsXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMud2luZG93W3ErK10gPSBzLndpbmRvd1tyKytdOyAvLyBzbyB1bnJvbGxcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbG9vcCBhXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxpdHRsZVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjIC09IDI7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcy53aW5kb3cuc2V0KHMud2luZG93LnN1YmFycmF5KHIsIHIgKyAyKSwgcSk7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHEgKz0gMjtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgciArPSAyO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjIC09IDI7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gZWxzZSBvZmZzZXQgYWZ0ZXIgZGVzdGluYXRpb25cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByID0gcSAtIGQ7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG8ge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByICs9IHMuZW5kOyAvLyBmb3JjZSBwb2ludGVyIGluIHdpbmRvd1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKHIgPCAwKTsgLy8gY292ZXJzIGludmFsaWQgZGlzdGFuY2VzXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZSA9IHMuZW5kIC0gcjtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYyA+IGUpIHsgLy8gaWYgc291cmNlIGNyb3NzZXMsXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgLT0gZTsgLy8gd3JhcHBlZCBjb3B5XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChxIC0gciA+IDAgJiYgZSA+IChxIC0gcikpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzLndpbmRvd1txKytdID0gcy53aW5kb3dbcisrXTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tZSAhPT0gMCk7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzLndpbmRvdy5zZXQocy53aW5kb3cuc3ViYXJyYXkociwgciArIGUpLCBxKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHEgKz0gZTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgKz0gZTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUgPSAwO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgPSAwOyAvLyBjb3B5IHJlc3QgZnJvbSBzdGFydCBvZiB3aW5kb3dcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb3B5IGFsbCBvciB3aGF0J3MgbGVmdFxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHEgLSByID4gMCAmJiBjID4gKHEgLSByKSkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcy53aW5kb3dbcSsrXSA9IHMud2luZG93W3IrK107XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1jICE9PSAwKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcy53aW5kb3cuc2V0KHMud2luZG93LnN1YmFycmF5KHIsIHIgKyBjKSwgcSk7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcSArPSBjO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgKz0gYztcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjID0gMDtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKChlICYgNjQpID09PSAwKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ICs9IHRwW3RwX2luZGV4X3RfMyArIDJdO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdCArPSAoYiAmIGluZmxhdGVfbWFza1tlXSk7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cF9pbmRleF90XzMgPSAodHBfaW5kZXggKyB0KSAqIDM7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlID0gdHBbdHBfaW5kZXhfdF8zXTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHoubXNnID0gXFxcImludmFsaWQgZGlzdGFuY2UgY29kZVxcXCI7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjID0gei5hdmFpbF9pbiAtIG47XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjID0gKGsgPj4gMykgPCBjID8gayA+PiAzIDogYztcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4gKz0gYztcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAgLT0gYztcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGsgLT0gYyA8PCAzO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcy5iaXRiID0gYjtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMuYml0ayA9IGs7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB6LmF2YWlsX2luID0gbjtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHoudG90YWxfaW4gKz0gcCAtIHoubmV4dF9pbl9pbmRleDtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHoubmV4dF9pbl9pbmRleCA9IHA7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzLndyaXRlID0gcTtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBaX0RBVEFfRVJST1I7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB9IHdoaWxlICh0cnVlKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcXHJcXG4gICAgICAgICAgICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgIGlmICgoZSAmIDY0KSA9PT0gMCkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHQgKz0gdHBbdHBfaW5kZXhfdF8zICsgMl07XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgdCArPSAoYiAmIGluZmxhdGVfbWFza1tlXSk7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgdHBfaW5kZXhfdF8zID0gKHRwX2luZGV4ICsgdCkgKiAzO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoZSA9IHRwW3RwX2luZGV4X3RfM10pID09PSAwKSB7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIgPj49ICh0cFt0cF9pbmRleF90XzMgKyAxXSk7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGsgLT0gKHRwW3RwX2luZGV4X3RfMyArIDFdKTtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcy53aW5kb3dbcSsrXSA9IC8qIChieXRlKSAqL3RwW3RwX2luZGV4X3RfMyArIDJdO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtLS07XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoKGUgJiAzMikgIT09IDApIHtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBjID0gei5hdmFpbF9pbiAtIG47XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgYyA9IChrID4+IDMpIDwgYyA/IGsgPj4gMyA6IGM7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgbiArPSBjO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHAgLT0gYztcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBrIC09IGMgPDwgMztcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBzLmJpdGIgPSBiO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHMuYml0ayA9IGs7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgei5hdmFpbF9pbiA9IG47XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgei50b3RhbF9pbiArPSBwIC0gei5uZXh0X2luX2luZGV4O1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHoubmV4dF9pbl9pbmRleCA9IHA7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgcy53cml0ZSA9IHE7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VORDtcXHJcXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgei5tc2cgPSBcXFwiaW52YWxpZCBsaXRlcmFsL2xlbmd0aCBjb2RlXFxcIjtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBjID0gei5hdmFpbF9pbiAtIG47XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgYyA9IChrID4+IDMpIDwgYyA/IGsgPj4gMyA6IGM7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgbiArPSBjO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHAgLT0gYztcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBrIC09IGMgPDwgMztcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBzLmJpdGIgPSBiO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHMuYml0ayA9IGs7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgei5hdmFpbF9pbiA9IG47XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgei50b3RhbF9pbiArPSBwIC0gei5uZXh0X2luX2luZGV4O1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHoubmV4dF9pbl9pbmRleCA9IHA7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgcy53cml0ZSA9IHE7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFpfREFUQV9FUlJPUjtcXHJcXG4gICAgICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgfSB3aGlsZSAodHJ1ZSk7XFxyXFxuICAgICAgICAgICAgfSB3aGlsZSAobSA+PSAyNTggJiYgbiA+PSAxMCk7XFxyXFxuXFxyXFxuICAgICAgICAgICAgLy8gbm90IGVub3VnaCBpbnB1dCBvciBvdXRwdXQtLXJlc3RvcmUgcG9pbnRlcnMgYW5kIHJldHVyblxcclxcbiAgICAgICAgICAgIGMgPSB6LmF2YWlsX2luIC0gbjtcXHJcXG4gICAgICAgICAgICBjID0gKGsgPj4gMykgPCBjID8gayA+PiAzIDogYztcXHJcXG4gICAgICAgICAgICBuICs9IGM7XFxyXFxuICAgICAgICAgICAgcCAtPSBjO1xcclxcbiAgICAgICAgICAgIGsgLT0gYyA8PCAzO1xcclxcblxcclxcbiAgICAgICAgICAgIHMuYml0YiA9IGI7XFxyXFxuICAgICAgICAgICAgcy5iaXRrID0gaztcXHJcXG4gICAgICAgICAgICB6LmF2YWlsX2luID0gbjtcXHJcXG4gICAgICAgICAgICB6LnRvdGFsX2luICs9IHAgLSB6Lm5leHRfaW5faW5kZXg7XFxyXFxuICAgICAgICAgICAgei5uZXh0X2luX2luZGV4ID0gcDtcXHJcXG4gICAgICAgICAgICBzLndyaXRlID0gcTtcXHJcXG5cXHJcXG4gICAgICAgICAgICByZXR1cm4gWl9PSztcXHJcXG4gICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgIHRoYXQuaW5pdCA9IGZ1bmN0aW9uKGJsLCBiZCwgdGwsIHRsX2luZGV4LCB0ZCwgdGRfaW5kZXgpIHtcXHJcXG4gICAgICAgICAgICBtb2RlID0gU1RBUlQ7XFxyXFxuICAgICAgICAgICAgbGJpdHMgPSAvKiAoYnl0ZSkgKi9ibDtcXHJcXG4gICAgICAgICAgICBkYml0cyA9IC8qIChieXRlKSAqL2JkO1xcclxcbiAgICAgICAgICAgIGx0cmVlID0gdGw7XFxyXFxuICAgICAgICAgICAgbHRyZWVfaW5kZXggPSB0bF9pbmRleDtcXHJcXG4gICAgICAgICAgICBkdHJlZSA9IHRkO1xcclxcbiAgICAgICAgICAgIGR0cmVlX2luZGV4ID0gdGRfaW5kZXg7XFxyXFxuICAgICAgICAgICAgdHJlZSA9IG51bGw7XFxyXFxuICAgICAgICB9O1xcclxcblxcclxcbiAgICAgICAgdGhhdC5wcm9jID0gZnVuY3Rpb24ocywgeiwgcikge1xcclxcbiAgICAgICAgICAgIHZhciBqOyAvLyB0ZW1wb3Jhcnkgc3RvcmFnZVxcclxcbiAgICAgICAgICAgIHZhciB0aW5kZXg7IC8vIHRlbXBvcmFyeSBwb2ludGVyXFxyXFxuICAgICAgICAgICAgdmFyIGU7IC8vIGV4dHJhIGJpdHMgb3Igb3BlcmF0aW9uXFxyXFxuICAgICAgICAgICAgdmFyIGIgPSAwOyAvLyBiaXQgYnVmZmVyXFxyXFxuICAgICAgICAgICAgdmFyIGsgPSAwOyAvLyBiaXRzIGluIGJpdCBidWZmZXJcXHJcXG4gICAgICAgICAgICB2YXIgcCA9IDA7IC8vIGlucHV0IGRhdGEgcG9pbnRlclxcclxcbiAgICAgICAgICAgIHZhciBuOyAvLyBieXRlcyBhdmFpbGFibGUgdGhlcmVcXHJcXG4gICAgICAgICAgICB2YXIgcTsgLy8gb3V0cHV0IHdpbmRvdyB3cml0ZSBwb2ludGVyXFxyXFxuICAgICAgICAgICAgdmFyIG07IC8vIGJ5dGVzIHRvIGVuZCBvZiB3aW5kb3cgb3IgcmVhZCBwb2ludGVyXFxyXFxuICAgICAgICAgICAgdmFyIGY7IC8vIHBvaW50ZXIgdG8gY29weSBzdHJpbmdzIGZyb21cXHJcXG5cXHJcXG4gICAgICAgICAgICAvLyBjb3B5IGlucHV0L291dHB1dCBpbmZvcm1hdGlvbiB0byBsb2NhbHMgKFVQREFURSBtYWNybyByZXN0b3JlcylcXHJcXG4gICAgICAgICAgICBwID0gei5uZXh0X2luX2luZGV4O1xcclxcbiAgICAgICAgICAgIG4gPSB6LmF2YWlsX2luO1xcclxcbiAgICAgICAgICAgIGIgPSBzLmJpdGI7XFxyXFxuICAgICAgICAgICAgayA9IHMuYml0aztcXHJcXG4gICAgICAgICAgICBxID0gcy53cml0ZTtcXHJcXG4gICAgICAgICAgICBtID0gcSA8IHMucmVhZCA/IHMucmVhZCAtIHEgLSAxIDogcy5lbmQgLSBxO1xcclxcblxcclxcbiAgICAgICAgICAgIC8vIHByb2Nlc3MgaW5wdXQgYW5kIG91dHB1dCBiYXNlZCBvbiBjdXJyZW50IHN0YXRlXFxyXFxuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcXHJcXG4gICAgICAgICAgICAgICAgc3dpdGNoIChtb2RlKSB7XFxyXFxuICAgICAgICAgICAgICAgIC8vIHdhaXRpbmcgZm9yIFxcXCJpOlxcXCI9aW5wdXQsIFxcXCJvOlxcXCI9b3V0cHV0LCBcXFwieDpcXFwiPW5vdGhpbmdcXHJcXG4gICAgICAgICAgICAgICAgY2FzZSBTVEFSVDogLy8geDogc2V0IHVwIGZvciBMRU5cXHJcXG4gICAgICAgICAgICAgICAgICAgIGlmIChtID49IDI1OCAmJiBuID49IDEwKSB7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgcy5iaXRiID0gYjtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBzLmJpdGsgPSBrO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHouYXZhaWxfaW4gPSBuO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHoudG90YWxfaW4gKz0gcCAtIHoubmV4dF9pbl9pbmRleDtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB6Lm5leHRfaW5faW5kZXggPSBwO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHMud3JpdGUgPSBxO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHIgPSBpbmZsYXRlX2Zhc3QobGJpdHMsIGRiaXRzLCBsdHJlZSwgbHRyZWVfaW5kZXgsIGR0cmVlLCBkdHJlZV9pbmRleCwgcywgeik7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgcCA9IHoubmV4dF9pbl9pbmRleDtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBuID0gei5hdmFpbF9pbjtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBiID0gcy5iaXRiO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGsgPSBzLmJpdGs7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgcSA9IHMud3JpdGU7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgbSA9IHEgPCBzLnJlYWQgPyBzLnJlYWQgLSBxIC0gMSA6IHMuZW5kIC0gcTtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAociAhPSBaX09LKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGUgPSByID09IFpfU1RSRUFNX0VORCA/IFdBU0ggOiBCQURDT0RFO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgICAgICBuZWVkID0gbGJpdHM7XFxyXFxuICAgICAgICAgICAgICAgICAgICB0cmVlID0gbHRyZWU7XFxyXFxuICAgICAgICAgICAgICAgICAgICB0cmVlX2luZGV4ID0gbHRyZWVfaW5kZXg7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICBtb2RlID0gTEVOO1xcclxcbiAgICAgICAgICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xcclxcbiAgICAgICAgICAgICAgICBjYXNlIExFTjogLy8gaTogZ2V0IGxlbmd0aC9saXRlcmFsL2VvYiBuZXh0XFxyXFxuICAgICAgICAgICAgICAgICAgICBqID0gbmVlZDtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChrIDwgKGopKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG4gIT09IDApXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgPSBaX09LO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzLmJpdGIgPSBiO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzLmJpdGsgPSBrO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB6LmF2YWlsX2luID0gbjtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgei50b3RhbF9pbiArPSBwIC0gei5uZXh0X2luX2luZGV4O1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB6Lm5leHRfaW5faW5kZXggPSBwO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzLndyaXRlID0gcTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHMuaW5mbGF0ZV9mbHVzaCh6LCByKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgbi0tO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGIgfD0gKHoucmVhZF9ieXRlKHArKykgJiAweGZmKSA8PCBrO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGsgKz0gODtcXHJcXG4gICAgICAgICAgICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgIHRpbmRleCA9ICh0cmVlX2luZGV4ICsgKGIgJiBpbmZsYXRlX21hc2tbal0pKSAqIDM7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICBiID4+Pj0gKHRyZWVbdGluZGV4ICsgMV0pO1xcclxcbiAgICAgICAgICAgICAgICAgICAgayAtPSAodHJlZVt0aW5kZXggKyAxXSk7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICBlID0gdHJlZVt0aW5kZXhdO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUgPT09IDApIHsgLy8gbGl0ZXJhbFxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpdCA9IHRyZWVbdGluZGV4ICsgMl07XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZSA9IExJVDtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcXHJcXG4gICAgICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgICAgIGlmICgoZSAmIDE2KSAhPT0gMCkgeyAvLyBsZW5ndGhcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQgPSBlICYgMTU7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVuID0gdHJlZVt0aW5kZXggKyAyXTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlID0gTEVORVhUO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcclxcbiAgICAgICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICAgICAgaWYgKChlICYgNjQpID09PSAwKSB7IC8vIG5leHQgdGFibGVcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBuZWVkID0gZTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmVlX2luZGV4ID0gdGluZGV4IC8gMyArIHRyZWVbdGluZGV4ICsgMl07XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxyXFxuICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgICAgICBpZiAoKGUgJiAzMikgIT09IDApIHsgLy8gZW5kIG9mIGJsb2NrXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZSA9IFdBU0g7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxyXFxuICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgICAgICBtb2RlID0gQkFEQ09ERTsgLy8gaW52YWxpZCBjb2RlXFxyXFxuICAgICAgICAgICAgICAgICAgICB6Lm1zZyA9IFxcXCJpbnZhbGlkIGxpdGVyYWwvbGVuZ3RoIGNvZGVcXFwiO1xcclxcbiAgICAgICAgICAgICAgICAgICAgciA9IFpfREFUQV9FUlJPUjtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgIHMuYml0YiA9IGI7XFxyXFxuICAgICAgICAgICAgICAgICAgICBzLmJpdGsgPSBrO1xcclxcbiAgICAgICAgICAgICAgICAgICAgei5hdmFpbF9pbiA9IG47XFxyXFxuICAgICAgICAgICAgICAgICAgICB6LnRvdGFsX2luICs9IHAgLSB6Lm5leHRfaW5faW5kZXg7XFxyXFxuICAgICAgICAgICAgICAgICAgICB6Lm5leHRfaW5faW5kZXggPSBwO1xcclxcbiAgICAgICAgICAgICAgICAgICAgcy53cml0ZSA9IHE7XFxyXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcy5pbmZsYXRlX2ZsdXNoKHosIHIpO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICBjYXNlIExFTkVYVDogLy8gaTogZ2V0dGluZyBsZW5ndGggZXh0cmEgKGhhdmUgYmFzZSlcXHJcXG4gICAgICAgICAgICAgICAgICAgIGogPSBnZXQ7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoayA8IChqKSkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuICE9PSAwKVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByID0gWl9PSztcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcy5iaXRiID0gYjtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcy5iaXRrID0gaztcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgei5hdmFpbF9pbiA9IG47XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHoudG90YWxfaW4gKz0gcCAtIHoubmV4dF9pbl9pbmRleDtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgei5uZXh0X2luX2luZGV4ID0gcDtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcy53cml0ZSA9IHE7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzLmluZmxhdGVfZmx1c2goeiwgcik7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIG4tLTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBiIHw9ICh6LnJlYWRfYnl0ZShwKyspICYgMHhmZikgPDwgaztcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBrICs9IDg7XFxyXFxuICAgICAgICAgICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICBsZW4gKz0gKGIgJiBpbmZsYXRlX21hc2tbal0pO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgYiA+Pj0gajtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGsgLT0gajtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgIG5lZWQgPSBkYml0cztcXHJcXG4gICAgICAgICAgICAgICAgICAgIHRyZWUgPSBkdHJlZTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHRyZWVfaW5kZXggPSBkdHJlZV9pbmRleDtcXHJcXG4gICAgICAgICAgICAgICAgICAgIG1vZGUgPSBESVNUO1xcclxcbiAgICAgICAgICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xcclxcbiAgICAgICAgICAgICAgICBjYXNlIERJU1Q6IC8vIGk6IGdldCBkaXN0YW5jZSBuZXh0XFxyXFxuICAgICAgICAgICAgICAgICAgICBqID0gbmVlZDtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChrIDwgKGopKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG4gIT09IDApXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgPSBaX09LO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzLmJpdGIgPSBiO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzLmJpdGsgPSBrO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB6LmF2YWlsX2luID0gbjtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgei50b3RhbF9pbiArPSBwIC0gei5uZXh0X2luX2luZGV4O1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB6Lm5leHRfaW5faW5kZXggPSBwO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzLndyaXRlID0gcTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHMuaW5mbGF0ZV9mbHVzaCh6LCByKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgbi0tO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGIgfD0gKHoucmVhZF9ieXRlKHArKykgJiAweGZmKSA8PCBrO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGsgKz0gODtcXHJcXG4gICAgICAgICAgICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgIHRpbmRleCA9ICh0cmVlX2luZGV4ICsgKGIgJiBpbmZsYXRlX21hc2tbal0pKSAqIDM7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICBiID4+PSB0cmVlW3RpbmRleCArIDFdO1xcclxcbiAgICAgICAgICAgICAgICAgICAgayAtPSB0cmVlW3RpbmRleCArIDFdO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgZSA9ICh0cmVlW3RpbmRleF0pO1xcclxcbiAgICAgICAgICAgICAgICAgICAgaWYgKChlICYgMTYpICE9PSAwKSB7IC8vIGRpc3RhbmNlXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0ID0gZSAmIDE1O1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3QgPSB0cmVlW3RpbmRleCArIDJdO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGUgPSBESVNURVhUO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcclxcbiAgICAgICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICAgICAgaWYgKChlICYgNjQpID09PSAwKSB7IC8vIG5leHQgdGFibGVcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBuZWVkID0gZTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmVlX2luZGV4ID0gdGluZGV4IC8gMyArIHRyZWVbdGluZGV4ICsgMl07XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxyXFxuICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgICAgICBtb2RlID0gQkFEQ09ERTsgLy8gaW52YWxpZCBjb2RlXFxyXFxuICAgICAgICAgICAgICAgICAgICB6Lm1zZyA9IFxcXCJpbnZhbGlkIGRpc3RhbmNlIGNvZGVcXFwiO1xcclxcbiAgICAgICAgICAgICAgICAgICAgciA9IFpfREFUQV9FUlJPUjtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgIHMuYml0YiA9IGI7XFxyXFxuICAgICAgICAgICAgICAgICAgICBzLmJpdGsgPSBrO1xcclxcbiAgICAgICAgICAgICAgICAgICAgei5hdmFpbF9pbiA9IG47XFxyXFxuICAgICAgICAgICAgICAgICAgICB6LnRvdGFsX2luICs9IHAgLSB6Lm5leHRfaW5faW5kZXg7XFxyXFxuICAgICAgICAgICAgICAgICAgICB6Lm5leHRfaW5faW5kZXggPSBwO1xcclxcbiAgICAgICAgICAgICAgICAgICAgcy53cml0ZSA9IHE7XFxyXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcy5pbmZsYXRlX2ZsdXNoKHosIHIpO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICBjYXNlIERJU1RFWFQ6IC8vIGk6IGdldHRpbmcgZGlzdGFuY2UgZXh0cmFcXHJcXG4gICAgICAgICAgICAgICAgICAgIGogPSBnZXQ7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoayA8IChqKSkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuICE9PSAwKVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByID0gWl9PSztcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcy5iaXRiID0gYjtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcy5iaXRrID0gaztcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgei5hdmFpbF9pbiA9IG47XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHoudG90YWxfaW4gKz0gcCAtIHoubmV4dF9pbl9pbmRleDtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgei5uZXh0X2luX2luZGV4ID0gcDtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcy53cml0ZSA9IHE7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzLmluZmxhdGVfZmx1c2goeiwgcik7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIG4tLTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBiIHw9ICh6LnJlYWRfYnl0ZShwKyspICYgMHhmZikgPDwgaztcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBrICs9IDg7XFxyXFxuICAgICAgICAgICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICBkaXN0ICs9IChiICYgaW5mbGF0ZV9tYXNrW2pdKTtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgIGIgPj49IGo7XFxyXFxuICAgICAgICAgICAgICAgICAgICBrIC09IGo7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICBtb2RlID0gQ09QWTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cXHJcXG4gICAgICAgICAgICAgICAgY2FzZSBDT1BZOiAvLyBvOiBjb3B5aW5nIGJ5dGVzIGluIHdpbmRvdywgd2FpdGluZyBmb3Igc3BhY2VcXHJcXG4gICAgICAgICAgICAgICAgICAgIGYgPSBxIC0gZGlzdDtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChmIDwgMCkgeyAvLyBtb2R1bG8gd2luZG93IHNpemUtXFxcIndoaWxlXFxcIiBpbnN0ZWFkXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgZiArPSBzLmVuZDsgLy8gb2YgXFxcImlmXFxcIiBoYW5kbGVzIGludmFsaWQgZGlzdGFuY2VzXFxyXFxuICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAobGVuICE9PSAwKSB7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG0gPT09IDApIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHEgPT0gcy5lbmQgJiYgcy5yZWFkICE9PSAwKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxID0gMDtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0gPSBxIDwgcy5yZWFkID8gcy5yZWFkIC0gcSAtIDEgOiBzLmVuZCAtIHE7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG0gPT09IDApIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMud3JpdGUgPSBxO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgciA9IHMuaW5mbGF0ZV9mbHVzaCh6LCByKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHEgPSBzLndyaXRlO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbSA9IHEgPCBzLnJlYWQgPyBzLnJlYWQgLSBxIC0gMSA6IHMuZW5kIC0gcTtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChxID09IHMuZW5kICYmIHMucmVhZCAhPT0gMCkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHEgPSAwO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0gPSBxIDwgcy5yZWFkID8gcy5yZWFkIC0gcSAtIDEgOiBzLmVuZCAtIHE7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobSA9PT0gMCkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMuYml0YiA9IGI7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcy5iaXRrID0gaztcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB6LmF2YWlsX2luID0gbjtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB6LnRvdGFsX2luICs9IHAgLSB6Lm5leHRfaW5faW5kZXg7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgei5uZXh0X2luX2luZGV4ID0gcDtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzLndyaXRlID0gcTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcy5pbmZsYXRlX2ZsdXNoKHosIHIpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHMud2luZG93W3ErK10gPSBzLndpbmRvd1tmKytdO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIG0tLTtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZiA9PSBzLmVuZClcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZiA9IDA7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVuLS07XFxyXFxuICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgICAgICBtb2RlID0gU1RBUlQ7XFxyXFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcXHJcXG4gICAgICAgICAgICAgICAgY2FzZSBMSVQ6IC8vIG86IGdvdCBsaXRlcmFsLCB3YWl0aW5nIGZvciBvdXRwdXQgc3BhY2VcXHJcXG4gICAgICAgICAgICAgICAgICAgIGlmIChtID09PSAwKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHEgPT0gcy5lbmQgJiYgcy5yZWFkICE9PSAwKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHEgPSAwO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtID0gcSA8IHMucmVhZCA/IHMucmVhZCAtIHEgLSAxIDogcy5lbmQgLSBxO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobSA9PT0gMCkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzLndyaXRlID0gcTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgciA9IHMuaW5mbGF0ZV9mbHVzaCh6LCByKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcSA9IHMud3JpdGU7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0gPSBxIDwgcy5yZWFkID8gcy5yZWFkIC0gcSAtIDEgOiBzLmVuZCAtIHE7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChxID09IHMuZW5kICYmIHMucmVhZCAhPT0gMCkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcSA9IDA7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtID0gcSA8IHMucmVhZCA/IHMucmVhZCAtIHEgLSAxIDogcy5lbmQgLSBxO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtID09PSAwKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzLmJpdGIgPSBiO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcy5iaXRrID0gaztcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHouYXZhaWxfaW4gPSBuO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgei50b3RhbF9pbiArPSBwIC0gei5uZXh0X2luX2luZGV4O1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgei5uZXh0X2luX2luZGV4ID0gcDtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMud3JpdGUgPSBxO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHMuaW5mbGF0ZV9mbHVzaCh6LCByKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgICAgIHIgPSBaX09LO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgcy53aW5kb3dbcSsrXSA9IC8qIChieXRlKSAqL2xpdDtcXHJcXG4gICAgICAgICAgICAgICAgICAgIG0tLTtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgIG1vZGUgPSBTVEFSVDtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcclxcbiAgICAgICAgICAgICAgICBjYXNlIFdBU0g6IC8vIG86IGdvdCBlb2IsIHBvc3NpYmx5IG1vcmUgb3V0cHV0XFxyXFxuICAgICAgICAgICAgICAgICAgICBpZiAoayA+IDcpIHsgLy8gcmV0dXJuIHVudXNlZCBieXRlLCBpZiBhbnlcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBrIC09IDg7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgbisrO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHAtLTsgLy8gY2FuIGFsd2F5cyByZXR1cm4gb25lXFxyXFxuICAgICAgICAgICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICBzLndyaXRlID0gcTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHIgPSBzLmluZmxhdGVfZmx1c2goeiwgcik7XFxyXFxuICAgICAgICAgICAgICAgICAgICBxID0gcy53cml0ZTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIG0gPSBxIDwgcy5yZWFkID8gcy5yZWFkIC0gcSAtIDEgOiBzLmVuZCAtIHE7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICBpZiAocy5yZWFkICE9IHMud3JpdGUpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBzLmJpdGIgPSBiO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHMuYml0ayA9IGs7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgei5hdmFpbF9pbiA9IG47XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgei50b3RhbF9pbiArPSBwIC0gei5uZXh0X2luX2luZGV4O1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHoubmV4dF9pbl9pbmRleCA9IHA7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgcy53cml0ZSA9IHE7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHMuaW5mbGF0ZV9mbHVzaCh6LCByKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgICAgIG1vZGUgPSBFTkQ7XFxyXFxuICAgICAgICAgICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXFxyXFxuICAgICAgICAgICAgICAgIGNhc2UgRU5EOlxcclxcbiAgICAgICAgICAgICAgICAgICAgciA9IFpfU1RSRUFNX0VORDtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHMuYml0YiA9IGI7XFxyXFxuICAgICAgICAgICAgICAgICAgICBzLmJpdGsgPSBrO1xcclxcbiAgICAgICAgICAgICAgICAgICAgei5hdmFpbF9pbiA9IG47XFxyXFxuICAgICAgICAgICAgICAgICAgICB6LnRvdGFsX2luICs9IHAgLSB6Lm5leHRfaW5faW5kZXg7XFxyXFxuICAgICAgICAgICAgICAgICAgICB6Lm5leHRfaW5faW5kZXggPSBwO1xcclxcbiAgICAgICAgICAgICAgICAgICAgcy53cml0ZSA9IHE7XFxyXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcy5pbmZsYXRlX2ZsdXNoKHosIHIpO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICBjYXNlIEJBRENPREU6IC8vIHg6IGdvdCBlcnJvclxcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgciA9IFpfREFUQV9FUlJPUjtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgIHMuYml0YiA9IGI7XFxyXFxuICAgICAgICAgICAgICAgICAgICBzLmJpdGsgPSBrO1xcclxcbiAgICAgICAgICAgICAgICAgICAgei5hdmFpbF9pbiA9IG47XFxyXFxuICAgICAgICAgICAgICAgICAgICB6LnRvdGFsX2luICs9IHAgLSB6Lm5leHRfaW5faW5kZXg7XFxyXFxuICAgICAgICAgICAgICAgICAgICB6Lm5leHRfaW5faW5kZXggPSBwO1xcclxcbiAgICAgICAgICAgICAgICAgICAgcy53cml0ZSA9IHE7XFxyXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcy5pbmZsYXRlX2ZsdXNoKHosIHIpO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxcclxcbiAgICAgICAgICAgICAgICAgICAgciA9IFpfU1RSRUFNX0VSUk9SO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgcy5iaXRiID0gYjtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHMuYml0ayA9IGs7XFxyXFxuICAgICAgICAgICAgICAgICAgICB6LmF2YWlsX2luID0gbjtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHoudG90YWxfaW4gKz0gcCAtIHoubmV4dF9pbl9pbmRleDtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHoubmV4dF9pbl9pbmRleCA9IHA7XFxyXFxuICAgICAgICAgICAgICAgICAgICBzLndyaXRlID0gcTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzLmluZmxhdGVfZmx1c2goeiwgcik7XFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICB9O1xcclxcblxcclxcbiAgICAgICAgdGhhdC5mcmVlID0gZnVuY3Rpb24oKSB7XFxyXFxuICAgICAgICAgICAgLy8gWkZSRUUoeiwgYyk7XFxyXFxuICAgICAgICB9O1xcclxcblxcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgIC8vIEluZkJsb2Nrc1xcclxcblxcclxcbiAgICAvLyBUYWJsZSBmb3IgZGVmbGF0ZSBmcm9tIFBLWklQJ3MgYXBwbm90ZS50eHQuXFxyXFxuICAgIHZhciBib3JkZXIgPSBbIC8vIE9yZGVyIG9mIHRoZSBiaXQgbGVuZ3RoIGNvZGUgbGVuZ3Roc1xcclxcbiAgICAxNiwgMTcsIDE4LCAwLCA4LCA3LCA5LCA2LCAxMCwgNSwgMTEsIDQsIDEyLCAzLCAxMywgMiwgMTQsIDEsIDE1IF07XFxyXFxuXFxyXFxuICAgIHZhciBUWVBFID0gMDsgLy8gZ2V0IHR5cGUgYml0cyAoMywgaW5jbHVkaW5nIGVuZCBiaXQpXFxyXFxuICAgIHZhciBMRU5TID0gMTsgLy8gZ2V0IGxlbmd0aHMgZm9yIHN0b3JlZFxcclxcbiAgICB2YXIgU1RPUkVEID0gMjsvLyBwcm9jZXNzaW5nIHN0b3JlZCBibG9ja1xcclxcbiAgICB2YXIgVEFCTEUgPSAzOyAvLyBnZXQgdGFibGUgbGVuZ3Roc1xcclxcbiAgICB2YXIgQlRSRUUgPSA0OyAvLyBnZXQgYml0IGxlbmd0aHMgdHJlZSBmb3IgYSBkeW5hbWljXFxyXFxuICAgIC8vIGJsb2NrXFxyXFxuICAgIHZhciBEVFJFRSA9IDU7IC8vIGdldCBsZW5ndGgsIGRpc3RhbmNlIHRyZWVzIGZvciBhXFxyXFxuICAgIC8vIGR5bmFtaWMgYmxvY2tcXHJcXG4gICAgdmFyIENPREVTID0gNjsgLy8gcHJvY2Vzc2luZyBmaXhlZCBvciBkeW5hbWljIGJsb2NrXFxyXFxuICAgIHZhciBEUlkgPSA3OyAvLyBvdXRwdXQgcmVtYWluaW5nIHdpbmRvdyBieXRlc1xcclxcbiAgICB2YXIgRE9ORUxPQ0tTID0gODsgLy8gZmluaXNoZWQgbGFzdCBibG9jaywgZG9uZVxcclxcbiAgICB2YXIgQkFEQkxPQ0tTID0gOTsgLy8gb3QgYSBkYXRhIGVycm9yLS1zdHVjayBoZXJlXFxyXFxuXFxyXFxuICAgIGZ1bmN0aW9uIEluZkJsb2Nrcyh6LCB3KSB7XFxyXFxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XFxyXFxuXFxyXFxuICAgICAgICB2YXIgbW9kZSA9IFRZUEU7IC8vIGN1cnJlbnQgaW5mbGF0ZV9ibG9jayBtb2RlXFxyXFxuXFxyXFxuICAgICAgICB2YXIgbGVmdCA9IDA7IC8vIGlmIFNUT1JFRCwgYnl0ZXMgbGVmdCB0byBjb3B5XFxyXFxuXFxyXFxuICAgICAgICB2YXIgdGFibGUgPSAwOyAvLyB0YWJsZSBsZW5ndGhzICgxNCBiaXRzKVxcclxcbiAgICAgICAgdmFyIGluZGV4ID0gMDsgLy8gaW5kZXggaW50byBibGVucyAob3IgYm9yZGVyKVxcclxcbiAgICAgICAgdmFyIGJsZW5zOyAvLyBiaXQgbGVuZ3RocyBvZiBjb2Rlc1xcclxcbiAgICAgICAgdmFyIGJiID0gWyAwIF07IC8vIGJpdCBsZW5ndGggdHJlZSBkZXB0aFxcclxcbiAgICAgICAgdmFyIHRiID0gWyAwIF07IC8vIGJpdCBsZW5ndGggZGVjb2RpbmcgdHJlZVxcclxcblxcclxcbiAgICAgICAgdmFyIGNvZGVzID0gbmV3IEluZkNvZGVzKCk7IC8vIGlmIENPREVTLCBjdXJyZW50IHN0YXRlXFxyXFxuXFxyXFxuICAgICAgICB2YXIgbGFzdCA9IDA7IC8vIHRydWUgaWYgdGhpcyBibG9jayBpcyB0aGUgbGFzdCBibG9ja1xcclxcblxcclxcbiAgICAgICAgdmFyIGh1ZnRzID0gbmV3IEludDMyQXJyYXkoTUFOWSAqIDMpOyAvLyBzaW5nbGUgbWFsbG9jIGZvciB0cmVlIHNwYWNlXFxyXFxuICAgICAgICB2YXIgY2hlY2sgPSAwOyAvLyBjaGVjayBvbiBvdXRwdXRcXHJcXG4gICAgICAgIHZhciBpbmZ0cmVlID0gbmV3IEluZlRyZWUoKTtcXHJcXG5cXHJcXG4gICAgICAgIHRoYXQuYml0ayA9IDA7IC8vIGJpdHMgaW4gYml0IGJ1ZmZlclxcclxcbiAgICAgICAgdGhhdC5iaXRiID0gMDsgLy8gYml0IGJ1ZmZlclxcclxcbiAgICAgICAgdGhhdC53aW5kb3cgPSBuZXcgVWludDhBcnJheSh3KTsgLy8gc2xpZGluZyB3aW5kb3dcXHJcXG4gICAgICAgIHRoYXQuZW5kID0gdzsgLy8gb25lIGJ5dGUgYWZ0ZXIgc2xpZGluZyB3aW5kb3dcXHJcXG4gICAgICAgIHRoYXQucmVhZCA9IDA7IC8vIHdpbmRvdyByZWFkIHBvaW50ZXJcXHJcXG4gICAgICAgIHRoYXQud3JpdGUgPSAwOyAvLyB3aW5kb3cgd3JpdGUgcG9pbnRlclxcclxcblxcclxcbiAgICAgICAgdGhhdC5yZXNldCA9IGZ1bmN0aW9uKHosIGMpIHtcXHJcXG4gICAgICAgICAgICBpZiAoYylcXHJcXG4gICAgICAgICAgICAgICAgY1swXSA9IGNoZWNrO1xcclxcbiAgICAgICAgICAgIC8vIGlmIChtb2RlID09IEJUUkVFIHx8IG1vZGUgPT0gRFRSRUUpIHtcXHJcXG4gICAgICAgICAgICAvLyB9XFxyXFxuICAgICAgICAgICAgaWYgKG1vZGUgPT0gQ09ERVMpIHtcXHJcXG4gICAgICAgICAgICAgICAgY29kZXMuZnJlZSh6KTtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgbW9kZSA9IFRZUEU7XFxyXFxuICAgICAgICAgICAgdGhhdC5iaXRrID0gMDtcXHJcXG4gICAgICAgICAgICB0aGF0LmJpdGIgPSAwO1xcclxcbiAgICAgICAgICAgIHRoYXQucmVhZCA9IHRoYXQud3JpdGUgPSAwO1xcclxcbiAgICAgICAgfTtcXHJcXG5cXHJcXG4gICAgICAgIHRoYXQucmVzZXQoeiwgbnVsbCk7XFxyXFxuXFxyXFxuICAgICAgICAvLyBjb3B5IGFzIG11Y2ggYXMgcG9zc2libGUgZnJvbSB0aGUgc2xpZGluZyB3aW5kb3cgdG8gdGhlIG91dHB1dCBhcmVhXFxyXFxuICAgICAgICB0aGF0LmluZmxhdGVfZmx1c2ggPSBmdW5jdGlvbih6LCByKSB7XFxyXFxuICAgICAgICAgICAgdmFyIG47XFxyXFxuICAgICAgICAgICAgdmFyIHA7XFxyXFxuICAgICAgICAgICAgdmFyIHE7XFxyXFxuXFxyXFxuICAgICAgICAgICAgLy8gbG9jYWwgY29waWVzIG9mIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gcG9pbnRlcnNcXHJcXG4gICAgICAgICAgICBwID0gei5uZXh0X291dF9pbmRleDtcXHJcXG4gICAgICAgICAgICBxID0gdGhhdC5yZWFkO1xcclxcblxcclxcbiAgICAgICAgICAgIC8vIGNvbXB1dGUgbnVtYmVyIG9mIGJ5dGVzIHRvIGNvcHkgYXMgZmFyIGFzIGVuZCBvZiB3aW5kb3dcXHJcXG4gICAgICAgICAgICBuID0gLyogKGludCkgKi8oKHEgPD0gdGhhdC53cml0ZSA/IHRoYXQud3JpdGUgOiB0aGF0LmVuZCkgLSBxKTtcXHJcXG4gICAgICAgICAgICBpZiAobiA+IHouYXZhaWxfb3V0KVxcclxcbiAgICAgICAgICAgICAgICBuID0gei5hdmFpbF9vdXQ7XFxyXFxuICAgICAgICAgICAgaWYgKG4gIT09IDAgJiYgciA9PSBaX0JVRl9FUlJPUilcXHJcXG4gICAgICAgICAgICAgICAgciA9IFpfT0s7XFxyXFxuXFxyXFxuICAgICAgICAgICAgLy8gdXBkYXRlIGNvdW50ZXJzXFxyXFxuICAgICAgICAgICAgei5hdmFpbF9vdXQgLT0gbjtcXHJcXG4gICAgICAgICAgICB6LnRvdGFsX291dCArPSBuO1xcclxcblxcclxcbiAgICAgICAgICAgIC8vIGNvcHkgYXMgZmFyIGFzIGVuZCBvZiB3aW5kb3dcXHJcXG4gICAgICAgICAgICB6Lm5leHRfb3V0LnNldCh0aGF0LndpbmRvdy5zdWJhcnJheShxLCBxICsgbiksIHApO1xcclxcbiAgICAgICAgICAgIHAgKz0gbjtcXHJcXG4gICAgICAgICAgICBxICs9IG47XFxyXFxuXFxyXFxuICAgICAgICAgICAgLy8gc2VlIGlmIG1vcmUgdG8gY29weSBhdCBiZWdpbm5pbmcgb2Ygd2luZG93XFxyXFxuICAgICAgICAgICAgaWYgKHEgPT0gdGhhdC5lbmQpIHtcXHJcXG4gICAgICAgICAgICAgICAgLy8gd3JhcCBwb2ludGVyc1xcclxcbiAgICAgICAgICAgICAgICBxID0gMDtcXHJcXG4gICAgICAgICAgICAgICAgaWYgKHRoYXQud3JpdGUgPT0gdGhhdC5lbmQpXFxyXFxuICAgICAgICAgICAgICAgICAgICB0aGF0LndyaXRlID0gMDtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgLy8gY29tcHV0ZSBieXRlcyB0byBjb3B5XFxyXFxuICAgICAgICAgICAgICAgIG4gPSB0aGF0LndyaXRlIC0gcTtcXHJcXG4gICAgICAgICAgICAgICAgaWYgKG4gPiB6LmF2YWlsX291dClcXHJcXG4gICAgICAgICAgICAgICAgICAgIG4gPSB6LmF2YWlsX291dDtcXHJcXG4gICAgICAgICAgICAgICAgaWYgKG4gIT09IDAgJiYgciA9PSBaX0JVRl9FUlJPUilcXHJcXG4gICAgICAgICAgICAgICAgICAgIHIgPSBaX09LO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgY291bnRlcnNcXHJcXG4gICAgICAgICAgICAgICAgei5hdmFpbF9vdXQgLT0gbjtcXHJcXG4gICAgICAgICAgICAgICAgei50b3RhbF9vdXQgKz0gbjtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgLy8gY29weVxcclxcbiAgICAgICAgICAgICAgICB6Lm5leHRfb3V0LnNldCh0aGF0LndpbmRvdy5zdWJhcnJheShxLCBxICsgbiksIHApO1xcclxcbiAgICAgICAgICAgICAgICBwICs9IG47XFxyXFxuICAgICAgICAgICAgICAgIHEgKz0gbjtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgLy8gdXBkYXRlIHBvaW50ZXJzXFxyXFxuICAgICAgICAgICAgei5uZXh0X291dF9pbmRleCA9IHA7XFxyXFxuICAgICAgICAgICAgdGhhdC5yZWFkID0gcTtcXHJcXG5cXHJcXG4gICAgICAgICAgICAvLyBkb25lXFxyXFxuICAgICAgICAgICAgcmV0dXJuIHI7XFxyXFxuICAgICAgICB9O1xcclxcblxcclxcbiAgICAgICAgdGhhdC5wcm9jID0gZnVuY3Rpb24oeiwgcikge1xcclxcbiAgICAgICAgICAgIHZhciB0OyAvLyB0ZW1wb3Jhcnkgc3RvcmFnZVxcclxcbiAgICAgICAgICAgIHZhciBiOyAvLyBiaXQgYnVmZmVyXFxyXFxuICAgICAgICAgICAgdmFyIGs7IC8vIGJpdHMgaW4gYml0IGJ1ZmZlclxcclxcbiAgICAgICAgICAgIHZhciBwOyAvLyBpbnB1dCBkYXRhIHBvaW50ZXJcXHJcXG4gICAgICAgICAgICB2YXIgbjsgLy8gYnl0ZXMgYXZhaWxhYmxlIHRoZXJlXFxyXFxuICAgICAgICAgICAgdmFyIHE7IC8vIG91dHB1dCB3aW5kb3cgd3JpdGUgcG9pbnRlclxcclxcbiAgICAgICAgICAgIHZhciBtOyAvLyBieXRlcyB0byBlbmQgb2Ygd2luZG93IG9yIHJlYWQgcG9pbnRlclxcclxcblxcclxcbiAgICAgICAgICAgIHZhciBpO1xcclxcblxcclxcbiAgICAgICAgICAgIC8vIGNvcHkgaW5wdXQvb3V0cHV0IGluZm9ybWF0aW9uIHRvIGxvY2FscyAoVVBEQVRFIG1hY3JvIHJlc3RvcmVzKVxcclxcbiAgICAgICAgICAgIC8vIHtcXHJcXG4gICAgICAgICAgICBwID0gei5uZXh0X2luX2luZGV4O1xcclxcbiAgICAgICAgICAgIG4gPSB6LmF2YWlsX2luO1xcclxcbiAgICAgICAgICAgIGIgPSB0aGF0LmJpdGI7XFxyXFxuICAgICAgICAgICAgayA9IHRoYXQuYml0aztcXHJcXG4gICAgICAgICAgICAvLyB9XFxyXFxuICAgICAgICAgICAgLy8ge1xcclxcbiAgICAgICAgICAgIHEgPSB0aGF0LndyaXRlO1xcclxcbiAgICAgICAgICAgIG0gPSAvKiAoaW50KSAqLyhxIDwgdGhhdC5yZWFkID8gdGhhdC5yZWFkIC0gcSAtIDEgOiB0aGF0LmVuZCAtIHEpO1xcclxcbiAgICAgICAgICAgIC8vIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICAvLyBwcm9jZXNzIGlucHV0IGJhc2VkIG9uIGN1cnJlbnQgc3RhdGVcXHJcXG4gICAgICAgICAgICAvLyBERUJVRyBkdHJlZVxcclxcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XFxyXFxuICAgICAgICAgICAgICAgIHN3aXRjaCAobW9kZSkge1xcclxcbiAgICAgICAgICAgICAgICBjYXNlIFRZUEU6XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoayA8ICgzKSkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuICE9PSAwKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgPSBaX09LO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuYml0YiA9IGI7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuYml0ayA9IGs7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHouYXZhaWxfaW4gPSBuO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB6LnRvdGFsX2luICs9IHAgLSB6Lm5leHRfaW5faW5kZXg7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHoubmV4dF9pbl9pbmRleCA9IHA7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQud3JpdGUgPSBxO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhhdC5pbmZsYXRlX2ZsdXNoKHosIHIpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBuLS07XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgYiB8PSAoei5yZWFkX2J5dGUocCsrKSAmIDB4ZmYpIDw8IGs7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgayArPSA4O1xcclxcbiAgICAgICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICAgICAgdCA9IC8qIChpbnQpICovKGIgJiA3KTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGxhc3QgPSB0ICYgMTtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodCA+Pj4gMSkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiAvLyBzdG9yZWRcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgYiA+Pj49ICgzKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBrIC09ICgzKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB9XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgdCA9IGsgJiA3OyAvLyBnbyB0byBieXRlIGJvdW5kYXJ5XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8ge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGIgPj4+PSAodCk7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgayAtPSAodCk7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gfVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGUgPSBMRU5TOyAvLyBnZXQgbGVuZ3RoIG9mIHN0b3JlZCBibG9ja1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcclxcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiAvLyBmaXhlZFxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYmwgPSBbXTsgLy8gbmV3IEFycmF5KDEpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiZCA9IFtdOyAvLyBuZXcgQXJyYXkoMSk7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRsID0gWyBbXSBdOyAvLyBuZXcgQXJyYXkoMSk7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRkID0gWyBbXSBdOyAvLyBuZXcgQXJyYXkoMSk7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgSW5mVHJlZS5pbmZsYXRlX3RyZWVzX2ZpeGVkKGJsLCBiZCwgdGwsIHRkKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2Rlcy5pbml0KGJsWzBdLCBiZFswXSwgdGxbMF0sIDAsIHRkWzBdLCAwKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8ge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGIgPj4+PSAoMyk7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgayAtPSAoMyk7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gfVxcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGUgPSBDT0RFUztcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcXHJcXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjogLy8gZHluYW1pY1xcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBiID4+Pj0gKDMpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGsgLT0gKDMpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlID0gVEFCTEU7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxyXFxuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6IC8vIGlsbGVnYWxcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgYiA+Pj49ICgzKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBrIC09ICgzKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB9XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZSA9IEJBREJMT0NLUztcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB6Lm1zZyA9IFxcXCJpbnZhbGlkIGJsb2NrIHR5cGVcXFwiO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHIgPSBaX0RBVEFfRVJST1I7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5iaXRiID0gYjtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmJpdGsgPSBrO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHouYXZhaWxfaW4gPSBuO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHoudG90YWxfaW4gKz0gcCAtIHoubmV4dF9pbl9pbmRleDtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB6Lm5leHRfaW5faW5kZXggPSBwO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQud3JpdGUgPSBxO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGF0LmluZmxhdGVfZmx1c2goeiwgcik7XFxyXFxuICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcXHJcXG4gICAgICAgICAgICAgICAgY2FzZSBMRU5TOlxcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGsgPCAoMzIpKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG4gIT09IDApIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgciA9IFpfT0s7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5iaXRiID0gYjtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5iaXRrID0gaztcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgei5hdmFpbF9pbiA9IG47XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHoudG90YWxfaW4gKz0gcCAtIHoubmV4dF9pbl9pbmRleDtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgei5uZXh0X2luX2luZGV4ID0gcDtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC53cml0ZSA9IHE7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGF0LmluZmxhdGVfZmx1c2goeiwgcik7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIG4tLTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBiIHw9ICh6LnJlYWRfYnl0ZShwKyspICYgMHhmZikgPDwgaztcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBrICs9IDg7XFxyXFxuICAgICAgICAgICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICBpZiAoKCgofmIpID4+PiAxNikgJiAweGZmZmYpICE9IChiICYgMHhmZmZmKSkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGUgPSBCQURCTE9DS1M7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgei5tc2cgPSBcXFwiaW52YWxpZCBzdG9yZWQgYmxvY2sgbGVuZ3Roc1xcXCI7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgciA9IFpfREFUQV9FUlJPUjtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmJpdGIgPSBiO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuYml0ayA9IGs7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgei5hdmFpbF9pbiA9IG47XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgei50b3RhbF9pbiArPSBwIC0gei5uZXh0X2luX2luZGV4O1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHoubmV4dF9pbl9pbmRleCA9IHA7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC53cml0ZSA9IHE7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoYXQuaW5mbGF0ZV9mbHVzaCh6LCByKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSAoYiAmIDB4ZmZmZik7XFxyXFxuICAgICAgICAgICAgICAgICAgICBiID0gayA9IDA7IC8vIGR1bXAgYml0c1xcclxcbiAgICAgICAgICAgICAgICAgICAgbW9kZSA9IGxlZnQgIT09IDAgPyBTVE9SRUQgOiAobGFzdCAhPT0gMCA/IERSWSA6IFRZUEUpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxyXFxuICAgICAgICAgICAgICAgIGNhc2UgU1RPUkVEOlxcclxcbiAgICAgICAgICAgICAgICAgICAgaWYgKG4gPT09IDApIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmJpdGIgPSBiO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuYml0ayA9IGs7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgei5hdmFpbF9pbiA9IG47XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgei50b3RhbF9pbiArPSBwIC0gei5uZXh0X2luX2luZGV4O1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHoubmV4dF9pbl9pbmRleCA9IHA7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC53cml0ZSA9IHE7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoYXQuaW5mbGF0ZV9mbHVzaCh6LCByKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgIGlmIChtID09PSAwKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHEgPT0gdGhhdC5lbmQgJiYgdGhhdC5yZWFkICE9PSAwKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHEgPSAwO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtID0gLyogKGludCkgKi8ocSA8IHRoYXQucmVhZCA/IHRoYXQucmVhZCAtIHEgLSAxIDogdGhhdC5lbmQgLSBxKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG0gPT09IDApIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC53cml0ZSA9IHE7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgPSB0aGF0LmluZmxhdGVfZmx1c2goeiwgcik7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHEgPSB0aGF0LndyaXRlO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtID0gLyogKGludCkgKi8ocSA8IHRoYXQucmVhZCA/IHRoYXQucmVhZCAtIHEgLSAxIDogdGhhdC5lbmQgLSBxKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHEgPT0gdGhhdC5lbmQgJiYgdGhhdC5yZWFkICE9PSAwKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxID0gMDtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0gPSAvKiAoaW50KSAqLyhxIDwgdGhhdC5yZWFkID8gdGhhdC5yZWFkIC0gcSAtIDEgOiB0aGF0LmVuZCAtIHEpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtID09PSAwKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmJpdGIgPSBiO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5iaXRrID0gaztcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHouYXZhaWxfaW4gPSBuO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgei50b3RhbF9pbiArPSBwIC0gei5uZXh0X2luX2luZGV4O1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgei5uZXh0X2luX2luZGV4ID0gcDtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQud3JpdGUgPSBxO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoYXQuaW5mbGF0ZV9mbHVzaCh6LCByKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgICAgIHIgPSBaX09LO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgdCA9IGxlZnQ7XFxyXFxuICAgICAgICAgICAgICAgICAgICBpZiAodCA+IG4pXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgdCA9IG47XFxyXFxuICAgICAgICAgICAgICAgICAgICBpZiAodCA+IG0pXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgdCA9IG07XFxyXFxuICAgICAgICAgICAgICAgICAgICB0aGF0LndpbmRvdy5zZXQoei5yZWFkX2J1ZihwLCB0KSwgcSk7XFxyXFxuICAgICAgICAgICAgICAgICAgICBwICs9IHQ7XFxyXFxuICAgICAgICAgICAgICAgICAgICBuIC09IHQ7XFxyXFxuICAgICAgICAgICAgICAgICAgICBxICs9IHQ7XFxyXFxuICAgICAgICAgICAgICAgICAgICBtIC09IHQ7XFxyXFxuICAgICAgICAgICAgICAgICAgICBpZiAoKGxlZnQgLT0gdCkgIT09IDApXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxyXFxuICAgICAgICAgICAgICAgICAgICBtb2RlID0gbGFzdCAhPT0gMCA/IERSWSA6IFRZUEU7XFxyXFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcXHJcXG4gICAgICAgICAgICAgICAgY2FzZSBUQUJMRTpcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChrIDwgKDE0KSkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuICE9PSAwKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgPSBaX09LO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuYml0YiA9IGI7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuYml0ayA9IGs7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHouYXZhaWxfaW4gPSBuO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB6LnRvdGFsX2luICs9IHAgLSB6Lm5leHRfaW5faW5kZXg7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHoubmV4dF9pbl9pbmRleCA9IHA7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQud3JpdGUgPSBxO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhhdC5pbmZsYXRlX2ZsdXNoKHosIHIpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBuLS07XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgYiB8PSAoei5yZWFkX2J5dGUocCsrKSAmIDB4ZmYpIDw8IGs7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgayArPSA4O1xcclxcbiAgICAgICAgICAgICAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgdGFibGUgPSB0ID0gKGIgJiAweDNmZmYpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgaWYgKCh0ICYgMHgxZikgPiAyOSB8fCAoKHQgPj4gNSkgJiAweDFmKSA+IDI5KSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZSA9IEJBREJMT0NLUztcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB6Lm1zZyA9IFxcXCJ0b28gbWFueSBsZW5ndGggb3IgZGlzdGFuY2Ugc3ltYm9sc1xcXCI7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgciA9IFpfREFUQV9FUlJPUjtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmJpdGIgPSBiO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuYml0ayA9IGs7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgei5hdmFpbF9pbiA9IG47XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgei50b3RhbF9pbiArPSBwIC0gei5uZXh0X2luX2luZGV4O1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHoubmV4dF9pbl9pbmRleCA9IHA7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC53cml0ZSA9IHE7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoYXQuaW5mbGF0ZV9mbHVzaCh6LCByKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgICAgIHQgPSAyNTggKyAodCAmIDB4MWYpICsgKCh0ID4+IDUpICYgMHgxZik7XFxyXFxuICAgICAgICAgICAgICAgICAgICBpZiAoIWJsZW5zIHx8IGJsZW5zLmxlbmd0aCA8IHQpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBibGVucyA9IFtdOyAvLyBuZXcgQXJyYXkodCk7XFxyXFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0OyBpKyspIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxlbnNbaV0gPSAwO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgIC8vIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGIgPj4+PSAoMTQpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgayAtPSAoMTQpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgLy8gfVxcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSAwO1xcclxcbiAgICAgICAgICAgICAgICAgICAgbW9kZSA9IEJUUkVFO1xcclxcbiAgICAgICAgICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xcclxcbiAgICAgICAgICAgICAgICBjYXNlIEJUUkVFOlxcclxcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGluZGV4IDwgNCArICh0YWJsZSA+Pj4gMTApKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGsgPCAoMykpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG4gIT09IDApIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgPSBaX09LO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5iaXRiID0gYjtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuYml0ayA9IGs7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB6LmF2YWlsX2luID0gbjtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHoudG90YWxfaW4gKz0gcCAtIHoubmV4dF9pbl9pbmRleDtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHoubmV4dF9pbl9pbmRleCA9IHA7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LndyaXRlID0gcTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGF0LmluZmxhdGVfZmx1c2goeiwgcik7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbi0tO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiIHw9ICh6LnJlYWRfYnl0ZShwKyspICYgMHhmZikgPDwgaztcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgayArPSA4O1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBibGVuc1tib3JkZXJbaW5kZXgrK11dID0gYiAmIDc7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8ge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGIgPj4+PSAoMyk7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgayAtPSAoMyk7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gfVxcclxcbiAgICAgICAgICAgICAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGluZGV4IDwgMTkpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBibGVuc1tib3JkZXJbaW5kZXgrK11dID0gMDtcXHJcXG4gICAgICAgICAgICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgIGJiWzBdID0gNztcXHJcXG4gICAgICAgICAgICAgICAgICAgIHQgPSBpbmZ0cmVlLmluZmxhdGVfdHJlZXNfYml0cyhibGVucywgYmIsIHRiLCBodWZ0cywgeik7XFxyXFxuICAgICAgICAgICAgICAgICAgICBpZiAodCAhPSBaX09LKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgciA9IHQ7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHIgPT0gWl9EQVRBX0VSUk9SKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsZW5zID0gbnVsbDtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZSA9IEJBREJMT0NLUztcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5iaXRiID0gYjtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmJpdGsgPSBrO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHouYXZhaWxfaW4gPSBuO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHoudG90YWxfaW4gKz0gcCAtIHoubmV4dF9pbl9pbmRleDtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB6Lm5leHRfaW5faW5kZXggPSBwO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQud3JpdGUgPSBxO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGF0LmluZmxhdGVfZmx1c2goeiwgcik7XFxyXFxuICAgICAgICAgICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IDA7XFxyXFxuICAgICAgICAgICAgICAgICAgICBtb2RlID0gRFRSRUU7XFxyXFxuICAgICAgICAgICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXFxyXFxuICAgICAgICAgICAgICAgIGNhc2UgRFRSRUU6XFxyXFxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHQgPSB0YWJsZTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gMjU4ICsgKHQgJiAweDFmKSArICgodCA+PiA1KSAmIDB4MWYpKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaiwgYztcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB0ID0gYmJbMF07XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGsgPCAodCkpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG4gIT09IDApIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgPSBaX09LO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5iaXRiID0gYjtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuYml0ayA9IGs7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB6LmF2YWlsX2luID0gbjtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHoudG90YWxfaW4gKz0gcCAtIHoubmV4dF9pbl9pbmRleDtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHoubmV4dF9pbl9pbmRleCA9IHA7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LndyaXRlID0gcTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGF0LmluZmxhdGVfZmx1c2goeiwgcik7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbi0tO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiIHw9ICh6LnJlYWRfYnl0ZShwKyspICYgMHhmZikgPDwgaztcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgayArPSA4O1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiAodGJbMF0gPT0gLTEpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTeXN0ZW0uZXJyLnByaW50bG4oXFxcIm51bGwuLi5cXFwiKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgdCA9IGh1ZnRzWyh0YlswXSArIChiICYgaW5mbGF0ZV9tYXNrW3RdKSkgKiAzICsgMV07XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgYyA9IGh1ZnRzWyh0YlswXSArIChiICYgaW5mbGF0ZV9tYXNrW3RdKSkgKiAzICsgMl07XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGMgPCAxNikge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiID4+Pj0gKHQpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrIC09ICh0KTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxlbnNbaW5kZXgrK10gPSBjO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8vIGMgPT0gMTYuLjE4XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBjID09IDE4ID8gNyA6IGMgLSAxNDtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaiA9IGMgPT0gMTggPyAxMSA6IDM7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChrIDwgKHQgKyBpKSkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG4gIT09IDApIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByID0gWl9PSztcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5iaXRiID0gYjtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmJpdGsgPSBrO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHouYXZhaWxfaW4gPSBuO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHoudG90YWxfaW4gKz0gcCAtIHoubmV4dF9pbl9pbmRleDtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB6Lm5leHRfaW5faW5kZXggPSBwO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQud3JpdGUgPSBxO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGF0LmluZmxhdGVfZmx1c2goeiwgcik7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuLS07XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiIHw9ICh6LnJlYWRfYnl0ZShwKyspICYgMHhmZikgPDwgaztcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGsgKz0gODtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiID4+Pj0gKHQpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrIC09ICh0KTtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaiArPSAoYiAmIGluZmxhdGVfbWFza1tpXSk7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIgPj4+PSAoaSk7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGsgLT0gKGkpO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gaW5kZXg7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQgPSB0YWJsZTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgKyBqID4gMjU4ICsgKHQgJiAweDFmKSArICgodCA+PiA1KSAmIDB4MWYpIHx8IChjID09IDE2ICYmIGkgPCAxKSkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxlbnMgPSBudWxsO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZSA9IEJBREJMT0NLUztcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHoubXNnID0gXFxcImludmFsaWQgYml0IGxlbmd0aCByZXBlYXRcXFwiO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgciA9IFpfREFUQV9FUlJPUjtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuYml0YiA9IGI7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmJpdGsgPSBrO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgei5hdmFpbF9pbiA9IG47XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB6LnRvdGFsX2luICs9IHAgLSB6Lm5leHRfaW5faW5kZXg7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB6Lm5leHRfaW5faW5kZXggPSBwO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC53cml0ZSA9IHE7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhhdC5pbmZsYXRlX2ZsdXNoKHosIHIpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSBjID09IDE2ID8gYmxlbnNbaSAtIDFdIDogMDtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG8ge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxlbnNbaSsrXSA9IGM7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0taiAhPT0gMCk7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICB0YlswXSA9IC0xO1xcclxcbiAgICAgICAgICAgICAgICAgICAgLy8ge1xcclxcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJsXyA9IFtdOyAvLyBuZXcgQXJyYXkoMSk7XFxyXFxuICAgICAgICAgICAgICAgICAgICB2YXIgYmRfID0gW107IC8vIG5ldyBBcnJheSgxKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHZhciB0bF8gPSBbXTsgLy8gbmV3IEFycmF5KDEpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRkXyA9IFtdOyAvLyBuZXcgQXJyYXkoMSk7XFxyXFxuICAgICAgICAgICAgICAgICAgICBibF9bMF0gPSA5OyAvLyBtdXN0IGJlIDw9IDkgZm9yIGxvb2thaGVhZCBhc3N1bXB0aW9uc1xcclxcbiAgICAgICAgICAgICAgICAgICAgYmRfWzBdID0gNjsgLy8gbXVzdCBiZSA8PSA5IGZvciBsb29rYWhlYWQgYXNzdW1wdGlvbnNcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgIHQgPSB0YWJsZTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHQgPSBpbmZ0cmVlLmluZmxhdGVfdHJlZXNfZHluYW1pYygyNTcgKyAodCAmIDB4MWYpLCAxICsgKCh0ID4+IDUpICYgMHgxZiksIGJsZW5zLCBibF8sIGJkXywgdGxfLCB0ZF8sIGh1ZnRzLCB6KTtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICE9IFpfT0spIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodCA9PSBaX0RBVEFfRVJST1IpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxlbnMgPSBudWxsO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlID0gQkFEQkxPQ0tTO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICByID0gdDtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmJpdGIgPSBiO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuYml0ayA9IGs7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgei5hdmFpbF9pbiA9IG47XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgei50b3RhbF9pbiArPSBwIC0gei5uZXh0X2luX2luZGV4O1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHoubmV4dF9pbl9pbmRleCA9IHA7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC53cml0ZSA9IHE7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoYXQuaW5mbGF0ZV9mbHVzaCh6LCByKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgICAgIGNvZGVzLmluaXQoYmxfWzBdLCBiZF9bMF0sIGh1ZnRzLCB0bF9bMF0sIGh1ZnRzLCB0ZF9bMF0pO1xcclxcbiAgICAgICAgICAgICAgICAgICAgLy8gfVxcclxcbiAgICAgICAgICAgICAgICAgICAgbW9kZSA9IENPREVTO1xcclxcbiAgICAgICAgICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xcclxcbiAgICAgICAgICAgICAgICBjYXNlIENPREVTOlxcclxcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5iaXRiID0gYjtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuYml0ayA9IGs7XFxyXFxuICAgICAgICAgICAgICAgICAgICB6LmF2YWlsX2luID0gbjtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHoudG90YWxfaW4gKz0gcCAtIHoubmV4dF9pbl9pbmRleDtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHoubmV4dF9pbl9pbmRleCA9IHA7XFxyXFxuICAgICAgICAgICAgICAgICAgICB0aGF0LndyaXRlID0gcTtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgIGlmICgociA9IGNvZGVzLnByb2ModGhhdCwgeiwgcikpICE9IFpfU1RSRUFNX0VORCkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGF0LmluZmxhdGVfZmx1c2goeiwgcik7XFxyXFxuICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgICAgICByID0gWl9PSztcXHJcXG4gICAgICAgICAgICAgICAgICAgIGNvZGVzLmZyZWUoeik7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICBwID0gei5uZXh0X2luX2luZGV4O1xcclxcbiAgICAgICAgICAgICAgICAgICAgbiA9IHouYXZhaWxfaW47XFxyXFxuICAgICAgICAgICAgICAgICAgICBiID0gdGhhdC5iaXRiO1xcclxcbiAgICAgICAgICAgICAgICAgICAgayA9IHRoYXQuYml0aztcXHJcXG4gICAgICAgICAgICAgICAgICAgIHEgPSB0aGF0LndyaXRlO1xcclxcbiAgICAgICAgICAgICAgICAgICAgbSA9IC8qIChpbnQpICovKHEgPCB0aGF0LnJlYWQgPyB0aGF0LnJlYWQgLSBxIC0gMSA6IHRoYXQuZW5kIC0gcSk7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICBpZiAobGFzdCA9PT0gMCkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGUgPSBUWVBFO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcclxcbiAgICAgICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICAgICAgbW9kZSA9IERSWTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cXHJcXG4gICAgICAgICAgICAgICAgY2FzZSBEUlk6XFxyXFxuICAgICAgICAgICAgICAgICAgICB0aGF0LndyaXRlID0gcTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHIgPSB0aGF0LmluZmxhdGVfZmx1c2goeiwgcik7XFxyXFxuICAgICAgICAgICAgICAgICAgICBxID0gdGhhdC53cml0ZTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIG0gPSAvKiAoaW50KSAqLyhxIDwgdGhhdC5yZWFkID8gdGhhdC5yZWFkIC0gcSAtIDEgOiB0aGF0LmVuZCAtIHEpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoYXQucmVhZCAhPSB0aGF0LndyaXRlKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5iaXRiID0gYjtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmJpdGsgPSBrO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHouYXZhaWxfaW4gPSBuO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHoudG90YWxfaW4gKz0gcCAtIHoubmV4dF9pbl9pbmRleDtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB6Lm5leHRfaW5faW5kZXggPSBwO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQud3JpdGUgPSBxO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGF0LmluZmxhdGVfZmx1c2goeiwgcik7XFxyXFxuICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgICAgICBtb2RlID0gRE9ORUxPQ0tTO1xcclxcbiAgICAgICAgICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xcclxcbiAgICAgICAgICAgICAgICBjYXNlIERPTkVMT0NLUzpcXHJcXG4gICAgICAgICAgICAgICAgICAgIHIgPSBaX1NUUkVBTV9FTkQ7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICB0aGF0LmJpdGIgPSBiO1xcclxcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5iaXRrID0gaztcXHJcXG4gICAgICAgICAgICAgICAgICAgIHouYXZhaWxfaW4gPSBuO1xcclxcbiAgICAgICAgICAgICAgICAgICAgei50b3RhbF9pbiArPSBwIC0gei5uZXh0X2luX2luZGV4O1xcclxcbiAgICAgICAgICAgICAgICAgICAgei5uZXh0X2luX2luZGV4ID0gcDtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHRoYXQud3JpdGUgPSBxO1xcclxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoYXQuaW5mbGF0ZV9mbHVzaCh6LCByKTtcXHJcXG4gICAgICAgICAgICAgICAgY2FzZSBCQURCTE9DS1M6XFxyXFxuICAgICAgICAgICAgICAgICAgICByID0gWl9EQVRBX0VSUk9SO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5iaXRiID0gYjtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuYml0ayA9IGs7XFxyXFxuICAgICAgICAgICAgICAgICAgICB6LmF2YWlsX2luID0gbjtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHoudG90YWxfaW4gKz0gcCAtIHoubmV4dF9pbl9pbmRleDtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHoubmV4dF9pbl9pbmRleCA9IHA7XFxyXFxuICAgICAgICAgICAgICAgICAgICB0aGF0LndyaXRlID0gcTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGF0LmluZmxhdGVfZmx1c2goeiwgcik7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XFxyXFxuICAgICAgICAgICAgICAgICAgICByID0gWl9TVFJFQU1fRVJST1I7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICB0aGF0LmJpdGIgPSBiO1xcclxcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5iaXRrID0gaztcXHJcXG4gICAgICAgICAgICAgICAgICAgIHouYXZhaWxfaW4gPSBuO1xcclxcbiAgICAgICAgICAgICAgICAgICAgei50b3RhbF9pbiArPSBwIC0gei5uZXh0X2luX2luZGV4O1xcclxcbiAgICAgICAgICAgICAgICAgICAgei5uZXh0X2luX2luZGV4ID0gcDtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHRoYXQud3JpdGUgPSBxO1xcclxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoYXQuaW5mbGF0ZV9mbHVzaCh6LCByKTtcXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH07XFxyXFxuXFxyXFxuICAgICAgICB0aGF0LmZyZWUgPSBmdW5jdGlvbih6KSB7XFxyXFxuICAgICAgICAgICAgdGhhdC5yZXNldCh6LCBudWxsKTtcXHJcXG4gICAgICAgICAgICB0aGF0LndpbmRvdyA9IG51bGw7XFxyXFxuICAgICAgICAgICAgaHVmdHMgPSBudWxsO1xcclxcbiAgICAgICAgICAgIC8vIFpGUkVFKHosIHMpO1xcclxcbiAgICAgICAgfTtcXHJcXG5cXHJcXG4gICAgICAgIHRoYXQuc2V0X2RpY3Rpb25hcnkgPSBmdW5jdGlvbihkLCBzdGFydCwgbikge1xcclxcbiAgICAgICAgICAgIHRoYXQud2luZG93LnNldChkLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIG4pLCAwKTtcXHJcXG4gICAgICAgICAgICB0aGF0LnJlYWQgPSB0aGF0LndyaXRlID0gbjtcXHJcXG4gICAgICAgIH07XFxyXFxuXFxyXFxuICAgICAgICAvLyBSZXR1cm5zIHRydWUgaWYgaW5mbGF0ZSBpcyBjdXJyZW50bHkgYXQgdGhlIGVuZCBvZiBhIGJsb2NrIGdlbmVyYXRlZFxcclxcbiAgICAgICAgLy8gYnkgWl9TWU5DX0ZMVVNIIG9yIFpfRlVMTF9GTFVTSC5cXHJcXG4gICAgICAgIHRoYXQuc3luY19wb2ludCA9IGZ1bmN0aW9uKCkge1xcclxcbiAgICAgICAgICAgIHJldHVybiBtb2RlID09IExFTlMgPyAxIDogMDtcXHJcXG4gICAgICAgIH07XFxyXFxuXFxyXFxuICAgIH1cXHJcXG5cXHJcXG4gICAgLy8gSW5mbGF0ZVxcclxcblxcclxcbiAgICAvLyBwcmVzZXQgZGljdGlvbmFyeSBmbGFnIGluIHpsaWIgaGVhZGVyXFxyXFxuICAgIHZhciBQUkVTRVRfRElDVCA9IDB4MjA7XFxyXFxuXFxyXFxuICAgIHZhciBaX0RFRkxBVEVEID0gODtcXHJcXG5cXHJcXG4gICAgdmFyIE1FVEhPRCA9IDA7IC8vIHdhaXRpbmcgZm9yIG1ldGhvZCBieXRlXFxyXFxuICAgIHZhciBGTEFHID0gMTsgLy8gd2FpdGluZyBmb3IgZmxhZyBieXRlXFxyXFxuICAgIHZhciBESUNUNCA9IDI7IC8vIGZvdXIgZGljdGlvbmFyeSBjaGVjayBieXRlcyB0byBnb1xcclxcbiAgICB2YXIgRElDVDMgPSAzOyAvLyB0aHJlZSBkaWN0aW9uYXJ5IGNoZWNrIGJ5dGVzIHRvIGdvXFxyXFxuICAgIHZhciBESUNUMiA9IDQ7IC8vIHR3byBkaWN0aW9uYXJ5IGNoZWNrIGJ5dGVzIHRvIGdvXFxyXFxuICAgIHZhciBESUNUMSA9IDU7IC8vIG9uZSBkaWN0aW9uYXJ5IGNoZWNrIGJ5dGUgdG8gZ29cXHJcXG4gICAgdmFyIERJQ1QwID0gNjsgLy8gd2FpdGluZyBmb3IgaW5mbGF0ZVNldERpY3Rpb25hcnlcXHJcXG4gICAgdmFyIEJMT0NLUyA9IDc7IC8vIGRlY29tcHJlc3NpbmcgYmxvY2tzXFxyXFxuICAgIHZhciBET05FID0gMTI7IC8vIGZpbmlzaGVkIGNoZWNrLCBkb25lXFxyXFxuICAgIHZhciBCQUQgPSAxMzsgLy8gZ290IGFuIGVycm9yLS1zdGF5IGhlcmVcXHJcXG5cXHJcXG4gICAgdmFyIG1hcmsgPSBbIDAsIDAsIDB4ZmYsIDB4ZmYgXTtcXHJcXG5cXHJcXG4gICAgZnVuY3Rpb24gSW5mbGF0ZSgpIHtcXHJcXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcXHJcXG5cXHJcXG4gICAgICAgIHRoYXQubW9kZSA9IDA7IC8vIGN1cnJlbnQgaW5mbGF0ZSBtb2RlXFxyXFxuXFxyXFxuICAgICAgICAvLyBtb2RlIGRlcGVuZGVudCBpbmZvcm1hdGlvblxcclxcbiAgICAgICAgdGhhdC5tZXRob2QgPSAwOyAvLyBpZiBGTEFHUywgbWV0aG9kIGJ5dGVcXHJcXG5cXHJcXG4gICAgICAgIC8vIGlmIENIRUNLLCBjaGVjayB2YWx1ZXMgdG8gY29tcGFyZVxcclxcbiAgICAgICAgdGhhdC53YXMgPSBbIDAgXTsgLy8gbmV3IEFycmF5KDEpOyAvLyBjb21wdXRlZCBjaGVjayB2YWx1ZVxcclxcbiAgICAgICAgdGhhdC5uZWVkID0gMDsgLy8gc3RyZWFtIGNoZWNrIHZhbHVlXFxyXFxuXFxyXFxuICAgICAgICAvLyBpZiBCQUQsIGluZmxhdGVTeW5jJ3MgbWFya2VyIGJ5dGVzIGNvdW50XFxyXFxuICAgICAgICB0aGF0Lm1hcmtlciA9IDA7XFxyXFxuXFxyXFxuICAgICAgICAvLyBtb2RlIGluZGVwZW5kZW50IGluZm9ybWF0aW9uXFxyXFxuICAgICAgICB0aGF0LndiaXRzID0gMDsgLy8gbG9nMih3aW5kb3cgc2l6ZSkgKDguLjE1LCBkZWZhdWx0cyB0byAxNSlcXHJcXG5cXHJcXG4gICAgICAgIC8vIHRoaXMuYmxvY2tzOyAvLyBjdXJyZW50IGluZmxhdGVfYmxvY2tzIHN0YXRlXFxyXFxuXFxyXFxuICAgICAgICBmdW5jdGlvbiBpbmZsYXRlUmVzZXQoeikge1xcclxcbiAgICAgICAgICAgIGlmICgheiB8fCAhei5pc3RhdGUpXFxyXFxuICAgICAgICAgICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcXHJcXG5cXHJcXG4gICAgICAgICAgICB6LnRvdGFsX2luID0gei50b3RhbF9vdXQgPSAwO1xcclxcbiAgICAgICAgICAgIHoubXNnID0gbnVsbDtcXHJcXG4gICAgICAgICAgICB6LmlzdGF0ZS5tb2RlID0gQkxPQ0tTO1xcclxcbiAgICAgICAgICAgIHouaXN0YXRlLmJsb2Nrcy5yZXNldCh6LCBudWxsKTtcXHJcXG4gICAgICAgICAgICByZXR1cm4gWl9PSztcXHJcXG4gICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgIHRoYXQuaW5mbGF0ZUVuZCA9IGZ1bmN0aW9uKHopIHtcXHJcXG4gICAgICAgICAgICBpZiAodGhhdC5ibG9ja3MpXFxyXFxuICAgICAgICAgICAgICAgIHRoYXQuYmxvY2tzLmZyZWUoeik7XFxyXFxuICAgICAgICAgICAgdGhhdC5ibG9ja3MgPSBudWxsO1xcclxcbiAgICAgICAgICAgIC8vIFpGUkVFKHosIHotPnN0YXRlKTtcXHJcXG4gICAgICAgICAgICByZXR1cm4gWl9PSztcXHJcXG4gICAgICAgIH07XFxyXFxuXFxyXFxuICAgICAgICB0aGF0LmluZmxhdGVJbml0ID0gZnVuY3Rpb24oeiwgdykge1xcclxcbiAgICAgICAgICAgIHoubXNnID0gbnVsbDtcXHJcXG4gICAgICAgICAgICB0aGF0LmJsb2NrcyA9IG51bGw7XFxyXFxuXFxyXFxuICAgICAgICAgICAgLy8gc2V0IHdpbmRvdyBzaXplXFxyXFxuICAgICAgICAgICAgaWYgKHcgPCA4IHx8IHcgPiAxNSkge1xcclxcbiAgICAgICAgICAgICAgICB0aGF0LmluZmxhdGVFbmQoeik7XFxyXFxuICAgICAgICAgICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgdGhhdC53Yml0cyA9IHc7XFxyXFxuXFxyXFxuICAgICAgICAgICAgei5pc3RhdGUuYmxvY2tzID0gbmV3IEluZkJsb2Nrcyh6LCAxIDw8IHcpO1xcclxcblxcclxcbiAgICAgICAgICAgIC8vIHJlc2V0IHN0YXRlXFxyXFxuICAgICAgICAgICAgaW5mbGF0ZVJlc2V0KHopO1xcclxcbiAgICAgICAgICAgIHJldHVybiBaX09LO1xcclxcbiAgICAgICAgfTtcXHJcXG5cXHJcXG4gICAgICAgIHRoYXQuaW5mbGF0ZSA9IGZ1bmN0aW9uKHosIGYpIHtcXHJcXG4gICAgICAgICAgICB2YXIgcjtcXHJcXG4gICAgICAgICAgICB2YXIgYjtcXHJcXG5cXHJcXG4gICAgICAgICAgICBpZiAoIXogfHwgIXouaXN0YXRlIHx8ICF6Lm5leHRfaW4pXFxyXFxuICAgICAgICAgICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcXHJcXG4gICAgICAgICAgICBmID0gZiA9PSBaX0ZJTklTSCA/IFpfQlVGX0VSUk9SIDogWl9PSztcXHJcXG4gICAgICAgICAgICByID0gWl9CVUZfRVJST1I7XFxyXFxuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcXHJcXG4gICAgICAgICAgICAgICAgLy8gU3lzdGVtLm91dC5wcmludGxuKFxcXCJtb2RlOiBcXFwiK3ouaXN0YXRlLm1vZGUpO1xcclxcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHouaXN0YXRlLm1vZGUpIHtcXHJcXG4gICAgICAgICAgICAgICAgY2FzZSBNRVRIT0Q6XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICBpZiAoei5hdmFpbF9pbiA9PT0gMClcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcjtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHIgPSBmO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgei5hdmFpbF9pbi0tO1xcclxcbiAgICAgICAgICAgICAgICAgICAgei50b3RhbF9pbisrO1xcclxcbiAgICAgICAgICAgICAgICAgICAgaWYgKCgoei5pc3RhdGUubWV0aG9kID0gei5yZWFkX2J5dGUoei5uZXh0X2luX2luZGV4KyspKSAmIDB4ZikgIT0gWl9ERUZMQVRFRCkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHouaXN0YXRlLm1vZGUgPSBCQUQ7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgei5tc2cgPSBcXFwidW5rbm93biBjb21wcmVzc2lvbiBtZXRob2RcXFwiO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHouaXN0YXRlLm1hcmtlciA9IDU7IC8vIGNhbid0IHRyeSBpbmZsYXRlU3luY1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcclxcbiAgICAgICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICAgICAgaWYgKCh6LmlzdGF0ZS5tZXRob2QgPj4gNCkgKyA4ID4gei5pc3RhdGUud2JpdHMpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB6LmlzdGF0ZS5tb2RlID0gQkFEO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHoubXNnID0gXFxcImludmFsaWQgd2luZG93IHNpemVcXFwiO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHouaXN0YXRlLm1hcmtlciA9IDU7IC8vIGNhbid0IHRyeSBpbmZsYXRlU3luY1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcclxcbiAgICAgICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICAgICAgei5pc3RhdGUubW9kZSA9IEZMQUc7XFxyXFxuICAgICAgICAgICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXFxyXFxuICAgICAgICAgICAgICAgIGNhc2UgRkxBRzpcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgIGlmICh6LmF2YWlsX2luID09PSAwKVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByO1xcclxcbiAgICAgICAgICAgICAgICAgICAgciA9IGY7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICB6LmF2YWlsX2luLS07XFxyXFxuICAgICAgICAgICAgICAgICAgICB6LnRvdGFsX2luKys7XFxyXFxuICAgICAgICAgICAgICAgICAgICBiID0gKHoucmVhZF9ieXRlKHoubmV4dF9pbl9pbmRleCsrKSkgJiAweGZmO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgaWYgKCgoKHouaXN0YXRlLm1ldGhvZCA8PCA4KSArIGIpICUgMzEpICE9PSAwKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgei5pc3RhdGUubW9kZSA9IEJBRDtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB6Lm1zZyA9IFxcXCJpbmNvcnJlY3QgaGVhZGVyIGNoZWNrXFxcIjtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB6LmlzdGF0ZS5tYXJrZXIgPSA1OyAvLyBjYW4ndCB0cnkgaW5mbGF0ZVN5bmNcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcXHJcXG4gICAgICAgICAgICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgIGlmICgoYiAmIFBSRVNFVF9ESUNUKSA9PT0gMCkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHouaXN0YXRlLm1vZGUgPSBCTE9DS1M7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxyXFxuICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgICAgICB6LmlzdGF0ZS5tb2RlID0gRElDVDQ7XFxyXFxuICAgICAgICAgICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXFxyXFxuICAgICAgICAgICAgICAgIGNhc2UgRElDVDQ6XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICBpZiAoei5hdmFpbF9pbiA9PT0gMClcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcjtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHIgPSBmO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgei5hdmFpbF9pbi0tO1xcclxcbiAgICAgICAgICAgICAgICAgICAgei50b3RhbF9pbisrO1xcclxcbiAgICAgICAgICAgICAgICAgICAgei5pc3RhdGUubmVlZCA9ICgoei5yZWFkX2J5dGUoei5uZXh0X2luX2luZGV4KyspICYgMHhmZikgPDwgMjQpICYgMHhmZjAwMDAwMDtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHouaXN0YXRlLm1vZGUgPSBESUNUMztcXHJcXG4gICAgICAgICAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cXHJcXG4gICAgICAgICAgICAgICAgY2FzZSBESUNUMzpcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgIGlmICh6LmF2YWlsX2luID09PSAwKVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByO1xcclxcbiAgICAgICAgICAgICAgICAgICAgciA9IGY7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICB6LmF2YWlsX2luLS07XFxyXFxuICAgICAgICAgICAgICAgICAgICB6LnRvdGFsX2luKys7XFxyXFxuICAgICAgICAgICAgICAgICAgICB6LmlzdGF0ZS5uZWVkICs9ICgoei5yZWFkX2J5dGUoei5uZXh0X2luX2luZGV4KyspICYgMHhmZikgPDwgMTYpICYgMHhmZjAwMDA7XFxyXFxuICAgICAgICAgICAgICAgICAgICB6LmlzdGF0ZS5tb2RlID0gRElDVDI7XFxyXFxuICAgICAgICAgICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXFxyXFxuICAgICAgICAgICAgICAgIGNhc2UgRElDVDI6XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgICBpZiAoei5hdmFpbF9pbiA9PT0gMClcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcjtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHIgPSBmO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgei5hdmFpbF9pbi0tO1xcclxcbiAgICAgICAgICAgICAgICAgICAgei50b3RhbF9pbisrO1xcclxcbiAgICAgICAgICAgICAgICAgICAgei5pc3RhdGUubmVlZCArPSAoKHoucmVhZF9ieXRlKHoubmV4dF9pbl9pbmRleCsrKSAmIDB4ZmYpIDw8IDgpICYgMHhmZjAwO1xcclxcbiAgICAgICAgICAgICAgICAgICAgei5pc3RhdGUubW9kZSA9IERJQ1QxO1xcclxcbiAgICAgICAgICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xcclxcbiAgICAgICAgICAgICAgICBjYXNlIERJQ1QxOlxcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgaWYgKHouYXZhaWxfaW4gPT09IDApXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHI7XFxyXFxuICAgICAgICAgICAgICAgICAgICByID0gZjtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgIHouYXZhaWxfaW4tLTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHoudG90YWxfaW4rKztcXHJcXG4gICAgICAgICAgICAgICAgICAgIHouaXN0YXRlLm5lZWQgKz0gKHoucmVhZF9ieXRlKHoubmV4dF9pbl9pbmRleCsrKSAmIDB4ZmYpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgei5pc3RhdGUubW9kZSA9IERJQ1QwO1xcclxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFpfTkVFRF9ESUNUO1xcclxcbiAgICAgICAgICAgICAgICBjYXNlIERJQ1QwOlxcclxcbiAgICAgICAgICAgICAgICAgICAgei5pc3RhdGUubW9kZSA9IEJBRDtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHoubXNnID0gXFxcIm5lZWQgZGljdGlvbmFyeVxcXCI7XFxyXFxuICAgICAgICAgICAgICAgICAgICB6LmlzdGF0ZS5tYXJrZXIgPSAwOyAvLyBjYW4gdHJ5IGluZmxhdGVTeW5jXFxyXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XFxyXFxuICAgICAgICAgICAgICAgIGNhc2UgQkxPQ0tTOlxcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICAgciA9IHouaXN0YXRlLmJsb2Nrcy5wcm9jKHosIHIpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgaWYgKHIgPT0gWl9EQVRBX0VSUk9SKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgei5pc3RhdGUubW9kZSA9IEJBRDtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB6LmlzdGF0ZS5tYXJrZXIgPSAwOyAvLyBjYW4gdHJ5IGluZmxhdGVTeW5jXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxyXFxuICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgICAgICBpZiAociA9PSBaX09LKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgciA9IGY7XFxyXFxuICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgICAgICBpZiAociAhPSBaX1NUUkVBTV9FTkQpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcjtcXHJcXG4gICAgICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgICAgIHIgPSBmO1xcclxcbiAgICAgICAgICAgICAgICAgICAgei5pc3RhdGUuYmxvY2tzLnJlc2V0KHosIHouaXN0YXRlLndhcyk7XFxyXFxuICAgICAgICAgICAgICAgICAgICB6LmlzdGF0ZS5tb2RlID0gRE9ORTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cXHJcXG4gICAgICAgICAgICAgICAgY2FzZSBET05FOlxcclxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VORDtcXHJcXG4gICAgICAgICAgICAgICAgY2FzZSBCQUQ6XFxyXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWl9EQVRBX0VSUk9SO1xcclxcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxcclxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgfTtcXHJcXG5cXHJcXG4gICAgICAgIHRoYXQuaW5mbGF0ZVNldERpY3Rpb25hcnkgPSBmdW5jdGlvbih6LCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoKSB7XFxyXFxuICAgICAgICAgICAgdmFyIGluZGV4ID0gMDtcXHJcXG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gZGljdExlbmd0aDtcXHJcXG4gICAgICAgICAgICBpZiAoIXogfHwgIXouaXN0YXRlIHx8IHouaXN0YXRlLm1vZGUgIT0gRElDVDApXFxyXFxuICAgICAgICAgICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcXHJcXG5cXHJcXG4gICAgICAgICAgICBpZiAobGVuZ3RoID49ICgxIDw8IHouaXN0YXRlLndiaXRzKSkge1xcclxcbiAgICAgICAgICAgICAgICBsZW5ndGggPSAoMSA8PCB6LmlzdGF0ZS53Yml0cykgLSAxO1xcclxcbiAgICAgICAgICAgICAgICBpbmRleCA9IGRpY3RMZW5ndGggLSBsZW5ndGg7XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIHouaXN0YXRlLmJsb2Nrcy5zZXRfZGljdGlvbmFyeShkaWN0aW9uYXJ5LCBpbmRleCwgbGVuZ3RoKTtcXHJcXG4gICAgICAgICAgICB6LmlzdGF0ZS5tb2RlID0gQkxPQ0tTO1xcclxcbiAgICAgICAgICAgIHJldHVybiBaX09LO1xcclxcbiAgICAgICAgfTtcXHJcXG5cXHJcXG4gICAgICAgIHRoYXQuaW5mbGF0ZVN5bmMgPSBmdW5jdGlvbih6KSB7XFxyXFxuICAgICAgICAgICAgdmFyIG47IC8vIG51bWJlciBvZiBieXRlcyB0byBsb29rIGF0XFxyXFxuICAgICAgICAgICAgdmFyIHA7IC8vIHBvaW50ZXIgdG8gYnl0ZXNcXHJcXG4gICAgICAgICAgICB2YXIgbTsgLy8gbnVtYmVyIG9mIG1hcmtlciBieXRlcyBmb3VuZCBpbiBhIHJvd1xcclxcbiAgICAgICAgICAgIHZhciByLCB3OyAvLyB0ZW1wb3JhcmllcyB0byBzYXZlIHRvdGFsX2luIGFuZCB0b3RhbF9vdXRcXHJcXG5cXHJcXG4gICAgICAgICAgICAvLyBzZXQgdXBcXHJcXG4gICAgICAgICAgICBpZiAoIXogfHwgIXouaXN0YXRlKVxcclxcbiAgICAgICAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XFxyXFxuICAgICAgICAgICAgaWYgKHouaXN0YXRlLm1vZGUgIT0gQkFEKSB7XFxyXFxuICAgICAgICAgICAgICAgIHouaXN0YXRlLm1vZGUgPSBCQUQ7XFxyXFxuICAgICAgICAgICAgICAgIHouaXN0YXRlLm1hcmtlciA9IDA7XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIGlmICgobiA9IHouYXZhaWxfaW4pID09PSAwKVxcclxcbiAgICAgICAgICAgICAgICByZXR1cm4gWl9CVUZfRVJST1I7XFxyXFxuICAgICAgICAgICAgcCA9IHoubmV4dF9pbl9pbmRleDtcXHJcXG4gICAgICAgICAgICBtID0gei5pc3RhdGUubWFya2VyO1xcclxcblxcclxcbiAgICAgICAgICAgIC8vIHNlYXJjaFxcclxcbiAgICAgICAgICAgIHdoaWxlIChuICE9PSAwICYmIG0gPCA0KSB7XFxyXFxuICAgICAgICAgICAgICAgIGlmICh6LnJlYWRfYnl0ZShwKSA9PSBtYXJrW21dKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICBtKys7XFxyXFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoei5yZWFkX2J5dGUocCkgIT09IDApIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIG0gPSAwO1xcclxcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgICAgICAgICAgICAgbSA9IDQgLSBtO1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgIHArKztcXHJcXG4gICAgICAgICAgICAgICAgbi0tO1xcclxcbiAgICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICAvLyByZXN0b3JlXFxyXFxuICAgICAgICAgICAgei50b3RhbF9pbiArPSBwIC0gei5uZXh0X2luX2luZGV4O1xcclxcbiAgICAgICAgICAgIHoubmV4dF9pbl9pbmRleCA9IHA7XFxyXFxuICAgICAgICAgICAgei5hdmFpbF9pbiA9IG47XFxyXFxuICAgICAgICAgICAgei5pc3RhdGUubWFya2VyID0gbTtcXHJcXG5cXHJcXG4gICAgICAgICAgICAvLyByZXR1cm4gbm8gam95IG9yIHNldCB1cCB0byByZXN0YXJ0IG9uIGEgbmV3IGJsb2NrXFxyXFxuICAgICAgICAgICAgaWYgKG0gIT0gNCkge1xcclxcbiAgICAgICAgICAgICAgICByZXR1cm4gWl9EQVRBX0VSUk9SO1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICByID0gei50b3RhbF9pbjtcXHJcXG4gICAgICAgICAgICB3ID0gei50b3RhbF9vdXQ7XFxyXFxuICAgICAgICAgICAgaW5mbGF0ZVJlc2V0KHopO1xcclxcbiAgICAgICAgICAgIHoudG90YWxfaW4gPSByO1xcclxcbiAgICAgICAgICAgIHoudG90YWxfb3V0ID0gdztcXHJcXG4gICAgICAgICAgICB6LmlzdGF0ZS5tb2RlID0gQkxPQ0tTO1xcclxcbiAgICAgICAgICAgIHJldHVybiBaX09LO1xcclxcbiAgICAgICAgfTtcXHJcXG5cXHJcXG4gICAgICAgIC8vIFJldHVybnMgdHJ1ZSBpZiBpbmZsYXRlIGlzIGN1cnJlbnRseSBhdCB0aGUgZW5kIG9mIGEgYmxvY2sgZ2VuZXJhdGVkXFxyXFxuICAgICAgICAvLyBieSBaX1NZTkNfRkxVU0ggb3IgWl9GVUxMX0ZMVVNILiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgYnkgb25lIFBQUFxcclxcbiAgICAgICAgLy8gaW1wbGVtZW50YXRpb24gdG8gcHJvdmlkZSBhbiBhZGRpdGlvbmFsIHNhZmV0eSBjaGVjay4gUFBQIHVzZXNcXHJcXG4gICAgICAgIC8vIFpfU1lOQ19GTFVTSFxcclxcbiAgICAgICAgLy8gYnV0IHJlbW92ZXMgdGhlIGxlbmd0aCBieXRlcyBvZiB0aGUgcmVzdWx0aW5nIGVtcHR5IHN0b3JlZCBibG9jay4gV2hlblxcclxcbiAgICAgICAgLy8gZGVjb21wcmVzc2luZywgUFBQIGNoZWNrcyB0aGF0IGF0IHRoZSBlbmQgb2YgaW5wdXQgcGFja2V0LCBpbmZsYXRlIGlzXFxyXFxuICAgICAgICAvLyB3YWl0aW5nIGZvciB0aGVzZSBsZW5ndGggYnl0ZXMuXFxyXFxuICAgICAgICB0aGF0LmluZmxhdGVTeW5jUG9pbnQgPSBmdW5jdGlvbih6KSB7XFxyXFxuICAgICAgICAgICAgaWYgKCF6IHx8ICF6LmlzdGF0ZSB8fCAhei5pc3RhdGUuYmxvY2tzKVxcclxcbiAgICAgICAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XFxyXFxuICAgICAgICAgICAgcmV0dXJuIHouaXN0YXRlLmJsb2Nrcy5zeW5jX3BvaW50KCk7XFxyXFxuICAgICAgICB9O1xcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgIC8vIFpTdHJlYW1cXHJcXG5cXHJcXG4gICAgZnVuY3Rpb24gWlN0cmVhbSgpIHtcXHJcXG4gICAgfVxcclxcblxcclxcbiAgICBaU3RyZWFtLnByb3RvdHlwZSA9IHtcXHJcXG4gICAgICAgIGluZmxhdGVJbml0IDogZnVuY3Rpb24oYml0cykge1xcclxcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcXHJcXG4gICAgICAgICAgICB0aGF0LmlzdGF0ZSA9IG5ldyBJbmZsYXRlKCk7XFxyXFxuICAgICAgICAgICAgaWYgKCFiaXRzKVxcclxcbiAgICAgICAgICAgICAgICBiaXRzID0gTUFYX0JJVFM7XFxyXFxuICAgICAgICAgICAgcmV0dXJuIHRoYXQuaXN0YXRlLmluZmxhdGVJbml0KHRoYXQsIGJpdHMpO1xcclxcbiAgICAgICAgfSxcXHJcXG5cXHJcXG4gICAgICAgIGluZmxhdGUgOiBmdW5jdGlvbihmKSB7XFxyXFxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xcclxcbiAgICAgICAgICAgIGlmICghdGhhdC5pc3RhdGUpXFxyXFxuICAgICAgICAgICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcXHJcXG4gICAgICAgICAgICByZXR1cm4gdGhhdC5pc3RhdGUuaW5mbGF0ZSh0aGF0LCBmKTtcXHJcXG4gICAgICAgIH0sXFxyXFxuXFxyXFxuICAgICAgICBpbmZsYXRlRW5kIDogZnVuY3Rpb24oKSB7XFxyXFxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xcclxcbiAgICAgICAgICAgIGlmICghdGhhdC5pc3RhdGUpXFxyXFxuICAgICAgICAgICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcXHJcXG4gICAgICAgICAgICB2YXIgcmV0ID0gdGhhdC5pc3RhdGUuaW5mbGF0ZUVuZCh0aGF0KTtcXHJcXG4gICAgICAgICAgICB0aGF0LmlzdGF0ZSA9IG51bGw7XFxyXFxuICAgICAgICAgICAgcmV0dXJuIHJldDtcXHJcXG4gICAgICAgIH0sXFxyXFxuXFxyXFxuICAgICAgICBpbmZsYXRlU3luYyA6IGZ1bmN0aW9uKCkge1xcclxcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcXHJcXG4gICAgICAgICAgICBpZiAoIXRoYXQuaXN0YXRlKVxcclxcbiAgICAgICAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XFxyXFxuICAgICAgICAgICAgcmV0dXJuIHRoYXQuaXN0YXRlLmluZmxhdGVTeW5jKHRoYXQpO1xcclxcbiAgICAgICAgfSxcXHJcXG4gICAgICAgIGluZmxhdGVTZXREaWN0aW9uYXJ5IDogZnVuY3Rpb24oZGljdGlvbmFyeSwgZGljdExlbmd0aCkge1xcclxcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcXHJcXG4gICAgICAgICAgICBpZiAoIXRoYXQuaXN0YXRlKVxcclxcbiAgICAgICAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XFxyXFxuICAgICAgICAgICAgcmV0dXJuIHRoYXQuaXN0YXRlLmluZmxhdGVTZXREaWN0aW9uYXJ5KHRoYXQsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgpO1xcclxcbiAgICAgICAgfSxcXHJcXG4gICAgICAgIHJlYWRfYnl0ZSA6IGZ1bmN0aW9uKHN0YXJ0KSB7XFxyXFxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xcclxcbiAgICAgICAgICAgIHJldHVybiB0aGF0Lm5leHRfaW4uc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgMSlbMF07XFxyXFxuICAgICAgICB9LFxcclxcbiAgICAgICAgcmVhZF9idWYgOiBmdW5jdGlvbihzdGFydCwgc2l6ZSkge1xcclxcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcXHJcXG4gICAgICAgICAgICByZXR1cm4gdGhhdC5uZXh0X2luLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIHNpemUpO1xcclxcbiAgICAgICAgfVxcclxcbiAgICB9O1xcclxcblxcclxcbiAgICAvLyBJbmZsYXRlclxcclxcblxcclxcbiAgICBmdW5jdGlvbiBJbmZsYXRlcigpIHtcXHJcXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcXHJcXG4gICAgICAgIHZhciB6ID0gbmV3IFpTdHJlYW0oKTtcXHJcXG4gICAgICAgIHZhciBidWZzaXplID0gNTEyO1xcclxcbiAgICAgICAgdmFyIGZsdXNoID0gWl9OT19GTFVTSDtcXHJcXG4gICAgICAgIHZhciBidWYgPSBuZXcgVWludDhBcnJheShidWZzaXplKTtcXHJcXG4gICAgICAgIHZhciBub21vcmVpbnB1dCA9IGZhbHNlO1xcclxcblxcclxcbiAgICAgICAgei5pbmZsYXRlSW5pdCgpO1xcclxcbiAgICAgICAgei5uZXh0X291dCA9IGJ1ZjtcXHJcXG5cXHJcXG4gICAgICAgIHRoYXQuYXBwZW5kID0gZnVuY3Rpb24oZGF0YSwgb25wcm9ncmVzcykge1xcclxcbiAgICAgICAgICAgIHZhciBlcnIsIGJ1ZmZlcnMgPSBbXSwgbGFzdEluZGV4ID0gMCwgYnVmZmVySW5kZXggPSAwLCBidWZmZXJTaXplID0gMCwgYXJyYXk7XFxyXFxuICAgICAgICAgICAgaWYgKGRhdGEubGVuZ3RoID09PSAwKVxcclxcbiAgICAgICAgICAgICAgICByZXR1cm47XFxyXFxuICAgICAgICAgICAgei5uZXh0X2luX2luZGV4ID0gMDtcXHJcXG4gICAgICAgICAgICB6Lm5leHRfaW4gPSBkYXRhO1xcclxcbiAgICAgICAgICAgIHouYXZhaWxfaW4gPSBkYXRhLmxlbmd0aDtcXHJcXG4gICAgICAgICAgICBkbyB7XFxyXFxuICAgICAgICAgICAgICAgIHoubmV4dF9vdXRfaW5kZXggPSAwO1xcclxcbiAgICAgICAgICAgICAgICB6LmF2YWlsX291dCA9IGJ1ZnNpemU7XFxyXFxuICAgICAgICAgICAgICAgIGlmICgoei5hdmFpbF9pbiA9PT0gMCkgJiYgKCFub21vcmVpbnB1dCkpIHsgLy8gaWYgYnVmZmVyIGlzIGVtcHR5IGFuZCBtb3JlIGlucHV0IGlzIGF2YWlsYWJsZSwgcmVmaWxsIGl0XFxyXFxuICAgICAgICAgICAgICAgICAgICB6Lm5leHRfaW5faW5kZXggPSAwO1xcclxcbiAgICAgICAgICAgICAgICAgICAgbm9tb3JlaW5wdXQgPSB0cnVlO1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgIGVyciA9IHouaW5mbGF0ZShmbHVzaCk7XFxyXFxuICAgICAgICAgICAgICAgIGlmIChub21vcmVpbnB1dCAmJiAoZXJyID09PSBaX0JVRl9FUlJPUikpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGlmICh6LmF2YWlsX2luICE9PSAwKVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcXFwiaW5mbGF0aW5nOiBiYWQgaW5wdXRcXFwiKTtcXHJcXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlcnIgIT09IFpfT0sgJiYgZXJyICE9PSBaX1NUUkVBTV9FTkQpXFxyXFxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXFxcImluZmxhdGluZzogXFxcIiArIHoubXNnKTtcXHJcXG4gICAgICAgICAgICAgICAgaWYgKChub21vcmVpbnB1dCB8fCBlcnIgPT09IFpfU1RSRUFNX0VORCkgJiYgKHouYXZhaWxfaW4gPT09IGRhdGEubGVuZ3RoKSlcXHJcXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcXFwiaW5mbGF0aW5nOiBiYWQgaW5wdXRcXFwiKTtcXHJcXG4gICAgICAgICAgICAgICAgaWYgKHoubmV4dF9vdXRfaW5kZXgpXFxyXFxuICAgICAgICAgICAgICAgICAgICBpZiAoei5uZXh0X291dF9pbmRleCA9PT0gYnVmc2l6ZSlcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJzLnB1c2gobmV3IFVpbnQ4QXJyYXkoYnVmKSk7XFxyXFxuICAgICAgICAgICAgICAgICAgICBlbHNlXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVycy5wdXNoKG5ldyBVaW50OEFycmF5KGJ1Zi5zdWJhcnJheSgwLCB6Lm5leHRfb3V0X2luZGV4KSkpO1xcclxcbiAgICAgICAgICAgICAgICBidWZmZXJTaXplICs9IHoubmV4dF9vdXRfaW5kZXg7XFxyXFxuICAgICAgICAgICAgICAgIGlmIChvbnByb2dyZXNzICYmIHoubmV4dF9pbl9pbmRleCA+IDAgJiYgei5uZXh0X2luX2luZGV4ICE9IGxhc3RJbmRleCkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgb25wcm9ncmVzcyh6Lm5leHRfaW5faW5kZXgpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgbGFzdEluZGV4ID0gei5uZXh0X2luX2luZGV4O1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgfSB3aGlsZSAoei5hdmFpbF9pbiA+IDAgfHwgei5hdmFpbF9vdXQgPT09IDApO1xcclxcbiAgICAgICAgICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyU2l6ZSk7XFxyXFxuICAgICAgICAgICAgYnVmZmVycy5mb3JFYWNoKGZ1bmN0aW9uKGNodW5rKSB7XFxyXFxuICAgICAgICAgICAgICAgIGFycmF5LnNldChjaHVuaywgYnVmZmVySW5kZXgpO1xcclxcbiAgICAgICAgICAgICAgICBidWZmZXJJbmRleCArPSBjaHVuay5sZW5ndGg7XFxyXFxuICAgICAgICAgICAgfSk7XFxyXFxuICAgICAgICAgICAgcmV0dXJuIGFycmF5O1xcclxcbiAgICAgICAgfTtcXHJcXG4gICAgICAgIHRoYXQuZmx1c2ggPSBmdW5jdGlvbigpIHtcXHJcXG4gICAgICAgICAgICB6LmluZmxhdGVFbmQoKTtcXHJcXG4gICAgICAgIH07XFxyXFxuICAgIH1cXHJcXG5cXHJcXG4gICAgLy8gJ3ppcCcgbWF5IG5vdCBiZSBkZWZpbmVkIGluIHotd29ya2VyIGFuZCBzb21lIHRlc3RzXFxyXFxuICAgIHZhciBlbnYgPSBnbG9iYWwuemlwIHx8IGdsb2JhbDtcXHJcXG4gICAgZW52LkluZmxhdGVyID0gZW52Ll9qemxpYl9JbmZsYXRlciA9IEluZmxhdGVyO1xcclxcbn0pKHRoaXMpO1wiO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBcIi8qIGpzaGludCB3b3JrZXI6dHJ1ZSAqL1xcclxcbihmdW5jdGlvbiBtYWluKGdsb2JhbCkge1xcclxcbiAgICBcXFwidXNlIHN0cmljdFxcXCI7XFxyXFxuXFxyXFxuICAgIGlmIChnbG9iYWwueldvcmtlckluaXRpYWxpemVkKVxcclxcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd6LXdvcmtlci5qcyBzaG91bGQgYmUgcnVuIG9ubHkgb25jZScpO1xcclxcbiAgICBnbG9iYWwueldvcmtlckluaXRpYWxpemVkID0gdHJ1ZTtcXHJcXG5cXHJcXG4gICAgYWRkRXZlbnRMaXN0ZW5lcihcXFwibWVzc2FnZVxcXCIsIGZ1bmN0aW9uKGV2ZW50KSB7XFxyXFxuICAgICAgICB2YXIgbWVzc2FnZSA9IGV2ZW50LmRhdGEsIHR5cGUgPSBtZXNzYWdlLnR5cGUsIHNuID0gbWVzc2FnZS5zbjtcXHJcXG4gICAgICAgIHZhciBoYW5kbGVyID0gaGFuZGxlcnNbdHlwZV07XFxyXFxuICAgICAgICBpZiAoaGFuZGxlcikge1xcclxcbiAgICAgICAgICAgIHRyeSB7XFxyXFxuICAgICAgICAgICAgICAgIGhhbmRsZXIobWVzc2FnZSk7XFxyXFxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xcclxcbiAgICAgICAgICAgICAgICBvbkVycm9yKHR5cGUsIHNuLCBlKTtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICAvL2ZvciBkZWJ1Z1xcclxcbiAgICAgICAgLy9wb3N0TWVzc2FnZSh7dHlwZTogJ2VjaG8nLCBvcmlnaW5hbFR5cGU6IHR5cGUsIHNuOiBzbn0pO1xcclxcbiAgICB9KTtcXHJcXG5cXHJcXG4gICAgdmFyIGhhbmRsZXJzID0ge1xcclxcbiAgICAgICAgaW1wb3J0U2NyaXB0czogZG9JbXBvcnRTY3JpcHRzLFxcclxcbiAgICAgICAgbmV3VGFzazogbmV3VGFzayxcXHJcXG4gICAgICAgIGFwcGVuZDogcHJvY2Vzc0RhdGEsXFxyXFxuICAgICAgICBmbHVzaDogcHJvY2Vzc0RhdGEsXFxyXFxuICAgIH07XFxyXFxuXFxyXFxuICAgIC8vIGRlZmxhdGVyL2luZmxhdGVyIHRhc2tzIGluZGV4ZWQgYnkgc2VyaWFsIG51bWJlcnNcXHJcXG4gICAgdmFyIHRhc2tzID0ge307XFxyXFxuXFxyXFxuICAgIGZ1bmN0aW9uIGRvSW1wb3J0U2NyaXB0cyhtc2cpIHtcXHJcXG4gICAgICAgIGlmIChtc2cuc2NyaXB0cyAmJiBtc2cuc2NyaXB0cy5sZW5ndGggPiAwKVxcclxcbiAgICAgICAgICAgIGltcG9ydFNjcmlwdHMuYXBwbHkodW5kZWZpbmVkLCBtc2cuc2NyaXB0cyk7XFxyXFxuICAgICAgICBwb3N0TWVzc2FnZSh7dHlwZTogJ2ltcG9ydFNjcmlwdHMnfSk7XFxyXFxuICAgIH1cXHJcXG5cXHJcXG4gICAgZnVuY3Rpb24gbmV3VGFzayhtc2cpIHtcXHJcXG4gICAgICAgIHZhciBDb2RlY0NsYXNzID0gZ2xvYmFsW21zZy5jb2RlY0NsYXNzXTtcXHJcXG4gICAgICAgIHZhciBzbiA9IG1zZy5zbjtcXHJcXG4gICAgICAgIGlmICh0YXNrc1tzbl0pXFxyXFxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ2R1cGxpY2F0ZWQgc24nKTtcXHJcXG4gICAgICAgIHRhc2tzW3NuXSA9ICB7XFxyXFxuICAgICAgICAgICAgY29kZWM6IG5ldyBDb2RlY0NsYXNzKG1zZy5vcHRpb25zKSxcXHJcXG4gICAgICAgICAgICBjcmNJbnB1dDogbXNnLmNyY1R5cGUgPT09ICdpbnB1dCcsXFxyXFxuICAgICAgICAgICAgY3JjT3V0cHV0OiBtc2cuY3JjVHlwZSA9PT0gJ291dHB1dCcsXFxyXFxuICAgICAgICAgICAgY3JjOiBuZXcgQ3JjMzIoKSxcXHJcXG4gICAgICAgIH07XFxyXFxuICAgICAgICBwb3N0TWVzc2FnZSh7dHlwZTogJ25ld1Rhc2snLCBzbjogc259KTtcXHJcXG4gICAgfVxcclxcblxcclxcbiAgICAvLyBwZXJmb3JtYW5jZSBtYXkgbm90IGJlIHN1cHBvcnRlZFxcclxcbiAgICB2YXIgbm93ID0gZ2xvYmFsLnBlcmZvcm1hbmNlID8gZ2xvYmFsLnBlcmZvcm1hbmNlLm5vdy5iaW5kKGdsb2JhbC5wZXJmb3JtYW5jZSkgOiBEYXRlLm5vdztcXHJcXG5cXHJcXG4gICAgZnVuY3Rpb24gcHJvY2Vzc0RhdGEobXNnKSB7XFxyXFxuICAgICAgICB2YXIgc24gPSBtc2cuc24sIHR5cGUgPSBtc2cudHlwZSwgaW5wdXQgPSBtc2cuZGF0YTtcXHJcXG4gICAgICAgIHZhciB0YXNrID0gdGFza3Nbc25dO1xcclxcbiAgICAgICAgLy8gYWxsb3cgY3JlYXRpbmcgY29kZWMgb24gZmlyc3QgYXBwZW5kXFxyXFxuICAgICAgICBpZiAoIXRhc2sgJiYgbXNnLmNvZGVjQ2xhc3MpIHtcXHJcXG4gICAgICAgICAgICBuZXdUYXNrKG1zZyk7XFxyXFxuICAgICAgICAgICAgdGFzayA9IHRhc2tzW3NuXTtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICAgIHZhciBpc0FwcGVuZCA9IHR5cGUgPT09ICdhcHBlbmQnO1xcclxcbiAgICAgICAgdmFyIHN0YXJ0ID0gbm93KCk7XFxyXFxuICAgICAgICB2YXIgb3V0cHV0O1xcclxcbiAgICAgICAgaWYgKGlzQXBwZW5kKSB7XFxyXFxuICAgICAgICAgICAgdHJ5IHtcXHJcXG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gdGFzay5jb2RlYy5hcHBlbmQoaW5wdXQsIGZ1bmN0aW9uIG9ucHJvZ3Jlc3MobG9hZGVkKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZSh7dHlwZTogJ3Byb2dyZXNzJywgc246IHNuLCBsb2FkZWQ6IGxvYWRlZH0pO1xcclxcbiAgICAgICAgICAgICAgICB9KTtcXHJcXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XFxyXFxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0YXNrc1tzbl07XFxyXFxuICAgICAgICAgICAgICAgIHRocm93IGU7XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgICBkZWxldGUgdGFza3Nbc25dO1xcclxcbiAgICAgICAgICAgIG91dHB1dCA9IHRhc2suY29kZWMuZmx1c2goKTtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICAgIHZhciBjb2RlY1RpbWUgPSBub3coKSAtIHN0YXJ0O1xcclxcblxcclxcbiAgICAgICAgc3RhcnQgPSBub3coKTtcXHJcXG4gICAgICAgIGlmIChpbnB1dCAmJiB0YXNrLmNyY0lucHV0KVxcclxcbiAgICAgICAgICAgIHRhc2suY3JjLmFwcGVuZChpbnB1dCk7XFxyXFxuICAgICAgICBpZiAob3V0cHV0ICYmIHRhc2suY3JjT3V0cHV0KVxcclxcbiAgICAgICAgICAgIHRhc2suY3JjLmFwcGVuZChvdXRwdXQpO1xcclxcbiAgICAgICAgdmFyIGNyY1RpbWUgPSBub3coKSAtIHN0YXJ0O1xcclxcblxcclxcbiAgICAgICAgdmFyIHJtc2cgPSB7dHlwZTogdHlwZSwgc246IHNuLCBjb2RlY1RpbWU6IGNvZGVjVGltZSwgY3JjVGltZTogY3JjVGltZX07XFxyXFxuICAgICAgICB2YXIgdHJhbnNmZXJhYmxlcyA9IFtdO1xcclxcbiAgICAgICAgaWYgKG91dHB1dCkge1xcclxcbiAgICAgICAgICAgIHJtc2cuZGF0YSA9IG91dHB1dDtcXHJcXG4gICAgICAgICAgICB0cmFuc2ZlcmFibGVzLnB1c2gob3V0cHV0LmJ1ZmZlcik7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICBpZiAoIWlzQXBwZW5kICYmICh0YXNrLmNyY0lucHV0IHx8IHRhc2suY3JjT3V0cHV0KSlcXHJcXG4gICAgICAgICAgICBybXNnLmNyYyA9IHRhc2suY3JjLmdldCgpO1xcclxcblxcclxcbiAgICAgICAgLy8gcG9zdGluZyBhIG1lc3NhZ2Ugd2l0aCB0cmFuc2ZlcmFibGVzIHdpbGwgZmFpbCBvbiBJRTEwXFxyXFxuICAgICAgICB0cnkge1xcclxcbiAgICAgICAgICAgIHBvc3RNZXNzYWdlKHJtc2csIHRyYW5zZmVyYWJsZXMpO1xcclxcbiAgICAgICAgfSBjYXRjaChleCkge1xcclxcbiAgICAgICAgICAgIHBvc3RNZXNzYWdlKHJtc2cpOyAvLyByZXRyeSB3aXRob3V0IHRyYW5zZmVyYWJsZXNcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgfVxcclxcblxcclxcbiAgICBmdW5jdGlvbiBvbkVycm9yKHR5cGUsIHNuLCBlKSB7XFxyXFxuICAgICAgICB2YXIgbXNnID0ge1xcclxcbiAgICAgICAgICAgIHR5cGU6IHR5cGUsXFxyXFxuICAgICAgICAgICAgc246IHNuLFxcclxcbiAgICAgICAgICAgIGVycm9yOiBmb3JtYXRFcnJvcihlKVxcclxcbiAgICAgICAgfTtcXHJcXG4gICAgICAgIHBvc3RNZXNzYWdlKG1zZyk7XFxyXFxuICAgIH1cXHJcXG5cXHJcXG4gICAgZnVuY3Rpb24gZm9ybWF0RXJyb3IoZSkge1xcclxcbiAgICAgICAgcmV0dXJuIHsgbWVzc2FnZTogZS5tZXNzYWdlLCBzdGFjazogZS5zdGFjayB9O1xcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgIC8vIENyYzMyIGNvZGUgY29waWVkIGZyb20gZmlsZSB6aXAuanNcXHJcXG4gICAgZnVuY3Rpb24gQ3JjMzIoKSB7XFxyXFxuICAgICAgICB0aGlzLmNyYyA9IC0xO1xcclxcbiAgICB9XFxyXFxuICAgIENyYzMyLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbiBhcHBlbmQoZGF0YSkge1xcclxcbiAgICAgICAgdmFyIGNyYyA9IHRoaXMuY3JjIHwgMCwgdGFibGUgPSB0aGlzLnRhYmxlO1xcclxcbiAgICAgICAgZm9yICh2YXIgb2Zmc2V0ID0gMCwgbGVuID0gZGF0YS5sZW5ndGggfCAwOyBvZmZzZXQgPCBsZW47IG9mZnNldCsrKVxcclxcbiAgICAgICAgICAgIGNyYyA9IChjcmMgPj4+IDgpIF4gdGFibGVbKGNyYyBeIGRhdGFbb2Zmc2V0XSkgJiAweEZGXTtcXHJcXG4gICAgICAgIHRoaXMuY3JjID0gY3JjO1xcclxcbiAgICB9O1xcclxcbiAgICBDcmMzMi5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0KCkge1xcclxcbiAgICAgICAgcmV0dXJuIH50aGlzLmNyYztcXHJcXG4gICAgfTtcXHJcXG4gICAgQ3JjMzIucHJvdG90eXBlLnRhYmxlID0gKGZ1bmN0aW9uKCkge1xcclxcbiAgICAgICAgdmFyIGksIGosIHQsIHRhYmxlID0gW107IC8vIFVpbnQzMkFycmF5IGlzIGFjdHVhbGx5IHNsb3dlciB0aGFuIFtdXFxyXFxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcXHJcXG4gICAgICAgICAgICB0ID0gaTtcXHJcXG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgODsgaisrKVxcclxcbiAgICAgICAgICAgICAgICBpZiAodCAmIDEpXFxyXFxuICAgICAgICAgICAgICAgICAgICB0ID0gKHQgPj4+IDEpIF4gMHhFREI4ODMyMDtcXHJcXG4gICAgICAgICAgICAgICAgZWxzZVxcclxcbiAgICAgICAgICAgICAgICAgICAgdCA9IHQgPj4+IDE7XFxyXFxuICAgICAgICAgICAgdGFibGVbaV0gPSB0O1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgcmV0dXJuIHRhYmxlO1xcclxcbiAgICB9KSgpO1xcclxcblxcclxcbiAgICAvLyBcXFwibm8tb3BcXFwiIGNvZGVjXFxyXFxuICAgIGZ1bmN0aW9uIE5PT1AoKSB7fVxcclxcbiAgICBnbG9iYWwuTk9PUCA9IE5PT1A7XFxyXFxuICAgIE5PT1AucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uIGFwcGVuZChieXRlcywgb25wcm9ncmVzcykge1xcclxcbiAgICAgICAgcmV0dXJuIGJ5dGVzO1xcclxcbiAgICB9O1xcclxcbiAgICBOT09QLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uIGZsdXNoKCkge307XFxyXFxufSkodGhpcyk7XCI7XG4iLCIvKlxyXG4gQ29weXJpZ2h0IChjKSAyMDEzIEdpbGRhcyBMb3JtZWF1LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG5cclxuIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxyXG4gbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XHJcblxyXG4gMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxyXG4gdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cclxuXHJcbiAyLiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxyXG4gbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluXHJcbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cclxuXHJcbiAzLiBUaGUgbmFtZXMgb2YgdGhlIGF1dGhvcnMgbWF5IG5vdCBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0c1xyXG4gZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXHJcblxyXG4gVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBgYEFTIElTJycgQU5EIEFOWSBFWFBSRVNTRUQgT1IgSU1QTElFRCBXQVJSQU5USUVTLFxyXG4gSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORFxyXG4gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIEpDUkFGVCxcclxuIElOQy4gT1IgQU5ZIENPTlRSSUJVVE9SUyBUTyBUSElTIFNPRlRXQVJFIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsXHJcbiBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UXHJcbiBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSxcclxuIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0ZcclxuIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HXHJcbiBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsXHJcbiBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxyXG4gKi9cclxuXHJcbihmdW5jdGlvbigpIHtcclxuXHRcInVzZSBzdHJpY3RcIjtcclxuXHJcblx0dmFyIEVSUl9IVFRQX1JBTkdFID0gXCJIVFRQIFJhbmdlIG5vdCBzdXBwb3J0ZWQuXCI7XHJcblxyXG5cdHZhciBSZWFkZXIgPSB6aXAuUmVhZGVyO1xyXG5cdHZhciBXcml0ZXIgPSB6aXAuV3JpdGVyO1xyXG5cdFxyXG5cdHZhciBaaXBEaXJlY3RvcnlFbnRyeTtcclxuXHJcblx0dmFyIGFwcGVuZEFCVmlld1N1cHBvcnRlZDtcclxuXHR0cnkge1xyXG5cdFx0YXBwZW5kQUJWaWV3U3VwcG9ydGVkID0gbmV3IEJsb2IoWyBuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDApKSBdKS5zaXplID09PSAwO1xyXG5cdH0gY2F0Y2ggKGUpIHtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIEh0dHBSZWFkZXIodXJsKSB7XHJcblx0XHR2YXIgdGhhdCA9IHRoaXM7XHJcblxyXG5cdFx0ZnVuY3Rpb24gZ2V0RGF0YShjYWxsYmFjaywgb25lcnJvcikge1xyXG5cdFx0XHR2YXIgcmVxdWVzdDtcclxuXHRcdFx0aWYgKCF0aGF0LmRhdGEpIHtcclxuXHRcdFx0XHRyZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcblx0XHRcdFx0cmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdGlmICghdGhhdC5zaXplKVxyXG5cdFx0XHRcdFx0XHR0aGF0LnNpemUgPSBOdW1iZXIocmVxdWVzdC5nZXRSZXNwb25zZUhlYWRlcihcIkNvbnRlbnQtTGVuZ3RoXCIpKTtcclxuXHRcdFx0XHRcdHRoYXQuZGF0YSA9IG5ldyBVaW50OEFycmF5KHJlcXVlc3QucmVzcG9uc2UpO1xyXG5cdFx0XHRcdFx0Y2FsbGJhY2soKTtcclxuXHRcdFx0XHR9LCBmYWxzZSk7XHJcblx0XHRcdFx0cmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgb25lcnJvciwgZmFsc2UpO1xyXG5cdFx0XHRcdHJlcXVlc3Qub3BlbihcIkdFVFwiLCB1cmwpO1xyXG5cdFx0XHRcdHJlcXVlc3QucmVzcG9uc2VUeXBlID0gXCJhcnJheWJ1ZmZlclwiO1xyXG5cdFx0XHRcdHJlcXVlc3Quc2VuZCgpO1xyXG5cdFx0XHR9IGVsc2VcclxuXHRcdFx0XHRjYWxsYmFjaygpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIGluaXQoY2FsbGJhY2ssIG9uZXJyb3IpIHtcclxuXHRcdFx0dmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuXHRcdFx0cmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHR0aGF0LnNpemUgPSBOdW1iZXIocmVxdWVzdC5nZXRSZXNwb25zZUhlYWRlcihcIkNvbnRlbnQtTGVuZ3RoXCIpKTtcclxuXHRcdFx0XHRjYWxsYmFjaygpO1xyXG5cdFx0XHR9LCBmYWxzZSk7XHJcblx0XHRcdHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIG9uZXJyb3IsIGZhbHNlKTtcclxuXHRcdFx0cmVxdWVzdC5vcGVuKFwiSEVBRFwiLCB1cmwpO1xyXG5cdFx0XHRyZXF1ZXN0LnNlbmQoKTtcclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiByZWFkVWludDhBcnJheShpbmRleCwgbGVuZ3RoLCBjYWxsYmFjaywgb25lcnJvcikge1xyXG5cdFx0XHRnZXREYXRhKGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdGNhbGxiYWNrKG5ldyBVaW50OEFycmF5KHRoYXQuZGF0YS5zdWJhcnJheShpbmRleCwgaW5kZXggKyBsZW5ndGgpKSk7XHJcblx0XHRcdH0sIG9uZXJyb3IpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoYXQuc2l6ZSA9IDA7XHJcblx0XHR0aGF0LmluaXQgPSBpbml0O1xyXG5cdFx0dGhhdC5yZWFkVWludDhBcnJheSA9IHJlYWRVaW50OEFycmF5O1xyXG5cdH1cclxuXHRIdHRwUmVhZGVyLnByb3RvdHlwZSA9IG5ldyBSZWFkZXIoKTtcclxuXHRIdHRwUmVhZGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEh0dHBSZWFkZXI7XHJcblxyXG5cdGZ1bmN0aW9uIEh0dHBSYW5nZVJlYWRlcih1cmwpIHtcclxuXHRcdHZhciB0aGF0ID0gdGhpcztcclxuXHJcblx0XHRmdW5jdGlvbiBpbml0KGNhbGxiYWNrLCBvbmVycm9yKSB7XHJcblx0XHRcdHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcblx0XHRcdHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0dGhhdC5zaXplID0gTnVtYmVyKHJlcXVlc3QuZ2V0UmVzcG9uc2VIZWFkZXIoXCJDb250ZW50LUxlbmd0aFwiKSk7XHJcblx0XHRcdFx0aWYgKHJlcXVlc3QuZ2V0UmVzcG9uc2VIZWFkZXIoXCJBY2NlcHQtUmFuZ2VzXCIpID09IFwiYnl0ZXNcIilcclxuXHRcdFx0XHRcdGNhbGxiYWNrKCk7XHJcblx0XHRcdFx0ZWxzZVxyXG5cdFx0XHRcdFx0b25lcnJvcihFUlJfSFRUUF9SQU5HRSk7XHJcblx0XHRcdH0sIGZhbHNlKTtcclxuXHRcdFx0cmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgb25lcnJvciwgZmFsc2UpO1xyXG5cdFx0XHRyZXF1ZXN0Lm9wZW4oXCJIRUFEXCIsIHVybCk7XHJcblx0XHRcdHJlcXVlc3Quc2VuZCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIHJlYWRBcnJheUJ1ZmZlcihpbmRleCwgbGVuZ3RoLCBjYWxsYmFjaywgb25lcnJvcikge1xyXG5cdFx0XHR2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG5cdFx0XHRyZXF1ZXN0Lm9wZW4oXCJHRVRcIiwgdXJsKTtcclxuXHRcdFx0cmVxdWVzdC5yZXNwb25zZVR5cGUgPSBcImFycmF5YnVmZmVyXCI7XHJcblx0XHRcdHJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcihcIlJhbmdlXCIsIFwiYnl0ZXM9XCIgKyBpbmRleCArIFwiLVwiICsgKGluZGV4ICsgbGVuZ3RoIC0gMSkpO1xyXG5cdFx0XHRyZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdGNhbGxiYWNrKHJlcXVlc3QucmVzcG9uc2UpO1xyXG5cdFx0XHR9LCBmYWxzZSk7XHJcblx0XHRcdHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIG9uZXJyb3IsIGZhbHNlKTtcclxuXHRcdFx0cmVxdWVzdC5zZW5kKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gcmVhZFVpbnQ4QXJyYXkoaW5kZXgsIGxlbmd0aCwgY2FsbGJhY2ssIG9uZXJyb3IpIHtcclxuXHRcdFx0cmVhZEFycmF5QnVmZmVyKGluZGV4LCBsZW5ndGgsIGZ1bmN0aW9uKGFycmF5YnVmZmVyKSB7XHJcblx0XHRcdFx0Y2FsbGJhY2sobmV3IFVpbnQ4QXJyYXkoYXJyYXlidWZmZXIpKTtcclxuXHRcdFx0fSwgb25lcnJvcik7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhhdC5zaXplID0gMDtcclxuXHRcdHRoYXQuaW5pdCA9IGluaXQ7XHJcblx0XHR0aGF0LnJlYWRVaW50OEFycmF5ID0gcmVhZFVpbnQ4QXJyYXk7XHJcblx0fVxyXG5cdEh0dHBSYW5nZVJlYWRlci5wcm90b3R5cGUgPSBuZXcgUmVhZGVyKCk7XHJcblx0SHR0cFJhbmdlUmVhZGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEh0dHBSYW5nZVJlYWRlcjtcclxuXHJcblx0ZnVuY3Rpb24gQXJyYXlCdWZmZXJSZWFkZXIoYXJyYXlCdWZmZXIpIHtcclxuXHRcdHZhciB0aGF0ID0gdGhpcztcclxuXHJcblx0XHRmdW5jdGlvbiBpbml0KGNhbGxiYWNrLCBvbmVycm9yKSB7XHJcblx0XHRcdHRoYXQuc2l6ZSA9IGFycmF5QnVmZmVyLmJ5dGVMZW5ndGg7XHJcblx0XHRcdGNhbGxiYWNrKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gcmVhZFVpbnQ4QXJyYXkoaW5kZXgsIGxlbmd0aCwgY2FsbGJhY2ssIG9uZXJyb3IpIHtcclxuXHRcdFx0Y2FsbGJhY2sobmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIuc2xpY2UoaW5kZXgsIGluZGV4ICsgbGVuZ3RoKSkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoYXQuc2l6ZSA9IDA7XHJcblx0XHR0aGF0LmluaXQgPSBpbml0O1xyXG5cdFx0dGhhdC5yZWFkVWludDhBcnJheSA9IHJlYWRVaW50OEFycmF5O1xyXG5cdH1cclxuXHRBcnJheUJ1ZmZlclJlYWRlci5wcm90b3R5cGUgPSBuZXcgUmVhZGVyKCk7XHJcblx0QXJyYXlCdWZmZXJSZWFkZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQXJyYXlCdWZmZXJSZWFkZXI7XHJcblxyXG5cdGZ1bmN0aW9uIEFycmF5QnVmZmVyV3JpdGVyKCkge1xyXG5cdFx0dmFyIGFycmF5LCB0aGF0ID0gdGhpcztcclxuXHJcblx0XHRmdW5jdGlvbiBpbml0KGNhbGxiYWNrLCBvbmVycm9yKSB7XHJcblx0XHRcdGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoKTtcclxuXHRcdFx0Y2FsbGJhY2soKTtcclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiB3cml0ZVVpbnQ4QXJyYXkoYXJyLCBjYWxsYmFjaywgb25lcnJvcikge1xyXG5cdFx0XHR2YXIgdG1wQXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheS5sZW5ndGggKyBhcnIubGVuZ3RoKTtcclxuXHRcdFx0dG1wQXJyYXkuc2V0KGFycmF5KTtcclxuXHRcdFx0dG1wQXJyYXkuc2V0KGFyciwgYXJyYXkubGVuZ3RoKTtcclxuXHRcdFx0YXJyYXkgPSB0bXBBcnJheTtcclxuXHRcdFx0Y2FsbGJhY2soKTtcclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBnZXREYXRhKGNhbGxiYWNrKSB7XHJcblx0XHRcdGNhbGxiYWNrKGFycmF5LmJ1ZmZlcik7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhhdC5pbml0ID0gaW5pdDtcclxuXHRcdHRoYXQud3JpdGVVaW50OEFycmF5ID0gd3JpdGVVaW50OEFycmF5O1xyXG5cdFx0dGhhdC5nZXREYXRhID0gZ2V0RGF0YTtcclxuXHR9XHJcblx0QXJyYXlCdWZmZXJXcml0ZXIucHJvdG90eXBlID0gbmV3IFdyaXRlcigpO1xyXG5cdEFycmF5QnVmZmVyV3JpdGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEFycmF5QnVmZmVyV3JpdGVyO1xyXG5cclxuXHRmdW5jdGlvbiBGaWxlV3JpdGVyKGZpbGVFbnRyeSwgY29udGVudFR5cGUpIHtcclxuXHRcdHZhciB3cml0ZXIsIHRoYXQgPSB0aGlzO1xyXG5cclxuXHRcdGZ1bmN0aW9uIGluaXQoY2FsbGJhY2ssIG9uZXJyb3IpIHtcclxuXHRcdFx0ZmlsZUVudHJ5LmNyZWF0ZVdyaXRlcihmdW5jdGlvbihmaWxlV3JpdGVyKSB7XHJcblx0XHRcdFx0d3JpdGVyID0gZmlsZVdyaXRlcjtcclxuXHRcdFx0XHRjYWxsYmFjaygpO1xyXG5cdFx0XHR9LCBvbmVycm9yKTtcclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiB3cml0ZVVpbnQ4QXJyYXkoYXJyYXksIGNhbGxiYWNrLCBvbmVycm9yKSB7XHJcblx0XHRcdHZhciBibG9iID0gbmV3IEJsb2IoWyBhcHBlbmRBQlZpZXdTdXBwb3J0ZWQgPyBhcnJheSA6IGFycmF5LmJ1ZmZlciBdLCB7XHJcblx0XHRcdFx0dHlwZSA6IGNvbnRlbnRUeXBlXHJcblx0XHRcdH0pO1xyXG5cdFx0XHR3cml0ZXIub253cml0ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHdyaXRlci5vbndyaXRlID0gbnVsbDtcclxuXHRcdFx0XHRjYWxsYmFjaygpO1xyXG5cdFx0XHR9O1xyXG5cdFx0XHR3cml0ZXIub25lcnJvciA9IG9uZXJyb3I7XHJcblx0XHRcdHdyaXRlci53cml0ZShibG9iKTtcclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBnZXREYXRhKGNhbGxiYWNrKSB7XHJcblx0XHRcdGZpbGVFbnRyeS5maWxlKGNhbGxiYWNrKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGF0LmluaXQgPSBpbml0O1xyXG5cdFx0dGhhdC53cml0ZVVpbnQ4QXJyYXkgPSB3cml0ZVVpbnQ4QXJyYXk7XHJcblx0XHR0aGF0LmdldERhdGEgPSBnZXREYXRhO1xyXG5cdH1cclxuXHRGaWxlV3JpdGVyLnByb3RvdHlwZSA9IG5ldyBXcml0ZXIoKTtcclxuXHRGaWxlV3JpdGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEZpbGVXcml0ZXI7XHJcblxyXG5cdHppcC5GaWxlV3JpdGVyID0gRmlsZVdyaXRlcjtcclxuXHR6aXAuSHR0cFJlYWRlciA9IEh0dHBSZWFkZXI7XHJcblx0emlwLkh0dHBSYW5nZVJlYWRlciA9IEh0dHBSYW5nZVJlYWRlcjtcclxuXHR6aXAuQXJyYXlCdWZmZXJSZWFkZXIgPSBBcnJheUJ1ZmZlclJlYWRlcjtcclxuXHR6aXAuQXJyYXlCdWZmZXJXcml0ZXIgPSBBcnJheUJ1ZmZlcldyaXRlcjtcclxuXHJcblx0aWYgKHppcC5mcykge1xyXG5cdFx0WmlwRGlyZWN0b3J5RW50cnkgPSB6aXAuZnMuWmlwRGlyZWN0b3J5RW50cnk7XHJcblx0XHRaaXBEaXJlY3RvcnlFbnRyeS5wcm90b3R5cGUuYWRkSHR0cENvbnRlbnQgPSBmdW5jdGlvbihuYW1lLCBVUkwsIHVzZVJhbmdlSGVhZGVyKSB7XHJcblx0XHRcdGZ1bmN0aW9uIGFkZENoaWxkKHBhcmVudCwgbmFtZSwgcGFyYW1zLCBkaXJlY3RvcnkpIHtcclxuXHRcdFx0XHRpZiAocGFyZW50LmRpcmVjdG9yeSlcclxuXHRcdFx0XHRcdHJldHVybiBkaXJlY3RvcnkgPyBuZXcgWmlwRGlyZWN0b3J5RW50cnkocGFyZW50LmZzLCBuYW1lLCBwYXJhbXMsIHBhcmVudCkgOiBuZXcgemlwLmZzLlppcEZpbGVFbnRyeShwYXJlbnQuZnMsIG5hbWUsIHBhcmFtcywgcGFyZW50KTtcclxuXHRcdFx0XHRlbHNlXHJcblx0XHRcdFx0XHR0aHJvdyBcIlBhcmVudCBlbnRyeSBpcyBub3QgYSBkaXJlY3RvcnkuXCI7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBhZGRDaGlsZCh0aGlzLCBuYW1lLCB7XHJcblx0XHRcdFx0ZGF0YSA6IFVSTCxcclxuXHRcdFx0XHRSZWFkZXIgOiB1c2VSYW5nZUhlYWRlciA/IEh0dHBSYW5nZVJlYWRlciA6IEh0dHBSZWFkZXJcclxuXHRcdFx0fSk7XHJcblx0XHR9O1xyXG5cdFx0WmlwRGlyZWN0b3J5RW50cnkucHJvdG90eXBlLmltcG9ydEh0dHBDb250ZW50ID0gZnVuY3Rpb24oVVJMLCB1c2VSYW5nZUhlYWRlciwgb25lbmQsIG9uZXJyb3IpIHtcclxuXHRcdFx0dGhpcy5pbXBvcnRaaXAodXNlUmFuZ2VIZWFkZXIgPyBuZXcgSHR0cFJhbmdlUmVhZGVyKFVSTCkgOiBuZXcgSHR0cFJlYWRlcihVUkwpLCBvbmVuZCwgb25lcnJvcik7XHJcblx0XHR9O1xyXG5cdFx0emlwLmZzLkZTLnByb3RvdHlwZS5pbXBvcnRIdHRwQ29udGVudCA9IGZ1bmN0aW9uKFVSTCwgdXNlUmFuZ2VIZWFkZXIsIG9uZW5kLCBvbmVycm9yKSB7XHJcblx0XHRcdHRoaXMuZW50cmllcyA9IFtdO1xyXG5cdFx0XHR0aGlzLnJvb3QgPSBuZXcgWmlwRGlyZWN0b3J5RW50cnkodGhpcyk7XHJcblx0XHRcdHRoaXMucm9vdC5pbXBvcnRIdHRwQ29udGVudChVUkwsIHVzZVJhbmdlSGVhZGVyLCBvbmVuZCwgb25lcnJvcik7XHJcblx0XHR9O1xyXG5cdH1cclxuXHJcbn0pKCk7XHJcbiIsIi8qXHJcbiBDb3B5cmlnaHQgKGMpIDIwMTMgR2lsZGFzIExvcm1lYXUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcblxyXG4gUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XHJcbiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcclxuXHJcbiAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXHJcbiB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxyXG5cclxuIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XHJcbiBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW5cclxuIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxyXG5cclxuIDMuIFRoZSBuYW1lcyBvZiB0aGUgYXV0aG9ycyBtYXkgbm90IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzXHJcbiBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cclxuXHJcbiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIGBgQVMgSVMnJyBBTkQgQU5ZIEVYUFJFU1NFRCBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsXHJcbiBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EXHJcbiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgSkNSQUZULFxyXG4gSU5DLiBPUiBBTlkgQ09OVFJJQlVUT1JTIFRPIFRISVMgU09GVFdBUkUgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCxcclxuIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1RcclxuIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLFxyXG4gT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRlxyXG4gTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkdcclxuIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSxcclxuIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXHJcbiAqL1xyXG5cclxuKGZ1bmN0aW9uKG9iaikge1xyXG5cdFwidXNlIHN0cmljdFwiO1xyXG5cclxuXHR2YXIgRVJSX0JBRF9GT1JNQVQgPSBcIkZpbGUgZm9ybWF0IGlzIG5vdCByZWNvZ25pemVkLlwiO1xyXG5cdHZhciBFUlJfQ1JDID0gXCJDUkMgZmFpbGVkLlwiO1xyXG5cdHZhciBFUlJfRU5DUllQVEVEID0gXCJGaWxlIGNvbnRhaW5zIGVuY3J5cHRlZCBlbnRyeS5cIjtcclxuXHR2YXIgRVJSX1pJUDY0ID0gXCJGaWxlIGlzIHVzaW5nIFppcDY0ICg0Z2IrIGZpbGUgc2l6ZSkuXCI7XHJcblx0dmFyIEVSUl9SRUFEID0gXCJFcnJvciB3aGlsZSByZWFkaW5nIHppcCBmaWxlLlwiO1xyXG5cdHZhciBFUlJfV1JJVEUgPSBcIkVycm9yIHdoaWxlIHdyaXRpbmcgemlwIGZpbGUuXCI7XHJcblx0dmFyIEVSUl9XUklURV9EQVRBID0gXCJFcnJvciB3aGlsZSB3cml0aW5nIGZpbGUgZGF0YS5cIjtcclxuXHR2YXIgRVJSX1JFQURfREFUQSA9IFwiRXJyb3Igd2hpbGUgcmVhZGluZyBmaWxlIGRhdGEuXCI7XHJcblx0dmFyIEVSUl9EVVBMSUNBVEVEX05BTUUgPSBcIkZpbGUgYWxyZWFkeSBleGlzdHMuXCI7XHJcblx0dmFyIENIVU5LX1NJWkUgPSA1MTIgKiAxMDI0O1xyXG5cclxuXHR2YXIgVEVYVF9QTEFJTiA9IFwidGV4dC9wbGFpblwiO1xyXG5cclxuXHR2YXIgYXBwZW5kQUJWaWV3U3VwcG9ydGVkO1xyXG5cdHRyeSB7XHJcblx0XHRhcHBlbmRBQlZpZXdTdXBwb3J0ZWQgPSBuZXcgQmxvYihbIG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMCkpIF0pLnNpemUgPT09IDA7XHJcblx0fSBjYXRjaCAoZSkge1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gQ3JjMzIoKSB7XHJcblx0XHR0aGlzLmNyYyA9IC0xO1xyXG5cdH1cclxuXHRDcmMzMi5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24gYXBwZW5kKGRhdGEpIHtcclxuXHRcdHZhciBjcmMgPSB0aGlzLmNyYyB8IDAsIHRhYmxlID0gdGhpcy50YWJsZTtcclxuXHRcdGZvciAodmFyIG9mZnNldCA9IDAsIGxlbiA9IGRhdGEubGVuZ3RoIHwgMDsgb2Zmc2V0IDwgbGVuOyBvZmZzZXQrKylcclxuXHRcdFx0Y3JjID0gKGNyYyA+Pj4gOCkgXiB0YWJsZVsoY3JjIF4gZGF0YVtvZmZzZXRdKSAmIDB4RkZdO1xyXG5cdFx0dGhpcy5jcmMgPSBjcmM7XHJcblx0fTtcclxuXHRDcmMzMi5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0KCkge1xyXG5cdFx0cmV0dXJuIH50aGlzLmNyYztcclxuXHR9O1xyXG5cdENyYzMyLnByb3RvdHlwZS50YWJsZSA9IChmdW5jdGlvbigpIHtcclxuXHRcdHZhciBpLCBqLCB0LCB0YWJsZSA9IFtdOyAvLyBVaW50MzJBcnJheSBpcyBhY3R1YWxseSBzbG93ZXIgdGhhbiBbXVxyXG5cdFx0Zm9yIChpID0gMDsgaSA8IDI1NjsgaSsrKSB7XHJcblx0XHRcdHQgPSBpO1xyXG5cdFx0XHRmb3IgKGogPSAwOyBqIDwgODsgaisrKVxyXG5cdFx0XHRcdGlmICh0ICYgMSlcclxuXHRcdFx0XHRcdHQgPSAodCA+Pj4gMSkgXiAweEVEQjg4MzIwO1xyXG5cdFx0XHRcdGVsc2VcclxuXHRcdFx0XHRcdHQgPSB0ID4+PiAxO1xyXG5cdFx0XHR0YWJsZVtpXSA9IHQ7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGFibGU7XHJcblx0fSkoKTtcclxuXHJcblx0Ly8gXCJuby1vcFwiIGNvZGVjXHJcblx0ZnVuY3Rpb24gTk9PUCgpIHt9XHJcblx0Tk9PUC5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24gYXBwZW5kKGJ5dGVzLCBvbnByb2dyZXNzKSB7XHJcblx0XHRyZXR1cm4gYnl0ZXM7XHJcblx0fTtcclxuXHROT09QLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uIGZsdXNoKCkge307XHJcblxyXG5cdGZ1bmN0aW9uIGJsb2JTbGljZShibG9iLCBpbmRleCwgbGVuZ3RoKSB7XHJcblx0XHRpZiAoaW5kZXggPCAwIHx8IGxlbmd0aCA8IDAgfHwgaW5kZXggKyBsZW5ndGggPiBibG9iLnNpemUpXHJcblx0XHRcdHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQ6JyArIGluZGV4ICsgJywgbGVuZ3RoOicgKyBsZW5ndGggKyAnLCBzaXplOicgKyBibG9iLnNpemUpO1xyXG5cdFx0aWYgKGJsb2Iuc2xpY2UpXHJcblx0XHRcdHJldHVybiBibG9iLnNsaWNlKGluZGV4LCBpbmRleCArIGxlbmd0aCk7XHJcblx0XHRlbHNlIGlmIChibG9iLndlYmtpdFNsaWNlKVxyXG5cdFx0XHRyZXR1cm4gYmxvYi53ZWJraXRTbGljZShpbmRleCwgaW5kZXggKyBsZW5ndGgpO1xyXG5cdFx0ZWxzZSBpZiAoYmxvYi5tb3pTbGljZSlcclxuXHRcdFx0cmV0dXJuIGJsb2IubW96U2xpY2UoaW5kZXgsIGluZGV4ICsgbGVuZ3RoKTtcclxuXHRcdGVsc2UgaWYgKGJsb2IubXNTbGljZSlcclxuXHRcdFx0cmV0dXJuIGJsb2IubXNTbGljZShpbmRleCwgaW5kZXggKyBsZW5ndGgpO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gZ2V0RGF0YUhlbHBlcihieXRlTGVuZ3RoLCBieXRlcykge1xyXG5cdFx0dmFyIGRhdGFCdWZmZXIsIGRhdGFBcnJheTtcclxuXHRcdGRhdGFCdWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoYnl0ZUxlbmd0aCk7XHJcblx0XHRkYXRhQXJyYXkgPSBuZXcgVWludDhBcnJheShkYXRhQnVmZmVyKTtcclxuXHRcdGlmIChieXRlcylcclxuXHRcdFx0ZGF0YUFycmF5LnNldChieXRlcywgMCk7XHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHRidWZmZXIgOiBkYXRhQnVmZmVyLFxyXG5cdFx0XHRhcnJheSA6IGRhdGFBcnJheSxcclxuXHRcdFx0dmlldyA6IG5ldyBEYXRhVmlldyhkYXRhQnVmZmVyKVxyXG5cdFx0fTtcclxuXHR9XHJcblxyXG5cdC8vIFJlYWRlcnNcclxuXHRmdW5jdGlvbiBSZWFkZXIoKSB7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBUZXh0UmVhZGVyKHRleHQpIHtcclxuXHRcdHZhciB0aGF0ID0gdGhpcywgYmxvYlJlYWRlcjtcclxuXHJcblx0XHRmdW5jdGlvbiBpbml0KGNhbGxiYWNrLCBvbmVycm9yKSB7XHJcblx0XHRcdHZhciBibG9iID0gbmV3IEJsb2IoWyB0ZXh0IF0sIHtcclxuXHRcdFx0XHR0eXBlIDogVEVYVF9QTEFJTlxyXG5cdFx0XHR9KTtcclxuXHRcdFx0YmxvYlJlYWRlciA9IG5ldyBCbG9iUmVhZGVyKGJsb2IpO1xyXG5cdFx0XHRibG9iUmVhZGVyLmluaXQoZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0dGhhdC5zaXplID0gYmxvYlJlYWRlci5zaXplO1xyXG5cdFx0XHRcdGNhbGxiYWNrKCk7XHJcblx0XHRcdH0sIG9uZXJyb3IpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIHJlYWRVaW50OEFycmF5KGluZGV4LCBsZW5ndGgsIGNhbGxiYWNrLCBvbmVycm9yKSB7XHJcblx0XHRcdGJsb2JSZWFkZXIucmVhZFVpbnQ4QXJyYXkoaW5kZXgsIGxlbmd0aCwgY2FsbGJhY2ssIG9uZXJyb3IpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoYXQuc2l6ZSA9IDA7XHJcblx0XHR0aGF0LmluaXQgPSBpbml0O1xyXG5cdFx0dGhhdC5yZWFkVWludDhBcnJheSA9IHJlYWRVaW50OEFycmF5O1xyXG5cdH1cclxuXHRUZXh0UmVhZGVyLnByb3RvdHlwZSA9IG5ldyBSZWFkZXIoKTtcclxuXHRUZXh0UmVhZGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRleHRSZWFkZXI7XHJcblxyXG5cdGZ1bmN0aW9uIERhdGE2NFVSSVJlYWRlcihkYXRhVVJJKSB7XHJcblx0XHR2YXIgdGhhdCA9IHRoaXMsIGRhdGFTdGFydDtcclxuXHJcblx0XHRmdW5jdGlvbiBpbml0KGNhbGxiYWNrKSB7XHJcblx0XHRcdHZhciBkYXRhRW5kID0gZGF0YVVSSS5sZW5ndGg7XHJcblx0XHRcdHdoaWxlIChkYXRhVVJJLmNoYXJBdChkYXRhRW5kIC0gMSkgPT0gXCI9XCIpXHJcblx0XHRcdFx0ZGF0YUVuZC0tO1xyXG5cdFx0XHRkYXRhU3RhcnQgPSBkYXRhVVJJLmluZGV4T2YoXCIsXCIpICsgMTtcclxuXHRcdFx0dGhhdC5zaXplID0gTWF0aC5mbG9vcigoZGF0YUVuZCAtIGRhdGFTdGFydCkgKiAwLjc1KTtcclxuXHRcdFx0Y2FsbGJhY2soKTtcclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiByZWFkVWludDhBcnJheShpbmRleCwgbGVuZ3RoLCBjYWxsYmFjaykge1xyXG5cdFx0XHR2YXIgaSwgZGF0YSA9IGdldERhdGFIZWxwZXIobGVuZ3RoKTtcclxuXHRcdFx0dmFyIHN0YXJ0ID0gTWF0aC5mbG9vcihpbmRleCAvIDMpICogNDtcclxuXHRcdFx0dmFyIGVuZCA9IE1hdGguY2VpbCgoaW5kZXggKyBsZW5ndGgpIC8gMykgKiA0O1xyXG5cdFx0XHR2YXIgYnl0ZXMgPSBvYmouYXRvYihkYXRhVVJJLnN1YnN0cmluZyhzdGFydCArIGRhdGFTdGFydCwgZW5kICsgZGF0YVN0YXJ0KSk7XHJcblx0XHRcdHZhciBkZWx0YSA9IGluZGV4IC0gTWF0aC5mbG9vcihzdGFydCAvIDQpICogMztcclxuXHRcdFx0Zm9yIChpID0gZGVsdGE7IGkgPCBkZWx0YSArIGxlbmd0aDsgaSsrKVxyXG5cdFx0XHRcdGRhdGEuYXJyYXlbaSAtIGRlbHRhXSA9IGJ5dGVzLmNoYXJDb2RlQXQoaSk7XHJcblx0XHRcdGNhbGxiYWNrKGRhdGEuYXJyYXkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoYXQuc2l6ZSA9IDA7XHJcblx0XHR0aGF0LmluaXQgPSBpbml0O1xyXG5cdFx0dGhhdC5yZWFkVWludDhBcnJheSA9IHJlYWRVaW50OEFycmF5O1xyXG5cdH1cclxuXHREYXRhNjRVUklSZWFkZXIucHJvdG90eXBlID0gbmV3IFJlYWRlcigpO1xyXG5cdERhdGE2NFVSSVJlYWRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBEYXRhNjRVUklSZWFkZXI7XHJcblxyXG5cdGZ1bmN0aW9uIEJsb2JSZWFkZXIoYmxvYikge1xyXG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xyXG5cclxuXHRcdGZ1bmN0aW9uIGluaXQoY2FsbGJhY2spIHtcclxuXHRcdFx0dGhhdC5zaXplID0gYmxvYi5zaXplO1xyXG5cdFx0XHRjYWxsYmFjaygpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIHJlYWRVaW50OEFycmF5KGluZGV4LCBsZW5ndGgsIGNhbGxiYWNrLCBvbmVycm9yKSB7XHJcblx0XHRcdHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xyXG5cdFx0XHRyZWFkZXIub25sb2FkID0gZnVuY3Rpb24oZSkge1xyXG5cdFx0XHRcdGNhbGxiYWNrKG5ldyBVaW50OEFycmF5KGUudGFyZ2V0LnJlc3VsdCkpO1xyXG5cdFx0XHR9O1xyXG5cdFx0XHRyZWFkZXIub25lcnJvciA9IG9uZXJyb3I7XHJcblx0XHRcdHRyeSB7XHJcblx0XHRcdFx0cmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGJsb2JTbGljZShibG9iLCBpbmRleCwgbGVuZ3RoKSk7XHJcblx0XHRcdH0gY2F0Y2ggKGUpIHtcclxuXHRcdFx0XHRvbmVycm9yKGUpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0dGhhdC5zaXplID0gMDtcclxuXHRcdHRoYXQuaW5pdCA9IGluaXQ7XHJcblx0XHR0aGF0LnJlYWRVaW50OEFycmF5ID0gcmVhZFVpbnQ4QXJyYXk7XHJcblx0fVxyXG5cdEJsb2JSZWFkZXIucHJvdG90eXBlID0gbmV3IFJlYWRlcigpO1xyXG5cdEJsb2JSZWFkZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQmxvYlJlYWRlcjtcclxuXHJcblx0Ly8gV3JpdGVyc1xyXG5cclxuXHRmdW5jdGlvbiBXcml0ZXIoKSB7XHJcblx0fVxyXG5cdFdyaXRlci5wcm90b3R5cGUuZ2V0RGF0YSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XHJcblx0XHRjYWxsYmFjayh0aGlzLmRhdGEpO1xyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIFRleHRXcml0ZXIoZW5jb2RpbmcpIHtcclxuXHRcdHZhciB0aGF0ID0gdGhpcywgYmxvYjtcclxuXHJcblx0XHRmdW5jdGlvbiBpbml0KGNhbGxiYWNrKSB7XHJcblx0XHRcdGJsb2IgPSBuZXcgQmxvYihbXSwge1xyXG5cdFx0XHRcdHR5cGUgOiBURVhUX1BMQUlOXHJcblx0XHRcdH0pO1xyXG5cdFx0XHRjYWxsYmFjaygpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIHdyaXRlVWludDhBcnJheShhcnJheSwgY2FsbGJhY2spIHtcclxuXHRcdFx0YmxvYiA9IG5ldyBCbG9iKFsgYmxvYiwgYXBwZW5kQUJWaWV3U3VwcG9ydGVkID8gYXJyYXkgOiBhcnJheS5idWZmZXIgXSwge1xyXG5cdFx0XHRcdHR5cGUgOiBURVhUX1BMQUlOXHJcblx0XHRcdH0pO1xyXG5cdFx0XHRjYWxsYmFjaygpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIGdldERhdGEoY2FsbGJhY2ssIG9uZXJyb3IpIHtcclxuXHRcdFx0dmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XHJcblx0XHRcdHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbihlKSB7XHJcblx0XHRcdFx0Y2FsbGJhY2soZS50YXJnZXQucmVzdWx0KTtcclxuXHRcdFx0fTtcclxuXHRcdFx0cmVhZGVyLm9uZXJyb3IgPSBvbmVycm9yO1xyXG5cdFx0XHRyZWFkZXIucmVhZEFzVGV4dChibG9iLCBlbmNvZGluZyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhhdC5pbml0ID0gaW5pdDtcclxuXHRcdHRoYXQud3JpdGVVaW50OEFycmF5ID0gd3JpdGVVaW50OEFycmF5O1xyXG5cdFx0dGhhdC5nZXREYXRhID0gZ2V0RGF0YTtcclxuXHR9XHJcblx0VGV4dFdyaXRlci5wcm90b3R5cGUgPSBuZXcgV3JpdGVyKCk7XHJcblx0VGV4dFdyaXRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUZXh0V3JpdGVyO1xyXG5cclxuXHRmdW5jdGlvbiBEYXRhNjRVUklXcml0ZXIoY29udGVudFR5cGUpIHtcclxuXHRcdHZhciB0aGF0ID0gdGhpcywgZGF0YSA9IFwiXCIsIHBlbmRpbmcgPSBcIlwiO1xyXG5cclxuXHRcdGZ1bmN0aW9uIGluaXQoY2FsbGJhY2spIHtcclxuXHRcdFx0ZGF0YSArPSBcImRhdGE6XCIgKyAoY29udGVudFR5cGUgfHwgXCJcIikgKyBcIjtiYXNlNjQsXCI7XHJcblx0XHRcdGNhbGxiYWNrKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gd3JpdGVVaW50OEFycmF5KGFycmF5LCBjYWxsYmFjaykge1xyXG5cdFx0XHR2YXIgaSwgZGVsdGEgPSBwZW5kaW5nLmxlbmd0aCwgZGF0YVN0cmluZyA9IHBlbmRpbmc7XHJcblx0XHRcdHBlbmRpbmcgPSBcIlwiO1xyXG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgKE1hdGguZmxvb3IoKGRlbHRhICsgYXJyYXkubGVuZ3RoKSAvIDMpICogMykgLSBkZWx0YTsgaSsrKVxyXG5cdFx0XHRcdGRhdGFTdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShhcnJheVtpXSk7XHJcblx0XHRcdGZvciAoOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspXHJcblx0XHRcdFx0cGVuZGluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGFycmF5W2ldKTtcclxuXHRcdFx0aWYgKGRhdGFTdHJpbmcubGVuZ3RoID4gMilcclxuXHRcdFx0XHRkYXRhICs9IG9iai5idG9hKGRhdGFTdHJpbmcpO1xyXG5cdFx0XHRlbHNlXHJcblx0XHRcdFx0cGVuZGluZyA9IGRhdGFTdHJpbmc7XHJcblx0XHRcdGNhbGxiYWNrKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gZ2V0RGF0YShjYWxsYmFjaykge1xyXG5cdFx0XHRjYWxsYmFjayhkYXRhICsgb2JqLmJ0b2EocGVuZGluZykpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoYXQuaW5pdCA9IGluaXQ7XHJcblx0XHR0aGF0LndyaXRlVWludDhBcnJheSA9IHdyaXRlVWludDhBcnJheTtcclxuXHRcdHRoYXQuZ2V0RGF0YSA9IGdldERhdGE7XHJcblx0fVxyXG5cdERhdGE2NFVSSVdyaXRlci5wcm90b3R5cGUgPSBuZXcgV3JpdGVyKCk7XHJcblx0RGF0YTY0VVJJV3JpdGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IERhdGE2NFVSSVdyaXRlcjtcclxuXHJcblx0ZnVuY3Rpb24gQmxvYldyaXRlcihjb250ZW50VHlwZSkge1xyXG5cdFx0dmFyIGJsb2IsIHRoYXQgPSB0aGlzO1xyXG5cclxuXHRcdGZ1bmN0aW9uIGluaXQoY2FsbGJhY2spIHtcclxuXHRcdFx0YmxvYiA9IG5ldyBCbG9iKFtdLCB7XHJcblx0XHRcdFx0dHlwZSA6IGNvbnRlbnRUeXBlXHJcblx0XHRcdH0pO1xyXG5cdFx0XHRjYWxsYmFjaygpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIHdyaXRlVWludDhBcnJheShhcnJheSwgY2FsbGJhY2spIHtcclxuXHRcdFx0YmxvYiA9IG5ldyBCbG9iKFsgYmxvYiwgYXBwZW5kQUJWaWV3U3VwcG9ydGVkID8gYXJyYXkgOiBhcnJheS5idWZmZXIgXSwge1xyXG5cdFx0XHRcdHR5cGUgOiBjb250ZW50VHlwZVxyXG5cdFx0XHR9KTtcclxuXHRcdFx0Y2FsbGJhY2soKTtcclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBnZXREYXRhKGNhbGxiYWNrKSB7XHJcblx0XHRcdGNhbGxiYWNrKGJsb2IpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoYXQuaW5pdCA9IGluaXQ7XHJcblx0XHR0aGF0LndyaXRlVWludDhBcnJheSA9IHdyaXRlVWludDhBcnJheTtcclxuXHRcdHRoYXQuZ2V0RGF0YSA9IGdldERhdGE7XHJcblx0fVxyXG5cdEJsb2JXcml0ZXIucHJvdG90eXBlID0gbmV3IFdyaXRlcigpO1xyXG5cdEJsb2JXcml0ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQmxvYldyaXRlcjtcclxuXHJcblx0LyoqXHJcblx0ICogaW5mbGF0ZS9kZWZsYXRlIGNvcmUgZnVuY3Rpb25zXHJcblx0ICogQHBhcmFtIHdvcmtlciB7V29ya2VyfSB3ZWIgd29ya2VyIGZvciB0aGUgdGFzay5cclxuXHQgKiBAcGFyYW0gaW5pdGlhbE1lc3NhZ2Uge09iamVjdH0gaW5pdGlhbCBtZXNzYWdlIHRvIGJlIHNlbnQgdG8gdGhlIHdvcmtlci4gc2hvdWxkIGNvbnRhaW5cclxuXHQgKiAgIHNuKHNlcmlhbCBudW1iZXIgZm9yIGRpc3Rpbmd1aXNoaW5nIG11bHRpcGxlIHRhc2tzIHNlbnQgdG8gdGhlIHdvcmtlciksIGFuZCBjb2RlY0NsYXNzLlxyXG5cdCAqICAgVGhpcyBmdW5jdGlvbiBtYXkgYWRkIG1vcmUgcHJvcGVydGllcyBiZWZvcmUgc2VuZGluZy5cclxuXHQgKi9cclxuXHRmdW5jdGlvbiBsYXVuY2hXb3JrZXJQcm9jZXNzKHdvcmtlciwgaW5pdGlhbE1lc3NhZ2UsIHJlYWRlciwgd3JpdGVyLCBvZmZzZXQsIHNpemUsIG9ucHJvZ3Jlc3MsIG9uZW5kLCBvbnJlYWRlcnJvciwgb253cml0ZWVycm9yKSB7XHJcblx0XHR2YXIgY2h1bmtJbmRleCA9IDAsIGluZGV4LCBvdXRwdXRTaXplLCBzbiA9IGluaXRpYWxNZXNzYWdlLnNuLCBjcmM7XHJcblxyXG5cdFx0ZnVuY3Rpb24gb25mbHVzaCgpIHtcclxuXHRcdFx0d29ya2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBvbm1lc3NhZ2UsIGZhbHNlKTtcclxuXHRcdFx0b25lbmQob3V0cHV0U2l6ZSwgY3JjKTtcclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBvbm1lc3NhZ2UoZXZlbnQpIHtcclxuXHRcdFx0dmFyIG1lc3NhZ2UgPSBldmVudC5kYXRhLCBkYXRhID0gbWVzc2FnZS5kYXRhLCBlcnIgPSBtZXNzYWdlLmVycm9yO1xyXG5cdFx0XHRpZiAoZXJyKSB7XHJcblx0XHRcdFx0ZXJyLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJ0Vycm9yOiAnICsgdGhpcy5tZXNzYWdlOyB9O1xyXG5cdFx0XHRcdG9ucmVhZGVycm9yKGVycik7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChtZXNzYWdlLnNuICE9PSBzbilcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdGlmICh0eXBlb2YgbWVzc2FnZS5jb2RlY1RpbWUgPT09ICdudW1iZXInKVxyXG5cdFx0XHRcdHdvcmtlci5jb2RlY1RpbWUgKz0gbWVzc2FnZS5jb2RlY1RpbWU7IC8vIHNob3VsZCBiZSBiZWZvcmUgb25mbHVzaCgpXHJcblx0XHRcdGlmICh0eXBlb2YgbWVzc2FnZS5jcmNUaW1lID09PSAnbnVtYmVyJylcclxuXHRcdFx0XHR3b3JrZXIuY3JjVGltZSArPSBtZXNzYWdlLmNyY1RpbWU7XHJcblxyXG5cdFx0XHRzd2l0Y2ggKG1lc3NhZ2UudHlwZSkge1xyXG5cdFx0XHRcdGNhc2UgJ2FwcGVuZCc6XHJcblx0XHRcdFx0XHRpZiAoZGF0YSkge1xyXG5cdFx0XHRcdFx0XHRvdXRwdXRTaXplICs9IGRhdGEubGVuZ3RoO1xyXG5cdFx0XHRcdFx0XHR3cml0ZXIud3JpdGVVaW50OEFycmF5KGRhdGEsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0XHRcdHN0ZXAoKTtcclxuXHRcdFx0XHRcdFx0fSwgb253cml0ZWVycm9yKTtcclxuXHRcdFx0XHRcdH0gZWxzZVxyXG5cdFx0XHRcdFx0XHRzdGVwKCk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRjYXNlICdmbHVzaCc6XHJcblx0XHRcdFx0XHRjcmMgPSBtZXNzYWdlLmNyYztcclxuXHRcdFx0XHRcdGlmIChkYXRhKSB7XHJcblx0XHRcdFx0XHRcdG91dHB1dFNpemUgKz0gZGF0YS5sZW5ndGg7XHJcblx0XHRcdFx0XHRcdHdyaXRlci53cml0ZVVpbnQ4QXJyYXkoZGF0YSwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHRcdFx0b25mbHVzaCgpO1xyXG5cdFx0XHRcdFx0XHR9LCBvbndyaXRlZXJyb3IpO1xyXG5cdFx0XHRcdFx0fSBlbHNlXHJcblx0XHRcdFx0XHRcdG9uZmx1c2goKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdGNhc2UgJ3Byb2dyZXNzJzpcclxuXHRcdFx0XHRcdGlmIChvbnByb2dyZXNzKVxyXG5cdFx0XHRcdFx0XHRvbnByb2dyZXNzKGluZGV4ICsgbWVzc2FnZS5sb2FkZWQsIHNpemUpO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0Y2FzZSAnaW1wb3J0U2NyaXB0cyc6IC8vbm8gbmVlZCB0byBoYW5kbGUgaGVyZVxyXG5cdFx0XHRcdGNhc2UgJ25ld1Rhc2snOlxyXG5cdFx0XHRcdGNhc2UgJ2VjaG8nOlxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0ZGVmYXVsdDpcclxuXHRcdFx0XHRcdGNvbnNvbGUud2FybignemlwLmpzOmxhdW5jaFdvcmtlclByb2Nlc3M6IHVua25vd24gbWVzc2FnZTogJywgbWVzc2FnZSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBzdGVwKCkge1xyXG5cdFx0XHRpbmRleCA9IGNodW5rSW5kZXggKiBDSFVOS19TSVpFO1xyXG5cdFx0XHQvLyB1c2UgYDw9YCBpbnN0ZWFkIG9mIGA8YCwgYmVjYXVzZSBgc2l6ZWAgbWF5IGJlIDAuXHJcblx0XHRcdGlmIChpbmRleCA8PSBzaXplKSB7XHJcblx0XHRcdFx0cmVhZGVyLnJlYWRVaW50OEFycmF5KG9mZnNldCArIGluZGV4LCBNYXRoLm1pbihDSFVOS19TSVpFLCBzaXplIC0gaW5kZXgpLCBmdW5jdGlvbihhcnJheSkge1xyXG5cdFx0XHRcdFx0aWYgKG9ucHJvZ3Jlc3MpXHJcblx0XHRcdFx0XHRcdG9ucHJvZ3Jlc3MoaW5kZXgsIHNpemUpO1xyXG5cdFx0XHRcdFx0dmFyIG1zZyA9IGluZGV4ID09PSAwID8gaW5pdGlhbE1lc3NhZ2UgOiB7c24gOiBzbn07XHJcblx0XHRcdFx0XHRtc2cudHlwZSA9ICdhcHBlbmQnO1xyXG5cdFx0XHRcdFx0bXNnLmRhdGEgPSBhcnJheTtcclxuXHJcblx0XHRcdFx0XHQvLyBwb3N0aW5nIGEgbWVzc2FnZSB3aXRoIHRyYW5zZmVyYWJsZXMgd2lsbCBmYWlsIG9uIElFMTBcclxuXHRcdFx0XHRcdHRyeSB7XHJcblx0XHRcdFx0XHRcdHdvcmtlci5wb3N0TWVzc2FnZShtc2csIFthcnJheS5idWZmZXJdKTtcclxuXHRcdFx0XHRcdH0gY2F0Y2goZXgpIHtcclxuXHRcdFx0XHRcdFx0d29ya2VyLnBvc3RNZXNzYWdlKG1zZyk7IC8vIHJldHJ5IHdpdGhvdXQgdHJhbnNmZXJhYmxlc1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0Y2h1bmtJbmRleCsrO1xyXG5cdFx0XHRcdH0sIG9ucmVhZGVycm9yKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR3b3JrZXIucG9zdE1lc3NhZ2Uoe1xyXG5cdFx0XHRcdFx0c246IHNuLFxyXG5cdFx0XHRcdFx0dHlwZTogJ2ZsdXNoJ1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0b3V0cHV0U2l6ZSA9IDA7XHJcblx0XHR3b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIG9ubWVzc2FnZSwgZmFsc2UpO1xyXG5cdFx0c3RlcCgpO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gbGF1bmNoUHJvY2Vzcyhwcm9jZXNzLCByZWFkZXIsIHdyaXRlciwgb2Zmc2V0LCBzaXplLCBjcmNUeXBlLCBvbnByb2dyZXNzLCBvbmVuZCwgb25yZWFkZXJyb3IsIG9ud3JpdGVlcnJvcikge1xyXG5cdFx0dmFyIGNodW5rSW5kZXggPSAwLCBpbmRleCwgb3V0cHV0U2l6ZSA9IDAsXHJcblx0XHRcdGNyY0lucHV0ID0gY3JjVHlwZSA9PT0gJ2lucHV0JyxcclxuXHRcdFx0Y3JjT3V0cHV0ID0gY3JjVHlwZSA9PT0gJ291dHB1dCcsXHJcblx0XHRcdGNyYyA9IG5ldyBDcmMzMigpO1xyXG5cdFx0ZnVuY3Rpb24gc3RlcCgpIHtcclxuXHRcdFx0dmFyIG91dHB1dERhdGE7XHJcblx0XHRcdGluZGV4ID0gY2h1bmtJbmRleCAqIENIVU5LX1NJWkU7XHJcblx0XHRcdGlmIChpbmRleCA8IHNpemUpXHJcblx0XHRcdFx0cmVhZGVyLnJlYWRVaW50OEFycmF5KG9mZnNldCArIGluZGV4LCBNYXRoLm1pbihDSFVOS19TSVpFLCBzaXplIC0gaW5kZXgpLCBmdW5jdGlvbihpbnB1dERhdGEpIHtcclxuXHRcdFx0XHRcdHZhciBvdXRwdXREYXRhO1xyXG5cdFx0XHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRcdFx0b3V0cHV0RGF0YSA9IHByb2Nlc3MuYXBwZW5kKGlucHV0RGF0YSwgZnVuY3Rpb24obG9hZGVkKSB7XHJcblx0XHRcdFx0XHRcdFx0aWYgKG9ucHJvZ3Jlc3MpXHJcblx0XHRcdFx0XHRcdFx0XHRvbnByb2dyZXNzKGluZGV4ICsgbG9hZGVkLCBzaXplKTtcclxuXHRcdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0XHR9IGNhdGNoIChlKSB7XHJcblx0XHRcdFx0XHRcdG9ucmVhZGVycm9yKGUpO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZiAob3V0cHV0RGF0YSkge1xyXG5cdFx0XHRcdFx0XHRvdXRwdXRTaXplICs9IG91dHB1dERhdGEubGVuZ3RoO1xyXG5cdFx0XHRcdFx0XHR3cml0ZXIud3JpdGVVaW50OEFycmF5KG91dHB1dERhdGEsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0XHRcdGNodW5rSW5kZXgrKztcclxuXHRcdFx0XHRcdFx0XHRzZXRUaW1lb3V0KHN0ZXAsIDEpO1xyXG5cdFx0XHRcdFx0XHR9LCBvbndyaXRlZXJyb3IpO1xyXG5cdFx0XHRcdFx0XHRpZiAoY3JjT3V0cHV0KVxyXG5cdFx0XHRcdFx0XHRcdGNyYy5hcHBlbmQob3V0cHV0RGF0YSk7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRjaHVua0luZGV4Kys7XHJcblx0XHRcdFx0XHRcdHNldFRpbWVvdXQoc3RlcCwgMSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZiAoY3JjSW5wdXQpXHJcblx0XHRcdFx0XHRcdGNyYy5hcHBlbmQoaW5wdXREYXRhKTtcclxuXHRcdFx0XHRcdGlmIChvbnByb2dyZXNzKVxyXG5cdFx0XHRcdFx0XHRvbnByb2dyZXNzKGluZGV4LCBzaXplKTtcclxuXHRcdFx0XHR9LCBvbnJlYWRlcnJvcik7XHJcblx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdHRyeSB7XHJcblx0XHRcdFx0XHRvdXRwdXREYXRhID0gcHJvY2Vzcy5mbHVzaCgpO1xyXG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHtcclxuXHRcdFx0XHRcdG9ucmVhZGVycm9yKGUpO1xyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiAob3V0cHV0RGF0YSkge1xyXG5cdFx0XHRcdFx0aWYgKGNyY091dHB1dClcclxuXHRcdFx0XHRcdFx0Y3JjLmFwcGVuZChvdXRwdXREYXRhKTtcclxuXHRcdFx0XHRcdG91dHB1dFNpemUgKz0gb3V0cHV0RGF0YS5sZW5ndGg7XHJcblx0XHRcdFx0XHR3cml0ZXIud3JpdGVVaW50OEFycmF5KG91dHB1dERhdGEsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0XHRvbmVuZChvdXRwdXRTaXplLCBjcmMuZ2V0KCkpO1xyXG5cdFx0XHRcdFx0fSwgb253cml0ZWVycm9yKTtcclxuXHRcdFx0XHR9IGVsc2VcclxuXHRcdFx0XHRcdG9uZW5kKG91dHB1dFNpemUsIGNyYy5nZXQoKSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRzdGVwKCk7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBpbmZsYXRlKHdvcmtlciwgc24sIHJlYWRlciwgd3JpdGVyLCBvZmZzZXQsIHNpemUsIGNvbXB1dGVDcmMzMiwgb25lbmQsIG9ucHJvZ3Jlc3MsIG9ucmVhZGVycm9yLCBvbndyaXRlZXJyb3IpIHtcclxuXHRcdHZhciBjcmNUeXBlID0gY29tcHV0ZUNyYzMyID8gJ291dHB1dCcgOiAnbm9uZSc7XHJcblx0XHRpZiAob2JqLnppcC51c2VXZWJXb3JrZXJzKSB7XHJcblx0XHRcdHZhciBpbml0aWFsTWVzc2FnZSA9IHtcclxuXHRcdFx0XHRzbjogc24sXHJcblx0XHRcdFx0Y29kZWNDbGFzczogJ0luZmxhdGVyJyxcclxuXHRcdFx0XHRjcmNUeXBlOiBjcmNUeXBlLFxyXG5cdFx0XHR9O1xyXG5cdFx0XHRsYXVuY2hXb3JrZXJQcm9jZXNzKHdvcmtlciwgaW5pdGlhbE1lc3NhZ2UsIHJlYWRlciwgd3JpdGVyLCBvZmZzZXQsIHNpemUsIG9ucHJvZ3Jlc3MsIG9uZW5kLCBvbnJlYWRlcnJvciwgb253cml0ZWVycm9yKTtcclxuXHRcdH0gZWxzZVxyXG5cdFx0XHRsYXVuY2hQcm9jZXNzKG5ldyBvYmouemlwLkluZmxhdGVyKCksIHJlYWRlciwgd3JpdGVyLCBvZmZzZXQsIHNpemUsIGNyY1R5cGUsIG9ucHJvZ3Jlc3MsIG9uZW5kLCBvbnJlYWRlcnJvciwgb253cml0ZWVycm9yKTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGRlZmxhdGUod29ya2VyLCBzbiwgcmVhZGVyLCB3cml0ZXIsIGxldmVsLCBvbmVuZCwgb25wcm9ncmVzcywgb25yZWFkZXJyb3IsIG9ud3JpdGVlcnJvcikge1xyXG5cdFx0dmFyIGNyY1R5cGUgPSAnaW5wdXQnO1xyXG5cdFx0aWYgKG9iai56aXAudXNlV2ViV29ya2Vycykge1xyXG5cdFx0XHR2YXIgaW5pdGlhbE1lc3NhZ2UgPSB7XHJcblx0XHRcdFx0c246IHNuLFxyXG5cdFx0XHRcdG9wdGlvbnM6IHtsZXZlbDogbGV2ZWx9LFxyXG5cdFx0XHRcdGNvZGVjQ2xhc3M6ICdEZWZsYXRlcicsXHJcblx0XHRcdFx0Y3JjVHlwZTogY3JjVHlwZSxcclxuXHRcdFx0fTtcclxuXHRcdFx0bGF1bmNoV29ya2VyUHJvY2Vzcyh3b3JrZXIsIGluaXRpYWxNZXNzYWdlLCByZWFkZXIsIHdyaXRlciwgMCwgcmVhZGVyLnNpemUsIG9ucHJvZ3Jlc3MsIG9uZW5kLCBvbnJlYWRlcnJvciwgb253cml0ZWVycm9yKTtcclxuXHRcdH0gZWxzZVxyXG5cdFx0XHRsYXVuY2hQcm9jZXNzKG5ldyBvYmouemlwLkRlZmxhdGVyKCksIHJlYWRlciwgd3JpdGVyLCAwLCByZWFkZXIuc2l6ZSwgY3JjVHlwZSwgb25wcm9ncmVzcywgb25lbmQsIG9ucmVhZGVycm9yLCBvbndyaXRlZXJyb3IpO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gY29weSh3b3JrZXIsIHNuLCByZWFkZXIsIHdyaXRlciwgb2Zmc2V0LCBzaXplLCBjb21wdXRlQ3JjMzIsIG9uZW5kLCBvbnByb2dyZXNzLCBvbnJlYWRlcnJvciwgb253cml0ZWVycm9yKSB7XHJcblx0XHR2YXIgY3JjVHlwZSA9ICdpbnB1dCc7XHJcblx0XHRpZiAob2JqLnppcC51c2VXZWJXb3JrZXJzICYmIGNvbXB1dGVDcmMzMikge1xyXG5cdFx0XHR2YXIgaW5pdGlhbE1lc3NhZ2UgPSB7XHJcblx0XHRcdFx0c246IHNuLFxyXG5cdFx0XHRcdGNvZGVjQ2xhc3M6ICdOT09QJyxcclxuXHRcdFx0XHRjcmNUeXBlOiBjcmNUeXBlLFxyXG5cdFx0XHR9O1xyXG5cdFx0XHRsYXVuY2hXb3JrZXJQcm9jZXNzKHdvcmtlciwgaW5pdGlhbE1lc3NhZ2UsIHJlYWRlciwgd3JpdGVyLCBvZmZzZXQsIHNpemUsIG9ucHJvZ3Jlc3MsIG9uZW5kLCBvbnJlYWRlcnJvciwgb253cml0ZWVycm9yKTtcclxuXHRcdH0gZWxzZVxyXG5cdFx0XHRsYXVuY2hQcm9jZXNzKG5ldyBOT09QKCksIHJlYWRlciwgd3JpdGVyLCBvZmZzZXQsIHNpemUsIGNyY1R5cGUsIG9ucHJvZ3Jlc3MsIG9uZW5kLCBvbnJlYWRlcnJvciwgb253cml0ZWVycm9yKTtcclxuXHR9XHJcblxyXG5cdC8vIFppcFJlYWRlclxyXG5cclxuXHRmdW5jdGlvbiBkZWNvZGVBU0NJSShzdHIpIHtcclxuXHRcdHZhciBpLCBvdXQgPSBcIlwiLCBjaGFyQ29kZSwgZXh0ZW5kZWRBU0NJSSA9IFsgJ1xcdTAwQzcnLCAnXFx1MDBGQycsICdcXHUwMEU5JywgJ1xcdTAwRTInLCAnXFx1MDBFNCcsICdcXHUwMEUwJywgJ1xcdTAwRTUnLCAnXFx1MDBFNycsICdcXHUwMEVBJywgJ1xcdTAwRUInLFxyXG5cdFx0XHRcdCdcXHUwMEU4JywgJ1xcdTAwRUYnLCAnXFx1MDBFRScsICdcXHUwMEVDJywgJ1xcdTAwQzQnLCAnXFx1MDBDNScsICdcXHUwMEM5JywgJ1xcdTAwRTYnLCAnXFx1MDBDNicsICdcXHUwMEY0JywgJ1xcdTAwRjYnLCAnXFx1MDBGMicsICdcXHUwMEZCJywgJ1xcdTAwRjknLFxyXG5cdFx0XHRcdCdcXHUwMEZGJywgJ1xcdTAwRDYnLCAnXFx1MDBEQycsICdcXHUwMEY4JywgJ1xcdTAwQTMnLCAnXFx1MDBEOCcsICdcXHUwMEQ3JywgJ1xcdTAxOTInLCAnXFx1MDBFMScsICdcXHUwMEVEJywgJ1xcdTAwRjMnLCAnXFx1MDBGQScsICdcXHUwMEYxJywgJ1xcdTAwRDEnLFxyXG5cdFx0XHRcdCdcXHUwMEFBJywgJ1xcdTAwQkEnLCAnXFx1MDBCRicsICdcXHUwMEFFJywgJ1xcdTAwQUMnLCAnXFx1MDBCRCcsICdcXHUwMEJDJywgJ1xcdTAwQTEnLCAnXFx1MDBBQicsICdcXHUwMEJCJywgJ18nLCAnXycsICdfJywgJ1xcdTAwQTYnLCAnXFx1MDBBNicsXHJcblx0XHRcdFx0J1xcdTAwQzEnLCAnXFx1MDBDMicsICdcXHUwMEMwJywgJ1xcdTAwQTknLCAnXFx1MDBBNicsICdcXHUwMEE2JywgJysnLCAnKycsICdcXHUwMEEyJywgJ1xcdTAwQTUnLCAnKycsICcrJywgJy0nLCAnLScsICcrJywgJy0nLCAnKycsICdcXHUwMEUzJyxcclxuXHRcdFx0XHQnXFx1MDBDMycsICcrJywgJysnLCAnLScsICctJywgJ1xcdTAwQTYnLCAnLScsICcrJywgJ1xcdTAwQTQnLCAnXFx1MDBGMCcsICdcXHUwMEQwJywgJ1xcdTAwQ0EnLCAnXFx1MDBDQicsICdcXHUwMEM4JywgJ2knLCAnXFx1MDBDRCcsICdcXHUwMENFJyxcclxuXHRcdFx0XHQnXFx1MDBDRicsICcrJywgJysnLCAnXycsICdfJywgJ1xcdTAwQTYnLCAnXFx1MDBDQycsICdfJywgJ1xcdTAwRDMnLCAnXFx1MDBERicsICdcXHUwMEQ0JywgJ1xcdTAwRDInLCAnXFx1MDBGNScsICdcXHUwMEQ1JywgJ1xcdTAwQjUnLCAnXFx1MDBGRScsXHJcblx0XHRcdFx0J1xcdTAwREUnLCAnXFx1MDBEQScsICdcXHUwMERCJywgJ1xcdTAwRDknLCAnXFx1MDBGRCcsICdcXHUwMEREJywgJ1xcdTAwQUYnLCAnXFx1MDBCNCcsICdcXHUwMEFEJywgJ1xcdTAwQjEnLCAnXycsICdcXHUwMEJFJywgJ1xcdTAwQjYnLCAnXFx1MDBBNycsXHJcblx0XHRcdFx0J1xcdTAwRjcnLCAnXFx1MDBCOCcsICdcXHUwMEIwJywgJ1xcdTAwQTgnLCAnXFx1MDBCNycsICdcXHUwMEI5JywgJ1xcdTAwQjMnLCAnXFx1MDBCMicsICdfJywgJyAnIF07XHJcblx0XHRmb3IgKGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGNoYXJDb2RlID0gc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGO1xyXG5cdFx0XHRpZiAoY2hhckNvZGUgPiAxMjcpXHJcblx0XHRcdFx0b3V0ICs9IGV4dGVuZGVkQVNDSUlbY2hhckNvZGUgLSAxMjhdO1xyXG5cdFx0XHRlbHNlXHJcblx0XHRcdFx0b3V0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG91dDtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGRlY29kZVVURjgoc3RyaW5nKSB7XHJcblx0XHRyZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZShzdHJpbmcpKTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGdldFN0cmluZyhieXRlcykge1xyXG5cdFx0dmFyIGksIHN0ciA9IFwiXCI7XHJcblx0XHRmb3IgKGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspXHJcblx0XHRcdHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldKTtcclxuXHRcdHJldHVybiBzdHI7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBnZXREYXRlKHRpbWVSYXcpIHtcclxuXHRcdHZhciBkYXRlID0gKHRpbWVSYXcgJiAweGZmZmYwMDAwKSA+PiAxNiwgdGltZSA9IHRpbWVSYXcgJiAweDAwMDBmZmZmO1xyXG5cdFx0dHJ5IHtcclxuXHRcdFx0cmV0dXJuIG5ldyBEYXRlKDE5ODAgKyAoKGRhdGUgJiAweEZFMDApID4+IDkpLCAoKGRhdGUgJiAweDAxRTApID4+IDUpIC0gMSwgZGF0ZSAmIDB4MDAxRiwgKHRpbWUgJiAweEY4MDApID4+IDExLCAodGltZSAmIDB4MDdFMCkgPj4gNSxcclxuXHRcdFx0XHRcdCh0aW1lICYgMHgwMDFGKSAqIDIsIDApO1xyXG5cdFx0fSBjYXRjaCAoZSkge1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gcmVhZENvbW1vbkhlYWRlcihlbnRyeSwgZGF0YSwgaW5kZXgsIGNlbnRyYWxEaXJlY3RvcnksIG9uZXJyb3IpIHtcclxuXHRcdGVudHJ5LnZlcnNpb24gPSBkYXRhLnZpZXcuZ2V0VWludDE2KGluZGV4LCB0cnVlKTtcclxuXHRcdGVudHJ5LmJpdEZsYWcgPSBkYXRhLnZpZXcuZ2V0VWludDE2KGluZGV4ICsgMiwgdHJ1ZSk7XHJcblx0XHRlbnRyeS5jb21wcmVzc2lvbk1ldGhvZCA9IGRhdGEudmlldy5nZXRVaW50MTYoaW5kZXggKyA0LCB0cnVlKTtcclxuXHRcdGVudHJ5Lmxhc3RNb2REYXRlUmF3ID0gZGF0YS52aWV3LmdldFVpbnQzMihpbmRleCArIDYsIHRydWUpO1xyXG5cdFx0ZW50cnkubGFzdE1vZERhdGUgPSBnZXREYXRlKGVudHJ5Lmxhc3RNb2REYXRlUmF3KTtcclxuXHRcdGlmICgoZW50cnkuYml0RmxhZyAmIDB4MDEpID09PSAweDAxKSB7XHJcblx0XHRcdG9uZXJyb3IoRVJSX0VOQ1JZUFRFRCk7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHRcdGlmIChjZW50cmFsRGlyZWN0b3J5IHx8IChlbnRyeS5iaXRGbGFnICYgMHgwMDA4KSAhPSAweDAwMDgpIHtcclxuXHRcdFx0ZW50cnkuY3JjMzIgPSBkYXRhLnZpZXcuZ2V0VWludDMyKGluZGV4ICsgMTAsIHRydWUpO1xyXG5cdFx0XHRlbnRyeS5jb21wcmVzc2VkU2l6ZSA9IGRhdGEudmlldy5nZXRVaW50MzIoaW5kZXggKyAxNCwgdHJ1ZSk7XHJcblx0XHRcdGVudHJ5LnVuY29tcHJlc3NlZFNpemUgPSBkYXRhLnZpZXcuZ2V0VWludDMyKGluZGV4ICsgMTgsIHRydWUpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGVudHJ5LmNvbXByZXNzZWRTaXplID09PSAweEZGRkZGRkZGIHx8IGVudHJ5LnVuY29tcHJlc3NlZFNpemUgPT09IDB4RkZGRkZGRkYpIHtcclxuXHRcdFx0b25lcnJvcihFUlJfWklQNjQpO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblx0XHRlbnRyeS5maWxlbmFtZUxlbmd0aCA9IGRhdGEudmlldy5nZXRVaW50MTYoaW5kZXggKyAyMiwgdHJ1ZSk7XHJcblx0XHRlbnRyeS5leHRyYUZpZWxkTGVuZ3RoID0gZGF0YS52aWV3LmdldFVpbnQxNihpbmRleCArIDI0LCB0cnVlKTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGNyZWF0ZVppcFJlYWRlcihyZWFkZXIsIGNhbGxiYWNrLCBvbmVycm9yKSB7XHJcblx0XHR2YXIgaW5mbGF0ZVNOID0gMDtcclxuXHJcblx0XHRmdW5jdGlvbiBFbnRyeSgpIHtcclxuXHRcdH1cclxuXHJcblx0XHRFbnRyeS5wcm90b3R5cGUuZ2V0RGF0YSA9IGZ1bmN0aW9uKHdyaXRlciwgb25lbmQsIG9ucHJvZ3Jlc3MsIGNoZWNrQ3JjMzIpIHtcclxuXHRcdFx0dmFyIHRoYXQgPSB0aGlzO1xyXG5cclxuXHRcdFx0ZnVuY3Rpb24gdGVzdENyYzMyKGNyYzMyKSB7XHJcblx0XHRcdFx0dmFyIGRhdGFDcmMzMiA9IGdldERhdGFIZWxwZXIoNCk7XHJcblx0XHRcdFx0ZGF0YUNyYzMyLnZpZXcuc2V0VWludDMyKDAsIGNyYzMyKTtcclxuXHRcdFx0XHRyZXR1cm4gdGhhdC5jcmMzMiA9PSBkYXRhQ3JjMzIudmlldy5nZXRVaW50MzIoMCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZ1bmN0aW9uIGdldFdyaXRlckRhdGEodW5jb21wcmVzc2VkU2l6ZSwgY3JjMzIpIHtcclxuXHRcdFx0XHRpZiAoY2hlY2tDcmMzMiAmJiAhdGVzdENyYzMyKGNyYzMyKSlcclxuXHRcdFx0XHRcdG9uZXJyb3IoRVJSX0NSQyk7XHJcblx0XHRcdFx0ZWxzZVxyXG5cdFx0XHRcdFx0d3JpdGVyLmdldERhdGEoZnVuY3Rpb24oZGF0YSkge1xyXG5cdFx0XHRcdFx0XHRvbmVuZChkYXRhKTtcclxuXHRcdFx0XHRcdH0pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmdW5jdGlvbiBvbnJlYWRlcnJvcihlcnIpIHtcclxuXHRcdFx0XHRvbmVycm9yKGVyciB8fCBFUlJfUkVBRF9EQVRBKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0ZnVuY3Rpb24gb253cml0ZWVycm9yKGVycikge1xyXG5cdFx0XHRcdG9uZXJyb3IoZXJyIHx8IEVSUl9XUklURV9EQVRBKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmVhZGVyLnJlYWRVaW50OEFycmF5KHRoYXQub2Zmc2V0LCAzMCwgZnVuY3Rpb24oYnl0ZXMpIHtcclxuXHRcdFx0XHR2YXIgZGF0YSA9IGdldERhdGFIZWxwZXIoYnl0ZXMubGVuZ3RoLCBieXRlcyksIGRhdGFPZmZzZXQ7XHJcblx0XHRcdFx0aWYgKGRhdGEudmlldy5nZXRVaW50MzIoMCkgIT0gMHg1MDRiMDMwNCkge1xyXG5cdFx0XHRcdFx0b25lcnJvcihFUlJfQkFEX0ZPUk1BVCk7XHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJlYWRDb21tb25IZWFkZXIodGhhdCwgZGF0YSwgNCwgZmFsc2UsIG9uZXJyb3IpO1xyXG5cdFx0XHRcdGRhdGFPZmZzZXQgPSB0aGF0Lm9mZnNldCArIDMwICsgdGhhdC5maWxlbmFtZUxlbmd0aCArIHRoYXQuZXh0cmFGaWVsZExlbmd0aDtcclxuXHRcdFx0XHR3cml0ZXIuaW5pdChmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdGlmICh0aGF0LmNvbXByZXNzaW9uTWV0aG9kID09PSAwKVxyXG5cdFx0XHRcdFx0XHRjb3B5KHRoYXQuX3dvcmtlciwgaW5mbGF0ZVNOKyssIHJlYWRlciwgd3JpdGVyLCBkYXRhT2Zmc2V0LCB0aGF0LmNvbXByZXNzZWRTaXplLCBjaGVja0NyYzMyLCBnZXRXcml0ZXJEYXRhLCBvbnByb2dyZXNzLCBvbnJlYWRlcnJvciwgb253cml0ZWVycm9yKTtcclxuXHRcdFx0XHRcdGVsc2VcclxuXHRcdFx0XHRcdFx0aW5mbGF0ZSh0aGF0Ll93b3JrZXIsIGluZmxhdGVTTisrLCByZWFkZXIsIHdyaXRlciwgZGF0YU9mZnNldCwgdGhhdC5jb21wcmVzc2VkU2l6ZSwgY2hlY2tDcmMzMiwgZ2V0V3JpdGVyRGF0YSwgb25wcm9ncmVzcywgb25yZWFkZXJyb3IsIG9ud3JpdGVlcnJvcik7XHJcblx0XHRcdFx0fSwgb253cml0ZWVycm9yKTtcclxuXHRcdFx0fSwgb25yZWFkZXJyb3IpO1xyXG5cdFx0fTtcclxuXHJcblx0XHRmdW5jdGlvbiBzZWVrRU9DRFIoZW9jZHJDYWxsYmFjaykge1xyXG5cdFx0XHQvLyBcIkVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeSByZWNvcmRcIiBpcyB0aGUgbGFzdCBwYXJ0IG9mIGEgemlwIGFyY2hpdmUsIGFuZCBpcyBhdCBsZWFzdCAyMiBieXRlcyBsb25nLlxyXG5cdFx0XHQvLyBaaXAgZmlsZSBjb21tZW50IGlzIHRoZSBsYXN0IHBhcnQgb2YgRU9DRFIgYW5kIGhhcyBtYXggbGVuZ3RoIG9mIDY0S0IsXHJcblx0XHRcdC8vIHNvIHdlIG9ubHkgaGF2ZSB0byBzZWFyY2ggdGhlIGxhc3QgNjRLICsgMjIgYnl0ZXMgb2YgYSBhcmNoaXZlIGZvciBFT0NEUiBzaWduYXR1cmUgKDB4MDYwNTRiNTApLlxyXG5cdFx0XHR2YXIgRU9DRFJfTUlOID0gMjI7XHJcblx0XHRcdGlmIChyZWFkZXIuc2l6ZSA8IEVPQ0RSX01JTikge1xyXG5cdFx0XHRcdG9uZXJyb3IoRVJSX0JBRF9GT1JNQVQpO1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cdFx0XHR2YXIgWklQX0NPTU1FTlRfTUFYID0gMjU2ICogMjU2LCBFT0NEUl9NQVggPSBFT0NEUl9NSU4gKyBaSVBfQ09NTUVOVF9NQVg7XHJcblxyXG5cdFx0XHQvLyBJbiBtb3N0IGNhc2VzLCB0aGUgRU9DRFIgaXMgRU9DRFJfTUlOIGJ5dGVzIGxvbmdcclxuXHRcdFx0ZG9TZWVrKEVPQ0RSX01JTiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0Ly8gSWYgbm90IGZvdW5kLCB0cnkgd2l0aGluIEVPQ0RSX01BWCBieXRlc1xyXG5cdFx0XHRcdGRvU2VlayhNYXRoLm1pbihFT0NEUl9NQVgsIHJlYWRlci5zaXplKSwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHRvbmVycm9yKEVSUl9CQURfRk9STUFUKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHQvLyBzZWVrIGxhc3QgbGVuZ3RoIGJ5dGVzIG9mIGZpbGUgZm9yIEVPQ0RSXHJcblx0XHRcdGZ1bmN0aW9uIGRvU2VlayhsZW5ndGgsIGVvY2RyTm90Rm91bmRDYWxsYmFjaykge1xyXG5cdFx0XHRcdHJlYWRlci5yZWFkVWludDhBcnJheShyZWFkZXIuc2l6ZSAtIGxlbmd0aCwgbGVuZ3RoLCBmdW5jdGlvbihieXRlcykge1xyXG5cdFx0XHRcdFx0Zm9yICh2YXIgaSA9IGJ5dGVzLmxlbmd0aCAtIEVPQ0RSX01JTjsgaSA+PSAwOyBpLS0pIHtcclxuXHRcdFx0XHRcdFx0aWYgKGJ5dGVzW2ldID09PSAweDUwICYmIGJ5dGVzW2kgKyAxXSA9PT0gMHg0YiAmJiBieXRlc1tpICsgMl0gPT09IDB4MDUgJiYgYnl0ZXNbaSArIDNdID09PSAweDA2KSB7XHJcblx0XHRcdFx0XHRcdFx0ZW9jZHJDYWxsYmFjayhuZXcgRGF0YVZpZXcoYnl0ZXMuYnVmZmVyLCBpLCBFT0NEUl9NSU4pKTtcclxuXHRcdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGVvY2RyTm90Rm91bmRDYWxsYmFjaygpO1xyXG5cdFx0XHRcdH0sIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0b25lcnJvcihFUlJfUkVBRCk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgemlwUmVhZGVyID0ge1xyXG5cdFx0XHRnZXRFbnRyaWVzIDogZnVuY3Rpb24oY2FsbGJhY2spIHtcclxuXHRcdFx0XHR2YXIgd29ya2VyID0gdGhpcy5fd29ya2VyO1xyXG5cdFx0XHRcdC8vIGxvb2sgZm9yIEVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeSByZWNvcmRcclxuXHRcdFx0XHRzZWVrRU9DRFIoZnVuY3Rpb24oZGF0YVZpZXcpIHtcclxuXHRcdFx0XHRcdHZhciBkYXRhbGVuZ3RoLCBmaWxlc2xlbmd0aDtcclxuXHRcdFx0XHRcdGRhdGFsZW5ndGggPSBkYXRhVmlldy5nZXRVaW50MzIoMTYsIHRydWUpO1xyXG5cdFx0XHRcdFx0ZmlsZXNsZW5ndGggPSBkYXRhVmlldy5nZXRVaW50MTYoOCwgdHJ1ZSk7XHJcblx0XHRcdFx0XHRpZiAoZGF0YWxlbmd0aCA8IDAgfHwgZGF0YWxlbmd0aCA+PSByZWFkZXIuc2l6ZSkge1xyXG5cdFx0XHRcdFx0XHRvbmVycm9yKEVSUl9CQURfRk9STUFUKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0cmVhZGVyLnJlYWRVaW50OEFycmF5KGRhdGFsZW5ndGgsIHJlYWRlci5zaXplIC0gZGF0YWxlbmd0aCwgZnVuY3Rpb24oYnl0ZXMpIHtcclxuXHRcdFx0XHRcdFx0dmFyIGksIGluZGV4ID0gMCwgZW50cmllcyA9IFtdLCBlbnRyeSwgZmlsZW5hbWUsIGNvbW1lbnQsIGRhdGEgPSBnZXREYXRhSGVscGVyKGJ5dGVzLmxlbmd0aCwgYnl0ZXMpO1xyXG5cdFx0XHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgZmlsZXNsZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0XHRcdGVudHJ5ID0gbmV3IEVudHJ5KCk7XHJcblx0XHRcdFx0XHRcdFx0ZW50cnkuX3dvcmtlciA9IHdvcmtlcjtcclxuXHRcdFx0XHRcdFx0XHRpZiAoZGF0YS52aWV3LmdldFVpbnQzMihpbmRleCkgIT0gMHg1MDRiMDEwMikge1xyXG5cdFx0XHRcdFx0XHRcdFx0b25lcnJvcihFUlJfQkFEX0ZPUk1BVCk7XHJcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdHJlYWRDb21tb25IZWFkZXIoZW50cnksIGRhdGEsIGluZGV4ICsgNiwgdHJ1ZSwgb25lcnJvcik7XHJcblx0XHRcdFx0XHRcdFx0ZW50cnkuY29tbWVudExlbmd0aCA9IGRhdGEudmlldy5nZXRVaW50MTYoaW5kZXggKyAzMiwgdHJ1ZSk7XHJcblx0XHRcdFx0XHRcdFx0ZW50cnkuZGlyZWN0b3J5ID0gKChkYXRhLnZpZXcuZ2V0VWludDgoaW5kZXggKyAzOCkgJiAweDEwKSA9PSAweDEwKTtcclxuXHRcdFx0XHRcdFx0XHRlbnRyeS5vZmZzZXQgPSBkYXRhLnZpZXcuZ2V0VWludDMyKGluZGV4ICsgNDIsIHRydWUpO1xyXG5cdFx0XHRcdFx0XHRcdGZpbGVuYW1lID0gZ2V0U3RyaW5nKGRhdGEuYXJyYXkuc3ViYXJyYXkoaW5kZXggKyA0NiwgaW5kZXggKyA0NiArIGVudHJ5LmZpbGVuYW1lTGVuZ3RoKSk7XHJcblx0XHRcdFx0XHRcdFx0ZW50cnkuZmlsZW5hbWUgPSAoKGVudHJ5LmJpdEZsYWcgJiAweDA4MDApID09PSAweDA4MDApID8gZGVjb2RlVVRGOChmaWxlbmFtZSkgOiBkZWNvZGVBU0NJSShmaWxlbmFtZSk7XHJcblx0XHRcdFx0XHRcdFx0aWYgKCFlbnRyeS5kaXJlY3RvcnkgJiYgZW50cnkuZmlsZW5hbWUuY2hhckF0KGVudHJ5LmZpbGVuYW1lLmxlbmd0aCAtIDEpID09IFwiL1wiKVxyXG5cdFx0XHRcdFx0XHRcdFx0ZW50cnkuZGlyZWN0b3J5ID0gdHJ1ZTtcclxuXHRcdFx0XHRcdFx0XHRjb21tZW50ID0gZ2V0U3RyaW5nKGRhdGEuYXJyYXkuc3ViYXJyYXkoaW5kZXggKyA0NiArIGVudHJ5LmZpbGVuYW1lTGVuZ3RoICsgZW50cnkuZXh0cmFGaWVsZExlbmd0aCwgaW5kZXggKyA0NlxyXG5cdFx0XHRcdFx0XHRcdFx0XHQrIGVudHJ5LmZpbGVuYW1lTGVuZ3RoICsgZW50cnkuZXh0cmFGaWVsZExlbmd0aCArIGVudHJ5LmNvbW1lbnRMZW5ndGgpKTtcclxuXHRcdFx0XHRcdFx0XHRlbnRyeS5jb21tZW50ID0gKChlbnRyeS5iaXRGbGFnICYgMHgwODAwKSA9PT0gMHgwODAwKSA/IGRlY29kZVVURjgoY29tbWVudCkgOiBkZWNvZGVBU0NJSShjb21tZW50KTtcclxuXHRcdFx0XHRcdFx0XHRlbnRyaWVzLnB1c2goZW50cnkpO1xyXG5cdFx0XHRcdFx0XHRcdGluZGV4ICs9IDQ2ICsgZW50cnkuZmlsZW5hbWVMZW5ndGggKyBlbnRyeS5leHRyYUZpZWxkTGVuZ3RoICsgZW50cnkuY29tbWVudExlbmd0aDtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRjYWxsYmFjayhlbnRyaWVzKTtcclxuXHRcdFx0XHRcdH0sIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0XHRvbmVycm9yKEVSUl9SRUFEKTtcclxuXHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRjbG9zZSA6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XHJcblx0XHRcdFx0aWYgKHRoaXMuX3dvcmtlcikge1xyXG5cdFx0XHRcdFx0dGhpcy5fd29ya2VyLnRlcm1pbmF0ZSgpO1xyXG5cdFx0XHRcdFx0dGhpcy5fd29ya2VyID0gbnVsbDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKGNhbGxiYWNrKVxyXG5cdFx0XHRcdFx0Y2FsbGJhY2soKTtcclxuXHRcdFx0fSxcclxuXHRcdFx0X3dvcmtlcjogbnVsbFxyXG5cdFx0fTtcclxuXHJcblx0XHRpZiAoIW9iai56aXAudXNlV2ViV29ya2VycylcclxuXHRcdFx0Y2FsbGJhY2soemlwUmVhZGVyKTtcclxuXHRcdGVsc2Uge1xyXG5cdFx0XHRjcmVhdGVXb3JrZXIoJ2luZmxhdGVyJyxcclxuXHRcdFx0XHRmdW5jdGlvbih3b3JrZXIpIHtcclxuXHRcdFx0XHRcdHppcFJlYWRlci5fd29ya2VyID0gd29ya2VyO1xyXG5cdFx0XHRcdFx0Y2FsbGJhY2soemlwUmVhZGVyKTtcclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdGZ1bmN0aW9uKGVycikge1xyXG5cdFx0XHRcdFx0b25lcnJvcihlcnIpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0KTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8vIFppcFdyaXRlclxyXG5cclxuXHRmdW5jdGlvbiBlbmNvZGVVVEY4KHN0cmluZykge1xyXG5cdFx0cmV0dXJuIHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmcpKTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGdldEJ5dGVzKHN0cikge1xyXG5cdFx0dmFyIGksIGFycmF5ID0gW107XHJcblx0XHRmb3IgKGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKVxyXG5cdFx0XHRhcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpKTtcclxuXHRcdHJldHVybiBhcnJheTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGNyZWF0ZVppcFdyaXRlcih3cml0ZXIsIGNhbGxiYWNrLCBvbmVycm9yLCBkb250RGVmbGF0ZSkge1xyXG5cdFx0dmFyIGZpbGVzID0ge30sIGZpbGVuYW1lcyA9IFtdLCBkYXRhbGVuZ3RoID0gMDtcclxuXHRcdHZhciBkZWZsYXRlU04gPSAwO1xyXG5cclxuXHRcdGZ1bmN0aW9uIG9ud3JpdGVlcnJvcihlcnIpIHtcclxuXHRcdFx0b25lcnJvcihlcnIgfHwgRVJSX1dSSVRFKTtcclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBvbnJlYWRlcnJvcihlcnIpIHtcclxuXHRcdFx0b25lcnJvcihlcnIgfHwgRVJSX1JFQURfREFUQSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHppcFdyaXRlciA9IHtcclxuXHRcdFx0YWRkIDogZnVuY3Rpb24obmFtZSwgcmVhZGVyLCBvbmVuZCwgb25wcm9ncmVzcywgb3B0aW9ucykge1xyXG5cdFx0XHRcdHZhciBoZWFkZXIsIGZpbGVuYW1lLCBkYXRlO1xyXG5cdFx0XHRcdHZhciB3b3JrZXIgPSB0aGlzLl93b3JrZXI7XHJcblxyXG5cdFx0XHRcdGZ1bmN0aW9uIHdyaXRlSGVhZGVyKGNhbGxiYWNrKSB7XHJcblx0XHRcdFx0XHR2YXIgZGF0YTtcclxuXHRcdFx0XHRcdGRhdGUgPSBvcHRpb25zLmxhc3RNb2REYXRlIHx8IG5ldyBEYXRlKCk7XHJcblx0XHRcdFx0XHRoZWFkZXIgPSBnZXREYXRhSGVscGVyKDI2KTtcclxuXHRcdFx0XHRcdGZpbGVzW25hbWVdID0ge1xyXG5cdFx0XHRcdFx0XHRoZWFkZXJBcnJheSA6IGhlYWRlci5hcnJheSxcclxuXHRcdFx0XHRcdFx0ZGlyZWN0b3J5IDogb3B0aW9ucy5kaXJlY3RvcnksXHJcblx0XHRcdFx0XHRcdGZpbGVuYW1lIDogZmlsZW5hbWUsXHJcblx0XHRcdFx0XHRcdG9mZnNldCA6IGRhdGFsZW5ndGgsXHJcblx0XHRcdFx0XHRcdGNvbW1lbnQgOiBnZXRCeXRlcyhlbmNvZGVVVEY4KG9wdGlvbnMuY29tbWVudCB8fCBcIlwiKSlcclxuXHRcdFx0XHRcdH07XHJcblx0XHRcdFx0XHRoZWFkZXIudmlldy5zZXRVaW50MzIoMCwgMHgxNDAwMDgwOCk7XHJcblx0XHRcdFx0XHRpZiAob3B0aW9ucy52ZXJzaW9uKVxyXG5cdFx0XHRcdFx0XHRoZWFkZXIudmlldy5zZXRVaW50OCgwLCBvcHRpb25zLnZlcnNpb24pO1xyXG5cdFx0XHRcdFx0aWYgKCFkb250RGVmbGF0ZSAmJiBvcHRpb25zLmxldmVsICE9PSAwICYmICFvcHRpb25zLmRpcmVjdG9yeSlcclxuXHRcdFx0XHRcdFx0aGVhZGVyLnZpZXcuc2V0VWludDE2KDQsIDB4MDgwMCk7XHJcblx0XHRcdFx0XHRoZWFkZXIudmlldy5zZXRVaW50MTYoNiwgKCgoZGF0ZS5nZXRIb3VycygpIDw8IDYpIHwgZGF0ZS5nZXRNaW51dGVzKCkpIDw8IDUpIHwgZGF0ZS5nZXRTZWNvbmRzKCkgLyAyLCB0cnVlKTtcclxuXHRcdFx0XHRcdGhlYWRlci52aWV3LnNldFVpbnQxNig4LCAoKCgoZGF0ZS5nZXRGdWxsWWVhcigpIC0gMTk4MCkgPDwgNCkgfCAoZGF0ZS5nZXRNb250aCgpICsgMSkpIDw8IDUpIHwgZGF0ZS5nZXREYXRlKCksIHRydWUpO1xyXG5cdFx0XHRcdFx0aGVhZGVyLnZpZXcuc2V0VWludDE2KDIyLCBmaWxlbmFtZS5sZW5ndGgsIHRydWUpO1xyXG5cdFx0XHRcdFx0ZGF0YSA9IGdldERhdGFIZWxwZXIoMzAgKyBmaWxlbmFtZS5sZW5ndGgpO1xyXG5cdFx0XHRcdFx0ZGF0YS52aWV3LnNldFVpbnQzMigwLCAweDUwNGIwMzA0KTtcclxuXHRcdFx0XHRcdGRhdGEuYXJyYXkuc2V0KGhlYWRlci5hcnJheSwgNCk7XHJcblx0XHRcdFx0XHRkYXRhLmFycmF5LnNldChmaWxlbmFtZSwgMzApO1xyXG5cdFx0XHRcdFx0ZGF0YWxlbmd0aCArPSBkYXRhLmFycmF5Lmxlbmd0aDtcclxuXHRcdFx0XHRcdHdyaXRlci53cml0ZVVpbnQ4QXJyYXkoZGF0YS5hcnJheSwgY2FsbGJhY2ssIG9ud3JpdGVlcnJvcik7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRmdW5jdGlvbiB3cml0ZUZvb3Rlcihjb21wcmVzc2VkTGVuZ3RoLCBjcmMzMikge1xyXG5cdFx0XHRcdFx0dmFyIGZvb3RlciA9IGdldERhdGFIZWxwZXIoMTYpO1xyXG5cdFx0XHRcdFx0ZGF0YWxlbmd0aCArPSBjb21wcmVzc2VkTGVuZ3RoIHx8IDA7XHJcblx0XHRcdFx0XHRmb290ZXIudmlldy5zZXRVaW50MzIoMCwgMHg1MDRiMDcwOCk7XHJcblx0XHRcdFx0XHRpZiAodHlwZW9mIGNyYzMyICE9IFwidW5kZWZpbmVkXCIpIHtcclxuXHRcdFx0XHRcdFx0aGVhZGVyLnZpZXcuc2V0VWludDMyKDEwLCBjcmMzMiwgdHJ1ZSk7XHJcblx0XHRcdFx0XHRcdGZvb3Rlci52aWV3LnNldFVpbnQzMig0LCBjcmMzMiwgdHJ1ZSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZiAocmVhZGVyKSB7XHJcblx0XHRcdFx0XHRcdGZvb3Rlci52aWV3LnNldFVpbnQzMig4LCBjb21wcmVzc2VkTGVuZ3RoLCB0cnVlKTtcclxuXHRcdFx0XHRcdFx0aGVhZGVyLnZpZXcuc2V0VWludDMyKDE0LCBjb21wcmVzc2VkTGVuZ3RoLCB0cnVlKTtcclxuXHRcdFx0XHRcdFx0Zm9vdGVyLnZpZXcuc2V0VWludDMyKDEyLCByZWFkZXIuc2l6ZSwgdHJ1ZSk7XHJcblx0XHRcdFx0XHRcdGhlYWRlci52aWV3LnNldFVpbnQzMigxOCwgcmVhZGVyLnNpemUsIHRydWUpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0d3JpdGVyLndyaXRlVWludDhBcnJheShmb290ZXIuYXJyYXksIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0XHRkYXRhbGVuZ3RoICs9IDE2O1xyXG5cdFx0XHRcdFx0XHRvbmVuZCgpO1xyXG5cdFx0XHRcdFx0fSwgb253cml0ZWVycm9yKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGZ1bmN0aW9uIHdyaXRlRmlsZSgpIHtcclxuXHRcdFx0XHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cdFx0XHRcdFx0bmFtZSA9IG5hbWUudHJpbSgpO1xyXG5cdFx0XHRcdFx0aWYgKG9wdGlvbnMuZGlyZWN0b3J5ICYmIG5hbWUuY2hhckF0KG5hbWUubGVuZ3RoIC0gMSkgIT0gXCIvXCIpXHJcblx0XHRcdFx0XHRcdG5hbWUgKz0gXCIvXCI7XHJcblx0XHRcdFx0XHRpZiAoZmlsZXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcclxuXHRcdFx0XHRcdFx0b25lcnJvcihFUlJfRFVQTElDQVRFRF9OQU1FKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0ZmlsZW5hbWUgPSBnZXRCeXRlcyhlbmNvZGVVVEY4KG5hbWUpKTtcclxuXHRcdFx0XHRcdGZpbGVuYW1lcy5wdXNoKG5hbWUpO1xyXG5cdFx0XHRcdFx0d3JpdGVIZWFkZXIoZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHRcdGlmIChyZWFkZXIpXHJcblx0XHRcdFx0XHRcdFx0aWYgKGRvbnREZWZsYXRlIHx8IG9wdGlvbnMubGV2ZWwgPT09IDApXHJcblx0XHRcdFx0XHRcdFx0XHRjb3B5KHdvcmtlciwgZGVmbGF0ZVNOKyssIHJlYWRlciwgd3JpdGVyLCAwLCByZWFkZXIuc2l6ZSwgdHJ1ZSwgd3JpdGVGb290ZXIsIG9ucHJvZ3Jlc3MsIG9ucmVhZGVycm9yLCBvbndyaXRlZXJyb3IpO1xyXG5cdFx0XHRcdFx0XHRcdGVsc2VcclxuXHRcdFx0XHRcdFx0XHRcdGRlZmxhdGUod29ya2VyLCBkZWZsYXRlU04rKywgcmVhZGVyLCB3cml0ZXIsIG9wdGlvbnMubGV2ZWwsIHdyaXRlRm9vdGVyLCBvbnByb2dyZXNzLCBvbnJlYWRlcnJvciwgb253cml0ZWVycm9yKTtcclxuXHRcdFx0XHRcdFx0ZWxzZVxyXG5cdFx0XHRcdFx0XHRcdHdyaXRlRm9vdGVyKCk7XHJcblx0XHRcdFx0XHR9LCBvbndyaXRlZXJyb3IpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKHJlYWRlcilcclxuXHRcdFx0XHRcdHJlYWRlci5pbml0KHdyaXRlRmlsZSwgb25yZWFkZXJyb3IpO1xyXG5cdFx0XHRcdGVsc2VcclxuXHRcdFx0XHRcdHdyaXRlRmlsZSgpO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRjbG9zZSA6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XHJcblx0XHRcdFx0aWYgKHRoaXMuX3dvcmtlcikge1xyXG5cdFx0XHRcdFx0dGhpcy5fd29ya2VyLnRlcm1pbmF0ZSgpO1xyXG5cdFx0XHRcdFx0dGhpcy5fd29ya2VyID0gbnVsbDtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHZhciBkYXRhLCBsZW5ndGggPSAwLCBpbmRleCA9IDAsIGluZGV4RmlsZW5hbWUsIGZpbGU7XHJcblx0XHRcdFx0Zm9yIChpbmRleEZpbGVuYW1lID0gMDsgaW5kZXhGaWxlbmFtZSA8IGZpbGVuYW1lcy5sZW5ndGg7IGluZGV4RmlsZW5hbWUrKykge1xyXG5cdFx0XHRcdFx0ZmlsZSA9IGZpbGVzW2ZpbGVuYW1lc1tpbmRleEZpbGVuYW1lXV07XHJcblx0XHRcdFx0XHRsZW5ndGggKz0gNDYgKyBmaWxlLmZpbGVuYW1lLmxlbmd0aCArIGZpbGUuY29tbWVudC5sZW5ndGg7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGRhdGEgPSBnZXREYXRhSGVscGVyKGxlbmd0aCArIDIyKTtcclxuXHRcdFx0XHRmb3IgKGluZGV4RmlsZW5hbWUgPSAwOyBpbmRleEZpbGVuYW1lIDwgZmlsZW5hbWVzLmxlbmd0aDsgaW5kZXhGaWxlbmFtZSsrKSB7XHJcblx0XHRcdFx0XHRmaWxlID0gZmlsZXNbZmlsZW5hbWVzW2luZGV4RmlsZW5hbWVdXTtcclxuXHRcdFx0XHRcdGRhdGEudmlldy5zZXRVaW50MzIoaW5kZXgsIDB4NTA0YjAxMDIpO1xyXG5cdFx0XHRcdFx0ZGF0YS52aWV3LnNldFVpbnQxNihpbmRleCArIDQsIDB4MTQwMCk7XHJcblx0XHRcdFx0XHRkYXRhLmFycmF5LnNldChmaWxlLmhlYWRlckFycmF5LCBpbmRleCArIDYpO1xyXG5cdFx0XHRcdFx0ZGF0YS52aWV3LnNldFVpbnQxNihpbmRleCArIDMyLCBmaWxlLmNvbW1lbnQubGVuZ3RoLCB0cnVlKTtcclxuXHRcdFx0XHRcdGlmIChmaWxlLmRpcmVjdG9yeSlcclxuXHRcdFx0XHRcdFx0ZGF0YS52aWV3LnNldFVpbnQ4KGluZGV4ICsgMzgsIDB4MTApO1xyXG5cdFx0XHRcdFx0ZGF0YS52aWV3LnNldFVpbnQzMihpbmRleCArIDQyLCBmaWxlLm9mZnNldCwgdHJ1ZSk7XHJcblx0XHRcdFx0XHRkYXRhLmFycmF5LnNldChmaWxlLmZpbGVuYW1lLCBpbmRleCArIDQ2KTtcclxuXHRcdFx0XHRcdGRhdGEuYXJyYXkuc2V0KGZpbGUuY29tbWVudCwgaW5kZXggKyA0NiArIGZpbGUuZmlsZW5hbWUubGVuZ3RoKTtcclxuXHRcdFx0XHRcdGluZGV4ICs9IDQ2ICsgZmlsZS5maWxlbmFtZS5sZW5ndGggKyBmaWxlLmNvbW1lbnQubGVuZ3RoO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRkYXRhLnZpZXcuc2V0VWludDMyKGluZGV4LCAweDUwNGIwNTA2KTtcclxuXHRcdFx0XHRkYXRhLnZpZXcuc2V0VWludDE2KGluZGV4ICsgOCwgZmlsZW5hbWVzLmxlbmd0aCwgdHJ1ZSk7XHJcblx0XHRcdFx0ZGF0YS52aWV3LnNldFVpbnQxNihpbmRleCArIDEwLCBmaWxlbmFtZXMubGVuZ3RoLCB0cnVlKTtcclxuXHRcdFx0XHRkYXRhLnZpZXcuc2V0VWludDMyKGluZGV4ICsgMTIsIGxlbmd0aCwgdHJ1ZSk7XHJcblx0XHRcdFx0ZGF0YS52aWV3LnNldFVpbnQzMihpbmRleCArIDE2LCBkYXRhbGVuZ3RoLCB0cnVlKTtcclxuXHRcdFx0XHR3cml0ZXIud3JpdGVVaW50OEFycmF5KGRhdGEuYXJyYXksIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0d3JpdGVyLmdldERhdGEoY2FsbGJhY2spO1xyXG5cdFx0XHRcdH0sIG9ud3JpdGVlcnJvcik7XHJcblx0XHRcdH0sXHJcblx0XHRcdF93b3JrZXI6IG51bGxcclxuXHRcdH07XHJcblxyXG5cdFx0aWYgKCFvYmouemlwLnVzZVdlYldvcmtlcnMpXHJcblx0XHRcdGNhbGxiYWNrKHppcFdyaXRlcik7XHJcblx0XHRlbHNlIHtcclxuXHRcdFx0Y3JlYXRlV29ya2VyKCdkZWZsYXRlcicsXHJcblx0XHRcdFx0ZnVuY3Rpb24od29ya2VyKSB7XHJcblx0XHRcdFx0XHR6aXBXcml0ZXIuX3dvcmtlciA9IHdvcmtlcjtcclxuXHRcdFx0XHRcdGNhbGxiYWNrKHppcFdyaXRlcik7XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRmdW5jdGlvbihlcnIpIHtcclxuXHRcdFx0XHRcdG9uZXJyb3IoZXJyKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdCk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiByZXNvbHZlVVJMcyh1cmxzKSB7XHJcblx0XHR2YXIgYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcclxuXHRcdHJldHVybiB1cmxzLm1hcChmdW5jdGlvbih1cmwpIHtcclxuXHRcdFx0YS5ocmVmID0gdXJsO1xyXG5cdFx0XHRyZXR1cm4gYS5ocmVmO1xyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxuXHR2YXIgREVGQVVMVF9XT1JLRVJfU0NSSVBUUyA9IHtcclxuXHRcdGRlZmxhdGVyOiBbJ3otd29ya2VyLmpzJywgJ2RlZmxhdGUuanMnXSxcclxuXHRcdGluZmxhdGVyOiBbJ3otd29ya2VyLmpzJywgJ2luZmxhdGUuanMnXVxyXG5cdH07XHJcblx0ZnVuY3Rpb24gY3JlYXRlV29ya2VyKHR5cGUsIGNhbGxiYWNrLCBvbmVycm9yKSB7XHJcblx0XHRpZiAob2JqLnppcC53b3JrZXJTY3JpcHRzICE9PSBudWxsICYmIG9iai56aXAud29ya2VyU2NyaXB0c1BhdGggIT09IG51bGwpIHtcclxuXHRcdFx0b25lcnJvcihuZXcgRXJyb3IoJ0VpdGhlciB6aXAud29ya2VyU2NyaXB0cyBvciB6aXAud29ya2VyU2NyaXB0c1BhdGggbWF5IGJlIHNldCwgbm90IGJvdGguJykpO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblx0XHR2YXIgc2NyaXB0cztcclxuXHRcdGlmIChvYmouemlwLndvcmtlclNjcmlwdHMpIHtcclxuXHRcdFx0c2NyaXB0cyA9IG9iai56aXAud29ya2VyU2NyaXB0c1t0eXBlXTtcclxuXHRcdFx0aWYgKCFBcnJheS5pc0FycmF5KHNjcmlwdHMpKSB7XHJcblx0XHRcdFx0b25lcnJvcihuZXcgRXJyb3IoJ3ppcC53b3JrZXJTY3JpcHRzLicgKyB0eXBlICsgJyBpcyBub3QgYW4gYXJyYXkhJykpO1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cdFx0XHRzY3JpcHRzID0gcmVzb2x2ZVVSTHMoc2NyaXB0cyk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRzY3JpcHRzID0gREVGQVVMVF9XT1JLRVJfU0NSSVBUU1t0eXBlXS5zbGljZSgwKTtcclxuXHRcdFx0c2NyaXB0c1swXSA9IChvYmouemlwLndvcmtlclNjcmlwdHNQYXRoIHx8ICcnKSArIHNjcmlwdHNbMF07XHJcblx0XHR9XHJcblx0XHR2YXIgd29ya2VyID0gbmV3IFdvcmtlcihzY3JpcHRzWzBdKTtcclxuXHRcdC8vIHJlY29yZCB0b3RhbCBjb25zdW1lZCB0aW1lIGJ5IGluZmxhdGVyL2RlZmxhdGVyL2NyYzMyIGluIHRoaXMgd29ya2VyXHJcblx0XHR3b3JrZXIuY29kZWNUaW1lID0gd29ya2VyLmNyY1RpbWUgPSAwO1xyXG5cdFx0d29ya2VyLnBvc3RNZXNzYWdlKHsgdHlwZTogJ2ltcG9ydFNjcmlwdHMnLCBzY3JpcHRzOiBzY3JpcHRzLnNsaWNlKDEpIH0pO1xyXG5cdFx0d29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBvbm1lc3NhZ2UpO1xyXG5cdFx0ZnVuY3Rpb24gb25tZXNzYWdlKGV2KSB7XHJcblx0XHRcdHZhciBtc2cgPSBldi5kYXRhO1xyXG5cdFx0XHRpZiAobXNnLmVycm9yKSB7XHJcblx0XHRcdFx0d29ya2VyLnRlcm1pbmF0ZSgpOyAvLyBzaG91bGQgYmVmb3JlIG9uZXJyb3IoKSwgYmVjYXVzZSBvbmVycm9yKCkgbWF5IHRocm93LlxyXG5cdFx0XHRcdG9uZXJyb3IobXNnLmVycm9yKTtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKG1zZy50eXBlID09PSAnaW1wb3J0U2NyaXB0cycpIHtcclxuXHRcdFx0XHR3b3JrZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIG9ubWVzc2FnZSk7XHJcblx0XHRcdFx0d29ya2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZXJyb3JIYW5kbGVyKTtcclxuXHRcdFx0XHRjYWxsYmFjayh3b3JrZXIpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHQvLyBjYXRjaCBlbnRyeSBzY3JpcHQgbG9hZGluZyBlcnJvciBhbmQgb3RoZXIgdW5oYW5kbGVkIGVycm9yc1xyXG5cdFx0d29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZXJyb3JIYW5kbGVyKTtcclxuXHRcdGZ1bmN0aW9uIGVycm9ySGFuZGxlcihlcnIpIHtcclxuXHRcdFx0d29ya2VyLnRlcm1pbmF0ZSgpO1xyXG5cdFx0XHRvbmVycm9yKGVycik7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBvbmVycm9yX2RlZmF1bHQoZXJyb3IpIHtcclxuXHRcdGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xyXG5cdH1cclxuXHRvYmouemlwID0ge1xyXG5cdFx0UmVhZGVyIDogUmVhZGVyLFxyXG5cdFx0V3JpdGVyIDogV3JpdGVyLFxyXG5cdFx0QmxvYlJlYWRlciA6IEJsb2JSZWFkZXIsXHJcblx0XHREYXRhNjRVUklSZWFkZXIgOiBEYXRhNjRVUklSZWFkZXIsXHJcblx0XHRUZXh0UmVhZGVyIDogVGV4dFJlYWRlcixcclxuXHRcdEJsb2JXcml0ZXIgOiBCbG9iV3JpdGVyLFxyXG5cdFx0RGF0YTY0VVJJV3JpdGVyIDogRGF0YTY0VVJJV3JpdGVyLFxyXG5cdFx0VGV4dFdyaXRlciA6IFRleHRXcml0ZXIsXHJcblx0XHRjcmVhdGVSZWFkZXIgOiBmdW5jdGlvbihyZWFkZXIsIGNhbGxiYWNrLCBvbmVycm9yKSB7XHJcblx0XHRcdG9uZXJyb3IgPSBvbmVycm9yIHx8IG9uZXJyb3JfZGVmYXVsdDtcclxuXHJcblx0XHRcdHJlYWRlci5pbml0KGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdGNyZWF0ZVppcFJlYWRlcihyZWFkZXIsIGNhbGxiYWNrLCBvbmVycm9yKTtcclxuXHRcdFx0fSwgb25lcnJvcik7XHJcblx0XHR9LFxyXG5cdFx0Y3JlYXRlV3JpdGVyIDogZnVuY3Rpb24od3JpdGVyLCBjYWxsYmFjaywgb25lcnJvciwgZG9udERlZmxhdGUpIHtcclxuXHRcdFx0b25lcnJvciA9IG9uZXJyb3IgfHwgb25lcnJvcl9kZWZhdWx0O1xyXG5cdFx0XHRkb250RGVmbGF0ZSA9ICEhZG9udERlZmxhdGU7XHJcblxyXG5cdFx0XHR3cml0ZXIuaW5pdChmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRjcmVhdGVaaXBXcml0ZXIod3JpdGVyLCBjYWxsYmFjaywgb25lcnJvciwgZG9udERlZmxhdGUpO1xyXG5cdFx0XHR9LCBvbmVycm9yKTtcclxuXHRcdH0sXHJcblx0XHR1c2VXZWJXb3JrZXJzIDogdHJ1ZSxcclxuXHRcdC8qKlxyXG5cdFx0ICogRGlyZWN0b3J5IGNvbnRhaW5pbmcgdGhlIGRlZmF1bHQgd29ya2VyIHNjcmlwdHMgKHotd29ya2VyLmpzLCBkZWZsYXRlLmpzLCBhbmQgaW5mbGF0ZS5qcyksIHJlbGF0aXZlIHRvIGN1cnJlbnQgYmFzZSB1cmwuXHJcblx0XHQgKiBFLmcuOiB6aXAud29ya2VyU2NyaXB0cyA9ICcuLyc7XHJcblx0XHQgKi9cclxuXHRcdHdvcmtlclNjcmlwdHNQYXRoIDogbnVsbCxcclxuXHRcdC8qKlxyXG5cdFx0ICogQWR2YW5jZWQgb3B0aW9uIHRvIGNvbnRyb2wgd2hpY2ggc2NyaXB0cyBhcmUgbG9hZGVkIGluIHRoZSBXZWIgd29ya2VyLiBJZiB0aGlzIG9wdGlvbiBpcyBzcGVjaWZpZWQsIHRoZW4gd29ya2VyU2NyaXB0c1BhdGggbXVzdCBub3QgYmUgc2V0LlxyXG5cdFx0ICogd29ya2VyU2NyaXB0cy5kZWZsYXRlci93b3JrZXJTY3JpcHRzLmluZmxhdGVyIHNob3VsZCBiZSBhcnJheXMgb2YgdXJscyB0byBzY3JpcHRzIGZvciBkZWZsYXRlci9pbmZsYXRlciwgcmVzcGVjdGl2ZWx5LlxyXG5cdFx0ICogU2NyaXB0cyBpbiB0aGUgYXJyYXkgYXJlIGV4ZWN1dGVkIGluIG9yZGVyLCBhbmQgdGhlIGZpcnN0IG9uZSBzaG91bGQgYmUgei13b3JrZXIuanMsIHdoaWNoIGlzIHVzZWQgdG8gc3RhcnQgdGhlIHdvcmtlci5cclxuXHRcdCAqIEFsbCB1cmxzIGFyZSByZWxhdGl2ZSB0byBjdXJyZW50IGJhc2UgdXJsLlxyXG5cdFx0ICogRS5nLjpcclxuXHRcdCAqIHppcC53b3JrZXJTY3JpcHRzID0ge1xyXG5cdFx0ICogICBkZWZsYXRlcjogWyd6LXdvcmtlci5qcycsICdkZWZsYXRlLmpzJ10sXHJcblx0XHQgKiAgIGluZmxhdGVyOiBbJ3otd29ya2VyLmpzJywgJ2luZmxhdGUuanMnXVxyXG5cdFx0ICogfTtcclxuXHRcdCAqL1xyXG5cdFx0d29ya2VyU2NyaXB0cyA6IG51bGwsXHJcblx0fTtcclxuXHR3aW5kb3cuemlwID0gb2JqLnppcDtcclxuXHJcbn0pKHRoaXMpO1xyXG4iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTphcHBsaWNhdGlvbi9mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFRbEFBQTBBQUFBQjF1UUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCR1JsUk5BQUVKSkFBQUFCc0FBQUFjYllvSjlrOVRMeklBQUFHZ0FBQUFTZ0FBQUdCQk9XSFRZMjFoY0FBQUJGd0FBQURPQUFBQittMENiaDlqZG5RZ0FBQUZMQUFBQUFRQUFBQUVBQkVCUkdkaGMzQUFBUWtjQUFBQUNBQUFBQWovL3dBRFoyeDVaZ0FBQ3ZRQUFQR0JBQUdpY1BraUpoQm9aV0ZrQUFBQk1BQUFBQzRBQUFBMkFtdW5wV2hvWldFQUFBRmdBQUFBSFFBQUFDUUQ4QVNnYUcxMGVBQUFBZXdBQUFKdkFBQUxma0VLQUVsc2IyTmhBQUFGTUFBQUJjSUFBQVhDbExncDFtMWhlSEFBQUFHQUFBQUFJQUFBQUNBRFBBR2pibUZ0WlFBQS9IZ0FBQUZiQUFBQ2hhSVAzRzV3YjNOMEFBRDkxQUFBQzBZQUFCekttY0xWMm5qYVkyQmtZR0FBWWhOVk9mZDRmcHV2RE54TURDQndZWm54RkFUOS93QVRBK01CSUplREFTd05BUGJIQ1hNQUFIamFZMkJrWUdBODhQOEFneDRUQXdnQVNVWUdGTUIwSHdCUmN3T1dBQUFBQUFFQUFBTGdBWElBR2dBQUFBQUFBZ0FBQUFFQUFRQUFBRUFBTGdBQUFBQjQybU5nWWF4aC9NTEF5c0RBNk1PWXhzREE0QTZsdnpKSU1yUXdNREF4c0RFendJRUFnc2tRa09hYXduRGdJOE9YNzR3SC9oOWcwR004d09BQUZHWkVVcUxBd0FnQWZSUU5wQUFBZU5xTlZqdHlGREVRYlkzM0FMQVI0Y1NjUWhFaFJiUWhwUU00NGdMb0FBUUVEb2hBUlVCUkxtNUFNcHdBUW9kYlpKUURIOEhXcHlVOTliU01YWDZsWGtrdDllZDFhK2duUGFmMGQwMWtOakxrODBnbWpUYmlXR1JLYzI0dnR6M2JJNGovZVF6OE8weXdEZkpGMUV1NkYxbDJZQmZhbU1hMVlDRzJKN1IxMDJRTHVoNXN4ejBFWnpKeVBFSTVQL2xOWjc3blc3UXB4ZUtPZFY1SCtYdTNod0l0K1R6TlpyaWZBdCs3Q1orc29pdGo2Q2RuTzRhTnZpWElNMFFjc2w5YTNtUzhmakhrUERGdUdMTnpiRUdLMzBMS0hRN3loUG9wdisvR3VFUjdUWXVSaEpacjMvVEcrRzVLN0owNGkzbEJIdlRTK0lwamwrUzNDbjltTXZMcnJOelpjMjFxekhaNkhDOUM3dEkrRGd2TVpmazkxTWhKOENmTnZZVGYxYmJQa2N0ZXhDUkFuQVBibXVRcm1DdDNtbWJEYVl6SHdBTUxmUUw1RFRGZDZycUhkU2Y0YnlGbjY1NTdLbC9TV1QvQXB4UExWTWJhQTFvdm9MS0hib2U4bW54ZnpXVVFkaUp3N1F6d1NyMWdIdVY2QUp2UkY5ZlhtaDdXeENmdVBXOTRQdTIvRkxIY2hFM3JMdC9qWFYvQXJ5dUdFL1Y0RFRWKzdqMjEyZlZzOUhlUmZDNzJkQzdXZTdiZDI5RnIzZmIreGxncUY2cE05ejNYS21TLy9GdlE1cjR5TE5RRzZxMkNpeG9mWUQvOW50dENpcC9UZm52czcvY09INVQ3MTBuTk9MMlhOcTRuZkdTUWdKLzB2cGtQczdkS3ZzZEJyUDNoUGh5ZUVQOFYrRnhyNngvWHdDWG92eEMraExGbTZhWUErS1RuWDhaVHZwdWVEaG5ZWCsyOFo2VTNJNzhibW0weXJtZ3pmQ3NOUGNlTE03UThTTnNuYnp2MFgvTW9OenUzRGhuMTdxUDRucFQrekRoYUFiVkkrRzJET2NHMzdYODFOUE43Ry90eDVOQ2h4VlRhckh6LzVEelNBL1pXaENNQWVOcGpZR0JnWm9CZ0dRWkdCaEQ0QXVReGd2a3NERGVBdEJHREFwQWw5Tkg4bzlWSGw0L2VuMm8vN2ZwMDlOUHhUNmMrWGZsMDg5UGRUdzgrUGZuMDh0T2JUeDgrL2ZqMDl6UGJaNTdQL0o5bHYzei8vNStCNFNQRFI4dVB0aC9kUC83OE5QWFRQcUNlazU4dWZyb08xdk1ZcU9jMVVNK1hUMzgrczM3bUF1b1IvbXovL3o4L016OFRQd1BmUDc1QVBpcytjejR6UGxNK2ZUNWRQaTArRFQ0MVBpVStSVDQ1UG1rK0NUNUJQajQrSGo1TzNoZFFONU1JR05rWTRCb1ptWUFFRTdvQ2htRVBBQU5uVnI0QUFBQVJBVVFBQUFBcUFDb0FLZ0JTQUdRQW1BQ29BTWdBOEFFQUFTQUJTQUZZQVhZQm5nR3VBYzRCOWdLc0F2WURIQU5JQTJZRGtnTzhCQ1FFY2dTMEJQZ0ZPZ1ZhQlpvRjRnWUtCbG9HbEFhOEJ1b0hEQWN1QjFBSGNnZmNDQ1FJVWdpT0NMWUk4Z2ttQ1lZSnVnblVDZndLV0FxVUNzNExDZ3QwQzRRTHVndlNEQ1FNYmd6d0RXWU5oQTNXRGlJT05nNThEdndQTGc5S0Q1d1B5aEFBRUVJUVpoQ3FFUUlSS0JGZ0Vhd1I2aEswRXZ3VFpCT2FFN0lUeWhQV0ZBNFVOaFJ5RktvVXhCVU1GVEFWaWhZY0ZtZ1dyQmJLRnVvWEVoY21GMVlYbmhld0dBUVlLQmhDR0hBWW9oajBHU2daV2hvZUdwb2JIaHRjRy9RY1dCeTJIT1FkVGgyK0hnZ2VOaDUySHBRZmFCL0NJRElncGlESUlPSWhPQ0YrSWtBaTBpTWtJMG9rSENTMkpSd2xVaVh1SmpBbThpZEtKNEFubmlnY0tLb280aWtBS1c0cG5pbTBLY29xRGlwU0txQXE3Q3NpSzFJcmxDdklLK1FzREN4YUxKWXM0QzBtTFZZdGJDMkNMWmd0cmkzU0xlb3VCaTRrTGxndWVpN09MOVF2N2pBc01KWXhGakYrTWNReCtqSmlNcTR5eWpMbU5HQTBkRFNnTk5ZMUdEVnNOY1EyQmpZeU5wUTJ0RGNNTjVBM3lqaFVPUVE1c0RubU9obzZlanFrT3VZNjlqc3dPMWc3bWp2UVBDbzhmRHkwUFJ3OW1ENCtQeHcva2ovOFFGcEE2RUZFUVhSQmtFRytRZ3hDbWtNOFEzaEVMa1JVUkxaRitrYkNSdDVIMGtuVVNlaEtIRW95U21KS2tFckNTdTVMQ0VzMFM0aExza3ZRVENaTVRFeUlUSzVNMkUwQ1RRNU5PazFLVGJKTnhrM2NUZzVPWGs2NFQwNVAwRkFxVUQ1UWpsQ3dVV0pTSmxMRVV5SlRabE9XVThoVU1GU1VWT3hWVWxXcVZnQldhRlorVnQ1WEdsYytWNEpYd2xneVdMNVpNRm1LV2V4YVVscWlXdnBjTGx5OFhPaGRKRjJBWGFwZDRGNEFYalplVkY2S1hxQmV1RjdFWHR4ZTZGOEFYd3hmSkY4d1gwUmZlbCtZWC9CZ1NHQmVZS3hnL21Fa1lXaGhxbUhHWWVwaUVtSTZZbVppb0dMS1l2UmpMbU5PWTV4andHUGtaQUJrSUdSS1pHaGtpR1NhWkx4azdtVVVaVnBsZkdXOFplWm1BR2E2WnVKbkhtY3laMnhubW1mVWFBUm9IbWhzYUpSb3ZHak9hUkJwUm1sdWFacHA4R29zYWxacWNtcVVhclpxM0dyK2F5UnJRbXRxYTVKcnFtdlliQlJzVEd4MGJLaHM2RzA2YldwdGttMjRiZVp1SEc1R2JtQnVjRzZ5YnQ1dkRtOG1iMHB2cm5BQWNJUndwSERnY1d4eHdISkVjcmh6TW5PR2M2aHp4SFJpZE5aMWFIWFNkZVIxOW5ZSWRocDJLblpPZG5KMmxuYThkczUzckhpTWVNSjQ3SG5xZXNoN1ZIdlNmQjU4Vm56NmZWSjljSDJBZmRoK0RuNXdmclIrN0g4S2YwcC9oSCtvZjc2QVBvQ0tnTHlBNElGVWdhU0I5SUl5Z2xxQ2RJTE9nd0NERklOQWcyQ0RpSU9tZzh5RDVvUUFoREtFV0lTMmhQQ0ZRb1dnaGRxR0JJYUFoczZIRm9jMmlDNkl4SWxjaWZTS05vcHlpcWFLMElzb2kzcUxwb3ZLaSs2TUVvdzJqRmFNY0l5WWpMaU5HbzFZalhhTmlJM0FqZTZPUUk2TWp0S1BBSTljajR5UC9KQldrbktUZkpQSWsvcVVoSlRjbFZDVnNKWmtsdHFYc3BnT21HS1lvSmpLbVB5WlhKbUltYmFaL0pvNG1tcWFpcHJXbXlDYk9KdG1tNDZjQXB6YW5VNmRzcDMwbml5ZVdwNmFucjZlK3A4d240Q2YwcUFNb0N5Z2VLQzhvUWloU3FGOG9ZcWhycUhHb2VTaUNLSStvbUtpcktMVW92cWpLcU5PbzJha0hLUnNwS3lrM3FUNHBRcWxpcVhrcGdhbUdLY3NwN3FwU3FvMnF2eXJTS3djckhhc21xeXlyUWF0TEsyU3JjeXQ0SzN1cmdLdUxxNU9ybml1bXE3WXJ3YXZTcTk4cjdpdjhMQm1zTGF4R3JGb3NaaXh0TEhTc2dpeU1ySmVzdUt6T3JOYXMyeTBITFJ3dEp5MHhMVDZ0WGExNHJaT3RuQzJncmFtdHJpM2lyZ2N1TVM0NUxrS3VTQzVkcm0rdWc2NlVycmN1eWk3Z0x2VXZDYThXcnpzdlk2OXpMNE92b0srMXI4a3YyUy9rcit1ditqQUhNQkF3RjdBbXNDOHdQREJBTUZNd1lEQ01zTDB3OHpFRE1RMHhMREUzc1VBeFVyRnJzWk94dUxIRk1jK3g3Ykg2c2dheUVMSTBNa1F5VWJKMHNwc3l1REwvTTA4emdMT0xzNU96czdQTXM5NHo1N1FJTkNRME9MUkhORTRBQUI0MnF5OUNaUmtSM1VtL0NMZUVtL2ZsOXp6WldabFp1MUxydFZMVldXM3VxWGUxS3FXV28xMmxWcXRIVUZMSUpERlZpQWRJMk00Tk5nQ0dRdFRad3hHV0lBYmJJTXdZMU0yeGdac3o4Z3lHUEJhd0RtL1BmeGpXOE40UEl6SGsvcHZ4TXVzeW1xRURHZitxc3g0OGJaWWJrVGMrOTBiTnlJNXpEa2N4LzBDdXBiak9jTE5mZ3B4Yy9zL1RRVHVIeHFma3NTLzJ2OXBIa09VK3hSUEw0djA4cWVKaFA1dC82Y1J2ZDUwbWs2OTZWU2N4MTkvNTUzbzJ2NHpEbXBDYWp5SE9BNTlBYTF6QnFRZWNGdzFKRktsVks3WHVsNm5FWG50U3RDRkwvcHRTUkNWL2kyS0tFai9XWFJGdDlmclpUUWl5MFJETnl0Sy8zUHo4NnNYTGtCNm1PTmUzT0xXMFFZckl4ZFYyczE2aFcrdXI2L2JhL1o2dk5aRE1YMkdpOUVtV3VNa0x1YTRicjNaYmdiTktMUVF6WGtPMVZaUWt6UWJSZFRzZHZhaGVuTnJmWFZ0OVpUTEszeTYvNDQwSEp3ams4c05BYnRQdTVodkxrKys4N1ZyYS9lbzRXVytmMW1vZHBmNW1SbCtHYktnTllOZ0hlb21jVnd6eVdWejgvekcrYzNOemVIOU5VUkxCSFQxYXUxV3AxbHFoSUZ2WVFsS3dmTXFRUVdpOHZoeHhWY2VSNFNYaUtJUWtlZWZVcFNuaHUvYnlFWG51UlRRRGNoR3k5N3FRTUVocVVhWVIxMElmYVRjbzVpR2NxL2k1cFNHbC9FYVNzNTkwemxGT2Fla1hXWCtXNGJyR3QrYVY5ejBKZVZ0ZDRObVVBazI2UjhVZVpoZnpGRzYwZkoybWxCV3g2ZTU0bHByQlgwMEtaL0VZMW8rZERNVXYvK2Q3ZUlQMysraU5YU1VsdGVqWmJNUUpPSkxVeWlDa0phKzNlcmVyMlJjWldHblhGQlFCZlZHU3c5MU1VemxrdkpXU1J2YXVvM1dkMHE4cTd4ZEtHaXQ3UUNORzBWTWMwN3ZvbWRsTjdVdktXdEVXd1ZKWlZwUFNLWkZ1d1dsOUgrL2hJNExpcHRCdlIrbTl5Vmw5YUpLVUdsWFdERlpnUy9wQzFYSWpuWkZJTWNLcHUySmxuWlQ4NmRldmk5NFhWcExsTkFVa2lyWGxoQ2hwWCtKcm9ENGw2akRZQnpCR05uZ2J1UFdvVVFtMUx0ZW8vL1F0N29kbWtFQkJ6NlI2RCtsYkNWNUFocHdjRHNLbzJhM1NXOEhmdGhzZER2dFZwSkFwWnk4RmZqd0NQelRlOTM2Nk1VQ1l0YzZPKytnWHhrN3U5aVltU29VYldjc3pzOU16VTJlM0QrbWFyWUx6NmNLdkZMTFRrU1JvbGhtS3NyNHJpMGlzWlBDQ010YXlySjFMUXFLaGNwNG9SaWxOTU13bzNSY3FzL1Y0dElIYmNXUUpGRkFTQlJzelRKVVJjRThRcEpJNUlucW1HTVhpdU5UYy9OWEYzS2VrNW8vc2xETDVCMVBVVk9PbGNubXBqS3B0T2NhdXFxYXFRZDBZb3FhbWNsT2pPWFNvYThvaHBIT0ZNcVZ5VUljUnJwdUc0WFB5cHFtdW9halNqS1JWRm15VE4zU0RZbW9SQlNCVXcxcGJYQVJCMXdSZVNXdjJhYTlqSTdpZWdEeDJoUXFTM3lKcndRaGExQ2djM3RYSEczRS9WN2NPOXFVbTBlM05qczF1ZGE1Q1QyY3J0aHV6clUzV1ZoQmNYOFQ5WVRtMGFOTkFmNXFuVTcvTTRnYlUxM1RoWTg2dGhOalBMSUhaZXB4SGdlc29WdGVRaTNnVG5sb21UenlwNkJYVmVxa1Nib1ZWVlhSbTlTcUNwOWZPYmVVUGJmVVUvK3JxbmJVVjhKMzY5V25YcDN3NU8yMGlsQzc3UlJLMjZsRzdTbTBoRXBCYVFrMTBXZG9ZdjFIV2NLV0ZmZC9EWjJLRWNkU1pHbXY5ZUo0TTQ1Wm54K20rNUtwN2twcE5JV2ZvRXlWcVBrU1pUb1ZMN3hra1M1Tjl5WHB4cExjaHlENTlnajF3aitOUHhWRDBxUDBneVI3TVpXUklOUCtEL1NQT1c0dmQ1anl6aUphS0tBdVRadU9NeXE1QWhqdlZJQ1ZsM0JOSWdHUjZpREdPbTA2ZUxwQjJJRjRDL2dybENHSnpTTGQ1Zy94SXRaRjRTRlJKcWNGNFRTUkh4RkVIWXR3M1RiNUd3VGhlc1IvQUU0TFBGOVFWUnJ5SXBxM2hRTUM1cC9DcXZDQVFNZ3BRWkJQRWZLUW9PS25lSjZIM21XYndobGVsSzlGUXUwcWVMREF5L0QySDE0bHFTd0dHSUVUdHZ1N0J2Mjl4UzF5bkV0WlZDSzAvSEFrM20yQWlJRTJBY2E5RDJnWE5qclFHSXlmUU1SelNzNmJjeTUwN2YvRXdpT3kzRitWNWNWOExiOWU4Tnk4M2Q5QVBkZU1hWjhlRFdibC9ubFpSaGZrQ1R1SzdJa2s3RjlBM0l1c2JJQU5Oa0JtcEVCMmpISFR0Ry9Ra2pCK1RNdTFEMUZVMElnV0lxblJhZFhLa3Q5cHRNb1NsV1BBWWRHYlRkODMreCttNGVHNllwODIxSW4zbk9oMFRuVCtKWmY3N042SmliMFRhTVl6djBydmY5WDB4alYxNGkrN0o3cmRFNi9PRlNmb2JjaGYyc1luRG95OUVsZmxKcmdaVmc0bWI2bGNXSEFXUUpKRlpSS1UycldLMCtpMlMwSFk3QUxDSUJSbHdCZDlXTGR0dmY4d0RSME5vM1dzYWJnUG9iZTV1YmJSUTJ0dzh3ZjBKcEoxTzlaOVgzK1IwMS83V3IxbjI3RnR6ODl6U1R1OUFMUzR3UGxjTHFGRk42RUJ4U21VSnRDZloxR2xBelFJQjdRWVBaNklwNmRqSk5OUXVNbzByMmVOOU9CSU9EOVIrTlBDNUNRRUU3Mk8rcHpMTG81OEVybTJYWWFYenYyU1hIYW55ZVJZOG42S200VVVJaE1CSjdWUXV6SnNUZWhOMEp6ZWRwSjF5bXByU3hqeStaY01YL0J1SUZMYjluTlpEOWN5RHltdnlWU3JHZWU0WU55UnFSWXlWN3VXdzgvTVIrNWJ2Y3dkNlRMYVUway9uYTcwOWd1VjlObkxNK1ZkTktUOWFad0R1a1lVUUZDY1Iwd1VTRUhFSkdMWnIwZy9pbzdQblhua2tZOC9Va0pZQ0U4TE1pOGpWRDM0UTdSRUQvM0s2MTUzemI0RmhKRk1yaXRpakt4dnZ3UkIwVWg1Zm5SSlhpTEhsMGlmRytEdEpMME0xd1g2MWhiYVZCNE5aRDZ3bzNvRkVyVlF0K1UxRWhBMXpBaWlDWEpvZFpkUkdxVVdoRHVQUk1ITTVka2lFZ1JlV3RULy9NaWRPWVI0NTdBRXAxaTJnK2pJSGJ5K3RnZmh5bVJ2TXRRUDN5NjFkWXpERlJIZGRQdmh1U2tFa2xzNmxvR1M4WUowOXJEcjdEa3hpbU1JOUdET0hReFRFWkFGc0VOYUNvWklBSElIUG5EUUtHeDBILzJ0UitHRHJrR29pSGlNWGowTlVCenhhVWdlbjRTa2ViVEJubkFSWUlVVVF1K2VoUHR3Rng1Rnh5R2FZREVFTkhrTGxVdGNBWkM3aWVxemlJSHpzSWk4RG5vMEk2bi9XUzBhOHFGQ1VVdkYydTIvb2FLMytTV3ovN3docWRMUmNsa3ZwNUJ4SHlMR2poNnhBZGd4QzhmUUIwMkFnVzVBaDZpVFFEMkt4aVAwU3hqL0w0a1h4WGZ4R09PY0xXRkJXdjB5Rm5nQlhRM2l2cjhwaVkvekFrWUNMdGlTZEJMcWd5RnRIdVRWYjZNbGhwRVh1cDFFakNSYVVDZmErcVFzRjJYNTY3ektmNTNGM3ZkUldTN0k4aC96L0IrenlLQjhMMzRYNU5NSFdScE1HdEc2d3Zzc3NUTTdyeEFGSWgvZEhFbVUwRnVmcEdud0wzNFhjWU0wRnBqd29nZzJTYXY3cXpRTmhXeG5TNU1veUdTblhFazVlTzR5cUV1UHBVR2twQTZOcEVaejZJZnE4c252WFZLWmozSlVaNFQrc2diOXhRSFp0TXdkNUM3bmpuRW5xY3lGdExibFV0UU1vM3JaYnpaYUF5MW9DaWZhQmVVbndFWEtjQTNZRkZ4aHpBU1JBV2V1RDc2cjBHT0NiQzBiNEJTL0JwRDA3WnB0YTAvOHZPWTQybEZOcnVvYVVqUzlLdXVmUDM5K1krT3RiMzBPeFNXQ1JDdndzbGt2c0VWU1dzdmxnSUUveVJqNDNZQXdaYzNvZjA3WDBSV0dKaHNiREl6MDJHY3dSdjhXeHNDSG9IWXpJMk9nM3UwTXhzQmdQQlpCUzZDam9MR0NLQ3luK0tFMUdBMG5qcCtRcEpEbk1YL2lCQVI4SUVrblRtQWNZQmtmVHk3dzZFUHMyYWVQSDVla2dPZVBIV05QSFQrQlpCeGlmT0k0bkVKZjNLVVhaNm11dzdRVWtpaFg5VVIvN1NiS0lYcWQ2aGUwUngvVmNxSDJ0cmRwWVk3R0M3NzY2QklMSHgzYzNZbVBwbDFsYVROSVJKTlBsR09hQTFTcnlmSm9KbDBEdlJHZ3NDQkt3cU9QMHJBbUNJODlCb0JNRXVnVkdnSThlMnhKMElXcVFCK0JneTQ4K2paVmhRZmY5alo0VlZYZWx1UTdEelJlWmJwNFkwZUI2d0IzZzdGSmd6QkFyeXJQejVmNy83WGFMbWVGVXFpYjVwN3kvR1hmV0tpVUZ6clZ3cHdTNWttaGVuaUIyVVZvUGQ2QTNnQnRwdE82MEpKQ2cwVWtzdEFLSGliUGVoeXBETHNiZW9OaHhOMmlvUi9zZnFwblBoOGJhdjgvcVlhaGZpVitRbE9Sb2FDYmRLUFlqUTFqb3ZzSkV6ckhWK2hOMUZDTldPMy9zNnB5bzlpTWNCYU1nT0pPZnhtS3BOb2w1OCt1N3RtenV1ZXFzVXhtTExQQWVzc243anh5NU00anFMU0gzam1kb1hlK3ovckdONC9RTzl3QTQzQW9obmJ5UVM1T0F3WTh4QjJsdFV5azhMQnFnRzZoVXdZK3hHRHN3WFc0dlIyUDJqdFh1aVB4ZXJNZStLaUFEZVcvSzZhcGJFakF0RS8vdi93VlBQMjhBZU0zOEJ2NEYzbitGM0dNUDgvem44ZHorNjlBa1NUOEQ5VTBWYlNxbWhqek45a3FEM3ppVVJaZU9SSS9lZktnem0yM0R5MS9BQzFlK2hFbEQwRjNJODBFYTFSQW5PaFFJc3VpSlpMUU5mek5lLzl5NnpMTmVTdUtlT21mVmR0VzBWV0tDVUxsSnI2ejh2M25IZTNxUVQ2cndLYm5tVDFMNHpnSGtKNDQrR0t1enlWZlpNZnhHdnNNOUswWUFjUURmUkowdHlyQTU5YUFFWUtvcDNySVFNdEJjLzN2T1B3N0ZGOTVCNi9yZXYrYnVyNXVDOElYRk9WM1FDR085WEVkUGtPZEJyQTA1M0pMMUZKVnIzWDI0VWFZYU96VVZOZEpLbzhacG9vS09DSlNSSFVPSms4N1hWRG9nZE1zWTAvbHNhaDg0UXVLaUhuMUk0S2NrWVV0Z2l6eXVjL0p0c0pQSC9DdkFTRXFvTE9CQkxlazRDeElLdjVxdnplTnBrUkpFZ1JRMVcvQWdvRFBnTDcrSjhRMHlaOG9BczVQR3pkVDBZdXVNWG5BRFNhSWJTemNiRXpuRTlvbHVoanR5WFVvZVNNeWhVcDVGdGVYMGJEM2RobFFZWG8wYlRacDYxVVBacTI5WS92eVkvdjNsOHNIN2dpT3RkdkgyamU0Sm1oQTA0VkNDSXBENzYxWmM5NzEzZWxpNWNES1gzYU9kVHJIRHBzdUlXR3hPRjFVRTV0bWpONEM5RmNCQVl4UjVGNUFlVlNpQnI0dWNJRktDN2pCaUxrUkNBVXdIaTBSSXZhM0ZPMHJtcndwRXZuZlhONFIvUDdYZk1IQmttYWhBMmdGS1dvdVowb2x5VkJrZkV3clBCc0VuL05Nb3NhSlRUUEJDQm1hWTNXWHp0S3RVUmxhcFFLVmlGRzlDNnA3SlNKZGRJRWFrZnJyUkRGNHBQQTJldEFVRk1IdS8rcFgvT2F5NzYwMHZjWUxpdlM4cEVCZ1lDek9tTUl4d1o0MWhVTy90M2RzTDN6R3VCSGJSWWJyZ2F6a29sbHFmYVJxYVlOWmNpaW5naTVDalVjOFJZVlVYVzBNekQ3MWJnUVNoaGw0eWdQTEVQQzNicVZMbXE5cHJUeDZjNldFZU9UWjdXRTBwUlhpaFFrYjBCaUNQdXQyWmxwajNiZ3hvVXVEQzkyWjlsaTFkdTNQMXE0Vjh2Y3MzL3lvQm9oUUdjWmtDWTNQZE9aWFEwQ3pBT053M0I3dnpIUVdUZ1VTVHM1YkU3Lyt3QzgrTU1Beld6QitOamlSNDlvZWFmTGRyZWJQYlRVM0VMZjVJcmM1R0YvcjBMNFdHL2tOYUVvVFUxb0RtWnZWcUFTSUZsUGJEVlFmRHVoVk9rRTZ3cXJjLzZJdUl3UDc2RHJjZjFvQy9Lc2Q5eVZOMDkxM1c0aVQxZDhpUkZMVlovMkZrdDVVQ09KMVF4aklsWFdRS3pyVmZ5U3lMRFRiRWRtNjd2WXFKcVdaYTFzYkcrK3I5ZVQ4RmQyWjFRcy96UTM2QVpWL1U5U1NOT1pIRXFuQmFJU3dUR3IxVG8wRzdWYTkwdzI3SFJvMnVtRUVnNVdHZ3hHQmJxeUtXam1YVmtJN1BCRzZnVEpmVTZWcWxTamxYRW9KM09SYUtsZld4TDlmM2J0M2RlOTNEc0dEY2k1ZDFjUnFWVkpyOC9TaFdqa01iVG1YWXEvQ3hWUk9EdTBQN0tVdmpKU3h6czFCWDYxSTBPeDFpUVNWZHExTzZ0MWF2ZEp1ZGxqdm9CcHRHSFVqRWtiTjdmS3RUMHRhM0NtWnFSTVp2ZFNKTldsNkN1QmJKKytrVDZTZGZLZWdpVk4vUGgzSDAvRUhQRC91eERLWm5aVUpSSHp2Uk5hRTUxUXlNVUZVZU5BUGJvcnBnMUFjWlp0blVwdEVCY3Exajd1Q3U0YTdsYnNQK0lZUGZCM0dFVFJtRVAySXVQai8wek05MGlEd1dkOTFlSkg3OGEraU9ra2lPNTlQL3hoWFdMOUgwTy9mQXYzK0pNVk9FcUVtM1VUamJrQlRkRUNIcWRNdXZtUEVwVHFjQ2VBS09ucVJvcXFFNlpScjhHUml2d1VnbHhoNTBWdXdUTXc0a3lvWHc1eXRZVUVSTTZJZ2dFRHd6V3lwbk5WQ0VBbUNBQmNWQVVrOGIrZkNZam1WaVUwaVk2SGxpWVpkdTY0R3d0eHVQVisvUFRVZlYxTDNwc3NwWXBXS2pnV3lRZVdSSXhtRzZDSklSWklzSjQ2SmhuRUtIa3RWNHZuVTdmWHJGMzFlbFgyZmFNUmVITldwTEtaVFVRemM2ZzZ3SjNwenVmekpUNWJMaFZjVXNybkNHYlJXdWFQeW03OEpRUnpuY3ZFSXp5TWdFYnM3Q0NucUFGMGtacDFLVE5lVVNrR1RwaHNPYmVXRUloUnFKUWVKbkdEcmYwYU9vYnUyYnJnTGVqcFZ5M201QlVFcDJ6S1dNOERtaFRvSVM4WDBCbHJuN3h1dW5YR3NkemxleVhNTmJ5R1FyRkNYZFVHeUxDTW5DSnFzeUlvNXdQei9EUnIwM2R3NEIzalNZL2t6bFR1Z25hMU5ZU25USHJlTFdXbFJSTXdYa0lsbTBUTDZWdDFUaW9FbDhtU1pZSVBrTkUwVGRNM0twQzF5NVhSK2R1bGdrTUc1OFF6T290Y1Uyc1dNbGpaMVcvRWxjZFpYVTRRb2ttT0ZwcHZTNHF2eWZ2OExLRE9aeHVuSnpDZytWK25JcDlNZzlOdEY2L05yYTJ2em14c2I2K3NiVzBOOHRRblBFUmlQczhESkVsdUYzeDJ4Z3RIWkhERnlXbkJDbkc0eXM5Tmc4QjZkRzgvbHhuTmpPell3VkxyZDZIOUF3MitXRlUzcUNKSktYQ0xKV3puNjNHUHcwTFBzb1NPNi9RZjNJZ0d3MEw4OUtaTjkwQ0Z0a2RrRWs3S2t1UWxBcWRmQTJVQ3JyODRDRllsRVIwVUhCQ3hBUHBIS2RtQmd0WW9JY0RUcWlvQk1LM080VEFJTEJZbnFnUlBkaXFvZmRWb3JOZ2VHZmxVMWdQU20ydjhNUkxDbEdDaEFtb0xHSVNMMlgwQ0crcGQwUHFQL3YxWGJSZGVxMnQ3OEg2dVlKOUtka3F5SVU3d0FrTklSSlpuUE9wWWZtUEJGTFdRcS9mK2w2c2hHdWpxTGtDYi9WOWxBS1RoMlZNWFFpa2dPRmZUcDlKMS9nR0FVS2dwYVdTZmtmb2tzQUZyV0JiRjB3QWYrbUF1NFVSbXZBWjdKSjd4Qm9pZ1FnTi9RU09XMWFWUFNLVU40OHEwMzMvd1ladUZ6elBLa2h3ZkQ4SXZEYXhET00zTlUvMzlxSDljM3RHMDdFcmVPTGdBbkJ1MGQxR2c2bXdmZjJxRGQxK0oxd0xjNmExYmJmc0dlWnkzSHlwYllueHpvNTIwNmxnZFlqdklzcW5QNUdJcEpwNUVHeGlZS05oalQ4b0ZyVVh4YWF6Vjg5UEQ0SXg5LzVKRXpoenV5YW5nckxjdXlWRTBtaGljNHdkakpzUXE5WUxVcUVIMW1FKzNySEdiMnNYSFJBd1hyTDlubHdCRThnOGlhT255T3ZYS0tUZlR1NkFvYThJc0NZSGc2SlRBd2JIZUFHY0FBNUIzR0Y1aTlRSUdHVS9yZlY5NldVMFR6clBSbmhQeVpoRjRQbDk0THJXUktNcXIwLzBHU2tFZDV0a2pUNWpZWkg0dEFueTZDN09LOGdVMWlvSXcwUTVvMnBEeUovSWJiYUpXN1RzVjVtbW83RjJpd0tLUUVJYVhMc2d3RUJvNElYZkRpVUJXSzRXci8yZGpldG8xejNOWmdUQllCWVhDZEFlZTdORWQzaUs1Qm9sZWtSQzA3eTdyQ2E2bU40MmthZFBaUFR1NmZmQktyait2bW84YlBlQm5QeXlCMWRDajJOeWJwTXovM09tRGx4b1BXVU8rS1FkOVpZOW9RbmZkeFNveWNCUFFoK2pXaENHaXIzMVBSeDlXNHY5N0RYUGZjVjgraE0vMS9SWkw2d25QUHRVWFIxalRvYjlSUTl5dm9MWUJieDZGSEY1QlVoMy9vR0V5OGdhSU5XZ3dNOHBCMDJyUDhIQ29JNkNsWlVFa3dhVWR1NS9xeFkxa1RobC8xcmp2eUU5T3lPSzNPWEx0bldsTUZ1OW0rNmpBS1hJUU1UNVBsTUw3c1EyZDhnYTluN1ZUcFZRdXlycHJXMUdSVjF5Uy9QVHMvck04YThNT1l6VlVmNExnVk5MUkVBeVJPSmp1QWR0VHlWSnRDMUlnWXdlM0tZRUtRenBic1ExVDRicHV6RytIbStkTGNYT2w4TXlUenJubWVUbm5ZdkEzSVV0cDFPczhlU2syOE1EOVhpa3R6ODQ0VkQrZEl6SlFvemxNUk9uTE9Ic29POENYM1Q5QUhUQzVra2crR200Vm1oZmEyUGVEeXMxZnNMeFJFZTZLWVdac3RsMmRMYVAzeVJ2T3hpWEVwWEZsYWpSdXZMTkdyUTE4TnRNNTBoMGxtaldaVndGUi9XS0JVR0FJS0ZOQ0xkZUNwQzhCSHBWQXhESVgzeml3dm4ySFIvdjkwZnRITlpjZkhzN25ZVUw2bUdNWEROOTEwdU1paXFGZ3NVdTByandxRC9FNUNmaEcxdzNlRFpjVG1sd0g3UWo2VUpaQmdEblZCT1FUZzBpNGlDM1ZOeENha0NWVlMyczlXRjFRWldnQ1gwTkpDWkovSVRMOFpyU3o0RGtUMkliZ244WE1ZbFg1K3I3U25Ia1FXbmtMODlLTFFQdTNJYU05bFVmMzJ6bW1Ic0ZoenI3UzNGa1lHUHcxNnkyeUhsZXM3M05NTVQweXh1VERHOFlLazl0UjBBRU9yVm0vVDJVTUp4bGNsWUZkcGE1K0xneUFPL0t4dGkwR0FvTHNDSHJDemZoVmRHOUk3aGJ6M29Lb282ajM5N3hpNmFuM2tJNmFtbWFod0Q3MzJvQWVjbkVwaEp0dmVESHk5QkJyREVlNDBZTjQ3dVB1NTEzT1BNbTdxK0dSZ1FxUGZPaDNmekRZTFE0UnZrNkFidFFrallic09TSjBBbUlpNmNCbGdQSkFSN2dYTnFFd2RQT0IycHdGQUhtZ013NnhPc1NGb0hCRU5TVDJvdDJrRVVpRzBpNE51VXFmd0h4NkhGTkhuQ0tFekFMZmRKcFBiYnFNK1AvZEE1S3hNdm5mRlhVY0YwUUlXZFZUREttaDE5eHhGa2k1aEFZdEhDWThsaEM1ZWdVVWtpQ0wrQVNHYURJbUlDSDNVd0pxcy9Za2xpQVovcXlocFdNYThqcjZtcWFxbWFqVFVVRmRVK24rbkNoZ2ZQQ2dJOUNzcUtLMklWeVFuL1c5L3YvSDl4c0piTmFRWUluLy93aDBTTWhENitNTDlvRzFxRWlKWWZQM0NlUXM5K1AyRjZ4RElYb1IrNWpFc1FyRXdobkVpWTEwVzAwaEV1cXhRZzRhT0ZjeHJTTlJWVlFkTmtJYURmaHBEZjZoVEhhNDluQmR0N05pZkpWS2hsRXhjT3dCOVZFRHI3Zzd2QVEvV2JXMzV6TEptNjB0ekdDdThidXU4Z3ZIYzBtVXp2ZG5aM3N6enNxYko1c1R5OG9USllndkhkUURPZTJWZGwvY0NsTmFQTDF5SXAyZUtGNHJUMDBYS28vQ0xXOXd2UVhsaTdpQjNqSTM2S0xIKzBNa2lRZzAvTUl6S3JjcVFkemJ5ZzhtZE9kUUNwYUVObWswRWc3bEpsZjRHblVFbDdSWTExZ0hIbUpSbGlkY0VBc1FUZkE5QkZ4ZWc0WWlnOFpJczM2Y0RvTThiTnNKRXdhRERJeVFnSmZRVk9DQ1U4MzIwRVdkVFJjT1NlSVNSS0VMQVM1WlJUR1YvUnNjdjZJWWs4T0t0Yjh4aG5VNTFJSFNxcEdrbGJhamZBL3FubzQxTi9DWEFKZm15U2NCS1lyTmpDR1R3QmFiMGxTamV4LzdpcUhDbUVNVlBzcjg0UWh1Rk1GZWRndi9Kc0hEbGxZVndrcDNrd3NLdStTZHR4UFlPa21wZ1dWOTdrUnRnKy9zSFBnMVVLOW1pVDFmcDB4VHBRdDdvTnVxZDAvOGRHbTR4V2VrTjU0YVM1MEdTVUE4S3RMN1I2NDNpWncyUVFZVmFLYlpuMHBzSWNvOHE1VzVyR2JlNyt5aGlva2lJb04vVXRQNFo2UDlQOU5mLzhhWUtraDBGemN3Z3hSSDBDSzFyL1grQlc2cjJJcmUxdFU0d0FHaCtaa0xnaVFvOUs4bnZBdVQyd3NCdXpIVUdYQ3k4NUhqRlpENC9tWDlnSkx6QWtOem9aOXNHczg3R3dHRG1tekI0UWJrZWNCVTJaYmx6eFdIYURMcFhNWFNqVUEyS3hXRC9jNENpc1JWVmcwSWhXRUtXOWhjODJ0Q1YvcC9XN1NBN21kMnMvWDBFZlF0aEYwNVFRZlg0RXRyR0Y4eTJrOWdCZHJYQnJ2YjRFVzJERHI1MGZOQm02OG5oUlc3UWhEUy9xMUFQelEzdHU3UU5xd1A3THVwUmZ4MzYvVFZtMjJVZUpnTWRDbHI5WWE1Rit5K01JemJXcUtHdkU0VUI4YVZ0dFIzdVVWY3FPS25YaUxUTlJKN1FVbEVwbnM4WHNubmsycVl2QzVyR0M2TGpPazU1dG95cStoZnJxV2h1NG5zMTIzSGNzVy83cVNqNGhDRHJud2dFb240N3JhaXFrdjVlc1JRWHZ6akU3c3g0c001b3huV1pndWt3YXdiejMwaE9tMnY2RVIwK1AwOEQrb2Z1cG1IL1NSYmJTU2Zwcy91cGRzaEdYcE9PU3pLRkVzY3lLcktweVpDYUlqcHRxb013TzdRZlVrZy9rTmIwSDcxcnN0bUVqN0c1aVlVcmRTZVNYUkdEQkJDQkRVL2ZOQTJoeUFzeUZsMEp6MkgrU3VGaCt2RGtNeG5Uend1Z1VZVUMxcU84cXJ1S2pXMG5hcmNqQnlLS3E2djVTQzhJMkVFbzcrOHVjNHM3UnpVamdHS3QraXltQlZ6bTk2T2RzclpxYlZaWW4xcEJkMG83cU5reWVybGE1UkFkb1BRL1FEL1R4UGdzUW53bXpSdWc5Z2xJNTVISVl4NmozUDQ4Z2lNdkl0NFE4ZGd2L3djc0hCaFhiUUZVVlhvYlYwL1dJQlF3THlQQmxuU0R0dzhJK0EyZWVjTVZrcXlHS2dnbERDS1NWNURpZVpLcWl5QVRUTkVlcTFxaUNRb2kwVlhKOCtWQVFJOGYwTjIwcGVWVkx5M3J0bXhnVURmbjVqM0x4THBpNjNMYVUyM1pCRzRzcFYyOXNtdStEMUJYNlNkdXlmVWZzd2wvNHJhalBPWTVhTHVMekxNRkJsRVlGSEdkMUVrWEVFNnJRNTBaYXhVTHQ5ZzhLRFhoMEFrVTBQVC9WVUpTazBlSGRQMFF3aTA0QWFTd3ZLNThWblI4Ui95c3NyNHNQMzRzaHdWVWtsMDdqbTBvWHdrSk9IZU01NUd4a0pZZVhXa0VlL1lFRHp3cXBSY012RTJmWG1LTHFvWStFWGQ4VlNQVUJxYjhQVW1rc2xrU3Y2SGtsRi9oZFJsZEorczh4KzMyYi9CRzVRc3pyQVRVRjJnb1o4N0g1OC9IMjZMbVBEMjlkQzQyY2NZZHdJcUJvK3NBZmlRODdxM0FzOTQ2akd5Tm5pU1JrZlNvL0FxWWNZY05ZaXFYTmpaNld6VFkyQmdwZDViNXljRkQ3TnNrN0Fzam5uNHJYZmg2Y09ubW0rOHdicjh2N0lYM2hpdmh6WGZxRUY4SjRYdXZmcSsrMWpuZFdZZS81SURVMDZlNTRUeitKcXNYMVlucklPdm5tRy9sdHFQUGxMRGpCQVRNbGdlQ1VYZHpJRjB3bks2blgvUjRWQ3FINDdLOHBZbmpZYmtValNQTzN0cmFRcmJ6VDh6WEdQWHltVWVqNHZuemxld2JzcmxlcjMveDRrVzBPai9mcyswTHRqM1BQaU4rTjFBeVlTQUxVZTNqMUk1Z1U5UER4NGR0UWNzTWVtQzEzcHhGQTJ2aUNvb1loNiszNmxEY2hUcmpKVXRTQ3hEZkV1b3U4WjMyTWdLTktkcEhKOXlpSmxxNys1aDR2TkUrZnJ3OVdaS21TR2Zsc25zc2xHQWdaTjF6bVcxaGZQMjB6eDlZT3ovZk8zN3Y4WlE0SzAyY1BnRG9pZjdEUnljVU5BUGYwT2s1OEJvYUhEak4yNnVWeVFIUG00ZTYwRGtKbDgxdTRTS29wcFdnM2hXN0FZbEFFWm5xRlYyRXh3N3VlZkxKL29zWHJyNGFjVk5MUzBGNG9IclRUMSs0OFBpZXF3N3Q1YmpkY3h2VkpJRUFFb01oWDczOXVvMk4xcld6UlhHK1Y0TjNWdW5yTy96MlRVQWpML0VlR0V6d1M1VnRYNmFoUlFxOWlaQXBYaFQ0MDdYSkE3ZmM4cmFiZzl2b2ZQVGlFaUhUUEg4bXV2bXhtMjgrT0RuMmEyeVdtdHVlTjZXeTM2UHJBcXJ0THZNSHJUSEx2QW5xWUNXZ016Q3RaWjVPd2FDNDV2VzNaTTE3MkFoRVllOWZMQjBvODI3eHdOVDYrdVg3aXZlRDl2OFhudXlKMG05OFlIeVJoSXZUbGYxcmE5d29Mc3R4NDlSMmpNb21KaVkvaGRyTnhqTHVMdlBRR1NOQ2RTb1lEbzJJV2lRaWVxRlNybE9lMlEyYjZHcXZXSEs5TURYVHpNL05lY1V4SXd6UzA0MUMvdFNwZjZuVTUrYVdtNnFMeVQrZk9wWHZ0Y1VzY1BXeFNhUVpjWkRKNTZlOEZhUHE1SFA1Q2JkejZ2Ujh0WUpXNXZVVXJ6NDRkL3BVcHkyT2djNVVIL2pOTXpwVUFWOVFFTkZOYlB2MFFGRms0bFdlSEJMaHJzdjY1M2xSVWwrSEpjdml4ZGVCTGl4K0hpNmlOZjJCUjNpVnJKekVEcDFyUHRrRHZQaklBeUR5eC9XUmZJYjRsRTJEMEs2ZWhCUTFzTlVNZ3hDOVZxY1ppYnoxZXZoYUVuNjlKZktmcDVuUXFXdkl5T21kNUIxVWNQREpGWWRtTTlSdjE0RGVSY0FVaDdoVjdqcVEwdzl3NytCK25udUtZb3c4Mm9lb0pyS0U5K0hFc1djZldxQm5vRkFOUEhhSHRwaktObU5jd2pGVFgwRDNHcXBjMEVtRWw3aldaWDV1VFdvZ3JpelVteEh6RElCR2pBajA4OG95VDlYY2dRMDQ4QnZsTnZNblF2Wm15cmFkQll1blk1WTRvYTNtRFJYSlJGa3dmVE9uSTl1MlhkK0VlUCtGWWV6WDdGQ3RLTCtsVkZRM3VBSjVVUmFsMHo0TVppL01FclNGQkMzbGVEZ1NGUkFpOHRtTUljb3Y3TC9lYXNseXk3SmFQSS9oZVAySkV6ZFlUZFVVaWQ1c1VnTmcwN3JoaEx3bXkyc3BVMTJqRjlaVWZNbjVtaVJZRStPMklCVWlSWWtRSDZxMWpDNTd1VFFKOFRGWlZSVFJNRXhGSFBwN3JBMzZmWXRaMFc4Q3Z0OXUva2dpdHpzamRCd2JwU2tsWGFkYkI4Rk1UYnhSRjNvSFNjeW95ZVFMalFWK2IwdkxtU29pQ2RYeVdqK2gyTit3dzk4eHNnZ3QwQUc4ZENZaDFSc01XUVQ4Y0pkSWkvMGJRQTJ6eGFqUmF0SEt0c3pQYkZkN0o3aERyV2YwWGhRQ2cyUVV3RWNNZUYyVm9lNm13ZnhwMEVDMjE3bkxvZmRkRHlPcVROaVVlREtGUmpFTzlWK2hFMlZzMWNOQWg0WmpJektCb1V1SmxsTXBNd3JOSm1NUktsbFAxa3RRS0JYU1IrQ2RmN1JDM3pKU29lN2FudTZLUWpFWElzbjA1MzFUREF1SzdHa09Bb2htaGVtSlFzSE5GVFZqTEkrMGl1TldORlFveDJwUW1MZG1OSFZhY2pSWnhLNnErVUlZbFpBWXBWRW93eDljeURhYTh6T1Nxa3J6cHFNNTZXd2hjblhmcmp1OS9YckdYN1R0ZHVOOEVjVGQ1YktwR2hMbzRtWTlMaFR5UmFvSEQrbFFHSHBpdkV6ZGRtcjA4aVZWdHd0WSs2RXkzRERJZWRqMzFobStTbk1MM0JKM0xYY2I5V01aZXNXd3RUMzFMb25vN0ZHOVZvNlNLOVJoakVKVjZoRkhqeEhwMWdselZtTXVEUC8rTTRTUWowbSs5TEhrUUo1NkNwdjRxYWNFOVhmZ2dtekxjRDByU2VRTmNPK25CRkY0MTFQZUc5U00rZ1lQbnZpTjdUZXpNRjVIbjVBTE1uc0M1WGlGdjVxSER6dDgrUGh4aEk0ZngwL3pLbjlLRUU3QkFiUURZVC9QN3dPZ2ZPNjRzazhVOXluSHNiWHpsc256d2o2ZTN3djNieit1N0llSDRmNk9iMU5DcnpxMzhzT1UraEYxSDk3L1lacnNvc05YWHJMMmxaZXM4U1cxeEM5WnU0ZGVzazZqZnZUVTJoOUN5Ky9qRGtMTmdqcXBSa0dsRGgyTmVnRkhRYk1lZ1VSdjE5dDVQSVhwaFNtOGhOandta0pSSGJqVFlQbFNnNHE3TnVJUC9CNmFlUDhQdnJ4U21iVDQ2Z1JlR1h2NzY2MnFJcFNRUFdFRHYzQ2R3UDdRenlGZTBDUXBxbzk3YUxaOTE0Yy8vUHF2UERWVExRUjgvcjZ6WjA5dmZmb21OSGVOSXpjbWJUdXZFcE9RTi83ckhvbFllWHRtK3ZvZE8wUlM5b0NqanRzUlNJOGZLalR4R1hBQW1OYTdjN3RFNDdnMzlvZmpuamVPNXRwM3Z1NnJIeHhrZS92dDEyQ1dPTmx1MzhSV1UyRCtkNzBkN2FFcWtURHFSTFY2bVI2N05hQUVVS0JHUUNmck1NNGtrWEl0YWpCV1Jja1Uwb3Z3YUhoKzR6eGQwclkzdlY4aWl4MytnMDVZaUR2cG1iZjJ2UFNCeGZ3ajQ3WFRvaUlKKzA4Sy9sUEZqS2dLdWk0ZWo2ZmZlWkRzRzllUWd0YlorNmxxMW5CRnZyMG1GdmFFcGFwYnV0eHBuWk9YWnE2b1lHekxIa1pQcTVOVkorYjVjcStjbVRvcUNFVlM0ZVJMNmxRRTdETEw3YUdyWlM3MVg0UmlBNE9KeWxCMGlEVWJoUEtoRG55Wkp4TGxxeUJrT29sYkRQeExESGwxa3FxOStiRmJibm5zbHVlSk5CNmwrV2t4S25tZXFFN2Q3SVh0L2M3ZlMrTUVJMjNzbHQ1NDVzUmVRVko4UmVKSk9qdGJLZTBSQm5WNzRSYWF3SEhYY0lPNGNwMW5sTk5JRGNkdHRQanFab3hqaFJSNUs5c2NteVRZazIyY1NxZjBzcGFmeWVDa3pReW8zMnVZblNqTnJQVjBYUWpuUmFSZVJOMDZkWk1rOVRiQUNWSVBxQW1lc3FCdU13S0FRU2hyNjlZZnVPckJrOW5XbWZidm5UejU0SVB3dmNvN2U5YTc2b0hXdGUxTys5cldWWENoZGFaMUxYck53U3RXOEdSNzlxR1ZadjN3SVJDeVZ4elUvWDM3ZlAxZ2U3bzdQYjA0dFFwWERyWW1GOW5jNDA2WnRNVHVSOHNUUUNHb3pqTEltWllyb3JsREZoQSs4QUE5cnBZZmZMRE1NbnZUOHVVSEQxNitmT3dQSWQyL1BoaW1EeDFLaDRONXBrMkc4Nm4vUXBNTVZVbm1ZdzBTQXlwSjEyZTE2R3FjTnBXbE1IaFJRTUVjWGJDMTNwTVhyNW1abVZ4WUxIdmFwRERqS0ZyR0haKzJMYXRRc0pvTzRucWJtNzJweWFtZWJwNkpuYXF2NnJGclY2YnMyTDU0MGQ2MnNTWDV2MlR1dXpJWVRXN1VoM1lGWlA0cDdoZUg4MlFFUUUyTE1oSTI4ZFNwUTZtcFY5WVVraUxtR2ljbHdLQmVwcDV6bUxrbDBqbS9kc3NyMThNSVZMMWFmYkJlc2hXTkxJNGNYVHBKTDFUYU5VcVVCVGlqODkwcnVKRk1oaThrTStKTjZnWklGYVV3ajZrTHlwbkxCRUNVczNzaVZSZWpjcjZUTDBlaXJrYUxzeHF2bTJuVG9NczJWQ1JsUFZQV2hFUFh2dGQzdmJSWThqU3NXcEtFdnBEeHhtMnptQmtmdjNwOFBCTWI5cmpsSzRLc1lGOFVmZVFaMVlEb1BFRVNueWxuc2xrSWVBa1JYaWZCVFdJT2JiejkxdU1QUnpxYWN2T21OTGQvTEpPUFU3S2Npdk9ac2Yxemt1Wkw2UkNiY2tiUVhGelhvdGVmdUxYL2Q0cXBTUEpSMmRaRUJ5TnhyNS9aYzNpMk5oWm5YY2R4czZWS2JmYnduc0JSZFY5RXVtMGh2WFNnbGlzV1pZeENTUW9SSnNVNFY3dkhONXltcEExc3pFazcvZCsyMEU5T3g1Kzg4aHpIamZpaTFFRjd2Snk3ZXVqYlE1ZXZGSmhmZURsWmhFdkQ4dkJzSDJpdjVjVFBoeUZrYW5qck1NUThYSjQ3YXF2WkhKdXlUTmN5emFQTDdUM2orY08yeUd1NFBodVg5OTViT29RSm53ZDFjMktzSHJsR3BSQVpXcmtRQUpnNzZhNnV1dWhWaFZxOVpDbUdZdXBXenE3dG1TelVVbzRVR0tLRjVvdjFYTTdkUXJJOWxxMFVVMjc2OVVZcTNtOGJxZUkrODVCNzZwUjc4dVJvL1NhQWV4OEZwTVoxZjZoYXc0WEcxUFVkS204QzY2Tzl2KzVIMnd1TmFjVWlxT1JvcGJ2Tm5UbytiMW5Xc1FPTCt5ZUxIUmtKaytsVXBicm5wL2Nia1cyWm1ucWZhYWNkVGJXY3lGT1ZuL0lMU01UcGRHMTZyRmo1OE1tVDVkWFY4c2QxcytDTTc1c3RqcWM5d2RRSm4wbVZKdlA1VXJib0ZVSGwwQ1FpUDVKSlp6WFZ6MlJ6aHZZRE0vU1JiT2FpWE9wZnlxZE9sVStPWWl6S080SGpvSkpUb2dzYW95YjFnd1JaajlhbzRUL3VyLytYbWQ3NHdibHhkcjdXaDFkdWZmaklrWWRQai9wNjh0U0NBaStYVmxDRjFDc0FEdEI2Zi8zUGV6TzE4Ym1ENHpUK3NZZFBuMzc0eU1CZlpQQ094Wlc1QnJlY1dOL3FDMnkxQWhzRlVTUHhNV0JjRlNKTjBESXVjYnRpdmlwd1JoY2V2TDdielJpMms3R2Q5K2NxM1p3djQyN1hmek9iK3RnMGZNOUVTeGozZngvenZXY3lqbTQ0anFFN1lhMTY3cGFxTDZpM1BaUEt2Y2N4K2w4d2ZOOUFCd3ludjRIUmZuaitTL3lnTHlRNGxQb2R6ZTllQTBtTFFRMTJIZGFkZ1NYN1l0S2pxUjlTbTNtekRjMldTVG5PZE8yTUF4L0VWWElGdjl2RnNwOUQ2N3N5MzN6bW1TOE55dmpuNTZxMVhPcVoyMVRCcjk0eXdCZS9DMlVSUWRJdGNpZTRHN2lIdURkemozTmN0UVc0c0Z4bllkVW40WFpuWmZRRVJ0M3NSb21QRjcxY3A1QXFXYlc3cytZOTBmeG9OVVFLc2FoQ1JLamxSK3dzTVgrVVdieTlZbzZDc0VFdnAzVU5DUU1vWGJpRStGN3ZzVjRQSGN5aTExNTl6V3RSdGpCdWRJK1IvQms5NzJZeXJwYzVuRHJSTm4zVjFDVnlUSlI0VVFBOHBVR0t2R0QzTDVoYVJsR0pKQWwwaGRpcEJoS1VBRXNpYmw5NXNtMEZpZ0R0ZmZMSzE1aXVvU21aaDR6QzNIekJTRTJNYnhTTGNRemZ3MFZUVlBhdXJ1NVJSYlBvRjR3YWY5YkpaV3FRcTNrbFh6T0lwSnUvQk55YUxxL1JiSjRuc3FUWkg3TzFRaVRSMVdtUzlFUjVRWkgwdElza0FWV3J1cHZXSldXaFhIMVNjVTFYaWw2bEZ3cDZhb2hiZjVmNU5yZTQvWXo3M2NUZEFTMlFVSDJiNk0waDFmZWh4S0pOSjZJVHVvZGlRdDdBSHh1c3NTVDB5RG9RSU5wNk1tbE53cDFPdFUxcDlMdFo5TkNIS1YxOTErb2V3OFViekRUeTBta1BPUmwwV1hoaXdmTDhmUDgyT1NDeWF0R2xIS3BxdnVCbFBEZm4zZ2JrU28rN01TRkc0UTUyNVNuTjFHUVNmSWtTYnMrcGhIQkJIZ2gzbDVzQ3drV09lVXlzR1BtSnlCVXQxZnBsbXBiNis5UWZCN3J6bTRBYXVpVHBoVlYyYXBnRlVMY3QwZVYyNmJvSkRxNHdXbTM3YVEweGNKMHRRNmhWb21UK3BSNFVVTVFQcjRWUkV5NEdZV20yQkoveE9KV0tVL1k5NzE5ZFczMkJ0OTFEazlYeFkyZUZ6UTk5ZS9YaStuZGZJYzFMZi9UdU41MW56NjZrNkxQZmZQODlxMnNiRTJPVGgxeUxueFBPSGtQbnYvMmg5WXNuWHZHbWQvOFJQRDNLKzRaenhZUFN0UWNsR0I2VEFyQ2NXVzVKTHAraTZUOUhrOXlscTQ2QkJ2TithbDFob25Bd3FwS0ZiRXhqR3NvRjZ1bGJIL29HRGtacmZXVEVla01aWDB0NFNETHpOcnFCeGZEZVlKY0xPaXZuRDk4Wk9OUDZDVDVJWnJEb0lvaDdpMU9xaFBuclZreFRVMnkvT0NXTFBEODkxWE5sWGZXQ1FrWU5UOXduYU12VHVkQjJJV1l0ZjBmTFJKVjZ4dE4wbWVncUJFVFdyZENpUG9aQ0lST0dxcVlia1YvT1dyNm0wdzByTklVUVFTRnE0QnE2QUFNWFBxS2Z0a0pWdDlIYVZNRjFOZDJ5bHE2akMzQ21DcmF0YXBhek5EMkZNZEZpRzk5elBMTEQxUFNTenQ5N1hFOWxNOU5ML2I4SEFXaHFsdTBva0wrcnlJSkluVVlsbVllVUZkVUFpV2JiaWd3Wks1cWlxd1JpeEpTb2tRaUdNNmFMWVVVUkxzazUxeCtSVTFudS91SHVKcnRvdnUyclNZYnJRUWFPNW9PbEpFa0xYTEtEeVBZTUlXdUFJZjNwcE1ud0htMDA5TkFvVmFlTEdUVTRjZC8xT2pTRGIyWjkwZUtKRUFhUlRCU0JFRVcxSmFMcHJwVXIrWkdoYTJvWVpnb0NqTk5NeXRJVnVsTUl0QVMwZytabFFNaG0zcitiWkl5TUszYkt5OUNta0VRRVFCZjRuVWtrVU85RlcxRTFUVkVrVVZaczJ3OU5RMVZFNkJEQUNVMVhGR2o3UWNxS1kxdWFxV3JEZGRVY3VnQWorQXFRMElBMHBaMCt0Z1JDT2ZHdlo3UGpBMHEwQi9jVHY1Vks0bTVPUFZwMjlsbjUzVktoYkVaaFBraVpBTjduZzhEU1pHbDViVTNnTmYxZ09nUzJRNFMxdFZoUURjZDE1d1hlTWgwdjY0VjJ5ejlnOFNKUmdHNVcvcDE3aWFOSDl0VDUzaDAxUlpYa1NsNVZGVnNmZnlnK253L1NsaVVYbjhyb2lnRXNTdVM1N1RYOFNWMStySnE4WENsZnRpUkRUUFJONkd1VDNDc2h4cHlrSUROYWUyQnF5V0VKaFUzYTlaaUN4RVMwUkRwa0dYWEpKS3JVT3l2SXBEQXFFUk5GeEFxYTlDaElpRHBiUXZHcEJaK1pQb1k3MVN5aE92cW1XM2ovbTFZUDJlU3lkckdoNkpKcWwyYkNjTXE0OGhHOGVIVytFS3VsWWdrcFNJRE9FWmdDS0ZCWWxsSjBLYmNZTHUycFZmRll5VmpVZGFrY0xpMnBXcm8rVThtV1FqSTV1ZFNjclJSOEI2R3JjNkYrenpQVGVCSlY4MWdBbklQMFhEc2QzU29SYTJLeEtIb1ZqMDlEcjBPaUlXZ0lZeWt6WDVMMEFQRjVyNnFUcVhRazhVRlJVQU8rakhLQlRwQ1pDdXFsNXV5c0xnL25IaE82L1NSVSszSHEvT09VZTJkdTc3ZWhERXVKNytGZ3hjUjJaMG5HUGxzSDJ4MnloU2pjMlN1b1J2VzFBVnNtblcxT1FUMWtJNThrUzFXMjJRUTlUTkgxSzVoRXkyaUhsNDhtaVg1YmpieTRVU25IdXBYMlhOV0tSSlZYQURtSnVlRHFnaXRuTFYxeWlFZ2tXWUNoSHR1OHFSSExNY2Z6TmNNcys3NGlwaFVEVkVWYmtwMFFDWFlGeWJ4aTJOQ1ppWTU0SkttYUl4bFpGSlYxREFxV0tpdUtMbWhpUmxkdDAxRzFWTFhVS0tLVHM4M0ptY054U1JPenFYcjNLdE1URlo1M3MxZWtjZWpWYmt2Ymhpb0tVbTFLZ2NJaDBpbjRndjdHMlltMHdqdE9FVVZPcUU5T0llaG1ydUZGUjBSUHJKb1dEcEJmVUhsTWtFZzA0cm5Yell4RnZpQ1hDb2NuQm5ZUEVkcmdMUlExN0xUQUR2MFQ2bmVHbE5vaGZZM1ErY2tvM0tIWmRIWklNYUl5ZXNXdUxnR3pVelJ6UUN3M01NZURQWFo1cDVaMmJWaExVV1MxRkxOZTdSNUhkeHg5dTVwSTdoUXNrRXEwdThqYk92elFCdVVOL09EcDZwS29HOVRiWkhDc0FpL3NnbTVsb2VTSUxuN3ptL1lQNGllZnRKOGRpWDcwaWZoTDN4ajdkZnZoOEpjK2xYM2ZONHBQZnVWYm53bkNOL3p5ci8vQ2lGMW5tQmRYaFhRck5HMUlqK3B0YVBNSGtCb05QZ3VKUUFMLzVWdWY0ZUhWRWIzTGdCSVdFczNXSGV5OXdTYjNXNUVmUm5VSmhoV0FGUXZSUGhnbG1JTVpuV2hYYm9SMC9haFVrU3BSZHc1QWJhYzV2REF3QjdFZE5zNXZuTWZLVFQxYldUM3ZkYWF2c2I2WTBsQzc1QVU1MlY1MkRCTW9pUnNIYjI1aUdjMEtnTDVWZGFXV2RTRWk1SnhaUVlRTDdhTWFEcEZSUit2blYxVzdkNU9NejIrc05rNEgzNDcvVkJBUWZzOWFsL1IvYTIrY2lsSVpTM2RucmtRQTZOSG5IemlHWkVLeFBmcC9KcSt4NWVtNnBPZExEK3llVDdDaDVtZnBIaEYrVkI2T2JORFF1d0JIbTFFNUdaWHRWblZJbFRKaGV5N00waFh1akFIVDZ0VzdqVTROU0ZBdlM5U2hOQ0tEQzFOb0NNZ29ZdnRpV3dGTzZPdTJra25CVUV1L2g1ZUZtMEdQbjE4UkVYcVZpOG1lS2JnYzFnM2t1Qmg2bDJrNHk3NEFJenZuemxDcUtFcTJ0dUl6cXJobFVkOXpjNlhjcU1BYjhxZmVpMXdNU1dNSkgvMDhlaEVqLzlxMlpGU242NU9xUFgrVmo5Q0JCMHA1ejhraVY3Y3lRS0o0NzI4TjZYTHNnYzhEdzhlS2ZjVHdacEdJdEcyZWwvaitzRm53TGdsQUoyblhROXI4SWFHMkRndk5JYWhlRWRHNTZpV0VTcTZ4cms2cjlMdTJwbDczYW1RcE41am05WXFOWG8xdEc3MVIrUG96Z3ZETTF3VmhZMFA0OHJQNGZWSDBQdnlzSUw3Ly9lSWx2a2FYNW5aSnlydFRHclFqNXBpdjIybnVGZkErYUZhRXJVUEFVckRnUjNUK1BOeUg2UXc2OUY0MnE3bUVPKzBGNXJaU204SVVkME9YcDgwTDRvVzVEUU1FcERJRllCNzBjYjRkSVVWUkRwMUR5RW56dkFuUUZkMjlyR243NzBYSTFrMmVUNE1RUEhycmE3ckZLWjZmS2g2OVZkTnVQUXB4WWJKNHpTdVVoZmVnTlNFUExkRHN0SnZRTHJZaENJYnRJOXhzZDVvSSszays1dWZLblU2N1U1NFRCSWkxSzBmSzgzei9iNzUwKzZBZFdOMnlkSVVPM1dXRkZuRjNBVEV0dnRpdG8vOURzNy95ajY5TThqNTZtNkxjQnVYb1AvK2U5NkNwenIyajZkUFlQNTI5ZmNUV3FOQzlDcU02NmRaQlEwV2JQOXQ5NXp1N1AvdnhWdnNIZDE4OGYvN2kzVTgvdmR1SGFwZmY3a09hMW4rZnBsRm5YSHE0bC9tS2N3SjdkcEx0YnpSQTFOMWttejRvTHJYblZkb01MdE0xVzNScFg1c0I3N0d5MzBpNXZ1U0x0dGMrcW5hMTgrZnoycmlnamtrOHhzSmRwby9XNHZpTGloL0tzZ1pmd0hNQUswajhnbzMxeVlNRlFjMEVlc2JKU0w2WitYQzhZNHQ2WTFLTzZrQzNZdm9WaUE4WTVFRmlSK3BRelltT1VaTk9xOEZ0b2RFcW83dGZyaUQ5alRqKzdSK3pJT0sybjBHSjdacVZyQWtERWtnV3BsNDI1Vms4eHh6bTI4TU45Z0ptTFlJN2ZCTkFQYlVkZFNzZ0cyOVVnQlY2SUdzTTQ4dUdJU1BrSVY1V2J2U3NPeXovaVhYdlJsZjIxZUNXOExUcWE2Z1hJMTc1YjREb01RYlY2UHNTejhkNXVnb3ZuN2Y2WDJNK1lwczcrR2FaK2FKUVd4WXpZd0dIbytzd2x3VW9TNEZubTBZQWVFbVdsQ2VHQzJEemFGbmcrOC9MMUQvVGJoUFE0VER3cUx2b2ZnY2k1a25iNW5GSmw2Q0VtSkRuTkFGN1NOTFJQZzByaGt4Tjd5SWdjVkQwZ0dvU2tuaFpiSW5xOTRuSVE2aEkzS1crMXBlc3dxR2d0N2E5OGlhUEJsdHZWWGJXNEV6bDFiWnNzOVUzaU81OHFHeXZ3Wmt0dEFvT1czclRTQmJqY0tQN3BCU0grNlRRR2N3NmRmZjdFZHVsdkdwK2RYWCt6a3UzVENsWEZsWlBuMTY5Wk5zVVJtTWIwajhQbzdoQjUzcTdkQU5GdHVFRjM2TE9qRFUyWWNvV0Y1R0JNU1NxRFBiYTJvZlJWUTg4b1BTL3FDalBFZjdpcDdPMWxuSy9GUVNGUUR1a1FSaFkrcTJJSEt4Y2YxM2xBR0MxN2pOS2pTZnp0VXo4a2FEZyt3Vk5LOUJuUjJ6WUlrajdnSzZZN0ZKdnJtNVU3N1RxM2RBZkhubjRFb2ovNGExMzMzM3JvcC9OK3FWeU1EVVZ6SXYreW9xL2QveTY5ZXYremE3ZFZMTm5YM21UdmVlOWUreURHd2hacjNqK0ZkWlZ2eitvNnppSzBYVXNuMHZ5R0tTWnkvbWxKSjN4NjhZaG5hRThIa2NQRHQ0TGZsVHBSbEpJU2pXYXpyQTgzSzcxb1dLeWYrVUtDaURGYm1Ib0pUYmNFc0liYXZkMG80ZEtmYmdkQk4wSm9yMDFOM2ZnRTNTbmh6MU5SUGQrMk5Nb2xwb1RKbCtJT3pOSFQ0eXhmUjhLeGU2TS8zZk4zMmllL0NEYjFTR0wyQ0hYLzlac2UrRlVRSkFXSDZzTTlualFZdi9LYmYvWUhsdGpOc1p4WG9GUHpMT0o3c25BSzNWdGlIaG1YUURRRWY2YVA5Nk9iems0ZVVWQU54ZGU4ZXV1Z0dSZE5pZjJ5Y2F4aFJEOVF0QTRlY3RNNy9wcWJOalpuSEQ2OXVLc0x5Qko2cjk1MzBUZ0xWekJ0dEVabWIrblZ2WlppdldLeU1MMUdxZ3ZjN2dyUmp0eDBHVVdHb1JHcUp1YmhjNzk0QVpWalZYbDhIODhyTUJSUmJkcmFrbFJ4OCtOcTBwSjFmWWNWMDZkVWx1YVhpeFVzcHJhUm11blZRVWU3L1hnYVVVOUFlOHFjcVVpd3pXMXlmKzUybEpWMzFmVkZoTnZMMzZiK3dMUW9rcjNnZkpBNjJsU2RUYWs2NWNyMFdCWjJmQUFYTkNrTGpqSmFscmdUYUV6YjRkQ250ZHNQcVBNVHRtV2F0dVRNeVRMMnhyL1dGZ0l3d0thMGtLRUF2MXV6UkRVdFkrOVJWTVU3UzFKK0xFMVZUQzBMN1BsYXNONXJHUy9CUW42b0U5OU9WZFF2UmtBMkFFa0VnQWtoQjdTamxZUXFaTjJrM3k2MTFodjlISTVlamczRXY5SEZ1L2xrc05PZkdSdlVJV3VxWWdnVVVncFducjB2aWVldU8rVzVkN0cwcnZPci8vUmZXZVhCenhwKzlrcTVGeW5qd2NvWHI2RlB2M29VbS81N0gxL3RINytYVXNidTUvMUNEeElIY2JiRzhOSDBZOTZGbVFRY3kyUHVpamVHQlFEYlJkakJCOUV5VjdHVVpQVW0yM21FZ3VIYmtTbEZOcGN1eCtkV0ZzNzhjcTF0VmV5NCtaSW5CNEhQcFhKUGhhY3graVowSEZ6dmFGOEZpaXpEdmUybzZPK25pNDhIelIzZGdlaXMrcEJmZjBIc3R4L1RwWi9zQW5QOU9RWFpIbGVYdSt0N1g0UHNTbVhYYStpOWZYTjRhdUlXK3V0dzN2d2RtOW5EalBaQzNuUTlvaTFkdGRMV2hzZ0ZxVVduL1FFdEg0MUZQYnFYSTRlK3MrUG5LQno3S1QvRkR1N21nWG9IRHZaa2JmSlhnTUJYVWVYdU5aV3l1MHFkVG1rbEcwRThnL1dvWTVvUFRrK0xQZldvSnFieVNGWlh6MlFqWVRwbHROMFpRclFsZm05ZGdlcjJHcDBUWFZqdUkzaXpqcm9XcDF1VU5CcWxzcUVUbHV4aGJ6dDFSZnM1K3h2MnZUdkR1cFliZFF5ejJWcVNsU293Tmp2L3hPUEJOZDgzbkFRdDJYYlIrWXB2VmZ0TGVhQmpUSm0vMkttVnN1Z1prcmx6Y3k4amFSYS8wL29yTUNJSGp6RmRiaEQzQnIzTFBkNzNCOXdYeDMxZUUrYWgyNXVPYkRnTkxlL0RLY0ZoTzZzVldZd25xMlpINmhkd0tDWk9URXgybEl3UjBFZEFSbmFhZ0JjR2s0a2s4ckFQcE5ZdzRIckR5d3c1VUZLQVAycGp0QmN3Z1A3eXREU1F0VzJZTnZLM3RuSE55SW1xYUdCT21PdGh0K2dTL1RYYWRWaiswWE85bk4ycmVVN0djLzFvcXhISjB4OGZWRzJCYVFpbms0b0NSQjR2aWo3bGZGQVVSd0xzZVdCK3FxOVhrU3VhYWlpSm12QXhuUURjSjRrZ2k2SEJFbFZiREVsbXJicElsNjNMWUJ5a2hUS1JPY0ZHVW1DUmxQUW8wQ1RCUUJjOC9vaDE2VExvL3RiOWdVYnhiWE1XcWEyYXR0L20vYzZpQlhITjAzYnJtV2NIRzlmb0QxL1hzVG9CR2pjU0tZcmNZN0VwcEl1OGFwQWpVQXlzR3Y1RmJ4a3VxcUlNSzhwQkVHcGFKRUZ5WllrMnpWQlZiU2tjc1hPUkxHR0JSV0Jjb294alNBQ1dnN3dXbUZyelhRMzNGK2lmV3JZNzdsazd3dzlXU0ZXYWJlYVBOMkIvMW5vMi9JbTRHTjVjVkh1cjZQNS9uTnJITGQ3dldDSjdzcERkOTVKK2tzejZMSVVLSUtuUTJnWnNiMk5ndnB3RVRyZmJML3dITjE2OTdtL2w1K0xuNU1mUnJud2hqQ0hZcDNjUVBUMWkvSkZHVDdyekhWWUxnYTVYRkRNSWFMclVORnNsdUsxYlJrOWFyL1pXYlBSNWZaeEs5eGwxQTQrcWcxRndCSEo0QnNOZmlkZytQMzN6dEc4YlVQajJUSDdnOEhPamttNGZkeENHM1ovRFRUcURmdmljRHZGdFdHa043TEhJbzJ2cmEyenlPcnE2bTVNUktEY1ozYTgwSVRCeGtaMGF3dTYyZEVzU3JZOFlrcGFSQ2dFWVpzaEFSNW1HeDhWVUxMOUVWT2U2b3dqRGlaTzJOWklnOFU5MThWcVZzNkN5SXBSQUJFMWRtelRIcCt3SjhiaDZMemN6WW1IVk1kMDdaaUlnNlZCLytQSGYvZVNtNStLTGJwNStLRkRnc0w2MHlMVS93aFhnL1k3QWpMTkVxWVFtVUwxS2JvUjZrSzVUWjJjZC8xVVFSUktnejBhazkwZm8yVFI2UGFta0d4SHlLbVZ3U0lWak5sU0ZZUlhORTAweFlwaUtoVTRhaC8yeVhrQ0g5OGt0OTVLL2tOeU1KT0xIMTVCMjM4cnVpYUs1ZGNSVlNXdks0dWk5akI5Qjc3d0tMeEFmY1NUWTNLWjZaVkpmUkxiWDQ0aXFNNkFOZEh2djEvMjlma1UvSC95WmNyMzlEejdPLy95UldIak95bUxUZmNmNi95N09iLzNaZkpjZlBuTWRtVG9FdDJmc1VveC9jQ0luamh2RDM0U1lGOEM4cnVnUmNFRFRlRGlnL01ndWRBb1lKOGtma2RzMmdTdDVLcEJWRE4wUVZORG90K3BrNGtnSjZsMzRJcWo4WFcwaUhPNXJLL3MwVTlJZ29qY0tCczZ4QlJrK1F2aVRMNlF5b0NRTkh4Q3hocVhUWnVTbExiMFFORGRXSmVBcFZwaDFnL0d4SmkzMnI0ZGdNNXVQMGJOY1h4Y1ZteGgxRGZQQVkyQUlYTXZHWmtqVTVGazZJVEJEUlJEajg0ZFdJZ3R3Tm02bVk2NGJCWmtrZDk4dStGbFZDb3piT29kZXY1aXg1WDNaeklzVElZVHFETituS2xsc3oxYnpYaUcyMy92d0VlMjk3WlFiUVhCWTc3U0NyYng4QnJncVczYk11Vzh6Y0Z1M3ZUWFUzcng0TCszdnI2MVJkY0ZYN0wrejlqaE1yVGdGV2ZBSE9iUG4xOGRETzcrZHlIdi9qcnpFeGk4NXdMSHBmdDdmd09oeE9KUEc3UmVrZHFkTGlBQWFwQVlHMjd5c20zeUJ6S3dEeVZZdlNXQnFKZW83Ty9TQlV6c1ZnZEVlVlJBUUVzUS9kU3FTK2dFRER6UlhCWWgrYUdsdDlsbzBuMTVnTG84WFFBS3ZDRWs1UnI5UUNjSjJXcG0zMFQxOGl3YXpONUFuNVJtNmZMUXFJQ0pCSjJ4Z05oY0JIQkphdlVkUEZSbUswanAyb282ZFltRW9WRWJUaDEzT3dES0lLeXovQ1NvWGRCa3I2UERFbzhWdWhXZ1JIY1hFT1QwdnY0TGpIN3ZraVhCUzgzVXNqWlB4YklzWXJvZE5jS2FnZldBRitqZUJOUU1BNEVqRUl1SE0wSGlSU1VVaVlBTU9rVU9tRVFDVE1LMkhTUjBOd3FjamdXQkFNS0FFeDZMU09LSkpTZ0NKdGhBV0pWTVRVU0NnQ0JObkpVY3JDRTZhUytwTG84TW5sQ21aMHFpVXBld0pxQUEwaEd4anJHSkJFQU1xaGlKZkFrVE93MW4xTDlINFdWWEJGSWd1a1FZY295Vk9vTHNNRnc0YUxBVnREeVBKY3BLQVFYdHlYd2s2U1QvQW9VbHZHZ29HdmF4VkpJbDFSQjVYNkpyaTRIeEJuekVoeHBHQ3VPL3ZFYXhLU1NkQnR5bEl3SHJDay9aTXcrNUE0eWgwNUVHc1dVZHVMWWk4S0lrdVFKZEd3ekFSMUlBOU1pQ0traUVyakNFTWhFZ3U0bVFwaUhrcUpnSE1rc2FJaklRS1pCd0NnUHBKVU5BR1VpYjd2Vmc4blpPajdDa3B0c3BxQnNVQVN1eWs1RkRhQitlN2dVaGVIejdqWE9BdWVoZUlMdjJkVlNHL3A1MDJML3EzS3RlOGQ1WG9JMlAzbkRqdVhNMzNqQWNVM1IvaU1SMkUrejREYzZpb1k5Y2JXQTgydWpSdjhuTzhYdVBkKzQ3T0RkM2NPN0RoK2lWUTlyaGFib0NjL3B3YVk1ZTNyWGZUY0QyamV4MHFjWUFZNk84QUdNak1kaUc5WkVWOCtoZVhWV3l0M2VQVGlOc2FaNTUrOElVNkZTMkxDTVZDNjY3c0pTcGFORE1YOUo5M3IzcDFFZllyeCtnaXpLMzYzZVFPTWJqSXBwVkhpV2VLZ3ZVZjdMTFpwWmd4QUxPb3dDL0M0QUtSaTF3bmZCa295cEt0aUpicHF6YVdwVnRrcUxJUUYwVitycWNRbFBPaEFOZEhuM1pzQUM3cXViWEpkR1pzR3JaR2VVaFRVVVBQWVJVN2FIN1J1bTliL3NYTmdCUHNzRWRSR3hMa3lKS2RxTUR0V01Gc1VsRU9tN3JnL2xZOWpzd2ROM2ZYa2xxU2JycTZwSk1mL1JHT2kxcGhDaEdORzVXb0Z5b1ZtbzFRbHUwUlVXUjBBYmNsVXlWRjMxMUVick01Wk4zNVBPU2RPK3RsOVB1WHdCSkFiaFVjdXltR2ZMSVVTUnBsQmRTVDB5Nm0rOGt0V0p0cjZXbUVJMnRCQmh1Z0F4QWphb3ZkUWJPS0ZzSjRZU0t0U0VjZTYvZHFudUI0OGtmWEYxY1hGMDBXL2FTNG5pZWQrL3crbmVIVndaOE9hZ05Manl4U04vNDZ1Q3hwWDhkWHI5L2VHV1hUUXRURk5JdEVZL1pVZm5CRHdaMTJ3TkJSdGl1R0lsakRkdmVQa2JjK3M4WnJpNzhHOGhMaytvUGVEcFdUSUZ5aDhMYytLSUlHc3JtRm1yS2xtNDdtZ2tqWENSSTB1TnBvUWppVjZndGpsc1dERnlRRkxSdE45SGxhSlB1ZDkybGtKWCtBMG1ZTVJ1eURZdjgzK0MyZTh6MWpycHRmRGYvWUFaVEJtQ0l1UWY1VldOdlZ1bDJsZXhlbzlLKzZ4T2VteFZGYTN6enJ2YXczeVkrMmRUdlpkdXZyOE1XTzdmb0R6T3NvRFo4T3RDRDI2MDV2c2I2RHR2aW9nMUFpSzBJYURaRzIrdkNQQkIxbm9nYVpaN0FHQVg0QnhZaUFJL2xGY1cwTFdCZlhiWTUyYy9sTytPTGkrT0xPVHVOQ2U4RHQ1Vmx4cmpoU1dCdmxDdERUQ1FpdkkxVGd6UFhFM2piUDdYOEQ2Ty9XYkZGZDB4bWF3Y2F6R0UxOGE3dHRsaFZsakgxNTdOUTNCR2d1L2JQNmE2cmkyZXo1cGoveEFGaGFCKzVoYzNSRlVFRG9pdXdRcDg0UGpDRkd1QitVTG9CNVVHTDBzSDAwdWZ1enFrRHA4NnM2OGFtR2E5WlZ1dzQ4UnI3alkvNFBBdlJ6ZktrM1A4SFVITkNOVlpEMi82NldsYXZ0ZTNUOHJqOE5kdStSaDFUdjA0dmpxblhnTTcwM1RFMXNPMEF6cEFIcC8rd3N3Y0I1WmQ1T3JzN25OVm1XMm9GRENPMjJTWkFEQ2w2ekZXYnpRSHV4S2kvYXlYWlM3b09jR0dLL1JCWXU4UDIvTnFKTGFIOXFNTzJxd0ZtQzAwcHpjaThjNFBEeXpOMEM5L2ZBVWtHTWdPcmlEZDRMRXV5cjRpZ2JSczhvcUtFM1JMNEJ3bmFPTnBVUkY3bGNYQmpGK2s2NnQ0WTBHVmxvdExzL3pXaUV5dlFxQmdDMXQ1WXBudEx5eXJyT3J5TWFjY0IyVUovUkFFNkEyWXh6RGJWU0h3UkdGWWUrZ2ZzYUxLY0N4cUNBRitxTWRRU3R0S2g1OUxnUy9jZ3ZMRGVmMkh0bS9hZkZRcVRCVUEyOFN2bVA5WjdkaFhGNitzWDF0YWV0TzE5OVBwazRkZmorS2ZtNTd1OTNqalZOT1ZkdjZVenVtOHROMXd1UytVVkhsMCtPL1NKQlI1UkdZbFhreTM0cVJvQjRHdjc5ODQ2dzk5bW94YWora2djY2NuUGlzeXljSXVhb2Rab3NMa2RReGtsNnlxSGFQQzF3ZkV5NVFYRnpVSWNncmZUM3lHN2pNWlF2UDNPaTl3Z3NtWStPUHJqSmNiMncwKzRXZld5SkpFcnQ5Ti8rM2FNRzdHbHZvYjVCalB2bFczZlRXcXlHUDRFMmNDTjBBOTN1N09NL0xjNjdYRG4yVXVkWWRoQzNjN0lMNTRsN3A2UXQyeUpGRlRaZmpZekZzY0NBQkJaZC94aUp1VzZFbFZnWlQvSUZpcGo0OVV4MDdWMFFSWWtYWlRwejNZQXlJTE9SU1JOc1pWMHRWeXYxdUpTUGdCeEo0R2drMGhBclVDMU1kVXpVNVZTbkk0TVFmOGJpYmNWZ0s0S244K1h3MEJYYUUvVm82QllxbXFSSnNJSXFPVmpQOVJVbm5ja2c1cm1SZFhYYklVSGFRNndRaGRFMWRZOXpaVURDeUNob1VaQjNyWWNPMTNNRmNybFRDbzBBWGdLeEhNTHVZSkt0MHJtOUI5YWF6Y0I4bklKK3QwcDdrYnVEdTdWZEdhUHl2VldzOHdPTUdhcDlBZCtaQStPREpTekxkQUpEWVkvOThGK3N3UEFlVFNNdmRSek96Y3ArZGxiZFhUZXRsZHQreUlOVmxlcDhlWmEyVHhzRVJxOFp6djJqbkhadEFnTjNyb2QreWxUSGljV0RXN2RqbjNEbElsMW1BYi9lenYySERNTXNmUlJ6QTZQSndsQWNIQTd0akRJaWNoL3ZSMjdaNURDWWZOdDJ6RWp5UWlDVjI3SFJuUzVpTzQvNFEyV0ROU3BHM0hpcWc1Y2NobDViTGxHTnlKVUU3MzVpZ2RUWlRPOVNKWEt4YlJaVGowWXRyNzczVlo0NDQwTVdhejJpdWxGVVBrVzA4WGVhdit2V25FcnV2SEczZnZHeUd5dmkyR2FVYmRwSmp1L1VCbGFxUS9YMUtPckJzbGllYUo0MnlMTmVmRzI0b1M4ZU5VcWFKZFh2VEZKZVVhZXBpdWhXdFB5NHVBM0kvbHR6TnZrOXRKOVRZYlN3VUpVTklENFp2eTlPNWlKRFprOHNJUUt5SXhFWE5RbzlxSUdNN3BCK0QyZnZNY2l2aVFKZERlOUJyRGZuR0pjZHZZeVE4a0I1MjVncWxHbGJQUCtqRHFwUjFQUFpkUXBMWVUyN3IreDE4dnZNUTJxaXZpZzNvR3VjV0NzZSsvaHcvZDJ4dzRnZHNHbmVzcmN3ZjJIYnV6L2FYZEtYK2c2enRLVVB0ZEVJM1NpeUpDalNIQm5mOWx1dllrSEZnSzB1WEo0N0s3MzNuWFgwVDBMaDFjMi91ckVpYnRQbkVEY3l1R0ZQVWZ2Z3V0amgxZjY1K20xdTArTTJGcERya3BYTjZMUlh6bWo5bFhNN0t0QkU4Qk9iUXJUZlQ2amtRMTkwTFBKRDUxUk8rdk1USmhERytzNm1aa2hlcUtMb0htNXZ3V0tRRHl3dFdheldaU1lXLytZM2UvdHpQa252bXdjNHAwUzJ0eWtHOUgxZThuS1I1SDU3RzZpQzB5V09TREh5b205cXd6ZmJyS1hkYjNUcnBkSm5TSE5HdkhwM28zdGkydHJheGN0SzUyTnJ5cjFYR3UxczI5Lys1UjFxblJWYTNsOWplN3dQRjZyWnd2dTQyNnRwN3lqV1BoWnBWZHpIeStjVzk3ZEozWDJtNE90Qk1hR3pUeWlDeFdhN2FHak4wS1BuQUdsOXdzekU4TGY5aG9uSHpseit5YWNubmtFeFY5NGI2UDN0OExFeXUxbkhobmlzQzFJYjJhQUpLY1FxZFFUNjJtRFR2elNkUUdWMnRBUnhLZWJLdWFadS85L0hKT1VVN3FzbjFLa01ZdzEzbFVSMG1YMUpsWFdFUUpOWE1OLzVWWU4rZUpGUmErNldESmVKOG9pRW5XVEVGT0hpQ3krenBEd3Bmc3pGVWZ0TTkxNm05bCtLOHppR3pCVm9qblVIN3BucFpVVjZld1ZvT3Rkc1JNZDJuQytkK2tORmgzT1ZkSGZMbEk1bDFtMzlqS0xEbzhwbzJ3MnBFdCtXNnd6WEJDZC9EQlhKWm04R2Z3TUs5MUVlNThsL2Z5N1JjbGFPbm5pQTB3SVh6MFMvclFLK3JnaUhicnF4QlVTSUMya1hubjlkV2haTXZ1ZlFUM05rSEkzTUxuOUViYlAzUnFMdjVOS09FL0JoUUpXUE13clltbVVQblJWRmQwMWNPZTMvd3BvQVA2WmRFMTJVUGZaSWloV2haMmxHSEQzSDFtWmJweWpDMW83YzdKQ25lcEJrdHBrN3BiSGJwa2pOc1h2b21zcW0vOGZhMjhDSjlkVjNvbld1ZnUrMzdxMXIxMUw3OVZWWFZWcUxhMXlTNVpsTGFZdFdTM1psdTMyZ214c01NMW1qQU4yRTlzUWJERENnQ0hBUUNkREFzRWtDUEtJQ1dIcEpQTVNFZ2lZelNISjc4MG95eENHa0l6ek1pUWtZY3J6ZmVmZXFxNXVpWVJmM3BPNmJ0MjZ5N24zYk4vNTF2L25HQnZJWFd3WXY1Sy9iVGVTc2QyMzVmR0VoRHdrMGNSWkROQ2VSZVFqUnNCaXR2VWh0bW1ZVmNoQTBsVnIxMmhtbFQwa2FPYVpzVUYrZ21kaytaZWtwTXgrRlpac1VaL1RYTzRPUjJPKzBmOGxDbS80VzNKUy9vaEVKUGJydkdJd3QzR2VQZ2VMT1BQTkt3ZlFoNVJtL25XRWpiV0hhbDN4aVZEaE9SeXRPSURGTG4xbTBNb1RFYysxVFVZSTN3ZUZJVFo4SVRLU2VSVjZGcWxHVnBLK1FJaWgzOEJaU2tZenVSdUFLcEl2VEVuU1MxT01ibnZzWjNrWnhMMHBRbFI2amxuM2swNWdpQ2xIK2JvVXdOMkI5RVdpc1VwYTQxVHl4VWtwSWIyTXBPRkdpLzBjcjJqTUdSQ290V2xDWkZZbGMwYmdKSDBRMlZPaDcydm9DOEVDSmNsRFB4OFBhVWtWR0MreFNvSDN1NEVRbncraGVEMUtXaW9VZDVkMmNJZ1hGMFRjRnplQTdBMEdtUHExVG5kai9VTEtDMHkyVW1ITndQdTlrZjMrOTIyekVHaDgwakpOSzhscmdXWkltc1R6WkgzME9LY0hCWE45ZmYyRytZYWVCSWJwMVZVV3Z1L1k5dXRJdlZKS0poUWhWYXRjVjZtbEJDV2gyRXJjQ09LN2x3Y25xdU1UY0laWEU4bFNDSWxJY3d3OEZMczM4cVV1MGJ5YzVTcXE2U2s3VTZQcTFpZ3RGZFZ5Q2tHOFhCcm1Ud0NHdEQxZ2ptZ1NzeEpGaktFNlQrQ1Q1dWs1OUtlREFlRGwrWGh6UDBPZXRCZ21JRXl0aXdMMzJEMGMxK1RZcWJtemFsRlZ0VnMxRUZ6ZHVKbjJnWnl3UEMrTGlwUFROTTVqVVJ6T3MzQXRiaVdkRXptMnlDTzZZSlVueEI1akVsa3B3VFlZQ2lNMnpsSjlJVU02U2lvZkVGS3hZYkxVVmxtdXhiTGQrZHMwb21vbDVTYU41M2tQeGxmYW14QUVwVkdlenFGcWtPVlZqbVB6WFBna1ZsWk1SeW5DNUdTMENpZHpaS0dHaWo1WmJPQWpZRUdmb0padk50TFJvRXg5TFBabzdDMnh0OFdlaW4wWWVLUnlsaUJZQjM2aHRUaWdVTTRvV29yb0VTeEdjQUFJN1lTb0FCR3JIb1lYYmUzanIzYlhqMlNBTUs1anVFZnprb1JKQ2tKak5RWFRyRkUvTXFxZFI5dG9BT2U3Z3hIcGp3ek9Vdmt6RW9qWjFPZFhrRGtXYWd6cmhNNGVnRU1GU3pMemljQlFvZlZFUXpSbUpnVUJtNXlSVk05S3dxajBranFjNDNsVmttVExsMFNHTWF4c29sd3ZqSitXTXJ5QW9pbkl0R2JtOURneXA0Y0ZTY0FNTW93bVNvcW1vaGI3UEtMUHdZZmxaTUg0bENNUWhXUERJNDA1aTZCcFBCM29wc1J4cXNzS25LYXFLUldXTUVMTS9mdUpKRHRtenRKMEJZaTJwTHAyT3U5NXFrS3VBQVlDaGdIUG1wK2ljblVEZnQ5MzVNZ0ROOXh3SDZQSW1pN0piQWNFR0ZreGJGbmxTR3pvUTRGOTE0NHRnSnh3SlVhdGoxMm1kUmZKenJadDdlZ1V6SVdNQ2JXNmZnanFId3hpd253TTlXcGFJeTBrcDJRRVpvemFwdzRrQVJzYXhDRnN6QStHRFFiTkpTY1VTZFJaaWVYMHoxV1RSUWZyMktOMTFOUmZOYmlvaHIxQmMyZ3FOc2Z0UjQ1ODY0YjdsbGhaU3NqcWIwSXpLckQ4TXljWWZ0dDZmMlM3UFNia2IrZUI3WWo0R2hxNUxrVGgrSkdyQlhVaHFRMHZvUHgvR0dlMFpjd0JkdDdKTVNRcnBSekRFbFdHODUxOGZXNXFiaC9LbkJ3cnphd2NXVncrMEhIeWdzYnlUSkFZdGYyQWxPQllyTUkrWVBySm9tZklxWkxpSks5c1ZtZjNUNlVjUVdBTUVDUGRBKzNUeCtjUHJGamF2R0p5d2dpdnVCVFZDQ0ZSOXBQdGI5NmRwN05wOU0yN2k4emdmRHlQNjNZUVFTVThmRk1wNS9DV1dlc2NXRjQ4c2pJanN5eGhlSFBmM0ZTem5uZmlIS09LbHVFa09ZWWtnZFhmZTRUV1FDNVlpNW1WQS9QSFQ3Y1B1SndDcnlvSVRtcHEvMnkxZVdYU1VVb3AyZkNLU1JrVy9ydWNSRHA5NzhHYnR0bmgvZGdLeGdxN1hsQ0NkYlNFVnFrU3pUMksySDZWa0FWQ0FZdjZLNGJnV2dIYUxxbk9lcEZGUk5CdUp6UmJkYnA3Z09vMk82MVE2UGN3U2NEOFZ1Um5zOVpFK3pSSlZYbE41V2R5VXJwRUhqTk5WalpkazFVMHhUMFNWeENkbkNQeWNhQUdvc2l5OE11STg3UEYxSVM3Y2h4ZFRUVFhzU1FtYnBxd3V1cW1hZVNJc2pzRDA3MldzUXltTUttMjlsV2JyWXJzR1M3aGVja2pucEl1bFdjSlQyVGdrYVpLR1ZraFBrWm5jcG5kdVpiS3pUQ0NaYmxFK0ZSbHZsWEpaaXV0K1VveHdqdmNwTDVpd0lCWEFuR1lCcTBhc3NNLzJVMkJhcnVIZmdySVE1TmRVZy9aUElPNzliTVB4OGVTQTY4QUkrR1B1QXo0R25BZVVvYjZEQ1RINHB2U2RaeEIxVWNQMzlTY21acUNpMHpkOGhQR3FGK0JvVm5ZQ0ZERTFOUk04NmFJcjBlWk1nZjlHUTR3NnNmb2g5NUtjOGp5SURyY0ltbXZqMlhTRmVLYlJMRVVkRTZHTDJKQnljMXJybW02VlpHSTdPK3JGc0xoVzk5ZzRWZkZ1N3d0dG11MzdISjd5eDY3MnR2b3JhTXhGczJ3cTZzYkd4Y3ZScmJsMkFhOGx3bWpMVWx0UjBQOXRVMzFjTlRYdkRUd1Jua0lUVVBGZEQyOW1NdmxMY3RhQzhZeEs4TUVMS21ZNkxQWk5OQkZoUXBzVytNWStZb3VSamQxTWFrY3hRajFxZjlWYUppdm92bzNTcEM5ZFZJUWNkVGlLWExtK1o4Ny9UbzI1OFp6dVhpRGM5eDBxbEp3ZE1NaGVROFBlVG5tZGFjTEcvOVRlT1I2elN1Z1YrZjBtOU9PVzAxWmx1NDZ4cHVjREI0cmVNNlpod1JDM1kwaStoNmo3M1pqN0piWTdiRTcwWnNUUVVsQ2d5eDFLQXZpL2tBQnVTT1NPc3FPaEJFa2FQSEJOYURjM2pxT2RxSnVtSk1odWxwb3pwY3c2WFljUHRiekJzdUl5bTVSVlJqSnlFNWtFN0lpSnZNeVNQVXNacjNYT0JHRVU0a2xKdnd3R0paWGFtakd4VlBQRDNJbS90VlpTeVZDMFU3VkRiZVUwQVFpV1k2Znpmb2tiWXFxYmlpV256UVRFcXM0S0RuWXdON0NYazc3TDRRbDZEc0RSMldHZmFzSUswQkJkdU5Fb05mZERBV3ZGa2JhWmk1MlJleDA3TGJZR293S2c0bWFCQm9GNUs3NVFRanBmQmlXT0VBM2FRNjRpRnFUc25tMXNoQ3BLY05rVHFYWlFiYVNiaXZ1eHlOUWZYU2pvem5lcWdONjlCRkpsRFZlbWVZNTQ4UXF4MDlMZ2lwS29pYzRSbDRTRTU5S2lGTGVjSVE5dFF4QzVDaWZsQmtTNTlqTWZSeXY4TUZTWEZCNGhtcTVmNTZCRG1jSkp4RlVqTlBOejdPY29kNXN5UnlqODJoTWhvM09jSko5c3dwTHA4aXA1bGhySlpOTVprNDN4MHlWY3pKQ1lueHBmR2F4bmhDWTFPMjJac0lEb0h4VGpLc1RMcXNwZmowbFNTbFl4YnF3YmpQVW1ZOGgyN0NDaXhFbmpYYlRVRU1OUXlOVXd3Wmluc1E2aUhOT2ZzMWoyS3pmeTZqS0grcTFqUEUxaTA4MTA5V0V0NkIwKzc4VlYrRWZPZTRseHJLK3FZbktIeHVabXY0N2xyRjNQc3N5M3E1ZFN2KzdjY3pGTUtLbmtXTzkyUDAwTHBhYUtEcE5GTmQ5WEpuUlh3Sk5ib2lWSmtTSXlTQ3RoakNPTkRVbXJPbXcrTUgxaTRTUDFzNXFHWGtaZE01Qmx3Z3NwZzNqbTE2Qy9SemVKSlJEbGdjdUk2ZGx0L0xTaWl2UG52OEQrNHJhdmttRjFRMXJ6R0lad1lkRjBtVGlDRWJKYW9ZS0N3Y0xraXdEWEV6Z1VnTzlnUEM5Ui9COEhDN2trajRlZ0hzTm5WVW05OVd1c0VuSXpJUFk1Z2FLNnFIWXkyckF3aHNhdVNMaFZpcHVZditMU2xQTW43TXRTVFF0cCtDd3hMTW1aOW5BOERDTXN5aXhnczRvZ2FmQ3ZaZ29HMWpTbDhPcGdKMmR0RHpDd2cyV0tVb3Q5cytacVJJREt6cGNBczBNVndjS293dXNWQ3h3d29DKy9UYjVCZGpUS1I2T1dBTU9ROEI0djBVU2tFQWtiL2lYRy8vMTNUSlJwbStjVmxKeS83Mm5Ya1BZZjczeFgxUTVSUThSdWYvNVU0WFlNSWR0NkUvWXB2eG1qSXlnRzRrdEdwT0VsR2xJbmJmSURUQ1dpMHdMTndOVkNUT1E2M3VOWGdPWlFTdnVkeHhMTTZ2ejFVSUJONnJGS3pwYmtBU2UvZGtSa3doWncrc2JqUTIrTk9rNDZJM2hCT2pET3VaK3d4MExkelo0ekdUQmlMemcvVzZZRXV2SjBJcUlXQ2NXRXlOck1UZFdpYjA3OXJIWWI4ZStHZnN1MFAwczR5RmREZTFxbmFEWnhYakplS3NUK0pFNzFqNm00dEZvTHlBdFZiRUU0d2dYQUlxeWlhNjdjS2hHVGY4UmhnWDhMMVZMd2dCVENUTWZrUXlzTE1FaXM4MndrV09DYnJVekJGdkFXMEpvakFxbWowVDNQZlN0R2NDUlViczRsVlZ6ekc1WWlCSFdjeEVIT1BYOENSTncwZXl3N1dyb1dwVW56VTRUeUQrdzhmOGJ2VlhFU1lVVVBKM3RBMitvZXdXaVRJcklKZjF2R0VENFcwd0p0czR4eTUxckdVNjNoYVNJMThMWUU5Z0FTRHpJSjR6QUJ5Q0FzZ2tKQkNxWlNBcHYydHhVb3pFM084WFpKcTlJQkE2Q1NNc3JBUzh3NkhsckJxelFYOUZaUm05OHY2RXpiRW8zNnExclduVkRDMVE3WDAvQnNBV1dFeVJWanVmeUNObnd0N290RzFxMnZGVE9hb1pzNi80dnZoOVdrQVFQNTN3K2oraVZsckVnSVJVakRrSVh3dFFpaW9KaXJXUXhyQzJ5NUp6VEFGYVhIc0pYeHRlZ0Z3RlQzM0M2TWcrWENjQWRnbXd1aUJ4MVlzWklMc0ttRW5KS1FJUU5uZ2dwR2YzaFBMUk1pZ0p3OXF6QUtCWXYzNW9Ca1FSYWhKZDJ5U0lLYXFMNGZzYVNOY1pTWlN5SnhlUzYxekMrWXFMa3ovR200alBzMlRTamNUb0hyeUZRU3lmTml6a1M4MXlLdFdJSFkxZkZqc1plRFJKNHJBS3pxZGh1QmQxdGFWN0xveGxnV2NUVUdVMzcycjBrNDJ1dGhjNnR0UkJ5aXRybmdDZ09GSHQrQ1ZNQjVIRXB4TkdFYTJJNXZBaWxpeHBpeGNBWmZCZzViUFYvZEVQamxlMnR4TEZrSzRuczJlNzAzNDNranYzQWFOcll6dlR2VGt3VXJMcGx3VUxJSm1RUjJwVkpwVFZHMWl3SHN3MG9BbWV4aFE2Y3RuUG95QVVkeWlTclBDdllTVU0rank2Yi8rdlNmTE5DL3kyRnY1dnViaVdjdldwYnR0bi9hd0p1dTFGTUUyS0Q2S25aY0kyYWpzY3R4dEJzZ1lVaGFVakNlRWt6Skk0UmJjRzJjcVlWTjBkMWtZaERGV3RYV0F4WGNmbWdLNUxOdGJWbDY0dkwvUytjM0Z5LzhIeS9COExlcmVUQXIrYmZkMkZBWDErQSt4NkpuWS85WjF4RlE1OUdMKzRaakNpRVMxU3hVNXRoS0tNVjRpQzFnTWxIVm5JL2N2K0JDQ1FCMHpNaEFnTlFBeVRPUVNkY3E2ajNYWmVpVmMyd1ZHTzNuOHhRWjBDRGc3dW9WWlQyL0N5Sjg1Z21FZFpwSUFHZG9CT241Y1REQkJoSUZzZy9HVnBjeThrdzcyVUh4QnNGZUFTdS83d1pCeTRQS0tXcjUrMkNKTTBJNkNjbVdSeWZNSzBhRUN5Y2x5RHQ4OEN0R0Jub1pZYXhCVFVPVEJtdytBSmpDcEljQ0FrZ0FiSWNzT2kxUVpqcE9RWmRRZ1RPckRzemFjTXhNeExIamZYL1FsQVpwcWp5dVJ3Uk9seWVZVFJSRkMwems3UmtseWZITTN0OHpZYVo2cXVlNFNzT0RocFhNQnlRcjRCYmdyZHpGVVhpWVpxeWJKeXJLS1pET01NQ1lzSUpVNHhjOEdRYm1TcUcwMlJGeHJWWjRIamRralJXbFRSQkw4R3lOZ0ZMdXBxOXdtT2t1QnRIR0g3Q0pnMlJrNUtZREZSOEJPblBIcDUxcGpONVZSUnRLeU1LRE1kVk03a3l5K1NNS08vQm41TUg2Zmk0SmZaR0VBRzZ3Rk9jQXprSjRUcm1vVXlESFZpeFlTbkFya2RHSlF3TXJzM0RhZ2FySHdMUmQ2cWRhc2gxNDZZMlA3Q1NCSjRRUnRoVG5VeWNhaXc2MEszWTdhTGdVU1VuemVIaGd5VFJvc01DK1JrYTlJdUtXeHhBRVZkYjNSSUQ0QW1sR1FaeEszTzRNSVE2YTFRT1Vmdyt6RHdyQ25uRXY4U3lmQmhUMUZJZnArOFBOY0RId0h0M20ySUlIRENMVG1ieDBMeVAramgwSXExMllaU3l5TEYxWVBSR0t4OE1QZ3Ird2ZyTkRsS1ZlQmZJVUJPYXhzV1ZDb1VtMkRkWUpHMVFNS3l6T05LaFJUN1BNVHp6cXdGMG9hQ1F2R0pyY1ZWankxT0Nva0YzSnkybUtLbm84b2x1amJBTTZLS01Qa1JBT0RBSExSTndDc1BrMDBhbURPU2VseW9JbkFSRUFhazArUllqS0Fxc0NicGdvNGJBdFdHWWlDQ2RNV0pObFIvbEJWNWp4VUNHS3FKdFEwcHpBZzlTSzlwVk9BMFZVd1FZZTFhU2RFYkFUQ2trcnNHaUl6TG9nY3BhdkNSeDZKRXBBZjJYQlpFdzFwZ0hMRHhEWkpVNENtWUk0eGxIc0luT0VKTkpJWVlaOGlhRVVSa1d5Q2JNcUVDV0ZEYUl1MFNIWnBjWTBaTlRuZ0FMRGlFYVRFYkNuS1BLWVlidm91Y3ArMlpQbGhtSjVmRThpNEV2Q3E5Q24wZzhqbnNvT2Fzd0pYSWpUa1dtLzZlNnpJb3dKMjBKV0ZRTkpoemhaZWhaQmR0RTFSd1F5RGdSSFE0SkQvVVFYRllwaUdtRlNZcE9SU3JLcVZJOXkyYmp1dGxRZ0wyQytzTnNpNnVISGRzME9WY3pXTm5nTEFaZnhSY3dzU2tVeWVpRXJLUWxFZG9JSGdQY1FjbkppMEp1QXBkb2xwT3pTVVBoVk1OUmJZT0Z4WmMxZVZHeVJGZ0dPQmttSzQvWW9nYTBwV1JhQXNkQ1d6T0tUZ1IwQ3ZNd3h4d2xSQmpuQTBzdHd3blFmTkFGYUdFT2lNaUJNTXBhdWtuOEhDK29PaENmOGJ6T21iYmppbWtEaEM4T2xpVDB6MkJVeGNlTXhqQzIwQWtXVm1JUlptMS9VNVlsZ2o1SHNGN0RhUTZ1RS9rRUp5bEN3TWhsR1lnY1NjUmkyMk1BSzF1TWI0djBIcDk0SFA2ZXhzM2pJN2xUM1ZncVJEMFlBVmRFejhGaU0yQzdWRDliSzlhSzVDa2w3ZlkvNTZhVm9tS1J1S1g4MGtQWG5yMjJRUGJGKzM5RHppcHUvNytoMW9JVVhhV202LzB2UERRejg0dkJJRitWVDFiSVBlaXRWUEdMQ05rQi9QeEsvOGV2elQzOWRQNytiMC9jRDkrNSs3ZGpoYkFSaWd0cTFsc1VLbUFFK0hFUHdmcTRtQ09yc2RwckpLeEV3dW8vaTl0RVkrTncvOWtMcTZ2UEZ1RFE4M2dJcE5aRW9kRC8wcmUrTlpydkprUGp6Nk9FMVVNVE1OcGxRdnNLdVVmV05QazkzOUxrbzdLbWMvSnM0NlpaMGFpOWh2NysxbnZ3NVBpWUpzL2UxSmlWT1cxN0RCVkx2V0tvamF1Nzg4VzdyV0FnVWZ6Q2c2K2pMMzRldDJjSzY0VW56aTR0blYxNnlZTVAvdE9PZC8vT0VwNFp4alNHZWF0elE2OWFNY3BrMCtMRDMzNE4xZW43Q0RramlyOTF3d0lMSytjVGtyUnd3OC9XUHAwazY5Sno4dlhYQyt4ejBuNFo5MnFwajRUdGdnbGlUMUhNaWRDZms0WWJrWW5YdmpZMytDUGRrUjhqZllVNWV3TWFIUklVTVVkSms5bkNHK3lXNDBTZFhsVDY2OHJpZE9uRTZyM0hqOTk3L01XTFRmVXo2cjNHN21wMXQrR1I2bkU4K3I1eUpoTWI1TFNONUc0c3Q0UVlEdDFoMmRWdFpRY1V6YnVGYWV4ckZNNDdVazkzS2VMcjE0clRjdjlQNWVsaWR2SEl5djc5Sy91dmJkYmxkOGxmVDVWTTNmZnoyUVBlcityTndzTGsvdjJUSmhCYzFValc1YnVVUGVYeUhzVjZmdkhNNHVLWk4yVGo4YnZydWhaSWxuZnNNM3N5YzNDVXQyUXVFNC8wcHhkcERHd3lpbzBKT3pxQ01ZaUw1UUNuRDNtNDF0a3ozdjl4ODlEaXRIdlZaT2ZFUncvZWNjZkIzbDh6Qy9YeFBZZWFNd2Y1eXRTVmQ5NXh4N0hCM0VXZHJJMWUyNE1NcU1Vb29kdW5Kejl0cDFKMi95bmNrdFZHeXY0czduM2ZUdEY1eGdDUDl5NVkrMUUvR0EveGRkQW9QTit1VlJkSlBNOTBvaDNTYklYeWJoQkhMU21zYVNZUmNMOUQzcEZPck9hbXUrTTlqZXptbExqSGxRaUpNM3JjWTVMQXFzWnRrR2NDeGxGVm9HRXNiOWdUaVY5TEorNTBTbzBLcmhXZlYrT1NxcDZCaGU0WFZJOHoxTWMraVlsK1A4R3hiNGJyR1ZmOWVCNmtzSW5FdHRoY00rYWhsOTRXcG1zUjNvc1hpeldSckVOTm42TTFuYkJUL1I4ZUlST3JSeVlIdjFQMnAxZlhWM2ZHMnVVUncyTG91ZDN5eStpRFdrYi9VNkNCTUh5QWJBQmZGODIvTDFKL2ZXSVdpK0xxZ1lrRHErSmc1eDlmZi9yMDYwOFRpM3J1YTZObjZNN2Zuc2J6STFnVHFPKzlCSnVXYnlNU08zbjNTSWU5R0ZORHJjSFBmNlEvRlR0MTQrUnJYalA1bWxHZmJoWGpvYmY1UWJROElheER1NFVLaWMvdEdoL2ZOVDVmVzE2WVdWaXVIYjd0OEhvOSsxUzJqcHZ5N3RQU2lSUFM2ZDNOcGFYWUNIMUh6S2s0dktGQjhnUjQvQmJ0ZTBRM2JjMnozUnJaa0VSQytnOEk3bDM3VnZZZDdzMTg0R2ZmL25aU3YrVUQrZHpxZHliMzdadThaZ1pJMFBkUFhSZlI4cWRKTC9idFliN0ozdE1URTZQOWlaNG5hRXVvaFVKRVpBNFNnOUpBamVMY1czeVpXRy92T1hseTk1NlRKZkg5SjNidlBySHc5bnVMOTlwQzZlUjkxMTIzcDEzbkYvRGdNTmNocFhkQUZlYmEwNlROazRuK2MyVGozWk9UNzk0TU1RMmVKeCtDT3U2SkhjRG5obVp5MUk1T1VsZVdHdVVHTWJoZ2ZtaEs3MUNmRGRTL0JkM1FzbzZHbnNHb0lQZk9DdHdrSjNXU3FzVElwNEJ6TVAyT3hFM3k0alFoTTl0UGlhYmZsbmg2Nm91TFUxT0xrMCtYQk9rcVlEVnNyaXRKWGNIME9ma3FtUyt4aG1Td1Ara1VaKzZlV0p5WVdJekZSdVB4SllvRFVCSkVFTWZJK3NhTFhsSWZmK1pMN3p3enYvRDExS2xCdTd5TDBzaFlWK3pXOWlNdVlmQ0hieWplKzQ2RmhYZmNXeng2OUlsVjdVMXYwbGFmaVBSaG9WK3lIZGtsWUI1MFJ6M1pnb0VqR3d0blB0cFlyNk90Y1BtS2RyNTQvNWt6cno5emhsbC8yOE1QdjZWOXhUS2FIK3U1WXYvYmVQVDFaOGk1Um1OcjdkdWdQcUZacE5jRFRGZVFGOFRhQUV1WHVvamg0S3VHQWVjVVpwMmVpWWVudmxoS0prdkpqNVF6M3ZqY3dibHhMMU8rK3E2cnYvbnhCeFptL2VyMHJZL2RPbDMxWnhmK0xGRktKRXAyY2NFZUN4cUlFTk1JeHV5Rll1dnFxOS8vdWxPN2JzNk0rY2VtRDk1NjY4SHBvL0d4ek0yN1RtMWZtK094Y1l6aGg3NDMwTTJRV3JVbzVrdzM0TDJnRzdJQytLNDBBakNndUNBVTVqRlVjWWh4Y21aMkllRjFhcnV6elluandWVzVxM3ZuZHMvTUhBLzYzN1hTZkM0dVNhUVZaQ3Z0R3lwdHE4bnlpcEtMRzBvbUlLWDhsU2x2TnU3RjRSNy8rS0VEd1RYQnI2UVRhZG1NNXhXVlo1dDJaNzFUeVNSYVJCVGplU0Z0NHp1VENKTUtNNFBmSHZveVI2aHBZVDV3OUF5MGEvYlFmWm1QRWdxMXFIZWJMNVFGcW03clJqZ252aENXWUpMMjBQY0JYYjdhSSs3TDVEd3dyWUttR0hGUEZvZ29MMmRtOS91cW92RnkvdzhVWk9SNVdURkZWaDNQeENlblBjeTN3Z3FLSXprdlh5UlA4SUpsYUUrZkhWY0VqbDZuMjdkT3g2Vmd1c1RMaGlyOU1LNDZpaW9JOHNNTVJ0MnkvVytseURuT2NEVlIwVlRudDBEU1pXaWVTazZiNElnaEt1ak53Q0dTYW1YV1kyQmZFcms5alp5QnVOV1k1TEl3WnpBRVpCTmVqbkFhWWtlaHJkb3hKVFlKNCs4UVpscUtEWGk3VmpNY2NBaHBRaFViUThxVXAvRXhyUzVpNWZ1aFp4d2ZlcngyMFFsbkVXWlZOU2dKWmN3RmowSmtMY3d2UlM3NmxobUh6OVR1K25qbUFKUDEzQXozWDFRVE04ODZzS2NiMEZTVGg3eDBwcHBPOTg5WjhiakZzNVlxYzN5Z3Vzby9FNEd4TklYbkFrMlJsUVNjamIyUXc5TGloZkZNZHJ6aHBSUDJOV0orSWg4NEw1TElZc1pKdTE0NlhVL0o4VUljSkkxQVZSVk85TmFJd0NVMEtJWm5QVGd4R3R1Sy9wTlZ5alVKUG1wMUF6U1BDcnduenRkUS9rYmJmYVVxZHBwQnFIeWxVWjZZQVNrSzNibWxPWDJjRFdZMHJVb1dwcHRPVFZFbld1engvdjhZeis5NllsZDJVaytMVXVxTmt5Nno5SWRMeEozeTVrMXI0VXRYSDlwMzVOd0JJcFYwdlhqZ3lMNURWNmRtRktYcGtBTlh1M0t0Sm9GZ0tRangzNS9meFI4NXduYzZ5VmxWclZ3aUc4QjZRdk9YZEFrWFNnWlBEeVVEYVdTTlI0eUFKTTN3TW81SUJUdDhMT0p1VU83d1phUnVOZXFjS3JaRWFJT2cxaEtnY09qNFVVZUt0Y1N1ZDZhSmYrNXdjZGZjTlphNDkwOWc3enR3NkNMOXRkMXhZbzJzckN4KzhJMFRYZnZ4R3g1azFuSG5JeXVMSE94djg2ZTFLU3BreUVDTDdTQk1ZMDQyUDN2WHJwV1ZYWGQ5OXJkZXRuZGxaZS9MTHZhVWp4VXVYQ2g4VE9tSkg4RWQ0TUhWSVowMmFPUlBJVFlWbTQ3dGlsMFp1eUYyWit6VmlKczRNRmpRc0M0TTdxWUdLY1FJQTU0dVhxTWtmWmJNb1paRW5LTWFGdW93SDBRKzlBS1NBdGRESGRBTTExMWtFUVk4Y3VhZ2VjUXdoSmZVTUJlT3dYek5KRzdLSlNhbkdaWFRNUHQ4Z1RCenZDSDNDT3N1NnBxd2dCaUlmN3RiVUxXOUFrTW1KVW5rNXdqamxHeVcrYXVtTkpYSUNJemtnbHpQMWlkelhQSXFiMi9LTmd1YXhwZDA1UnNLUXdva2JmSUJaK20zWGc5OHBPTVlQSE5XZDh1Q0w0SDB6eTVKaGpETGRYWGlDQkxqY0x6RW1BNGppZzVoR0ltWGdCUklTNFMxU3c0cVdPWkxmTm9wKzRTenZMSVhOTWM2MlYwZjdhVWNWeEM0SUpYZkwvanlwTTFsMUlERGhHd3lycTlBSjFacC9vTWJZdWRpZDhmdWpUMFllM1BzOFRDRFFyYzYzeTBEcGZDaGFVWU0xYWpiTHJkenBCVVBXdk9VcUtKWVBKcDVKVlJ4dC96UWZsc2VnQzc3clhZVExWaHQ2TFl5OUJmd1hvaG9Vb0JQTGZJU001a1NRcDdqS3VUaklpaUNXTXZFK3JIZkxoWnZyYWE4eko5eUJQMllnS2dLRk4wWGdTMDVWcE00MW1Fd2ZKWUZhc3Z5cklCbmFlU3J4M0dDSkFxTUE2UlorbHlxZW11eCtJcE0vOVU5RXV0OWdxTXh2QklhL0lReElqRzg5SDFzamhkaWhlcXJxNm5xY3NiYnd5dFFHTU9obGh2SUJzUEoyT0lNZzZnakxNK2psWXRIQkRwQ3lxZ3VFZUFoRkVRRnp3dnNNaFR5NnFxWHNkQnJ5b2NMQkN5SWc0SW1HUzVGNEtYL0g4eGl6UTN4RmxtUXhBK2hWUnhidnhLNmZ6RWpBTi9VNTA0RTFuY0xCM2hndUtLd01lVkJHaFBxUE5DdS9kUlhZaE9UWnptaFBYWk9GTStOdFFXT1kzZlZ2MUhmeFhKbjI2NHo2ZHFHQ3NSVkZGUUVUYTE0N3J5bEJtZ0tOOVgwSndjWHFOemdncW83ZWdIbTNOaWNHdXRBb1VKbmJNcFlDdmVXREs0TzBnMm5hMzZReVNiaXFzN3h2amRCVENlbk9obmR5cEovNTN4c2gwL1ROTTFvMWd5ZEhrVS95dnk5biswZ0ZxeGdza0pwbG9MOTdHYzZyVUNNMUIyenBCM2xCODh6NU5kNXlmZ0VBMU5NWnovT01JckVNY3d6akdBSXpETzQrMmxWc0dkMENicjdFNGJFdzRoNG1pUkUvaGxkSm1jSkVmbmZOQ1RtZWtMbVdBR05jN2Vpd1dtVkYzRkFudUQ1aTVMeG03ekluQ1d5L2d3UEVzYjEyMkt3cHlLVXlMbEJad2xCRlIydHV2anFpT0k4UzVwVTBZeW84RjB5SHFUbVR1V3NRTEY0eWI2U2lhZUtJakRPOEZ4dGpvanFWZWRVbHRlWWI5UW1aOGNQaTRxWnlCUXlFeWU1ZENNenBpVVNXanFydVlmM0VsYTc4eXJIamlmVEdTbzNoSDRaRm1xQ3V0Vk9WOGl4UHJJSE0weUE3bXFodFVJZzB1cFZvbEVvSnNndEJiVTBXVHJoS2NxNHJ5ajE5ZU1mYk5jWEo4YjMxNCtmTlBJSGlWZFhsTEVwdXIzVVp6eUtlaEhRZUV0N0NJZm13QThmZmR2WWdsK0dGNjNPVjkrdHZ1K3RkOS85MXJ2SnhteFJVOWg2YXFwWVNVdmNTVHVSc0UrWGZrTlhpOWRtcTlsc2RYUzlGK0VwemRGY1p5RUxHS1dVREQzVCtQQ2JNa0JSZmh5Y0JwM0IrWkZid2hYeUtrNlFlZEVURVlyWlVLeHN5bEZJQXhxZGxYbDliNlc2VjBORnBTbGF4MlpuamhTakMvU3RlNkxGOHdZVzAwV3lzaDRFMmtGRFpLUlVMcGVVZ1prcTFXdG42VkdGWHJGTmhzakdKakRxdFl1UXZ6WHE0aEVJMERjaW5jdzBWc0tqaks2SWRvbHFOOTZLZDlFTm5uclAwSHppUUxtaExwL21tSjh2bFhJbjg2d3dMcXRLVW9SeHFRUGR1MUhPM21WejZDUTk4NFpTNmFBMUtaZ3BKSWsyTEcyNTB4c25FNHIvb2ZLTHkza21GMDl3U1VVVVVUVVBMSytrc2RvdTEzdXBJeWFGeWR1Si9HRzQ2SkN4VjdSTk1TV0lIcWVsM2NMUS93RFg4VEVZNWZNMGwzMmtsb0kvL3pKT0J6UUhhR2VudzhFd29LQVhPZ3NvTnkwVkJqNEhjU05vOUJUM3E2UHVCbUdnNUVXODVNaXJCaDRHa2F0QnppMmsyb1dOVVIrRGV3Znh5bHMrU2t3c0VjdkJlRDJFbnRVMFdXM28wQnlTRldyUzdiSm9TUElSKzUxRkJ6VDBtUFFGa1hwSlV2Y2pUTnhaSzgwamF1aDhwN3RPK05jQ1JXeUxZcXJjUGdvcy90N1g3OTBIM0N1TUkwWHN6UjhHRXNNVWdXK3dDNkxDdElwb0d6M1NKaHUvUUM3c0xuSXMwYStZdlVDQ29QOC9PWkF6aUlTYlR6QzltUUE2MHVDVkZjczZKUUgzUUFnWHpGeEJZcGR2KzVBeWJyVjZiY1RaSXhoMHdsalU5azdVNW9OdnNsNVlwNDBlYmxkWDhhdi8xWkU0bUNmRHhsOGRjMi9xdFFldDN1N2ROTnh0Tk1MRHdtamprNW13OWJmbXNCa3J4aHBiMUp4RzVWSWlIVUtobFVTZ0hTR0NYRUJsWm5TTDI4TTBFWVJ1KzJseVlxYlhtL2tyM0JRMUtYQVkyRWphQXlBMGE1THZlM2RxVWdLUEpTU05iQ3pOL3RmWkpicjVzM09TN2pFdkpwaG4vbnpXVGlidHJLUTU3eHc1U3VYUkFubUI2aVl5R012WGpmSWpWZ2VMYkR5ZzQ0VXV2WHc4UW9HandRb0NKbEVMellaaHhsczZWenVyaTRjUDdacGM2SjBWQ1dma2NJZFRDU2VwKy9lZkl0ejFrbEE5K2E2WFBDYUpsWEtWMFNweGdmQ01uZDEzeTlKaVo0enVKL2pmcU9aelZ2bjBJd0tmUzVaUDcxZnlHWUVubkpNZW0rNm03ZDdNbmFrNHordXNLNEhFWlh1VEUxbmJ4RDNiR05VSkZDSS96OWhjaExTRHhoTHM5L1ZOT05tL3VMNCtpZ09JZWNmTHNkMlJMelFPb20wVGV1Y0E0cmZPb29zd29nNGlyTTBRUzJMZ1ExUm9qZ1E3ay8xRk9KWlg5ZHJxYXErUW53NFBydU53K3RSZ1hPRk8vNWZEd1dUUXJ6OTFxbmlxNG53Z3Jtb0lZTWprTS9QL01CeG5FVzFGTE1RQ3lNZ3hGeG1pTUoxaEpVcjROVW5hTHVLK1VVemVacEZpOGlJTWtkZG9qQ1VQSE5USWZMTGMwQThzTjhySmd3ZTEvbGNPSGtpT05jakJnd2ZoY0hpczBmLzhBVGc0TndmWEg5QXV3V0RFN0R6b1NndkR1cnUxdTc2NHRMR2FLMTBNdjhqNjB1SUxNTlJLdWQ1Z1o0RFJnYkZ0SFBEd0dJdFppTlV4SzZvSWl6U01ybHEzaGVCaUxXRkhvcU9CR29wWXk3M0s0c3RPTGxaNm56L1FUcWZieSsyN2p4NjkrK2daQ3RDeDUwaXJkYVJGTmxiZk5DdDg4cFBDN0p0VzE5WTJqK0lGSVI3SGVnc3ZpRjJDQjRseHVpUDY1cDFabHFqYXlDUzFjaVVvd3h0MjNrOGZVeDU1c0Q2NTVKcWxSbU9WVEo5Y2JkU25DK1IrK3FnYlJ4N2VhWEpIN2w1KzhzbmxNN2ZwTzliOEZsTHE0WnBQZlRGQ3ZRN1ZBOEZQOU9jb2hWQkl1THBUaFVmSUU4eVFVRlUwU09VUXJ2bXY0Q1ZaRVdTQlZZeGtVK1l0VnBTK3JNdU1PYnQ3MW1Sa25lY2szbTM0SlVIZ0phNWg4WEl6WWNMeUxRdUtMUEdzSkVSci9oczFsaFY0NFB0MTJYUXlKbkNON0FsWjUwelBNem0wOUNZMVFSU3Y1Y3lNWThKaGROcGdXVTFrbWRpZ243RjlzWCtuWXQzWXFkaE5WSE50TXFIRHlqQThPYytnMThoK05oNGI5dlY4Q1dsUEYyVmZIN1BZRGFGK2EvdEpxeHVCUkNIVVRiY3o2Q055U3RpZFRoWHlybVJ6SEo5emdtSXhjRTJPNFdYTzRhdjIrVXovdCtPMkhiZmZWU2dVejJoQjVrMnN6VCtORnpsNVhuZTFSQlp0M2h6aFhSQ1RZQjB5SlhvMU9XYXVsTWNLZWs0ZlUxVXZCWk1aNnNsYllrWFpFMndtKzYralVaRnZLOGozWi9ja1A4VUZoSDhaWEpMeXhuT09EU0lBSXhPNUlsbFlucjVLTDZYajdpL0lJaDMvU1lwcmZnMjJDaU82VGRvcXVGelFpREpxZWdnNlZEbm8yeDZWbm5CWlFEdFBWMnlHVjhMYWdlYk9NTU14M29lMlF6TEQ2MEFuNXpTaXNXa3BmNWhsWDZYYXBoLy9XMTZNLzY0dkNhbHJRQlpjZEJWdU42dVJVd29qTWZKUlNlcHhJaEVFVmxwVXhBNVJTU1p4YUp3bHhvTFlzdDlTWmgvVlJXamgxNXZKWGlCTFh2K1BxL25yQ2FONkw3TmJvcWhPeWJxZ1M5eVlJMHY3Q2ZscmxjbzFZUjNqUUdQMzRVcUlEaDRVQjMycmJ1NGkweFdIOVl1cVI0TlBxdEdTaWI5SmNrN2pmSnN3dkdNTWEvSTlZdnRjQ3diK0Z3V1pPU1RKUms5alpVSWs0WVNrT0tzNlF6WVc3SmVkNEdWTjMzcnovdi9MbjNpWkxjRUlGL3JmWVpqckZGVmpwam5nV0NYZDFnWnJTSXptNCt3Z0IvN1RadVA4TjVOeGZyRnkyUVNjeGRMQzNjV0RuSFM1L0p2MzVpdVllRlBSZGlUZVZKU2ZtSGd6bWQ4OXNnNFdhTTdOWFlqVitCL0l1SG5aaEp1WVpQUG9GYnYyVEdSM0RaSnM3bjUwUjVMTlhOSlJveHlicVdRRmMyeU9KTmUwZVVQL041SnJwanZiY210dXh4WU9zOS90Z2wvMmR1T2lFTEY2WFlyNkgwNEZCTDR0eDRjUkZOMHlWb0NzWjd6K1JRUkFKd1V2OHlGcUxGeTJNSGpPTXMxNXJsQ2NuVm5pMjRwSWx2di96YzFrWEZLRWE2K2pOc1A5OUtybnJRdTZPMXNvTHMyWTlnVlIzdjUrNkNNd2puRTM2Q1ZRQXphYUJsMVRmUDBRUnpjWTRLdlNyQnFZVEVQczRPSXNZbTFvbGkvYSttc2JIL0xGVTRibGtvS2J1VTcwNGEyK0t2RlZJTkNzVUJWWWJybXdiT2hZRDhPOHRsQ2NtVjNiZ0J0U2E3NXVaTHkxbEYva2Fyd2s4VFVlUFZkK296QjczckVNdzNUUHcydkhodlM0UjNYS0FWRGtidXdOc1cvQktPLzZXK3FWb0QyaUJZdGljdEhHUUJlV1lZQmU2SEExUEk4V3pWSW9ycldvZTJnN3lzazA5RXFHdWtic1lwa1dnTmtScU52WlZvNjRXbm1XYVlmWHRJWnA0OXBsZndUYkpUdzdsMk5hZ1QrOEsrSkNFZnl2SFQ3dERXNDgwRjBWbHJnQWxqVkoxSlVuVFY0d05GZFVIRTl4YklGVFpJTU5CTW5RNWF0aFZNYlRnZXIwbUZUT2o2ZklsWVpoMk9sa1FaVjVUdFA4SUJDc1hpTGorWnBLcnVSOVUrUXN4V1V0MndJcW8wcVNBTzByMm9UemRWbHhsTGhVNVRqVmRoT1dxQmNNUXdnY1YxWllWdUlkTFFsVWg5VWtMZEJ0bWVQR09FRzM3YXlwR2dWVGRKT2VRNjVuSHhZazFVcTdtSUgyM0ZtZTRSWEo5Qlg1WmpOdHFib3FvNnZ3TzNoV0VLK1dWVGpNRS9FZTFPWUpCMjB0RjhSMWkyZVljbGtRTGF1WjgxSncvbjVCOEhURjBxdzB6SEFEN2k0V29iNW0zRXNWREltNW15RGVFYStvcW43YVRlcHhWVlprVk8wSjdGc1FFa3ZQR1pLUGlaMElrOCtqRjdPbW0xWkMxV1JOMUVCK0JnSDZQUVE0QmQwV0hGOU5xRHE2WlJkQjN1TUVUUjNxdEhDY1hSbGJSdlNpeXY4UEk2VTJNakMzajBPeTV6L2VoODlFQStSdEkwUGlIZjlmbS9SRlc5MzNnZTI5RmRMbkVFZGVwTkpIYkFESU9ZcmtOT1JucGlqS1FBT3hCemR4RTlLdDV5bTZ3RXNwVzNuMDJSQ1JrQnVXcTFKL0plQmtDWVY3UVg0QnB0aG82UVBZaUFFNzNkdEVvRFM2R1Q3Sm8wKytOblNxS0ZEZWRWY2hmT0l5ZmZ6ZThMbGIrc3NKaWh1RUVuclUwMTZPQllHazJFYmN2OEZzeFhTR2U5aTQyT0tqOU9hWXc3V01jYkxBY1d6RzQrUGxpU0FncWpPZTBWK0k2VGRLUVRCVkhJOTd6UExiQ1htQ1lhN3R2eXJWU3B1RWFUSGtIcHRwRWRaTXQ4bjF4NmVuYzBrbElTSmFwcTRXQ2pOallrSk41S1ludXFyZnk1WmYxVTdPclVqTzdOallMRzl6SzNPcG9jOEsycEFsOUtad0EyRHQvVnE3eGdkb1QyRnIzZURpeGJPUGJCUUs1SnpDVG83UHFPck0rQ1FydjVtc3YzenZxWE8vWjMzWlh6N0I1SFBBRVk3bDhzeUpNN0hJWC9keStjdGkrMG1BcVJCRWxNZlFKSVkrY3k1OGFwaWZ1OUZvUEgraGNlRkM0WW5wWU9hZnArUFRmemtUVEJ1OVorSDRlVGhPMW5zOUNZNGVnRS8vNytHUysxSGxIdVdVUkg4UUhFZGJYaklqMERJUGZQd0IrQ043VmlaV1ZpYkllZnJ6SHR4ZldRbGxuKytUajVPbjZMdGk1cEFjamROQkVhY2I0RnUyUjN5ejJ1RncvSGptdHN3ZjNacTVkZjJVOWVJOUc2OTR4Y1lySGc0ZEJ3NFVUeFFMSjRzbkgzNTVNNzN2b1ZOckgxeGIrK0JmblY3Y2QrYk1BN0ZSMzVVb0FuTW81VVN4aytHYmZnOXFITDNtRityMU15aXBSelllNnYrNE15ZGNPUmF6c1QxcFRxU1dYNHVpT2JzdEh3VmVlbHlFejNKOStVdkx5N0N0THkvZmo1dGxFQitYbjRkditBbi92aFR1d045Mis2VnJVK3RsWUcrR1prdHlULy9IOStkaDc3V0UyOUgreWtpTnV1V3dNcyt1YmtaMWVXcDFZQnRkSjZFVFFNd3VpZ1IvclY5U1RpeVNQY1dnVFRhaTIwbDhVT0lndndYYzI4TTdYYnUyRHJzdlFFRTd5dUVpQ1ZiczFraVYzdjc4NnFwRkMxUldWM2VXWXdjaWxyUCtrOThucUluUis4RHQwUXM5andWdHExZTdHNnpqdjUyMjRHN1pwbTZpdGMzSUJ1d1BqTUpSL08vZmhQbUtNQmVETU9JdEpVUWFpM2lUd2tXR2VqSVlqVjh1WEhuYndlYWhWbjRtVjlBY0hiN2dCK245emR6QmczUC9XRzQyeS84WXorZUNMMzhaL1RycExqMDRvcjhJNDRCcjdhS1BPVldCUkxHdGJ2SHBwOG42MC9lOEVMdm42T1prLy90UGYyeHk4bU1QMSt1RW5kakt4Ync1eEVtYmlEVVJrU2MyMEJUczBCYk1JZzVRdVUzaFFLaDF0K1Z6T3k0aEN4blB5N2ptc1c3MzJLNERuV3ExVXpOems3WENQbGMrREV1cld0clQvK05qdTNZZDZ5NTFhclZPbGV4ejhmcDM3OExyNzZ6aXNROU9UeGZXVnFwNlJyNVN0dllXS2lPblVMLzN3dmZJRjhsN1l5Vm8yVDFZMjJxSWtoUzZyVkpuUkZ4WFRSSmxnaERLcnQ4TjJpeHdWL2dML2lhcHFCbHZ6cmRZamxHcktidG5yVm85TzFWVkdZNXRrZGxhYldhMldtMU1ycTlQaXZFRjN4OXIxbStvTjhmOGVOdXlhbWZMajB1eXdPbTMyYWwyTzJYZnBvT2NKVDQrT1RreFFmenJ4c2V2Nno4dittTXAzMDhWTENzOThJRXFVTjBTb3FYNWRrMUVIdjlIVnVMOCtZUkYxaE5XLzZPOUhqbGpKVWJvckJYellvbFlKc29PQnIxQmhUV0tEMEtEVURERVBROVVEVjNZNHFHQ2ovcmV6ZlB3WGNRY2o5THlyb2JWcytLcG94TlA1NnE1L3I5VWM5WDF1NDcxMXJObHN0cnJiL1pJZkZkOVYxcHhycnJLVWJTcGRQMTNlcjBPWEZpRnYvaXgrU09WTysrMDk1VG44eE1URXhOYk1zRXFsU0ZuYWJhREdBemRSYWFad3pCaGtJRDlnVGE0UE55YlllTTcwSnk2OEhMcE5peTU3VFF2Nkt3bSs3TCtNUjIyR3FzTC9CSlZJWDZEYm1IeXIzNGxYY2JrRXVYMFZ3UVZ1TXdhRHZ0NEhMYzFWdUZWZVFSNjhTVjMzLzJUMXc2RWZLMkppQnNYUkd2SHJxTkhzNE8vaUp6OXdzaWhZWHc5K3JnbG95eHRNUklNYTFZYzdsSEpudHRSelZxeFZpWW5wK0Z0WmUyRkdQMmFGaExmVC9UL0h2VWs3dittMisrVGljTDN5ZEg3TnJCQ3FvcmJqZnY4aXlPVnV2NVV1TWI4QTlUcGJWQW50QllNZmRiWVZvQk9xQjVWbGlEL1NKV2sxSm1pVm81RkY3MEVuZENTeXdkZE1pL3B6RkUxK1g2ZjRmL3VIN3drbno4eVFkcm95Slk0bE1BdmNzdUVKZ25jRytNRllQYnFjVStUV3UvcC95VTlOZUtQYmw3cVFVcE9VZC9SMEFWMm16UHNDRjFpc1Q5STBTN2FsOXpkZnk1MGxJM3V3OStudHBVeXFwL2xLWkl2T3F2VWVLb0QzbkpaOTh2MlM1YWV5WDE3bFNpVGcvdS8vZTMvUVE5dGZPeGpnK0ltKzg5dDgrdTlqRStzUzRmTGFMM3Uzc3o5NHJIY0RsZmZiOFBCNDduWXRqV1RwNWh3NGZ1MWhvNkxZZ2hRMk96OFRPL1hzOC9lUkJJVE9PSlc2dFZDUEhIbHJiYytkdXYzZXArQzQ4b0tqazJySU1DUlc3ZmpFaUxHZCtXU045MURZMWFEQ1JLT1BOZW1ZUlQyNkp1ZjVzdFRaYjd0YUpxalBWeS9XS2VPdmI5SDY3RGJUdm5wdEEvcmpPNzBQMHg2aHcvM043ZlBvZFRJSE1LUlBVbENtSVlRYmpHYVNqTUl5S0RPbFRMVElwdXNWbExSZFBxVjNGU3UzQ2lucTgzS05oLzB4T1Y5ME1NbTMrbUMvdXR2eTcxOEtyZmRCZjMzNE5oMGJsdVoxY3VXR1lTdjNCNTk1MHVld0NYTDVXU3VOMVBkclJnSWE3SDlXZDhzTjh2S1RHKzZERExCME84MWZPYmxubmhKNmR0TEc4bXZHL2JuTkhxL3VWRit3VUh5Mk5EclQ5Z0JmN2VUa0c2KzZCWDdwNnE2SzhtT3NieTIxcVFVNVNUZHZtRmtuNnpmY2RYVW9xc2JrcXdaenRyRzJpWWxMQWVvdmpiOHV5dTB2YkE3Zk5lR2RHYkFMZlBBUVQvbm1hWm5IdmpNSTQ5ODVoRmluM3JtMUorWWVPUzVSL0RJMjU0NTljeW83Z2hqUDJuRUJiSTY1WDBNc3JQSXdKWjltM0syNjYwV3NvckhqNiszanJmV2ozOFh2dnQvQlBzRWpnL20vQVBrQVNoUm94eVlXRVkySGwyaGY3RDhnMlh5QUhDK2h0a3lZUDhIWkFKL0dDMXpORmN0eG1YRWNNRUpTVFdWMklCQktKQll5Z1p5UUFyOXplWDAzZW5KSC80UXBnTTVoR0JMMjN3aUVCMWxNT01tQ1FYUEtnK29Gc2IwVUovNXh5WStOdkVZblU1Mzk1OGlHekM1dm11bkdvVkNBNDZrZ0VoYy9PRVBCM09xUjMzY0xaVEovR0gyclE1d0xMVk5ZQUpvSU0zUHJhMlI4K3Mvb2pFMXk4QWdySVZ5OVRRVEl5ZGhUOGJzR2RnSXJRQ0ZHUnFnOU1oYjgyOTlmYjcvb3dkeVozOVVlQ0JQNWgvUFA1N3YvL1BQNUcvY20vK1pmRGhtWjZBL1R1RG9BM2tOYm56Z3U0WCt2enhRZU9sMzgvMS9mU0MvVFdZMDZNajJoOEVjY0FPZG0yUXpEQS93dnZJVjcrTFRUei85ajEvR09uODVxYjM0eGVyNjJxbFRvelNhWXJYdUp4RldxN3RGc25BY3dCSkFMWHF0OTNTLytyVmR1WHZ1MlJqUXFrbDBtUWZLL2FwZEUzaWNESW40cVZOazR0UXBYQWd1TTdZcVZFcHlVVkFxVjZpOHhOTEJSWEJJNFlqNmJ2amRnZzlKYlIwYmlWSHk2ZHBPa2E0WUVCSm4yQ2pCQ3R1SmRNWW1HU1laeXpOZE10Tlk4dmZNek9keTh6TjcvS1hHUXFXU3VDVlRiNVFtTW9sRVpxTFVxR2R1NFdTWnJDL05aZHNIcHhycGRHUHFZRHM3dHpRMTFYL21US2s1VVc0VXM5bGlvenpSTEozaEpHbGIvQUNzUnEydE53amh0eGp4MmExSExZUVAzeW96ZWdyRllnakgvZmJjVkRHQ29FRGxFTURNanNDQjJKK1FkWW9rNnZYNlJwMXV2b1JmOWVmcEZoM0ZKdUVmd2UwTHNjbkpsWW1KVTVPVFR3OTJvakUwaUFsS0QvMERCakZCZXdnbVVTckRYR3dWbTZQUkpvOU5icXI5eHpGTE1CbUpFMnI4OTgrcS96ZTF0VVI1V0NQYk55clJnUGNxQmpEL0xxejJueWViL2Q0eUthQjhYV2k4cnRuY0laUFhZMi9ZV3NIY1JXYWVLdWlvOFhHR29Xb2IrRFZmQzVIQk90MFFnWHVHb2ovQTh0RnBWV3QrSU02eWd1aGorRzFnRUpHR1lQaWRGa2FFWTRDdktHQkJaY1FFQ2pPOFJEcWlUcmc0ZnBZUk9kNFNHWW53TEd1SmhzMDdhRGJqV0daaWZ2THJaYzMxRWJNbVlGaWRJenhSdU1JVVo4aUtZdmdKMXVJWWczaEVKRDZSVXd4UjRwd2hNQXJQb08ra1VEREh0VEcrYU1oeFhpZVNwa3VkYU5YdC96TUhwSjR6Uk1abFpGTlRPTTNnZENIRjZGbExkQm9Iajh4UFRwWm5tWVF2VnhXNXdJc1pFWjRmQ0pLc3M0ckdzNHFJVWFFS3NWbUNNYTJzei9naXF6cWNMUEVlaDE2VVJDeW9PWFJaRlZoZjlGaGJVbHgxMk9hcjBPWUs5SDVpa0xkRWJFZXFrSmJZNm9aZmR6NTU1NHVQWG4zbkx5L20vZnlkaTNtUWFjNi8rS3FEYngyNzZ0d1RKL2J0cTlmaE04VDFEZnN3eE82dWJQWGowR2crWXN2Rzd6aUNVQXRodXovK0dISlZQMDQ1VHNyNU1OMWVjM2hCLzVZZXRkS1BrY0Y2N0FZN1l3LyszbHNyRmtmbkljaHFyWEtZMFJLK05tNWJmUGJaeGR0V01VZnllbXcweDNoQS9TeGlsVmJFQ2JSR3dzT0E2aEZnZUlmSUxKOCtla1crdjVtLzRtaTRYTUMyL3lpNSt3dVVOU3VZdG0yR3dWWmg0QlZwdytpMitwL1I4ZlJPbTFHa2ZidUVieDJkeVdlMm9rMi90SEVSL2xGSmsvNG1EU3ZSZjdiUk9FUC9vdjc3TzZBZFR3NDFyTnU5ZS9ZTUVxQUpRekV1VkZvUUd0TktseTV2ejRrOXJ5NGtFb1hFdWJINU1TTEFZK216clFSd1FIdkc2NytSd0pNZnJLZkd4bEwxYlR4OVZCZW9pb21RZGlXMG5kUFFYdlFWWU5zMW43eEdGViszL2hJV3N3ZmgzcDI4K0twMVRDLytCWWtabng0bkRGSEpFdTdXR2JiL2RIK3FQN0FYQWpVa3ZRSHRRS0d0QW5TakF2UUQ2ZG5nMDV1Y3ZHZGk0dDJUUTcrczk4TGFYd1RLT1lmNVZTcEJEZVhza2RnMkRMb0lYYzFxM1R4Yjg4UmFGS1dJV1pMYlFZM3MzYjE3ZHlseFN6RkxJOS9tOHFtQ3JtWEczNXg0K1Z0NTJTSnZHZDgxZmphZE5rK1Vib0xyaW9sYlhPN0VDZW5NUXZPQVVlVHIyZXliRXZmQ2RjY2w3aTFKREpjN1AxUE5aREovVUtUMWVTL1U1bnZSbkJqeVoyTTcrRFRhemdraTBhOVZ1djFlZUd6a0w4cjlHMXNHZWgyVjUwUXphZkE5eUttN2ZNbk41RERkNmY5bzVCSFIzT21GTVhCcHpJaGIyOWd3My9FT0U5cjQ3V2F2WjI2akU4aXpUNkgvSHFiZ2dGVzNOWXVvbWtpUGNaaWh5MTRBN0ZvM3hJTnpxVy9TSjVsRWFVcVducGZrcVpJZHo5alR3R2x2ak8rWlBwd29KY2hoWGx3WWU2V3VTSktpdjNKc1FlUVBPN3FwWGozN3lnbmZuM2psN05XcXFmYy9nUDVpMFR1OGxNcHFEbklxY1p5MkhrdEFaS05QN05hNnZGL0Q1M2JDZC9uOVV1TEVMNU9hbGhqclB6ZHU3VStReXJPQmErTUxXRW5iSnNmNmZ3S24vUEZYRlhPOXhIdHUvcHJCbWJwRG54N3hmYXNEdVRCOFVuZWtadEVUL04rR1I5d2NWbWRZOEIxYnJ4NFdON3N0ZmpFZDhqNDdKR0FYbVI5Z0VNdmsxSkIvZXZUUlQyOU0vbkh1ajA5UFB2cm9pQlJNVG0yY2hxT1JMbnBFdng5U2x6Q3Y1WjV3M2xCRXFwRk1IUldxa3k3Ni9NZ3hWRHJ1dkk1WXE4c2hyTGJUMzFoZUJZSVdxVGMyUnM2RWVTeUh1VFdXLzgyZmxBNkdQSUZNN1V3byswVmhVdDR3WU1vejZEZ3F0dWNIVG1QVldvZk1KY2ZHa2tCL1BvYzBDUFlQM1hCSC95S1phOTYwYmpqaWQwRFVHLzVOVlF1ZFRpR2R5WGM2UGl6N1cvNEhGeU05S2RxM3RqU2s5RW50clFSY0xYS1kycFUrY1A4alFGOHdHVjVoazFxYTdtcFBOaHFUaitLQjNqWWFpR1hHT2p0Sy9ONVdJYU8zaC9lRmJVQWx0Y3BJN0RXTlN5NjJpMlF6WWZlZlJIZHNjcStkNko5SEY4SHI4ZWRYY2ZQTjcwUnlUb0g2ZExxUlpuSkVLbkh0c3YxUEk5ZVRqVXZMRzRrSE50RFdGSzc2SnBuaHR0ekdiMzdrNXVWNlhmUzdFK1dmYXhTTGpTTFpPSHZGL0pPek0yTHk4TUdWNGhXdks4NFVpek9Sei8zejBCYm5hYVExTUY1K1RZUnBJcllIMHlRZzZ4dU41ZVhHeGdhSXJSdHJqVmZtODVhVno3K3lVYi9yRlRoRFhuSFhpRysyRG55SUg2MWpaWmh2Vk9UQTlkR0ZId1FUNGI0UVc2Nm1udCs4K0VJTVUrTStmdXJVNDZucUM3SDFkYklhNWtabHR2RWdsM0FmbzN6R05xNGl0b01IRFduclQvQzkrNldWZmZ0VzlqbWpaZFgzNGJGZjJsWWlvVEhjcTJTTmFyK2FuWkgwRnpUNWRLaGV1akJ4d0ppeGJ0cDc5WjEzWG4xNGZ2NTloNnFkN3ZIamUyZXF1dzREMjRVSDZzZnZQYjZ6YnVvMkc1cy9zSzA5TjdTckRlT21QempVdjZHM2V6N0NYK2hnVk1KaUNOVDA2aHVUeVo5ZktUNlZlK3FwM0g5dWFIWXFmN3loNUpPOWoxNmZ2REw1cm5qK0hia25uOHg5cUpGWVRPYlV4dEVjVU9OUlhvK24xanFxNStwZ1dvL092OGZ4ZldLcFkzN0ZKRCtCNDlzb1o3UEUvUW44WGpqZWZnRGo3VjJ4c2FHdEdvbS9NR3pZME9jNmlxZjF4SURBV2d1c0RmTmVONW1xVmxKSjl6ME1yTHBWdXNQOC9GMXdhaXdsU0dkc09HaWZWdmhVTmR4UmxETmJlYjdEV0dnYzRXSlFvd0hSZ1JqTWt2MWtsdlhKdSs0dHZpRU1qYTd2dFhpemZjaVYwbiszK2tRVUpQM09zWU91TmlNd1R1L3pPOHZMWHE0OGs4MFRFL1l1VzJ4YWNnKzFUZDdhYTEvdUFUMkhFV1kwOStDWU11Z2ZYTVBDcUd5TVo4UVJRNlU3dXBSUnl1TU1PY095SHgvWlAvdlJzNU9GOUF1eGRHRXkxTzZ2clVYNi9UVnl2dFI2TGorWnRxejBaUDY1VnY4YmREbDRjSFgxL0dBSHE2aU02S1ZDSytsbzNtVzBqSVI1RnJZYlJNTHhITmxDZUJEaWNIa1BJcnNJME5MdFJwRmpkeDJMYkNMM3dvRStuUG1EaWNnMzRETzkzdFRRS29KWFVvUElvL0F6QjM5S21LZGtsQTVtSTQxZUdFK09ydFEyNW5Pbmd5dEFsN09OcFp1VFdlT3FPYlRSaHJ2azl0VURqVm91bFc4ZTNuZmkydjR2dzJiZjZvRm1oUjdaenZ0cmtXVm9TNzRXTWNrMENsZlJKMkw4djljcm5LdStDdjZUVUxmVUkyZnFuNkt5ZkQya1QzOURQa2JlVGVtVHYwVUJocjFJN2VSdnVQQUcrSHZpaWR0dmYrTDJUNjlhYStUZDlFaS9mOGRiNzdqanJSZGV2cEE2OE5BSVR4ZEY3VzhaT1FmRG96TmkvQmtaRHh1VWNmem9DN0VYUDljcWJRMEZodktZNjlqN3pGQXVHV2kvZDBvbEdKWmYzaTZiak1na3Z3RnpzanFVUzdiSkpNZ0NqTWdsc1o4R0o2VlZFeEdmYUtlUzk2N0w0S1M4bk9La2hOZ2JCWUtabWJWWXpHNTE3VnE1Z29KeGpweTY1NTVUcEpCTkpMSWt0dGJmV090bEcrb250Ym1RMXNjMjZUM1JIZlJTZXRHMnNhRENhS09lM1JYZ2J0bzA1M0d0VS9OckxvVzhibmU2c0EvY0NQS3pLS1RrQ0ZuWk85czdsU2dZVDdXK2swalV4MmJ5L2kzM25Eb2wzNWdnUE5OS1pEZGJKNHhwODZWWGRpWUt1Vy9jMWVyL0NDNHFLdE9LYzh0NzE5YVZHeE9mTjhYV1huakZFVXdkckZkaVI4MXFPZUpSc0ZoNHJhMWF0bnVuVHZWbTkreVozVmJkRDVzdmZleWw1clJ4NHR3Sll6Q1BMRHJYY3pBcUI3YitXbWh6RnNzdWltSGR5Tzc4R2RxcmRjOWJxRFlYNnRlTzExL095YTQyZlppRUVzdjU2dUxxK3VyQkQ1T2V0YnhXSmM2VjlXaXNZcjRnSmlZZ1pmSFRwQllKekJjdmZxblJhTUN6KzZ1OVJtT1pFaDk4bjJkaC9GMmdlZkppTVJCUXk5VHkzUW9HbW5qUzIrZHV1UHR3ODJlSDdqaDA2QTZpdjYveHFsYzFjSE1VZngrS2VNY1FKN1VZbThlWWxFcVl1VzZXaUlPTTNCVDBBNnBGMDQzSFRkSWRpUGExNml4RFhTNVpleDUrWWxJT1ZLSDlKNWIxR1lrNWRndzJQc3NlT3k0SThjSHZ1Q0FjLzBVOTdmYWZjMDFkSWZmZTYxZkloTXNiL2VjOGJYVlZkOG1FOFdwV1lPTU1jL3c0dzhSaDk5Z3h2QjN2eHB1UC9hTHV2UkR6c3JLb2t5ZmZsZWwvbmNSTWEzM2RDc2N6clljRDlkaEM0aHErSStybm9UNVVZNHJlMEpqZUJWTjZObEdQalBEUTgrUWZMbm14dzVlOC9MRnRsU08zYlh1ZEgrOTQyV1BicWpLaU03UkJmbDhCYm9WR0hKakVZRUpZZ1M2bXlCYUhtQXZ4UE1KQm9zY3crdDJIbUxUZFlWWURFTklRbFNEMDhlcFNqMUYwM2x3a201SldsVDJXWjRTa1lYbVlzcUZlblhhVmswVS9YL0JTcDJ6R1Rtcyt6emsxMGVFSU1mL2FLK1Q5eERHTmd3Y1podS9HSllhNTB2UWswMkJGWXAvNEFjK0lWcWtWSnhpVUtyR3NsamNWamk4dG4xN1lkV1lwWDVCNUZyM3NNU0d5UkJSZStOaVpYUXVuOTF1OExiTWlnNmh1YkVJdU1TTExDNHJCa2Z6UzlweE8xUGFLMWxJRVFyV3BmR0szVUU3QkZCSW9uL1EyTHp4ZmFEVFdNZlFhVnNITjNrNmZyMjIrU1VqRnUxdTV3S2d0Sk9pMlJEY29kOTFXVUVaL3BRWlpMVmhXZjlXeXlQbit1cFhOWno1azkreUg4OW5DUm1GdGMvTjU2NFVZbklyQjE4V0w2OHZMWkxQUjZKOWZMcUF5aWgzU1lUWTJnVkVWR0loZWFYbUJFZXBXalRETGRqaDlRbDF0cU12dHRIakUwL0pEY01WSmhub2Z6d2NSRHFSSWthTnlUQ3ZlN0RZWENZSk5kR3BrZGIzLzl3K1pyTWxab2lGeEJpdGd3QUF2cFNTT2o2dEdSMWNERldFRE9abXc2dUZrbm9HK0VaamYvRTFabEdRbUlaYlZtbkdTWlZqMk5zRVFDTnhGNFBzMmhLeTl1TDdlUy9sRVppUk9RaFJ5VmlBODlDM0hNcG9nWmlWQkU0aklDZHdyeExuZy9VUmdKY0tJa3ZCSENrOHNQaUdtNUpzd0UraEpUa2JNVzVrN2lRbFVvRFdnUjhtRFFITm5vbWpOZUZSTDlIMXBOYk5rQ0N1R1BnR3RLTHN1QlZ5RGs3QjR3Wml1UmhTVlBNaHh2UFRKVDRrOHg5MW5tS0tzV3BZcWkwejVjQ3JwK0FZeHpKbDJuaTJpWlZqM2FjSVc2ZmVmTW94bDNvcWJmSjdoOWlocE8ra3k3UHNNNDZrck82S1MvcUEyMEZOdXhSN2xZUDR0eFpaak40ZCtzamhjTVBFdjZubmFWWXBrSjNxaDMzZ0hVNXlGbmlNbUNkTWpGS05VYUtGRFF5dEFTSlA5WkFnWGoxUUdYZmhwb0JCNXJieS8zOTh2ejgzNUZoRzBCeldlbU81K2czdHgwRXZlemdrSXlNQ3hrdkMvZUptOTlzNFRweWt5QzB0Z0JzNEpYQUF6bDRSZjg3bzdQKzhZVng4dlZNK3FlZWdXNkxXc2R0TjQ5ZzhOcVA5VGxlYmFXcVAybElRSmJDb0NJOGlJTWZENjF4OUNQQUhvTDQ3aDlySFNHRWR3TTJ5SE1FL2lCTVgzUGs3N0xBcHRIcWFPcGlHSjNUQU1zVm9Ldi9DUWVPbWg2ZzRNRVhLN0lUcEhabWFQV2FMSjhBcW43YTFXOXVwUXk1eGk4UHd3TEZwWG5GVDIyVXNQS2FNUUl4OFVqVkt0WGpKRUlpZHp1WlMwb010aFRMU2lCY0hJL29WdFlDTlJQZjhGNUpBM1FXOGp1dFhSMkxXRERJUTA5d2JtOFViNElwU3RSTXBNb1VORWdFbExnY3JHZ3k1d1U2Z0M4eXJkS2dWazVTSTd0eHVFTHZSaWFNOWI3OGdMazJOYWVmN1FvZm15TmphNUlIZThtUktmVFhiVWlZYWl5WE1UYWllWjVVc3ovWis5VVhjekZYTER6WmdrTGJoUnFHVGNjOWJhS29uTnkvUFhYREUzclV6T3pVMHEwM05MeCtGQWtDMDJpRE92NWpGYVJ1RHk2cnhER3NVc3VSNW9iVDFsZk82UnMyY2ZPVXR1djk0d1VuVkN6cHkzQnJSMVVPZUYvMWh0UmVyTlN0N1loVnBWOUgrL1ZwKzFMcTNBRmRjTUs5Qld0bGNnOTZienNGNXpJMWlQa1ljcSt1QzRkdEZHS283YWNIS2h2MG8yckg2dlR0YjZGMGlETlBvWDRiTUpYQlBOdjd3Tkw1SnFDOGpvM1p0Yk4vWkdidG9tMTd2QXZjL0dkc1h1Z0h0ekxPYndLOVZtV09vK0dPWUpxMEtydVhHNkYzbFRZNnc1UWdGUVRLc3daZmYyRC9YbHV1UlQ2NUtqK2JvRzB6RlYrK1NwNGQ1L0Z3U0dQRFF4bGx1WVBhNjVUd2hxdkRUWUlkY096dDJYMGJMQnlDZWVWUS9zUERJNFN2YmtiN3p1YUJCd3A2SnZ1OU8yeElmNC90ZG1YWlo3b3BqYlhScnN2Q0k4ODNCV3l3VGJQd2RVTFBFeVIwTTd4S0R0QXBoVFYxMm01V0FvdVdHOUw5Yyt0UjF0QTR4bFRieHM0L3dGKzRSeitOOStvVzFIL1lmWUp5NnAvenVkSjlqK0R5L1hhSmR2eXVBdER6bFBqR0tFb04zcEZwVG02ZUx0MFRXN1NVR2RReHliZ1JkeWxLd0NNYUFZbWdRQVBUMHBMbENybWVQQ05MdlZDRUlDVTFUUm14RlVxQ1FRZGFWYVhqUXN5MWdzVjdkMmY0MVN3V09CSzRpOFlMdEtodUY0NGlmc25LajZnY2NRRW1RRlhaRkZ6Rm9sU2hoRFlqZ2VZWlBGbkNVbUZNdFVDZzdEa2ZNN1NnMTNDNVJZL2llWHg2SlpwbzdvTjBtT3lUbHBoaW5BS2pSSkVYQllSbUtoYUZFdlEwSGpMRk94NHd5eHpXbVdiT2ZqSElwNEVLV1lESmNSbWhxS3g2aVJyWVFGTk10UXl4KzJVWHhuRTEyODZXR1dJYzREMTl6NE1NTW9ENUlLR1hsNXdlUTRZbm1EWmhoelZEL3BiR3NGbVd3OGZKUHJhUHlSMWZVYmVjbTU3cFUva3F6SnJacFB5allXTWF3dVB3MjF6Y01LT1JYVlZndjlxR0xvS3lCQWpaQnd6blUzSDNxb3NMR0J2dHJ3RmZsRXJJTHNSYlBURU9xeFRxYmRqUTMzYmFUZ1AvMjAvOVRBSDJ0UWp0ME41dUFxdUx2d0VPbmgxM3BzMnpWODlLenU1bE5QUVFuaytOdmU1dEpIYmI4bWRJK25qeURINlFNUnN6UTY3eUdlUUpnekw4U3pvb25ydTUwdk1NeHBBcnpqR1dEdGpsaEhoQWRoLzBXRVlaYmg5d0dTbGFUK1h4NFFoblhLMFhKb2xoYnFSdzNTU2JFSkRGSVF2L2x5OTkyMm8vQWQ1UUFEV0N6TnQ0cTFNUEVGbFN6L1FoQU85UDlTa2tqMkFOeEVTMlNrMndSNnV5YUVwVEhiNitVS3M4VDJnS1VQQWJpb0hPcDlZY2N0aExsY3diR2QvVldwaGYxRlczaVZOdmRBWjdrUWU0RmNGWHRON0gzVW0yTVFBM2M1S0tUUlFEMDhIWDJobHpNbVk2WndpSEdVUEpCckNFTTh1NTB0Tkt6eUR0eXJ3WG5FRWFNUk9pTVhlVHN2KzRITGlxWnE2NjVqQmFuQWkydUtxcmhXT3A1UHhBTkwweVFRQUF6WlNva2NJMHQ2U2xKRVFRRW1XUzM1bGltTGdsTkZid2xPMUVWTkFmNVRrUTNYU1dTOHVHa3FpcVE0dHUrbGJCMmozNndWa2ZNNWRLd2dISyt3aG1GS0lrdDRGbGhLa0RFNFJlTEVoNGlnR3hTdVh4SnRMeFdVTStuQXRUUlprZ3cxWWFjRDI5Rk1RUlpSZE9FUTVpbWhtRDdqU0daYzVsWDduQ0xCaEdORVR0YzEyL0hOdUtTTG9peWJScEFNQ25iQ3RrU1I0d1ZKc1FxU3RxQ3dQTTJNSXl1YUNnS1BZVWtTTC9ISTI3SjgxSGNrQm4xM1grd0QwSGMvVGRjaE9TcEhYYmQxV1FqajFobjBIdTJpMWsvWmZZUE9teVR0NFRVbThYeGgyMVYvbFdGVlRjV3NWNk85Qit0WFBCRllPdlNlRU5jZHpRQUpnRk5zUllYR0JFRklJREtuV2JadlcwQ3VrelVHczRoeWtpcktFaTlBRXhtMjd5WmQzekJsV1ZKTjAvTUNGY1NqeENGTzhBaUg2YnBCb29NdU1hQWtnbGpvdk1ESkVpTGZyd3VXcWlneWgvM25aSUp5TGpub1B5M2hKZ1BieWtpeVJEQzdDYzlKb2liRG1DTngzb1piV0ZHN2k1Y3c5YmZJYWFwbTJuSE5sVUdBaExGbmVuNGk3U1lOWFJKQnRERm5lYU1MTmNCVW0wU0VQZ2FabFhpV2dNRDJNR1ZaTHBUbll6M2dLWHFSZitkUW5tK2pONmJmOHFtZldLdGQ1c044S1RUR0NQM3AwT2RxdWRjanNXWFk5cDlIc1gzWjJyQzZGaHl5THNKUGtPVXZYc0RvbUFMNngxaEFVb1hoczBaam0wTGt1aEdQczhFMzZ0eVdvZERUMXZXd3hiQ2ZIaTBNaXJJMk53dGh2TlFXVDFRQ0dlTlZzVStnbnlJTXNISkptT1JLMVgzY1BFaVd3RERNUlZDK05lcjJXL2FRLzZHOFpTQnViU2pmZ0Q5YTg1MEtoaEpXMnhSaWRaQkFjTENoSVp6NHpaUXhBME4xKzluUkRlWnAydjZNa1EzNWtIVDMxWmpOQnY2a2xRZUllT2ZWa2dYZjF0cUxVRzcwZUtBQkxHL0xybUlabW1uQjBOUllUQlFubW9LbmtQN1BycjJJWStOOHdHQktBay8yRmN0V2JTMXVHQWFqc0xvaW1TSW5xK3czbDI2UmRGODJKYzgzZFNNd1hOVTFOVitPeTJLU1QzRms2U1l4THNPbGdhc2J1bTlDQ1JhTUprOFdBejdCL0FxNStrNlJQTEFpaGUvSVhIMjNCTDhNd1h2UkdsRTl3UlFOVVpJMFhiY3RVek1OMVpGdFJQaG5QZDdGUEFJdldrc1MwUklsaTVGWkhkZ2pHMThQWHNXRGkzZzJ3UWN3R245SHZHbUpjR2srS2FpQjdCdjRkclpyNkthZGtDd3BxVWkzTERGTXdNZEYyWlVkSGQvTzl1QTkzVUEwSldYRW5tckhUc2FlSEhCQmM1UUpRaUZycnVNMm9STlE1cnJzUnZDYk9iU01kYWsyaUg0UE5xRjJLT2g2WFF5L2phNkhmdDlSUXZSVkV1UGJieDl1bm9YK2xPOWJYbm5nN21za1QrVVpCdW90UXZ1Nkd2YVc2UTlxSThjSnE4b2Mxa3VIVG9aT2pHdllHUXEyRjVBT2JJWDMrVHJ4Rkd4MmljR01hWm9UdHJzcjIwQ1BPWi8zR0VhRkRranhTUkU2Mk5kTWFFN29jdDMwUGNrazV4OVlzYVJyN241Z1pmayttZlJmQVVVTit0M0RyakYxQjFwWnhBSEY4Q3IwRFl3QUZub0toNWFPNzJJN2hxNnpNbU5KMEt2a25SemhWWVp4ZVk5RkowVmJkbFFEMzhhRk5VV1NSQnlrcWtlVUpQUmpBc28yb0YvaFpReGZEbFFoeVZQZmtpMWJlT2oxM2dXWjVoclV6UTR0ei9NMW1xWUZTRHJPMVdhOEJSSnpreDdyZEt0QjlGM3IwcVVFOW1zZVZRSlJqMDJhKzZjVll2TjFhSjY2ZUdURWZ2dWluL2V5dVZwckNkb3dENlN4NkpKSGo3WnZQdXBvVjVTZDNCUTdPMTY4V2xLdXZENHJuTjN2Zm9KTTdwNFM4K1V4WjllMW1PUEtVSnk1Yit3UkRuWTlkWGRrREY4NXVkQ2N0blQ5WGZWcXVwem5abWRJWGRnemZvMW43MzJkbCtnZUZySkhscUM0MnZnc2Q4aWNoSWx4b0owcWlYbkRmT3R1VWkwbWdtcXBkWnliU21sTE8yM3cxNDYwQk0wVUVNeDNhR1F4MXNkRDVMSVEzbE1vVTR3cXJDSnExdW5BcGdnQkFsSzBEa1c2d25tQWU1RUhLam1lMzYxNjNZT2tuTXQ2ZVYvaWlGdms4a0JmR0kwUnJ0Q2NvemNUK2ZvckZjbDM5NThsNWJGeVhwemF6WWpNL0p5akdEREcyS21jMHlscVVmMi9lM2hKUzAxeGNDdk1jMnU2S1FHMW1Kbmw4dVYwbFp6ZWEzdlhqQk90aG9XWmh6Z1lXYWFSRjBzcFJtYUNhcEFvVnNuaGJzSmJQQ0tQMm8veU1CclF5ODdMQ1VGeFVhWUFWTlNhRnlmRjZqQTdKS3pYMUxtVExMS3N5anBNa3ZUWFdZdlhlZUN1R09hYzRSbm4rbjlMSnVxVnpKbE14WmJlVjg4eGR6SC9GYkVLVlpjRllVM2pkY25VL1hqV2ZwM05ZSUpWeHV6L1UvM2NsWVVneUI4NldyWnZTVHBPYkpzL0R2VTR2Y3hiTWYvZWU5ejkweno3STlIenVHMDRUYjNZYTlIbXRUMkdQWWppMjFIVjZRZHhqR05CSkYwTUZ6RVpPREZEOXBOMnR4TW1HNk9weUVBU2FIcjBqbUF1ejNoUnR1QW9ZelZsbUxJa1RNeUhtbU1nblREcFFxaTRlUm9hL3gxTXczaUhoa20rQzR5cThES3cxN3pHOEFyRCtLekxLeXBUQUxaRzBPN0E2MEFRV0pha2M2NktmR3NCV0ExR2hLdFpYbFlaVmVaWndXZUFFZ0lQVXVCRWtLZEphTmt2MFRqNzY2QzVUTDNxazQ4ck5sSGwrL09tSk4zdkVWdjVPUEdydWdsbkM1YVY4T3N1KzNFZVUwVGV6d0Z6cktyQTN2RGsvdi9EM0p1SFNYSlU5NkladVcrVmxaV1ZTKzJWdFdiMVZsMUxWMVhQMHQwMWkwYWpHVWxUa2thRDFsRkxHcUVWcVNVd0drWWdDb1FSWUFHRGpMRlkxV3orN0FjMmc0Mk43QWU0Ylh3RitCb3p6K1ppK0Q2dzIvTHlmUDFzTXl6MncxdnB4WW5NV3JwblJveXUvN2h2cGl2WHlJZ1RKeUlqVDhRNTUzZXdWTXZpZE5QUjJIaU83R1BINzhROFhHaVlBZC80Z0c5K0xLbDVaQTNaMFBLditEeUFsU2JmN09QMDZrbW8xaDBhRm92WkRJMWxMU3dBSWd0aWRuRzB5bHRJRWhRQXJjMWdGckRhSFpBV2RWZFhkVXd0SzZzVlhCbElqNStUVGlJSmkvQTVkQkxQQnlCV3ZJTEpyZURwQUU3cDl6UHFCV0s3RVlaWktXRHRkR1p3VXdwTm9WTjQ0c1NlS0JPQlRUV3p1cDVaUmJ1Zml0NzRWUFRENjV2cmdZMHllWmJNWnlIOXVwK3FUKzZQMzYwODFjQjlpbWpONllnMVEvdHVVQkJ1VjVpaFd4RWZXOVZwTTBzMENjRXJXQkVJRmQxWmdwVjFnR3lIdXlnMXU4Z3JYS3lkcWZJbVg4M3NzRGlGWDV5OTNESVNhTDVZbUtkUllrZjdXMnl2Tko5cDc0cWovbFFac1lOL2oweVhrc25TdElSRUNaV25abWNIbnh5RTZHdzJtMEdEZnl0K1YwT3RYQllOL21XbXVQV2RNK0NkaXphY3lIWWF0OUFmYVovWUZhZEhwUHoxbUQ3OE92YXpnMmZIQlkrSlFiZG54M1lVSDhObFphaFpINWRzNU4rVFR5UHdGUnNhd0VFTVB5eEtNaEVDYjRPVEFONUUxSUlBQnExb1pBR2kxMEE4Rzk2S0VPQXE5Q1l0R3RYZUhSZkYrTHZoNkgyNkxPdDVYWHEzTGdtbkkwY2NTWEs2dWx1cmhTV2ROMDdqTHRJM3RNRUxtb2svb2xGVFF4bk5VTlhCSjFGTENPdURGd1FGZFU5b1BLK2RHUHdKeXVoUHVPNFRZV0h3M3hWbHpDK29Bdy8yTHdqRTlIblV1WGcxOEEybjQ5dUhkcHdXcWpoZFIrcHRvNWJIWDNLVnQyczFsQXkvNWpWaC9yYnQxTW5jNFBNOGo2N2dwYWRkOStsaC9Kc2FudS8zS0pFeXFSVGxnaDBWN3NONVFDcGFtSVRsNkZpK0JSNEtGbzAzMElxdWQzVWR6RG03c05uUUIzZ2U0YjVJZ1gzb1dkZlZmYnZRdGQ3WnM3M0J1WTJOczBPOW9GOGVRM3gvaUI3Uzgwc3JlRG1ya0N2Z1BNNlFuR0VoR21kWjI5aFlkOTErYndKWDBDYklvVlhpRlpNakVJcE5INHNMOXpGOEpqUUo2eXlmMUVKZ1A0Um5LR3Uxd1dyTnJhWHYxSXlhdTltUDNLNGhDc3pIWFV5MTZ3N1h2ak8wYTJoMEJoOFl4dURYTnpmUDFYVDhyeGI0L2EyUDF0RHoxRFR1NmVDcmhQT0hXQloxZjhxRktSaFRZelc5QVB1cDV2YlFlcytkSkdFVktNQWxEamJPbllOOXQrdTZRZW40d0RBeVcySlVDY0F2Z2x5Tk53aW1lY1FMQzlVR1o1RTdPQWNoWUdGaWgwOTEzQVQ0bkJ6VXVsdmZUL0EvSTdsRVFZdGNnT1E5Vk91ZUk5bjBCMmZQVWVySTF4M0tCR1NybVpGVzZEcnFab2dPQWJYMkFORG9QSHZUQmY4OXc3WDN3SlM1MVV5anJYdXJFK3lkWUM5c3V6Kzg3bTZlM1NDOWF4TTI1L0FrRmY5dHVyaG5ESCs5clp2UkFYSzdYWERldzkxL0E1NUZ1SDhPMW4xRzZ4czR3VnJ3NndkUERjOWQvZlFxc1ZVTDZoL2U1b1UxRDFJTzJsWm5KN0RhRXNiV1cxdU9QYnhGMUtnaTM0WVlucjFhYldKWE8zdVdqQ1FqWXIvZFAxdGJxL1h4ZjMrN1d0dU81d1dVWlFGWE05ZnlSdTlBeTQ5U05uUVR3ejhkcmZaV0IvMVZQTlB2WVE2c3dwUy9oM3BkL0dMaE05ZDFCNmR4ejZPNllKemR2VkFaZUw1ZmorVGlhTml4TFdKeVFJN0E2d0l5eGhOOHNud0FKcmRRR2VLQnlaUDN2SS9mODJUUWM0N2d2bk8rUHhua3RZemdYUUhQc2htYXJBek9vK0dTVUlCSkJyWXk1VzFtcExDZ3dXTVJBZDBSaWtSQ21IZW1xWVh5b1lRbDNpQmFpU3UxWllGakJEN0NDRGZRbkdCSWVMTWI1QTdNM2o4OTBHd2VhTzdZT1RXMWMrcVhJdS9wSWplaW5kR2ladWhNeUNBdmZlWWJaOElNRm5Yd1ZJbmxMU3dtUy93WlFmNzl4b0ZHNDhBOVV4QVM2WGdrY2djeEd1UW02bGtJTUJWZXFwWU9QMkZWdWIxS0Y2N0trNFRjcjBUZVFBaGU5UEZaenlQNXE0UzZ1eUlSaGhDNDI0ZHlESEJCZk50MGhiUm5GY3NUMU5pQ0dhTGJqNCtqQWdmNGIxYkJqL1FReEx4MXVFN0pPV1pxV09qQkErR2ZEdzhPNm9NZmNFTDAzTG1JSWpNekRDdW1jeHFlbVZTVXdWbTNwa0VxVEZ1d1IyNi9sc25ybWhiOWU1VVZkRVhRbnI0emUyWlN6Z0hadVR5bWJMaS9DRVUrTmY5RXRqZGNrQTZmQXY4UFpiYVh2dFcrVy9MOTNhSldNL2hXQ0Rud0F2QUs4S0ZyT2kxOWRRM2hzUUc1dFZEMzQwaC9rWHAvQi9VMzlNMjExYlZOL0M1dGJIUTYyL0FEUXNNNDRFNlFFLzZvcmZXRERFNnZyVzMyTjd2ZGtiOGw0Rk9rUWNvakNDRU8yRnJoNlJKZ1V2aEdja1BndzhDZ3lTdkFtbW16a0E4ek02aE1GbHZyRHF6Skl1bnB1NU5ZYmcxNWVFNG5pcXlNYUxkOHNOVjQ4U01QUDlTYmNXbWV4VjkvaUd6Wm9CbEdvaU1NWWpPb2Q4Mk9jb0ZHdEtUd1V4RVdTL2x5eGV2c3VQMm03c29ySUo0a2JTTmEzSUVBNnJoYzdXNk5HelZFbTM4cG1oNStxYkpYTDFZS2xQRUk5UTBVSnZnOG9LWUJPSVpEck13dUd2TnZpTHlXaGYzanhrUWJpZ1NwRjNSTWZtcDZtekVzS2hwdjlSK2ZJMVBxTndFSTFCb0tHMCtTdktnWGZjL0wvNGVBUTIyWjErdVQrRWtFZ3NSdStOUHlNMjgxM2pCdkxHSSsrelByOVNlTngrSDhKWHdIakcxZ3dhY21pSGtEbURvY0gvcUErcFI4bjlnL1hNeVB3ZGppeHhCVWFjdno1L2t4WE1oT21Ld1JUK2J4dTVHSHQyWnpwUCtleVBiMWp0QldwS3loMThGZlJsYURaKzkrVHo4eTFDbFJnSDJ0Z05mOE9PRGo1OVNqUjRkL3lKMDQyVTV6RXVjUURBdkdLUExPT0I5VWhuSlAvZEtERDY0LytPQW5KalAxNlRnMWVBVHVyRCtJTXBPRmJNT1pHWllRbmNDWkNYTCtyZkZUNHp5L08zRXhzSEhlUUUvamZyZ2ZzRU5BMEFFTnBDOUJ0M3lZdXlHTVJlQ0tIcVpCNTJVUEVWOENaUml4VXJiTStrYzdla2M5Zk9nNytmbGEvcTdiMlZUWlM0WjNUYWZxSVY3RHM1STRneVFuT1pPOStlWlNLNTlrYzdhbWFqdnl0Y3YydFgvNHc3WjZ4UlYvVTl0ZjA3MTJ4WnhhekNRMFBJanFFaU1XbmN5c3ZsQkt6MGxXaHM4VTl0Vkd1dWtoN1pVZ1hoc21mUVVGdEJmd3JPMEM5SDJia0tmOE1kRDNWcjFnSGRoS1NPaisrNEVPOVR1WWtDZWYzRjdvMlBjcEFiaXBKWDhVeVoxZkRDOWNuSEhOSEhvSVNoLzh3NmpvOENJdUdxR2tWMDVkZ0ZsSS83TmFJZDlvbHpFeE5pYW1kRmtOMGM5TUxYclc5QTRYdUdSSE1KZEtzZXdjdFEyREQ5cVVRSVNCNVhJQTlSRTBhc0c3MUVaTm80OHFodzZySGYwWEw5Nm1kZ3JhdEx3d3ljb3ZLSWNQSzdoZDdVWWhYOWU5eFdsa0FyMGhudEFyVkdKWjNLcmx6RHlwVTNGL2paNmtuWUUyQlhsdGlGRFNjb2hkeVFVYU5ZMityVDlKbXBPMGJLZVEzYjJWa05WVkpBSU5UN2NKUlU5dkxSUk50T2xMdGVoRkd1MENUVE9jTDRKOGxhYnExUFc0RlVBZ2hDaHB2cm80YUFKODdpK3VZZ21yT1p5MEJzNlpYS05EZlBrQlhqalFjTUthSzRrM0htZ21tMjlJbEJBakl5MHFLK0VQbStrMHJPRnJER3RFN05RMEx5Ykw1ZVNIcld3cVdrV3FvUE5pdnNHeUtUc2V6OXUyVUE1TGtqeWIwa1dCVXd2RnhtWXBydUt2cnFYcHNwS3VaQkN0V1pxbUZ4TGx0cGUxVFJlSmJ2VU9WcFk5WGxENUtGTDFRbTQ2WmtZckRKMmNrbGdrcXJGVXN4REVkS0htU2IyelpHWFZyME5oSENTcXRZWCtDOVViM1N2b0lwOXJNa0xNY2tVTHovN0haUDd0MW1xOWl3MkpaZDdROGpHYmRpSUt2NFdhMjhmVUMrNThRTnNxd2pJb2FSUEEyWCtaTFhMSjNOWi9PamRITmd0QWorOEJlWDU1MjdKMXQrWXdscEZYcUQ3MU51bzkxUHVwajJLZWg4RmVSUWgrWVZTWVJ4T21XZk9vdFFMb0xaM2d0NEthV1RSaHJBVmVUQ3VvTlk4bWpMbnd2QVlQRWdMNE1mblpocEVGRG5nVDlsM05GVFRLY3JSNGJPTGMvUUNSSFdKVEY2alhCZFRQTVVrMUwwYWN0TXlsTFUxMHBaQ1ZacFdNWXdnRk5VVVhDblJhTFFwUjIxWFl0SzFLcnFUYWFVN0oyQkc0emVSU0NkNTErUVRqUmlOY0tzWHhwaXNLa21zS1hFcXlPTVBBbWZPNUhKOWtja2FFUzZld2lKMFRSU0dIN3lkU25CNTF2MFhnVm5YNm5wUW1WdmV1VGJtSDc1R00zSnRUT2ROT2ZVYlV6QXlucEoySWtGZHhEamttaFFtTk9sbUZHMUtTNFdUWGpvcUZVQm9JVGFrRjBYQXlNcGV4UWxMUHpJbUNtTU95ZnpMRlI0dzhuZkFKeVJ1OHltV1NuQkJReXJQSk5FOElGYkpaQVZmRTBQRVQ3RmNJRUd4TDFGTDMwSHMva2p5Y2NveGNPVHRUeGFUZk80cjU3TTg1UUdhOEFVc25WTlMzZFFDQVVkL21XaUFCL0x6eWY3VWJEQ2Q4ZjJPYnVkVGhFSkJVRlIrNTU3QTdWYzBaS1BkZmE4Ri9KazJBcGdVelY1M0pIbjZWM3hUdlN4MU81b3paLzFJVHZKdndFS1J2U3NlOEFwL1ZLV3FCV3FJTzRKbjhMZFM5STk4cWdzNUkzclJocUJ2UGRBTGNHOGRIWm5VV0NGNGo2UHJLUk1tSFArcWdGSU5Cd2dZbFZ3ZVEzUGtHTWJnRkpUeUIxQVN6WVo2WTVLSnFzYnEzQ2lzNmVGZWs5OTZ5OXl6aVpEaVhPYlRZVzF4RG5Na2hYVGRZbm9iUVo3VEJ5NWtLemRQNlVabXY2Zmlnc3Q3TDJQU09hS2J5N2Q1aUpSUGRRZHYvSU84dVYvZm04M3VyNWQyeXhsZjM3cTN5dUhlaGZCNXhhbVZ4OFpmeE1UNUt4MkpMQ0ZaeEdVUE5vR3BFTlVKVnRKSEpGSGxOWHhTYk9VQWx6alhGUlYzamkzN3NrQkcvOW1OTzNVRGRUdDMzRXJ3Q28ySjRtK0hyNU9VTHJYS2UyTU1RbTVpOFlPWHJ4T3JCTjU4aGdPYkFJcnRCdm1Dd3BpN2s4UWhSZ0hDS0RhSlRiTFRQWjlZYVluaW9QTEdGQWMrSWdIWDRFT0daRnpDRFp5RDZPMlpqVDYvNXZMc2FKbXpBemFPVmpNL0VDekhzdjlHTTZMT0NreUVvTjNBUC9zbWN6eENST1U1WW1NYk1QRklOQVF1WEViQ3puaUdNSlBpNTRtaDljeHQrYmhRSkNMOU44eWl3WStrRU5pMGdoeEVCRmIrQWZVVGxYNlE2WDFPK1Z0RjF2VmQ1a2FvSWFUVlZTU3VwRDZYVU5KcCtrY29qeXYyYThvY25LcFUvcWxSZUEydTVkK0M3cDFOSzZtZFRZS2NMOFQ0SDZDbjA1dk5vSUJSMEprb25nVFk3UGxveWVNZzhSVW9IN0lQZDNmeWNNL2RGQjIvdzM0NHV5ZzFleEx6WTErMytVYmQ3MG5Ydm1MT3JqbE8xVCtIOUxRU2l6UGNuQzJMYUc4VDd0OVVCWkMyaEVBRUg0QUtBcFpGWVkvUGdUK2FnbWo3WUFHT2RqM3hLK1p6N09lVlQzMlpaMVZKVVh1VGRzL281dUgzdUxjR3QzOGNYNFI3TGJpbEhJTWo2MUFvaXhRQWZjU0hqRWpiNlVFRC9EOXpQdWY4d3lydmZ4MW4zdTMrTkwyNk1jNTJjT3kyTzU0SEZ2Sy9SSDhrcG5WYWJ4QVJ1QXBnK2o0ZFlXOWlDa3g2b3Q3TWZXWnVyTkJpV1l5VU9vdnh5WnRRenZLako4UXhpR0R4dDUzaTZNVE1YekwzdVhUdHlXY3ZRYUZFWEZWTzFkSldXVTRsRW5LRVRpVVFLOTBQWk1GVmIxaVFaaFNPdHk0NXNuN2MySjlDa1FNOCtzbm56SU1BYjBTS1NtRFlRMTJWc3ZoaVlJNXk5WWVkTWd4RTRUQk9EYVp1a2xHVTRDZGVBYVZSMmpDYlBsMFhDdENUb3NxMmFCbENHNlV6UVRCem9wRlhkVWswRlY0TFdqTXRHYTY4dTBRbHFsQW4rcS82S1ZNZUpFTlN2VnJSVmlCUWlwWlpYaUd4MGU2WER0WE1Bekkyb1BlOUdxN0QyZlhqdzd6WFVxdzFPdTBnZm5LMzkwOTdCMlMweE53U1NMMFZXNENQTlNOU0p6S0JJeXlHZzNLNitjYzc5emNPMWpiTmQzWFZSYjdDSmVqZy81TmJXOUc1dis5cXdST0s4Z3g0Z2pZaUJtVU13dlRCMXVhNTc1cXg3cmpib282NExtZFJxNTl5elozR1cxQURXQUM2V1R3QW55STN6MGMrQ1hSckpDTmNHTWdJYnRVMXdPY001MVNZd0FoVmkrVXJXd1hIRjhOUENjUDROWGJxL2h0eTEyL0JzV2psMGlHZzU0RTFCK2kyZEgvMm9veDQ2TkpHUFNuRDkvSHc4M3lZZlFwUS9NOWg0Qmg1V09ycnVaL0J4ZUZEdGZKeUFUREFFWTNvVlVlZGhGTUZxL0Nxc3RNT3ZyK3VMNUc4N3JoRVBIQUNOekFyS0NibVd2NjRCOGdVSjdQbnh3ZStFME9xcjk5TkhhclVqOVA1WGcySGRhMTYvK2EwYnJxSVBsRW9INkt0R3VBUitmaXFzRDVWeUxTSi9FS0VFNXdVNVBUSE00Z254dWVlNlB6d3hmUDZFOXRSVFJDYnE0ZWRyVklSRVE2ckJhbVRKOFMxRHEyUjhJTzVNZVdMZzAyd1FNN3J5Y0tGMkNHa3BETUZTTGY4Q2VpTVdmMUx0dG5kNXVZUUhVcTlXUDM1ODl1cGEyNTVlS0Z6dUpVcWwrUWhCOE1jU0VzUWwwOEdpd0ZUTmFDSzZnUitNRnZONS9OaGlQS1BQMTl0YXFwQlBUTVd6Wndpdy8rMkEyYkNRTU1IVVFUY1NaalRnNmJBT2NlSlJmUjc5bzlWM0FnQVZFTXRmZ013M0Vyb09XWm9pRXFMNHJRUnRFQ0tXTllzbkZJZ1RjUk5vOHBaUm9HUk8weDM4bldvSkVVZC9ybkptZzhCM2xmN3dyaE5YSjI4NzBlLzNIM3NNVVk4TnNjN0pzenhaSDRNSE5rbmk3aWdSUjlLc2tqU0FtR05UT1lKa2pLZnpIYzREWFJ3Um1acXRNTUt2RUo2SzVmRW9aaldSMnoxenBvdENjMmRyRUtqaDdOd2MwdThnV0xKM3JLUHU2dnI2NnVyKy9iMGV4SjNwcWZ0UDl3Rkp0ai91VDFDZURLdThiVUFySWNEMXRqZURPb0VteUpsaENkN0dEUG9BenZHUk0yY2U0VHJDamk2bzJCYnhzRmJCUlhyU2V0STZmZG9xclFKUXdpb1VCT3VHVkF5ZFJ2ZGM0SnMvMHJJTnJVeTMvMUN3NXk1MDcvUmc3ZURpOEIrcUFBc3I0L043Qm1mMFdxMDc4ZmNpZGZyME92N2JlaFhxci81VUdpOUtJWGVwMUwwMGJXdTZmdnA4dW54OUFjU1V6cEM1TjI2WE5JUXBJMU1WTERRQ1FxdHZsTjFzdEoxV2ZuUTl1SGFPa1JuOGwrUFRsUjFDMXRJWmV5WloyU2xJR1lReWtsbXJ4TEtXNmNvNzVxTTg2aUdrZnhnaFJnb0o3MzdYeDJoR2tSVDJ3KzlrRlVsNE94K1NSbm9BbjVhZlFzbkZpNzFRS1VQTVpPckZJR2J1YnB4L0Jna2FBOTR5Qzh0TU5BaVlpK2NKRHZsZ200SkdCeWJteERROWlPU0wvNjlldmlweStabTg0dDZHWWpsWGkxZjhvTHF2RTJyNWVqMENwckNPcEJsVlJabUxLcEtwaGRGNjZ5Tlh6ZS9QYXRkZFZWbVptbDRlckFXUmRtRjcrc0ExaXpPN1Y1eDRNMVBPeEUxUmRPUFZxaVROeldjeXZCaEpwbjBicGhIZEY2ZjZZbVM5Wk9sYnNLUjNVSmZCZWxqSmhrRENPU2hoQmI4YnJWMklmSkN0NFM4TVp5UW1YNDdva09icEphSm90NFJPRTJKRHpxQTh4S0FTNmp4WnRHeUFxMVlkL1l5Q0NnRHZVVUlxQ015ZzFLM1Y2SEI5NXkyR0hrNGdLaFhpcGRjdytNNDNENzcvb0V6UHZsRDlxeWYzU2FyeGdpWUo0dFYyTEZrcXB1ellsOStvRTA5Q1YyZll1UDZCWXRLeFpkMktmSmw5UXRmZitOVkhIOVVqbFlwKzhpRk5VVlZCc0VOamYzVS9MbjJlS2xQVFJGKzVUTEFXaEdCTnAxTW5wRytwTmxRVkRCS0U0SWVyM1hJVzVsSEJoMVJ2b010RlFkSmVNRlJwMzVNUFQxWnVYVjhqdGRzajdmeU1mUEFEbHl2VkYyYjNoR3hCVUZWRmUraU95YXE4OFNIZGo4Z0ZmMStONkk4K0d0RUJBekV4OHUyNmpscWw3cWRlU3oxQnZaUDZSZW9UMUdlcDM2YitHL1YxNmp2VVgxTC9TUDBFc1NpTW02ZU1GdEFTT294ZWdlNUNEd1B1bVc4MU8zS3l3SDAzVHliQy9OQnBHSTRMK1FXWVVIZUdYc2ZFbHJhMTBDQWhmUU5IRElHWTFUWWJwbWY1UGhURXV3TG40L2hPR1htQlhDRXZpZ0JoYjRpZW5ZVE82bmpFNjZ6UklkOTM4RVJqUUVoditwSThEMzBYaThXKzJGNE92cUlCelczY3FjR2FGMTVERzA4MUNkQUNJWWhVQXFleTJ5c29xQXhNOWpGQm9OSXMyVUtaRC9zdWJRS1ovZ0kxRFdFWnJTQ05kb1oxWHloRGFLV29UZUFDbG1tUHBNWlptTGJWRnNCTHJrb0xnYSsxNDVzUUYvS0ZVVVRZZVpTaG5VYXpFOWpkMnVqKzBpSk5OeEs3bzZ6b3pDVXl0QmhlREl0MEpqSG5pR3gwZDZKQjA0dWw2Ni9QN1diUVFnd1N4V1luRXMzR0lGRnNBVEc3Yzlldno3Z1ptMU1VenM2a0xEdEdlN1lqQzhabjZKanRHWUxzMkcxM1pqNEZLVUswM1lQN3M0b1FPWU52VnlLQ01uc0xwOUFLUjNOOGlCd2dIb3NTb05wL1hkaWtHU01LVGlBeERjOHZaQlI2aEVFMFNscHdJMElqRmJ5RVhtWGtWVFVmTVNKUlR0Z2hjaEVSMzJQb0VIcE1uSVk3T1VPUG1ubi9Xb2lWcFA5WFN3ZzhUUFlkbmFVak1WbEZnc3A5T3FLR0VvS0FjQ296eWdvY0E1ZS9LNllrbWRXbWxDck8xWWh6RmhOaVZVNkgrRjRucWlLTFgzOHBLY2xjZUNvT0RrVndWNURWVDJnOGswa3NSZG01UklPd2h2Q3ZrWmhqbzB1SkRNTnJ3RDNYMlcyeXMxc1R6TExtYnNjRjlxWVpHWmlCdU50c0Q3UElpWVNZVjJLT2Vrd280dGc5bVNFY0N1N09Sa1BNM2ZobWhRbEZaeEdEMlQvdk0xb1p2TjdPd2tuV3h2WCtHREZBZTF0RFJBWENyU1hGWWVXSWFLRUhqTHlpRnZTbWlMckFPTVVSZjQvR0hJN0ZlRVVYWkE1ekdIMDhFb2NXaU1lNElqNWpPZWwvS0VsSnhIeFJQU1NLUWIwdDlMTmlWVXBKRXFmUENGN1ZsUEYxalJWMktnbFJCR2JIbzBvRTgxVGwyVGNrb2pLbkVtYlRSVVRZejB6Z05WNkJSL0xicVZkUnI2T2VwSDZCK2pnZU42aFN3eXdFQXdOLzNxaHdvU0hodkFGaE9CeU14cGEyYjBCQjNremVkb1plWHgxNE80Y0RDTHlRays5ZmRQelNPVFkzeER1QWQyN0xHNGJ1di83NjRMMHFMMDI4TDB2bDg5NG9jN2ZmSTBpWDJXMEdiOVBlV0h6VTc2OEx1cnFKdS8xaTBNZW5jQXVlSmIyYUpUMzh2Mi9wME05UDlHTTZNdmcrNmJ1aG9DZWp5N2IwMisvNkpSUEtKcnNpSVh5aXE1b2p5b09LbVVGWGZUeHZCRjNxTE9sRFJkeWJmcEgwSGR4bDZHdHhsNUZKNS9ueVJJOUJ0NDI2Q1JJL2lQc0ZGL1NSR3lZNnhtU2NhTUFROXdnNnovWllFZURRMmZUeUFCU1NhempFdGhCUU5BZ3VkejZ3bFVLL0lvZEM4bUJORG12S21pdzROUHNSaWVIUWFZNFJma2hPa1NjTzFrU2VRYWNGdElwVG5sVzBzSXg2Y2dqZjFJVkRDRTBMK0dqd0s5OFh4ZTh6L0JaZGFJak1QQm9UQms1TmdzNVp4bWRDYTBRaGVrNzBLUkRSUitVUXd3MTZIRE1rQnVuaTk2SEE3NHU5a0R5TjBDRlNMc2pjb3pVYUg1RVp2djR0YW9uYWo5K1FxOEYrYkx4dTAyNTJ2QmFlNXpkcytKUXd2QUJmbUN6ZGFUbWVZRG5OamxQMjRHTUhZZGM1R3hZUmFRZVdXQ0Y4V0Rrdk1IaXM5aHdBRWZKWGRmNlZadW1ZZVo4WkIvOFp3L3B0bTU2NWRrZk81dXFYWDMzZ011TWU0M1UwTEpOM2RsN2VIbnlSVFIrd1RGVC9pd05wdHQwdzk4M2JOV2NHRC9YbVIyYmNSWHE0OEhPTzduckkyME56S0ZtcGwzN09udS9TenU2ZGI5NjVFeDA4eURVcXJRTjFzN0p6ZDJ5NU9ZVzhxNUQ5YzJpcVdYV3UyblI1ZnZBMVZOSWJEYjJFbUNBbTVwZ25XU3dSQVVkZWlnK0VCeGVxK0FWcmV0U3Y1U2N2V0xmeksvTklVSkgwQmNrUC9CT3Z4ZjJrU3RvUDdFWjNVMWRTTndEZUplNHhNOGdDbjRZbFZNZ1RDOWtXV01tbVVSQTllY0dETVkvQU52cDdiNFRuR09EMkUvbTB0VFZjNE1jNURzc2xYQUh2T0p2N1E0Z2VIM1dpVWJ5L2xXd0wrS2NyaVJlOHhWUzYvRUk1blZyMHFudjJWRitBelZuOFJHSDh2S2ZvU25tNkRGdjhtMWJBUlRpYVc1aWFUaVNUaWVtcEJYMzVlTGQ3ZkhrWWI4dXZweEpZL1hVaG1pMmFJSXk4bTRIdGI4R1AvVXBFMFNYUWhUY1dDTmluNCt0Sy9mZ2doVHl1WTNBRFhUTWljZ2VwR0ttZnhSZTRrNlJXRFZKUG44SmxjZ1ZWZmVwZU41R1dLekJCVFpUeWRaZ0xVYkVGNXhSWjh3NXcvbjM3SkwrMWpnRFNmbkZrRDdnVmtYcXJyV0NnbXJUNTRDc0FscHJCSVFGOGFEYnNodit4Y0phUkQrQkFkQm9CcWdQK20zRG1CalA5d1BFWHFiaE91cnBJdHYvRGRSelhNY3ZsdjU2NGVKUE9SbmtoUGhOMWQ4VjJ1ZEdaT0JZT1dUM2l1YUdRc3JPOVV3bUZYSS9oUlZiUml3a1Z6MGtxQ3hVczlxdUpvcTZ3SWsremNralhiVHV5SEZ1TzJMYXVoMlQyeDZSTWwyeXZkUEtPa3krVzV5YXU1ZmJlS0RFTE1VbUtMVERTalhzUEhKRFljSmlWRG55WFNWODJ0MjlGWkRoWjVoaHhaZC9jWldrR3FacVo0am1PVDVtYVN0NEhuODlNMEU5V3FNc3hueW44ZXVXNVMrQWVlNUhJTWRzanlod3RsOUh4UytETTRMY0lULzlvZ3FHVEhQOVJtYjlJWmE4bmpHRkk0a1dmVlJQSFc5ZUhvVS9kUnYzOCtYaTdIVjZ3QTdtRGlEYit5cm9UZUp1UEp6SWd5Z1RlNWUzUkNqMlJlSWhTWVR3MXNoMC8zRHplbTZBQUk2R2g4UjZDczdkOVZaclhCdldhSDRrZTd4dnZKOUNoSzJTQkx4NE9ZekUySEUxS1dQNFZJWGFYeUFtc2xJeUdHWm9PaHprMVlscTZ5djIwVkxwbFJ0VGIzTGdXMHl4VjFFWFh4UnZWd3FkeFY5MnZYdXhHQUU1Nmtpd20vakVuaUxvWmpxSlJocmhZRkEyYllMTXhMSFNjWWtqWWxoUkpVYy9HTkRZb2xOVmlXYi9JOHk5dTlRa0E2MzZxZUtrTW5HVDYwTGh5OWRKcVBIRmprelRBQ3orTjBOSEZ4LzJBcm9HTWRBSy9VNm5BTDRFcTRkay83Mk1CMWdtV2FOMzBlMHFoMVNTZENQY24zL3dJajFjQnhTUEtQeHNPTTRsa29keldUYjFkTGlRVERGeElGTjI2cU9aVnNlN2lTeWU3YzNQZHVkOGwyNjhaK1ZpOFhSWTFUU3kzNDdHOGtVdkVTaGxWelpUaXNaTnpKQW41ODlmSGhuUytMQm92aWFhWG9tT3liWWtlRS9tTFFZRmJRS3ZwNDV2N3k3aUFZWVg2YTJ0cmVsOWZDM1o5Q09rME9zUC9UdmY3MjN4UkNzTTRMcEVjYW8xQzB3VHJUa0htK0hxLy95SkZZalNzOW5CV3NBaE1kbjBvQVYrbHhwZGdGMkN0QW01cW5FVHJIZUhraEZGZ3ZFVll0WXpHU3NaaFpKK1JXcEg0Z29QTkdicTh0WCtxc2pzMkxZbXB6dTdLMVA1V2RrYzR2T1BPcUNTbHc0WVJYMDVxV25JNWJoamh0Q1JGbldKNTJuV255MFcwdHR6dU5PcWViakdNVVBUcXVOOHZwK0x4MUovYXlaZzluOVE0WWM1eDVnUk9TODdic2FTZGN1TXBSVW5GM2FGdDlKRCtsNkQrSXBSZHJHUy9QYStsK2xqZUVFQlRQTVRRN2dCMHdqREFFZThVRm9pRjNXRk5salU1b3ZNb2l0TFJtQkdMbytqK1JQNWFHYTdmRzlidGNpSmlHMWJNWGs3SGs1T1lEREJ1ZzJmMytSYkNqUUFJWkV0aDlnVnNtTDhjTHlTMkZMeEVpTmxxVGZ6RlREd1IwM1VMMDJFWk5xYmpkd2hwNTlrcWV4ZjRndmpGVzgxeWdCREJDODMyd25JZzNYNmRGTlpNNUJQN295aU9DWWltTVNtc0ZCVC9CejRIWXNsNGV0bU80YUlqaVhKSUNNdVQzeTZSUkQ3S2t2aGVmcmZtV3A1QWVqVGpXeHdUZTRDQ3RiRyt0cnFHYXFkUDkvcmREZlZ6bjFQZHJ1NmlYdjlzdjM5MjQ3blh2T1k1M01YWDNxKys1ejFxZkhVdU5MMXZTMnd0WXlML3ppaGJrdVY2a0ZtUTFabGhGb0dkRytoUXdRc0oxa01MK1FCQWtRRG5nTkVBR1ZNV2ZHeGRNbUl2QkM4SVhFSWZUNmN6RlMvenVKM1AyWTVqNS9MMlRHZ2FydURyWGdWZngxZndkWHpYdjQ3WTlOWHBWT294MjNhNmptMVBhMU9wMUhsWENGMDNvTE9vQWhxSlM2T3J2VEJCMVdlejJVeDFMdk1HTTVzeExjdk1aRTB2N3NFVmZIMnVpcTluc3BVS3Z1ZGZSWEwyV0RhVGVjdzByVVhMTk12eGNpWVRYS25zckpEem9ZMGkxVVdBRmh6eWZZbUpLcDJNZkdJRjNBdHJpS3BVbmhIRmsrSVdYQkltd0svZjlreDUyeHZ4bkovSEt5Y043NGY1L2ZKV0EveXRmVG8rRVVjZ2tOOThCWHh6WkVIL1RTS0trV1htb09NYVJNajZndGdIYXNlWWZHQzlGbUJTZ3NmSU1GQWxnUkFkQ29mTWNLRDBUWTlBbXRxR3lZTjdDYjNkRStsVStYV2ZmdXl4WTN2YnNxSlpDWUlnbW9ycjRiQVFFa1ROWWcwamYyMCtuMHlFdzJFOW5pZ1VyeTRXM2pjV3E2cG9SM3NmaVlKWkZxMVVNVVJDVTI3R1M4V3lWelFNeHRJQTNFYlR3a244cEZjdWx1S1FUeGpSRTlJUXZDckc2SDJSaUVZM2Q1NGY0cXVvbjhFemxwK2wzazM5SXJFNDltZUw3V0V0dHZ0WGVZMGhrNFpYaXR0U2xIL0tlU2svRENkUTN1YmhQL0ZFRVB4eHhNdkROdTdmMmF6Z1dwWnJQemFiemM1bVMzQnN2ZExKWnF1WkxPL2F0bXVoWWpXRGs1WFBTL1dHS3FRcStZbDJUVDd5L0xaVWpwMzFrOTBQYVd3bmU3TUZwd2V5a1BQdTROZ2gxUGgzem1ZaGgxMFc1SERaUlk3djJ2SkVDV3BTWGJMOVZMWXpPZ2xpb1kvYmF6ai9oLzU1WkxKMThnSEh4cTJ4UGZiUmNEL0I3ZkdkZ0x0RHJyNkQ4T0NZenhaa0VSN2VUNjY5aXZBTkhmWnZmWDUwRFZkbnlCL0NtR3hRd1hlUVNrLytyUVIzN2llVkRwNFlZc0pDekpVb3RRUFhidyt1SVlWTUg1T2g0QXNsaEc3QmYvTUkrRVVXNXJ2NEsrSTFIZkNiYmVJdkNyRTZxaThJUVhSNCtDRTNrMktOZmxSME10ZS85dm82bjZ3VTd5bFdrbmhXWitsdUpPdG1JNjV1aVRwNnZOdGJYVjFGMGFucHNwQnRJbFRQYWRucHFaM1hYZmR6WXFsWXJ4U0xsWHF4bEJDMG9yZlc3YTdCcjF6U2JFUy9RSUE5QTJ4UGRsU1BjWlRCVVMwNkJRQnA5d3J3a1JyWGlEbVBWdGZWWFNETERXZytzNVd5ZnJmYmg5K1l3c0hQVDlJZ2JwRXB0OWplRFRGT25jRCtEbjZBSXMwSFA3UUdWalg2b044SHdLb044T0RHLzhqVk5YRHF2a2ZYVjhuZmM2NjdTdjZDOWFrTGxVZTArZTNHUW40aCtFMXE4RWw4TVQrK0VhSklZWENsNTNieC8yOFBTNW5rcHhwRW13WWNFRjlsTm5iZkM2TXEzVG92aE16ekR4dzZrSXZIY3dlK2NQTG93V0pSci9WZVMyeGlaaXZKWkNXSlRoOXE3ejI1STUvZmNYSnYrNmFqdXh2UE5KdjJaUjl2N0dhSkdjd1ZTVWcxRVF0SUJYc29ZNks0MFNyQk1QZlgrL211VCtSMXY1L0xFUE1WNHB6NkhxTUZZa3REVEM5OXExVndiSWJzd051NFBReGJYbTZSRlNJa0xnNDJGcGVPTFcyY2FSNXEvdDFnODgwcEk2YkhjQ2ZaUEhmdTRNelMwc3pCZzZWbWMvQWJaOCt1RzFwTXlPV0VtSlp4eDloZ2ZybU9id0U2V2FyZ0d4TmpmbHJOWWVRNnUyR09TMXlOR1ZCV0Q1ZDdjRnpjVjNEK0JpbHBIUW91SGV5NXc3Sm9DcGRsNFg1ZkpaS0xINGJiR3dxNGNMaU1vbGc2Q3dDcWlCd0Ria2VOdHRjVVNoMEhVY2RPc1NpRzJBZXVyQitMMHhhZHV2M2JaTHM0Y1Yzb2R3ZmRiaGZnbkp3b3k3R3gwSlVQTkdZWmhhM3ZHSHlMN0NadnZCVW43UWIwL1JqOVQvUVVpVG5tbytzUTlNeE9uY1FrOGJFK1BEOUNzdUQ0T0tKTEtBaE9naWtzRWFFUy9ibXkwSkpuVktRajlPQlZ6UnZpV25LMWMvUlJWSUg5ZFkvUytQcEQrUExnTnhlVXFXbGxRMm0xbEtrcFRVQ0NkdFdEQzdOaWJmSFI2NDdqN2M5Y3g2RGgxYTlDa2drTWl3Znd1eFNCdGlJK0RYN2NNaS93ZndQYk0veisrTTUwWURDRUhuanRhOTNYZHZHUDdPUitYKys3ZmQzZklYYi8vc1hMM3Y3Mnl4YUQvZk9IRHFVT3ZmZTllT1B2UnpGVy9USXZVT0syL00vTGNRTERBZnpuWjZrRnNGN3RGQUJ1d3lLbUUyQWQwUUtyS21zY0NLemplOWdUU0FjTHBnS3dxQXNBeXB1dVhxdnBaS05EdzNYWCtvUFZQbUE3bkI2Q1M1d0w3cnQrQXNEcTMwQjRNQUdNaHd5Z0VrQUVMbW9DMnlKSzdPOFdmQ3ZOR1V4U1lRa1JYek9JdTN0QlNuengwWjkyYjQ0SWNydGJhRmtuWlo4WkVkeWZKT09jVDlrSTd6eEdNSGhrRXFXbmhpK2lEdkpBMWVQd0hlaDl6V0djUkV5U0VJaklWVUlmTWF0emVDUVBCaHFpbjhsVkg5YVh1TGZabFZ5MUhwTWprWis1N0tOWE5BNUU5OHdsYk1seDBYUGk0T0NqdGNKcmYwKzhMaFQrZTdkZStOQlVQcEp3ZTk5WU1Zd1Y5b3BHcnpmWFZYUjFIRU1kYzRpTURmT2oyRVZFQWVVRW93RUlaQjBJcHJlZHFFYTdkZHZlYW5WdjlWMmxoUkwrcTBYMk5RSlNidHFEMXV1RkR4VHFzUG5pQjFLVlNnbzI5L1VhVjdBVFpIVG5odmhFUGcwRk1nY2ZCY201V0trZkphVzZrOFVkSDVYMjhBWEtnUDc5ZWJ6NUt0UzRCQkhnQUZtQituemt2TGx4OUVKK3ZEbHJjaTYrZ29uZE11OCtFSW04Vk55dzRkT285K0x3d2R2d0UrT1lPZ1I3dkFROURVYmxRaVRIQVJMSjVwbnU0TVh1WjlEbW9JWTJBRHRjUjY3K0lqV0t0emQrTm5yKzAxRHExaHdHUGJRK21jdTV6VTEvckxtSytqWnE0dkU2RDlxa0RqOE0vakYwZzdPYlFxTkRZR1dKQThtWEZWbmc4dTNhL3JtaXFJbU0wcDA3VkU3VzkvSHh6SzZmWlJSaGFsL05XMUpvV3VYdCtGeTNFbU1QMW0xRHJhZW5kaExDaDJWZHBLVHpNejgvVDZJakF2VE16Vkg4VzlBQVVPMXRNNGZ0TTRuaXR2TmZCaEFpMlNYR0lUZE1IS1BLeE1tZnlIQVNJeFlQN0VXT2grMHhTZE41OGVHSHN2alRKTnNIL1pKOEpKOGc2T1BFbjk5Zk5Xb0RQUUtSQTZQNFRaaEhKTlkxRHl2MnpVZ1dOWndOL2dwYWRJemxwdTNjUk5NMHVnbnRFZWpRaGhITmFJaVo5V2lFSWxHaTZ5UjU0ZS8vSTJCUFdDS1NLTTZsZ2I5eExjRXlKN0p0ZFZCWFZwUExDMUpVWVgrWEZtMWpaY0d4TnZ2MWNDVEljZDM5S00xRW9xa1FZdWJ3K1Q4V3FBdTlQOE9vWThNNmwvREhDbVUrOU1nakgzcGs4UGYrbTFCYnhiTGlJM0RwemVSOWtEZjdGM3Qvbkk3UURId0VWamY3d2Z2enJjM1ZvRnlJaVZqSDg5VytIMGREQURSQVAvWkYwTDF3Ny9JMVl2TUFnRG84OUpkTUJCSmJvMFZXVlNBR2pnRFJoV2hZVkdrVnZEQnk2cjR4UnQzakJZMGhTTHlORmVRVnlwMTZ1K0Uwc2ZqcFlHa0d5eTloUEpLWDVWQ3pVMllZR3JGYyt0V3FwQmtzbTdOb2xrRU1GNVdXdENMREFOaHNMaXBITlBscWxlZTR5emhPRURrTzRSdHhGQW9oVExFa0lDczJxMm9hTDRtaUlDQldZR2xFNjR4NGw0SHdSVU5BcVJ0ZUtYSjNSeTZuTldibDVtL0pJVjB1VmJJTVl2bkNVZEhRRklGdFJXakVZTkhsRGp2RDBBeGZTZXZ5a1NJckFmSXVMbEFVTVhsMEJrVndjUnlQRE8rQUZ0RjRubE1Sci9LQXphdHpoMnk0RXR1enJqRzdJNCt4SXZ0UUsyZ2I0UFUweUhRalRrK3dlWUZ3ZDhqbEVZczdKQjRCL3RCSndCNWU1TktQQUc4NEtTcWErTXdFenVCOXpwQU56SmFiN2s0ZFNEWDJmVXZDOVNwWFhFNzBxeVdMU0V1SEl2aVUxQXZ2U2JXTzcwcS9Ucisrdk1YM01FRXdyTW9FUXlvM3N2QUEvd1Zpd3RGdWdSL0Rsc21QUUVMeTlJelE0RXNodzlVbEh1M2xwY0ZadmRidm56dTNzWUdyUFhnV1FtaWl1ajc0QzE3Qzk2K0JqenlXVFhyRHY0bnlKNzJjSnNySC8xdE9ZRVE1UlBhZEtCU1h0VkU3ZDI2aXJBR2VjdUJKb0w1T1prSHJRYXdKRjcvSHE4UzNRYUtvVm9raDdwR0NnN3BQN3doUHZacit5WFhQZjJDdzhXcnV1bitsWDFjYzJ6WERNelRRMkNvSkhjWkQzVzk5NittRjV6L3cxYThPTnU0WjZxejdKTi9oM0sxRTdhTmU0ZnVQa0hrME5DSHgwOGZsOFVJUVBZZW90ZkJMOGZKOXgwL3I2eDFGZHBYM0txN3lGVG1yVFBHOE41M08yZ29UampudU95L1ZqM202M2I1UDErL0htU0Q4K3lNbHF5UTR3WnhKVDhjNUpwS3pTMU9YNU9jc1hLRCtIdWkvTGxqN0M5VEdjOGlYMFJJS3ZOQ3lmT1pzcitIUGJ5V2RSbzZIRU5KSnRTOVFqOXUzRUptaTJma1k0aENTSWdoQi9ZaGM2OXVJajJLWFJBc1JFcGZXQ2ZZcjgvUDZrWE93SVU1SGZ0U1M0Y0ZXbTNmSWcvSTdhVE55NUk0akFXVGJZQVBMcXJnazlIcmNyM1hjbzJ2VUNuVU5kVHYxR1BWQjZsUFUvem1LMk9PcjE0bWhXM3VJVGs2c0RrcStKcDVZeHhGbG5MQTgwaW1Sa1Jqc0Y4Q05EWFJMQXNTaDhIalFNNEhxRG13YkNyenRLeU1LZVFoamxTZEczN0JtNGdSS3FwRjJxZ254TUpwNFZHNlFnb2s2R3c5RXhEOU9neERsRG00M01BRUExYUNHME92bGtKZ0tpMEpFbG9WMFdPVERxZ3pLWjhiV0JFNm0rZGpnUDJVNUlvamhsQmlTK1RBdmh2RjR3d21hellDcVdnN0YrTXNzbDJHaUlZTTNrd3huaE1LSVRZVVpNQzJWaFJCRG15RkdTYTMyN0VoY0RQRjRtb2lsTHBVUGlmR0kvWUpXTkF4akZ2K0ttbTdnVVo4Rk1RQnZReUVqRXc0WkhKTTBoVWdveWpDdWxXVkNnc3hvY1pyUkpaa05tZitSekVSampEaVhzT0lNZjFuTVZCbTZHTTJ4cUp1WUU1bFlOSk9NOGt6OEtQN0VGR2xHTldQdVBsUkpGV080ejVUU0ZmeU5RbzhhR1R1TGFGRXYyQm1FbmozZXlXa3F3NGhJbGtsWU5TM1hlWVhrek05YXNxTEkxdXk4SThrU1lsU1ZRZEwzVU5pcHBFdFlwb2dWVXg2NnFxQ0xOTXJhNmFpQ1VJYU12K04ra3NPejZxc2dOdGw1dllQYjNoMmM4OXIvSXUzZDJkYWU1N2ZmNEsrM04xanp2QmFTTHRnaW45dkc5UzFjTGsyeTF0akd6L1FGT1BqNnJad0t4aGNmdjRPaWRsT3ZwejVOL1NIMXJ3aThFSEZYeDFQUmhTM1EvandXdGN1T1gxMG5ZRXZiQmxXbmhzQTZtOHpIOEExOGVaZHZBQVNjd21OT3F6MzB0aVR2RG43QnpBd0Vndk9qd0ZqNEdUcU5oakhpd05CamhpWlNZS2ZGWXhHbVRTUkEzRVltdkUwa0pnd1dEdkV6amwwQWtJOXlCeWJIblhJN2VMc2g5SkNGODZJRkRxaWVScVJKT3kzZmtHU1pCaHNVTU1UQzVFT293NEtmbGVYWnUyZ1NrRzZodVMwek1GUFp2TldLcC80dEtYc3hMUFN3TE9ESzR2Y05wQmloYUprNW5zT1hHQWdtUUNOOGlGOVhWVWgrV1dMWWYrSmpRZ3BMVEhpc0YzRnFDRTdHSXBwaitHVWpETUVIYUFiTHgvZ2NQOHN5TkM4WnJNTXJJVjNpNkhnbmkzUVZtU29XMDBRbE9jWFRFS0NBVTBYRTBZcElNMXlrS2hxWUFwRlRjWTVzTXM1aG9nd1JJWU14OEh0eEU2MUZGQ1J5aUZiQ0lFQnhMTXV3RFFkL3NNQ0xsVVVxeE1hVFEwejJHb1hWVTB6SVlNTTBNa1JjRFM2ZXhKSWR5K09TR0VGQ3ZiOFFDM1l4S2tpTXpFWVptcFZGSFlraFpDTTJiRWVpSmtKMlZJdmpBckdBU0FzQ2oyd0ppVWlSWlZ4UlYxTHdkNVBGZ3FZaUtEWitOVGhWUTV5b0NyUmlHRW5WMUxNMENaWEhxcGdEdEdCd21EamFNbmlSUmZnaFY1S1ZqSXpKMVdtd2RJa1dWYU1rRlZnbGhPbkNURk40d2oyT2pvUVVJY1BSYWxWMTRsSkRvdE02RDE2NnVxQ0dvRTBZbHRFQWJrd1NiakJEcXN2YXFzSGo3eFZpa0k0d2JVak9KQldPeDd3M2ttaVVCNWNSK0JIVzMvRDlXS0ZlUzMwU2p4MzEvOEs3NFRVSnRySGZ3V25jdjNINjFrdjM4SUxRYkdPcHRuREpuUmt0dmZ5KytoVThoZEprNkhVWjNPdG9FL3JVaGJ1ZGhwc1IzMnRtZTVmV3d4NytYKzQrc3FpUURzQ0hjQWVnQlZxS2xpN1NCZkRNUnBFemw5Ymc0elVLa0QwcFBHZDRHNkIzMmFSSjRUTzhBcEZDOHlSY0RSNytJVUJsQTdmSjBCcUN4M1VsZzF6VFIrWEpWeEcwVEt2VFdrSCswOHNBVE4xcHc2VmxwclhnRHlTV2lWdlRncmJGbnpuVEpycWhMTEpHY1hMSS8vcysybHBmYjRrdUU0R0JRaEJ3KytCYXNnaFZEbFFRaCtkRTBKYU1SUE1SeHIzejdTd3JHYXJHY0J6dDhNUXdIak1kdDZJSW9BODh3V1RROUZSYUQ1RkRNdERRSWtTa1pEZ2E4YndqODJySXdLL2Z2M3pNZEYwVDRnaXdVN0xvcXJ6T3NSd0twWk5UVThscEpORUpYSzRqR2lYYzBKekgwN3dBa1VsRVFZeVowTTQ4SXh0NFIzT1lmaG5JNVNWVndGS3RIcklGVmVLaFBUaFc0M0VUWVNsWlZ2QzdMc3N4L0RTbWtSVndia09mUW1pTEdwbTl2YnhtUU1xbHMrem9wVmMwV0ovMTZWSW9sVnFpM2p2RWQvUU5xWVQvWC9RWTFJMXI4YmoyeGY4ZEhRZDVVSFE4WHYvZjI0SG9pWGJhdmEyTlhuWnY4dG1adW5SdURwbndweStyYjIyTnpSZ2g4M0dDOGN3QUZDbkJOT2dTRTdxMXdYb1A5ZlhCdWt2aU5PcWdPMEJyTmJ6VnQrTFZFZDhpeUFXQVBnb1IvK251NEl3ZjNyRmZHNXlEbVJVNzhqOHlxUXcxQlg0RktJMi9VY01RVE1BcDhrSHp6Zk1oY0lkdk4xSUhRQ3BMd0NKZGEyR1piaUpLL1p5a1J1M21pbGNzTElURGkvVlhIRHQxNnRqK0I4M24zVnFwR0srcW45Ty9qbVdlV1AyR0hlaWhiNmpzWERTUzBFdmg4RUtoNlBVVzY4NnBUNS9xcmRUUDBicWVhVjlSZHF2Lzk0OFh0TGx3dUhoZ3BidzFkcDRFSzdMUkVUbk1tSVp6d3hMSEpmWDliQkUxbVp2dlY3eUo4MHJpdWZNaG5CdkVJQmtIcVFYZEgzeC9pVVU2K0NrR1lScUVLTDYzQU55QXU1Q29RSUtYa0Jjd1dFellkUFZRdEI4TjZXNlVUNXhLOE5FdnFkeVhPSlZtbFZNSyswRWtTRmlVL3hJVzZDVUIwYUUrL3VvMWJ5bGJlMEpSUlk2cSs2enlMYzFYbEVPaGNqYmViTWJ4U3phNEUzK2s4S2M2VjdHblo2dDFMc0t5RWE1ZW5aMjJwbklzSTZPQUw2TzZYSEpOWHBMTW4wTFV4Rnljck5ORUl4MHZoUFEvZVlHb0tmWU4vdTJKOVlsWWZFRTZDdGJ3Q0VEMCtGNFgzK3ZDNm1scC9JTGlqblF5OHVpamtaT2ZoODNKOHpGQXo5TjNUT2pvSnZVZVh6a0orV3hWZlh6RHozbzdGa3gwVXY4eFZxTU45U0Rrb1pFcWhHUTdmRy9XTWQ5Wll1bGl3VGlEUE9TMENveGpqQ0F4ekFaYWY1RmFSOVRwdDUxNzI2K1JGWE1BVmxsZkgyeXVJL2VadHczT3ZRMVZ5REo2eGczMFcrdEU3d1pJdGhTMTBEQzlKczYyT0RRanFyazlrdDlDekRSamNPcXVRVmJySnB4VFcySVZndzFqb0VGSFRZc0JSWEFUcmRCTGRJRUJQSHhoRzVYdXViaUQ2Y1M1cThwMzN2NEQ5QUg5ZTZISFJ3VDNUdy9PeFdLZ3FIeUZxdjdrWGwwZm5IdjBkV3YvcWFLcElmSFU1RmdDMkRVMitFU1RrcU5lTTAySDZWRXRiRERjT0tPZkMvM2ptZlh2cWJqVVJsQU9LU2FFNUY5eDliWC9WR0xyNnlSekdvdzJ4cnBSZjcxeWZvU3dQUU80NUlVUnluYk9LdUZ6QnRld05QU0dJMWViRGRRSEc0RGFpMVFOOWk2Qnk2ZjBUVUNDV1NlV2dEVWQxamlmMVl4SEhqRzBaME1HZ1RFZnJHOXN2UG5aY1BoWi9manhMVHBhZnkwckM3aWFPVnhpamtRYWNJWTBBWUswVDFPejU2dnZjR2x1RHBaTGM0UE5iTWlNYWdUZFl4VmlKSVErRXJJZWY5ekNPeU40TjNEZjNNUjlzeHpZVEFHMGNuNCtpUFhDd0s3VkpQT0RLQW51MkZ4RzZBekFhdVRVcHNyb0RVWkZJYm81eDRUVzdseGlWWTFlbUdOaVRMck14VCtUcktTenl2eXZLaXBhK0MzVi9lZVFObmorZzRweXZSWWRsdnNUM0g1dkkxWVhXOHFkS0hXeTBIWGZxbUlQVHpzN2FKWGUyYWI1MVp1Vy9TT1Z6dXlpRFdoQ2h6djRQQlpNYnZvdXIvODdMd3crL2lXT3UxblJodml2THA1TExVSUVxV2hncTRKTEJUdUxnckRsWU9KQ0ZYTVZQTUo5UStwRzIvSFJZUVYvTlk5UDA2QWVDVlozNjk5TlZlSm1oMlZGdWxySXdqYzZYbXJoSFZNdHVpd2owbkU3a3pIUlhNbWQ0V2s4MDh4bUxUN004SkZJTE9teEhCYzJGVlY3UFFwTnArMmkyTU41c0h0bldSR3hoU3Raa1lkRG1zMmozR3dKaTBKMHNlYWwwV1BaNlJ3ZFRvYTBTbEtWc1lTVUNPdUtPaHp2aG5YOVg2L3B5Nm5NeTZBNldQZnA0VDVYSS9yK2NiUUhpaUw5SU9lUEZmaERCOUhvaHg1SFE3K2tuNmJOUlB0djZYYXJnLytvZHJ1M2RGdFB0MzdjdWJyZHZocXhWM2Z3d1VNa1ZORWhZdW4wNllsalZOdHpmQS84elMvbmNzdnpRcS9UNlhXKzFJSGREU1RxMEN5eGU3SW5qb1A1K2ZaNlhMZ09BZTNzTml6dWk5SDhhejVSNWNBaUMrajhhN0lkMDluTlpydnpEL2tweU44aFFwdi9OOEk3aHJWN0RXeUxsOGlDUWNzUldpVE1RU2V2c1drcytEZXRqbGR2M0xxeFVaM3lpdWJ6VTN1OWxNb1hYbkhndmUrdHVjY2FDMnl2MysraHFMRXJlemFhTHBiU3NyU3J1dWYyMjhkOXpNOS9lKzdqSExmbE12RXRmZ0NzYllsWFFST2U4eHV4MVRSLzg3N0RoMXVycTNNckt6ZXRtTjNEOXgyZTdTNHU0dU9WdWRiRTk5bkE0MzBlckxVQ0UrUnhGdHZOcHRGdTgvQkVscjgvOGRYZWFCMmV5UDgvdDlwUVQzNnpFMXU4QWtBUTh6R25PcDQxZ2tMLzRIMkhUVUxtNm1ycjhGQVhlN2hGQ2wxYzdNNGV2bTlvUzdSQmRISEVXczdYblBoZHVObG9kM3l6cW9XMTliV09kR0NmMUx6M3ZmZmVlMmpYcllacTNyblNXMFA5dFY1TDJyOWZXamgwRDc2enI4M3N2R0p0UGZoTytKakZHdVhpV2NodGdMZ0hzUFJscjlCeENoa0VubE5Od1d1Q0VWZGdCTi81YVlFeDhtUUZkUlFhQXhhTlJxRXgvb2xXNk5qZUJwc3BlMWwyYWlIditFZVZaTUtFTzduQ0cvMjRFaUZyVzRnTW5zRnpHcG8zR09FR3hDbGhDVStyK0dHVWpEZmhVZHlxdW8xR3ZQUjJzOVJzSmtzUnVJSy9XR2RDNXJaWUdYaTJ5RnNNbVVrR3dUS0c2eXJEMkJqVFpEYjJFbkV4aEk1SE9OVDBoQ2JtMEFxWkZRTjdISDhCdmpBTWpyRzFFak80Z3ViQ0ZKdjF5aG0yc2JlS3QwNjhrSXZCNVVTeXdtYVJ1NTNnVCtGcVJFcnhSc090empWTHBtT1I4eVIxUG9ZWEVoeFBjSlpReCtwRVBNdERaNTU3YnZQTUdaM0FlTjExMTlkT25MZ3RlZDlqajcxSVBmWlluem9QeDh0L3hvZnhHaWNTaVp6VUpUTDdIT2JKUWVwYTZsYnFCUFVBZmh6V3UrRjlIWm5tRSs5WWdHSnBkN1RBdnQrM1FzSC9TK0JHUktab2ZuaFRBaE1xK0VEWHZEQU10UWpYUElKMTdVMWNLWHR0bEtJbHVsMlB4b1U1dzVZVXJmRGFncVpJaXNEempieVlPUExtSTlWNUw5UnNad2YvR2FFaHJxbkd5anlqMHNuZTNub3NGRk0xUHBOVXZtS0h2TGdxN1NweVhJSmYyY2xvY1dldjlUNThpeGUxWkNFZE51WjBHWXZGTk5JZEtjd200dG1xWXpraDF3MDVWcldVekhhYU00ZXV0eGNQSGx4Y1dFbmFmRXlYNUh5ZERUR1lNQWltanZTcGNDcWtxNExJUnAwYkRqS3NDajZwc3BKem5YQ1NpWVNUV1ZwTjBXR1JqeFQxaW1MYVhIWXNod0ovSTNpY0JSdzc0T3Y1dkJzemE0SkZROTUwdDdMZ3p5YnEvTWZqbW41d1dNWHU5bnFVSmdpL2NVeHVmb0pPZWtJUEg4Y2pKd0g5STRidFBvU3UveG5Gclk5aTdBUDVCNFRLek1xTk56NSs0NzdDaVFNSFRoU0s3eE5lbFg4VkY3L3A4UnR2WEpsOVUrSEFpUU9GNGgxYjh3MUJOSXlTNEkwekRRZWVONkFLUjMzbjRha095VFAzWjk2T3hWNXZyZWM0RCtkdWhCemJVN1NIejN1TE93THNVUEJuVTRnbE1OWEtnVVdKVmNCaVlhNEZla3dzQU9Qand1UjFsSlRiOHMwMzQ4M2diMkNMa29PL2dTdVQxdy9HWW00czlzc1Qyd0J6YllOZ3Jpa1RYdWxqbncrS3d2T1YwU2RsNHJnOGNRd1U0Ymw2R1RNUXpQRk1EbE0xUE1leXVoa056ajNUdjRKNnJwc2hzNURhOE9EMDhPQUlpZ3krajlCdDZKcHJVQWIvOEJFK2p4eUh3K01Jam05d2EyU21NdmhoY1BDT1lNL3JOTkZtc0xST3YzWGlHQms2NHNnNlBNdWhJUmJraXovR2JmWVVuc1czU0RTN3ZFWUx2cmFBT0V1M0dtMmlVd1FnZldZWDhqWDgwR002V0VqdlpQQUFPby9GUlQ4d0RpL2dtaFdxQ00xbGFpVXpnZ2ptTHlya010T0ZaZ0xPR0dUWWN6dEw0UVhyemp1dFpnWnZGc0xIZHhtSnBacldmQ2JSTEV4bjhqbEI5UityUkdmZExGa0Y1T2dWMDNDTE5ScGluTk81WWpNMkV6OTZiV3o2WGRjZWpjL2NscXMycG8vVmlxNWg3VlpzMFAvell5d1Q2SXM1WEsrREVFOGVFNnd4d3RacUxiTitsUndUQWtFdjVGdmtRMGRxQXlEcVVNZGxCSEQzVUZFUFRjdkwxZVI4b2lRWnVDcnBZcWJpZFpMNEtLS1dzczFNZFZrKzlxOElpTVNYa2gydmtpbHVIRHVHbjdocEY0SkZ1K1JLbzdyOEE3VnBHZ3NSRjMvNjJsWkVMOVJ4K3F5MVlGc0w2c0dqOEtRQ3RlZnBla0dQV0Q5MytVRjE0VGFvazRqbW1zMnQrZ0xBMHdYc3ppWVo3QXVkTElvSVhxUzV4Qno1d1ErTzlJVHZmT2Z5ZWJUNnJuY05OdDcxcm5XMmo4VCtVNFBOeDhYVTQ1UHIzTUw0ZVhocW1QNUM1VVFodHJjUXdkL0tlUlRoSW9VMDg0TWorQmxSRUw2RFhGd1NQSWU2NzdKWnRqLzRpWXJjeDFQaTQ5UzJzb1o1a0NkSGorQTBlQTVNdllpLzFlK2dxSTR0OFBNSWdMdDRyNHlsS3RzLzhpd3p2NFFDK0tHVzROOXRlN0JiUVVNTUlySkdTSFRsc01taXRuOWRjQ0FTTGlSb0xUVFNhQWhQWklHYlB3QUR3emxaZVNRRkNTUDhvditBd09ocEJuOFVCSnJsdWxFSWFNcXBraTZwbk1xSG9udEFVd2hpUzFwa1dDRXRoZ1NhRVNLaFBYdVVxRWpqZDBoSVR6elBjSHVpSVY0TkhvZmdwOUV1Zmw2bjZZbkhhZEZVdXQyUUFZK0h4Q2NZVVdBanFvclBSRnNyWHNFcFVMNU01MFF4Ujh1Y3lpbmNGVVU5S3VIYnFocGhCWkhSUlk0V0JaclRpcVVRRnEwZzdwZ09tZUM1SUdSaUdKQUpmbkNVQjg0UU1qRU1rUlhsa0Q2Umg2QVdpemdQUWFRNWNZeXZBUEpxbkxyY2o4Tm5EUDF5Q2JJVGxnekRORWdEclFXdTNRR25SZUFsRmhsSjRBczhHTUlYejZtSEVWbkh4Y01nUVg1ck9HM1BFWUlvVGhBRlBUQ2FDaVQySjM3bmlVVmFvR1dVS1pTUGxiSDBLdU96UlR6OXAxMlgxdFJra3VkUU1wM05UZWxlcmhqSFo4bWs2dDhMbTkzZjZacDc2TU5TQ3FLQUt5cmVhNkVwMzZTMC84U3RSN3UwU010MEtxenI0UlErRU9udTBWdC9MVmZSSzdsTWhtUVUwdWh5bWRiMEdKeGxNcVNNbk5QdE9uK0ZqcXE2bVpKVVJZVzllSEJvNE1xTmVGU2w5bExIcURYcU5SQmh2Z2tWSnBnR1pRK0xuZURGREZqOWRZSzdidUVydGhPRUFNZVNwckJBb29UN21ETndzVW5tTVlGMkFPZFNHUEo0N04xRkUvVU5GdFpwM0tWaGpldE5HVHFrbWt1L3RHU3FJVHFGMGtqVHJMaU00bWJSeld1b21NM1pNU1Z1aGpXVWVWaGFvYThJYWFRMkVOdzc5VTZmNDA3cll5Mkg4UHF4aGFYZG45Njl0Q0FqQ2NVT1hua3dodmVmN2Y1S09KOU5PanQzT3Nsc1hzKzdyaDNEMlVmMUVKM1AweUZjbUJLMzhtNWUxdFVyMFI0eFplcXFDaTN3NDREdjNhN1A3eGQySERtNnRIdjMwdEVqTzJRRStXY3lrRDE2cU5zZHI1VnVrQmhwWVlpQjAremdxUXNXaTZPV2c0Zm1wNTc2Vkt2MXFhZmE3M2pITys2ZmVlQ0pkOS94N0xOM1BIdm5uZWorSDE5NTZ2RDI1Nk5FenZFRXlDU0xoL3lDSnhUQTRuSURubTlEVG0yY3g5VFVFdy9NM1A4RHlBYm45ZXkzVGgxKzdMSERwNjRjclkzNWVZMXpjaWFlSHowMVlYTUxYcU03UnY2eC9sSUxmRzZzZGdjV25XRjZSVDZvQlRxd0JyVE1qdThJNUp2Tk5kSFZqWWMvOG5BVEdhSXo1VWlOdmJTN3A4Wkp6cFF0R2Q4OGZkZGRCeTkvNVcvR1lxSVlDMHM2bXV0Y2NmVkREMTE5dUkxRXA0SVQxTmx5bVovaG9wSmRjY1RCbjU1NDE0bTdEbHgrb3hCekJNTVFITmxnM2pUaWtVL3IvS1ZRQ3RiQVhxdGd3VUpYRnIwRWZXK0pZV2swSEJOZm1xNWZGWnlZOEtZM01ZYU15YUw4K0pkRCs4MnRQbm5FZnQyUGVEcEc0OC9DNkFPSS9BRXVmbnNiS1BRdkdvWngyK0pnWS9mbjhtcnVrM2sxLzltY212OUNYc24xdTdPejNkbUZXcUZRS3dBVzd1QW51M2REWXFPRkUzMEJKM0tDQjl4WlNIbHpBVklHZnFZWG8rK1NxZnNwVkYwQ1BiamRXQ3diOTdCc1hLTnU4YTNJYUIrZ0JyNTVLMzdzUHZKSjg5MC9ZU3B2QjI3NUJPOERyS0o4VUtTQ0Q4M25rWTlrWU9WTlRBOTlWVndiOVRJWjFRbHJYbnVtTUpmUHFMeU5EQzJLSjhkU1dGZERDRXc3RUcxS1NHSzRtQ0FiVFRwRXkwbzF6TEpwUFl6d3BCd3hESmlENVd0SVZzVXdyWE55MHAzTnpyV3locm1XS1dvYVhja1c1M2N2RnFNYVVnMlVpV1J0WFdEQ0tBbm1TS2FJeERDWHVjd0l5MnFTTmtKaERWOWtraWdxcWJNN2tDb2hXY3ZVZDgyNWJsbUVkM1RNazVmTmtaZGJ5MHNsZll0L2Z4VFBLZVpnUkNqNUEvb00vbVA4VGlINDFzQUJnc2hDdXdTSXVGWEdnNWsySHZKeDRnekNlWWozWGNFU1FWb2tQdTZSdFNNMFB0ZTBiaWxYUUlNM3J4MWhVYXA3TVBPbmUyL0RDYmk5dHdyWG45d1E4VGYrYm9HZ1ZCdzdzb2JsOFZKWDAyQVI5c2hhNW1BM2hYNWZ1SFV2ZCtxWWVOdGU3aVExOHNFRWVtRjh5RkRUc0hiY2Nwb00rUTdWTVNsMW5pZ1o2Z3VkT2lhdjNtN1dlVUE2QlVKNXF3M0JGWHpVTFM4dmZCTnh4MDRCMmJ5Rzk4TGRWL0R5KzZGUWhlTk9YbzgrZmVyWWtCNkYrNE52b3ZWVHgzU1JFSHVNeFZUZko2S3ZRM1hROVNjNVRybnpGTjRNNnpwYTF6U3czTWhEelBhTzBDbDBtc0l3NmwxejIrcjhGdVByWVh5MFlJWDc5MjVJTDRRUDZvdGdleXlLWUUzTmd5MjE3a3dZV1NzS01VcDJVOVA4bWY1cXIzWm51ZTFGMHBVTTJFdUhBTzJMOW0yb0kwT0Q1RUppQzQwQzhSMXE0b0VBVStrMWhWMUlDRWdrL3BScEZJUnVlMy9GM2d2VVhIKy9ibVJ5VVVJU1A1MXlxOUZVMXRMT3VLdXJQYjFXODlybFJLSHFpc2cxYlpqVWgwYzZNR0VMbG5rSHoxOVg4QXoyY2hJRmQzVzhla2tGeXp2RWdCUUJXZ1owdkVhSHhnSUUvTnI0NXdaN0k5aXorRmVlMkVNNkxLOFQwUnlFOVRLV3VSdFlac04vNk9peXB1dmFNcEhieG9jMzZtQ21Qeml0SDhRN2lDbml1MXIxOUEzOXVLanBQTWVWV0kwcFMyaWRaRFA0d2ZZTXlDRzZSeWU2c3pQZ3FmVU1QajZyNitmSXFmOTN6ci8weTJIaGxDaWU0a1Z4UmVUNUZWaFZHL0VJUm02YlNsTkZ3cWY5bUR2WFVqZGkvcHlZUk1nd0czeGpJUS9vd2p3RXZ2TEtBbTkzeUdGWkoyY09lQjNEalFLYzRkbXFrNkdibHRsb09YN2lxUDhvSG0waGJYbjhqTStrdjlOeHZmVWlEMHRjak16eWVDS2c3WUJKQTQvL3dhemdLSzZmSm5KU0dWOWlTeHlIOE1DaUgvVlRLRmhheDZuMllYN2hKd1VOTHJJMlpvN1B1cHN4SSs2R2RLTHdlY2hLNUsrQkJJdzIrQjN5QUJQWFB5Q0V4UzYraE5rRFZteVlWNDZmQkhXQUVvYjllNUdROFZtY0IwNTFpNzVGZjIyQWozbkhxekp0R0VYclpwUG83VG9CODN4ZllEK1FFaGIrdjRoNG94eW5sekpwUEpmRlk3bEtScThsZGZHaDlZZnVPcVNmb1lYNFFvR2VzUzJFNTBEaC8wbVd6UEhkSTcySEh1b2RmcEMvYlcyN0Q1VUppQUhEbHVyd1dQWWw2MHZ6RVBJS1hLaXRab3VFUFNKZU45NXdaZjZWYU1hMmthaklZWkU1dnI2MjF0UDMzdkxLMDNjM2xjVmdtZDVFdTlONGxoRTJSZWFiYTBkNmE2dFhDeWYySFh6bEt3OWUwVlFYMTRNMVZGOE85TzBDZkZ5OWZRUlZiNXYycVVUQUZNR2RKZ0NOOURWQnplMCtkdDQ0V2FHVUd5ZDh6YVJTYXVYRjNQeDhEbEc1K1pvTFlaOWVwR0NMeklrMHY1dXIrU25tYzZEM0hhWHFUMmlxMmdUZ1pGNG5hQ2VMWnk1Nko4RCszQWpzRkdBdGpFU1hIbXFyU2hQMUdVN1dpb0YwdzVHcmZrV0dQTGt5VUZtTlNVLzQ5VHBLYmd6T2t0cE0zUENKdnRLblpwMVErSWZuWHhyR21IYUpmajZMZStRY1ZTZTJSRmFCQ1l4Um1BSng0dDlGRkFCZTRMYWNSSVVvQWNSc0FacEVSeWgwQ2s3Qnc0TnBMS0srVTQzRXJGNUVQYUJHSHI1RE82QTk2WHpIQ2I4emZLdTJROUhrT3hWTlFVZkNnKytwa1lpS0NtRVQ5aWIrcHcxK0ZlVUhmNDQvVDhZUC9IL0JmSEJJVzRCeUFTdUFGeUROeHpYQVY1bW1Wd0RmcDJhbklKenRYWWdlVmxPMHk3WGRGeVpFRzN3cEtIMnIzaThKTWtlQlNFT1cxeUdyS2d0VlhMN2d0TERzMDVmTm9qZFYzZGk0ZWFHdUk2TjR6ZUo3MzN2Z0ZUMDN1OHVJSWxEWjRSSC9pT0RzbkMzdHVmMzJQZFh0T3I5dE9XL0pibXNtVzNBV3dqNjZ3M1lVQjIrTXUwQWdUV0ROR05BZW5oNkNPUno4aVkrNW9Qc2dENU5RRHIwQWVFRVVBVzVoOE8yelowZmpScGZnSzVGMVpNQy92RkFwemdUS3crbXQ1UVQ0RHFmZHRTMGxqQUVlUnV2ZlhlS2p2UzBtMER3SzRyZU9Zd0w1TVgwbVlnSk5rN0ErUC9yUlJEN0NSRXlnWnN0SEczQUVFaE5JSnlHRkZQLzVqLzNvbW10SVZDQ3lUdE5GSDBOZHpGMi96NDN0VlFLN0VQQllIOGEyQnplMEZZVGJUYkFjaE9XY3FQWTl6YmJDL3lnTDN4TVVGVytrK1R2dXVLYmJSZDJvOWdYTnN2QW0rcjB2Q0pJa2ZFRlFsSGUzTmxxdnl1M05qV0syK09WR3p5K1Q2MWplUlA0b2RjY2RrMWxlanpPaUF0cngvOEEvT08wamVnRUVKTmwwZ2hPOHh4M05LN1NRUFQydGVWNUZTNmMxOXdqWXVOanZQSEJnSitydWZHcW4zTzYzdnlWN3h6MTU1ajVGdHJ1Mm5EcDQ1ZUxHWW04WUU3cVBYSGhEb2ZhRjFrNzgyTi81ZDRkMmVodEVUNVluYUFpV0gzL0d0N0FIRGZjdUJQV0RsV1JpM2VZVitBQk5kZ2tWQW1pcmV3NzJlZ2NycXB4d3UxMDNJYXVWSlpQN0VHZTJPSm1XN0pCZ3I5dEN5SlorN29PNi9rSEhsZVRrTEl0Rk81ZWRUY3FTKzA5N3N0azlmMGtyaGl3NkpaWXRPYUpzS0lITjNaQ3VTNkhxWWpTOFJLbTQvcEhSZDFZaHRsd3BYTm9VbmxPMXNTeTVCMHVTVjFQWFV6ZFR0MU4zVTY4YVdrVFdmZFJoQytJcmVrUXJXQUExb0FWZ3FjMENnVThWbklJUHJRcmJsZ1czbXlTU1V3c3VGSnErMnRBakVScHRvaXhzRTV6V05tTTdFTW1CWkhJV1RDM2hKeDVHY3FKY2N1UmNSQy9HWWtVdklhTXJiNkdsZEtiQzNId3pVOG5ISlEzSjJUemMweU01MlNtNXJvd08zMExMeWR3b1JiblNkUFRVaDF0bHZSamVWMm5Hdytsbm01VllhZ2g4ZHVyMVYxYkx2RWJ6K1JsT3VvS25kWm92VjFzRk1WTGJvKytwR1VLaFZTMExOTTZUdjBMaVp2SThIVUZpdVZyM3hnbXVxS2l4aHJSSHJVaHFiZkNkaXBxb3lWMjFFcElhWVBFdzRuRU16N0VLVklXZ2Evc2N2aEpMb3pkUXQyRnA5SDdxRWVya1ZpNUhpS1JRenhNd2dLanRGRnB0WDlmYTdsaGxFcHdSR0FiS1JZak42RmhFc2RqQ3Y2YkZreHNPVVR3eVJOK0lqNXYrSTd6QThCWjV3bGRGa2xUbEVjTkJFdXM5dEhaa3IwanZUeVJ5bHUxZWJoYXluNGc3bWwzSFFsc2lWV0wrblJaaWhhTzBHTXNmRnVqOWhVTEJqR1hydHBZeWkyKzJ3aGtqLzJtUlBzcVVVbmU2dHBtL1Via09INFp4NG5TSmFSaVpzTlVZQlRkL0dBdUZEL1h3VERXYW5kdVBicGYzY0xUUVZhNmwweUZoemxiZlY4Mkw0Ym1kOVNSUDc5Zm5zbmg3WmJLK24xNVZ1aHg5dFQwbktrVjAwS3BLY3VHZjg5V2RjMkdXNXZiSWlKOHQ0dU43cW5sQm45djVpQ3hWclpDUGI3NkJ2MkViUkE4S21FbnZvWDVoWWcyc00wUWNhamQ4bEE5am04ME8xd2J6endXeWNMMXRVeURZS1R3b3lyWnZ3SERVaFBpczl2Yk5FbXFDZXNLREZwcmNFTVNwYm5kdGZRMnNZRGFySjZwWUFzcTg1Zmp4dHh3L2NmTG8wWk5IRVV3R3VEZ2I1MFdGVmJCNHE0UkRHc3R6WVUwM0ZKWm50VkJZRG9ja2haVUZJY2JGR1o1alkyeE1FQ1JXd29ubHNDRXhBcXNZdWlseEpMRVNsaFdjV09MajdHOThESVYzSE90aFdmbllqbnJyOE9GV0F2K0RCYXFUeDRHQVB6a0tCTnhxS0VJb0lxaWlMb3U4cUltV2FNcHNpQTV4SVo0UDBZeEtxNnhzaXBZVUVqbFJNa1JWa0UxQk1YQjZReEk0Z2FSWEdJVldHSHJyQTZJbThLSWFGdFhPeHo3bWo4cy9STCtOM2s2cFZBbHNGUEZrQXdZNzNJMXhTeFZCaHhOR2RSN0d3alllL1BLdDhncHFPeDN1dFZNN0plM0s5RlZxdm9xdXFob2ZZUGdHT0IwdGxNR2tmNWNZL3N6Z3hVL3VuTzJHdUlnVEtucUwvMUsxUDZOSk93R0pBSlVic0h4VjU1Z1BmSDJJQXdNMnorQlpEbC80RGdJVEdzY1R1TEdXZjgxRjBaMGZmLzZaRHovNElEcTBWR3dVTW1IVWR3Zi9vSzV2UFBQTWd3K2FlM1B4UWlFZXJrY21iR1lOZ256YXdpTXJyRnZ4L3FLVnYrKzBiWS9VRWk3NCs4NHlLbzltOGI3RlVDZUk0RU9nbzN4MDZtVzZrVUhvSVU2SHlSNW11OHhMUENPSFk0M2YwMlFHSDh1U3lER2l3T2ljMUpEOE9YdHREWGV4dFYrVlFod3JjdEdhbGVkNVRtUzVrRVNINTNmT2h6OFJaaEhOQ0NvRC9ZZG1RMUxZWUtRUVB1SjRobEhCbVlJTnA0dy85bWZ1ZndWWnJhL2RHTUpkSzY3eWdnQkp3NllaM21xdnErQzZnMTI5a0VVcnlITVl3V000cnlBVWtzaHJlcHRmOEg3aEY3d3ZiRlovL2RlcmFERjVLbG5wOS8rUG85T29mOW5mOW5wL2UxZHZjRzUxRmVubkZoZFJiUEIzcXplT3NYb2dieHJQMWNMRStpbkl0cW1nWnFmNVc5UFQwMEdHT0xkSzh0VEdqVGR1RG5PQ2ZCWW4ya1VnMkkvRkFQUEhuMnZtQlFmTWhxcklEdXdOUFFnRVJtQkhlYWRCUWhXQlBQdVc1OTZDL3padmFMWDV1dnRCNXpyRFcvUzh4Vy9jc0xkdEtJM2sxYkhmT0hSdjZBRTNoTlpKd2xmc3Z6VTdOVlg3QnFUeDl1Mi9TN3lWbjN1eThqZjNIaXBsMHVXWU5ja3pnWEx4bDJJZmxtSURJRGZRR1BBQnNIbTlSZHdtbXZBRmdDaEx3aEMvM0xHOVZ1Qk9URzdpYnpHQWVIMllVUFd2ekIxWG1qSitnOFZYaHR3UE1lQU04eDB0ZlBWeWRaOGg2M2NuSHNIenZYTDdWaGVGVkRXRWRQbnJicDMvQktIMFhzTThjaXJDZ25QT1o2MVlPUzJacGlUOVBQZGtxTHJudGxyRmRuNTk5aHlhTWtLMWFTT1JNR3g3S2d2ciswRTk0bVJPMlFqc2tLNm5icVh1Z3Q0UEFneHh2b1dscWFYQVp3YmNGUzEvaFdvRitlanR2b2NJeEpGdCtjdFlZVVFVd2NSMmdlaUN5eVFmcTRNL2ZkdXdWdEFKUVRTdnRVVEp1c1lVUmZNYVN4S3Q2MDdRWWxhazZjclBMR2Z4cDV3V1hJRzVPM01GSTJSRmh2WWV3Sk4wUEZpSVROeGoxRnZMREN0a1JPYVZHWmIwOGNGZmtkZm54Nng0amNpRkZ2RVFwclUxVHV4Sm5OYUc4V3pSYXlPYXN6bWFUaXhQV1RZNHRsb2N3K1FxNWowdHhPQmpoQko2d21IQktaZU9KTkJWeXdtR0dTYjVQZkllblNZdmxhOS9DUGduNC9jbVMvRGoybFNQdWdsOHlUc1FDc1h6MlFXRFI0ZXNNbmNBUElzd0ZIOSsrSGxFREIvYStIajBHUXM0U1BpRitVLzRUQko1N1N3U1dxUU52TTcveFN4blBab1I4UWFMUkxjeWdydWZ2clZDWTdhWkZZOWh2SWlJK2NPOE9wT3gvZEhrZnNHOERqZzc1dkcxcG5pRVpjcTNNbUptS1pNNXphRFdsSlZBaUxOMjBqUnJMemVoMWtrYXRWY1NtRVcybnNUM0VncFA4NGpCSGV1ZkNRdmVlbzNJRWhhSE1JdWxub2hackFHTFE1ekxNQWsvQzJTYUU3SHFkTXluQk9qczVpRThlbjBGRlR3OHQvYWFwUndlRlVyUlhOUkJoVHZ2RUdwc3E4MnRzYTlqbjJOL01QZ0s2aGMrL0dHVXlneWV6N3p4bXYrdnRhdUprZU80emwzVmY5WC8vOTB6MC9PMzg5ZjdPNXlkM3BtbXhCK05sVFZGV3FKRVE0NjBBV1ZtSWNVMndjUUdBWWUycFFRUktRa0JJdWVnK0dBSmlCRXdnWU1jRWdTRUQ1WU5HellQQm9MY2VMQ0RJTEVSSWdnUTMwd0RPZVFRTFBOZWRjL3VVZ0Y5aVJ2VE16MDExVy9xNTNYVmUxWHZmYS9aZkg3VmNSYlRmUHZGZzg5dmJkWEk1WU8vSGp3U0R3L1h6R05vZjVIVExQcEpyc0lKazlFSjB1OFFoR3hFY2tMOFM2RCt1blFkNUFacG9yNzZlWklqdmQzLzJjNm5DOGRaZmI2NVhGOURYZlVVU05oQzBJTWVvU1UrWFBWQlNpQ0hNaDdCR1hxS0ZCdGsrVUZLNzEyUVFhYUpXcTU2UTBraVBDdDBOQXgrc3NSZzMvbW5Gd1lyYnEvbjRya3llR0U3azJmcFRoeTVueE92dWU2WDZGZmNLTWxidVp4dEY3bFdaRnU5cjdLMy8xQzlzVExPQ2kwdnZqbUZnOXhNYTFQRGM1MEpuT20wbHJLK0d2anJsdU42RXpqcDBBL1VQblBOajJtdGxqaVpUTXhlQzhUaEd3Mjh2SEhrYzREMUhlTHErR01LbWgrdnpydThETU9UZWxXR2J4YTVmbks0MVh0WGZmdk94Q3IvSUlVL01HN3d2NlVUNFpHK1FyK1pPbUp1THJ2L0JLbDZpelBJVStSNDMvK2VoVjEyeDM3MU5XVWl6bWNLdVgzRUFSOStmWnEvMzJ4ZXpJQTNLait4a241WVVTZEZSYmFQWlB0WlNkaVRmbW45alRLYml4UGx0VmZ0TzFKSmtqalRyd01QWk0rbnpmZnp5dDZpdEgxelFQOTZSdmdzWXBlVW9BK1p5dmVzWnZCMG93a1dybnZDQTk0N3dsUitOQnRxaDl1SXcva1Ixc0JJa0pYaEJkTEFoVnFVWDI1UFBLOWoyRkxzNVBXVyszcW54cHhhdlhhUWQ1cFJ0TnEzL0RCb2RUSzFzM2E2blhwQlZxOGxnZHZxTlBSdWIzc1FkUHRKdlRINHpkMlBGUU5udExGVGIzLzY0MlR2Uit0eFNOdFNQWDNxSno5NW01MVYycU1mczBZOGFpYVJZNXBlMUxCdHAydW50YXdkSnJadU5Oell0b3l1N3JvTEw3Q2R3TzZlRzUrT25vcEdibWowZGplZlhOb1psbTFqOGhXMTQrMVEvT3JhM1RtczBHT0tlL1d3akk4dmdIZ1lWOFVwTmZHUHhNbktnMWxmeFFpNE13U2VMTGhuVitteWNzQmRnWDU2Y24zOUpKeC9lbTc5NURyWjkrMkhBaVlUZUg4bzNOM2R2YnMvbisvRGNlUi9lSk44QStiSnp3bENqT0RtdU03UUlmRVVwRnQ0NGlFQlJENFlGaUJwemlNYmxmR3hNQ2Q4aFV3ZHZpeUFsdjRqanQ0WXRVblpJdWptQVR6QjEybG1QQVFRYmo5aXEvMmp6MlpNdFExS015S1NiMUFLcno4WDZhb2Z3anpXU0p4NHpmUCtvbngxdHpJcGttbXRlU0lZOUFkWjcxbEpJcUVzYjY0Ri9kWHUrckFyZDJVcXE1UW1oTHhDNmZja2NvWFNLMFQ2bmtocXpEQS9sT1VQNjZsUjA4TWZoUHB2Ni9EQ2l5dC8wS3ZMa21lMzBQcyttYVk1a2FRazFrQTdDZXRwOTFGN0pCdWVqNHZDTmRRR2xxdy9Pa1F4VUNwa2xIbnhpTGR5WCtsbjFkWndDUy9NSTc2VXNXRG11RmtjSjJLRnA4RHA4ZGNTUlFkYThHdVdwdXVhWmZ1YTlyZVdwdm1XbzhIeFJ6MUZNeDJ2cmdWZVEyNE9GbkxEQzZ6SWMweE42WUdxWVczdXhxdHJVYTNYdEN4TGZIcTlZWWIyK3BTcUxZVTE1Sm9hYVBXMTRVdjBVMzlwT1RDV1dnMC9OQzNMSGpRczI0T3JMNDZlWEU5YWtPYUxqRXBvQjhsazF3ejlWckorYW1qWHM3WjBRbEU4RjJUemRuYndpL0RNSURGRktuSjNaaTBlbmczOHFzMVViaE01QXNucmt5QXpDSVVOOHdvSG02bU00dnZjVUpsSC8ybFJIdlUwN3hYQUxQeVJrc3M0cUtEQWhxaUhuS0dsaStjOFB3c3pFQUlYOWZqb1BkdTVGVFdkdUtlSW8vVE5mYi9aQ0hwUmtLNHcrU3JvRzU2SENDU1NHbVJ2N28vejhUWW13d3dQTjBRcnQzeWRlZjhnZGFNTk1XdGJObGt0M0ZZVUlacER3MytpMDlQbzZ4N20yTGRXazVuYldMSGhXSm12ZERYUTBYcjFrZGovUHREMlBZNno0MUdCZkVGNFgvZ3I0ZStFYnduZnhUWHF5amFRZDJxbFVWVWhRcmxPUmZsUGlHQ1g0U3FLZ3JvWHoyZVg5b1VGUXJKd25JdGwyanhQMm1JZWwzZ3lKWlJNZ21RS2p2R1V4QXEza3FlbE5XRVpCYlc4U3JaamVaN1pLR1h4VkpTODhEcUpNUldvUWFIbVZLQ1dMb0p3WkNoaGI2UnFUZzBVNHhWTjdpcHlFTmRVU3N5UWlwUXB4TmNEelFidHkxYmtVSTdjbHE2dzFHaDFGTjIxVDZzN2JkVTczYjEwWlRSVTVNUzc4S3lCTnFhaXF0dEszTjQxMWJpNCtpbWFUaFF4OWFVb3NVUktOVVdKRlJZUm9odVN4eVNxV3kwWjlEb29pZTZlSHZvSHYwK2tlSU1RMTNEanE4Q0ZVUWpzR0gxU2lZamtYd3hVdUUvK01yTXh1cDlraFpacUdMSHB5WklWTkszYW9KNVlqa1FWQlFNc1NrNGtyZ2ROUlhlMHNLTXFSRW5IVHRKb2VTcFRyRGdPMjNJbjlWYTNHMFBiOS9xZHhHdUxMY1Raa0dCczBaTE5tcDdPTmphOVpsY21oaTdYaVM3YktsTnp4cWFFTm1NaXkxUk02MnNOekUra1RobzF6QzNGVm9lK0RZM203YU9ZZlRLUXBiQkdJeWI1bGg2NkRpR0hQcXlvMzM5RytMRndYL2dQNGVjd3UyejNjQWUzQ2g2R29DWmNxSFpJV0dJR0paT29OSlBKK1ZNalRzK1drYWVuT1B2dXpJcWQrYzVacVRoYktpZXpIYTYxOE1Ha2ovWi9ZMUpHenExVXM3Z3lUOFpocGtQNGlOWGpZYTJqVXIyRFlhZ2FpSHJMcUdZOXBZeDZuYzE2U3p5SE0rUVFEb1pEUjVXNFVod1NKdTV4UTlncEdyN2lEdjRVemdmRk9SVWFOL1NwWkZKRzI4NGE2NW9tZFczTk1Ja29FVVJRcWJIUWxtcG1yUWFuWkVkcURkSVErRUNraW16SXRrdkkyRjl6MmxTanBreGR3eEtKZXU3MWQ3SWg1TEVsSnBrZW9TSFZxY0hrZ1R0eUZDTVZaUVYwSWhEelBXQVZrZGlhWXhqaWNIZUltV3pkaGlSUjhSQkhDSUVleE5SUW5Nd1pTS29GdndlVWVDYVRGSU5RTm56MzZVUXhsV0Fhd1B0WHVvc3VvcFhyZlZrbHBnYXNZdW4xak9rSThnQ01Kd0t4RU5sZm83N0NtT0pUVFNSUVE0VnlRM1dzSnp4Q2twZlZkVXREY0NDaVNIMTkvZ2wzYStQSldBUHVjNDFRdzRMSkV2RjdOaFRhMEgyTVRVc2MwU1NFS295bUtXR2d3eEZpaXNCU29DYjV1dTRRNnZSODRIaHNTUllaYVBKcmVhYzJQdUFGeDNLM1FWaWRIUHFQSVA5OVFmaVM4QlphUXc5Ly9Td3cveFVjdDl5YTVnWUxQVzY3TUYwR2V5UDNmNDNkbGoyV053NyswOVkwVzlzNzdOWGthVmFtL0w5YWUrdHhuZmd2ZG1qYjRXTFpGOG1NZnovbVoxOTYyZGM1cG9YYVYwR2FROXhnTkp2UGNlOFl3MzkzMFIxdnNkZ24xdy91WFZyc2R5ZTNKeURWUDdpK1dKREpuWHNIRHhhTFM3ZmdPTkpEU3JwV2hiZFJVZVc3dm5BdXFkMDdUdVoyUmVCb2ZTc1h6bU1NOWdBR3BKaDdicFhDLzNLOUpGbjJMWENBWEFtTk9GZFhBU0Z3dFNRNVZCQXFuMnNWN2ErL1JWVVZGMFp4dFREMEd6QUZPRlJtWXBmcUJQVDdoa2JhQXlNQlNRTjAvWmlRU0dXNjl0WUhUeFFwazRNemxya3h1WGl5S081Lys5YXR5MFgreG1xWGpPVFFoUWRKQVhwS0dIaVdKRk9QQXZQNFJLWktxRGt3d2pnd2dMaXVLVXV0VmoxU1h5aUs1M1kyTGZ1SlFNSko4K0p6eGN0dmZ2dk5OTHN4TzMzNU9CNkhLU3lxVmJsbHllVjV4ZTdsQWhJWDdYaDA0V3dIVXhGL1FrRXJuYllNN1FQdDlDZEhwYnpBWUg2alhaSEpVRnVKZ2ZDRmE2UWdQV0ZqU0pyT2NHYUxSWkdacnBjWWd6YlJHdVQyWWJIK1BsU29ERFdDb2NTak1OdDVRYWpBM1ZCcjRvYXlvVWIxVmt1U1RUVG1rUjFKSkk1d1RGK3M4WWhLYUJHdkhvT1V3TkJzV1E3NlE1OWI0b0lHQ2N5UkxPT2JRWllpQnphWlhIRDI5aTd0N2RtZm1GeS9kUDM2S2V1MWpUZmUySGpOT3JVYjd1MU45dmFpM3lDMzcwMDYzbVIvZitKMUp2ZCs5clA3dGU4OGVQQ2RtcnM1Y1BmMzNlSEdVZ2RmbHVYeEpmbS9mL2RSMmxWTWpZZjNRSisvdy9kd1Y0UzVzQ3Q4SFBUWDM4SjRGSS9hNWlyVGVSR3FVWW1qanJqbG9UeFQxTDVOMEZkMWxFVlZqTTR6QkVZaStJTCtYdmxjN2VkRmdoTndyd1F1NGpaRy84NjNRbjczMm9VTDF5Nzg4SjFYQ0h2NXJaZGhBS2lsVzFTdWQrc3kzVXFseG5BMkg3WjIvbmllamtWellZcmpaMzN5UG1QdWk5ZGVkQmw3NloyWHlLU01aMUVmMU91RHo0NGFLK3FEZERoTUg0aWh4aG9IbHh3RkY2OFY1eExUYmR2NDh1VWd1T3dvclpieTNZbXI2Mkd0RnVxZ3MrSU41VGhldG9Fb05JUkNlQmJVMVoxdVNMR2VZZlZvVnR2RnN5ak1wdmlPL2lqNE5zWmduSHdBSDgxUW5VZXNlejdXSDFXWExLNjg4NUpsanp2VXR0RUdkYXZkK3VEcEs1VElyZlpZYkhhYjRyamRZaWZHLzhxWXQ3WitkWDNOcTZwMzgrYkJQdythTjBIcjlrSHFNVTNMVnp3dnV0bjhyMEdUU2JZbTcwZWVwemh4N0dEeVBrTnM3NS9Yc0hJbUhGaTlXbk93eE10OWVCZms2N3ZDRk8wdUNRNkMzSWZqT050d01IVGNDc3Y0RU5uSEhhNHExbVpSbXJ2am5ITDl2ZFhQV0tjM3o1K2ZuRCsvZGNxS0J5dUQ4ZXA3NXpiZzB4dmw2MTFGKy9TNVArT0dTZVR1ZTgvOVRyTjU0aG0yTTE0c3hqdnNtUlBOSnViZmV1NjkxWFhNUDBoazlzckJmNWNobkxDTXYrRDJTeGpUUUFqVTVDa1k4M0l4NnhEdUpkVGZIcUZGUnJBU1FCSGpaUHExcTBZMm92WlBiVHJLakt2TVNucjVGMjkzRVF2V1hYUnZoNXNiNUZxbks4bWpoOExEa1N4MU93Wno2TG5KSGp2NE43TEM5aVljdy9MSVI4REU1K2lJZUVIdUhpY1ZrWDI0OFQ3cDhodFgveGNwWitmaEFBQUFlTnA5anoxT3cwQVFoWi96cHlBaGxDTnNRUkVLYjlhV0szZEpVRVNLdE9rZHZFNHNKWFprYnhTbG93U3Vnc1FKT0FPY2daWVQwTUd6c3lCQkVhOTI1NXMzNHplN0FDN3dEQWZIN3hxUGxoMTA4VzY1Z1E0K0xUZHg2VXd0dDlCMTdpeTMwWE9lTEhlb3Y3TFRhWjB4dTYvL3F0aEJEMitXR3pqSGgrVW1idkJsdVVXZnpISWJ3bm13M0tIK2dqRUthRVF3UEdNSUxIRGdPU1JIMkpCR3JFZk0xcXhYbFQxUzlxNUlFK1RJeUZVc3NHUmR3SWVFWXV5enczQnRFV0xBbGRqZTVMZFhvbVFtcVdycVY4QzQwSkhSc1ZnY3hEQ09ObUpVUlBGYUg4UStOU3N4eVRNenlZdWxGcjVVb3I4eVpoc09CZ25WcEZKbG1jaE1HN3BNNjBFcGJ1dFlVc2l6OURiUFNMUDZoU2wyZkJkbU9rNTNqS2NlRVhMLzl6dXFBVng0N0hPNUZTbWcwWjhiaHVKbkxqRndQZC8xbFJlY3ZONmNzd3RLYVYwUzlLMmNaUjJyMjJDdWl6TE5NNkdVSjVWUzRwVGJOeEQ0Y0tJQWVOcHRsMk8wbmVjV1JyUFdhcHZhU3QzVXpuN1hzMVZ2MXJhTkZDbFQyMGhTMjdidDFMWnQyOGE5dHpQL2JuNzBHK09NN0crZW5UNWp6ckVHK0lELy9mbDc5SUJCQS83UEgzL25QLyt4QVc1dVlXUFoyRGFPRGJSeGJUd2IzeWF3Q1cwaW05Z21zVWx0TXB2Y3ByQXBiU3FiMnFheGFXMlFUV2ZUMnd3Mm84MWtNOXNzTnFzTnR0bHNkcHZENXJTNWJHNmJ4K2ExK1d4K1c4QVd0SVZzaUZXc1dKcXNhaldyVzhPYXRyQXRZb3ZhWXJhNExXRkxXc3ZhMXJHdTlheHZTOW5TdG93dGE4dlo4cmFDcldncjJjcTJpcTFxcTlucXRvYXRhV3ZaMnJhT3JXdnIyZnEyZ1cxb0c5bkd0b2x0YXB2WjVyYUZiV2xiMmRZMjFMYXhiVzA3Mjk2RzJRNjJvKzFrTzlzdXRxc050OTFzZDl2RDlyUzliRy9ieC9hMS9XeC9POEFPdElQc1lEdkVEclhEN0hBN3dvNjBvK3hvRzJFamJaUWRZOGZhY1hhOG5XQW4ya2wyc3AxaXA5cHBkcnFkWVdmYVdYYTJuV1BuMm5sMnZsMWdGOXBGZHJGZFlwZmFaWGE1WFdGWDJsVjJ0VjFqMTlwMWRyM2RZRGZhVFhhejNXSzMybTEydTkxaGQ5cGRkcmZkWTZQdFhydlA3cmNIN0VGN3lCNjJSK3hSZTh3ZXR5ZnNTWHZLbnJabjdGbDd6cDYzRit4RmU4bGV0bGZzVlh2TlhyYzM3RTE3eTk2MmQreGRlOC9ldHcvc1EvdklQclpQN0ZQN3pENjNMK3hMKzhxK3RtL3NXL3ZPdnJjZjdFZjd5WDYyWCt4WCs4MSt0ei9zVC92TC92Yi8vdTkzRHgvTHgvWnhmS0NQNitQNStENkJUK2dUK2NRK2lVL3FrL25rUG9WUDZWUDUxRDZOVCt1RGZEcWYzbWZ3R1gwbW45bG44Vmw5c00vbXMvc2NQcWZQNVhQN1BENnZ6K2Z6K3dLK29DL2tRN3ppeGRQbFZhOTUzUnZlOUlWOUVWL1VGL1BGZlFsZjBsdmU5bzUzdmVkOVg4cVg5bVY4V1YvT2wvY1ZmRVZmeVZmMlZYeFZYODFYOXpWOFRWL0wxL1oxZkYxZno5ZjNEWHhEMzhnMzlrMThVOS9NTi9jdGZFdmZ5cmYyb2I2TmIrdmIrZlkrekhmd0hYMG4zOWwzOFYxOXVPL211L3NldnFmdjVYdjdQcjZ2NytmNyt3RitvQi9rQi9zaGZxZ2Y1b2Y3RVg2a0grVkgrd2dmNmFQOEdEL1dqL1BqL1FRLzBVL3lrLzBVUDlWUDg5UDlERC9Uei9Lei9Sdy8xOC96OC8wQ3Y5QXY4b3Y5RXIvVUwvUEwvUXEvMHEveXEvMGF2OWF2OCt2OUJyL1JiL0tiL1JhLzFXL3oyLzBPdjlQdjhydjlIaC90OS9wOWZyOC80QS82US82d1ArS1ArbVArdUQvaFQvcFQvclEvNDgvNmMvNjh2K0F2K2t2K3NyL2lyL3ByL3JxLzRXLzZXLzYyditQditudit2bi9nSC9wSC9yRi80cC82Wi82NWYrRmYrbGYrdFgvajMvcDMvcjMvNEQvNlQvNnovK0svK20vK3UvL2hmL3BmL25jTUNBdVBpTEZpN0JnbkJzYTRNVjZNSHhQRWhERlJUQnlUeEtReFdVd2VVOFNVTVZWTUhkUEV0REVvcG92cFk0YVlNV2FLbVdPV21EVUd4Mnd4ZTh3UmM4WmNNWGZNRS9QR2ZERi9MQkFMeGtJeEpDcFJJa05SalZyVW94SE5XRGdXaVVWanNWZzhsb2dsb3hYdDZFUTNldEdQcFdMcFdDYVdqZVZpK1ZnaFZveVZZdVZZSlZhTjFXTDFXQ1BXakxWaTdWZ24xbzMxWXYzWUlEYU1qV0xqMkNRMmpjMWk4OWdpdG95dFl1c1lHdHZFdHJGZGJCL0RZb2ZZTVhhS25XT1gyRFdHeDI2eGUrd1JlOFplc1hmc0UvdkdmckYvSEJBSHhrRnhjQndTaDhaaGNYZ2NFVWZHVVhGMGpJaVJNU3FPaVdQanVEZytUb2dUNDZRNE9VNkpVK08wT0QzT2lEUGpyRGc3em9sejQ3dzRQeTZJQytPaXVEZ3VpVXZqc3JnOHJvZ3I0NnE0T3E2SmErTzZ1RDV1aUJ2anByZzVib2xiNDdhNFBlNklPK091dUR2dWlkRnhiOXdYOThjRDhXQThGQS9ISS9Gb1BCYVB4eFB4WkR3VlQ4Y3o4V3c4RjgvSEMvRml2QlF2eHl2eGFyd1dyOGNiOFdhOE5YRDRzS0g5eXBBaFBDczhDOC9rS1o1Vm5qV2VkWjRObmsyZUxaNXRuaDJlWFo0OW52MS9ueFg0RmZnVitCWDRGZmdWK0JYNEZmZ1YrQlg0RmZnVitCWDRGZmdWK0JYNEJYNkJYK0FYK0FWK2dWL2dGL2dGZm9GZjRCZjRCWDZCWCtBWCtBay80U2Y4aEovd0UzN0NUL2dKTitFbW5JU1RjQVJIY0FSSGNBUkh2RmQ4TC9GKzhYN3h2ZnI4dk0vUCsyTit6dmZ0ODN2MCtUMzYvLzRlaGIwVjlsYllXMkZ2aGIwVjlsYllXMkZ2aGIwVjlsYllXMkZ2aGIwVjlsYllXMkZ2aGIwVjlsYllXMkZ2aGIwVjlsYllXMkZ2aGIwVjlsYllXMkZ2aGIwVjlsYllXMkZ2aGIwVjlsYllXMkZ2aGIwVjlsYllXMkZ2aGIwVjlsYllXMkZ2aGIwVjlsYllXMkZ2aGIwVjlsYllXMkZ2aGIwVjlsYllXMkZ2SmVHenU4THVTc0pQK095d3NNUENEZ3M3TE95d3NNUENEZ3M3TElJditPeXlzTXZDTGd1N0xPeXlDTDdnQzc3Z1YrRlg0VmZoVitGWDRWZmhWK0ZYNFZmaFYrRlg0VmZoVitGWDRWZmhWK0hYNE5mZzErRFg0TmZnMStEWDROZmcxK0RYNE5mZzErRFg0TmZnMStEWDROZmgxK0hYNGRmaDErSFg0ZGZoMStIWDRkZmgxK0hYNGRmaDErRTNlVStUOXpSNVQ1UDNOSGxQay9jMGVVK1Q5elRIdklmdjBlUjd0UGdlTGI1SGkrL1I0bnUwK0I0dCtDMzRMZmd0K0MzNExmZ3QrQzM0TGZndCtDMzRiZmh0K0czNGJmaHQrRzM0YmZodCtHMzRiZmh0K0cwNGJUZ2RPQjA0SFRnZE9CMDRIVGdkM3QvaHZSM2UyK1h6WFQ3ZjVmTmRQdC9sYzExK3J5NmY3L0w5ZS93ZVBUN1g0M005L2w2UGY3Y2UvMjU5L242ZnY5Zm45K3Z6NzlDSDE0ZlhIL081ZjNtSi94UC9KNTVQUEo5NFB2RjY0dS9FMzRtL0UzOG4vazc4bmZnNzhYZmk3OFRmaWI4VGJ5WGVTcnlWZUN2eFZ1S3R4RnVKdHhKdkpkNUt2SlY0Sy9GVzRxM0VXNG0zRW04bDNrcThsWGdyOFZiaXJjUmJpYmNTYnlYZVNyeVZlQ3Z4VnVLdHhGdUp0eEp2SmQ1S3ZKVjRLL0ZXNHEzRVc0bTNFbThsM2txOGxYZ3I4VmJpcmNSYmliY1NieVhlU3J5VmVDdnhWdUt0eEZ1SnR4SnZKZDVLdkpWNEsvRlc0cTNFVzFtSFg0ZmZnTitBMzREZmdOK0EzNERmZ04rQTM0RGZnTitBMzREZmdOK0EzNERmZ04rRTM0VGZoTitFMzRTUGJ4UGZKcjVOZkp2NE52RnQ0dHZFdDRsdkU5OG12azE4bS9nMjhXM2kyOFMzaVc4VDN5YStUWHliK0RieGJlTGJ4TGVKYnhQZkpyNU5mSnY0TnZGdDR0dkV0NGx2RTk4bXZrMThtL2cyOFcyMjRiZmh0K0hqNGNURGlZY1REeWNlVGp5Y2VEanhjSGJnNCtQc3dNZkxpWmV6QTc4RHZ3Ty9BNzhEdndzZmp5Y2VUenllZUR5NzhMdnc4WHJpOWNUcjJZWGZoZCtGaisrekM3OExILzluRDM0UFBqMUllcEE5K0QzNFBmZzkrUFFpZS9EcFJ0S043TUh2d2UvQnB5ZlpoOStIMzRkUFo1TE9KSjFKT3BOMEpybGJrcnNsdVZ1Uy91U1kvbkMzSkhlTHVGdkUzU0x1Rm5HM2lMdEZkRXQwUzl3dDRtNFJkNHZvbWVpWjZKbTRXOFRkSXZvbTdoWnh0NGk3UlhSUGRFOTBUM1JQZEU5MFQzUlBkRTkwVDNSUGRFL2NMZUp1RVhlTHVGdkUzU0x1Rm5HM2lMdEYzQzNpYmhGM2k3aGJ4TjBpN2haeHQ0aTdSZHd0NG00UmQ0dTRXOFRkSXU0V2NiZUl1MFhjTGVKdUVYZUx1RnZFM1NMdUZuRzNpTHRGM0MyaS82TC9vditpLzZML292K2kvNkwvb3YraS82TC9vditpLzZML292K2kvNkwvb3YraS82TC9vditpLzZML292K2kvNkwvb3YraS82TC9vditpLzZML292K2kvNkwvb3YraS82TC9vditpLzZML292K2kvNkwvb3YraS82TC9vditpLzZML292K2kvNkwvb3YraS82TC9vditpLzZML292K2kvNkwvb3YraS82TC9vditpLzZML292K2kvNkwvb3YraS82TC9vditpLzZML292K2kvNkwvb3YraS82TC9vditpLzZML292K2kvNkwvb3YraS82TC9vditpLzZML292K2kvNkwvb3YraS82TC9vditpLzZML292K2kvNkwvb3YraS82TC9vditpLzZML292K2kvNkwvb3YraS82TC9vditpLzZML292K2kvNkwvb3YraS82TC9vditpLzZML292K2kvNkwvb3YraS82TC9vditpLzZML292K2kvNkwvb3YraS82TC9vditpLzZML292K2kvNkwvb3YraS82TC9vditpLzZML292K2kvNkwvb3YraS82TC9vditpLzZML292K2kvNkwvb3YraS82TC9vditpLzZML292K2kvNkwvb3YraS82TC9vditpLytyWC93SHVmOWQvQUFBQUFBQUIvLzhBQW5qYVkyQmdZR1FBZ2pPMmk4NkQ2QXZMakNkQjZTa0FTLzBHOUFBPVwiO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaE1BQXdBUGNBQUFBQUFETXpNMlZsWlplWGw1aVltSm1abWFpb3FLdXJxN0N3c0x1N3U4TEN3c3JLeXM3T3pzL1B6OUxTMHRUVTFOWFYxZG5aMmVEZzRPSGg0ZVBqNCtUazVPYm01dWpvNk9ycTZ1dnI2Kzd1N3ZEdzhQTHk4dlB6OC9YMTlmYjI5dmYzOS9qNCtQbjUrZnI2K3Z2NysvejgvUDM5L2Y3Ky92Ly8vNUdSa1phV2xwcWFtazFOVFhSMGRJQ0FnSEp5Y3FtcHFkL2YzelEwTkRZMk5rTkRRMFJFUkVoSVNFbEpTVTlQVDFwYVdsdGJXM2w1ZVg5L2Y1dWJtNStmbjZDZ29LT2pvNlNrcEthbXBxZW5wN096czdTMHRMYTJ0cm01dWIrL3Y4SEJ3YzNOemREUTBOYlcxdGZYMTl6YzNPWGw1ZW5wNmUzdDdWTlRVeDBkSFNBZ0lDWW1Ka1ZGUlhwNmVuNStmb1NFaEpPVGs5SFIwVTVPVG9XRmhRRUJBUUlDQWdRRUJCUVVGQlVWRlJvYUdoc2JHeUlpSWlNakl5OHZMekF3TURFeE1USXlNbEZSVVZaV1ZsZFhWMlptWm1kbloyaG9hR3hzYkhGeGNYTnpjM1oyZG5oNGVIeDhmSWFHaG9lSGg0aUlpSldWbFo2ZW5xeXNyTEd4c2JlM3Q3aTR1THE2dXI2K3ZzUER3OFRFeE12THk4ek16TlBUMDlqWTJOcmEydHZiMjk3ZTN1TGk0dXpzN08vdjcvSHg4ZlQwOUV0TFMxSlNVcEtTa2g0ZUhpUWtKQ2NuSjBaR1JsUlVWSFYxZFh0N2UweE1USGQzZDd5OHZBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFDSC9DMDVGVkZORFFWQkZNaTR3QXdFQUFBQWgvd3RKUTBOU1IwSkhNVEF4TWtnQUFBeElUR2x1YndJUUFBQnRiblJ5VWtkQ0lGaFpXaUFIemdBQ0FBa0FCZ0F4QUFCaFkzTndUVk5HVkFBQUFBQkpSVU1nYzFKSFFnQUFBQUFBQUFBQUFBQUFBUUFBOXRZQUlmOExTVU5EVWtkQ1J6RXdNVEpJQUFBTVNFeHBibThDRUFBQWJXNTBjbEpIUWlCWVdWb2dCODRBQWdBSkFBWUFNUUFBWVdOemNFMVRSbFFBQUFBQVNVVkRJSE5TUjBJQUFBQUFBQUFBQUFBQUFBRUFBUGJXQUNIL0MwbERRMUpIUWtjeE1ERXlTQUFBREVoTWFXNXZBaEFBQUcxdWRISlNSMElnV0ZsYUlBZk9BQUlBQ1FBR0FERUFBR0ZqYzNCTlUwWlVBQUFBQUVsRlF5QnpVa2RDQUFBQUFBQUFBQUFBQUFBQkFBRDIxZ0FoL3d0SlEwTlNSMEpITVRBeE1rZ0FBQXhJVEdsdWJ3SVFBQUJ0Ym5SeVVrZENJRmhaV2lBSHpnQUNBQWtBQmdBeEFBQmhZM053VFZOR1ZBQUFBQUJKUlVNZ2MxSkhRZ0FBQUFBQUFBQUFBQUFBQVFBQTl0WUFJZjhMU1VORFVrZENSekV3TVRKSUFBQU1TRXhwYm04Q0VBQUFiVzUwY2xKSFFpQllXVm9nQjg0QUFnQUpBQVlBTVFBQVlXTnpjRTFUUmxRQUFBQUFTVVZESUhOU1IwSUFBQUFBQUFBQUFBQUFBQUVBQVBiV0FDSC9DMGxEUTFKSFFrY3hNREV5U0FBQURFaE1hVzV2QWhBQUFHMXVkSEpTUjBJZ1dGbGFJQWZPQUFJQUNRQUdBREVBQUdGamMzQk5VMFpVQUFBQUFFbEZReUJ6VWtkQ0FBQUFBQUFBQUFBQUFBQUJBQUQyMWdBaC93dEpRME5TUjBKSE1UQXhNa2dBQUF4SVRHbHVid0lRQUFCdGJuUnlVa2RDSUZoWldpQUh6Z0FDQUFrQUJnQXhBQUJoWTNOd1RWTkdWQUFBQUFCSlJVTWdjMUpIUWdBQUFBQUFBQUFBQUFBQUFRQUE5dFlBSWY4TFNVTkRVa2RDUnpFd01USklBQUFNU0V4cGJtOENFQUFBYlc1MGNsSkhRaUJZV1ZvZ0I4NEFBZ0FKQUFZQU1RQUFZV056Y0UxVFJsUUFBQUFBU1VWRElITlNSMElBQUFBQUFBQUFBQUFBQUFFQUFQYldBQ0grTFUxaFpHVWdZbmtnUzNKaGMybHRhWEpoSUU1bGFtTm9aWFpoSUNoM2QzY3ViRzloWkdsdVptOHVibVYwS1FBaCtRUUVCUUQvQUN3QUFBQUFNQUF3QUFBSC80QW9nb09FaFlhSGlJbUtpNHlOam80bEpZK1RqVTFaVWxKWlRaU2Noa1ZWQUtFQVZVV2RwaENnb3FGVkVLYWNQS3FxUEs2SUp4c1VVQ09ESkRpeG9qZ2t0SVZSUFRrMk9Ec05KeWdqTEw2aExMckNnbEV2TWdIWUFUY0tnbGZQQUZmVGd6M1o1VG9ZS0ExVXZsUU40aWdiT3VYWk13bUNCbE9xVXdidktCUTI4N0w5RUhSQ1NRc3JWbG9vV2ZZT0NvNkEyQTRRT2hFaUJNTitKSFpBck1HazM2SUdOK2JKU0NISm95SUZPV1pnbzVHQ2cwbEdHQkw0T01BazJFdEVKa3pjYkFURnlBQVZSQ3pzVEFRQmk0Q2pBcTRzR1dvSWd3dWtTSzlVWUVyb0NGU29DS2dTN0hFVnFaYVNURTl3N1NyZ3ExWVVWc2xtUGV1MHE5U3pnck9LUWxVS2QxRFBuMEhyRnNxcE54R0lDUThpYUxnSTl3bUNGUU1JQUdGZzgyeUdJUU1pUjE3QmdQRFFFMGtrYXc2aTRld0hHSm9sRTRoUTZJUmxjUjJDaEpiOFlKQ0lDMDZjWEJEaGNRU0MxUU42VEJERTRjR0Mzd3NldU96bm9NQnFCQ0JRaUlBQUhEZ0UydTlFSURFdVdjZ1RRVkNhTjRmaVVjUVdCRUVNSk1rd0tJWjI0REZlanVqd2diRDU4d3ZTczRXL0FOM1pFVXpPTTVGMjFrTis0RXg0ME5jSUdVZ2dRUWI4OWFYZ2dsb0ZBZ0FoK1FRRkJRQXZBQ3dDQUFJQUp3QXJBQUFJL3dCUkNCeElzS0JCRXlZTUtseklzS0NFUFhUbzdKSFFzR0xGUVpFQ2FBd1FhWkRGandVVnJkbTRjWTBpa0NoWGtDUzU0b1hMbHpCanl2U1FZVU9KZ1NYbXJOdzQ1NlpBRVlzUU1UclJzSU9mTG5UczdEbUpvb1NjblJybDNEeWhnRTJaTVdoY1hGallvWUFiQVdBRjFJRWdVQVhVQUNvRTloa0RvQzBBTDF5Mkd2VHpOU3pZTzQ1UUlHS3hrd1VpRkJYU3VIWHJ4WVZCRDNmc2hvWERRR0FDU0NRaEpSQm9BTXhndDJvWUZjeEFSM0hZQkM4UHBZZ1RKOFdobDNrdXV4MlRxT0FHTzU3QkNvbzVZa1JNUFY1VUF6Q3pxS0NKUGJGYlVMQklTSXp1TmlNTUtxcWorQTJDaEJWSnRQaHltWXlDaFJDNndCSGdaZzRDRUNBMXROOElreHZNbVQ1RUZ6cGlBRWdRQmVnZ1J4RFNnOGRBaFlVbjBxUGNMNUREbGdTQU5MQUJmeWhaY0FBQkF3eEFnQUhERVZoUkIzd2tLT0VBQmpUaVlFT0dJRGhoZ29WY3lGQWdHMHI0QjN3ZUVnUmlpQU9NV0tKQkdhTFk0WW9GUVJoaWhUQWFaS0NHQ3paWVkwSCtBU2pnamd6bEIrUkhKWENBZ1FZaERGblFJeEVVc2dBaFcxeEE0bzRmR0xMQWxWY1dJdGVRRTJEcDVSWkpBa25DQTE1aVNZZ0dRNDdnUUpsWVlqQ2tDUkd3dVVBaEhDaUpBU0ZzUnVBVGtDWklnQ2VXaGp5aXBFQWxZSENJQXc5TUFONmdBNWt3QWdreE1TcnBwSlJXK2xGQUFDSDVCQVVGQUN3QUxBTUFBZ0FyQUNjQUFBai9BRkVJSEVpd1lNRVRKd3dxWE1pUUlZWWpQWG9jd2RDd29zV0JFSGdJMkNpQUI0U0xJQlZDMGNoeEl3OG9JVk1LTkZLeXBCR1ZDMGQwK0pCUW9Ja0JMVGtPTURGd0JCUUtHMnBhRk9FQVFSQURTVExZVkpGem93cWVKeHJzd0dFalI0OG9RNUVVR01CMWdKQW5Bb2swRlVCRW9JSWJBZElHa1BFQ2EwTUhXN3R5UlFBQ2hZVk1PVE5aUUlGQmg5cS9QUnFPUUNDM2E0OEpBcGZzS0xsamljQUVNLzZxMWJHQllZY2doYnMrR0ZnQmdTUkpDQ29NL0NGWnJRMEtERC9BeUR5QVFJU0NKVW9VUEZBNkxRNlVDMDhrWVIxRWcwVW1OV3J2SU5Fd3c1RENLeGdJWlZnaWhRekpOeHBZZklKZ1JXc2dESWhmNUpDQ1J0b1pPUlNBc1FReDRVRUVEY3N0a21oeXdFY0NpakRqR3h5aHZhRFBHREdnaUpCL1VMRW1MaDRSNUFFVEN4UzR3QU1jOERlUUFaTUE0Q0FBbEJRaDBBaE5HR2pnQS92eHAwU0REenBZU1JNb1pHQ2hoUmNvaUVtSEhYYUJnZ1FqR3VnRWZ5RllndUtEbDVUQVlvc0x2Q2hmakRNNldLT0lPSmJJMzRrOXFraGhpeGdxdU9HTUh3bzBvSVVJS2lnUWd4MUdTTkI5K1dVbzVRbitBZmlSbENIUkIrYVlaSlpwNXBsb3Bxbm1tbXkyNmVhYmNGNFVFQUFoK1FRRkJRQXBBQ3dEQUFJQUt3QW5BQUFJL3dCUkNCeElzS0RCZ3dnVEtqVFl3VkNnUUlZNkxKeEkwUUlmQWdNR0VPQmpnYUxIZ3h3T1pCdzU0QUNIanlnRmJzRklVdU9XbEFoTmpDQnhZdUNKQkMxSGNxb3BzTVNHREI1NFRpeUI0WkNEQnhOQUNMeVpNMk1Dbm9yMjJLSFR4WS9FaFNZa0VGckFkWUdoUndJYk5CM1FRQ0NFT2dMU0NuQlQ0R3BDREZ1N2NvMVFBc1VHR0RsaGJFRGg2STVhdFc3OEtEUVJRVzdYUWlkUlVEQkEwZ0FGZ1F6Zy9GVjd4MFBDRVE0TWQ4VXdzRkdoUDM4S05ScVlZTEphT2hrU2tuaWdlUUVoRFFWTm1DZ295SFJhTzNzVFRtaTlKY1JFQ2kxczc1bWQ4SU1odzRVdVVEU0I0TTNrT29vbVBvcFF5UFdXQzhRbmdrQXd4NDBBT0YwZ2VOVXN3UUdEQnQ4b1RWQVFCSWlCSTVqd0Q1YW9Hei9sQ1VSNjVMd29FS1AreHdTYUJDQmdBR3NNNHQ5RWh3UTRvSUJTU0hDZ1FwSXN1T0FlRHlJMFFod1NEcmhKZGhVT2RHR0dBbTdZb1VFUmdramhpQVVsbUdHREtCb0U0SUlGdG1qUWZmbnQxNStNQ00ySG80ZUU2SUdIQVJYc1NKQUdMWVRoQlFCZ25OR0hVREtTME1JWEFFUVpKUmtLQ0VtSUdGSm0yY1lJTytweFpKWlJtckhJam5tQUtlVVlpZXhvQUJobUFxQUdJenRXa0lhWlhyZ2dKQXA5akpHbEYxd29KK1FKQ3JCUnhoaG91T0RublNpSXNBZ2lqREJKVUVBQUlma0VCUVVBV3dBc0J3QURBQ2NBS3dBQUIvK0FLSUtEaElRakdSSVNHU09Galk2UGpSNU1DNVFMVEI2UW1ab2prNVdVVEl5YW9vVVlucDRZbzZtQ01hYVZNWVFuSHgyaHFvU3NyUXV2Z2hsSkJrRUlEaUsxZzFDNEMxQ0NUMElEekFNRlNNTERJaEN0RU1JZ0NNM05CUTdEZ2h3UG5nOGNnaE05MnMwSXRMVWlGMDVPRjlFb0Qrak5RUjNlZ3ljbmhSRUU5UU5nZk1nSFNVTVFnRW40RVhSMGdzRUtkRU15TElSRWdnR1FmeXNRUEptWTZZU0dDQThtZ09BNHpJUUprcG9zRUZFeHdBZ3lsSTJXWEJGQVV3QVdDREFKVlpoWms2WUxWRGxSSU9qWjgwalFFbHFJMXV5aEVDVlNwVFNaQmgwSzFXalFuVXAvQmhVa3MrZk5yWU5Vc25RSnRwQkpzQ1NZSFBDUkFDaFlEaW1oYUFRSU1DT0hBckFsVXNpWXkvZEdnNjFNYXZBZHZJTUV3Uk1oUWpSRmNXRHdZQnd2YTUxUTBzS0tsUlpLRlA1d3pOY0dCVzhHcGdBWURXQ0tBVUVKWm5BT29HUERzQVpVU0pPbThoZURqdFU5dkYyUkxmdUtJQVUzQnN0NEVXWFlDQmE4U2JOZ2RLTEJEaHcyY3ZRb1Bvd0VqdVNqY1JnV05BSUtoUTJMYS9IQURvREhWZ2hWa2xmQnViVklldEpWaXBSRjBTU0xGQ2xabXN3ZlZLTEV3a0FBSWZrRUJRVUFMd0FzQndBREFDY0FLd0FBQ1A4QVVRZ2NTTENnd1lNSUV5cGN5TENodzRjUUkwcGNlSUxFQ0JNVEg0S1k4TURCSVF3bE1pNThaR2lCeVFXRUpHQVVlYkJFaEpNbkNXRmdlWkJESVpnbkQ2MmtPUkFEenBNT1J2QWtxSUhRendVUFNBd2RHR0xMMFFsTENWNjRDZFBRaDZnRFRWellZclJRaEVkWUM0YlFnSUZEeUxBS1Q1eEFXM0JEQTBBSnRuQmdpNEtDQVFJREJoQTRZQUZ0SXdONUF3L2cweUZzSWNHQkNSakNhdUlQNHNDQkdEdCtQQ0F5MXNPUEZZZjkrNWd3V3J0NDlmS2w2eGF1WExvRDFTS3NZQUNQSGtKQ0g1cWdJQWdRQTBjSlQvUTVBd2FBbHpBdE5EZ0VnV0NPR3dGd3VrQkFxSUFNZ09mUHY3UlF1dEFFZ2pjQ3NtZXZvOGpnaURiUXc0dlpJY1NRUWd2dDZQZnNGTGpJVEhqb1h2UVFQREZpeE5xQmd0Q2p0N09oWUtJeDcwR1hoMEFuSEpKQ0hIR2tjTWg5Q2VpbkhSMFpGTVNJR2dFQ0FJWUJBaVVBU1FBY0JnQkpBZ0l4QUllREF0emhnVUV1ZUJGZ0doV2dnQWdMSFhiSUFpSW9PSEtIZzI3NGNkQUZYS2dJM1JoOUNLUkNqREdxSUJBRWRhRG5SZ0dGN2VnQ0dtT1V3WVlDYTVVZ0I1RWR5bkdXSW52WVFVY1hmalNKMEFtTUlMS0lDQU9WTUFlV0hNNXhGZ29sYkpDQkIvZEp0QUtiQWF3UWxpSnJZTGxHZDJFTkVrbU1rUXhDbHdSNzBFSEhIaEtnSnBBSjYwVVVFQUFoK1FRRkJRQXRBQ3dDQUFjQUt3QW5BQUFJL3dCUkNCeElzS0RCZ3dnVEtseklzS0hEaHhBalNweElzYUxGaXhnemF0eklzYVBIaGlSR2ZFUUlnUWNYRmp1V25NZ29Ba3FNR0ZCRURpeENDWUJOQUpNTVlPVHdZSUhQQlV3OENHeFM2ZWJOU1Vvc2l1ajUwMmNUa1YyTUdzVms4VUxUcGhsS1hKSjYwMUtJaWs2dS9wU2dsYXROcjJERitwU0FJcXBacWhXdHFzMkFnaWhYcEVxWk5uMHFrS2JSbkR2MUFoVTZzT1RKbENzeHRud1o4MkRJa1F3eEpQQnhvQWtKaUNjMFJIZ3dBWVJEQlRsbUJBaEFJd1VIaHlRWUFDRXdvQWVDSnd3YjNCaE5XMGFLRWd4UE1GZ3hvSGZ2SVhRVGt0aEJ1M2dOSmd3MUJQSE5QRW5pZzFCd0ZDOStvR0FKM0FRanNHYmVHOGFIaEJSc1RMR24vV05nQlFTU0pDR29NUEFCZDk5Qk9pVGNvR044Z0JrSkJDN1pJYUMvZ0pRQ1RkRERld01nSUJOQ1BkaW5Bd1lvV0pDSmYvNWxZZ0VLSUNEd1hnRU9MQlRGQ3pJVWQ0TUNBaEVCSVlSRUNQU0VFTXdWZ0lRSURFWFJRdzQyNExCREF5dVpvTUtJL3FsZ2drQVpKR0ZBRUFoc3dXSkRKMnhBUVdNQ21UQUFqdjBOc0tOQUozelF3WUVXR2NHa0FFWkFCZ1VQT1BJQUJXUW9sQVFoRHhDQUtSQUdSL1RRd3hFTW1qblFDYzlGRkJBQUlma0VCUVVBS1FBc0FnQUhBQ3NBSndBQUNQOEFVUWdjS1BBRUkwU0xSQkJjeUxDaHc0WVhYS0FaVTRhTmdoTVBNMm9rZUlHTEZ3QWdBWXpwczdIa1F4Y2ZRNEpNVThHa3k0R00xS2dNQ2NiQXk1ZUp4c3dNbWVlbXkwVm1kZ0x3b3NlbnlSRnRoSW9oWk5Ta0FqSXp2N1FnMGJUa2lUNW53QXdOMDBKRFZaY1ZET0RSUTJqRTE0MGxTcHg5R2FQQUN6bDZFR0ZjbTNIUW1nQjRBMmhLUVBlaEJDbDU4Mm82MUxmaG5zQ0JKUlZlYUdJVDRyeHh6QzRXMlBneDNzaVRCeDYyckRpendMK1BCM3NlYURmdzN0RUUyNzZOT3hmMXdMU3VNenBpQUVnUUJSTTNRMmpBd0VGdFNRaGQ0QWh3TXdjQkNKTW1MbXdodEtCUWhFY2JGZFVSUUozNkd3UzROMTRvdEtCN2QwTWZNcHJVMkZPOWZBc0tHME5zOGM1K1FzWU5kc3FYRjhRNCswQU56TmwzZjBEVllRWTY4bFhIbDBDTkZQTEhINFUwTWhBRytubm5nR1FOZVhCSGdBTEF3WUJBRkJnd3dJWURHSUFlQ2h4dzEyQUU5alhraHhzQjN1RUlDaHZBd0NHSE1HeUFRZ2tSTkVnSUJocDFVQUNLMWRVQmdVQU52UGhpQXdJOVlnaDdoRWhRb2tNZCtORUZIWGJzb1VoQkNRakpZUUp6Z1REQkF3NGNnb0Z2RzUzZ1FRWWJnSGxDbFZZT3dFbHJKNUF3d3BKTmJVR0FsUVJzZ1JvSEIxaDVBQWV1V2NESG5BTVF3SWNGc2FIUWdTR0JCR0pJQjRYU0ZSQUFPdz09XCI7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTphcHBsaWNhdGlvbi9mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFSVEFBQklBQUFBQ0ZzUUFBWWN0QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCR1JsUk5BQUFCbEFBQUFCd0FBQUFjWlFZRU1rZEVSVVlBQUFHd0FBQUFLZ0FBQUNvSEJBcm9SMUJQVXdBQUFkd0FBQ2MyQUFCTnR1MFlGVHBIVTFWQ0FBQXBGQUFBQXJJQUFBWk1iS3RDSlU5VEx6SUFBQ3ZJQUFBQVZnQUFBR0M1Y3dFV1kyMWhjQUFBTENBQUFBTWhBQUFFZGtFcVRqbGpkblFnQUFBdlJBQUFBREFBQUFBd0dCNEN2bVp3WjIwQUFDOTBBQUFCUEFBQUFid3Y1azZyWjJGemNBQUFNTEFBQUFBTUFBQUFEQUFJQUJObmJIbG1BQUF3dkFBQXZyUUFBWGVJZVZHUjUyaGxZV1FBQU85d0FBQUFNUUFBQURZSlp2U09hR2hsWVFBQTc2UUFBQUFoQUFBQUpBdWRDWlJvYlhSNEFBRHZ5QUFBQ0tvQUFCQkVFV3A4UVd4dlkyRUFBUGgwQUFBSCtRQUFDQ1FEYW1NVWJXRjRjQUFCQUhBQUFBQWdBQUFBSUFZK0FoTnVZVzFsQUFFQWtBQUFBb1FBQUFVMDhhYjNKWEJ2YzNRQUFRTVVBQUFRMHdBQUk2WmZlT0hnY0hKbGNBQUJFK2dBQUFEV0FBQUJNN1ZVUXpNQUFBQUJBQUFBQU5JQkp0b0FBQUFBeFBBUkxnQUFBQURPRk13cEFBRUFBQUFNQUFBQUlnQUFBQUlBQXdBQ0EyWUFBUU5uQTJjQUFnTm9CQkFBQVFBRUFBQUFBZ0FBQUFCNG5NMmNlM3hWeGJuM1oyWWw1SjZkaEl0NEtTQTNMV29GYXN0RnZMUUhQZEw2S3JXMENnZDVxWitLNTZnOTlGQ1BSNjAzRk1TcTlZNVNxNEFpdG1CVlZGUzhFQkNNUW5CRHdpWGNkb0FrTzJ2dm5henNhMkp0clpuM08ydGZzaE1pWWovbmozZXR6NDlaYTlaYU0vTTh6MitlNTVuWlVTR0ZFSVZpdERoZnFNa1hYenBObE43NGk1ditVNXdrY3FnWFdndnpQUHRhM25EdHZQOFUrZWJLUlk1UWxFb1VmdStJa0dQdk51L0tWZFpNem11c2RWWmx6dWljaVRtWDVzekx1VDl2RTZjL3J5Vi92TG5LdVRSL1R2NURCYVVGdCtUNUMyY1ZMaWhjWFZSY3RMUm9ZN0VxSGxJOHNmakNrdXRMWnhjUEtiMnY5TW5TdUtmTU00cC9SMXVWWFNldHprdWVicnR1aXdicGs1N2NzNmlZRnJ2T2ljbXpkSGJtak5OTDNLb3NWbW5RY3ZJMDdjd3JudGdUNmY2NjVFbWU2VkdVems2RDBYTVczR0xPOUhqTVdiaWdxTGcwN3NyTGFmb3N1TVV6RDQxVkpxWEp1YlNvMkdqTzQ1aWFvcVZKMmZKYXJFcnp0T3hWbzd2eUpRVzNGQlZYM0ZlNHV1OHY4ellWRmZkVHBmRisrZjBxQnV3ZStHcHAvTVFsUm5zblBYN1NrbE1lUDJYTG9CbURIbUpFNkdwd29jZEpqdnZVVXpoL21OZHk2cjY4VFZibDBLR210Mkg5Y3VZVnJoNXhoZWtyTFUzK25KeUpCYmVjdXE5d3Ria2ZhYjQ2NWJRM1RyL3AyMmp6MjdOSFRSeTFjVlIxOFVUUHFGSHRad3d5Zlo2NXdHalVNK3BzZGZhazBYTkd6eWtlTXZwK28vRlJHOGNVbXZ2UytLbW5qSjVqVlpiT0xweFZHamNZMWM3N3pxaU5IcWR3dFdjVVBTZlBUYWJmcEo3YytrM0pmODJac2RTOHBEWE5FMWZmOUgvcVBucEl3YlE2YXFONWF0Nm1oUVhtekxiMThhQTNEdlRrUTdiVmU2SjBkcEtIUnBJdTVGenF6cEhNT2VhY01SZVB1WEhNeldOdUgvUHdtSFZqdG84NU1pWStkdURZUVdQUEdYdisyRitPdlkyWk5rTVVpZjVpZ3Vnbkpvb0tNVWtNRU12RUFQbDlVU0hIVTA0RU40Sjd3UDFpZ0JvbStxa1JZQ2JYczhESG9rSnRBZFdpd2hva0JsaER3RkF3bkhha3FOQkR4Q2xpcU40c3J0UVJNVU1mbGhmcHNMeFhOOHVGdWxZdUVlWHllYjFGYmhaOTVVRmRKV082V2wydWw2azUraWZxT3YxYmRUMzNOK2g2ZForT3F6ZjBmNnUxM0grZ0wxZnI5VVBXWEYxdkxkSWQxaVBnQ2YySjlhU09XWXUxMTFxaVB4SktuU2lLZU5QR2F4VHo3NFc2WGN6V0VkcHFFd1hpZmtaeHUwN0l1M1ZVTHRFdGNqUDNCL1VSM2o5aXpkZHQxdE82UStTS0tUck1lRnZvcDQxMm83UWJGZHVGUnc4UTVXQzRyaEpuZFg0dXhxRzF5ZnFRdUZpM2luOEZsNEFmZ1N2QU5QQXplcjlLdDRqcE9paG1nbnY0N2w2d0FDd0U5NEZGNEFYYVdBRmVCQ3ZCUytCUFlCVnRyQVl2ZzcrQVY4QmE4Qlo0Rzd3RDFvSDM2ZU1Ec0I1VWdnMzA5U0hZUk51YmFlY2p5aXJLanlrL29kektOOXVBRit3QXRXQVAyQXYyZzRPZ0hod0dEYUFKTklQUE9qK1hIdDBxeTBGZjBCOE1GLzNrU0hBR3Vqd0xuQTNHZ08rQzc0RUpPaWduODk3RlhGK0NsYWZvUTNJcTc4L2hlaTZZQjI0RnYrT2QzL1BPdzVTUDhzMHo0Rm11bDRIbDRBV2UvUm1nRTdtYThuWGFlSWZ4dkVlNWdlOXJLUS9UdHAvbmJTQUs0clNSb05TNlZRbGdnUklkVlAxMWxScks5WEN1UjRMVHVUNFRqQWFYd2U0ckthZURHVnhmemZOcktPL2ttN3YwSVhVMzVYektoVHhmQkJpM1dneWVCbjhBei9IK012QThlSTM3TmVCMThEN0FIZ3A3cUU4cHZaVGJLWGRRMWxEV1V1NmszRVc1bTNJUFpSM2xYc3A5bFBzcEQxQWVwUFJSMWxNZW9rUm1kWVN5Z2JLUnNva1NXNmtBQ0lGV2dENVVCTVFBK2xCL0ExK0FMd0c2c1NSQU4xWXV5QU1Gb0FpVUFPeHRsVE1UK29MKzRBUndJamdaZkFzTTFrSHJWREFNakFBVDlBRHJQUEFEOEVNd1gyOFUrY3p4L3JKSjlHZHUrNW5iemN4dFAzTzZpVG5keU16ekM4bDdyYUl2Yys1RC9FTVZmbUd0UEtMMzRoUGVWV1g2RFRWSzcxVGYwVnZ3RDh2NXZncWY0RmR2NmsvVlcyQzkzcVlxZGNTNmw5NFhhUnVmRUxBZTFRSDgyZ3o5SWpQNE1XdSs2TXZUQkU5alBJM3pOSWJYT0JldmNZRFpQWTNaZlFHZTRVcFJpbmRZSmgvVEhYaUdRM0lwZm1xei9yTnN3dSs4cXBzWTRjZGlpQmluOTRnSmpIaWlkc1FrWFMrVzZYbzVYTytSSThIM3RTUEhjejhSVE9YK1JzcDd3UDNnZGU3ZkE3VjZqeHJHNkVlQXk3aWVBV2JpNVdhQmE3aitXRHRxQzZqV2pqVUlMemNFREFYRHdYeEdlQklqV01NSTJ1aTlodDVyNkgwTnZhK2g1eHA2cnFIbk5mUmNRODgxOUZ4RHoydm9lUTA5cjZIbk5ucHVvK2MxOUx5R25tdm91WWFlMTlCYkRiM1YwRnNOdmRVUUUzNm0zMEtIbjRoZmRhNFRkK2pUMGM3L0VYL1dENHYzOVBOWTZWVTB0VlUrcnUrVVQrbnI1SE42RVJxN0Zzc3RsU3YwOWZKRnZVcXUxTCtSTCtsWmFIR2xQQ2c4V05RdkcvUnlOSHFUdFBYZFdQY04rWGQ5aC93SDE1MzZWbFdxNzhEYWQySHRKVmo3Z0RwUHoxY1hjUDFqNmkvWGI2cWZ1ZGEvSGZZOGd6ZS9FUmJZV09ZR21QQTRUSGhGdlV2VStFQjRZTVJqTUNLTzdXTlk3VFZzL3k2MmZ4ZmJ2NHZ0MzdVZTF4OWcveGkrM2tTRVlyejRoYUljYVJ2RmJKZ3lYNi9saS8xOHNaOHY5dlBGZnZjdEQyOFY4MVlyYjVYeTFqYmVDdkZXSU1PNGdXaGxOMXFKeXNXNkxSWGZqcUNOQUpwb1JoTmg1a0VGV2dnaCtWNGsyb3MwdTVDbURta01wd1BxRFZHaTFvcGlKS2h6SmVqZVEwZ01Gd1dNMG95NFJPOWdQQlZFcWhiR3RJOEkyMkpHTDM2bFg4VldYbXkxSEZ0OWlLMDJNcW9hK1FnKzh6Rkc4TGorV0Q0aFNoaGhDTHZWWWJjZ2RudVBrWVlZNlRic0ZtUzBCeGp0SjlhRmVoYzZUQ0RyeTR6RXkwaTJNWkp0akdRYitrdWd2d2c1K3d4a3U1Y3ZWMm8vREMzaHpUYmViT1ZOaHpjZFVTYk9JcHFPQjM4RXo0TG53Rkx3R2VNWkJjNEUzd0dqd1Zod0RuaEhoNjB5VU1GN2VlZ3JDak5pc0NLQjNtSllQSUhGUStocGwrakQyRnZjY1RmeG5mRnhsek4vMXRPejVLNUQvSWg0WHNacXBDeGw2UXJpZFpCNEhTUmVCNG5YUVdKMTBOWGRLc3JWNEdYd0YvQUsyQXEyQVMvWUFXckJIckFYN0FjSFFUMDREQnBBRTJobUxQM2R1QmVVMDBRWnNTMUlYQXNTeTRMRXNpQXhLa2g4TXJFcFNHd0tFcHVDeENZVGg0TEVvU0J4S0VnTUNoS0Rnc1NaSUhFbVNKd0pFbU5NVEFrU1U0TEVsQ0F4SllpdkQrTHJnL2o2SUw0K2lLOFA0dXVEK1BvZ3ZqNklQdy9pejRQNDh5QytQR2lORTJYV2VEQVJuQXNtZ2NuZ0l2UnpIcHB4MEl5RFpodzA0NkFaQjYwNGFNVkJLdzVhY2RDS2cxWWN0T0tnRlFldE9HakZRU3NPV25IUWlvTldITFRpb0JVSHJUaG94VUVyRGxweDBJcURSaHcwNHFBUkI0MDRhTVJCSXc0YWNkQ0lnMFljTk9LZ0VRZU5PR2pFUVNNT0duSFFpSU5HSERUaW9CRUhqVGhveEVFakRocHgwSWlEUmh3MDRxQVJCNDA0YU1SQkl3NGFjZENJZzBZY05PS2dFVWNVcFBqVEFuL1d3WmdXbUJhRmFURjQxQXJUT2x3dVdXSUtIdUJLSXNBTWZNVUo1SGdPdVpoREx1YVFpem5rWWc2NW1FTis1SkFmT2VSSER2bUxRNzdpU0RPQ29XQXgrQVA0Ry9nQ2ZBbVFsdmpyRUg4ZDRxOUR6SFZFSG4yVnVISG9PVkhFN0d5Uno0dGlScmNGenhnVGZjaERGNUNITGlEV0xpRFdMaURXTGlEV0xoRFNmVzdtbThOOGM1aHZEdlBOWWI0NXpEZUgrZVl3M3h6bW04TjhjNWh2RHZQTlliNDV6RGVIK2VZdzN4d3hTT1RxdUNnRTAzV0N6RFZCUnBrZ28weVF6U1hrTkIwblEwdVFvU1hNL0NMTFNwQlZKY2ltRW1SVENUS21CRmxRZ2l3b1FSYVVJRU5Ja0NFa3lCQVNaQWdKYXh4K2JUeVlDTTRGazhCa2NCSDlqY2FYL1FxUDhwRDQxWmNieEIyZGQ0ajdPei9BajUyQkgvc3hYdVlYYU9VUmZKaEhQdFVaeEhjTmxrczdtN0hmeFhKRlp4czJuQzVYZG40cFgrcmNUOHk1Z3BpVGk3ZGRUOHlaSXBzNk80azVmUm54dnhOelNvazVmWWs1ZWNTY1V1eGRqdVltWWZPL0VIUDZFM01tRVhOS3NmLzF4SndwZU9saXZQUUY2b2JPR0Y1Nm8zcTFNd0l2eHVDQi9pOHhwNUNZa3d0SFJ1T3g5N0NLUWdkaUZCZ0x6Z0cvQTArQ3hlQXA4RFJZQXRDZjJBS3F3YWRnT3pnRWpvQkc0RWUvcGFBTVZJQis0Ri9BcGVBR2NETzRBeXlCSy9oRDZRVTE2TndEMExjNkRYd2JuQUhPQW1lRG40T3JBT05SakVVeER2VWUrQno4SGZ3RGRHSWpBUlRJQVgxQVBpZ0V4WUF4V1ViR2M1SFVSbEliU1cwa3RaSFVSbEliU1cwa3RaSFVSbEliU1cwa3RaSFVSbEliU1cwa3RaSFVSbEliU1cwa3RaSFVSbEliU1cwa3RaSFVSbEliU1cwa3RiSC9KcVF0UTFvYmFXMmt0WkhXUmxvYmFXMmt0WkhXUmxvYmFXMmt0WkhXUmxvYmFXMmt0WkhXUmxvYmFXMmt0WkhXUmxvYmFXMmt0WkhXUmxvYmFXMmt0WkhXdG95YzQxajErY1c1ZWlkNTF5NVdjbjVXY241V2NuNVdjbjVXY241V2NuN3lzVjJzdXZ5c3VQeXN0dnprWkx2SXlYYXg4dkd6NHZHVGwrMWkxZU5uMWVObjFlTW5SOXNsRitpZDVHbTd5RGtiV2NuNFpSWDN1OGwzKzVNaFRxYWNTWTR3Qzh6bWVpNjRrL3E3d1FOY3J3YjB4NHJDejJyQ3owckN6eXJDendyQ3orckJ6OHJCejZyQno0ckJ6MnJCejByQnp5ckJUNjYzaTF4dkY3bmVMbks5WGVJMGZNb2dmTW9ncFBRaW5SZnB2RWpuUlRvdjBubVJ6b3RrWGlUeklwa1hpYnhJNUVVYUw5SjRrY2FMcDRvamdaZVJleG1sbDFGNkdaMlgwWGtablpmUmVSbWRsOUY1R1oyWDBYa1puWmZSZVJtZGw5RjVHWjBYdnpZSXZ6WUl2ellJdnphSU9MNkV6RmN4ejgwY2Q4UWE0cFNQT09ValR2bUlVejR4RlQ3K0JGeWg2OFJQS2FkUmR4WForWFRkZ1A5cUlJYjVpR0UrWXBpUEdPWWpodmtFY3dZUFhvY0hyOE9EMStIQjYvRGdkYXltNjFsTjE3T2FybWMxWFkvdmE4RDNOUkR6Zk1ROEh6SFBSOHp6RWZOOHhEd2ZNYzlIelBNUjgzekVQQjh4ejBmTTh4SHpmTVE4bjJUK1NPYVBaUDdJSXVBaDZ5b0hmVUYvbnAvQjZ1QXNjRFlZQTc0THZnY202QVppcFkrVmN6M3gwaWNmNU52ZmMvMHcxNC95TEpuTjJaSzVURGJYU2pZWHdpYzN5RCtTZno3clpuWUI0cXVQK09wRGMwMnNvT3ZKOExhVHArMG11enZJYXJxZTZGVEhhcnBlNG0rSXdUNFpvQXlDRUdnRkRtampuVEJsQkVSNUowNGZDY29PN3Y4SzhCM3lDL0FsME5wSDdQWXBmQWZ4MjZjS0tKRlpGYnN4b29Fb1dFZWNhQ0JPTkJEYmZjUjJIN0hkcDRncmFnckFoZ3I3RWV0OXhIb2ZzYVJCNGVmVUxlQjJzSkM2UlFCOXFNZTRKd3NscXRhUkIvaUlySFhFblFiaVRnTnhwMEd0NU5tZndDcndHcy9YZ05mQis2Q0tPbXhEbnVBalQvQ1JKL2pJRTN6a0NUN3lCQjk1Z284b1hVZVVyaU5LMXhHbDY0alNkVVRwT3FKMEhUbUVqeHpDUnc3aEkyTFhrVWY0V0NYWHMwcXVaNVZjenlxNW5sVnlQYXZrZWxiSjljVEFCbUpnQXpHd2dSallJRzRtd2g0Z3doNkF5VkdZSElYSlVaZ2NoYmxSbUJ1QnVUNlk2NE81VVpnYmhibFJtQnVGdVZFWUdvR2hFUmdhZ2FFUkdPcURvVDRZR29XaFVSZ2FoYUZSR0JxRm9WRVlHb1doVVJnYWhhRlJHQnFGb1ZFWUdvV2hVVmdZaFlVUldCaUJoUkZZR0lHRkVWZ1lnWVUrV0JpRmhSRWkvd0dZR0lXRkVWZ1loWVUrbU9jd096MHd6d2ZqV21CY0ZNWkZZWndQeGtYYzFjK2ZLVmNEUC9WUkVPZFpnbEtUWndsZ2dSSTBQaHlNQktkemZ5WVlEYTRFMDhIVjFDK2tYQVFZQXhhUFltMGYxdlpoYlI4V2ptTGhLQmFPWXVFbzFvMWkzU2pXaldMZEtOYU5ZdDJvTWlzSitzYUNVU3dZeFlKUnJCZkZlaEdzRjhGNkVhd1h3WG9SckJmQmVoR3M1OE42UHF6bnczbytNcGdEWkRBSHlHQU9rTUVjSUlNNVFBWnpnQXptQVBFL2w1VlhJWmpDZXUwcThySHB1Z3BMVm1HMUdGYUxZYlVZVm90aHRTcXNWb1htWTJnK2h1WmphRDZHNW1Ob1BvYm1xOUI2REswdlIrTXh0RjJGdHNOdUJIeUdhN0k2dEZ5SmxtTjR4UU5vT1lhV1kyaTNDbTFXb2MwcXRGbUY1cXJRVkJXYXFrSlRWVWdhUTlJWWtzYVFOSWFrTVNTTklXa01TYXVRdEFwSnE1QzBDa21YSStseUpGMk9wTXVSZERtU0xrZlM1ZUo4dUJ1QXV3RzRHNEM3QWJnYmdLOEIrQnFBcndINEdvQ3ZBWGdaZ0pjQmVCbUFsd0Y0R1lDWEFYZ1pnSmNCZUJtQWx3RjRHWUNYQVhnWmdKY0JlQm1BZXdFNEY0QnZBWmRueXlpWEF6K0lnZ1RRckp3RnNNRHA0RXd3R2x3SnBvT0ZnRlUwdkFuQW13QmNDY0NWQUZ3SndKVUFYQW5BbFFCY0NjQ1ZBRndKd0pVQVhBbkFsUUJjQ2NDVkFGd0p3SlVBOGVoNVVTVHVaRjFaekxxeXVOdDZjZ3IzWmsxNUJldHhzNjZjenBzelFXOXJ5N1c4OHhaNEc3d0QxcG05Vzk3OUVQeXo2MDRQYzdBYzlBVm1EVHFCRlVSeUhWcWNXWWMrU3QxanhOSm5LSi9sUGJQS1NLOU56VXBqRlhWbWpkcEdhZGFwY1o3M1hLdVdpQ0s4ZVlzYVRqa1M5TFoydlpyNjdQWHJZdDQzYTlnL1VOS25XZ2JRNURkZDArS1pXL0RNTFhqbUZqeHpDNTY1QmMvY2dtZHU2YmJlTGVIZXJIa0hpeUxyVkRBTWpBRGpSREZyNEdMV3dNV3NnWXRaQXhlekJpNW1EVnhzemRjYnJIdDEyR0tGYVQyaTI4d09odlc0K1pWQmxGcUxSWWxGdHMzNWI3cE5YSTBHSjRIendZVnVadElnbXluYmRadTZDUHdDL0JvOENGN20vVi9DbHlMNFV0VHQ5NElwM0NkL013aTV2eG4wdnVjZmdpY2hlQktDSnlGNEV2cG45L0RoUndoK2hPQkh5TjIvTjN2ejA3Q3YyWDgzZSsvSnJDSU9MMEtadmZjVnhzTXc5MTdDaDYraVBybkhIbkwzMkh2dXJ3L1ZvVzc3NmVtOTlPNzc1YUhVZm5ub3FEM3lyOSs3RG1IN0VMWVBZZnNRdGc5aCt4QzJEL1hZdXc2NWU5ZmpzUGQ0TUJHY0N5YUJ5ZUFpOUY2TUhlUFlNWTRkNDlneGpoM2oyRENPRGVQWU1JNE40OWd3amczajJEQXVCdVBOMjkydlpsSmU3YTZNMi9IaTdYanJkbHBKMEVxQ1ZoSjQ2M2E4ZEx2YldwelN0RmlpMi9ISzdYamxkcmYxcXltemUzaU8rMlhnZVVCdmVPTjJ2SEU3M3JnZGI5d3VGaEJicW9rdDFXSWM2NUFKZWpmcmtYWjNQVEpWMTVMLzFwTDcxakpDbXhGR0dLSHRya2ZlcEc0RDF4K1NLL2JSdGVTaXRlU2l0ZVNpdFhJNGE0MlJ3S3hUSnZEY3JGV21jajlOVjd0cmxlVDZwTjFkbnp6SSs0KzYrV1l0a3RueWRkNTdENnlIODFXOFU4djFUcTUzYzEzSFhEaEludG5JdTgyd0prQVpCQ0hRQ2h3UUJoRVEwMXZSa0kyR0l1U1V0ZVNVdGVTVXRlU1V0ZVNVdGVTU3RlU1J0ZVNSdGVTUnRXalJac1hlcklicDNXalRWaU1vV2FHeGVtOGlqNnhseldTMEd5R2ZyRldYc1Q2NlhIOUVYbGxMWGxtclpxVFdVMWZ6Zm5KTlpTd1FVZGRRLzB0eXhqbGdMblcvcHU1bTNyOEYzRXJkN1pRUFVQOGc5WTl4L1FSNGxubjlITzBzcFZ4R3VaenllY29YM055emx0eXpsdHl6bGpXYXNXWkV2Y0U0elc3U1dxTEtCL1MzWG04bEQ2MTExMktEV1dXYTlSZ3JXWGROTm95U2RSbFd0NG5CMWNUZ2FtSndOVEc0bWhoY1RReXVKZ1pYaXdLMHZCa043a0RLN1l3K29LN1hoK21wbGw0Y2VsbE9MN1ZpQkh5cGhCZUdFeVpiak1DRkNMYXZ4UGFWMkQyQ3pTdXhiUVM3UnJCckpYYXR4SjZWdEw2VjFnOWpud2g2ajZEM05uUWVRZDhSOU4yS2ZpdnArVEI2clVTblJvK1ZqQ0NFWGlMb0pJSStJcWtkdENQSUdFRytDTEpGa0NzaUt1Um0vYW84U05tZ2o4Z20vWXEwV1duOG5kNDYwVTZwUHFKR0lkTjV1bDVkb0J2Vmo3bi9HYmlPMW0vUUI5U3JlcjE2bDU0L0VPVmlFdkxaekljQTh5SE9mQWpBLzVnd21RTDhRRVliZmdmZ2RnQTViWGdkZ05jQmVCMkgxd0hrdFpIWGhzZGhlQnhIYmhzZWgrRnhIQjRIMFlFTmgyUG9vUWFPeHVCZEFNNEY0Sm54RVRGMFlMdmFuMEU1ay9wWllMYnJPMkxvdzRaWFFTd1RoRmRtcHNmZ1V4QXVtUmtmZzBOaCtCT0dPMkY0RTRRcnhzL0VzR0FBQzdhWlg3SFJYUTBjQ2NDUEFOd0l3SXVBZUVRTUYyVmlKREYvRkJnTHpnSGo5QkcwY0FRTkhCYjM4UHhlc0FBc0JQZUJSWUE0TEo0RWk4RlRnSGdzbG9CbndESysyOFE3SDRHUHdSYnFxc0duWURzNEJJNkFSbUR5ZzFKUUJpcEFQekFjTzQ0RTQ3SGhSUEF2MUYxQ3Rub3A1VlRxNTNCOUE5YzM4bXd1MS9QQXpkemZTbmtINVQzVW05L25YK2ZkTjdsZlIvMTdYRytnM0N6NnlXcEs4aUZaQTJxcFQzb1p1Q1A2eWhhZWZRWS84a1daOHBqZmVDbFBwUnhHM1Fod0d0ZmZCbWVBczhEWjRETHFmMDU1RlpqQjlVejROQXRjdzdYeEJ0ZFNHbzl3SGVVTmxMK2h6WnVBOFFpM1VYY24xM2VEKytBa09sWG9VNkZMMXdPczRQa2J0TFZXSDFKdjg4NTcxSC9BZlNVVzNzajlod0JkcTAvQmRsQURkb0xkb0E3c0F3ZUFEeHdDUjBBaitKeDIvZzcrQVRySmJjakhMQVZ5UUIrUUR3cEJNY0ErTU9jd3pEa01jdzdEbk1PVzRjeFljUkx6WkJ4emhLaVZpaUZSWVZadXcrSDVTRENlNjRsZ0t0YzNVdDREa25FZ2luVmljcDN1d0RJeDVrekM5ZjNWM05keXY1Tjc0LzhQdXZPa0hjMjN1Lzc0TXU1bmdKbXN2bVlCNDNldjRkNzQydC9nSDR4dmZaWTErVkt3SEJpZitRYWFXZ3ZlNXZrSFJtdGtZWU5ZcVEwQlE4Rnd4bnd0ODhDVG12MjJPRmVVSW9rTjl6MXczd1AzUFhEZkEvYzljTitEaERiODlzQnZEL3oyWkhrSEUvbHN1T3B4UGNRY3loc3A1MUxPQTdlQ2U3aGZJRXJSZ08xNmpIVmN1MTZEM0drRHo4MWZzVlJSVncxY0QwTDlicTdyZExQclFYeG9wUWxmMThLN3JDdmdhaEN1ZXVDcEIwMlpLR2FyeWFJMDVVMENLVzlpb3BTdFpsT2Y5Q1ROY05KNGsyWTRpVWVoL2pmZ0p0cTRsYnJicUx1VDY3dkJBOVEvUzI2OUZDd0hML0I4aGZFdzFMOUJXMnZCMjF3blBVd0FUcGJDU1ErYzlNQkpENXowd0VrUG5QVEFTUStjOU1CSkQ1ejB3RWtQblBUQVNRK2M5R0FWRTcxTTVESlJ5eGFqc1VnVHZHckdHbVpQMUkrbW05QjBFNXIybzJrL1dtNUN3MmIvMHcrdm10R3FINjAyd2F0bXROb0VyMEpFaDBhNDFReTNtdEZvRTl3S3dhMW0yVUxXbnc4bUk5Rmx4UHdaWUtiMm95ay92R3BHVTAzd3FobGVOYXViZU84QlNySlp1QldDV3lHNDFReW5tczNmSGNDcFp2VWhxNFJCMm84RWZpVHdXMmFmZHhnU05DS0JHWGtqSTI5a3hJMk0xSXl5a1ZINkdXVmphcFFOak5MUEtQMk1zakUxU2oveHpNOUlXeGxwS3lNMXYvVTNNdEpHUnVobmhJMk0wTThJL1l5d2xSSDZlNHpRendqTjZQeU1ybFdjd0doYTBXVUNYU1lZVVNzamFrV1hDWFNaWUdTdDZES0JMaFBvTWNFSVd4bGRLNk14OGJtVlhsdlJUd0w5Sk9pNUZWa1R5SnBBMWdTeUpzVDN5UjRqWkk4UnNzY0lrVE5LeGhnaFU0eVFLVWJJRkNOa2loR3l2d2laWDRTTUx1TCt6bXIyalFKY0IwRUl0QUlIaEVFRXhIaW5uWGM2dVA0citCeDhBYjRrSTFDZ0FOQXVHWjNKS3RyZDM5dklSSWlvVVRLM0NITWdRdFlXSVd1TEVFbWpSTTRvR1ZtRWpDeENOaFloZWtiSnhDSmtZaEd5clFqWlZvUnNLMEwwak1MbkNKbFZSSnlhOVR0V0I3bFBCN2xQQjdsUEJ6bFBSK3AzckE1eW5nNUcyMDZPMDBHTzA4Rm9Pc2h4T3NoeE9oaEZCM2xOQi9sTUIvbE1CL21NeVdVNnlHVTZ5R1U2eUdVNnlHVTZqdm1ibGtKZlc4bGx3cUlRRDlDUHZ0cVkvVzN5YjdEZ2NtTDh0ZUE2Y0J0WUFjaW5XU1htTXRKQ2Q1U205UTVhNzZEMURscnZvUFVPV3UrZzlRNHgvYWdkeE9SZm4wVjczVG5zN2EvSC90bGR3KzUvQ1JaMWR3bk43dUREN3Y1emEyWW4wUHpGbHRuNVMvNVZWdlNvblQvemwxaG14MitVdTJyc3Z1dVh2ZU9YL0N1cnFQdFhWdDl3dCs5ci91S3BheWN3K1JkUFVldGV5a1dzSUIraGZCUWRMV1B0WG9KVlNnUlNvdkV3R2crajhiRDVwUmF0aDkxZkhxWlJwdmQ3WHVDOUZlQkZzQks4QlA3a1dpV01WY0pZSll4VndsZ2wzT3V2RU9sOW9NMThVd1UrQVZ0NWR4dndnaDJnRnV3QmU4RitjQkRVZzhPZ0FUQlBzVlM0eHk4TzRkU2VVRmhPd1JMVFJBbFdDMk8xc0xzdmxOd1Rxc042WWF3WGRuOGh3UEp3ZURWV0RPUFRYbk4vRVloeW5kd1hDbVBOTU5ZTVk4MHcvdTYxMU41UVhkYmVVQmpyTm1MZHNQcU9LTWJDWVN3Y3hzSmhkNC9vSnI2NUN5dk5keTBleHVKaExCNU83ZXlIa3p2NzNmYUx3bGcvalBYRDZrM3Uzd0x2Yy8waDdhQXZCWk1WVEZZd1dlMENzRm5CWmdXYkZXeFdzRmtoazRMTnFzbGxUeGoyaEdGUEdQYUVZVThZOW9SaFR4ajJoTC9tbDRBdzdBbkRubkRxbDRCd0wvdE5KZFo0TUJHY0N5YUJ5ZUFpY0R6N1RhV3UzekFaTG56R2QwUmxKMW8wbWU3bGpQNWFjQjFSM0dTbXQzRzl3dldBVVpOaGloK0ppMFd4K0Zkd2lkbVhCTlBBS3JBYXZBeitBbDRCVzhFMjRBVTdRQzNZQS9hQy9lQWdxQWVIUVFOb0FzMmlXUFlIazgzZUluZ1lMQVBMelY4cmlJblNUOWtpQnNvb1pZd0lucUQ4VFA5VmFrWXZnT1ZLTVZDZFRubW00UVc0SEo1Y1NUa2RYS3YvaW1STlNEWVF5ZjZxRmxLM0NOQ1hlaHFzb080MXlqWGdkZkMrKzVkVFRVZytVREUyRlFBaDBBcmFRQVRFQU9PdzhrQUJLQUllWk1sbmhPL2grM2NRaVE0eWlxbjAvQnhyMTZoNmk5eHp2YjVVREVudC9VVGR2Wi9zZlovMFhrOFQ4YzE0eGhhaWNITFBKOHA4U1BUWTk0bW05bjJTTWUwbW5qL28vcGFSdmZlRDlkeS9uT2krLzJPaVFoMVJvWTZvVUVkVXFDTXExQkVWNm9nS2RVU0ZPcUpDSFZHaFR1UmsvUlZXMG9NVldIUDFQbXJqMU1aVGZ3VVp0NTdRRzYwbllkeGkvWW0xUkc4UWlyYzZ1QXU3ZjVHNTAyMm51eWNzNUkwOTFueFJ6cE1vVDhJOGlmQWtTbHZ2cDlwNmg3YldpbHhhU0ZBYnBzYjhyWjFEYlFzdHpuWC8rakpFYlNzMXpXNk4rU3Z1dVB2ZUV2b3VPSzVaWVVZWWNYdjVKQ1ZYbEhlalppeklNVi83ek50R2JuZVdiZXlwRVo1NmFLdU10c3BNSy9BZ0tWRlhLNmFIUFVMS1ZYaC9zMjlid1dwamhCZ3BUaE9uaTIrTE04U1o0aXp4SFhFMitlNFkxbFRmRmVlSTc0bHhZcnlZSUNheUZwa2t6aFBuaThuaUl1YmVGSEdadUVMOFZQeE1YRW1FbUNIK2pSZ3hpM1hLdmF4UkZySStXU1IrSng0UUQ0cUh4Ty9GdzZ6dUh4V1BpY2ZGRStKSnNWZzhKWjRXUzhRZnhiUGlPYkdVU1BTQ1dDRmVGQ3ZGUytKUHpPS1htY0d2aUxYaUxmRzJlRWVzSTI1c0pHNXNFcHRaNVZTeHl2bEViQkhWNGxPeFhkU0luV0kzYzdxT09iMlBPWDJBT2UxalR0dWlSVGdpTEtJaUxqNFRuNHN2eEpkQ1N5bHpaWjRza0tYU0k4dGt1YXlRZmVVSjhrUjVzaHd1UjhyVDVTaDVwdnlPSEMzSHluUGs5K1Y0T1VGT2xPZks4K1FGOGhJNVJVNlZQNVhUNUJ6NTcvSS81UFh5Qm5tam5DdC9MZjlMenBPL2tUZkovNVkzeS8rUnQ4aGI1VzN5dC9KMmVZZThTOTR0NTh0NzVMMXlnVndvRjhuNzVjUHlVZm1ZZkVJK0paZklaK1FmNWJOeXFWd3VuNWNyNUl0eXBYeEpycEt2eVRYeWRmbUdmRXUrTGQrUjYrUzc4ajM1dmx3dksrVUd1VkYrS0RmSnpmSWpXU1UvbHAvSXJiSmFicE9mU3EvY0lXdGtyZHdwZDhzOWNxL2NKL2ZMZzlJbjYrVWhlVmdla1EyeVVUWkp2MnlXdGd6Sk5ra2VLK015SWR0bGgveGMvazErSWY4aHY1UmFDYVdVcGZKVmdTcFI1YXBDOVZkRDFUQTFYSTFRSTlWb2RaNDZYMTJnTGxTVDFVWHFFdlVqZGFtNlRFMVZWNmtaYXFhNldzMVNzOVV2MUgrcXVlclg2bi9VYjlVZDZrNTFsN3BielZjTDFFSzFTUDFPUGFBZVZFK3F4ZW9QNm8vcVdmV2NXcXFXcWVYcWVmV2lXcWxXcWRYcVpiVkpiVllmcVkvVkZsV3RQbFZldFYzdFVEV3FWdTFVdTlSdXRVZlZxYjFxbjlxdkRxaUR5cWZxMVNGMVdCMVJEYXBSTlNtL2FsYTJDcWlnQ3FrVzFhb2MxYWFJZDRwc1NjVlZRcldyejlUbjZtL3E3K29MOVEvMXBlcFUyaEtXdEpSbFdUbFdybFZpbFZrVjFpQnJzRFhFT3RVYWFnMnpobHNqckpIV09HdThOZEU2MTVwa1RiWXVzdVphZDF2M1dndXRCNndIcllldFI2eEhyY2V0SjZ3bnJjWFcwOVlTNngyaCtybi9WVmZlQXlXZms2ZC9Td2k5V04rdnQrc3E3ZWpOZW8zNEJvZisrVGQ1dTl1WDkyZXUya0dIdmt0SDlDcjl2bjZCNisxRWhYSzlWVlRvUjQ2anBXWVFCRnQ3MUNlKzlzdW1iekRlMXFQNmJBRjdVdmNObVNmUDZCWWRPdXJydGlRNCttWHFJcXpYajMxVTlEWmExc2pKbzV5cmNqTVNjOTJqdjVhdmFmbVloN1oxeUpXd0lhc3VwUGRscmxka3JqWm1ybTRXZmJQZTN0RFpwcXYxVC9SLzZYSzlXLy8yYS9xN0dac25lcldZSjJsWHZkL2NkSDZnRzR6TzlQak1sNi9yUi9SeitnbndFTm9vbzZxTWI4cjA4M3FkL2todjQ0MDc5ZTM4TzlKOWU2QXUwMUg5cG52OWx0NnBkMVB1N042djlyT3l5eDdiWVBmZmcxazFlL1JobzVtVWRrb3o5VzA5cEZyby92dFJqMW83eVNVZDZQcGF0N3B0R1J1VzY5ck1tenV6dm5wQnY2TTM2SDNnWTNoUXJwZkRqWExteDM3bWJHUFdlMmNSbllYK1ZMUDZTN0d3Sk5WZmE3THZydEdtbVBNVmgxNS9qR2V4WTM1NWpGbUZuZDF2V1p2MzBtWjN6WCtUNCtqMnNwNGQwdytRYS95emZUckhlQlpMdG50MDY2NGZLWE92Mm5wdG8vdWNYOWpqcWNkdE8zRXNHK2k5N3IrTHYyck14eHIzVng5R2ttK3VLMzIrUGxOUDF0OEZwOEdvUEtyeXlPank5SS8xUEgyZmZwdzNQTHFZbVgyYmVidnpHdTVyOWZYWmZpVjVkTUlNdlFXOGttcTNJemwvWEZablJwV01BSHFsZmt5dnh3K3ZaNGFITXZwTWxib2F2Ry9tUnVldjNQdmY5Ump4TVRYVTVRTzcxZDU2REEzVVo2NzI5M2pTSVNSNThEbXAvKzc2ZUE0bExDSjNydWpqM3VWeDVvc0M4dU04VjZ0RnFiZFlVWm1WcS9HRFBlSkNCVDdheEovKzd0MkFUUDBBemhOYy96MHdWWE1pT0lsL1R6NnVjUjNmMkx0TzgxK2c5MG1kZWFrejEwWDZORWQrNml4TGpiM3JORkcwZityc09vd002VFA3T0JISlRxVFhpZ3h5K0Q0YnBqK0RQclRYRXoyUHZKVGU4bnBCY3RRQ201aWpzQWZTWDZlUmJDZVgwYWFSUEFabW9mdFJuSVg4cjRDSktHWElhMngvY2dZOWJkSE55N2p0SGU5aHJOY25aYkd5VkkwbFR1SGZQdlNVdEdNQmQzbXVSb3hXaTl3ZXpMdWVsQTZTMzNYeDc4UlUyVldUckRNYXljb3FzbzVzQy9keDU4TXBxYmJOblBpV3lXcGRLd3ppM296WWNwLzNjVWVRNXo1THM4Nk1MNGZ4RFhMSGw3Ymt0MUl3UjFKWEpnL296NXc0ZWh6Sk9XVlkxdlYwaUl2azJKTXNIWnoxMVJEM2ViYmszMHJWcUY2bFRmWlV3dHNsbVMrTzcraUwzSU5UdWpIeUpVZFkwQU41UGI0eWM4SndJc21qcnUrNmppNUw1UjMxTkMrcnpNdk1PWE1rNTFNU1I3Y3BzdVpBVXErRDZEOE5jNXlTMGVMZ1hyOC8xbUhHWUdhZG1SOXBaUHVFNDBGdi9pRWJhZlpreittZTZINGs3OU56dDdjamFZTXU1QjZYdFBLbzBweTUxZyt5SWszWDFRRGF6WjU3WDMyb3JKRW15eTRycEtVNDJZMUo1bSs4REdlN2V6RkxHSGJsdVA4SGtweXMrbHczcXVXNmRVYURwZTVNUGNXTllWOS9ITitjNkI2QmV0ZDNmdVkwMTRXcHN5UTE5cTR6TFVWT0R5bjZaRTdoU3BFOGpTd2UxMCtta2M5MzJlalNSczVST1ByZFl4OWZOeTl5TTBqSDJUNVo2TjcreVZnakcybVBZWTVDSk9zTnhuT1VJSyt4ZlZrR3laNXlSSHJtV2FrYWtXblhITWVUQjNYNXlQeVVaVlRtMzRFaWJWbVZlU2Q5bUhkUHlGem5wTFJRNmw1NXNuU1RQa3hkMG80NW1YR25qMUtlWk44bnRaTHU2eVEzNzBySzFGOTA5K3BkSHFBOGEzd21qK3VmZXRvOU5wdkR5b3d0eC9YbHlSeXBiMmJXNUtaa01FOXozWHdtTi9ORmJtYjg1cTIwYis2YllZQkhkSjhMWHhXQkREdUtlTnNneVVUUnJleDU5TzZuVHNqRW9xN25CZDNHS2pJOE4vVkpIaVcvSzNCMTAwOGNmYVJiTFhjamJyS2w1SnU1UW1UbVhQTG9tbGRkWStucVB6MEg4bE9XTjNFcWphNFdrK2o2dnJzZlNPZmMrZDNxK3FiR2tOc3RpOHYyQ2NlRDN2eERkNlQ3N25NTVpQdVQ1SDE2N29wZWtMUkJGNzRxVWhrL2ZLTHJpMDJzR1pDS09lbTRrc3gzM1RwNXY3dXI3MEVyWGJ2NlIrL3BkOS9QTjd2NUY0dEx4SS9GVlBHVDFJNytkSGMzLytyL2hkMzhWWm45L0RlL1prZC9xNmdXMjhTbndpdTJpeDNIMk5rUGZPWGVmaCtaSi9ObGdTeVVSZDl3ajMrU1BFK2VMeStRRjZaMitvOTNuOS9zOHBzOS9nWHUvdjZEOGxINXBIekczZGRQN3VWbjcrU245L0hOTHI3WncvL3FIWHl6ZjM5WU5ycDc5bWEvUHByYXIwL3UxU2QzNm52ZnAvK3FYZnJwM2ZicC8rTi9aYWUrNnYvRHZmb0pxZDM2ODZ3ZldEODBlL2IvRDVneWFjQUFBSGljN2RSSmJJeGhITWZ4My9QKzN1bFVNWlhXemtuRW9YR2djV3BDR3BwRzZRa1JEc0xFUVVpWG9YVld0VysxYTYxVklTSWhvYmFpU3UyVW92WWxxQzcycmRiYTZ2YytNeGNTaVlpamZ0TG5mZWFaK2M5TU10OFpHQUF4R0l5TmNGSlMwMGNna0JITXpVSXZ1RHBIU3d2OHVoZzRvRTU4aVBydHVUOFl6TWhGNzR5SkU0TG9sNUUxTlJOSklXOU56c2tjSDBKcVRrNmZ2a2pYbW9oaG1uVHN0UGRQdS9yczZrYWUwMXVqN09wSE5PTFFGVDJRZ0VRa1lTQ0dST2FTdzVOT2FmaTJVeEdlZHIrSGIvc0NrV3RDNURvc2NoMEp4elRpTlZkekRkZHlIZGR6QTRzWllnazNNWS9UbWM4Wm5NbFpuTTA1bk10NW5NOEZYTWhGTE9CK0x1WVNMdVV5THVjS3JtUTJDMW4wMDh5ZlRSeG1CWS93S0N0NWpDZDRrcWQ0bW1kNGx1ZFl4Zk04eEF1czVrVmU0bVhXOEFxdjhocXY4NGJiN2kvbjJ2Q20zSkxiY2tmdXlqMjVMd2ZsZ2RUS1E2bVRlbW1RUm5rc1QrU3BQSlBuOGtKZThwVzhsamZTSkcvbG5ieVhEL0pSUGttemZKWXY4bFcreVhkcFlZdXJqOHcxNGdoZHNwemxydmZua3lqeFM3UzBraGhwTFczY3RoS1FXRGVXeDZWTWZjU2pQVHFnSXpxaE03cWdHN3Fyb3M0NjdhN1B2Q2Y2cS9BVXBHazNGR05VVWo3bTZHd2VpakFJYTFHTTRTakJWb3pDTnBSaExBN2hDTEpSaVNya29ocTFtSVo2UE1KeVBFVVRDdkVCemZxdWZERU9OaHVmaWNGMkV6RHhLRFVkVFRMS3pHQ1RoanBUWUFyUW9LWkNhRlJueFhqazFZV1hLdENyTWhxTzZ0cWpuVkhOanFteGovcjNOZjdwelA4ZS8ybVBLaS8rbC9MR2FPYzFOOEEybDJLYkcyR2JHMjJiRzJlYkM5bm1wdHJtOG14eksyeHpSYmE1RXR2Y0Z0dmNEdHZjYnR2Y0FkdGN2VnFLczIzcFY1UVQ5QjdTYlY5cDJuVkZEQ2R6Q2pkeUZYZHlGMHU1bTN1NVQvZVl5UHUwai9uTnQ0aTJZOWlPamUzWWU0MG9Ub3IwcTczai9jWWFVL0FEQjdXazhBQUFlSnhqWUdhWnpxakR3TXJBd0RxTDFaaUJnVkVlUWpOZlpFaGpZbUJnQUdFSWVNREE5RCtBUVNFYXlGUUE4ZDN6ODlPQkZPLy92eHhKZjY4eU1IQWtNV2tyTURETzkyZGtZR0N4WXQwQVZzY0VBSlFGRHpZQUFIaWN6ZFRwYjFWRkdNZng3NXpudHJLMFZub3BXL0YwN3NHMktvallBcVdsRzZVV2tJSlZscTZVQXEwb1ZnTm8zS0lXRlNvaWdpc1NFZE42cXdWQldxT0NDNXFJaVVaalRQUUZ3WmhLN3puOUEweUlKb0xuSEVmYUVBMkpyNTFrNXBubnhTU2Z5Znd5Z0RBOHA2TE1pdFZ1T25XeGoxZzFwajdQTnBLNWlsUWVWeDNxUmRXdCt0V3ZLclF5clFLcjNqcHBmVzE5WXcxWTUwU0p5R2hKazJteVMzWkx0M3d2UDhycFNHZFMxRloybWIzRC9pTnJtUjZyTTdTdEhaMmpaK2w4WGFTTGRhVytYM2ZvSHQycmo4YVNZdEhZaEpnVHk0bk5qRFU3bHBQc3BEbnB6aFRIZHFZN2k1MFdweTM3MjkrL3ZCQUp3dEFQUXlOTFJkTmxSRjJxejRqT1c1TkdSRjhaMFJrajRwSm91eEh0a2JqOFlFUkVkdHJZcGZZMnU4dUkwRkU5VVd1ZGJVUjV1dkNTS0c1RVIvNGxhaHdSamZ1SHFQV2lTQm5SbjJFWS9oWjY0YW13UDR5SCs4TGFjSGs0Tjh3TXpnZjdnNzMrb2FBajJCUTBCMnVDdW1CRlVPNFArbWY5WC93Qi8yZi9qTi9uSHhzNk5kUTVWRFUwdy92SnkvVzBsK1haM2xRdjZxVjdxVjZLbCtTZWRyOXpEN3U5Ym85YjdaYTVKVzdlWUl1Ym03aVFxRHZibnFoT0xFMVVKaFlrNWlRbUo2ekJjT0JBU256VUhaRjIyVHo4bXYrcmtXeU4rYnNvTHJNcHJKR2R4WCtQNFpOQ2hDU1R5aXNZeFdqR01KWVVrNFlyU1RNNUhVYzZVY2FUd1FRbU1vbkpUQ0hUcFBscWJMSk1ZbUk0VE9NYXNza2hsMnU1anV1WnpneHVZQ1kzTW91YnlDT2YyY3hoTGdYTW81QWk1bE5NQ2FXVVVjNENLbGhJSlRkVHhTSVdzNFJiV0VvMXkxak9yZFJ3RzdlemdwV3NZalcxMUZGUEE0MDBzWVptMXRMQ091UHY1R21lNFZsZVlqOXZFT2ROZW5pYnQramxNRWQ0aDZPOFN4L0g2T2M5M3VkRFB1QTRIM0dDazN6S1ozd3VwV3lsbFRidWtuSWVvcHZOM0MwcmVZQk5zcDZkdkNacnVVODJTQ3NiZVZBYXBFa2ExVUZwb1oxSFZTZUgrSVFuMk1DOTBxd3FaSjNheWowOEpoV3M1MGwyOEtvYXJ6SWtYMmJMZkNtV0Fwbkh4OUxHRjZwSWxraU5WTWtpMlNoM1Noa1BTNkdVeUVLMnM1dW5lSTVkN0RVL3hRdnM0UlgybVJ1K3pPc2M1QURuMUNyVnlCWlZxK3BVUFkrb0p0V2dWdjhGdExmOUlBQUFBQUFxQUdZQVZ3Qm9BSXdBcWdFQkFOWUFBQUFWL21BQUZRUTZBQlFGc0FBVkJJMEFFQU1oQUFzR0dBQUNBQUFBQUhpY1haRE5TZ014RklVVFo5VFdIM0RWQ2tGSUdLcFFFdHk3bXNWTVFib1puUzV5WGZpRExkaXVmQUZoRmdwREZqN0xtZDEwMThmcFM0aW1VeTNxSmlmblhQSnhic0QwRU8zTVZweS9VODAvMy9CNlVyV0R1MXNEcnFWTXB3bjR2Y0dXQnU4cmcwRExBWUxlNE5wR0pKMTBsMk1uQi9McFlZeXcxNmdmVEJ5ZFM3RGNUdjA1c2dveGljMTFRblJoRUs0d1lZTng1QUd6YjhDc0FmajNId2JiZWlnUm5HYjJ5cUpJQk9LRWhGSXl4U0t6V0NSQ0VSbnNiRHA2ZlprZXI5dnVhdXowRFZwclFtNFJDekJ5YnUwaWhjSTU0ZndHUDM3eDE5ZWMvUS9pMzRIL2diVG1SZFpNaWtpSlZSQ3BTUG1HbEJpMDlUQzNxYStvZk1VOWpVNXFzSy9SOVhLZ3F6TmVTcGZiZWN4QzlsaTNXRG15YzlZSmxzOGtFSG00TE9zanRzbFdXeDVxeEdVdDJZMnR1aXdSYzlZTmxnbVpMN0VRaUswQUFRQUNBQWdBQXYvL0FBOTRuTnk5ZDN3VTFSWTRQdmRPMmZUc0p0bHNDdWtrZ1FUWWhDV0VEaUpOV2tCNkNUMEJxUWtDV1dyb1JYcVJUdWhGQWRrc0FVRVFSQUVGRkNJV1FBUVVVVVJBVkZDVTdONThiNW1aekN6Qjk5NzM4LzM5OC9NOVpuY21aKy9jY3U3cDUxd09ja1VjQjJxSURvN25ERndkenNHMTdPbUExc2hpR05Da0Y3MFI4STNnMWFTWGt4T2dLYWkrZzdNNkJLTkRjdmlrOXJ3YStXMnZ0SFNRWUxJRkoyVFlRR3hCZ2QrU0plQW1mL2xacDkwY3gwR3VVR2dJcmtoaG5NajVjZ21zYlJFM0o0Ymd0b0hTZ3NPcjFDRWFIVDZsYWVuQmZFSndoczFDcnovSHRlRnpIOFcxRVhMRVpxaU1LNzk1RlpVQmVKMjIrekxIQ1p0eG55TzVHQzZQdGV1UDIvVlgra3dIUVByc0xmR3BEc2xZTE5LM3hWMk5mSUpmWE9yd05oYjdhSjRFbERyOGpRNWpxU1BBNkFnaWYzWEVsRHJNcGZpSGppcWxqdEJTQnpBNndrc2QwT2lJeEowRWNiaC9DUmx4d1hING40MG4vMnptQkQ3T2pKL2p1emg0QzMzY1lVaUhjbURzZ3U2QjZsbERza0FEZlBueGFSZXVIRDNxTU9RNmFOQUZuUVhyVVM1WW53Mk9EZ0JiRVAwM0FMWE94cytlZ3FONGpJQWJWNTdHdTZYRlhFMXVKUnVoTng2VXR6SkNQM3pqcDl6RTRwdFlML2ttQWQ4a2tMSHpDZDVrdmZCb2ZKU3BkcHE4RTlpejRoRE4rSGxqY1lUbU5zSG9pRmQvVVkyMWttQXNUcTBBd1pOUUp5bTVGc2lvVXpjencyYU9Cb0Vnb1U1U1FyeGtEZ20xUkFOemlHUXdKMlRVQWsyQkxTVFVWcnN1UDJmWjRkSlBQdG1YZStBRHlPZHRXYlpxM2Z4VGx6NHVkZVFjZWlUd2VlZVhydG9QaG81ZTlGTHo5OTdhOW1uQStmUEduMDZMYTA5c21EQjJZYk9XNys3ZTlYSEFpZmQ5UC85Q0t0NjRBV1BTNlBMNzRtenhET2VQVjc4Nmw4azFKQmhReitwb1lLWEQ1L0h3ZVdWaWt2Qk5FcGtMbnlTZWpNTEhXbXlDdW5HSFZkdzZZeGhRak5XUlpDeXVxWUdMTVJiWGdackJCOWVwYTZzZEdnVkNwSVQ0cEF3MnhNYUFUUUQ0bDcrSnljQXlldFAwd2swYnA4MG9HakM0YjYrQmczcjNIZ3luNEVkRm0vQ2pnWVBZbzBFb3JpMzh1SzJ3dHZDZGR3bzdUTnUvZjFyUEtWTjZkdWc1YlZwUDE2ZlQzbmxuV2tmbFdjYytreWIzdnA4bWpFM0RPTU56ZmNydkMwZngzTVJ6YVZ4amJqYkRHd2xQZ3FUTWlBWGZXQlJVcVlKdnFwRHBTWkdxNEpFNzYxU1J5QWVYVW9kOCtOZEpJUjhCN0c4bTlyZHc5bUVPRDhBZnhRa1ZLT0ZNQ2dnbnM0YzNXME1kb2xBc3dWT0NrU0lRZ0NZQXo0bGtzQmdTa2dNQW1TR01RY0cxNjJaaXNHUkRBTWFjVUI2alVDWUdvMU1HWm5mdTZOeXc3SzNlM1RhRGplbDFSNy9TOGloY01LbmIrZkdmUDFtK1lHL2ZBNjNRSU5FQXJlT3k5c1kxZmFtNFFmcHIvWExIOEpGRGR2WW8ycmR0Y3UrWkwwMUNNYTBkUTZaZjZYRlZYTnl4NjlkTys2a2g3bVp0WGdhM1JZTlF0ZC9hWmxOMkN6V2JMK2swdSthZ2VsbkRacko5SnpUbmJsT2FGY0ZWRUVCQ3NXQUZ6V09FNm5aU0c2OWNzUnQ2Q0h3K3BiOWRoTkxoS0trWForSzhPWXlKbUNoaFVDT1hHUU1rYURJYmcvQ3drempUSWhDNlY0cFlmdlhxOGdocFAzb0EyNE1Sc05rZzhNcFE5eC9vVUFnNjVQNWpSS3Noc0E0WVI5c01RdW5nRDQ4MmdaSERFMWczeUpSaGhNbVp0bERPQlA1QUQvWkpFY3V1M1ZnVUliME5RbUZqdE1qOTZaQld1VEFJdEE4QnIwQnpicXRCN2cvUW03VE5LRGlWYjR2cFp3RFhYRE5HakNOTy8wQ0JyS0svMVFrRmYvSU5XcDErL3BDaUJmUWpEd3lsVG04L3lna3d6ZlFsOURBeFUrUnRmS0pGRERiNGdtVHdHaXFKQmUyRllWNmdSUnc2ZUt2YjE1OTI0MzhlbVRNWmpFVUxDM05lUjk4MEJlbm84OGFrSCsyNEZVSzZjQmh6aDBnTzB6Y0hSMG16cENWTmxPQ2E0MHdKSmt4dVRUWTRBUnhETFNlaWpzQTVFZDdKUTlIZ2RoNjRUTnJxZ2hBSTVJN2pkVE55ZUR3Vi9DVXRQWkd1RmdnYy9tckxnaUQwQUZoMlkvaDAyQUFhNFdhOGE0STRQTXBpb01OYS9ESm9SSEhnRm15UXc5RTV3eHdOcEhFN01MeU1GeHllTTg1TGp4ZHhoQSttTFZpd2cvMG11bndXL0lYeTFtQ09NRTR0YzAxTHR5UUEyOEpSY01ESXFWSk5qdksxZVhqL0pzaTByU0Y3aXc4RzkxRjJMeVZ1NUpVK3htS1Rub0NINmJwdmhBbnhNQndZZzJ5MWcwekpqUHFZS0MzS0VCS2VYTHY2OU1tMWEzL1pIYnQzdjFPOGE5Y0JtSUYrUXFVZ0hZU0RsdmhmYlhRUjNRMzU3dmZmdjBOdjN2enp5UzAybHVQbC84QmRZZ21lMzhZYVRxNzBUSjBNek1rRlpUNktlUTExaGJ5SWtTWXRYVXd3aVJtSmNKY2RMUUcvR01RR3FWMTcwdmFIWTU1dXdtT1A0TEpZK3liY3BNbXpmUjJqZ3FWTzNzUVJWRFFaaTcwMWZ6QVpIWDZsVGd0bm9tK3NEaktBUWxETUNjbEpNalV5QUV1Y1lITFp3WTNabzlZdDJyVnZEQlQvdW56ODlwcDVhQXlFdi9hRlVXK2U2enQveDVIMTBtSFgxY1AycDJ0UkE1SDBjM0Q1ZmY0SjdtY0tsOC82R1lpN0ZxajBNeExmUkZKcEtUS1FTVXZPL2h6SWRscnh4UkZvTERab2VobEloQjRIWnl4TzBaQlJjd29kVUtUUkVWdUtyMW9TaTllVkxPQno0NkFNTnlHK3FzSnRNVVFxQUNzWGJ0NnhmdTJpZzNsUS9QdkVSM2VuajVzL3Irek1TZlNyQ1BOT3Jkdnd6dUczRnZMaG02Zk8zN1p6bnZUMjdhOVBERDFVSS9ub3RBOXZYanNsTFhSc1hiMXVKY0hIbG5oTjJtSDg5ZUVDdVZjcWtVSlUyUkFJVkVvQTFtS29HYUJFSlNmZlVxY1g5SlZGRVgreW43RzRSUGN6c0lFNFU3S0JIM3JuVG9HN0c5dzh5ejBTUmtrMjhGVU9XZ2J5V3ZBdVZ5TGZCSTVpK1BjVzNodGV1Qzh4M0JEV0U0QmZEcFNlQk9DYkFJSi93RmpNYTZiVEt3Q1FOM3Rac1VqbkZHTzh5QTJXOG9LSnJGY2NxdW1ybDdHNGluYXFJd25WNFp1QXpMcEI1aEM4bTVJMHM0dm4zL0IrWi9pUmUzdmR6Tm41NzkyNWNiUGtOeEdPMkwxdzI5YXR5eGV0aklNcithZ3g3bit3M01PWGMxZHZvTC9QblpGV2Jqejkzdll6dlhyVGZiNFdqeVdHNG5veTExbERUWlRSaE9DYkVNcWxkUmpqREFpaHlCRmdMWTdVZEQzRVdCeXZ3NUxhb1JaRExjeGRwU2lNOTVnQzBBRnc0YUFPRjR4N2JsYUdBZWUxVzFFL3BuNWV4MjFmTlhvdi8vU2RQMCtmd3lKMjlGc1REOFY5c0hyRmdiZkZNL0d4ZzJLalhaL042TmdQL1hIdEN2b1oxQUFpR09NQ1RkenJwdzBlOGZrZlArNDg4RFZabXc0WVQ4amErSEZXTmhwZlBBQmZUeXh4K09wM0tVZHd3UWZ3aG9UTUlJNUkwNExYZzJjcHZuYmZGT0QxamVzVWYweHNpMzUybjBRTEprMENZMkVQWU1nbE1zNFFQSGYrZU80c1dLT3djcSt4OTVueEs4eksreWlLRXF5czZXMG0wMVVUNzhHYVpBL2lpM2Jpbkh4a1RjTFlBbXRHeWtKeG5LWjNabU54c201VzVaMG00SjFHcEJaRnJ1RVZ3WmZJdWRydmQ5NTRmYzVXOU96aVplUXVtdlA2dklmdkgvODk2NVBWYTA5L3VISHQ2ZXJGcytmdDJ6OS96anRDL1FuRjFhcWZuSDc2aTh0blpweXNYczB4NFhqcDU2N0ZiK3pmLzhiU2JkdjUxdE4yYjVrelk4TUdqRE85TU4zNVVjYVpqcFhvUEFyT0ZIT2FFUnBDS0JNMzZCSEczd05oRW9tSVNzUXhtRkdIdy9nU0RrSTRqUEhKbWRHQXlHWVp5cWhBK2E3VEdRZEhmL3lZS3ovK0JVSlB2dW00cVhWb2l6bERaeDVJUExSaDhidjdPdDI4dEtMdkVCQnkvUVpJUVEvUk05VEZqZTVGeHd5SnJRTHV6Qm0wL3RMMUovdjMzT2JLeTduMUdHa1NoSHBHTEF3OTVrd0d6bFQrbUY5RitMWXFyL29SQnNrUjJPR1lyeWNMRFl6SkdPb3B2OW9rY1lFV1RvR2x6RlNHcFhnNGlaL1BsMkpKS1pzN2FBQ1NrT29jSTRGOHAxWEN5MytMWFByVGl3RmZ4aGp3SDI2UmIxWnk4U1lYSUJtWURPc1FTeDFDYVVtQ1lCTmd2c05nSkRxcWQybEpEZTlHM2pBZjQ0TEJiQUZtekZiTUlIN2tTSmpyT3NNM2hNMnJTRlhRazJsZzhrQXdhUnJqNTIrQ1hmd1ZmaS9WclJ0eHVIayt0Y1FJWWdITWRob0J5Q2ZFU2tNdm5VYlNWM3pKOWxCWm1UeENCQ0QraXVzRTM1ejg0MThhN2k0YmpzYzhCWS81bkRKbUNIZ3lab2piNlEvSjBNamxGcmw0NHd2UllMSDJ5K0dCNE81QURNT1RpZURKREpGdnQvQUZ5eEo0NUhqOEpRbWlUY1F3Qmg1U0xocWNRVWVjbVpFOGhlL2dPZ2p0STBmeTNTYWp1UVBSbkNrZ0tGS0t3dVB0aURkb0c0cWowVnlQU3JpNHloMGpJZ2xyZGtSWU1RT1BlREVEanpESnZEQktZMjdBTkZuaDVnWU5GOFRLQTdWQ1RBUXAyU01IejU4MkFiTVF5SCs5NitDRk9aT2FSQm9YTGdTclpnM3RscmRtM1BSRkM4WkxPMCtjM3pmdjg3RVpmUWVna2V2cFdnMUZEYVdmeFVXY2pYdVpHODlocnU1SXR6cFNyVHFLb2hQQ25KSTNZZkZhRmRLUmJpeU8xdHltR291cmFtNHhoY25VOGYvaWw3UnFKVllTeUs2amVoRm1PelpDeG0yOFJJZ0pKcEJ4c1J3UHVUajgzWUloWXJsZytnaXdQemNDbWNHVTRrdFhmTDYrMlBFMVU4YkczRm56Z3kwUDl2UWIyeEx5dFgwNlpTN1o2UnVFSEdnMWVoLzFOUVdEVWFCeno1SW1NYzB1OWtlejBZRGdJUEFWS0FEendJS3lJOGF1QTdvdnJnT3NzUjNUNWpvZ3VJbyt6TzB6WU9Cdlp4Q3daV1JDOTRlekIvenpNWmdERHFEcWFEcWFnMnJXU0doWFBRMDhCZzZ3QjBvb3l2MTB3NUh1WTdGK0JXTXRFYit5ZlJDTCtjTXR6QjhNV05KdnBkYzRkUGFhaXYxUGhRb295RUtGbDJiV0JHWXFJbFlZTEQ4a2dEaVF3SC9temxrOUJWYlBoNGxUWEU5aGUzUlRBcXZSY05IeHJCUGVFQ0VjMVkxUDRqN01venFQQmZjbnV4SVpRcEV4bldFY0ZSckNyRTVyR0dZWmdWcDVJakNNaW5YR1lxUFdwR1FzanRGdVY1c3BUaXVhQVh4TDVZWkUrVFB1SkhqckIzZmhxRG03M0YraTZXRDYxaU83TjZOUklLdG8veEVIdWlnNlRuNlF0eXMyN1B6c2p5N0RFKzdkbTVmTzJwT3pjTjRiQ3ltTm00MzUzejY4eDZLNDF2L09hNGxCQzNQY1lOM2M2ZVJuUEpWUlpDb3RFbVpxSEZZbU1mRVhzSTVLTUFsR2daQWdnbHJDMnpBWS9mclRZL1ExU0huOE16QUd3N3l3YzBkTzNyMTc4c2g1Qy9oWXVsNEcrZ1BMUXhBS0J2NTFTenIwQWJwNjk5RXY2TnJ4WTNqZHlaeC9odWZjRytzL0RmOWx4c2tFYWcxeWVIcDlQZVl6bHNNS05CZEhwcEpyakNXWmhKTmdOL0FGZmRFTzlDZldYZEt1QWd2NitZcm9RQnZSdldQb1oxUWt0aTJMQkxYdW5yZ0RhdEY1STMzcGhmdml5M1d2eEM2aVNySStnc1FzUlU2ckQxNTdvSjg5blhScjFPSWx3VWdUVVZUcFAvNngrMlUrd1pYTHYrbTZEZCtIcDl3N2NrUkhydnVHM0k4QmRFNkcvTXRPd0NLendBUlhaMzh2a0YwUzQyWDF3c1E0eXd2a2x4UjZMZlhDSE1TS256c0w4UVBQVGtvZXZVcVErL1RNM2FpQTMrcjZHcDZHYjd1N2svNThqUHV6QXVQVFJZeFBzVnkvZjljNEhZR2xSTzhNMHV1ZDRack5FY1A3TUFOYVNXQk1UQXpNTG83V1NSa1V5N0JTcXNVeXJKVlNMQ1BNVGJpWWp0eG5FRG9HTXY2NkQ3ek5jRXpFaDhkUFAwS2ZMYitRaUthQ3N2MnRKNFBlSUJpdmVnRG9ldis0dE9JUXVuTVRQYjZEdnUyY0JxYmt5bk43ajY3eG1FcldXRGN3RmZWMHErL0ZWbCtaOVFOZUo4bE0zeUxmdGJOT2xrR3JaaERGMzBRbUdpT3F5U2JjSzNDZExpamdHeFhBSXZjZzBlSHVDdmN4SGVZYXZuU205b0NvU2l6dFNwZG9hemJRMlc3SG9FeXV3YkpmTWI0eEt2SzFUbHVnaWpoZEkySklML2JYYTR3bWFvbFV0UmUrdnYzaDhjK0lGcmhuNDV4OW9xUHM0Y2Yzdi94VUt0cCthQzJuN3BOZktaM01xUVEvdmZDTlY2VmtXOUhBbkJMRFhNbktoQzBpZTVVVVNrc2xxTnROVGw4Z1Via0NKTkI1c3dHYnhSc1lFZ0Q2cEtEZ1k5aDRIblR2Z25QZ0VyamYzUVZQNFNCWUpMcnJ1K05FdFk4RzNFZVJxLzR2ZTBnckNXUDBJNXZBQmpKaHFldUlQUWR2UjlhT2xJYS9tYmd1bGN5cnpwU3NUcktLU2NvTjFmL2xMVUtrS3lLNllHRXhMZDBiOHljYkhseHdNbVpUaG1EOERmU0ZGZ21HRnhYNFNPNGZ1cmp2U0w0Rm1Fa2hFV0pHTlF0T2hjK1E0QUx1K2U2cGRPSFpPQjlSZkg3NS93cWZpU1FMYVplOFNnbFdBUU9aYTVDSmNmUlJnZXVNWkxmekRhVUM0UTRvaThLWUVBMkU3eG0vbm9KcHdrLy9UK3hRUkVZaGpJVjhKTmVCS2w4SnloQitRaGVRcTV4RGwwQWE0SUFBNmhZOCtyTDA1M3VsWHoyRUE5RlBhQWZvQ3lJZWduRFFEMjFEZCtFREVJdStlL0RvVi9RZGlIbkV5YnhsRmJWTkJDdFdUTjJDVVVaRExUR0FaNVlZTFU4aFhRM1NkWldRU2NxMEs3ZzA3aEw0ODhleXNoL1JUREN0NUZESklUUVRacnUzaTQ1N0gzejRjKzY3Q3hjZHBYTlZRd3pBY3hYTXhTbjlNT0pYRzUvVFJubHZJK21IMFZoc0FUcVpVRWNsUVFnMFdBeUpWTVI3MGNTTnlubldCZjNkY0ZhYkY4emVEdlJQbHdmdC9vbUsrdGNweEgwL2p1ZXdWRHlBNWZVRWhTdFdPb2YwSmdqZkJPa25WS3RNKzNCVWkrWTlqUkhxdkdKaENBOGgxR0xHbEo5NlJDcm0yVllBSHY3eWJPNmtlUVd4aVpNU28vZHZRTVBBMERPSEQ3Mkwzb0FyM0tQRkE1K2RHZmR1U3Z5QjJRdGFqSXdQcXpxejFaeTVHM0kzejF1MkFlK1IvaGhYN1hqK2t4V1pUbWVoaXNJM1VYVDJveFJ2V0FBMU1udWdyWFpKb295TytGSjhMVTZzek9OVkZYTXZUM2VYb0xHK0Naenp4cU8vUVBEVjcwR0l3SSsrVkh6Z3pPRmI5LzlFUDl6NEJoMFQ0V2kwYi85WElLZGdUWU5HSDJ6ZmZmbFppYlRpK01aeG8xZldhL1RwN25jdVhyOHN2YjFqTGQzN05mSGFMS1V5czdXU3ZhL3V3T2VjbXdyTHgveDBLZksxSTE5aGtOajIyV0d4YmE1c3g2WStJa0x6NmxaQzgzVDBYU0VqSGl6RnhHd2dtR2d6bG1JU2pxSWJ2OXhGdCszZkZwZmNGaDJ1eEY5ZDdvZjhkVmZpZXhmT0grT3ZzL2NTSGVBU2xYdHEvaWUrb21nQWREU0pGbHNtRmZSdHNHZVVGQVVPelhSL24rLytmdVpmQXdjSzd6M3JST2w0ZlV6SGlaM2RyTkJ4WGRzNjBrWE5KRG92cWlkK08veU1Ea01wSWVVQ2tYbndnR01BNllHbEthRDlTRTR3a042QTkydEltYUJPUHFpVElWbUJZUko2SXg4ZFRaSVMwZUd4NkkzSllPTXQ4SjBRVXZiZ2UvTHhySk9Rdlc1ZDJYYUZuemZFYytHZ2RMMVRKVkt4cnI4cUtTYzNCbnhqb0g1dGc0K016ZFJsNHVEcFZXSk14eHNrMFAvYjREaXdZVG1xQXA0c1JkMVE5K1hnQ1lwY3pqZUhvOTIxM2RGd3Buc2F2QTB2MHY3RTRmNjhoL3ZqeGFWWDBoLzYxa3JDQVF5VWZ4TXVSMWliRFk0RUh5MTBQeXh3Lzc0UXp1T3J1NGE0SDhCSS9rM1Nmbi9jL2dpNjlyTDJwMnV5TW43dEZDQTFkUnAwNk8zMEZ0bExNekV6enlCR0VmT3YvTlN5SjN4djF5bis4NXljdnNLdnVUM3crN2FqVDhCRGFUcmVPOGtjZmhkeEIrR0dPTDJZckpQZlNCQURFWkxCdzh1WDBXSFFWb3I0SnlUWGNBUzNsVlkraXhjVkh3NjA2clpNV25vd3hvaTA4WERBZU5IeHp4ZDBMam44N25iMDNWV3B6NGUzRmd0NjFjYWdmYkdKMkhXd2xBRGFvVU5mZkNGTi83dE5ydlNBeW56d0duVFJPVXZ3bEJYVnlBbVJCaVVZU09RRVZZWjVqSnVueG9IVTNpQmwzT2xvS1JvM2NjVmRIZHdaUHB6aEhTamZ3SStsMm5BVlRrZEc5S0tTU0N4TlkxMUwrZnljSFBxN2JPRTk4SkY0bWhPNGFnNUtqcXpPUXVMUVVEMDlKWnVGQXdMTVBod294QWhXZ2M4bUU4cG4yc0JINDMrSDYvR1BSWkhaV0xBYys0blFFZE9DVkc0RzYwRTQ3a0c0WDJWQ2pHb0g0S1Z3Nm84T2wyVFhwTlVmaTVTeC9tbitNTjhScmlQbHpoQi94UXNkcHlQd2pxb2t4a05QMGVNd09aZWQwRlViS3Y0aEsyQVdKVXpiTEluRStNbklQTi9PejZmUkoxT0xEZ0QrMjBkdnpwMjZjelNVN3BVYy9NWS8wUDFzeHRrYXYyLy9hR0ptcCtyZDh2WXNYbDB5ZDl6c2FYMkFOUEhrNGJmZEQrcVB6T2cyc2QvdGhVTjdqbUd5MVNaTWZ5VXBETlBmR0c2d2htT0ZhT1ZvUDQ4TjcyRjQ0b24zM2VrYndETjNSckZaejh5cWVBZ1V4S3BrSUVJMjlRYVlFb2c0SVJsTTBkU2RKRWpmbmlyWWwrRS8xRjUzejdpUHZwMjRaZFBVZFluVk5rL1lWQVRLSDZOYi9YdHRsOExjOWo2RDBUbmt2Z1Q0S1FPUnBkK1luMDlUdkJpSTEvTXp2SjVSWEF1Tkw4eFBTOU05a012aFJZbFZvTkVSUXE1YXZrdnQwQmsyU3lqV1Z5QVdFSWdCVEdHMFJIQ0Exb0xEdzZINGJNZU4zLys0N253b3dCRUhDdC9admF2VC9JblM2dlBBK212S0E1QjJlYTgwYzhNLzc2ZDg4RGVkNnpHNGYxL0ljejFBUTNsQ3REUHE1eUdvZVdnejJybisxNGtPTmxLVEhaNW1GdHNBNWVpUFRCUFRkTWRjUDUyL0s3Tmd1RS9kdDEvLzhMcDlVOUc0RGFuVlYwOHMyZ3hEQUE4eUIvU0VNLy81ZVZQM3ZpRHU4ZW1maC9VRnJuN2o4WXpUY2ZURjR5akY4eHlLeDlGVk13N1BmZVAwNWFnQjI5ZnFhYUV5NkVVY1g0KytpL0hVcUVJalYrS1kvNEtZR1htTUpwWTQ0aXFxY3dFOUJyNG5QcjdqRmo0c3lpdXFaMnQ4Yk5tY2trQUlKKzB5Z3hvL1pmNE1hcnN1NTBhOSsxZVRCcTgyYThlN0w2d1RveGVmSURqU0hBL2dvRlNUczNEek9lS0hlMjdlZy9GTjhITVVJTmlvTTJ2QVV1Y0Fvbm4vUmk1NVdQMG1sby9zRXF0WFU2S1VwNUVIVzhnRGg5Y0h4RTdDZVlHeHhLVVhxRzNDU0dLNlFrdUpPU2todzhhOE42cWpqR2lIZng0OHVIMWxYSXVFd0RCYi9LQmhBQ0xFWHgxVXROM3A0ejFZTWt6Skt4cmtxc2IyOEJqVWp2K2E0bjBxTjYyUzlkQ05qd29aUHZKTkJMNkpZSGhGN2Q1K09nT2QweEpCdDNTRW5ueFpLUG5DdWx4aUtjRzZhcFZnWGFhczV4T2ZqYTNDbmVPQmdUZk92TDRuTXlEbjdzV09qdVl4elpaMEx0cWF1U2Z2b3h2MkxSZ1hVNUxYVEN6YXhuQXhwKy8rc2k4Ly95TXBMaWMyN3ZDMithLzJBdkYvZkhSdmVEYjRxNThkdVpqTVVJVFp5RGQ0YndWekhiZ0srYW5TbmFXallsUTVvZ0lFYjVRVkJqOGR2U0pFQ3RQZkJCTXo4Vk9OTmJSdWlYM3Z1L2FGa3lidlRNWks2NHlCSTcrODVjNkJteHpyWm94d0Uyb0t1ZjI0VTFYeE4rWnJxZUFnSVZvcDR6azBJNjRlTmRadG1RaXltZkdGSUFpb1dvRC9FeHFBdW52d21wY3ZSdTFBS200L0VJKzRUU1VqcGszNmFhVWt2T1k2bFRQSTZEQlZ2TXRFM2dWMHE1WmhvaDZNMUMxTG9qT2kvSTMxekwyRzVKTWVsSTNhZmNqSE8wZjBtV3dYVm9JR08rajhiOGJ6VCtLVUFoU0tvTVlwcWJUWHowUEE4clRUZURFN3pYOWxsdG42aHQwK0RheFlCRkVXdU1rdmdJSHUzNlV3Vno5d1drUmg3aU1pa3k4cTFrQnIzd3J4bUhUWnZvV25GNFBTMzJHTlJ5ckUreWxSaWFsNGZqS1ZHeW9jKzNtTVJiZTE2STBhQlFraWlEWEthUkRvZHZQUjI4TmpxUFdiSXB6RkErMUM5Q2dJZU44NisrMVRkbGROUHpSei8zSDc0bWtMMXdhQmlVdW5GcjRaUFZGb2NMRC9NUHZrc1ROKyt0MjlBRTc4Wk9jNzh3MFJrcnNBVGp6OTFveFJiaStoZ2JKZnJ1RXhxdnZseFdOVUdHZUZBNDNGV0ZCdm1PQnA0ZlBzT2VtdGwyK2Q0b21PSS9hRjA2ZHRUckFMRGQ0Zk11cktIZmNvdU9LOTlYTkd1LzFKandnZEkvR0NZYmhQeE01VGozdCs0eXAycm44MThnUVR2c0ZGVVo4eGh5a09NVkpnWmtKTUZtWXNCbDI5QmlSVWR2VWI5TXgrNHUzZEp6L1lzK2NFclBtSUJCazlpdnNOWFFMcHZ4MHZKK0ZGY1VjSndUM0taQ1EwUUJCeHZ6eGxKTjI2NjZpTGo1YnUvTi9LU0FUakxaWEtTT0szcDhidXJXdlBDYXk3Rjh0STloMUZFOWNrVmQ4d2J0TjJLaU4xNytTK0pINnpwL2NnSWlOZEJNTHJmZDEvOThwOThKSE1Ld2J3RitXeERQaFB2SUtPMHVlNW5mcS95aUNaeE96NEFobGt6TzY2ZnNNS01uZU5wakpJM3JvYTFkZThyc2dnMmQwM1AwdUN0Yks2RWhua2ZrNFBHTlFySDVWZFV1ZzkzSUxIWWVTYVZUSUtHb3FnM0tpMlVuOGRFM2Y2K0xNUU1KQXMwM1dMbWUwOXVLeFgvdklZKzJ1QjFxSlJsdFFBTExNVmpuR2JoUVlsZmtQeURBS2pFY093RExRSnZ6K1pHMWtKUmxScTUzRkdCV0Jwd1E5Zi9odUxqek00SGdPK3lPeFRWeU9OcWxIT3pMQk9jWVJQbXJyOXc2T2Y3M3YzYXhHT1dUTjkxcXo4dDA1OWNMM2t6UGNTSEcwb3RzOWNEWUxiajYyYThzYTBLWHNQelpkNnpjNXYzMjVRWXVxYjArZnRQajVUR2o5OExCMWpVdmw5bUM5bVlWbXBuMFlQVjhaSWcxeVVHOVhxREl3YWhWQWYvVVFFYkMrOUdoUmNpZ1Z2d25kSURKWXE1eEVkaUxBOEUrajk2NjhkbWtWbFZnMks3cDQ2dHZEWU1URUwzUi9rYmpxOGx5ajE4ZzlZdGhHZUdnVE10Sy9yOFhwY3dZUWttR3RiQ1Q1UUxxL2NxSllWM1E1bC9GL1AvQlBsdnNpbXBVekNpZm5CZFJ6MnZSL2E1MDJadnkzV1ByeTQvOUNmbjhEWDNRdlA3cHMwZ29kbFozRmZhbURhK2hIdWk5NjI1RmNaTDlUWmxvQnFXd0tYRTZRa2tEUUY1UXhBUTZhQXdNSkNQclhzTEtPVGdIdUo0OFRUK0Vadlg2cVVKVkg3a2s3MCs4LzJKZHlMWUZzd3ZUSWRucnEyNTFXWGJEOE4vYW1PVlBQTUZIUW05emVybFBaZ0tEbzdCZlEvZFFwZWR5ZWVQUXV2bDUyRmQ0NGRjMWVoSFFWY2JUd1BKZmk3cjlKUEhmN28rbG01WFlueklmcURVNkxtSmF4NEV4dU0wNXVURkV1UGFsb0NmNERFSldnNW1MWUlmWW8rWFFJSzBmTEZjRHA0ei8zUWZRMThobXd3R1FhenVVdkFzdko1T25lTksrRXd1dW1pQytWRFdKMVhDRUdOUUQyZnc3SUlGV3NWY1luYTR6NVBra0RydVNnbFplNE1jNk9BQUw4TXY0Nzk0dXFqZm5OQTRneCtkVm40NlBYZTRoQW9qdW14UXFoQis5TWJ6OUYraWl1dEtzSGJ5bTFSSFB6dmJGSHdwR3MvWE9TZXp3Zm01UFRrSncvdGhkL1hBbzJFNjZYR1hEU1hSS05LT0t2VGl3dGtYa1pkY0ovRjRNV29vMndlejZDSkEzUi9Sb0VLOHptYyt1NkcvQWtUOGplOEcxRTR2azkyZHArQzZXaGs1c08zYjA5YU1HenU1RHQ3SDJWbVZUKy85TTdvYlluSjIwZmRYbm9tQmZmQmlmNEFsaGZHSVJQYkY3RGs1S0EvcEJOc3pieHhuL3RyK2h4dGRZWkcwejZIV3JXRTAybXdoTExnb0NhQTlwVjFuYXdQNmF2TlREVjN5ZUJkYU84M2VIQy84WVVSaHpmbUZSVGtiWGdYSFU4NXMvUjIzcmFxQ2R2eTd5dzdWejByODlIZU81UG1EVnN3NmZiYkR6TkpINWFDM2NJOVBwZ0x4MWp0OUE3bFV4MmhldUxtVjRyM0Z5SHNXajAzdk5RUmJxWEJlZ1JQcUc1blRtYWFuc3pLNzIyYjJITjV6MmFqNm1XOU5yQm9jbytWdlpxT3FOOWhKTHd6NDNqcnJMb1pFNGNFempyY3RuMTkyL1JCbUhjdlIyK0FHSXdyUktkSVVXZE9DVkJ6OG5SamtLQjhTUlAxck1tSUNySGJmWmNzUVcvd2wwRVNzU1ZPS3ZmbGZ4S1R1QVJ1T1BjOFNhZUJISjcyRWw5cUwvR2xFV2krbWxRZWg1bm1LdUZyaVBaUkJIbFVIRldaVllXazVDUlJ3NG8rWjRmYVZ0b1VIQjRCaFMvZnRKLzQ3T0w3OXFJTFBGOWhYVm53WWRBUGR5d2crWHJLTlpBYzl1MTEwNmViVkNzTG9MbFlhVFRuUkpiZGRSWjJoZHpxYktCZXBjNDRpZXh3UjV6VmFZMGpFWGx4eEVrY3R6UU9abXZkUnc3L1VrY2NEV1FKb1JsWUlaNXltd1VqRjlsK3RpWWdJeG5QT0svbjA4RnhackRBWUt2RkExY1huMWF0REpjdStIN3BQSGFjNS9NVzJLY3U5d1Vmd3BtT0VSODJ5OGtKL01udXlBWFZQcjEzNlIxcDFRTEhablExbDhodW84cC9GUHNMdjlOSTB5VE95WnN4RnZLNnVGQXkyeldmNTJESmhtUVdJSnFabkNuckY1a1dGZzFrc0Jpd3FJd2w1b3c2UkdBV1JuUTZOM3JNdWF3TjNUWTNhdGF5Mlo1dXV6dCtPR0w0aDFsdmQ5L2JwRVd6QnR1N2wvME5Jajg1Q3lMUmoyYy9RVC9PYVp1VjlVcFI5NjJkVDQvTysvVFZ2VDNlZnZtVmRpL3Y3M25nMVhOalJwN3V0S01Ibkh3RlhRYTFybndGYXFJdlZEL1NDcnozUTdteGJIMUM4WktFNmp4OG51NFFaMkF3bityay9NamVMZ2tNamdtRzJZNWdpb2ZCK3ZnUHFkUVpHMGdEMndsSHc5SkdnT2FQUHJJTEhLK1BXYzNnSVA4RE50Z2Y3Rm1JNm9QWFVSK3dFL1VwWUFsd1lDeXF2eERlZ0YrNFRia0hjdEY3b0JYK2dJL3dPbXhXNlplQkM5UHZRNUswQWtRK0ZkTWdreTJjN0x6TmRyc2QvY0h6TGpmL0NmeExqdTB6Q2YweGp0cTRsdHdDbG1taTZJams5eGFhRlhjNHlWTFgwc3JDWnpzc3h1TEcyakJoUytNWHVRNmQ2VFE5N25EMTlQcnByNlRqbjZZYmkrdG8vaHhWSjUxbHp6bXFsVDZmUTZlTjNZZEtWTGFjVmllN0dqMWt6c1JhSUpsbVNlSHZGaG9GS2ZTZk5McGZ2L0t2djBJM1JaaDN1Mmo3MGZWWEh2OHlmbmp2bm9DN2N2TWZBZVlkMzduZnVlcjdwN2ZkZjFackhaTTN0dWhKZkpPbzEyZThEUTRNV2h4WGUvR0lYU2MrKzFhQys0c1dqeGx1Yjl5NGVQZWdKZkhwaTEvYmV2cldlV254OFNXangwNW8rdEx1T2Q1bXY0QUozY2ROYU9FVDVPMC92dXZJcVV4LzNDWUc4NG55dW1UU3BCc3JoNlYvSXR1SW1oelJadDRrL21PemRFQVNzcHQ1WjBuOXBURlNvU1RrT3lDUmZ2QzJGY25XVGR5L0g2Vys4NDRZdkduVEp0emlpUEw3NGwvaWFTNktxODVsa0loTXNtUTE4WkxWVk5EVmhtOXNoTGJFYVdJc2ErTHRxY2s2RWVLU3FkSnNkZm9teHpIVHFOUG9TMHdDeGNHYVg1SEFPTTJ2b2dSZnhvcXBNVHFwTWRDUkZjcmE4Rm9sTXU4OHZmS2E3MEl2S094Y3VlYnc0VFVyZHdtd3oramhvNmRNSGpOaXBPdERNQW9JQUlBeGFBVkN5SVZXZGdORm9CcElCa1ZvSVBvR1hVV0RZRmRwZGRGWDd4VHN1MUwwcHBRL2V2Y00rK3lkSThmTlFmZFFJWmdCU01oeElacUI3b09Hd0lFNm9UUG9OTW1ESW5sRHNBVCtUV080VWptN3hxOUNrRnVxRVM2SDQ4U1N5R0t1bEVnZ3NrdkZqMzdnZlg5NHBOOFV2MFYrZkxhenZSOTQzcW5pVjVsVHhjOVluT1NSNmFmbTlQMG5kd3BjNE8wTEV5ZDNLWmhadFByd3ExbDljd1pEY2NlOHlTdjlBdERHVnJOQ0RnMTRMUXQrR0o1WkphUGxwT0d2ald2Y0xidGRhMjlwME15bGM5RFp0RjQxT3JlM3J1eFFyM2xyR2g4K21kdkdOK1AzR3BQNFZvR2MwY0MzQWkwbzNac0Nadko3ZUM5T0pMNHVVWitZQW5TOG1uaTc5dGpkN2ZrYVlDYW9NaHkzS2VlR0JVbFkyOFhrazh2RnVQZ0h4a1ZmckpuVjVocHliMVFTSzZHNEQ0b0Q5Um1tWmcxZWhYdFRhMFM0MVJuSlV6VTEwbHJDUlJvalliWXpMRHhTamptTkpUR25OczJ2NG0wMDVqVGM2RWlsS1VFTmRibW9Hc1RUZnYrWHVJdGtKVWNvVjhhL3pSai9yaEg4NndaR0F4NUFNSnBpcUJ1dEFKY0dBYml5NkpVV0xScDVlZWY2Q08xN0hUK1VOYUx2NjF2Z05UMFNna1llU09wRUcvbFhwMDFxTVRnNmZIaTdldFdhbTQzbXppbDF1N2J0MDdsTnQ3WTAzMHZNNHIwbzdUQnltRzVvcytpSU1NMTcwWml2cklHRXppemx2NFFUTUg2VCtjL3dtUHRBNVhmRjNpK2NlQ1ZsbDZuc21abzhucVhMY2dZdlhUSWtaMW52WHMxZjZ0SGpwZWE5aEF1NXExYmxEbHU2YkdpTG5qMWJ0T2pURjcrL0c1Y21DTUpqL1A1QXJnSHRMWlk4OWNIN1pEdG9BNFdGUUJwRERJMXlGcFMzUnlJanpUQWNDT1lqKzJnMENCU05CdHRkNy9Ndjg0MXowQ3ZnM1J4d3VLd3hpZGZBdURnQmJvQUh4STlOUEw4RFQ4VUdKZk5CaWF0UFM4Y3dyOE9sOEl4NEZzUHN4RERyRlpocUdLWWFoYUY1cmNmQk5mRXM5ZUVLVnBJaTZTd1VDRUdvOE9GeUJ6aml3K1Zpc0xoRGZiZ2tGUis4dkpML1o2UjRWa0l1dXErMm9RSDhGMVNmNjFlSkhWT25hMVBQam85VysvU01tZE9LaFU2L1FLSUFPWU84QWhueDFkZ0FHR0VoQmpvUXZtVGlndFZWN0VOOTB6YU82dmxHelFLaGdYdmVwVzBGWTNpaDdPeUdibjBhTlhjL0ZiL0IvWHdWNjNteE5ENnNLbGZSdGVkaXZRSEh0QzY4TVBGRUpHc0lUSERQOEh2SURmaDd0NkVYNEQrL0JNUm5uWmhldEF2bWdaZjRxZ3hub1ZWUFI3QzgvOUtHRFRDdmhNRU9RaDBBeVN3STVKcDY1SXVxdjNKNHFiaHIwT0F1UnF3QUxlN2FaQ2tobWNrSG1YLzVaUTBzV21ub1BibkxzQ2pNVHJ2MEdkV3hjY1A2TmIwS0tiNzBnT3RBVC9FTXhvWHQ1ZVZ3bllJTFNyWW14Z1hLTC9nQU9iNnZnWDQvT1gycXlLbnl6bGdTQVAzdmx0OFg1N3JQTzdCcWxlUEF5amNkSTBlTkhEb21iOWl3TWNLRVZjZU9yUnIzNXRHamI0NllQV2Y0dUdGejV3N0QvWjJKNlhjSFNyOWJSeEg2M1JyMHBPUFl3bkhpZStKcFl6Sy9uV3NEMStMUFY0QVhYaXdEdndzZTRMam54eVgvNWh6OXpTdFl4dlpTZm90L3M0T1BxUGlORWlGR2Y3T0k0NlNGNHNmME4xZm9iM2J4MHprTy8yWW5GMTZ4M3hyaDN6UlM1bThrbXNEbkNBMXBua3NIRHU5RkNrS3pXNGhleUpraTVkelAvNXllNnBuZEVnQllHanpCZk9ZTHB6bnlXTllqVlNaZ0k1amFkOVNnZVlYamw4RThDTC9lV1hKKzl1VEdWWXdMRjhKZHM0WjF6Vjh6VnMxdW1mUDU2M1d5QjRBM04rQXgwdndMUTBKUUV0NExKTi9xWlV5ayszUGUzRUUvWGhTdzZNeXBNREVxekFUd0JlaEZZSXk4b0lleEtUQ2dHM2NUWkJPWUFNR2puZG9xVEIvdUN3eUhZUUk5WVNUMVhjTzVnNkE3M2lrSC9VVU13NHB4MEpRdUZYYVkybDR2MEFpc0pyQm0waStpODBZeVdMd3VKbzR6eE9BOUg4aUZjTHNxaVpxclBPaWJGMlExM3ZtSUIvbUhZM2dyMzVUbjh6MEMvSjArbkM0elFHTzNKTTcyQVAwKzBkb2t2SWltN293S0F2bk94dmhTY2lIb2VoRG0rS240TzBsTzVra21DK1lNd2ZRZmlPT1REWVlZMXlXVGUrK1BLL2g4Zm9DN3JRVjJjTDhiQVU4ODJ3Y0RFcVJBTUFkTkp0SDd0M0xkMjhCeXZHRnFrSG1halZxU3ZCQThUMGtZMFEzY0pIQzcvRy84bk9ZOTBMV3Z4dGFlKzBOWmUwbFpEd1lUbzhKTUFBNWw3VDFnYkFvTVh0TmpiTzJOZ2dlTXBMWXpuRnZHMXRVb1loaUhrZVgvMG5VdGY0cUpaRGJ0VnczV3IvTDFyRjhDRDVYMnp1TkZ0ZEorTVpnSlhIZldMNjhLR0I3RDFLTDlxc0g2VlQ2WTlVc1NlQm1tL0JzTWswMzd4ZG9aWGw2UDljdEx4TzJRQlJKVkhNTFNvM0FmNHhDaGphLzlTNmE3VStCRVdiWG9MNUE0ZDNMSkVqelNNUUpLUFNNeFJCMFJKVGJnQ0NVa1FjMXlDWTVUMDF6d3R4dnIxbFhrdWxSRis1UmtGMVFLdXNMaVhMaE96WG1CeGU0U09lZkYvWm04SG8vb1hreG5leEdFS1h0UlhUTWE2MjJvaDJGcXk3UWhIWXdqTUZWNEh6MU1IUlZtQW5nRVJoT1lXRStZTmdvTWZzOHpNSmJBUkFzZU1LMVZtRDdjSXpDY3dNUjR3a1NxN3hyT1hRSWp5RnJGaWhqR0VjdHlsaGlQemVZZThXZUZYbGd1QytXY2dnK2Y2Z1Erc3J2WGg5a2x2VUdtTnlBZWJHK1FEWExSVzFtZ08raVJoZDRDdVZsb1Bkb0FtbUNkckY4bnRJMWUwTW9zTUJLdFl2bGlVOHIzQ1QrSjMzUGhYQ0tldmE2VlJIYXJ3WE8xTk90cDFNVS9PNk5yeFpQK3hNVFhJaDhwN0NPVlBtVGg4VFEwaTlwTjhRMTEzUkZ1TDRhRXhnREFmSFp4bU9jbkFHSzlWSUxtKzI1K2FjQ3dXZDE3azlEdlVVZGZHVEJzL3N0dFhBRU42MG53OVFZYitwZit6RTlPVFpiY0syMnpPaWl4OU5hYUc3N3MrblExalFWdjNtVGp6YTYzWmo2Y2NLb1o0TjMxRzZQdkhnemMzZGdWV0swNkN3dkhhMEJqaE9uZXJDZmpSQ08yTjRONEwyV2RHRXlNQ2pNQlBHTjdNOVFUeHFiQWdHNUFaSHN6VlBDQWtkUjJoblBmc0wwWkttSVlSeWp4V1NtOGdNYXBHc0l3YkNQNW5mdkJxNlE5Zjk1QTI4UDc5MTBNMDRibW9wdVZTaEs2Q0dkRkRzV1NudzlMTDNSNisxQXU3VTFsZW8xem5SaDdBblFxcnBJaVFNVDRZQ1dyRDFoQml4dC8vMzBESGJmYlFZdjlEc2QrMFlGSzc3NTc5RWQwSEg4YjRWNXlwSERtVVlLdmEvQlkyNGcvYzhta21vSm9mWjRucWM1K2I1TkljMHUxdGlTUnlndVlmbFQxeUR4U2RCdHpDR2ZXeFpQVXdSS3RVakFDQk5vLzI3dm95R1NROSszRzdvZVM0NnV2YkRWMU9WbzJ6ZDVoNG5LaHdhZTNOeThkOVZYSDd1ak84blhiclhFNU1lbjIvb05CNUx6c2E2LzJmWDF2RVo1N0dyc3Azc1p6MzBMbUk5dXc5SVBudm9ZUXJxd2xnN21wd2t3QUE3Z3dBcFBtQ2ZPSERDT0JiaU9xRUloYUlvUGdLbUIrVjJINkRBZ2hNTmJuWWM0b01OendabWFDTldrR0RPTklNenBxbG1yZUp5VXJmY0k0ZWc3cmN4Z3lnL1RKa1dGME5KVHBDVS95cktSSlFrZXVGbGVmYTg0ZHJpUkNOUWJmeFB4MzRhck10cUlQVjNYK2hyOVhIclBxckVMalc1MEpYQXcxR2RJUVBrMm9sOE5LSTFodGVqbXlBVFVyTnRYSDhpV3BkaGhibk40T3cyelJ1aGkvUkpwOXgvTDdsWEEvNGZjM0xqWkt2N0g1N2FPM3Z3TFN0Q256Tm8yRzRxMzNwaFJYYTN4eTdDZTMzQUVIRHcvZDFNemFxTmpWTnZka1ZlVGFzR3NtditpTmZmNFE1bTh3ajhudE1lMnQ1VVdIZXM1ZE1UZkhUM3JqME1paGcvUCt2am9rNnVTdkw5WHRrZGx4eUlnbUlIYkphd1B6K1hVWE5vb3hLNDZ4OVJ5SVdwSllVcnhPcldUNXBUZVZYMmpzSThXN05qTGVIV0o0RnlzWUZKeGlNRGRWbUFuZ2RZWjNWVDFoL3BCaE1ONU5vM2dYTHhvcWNJckJuRkZndU9GZEtFNVZOV0FZUjFXakk0N2hWUGxaV2pQdlV3ejNXSlpkWHVPOHFPeWl5aHpjT2d5RHhFOWtHSW1ia0FpcDVDSkE5WDNscEhDUlcveFdhUWZMTHJVNWljb3VvaXE3dklXSldnM1JvYjVyZUxtQmFwVUh2UXpQeVM2RE1YMnBLVDdFTW5NYU41SERDb25ldSt0dmlKUlIwdXhQdnBYVU1EY3lZMGswSnBMVXlYQ0dtQW5tT2FOajZCMFhFazAralA3VUkyeUpEcEdWbFFpS2hsb1hpTUhEQlFKQ2c1Um9JQnBTYXNIc0xWbE1KclpyVEpjc2lSYStUbElHYzgwUkxBeks0QnVOR1lkK3ZWU0svZ1RDTjhPY2RZV2dJZTNScDdWQlRNM0JkWk03ekswUGdHMHVTQ3BadVAvb2h6dUxQaGFEN2VqQTlaNS9vbk1nNlB4OUVOenBaWEhXeFN4SDJ4MXg5U3pEb3R0YlY3WjFmZW1kNk5OKzJFK09ONy9qeXMvaXRhQ3hWK0p2ZUE0N3kzTEhMQzZZekxORlZIVWJHZ3NsZm85aFhwWHg3QndYUmVXZ2lqVmxNRGRVbUFsZ0htZGh1T2dCODdzQ2crV2dGVmlTSkhLUTZBSHptd3JUaDV2SCtoUGpDWE5haHNHNE9EU0VTa0VHWGlzRjhSaFR2eFJxQ1N1b0RkNlh5K1FPOG9BVFVta1pCOVhPWUZDL2NVYUg3L1BtQjJaeVN5UWlLUDRuMUhKRjhEK2gza3Z3ZjNEMnVHZGJYTTIzTVByWXAzeWNFQ2FjME10RU9uKytFdDJwazRuME9XSE9LSjFNVkYwdkV3WExLR05qWmtzdVFSR1FpSDNCWXF0RUppSXhabzFHcG1WbDUvVEpRV1ZYTXdmWDdKZzllTWdvZTZ1WEpEQ2phamZybmhQd1lyUDZFcG9lMXlGMTkwa2FleFlldHZWU20xK1drZmd6YzhpVzg2MStYNU4zUEpNUE5sc1FPcHBiVXQvMWg4a0VTSEljclZWQzRsem9YdThwNDhYSGJLK0hWTkFXQnZPSkNqTUJ6T0hvYmcvemhQbFdnY0Y0c1l6dDlURFJBOFlodytBMXo2RTdQWXpTbnpBU3Y4emdhRXdGZlY5ZitYMHZzL2RGQ0NHS0hMUVZEUkM4OVhrR1ZQUjVjWjdCLzdNWXVzcnpETHhaREoyOTdsdGpLdytoTXh4eFQrL1IvN2tZT25XOERubThlRjRTNkx4RUdQQm9IUkZHaDZWVVkxZVFucWwyaFh6dUNtaExkVjFSMU1zZlIxVzVJWCtJTjVWaUpJMXN3V3dPVFZTYlF3L3VMbGpDZEYyUGR0eXFqTkpqWEFjcTZXaGxsRmhrRjgyMDMxVUpUd085K1hGTWRrRjJIbEZlMTRJOWg5bjBPYTN0UVBXc0pIbGQ3ekk5SzQ3M1ZkNUxjeTRvRFdvbHcvUm5OQ2hlQ0ZSZ1dEdHRsSFl3cnYzQmRMRll3YU9kMytWMk1EOGNUcWxVckJoWTBYL1dUcnphVGs5d1hOYnBSSTkyTGlqOXdUQjFGSHJuMForMmFqdmRnY0IwekhqUC9qeFcrOU45U2hUano1ciswSG9TaGd3TWs4emE0WTR5dlNSY0FFbzdZL0M3SGtoaHhpU3VOYlhpNWZKbnhLR0tGYThxUnUycUlYSzlvUDlCMStlWnJzOWJXY2tjV2kwbmk4ZTZ2dFlERUZpWnJoK3UyekwvWCtuNkxOZEZtSTMzZXppZW0za2FUMytsKzEwWEVhN0tCeUdoWkw4N1Fxek93QkNRcll1VUJxVk93VUNwZ1NtQXBwaUVHQjFocFlUMVIybXRIUjY2Q1FraVo3a3dqWUdjSFVNaUFHeG1HOUNGcFFxemkrVzBHSm9qZzA2RFJnWEZyc0VWS1RMQ3ZUSUxTNDB4czF3WjBDWDMzRG1YUTVzb285aWY2UDZ2SnUvL0VyYi8vVVZKTHdjZVZXVzgvQUs2LytNa2d4N1BldEg5WDAzZS82ZVYvZS9Samx1Uk9USE1QSTVTZ0tvVjlKeTE0NisyMHhQTVlmcnZjLzM1VkcybkoyakRWV0U3c2FJZFpDZTFTMWc3aEY2QVRreGVSU1VrTDRqOWxqNy9pMnVrdmpkRGZXOTM3ak8yVDB5ZS9YK2l2cmM3NWtmUkh2Mm50VUVvSFVtUjZVZ1oyLzhKRmZZYW1ndEQ2VWhiR1dZRzIvKzFLbVFaMWs0WHRaMGVlUDl2SnpDSm51MjQxSFo2Y0c5dzdSbEY5V2duWG0ybkp6akQraE1uZXJSelFXMm5KMmpIK2xORDB3NnFTV3Flc0hhTW1FYUFzK2dUNWJkU1orVzNmQ0dldFFZZWZhQTFScWhOSTFXMmFVUW9kbEIxM21odURMVzd0WlBuSkFQMHhWVEdHVVlDYTVxR2tkUVBRbi9DT1U0Y2h1bFBNS2JnbFZXVFZCSUJuRWJxR3NQU1ZVbWdNY1lJcVJ2Zm81QUFYOHAwQVdjSTlaL2hYYXdyTm1taHhTYXBCWmFFNndScDZqRGlmNFFnMGRvbFJBNFVMcTllVFNxWUxGMUthcGk0T3ZDTlhLZUZ3UVBMRUNsbklzQ0JvQU02Q0RxNHV5SWxkNWovRzlPZFNLSnhrRTZINFU2SEtWU0hrdE5LTSt6VWNnS1JZU0p6aFRzREl3bFpqY1JrVlJ0OUNjVWcyZTRSb0RPNWt3eENySStFc296MzU1TWdTSTZYelJ3SDU2QUQydXloRFJ2c29MTndENjNWNXhBSjl6QkJJZnJXQ2J3d1BlamFNWHR5bi9LZXpHWnFFQldiYy9saURKTkVlZkJqR1Fiekl3OFlyQ1BDSVpRV01adHpmbmxmUm91RUNwZzNNWXhOM0tucWR2bmxxZVYvRWhoUlVtR2VZcGk2bEJheC92UW9IOGxva2FKSnl1OFN4YnRxZjNxVU44U2FnTGRzMzJZNCtUS3lnd1dVaHVCMmpCTG8vVE9qZGFINGVWK0oyTlRhcytleVB2NEpYdHorbEhheDkvYmtVaG1laTNLYmVPMzM0RXNzalkvVTV2dDRta2ZrZko5WXU1MkdLZU8ycjVYZkY2K0xEaVByaTRHckNWUG84LzJvSFhSUjN0MmVQdThBUHFmUE8rQjlQOThRaGZ0U1U5NXo3NFBXcEMvQkt0OHZYNFIvSzRubmc1S0FySGVWTnl4L1FtMldJbGRCUit1VDJqYTRuVnJ5dnArS3ZzVFBONk9HSkpjS1ArOG9QNDlEWHhOZk45N3JrYmpUQVVybWhzNjlyY1B0RitSWWlaQUYzNVNRbUNmSXF1SDhWL2xXT3haTW5EZ1hIRnNJVVZVWXdDOER2eUdqMEFERmd1OUU5OS91YXhLYngySlNCMGY2RHZmYkt2dEhHb01JTW1hZkNwL2Rab3diZ3FFdmhzbVNZVkxCYWc4ZnlrblVrTlRUWWUzUThVOUdYeFBmTEdwSThyblliOG56OGovcGM3bitqdkplREg5QVZMMnJTdmtDdVg3amZ2eitWK2lhWnNtdzhSWHlHSjNQRUJYV28xMU11ejl5NzhGYUVvYWp2bHJTVm9lS3R2RGZ3OTJIeU44bEs0MXhzR0JhVkVibE9ia1dpSzVNZmtWaE9jbVBXWDRKR2ZVSTQrQkpvcVV1V3BXWHF6OVMzYm1VRlo5TE5JdTBxSlloSXhNdldTcW9qejRtZFlVMmJyVHoxaUdqaHJpMzU4Q042YVBTNFc3bXA0akFsMzh3amZURi9PQjVUVXhUUmRmblgvdFZTcUlzT1JKTFF1djVnRXd6b1hPc0Q2MmR6b0xEaHd2NHZxMUd0WEtiNEtuV28xckRYNVE1ZlVUdDlPbHMvV0hZYzc0OVpoKzVvZGhIc0U0eGkra1VZWUtneFpGSGRHM1NaUno1anVKQ0VkNDcxNmdNMGxsKzNrN0ZrVWRVQmttWFpmNk01MlFROXQ3SHFsMm1PN2VGMlZ6Q1ZMdE0rVzhFUmpJck1CZ0hCNHM1Q3Y0b3ZFYXUvM2tZdFJQdTR2VVB3M3JpODVaL1hXQ3ltai96WElKS3BibWJJVFFLT1ZCbU54NjV0bXBaSmVIdTFxVXhkYUlDQXB1WWV3eHluU2IxbFJwSm91T2ZweVIvYzdEa00zTmNMK0VHS0tzcU9zcmlnWENEOW5rVGxqbStFanBpTGIzWGY4b0xWSktjS3FMRmFiS0VFRVZjQlVFNnA2Slc3OURrQ09xelRUWDVnajRaQndvY1I3WXVqVzhRRzJCc0dkNXp3TUxwVXpkV3hRVDd5TUFSVis2NFE4Z0Fob28rVThmQisrK3RuempVOVV4b29QcnFBbFZmWFQ3M21LMXhsUXA1ak5teGpxZzJzM3h1SWJPZlJFbXFUTVhhNmFMNkJYdGdJWDg3MDFjOTJuR3BOck1lM0FZbUg4YUtIdTBNVU52cEMvcGgrVENRT3hoRC9KU09HSkpCcmNqNHREM0pXMjJ2TC9jWGxtRUlMTEhsYVdCSnZFZjVmVU1zclRtY3lDMnBwT3FpVG1qVFpkYW9Mb0pBbldib0RHWXBJTUZXcHpVWWM0UVFuV1NqaytzRXZiL1kxNlBVWkhXYUVpT1gxUXUxcUJVSXhRcnR5aFFTWkloMWJScTQrSlZINkN0US9WRzc5VjM1ZnFRdUlhbFJXSmJiZkZiRFJqTmJmUERkRHo2K29EM3dCbW5BQzNUdzg4NTEzOGgxN3dneGVBbS9HYnpRM3oraWkzZlFuNWpUOThOekVZUHhsWnd4VVorYldZa05VSmVZUjcwbnlteFE3d216TE1Xd2toN2V6Q0JOWENJYUJIWldpYUVtcHlTYTc2NHhManZTcWZXNTduUDVwNVY1TnBSaXFwNUpxYXFib3grUXJxNjQzckRoMTRWeVhZTk45ZW8wUGpaajRmV0dEYjVaSmllc25qaTVaODhKb1lqV09waTRrMW9QbHhkT1hha3BkckIwMnJTbG5sbXM0QmdyZ0lEeGpOYllvdlEzUTZhdE94bjlyY2J6R2pvSTM2WDB0NXZNbzI4eSttc1cvQldZNDVqK2xvb0hXRHVVem82aWRIWWlha3J5TXRsdktZOStnTDVSMzV1aHZCZlQxZy9aM3F4ZVlhdWVROS83V0g2dkJMcTdLZlVORmYwcmRHRmFYNHZhcE9ySy9YK0gyYVJxOE41S096UTNrL2EvdXd6ekN1dC9EVUdGWWUyMFVkckJNdlZScHJ1bENCN3QvQzYzSTRGdVhhbm1saUo2YS9xRFdwSjZYNndkNmlkNmkvcUpocUUySkQrVS9aWStiMUZlcHI2M3JmcmU3dHdGWm51cTRmbmV4K3A3dStkR01ZMVI4OTZhS0lQVTQ4SXdtZkw4RDBPbCtIa1NTaWM1bS9oNUQvYWMreEo5U3VCSi9TNURHb09uN3owT2VsUGR2NEwva1h6UGVWS0VrZjZXeWtZRHhPRUtiNk9uczFUd05xVWVXS0JTL2J2U2lueDRaL25JV2YwZVp4NzU2R1BRL0dsQmlZQlNXZktVNjB1VEVvbjhuUHQyVkE0QXFSeUdmTyt6Y3RPNVlGdHVMdXFIK3hHQysyd1hzekMvbWw1SmppRmxVYnI0ei8rUW8rcVVnb0hjWWEyNkdxeXJDa0VxY0Z0b2g4TUpSWEJFbGpxcXFGbXNwTlBQWjdJcTJhd2dHdDNXWkxSKzlwbWMwNHFlNXFKMzFMUlc4R291OEI0RXpHbzhRbTAxWnFFUDk0enBmMlpSeFJkbXA3K2gydkw3a0ozRS9FbjZ1QWFxLzlXVCtSNWkrbCt3WnpzN1ZiOUJQcmVBNlg5bXlhQnJoK3AvOVdUZUdNRDBQMDBNQld2bnJ0cWZIdHc2cHY5cGZBdXNuV0ZxTzczQVlCWkhGMG5pTllnbUhhZnlSdG9lMWt1VTlucHh2M0pOQ1d3VXNYR1FkT2tFRlphMTIwNXR0eTk0RGV1SjJuYk4ybllGSDJwejZpbnozQ2RZZXRlMmE2bG9GOWxKblRyV0xyVnRGYk0yOEhNL29RRnJnOXJPUjlEbnRBWWN0Y3Mwa0hYRUcweGZqUkRNeWh6UVBGN3FnK2t0dzNSbVBwZ0lVWVZoTVNZMWxCZ1R2UFpIOE42bCsxYWRiK2FQK0ZieFI0QnVIWFd0Vk1TcVNPVnFyTXB3YmpISVlqR09YaXpHMFVjZEs2MlBSbmxFWTVsK2JtTThJb0JYMTQvbXJWS2ZUN1lNMDRINWZBSXE3RTZzSFgrbEhhd2ZGYkE1OEJVOTJqbXN0SU5oNHRrY2FHQllPeGxxTzkyNWs0eDNCQW9lN2R5VTI4RTBjemlWNmdKVmZ6bzdNd2ZtU0RYeHFMdlFNM2wwTnZYZlNNQmNuZ0R5blp3QXhwWlloYVlDVnBCSlRIcUpRL2hBZ1BuT05QTEhMUVJzQUlsVUY1NnJDcTB0NFdNMjdhYkZlNHpoYWJHRFJncFhTZG1lQVpLaE1LK01GTzBCNVdkUU8vZzI3a3NDdDRweldLd1ZjcjlDcmVMeFRieE90eWNPc1hoOTNUalI2Qkg0U2RRQ1U2a3p6NEs3T3NCQ0toU1JTNkdGRkNleU5MWGdFVzBoRDlMdzMwc2NsZzhzcERpUkJZd2xPV2JSSHFaeXZYRCtmSWtpRyt6NVpPdlM2Tm94QVlHTlFuc01MQ2xoeFlyQ2E4Y1BHdmFFdjFwMmFmY2hiNS9Cb3UrTThVSzZ0bXdSazJFWGx0OFhYVkp2S3NOMjVSeEc2Nzh3RVgvR1JQeXRPc0VVYzVCSW5WN3NVZW16b3RnckZjZm9RVi9Sd094UnZmUlBiZG5YQlRmYUwxaGlkMnl0bXZTaTRxL0QrbmtmM0h6aVRuaWJ2ZjJlcndGTFpQaHJ3bFZsVE42VlZKZFNqc1Z3U2lHOHpHZjhkWHJkdjQ1SmxTM2x3Ynk0eXNuUS9VMUg1ZVV0bVZNdHBiSmlKKzFhK0M2ZnV2cG9XSXNkZlNzdmVrTHJja28ycVM3V1FWN1Z4NFlGYUpWVXovTnVuQ0NBWXpZRC9ZbUdIcFhWZ0ptT2dXUUJWMUs5VTVvOEt4L3lwdy9ycW5oZWhBSEZhOFFQN3BqZDJSN2xQR250QjhFbEhNTzZlcTZhamFuekw5Rmo1cDRyQjZJTHY0dXdVQnlMMEpWSGRCcDhBcDZ2MDhNUzhReEtHb2kyUEFRZGwvQVU4cXVXRC9mUjFvbVErdlVWam9scjl3VzRObnBVakpnQ3ZXYU9aL0UzeEdab0lMNFgyV2JZdmJ4RCtWL1V0MS9odTZTK1lDODFkcDUvQjdRQjh6a3pwdlkwL2p5QzFrV1BJTWMxYWVQTjFEZzUvaDN1SzY0MWdXL0FrM2l6QmtZU3lJV3Z6V1I0R3JOT2FmOTgyVDVUeG1oL2VJVjloc2FsVVZxN1I0Ylp5T0tiV2xmRTFkRjRWVU0yaGxrdncvQmdEWUdweXhzcmRPaHhXSWNtZk9zOW1ZZTA1MElwVElWTzBCOGxhK1ZyTEpOT1FCOVMrVHBGSzEvajV5WjBoc3JGbmJWeU1aYTdOM0FDbFlzN3dLMFZjakYrYnFCMEdNODVTQkVhWUo1US9VWDJEZy9qeS9ObHNrREtsaVhSZGFMOWpVM01QUVlvOWJFdzVaczVUbGpKNnVVOVVPdmw5YW5rTGFySDA4L0FzUVJJRDg4dDFzOE5jc2tIclM3dTV4bnpvTlE5U21vTTVFZzdRM0lUZW1oT01sRkV3ZDhYZ0Q5NmN2eVRPOUI5ZWxQK3BreGJvL2RXekNveFF2ZThuVUpIOU9WUG1mZFE2Yk12Y3FNTy9kMjBRWmVtN1YzOHVmVmkxSkwzNlZvSnRZRkpDZ3VXK0hvVm1TdEtqUzlaSjlnaTNJRVh4Szg1TDY0aHBucVV4VUphVmtRTitDazVhYmhrZ05uTnZBTXhrbGtOVFExQ3RqUExBUElkZkdsSks3NDdUMCt6TVNja0d4SXlNbTN3UXQ3dVhhTi9HQ1Q4RmJSbmova0c0K0h6OFR2ZWs5L0JzWGR3cFNXdmNMMDRtRTllQlNwZUJTNEIraW9RQTZ5Z0tTQ3ZJcWZjTUZ1bHpXeElTTTZ3Z2EyN1hyODM4T2V4WXMyM1ROOS9iMkx2V0NpOEE4OVQzU2FJdktEWUQzcnNmVzBGZTNnYUN1dm56Tmtnd242OUIvYkxGaDFTM3FMRlk2UU8vUWEwby9ZMDBRdlVvWG1GNGZxOHdzT0ZjQ25jREZseFV0eVJPbXZXaUY1N0tHL2NLeXdBejhUTE5MOHdtZklSczZxdThPbzNiMk5Gc3VHTE13cjNEbTdWWXREQWxxMEhkY3hJU3JUWkVwTXl4Qm90QitJSGZmdTJUcTVqcTFZdG95NGRjeDlrQjFzeDN3b20rYW5CMW9wc2FYMTVyemcxRzhpaUhwZ0orclJwbjJTTFRROExpMzRsdmYyZzNPeEdBK3JGMUEwSzZCSWMzcXRUNi9rWnRQMWM0UkVzRjIvZzloTXcwZVd3WWtpTEZ4RGpzVVM5Z0R5VlhmeFpmRFhMNGFxb2xrRW51bnowcTIzWDE3VTI2elN5eTBzN01tbzFGOC8xSERlNlZkMmc3dU5IdDhrazh6Wlh1TU9IaXIvUzgzMlRuYnczbjBxUHFGUjFQVFdYa05pdWVUa0owbVlCQ2NrOFNTMU1ock9XUTNRMUg4Yk00Zi9NNWNWZkplU1NnSUN2SXBOWmpxQ040R3I1RHJvdWpUbEhtRlc3R21wMnVZWHpObnJIZXFkNU4vUHU1RDNBTzg5N3V2Y3k3eTNldnRtRU12Tk0vN0M4WUxXT2RHL1VvR3VYaG8yN3RVbU5pYTVlUFRvbTlYYjlEaDNxWjdacmx4bWVXRFVpcW1wVkVxSVpJSnhBb2FJTDQ1U1oxZlJWM3UwTTVBRXJkbXREb2YzZm1pYWNBRTB3L0JiaEpOb2h1aG04ZGtLY2dSeUZ0L0VKcUlaOVgwL1JUV2lyNjREd3FMeU5lQU5yTTMxY3IzQjBUN2hIQ1pmUmVxa1gzaE9zOG9pNnBZdTlOTG5CTEgzUkdTQm5NWUlNZGpSU3BuemVxbnRwN3c3anVobm1GdzNxQ0lUTFU2V1VXdW0xT3ZUTGF0dk8wQVRQcnl0RHVJUE9xT3ZueFpIMTg2STB4RXNUSjNnNDBEZkcxK3FMVjVGRW1oTG5WS1lOWC9sTW03c1U1cU9yY0Rsdzg3bC84bk9FWCtqcWxZbjRTc2Z3R2pxRHVQSlJlQjRTS09Hb1dMMEtGTW5qcG5QTE9HVlhJbTdOR25SbUQ4YmZEL0ErM2kxMS90YzVCQUhydHJTV09xTjNNZFIyTVl5M1NodmtPTWk2N0F4UVBURnM1bHRvV0dyWWJEaGdPR2tRczhrd0RkU2w0MnNsSGg3aVkxS0tFV1RhOFBpc216ZWprQzFiTnIwenFhY1l0bmJ0MnZ2WEsyTE1Pc3N4WFJJWUlqSWRUczRORFphNGlmaUJSUEpEaWMrcS9BbUdmMS9xWWt6aXFnMGgrdXFROGpvY1pIeGY3RUNmcDhyUE85UG5XRzhFaDZUT3hEY3FQeDlJMjIrSVphNW45SG50RVBaOE1pZjdrTVZvK3J3UmcwZGZVZmlleFA1SG5vTzVJYlNmYTVuTTR5aS9EeHRKWGJETXM1cktQRG5sL3VWSGlId1NRdUxIaUtQRFJNdXRSR3BqNmpCL2w4aDRaYi9PUEhxZlNPbk1NWHlmVE0vaXFQRnZKenNKUm4yTmFWYWtYa2gyK3hid0kybUJlZ2ZiOHpYeGVQcktOU1VxTysxRU9aUEFvNnEyWFB3OHpwc2VDQ1hCN3M4K2g4TlFFLzRIRkNHUmc2RHd2MFBDdTBwc0RPMS90UXJkbTk0M1ZzZDNqOTZueW5sQTdDd01ua1pTRm5JVndtNkFwelFCYVlRVU9US1hITDVXY2dDZWhFU2pKYWV4SFNDWExFaE83OEZjQ0xLVDJVb3V3VnNRZWlTTTZhTXNEWjRTUjF4R25QZ3ZwMnJ3WjkxZnd4U3NKNzN3YkkwZE9Ydis0K2thMUVmUHpxckI4MUJEblpkZjZUMDdUNG1jRGZvRFBaOGc3Yjg5MFl0c1Jucm9Zd0l0dVpZQVYwdW85bFFZT2hhR1RoSDVaMjZ5VHNxN3lMa3MrRjFwNnJzZjBmdDB1aVpZZkJmOFpCenh4U3Y0Zkg1M3BYVzhSRmJ4VkxRNnJTSXBPaVNTb2tQaVVoRm02ODRjOXRJZFJzVUtmSkhrVEhMRSszaCtqZXUxQWZDaXUzWTNmcXhyU1U0T2I4emxwVnpGOTRUbFpvbjRudVN6VzM2aDgxUC92ODFFSlo1bnFHUCtMRG9uVHZpbHdQVlJnWkNxN2hONVRsYlJPYkhSOXpYRjk3V283N3RKSmZPaDVxcHBjVTBzOVJnckxTWHZUWkpSTTd3QnNRWWJBRHlKUXZsZUxoTVUzQzcraU9zQkJEZmhYWGRoYmpaY0QvdG01NHJ1czRxdG0vWWxzOEwyUmU4YjBmWHFoZmQwZjNvK1F6U1dyL3BVVWlkS1ZRdURRcWhhR0VTa1RLZXZUNGhjenRwUTZnalNlYjRjb2ZSME0wMnRSbW83QkxaWXpoekN4U1dZRXpJU1lra0NRcHd0d3hZT2xKSVhOT2VnSVREeEZnZ0FhSW1Pb1hKb0J3aWg5OEhMQUFLNzhOWFR2NytjZXVYcFgxZUI4QVJkdXZzTHVuVHFGTEQrOGpPb2ZSemRkSzE5L05FSGZ6dytkZm8zZmhpbHlld2NCenpPaHF6bUNCNm5OeDVudUhLYWlrNW5wODVxM1hsQ3p4VmVDdlVMWWxYV1NBUkFxRDRaelVjdVZrdlZYNDY0YlpNNHBncGJzQ0lNbjBrSGI5clJqUWNUNzZFNzlxc0hwSW5nQXZSKzhDRk1jNWYraGI0THdEcytPeERFUGlIM3ArNzdRdjVIM0Y4Nzd2OXhUTnNTbEJxT1N0VVlmU3kvdGdZQVNXZ3RKZTQ2cmJYZVJJekhKTGlNbUlVVHlibmtNbEV5Qmxrd0xzV1JzbVBFUDhtWnpDR1FGT3lDRDVjZCsrSGtCOStmWEluU1FlcnNyYURhYjQ5QTZ0YVp3SXJTeDVGS01rTEJJeENQYmo0cVFHWG9jdHE0bk42ZzFlWHhJQktUcTYzb3AvR2ZvNk85Yy82WHZONy8wUjVMWW1rblNhbVlSeTZoUEhJSUdJZmZSV0lhaFRCRlR4NVIvaXYvbzVTQ1lWYklNQ25sMXhpTWF0OHZRZ1A1cjJnN3EyU1lscXlkMElxNGlzT1VINGZLL0JqejZXZG5XR1NUSnU1NVEvbDkvakhsMmRzb1RFNG55ckVqQkU2SmZ5ZlhPTlZmVGZ1UDlkOHFXSGJNclVUL3Baam9XWFpPbDRCSTlwYldMaE5nSWpWb25KSDBneHhOSGVaNVBLN3BPYityR3ZTYnFZLzI1UzlucFBsWkFrMld0TWhPZmYwejNoNUh3bjdIN3NrSWNFL1pWRFIrYldySzJuRkZtNFVHcnF2RHVnaEN0cjlQOXJEK3VVcms3NGhCUjkxblR0K2ZuZysyakZ2SlN0UGk4UmFqZktFNXh1TVFQTjVCcW0xVEp6YW9XeXpGajZyOEtkYmk2bG92VlBVVU1yNUFqa1lHY1hxcm9OL3pCeXhyenQybU9ROTE2Z2FyUjNQTENRK0UzR1RBVjQ5OC8xcS9OMWI5Zlg3QTBTYjJQL2VzV2JwbTRiUzlOUStPM3VvOHNIR3BlT2JLV3prN2F5YWZlK09UNzE5cWhrVHg4RHUvdWNjdW01VzMwem5YOWZFcjNmYXRXblNJbkd0WEErUFJSN1N1WjNvbHE2blVJNndnOUNRc3hKdVhBOHZrNDFsSWxWRys5UlNVYjBkNVUwQktncFFrTkNqN0VUVUhKNFJJMTFlRmhXbzlhRXEvVXJoaGxjaGVGRHM4aTBPVDJkSkd0QWswcjlZWnlwSnF3NmpuTVVwSExEd3dCN01aUWFrZlRjc1R5aWxqR2J4aVpXV1ZIREhtbExoLzVURjFhTWRzclA5YzhxdHBoQzB1alFzaHh0WUZYYUk3UiswNUlUcUdpUHZRcU91eW5UWHVXNURzTDRoU3N4V3RzMTE5WmF2cnNwc05ESDZ5M1pYdVk2RWRIbkZCSlhXRmFRa2RnalpoMWJ4WmZhYVNNV0dGWVRDL3BIL1ltREFpeDVGcVRkcERFUG13OEJkVmkzTlVNeGJINm00cHdRelduQ2F0S2ZmV0VKalZ3NlNKNlZiQXFEWmk3SmhCSTM4NGMraHZFWTQ2Tkh2TjJ1WHJqeDdkdlBudHRTdU9qSVlpZW5yNHpGK2crc0JaMGZHRkhWZHNmbXV1MUdmODJKNTljNGZrREI4d2Z0WkFhZU11b2xlOWd2TDRUWGlONldsbGdaWHNGSm8xUUUzTDBXUUZkUldFT1kvb0UyQUcxRDdSa0d5SkFFQ01YNHpOSm1YZ2RRVEpjUm44SmpSdTZtdkxGcmVhdVFDczZsT3p5Y2oyWFR1OWY2YmdEZENGZDdjUUhhOGdmc012azhZdkh6MTAwSWFFSHVIRFd0UnJkR25kT0JEekZ0Z3E1bEtlU21uby8xQTMzY2VEa3YydmRkTVBGQlMvYTE4NGZjcUdSTHZRNE4wQkl5N2ZLN3NvcEwrM2NXS3U2eW1yQjh4emMvRStNZEw2T2NUQ09PL2YvUEVCekpVU2dIV0NBS0lUQkp3TUlEcEJBTllFTGdYY0NvQllOUWdncWdGNVVCaXdsUHpSU3FwV0J3YUFzWjdsNmdQMG9VRFBaV0FaQ2RNTnAwUTN5Q1FxcWIraUhCS1RJUmdmZmZYbEg3OTkrZFh2cmwvaCtyM2J0NzBOMTd0ejkyM0RueGxZSlNnRjZWZ2ZhSW4vMVVZWDBkM1g1MzMzKysvZlBaeDI4ODhudDJoc0hlRlRRdjBYMkczVjJxWENpNWxDaGduVWF0OHlvbGFWOFBqV0taUHRRbjNYdGVIZHZMeDdCUVVzM3N6SEV6NG54OXRpZWVvWlhmdTY1WDhLN2NWZk1hNWlHZC9mcXRQLzZJMTZvRFFFOUtCemY5M3BwNlJZbXNhQjVZeGhXYThQWWx3eHhFN3BGMU1scGtaTW94Z2hQeTNkbGdCWXRWaUN3b1JuMGVSQ2xaM3hDWVpqYzhDbXhySGRXdnFrR01XQWVpRUZVNVBBYTlFZGJQNHhBWUp2allEY2dwcS9TL0ZDMU5iK0l3VFlYL0JlUDlyVnNOZHJQSjhqR0JaUGd2TmVaM3hjcnAyRngxZEE3K1c2MWZpK0Z4M3ZZRFNVdjQzM1ppMXVSQ1hVbDNKdEJiMWo4VTFzSmRUWE8xYXVaYUNUNjJQMUdlZEpQcFNZQVpZbHI5Q1poaFZmUEhaenhZSDNtUWtaL09MN0RzZmVJN05tblh2NC9RbmJrcFYwVzQ5NnRWZm1QWFI1MzhieE16cTJSYUlqZDBuK2FQdlFZc2VLQStORzluOHpycWRsNEV0Tm12OXdkdDNGbE1TVjJUMW5Wcyt0aU1FVE91THh2MHJIM3huZlg4Q2J6S0xFdUZCYTlGdzRpWmFmRXlsWnF6Q2JhR1Z0UDgvejB6MkxuYk9raHppaDl5WU5SaUtMZmFYZ3pYL2hicXJpSlR6dXFzbC9NUlR6eGlJMFFPRGxPdjVaR2l2QWY1TkMrVC9rVGliWENhckluVlJFQ1lILzVsVGUyL1hzQVB6NS9xVTc5cUpOUlJ0VDFyKythU3RObmV6VXp2ME4vOVQ3RnlCZ3BiL3NFaENmYkVGSGUrYmNQODFzNjJOUUR2ODVqZGZyV01tK3BRV0lsVjdUaUNPR1UwUTM1UFRWNDZzWVBRcHk2eXRpa29yNEtzNGtzMExEc0xIampnQkhiSnV4eTNINi9UV0x3WnQ5YWpZZDJTdm5ZZmsvUXNjTFRtbjJPblFreGZsTHNDbDNXUDlWOFQzQ0JqWnIyTkFuRElUOWtISVAyQlI1WkFUR0J5T2U4N2IvY3NJVWlhN1VIektsYzF3SDZzUTVZa1JSUGJrazd5NHpEcWlDUmlyaFo4SUk5UEdvaWVpZnI3R01BY1NyME9ZYXhyeTVZTS83L0JjdGYxZ1dkeHQ5UVdTTEgwRXljRitXaFFySFgrQ3ZBMnpPTytCOWZRNzNXMzkybzU4SGN2emIyWTM4T1ZSZ1IzUDRLZnlYcmhyOGwvTFpqVlFQb0xYMzZsYXlscnI2N2dyN3E0d2dCMlVrd1dRYkVWOEoyb1VERUx4dDRhN1ZzRW5HelBUNm45ODQvNTNRd0wzanMxTlk5VjhHVFBPbmx1LzlHNVgrQ1RqWW04cmErU2hlRE1COUNNTlV1U2M5WGUrNWp1aldTRFgrcUxJVjZWV29adHpoRk5WaTliaEZ0SGdSejBWVlNLaU9UWUxta0NDczV3WVRCVGdKQmdMNDVDZFFCejFDVCszb1NYbTdsMmEyNm5UOGM4a3VuZjhDL25oWUVocWcwNy9mUUJkTktBTmNDQUtaVDdZL21UZ1QvVFAvR1BySEgvSTNYYkhRRiswOUN2d0V5T2ExR2VvbTFCRmF2dUQ4R1YyQmVGMU5RNm91RTJFN0xKeFdTUkFNVkV2eUVxaVdwSTloYzBhR0NiSnVvUk9oZ2pHekNTYWw3WU05T0E1SUFMektrdGFQbnB5K1hBSTFwNkpGVjJ3TjAveGpBbm5mMU1DK281dThMYUdTUXZEbUNXdWJsLzFxK29vQm1VTExaYU5STVd6dXprQkJyM1VYNEZEUk1IRXBtTzJld1h1Qmd6bTlCVGhZOENKam5vaGFpajU0SGFPVXVIT2R6MTRYeDZmTGVxR0lwVXlBRWppdlU1Y2dzZFd3a3cxTWxycEJHVmlVSjhobXBPdVp4SVVEMldZQkgwblh6c0MyeldZMWJJbWVvZnNGajlFVCt5V25oT1dDZU9nSFFqK2VVVGJsOVhzYmtCc2REMFE5d1Z0Qm9BWklCUGVRK2ZGVFg4amZJR09ZWFg1ZjZvWEhVSTNyL1NMYTV2Y2NiVk5DZlVpM05jS0MwNGVMWi9YZGlIOHNzTlFaRTg4eEJVcUNCbnBJdVJKM29OOCs4bGx2Uk54ZDI2WUxYTEo4K3RxSmEyWXNXd3E3dEpuNWN0YUZNek9jMWFvWFR6OTd2bU1Mb2NGODlHalpxWEx1MUdlZ0t2b1c3ekR1MUZKZ1dvQjMyQlAwNll5Wk0yZUFPay8yQXNEcyt1OWhlYXN4OGFzek96MDN2RHlNMWYwSU1haDJlcDE5Z01KdVkvbnhmU2hrcE1ITUl2Q1UvSGdXODU2cXhyd1BBYTh3ZTBSTWhmK2YyUnBDNWJZSVRPUHlNeXpIV28yUm8vTk9ZWFl4R1BnYWc2a2hWRlBxRDh6Qjc1cUJaZVFJam1SdUtCRlh1ckI1RlhzNFhxTStCdm15c21yYStDaGlqa2pRN3BwRWtuZVJWRld1ekd3MkdXbFlqaWtUTDFBd1JTNG0rOEtKSjc2NGlYN2ZPMi9KRG5UbndmZm9vZjNUVDAvdkUvdjM3VDZreXgvZlZmVXErNkRKdmt2bmk5M1gwVjlZL20yRTRFbm9idm9sNHQ5ZGRrS0VZUG04aFcvTUp6RUxWN0JjT2xFOHhpVW81M0RyS3Y5UzFIb3VyNFRYVzFiTnBjNjR3Q29Nb1ppRXljSzZERlE3MTRtZTVDUVEzczgycVh0MDNWQ0xUM3hJV2xZaXVtdEhkNUk3V3MyeFBwYlFqT2h1aytxY3FDcFZGYTVNR1JiZzEwLzBhZEROdmNyOUZ1d0ZoM2RyNENQMjh3c1lOZ1Yxejh1ajlMb2VYcXRFdkVkQ3NiUTVxSkpUQjNTSHM5RmpmTWlOV2M5Qkk0bFU1ZlR4Tjh0QkVTbWF2OFdWT2hQTlZQcE9wQjQwejQxQlpNWTRUTW1TcVN0YnQ1R2t4RjNWclVlY0UzY25WOXRwUC9odXJaUTE0c016TUtPV3E0YzFZOHJVZ2tVVEYwMmNQSlgvWXVDMXVZL1JoV21GaGROQXh1TTUxd1lOZFY4WmQydk1tTzllWjN2Skh6MG1lNm44ZjZsMVdFbU5RaE90VVdoU2F4UlMvZU9wV0lUbDhTcmNFSzVDMzFDV21oSk1YVG9PdWNFNlI0UStjVjYwUkRLM0E4RmlyVVZYOUl4eVltbXNnamxFc2tJOFRRd3I1TU9jMTdyUDlYN241WitCeitNN0lpZytCTTRWdDkvYjFZNDZrT09kM1hkaXF0MjllL1FwRDN1ZldIbXdPRG5HM1pDZDk0ekhTLzF6Skw0STVNc3hQMit6K0NJbFJ4Q1BjMUg1QTZGRVBJczUrdFJLc2x0VTk0UXZqUmp3MVI5WkdFWnJwWlBDMVZsaFdKSHRIMGFjS21GTEZkdUlzNUE4UFlBdnVsSUlnaTc4a1RpRzRxaDVXeEx3UGlhdUxUd05Ga01DTmZ2UXd4a1o1bVFLVGhpTWZ2M3BNZm9hcER6K0dSaURZVjdZdVNNbjc4TCs3cTEzVHg0NWJ3R2ZTTmZMUUg5Z2VRaEN3Y0MvYmttSFBrQlg3emJPNmZBTHVuYjgyUDlmend0LzNsLzNQOW5HTzJDYVgweC9XNVBTakRvYzUyV2xaMGJFY0htVm5CcWhlQVowTXAwVGVJZks2WXVodWtoZGtxbXVuVDZnbno1dmo2ckNtaUo3Y2J3UFNBVVptRkpFQXFDVTJ4TnVnMUUvbHJudW9FajN4V0RUQjArckp4NVlaYkx3MFdCVXlhSERCMFdIdStpWDk5Ly9CVytLTDFBN3REWUhWQVBMNEVwM2ZmZVU5OTZZYzR6Wmk0L2o4WkVZb1NBdVVzbGkwSGxxRkNMdTVBS0Q1RXErL1RtQzE5eFNqdUExUi9MVU9aQlA1QnhJMHdMOVNwMkNIMlNNeTdNY3JLQzM0dmpwU0N2ZDlUYk5rR2txb1ZwYTBNWTNMZ0NqZm5wVzlpT3E0dnFvb0lBdkljTThWTUtiNEdiMy9OdEhqdjRJOTdtNzRrSEh1OWM2NXM0b1puUXJrOGE1TzdBZS9Xb2xxNmZMZGxTdHVCNTZOS0Zib1N6eDN1cFJCTEd5Wkh0Q29kYTVML1U5TlBUUm4vYURSd2NlN1dkSHJTbHB1aGtlK2NVRE5CaHNPcm9sTXR6ZDVQOFE5eWJ3TVYzdi8vZzk1eTZUUkphWlRCWkJaQmxKRUUxSUpDbHFYMnBwQkcxdEVZa2xzWXZZTWdoQkxhWDJwYWdTYlZGTE1SbkVXdFRXRnRVb1NwVlNXa3RwYVlzV21aUC9XZTY5Yys5a2FEK2Z6L2YzK3ZmenlUVno1OXh6bjdNOTUzbk84enp2UitWTDFKNU0vUjdqWkw2MGh2RWxzek4ybWNXUVluNE9QbWY4SFBSUitMbnFpOStBbkJtUStBandqUno3OEQyTGoxQ3hrTEJ5aG9wb1hLaWFGMHQzcnFJelhPdlVGVFgvb1Vza3JwZlI2WDVFY29DYjZCQ1NidGlmandjTTFiR2lDT0p3SUhaNDJna1ZnVDRWL0Nqd0hOeU92MXRsbk1yT2JyaXVDcFpReWFpSFEvQ3N4SndNWG94VUdhR1pVczZsRStid0JrTnZQWDEyRTFYamg1TFBPN2R2MzRrSDZkNFArL2IvaUdkUnVHTnA4YXkzdGxidzgxRDJFZktkN0NPWS9yYW9TSHdiMCsvN0hQcFZMZGNKUXdab09KODJVSldhZFlreldpWGQ3R05wR1V3V1BqRVpyM3dDUytFRkRDU29zVEQzMmJiQlBuMWYvOUJZaGJlOFgxYmtOek9EYitiNGd2UXgvanZlRmN3QkdkRDc2VTYrS2JxQlhoOGovS3pCYzFGOFBsaWN1UFFidFVmUGRMTUhVQ0ZJWi9KNHNWZURhc3ltU0IzUWh5RjEyT09OeE1jQVgvU0o1MHZ0WnM3STFFUGlkV1FrSGtoeUVKYUZwVlpMWkRnQW5zQWk5RitidnhINUxZZWh5SE1CT0ZtY3Z3V2NYSUE4WVBYbGNKZWpIZjE3QUE4NWhtSCtSdjZhT1l4cy9mZkNhNklmM3VOVW00YVNDVURQc0VNOGE3SjBGQ1ZwSVpraHVTRTgzcjVEQ0x3UnZ1aWdSLzl6bTRhUzIwYTcwekdMbU9wNkYyaUppU2Fiby9EYTdBbHpGcURMZDc1Q1owV1krOTNtZzkrZStIemJ0c043UGp1dzhsd3VsRUNWVTNlQWoxQnYyTGJZR1B1TUkxY3VucFRtN040d2YrWENBVXRtemxpN1lacGt1L3lON0c5eG42N3hsbTdXdUZ2bkVKZGhwSWRla2p3ZUpJTm1ERWtuWkFvV3JQbjVVdGxSZkNFT0tpU0FPMUswUGFzQm5IUHJQdVUvbjh2eFdZa0tWcENIbG85cGZXZHE0ZS9YcWI5cjJ4ZDRPT21QdURoOTlqTlhKeFdhNzBPelhRclhyWTU1WnQvTmwycEZMWjNvRTB4ZG9NaVcrQnBhSm0rSnovR3pVWDJmWEgxYTVOOS9vVHhnVWtVZmxISVo1NHVXajJZeGsxcS9FTnh1eXF2cHVtdnNSby9TT1lTbzBEZi9QaGNnN05sVUFtdm1PTTYrc21oUjhDdGVYdDVKQVYxejRwTWMzODJDU3hiejI1NjFMVmhvRVByd1FuYnZJVUlDeC9CZWo0cWJ4SHV5WDBvcVI1VC9nSGlORHdybVdDRGU3czNjVUx5cEc0b2hudXpnV3IrVHloVjhVNnEvMEJPRmZJNEZrZVJYNG9tU1VoVjRnRTdJaHY2dU9xNEsxa08zZzQ3QXM4cTQwQ3NBb1BJcnRxdW9ISERYcW9qVjBKNG5UOUd1OCtmQnEwK2ZnSGFsNkdSWlcrQngvaXp3UUkvUG5rZFArZDFzUHJyNnBKU2dEOFRoMUMrb2hTWmVVOGZyWEhjNFFKT1dRTXFmZkRTT29HeXJvMUJCaVR5ZWJpWDVmQ09ZUDlkejJMTURaTGVEWXJ1bnUxQkR2RVBMdWFDRlpSVGJxSm1iM1lFZW83bXVSN3NmcEh1Ylg3ejJZSWJOYmRmSUQyR1pOZnZBMEFkL1d1MTdjbzcxSjlNYkxnOE4vZVpYc0JnTjIxc1VHZ3J0bUFiY0paS044b1EyYnRhWmJ2SlJOZGpWRzhuRlc0cktwaVpsdHdkMVlUc3JmTlg2MUVQZTZ1bDJqOStHMzRzK01EU202N3ZyZi9SZUphckgxVXZMczlUbWkyVk01emc0NmFBRG9kSXkxM1A0a3o4MDVKU2dSb0E0WG5Hdy9ER1dDZGZLOHNZYmJxaFNkd1hveVRFQmc3QWNyUmdQWHd5T3pic1ZPYnhnSDBYaVFNSGtNNVU0Ykk0WlZPSm83NWdoU3h4MFBXSVpRL3lONW13aGlGaTkzT3pOT2tGV2QzU2g3c0Njd1pQSjdEcmlEYTVwNWxWYThacFVwRzBpZWljcTVGb1pyWHlhMWNvbjYrVWpSMTNhcDZvTVIraHQ0WVphWjE3Vi81Nm1XRmQ2WEdnaGErMERyTDkvU2ZYM1REZSttT3JSUkVYbFBZU21RaU1KcVZ6My9PZG82T2FZYU9iSFJRN2NsSjNkbjBTL1JDUXhrOVVHS0lMd3UzK0FXSFQrajkvUURSR08rUGJBZ2R1TzkySC8yd2NPZk12ZmtjNERpSXJRTDcraU8raUR2eTlMeFVkQjlKMCtPVFh2Z0pxZmxlQSt2VkIrVi9vQ3l5NkJuSVY3M3czbjBDbHFPa1F4Wi9naUU1RjlzTlpHb0xlMytSejB3VnFibncvSXN4ZVNTeHE1WENVL0Zmck1KejhSaEc3N05ueFhaL0R5ZDBWdmRMRlJ5RzY0VkdQRGJOR2RPNjcwaGVLSWkzNjNXb0ZmUlhkY05kb3h4VEVRRDJwcTUrZjY1T0srNllQblcxUEt5NE1VenVJMnE1R09pZUh0eTROdFgxcXJpeDNTOUk1RWp0Q3Q0a1FMWUtjV1ZKMEJEQmc4TWVMNkZOQnovcnRBdWdYMlcxRlBzQjd0MzNWd3h4cVFBL1Bqajg4cnZZbTU3K3Z3citKVkMreE9iSFpxMTIzRjZNYjdmblhKUlAzUk9tcnlWd1ZVWENjbVdkOG0yVUhzVldnVWxzNTd5T0FLTVpuZ3I1cnlqRnlLRXVYb0N3ekJUVUN3bXF5UDJQWmdwek1POVBUaWQ4U285K095aWIyaHNLMTQ1ZmxBb2VHUmZocytQYkJ4dzRHRC9CL293Ym1JRytoSEVINTlGV2dBSnRVSWZxMmQ5SFplc1BuYUlURXRLL3RhVWNTMjMzN2JGdkhCRDR4ZmJjVGpVWW5pZ3dWai9lNU5OM2dJeW9qb2dzc3FHd0U3TXRObERQUHdxOHlNOG5yN1VLSXpqUnZoRFNwampZcGdvUjRSRzhIY0U5ZXkwd2RQdWJBSHJRUHBNeFl2blliL2paKzlZT1Z5OUl2UWNPR0MxeWRWQzVpZnNYZ0YrQU9OSE5pMzUrRCtzRTlHbnd6Q056N0NqV2lDNmRmNzdsZUFOSFB2dTg4M2NWeXh3cFg4MmJLWG1GOE01SkxRWWFFRDdROVZKOVRWcUhxSmFIVkFqdXFBRWsxdnEyNXhaTXNUWEhSQ1BMZ3A1Z2g1eDdQd3hDNkRkNXEzdXVaVThvZUZJenlIbDUwZDVBbm1lR1oxZ0YzUmtPeWh2ejRDTTh0aVVRWm9nZzZEajJESGMraDZMejdiaWZOTzUyZGJLcXRVdy90T0dmVTdtS1h4NWZIVzdzcTZYT1p1UWQ5MCtxQnlObXczUWVvQVlNSWMxb1FaVHFZcDF3UXJhSVFCTEJWVUFJM09vdG1obkJwaGpFNGxORmo0Q3d1czg5R0loVHc0aElZdkJQMFdXaGVCZm92UlVQQVp2d2c4Uk43a1Q0UjFvQ2VLQXQrVFA4ZGp4M21SNllYOXkzL2pQNlMrYm4wMGVxRXJQS1BPVlNURUpPdUl6MWNJWDZ3QjZtTDNLbXFBeEh6RHordmJjOENnRzNzM1BNSDYzNllwYzViUFhieHUzYnpDR2UrTVdUY2NTcitzMzFQS1YwbWJGRmw5YXQ4bEgzKzhVc3FhTnJyUGtMNEQrMlgwSERHMnB6UjkwMnJhdHJWNExuOVBmU1MxK3A5YkUrWS82SDllTHZvZjM4OXFsUndIc1A0bk5IeDJuQjhGeTk0UkdwYk5oVXplcHU4bDJCdmdsbnordEpCaGJ4aGxMQkMyemdRalhSZkQvMHNjUVNqcWNBUjNrQVNxTUkvQ0NlNGdxVlhoeUgrRktuaDQvYmh4YThIY0JSQzFBN2ZoTWoycTRFV1IwRm9idCtjeWpjOXQ2NllmLzN2ZDFHU0VzYUFwU0VnT0FmeGxLMHBlYW91RlVjUDcwUzQ5aTJhaHcrajZFSEFGbU1FUGJLNWkzaW9tVVRwZWQ0TXRxVnVUT3NRdEoxR3ROVjVDSGlUeWhLZzBCb2JnRjVXb2pEQURiNE1QSkxCNWlWVkNPVytpM2xMK3FnMzhJa3pYWUZDMmxDOEVaVk1wZzlQT3NlRnUvRHAwVE1OOXFqRVBsbXJNQTQralI2NEhIc2R0SGdjOVlONk9YSTlDRHpLY0htUTRQWW84OEhEeTJoNlVBMEdveU05L2IzWHNzUkpwWHg2K3F1Qm5ONzVVQ3EzNitKTVhrdmZjK0JQMlNqNUY1Zlg0ZmF0UWxpRFM5NzFPMzBmeHU0V09YQ2plODUySDZLNmVPaTV1T3VRdzFZOGl1ZnE1SUJZb1djdXBHem54aWRJNUc4SDQvSkxCVUh5NjlzcnZmM3h2LzFXQXptemw3NTRBOGIvVnZnZnFmck5aelZKTzZLdEw4RXFlNjVPakxqdko2TUtjTlQ0NVc5RFlmRFNObitqMHlWR3dZS2dQWHk4cUUrU2lMREZEcXN5RmNTOWhEVnpPeGtzRkhFWGEwZUZUMEJtcWcwMVFmQ3QwN202cSs0SzN6aEJPZkV5MHR0aDZKQjJNN1dVaXFNdDQyd29ZZjZEcVlzYk1zbEU2Y1A0SW5ZTis3cW05U1QwdCtaWmVEZmFjL21wM2c0d2ErVkU5a25lZkV2S1hMVTdwR0ZJdExXbngwakt3WUhGQ3g5Q3FyOVZmc2hBR0VKRTJKQWc4UVh6bHF1Z0VLZ3Y4RTEydEhJemFnRDFCbFlubi90ZEFyQnhRdHM4LzhPN1JZNzhFbWZrMi9zR29ySlQxWHdMdXRCMjAvOUxadkVVSGhYWjBqYlZ4dzM5MDRvVGI0M25wT2NmelZHeFlTNWJOY0N3cWZJTTVlQ3gvSHNzSFBVRnordDdobUk3VitMM3FlWVZ1cDljNWhTdE0wQzRDVDNjV2tnajljUVVXVy9EYlYxdGJMMnAxNWxUK095dmJMbWxxQlorSGhPNjdEUHpSYjV0bWdHckIwRmRacytJSjJ2Wkd6L1B2Y2owZDRPZ2FBblR2NG8wMGdFdDNTRkVOL0dnRlY2eFBMeWtONXM4L084N2tOY0FWb1lQU3E1VEhkblh6UHQwODFUbEIvZmZuRk1HTW5LbWV3NTkrN2FTb3JBN3FBWm9UcWlEVytqaGhKLzdvZWs3aEtxWDgxK2NVWnJmbkZCWlFDcEwzblRtekQ3Mk9QaWFmMzVrMWV6Wm1ydmtIbDYvNGpEK0g4bEdWZHdiMm42L0svV0puVEdQRmN3cUZTcDNqNnYrVGM0cHdoZHg4Uml0OGh2ZUVZa0l0cHRyRXFIWHNaSDJLNmVXdnkvUzJjRVB0LzhVNVJRVjZYR2doODIwRTNpUE80ajBpUXJHOTYrUWcxWFhHdzlXYjgzbmJoRDAwbUtxMm9mRXUvclNxYkVtVVE2aVJRRk5pTUNOUGlRTlFITDExS0JULy9QRGMweWZudHQ0VzRkQ1BDOVpzNFhsVUhWeUg0aGIrOXR0V2FlbEpkUHFYMm5mUjZUT2ZTTlBldTdkTnpCWTMvVVQxbkkzbGR5VXpqVW1JVU9Ka2ROeEN4NlYweG5KVkE5SzJBZ1Q3eXhnK0xtWmpQVUpVUkRJNWVwRzEzUmhtS05ZRFcwYUFaRThnbEg0SEpQVHM0aGxVNW9WT1dLMWdpd3BGbEhvZGhLSFQ5MmxvVEpVYnFMTFFVUFZlbFlHSUlFSHo0b3Z4WE5HY01UeGZBbFNnZmV3ODRGaUNEQjJNcDRIM2wxMGV6UlhrUWNBT0dwSnBLb2dJa29HTUw3YVNVL0Jwd0RoaS9GZTcwTU94WTBFWGRIckdEQ0lpZ2gzb05YQWtkTzJvZVR2UnZsNkZZTzhVVlkvN1Y3bkIvaUduRndmS2Y4YjcrQ1c4Yjhkd2IrdHpoVlNVMGF2akw5VjFJaWJ4QVkycFFXWDBtSGk3WHd6eEQ0aXBnR05mblI3RDZMMEJSTDI3RUVlQWhHd3h4S05FYTJsL0RtNnZBbkhmRG4xRkllN1hMSWhvRk9icjF6cWtXeDhHZHI5bmp4VWtDbWZSVmdwMjcwMWdjdnFLWGxQR3dNY3k2djNabkt0WDJUNU16d0lJdmh5NExtT1EzbVg0Y2w2QzZpYzBIUGZsSmJwK2UvN3ZNcDY5R3NQQXJSYXZQZUI1a2VSbklQQzJXS21FcjFTVS9qNytHRUx3RTZvR29Sc3A4T1lXdkhhTGYrWlVyRThxdDNaVjhNa3B4cmxFTU9mL2szeHJKQThBNmdCaTZiT3BsQy9VNERocER2VzFDK01HUEU4TDlYQmhkM2Jnd1NtdzMzcWZRYjhYK3MyWVNBWVd2YnNNMWJGU0VvbU9wVzVzL0FuQ21ML1ppN3FnVjVmYlkySDA4QUZ3STBpZVBadHViMms3NWk4b29mclhFZlRqZ0J2QUgvemcrQVUxbTViVmF6SnVENVpIcFBkeGU0aWZUTFliUHFkVHlYU0kybXE0cGRNcmhvSng2T2ErVCtsLzVneFRqZWc4eVh2UG5NR05vU3JRUWR5T1diTm13emxnSzJzSmpIRjhoNW1hMGdLeXJnbCsrS1gvS1QrRmYrWC9wL2twM2tDSHRma3B0bTYxZ2liQ1ZmU2hTMzZLcXpsbno4cnJWRENLbitOMWVrZjJtK21GVnlhTkdGYjladGlaeENubFRBTHp4WU1NYzl2YkZjUHlsb3BoMmExYkNzT3dESERpTjY1RlJiSysrL28veVljNmtEZjFKRWtySDBMaU9xRExPZWQwbXpIUnNVVnJyV2dWa3dxZkhTYytIWXFjK2duZWJ3ZUpOaTVjNStldHM1cnBuRExkUW5HcjUrRUdyMkJ5cXF5ZGlkVTBxTzU2UzZQbWd6VG8rK0t4eFhYaWR1WnZPMjlkWWkxY1BXSDV4QWtyUk51enUyZXZEQmswYU1pVnMwTGdzN3RGbjN4UzVQeVgwYitxL0s1NEF6Y20zSzJmK3ZPUjgvNXY2UmR2bkZ3NytNTmFkZFlPK2ZCWS9yU2hJK2RaWitVT240V1hTNnRqcHpONzk4NDhmUXp1ZDdSYXVHclZRdWUvOUZ5MzNDSGJ1UWdmR09BbVQ0MHFrL3Q3K2pITHVZdkxrcDhxcVJPOEhlYnlBL1hNd0xNaUozQW0yMlZMUmVVRXNBODZvWmpGU2tvd1R5QmZpWEZNR0lDK0p1WXhZVURPalJ1SWQ5b1dZZmtOdkNaK2xFSm9HMFpyMnFCd0Ftb0pOMnE5Zm95dWJNSGs2b25sbzJ2V2Y5WWdNdldkRGNwRyswQVNrNStQSGJNU1lBcVFKR3NnczQ2K3Z3cHJiTmxnUEpyaE9JQThGZ3dkdUFUUHFZdmw5NlJDOFRoWFMvRmdySVhKck9VV1hpSWFmNGxXcHBFU09LZzd6L1ZuT1hpWXg0TklVd1dKZWkzS1g5KzRjQXJDYkRiYWFsRDI5bnlIM1VURnBaZng4azdBNE9LNDYrLzRqVHJ1amxBY2U5RVRxNVYvS1ZMcnZsc2pKNXU2NzhxdXZkbU9Cc1QrQ3JqMWVGMU53L0pJak5JSHRLVnVwWEFxelNsOW9PRFE2OFFSVTdEQVR1ckpTYUZnbEMwUTNyb2RWMmU0Q0tQSlVQMWxXUzB4dWFLb29zWnVFMkVtaHA3Rmd1clB2QjU4SXdzdDY5WUxFSHlONnZJZmI1WWxtb3UvaTAveHh0YmpDcWhNSlpkcm03RGtzdU11azJnaWJ5RnZ6RVVnOGE0UlBxTitEWDVLOU02L2NYRFNNaEZPOG1DYW5rMmc0VmMrZXBsTkJRYTM4QlNxQjBUd0ZuN2xIL2svZlZJQWcvT2d1Y0FSRDBHWnhDd01LSXI2WDdTR2gxaE9LMm9UcThTWmREWkt0L0ZncXBPZ1ZqZXlDN3lIS2pPNEVtYXNTRmlNeFFETE5sdnRpd3JBMFVIZ1dJSGpDSmkwdklZVUJkS0pQUXl0by9yRFoyQ2cxVXBrdEYrd1RQT05uSE9yUUhPeTdOYSsvQzlPbHJVcW5sM3lrUFA5RkFmeUdsbEFOaXN3eEhWeUNzMkVBa0kvTDdmRnpOWUg3bWJRRjJ3Q0xVZ2ZiNkw5dlJWTnhEUENRcm9idHVhSFBPMmtkRHJyK0xLbHVOdHh1NzZVejQ3TWVBVGtkdEVUUkxleW1sc0g3b3J0VXRXN1NreUtxNlFIQkFiVVptZWdWOWF1NE9lM0M0OFNhQTY2QUU4eVJJdnBjQzFFRjdGNldpcVAxbWR3SEI0bmVjell1RGxtc2xFajdWdU4yM2NUajFzbzFqNkcvQk9pa2hySFFyN1FjQmZTQ2s4ZmljVkdrem52cVYvTWxhbDBVcDFtLzlHWitRbktkQ05BR3FYSWI3SFVaQkJENDNOeFV5TlczL2d1RzNVU2hxSzByTzl1V04vYjlJR1gxYkIrMHdwWXd3ejZPV3FDZ204T3dMV09YcCtlUmROQXdicnBSc2RndUxMU2pMVm9HdThObXpqYjVvSEhyaHFXRUliODAybTlib1RVMHlTUEFObXlRTnJtb1ZjY2dpbWVYeWh0bTk2Mm5DUzNqY1REV3BLMFRRc0ZJTkVjc2ZyU0dRbnQ1ZDlIZTcrK1pGMjBwcVZYdnFIOWh3dEFTY0FUeDlNajMzd0ticVBLNE5NelI0NnNuVzVFTmNCMXIrbHJqOEF1WUFwcDB3V084NUR3ZUVYaEhXcWhHNjhVeXBBcnVLaFVPUGhXSXZ6cEZ5VnV6MjR3VTE1dG9MemFZR1JRZnJyVW0wSFV0VGFjL2hwTk9YbE4vV2JzZmt4OUFmMmVuTUttTFI1ZGtNWUhCVllZMzVJUEZvMUxxbzlxV3EyQ054MW1QSmdWQmxtWXNZWjh6VjVTejlGVHREbDY0ZUdHQk1GWElqSHVOYmlhU3Ivb2dpMHQrSXZGclFEb2R1QjFuV1RudkMzeStaMDIxNE1mbmRzMHpOWVdScThSOUJwRms4ZnJ3VmhjWjRJdit5NTNpRW51Tm5PRUdLbk9pSjRyWm8xTFNFUTlNWmU2R01DbVMwMHlRZkJNME00TllmcWFJMGV5RjlkREFWaW9xVXluemhUY0gyUFFBUDYwSVlPcnd5VnhlMWwvMU1ITnFhUHpDdlZ5V2RmYU14TzdwVW9kMG1oTHZDN0x0QlJKdTZLT3NUaFcweFYxakxhRVVsdENmRE9meVFrTEV0WWsyQklPSlpRbVNCbk5USFVUbWlWMFNzaEtHSkhBZnZISXN6OUlBSG0ybDNCeG95MU9VVnQySEl6N09vNmkzTWFGeGNYSE5ZMFRNbXhKaE92UnNDM204eXpEakpFSVA3ckFYQXpmRVVsT05OekxGd0UvWitLOFJlajZwWmJwblljMmZhblhra1h6bTIwN2MvTFl0R21mN2Q1dVF3ZkJhaGt3MTNaaTUvQXR0YU8zei96MFl2T216ZnNFZDR0WTJudm9tSTltdmJka3dLSVpCU3R5Z0NBajZrS3VOKzdUb1ZJQTdkUGJidlpnT3VHVVBsWHdYZ2pYMElKNkJla3NUZlk2RnJvcDE0blg5cWZkTDdZTzh5S1N1elZZMjRXc2M2OGxQRWlvbE5Fc2drc3dKb1FudUhhenM0d3hyNW01WWhuUGthNGpvTzE2ZVRUa0VaQjdWK012ODl5aE1Lc2pzUHpqb2hYdm9zdWd4c0hidWYxR2prWGxoMTlLN3pTMGFWejYwc1h6YXkzYnNXM0xXNXZaQU1BZUEzcDN5aDZ3WW1iYVpFdjFTYjBXYk5TTVFsNW1UdFlBM3A4T0FQR2Jaamh3L2hLWVRzK1k1RmhyL0gyZERsT1M0Y2NNZndGK2pQWmMyKzViVGNHU0lSQXhDbHlNRmxlR3dNaThHRFZHaDlPUC94R1ozeDZrTURFTW9mK21LM2hrbVM4L2dUaXM4UlBLcHJ1QjZDZmVhbTNiTTNlMWJjMmMvbXE4WXBPVzI5blJUYTRvMWFhbE9UdXhWMlVKeDZ2RzY5ckJ1MWlJS1RhL2NoeWVCT2paUGg1ME14VytVK0lBUWVWbkorRUV4dUZhMFg0Uk9scEFmdjhIYS9hSkVCNkFodjBVbWw4NUQ2LzNBTFg2Wllzb2JyM0RMNyt6UVJRMzNHRzZleWlXWjc4V2oySnA5aFdOTFZjWENlZnF2a3NFSTRNdTNRNTFXVThoZ2I5WVJ5SkJ2MWgyaFdHaGVKZE5xRE43YURWUXFYbG1EV1ROUThGVHVmTHNiSDdQd2dsZ1VQc1J6N0lvMkNNZ0VYeENwSkRLQlNvMFVLYm8xalNuQm5jeEdueGRhVERyZzQrSkRHMjNTTkY3YXhkMEMwc09EUGFLQ0tqWE9SUjluNFdtRlFDL3drTFllVkt1cjArRzZOV3NlOWtPbXZPTjlvZWhzWDgwdEZCL2w3NUNJc1BSQ3lBNDg4U0hxWW9hVnlnU3VrbnVQc2p5cVBmbFM3R3VSakxhazB3cEpLTjlkYlZzQWVyZ1dVYzhacVM1MjR3R3JwZllsMkhFb0E0ZVRZU09SaHF6VHU0TG82bk1WRkNlSjl5VWlNOVd2SUlOb2hzTTFlZ21VRW5BVEJQbWFwMzBxOUVPMGtnRnRsakNSWXdHeVJCb1NZcU9pY1pMSkNVNUpTa3hNQ2c0eUJSVFB5WTZCdCtYRE1RQklUZ29HTjlQVGtuR3EyWGx6QXY1bDk1ZXZuem05L2tYWnE3TXQvWmZuNytwLytqUjJSdnpQKzZmVDViSzF1WG1pUVdtbFZ2cGN0bjJ2aW5mR3JCOEczSHdYRERPYkIxbktsaHc3LzV2Q3lhYUpvdzNqMXR3bjJPNEp4UHd1dGxQMjVhcThZR3Q0SzJnRWJ6SjhVTTFyWFpLblgyMWUxOU4zRHlSdHF3eHFLKzJETGNHdDFqVEpQeWoydFJBbUc4dEh2SFdXM2syNjFiOHo0aXRxRmRtNm1UcnhOU3NySTRGMXNLT21kTkgrYisxNGtIRS9SWFQvUE5HbXFldXdHdHB4VlF6ckw1LzhpQ3oxUm93Y1BMK2lEMVRCZ1pZeDVrSFQ5bERlUUk1eThzeDFPZml1R1pjRys1YlRVUjZoZHdXOWV2eHNiWkFJNW5LdmlRWXdSN3BTd1BRSStQdGxYd3BXRU9nL2tqY1YrK3pIRk5LMGg3SGxkcWIxaU9JV3ZoU01yOWVVYjF0OWZpTUhYNzF3dXJCUEx0ZmZmeEwwL3JrbC9wRjliZlZKNy9VRDZzUDgyejFpQitGcmI2eHVMRVRiaHZmTEc2bStZcHJiMTVxYXg1dmE2VnNUbmEvVmhTY09pVlp0ZHJJNTNIMWs4TkFJRkVaWEkvbDhKNWxEclJFMXFCQ3Q0WEN3T0VsRlVPR1I3Z3ViVHovN1ZicmpwZmlkNHpkZHY3Y0pzbTZoQnc4V2xkTnpuLzMzZnk4c01ub3o0WnRPNlpQeXUwRWpNTlI1TXVOWjR2cm9IanprdU96NzI4TkhqaHc4SzN2WWROTE4wWFlhOWQ2eDJjZmwzeFNCTDVETVVXZmxId01tNjdmQmRxL3VhcExjLyt3bkhFZm9LSzRjWE9tMC9HWlczNVhQQ3YrS28vUGNUZUlBZjlxZkNKOS81dnhzUmVSUzI0OWtFY0hoUTFQRWJuazFnZi9ha3pzelFQSjZhaHVVUDdGZURRR2lZSC9ZanlHU3U4Zk8vN0JzSFd4c1d1SGZuanM2Q3BwNkRSeWtKby9iOVNRYWRPR3ZGdDlDbnJZc0YwcUhvODBZTXhGRVM4M2ZrZG9ETVVMcDlEOTB4Y3k4WDhYVGdQVHFRdDRQRDVlZ2U2L3QzN1Z3b2NQRjY1YS94NHdyZmdZREg1elZlZm0vdFZ6eG4rSTF0RFJnT3pjVy9xRE0yQmQ0U00zNXp5NmFBaDZxT1VLZDZrM1pSZ2tQdFkrMzRCNzE4OUFRdk1OSkV1Um9ha0JTMUNZRlFKTnAyS3RTU2kxRjBxNDFId0o1TzJJbDVxUzlNVis1SVpmR0RWNCtPdEJNdWxCWUZKRWNBVG1IT0kvSFVWRFQvZ25SRHR5K1doM1IrclNCNTA3anh6NSt6K2RxME4ycms0eGxtdHlKVzRRdzJpWDZLQWNYYmRKMWlVSFNXODBKWmQ0dFhNeXlhV2NYTGFSZkJsdSt5ZVRkZ2U1Yk1PZFJMd3g4YndsWHcrU1N6bStrT05CNzFLN24zL1k4N29zaFhYWlA1N2VneThCZkFqUjlseDQxZDB4dnBqWnVmUFVxZWo3ZnpqTUI5dzB0RWpZakdYUEVDVVhzUzVpUmQxWmdOTVQyMTNVSjNRVktnbXlqNHpiSUorQjBpQ0lSZ0RldDE1SDkwSHRQMzhGb1FJY2NlSFRnN2R1SGV5SUZvRjBJK2dKdkNoTXc5UHZKZHN4ZFBIVy9WL1Fkd3l6YkJIRkxOUFRXR0gzK3k5b2RPZE1pR21jbVgvNDZwUHpXMjRKY01pR0NldHQyemEwd3dUMk1vSFlId2dVR1QySlJidHI3eThqK1ZBb0Zrd1R6b3ovaDFtaFRrM0g3eEFOVWJ6RkhKVWkwcjlFSG4rSHpVRkVNcnF5ZCthUDZHb1NpTHFNZmtnQmxwUFRmZ2RSRGJHc2JQc2tjeE1xQnZNMjk5NE1abS9PMmd3R29wNmJlMjhpWTFYMmtYQ28zRTk4ak9lM1A4a0JVY3pyOHFMZ1dST0JtWkxEUEFLZzRXS2pDU2VHN3NQUEZJckI1VjJsUUN5djF1SHMza2JNb2IyTjJnZUpNRVRqam90TnV0b1NhdEQ4cVJicW1vMzFwcVN5bGNPQnNWUHVwRjZwYlJ1aVB5ZUhpYU0rSEo5VDNiOTU1MVZ2a3R3T284VTQ5SXJVQjh0NEhwd2RpSHdzV2Y2SmdjRUd4K2paVFJxSWw2ZlBHUmRIeW4yTXkrVXE1WGlPbG90SmljRjBYMnZRQkx3anhsRmU1L0hVR3gwRkg0bmJPSll5cENtWHhtVnl1VndoUWR4L0k5N1dQOTQyR25OMFRYZmpHYXZORTJON2d4cGMzekFXOTRJNkdhOC9zVkhnYS9GUXpmMDZwYmJSUmx0OWNpMHUwTngvcGRUV3lsajhtcTVqbUkrNkN1SGgrdDM4RDcvL3A5OWQ2eXNyaDhLSXpLdzhBUTZzbDVBUUIzNkdZbDVXMWtnQkRxcWJtQkRYbVg0alArSnY4ZWdiM1ZkSGQ5MmpqamVoa0pmVkowOGt2OWFyaTI3aXI1bjBhM3o5ZW5VYjAyOGpSVGdJZjRzWC9wVFNCZ3hJazJJYk5xaUQ3a29kQitMUGRSbzBqRVdlenMrT0o1cjdQMG1kY25JNjRjOE42b2hWbEdlZlg1N3diNCtudFZBL01GQTh6Z21jSitkTFQ2NnJjeGJNeStOSjlnd3NSdGlxeGR0aTRvbFpxbEo4UmQyTHNub2pXWFZpTUY1emZBeGViaUJGREl6Q2F5NUpCQ2xSd1pJSURHSk1GQi9EcDVoQnNObkFvOWhLNHpOYk4vQWVsOVVHVnZjQnFXajlzekUrYUR2b3lhK0VvSG1yS0ZSZWhubnNvZFlnT3RhMHBQbHhQdE8wdE1XeFYzelJGdEJIK05BWGRFRnJrTW03b08rcmpjZ0ZiRFd1YUJWY1hEYlB0S0wxRi9BbkNOcTBSdWZMYmtDMDcxWEE0cWNQb210aVZ5VTIzQmpEWXNOTkJzNVBlTFg4dWt1TStGcDBUV2loeEJHUXNpU09nSlRsRStXeVNqeUIzaDdiLzBYMldOWHlhdmVIYml5ei8vOFlZeFZiYkQ5Sy8yRE9lYkxuRm5UaCtlWlhrODc4NnYyL3RlSjVGbGl4dldNY3NjQ0s3WE8yYnkvYkl0dGZJY1hEV0lESHdJam5iQXMzMGV4cVVETUhlZmxNMWdWRFNPL2RSOXdnQ0hGWUdRczJ4RWlXcUlpRWxKaVU0QlIycUFVUzhzR2puNTlOTWhobWRGZzRhQ21hQ2lZTmFqK3l3MFF4ZmNkT05CVm1PRDRTYlhjT0hSNXRrTjV0dGJaZVR0alVWdlBGWHUvTTJTUExTY3hYSCt1VHRiaCtiankzZE1jSmRDUzhYR2VTdHllSmdiZWJBanhacEpKT2tQRjBCVWhYV3lHam1nWXpKM1NMeHVtY05BNnJ6K0p3ZzJGdzZxQWVCU00zSjF1ei9aSTNqejV5MmJwMjliaGwwYlZXanU3WE9pOTFhQ2RRL3VkQ1Q0KzNXazV0MUxXVDQydngwb2FlZmRHWHlIRWFDS042T2Y3dWtSTS90OFdNc1o4UnVZSEU0MFlZL0oweEQvOG1GdzJ4OVVvYVZTR0tPcVFrQ2hFT3ozejRWNzdZRHBDa0c2QXY4WmZHODdheHVOaWwvbitJbDNPdG56bThKUEtOSFplc01DYWZ4VlNBSG9UK1dEbVhqbzhpOTdpMTZ0cTlvUkxRcWZXdkVZZzNGYkhHZWJqa1NRVU03RGFSSllhSDg5RkgrUXNXOEVNZGxVQUdQT0pvREkva3dKazVqcXNjb0lkMlRhanZad2MzcDhicSszM1krMzNpWFVJbENGaUE1SnBUcE1MNys2TmQxbzgrZ2lzZFYwQTc4Qmg1Z2NjNTRJY0JhQmJKSllSdUNlMG83bFEzTlp1bjdtaEFOUTBGdXZBQ2M2RE1DendyK0lMN3U5Q1NHTTZaQXFBTXNCWUxsRFJFNTRBUFNQN2xPd21zL3dUOGVlRWN6VXJrK0IzOWlINjZnVTRJc01lemc3ZnZPT0taMzBFUitwUGZUSEZZblhUcTFwQjZDaGZnUXFkL2dKTk9MejJkSmxjNkU0VEFJRWhBQVZPU294bWRmRVBIbGZtM1FUVlE4bG40OHVrUVh0NCtuMFpnb3RWM2JreERmMFZsUk82emJ0dnVlS0xFNkFTalZZWkFpZ3Q1ak9ac0hDdjUwZnZWMENySmorUlFCait6KzZJbmk0dEVyeFBjR0h6L09Mc1Bpc3BMOFAzKzZBMFNONGp2MzVUdko1WFRYRXBvbFZpVitrckdzZnRFTVNNK2FtaVZVSXZXZjRmZDV5MVU5OWhKY2xMaExnelFlVWZxZEZhM0xneXExNExaaStabk1NZmI0ODFFUjhNWFhab0tJSmlwT1lLNnBoQWZCazlvWWQ0Q0xBNk94c0lKUzFBcXVMOE10ZW1Wc3pBL2YyRk9QekJKdEJId0hMZ2RYUWZWSGFuNDIwQlFCY3RIeXpITkJKTzhLZTdRQUFWTFIrZTdwUXZmK1FlYWQyU2FjODBrZHM5Y2FDYkJYbVlTN0dVdU1zT1IvNklOQkVXRXRRRnZXN2dOUG1nOW1MTWFiZStROC9hNGNXL252QVlpaElhT3g0NVM4T0MzMzFoUTMrKy9nMnNjS1ArTDQwUkkxOVEwTi9xZTdzaFU1NDJocGdIdzVUMDFDUFphMDRNdTVORExrMmZ3cVRxUERZRkc0eGhLN1diZzY0eElsRGRma20xZWpreUUvbC9rWDc2Y0Qwem8vdWV3OFV6b1dBK253M2x3aStOMTRmMmNyVnR6MEZpNFduUTBjRVRRR01WS21FODlsaXJqTm8zU25QenEzRGdEM0kySnMwM1F5TnJrMGdUNFB6UUI3Snh0M2JEQkNscWgvWlBBb2prUXBZRWYrRm5Rei9HN2NESG4wcVVjeDJwd1ZFU1ZIYnRGaG5YT2NkSmdLaitNZHVQTm9ETUc2ZHFnK3BwNFFObmliOC8wSU9OQ1lnY0xQZVo3Nk1lRjJQeTFzOHNIZURnYkVaSGtKSjhmLzBVK0NvSjlYTG9maXoyT3Z0cStUOFR6cVM3RjVNNzlweGpJZjZLYmtzd0NJZjhya3VIMTllUFFDT2pwRXRIS244dlJoclRLZktvZDVWT3hNcDlxeVdKM2lic3A1VlAzWkQ1Vm40N05mbzR6SEtMNzhCUTNIa0k2UHZVYzd5cHZMeTF1NERidUlNRU52T29XUXhBYVhWTFp1UmlPSXVpK0tRZUFna1QrRmI2ekl6cWY0Rkh4QXZ3azUya0pYTzNvSys5TGVHeW0wdjE3c3B1WVdSMnZlZzdkakZkeG1GZmg0WVV5NVhrN2lDSk9XQlpwd0h6OEdqanlQeVE3R0w0S2E2QTNXT1RxbStEbkFXVXZzZWhWMnQvYjBYMER5ZjlhbVdnek1xSzR6cEZYVFV1azgrZmhUTUd5RDV2ZTJ1YVN6SmZrV3RmSG43Z1JBYWdZOE1OR25SQ3drV1ZkNDF1NlNBRXh6bnlGVkJhUVpsSHNnSFNWZHQwaHBNN1h5aG45WlF4U2FTZThudE9oNnhQanUxNXVvYkN3ZW1tQVNnVGZycjhISW1SeDROcXU5U3hPRiticDVRRXRSa05CK1UxeHFYaUVxODI5VE5ITzQvRlVxS2lCVVM5UjhnV3ZSUzFxQ0M5UnNzT054VWw2QnhPc3o4UnB5b1h3Y1VSZGlJbWptMEtRMFZhNzFGWTdIbXZxN0lpVDJKL3IrNGRCbWlPTUkzNmkwVERKUkZNZkJPS1JNV0FGQVFUNEUvQndHY2haWERyb1FKYzJxN3VpVzJqN3MyTVNYTDRiK0Y1THpJeGRXSFRSYnIveWxyWGh0UGFPTGlzV2o1KzJiRXJoNGlvV1MzZ0VlQWZFbjBhZ2l3aXowTStuU2hGQ05oL2YzaUJxTytCK0FYSG8zRDMweUladXBQdWI0QnViMEtNTzdZSEhPdUR6NmUrUFNBelUyUEs3d21Tc0w5WEdjcjRjTlVBN1JLY2l1VjFKcXFmV2Mvc3QzclhmYk1tbDlwQmtubllYbjZ4Mmw5cFhMQ2tTTlZZd1dCbVNpb01CWDVQb051TG9rTWduT2ZNd0pEWUJ3dVRYbDdWSW1kejZXL1J3L3hLcDkrUWpIOWRvSFRZOGY5MnNtUnZmVEgwcE82VW9wMHUzck54c3FVMmFkN1dxNGVHZzllUFVyMEFsRVdhZVhaVjJFdjFkeVR2MXp2ekJuejFFejQ0TkxQenVOVjlmY0dqSWtoTzdGdzJmK25sS2c4OEl6aHVXRXoraE1WWFJzang0aGNxSmZkRHJKQVljMzI4ajMzK1QzbjhKODFsTmpuQjgveUhsdjNYUktoS1RqZm52Ny9MOVNSWHpCNUk4S1N6L2xiOEVGdEExSi8rTzk2Q09iakROZEVjaEtvNWNLOHhyN1lJSGtNSEZ0WWtYS2xGL1h4K2EreEJ6MkVBTGMzMUt3cC9oVUhEa0hmVFMxdHRTUG5RY1JuSHZ3Smw4cmJMek9aVWM5MkJWSVllUFpmWjVPVCtYU2NsdHFOT2JkUDc5bENON3VjNFc3U0d5RHBTK1ZTVzhReGhMS2RhN0tNc2RMSmNYb1pTdi9kajYrREthemZKNWdlZ0NOUHVLZ0xMQnloeitJc25weGNlVzFhU1ljTGovRDlMK2J5VHZjM3RZN0RYdS8wdWsvMG5zTmJrUHo5SDJXTkFIMGxEY3Z5WWxBbGUzLytsa0U1VXpRNk5yTkxCSm40ekhtMEtiK0RGL2Nhb0tPcEhrd0E2VXkrL0VzMGZGazJ1Zm5mMnNxaE5SRG5DaDZLRHdHNDFWVG5lenQxWHNjSmttVGsrVHI1NG1MMnE1OU5GcTU0dzBsYkIyNkJ3OGlxNHBZZVA4K2V6c3NnVnE0RGlKSDhOOSs1anFXTi9LZmZ1QTl1MXczTGNPT3JjZnkzMzdsdzRYTDVScnAvSCtjeXVQcXdwM0lCTlhBK05ka25VUzR5dUxBYk9ZSk5WdmdScU5nbW5zZjNLS0RKV1htZlJ5emkvV2NkWWUzYmJuSk5mdnB3RG0rWGtJZnowQ0F3Y3gyTHhPSFFIb2pqYnpIbjRFUGcvVHVoekwyVi9RSEJIdDNKd2FVVXlDQ2pIeG5zQlBkcktWU2wxTzRLaDdjTVNMU0Uza3Y3QzJiaGRlZmNEQnJKejgxczFtRFlpSWJFK0Q1ZjBrWWVNNnNYdHZGakxmc29rSW90QTEzdUJMSXVjQjhha1VGbW14Qm5YOHdEMHFsc1FCMlZWYkJ5MlpLQ01tYUdPMU5sajdIeGgyLzZGMSsyNEtOZWdZV0szNjJYdG9HRmk4WjAzMWFvNk9UTmRlemVMTU1NL3FRUGZaV3VWM3hJVjRudzNuYWlsUlA3cGpUWVVxZXlBRC93bWtucnVCdXBNMHNtWTRmWUFvWGxUUlducEZzcFhHQVJyZkhKeVNKR2ZaVktJdmduMEJVQnk4K0dKMEV4MS9kN1VBTTNQNlNTRHhwZ05VTDJ2MTYvMEpoenJFdERybG1NbTMvdmIwb1IrRFFRZGdYT2xYdkZBY05Na1RCb0ZLSUIxdFFwY0dyN2lLN3JSSTZkSGdOYjV6N1Ird2N2ejlKUTZXLzQzM3lZNFU4eU5hYWFPTzJhbHQ5T2Q4NWZnU2dZSmxXdlRjbDN1Um13RFpDUEVXR0FlU1NCT1RtWmxLem1sR0dzaFRoeSs4QVVMN1NmUm43cWljNXMycmNPV2JQdi9KSVJ4ZVBXTDF5NG1OOXkyWXZzTVB3dkhyQTBHZG13bEI3eFYwR21RKy9xVHNtNXpRWFkrYk5PelNyQVB2T0xsQ3JENzNBQm5IV3FnVkdUZi9hRGhZWHJmZmxuOWNYbDcrTitwRjJvcnZENUgzcWovS0Q3ckprMHl4aGVtWi96RVpEL2FpZ2tmdG81ejFVN3dwZXRiL3MxeG1ETU1NcWliNktyRzJPOUVwWVFPVmlRZTVRU2pYV2Y1MWlXVnBuL3RyeFUxL0YwRjBPOWJBaEZpS1VzNXJaUkhNUndTTlhHeUpVTEdEOEM2SWQ4WTdpbHlNanVmbkY4T1lXWkFQaDFnMHZxa1JqZHZqNVRFQ0xwRHhwajVFZi9JM3FXeU0rWWNzWnVweVNPcjhTblNoYjBvMDZmWUEzb2U1bFhGNG5zUlREMlVYUVZpbXNlNlh2NVljaWxnK0E4SWY5aDRZTjI0RzJMd0F3cTdtS3llbklsUWpJM0xuNkMwYlZMUWpPczdYbUU0SVRsQy9NaitoWWZsMWZMODJ1aWEwcEh6N0YzYWZyMTkrbldLSWQ2QVk0c0hjYS8rRTZha29LTTZkQ1cvNDJ5RXcwL2hoRnloYnV0Zm80N3NqYU1KTy9oWHJCL09ySjRYNitqWU43TllINjN1NGE5K0Fueno1aTBSeDl4TXJUUmtELzZLS0g4bVIySUUvVC90NThqL0ZhYnFselE0QzVSRGtIWmtnRnhDOUR4d0VSTzhEaFlEb2ZZRG9mYUFJWUwxUDN3QVNsQnp3cjlvVGhMZlFEK2FIMWNmdGFSTFVyUS9XVXhoMDBiTmh6dmEwSXdNazI4MDZPZlYxUERiTjZkZ1FHMWx6cDc2T3h5YUIzaWQ3OERMZEhseFgzWU5YNi9iZ0ZNVXVKOUh5QkJXSTFDTytUZXZaaU4vN1BpMS9WMzd2WEhyZmRZMVRMSGV5eHJrYU11YlhMUVh6V1kzQnBSaUlvZ09YYWNYaWEwZW5raEoxeFJCblhsOVdqNlRVd3czbXRyTWNEVVlSMTBNczlUNnFmeVNyNzVoU0h6ZTRHY1V4cUd2QTlkbnFza3grcEp5SjR3eGhsTmEzbGR3TzBuZ2E3NzdCaVlWT2FhOHAwMzVVb1YzU1l5WTRGRndGWEdZbVI2bXZJUnFVL0Q0VHkrK0tZZUl4NnRuYjNNMktVUHd2dDN0alFUbldWU1UzdURqemduQ0dLVW9CTlJtU0tGbmk1Z1QvbEJpeW1jRXRvQ1pvajByK3d2em1nQkRyUUZOT2RJeDU5Zno1MDQ4QlgvYm0zK0l4dEF4ZDJvQXVvdW5nRFJBekp2MFJxTjh5dWNmTEhaKytBMTc1VlV5NmhtNFJtdDh1djhlWENXbVU1dlRuWmZxaUZoWURKeU0rNittMm0xbjJZRDM1eE1OQ2p6K2krQ1ZIRTJSVUprWFExaVRUMWdUQkdpZUJEM3AwNFBPZllKbHVqM0xNV0Mra29YTTNVMjZqMDVyOXFZeDM3ayswMzZXTGVCK2FJYytaM2FBbVJiUVFPUzJpQlNsTDJ5c2V4V1Zuc2puVEk0Q1VqRENRa2hFc2VOTzVaMG5LbnNVTkJtdlpQS3dpK2lnWnBwVTYyZDVsVS9ZdVhMWTV3MGVvWnNCN2w2MGFDVFJSeWxJY2VrTlZaaytndE00Q1EwalplTEVtTGh0dnROVlJ5MUpzUXJMdkVoc0RvVFhNVEVzYWRDVUJOeExYV1lubTVHbnV4dXFxK0wxdGwwQVYvQnl2VjBvcW9BMFFOSmhnNEI2b25oOElIYkY4TmtRdGJ2eUd5ci9haHg2SU1HLy9zZzlLdGhlUEUxdUxPUm1PMytHTmM0ZC9rUEhvZDI1ZytXcEhvakUwL3JFYTVsMDY5cnM5QUhnTHNXNEoreWRLZWtOSEVxR2szYVVIQ0ozYWkrN0xsSHkyZlRCL1doeVE0Ymp2OGRPcFExZS8rMUthdlh2RDNCMGJCeWk0OU5KVE5YZEdIckNBOW1RTiswZ2VlcHlBSWhVbklJK2JVbjdmcFF6RHQ1ZlVlZ1p6NVVxK0pBOWR2aVMxUHB0Y0h4N0RERG96VEFadFNRVlhuc3dMNHV0TjYveWF6WXR3MFF1WERDZkJha3FkTENmMVVUbG5HYTV6QUozRDRRWmVVMUtMVlE4ajlMbEZZYVFUeTk0QThGcUlrTjk1RjNSbTY4YkxkZDJ3ZDE3RFpTUFpPenZWWlpneHZLWWtMa2R4bHczVmNIc3Z5M1dlQjBOSnlXakt2Nk1aRWlhcmsySWZrWGFBTWxabks5cU9hTm8zU2trbG53a2R0Mi9rTVRuSnhpMVlDdEJqTjZ4VHNCdTR2RmNmYVV0d3pyd29rbHJQWU81alpVMEh1SzVwVnA5TnJXK3doWTViRllPMnBGcG5CelhYU2krUURESkl5VENlbEF6VHJuMVc1ME81VGx5V3MzTVNMVXZ5eU9uTFVwMlkwdnF0VE9zWlJtdGxzUktMRXdoVXkxS2NOanJISHN0OGd0SmEyZUNsS1VueWxXQ1pJSWFXeTJON1B6ZFhzVTBTR3pmRHVURksvTmhzVHNsdkltSWVhSXdHMzN0d3hoaXVqckJLNW05TEdDMmhkSjZFYXVtbU9HQ2lEVC96alBqc2NIOEs5ZVJuR2pPZUdHcW84RXdWTEVlMm84L2tSWExHYUg3THFsYVl1dEVjT2RtaSt6ZnV0eHloSWY3OWVrMzYrNGN6Nk8vVDVOOGI0ZWUvMVp6bGpPWTN5MmM1SGZqZk5XYzVvK0Z4eW8va2ZBQllMc2h5ZzZhdHc4N1EyV3ZVMkYrVEtDUFk2aXpaN1FYaUZFdVBkRHhMN2MxOVFCNHgwSkFFSnZpU1JMRnF5UUhWaGxKd2NUNTZFM1ZkQ0M2Y1BveGFMUVFyd01xRnFOVlJ1TnZSRms1MVRJSzdjK0FpeHlJNDNER2M2UXd5SHFBTHZjOC9TNnRJTDNSSGIrcS9vN2ZHYWRCN0RqcUZUczBEdlV0UG9sMXo4YzlSODlDdUw4RGZ5QU44aFJMQjN6bmdNbW9EOXFJYTdEejlOWXJId2pEZ1c3czVmVkJSeVRrZXlDZit2TjVIZ1hPRlZ5TnhsaVNEZWpMQnZtRUEzUHlLZkZUdDV0T25OOEV3dEhqSGp1MDcrZll3NTJtblh6N2RmOHRSRlJidW1qWjdMNTREdVlUSDBET0lWeFhhSkErcVEwWW9PWXZkNG9YYkRaeUhFazlyTEk3UUhaRFpUZkp2dW5PSXV2VmtDb20wbjBKMU1aSVMwK0FMTERFS3piQU9JemkvWVB4MEFZUlhIeFZ1Z2NKM3EvNWtEU0NrNHlac0I2Qm9ibWY3bXdQV3BoNytPcHUxaE5LZVczNUhTcFVxYzVGY29wS0Q3UGtvbWpRUnF5dTZnMTNpcWRkMWlENFBxMzhZemRWYUxZeWFKbmpkZVFyeG9IbEpoNTRwVWZ6R1pLck1HTHlBUlZMeUdnSVo2b0tkUThTQnBOenZqdzc3S05rS0J2ZGV0azRBa1dGakluRnpIeDBjc1RRaXFYakM0ZS9oejdVV2oxNWR0R3IxcVBkcVF4NEdBQjZrOUhnZGpuM1dmUElzK051WjNsOE1CWVY3MHRGRGRCUDJIZHhuRUlqNEUxaTZEMFdPcndPUDNoN1kwei9DUkd5djViZkY0M2c4NnlpWWc3cmxTd0ZBWEdNR3hXcStNa1Nsb0Q5aDBYWkpvRURnUCt5UnRXUUR0ejVhVlkybkRBVzRONUw5bGJHV0lPa05lSG54N0lNYmR0cExEcUlWWU1COXgrekNVZjNCd0c0TDFndkFFajQyc2dZVUh1NWRVR1FBRTJldXlWbjY3bHVMY283c0xkeFRxOGJXS1duOUN5RGdEdmIrY3VqVWt2Um42RHkvYWpOWi8zSGxOd1dDT2FTMmtRWjl1eHJUdFBDNGRrOGpDUWF5aDd3VVdSR3EyaGFwaStlMzE2TEkxWFhyUmFrREswOWIzQlFxYmNVbzdZNXh4cEhDTDBDVHRNbXpCVmlqeG9USVNDRDhzSFp5b1RqWmVoYWVuanhyK2R2b3FRUzhQN3ZZdDFmbUcrZGJ0WUxiUDBoZDIzSFEvRmN2M09CenAzVHVsdGwvY05lTWNmM1dMK2hTRUZuTjJwM3l1TDdvZS82NHVJMkw0blp6RlkyZEtwUVNWS09LZk1WZ041R2ZWOG5ucHI1cHZsaEYzK1lMOHV6bDVPTG5DMGJhNTVQTFFYTEJENHpjOGJYdlZWS29VUDQ5VDRrWHBSNGQ5M0VKbmNkRHNONTJWZDJIVFNHc0x6Z1B5a1hlWWs2eVVFUFU4eVpMUUhBaWYzeHdsOVpSVVdHZnJQeDIzZkdkTzNlaG4wSFZPMDluakorWkwvVTFvWHNnMkNmcXJkYlRaN3lmWGZUMmdwWFpYeDBkdmF0MnBHM2FyRHBSYkMvSVE5ZjUrVFJXZnBTbW45d0d4enQ5VjZoTkRUaTdMa3J1T3RjbUJsWnNJbjdROHJ3bXF2TWl4ZGxFbU1qUHh3MnNIK3o5bHJVY1hIMTM1dHRMMFNrSUVvNThrNVdWM2JPckYybWhvWExmeEt5TXdkazUvYk9IWmE5WjJtTnlSTldwV1gyOWFmdGFsTjgycE9IMUhLSFRScFY1VUFWL3FhSzB6MTArYjd1WGlaUHhGYldwKzZxNGFxTXlFNnV2WldJeVdCeEpGaFVDaE5PTWEwV0dqU1ZNNi9HQnBSOFpISjhmdlo1VWEvMFMwZlpzb3l1SDRvc1A4Yjg3U3RBb05EY2J2QXo2UWRrV2p2bVRSR3o2RVZ4dnJxTExnUTRpVE1WUTlIYXgwZWlEMEt2ci9PTHN3ZFc5R1lmU3dvbEg2SmswVzh0OE81UzlmRk1EVUNjdkI4NEMyZDJuTDhROE9Yd000VWZYdHM1ZkxmRm4wVXAwREgwMUJEd0NQdUNVSXd5MzhhUzl4OEZzVVBCSjEzdC80eGFTbkdKNGZLS3ByV2FxbS9HaG00N2JaTEF2R0N4NzFlQVFGdHk4WTF2VmcxWEpHcXhLVm5UVitlUnpQRUdZdTZyQ3pBWDltMkZrc09EQ1dqQ0VEU0Zwby9qb3dOSzFrc1BMYW9XUGRRTllzSytYUElDZ2xhT2ZhSE84RHJld3NYc1hqMTBJdGZYTWN1UGIrbno4ZkdXVzJpVW91TU9vMzdGTk9raitLWksya1FneWdsaHZ2eS9oeGdIOWxOV3NUcnU1aW9jeXpETG91ZHNoN3VMWWp4dllLbDhlWGt1WWMzakJYUlFvTkVTQjRLNHlzcDhPY0k0c2FlOHNyTXNzRkkvaHVkckNUVnkzYWpNeXVNTDY2ZmhHVlpxZ2hGb29RcWdqZ3h4WkRRTk5BZjZhL1VVU1lNbGY2QVJJL212dyttWTFXeTU0ODh0Nzk3N2NVQ0tBcXBYenErTDFoMzRQQkJsNEh1S05CUFNPaWVvZFlVSGZmWS8rL2dGOUIzZCsyR1Y3Lzhrck9sMjh5Y1pwREpieGpsQU16cVp1WXNGVmdBeXQ3Q3Y1QkZSMDJzWmJJSnRNSkpNNUZXbmswQ2k1QmNUWEFIYWNNWWIzcVRUYXgxYzR0ZTZ5NDg4enZkNk9qWXdiMzNydGhwSk9jUFNBQmhOZWJqVXFhZlZhMFBCRzdldWdZWGhZWnRWUTlOUld1eGc5WWJSR1lIa2xGSytmRUVVeTF0bVJWZUNKaW1iYUlKMC9qOTB2Q01yemdWcG4zYXdEV01QaEVDWTd5aUJiQk9HVWo1RkZZQkRiNStTVStiRUY4T1VRRFFmRDlMVXN2eTJzd0hOZVQ1LzMveWw5Yks2QzQyZ2kvdzdLdzN3V1QxVzhTQzFZalBoeHk1SzFIc1NpN0ppRzZmdDBmWmZ0R1dCTVVkclZ1OG9jWFlUbjZIV2F4N0dQRzk5Tkd0Qkl4bG9yMzFRTzk1Unp5Mmh5RjluNWtNck9mQjBWRWpqU3N3ZHpmU3JGdXVZcmJnUUMyUWNaeVl5Y1RpMTZiOW5NSmNCUzlqMTRTWVM1dHphZk8zdnF3cTVkbDYvOGNuYmYzVndvb004dU85QVg0SjBaOXBqWWJjTU9mM1BaSmszYnNIYkdqS1VERnE2Y3YySDNIT25reFN0TWx4MVMvaHYvczlEQlh3S0xPR1o3NnlEMmNOcGsrTkZDSEwxZkcrdThyenR0TWxqbnJjbk96MUVSemFsS3o4K05CcnlFT25BOE9TdEhSVFQvRUQwckovZTV6ZlErelhkSWM4N1daZGlaOENETE9SdkVjOHJaeW5KY3BsQzhnc3Qwa3N1YzU0SkptZHJPcy8wR3VNd3ZOTTk0UTRhdmljWDVURmFQZWtiVG5PYmdQZVZQTEtNc2QrM2JESU16U0FqUTF4T20xak1XZnNQb3FlSmF6eGRxUFdOaEc0YkxXOFcxSGttdFp6Q3dQL2VzaDlWblUrc2JES0k1TjZjOWN2OGUwL1Z2UCtFR3MwV2dZN3IrN1NmN1V6Sjd4aTdWTHRKSHVBaDZzM3k5ZXJ1SU5GYTJZNUF5MlhqUHdXWHFDQ0ZLR1ZiUFZxVWVmaUozQjZSU3U0Z2dNcnRJWmExZFJHZ3FEVlBzSXZ6RXNkN1VMaUxLZHBHWFM3VjFybGZyTE9DK0I2MUpTVjh5cnNRTlJEMWpLbjlDYWN4VzZ5d1lLSkNTY2JUT09DT0ZtM0hXK1ZpdGM0S3pUdEdsVGtybnk5Sk90YzRKTDZ6emtWcm5lTzRTU05iVnFXczdwck5FclhQOGdMOTBkYXB0SitOb1NKVEhNUWE4eWYwQU1renllSksrOTlYWXJjallpbi9JWXhzTjNoeFN6U1NQTUNrWlY5RitkVktsZFJ4M0diekJ4a20yWDRXNTBEcGJwWFhjSUxOdW5KcHEyKy9ocmRZNWlic0d4dXZxck9aUzUwbTF6a25ER3VqcWZFVlhaNXBhcHhYWDJlNUZkUnA4MVRxdHd6eGVVR2VBV21jK3JyUHpDOXQrVnEwemY1alJmZHZwT0RWUng0bmFGYlhqWkhRZEo0YzZUdDFHcDJySFNXZG5QSWkrcHZtUHFjMlBydGRkbkJlTjkvaWM1c0dpZGo1NmZ3b0hWUnZoTHRWRzJFZllxYXhqdlkyUXJ1TzJjaGtyVzhjYTdIVldUNEphRDlaeThOekRaZnhFRjF2ajd3bytPMGdmRlVCS1dCUkxvMUxQZk1vUGFzcjg0RGpqQi83RVprbENHSjFyZ3RpY3VsQiswRll1TzR2elp1ZjhNdUs3MCtiVWp0SzNYcTIzZ052TjFpKzFoWkl4ZEs1ZmI5cmViSVZPdm1BQ1hiK1J0TlpJbzYxV3FiUE5iMU9lVUZQbUNYS2RKbHFuU1Zzbm9iVUQ1UW1zemdrdnFMTUg1UWsxWlo2d2kvRUV0VTVkK3pHZEpXcWQ0OGYvcGF1empsSW5tUk9VSjlTVWVjSSttU2ZndVVGR3dLU3hCNU41UW5sQ1c4WVRKakdlTUlYdFJKSGFzZm9DQ3k2UDZOeXB3K1lGbjg3bWpzQkRwYjVsdU14UktVdkJXTWRsYW5NR1drWlF5eHhIWDRJTU9tZnJzTG5KWjNBQ3ZyK0M0RkpKbGZIOTErVDdkZWxjTGtDSHFmMUh4Zy9DMUQwdGR4QmJEdnFVMm9Gay9DQjhmMTc1MzZvOTZKUmlnOEx6OXlFWVJYMXdlQytGQm1vSGtzYkl0aWRTWmc1WGpaWVJlS1VNcStlSVVnOC9FWWlnTDdWUUNiSXRxNmJPcnBRakRWWHF3M056RmNWdzNSNHU4cTVsV2IzNzFIb0x1TDlBVDFLMk9xMjNPb0h2VS9rd3BiTy9XbThCTjUvamFWbGFyNjRzcmRlamtscnZoQmZVUytqTmxIYW85VTc0eDNxOTFIckhjNCt4TkthdFY5OFBsZW04N3lLWG5WZitXRmV2cGgvSXVCcmF5dU5LNXVsVE1OSWtqeThaQzFxL1BGNWtyQ2t2NlNLWFhjUlZOY2xqVHN1SzZyaTlVMzVYTEtPMnU1YXlYRlVKeTB4RXp0T1AvM2RFRmdTdFpLejFtWW9zNkZKUHVGcFBTNUFLZXBFeTBhNzEvS2pXMDVMN2t2SEthTmQ2ZGlqMWdENmlFZk5MTi9XUStRaGE2ZWRqaFhyaTFYclNRU1hRaFpTcEpialE4MEN0SjUyYnlabHBHVTMvb0dOaW1kU1QxVVBYVFJtbjlQRjN3a1gyckdZOWZZeU9DSHZvZW4xWnZ2K2tIT0g3NytGOTZnSzFTM1dYNzdlbjlYeU1hZGhEK2NUTGNsdktHWi93NTFYYjgzdVlsMTJnZktLN1hHWTI0eE1CemowRzF5TWxFaGthYzFrMlJyZVpEQjNPKzJ2cUVjcG9ib3MyY3BucE11Y1NmUFgxV05SNldvTGFUS2F2NWxyUEtiV2VsdHpuVEthdjdsclBMcVVlVFBPdnJGMnU5WkIyc1hxYzdhcFFUNEphVHpwM20rMmRZWUlMUFZmVWV0SzU2V3ozanhDZDlhQWpVcUtVek9xaC9YOWJHUmVoVE5qSG50V01DL1d0Sit1QytON1ROdDRIM1VtZG5yemE1OHkyZTBxeDdlSXkweXZvTmhGNGY5bEw1OE1yY3YwbGxFOWJVQzJhTDQwK1MrNkxnZVg5MWZmYWxQZmlQckZqK2NmTmUrbDg2Q1dYYWN2NlRmdGVXaytzV2s4NnR3VjBaTGtQWE9pL291WStTRzlKZXkxRWROclB5enNUZmlZVnFQeHNHenJMN2NLbGJEWGlWWjhERzl3cS9NWUhHTnZ3R1plNDF4T2JrWHU3NEZieEFidG40M0p5bm51dkR0cklyNkpXNHhaY2JMbXZTZUpheEJJOXJKa25CNDB3SE5hRlFvYVNoeUZkU0FBbXFUSW5jbFUwRmtaaUNST2N4OVZWUVNJZmFFblBmYlZwdm5BTnZJeSsyT3IrV1hxdVI1NEZ6bWNCT2VwT0JDYnlzSmlOdmdKMVMraXo1UzhCQ2ZENFdTTkg0YmlkVDBTeEo2VCtyOWJQYjQ3dUFhOVR1RTN0OGJ1QVZObjBLdjh5N25mdUVHekdrU2ZWdzk4QUF0WkJlSWlRQUQya3lzWm9Qb1gyYlFwSGZPUE5tak1ZUXAvQnVWL2c4ajYwUE9VVitGcm1MSy9VVFBNNk1wdHNlbmt5ZUF6OE1kMlZ1QkE5NVNUV1NtQTVQbGtUZ3RXR0pGb2Y5RzliMzlvUG5RVXhPL0Z3ZzloaWNrWkVNQVVvMXZwcmJpeW8veUw0MGNzMW95RExKQitoQkRPYUlvUUkxTW1LMm9NU0s3RHhaOHJpK1RPRHdGZzBtNDM5R3loTHFFZDkyOGRvenRSOTNiM3lmd2cwSVJaQmJlNXJFd1VyOThlRTFnSXlvVEt4SkRwQ3FJZGFqMFBkd0VieU53N3NRNjN4WHhaWWs4MFBIMEFvSDFDMmlKMWZ3V3BRNUQvamZDajJqeGZCL2pHVHVDVUNPa2c4UkpNV1piL3haamI1NDMwN1ptZDNiSjdXdDI4YUh1LzllQkN2Y211TjBad3BrUGhobXNBMk9nL3dmV0dBZWorRzNTZS9rM25FU1VUMk5ReWcyRll4WEJJZXVjN2NtOXk3bksxTFBJRVFxaEJyb1VZRDgwR2hMSG1WWGVKcG1KWW5PZUd6R1V2dDVpQWFsMVdERmNBclA4aFlIS3ZCQytLTnhRbWFyN0ZHV3dNS1Z0dXNGQ3NheGE5cWZnbzFGbmZVd1FyUmZxQzRHRXB2eU5oZlFOZER6dlRWTkF4TzkwMy9HNGdCd1h6YXFzTE80eU10RXp0UFhyMTZVcGRKbHNoeG5hYXNjdmlzS3B5OG12enhyL2Z0MWFOdjMvU2VmY0dsUHIxNjlPbVRucDcxTEpIYzY5ZXpSejlnYkE4L2J3LzZUOXJhc1dYTGpsc25wUlp1U1czWk1uVkxJVCtsY092V3d0UkpXN1pNS2p2VmZXSkJqOVQwOFJONnB2WW9vSi9HcDhOYjNRc0t1cWQybjFUWTdkbVBkWVdSZGZGWWpSWmFjTmVseW1ZSmF4TXFGMUI0RDFtb3VFeWgwQWhjb0dXSXczaW9DMzlTNTdmOEFPQ0djaCtDTW40ekhta1BMZ1JQNnNwNFBnRUxTQUtKdDBIQUlQUWRpQmtFbzFFQm1HQUdFMGo1YkZ6K2tWcGVvdVVUUVNCK0pIc1FpRUhmRFFJQi9HWTAzWXltZzJtRW50VjQzajBsdmptY1FPZVZBRTdUZWR5RUc4ZW5pVld4N090Skl5WmhmTjE2S2JpNzN5YjlOWTQwbVBHZFZGaVhUOFh6ejR0bHJSWGpkWWUyOXNraXlMQS9JSmRtNUdJa0YwbjBsTU5RdEdCV0xHTUFYMnIzOEpiVWcxc1NCUnBJZ0FBaVlnZ3d1U25HQUQvYXRHa1lxaXFBN3llZ0dpQlhxc3lucGg4Ky9CcWM2WGdiM0lWMUtlMFQ0RHZ3VjNFdjVoK3pPSnJjd3RXTXBXQ2syTU5OQk1pT1hNSk1JTTkra0Z6d3A1SDJYSHpaY2RWMDN3UkhrdDlIMnB1U3kzM3krM3h5dVUrZUtTU1hjUEwxQWZrRUJCclZZbEx5YVBob0xRL200SXJwa000RXhFeEttN1lndDMrdmprTkRSb2hiWnJUdStPNHFKSUQ3K1lOZWIrczR4VWZpOFFuRDZ6K0x5aFMxNkRud2x2SVAwV2laUjllbDUrVHZhWEk4dVlabzIvMzkrRmk3bng5Qmt5U1hwdmhDY216cDdEc1VKRjhiSE9oQjBQdElhWExKOWFlUWZqcVVvY29VV3IreVBnazJ6WXhDRGlaaWFQSXpvczZBNEFESmdObG5VbUlUa0VTaUMrbGZmUjNZRjhrYWd2L0FmSkFZeDRPeTE3M2F0QUhuejBqSFBqT2NzKy9iei9Nalpsa25McFRBZXRSYkFoK0ErNkZERGpmTHp2YTdhUTNOV1p0VGZPck8xMXVsSmJOc1JjWDRHNTJQZTdBTUdZajNEZ3ZXb2QvbG5FRmJTcy9vVXRYcnpNMXFNaTlndEhIcTNnbjBNZDkrK2oxRElDaTc5cEFxMVpnWEJuazBzcFI0MzlUUUZLcG1MSzdqNHV3VWFER3B3VHdVL05BaUdTUVc0cHdRSEJTY2FBS0tKNnlBZnZzdHRWbG9TZzMvNmwxalJ4WitVR25reEovUFdjRnJQMDBhWkZwYjlzbTU3VHQzN0RnbnBxRzdmUjFOQi9jUXBSNCt2Z3ZlaDU5dEdtcDFsSWkyY1RuTFFLQWo2OUNjZVo5Ulh5bWpNSTNJRk1SWHloakRid0Vmd1VaWWxtM0JiUzRmZzNjc2U5TklNcXNqUVFialBaMndMbklLejdGWUpic0dCZDEzOVR1Mng4YndzWGdmMEczNTN2b1p4Um5KOWhwTHR0Y1N2NWl3bVBnWUxCYkc2S0dJQTJrU3dDQ1NRY3dGV2trVCtVUkRnd2tRQmZtcjc3UStTaXdCVHdTLzJISGw1T1lHSStwN0pvOXBkQm5kMzRqL0EzNlhHK1EyODB6T2UvbVRMNkRGY1FWYVlLRDUrRDJUYWFDZkVVUStNdWRzeUlsNkNDeEd2OEZHOCszUFkzSklhQjJKaHhhbjRiYUg0dFkzNEJwamFkL1dNTjcyU254RmYwTEZKa1dRaVZYWmxId3hVamhpTTlST2wrSXF1cTlrR2RVMDJpTFV4Mm9haStNMUpTS014Y202TFpUbTFZbG1vZEE2UkVjeVgvVGJhS0orRzhXOEc4Nkd3dnpSNDFhdnNvNVpJTUR1M1RwMTZkdnY5WTdkUU9WVmt3dFhyNW8wWlhVZnZDMzI2ZHV6WjE4a0VqWXZlRW05WjJ5ZG1EclJOck8zMUxqYjVLNnBYU2QxYitSSW43UjE2NlNPaFZ1MkZKTGRzQ1BaRisvSkd3S1JRMy9sWDhiOVZoWExJejNkWUZScmdpYU5MR2hTdDZDQ1NXSmZIZENXVWM5bFBOa0JqR2lRY0MvZytaQkVjamdyN1lZR01sUE1MUHdnMElSWkxqd29GZTl1TUtGNXF3bkpNL01IdkhYMGsxSFRRSlA2TFZ0S1l3dThvWGovYkxUWlB5OGdBSUxpRTU4c3FGMk1kdmJxWHZTcDRGVm40SkE1TTlDcnNLMkQ3dG03T2M2am5uallHTW5WZThJWkxWeUJhQ2wzbUhqT0tMNVZIc1JWZGtHanExRnFENi9ObGhEdWp5eCttZEFTOHlNL0xsaUpMTlo1UHFtaU5jbEpoS1d2eXNFTU9ZYzRidklrY1R0Sk5PQk5IWHo4Q0had3NWRXpQUUlJajQzaExUeE42RzdHL3pQSjJEOUpFZnhUYVUzaU9xbHQ3ODNTMXU3dEhEZVh0MThOSm90QkFFM0dyQmFOaENHb0IvalljUXVjUTNYQXVkYVUxcVhsOTRRRlFrY3VrS3V1MEtwRElWWDlPbFY4SENJTitrUHQ2QlFIUVoyRVhVVTdmYVBvQWs2U1Vld2pXQ2J1RkVCMnd3aFRIQkRNM2ZablhrS25RY3N2dndiaERpNWxibXJtM201b1FmdTVEV0cxNUhkNnB6UUM3VzVmQjJub3hLMTR0RHVwd1N0TitOck5HNkM3b0hyOXhtU2NKcFUva2hxSmRzelpQdUtpNFF6OGJ6c1FTTFduVFh3YXA5ZkxmR1c5YkNoKzVwQjRDSmRkVi80RUxxSFBGTXZQbkhNK1F4ZTU4c3d3L013OWNSc3UrM0g1UFRpUFB2TVRlMGJnbk04b1BySDBtWUg0bVhUNnpFYk9LRC9UVUg1UHJ2TVpoYlBnMlFPNWZsZ2ZEeE4vNVFKa2p3ME5JQ1RGSkdNUk96N3hkcU9QUWZaWDFUcEYrYmc2UlFsWWgyQ3BBNWpYUTBvMGpER1RYTHFVZytLbEEzNEZKaENCZnZ1NkZEMzY4OEtZSTBrQ1FOOFZyUDQ4K3VpQ2pSc1BpNzkyUnpQUXhjdVAwSmZBLzhSdndOaTdpK0FBbHRlZWZzV1ZIKy9hYis2TjdVdXZVZmxyYTdtUHNKaGlGRWVwVkN0UVA3ckU1WnlSWnBzWEZUQ1N4VlpISlN2Lzg1OVM0eWRIcEk5b1hVM1JuOEpLWEpjM1Fiem40M1ZyQnVzdTFFOVhNaklYT0YzZG9pc3FHMWxSRWxsTEJQT0FDQ1dlZ0xndUFMNnFZeGYvNWJPMXNLZGp2UkJTTmc2Mmh5MGN3VG05ZUk0WE1uSWNKcWFUcm9OYitkdDhBSmFIL1FrZDJzMk9PVUh3dDhzKzVWdkNyVG1zZkROVmgwN0F3b1FleEZVbm9oRW9jUzkzbVJOb1JpbXNwbjhiS1ZuQXRBSlVLZXZQRmZkQjJOU3B3c0tubmVCaytoNmVtNEQxdjE4b2JqRFIvOGE3d1liU0liUG84SzVVcEVQSmsvQml1OW5veWJBNHRObHA3UkdTV2ZZYTFnbzFzYVgyT0RNVjFFTkpJaFFDZ0FnVmhVNTFxNkVRaUlFTUd0a1FHRVRpczVNaXlMYmtuNUlVVFFMZUFnMi9QRDFWOHJCdDI0YzdUai81KzZ1ZGo5cTJlMVJ5OGtuK3R0VWxWMEtyWE4xWlpIc3llZXNIMnkrSFJWN2FVYlFWUExxTXZuRnMydVFBY1pjN1hnYng1UnMySW5UbThyYkhhUGZ3MnNQUXpvZkZ4UTlCbTVHMVI0TVdqN2R4b1B3ZDFBR09rRjdDZTFHbXFnZlFEdkRDODFBek0reHJpUGhlRnd2eU8yeW1ReWJpTldvaU1PR21waWFZWVIraEN2aFo1SUkxOEpFa0pGMkhzeXk2WkN0T2Rnb21nYURXbW5uVmswSjlqRTBDdTJWOXREaWlsY1VZVWplODc5QWVjaERvMU5GaXZZL3NYcDVaa3FGd0JPWEQyYUM5WU9idjRURk54UHFaUFNpVWo5MWhDem9VaElscEZvUkpXRUF1SS9DRkRKWEdLNWhxOElvb29VTUg0dWtlWWlSQkdmWm1vYmh0dHRCRG9UQ2paRVRvNU5BRm9WZ1dDOVc0Z1pJdjBUUlBVbTFORlZpYnI2djVXdHRvU3lRdU5IaUlrNE9DR1NObndteE1IREJnanM0Lzk1ZmMrSUxtclp0bDkyemV2Tm00ZWg1MUM1cTFhTkYxY0pOV3pjZlY5V2UvOUc3Y3ZPbjRlZ2IyeS9DR3JacU5yOHQzYmRVUlZFNklDK25ZWmt6cjFKQTY5U3VEdE5ib0IzcXpidVUwZGpNNUdIUnFqZGZlVW00RmYwRTRpdlcvanB6ZHp4djNudEV2M0EvM250RVA1QkVSM3FoWGYveW8zbW4wSmdxcU55N2hiV1RJa3ZxTThFd1pqZUNKbEJtVGduZFlNMTcxNW1ENDJ4MTBlUk00N2ZocmFhT0pOMEhFUnBRTXhmZGY0VGNQUmw4UFJuL0dYaDhNNmcwR0liRjREL2lBZy94UC9DUGpBS3pWdmNITmFNWTFlQS96LzR6eU1zY2J5a21sbWhDUVlxcDNrcGdjZ1o5ZGlKLzlnVDRiZ2ZkbjU3T1AzVDBya0djRlZRWkp3WXppTk9aRklwWkNhajB2a3BzeUJhcTY4aXhxamNTSFdFQUVpTEVZUENsRCtpWUx2STl5c2xBL3ZpcjZ0b1pVQTEwQ3RTeFNsR2h6eERocXdRc3cvTTAzSGRjY1AzYnRTdmpmM1BKc0VNUFozSjZqR2l3cG1LL0Z2UDVxL1p6a00yZXRsRVlzUGZKcjhGb054cXQxTFVlU3VsV0llTkRsOXFPcW05dGtjVlFSSmwvTVJwZGt2UFlzZ3I1MnplT0JCMW5XSG5oWkY1SWI4UjVOeVkyNjVNWWFjc1BtY2NnRE13SE9BMVNJL1liRWxrMXpHU1pTUER6dFNnOGxaeFdtQ0N5Si9iUmp4NEdOTFdlL0d0QjRaTHZ4RXgwTzJNcHE1Uy8ybmYzSnA5VkRCNFJVbXpwK2R0K3lta0pETXE0dGNMdVBTUzlobmF3ZFBYOUpneDl3OG4ycHVmTStQMEJ6UDBlOUg4TzFJL2ZKY3lMK2hRdml1cU9SaHJ2aVZxek5WZU5xYzQyNDVsalhTK1ZlNXpLNFBsdzJONGdieHVWeFk3aEozRlJ1QmplYm04Y3Q0dDRGVlRtaTJQRHhCYmF4OFpWcEg3YkhmZGllN0xBTHUvQ3g5cmtMOEdYcEhIeHB2UVJmbXZLWTh5d3cydDZpNGlsUEhleThxSGc2cWRRV1htcC9FSTdYa0svUlZyZVVwSzU0RTZ0MXBmYnlHTHJ5OExaaGEyMjBOU20xdldLME5WVVpEdjR5c3RRMnZOUTJ1TlRXb3RUVzFHZ2JWV3JMTGJVTktiVzFMTFcxTjlvNnFMN3RhUjJJZzM4SFhGc1hveTIxMU5iQmFNc3B0ZlV0dGZVdXRYV2taUWVVMnZxVjJqSkxiV21ZbExGa1RNZmk1VkNLTDdheFJ0c2IrT1liSUsrRWU4UDRSdmdiL0VqYkhLT3RzTlEyMTJpYldtcGJhTFROS0xVdE1kcG1sdHFXR20yejZiYW1VYmdDemFaRVo2WXR2QzNyMVM4WkJFQ05aQ1dLZmlJNS9VakNDcjBwSXRBU0dFVnl3aWFCUUtiZHgxak1SQUtSLzREbXMxbFIveFZkbDB5MktNMW5Qbmx5OXNESmszTnlwclRjbjUxYnAyYmQ1RUc5MExRT3pacTFiOStpYVh0K2I2L0JuZE1IU2ZDTjVJU2FLVStPNWgwVmEzNmUrL2N3a0hSVXZBZVNjOHQ2VFVwSVNvd1hTMEdRSXgwRU9ucmh6ZHZMK1hsL1JzTlhHalRPS1BzOWovNW5pTXlsLzRGemZjZU42enNpYThLRUxMUWJSblhvRU5QRXo2Zk5TNitsZ2JhdDB0SmFqV2pkc1dOckxKelBTT3ZWT1ZXS2V5bTVUdG1Yb05HSnZMd1Q2SmdVQmtKSGI5dzRHdDNZV0ZheU1iWm1kQnprMjQrbS96MTVtYjJGUDFxelprdzRPbHMyNldsWjRKTko3QjhpNDRoY0w4ZDV3d1dQdmxqYXFjNUZjdEY0WGdkejl2RHFlQ3JDQ0h6aGZQQWxzQ281YXZma3hmckpLVTBBMHdERFFDSTdkTU1ENWdzQ2d5MkJpVHhlb3VSUHFNd2ZMR3RlMWtyd3ExS3piZStOaTkvK21PY1BnMGF4eVkwU2E2YzFPbkhpUkFmaWx5RklYY3JxbGRYanYvNDlxWEdWbUxjNlRsNDJkYXFVV0w5cFVrSnF0WlNlM2RNM09WNFR2T1lLaE4rOVFuQ01oYm5Pdk9GVStqZHF6M1NOTHNZSXZUVFBHUWgrb2wzeW9xRmF2RVE5NXowNWlYclplbEptVFArZkNPdUJudk5RRnRnNkQ2MUE3eTBBVzFIbWZMZ0ZYSE44NXJDRCs4Z0VPOEttVEFadGkzbExCMHlUTjBHWFYzZUlDbVJVY2tFU0pMTmVncVpBUzVMUlA0Vkl0aDJPYkxGK3VkbVJ4L05DemJ0b0xicTRadytJQXRPUFpXTytYWWgxRkUrYTE2MHE1amJPeGxiWVc3ejBMcmg4aFJSdEJMRW5CSkFvTkg5VGpLekJzM1VrZU40L2YrNlBCK2ZPLzI3ZC9OR0htejc1OE1OTk1BbmRSS1dnSGdnQnJmRmZBanFOYmdWYysvMzNhMmpwRDQ4ZVhtWHREeTkvQXY0V2QrQVoxRml2K2VrM0RWRnpicU5ORzJHSHZNaGMzUzBtTVNrSy9HMUZhOEJGZzlnNk5yME5xYjk4RGJvUHYrUmI0aDJ1QnRWekRQRXZnR1NzVzQ5M3dXRE11cW1EWHJ6cENycEkzekVYZFFDeDNFeWFJMExScGVqSUVSbFdoM2tkRmFnVlFoc0RFS3VSTzJkZUk5TG1BTkZyNG1pbW83VkdVOEQ3ZUNXWnFVUVE3NFRyTHZhQk9nWE43Tnk0VXhqWGN3cTZtSVU5VHUweElDMDV0WHB3MWZxV2xEb3RtOVJPZkx0MXB4NGg1dGQ5L1pQRGtuczFJTythaDFZQmlTdlEyUklBZ2NpVXJGYjgwMVd5Lzc4amZBOVBTa2R3T3kzY0RTSXdCTVVUdWNFZVpPWmp5VUdabjBKR014OC92ekMvZUwrbWZtbCttWDVTQmp0c3Qza3J2NWY0ZVlkNXgzdnpJKzJIekZpZ0x6SnZNMk5CMTg4Y1pvNDM4eGtsQkpDNEVIK3dseE0wNVNKY3hENlpYRXJKMTBOQitGTVJ2cFQ0QllVRnhRZVI4a0c1UVlYNHc0NmlvRzFFQUM4bnNuY3B1VXpHNWNpaGR3aTFuSVdxN3k4TnZSYjZJSlNudjRVNzc0WmZDMzhRanUrR010OXorU1JQM1N2TXRHUEpwSStwbnh5Y0hKUVNsSndFajBCcDViUVpLdzJ3VjgrK3ZYdjF5MmpWNUsyWGFpYTNTRytkTXZ1bG1KZEZtNVErZW5TNjFEU3RVeE1BMi9mTmFCam4xN1lmQUprQU5LN0wrdlE2UEdBZ0VlamgzQnpTcDBiYXAvaWZGL1pvU2FIZmZMOGlQejdQWGs3TUJTNzkyOHlUZFhCVGIyR2t2ZENJdXpqTm1Ha2tYV3dNTThZYmNjOFdHVWxjbmhFL1NyeVcxVTArUkdON2QybDhURklURUpPVUhHMUpvY3phRDhBU0tDMmIrdFl5QSt6Ukl6TTkvV0xYZHFJd3ZMTmgyckxlSFFCdWR2Y1JJN3BMalY5TGZjVTBSSWlNbHFLakdyL1d2SEVUS1lXMitTbzhJK1hqTmdkdzQwbGpBMWliL3c5YVMrU1hnRkpjNFk3TWdOd0FtT2ZVdFhDZHRQRk5qYVF2cEF3M0xTUlpFT0dYVUhwL3hzeFZCcGpScTIvdjNzTnorUFZwdURVOVJvN3NJVFhwbU5iNGMvRkxLZ3VQRW42Q2o2V0RuQWVXNGZhUlF3OC90aGFJS2tPb2c1UkdnNFpHUTVpQkpMVVNNckFpcytPK2Q3azNIbzlNNzF6dlFtODhIdHV3WXFPc2lnejdmVzhpOStMTGp2dCs1WDZrbkYrdVg2RWZLZWRIeXRIT0llWDhTRGsvcGc3NVV5VXB5RG1iZzY0RlBRamk2VzhoenJzaDEwSWVoT0M3UWN5N0dCZ3NNZmovVVlrcGRISWJvdW5reHJ5RFR1N0hNUC9MTC9JaDhCbjA5WnV2SkkrcUdSblg3TTFHZGNmSFJNWUx2MGc3ZDByM0xyVkk3dzVoazFvK3pRY0EwQTNDK3JWWTMvQ2xFbWJjWEdYdU5kSTNubXg4WDl3bk5MbTlPaFBWY2JPWk5IT1NFWnVTR0J6RDVBYzJGdzJCQ3FGb3hrT1Era3JHcStMb3Q3dTB4Q1R1M1N2ZEd6MUNESTJ1R2RXK2M4dG16UXoxU1o2UGhYVHMrbUQ2dkxuMkd2bzg0Lzk1NU1qaGRpWE5iNVhDS3NWWGFscUpPTVdvWFNsYVloSXhSZFAzN1pzR2dXRTAralI3NTB4TXpDZWZTUGQ2M2NMOTB4ZjN6NWZ5KzlzUWM2eDNQTVVoODQ1bngyUzRXam5iRUg2bFJCVmR6T1JGbWtqQlUvTnV6ekRQZU0rbW52VGRpU0o3TzBnMFdNRGcwY0FBcCszYk54M0NIMmFWNUlqZjNpTXZCL20zbUQxNHJMQVgvaUF0b3V0dkJubXJ5blBzQndVOG82NFNVQUlkOS9GVTFxT0FHU3VaZEEvSXBITmRoNVZzM29lOFM3MnZlVC93RnZQc21ZVEZwQmxKWEozTVp3STBhekVnTENBK29HbEFXa0JtZ051MVNFWVo2NnZpdW5uejEwdXdkNytoQXdlOE5XWS9YSUxYNHVBWk13ZEpiYnYzYk9OMWxtR1dMeE5LUUxJVS9HSS9KSE5Lb2lIUXNxeGIyNXI1WXRPTGwyYmlma2pDOG1BNmxyME1XQ0pzbzdIeUs5S1hMcUJRTmRjQ0ZsQUk0bDJ0akY3VWY0WW51VXN0NUY5K2dPT0lkU0w0Yml5NFVPQVlCWDU5S0lHNnFGU1krMndVV0FwejhFNjdBY3QrditQMysxSWtoTEZ1WkZKRi90R2RoZ0I5NkhpSU1aeFpObmVraFdTR1lKMDRNd1RyeDJFaDhTRXdZOGY4a0NKOGkvMHpVcXNsMnozOFdNUjVvaWxDcHk3Sm1XZGlMRkdLZnJNQmpENXhMU2RqNk5Sdjk2QURvTVgwUlhNbitxQURaY3ZlWDc2eVRKajczc3IwMmFHQks3TlhyWVZocVBXb29YM3loY3hoZzRaazRYRXBMTDh2VkJKV2NhRll2MzJoYkt1WTRYVDlxY09YRkJpaURwc21CSG1ZYzJOYkUzZ28vbkh5SzFRT3dGZGYzeGRoN3FiVkt6N2QvOTdxalNCUDJuMFVlSjcvOHh6d1BMcExtclBnbTNVUE41eVpzNURsUFJmTWVBdzhzWlRWNkFValFIcmRTeTg0NmlRNzBvME1YWXYySURYcGJRQnp2d0JCNkpjdjBGMFF1UFRNbWFYQ1hQUkg2VGRuMEVPaFp0a3JGejQ4KzhFRk9uL0pQRGhJOVpLZUd1eDYxMzdTblp4TE9odTMzWXVsUHZHS3QyZDZrY0gzaXZmU2c5ZXJ5T2YwangvbzJBMkx5dTd3d1k0K3NDMnNnMTd1TDh6TlJvTmtXZzdRL2hqMmdoVmg5eENnRnVVL2pKekx6UGNnZ29aSHBnZVpjQjVGSG5qNmhYbkVrMzhPZW55TmIrclR3dWdRYnhYSE0wcmNBQUlXSHVUb0MxK0Z3WTQ3aExBM21hNUE1bE1jbmsvaDNFQ3Vvc3FtMFdKc2ZxWFVvWUlvTlA1NmhVWWJmaGpHVXpqOE1MeHJoeEhJZ3JDME1OeHJPb3pQS0FYcG1wcXgvWUI4aU1SczNjVDNUSWlMdmJYNUIzUVBtQzUrZTBPQXVaNXJQbHAzNnZRbms5ZUhvd3RnemZ2TmhwRnBkeFo0N1ZvakNoTW5uZnZvNGZxenpXcURvQng1M0lXWDZiaS80V2JjZFkxejZ5bUhSNEdvbmdWNEdDcmJqYmozdFFmTkZOSldEVlFXWHJZNnNxeFd1TVlLUFIxL0NYTWRQOEl3WmU2Qk1Fd0RyL2c1MFNGMmZTMnRMQkdFNWVmam92UzV0UEw3ZkdmOHhham9yYlNvOHB3YVUrOVYrdi9WZHVWaFVSemJ2cXU2cHdFSisrYUFCaEJSUVpFb29zR1lLMG9TdVdMUVJHVVJBVGZjbFVXRmtTZ29Lc2d5Z2lnYVJVVU03bEZnUkV4OHhnMDBhbUlrYWx4djlEUFJHM1BOalQ2ajJXUjZYaTNkVGZjd2V2TWw5LzB6TVBPZHFhazZkYzc1VlhXZCtoMThkVjZWWmRQdUVReThycnRjMDNoWnc2YnE4K2VXYy9yV3ozYzA3OS9PTDg1YWxjVklmZVM4U1p5Y1lNRW15VW1UeFpBdFY0U1Y3NENUMHBnTjNud3diMVlteEJid2JjVWNRdHFLWit3dTFPbnl3WkVpS1BoQUo3Z2FhbzNmSWVYOUJPMDB4aStNdFJxNWYrd2sxRCtOOU9UV29zK29qNlA4YVkwT0h6alUrSlp1Q25JLzJvNm1IL3JQUVhvK29ab0xNaHFMenlja01uRlZ5Z2MrazJaSUVXYXJGcHBYaWdhRkNjUVJPSkdqYVBpUUIzdlg2bmhoNmxnaG1kZHQzczNlZlRhUDNRZGIzMkZQZ3RiQlpLS3A3aE9JalViOEtSdkY2eGRJMWkvV2hHV1ovallZZ0V3eUljczRGTzB1NFZFK2l6MFBXMFBSelBlRDdEbTZSc0crSG81ODNmeVpoUVZ2Zi9FekMzS1lTaDJZY2V1dXhvdHc0WmVyMTRSZmdQWFZxOEEyNitUdVhjZU83OTU5SEp5L0liUUM3c1pQMTRCR2VIWU5ORFExTlR4cGJEcDVpUFpyTmZjKzZwZEwydzE5Y3BJbjlVcytyMlBKZVIxT2pWQlNNdHFZMTFkekpSWEpGRkdtZlNmNzl6MCsrc1JyYThkYTZ1bUVyYThmSEc0SURMVGNYUkhmN05IOGVhSTllNktDK1UvcXI1VHJRZDdJNVdjWklCYUhhM0JFMFJiNWlwY1NiQmd2OGJCUm5RSWtsWW9UYVZiY1BkeEVsaEpjTkU2c0YrZWpBLy9UZEhIU3BPa0pOdmFMWCtMemRFSWxpRmhYVUxCTytBUVlCWmJUNzZtYVZPVFh1V1JHVnQ5UkhpNGRKL2FiUDMxK1NscHFxZzdiNGd3VWM1NGkzWGVYUmtLVUxZMkVKTkVTelhlMmVlNnRjbFk5SFoxSkxsaG54M3AvMVVqNjRXT3dVSFVPbkNzK0p5T1BWbVFhUkhaeDZmRnJwNzlyT25NSHJUVzJyVjVmdWV6c2xjOSsvdks0OEF5OWJ5N2VkQUQ0eFV3TENTdlRsK3c2Vk1PbmxXVEd4YVdFaEswcFdsMnpzNEZma1pVcFBmODdSZGFnd1JiOFM3WnlzK3cvb0VqVlprOEptVHBoQmJ1WTYvSHNHdGNqaGNha1RjaC9FbEc3VGt4L0MvRlpGVFBsQllZNlREc1J5a2RGcVY4dVVYaHkrU3ZoU2RablZWWG5rTE1hVDl5NGNZSmxXNDJsTzNlV3NpejkzWUhJM2hMSitpSG9QOFZxeGVrNmlrN2ljVG9JZ1NIdXZEdlFMUkVDRmdnQlMxdWlock5IbjgwajhURWF4Y2ZqNkQ4M0tUNnEybGFGQjhJKzRXZ2VFcFUyTGxhbEEyUVBRMWltVVE5Y1FseklLL0JqdS90WmthWDhubzY4eDQ4TEhycnhYamR5aGRQemZuZmc3WXp6aEU5emdMdHVJWnZaV3Jnd204MUVjWFB0c0dHdHM4V1krWjdwQWVkRzhqNHpMVlRCSkFsNnhNbThITVJxUExqZ0RpbkpRMHJaNE5OUEpkbU1BOTVhNEFXbjRxalg0QlpJRWt1OEhPdDhTRGFlbnhwaXFiOGhzL1dqZFZ1bEJYNDdGayt3dDdobVoxV2wva0FhMVB4MjlQUVBlVm5GUlNibTdESGhSMlRESnpkVUdRN3ZLMmExVzNKV2J0dGV3Ty81NXNyUmFRZDdkZjg0NStTdDZ5ZjQ0cnJxZFJ2VzBIa1BRdlB1aWNadnpmU3hzSW9tVDlETjdjM0FjRmJTazNOQXVLV2hINWhiS0VSa0NjTldRbGU0ME5oUlNBQjc0VGU0L1Nqa0o5ZUpYYjNGdEcvU0VzWWFPQWFLR1RjSzF6SFlhT2lQRHNDbk9JUVo0eDU4MHBvQnJ4di96cjQ3WmNvbzlscktDUHlNQ3NXYVcvOFYvT0hGdXU1NEZ0VFB6TmxiM3g4NzhhL3ZqeDk3b051dTE5ZnMwSmZVZ01vemQrK2VBYkduNzkwN0RkYlYxbFVJdXlvTTlldW9qcEVPUUFYcWswYnlhYkxNYWdlLytGbDVpNHFKVEhwSWpoWnhWcUgrb0NMckVoak9kWFdZNWt2YlRVYTZUVWJ0ZWtwK1JZaUMydTFCbFV0bnFDVm5IeXhsZW5KU24wNDRrZUxpSHFTQUFMNnBFUXFrMHg2bE9RSVBYemJaeUlDRHMwY3RtSityUi9aM3FhN21rMlVGd2xFSUowNEIrMmNYRDV1WlV6S0xYM1htd3crbU54WUp6VHp1NjJRMEx6bW9yNEZTRFN5UzlkVU9mYlUyUGVpbW1PeUdEYVZhdkRVaDIyTnhaNHcveWxCT2xZRWxGR3pQSXlOUkpUaUszQ1JBM2pVclZyTkszckcyQWJPelUrS256cnhWdisxZnlLMDJMbHEydG5obGRmV3lSWGxMMDlhbVFmNW1kZDE1Tmo2bTJNOW4xWXpOaGcrcitXa0Z1VE1XcEU1SlQ1bTBLSHNTWDFLN2kyQTV4b3Fma1EvZ1BQNFJGaEJRZGl6STJkQjZqdXJEZFZJR0UrQ3F0QVpyVzJpV3dJL0JSRXJnWnoxdTM5WVo5MEk0Y29ueE9EakRlNEhwS1lJUnNNUFo4TmFic0FDR1VydEpSM09oUi8zeGxtb0JxSHhlTG5jQ1ZBa3dCbTlTcjg1Z2JRL0VIYVRHMjVwa050RVA3RlVzYi9oc1g1VWc1NFhUd2xoTVllUXVLaDVLZXNjWis2VnZ3SlhHT3ozN3ZKZTQ2N05QdjloMUcybTdZbEY1Y2RHaTdCVXZRd2JxWndzWi9yMVo5a3k5NFdMMVp0NXF6c0x5NHB3MXc5K2thODRDTko1RzRnZmRtVGdMcUNsVnljS3hXQkdnRGZhdWpFaURaMnVQS1kxVXViR3U1c3NrUlM2Q2RQSkpJMFJYRnpRQU4yazBNQ0t5OURWdFdIcDA4ZUUrTmJNYW1yNXRxTHNQUU5Yc2FxOXRPVXUzRkhHYk8zcE85SFE5V3JGMXlJaW0ycHJ6dnphRFYwLzhabXhKaU9wVTBWU1pzYlFFY3o2am1LeEZPT1RKeEx5bzBnZnMrQWQ5R1k5YnF4ekxDMXliMDdicXdOZkw1MndzM3ZGaEt0VDhmUEhJbmZYNVFpcUVQNDZIbmRlZEdWK3cvYU9OZkdQcnRVYmRMKzhMQXpVa1R5NE42YjhPNmQ4RHJWV0RtVm0wejZReVFEdi9EcklobFZXRGtIOEg0UjFkVUhDUTJTcVY5UXJDbzNJSThxS0dydUlQZFhPczcyNitESmM4T1ZSa0hDSnVLNjM5OEdwUCtiOCtkZnpzdk8vM2YveG9SZHFrOUp1N3E2K00zYU5iVWx1N2JPRU92NHFaOHpkc21qOWpEVHRsZkhHWHJoV1R0eGdNVzZaVWRPMVNOTDZpWnJ0eDJOVGx5NmZPV3JJRWxpVm1aVXlha0ptSjdDNFpqYnRNdEx1eGlyclQ1bmFuUWpjclZ6dktqV3Jnck96TWpjN096T2o4OFJNcGVvMkJBbEZiS1FUTS9oNHFEUTE4czJKZjMrckVneTNmTmhqdVAvMTRxRDdDL2JVRjc2UnQ5dG4yWGs1VjhaamEvT3J3Tjg3dDJISG44VW1oK3VBL1BUdE8xTHFCaHZGREk4by9xWjJYK1Q2T0NYSG9KWjd0aFRBcVRJRlJ6aFl4Q2hlOFVwL2xja3FZaXArekZnQjR6Q3JSQTdXTEZzdXdGclhyS2EzOWlTMmJ0MXV2aGMvQktFTUF6b2pCeGcwdEc3Y2h3QU1uWXozSHBCMlFTY05hNDZmZ3RiZjdSNCtNVFpvQytjM0xGNjFLbW5ZRmdwM2pnT2V3K09EdzZERkQrWWxGQzlPanNpY2VJVmcxei9RVW5rSjlEbVR5RlZqbC9GeXNha3pXcG1wenRXeGlZNjRXUDdGbDB4c2N0TjRJckJvdmFHOXJINkwzOVIzaEN3QUxxZ0VML2hYQWdvZUdEWTRjc1hQRnduMGFtREoxekxpVXhNVHM3TGl4NCtLaUprK0dmTFZ1K1VZWU5UQko2ejV4Mkp6c0JYUDV3YU5HRElsNk0vNnQ4TmVpaGcza2szUUxjRHdkZzV6YWx2VnRoMWZPTDhBcitFZnhTblhoTEdQRGh0bkN1eHpZbHk1TUJuMTRMZURHN2RrVEFmc1p2d1hsdU9nOVlKYWl1YmlDK3FMR0ttZExXS1ZRY1J0SWVWc1QxSkt4eWxyQ0txakdLbWlPVlZiUHhhcjMrNEo3UW5abjM3akJpOVpWVk9iczFNREpVOGRPU1U0ZU8zcWNLMGdDVGNtUDNEdER0blJSZHRtY1dieFZSR1JjN0tpazNvRmtiZm9VL2tCOFFZMVR6cFp3Q2xyQXFRYkczaEVYeXZXQ2FweUMveG1uY0phVkNxZkF0ZjR6QXQwRHhvUk95T3U2SUdwcDJaNzg1ZnRPTEl4T2RVcU5pWitWeVBaeWRvcDFkRmlRTkxWWFNLRXVvM1JQd2RYbGU0WDBRWDF0a25WSmZ4OFZ5NGd4QTVhaXVWSG53SmhiQ2NtQlVWMUdSSjIwQjUyQlgyZy9rZ01EUy9VTFo2MmVJd3lDQStEcHFtOVA1ZWFlQnU2ekVtZ09kcTZvTTRvdE9nVzJ0UE5IR1ZzYWs0TlNnM0tEMk1RR2h5QnZoQytOdVVHbFFWVkJ5QTI5WUh1Z0lYOEkwRUExME1DL0FEVHc4dHZoVWVQMjV4VWRTQmdaRVYyVHE2c2VNLytkZUoxdTNPaDB6OG1SbzZiTkdEbHNNaHo5ZXBMV2ErcVF1ZG5aYzRlbWVHbVRYcCtXa1NINEQzbjMzU0ZEbzZQQmdZSEQzaHcwS0RLU3JuSFNrUjR1aWJZelhvRTE1clpUejBBTFdOT0F6MExSNGxtQ0hLaUdIUGdDeUpGdUU3ZURuUEtFVEw4NWcxZFc3aWxZdHYrandyNHorcmdHamgzODlrelgxTkd4TTVOR3podzdOYkJYeVlLTXlsMzVEeGR2ZG5LS2M3WUgzVjRON0o2WU9UTnlSQklkVTVucEtZb3p2ZHJ0MVp3dDdkWFUxNlE3bWsyT0lvOVEvUmlPdGQxZldscTdmMVZaN1p6MGlSUG5wazJja0FhOENqZHZMbnhRVUZWVkFKSm16MDc2WWNMczJST3dQUytHKytFZGNnK2hKNzZIWUxpTm9NZmdnRjlHc25pamovOExSaS90THlqQU84Wk5jQXE5b01BeWRkd3NPSUt2WkRqR2tlbUV6MlBzZzVFM2hOdGM0RzV6RHprVHg2Rlc4WGx0cnZpU1lhakNMdy94MjJRTzczaTRaQTdObGplSG9LL3R1cVM5WTUybi9NWmErYkY4UUl0RHJJZVZuMVcvL3JMakQxQ0VMbkJtS1hzcVdaY1FQamcrZm5CNHdoc2hYZjM2OXZYckdzSlg4cWUvR0JJZlB5UThKaWE4YTk4Ky90MzY5VVB6azhPbHdueTBEc1c4QjY5WTRLS1hLVTZCOG5aZWh4WVUrRkZIWEVMY1dId2FiT1htQjk2YnV2M0NJT1BTOGU4V2N5VWd6RTA0b1QvOWVTR3hnVkZvclJ0RCtPN1ZXR1AvSi9aRzBOYkMzaWhVMmh1bDM3dVhaWXlCVlhuR09iQVRId0srU2hIS1FOb2JiR3VyUC9zR3dHZG9SMHdQdUU2b0w5NjRibkM3MFQ1dlh5UmpUWjEzaTRnemVFNWNXdjc0bHNqWmpWendVRUE3eHBtV2QyQ3o4WU1CQTFha0hiNTM2MWJESXcyY3RiUDRnK3B0cTR2WCtzSTFiT2RVNDI5OUJyQ3NpYm4ydGZEcjJWUDhtazNOaHo4NEZUK082Qlh6NGZRbWV3ZzExdGovZis2SjZEZ1lMZWpIcVBkRTY2TEt3N3pEMHFLM2ZUWG9jSHJ6M2FmTlo0Vm40T1hkQ3cvNkhsOVhYcnRIYzZxTHp5U2ZsMXZQTDQxT0VoNWZ2eXJjQjcyQUJxUzJncjhaTitaTW52WGw0M3ZiYTYvUXZFUGtZQWZJblNVbDVwaGJpOFc4eXc2QXRmSWI0QW53M1FMMndJM3Z1dHRtZGVqeDA3blcrK3dhelhEaHZ2R29VSlNkRGViQldNQlRQeDRrREdjZmM5RWtvK050WmkzOXZaN29KM3BLeWZFa0h4NnpZdlIwckF0dXFRdFczVjNDSDBaSWJ0SGdFT0VkZ2FCYmVmcnJaTjFSTEMyaHVQMWhlUGtWc3F6dGFoMUJtRmNkNjhOVVRkWVBWODJBSDNsbUwvSTlFSUpWN1BpY0VxYmsrcjd1SHI1QWtoUE5UTTM1d0Q3ZTIrdVZmKzd2SHVuckUvQldXT1BCTDRXNzM1Mi9OeS9CcDh1cnZXTW0zSzN2RnRrRmpEWTIySG5hdmpOM2E2WGh4cklTWWZtMm5FWFYxVGs1VzltcnZUT0h1cTg2MWFHRGRuQkEvNTdscTNJdWJ0Tk4xQWU2RHduNlc0Si8wUHA0OS9XbmJXMWF2UUIwejRtT1NWc1RHemNaNWllVmxTVzVwNVNYcHhCOTV5R2JmUjNaTE1YNkdRcXN0My94UHRJUWpGNysraTZTUERmL0ErRE91WlprRnRRSVR5OWVFWDZ0WHBsWjlQakU4WjlIZnJGaDA1blRXemVkRFRoVVVGeFhYMUo0Z0F2THJPOFJjRHkzK2RMRlUwdVBCZlNveXp6UzhtV3J2bWpmdnFMU2JSK3d3M0oyYmwyeHRMSVMrZXAwMHdQMmllaXJ5bjJrdWEvK0YvYVJrRndRZGRiU2NtTHRRQjNhNzJnT1BURDM5QlBHZE9TU0lEeTU4ZmJtU1BlSUZkUHphdjBQVnVvUGZUanExb1hHeENuQTd0Smw0QzM4Vy9oZEdHMFV2dmQrT2NXM0U3VEtuNVI1NGViOTdWdHZTdWRYN08va21aZUxkTjVtOGZ5cXJZNko2a1lRYTE2d1hENmtVaDlLSFQ1Mi9mb3huTjJ5cW54MUtmcmJJSXpnOUo5WGJ6dVhzbjV1MmtaUzkrTUIxdy81c0RPS0hCTXMxQlJWTWQ2bzZzSXJLcTJRN0hHN0R2aHNUUlhSTzZodTg1RmxMYm1oUjh0OXVJU3dMcUtEMFN0NTBJM1Y5MjRxTzNuelpyUCsyQ3RCbVJPblp4b0RObS9KM2Q3WmMxUGhsaXJRZjRNQitQN2toa3Q1R0NwQm1QRWI0MTFnYW43dzNhR1JIekltNGRrRndxUEc3WWU0dGhJUFlnbXYxTDlwSG94ek4zWVp1Zkc2ejVSbVNzYzUvTWM4TU4rR0IzWU8vSi9KUTd5eTlPZStJNTEzb2UrVUV4N0lmVkYza1U0TmpDMitEb1ZmZkd6bCsxUWtQd3ZYdTJLWHlMeG1uY3g0ZTZuTVAyUVp6S0htVGpoSnpXVWVTVEpnTEZPR2ZBVHp5N0lhdGN4RFdRWnpsamtUVGxET1RLWkpsT0dabVNrdUttWlZxWTRZa2VQOTViYmltUitaMFZqU0RmY0pWMGYya2pta3FLdzhSblkvOHp2ekp1UEtHRHc1bHRBZU83YmdWNThXaVp0R2lNUTVWVWcrajl3cHlnWUxUYy9RNXlTSGlPaHF1YWlyclpLdVpMNU1Ldk1QV1NZVEpFbTZNcE41Sk1yd1lPd01UNlVFMHliVEpNa3dNLy9tb21JbkZmVmdPb1dBdGlmcDAwcmFKOU4wMmljRjV5WithR1FrZlZwSjJzcnNTbnBrTFVvUU8vc1N5YlNTUHEyazgyZnFRK2VQWnlWZVFCUHFFK3hKK2tSL2E2YUpaMGl2ckRGM0owNkcwTFFvK2kvT3RWN2lZcFBtV3RZRHlUOGd2N2xLMU9kNXBwY1pEeWVWK1VHV3lRVEZURGZLOGFlVzRSbEpCbURtcDBEQ3FXZmVqa21XU1dDS21TNlVVODlNNXBJb2czUSt5MC9GNWlseHY1RnpYOHpweUs0UisvMDc1WFJVOEJkU21hOWxtVXp3RWVXUGREZVgrVjlKQnZXN0NlMnVMTWsweSszTVJMTkpxc2U1YzdoNm5EdGV2RW82SitlRG1xdElkcjM0bTRtTUU2bnAxOGFqUi8zcmtPekw2VXdoNWRGN1NXUG15ODlrMzRwbE5qQlI1djR1NkRnOWlURkxDSmZmT1BnREkrblFsc3hYbnRpSEhEcGZ2cXl0VXMrMlpMN3l4SEVYMHZueU1aUFIzSkJsNHNCb2NVNDVzM2FnTEJQRFZGTDc2ZExXRHNrOXhQeTFKSDd5SU9aTjRoMWFGcGo3MmlIWjE5SW5FWTNZYWRyNTR6UFpaMk16b3A3anMrY2szMGQ5RHFFK1pOZG04N3NFSGM1RHBESlliOEJEOGQzSGN2c3g3NUYrT2luYko3bDVSRy81b3Q3eXFFNzgxSGJlbTdlVlpXS1JuUk11VVg4ekdhTGJmTEdmSTJnN3ZncGZFSHJqUEVBcTQyakZUZ1hqaGJPaVBsOGxQbHNnOW1FVEkwWXZ5Y1pNSlNoTytCUGZwN0Vrd2RTTityNlZ6RlZxV290aytoS2QwMWlTYnBKNGdHVWVVaHpiSUVkMFR0dUpOUTJrZG1ndHh5VEdTZENCV0tMUGxiaW1IeGpYU0hXRlkxNHdtUXNTODBEY00wL0tNc3kyNlhNazBrTlh6VzBrVTBqSFF0aERrWlNMYUIxa3ZnYmd2RGdrVXlUcXdVYTRpTG1JY1Q0YTVoeG1pMmxNOVRmaGIzWVFQWVRPcVJDR2M5YW9EUDR1ODcxd1daeHIrWE1uM0daWDltdUorVUk2QVJleHlFd1d6VldvMFk3aDhjMWd3cWV4UzhabXZlaHYrOXJqalJDRzg4dW9EQm5EQXFrZjZMdVA1UmdkdzV4alZGWW54OFJQNWZpYnpwVFNPTlpKWXhaL2JlWFlHc3RVVVp0ckY2TTd5akxqVWN3TXhIR00yR1dkdjVJem5lUlRrVEdWaVdNS3BtUHEwVGJ2ZUV6MlpFeGxvbTUva2Nka1Q4WlVSdjFvQkJsUkFLdVlkNUxqUkdMVWFySDlPVFJHOVdKdHBQYUpEUEcxMVJTamRZR1VJZGhHMFk0UWlYT2xxQXhaSjB3bjZ3VDZYU2kxai9SYVJPT1NvdjFJWkJ2eUdvM015VXVrLzJUdHB2bFJXcnVCbUFrZGFRUlh4QUdLQ1k5azNFaGdQcUljdm02YzNENlYrVWpHalhUbUNPVnBkZEdZeWJUSzdjUXluek1qS1A2b1pmaHVza3c4OEdVSXo3OFhsc0c1TVcyMVU2bXNqU3c3SG5SSGVFWmtyYWxzRy8vNUpvUWZpV1Q4YThRNG1FTStKL2xIWkd3Vm9rOUcwdmppeWJwSmZhSTQ5MERFT1RRMzA5Mm9qcXpiZEVSbGprb3l6TXpYN1hGUDdBaHEydEdMQkZpTzVMd1FXM3RmdElXaDFOYnMyekNUeXB5VFpKQVBldEErMlhKbU1vOUZHVFJ2eWNUdUhGZ3JsZDFaeDNLYkhVVjdZVmR6a3hqbS93QkFMVHZDZUp4allHUmdZQURpc2c4MXp2SDhObDhaNURrWVFPQnk3WlcxTVBvWHo5K3JuRG9jU1VBdUJ3TVRTQlFBWjBRTkVRQUFBSGljWTJCa1lPQkkrbnVWZ1lIVDV4ZlB2MFJPSFFhZ0NESmdFUVFBaGJFRlF3QUFBSGljalZjTGNCWFZHZjUyenptN0Y2UU1vQ09GZ2tDcEtDOEZMWUpGaFFZWUFpUm9CRWRvZUVoNEJBSVlrSVF4RUV5aGlOZ2tJTkdFZHhKQ0pKZGFLTXFBUVNKeE9rQkJxeTJkdG9qajJCZGFpNlh5VUtsV1ovdjloOTE0dVVQRU8vUE50M2ZQN3A3Ly9mL0h1UUQ3Y3k2RWVBdVZiaHFLOUdjWXBuT1JaODdnVWYxdlpEcVRrT2YrRkNWdUNkcXBtZWlzVjJLTXN4cmozTkhvNy93TGRhb3ZidEsvd0ZOOHA0SElJYVlUSTRpZHhBWWluWmhCVEhSZXdpWm5QNTlwejN0TFVhNXZScUdxd1ZoL0xMSjFnSzc2VXpTYWJsaHBocUpSYnlHMjhuOEJ5a3djalc0dm5OTFpTRGVkZUg4Z0dyMlB1YmFieUVLaHZraWVqa0l6bkRMOERsUDFxK2hycHFCT2Y0eXVmaS9jclQvRVlQMHV1dWxqbU9wOGhPM3FGdlFqUTQxSHVzcUQ0NDdDWkoxT0dmS3dsVEpOSStmcUxwamtia09LenVkMUhpcWRFOWpsbkE1SzFYOVFKZGQrZStyRyswU21mWS92dUFmNC8zck1kdVBvd2YrYjFCbjA4VnJqeCtRN2lPN0VUOXhhREhjTzR5VnlDN01FYTYzdEQyT2R6c1FTWFlaaDVqam02OStncjlPQUtuMFMyYW9STmQ1TXpGVS94MVBxZVN6VmsxRW90dmR5TUV2bElFZDVXS3Z2dzBOcUdCWlRuMFh1VU9SeDd4cjFKaDUwTG1FSHY1L2xCSGhZYmVMNzFWamhkVUMxMTRYWWd4SjFDUE9zM2E4Q2Z4VGFpaStzSHhMZzlnb3UwUmV2RTRyWDc5RE93eU0vSkVQM3cyVHJGL29pRWRZWGgvQ3kzb1AxMXU1WGdYZVlNU0srb0I4UzRSd0xqanJIc0pIOEIyS25ybU84ZmUySEsxR0NWUHBQcmpjbFFueWhpN0ROc3VpYkhzWmZBbHZkdVgrenpCZzFMWkVyK3ROdnVkWStJdU0xV09KWllxcFpacXlMUG1ZbE92QzczV2pqUTlTemxFeTlnM0t4djlpQTloL0dPTHlSZkl6MmlIdnJjRXJ0d3k3SkVlZVBRWW5raWNTcWZoZzF6SmNYK1d5VjVBMTVoYkNieldlRmQ1SDdvTDNiRmgzRmozYnZKTlo1d1RtekNmc2x6cTFmYWR0azlnc3d6NStCS1pLRGtnY2hGNFQ4cE0xTDVrYXp6SnkxZVNQOCs1RGp1TUhHQzMzMmJWbnlYWEpPWXN6Nk44eDd5YjFrcGkzcTNNcmdpQ2xIc1Y1Q1hSYnhHd2RZbzJpL0tBNGtEeVFXSlk1dExDWEphNStWdUp5SFRMVUExV280VnF0cEtIYitpYTNNOFJkYzhINGhjOVZnbGJzVzljQlhyWWxxNE10ZmtlZVRCNURudUQ1ZVUzL0NkdGxYOHRZZytNUnJoYmJ1R25Reml6SFlEQTNLVFFZbXVMT0NQVkd0MURrNGFKNUZYeHRiMUVsaVIrU1VXaW4rTjdkalJGUW5kUUh5YlY3dTVQVkYrMytJNkNEMk1mV1lLRFhTck9INnZYaGM4dHJhYlRuamVpTG1TZ3k0czZ6L045dDdyK0pGcVcwMng3aXV2c1FvR3ljVjFGR2VrNWpMdzEyMkRzbHpOOW9jemRTSGtXR2ZHMmxyYXFidEEveW1LY1JDUFJ4RHplTW84TjdEU3VyNGl0M3JjaDV2bG52Nkk4YlE2T0NrTnhxRG9scGtQdUVlWW9OUktCRy9pTjVXZHVaQWJDdCtHS3RCZzVlTGdkWVdVcU1NN2phMTdCRzBINi8zTnRud2RkWUpmczl2aWZiNjE4elIzZUh6OGw0bGVsb2J4c01hRjlyUDFnSHBNL0xOODlSRDdMY1ArODA0OW9iWnFQZUxVZS9kRVh6bTdjWkIvUUgybWxSczgxTnhVcDltVFpNNmswMHV3RTQxbFQ2dndBQ0pJYTg3T3VudnNGY1dvZGJpWnE0dFJ5OXppcjFVL29zOUxyUHRVK285OUpNWU43OUZydlFZdllacktYalVtNGhhYnk2cVdKKzZleTdmVFNWR1lvRzNuRHlCdlM2cXAvbkIrM2Iva2V6MWpHbmI0MWhUcGM5NWY4WVB2TlA4WG41d3pzckJmY082V2V0M3hDKzlDc3J3UWZDVkhobjh3KytCdDgxRjdOQnZNbThIb1lQdjRZem40YmozSk90QUhTcGpPM0RTbjR1NHZnbjU2cStzRVJKbjlMWE5xVlhVNlN3NnEvT01rOHRzV3FTaE1EYUYrUmptbk4rRyswMUhxZDEzUFd0UUc5citkc2JRMzdDYStiT2RLR0lPNVJGMXdCZXRpSjQyNXNWV29ZeW1OZjJ3a2pKUHgxNjFuTFV3QjcycE8zUWxEcXIvb1VwOGIrMVAvNHNQN0p3aGVuK0lmZnBCMUpoK3dTWHQ0anB2TVRMTVNOeHA2elMvSDJ1REJ2TUdxbUszWXEvSEdtc3VVT2JYc0RqcUV4SWo0cWV3SHZWcFlzYUwrTXk3UVA4TlJtZUpHL0dkR1V1ZWhRM2t1T1NLMXhJOWRYM3czNGdseHB0a0Zka0dVVGJHcUkyVDdZeHRxZHVoYk5FM2Jmd3lodXdNbGRUbm92clcxSjgyWXBrZWpOVVJKOXRGYjhaamdzaStUUnoxZzlDblRjeTRsOWlUUExHeG1zeWhqSktIRW91U0x6Wm1TOUZSalViYnlFNU5YSTQwbWJXOElVanova0xPb0M5NjREYldqeXo2WjZIZmdCUnZBZTcwMytDTXVBVVYranllMXQ5bDdZdXp6bjJQODFVcSt5eHJWbVN6eUE1aUk1bnBvdjZSek0zTkNaYzUrUHliMTc4RlgzdCtHRVZ1MWR4Nk9BZXNKeDlsSG05c3JrK0gzTFhaOWFnWFhvdVQrMi9ZTzYvRmlYMzVhbXl5Z2d4OUF4RHJ5ZHdNbWZNRDNKYWNreWZ4SGpQZDdjZnJHaDVlVGx3K3c1aFYyT1A5REM4TE9PUDJrVjVzTVkyWWo5SHVER1M2YzRnTTFwcHNubTlXWUx4YmdUSzFqYm5iRFEzK1cremZjczdoK2NlZGhubkVUTFVGbGFvQzkvRjhrcTZtY083ZWlpNHluM3ZGT0dEbnZmNTR3UHlkTS9jQlpNYU9vRjZmd3lPbUhjcTlXanpCbUpublA0VDUzaEhPQ2RXWWJsS3dtM1ZtaUg0R3orc3BHQnJMdzFMWEQ0b3B4MHpkaWVlZ25zeVJXM2tHYUltQm5CdEtkUnJyeFdPTTQ3Tkk4YTlIaXVnWXV3MFRZZ013U2E3MWJOeEQyVlAxMDVUM1UzUjFnNkRhT1JHVU91OWpoUE1jMXFncUZLdGx4QXFpQUl0MEN5eFMrY0U2NnBIRnRjWE9VYzdkRzlsenBySEdyT0NacjR6Y20yaER2TUwvN3lBdU02VzZoUHZaTytMY0syN2VKV0pjUDg3MXQ0bG5lWjJGT2V6aHFmcHpiT0VjL2lPdkhjWlN6NlU2ZzNORmY0eGhUaGU3OTJLTU9zNTU2d3ZPQUdsODlqcjIrazQ4THhheGpuVEZBdjE5OXUwWUpxaTdhTXR4bEhNT3hxdlpXSzdtODkxenZKK1BJalVMQ3luM00rb1JMT05NdFVjQlQ3QStQTUM5R3NoMTZpSnphQ0R1MFkyY2JVdHBjOUhyQmZaRXptRzZMRGhySVhLS3pzMUI3TkE3dEVNSTlzSWp0TU1HOGduaWEvMlRJZm9uUXZSUC9uWWl5cTdjcHdsaSswUllQd1FseEhPaExHMUZuZ1MvYkJUZlJCRDVJbHdobi9ncWd2Z3NFV0tYeUlkWGdmV3A2QlA1TkVUc01PYjhIdzVYTFZjQUFIaWNkY0Z0VE5JSkF3QndEODJJak13akl6TkVSVVJFUkVSU1FrUlRNaUpFTWlJek11TklQU05EOGlFRkJNOHoza0hrek1nanpzeklPREpQZWZualhHdk90ZWFhWTY2NTVseGp6am5uSEhPdU9lZmNjNStlYjgvdkZ4WDFQL2lvMnFqNW4vZy9yWUUwb0ZIUUFtZ3ZtaFl0akpaSDI2STkwWE14c0pqeW1NRkQwRU0xaDREWXRGaCs3T0poeW1IT1lkRmh6K0h2WURTNDV3anhpUFRJRWdRUGtVTDhSNk9PaW81Nmo0Yml3SEcxY2NxNEw4Y2d4K3FPT1k4ZFFPdWg4OURkNDZUakRjZUJlRkE4TWI0NTNoTHZpcCtQLzNFaTRRVDVoRDhCa1NCT0NQMU0rTmtPUzRZSllUYlk4a24weWJLVGt5Y1BFcG1KNDZkZ3AycE96Y0dUNFExd0szenROT0cwN1BUNDZlMGtTQklyeWZSdjd4bmtHZE9aU0RJM1dYSVdjWloxTm95b1I3UWdkQWhyQ2pXRm0ySk5XVWdKcCt3ZzRjZ1c1QURTalZ4SDdxWFNVMW1wb2xSVnFqMTFPeTBtTFRFTmswWko0NlNKMGxiVEl1bWdkRmc2T3AyYXprNnZUNWVrYTlLM1VGR29CQlFLUlVaVm9nUW9Rd1lrSXprRG4wSFA0R1UwWm5qUk1EUWFYWWhtb3V2UXJlamV6UEpNVG1aRHBqU3pOOU9lNmM2Y3lWeklYTU5JTUQyWUFZd0xBMkRtTWQrekVyTXNXY05aazFseldkK3lOckZjckFncncrcXdRMWdQRnNET1laZXdHOWo5YkdnMk1wdVlYWjdOeTI3TVZtYXY0a1E0R1U2SEc4SjVjQjl3SWR3S2JnTzNud1BOUWVZUWM4cHplRG1OT1IwNXZUbURPV001TTNna1hvTzM0OTM0R2Z3Q1BvemZ5WTNLamN0RjVGSnlHYm5jWEdGdWUyNTNyaWwzSlRkQ0FCR2doQ1FDZ2NBZzhBZ2l3Z1Foa2dmS2crVWg4M0I1dER4T25panZBeEZCSkJETGlEVkVFVkZPdE9iRDg4ZnpQK1l2NW4vUDM4dy9JTVdUMGtna0VvUEVKd2xKcmFSdWtvM2tKTGxKTTZURkFuaUJwc0JlNEM2WUtWZ29DQmZza0NGa0pKbE1acEg1WkNHNW5hd2gyOGx1OGtmeUlubU52SHNPY2k3NUhQNmM5TnhPb2FCd3RpaXBTRmxrS1hJVmZTZ0tGYTBXL2FDQUtUQUtrb0tqRkZLYUtmT1VsZlB4NTh2T041N3ZQajk5ZnBPS29MS3BWdW9ZOVNOMW5ucFFqQzltRlF1TEI0dEhpc2VMcDRzL0ZTOFdmeS9lTE42bHhkUGdOQ1N0a2lhanFXZ2FtcVVrcmdSV2tsekNMT0dXMUphTWxMaExsa3RXNldsMExKMUlkOUJINlFlbGdsSnBxYTUwcU5SVCtxRTBWTHBSMWxBV3VoQjdRWFZodDV4VGJxK0FWVEFxMkJYZWlwbUtPUWFOd1dEWUdKR0w3SXRqRjc5V3dpdTdLL2N2Q1M3Tlh3cGYrc0VFTTVPWU9LYVZHYmtzdWl5N2JMb2NZWUZZTXRZcWEvTUs2QXJrU3NlVkRUYVZ6V2JYc3lYc1NmWjBWVndWckNxNVNsTFZVYlhCRVhLY25Ba093RG1vanEyR1ZpZFdJNnJSMWZocWNyV3llcjA2d3NWeHhkd3g3czVWeGxYSDFYQk5aYzNYYTlocnhHdU9hd2M4TksrRDE4MzdjVjE0M1hsOWdnL21zL2dEL0ZYKzVvM2tHNmdiMGh2T0c2NWFlbTFsYlUvdFhPM0J6Y3FiOXB2YmRlUTYreTN3TGNHdDFsczlnaGhCb2tBbVVBazBBb2RnOURiMGR1dnRwZHNidC9mcm9mWGMrb2s3Q1hla2Q1WWJCQTNmN21MdXl1NnVDbXVFSDMvQi9lSVgwVVViOThidVRkd0RHdkdObHNaUUU3d0ozMVRleEdtcWEvcmNYUGdyK05jdkxZS1czZnZNKzRQM3Y5eGZGeWVMQ2VMeUI3UUhuZ2V6RDc2MVVscUhXcmNmaWg0T1BKeVR4RW9ZRXJ0a1M3TFhGdHVXMElab3c3YVIyeXh0RVdtdGRQb1IvSkhra2ZLUjd0RmFlMW03czMzM1B6cFprZ3d0SThwb01xYU1LNnVWRGN1MlpRZVBJWTlySGpzZnV4LzdPNkFkRFIwakhlNU9SS2VtMDlicDdIUjFBcDN6Y3J4Y0x0ZkliZkt3Z3FuZ0tSb1VZa1dIb2xkaFZkZ1Zic1dNWWxHeHJvZ29kcFVRWmJLeVhibWszT29DZGNHNzhGM2xYZnd1VjlkbTE0RXFYb1ZXVVZRY2xWRFZvcEtxZENxSGFsTDFTZlZOdGFrR3FSUFZPSFdabXE5dVVjdlVQV3FIMnEvK3BGNVNyNm9qM1pYZHp1NjE3cTNmV0w5OTdhbnNBWDVuL3o3VGkrNDFQWWw1SW4reXBNRnJsSm92V3BxV29lVnFCZHBtYmJ0V283VnIzZG9aN1lJMnJOM1ZRWFZKT3JTdVVNZlUxZXVrT3AzT29adlVmZEt0NkxiMVlEMUNUOUpYNmdWNmlWNmpIOUpQNk9mMHkvcHQvWUVCWWtnMjRBMTBBOWZRYUZBYWJBYVhZY1lRTXF3YjlvMEpSb3lSWW1RWitVYWhzZFVvTjVxTVRxUFhPRzhNRzNkTlVCUEtSREZ4VENLVDNHUXlPVTBUcGxuVFY5TzZhYzhjWjRhYlVXYUNtV3BtbSt2TkVuT1BlY0RzTWdQbWVmT0tPV0xldDRBdFNSYWNwZEJTYnVGWkdpMGRGb1BGOFgrN0xCT1dhVXZJRXVtRDlxSDdLSDNjdnVZK1M5K0NGVzlsV25sV1VUK3VuOWJQNnhmMzkvWmIrMGY3SXphZXJjRzI5WWY4RDl0QXdvRG5LZndwK2FuaDZlWmc3Q0J5a0RKWU16ZysrUFZaMGpQaU05R3pIVHZISG5sT2ZWNzdYUFo4NHZubkljWVFkMGd3SkI0Uy83bmt3UDViNmhoMTdMeEF2ZUM5Nkg3aGYvSFpLWFZ1L2NYNWEyVVlQeXdlOXJ4TWZFbDhLWGtaSGlHTnRJOU12NEs4a3J5YWZMVXdHanZLRyswWW5YMGQ5WnIxZXNRRmNVbGRUdGZ5RzhnYndadWxNZkFZZlV3MzVuMGI5MWIzTnVTbXVJZmRlMyszLzczc0FYc2FQT0YzbUhlbWR6L0dNZVB1OTRudkJlKzczNjlOd0NjRUU3UC9FUDRSVFNJbTdWTXhVNVZUNDFQK3FkRFVwaGZraFhuUjNrSXYweXZ3U3IwRzc2QjN6RHZ0L2VJTmUzZDhzVDY0RCsrais3ZytvYS9kcC9FTitUeStENzZRYjkyMzU0L3pJL3hZUDlYUDl0ZjdKZjRlLzREZjVRZjhjLzRsLzRaL1B3QU5KQVZ3QVZxQUUyZ0lpQU9xZ0RYZ0NJd0hwZ09oUURpd0EwUUJDUUFLSUFNc1FBQTBBM0xBQkRnQk56QURmQWFXZ2ExZ1ZEQWhpQW5TZ3N4Z1hWQWM3QTdhZ3FOQmYzRDJ2KzBWaGxBQUFBQUFBUUFBQkJFQWx3QVdBRjhBQlFBQkFBQUFBQUFPQUFBQ0FBRWJBQU1BQVhpY2paTFBUdHRBRU1ZLzJ3RUVCRlJvaGJoMVR6MVV4UGtEdlFTSmdoQWdwSWhEcURqMTBDVXhpVVh3UnZaR0VaVjY2S1U4UW85VjM2QnYwR2ZvRTdUbkhucnJ2Wjgza3pSQWtXcHI3ZC9PN3M1OE03TUFsUGNCSGtiUFUrd0tleWppcmJDUE9Yd1VEckNPYjhJRkZMMkM4QXpXdkpmQ3M3VDNoZWZvLzZ2d1BHYTlYOEtMV1BBWGhZdDQ3TzhJTHlIMHZ3Z3Y0M253UXZnUlpvTkVlQVV6d1h2aFZSU0R6MVRsRmVZNTIzRUtjL2FvODQyd1QwODN3Z0VxK0NSYzRKNmZ3alBZOEZhRVo3SHVuUW5QWWRkN0p6elB2SDRJTCtLSjkxdTRpR2YrbXZBU1h2dE40V1c4OHI4TFA2TE9zWjRWTEFRRDRWV3NCemM0aEVFQ0M0VTJOUCthMUtLdGoydWtpTkZCMTYwZTBXWTQ2eUhpck1aY3F2emkwQ1JXdGJYVnFtWDYxMm5jNlZwMVpFeW5GNmxhcGNvTlRaNDY1N0FjQ28ySlJ6VE51YkZHTmZJaitiYUlDd082MXd5TFp0UVo5RFJoT216OVFXZDFFYlRKQXk1NGZkcDduVW8yLzF2SkdTT2x5TGljRjBiUmE4aFJjZjYzT0xZbjZkUG5XWlJtc1VsVU5heFdLdFd0NnJhNkg2dDBQMVpwa3ZXMHBKaFJsV3VBcFFMTmhrUzRjdlc0cE0zZzRrNGJ3b24wT0ZOYTJWUzNveXVkWGlweklUMElieGRRaW9NN1h2SjJYNDBYdzVZaDcxTnQ2Z1JaZnJVcnhFaHNYaHhMZTE0YzdIZlRPTE94VGhTRlJLbk5ESTE1dGkzdVM3Z3JZaEtLYlUxY01xbExyZXR1MEI1dm1PYSswZXoybVExYTdyYWhScUVWT285YlVaSkZiVFZJMmxHcWJEZFNlMzNkNGs5V050UzRKN1dRKy9PaVc0YXFvOHgzNk42UWdmOEdEeGtnWlMzS3JNYTBpSXlXQm81WmlnT2M0SlRmMGxoRTE5cCt2VndlRG9laGRzRkRrM2JLdlpHQXJOdzQzajg0T1Qwb09RSFRMWloyWWZwQy9QTW1QSFE1L3dCdkgrZ0JlSnh0MlFWWUc4bmZCL0NmaEZDc2R1N3VkejFpQk00am01YVdRbytXcTV3R1NDRnRTTGhJN2R6ZDNkM2QzZDN2L3VmdTd1NTM3MmJuQzFtNHQ4L1RmR2ZKekh4bVpuZVpaQ0VoNTkrL1h1cWwvK2VmWjRMOXdpU2s1S0VxOGxJMWphRWFxcVU2cXFjR0drdmphRHhOb0ltMEhDMVBLOUNLdEJLdFRLdlFxclFhclU1cjBKcTBGcTFONjlDNnRCNnRUeHZRaHJRUmJVeWIwS2EwR1cxT1c5QWsycElheVVkK0NsQ1FRdFJFWVdxbUZ0cUt0cVp0YUZ2YWpyYW5IU2hDVVlwUm5DeEswR1NhUXEwMGxhWlJHMDJuZHVxZ0diUWpkZEpNbWtWZHRCUE5wamswbCtiUnpyUUw3VXE3MGU2MEJ5WHBhcnFJRHFaRDZCNDZsVDZqUStsWU9vck9vU3ZvWWhZNmt0NmdnK2drK29GK3BHUG9ORHFjSHFKMzZIczZsNjZrbitrbitvVXVwR3ZvQ1hxTXJxVnU2cUhqN1pWNmlsTDBPRDFKejlIVDlBdzlTNS9UZkhxUm5xY1g2RHJxbysvb0JIcUZYcUtYcVorK3BLL3BDRnBBYVZwSUE1U2hMSjFQT2RxVEJpbFBCU3BSa1JiUll2cUNsdEF5V2twNzBUNjBOOTFPRjlCK3RDL3RUd2ZRVi9RTjNjbktIcTVpTDFmekdQcWIvdUVhcnVVNnJxZC9tYmlCeC9JNFpoN1BFM2dpTDhmTDh3cThJcS9FSy9NcXZDcXZSci9SNzd3NnI4RnI4bHE4TnEvRDYvSjZ2RDV2d0J2eVJyd3hiOEtiOG1iMEI3M0ttL01XUEltMzVFYjJzWjhESE9RUU4zR1ltN21GdDZJUDZFUGVtcmZoYlhrNzNwNTM0QWhIT2NaeHRqakJrM2tLdDlMMWRBTlA1V25jeHRPNW5UdDRCdS9JblR5VC9xUy82Q1A2bUdkeEYrL0VzM2tPeitWNXZEUHZ3cnZ5YnJ3Nzc4Rko3dVllN3VVVXorYys3dWMwM2NVTGVDRm5lSUErb1U4NVM1ZHlqZ2Q1VDg1emdZdGM0a1c4bUpmd1VsN0dlL0hldkEvdnkvdngvdlFhdlU5djBsdjBOcjFIcjlPN2ZBQWZ5QWZ4d1h3SUg4cUg4ZUY4QkIvSlIvSFJmQXdmeThmeDhYd0NuOGduOGNsOENsM09wL0pwZkRxZndXZnlXWHcybjhQbjhubDhQbC9BRi9KRmZERmZ3cGZ5Wlh3NW5jZFg4SlY4RlYvTjEvQzFmQjFmenpmd2pYd1QzOHkzOEsxOEc5L09kL0NkZkJmZnpmZnd2WFFXMzhmMzh3UDhJRC9FRC9Nai9DZy94by96RS93a1A4VlA4elA4TEQvSHovTUwvRDkra1YvaWwva1ZmcFZmNDlmNURYNlQzK0szK1IxK2w5L2o5L2tEL3BBLzRvLzVFLzZVUCtQUCtRditrci9pci9rYi9wYS80Ky81Qi82UmYrS2YrUmYrbFgvajMva1AvcFAvNHIvNUgvNVhTRmhFVkR4U0pWNnBsakZTSTdWU0ovWFNJR05sbkl5WENUSlJscFBsWlFWWlVWYVNsV1VWV1ZWV2s5VmxEVmxUMXBLMVpSMVpWOWFUOVdVRDJWQTJrbzFsRTlsVU5wUE5aUXVaSkZ0S28vakVMd0VKU2tpYUpDek4waUpieWRheWpXd3IyOG4yc29ORUpDb3hpWXNsQ1prc1U2UlZwc28wYVpQcDBpNGRNa04ybEU2WktiT2tTM2FTMlRKSDVzbzgyVmwya1YxbE45bGQ5cENrZEV1UDlFcEs1a3VmOUV0YUZzaEN5Y2lBWkNVbmc3S241S1VnUlNuSklsa3NTMlNwTEpPOVpHL1pSL2FWL1dSL09VQU9sSVBrWURsRURwWEQ1SEE1UW82VW8rUm9PVWFPbGVQa2VEbEJUcFNUNUdRNVJVNlYwK1IwT1VQT2xMUGtiRGxIenBYejVIeTVRQzZVaStSaXVVUXVsY3ZrY3JsQ3JwU3I1R3E1UnE2VjYrUjZ1VUZ1bEp2a1pybEZicFhiNUhhNVErNlV1K1J1dVVmdWxmdmtmbmxBSHBTSDVHRjVSQjZWeCtSeGVVS2VsS2ZrYVhsR25wWG41SGw1UWY0bkw4cEw4cks4SXEvS2EvSzZ2Q0Z2eWx2eXRyd2o3OHA3OHI1OElCL0tSL0t4ZkNLZnltZnl1WHdoWDhwWDhyVjhJOS9LZC9LOS9DQS95ay95cy93aXY4cHY4cnY4SVgvS1gvSzMvQ1AvS2ltcnFLcEhxOVNyMVRwR2E3Ulc2N1JlRzNTc2p0UHhPa0VuNm5LNnZLNmdLK3BLdXJLdW9xdnFhcnE2cnFGcjZscTZ0cTZqNitwNnVyNXVvQnZxUnJxeGJxS2I2bWE2dVc2aGszUkxiVlNmK2pXZ1FRMXBrNGExV1Z0MEs5MWF0OUZ0ZFR2ZFhuZlFpRVkxcG5HMU5LR1RkWXEyNmxTZHBtMDZYZHUxUTJmb2p0cXBNK2xHdWtsbmFSZmRTcmZSdzdvVDNVeTMwQ04wSUQxSWgrbHN1b29lMVRrNmwrNmwrM1FlM2EwNzZ5NzBxKzZxdStudXVvY210VnQ3NkdqdDFaVE8xejd0cDlQcFREcUR2cVZMNkVRNm15Nmo0K2hrT29YdTBEVGRyd3Qwb1daMFFMT2EwMEhkVS9OYTBLS1dkSkV1MWlXNlZKZnBYcnEzN3FQNzZuNjZ2eDZnQitwQmVyQWVvb2ZxWVhxNEhxRkg2bEY2dEI2angrcHhlcnllb0NmcVNYcXlucUtuNm1sNnVwNmhaK3BaZXJhZW8rZnFlWHErWHFBWDZrVjZzVjZpbCtwbGVybGVvVmZxVlhxMVhxUFg2blY2dmQ2Z04rcE5lclBlb3JmcWJYcTczcUYzNmwxNnQ5Nmo5K3A5ZXI4K29BL3FRL3F3UHFLUDZtUDZ1RDZoVCtwVCtyUStvOC9xYy9xOHZxRC8weGYxSlgxWlg5Rlg5VFY5WGQvUU4vVXRmVnZmMFhmMVBYMWZQOUFQOVNQOVdEL1JUL1V6L1Z5LzBDLzFLLzFhdjlGdjlUdjlYbi9RSC9Vbi9WbC8wVi8xTi8xZC85QS85Uy85Vy8vUmZ6M2tZWTk0MU9QeFZIbThubXJQR0UrTnA5WlQ1Nm4zTkhqR2VzWjV4bnNtZUNaV2w3THB4c1pJdkRveWtPeko1N0xWU1pQZVNIYyt0U2psVFRwUkhjbjE1YktwaGRWSmszV3hublMrcHpRd1A1TmFVdGRUS1R1OStSb2p5S2czM3BNc2Q5WnJJbTczbkN4V1c2QlNvQ3hEcFp5b3RYcHp4V1JQVHlwYnJFME5GNnN0RENCbDBtdVpIbE5PMUUxMkRhZHY5SEQ4alVoZi9lU2UzTUJBMG5SWjMrYzZxSnZpNnFHL1V2Wk02VTdtUGYzMmk3ZTFtTTcwcHJ4cEo2cGJNWWMwNXRCcTVwQTJ5OVdLMGFaTlN1dFVTUytvbStveUZsVEs5ZFBjbzFvNDRxQXZuMHBsTThsc2I3ckgyNWJzS1JWVDNvd1Q5VzN1ZWhuWGdiZk5MRTNHQ1UrYnZZYWVqUDNpYlRmdHM2Wjl1N3Q5MXQyKzNiVFBtcVhOSmdkemhXSStOOWlmVWl2YnA2bHNYM1VISnAvRDVEdk01SE5PTkhUMGw3Sjl5WHhwSUpNc0ZSdHk3aU52cHhsRDNveWgwejJHdkhzTW5XWU1lUk16VGF1Q0UzVXpYY3RZR0gyeW0veklnSGVXYVZ3MDZ6Q3JmQ0tMNVJQWlpVNWt5WnpJTHN5bGhMbDBtYm1VbktqcXlxZXpmVldsOG10RDE0aDVsZHhIMVYwNDRTWGNIN05kWTF6c0tzOTFsWmRXeXQ1NVpvYkxuS2lkVjdrRmxnMFhxeks1YkYraHFxTS9sODlXNVp6WEx1ZTFWSDQxczA0MDFrYktZelhkSkllTDFSSExaREpsMXJDamtFa1crazA1VnlrN3ZmaDl6Y2dXWkFRWk5Sa0lWeFY2K2hjbnpWRTBaaklScU9uTEp4ZWw3TlBZWGVQMDVwU2NWUzZYUFAyNTNFS25hcUF4TWNhZVZuY3FrMXRjVmN4bGM0V0czblFxbnlxa0M4NVJiU1F6Mko5MGlqWEpiSzZZeXFUU3lYcHJzSkMybDhENThSaXJpUGRiY3lqVmR3eWt5eWZRSEhTNUt0ZDJES1Q2VEtVSmFidjZDS3ZLc1R6UlZERlpOVGxwWDREVmNEeno3QitwN1ZUTjZyZExuakpVTlMwNU9KaTBiOFNCN3Q2a1RDOUplMG5tcEtzaHk0eTBkdmJucW1hbSt3YVNPaXRacXNZb2RFWi9XbVAyL3htRmRIMnJhd1RqVUdIb3VEWTVQUEg2bEh1NnFhSHBwb2VtdTN4cFpGTXpHYWU5cDdzOG1iN3laS3A2VTVsaXNocDllWmFWcDFSK3MraE1xZHhaMVVKblNobG5TdWJzUkdPU0xjbVN0SDE3Ty9QU2ZIL09XeWhQeWxmbGhCYnR1Y0hYUVh0ZVBmWi8rN0FxVjE3b2V2Y2FqeHMxelBxYyt5eVYzR2NwTjN5V3pERGlQcVFmMmVSa3NMRVI2VVA2a1FGa0VCbENEclVMSTV1UkxjZ0lNb3FNSWVOSUM1a3c2WVB2ZysrRDc0UHZnKytENzRQdmc0KzdLNGk3SzRpN0s0aTdLK2lENzRQdmcrK0RqKzBzNklmdmgrK0g3NGZ2aCsrSDc0ZnZoKytINzRmdmgrK0g3NGZ2aCsrSEg0QWZnQitBSDRBZmdCK0FINEFmZ0IrQUg0QWZnQitBSDRBZmdCK0FINEFmaEIrRUg0UWZoQitFSDRRZmhCK0VINFFmaEIrRUg0UWZoQitFSDRRZmhCK0NINElmZ2grQ0g0SWZnaCtDSDRJZmdoK0NINElmZ2grQ0g0SWZnaCtDM3dTL0NUNTJ2R0FUL0NiNFRmQ2I0RGZCYjRMZkJMOEpmaFA4SnZoTjhKdmdOOEVQd3cvREQ4TVB3dy9ERDhNUHd3L0REOE1Qd3cvREQ4TVB3dy9ERDhNUHcyK0czd3kvR1g0ei9HYjR6ZkNiNFRmRGJZYmJETGNaYmpQY1pyak5jSnZodHNCdGdkc0N0d1Z1Qzl3V3VDMXdXekR2RnZndDhGdmd0OEJ2Z2Q4Q3Z3VitDL3dJL0FqOENQd0kvQWo4Q1B3SS9BajhDUHdJL0FqOENQd0kvQWo4Q1B3SS9DajhLUHdvL0NqOEtQd28vQ2o4S1B3by9DajhLUHdvZkh5T0NFYmhSK0ZINGNmZ3grREg0TWZneCtESDRNZmd4K0RINE1mZ3grREg0TWZneCtESDRNZmd4K0ZqWHdwaVh3ckc0Y2ZoeCtFUDdWZHgrSEg0Y2ZoeCtISDRjZmh4K0hINGNmZ1dmQXUrQmQrQ2I4RzM0RnZ3TGZnV2ZBdStCZCtDYjhHMzRGdndMZmdKK0FuNENmZ0orQW40Q2ZnSitBbjRDZmdKK0FuNENmZ0orQW40Q2ZnSjQ0ZXc3NGV3NzRldzc0ZXc3NGV3NzRldzc0ZXc3NGV3NzRldzc0ZXc3NGV3NzRldzc0ZXc3NGV3NzRldzc0ZXc3NGV3NzRldzc0ZXc3NGZNdnUrenpQanM5SmswKzVhZENlOXM1NE94ZDdHSjJlYXovbUluYW1ZUGZUU3FXVHhVTXUwaTZDK0Mvc3o5YmljOGM3L2JHVUkySWNQSVptUUxNb0tNSW1QSU9CTGpOZmU3ejRyQ2o4S1B3by9DajhLUHdvL0NqOEtQd28vQ2o4S1B3by9DajhLUHdvL0NqOEdQd1kvQmo4R1B3WS9CajhHUHdZL0JqOEdQd1kvQmo4R1B3WS9CajhHUHc0L0RqOE9QdzQvRGo4T1B3NC9EajhPUHc0L0RqOE9QdzQvRGo4T1B3N2ZnVy9BdCtCWjhDNzRGMzRKdndiZmdXL0F0K0JaOEM3NEYzNEp2d1UvQVQvaThjODJGdTlRSi9CUjZBbm9DZWdKNkFycTUyMzBKODJuSzMyanVFanQ5U0Q4eWdBd2lROGdtWkJqWmpHeEJScEJSazc1UVF5bmJtOG9YZW5MNVZHOTNwbUhQa3YwRnN2eGRQbDlJOVpvNi9wQjNJSjExbmlqWTMweXp2VFdwSlQzMkZ5Qzd0bmsvSEt6SkZrcURxWHc2bC9kazB2bWtkekJWc0w4d21YY2pVWTlWeXVlY0F4K0c2VE8vQk94c3Fra1ZpdW1CWkRIVlc1UExwbExwdnY1aWYzMnhQNTlDdVZBM1A3MW9xRnhmc0FlV0hYckQ5UUNrM0ZzaWFoYkh6Z0RTV1p5RVpYNGxKaExtVjZhZGNVOTdWMXViZDg2a3drRFBZSzNUcVZPc1daYks1eVpsc3FXQk1mWmduTUxZVERMZlowK3RUTnBmeU90N2x1YlRtVXk2cDN3dzNuMlFTYzB2MWczOW9KanVHZXM4RVJuK090L2dISllybG8vTW04UGYrcGVyUE5vWWJqQ3g4ck9oVnE1cXc0OE9YRDhiN3M3MFBseGxnbXVoOHVVdnhDbHZ4Sm11TjJvaVppSnV3aktSTURIWnhCUVRyU2FtbXBobW9zM0VkQlB0SmpwTTdHaWkwOFJNRTdOTWRKbll5Y1JzY3pLY1UrK3N2SGV1ZVdPZTY5U1VTODZwY1FyRnhUbDNJNmZhL0Z3cGo1SjkzWmg2aGZTU1NvTnkxN1hPSldTcVpkUG9ydHJwdHpSWTdYUmJHcXhCcjZYQk1hYlRjc0hwMDY3amRHblh3YlZqbDlDbFhjbjBhQmZNa08yQy9SVytVT2hPNW11R256RFY5Q1lMNldSdVNUcHBSbHdlbFJteGMvV1Z1M2NHYXZvdkY2djZKaVV6Ull6Y3FlNDR6a3JOTUZOeEhtZVVhelVNWFlmT2hWQm5uaU9iSmJDSy9hWnkrUUdmVTZxTE9GY0t5czdvblBMNFNPWFN3cHZPeGVtVXgwYUdkbDl6QnB6SGFFNXhYT1dKbW5QY0VPdEo5ZHFEU1pvK0xCZG11VEJyRkRiV0dnSFV0YnJhdGJyYXRZNXUxenF5WFh0bHpIVWRyajQ2WEgxMGpKNW9oMnVpSFNQNzYzTDEwZVhxbzJ2ME9McEd0cHRicVZ1UHZ4MWdVWjF6aERmTTQxRHpSc3pWZTJ4VTcvWGxqMUsreGdocU9vOXNUVGxlS2RkYmJzZXFPT01xZnpOQVJiZHJWWG9ZUDNuMHlreDJqZFlaZzcvUk9aamcvbE9CYVR0bGROdld5cXJXdDdxSDF1cnF0TlUxbEhHdEk4YzVmdXFvTGlkTUc2M1d0VlZXYlVMYmY5K3R6SzJtL0tRZjE0aXJUZnQvMnJTN1ZyVERQZXlPeXJBbmpuaUliOTd1ZFBYYStaOWVPMTNuYkticlRNOGNOY1dHbVNOdW41bVZaaE5tL2FmVFdhNU91MXlyM2VVZWRsZGwyTFZkdzdmdHhLNy96S0MreTNVdXhzOGVOYkR4YzBkZjhYTkhYdkh6S3JNYU4yL2tpYXliVnhub09IdDNIVWhtN1U4VHB0My9BZW0wMUJRQWVKd2R6ajBLd2pBWUJ1REV2eGFwYmFrT09raEZ4Q1ZnL0JsRUhBcHFjUlJ4RW9mT0NsSkJPMHJGQzNnRWo2QmtjZlFJZWhPUFVMKzN5OE9iN3lmSjB4QlBKcGppV2thd0Z3ODM4MTZkNmVLVnVlNVc0elJsOTJ1L1gwYktMU2VEVmdrcFB4MEtOMDBGMlhacmFkSkduV1phWTByWE5McTE0WiszMVpucUZ2bFJIY0FGZkVHanlFL0tNeWdGSUFiU29Ob0NoT0FHSGlBQnJzRWpiRVRZaUxBUktjdkVMdmdCMTZTNUFOekFCeVRBTTJrNEJHOGJEOWxVdTRNM3NHeHFTQkE0MUUzQXg4RmZnTVJSVmdnUHhNUWZ6Y0ZaT3dBQVwiO1xuIiwiaW1wb3J0IHtkZWZpbmVDb21wb25lbnRTdHlsZSwgZGVmaW5lU3R5bGVGb3JDb21wb25lbnQsIGRlZmluZUN1c3RvbUJhc2V9IGZyb20gXCJsaWItc291cmNlL3YyL3N0eWxlLmpzXCI7XHJcbmltcG9ydCBSaXBwbGUgZnJvbSBcImxpYi1zb3VyY2UvdWl2Mi9yaXBwbGUuanNcIjtcclxuaW1wb3J0IEljb24gZnJvbSAnbGliLXNvdXJjZS91aXYyL2ljb24uanMnO1xyXG5pbXBvcnQgVG91Y2hhYmxlIGZyb20gJ2xpYi1zb3VyY2UvdWl2Mi9Ub3VjaGFibGUnO1xyXG5pbXBvcnQgdmFycyBmcm9tICdsaWItc291cmNlL3VpdjIvdmFycyc7XHJcbmltcG9ydCB7dHJhbnNmZXJQcm9wc30gZnJvbSAnbGliLXNvdXJjZS92Mi91dGlscyc7XHJcblxyXG5kZWZpbmVDb21wb25lbnRTdHlsZShcclxuICAgICdidXR0b24nLFxyXG4gICAgJ2NvcmUnLFxyXG4gICAge1xyXG4gICAgICAgIFwid3JhcHBlclwiOiB7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxyXG4gICAgICAgICAgICB0ZXh0QWxpZ246ICdjZW50ZXInLFxyXG4gICAgICAgICAgICBtYXJnaW46IDQsXHJcbiAgICAgICAgICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcclxuICAgICAgICAgICAgekluZGV4OiBcIiswXCIsXHJcbiAgICAgICAgICAgIHdoaXRlU3BhY2U6ICdwcmUnLFxyXG4gICAgICAgICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAndHJhbnNwYXJlbnQnLFxyXG4gICAgICAgICAgICBjb2xvcjogJ2JsYWNrJyxcclxuICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAzXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcIndyYXBwZXI6Zm9jdXNcIjoge1xyXG4gICAgICAgICAgICBvdXRsaW5lOiAnbm9uZSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwid3JhcHBlcltkaXNhYmxlZF1cIjoge1xyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjZWFlYWVhJyxcclxuICAgICAgICAgICAgY29sb3I6ICcjYTBhMGEwJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJ0ZXh0LXdyYXBwZXJcIjoge1xyXG4gICAgICAgICAgICBkaXNwbGF5OiAndGFibGUnLFxyXG4gICAgICAgICAgICB3aWR0aDogJzEwMCUnXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcInRleHRcIjoge1xyXG4gICAgICAgICAgICBoZWlnaHQ6ICcxMDAlJyxcclxuICAgICAgICAgICAgd2lkdGg6ICcxMDAlJyxcclxuICAgICAgICAgICAgcGFkZGluZzogNSxcclxuICAgICAgICAgICAgcGFkZGluZ0xlZnQ6IDE1LFxyXG4gICAgICAgICAgICBwYWRkaW5nUmlnaHQ6IDE1LFxyXG4gICAgICAgICAgICB0ZXh0QWxpZ246ICdjZW50ZXInLFxyXG4gICAgICAgICAgICB2ZXJ0aWNhbEFsaWduOiAnbWlkZGxlJyxcclxuICAgICAgICAgICAgd2hpdGVTcGFjZTogJ3ByZScsXHJcbiAgICAgICAgICAgIGRpc3BsYXk6ICd0YWJsZS1jZWxsJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJ3cmFwcGVyID4gb3ZlcmxheVwiOiB7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxyXG4gICAgICAgICAgICB0b3A6IDAsXHJcbiAgICAgICAgICAgIGxlZnQ6IDAsXHJcbiAgICAgICAgICAgIHJpZ2h0OiAwLFxyXG4gICAgICAgICAgICBib3R0b206IDAsXHJcbiAgICAgICAgICAgIHRyYW5zaXRpb246ICdiYWNrZ3JvdW5kLWNvbG9yIDUwMG1zIGxpbmVhcidcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiLmNvcmUtZGVza3RvcCBvdmVybGF5OmhvdmVyXCI6IHtcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiB2YXJzLmhvdmVyQ29sb3JcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwid3JhcHBlcjphY3RpdmUgPiBvdmVybGF5XCI6IHtcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiB2YXJzLmFjdGl2ZUNvbG9yLFxyXG4gICAgICAgICAgICB0cmFuc2l0aW9uOiAnbm9uZSdcclxuICAgICAgICB9XHJcbiAgICB9XHJcbik7XHJcblxyXG5jb25zdCBCdXR0b24gPSBwcm9wcyA9PiB7XHJcbiAgICBsZXQge1xyXG4gICAgICAgIHRleHQsXHJcbiAgICAgICAgb25UYXAgPSAoKSA9PiBjb25zb2xlLndhcm4oXCJObyBvblRhcCBnaXZlbiB0byBCdXR0b25cIiksXHJcbiAgICAgICAgc3R5bGVOYW1lID0gXCJjb3JlXCIsXHJcbiAgICAgICAgYnV0dG9uQ29sb3IgPSBudWxsLFxyXG4gICAgICAgIHRleHRDb2xvciA9IG51bGwsXHJcbiAgICAgICAgZmx1c2gsXHJcbiAgICAgICAgYmxvY2ssXHJcbiAgICAgICAgZmlsbCxcclxuICAgICAgICBwYWRkaW5nLFxyXG4gICAgICAgIGRpc2FibGVkLFxyXG4gICAgICAgIGljb25OYW1lID0gbnVsbCxcclxuICAgICAgICBpY29uU2l6ZSA9IG51bGxcclxuICAgIH0gPSBwcm9wcztcclxuXHJcbiAgICBjb25zdCB3cmFwcGVyTmFtZSA9IGBidXR0b24tY29yZS13cmFwcGVyIGJ1dHRvbi0ke3N0eWxlTmFtZX0td3JhcHBlci1jdXN0b21gO1xyXG5cclxuICAgIGNvbnN0IHdyYXBwZXJTdHlsZSA9IHtiYWNrZ3JvdW5kQ29sb3I6IGJ1dHRvbkNvbG9yfTtcclxuICAgIGNvbnN0IHRleHRXcmFwcGVyU3R5bGUgPSB7fTtcclxuICAgIGNvbnN0IHRleHRTdHlsZSA9IHtjb2xvcjogdGV4dENvbG9yfTtcclxuICAgIGxldCByaXBwbGVFbGVtZW50O1xyXG4gICAgbGV0IG9uVGFwSGFuZGxlcjtcclxuXHJcbiAgICBpZiAoZGlzYWJsZWQgIT09IHRydWUpIHtcclxuICAgICAgICAvLyByaXBwbGVFbGVtZW50ID0gPFJpcHBsZSAvPjtcclxuICAgICAgICBvblRhcEhhbmRsZXIgPSBvblRhcDtcclxuICAgIH1cclxuICAgIGlmIChibG9jayA9PT0gdHJ1ZSkge1xyXG4gICAgICAgIHdyYXBwZXJTdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcclxuICAgIH1cclxuICAgIGlmIChmaWxsID09PSB0cnVlKSB7XHJcbiAgICAgICAgZmx1c2ggPSB0cnVlO1xyXG4gICAgICAgIHdyYXBwZXJTdHlsZS53aWR0aCA9ICcxMDAlJztcclxuICAgICAgICB3cmFwcGVyU3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xyXG4gICAgICAgIHRleHRXcmFwcGVyU3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xyXG4gICAgICAgIHRleHRTdHlsZS5wYWRkaW5nID0gMDtcclxuICAgIH1cclxuICAgIGlmIChmbHVzaCA9PT0gdHJ1ZSkge1xyXG4gICAgICAgIHdyYXBwZXJTdHlsZS5tYXJnaW4gPSAwO1xyXG4gICAgfVxyXG4gICAgaWYgKGljb25OYW1lICE9PSBudWxsKSB7XHJcbiAgICAgICAgdGV4dCA9IDxzcGFuPjxJY29uIG5hbWU9e2ljb25OYW1lfSBzaXplPXtpY29uU2l6ZX0gLz57dGV4dH08L3NwYW4+O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPFRvdWNoYWJsZSBjb21wb25lbnQ9XCJkaXZcIiB0YWJJbmRleD17LTF9IGNsYXNzTmFtZT17d3JhcHBlck5hbWV9IG9uVGFwPXtvblRhcEhhbmRsZXJ9IGRpc2FibGVkPXtkaXNhYmxlZH0gc3R5bGU9e3dyYXBwZXJTdHlsZX0+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYnV0dG9uLWNvcmUtdGV4dC13cmFwcGVyXCIgc3R5bGU9e3RleHRXcmFwcGVyU3R5bGV9PlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJidXR0b24tY29yZS10ZXh0XCIgc3R5bGU9e3RleHRTdHlsZX0+e3RleHR9PC9kaXY+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImJ1dHRvbi1jb3JlLW92ZXJsYXlcIiAvPlxyXG4gICAgICAgICAgICB7cmlwcGxlRWxlbWVudH1cclxuICAgICAgICA8L1RvdWNoYWJsZT5cclxuICAgICk7XHJcbn07XHJcbkJ1dHRvbi5jb21wb25lbnROYW1lID0gJ2J1dHRvbic7XHJcblxyXG5kZWZpbmVDdXN0b21CYXNlKFxyXG4gICAgQnV0dG9uLFxyXG4gICAgKHtub3JtYWwgPSBudWxsLCBmb2N1cyA9IG51bGwsIGRpc2FibGVkID0gbnVsbH0pID0+IHRyYW5zZmVyUHJvcHMoe1xyXG4gICAgICAgIFwiLmJ1dHRvbi1jb3JlLXdyYXBwZXIvd3JhcHBlci1jdXN0b21cIjogW1xyXG4gICAgICAgICAgICBub3JtYWwsXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRleHRDb2xvcjogJ2NvbG9yJyxcclxuICAgICAgICAgICAgICAgIGNvbG9yOiAnYmFja2dyb3VuZENvbG9yJyxcclxuICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1czogJ2JvcmRlclJhZGl1cycsXHJcbiAgICAgICAgICAgICAgICBzaGFkb3c6ICdib3hTaGFkb3cnXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gWydiYWNrZ3JvdW5kQ29sb3InLCAnY29sb3InLCAnYm9yZGVyUmFkaXVzJywgJ2JveFNoYWRvdyddXHJcbiAgICAgICAgXSxcclxuICAgICAgICBcIi5idXR0b24tY29yZS13cmFwcGVyL3dyYXBwZXItY3VzdG9tOmZvY3VzXCI6IFtcclxuICAgICAgICAgICAgZm9jdXMsXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRleHRDb2xvcjogJ2NvbG9yJyxcclxuICAgICAgICAgICAgICAgIGNvbG9yOiAnYmFja2dyb3VuZENvbG9yJyxcclxuICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1czogJ2JvcmRlclJhZGl1cycsXHJcbiAgICAgICAgICAgICAgICBzaGFkb3c6ICdib3hTaGFkb3cnXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gWydiYWNrZ3JvdW5kQ29sb3InLCAnY29sb3InLCAnYm9yZGVyUmFkaXVzJywgJ2JveFNoYWRvdyddXHJcbiAgICAgICAgXSxcclxuICAgICAgICBcIi5idXR0b24tY29yZS13cmFwcGVyL3dyYXBwZXItY3VzdG9tW2Rpc2FibGVkXVwiOiBbXHJcbiAgICAgICAgICAgIGRpc2FibGVkLFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0Q29sb3I6ICdjb2xvcicsXHJcbiAgICAgICAgICAgICAgICBjb2xvcjogJ2JhY2tncm91bmRDb2xvcicsXHJcbiAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6ICdib3JkZXJSYWRpdXMnLFxyXG4gICAgICAgICAgICAgICAgc2hhZG93OiAnYm94U2hhZG93J1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFsnYmFja2dyb3VuZENvbG9yJywgJ2NvbG9yJywgJ2JvcmRlclJhZGl1cycsICdib3hTaGFkb3cnXVxyXG4gICAgICAgIF1cclxuICAgIH0pXHJcbik7XHJcblxyXG5kZWZpbmVTdHlsZUZvckNvbXBvbmVudChcclxuICAgIEJ1dHRvbiwgXCJjYW5jZWxcIixcclxuICAgIHtcclxuICAgICAgICBub3JtYWw6IHtcclxuICAgICAgICAgICAgY29sb3I6IFwiI2I1MjYzZVwiLFxyXG4gICAgICAgICAgICB0ZXh0Q29sb3I6ICd3aGl0ZSdcclxuICAgICAgICB9XHJcbiAgICB9XHJcbik7XHJcbmRlZmluZVN0eWxlRm9yQ29tcG9uZW50KFxyXG4gICAgQnV0dG9uLCBcImNvbmZpcm1cIixcclxuICAgIHtcclxuICAgICAgICBub3JtYWw6IHtcclxuICAgICAgICAgICAgY29sb3I6IFwiIzMwZDVhN1wiXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4pO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uO1xyXG4iLCJpbXBvcnQge2RlZmluZUNvbXBvbmVudFN0eWxlLCBUaGVtZX0gZnJvbSBcImxpYi1zb3VyY2UvdjIvc3R5bGVcIjtcclxuaW1wb3J0IEJ1dHRvbiBmcm9tIFwibGliLXNvdXJjZS91aXYyL0J1dHRvblwiO1xyXG5pbXBvcnQgQ2VudGVyQ29udGVudCBmcm9tICdsaWItc291cmNlL3VpdjIvQ2VudGVyQ29udGVudCc7XHJcblxyXG5jb25zdCBjb29sQmx1ZSA9IFwiIzJGQjFERlwiO1xyXG5kZWZpbmVDb21wb25lbnRTdHlsZShcclxuICAgICdjYWxlbmRhcicsXHJcbiAgICAnY29yZScsXHJcbiAgICB7XHJcbiAgICAgICAgJ2RheSc6IHtcclxuICAgICAgICAgICAgaGVpZ2h0OiAnMTAwJScsXHJcbiAgICAgICAgICAgIGZvbnRTaXplOiAxNCxcclxuICAgICAgICAgICAgdGV4dEFsaWduOiAnY2VudGVyJyxcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiZGF5W2RhdGEtaW5hY3RpdmVdXCI6IHtcclxuICAgICAgICAgICAgY29sb3I6ICdsaWdodGdyYXknLFxyXG4gICAgICAgICAgICBwYWRkaW5nVG9wOiA0XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4pO1xyXG4vKmJnY29sb3IgdGV4dGNvbG9yIGFsbCAzKi9cclxuLy8gY29uc3QgQ2FsZW5kYXIgPSAoe3NlbGVjdGVkRGF0ZX0pID0+XHJcbmNsYXNzIENhbGVuZGFyIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XHJcbiAgICAgICAgc3VwZXIocHJvcHMpO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XHJcbiAgICAgICAgICAgIG1vbnRoOiBwcm9wcy5zZWxlY3RlZERhdGUubW9udGgsXHJcbiAgICAgICAgICAgIHllYXI6IHByb3BzLnNlbGVjdGVkRGF0ZS55ZWFyXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBwcmV2TW9udGggPSAoKSA9PiB7XHJcbiAgICAgICAgbGV0IHttb250aCwgeWVhcn0gPSB0aGlzLnN0YXRlO1xyXG5cclxuICAgICAgICBtb250aCAtPSAxO1xyXG5cclxuICAgICAgICBpZiAobW9udGggPT09IC0xKSB7XHJcbiAgICAgICAgICAgIG1vbnRoID0gMTE7XHJcbiAgICAgICAgICAgIHllYXIgLT0gMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe21vbnRoLCB5ZWFyfSk7XHJcbiAgICB9XHJcbiAgICBuZXh0TW9udGggPSAoKSA9PiB7XHJcbiAgICAgICAgbGV0IHttb250aCwgeWVhcn0gPSB0aGlzLnN0YXRlO1xyXG5cclxuICAgICAgICBtb250aCArPSAxO1xyXG5cclxuICAgICAgICBpZiAobW9udGggPT09IDEyKSB7XHJcbiAgICAgICAgICAgIG1vbnRoID0gMDtcclxuICAgICAgICAgICAgeWVhciArPSAxO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7bW9udGgsIHllYXJ9KTtcclxuICAgIH1cclxuXHJcbiAgICBzZWxlY3QgPSAoZGF0ZSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHtvbkNoYW5nZSA9ICgpID0+IHt9fSA9IHRoaXMucHJvcHM7XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coZGF0ZS50b1N0cmluZygpKTtcclxuICAgICAgICBvbkNoYW5nZShkYXRlKTtcclxuICAgIH1cclxuXHJcbiAgICByZW5kZXIgPSAoKSA9PiB7XHJcbiAgICAgICAgY29uc3Qge3NlbGVjdGVkRGF0ZX0gPSB0aGlzLnByb3BzO1xyXG4gICAgICAgIGNvbnN0IHttb250aCwgeWVhcn0gPSB0aGlzLnN0YXRlO1xyXG4gICAgICAgIGNvbnN0IGJhc2VEYXRlID0gY2hyb25vKHttb250aCwgeWVhcn0pLnN0YXJ0T2YoJ3dlZWsnKTtcclxuXHJcbiAgICAgICAgY29uc3QgY3VycmVudCA9IGNocm9ubyhzZWxlY3RlZERhdGUpO1xyXG5cclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICA8ZGl2IHN0eWxlPXt7Y29sb3I6ICdibGFjayd9fT5cclxuICAgICAgICAgICAgICAgIDxVSS5QaW5ib2FyZCBoZWlnaHQ9ezMwfT5cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IHBpbkluZm89e3tiYWNrZ3JvdW5kQ29sb3I6IGNvb2xCbHVlLCB0b3A6IDAsIGxlZnQ6IDAsIGJvdHRvbTogMCwgcmlnaHQ6IDB9fSAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDxCdXR0b24gcGluSW5mbz17e3RvcDogMCwgbGVmdDogMCwgaGVpZ2h0OiAnMTAwJScsIHdpZHRoOiAzMH19IGljb25OYW1lPVwiaW9uLWFycm93LWxlZnQtYlwiIGZpbGwgZmx1c2ggb25UYXA9e3RoaXMucHJldk1vbnRofSB0ZXh0Q29sb3I9XCJ3aGl0ZVwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPENlbnRlckNvbnRlbnQgcGluSW5mbz17e3RvcDogMCwgbGVmdDogMzAsIHJpZ2h0OiAzMCwgYm90dG9tOiAwLCBjb2xvcjogJ3doaXRlJ319IGhlaWdodD1cIjEwMCVcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAge21vbnRoICsgMX0ve3llYXJ9XHJcbiAgICAgICAgICAgICAgICAgICAgPC9DZW50ZXJDb250ZW50PlxyXG4gICAgICAgICAgICAgICAgICAgIDxCdXR0b24gcGluSW5mbz17e3RvcDogMCwgcmlnaHQ6IDAsIGhlaWdodDogJzEwMCUnLCB3aWR0aDogMzB9fSBpY29uTmFtZT1cImlvbi1hcnJvdy1yaWdodC1iXCIgZmlsbCBmbHVzaCBvblRhcD17dGhpcy5uZXh0TW9udGh9IHRleHRDb2xvcj1cIndoaXRlXCIgLz5cclxuICAgICAgICAgICAgICAgIDwvVUkuUGluYm9hcmQ+XHJcbiAgICAgICAgICAgICAgICA8VUkuR3JpZCBjb2xDb3VudD17N30gcm93Q291bnQ9ezd9IGhlaWdodD17MTk1fT5cclxuICAgICAgICAgICAgICAgICAgICB7WydzJywgJ20nLCAndCcsICd3JywgJ3QnLCAnZicsICdzJ10ubWFwKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXR0ZXIgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDxDZW50ZXJDb250ZW50IGtleT17bGV0dGVyfT57bGV0dGVyLnRvVXBwZXJDYXNlKCl9PC9DZW50ZXJDb250ZW50PjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICl9XHJcbiAgICAgICAgICAgICAgICAgICAge2ZhY3RvdHVtLnJhbmdlKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA0MixcclxuICAgICAgICAgICAgICAgICAgICAgICAgbiA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRlID0gYmFzZURhdGUuc2hpZnQobiwgJ2RheXMnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGVWYWx1ZSA9IHNlbGVjdGVkRGF0ZS5zZXQoe21vbnRoOiBkYXRlLm1vbnRoLCB5ZWFyOiBkYXRlLnllYXIsIGRhdGU6IGRhdGUuZGF0ZX0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRlLm1vbnRoID09PSBtb250aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBidXR0b25TdHlsZSA9IHt9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0ZS55ZWFyID09PSBjdXJyZW50LnllYXIgJiYgZGF0ZS5tb250aCA9PT0gY3VycmVudC5tb250aCAmJiBkYXRlLmRhdGUgPT09IGN1cnJlbnQuZGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b25TdHlsZSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbkNvbG9yOiBjb29sQmx1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRDb2xvcjogJ3doaXRlJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjYWxlbmRhci1jb3JlLWRheVwiIGtleT17bn0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8QnV0dG9uIHRleHQ9e2RhdGUuZGF0ZSArIDF9IGZsdXNoIGZpbGwgb25UYXA9eygpID0+IHRoaXMuc2VsZWN0KGRhdGVWYWx1ZSl9IHsuLi5idXR0b25TdHlsZX0gLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDxkaXYga2V5PXtufSBjbGFzc05hbWU9XCJjYWxlbmRhci1jb3JlLWRheVwiIGRhdGEtaW5hY3RpdmU+e2RhdGUuZGF0ZSArIDF9PC9kaXY+O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgKX1cclxuICAgICAgICAgICAgICAgIDwvVUkuR3JpZD5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgKTtcclxuICAgIH1cclxufVxyXG5DYWxlbmRhci5jb21wb25lbnRTdHlsZU5hbWUgPSAnY2FsZW5kYXInO1xyXG5cclxuQ2FsZW5kYXIudmFsdWVQcm9wID0gXCJzZWxlY3RlZERhdGVcIjtcclxuQ2FsZW5kYXIudmFsdWVGdW5jdGlvbiA9IGRhdGUgPT4gZGF0ZTtcclxuQ2FsZW5kYXIuZGVmYXVsdFByb3BWYWx1ZSA9ICgpID0+IGNocm9ubygpO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgQ2FsZW5kYXI7XHJcbiIsImltcG9ydCB7ZGVmaW5lQ29tcG9uZW50U3R5bGV9IGZyb20gXCJsaWItc291cmNlL3YyL3N0eWxlXCI7XHJcblxyXG5kZWZpbmVDb21wb25lbnRTdHlsZShcclxuICAgICdjYXJkJyxcclxuICAgICdjb3JlJyxcclxuICAgIHtcclxuICAgICAgICBcImNvbnRhaW5lclwiOiB7XHJcbiAgICAgICAgICAgIG1hcmdpbjogNSxcclxuICAgICAgICAgICAgcGFkZGluZzogNSxcclxuICAgICAgICAgICAgYm94U2hhZG93OiAnMXB4IDJweCAycHggcmdiYSgxMjAsIDEyMCwgMTIwLCAwLjE1KScsXHJcbiAgICAgICAgICAgIGJvcmRlcjogJzFweCBzb2xpZCAjZTBlMGUwJyxcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnd2hpdGUnLFxyXG4gICAgICAgICAgICBib3JkZXJSYWRpdXM6IDNcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwidGl0bGVcIjoge1xyXG4gICAgICAgICAgICBmb250U2l6ZTogMjAsXHJcbiAgICAgICAgICAgIHBhZGRpbmc6IDMsXHJcbiAgICAgICAgICAgIGNvbG9yOiAnYmxhY2snXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4pO1xyXG5jb25zdCBDYXJkID0gKHtjaGlsZHJlbiwgdGl0bGUgPSBudWxsfSkgPT4ge1xyXG4gICAgbGV0IGNvbnRlbnQ7XHJcblxyXG4gICAgaWYgKHRpdGxlID09PSBudWxsKSB7XHJcbiAgICAgICAgY29udGVudCA9IGNoaWxkcmVuO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBjb250ZW50ID0gKFxyXG4gICAgICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjYXJkLWNvcmUtdGl0bGVcIj57dGl0bGV9PC9kaXY+XHJcbiAgICAgICAgICAgICAgICB7Y2hpbGRyZW59XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNhcmQtY29yZS1jb250YWluZXJcIj5cclxuICAgICAgICAgICAge2NvbnRlbnR9XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICApO1xyXG59O1xyXG5DYXJkLmNvbXBvbmVudFN0eWxlTmFtZSA9ICdjYXJkJ1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgQ2FyZDtcclxuIiwiaW1wb3J0IHtkZWZpbmVDb21wb25lbnRTdHlsZX0gZnJvbSBcImxpYi1zb3VyY2UvdjIvc3R5bGVcIjtcclxuXHJcbmRlZmluZUNvbXBvbmVudFN0eWxlKFxyXG4gICAgJ2NlbnRlci1jb250ZW50JyxcclxuICAgICdjb3JlJyxcclxuICAgIHtcclxuICAgICAgICAnY29udGFpbmVyJzoge1xyXG4gICAgICAgICAgICBkaXNwbGF5OiAndGFibGUnLFxyXG4gICAgICAgICAgICB3aGl0ZVNwYWNlOiAncHJlJyxcclxuICAgICAgICAgICAgdGV4dEFsaWduOiAnY2VudGVyJyxcclxuICAgICAgICAgICAgd2lkdGg6ICcxMDAlJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgJ2NvbnRlbnQnOiB7XHJcbiAgICAgICAgICAgIGRpc3BsYXk6ICd0YWJsZS1jZWxsJyxcclxuICAgICAgICAgICAgdmVydGljYWxBbGlnbjogJ21pZGRsZScsXHJcbiAgICAgICAgICAgIHBhZGRpbmc6ICdhdXRvJ1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuKTtcclxuY29uc3QgQ2VudGVyQ29udGVudCA9ICh7Y2hpbGRyZW4sIHdpZHRoLCBoZWlnaHQsIGNsYXNzTmFtZSA9IFwiXCJ9KSA9PlxyXG4gICAgPGRpdiBjbGFzc05hbWU9e2BjZW50ZXItY29udGVudC1jb3JlLWNvbnRhaW5lciAke2NsYXNzTmFtZX1gfSBzdHlsZT17e3dpZHRoLCBoZWlnaHR9fT5cclxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNlbnRlci1jb250ZW50LWNvcmUtY29udGVudFwiPlxyXG4gICAgICAgICAgICA8ZGl2IHN0eWxlPXt7bWFyZ2luOiAnYXV0bycsIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snfX0+e2NoaWxkcmVufTwvZGl2PlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgPC9kaXY+XHJcblxyXG5leHBvcnQgZGVmYXVsdCBDZW50ZXJDb250ZW50O1xyXG4iLCJpbXBvcnQge2RlZmluZUNvbXBvbmVudFN0eWxlLCBkZWZpbmVDdXN0b21CYXNlfSBmcm9tIFwibGliLXNvdXJjZS92Mi9zdHlsZVwiO1xyXG5pbXBvcnQgQ2VudGVyQ29udGVudCBmcm9tIFwibGliLXNvdXJjZS91aXYyL0NlbnRlckNvbnRlbnRcIjtcclxuLy8gaW1wb3J0IFJpcHBsZSBmcm9tIFwibGliLXNvdXJjZS91aXYyL1JpcHBsZVwiO1xyXG5pbXBvcnQgSWNvbiBmcm9tIFwibGliLXNvdXJjZS91aXYyL0ljb25cIjtcclxuaW1wb3J0IHZhcnMgZnJvbSAnbGliLXNvdXJjZS91aXYyL3ZhcnMnO1xyXG5pbXBvcnQge3RyYW5zZmVyUHJvcHN9IGZyb20gJ2xpYi1zb3VyY2UvdjIvdXRpbHMnO1xyXG5cclxuZGVmaW5lQ29tcG9uZW50U3R5bGUoXHJcbiAgICAnY2hlY2tib3gnLFxyXG4gICAgJ2NvcmUnLFxyXG4gICAge1xyXG4gICAgICAgIFwiY29udGFpbmVyXCI6IHtcclxuICAgICAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXHJcbiAgICAgICAgICAgIHRyYW5zaXRpb246ICdiYWNrZ3JvdW5kLWNvbG9yIDUwMG1zIGxpbmVhcicsXHJcbiAgICAgICAgICAgIGZvbnRTaXplOiAyMCxcclxuICAgICAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcImNvbnRhaW5lcjphY3RpdmVcIjoge1xyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDAsIDAsIDAsIDAuMDc1KScsXHJcbiAgICAgICAgICAgIHRyYW5zaXRpb246ICdub25lJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJpY29uXCI6IHtcclxuICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXHJcbiAgICAgICAgICAgIHRvcDogMCxcclxuICAgICAgICAgICAgcmlnaHQ6IDAsXHJcbiAgICAgICAgICAgIGJvdHRvbTogMCxcclxuICAgICAgICAgICAgd2lkdGg6IDMwLFxyXG4gICAgICAgICAgICBjb2xvcjogJ2JsYWNrJyxcclxuICAgICAgICAgICAgZm9udFNpemU6IDI0LFxyXG4gICAgICAgICAgICB0cmFuc2l0aW9uOiAnY29sb3IgMjUwbXMgbGluZWFyJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJpY29uW2RhdGEtY2hlY2tlZD0ndHJ1ZSddXCI6IHtcclxuICAgICAgICAgICAgY29sb3I6ICcjMjRiMzI0J1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJsYWJlbFwiOiB7XHJcbiAgICAgICAgICAgIHBhZGRpbmc6IDMsXHJcbiAgICAgICAgICAgIHBhZGRpbmdSaWdodDogMzAsXHJcbiAgICAgICAgICAgIHdoaXRlU3BhY2U6ICdwcmUnLFxyXG4gICAgICAgICAgICBjb2xvcjogJ2JsYWNrJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJzdWJ0aXRsZVwiOiB7XHJcbiAgICAgICAgICAgIGNvbG9yOiAnZ3JheScsXHJcbiAgICAgICAgICAgIGZvbnRTaXplOiAxNFxyXG4gICAgICAgIH1cclxuICAgIH1cclxuKTtcclxuY29uc3QgaW9uT25JY29uID0gXCJpb24tYW5kcm9pZC1jaGVja2JveFwiO1xyXG5jb25zdCBpb25PZmZJY29uID0gXCJpb24tYW5kcm9pZC1jaGVja2JveC1vdXRsaW5lLWJsYW5rXCI7XHJcblxyXG5jb25zdCBDaGVja2JveCA9IHByb3BzID0+IHtcclxuICAgIGNvbnN0IHtcclxuICAgICAgICBjaGVja2VkID0gZmFsc2UsXHJcbiAgICAgICAgb25JY29uTmFtZSA9IGlvbk9uSWNvbixcclxuICAgICAgICBvZmZJY29uTmFtZSA9IGlvbk9mZkljb24sXHJcbiAgICAgICAgbGFiZWwsXHJcbiAgICAgICAgc3ViVGl0bGUgPSBudWxsLFxyXG4gICAgICAgIG9uQ2hhbmdlID0gKCkgPT4gY29uc29sZS53YXJuKFwiTm8gb25DaGFuZ2UgZ2l2ZW4gdG8gY2hlY2tib3hcIiksXHJcbiAgICAgICAgc3R5bGVOYW1lID0gXCJjb3JlXCJcclxuICAgIH0gPSBwcm9wcztcclxuICAgIGNvbnN0IGljb25OYW1lID0gKGNoZWNrZWQgPT09IHRydWUpID8gb25JY29uTmFtZSA6IG9mZkljb25OYW1lO1xyXG4gICAgY29uc3QgaWNvbkNsYXNzTmFtZSA9IGBjaGVja2JveC1jb3JlLWljb24gY2hlY2tib3gtJHtzdHlsZU5hbWV9LWljb24tY3VzdG9tYDtcclxuICAgIGNvbnN0IGxhYmVsQ2xhc3NOYW1lID0gYGNoZWNrYm94LWNvcmUtbGFiZWwgY2hlY2tib3gtJHtzdHlsZU5hbWV9LWxhYmVsLWN1c3RvbWA7XHJcbiAgICBsZXQgY29udGVudCA9IGxhYmVsO1xyXG5cclxuICAgIGlmIChzdWJUaXRsZSAhPT0gbnVsbCkge1xyXG4gICAgICAgIGNvbnN0IHN1YnRpdGxlQ2xhc3NOYW1lID0gYGNoZWNrYm94LWNvcmUtc3VidGl0bGUgY2hlY2tib3gtJHtzdHlsZU5hbWV9LXN1YnRpdGxlLWN1c3RvbWA7XHJcbiAgICAgICAgY29udGVudCA9IChcclxuICAgICAgICAgICAgPGRpdj5cclxuICAgICAgICAgICAgICAgIHtsYWJlbH1cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdWJ0aXRsZUNsYXNzTmFtZX0+e3N1YlRpdGxlfTwvZGl2PlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPFVJLlRvdWNoYWJsZSBjb21wb25lbnQ9XCJkaXZcIiBjbGFzc05hbWU9XCJjaGVja2JveC1jb3JlLWNvbnRhaW5lclwiIG9uVGFwPXsoKSA9PiBvbkNoYW5nZSghY2hlY2tlZCl9PlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17aWNvbkNsYXNzTmFtZX0gZGF0YS1jaGVja2VkPXtjaGVja2VkfT5cclxuICAgICAgICAgICAgICAgIDxDZW50ZXJDb250ZW50IGhlaWdodD1cIjEwMCVcIj5cclxuICAgICAgICAgICAgICAgICAgICA8SWNvbiBuYW1lPXtpY29uTmFtZX0gLz5cclxuICAgICAgICAgICAgICAgIDwvQ2VudGVyQ29udGVudD5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtsYWJlbENsYXNzTmFtZX0+e2NvbnRlbnR9PC9kaXY+XHJcbiAgICAgICAgICAgIHsvKjxSaXBwbGUgLz4qL31cclxuICAgICAgICA8L1VJLlRvdWNoYWJsZT5cclxuICAgICk7XHJcbn07XHJcbkNoZWNrYm94LmNvbXBvbmVudE5hbWUgPSBcImNoZWNrYm94XCI7XHJcblxyXG5DaGVja2JveC52YWx1ZVByb3AgPSBcImNoZWNrZWRcIjtcclxuQ2hlY2tib3gudmFsdWVGdW5jdGlvbiA9IGNoZWNrZWQgPT4gY2hlY2tlZDtcclxuQ2hlY2tib3guZGVmYXVsdFByb3BWYWx1ZSA9IGZhbHNlO1xyXG5cclxuZGVmaW5lQ3VzdG9tQmFzZShcclxuICAgIENoZWNrYm94LFxyXG4gICAgKHtub3JtYWwgPSBudWxsLCBjaGVja2VkID0gbnVsbCwgbGFiZWwgPSBudWxsLCBzdWJ0aXRsZSA9IG51bGx9KSA9PiB0cmFuc2ZlclByb3BzKHtcclxuICAgICAgICBcIi5jaGVja2JveC1jb3JlLWljb24vaWNvbi1jdXN0b21cIjogW1xyXG4gICAgICAgICAgICBub3JtYWwsXHJcbiAgICAgICAgICAgIHtpY29uQ29sb3I6ICdjb2xvcid9XHJcbiAgICAgICAgXSxcclxuICAgICAgICBcIi5jaGVja2JveC1jb3JlLWljb24vaWNvbi1jdXN0b21bZGF0YS1jaGVja2VkPSd0cnVlJ11cIjogW1xyXG4gICAgICAgICAgICBjaGVja2VkLFxyXG4gICAgICAgICAgICB7aWNvbkNvbG9yOiAnY29sb3InfVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgXCIuY2hlY2tib3gtY29yZS1sYWJlbC9sYWJlbC1jdXN0b21cIjogW1xyXG4gICAgICAgICAgICBsYWJlbCxcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGV4dENvbG9yOiAnY29sb3InLFxyXG4gICAgICAgICAgICAgICAgY29sb3I6ICdiYWNrZ3JvdW5kQ29sb3InXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICBdLFxyXG4gICAgICAgIFwiLmNoZWNrYm94LWNvcmUtc3VidGl0bGUvc3VidGl0bGUtY3VzdG9tXCI6IFtcclxuICAgICAgICAgICAgc3VidGl0bGUsXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRleHRDb2xvcjogJ2NvbG9yJyxcclxuICAgICAgICAgICAgICAgIGNvbG9yOiAnYmFja2dyb3VuZENvbG9yJ1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgXVxyXG4gICAgfSlcclxuKTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IENoZWNrYm94O1xyXG4iLCJpbXBvcnQge2RlZmluZUNvbXBvbmVudFN0eWxlfSBmcm9tIFwibGliLXNvdXJjZS92Mi9zdHlsZVwiO1xyXG5pbXBvcnQgQnV0dG9uIGZyb20gXCJsaWItc291cmNlL3VpdjIvQnV0dG9uXCI7XHJcbmltcG9ydCBJY29uIGZyb20gXCJsaWItc291cmNlL3VpdjIvSWNvblwiO1xyXG5pbXBvcnQgT3B0aW9uIGZyb20gXCJsaWItc291cmNlL3VpdjIvT3B0aW9uXCI7XHJcbmltcG9ydCBUb3VjaGFibGUgZnJvbSBcImxpYi1zb3VyY2UvdWl2Mi9Ub3VjaGFibGVcIjtcclxuXHJcbmRlZmluZUNvbXBvbmVudFN0eWxlKFxyXG4gICAgJ2NvbWJvYm94JyxcclxuICAgICdjb3JlJyxcclxuICAgIHtcclxuICAgICAgICAnY29udGFpbmVyJzoge1xyXG4gICAgICAgICAgICBib3JkZXI6ICcxcHggc29saWQgbGlnaHRncmF5JyxcclxuICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAzLFxyXG4gICAgICAgICAgICAvLyBwYWRkaW5nOiAzLFxyXG4gICAgICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcclxuICAgICAgICAgICAgY29sb3I6ICdibGFjaycsXHJcbiAgICAgICAgICAgIGhlaWdodDogMzBcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiaWNvblwiOiB7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxyXG4gICAgICAgICAgICB0b3A6ICc1MCUnLFxyXG4gICAgICAgICAgICByaWdodDogMTAsXHJcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVkoLTUwJSknLFxyXG4gICAgICAgICAgICBwb2ludGVyRXZlbnRzOiAnbm9uZSdcclxuICAgICAgICB9XHJcbiAgICB9XHJcbik7XHJcblxyXG4vLyBjb25zdCBjb21ib2JveFNlbGVjdCA9IChpbmRleCwgdmFsdWUpID0+IGRpYWxvZy5zdWNjZXNzKFtpbmRleCwgdmFsdWVdKTtcclxuY2xhc3MgQ29tYm9ib3ggZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xyXG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcclxuICAgICAgICBzdXBlcihwcm9wcyk7XHJcbiAgICB9XHJcblxyXG4gICAgb3Blbk9wdGlvbnMgPSBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgY29uc3Qge3RpdGxlID0gXCJDb21ib2JveCFcIiwgc2Nyb2xsVG9TZWxlY3RlZCA9IGZhbHNlLCBzZWxlY3RlZEluZGV4fSA9IHRoaXMucHJvcHM7XHJcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBSZWFjdC5DaGlsZHJlbi50b0FycmF5KHRoaXMucHJvcHMuY2hpbGRyZW4pO1xyXG5cclxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGRpYWxvZy5zaG93KHtcclxuICAgICAgICAgICAgdGl0bGUsXHJcbiAgICAgICAgICAgIGNvbnRlbnQ6IGNoaWxkcmVuLm1hcChcclxuICAgICAgICAgICAgICAgICh7cHJvcHM6IHt2YWx1ZSA9IG51bGwsIGNoaWxkcmVuLCBzdHlsZSA9IG51bGwsIGNsYXNzTmFtZSA9IG51bGx9fSwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBvblRhcCA9ICgpID0+IGRpYWxvZy5oaWRlKGRpYWxvZy5zdWNjZXNzKFtpbmRleCwgdmFsdWVdKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiB7Li4ue3N0eWxlLCBjbGFzc05hbWV9fSBrZXk9e2luZGV4fT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxCdXR0b24gdGV4dD17Y2hpbGRyZW59IGJsb2NrIGZsdXNoIG9uVGFwPXtvblRhcH0gLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgKSxcclxuICAgICAgICAgICAgYnV0dG9uczogW1xyXG4gICAgICAgICAgICAgICAge3RleHQ6IFwiQ2FuY2VsXCIsIGNhbmNlbHM6IHRydWV9XHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIHNldHVwKGNvbnRhaW5lcikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNjcm9sbFRvU2VsZWN0ZWQgPT09IHRydWUgJiYgc2VsZWN0ZWRJbmRleCAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250YWluZXIuc2Nyb2xsVG9wID0gY29udGFpbmVyLmNoaWxkcmVuW3NlbGVjdGVkSW5kZXhdLm9mZnNldFRvcCAtIGNvbnRhaW5lci5vZmZzZXRUb3A7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gXCJzdWNjZXNzXCIpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZSguLi5yZXNwb25zZS52YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJlbmRlciA9ICgpID0+IHtcclxuICAgICAgICBjb25zdCB7c2VsZWN0ZWRJbmRleCwgY2hpbGRyZW4sIGhlaWdodCwgLi4uYnV0dG9uUHJvcHN9ID0gdGhpcy5wcm9wcztcclxuICAgICAgICBjb25zdCBmbGF0dGVuZWRDaGlsZHJlbiA9IFJlYWN0LkNoaWxkcmVuLnRvQXJyYXkoY2hpbGRyZW4pO1xyXG4gICAgICAgIGxldCBjdXJyZW50Q2hpbGQgPSBcIlBsZWFzZSBzZWxlY3QgYW4gb3B0aW9uXCI7XHJcblxyXG4gICAgICAgIGlmIChzZWxlY3RlZEluZGV4ICE9PSAtMSkge1xyXG4gICAgICAgICAgICBjdXJyZW50Q2hpbGQgPSBmbGF0dGVuZWRDaGlsZHJlbltzZWxlY3RlZEluZGV4XS5wcm9wcy5jaGlsZHJlbjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29tYm9ib3gtY29yZS1jb250YWluZXJcIiBzdHlsZT17e2hlaWdodH19PlxyXG4gICAgICAgICAgICAgICAgPEJ1dHRvbiB7Li4uYnV0dG9uUHJvcHN9IHRleHQ9e2N1cnJlbnRDaGlsZH0gYmxvY2sgZmx1c2ggZmlsbCBvblRhcD17dGhpcy5vcGVuT3B0aW9uc30gLz5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29tYm9ib3gtY29yZS1pY29uXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPEljb24gbmFtZT1cImlvbi1hcnJvdy1kb3duLWJcIiBzaXplPXsyNH0gLz5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICApO1xyXG4gICAgfVxyXG59XHJcblxyXG5Db21ib2JveC52YWx1ZVByb3AgPSBcInNlbGVjdGVkSW5kZXhcIjtcclxuQ29tYm9ib3gudmFsdWVGdW5jdGlvbiA9IChpbmRleCwgdmFsdWUpID0+ICh7aW5kZXgsIHZhbHVlfSk7XHJcbkNvbWJvYm94LmRlZmF1bHRQcm9wVmFsdWUgPSAwO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgQ29tYm9ib3g7XHJcbiIsImltcG9ydCBCdXR0b24gZnJvbSBcImxpYi1zb3VyY2UvdWl2Mi9CdXR0b25cIjtcclxuXHJcbmNsYXNzIEl0ZW1Db250YWluZXIgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xyXG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcclxuICAgICAgICBzdXBlcihwcm9wcyk7XHJcblxyXG4gICAgICAgIHRoaXMuc3RhdGUgPSB7dmFsdWU6IHByb3BzLmNoaWxkSW5mby5pbml0aWFsVmFsdWV9O1xyXG4gICAgfVxyXG5cclxuICAgIGNoYW5nZSA9ICguLi5hcmdzKSA9PiB7XHJcbiAgICAgICAgY29uc3Qge3VwZGF0ZUZvcm0sIGNoaWxkSW5mbzoge3ZhbHVlRnVuY3Rpb24sIG5hbWV9fSA9IHRoaXMucHJvcHM7XHJcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7dmFsdWU6IGFyZ3NbMF19KTtcclxuICAgICAgICB1cGRhdGVGb3JtKG5hbWUsIHZhbHVlRnVuY3Rpb24oLi4uYXJncykpO1xyXG4gICAgfVxyXG5cclxuICAgIHJlbmRlciA9ICgpID0+IHtcclxuICAgICAgICBjb25zdCB7UmVuZGVyZXIsIHZhbHVlUHJvcCwgY2hpbGRyZW4sIHByb3BzfSA9IHRoaXMucHJvcHMuY2hpbGRJbmZvO1xyXG4gICAgICAgIGNvbnN0IHt2YWx1ZX0gPSB0aGlzLnN0YXRlO1xyXG4gICAgICAgIGNvbnN0IHZhbHVlT2JqID0ge1xyXG4gICAgICAgICAgICBbdmFsdWVQcm9wXTogdmFsdWVcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgICAgICAgPFJlbmRlcmVyIHsuLi5wcm9wc30gb25DaGFuZ2U9e3RoaXMuY2hhbmdlfSB7Li4udmFsdWVPYmp9PlxyXG4gICAgICAgICAgICAgICAge2NoaWxkcmVufVxyXG4gICAgICAgICAgICAgICAgPC9SZW5kZXJlcj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgKTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBGb3JtIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XHJcbiAgICAgICAgc3VwZXIocHJvcHMpO1xyXG5cclxuICAgICAgICBjb25zdCB7aXRlbUNvbnRhaW5lciA9ICdkaXYnLCBsYXlvdXQgPSBudWxsfSA9IHByb3BzO1xyXG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gUmVhY3QuQ2hpbGRyZW4udG9BcnJheShwcm9wcy5jaGlsZHJlbik7XHJcbiAgICAgICAgbGV0IEVsZW1Db250YWluZXI7XHJcblxyXG4gICAgICAgIHRoaXMuaW50ZXJuYWxTdGF0ZSA9IHt9O1xyXG5cclxuICAgICAgICBpZiAobGF5b3V0ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuQ29udGFpbmVyID0gJ2Rpdic7XHJcbiAgICAgICAgICAgIEVsZW1Db250YWluZXIgPSBpdGVtQ29udGFpbmVyO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuQ29udGFpbmVyID0gbGF5b3V0O1xyXG4gICAgICAgICAgICBFbGVtQ29udGFpbmVyID0gbGF5b3V0LkZvcm1Db250YWluZXIgfHwgKCh7Y2hpbGRyZW59KSA9PiBjaGlsZHJlbik7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyUHJvcHMgPSBPYmplY3QuZW50cmllcyhwcm9wcykucmVkdWNlKFxyXG4gICAgICAgICAgICAgICAgKHByb3BzLCBba2V5LCB2YWx1ZV0pID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5LnN0YXJ0c1dpdGgoJ2xheW91dC0nKSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wc1trZXkuc3Vic3RyKDcpXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvcHM7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAge31cclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuY2hpbGRMaXN0ID0gY2hpbGRyZW4ubWFwKFxyXG4gICAgICAgICAgICAoY2hpbGQsIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlbGVtVHlwZSA9IChjaGlsZC50eXBlLnBhcmVudEluZm8gIT09IHVuZGVmaW5lZCkgPyBjaGlsZC50eXBlLnBhcmVudEluZm8gOiBjaGlsZC50eXBlO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaW5pdFZhbHVlID0gY2hpbGQucHJvcHMuZGVmYXVsdFByb3BWYWx1ZSB8fCBlbGVtVHlwZS5kZWZhdWx0UHJvcFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qge2Zvcm1OYW1lID0gaW5kZXgsIGNoaWRyZW4sIC4uLmNoaWxkUHJvcHN9ID0gY2hpbGQucHJvcHM7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZEluZm8gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgUmVuZGVyZXI6IGNoaWxkLnR5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcHM6IGNoaWxkUHJvcHMsXHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IGNoaWxkLnByb3BzLmNoaWxkcmVuLFxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlUHJvcDogZWxlbVR5cGUudmFsdWVQcm9wLFxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlRnVuY3Rpb246IGVsZW1UeXBlLnZhbHVlRnVuY3Rpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgaW5pdGlhbFZhbHVlOiB0eXBlb2YgaW5pdFZhbHVlID09PSAnZnVuY3Rpb24nID8gaW5pdFZhbHVlKCkgOiBpbml0VmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogZm9ybU5hbWVcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb250YWluZXJQcm9wcyA9IE9iamVjdC5lbnRyaWVzKGNoaWxkUHJvcHMpLnJlZHVjZShcclxuICAgICAgICAgICAgICAgICAgICAocHJvcHMsIFtrZXksIHZhbHVlXSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5LnN0YXJ0c1dpdGgoJ2xheW91dC0nKSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHNba2V5LnN1YnN0cig3KV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvcHM7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICB7fVxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGNoaWxkLCBjaGlsZC50eXBlLCBjaGlsZC50eXBlID09PSBDaGVja2JveCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmludGVybmFsU3RhdGVbY2hpbGRJbmZvLm5hbWVdID0gY2hpbGRJbmZvLnZhbHVlRnVuY3Rpb24oY2hpbGRJbmZvLmluaXRpYWxWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICAgICAgICAgIDxFbGVtQ29udGFpbmVyIHsuLi5jb250YWluZXJQcm9wc30ga2V5PXtpbmRleH0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxJdGVtQ29udGFpbmVyIGNoaWxkSW5mbz17Y2hpbGRJbmZvfSB1cGRhdGVGb3JtPXt0aGlzLnVwZGF0ZUludGVybmFsU3RhdGV9IC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9FbGVtQ29udGFpbmVyPlxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlSW50ZXJuYWxTdGF0ZSA9IChuYW1lLCB2YWx1ZSkgPT4ge1xyXG4gICAgICAgIHRoaXMuaW50ZXJuYWxTdGF0ZVtuYW1lXSA9IHZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIHN1Ym1pdCA9IGV2dCA9PiB7XHJcbiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xyXG5cclxuICAgICAgICBjb25zdCB7b25TdWJtaXQgPSBzdGF0ZSA9PiBjb25zb2xlLmxvZyhzdGF0ZSl9ID0gdGhpcy5wcm9wcztcclxuICAgICAgICBvblN1Ym1pdCh0aGlzLmludGVybmFsU3RhdGUpO1xyXG4gICAgfVxyXG5cclxuICAgIHJlbmRlciA9ICgpID0+IHtcclxuICAgICAgICBjb25zdCB7Q29udGFpbmVyLCBjaGlsZExpc3QsIGNvbnRhaW5lclByb3BzfSA9IHRoaXM7XHJcbiAgICAgICAgY29uc3Qge3N1Ym1pdFRleHQgPSBcIlN1Ym1pdFwifSA9IHRoaXMucHJvcHM7XHJcblxyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIDxmb3JtIG9uU3VibWl0PXt0aGlzLnN1Ym1pdH0gcmVmPVwiZm9ybVwiPlxyXG4gICAgICAgICAgICAgICAgPENvbnRhaW5lciB7Li4uY29udGFpbmVyUHJvcHN9PlxyXG4gICAgICAgICAgICAgICAgICAgIHtjaGlsZExpc3R9XHJcbiAgICAgICAgICAgICAgICA8L0NvbnRhaW5lcj5cclxuICAgICAgICAgICAgICAgIDxCdXR0b24gdGV4dD17c3VibWl0VGV4dH0gb25UYXA9e3RoaXMuc3VibWl0fSBibG9jayAvPlxyXG4gICAgICAgICAgICA8L2Zvcm0+XHJcbiAgICAgICAgKTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgRm9ybTtcclxuIiwiaW1wb3J0IHtkZWZpbmVDb21wb25lbnRTdHlsZX0gZnJvbSBcImxpYi1zb3VyY2UvdjIvc3R5bGUuanNcIjtcclxuXHJcbmRlZmluZUNvbXBvbmVudFN0eWxlKFxyXG4gICAgJ2ljb24nLFxyXG4gICAgJ2NvcmUnLFxyXG4gICAge1xyXG4gICAgICAgIFwiY29udGVudFwiOiB7XHJcbiAgICAgICAgICAgIGZvbnRGYW1pbHk6IFwiSW9uaWNcIixcclxuICAgICAgICAgICAgbWFyZ2luTGVmdDogMixcclxuICAgICAgICAgICAgbWFyZ2luUmlnaHQ6IDJcclxuICAgICAgICB9XHJcbiAgICB9XHJcbik7XHJcbmNvbnN0IEljb24gPSAoe25hbWUsIHN0eWxlTmFtZSA9ICdjb3JlJywgc2l6ZX0pID0+XHJcbiAgICA8c3BhbiBjbGFzc05hbWU9e2BpY29uLSR7c3R5bGVOYW1lfS1jb250ZW50YH0gc3R5bGU9e3tmb250U2l6ZTogc2l6ZX19Pntpb25pY1tuYW1lXX08L3NwYW4+O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgSWNvbjtcclxuIiwiY29uc3QgSW1hZ2UgPSAoe3NvdXJjZSwgd2lkdGggPSAnMTAwJScsIGhlaWdodCA9IG51bGwsIGltYWdlU2l6ZSA9ICdmaXQnLCBjb2xvciwgYmxvY2sgPSBmYWxzZX0pID0+IHtcclxuICAgIGlmIChoZWlnaHQgPT09IG51bGwpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOZWVkIHRvIGdpdmUgaW1hZ2UgaGVpZ2h0XCIpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHN0eWxlID0ge1xyXG4gICAgICAgIGRpc3BsYXk6IGJsb2NrID09PSB0cnVlID8gXCJibG9ja1wiIDogXCJpbmxpbmUtYmxvY2tcIixcclxuICAgICAgICBiYWNrZ3JvdW5kUmVwZWF0OiAnbm8tcmVwZWF0JyxcclxuICAgICAgICBiYWNrZ3JvdW5kUG9zaXRpb246ICdjZW50ZXIgY2VudGVyJyxcclxuICAgICAgICBiYWNrZ3JvdW5kSW1hZ2U6IGB1cmwoXCIke3NvdXJjZX1cIilgLFxyXG4gICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxyXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogY29sb3IsXHJcbiAgICAgICAgd2lkdGgsXHJcbiAgICAgICAgaGVpZ2h0XHJcbiAgICB9O1xyXG5cclxuICAgIHN3aXRjaCAoaW1hZ2VTaXplKSB7XHJcbiAgICAgICAgY2FzZSAnZml0JzpcclxuICAgICAgICAgICAgc3R5bGUuYmFja2dyb3VuZFNpemUgPSAnY29udGFpbic7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICBjYXNlICdjbGlwJzpcclxuICAgICAgICAgICAgc3R5bGUuYmFja2dyb3VuZFNpemUgPSAnY292ZXInO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgc3R5bGUuYmFja2dyb3VuZFNpemUgPSBpbWFnZVNpemU7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIDxkaXYgc3R5bGU9e3N0eWxlfSAvPjtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IEltYWdlO1xyXG4iLCJpbXBvcnQge2RlZmluZUNvbXBvbmVudFN0eWxlfSBmcm9tIFwibGliLXNvdXJjZS92Mi9zdHlsZVwiO1xyXG5pbXBvcnQgUmFuZ2VJbnB1dCBmcm9tICdsaWItc291cmNlL3VpdjIvaW5wdXQvUmFuZ2VJbnB1dCc7XHJcbmltcG9ydCBEYXRlSW5wdXQgZnJvbSAnbGliLXNvdXJjZS91aXYyL2lucHV0L0RhdGVJbnB1dCc7XHJcbmltcG9ydCBUaW1lSW5wdXQgZnJvbSAnbGliLXNvdXJjZS91aXYyL2lucHV0L1RpbWVJbnB1dCc7XHJcbmltcG9ydCBGaWxlSW5wdXQgZnJvbSAnbGliLXNvdXJjZS91aXYyL2lucHV0L0ZpbGVJbnB1dCc7XHJcbmltcG9ydCBDZW50ZXJDb250ZW50IGZyb20gJ2xpYi1zb3VyY2UvdWl2Mi9DZW50ZXJDb250ZW50JztcclxuaW1wb3J0IEljb24gZnJvbSAnbGliLXNvdXJjZS91aXYyL0ljb24nO1xyXG5pbXBvcnQgVG91Y2hhYmxlIGZyb20gJ2xpYi1zb3VyY2UvdWl2Mi9Ub3VjaGFibGUnO1xyXG5cclxuY29uc3QgY29vbEJsdWUgPSBcIiMyRkIxREZcIjtcclxuXHJcbmRlZmluZUNvbXBvbmVudFN0eWxlKFxyXG4gICAgJ2lucHV0JyxcclxuICAgICdjb3JlJyxcclxuICAgIHtcclxuICAgICAgICBcIiRib2R5XCI6IHtcclxuICAgICAgICAgICAgV2Via2l0VGFwSGlnaGxpZ2h0Q29sb3I6ICdyZ2JhKDAsIDAsIDAsIDApJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJ3cmFwcGVyXCI6IHtcclxuICAgICAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXHJcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3doaXRlJyxcclxuICAgICAgICAgICAgaGVpZ2h0OiAzMixcclxuICAgICAgICAgICAgbWFyZ2luOiAzXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcImZpZWxkXCI6IHtcclxuICAgICAgICAgICAgd2lkdGg6ICcxMDAlJyxcclxuICAgICAgICAgICAgYm9yZGVyV2lkdGg6IDAsXHJcbiAgICAgICAgICAgIGJvcmRlckJvdHRvbTogJzJweCBzb2xpZCBsaWdodGdyYXknLFxyXG4gICAgICAgICAgICBXZWJraXRCb3JkZXJSYWRpdXM6IDAsXHJcbiAgICAgICAgICAgIFdlYmtpdEFwcGVhcmFuY2U6ICdub25lJyxcclxuICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAwLFxyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICd0cmFuc3BhcmVudCcsXHJcbiAgICAgICAgICAgIG1hcmdpbjogMCxcclxuICAgICAgICAgICAgaGVpZ2h0OiAnMTAwJScsXHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxyXG4gICAgICAgICAgICB6SW5kZXg6ICcrMSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiZmllbGQ6Zm9jdXNcIjoge1xyXG4gICAgICAgICAgICBvdXRsaW5lOiAnbm9uZSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiaWNvblwiOiB7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxyXG4gICAgICAgICAgICB0b3A6IDAsXHJcbiAgICAgICAgICAgIGxlZnQ6IDAsXHJcbiAgICAgICAgICAgIGJvdHRvbTogMCxcclxuICAgICAgICAgICAgd2lkdGg6IDMwXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcImhpZ2hsaWdodC1ib3JkZXJcIjoge1xyXG4gICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcclxuICAgICAgICAgICAgYm90dG9tOiAwLFxyXG4gICAgICAgICAgICBib3JkZXJCb3R0b206IGAycHggc29saWQgJHtjb29sQmx1ZX1gLFxyXG4gICAgICAgICAgICBsZWZ0OiAnNTAlJyxcclxuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlWCgtNTAlKSBzY2FsZVgoMCknLFxyXG4gICAgICAgICAgICB3aWR0aDogJzEwMCUnLFxyXG4gICAgICAgICAgICB6SW5kZXg6ICcrMidcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiZmllbGQ6Zm9jdXMgKyBoaWdobGlnaHQtYm9yZGVyXCI6IHtcclxuICAgICAgICAgICAgLy8gd2lkdGg6ICcxMDAlJyxcclxuICAgICAgICAgICAgV2Via2l0VHJhbnNpdGlvbjogJy13ZWJraXQtdHJhbnNmb3JtIDI1MG1zIGxpbmVhcicsXHJcbiAgICAgICAgICAgIHRyYW5zaXRpb246ICd0cmFuc2Zvcm0gMTUwbXMgbGluZWFyJyxcclxuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlWCgtNTAlKSBzY2FsZVgoMSknXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcImxhYmVsXCI6IHtcclxuICAgICAgICAgICAgY29sb3I6IFwiYmxhY2tcIixcclxuICAgICAgICAgICAgZm9udFNpemU6IDE2LFxyXG4gICAgICAgICAgICBwYWRkaW5nOiAzXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4pO1xyXG5jbGFzcyBJbnB1dFdyYXBwZXIgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xyXG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcclxuICAgICAgICBzdXBlcihwcm9wcyk7XHJcbiAgICB9XHJcblxyXG4gICAgZm9jdXMgPSAoKSA9PiB7XHJcbiAgICAgICAgdGhpcy5yZWZzLmZpZWxkLmZvY3VzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmVuZGVyID0gKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHtwYXJzZXIgPSBpID0+IGksIG9uQ2hhbmdlID0gKCkgPT4ge30sIGljb25OYW1lID0gbnVsbCwgc3R5bGUgPSB7fSwgYm9yZGVyUmFkaXVzID0gbnVsbCwgLi4ucHJvcHN9ID0gdGhpcy5wcm9wcztcclxuICAgICAgICBjb25zdCBoYW5kbGVyID0gZXZ0ID0+IHtcclxuICAgICAgICAgICAgLy8gY29uc3QgcmF3ID0gZXZ0LnRhcmdldC52YWx1ZTtcclxuICAgICAgICAgICAgb25DaGFuZ2UocGFyc2VyKGV2dC50YXJnZXQudmFsdWUpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGxldCByZWFsU3R5bGUgPSB7Li4uc3R5bGV9O1xyXG4gICAgICAgIGxldCBib3JkZXJTdHlsZSA9IHt9O1xyXG4gICAgICAgIGxldCBpY29uRGlzcGxheSA9IG51bGw7XHJcblxyXG4gICAgICAgIGlmIChpY29uTmFtZSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBpY29uRGlzcGxheSA9IDxDZW50ZXJDb250ZW50IGNsYXNzTmFtZT1cImlucHV0LWNvcmUtaWNvblwiIGhlaWdodD1cIjEwMCVcIj48SWNvbiBuYW1lPXtpY29uTmFtZX0gc2l6ZT17MTh9IC8+PC9DZW50ZXJDb250ZW50PjtcclxuICAgICAgICAgICAgcmVhbFN0eWxlLnBhZGRpbmdMZWZ0ID0gMzA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChib3JkZXJSYWRpdXMgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmVhbFN0eWxlLmJvcmRlclJhZGl1cyA9IGJvcmRlclJhZGl1cztcclxuICAgICAgICAgICAgYm9yZGVyU3R5bGUuYm9yZGVyUmFkaXVzID0gYm9yZGVyUmFkaXVzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJpbnB1dC1jb3JlLXdyYXBwZXJcIj5cclxuICAgICAgICAgICAgICAgIDxpbnB1dCB7Li4ucHJvcHN9IHN0eWxlPXtyZWFsU3R5bGV9IG9uQ2hhbmdlPXtoYW5kbGVyfSBjbGFzc05hbWU9XCJpbnB1dC1jb3JlLWZpZWxkXCIgcmVmPVwiZmllbGRcIiAvPlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJpbnB1dC1jb3JlLWhpZ2hsaWdodC1ib3JkZXJcIiBzdHlsZT17Ym9yZGVyU3R5bGV9IC8+XHJcbiAgICAgICAgICAgICAgICB7aWNvbkRpc3BsYXl9XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgTGFiZWxlZElucHV0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XHJcbiAgICAgICAgc3VwZXIocHJvcHMpO1xyXG4gICAgfVxyXG5cclxuICAgIGZvY3VzID0gKCkgPT4ge1xyXG4gICAgICAgIHRoaXMucmVmcy53cmFwcGVkLmZvY3VzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmVuZGVyID0gKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHtsYWJlbCwgV3JhcHBlciA9IElucHV0V3JhcHBlciwgLi4ucHJvcHN9ID0gdGhpcy5wcm9wcztcclxuXHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPGRpdiBzdHlsZT17e3Bvc2l0aW9uOiAncmVsYXRpdmUnfX0+XHJcbiAgICAgICAgICAgICAgICA8VG91Y2hhYmxlIGNvbXBvbmVudD1cImRpdlwiIGNsYXNzTmFtZT1cImlucHV0LWNvcmUtbGFiZWxcIiBvblRhcD17KCkgPT4gdGhpcy5yZWZzLndyYXBwZWQuZm9jdXMoKX0+e2xhYmVsfTwvVG91Y2hhYmxlPlxyXG4gICAgICAgICAgICAgICAgPFdyYXBwZXIgcmVmPVwid3JhcHBlZFwiIHsuLi5wcm9wc30gLz5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgKTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBWYWxpZGF0ZWRJbnB1dCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xyXG4gICAgICAgIHN1cGVyKHByb3BzKTtcclxuICAgIH1cclxuXHJcbiAgICBmb2N1cyA9ICgpID0+IHtcclxuICAgICAgICB0aGlzLnJlZnMuaW5wdXQuZm9jdXMoKTtcclxuICAgIH1cclxuXHJcbiAgICByZW5kZXIgPSAoKSA9PiB7XHJcbiAgICAgICAgY29uc3Qge3ZhbGlkYXRvciwgb25DaGFuZ2UgPSAoKSA9PiB7fSwgLi4ucHJvcHN9ID0gdGhpcy5wcm9wcztcclxuICAgICAgICBjb25zdCBjaGFuZ2VIYW5kbGVyID0gdmFsdWUgPT4gb25DaGFuZ2UodmFsdWUsIHZhbGlkYXRvcih2YWx1ZSkpO1xyXG4gICAgICAgIHJldHVybiA8TGFiZWxlZElucHV0IHsuLi5wcm9wc30gb25DaGFuZ2U9e2NoYW5nZUhhbmRsZXJ9IC8+O1xyXG4gICAgfVxyXG59XHJcblxyXG5jb25zdCBJbnB1dCA9IHtcclxuICAgIFRleHQ6IHByb3BzID0+IDxMYWJlbGVkSW5wdXQgey4uLnByb3BzfSB0eXBlPVwidGV4dFwiIC8+LFxyXG4gICAgUGFzc3dvcmQ6IHByb3BzID0+IDxMYWJlbGVkSW5wdXQgey4uLnByb3BzfSB0eXBlPVwicGFzc3dvcmRcIiAvPixcclxuICAgIFNlYXJjaDogcHJvcHMgPT4gPExhYmVsZWRJbnB1dCB7Li4ucHJvcHN9IHR5cGU9XCJzZWFyY2hcIiBpY29uTmFtZT1cImlvbi1zZWFyY2hcIiAvPixcclxuICAgIERhdGU6IERhdGVJbnB1dCxcclxuICAgIFJhbmdlOiBSYW5nZUlucHV0LFxyXG4gICAgVGltZTogVGltZUlucHV0LFxyXG4gICAgRmlsZTogRmlsZUlucHV0LFxyXG4gICAgLy8gRGF0ZTogcHJvcHMgPT4gPERhdGVJbnB1dCB7Li4ucHJvcHN9IC8+LFxyXG4gICAgLy8gUmFuZ2U6IHByb3BzID0+IDxSYW5nZUlucHV0IHsuLi5wcm9wc30gLz4sXHJcbiAgICAvLyBUaW1lOiBwcm9wcyA9PiA8VGltZUlucHV0IHsuLi5wcm9wc30gLz4sXHJcbiAgICAvLyBGaWxlOiBwcm9wcyA9PiA8RmlsZUlucHV0IHsuLi5wcm9wc30gLz4sXHJcbiAgICBVUkw6ICh7dmFsaWRhdG9yID0gdXJsID0+IC9eKGh0dHBzPzpcXC9cXC8pPyhcXHcrKFxcLlxcdyspK3xsb2NhbGhvc3QpKFxcL1tcXHdcXCNcXC1cXCVdKykqXFwvPyQvLnRlc3QodXJsKSwgLi4ucHJvcHN9KSA9PiA8VmFsaWRhdGVkSW5wdXQgdmFsaWRhdG9yPXt2YWxpZGF0b3J9IHsuLi5wcm9wc30gdHlwZT1cInVybFwiIC8+LFxyXG4gICAgRW1haWw6ICh7dmFsaWRhdG9yID0gZW1haWwgPT4gL14oW2EtekEtWl1cXHcqKShcXC4oW2EtekEtWl1cXHcqKSkqXFxAKFthLXpBLVpdXFx3KikoXFwuKFthLXpBLVpdXFx3KikpKyQvLnRlc3QoZW1haWwpLCAuLi5wcm9wc30pID0+IDxWYWxpZGF0ZWRJbnB1dCB2YWxpZGF0b3I9e3ZhbGlkYXRvcn0gey4uLnByb3BzfSB0eXBlPVwiZW1haWxcIiAvPlxyXG59O1xyXG5cclxuSW5wdXQuVGV4dC52YWx1ZVByb3AgPSAndmFsdWUnO1xyXG5JbnB1dC5UZXh0LnZhbHVlRnVuY3Rpb24gPSB0ZXh0ID0+IHRleHQ7XHJcbklucHV0LlRleHQuZGVmYXVsdFByb3BWYWx1ZSA9IFwiXCI7XHJcblxyXG5JbnB1dC5QYXNzd29yZC52YWx1ZVByb3AgPSAndmFsdWUnO1xyXG5JbnB1dC5QYXNzd29yZC52YWx1ZUZ1bmN0aW9uID0gdGV4dCA9PiB0ZXh0O1xyXG5JbnB1dC5QYXNzd29yZC5kZWZhdWx0UHJvcFZhbHVlID0gXCJcIjtcclxuXHJcbklucHV0LlNlYXJjaC52YWx1ZVByb3AgPSAndmFsdWUnO1xyXG5JbnB1dC5TZWFyY2gudmFsdWVGdW5jdGlvbiA9IHRleHQgPT4gdGV4dDtcclxuSW5wdXQuU2VhcmNoLmRlZmF1bHRQcm9wVmFsdWUgPSBcIlwiO1xyXG5cclxuSW5wdXQuVVJMLnZhbHVlUHJvcCA9ICd2YWx1ZSc7XHJcbklucHV0LlVSTC52YWx1ZUZ1bmN0aW9uID0gKHRleHQsIHZhbGlkKSA9PiAoe3RleHQsIHZhbGlkfSk7XHJcbklucHV0LlVSTC5kZWZhdWx0UHJvcFZhbHVlID0gXCJcIjtcclxuXHJcbklucHV0LkVtYWlsLnZhbHVlUHJvcCA9ICd2YWx1ZSc7XHJcbklucHV0LkVtYWlsLnZhbHVlRnVuY3Rpb24gPSAodGV4dCwgdmFsaWQpID0+ICh7dGV4dCwgdmFsaWR9KTtcclxuSW5wdXQuRW1haWwuZGVmYXVsdFByb3BWYWx1ZSA9IFwiXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBJbnB1dDtcclxuIiwiY29uc3QgT3B0aW9uID0gKCkgPT4ge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiT3B0aW9uIGlzIGludGVuZGVkIGFzIGEgZmlsbGVyIGVsZW1lbnQgYW5kIHNob3VsZCBub3QgYmUgcmVuZGVyZWQgb24gaXRzIG93blwiKTtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IE9wdGlvbjtcclxuIiwiaW1wb3J0IHtkZWZpbmVDb21wb25lbnRTdHlsZX0gZnJvbSBcImxpYi1zb3VyY2UvdjIvc3R5bGVcIjtcclxuaW1wb3J0IENlbnRlckNvbnRlbnQgZnJvbSBcImxpYi1zb3VyY2UvdWl2Mi9DZW50ZXJDb250ZW50XCI7XHJcbmltcG9ydCBUb3VjaGFibGUgZnJvbSBcImxpYi1zb3VyY2UvdWl2Mi9Ub3VjaGFibGVcIjtcclxuaW1wb3J0IEljb24gZnJvbSBcImxpYi1zb3VyY2UvdWl2Mi9JY29uXCI7XHJcblxyXG5kZWZpbmVDb21wb25lbnRTdHlsZShcclxuICAgICdyYWRpbycsXHJcbiAgICAnY29yZScsXHJcbiAgICB7XHJcbiAgICAgICAgXCJ0aXRsZVwiOiB7XHJcbiAgICAgICAgICAgIGZvbnRTaXplOiAyMixcclxuICAgICAgICAgICAgcGFkZGluZzogM1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuKTtcclxuZGVmaW5lQ29tcG9uZW50U3R5bGUoXHJcbiAgICBcInJhZGlvLWl0ZW1cIixcclxuICAgIFwiY29yZVwiLFxyXG4gICAge1xyXG4gICAgICAgIFwiZGVmYXVsdC1pdGVtXCI6IHtcclxuICAgICAgICAgICAgY29sb3I6ICdibGFjaycsXHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxyXG4gICAgICAgICAgICBwYWRkaW5nTGVmdDogMzAsXHJcbiAgICAgICAgICAgIHRyYW5zaXRpb246ICdiYWNrZ3JvdW5kLWNvbG9yIDUwMG1zIGxpbmVhcidcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8vIFwiLnJhZGlvLWl0ZW0tY29udGFpbmVyOmFjdGl2ZSA+IGRlZmF1bHQtaXRlbVwiOiB7XHJcbiAgICAgICAgXCJkZWZhdWx0LWl0ZW06YWN0aXZlXCI6IHtcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSgwLCAwLCAwLCAwLjEpJyxcclxuICAgICAgICAgICAgdHJhbnNpdGlvbjogJ25vbmUnXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcImljb25cIjoge1xyXG4gICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcclxuICAgICAgICAgICAgdG9wOiAwLFxyXG4gICAgICAgICAgICBsZWZ0OiAwLFxyXG4gICAgICAgICAgICBib3R0b206IDAsXHJcbiAgICAgICAgICAgIHdpZHRoOiAzMFxyXG4gICAgICAgIH1cclxuICAgIH1cclxuKTtcclxuY29uc3QgUmFkaW9JdGVtID0gKHtjaGVja2VkLCBpY29uQ29sb3IsIGNoaWxkcmVuLCBvblRhcH0pID0+IHtcclxuICAgIGNvbnN0IGljb25OYW1lID0gYGlvbi1hbmRyb2lkLXJhZGlvLWJ1dHRvbi0ke2NoZWNrZWQgPT09IHRydWUgPyAnb24nIDogJ29mZid9YDtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPFRvdWNoYWJsZSBjb21wb25lbnQ9XCJkaXZcIiBvblRhcD17b25UYXB9IGNsYXNzTmFtZT1cInJhZGlvLWl0ZW0tY29yZS1kZWZhdWx0LWl0ZW1cIiBkYXRhLWNoZWNrZWQ9e2NoZWNrZWR9PlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17YHJhZGlvLWl0ZW0tY29yZS1pY29uYH0gZGF0YS1jaGVja2VkPXtjaGVja2VkfT5cclxuICAgICAgICAgICAgICAgIDxDZW50ZXJDb250ZW50IGhlaWdodD1cIjEwMCVcIj5cclxuICAgICAgICAgICAgICAgICAgICA8SWNvbiBzaXplPXsxOH0gbmFtZT17aWNvbk5hbWV9IC8+XHJcbiAgICAgICAgICAgICAgICA8L0NlbnRlckNvbnRlbnQ+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICB7Y2hpbGRyZW59XHJcbiAgICAgICAgPC9Ub3VjaGFibGU+XHJcbiAgICApO1xyXG59O1xyXG5jbGFzcyBSYWRpbyBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xyXG4gICAgICAgIHN1cGVyKHByb3BzKTtcclxuICAgIH1cclxuXHJcbiAgICBzZWxlY3QgPSAoaW5kZXgsIHZhbHVlKSA9PiB7XHJcbiAgICAgICAgaWYgKGluZGV4ICE9PSB0aGlzLnByb3BzLnNlbGVjdGVkSW5kZXgpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZShpbmRleCwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZW5kZXIgPSAoKSA9PiB7XHJcbiAgICAgICAgY29uc3Qge1xyXG4gICAgICAgICAgICBsYXlvdXQgPSAnZGl2JyxcclxuICAgICAgICAgICAgc2VsZWN0ZWRJbmRleCxcclxuICAgICAgICAgICAgb25DaGFuZ2UgPSAoKSA9PiB7fSxcclxuICAgICAgICAgICAgc3R5bGVOYW1lID0gJ2NvcmUnLFxyXG4gICAgICAgICAgICB0aXRsZVxyXG4gICAgICAgIH0gPSB0aGlzLnByb3BzO1xyXG4gICAgICAgIGNvbnN0IENvbnRhaW5lciA9IGxheW91dDtcclxuXHJcbiAgICAgICAgbGV0IHtcclxuICAgICAgICAgICAgY2hpbGRyZW4sXHJcbiAgICAgICAgICAgIC4uLmxheW91dFByb3BzXHJcbiAgICAgICAgfSA9IHRoaXMucHJvcHM7XHJcbiAgICAgICAgbGV0IEl0ZW07XHJcblxyXG4gICAgICAgIGlmIChDb250YWluZXIgPT09ICdkaXYnKSB7XHJcbiAgICAgICAgICAgIEl0ZW0gPSBSYWRpb0l0ZW07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgSXRlbSA9IENvbnRhaW5lci5SYWRpb0l0ZW07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjaGlsZHJlbiA9IFJlYWN0LkNoaWxkcmVuLnRvQXJyYXkoY2hpbGRyZW4pO1xyXG4gICAgICAgIGxheW91dFByb3BzID0gT2JqZWN0LmVudHJpZXMobGF5b3V0UHJvcHMpLnJlZHVjZShcclxuICAgICAgICAgICAgKG5ld1Byb3BzLCBba2V5LCB2YWx1ZV0pID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChrZXkuc3RhcnRzV2l0aChcImxheW91dC1cIikgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdQcm9wc1trZXkuc2xpY2UoNyldID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3UHJvcHM7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHt9XHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPGRpdj5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicmFkaW8tY29yZS10aXRsZVwiPnt0aXRsZX08L2Rpdj5cclxuICAgICAgICAgICAgICAgIDxDb250YWluZXIgey4uLmxheW91dFByb3BzfT5cclxuICAgICAgICAgICAgICAgIHtjaGlsZHJlbi5tYXAoKGNoaWxkLCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gY2hpbGQucHJvcHMudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gPFRvdWNoYWJsZSBjb21wb25lbnQ9XCJkaXZcIiBjbGFzc05hbWU9XCJyYWRpby1pdGVtLWNvbnRhaW5lclwiIGtleT17aW5kZXh9IG9uVGFwPXsoKSA9PiB0aGlzLnNlbGVjdChpbmRleCwgdmFsdWUpfT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxJdGVtIGNoZWNrZWQ9e3NlbGVjdGVkSW5kZXggPT09IGluZGV4fSB7Li4uY2hpbGQucHJvcHN9IG9uVGFwPXsoKSA9PiB0aGlzLnNlbGVjdChpbmRleCwgdmFsdWUpfSAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB7Lyo8L1RvdWNoYWJsZT4qL31cclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgfSl9XHJcbiAgICAgICAgICAgICAgICA8L0NvbnRhaW5lcj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgKTtcclxuICAgIH1cclxufVxyXG5cclxuUmFkaW8udmFsdWVQcm9wID0gJ3NlbGVjdGVkSW5kZXgnO1xyXG5SYWRpby52YWx1ZUZ1bmN0aW9uID0gKGluZGV4LCB2YWx1ZSkgPT4gKHtpbmRleCwgdmFsdWV9KTtcclxuUmFkaW8uZGVmYXVsdFByb3BWYWx1ZSA9IDA7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBSYWRpbztcclxuIiwiaW1wb3J0IEltYWdlIGZyb20gXCJsaWItc291cmNlL3VpdjIvSW1hZ2VcIjtcclxuaW1wb3J0IFNwaW5uZXJEYXRhVVJMIGZyb20gXCJsaWItc291cmNlL2RhdGEtdXJpL2xvYWQtc3Bpbm5lci5naWYuc291cmNlXCI7XHJcblxyXG5jb25zdCBTcGlubmVyID0gKHtzaXplfSkgPT4gPEltYWdlIHdpZHRoPXtzaXplfSBoZWlnaHQ9e3NpemV9IHNvdXJjZT17U3Bpbm5lckRhdGFVUkx9IC8+O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgU3Bpbm5lcjtcclxuIiwiaW1wb3J0IHtkZWZpbmVDb21wb25lbnRTdHlsZX0gZnJvbSBcImxpYi1zb3VyY2UvdjIvc3R5bGVcIjtcclxuaW1wb3J0IFJhbmdlSW5wdXQgZnJvbSAnbGliLXNvdXJjZS91aXYyL2lucHV0L1JhbmdlSW5wdXQnO1xyXG5cclxuZGVmaW5lQ29tcG9uZW50U3R5bGUoXHJcbiAgICAndGltZS1zZWxlY3RvcicsXHJcbiAgICAnY29yZScsXHJcbiAgICB7XHJcbiAgICAgICAgXCJ0aW1lLWRpc3BsYXlcIjoge1xyXG4gICAgICAgICAgICB0ZXh0QWxpZ246ICdjZW50ZXInLFxyXG4gICAgICAgICAgICBmb250U2l6ZTogMjQsXHJcbiAgICAgICAgICAgIGNvbG9yOiAnYmxhY2snXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4pO1xyXG5jbGFzcyBUaW1lU2VsZWN0b3IgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xyXG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcclxuICAgICAgICBzdXBlcihwcm9wcyk7XHJcbiAgICB9XHJcblxyXG4gICAgY2hhbmdlID0gcHJvcCA9PlxyXG4gICAgICAgIChuZXdWYWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB7dmFsdWUsIG9uQ2hhbmdlID0gd2FybmluZ0Z1bmMoXCJvbkNoYW5nZSBub3QgZ2l2ZW4gdG8gVGltZVNlbGVjdG9yXCIpfSA9IHRoaXMucHJvcHM7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoYW5nZWQgPSB7W3Byb3BdOiBuZXdWYWx1ZX07XHJcblxyXG4gICAgICAgICAgICBvbkNoYW5nZSh2YWx1ZS5zZXQoY2hhbmdlZCkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICByZW5kZXIgPSAoKSA9PiB7XHJcbiAgICAgICAgY29uc3Qge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IG51bGwsXHJcbiAgICAgICAgICAgIGZvcm1hdCA9IFwie2hvdXIvMTJwYWRkZWR9OnttaW51dGUvcGFkZGVkfSB7dG9kfVwiXHJcbiAgICAgICAgfSA9IHRoaXMucHJvcHM7XHJcbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBhIHZhbHVlIHRvIFRpbWVTZWxlY3RvclwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qge2hvdXJzLCBtaW51dGVzfSA9IHZhbHVlO1xyXG5cclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0aW1lLXNlbGVjdG9yLWNvcmUtdGltZS1kaXNwbGF5XCI+e3ZhbHVlLmZvcm1hdChmb3JtYXQpfTwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPFJhbmdlSW5wdXQga2V5PVwiMFwiIHZhbHVlPXtob3Vyc30gbWluPXswfSBtYXg9ezIzfSBsYWJlbD1cIkhvdXJcIiBvbkNoYW5nZT17dGhpcy5jaGFuZ2UoJ2hvdXJzJyl9IHNob3dBcnJvd3MgLz5cclxuICAgICAgICAgICAgICAgIDxSYW5nZUlucHV0IGtleT1cIjFcIiB2YWx1ZT17bWludXRlc30gbWluPXswfSBtYXg9ezU5fSBsYWJlbD1cIk1pbnV0ZVwiIG9uQ2hhbmdlPXt0aGlzLmNoYW5nZSgnbWludXRlcycpfSBzaG93QXJyb3dzIC8+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFRpbWVTZWxlY3RvcjtcclxuIiwiaW1wb3J0IHtkZWZpbmVDb21wb25lbnRTdHlsZSwgZGVmaW5lQ3VzdG9tQmFzZX0gZnJvbSBcImxpYi1zb3VyY2UvdjIvc3R5bGVcIjtcclxuaW1wb3J0IHt0cmFuc2ZlclByb3BzfSBmcm9tICdsaWItc291cmNlL3YyL3V0aWxzJztcclxuXHJcbmNvbnN0IGFuaW1hdGlvblRpbWUgPSAxMDA7XHJcbmRlZmluZUNvbXBvbmVudFN0eWxlKFxyXG4gICAgJ3RvZ2dsZScsXHJcbiAgICAnY29yZScsXHJcbiAgICB7XHJcbiAgICAgICAgXCJjb250YWluZXJcIjoge1xyXG4gICAgICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcclxuICAgICAgICAgICAgdHJhbnNpdGlvbjogJ2JhY2tncm91bmQtY29sb3IgNTAwbXMgbGluZWFyJyxcclxuICAgICAgICAgICAgZm9udFNpemU6IDIwLFxyXG4gICAgICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbidcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiY29udGFpbmVyOmFjdGl2ZVwiOiB7XHJcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMCwgMCwgMCwgMC4wNzUpJyxcclxuICAgICAgICAgICAgdHJhbnNpdGlvbjogJ25vbmUnXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcInRvZ2dsZS1jb250YWluZXJcIjoge1xyXG4gICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcclxuICAgICAgICAgICAgcmlnaHQ6IDEzLFxyXG4gICAgICAgICAgICB3aWR0aDogMzAsXHJcbiAgICAgICAgICAgIHRvcDogJzUwJScsXHJcbiAgICAgICAgICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGVZKC01MCUpXCIsXHJcbiAgICAgICAgICAgIGhlaWdodDogOCxcclxuICAgICAgICAgICAgZm9udFNpemU6IDExLFxyXG4gICAgICAgICAgICBib3JkZXJSYWRpdXM6IDE1LFxyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdsaWdodGdyYXknLFxyXG4gICAgICAgICAgICBsaW5lSGVpZ2h0OiAnMjJweCdcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwidG9nZ2xlLWNvbnRhaW5lcltkYXRhLW9uPSd0cnVlJ11cIjoge1xyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjYmVkMGJkJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJ0b2dnbGVcIjoge1xyXG4gICAgICAgICAgICBXZWJraXRUcmFuc2l0aW9uOiBgYmFja2dyb3VuZC1jb2xvciAke2FuaW1hdGlvblRpbWV9bXMgbGluZWFyLCAtd2Via2l0LXRyYW5zZm9ybSAke2FuaW1hdGlvblRpbWV9bXMgbGluZWFyYCxcclxuICAgICAgICAgICAgdHJhbnNpdGlvbjogYGJhY2tncm91bmQtY29sb3IgJHthbmltYXRpb25UaW1lfW1zIGxpbmVhciwgdHJhbnNmb3JtICR7YW5pbWF0aW9uVGltZX1tcyBsaW5lYXJgLFxyXG4gICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcclxuICAgICAgICAgICAgbGVmdDogLTExLFxyXG4gICAgICAgICAgICB0b3A6IC03LFxyXG4gICAgICAgICAgICBoZWlnaHQ6IDIyLFxyXG4gICAgICAgICAgICB3aWR0aDogMjIsXHJcbiAgICAgICAgICAgIGJvcmRlclJhZGl1czogMTUsXHJcbiAgICAgICAgICAgIHRleHRBbGlnbjogJ2NlbnRlcicsXHJcbiAgICAgICAgICAgIGJvcmRlcjogJzFweCBzb2xpZCBsaWdodGdyYXknLFxyXG4gICAgICAgICAgICBib3hTaGFkb3c6ICcycHggMnB4IDJweCByZ2JhKDAsIDAsIDAsIDAuMTUpJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJ0b2dnbGVbZGF0YS1vbj0nZmFsc2UnXVwiOiB7XHJcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVgoMCknLFxyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICd3aGl0ZSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwidG9nZ2xlW2RhdGEtb249J3RydWUnXVwiOiB7XHJcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVgoMzBweCknLFxyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjMjRiMzI0J1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJsYWJlbFwiOiB7XHJcbiAgICAgICAgICAgIHBhZGRpbmc6IDMsXHJcbiAgICAgICAgICAgIHBhZGRpbmdSaWdodDogNzAsXHJcbiAgICAgICAgICAgIHdoaXRlU3BhY2U6ICdwcmUnLFxyXG4gICAgICAgICAgICBjb2xvcjogJ2JsYWNrJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJzdWJ0aXRsZVwiOiB7XHJcbiAgICAgICAgICAgIGNvbG9yOiAnZ3JheScsXHJcbiAgICAgICAgICAgIGZvbnRTaXplOiAxNFxyXG4gICAgICAgIH1cclxuICAgIH1cclxuKTtcclxuXHJcbmNvbnN0IFRvZ2dsZSA9IHByb3BzID0+IHtcclxuICAgIGNvbnN0IHtcclxuICAgICAgICBvbiA9IGZhbHNlLFxyXG4gICAgICAgIGxhYmVsLFxyXG4gICAgICAgIHN1YlRpdGxlID0gbnVsbCxcclxuICAgICAgICBvbkNoYW5nZSA9ICgpID0+IGNvbnNvbGUud2FybihcIk5vIG9uQ2hhbmdlIGdpdmVuIHRvIGNoZWNrYm94XCIpLFxyXG4gICAgICAgIHN0eWxlTmFtZSA9ICdjb3JlJ1xyXG4gICAgfSA9IHByb3BzO1xyXG4gICAgbGV0IGNvbnRlbnQgPSBsYWJlbDtcclxuICAgIGxldCB0b2dnbGVTdHlsZTtcclxuXHJcbiAgICBpZiAoc3ViVGl0bGUgIT09IG51bGwpIHtcclxuICAgICAgICBjb250ZW50ID0gKFxyXG4gICAgICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgICAgICAge2xhYmVsfVxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjaGVja2JveC1jb3JlLXN1YnRpdGxlXCI+e3N1YlRpdGxlfTwvZGl2PlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPFVJLlRvdWNoYWJsZSBjb21wb25lbnQ9XCJkaXZcIiBjbGFzc05hbWU9XCJ0b2dnbGUtY29yZS1jb250YWluZXJcIiBvblRhcD17KCkgPT4gb25DaGFuZ2UoIW9uKX0+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtgdG9nZ2xlLWNvcmUtbGFiZWwgdG9nZ2xlLSR7c3R5bGVOYW1lfS1sYWJlbC1jdXN0b21gfT57Y29udGVudH08L2Rpdj5cclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2B0b2dnbGUtY29yZS10b2dnbGUtY29udGFpbmVyIHRvZ2dsZS0ke3N0eWxlTmFtZX0tdG9nZ2xlLWNvbnRhaW5lci1jdXN0b21gfSBkYXRhLW9uPXtvbn0+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17YHRvZ2dsZS1jb3JlLXRvZ2dsZSB0b2dnbGUtJHtzdHlsZU5hbWV9LXRvZ2dsZS1jdXN0b21gfSBkYXRhLW9uPXtvbn0gLz5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIHsvKjxSaXBwbGUgLz4qL31cclxuICAgICAgICA8L1VJLlRvdWNoYWJsZT5cclxuICAgICk7XHJcbn07XHJcblRvZ2dsZS5jb21wb25lbnROYW1lID0gJ3RvZ2dsZSc7XHJcblxyXG5kZWZpbmVDdXN0b21CYXNlKFxyXG4gICAgVG9nZ2xlLFxyXG4gICAgKHtub3JtYWwgPSBudWxsLCBvbiA9IG51bGwsIGxhYmVsID0gbnVsbCwgc3VidGl0bGUgPSBudWxsfSkgPT4gdHJhbnNmZXJQcm9wcyh7XHJcbiAgICAgICAgXCIudG9nZ2xlLWNvcmUtdG9nZ2xlLWNvbnRhaW5lci90b2dnbGUtY29udGFpbmVyLWN1c3RvbVwiOiBbXHJcbiAgICAgICAgICAgIG5vcm1hbCxcclxuICAgICAgICAgICAge3RyYWNrQ29sb3I6ICdiYWNrZ3JvdW5kQ29sb3InfVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgXCIudG9nZ2xlLWNvcmUtdG9nZ2xlLWNvbnRhaW5lci90b2dnbGUtY29udGFpbmVyLWN1c3RvbVtkYXRhLW9uPSd0cnVlJ11cIjogW1xyXG4gICAgICAgICAgICBvbixcclxuICAgICAgICAgICAge3RyYWNrQ29sb3I6ICdiYWNrZ3JvdW5kQ29sb3InfVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgXCIudG9nZ2xlLWNvcmUtdG9nZ2xlL3RvZ2dsZS1jdXN0b21cIjogW1xyXG4gICAgICAgICAgICBub3JtYWwsXHJcbiAgICAgICAgICAgIHt0aHVtYkNvbG9yOiAnYmFja2dyb3VuZENvbG9yJ31cclxuICAgICAgICBdLFxyXG4gICAgICAgIFwiLnRvZ2dsZS1jb3JlLXRvZ2dsZS90b2dnbGUtY3VzdG9tW2RhdGEtb249J3RydWUnXVwiOiBbXHJcbiAgICAgICAgICAgIG9uLFxyXG4gICAgICAgICAgICB7dGh1bWJDb2xvcjogJ2JhY2tncm91bmRDb2xvcid9XHJcbiAgICAgICAgXSxcclxuICAgICAgICBcIi50b2dnbGUtY29yZS1sYWJlbC9sYWJlbC1jdXN0b21cIjogW1xyXG4gICAgICAgICAgICBsYWJlbCxcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGV4dENvbG9yOiAnY29sb3InLFxyXG4gICAgICAgICAgICAgICAgY29sb3I6ICdiYWNrZ3JvdW5kQ29sb3InXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICBdLFxyXG4gICAgICAgIFwiLnRvZ2dsZS1jb3JlLXN1YnRpdGxlL3N1YnRpdGxlLWN1c3RvbVwiOiBbXHJcbiAgICAgICAgICAgIHN1YnRpdGxlLFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0Q29sb3I6ICdjb2xvcicsXHJcbiAgICAgICAgICAgICAgICBjb2xvcjogJ2JhY2tncm91bmRDb2xvcidcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIF1cclxuICAgIH0pXHJcbik7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBUb2dnbGU7XHJcbiIsIi8vIGltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcclxuLy8gaW1wb3J0IFJlYWN0RE9NIGZyb20gXCJyZWFjdC1kb21cIjtcclxuXHJcbmNvbnN0IGZvckVhY2ggPSBBcnJheS5wcm90b3R5cGUuZm9yRWFjaDtcclxuY29uc3Qge3NxcnR9ID0gTWF0aDtcclxuXHJcbmxldCBUb3VjaGFibGU7XHJcblxyXG5Ub3VjaGFibGUgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XHJcbiAgICB0b3VjaFN0YXJ0KGV2dCkge1xyXG4gICAgICAgIGNvbnN0IHtvblRvdWNoU3RhcnR9ID0gdGhpcy5wcm9wcztcclxuICAgICAgICBjb25zdCBbdG91Y2hdID0gZXZ0LmNoYW5nZWRUb3VjaGVzO1xyXG5cclxuICAgICAgICBSZWFjdERPTS5maW5kRE9NTm9kZSh0aGlzKS5jbGFzc0xpc3QuYWRkKFwiY29yLXRvdWNoLWFjdGl2ZVwiKTtcclxuICAgICAgICBpZiAob25Ub3VjaFN0YXJ0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgb25Ub3VjaFN0YXJ0KGV2dCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmluZm8gPSB7XHJcbiAgICAgICAgICAgIGlkOiB0b3VjaC5pZGVudGlmaWVyLFxyXG4gICAgICAgICAgICB4OiB0b3VjaC5wYWdlWCxcclxuICAgICAgICAgICAgeTogdG91Y2gucGFnZVlcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxuICAgIHRvdWNoTW92ZShldnQpIHtcclxuICAgICAgICBjb25zdCB7b25Ub3VjaE1vdmV9ID0gdGhpcy5wcm9wcztcclxuICAgICAgICBpZiAob25Ub3VjaE1vdmUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBvblRvdWNoTW92ZShldnQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZXZ0LmNoYW5nZWRUb3VjaGVzOjpmb3JFYWNoKHRvdWNoID0+IHtcclxuICAgICAgICAgICAgaWYgKHRvdWNoLmlkZW50aWZpZXIgIT09IHRoaXMuaW5mby5pZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoc3FydCgodG91Y2gucGFnZVggLSB0aGlzLmluZm8ueCkgKiogMiArICh0b3VjaC5wYWdlWSAtIHRoaXMuaW5mby55KSAqKiAyKSA+IDI1KSB7XHJcbiAgICAgICAgICAgICAgICBSZWFjdERPTS5maW5kRE9NTm9kZSh0aGlzKS5jbGFzc0xpc3QucmVtb3ZlKFwiY29yLXRvdWNoLWFjdGl2ZVwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgIHRvdWNoRW5kKGV2dCkge1xyXG4gICAgICAgIGNvbnN0IHtvblRvdWNoRW5kfSA9IHRoaXMucHJvcHM7XHJcbiAgICAgICAgaWYgKG9uVG91Y2hFbmQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBvblRvdWNoRW5kKGV2dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGV2dC5jaGFuZ2VkVG91Y2hlczo6Zm9yRWFjaCh0b3VjaCA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0b3VjaC5pZGVudGlmaWVyICE9PSB0aGlzLmluZm8uaWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgUmVhY3RET00uZmluZERPTU5vZGUodGhpcykuY2xhc3NMaXN0LnJlbW92ZShcImNvci10b3VjaC1hY3RpdmVcIik7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gdGhpcy5wcm9wcy5vblRvdWNoRW5kKGV2dCk7XHJcbiAgICB9LFxyXG4gICAgZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlZnMubm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgIH0sXHJcbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcclxuICAgICAgICBjb25zdCB7bm9kZX0gPSB0aGlzLnJlZnM7XHJcbiAgICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKFxyXG4gICAgICAgICAgICAndGFwJyxcclxuICAgICAgICAgICAgZXZ0ID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHtvblRhcH0gPSB0aGlzLnByb3BzO1xyXG4gICAgICAgICAgICAgICAgbm9kZS5mb2N1cygpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG9uVGFwICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzOjpvblRhcChldnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gOjp0aGlzLnByb3BzLm9uVGFwKGV2dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICApO1xyXG4gICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcclxuICAgICAgICAgICAgJ2hvbGQnLFxyXG4gICAgICAgICAgICBldnQgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qge29uSG9sZH0gPSB0aGlzLnByb3BzO1xyXG4gICAgICAgICAgICAgICAgbm9kZS5mb2N1cygpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG9uSG9sZCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpczo6b25Ib2xkKGV2dCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyA6OnRoaXMucHJvcHMub25Ib2xkKGV2dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICApO1xyXG4gICAgfSxcclxuICAgIHJlbmRlcigpIHtcclxuICAgICAgICBjb25zdCB7Y29tcG9uZW50ID0gbnVsbCwgY2hpbGRyZW4sIG9uVGFwLCBvbkhvbGQsIC4uLnByb3BzfSA9IHRoaXMucHJvcHM7XHJcbiAgICAgICAgY29uc3QgQ29tcG9uZW50ID0gY29tcG9uZW50O1xyXG4gICAgICAgIGNvbnN0IGNvbXBvbmVudFByb3BzID0ge1xyXG4gICAgICAgICAgICAuLi5wcm9wcyxcclxuICAgICAgICAgICAgb25Ub3VjaFN0YXJ0OiB0aGlzLnRvdWNoU3RhcnQsXHJcbiAgICAgICAgICAgIG9uVG91Y2hNb3ZlOiB0aGlzLnRvdWNoTW92ZSxcclxuICAgICAgICAgICAgb25Ub3VjaEVuZDogdGhpcy50b3VjaEVuZCxcclxuICAgICAgICAgICAgb25Ub3VjaENhbmNlbDogdGhpcy50b3VjaEVuZFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGlmIChDb21wb25lbnQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwYXNzIGEgY29tcG9uZW50IGludG8gVG91Y2hhYmxlXCIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIDxDb21wb25lbnQgcmVmPVwibm9kZVwiIHsuLi5jb21wb25lbnRQcm9wc30+e2NoaWxkcmVufTwvQ29tcG9uZW50PjtcclxuICAgIH1cclxufSk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBUb3VjaGFibGU7XHJcbiIsImltcG9ydCB7ZGVmaW5lQ29tcG9uZW50U3R5bGUsIGRlZmluZVN0eWxlRm9yQ29tcG9uZW50LCBkZWZpbmVDdXN0b21CYXNlfSBmcm9tIFwibGliLXNvdXJjZS92Mi9zdHlsZS5qc1wiO1xyXG5pbXBvcnQgUmlwcGxlIGZyb20gXCJsaWItc291cmNlL3VpdjIvcmlwcGxlLmpzXCI7XHJcbmltcG9ydCBJY29uIGZyb20gJ2xpYi1zb3VyY2UvdWl2Mi9pY29uLmpzJztcclxuaW1wb3J0IFRvdWNoYWJsZSBmcm9tICdsaWItc291cmNlL3VpdjIvVG91Y2hhYmxlJztcclxuaW1wb3J0IHZhcnMgZnJvbSAnbGliLXNvdXJjZS91aXYyL3ZhcnMnO1xyXG5pbXBvcnQge3RyYW5zZmVyUHJvcHN9IGZyb20gJ2xpYi1zb3VyY2UvdjIvdXRpbHMnO1xyXG5cclxuZGVmaW5lQ29tcG9uZW50U3R5bGUoXHJcbiAgICAnYnV0dG9uJyxcclxuICAgICdjb3JlJyxcclxuICAgIHtcclxuICAgICAgICBcIndyYXBwZXJcIjoge1xyXG4gICAgICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcclxuICAgICAgICAgICAgdGV4dEFsaWduOiAnY2VudGVyJyxcclxuICAgICAgICAgICAgbWFyZ2luOiA0LFxyXG4gICAgICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXHJcbiAgICAgICAgICAgIHpJbmRleDogXCIrMFwiLFxyXG4gICAgICAgICAgICB3aGl0ZVNwYWNlOiAncHJlJyxcclxuICAgICAgICAgICAgZGlzcGxheTogJ2lubGluZS1ibG9jaycsXHJcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3RyYW5zcGFyZW50JyxcclxuICAgICAgICAgICAgY29sb3I6ICdibGFjaycsXHJcbiAgICAgICAgICAgIGJvcmRlclJhZGl1czogM1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJ3cmFwcGVyOmZvY3VzXCI6IHtcclxuICAgICAgICAgICAgb3V0bGluZTogJ25vbmUnXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcIndyYXBwZXJbZGlzYWJsZWRdXCI6IHtcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnI2VhZWFlYScsXHJcbiAgICAgICAgICAgIGNvbG9yOiAnI2EwYTBhMCdcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwidGV4dC13cmFwcGVyXCI6IHtcclxuICAgICAgICAgICAgZGlzcGxheTogJ3RhYmxlJyxcclxuICAgICAgICAgICAgd2lkdGg6ICcxMDAlJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJ0ZXh0XCI6IHtcclxuICAgICAgICAgICAgaGVpZ2h0OiAnMTAwJScsXHJcbiAgICAgICAgICAgIHdpZHRoOiAnMTAwJScsXHJcbiAgICAgICAgICAgIHBhZGRpbmc6IDUsXHJcbiAgICAgICAgICAgIHBhZGRpbmdMZWZ0OiAxNSxcclxuICAgICAgICAgICAgcGFkZGluZ1JpZ2h0OiAxNSxcclxuICAgICAgICAgICAgdGV4dEFsaWduOiAnY2VudGVyJyxcclxuICAgICAgICAgICAgdmVydGljYWxBbGlnbjogJ21pZGRsZScsXHJcbiAgICAgICAgICAgIHdoaXRlU3BhY2U6ICdwcmUnLFxyXG4gICAgICAgICAgICBkaXNwbGF5OiAndGFibGUtY2VsbCdcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwid3JhcHBlciA+IG92ZXJsYXlcIjoge1xyXG4gICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcclxuICAgICAgICAgICAgdG9wOiAwLFxyXG4gICAgICAgICAgICBsZWZ0OiAwLFxyXG4gICAgICAgICAgICByaWdodDogMCxcclxuICAgICAgICAgICAgYm90dG9tOiAwLFxyXG4gICAgICAgICAgICB0cmFuc2l0aW9uOiAnYmFja2dyb3VuZC1jb2xvciA1MDBtcyBsaW5lYXInXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcIi5jb3JlLWRlc2t0b3Agb3ZlcmxheTpob3ZlclwiOiB7XHJcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogdmFycy5ob3ZlckNvbG9yXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcIndyYXBwZXI6YWN0aXZlID4gb3ZlcmxheVwiOiB7XHJcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogdmFycy5hY3RpdmVDb2xvcixcclxuICAgICAgICAgICAgdHJhbnNpdGlvbjogJ25vbmUnXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4pO1xyXG5cclxuY29uc3QgQnV0dG9uID0gcHJvcHMgPT4ge1xyXG4gICAgbGV0IHtcclxuICAgICAgICB0ZXh0LFxyXG4gICAgICAgIG9uVGFwID0gKCkgPT4gY29uc29sZS53YXJuKFwiTm8gb25UYXAgZ2l2ZW4gdG8gQnV0dG9uXCIpLFxyXG4gICAgICAgIHN0eWxlTmFtZSA9IFwiY29yZVwiLFxyXG4gICAgICAgIGJ1dHRvbkNvbG9yID0gbnVsbCxcclxuICAgICAgICB0ZXh0Q29sb3IgPSBudWxsLFxyXG4gICAgICAgIGZsdXNoLFxyXG4gICAgICAgIGJsb2NrLFxyXG4gICAgICAgIGZpbGwsXHJcbiAgICAgICAgcGFkZGluZyxcclxuICAgICAgICBkaXNhYmxlZCxcclxuICAgICAgICBpY29uTmFtZSA9IG51bGwsXHJcbiAgICAgICAgaWNvblNpemUgPSBudWxsXHJcbiAgICB9ID0gcHJvcHM7XHJcblxyXG4gICAgY29uc3Qgd3JhcHBlck5hbWUgPSBgYnV0dG9uLWNvcmUtd3JhcHBlciBidXR0b24tJHtzdHlsZU5hbWV9LXdyYXBwZXItY3VzdG9tYDtcclxuXHJcbiAgICBjb25zdCB3cmFwcGVyU3R5bGUgPSB7YmFja2dyb3VuZENvbG9yOiBidXR0b25Db2xvcn07XHJcbiAgICBjb25zdCB0ZXh0V3JhcHBlclN0eWxlID0ge307XHJcbiAgICBjb25zdCB0ZXh0U3R5bGUgPSB7Y29sb3I6IHRleHRDb2xvcn07XHJcbiAgICBsZXQgcmlwcGxlRWxlbWVudDtcclxuICAgIGxldCBvblRhcEhhbmRsZXI7XHJcblxyXG4gICAgaWYgKGRpc2FibGVkICE9PSB0cnVlKSB7XHJcbiAgICAgICAgLy8gcmlwcGxlRWxlbWVudCA9IDxSaXBwbGUgLz47XHJcbiAgICAgICAgb25UYXBIYW5kbGVyID0gb25UYXA7XHJcbiAgICB9XHJcbiAgICBpZiAoYmxvY2sgPT09IHRydWUpIHtcclxuICAgICAgICB3cmFwcGVyU3R5bGUuZGlzcGxheSA9ICdibG9jayc7XHJcbiAgICB9XHJcbiAgICBpZiAoZmlsbCA9PT0gdHJ1ZSkge1xyXG4gICAgICAgIGZsdXNoID0gdHJ1ZTtcclxuICAgICAgICB3cmFwcGVyU3R5bGUud2lkdGggPSAnMTAwJSc7XHJcbiAgICAgICAgd3JhcHBlclN0eWxlLmhlaWdodCA9ICcxMDAlJztcclxuICAgICAgICB0ZXh0V3JhcHBlclN0eWxlLmhlaWdodCA9ICcxMDAlJztcclxuICAgICAgICB0ZXh0U3R5bGUucGFkZGluZyA9IDA7XHJcbiAgICB9XHJcbiAgICBpZiAoZmx1c2ggPT09IHRydWUpIHtcclxuICAgICAgICB3cmFwcGVyU3R5bGUubWFyZ2luID0gMDtcclxuICAgIH1cclxuICAgIGlmIChpY29uTmFtZSAhPT0gbnVsbCkge1xyXG4gICAgICAgIHRleHQgPSA8c3Bhbj48SWNvbiBuYW1lPXtpY29uTmFtZX0gc2l6ZT17aWNvblNpemV9IC8+e3RleHR9PC9zcGFuPjtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxUb3VjaGFibGUgY29tcG9uZW50PVwiZGl2XCIgdGFiSW5kZXg9ey0xfSBjbGFzc05hbWU9e3dyYXBwZXJOYW1lfSBvblRhcD17b25UYXBIYW5kbGVyfSBkaXNhYmxlZD17ZGlzYWJsZWR9IHN0eWxlPXt3cmFwcGVyU3R5bGV9PlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImJ1dHRvbi1jb3JlLXRleHQtd3JhcHBlclwiIHN0eWxlPXt0ZXh0V3JhcHBlclN0eWxlfT5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYnV0dG9uLWNvcmUtdGV4dFwiIHN0eWxlPXt0ZXh0U3R5bGV9Pnt0ZXh0fTwvZGl2PlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJidXR0b24tY29yZS1vdmVybGF5XCIgLz5cclxuICAgICAgICAgICAge3JpcHBsZUVsZW1lbnR9XHJcbiAgICAgICAgPC9Ub3VjaGFibGU+XHJcbiAgICApO1xyXG59O1xyXG5CdXR0b24uY29tcG9uZW50TmFtZSA9ICdidXR0b24nO1xyXG5cclxuZGVmaW5lQ3VzdG9tQmFzZShcclxuICAgIEJ1dHRvbixcclxuICAgICh7bm9ybWFsID0gbnVsbCwgZm9jdXMgPSBudWxsLCBkaXNhYmxlZCA9IG51bGx9KSA9PiB0cmFuc2ZlclByb3BzKHtcclxuICAgICAgICBcIi5idXR0b24tY29yZS13cmFwcGVyL3dyYXBwZXItY3VzdG9tXCI6IFtcclxuICAgICAgICAgICAgbm9ybWFsLFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0Q29sb3I6ICdjb2xvcicsXHJcbiAgICAgICAgICAgICAgICBjb2xvcjogJ2JhY2tncm91bmRDb2xvcicsXHJcbiAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6ICdib3JkZXJSYWRpdXMnLFxyXG4gICAgICAgICAgICAgICAgc2hhZG93OiAnYm94U2hhZG93J1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFsnYmFja2dyb3VuZENvbG9yJywgJ2NvbG9yJywgJ2JvcmRlclJhZGl1cycsICdib3hTaGFkb3cnXVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgXCIuYnV0dG9uLWNvcmUtd3JhcHBlci93cmFwcGVyLWN1c3RvbTpmb2N1c1wiOiBbXHJcbiAgICAgICAgICAgIGZvY3VzLFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0Q29sb3I6ICdjb2xvcicsXHJcbiAgICAgICAgICAgICAgICBjb2xvcjogJ2JhY2tncm91bmRDb2xvcicsXHJcbiAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6ICdib3JkZXJSYWRpdXMnLFxyXG4gICAgICAgICAgICAgICAgc2hhZG93OiAnYm94U2hhZG93J1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFsnYmFja2dyb3VuZENvbG9yJywgJ2NvbG9yJywgJ2JvcmRlclJhZGl1cycsICdib3hTaGFkb3cnXVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgXCIuYnV0dG9uLWNvcmUtd3JhcHBlci93cmFwcGVyLWN1c3RvbVtkaXNhYmxlZF1cIjogW1xyXG4gICAgICAgICAgICBkaXNhYmxlZCxcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGV4dENvbG9yOiAnY29sb3InLFxyXG4gICAgICAgICAgICAgICAgY29sb3I6ICdiYWNrZ3JvdW5kQ29sb3InLFxyXG4gICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAnYm9yZGVyUmFkaXVzJyxcclxuICAgICAgICAgICAgICAgIHNoYWRvdzogJ2JveFNoYWRvdydcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBbJ2JhY2tncm91bmRDb2xvcicsICdjb2xvcicsICdib3JkZXJSYWRpdXMnLCAnYm94U2hhZG93J11cclxuICAgICAgICBdXHJcbiAgICB9KVxyXG4pO1xyXG5cclxuZGVmaW5lU3R5bGVGb3JDb21wb25lbnQoXHJcbiAgICBCdXR0b24sIFwiY2FuY2VsXCIsXHJcbiAgICB7XHJcbiAgICAgICAgbm9ybWFsOiB7XHJcbiAgICAgICAgICAgIGNvbG9yOiBcIiNiNTI2M2VcIixcclxuICAgICAgICAgICAgdGV4dENvbG9yOiAnd2hpdGUnXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4pO1xyXG5kZWZpbmVTdHlsZUZvckNvbXBvbmVudChcclxuICAgIEJ1dHRvbiwgXCJjb25maXJtXCIsXHJcbiAgICB7XHJcbiAgICAgICAgbm9ybWFsOiB7XHJcbiAgICAgICAgICAgIGNvbG9yOiBcIiMzMGQ1YTdcIlxyXG4gICAgICAgIH1cclxuICAgIH1cclxuKTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbjtcclxuIiwiaW1wb3J0IHtkZWZpbmVDb21wb25lbnRTdHlsZX0gZnJvbSBcImxpYi1zb3VyY2UvdjIvc3R5bGVcIjtcclxuaW1wb3J0IEJ1dHRvbiBmcm9tIFwibGliLXNvdXJjZS91aXYyL0J1dHRvblwiO1xyXG5pbXBvcnQgVG91Y2hhYmxlIGZyb20gXCJsaWItc291cmNlL3VpdjIvVG91Y2hhYmxlXCI7XHJcblxyXG5jb25zdCBhbmltYXRpb25UaW1lID0gMjUwO1xyXG5kZWZpbmVDb21wb25lbnRTdHlsZShcclxuICAgICdkaWFsb2cnLFxyXG4gICAgJ2NvcmUnLFxyXG4gICAge1xyXG4gICAgICAgIFwib3ZlcmxheVwiOiB7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxyXG4gICAgICAgICAgICB0b3A6IDAsXHJcbiAgICAgICAgICAgIGxlZnQ6IDAsXHJcbiAgICAgICAgICAgIHdpZHRoOiAnMTAwJScsXHJcbiAgICAgICAgICAgIGhlaWdodDogJzEwMCUnLFxyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDAsIDAsIDAsIDAuMzUpJyxcclxuICAgICAgICAgICAgekluZGV4OiAnKzEwMCcsXHJcbiAgICAgICAgICAgIGRpc3BsYXk6ICdub25lJyxcclxuICAgICAgICAgICAgV2Via2l0T3ZlcmZsb3dTY3JvbGxpbmc6ICdhdXRvJyxcclxuICAgICAgICAgICAgb3BhY2l0eTogMCxcclxuICAgICAgICAgICAgdHJhbnNpdGlvbjogYG9wYWNpdHkgJHthbmltYXRpb25UaW1lfW1zIGxpbmVhcmBcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBcIndpbmRvd1wiOiB7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICd3aGl0ZScsXHJcbiAgICAgICAgICAgIGJveFNoYWRvdzogJzBweCAwcHggMTBweCByZ2JhKDAsIDAsIDAsIDAuNiknLFxyXG4gICAgICAgICAgICAvLyBib3JkZXJSYWRpdXM6IDUsXHJcbiAgICAgICAgICAgIHdpZHRoOiAnNzUlJyxcclxuICAgICAgICAgICAgbWF4V2lkdGg6IDQ4MCxcclxuICAgICAgICAgICAgcGFkZGluZzogMCxcclxuICAgICAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcIndpbmRvdy10b3BcIjoge1xyXG4gICAgICAgICAgICB0b3A6ICcxNSUnLFxyXG4gICAgICAgICAgICBsZWZ0OiAnNTAlJyxcclxuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlWCgtNTAlKSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwid2luZG93LWNlbnRlclwiOiB7XHJcbiAgICAgICAgICAgIHRvcDogJzUwJScsXHJcbiAgICAgICAgICAgIGxlZnQ6ICc1MCUnLFxyXG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUoLTUwJSwgLTUwJSknXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgXCJjb250ZW50XCI6IHtcclxuICAgICAgICAgICAgbWF4SGVpZ2h0OiAnNTB2aCcsXHJcbiAgICAgICAgICAgIFdlYmtpdE92ZXJmbG93U2Nyb2xsaW5nOiAndG91Y2gnLFxyXG4gICAgICAgICAgICBvdmVyZmxvdzogJ2F1dG8nLFxyXG4gICAgICAgICAgICBib3JkZXJCb3R0b206ICcxcHggc29saWQgbGlnaHRncmF5JyxcclxuICAgICAgICAgICAgYm9yZGVyVG9wOiAnMXB4IHNvbGlkIGxpZ2h0Z3JheSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwidGl0bGVcIjoge1xyXG4gICAgICAgICAgICBwYWRkaW5nOiAnNSAxNScsXHJcbiAgICAgICAgICAgIGZvbnRTaXplOiAyMCxcclxuICAgICAgICAgICAgZm9udFdlaWdodDogOTAwLFxyXG4gICAgICAgICAgICBjb2xvcjogJ2JsYWNrJ1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuKTtcclxuXHJcbmxldCBjdXJyZW50RGlhbG9nID0gbnVsbDtcclxud2luZG93LmRpYWxvZyA9IHtcclxuICAgIHNob3cob3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiBjdXJyZW50RGlhbG9nLnNob3cob3B0aW9ucyk7XHJcbiAgICB9LFxyXG4gICAgaGlkZSh2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiBjdXJyZW50RGlhbG9nLmhpZGUodmFsdWUpO1xyXG4gICAgfSxcclxuICAgIHN1Y2Nlc3ModmFsdWUpIHtcclxuICAgICAgICByZXR1cm4ge3ZhbHVlLCBzdGF0dXM6ICdzdWNjZXNzJ307XHJcbiAgICB9LFxyXG4gICAgY2FuY2VsKHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHt2YWx1ZSwgc3RhdHVzOiAnY2FuY2VsZWQnfTtcclxuICAgIH0sXHJcbiAgICBpbnZhbGlkKHZhbHVlID0gbnVsbCwgcmVhc29uID0gJ2ludmFsaWQnKSB7XHJcbiAgICAgICAgcmV0dXJuIHt2YWx1ZSwgcmVhc29ufTtcclxuICAgIH1cclxufTtcclxuY2xhc3MgRGlhbG9nIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XHJcbiAgICAgICAgc3VwZXIocHJvcHMpO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XHJcbiAgICAgICAgICAgIGRpc3BsYXk6IG51bGwsXHJcbiAgICAgICAgICAgIG9wYWNpdHk6IG51bGwsXHJcbiAgICAgICAgICAgIG5hbWU6IG51bGwsXHJcbiAgICAgICAgICAgIHBvczogJ3RvcCcsXHJcbiAgICAgICAgICAgIGNvbnRlbnQ6IG51bGwsXHJcbiAgICAgICAgICAgIGNsb3NhYmxlOiAhdHJ1ZSxcclxuICAgICAgICAgICAgYnV0dG9uczogbnVsbCxcclxuICAgICAgICAgICAgdGl0bGU6IG51bGxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuYW5pbWF0aW5nID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5yZXNvbHZlciA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgc2hvdyA9IGFzeW5jIChkaXNwbGF5UHJvcHMpID0+IHtcclxuICAgICAgICBpZiAodGhpcy5hbmltYXRpbmcgPT09IHRydWUgfHwgdGhpcy5yZXNvbHZlciAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZGlhbG9nLmludmFsaWQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5hbmltYXRpbmcgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMucmVzb2x2ZXIgPSBuZXcgUHJvbWlzZShcclxuICAgICAgICAgICAgcmVzb2x2ZSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3BvbnNlID0gdmFsdWUgPT4gcmVzb2x2ZSh2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICApO1xyXG5cclxuICAgICAgICBjb25zdCB7XHJcbiAgICAgICAgICAgIGNvbnRlbnQgPSBudWxsLFxyXG4gICAgICAgICAgICBjbG9zYWJsZSA9IHRydWUsXHJcbiAgICAgICAgICAgIGJ1dHRvbnMgPSBbXHJcbiAgICAgICAgICAgICAgICB7dGV4dDogJ29rJ31cclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgdGl0bGUgPSBudWxsLFxyXG4gICAgICAgICAgICBzZXR1cCA9IG51bGxcclxuICAgICAgICB9ID0gZGlzcGxheVByb3BzO1xyXG5cclxuICAgICAgICB0aGlzLnNldFN0YXRlKHtkaXNwbGF5OiAnYmxvY2snLCBjb250ZW50LCBidXR0b25zLCBjbG9zYWJsZSwgdGl0bGV9KTtcclxuICAgICAgICBhd2FpdCBjaHJvbm8ud2FpdCg1MCk7XHJcbiAgICAgICAgdGhpcy5yZWZzLmNvbnRhaW5lci5zY3JvbGxUb3AgPSAwO1xyXG4gICAgICAgIGlmIChzZXR1cCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBzZXR1cCh0aGlzLnJlZnMuY29udGFpbmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7b3BhY2l0eTogMX0pO1xyXG4gICAgICAgIGF3YWl0IGNocm9uby53YWl0KGFuaW1hdGlvblRpbWUpO1xyXG4gICAgICAgIHRoaXMuYW5pbWF0aW5nID0gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucmVzb2x2ZXI7XHJcbiAgICB9XHJcbiAgICBoaWRlID0gYXN5bmMgKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2codGhpcy5hbmltYXRpbmcsIHRoaXMuYW5pbWF0aW5nID09PSB0cnVlKTtcclxuICAgICAgICBpZiAodGhpcy5hbmltYXRpbmcgPT09IHRydWUgfHwgdGhpcy5yZXNvbHZlID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5hbmltYXRpbmcgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe29wYWNpdHk6IG51bGx9KTtcclxuICAgICAgICBhd2FpdCBjaHJvbm8ud2FpdChhbmltYXRpb25UaW1lKTtcclxuICAgICAgICB0aGlzLnNldFN0YXRlKHtkaXNwbGF5OiBudWxsfSk7XHJcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5yZXNwb25zZSh2YWx1ZSk7XHJcbiAgICAgICAgICAgIHRoaXMucmVzcG9uc2UgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLnJlc29sdmVyID0gbnVsbDtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmFuaW1hdGluZyA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGNsb3NlID0gKCkgPT4ge1xyXG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmNsb3NhYmxlID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuaGlkZShkaWFsb2cuY2FuY2VsKG51bGwpKTtcclxuICAgIH1cclxuICAgIHN0b3BwZXIgPSAoZXZ0KSA9PiB7XHJcbiAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbXBvbmVudERpZE1vdW50ID0gKCkgPT4ge1xyXG4gICAgICAgIGN1cnJlbnREaWFsb2cgPSB0aGlzO1xyXG4gICAgfVxyXG4gICAgY29tcG9uZW50V2lsbFVubW91bnQgPSAoKSA9PiB7XHJcbiAgICAgICAgY3VycmVudERpYWxvZyA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgcmVuZGVyID0gKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHtkaXNwbGF5LCBvcGFjaXR5LCBwb3MsIGNvbnRlbnQsIGJ1dHRvbnMsIHRpdGxlfSA9IHRoaXMuc3RhdGU7XHJcbiAgICAgICAgY29uc3QgYnV0dG9uTGlzdCA9IChidXR0b25zIHx8IFtdKS5tYXAoXHJcbiAgICAgICAgICAgICh7dGV4dCwgdmFsdWUgPSBudWxsLCBjYW5jZWxzID0gZmFsc2V9LCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gY29uc3QgdmFsdWVGdW5jID0gKGNhbmNlbHMgPT09IHRydWUpID8gZGlhbG9nLmNhbmNlbCA6IGRpYWxvZy5zdWNjZXNzO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgb25UYXAgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlKHRoaXMucmVmcy5jb250YWluZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXRWYWx1ZSA9IChjYW5jZWxzID09PSB0cnVlKSA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpYWxvZy5jYW5jZWwodmFsdWUpIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlhbG9nLnN1Y2Nlc3ModmFsdWUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZGUocmV0VmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHJldHVybiA8QnV0dG9uIHRleHQ9e3RleHR9IGtleT17aW5kZXh9IG9uVGFwPXtvblRhcH0gYmxvY2sgZmx1c2ggLz47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICApO1xyXG4gICAgICAgIGxldCB0aXRsZURpc3BsYXkgPSBudWxsO1xyXG5cclxuICAgICAgICBpZiAodGl0bGUgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgdGl0bGVEaXNwbGF5ID0gPGRpdiBjbGFzc05hbWU9XCJkaWFsb2ctY29yZS10aXRsZVwiPnt0aXRsZX08L2Rpdj47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICA8VG91Y2hhYmxlIGNvbXBvbmVudD1cImRpdlwiIG9uVGFwPXt0aGlzLmNsb3NlfSBjbGFzc05hbWU9XCJkaWFsb2ctY29yZS1vdmVybGF5XCIgc3R5bGU9e3tkaXNwbGF5LCBvcGFjaXR5fX0+XHJcbiAgICAgICAgICAgICAgICA8VG91Y2hhYmxlIGNvbXBvbmVudD1cImRpdlwiIGNsYXNzTmFtZT17YGRpYWxvZy1jb3JlLXdpbmRvdyBkaWFsb2ctY29yZS13aW5kb3ctJHtwb3N9YH0gb25UYXA9e3RoaXMuc3RvcHBlcn0+XHJcbiAgICAgICAgICAgICAgICAgICAge3RpdGxlRGlzcGxheX1cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImRpYWxvZy1jb3JlLWNvbnRlbnRcIiByZWY9XCJjb250YWluZXJcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgey8qPEJ1dHRvbiB0ZXh0PVwiZGVtb1wiIGJsb2NrIG9uVGFwPXsoKSA9PiB0aGlzLmhpZGUoJ3Rlc3QnKX0gLz4qL31cclxuICAgICAgICAgICAgICAgICAgICAgICAge2NvbnRlbnR9XHJcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgPFVJLkZsZXhib3ggY29sQ291bnQ9ezN9PntidXR0b25MaXN0fTwvVUkuRmxleGJveD5cclxuICAgICAgICAgICAgICAgIDwvVG91Y2hhYmxlPlxyXG4gICAgICAgICAgICA8L1RvdWNoYWJsZT5cclxuICAgICAgICApO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBEaWFsb2c7XHJcbiIsImltcG9ydCB7ZGVmaW5lQ29tcG9uZW50U3R5bGV9IGZyb20gXCJsaWItc291cmNlL3YyL3N0eWxlLmpzXCI7XHJcblxyXG5kZWZpbmVDb21wb25lbnRTdHlsZShcclxuICAgICdpY29uJyxcclxuICAgICdjb3JlJyxcclxuICAgIHtcclxuICAgICAgICBcImNvbnRlbnRcIjoge1xyXG4gICAgICAgICAgICBmb250RmFtaWx5OiBcIklvbmljXCIsXHJcbiAgICAgICAgICAgIG1hcmdpbkxlZnQ6IDIsXHJcbiAgICAgICAgICAgIG1hcmdpblJpZ2h0OiAyXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4pO1xyXG5jb25zdCBJY29uID0gKHtuYW1lLCBzdHlsZU5hbWUgPSAnY29yZScsIHNpemV9KSA9PlxyXG4gICAgPHNwYW4gY2xhc3NOYW1lPXtgaWNvbi0ke3N0eWxlTmFtZX0tY29udGVudGB9IHN0eWxlPXt7Zm9udFNpemU6IHNpemV9fT57aW9uaWNbbmFtZV19PC9zcGFuPjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IEljb247XHJcbiIsImltcG9ydCB7ZGVmaW5lQ29tcG9uZW50U3R5bGUsIFRoZW1lfSBmcm9tIFwibGliLXNvdXJjZS92Mi9zdHlsZS5qc1wiO1xyXG4vLyBpbXBvcnQgUmlwcGxlIGZyb20gXCJsaWItc291cmNlL3VpdjIvcmlwcGxlLmpzXCI7XHJcbmltcG9ydCBJY29uIGZyb20gJ2xpYi1zb3VyY2UvdWl2Mi9pY29uLmpzJztcclxuXHJcbmRlZmluZUNvbXBvbmVudFN0eWxlKFxyXG4gICAgJ2ljb24tYnV0dG9uJyxcclxuICAgICdjb3JlJyxcclxuICAgIHtcclxuICAgICAgICBcIndyYXBwZXJcIjoge1xyXG4gICAgICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcclxuICAgICAgICAgICAgdGV4dEFsaWduOiAnY2VudGVyJyxcclxuICAgICAgICAgICAgbWFyZ2luOiA0LFxyXG4gICAgICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXHJcbiAgICAgICAgICAgIHpJbmRleDogXCIrMFwiLFxyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICd0cmFuc3BhcmVudCcsXHJcbiAgICAgICAgICAgIGNvbG9yOiAnYmxhY2snLFxyXG4gICAgICAgICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcclxuICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAnNTAlJ1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuKTtcclxuY29uc3QgSWNvbkJ1dHRvbiA9IHByb3BzID0+IHtcclxuICAgIGNvbnN0IHtcclxuICAgICAgICBzaXplID0gNDIsXHJcbiAgICAgICAgbmFtZSxcclxuICAgICAgICBpY29uU2l6ZSxcclxuICAgICAgICBzdHlsZU5hbWUgPSAnY29yZSdcclxuICAgIH0gPSBwcm9wcztcclxuXHJcbiAgICBjb25zdCB3cmFwcGVyTmFtZSA9IGBpY29uLWJ1dHRvbi0ke3N0eWxlTmFtZX0td3JhcHBlcmA7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8VUkuVG91Y2hhYmxlIGNvbXBvbmVudD1cImRpdlwiIGNsYXNzTmFtZT17d3JhcHBlck5hbWV9IHN0eWxlPXt7d2lkdGg6IHNpemUsIGhlaWdodDogc2l6ZX19PlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImJ1dHRvbi1jb3JlLXRleHQtd3JhcHBlclwiIHN0eWxlPXt7aGVpZ2h0OiAnMTAwJSd9fT5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYnV0dG9uLWNvcmUtdGV4dFwiIHN0eWxlPXt7cGFkZGluZzogMH19PjxJY29uIG5hbWU9e25hbWV9IHNpemU9e2ljb25TaXplfSAvPjwvZGl2PlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L1VJLlRvdWNoYWJsZT5cclxuICAgICk7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBJY29uQnV0dG9uO1xyXG4iLCJpbXBvcnQge2RlZmluZUNvbXBvbmVudFN0eWxlfSBmcm9tIFwibGliLXNvdXJjZS92Mi9zdHlsZVwiO1xyXG5pbXBvcnQgQnV0dG9uIGZyb20gXCJsaWItc291cmNlL3VpdjIvQnV0dG9uXCI7XHJcbmltcG9ydCBDYWxlbmRhciBmcm9tIFwibGliLXNvdXJjZS91aXYyL0NhbGVuZGFyXCI7XHJcblxyXG5jb25zdCBEYXRlSW5wdXQgPSAoe3ZhbHVlID0gY2hyb25vKCksIGZvcm1hdCA9IFwie21vbnRofS97ZGF5fS97eWVhcn1cIiwgb25DaGFuZ2UgPSAoKSA9PiB7fSwgaWNvbk5hbWV9KSA9PiB7XHJcbiAgICBjb25zdCBjaGFuZ2VEYXRlID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSBkYXRlID0+IHtcclxuICAgICAgICAgICAgZGlhbG9nLmhpZGUoZGlhbG9nLnN1Y2Nlc3MoZGF0ZSkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZGlhbG9nLnNob3coe1xyXG4gICAgICAgICAgICBjb250ZW50OiA8Q2FsZW5kYXIgc2VsZWN0ZWREYXRlPXt2YWx1ZX0gb25DaGFuZ2U9e2hhbmRsZXJ9IGtleT17RGF0ZS5ub3coKX0gLz4sXHJcbiAgICAgICAgICAgIGJ1dHRvbnM6IFt7dGV4dDogXCJDYW5jZWxcIn1dLFxyXG4gICAgICAgICAgICAvLyB0aXRsZTogXCJTZWxlY3QgRGF0ZVwiXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGlmIChyZXN1bHQudmFsdWUgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgb25DaGFuZ2UocmVzdWx0LnZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8ZGl2IHN0eWxlPXt7aGVpZ2h0OiAzMH19PlxyXG4gICAgICAgICAgICA8QnV0dG9uIHRleHQ9e3ZhbHVlLmZvcm1hdChmb3JtYXQpfSBvblRhcD17Y2hhbmdlRGF0ZX0gZmx1c2ggZmlsbCBpY29uTmFtZT17aWNvbk5hbWV9IC8+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICApO1xyXG59O1xyXG5cclxuRGF0ZUlucHV0LnZhbHVlUHJvcCA9ICd2YWx1ZSc7XHJcbkRhdGVJbnB1dC52YWx1ZUZ1bmN0aW9uID0gZGF0ZSA9PiBkYXRlO1xyXG5EYXRlSW5wdXQuZGVmYXVsdFByb3BWYWx1ZSA9ICgpID0+IGNocm9ubygpO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgRGF0ZUlucHV0O1xyXG4iLCJpbXBvcnQge2RlZmluZUNvbXBvbmVudFN0eWxlfSBmcm9tIFwibGliLXNvdXJjZS92Mi9zdHlsZVwiO1xyXG5pbXBvcnQgQnV0dG9uIGZyb20gJ2xpYi1zb3VyY2UvdWl2Mi9CdXR0b24nO1xyXG5cclxuY2xhc3MgRmlsZUlucHV0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XHJcbiAgICAgICAgc3VwZXIocHJvcHMpO1xyXG4gICAgfVxyXG5cclxuICAgIHRyaWdnZXIgPSAoKSA9PiB7XHJcbiAgICAgICAgdGhpcy5yZWZzLmZpbGUuY2xpY2soKTtcclxuICAgIH1cclxuICAgIHVwbG9hZCA9IChldnQpID0+IHtcclxuICAgICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKEFycmF5LmZyb20oZXZ0LnRhcmdldC5maWxlcykpO1xyXG4gICAgfVxyXG5cclxuICAgIHJlbmRlciA9ICgpID0+IHtcclxuICAgICAgICBjb25zdCB7dmFsdWUsIHZhbHVlRm9ybWF0ID0gZmlsZUxpc3QgPT4gZmlsZUxpc3RbMF0ubmFtZSwgbnVsbFRleHQgPSBcIlNlbGVjdCBhIGZpbGVcIiwgLi4ucHJvcHN9ID0gdGhpcy5wcm9wcztcclxuICAgICAgICBsZXQgYnV0dG9uVGV4dDtcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgYnV0dG9uVGV4dCA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgYnV0dG9uVGV4dCA9IHZhbHVlRm9ybWF0KHZhbHVlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICBidXR0b25UZXh0ID0gbnVsbFRleHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgICAgICAgPGlucHV0IHsuLi5wcm9wc30gdHlwZT1cImZpbGVcIiByZWY9XCJmaWxlXCIgc3R5bGU9e3tkaXNwbGF5OiAnbm9uZSd9fSB2YWx1ZT1cIlwiIG9uQ2hhbmdlPXt0aGlzLnVwbG9hZH0gLz5cclxuICAgICAgICAgICAgICAgIDxCdXR0b24gdGV4dD17YnV0dG9uVGV4dH0gb25UYXA9e3RoaXMudHJpZ2dlcn0gYmxvY2sgLz5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgKTtcclxuICAgIH1cclxufVxyXG5cclxuRmlsZUlucHV0LnZhbHVlUHJvcCA9IFwidmFsdWVcIjtcclxuRmlsZUlucHV0LnZhbHVlRnVuY3Rpb24gPSBmaWxlTGlzdCA9PiBmaWxlTGlzdDtcclxuRmlsZUlucHV0LmRlZmF1bHRQcm9wVmFsdWUgPSBudWxsO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgRmlsZUlucHV0O1xyXG4iLCJpbXBvcnQge2RlZmluZUNvbXBvbmVudFN0eWxlfSBmcm9tIFwibGliLXNvdXJjZS92Mi9zdHlsZVwiO1xyXG5pbXBvcnQgQnV0dG9uIGZyb20gJ2xpYi1zb3VyY2UvdWl2Mi9CdXR0b24nO1xyXG5cclxuY29uc3QgY29vbEJsdWUgPSBcIiMyRkIxREZcIjtcclxuY29uc3QgY2xhbXBWYWx1ZSA9ICh2YWx1ZSwgbWluLCBtYXgpID0+IE1hdGgubWluKE1hdGgubWF4KHZhbHVlLCBtaW4pLCBtYXgpO1xyXG5jb25zdCB0aHVtYlNpemUgPSB7XHJcbiAgICB3aWR0aDogMjQsXHJcbiAgICBoZWlnaHQ6IDI0XHJcbn07XHJcbmNvbnN0IHRyYWNrQmFzZSA9IHtcclxuICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxyXG4gICAgbGVmdDogMCxcclxuICAgIHRvcDogJzUwJScsXHJcbiAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGVZKC01MCUpJyxcclxuICAgIGhlaWdodDogNCxcclxuICAgIGJvcmRlclJhZGl1czogMlxyXG59O1xyXG5kZWZpbmVDb21wb25lbnRTdHlsZShcclxuICAgICdyYW5nZS1pbnB1dCcsXHJcbiAgICAnY29yZScsXHJcbiAgICB7XHJcbiAgICAgICAgXCJ3cmFwcGVyXCI6IHtcclxuICAgICAgICAgICAgaGVpZ2h0OiAzMCxcclxuICAgICAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiZm9jdXMtYmFja2dyb3VuZFwiOiB7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxyXG4gICAgICAgICAgICB0b3A6IDAsXHJcbiAgICAgICAgICAgIGxlZnQ6IDAsXHJcbiAgICAgICAgICAgIHJpZ2h0OiAwLFxyXG4gICAgICAgICAgICBib3R0b206IDAsXHJcbiAgICAgICAgICAgIG9wYWNpdHk6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwidHJhY2stY29udGFpbmVyXCI6IHtcclxuICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXHJcbiAgICAgICAgICAgIHRvcDogMCxcclxuICAgICAgICAgICAgbGVmdDogMTIsXHJcbiAgICAgICAgICAgIHJpZ2h0OiAxMixcclxuICAgICAgICAgICAgYm90dG9tOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcInRyYWNrLWJhY2tncm91bmRcIjoge1xyXG4gICAgICAgICAgICAuLi50cmFja0Jhc2UsXHJcbiAgICAgICAgICAgIHJpZ2h0OiAwLFxyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdsaWdodGdyYXknXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcInRyYWNrXCI6IHtcclxuICAgICAgICAgICAgLi4udHJhY2tCYXNlLFxyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGNvb2xCbHVlXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcInRyYWNrOjphZnRlclwiOiB7XHJcbiAgICAgICAgICAgIC4uLnRodW1iU2l6ZSxcclxuICAgICAgICAgICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxyXG4gICAgICAgICAgICB0b3A6ICc1MCUnLFxyXG4gICAgICAgICAgICByaWdodDogMCxcclxuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlKDUwJSwgLTUwJSknLFxyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICd3aGl0ZScsXHJcbiAgICAgICAgICAgIGJvcmRlcjogYDNweCBzb2xpZCAke2Nvb2xCbHVlfWAsXHJcbiAgICAgICAgICAgIGJvcmRlclJhZGl1czogJzUwJScsXHJcbiAgICAgICAgICAgIGNvbnRlbnQ6IFwiJydcIlxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJhcnJvd1wiOiB7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxyXG4gICAgICAgICAgICB0b3A6IDAsXHJcbiAgICAgICAgICAgIGJvdHRvbTogMCxcclxuICAgICAgICAgICAgd2lkdGg6IDMwLFxyXG4gICAgICAgICAgICBjb2xvcjogJ2JsYWNrJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJ3cmFwcGVyID4gJGlucHV0W3R5cGU9J3JhbmdlJ11cIjoge1xyXG4gICAgICAgICAgICBXZWJraXRBcHBlYXJhbmNlOiAnbm9uZScsXHJcbiAgICAgICAgICAgIHdpZHRoOiAnMTAwJScsXHJcbiAgICAgICAgICAgIGhlaWdodDogJzEwMCUnLFxyXG4gICAgICAgICAgICBsZWZ0OiAwLFxyXG4gICAgICAgICAgICByaWdodDogMCxcclxuICAgICAgICAgICAgbWFyZ2luOiAwLFxyXG4gICAgICAgICAgICB6SW5kZXg6ICcrMTAnLFxyXG4gICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcclxuICAgICAgICAgICAgb3BhY2l0eTogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJ3cmFwcGVyID4gJGlucHV0W3R5cGU9J3JhbmdlJ106Oi13ZWJraXQtc2xpZGVyLXRodW1iXCI6IHtcclxuICAgICAgICAgICAgLi4udGh1bWJTaXplLFxyXG4gICAgICAgICAgICBib3JkZXJSYWRpdXM6ICc1MCUnLFxyXG4gICAgICAgICAgICBXZWJraXRBcHBlYXJhbmNlOiAnbm9uZScsXHJcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ2dyZWVuJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJ3cmFwcGVyID4gJGlucHV0W3R5cGU9J3JhbmdlJ106Zm9jdXMgKyBmb2N1cy1iYWNrZ3JvdW5kXCI6IHtcclxuICAgICAgICAgICAgb3BhY2l0eTogMVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuKTtcclxuY29uc3QgUmFuZ2VJbnB1dCA9IHByb3BzID0+IHtcclxuICAgIGNvbnN0IHtcclxuICAgICAgICBtaW4gPSAwLFxyXG4gICAgICAgIG1heCA9IDEwLFxyXG4gICAgICAgIHN0ZXAgPSAxLFxyXG4gICAgICAgIG9uQ2hhbmdlID0gKCkgPT4ge30sXHJcbiAgICAgICAgZm9jdXNTdHlsZSA9IG51bGwsXHJcbiAgICAgICAgbGFiZWwsXHJcbiAgICAgICAgc2hvd0Fycm93cyA9IGZhbHNlXHJcbiAgICB9ID0gcHJvcHM7XHJcbiAgICBjb25zdCByYW5nZSA9IG1heCAtIG1pbjtcclxuICAgIGNvbnN0IGNoYW5nZUhhbmRsZXIgPSBldnQgPT4ge1xyXG4gICAgICAgIC8vIGV2dC50YXJnZXQuZm9jdXMoKTtcclxuICAgICAgICBvbkNoYW5nZShldnQudGFyZ2V0LnZhbHVlKTtcclxuICAgIH07XHJcbiAgICBsZXQge3ZhbHVlID0gbnVsbH0gPSBwcm9wcztcclxuICAgIGxldCBhZGp1c3RlZDtcclxuICAgIGxldCBpbnB1dE9mZnNldCA9IG51bGw7XHJcbiAgICBsZXQgdHJhY2tPZmZzZXQgPSBudWxsO1xyXG4gICAgbGV0IGFycm93cyA9IG51bGw7XHJcblxyXG4gICAgaWYgKHZhbHVlID09PSBudWxsKSB7XHJcbiAgICAgICAgdmFsdWUgPSBtaW47XHJcbiAgICB9XHJcblxyXG4gICAgYWRqdXN0ZWQgPSB2YWx1ZSAtIG1pbjtcclxuICAgIGlmIChhZGp1c3RlZCAlIHN0ZXAgIT09IDApIHtcclxuICAgICAgICBhZGp1c3RlZCAtPSBhZGp1c3RlZCAlIHN0ZXA7XHJcbiAgICB9XHJcbiAgICBhZGp1c3RlZCA9IGNsYW1wVmFsdWUoYWRqdXN0ZWQsIG1pbiwgbWF4KTtcclxuXHJcbiAgICBpZiAoc2hvd0Fycm93cyA9PT0gdHJ1ZSkge1xyXG4gICAgICAgIGNvbnN0IGFycm93Q2hhbmdlID0gYWRqdXN0ID0+XHJcbiAgICAgICAgICAgICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCBuZXdWYWx1ZSA9IHZhbHVlICsgYWRqdXN0O1xyXG4gICAgICAgICAgICAgICAgbmV3VmFsdWUgPSBNYXRoLm1heChuZXdWYWx1ZSwgbWluKTtcclxuICAgICAgICAgICAgICAgIG5ld1ZhbHVlID0gTWF0aC5taW4obmV3VmFsdWUsIG1heCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IG5ld1ZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2UobmV3VmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIGlucHV0T2Zmc2V0ID0ge2xlZnQ6IDMwLCB3aWR0aDogJ2NhbGMoMTAwJSAtIDYwcHgpJ307XHJcbiAgICAgICAgdHJhY2tPZmZzZXQgPSB7bGVmdDogNDIsIHJpZ2h0OiA0Mn07XHJcbiAgICAgICAgYXJyb3dzID0gW1xyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInJhbmdlLWlucHV0LWNvcmUtYXJyb3dcIiBzdHlsZT17e2xlZnQ6IDB9fSBrZXk9ezB9PlxyXG4gICAgICAgICAgICAgICAgPEJ1dHRvbiBpY29uTmFtZT1cImlvbi1hcnJvdy1sZWZ0LWJcIiBmbHVzaCBmaWxsIGljb25TaXplPXsyMH0gb25UYXA9e2Fycm93Q2hhbmdlKC0xKX0gLz5cclxuICAgICAgICAgICAgPC9kaXY+LFxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInJhbmdlLWlucHV0LWNvcmUtYXJyb3dcIiBzdHlsZT17e3JpZ2h0OiAwfX0ga2V5PXsxfT5cclxuICAgICAgICAgICAgICAgIDxCdXR0b24gaWNvbk5hbWU9XCJpb24tYXJyb3ctcmlnaHQtYlwiIGZsdXNoIGZpbGwgaWNvblNpemU9ezIwfSBvblRhcD17YXJyb3dDaGFuZ2UoMSl9IC8+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIF07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImlucHV0LWNvcmUtbGFiZWxcIj57bGFiZWx9PC9kaXY+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicmFuZ2UtaW5wdXQtY29yZS13cmFwcGVyXCI+XHJcbiAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cInJhbmdlXCIgc3R5bGU9e2lucHV0T2Zmc2V0fSBtaW49e21pbn0gbWF4PXttYXh9IHN0ZXA9e3N0ZXB9IHZhbHVlPXthZGp1c3RlZH0gb25DaGFuZ2U9e2NoYW5nZUhhbmRsZXJ9IG9uVG91Y2hTdGFydD17ZXZ0ID0+IGV2dC50YXJnZXQuZm9jdXMoKX0gLz5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicmFuZ2UtaW5wdXQtY29yZS1mb2N1cy1iYWNrZ3JvdW5kXCIgc3R5bGU9e2ZvY3VzU3R5bGV9IC8+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInJhbmdlLWlucHV0LWNvcmUtdHJhY2stY29udGFpbmVyXCIgc3R5bGU9e3RyYWNrT2Zmc2V0fT5cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInJhbmdlLWlucHV0LWNvcmUtdHJhY2stYmFja2dyb3VuZFwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJyYW5nZS1pbnB1dC1jb3JlLXRyYWNrXCIgc3R5bGU9e3t3aWR0aDogYCR7KGFkanVzdGVkIC8gcmFuZ2UpICogMTAwfSVgfX0gLz5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAge2Fycm93c31cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICApO1xyXG59O1xyXG5cclxuUmFuZ2VJbnB1dC52YWx1ZVByb3AgPSAndmFsdWUnO1xyXG5SYW5nZUlucHV0LnZhbHVlRnVuY3Rpb24gPSBuID0+IG47XHJcblJhbmdlSW5wdXQuZGVmYXVsdFByb3BWYWx1ZSA9IDA7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBSYW5nZUlucHV0O1xyXG4iLCJpbXBvcnQge2RlZmluZUNvbXBvbmVudFN0eWxlfSBmcm9tIFwibGliLXNvdXJjZS92Mi9zdHlsZVwiO1xyXG5pbXBvcnQgQnV0dG9uIGZyb20gJ2xpYi1zb3VyY2UvdWl2Mi9CdXR0b24nO1xyXG5pbXBvcnQgVGltZVNlbGVjdG9yIGZyb20gJ2xpYi1zb3VyY2UvdWl2Mi9UaW1lU2VsZWN0b3InO1xyXG5pbXBvcnQge3NoYXJlZFJlZmVyZW5jZSwgU2hhcmVkT2JqZWN0RGlzcGxheX0gZnJvbSBcImxpYi1zb3VyY2UvdjIvc2hhcmVkXCI7XHJcblxyXG5jbGFzcyBUaW1lSW5wdXQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xyXG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcclxuICAgICAgICBzdXBlcihwcm9wcyk7XHJcbiAgICB9XHJcblxyXG4gICAgc2VsZWN0ID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHtcclxuICAgICAgICAgICAgb25DaGFuZ2UgPSB3YXJuaW5nRnVuYyhcIm9uQ2hhbmdlIG5vdCBnaXZlbiB0byBUaW1lSW5wdXRcIiksXHJcbiAgICAgICAgICAgIHRpbWVGb3JtYXRcclxuICAgICAgICB9ID0gdGhpcy5wcm9wcztcclxuICAgICAgICBjb25zdCBjdXJyZW50RGF0ZSA9IHNoYXJlZFJlZmVyZW5jZSh0aGlzLnByb3BzLnZhbHVlKTtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBkaWFsb2cuc2hvdyh7XHJcbiAgICAgICAgICAgIC8vIGNvbnRlbnQ6IDxkaXYgc3R5bGU9e3twYWRkaW5nOiAzfX0+PFRpbWVTZWxlY3RvciB2YWx1ZT17Y3VycmVudERhdGV9IG9uQ2hhbmdlPXtkYXRlID0+IGN1cnJlbnREYXRlID0gZGF0ZX0gLz48L2Rpdj4sXHJcbiAgICAgICAgICAgIGNvbnRlbnQ6IDxTaGFyZWRPYmplY3REaXNwbGF5IGtleT17RGF0ZS5ub3coKX0gcmVmZXJlbmNlPXtjdXJyZW50RGF0ZX0gY29tcG9uZW50PXtUaW1lU2VsZWN0b3J9IHZhbHVlUHJvcD1cInZhbHVlXCIgZm9ybWF0PXt0aW1lRm9ybWF0fSAvPixcclxuICAgICAgICAgICAgYnV0dG9uczogW1xyXG4gICAgICAgICAgICAgICAge3RleHQ6IFwiQ2FuY2VsXCIsIGNhbmNlbHM6IHRydWV9LFxyXG4gICAgICAgICAgICAgICAge3RleHQ6IFwiU2V0XCIsIHZhbHVlOiAoKSA9PiBjdXJyZW50RGF0ZS52YWx1ZX1cclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gJ3N1Y2Nlc3MnKSB7XHJcbiAgICAgICAgICAgIG9uQ2hhbmdlKHJlc3VsdC52YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJlbmRlciA9ICgpID0+IHtcclxuICAgICAgICBjb25zdCB7Zm9ybWF0ID0gXCJ7aG91cn06e21pbnV0ZS9wYWRkZWR9XCIsIHZhbHVlLCAuLi5idXR0b25Qcm9wc30gPSB0aGlzLnByb3BzO1xyXG4gICAgICAgIHJldHVybiA8QnV0dG9uIHsuLi5idXR0b25Qcm9wc30gdGV4dD17dmFsdWUuZm9ybWF0KGZvcm1hdCl9IG9uVGFwPXt0aGlzLnNlbGVjdH0gYmxvY2sgLz47XHJcbiAgICB9XHJcbn1cclxuXHJcblRpbWVJbnB1dC52YWx1ZVByb3AgPSAndmFsdWUnO1xyXG5UaW1lSW5wdXQudmFsdWVGdW5jdGlvbiA9IGRhdGUgPT4gZGF0ZTtcclxuVGltZUlucHV0LmRlZmF1bHRQcm9wVmFsdWUgPSAoKSA9PiBjaHJvbm8oKTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFRpbWVJbnB1dDtcclxuIiwiaW1wb3J0IHtkZWZpbmVDb21wb25lbnRTdHlsZX0gZnJvbSBcImxpYi1zb3VyY2UvdjIvc3R5bGVcIjtcclxuaW1wb3J0IFRvdWNoYWJsZSBmcm9tIFwibGliLXNvdXJjZS91aXYyL1RvdWNoYWJsZVwiO1xyXG5cclxuY29uc3QgY29vbEJsdWUgPSBcIiMyRkIxREZcIjtcclxuXHJcbmRlZmluZUNvbXBvbmVudFN0eWxlKFxyXG4gICAgJ2ZsZXhib3gnLFxyXG4gICAgJ2NvcmUnLFxyXG4gICAge1xyXG4gICAgICAgIFwiY29udGFpbmVyXCI6IHtcclxuICAgICAgICAgICAgZGlzcGxheTogWyctd2Via2l0LWZsZXgnLCAnZmxleCddLFxyXG4gICAgICAgICAgICBXZWJraXRGbGV4V3JhcDogJ3dyYXAnLFxyXG4gICAgICAgICAgICBmbGV4V3JhcDogJ3dyYXAnLFxyXG4gICAgICAgICAgICAvLyBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcclxuICAgICAgICAgICAgLy8ganVzdGlmeUNvbnRlbnQ6ICdjZW50ZXInXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4pO1xyXG5jb25zdCBGbGV4Ym94ID0gcHJvcHMgPT4ge1xyXG4gICAgY29uc3Qge1xyXG4gICAgICAgIGNvbENvdW50LFxyXG4gICAgICAgIHdpZHRoID0gJzEwMCUnLFxyXG4gICAgICAgIHBhZEVuZCA9IGZhbHNlLFxyXG4gICAgICAgIG1pbkl0ZW1XaWR0aCA9IG51bGwsXHJcbiAgICAgICAgbWF4SXRlbVdpZHRoID0gbnVsbCxcclxuICAgICAgICBhbGlnbiA9ICdjZW50ZXInXHJcbiAgICB9ID0gcHJvcHM7XHJcbiAgICBjb25zdCBmbGV4V2lkdGggPSAxMDAgLyBjb2xDb3VudDtcclxuICAgIGxldCB7Y2hpbGRyZW59ID0gcHJvcHM7XHJcblxyXG4gICAgaWYgKGlzTmFOKGZsZXhXaWR0aCkgPT09IHRydWUgfHwgZmxleFdpZHRoIDw9IDApIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHdpZHRoIHByb3BlcnR5IGZvciBGbGV4Ym94XCIpO1xyXG4gICAgfVxyXG5cclxuICAgIGNoaWxkcmVuID0gUmVhY3QuQ2hpbGRyZW4udG9BcnJheShjaGlsZHJlbik7XHJcbiAgICBpZiAocGFkRW5kID09PSB0cnVlICYmIG1pbkl0ZW1XaWR0aCA9PT0gbnVsbCAmJiBtYXhJdGVtV2lkdGggPT09IG51bGwpIHtcclxuICAgICAgICBjb25zdCBmaWxsZXIgPSBuZXcgQXJyYXkoY29sQ291bnQgLSBjaGlsZHJlbi5sZW5ndGggJSBjb2xDb3VudClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmZpbGwobnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcCgoKSA9PiA8ZGl2IC8+KTtcclxuICAgICAgICBjaGlsZHJlbiA9IFsuLi5jaGlsZHJlbiwgLi4uZmlsbGVyXTtcclxuICAgIH1cclxuXHJcbiAgICBjaGlsZHJlbiA9IGNoaWxkcmVuLm1hcChcclxuICAgICAgICAoY2hpbGQsIGluZGV4KSA9PlxyXG4gICAgICAgICAgICA8RmxleGJveEl0ZW0ga2V5PXtpbmRleH0gd2lkdGg9e2ZsZXhXaWR0aH0gY29udGVudD17Y2hpbGR9IG1pbldpZHRoPXttaW5JdGVtV2lkdGh9IG1heFdpZHRoPXttYXhJdGVtV2lkdGh9IC8+XHJcbiAgICApXHJcblxyXG4gICAgLy8gY29uc29sZS50cmFjZSgpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPGRpdiBzdHlsZT17e3dpZHRoLCBqdXN0aWZ5Q29udGVudDogYWxpZ24sIFdlYmtpdEp1c3RpZnlDb250ZW50OiBhbGlnbn19IGNsYXNzTmFtZT1cImZsZXhib3gtY29yZS1jb250YWluZXJcIj5cclxuICAgICAgICAgICAge2NoaWxkcmVufVxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgKTtcclxufTtcclxuY29uc3QgRmxleGJveEl0ZW0gPSAoe2NvbnRlbnQsIHdpZHRoLCBtYXhXaWR0aCwgbWluV2lkdGh9KSA9PiB7XHJcbiAgICBjb25zdCBmbGV4Q1NTID0gYDEgMCAke3dpZHRofSVgO1xyXG4gICAgY29uc3QgaXRlbVN0eWxlID0ge1xyXG4gICAgICAgIFdlYmtpdEZsZXg6IGZsZXhDU1MsXHJcbiAgICAgICAgZmxleDogZmxleENTUyxcclxuICAgICAgICBtYXhXaWR0aCxcclxuICAgICAgICBtaW5XaWR0aFxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gPGRpdiBzdHlsZT17aXRlbVN0eWxlfT57Y29udGVudH08L2Rpdj47XHJcbn07XHJcblxyXG5kZWZpbmVDb21wb25lbnRTdHlsZShcclxuICAgIFwiZmxleGJveC1yYWRpb1wiLFxyXG4gICAgJ2NvcmUnLFxyXG4gICAge1xyXG4gICAgICAgICdpdGVtJzoge1xyXG4gICAgICAgICAgICB0cmFuc2l0aW9uOiAnYmFja2dyb3VuZC1jb2xvciA1MDBtcyBsaW5lYXInXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcIml0ZW06YWN0aXZlXCI6IHtcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSgwLCAwLCAwLCAwLjEpJyxcclxuICAgICAgICAgICAgdHJhbnNpdGlvbjogJ25vbmUnXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcIml0ZW1bZGF0YS1jaGVja2VkPSd0cnVlJ11cIjoge1xyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGNvb2xCbHVlLFxyXG4gICAgICAgICAgICBjb2xvcjogJ3doaXRlJyxcclxuICAgICAgICAgICAgdHJhbnNpdGlvbjogJ25vbmUnXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4pO1xyXG5GbGV4Ym94LlJhZGlvSXRlbSA9ICh7Y2hpbGRyZW4sIGNoZWNrZWQsIG9uVGFwfSkgPT4gKFxyXG4gICAgPFRvdWNoYWJsZSBjb21wb25lbnQ9XCJkaXZcIiBjbGFzc05hbWU9XCJmbGV4Ym94LXJhZGlvLWNvcmUtaXRlbVwiIGRhdGEtY2hlY2tlZD17Y2hlY2tlZH0gb25UYXA9e29uVGFwfT5cclxuICAgICAgICB7Y2hpbGRyZW59XHJcbiAgICA8L1RvdWNoYWJsZT5cclxuKTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IEZsZXhib3g7XHJcbiIsImltcG9ydCB7ZGVmaW5lQ29tcG9uZW50U3R5bGV9IGZyb20gXCJsaWItc291cmNlL3YyL3N0eWxlXCI7XHJcbmltcG9ydCBUb3VjaGFibGUgZnJvbSBcImxpYi1zb3VyY2UvdWl2Mi9Ub3VjaGFibGVcIjtcclxuXHJcbmNvbnN0IGNvb2xCbHVlID0gXCIjMkZCMURGXCI7XHJcblxyXG5kZWZpbmVDb21wb25lbnRTdHlsZShcclxuICAgICdncmlkJyxcclxuICAgICdjb3JlJyxcclxuICAgIHtcclxuICAgICAgICBcIml0ZW1cIjoge1xyXG4gICAgICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4pO1xyXG5cclxuY29uc3QgR3JpZCA9ICh7Y2hpbGRyZW4sIGNvbENvdW50LCByb3dDb3VudCwgd2lkdGggPSAnMTAwJScsIGhlaWdodCA9ICcxMDAlJ30pID0+IHtcclxuICAgIGlmIChoZWlnaHQgPT09IG51bGwpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJIZWlnaHQgbmVlZHMgdG8gYmUgZ2l2ZW4gdG8gdGhlIGdyaWRcIik7XHJcbiAgICB9XHJcbiAgICBjb25zdCBpdGVtV2lkdGggPSAxMDAgLyBjb2xDb3VudDtcclxuICAgIGNvbnN0IGl0ZW1IZWlnaHQgPSAxMDAgLyByb3dDb3VudDtcclxuICAgIGNvbnN0IGdyaWRTdHlsZSA9IHtcclxuICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcclxuICAgICAgICB3aWR0aCxcclxuICAgICAgICBoZWlnaHRcclxuICAgIH07XHJcblxyXG4gICAgY2hpbGRyZW4gPSBSZWFjdC5DaGlsZHJlbi50b0FycmF5KGNoaWxkcmVuKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxkaXYgc3R5bGU9e2dyaWRTdHlsZX0+XHJcbiAgICAgICAgICAgIHtjaGlsZHJlbi5tYXAoKGNoaWxkLCBpbmRleCkgPT4gPEdyaWRJdGVtIGtleT17aW5kZXh9IHdpZHRoPXtpdGVtV2lkdGh9IGhlaWdodD17aXRlbUhlaWdodH0geD17aW5kZXggJSBjb2xDb3VudH0geT17TWF0aC5mbG9vcihpbmRleCAvIGNvbENvdW50KX0gY29udGVudD17Y2hpbGR9IC8+KX1cclxuICAgICAgICA8L2Rpdj5cclxuICAgICk7XHJcbn07XHJcbmNvbnN0IEdyaWRJdGVtID0gKHt3aWR0aCwgaGVpZ2h0LCB4LCB5LCBjb250ZW50fSkgPT4ge1xyXG4gICAgY29uc3Qgc3R5bGUgPSB7XHJcbiAgICAgICAgd2lkdGg6IGAke3dpZHRofSVgLFxyXG4gICAgICAgIGhlaWdodDogYCR7aGVpZ2h0fSVgLFxyXG4gICAgICAgIGxlZnQ6IGAke3ggKiB3aWR0aH0lYCxcclxuICAgICAgICB0b3A6IGAke3kgKiBoZWlnaHR9JWBcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIDxkaXYgY2xhc3NOYW1lPVwiZ3JpZC1jb3JlLWl0ZW1cIiBzdHlsZT17c3R5bGV9Pntjb250ZW50fTwvZGl2PjtcclxufTtcclxuXHJcbmRlZmluZUNvbXBvbmVudFN0eWxlKFxyXG4gICAgXCJncmlkLXJhZGlvXCIsXHJcbiAgICAnY29yZScsXHJcbiAgICB7XHJcbiAgICAgICAgJ2l0ZW0nOiB7XHJcbiAgICAgICAgICAgIHdpZHRoOiAnMTAwJScsXHJcbiAgICAgICAgICAgIGhlaWdodDogJzEwMCUnLFxyXG4gICAgICAgICAgICB0cmFuc2l0aW9uOiAnYmFja2dyb3VuZC1jb2xvciA1MDBtcyBsaW5lYXInXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcIml0ZW06YWN0aXZlXCI6IHtcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSgwLCAwLCAwLCAwLjEpJyxcclxuICAgICAgICAgICAgdHJhbnNpdGlvbjogJ25vbmUnXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcIml0ZW1bZGF0YS1jaGVja2VkPSd0cnVlJ11cIjoge1xyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGNvb2xCbHVlLFxyXG4gICAgICAgICAgICBjb2xvcjogJ3doaXRlJyxcclxuICAgICAgICAgICAgdHJhbnNpdGlvbjogJ25vbmUnXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4pO1xyXG5HcmlkLlJhZGlvSXRlbSA9ICh7Y2hpbGRyZW4sIGNoZWNrZWQsIG9uVGFwfSkgPT4gKFxyXG4gICAgPFRvdWNoYWJsZSBjb21wb25lbnQ9XCJkaXZcIiBjbGFzc05hbWU9XCJncmlkLXJhZGlvLWNvcmUtaXRlbVwiIGRhdGEtY2hlY2tlZD17Y2hlY2tlZH0gb25UYXA9e29uVGFwfT5cclxuICAgICAgICB7Y2hpbGRyZW59XHJcbiAgICA8L1RvdWNoYWJsZT5cclxuKTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IEdyaWQ7XHJcbiIsImltcG9ydCB7ZGVmaW5lQ29tcG9uZW50U3R5bGV9IGZyb20gXCJsaWItc291cmNlL3YyL3N0eWxlXCI7XHJcbmltcG9ydCBUb3VjaGFibGUgZnJvbSBcImxpYi1zb3VyY2UvdWl2Mi9Ub3VjaGFibGVcIjtcclxuXHJcbmNvbnN0IGNvb2xCbHVlID0gXCIjMkZCMURGXCI7XHJcblxyXG5kZWZpbmVDb21wb25lbnRTdHlsZShcclxuICAgIFwicGluYm9hcmRcIixcclxuICAgICdjb3JlJyxcclxuICAgIHtcclxuICAgICAgICAnY29udGFpbmVyJzoge1xyXG4gICAgICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJ1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuKTtcclxuY29uc3QgUGluYm9hcmQgPSAoe2NoaWxkcmVuLCB3aWR0aCA9ICcxMDAlJywgaGVpZ2h0ID0gJzEwMCUnfSkgPT4ge1xyXG4gICAgY2hpbGRyZW4gPSBSZWFjdC5DaGlsZHJlbi50b0FycmF5KGNoaWxkcmVuKTtcclxuXHJcbiAgICBjaGlsZHJlbiA9IGNoaWxkcmVuLm1hcChcclxuICAgICAgICAoY2hpbGQsIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHtwaW5JbmZvLCAuLi5wcm9wc30gPSBjaGlsZC5wcm9wcztcclxuICAgICAgICAgICAgLy8gY29uc3Qge3Byb3BzOiB7cGluSW5mb319ID0gY2hpbGQ7XHJcbiAgICAgICAgICAgIGNvbnN0IGRpc3BsYXllZENoaWxkID0gPGNoaWxkLnR5cGUgey4uLnByb3BzfSAvPjtcclxuICAgICAgICAgICAgLy8gY2hpbGQgPSBSZWFjdC5jbG9uZVxyXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhjaGlsZC50eXBlKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiA8ZGl2IGtleT17aW5kZXh9IHN0eWxlPXt7Li4ucGluSW5mbywgcG9zaXRpb246ICdhYnNvbHV0ZSd9fT57ZGlzcGxheWVkQ2hpbGR9PC9kaXY+O1xyXG4gICAgICAgIH1cclxuICAgICk7XHJcblxyXG4gICAgcmV0dXJuIDxkaXYgc3R5bGU9e3twb3NpdGlvbjogJ3JlbGF0aXZlJywgd2lkdGgsIGhlaWdodH19PntjaGlsZHJlbn08L2Rpdj47XHJcbn07XHJcbmRlZmluZUNvbXBvbmVudFN0eWxlKFxyXG4gICAgXCJwaW5ib2FyZC1yYWRpb1wiLFxyXG4gICAgJ2NvcmUnLFxyXG4gICAge1xyXG4gICAgICAgICdpdGVtJzoge1xyXG4gICAgICAgICAgICB3aWR0aDogJzEwMCUnLFxyXG4gICAgICAgICAgICBoZWlnaHQ6ICcxMDAlJyxcclxuICAgICAgICAgICAgdHJhbnNpdGlvbjogJ2JhY2tncm91bmQtY29sb3IgNTAwbXMgbGluZWFyJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJpdGVtOmFjdGl2ZVwiOiB7XHJcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMCwgMCwgMCwgMC4xKScsXHJcbiAgICAgICAgICAgIHRyYW5zaXRpb246ICdub25lJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJpdGVtW2RhdGEtY2hlY2tlZD0ndHJ1ZSddXCI6IHtcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBjb29sQmx1ZSxcclxuICAgICAgICAgICAgY29sb3I6ICd3aGl0ZScsXHJcbiAgICAgICAgICAgIHRyYW5zaXRpb246ICdub25lJ1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuKTtcclxuUGluYm9hcmQuUmFkaW9JdGVtID0gKHtjaGlsZHJlbiwgY2hlY2tlZCwgb25UYXB9KSA9PiAoXHJcbiAgICA8VG91Y2hhYmxlIGNvbXBvbmVudD1cImRpdlwiIGNsYXNzTmFtZT1cInBpbmJvYXJkLXJhZGlvLWNvcmUtaXRlbVwiIGRhdGEtY2hlY2tlZD17Y2hlY2tlZH0gb25UYXA9e29uVGFwfT5cclxuICAgICAgICB7Y2hpbGRyZW59XHJcbiAgICA8L1RvdWNoYWJsZT5cclxuKTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFBpbmJvYXJkO1xyXG4iLCJpbXBvcnQge2RlZmluZUNvbXBvbmVudFN0eWxlfSBmcm9tIFwibGliLXNvdXJjZS92Mi9zdHlsZS5qc1wiO1xyXG5cclxuY29uc3QgYW5pbWF0aW9uRHVyYXRpb24gPSAzMDA7XHJcbmRlZmluZUNvbXBvbmVudFN0eWxlKFxyXG4gICAgJ3JpcHBsZScsXHJcbiAgICAnY29yZScsXHJcbiAgICB7XHJcbiAgICAgICAgXCJ3cmFwcGVyXCI6IHtcclxuICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXHJcbiAgICAgICAgICAgIHRvcDogMCxcclxuICAgICAgICAgICAgbGVmdDogMCxcclxuICAgICAgICAgICAgcmlnaHQ6IDAsXHJcbiAgICAgICAgICAgIGJvdHRvbTogMCxcclxuICAgICAgICAgICAgekluZGV4OiAnKzUnXHJcbiAgICAgICAgICAgIC8vIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJkb3RcIjoge1xyXG4gICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcclxuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlKC01MCUsIC01MCUpJyxcclxuICAgICAgICAgICAgYW5pbWF0aW9uOiBgcmlwcGxlLWNvcmUtYW5pbWF0aW9uLXJpcHBsZS1lZmZlY3QgJHthbmltYXRpb25EdXJhdGlvbn1tcyBsaW5lYXJgLFxyXG4gICAgICAgICAgICBib3JkZXJSYWRpdXM6ICc1MCUnLFxyXG4gICAgICAgICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcclxuICAgICAgICAgICAgd2lkdGg6ICcyNTAlJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJkb3Q6YmVmb3JlXCI6IHtcclxuICAgICAgICAgICAgcGFkZGluZ1RvcDogJzEwMCUnLFxyXG4gICAgICAgICAgICBjb250ZW50OiBgXCJcImAsXHJcbiAgICAgICAgICAgIGZsb2F0OiAnbGVmdCdcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiIXJpcHBsZS1lZmZlY3RcIjoge1xyXG4gICAgICAgICAgICBcIjAlXCI6IHtcclxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZSgtNTAlLCAtNTAlKSBzY2FsZSgwLCAwKScsXHJcbiAgICAgICAgICAgICAgICAvLyB3aWR0aDogMCxcclxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMCwgMCwgMCwgMCknXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIFwiNzAlXCI6IHtcclxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMCwgMCwgMCwgMC4xKSdcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXCIxMDAlXCI6IHtcclxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZSgtNTAlLCAtNTAlKSBzY2FsZSgxLCAxKScsXHJcbiAgICAgICAgICAgICAgICAvLyB3aWR0aDogJzE1MCUnLFxyXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSgwLCAwLCAwLCAwLjApJ1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4pO1xyXG5cclxuY2xhc3MgUmlwcGxlIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XHJcbiAgICAgICAgc3VwZXIocHJvcHMpO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSB7bGlzdDogW119O1xyXG4gICAgfVxyXG5cclxuICAgIHRvdWNoID0gKGV2dCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHtwb3NpdGlvbn0gPSBldnQudG91Y2g7XHJcbiAgICAgICAgY29uc3Qge3RvcCwgbGVmdH0gPSB0aGlzLnJlZnMud3JhcHBlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgICB0aGlzLnRyaWdnZXJSaXBwbGUocG9zaXRpb24ueCAtIGxlZnQsIHBvc2l0aW9uLnkgLSB0b3ApO1xyXG4gICAgfVxyXG4gICAgdHJpZ2dlclJpcHBsZSA9ICh4ID0gbnVsbCwgeSkgPT4ge1xyXG4gICAgICAgIGxldCB7bGlzdH0gPSB0aGlzLnN0YXRlO1xyXG5cclxuICAgICAgICBpZiAoeCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICBjb25zdCB7d2lkdGgsIGhlaWdodH0gPSB0aGlzLnJlZnMud3JhcHBlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgICAgICAgeCA9IHdpZHRoIC8gMjtcclxuICAgICAgICAgICAgeSA9IGhlaWdodCAvIDI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjaHJvbm8udHJpZ2dlcihcclxuICAgICAgICAgICAgYW5pbWF0aW9uRHVyYXRpb24sXHJcbiAgICAgICAgICAgICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmFjdGl2ZSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcclxuICAgICAgICAgICAgICAgICAgICBsaXN0OiB0aGlzLnN0YXRlLmxpc3Quc2xpY2UoMSlcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgKTtcclxuICAgICAgICBsaXN0ID0gWy4uLmxpc3QsIHt4LCB5LCBpZDogRGF0ZS5ub3coKX1dO1xyXG5cclxuICAgICAgICB0aGlzLnNldFN0YXRlKHtsaXN0fSk7XHJcbiAgICB9XHJcblxyXG4gICAgY29tcG9uZW50RGlkTW91bnQgPSAoKSA9PiB7XHJcbiAgICAgICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgY29tcG9uZW50V2lsbFVubW91bnQgPSAoKSA9PiB7XHJcbiAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZygncmVtb3ZpbmcnKTtcclxuICAgIH1cclxuXHJcbiAgICByZW5kZXIgPSAoKSA9PiB7XHJcbiAgICAgICAgY29uc3Qge2xpc3R9ID0gdGhpcy5zdGF0ZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPFVJLlRvdWNoYWJsZSBjb21wb25lbnQ9XCJkaXZcIiBjbGFzc05hbWU9XCJyaXBwbGUtY29yZS13cmFwcGVyXCIgb25UYXA9e3RoaXMudG91Y2h9IHJlZj1cIndyYXBwZXJcIj5cclxuICAgICAgICAgICAgICAgIHtsaXN0Lm1hcCgoe2lkLCB4LCB5fSkgPT4gPGRpdiBrZXk9e2lkfSBzdHlsZT17e3RvcDogeSwgbGVmdDogeH19IGNsYXNzTmFtZT1cInJpcHBsZS1jb3JlLWRvdFwiIC8+KX1cclxuICAgICAgICAgICAgPC9VSS5Ub3VjaGFibGU+XHJcbiAgICAgICAgKTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgUmlwcGxlO1xyXG4iLCJjb25zdCByZ2IgPSAociwgZywgYikgPT4gYHJnYmEoJHtyfSwgJHtnfSwgJHtifSlgO1xyXG5jb25zdCByZ2JhID0gKHIsIGcsIGIsIGEpID0+IGByZ2JhKCR7cn0sICR7Z30sICR7Yn0sICR7YX0pYDtcclxuXHJcbmNvbnN0IGhvdmVyQ29sb3IgPSByZ2JhKDAsIDAsIDAsIDAuMSk7XHJcbmNvbnN0IGFjdGl2ZUNvbG9yID0gcmdiYSgwLCAwLCAwLCAwLjIpO1xyXG5jb25zdCBzaGFkb3cgPSBudWxsO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgT2JqZWN0LmZyZWV6ZSh7XHJcbiAgICByZ2IsIHJnYmEsXHJcblxyXG4gICAgaG92ZXJDb2xvcixcclxuICAgIGFjdGl2ZUNvbG9yLFxyXG4gICAgc2hhZG93XHJcbn0pO1xyXG4iLCJjb25zdCBhamF4ID0gKHVybCwgb3B0aW9ucyA9IHt9KSA9PiBuZXcgUHJvbWlzZShcclxuICAgIChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICBjb25zdCB7XHJcbiAgICAgICAgICAgIGhlYWRlcnMgPSB7fSxcclxuICAgICAgICAgICAgdGltZW91dCA9IDAsXHJcbiAgICAgICAgICAgIHR5cGUgPSBudWxsLFxyXG4gICAgICAgICAgICBvblByb2dyZXNzID0gKCkgPT4ge30sXHJcbiAgICAgICAgICAgIHRva2VuID0gbnVsbFxyXG4gICAgICAgIH0gPSBvcHRpb25zO1xyXG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuICAgICAgICBsZXQge3Bvc3QgPSBudWxsfSA9IG9wdGlvbnM7XHJcblxyXG4gICAgICAgIGxldCBjb250ZW50VHlwZSA9IG51bGw7XHJcbiAgICAgICAgbGV0IG1ldGhvZDtcclxuXHJcbiAgICAgICAgaWYgKHRva2VuICE9PSBudWxsICYmIHRva2VuLnVzZWQgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIHRva2VuLmJpbmRUbyhyZXF1ZXN0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChwb3N0ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIG1ldGhvZCA9ICdHRVQnO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG1ldGhvZCA9IFwiUE9TVFwiO1xyXG4gICAgICAgICAgICBpZiAoRm9ybURhdGEucHJvdG90eXBlLmlzUHJvdG90eXBlT2YocG9zdCkgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICBkZWJ1Z2dlcjtcclxuICAgICAgICAgICAgICAgIHBvc3QgPSBKU09OLnN0cmluZ2lmeShwb3N0KTtcclxuICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlID0gXCJhcHBsaWNhdGlvbi9qc29uXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0eXBlICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gdHlwZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcihcclxuICAgICAgICAgICAgJ2xvYWQnLFxyXG4gICAgICAgICAgICAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPT09IDAgfHwgKHJlcXVlc3Quc3RhdHVzID49IDIwMCAmJiByZXF1ZXN0LnN0YXR1cyA8IDMwMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiByZXF1ZXN0LnN0YXR1cyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzVGV4dDogcmVxdWVzdC5zdGF0dXNUZXh0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZTogcmVxdWVzdC5yZXNwb25zZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZWplY3QocmVxdWVzdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICApO1xyXG4gICAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIHJlamVjdCk7XHJcbiAgICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKFwidGltZW91dFwiLCByZWplY3QpO1xyXG4gICAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsICgpID0+IHJlc29sdmUobnVsbCkpO1xyXG4gICAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcihcInByb2dyZXNzXCIsIG9uUHJvZ3Jlc3MpO1xyXG5cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICByZXF1ZXN0Lm9wZW4obWV0aG9kLCB1cmwsIHRydWUpO1xyXG4gICAgICAgICAgICByZXF1ZXN0LnRpbWVvdXQgPSB0aW1lb3V0O1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtoZWFkZXIsIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhoZWFkZXJzKSkge1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5zZXRSZXF1ZXN0SGVhZGVyKGhlYWRlciwgdmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcihcIkFjY2VwdFwiLCBcIlwiKTtcclxuICAgICAgICAgICAgcmVxdWVzdC5zZXRSZXF1ZXN0SGVhZGVyKFwiQWNjZXB0XCIsIFwiKi8qXCIpO1xyXG4gICAgICAgICAgICBpZiAoY29udGVudFR5cGUgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcihcIkNvbnRlbnQtVHlwZVwiLCBjb250ZW50VHlwZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVxdWVzdC5zZW5kKHBvc3QpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIHJlamVjdChlcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4pO1xyXG5hamF4LmNhbmNlbFRva2VuID0gKCkgPT4ge1xyXG4gICAgbGV0IHJlcXVlc3QgPSBudWxsO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgY2FuY2VsKCkge1xyXG4gICAgICAgICAgICBpZiAocmVxdWVzdCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5hYm9ydCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXQgdXNlZCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3QgIT09IG51bGw7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBiaW5kVG8ocmVxKSB7XHJcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0ID0gcmVxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGFqYXg7XHJcbiIsImltcG9ydCByZWdleCBmcm9tIFwieHJlZ2V4cFwiO1xyXG5cclxuY29uc3QgY2hyb25vU3BlY2lhbCA9IHtcclxuICAgICd5ZXN0ZXJkYXknKGRhdGUpIHtcclxuICAgICAgICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgLSAxKTtcclxuICAgICAgICByZXR1cm4gZGF0ZTtcclxuICAgIH0sXHJcbiAgICAnMSB3ZWVrIGFnbycoZGF0ZSkge1xyXG4gICAgICAgIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSAtIDcpO1xyXG4gICAgICAgIHJldHVybiBkYXRlO1xyXG4gICAgfVxyXG59O1xyXG5jb25zdCBjaHJvbm9Vbml0UmVnZXggPSByZWdleChcIig/PG9mZnNldD4oXFxcXCt8XFxcXC0pXFxcXGQrKSAoPzx1bml0PlxcXFx3KylcIik7XHJcbmNvbnN0IHVuaXRGdW5jdGlvbiA9IHtcclxuICAgIG1pbGxpc2Vjb25kKGRhdGUsIG1pbGxpc2Vjb25kcykge1xyXG4gICAgICAgIGRhdGUuc2V0TWlsbGlzZWNvbmRzKGRhdGUuZ2V0TWlsbGlzZWNvbmRzKCkgKyBtaWxsaXNlY29uZHMpO1xyXG4gICAgICAgIHJldHVybiBkYXRlO1xyXG4gICAgfSxcclxuICAgIHNlY29uZChkYXRlLCBzZWNvbmRzKSB7XHJcbiAgICAgICAgZGF0ZS5zZXRTZWNvbmRzKGRhdGUuZ2V0U2Vjb25kcygpICsgc2Vjb25kcyk7XHJcbiAgICAgICAgcmV0dXJuIGRhdGU7XHJcbiAgICB9LFxyXG4gICAgbWludXRlKGRhdGUsIG1pbnV0ZXMpIHtcclxuICAgICAgICBkYXRlLnNldE1pbnV0ZXMoZGF0ZS5nZXRNaW51dGVzKCkgKyBtaW51dGVzKTtcclxuICAgICAgICByZXR1cm4gZGF0ZTtcclxuICAgIH0sXHJcbiAgICBob3VyKGRhdGUsIGhvdXJzKSB7XHJcbiAgICAgICAgZGF0ZS5zZXRIb3VycyhkYXRlLmdldEhvdXJzKCkgKyBob3Vycyk7XHJcbiAgICAgICAgcmV0dXJuIGRhdGU7XHJcbiAgICB9LFxyXG4gICAgZGF5KGRhdGUsIGRheXMpIHtcclxuICAgICAgICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgKyBkYXlzKTtcclxuICAgICAgICByZXR1cm4gZGF0ZTtcclxuICAgIH0sXHJcbiAgICB3ZWVrKGRhdGUsIHdlZWtzKSB7XHJcbiAgICAgICAgZGF0ZS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpICsgd2Vla3MgKiA3KTtcclxuICAgICAgICByZXR1cm4gZGF0ZTtcclxuICAgIH0sXHJcbiAgICBtb250aChkYXRlLCBtb250aHMpIHtcclxuICAgICAgICBjb25zdCBleHBlY3RlZCA9IGRhdGUuZ2V0TW9udGgoKSArIG1vbnRocztcclxuICAgICAgICBkYXRlLnNldE1vbnRoKGV4cGVjdGVkKTtcclxuICAgICAgICBpZiAoZGF0ZS5nZXRNb250aCgpICE9PSBleHBlY3RlZCkge1xyXG4gICAgICAgICAgICBkYXRlLnNldERhdGUoMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkYXRlO1xyXG4gICAgfSxcclxuICAgIHllYXIoZGF0ZSwgeWVhcnMpIHtcclxuICAgICAgICBkYXRlLnNldEZ1bGxZZWFyKGRhdGUuZ2V0RnVsbFllYXIoKSArIHllYXJzKTtcclxuICAgICAgICByZXR1cm4gZGF0ZTtcclxuICAgIH0sXHJcbiAgICBkZWNhZGUoZGF0ZSwgZGVjYWRlcykge1xyXG4gICAgICAgIGRhdGUuc2V0RnVsbFllYXIoZGF0ZS5nZXRGdWxsWWVhcigpICsgZGVjYWRlcyAqIDEwKTtcclxuICAgICAgICByZXR1cm4gZGF0ZTtcclxuICAgIH1cclxufTtcclxuY29uc3Qgc3RhcnRPZiA9IHtcclxuICAgIHNlY29uZChkYXRlKSB7XHJcbiAgICAgICAgZGF0ZS5zZXRNaWxsaXNlY29uZHMoMCk7XHJcbiAgICB9LFxyXG4gICAgbWludXRlKGRhdGUpIHtcclxuICAgICAgICBzdGFydE9mLnNlY29uZChkYXRlKTtcclxuICAgICAgICBkYXRlLnNldFNlY29uZHMoMCk7XHJcbiAgICB9LFxyXG4gICAgaG91cihkYXRlKSB7XHJcbiAgICAgICAgc3RhcnRPZi5taW51dGUoZGF0ZSk7XHJcbiAgICAgICAgZGF0ZS5zZXRNaW51dGVzKDApO1xyXG4gICAgfSxcclxuICAgIGRheShkYXRlKSB7XHJcbiAgICAgICAgc3RhcnRPZi5ob3VyKGRhdGUpO1xyXG4gICAgICAgIGRhdGUuc2V0SG91cnMoMCk7XHJcbiAgICB9LFxyXG4gICAgd2VlayhkYXRlKSB7XHJcbiAgICAgICAgc3RhcnRPZi5kYXkoZGF0ZSk7XHJcbiAgICAgICAgZGF0ZS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpIC0gZGF0ZS5nZXREYXkoKSk7XHJcbiAgICB9LFxyXG4gICAgbW9udGgoZGF0ZSkge1xyXG4gICAgICAgIHN0YXJ0T2YuZGF5KGRhdGUpO1xyXG4gICAgICAgIGRhdGUuc2V0RGF0ZSgxKTtcclxuICAgIH0sXHJcbiAgICB5ZWFyKGRhdGUpIHtcclxuICAgICAgICBzdGFydE9mLm1vbnRoKGRhdGUpO1xyXG4gICAgICAgIGRhdGUuc2V0TW9udGgoMCk7XHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IGVuZE9mID0ge1xyXG4gICAgc2Vjb25kKGRhdGUpIHtcclxuICAgICAgICBkYXRlLnNldE1pbGxpc2Vjb25kcyg5OTkpO1xyXG4gICAgfSxcclxuICAgIG1pbnV0ZShkYXRlKSB7XHJcbiAgICAgICAgZW5kT2Yuc2Vjb25kKGRhdGUpO1xyXG4gICAgICAgIGRhdGUuc2V0U2Vjb25kcyg1OSk7XHJcbiAgICB9LFxyXG4gICAgaG91cihkYXRlKSB7XHJcbiAgICAgICAgZW5kT2YubWludXRlKGRhdGUpO1xyXG4gICAgICAgIGRhdGUuc2V0TWludXRlcyg1OSk7XHJcbiAgICB9LFxyXG4gICAgZGF5KGRhdGUpIHtcclxuICAgICAgICBlbmRPZi5ob3VyKGRhdGUpO1xyXG4gICAgICAgIGRhdGUuc2V0SG91cnMoMjMpO1xyXG4gICAgfSxcclxuICAgIHdlZWsoZGF0ZSkge1xyXG4gICAgICAgIGVuZE9mLmRheShkYXRlKTtcclxuICAgICAgICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgKyAoNiAtIGRhdGUuZ2V0RGF5KCkpKTtcclxuICAgIH0sXHJcbiAgICBtb250aChkYXRlKSB7XHJcbiAgICAgICAgZW5kT2YuZGF5KGRhdGUpO1xyXG4gICAgICAgIGRhdGUuc2V0TW9udGgoZGF0ZS5nZXRNb250aCgpICsgMSk7XHJcbiAgICAgICAgZGF0ZS5zZXREYXRlKDApO1xyXG4gICAgfSxcclxuICAgIHllYXIoZGF0ZSkge1xyXG4gICAgICAgIGVuZE9mLm1vbnRoKGRhdGUpO1xyXG4gICAgICAgIGRhdGUuc2V0TW9udGgoMTEpO1xyXG4gICAgfVxyXG59O1xyXG5jb25zdCB1bml0Q29udmVyc2lvbiA9IHtcclxuICAgICdtaWxsaXNlY29uZCc6ICdtaWxsaXNlY29uZCcsXHJcbiAgICAnbWlsbGlzZWNvbmRzJzogJ21pbGxpc2Vjb25kJyxcclxuICAgICdtcyc6ICdtaWxsaXNlY29uZCcsXHJcblxyXG4gICAgJ3NlY29uZCc6ICdzZWNvbmQnLFxyXG4gICAgJ3NlY29uZHMnOiAnc2Vjb25kJyxcclxuICAgICdzJzogJ3NlY29uZCcsXHJcblxyXG4gICAgJ21pbnV0ZSc6ICdtaW51dGUnLFxyXG4gICAgJ21pbnV0ZXMnOiAnbWludXRlJyxcclxuICAgICdtaW4nOiAnbWludXRlJyxcclxuXHJcbiAgICAnaG91cic6ICdob3VyJyxcclxuICAgICdob3Vycyc6ICdob3VyJyxcclxuICAgICdocic6ICdob3VyJyxcclxuXHJcbiAgICAnZGF5JzogJ2RheScsXHJcbiAgICAnZGF5cyc6ICdkYXknLFxyXG4gICAgJ25pJzogJ2RheScsXHJcbiAgICAnaGknOiAnZGF5JyxcclxuICAgICfml6UnOiAnZGF5JyxcclxuXHJcbiAgICAnd2Vlayc6ICd3ZWVrJyxcclxuICAgICd3ZWVrcyc6ICd3ZWVrJyxcclxuICAgICdzaHV1JzogJ3dlZWsnLFxyXG4gICAgJ+OBl+OCheOBhic6ICd3ZWVrJyxcclxuICAgICfpgLEnOiAnd2VlaycsXHJcblxyXG4gICAgJ21vbnRoJzogJ21vbnRoJyxcclxuICAgICdtb250aHMnOiAnbW9udGgnLFxyXG5cclxuICAgICd5ZWFyJzogJ3llYXInLFxyXG4gICAgJ3llYXJzJzogJ3llYXInLFxyXG5cclxuICAgICdkZWNhZGUnOiAnZGVjYWRlJyxcclxuICAgICdkZWNhZGVzJzogJ2RlY2FkZSdcclxufTtcclxuY29uc3QgY2hyb25vSW5mbyA9IHtcclxuICAgIGRheXM6IFtcclxuICAgICAgICAnU3VuZGF5JyxcclxuICAgICAgICAnTW9uZGF5JyxcclxuICAgICAgICAnVHVlc2RheScsXHJcbiAgICAgICAgJ1dlZG5lc2RheScsXHJcbiAgICAgICAgJ1RodXJzZGF5JyxcclxuICAgICAgICAnRnJpZGF5JyxcclxuICAgICAgICAnU2F0dXJkYXknXHJcbiAgICBdLFxyXG4gICAgbW9udGhzOiBbXHJcbiAgICAgICAgJ0phbnVhcnknLFxyXG4gICAgICAgICdGZWJydWFyeScsXHJcbiAgICAgICAgJ01hcmNoJyxcclxuICAgICAgICAnQXByaWwnLFxyXG4gICAgICAgICdNYXknLFxyXG4gICAgICAgICdKdW5lJyxcclxuICAgICAgICAnSnVseScsXHJcbiAgICAgICAgJ0F1Z3VzdCcsXHJcbiAgICAgICAgJ1NlcHRlbWJlcicsXHJcbiAgICAgICAgJ09jdG9iZXInLFxyXG4gICAgICAgICdOb3ZlbWJlcicsXHJcbiAgICAgICAgJ0RlY2VtYmVyJ1xyXG4gICAgXVxyXG59O1xyXG5jb25zdCBjaHJvbm9Gb3JtYXQgPSB7XHJcbiAgICBtczoge1xyXG4gICAgICAgIGJhc2U6IGRhdGUgPT4gZGF0ZS5nZXRNaWxsaXNlY29uZHMoKSxcclxuICAgICAgICBwYWRkZWQ6IGRhdGUgPT4gYDAwJHtkYXRlLmdldE1pbGxpc2Vjb25kcygpfWAuc2xpY2UoLTMpXHJcbiAgICB9LFxyXG4gICAgc2Vjb25kOiB7XHJcbiAgICAgICAgYmFzZTogZGF0ZSA9PiBkYXRlLmdldFNlY29uZHMoKSxcclxuICAgICAgICBwYWRkZWQ6IGRhdGUgPT4gYDAke2RhdGUuZ2V0U2Vjb25kcygpfWAuc2xpY2UoLTIpXHJcbiAgICB9LFxyXG4gICAgbWludXRlOiB7XHJcbiAgICAgICAgYmFzZTogZGF0ZSA9PiBkYXRlLmdldE1pbnV0ZXMoKSxcclxuICAgICAgICBwYWRkZWQ6IGRhdGUgPT4gYDAke2RhdGUuZ2V0TWludXRlcygpfWAuc2xpY2UoLTIpXHJcbiAgICB9LFxyXG4gICAgaG91cjoge1xyXG4gICAgICAgIGJhc2U6IGRhdGUgPT4gZGF0ZS5nZXRIb3VycygpLFxyXG4gICAgICAgIHBhZGRlZDogZGF0ZSA9PiBgMCR7ZGF0ZS5nZXRIb3VycygpfWAuc2xpY2UoLTIpLFxyXG4gICAgICAgIFwiMTJcIjogZGF0ZSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGhvdXIgPSBkYXRlLmdldEhvdXJzKCkgJSAxMjtcclxuICAgICAgICAgICAgaWYgKGhvdXIgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAxMjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gaG91clxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCIxMnBhZGRlZFwiOiBkYXRlID0+IGAwJHtjaHJvbm9Gb3JtYXQuaG91clsnMTInXShkYXRlKX1gLnNsaWNlKC0yKVxyXG4gICAgfSxcclxuICAgIHdlZWtkYXk6IHtcclxuICAgICAgICBiYXNlOiBkYXRlID0+IGRhdGUuZ2V0RGF5KCksXHJcbiAgICAgICAgc2hvcnQ6IGRhdGUgPT4gY2hyb25vSW5mby5kYXlzW2RhdGUuZ2V0RGF5KCldLnNsaWNlKDAsIDMpLFxyXG4gICAgICAgIGZ1bGw6IGRhdGUgPT4gY2hyb25vSW5mby5kYXlzW2RhdGUuZ2V0RGF5KCldXHJcbiAgICB9LFxyXG4gICAgZGF0ZToge1xyXG4gICAgICAgIGJhc2U6IGRhdGUgPT4gZGF0ZS5nZXREYXRlKCksXHJcbiAgICAgICAgcGFkZGVkOiBkYXRlID0+IGAwJHtkYXRlLmdldERhdGUoKX1gLnNsaWNlKC0yKVxyXG4gICAgfSxcclxuICAgIG1vbnRoOiB7XHJcbiAgICAgICAgYmFzZTogZGF0ZSA9PiBkYXRlLmdldE1vbnRoKCkgKyAxLFxyXG4gICAgICAgIHNob3J0OiBkYXRlID0+IGNocm9ub0luZm8ubW9udGhzW2RhdGUuZ2V0RGF0ZSgpXS5zbGljZSgwLCAzKSxcclxuICAgICAgICBmdWxsOiBkYXRlID0+IGNocm9ub0luZm8ubW9udGhzW2RhdGUuZ2V0RGF0ZSgpXVxyXG4gICAgfSxcclxuICAgIHllYXI6IHtcclxuICAgICAgICBiYXNlOiBkYXRlID0+IGRhdGUuZ2V0RnVsbFllYXIoKSAlIDEwMCxcclxuICAgICAgICBmdWxsOiBkYXRlID0+IGRhdGUuZ2V0RnVsbFllYXIoKVxyXG4gICAgfSxcclxuICAgIHRvZDoge1xyXG4gICAgICAgIGJhc2U6IGRhdGUgPT4gKGRhdGUuZ2V0SG91cnMoKSA8IDEyID09PSB0cnVlKSA/IFwiQU1cIiA6IFwiUE1cIlxyXG4gICAgfVxyXG59O1xyXG5jaHJvbm9Gb3JtYXQuZGF5ID0gY2hyb25vRm9ybWF0LmRhdGU7XHJcbmNvbnN0IGNocm9ub0NoZWNrVW5pdCA9IHVuaXQgPT4ge1xyXG4gICAgaWYgKHVuaXRDb252ZXJzaW9uLmhhc093blByb3BlcnR5KHVuaXQpID09PSBmYWxzZSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5yZWNvZ25pemVkIHVuaXQ6ICR7dW5pdH1gKTtcclxuICAgIH1cclxufTtcclxuXHJcbi8qIC1BeGVsRG9jLVxyXG5tb2R1bGUgZ2xvYmFsIHtcclxuICAgIEBmdW5jdGlvbiBjaHJvbm8ge1xyXG4gICAgICAgIEBkZXNjIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2Yge2Nocm9ub30uXHJcbiAgICAgICAgQGFyZ3Mge1xyXG4gICAgICAgICAgICBAYXJnIGRhdGVUaW1lIFtEYXRlXVxyXG4gICAgICAgICAgICAgICAgVGhpcyBpcyBzb21lIGxvbmcgZGVzY3JpcHRpb24gb2YgdGhlIHRoaW5nXHJcbiAgICAgICAgICAgICAgICB7eWVhciwgbW9udGh9IGRlc3RydWN0dXJpbmc/XHJcbiAgICAgICAgICAgICAgICBbdGl0bGVdeWVhclt0aXRsZV1cclxuICAgICAgICB9XHJcbiAgICAgICAgQHJldHVybiBjaHJvbm9cclxuXHJcbiAgICAgICAgQGZ1bmN0aW9uIGRpZmYge1xyXG4gICAgICAgICAgICBAZGVzYyBBIGZ1bmN0aW9uIHRoYXQgd2lsbCBjYWxjdWxhdGUgdGhlIGFtb3VudCBvZiB0aW1lIHRvIGFkZCB0byB0aGUgZmlyc3QgYXJndW1lbnQgaW4gb3JkZXIgdG8gZ2V0IHRoZSBzZWNvbmQgYXJndW1lbnQuXHJcbiAgICAgICAgICAgIEBhcmdzIHtcclxuICAgICAgICAgICAgICAgIEBhcmcgc3RhcnREYXRlIFtjaHJvbm9dIFRoZSBkYXRlIHRvIHN0YXJ0IGZyb20uXHJcbiAgICAgICAgICAgICAgICBAYXJnIHRhcmdldERhdGUgW2Nocm9ub10gVGhlIGRhdGUgdG8gZ2V0IHRvLlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIEByZXR1cm4gb2JqZWN0XHJcbiAgICAgICAgfVxyXG4gICAgICAgIEBmdW5jdGlvbiBub3cge1xyXG4gICAgICAgICAgICBAZGVzYyBSZXR1cm5zIHRoZSBjdXJyZW50IGRhdGUgYXMgYSBjaHJvbm8gb2JqZWN0LlxyXG4gICAgICAgICAgICBAYXJncyB7fVxyXG4gICAgICAgICAgICBAcmV0dXJuIGNocm9ub1xyXG4gICAgICAgIH1cclxuICAgICAgICBAZnVuY3Rpb24gcGFyc2Uge1xyXG4gICAgICAgICAgICBAZGVzYyBQYXJzZXMgYSBkYXRlIHN0cmluZyBhbmQgcmV0dXJucyB0aGUgY2hyb25vIG9iamVjdCByZXByZXNlbnRlZCBieSBpdC5cclxuICAgICAgICAgICAgQGFyZ3Mge1xyXG4gICAgICAgICAgICAgICAgQGFyZyBkYXRlU3RyaW5nIFtzdHJpbmddIFRoZSBzdHJpbmcgdG8gcGFyc2UuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgQHJldHVybiBjaHJvbm9cclxuICAgICAgICB9XHJcbiAgICAgICAgQGZ1bmN0aW9uIHBhcnNlTVMge1xyXG4gICAgICAgICAgICBAZGVzYyBQYXJzZXMgYSBkYXRlIHN0cmluZyBnZW5lcmF0ZWQgYnkgQyMgY29kZSBhbmQgcmV0dXJucyB0aGUgY2hyb25vIG9iamVjdCByZXByZXNlbnRlZCBieSBpdC5cclxuICAgICAgICAgICAgQGFyZ3Mge1xyXG4gICAgICAgICAgICAgICAgQGFyZyBkYXRlU3RyaW5nIFtzdHJpbmddIFRoZSBzdHJpbmcgdG8gcGFyc2UuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgQHJldHVybiBjaHJvbm9cclxuICAgICAgICB9XHJcbiAgICAgICAgQGZ1bmN0aW9uIHRyaWdnZXIge1xyXG4gICAgICAgICAgICBAZGVzYyBGaXJlcyBhIGZ1bmN0aW9uIGFmdGVyIGEgc3BlY2lmaWVkIHRpbWUuXHJcbiAgICAgICAgICAgIEBhcmdzIHtcclxuICAgICAgICAgICAgICAgIEBhcmcgZGVsYXkgW251bWJlcl0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gd2FpdC5cclxuICAgICAgICAgICAgICAgIEBhcmcgZnVuYyBbZnVuY3Rpb25dIFRoZSBmdW5jdGlvbiB0byBjYWxsLlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIEByZXR1cm4gY2hyb25vVHJpZ2dlclxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBvYmplY3QgY2hyb25vIHtcclxuICAgICAgICBAcHJvcCBkYXRlT2JqZWN0IHtcclxuICAgICAgICAgICAgQGRlc2MgR2V0cyBhIGNvcHkgb2YgdGhlIGludGVybmFsIERhdGUgb2JqZWN0LlxyXG4gICAgICAgICAgICBAdHlwZSBEYXRlXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBAcHJvcCB1bml4VGltZXN0YW1wIHtcclxuICAgICAgICAgICAgQGRlc2MgR2V0cyB0aGUgdW5peCB0aW1lc3RhbXAgb2YgdGhlIGNocm9ubyBvYmplY3QuXHJcbiAgICAgICAgICAgIEB0eXBlIG51bWJlclxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgQHByb3AgbWlsbGlzZWNvbmRzIHtcclxuICAgICAgICAgICAgQGRlc2MgR2V0cyB0aGUgbWlsbGlzZWNvbmRzIG9mIHRoZSBjaHJvbm8gb2JqZWN0LlxyXG4gICAgICAgICAgICBAdHlwZSBudW1iZXJcclxuICAgICAgICB9XHJcbiAgICAgICAgQHByb3Agc2Vjb25kcyB7XHJcbiAgICAgICAgICAgIEBkZXNjIEdldHMgdGhlIHNlY29uZHMgb2YgdGhlIGNocm9ubyBvYmplY3QuXHJcbiAgICAgICAgICAgIEB0eXBlIG51bWJlclxyXG4gICAgICAgIH1cclxuICAgICAgICBAcHJvcCBtaW51dGVzIHtcclxuICAgICAgICAgICAgQGRlc2MgR2V0cyB0aGUgbWludXRlcyBvZiB0aGUgY2hyb25vIG9iamVjdC5cclxuICAgICAgICAgICAgQHR5cGUgbnVtYmVyXHJcbiAgICAgICAgfVxyXG4gICAgICAgIEBwcm9wIGhvdXJzIHtcclxuICAgICAgICAgICAgQGRlc2MgR2V0cyB0aGUgaG91cnMgb2YgdGhlIGNocm9ubyBvYmplY3QuXHJcbiAgICAgICAgICAgIEB0eXBlIG51bWJlclxyXG4gICAgICAgIH1cclxuICAgICAgICBAcHJvcCB3ZWVrZGF5IHtcclxuICAgICAgICAgICAgQGRlc2MgR2V0cyB0aGUgd2Vla2RheSBvZiB0aGUgY2hyb25vIG9iamVjdC5cclxuICAgICAgICAgICAgQHR5cGUgbnVtYmVyXHJcbiAgICAgICAgfVxyXG4gICAgICAgIEBwcm9wIGRhdGUge1xyXG4gICAgICAgICAgICBAZGVzYyBHZXRzIHRoZSBkYXRlIG9mIHRoZSBjaHJvbm8gb2JqZWN0LiBUaGlzIG51bWJlciBpcyBhZGp1c3RlZCB0byB0aGUgcmFuZ2UgKDAtMzApIHVubGlrZSB0aGUgbm9ybWFsIERhdGUgb2JqZWN0LlxyXG4gICAgICAgICAgICBAdHlwZSBudW1iZXJcclxuICAgICAgICB9XHJcbiAgICAgICAgQHByb3AgbW9udGhzIHtcclxuICAgICAgICAgICAgQGRlc2MgR2V0cyB0aGUgbW9udGhzIG9mIHRoZSBjaHJvbm8gb2JqZWN0LlxyXG4gICAgICAgICAgICBAdHlwZSBudW1iZXJcclxuICAgICAgICB9XHJcbiAgICAgICAgQHByb3AgeWVhciB7XHJcbiAgICAgICAgICAgIEBkZXNjIEdldHMgdGhlIHllYXIgb2YgdGhlIGNocm9ubyBvYmplY3QuXHJcbiAgICAgICAgICAgIEB0eXBlIG51bWJlclxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgQGZ1bmN0aW9uIHNoaWZ0IHtcclxuICAgICAgICAgICAgQGRlc2MgU2hpZnRzIHRoZSBkYXRlIGZvcndhcmQgb3IgYmFja3dhcmQgaW4gdGltZS5cclxuICAgICAgICAgICAgQGFyZ3Mge1xyXG4gICAgICAgICAgICAgICAgQGFyZyBvZmZzZXQgW051bWJlcl0gVGhlIGFtb3VudCBvZiB0aW1lIHRvIHNoaWZ0IHRoZSBkYXRlLlxyXG4gICAgICAgICAgICAgICAgQGFyZyB1bml0IFtTdHJpbmddIFRoZSB1bml0cyB0byBzaGlmdCBieS4gVmFsaWQgdmFsdWVzIGFyZTogJ3NlY29uZCcsICdtaW51dGUnLCAnaG91cicsICdkYXknLCAnd2VlaycsICdtb250aCcsICd5ZWFyJywgJ2RlY2FkZScuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgQGFyZ3Mge1xyXG4gICAgICAgICAgICAgICAgQGFyZyBkdXJhdGlvbiBbb2JqZWN0XSBBbiBvYmplY3QgdGhhdCB3aWxsIHNoaWZ0IHRoZSBkYXRlLlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIEByZXR1cm4gY2hyb25vXHJcbiAgICAgICAgfVxyXG4gICAgICAgIEBmdW5jdGlvbiBzdGFydE9mIHtcclxuICAgICAgICAgICAgQGRlc2MgTW92ZXMgdGhlIGRhdGUgdG8gdGhlIHN0YXJ0IG9mIHRoZSBzcGVjaWZpZWQgdW5pdC5cclxuICAgICAgICAgICAgQGFyZ3Mge1xyXG4gICAgICAgICAgICAgICAgQGFyZyB1bml0IFtzdHJpbmddIFRoZSB1bml0IHRvIG1vdmUgdG8gdGhlIHN0YXJ0IG9mLiBWYWxpZCB2YWx1ZXMgYXJlOiAnc2Vjb25kJywgJ21pbnV0ZScsICdob3VyJywgJ2RheScsICd3ZWVrJywgJ21vbnRoJywgJ3llYXInLlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIEByZXR1cm4gY2hyb25vXHJcbiAgICAgICAgfVxyXG4gICAgICAgIEBmdW5jdGlvbiBmb3JtYXQge1xyXG4gICAgICAgICAgICBAZGVzYyBGb3JtYXRzIHRoZSBjaHJvbm8gb2JqZWN0IHVzaW5nIHRoZSBzcGVjaWZpZWQgc3RyaW5nLlxyXG4gICAgICAgICAgICBAYXJncyB7XHJcbiAgICAgICAgICAgICAgICBAYXJnIGZvcm1hdCBbc3RyaW5nXSBUaGUgc3RyaW5nIGRlc2NyaWJpbmcgdGhlIGZvcm1hdCB0aGUgZGF0ZSBzaG91bGQgYmUgcHV0IGludG8uXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgQHJldHVybiBzdHJpbmdcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgb2JqZWN0IGNocm9ub1RyaWdnZXIge1xyXG4gICAgICAgIEBwcm9wIHN0YXR1cyB7XHJcbiAgICAgICAgICAgIEBkZXNjIFRoZSBzdGF0dXMgb2YgdGhlIHRyaWdnZXIuXHJcbiAgICAgICAgICAgIEB0eXBlIHN0cmluZ1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgQGZ1bmN0aW9uIGNhbmNlbCB7XHJcbiAgICAgICAgICAgIEBkZXNjIENhbmNlbHMgdGhlIHRyaWdnZXIgaWYgaXQgaGFzbid0IGZpcmVkIHlldC5cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuKi9cclxuY29uc3QgY2hyb25vID0gKGFyZyA9IG51bGwpID0+IHtcclxuICAgIGNvbnN0IGludGVybmFsRGF0ZSA9ICgoKSA9PiB7XHJcbiAgICAgICAgaWYgKGFyZyA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChEYXRlLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGFyZykgPT09IHRydWUgfHwgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoYXJnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChhcmcuX19jaHJvbm8gPT09IHRydWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFyZy5kYXRlT2JqZWN0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIGFyZyA9IGFyZy50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICBpZiAoY2hyb25vU3BlY2lhbC5oYXNPd25Qcm9wZXJ0eShhcmcpID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hyb25vU3BlY2lhbFthcmddKG5ldyBEYXRlKCkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjb25zdCBtYXRjaCA9IHJlZ2V4LmV4ZWMoYXJnLCBjaHJvbm9Vbml0UmVnZXgpO1xyXG4gICAgICAgICAgICBpZiAobWF0Y2ggIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHtvZmZzZXQsIHVuaXR9ID0gbWF0Y2g7XHJcblxyXG4gICAgICAgICAgICAgICAgY2hyb25vQ2hlY2tVbml0KHVuaXQpO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiB1bml0RnVuY3Rpb25bdW5pdENvbnZlcnNpb25bdW5pdF1dKG5ldyBEYXRlKCksIHBhcnNlSW50KG9mZnNldCkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoYXJnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHt5ZWFyID0gMTk3MCwgbW9udGggPSAwLCBkYXRlID0gMCwgaG91cnMgPSAwLCBtaW51dGVzID0gMCwgc2Vjb25kcyA9IDAsIG1pbGxpc2Vjb25kcyA9IDB9ID0gYXJnO1xyXG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSh5ZWFyLCBtb250aCwgZGF0ZSArIDEsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMpO1xyXG4gICAgfSkoKTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIF9fY2hyb25vOiB0cnVlLFxyXG4gICAgICAgIGdldCBkYXRlT2JqZWN0KCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoaW50ZXJuYWxEYXRlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldCB1bml4VGltZXN0YW1wKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxEYXRlLmdldFRpbWUoKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBnZXQgbWlsbGlzZWNvbmRzKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxEYXRlLmdldE1pbGxpc2Vjb25kcygpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0IHNlY29uZHMoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbERhdGUuZ2V0U2Vjb25kcygpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0IG1pbnV0ZXMoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbERhdGUuZ2V0TWludXRlcygpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0IGhvdXJzKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxEYXRlLmdldEhvdXJzKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXQgd2Vla2RheSgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGludGVybmFsRGF0ZS5nZXREYXkoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldCBkYXRlKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxEYXRlLmdldERhdGUoKSAtIDE7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXQgbW9udGgoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbERhdGUuZ2V0TW9udGgoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldCB5ZWFyKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxEYXRlLmdldEZ1bGxZZWFyKCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0KHByb3BzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHtcclxuICAgICAgICAgICAgICAgIHllYXIgPSBpbnRlcm5hbERhdGUuZ2V0RnVsbFllYXIoKSxcclxuICAgICAgICAgICAgICAgIG1vbnRoID0gaW50ZXJuYWxEYXRlLmdldE1vbnRoKCksXHJcbiAgICAgICAgICAgICAgICBkYXRlID0gaW50ZXJuYWxEYXRlLmdldERhdGUoKSAtIDEsXHJcbiAgICAgICAgICAgICAgICBob3VycyA9IGludGVybmFsRGF0ZS5nZXRIb3VycygpLFxyXG4gICAgICAgICAgICAgICAgbWludXRlcyA9IGludGVybmFsRGF0ZS5nZXRNaW51dGVzKCksXHJcbiAgICAgICAgICAgICAgICBzZWNvbmRzID0gaW50ZXJuYWxEYXRlLmdldFNlY29uZHMoKSxcclxuICAgICAgICAgICAgICAgIG1pbGxpc2Vjb25kcyA9IGludGVybmFsRGF0ZS5nZXRNaWxsaXNlY29uZHMoKVxyXG4gICAgICAgICAgICB9ID0gcHJvcHM7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gY2hyb25vKG5ldyBEYXRlKHllYXIsIG1vbnRoLCBkYXRlICsgMSwgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcykpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2hpZnQob2Zmc2V0LCB1bml0KSB7XHJcbiAgICAgICAgICAgIGxldCBuZXdEYXRlO1xyXG4gICAgICAgICAgICBuZXdEYXRlID0gbmV3IERhdGUoaW50ZXJuYWxEYXRlKTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgLy8gaWYgKG9mZnNldC5oYXNPd25Qcm9wZXJ0eSgnX19jaHJvbm9fZHVyYXRpb24nKSAmJiBvZmZzZXQuX19jaHJvbm9fZHVyYXRpb24gPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgIC8vICAgICBvZmZzZXQgPSBvZmZzZXQuYXNPYmplY3QoKTtcclxuICAgICAgICAgICAgICAgIC8vIH1cclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFt1bml0LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMob2Zmc2V0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNocm9ub0NoZWNrVW5pdCh1bml0KTtcclxuICAgICAgICAgICAgICAgICAgICBuZXdEYXRlID0gdW5pdEZ1bmN0aW9uW3VuaXRDb252ZXJzaW9uW3VuaXRdXShuZXdEYXRlLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNocm9ubyhuZXdEYXRlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gcmVnZXguZXhlYyhvZmZzZXQsIGNocm9ub1VuaXRSZWdleCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICh7b2Zmc2V0LCB1bml0fSA9IG1hdGNoKTtcclxuICAgICAgICAgICAgICAgICAgICBjaHJvbm9DaGVja1VuaXQodW5pdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gcGFyc2VJbnQob2Zmc2V0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hyb25vKHVuaXRGdW5jdGlvblt1bml0Q29udmVyc2lvblt1bml0XV0obmV3RGF0ZSwgb2Zmc2V0KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHN0YXJ0T2YodW5pdCkge1xyXG4gICAgICAgICAgICBjb25zdCBhZGp1c3RlZERhdGUgPSBuZXcgRGF0ZShpbnRlcm5hbERhdGUpO1xyXG5cclxuICAgICAgICAgICAgc3RhcnRPZlt1bml0XShhZGp1c3RlZERhdGUpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGNocm9ubyhhZGp1c3RlZERhdGUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW5kT2YodW5pdCkge1xyXG4gICAgICAgICAgICBjb25zdCBhZGp1c3RlZERhdGUgPSBuZXcgRGF0ZShpbnRlcm5hbERhdGUpO1xyXG5cclxuICAgICAgICAgICAgZW5kT2ZbdW5pdF0oYWRqdXN0ZWREYXRlKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBjaHJvbm8oYWRqdXN0ZWREYXRlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGZvcm1hdChmb3JtYXRTdHJpbmcgPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmIChmb3JtYXRTdHJpbmcgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbERhdGUudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGZvcm1hdFN0cmluZyA9PT0gJ3V0YycpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbERhdGUudG9VVENTdHJpbmcoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZm9ybWF0U3RyaW5nID09PSAnbG9jYWxlJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFsRGF0ZS50b0xvY2FsZVN0cmluZygpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0U3RyaW5nLnJlcGxhY2UoXHJcbiAgICAgICAgICAgICAgICAvXFx7KFxcdyspKFxcLyhcXHcrKSk/XFx9L2csXHJcbiAgICAgICAgICAgICAgICAoZnVsbCwgcHJvcCwgc2tpcCwgdHlwZSA9ICdiYXNlJykgPT4gY2hyb25vRm9ybWF0W3Byb3BdW3R5cGVdKGludGVybmFsRGF0ZSlcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxEYXRlLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB0b0pTT04oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbERhdGUudG9KU09OKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufTtcclxuY2hyb25vLmRpZmYgPSAoZmlyc3QsIHNlY29uZCkgPT4ge1xyXG4gICAgY29uc3QgaW50ZXJuYWxEYXRlID0gbmV3IERhdGUoc2Vjb25kLnVuaXhUaW1lc3RhbXAgLSBmaXJzdC51bml4VGltZXN0YW1wKTtcclxuICAgIGNvbnNvbGUubG9nKHNlY29uZC51bml4VGltZXN0YW1wIC0gZmlyc3QudW5peFRpbWVzdGFtcCk7XHJcbiAgICBjb25zb2xlLmxvZyhpbnRlcm5hbERhdGUpO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbWlsbGlzZWNvbmRzOiBpbnRlcm5hbERhdGUuZ2V0TWlsbGlzZWNvbmRzKCksXHJcbiAgICAgICAgc2Vjb25kczogaW50ZXJuYWxEYXRlLmdldFNlY29uZHMoKSxcclxuICAgICAgICBtaW51dGVzOiBpbnRlcm5hbERhdGUuZ2V0TWludXRlcygpLFxyXG4gICAgICAgIGhvdXJzOiBpbnRlcm5hbERhdGUuZ2V0SG91cnMoKSxcclxuICAgICAgICBkYXlzOiBpbnRlcm5hbERhdGUuZ2V0RGF0ZSgpIC0gMSxcclxuICAgICAgICBtb250aHM6IGludGVybmFsRGF0ZS5nZXRNb250aCgpLFxyXG4gICAgICAgIHllYXJzOiBpbnRlcm5hbERhdGUuZ2V0RnVsbFllYXIoKSAtIDE5NzBcclxuICAgIH07XHJcbn07XHJcbmNocm9uby5ub3cgPSAoKSA9PiBjaHJvbm8oRGF0ZS5ub3coKSk7XHJcbmNocm9uby5wYXJzZSA9IHN0cmluZyA9PiBjaHJvbm8oRGF0ZS5wYXJzZShzdHJpbmcpKTtcclxuY2hyb25vLnBhcnNlTVMgPSBzdHJpbmcgPT4gY2hyb25vKERhdGUucGFyc2Uoc3RyaW5nLnJlcGxhY2UoXCJUXCIsIFwiIFwiKSkpO1xyXG5jaHJvbm8udHJpZ2dlciA9IChkZWxheSwgZnVuYywgLi4uYXJncykgPT4ge1xyXG4gICAgY29uc3QgaWQgPSBzZXRUaW1lb3V0KFxyXG4gICAgICAgICgpID0+IHtcclxuICAgICAgICAgICAgc3RhdHVzID0gJ2ZpcmVkJztcclxuICAgICAgICAgICAgZnVuYyguLi5hcmdzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRlbGF5XHJcbiAgICApO1xyXG4gICAgbGV0IHN0YXR1cztcclxuXHJcbiAgICBzdGF0dXMgPSAnd2FpdGluZyc7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBjYW5jZWwoKSB7XHJcbiAgICAgICAgICAgIHN0YXR1cyA9ICdjYW5jZWxsZWQnO1xyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoaWQpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0IHN0YXR1cygpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN0YXR1cztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59O1xyXG5jaHJvbm8ud2FpdCA9IHdhaXQgPT4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KCgpID0+IHJlc29sdmUobnVsbCksIHdhaXQpKTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNocm9ubztcclxuIiwiaW1wb3J0IGNyeXB0byBmcm9tIFwiY3J5cHRvXCI7XHJcblxyXG5sZXQgZW5jcnlwdDtcclxubGV0IGRlY3J5cHQ7XHJcbmxldCBoYXNoO1xyXG5cclxuZW5jcnlwdCA9IChzdHIsIGtleSwge2l2ID0gbnVsbCwgYWxnb3JpdGhtID0gJ2FlczI1NicsIG91dHB1dCA9ICdoZXgnLCBpbnB1dCA9ICd1dGY4J30gPSB7fSkgPT4ge1xyXG4gICAgbGV0IGVuY3J5cHRvcjtcclxuICAgIGxldCByZXN1bHQ7XHJcblxyXG4gICAga2V5ID0gbmV3IEJ1ZmZlcihrZXkpO1xyXG5cclxuICAgIGlmIChpdiA9PT0gbnVsbCkge1xyXG4gICAgICAgIGVuY3J5cHRvciA9IGNyeXB0by5jcmVhdGVDaXBoZXIoYWxnb3JpdGhtLCBrZXkpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBpdiA9IG5ldyBCdWZmZXIoaXYpO1xyXG4gICAgICAgIGVuY3J5cHRvciA9IGNyeXB0by5jcmVhdGVDaXBoZXIoYWxnb3JpdGhtLCBrZXksIGl2KTtcclxuICAgIH1cclxuXHJcbiAgICByZXN1bHQgPSBlbmNyeXB0b3IudXBkYXRlKHN0ciwgaW5wdXQsIG91dHB1dCk7XHJcbiAgICByZXN1bHQgKz0gZW5jcnlwdG9yLmZpbmFsKG91dHB1dCk7XHJcbiAgICBlbmNyeXB0b3IgPSBudWxsO1xyXG4gICAgc3RyID0gbnVsbDtcclxuICAgIGtleS5maWxsKDApO1xyXG5cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG5kZWNyeXB0ID0gKHN0ciwga2V5LCB7aXYgPSBudWxsLCBhbGdvcml0aG0gPSAnYWVzMjU2JywgaW5wdXQgPSAnaGV4Jywgb3V0cHV0ID0gJ3V0ZjgnfSA9IHt9KSA9PiB7XHJcbiAgICBsZXQgZGVjcnlwdG9yO1xyXG4gICAgbGV0IHJlc3VsdDtcclxuXHJcbiAgICBrZXkgPSBuZXcgQnVmZmVyKGtleSk7XHJcblxyXG4gICAgaWYgKGl2ID09PSBudWxsKSB7XHJcbiAgICAgICAgZGVjcnlwdG9yID0gY3J5cHRvLmNyZWF0ZURlY2lwaGVyKGFsZ29yaXRobSwga2V5KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaXYgPSBuZXcgQnVmZmVyKGl2KTtcclxuICAgICAgICBkZWNyeXB0b3IgPSBjcnlwdG8uY3JlYXRlRGVjaXBoZXIoYWxnb3JpdGhtLCBrZXksIGl2KTtcclxuICAgIH1cclxuXHJcbiAgICByZXN1bHQgPSBkZWNyeXB0b3IudXBkYXRlKHN0ciwgaW5wdXQsIG91dHB1dCk7XHJcbiAgICByZXN1bHQgKz0gZGVjcnlwdG9yLmZpbmFsKG91dHB1dCk7XHJcbiAgICBkZWNyeXB0b3IgPSBudWxsO1xyXG4gICAgc3RyID0gbnVsbDtcclxuICAgIGtleS5maWxsKDApO1xyXG5cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG5oYXNoID0gKHN0ciwgYWxnb3JpdGhtID0gJ3NoYTUxMicpID0+IHtcclxuICAgIGxldCBoYXNoZXI7XHJcblxyXG4gICAgaGFzaGVyID0gY3J5cHRvLmNyZWF0ZUhhc2goYWxnb3JpdGhtKTtcclxuICAgIGhhc2hlci51cGRhdGUoc3RyLCAndXRmOCcpO1xyXG4gICAgc3RyID0gbnVsbDtcclxuXHJcbiAgICByZXR1cm4gaGFzaGVyLmRpZ2VzdCgnaGV4Jyk7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgICBlbmNyeXB0LFxyXG4gICAgZGVjcnlwdCxcclxuICAgIGhhc2hcclxufTtcclxuIiwiY29uc3Qgc2hhcmVkUmVmZXJlbmNlID0gdmFsdWUgPT4gKHtcclxuICAgIGdldCB2YWx1ZSgpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9LFxyXG4gICAgc2V0KG5ld1ZhbHVlKSB7XHJcbiAgICAgICAgdmFsdWUgPSBuZXdWYWx1ZTtcclxuICAgIH1cclxufSk7XHJcbmNsYXNzIFNoYXJlZE9iamVjdERpc3BsYXkgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xyXG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcclxuICAgICAgICBzdXBlcihwcm9wcyk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHt2YWx1ZTogdGhpcy5wcm9wcy5yZWZlcmVuY2UudmFsdWV9O1xyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZSA9ICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgIHRoaXMucHJvcHMucmVmZXJlbmNlLnNldCh2YWx1ZSk7XHJcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7dmFsdWV9KTtcclxuICAgIH1cclxuXHJcbiAgICByZW5kZXIgPSAoKSA9PiB7XHJcbiAgICAgICAgY29uc3Qge2NvbXBvbmVudDogQ29tcG9uZW50LCByZWZlcmVuY2UsIHZhbHVlUHJvcCwgY29udGFpbmVyU3R5bGUsIC4uLnByb3BzfSA9IHRoaXMucHJvcHM7XHJcbiAgICAgICAgY29uc3Qge3ZhbHVlfSA9IHRoaXMuc3RhdGU7XHJcblxyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIDxkaXYgc3R5bGU9e2NvbnRhaW5lclN0eWxlfT5cclxuICAgICAgICAgICAgICAgIDxDb21wb25lbnQgey4uLnByb3BzfSB7Li4ue1t2YWx1ZVByb3BdOiB2YWx1ZX19IG9uQ2hhbmdlPXt0aGlzLnVwZGF0ZX0gLz5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgKTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IHtcclxuICAgIHNoYXJlZFJlZmVyZW5jZSxcclxuICAgIFNoYXJlZE9iamVjdERpc3BsYXlcclxufTtcclxuIiwiY29uc3QgY3NzTm9NZWFzdXJlbWVudCA9IG5ldyBTZXQoW1xyXG4gICAgXCJhbmltYXRpb25JdGVyYXRpb25Db3VudFwiLFxyXG4gICAgXCJib3hGbGV4XCIsXHJcbiAgICBcImJveEZsZXhHcm91cFwiLFxyXG4gICAgXCJib3hPcmRpbmFsR3JvdXBcIixcclxuICAgIFwiY29sdW1uQ291bnRcIixcclxuICAgIFwiZmlsbE9wYWNpdHlcIixcclxuICAgIFwiZmxleFwiLFxyXG4gICAgXCJmbGV4R3Jvd1wiLFxyXG4gICAgXCJmbGV4UG9zaXRpdmVcIixcclxuICAgIFwiZmxleFNocmlua1wiLFxyXG4gICAgXCJmbGV4TmVnYXRpdmVcIixcclxuICAgIFwiZmxleE9yZGVyXCIsXHJcbiAgICBcImZvbnRXZWlnaHRcIixcclxuICAgIFwibGluZUNsYW1wXCIsXHJcbiAgICBcImxpbmVIZWlnaHRcIixcclxuICAgIFwib3BhY2l0eVwiLFxyXG4gICAgXCJvcmRlclwiLFxyXG4gICAgXCJvcnBoYW5zXCIsXHJcbiAgICBcInN0b3BPcGFjaXR5XCIsXHJcbiAgICBcInN0cm9rZURhc2hvZmZzZXRcIixcclxuICAgIFwic3Ryb2tlT3BhY2l0eVwiLFxyXG4gICAgXCJzdHJva2VXaWR0aFwiLFxyXG4gICAgXCJ0YWJTaXplXCIsXHJcbiAgICBcIndpZG93c1wiLFxyXG4gICAgXCJ6SW5kZXhcIixcclxuICAgIFwiem9vbVwiXHJcbl0pO1xyXG5jb25zdCBjc3NQcmVmaXhOYW1lcyA9IG5ldyBTZXQoW1xyXG4gICAgJ3RyYW5zZm9ybScsXHJcbiAgICAnYm94LXNoYWRvdycsXHJcbiAgICAndHJhbnNpdGlvbicsXHJcbiAgICAnYW5pbWF0aW9uJyxcclxuICAgICdhbmltYXRpb25EZWxheScsXHJcbiAgICAnYW5pbWF0aW9uRGlyZWN0aW9uJyxcclxuICAgICdhbmltYXRpb25EdXJhdGlvbicsXHJcbiAgICAnYW5pbWF0aW9uRmlsbE1vZGUnLFxyXG4gICAgJ2FuaW1hdGlvbkl0ZXJhdGlvbkNvdW50JyxcclxuICAgICdhbmltYXRpb25OYW1lJyxcclxuICAgICdhbmltYXRpb25QbGF5U3RhdGUnLFxyXG4gICAgJ2FuaW1hdGlvblRpbWluZ0Z1bmN0aW9uJ1xyXG5dKTtcclxuY29uc3QgY3NzUHJlZml4ZXMgPSBbJy13ZWJraXQtJywgJy1tb3otJywgJy1tcy0nLCAnLW8tJywgJyddO1xyXG5cclxuY29uc3QgZ2V0Q1NTVmFsdWUgPSAocHJvcCwgdmFsdWUpID0+IHtcclxuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIHZhbHVlID0gdmFsdWUoKTtcclxuICAgIH1cclxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZS5tYXAodmFsdWUgPT4gZ2V0Q1NTVmFsdWUocHJvcCwgdmFsdWUpWzBdKTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGNzc05vTWVhc3VyZW1lbnQuaGFzKHByb3ApID09PSBmYWxzZSkge1xyXG4gICAgICAgIHZhbHVlICs9IFwicHhcIjtcclxuICAgIH1cclxuICAgIHJldHVybiBbdmFsdWVdO1xyXG59O1xyXG5jb25zdCBwcm9jZXNzU2VsZWN0b3IgPSAoY29tcG9uZW50TmFtZSwgc3R5bGVOYW1lLCBzZWxlY3RvcikgPT4ge1xyXG4gICAgY29uc3QgcGFydHMgPSBzZWxlY3Rvci5zcGxpdCgvXFxzKy8pO1xyXG4gICAgY29uc3QgcmVhbFBhcnRzID0gcGFydHMubWFwKHBhcnQgPT4ge1xyXG4gICAgICAgIHBhcnQgPSBwYXJ0LnJlcGxhY2UoXCI6YWN0aXZlXCIsIFwiLmNvci10b3VjaC1hY3RpdmVcIik7XHJcbiAgICAgICAgcmV0dXJuIHBhcnQuc3BsaXQoJy8nKS5tYXAocGFydCA9PiB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAodHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBwYXJ0LmNoYXJBdCgwKSA9PT0gXCIkXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnQuc2xpY2UoMSk7XHJcbiAgICAgICAgICAgICAgICBjYXNlIC9eW2Etel0vaS50ZXN0KHBhcnQpID09PSB0cnVlOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBgLiR7Y29tcG9uZW50TmFtZX0tJHtzdHlsZU5hbWV9LSR7cGFydH1gO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFydDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pLmpvaW4oJycpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcmVhbFBhcnRzLmpvaW4oJyAnKTtcclxufTtcclxuY29uc3QgcHJvY2Vzc0RlZiA9IChjc3NMaW5lcywgc2VsZWN0b3IsIGRlZnMpID0+IHtcclxuICAgIGNzc0xpbmVzID0gWy4uLmNzc0xpbmVzLCBgJHtzZWxlY3Rvcn0ge2BdO1xyXG4gICAgZm9yIChjb25zdCBbY3NzUHJvcCwgY3NzVmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGRlZnMpKSB7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSBnZXRDU1NWYWx1ZShjc3NQcm9wLCBjc3NWYWx1ZSk7XHJcbiAgICAgICAgY29uc3QgcHJvcCA9IGNzc1Byb3AucmVwbGFjZSgvW0EtWl0vZywgbGV0dGVyID0+ICctJyArIGxldHRlci50b0xvd2VyQ2FzZSgpKTtcclxuICAgICAgICBpZiAodmFsdWUgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKGNzc1ByZWZpeE5hbWVzLmhhcyhjc3NQcm9wKSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgY3NzTGluZXMgPSBbXHJcbiAgICAgICAgICAgICAgICAgICAgLi4uY3NzTGluZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgLi4uY3NzUHJlZml4ZXMubWFwKHByZWZpeCA9PiBgXFx0JHtwcmVmaXh9JHtwcm9wfTogJHt2YWx1ZVswXX07YClcclxuICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjc3NMaW5lcyA9IFtcclxuICAgICAgICAgICAgICAgICAgICAuLi5jc3NMaW5lcyxcclxuICAgICAgICAgICAgICAgICAgICAuLi52YWx1ZS5tYXAodmFsdWUgPT4gYFxcdCR7cHJvcH06ICR7dmFsdWV9O2ApXHJcbiAgICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY3NzTGluZXMgPSBbLi4uY3NzTGluZXMsIFwifVwiXTtcclxuICAgIHJldHVybiBjc3NMaW5lcztcclxuICAgIC8vIGNzc0xpbmVzLnB1c2goXCJ9XCIpO1xyXG59O1xyXG5cclxuY29uc3QgY29tcG9uZW50U3R5bGVzID0ge307XHJcbmNvbnN0IGNyZWF0ZVByb3AgPSAob2JqZWN0LCBwcm9wTmFtZSwgZGVmYXVsdFZhbHVlKSA9PiB7XHJcbiAgICBpZiAob2JqZWN0Lmhhc093blByb3BlcnR5KHByb3BOYW1lKSA9PT0gZmFsc2UpIHtcclxuICAgICAgICBvYmplY3RbcHJvcE5hbWVdID0gZGVmYXVsdFZhbHVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG9iamVjdFtwcm9wTmFtZV07XHJcbn07XHJcbmNvbnN0IGRlZmluZUNvbXBvbmVudFN0eWxlID0gKGNvbXBvbmVudCwgc3R5bGVOYW1lLCBzdHlsZXMpID0+XHJcbiAgICBjcmVhdGVQcm9wKFxyXG4gICAgICAgIGNyZWF0ZVByb3AoY29tcG9uZW50U3R5bGVzLCBjb21wb25lbnQsIHt9KSxcclxuICAgICAgICBzdHlsZU5hbWUsXHJcbiAgICAgICAgc3R5bGVzXHJcbiAgICApO1xyXG5jb25zdCBiYXNlU3R5bGVzID0ge307XHJcbmNvbnN0IGRlZmluZUN1c3RvbUJhc2UgPSAoY29tcG9uZW50LCBiYXNlRnVuYykgPT4ge1xyXG4gICAgaWYgKHR5cGVvZiBjb21wb25lbnQgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgY29tcG9uZW50ID0gY29tcG9uZW50LmNvbXBvbmVudE5hbWU7XHJcbiAgICB9XHJcbiAgICBiYXNlU3R5bGVzW2NvbXBvbmVudF0gPSBiYXNlRnVuYztcclxufTtcclxuY29uc3QgcHJvcFN0eWxlTmFtZSA9IG5hbWUgPT4gbmFtZS5yZXBsYWNlKC8oXlxcdyl8XFwtXFx3L2csIHMgPT4gcy5zbGljZSgtMSkudG9VcHBlckNhc2UoKSk7XHJcbmNvbnN0IGRlZmluZVN0eWxlRm9yQ29tcG9uZW50ID0gKGNvbXBvbmVudCwgc3R5bGVOYW1lLCBvcHRpb25zKSA9PiB7XHJcbiAgICBjb25zdCBDb21wb25lbnQgPSBjb21wb25lbnQ7XHJcbiAgICBjb25zdCBzdHlsZURlZiA9IGJhc2VTdHlsZXNbY29tcG9uZW50LmNvbXBvbmVudE5hbWVdKG9wdGlvbnMpO1xyXG4gICAgbGV0IHN0eWxlZENvbXBvbmVudCA9IG51bGw7XHJcblxyXG4gICAgaWYgKHN0eWxlRGVmID09PSBudWxsIHx8IHN0eWxlRGVmID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHN0eWxlRGVmICE9PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIGNvbnNvbGUud2FybihgSW1wcm9wZXIgdHlwZSByZXR1cm5lZCBmcm9tIHN0eWxlIGZ1bmN0aW9uIGZvciAke2NvbXBvbmVudC5jb21wb25lbnROYW1lfToke3N0eWxlTmFtZX0uIERpZCB5b3UgZm9yZ2V0IHRvIHJldHVybiB0aGUgY29uc3RydWN0ZWQgc3R5bGU/YCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGRlZmluZUNvbXBvbmVudFN0eWxlKGNvbXBvbmVudC5jb21wb25lbnROYW1lLCBzdHlsZU5hbWUsIHN0eWxlRGVmKTtcclxuICAgIH1cclxuXHJcbiAgICBzdHlsZWRDb21wb25lbnQgPSBwcm9wcyA9PiA8Q29tcG9uZW50IHsuLi5wcm9wc30gc3R5bGVOYW1lPXtzdHlsZU5hbWV9IC8+O1xyXG4gICAgc3R5bGVkQ29tcG9uZW50LnBhcmVudEluZm8gPSBjb21wb25lbnQ7XHJcbiAgICBjb21wb25lbnRbcHJvcFN0eWxlTmFtZShzdHlsZU5hbWUpXSA9IHN0eWxlZENvbXBvbmVudDtcclxufTtcclxuXHJcbmNvbnN0IGNyZWF0ZVN0eWxlcyA9ICgpID0+IHtcclxuICAgIGNvbnN0IGhlYWQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiaGVhZFwiKTtcclxuXHJcbiAgICAvLyAgSXRlcmF0ZSBvdmVyIHRoZSBjb21wb25lbnRzIHRoYXQgaGF2ZSBzdHlsZXMgZGVmaW5lZFxyXG4gICAgZm9yIChjb25zdCBbY29tcG9uZW50TmFtZSwgc3R5bGVzXSBvZiBPYmplY3QuZW50cmllcyhjb21wb25lbnRTdHlsZXMpKSB7XHJcbiAgICAgICAgLy8gIEl0ZXJhdGUgb3ZlciB0aGUgdmFyaW91cyBuYW1lZCBzdHlsZXMgZm9yIHRoZSBnaXZlbiBjb21wb25lbnRcclxuICAgICAgICBmb3IgKGNvbnN0IFtzdHlsZU5hbWUsIHN0eWxlRGVmc10gb2YgT2JqZWN0LmVudHJpZXMoc3R5bGVzKSkge1xyXG4gICAgICAgICAgICBsZXQgY3NzTGluZXMgPSBbXTtcclxuICAgICAgICAgICAgLy8gIEdyYWIgYWxsIHRoZSBpbmRpdmlkdWFsIGdyb3VwcyBvZiBzdHlsZXMgZGVmaW5lZCBpbiB0aGUgbmFtZWQgc3R5bGVcclxuICAgICAgICAgICAgZm9yIChjb25zdCBbZGVzY3JpcHRvciwgZGVmc10gb2YgT2JqZWN0LmVudHJpZXMoc3R5bGVEZWZzKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGRlc2NyaXB0b3Iuc3RhcnRzV2l0aChcIiFcIikgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyAgUmVwZWF0IGFuIGV4dHJhIHRpbWUgd2l0aCBwcmVmaXhlZCBrZXlmcmFtZXMgYmVjYXVzZSBpb3MgPCA5IGlzIHByZXR0eSBhd2Z1bFxyXG4gICAgICAgICAgICAgICAgICAgIGNzc0xpbmVzLnB1c2goYEAtd2Via2l0LWtleWZyYW1lcyAke2NvbXBvbmVudE5hbWV9LSR7c3R5bGVOYW1lfS1hbmltYXRpb24tJHtkZXNjcmlwdG9yLnNsaWNlKDEpfSB7YCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBbc2VsZWN0b3IsIGRlZl0gb2YgT2JqZWN0LmVudHJpZXMoZGVmcykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3NzTGluZXMgPSBwcm9jZXNzRGVmKGNzc0xpbmVzLCBzZWxlY3RvciwgZGVmKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY3NzTGluZXMucHVzaChcIn1cIik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vICBub3JtYWwgQGtleWZyYW1lcyBjc3NcclxuICAgICAgICAgICAgICAgICAgICBjc3NMaW5lcy5wdXNoKGBAa2V5ZnJhbWVzICR7Y29tcG9uZW50TmFtZX0tJHtzdHlsZU5hbWV9LWFuaW1hdGlvbi0ke2Rlc2NyaXB0b3Iuc2xpY2UoMSl9IHtgKTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtzZWxlY3RvciwgZGVmXSBvZiBPYmplY3QuZW50cmllcyhkZWZzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjc3NMaW5lcyA9IHByb2Nlc3NEZWYoY3NzTGluZXMsIHNlbGVjdG9yLCBkZWYpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjc3NMaW5lcy5wdXNoKFwifVwiKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSBwcm9jZXNzU2VsZWN0b3IoY29tcG9uZW50TmFtZSwgc3R5bGVOYW1lLCBkZXNjcmlwdG9yKTtcclxuICAgICAgICAgICAgICAgICAgICBjc3NMaW5lcyA9IHByb2Nlc3NEZWYoY3NzTGluZXMsIHNlbGVjdG9yLCBkZWZzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBzdHlsZVRhZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcclxuICAgICAgICAgICAgc3R5bGVUYWcuc2V0QXR0cmlidXRlKFwidHlwZVwiLCBcInRleHQvY3NzXCIpO1xyXG4gICAgICAgICAgICBzdHlsZVRhZy5zZXRBdHRyaWJ1dGUoXCJkYXRhLW5hbWVcIiwgYCR7Y29tcG9uZW50TmFtZX0vJHtzdHlsZU5hbWV9YCk7XHJcbiAgICAgICAgICAgIHN0eWxlVGFnLmlubmVySFRNTCA9IGNzc0xpbmVzLmpvaW4oJ1xcbicpO1xyXG4gICAgICAgICAgICBoZWFkLmFwcGVuZENoaWxkKHN0eWxlVGFnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG5sZXQgdGhlbWVWYWx1ZXM7XHJcbmNvbnN0IFRoZW1lID0ge1xyXG4gICAgZGVmaW5lKHRoZW1lKSB7XHJcbiAgICAgICAgdGhlbWVWYWx1ZXMgPSB0aGVtZTtcclxuICAgIH0sXHJcbiAgICBnZXQgdmFyaWFibGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoZW1lVmFsdWVzO1xyXG4gICAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgZGVmaW5lQ29tcG9uZW50U3R5bGUsXHJcbiAgICBkZWZpbmVDdXN0b21CYXNlLFxyXG4gICAgZGVmaW5lU3R5bGVGb3JDb21wb25lbnQsXHJcbiAgICBnZW5Gb250Q1NTKG5hbWUsIGRhdGFVUkkpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBmb250RmFtaWx5OiBgXCIke25hbWV9XCJgLFxyXG4gICAgICAgICAgICBzcmM6IGB1cmwoXCIke2RhdGFVUkl9XCIpYCxcclxuICAgICAgICAgICAgZm9udFdlaWdodDogXCJub3JtYWxcIixcclxuICAgICAgICAgICAgZm9udFN0eWxlOiBcIm5vcm1hbFwiXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIFRoZW1lLFxyXG4gICAgX19zZXR1cDogY3JlYXRlU3R5bGVzXHJcbn07XHJcbiIsImNvbnN0IHdhcm5pbmdGdW5jID0gZXJyb3JNZXNzYWdlID0+XHJcbiAgICAoKSA9PiBjb25zb2xlLndhcm4oZXJyb3JNZXNzYWdlKTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIHdhcm5pbmdGdW5jLFxyXG4gICAgdHJhbnNmZXJQcm9wcyhzb3VyY2VzKSB7XHJcbiAgICAgICAgY29uc3QgZGVzdCA9IHt9O1xyXG5cclxuICAgICAgICBmb3IgKGNvbnN0IFtkZXN0TmFtZSwgc291cmNlXSBvZiBPYmplY3QuZW50cmllcyhzb3VyY2VzKSkge1xyXG4gICAgICAgICAgICAvLyBkZWJ1Z2dlcjtcclxuICAgICAgICAgICAgY29uc3QgW3NvdXJjZU9iaiwgcHJvcHNdID0gc291cmNlO1xyXG4gICAgICAgICAgICBjb25zdCBjb3B5ID0ge307XHJcblxyXG4gICAgICAgICAgICBpZiAoc291cmNlT2JqICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtzb3VyY2VQcm9wLCBkZXN0UHJvcF0gb2YgT2JqZWN0LmVudHJpZXMocHJvcHMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZU9ialtzb3VyY2VQcm9wXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcHlbZGVzdFByb3BdID0gc291cmNlT2JqW3NvdXJjZVByb3BdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMoY29weSkubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlc3RbZGVzdE5hbWVdID0gY29weTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGRlc3Q7XHJcbiAgICB9XHJcbn07XHJcbiIsImltcG9ydCBcImV4dGVybmFsL3ppcC5qc1wiO1xyXG5pbXBvcnQgXCJleHRlcm5hbC96aXAtZXh0LmpzXCI7XHJcblxyXG5pbXBvcnQgZGVmbGF0ZVNvdXJjZSBmcm9tIFwiZXh0ZXJuYWwvZGVmbGF0ZS5qcy5zb3VyY2VcIjtcclxuaW1wb3J0IGluZmxhdGVTb3VyY2UgZnJvbSBcImV4dGVybmFsL2luZmxhdGUuanMuc291cmNlXCI7XHJcbmltcG9ydCB3b3JrZXJTb3VyY2UgZnJvbSBcImV4dGVybmFsL3otd29ya2VyLmpzLnNvdXJjZVwiO1xyXG5cclxuY29uc3QgY3JlYXRlVVJMID0gc291cmNlID0+IHtcclxuICAgIGNvbnN0IGJsb2IgPSBuZXcgQmxvYihbc291cmNlXSwge3R5cGU6IFwiYXBwbGljYXRpb24vamF2YXNjcmlwdFwifSk7XHJcbiAgICByZXR1cm4gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcclxufTtcclxuXHJcbmNvbnN0IHdvcmtlclVSTCA9IGNyZWF0ZVVSTCh3b3JrZXJTb3VyY2UpO1xyXG5jb25zdCBpbmZsYXRlVVJMID0gY3JlYXRlVVJMKGluZmxhdGVTb3VyY2UpO1xyXG5jb25zdCBkZWZsYXRlVVJMID0gY3JlYXRlVVJMKGRlZmxhdGVTb3VyY2UpO1xyXG5cclxuemlwLndvcmtlclNjcmlwdHMgPSB7XHJcbiAgICBpbmZsYXRlcjogW3dvcmtlclVSTCwgaW5mbGF0ZVVSTF0sXHJcbiAgICBkZWZsYXRlcjogW3dvcmtlclVSTCwgZGVmbGF0ZVVSTF1cclxufTtcclxuXHJcbmNvbnN0IHppcExpYiA9IHppcDtcclxuXHJcbndpbmRvdy56aXAgPSBudWxsO1xyXG5cclxuY29uc3QgcmVhZEVudHJ5ID0gKGVudHJ5LCB3cml0ZXIpID0+IG5ldyBQcm9taXNlKFxyXG4gICAgcmVzb2x2ZSA9PiBlbnRyeS5nZXREYXRhKHdyaXRlciwgcmVzb2x2ZSlcclxuKTtcclxuY29uc3QgemlwRW50cnkgPSBlbnRyeSA9PiB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHJlYWRUZXh0KCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVhZEVudHJ5KGVudHJ5LCBuZXcgemlwTGliLlRleHRXcml0ZXIoKSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICByZWFkQmxvYigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlYWRFbnRyeShlbnRyeSwgbmV3IHppcExpYi5CbG9iV3JpdGVyKCkpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0IGVudHJ5KCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZW50cnk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufTtcclxuXHJcbmNvbnN0IHJlYWRBcnJheUJ1ZmZlciA9IGJ1ZmZlciA9PiBuZXcgUHJvbWlzZShcclxuICAgIChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICB6aXBMaWIuY3JlYXRlUmVhZGVyKFxyXG4gICAgICAgICAgICBuZXcgemlwTGliLkFycmF5QnVmZmVyUmVhZGVyKGJ1ZmZlciksXHJcbiAgICAgICAgICAgIHJlYWRlciA9PiB7XHJcbiAgICAgICAgICAgICAgICByZWFkZXIuZ2V0RW50cmllcyhlbnRyaWVzID0+IHJlc29sdmUoW2VudHJpZXMsIHJlYWRlcl0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcbik7XHJcbmNvbnN0IGRvd25sb2FkID0gYXN5bmMgKHVybCwgb25Qcm9ncmVzcykgPT4ge1xyXG4gICAgY29uc3QgYnVmZmVyID0gYXdhaXQgZmFjdG90dW0uYWpheCh1cmwsIHt0eXBlOiAnYXJyYXlidWZmZXInLCBvblByb2dyZXNzfSk7XHJcbiAgICByZXR1cm4gYXdhaXQgcmVhZEFycmF5QnVmZmVyKGJ1ZmZlci5yZXNwb25zZSk7XHJcbn07XHJcblxyXG5jb25zdCB6aXBGaWxlID0gKFtlbnRyaWVzLCByZWFkZXJdKSA9PiB7XHJcbiAgICBjb25zdCBlbnRyeVNvcnQgPSAoZmlyc3QsIHNlY29uZCkgPT4ge1xyXG4gICAgICAgIGlmIChmaXJzdC5maWxlbmFtZSA8IHNlY29uZC5maWxlbmFtZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmaXJzdC5maWxlbmFtZSA+IHNlY29uZC5maWxlbmFtZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgZmlsZXMgPSBlbnRyaWVzLnNvcnQoZW50cnlTb3J0KS5yZWR1Y2UoXHJcbiAgICAgICAgKGNvbGxlY3Rpb24sIGVudHJ5KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbGxlY3Rpb25bZW50cnkuZmlsZW5hbWVdID0gZW50cnk7XHJcbiAgICAgICAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge31cclxuICAgICk7XHJcbiAgICBlbnRyaWVzID0gZW50cmllcy5zb3J0KGVudHJ5U29ydCk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBnZXRGaWxlKG5hbWUpIHtcclxuICAgICAgICAgICAgaWYgKGZpbGVzLmhhc093blByb3BlcnR5KG5hbWUpID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gemlwRW50cnkoZmlsZXNbbmFtZV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0RW50cmllcygpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGVudHJpZXMubWFwKHppcEVudHJ5KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGFzeW5jIGV4dHJhY3RUbyhkZXN0LCBvblByb2dyZXNzID0gKCkgPT4ge30pIHtcclxuICAgICAgICAgICAgbGV0IGluZGV4O1xyXG5cclxuICAgICAgICAgICAgaW5kZXggPSAwO1xyXG4gICAgICAgICAgICBmb3IoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qge2ZpbGVuYW1lfSA9IGVudHJ5O1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChlbnRyeS5kaXJlY3RvcnkgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBhd2FpdCBmcy5kaXJDcmVhdGUoYCR7ZGVzdH0ke2ZpbGVuYW1lfWApO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBhd2FpdCBmcy5maWxlV3JpdGUoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGAke2Rlc3R9JHtmaWxlbmFtZX1gLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB6aXBFbnRyeShlbnRyeSkucmVhZEJsb2IoKVxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpbmRleCArPSAxO1xyXG4gICAgICAgICAgICAgICAgb25Qcm9ncmVzcyh7XHJcbiAgICAgICAgICAgICAgICAgICAgZXh0cmFjdGVkOiBpbmRleCxcclxuICAgICAgICAgICAgICAgICAgICB0b3RhbDogZW50cmllcy5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEZpbGU6IHppcEVudHJ5KGVudHJ5KSxcclxuICAgICAgICAgICAgICAgICAgICBuZXh0RmlsZTogKGluZGV4IDwgZW50cmllcy5sZW5ndGgpID8gemlwRW50cnkoZW50cmllc1tpbmRleF0pIDogbnVsbFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjbG9zZSgpIHtcclxuICAgICAgICAgICAgcmVhZGVyLmNsb3NlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIGFzeW5jIGRvd25sb2FkKHVybCwgb25Qcm9ncmVzcykge1xyXG4gICAgICAgIGNvbnN0IHppcEluZm8gPSBhd2FpdCBkb3dubG9hZCh1cmwsIG9uUHJvZ3Jlc3MpO1xyXG4gICAgICAgIHJldHVybiB6aXBGaWxlKHppcEluZm8pO1xyXG4gICAgfVxyXG59O1xyXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vYXJyYXkvZnJvbVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9nZXQtaXRlcmF0b3JcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2Fzc2lnblwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvY3JlYXRlXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9kZWZpbmUtcHJvcGVydGllc1wiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZW50cmllc1wiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZnJlZXplXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9rZXlzXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9zZXQtcHJvdG90eXBlLW9mXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL3Byb21pc2VcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vc2V0XCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbFwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59O1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX09iamVjdCRhc3NpZ24gPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9hc3NpZ25cIilbXCJkZWZhdWx0XCJdO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IF9PYmplY3QkYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufTtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9PYmplY3QkY3JlYXRlID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvY3JlYXRlXCIpW1wiZGVmYXVsdFwiXTtcblxudmFyIF9PYmplY3Qkc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9zZXQtcHJvdG90eXBlLW9mXCIpW1wiZGVmYXVsdFwiXTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBmdW5jdGlvbiAoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gX09iamVjdCRjcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIF9PYmplY3Qkc2V0UHJvdG90eXBlT2YgPyBfT2JqZWN0JHNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG59O1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICBcImRlZmF1bHRcIjogb2JqXG4gIH07XG59O1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGZ1bmN0aW9uIChvYmosIGtleXMpIHtcbiAgdmFyIHRhcmdldCA9IHt9O1xuXG4gIGZvciAodmFyIGkgaW4gb2JqKSB7XG4gICAgaWYgKGtleXMuaW5kZXhPZihpKSA+PSAwKSBjb250aW51ZTtcbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTtcbiAgICB0YXJnZXRbaV0gPSBvYmpbaV07XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufTtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2LmFycmF5LmZyb20nKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy8kLmNvcmUnKS5BcnJheS5mcm9tOyIsInJlcXVpcmUoJy4uL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3InKTsiLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QuYXNzaWduJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvJC5jb3JlJykuT2JqZWN0LmFzc2lnbjsiLCJ2YXIgJCA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvJCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGUoUCwgRCl7XG4gIHJldHVybiAkLmNyZWF0ZShQLCBEKTtcbn07IiwidmFyICQgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzLyQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhULCBEKXtcbiAgcmV0dXJuICQuc2V0RGVzY3MoVCwgRCk7XG59OyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM3Lm9iamVjdC5lbnRyaWVzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvJC5jb3JlJykuT2JqZWN0LmVudHJpZXM7IiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmZyZWV6ZScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzLyQuY29yZScpLk9iamVjdC5mcmVlemU7IiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmtleXMnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy8kLmNvcmUnKS5PYmplY3Qua2V5czsiLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3Quc2V0LXByb3RvdHlwZS1vZicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzLyQuY29yZScpLk9iamVjdC5zZXRQcm90b3R5cGVPZjsiLCJyZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYucHJvbWlzZScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9tb2R1bGVzLyQuY29yZScpLlByb21pc2U7IiwicmVxdWlyZSgnLi4vbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZycpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnNldCcpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczcuc2V0LnRvLWpzb24nKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vbW9kdWxlcy8kLmNvcmUnKS5TZXQ7IiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYuc3ltYm9sJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvJC5jb3JlJykuU3ltYm9sOyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICBpZih0eXBlb2YgaXQgIT0gJ2Z1bmN0aW9uJyl0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uIScpO1xuICByZXR1cm4gaXQ7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKXsgLyogZW1wdHkgKi8gfTsiLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLyQuaXMtb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYoIWlzT2JqZWN0KGl0KSl0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhbiBvYmplY3QhJyk7XG4gIHJldHVybiBpdDtcbn07IiwiLy8gZ2V0dGluZyB0YWcgZnJvbSAxOS4xLjMuNiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKClcbnZhciBjb2YgPSByZXF1aXJlKCcuLyQuY29mJylcbiAgLCBUQUcgPSByZXF1aXJlKCcuLyQud2tzJykoJ3RvU3RyaW5nVGFnJylcbiAgLy8gRVMzIHdyb25nIGhlcmVcbiAgLCBBUkcgPSBjb2YoZnVuY3Rpb24oKXsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA9PSAnQXJndW1lbnRzJztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHZhciBPLCBULCBCO1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/ICdVbmRlZmluZWQnIDogaXQgPT09IG51bGwgPyAnTnVsbCdcbiAgICAvLyBAQHRvU3RyaW5nVGFnIGNhc2VcbiAgICA6IHR5cGVvZiAoVCA9IChPID0gT2JqZWN0KGl0KSlbVEFHXSkgPT0gJ3N0cmluZycgPyBUXG4gICAgLy8gYnVpbHRpblRhZyBjYXNlXG4gICAgOiBBUkcgPyBjb2YoTylcbiAgICAvLyBFUzMgYXJndW1lbnRzIGZhbGxiYWNrXG4gICAgOiAoQiA9IGNvZihPKSkgPT0gJ09iamVjdCcgJiYgdHlwZW9mIE8uY2FsbGVlID09ICdmdW5jdGlvbicgPyAnQXJndW1lbnRzJyA6IEI7XG59OyIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpLnNsaWNlKDgsIC0xKTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgICAgICAgICAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgaGlkZSAgICAgICAgID0gcmVxdWlyZSgnLi8kLmhpZGUnKVxuICAsIHJlZGVmaW5lQWxsICA9IHJlcXVpcmUoJy4vJC5yZWRlZmluZS1hbGwnKVxuICAsIGN0eCAgICAgICAgICA9IHJlcXVpcmUoJy4vJC5jdHgnKVxuICAsIHN0cmljdE5ldyAgICA9IHJlcXVpcmUoJy4vJC5zdHJpY3QtbmV3JylcbiAgLCBkZWZpbmVkICAgICAgPSByZXF1aXJlKCcuLyQuZGVmaW5lZCcpXG4gICwgZm9yT2YgICAgICAgID0gcmVxdWlyZSgnLi8kLmZvci1vZicpXG4gICwgJGl0ZXJEZWZpbmUgID0gcmVxdWlyZSgnLi8kLml0ZXItZGVmaW5lJylcbiAgLCBzdGVwICAgICAgICAgPSByZXF1aXJlKCcuLyQuaXRlci1zdGVwJylcbiAgLCBJRCAgICAgICAgICAgPSByZXF1aXJlKCcuLyQudWlkJykoJ2lkJylcbiAgLCAkaGFzICAgICAgICAgPSByZXF1aXJlKCcuLyQuaGFzJylcbiAgLCBpc09iamVjdCAgICAgPSByZXF1aXJlKCcuLyQuaXMtb2JqZWN0JylcbiAgLCBzZXRTcGVjaWVzICAgPSByZXF1aXJlKCcuLyQuc2V0LXNwZWNpZXMnKVxuICAsIERFU0NSSVBUT1JTICA9IHJlcXVpcmUoJy4vJC5kZXNjcmlwdG9ycycpXG4gICwgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZSB8fCBpc09iamVjdFxuICAsIFNJWkUgICAgICAgICA9IERFU0NSSVBUT1JTID8gJ19zJyA6ICdzaXplJ1xuICAsIGlkICAgICAgICAgICA9IDA7XG5cbnZhciBmYXN0S2V5ID0gZnVuY3Rpb24oaXQsIGNyZWF0ZSl7XG4gIC8vIHJldHVybiBwcmltaXRpdmUgd2l0aCBwcmVmaXhcbiAgaWYoIWlzT2JqZWN0KGl0KSlyZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnID8gaXQgOiAodHlwZW9mIGl0ID09ICdzdHJpbmcnID8gJ1MnIDogJ1AnKSArIGl0O1xuICBpZighJGhhcyhpdCwgSUQpKXtcbiAgICAvLyBjYW4ndCBzZXQgaWQgdG8gZnJvemVuIG9iamVjdFxuICAgIGlmKCFpc0V4dGVuc2libGUoaXQpKXJldHVybiAnRic7XG4gICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgaWRcbiAgICBpZighY3JlYXRlKXJldHVybiAnRSc7XG4gICAgLy8gYWRkIG1pc3Npbmcgb2JqZWN0IGlkXG4gICAgaGlkZShpdCwgSUQsICsraWQpO1xuICAvLyByZXR1cm4gb2JqZWN0IGlkIHdpdGggcHJlZml4XG4gIH0gcmV0dXJuICdPJyArIGl0W0lEXTtcbn07XG5cbnZhciBnZXRFbnRyeSA9IGZ1bmN0aW9uKHRoYXQsIGtleSl7XG4gIC8vIGZhc3QgY2FzZVxuICB2YXIgaW5kZXggPSBmYXN0S2V5KGtleSksIGVudHJ5O1xuICBpZihpbmRleCAhPT0gJ0YnKXJldHVybiB0aGF0Ll9pW2luZGV4XTtcbiAgLy8gZnJvemVuIG9iamVjdCBjYXNlXG4gIGZvcihlbnRyeSA9IHRoYXQuX2Y7IGVudHJ5OyBlbnRyeSA9IGVudHJ5Lm4pe1xuICAgIGlmKGVudHJ5LmsgPT0ga2V5KXJldHVybiBlbnRyeTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldENvbnN0cnVjdG9yOiBmdW5jdGlvbih3cmFwcGVyLCBOQU1FLCBJU19NQVAsIEFEREVSKXtcbiAgICB2YXIgQyA9IHdyYXBwZXIoZnVuY3Rpb24odGhhdCwgaXRlcmFibGUpe1xuICAgICAgc3RyaWN0TmV3KHRoYXQsIEMsIE5BTUUpO1xuICAgICAgdGhhdC5faSA9ICQuY3JlYXRlKG51bGwpOyAvLyBpbmRleFxuICAgICAgdGhhdC5fZiA9IHVuZGVmaW5lZDsgICAgICAvLyBmaXJzdCBlbnRyeVxuICAgICAgdGhhdC5fbCA9IHVuZGVmaW5lZDsgICAgICAvLyBsYXN0IGVudHJ5XG4gICAgICB0aGF0W1NJWkVdID0gMDsgICAgICAgICAgIC8vIHNpemVcbiAgICAgIGlmKGl0ZXJhYmxlICE9IHVuZGVmaW5lZClmb3JPZihpdGVyYWJsZSwgSVNfTUFQLCB0aGF0W0FEREVSXSwgdGhhdCk7XG4gICAgfSk7XG4gICAgcmVkZWZpbmVBbGwoQy5wcm90b3R5cGUsIHtcbiAgICAgIC8vIDIzLjEuMy4xIE1hcC5wcm90b3R5cGUuY2xlYXIoKVxuICAgICAgLy8gMjMuMi4zLjIgU2V0LnByb3RvdHlwZS5jbGVhcigpXG4gICAgICBjbGVhcjogZnVuY3Rpb24gY2xlYXIoKXtcbiAgICAgICAgZm9yKHZhciB0aGF0ID0gdGhpcywgZGF0YSA9IHRoYXQuX2ksIGVudHJ5ID0gdGhhdC5fZjsgZW50cnk7IGVudHJ5ID0gZW50cnkubil7XG4gICAgICAgICAgZW50cnkuciA9IHRydWU7XG4gICAgICAgICAgaWYoZW50cnkucCllbnRyeS5wID0gZW50cnkucC5uID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGRlbGV0ZSBkYXRhW2VudHJ5LmldO1xuICAgICAgICB9XG4gICAgICAgIHRoYXQuX2YgPSB0aGF0Ll9sID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGF0W1NJWkVdID0gMDtcbiAgICAgIH0sXG4gICAgICAvLyAyMy4xLjMuMyBNYXAucHJvdG90eXBlLmRlbGV0ZShrZXkpXG4gICAgICAvLyAyMy4yLjMuNCBTZXQucHJvdG90eXBlLmRlbGV0ZSh2YWx1ZSlcbiAgICAgICdkZWxldGUnOiBmdW5jdGlvbihrZXkpe1xuICAgICAgICB2YXIgdGhhdCAgPSB0aGlzXG4gICAgICAgICAgLCBlbnRyeSA9IGdldEVudHJ5KHRoYXQsIGtleSk7XG4gICAgICAgIGlmKGVudHJ5KXtcbiAgICAgICAgICB2YXIgbmV4dCA9IGVudHJ5Lm5cbiAgICAgICAgICAgICwgcHJldiA9IGVudHJ5LnA7XG4gICAgICAgICAgZGVsZXRlIHRoYXQuX2lbZW50cnkuaV07XG4gICAgICAgICAgZW50cnkuciA9IHRydWU7XG4gICAgICAgICAgaWYocHJldilwcmV2Lm4gPSBuZXh0O1xuICAgICAgICAgIGlmKG5leHQpbmV4dC5wID0gcHJldjtcbiAgICAgICAgICBpZih0aGF0Ll9mID09IGVudHJ5KXRoYXQuX2YgPSBuZXh0O1xuICAgICAgICAgIGlmKHRoYXQuX2wgPT0gZW50cnkpdGhhdC5fbCA9IHByZXY7XG4gICAgICAgICAgdGhhdFtTSVpFXS0tO1xuICAgICAgICB9IHJldHVybiAhIWVudHJ5O1xuICAgICAgfSxcbiAgICAgIC8vIDIzLjIuMy42IFNldC5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxuICAgICAgLy8gMjMuMS4zLjUgTWFwLnByb3RvdHlwZS5mb3JFYWNoKGNhbGxiYWNrZm4sIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gICAgICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm4gLyosIHRoYXQgPSB1bmRlZmluZWQgKi8pe1xuICAgICAgICB2YXIgZiA9IGN0eChjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgMylcbiAgICAgICAgICAsIGVudHJ5O1xuICAgICAgICB3aGlsZShlbnRyeSA9IGVudHJ5ID8gZW50cnkubiA6IHRoaXMuX2Ype1xuICAgICAgICAgIGYoZW50cnkudiwgZW50cnkuaywgdGhpcyk7XG4gICAgICAgICAgLy8gcmV2ZXJ0IHRvIHRoZSBsYXN0IGV4aXN0aW5nIGVudHJ5XG4gICAgICAgICAgd2hpbGUoZW50cnkgJiYgZW50cnkucillbnRyeSA9IGVudHJ5LnA7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyAyMy4xLjMuNyBNYXAucHJvdG90eXBlLmhhcyhrZXkpXG4gICAgICAvLyAyMy4yLjMuNyBTZXQucHJvdG90eXBlLmhhcyh2YWx1ZSlcbiAgICAgIGhhczogZnVuY3Rpb24gaGFzKGtleSl7XG4gICAgICAgIHJldHVybiAhIWdldEVudHJ5KHRoaXMsIGtleSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYoREVTQ1JJUFRPUlMpJC5zZXREZXNjKEMucHJvdG90eXBlLCAnc2l6ZScsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIGRlZmluZWQodGhpc1tTSVpFXSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIEM7XG4gIH0sXG4gIGRlZjogZnVuY3Rpb24odGhhdCwga2V5LCB2YWx1ZSl7XG4gICAgdmFyIGVudHJ5ID0gZ2V0RW50cnkodGhhdCwga2V5KVxuICAgICAgLCBwcmV2LCBpbmRleDtcbiAgICAvLyBjaGFuZ2UgZXhpc3RpbmcgZW50cnlcbiAgICBpZihlbnRyeSl7XG4gICAgICBlbnRyeS52ID0gdmFsdWU7XG4gICAgLy8gY3JlYXRlIG5ldyBlbnRyeVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGF0Ll9sID0gZW50cnkgPSB7XG4gICAgICAgIGk6IGluZGV4ID0gZmFzdEtleShrZXksIHRydWUpLCAvLyA8LSBpbmRleFxuICAgICAgICBrOiBrZXksICAgICAgICAgICAgICAgICAgICAgICAgLy8gPC0ga2V5XG4gICAgICAgIHY6IHZhbHVlLCAgICAgICAgICAgICAgICAgICAgICAvLyA8LSB2YWx1ZVxuICAgICAgICBwOiBwcmV2ID0gdGhhdC5fbCwgICAgICAgICAgICAgLy8gPC0gcHJldmlvdXMgZW50cnlcbiAgICAgICAgbjogdW5kZWZpbmVkLCAgICAgICAgICAgICAgICAgIC8vIDwtIG5leHQgZW50cnlcbiAgICAgICAgcjogZmFsc2UgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIHJlbW92ZWRcbiAgICAgIH07XG4gICAgICBpZighdGhhdC5fZil0aGF0Ll9mID0gZW50cnk7XG4gICAgICBpZihwcmV2KXByZXYubiA9IGVudHJ5O1xuICAgICAgdGhhdFtTSVpFXSsrO1xuICAgICAgLy8gYWRkIHRvIGluZGV4XG4gICAgICBpZihpbmRleCAhPT0gJ0YnKXRoYXQuX2lbaW5kZXhdID0gZW50cnk7XG4gICAgfSByZXR1cm4gdGhhdDtcbiAgfSxcbiAgZ2V0RW50cnk6IGdldEVudHJ5LFxuICBzZXRTdHJvbmc6IGZ1bmN0aW9uKEMsIE5BTUUsIElTX01BUCl7XG4gICAgLy8gYWRkIC5rZXlzLCAudmFsdWVzLCAuZW50cmllcywgW0BAaXRlcmF0b3JdXG4gICAgLy8gMjMuMS4zLjQsIDIzLjEuMy44LCAyMy4xLjMuMTEsIDIzLjEuMy4xMiwgMjMuMi4zLjUsIDIzLjIuMy44LCAyMy4yLjMuMTAsIDIzLjIuMy4xMVxuICAgICRpdGVyRGVmaW5lKEMsIE5BTUUsIGZ1bmN0aW9uKGl0ZXJhdGVkLCBraW5kKXtcbiAgICAgIHRoaXMuX3QgPSBpdGVyYXRlZDsgIC8vIHRhcmdldFxuICAgICAgdGhpcy5fayA9IGtpbmQ7ICAgICAgLy8ga2luZFxuICAgICAgdGhpcy5fbCA9IHVuZGVmaW5lZDsgLy8gcHJldmlvdXNcbiAgICB9LCBmdW5jdGlvbigpe1xuICAgICAgdmFyIHRoYXQgID0gdGhpc1xuICAgICAgICAsIGtpbmQgID0gdGhhdC5fa1xuICAgICAgICAsIGVudHJ5ID0gdGhhdC5fbDtcbiAgICAgIC8vIHJldmVydCB0byB0aGUgbGFzdCBleGlzdGluZyBlbnRyeVxuICAgICAgd2hpbGUoZW50cnkgJiYgZW50cnkucillbnRyeSA9IGVudHJ5LnA7XG4gICAgICAvLyBnZXQgbmV4dCBlbnRyeVxuICAgICAgaWYoIXRoYXQuX3QgfHwgISh0aGF0Ll9sID0gZW50cnkgPSBlbnRyeSA/IGVudHJ5Lm4gOiB0aGF0Ll90Ll9mKSl7XG4gICAgICAgIC8vIG9yIGZpbmlzaCB0aGUgaXRlcmF0aW9uXG4gICAgICAgIHRoYXQuX3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBzdGVwKDEpO1xuICAgICAgfVxuICAgICAgLy8gcmV0dXJuIHN0ZXAgYnkga2luZFxuICAgICAgaWYoa2luZCA9PSAna2V5cycgIClyZXR1cm4gc3RlcCgwLCBlbnRyeS5rKTtcbiAgICAgIGlmKGtpbmQgPT0gJ3ZhbHVlcycpcmV0dXJuIHN0ZXAoMCwgZW50cnkudik7XG4gICAgICByZXR1cm4gc3RlcCgwLCBbZW50cnkuaywgZW50cnkudl0pO1xuICAgIH0sIElTX01BUCA/ICdlbnRyaWVzJyA6ICd2YWx1ZXMnICwgIUlTX01BUCwgdHJ1ZSk7XG5cbiAgICAvLyBhZGQgW0BAc3BlY2llc10sIDIzLjEuMi4yLCAyMy4yLjIuMlxuICAgIHNldFNwZWNpZXMoTkFNRSk7XG4gIH1cbn07IiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL0RhdmlkQnJ1YW50L01hcC1TZXQucHJvdG90eXBlLnRvSlNPTlxudmFyIGZvck9mICAgPSByZXF1aXJlKCcuLyQuZm9yLW9mJylcbiAgLCBjbGFzc29mID0gcmVxdWlyZSgnLi8kLmNsYXNzb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oTkFNRSl7XG4gIHJldHVybiBmdW5jdGlvbiB0b0pTT04oKXtcbiAgICBpZihjbGFzc29mKHRoaXMpICE9IE5BTUUpdGhyb3cgVHlwZUVycm9yKE5BTUUgKyBcIiN0b0pTT04gaXNuJ3QgZ2VuZXJpY1wiKTtcbiAgICB2YXIgYXJyID0gW107XG4gICAgZm9yT2YodGhpcywgZmFsc2UsIGFyci5wdXNoLCBhcnIpO1xuICAgIHJldHVybiBhcnI7XG4gIH07XG59OyIsIid1c2Ugc3RyaWN0JztcbnZhciAkICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgZ2xvYmFsICAgICAgICAgPSByZXF1aXJlKCcuLyQuZ2xvYmFsJylcbiAgLCAkZXhwb3J0ICAgICAgICA9IHJlcXVpcmUoJy4vJC5leHBvcnQnKVxuICAsIGZhaWxzICAgICAgICAgID0gcmVxdWlyZSgnLi8kLmZhaWxzJylcbiAgLCBoaWRlICAgICAgICAgICA9IHJlcXVpcmUoJy4vJC5oaWRlJylcbiAgLCByZWRlZmluZUFsbCAgICA9IHJlcXVpcmUoJy4vJC5yZWRlZmluZS1hbGwnKVxuICAsIGZvck9mICAgICAgICAgID0gcmVxdWlyZSgnLi8kLmZvci1vZicpXG4gICwgc3RyaWN0TmV3ICAgICAgPSByZXF1aXJlKCcuLyQuc3RyaWN0LW5ldycpXG4gICwgaXNPYmplY3QgICAgICAgPSByZXF1aXJlKCcuLyQuaXMtb2JqZWN0JylcbiAgLCBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vJC5zZXQtdG8tc3RyaW5nLXRhZycpXG4gICwgREVTQ1JJUFRPUlMgICAgPSByZXF1aXJlKCcuLyQuZGVzY3JpcHRvcnMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihOQU1FLCB3cmFwcGVyLCBtZXRob2RzLCBjb21tb24sIElTX01BUCwgSVNfV0VBSyl7XG4gIHZhciBCYXNlICA9IGdsb2JhbFtOQU1FXVxuICAgICwgQyAgICAgPSBCYXNlXG4gICAgLCBBRERFUiA9IElTX01BUCA/ICdzZXQnIDogJ2FkZCdcbiAgICAsIHByb3RvID0gQyAmJiBDLnByb3RvdHlwZVxuICAgICwgTyAgICAgPSB7fTtcbiAgaWYoIURFU0NSSVBUT1JTIHx8IHR5cGVvZiBDICE9ICdmdW5jdGlvbicgfHwgIShJU19XRUFLIHx8IHByb3RvLmZvckVhY2ggJiYgIWZhaWxzKGZ1bmN0aW9uKCl7XG4gICAgbmV3IEMoKS5lbnRyaWVzKCkubmV4dCgpO1xuICB9KSkpe1xuICAgIC8vIGNyZWF0ZSBjb2xsZWN0aW9uIGNvbnN0cnVjdG9yXG4gICAgQyA9IGNvbW1vbi5nZXRDb25zdHJ1Y3Rvcih3cmFwcGVyLCBOQU1FLCBJU19NQVAsIEFEREVSKTtcbiAgICByZWRlZmluZUFsbChDLnByb3RvdHlwZSwgbWV0aG9kcyk7XG4gIH0gZWxzZSB7XG4gICAgQyA9IHdyYXBwZXIoZnVuY3Rpb24odGFyZ2V0LCBpdGVyYWJsZSl7XG4gICAgICBzdHJpY3ROZXcodGFyZ2V0LCBDLCBOQU1FKTtcbiAgICAgIHRhcmdldC5fYyA9IG5ldyBCYXNlO1xuICAgICAgaWYoaXRlcmFibGUgIT0gdW5kZWZpbmVkKWZvck9mKGl0ZXJhYmxlLCBJU19NQVAsIHRhcmdldFtBRERFUl0sIHRhcmdldCk7XG4gICAgfSk7XG4gICAgJC5lYWNoLmNhbGwoJ2FkZCxjbGVhcixkZWxldGUsZm9yRWFjaCxnZXQsaGFzLHNldCxrZXlzLHZhbHVlcyxlbnRyaWVzJy5zcGxpdCgnLCcpLGZ1bmN0aW9uKEtFWSl7XG4gICAgICB2YXIgSVNfQURERVIgPSBLRVkgPT0gJ2FkZCcgfHwgS0VZID09ICdzZXQnO1xuICAgICAgaWYoS0VZIGluIHByb3RvICYmICEoSVNfV0VBSyAmJiBLRVkgPT0gJ2NsZWFyJykpaGlkZShDLnByb3RvdHlwZSwgS0VZLCBmdW5jdGlvbihhLCBiKXtcbiAgICAgICAgaWYoIUlTX0FEREVSICYmIElTX1dFQUsgJiYgIWlzT2JqZWN0KGEpKXJldHVybiBLRVkgPT0gJ2dldCcgPyB1bmRlZmluZWQgOiBmYWxzZTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX2NbS0VZXShhID09PSAwID8gMCA6IGEsIGIpO1xuICAgICAgICByZXR1cm4gSVNfQURERVIgPyB0aGlzIDogcmVzdWx0O1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgaWYoJ3NpemUnIGluIHByb3RvKSQuc2V0RGVzYyhDLnByb3RvdHlwZSwgJ3NpemUnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiB0aGlzLl9jLnNpemU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBzZXRUb1N0cmluZ1RhZyhDLCBOQU1FKTtcblxuICBPW05BTUVdID0gQztcbiAgJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYsIE8pO1xuXG4gIGlmKCFJU19XRUFLKWNvbW1vbi5zZXRTdHJvbmcoQywgTkFNRSwgSVNfTUFQKTtcblxuICByZXR1cm4gQztcbn07IiwidmFyIGNvcmUgPSBtb2R1bGUuZXhwb3J0cyA9IHt2ZXJzaW9uOiAnMS4yLjYnfTtcbmlmKHR5cGVvZiBfX2UgPT0gJ251bWJlcicpX19lID0gY29yZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZiIsIi8vIG9wdGlvbmFsIC8gc2ltcGxlIGNvbnRleHQgYmluZGluZ1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vJC5hLWZ1bmN0aW9uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGZuLCB0aGF0LCBsZW5ndGgpe1xuICBhRnVuY3Rpb24oZm4pO1xuICBpZih0aGF0ID09PSB1bmRlZmluZWQpcmV0dXJuIGZuO1xuICBzd2l0Y2gobGVuZ3RoKXtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbihhKXtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEpO1xuICAgIH07XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24oYSwgYil7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiKTtcbiAgICB9O1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKGEsIGIsIGMpe1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24oLyogLi4uYXJncyAqLyl7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gIH07XG59OyIsIi8vIDcuMi4xIFJlcXVpcmVPYmplY3RDb2VyY2libGUoYXJndW1lbnQpXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYoaXQgPT0gdW5kZWZpbmVkKXRocm93IFR5cGVFcnJvcihcIkNhbid0IGNhbGwgbWV0aG9kIG9uICBcIiArIGl0KTtcbiAgcmV0dXJuIGl0O1xufTsiLCIvLyBUaGFuaydzIElFOCBmb3IgaGlzIGZ1bm55IGRlZmluZVByb3BlcnR5XG5tb2R1bGUuZXhwb3J0cyA9ICFyZXF1aXJlKCcuLyQuZmFpbHMnKShmdW5jdGlvbigpe1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnYScsIHtnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiA3OyB9fSkuYSAhPSA3O1xufSk7IiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi8kLmlzLW9iamVjdCcpXG4gICwgZG9jdW1lbnQgPSByZXF1aXJlKCcuLyQuZ2xvYmFsJykuZG9jdW1lbnRcbiAgLy8gaW4gb2xkIElFIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnXG4gICwgaXMgPSBpc09iamVjdChkb2N1bWVudCkgJiYgaXNPYmplY3QoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGlzID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07IiwiLy8gYWxsIGVudW1lcmFibGUgb2JqZWN0IGtleXMsIGluY2x1ZGVzIHN5bWJvbHNcbnZhciAkID0gcmVxdWlyZSgnLi8kJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgdmFyIGtleXMgICAgICAgPSAkLmdldEtleXMoaXQpXG4gICAgLCBnZXRTeW1ib2xzID0gJC5nZXRTeW1ib2xzO1xuICBpZihnZXRTeW1ib2xzKXtcbiAgICB2YXIgc3ltYm9scyA9IGdldFN5bWJvbHMoaXQpXG4gICAgICAsIGlzRW51bSAgPSAkLmlzRW51bVxuICAgICAgLCBpICAgICAgID0gMFxuICAgICAgLCBrZXk7XG4gICAgd2hpbGUoc3ltYm9scy5sZW5ndGggPiBpKWlmKGlzRW51bS5jYWxsKGl0LCBrZXkgPSBzeW1ib2xzW2krK10pKWtleXMucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiBrZXlzO1xufTsiLCJ2YXIgZ2xvYmFsICAgID0gcmVxdWlyZSgnLi8kLmdsb2JhbCcpXG4gICwgY29yZSAgICAgID0gcmVxdWlyZSgnLi8kLmNvcmUnKVxuICAsIGN0eCAgICAgICA9IHJlcXVpcmUoJy4vJC5jdHgnKVxuICAsIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuXG52YXIgJGV4cG9ydCA9IGZ1bmN0aW9uKHR5cGUsIG5hbWUsIHNvdXJjZSl7XG4gIHZhciBJU19GT1JDRUQgPSB0eXBlICYgJGV4cG9ydC5GXG4gICAgLCBJU19HTE9CQUwgPSB0eXBlICYgJGV4cG9ydC5HXG4gICAgLCBJU19TVEFUSUMgPSB0eXBlICYgJGV4cG9ydC5TXG4gICAgLCBJU19QUk9UTyAgPSB0eXBlICYgJGV4cG9ydC5QXG4gICAgLCBJU19CSU5EICAgPSB0eXBlICYgJGV4cG9ydC5CXG4gICAgLCBJU19XUkFQICAgPSB0eXBlICYgJGV4cG9ydC5XXG4gICAgLCBleHBvcnRzICAgPSBJU19HTE9CQUwgPyBjb3JlIDogY29yZVtuYW1lXSB8fCAoY29yZVtuYW1lXSA9IHt9KVxuICAgICwgdGFyZ2V0ICAgID0gSVNfR0xPQkFMID8gZ2xvYmFsIDogSVNfU1RBVElDID8gZ2xvYmFsW25hbWVdIDogKGdsb2JhbFtuYW1lXSB8fCB7fSlbUFJPVE9UWVBFXVxuICAgICwga2V5LCBvd24sIG91dDtcbiAgaWYoSVNfR0xPQkFMKXNvdXJjZSA9IG5hbWU7XG4gIGZvcihrZXkgaW4gc291cmNlKXtcbiAgICAvLyBjb250YWlucyBpbiBuYXRpdmVcbiAgICBvd24gPSAhSVNfRk9SQ0VEICYmIHRhcmdldCAmJiBrZXkgaW4gdGFyZ2V0O1xuICAgIGlmKG93biAmJiBrZXkgaW4gZXhwb3J0cyljb250aW51ZTtcbiAgICAvLyBleHBvcnQgbmF0aXZlIG9yIHBhc3NlZFxuICAgIG91dCA9IG93biA/IHRhcmdldFtrZXldIDogc291cmNlW2tleV07XG4gICAgLy8gcHJldmVudCBnbG9iYWwgcG9sbHV0aW9uIGZvciBuYW1lc3BhY2VzXG4gICAgZXhwb3J0c1trZXldID0gSVNfR0xPQkFMICYmIHR5cGVvZiB0YXJnZXRba2V5XSAhPSAnZnVuY3Rpb24nID8gc291cmNlW2tleV1cbiAgICAvLyBiaW5kIHRpbWVycyB0byBnbG9iYWwgZm9yIGNhbGwgZnJvbSBleHBvcnQgY29udGV4dFxuICAgIDogSVNfQklORCAmJiBvd24gPyBjdHgob3V0LCBnbG9iYWwpXG4gICAgLy8gd3JhcCBnbG9iYWwgY29uc3RydWN0b3JzIGZvciBwcmV2ZW50IGNoYW5nZSB0aGVtIGluIGxpYnJhcnlcbiAgICA6IElTX1dSQVAgJiYgdGFyZ2V0W2tleV0gPT0gb3V0ID8gKGZ1bmN0aW9uKEMpe1xuICAgICAgdmFyIEYgPSBmdW5jdGlvbihwYXJhbSl7XG4gICAgICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgQyA/IG5ldyBDKHBhcmFtKSA6IEMocGFyYW0pO1xuICAgICAgfTtcbiAgICAgIEZbUFJPVE9UWVBFXSA9IENbUFJPVE9UWVBFXTtcbiAgICAgIHJldHVybiBGO1xuICAgIC8vIG1ha2Ugc3RhdGljIHZlcnNpb25zIGZvciBwcm90b3R5cGUgbWV0aG9kc1xuICAgIH0pKG91dCkgOiBJU19QUk9UTyAmJiB0eXBlb2Ygb3V0ID09ICdmdW5jdGlvbicgPyBjdHgoRnVuY3Rpb24uY2FsbCwgb3V0KSA6IG91dDtcbiAgICBpZihJU19QUk9UTykoZXhwb3J0c1tQUk9UT1RZUEVdIHx8IChleHBvcnRzW1BST1RPVFlQRV0gPSB7fSkpW2tleV0gPSBvdXQ7XG4gIH1cbn07XG4vLyB0eXBlIGJpdG1hcFxuJGV4cG9ydC5GID0gMTsgIC8vIGZvcmNlZFxuJGV4cG9ydC5HID0gMjsgIC8vIGdsb2JhbFxuJGV4cG9ydC5TID0gNDsgIC8vIHN0YXRpY1xuJGV4cG9ydC5QID0gODsgIC8vIHByb3RvXG4kZXhwb3J0LkIgPSAxNjsgLy8gYmluZFxuJGV4cG9ydC5XID0gMzI7IC8vIHdyYXBcbm1vZHVsZS5leHBvcnRzID0gJGV4cG9ydDsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGV4ZWMpe1xuICB0cnkge1xuICAgIHJldHVybiAhIWV4ZWMoKTtcbiAgfSBjYXRjaChlKXtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTsiLCJ2YXIgY3R4ICAgICAgICAgPSByZXF1aXJlKCcuLyQuY3R4JylcbiAgLCBjYWxsICAgICAgICA9IHJlcXVpcmUoJy4vJC5pdGVyLWNhbGwnKVxuICAsIGlzQXJyYXlJdGVyID0gcmVxdWlyZSgnLi8kLmlzLWFycmF5LWl0ZXInKVxuICAsIGFuT2JqZWN0ICAgID0gcmVxdWlyZSgnLi8kLmFuLW9iamVjdCcpXG4gICwgdG9MZW5ndGggICAgPSByZXF1aXJlKCcuLyQudG8tbGVuZ3RoJylcbiAgLCBnZXRJdGVyRm4gICA9IHJlcXVpcmUoJy4vY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0ZXJhYmxlLCBlbnRyaWVzLCBmbiwgdGhhdCl7XG4gIHZhciBpdGVyRm4gPSBnZXRJdGVyRm4oaXRlcmFibGUpXG4gICAgLCBmICAgICAgPSBjdHgoZm4sIHRoYXQsIGVudHJpZXMgPyAyIDogMSlcbiAgICAsIGluZGV4ICA9IDBcbiAgICAsIGxlbmd0aCwgc3RlcCwgaXRlcmF0b3I7XG4gIGlmKHR5cGVvZiBpdGVyRm4gIT0gJ2Z1bmN0aW9uJyl0aHJvdyBUeXBlRXJyb3IoaXRlcmFibGUgKyAnIGlzIG5vdCBpdGVyYWJsZSEnKTtcbiAgLy8gZmFzdCBjYXNlIGZvciBhcnJheXMgd2l0aCBkZWZhdWx0IGl0ZXJhdG9yXG4gIGlmKGlzQXJyYXlJdGVyKGl0ZXJGbikpZm9yKGxlbmd0aCA9IHRvTGVuZ3RoKGl0ZXJhYmxlLmxlbmd0aCk7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKXtcbiAgICBlbnRyaWVzID8gZihhbk9iamVjdChzdGVwID0gaXRlcmFibGVbaW5kZXhdKVswXSwgc3RlcFsxXSkgOiBmKGl0ZXJhYmxlW2luZGV4XSk7XG4gIH0gZWxzZSBmb3IoaXRlcmF0b3IgPSBpdGVyRm4uY2FsbChpdGVyYWJsZSk7ICEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZTsgKXtcbiAgICBjYWxsKGl0ZXJhdG9yLCBmLCBzdGVwLnZhbHVlLCBlbnRyaWVzKTtcbiAgfVxufTsiLCIvLyBmYWxsYmFjayBmb3IgSUUxMSBidWdneSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB3aXRoIGlmcmFtZSBhbmQgd2luZG93XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi8kLnRvLWlvYmplY3QnKVxuICAsIGdldE5hbWVzICA9IHJlcXVpcmUoJy4vJCcpLmdldE5hbWVzXG4gICwgdG9TdHJpbmcgID0ge30udG9TdHJpbmc7XG5cbnZhciB3aW5kb3dOYW1lcyA9IHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXNcbiAgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh3aW5kb3cpIDogW107XG5cbnZhciBnZXRXaW5kb3dOYW1lcyA9IGZ1bmN0aW9uKGl0KXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZ2V0TmFtZXMoaXQpO1xuICB9IGNhdGNoKGUpe1xuICAgIHJldHVybiB3aW5kb3dOYW1lcy5zbGljZSgpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5nZXQgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KXtcbiAgaWYod2luZG93TmFtZXMgJiYgdG9TdHJpbmcuY2FsbChpdCkgPT0gJ1tvYmplY3QgV2luZG93XScpcmV0dXJuIGdldFdpbmRvd05hbWVzKGl0KTtcbiAgcmV0dXJuIGdldE5hbWVzKHRvSU9iamVjdChpdCkpO1xufTsiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxudmFyIGdsb2JhbCA9IG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTWF0aCA9PSBNYXRoXG4gID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5NYXRoID09IE1hdGggPyBzZWxmIDogRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbmlmKHR5cGVvZiBfX2cgPT0gJ251bWJlcicpX19nID0gZ2xvYmFsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmIiwidmFyIGhhc093blByb3BlcnR5ID0ge30uaGFzT3duUHJvcGVydHk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCBrZXkpe1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChpdCwga2V5KTtcbn07IiwidmFyICQgICAgICAgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuLyQucHJvcGVydHktZGVzYycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLyQuZGVzY3JpcHRvcnMnKSA/IGZ1bmN0aW9uKG9iamVjdCwga2V5LCB2YWx1ZSl7XG4gIHJldHVybiAkLnNldERlc2Mob2JqZWN0LCBrZXksIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcbn0gOiBmdW5jdGlvbihvYmplY3QsIGtleSwgdmFsdWUpe1xuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICByZXR1cm4gb2JqZWN0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vJC5nbG9iYWwnKS5kb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7IiwiLy8gZmFzdCBhcHBseSwgaHR0cDovL2pzcGVyZi5sbmtpdC5jb20vZmFzdC1hcHBseS81XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGZuLCBhcmdzLCB0aGF0KXtcbiAgdmFyIHVuID0gdGhhdCA9PT0gdW5kZWZpbmVkO1xuICBzd2l0Y2goYXJncy5sZW5ndGgpe1xuICAgIGNhc2UgMDogcmV0dXJuIHVuID8gZm4oKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0KTtcbiAgICBjYXNlIDE6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0pO1xuICAgIGNhc2UgMjogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgY2FzZSAzOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICBjYXNlIDQ6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pO1xuICB9IHJldHVybiAgICAgICAgICAgICAgZm4uYXBwbHkodGhhdCwgYXJncyk7XG59OyIsIi8vIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgYW5kIG5vbi1lbnVtZXJhYmxlIG9sZCBWOCBzdHJpbmdzXG52YXIgY29mID0gcmVxdWlyZSgnLi8kLmNvZicpO1xubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QoJ3onKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKSA/IE9iamVjdCA6IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGNvZihpdCkgPT0gJ1N0cmluZycgPyBpdC5zcGxpdCgnJykgOiBPYmplY3QoaXQpO1xufTsiLCIvLyBjaGVjayBvbiBkZWZhdWx0IEFycmF5IGl0ZXJhdG9yXG52YXIgSXRlcmF0b3JzICA9IHJlcXVpcmUoJy4vJC5pdGVyYXRvcnMnKVxuICAsIElURVJBVE9SICAgPSByZXF1aXJlKCcuLyQud2tzJykoJ2l0ZXJhdG9yJylcbiAgLCBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGl0ICE9PSB1bmRlZmluZWQgJiYgKEl0ZXJhdG9ycy5BcnJheSA9PT0gaXQgfHwgQXJyYXlQcm90b1tJVEVSQVRPUl0gPT09IGl0KTtcbn07IiwiLy8gNy4yLjIgSXNBcnJheShhcmd1bWVudClcbnZhciBjb2YgPSByZXF1aXJlKCcuLyQuY29mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24oYXJnKXtcbiAgcmV0dXJuIGNvZihhcmcpID09ICdBcnJheSc7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gdHlwZW9mIGl0ID09PSAnb2JqZWN0JyA/IGl0ICE9PSBudWxsIDogdHlwZW9mIGl0ID09PSAnZnVuY3Rpb24nO1xufTsiLCIvLyBjYWxsIHNvbWV0aGluZyBvbiBpdGVyYXRvciBzdGVwIHdpdGggc2FmZSBjbG9zaW5nIG9uIGVycm9yXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLyQuYW4tb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0ZXJhdG9yLCBmbiwgdmFsdWUsIGVudHJpZXMpe1xuICB0cnkge1xuICAgIHJldHVybiBlbnRyaWVzID8gZm4oYW5PYmplY3QodmFsdWUpWzBdLCB2YWx1ZVsxXSkgOiBmbih2YWx1ZSk7XG4gIC8vIDcuNC42IEl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IsIGNvbXBsZXRpb24pXG4gIH0gY2F0Y2goZSl7XG4gICAgdmFyIHJldCA9IGl0ZXJhdG9yWydyZXR1cm4nXTtcbiAgICBpZihyZXQgIT09IHVuZGVmaW5lZClhbk9iamVjdChyZXQuY2FsbChpdGVyYXRvcikpO1xuICAgIHRocm93IGU7XG4gIH1cbn07IiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCBkZXNjcmlwdG9yICAgICA9IHJlcXVpcmUoJy4vJC5wcm9wZXJ0eS1kZXNjJylcbiAgLCBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vJC5zZXQtdG8tc3RyaW5nLXRhZycpXG4gICwgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcblxuLy8gMjUuMS4yLjEuMSAlSXRlcmF0b3JQcm90b3R5cGUlW0BAaXRlcmF0b3JdKClcbnJlcXVpcmUoJy4vJC5oaWRlJykoSXRlcmF0b3JQcm90b3R5cGUsIHJlcXVpcmUoJy4vJC53a3MnKSgnaXRlcmF0b3InKSwgZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXM7IH0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KXtcbiAgQ29uc3RydWN0b3IucHJvdG90eXBlID0gJC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUsIHtuZXh0OiBkZXNjcmlwdG9yKDEsIG5leHQpfSk7XG4gIHNldFRvU3RyaW5nVGFnKENvbnN0cnVjdG9yLCBOQU1FICsgJyBJdGVyYXRvcicpO1xufTsiLCIndXNlIHN0cmljdCc7XG52YXIgTElCUkFSWSAgICAgICAgPSByZXF1aXJlKCcuLyQubGlicmFyeScpXG4gICwgJGV4cG9ydCAgICAgICAgPSByZXF1aXJlKCcuLyQuZXhwb3J0JylcbiAgLCByZWRlZmluZSAgICAgICA9IHJlcXVpcmUoJy4vJC5yZWRlZmluZScpXG4gICwgaGlkZSAgICAgICAgICAgPSByZXF1aXJlKCcuLyQuaGlkZScpXG4gICwgaGFzICAgICAgICAgICAgPSByZXF1aXJlKCcuLyQuaGFzJylcbiAgLCBJdGVyYXRvcnMgICAgICA9IHJlcXVpcmUoJy4vJC5pdGVyYXRvcnMnKVxuICAsICRpdGVyQ3JlYXRlICAgID0gcmVxdWlyZSgnLi8kLml0ZXItY3JlYXRlJylcbiAgLCBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vJC5zZXQtdG8tc3RyaW5nLXRhZycpXG4gICwgZ2V0UHJvdG8gICAgICAgPSByZXF1aXJlKCcuLyQnKS5nZXRQcm90b1xuICAsIElURVJBVE9SICAgICAgID0gcmVxdWlyZSgnLi8kLndrcycpKCdpdGVyYXRvcicpXG4gICwgQlVHR1kgICAgICAgICAgPSAhKFtdLmtleXMgJiYgJ25leHQnIGluIFtdLmtleXMoKSkgLy8gU2FmYXJpIGhhcyBidWdneSBpdGVyYXRvcnMgdy9vIGBuZXh0YFxuICAsIEZGX0lURVJBVE9SICAgID0gJ0BAaXRlcmF0b3InXG4gICwgS0VZUyAgICAgICAgICAgPSAna2V5cydcbiAgLCBWQUxVRVMgICAgICAgICA9ICd2YWx1ZXMnO1xuXG52YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzOyB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKEJhc2UsIE5BTUUsIENvbnN0cnVjdG9yLCBuZXh0LCBERUZBVUxULCBJU19TRVQsIEZPUkNFRCl7XG4gICRpdGVyQ3JlYXRlKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KTtcbiAgdmFyIGdldE1ldGhvZCA9IGZ1bmN0aW9uKGtpbmQpe1xuICAgIGlmKCFCVUdHWSAmJiBraW5kIGluIHByb3RvKXJldHVybiBwcm90b1traW5kXTtcbiAgICBzd2l0Y2goa2luZCl7XG4gICAgICBjYXNlIEtFWVM6IHJldHVybiBmdW5jdGlvbiBrZXlzKCl7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gICAgICBjYXNlIFZBTFVFUzogcmV0dXJuIGZ1bmN0aW9uIHZhbHVlcygpeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgIH0gcmV0dXJuIGZ1bmN0aW9uIGVudHJpZXMoKXsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgfTtcbiAgdmFyIFRBRyAgICAgICAgPSBOQU1FICsgJyBJdGVyYXRvcidcbiAgICAsIERFRl9WQUxVRVMgPSBERUZBVUxUID09IFZBTFVFU1xuICAgICwgVkFMVUVTX0JVRyA9IGZhbHNlXG4gICAgLCBwcm90byAgICAgID0gQmFzZS5wcm90b3R5cGVcbiAgICAsICRuYXRpdmUgICAgPSBwcm90b1tJVEVSQVRPUl0gfHwgcHJvdG9bRkZfSVRFUkFUT1JdIHx8IERFRkFVTFQgJiYgcHJvdG9bREVGQVVMVF1cbiAgICAsICRkZWZhdWx0ICAgPSAkbmF0aXZlIHx8IGdldE1ldGhvZChERUZBVUxUKVxuICAgICwgbWV0aG9kcywga2V5O1xuICAvLyBGaXggbmF0aXZlXG4gIGlmKCRuYXRpdmUpe1xuICAgIHZhciBJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvKCRkZWZhdWx0LmNhbGwobmV3IEJhc2UpKTtcbiAgICAvLyBTZXQgQEB0b1N0cmluZ1RhZyB0byBuYXRpdmUgaXRlcmF0b3JzXG4gICAgc2V0VG9TdHJpbmdUYWcoSXRlcmF0b3JQcm90b3R5cGUsIFRBRywgdHJ1ZSk7XG4gICAgLy8gRkYgZml4XG4gICAgaWYoIUxJQlJBUlkgJiYgaGFzKHByb3RvLCBGRl9JVEVSQVRPUikpaGlkZShJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IsIHJldHVyblRoaXMpO1xuICAgIC8vIGZpeCBBcnJheSN7dmFsdWVzLCBAQGl0ZXJhdG9yfS5uYW1lIGluIFY4IC8gRkZcbiAgICBpZihERUZfVkFMVUVTICYmICRuYXRpdmUubmFtZSAhPT0gVkFMVUVTKXtcbiAgICAgIFZBTFVFU19CVUcgPSB0cnVlO1xuICAgICAgJGRlZmF1bHQgPSBmdW5jdGlvbiB2YWx1ZXMoKXsgcmV0dXJuICRuYXRpdmUuY2FsbCh0aGlzKTsgfTtcbiAgICB9XG4gIH1cbiAgLy8gRGVmaW5lIGl0ZXJhdG9yXG4gIGlmKCghTElCUkFSWSB8fCBGT1JDRUQpICYmIChCVUdHWSB8fCBWQUxVRVNfQlVHIHx8ICFwcm90b1tJVEVSQVRPUl0pKXtcbiAgICBoaWRlKHByb3RvLCBJVEVSQVRPUiwgJGRlZmF1bHQpO1xuICB9XG4gIC8vIFBsdWcgZm9yIGxpYnJhcnlcbiAgSXRlcmF0b3JzW05BTUVdID0gJGRlZmF1bHQ7XG4gIEl0ZXJhdG9yc1tUQUddICA9IHJldHVyblRoaXM7XG4gIGlmKERFRkFVTFQpe1xuICAgIG1ldGhvZHMgPSB7XG4gICAgICB2YWx1ZXM6ICBERUZfVkFMVUVTICA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKFZBTFVFUyksXG4gICAgICBrZXlzOiAgICBJU19TRVQgICAgICA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKEtFWVMpLFxuICAgICAgZW50cmllczogIURFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZCgnZW50cmllcycpXG4gICAgfTtcbiAgICBpZihGT1JDRUQpZm9yKGtleSBpbiBtZXRob2RzKXtcbiAgICAgIGlmKCEoa2V5IGluIHByb3RvKSlyZWRlZmluZShwcm90bywga2V5LCBtZXRob2RzW2tleV0pO1xuICAgIH0gZWxzZSAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChCVUdHWSB8fCBWQUxVRVNfQlVHKSwgTkFNRSwgbWV0aG9kcyk7XG4gIH1cbiAgcmV0dXJuIG1ldGhvZHM7XG59OyIsInZhciBJVEVSQVRPUiAgICAgPSByZXF1aXJlKCcuLyQud2tzJykoJ2l0ZXJhdG9yJylcbiAgLCBTQUZFX0NMT1NJTkcgPSBmYWxzZTtcblxudHJ5IHtcbiAgdmFyIHJpdGVyID0gWzddW0lURVJBVE9SXSgpO1xuICByaXRlclsncmV0dXJuJ10gPSBmdW5jdGlvbigpeyBTQUZFX0NMT1NJTkcgPSB0cnVlOyB9O1xuICBBcnJheS5mcm9tKHJpdGVyLCBmdW5jdGlvbigpeyB0aHJvdyAyOyB9KTtcbn0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihleGVjLCBza2lwQ2xvc2luZyl7XG4gIGlmKCFza2lwQ2xvc2luZyAmJiAhU0FGRV9DTE9TSU5HKXJldHVybiBmYWxzZTtcbiAgdmFyIHNhZmUgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICB2YXIgYXJyICA9IFs3XVxuICAgICAgLCBpdGVyID0gYXJyW0lURVJBVE9SXSgpO1xuICAgIGl0ZXIubmV4dCA9IGZ1bmN0aW9uKCl7IHNhZmUgPSB0cnVlOyB9O1xuICAgIGFycltJVEVSQVRPUl0gPSBmdW5jdGlvbigpeyByZXR1cm4gaXRlcjsgfTtcbiAgICBleGVjKGFycik7XG4gIH0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuIHNhZmU7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZG9uZSwgdmFsdWUpe1xuICByZXR1cm4ge3ZhbHVlOiB2YWx1ZSwgZG9uZTogISFkb25lfTtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSB7fTsiLCJ2YXIgJE9iamVjdCA9IE9iamVjdDtcbm1vZHVsZS5leHBvcnRzID0ge1xuICBjcmVhdGU6ICAgICAkT2JqZWN0LmNyZWF0ZSxcbiAgZ2V0UHJvdG86ICAgJE9iamVjdC5nZXRQcm90b3R5cGVPZixcbiAgaXNFbnVtOiAgICAge30ucHJvcGVydHlJc0VudW1lcmFibGUsXG4gIGdldERlc2M6ICAgICRPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxuICBzZXREZXNjOiAgICAkT2JqZWN0LmRlZmluZVByb3BlcnR5LFxuICBzZXREZXNjczogICAkT2JqZWN0LmRlZmluZVByb3BlcnRpZXMsXG4gIGdldEtleXM6ICAgICRPYmplY3Qua2V5cyxcbiAgZ2V0TmFtZXM6ICAgJE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzLFxuICBnZXRTeW1ib2xzOiAkT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyxcbiAgZWFjaDogICAgICAgW10uZm9yRWFjaFxufTsiLCJ2YXIgJCAgICAgICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCB0b0lPYmplY3QgPSByZXF1aXJlKCcuLyQudG8taW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmplY3QsIGVsKXtcbiAgdmFyIE8gICAgICA9IHRvSU9iamVjdChvYmplY3QpXG4gICAgLCBrZXlzICAgPSAkLmdldEtleXMoTylcbiAgICAsIGxlbmd0aCA9IGtleXMubGVuZ3RoXG4gICAgLCBpbmRleCAgPSAwXG4gICAgLCBrZXk7XG4gIHdoaWxlKGxlbmd0aCA+IGluZGV4KWlmKE9ba2V5ID0ga2V5c1tpbmRleCsrXV0gPT09IGVsKXJldHVybiBrZXk7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gdHJ1ZTsiLCJ2YXIgZ2xvYmFsICAgID0gcmVxdWlyZSgnLi8kLmdsb2JhbCcpXG4gICwgbWFjcm90YXNrID0gcmVxdWlyZSgnLi8kLnRhc2snKS5zZXRcbiAgLCBPYnNlcnZlciAgPSBnbG9iYWwuTXV0YXRpb25PYnNlcnZlciB8fCBnbG9iYWwuV2ViS2l0TXV0YXRpb25PYnNlcnZlclxuICAsIHByb2Nlc3MgICA9IGdsb2JhbC5wcm9jZXNzXG4gICwgUHJvbWlzZSAgID0gZ2xvYmFsLlByb21pc2VcbiAgLCBpc05vZGUgICAgPSByZXF1aXJlKCcuLyQuY29mJykocHJvY2VzcykgPT0gJ3Byb2Nlc3MnXG4gICwgaGVhZCwgbGFzdCwgbm90aWZ5O1xuXG52YXIgZmx1c2ggPSBmdW5jdGlvbigpe1xuICB2YXIgcGFyZW50LCBkb21haW4sIGZuO1xuICBpZihpc05vZGUgJiYgKHBhcmVudCA9IHByb2Nlc3MuZG9tYWluKSl7XG4gICAgcHJvY2Vzcy5kb21haW4gPSBudWxsO1xuICAgIHBhcmVudC5leGl0KCk7XG4gIH1cbiAgd2hpbGUoaGVhZCl7XG4gICAgZG9tYWluID0gaGVhZC5kb21haW47XG4gICAgZm4gICAgID0gaGVhZC5mbjtcbiAgICBpZihkb21haW4pZG9tYWluLmVudGVyKCk7XG4gICAgZm4oKTsgLy8gPC0gY3VycmVudGx5IHdlIHVzZSBpdCBvbmx5IGZvciBQcm9taXNlIC0gdHJ5IC8gY2F0Y2ggbm90IHJlcXVpcmVkXG4gICAgaWYoZG9tYWluKWRvbWFpbi5leGl0KCk7XG4gICAgaGVhZCA9IGhlYWQubmV4dDtcbiAgfSBsYXN0ID0gdW5kZWZpbmVkO1xuICBpZihwYXJlbnQpcGFyZW50LmVudGVyKCk7XG59O1xuXG4vLyBOb2RlLmpzXG5pZihpc05vZGUpe1xuICBub3RpZnkgPSBmdW5jdGlvbigpe1xuICAgIHByb2Nlc3MubmV4dFRpY2soZmx1c2gpO1xuICB9O1xuLy8gYnJvd3NlcnMgd2l0aCBNdXRhdGlvbk9ic2VydmVyXG59IGVsc2UgaWYoT2JzZXJ2ZXIpe1xuICB2YXIgdG9nZ2xlID0gMVxuICAgICwgbm9kZSAgID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICBuZXcgT2JzZXJ2ZXIoZmx1c2gpLm9ic2VydmUobm9kZSwge2NoYXJhY3RlckRhdGE6IHRydWV9KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgbm90aWZ5ID0gZnVuY3Rpb24oKXtcbiAgICBub2RlLmRhdGEgPSB0b2dnbGUgPSAtdG9nZ2xlO1xuICB9O1xuLy8gZW52aXJvbm1lbnRzIHdpdGggbWF5YmUgbm9uLWNvbXBsZXRlbHkgY29ycmVjdCwgYnV0IGV4aXN0ZW50IFByb21pc2Vcbn0gZWxzZSBpZihQcm9taXNlICYmIFByb21pc2UucmVzb2x2ZSl7XG4gIG5vdGlmeSA9IGZ1bmN0aW9uKCl7XG4gICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmbHVzaCk7XG4gIH07XG4vLyBmb3Igb3RoZXIgZW52aXJvbm1lbnRzIC0gbWFjcm90YXNrIGJhc2VkIG9uOlxuLy8gLSBzZXRJbW1lZGlhdGVcbi8vIC0gTWVzc2FnZUNoYW5uZWxcbi8vIC0gd2luZG93LnBvc3RNZXNzYWdcbi8vIC0gb25yZWFkeXN0YXRlY2hhbmdlXG4vLyAtIHNldFRpbWVvdXRcbn0gZWxzZSB7XG4gIG5vdGlmeSA9IGZ1bmN0aW9uKCl7XG4gICAgLy8gc3RyYW5nZSBJRSArIHdlYnBhY2sgZGV2IHNlcnZlciBidWcgLSB1c2UgLmNhbGwoZ2xvYmFsKVxuICAgIG1hY3JvdGFzay5jYWxsKGdsb2JhbCwgZmx1c2gpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGFzYXAoZm4pe1xuICB2YXIgdGFzayA9IHtmbjogZm4sIG5leHQ6IHVuZGVmaW5lZCwgZG9tYWluOiBpc05vZGUgJiYgcHJvY2Vzcy5kb21haW59O1xuICBpZihsYXN0KWxhc3QubmV4dCA9IHRhc2s7XG4gIGlmKCFoZWFkKXtcbiAgICBoZWFkID0gdGFzaztcbiAgICBub3RpZnkoKTtcbiAgfSBsYXN0ID0gdGFzaztcbn07IiwiLy8gMTkuMS4yLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSwgLi4uKVxudmFyICQgICAgICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCB0b09iamVjdCA9IHJlcXVpcmUoJy4vJC50by1vYmplY3QnKVxuICAsIElPYmplY3QgID0gcmVxdWlyZSgnLi8kLmlvYmplY3QnKTtcblxuLy8gc2hvdWxkIHdvcmsgd2l0aCBzeW1ib2xzIGFuZCBzaG91bGQgaGF2ZSBkZXRlcm1pbmlzdGljIHByb3BlcnR5IG9yZGVyIChWOCBidWcpXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vJC5mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHZhciBhID0gT2JqZWN0LmFzc2lnblxuICAgICwgQSA9IHt9XG4gICAgLCBCID0ge31cbiAgICAsIFMgPSBTeW1ib2woKVxuICAgICwgSyA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdCc7XG4gIEFbU10gPSA3O1xuICBLLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uKGspeyBCW2tdID0gazsgfSk7XG4gIHJldHVybiBhKHt9LCBBKVtTXSAhPSA3IHx8IE9iamVjdC5rZXlzKGEoe30sIEIpKS5qb2luKCcnKSAhPSBLO1xufSkgPyBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCBzb3VyY2UpeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gIHZhciBUICAgICA9IHRvT2JqZWN0KHRhcmdldClcbiAgICAsICQkICAgID0gYXJndW1lbnRzXG4gICAgLCAkJGxlbiA9ICQkLmxlbmd0aFxuICAgICwgaW5kZXggPSAxXG4gICAgLCBnZXRLZXlzICAgID0gJC5nZXRLZXlzXG4gICAgLCBnZXRTeW1ib2xzID0gJC5nZXRTeW1ib2xzXG4gICAgLCBpc0VudW0gICAgID0gJC5pc0VudW07XG4gIHdoaWxlKCQkbGVuID4gaW5kZXgpe1xuICAgIHZhciBTICAgICAgPSBJT2JqZWN0KCQkW2luZGV4KytdKVxuICAgICAgLCBrZXlzICAgPSBnZXRTeW1ib2xzID8gZ2V0S2V5cyhTKS5jb25jYXQoZ2V0U3ltYm9scyhTKSkgOiBnZXRLZXlzKFMpXG4gICAgICAsIGxlbmd0aCA9IGtleXMubGVuZ3RoXG4gICAgICAsIGogICAgICA9IDBcbiAgICAgICwga2V5O1xuICAgIHdoaWxlKGxlbmd0aCA+IGopaWYoaXNFbnVtLmNhbGwoUywga2V5ID0ga2V5c1tqKytdKSlUW2tleV0gPSBTW2tleV07XG4gIH1cbiAgcmV0dXJuIFQ7XG59IDogT2JqZWN0LmFzc2lnbjsiLCIvLyBtb3N0IE9iamVjdCBtZXRob2RzIGJ5IEVTNiBzaG91bGQgYWNjZXB0IHByaW1pdGl2ZXNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi8kLmV4cG9ydCcpXG4gICwgY29yZSAgICA9IHJlcXVpcmUoJy4vJC5jb3JlJylcbiAgLCBmYWlscyAgID0gcmVxdWlyZSgnLi8kLmZhaWxzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKEtFWSwgZXhlYyl7XG4gIHZhciBmbiAgPSAoY29yZS5PYmplY3QgfHwge30pW0tFWV0gfHwgT2JqZWN0W0tFWV1cbiAgICAsIGV4cCA9IHt9O1xuICBleHBbS0VZXSA9IGV4ZWMoZm4pO1xuICAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIGZhaWxzKGZ1bmN0aW9uKCl7IGZuKDEpOyB9KSwgJ09iamVjdCcsIGV4cCk7XG59OyIsInZhciAkICAgICAgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vJC50by1pb2JqZWN0JylcbiAgLCBpc0VudW0gICAgPSAkLmlzRW51bTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXNFbnRyaWVzKXtcbiAgcmV0dXJuIGZ1bmN0aW9uKGl0KXtcbiAgICB2YXIgTyAgICAgID0gdG9JT2JqZWN0KGl0KVxuICAgICAgLCBrZXlzICAgPSAkLmdldEtleXMoTylcbiAgICAgICwgbGVuZ3RoID0ga2V5cy5sZW5ndGhcbiAgICAgICwgaSAgICAgID0gMFxuICAgICAgLCByZXN1bHQgPSBbXVxuICAgICAgLCBrZXk7XG4gICAgd2hpbGUobGVuZ3RoID4gaSlpZihpc0VudW0uY2FsbChPLCBrZXkgPSBrZXlzW2krK10pKXtcbiAgICAgIHJlc3VsdC5wdXNoKGlzRW50cmllcyA/IFtrZXksIE9ba2V5XV0gOiBPW2tleV0pO1xuICAgIH0gcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihiaXRtYXAsIHZhbHVlKXtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlICA6ICEoYml0bWFwICYgMSksXG4gICAgY29uZmlndXJhYmxlOiAhKGJpdG1hcCAmIDIpLFxuICAgIHdyaXRhYmxlICAgIDogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZSAgICAgICA6IHZhbHVlXG4gIH07XG59OyIsInZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vJC5yZWRlZmluZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih0YXJnZXQsIHNyYyl7XG4gIGZvcih2YXIga2V5IGluIHNyYylyZWRlZmluZSh0YXJnZXQsIGtleSwgc3JjW2tleV0pO1xuICByZXR1cm4gdGFyZ2V0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vJC5oaWRlJyk7IiwiLy8gNy4yLjkgU2FtZVZhbHVlKHgsIHkpXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5pcyB8fCBmdW5jdGlvbiBpcyh4LCB5KXtcbiAgcmV0dXJuIHggPT09IHkgPyB4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geSA6IHggIT0geCAmJiB5ICE9IHk7XG59OyIsIi8vIFdvcmtzIHdpdGggX19wcm90b19fIG9ubHkuIE9sZCB2OCBjYW4ndCB3b3JrIHdpdGggbnVsbCBwcm90byBvYmplY3RzLlxuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbnZhciBnZXREZXNjICA9IHJlcXVpcmUoJy4vJCcpLmdldERlc2NcbiAgLCBpc09iamVjdCA9IHJlcXVpcmUoJy4vJC5pcy1vYmplY3QnKVxuICAsIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi8kLmFuLW9iamVjdCcpO1xudmFyIGNoZWNrID0gZnVuY3Rpb24oTywgcHJvdG8pe1xuICBhbk9iamVjdChPKTtcbiAgaWYoIWlzT2JqZWN0KHByb3RvKSAmJiBwcm90byAhPT0gbnVsbCl0aHJvdyBUeXBlRXJyb3IocHJvdG8gKyBcIjogY2FuJ3Qgc2V0IGFzIHByb3RvdHlwZSFcIik7XG59O1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldDogT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8ICgnX19wcm90b19fJyBpbiB7fSA/IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICBmdW5jdGlvbih0ZXN0LCBidWdneSwgc2V0KXtcbiAgICAgIHRyeSB7XG4gICAgICAgIHNldCA9IHJlcXVpcmUoJy4vJC5jdHgnKShGdW5jdGlvbi5jYWxsLCBnZXREZXNjKE9iamVjdC5wcm90b3R5cGUsICdfX3Byb3RvX18nKS5zZXQsIDIpO1xuICAgICAgICBzZXQodGVzdCwgW10pO1xuICAgICAgICBidWdneSA9ICEodGVzdCBpbnN0YW5jZW9mIEFycmF5KTtcbiAgICAgIH0gY2F0Y2goZSl7IGJ1Z2d5ID0gdHJ1ZTsgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNldFByb3RvdHlwZU9mKE8sIHByb3RvKXtcbiAgICAgICAgY2hlY2soTywgcHJvdG8pO1xuICAgICAgICBpZihidWdneSlPLl9fcHJvdG9fXyA9IHByb3RvO1xuICAgICAgICBlbHNlIHNldChPLCBwcm90byk7XG4gICAgICAgIHJldHVybiBPO1xuICAgICAgfTtcbiAgICB9KHt9LCBmYWxzZSkgOiB1bmRlZmluZWQpLFxuICBjaGVjazogY2hlY2tcbn07IiwiJ3VzZSBzdHJpY3QnO1xudmFyIGNvcmUgICAgICAgID0gcmVxdWlyZSgnLi8kLmNvcmUnKVxuICAsICQgICAgICAgICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vJC5kZXNjcmlwdG9ycycpXG4gICwgU1BFQ0lFUyAgICAgPSByZXF1aXJlKCcuLyQud2tzJykoJ3NwZWNpZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihLRVkpe1xuICB2YXIgQyA9IGNvcmVbS0VZXTtcbiAgaWYoREVTQ1JJUFRPUlMgJiYgQyAmJiAhQ1tTUEVDSUVTXSkkLnNldERlc2MoQywgU1BFQ0lFUywge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzOyB9XG4gIH0pO1xufTsiLCJ2YXIgZGVmID0gcmVxdWlyZSgnLi8kJykuc2V0RGVzY1xuICAsIGhhcyA9IHJlcXVpcmUoJy4vJC5oYXMnKVxuICAsIFRBRyA9IHJlcXVpcmUoJy4vJC53a3MnKSgndG9TdHJpbmdUYWcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwgdGFnLCBzdGF0KXtcbiAgaWYoaXQgJiYgIWhhcyhpdCA9IHN0YXQgPyBpdCA6IGl0LnByb3RvdHlwZSwgVEFHKSlkZWYoaXQsIFRBRywge2NvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IHRhZ30pO1xufTsiLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi8kLmdsb2JhbCcpXG4gICwgU0hBUkVEID0gJ19fY29yZS1qc19zaGFyZWRfXydcbiAgLCBzdG9yZSAgPSBnbG9iYWxbU0hBUkVEXSB8fCAoZ2xvYmFsW1NIQVJFRF0gPSB7fSk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGtleSl7XG4gIHJldHVybiBzdG9yZVtrZXldIHx8IChzdG9yZVtrZXldID0ge30pO1xufTsiLCIvLyA3LjMuMjAgU3BlY2llc0NvbnN0cnVjdG9yKE8sIGRlZmF1bHRDb25zdHJ1Y3RvcilcbnZhciBhbk9iamVjdCAgPSByZXF1aXJlKCcuLyQuYW4tb2JqZWN0JylcbiAgLCBhRnVuY3Rpb24gPSByZXF1aXJlKCcuLyQuYS1mdW5jdGlvbicpXG4gICwgU1BFQ0lFUyAgID0gcmVxdWlyZSgnLi8kLndrcycpKCdzcGVjaWVzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKE8sIEQpe1xuICB2YXIgQyA9IGFuT2JqZWN0KE8pLmNvbnN0cnVjdG9yLCBTO1xuICByZXR1cm4gQyA9PT0gdW5kZWZpbmVkIHx8IChTID0gYW5PYmplY3QoQylbU1BFQ0lFU10pID09IHVuZGVmaW5lZCA/IEQgOiBhRnVuY3Rpb24oUyk7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQsIENvbnN0cnVjdG9yLCBuYW1lKXtcbiAgaWYoIShpdCBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSl0aHJvdyBUeXBlRXJyb3IobmFtZSArIFwiOiB1c2UgdGhlICduZXcnIG9wZXJhdG9yIVwiKTtcbiAgcmV0dXJuIGl0O1xufTsiLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi8kLnRvLWludGVnZXInKVxuICAsIGRlZmluZWQgICA9IHJlcXVpcmUoJy4vJC5kZWZpbmVkJyk7XG4vLyB0cnVlICAtPiBTdHJpbmcjYXRcbi8vIGZhbHNlIC0+IFN0cmluZyNjb2RlUG9pbnRBdFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihUT19TVFJJTkcpe1xuICByZXR1cm4gZnVuY3Rpb24odGhhdCwgcG9zKXtcbiAgICB2YXIgcyA9IFN0cmluZyhkZWZpbmVkKHRoYXQpKVxuICAgICAgLCBpID0gdG9JbnRlZ2VyKHBvcylcbiAgICAgICwgbCA9IHMubGVuZ3RoXG4gICAgICAsIGEsIGI7XG4gICAgaWYoaSA8IDAgfHwgaSA+PSBsKXJldHVybiBUT19TVFJJTkcgPyAnJyA6IHVuZGVmaW5lZDtcbiAgICBhID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIHJldHVybiBhIDwgMHhkODAwIHx8IGEgPiAweGRiZmYgfHwgaSArIDEgPT09IGwgfHwgKGIgPSBzLmNoYXJDb2RlQXQoaSArIDEpKSA8IDB4ZGMwMCB8fCBiID4gMHhkZmZmXG4gICAgICA/IFRPX1NUUklORyA/IHMuY2hhckF0KGkpIDogYVxuICAgICAgOiBUT19TVFJJTkcgPyBzLnNsaWNlKGksIGkgKyAyKSA6IChhIC0gMHhkODAwIDw8IDEwKSArIChiIC0gMHhkYzAwKSArIDB4MTAwMDA7XG4gIH07XG59OyIsInZhciBjdHggICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuLyQuY3R4JylcbiAgLCBpbnZva2UgICAgICAgICAgICAgPSByZXF1aXJlKCcuLyQuaW52b2tlJylcbiAgLCBodG1sICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuLyQuaHRtbCcpXG4gICwgY2VsICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi8kLmRvbS1jcmVhdGUnKVxuICAsIGdsb2JhbCAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vJC5nbG9iYWwnKVxuICAsIHByb2Nlc3MgICAgICAgICAgICA9IGdsb2JhbC5wcm9jZXNzXG4gICwgc2V0VGFzayAgICAgICAgICAgID0gZ2xvYmFsLnNldEltbWVkaWF0ZVxuICAsIGNsZWFyVGFzayAgICAgICAgICA9IGdsb2JhbC5jbGVhckltbWVkaWF0ZVxuICAsIE1lc3NhZ2VDaGFubmVsICAgICA9IGdsb2JhbC5NZXNzYWdlQ2hhbm5lbFxuICAsIGNvdW50ZXIgICAgICAgICAgICA9IDBcbiAgLCBxdWV1ZSAgICAgICAgICAgICAgPSB7fVxuICAsIE9OUkVBRFlTVEFURUNIQU5HRSA9ICdvbnJlYWR5c3RhdGVjaGFuZ2UnXG4gICwgZGVmZXIsIGNoYW5uZWwsIHBvcnQ7XG52YXIgcnVuID0gZnVuY3Rpb24oKXtcbiAgdmFyIGlkID0gK3RoaXM7XG4gIGlmKHF1ZXVlLmhhc093blByb3BlcnR5KGlkKSl7XG4gICAgdmFyIGZuID0gcXVldWVbaWRdO1xuICAgIGRlbGV0ZSBxdWV1ZVtpZF07XG4gICAgZm4oKTtcbiAgfVxufTtcbnZhciBsaXN0bmVyID0gZnVuY3Rpb24oZXZlbnQpe1xuICBydW4uY2FsbChldmVudC5kYXRhKTtcbn07XG4vLyBOb2RlLmpzIDAuOSsgJiBJRTEwKyBoYXMgc2V0SW1tZWRpYXRlLCBvdGhlcndpc2U6XG5pZighc2V0VGFzayB8fCAhY2xlYXJUYXNrKXtcbiAgc2V0VGFzayA9IGZ1bmN0aW9uIHNldEltbWVkaWF0ZShmbil7XG4gICAgdmFyIGFyZ3MgPSBbXSwgaSA9IDE7XG4gICAgd2hpbGUoYXJndW1lbnRzLmxlbmd0aCA+IGkpYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcbiAgICBxdWV1ZVsrK2NvdW50ZXJdID0gZnVuY3Rpb24oKXtcbiAgICAgIGludm9rZSh0eXBlb2YgZm4gPT0gJ2Z1bmN0aW9uJyA/IGZuIDogRnVuY3Rpb24oZm4pLCBhcmdzKTtcbiAgICB9O1xuICAgIGRlZmVyKGNvdW50ZXIpO1xuICAgIHJldHVybiBjb3VudGVyO1xuICB9O1xuICBjbGVhclRhc2sgPSBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShpZCl7XG4gICAgZGVsZXRlIHF1ZXVlW2lkXTtcbiAgfTtcbiAgLy8gTm9kZS5qcyAwLjgtXG4gIGlmKHJlcXVpcmUoJy4vJC5jb2YnKShwcm9jZXNzKSA9PSAncHJvY2Vzcycpe1xuICAgIGRlZmVyID0gZnVuY3Rpb24oaWQpe1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhjdHgocnVuLCBpZCwgMSkpO1xuICAgIH07XG4gIC8vIEJyb3dzZXJzIHdpdGggTWVzc2FnZUNoYW5uZWwsIGluY2x1ZGVzIFdlYldvcmtlcnNcbiAgfSBlbHNlIGlmKE1lc3NhZ2VDaGFubmVsKXtcbiAgICBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsO1xuICAgIHBvcnQgICAgPSBjaGFubmVsLnBvcnQyO1xuICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gbGlzdG5lcjtcbiAgICBkZWZlciA9IGN0eChwb3J0LnBvc3RNZXNzYWdlLCBwb3J0LCAxKTtcbiAgLy8gQnJvd3NlcnMgd2l0aCBwb3N0TWVzc2FnZSwgc2tpcCBXZWJXb3JrZXJzXG4gIC8vIElFOCBoYXMgcG9zdE1lc3NhZ2UsIGJ1dCBpdCdzIHN5bmMgJiB0eXBlb2YgaXRzIHBvc3RNZXNzYWdlIGlzICdvYmplY3QnXG4gIH0gZWxzZSBpZihnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lciAmJiB0eXBlb2YgcG9zdE1lc3NhZ2UgPT0gJ2Z1bmN0aW9uJyAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpe1xuICAgIGRlZmVyID0gZnVuY3Rpb24oaWQpe1xuICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKGlkICsgJycsICcqJyk7XG4gICAgfTtcbiAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGxpc3RuZXIsIGZhbHNlKTtcbiAgLy8gSUU4LVxuICB9IGVsc2UgaWYoT05SRUFEWVNUQVRFQ0hBTkdFIGluIGNlbCgnc2NyaXB0Jykpe1xuICAgIGRlZmVyID0gZnVuY3Rpb24oaWQpe1xuICAgICAgaHRtbC5hcHBlbmRDaGlsZChjZWwoJ3NjcmlwdCcpKVtPTlJFQURZU1RBVEVDSEFOR0VdID0gZnVuY3Rpb24oKXtcbiAgICAgICAgaHRtbC5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgICAgICAgcnVuLmNhbGwoaWQpO1xuICAgICAgfTtcbiAgICB9O1xuICAvLyBSZXN0IG9sZCBicm93c2Vyc1xuICB9IGVsc2Uge1xuICAgIGRlZmVyID0gZnVuY3Rpb24oaWQpe1xuICAgICAgc2V0VGltZW91dChjdHgocnVuLCBpZCwgMSksIDApO1xuICAgIH07XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXQ6ICAgc2V0VGFzayxcbiAgY2xlYXI6IGNsZWFyVGFza1xufTsiLCIvLyA3LjEuNCBUb0ludGVnZXJcbnZhciBjZWlsICA9IE1hdGguY2VpbFxuICAsIGZsb29yID0gTWF0aC5mbG9vcjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXNOYU4oaXQgPSAraXQpID8gMCA6IChpdCA+IDAgPyBmbG9vciA6IGNlaWwpKGl0KTtcbn07IiwiLy8gdG8gaW5kZXhlZCBvYmplY3QsIHRvT2JqZWN0IHdpdGggZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBzdHJpbmdzXG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vJC5pb2JqZWN0JylcbiAgLCBkZWZpbmVkID0gcmVxdWlyZSgnLi8kLmRlZmluZWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gSU9iamVjdChkZWZpbmVkKGl0KSk7XG59OyIsIi8vIDcuMS4xNSBUb0xlbmd0aFxudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vJC50by1pbnRlZ2VyJylcbiAgLCBtaW4gICAgICAgPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXQgPiAwID8gbWluKHRvSW50ZWdlcihpdCksIDB4MWZmZmZmZmZmZmZmZmYpIDogMDsgLy8gcG93KDIsIDUzKSAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxufTsiLCIvLyA3LjEuMTMgVG9PYmplY3QoYXJndW1lbnQpXG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vJC5kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIE9iamVjdChkZWZpbmVkKGl0KSk7XG59OyIsInZhciBpZCA9IDBcbiAgLCBweCA9IE1hdGgucmFuZG9tKCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGtleSl7XG4gIHJldHVybiAnU3ltYm9sKCcuY29uY2F0KGtleSA9PT0gdW5kZWZpbmVkID8gJycgOiBrZXksICcpXycsICgrK2lkICsgcHgpLnRvU3RyaW5nKDM2KSk7XG59OyIsInZhciBzdG9yZSAgPSByZXF1aXJlKCcuLyQuc2hhcmVkJykoJ3drcycpXG4gICwgdWlkICAgID0gcmVxdWlyZSgnLi8kLnVpZCcpXG4gICwgU3ltYm9sID0gcmVxdWlyZSgnLi8kLmdsb2JhbCcpLlN5bWJvbDtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obmFtZSl7XG4gIHJldHVybiBzdG9yZVtuYW1lXSB8fCAoc3RvcmVbbmFtZV0gPVxuICAgIFN5bWJvbCAmJiBTeW1ib2xbbmFtZV0gfHwgKFN5bWJvbCB8fCB1aWQpKCdTeW1ib2wuJyArIG5hbWUpKTtcbn07IiwidmFyIGNsYXNzb2YgICA9IHJlcXVpcmUoJy4vJC5jbGFzc29mJylcbiAgLCBJVEVSQVRPUiAgPSByZXF1aXJlKCcuLyQud2tzJykoJ2l0ZXJhdG9yJylcbiAgLCBJdGVyYXRvcnMgPSByZXF1aXJlKCcuLyQuaXRlcmF0b3JzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vJC5jb3JlJykuZ2V0SXRlcmF0b3JNZXRob2QgPSBmdW5jdGlvbihpdCl7XG4gIGlmKGl0ICE9IHVuZGVmaW5lZClyZXR1cm4gaXRbSVRFUkFUT1JdXG4gICAgfHwgaXRbJ0BAaXRlcmF0b3InXVxuICAgIHx8IEl0ZXJhdG9yc1tjbGFzc29mKGl0KV07XG59OyIsInZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vJC5hbi1vYmplY3QnKVxuICAsIGdldCAgICAgID0gcmVxdWlyZSgnLi9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi8kLmNvcmUnKS5nZXRJdGVyYXRvciA9IGZ1bmN0aW9uKGl0KXtcbiAgdmFyIGl0ZXJGbiA9IGdldChpdCk7XG4gIGlmKHR5cGVvZiBpdGVyRm4gIT0gJ2Z1bmN0aW9uJyl0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBpdGVyYWJsZSEnKTtcbiAgcmV0dXJuIGFuT2JqZWN0KGl0ZXJGbi5jYWxsKGl0KSk7XG59OyIsIid1c2Ugc3RyaWN0JztcbnZhciBjdHggICAgICAgICA9IHJlcXVpcmUoJy4vJC5jdHgnKVxuICAsICRleHBvcnQgICAgID0gcmVxdWlyZSgnLi8kLmV4cG9ydCcpXG4gICwgdG9PYmplY3QgICAgPSByZXF1aXJlKCcuLyQudG8tb2JqZWN0JylcbiAgLCBjYWxsICAgICAgICA9IHJlcXVpcmUoJy4vJC5pdGVyLWNhbGwnKVxuICAsIGlzQXJyYXlJdGVyID0gcmVxdWlyZSgnLi8kLmlzLWFycmF5LWl0ZXInKVxuICAsIHRvTGVuZ3RoICAgID0gcmVxdWlyZSgnLi8kLnRvLWxlbmd0aCcpXG4gICwgZ2V0SXRlckZuICAgPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi8kLml0ZXItZGV0ZWN0JykoZnVuY3Rpb24oaXRlcil7IEFycmF5LmZyb20oaXRlcik7IH0pLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMi4xIEFycmF5LmZyb20oYXJyYXlMaWtlLCBtYXBmbiA9IHVuZGVmaW5lZCwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgZnJvbTogZnVuY3Rpb24gZnJvbShhcnJheUxpa2UvKiwgbWFwZm4gPSB1bmRlZmluZWQsIHRoaXNBcmcgPSB1bmRlZmluZWQqLyl7XG4gICAgdmFyIE8gICAgICAgPSB0b09iamVjdChhcnJheUxpa2UpXG4gICAgICAsIEMgICAgICAgPSB0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nID8gdGhpcyA6IEFycmF5XG4gICAgICAsICQkICAgICAgPSBhcmd1bWVudHNcbiAgICAgICwgJCRsZW4gICA9ICQkLmxlbmd0aFxuICAgICAgLCBtYXBmbiAgID0gJCRsZW4gPiAxID8gJCRbMV0gOiB1bmRlZmluZWRcbiAgICAgICwgbWFwcGluZyA9IG1hcGZuICE9PSB1bmRlZmluZWRcbiAgICAgICwgaW5kZXggICA9IDBcbiAgICAgICwgaXRlckZuICA9IGdldEl0ZXJGbihPKVxuICAgICAgLCBsZW5ndGgsIHJlc3VsdCwgc3RlcCwgaXRlcmF0b3I7XG4gICAgaWYobWFwcGluZyltYXBmbiA9IGN0eChtYXBmbiwgJCRsZW4gPiAyID8gJCRbMl0gOiB1bmRlZmluZWQsIDIpO1xuICAgIC8vIGlmIG9iamVjdCBpc24ndCBpdGVyYWJsZSBvciBpdCdzIGFycmF5IHdpdGggZGVmYXVsdCBpdGVyYXRvciAtIHVzZSBzaW1wbGUgY2FzZVxuICAgIGlmKGl0ZXJGbiAhPSB1bmRlZmluZWQgJiYgIShDID09IEFycmF5ICYmIGlzQXJyYXlJdGVyKGl0ZXJGbikpKXtcbiAgICAgIGZvcihpdGVyYXRvciA9IGl0ZXJGbi5jYWxsKE8pLCByZXN1bHQgPSBuZXcgQzsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOyBpbmRleCsrKXtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IG1hcHBpbmcgPyBjYWxsKGl0ZXJhdG9yLCBtYXBmbiwgW3N0ZXAudmFsdWUsIGluZGV4XSwgdHJ1ZSkgOiBzdGVwLnZhbHVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gICAgICBmb3IocmVzdWx0ID0gbmV3IEMobGVuZ3RoKTsgbGVuZ3RoID4gaW5kZXg7IGluZGV4Kyspe1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gbWFwcGluZyA/IG1hcGZuKE9baW5kZXhdLCBpbmRleCkgOiBPW2luZGV4XTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0Lmxlbmd0aCA9IGluZGV4O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFkZFRvVW5zY29wYWJsZXMgPSByZXF1aXJlKCcuLyQuYWRkLXRvLXVuc2NvcGFibGVzJylcbiAgLCBzdGVwICAgICAgICAgICAgID0gcmVxdWlyZSgnLi8kLml0ZXItc3RlcCcpXG4gICwgSXRlcmF0b3JzICAgICAgICA9IHJlcXVpcmUoJy4vJC5pdGVyYXRvcnMnKVxuICAsIHRvSU9iamVjdCAgICAgICAgPSByZXF1aXJlKCcuLyQudG8taW9iamVjdCcpO1xuXG4vLyAyMi4xLjMuNCBBcnJheS5wcm90b3R5cGUuZW50cmllcygpXG4vLyAyMi4xLjMuMTMgQXJyYXkucHJvdG90eXBlLmtleXMoKVxuLy8gMjIuMS4zLjI5IEFycmF5LnByb3RvdHlwZS52YWx1ZXMoKVxuLy8gMjIuMS4zLjMwIEFycmF5LnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vJC5pdGVyLWRlZmluZScpKEFycmF5LCAnQXJyYXknLCBmdW5jdGlvbihpdGVyYXRlZCwga2luZCl7XG4gIHRoaXMuX3QgPSB0b0lPYmplY3QoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbiAgdGhpcy5fayA9IGtpbmQ7ICAgICAgICAgICAgICAgIC8vIGtpbmRcbi8vIDIyLjEuNS4yLjEgJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24oKXtcbiAgdmFyIE8gICAgID0gdGhpcy5fdFxuICAgICwga2luZCAgPSB0aGlzLl9rXG4gICAgLCBpbmRleCA9IHRoaXMuX2krKztcbiAgaWYoIU8gfHwgaW5kZXggPj0gTy5sZW5ndGgpe1xuICAgIHRoaXMuX3QgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHN0ZXAoMSk7XG4gIH1cbiAgaWYoa2luZCA9PSAna2V5cycgIClyZXR1cm4gc3RlcCgwLCBpbmRleCk7XG4gIGlmKGtpbmQgPT0gJ3ZhbHVlcycpcmV0dXJuIHN0ZXAoMCwgT1tpbmRleF0pO1xuICByZXR1cm4gc3RlcCgwLCBbaW5kZXgsIE9baW5kZXhdXSk7XG59LCAndmFsdWVzJyk7XG5cbi8vIGFyZ3VtZW50c0xpc3RbQEBpdGVyYXRvcl0gaXMgJUFycmF5UHJvdG9fdmFsdWVzJSAoOS40LjQuNiwgOS40LjQuNylcbkl0ZXJhdG9ycy5Bcmd1bWVudHMgPSBJdGVyYXRvcnMuQXJyYXk7XG5cbmFkZFRvVW5zY29wYWJsZXMoJ2tleXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ3ZhbHVlcycpO1xuYWRkVG9VbnNjb3BhYmxlcygnZW50cmllcycpOyIsIi8vIDE5LjEuMy4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vJC5leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYsICdPYmplY3QnLCB7YXNzaWduOiByZXF1aXJlKCcuLyQub2JqZWN0LWFzc2lnbicpfSk7IiwiLy8gMTkuMS4yLjUgT2JqZWN0LmZyZWV6ZShPKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi8kLmlzLW9iamVjdCcpO1xuXG5yZXF1aXJlKCcuLyQub2JqZWN0LXNhcCcpKCdmcmVlemUnLCBmdW5jdGlvbigkZnJlZXplKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGZyZWV6ZShpdCl7XG4gICAgcmV0dXJuICRmcmVlemUgJiYgaXNPYmplY3QoaXQpID8gJGZyZWV6ZShpdCkgOiBpdDtcbiAgfTtcbn0pOyIsIi8vIDE5LjEuMi4xNCBPYmplY3Qua2V5cyhPKVxudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi8kLnRvLW9iamVjdCcpO1xuXG5yZXF1aXJlKCcuLyQub2JqZWN0LXNhcCcpKCdrZXlzJywgZnVuY3Rpb24oJGtleXMpe1xuICByZXR1cm4gZnVuY3Rpb24ga2V5cyhpdCl7XG4gICAgcmV0dXJuICRrZXlzKHRvT2JqZWN0KGl0KSk7XG4gIH07XG59KTsiLCIvLyAxOS4xLjMuMTkgT2JqZWN0LnNldFByb3RvdHlwZU9mKE8sIHByb3RvKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuLyQuZXhwb3J0Jyk7XG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHtzZXRQcm90b3R5cGVPZjogcmVxdWlyZSgnLi8kLnNldC1wcm90bycpLnNldH0pOyIsbnVsbCwiJ3VzZSBzdHJpY3QnO1xudmFyICQgICAgICAgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsIExJQlJBUlkgICAgPSByZXF1aXJlKCcuLyQubGlicmFyeScpXG4gICwgZ2xvYmFsICAgICA9IHJlcXVpcmUoJy4vJC5nbG9iYWwnKVxuICAsIGN0eCAgICAgICAgPSByZXF1aXJlKCcuLyQuY3R4JylcbiAgLCBjbGFzc29mICAgID0gcmVxdWlyZSgnLi8kLmNsYXNzb2YnKVxuICAsICRleHBvcnQgICAgPSByZXF1aXJlKCcuLyQuZXhwb3J0JylcbiAgLCBpc09iamVjdCAgID0gcmVxdWlyZSgnLi8kLmlzLW9iamVjdCcpXG4gICwgYW5PYmplY3QgICA9IHJlcXVpcmUoJy4vJC5hbi1vYmplY3QnKVxuICAsIGFGdW5jdGlvbiAgPSByZXF1aXJlKCcuLyQuYS1mdW5jdGlvbicpXG4gICwgc3RyaWN0TmV3ICA9IHJlcXVpcmUoJy4vJC5zdHJpY3QtbmV3JylcbiAgLCBmb3JPZiAgICAgID0gcmVxdWlyZSgnLi8kLmZvci1vZicpXG4gICwgc2V0UHJvdG8gICA9IHJlcXVpcmUoJy4vJC5zZXQtcHJvdG8nKS5zZXRcbiAgLCBzYW1lICAgICAgID0gcmVxdWlyZSgnLi8kLnNhbWUtdmFsdWUnKVxuICAsIFNQRUNJRVMgICAgPSByZXF1aXJlKCcuLyQud2tzJykoJ3NwZWNpZXMnKVxuICAsIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4vJC5zcGVjaWVzLWNvbnN0cnVjdG9yJylcbiAgLCBhc2FwICAgICAgID0gcmVxdWlyZSgnLi8kLm1pY3JvdGFzaycpXG4gICwgUFJPTUlTRSAgICA9ICdQcm9taXNlJ1xuICAsIHByb2Nlc3MgICAgPSBnbG9iYWwucHJvY2Vzc1xuICAsIGlzTm9kZSAgICAgPSBjbGFzc29mKHByb2Nlc3MpID09ICdwcm9jZXNzJ1xuICAsIFAgICAgICAgICAgPSBnbG9iYWxbUFJPTUlTRV1cbiAgLCBXcmFwcGVyO1xuXG52YXIgdGVzdFJlc29sdmUgPSBmdW5jdGlvbihzdWIpe1xuICB2YXIgdGVzdCA9IG5ldyBQKGZ1bmN0aW9uKCl7fSk7XG4gIGlmKHN1Yil0ZXN0LmNvbnN0cnVjdG9yID0gT2JqZWN0O1xuICByZXR1cm4gUC5yZXNvbHZlKHRlc3QpID09PSB0ZXN0O1xufTtcblxudmFyIFVTRV9OQVRJVkUgPSBmdW5jdGlvbigpe1xuICB2YXIgd29ya3MgPSBmYWxzZTtcbiAgZnVuY3Rpb24gUDIoeCl7XG4gICAgdmFyIHNlbGYgPSBuZXcgUCh4KTtcbiAgICBzZXRQcm90byhzZWxmLCBQMi5wcm90b3R5cGUpO1xuICAgIHJldHVybiBzZWxmO1xuICB9XG4gIHRyeSB7XG4gICAgd29ya3MgPSBQICYmIFAucmVzb2x2ZSAmJiB0ZXN0UmVzb2x2ZSgpO1xuICAgIHNldFByb3RvKFAyLCBQKTtcbiAgICBQMi5wcm90b3R5cGUgPSAkLmNyZWF0ZShQLnByb3RvdHlwZSwge2NvbnN0cnVjdG9yOiB7dmFsdWU6IFAyfX0pO1xuICAgIC8vIGFjdHVhbCBGaXJlZm94IGhhcyBicm9rZW4gc3ViY2xhc3Mgc3VwcG9ydCwgdGVzdCB0aGF0XG4gICAgaWYoIShQMi5yZXNvbHZlKDUpLnRoZW4oZnVuY3Rpb24oKXt9KSBpbnN0YW5jZW9mIFAyKSl7XG4gICAgICB3b3JrcyA9IGZhbHNlO1xuICAgIH1cbiAgICAvLyBhY3R1YWwgVjggYnVnLCBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9NDE2MlxuICAgIGlmKHdvcmtzICYmIHJlcXVpcmUoJy4vJC5kZXNjcmlwdG9ycycpKXtcbiAgICAgIHZhciB0aGVuYWJsZVRoZW5Hb3R0ZW4gPSBmYWxzZTtcbiAgICAgIFAucmVzb2x2ZSgkLnNldERlc2Moe30sICd0aGVuJywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCl7IHRoZW5hYmxlVGhlbkdvdHRlbiA9IHRydWU7IH1cbiAgICAgIH0pKTtcbiAgICAgIHdvcmtzID0gdGhlbmFibGVUaGVuR290dGVuO1xuICAgIH1cbiAgfSBjYXRjaChlKXsgd29ya3MgPSBmYWxzZTsgfVxuICByZXR1cm4gd29ya3M7XG59KCk7XG5cbi8vIGhlbHBlcnNcbnZhciBzYW1lQ29uc3RydWN0b3IgPSBmdW5jdGlvbihhLCBiKXtcbiAgLy8gbGlicmFyeSB3cmFwcGVyIHNwZWNpYWwgY2FzZVxuICBpZihMSUJSQVJZICYmIGEgPT09IFAgJiYgYiA9PT0gV3JhcHBlcilyZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIHNhbWUoYSwgYik7XG59O1xudmFyIGdldENvbnN0cnVjdG9yID0gZnVuY3Rpb24oQyl7XG4gIHZhciBTID0gYW5PYmplY3QoQylbU1BFQ0lFU107XG4gIHJldHVybiBTICE9IHVuZGVmaW5lZCA/IFMgOiBDO1xufTtcbnZhciBpc1RoZW5hYmxlID0gZnVuY3Rpb24oaXQpe1xuICB2YXIgdGhlbjtcbiAgcmV0dXJuIGlzT2JqZWN0KGl0KSAmJiB0eXBlb2YgKHRoZW4gPSBpdC50aGVuKSA9PSAnZnVuY3Rpb24nID8gdGhlbiA6IGZhbHNlO1xufTtcbnZhciBQcm9taXNlQ2FwYWJpbGl0eSA9IGZ1bmN0aW9uKEMpe1xuICB2YXIgcmVzb2x2ZSwgcmVqZWN0O1xuICB0aGlzLnByb21pc2UgPSBuZXcgQyhmdW5jdGlvbigkJHJlc29sdmUsICQkcmVqZWN0KXtcbiAgICBpZihyZXNvbHZlICE9PSB1bmRlZmluZWQgfHwgcmVqZWN0ICE9PSB1bmRlZmluZWQpdGhyb3cgVHlwZUVycm9yKCdCYWQgUHJvbWlzZSBjb25zdHJ1Y3RvcicpO1xuICAgIHJlc29sdmUgPSAkJHJlc29sdmU7XG4gICAgcmVqZWN0ICA9ICQkcmVqZWN0O1xuICB9KTtcbiAgdGhpcy5yZXNvbHZlID0gYUZ1bmN0aW9uKHJlc29sdmUpLFxuICB0aGlzLnJlamVjdCAgPSBhRnVuY3Rpb24ocmVqZWN0KVxufTtcbnZhciBwZXJmb3JtID0gZnVuY3Rpb24oZXhlYyl7XG4gIHRyeSB7XG4gICAgZXhlYygpO1xuICB9IGNhdGNoKGUpe1xuICAgIHJldHVybiB7ZXJyb3I6IGV9O1xuICB9XG59O1xudmFyIG5vdGlmeSA9IGZ1bmN0aW9uKHJlY29yZCwgaXNSZWplY3Qpe1xuICBpZihyZWNvcmQubilyZXR1cm47XG4gIHJlY29yZC5uID0gdHJ1ZTtcbiAgdmFyIGNoYWluID0gcmVjb3JkLmM7XG4gIGFzYXAoZnVuY3Rpb24oKXtcbiAgICB2YXIgdmFsdWUgPSByZWNvcmQudlxuICAgICAgLCBvayAgICA9IHJlY29yZC5zID09IDFcbiAgICAgICwgaSAgICAgPSAwO1xuICAgIHZhciBydW4gPSBmdW5jdGlvbihyZWFjdGlvbil7XG4gICAgICB2YXIgaGFuZGxlciA9IG9rID8gcmVhY3Rpb24ub2sgOiByZWFjdGlvbi5mYWlsXG4gICAgICAgICwgcmVzb2x2ZSA9IHJlYWN0aW9uLnJlc29sdmVcbiAgICAgICAgLCByZWplY3QgID0gcmVhY3Rpb24ucmVqZWN0XG4gICAgICAgICwgcmVzdWx0LCB0aGVuO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYoaGFuZGxlcil7XG4gICAgICAgICAgaWYoIW9rKXJlY29yZC5oID0gdHJ1ZTtcbiAgICAgICAgICByZXN1bHQgPSBoYW5kbGVyID09PSB0cnVlID8gdmFsdWUgOiBoYW5kbGVyKHZhbHVlKTtcbiAgICAgICAgICBpZihyZXN1bHQgPT09IHJlYWN0aW9uLnByb21pc2Upe1xuICAgICAgICAgICAgcmVqZWN0KFR5cGVFcnJvcignUHJvbWlzZS1jaGFpbiBjeWNsZScpKTtcbiAgICAgICAgICB9IGVsc2UgaWYodGhlbiA9IGlzVGhlbmFibGUocmVzdWx0KSl7XG4gICAgICAgICAgICB0aGVuLmNhbGwocmVzdWx0LCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0gZWxzZSByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0gZWxzZSByZWplY3QodmFsdWUpO1xuICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgd2hpbGUoY2hhaW4ubGVuZ3RoID4gaSlydW4oY2hhaW5baSsrXSk7IC8vIHZhcmlhYmxlIGxlbmd0aCAtIGNhbid0IHVzZSBmb3JFYWNoXG4gICAgY2hhaW4ubGVuZ3RoID0gMDtcbiAgICByZWNvcmQubiA9IGZhbHNlO1xuICAgIGlmKGlzUmVqZWN0KXNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHZhciBwcm9taXNlID0gcmVjb3JkLnBcbiAgICAgICAgLCBoYW5kbGVyLCBjb25zb2xlO1xuICAgICAgaWYoaXNVbmhhbmRsZWQocHJvbWlzZSkpe1xuICAgICAgICBpZihpc05vZGUpe1xuICAgICAgICAgIHByb2Nlc3MuZW1pdCgndW5oYW5kbGVkUmVqZWN0aW9uJywgdmFsdWUsIHByb21pc2UpO1xuICAgICAgICB9IGVsc2UgaWYoaGFuZGxlciA9IGdsb2JhbC5vbnVuaGFuZGxlZHJlamVjdGlvbil7XG4gICAgICAgICAgaGFuZGxlcih7cHJvbWlzZTogcHJvbWlzZSwgcmVhc29uOiB2YWx1ZX0pO1xuICAgICAgICB9IGVsc2UgaWYoKGNvbnNvbGUgPSBnbG9iYWwuY29uc29sZSkgJiYgY29uc29sZS5lcnJvcil7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignVW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uJywgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IHJlY29yZC5hID0gdW5kZWZpbmVkO1xuICAgIH0sIDEpO1xuICB9KTtcbn07XG52YXIgaXNVbmhhbmRsZWQgPSBmdW5jdGlvbihwcm9taXNlKXtcbiAgdmFyIHJlY29yZCA9IHByb21pc2UuX2RcbiAgICAsIGNoYWluICA9IHJlY29yZC5hIHx8IHJlY29yZC5jXG4gICAgLCBpICAgICAgPSAwXG4gICAgLCByZWFjdGlvbjtcbiAgaWYocmVjb3JkLmgpcmV0dXJuIGZhbHNlO1xuICB3aGlsZShjaGFpbi5sZW5ndGggPiBpKXtcbiAgICByZWFjdGlvbiA9IGNoYWluW2krK107XG4gICAgaWYocmVhY3Rpb24uZmFpbCB8fCAhaXNVbmhhbmRsZWQocmVhY3Rpb24ucHJvbWlzZSkpcmV0dXJuIGZhbHNlO1xuICB9IHJldHVybiB0cnVlO1xufTtcbnZhciAkcmVqZWN0ID0gZnVuY3Rpb24odmFsdWUpe1xuICB2YXIgcmVjb3JkID0gdGhpcztcbiAgaWYocmVjb3JkLmQpcmV0dXJuO1xuICByZWNvcmQuZCA9IHRydWU7XG4gIHJlY29yZCA9IHJlY29yZC5yIHx8IHJlY29yZDsgLy8gdW53cmFwXG4gIHJlY29yZC52ID0gdmFsdWU7XG4gIHJlY29yZC5zID0gMjtcbiAgcmVjb3JkLmEgPSByZWNvcmQuYy5zbGljZSgpO1xuICBub3RpZnkocmVjb3JkLCB0cnVlKTtcbn07XG52YXIgJHJlc29sdmUgPSBmdW5jdGlvbih2YWx1ZSl7XG4gIHZhciByZWNvcmQgPSB0aGlzXG4gICAgLCB0aGVuO1xuICBpZihyZWNvcmQuZClyZXR1cm47XG4gIHJlY29yZC5kID0gdHJ1ZTtcbiAgcmVjb3JkID0gcmVjb3JkLnIgfHwgcmVjb3JkOyAvLyB1bndyYXBcbiAgdHJ5IHtcbiAgICBpZihyZWNvcmQucCA9PT0gdmFsdWUpdGhyb3cgVHlwZUVycm9yKFwiUHJvbWlzZSBjYW4ndCBiZSByZXNvbHZlZCBpdHNlbGZcIik7XG4gICAgaWYodGhlbiA9IGlzVGhlbmFibGUodmFsdWUpKXtcbiAgICAgIGFzYXAoZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIHdyYXBwZXIgPSB7cjogcmVjb3JkLCBkOiBmYWxzZX07IC8vIHdyYXBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGVuLmNhbGwodmFsdWUsIGN0eCgkcmVzb2x2ZSwgd3JhcHBlciwgMSksIGN0eCgkcmVqZWN0LCB3cmFwcGVyLCAxKSk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgJHJlamVjdC5jYWxsKHdyYXBwZXIsIGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVjb3JkLnYgPSB2YWx1ZTtcbiAgICAgIHJlY29yZC5zID0gMTtcbiAgICAgIG5vdGlmeShyZWNvcmQsIGZhbHNlKTtcbiAgICB9XG4gIH0gY2F0Y2goZSl7XG4gICAgJHJlamVjdC5jYWxsKHtyOiByZWNvcmQsIGQ6IGZhbHNlfSwgZSk7IC8vIHdyYXBcbiAgfVxufTtcblxuLy8gY29uc3RydWN0b3IgcG9seWZpbGxcbmlmKCFVU0VfTkFUSVZFKXtcbiAgLy8gMjUuNC4zLjEgUHJvbWlzZShleGVjdXRvcilcbiAgUCA9IGZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3Ipe1xuICAgIGFGdW5jdGlvbihleGVjdXRvcik7XG4gICAgdmFyIHJlY29yZCA9IHRoaXMuX2QgPSB7XG4gICAgICBwOiBzdHJpY3ROZXcodGhpcywgUCwgUFJPTUlTRSksICAgICAgICAgLy8gPC0gcHJvbWlzZVxuICAgICAgYzogW10sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIGF3YWl0aW5nIHJlYWN0aW9uc1xuICAgICAgYTogdW5kZWZpbmVkLCAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIGNoZWNrZWQgaW4gaXNVbmhhbmRsZWQgcmVhY3Rpb25zXG4gICAgICBzOiAwLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gc3RhdGVcbiAgICAgIGQ6IGZhbHNlLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSBkb25lXG4gICAgICB2OiB1bmRlZmluZWQsICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gdmFsdWVcbiAgICAgIGg6IGZhbHNlLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSBoYW5kbGVkIHJlamVjdGlvblxuICAgICAgbjogZmFsc2UgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIG5vdGlmeVxuICAgIH07XG4gICAgdHJ5IHtcbiAgICAgIGV4ZWN1dG9yKGN0eCgkcmVzb2x2ZSwgcmVjb3JkLCAxKSwgY3R4KCRyZWplY3QsIHJlY29yZCwgMSkpO1xuICAgIH0gY2F0Y2goZXJyKXtcbiAgICAgICRyZWplY3QuY2FsbChyZWNvcmQsIGVycik7XG4gICAgfVxuICB9O1xuICByZXF1aXJlKCcuLyQucmVkZWZpbmUtYWxsJykoUC5wcm90b3R5cGUsIHtcbiAgICAvLyAyNS40LjUuMyBQcm9taXNlLnByb3RvdHlwZS50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKVxuICAgIHRoZW46IGZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpe1xuICAgICAgdmFyIHJlYWN0aW9uID0gbmV3IFByb21pc2VDYXBhYmlsaXR5KHNwZWNpZXNDb25zdHJ1Y3Rvcih0aGlzLCBQKSlcbiAgICAgICAgLCBwcm9taXNlICA9IHJlYWN0aW9uLnByb21pc2VcbiAgICAgICAgLCByZWNvcmQgICA9IHRoaXMuX2Q7XG4gICAgICByZWFjdGlvbi5vayAgID0gdHlwZW9mIG9uRnVsZmlsbGVkID09ICdmdW5jdGlvbicgPyBvbkZ1bGZpbGxlZCA6IHRydWU7XG4gICAgICByZWFjdGlvbi5mYWlsID0gdHlwZW9mIG9uUmVqZWN0ZWQgPT0gJ2Z1bmN0aW9uJyAmJiBvblJlamVjdGVkO1xuICAgICAgcmVjb3JkLmMucHVzaChyZWFjdGlvbik7XG4gICAgICBpZihyZWNvcmQuYSlyZWNvcmQuYS5wdXNoKHJlYWN0aW9uKTtcbiAgICAgIGlmKHJlY29yZC5zKW5vdGlmeShyZWNvcmQsIGZhbHNlKTtcbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH0sXG4gICAgLy8gMjUuNC41LjEgUHJvbWlzZS5wcm90b3R5cGUuY2F0Y2gob25SZWplY3RlZClcbiAgICAnY2F0Y2gnOiBmdW5jdGlvbihvblJlamVjdGVkKXtcbiAgICAgIHJldHVybiB0aGlzLnRoZW4odW5kZWZpbmVkLCBvblJlamVjdGVkKTtcbiAgICB9XG4gIH0pO1xufVxuXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCB7UHJvbWlzZTogUH0pO1xucmVxdWlyZSgnLi8kLnNldC10by1zdHJpbmctdGFnJykoUCwgUFJPTUlTRSk7XG5yZXF1aXJlKCcuLyQuc2V0LXNwZWNpZXMnKShQUk9NSVNFKTtcbldyYXBwZXIgPSByZXF1aXJlKCcuLyQuY29yZScpW1BST01JU0VdO1xuXG4vLyBzdGF0aWNzXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC41IFByb21pc2UucmVqZWN0KHIpXG4gIHJlamVjdDogZnVuY3Rpb24gcmVqZWN0KHIpe1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3IFByb21pc2VDYXBhYmlsaXR5KHRoaXMpXG4gICAgICAsICQkcmVqZWN0ICAgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICAkJHJlamVjdChyKTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTtcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKCFVU0VfTkFUSVZFIHx8IHRlc3RSZXNvbHZlKHRydWUpKSwgUFJPTUlTRSwge1xuICAvLyAyNS40LjQuNiBQcm9taXNlLnJlc29sdmUoeClcbiAgcmVzb2x2ZTogZnVuY3Rpb24gcmVzb2x2ZSh4KXtcbiAgICAvLyBpbnN0YW5jZW9mIGluc3RlYWQgb2YgaW50ZXJuYWwgc2xvdCBjaGVjayBiZWNhdXNlIHdlIHNob3VsZCBmaXggaXQgd2l0aG91dCByZXBsYWNlbWVudCBuYXRpdmUgUHJvbWlzZSBjb3JlXG4gICAgaWYoeCBpbnN0YW5jZW9mIFAgJiYgc2FtZUNvbnN0cnVjdG9yKHguY29uc3RydWN0b3IsIHRoaXMpKXJldHVybiB4O1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3IFByb21pc2VDYXBhYmlsaXR5KHRoaXMpXG4gICAgICAsICQkcmVzb2x2ZSAgPSBjYXBhYmlsaXR5LnJlc29sdmU7XG4gICAgJCRyZXNvbHZlKHgpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pO1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhKFVTRV9OQVRJVkUgJiYgcmVxdWlyZSgnLi8kLml0ZXItZGV0ZWN0JykoZnVuY3Rpb24oaXRlcil7XG4gIFAuYWxsKGl0ZXIpWydjYXRjaCddKGZ1bmN0aW9uKCl7fSk7XG59KSksIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjEgUHJvbWlzZS5hbGwoaXRlcmFibGUpXG4gIGFsbDogZnVuY3Rpb24gYWxsKGl0ZXJhYmxlKXtcbiAgICB2YXIgQyAgICAgICAgICA9IGdldENvbnN0cnVjdG9yKHRoaXMpXG4gICAgICAsIGNhcGFiaWxpdHkgPSBuZXcgUHJvbWlzZUNhcGFiaWxpdHkoQylcbiAgICAgICwgcmVzb2x2ZSAgICA9IGNhcGFiaWxpdHkucmVzb2x2ZVxuICAgICAgLCByZWplY3QgICAgID0gY2FwYWJpbGl0eS5yZWplY3RcbiAgICAgICwgdmFsdWVzICAgICA9IFtdO1xuICAgIHZhciBhYnJ1cHQgPSBwZXJmb3JtKGZ1bmN0aW9uKCl7XG4gICAgICBmb3JPZihpdGVyYWJsZSwgZmFsc2UsIHZhbHVlcy5wdXNoLCB2YWx1ZXMpO1xuICAgICAgdmFyIHJlbWFpbmluZyA9IHZhbHVlcy5sZW5ndGhcbiAgICAgICAgLCByZXN1bHRzICAgPSBBcnJheShyZW1haW5pbmcpO1xuICAgICAgaWYocmVtYWluaW5nKSQuZWFjaC5jYWxsKHZhbHVlcywgZnVuY3Rpb24ocHJvbWlzZSwgaW5kZXgpe1xuICAgICAgICB2YXIgYWxyZWFkeUNhbGxlZCA9IGZhbHNlO1xuICAgICAgICBDLnJlc29sdmUocHJvbWlzZSkudGhlbihmdW5jdGlvbih2YWx1ZSl7XG4gICAgICAgICAgaWYoYWxyZWFkeUNhbGxlZClyZXR1cm47XG4gICAgICAgICAgYWxyZWFkeUNhbGxlZCA9IHRydWU7XG4gICAgICAgICAgcmVzdWx0c1tpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAtLXJlbWFpbmluZyB8fCByZXNvbHZlKHJlc3VsdHMpO1xuICAgICAgICB9LCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgICBlbHNlIHJlc29sdmUocmVzdWx0cyk7XG4gICAgfSk7XG4gICAgaWYoYWJydXB0KXJlamVjdChhYnJ1cHQuZXJyb3IpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH0sXG4gIC8vIDI1LjQuNC40IFByb21pc2UucmFjZShpdGVyYWJsZSlcbiAgcmFjZTogZnVuY3Rpb24gcmFjZShpdGVyYWJsZSl7XG4gICAgdmFyIEMgICAgICAgICAgPSBnZXRDb25zdHJ1Y3Rvcih0aGlzKVxuICAgICAgLCBjYXBhYmlsaXR5ID0gbmV3IFByb21pc2VDYXBhYmlsaXR5KEMpXG4gICAgICAsIHJlamVjdCAgICAgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICB2YXIgYWJydXB0ID0gcGVyZm9ybShmdW5jdGlvbigpe1xuICAgICAgZm9yT2YoaXRlcmFibGUsIGZhbHNlLCBmdW5jdGlvbihwcm9taXNlKXtcbiAgICAgICAgQy5yZXNvbHZlKHByb21pc2UpLnRoZW4oY2FwYWJpbGl0eS5yZXNvbHZlLCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgaWYoYWJydXB0KXJlamVjdChhYnJ1cHQuZXJyb3IpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JztcbnZhciBzdHJvbmcgPSByZXF1aXJlKCcuLyQuY29sbGVjdGlvbi1zdHJvbmcnKTtcblxuLy8gMjMuMiBTZXQgT2JqZWN0c1xucmVxdWlyZSgnLi8kLmNvbGxlY3Rpb24nKSgnU2V0JywgZnVuY3Rpb24oZ2V0KXtcbiAgcmV0dXJuIGZ1bmN0aW9uIFNldCgpeyByZXR1cm4gZ2V0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTsgfTtcbn0sIHtcbiAgLy8gMjMuMi4zLjEgU2V0LnByb3RvdHlwZS5hZGQodmFsdWUpXG4gIGFkZDogZnVuY3Rpb24gYWRkKHZhbHVlKXtcbiAgICByZXR1cm4gc3Ryb25nLmRlZih0aGlzLCB2YWx1ZSA9IHZhbHVlID09PSAwID8gMCA6IHZhbHVlLCB2YWx1ZSk7XG4gIH1cbn0sIHN0cm9uZyk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyICRhdCAgPSByZXF1aXJlKCcuLyQuc3RyaW5nLWF0JykodHJ1ZSk7XG5cbi8vIDIxLjEuMy4yNyBTdHJpbmcucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcbnJlcXVpcmUoJy4vJC5pdGVyLWRlZmluZScpKFN0cmluZywgJ1N0cmluZycsIGZ1bmN0aW9uKGl0ZXJhdGVkKXtcbiAgdGhpcy5fdCA9IFN0cmluZyhpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuLy8gMjEuMS41LjIuMSAlU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24oKXtcbiAgdmFyIE8gICAgID0gdGhpcy5fdFxuICAgICwgaW5kZXggPSB0aGlzLl9pXG4gICAgLCBwb2ludDtcbiAgaWYoaW5kZXggPj0gTy5sZW5ndGgpcmV0dXJuIHt2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlfTtcbiAgcG9pbnQgPSAkYXQoTywgaW5kZXgpO1xuICB0aGlzLl9pICs9IHBvaW50Lmxlbmd0aDtcbiAgcmV0dXJuIHt2YWx1ZTogcG9pbnQsIGRvbmU6IGZhbHNlfTtcbn0pOyIsIid1c2Ugc3RyaWN0Jztcbi8vIEVDTUFTY3JpcHQgNiBzeW1ib2xzIHNoaW1cbnZhciAkICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgZ2xvYmFsICAgICAgICAgPSByZXF1aXJlKCcuLyQuZ2xvYmFsJylcbiAgLCBoYXMgICAgICAgICAgICA9IHJlcXVpcmUoJy4vJC5oYXMnKVxuICAsIERFU0NSSVBUT1JTICAgID0gcmVxdWlyZSgnLi8kLmRlc2NyaXB0b3JzJylcbiAgLCAkZXhwb3J0ICAgICAgICA9IHJlcXVpcmUoJy4vJC5leHBvcnQnKVxuICAsIHJlZGVmaW5lICAgICAgID0gcmVxdWlyZSgnLi8kLnJlZGVmaW5lJylcbiAgLCAkZmFpbHMgICAgICAgICA9IHJlcXVpcmUoJy4vJC5mYWlscycpXG4gICwgc2hhcmVkICAgICAgICAgPSByZXF1aXJlKCcuLyQuc2hhcmVkJylcbiAgLCBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vJC5zZXQtdG8tc3RyaW5nLXRhZycpXG4gICwgdWlkICAgICAgICAgICAgPSByZXF1aXJlKCcuLyQudWlkJylcbiAgLCB3a3MgICAgICAgICAgICA9IHJlcXVpcmUoJy4vJC53a3MnKVxuICAsIGtleU9mICAgICAgICAgID0gcmVxdWlyZSgnLi8kLmtleW9mJylcbiAgLCAkbmFtZXMgICAgICAgICA9IHJlcXVpcmUoJy4vJC5nZXQtbmFtZXMnKVxuICAsIGVudW1LZXlzICAgICAgID0gcmVxdWlyZSgnLi8kLmVudW0ta2V5cycpXG4gICwgaXNBcnJheSAgICAgICAgPSByZXF1aXJlKCcuLyQuaXMtYXJyYXknKVxuICAsIGFuT2JqZWN0ICAgICAgID0gcmVxdWlyZSgnLi8kLmFuLW9iamVjdCcpXG4gICwgdG9JT2JqZWN0ICAgICAgPSByZXF1aXJlKCcuLyQudG8taW9iamVjdCcpXG4gICwgY3JlYXRlRGVzYyAgICAgPSByZXF1aXJlKCcuLyQucHJvcGVydHktZGVzYycpXG4gICwgZ2V0RGVzYyAgICAgICAgPSAkLmdldERlc2NcbiAgLCBzZXREZXNjICAgICAgICA9ICQuc2V0RGVzY1xuICAsIF9jcmVhdGUgICAgICAgID0gJC5jcmVhdGVcbiAgLCBnZXROYW1lcyAgICAgICA9ICRuYW1lcy5nZXRcbiAgLCAkU3ltYm9sICAgICAgICA9IGdsb2JhbC5TeW1ib2xcbiAgLCAkSlNPTiAgICAgICAgICA9IGdsb2JhbC5KU09OXG4gICwgX3N0cmluZ2lmeSAgICAgPSAkSlNPTiAmJiAkSlNPTi5zdHJpbmdpZnlcbiAgLCBzZXR0ZXIgICAgICAgICA9IGZhbHNlXG4gICwgSElEREVOICAgICAgICAgPSB3a3MoJ19oaWRkZW4nKVxuICAsIGlzRW51bSAgICAgICAgID0gJC5pc0VudW1cbiAgLCBTeW1ib2xSZWdpc3RyeSA9IHNoYXJlZCgnc3ltYm9sLXJlZ2lzdHJ5JylcbiAgLCBBbGxTeW1ib2xzICAgICA9IHNoYXJlZCgnc3ltYm9scycpXG4gICwgdXNlTmF0aXZlICAgICAgPSB0eXBlb2YgJFN5bWJvbCA9PSAnZnVuY3Rpb24nXG4gICwgT2JqZWN0UHJvdG8gICAgPSBPYmplY3QucHJvdG90eXBlO1xuXG4vLyBmYWxsYmFjayBmb3Igb2xkIEFuZHJvaWQsIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD02ODdcbnZhciBzZXRTeW1ib2xEZXNjID0gREVTQ1JJUFRPUlMgJiYgJGZhaWxzKGZ1bmN0aW9uKCl7XG4gIHJldHVybiBfY3JlYXRlKHNldERlc2Moe30sICdhJywge1xuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHNldERlc2ModGhpcywgJ2EnLCB7dmFsdWU6IDd9KS5hOyB9XG4gIH0pKS5hICE9IDc7XG59KSA/IGZ1bmN0aW9uKGl0LCBrZXksIEQpe1xuICB2YXIgcHJvdG9EZXNjID0gZ2V0RGVzYyhPYmplY3RQcm90bywga2V5KTtcbiAgaWYocHJvdG9EZXNjKWRlbGV0ZSBPYmplY3RQcm90b1trZXldO1xuICBzZXREZXNjKGl0LCBrZXksIEQpO1xuICBpZihwcm90b0Rlc2MgJiYgaXQgIT09IE9iamVjdFByb3RvKXNldERlc2MoT2JqZWN0UHJvdG8sIGtleSwgcHJvdG9EZXNjKTtcbn0gOiBzZXREZXNjO1xuXG52YXIgd3JhcCA9IGZ1bmN0aW9uKHRhZyl7XG4gIHZhciBzeW0gPSBBbGxTeW1ib2xzW3RhZ10gPSBfY3JlYXRlKCRTeW1ib2wucHJvdG90eXBlKTtcbiAgc3ltLl9rID0gdGFnO1xuICBERVNDUklQVE9SUyAmJiBzZXR0ZXIgJiYgc2V0U3ltYm9sRGVzYyhPYmplY3RQcm90bywgdGFnLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHNldDogZnVuY3Rpb24odmFsdWUpe1xuICAgICAgaWYoaGFzKHRoaXMsIEhJRERFTikgJiYgaGFzKHRoaXNbSElEREVOXSwgdGFnKSl0aGlzW0hJRERFTl1bdGFnXSA9IGZhbHNlO1xuICAgICAgc2V0U3ltYm9sRGVzYyh0aGlzLCB0YWcsIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gc3ltO1xufTtcblxudmFyIGlzU3ltYm9sID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnO1xufTtcblxudmFyICRkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KGl0LCBrZXksIEQpe1xuICBpZihEICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpKXtcbiAgICBpZighRC5lbnVtZXJhYmxlKXtcbiAgICAgIGlmKCFoYXMoaXQsIEhJRERFTikpc2V0RGVzYyhpdCwgSElEREVOLCBjcmVhdGVEZXNjKDEsIHt9KSk7XG4gICAgICBpdFtISURERU5dW2tleV0gPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZihoYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKWl0W0hJRERFTl1ba2V5XSA9IGZhbHNlO1xuICAgICAgRCA9IF9jcmVhdGUoRCwge2VudW1lcmFibGU6IGNyZWF0ZURlc2MoMCwgZmFsc2UpfSk7XG4gICAgfSByZXR1cm4gc2V0U3ltYm9sRGVzYyhpdCwga2V5LCBEKTtcbiAgfSByZXR1cm4gc2V0RGVzYyhpdCwga2V5LCBEKTtcbn07XG52YXIgJGRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKGl0LCBQKXtcbiAgYW5PYmplY3QoaXQpO1xuICB2YXIga2V5cyA9IGVudW1LZXlzKFAgPSB0b0lPYmplY3QoUCkpXG4gICAgLCBpICAgID0gMFxuICAgICwgbCA9IGtleXMubGVuZ3RoXG4gICAgLCBrZXk7XG4gIHdoaWxlKGwgPiBpKSRkZWZpbmVQcm9wZXJ0eShpdCwga2V5ID0ga2V5c1tpKytdLCBQW2tleV0pO1xuICByZXR1cm4gaXQ7XG59O1xudmFyICRjcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoaXQsIFApe1xuICByZXR1cm4gUCA9PT0gdW5kZWZpbmVkID8gX2NyZWF0ZShpdCkgOiAkZGVmaW5lUHJvcGVydGllcyhfY3JlYXRlKGl0KSwgUCk7XG59O1xudmFyICRwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IGZ1bmN0aW9uIHByb3BlcnR5SXNFbnVtZXJhYmxlKGtleSl7XG4gIHZhciBFID0gaXNFbnVtLmNhbGwodGhpcywga2V5KTtcbiAgcmV0dXJuIEUgfHwgIWhhcyh0aGlzLCBrZXkpIHx8ICFoYXMoQWxsU3ltYm9scywga2V5KSB8fCBoYXModGhpcywgSElEREVOKSAmJiB0aGlzW0hJRERFTl1ba2V5XVxuICAgID8gRSA6IHRydWU7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSl7XG4gIHZhciBEID0gZ2V0RGVzYyhpdCA9IHRvSU9iamVjdChpdCksIGtleSk7XG4gIGlmKEQgJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIShoYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKSlELmVudW1lcmFibGUgPSB0cnVlO1xuICByZXR1cm4gRDtcbn07XG52YXIgJGdldE93blByb3BlcnR5TmFtZXMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KXtcbiAgdmFyIG5hbWVzICA9IGdldE5hbWVzKHRvSU9iamVjdChpdCkpXG4gICAgLCByZXN1bHQgPSBbXVxuICAgICwgaSAgICAgID0gMFxuICAgICwga2V5O1xuICB3aGlsZShuYW1lcy5sZW5ndGggPiBpKWlmKCFoYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkgJiYga2V5ICE9IEhJRERFTilyZXN1bHQucHVzaChrZXkpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGl0KXtcbiAgdmFyIG5hbWVzICA9IGdldE5hbWVzKHRvSU9iamVjdChpdCkpXG4gICAgLCByZXN1bHQgPSBbXVxuICAgICwgaSAgICAgID0gMFxuICAgICwga2V5O1xuICB3aGlsZShuYW1lcy5sZW5ndGggPiBpKWlmKGhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSlyZXN1bHQucHVzaChBbGxTeW1ib2xzW2tleV0pO1xuICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciAkc3RyaW5naWZ5ID0gZnVuY3Rpb24gc3RyaW5naWZ5KGl0KXtcbiAgaWYoaXQgPT09IHVuZGVmaW5lZCB8fCBpc1N5bWJvbChpdCkpcmV0dXJuOyAvLyBJRTggcmV0dXJucyBzdHJpbmcgb24gdW5kZWZpbmVkXG4gIHZhciBhcmdzID0gW2l0XVxuICAgICwgaSAgICA9IDFcbiAgICAsICQkICAgPSBhcmd1bWVudHNcbiAgICAsIHJlcGxhY2VyLCAkcmVwbGFjZXI7XG4gIHdoaWxlKCQkLmxlbmd0aCA+IGkpYXJncy5wdXNoKCQkW2krK10pO1xuICByZXBsYWNlciA9IGFyZ3NbMV07XG4gIGlmKHR5cGVvZiByZXBsYWNlciA9PSAnZnVuY3Rpb24nKSRyZXBsYWNlciA9IHJlcGxhY2VyO1xuICBpZigkcmVwbGFjZXIgfHwgIWlzQXJyYXkocmVwbGFjZXIpKXJlcGxhY2VyID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSl7XG4gICAgaWYoJHJlcGxhY2VyKXZhbHVlID0gJHJlcGxhY2VyLmNhbGwodGhpcywga2V5LCB2YWx1ZSk7XG4gICAgaWYoIWlzU3ltYm9sKHZhbHVlKSlyZXR1cm4gdmFsdWU7XG4gIH07XG4gIGFyZ3NbMV0gPSByZXBsYWNlcjtcbiAgcmV0dXJuIF9zdHJpbmdpZnkuYXBwbHkoJEpTT04sIGFyZ3MpO1xufTtcbnZhciBidWdneUpTT04gPSAkZmFpbHMoZnVuY3Rpb24oKXtcbiAgdmFyIFMgPSAkU3ltYm9sKCk7XG4gIC8vIE1TIEVkZ2UgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIHt9XG4gIC8vIFdlYktpdCBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMgbnVsbFxuICAvLyBWOCB0aHJvd3Mgb24gYm94ZWQgc3ltYm9sc1xuICByZXR1cm4gX3N0cmluZ2lmeShbU10pICE9ICdbbnVsbF0nIHx8IF9zdHJpbmdpZnkoe2E6IFN9KSAhPSAne30nIHx8IF9zdHJpbmdpZnkoT2JqZWN0KFMpKSAhPSAne30nO1xufSk7XG5cbi8vIDE5LjQuMS4xIFN5bWJvbChbZGVzY3JpcHRpb25dKVxuaWYoIXVzZU5hdGl2ZSl7XG4gICRTeW1ib2wgPSBmdW5jdGlvbiBTeW1ib2woKXtcbiAgICBpZihpc1N5bWJvbCh0aGlzKSl0aHJvdyBUeXBlRXJyb3IoJ1N5bWJvbCBpcyBub3QgYSBjb25zdHJ1Y3RvcicpO1xuICAgIHJldHVybiB3cmFwKHVpZChhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCkpO1xuICB9O1xuICByZWRlZmluZSgkU3ltYm9sLnByb3RvdHlwZSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKXtcbiAgICByZXR1cm4gdGhpcy5faztcbiAgfSk7XG5cbiAgaXNTeW1ib2wgPSBmdW5jdGlvbihpdCl7XG4gICAgcmV0dXJuIGl0IGluc3RhbmNlb2YgJFN5bWJvbDtcbiAgfTtcblxuICAkLmNyZWF0ZSAgICAgPSAkY3JlYXRlO1xuICAkLmlzRW51bSAgICAgPSAkcHJvcGVydHlJc0VudW1lcmFibGU7XG4gICQuZ2V0RGVzYyAgICA9ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gICQuc2V0RGVzYyAgICA9ICRkZWZpbmVQcm9wZXJ0eTtcbiAgJC5zZXREZXNjcyAgID0gJGRlZmluZVByb3BlcnRpZXM7XG4gICQuZ2V0TmFtZXMgICA9ICRuYW1lcy5nZXQgPSAkZ2V0T3duUHJvcGVydHlOYW1lcztcbiAgJC5nZXRTeW1ib2xzID0gJGdldE93blByb3BlcnR5U3ltYm9scztcblxuICBpZihERVNDUklQVE9SUyAmJiAhcmVxdWlyZSgnLi8kLmxpYnJhcnknKSl7XG4gICAgcmVkZWZpbmUoT2JqZWN0UHJvdG8sICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICRwcm9wZXJ0eUlzRW51bWVyYWJsZSwgdHJ1ZSk7XG4gIH1cbn1cblxudmFyIHN5bWJvbFN0YXRpY3MgPSB7XG4gIC8vIDE5LjQuMi4xIFN5bWJvbC5mb3Ioa2V5KVxuICAnZm9yJzogZnVuY3Rpb24oa2V5KXtcbiAgICByZXR1cm4gaGFzKFN5bWJvbFJlZ2lzdHJ5LCBrZXkgKz0gJycpXG4gICAgICA/IFN5bWJvbFJlZ2lzdHJ5W2tleV1cbiAgICAgIDogU3ltYm9sUmVnaXN0cnlba2V5XSA9ICRTeW1ib2woa2V5KTtcbiAgfSxcbiAgLy8gMTkuNC4yLjUgU3ltYm9sLmtleUZvcihzeW0pXG4gIGtleUZvcjogZnVuY3Rpb24ga2V5Rm9yKGtleSl7XG4gICAgcmV0dXJuIGtleU9mKFN5bWJvbFJlZ2lzdHJ5LCBrZXkpO1xuICB9LFxuICB1c2VTZXR0ZXI6IGZ1bmN0aW9uKCl7IHNldHRlciA9IHRydWU7IH0sXG4gIHVzZVNpbXBsZTogZnVuY3Rpb24oKXsgc2V0dGVyID0gZmFsc2U7IH1cbn07XG4vLyAxOS40LjIuMiBTeW1ib2wuaGFzSW5zdGFuY2Vcbi8vIDE5LjQuMi4zIFN5bWJvbC5pc0NvbmNhdFNwcmVhZGFibGVcbi8vIDE5LjQuMi40IFN5bWJvbC5pdGVyYXRvclxuLy8gMTkuNC4yLjYgU3ltYm9sLm1hdGNoXG4vLyAxOS40LjIuOCBTeW1ib2wucmVwbGFjZVxuLy8gMTkuNC4yLjkgU3ltYm9sLnNlYXJjaFxuLy8gMTkuNC4yLjEwIFN5bWJvbC5zcGVjaWVzXG4vLyAxOS40LjIuMTEgU3ltYm9sLnNwbGl0XG4vLyAxOS40LjIuMTIgU3ltYm9sLnRvUHJpbWl0aXZlXG4vLyAxOS40LjIuMTMgU3ltYm9sLnRvU3RyaW5nVGFnXG4vLyAxOS40LjIuMTQgU3ltYm9sLnVuc2NvcGFibGVzXG4kLmVhY2guY2FsbCgoXG4gICdoYXNJbnN0YW5jZSxpc0NvbmNhdFNwcmVhZGFibGUsaXRlcmF0b3IsbWF0Y2gscmVwbGFjZSxzZWFyY2gsJyArXG4gICdzcGVjaWVzLHNwbGl0LHRvUHJpbWl0aXZlLHRvU3RyaW5nVGFnLHVuc2NvcGFibGVzJ1xuKS5zcGxpdCgnLCcpLCBmdW5jdGlvbihpdCl7XG4gIHZhciBzeW0gPSB3a3MoaXQpO1xuICBzeW1ib2xTdGF0aWNzW2l0XSA9IHVzZU5hdGl2ZSA/IHN5bSA6IHdyYXAoc3ltKTtcbn0pO1xuXG5zZXR0ZXIgPSB0cnVlO1xuXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVywge1N5bWJvbDogJFN5bWJvbH0pO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1N5bWJvbCcsIHN5bWJvbFN0YXRpY3MpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICF1c2VOYXRpdmUsICdPYmplY3QnLCB7XG4gIC8vIDE5LjEuMi4yIE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbiAgY3JlYXRlOiAkY3JlYXRlLFxuICAvLyAxOS4xLjIuNCBPYmplY3QuZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcylcbiAgZGVmaW5lUHJvcGVydHk6ICRkZWZpbmVQcm9wZXJ0eSxcbiAgLy8gMTkuMS4yLjMgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcylcbiAgZGVmaW5lUHJvcGVydGllczogJGRlZmluZVByb3BlcnRpZXMsXG4gIC8vIDE5LjEuMi42IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUClcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxuICAvLyAxOS4xLjIuNyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxuICBnZXRPd25Qcm9wZXJ0eU5hbWVzOiAkZ2V0T3duUHJvcGVydHlOYW1lcyxcbiAgLy8gMTkuMS4yLjggT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhPKVxuICBnZXRPd25Qcm9wZXJ0eVN5bWJvbHM6ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHNcbn0pO1xuXG4vLyAyNC4zLjIgSlNPTi5zdHJpbmdpZnkodmFsdWUgWywgcmVwbGFjZXIgWywgc3BhY2VdXSlcbiRKU09OICYmICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKCF1c2VOYXRpdmUgfHwgYnVnZ3lKU09OKSwgJ0pTT04nLCB7c3RyaW5naWZ5OiAkc3RyaW5naWZ5fSk7XG5cbi8vIDE5LjQuMy41IFN5bWJvbC5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKCRTeW1ib2wsICdTeW1ib2wnKTtcbi8vIDIwLjIuMS45IE1hdGhbQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKE1hdGgsICdNYXRoJywgdHJ1ZSk7XG4vLyAyNC4zLjMgSlNPTltAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoZ2xvYmFsLkpTT04sICdKU09OJywgdHJ1ZSk7IiwiLy8gaHR0cDovL2dvby5nbC9Ya0JyakRcbnZhciAkZXhwb3J0ICA9IHJlcXVpcmUoJy4vJC5leHBvcnQnKVxuICAsICRlbnRyaWVzID0gcmVxdWlyZSgnLi8kLm9iamVjdC10by1hcnJheScpKHRydWUpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHtcbiAgZW50cmllczogZnVuY3Rpb24gZW50cmllcyhpdCl7XG4gICAgcmV0dXJuICRlbnRyaWVzKGl0KTtcbiAgfVxufSk7IiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL0RhdmlkQnJ1YW50L01hcC1TZXQucHJvdG90eXBlLnRvSlNPTlxudmFyICRleHBvcnQgID0gcmVxdWlyZSgnLi8kLmV4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ1NldCcsIHt0b0pTT046IHJlcXVpcmUoJy4vJC5jb2xsZWN0aW9uLXRvLWpzb24nKSgnU2V0Jyl9KTsiLCJyZXF1aXJlKCcuL2VzNi5hcnJheS5pdGVyYXRvcicpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vJC5pdGVyYXRvcnMnKTtcbkl0ZXJhdG9ycy5Ob2RlTGlzdCA9IEl0ZXJhdG9ycy5IVE1MQ29sbGVjdGlvbiA9IEl0ZXJhdG9ycy5BcnJheTsiLCIvLyBUaGlzIG1ldGhvZCBvZiBvYnRhaW5pbmcgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QgbmVlZHMgdG8gYmVcbi8vIGtlcHQgaWRlbnRpY2FsIHRvIHRoZSB3YXkgaXQgaXMgb2J0YWluZWQgaW4gcnVudGltZS5qc1xudmFyIGcgPVxuICB0eXBlb2YgZ2xvYmFsID09PSBcIm9iamVjdFwiID8gZ2xvYmFsIDpcbiAgdHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIiA/IHdpbmRvdyA6XG4gIHR5cGVvZiBzZWxmID09PSBcIm9iamVjdFwiID8gc2VsZiA6IHRoaXM7XG5cbi8vIFVzZSBgZ2V0T3duUHJvcGVydHlOYW1lc2AgYmVjYXVzZSBub3QgYWxsIGJyb3dzZXJzIHN1cHBvcnQgY2FsbGluZ1xuLy8gYGhhc093blByb3BlcnR5YCBvbiB0aGUgZ2xvYmFsIGBzZWxmYCBvYmplY3QgaW4gYSB3b3JrZXIuIFNlZSAjMTgzLlxudmFyIGhhZFJ1bnRpbWUgPSBnLnJlZ2VuZXJhdG9yUnVudGltZSAmJlxuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhnKS5pbmRleE9mKFwicmVnZW5lcmF0b3JSdW50aW1lXCIpID49IDA7XG5cbi8vIFNhdmUgdGhlIG9sZCByZWdlbmVyYXRvclJ1bnRpbWUgaW4gY2FzZSBpdCBuZWVkcyB0byBiZSByZXN0b3JlZCBsYXRlci5cbnZhciBvbGRSdW50aW1lID0gaGFkUnVudGltZSAmJiBnLnJlZ2VuZXJhdG9yUnVudGltZTtcblxuLy8gRm9yY2UgcmVldmFsdXRhdGlvbiBvZiBydW50aW1lLmpzLlxuZy5yZWdlbmVyYXRvclJ1bnRpbWUgPSB1bmRlZmluZWQ7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vcnVudGltZVwiKTtcblxuaWYgKGhhZFJ1bnRpbWUpIHtcbiAgLy8gUmVzdG9yZSB0aGUgb3JpZ2luYWwgcnVudGltZS5cbiAgZy5yZWdlbmVyYXRvclJ1bnRpbWUgPSBvbGRSdW50aW1lO1xufSBlbHNlIHtcbiAgLy8gUmVtb3ZlIHRoZSBnbG9iYWwgcHJvcGVydHkgYWRkZWQgYnkgcnVudGltZS5qcy5cbiAgdHJ5IHtcbiAgICBkZWxldGUgZy5yZWdlbmVyYXRvclJ1bnRpbWU7XG4gIH0gY2F0Y2goZSkge1xuICAgIGcucmVnZW5lcmF0b3JSdW50aW1lID0gdW5kZWZpbmVkO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogbW9kdWxlLmV4cG9ydHMsIF9fZXNNb2R1bGU6IHRydWUgfTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIGh0dHBzOi8vcmF3LmdpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvbWFzdGVyL0xJQ0VOU0UgZmlsZS4gQW5cbiAqIGFkZGl0aW9uYWwgZ3JhbnQgb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpblxuICogdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgX1N5bWJvbCA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvc3ltYm9sXCIpW1wiZGVmYXVsdFwiXTtcblxudmFyIF9PYmplY3QkY3JlYXRlID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvY3JlYXRlXCIpW1wiZGVmYXVsdFwiXTtcblxudmFyIF9PYmplY3Qkc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9zZXQtcHJvdG90eXBlLW9mXCIpW1wiZGVmYXVsdFwiXTtcblxudmFyIF9Qcm9taXNlID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9wcm9taXNlXCIpW1wiZGVmYXVsdFwiXTtcblxuIShmdW5jdGlvbiAoZ2xvYmFsKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuICB2YXIgdW5kZWZpbmVkOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cbiAgdmFyICRTeW1ib2wgPSB0eXBlb2YgX1N5bWJvbCA9PT0gXCJmdW5jdGlvblwiID8gX1N5bWJvbCA6IHt9O1xuICB2YXIgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiO1xuICB2YXIgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuXG4gIHZhciBpbk1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCI7XG4gIHZhciBydW50aW1lID0gZ2xvYmFsLnJlZ2VuZXJhdG9yUnVudGltZTtcbiAgaWYgKHJ1bnRpbWUpIHtcbiAgICBpZiAoaW5Nb2R1bGUpIHtcbiAgICAgIC8vIElmIHJlZ2VuZXJhdG9yUnVudGltZSBpcyBkZWZpbmVkIGdsb2JhbGx5IGFuZCB3ZSdyZSBpbiBhIG1vZHVsZSxcbiAgICAgIC8vIG1ha2UgdGhlIGV4cG9ydHMgb2JqZWN0IGlkZW50aWNhbCB0byByZWdlbmVyYXRvclJ1bnRpbWUuXG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IHJ1bnRpbWU7XG4gICAgfVxuICAgIC8vIERvbid0IGJvdGhlciBldmFsdWF0aW5nIHRoZSByZXN0IG9mIHRoaXMgZmlsZSBpZiB0aGUgcnVudGltZSB3YXNcbiAgICAvLyBhbHJlYWR5IGRlZmluZWQgZ2xvYmFsbHkuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRGVmaW5lIHRoZSBydW50aW1lIGdsb2JhbGx5IChhcyBleHBlY3RlZCBieSBnZW5lcmF0ZWQgY29kZSkgYXMgZWl0aGVyXG4gIC8vIG1vZHVsZS5leHBvcnRzIChpZiB3ZSdyZSBpbiBhIG1vZHVsZSkgb3IgYSBuZXcsIGVtcHR5IG9iamVjdC5cbiAgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWUgPSBpbk1vZHVsZSA/IG1vZHVsZS5leHBvcnRzIDoge307XG5cbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIC8vIElmIG91dGVyRm4gcHJvdmlkZWQsIHRoZW4gb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IuXG4gICAgdmFyIGdlbmVyYXRvciA9IF9PYmplY3QkY3JlYXRlKChvdXRlckZuIHx8IEdlbmVyYXRvcikucHJvdG90eXBlKTtcbiAgICB2YXIgY29udGV4dCA9IG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKTtcblxuICAgIC8vIFRoZSAuX2ludm9rZSBtZXRob2QgdW5pZmllcyB0aGUgaW1wbGVtZW50YXRpb25zIG9mIHRoZSAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMuXG4gICAgZ2VuZXJhdG9yLl9pbnZva2UgPSBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuXG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfVxuICBydW50aW1lLndyYXAgPSB3cmFwO1xuXG4gIC8vIFRyeS9jYXRjaCBoZWxwZXIgdG8gbWluaW1pemUgZGVvcHRpbWl6YXRpb25zLiBSZXR1cm5zIGEgY29tcGxldGlvblxuICAvLyByZWNvcmQgbGlrZSBjb250ZXh0LnRyeUVudHJpZXNbaV0uY29tcGxldGlvbi4gVGhpcyBpbnRlcmZhY2UgY291bGRcbiAgLy8gaGF2ZSBiZWVuIChhbmQgd2FzIHByZXZpb3VzbHkpIGRlc2lnbmVkIHRvIHRha2UgYSBjbG9zdXJlIHRvIGJlXG4gIC8vIGludm9rZWQgd2l0aG91dCBhcmd1bWVudHMsIGJ1dCBpbiBhbGwgdGhlIGNhc2VzIHdlIGNhcmUgYWJvdXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZFxuICAvLyB0byBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gb2JqZWN0LiBXZSBjYW4gZXZlbiBnZXQgYXdheSB3aXRoIGFzc3VtaW5nXG4gIC8vIHRoZSBtZXRob2QgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIHNpbmNlIHRoYXQgaGFwcGVucyB0byBiZSB0cnVlXG4gIC8vIGluIGV2ZXJ5IGNhc2UsIHNvIHdlIGRvbid0IGhhdmUgdG8gdG91Y2ggdGhlIGFyZ3VtZW50cyBvYmplY3QuIFRoZVxuICAvLyBvbmx5IGFkZGl0aW9uYWwgYWxsb2NhdGlvbiByZXF1aXJlZCBpcyB0aGUgY29tcGxldGlvbiByZWNvcmQsIHdoaWNoXG4gIC8vIGhhcyBhIHN0YWJsZSBzaGFwZSBhbmQgc28gaG9wZWZ1bGx5IHNob3VsZCBiZSBjaGVhcCB0byBhbGxvY2F0ZS5cbiAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiBlcnIgfTtcbiAgICB9XG4gIH1cblxuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRTdGFydCA9IFwic3VzcGVuZGVkU3RhcnRcIjtcbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkWWllbGQgPSBcInN1c3BlbmRlZFlpZWxkXCI7XG4gIHZhciBHZW5TdGF0ZUV4ZWN1dGluZyA9IFwiZXhlY3V0aW5nXCI7XG4gIHZhciBHZW5TdGF0ZUNvbXBsZXRlZCA9IFwiY29tcGxldGVkXCI7XG5cbiAgLy8gUmV0dXJuaW5nIHRoaXMgb2JqZWN0IGZyb20gdGhlIGlubmVyRm4gaGFzIHRoZSBzYW1lIGVmZmVjdCBhc1xuICAvLyBicmVha2luZyBvdXQgb2YgdGhlIGRpc3BhdGNoIHN3aXRjaCBzdGF0ZW1lbnQuXG4gIHZhciBDb250aW51ZVNlbnRpbmVsID0ge307XG5cbiAgLy8gRHVtbXkgY29uc3RydWN0b3IgZnVuY3Rpb25zIHRoYXQgd2UgdXNlIGFzIHRoZSAuY29uc3RydWN0b3IgYW5kXG4gIC8vIC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgcHJvcGVydGllcyBmb3IgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIEdlbmVyYXRvclxuICAvLyBvYmplY3RzLiBGb3IgZnVsbCBzcGVjIGNvbXBsaWFuY2UsIHlvdSBtYXkgd2lzaCB0byBjb25maWd1cmUgeW91clxuICAvLyBtaW5pZmllciBub3QgdG8gbWFuZ2xlIHRoZSBuYW1lcyBvZiB0aGVzZSB0d28gZnVuY3Rpb25zLlxuICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cblxuICB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPSBHZW5lcmF0b3IucHJvdG90eXBlO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHcC5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZVt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcblxuICAvLyBIZWxwZXIgZm9yIGRlZmluaW5nIHRoZSAubmV4dCwgLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzIG9mIHRoZVxuICAvLyBJdGVyYXRvciBpbnRlcmZhY2UgaW4gdGVybXMgb2YgYSBzaW5nbGUgLl9pbnZva2UgbWV0aG9kLlxuICBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7XG4gICAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgcHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIHJ1bnRpbWUuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uIChnZW5GdW4pIHtcbiAgICB2YXIgY3RvciA9IHR5cGVvZiBnZW5GdW4gPT09IFwiZnVuY3Rpb25cIiAmJiBnZW5GdW4uY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIGN0b3IgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxuICAgIC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cbiAgICAvLyBkbyBpcyB0byBjaGVjayBpdHMgLm5hbWUgcHJvcGVydHkuXG4gICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiIDogZmFsc2U7XG4gIH07XG5cbiAgcnVudGltZS5tYXJrID0gZnVuY3Rpb24gKGdlbkZ1bikge1xuICAgIGlmIChfT2JqZWN0JHNldFByb3RvdHlwZU9mKSB7XG4gICAgICBfT2JqZWN0JHNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gICAgICBpZiAoISh0b1N0cmluZ1RhZ1N5bWJvbCBpbiBnZW5GdW4pKSB7XG4gICAgICAgIGdlbkZ1blt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGdlbkZ1bi5wcm90b3R5cGUgPSBfT2JqZWN0JGNyZWF0ZShHcCk7XG4gICAgcmV0dXJuIGdlbkZ1bjtcbiAgfTtcblxuICAvLyBXaXRoaW4gdGhlIGJvZHkgb2YgYW55IGFzeW5jIGZ1bmN0aW9uLCBgYXdhaXQgeGAgaXMgdHJhbnNmb3JtZWQgdG9cbiAgLy8gYHlpZWxkIHJlZ2VuZXJhdG9yUnVudGltZS5hd3JhcCh4KWAsIHNvIHRoYXQgdGhlIHJ1bnRpbWUgY2FuIHRlc3RcbiAgLy8gYHZhbHVlIGluc3RhbmNlb2YgQXdhaXRBcmd1bWVudGAgdG8gZGV0ZXJtaW5lIGlmIHRoZSB5aWVsZGVkIHZhbHVlIGlzXG4gIC8vIG1lYW50IHRvIGJlIGF3YWl0ZWQuIFNvbWUgbWF5IGNvbnNpZGVyIHRoZSBuYW1lIG9mIHRoaXMgbWV0aG9kIHRvb1xuICAvLyBjdXRlc3ksIGJ1dCB0aGV5IGFyZSBjdXJtdWRnZW9ucy5cbiAgcnVudGltZS5hd3JhcCA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgICByZXR1cm4gbmV3IEF3YWl0QXJndW1lbnQoYXJnKTtcbiAgfTtcblxuICBmdW5jdGlvbiBBd2FpdEFyZ3VtZW50KGFyZykge1xuICAgIHRoaXMuYXJnID0gYXJnO1xuICB9XG5cbiAgZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICByZWplY3QocmVjb3JkLmFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZztcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBd2FpdEFyZ3VtZW50KSB7XG4gICAgICAgICAgcmV0dXJuIF9Qcm9taXNlLnJlc29sdmUodmFsdWUuYXJnKS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX1Byb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbiAodW53cmFwcGVkKSB7XG4gICAgICAgICAgLy8gV2hlbiBhIHlpZWxkZWQgUHJvbWlzZSBpcyByZXNvbHZlZCwgaXRzIGZpbmFsIHZhbHVlIGJlY29tZXNcbiAgICAgICAgICAvLyB0aGUgLnZhbHVlIG9mIHRoZSBQcm9taXNlPHt2YWx1ZSxkb25lfT4gcmVzdWx0IGZvciB0aGVcbiAgICAgICAgICAvLyBjdXJyZW50IGl0ZXJhdGlvbi4gSWYgdGhlIFByb21pc2UgaXMgcmVqZWN0ZWQsIGhvd2V2ZXIsIHRoZVxuICAgICAgICAgIC8vIHJlc3VsdCBmb3IgdGhpcyBpdGVyYXRpb24gd2lsbCBiZSByZWplY3RlZCB3aXRoIHRoZSBzYW1lXG4gICAgICAgICAgLy8gcmVhc29uLiBOb3RlIHRoYXQgcmVqZWN0aW9ucyBvZiB5aWVsZGVkIFByb21pc2VzIGFyZSBub3RcbiAgICAgICAgICAvLyB0aHJvd24gYmFjayBpbnRvIHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24sIGFzIGlzIHRoZSBjYXNlXG4gICAgICAgICAgLy8gd2hlbiBhbiBhd2FpdGVkIFByb21pc2UgaXMgcmVqZWN0ZWQuIFRoaXMgZGlmZmVyZW5jZSBpblxuICAgICAgICAgIC8vIGJlaGF2aW9yIGJldHdlZW4geWllbGQgYW5kIGF3YWl0IGlzIGltcG9ydGFudCwgYmVjYXVzZSBpdFxuICAgICAgICAgIC8vIGFsbG93cyB0aGUgY29uc3VtZXIgdG8gZGVjaWRlIHdoYXQgdG8gZG8gd2l0aCB0aGUgeWllbGRlZFxuICAgICAgICAgIC8vIHJlamVjdGlvbiAoc3dhbGxvdyBpdCBhbmQgY29udGludWUsIG1hbnVhbGx5IC50aHJvdyBpdCBiYWNrXG4gICAgICAgICAgLy8gaW50byB0aGUgZ2VuZXJhdG9yLCBhYmFuZG9uIGl0ZXJhdGlvbiwgd2hhdGV2ZXIpLiBXaXRoXG4gICAgICAgICAgLy8gYXdhaXQsIGJ5IGNvbnRyYXN0LCB0aGVyZSBpcyBubyBvcHBvcnR1bml0eSB0byBleGFtaW5lIHRoZVxuICAgICAgICAgIC8vIHJlamVjdGlvbiByZWFzb24gb3V0c2lkZSB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uLCBzbyB0aGVcbiAgICAgICAgICAvLyBvbmx5IG9wdGlvbiBpcyB0byB0aHJvdyBpdCBmcm9tIHRoZSBhd2FpdCBleHByZXNzaW9uLCBhbmRcbiAgICAgICAgICAvLyBsZXQgdGhlIGdlbmVyYXRvciBmdW5jdGlvbiBoYW5kbGUgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQ7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9LCByZWplY3QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJiBwcm9jZXNzLmRvbWFpbikge1xuICAgICAgaW52b2tlID0gcHJvY2Vzcy5kb21haW4uYmluZChpbnZva2UpO1xuICAgIH1cblxuICAgIHZhciBwcmV2aW91c1Byb21pc2U7XG5cbiAgICBmdW5jdGlvbiBlbnF1ZXVlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBfUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9XG4gICAgICAvLyBJZiBlbnF1ZXVlIGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byB3YWl0IHVudGlsXG4gICAgICAvLyBhbGwgcHJldmlvdXMgUHJvbWlzZXMgaGF2ZSBiZWVuIHJlc29sdmVkIGJlZm9yZSBjYWxsaW5nIGludm9rZSxcbiAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcbiAgICAgIC8vIGVucXVldWUgaGFzIG5vdCBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gaXQgaXMgaW1wb3J0YW50IHRvXG4gICAgICAvLyBjYWxsIGludm9rZSBpbW1lZGlhdGVseSwgd2l0aG91dCB3YWl0aW5nIG9uIGEgY2FsbGJhY2sgdG8gZmlyZSxcbiAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXG4gICAgICAvLyBhbnkgbmVjZXNzYXJ5IHNldHVwIGluIGEgcHJlZGljdGFibGUgd2F5LiBUaGlzIHByZWRpY3RhYmlsaXR5XG4gICAgICAvLyBpcyB3aHkgdGhlIFByb21pc2UgY29uc3RydWN0b3Igc3luY2hyb25vdXNseSBpbnZva2VzIGl0c1xuICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcbiAgICAgIC8vIGV4ZWN1dGUgY29kZSBiZWZvcmUgdGhlIGZpcnN0IGF3YWl0LiBTaW5jZSB3ZSBpbXBsZW1lbnQgc2ltcGxlXG4gICAgICAvLyBhc3luYyBmdW5jdGlvbnMgaW4gdGVybXMgb2YgYXN5bmMgZ2VuZXJhdG9ycywgaXQgaXMgZXNwZWNpYWxseVxuICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxuICAgICAgcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcsXG4gICAgICAvLyBBdm9pZCBwcm9wYWdhdGluZyBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieSBsYXRlclxuICAgICAgLy8gaW52b2NhdGlvbnMgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcpIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICB9XG5cbiAgICAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxuICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XG4gIH1cblxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xuXG4gIC8vIE5vdGUgdGhhdCBzaW1wbGUgYXN5bmMgZnVuY3Rpb25zIGFyZSBpbXBsZW1lbnRlZCBvbiB0b3Agb2ZcbiAgLy8gQXN5bmNJdGVyYXRvciBvYmplY3RzOyB0aGV5IGp1c3QgcmV0dXJuIGEgUHJvbWlzZSBmb3IgdGhlIHZhbHVlIG9mXG4gIC8vIHRoZSBmaW5hbCByZXN1bHQgcHJvZHVjZWQgYnkgdGhlIGl0ZXJhdG9yLlxuICBydW50aW1lLmFzeW5jID0gZnVuY3Rpb24gKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcih3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSk7XG5cbiAgICByZXR1cm4gcnVudGltZS5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pID8gaXRlciAvLyBJZiBvdXRlckZuIGlzIGEgZ2VuZXJhdG9yLCByZXR1cm4gdGhlIGZ1bGwgaXRlcmF0b3IuXG4gICAgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgIHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpO1xuICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xuICAgIHZhciBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmUgZm9yZ2l2aW5nLCBwZXIgMjUuMy4zLjMuMyBvZiB0aGUgc3BlYzpcbiAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxuICAgICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlO1xuICAgICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICBpZiAobWV0aG9kID09PSBcInJldHVyblwiIHx8IG1ldGhvZCA9PT0gXCJ0aHJvd1wiICYmIGRlbGVnYXRlLml0ZXJhdG9yW21ldGhvZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gQSByZXR1cm4gb3IgdGhyb3cgKHdoZW4gdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBubyB0aHJvd1xuICAgICAgICAgICAgLy8gbWV0aG9kKSBhbHdheXMgdGVybWluYXRlcyB0aGUgeWllbGQqIGxvb3AuXG4gICAgICAgICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgICAgICAgLy8gSWYgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBhIHJldHVybiBtZXRob2QsIGdpdmUgaXQgYVxuICAgICAgICAgICAgLy8gY2hhbmNlIHRvIGNsZWFuIHVwLlxuICAgICAgICAgICAgdmFyIHJldHVybk1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW1wicmV0dXJuXCJdO1xuICAgICAgICAgICAgaWYgKHJldHVybk1ldGhvZCkge1xuICAgICAgICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2gocmV0dXJuTWV0aG9kLCBkZWxlZ2F0ZS5pdGVyYXRvciwgYXJnKTtcbiAgICAgICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcmV0dXJuIG1ldGhvZCB0aHJldyBhbiBleGNlcHRpb24sIGxldCB0aGF0XG4gICAgICAgICAgICAgICAgLy8gZXhjZXB0aW9uIHByZXZhaWwgb3ZlciB0aGUgb3JpZ2luYWwgcmV0dXJuIG9yIHRocm93LlxuICAgICAgICAgICAgICAgIG1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICAgICAgICBhcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICAgICAgLy8gQ29udGludWUgd2l0aCB0aGUgb3V0ZXIgcmV0dXJuLCBub3cgdGhhdCB0aGUgZGVsZWdhdGVcbiAgICAgICAgICAgICAgLy8gaXRlcmF0b3IgaGFzIGJlZW4gdGVybWluYXRlZC5cbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGRlbGVnYXRlLml0ZXJhdG9yW21ldGhvZF0sIGRlbGVnYXRlLml0ZXJhdG9yLCBhcmcpO1xuXG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICAgICAgICAvLyBMaWtlIHJldHVybmluZyBnZW5lcmF0b3IudGhyb3codW5jYXVnaHQpLCBidXQgd2l0aG91dCB0aGVcbiAgICAgICAgICAgIC8vIG92ZXJoZWFkIG9mIGFuIGV4dHJhIGZ1bmN0aW9uIGNhbGwuXG4gICAgICAgICAgICBtZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgICBhcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gRGVsZWdhdGUgZ2VuZXJhdG9yIHJhbiBhbmQgaGFuZGxlZCBpdHMgb3duIGV4Y2VwdGlvbnMgc29cbiAgICAgICAgICAvLyByZWdhcmRsZXNzIG9mIHdoYXQgdGhlIG1ldGhvZCB3YXMsIHdlIGNvbnRpbnVlIGFzIGlmIGl0IGlzXG4gICAgICAgICAgLy8gXCJuZXh0XCIgd2l0aCBhbiB1bmRlZmluZWQgYXJnLlxuICAgICAgICAgIG1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgIGFyZyA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcbiAgICAgICAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICAgICAgICBjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZTtcbiAgICAgICAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcbiAgICAgICAgICAgIHJldHVybiBpbmZvO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkWWllbGQpIHtcbiAgICAgICAgICAgIGNvbnRleHQuc2VudCA9IGFyZztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udGV4dC5zZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihhcmcpKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgICAgLy8gdGhlbiBsZXQgdGhhdCBjYXRjaCBibG9jayBoYW5kbGUgdGhlIGV4Y2VwdGlvbiBub3JtYWxseS5cbiAgICAgICAgICAgIG1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgICAgYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChtZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBhcmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUV4ZWN1dGluZztcblxuICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG4gICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIikge1xuICAgICAgICAgIC8vIElmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gZnJvbSBpbm5lckZuLCB3ZSBsZWF2ZSBzdGF0ZSA9PT1cbiAgICAgICAgICAvLyBHZW5TdGF0ZUV4ZWN1dGluZyBhbmQgbG9vcCBiYWNrIGZvciBhbm90aGVyIGludm9jYXRpb24uXG4gICAgICAgICAgc3RhdGUgPSBjb250ZXh0LmRvbmUgPyBHZW5TdGF0ZUNvbXBsZXRlZCA6IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XG5cbiAgICAgICAgICB2YXIgaW5mbyA9IHtcbiAgICAgICAgICAgIHZhbHVlOiByZWNvcmQuYXJnLFxuICAgICAgICAgICAgZG9uZTogY29udGV4dC5kb25lXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmIChyZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSB7XG4gICAgICAgICAgICBpZiAoY29udGV4dC5kZWxlZ2F0ZSAmJiBtZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgICAgIC8vIERlbGliZXJhdGVseSBmb3JnZXQgdGhlIGxhc3Qgc2VudCB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAgICAgICAgIC8vIGFjY2lkZW50YWxseSBwYXNzIGl0IG9uIHRvIHRoZSBkZWxlZ2F0ZS5cbiAgICAgICAgICAgICAgYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaW5mbztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgLy8gRGlzcGF0Y2ggdGhlIGV4Y2VwdGlvbiBieSBsb29waW5nIGJhY2sgYXJvdW5kIHRvIHRoZVxuICAgICAgICAgIC8vIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oYXJnKSBjYWxsIGFib3ZlLlxuICAgICAgICAgIG1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICBhcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIERlZmluZSBHZW5lcmF0b3IucHJvdG90eXBlLntuZXh0LHRocm93LHJldHVybn0gaW4gdGVybXMgb2YgdGhlXG4gIC8vIHVuaWZpZWQgLl9pbnZva2UgaGVscGVyIG1ldGhvZC5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEdwKTtcblxuICBHcFtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgR3BbdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JcIjtcblxuICBHcC50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjtcbiAgfTtcblxuICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykge1xuICAgIHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07XG5cbiAgICBpZiAoMSBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV07XG4gICAgfVxuXG4gICAgaWYgKDIgaW4gbG9jcykge1xuICAgICAgZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl07XG4gICAgICBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM107XG4gICAgfVxuXG4gICAgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xuICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xuICAgIHJlY29yZC50eXBlID0gXCJub3JtYWxcIjtcbiAgICBkZWxldGUgcmVjb3JkLmFyZztcbiAgICBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xuICAgIC8vIFRoZSByb290IGVudHJ5IG9iamVjdCAoZWZmZWN0aXZlbHkgYSB0cnkgc3RhdGVtZW50IHdpdGhvdXQgYSBjYXRjaFxuICAgIC8vIG9yIGEgZmluYWxseSBibG9jaykgZ2l2ZXMgdXMgYSBwbGFjZSB0byBzdG9yZSB2YWx1ZXMgdGhyb3duIGZyb21cbiAgICAvLyBsb2NhdGlvbnMgd2hlcmUgdGhlcmUgaXMgbm8gZW5jbG9zaW5nIHRyeSBzdGF0ZW1lbnQuXG4gICAgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XTtcbiAgICB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyk7XG4gICAgdGhpcy5yZXNldCh0cnVlKTtcbiAgfVxuXG4gIHJ1bnRpbWUua2V5cyA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBrZXlzLnJldmVyc2UoKTtcblxuICAgIC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcbiAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLFxuICAgICAgICAgICAgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgd2hpbGUgKCsraSA8IGl0ZXJhYmxlLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkge1xuICAgICAgICAgICAgICBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV07XG4gICAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXh0LnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG5leHQuZG9uZSA9IHRydWU7XG5cbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYW4gaXRlcmF0b3Igd2l0aCBubyB2YWx1ZXMuXG4gICAgcmV0dXJuIHsgbmV4dDogZG9uZVJlc3VsdCB9O1xuICB9XG4gIHJ1bnRpbWUudmFsdWVzID0gdmFsdWVzO1xuXG4gIGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9XG5cbiAgQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENvbnRleHQsXG5cbiAgICByZXNldDogZnVuY3Rpb24gcmVzZXQoc2tpcFRlbXBSZXNldCkge1xuICAgICAgdGhpcy5wcmV2ID0gMDtcbiAgICAgIHRoaXMubmV4dCA9IDA7XG4gICAgICB0aGlzLnNlbnQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KTtcblxuICAgICAgaWYgKCFza2lwVGVtcFJlc2V0KSB7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcykge1xuICAgICAgICAgIC8vIE5vdCBzdXJlIGFib3V0IHRoZSBvcHRpbWFsIG9yZGVyIG9mIHRoZXNlIGNvbmRpdGlvbnM6XG4gICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09PSBcInRcIiAmJiBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJiAhaXNOYU4oK25hbWUuc2xpY2UoMSkpKSB7XG4gICAgICAgICAgICB0aGlzW25hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdG9wOiBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcblxuICAgICAgdmFyIHJvb3RFbnRyeSA9IHRoaXMudHJ5RW50cmllc1swXTtcbiAgICAgIHZhciByb290UmVjb3JkID0gcm9vdEVudHJ5LmNvbXBsZXRpb247XG4gICAgICBpZiAocm9vdFJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcm9vdFJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJ2YWw7XG4gICAgfSxcblxuICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbiBkaXNwYXRjaEV4Y2VwdGlvbihleGNlcHRpb24pIHtcbiAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcbiAgICAgICAgcmVjb3JkLnR5cGUgPSBcInRocm93XCI7XG4gICAgICAgIHJlY29yZC5hcmcgPSBleGNlcHRpb247XG4gICAgICAgIGNvbnRleHQubmV4dCA9IGxvYztcbiAgICAgICAgcmV0dXJuICEhY2F1Z2h0O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgICAvLyBFeGNlcHRpb24gdGhyb3duIG91dHNpZGUgb2YgYW55IHRyeSBibG9jayB0aGF0IGNvdWxkIGhhbmRsZVxuICAgICAgICAgIC8vIGl0LCBzbyBzZXQgdGhlIGNvbXBsZXRpb24gdmFsdWUgb2YgdGhlIGVudGlyZSBmdW5jdGlvbiB0b1xuICAgICAgICAgIC8vIHRocm93IHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZShcImVuZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7XG4gICAgICAgICAgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIik7XG4gICAgICAgICAgdmFyIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpO1xuXG4gICAgICAgICAgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhYnJ1cHQ6IGZ1bmN0aW9uIGFicnVwdCh0eXBlLCBhcmcpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJiBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJiAodHlwZSA9PT0gXCJicmVha1wiIHx8IHR5cGUgPT09IFwiY29udGludWVcIikgJiYgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiYgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvbXBsZXRlKHJlY29yZCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24gY29tcGxldGUocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHwgcmVjb3JkLnR5cGUgPT09IFwiY29udGludWVcIikge1xuICAgICAgICB0aGlzLm5leHQgPSByZWNvcmQuYXJnO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICB0aGlzLnJ2YWwgPSByZWNvcmQuYXJnO1xuICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBhZnRlckxvYykge1xuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZmluaXNoOiBmdW5jdGlvbiBmaW5pc2goZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbiBfY2F0Y2godHJ5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aHJvd247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGNvbnRleHQuY2F0Y2ggbWV0aG9kIG11c3Qgb25seSBiZSBjYWxsZWQgd2l0aCBhIGxvY2F0aW9uXG4gICAgICAvLyBhcmd1bWVudCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEga25vd24gY2F0Y2ggYmxvY2suXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7XG4gICAgfSxcblxuICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uIGRlbGVnYXRlWWllbGQoaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG4gIH07XG59KShcbi8vIEFtb25nIHRoZSB2YXJpb3VzIHRyaWNrcyBmb3Igb2J0YWluaW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWxcbi8vIG9iamVjdCwgdGhpcyBzZWVtcyB0byBiZSB0aGUgbW9zdCByZWxpYWJsZSB0ZWNobmlxdWUgdGhhdCBkb2VzIG5vdFxuLy8gdXNlIGluZGlyZWN0IGV2YWwgKHdoaWNoIHZpb2xhdGVzIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5KS5cbnR5cGVvZiBnbG9iYWwgPT09IFwib2JqZWN0XCIgPyBnbG9iYWwgOiB0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiID8gd2luZG93IDogdHlwZW9mIHNlbGYgPT09IFwib2JqZWN0XCIgPyBzZWxmIDogdW5kZWZpbmVkKTsiLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxudmFyIHJvb3RQYXJlbnQgPSB7fVxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBEdWUgdG8gdmFyaW91cyBicm93c2VyIGJ1Z3MsIHNvbWV0aW1lcyB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uIHdpbGwgYmUgdXNlZCBldmVuXG4gKiB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIHR5cGVkIGFycmF5cy5cbiAqXG4gKiBOb3RlOlxuICpcbiAqICAgLSBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMsXG4gKiAgICAgU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzguXG4gKlxuICogICAtIFNhZmFyaSA1LTcgbGFja3Mgc3VwcG9ydCBmb3IgY2hhbmdpbmcgdGhlIGBPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yYCBwcm9wZXJ0eVxuICogICAgIG9uIG9iamVjdHMuXG4gKlxuICogICAtIENocm9tZSA5LTEwIGlzIG1pc3NpbmcgdGhlIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24uXG4gKlxuICogICAtIElFMTAgaGFzIGEgYnJva2VuIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhcnJheXMgb2ZcbiAqICAgICBpbmNvcnJlY3QgbGVuZ3RoIGluIHNvbWUgc2l0dWF0aW9ucy5cblxuICogV2UgZGV0ZWN0IHRoZXNlIGJ1Z2d5IGJyb3dzZXJzIGFuZCBzZXQgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYCB0byBgZmFsc2VgIHNvIHRoZXlcbiAqIGdldCB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uLCB3aGljaCBpcyBzbG93ZXIgYnV0IGJlaGF2ZXMgY29ycmVjdGx5LlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUICE9PSB1bmRlZmluZWRcbiAgPyBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVFxuICA6IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICBmdW5jdGlvbiBCYXIgKCkge31cbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICBhcnIuZm9vID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfVxuICAgIGFyci5jb25zdHJ1Y3RvciA9IEJhclxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyICYmIC8vIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkXG4gICAgICAgIGFyci5jb25zdHJ1Y3RvciA9PT0gQmFyICYmIC8vIGNvbnN0cnVjdG9yIGNhbiBiZSBzZXRcbiAgICAgICAgdHlwZW9mIGFyci5zdWJhcnJheSA9PT0gJ2Z1bmN0aW9uJyAmJiAvLyBjaHJvbWUgOS0xMCBsYWNrIGBzdWJhcnJheWBcbiAgICAgICAgYXJyLnN1YmFycmF5KDEsIDEpLmJ5dGVMZW5ndGggPT09IDAgLy8gaWUxMCBoYXMgYnJva2VuIGBzdWJhcnJheWBcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIGtNYXhMZW5ndGggKCkge1xuICByZXR1cm4gQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgICA/IDB4N2ZmZmZmZmZcbiAgICA6IDB4M2ZmZmZmZmZcbn1cblxuLyoqXG4gKiBDbGFzczogQnVmZmVyXG4gKiA9PT09PT09PT09PT09XG4gKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBhcmUgYXVnbWVudGVkXG4gKiB3aXRoIGZ1bmN0aW9uIHByb3BlcnRpZXMgZm9yIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBBUEkgZnVuY3Rpb25zLiBXZSB1c2VcbiAqIGBVaW50OEFycmF5YCBzbyB0aGF0IHNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0IHJldHVybnNcbiAqIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIEJ5IGF1Z21lbnRpbmcgdGhlIGluc3RhbmNlcywgd2UgY2FuIGF2b2lkIG1vZGlmeWluZyB0aGUgYFVpbnQ4QXJyYXlgXG4gKiBwcm90b3R5cGUuXG4gKi9cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgLy8gQXZvaWQgZ29pbmcgdGhyb3VnaCBhbiBBcmd1bWVudHNBZGFwdG9yVHJhbXBvbGluZSBpbiB0aGUgY29tbW9uIGNhc2UuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSByZXR1cm4gbmV3IEJ1ZmZlcihhcmcsIGFyZ3VtZW50c1sxXSlcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihhcmcpXG4gIH1cblxuICB0aGlzLmxlbmd0aCA9IDBcbiAgdGhpcy5wYXJlbnQgPSB1bmRlZmluZWRcblxuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIGZyb21OdW1iZXIodGhpcywgYXJnKVxuICB9XG5cbiAgLy8gU2xpZ2h0bHkgbGVzcyBjb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodGhpcywgYXJnLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6ICd1dGY4JylcbiAgfVxuXG4gIC8vIFVudXN1YWwuXG4gIHJldHVybiBmcm9tT2JqZWN0KHRoaXMsIGFyZylcbn1cblxuZnVuY3Rpb24gZnJvbU51bWJlciAodGhhdCwgbGVuZ3RoKSB7XG4gIHRoYXQgPSBhbGxvY2F0ZSh0aGF0LCBsZW5ndGggPCAwID8gMCA6IGNoZWNrZWQobGVuZ3RoKSB8IDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGF0W2ldID0gMFxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nICh0aGF0LCBzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykgZW5jb2RpbmcgPSAndXRmOCdcblxuICAvLyBBc3N1bXB0aW9uOiBieXRlTGVuZ3RoKCkgcmV0dXJuIHZhbHVlIGlzIGFsd2F5cyA8IGtNYXhMZW5ndGguXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICB0aGF0ID0gYWxsb2NhdGUodGhhdCwgbGVuZ3RoKVxuXG4gIHRoYXQud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAodGhhdCwgb2JqZWN0KSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqZWN0KSkgcmV0dXJuIGZyb21CdWZmZXIodGhhdCwgb2JqZWN0KVxuXG4gIGlmIChpc0FycmF5KG9iamVjdCkpIHJldHVybiBmcm9tQXJyYXkodGhhdCwgb2JqZWN0KVxuXG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ211c3Qgc3RhcnQgd2l0aCBudW1iZXIsIGJ1ZmZlciwgYXJyYXkgb3Igc3RyaW5nJylcbiAgfVxuXG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKG9iamVjdC5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgcmV0dXJuIGZyb21UeXBlZEFycmF5KHRoYXQsIG9iamVjdClcbiAgICB9XG4gICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHRoYXQsIG9iamVjdClcbiAgICB9XG4gIH1cblxuICBpZiAob2JqZWN0Lmxlbmd0aCkgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqZWN0KVxuXG4gIHJldHVybiBmcm9tSnNvbk9iamVjdCh0aGF0LCBvYmplY3QpXG59XG5cbmZ1bmN0aW9uIGZyb21CdWZmZXIgKHRoYXQsIGJ1ZmZlcikge1xuICB2YXIgbGVuZ3RoID0gY2hlY2tlZChidWZmZXIubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGFsbG9jYXRlKHRoYXQsIGxlbmd0aClcbiAgYnVmZmVyLmNvcHkodGhhdCwgMCwgMCwgbGVuZ3RoKVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXkgKHRoYXQsIGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBhbGxvY2F0ZSh0aGF0LCBsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG4vLyBEdXBsaWNhdGUgb2YgZnJvbUFycmF5KCkgdG8ga2VlcCBmcm9tQXJyYXkoKSBtb25vbW9ycGhpYy5cbmZ1bmN0aW9uIGZyb21UeXBlZEFycmF5ICh0aGF0LCBhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB0aGF0ID0gYWxsb2NhdGUodGhhdCwgbGVuZ3RoKVxuICAvLyBUcnVuY2F0aW5nIHRoZSBlbGVtZW50cyBpcyBwcm9iYWJseSBub3Qgd2hhdCBwZW9wbGUgZXhwZWN0IGZyb20gdHlwZWRcbiAgLy8gYXJyYXlzIHdpdGggQllURVNfUEVSX0VMRU1FTlQgPiAxIGJ1dCBpdCdzIGNvbXBhdGlibGUgd2l0aCB0aGUgYmVoYXZpb3JcbiAgLy8gb2YgdGhlIG9sZCBCdWZmZXIgY29uc3RydWN0b3IuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKHRoYXQsIGFycmF5KSB7XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIGFycmF5LmJ5dGVMZW5ndGhcbiAgICB0aGF0ID0gQnVmZmVyLl9hdWdtZW50KG5ldyBVaW50OEFycmF5KGFycmF5KSlcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgdGhhdCA9IGZyb21UeXBlZEFycmF5KHRoYXQsIG5ldyBVaW50OEFycmF5KGFycmF5KSlcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlICh0aGF0LCBhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB0aGF0ID0gYWxsb2NhdGUodGhhdCwgbGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuLy8gRGVzZXJpYWxpemUgeyB0eXBlOiAnQnVmZmVyJywgZGF0YTogWzEsMiwzLC4uLl0gfSBpbnRvIGEgQnVmZmVyIG9iamVjdC5cbi8vIFJldHVybnMgYSB6ZXJvLWxlbmd0aCBidWZmZXIgZm9yIGlucHV0cyB0aGF0IGRvbid0IGNvbmZvcm0gdG8gdGhlIHNwZWMuXG5mdW5jdGlvbiBmcm9tSnNvbk9iamVjdCAodGhhdCwgb2JqZWN0KSB7XG4gIHZhciBhcnJheVxuICB2YXIgbGVuZ3RoID0gMFxuXG4gIGlmIChvYmplY3QudHlwZSA9PT0gJ0J1ZmZlcicgJiYgaXNBcnJheShvYmplY3QuZGF0YSkpIHtcbiAgICBhcnJheSA9IG9iamVjdC5kYXRhXG4gICAgbGVuZ3RoID0gY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB9XG4gIHRoYXQgPSBhbGxvY2F0ZSh0aGF0LCBsZW5ndGgpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICBCdWZmZXIucHJvdG90eXBlLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlXG4gIEJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5XG59XG5cbmZ1bmN0aW9uIGFsbG9jYXRlICh0aGF0LCBsZW5ndGgpIHtcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IEJ1ZmZlci5fYXVnbWVudChuZXcgVWludDhBcnJheShsZW5ndGgpKVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICB0aGF0Lmxlbmd0aCA9IGxlbmd0aFxuICAgIHRoYXQuX2lzQnVmZmVyID0gdHJ1ZVxuICB9XG5cbiAgdmFyIGZyb21Qb29sID0gbGVuZ3RoICE9PSAwICYmIGxlbmd0aCA8PSBCdWZmZXIucG9vbFNpemUgPj4+IDFcbiAgaWYgKGZyb21Qb29sKSB0aGF0LnBhcmVudCA9IHJvb3RQYXJlbnRcblxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwga01heExlbmd0aGAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBrTWF4TGVuZ3RoKCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsga01heExlbmd0aCgpLnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKHN1YmplY3QsIGVuY29kaW5nKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTbG93QnVmZmVyKSkgcmV0dXJuIG5ldyBTbG93QnVmZmVyKHN1YmplY3QsIGVuY29kaW5nKVxuXG4gIHZhciBidWYgPSBuZXcgQnVmZmVyKHN1YmplY3QsIGVuY29kaW5nKVxuICBkZWxldGUgYnVmLnBhcmVudFxuICByZXR1cm4gYnVmXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIG11c3QgYmUgQnVmZmVycycpXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcblxuICB2YXIgaSA9IDBcbiAgdmFyIGxlbiA9IE1hdGgubWluKHgsIHkpXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIGJyZWFrXG5cbiAgICArK2lcbiAgfVxuXG4gIGlmIChpICE9PSBsZW4pIHtcbiAgICB4ID0gYVtpXVxuICAgIHkgPSBiW2ldXG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3Jhdyc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIWlzQXJyYXkobGlzdCkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2xpc3QgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzLicpXG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoMClcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIobGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gbGlzdFtpXVxuICAgIGl0ZW0uY29weShidWYsIHBvcylcbiAgICBwb3MgKz0gaXRlbS5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSBzdHJpbmcgPSAnJyArIHN0cmluZ1xuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgLy8gRGVwcmVjYXRlZFxuICAgICAgY2FzZSAncmF3JzpcbiAgICAgIGNhc2UgJ3Jhd3MnOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuLy8gcHJlLXNldCBmb3IgdmFsdWVzIHRoYXQgbWF5IGV4aXN0IGluIHRoZSBmdXR1cmVcbkJ1ZmZlci5wcm90b3R5cGUubGVuZ3RoID0gdW5kZWZpbmVkXG5CdWZmZXIucHJvdG90eXBlLnBhcmVudCA9IHVuZGVmaW5lZFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgc3RhcnQgPSBzdGFydCB8IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID09PSBJbmZpbml0eSA/IHRoaXMubGVuZ3RoIDogZW5kIHwgMFxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG4gIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmIChlbmQgPD0gc3RhcnQpIHJldHVybiAnJ1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGJpbmFyeVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGggfCAwXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIHZhciBzdHIgPSAnJ1xuICB2YXIgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJylcbiAgICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIH1cbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gMFxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYilcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0KSB7XG4gIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgYnl0ZU9mZnNldCA+Pj0gMFxuXG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG4gIGlmIChieXRlT2Zmc2V0ID49IHRoaXMubGVuZ3RoKSByZXR1cm4gLTFcblxuICAvLyBOZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IE1hdGgubWF4KHRoaXMubGVuZ3RoICsgYnl0ZU9mZnNldCwgMClcblxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xIC8vIHNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nIGFsd2F5cyBmYWlsc1xuICAgIHJldHVybiBTdHJpbmcucHJvdG90eXBlLmluZGV4T2YuY2FsbCh0aGlzLCB2YWwsIGJ5dGVPZmZzZXQpXG4gIH1cbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQpXG4gIH1cbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwodGhpcywgdmFsLCBieXRlT2Zmc2V0KVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKHRoaXMsIFsgdmFsIF0sIGJ5dGVPZmZzZXQpXG4gIH1cblxuICBmdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0KSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAodmFyIGkgPSAwOyBieXRlT2Zmc2V0ICsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFycltieXRlT2Zmc2V0ICsgaV0gPT09IHZhbFtmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleF0pIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWwubGVuZ3RoKSByZXR1cm4gYnl0ZU9mZnNldCArIGZvdW5kSW5kZXhcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTFcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbi8vIGBnZXRgIGlzIGRlcHJlY2F0ZWRcbkJ1ZmZlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChvZmZzZXQpIHtcbiAgY29uc29sZS5sb2coJy5nZXQoKSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdXNpbmcgYXJyYXkgaW5kZXhlcyBpbnN0ZWFkLicpXG4gIHJldHVybiB0aGlzLnJlYWRVSW50OChvZmZzZXQpXG59XG5cbi8vIGBzZXRgIGlzIGRlcHJlY2F0ZWRcbkJ1ZmZlci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gc2V0ICh2LCBvZmZzZXQpIHtcbiAgY29uc29sZS5sb2coJy5zZXQoKSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdXNpbmcgYXJyYXkgaW5kZXhlcyBpbnN0ZWFkLicpXG4gIHJldHVybiB0aGlzLndyaXRlVUludDgodiwgb2Zmc2V0KVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChzdHJMZW4gJSAyICE9PSAwKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKGlzTmFOKHBhcnNlZCkpIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJpbmFyeVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoIHwgMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIC8vIGxlZ2FjeSB3cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aCkgLSByZW1vdmUgaW4gdjAuMTNcbiAgfSBlbHNlIHtcbiAgICB2YXIgc3dhcCA9IGVuY29kaW5nXG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBvZmZzZXQgPSBsZW5ndGggfCAwXG4gICAgbGVuZ3RoID0gc3dhcFxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBiaW5hcnlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIHZhciByZXMgPSBbXVxuXG4gIHZhciBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGxcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xuICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXG4gICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgdmFyIHJlcyA9ICcnXG4gIHZhciBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGJpbmFyeVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0gKiAyNTYpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZlxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBuZXdCdWYgPSBCdWZmZXIuX2F1Z21lbnQodGhpcy5zdWJhcnJheShzdGFydCwgZW5kKSlcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydFxuICAgIG5ld0J1ZiA9IG5ldyBCdWZmZXIoc2xpY2VMZW4sIHVuZGVmaW5lZClcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyBpKyspIHtcbiAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfVxuXG4gIGlmIChuZXdCdWYubGVuZ3RoKSBuZXdCdWYucGFyZW50ID0gdGhpcy5wYXJlbnQgfHwgdGhpc1xuXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoXG4gIHZhciBtdWwgPSAxXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignYnVmZmVyIG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCd2YWx1ZSBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSwgMClcblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSwgMClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgMik7IGkgPCBqOyBpKyspIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSkpID4+PlxuICAgICAgKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDQpOyBpIDwgajsgaSsrKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZlxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IHZhbHVlIDwgMCA/IDEgOiAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gdmFsdWUgPCAwID8gMSA6IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndmFsdWUgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignaW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuICB2YXIgaVxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIGlmIChsZW4gPCAxMDAwIHx8ICFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIGFzY2VuZGluZyBjb3B5IGZyb20gc3RhcnRcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRhcmdldC5fc2V0KHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSwgdGFyZ2V0U3RhcnQpXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIGZpbGwodmFsdWUsIHN0YXJ0PTAsIGVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCF2YWx1ZSkgdmFsdWUgPSAwXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCkgZW5kID0gdGhpcy5sZW5ndGhcblxuICBpZiAoZW5kIDwgc3RhcnQpIHRocm93IG5ldyBSYW5nZUVycm9yKCdlbmQgPCBzdGFydCcpXG5cbiAgLy8gRmlsbCAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm5cbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm5cblxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChlbmQgPCAwIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignZW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgdGhpc1tpXSA9IHZhbHVlXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IHV0ZjhUb0J5dGVzKHZhbHVlLnRvU3RyaW5nKCkpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIHRoaXNbaV0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBgQXJyYXlCdWZmZXJgIHdpdGggdGhlICpjb3BpZWQqIG1lbW9yeSBvZiB0aGUgYnVmZmVyIGluc3RhbmNlLlxuICogQWRkZWQgaW4gTm9kZSAwLjEyLiBPbmx5IGF2YWlsYWJsZSBpbiBicm93c2VycyB0aGF0IHN1cHBvcnQgQXJyYXlCdWZmZXIuXG4gKi9cbkJ1ZmZlci5wcm90b3R5cGUudG9BcnJheUJ1ZmZlciA9IGZ1bmN0aW9uIHRvQXJyYXlCdWZmZXIgKCkge1xuICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgICByZXR1cm4gKG5ldyBCdWZmZXIodGhpcykpLmJ1ZmZlclxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5sZW5ndGgpXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYnVmLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGJ1ZltpXSA9IHRoaXNbaV1cbiAgICAgIH1cbiAgICAgIHJldHVybiBidWYuYnVmZmVyXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0J1ZmZlci50b0FycmF5QnVmZmVyIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyJylcbiAgfVxufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBCUCA9IEJ1ZmZlci5wcm90b3R5cGVcblxuLyoqXG4gKiBBdWdtZW50IGEgVWludDhBcnJheSAqaW5zdGFuY2UqIChub3QgdGhlIFVpbnQ4QXJyYXkgY2xhc3MhKSB3aXRoIEJ1ZmZlciBtZXRob2RzXG4gKi9cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIF9hdWdtZW50IChhcnIpIHtcbiAgYXJyLmNvbnN0cnVjdG9yID0gQnVmZmVyXG4gIGFyci5faXNCdWZmZXIgPSB0cnVlXG5cbiAgLy8gc2F2ZSByZWZlcmVuY2UgdG8gb3JpZ2luYWwgVWludDhBcnJheSBzZXQgbWV0aG9kIGJlZm9yZSBvdmVyd3JpdGluZ1xuICBhcnIuX3NldCA9IGFyci5zZXRcblxuICAvLyBkZXByZWNhdGVkXG4gIGFyci5nZXQgPSBCUC5nZXRcbiAgYXJyLnNldCA9IEJQLnNldFxuXG4gIGFyci53cml0ZSA9IEJQLndyaXRlXG4gIGFyci50b1N0cmluZyA9IEJQLnRvU3RyaW5nXG4gIGFyci50b0xvY2FsZVN0cmluZyA9IEJQLnRvU3RyaW5nXG4gIGFyci50b0pTT04gPSBCUC50b0pTT05cbiAgYXJyLmVxdWFscyA9IEJQLmVxdWFsc1xuICBhcnIuY29tcGFyZSA9IEJQLmNvbXBhcmVcbiAgYXJyLmluZGV4T2YgPSBCUC5pbmRleE9mXG4gIGFyci5jb3B5ID0gQlAuY29weVxuICBhcnIuc2xpY2UgPSBCUC5zbGljZVxuICBhcnIucmVhZFVJbnRMRSA9IEJQLnJlYWRVSW50TEVcbiAgYXJyLnJlYWRVSW50QkUgPSBCUC5yZWFkVUludEJFXG4gIGFyci5yZWFkVUludDggPSBCUC5yZWFkVUludDhcbiAgYXJyLnJlYWRVSW50MTZMRSA9IEJQLnJlYWRVSW50MTZMRVxuICBhcnIucmVhZFVJbnQxNkJFID0gQlAucmVhZFVJbnQxNkJFXG4gIGFyci5yZWFkVUludDMyTEUgPSBCUC5yZWFkVUludDMyTEVcbiAgYXJyLnJlYWRVSW50MzJCRSA9IEJQLnJlYWRVSW50MzJCRVxuICBhcnIucmVhZEludExFID0gQlAucmVhZEludExFXG4gIGFyci5yZWFkSW50QkUgPSBCUC5yZWFkSW50QkVcbiAgYXJyLnJlYWRJbnQ4ID0gQlAucmVhZEludDhcbiAgYXJyLnJlYWRJbnQxNkxFID0gQlAucmVhZEludDE2TEVcbiAgYXJyLnJlYWRJbnQxNkJFID0gQlAucmVhZEludDE2QkVcbiAgYXJyLnJlYWRJbnQzMkxFID0gQlAucmVhZEludDMyTEVcbiAgYXJyLnJlYWRJbnQzMkJFID0gQlAucmVhZEludDMyQkVcbiAgYXJyLnJlYWRGbG9hdExFID0gQlAucmVhZEZsb2F0TEVcbiAgYXJyLnJlYWRGbG9hdEJFID0gQlAucmVhZEZsb2F0QkVcbiAgYXJyLnJlYWREb3VibGVMRSA9IEJQLnJlYWREb3VibGVMRVxuICBhcnIucmVhZERvdWJsZUJFID0gQlAucmVhZERvdWJsZUJFXG4gIGFyci53cml0ZVVJbnQ4ID0gQlAud3JpdGVVSW50OFxuICBhcnIud3JpdGVVSW50TEUgPSBCUC53cml0ZVVJbnRMRVxuICBhcnIud3JpdGVVSW50QkUgPSBCUC53cml0ZVVJbnRCRVxuICBhcnIud3JpdGVVSW50MTZMRSA9IEJQLndyaXRlVUludDE2TEVcbiAgYXJyLndyaXRlVUludDE2QkUgPSBCUC53cml0ZVVJbnQxNkJFXG4gIGFyci53cml0ZVVJbnQzMkxFID0gQlAud3JpdGVVSW50MzJMRVxuICBhcnIud3JpdGVVSW50MzJCRSA9IEJQLndyaXRlVUludDMyQkVcbiAgYXJyLndyaXRlSW50TEUgPSBCUC53cml0ZUludExFXG4gIGFyci53cml0ZUludEJFID0gQlAud3JpdGVJbnRCRVxuICBhcnIud3JpdGVJbnQ4ID0gQlAud3JpdGVJbnQ4XG4gIGFyci53cml0ZUludDE2TEUgPSBCUC53cml0ZUludDE2TEVcbiAgYXJyLndyaXRlSW50MTZCRSA9IEJQLndyaXRlSW50MTZCRVxuICBhcnIud3JpdGVJbnQzMkxFID0gQlAud3JpdGVJbnQzMkxFXG4gIGFyci53cml0ZUludDMyQkUgPSBCUC53cml0ZUludDMyQkVcbiAgYXJyLndyaXRlRmxvYXRMRSA9IEJQLndyaXRlRmxvYXRMRVxuICBhcnIud3JpdGVGbG9hdEJFID0gQlAud3JpdGVGbG9hdEJFXG4gIGFyci53cml0ZURvdWJsZUxFID0gQlAud3JpdGVEb3VibGVMRVxuICBhcnIud3JpdGVEb3VibGVCRSA9IEJQLndyaXRlRG91YmxlQkVcbiAgYXJyLmZpbGwgPSBCUC5maWxsXG4gIGFyci5pbnNwZWN0ID0gQlAuaW5zcGVjdFxuICBhcnIudG9BcnJheUJ1ZmZlciA9IEJQLnRvQXJyYXlCdWZmZXJcblxuICByZXR1cm4gYXJyXG59XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXitcXC8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHJpbmd0cmltKHN0cikucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gc3RyaW5ndHJpbSAoc3RyKSB7XG4gIGlmIChzdHIudHJpbSkgcmV0dXJuIHN0ci50cmltKClcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuIiwidmFyIGxvb2t1cCA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJztcblxuOyhmdW5jdGlvbiAoZXhwb3J0cykge1xuXHQndXNlIHN0cmljdCc7XG5cbiAgdmFyIEFyciA9ICh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgPyBVaW50OEFycmF5XG4gICAgOiBBcnJheVxuXG5cdHZhciBQTFVTICAgPSAnKycuY2hhckNvZGVBdCgwKVxuXHR2YXIgU0xBU0ggID0gJy8nLmNoYXJDb2RlQXQoMClcblx0dmFyIE5VTUJFUiA9ICcwJy5jaGFyQ29kZUF0KDApXG5cdHZhciBMT1dFUiAgPSAnYScuY2hhckNvZGVBdCgwKVxuXHR2YXIgVVBQRVIgID0gJ0EnLmNoYXJDb2RlQXQoMClcblx0dmFyIFBMVVNfVVJMX1NBRkUgPSAnLScuY2hhckNvZGVBdCgwKVxuXHR2YXIgU0xBU0hfVVJMX1NBRkUgPSAnXycuY2hhckNvZGVBdCgwKVxuXG5cdGZ1bmN0aW9uIGRlY29kZSAoZWx0KSB7XG5cdFx0dmFyIGNvZGUgPSBlbHQuY2hhckNvZGVBdCgwKVxuXHRcdGlmIChjb2RlID09PSBQTFVTIHx8XG5cdFx0ICAgIGNvZGUgPT09IFBMVVNfVVJMX1NBRkUpXG5cdFx0XHRyZXR1cm4gNjIgLy8gJysnXG5cdFx0aWYgKGNvZGUgPT09IFNMQVNIIHx8XG5cdFx0ICAgIGNvZGUgPT09IFNMQVNIX1VSTF9TQUZFKVxuXHRcdFx0cmV0dXJuIDYzIC8vICcvJ1xuXHRcdGlmIChjb2RlIDwgTlVNQkVSKVxuXHRcdFx0cmV0dXJuIC0xIC8vbm8gbWF0Y2hcblx0XHRpZiAoY29kZSA8IE5VTUJFUiArIDEwKVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBOVU1CRVIgKyAyNiArIDI2XG5cdFx0aWYgKGNvZGUgPCBVUFBFUiArIDI2KVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBVUFBFUlxuXHRcdGlmIChjb2RlIDwgTE9XRVIgKyAyNilcblx0XHRcdHJldHVybiBjb2RlIC0gTE9XRVIgKyAyNlxuXHR9XG5cblx0ZnVuY3Rpb24gYjY0VG9CeXRlQXJyYXkgKGI2NCkge1xuXHRcdHZhciBpLCBqLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyXG5cblx0XHRpZiAoYjY0Lmxlbmd0aCAlIDQgPiAwKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuXHRcdH1cblxuXHRcdC8vIHRoZSBudW1iZXIgb2YgZXF1YWwgc2lnbnMgKHBsYWNlIGhvbGRlcnMpXG5cdFx0Ly8gaWYgdGhlcmUgYXJlIHR3byBwbGFjZWhvbGRlcnMsIHRoYW4gdGhlIHR3byBjaGFyYWN0ZXJzIGJlZm9yZSBpdFxuXHRcdC8vIHJlcHJlc2VudCBvbmUgYnl0ZVxuXHRcdC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lLCB0aGVuIHRoZSB0aHJlZSBjaGFyYWN0ZXJzIGJlZm9yZSBpdCByZXByZXNlbnQgMiBieXRlc1xuXHRcdC8vIHRoaXMgaXMganVzdCBhIGNoZWFwIGhhY2sgdG8gbm90IGRvIGluZGV4T2YgdHdpY2Vcblx0XHR2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXHRcdHBsYWNlSG9sZGVycyA9ICc9JyA9PT0gYjY0LmNoYXJBdChsZW4gLSAyKSA/IDIgOiAnPScgPT09IGI2NC5jaGFyQXQobGVuIC0gMSkgPyAxIDogMFxuXG5cdFx0Ly8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5cdFx0YXJyID0gbmV3IEFycihiNjQubGVuZ3RoICogMyAvIDQgLSBwbGFjZUhvbGRlcnMpXG5cblx0XHQvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG5cdFx0bCA9IHBsYWNlSG9sZGVycyA+IDAgPyBiNjQubGVuZ3RoIC0gNCA6IGI2NC5sZW5ndGhcblxuXHRcdHZhciBMID0gMFxuXG5cdFx0ZnVuY3Rpb24gcHVzaCAodikge1xuXHRcdFx0YXJyW0wrK10gPSB2XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgaiA9IDA7IGkgPCBsOyBpICs9IDQsIGogKz0gMykge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAxOCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA8PCAxMikgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDIpKSA8PCA2KSB8IGRlY29kZShiNjQuY2hhckF0KGkgKyAzKSlcblx0XHRcdHB1c2goKHRtcCAmIDB4RkYwMDAwKSA+PiAxNilcblx0XHRcdHB1c2goKHRtcCAmIDB4RkYwMCkgPj4gOClcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9XG5cblx0XHRpZiAocGxhY2VIb2xkZXJzID09PSAyKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDIpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPj4gNClcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9IGVsc2UgaWYgKHBsYWNlSG9sZGVycyA9PT0gMSkge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAxMCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA8PCA0KSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMikpID4+IDIpXG5cdFx0XHRwdXNoKCh0bXAgPj4gOCkgJiAweEZGKVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH1cblxuXHRcdHJldHVybiBhcnJcblx0fVxuXG5cdGZ1bmN0aW9uIHVpbnQ4VG9CYXNlNjQgKHVpbnQ4KSB7XG5cdFx0dmFyIGksXG5cdFx0XHRleHRyYUJ5dGVzID0gdWludDgubGVuZ3RoICUgMywgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcblx0XHRcdG91dHB1dCA9IFwiXCIsXG5cdFx0XHR0ZW1wLCBsZW5ndGhcblxuXHRcdGZ1bmN0aW9uIGVuY29kZSAobnVtKSB7XG5cdFx0XHRyZXR1cm4gbG9va3VwLmNoYXJBdChudW0pXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcblx0XHRcdHJldHVybiBlbmNvZGUobnVtID4+IDE4ICYgMHgzRikgKyBlbmNvZGUobnVtID4+IDEyICYgMHgzRikgKyBlbmNvZGUobnVtID4+IDYgJiAweDNGKSArIGVuY29kZShudW0gJiAweDNGKVxuXHRcdH1cblxuXHRcdC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcblx0XHRmb3IgKGkgPSAwLCBsZW5ndGggPSB1aW50OC5sZW5ndGggLSBleHRyYUJ5dGVzOyBpIDwgbGVuZ3RoOyBpICs9IDMpIHtcblx0XHRcdHRlbXAgPSAodWludDhbaV0gPDwgMTYpICsgKHVpbnQ4W2kgKyAxXSA8PCA4KSArICh1aW50OFtpICsgMl0pXG5cdFx0XHRvdXRwdXQgKz0gdHJpcGxldFRvQmFzZTY0KHRlbXApXG5cdFx0fVxuXG5cdFx0Ly8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuXHRcdHN3aXRjaCAoZXh0cmFCeXRlcykge1xuXHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHR0ZW1wID0gdWludDhbdWludDgubGVuZ3RoIC0gMV1cblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSh0ZW1wID4+IDIpXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPDwgNCkgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gJz09J1xuXHRcdFx0XHRicmVha1xuXHRcdFx0Y2FzZSAyOlxuXHRcdFx0XHR0ZW1wID0gKHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDJdIDw8IDgpICsgKHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDFdKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKHRlbXAgPj4gMTApXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPj4gNCkgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wIDw8IDIpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9ICc9J1xuXHRcdFx0XHRicmVha1xuXHRcdH1cblxuXHRcdHJldHVybiBvdXRwdXRcblx0fVxuXG5cdGV4cG9ydHMudG9CeXRlQXJyYXkgPSBiNjRUb0J5dGVBcnJheVxuXHRleHBvcnRzLmZyb21CeXRlQXJyYXkgPSB1aW50OFRvQmFzZTY0XG59KHR5cGVvZiBleHBvcnRzID09PSAndW5kZWZpbmVkJyA/ICh0aGlzLmJhc2U2NGpzID0ge30pIDogZXhwb3J0cykpXG4iLCJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cbiIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMucmFuZG9tQnl0ZXMgPSBleHBvcnRzLnJuZyA9IGV4cG9ydHMucHNldWRvUmFuZG9tQnl0ZXMgPSBleHBvcnRzLnBybmcgPSByZXF1aXJlKCdyYW5kb21ieXRlcycpXG5leHBvcnRzLmNyZWF0ZUhhc2ggPSBleHBvcnRzLkhhc2ggPSByZXF1aXJlKCdjcmVhdGUtaGFzaCcpXG5leHBvcnRzLmNyZWF0ZUhtYWMgPSBleHBvcnRzLkhtYWMgPSByZXF1aXJlKCdjcmVhdGUtaG1hYycpXG5cbnZhciBoYXNoZXMgPSBbJ3NoYTEnLCAnc2hhMjI0JywgJ3NoYTI1NicsICdzaGEzODQnLCAnc2hhNTEyJywgJ21kNScsICdybWQxNjAnXS5jb25jYXQoT2JqZWN0LmtleXMocmVxdWlyZSgnYnJvd3NlcmlmeS1zaWduL2FsZ29zJykpKVxuZXhwb3J0cy5nZXRIYXNoZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBoYXNoZXNcbn1cblxudmFyIHAgPSByZXF1aXJlKCdwYmtkZjInKVxuZXhwb3J0cy5wYmtkZjIgPSBwLnBia2RmMlxuZXhwb3J0cy5wYmtkZjJTeW5jID0gcC5wYmtkZjJTeW5jXG5cbnZhciBhZXMgPSByZXF1aXJlKCdicm93c2VyaWZ5LWNpcGhlcicpXG47W1xuICAnQ2lwaGVyJyxcbiAgJ2NyZWF0ZUNpcGhlcicsXG4gICdDaXBoZXJpdicsXG4gICdjcmVhdGVDaXBoZXJpdicsXG4gICdEZWNpcGhlcicsXG4gICdjcmVhdGVEZWNpcGhlcicsXG4gICdEZWNpcGhlcml2JyxcbiAgJ2NyZWF0ZURlY2lwaGVyaXYnLFxuICAnZ2V0Q2lwaGVycycsXG4gICdsaXN0Q2lwaGVycydcbl0uZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGV4cG9ydHNba2V5XSA9IGFlc1trZXldXG59KVxuXG52YXIgZGggPSByZXF1aXJlKCdkaWZmaWUtaGVsbG1hbicpXG47W1xuICAnRGlmZmllSGVsbG1hbkdyb3VwJyxcbiAgJ2NyZWF0ZURpZmZpZUhlbGxtYW5Hcm91cCcsXG4gICdnZXREaWZmaWVIZWxsbWFuJyxcbiAgJ2NyZWF0ZURpZmZpZUhlbGxtYW4nLFxuICAnRGlmZmllSGVsbG1hbidcbl0uZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGV4cG9ydHNba2V5XSA9IGRoW2tleV1cbn0pXG5cbnZhciBzaWduID0gcmVxdWlyZSgnYnJvd3NlcmlmeS1zaWduJylcbjtbXG4gICdjcmVhdGVTaWduJyxcbiAgJ1NpZ24nLFxuICAnY3JlYXRlVmVyaWZ5JyxcbiAgJ1ZlcmlmeSdcbl0uZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGV4cG9ydHNba2V5XSA9IHNpZ25ba2V5XVxufSlcblxuZXhwb3J0cy5jcmVhdGVFQ0RIID0gcmVxdWlyZSgnY3JlYXRlLWVjZGgnKVxuXG52YXIgcHVibGljRW5jcnlwdCA9IHJlcXVpcmUoJ3B1YmxpYy1lbmNyeXB0JylcblxuO1tcbiAgJ3B1YmxpY0VuY3J5cHQnLFxuICAncHJpdmF0ZUVuY3J5cHQnLFxuICAncHVibGljRGVjcnlwdCcsXG4gICdwcml2YXRlRGVjcnlwdCdcbl0uZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGV4cG9ydHNba2V5XSA9IHB1YmxpY0VuY3J5cHRba2V5XVxufSlcblxuLy8gdGhlIGxlYXN0IEkgY2FuIGRvIGlzIG1ha2UgZXJyb3IgbWVzc2FnZXMgZm9yIHRoZSByZXN0IG9mIHRoZSBub2RlLmpzL2NyeXB0byBhcGkuXG47W1xuICAnY3JlYXRlQ3JlZGVudGlhbHMnXG5dLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgZXhwb3J0c1tuYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoW1xuICAgICAgJ3NvcnJ5LCAnICsgbmFtZSArICcgaXMgbm90IGltcGxlbWVudGVkIHlldCcsXG4gICAgICAnd2UgYWNjZXB0IHB1bGwgcmVxdWVzdHMnLFxuICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS9jcnlwdG8tYnJvd3NlcmlmeS9jcnlwdG8tYnJvd3NlcmlmeSdcbiAgICBdLmpvaW4oJ1xcbicpKVxuICB9XG59KVxuIiwidmFyIGVidGsgPSByZXF1aXJlKCdldnBfYnl0ZXN0b2tleScpXG52YXIgYWVzID0gcmVxdWlyZSgnYnJvd3NlcmlmeS1hZXMvYnJvd3NlcicpXG52YXIgREVTID0gcmVxdWlyZSgnYnJvd3NlcmlmeS1kZXMnKVxudmFyIGRlc01vZGVzID0gcmVxdWlyZSgnYnJvd3NlcmlmeS1kZXMvbW9kZXMnKVxudmFyIGFlc01vZGVzID0gcmVxdWlyZSgnYnJvd3NlcmlmeS1hZXMvbW9kZXMnKVxuZnVuY3Rpb24gY3JlYXRlQ2lwaGVyIChzdWl0ZSwgcGFzc3dvcmQpIHtcbiAgdmFyIGtleUxlbiwgaXZMZW5cbiAgc3VpdGUgPSBzdWl0ZS50b0xvd2VyQ2FzZSgpXG4gIGlmIChhZXNNb2Rlc1tzdWl0ZV0pIHtcbiAgICBrZXlMZW4gPSBhZXNNb2Rlc1tzdWl0ZV0ua2V5XG4gICAgaXZMZW4gPSBhZXNNb2Rlc1tzdWl0ZV0uaXZcbiAgfSBlbHNlIGlmIChkZXNNb2Rlc1tzdWl0ZV0pIHtcbiAgICBrZXlMZW4gPSBkZXNNb2Rlc1tzdWl0ZV0ua2V5ICogOFxuICAgIGl2TGVuID0gZGVzTW9kZXNbc3VpdGVdLml2XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBzdWl0ZSB0eXBlJylcbiAgfVxuICB2YXIga2V5cyA9IGVidGsocGFzc3dvcmQsIGZhbHNlLCBrZXlMZW4sIGl2TGVuKVxuICByZXR1cm4gY3JlYXRlQ2lwaGVyaXYoc3VpdGUsIGtleXMua2V5LCBrZXlzLml2KVxufVxuZnVuY3Rpb24gY3JlYXRlRGVjaXBoZXIgKHN1aXRlLCBwYXNzd29yZCkge1xuICB2YXIga2V5TGVuLCBpdkxlblxuICBzdWl0ZSA9IHN1aXRlLnRvTG93ZXJDYXNlKClcbiAgaWYgKGFlc01vZGVzW3N1aXRlXSkge1xuICAgIGtleUxlbiA9IGFlc01vZGVzW3N1aXRlXS5rZXlcbiAgICBpdkxlbiA9IGFlc01vZGVzW3N1aXRlXS5pdlxuICB9IGVsc2UgaWYgKGRlc01vZGVzW3N1aXRlXSkge1xuICAgIGtleUxlbiA9IGRlc01vZGVzW3N1aXRlXS5rZXkgKiA4XG4gICAgaXZMZW4gPSBkZXNNb2Rlc1tzdWl0ZV0uaXZcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHN1aXRlIHR5cGUnKVxuICB9XG4gIHZhciBrZXlzID0gZWJ0ayhwYXNzd29yZCwgZmFsc2UsIGtleUxlbiwgaXZMZW4pXG4gIHJldHVybiBjcmVhdGVEZWNpcGhlcml2KHN1aXRlLCBrZXlzLmtleSwga2V5cy5pdilcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ2lwaGVyaXYgKHN1aXRlLCBrZXksIGl2KSB7XG4gIHN1aXRlID0gc3VpdGUudG9Mb3dlckNhc2UoKVxuICBpZiAoYWVzTW9kZXNbc3VpdGVdKSB7XG4gICAgcmV0dXJuIGFlcy5jcmVhdGVDaXBoZXJpdihzdWl0ZSwga2V5LCBpdilcbiAgfSBlbHNlIGlmIChkZXNNb2Rlc1tzdWl0ZV0pIHtcbiAgICByZXR1cm4gbmV3IERFUyh7XG4gICAgICBrZXk6IGtleSxcbiAgICAgIGl2OiBpdixcbiAgICAgIG1vZGU6IHN1aXRlXG4gICAgfSlcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHN1aXRlIHR5cGUnKVxuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVEZWNpcGhlcml2IChzdWl0ZSwga2V5LCBpdikge1xuICBzdWl0ZSA9IHN1aXRlLnRvTG93ZXJDYXNlKClcbiAgaWYgKGFlc01vZGVzW3N1aXRlXSkge1xuICAgIHJldHVybiBhZXMuY3JlYXRlRGVjaXBoZXJpdihzdWl0ZSwga2V5LCBpdilcbiAgfSBlbHNlIGlmIChkZXNNb2Rlc1tzdWl0ZV0pIHtcbiAgICByZXR1cm4gbmV3IERFUyh7XG4gICAgICBrZXk6IGtleSxcbiAgICAgIGl2OiBpdixcbiAgICAgIG1vZGU6IHN1aXRlLFxuICAgICAgZGVjcnlwdDogdHJ1ZVxuICAgIH0pXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBzdWl0ZSB0eXBlJylcbiAgfVxufVxuZXhwb3J0cy5jcmVhdGVDaXBoZXIgPSBleHBvcnRzLkNpcGhlciA9IGNyZWF0ZUNpcGhlclxuZXhwb3J0cy5jcmVhdGVDaXBoZXJpdiA9IGV4cG9ydHMuQ2lwaGVyaXYgPSBjcmVhdGVDaXBoZXJpdlxuZXhwb3J0cy5jcmVhdGVEZWNpcGhlciA9IGV4cG9ydHMuRGVjaXBoZXIgPSBjcmVhdGVEZWNpcGhlclxuZXhwb3J0cy5jcmVhdGVEZWNpcGhlcml2ID0gZXhwb3J0cy5EZWNpcGhlcml2ID0gY3JlYXRlRGVjaXBoZXJpdlxuZnVuY3Rpb24gZ2V0Q2lwaGVycyAoKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhkZXNNb2RlcykuY29uY2F0KGFlcy5nZXRDaXBoZXJzKCkpXG59XG5leHBvcnRzLmxpc3RDaXBoZXJzID0gZXhwb3J0cy5nZXRDaXBoZXJzID0gZ2V0Q2lwaGVyc1xuIiwiLy8gYmFzZWQgb24gdGhlIGFlcyBpbXBsaW1lbnRhdGlvbiBpbiB0cmlwbGUgc2VjXG4vLyBodHRwczovL2dpdGh1Yi5jb20va2V5YmFzZS90cmlwbGVzZWNcblxuLy8gd2hpY2ggaXMgaW4gdHVybiBiYXNlZCBvbiB0aGUgb25lIGZyb20gY3J5cHRvLWpzXG4vLyBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2NyeXB0by1qcy9cblxudmFyIHVpbnRfbWF4ID0gTWF0aC5wb3coMiwgMzIpXG5mdW5jdGlvbiBmaXh1cF91aW50MzIgKHgpIHtcbiAgdmFyIHJldCwgeF9wb3NcbiAgcmV0ID0geCA+IHVpbnRfbWF4IHx8IHggPCAwID8gKHhfcG9zID0gTWF0aC5hYnMoeCkgJSB1aW50X21heCwgeCA8IDAgPyB1aW50X21heCAtIHhfcG9zIDogeF9wb3MpIDogeFxuICByZXR1cm4gcmV0XG59XG5mdW5jdGlvbiBzY3J1Yl92ZWMgKHYpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2Lmxlbmd0aDsgdisrKSB7XG4gICAgdltpXSA9IDBcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gR2xvYmFsICgpIHtcbiAgdGhpcy5TQk9YID0gW11cbiAgdGhpcy5JTlZfU0JPWCA9IFtdXG4gIHRoaXMuU1VCX01JWCA9IFtbXSwgW10sIFtdLCBbXV1cbiAgdGhpcy5JTlZfU1VCX01JWCA9IFtbXSwgW10sIFtdLCBbXV1cbiAgdGhpcy5pbml0KClcbiAgdGhpcy5SQ09OID0gWzB4MDAsIDB4MDEsIDB4MDIsIDB4MDQsIDB4MDgsIDB4MTAsIDB4MjAsIDB4NDAsIDB4ODAsIDB4MWIsIDB4MzZdXG59XG5cbkdsb2JhbC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGQsIGksIHN4LCB0LCB4LCB4MiwgeDQsIHg4LCB4aSwgX2lcbiAgZCA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9pLCBfcmVzdWx0c1xuICAgIF9yZXN1bHRzID0gW11cbiAgICBmb3IgKGkgPSBfaSA9IDA7IF9pIDwgMjU2OyBpID0gKytfaSkge1xuICAgICAgaWYgKGkgPCAxMjgpIHtcbiAgICAgICAgX3Jlc3VsdHMucHVzaChpIDw8IDEpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfcmVzdWx0cy5wdXNoKChpIDw8IDEpIF4gMHgxMWIpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBfcmVzdWx0c1xuICB9KSgpXG4gIHggPSAwXG4gIHhpID0gMFxuICBmb3IgKGkgPSBfaSA9IDA7IF9pIDwgMjU2OyBpID0gKytfaSkge1xuICAgIHN4ID0geGkgXiAoeGkgPDwgMSkgXiAoeGkgPDwgMikgXiAoeGkgPDwgMykgXiAoeGkgPDwgNClcbiAgICBzeCA9IChzeCA+Pj4gOCkgXiAoc3ggJiAweGZmKSBeIDB4NjNcbiAgICB0aGlzLlNCT1hbeF0gPSBzeFxuICAgIHRoaXMuSU5WX1NCT1hbc3hdID0geFxuICAgIHgyID0gZFt4XVxuICAgIHg0ID0gZFt4Ml1cbiAgICB4OCA9IGRbeDRdXG4gICAgdCA9IChkW3N4XSAqIDB4MTAxKSBeIChzeCAqIDB4MTAxMDEwMClcbiAgICB0aGlzLlNVQl9NSVhbMF1beF0gPSAodCA8PCAyNCkgfCAodCA+Pj4gOClcbiAgICB0aGlzLlNVQl9NSVhbMV1beF0gPSAodCA8PCAxNikgfCAodCA+Pj4gMTYpXG4gICAgdGhpcy5TVUJfTUlYWzJdW3hdID0gKHQgPDwgOCkgfCAodCA+Pj4gMjQpXG4gICAgdGhpcy5TVUJfTUlYWzNdW3hdID0gdFxuICAgIHQgPSAoeDggKiAweDEwMTAxMDEpIF4gKHg0ICogMHgxMDAwMSkgXiAoeDIgKiAweDEwMSkgXiAoeCAqIDB4MTAxMDEwMClcbiAgICB0aGlzLklOVl9TVUJfTUlYWzBdW3N4XSA9ICh0IDw8IDI0KSB8ICh0ID4+PiA4KVxuICAgIHRoaXMuSU5WX1NVQl9NSVhbMV1bc3hdID0gKHQgPDwgMTYpIHwgKHQgPj4+IDE2KVxuICAgIHRoaXMuSU5WX1NVQl9NSVhbMl1bc3hdID0gKHQgPDwgOCkgfCAodCA+Pj4gMjQpXG4gICAgdGhpcy5JTlZfU1VCX01JWFszXVtzeF0gPSB0XG4gICAgaWYgKHggPT09IDApIHtcbiAgICAgIHggPSB4aSA9IDFcbiAgICB9IGVsc2Uge1xuICAgICAgeCA9IHgyIF4gZFtkW2RbeDggXiB4Ml1dXVxuICAgICAgeGkgXj0gZFtkW3hpXV1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxudmFyIEcgPSBuZXcgR2xvYmFsKClcblxuQUVTLmJsb2NrU2l6ZSA9IDQgKiA0XG5cbkFFUy5wcm90b3R5cGUuYmxvY2tTaXplID0gQUVTLmJsb2NrU2l6ZVxuXG5BRVMua2V5U2l6ZSA9IDI1NiAvIDhcblxuQUVTLnByb3RvdHlwZS5rZXlTaXplID0gQUVTLmtleVNpemVcblxuZnVuY3Rpb24gYnVmZmVyVG9BcnJheSAoYnVmKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoIC8gNFxuICB2YXIgb3V0ID0gbmV3IEFycmF5KGxlbilcbiAgdmFyIGkgPSAtMVxuICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgb3V0W2ldID0gYnVmLnJlYWRVSW50MzJCRShpICogNClcbiAgfVxuICByZXR1cm4gb3V0XG59XG5mdW5jdGlvbiBBRVMgKGtleSkge1xuICB0aGlzLl9rZXkgPSBidWZmZXJUb0FycmF5KGtleSlcbiAgdGhpcy5fZG9SZXNldCgpXG59XG5cbkFFUy5wcm90b3R5cGUuX2RvUmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBpbnZLc1Jvdywga2V5U2l6ZSwga2V5V29yZHMsIGtzUm93LCBrc1Jvd3MsIHRcbiAga2V5V29yZHMgPSB0aGlzLl9rZXlcbiAga2V5U2l6ZSA9IGtleVdvcmRzLmxlbmd0aFxuICB0aGlzLl9uUm91bmRzID0ga2V5U2l6ZSArIDZcbiAga3NSb3dzID0gKHRoaXMuX25Sb3VuZHMgKyAxKSAqIDRcbiAgdGhpcy5fa2V5U2NoZWR1bGUgPSBbXVxuICBmb3IgKGtzUm93ID0gMDsga3NSb3cgPCBrc1Jvd3M7IGtzUm93KyspIHtcbiAgICB0aGlzLl9rZXlTY2hlZHVsZVtrc1Jvd10gPSBrc1JvdyA8IGtleVNpemUgPyBrZXlXb3Jkc1trc1Jvd10gOiAodCA9IHRoaXMuX2tleVNjaGVkdWxlW2tzUm93IC0gMV0sIChrc1JvdyAlIGtleVNpemUpID09PSAwID8gKHQgPSAodCA8PCA4KSB8ICh0ID4+PiAyNCksIHQgPSAoRy5TQk9YW3QgPj4+IDI0XSA8PCAyNCkgfCAoRy5TQk9YWyh0ID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoRy5TQk9YWyh0ID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgRy5TQk9YW3QgJiAweGZmXSwgdCBePSBHLlJDT05bKGtzUm93IC8ga2V5U2l6ZSkgfCAwXSA8PCAyNCkgOiBrZXlTaXplID4gNiAmJiBrc1JvdyAlIGtleVNpemUgPT09IDQgPyB0ID0gKEcuU0JPWFt0ID4+PiAyNF0gPDwgMjQpIHwgKEcuU0JPWFsodCA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKEcuU0JPWFsodCA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IEcuU0JPWFt0ICYgMHhmZl0gOiB2b2lkIDAsIHRoaXMuX2tleVNjaGVkdWxlW2tzUm93IC0ga2V5U2l6ZV0gXiB0KVxuICB9XG4gIHRoaXMuX2ludktleVNjaGVkdWxlID0gW11cbiAgZm9yIChpbnZLc1JvdyA9IDA7IGludktzUm93IDwga3NSb3dzOyBpbnZLc1JvdysrKSB7XG4gICAga3NSb3cgPSBrc1Jvd3MgLSBpbnZLc1Jvd1xuICAgIHQgPSB0aGlzLl9rZXlTY2hlZHVsZVtrc1JvdyAtIChpbnZLc1JvdyAlIDQgPyAwIDogNCldXG4gICAgdGhpcy5faW52S2V5U2NoZWR1bGVbaW52S3NSb3ddID0gaW52S3NSb3cgPCA0IHx8IGtzUm93IDw9IDQgPyB0IDogRy5JTlZfU1VCX01JWFswXVtHLlNCT1hbdCA+Pj4gMjRdXSBeIEcuSU5WX1NVQl9NSVhbMV1bRy5TQk9YWyh0ID4+PiAxNikgJiAweGZmXV0gXiBHLklOVl9TVUJfTUlYWzJdW0cuU0JPWFsodCA+Pj4gOCkgJiAweGZmXV0gXiBHLklOVl9TVUJfTUlYWzNdW0cuU0JPWFt0ICYgMHhmZl1dXG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuQUVTLnByb3RvdHlwZS5lbmNyeXB0QmxvY2sgPSBmdW5jdGlvbiAoTSkge1xuICBNID0gYnVmZmVyVG9BcnJheShuZXcgQnVmZmVyKE0pKVxuICB2YXIgb3V0ID0gdGhpcy5fZG9DcnlwdEJsb2NrKE0sIHRoaXMuX2tleVNjaGVkdWxlLCBHLlNVQl9NSVgsIEcuU0JPWClcbiAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIoMTYpXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKG91dFswXSwgMClcbiAgYnVmLndyaXRlVUludDMyQkUob3V0WzFdLCA0KVxuICBidWYud3JpdGVVSW50MzJCRShvdXRbMl0sIDgpXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKG91dFszXSwgMTIpXG4gIHJldHVybiBidWZcbn1cblxuQUVTLnByb3RvdHlwZS5kZWNyeXB0QmxvY2sgPSBmdW5jdGlvbiAoTSkge1xuICBNID0gYnVmZmVyVG9BcnJheShuZXcgQnVmZmVyKE0pKVxuICB2YXIgdGVtcCA9IFtNWzNdLCBNWzFdXVxuICBNWzFdID0gdGVtcFswXVxuICBNWzNdID0gdGVtcFsxXVxuICB2YXIgb3V0ID0gdGhpcy5fZG9DcnlwdEJsb2NrKE0sIHRoaXMuX2ludktleVNjaGVkdWxlLCBHLklOVl9TVUJfTUlYLCBHLklOVl9TQk9YKVxuICB2YXIgYnVmID0gbmV3IEJ1ZmZlcigxNilcbiAgYnVmLndyaXRlVUludDMyQkUob3V0WzBdLCAwKVxuICBidWYud3JpdGVVSW50MzJCRShvdXRbM10sIDQpXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKG91dFsyXSwgOClcbiAgYnVmLndyaXRlVUludDMyQkUob3V0WzFdLCAxMilcbiAgcmV0dXJuIGJ1ZlxufVxuXG5BRVMucHJvdG90eXBlLnNjcnViID0gZnVuY3Rpb24gKCkge1xuICBzY3J1Yl92ZWModGhpcy5fa2V5U2NoZWR1bGUpXG4gIHNjcnViX3ZlYyh0aGlzLl9pbnZLZXlTY2hlZHVsZSlcbiAgc2NydWJfdmVjKHRoaXMuX2tleSlcbn1cblxuQUVTLnByb3RvdHlwZS5fZG9DcnlwdEJsb2NrID0gZnVuY3Rpb24gKE0sIGtleVNjaGVkdWxlLCBTVUJfTUlYLCBTQk9YKSB7XG4gIHZhciBrc1JvdywgczAsIHMxLCBzMiwgczMsIHQwLCB0MSwgdDIsIHQzXG5cbiAgczAgPSBNWzBdIF4ga2V5U2NoZWR1bGVbMF1cbiAgczEgPSBNWzFdIF4ga2V5U2NoZWR1bGVbMV1cbiAgczIgPSBNWzJdIF4ga2V5U2NoZWR1bGVbMl1cbiAgczMgPSBNWzNdIF4ga2V5U2NoZWR1bGVbM11cbiAga3NSb3cgPSA0XG4gIGZvciAodmFyIHJvdW5kID0gMTsgcm91bmQgPCB0aGlzLl9uUm91bmRzOyByb3VuZCsrKSB7XG4gICAgdDAgPSBTVUJfTUlYWzBdW3MwID4+PiAyNF0gXiBTVUJfTUlYWzFdWyhzMSA+Pj4gMTYpICYgMHhmZl0gXiBTVUJfTUlYWzJdWyhzMiA+Pj4gOCkgJiAweGZmXSBeIFNVQl9NSVhbM11bczMgJiAweGZmXSBeIGtleVNjaGVkdWxlW2tzUm93KytdXG4gICAgdDEgPSBTVUJfTUlYWzBdW3MxID4+PiAyNF0gXiBTVUJfTUlYWzFdWyhzMiA+Pj4gMTYpICYgMHhmZl0gXiBTVUJfTUlYWzJdWyhzMyA+Pj4gOCkgJiAweGZmXSBeIFNVQl9NSVhbM11bczAgJiAweGZmXSBeIGtleVNjaGVkdWxlW2tzUm93KytdXG4gICAgdDIgPSBTVUJfTUlYWzBdW3MyID4+PiAyNF0gXiBTVUJfTUlYWzFdWyhzMyA+Pj4gMTYpICYgMHhmZl0gXiBTVUJfTUlYWzJdWyhzMCA+Pj4gOCkgJiAweGZmXSBeIFNVQl9NSVhbM11bczEgJiAweGZmXSBeIGtleVNjaGVkdWxlW2tzUm93KytdXG4gICAgdDMgPSBTVUJfTUlYWzBdW3MzID4+PiAyNF0gXiBTVUJfTUlYWzFdWyhzMCA+Pj4gMTYpICYgMHhmZl0gXiBTVUJfTUlYWzJdWyhzMSA+Pj4gOCkgJiAweGZmXSBeIFNVQl9NSVhbM11bczIgJiAweGZmXSBeIGtleVNjaGVkdWxlW2tzUm93KytdXG4gICAgczAgPSB0MFxuICAgIHMxID0gdDFcbiAgICBzMiA9IHQyXG4gICAgczMgPSB0M1xuICB9XG4gIHQwID0gKChTQk9YW3MwID4+PiAyNF0gPDwgMjQpIHwgKFNCT1hbKHMxID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoU0JPWFsoczIgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBTQk9YW3MzICYgMHhmZl0pIF4ga2V5U2NoZWR1bGVba3NSb3crK11cbiAgdDEgPSAoKFNCT1hbczEgPj4+IDI0XSA8PCAyNCkgfCAoU0JPWFsoczIgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChTQk9YWyhzMyA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IFNCT1hbczAgJiAweGZmXSkgXiBrZXlTY2hlZHVsZVtrc1JvdysrXVxuICB0MiA9ICgoU0JPWFtzMiA+Pj4gMjRdIDw8IDI0KSB8IChTQk9YWyhzMyA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKFNCT1hbKHMwID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgU0JPWFtzMSAmIDB4ZmZdKSBeIGtleVNjaGVkdWxlW2tzUm93KytdXG4gIHQzID0gKChTQk9YW3MzID4+PiAyNF0gPDwgMjQpIHwgKFNCT1hbKHMwID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoU0JPWFsoczEgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBTQk9YW3MyICYgMHhmZl0pIF4ga2V5U2NoZWR1bGVba3NSb3crK11cbiAgcmV0dXJuIFtcbiAgICBmaXh1cF91aW50MzIodDApLFxuICAgIGZpeHVwX3VpbnQzMih0MSksXG4gICAgZml4dXBfdWludDMyKHQyKSxcbiAgICBmaXh1cF91aW50MzIodDMpXG4gIF1cbn1cblxuZXhwb3J0cy5BRVMgPSBBRVNcbiIsInZhciBhZXMgPSByZXF1aXJlKCcuL2FlcycpXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnY2lwaGVyLWJhc2UnKVxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIEdIQVNIID0gcmVxdWlyZSgnLi9naGFzaCcpXG52YXIgeG9yID0gcmVxdWlyZSgnYnVmZmVyLXhvcicpXG5pbmhlcml0cyhTdHJlYW1DaXBoZXIsIFRyYW5zZm9ybSlcbm1vZHVsZS5leHBvcnRzID0gU3RyZWFtQ2lwaGVyXG5cbmZ1bmN0aW9uIFN0cmVhbUNpcGhlciAobW9kZSwga2V5LCBpdiwgZGVjcnlwdCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU3RyZWFtQ2lwaGVyKSkge1xuICAgIHJldHVybiBuZXcgU3RyZWFtQ2lwaGVyKG1vZGUsIGtleSwgaXYpXG4gIH1cbiAgVHJhbnNmb3JtLmNhbGwodGhpcylcbiAgdGhpcy5fZmluSUQgPSBCdWZmZXIuY29uY2F0KFtpdiwgbmV3IEJ1ZmZlcihbMCwgMCwgMCwgMV0pXSlcbiAgaXYgPSBCdWZmZXIuY29uY2F0KFtpdiwgbmV3IEJ1ZmZlcihbMCwgMCwgMCwgMl0pXSlcbiAgdGhpcy5fY2lwaGVyID0gbmV3IGFlcy5BRVMoa2V5KVxuICB0aGlzLl9wcmV2ID0gbmV3IEJ1ZmZlcihpdi5sZW5ndGgpXG4gIHRoaXMuX2NhY2hlID0gbmV3IEJ1ZmZlcignJylcbiAgdGhpcy5fc2VjQ2FjaGUgPSBuZXcgQnVmZmVyKCcnKVxuICB0aGlzLl9kZWNyeXB0ID0gZGVjcnlwdFxuICB0aGlzLl9hbGVuID0gMFxuICB0aGlzLl9sZW4gPSAwXG4gIGl2LmNvcHkodGhpcy5fcHJldilcbiAgdGhpcy5fbW9kZSA9IG1vZGVcbiAgdmFyIGggPSBuZXcgQnVmZmVyKDQpXG4gIGguZmlsbCgwKVxuICB0aGlzLl9naGFzaCA9IG5ldyBHSEFTSCh0aGlzLl9jaXBoZXIuZW5jcnlwdEJsb2NrKGgpKVxuICB0aGlzLl9hdXRoVGFnID0gbnVsbFxuICB0aGlzLl9jYWxsZWQgPSBmYWxzZVxufVxuU3RyZWFtQ2lwaGVyLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIGlmICghdGhpcy5fY2FsbGVkICYmIHRoaXMuX2FsZW4pIHtcbiAgICB2YXIgcnVtcCA9IDE2IC0gKHRoaXMuX2FsZW4gJSAxNilcbiAgICBpZiAocnVtcCA8IDE2KSB7XG4gICAgICBydW1wID0gbmV3IEJ1ZmZlcihydW1wKVxuICAgICAgcnVtcC5maWxsKDApXG4gICAgICB0aGlzLl9naGFzaC51cGRhdGUocnVtcClcbiAgICB9XG4gIH1cbiAgdGhpcy5fY2FsbGVkID0gdHJ1ZVxuICB2YXIgb3V0ID0gdGhpcy5fbW9kZS5lbmNyeXB0KHRoaXMsIGNodW5rKVxuICBpZiAodGhpcy5fZGVjcnlwdCkge1xuICAgIHRoaXMuX2doYXNoLnVwZGF0ZShjaHVuaylcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9naGFzaC51cGRhdGUob3V0KVxuICB9XG4gIHRoaXMuX2xlbiArPSBjaHVuay5sZW5ndGhcbiAgcmV0dXJuIG91dFxufVxuU3RyZWFtQ2lwaGVyLnByb3RvdHlwZS5fZmluYWwgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLl9kZWNyeXB0ICYmICF0aGlzLl9hdXRoVGFnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBzdGF0ZSBvciB1bmFibGUgdG8gYXV0aGVudGljYXRlIGRhdGEnKVxuICB9XG4gIHZhciB0YWcgPSB4b3IodGhpcy5fZ2hhc2guZmluYWwodGhpcy5fYWxlbiAqIDgsIHRoaXMuX2xlbiAqIDgpLCB0aGlzLl9jaXBoZXIuZW5jcnlwdEJsb2NrKHRoaXMuX2ZpbklEKSlcbiAgaWYgKHRoaXMuX2RlY3J5cHQpIHtcbiAgICBpZiAoeG9yVGVzdCh0YWcsIHRoaXMuX2F1dGhUYWcpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHN0YXRlIG9yIHVuYWJsZSB0byBhdXRoZW50aWNhdGUgZGF0YScpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRoaXMuX2F1dGhUYWcgPSB0YWdcbiAgfVxuICB0aGlzLl9jaXBoZXIuc2NydWIoKVxufVxuU3RyZWFtQ2lwaGVyLnByb3RvdHlwZS5nZXRBdXRoVGFnID0gZnVuY3Rpb24gZ2V0QXV0aFRhZyAoKSB7XG4gIGlmICghdGhpcy5fZGVjcnlwdCAmJiBCdWZmZXIuaXNCdWZmZXIodGhpcy5fYXV0aFRhZykpIHtcbiAgICByZXR1cm4gdGhpcy5fYXV0aFRhZ1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignQXR0ZW1wdGluZyB0byBnZXQgYXV0aCB0YWcgaW4gdW5zdXBwb3J0ZWQgc3RhdGUnKVxuICB9XG59XG5TdHJlYW1DaXBoZXIucHJvdG90eXBlLnNldEF1dGhUYWcgPSBmdW5jdGlvbiBzZXRBdXRoVGFnICh0YWcpIHtcbiAgaWYgKHRoaXMuX2RlY3J5cHQpIHtcbiAgICB0aGlzLl9hdXRoVGFnID0gdGFnXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdBdHRlbXB0aW5nIHRvIHNldCBhdXRoIHRhZyBpbiB1bnN1cHBvcnRlZCBzdGF0ZScpXG4gIH1cbn1cblN0cmVhbUNpcGhlci5wcm90b3R5cGUuc2V0QUFEID0gZnVuY3Rpb24gc2V0QUFEIChidWYpIHtcbiAgaWYgKCF0aGlzLl9jYWxsZWQpIHtcbiAgICB0aGlzLl9naGFzaC51cGRhdGUoYnVmKVxuICAgIHRoaXMuX2FsZW4gKz0gYnVmLmxlbmd0aFxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignQXR0ZW1wdGluZyB0byBzZXQgQUFEIGluIHVuc3VwcG9ydGVkIHN0YXRlJylcbiAgfVxufVxuZnVuY3Rpb24geG9yVGVzdCAoYSwgYikge1xuICB2YXIgb3V0ID0gMFxuICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgb3V0KytcbiAgfVxuICB2YXIgbGVuID0gTWF0aC5taW4oYS5sZW5ndGgsIGIubGVuZ3RoKVxuICB2YXIgaSA9IC0xXG4gIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICBvdXQgKz0gKGFbaV0gXiBiW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cbiIsInZhciBjaXBoZXJzID0gcmVxdWlyZSgnLi9lbmNyeXB0ZXInKVxuZXhwb3J0cy5jcmVhdGVDaXBoZXIgPSBleHBvcnRzLkNpcGhlciA9IGNpcGhlcnMuY3JlYXRlQ2lwaGVyXG5leHBvcnRzLmNyZWF0ZUNpcGhlcml2ID0gZXhwb3J0cy5DaXBoZXJpdiA9IGNpcGhlcnMuY3JlYXRlQ2lwaGVyaXZcbnZhciBkZWNpcGhlcnMgPSByZXF1aXJlKCcuL2RlY3J5cHRlcicpXG5leHBvcnRzLmNyZWF0ZURlY2lwaGVyID0gZXhwb3J0cy5EZWNpcGhlciA9IGRlY2lwaGVycy5jcmVhdGVEZWNpcGhlclxuZXhwb3J0cy5jcmVhdGVEZWNpcGhlcml2ID0gZXhwb3J0cy5EZWNpcGhlcml2ID0gZGVjaXBoZXJzLmNyZWF0ZURlY2lwaGVyaXZcbnZhciBtb2RlcyA9IHJlcXVpcmUoJy4vbW9kZXMnKVxuZnVuY3Rpb24gZ2V0Q2lwaGVycyAoKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhtb2Rlcylcbn1cbmV4cG9ydHMubGlzdENpcGhlcnMgPSBleHBvcnRzLmdldENpcGhlcnMgPSBnZXRDaXBoZXJzXG4iLCJ2YXIgYWVzID0gcmVxdWlyZSgnLi9hZXMnKVxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJ2NpcGhlci1iYXNlJylcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBtb2RlcyA9IHJlcXVpcmUoJy4vbW9kZXMnKVxudmFyIFN0cmVhbUNpcGhlciA9IHJlcXVpcmUoJy4vc3RyZWFtQ2lwaGVyJylcbnZhciBBdXRoQ2lwaGVyID0gcmVxdWlyZSgnLi9hdXRoQ2lwaGVyJylcbnZhciBlYnRrID0gcmVxdWlyZSgnZXZwX2J5dGVzdG9rZXknKVxuXG5pbmhlcml0cyhEZWNpcGhlciwgVHJhbnNmb3JtKVxuZnVuY3Rpb24gRGVjaXBoZXIgKG1vZGUsIGtleSwgaXYpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIERlY2lwaGVyKSkge1xuICAgIHJldHVybiBuZXcgRGVjaXBoZXIobW9kZSwga2V5LCBpdilcbiAgfVxuICBUcmFuc2Zvcm0uY2FsbCh0aGlzKVxuICB0aGlzLl9jYWNoZSA9IG5ldyBTcGxpdHRlcigpXG4gIHRoaXMuX2xhc3QgPSB2b2lkIDBcbiAgdGhpcy5fY2lwaGVyID0gbmV3IGFlcy5BRVMoa2V5KVxuICB0aGlzLl9wcmV2ID0gbmV3IEJ1ZmZlcihpdi5sZW5ndGgpXG4gIGl2LmNvcHkodGhpcy5fcHJldilcbiAgdGhpcy5fbW9kZSA9IG1vZGVcbiAgdGhpcy5fYXV0b3BhZGRpbmcgPSB0cnVlXG59XG5EZWNpcGhlci5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHRoaXMuX2NhY2hlLmFkZChkYXRhKVxuICB2YXIgY2h1bmtcbiAgdmFyIHRoaW5nXG4gIHZhciBvdXQgPSBbXVxuICB3aGlsZSAoKGNodW5rID0gdGhpcy5fY2FjaGUuZ2V0KHRoaXMuX2F1dG9wYWRkaW5nKSkpIHtcbiAgICB0aGluZyA9IHRoaXMuX21vZGUuZGVjcnlwdCh0aGlzLCBjaHVuaylcbiAgICBvdXQucHVzaCh0aGluZylcbiAgfVxuICByZXR1cm4gQnVmZmVyLmNvbmNhdChvdXQpXG59XG5EZWNpcGhlci5wcm90b3R5cGUuX2ZpbmFsID0gZnVuY3Rpb24gKCkge1xuICB2YXIgY2h1bmsgPSB0aGlzLl9jYWNoZS5mbHVzaCgpXG4gIGlmICh0aGlzLl9hdXRvcGFkZGluZykge1xuICAgIHJldHVybiB1bnBhZCh0aGlzLl9tb2RlLmRlY3J5cHQodGhpcywgY2h1bmspKVxuICB9IGVsc2UgaWYgKGNodW5rKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdkYXRhIG5vdCBtdWx0aXBsZSBvZiBibG9jayBsZW5ndGgnKVxuICB9XG59XG5EZWNpcGhlci5wcm90b3R5cGUuc2V0QXV0b1BhZGRpbmcgPSBmdW5jdGlvbiAoc2V0VG8pIHtcbiAgdGhpcy5fYXV0b3BhZGRpbmcgPSAhIXNldFRvXG59XG5mdW5jdGlvbiBTcGxpdHRlciAoKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTcGxpdHRlcikpIHtcbiAgICByZXR1cm4gbmV3IFNwbGl0dGVyKClcbiAgfVxuICB0aGlzLmNhY2hlID0gbmV3IEJ1ZmZlcignJylcbn1cblNwbGl0dGVyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB0aGlzLmNhY2hlID0gQnVmZmVyLmNvbmNhdChbdGhpcy5jYWNoZSwgZGF0YV0pXG59XG5cblNwbGl0dGVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoYXV0b1BhZGRpbmcpIHtcbiAgdmFyIG91dFxuICBpZiAoYXV0b1BhZGRpbmcpIHtcbiAgICBpZiAodGhpcy5jYWNoZS5sZW5ndGggPiAxNikge1xuICAgICAgb3V0ID0gdGhpcy5jYWNoZS5zbGljZSgwLCAxNilcbiAgICAgIHRoaXMuY2FjaGUgPSB0aGlzLmNhY2hlLnNsaWNlKDE2KVxuICAgICAgcmV0dXJuIG91dFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodGhpcy5jYWNoZS5sZW5ndGggPj0gMTYpIHtcbiAgICAgIG91dCA9IHRoaXMuY2FjaGUuc2xpY2UoMCwgMTYpXG4gICAgICB0aGlzLmNhY2hlID0gdGhpcy5jYWNoZS5zbGljZSgxNilcbiAgICAgIHJldHVybiBvdXRcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGxcbn1cblNwbGl0dGVyLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuY2FjaGUubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FjaGVcbiAgfVxufVxuZnVuY3Rpb24gdW5wYWQgKGxhc3QpIHtcbiAgdmFyIHBhZGRlZCA9IGxhc3RbMTVdXG4gIHZhciBpID0gLTFcbiAgd2hpbGUgKCsraSA8IHBhZGRlZCkge1xuICAgIGlmIChsYXN0WyhpICsgKDE2IC0gcGFkZGVkKSldICE9PSBwYWRkZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndW5hYmxlIHRvIGRlY3J5cHQgZGF0YScpXG4gICAgfVxuICB9XG4gIGlmIChwYWRkZWQgPT09IDE2KSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgcmV0dXJuIGxhc3Quc2xpY2UoMCwgMTYgLSBwYWRkZWQpXG59XG5cbnZhciBtb2RlbGlzdCA9IHtcbiAgRUNCOiByZXF1aXJlKCcuL21vZGVzL2VjYicpLFxuICBDQkM6IHJlcXVpcmUoJy4vbW9kZXMvY2JjJyksXG4gIENGQjogcmVxdWlyZSgnLi9tb2Rlcy9jZmInKSxcbiAgQ0ZCODogcmVxdWlyZSgnLi9tb2Rlcy9jZmI4JyksXG4gIENGQjE6IHJlcXVpcmUoJy4vbW9kZXMvY2ZiMScpLFxuICBPRkI6IHJlcXVpcmUoJy4vbW9kZXMvb2ZiJyksXG4gIENUUjogcmVxdWlyZSgnLi9tb2Rlcy9jdHInKSxcbiAgR0NNOiByZXF1aXJlKCcuL21vZGVzL2N0cicpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZURlY2lwaGVyaXYgKHN1aXRlLCBwYXNzd29yZCwgaXYpIHtcbiAgdmFyIGNvbmZpZyA9IG1vZGVzW3N1aXRlLnRvTG93ZXJDYXNlKCldXG4gIGlmICghY29uZmlnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBzdWl0ZSB0eXBlJylcbiAgfVxuICBpZiAodHlwZW9mIGl2ID09PSAnc3RyaW5nJykge1xuICAgIGl2ID0gbmV3IEJ1ZmZlcihpdilcbiAgfVxuICBpZiAodHlwZW9mIHBhc3N3b3JkID09PSAnc3RyaW5nJykge1xuICAgIHBhc3N3b3JkID0gbmV3IEJ1ZmZlcihwYXNzd29yZClcbiAgfVxuICBpZiAocGFzc3dvcmQubGVuZ3RoICE9PSBjb25maWcua2V5IC8gOCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQga2V5IGxlbmd0aCAnICsgcGFzc3dvcmQubGVuZ3RoKVxuICB9XG4gIGlmIChpdi5sZW5ndGggIT09IGNvbmZpZy5pdikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgaXYgbGVuZ3RoICcgKyBpdi5sZW5ndGgpXG4gIH1cbiAgaWYgKGNvbmZpZy50eXBlID09PSAnc3RyZWFtJykge1xuICAgIHJldHVybiBuZXcgU3RyZWFtQ2lwaGVyKG1vZGVsaXN0W2NvbmZpZy5tb2RlXSwgcGFzc3dvcmQsIGl2LCB0cnVlKVxuICB9IGVsc2UgaWYgKGNvbmZpZy50eXBlID09PSAnYXV0aCcpIHtcbiAgICByZXR1cm4gbmV3IEF1dGhDaXBoZXIobW9kZWxpc3RbY29uZmlnLm1vZGVdLCBwYXNzd29yZCwgaXYsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG5ldyBEZWNpcGhlcihtb2RlbGlzdFtjb25maWcubW9kZV0sIHBhc3N3b3JkLCBpdilcbn1cblxuZnVuY3Rpb24gY3JlYXRlRGVjaXBoZXIgKHN1aXRlLCBwYXNzd29yZCkge1xuICB2YXIgY29uZmlnID0gbW9kZXNbc3VpdGUudG9Mb3dlckNhc2UoKV1cbiAgaWYgKCFjb25maWcpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHN1aXRlIHR5cGUnKVxuICB9XG4gIHZhciBrZXlzID0gZWJ0ayhwYXNzd29yZCwgZmFsc2UsIGNvbmZpZy5rZXksIGNvbmZpZy5pdilcbiAgcmV0dXJuIGNyZWF0ZURlY2lwaGVyaXYoc3VpdGUsIGtleXMua2V5LCBrZXlzLml2KVxufVxuZXhwb3J0cy5jcmVhdGVEZWNpcGhlciA9IGNyZWF0ZURlY2lwaGVyXG5leHBvcnRzLmNyZWF0ZURlY2lwaGVyaXYgPSBjcmVhdGVEZWNpcGhlcml2XG4iLCJ2YXIgYWVzID0gcmVxdWlyZSgnLi9hZXMnKVxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJ2NpcGhlci1iYXNlJylcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBtb2RlcyA9IHJlcXVpcmUoJy4vbW9kZXMnKVxudmFyIGVidGsgPSByZXF1aXJlKCdldnBfYnl0ZXN0b2tleScpXG52YXIgU3RyZWFtQ2lwaGVyID0gcmVxdWlyZSgnLi9zdHJlYW1DaXBoZXInKVxudmFyIEF1dGhDaXBoZXIgPSByZXF1aXJlKCcuL2F1dGhDaXBoZXInKVxuaW5oZXJpdHMoQ2lwaGVyLCBUcmFuc2Zvcm0pXG5mdW5jdGlvbiBDaXBoZXIgKG1vZGUsIGtleSwgaXYpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIENpcGhlcikpIHtcbiAgICByZXR1cm4gbmV3IENpcGhlcihtb2RlLCBrZXksIGl2KVxuICB9XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMpXG4gIHRoaXMuX2NhY2hlID0gbmV3IFNwbGl0dGVyKClcbiAgdGhpcy5fY2lwaGVyID0gbmV3IGFlcy5BRVMoa2V5KVxuICB0aGlzLl9wcmV2ID0gbmV3IEJ1ZmZlcihpdi5sZW5ndGgpXG4gIGl2LmNvcHkodGhpcy5fcHJldilcbiAgdGhpcy5fbW9kZSA9IG1vZGVcbiAgdGhpcy5fYXV0b3BhZGRpbmcgPSB0cnVlXG59XG5DaXBoZXIucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB0aGlzLl9jYWNoZS5hZGQoZGF0YSlcbiAgdmFyIGNodW5rXG4gIHZhciB0aGluZ1xuICB2YXIgb3V0ID0gW11cbiAgd2hpbGUgKChjaHVuayA9IHRoaXMuX2NhY2hlLmdldCgpKSkge1xuICAgIHRoaW5nID0gdGhpcy5fbW9kZS5lbmNyeXB0KHRoaXMsIGNodW5rKVxuICAgIG91dC5wdXNoKHRoaW5nKVxuICB9XG4gIHJldHVybiBCdWZmZXIuY29uY2F0KG91dClcbn1cbkNpcGhlci5wcm90b3R5cGUuX2ZpbmFsID0gZnVuY3Rpb24gKCkge1xuICB2YXIgY2h1bmsgPSB0aGlzLl9jYWNoZS5mbHVzaCgpXG4gIGlmICh0aGlzLl9hdXRvcGFkZGluZykge1xuICAgIGNodW5rID0gdGhpcy5fbW9kZS5lbmNyeXB0KHRoaXMsIGNodW5rKVxuICAgIHRoaXMuX2NpcGhlci5zY3J1YigpXG4gICAgcmV0dXJuIGNodW5rXG4gIH0gZWxzZSBpZiAoY2h1bmsudG9TdHJpbmcoJ2hleCcpICE9PSAnMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAnKSB7XG4gICAgdGhpcy5fY2lwaGVyLnNjcnViKClcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2RhdGEgbm90IG11bHRpcGxlIG9mIGJsb2NrIGxlbmd0aCcpXG4gIH1cbn1cbkNpcGhlci5wcm90b3R5cGUuc2V0QXV0b1BhZGRpbmcgPSBmdW5jdGlvbiAoc2V0VG8pIHtcbiAgdGhpcy5fYXV0b3BhZGRpbmcgPSAhIXNldFRvXG59XG5cbmZ1bmN0aW9uIFNwbGl0dGVyICgpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNwbGl0dGVyKSkge1xuICAgIHJldHVybiBuZXcgU3BsaXR0ZXIoKVxuICB9XG4gIHRoaXMuY2FjaGUgPSBuZXcgQnVmZmVyKCcnKVxufVxuU3BsaXR0ZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHRoaXMuY2FjaGUgPSBCdWZmZXIuY29uY2F0KFt0aGlzLmNhY2hlLCBkYXRhXSlcbn1cblxuU3BsaXR0ZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuY2FjaGUubGVuZ3RoID4gMTUpIHtcbiAgICB2YXIgb3V0ID0gdGhpcy5jYWNoZS5zbGljZSgwLCAxNilcbiAgICB0aGlzLmNhY2hlID0gdGhpcy5jYWNoZS5zbGljZSgxNilcbiAgICByZXR1cm4gb3V0XG4gIH1cbiAgcmV0dXJuIG51bGxcbn1cblNwbGl0dGVyLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGxlbiA9IDE2IC0gdGhpcy5jYWNoZS5sZW5ndGhcbiAgdmFyIHBhZEJ1ZmYgPSBuZXcgQnVmZmVyKGxlbilcblxuICB2YXIgaSA9IC0xXG4gIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICBwYWRCdWZmLndyaXRlVUludDgobGVuLCBpKVxuICB9XG4gIHZhciBvdXQgPSBCdWZmZXIuY29uY2F0KFt0aGlzLmNhY2hlLCBwYWRCdWZmXSlcbiAgcmV0dXJuIG91dFxufVxudmFyIG1vZGVsaXN0ID0ge1xuICBFQ0I6IHJlcXVpcmUoJy4vbW9kZXMvZWNiJyksXG4gIENCQzogcmVxdWlyZSgnLi9tb2Rlcy9jYmMnKSxcbiAgQ0ZCOiByZXF1aXJlKCcuL21vZGVzL2NmYicpLFxuICBDRkI4OiByZXF1aXJlKCcuL21vZGVzL2NmYjgnKSxcbiAgQ0ZCMTogcmVxdWlyZSgnLi9tb2Rlcy9jZmIxJyksXG4gIE9GQjogcmVxdWlyZSgnLi9tb2Rlcy9vZmInKSxcbiAgQ1RSOiByZXF1aXJlKCcuL21vZGVzL2N0cicpLFxuICBHQ006IHJlcXVpcmUoJy4vbW9kZXMvY3RyJylcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ2lwaGVyaXYgKHN1aXRlLCBwYXNzd29yZCwgaXYpIHtcbiAgdmFyIGNvbmZpZyA9IG1vZGVzW3N1aXRlLnRvTG93ZXJDYXNlKCldXG4gIGlmICghY29uZmlnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBzdWl0ZSB0eXBlJylcbiAgfVxuICBpZiAodHlwZW9mIGl2ID09PSAnc3RyaW5nJykge1xuICAgIGl2ID0gbmV3IEJ1ZmZlcihpdilcbiAgfVxuICBpZiAodHlwZW9mIHBhc3N3b3JkID09PSAnc3RyaW5nJykge1xuICAgIHBhc3N3b3JkID0gbmV3IEJ1ZmZlcihwYXNzd29yZClcbiAgfVxuICBpZiAocGFzc3dvcmQubGVuZ3RoICE9PSBjb25maWcua2V5IC8gOCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQga2V5IGxlbmd0aCAnICsgcGFzc3dvcmQubGVuZ3RoKVxuICB9XG4gIGlmIChpdi5sZW5ndGggIT09IGNvbmZpZy5pdikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgaXYgbGVuZ3RoICcgKyBpdi5sZW5ndGgpXG4gIH1cbiAgaWYgKGNvbmZpZy50eXBlID09PSAnc3RyZWFtJykge1xuICAgIHJldHVybiBuZXcgU3RyZWFtQ2lwaGVyKG1vZGVsaXN0W2NvbmZpZy5tb2RlXSwgcGFzc3dvcmQsIGl2KVxuICB9IGVsc2UgaWYgKGNvbmZpZy50eXBlID09PSAnYXV0aCcpIHtcbiAgICByZXR1cm4gbmV3IEF1dGhDaXBoZXIobW9kZWxpc3RbY29uZmlnLm1vZGVdLCBwYXNzd29yZCwgaXYpXG4gIH1cbiAgcmV0dXJuIG5ldyBDaXBoZXIobW9kZWxpc3RbY29uZmlnLm1vZGVdLCBwYXNzd29yZCwgaXYpXG59XG5mdW5jdGlvbiBjcmVhdGVDaXBoZXIgKHN1aXRlLCBwYXNzd29yZCkge1xuICB2YXIgY29uZmlnID0gbW9kZXNbc3VpdGUudG9Mb3dlckNhc2UoKV1cbiAgaWYgKCFjb25maWcpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHN1aXRlIHR5cGUnKVxuICB9XG4gIHZhciBrZXlzID0gZWJ0ayhwYXNzd29yZCwgZmFsc2UsIGNvbmZpZy5rZXksIGNvbmZpZy5pdilcbiAgcmV0dXJuIGNyZWF0ZUNpcGhlcml2KHN1aXRlLCBrZXlzLmtleSwga2V5cy5pdilcbn1cblxuZXhwb3J0cy5jcmVhdGVDaXBoZXJpdiA9IGNyZWF0ZUNpcGhlcml2XG5leHBvcnRzLmNyZWF0ZUNpcGhlciA9IGNyZWF0ZUNpcGhlclxuIiwidmFyIHplcm9zID0gbmV3IEJ1ZmZlcigxNilcbnplcm9zLmZpbGwoMClcbm1vZHVsZS5leHBvcnRzID0gR0hBU0hcbmZ1bmN0aW9uIEdIQVNIIChrZXkpIHtcbiAgdGhpcy5oID0ga2V5XG4gIHRoaXMuc3RhdGUgPSBuZXcgQnVmZmVyKDE2KVxuICB0aGlzLnN0YXRlLmZpbGwoMClcbiAgdGhpcy5jYWNoZSA9IG5ldyBCdWZmZXIoJycpXG59XG4vLyBmcm9tIGh0dHA6Ly9iaXR3aXNlc2hpZnRsZWZ0LmdpdGh1Yi5pby9zamNsL2RvYy9zeW1ib2xzL3NyYy9jb3JlX2djbS5qcy5odG1sXG4vLyBieSBKdWhvIFbDpGjDpC1IZXJ0dHVhXG5HSEFTSC5wcm90b3R5cGUuZ2hhc2ggPSBmdW5jdGlvbiAoYmxvY2spIHtcbiAgdmFyIGkgPSAtMVxuICB3aGlsZSAoKytpIDwgYmxvY2subGVuZ3RoKSB7XG4gICAgdGhpcy5zdGF0ZVtpXSBePSBibG9ja1tpXVxuICB9XG4gIHRoaXMuX211bHRpcGx5KClcbn1cblxuR0hBU0gucHJvdG90eXBlLl9tdWx0aXBseSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIFZpID0gdG9BcnJheSh0aGlzLmgpXG4gIHZhciBaaSA9IFswLCAwLCAwLCAwXVxuICB2YXIgaiwgeGksIGxzYl9WaVxuICB2YXIgaSA9IC0xXG4gIHdoaWxlICgrK2kgPCAxMjgpIHtcbiAgICB4aSA9ICh0aGlzLnN0YXRlW35+KGkgLyA4KV0gJiAoMSA8PCAoNyAtIGkgJSA4KSkpICE9PSAwXG4gICAgaWYgKHhpKSB7XG4gICAgICAvLyBaX2krMSA9IFpfaSBeIFZfaVxuICAgICAgWmkgPSB4b3IoWmksIFZpKVxuICAgIH1cblxuICAgIC8vIFN0b3JlIHRoZSB2YWx1ZSBvZiBMU0IoVl9pKVxuICAgIGxzYl9WaSA9IChWaVszXSAmIDEpICE9PSAwXG5cbiAgICAvLyBWX2krMSA9IFZfaSA+PiAxXG4gICAgZm9yIChqID0gMzsgaiA+IDA7IGotLSkge1xuICAgICAgVmlbal0gPSAoVmlbal0gPj4+IDEpIHwgKChWaVtqIC0gMV0gJiAxKSA8PCAzMSlcbiAgICB9XG4gICAgVmlbMF0gPSBWaVswXSA+Pj4gMVxuXG4gICAgLy8gSWYgTFNCKFZfaSkgaXMgMSwgVl9pKzEgPSAoVl9pID4+IDEpIF4gUlxuICAgIGlmIChsc2JfVmkpIHtcbiAgICAgIFZpWzBdID0gVmlbMF0gXiAoMHhlMSA8PCAyNClcbiAgICB9XG4gIH1cbiAgdGhpcy5zdGF0ZSA9IGZyb21BcnJheShaaSlcbn1cbkdIQVNILnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIHRoaXMuY2FjaGUgPSBCdWZmZXIuY29uY2F0KFt0aGlzLmNhY2hlLCBidWZdKVxuICB2YXIgY2h1bmtcbiAgd2hpbGUgKHRoaXMuY2FjaGUubGVuZ3RoID49IDE2KSB7XG4gICAgY2h1bmsgPSB0aGlzLmNhY2hlLnNsaWNlKDAsIDE2KVxuICAgIHRoaXMuY2FjaGUgPSB0aGlzLmNhY2hlLnNsaWNlKDE2KVxuICAgIHRoaXMuZ2hhc2goY2h1bmspXG4gIH1cbn1cbkdIQVNILnByb3RvdHlwZS5maW5hbCA9IGZ1bmN0aW9uIChhYmwsIGJsKSB7XG4gIGlmICh0aGlzLmNhY2hlLmxlbmd0aCkge1xuICAgIHRoaXMuZ2hhc2goQnVmZmVyLmNvbmNhdChbdGhpcy5jYWNoZSwgemVyb3NdLCAxNikpXG4gIH1cbiAgdGhpcy5naGFzaChmcm9tQXJyYXkoW1xuICAgIDAsIGFibCxcbiAgICAwLCBibFxuICBdKSlcbiAgcmV0dXJuIHRoaXMuc3RhdGVcbn1cblxuZnVuY3Rpb24gdG9BcnJheSAoYnVmKSB7XG4gIHJldHVybiBbXG4gICAgYnVmLnJlYWRVSW50MzJCRSgwKSxcbiAgICBidWYucmVhZFVJbnQzMkJFKDQpLFxuICAgIGJ1Zi5yZWFkVUludDMyQkUoOCksXG4gICAgYnVmLnJlYWRVSW50MzJCRSgxMilcbiAgXVxufVxuZnVuY3Rpb24gZnJvbUFycmF5IChvdXQpIHtcbiAgb3V0ID0gb3V0Lm1hcChmaXh1cF91aW50MzIpXG4gIHZhciBidWYgPSBuZXcgQnVmZmVyKDE2KVxuICBidWYud3JpdGVVSW50MzJCRShvdXRbMF0sIDApXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKG91dFsxXSwgNClcbiAgYnVmLndyaXRlVUludDMyQkUob3V0WzJdLCA4KVxuICBidWYud3JpdGVVSW50MzJCRShvdXRbM10sIDEyKVxuICByZXR1cm4gYnVmXG59XG52YXIgdWludF9tYXggPSBNYXRoLnBvdygyLCAzMilcbmZ1bmN0aW9uIGZpeHVwX3VpbnQzMiAoeCkge1xuICB2YXIgcmV0LCB4X3Bvc1xuICByZXQgPSB4ID4gdWludF9tYXggfHwgeCA8IDAgPyAoeF9wb3MgPSBNYXRoLmFicyh4KSAlIHVpbnRfbWF4LCB4IDwgMCA/IHVpbnRfbWF4IC0geF9wb3MgOiB4X3BvcykgOiB4XG4gIHJldHVybiByZXRcbn1cbmZ1bmN0aW9uIHhvciAoYSwgYikge1xuICByZXR1cm4gW1xuICAgIGFbMF0gXiBiWzBdLFxuICAgIGFbMV0gXiBiWzFdLFxuICAgIGFbMl0gXiBiWzJdLFxuICAgIGFbM10gXiBiWzNdXG4gIF1cbn1cbiIsImV4cG9ydHNbJ2Flcy0xMjgtZWNiJ10gPSB7XG4gIGNpcGhlcjogJ0FFUycsXG4gIGtleTogMTI4LFxuICBpdjogMCxcbiAgbW9kZTogJ0VDQicsXG4gIHR5cGU6ICdibG9jaydcbn1cbmV4cG9ydHNbJ2Flcy0xOTItZWNiJ10gPSB7XG4gIGNpcGhlcjogJ0FFUycsXG4gIGtleTogMTkyLFxuICBpdjogMCxcbiAgbW9kZTogJ0VDQicsXG4gIHR5cGU6ICdibG9jaydcbn1cbmV4cG9ydHNbJ2Flcy0yNTYtZWNiJ10gPSB7XG4gIGNpcGhlcjogJ0FFUycsXG4gIGtleTogMjU2LFxuICBpdjogMCxcbiAgbW9kZTogJ0VDQicsXG4gIHR5cGU6ICdibG9jaydcbn1cbmV4cG9ydHNbJ2Flcy0xMjgtY2JjJ10gPSB7XG4gIGNpcGhlcjogJ0FFUycsXG4gIGtleTogMTI4LFxuICBpdjogMTYsXG4gIG1vZGU6ICdDQkMnLFxuICB0eXBlOiAnYmxvY2snXG59XG5leHBvcnRzWydhZXMtMTkyLWNiYyddID0ge1xuICBjaXBoZXI6ICdBRVMnLFxuICBrZXk6IDE5MixcbiAgaXY6IDE2LFxuICBtb2RlOiAnQ0JDJyxcbiAgdHlwZTogJ2Jsb2NrJ1xufVxuZXhwb3J0c1snYWVzLTI1Ni1jYmMnXSA9IHtcbiAgY2lwaGVyOiAnQUVTJyxcbiAga2V5OiAyNTYsXG4gIGl2OiAxNixcbiAgbW9kZTogJ0NCQycsXG4gIHR5cGU6ICdibG9jaydcbn1cbmV4cG9ydHNbJ2FlczEyOCddID0gZXhwb3J0c1snYWVzLTEyOC1jYmMnXVxuZXhwb3J0c1snYWVzMTkyJ10gPSBleHBvcnRzWydhZXMtMTkyLWNiYyddXG5leHBvcnRzWydhZXMyNTYnXSA9IGV4cG9ydHNbJ2Flcy0yNTYtY2JjJ11cbmV4cG9ydHNbJ2Flcy0xMjgtY2ZiJ10gPSB7XG4gIGNpcGhlcjogJ0FFUycsXG4gIGtleTogMTI4LFxuICBpdjogMTYsXG4gIG1vZGU6ICdDRkInLFxuICB0eXBlOiAnc3RyZWFtJ1xufVxuZXhwb3J0c1snYWVzLTE5Mi1jZmInXSA9IHtcbiAgY2lwaGVyOiAnQUVTJyxcbiAga2V5OiAxOTIsXG4gIGl2OiAxNixcbiAgbW9kZTogJ0NGQicsXG4gIHR5cGU6ICdzdHJlYW0nXG59XG5leHBvcnRzWydhZXMtMjU2LWNmYiddID0ge1xuICBjaXBoZXI6ICdBRVMnLFxuICBrZXk6IDI1NixcbiAgaXY6IDE2LFxuICBtb2RlOiAnQ0ZCJyxcbiAgdHlwZTogJ3N0cmVhbSdcbn1cbmV4cG9ydHNbJ2Flcy0xMjgtY2ZiOCddID0ge1xuICBjaXBoZXI6ICdBRVMnLFxuICBrZXk6IDEyOCxcbiAgaXY6IDE2LFxuICBtb2RlOiAnQ0ZCOCcsXG4gIHR5cGU6ICdzdHJlYW0nXG59XG5leHBvcnRzWydhZXMtMTkyLWNmYjgnXSA9IHtcbiAgY2lwaGVyOiAnQUVTJyxcbiAga2V5OiAxOTIsXG4gIGl2OiAxNixcbiAgbW9kZTogJ0NGQjgnLFxuICB0eXBlOiAnc3RyZWFtJ1xufVxuZXhwb3J0c1snYWVzLTI1Ni1jZmI4J10gPSB7XG4gIGNpcGhlcjogJ0FFUycsXG4gIGtleTogMjU2LFxuICBpdjogMTYsXG4gIG1vZGU6ICdDRkI4JyxcbiAgdHlwZTogJ3N0cmVhbSdcbn1cbmV4cG9ydHNbJ2Flcy0xMjgtY2ZiMSddID0ge1xuICBjaXBoZXI6ICdBRVMnLFxuICBrZXk6IDEyOCxcbiAgaXY6IDE2LFxuICBtb2RlOiAnQ0ZCMScsXG4gIHR5cGU6ICdzdHJlYW0nXG59XG5leHBvcnRzWydhZXMtMTkyLWNmYjEnXSA9IHtcbiAgY2lwaGVyOiAnQUVTJyxcbiAga2V5OiAxOTIsXG4gIGl2OiAxNixcbiAgbW9kZTogJ0NGQjEnLFxuICB0eXBlOiAnc3RyZWFtJ1xufVxuZXhwb3J0c1snYWVzLTI1Ni1jZmIxJ10gPSB7XG4gIGNpcGhlcjogJ0FFUycsXG4gIGtleTogMjU2LFxuICBpdjogMTYsXG4gIG1vZGU6ICdDRkIxJyxcbiAgdHlwZTogJ3N0cmVhbSdcbn1cbmV4cG9ydHNbJ2Flcy0xMjgtb2ZiJ10gPSB7XG4gIGNpcGhlcjogJ0FFUycsXG4gIGtleTogMTI4LFxuICBpdjogMTYsXG4gIG1vZGU6ICdPRkInLFxuICB0eXBlOiAnc3RyZWFtJ1xufVxuZXhwb3J0c1snYWVzLTE5Mi1vZmInXSA9IHtcbiAgY2lwaGVyOiAnQUVTJyxcbiAga2V5OiAxOTIsXG4gIGl2OiAxNixcbiAgbW9kZTogJ09GQicsXG4gIHR5cGU6ICdzdHJlYW0nXG59XG5leHBvcnRzWydhZXMtMjU2LW9mYiddID0ge1xuICBjaXBoZXI6ICdBRVMnLFxuICBrZXk6IDI1NixcbiAgaXY6IDE2LFxuICBtb2RlOiAnT0ZCJyxcbiAgdHlwZTogJ3N0cmVhbSdcbn1cbmV4cG9ydHNbJ2Flcy0xMjgtY3RyJ10gPSB7XG4gIGNpcGhlcjogJ0FFUycsXG4gIGtleTogMTI4LFxuICBpdjogMTYsXG4gIG1vZGU6ICdDVFInLFxuICB0eXBlOiAnc3RyZWFtJ1xufVxuZXhwb3J0c1snYWVzLTE5Mi1jdHInXSA9IHtcbiAgY2lwaGVyOiAnQUVTJyxcbiAga2V5OiAxOTIsXG4gIGl2OiAxNixcbiAgbW9kZTogJ0NUUicsXG4gIHR5cGU6ICdzdHJlYW0nXG59XG5leHBvcnRzWydhZXMtMjU2LWN0ciddID0ge1xuICBjaXBoZXI6ICdBRVMnLFxuICBrZXk6IDI1NixcbiAgaXY6IDE2LFxuICBtb2RlOiAnQ1RSJyxcbiAgdHlwZTogJ3N0cmVhbSdcbn1cbmV4cG9ydHNbJ2Flcy0xMjgtZ2NtJ10gPSB7XG4gIGNpcGhlcjogJ0FFUycsXG4gIGtleTogMTI4LFxuICBpdjogMTIsXG4gIG1vZGU6ICdHQ00nLFxuICB0eXBlOiAnYXV0aCdcbn1cbmV4cG9ydHNbJ2Flcy0xOTItZ2NtJ10gPSB7XG4gIGNpcGhlcjogJ0FFUycsXG4gIGtleTogMTkyLFxuICBpdjogMTIsXG4gIG1vZGU6ICdHQ00nLFxuICB0eXBlOiAnYXV0aCdcbn1cbmV4cG9ydHNbJ2Flcy0yNTYtZ2NtJ10gPSB7XG4gIGNpcGhlcjogJ0FFUycsXG4gIGtleTogMjU2LFxuICBpdjogMTIsXG4gIG1vZGU6ICdHQ00nLFxuICB0eXBlOiAnYXV0aCdcbn1cbiIsInZhciB4b3IgPSByZXF1aXJlKCdidWZmZXIteG9yJylcblxuZXhwb3J0cy5lbmNyeXB0ID0gZnVuY3Rpb24gKHNlbGYsIGJsb2NrKSB7XG4gIHZhciBkYXRhID0geG9yKGJsb2NrLCBzZWxmLl9wcmV2KVxuXG4gIHNlbGYuX3ByZXYgPSBzZWxmLl9jaXBoZXIuZW5jcnlwdEJsb2NrKGRhdGEpXG4gIHJldHVybiBzZWxmLl9wcmV2XG59XG5cbmV4cG9ydHMuZGVjcnlwdCA9IGZ1bmN0aW9uIChzZWxmLCBibG9jaykge1xuICB2YXIgcGFkID0gc2VsZi5fcHJldlxuXG4gIHNlbGYuX3ByZXYgPSBibG9ja1xuICB2YXIgb3V0ID0gc2VsZi5fY2lwaGVyLmRlY3J5cHRCbG9jayhibG9jaylcblxuICByZXR1cm4geG9yKG91dCwgcGFkKVxufVxuIiwidmFyIHhvciA9IHJlcXVpcmUoJ2J1ZmZlci14b3InKVxuXG5leHBvcnRzLmVuY3J5cHQgPSBmdW5jdGlvbiAoc2VsZiwgZGF0YSwgZGVjcnlwdCkge1xuICB2YXIgb3V0ID0gbmV3IEJ1ZmZlcignJylcbiAgdmFyIGxlblxuXG4gIHdoaWxlIChkYXRhLmxlbmd0aCkge1xuICAgIGlmIChzZWxmLl9jYWNoZS5sZW5ndGggPT09IDApIHtcbiAgICAgIHNlbGYuX2NhY2hlID0gc2VsZi5fY2lwaGVyLmVuY3J5cHRCbG9jayhzZWxmLl9wcmV2KVxuICAgICAgc2VsZi5fcHJldiA9IG5ldyBCdWZmZXIoJycpXG4gICAgfVxuXG4gICAgaWYgKHNlbGYuX2NhY2hlLmxlbmd0aCA8PSBkYXRhLmxlbmd0aCkge1xuICAgICAgbGVuID0gc2VsZi5fY2FjaGUubGVuZ3RoXG4gICAgICBvdXQgPSBCdWZmZXIuY29uY2F0KFtvdXQsIGVuY3J5cHRTdGFydChzZWxmLCBkYXRhLnNsaWNlKDAsIGxlbiksIGRlY3J5cHQpXSlcbiAgICAgIGRhdGEgPSBkYXRhLnNsaWNlKGxlbilcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ID0gQnVmZmVyLmNvbmNhdChbb3V0LCBlbmNyeXB0U3RhcnQoc2VsZiwgZGF0YSwgZGVjcnlwdCldKVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb3V0XG59XG5mdW5jdGlvbiBlbmNyeXB0U3RhcnQgKHNlbGYsIGRhdGEsIGRlY3J5cHQpIHtcbiAgdmFyIGxlbiA9IGRhdGEubGVuZ3RoXG4gIHZhciBvdXQgPSB4b3IoZGF0YSwgc2VsZi5fY2FjaGUpXG4gIHNlbGYuX2NhY2hlID0gc2VsZi5fY2FjaGUuc2xpY2UobGVuKVxuICBzZWxmLl9wcmV2ID0gQnVmZmVyLmNvbmNhdChbc2VsZi5fcHJldiwgZGVjcnlwdCA/IGRhdGEgOiBvdXRdKVxuICByZXR1cm4gb3V0XG59XG4iLCJmdW5jdGlvbiBlbmNyeXB0Qnl0ZSAoc2VsZiwgYnl0ZVBhcmFtLCBkZWNyeXB0KSB7XG4gIHZhciBwYWRcbiAgdmFyIGkgPSAtMVxuICB2YXIgbGVuID0gOFxuICB2YXIgb3V0ID0gMFxuICB2YXIgYml0LCB2YWx1ZVxuICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgcGFkID0gc2VsZi5fY2lwaGVyLmVuY3J5cHRCbG9jayhzZWxmLl9wcmV2KVxuICAgIGJpdCA9IChieXRlUGFyYW0gJiAoMSA8PCAoNyAtIGkpKSkgPyAweDgwIDogMFxuICAgIHZhbHVlID0gcGFkWzBdIF4gYml0XG4gICAgb3V0ICs9ICgodmFsdWUgJiAweDgwKSA+PiAoaSAlIDgpKVxuICAgIHNlbGYuX3ByZXYgPSBzaGlmdEluKHNlbGYuX3ByZXYsIGRlY3J5cHQgPyBiaXQgOiB2YWx1ZSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5leHBvcnRzLmVuY3J5cHQgPSBmdW5jdGlvbiAoc2VsZiwgY2h1bmssIGRlY3J5cHQpIHtcbiAgdmFyIGxlbiA9IGNodW5rLmxlbmd0aFxuICB2YXIgb3V0ID0gbmV3IEJ1ZmZlcihsZW4pXG4gIHZhciBpID0gLTFcbiAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgIG91dFtpXSA9IGVuY3J5cHRCeXRlKHNlbGYsIGNodW5rW2ldLCBkZWNyeXB0KVxuICB9XG4gIHJldHVybiBvdXRcbn1cbmZ1bmN0aW9uIHNoaWZ0SW4gKGJ1ZmZlciwgdmFsdWUpIHtcbiAgdmFyIGxlbiA9IGJ1ZmZlci5sZW5ndGhcbiAgdmFyIGkgPSAtMVxuICB2YXIgb3V0ID0gbmV3IEJ1ZmZlcihidWZmZXIubGVuZ3RoKVxuICBidWZmZXIgPSBCdWZmZXIuY29uY2F0KFtidWZmZXIsIG5ldyBCdWZmZXIoW3ZhbHVlXSldKVxuICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgb3V0W2ldID0gYnVmZmVyW2ldIDw8IDEgfCBidWZmZXJbaSArIDFdID4+ICg3KVxuICB9XG4gIHJldHVybiBvdXRcbn1cbiIsImZ1bmN0aW9uIGVuY3J5cHRCeXRlIChzZWxmLCBieXRlUGFyYW0sIGRlY3J5cHQpIHtcbiAgdmFyIHBhZCA9IHNlbGYuX2NpcGhlci5lbmNyeXB0QmxvY2soc2VsZi5fcHJldilcbiAgdmFyIG91dCA9IHBhZFswXSBeIGJ5dGVQYXJhbVxuICBzZWxmLl9wcmV2ID0gQnVmZmVyLmNvbmNhdChbc2VsZi5fcHJldi5zbGljZSgxKSwgbmV3IEJ1ZmZlcihbZGVjcnlwdCA/IGJ5dGVQYXJhbSA6IG91dF0pXSlcbiAgcmV0dXJuIG91dFxufVxuZXhwb3J0cy5lbmNyeXB0ID0gZnVuY3Rpb24gKHNlbGYsIGNodW5rLCBkZWNyeXB0KSB7XG4gIHZhciBsZW4gPSBjaHVuay5sZW5ndGhcbiAgdmFyIG91dCA9IG5ldyBCdWZmZXIobGVuKVxuICB2YXIgaSA9IC0xXG4gIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICBvdXRbaV0gPSBlbmNyeXB0Qnl0ZShzZWxmLCBjaHVua1tpXSwgZGVjcnlwdClcbiAgfVxuICByZXR1cm4gb3V0XG59XG4iLCJ2YXIgeG9yID0gcmVxdWlyZSgnYnVmZmVyLXhvcicpXG5cbmZ1bmN0aW9uIGluY3IzMiAoaXYpIHtcbiAgdmFyIGxlbiA9IGl2Lmxlbmd0aFxuICB2YXIgaXRlbVxuICB3aGlsZSAobGVuLS0pIHtcbiAgICBpdGVtID0gaXYucmVhZFVJbnQ4KGxlbilcbiAgICBpZiAoaXRlbSA9PT0gMjU1KSB7XG4gICAgICBpdi53cml0ZVVJbnQ4KDAsIGxlbilcbiAgICB9IGVsc2Uge1xuICAgICAgaXRlbSsrXG4gICAgICBpdi53cml0ZVVJbnQ4KGl0ZW0sIGxlbilcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldEJsb2NrIChzZWxmKSB7XG4gIHZhciBvdXQgPSBzZWxmLl9jaXBoZXIuZW5jcnlwdEJsb2NrKHNlbGYuX3ByZXYpXG4gIGluY3IzMihzZWxmLl9wcmV2KVxuICByZXR1cm4gb3V0XG59XG5cbmV4cG9ydHMuZW5jcnlwdCA9IGZ1bmN0aW9uIChzZWxmLCBjaHVuaykge1xuICB3aGlsZSAoc2VsZi5fY2FjaGUubGVuZ3RoIDwgY2h1bmsubGVuZ3RoKSB7XG4gICAgc2VsZi5fY2FjaGUgPSBCdWZmZXIuY29uY2F0KFtzZWxmLl9jYWNoZSwgZ2V0QmxvY2soc2VsZildKVxuICB9XG4gIHZhciBwYWQgPSBzZWxmLl9jYWNoZS5zbGljZSgwLCBjaHVuay5sZW5ndGgpXG4gIHNlbGYuX2NhY2hlID0gc2VsZi5fY2FjaGUuc2xpY2UoY2h1bmsubGVuZ3RoKVxuICByZXR1cm4geG9yKGNodW5rLCBwYWQpXG59XG4iLCJleHBvcnRzLmVuY3J5cHQgPSBmdW5jdGlvbiAoc2VsZiwgYmxvY2spIHtcbiAgcmV0dXJuIHNlbGYuX2NpcGhlci5lbmNyeXB0QmxvY2soYmxvY2spXG59XG5leHBvcnRzLmRlY3J5cHQgPSBmdW5jdGlvbiAoc2VsZiwgYmxvY2spIHtcbiAgcmV0dXJuIHNlbGYuX2NpcGhlci5kZWNyeXB0QmxvY2soYmxvY2spXG59XG4iLCJ2YXIgeG9yID0gcmVxdWlyZSgnYnVmZmVyLXhvcicpXG5cbmZ1bmN0aW9uIGdldEJsb2NrIChzZWxmKSB7XG4gIHNlbGYuX3ByZXYgPSBzZWxmLl9jaXBoZXIuZW5jcnlwdEJsb2NrKHNlbGYuX3ByZXYpXG4gIHJldHVybiBzZWxmLl9wcmV2XG59XG5cbmV4cG9ydHMuZW5jcnlwdCA9IGZ1bmN0aW9uIChzZWxmLCBjaHVuaykge1xuICB3aGlsZSAoc2VsZi5fY2FjaGUubGVuZ3RoIDwgY2h1bmsubGVuZ3RoKSB7XG4gICAgc2VsZi5fY2FjaGUgPSBCdWZmZXIuY29uY2F0KFtzZWxmLl9jYWNoZSwgZ2V0QmxvY2soc2VsZildKVxuICB9XG5cbiAgdmFyIHBhZCA9IHNlbGYuX2NhY2hlLnNsaWNlKDAsIGNodW5rLmxlbmd0aClcbiAgc2VsZi5fY2FjaGUgPSBzZWxmLl9jYWNoZS5zbGljZShjaHVuay5sZW5ndGgpXG4gIHJldHVybiB4b3IoY2h1bmssIHBhZClcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24geG9yIChhLCBiKSB7XG4gIHZhciBsZW5ndGggPSBNYXRoLm1pbihhLmxlbmd0aCwgYi5sZW5ndGgpXG4gIHZhciBidWZmZXIgPSBuZXcgQnVmZmVyKGxlbmd0aClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgYnVmZmVyW2ldID0gYVtpXSBeIGJbaV1cbiAgfVxuXG4gIHJldHVybiBidWZmZXJcbn1cbiIsInZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCdzdHJlYW0nKS5UcmFuc2Zvcm1cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXInKS5TdHJpbmdEZWNvZGVyXG5tb2R1bGUuZXhwb3J0cyA9IENpcGhlckJhc2VcbmluaGVyaXRzKENpcGhlckJhc2UsIFRyYW5zZm9ybSlcbmZ1bmN0aW9uIENpcGhlckJhc2UgKGhhc2hNb2RlKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMpXG4gIHRoaXMuaGFzaE1vZGUgPSB0eXBlb2YgaGFzaE1vZGUgPT09ICdzdHJpbmcnXG4gIGlmICh0aGlzLmhhc2hNb2RlKSB7XG4gICAgdGhpc1toYXNoTW9kZV0gPSB0aGlzLl9maW5hbE9yRGlnZXN0XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5maW5hbCA9IHRoaXMuX2ZpbmFsT3JEaWdlc3RcbiAgfVxuICB0aGlzLl9kZWNvZGVyID0gbnVsbFxuICB0aGlzLl9lbmNvZGluZyA9IG51bGxcbn1cbkNpcGhlckJhc2UucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhLCBpbnB1dEVuYywgb3V0cHV0RW5jKSB7XG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICBkYXRhID0gbmV3IEJ1ZmZlcihkYXRhLCBpbnB1dEVuYylcbiAgfVxuICB2YXIgb3V0RGF0YSA9IHRoaXMuX3VwZGF0ZShkYXRhKVxuICBpZiAodGhpcy5oYXNoTW9kZSkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cbiAgaWYgKG91dHB1dEVuYykge1xuICAgIG91dERhdGEgPSB0aGlzLl90b1N0cmluZyhvdXREYXRhLCBvdXRwdXRFbmMpXG4gIH1cbiAgcmV0dXJuIG91dERhdGFcbn1cblxuQ2lwaGVyQmFzZS5wcm90b3R5cGUuc2V0QXV0b1BhZGRpbmcgPSBmdW5jdGlvbiAoKSB7fVxuXG5DaXBoZXJCYXNlLnByb3RvdHlwZS5nZXRBdXRoVGFnID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ3RyeWluZyB0byBnZXQgYXV0aCB0YWcgaW4gdW5zdXBwb3J0ZWQgc3RhdGUnKVxufVxuXG5DaXBoZXJCYXNlLnByb3RvdHlwZS5zZXRBdXRoVGFnID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ3RyeWluZyB0byBzZXQgYXV0aCB0YWcgaW4gdW5zdXBwb3J0ZWQgc3RhdGUnKVxufVxuXG5DaXBoZXJCYXNlLnByb3RvdHlwZS5zZXRBQUQgPSBmdW5jdGlvbiAoKSB7XG4gIHRocm93IG5ldyBFcnJvcigndHJ5aW5nIHRvIHNldCBhYWQgaW4gdW5zdXBwb3J0ZWQgc3RhdGUnKVxufVxuXG5DaXBoZXJCYXNlLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGRhdGEsIF8sIG5leHQpIHtcbiAgdmFyIGVyclxuICB0cnkge1xuICAgIGlmICh0aGlzLmhhc2hNb2RlKSB7XG4gICAgICB0aGlzLl91cGRhdGUoZGF0YSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wdXNoKHRoaXMuX3VwZGF0ZShkYXRhKSlcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBlcnIgPSBlXG4gIH0gZmluYWxseSB7XG4gICAgbmV4dChlcnIpXG4gIH1cbn1cbkNpcGhlckJhc2UucHJvdG90eXBlLl9mbHVzaCA9IGZ1bmN0aW9uIChkb25lKSB7XG4gIHZhciBlcnJcbiAgdHJ5IHtcbiAgICB0aGlzLnB1c2godGhpcy5fZmluYWwoKSlcbiAgfSBjYXRjaCAoZSkge1xuICAgIGVyciA9IGVcbiAgfSBmaW5hbGx5IHtcbiAgICBkb25lKGVycilcbiAgfVxufVxuQ2lwaGVyQmFzZS5wcm90b3R5cGUuX2ZpbmFsT3JEaWdlc3QgPSBmdW5jdGlvbiAob3V0cHV0RW5jKSB7XG4gIHZhciBvdXREYXRhID0gdGhpcy5fZmluYWwoKSB8fCBuZXcgQnVmZmVyKCcnKVxuICBpZiAob3V0cHV0RW5jKSB7XG4gICAgb3V0RGF0YSA9IHRoaXMuX3RvU3RyaW5nKG91dERhdGEsIG91dHB1dEVuYywgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb3V0RGF0YVxufVxuXG5DaXBoZXJCYXNlLnByb3RvdHlwZS5fdG9TdHJpbmcgPSBmdW5jdGlvbiAodmFsdWUsIGVuYywgZmluYWwpIHtcbiAgaWYgKCF0aGlzLl9kZWNvZGVyKSB7XG4gICAgdGhpcy5fZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKGVuYylcbiAgICB0aGlzLl9lbmNvZGluZyA9IGVuY1xuICB9XG4gIGlmICh0aGlzLl9lbmNvZGluZyAhPT0gZW5jKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjYW5cXCd0IHN3aXRjaCBlbmNvZGluZ3MnKVxuICB9XG4gIHZhciBvdXQgPSB0aGlzLl9kZWNvZGVyLndyaXRlKHZhbHVlKVxuICBpZiAoZmluYWwpIHtcbiAgICBvdXQgKz0gdGhpcy5fZGVjb2Rlci5lbmQoKVxuICB9XG4gIHJldHVybiBvdXRcbn1cbiIsInZhciBhZXMgPSByZXF1aXJlKCcuL2FlcycpXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnY2lwaGVyLWJhc2UnKVxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuXG5pbmhlcml0cyhTdHJlYW1DaXBoZXIsIFRyYW5zZm9ybSlcbm1vZHVsZS5leHBvcnRzID0gU3RyZWFtQ2lwaGVyXG5mdW5jdGlvbiBTdHJlYW1DaXBoZXIgKG1vZGUsIGtleSwgaXYsIGRlY3J5cHQpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFN0cmVhbUNpcGhlcikpIHtcbiAgICByZXR1cm4gbmV3IFN0cmVhbUNpcGhlcihtb2RlLCBrZXksIGl2KVxuICB9XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMpXG4gIHRoaXMuX2NpcGhlciA9IG5ldyBhZXMuQUVTKGtleSlcbiAgdGhpcy5fcHJldiA9IG5ldyBCdWZmZXIoaXYubGVuZ3RoKVxuICB0aGlzLl9jYWNoZSA9IG5ldyBCdWZmZXIoJycpXG4gIHRoaXMuX3NlY0NhY2hlID0gbmV3IEJ1ZmZlcignJylcbiAgdGhpcy5fZGVjcnlwdCA9IGRlY3J5cHRcbiAgaXYuY29weSh0aGlzLl9wcmV2KVxuICB0aGlzLl9tb2RlID0gbW9kZVxufVxuU3RyZWFtQ2lwaGVyLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHJldHVybiB0aGlzLl9tb2RlLmVuY3J5cHQodGhpcywgY2h1bmssIHRoaXMuX2RlY3J5cHQpXG59XG5TdHJlYW1DaXBoZXIucHJvdG90eXBlLl9maW5hbCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fY2lwaGVyLnNjcnViKClcbn1cbiIsInZhciBDaXBoZXJCYXNlID0gcmVxdWlyZSgnY2lwaGVyLWJhc2UnKVxudmFyIGRlcyA9IHJlcXVpcmUoJ2Rlcy5qcycpXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG5cbnZhciBtb2RlcyA9IHtcbiAgJ2Rlcy1lZGUzLWNiYyc6IGRlcy5DQkMuaW5zdGFudGlhdGUoZGVzLkVERSksXG4gICdkZXMtZWRlMyc6IGRlcy5FREUsXG4gICdkZXMtZWRlLWNiYyc6IGRlcy5DQkMuaW5zdGFudGlhdGUoZGVzLkVERSksXG4gICdkZXMtZWRlJzogZGVzLkVERSxcbiAgJ2Rlcy1jYmMnOiBkZXMuQ0JDLmluc3RhbnRpYXRlKGRlcy5ERVMpLFxuICAnZGVzLWVjYic6IGRlcy5ERVNcbn1cbm1vZGVzLmRlcyA9IG1vZGVzWydkZXMtY2JjJ11cbm1vZGVzLmRlczMgPSBtb2Rlc1snZGVzLWVkZTMtY2JjJ11cbm1vZHVsZS5leHBvcnRzID0gREVTXG5pbmhlcml0cyhERVMsIENpcGhlckJhc2UpXG5mdW5jdGlvbiBERVMgKG9wdHMpIHtcbiAgQ2lwaGVyQmFzZS5jYWxsKHRoaXMpXG4gIHZhciBtb2RlTmFtZSA9IG9wdHMubW9kZS50b0xvd2VyQ2FzZSgpXG4gIHZhciBtb2RlID0gbW9kZXNbbW9kZU5hbWVdXG4gIHZhciB0eXBlXG4gIGlmIChvcHRzLmRlY3J5cHQpIHtcbiAgICB0eXBlID0gJ2RlY3J5cHQnXG4gIH0gZWxzZSB7XG4gICAgdHlwZSA9ICdlbmNyeXB0J1xuICB9XG4gIHZhciBrZXkgPSBvcHRzLmtleVxuICBpZiAobW9kZU5hbWUgPT09ICdkZXMtZWRlJyB8fCBtb2RlTmFtZSA9PT0gJ2Rlcy1lZGUtY2JjJykge1xuICAgIGtleSA9IEJ1ZmZlci5jb25jYXQoW2tleSwga2V5LnNsaWNlKDAsIDgpXSlcbiAgfVxuICB2YXIgaXYgPSBvcHRzLml2XG4gIHRoaXMuX2RlcyA9IG1vZGUuY3JlYXRlKHtcbiAgICBrZXk6IGtleSxcbiAgICBpdjogaXYsXG4gICAgdHlwZTogdHlwZVxuICB9KVxufVxuREVTLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgcmV0dXJuIG5ldyBCdWZmZXIodGhpcy5fZGVzLnVwZGF0ZShkYXRhKSlcbn1cbkRFUy5wcm90b3R5cGUuX2ZpbmFsID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbmV3IEJ1ZmZlcih0aGlzLl9kZXMuZmluYWwoKSlcbn1cbiIsImV4cG9ydHNbJ2Rlcy1lY2InXSA9IHtcbiAga2V5OiA4LFxuICBpdjogMFxufVxuZXhwb3J0c1snZGVzLWNiYyddID0gZXhwb3J0cy5kZXMgPSB7XG4gIGtleTogOCxcbiAgaXY6IDhcbn1cbmV4cG9ydHNbJ2Rlcy1lZGUzLWNiYyddID0gZXhwb3J0cy5kZXMzID0ge1xuICBrZXk6IDI0LFxuICBpdjogOFxufVxuZXhwb3J0c1snZGVzLWVkZTMnXSA9IHtcbiAga2V5OiAyNCxcbiAgaXY6IDBcbn1cbmV4cG9ydHNbJ2Rlcy1lZGUtY2JjJ10gPSB7XG4gIGtleTogMTYsXG4gIGl2OiA4XG59XG5leHBvcnRzWydkZXMtZWRlJ10gPSB7XG4gIGtleTogMTYsXG4gIGl2OiAwXG59XG4iLCJ2YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnc3RyZWFtJykuVHJhbnNmb3JtXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyJykuU3RyaW5nRGVjb2RlclxubW9kdWxlLmV4cG9ydHMgPSBDaXBoZXJCYXNlXG5pbmhlcml0cyhDaXBoZXJCYXNlLCBUcmFuc2Zvcm0pXG5mdW5jdGlvbiBDaXBoZXJCYXNlIChoYXNoTW9kZSkge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzKVxuICB0aGlzLmhhc2hNb2RlID0gdHlwZW9mIGhhc2hNb2RlID09PSAnc3RyaW5nJ1xuICBpZiAodGhpcy5oYXNoTW9kZSkge1xuICAgIHRoaXNbaGFzaE1vZGVdID0gdGhpcy5fZmluYWxPckRpZ2VzdFxuICB9IGVsc2Uge1xuICAgIHRoaXMuZmluYWwgPSB0aGlzLl9maW5hbE9yRGlnZXN0XG4gIH1cbiAgdGhpcy5fZGVjb2RlciA9IG51bGxcbiAgdGhpcy5fZW5jb2RpbmcgPSBudWxsXG59XG5DaXBoZXJCYXNlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGF0YSwgaW5wdXRFbmMsIG91dHB1dEVuYykge1xuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgZGF0YSA9IG5ldyBCdWZmZXIoZGF0YSwgaW5wdXRFbmMpXG4gIH1cbiAgdmFyIG91dERhdGEgPSB0aGlzLl91cGRhdGUoZGF0YSlcbiAgaWYgKHRoaXMuaGFzaE1vZGUpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG4gIGlmIChvdXRwdXRFbmMpIHtcbiAgICBvdXREYXRhID0gdGhpcy5fdG9TdHJpbmcob3V0RGF0YSwgb3V0cHV0RW5jKVxuICB9XG4gIHJldHVybiBvdXREYXRhXG59XG5cbkNpcGhlckJhc2UucHJvdG90eXBlLnNldEF1dG9QYWRkaW5nID0gZnVuY3Rpb24gKCkge31cblxuQ2lwaGVyQmFzZS5wcm90b3R5cGUuZ2V0QXV0aFRhZyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCd0cnlpbmcgdG8gZ2V0IGF1dGggdGFnIGluIHVuc3VwcG9ydGVkIHN0YXRlJylcbn1cblxuQ2lwaGVyQmFzZS5wcm90b3R5cGUuc2V0QXV0aFRhZyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCd0cnlpbmcgdG8gc2V0IGF1dGggdGFnIGluIHVuc3VwcG9ydGVkIHN0YXRlJylcbn1cblxuQ2lwaGVyQmFzZS5wcm90b3R5cGUuc2V0QUFEID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ3RyeWluZyB0byBzZXQgYWFkIGluIHVuc3VwcG9ydGVkIHN0YXRlJylcbn1cblxuQ2lwaGVyQmFzZS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChkYXRhLCBfLCBuZXh0KSB7XG4gIHZhciBlcnJcbiAgdHJ5IHtcbiAgICBpZiAodGhpcy5oYXNoTW9kZSkge1xuICAgICAgdGhpcy5fdXBkYXRlKGRhdGEpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucHVzaCh0aGlzLl91cGRhdGUoZGF0YSkpXG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgZXJyID0gZVxuICB9IGZpbmFsbHkge1xuICAgIG5leHQoZXJyKVxuICB9XG59XG5DaXBoZXJCYXNlLnByb3RvdHlwZS5fZmx1c2ggPSBmdW5jdGlvbiAoZG9uZSkge1xuICB2YXIgZXJyXG4gIHRyeSB7XG4gICAgdGhpcy5wdXNoKHRoaXMuX2ZpbmFsKCkpXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBlcnIgPSBlXG4gIH0gZmluYWxseSB7XG4gICAgZG9uZShlcnIpXG4gIH1cbn1cbkNpcGhlckJhc2UucHJvdG90eXBlLl9maW5hbE9yRGlnZXN0ID0gZnVuY3Rpb24gKG91dHB1dEVuYykge1xuICB2YXIgb3V0RGF0YSA9IHRoaXMuX2ZpbmFsKCkgfHwgbmV3IEJ1ZmZlcignJylcbiAgaWYgKG91dHB1dEVuYykge1xuICAgIG91dERhdGEgPSB0aGlzLl90b1N0cmluZyhvdXREYXRhLCBvdXRwdXRFbmMsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG91dERhdGFcbn1cblxuQ2lwaGVyQmFzZS5wcm90b3R5cGUuX3RvU3RyaW5nID0gZnVuY3Rpb24gKHZhbHVlLCBlbmMsIGZpbmFsKSB7XG4gIGlmICghdGhpcy5fZGVjb2Rlcikge1xuICAgIHRoaXMuX2RlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihlbmMpXG4gICAgdGhpcy5fZW5jb2RpbmcgPSBlbmNcbiAgfVxuICBpZiAodGhpcy5fZW5jb2RpbmcgIT09IGVuYykge1xuICAgIHRocm93IG5ldyBFcnJvcignY2FuXFwndCBzd2l0Y2ggZW5jb2RpbmdzJylcbiAgfVxuICB2YXIgb3V0ID0gdGhpcy5fZGVjb2Rlci53cml0ZSh2YWx1ZSlcbiAgaWYgKGZpbmFsKSB7XG4gICAgb3V0ICs9IHRoaXMuX2RlY29kZXIuZW5kKClcbiAgfVxuICByZXR1cm4gb3V0XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMudXRpbHMgPSByZXF1aXJlKCcuL2Rlcy91dGlscycpO1xuZXhwb3J0cy5DaXBoZXIgPSByZXF1aXJlKCcuL2Rlcy9jaXBoZXInKTtcbmV4cG9ydHMuREVTID0gcmVxdWlyZSgnLi9kZXMvZGVzJyk7XG5leHBvcnRzLkNCQyA9IHJlcXVpcmUoJy4vZGVzL2NiYycpO1xuZXhwb3J0cy5FREUgPSByZXF1aXJlKCcuL2Rlcy9lZGUnKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ21pbmltYWxpc3RpYy1hc3NlcnQnKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbnZhciBwcm90byA9IHt9O1xuXG5mdW5jdGlvbiBDQkNTdGF0ZShpdikge1xuICBhc3NlcnQuZXF1YWwoaXYubGVuZ3RoLCA4LCAnSW52YWxpZCBJViBsZW5ndGgnKTtcblxuICB0aGlzLml2ID0gbmV3IEFycmF5KDgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaXYubGVuZ3RoOyBpKyspXG4gICAgdGhpcy5pdltpXSA9IGl2W2ldO1xufVxuXG5mdW5jdGlvbiBpbnN0YW50aWF0ZShCYXNlKSB7XG4gIGZ1bmN0aW9uIENCQyhvcHRpb25zKSB7XG4gICAgQmFzZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgIHRoaXMuX2NiY0luaXQoKTtcbiAgfVxuICBpbmhlcml0cyhDQkMsIEJhc2UpO1xuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvdG8pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICBDQkMucHJvdG90eXBlW2tleV0gPSBwcm90b1trZXldO1xuICB9XG5cbiAgQ0JDLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBDQkMob3B0aW9ucyk7XG4gIH07XG5cbiAgcmV0dXJuIENCQztcbn1cblxuZXhwb3J0cy5pbnN0YW50aWF0ZSA9IGluc3RhbnRpYXRlO1xuXG5wcm90by5fY2JjSW5pdCA9IGZ1bmN0aW9uIF9jYmNJbml0KCkge1xuICB2YXIgc3RhdGUgPSBuZXcgQ0JDU3RhdGUodGhpcy5vcHRpb25zLml2KTtcbiAgdGhpcy5fY2JjU3RhdGUgPSBzdGF0ZTtcbn07XG5cbnByb3RvLl91cGRhdGUgPSBmdW5jdGlvbiBfdXBkYXRlKGlucCwgaW5PZmYsIG91dCwgb3V0T2ZmKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2NiY1N0YXRlO1xuICB2YXIgc3VwZXJQcm90byA9IHRoaXMuY29uc3RydWN0b3Iuc3VwZXJfLnByb3RvdHlwZTtcblxuICB2YXIgaXYgPSBzdGF0ZS5pdjtcbiAgaWYgKHRoaXMudHlwZSA9PT0gJ2VuY3J5cHQnKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJsb2NrU2l6ZTsgaSsrKVxuICAgICAgaXZbaV0gXj0gaW5wW2luT2ZmICsgaV07XG5cbiAgICBzdXBlclByb3RvLl91cGRhdGUuY2FsbCh0aGlzLCBpdiwgMCwgb3V0LCBvdXRPZmYpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJsb2NrU2l6ZTsgaSsrKVxuICAgICAgaXZbaV0gPSBvdXRbb3V0T2ZmICsgaV07XG4gIH0gZWxzZSB7XG4gICAgc3VwZXJQcm90by5fdXBkYXRlLmNhbGwodGhpcywgaW5wLCBpbk9mZiwgb3V0LCBvdXRPZmYpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJsb2NrU2l6ZTsgaSsrKVxuICAgICAgb3V0W291dE9mZiArIGldIF49IGl2W2ldO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJsb2NrU2l6ZTsgaSsrKVxuICAgICAgaXZbaV0gPSBpbnBbaW5PZmYgKyBpXTtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ21pbmltYWxpc3RpYy1hc3NlcnQnKTtcblxuZnVuY3Rpb24gQ2lwaGVyKG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcblxuICB0aGlzLnR5cGUgPSB0aGlzLm9wdGlvbnMudHlwZTtcbiAgdGhpcy5ibG9ja1NpemUgPSA4O1xuICB0aGlzLl9pbml0KCk7XG5cbiAgdGhpcy5idWZmZXIgPSBuZXcgQXJyYXkodGhpcy5ibG9ja1NpemUpO1xuICB0aGlzLmJ1ZmZlck9mZiA9IDA7XG59XG5tb2R1bGUuZXhwb3J0cyA9IENpcGhlcjtcblxuQ2lwaGVyLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIF9pbml0KCkge1xuICAvLyBNaWdodCBiZSBvdmVycmlkZWRcbn07XG5cbkNpcGhlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKGRhdGEpIHtcbiAgaWYgKGRhdGEubGVuZ3RoID09PSAwKVxuICAgIHJldHVybiBbXTtcblxuICBpZiAodGhpcy50eXBlID09PSAnZGVjcnlwdCcpXG4gICAgcmV0dXJuIHRoaXMuX3VwZGF0ZURlY3J5cHQoZGF0YSk7XG4gIGVsc2VcbiAgICByZXR1cm4gdGhpcy5fdXBkYXRlRW5jcnlwdChkYXRhKTtcbn07XG5cbkNpcGhlci5wcm90b3R5cGUuX2J1ZmZlciA9IGZ1bmN0aW9uIF9idWZmZXIoZGF0YSwgb2ZmKSB7XG4gIC8vIEFwcGVuZCBkYXRhIHRvIGJ1ZmZlclxuICB2YXIgbWluID0gTWF0aC5taW4odGhpcy5idWZmZXIubGVuZ3RoIC0gdGhpcy5idWZmZXJPZmYsIGRhdGEubGVuZ3RoIC0gb2ZmKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaW47IGkrKylcbiAgICB0aGlzLmJ1ZmZlclt0aGlzLmJ1ZmZlck9mZiArIGldID0gZGF0YVtvZmYgKyBpXTtcbiAgdGhpcy5idWZmZXJPZmYgKz0gbWluO1xuXG4gIC8vIFNoaWZ0IG5leHRcbiAgcmV0dXJuIG1pbjtcbn07XG5cbkNpcGhlci5wcm90b3R5cGUuX2ZsdXNoQnVmZmVyID0gZnVuY3Rpb24gX2ZsdXNoQnVmZmVyKG91dCwgb2ZmKSB7XG4gIHRoaXMuX3VwZGF0ZSh0aGlzLmJ1ZmZlciwgMCwgb3V0LCBvZmYpO1xuICB0aGlzLmJ1ZmZlck9mZiA9IDA7XG4gIHJldHVybiB0aGlzLmJsb2NrU2l6ZTtcbn07XG5cbkNpcGhlci5wcm90b3R5cGUuX3VwZGF0ZUVuY3J5cHQgPSBmdW5jdGlvbiBfdXBkYXRlRW5jcnlwdChkYXRhKSB7XG4gIHZhciBpbnB1dE9mZiA9IDA7XG4gIHZhciBvdXRwdXRPZmYgPSAwO1xuXG4gIHZhciBjb3VudCA9ICgodGhpcy5idWZmZXJPZmYgKyBkYXRhLmxlbmd0aCkgLyB0aGlzLmJsb2NrU2l6ZSkgfCAwO1xuICB2YXIgb3V0ID0gbmV3IEFycmF5KGNvdW50ICogdGhpcy5ibG9ja1NpemUpO1xuXG4gIGlmICh0aGlzLmJ1ZmZlck9mZiAhPT0gMCkge1xuICAgIGlucHV0T2ZmICs9IHRoaXMuX2J1ZmZlcihkYXRhLCBpbnB1dE9mZik7XG5cbiAgICBpZiAodGhpcy5idWZmZXJPZmYgPT09IHRoaXMuYnVmZmVyLmxlbmd0aClcbiAgICAgIG91dHB1dE9mZiArPSB0aGlzLl9mbHVzaEJ1ZmZlcihvdXQsIG91dHB1dE9mZik7XG4gIH1cblxuICAvLyBXcml0ZSBibG9ja3NcbiAgdmFyIG1heCA9IGRhdGEubGVuZ3RoIC0gKChkYXRhLmxlbmd0aCAtIGlucHV0T2ZmKSAlIHRoaXMuYmxvY2tTaXplKTtcbiAgZm9yICg7IGlucHV0T2ZmIDwgbWF4OyBpbnB1dE9mZiArPSB0aGlzLmJsb2NrU2l6ZSkge1xuICAgIHRoaXMuX3VwZGF0ZShkYXRhLCBpbnB1dE9mZiwgb3V0LCBvdXRwdXRPZmYpO1xuICAgIG91dHB1dE9mZiArPSB0aGlzLmJsb2NrU2l6ZTtcbiAgfVxuXG4gIC8vIFF1ZXVlIHJlc3RcbiAgZm9yICg7IGlucHV0T2ZmIDwgZGF0YS5sZW5ndGg7IGlucHV0T2ZmKyssIHRoaXMuYnVmZmVyT2ZmKyspXG4gICAgdGhpcy5idWZmZXJbdGhpcy5idWZmZXJPZmZdID0gZGF0YVtpbnB1dE9mZl07XG5cbiAgcmV0dXJuIG91dDtcbn07XG5cbkNpcGhlci5wcm90b3R5cGUuX3VwZGF0ZURlY3J5cHQgPSBmdW5jdGlvbiBfdXBkYXRlRGVjcnlwdChkYXRhKSB7XG4gIHZhciBpbnB1dE9mZiA9IDA7XG4gIHZhciBvdXRwdXRPZmYgPSAwO1xuXG4gIHZhciBjb3VudCA9IE1hdGguY2VpbCgodGhpcy5idWZmZXJPZmYgKyBkYXRhLmxlbmd0aCkgLyB0aGlzLmJsb2NrU2l6ZSkgLSAxO1xuICB2YXIgb3V0ID0gbmV3IEFycmF5KGNvdW50ICogdGhpcy5ibG9ja1NpemUpO1xuXG4gIC8vIFRPRE8oaW5kdXRueSk6IG9wdGltaXplIGl0LCB0aGlzIGlzIGZhciBmcm9tIG9wdGltYWxcbiAgZm9yICg7IGNvdW50ID4gMDsgY291bnQtLSkge1xuICAgIGlucHV0T2ZmICs9IHRoaXMuX2J1ZmZlcihkYXRhLCBpbnB1dE9mZik7XG4gICAgb3V0cHV0T2ZmICs9IHRoaXMuX2ZsdXNoQnVmZmVyKG91dCwgb3V0cHV0T2ZmKTtcbiAgfVxuXG4gIC8vIEJ1ZmZlciByZXN0IG9mIHRoZSBpbnB1dFxuICBpbnB1dE9mZiArPSB0aGlzLl9idWZmZXIoZGF0YSwgaW5wdXRPZmYpO1xuXG4gIHJldHVybiBvdXQ7XG59O1xuXG5DaXBoZXIucHJvdG90eXBlLmZpbmFsID0gZnVuY3Rpb24gZmluYWwoYnVmZmVyKSB7XG4gIHZhciBmaXJzdDtcbiAgaWYgKGJ1ZmZlcilcbiAgICBmaXJzdCA9IHRoaXMudXBkYXRlKGJ1ZmZlcik7XG5cbiAgdmFyIGxhc3Q7XG4gIGlmICh0aGlzLnR5cGUgPT09ICdlbmNyeXB0JylcbiAgICBsYXN0ID0gdGhpcy5fZmluYWxFbmNyeXB0KCk7XG4gIGVsc2VcbiAgICBsYXN0ID0gdGhpcy5fZmluYWxEZWNyeXB0KCk7XG5cbiAgaWYgKGZpcnN0KVxuICAgIHJldHVybiBmaXJzdC5jb25jYXQobGFzdCk7XG4gIGVsc2VcbiAgICByZXR1cm4gbGFzdDtcbn07XG5cbkNpcGhlci5wcm90b3R5cGUuX3BhZCA9IGZ1bmN0aW9uIF9wYWQoYnVmZmVyLCBvZmYpIHtcbiAgaWYgKG9mZiA9PT0gMClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgd2hpbGUgKG9mZiA8IGJ1ZmZlci5sZW5ndGgpXG4gICAgYnVmZmVyW29mZisrXSA9IDA7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5DaXBoZXIucHJvdG90eXBlLl9maW5hbEVuY3J5cHQgPSBmdW5jdGlvbiBfZmluYWxFbmNyeXB0KCkge1xuICBpZiAoIXRoaXMuX3BhZCh0aGlzLmJ1ZmZlciwgdGhpcy5idWZmZXJPZmYpKVxuICAgIHJldHVybiBbXTtcblxuICB2YXIgb3V0ID0gbmV3IEFycmF5KHRoaXMuYmxvY2tTaXplKTtcbiAgdGhpcy5fdXBkYXRlKHRoaXMuYnVmZmVyLCAwLCBvdXQsIDApO1xuICByZXR1cm4gb3V0O1xufTtcblxuQ2lwaGVyLnByb3RvdHlwZS5fdW5wYWQgPSBmdW5jdGlvbiBfdW5wYWQoYnVmZmVyKSB7XG4gIHJldHVybiBidWZmZXI7XG59O1xuXG5DaXBoZXIucHJvdG90eXBlLl9maW5hbERlY3J5cHQgPSBmdW5jdGlvbiBfZmluYWxEZWNyeXB0KCkge1xuICBhc3NlcnQuZXF1YWwodGhpcy5idWZmZXJPZmYsIHRoaXMuYmxvY2tTaXplLCAnTm90IGVub3VnaCBkYXRhIHRvIGRlY3J5cHQnKTtcbiAgdmFyIG91dCA9IG5ldyBBcnJheSh0aGlzLmJsb2NrU2l6ZSk7XG4gIHRoaXMuX2ZsdXNoQnVmZmVyKG91dCwgMCk7XG5cbiAgcmV0dXJuIHRoaXMuX3VucGFkKG91dCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnbWluaW1hbGlzdGljLWFzc2VydCcpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxudmFyIGRlcyA9IHJlcXVpcmUoJy4uL2RlcycpO1xudmFyIHV0aWxzID0gZGVzLnV0aWxzO1xudmFyIENpcGhlciA9IGRlcy5DaXBoZXI7XG5cbmZ1bmN0aW9uIERFU1N0YXRlKCkge1xuICB0aGlzLnRtcCA9IG5ldyBBcnJheSgyKTtcbiAgdGhpcy5rZXlzID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gREVTKG9wdGlvbnMpIHtcbiAgQ2lwaGVyLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgdmFyIHN0YXRlID0gbmV3IERFU1N0YXRlKCk7XG4gIHRoaXMuX2Rlc1N0YXRlID0gc3RhdGU7XG5cbiAgdGhpcy5kZXJpdmVLZXlzKHN0YXRlLCBvcHRpb25zLmtleSk7XG59XG5pbmhlcml0cyhERVMsIENpcGhlcik7XG5tb2R1bGUuZXhwb3J0cyA9IERFUztcblxuREVTLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgREVTKG9wdGlvbnMpO1xufTtcblxudmFyIHNoaWZ0VGFibGUgPSBbXG4gIDEsIDEsIDIsIDIsIDIsIDIsIDIsIDIsXG4gIDEsIDIsIDIsIDIsIDIsIDIsIDIsIDFcbl07XG5cbkRFUy5wcm90b3R5cGUuZGVyaXZlS2V5cyA9IGZ1bmN0aW9uIGRlcml2ZUtleXMoc3RhdGUsIGtleSkge1xuICBzdGF0ZS5rZXlzID0gbmV3IEFycmF5KDE2ICogMik7XG5cbiAgYXNzZXJ0LmVxdWFsKGtleS5sZW5ndGgsIHRoaXMuYmxvY2tTaXplLCAnSW52YWxpZCBrZXkgbGVuZ3RoJyk7XG5cbiAgdmFyIGtMID0gdXRpbHMucmVhZFVJbnQzMkJFKGtleSwgMCk7XG4gIHZhciBrUiA9IHV0aWxzLnJlYWRVSW50MzJCRShrZXksIDQpO1xuXG4gIHV0aWxzLnBjMShrTCwga1IsIHN0YXRlLnRtcCwgMCk7XG4gIGtMID0gc3RhdGUudG1wWzBdO1xuICBrUiA9IHN0YXRlLnRtcFsxXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0ZS5rZXlzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgdmFyIHNoaWZ0ID0gc2hpZnRUYWJsZVtpID4+PiAxXTtcbiAgICBrTCA9IHV0aWxzLnIyOHNobChrTCwgc2hpZnQpO1xuICAgIGtSID0gdXRpbHMucjI4c2hsKGtSLCBzaGlmdCk7XG4gICAgdXRpbHMucGMyKGtMLCBrUiwgc3RhdGUua2V5cywgaSk7XG4gIH1cbn07XG5cbkRFUy5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIF91cGRhdGUoaW5wLCBpbk9mZiwgb3V0LCBvdXRPZmYpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fZGVzU3RhdGU7XG5cbiAgdmFyIGwgPSB1dGlscy5yZWFkVUludDMyQkUoaW5wLCBpbk9mZik7XG4gIHZhciByID0gdXRpbHMucmVhZFVJbnQzMkJFKGlucCwgaW5PZmYgKyA0KTtcblxuICAvLyBJbml0aWFsIFBlcm11dGF0aW9uXG4gIHV0aWxzLmlwKGwsIHIsIHN0YXRlLnRtcCwgMCk7XG4gIGwgPSBzdGF0ZS50bXBbMF07XG4gIHIgPSBzdGF0ZS50bXBbMV07XG5cbiAgaWYgKHRoaXMudHlwZSA9PT0gJ2VuY3J5cHQnKVxuICAgIHRoaXMuX2VuY3J5cHQoc3RhdGUsIGwsIHIsIHN0YXRlLnRtcCwgMCk7XG4gIGVsc2VcbiAgICB0aGlzLl9kZWNyeXB0KHN0YXRlLCBsLCByLCBzdGF0ZS50bXAsIDApO1xuXG4gIGwgPSBzdGF0ZS50bXBbMF07XG4gIHIgPSBzdGF0ZS50bXBbMV07XG5cbiAgdXRpbHMud3JpdGVVSW50MzJCRShvdXQsIGwsIG91dE9mZik7XG4gIHV0aWxzLndyaXRlVUludDMyQkUob3V0LCByLCBvdXRPZmYgKyA0KTtcbn07XG5cbkRFUy5wcm90b3R5cGUuX3BhZCA9IGZ1bmN0aW9uIF9wYWQoYnVmZmVyLCBvZmYpIHtcbiAgdmFyIHZhbHVlID0gYnVmZmVyLmxlbmd0aCAtIG9mZjtcbiAgZm9yICh2YXIgaSA9IG9mZjsgaSA8IGJ1ZmZlci5sZW5ndGg7IGkrKylcbiAgICBidWZmZXJbaV0gPSB2YWx1ZTtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbkRFUy5wcm90b3R5cGUuX3VucGFkID0gZnVuY3Rpb24gX3VucGFkKGJ1ZmZlcikge1xuICB2YXIgcGFkID0gYnVmZmVyW2J1ZmZlci5sZW5ndGggLSAxXTtcbiAgZm9yICh2YXIgaSA9IGJ1ZmZlci5sZW5ndGggLSBwYWQ7IGkgPCBidWZmZXIubGVuZ3RoOyBpKyspXG4gICAgYXNzZXJ0LmVxdWFsKGJ1ZmZlcltpXSwgcGFkKTtcblxuICByZXR1cm4gYnVmZmVyLnNsaWNlKDAsIGJ1ZmZlci5sZW5ndGggLSBwYWQpO1xufTtcblxuREVTLnByb3RvdHlwZS5fZW5jcnlwdCA9IGZ1bmN0aW9uIF9lbmNyeXB0KHN0YXRlLCBsU3RhcnQsIHJTdGFydCwgb3V0LCBvZmYpIHtcbiAgdmFyIGwgPSBsU3RhcnQ7XG4gIHZhciByID0gclN0YXJ0O1xuXG4gIC8vIEFwcGx5IGYoKSB4MTYgdGltZXNcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0ZS5rZXlzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgdmFyIGtleUwgPSBzdGF0ZS5rZXlzW2ldO1xuICAgIHZhciBrZXlSID0gc3RhdGUua2V5c1tpICsgMV07XG5cbiAgICAvLyBmKHIsIGspXG4gICAgdXRpbHMuZXhwYW5kKHIsIHN0YXRlLnRtcCwgMCk7XG5cbiAgICBrZXlMIF49IHN0YXRlLnRtcFswXTtcbiAgICBrZXlSIF49IHN0YXRlLnRtcFsxXTtcbiAgICB2YXIgcyA9IHV0aWxzLnN1YnN0aXR1dGUoa2V5TCwga2V5Uik7XG4gICAgdmFyIGYgPSB1dGlscy5wZXJtdXRlKHMpO1xuXG4gICAgdmFyIHQgPSByO1xuICAgIHIgPSAobCBeIGYpID4+PiAwO1xuICAgIGwgPSB0O1xuICB9XG5cbiAgLy8gUmV2ZXJzZSBJbml0aWFsIFBlcm11dGF0aW9uXG4gIHV0aWxzLnJpcChyLCBsLCBvdXQsIG9mZik7XG59O1xuXG5ERVMucHJvdG90eXBlLl9kZWNyeXB0ID0gZnVuY3Rpb24gX2RlY3J5cHQoc3RhdGUsIGxTdGFydCwgclN0YXJ0LCBvdXQsIG9mZikge1xuICB2YXIgbCA9IHJTdGFydDtcbiAgdmFyIHIgPSBsU3RhcnQ7XG5cbiAgLy8gQXBwbHkgZigpIHgxNiB0aW1lc1xuICBmb3IgKHZhciBpID0gc3RhdGUua2V5cy5sZW5ndGggLSAyOyBpID49IDA7IGkgLT0gMikge1xuICAgIHZhciBrZXlMID0gc3RhdGUua2V5c1tpXTtcbiAgICB2YXIga2V5UiA9IHN0YXRlLmtleXNbaSArIDFdO1xuXG4gICAgLy8gZihyLCBrKVxuICAgIHV0aWxzLmV4cGFuZChsLCBzdGF0ZS50bXAsIDApO1xuXG4gICAga2V5TCBePSBzdGF0ZS50bXBbMF07XG4gICAga2V5UiBePSBzdGF0ZS50bXBbMV07XG4gICAgdmFyIHMgPSB1dGlscy5zdWJzdGl0dXRlKGtleUwsIGtleVIpO1xuICAgIHZhciBmID0gdXRpbHMucGVybXV0ZShzKTtcblxuICAgIHZhciB0ID0gbDtcbiAgICBsID0gKHIgXiBmKSA+Pj4gMDtcbiAgICByID0gdDtcbiAgfVxuXG4gIC8vIFJldmVyc2UgSW5pdGlhbCBQZXJtdXRhdGlvblxuICB1dGlscy5yaXAobCwgciwgb3V0LCBvZmYpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ21pbmltYWxpc3RpYy1hc3NlcnQnKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbnZhciBkZXMgPSByZXF1aXJlKCcuLi9kZXMnKTtcbnZhciBDaXBoZXIgPSBkZXMuQ2lwaGVyO1xudmFyIERFUyA9IGRlcy5ERVM7XG5cbmZ1bmN0aW9uIEVERVN0YXRlKHR5cGUsIGtleSkge1xuICBhc3NlcnQuZXF1YWwoa2V5Lmxlbmd0aCwgMjQsICdJbnZhbGlkIGtleSBsZW5ndGgnKTtcblxuICB2YXIgazEgPSBrZXkuc2xpY2UoMCwgOCk7XG4gIHZhciBrMiA9IGtleS5zbGljZSg4LCAxNik7XG4gIHZhciBrMyA9IGtleS5zbGljZSgxNiwgMjQpO1xuXG4gIGlmICh0eXBlID09PSAnZW5jcnlwdCcpIHtcbiAgICB0aGlzLmNpcGhlcnMgPSBbXG4gICAgICBERVMuY3JlYXRlKHsgdHlwZTogJ2VuY3J5cHQnLCBrZXk6IGsxIH0pLFxuICAgICAgREVTLmNyZWF0ZSh7IHR5cGU6ICdkZWNyeXB0Jywga2V5OiBrMiB9KSxcbiAgICAgIERFUy5jcmVhdGUoeyB0eXBlOiAnZW5jcnlwdCcsIGtleTogazMgfSlcbiAgICBdO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuY2lwaGVycyA9IFtcbiAgICAgIERFUy5jcmVhdGUoeyB0eXBlOiAnZGVjcnlwdCcsIGtleTogazMgfSksXG4gICAgICBERVMuY3JlYXRlKHsgdHlwZTogJ2VuY3J5cHQnLCBrZXk6IGsyIH0pLFxuICAgICAgREVTLmNyZWF0ZSh7IHR5cGU6ICdkZWNyeXB0Jywga2V5OiBrMSB9KVxuICAgIF07XG4gIH1cbn1cblxuZnVuY3Rpb24gRURFKG9wdGlvbnMpIHtcbiAgQ2lwaGVyLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgdmFyIHN0YXRlID0gbmV3IEVERVN0YXRlKHRoaXMudHlwZSwgdGhpcy5vcHRpb25zLmtleSk7XG4gIHRoaXMuX2VkZVN0YXRlID0gc3RhdGU7XG59XG5pbmhlcml0cyhFREUsIENpcGhlcik7XG5cbm1vZHVsZS5leHBvcnRzID0gRURFO1xuXG5FREUuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBFREUob3B0aW9ucyk7XG59O1xuXG5FREUucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiBfdXBkYXRlKGlucCwgaW5PZmYsIG91dCwgb3V0T2ZmKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2VkZVN0YXRlO1xuXG4gIHN0YXRlLmNpcGhlcnNbMF0uX3VwZGF0ZShpbnAsIGluT2ZmLCBvdXQsIG91dE9mZik7XG4gIHN0YXRlLmNpcGhlcnNbMV0uX3VwZGF0ZShvdXQsIG91dE9mZiwgb3V0LCBvdXRPZmYpO1xuICBzdGF0ZS5jaXBoZXJzWzJdLl91cGRhdGUob3V0LCBvdXRPZmYsIG91dCwgb3V0T2ZmKTtcbn07XG5cbkVERS5wcm90b3R5cGUuX3BhZCA9IERFUy5wcm90b3R5cGUuX3BhZDtcbkVERS5wcm90b3R5cGUuX3VucGFkID0gREVTLnByb3RvdHlwZS5fdW5wYWQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFKGJ5dGVzLCBvZmYpIHtcbiAgdmFyIHJlcyA9ICAoYnl0ZXNbMCArIG9mZl0gPDwgMjQpIHxcbiAgICAgICAgICAgICAoYnl0ZXNbMSArIG9mZl0gPDwgMTYpIHxcbiAgICAgICAgICAgICAoYnl0ZXNbMiArIG9mZl0gPDwgOCkgfFxuICAgICAgICAgICAgIGJ5dGVzWzMgKyBvZmZdO1xuICByZXR1cm4gcmVzID4+PiAwO1xufTtcblxuZXhwb3J0cy53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRShieXRlcywgdmFsdWUsIG9mZikge1xuICBieXRlc1swICsgb2ZmXSA9IHZhbHVlID4+PiAyNDtcbiAgYnl0ZXNbMSArIG9mZl0gPSAodmFsdWUgPj4+IDE2KSAmIDB4ZmY7XG4gIGJ5dGVzWzIgKyBvZmZdID0gKHZhbHVlID4+PiA4KSAmIDB4ZmY7XG4gIGJ5dGVzWzMgKyBvZmZdID0gdmFsdWUgJiAweGZmO1xufTtcblxuZXhwb3J0cy5pcCA9IGZ1bmN0aW9uIGlwKGluTCwgaW5SLCBvdXQsIG9mZikge1xuICB2YXIgb3V0TCA9IDA7XG4gIHZhciBvdXRSID0gMDtcblxuICBmb3IgKHZhciBpID0gNjsgaSA+PSAwOyBpIC09IDIpIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8PSAyNDsgaiArPSA4KSB7XG4gICAgICBvdXRMIDw8PSAxO1xuICAgICAgb3V0TCB8PSAoaW5SID4+PiAoaiArIGkpKSAmIDE7XG4gICAgfVxuICAgIGZvciAodmFyIGogPSAwOyBqIDw9IDI0OyBqICs9IDgpIHtcbiAgICAgIG91dEwgPDw9IDE7XG4gICAgICBvdXRMIHw9IChpbkwgPj4+IChqICsgaSkpICYgMTtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBpID0gNjsgaSA+PSAwOyBpIC09IDIpIHtcbiAgICBmb3IgKHZhciBqID0gMTsgaiA8PSAyNTsgaiArPSA4KSB7XG4gICAgICBvdXRSIDw8PSAxO1xuICAgICAgb3V0UiB8PSAoaW5SID4+PiAoaiArIGkpKSAmIDE7XG4gICAgfVxuICAgIGZvciAodmFyIGogPSAxOyBqIDw9IDI1OyBqICs9IDgpIHtcbiAgICAgIG91dFIgPDw9IDE7XG4gICAgICBvdXRSIHw9IChpbkwgPj4+IChqICsgaSkpICYgMTtcbiAgICB9XG4gIH1cblxuICBvdXRbb2ZmICsgMF0gPSBvdXRMID4+PiAwO1xuICBvdXRbb2ZmICsgMV0gPSBvdXRSID4+PiAwO1xufTtcblxuZXhwb3J0cy5yaXAgPSBmdW5jdGlvbiByaXAoaW5MLCBpblIsIG91dCwgb2ZmKSB7XG4gIHZhciBvdXRMID0gMDtcbiAgdmFyIG91dFIgPSAwO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgZm9yICh2YXIgaiA9IDI0OyBqID49IDA7IGogLT0gOCkge1xuICAgICAgb3V0TCA8PD0gMTtcbiAgICAgIG91dEwgfD0gKGluUiA+Pj4gKGogKyBpKSkgJiAxO1xuICAgICAgb3V0TCA8PD0gMTtcbiAgICAgIG91dEwgfD0gKGluTCA+Pj4gKGogKyBpKSkgJiAxO1xuICAgIH1cbiAgfVxuICBmb3IgKHZhciBpID0gNDsgaSA8IDg7IGkrKykge1xuICAgIGZvciAodmFyIGogPSAyNDsgaiA+PSAwOyBqIC09IDgpIHtcbiAgICAgIG91dFIgPDw9IDE7XG4gICAgICBvdXRSIHw9IChpblIgPj4+IChqICsgaSkpICYgMTtcbiAgICAgIG91dFIgPDw9IDE7XG4gICAgICBvdXRSIHw9IChpbkwgPj4+IChqICsgaSkpICYgMTtcbiAgICB9XG4gIH1cblxuICBvdXRbb2ZmICsgMF0gPSBvdXRMID4+PiAwO1xuICBvdXRbb2ZmICsgMV0gPSBvdXRSID4+PiAwO1xufTtcblxuZXhwb3J0cy5wYzEgPSBmdW5jdGlvbiBwYzEoaW5MLCBpblIsIG91dCwgb2ZmKSB7XG4gIHZhciBvdXRMID0gMDtcbiAgdmFyIG91dFIgPSAwO1xuXG4gIC8vIDcsIDE1LCAyMywgMzEsIDM5LCA0NywgNTUsIDYzXG4gIC8vIDYsIDE0LCAyMiwgMzAsIDM5LCA0NywgNTUsIDYzXG4gIC8vIDUsIDEzLCAyMSwgMjksIDM5LCA0NywgNTUsIDYzXG4gIC8vIDQsIDEyLCAyMCwgMjhcbiAgZm9yICh2YXIgaSA9IDc7IGkgPj0gNTsgaS0tKSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPD0gMjQ7IGogKz0gOCkge1xuICAgICAgb3V0TCA8PD0gMTtcbiAgICAgIG91dEwgfD0gKGluUiA+PiAoaiArIGkpKSAmIDE7XG4gICAgfVxuICAgIGZvciAodmFyIGogPSAwOyBqIDw9IDI0OyBqICs9IDgpIHtcbiAgICAgIG91dEwgPDw9IDE7XG4gICAgICBvdXRMIHw9IChpbkwgPj4gKGogKyBpKSkgJiAxO1xuICAgIH1cbiAgfVxuICBmb3IgKHZhciBqID0gMDsgaiA8PSAyNDsgaiArPSA4KSB7XG4gICAgb3V0TCA8PD0gMTtcbiAgICBvdXRMIHw9IChpblIgPj4gKGogKyBpKSkgJiAxO1xuICB9XG5cbiAgLy8gMSwgOSwgMTcsIDI1LCAzMywgNDEsIDQ5LCA1N1xuICAvLyAyLCAxMCwgMTgsIDI2LCAzNCwgNDIsIDUwLCA1OFxuICAvLyAzLCAxMSwgMTksIDI3LCAzNSwgNDMsIDUxLCA1OVxuICAvLyAzNiwgNDQsIDUyLCA2MFxuICBmb3IgKHZhciBpID0gMTsgaSA8PSAzOyBpKyspIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8PSAyNDsgaiArPSA4KSB7XG4gICAgICBvdXRSIDw8PSAxO1xuICAgICAgb3V0UiB8PSAoaW5SID4+IChqICsgaSkpICYgMTtcbiAgICB9XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPD0gMjQ7IGogKz0gOCkge1xuICAgICAgb3V0UiA8PD0gMTtcbiAgICAgIG91dFIgfD0gKGluTCA+PiAoaiArIGkpKSAmIDE7XG4gICAgfVxuICB9XG4gIGZvciAodmFyIGogPSAwOyBqIDw9IDI0OyBqICs9IDgpIHtcbiAgICBvdXRSIDw8PSAxO1xuICAgIG91dFIgfD0gKGluTCA+PiAoaiArIGkpKSAmIDE7XG4gIH1cblxuICBvdXRbb2ZmICsgMF0gPSBvdXRMID4+PiAwO1xuICBvdXRbb2ZmICsgMV0gPSBvdXRSID4+PiAwO1xufTtcblxuZXhwb3J0cy5yMjhzaGwgPSBmdW5jdGlvbiByMjhzaGwobnVtLCBzaGlmdCkge1xuICByZXR1cm4gKChudW0gPDwgc2hpZnQpICYgMHhmZmZmZmZmKSB8IChudW0gPj4+ICgyOCAtIHNoaWZ0KSk7XG59O1xuXG52YXIgcGMydGFibGUgPSBbXG4gIC8vIGluTCA9PiBvdXRMXG4gIDE0LCAxMSwgMTcsIDQsIDI3LCAyMywgMjUsIDAsXG4gIDEzLCAyMiwgNywgMTgsIDUsIDksIDE2LCAyNCxcbiAgMiwgMjAsIDEyLCAyMSwgMSwgOCwgMTUsIDI2LFxuXG4gIC8vIGluUiA9PiBvdXRSXG4gIDE1LCA0LCAyNSwgMTksIDksIDEsIDI2LCAxNixcbiAgNSwgMTEsIDIzLCA4LCAxMiwgNywgMTcsIDAsXG4gIDIyLCAzLCAxMCwgMTQsIDYsIDIwLCAyNywgMjRcbl07XG5cbmV4cG9ydHMucGMyID0gZnVuY3Rpb24gcGMyKGluTCwgaW5SLCBvdXQsIG9mZikge1xuICB2YXIgb3V0TCA9IDA7XG4gIHZhciBvdXRSID0gMDtcblxuICB2YXIgbGVuID0gcGMydGFibGUubGVuZ3RoID4+PiAxO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgb3V0TCA8PD0gMTtcbiAgICBvdXRMIHw9IChpbkwgPj4+IHBjMnRhYmxlW2ldKSAmIDB4MTtcbiAgfVxuICBmb3IgKHZhciBpID0gbGVuOyBpIDwgcGMydGFibGUubGVuZ3RoOyBpKyspIHtcbiAgICBvdXRSIDw8PSAxO1xuICAgIG91dFIgfD0gKGluUiA+Pj4gcGMydGFibGVbaV0pICYgMHgxO1xuICB9XG5cbiAgb3V0W29mZiArIDBdID0gb3V0TCA+Pj4gMDtcbiAgb3V0W29mZiArIDFdID0gb3V0UiA+Pj4gMDtcbn07XG5cbmV4cG9ydHMuZXhwYW5kID0gZnVuY3Rpb24gZXhwYW5kKHIsIG91dCwgb2ZmKSB7XG4gIHZhciBvdXRMID0gMDtcbiAgdmFyIG91dFIgPSAwO1xuXG4gIG91dEwgPSAoKHIgJiAxKSA8PCA1KSB8IChyID4+PiAyNyk7XG4gIGZvciAodmFyIGkgPSAyMzsgaSA+PSAxNTsgaSAtPSA0KSB7XG4gICAgb3V0TCA8PD0gNjtcbiAgICBvdXRMIHw9IChyID4+PiBpKSAmIDB4M2Y7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDExOyBpID49IDM7IGkgLT0gNCkge1xuICAgIG91dFIgfD0gKHIgPj4+IGkpICYgMHgzZjtcbiAgICBvdXRSIDw8PSA2O1xuICB9XG4gIG91dFIgfD0gKChyICYgMHgxZikgPDwgMSkgfCAociA+Pj4gMzEpO1xuXG4gIG91dFtvZmYgKyAwXSA9IG91dEwgPj4+IDA7XG4gIG91dFtvZmYgKyAxXSA9IG91dFIgPj4+IDA7XG59O1xuXG52YXIgc1RhYmxlID0gW1xuICAxNCwgMCwgNCwgMTUsIDEzLCA3LCAxLCA0LCAyLCAxNCwgMTUsIDIsIDExLCAxMywgOCwgMSxcbiAgMywgMTAsIDEwLCA2LCA2LCAxMiwgMTIsIDExLCA1LCA5LCA5LCA1LCAwLCAzLCA3LCA4LFxuICA0LCAxNSwgMSwgMTIsIDE0LCA4LCA4LCAyLCAxMywgNCwgNiwgOSwgMiwgMSwgMTEsIDcsXG4gIDE1LCA1LCAxMiwgMTEsIDksIDMsIDcsIDE0LCAzLCAxMCwgMTAsIDAsIDUsIDYsIDAsIDEzLFxuXG4gIDE1LCAzLCAxLCAxMywgOCwgNCwgMTQsIDcsIDYsIDE1LCAxMSwgMiwgMywgOCwgNCwgMTQsXG4gIDksIDEyLCA3LCAwLCAyLCAxLCAxMywgMTAsIDEyLCA2LCAwLCA5LCA1LCAxMSwgMTAsIDUsXG4gIDAsIDEzLCAxNCwgOCwgNywgMTAsIDExLCAxLCAxMCwgMywgNCwgMTUsIDEzLCA0LCAxLCAyLFxuICA1LCAxMSwgOCwgNiwgMTIsIDcsIDYsIDEyLCA5LCAwLCAzLCA1LCAyLCAxNCwgMTUsIDksXG5cbiAgMTAsIDEzLCAwLCA3LCA5LCAwLCAxNCwgOSwgNiwgMywgMywgNCwgMTUsIDYsIDUsIDEwLFxuICAxLCAyLCAxMywgOCwgMTIsIDUsIDcsIDE0LCAxMSwgMTIsIDQsIDExLCAyLCAxNSwgOCwgMSxcbiAgMTMsIDEsIDYsIDEwLCA0LCAxMywgOSwgMCwgOCwgNiwgMTUsIDksIDMsIDgsIDAsIDcsXG4gIDExLCA0LCAxLCAxNSwgMiwgMTQsIDEyLCAzLCA1LCAxMSwgMTAsIDUsIDE0LCAyLCA3LCAxMixcblxuICA3LCAxMywgMTMsIDgsIDE0LCAxMSwgMywgNSwgMCwgNiwgNiwgMTUsIDksIDAsIDEwLCAzLFxuICAxLCA0LCAyLCA3LCA4LCAyLCA1LCAxMiwgMTEsIDEsIDEyLCAxMCwgNCwgMTQsIDE1LCA5LFxuICAxMCwgMywgNiwgMTUsIDksIDAsIDAsIDYsIDEyLCAxMCwgMTEsIDEsIDcsIDEzLCAxMywgOCxcbiAgMTUsIDksIDEsIDQsIDMsIDUsIDE0LCAxMSwgNSwgMTIsIDIsIDcsIDgsIDIsIDQsIDE0LFxuXG4gIDIsIDE0LCAxMiwgMTEsIDQsIDIsIDEsIDEyLCA3LCA0LCAxMCwgNywgMTEsIDEzLCA2LCAxLFxuICA4LCA1LCA1LCAwLCAzLCAxNSwgMTUsIDEwLCAxMywgMywgMCwgOSwgMTQsIDgsIDksIDYsXG4gIDQsIDExLCAyLCA4LCAxLCAxMiwgMTEsIDcsIDEwLCAxLCAxMywgMTQsIDcsIDIsIDgsIDEzLFxuICAxNSwgNiwgOSwgMTUsIDEyLCAwLCA1LCA5LCA2LCAxMCwgMywgNCwgMCwgNSwgMTQsIDMsXG5cbiAgMTIsIDEwLCAxLCAxNSwgMTAsIDQsIDE1LCAyLCA5LCA3LCAyLCAxMiwgNiwgOSwgOCwgNSxcbiAgMCwgNiwgMTMsIDEsIDMsIDEzLCA0LCAxNCwgMTQsIDAsIDcsIDExLCA1LCAzLCAxMSwgOCxcbiAgOSwgNCwgMTQsIDMsIDE1LCAyLCA1LCAxMiwgMiwgOSwgOCwgNSwgMTIsIDE1LCAzLCAxMCxcbiAgNywgMTEsIDAsIDE0LCA0LCAxLCAxMCwgNywgMSwgNiwgMTMsIDAsIDExLCA4LCA2LCAxMyxcblxuICA0LCAxMywgMTEsIDAsIDIsIDExLCAxNCwgNywgMTUsIDQsIDAsIDksIDgsIDEsIDEzLCAxMCxcbiAgMywgMTQsIDEyLCAzLCA5LCA1LCA3LCAxMiwgNSwgMiwgMTAsIDE1LCA2LCA4LCAxLCA2LFxuICAxLCA2LCA0LCAxMSwgMTEsIDEzLCAxMywgOCwgMTIsIDEsIDMsIDQsIDcsIDEwLCAxNCwgNyxcbiAgMTAsIDksIDE1LCA1LCA2LCAwLCA4LCAxNSwgMCwgMTQsIDUsIDIsIDksIDMsIDIsIDEyLFxuXG4gIDEzLCAxLCAyLCAxNSwgOCwgMTMsIDQsIDgsIDYsIDEwLCAxNSwgMywgMTEsIDcsIDEsIDQsXG4gIDEwLCAxMiwgOSwgNSwgMywgNiwgMTQsIDExLCA1LCAwLCAwLCAxNCwgMTIsIDksIDcsIDIsXG4gIDcsIDIsIDExLCAxLCA0LCAxNCwgMSwgNywgOSwgNCwgMTIsIDEwLCAxNCwgOCwgMiwgMTMsXG4gIDAsIDE1LCA2LCAxMiwgMTAsIDksIDEzLCAwLCAxNSwgMywgMywgNSwgNSwgNiwgOCwgMTFcbl07XG5cbmV4cG9ydHMuc3Vic3RpdHV0ZSA9IGZ1bmN0aW9uIHN1YnN0aXR1dGUoaW5MLCBpblIpIHtcbiAgdmFyIG91dCA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgdmFyIGIgPSAoaW5MID4+PiAoMTggLSBpICogNikpICYgMHgzZjtcbiAgICB2YXIgc2IgPSBzVGFibGVbaSAqIDB4NDAgKyBiXTtcblxuICAgIG91dCA8PD0gNDtcbiAgICBvdXQgfD0gc2I7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICB2YXIgYiA9IChpblIgPj4+ICgxOCAtIGkgKiA2KSkgJiAweDNmO1xuICAgIHZhciBzYiA9IHNUYWJsZVs0ICogMHg0MCArIGkgKiAweDQwICsgYl07XG5cbiAgICBvdXQgPDw9IDQ7XG4gICAgb3V0IHw9IHNiO1xuICB9XG4gIHJldHVybiBvdXQgPj4+IDA7XG59O1xuXG52YXIgcGVybXV0ZVRhYmxlID0gW1xuICAxNiwgMjUsIDEyLCAxMSwgMywgMjAsIDQsIDE1LCAzMSwgMTcsIDksIDYsIDI3LCAxNCwgMSwgMjIsXG4gIDMwLCAyNCwgOCwgMTgsIDAsIDUsIDI5LCAyMywgMTMsIDE5LCAyLCAyNiwgMTAsIDIxLCAyOCwgN1xuXTtcblxuZXhwb3J0cy5wZXJtdXRlID0gZnVuY3Rpb24gcGVybXV0ZShudW0pIHtcbiAgdmFyIG91dCA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGVybXV0ZVRhYmxlLmxlbmd0aDsgaSsrKSB7XG4gICAgb3V0IDw8PSAxO1xuICAgIG91dCB8PSAobnVtID4+PiBwZXJtdXRlVGFibGVbaV0pICYgMHgxO1xuICB9XG4gIHJldHVybiBvdXQgPj4+IDA7XG59O1xuXG5leHBvcnRzLnBhZFNwbGl0ID0gZnVuY3Rpb24gcGFkU3BsaXQobnVtLCBzaXplLCBncm91cCkge1xuICB2YXIgc3RyID0gbnVtLnRvU3RyaW5nKDIpO1xuICB3aGlsZSAoc3RyLmxlbmd0aCA8IHNpemUpXG4gICAgc3RyID0gJzAnICsgc3RyO1xuXG4gIHZhciBvdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyBpICs9IGdyb3VwKVxuICAgIG91dC5wdXNoKHN0ci5zbGljZShpLCBpICsgZ3JvdXApKTtcbiAgcmV0dXJuIG91dC5qb2luKCcgJyk7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBhc3NlcnQ7XG5cbmZ1bmN0aW9uIGFzc2VydCh2YWwsIG1zZykge1xuICBpZiAoIXZhbClcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnIHx8ICdBc3NlcnRpb24gZmFpbGVkJyk7XG59XG5cbmFzc2VydC5lcXVhbCA9IGZ1bmN0aW9uIGFzc2VydEVxdWFsKGwsIHIsIG1zZykge1xuICBpZiAobCAhPSByKVxuICAgIHRocm93IG5ldyBFcnJvcihtc2cgfHwgKCdBc3NlcnRpb24gZmFpbGVkOiAnICsgbCArICcgIT0gJyArIHIpKTtcbn07XG4iLCJ2YXIgbWQ1ID0gcmVxdWlyZSgnY3JlYXRlLWhhc2gvbWQ1Jylcbm1vZHVsZS5leHBvcnRzID0gRVZQX0J5dGVzVG9LZXlcbmZ1bmN0aW9uIEVWUF9CeXRlc1RvS2V5IChwYXNzd29yZCwgc2FsdCwga2V5TGVuLCBpdkxlbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihwYXNzd29yZCkpIHtcbiAgICBwYXNzd29yZCA9IG5ldyBCdWZmZXIocGFzc3dvcmQsICdiaW5hcnknKVxuICB9XG4gIGlmIChzYWx0ICYmICFCdWZmZXIuaXNCdWZmZXIoc2FsdCkpIHtcbiAgICBzYWx0ID0gbmV3IEJ1ZmZlcihzYWx0LCAnYmluYXJ5JylcbiAgfVxuICBrZXlMZW4gPSBrZXlMZW4gLyA4XG4gIGl2TGVuID0gaXZMZW4gfHwgMFxuICB2YXIga2kgPSAwXG4gIHZhciBpaSA9IDBcbiAgdmFyIGtleSA9IG5ldyBCdWZmZXIoa2V5TGVuKVxuICB2YXIgaXYgPSBuZXcgQnVmZmVyKGl2TGVuKVxuICB2YXIgYWRkbWQgPSAwXG4gIHZhciBtZF9idWZcbiAgdmFyIGlcbiAgdmFyIGJ1ZnMgPSBbXVxuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmIChhZGRtZCsrID4gMCkge1xuICAgICAgYnVmcy5wdXNoKG1kX2J1ZilcbiAgICB9XG4gICAgYnVmcy5wdXNoKHBhc3N3b3JkKVxuICAgIGlmIChzYWx0KSB7XG4gICAgICBidWZzLnB1c2goc2FsdClcbiAgICB9XG4gICAgbWRfYnVmID0gbWQ1KEJ1ZmZlci5jb25jYXQoYnVmcykpXG4gICAgYnVmcyA9IFtdXG4gICAgaSA9IDBcbiAgICBpZiAoa2V5TGVuID4gMCkge1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgaWYgKGtleUxlbiA9PT0gMCkge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPT09IG1kX2J1Zi5sZW5ndGgpIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGtleVtraSsrXSA9IG1kX2J1ZltpXVxuICAgICAgICBrZXlMZW4tLVxuICAgICAgICBpKytcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGl2TGVuID4gMCAmJiBpICE9PSBtZF9idWYubGVuZ3RoKSB7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBpZiAoaXZMZW4gPT09IDApIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGlmIChpID09PSBtZF9idWYubGVuZ3RoKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBpdltpaSsrXSA9IG1kX2J1ZltpXVxuICAgICAgICBpdkxlbi0tXG4gICAgICAgIGkrK1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoa2V5TGVuID09PSAwICYmIGl2TGVuID09PSAwKSB7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuICBmb3IgKGkgPSAwOyBpIDwgbWRfYnVmLmxlbmd0aDsgaSsrKSB7XG4gICAgbWRfYnVmW2ldID0gMFxuICB9XG4gIHJldHVybiB7XG4gICAga2V5OiBrZXksXG4gICAgaXY6IGl2XG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0J1xuZXhwb3J0c1snUlNBLVNIQTIyNCddID0gZXhwb3J0cy5zaGEyMjRXaXRoUlNBRW5jcnlwdGlvbiA9IHtcbiAgc2lnbjogJ3JzYScsXG4gIGhhc2g6ICdzaGEyMjQnLFxuICBpZDogbmV3IEJ1ZmZlcignMzAyZDMwMGQwNjA5NjA4NjQ4MDE2NTAzMDQwMjA0MDUwMDA0MWMnLCAnaGV4Jylcbn1cbmV4cG9ydHNbJ1JTQS1TSEEyNTYnXSA9IGV4cG9ydHMuc2hhMjU2V2l0aFJTQUVuY3J5cHRpb24gPSB7XG4gIHNpZ246ICdyc2EnLFxuICBoYXNoOiAnc2hhMjU2JyxcbiAgaWQ6IG5ldyBCdWZmZXIoJzMwMzEzMDBkMDYwOTYwODY0ODAxNjUwMzA0MDIwMTA1MDAwNDIwJywgJ2hleCcpXG59XG5leHBvcnRzWydSU0EtU0hBMzg0J10gPSBleHBvcnRzLnNoYTM4NFdpdGhSU0FFbmNyeXB0aW9uID0ge1xuICBzaWduOiAncnNhJyxcbiAgaGFzaDogJ3NoYTM4NCcsXG4gIGlkOiBuZXcgQnVmZmVyKCczMDQxMzAwZDA2MDk2MDg2NDgwMTY1MDMwNDAyMDIwNTAwMDQzMCcsICdoZXgnKVxufVxuZXhwb3J0c1snUlNBLVNIQTUxMiddID0gZXhwb3J0cy5zaGE1MTJXaXRoUlNBRW5jcnlwdGlvbiA9IHtcbiAgc2lnbjogJ3JzYScsXG4gIGhhc2g6ICdzaGE1MTInLFxuICBpZDogbmV3IEJ1ZmZlcignMzA1MTMwMGQwNjA5NjA4NjQ4MDE2NTAzMDQwMjAzMDUwMDA0NDAnLCAnaGV4Jylcbn1cbmV4cG9ydHNbJ1JTQS1TSEExJ10gPSB7XG4gIHNpZ246ICdyc2EnLFxuICBoYXNoOiAnc2hhMScsXG4gIGlkOiBuZXcgQnVmZmVyKCczMDIxMzAwOTA2MDUyYjBlMDMwMjFhMDUwMDA0MTQnLCAnaGV4Jylcbn1cbmV4cG9ydHNbJ2VjZHNhLXdpdGgtU0hBMSddID0ge1xuICBzaWduOiAnZWNkc2EnLFxuICBoYXNoOiAnc2hhMScsXG4gIGlkOiBuZXcgQnVmZmVyKCcnLCAnaGV4Jylcbn1cblxuZXhwb3J0cy5EU0EgPSBleHBvcnRzWydEU0EtU0hBMSddID0gZXhwb3J0c1snRFNBLVNIQSddID0ge1xuICBzaWduOiAnZHNhJyxcbiAgaGFzaDogJ3NoYTEnLFxuICBpZDogbmV3IEJ1ZmZlcignJywgJ2hleCcpXG59XG5leHBvcnRzWydEU0EtU0hBMjI0J10gPSBleHBvcnRzWydEU0EtV0lUSC1TSEEyMjQnXSA9IHtcbiAgc2lnbjogJ2RzYScsXG4gIGhhc2g6ICdzaGEyMjQnLFxuICBpZDogbmV3IEJ1ZmZlcignJywgJ2hleCcpXG59XG5leHBvcnRzWydEU0EtU0hBMjU2J10gPSBleHBvcnRzWydEU0EtV0lUSC1TSEEyNTYnXSA9IHtcbiAgc2lnbjogJ2RzYScsXG4gIGhhc2g6ICdzaGEyNTYnLFxuICBpZDogbmV3IEJ1ZmZlcignJywgJ2hleCcpXG59XG5leHBvcnRzWydEU0EtU0hBMzg0J10gPSBleHBvcnRzWydEU0EtV0lUSC1TSEEzODQnXSA9IHtcbiAgc2lnbjogJ2RzYScsXG4gIGhhc2g6ICdzaGEzODQnLFxuICBpZDogbmV3IEJ1ZmZlcignJywgJ2hleCcpXG59XG5leHBvcnRzWydEU0EtU0hBNTEyJ10gPSBleHBvcnRzWydEU0EtV0lUSC1TSEE1MTInXSA9IHtcbiAgc2lnbjogJ2RzYScsXG4gIGhhc2g6ICdzaGE1MTInLFxuICBpZDogbmV3IEJ1ZmZlcignJywgJ2hleCcpXG59XG5leHBvcnRzWydEU0EtUklQRU1EMTYwJ10gPSB7XG4gIHNpZ246ICdkc2EnLFxuICBoYXNoOiAncm1kMTYwJyxcbiAgaWQ6IG5ldyBCdWZmZXIoJycsICdoZXgnKVxufVxuZXhwb3J0c1snUlNBLVJJUEVNRDE2MCddID0gZXhwb3J0cy5yaXBlbWQxNjBXaXRoUlNBID0ge1xuICBzaWduOiAncnNhJyxcbiAgaGFzaDogJ3JtZDE2MCcsXG4gIGlkOiBuZXcgQnVmZmVyKCczMDIxMzAwOTA2MDUyYjI0MDMwMjAxMDUwMDA0MTQnLCAnaGV4Jylcbn1cbmV4cG9ydHNbJ1JTQS1NRDUnXSA9IGV4cG9ydHMubWQ1V2l0aFJTQUVuY3J5cHRpb24gPSB7XG4gIHNpZ246ICdyc2EnLFxuICBoYXNoOiAnbWQ1JyxcbiAgaWQ6IG5ldyBCdWZmZXIoJzMwMjAzMDBjMDYwODJhODY0ODg2ZjcwZDAyMDUwNTAwMDQxMCcsICdoZXgnKVxufVxuIiwidmFyIF9hbGdvcyA9IHJlcXVpcmUoJy4vYWxnb3MnKVxudmFyIGNyZWF0ZUhhc2ggPSByZXF1aXJlKCdjcmVhdGUtaGFzaCcpXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgc2lnbiA9IHJlcXVpcmUoJy4vc2lnbicpXG52YXIgc3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJylcbnZhciB2ZXJpZnkgPSByZXF1aXJlKCcuL3ZlcmlmeScpXG5cbnZhciBhbGdvcyA9IHt9XG5PYmplY3Qua2V5cyhfYWxnb3MpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBhbGdvc1trZXldID0gYWxnb3Nba2V5LnRvTG93ZXJDYXNlKCldID0gX2FsZ29zW2tleV1cbn0pXG5cbmZ1bmN0aW9uIFNpZ24gKGFsZ29yaXRobSkge1xuICBzdHJlYW0uV3JpdGFibGUuY2FsbCh0aGlzKVxuXG4gIHZhciBkYXRhID0gYWxnb3NbYWxnb3JpdGhtXVxuICBpZiAoIWRhdGEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gbWVzc2FnZSBkaWdlc3QnKVxuICB9XG5cbiAgdGhpcy5faGFzaFR5cGUgPSBkYXRhLmhhc2hcbiAgdGhpcy5faGFzaCA9IGNyZWF0ZUhhc2goZGF0YS5oYXNoKVxuICB0aGlzLl90YWcgPSBkYXRhLmlkXG4gIHRoaXMuX3NpZ25UeXBlID0gZGF0YS5zaWduXG59XG5pbmhlcml0cyhTaWduLCBzdHJlYW0uV3JpdGFibGUpXG5cblNpZ24ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIF93cml0ZSAoZGF0YSwgXywgZG9uZSkge1xuICB0aGlzLl9oYXNoLnVwZGF0ZShkYXRhKVxuICBkb25lKClcbn1cblxuU2lnbi5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlIChkYXRhLCBlbmMpIHtcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgIGRhdGEgPSBuZXcgQnVmZmVyKGRhdGEsIGVuYylcbiAgfVxuXG4gIHRoaXMuX2hhc2gudXBkYXRlKGRhdGEpXG4gIHJldHVybiB0aGlzXG59XG5cblNpZ24ucHJvdG90eXBlLnNpZ24gPSBmdW5jdGlvbiBzaWduTWV0aG9kIChrZXksIGVuYykge1xuICB0aGlzLmVuZCgpXG4gIHZhciBoYXNoID0gdGhpcy5faGFzaC5kaWdlc3QoKVxuICB2YXIgc2lnID0gc2lnbihCdWZmZXIuY29uY2F0KFt0aGlzLl90YWcsIGhhc2hdKSwga2V5LCB0aGlzLl9oYXNoVHlwZSwgdGhpcy5fc2lnblR5cGUpXG5cbiAgcmV0dXJuIGVuYyA/IHNpZy50b1N0cmluZyhlbmMpIDogc2lnXG59XG5cbmZ1bmN0aW9uIFZlcmlmeSAoYWxnb3JpdGhtKSB7XG4gIHN0cmVhbS5Xcml0YWJsZS5jYWxsKHRoaXMpXG5cbiAgdmFyIGRhdGEgPSBhbGdvc1thbGdvcml0aG1dXG4gIGlmICghZGF0YSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBtZXNzYWdlIGRpZ2VzdCcpXG4gIH1cblxuICB0aGlzLl9oYXNoID0gY3JlYXRlSGFzaChkYXRhLmhhc2gpXG4gIHRoaXMuX3RhZyA9IGRhdGEuaWRcbiAgdGhpcy5fc2lnblR5cGUgPSBkYXRhLnNpZ25cbn1cbmluaGVyaXRzKFZlcmlmeSwgc3RyZWFtLldyaXRhYmxlKVxuXG5WZXJpZnkucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIF93cml0ZSAoZGF0YSwgXywgZG9uZSkge1xuICB0aGlzLl9oYXNoLnVwZGF0ZShkYXRhKVxuXG4gIGRvbmUoKVxufVxuXG5WZXJpZnkucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAoZGF0YSwgZW5jKSB7XG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICBkYXRhID0gbmV3IEJ1ZmZlcihkYXRhLCBlbmMpXG4gIH1cblxuICB0aGlzLl9oYXNoLnVwZGF0ZShkYXRhKVxuICByZXR1cm4gdGhpc1xufVxuXG5WZXJpZnkucHJvdG90eXBlLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeU1ldGhvZCAoa2V5LCBzaWcsIGVuYykge1xuICBpZiAodHlwZW9mIHNpZyA9PT0gJ3N0cmluZycpIHtcbiAgICBzaWcgPSBuZXcgQnVmZmVyKHNpZywgZW5jKVxuICB9XG5cbiAgdGhpcy5lbmQoKVxuICB2YXIgaGFzaCA9IHRoaXMuX2hhc2guZGlnZXN0KClcblxuICByZXR1cm4gdmVyaWZ5KHNpZywgQnVmZmVyLmNvbmNhdChbdGhpcy5fdGFnLCBoYXNoXSksIGtleSwgdGhpcy5fc2lnblR5cGUpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVNpZ24gKGFsZ29yaXRobSkge1xuICByZXR1cm4gbmV3IFNpZ24oYWxnb3JpdGhtKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVWZXJpZnkgKGFsZ29yaXRobSkge1xuICByZXR1cm4gbmV3IFZlcmlmeShhbGdvcml0aG0pXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBTaWduOiBjcmVhdGVTaWduLFxuICBWZXJpZnk6IGNyZWF0ZVZlcmlmeSxcbiAgY3JlYXRlU2lnbjogY3JlYXRlU2lnbixcbiAgY3JlYXRlVmVyaWZ5OiBjcmVhdGVWZXJpZnlcbn1cbiIsIid1c2Ugc3RyaWN0J1xuZXhwb3J0c1snMS4zLjEzMi4wLjEwJ10gPSAnc2VjcDI1NmsxJ1xuXG5leHBvcnRzWycxLjMuMTMyLjAuMzMnXSA9ICdwMjI0J1xuXG5leHBvcnRzWycxLjIuODQwLjEwMDQ1LjMuMS4xJ10gPSAncDE5MidcblxuZXhwb3J0c1snMS4yLjg0MC4xMDA0NS4zLjEuNyddID0gJ3AyNTYnXG5cbmV4cG9ydHNbJzEuMy4xMzIuMC4zNCddID0gJ3AzODQnXG5cbmV4cG9ydHNbJzEuMy4xMzIuMC4zNSddID0gJ3A1MjEnXG4iLCIoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIFV0aWxzXG5cbmZ1bmN0aW9uIGFzc2VydCh2YWwsIG1zZykge1xuICBpZiAoIXZhbClcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnIHx8ICdBc3NlcnRpb24gZmFpbGVkJyk7XG59XG5cbi8vIENvdWxkIHVzZSBgaW5oZXJpdHNgIG1vZHVsZSwgYnV0IGRvbid0IHdhbnQgdG8gbW92ZSBmcm9tIHNpbmdsZSBmaWxlXG4vLyBhcmNoaXRlY3R1cmUgeWV0LlxuZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yO1xuICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fTtcbiAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZTtcbiAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKTtcbiAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yO1xufVxuXG4vLyBCTlxuXG5mdW5jdGlvbiBCTihudW1iZXIsIGJhc2UsIGVuZGlhbikge1xuICAvLyBNYXkgYmUgYG5ldyBCTihibilgID9cbiAgaWYgKG51bWJlciAhPT0gbnVsbCAmJlxuICAgICAgdHlwZW9mIG51bWJlciA9PT0gJ29iamVjdCcgJiZcbiAgICAgIEFycmF5LmlzQXJyYXkobnVtYmVyLndvcmRzKSkge1xuICAgIHJldHVybiBudW1iZXI7XG4gIH1cblxuICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgdGhpcy53b3JkcyA9IG51bGw7XG4gIHRoaXMubGVuZ3RoID0gMDtcblxuICAvLyBSZWR1Y3Rpb24gY29udGV4dFxuICB0aGlzLnJlZCA9IG51bGw7XG5cbiAgaWYgKG51bWJlciAhPT0gbnVsbCkge1xuICAgIGlmIChiYXNlID09PSAnbGUnIHx8IGJhc2UgPT09ICdiZScpIHtcbiAgICAgIGVuZGlhbiA9IGJhc2U7XG4gICAgICBiYXNlID0gMTA7XG4gICAgfVxuXG4gICAgdGhpcy5faW5pdChudW1iZXIgfHwgMCwgYmFzZSB8fCAxMCwgZW5kaWFuIHx8ICdiZScpO1xuICB9XG59XG5pZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG4gIG1vZHVsZS5leHBvcnRzID0gQk47XG5lbHNlXG4gIGV4cG9ydHMuQk4gPSBCTjtcblxuQk4uQk4gPSBCTjtcbkJOLndvcmRTaXplID0gMjY7XG5cbkJOLm1heCA9IGZ1bmN0aW9uIG1heChsZWZ0LCByaWdodCkge1xuICBpZiAobGVmdC5jbXAocmlnaHQpID4gMClcbiAgICByZXR1cm4gbGVmdDtcbiAgZWxzZVxuICAgIHJldHVybiByaWdodDtcbn07XG5cbkJOLm1pbiA9IGZ1bmN0aW9uIG1pbihsZWZ0LCByaWdodCkge1xuICBpZiAobGVmdC5jbXAocmlnaHQpIDwgMClcbiAgICByZXR1cm4gbGVmdDtcbiAgZWxzZVxuICAgIHJldHVybiByaWdodDtcbn07XG5cbkJOLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIGluaXQobnVtYmVyLCBiYXNlLCBlbmRpYW4pIHtcbiAgaWYgKHR5cGVvZiBudW1iZXIgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHRoaXMuX2luaXROdW1iZXIobnVtYmVyLCBiYXNlLCBlbmRpYW4pO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBudW1iZXIgPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIHRoaXMuX2luaXRBcnJheShudW1iZXIsIGJhc2UsIGVuZGlhbik7XG4gIH1cbiAgaWYgKGJhc2UgPT09ICdoZXgnKVxuICAgIGJhc2UgPSAxNjtcbiAgYXNzZXJ0KGJhc2UgPT09IChiYXNlIHwgMCkgJiYgYmFzZSA+PSAyICYmIGJhc2UgPD0gMzYpO1xuXG4gIG51bWJlciA9IG51bWJlci50b1N0cmluZygpLnJlcGxhY2UoL1xccysvZywgJycpO1xuICB2YXIgc3RhcnQgPSAwO1xuICBpZiAobnVtYmVyWzBdID09PSAnLScpXG4gICAgc3RhcnQrKztcblxuICBpZiAoYmFzZSA9PT0gMTYpXG4gICAgdGhpcy5fcGFyc2VIZXgobnVtYmVyLCBzdGFydCk7XG4gIGVsc2VcbiAgICB0aGlzLl9wYXJzZUJhc2UobnVtYmVyLCBiYXNlLCBzdGFydCk7XG5cbiAgaWYgKG51bWJlclswXSA9PT0gJy0nKVxuICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuXG4gIHRoaXMuc3RyaXAoKTtcblxuICBpZiAoZW5kaWFuICE9PSAnbGUnKVxuICAgIHJldHVybjtcblxuICB0aGlzLl9pbml0QXJyYXkodGhpcy50b0FycmF5KCksIGJhc2UsIGVuZGlhbik7XG59O1xuXG5CTi5wcm90b3R5cGUuX2luaXROdW1iZXIgPSBmdW5jdGlvbiBfaW5pdE51bWJlcihudW1iZXIsIGJhc2UsIGVuZGlhbikge1xuICBpZiAobnVtYmVyIDwgMCkge1xuICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgIG51bWJlciA9IC1udW1iZXI7XG4gIH1cbiAgaWYgKG51bWJlciA8IDB4NDAwMDAwMCkge1xuICAgIHRoaXMud29yZHMgPSBbIG51bWJlciAmIDB4M2ZmZmZmZiBdO1xuICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgfSBlbHNlIGlmIChudW1iZXIgPCAweDEwMDAwMDAwMDAwMDAwKSB7XG4gICAgdGhpcy53b3JkcyA9IFtcbiAgICAgIG51bWJlciAmIDB4M2ZmZmZmZixcbiAgICAgIChudW1iZXIgLyAweDQwMDAwMDApICYgMHgzZmZmZmZmXG4gICAgXTtcbiAgICB0aGlzLmxlbmd0aCA9IDI7XG4gIH0gZWxzZSB7XG4gICAgYXNzZXJ0KG51bWJlciA8IDB4MjAwMDAwMDAwMDAwMDApOyAvLyAyIF4gNTMgKHVuc2FmZSlcbiAgICB0aGlzLndvcmRzID0gW1xuICAgICAgbnVtYmVyICYgMHgzZmZmZmZmLFxuICAgICAgKG51bWJlciAvIDB4NDAwMDAwMCkgJiAweDNmZmZmZmYsXG4gICAgICAxXG4gICAgXTtcbiAgICB0aGlzLmxlbmd0aCA9IDM7XG4gIH1cblxuICBpZiAoZW5kaWFuICE9PSAnbGUnKVxuICAgIHJldHVybjtcblxuICAvLyBSZXZlcnNlIHRoZSBieXRlc1xuICB0aGlzLl9pbml0QXJyYXkodGhpcy50b0FycmF5KCksIGJhc2UsIGVuZGlhbik7XG59O1xuXG5CTi5wcm90b3R5cGUuX2luaXRBcnJheSA9IGZ1bmN0aW9uIF9pbml0QXJyYXkobnVtYmVyLCBiYXNlLCBlbmRpYW4pIHtcbiAgLy8gUGVyaGFwcyBhIFVpbnQ4QXJyYXlcbiAgYXNzZXJ0KHR5cGVvZiBudW1iZXIubGVuZ3RoID09PSAnbnVtYmVyJyk7XG4gIGlmIChudW1iZXIubGVuZ3RoIDw9IDApIHtcbiAgICB0aGlzLndvcmRzID0gWyAwIF07XG4gICAgdGhpcy5sZW5ndGggPSAxO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdGhpcy5sZW5ndGggPSBNYXRoLmNlaWwobnVtYmVyLmxlbmd0aCAvIDMpO1xuICB0aGlzLndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKVxuICAgIHRoaXMud29yZHNbaV0gPSAwO1xuXG4gIHZhciBvZmYgPSAwO1xuICBpZiAoZW5kaWFuID09PSAnYmUnKSB7XG4gICAgZm9yICh2YXIgaSA9IG51bWJlci5sZW5ndGggLSAxLCBqID0gMDsgaSA+PSAwOyBpIC09IDMpIHtcbiAgICAgIHZhciB3ID0gbnVtYmVyW2ldIHwgKG51bWJlcltpIC0gMV0gPDwgOCkgfCAobnVtYmVyW2kgLSAyXSA8PCAxNik7XG4gICAgICB0aGlzLndvcmRzW2pdIHw9ICh3IDw8IG9mZikgJiAweDNmZmZmZmY7XG4gICAgICB0aGlzLndvcmRzW2ogKyAxXSA9ICh3ID4+PiAoMjYgLSBvZmYpKSAmIDB4M2ZmZmZmZjtcbiAgICAgIG9mZiArPSAyNDtcbiAgICAgIGlmIChvZmYgPj0gMjYpIHtcbiAgICAgICAgb2ZmIC09IDI2O1xuICAgICAgICBqKys7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGVuZGlhbiA9PT0gJ2xlJykge1xuICAgIGZvciAodmFyIGkgPSAwLCBqID0gMDsgaSA8IG51bWJlci5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgdmFyIHcgPSBudW1iZXJbaV0gfCAobnVtYmVyW2kgKyAxXSA8PCA4KSB8IChudW1iZXJbaSArIDJdIDw8IDE2KTtcbiAgICAgIHRoaXMud29yZHNbal0gfD0gKHcgPDwgb2ZmKSAmIDB4M2ZmZmZmZjtcbiAgICAgIHRoaXMud29yZHNbaiArIDFdID0gKHcgPj4+ICgyNiAtIG9mZikpICYgMHgzZmZmZmZmO1xuICAgICAgb2ZmICs9IDI0O1xuICAgICAgaWYgKG9mZiA+PSAyNikge1xuICAgICAgICBvZmYgLT0gMjY7XG4gICAgICAgIGorKztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbn07XG5cbmZ1bmN0aW9uIHBhcnNlSGV4KHN0ciwgc3RhcnQsIGVuZCkge1xuICB2YXIgciA9IDA7XG4gIHZhciBsZW4gPSBNYXRoLm1pbihzdHIubGVuZ3RoLCBlbmQpO1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSkgLSA0ODtcblxuICAgIHIgPDw9IDQ7XG5cbiAgICAvLyAnYScgLSAnZidcbiAgICBpZiAoYyA+PSA0OSAmJiBjIDw9IDU0KVxuICAgICAgciB8PSBjIC0gNDkgKyAweGE7XG5cbiAgICAvLyAnQScgLSAnRidcbiAgICBlbHNlIGlmIChjID49IDE3ICYmIGMgPD0gMjIpXG4gICAgICByIHw9IGMgLSAxNyArIDB4YTtcblxuICAgIC8vICcwJyAtICc5J1xuICAgIGVsc2VcbiAgICAgIHIgfD0gYyAmIDB4ZjtcbiAgfVxuICByZXR1cm4gcjtcbn1cblxuQk4ucHJvdG90eXBlLl9wYXJzZUhleCA9IGZ1bmN0aW9uIF9wYXJzZUhleChudW1iZXIsIHN0YXJ0KSB7XG4gIC8vIENyZWF0ZSBwb3NzaWJseSBiaWdnZXIgYXJyYXkgdG8gZW5zdXJlIHRoYXQgaXQgZml0cyB0aGUgbnVtYmVyXG4gIHRoaXMubGVuZ3RoID0gTWF0aC5jZWlsKChudW1iZXIubGVuZ3RoIC0gc3RhcnQpIC8gNik7XG4gIHRoaXMud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspXG4gICAgdGhpcy53b3Jkc1tpXSA9IDA7XG5cbiAgLy8gU2NhbiAyNC1iaXQgY2h1bmtzIGFuZCBhZGQgdGhlbSB0byB0aGUgbnVtYmVyXG4gIHZhciBvZmYgPSAwO1xuICBmb3IgKHZhciBpID0gbnVtYmVyLmxlbmd0aCAtIDYsIGogPSAwOyBpID49IHN0YXJ0OyBpIC09IDYpIHtcbiAgICB2YXIgdyA9IHBhcnNlSGV4KG51bWJlciwgaSwgaSArIDYpO1xuICAgIHRoaXMud29yZHNbal0gfD0gKHcgPDwgb2ZmKSAmIDB4M2ZmZmZmZjtcbiAgICB0aGlzLndvcmRzW2ogKyAxXSB8PSB3ID4+PiAoMjYgLSBvZmYpICYgMHgzZmZmZmY7XG4gICAgb2ZmICs9IDI0O1xuICAgIGlmIChvZmYgPj0gMjYpIHtcbiAgICAgIG9mZiAtPSAyNjtcbiAgICAgIGorKztcbiAgICB9XG4gIH1cbiAgaWYgKGkgKyA2ICE9PSBzdGFydCkge1xuICAgIHZhciB3ID0gcGFyc2VIZXgobnVtYmVyLCBzdGFydCwgaSArIDYpO1xuICAgIHRoaXMud29yZHNbal0gfD0gKHcgPDwgb2ZmKSAmIDB4M2ZmZmZmZjtcbiAgICB0aGlzLndvcmRzW2ogKyAxXSB8PSB3ID4+PiAoMjYgLSBvZmYpICYgMHgzZmZmZmY7XG4gIH1cbiAgdGhpcy5zdHJpcCgpO1xufTtcblxuZnVuY3Rpb24gcGFyc2VCYXNlKHN0ciwgc3RhcnQsIGVuZCwgbXVsKSB7XG4gIHZhciByID0gMDtcbiAgdmFyIGxlbiA9IE1hdGgubWluKHN0ci5sZW5ndGgsIGVuZCk7XG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKSAtIDQ4O1xuXG4gICAgciAqPSBtdWw7XG5cbiAgICAvLyAnYSdcbiAgICBpZiAoYyA+PSA0OSlcbiAgICAgIHIgKz0gYyAtIDQ5ICsgMHhhO1xuXG4gICAgLy8gJ0EnXG4gICAgZWxzZSBpZiAoYyA+PSAxNylcbiAgICAgIHIgKz0gYyAtIDE3ICsgMHhhO1xuXG4gICAgLy8gJzAnIC0gJzknXG4gICAgZWxzZVxuICAgICAgciArPSBjO1xuICB9XG4gIHJldHVybiByO1xufVxuXG5CTi5wcm90b3R5cGUuX3BhcnNlQmFzZSA9IGZ1bmN0aW9uIF9wYXJzZUJhc2UobnVtYmVyLCBiYXNlLCBzdGFydCkge1xuICAvLyBJbml0aWFsaXplIGFzIHplcm9cbiAgdGhpcy53b3JkcyA9IFsgMCBdO1xuICB0aGlzLmxlbmd0aCA9IDE7XG5cbiAgLy8gRmluZCBsZW5ndGggb2YgbGltYiBpbiBiYXNlXG4gIGZvciAodmFyIGxpbWJMZW4gPSAwLCBsaW1iUG93ID0gMTsgbGltYlBvdyA8PSAweDNmZmZmZmY7IGxpbWJQb3cgKj0gYmFzZSlcbiAgICBsaW1iTGVuKys7XG4gIGxpbWJMZW4tLTtcbiAgbGltYlBvdyA9IChsaW1iUG93IC8gYmFzZSkgfCAwO1xuXG4gIHZhciB0b3RhbCA9IG51bWJlci5sZW5ndGggLSBzdGFydDtcbiAgdmFyIG1vZCA9IHRvdGFsICUgbGltYkxlbjtcbiAgdmFyIGVuZCA9IE1hdGgubWluKHRvdGFsLCB0b3RhbCAtIG1vZCkgKyBzdGFydDtcblxuICB2YXIgd29yZCA9IDA7XG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSBsaW1iTGVuKSB7XG4gICAgd29yZCA9IHBhcnNlQmFzZShudW1iZXIsIGksIGkgKyBsaW1iTGVuLCBiYXNlKTtcblxuICAgIHRoaXMuaW11bG4obGltYlBvdyk7XG4gICAgaWYgKHRoaXMud29yZHNbMF0gKyB3b3JkIDwgMHg0MDAwMDAwKVxuICAgICAgdGhpcy53b3Jkc1swXSArPSB3b3JkO1xuICAgIGVsc2VcbiAgICAgIHRoaXMuX2lhZGRuKHdvcmQpO1xuICB9XG5cbiAgaWYgKG1vZCAhPT0gMCkge1xuICAgIHZhciBwb3cgPSAxO1xuICAgIHZhciB3b3JkID0gcGFyc2VCYXNlKG51bWJlciwgaSwgbnVtYmVyLmxlbmd0aCwgYmFzZSk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1vZDsgaSsrKVxuICAgICAgcG93ICo9IGJhc2U7XG4gICAgdGhpcy5pbXVsbihwb3cpO1xuICAgIGlmICh0aGlzLndvcmRzWzBdICsgd29yZCA8IDB4NDAwMDAwMClcbiAgICAgIHRoaXMud29yZHNbMF0gKz0gd29yZDtcbiAgICBlbHNlXG4gICAgICB0aGlzLl9pYWRkbih3b3JkKTtcbiAgfVxufTtcblxuQk4ucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5KGRlc3QpIHtcbiAgZGVzdC53b3JkcyA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKylcbiAgICBkZXN0LndvcmRzW2ldID0gdGhpcy53b3Jkc1tpXTtcbiAgZGVzdC5sZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgZGVzdC5uZWdhdGl2ZSA9IHRoaXMubmVnYXRpdmU7XG4gIGRlc3QucmVkID0gdGhpcy5yZWQ7XG59O1xuXG5CTi5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgdmFyIHIgPSBuZXcgQk4obnVsbCk7XG4gIHRoaXMuY29weShyKTtcbiAgcmV0dXJuIHI7XG59O1xuXG4vLyBSZW1vdmUgbGVhZGluZyBgMGAgZnJvbSBgdGhpc2BcbkJOLnByb3RvdHlwZS5zdHJpcCA9IGZ1bmN0aW9uIHN0cmlwKCkge1xuICB3aGlsZSAodGhpcy5sZW5ndGggPiAxICYmIHRoaXMud29yZHNbdGhpcy5sZW5ndGggLSAxXSA9PT0gMClcbiAgICB0aGlzLmxlbmd0aC0tO1xuICByZXR1cm4gdGhpcy5fbm9ybVNpZ24oKTtcbn07XG5cbkJOLnByb3RvdHlwZS5fbm9ybVNpZ24gPSBmdW5jdGlvbiBfbm9ybVNpZ24oKSB7XG4gIC8vIC0wID0gMFxuICBpZiAodGhpcy5sZW5ndGggPT09IDEgJiYgdGhpcy53b3Jkc1swXSA9PT0gMClcbiAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5CTi5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QoKSB7XG4gIHJldHVybiAodGhpcy5yZWQgPyAnPEJOLVI6ICcgOiAnPEJOOiAnKSArIHRoaXMudG9TdHJpbmcoMTYpICsgJz4nO1xufTtcblxuLypcblxudmFyIHplcm9zID0gW107XG52YXIgZ3JvdXBTaXplcyA9IFtdO1xudmFyIGdyb3VwQmFzZXMgPSBbXTtcblxudmFyIHMgPSAnJztcbnZhciBpID0gLTE7XG53aGlsZSAoKytpIDwgQk4ud29yZFNpemUpIHtcbiAgemVyb3NbaV0gPSBzO1xuICBzICs9ICcwJztcbn1cbmdyb3VwU2l6ZXNbMF0gPSAwO1xuZ3JvdXBTaXplc1sxXSA9IDA7XG5ncm91cEJhc2VzWzBdID0gMDtcbmdyb3VwQmFzZXNbMV0gPSAwO1xudmFyIGJhc2UgPSAyIC0gMTtcbndoaWxlICgrK2Jhc2UgPCAzNiArIDEpIHtcbiAgdmFyIGdyb3VwU2l6ZSA9IDA7XG4gIHZhciBncm91cEJhc2UgPSAxO1xuICB3aGlsZSAoZ3JvdXBCYXNlIDwgKDEgPDwgQk4ud29yZFNpemUpIC8gYmFzZSkge1xuICAgIGdyb3VwQmFzZSAqPSBiYXNlO1xuICAgIGdyb3VwU2l6ZSArPSAxO1xuICB9XG4gIGdyb3VwU2l6ZXNbYmFzZV0gPSBncm91cFNpemU7XG4gIGdyb3VwQmFzZXNbYmFzZV0gPSBncm91cEJhc2U7XG59XG5cbiovXG5cbnZhciB6ZXJvcyA9IFtcbiAgJycsXG4gICcwJyxcbiAgJzAwJyxcbiAgJzAwMCcsXG4gICcwMDAwJyxcbiAgJzAwMDAwJyxcbiAgJzAwMDAwMCcsXG4gICcwMDAwMDAwJyxcbiAgJzAwMDAwMDAwJyxcbiAgJzAwMDAwMDAwMCcsXG4gICcwMDAwMDAwMDAwJyxcbiAgJzAwMDAwMDAwMDAwJyxcbiAgJzAwMDAwMDAwMDAwMCcsXG4gICcwMDAwMDAwMDAwMDAwJyxcbiAgJzAwMDAwMDAwMDAwMDAwJyxcbiAgJzAwMDAwMDAwMDAwMDAwMCcsXG4gICcwMDAwMDAwMDAwMDAwMDAwJyxcbiAgJzAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgJzAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICcwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJ1xuXTtcblxudmFyIGdyb3VwU2l6ZXMgPSBbXG4gIDAsIDAsXG4gIDI1LCAxNiwgMTIsIDExLCAxMCwgOSwgOCxcbiAgOCwgNywgNywgNywgNywgNiwgNixcbiAgNiwgNiwgNiwgNiwgNiwgNSwgNSxcbiAgNSwgNSwgNSwgNSwgNSwgNSwgNSxcbiAgNSwgNSwgNSwgNSwgNSwgNSwgNVxuXTtcblxudmFyIGdyb3VwQmFzZXMgPSBbXG4gIDAsIDAsXG4gIDMzNTU0NDMyLCA0MzA0NjcyMSwgMTY3NzcyMTYsIDQ4ODI4MTI1LCA2MDQ2NjE3NiwgNDAzNTM2MDcsIDE2Nzc3MjE2LFxuICA0MzA0NjcyMSwgMTAwMDAwMDAsIDE5NDg3MTcxLCAzNTgzMTgwOCwgNjI3NDg1MTcsIDc1Mjk1MzYsIDExMzkwNjI1LFxuICAxNjc3NzIxNiwgMjQxMzc1NjksIDM0MDEyMjI0LCA0NzA0NTg4MSwgNjQwMDAwMDAsIDQwODQxMDEsIDUxNTM2MzIsXG4gIDY0MzYzNDMsIDc5NjI2MjQsIDk3NjU2MjUsIDExODgxMzc2LCAxNDM0ODkwNywgMTcyMTAzNjgsIDIwNTExMTQ5LFxuICAyNDMwMDAwMCwgMjg2MjkxNTEsIDMzNTU0NDMyLCAzOTEzNTM5MywgNDU0MzU0MjQsIDUyNTIxODc1LCA2MDQ2NjE3NlxuXTtcblxuQk4ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoYmFzZSwgcGFkZGluZykge1xuICBiYXNlID0gYmFzZSB8fCAxMDtcbiAgdmFyIHBhZGRpbmcgPSBwYWRkaW5nIHwgMCB8fCAxO1xuICBpZiAoYmFzZSA9PT0gMTYgfHwgYmFzZSA9PT0gJ2hleCcpIHtcbiAgICB2YXIgb3V0ID0gJyc7XG4gICAgdmFyIG9mZiA9IDA7XG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB3ID0gdGhpcy53b3Jkc1tpXTtcbiAgICAgIHZhciB3b3JkID0gKCgodyA8PCBvZmYpIHwgY2FycnkpICYgMHhmZmZmZmYpLnRvU3RyaW5nKDE2KTtcbiAgICAgIGNhcnJ5ID0gKHcgPj4+ICgyNCAtIG9mZikpICYgMHhmZmZmZmY7XG4gICAgICBpZiAoY2FycnkgIT09IDAgfHwgaSAhPT0gdGhpcy5sZW5ndGggLSAxKVxuICAgICAgICBvdXQgPSB6ZXJvc1s2IC0gd29yZC5sZW5ndGhdICsgd29yZCArIG91dDtcbiAgICAgIGVsc2VcbiAgICAgICAgb3V0ID0gd29yZCArIG91dDtcbiAgICAgIG9mZiArPSAyO1xuICAgICAgaWYgKG9mZiA+PSAyNikge1xuICAgICAgICBvZmYgLT0gMjY7XG4gICAgICAgIGktLTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNhcnJ5ICE9PSAwKVxuICAgICAgb3V0ID0gY2FycnkudG9TdHJpbmcoMTYpICsgb3V0O1xuICAgIHdoaWxlIChvdXQubGVuZ3RoICUgcGFkZGluZyAhPT0gMClcbiAgICAgIG91dCA9ICcwJyArIG91dDtcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMClcbiAgICAgIG91dCA9ICctJyArIG91dDtcbiAgICByZXR1cm4gb3V0O1xuICB9IGVsc2UgaWYgKGJhc2UgPT09IChiYXNlIHwgMCkgJiYgYmFzZSA+PSAyICYmIGJhc2UgPD0gMzYpIHtcbiAgICAvLyB2YXIgZ3JvdXBTaXplID0gTWF0aC5mbG9vcihCTi53b3JkU2l6ZSAqIE1hdGguTE4yIC8gTWF0aC5sb2coYmFzZSkpO1xuICAgIHZhciBncm91cFNpemUgPSBncm91cFNpemVzW2Jhc2VdO1xuICAgIC8vIHZhciBncm91cEJhc2UgPSBNYXRoLnBvdyhiYXNlLCBncm91cFNpemUpO1xuICAgIHZhciBncm91cEJhc2UgPSBncm91cEJhc2VzW2Jhc2VdO1xuICAgIHZhciBvdXQgPSAnJztcbiAgICB2YXIgYyA9IHRoaXMuY2xvbmUoKTtcbiAgICBjLm5lZ2F0aXZlID0gMDtcbiAgICB3aGlsZSAoYy5jbXBuKDApICE9PSAwKSB7XG4gICAgICB2YXIgciA9IGMubW9kbihncm91cEJhc2UpLnRvU3RyaW5nKGJhc2UpO1xuICAgICAgYyA9IGMuaWRpdm4oZ3JvdXBCYXNlKTtcblxuICAgICAgaWYgKGMuY21wbigwKSAhPT0gMClcbiAgICAgICAgb3V0ID0gemVyb3NbZ3JvdXBTaXplIC0gci5sZW5ndGhdICsgciArIG91dDtcbiAgICAgIGVsc2VcbiAgICAgICAgb3V0ID0gciArIG91dDtcbiAgICB9XG4gICAgaWYgKHRoaXMuY21wbigwKSA9PT0gMClcbiAgICAgIG91dCA9ICcwJyArIG91dDtcbiAgICB3aGlsZSAob3V0Lmxlbmd0aCAlIHBhZGRpbmcgIT09IDApXG4gICAgICBvdXQgPSAnMCcgKyBvdXQ7XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApXG4gICAgICBvdXQgPSAnLScgKyBvdXQ7XG4gICAgcmV0dXJuIG91dDtcbiAgfSBlbHNlIHtcbiAgICBhc3NlcnQoZmFsc2UsICdCYXNlIHNob3VsZCBiZSBiZXR3ZWVuIDIgYW5kIDM2Jyk7XG4gIH1cbn07XG5cbkJOLnByb3RvdHlwZS50b051bWJlciA9IGZ1bmN0aW9uIHRvTnVtYmVyKCkge1xuICBhc3NlcnQodGhpcy5iaXRMZW5ndGgoKSA8PSA1MywgJ051bWJlciBjYW4gb25seSBzYWZlbHkgc3RvcmUgdXAgdG8gNTMgYml0cycpO1xuICByZXR1cm4gcGFyc2VJbnQodGhpcy50b1N0cmluZygpLCAxMCk7XG59O1xuXG5CTi5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICByZXR1cm4gdGhpcy50b1N0cmluZygxNik7XG59O1xuXG5CTi5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uIHRvQXJyYXkoZW5kaWFuLCBsZW5ndGgpIHtcbiAgdmFyIGJ5dGVMZW5ndGggPSB0aGlzLmJ5dGVMZW5ndGgoKTtcbiAgdmFyIHJlcUxlbmd0aCA9IGxlbmd0aCB8fCBieXRlTGVuZ3RoO1xuICBhc3NlcnQoYnl0ZUxlbmd0aCA8PSByZXFMZW5ndGgsICdieXRlIGFycmF5IGxvbmdlciB0aGFuIGRlc2lyZWQgbGVuZ3RoJyk7XG5cbiAgdGhpcy5zdHJpcCgpO1xuICB2YXIgbGl0dGxlRW5kaWFuID0gZW5kaWFuID09PSAnbGUnO1xuICB2YXIgcmVzID0gbmV3IEFycmF5KHJlcUxlbmd0aCk7XG5cbiAgdmFyIHEgPSB0aGlzLmNsb25lKCk7XG4gIGlmICghbGl0dGxlRW5kaWFuKSB7XG4gICAgLy8gQXNzdW1lIGJpZy1lbmRpYW5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlcUxlbmd0aCAtIGJ5dGVMZW5ndGg7IGkrKylcbiAgICAgIHJlc1tpXSA9IDA7XG4gICAgZm9yIChpID0gMDsgcS5jbXBuKDApICE9PSAwOyBpKyspIHtcbiAgICAgIHZhciBiID0gcS5hbmRsbigweGZmKTtcbiAgICAgIHEuaXVzaHJuKDgpO1xuXG4gICAgICByZXNbcmVxTGVuZ3RoIC0gaSAtIDFdID0gYjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IHEuY21wbigwKSAhPT0gMDsgaSsrKSB7XG4gICAgICB2YXIgYiA9IHEuYW5kbG4oMHhmZik7XG4gICAgICBxLml1c2hybig4KTtcblxuICAgICAgcmVzW2ldID0gYjtcbiAgICB9XG4gICAgZm9yICg7IGkgPCByZXFMZW5ndGg7IGkrKylcbiAgICAgIHJlc1tpXSA9IDA7XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblxuaWYgKE1hdGguY2x6MzIpIHtcbiAgQk4ucHJvdG90eXBlLl9jb3VudEJpdHMgPSBmdW5jdGlvbiBfY291bnRCaXRzKHcpIHtcbiAgICByZXR1cm4gMzIgLSBNYXRoLmNsejMyKHcpO1xuICB9O1xufSBlbHNlIHtcbiAgQk4ucHJvdG90eXBlLl9jb3VudEJpdHMgPSBmdW5jdGlvbiBfY291bnRCaXRzKHcpIHtcbiAgICB2YXIgdCA9IHc7XG4gICAgdmFyIHIgPSAwO1xuICAgIGlmICh0ID49IDB4MTAwMCkge1xuICAgICAgciArPSAxMztcbiAgICAgIHQgPj4+PSAxMztcbiAgICB9XG4gICAgaWYgKHQgPj0gMHg0MCkge1xuICAgICAgciArPSA3O1xuICAgICAgdCA+Pj49IDc7XG4gICAgfVxuICAgIGlmICh0ID49IDB4OCkge1xuICAgICAgciArPSA0O1xuICAgICAgdCA+Pj49IDQ7XG4gICAgfVxuICAgIGlmICh0ID49IDB4MDIpIHtcbiAgICAgIHIgKz0gMjtcbiAgICAgIHQgPj4+PSAyO1xuICAgIH1cbiAgICByZXR1cm4gciArIHQ7XG4gIH07XG59XG5cbkJOLnByb3RvdHlwZS5femVyb0JpdHMgPSBmdW5jdGlvbiBfemVyb0JpdHModykge1xuICAvLyBTaG9ydC1jdXRcbiAgaWYgKHcgPT09IDApXG4gICAgcmV0dXJuIDI2O1xuXG4gIHZhciB0ID0gdztcbiAgdmFyIHIgPSAwO1xuICBpZiAoKHQgJiAweDFmZmYpID09PSAwKSB7XG4gICAgciArPSAxMztcbiAgICB0ID4+Pj0gMTM7XG4gIH1cbiAgaWYgKCh0ICYgMHg3ZikgPT09IDApIHtcbiAgICByICs9IDc7XG4gICAgdCA+Pj49IDc7XG4gIH1cbiAgaWYgKCh0ICYgMHhmKSA9PT0gMCkge1xuICAgIHIgKz0gNDtcbiAgICB0ID4+Pj0gNDtcbiAgfVxuICBpZiAoKHQgJiAweDMpID09PSAwKSB7XG4gICAgciArPSAyO1xuICAgIHQgPj4+PSAyO1xuICB9XG4gIGlmICgodCAmIDB4MSkgPT09IDApXG4gICAgcisrO1xuICByZXR1cm4gcjtcbn07XG5cbi8vIFJldHVybiBudW1iZXIgb2YgdXNlZCBiaXRzIGluIGEgQk5cbkJOLnByb3RvdHlwZS5iaXRMZW5ndGggPSBmdW5jdGlvbiBiaXRMZW5ndGgoKSB7XG4gIHZhciBoaSA9IDA7XG4gIHZhciB3ID0gdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCAtIDFdO1xuICB2YXIgaGkgPSB0aGlzLl9jb3VudEJpdHModyk7XG4gIHJldHVybiAodGhpcy5sZW5ndGggLSAxKSAqIDI2ICsgaGk7XG59O1xuXG5mdW5jdGlvbiB0b0JpdEFycmF5KG51bSkge1xuICB2YXIgdyA9IG5ldyBBcnJheShudW0uYml0TGVuZ3RoKCkpO1xuXG4gIGZvciAodmFyIGJpdCA9IDA7IGJpdCA8IHcubGVuZ3RoOyBiaXQrKykge1xuICAgIHZhciBvZmYgPSAoYml0IC8gMjYpIHwgMDtcbiAgICB2YXIgd2JpdCA9IGJpdCAlIDI2O1xuXG4gICAgd1tiaXRdID0gKG51bS53b3Jkc1tvZmZdICYgKDEgPDwgd2JpdCkpID4+PiB3Yml0O1xuICB9XG5cbiAgcmV0dXJuIHc7XG59XG5cbi8vIE51bWJlciBvZiB0cmFpbGluZyB6ZXJvIGJpdHNcbkJOLnByb3RvdHlwZS56ZXJvQml0cyA9IGZ1bmN0aW9uIHplcm9CaXRzKCkge1xuICBpZiAodGhpcy5jbXBuKDApID09PSAwKVxuICAgIHJldHVybiAwO1xuXG4gIHZhciByID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGIgPSB0aGlzLl96ZXJvQml0cyh0aGlzLndvcmRzW2ldKTtcbiAgICByICs9IGI7XG4gICAgaWYgKGIgIT09IDI2KVxuICAgICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIHI7XG59O1xuXG5CTi5wcm90b3R5cGUuYnl0ZUxlbmd0aCA9IGZ1bmN0aW9uIGJ5dGVMZW5ndGgoKSB7XG4gIHJldHVybiBNYXRoLmNlaWwodGhpcy5iaXRMZW5ndGgoKSAvIDgpO1xufTtcblxuQk4ucHJvdG90eXBlLmlzTmVnID0gZnVuY3Rpb24gaXNOZWcoKSB7XG4gIHJldHVybiB0aGlzLm5lZ2F0aXZlICE9PSAwO1xufTtcblxuLy8gUmV0dXJuIG5lZ2F0aXZlIGNsb25lIG9mIGB0aGlzYFxuQk4ucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uIG5lZygpIHtcbiAgaWYgKHRoaXMuY21wbigwKSA9PT0gMClcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpO1xuXG4gIHZhciByID0gdGhpcy5jbG9uZSgpO1xuICByLm5lZ2F0aXZlID0gdGhpcy5uZWdhdGl2ZSBeIDE7XG4gIHJldHVybiByO1xufTtcblxuQk4ucHJvdG90eXBlLmluZWcgPSBmdW5jdGlvbiBpbmVnKCkge1xuICB0aGlzLm5lZ2F0aXZlIF49IDE7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gT3IgYG51bWAgd2l0aCBgdGhpc2AgaW4tcGxhY2VcbkJOLnByb3RvdHlwZS5pdW9yID0gZnVuY3Rpb24gaXVvcihudW0pIHtcbiAgd2hpbGUgKHRoaXMubGVuZ3RoIDwgbnVtLmxlbmd0aClcbiAgICB0aGlzLndvcmRzW3RoaXMubGVuZ3RoKytdID0gMDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG51bS5sZW5ndGg7IGkrKylcbiAgICB0aGlzLndvcmRzW2ldID0gdGhpcy53b3Jkc1tpXSB8IG51bS53b3Jkc1tpXTtcblxuICByZXR1cm4gdGhpcy5zdHJpcCgpO1xufTtcblxuQk4ucHJvdG90eXBlLmlvciA9IGZ1bmN0aW9uIGlvcihudW0pIHtcbiAgYXNzZXJ0KCh0aGlzLm5lZ2F0aXZlIHwgbnVtLm5lZ2F0aXZlKSA9PT0gMCk7XG4gIHJldHVybiB0aGlzLml1b3IobnVtKTtcbn07XG5cblxuLy8gT3IgYG51bWAgd2l0aCBgdGhpc2BcbkJOLnByb3RvdHlwZS5vciA9IGZ1bmN0aW9uIG9yKG51bSkge1xuICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKVxuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaW9yKG51bSk7XG4gIGVsc2VcbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaW9yKHRoaXMpO1xufTtcblxuQk4ucHJvdG90eXBlLnVvciA9IGZ1bmN0aW9uIHVvcihudW0pIHtcbiAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aClcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLml1b3IobnVtKTtcbiAgZWxzZVxuICAgIHJldHVybiBudW0uY2xvbmUoKS5pdW9yKHRoaXMpO1xufTtcblxuXG4vLyBBbmQgYG51bWAgd2l0aCBgdGhpc2AgaW4tcGxhY2VcbkJOLnByb3RvdHlwZS5pdWFuZCA9IGZ1bmN0aW9uIGl1YW5kKG51bSkge1xuICAvLyBiID0gbWluLWxlbmd0aChudW0sIHRoaXMpXG4gIHZhciBiO1xuICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKVxuICAgIGIgPSBudW07XG4gIGVsc2VcbiAgICBiID0gdGhpcztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspXG4gICAgdGhpcy53b3Jkc1tpXSA9IHRoaXMud29yZHNbaV0gJiBudW0ud29yZHNbaV07XG5cbiAgdGhpcy5sZW5ndGggPSBiLmxlbmd0aDtcblxuICByZXR1cm4gdGhpcy5zdHJpcCgpO1xufTtcblxuQk4ucHJvdG90eXBlLmlhbmQgPSBmdW5jdGlvbiBpYW5kKG51bSkge1xuICBhc3NlcnQoKHRoaXMubmVnYXRpdmUgfCBudW0ubmVnYXRpdmUpID09PSAwKTtcbiAgcmV0dXJuIHRoaXMuaXVhbmQobnVtKTtcbn07XG5cblxuLy8gQW5kIGBudW1gIHdpdGggYHRoaXNgXG5CTi5wcm90b3R5cGUuYW5kID0gZnVuY3Rpb24gYW5kKG51bSkge1xuICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKVxuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaWFuZChudW0pO1xuICBlbHNlXG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLmlhbmQodGhpcyk7XG59O1xuXG5CTi5wcm90b3R5cGUudWFuZCA9IGZ1bmN0aW9uIHVhbmQobnVtKSB7XG4gIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpXG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pdWFuZChudW0pO1xuICBlbHNlXG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLml1YW5kKHRoaXMpO1xufTtcblxuXG4vLyBYb3IgYG51bWAgd2l0aCBgdGhpc2AgaW4tcGxhY2VcbkJOLnByb3RvdHlwZS5pdXhvciA9IGZ1bmN0aW9uIGl1eG9yKG51bSkge1xuICAvLyBhLmxlbmd0aCA+IGIubGVuZ3RoXG4gIHZhciBhO1xuICB2YXIgYjtcbiAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkge1xuICAgIGEgPSB0aGlzO1xuICAgIGIgPSBudW07XG4gIH0gZWxzZSB7XG4gICAgYSA9IG51bTtcbiAgICBiID0gdGhpcztcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKylcbiAgICB0aGlzLndvcmRzW2ldID0gYS53b3Jkc1tpXSBeIGIud29yZHNbaV07XG5cbiAgaWYgKHRoaXMgIT09IGEpXG4gICAgZm9yICg7IGkgPCBhLmxlbmd0aDsgaSsrKVxuICAgICAgdGhpcy53b3Jkc1tpXSA9IGEud29yZHNbaV07XG5cbiAgdGhpcy5sZW5ndGggPSBhLmxlbmd0aDtcblxuICByZXR1cm4gdGhpcy5zdHJpcCgpO1xufTtcblxuQk4ucHJvdG90eXBlLml4b3IgPSBmdW5jdGlvbiBpeG9yKG51bSkge1xuICBhc3NlcnQoKHRoaXMubmVnYXRpdmUgfCBudW0ubmVnYXRpdmUpID09PSAwKTtcbiAgcmV0dXJuIHRoaXMuaXV4b3IobnVtKTtcbn07XG5cblxuLy8gWG9yIGBudW1gIHdpdGggYHRoaXNgXG5CTi5wcm90b3R5cGUueG9yID0gZnVuY3Rpb24geG9yKG51bSkge1xuICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKVxuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXhvcihudW0pO1xuICBlbHNlXG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLml4b3IodGhpcyk7XG59O1xuXG5CTi5wcm90b3R5cGUudXhvciA9IGZ1bmN0aW9uIHV4b3IobnVtKSB7XG4gIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpXG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pdXhvcihudW0pO1xuICBlbHNlXG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLml1eG9yKHRoaXMpO1xufTtcblxuXG4vLyBTZXQgYGJpdGAgb2YgYHRoaXNgXG5CTi5wcm90b3R5cGUuc2V0biA9IGZ1bmN0aW9uIHNldG4oYml0LCB2YWwpIHtcbiAgYXNzZXJ0KHR5cGVvZiBiaXQgPT09ICdudW1iZXInICYmIGJpdCA+PSAwKTtcblxuICB2YXIgb2ZmID0gKGJpdCAvIDI2KSB8IDA7XG4gIHZhciB3Yml0ID0gYml0ICUgMjY7XG5cbiAgd2hpbGUgKHRoaXMubGVuZ3RoIDw9IG9mZilcbiAgICB0aGlzLndvcmRzW3RoaXMubGVuZ3RoKytdID0gMDtcblxuICBpZiAodmFsKVxuICAgIHRoaXMud29yZHNbb2ZmXSA9IHRoaXMud29yZHNbb2ZmXSB8ICgxIDw8IHdiaXQpO1xuICBlbHNlXG4gICAgdGhpcy53b3Jkc1tvZmZdID0gdGhpcy53b3Jkc1tvZmZdICYgfigxIDw8IHdiaXQpO1xuXG4gIHJldHVybiB0aGlzLnN0cmlwKCk7XG59O1xuXG5cbi8vIEFkZCBgbnVtYCB0byBgdGhpc2AgaW4tcGxhY2VcbkJOLnByb3RvdHlwZS5pYWRkID0gZnVuY3Rpb24gaWFkZChudW0pIHtcbiAgLy8gbmVnYXRpdmUgKyBwb3NpdGl2ZVxuICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCAmJiBudW0ubmVnYXRpdmUgPT09IDApIHtcbiAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICB2YXIgciA9IHRoaXMuaXN1YihudW0pO1xuICAgIHRoaXMubmVnYXRpdmUgXj0gMTtcbiAgICByZXR1cm4gdGhpcy5fbm9ybVNpZ24oKTtcblxuICAvLyBwb3NpdGl2ZSArIG5lZ2F0aXZlXG4gIH0gZWxzZSBpZiAodGhpcy5uZWdhdGl2ZSA9PT0gMCAmJiBudW0ubmVnYXRpdmUgIT09IDApIHtcbiAgICBudW0ubmVnYXRpdmUgPSAwO1xuICAgIHZhciByID0gdGhpcy5pc3ViKG51bSk7XG4gICAgbnVtLm5lZ2F0aXZlID0gMTtcbiAgICByZXR1cm4gci5fbm9ybVNpZ24oKTtcbiAgfVxuXG4gIC8vIGEubGVuZ3RoID4gYi5sZW5ndGhcbiAgdmFyIGE7XG4gIHZhciBiO1xuICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSB7XG4gICAgYSA9IHRoaXM7XG4gICAgYiA9IG51bTtcbiAgfSBlbHNlIHtcbiAgICBhID0gbnVtO1xuICAgIGIgPSB0aGlzO1xuICB9XG5cbiAgdmFyIGNhcnJ5ID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHIgPSAoYS53b3Jkc1tpXSB8IDApICsgKGIud29yZHNbaV0gfCAwKSArIGNhcnJ5O1xuICAgIHRoaXMud29yZHNbaV0gPSByICYgMHgzZmZmZmZmO1xuICAgIGNhcnJ5ID0gciA+Pj4gMjY7XG4gIH1cbiAgZm9yICg7IGNhcnJ5ICE9PSAwICYmIGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHIgPSAoYS53b3Jkc1tpXSB8IDApICsgY2Fycnk7XG4gICAgdGhpcy53b3Jkc1tpXSA9IHIgJiAweDNmZmZmZmY7XG4gICAgY2FycnkgPSByID4+PiAyNjtcbiAgfVxuXG4gIHRoaXMubGVuZ3RoID0gYS5sZW5ndGg7XG4gIGlmIChjYXJyeSAhPT0gMCkge1xuICAgIHRoaXMud29yZHNbdGhpcy5sZW5ndGhdID0gY2Fycnk7XG4gICAgdGhpcy5sZW5ndGgrKztcbiAgLy8gQ29weSB0aGUgcmVzdCBvZiB0aGUgd29yZHNcbiAgfSBlbHNlIGlmIChhICE9PSB0aGlzKSB7XG4gICAgZm9yICg7IGkgPCBhLmxlbmd0aDsgaSsrKVxuICAgICAgdGhpcy53b3Jkc1tpXSA9IGEud29yZHNbaV07XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIEFkZCBgbnVtYCB0byBgdGhpc2BcbkJOLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQobnVtKSB7XG4gIGlmIChudW0ubmVnYXRpdmUgIT09IDAgJiYgdGhpcy5uZWdhdGl2ZSA9PT0gMCkge1xuICAgIG51bS5uZWdhdGl2ZSA9IDA7XG4gICAgdmFyIHJlcyA9IHRoaXMuc3ViKG51bSk7XG4gICAgbnVtLm5lZ2F0aXZlIF49IDE7XG4gICAgcmV0dXJuIHJlcztcbiAgfSBlbHNlIGlmIChudW0ubmVnYXRpdmUgPT09IDAgJiYgdGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgIHZhciByZXMgPSBudW0uc3ViKHRoaXMpO1xuICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgIHJldHVybiByZXM7XG4gIH1cblxuICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKVxuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaWFkZChudW0pO1xuICBlbHNlXG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLmlhZGQodGhpcyk7XG59O1xuXG4vLyBTdWJ0cmFjdCBgbnVtYCBmcm9tIGB0aGlzYCBpbi1wbGFjZVxuQk4ucHJvdG90eXBlLmlzdWIgPSBmdW5jdGlvbiBpc3ViKG51bSkge1xuICAvLyB0aGlzIC0gKC1udW0pID0gdGhpcyArIG51bVxuICBpZiAobnVtLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgbnVtLm5lZ2F0aXZlID0gMDtcbiAgICB2YXIgciA9IHRoaXMuaWFkZChudW0pO1xuICAgIG51bS5uZWdhdGl2ZSA9IDE7XG4gICAgcmV0dXJuIHIuX25vcm1TaWduKCk7XG5cbiAgLy8gLXRoaXMgLSBudW0gPSAtKHRoaXMgKyBudW0pXG4gIH0gZWxzZSBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgIHRoaXMuaWFkZChudW0pO1xuICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgIHJldHVybiB0aGlzLl9ub3JtU2lnbigpO1xuICB9XG5cbiAgLy8gQXQgdGhpcyBwb2ludCBib3RoIG51bWJlcnMgYXJlIHBvc2l0aXZlXG4gIHZhciBjbXAgPSB0aGlzLmNtcChudW0pO1xuXG4gIC8vIE9wdGltaXphdGlvbiAtIHplcm9pZnlcbiAgaWYgKGNtcCA9PT0gMCkge1xuICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICB0aGlzLndvcmRzWzBdID0gMDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGEgPiBiXG4gIHZhciBhO1xuICB2YXIgYjtcbiAgaWYgKGNtcCA+IDApIHtcbiAgICBhID0gdGhpcztcbiAgICBiID0gbnVtO1xuICB9IGVsc2Uge1xuICAgIGEgPSBudW07XG4gICAgYiA9IHRoaXM7XG4gIH1cblxuICB2YXIgY2FycnkgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgciA9IChhLndvcmRzW2ldIHwgMCkgLSAoYi53b3Jkc1tpXSB8IDApICsgY2Fycnk7XG4gICAgY2FycnkgPSByID4+IDI2O1xuICAgIHRoaXMud29yZHNbaV0gPSByICYgMHgzZmZmZmZmO1xuICB9XG4gIGZvciAoOyBjYXJyeSAhPT0gMCAmJiBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgIHZhciByID0gKGEud29yZHNbaV0gfCAwKSArIGNhcnJ5O1xuICAgIGNhcnJ5ID0gciA+PiAyNjtcbiAgICB0aGlzLndvcmRzW2ldID0gciAmIDB4M2ZmZmZmZjtcbiAgfVxuXG4gIC8vIENvcHkgcmVzdCBvZiB0aGUgd29yZHNcbiAgaWYgKGNhcnJ5ID09PSAwICYmIGkgPCBhLmxlbmd0aCAmJiBhICE9PSB0aGlzKVxuICAgIGZvciAoOyBpIDwgYS5sZW5ndGg7IGkrKylcbiAgICAgIHRoaXMud29yZHNbaV0gPSBhLndvcmRzW2ldO1xuICB0aGlzLmxlbmd0aCA9IE1hdGgubWF4KHRoaXMubGVuZ3RoLCBpKTtcblxuICBpZiAoYSAhPT0gdGhpcylcbiAgICB0aGlzLm5lZ2F0aXZlID0gMTtcblxuICByZXR1cm4gdGhpcy5zdHJpcCgpO1xufTtcblxuLy8gU3VidHJhY3QgYG51bWAgZnJvbSBgdGhpc2BcbkJOLnByb3RvdHlwZS5zdWIgPSBmdW5jdGlvbiBzdWIobnVtKSB7XG4gIHJldHVybiB0aGlzLmNsb25lKCkuaXN1YihudW0pO1xufTtcblxuLypcbi8vIE5PVEU6IFRoaXMgY291bGQgYmUgcG90ZW50aW9uYWxseSB1c2VkIHRvIGdlbmVyYXRlIGxvb3AtbGVzcyBtdWx0aXBsaWNhdGlvbnNcbmZ1bmN0aW9uIF9nZW5Db21iTXVsVG8oYWxlbiwgYmxlbikge1xuICB2YXIgbGVuID0gYWxlbiArIGJsZW4gLSAxO1xuICB2YXIgc3JjID0gW1xuICAgICd2YXIgYSA9IHNlbGYud29yZHM7JyxcbiAgICAndmFyIGIgPSBudW0ud29yZHM7JyxcbiAgICAndmFyIG8gPSBvdXQud29yZHM7JyxcbiAgICAndmFyIGMgPSAwOycsXG4gICAgJ3ZhciBsbzsnLFxuICAgICd2YXIgbWlkOycsXG4gICAgJ3ZhciBoaTsnXG4gIF07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYWxlbjsgaSsrKSB7XG4gICAgc3JjLnB1c2goJ3ZhciBhJyArIGkgKyAnID0gYVsnICsgaSArICddIHwgMDsnKTtcbiAgICBzcmMucHVzaCgndmFyIGFsJyArIGkgKyAnID0gYScgKyBpICsgJyAmIDB4MWZmZjsnKTtcbiAgICBzcmMucHVzaCgndmFyIGFoJyArIGkgKyAnID0gYScgKyBpICsgJyA+Pj4gMTM7Jyk7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBibGVuOyBpKyspIHtcbiAgICBzcmMucHVzaCgndmFyIGInICsgaSArICcgPSBiWycgKyBpICsgJ10gfCAwOycpO1xuICAgIHNyYy5wdXNoKCd2YXIgYmwnICsgaSArICcgPSBiJyArIGkgKyAnICYgMHgxZmZmOycpO1xuICAgIHNyYy5wdXNoKCd2YXIgYmgnICsgaSArICcgPSBiJyArIGkgKyAnID4+PiAxMzsnKTtcbiAgfVxuICBzcmMucHVzaCgnJyk7XG4gIHNyYy5wdXNoKCdvdXQubGVuZ3RoID0gJyArIGxlbiArICc7Jyk7XG5cbiAgZm9yICh2YXIgayA9IDA7IGsgPCBsZW47IGsrKykge1xuICAgIHZhciBtaW5KID0gTWF0aC5tYXgoMCwgayAtIGFsZW4gKyAxKTtcbiAgICB2YXIgbWF4SiA9IE1hdGgubWluKGssIGJsZW4gLSAxKTtcblxuICAgIHNyYy5wdXNoKCdcXC8qIGsgPSAnICsgayArICcgKlxcLycpO1xuICAgIHNyYy5wdXNoKCd2YXIgdycgKyBrICsgJyA9IGM7Jyk7XG4gICAgc3JjLnB1c2goJ2MgPSAwOycpO1xuICAgIGZvciAodmFyIGogPSBtaW5KOyBqIDw9IG1heEo7IGorKykge1xuICAgICAgdmFyIGkgPSBrIC0gajtcblxuICAgICAgc3JjLnB1c2goJ2xvID0gTWF0aC5pbXVsKGFsJyArIGkgKyAnLCBibCcgKyBqICsgJyk7Jyk7XG4gICAgICBzcmMucHVzaCgnbWlkID0gTWF0aC5pbXVsKGFsJyArIGkgKyAnLCBiaCcgKyBqICsgJyk7Jyk7XG4gICAgICBzcmMucHVzaCgnbWlkID0gKG1pZCArIE1hdGguaW11bChhaCcgKyBpICsgJywgYmwnICsgaiArICcpKSB8IDA7Jyk7XG4gICAgICBzcmMucHVzaCgnaGkgPSBNYXRoLmltdWwoYWgnICsgaSArICcsIGJoJyArIGogKyAnKTsnKTtcblxuICAgICAgc3JjLnB1c2goJ3cnICsgayArICcgPSAodycgKyBrICsgJyArIGxvKSB8IDA7Jyk7XG4gICAgICBzcmMucHVzaCgndycgKyBrICsgJyA9ICh3JyArIGsgKyAnICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwOycpO1xuICAgICAgc3JjLnB1c2goJ2MgPSAoYyArIGhpKSB8IDA7Jyk7XG4gICAgICBzcmMucHVzaCgnYyA9IChjICsgKG1pZCA+Pj4gMTMpKSB8IDA7Jyk7XG4gICAgICBzcmMucHVzaCgnYyA9IChjICsgKHcnICsgayArICcgPj4+IDI2KSkgfCAwOycpO1xuICAgICAgc3JjLnB1c2goJ3cnICsgayArICcgJj0gMHgzZmZmZmZmOycpO1xuICAgIH1cbiAgfVxuICAvLyBTdG9yZSBpbiBzZXBhcmF0ZSBzdGVwIGZvciBiZXR0ZXIgbWVtb3J5IGFjY2Vzc1xuICBmb3IgKHZhciBrID0gMDsgayA8IGxlbjsgaysrKVxuICAgIHNyYy5wdXNoKCdvWycgKyBrICsgJ10gPSB3JyArIGsgKyAnOycpO1xuICBzcmMucHVzaCgnaWYgKGMgIT09IDApIHsnLFxuICAgICAgICAgICAnICBvWycgKyBrICsgJ10gPSBjOycsXG4gICAgICAgICAgICcgIG91dC5sZW5ndGgrKzsnLFxuICAgICAgICAgICAnfScsXG4gICAgICAgICAgICdyZXR1cm4gb3V0OycpO1xuXG4gIHJldHVybiBzcmMuam9pbignXFxuJyk7XG59XG5jb25zb2xlLmxvZyhfZ2VuQ29tYk11bFRvKDEwLCAxMCkpO1xuKi9cblxuZnVuY3Rpb24gc21hbGxNdWxUbyhzZWxmLCBudW0sIG91dCkge1xuICBvdXQubmVnYXRpdmUgPSBudW0ubmVnYXRpdmUgXiBzZWxmLm5lZ2F0aXZlO1xuICB2YXIgbGVuID0gKHNlbGYubGVuZ3RoICsgbnVtLmxlbmd0aCkgfCAwO1xuICBvdXQubGVuZ3RoID0gbGVuO1xuICBsZW4gPSAobGVuIC0gMSkgfCAwO1xuXG4gIC8vIFBlZWwgb25lIGl0ZXJhdGlvbiAoY29tcGlsZXIgY2FuJ3QgZG8gaXQsIGJlY2F1c2Ugb2YgY29kZSBjb21wbGV4aXR5KVxuICB2YXIgYSA9IHNlbGYud29yZHNbMF0gfCAwO1xuICB2YXIgYiA9IG51bS53b3Jkc1swXSB8IDA7XG4gIHZhciByID0gYSAqIGI7XG5cbiAgdmFyIGxvID0gciAmIDB4M2ZmZmZmZjtcbiAgdmFyIGNhcnJ5ID0gKHIgLyAweDQwMDAwMDApIHwgMDtcbiAgb3V0LndvcmRzWzBdID0gbG87XG5cbiAgZm9yICh2YXIgayA9IDE7IGsgPCBsZW47IGsrKykge1xuICAgIC8vIFN1bSBhbGwgd29yZHMgd2l0aCB0aGUgc2FtZSBgaSArIGogPSBrYCBhbmQgYWNjdW11bGF0ZSBgbmNhcnJ5YCxcbiAgICAvLyBub3RlIHRoYXQgbmNhcnJ5IGNvdWxkIGJlID49IDB4M2ZmZmZmZlxuICAgIHZhciBuY2FycnkgPSBjYXJyeSA+Pj4gMjY7XG4gICAgdmFyIHJ3b3JkID0gY2FycnkgJiAweDNmZmZmZmY7XG4gICAgdmFyIG1heEogPSBNYXRoLm1pbihrLCBudW0ubGVuZ3RoIC0gMSk7XG4gICAgZm9yICh2YXIgaiA9IE1hdGgubWF4KDAsIGsgLSBzZWxmLmxlbmd0aCArIDEpOyBqIDw9IG1heEo7IGorKykge1xuICAgICAgdmFyIGkgPSAoayAtIGopIHwgMDtcbiAgICAgIHZhciBhID0gc2VsZi53b3Jkc1tpXSB8IDA7XG4gICAgICB2YXIgYiA9IG51bS53b3Jkc1tqXSB8IDA7XG4gICAgICB2YXIgciA9IGEgKiBiO1xuXG4gICAgICB2YXIgbG8gPSByICYgMHgzZmZmZmZmO1xuICAgICAgbmNhcnJ5ID0gKG5jYXJyeSArICgociAvIDB4NDAwMDAwMCkgfCAwKSkgfCAwO1xuICAgICAgbG8gPSAobG8gKyByd29yZCkgfCAwO1xuICAgICAgcndvcmQgPSBsbyAmIDB4M2ZmZmZmZjtcbiAgICAgIG5jYXJyeSA9IChuY2FycnkgKyAobG8gPj4+IDI2KSkgfCAwO1xuICAgIH1cbiAgICBvdXQud29yZHNba10gPSByd29yZCB8IDA7XG4gICAgY2FycnkgPSBuY2FycnkgfCAwO1xuICB9XG4gIGlmIChjYXJyeSAhPT0gMCkge1xuICAgIG91dC53b3Jkc1trXSA9IGNhcnJ5IHwgMDtcbiAgfSBlbHNlIHtcbiAgICBvdXQubGVuZ3RoLS07XG4gIH1cblxuICByZXR1cm4gb3V0LnN0cmlwKCk7XG59XG5cbi8vIFRPRE8oaW5kdXRueSk6IGl0IG1heSBiZSByZWFzb25hYmxlIHRvIG9taXQgaXQgZm9yIHVzZXJzIHdobyBkb24ndCBuZWVkXG4vLyB0byB3b3JrIHdpdGggMjU2LWJpdCBudW1iZXJzLCBvdGhlcndpc2UgaXQgZ2l2ZXMgMjAlIGltcHJvdmVtZW50IGZvciAyNTYtYml0XG4vLyBtdWx0aXBsaWNhdGlvbiAobGlrZSBlbGxpcHRpYyBzZWNwMjU2azEpLlxudmFyIGNvbWIxME11bFRvID0gZnVuY3Rpb24gY29tYjEwTXVsVG8oc2VsZiwgbnVtLCBvdXQpIHtcbiAgdmFyIGEgPSBzZWxmLndvcmRzO1xuICB2YXIgYiA9IG51bS53b3JkcztcbiAgdmFyIG8gPSBvdXQud29yZHM7XG4gIHZhciBjID0gMDtcbiAgdmFyIGxvO1xuICB2YXIgbWlkO1xuICB2YXIgaGk7XG4gIHZhciBhMCA9IGFbMF0gfCAwO1xuICB2YXIgYWwwID0gYTAgJiAweDFmZmY7XG4gIHZhciBhaDAgPSBhMCA+Pj4gMTM7XG4gIHZhciBhMSA9IGFbMV0gfCAwO1xuICB2YXIgYWwxID0gYTEgJiAweDFmZmY7XG4gIHZhciBhaDEgPSBhMSA+Pj4gMTM7XG4gIHZhciBhMiA9IGFbMl0gfCAwO1xuICB2YXIgYWwyID0gYTIgJiAweDFmZmY7XG4gIHZhciBhaDIgPSBhMiA+Pj4gMTM7XG4gIHZhciBhMyA9IGFbM10gfCAwO1xuICB2YXIgYWwzID0gYTMgJiAweDFmZmY7XG4gIHZhciBhaDMgPSBhMyA+Pj4gMTM7XG4gIHZhciBhNCA9IGFbNF0gfCAwO1xuICB2YXIgYWw0ID0gYTQgJiAweDFmZmY7XG4gIHZhciBhaDQgPSBhNCA+Pj4gMTM7XG4gIHZhciBhNSA9IGFbNV0gfCAwO1xuICB2YXIgYWw1ID0gYTUgJiAweDFmZmY7XG4gIHZhciBhaDUgPSBhNSA+Pj4gMTM7XG4gIHZhciBhNiA9IGFbNl0gfCAwO1xuICB2YXIgYWw2ID0gYTYgJiAweDFmZmY7XG4gIHZhciBhaDYgPSBhNiA+Pj4gMTM7XG4gIHZhciBhNyA9IGFbN10gfCAwO1xuICB2YXIgYWw3ID0gYTcgJiAweDFmZmY7XG4gIHZhciBhaDcgPSBhNyA+Pj4gMTM7XG4gIHZhciBhOCA9IGFbOF0gfCAwO1xuICB2YXIgYWw4ID0gYTggJiAweDFmZmY7XG4gIHZhciBhaDggPSBhOCA+Pj4gMTM7XG4gIHZhciBhOSA9IGFbOV0gfCAwO1xuICB2YXIgYWw5ID0gYTkgJiAweDFmZmY7XG4gIHZhciBhaDkgPSBhOSA+Pj4gMTM7XG4gIHZhciBiMCA9IGJbMF0gfCAwO1xuICB2YXIgYmwwID0gYjAgJiAweDFmZmY7XG4gIHZhciBiaDAgPSBiMCA+Pj4gMTM7XG4gIHZhciBiMSA9IGJbMV0gfCAwO1xuICB2YXIgYmwxID0gYjEgJiAweDFmZmY7XG4gIHZhciBiaDEgPSBiMSA+Pj4gMTM7XG4gIHZhciBiMiA9IGJbMl0gfCAwO1xuICB2YXIgYmwyID0gYjIgJiAweDFmZmY7XG4gIHZhciBiaDIgPSBiMiA+Pj4gMTM7XG4gIHZhciBiMyA9IGJbM10gfCAwO1xuICB2YXIgYmwzID0gYjMgJiAweDFmZmY7XG4gIHZhciBiaDMgPSBiMyA+Pj4gMTM7XG4gIHZhciBiNCA9IGJbNF0gfCAwO1xuICB2YXIgYmw0ID0gYjQgJiAweDFmZmY7XG4gIHZhciBiaDQgPSBiNCA+Pj4gMTM7XG4gIHZhciBiNSA9IGJbNV0gfCAwO1xuICB2YXIgYmw1ID0gYjUgJiAweDFmZmY7XG4gIHZhciBiaDUgPSBiNSA+Pj4gMTM7XG4gIHZhciBiNiA9IGJbNl0gfCAwO1xuICB2YXIgYmw2ID0gYjYgJiAweDFmZmY7XG4gIHZhciBiaDYgPSBiNiA+Pj4gMTM7XG4gIHZhciBiNyA9IGJbN10gfCAwO1xuICB2YXIgYmw3ID0gYjcgJiAweDFmZmY7XG4gIHZhciBiaDcgPSBiNyA+Pj4gMTM7XG4gIHZhciBiOCA9IGJbOF0gfCAwO1xuICB2YXIgYmw4ID0gYjggJiAweDFmZmY7XG4gIHZhciBiaDggPSBiOCA+Pj4gMTM7XG4gIHZhciBiOSA9IGJbOV0gfCAwO1xuICB2YXIgYmw5ID0gYjkgJiAweDFmZmY7XG4gIHZhciBiaDkgPSBiOSA+Pj4gMTM7XG5cbiAgb3V0Lmxlbmd0aCA9IDE5O1xuICAvKiBrID0gMCAqL1xuICB2YXIgdzAgPSBjO1xuICBjID0gMDtcbiAgbG8gPSBNYXRoLmltdWwoYWwwLCBibDApO1xuICBtaWQgPSBNYXRoLmltdWwoYWwwLCBiaDApO1xuICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmwwKSkgfCAwO1xuICBoaSA9IE1hdGguaW11bChhaDAsIGJoMCk7XG4gIHcwID0gKHcwICsgbG8pIHwgMDtcbiAgdzAgPSAodzAgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gIGMgPSAoYyArIGhpKSB8IDA7XG4gIGMgPSAoYyArIChtaWQgPj4+IDEzKSkgfCAwO1xuICBjID0gKGMgKyAodzAgPj4+IDI2KSkgfCAwO1xuICB3MCAmPSAweDNmZmZmZmY7XG4gIC8qIGsgPSAxICovXG4gIHZhciB3MSA9IGM7XG4gIGMgPSAwO1xuICBsbyA9IE1hdGguaW11bChhbDEsIGJsMCk7XG4gIG1pZCA9IE1hdGguaW11bChhbDEsIGJoMCk7XG4gIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDApKSB8IDA7XG4gIGhpID0gTWF0aC5pbXVsKGFoMSwgYmgwKTtcbiAgdzEgPSAodzEgKyBsbykgfCAwO1xuICB3MSA9ICh3MSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgYyA9IChjICsgaGkpIHwgMDtcbiAgYyA9IChjICsgKG1pZCA+Pj4gMTMpKSB8IDA7XG4gIGMgPSAoYyArICh3MSA+Pj4gMjYpKSB8IDA7XG4gIHcxICY9IDB4M2ZmZmZmZjtcbiAgbG8gPSBNYXRoLmltdWwoYWwwLCBibDEpO1xuICBtaWQgPSBNYXRoLmltdWwoYWwwLCBiaDEpO1xuICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmwxKSkgfCAwO1xuICBoaSA9IE1hdGguaW11bChhaDAsIGJoMSk7XG4gIHcxID0gKHcxICsgbG8pIHwgMDtcbiAgdzEgPSAodzEgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gIGMgPSAoYyArIGhpKSB8IDA7XG4gIGMgPSAoYyArIChtaWQgPj4+IDEzKSkgfCAwO1xuICBjID0gKGMgKyAodzEgPj4+IDI2KSkgfCAwO1xuICB3MSAmPSAweDNmZmZmZmY7XG4gIC8qIGsgPSAyICovXG4gIHZhciB3MiA9IGM7XG4gIGMgPSAwO1xuICBsbyA9IE1hdGguaW11bChhbDIsIGJsMCk7XG4gIG1pZCA9IE1hdGguaW11bChhbDIsIGJoMCk7XG4gIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDApKSB8IDA7XG4gIGhpID0gTWF0aC5pbXVsKGFoMiwgYmgwKTtcbiAgdzIgPSAodzIgKyBsbykgfCAwO1xuICB3MiA9ICh3MiArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgYyA9IChjICsgaGkpIHwgMDtcbiAgYyA9IChjICsgKG1pZCA+Pj4gMTMpKSB8IDA7XG4gIGMgPSAoYyArICh3MiA+Pj4gMjYpKSB8IDA7XG4gIHcyICY9IDB4M2ZmZmZmZjtcbiAgbG8gPSBNYXRoLmltdWwoYWwxLCBibDEpO1xuICBtaWQgPSBNYXRoLmltdWwoYWwxLCBiaDEpO1xuICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmwxKSkgfCAwO1xuICBoaSA9IE1hdGguaW11bChhaDEsIGJoMSk7XG4gIHcyID0gKHcyICsgbG8pIHwgMDtcbiAgdzIgPSAodzIgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gIGMgPSAoYyArIGhpKSB8IDA7XG4gIGMgPSAoYyArIChtaWQgPj4+IDEzKSkgfCAwO1xuICBjID0gKGMgKyAodzIgPj4+IDI2KSkgfCAwO1xuICB3MiAmPSAweDNmZmZmZmY7XG4gIGxvID0gTWF0aC5pbXVsKGFsMCwgYmwyKTtcbiAgbWlkID0gTWF0aC5pbXVsKGFsMCwgYmgyKTtcbiAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsMikpIHwgMDtcbiAgaGkgPSBNYXRoLmltdWwoYWgwLCBiaDIpO1xuICB3MiA9ICh3MiArIGxvKSB8IDA7XG4gIHcyID0gKHcyICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICBjID0gKGMgKyBoaSkgfCAwO1xuICBjID0gKGMgKyAobWlkID4+PiAxMykpIHwgMDtcbiAgYyA9IChjICsgKHcyID4+PiAyNikpIHwgMDtcbiAgdzIgJj0gMHgzZmZmZmZmO1xuICAvKiBrID0gMyAqL1xuICB2YXIgdzMgPSBjO1xuICBjID0gMDtcbiAgbG8gPSBNYXRoLmltdWwoYWwzLCBibDApO1xuICBtaWQgPSBNYXRoLmltdWwoYWwzLCBiaDApO1xuICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmwwKSkgfCAwO1xuICBoaSA9IE1hdGguaW11bChhaDMsIGJoMCk7XG4gIHczID0gKHczICsgbG8pIHwgMDtcbiAgdzMgPSAodzMgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gIGMgPSAoYyArIGhpKSB8IDA7XG4gIGMgPSAoYyArIChtaWQgPj4+IDEzKSkgfCAwO1xuICBjID0gKGMgKyAodzMgPj4+IDI2KSkgfCAwO1xuICB3MyAmPSAweDNmZmZmZmY7XG4gIGxvID0gTWF0aC5pbXVsKGFsMiwgYmwxKTtcbiAgbWlkID0gTWF0aC5pbXVsKGFsMiwgYmgxKTtcbiAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsMSkpIHwgMDtcbiAgaGkgPSBNYXRoLmltdWwoYWgyLCBiaDEpO1xuICB3MyA9ICh3MyArIGxvKSB8IDA7XG4gIHczID0gKHczICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICBjID0gKGMgKyBoaSkgfCAwO1xuICBjID0gKGMgKyAobWlkID4+PiAxMykpIHwgMDtcbiAgYyA9IChjICsgKHczID4+PiAyNikpIHwgMDtcbiAgdzMgJj0gMHgzZmZmZmZmO1xuICBsbyA9IE1hdGguaW11bChhbDEsIGJsMik7XG4gIG1pZCA9IE1hdGguaW11bChhbDEsIGJoMik7XG4gIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDIpKSB8IDA7XG4gIGhpID0gTWF0aC5pbXVsKGFoMSwgYmgyKTtcbiAgdzMgPSAodzMgKyBsbykgfCAwO1xuICB3MyA9ICh3MyArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgYyA9IChjICsgaGkpIHwgMDtcbiAgYyA9IChjICsgKG1pZCA+Pj4gMTMpKSB8IDA7XG4gIGMgPSAoYyArICh3MyA+Pj4gMjYpKSB8IDA7XG4gIHczICY9IDB4M2ZmZmZmZjtcbiAgbG8gPSBNYXRoLmltdWwoYWwwLCBibDMpO1xuICBtaWQgPSBNYXRoLmltdWwoYWwwLCBiaDMpO1xuICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmwzKSkgfCAwO1xuICBoaSA9IE1hdGguaW11bChhaDAsIGJoMyk7XG4gIHczID0gKHczICsgbG8pIHwgMDtcbiAgdzMgPSAodzMgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gIGMgPSAoYyArIGhpKSB8IDA7XG4gIGMgPSAoYyArIChtaWQgPj4+IDEzKSkgfCAwO1xuICBjID0gKGMgKyAodzMgPj4+IDI2KSkgfCAwO1xuICB3MyAmPSAweDNmZmZmZmY7XG4gIC8qIGsgPSA0ICovXG4gIHZhciB3NCA9IGM7XG4gIGMgPSAwO1xuICBsbyA9IE1hdGguaW11bChhbDQsIGJsMCk7XG4gIG1pZCA9IE1hdGguaW11bChhbDQsIGJoMCk7XG4gIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDApKSB8IDA7XG4gIGhpID0gTWF0aC5pbXVsKGFoNCwgYmgwKTtcbiAgdzQgPSAodzQgKyBsbykgfCAwO1xuICB3NCA9ICh3NCArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgYyA9IChjICsgaGkpIHwgMDtcbiAgYyA9IChjICsgKG1pZCA+Pj4gMTMpKSB8IDA7XG4gIGMgPSAoYyArICh3NCA+Pj4gMjYpKSB8IDA7XG4gIHc0ICY9IDB4M2ZmZmZmZjtcbiAgbG8gPSBNYXRoLmltdWwoYWwzLCBibDEpO1xuICBtaWQgPSBNYXRoLmltdWwoYWwzLCBiaDEpO1xuICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmwxKSkgfCAwO1xuICBoaSA9IE1hdGguaW11bChhaDMsIGJoMSk7XG4gIHc0ID0gKHc0ICsgbG8pIHwgMDtcbiAgdzQgPSAodzQgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gIGMgPSAoYyArIGhpKSB8IDA7XG4gIGMgPSAoYyArIChtaWQgPj4+IDEzKSkgfCAwO1xuICBjID0gKGMgKyAodzQgPj4+IDI2KSkgfCAwO1xuICB3NCAmPSAweDNmZmZmZmY7XG4gIGxvID0gTWF0aC5pbXVsKGFsMiwgYmwyKTtcbiAgbWlkID0gTWF0aC5pbXVsKGFsMiwgYmgyKTtcbiAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsMikpIHwgMDtcbiAgaGkgPSBNYXRoLmltdWwoYWgyLCBiaDIpO1xuICB3NCA9ICh3NCArIGxvKSB8IDA7XG4gIHc0ID0gKHc0ICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICBjID0gKGMgKyBoaSkgfCAwO1xuICBjID0gKGMgKyAobWlkID4+PiAxMykpIHwgMDtcbiAgYyA9IChjICsgKHc0ID4+PiAyNikpIHwgMDtcbiAgdzQgJj0gMHgzZmZmZmZmO1xuICBsbyA9IE1hdGguaW11bChhbDEsIGJsMyk7XG4gIG1pZCA9IE1hdGguaW11bChhbDEsIGJoMyk7XG4gIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDMpKSB8IDA7XG4gIGhpID0gTWF0aC5pbXVsKGFoMSwgYmgzKTtcbiAgdzQgPSAodzQgKyBsbykgfCAwO1xuICB3NCA9ICh3NCArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgYyA9IChjICsgaGkpIHwgMDtcbiAgYyA9IChjICsgKG1pZCA+Pj4gMTMpKSB8IDA7XG4gIGMgPSAoYyArICh3NCA+Pj4gMjYpKSB8IDA7XG4gIHc0ICY9IDB4M2ZmZmZmZjtcbiAgbG8gPSBNYXRoLmltdWwoYWwwLCBibDQpO1xuICBtaWQgPSBNYXRoLmltdWwoYWwwLCBiaDQpO1xuICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw0KSkgfCAwO1xuICBoaSA9IE1hdGguaW11bChhaDAsIGJoNCk7XG4gIHc0ID0gKHc0ICsgbG8pIHwgMDtcbiAgdzQgPSAodzQgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gIGMgPSAoYyArIGhpKSB8IDA7XG4gIGMgPSAoYyArIChtaWQgPj4+IDEzKSkgfCAwO1xuICBjID0gKGMgKyAodzQgPj4+IDI2KSkgfCAwO1xuICB3NCAmPSAweDNmZmZmZmY7XG4gIC8qIGsgPSA1ICovXG4gIHZhciB3NSA9IGM7XG4gIGMgPSAwO1xuICBsbyA9IE1hdGguaW11bChhbDUsIGJsMCk7XG4gIG1pZCA9IE1hdGguaW11bChhbDUsIGJoMCk7XG4gIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDApKSB8IDA7XG4gIGhpID0gTWF0aC5pbXVsKGFoNSwgYmgwKTtcbiAgdzUgPSAodzUgKyBsbykgfCAwO1xuICB3NSA9ICh3NSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgYyA9IChjICsgaGkpIHwgMDtcbiAgYyA9IChjICsgKG1pZCA+Pj4gMTMpKSB8IDA7XG4gIGMgPSAoYyArICh3NSA+Pj4gMjYpKSB8IDA7XG4gIHc1ICY9IDB4M2ZmZmZmZjtcbiAgbG8gPSBNYXRoLmltdWwoYWw0LCBibDEpO1xuICBtaWQgPSBNYXRoLmltdWwoYWw0LCBiaDEpO1xuICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmwxKSkgfCAwO1xuICBoaSA9IE1hdGguaW11bChhaDQsIGJoMSk7XG4gIHc1ID0gKHc1ICsgbG8pIHwgMDtcbiAgdzUgPSAodzUgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gIGMgPSAoYyArIGhpKSB8IDA7XG4gIGMgPSAoYyArIChtaWQgPj4+IDEzKSkgfCAwO1xuICBjID0gKGMgKyAodzUgPj4+IDI2KSkgfCAwO1xuICB3NSAmPSAweDNmZmZmZmY7XG4gIGxvID0gTWF0aC5pbXVsKGFsMywgYmwyKTtcbiAgbWlkID0gTWF0aC5pbXVsKGFsMywgYmgyKTtcbiAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsMikpIHwgMDtcbiAgaGkgPSBNYXRoLmltdWwoYWgzLCBiaDIpO1xuICB3NSA9ICh3NSArIGxvKSB8IDA7XG4gIHc1ID0gKHc1ICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICBjID0gKGMgKyBoaSkgfCAwO1xuICBjID0gKGMgKyAobWlkID4+PiAxMykpIHwgMDtcbiAgYyA9IChjICsgKHc1ID4+PiAyNikpIHwgMDtcbiAgdzUgJj0gMHgzZmZmZmZmO1xuICBsbyA9IE1hdGguaW11bChhbDIsIGJsMyk7XG4gIG1pZCA9IE1hdGguaW11bChhbDIsIGJoMyk7XG4gIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDMpKSB8IDA7XG4gIGhpID0gTWF0aC5pbXVsKGFoMiwgYmgzKTtcbiAgdzUgPSAodzUgKyBsbykgfCAwO1xuICB3NSA9ICh3NSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgYyA9IChjICsgaGkpIHwgMDtcbiAgYyA9IChjICsgKG1pZCA+Pj4gMTMpKSB8IDA7XG4gIGMgPSAoYyArICh3NSA+Pj4gMjYpKSB8IDA7XG4gIHc1ICY9IDB4M2ZmZmZmZjtcbiAgbG8gPSBNYXRoLmltdWwoYWwxLCBibDQpO1xuICBtaWQgPSBNYXRoLmltdWwoYWwxLCBiaDQpO1xuICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmw0KSkgfCAwO1xuICBoaSA9IE1hdGguaW11bChhaDEsIGJoNCk7XG4gIHc1ID0gKHc1ICsgbG8pIHwgMDtcbiAgdzUgPSAodzUgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gIGMgPSAoYyArIGhpKSB8IDA7XG4gIGMgPSAoYyArIChtaWQgPj4+IDEzKSkgfCAwO1xuICBjID0gKGMgKyAodzUgPj4+IDI2KSkgfCAwO1xuICB3NSAmPSAweDNmZmZmZmY7XG4gIGxvID0gTWF0aC5pbXVsKGFsMCwgYmw1KTtcbiAgbWlkID0gTWF0aC5pbXVsKGFsMCwgYmg1KTtcbiAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsNSkpIHwgMDtcbiAgaGkgPSBNYXRoLmltdWwoYWgwLCBiaDUpO1xuICB3NSA9ICh3NSArIGxvKSB8IDA7XG4gIHc1ID0gKHc1ICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICBjID0gKGMgKyBoaSkgfCAwO1xuICBjID0gKGMgKyAobWlkID4+PiAxMykpIHwgMDtcbiAgYyA9IChjICsgKHc1ID4+PiAyNikpIHwgMDtcbiAgdzUgJj0gMHgzZmZmZmZmO1xuICAvKiBrID0gNiAqL1xuICB2YXIgdzYgPSBjO1xuICBjID0gMDtcbiAgbG8gPSBNYXRoLmltdWwoYWw2LCBibDApO1xuICBtaWQgPSBNYXRoLmltdWwoYWw2LCBiaDApO1xuICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmwwKSkgfCAwO1xuICBoaSA9IE1hdGguaW11bChhaDYsIGJoMCk7XG4gIHc2ID0gKHc2ICsgbG8pIHwgMDtcbiAgdzYgPSAodzYgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gIGMgPSAoYyArIGhpKSB8IDA7XG4gIGMgPSAoYyArIChtaWQgPj4+IDEzKSkgfCAwO1xuICBjID0gKGMgKyAodzYgPj4+IDI2KSkgfCAwO1xuICB3NiAmPSAweDNmZmZmZmY7XG4gIGxvID0gTWF0aC5pbXVsKGFsNSwgYmwxKTtcbiAgbWlkID0gTWF0aC5pbXVsKGFsNSwgYmgxKTtcbiAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsMSkpIHwgMDtcbiAgaGkgPSBNYXRoLmltdWwoYWg1LCBiaDEpO1xuICB3NiA9ICh3NiArIGxvKSB8IDA7XG4gIHc2ID0gKHc2ICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICBjID0gKGMgKyBoaSkgfCAwO1xuICBjID0gKGMgKyAobWlkID4+PiAxMykpIHwgMDtcbiAgYyA9IChjICsgKHc2ID4+PiAyNikpIHwgMDtcbiAgdzYgJj0gMHgzZmZmZmZmO1xuICBsbyA9IE1hdGguaW11bChhbDQsIGJsMik7XG4gIG1pZCA9IE1hdGguaW11bChhbDQsIGJoMik7XG4gIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDIpKSB8IDA7XG4gIGhpID0gTWF0aC5pbXVsKGFoNCwgYmgyKTtcbiAgdzYgPSAodzYgKyBsbykgfCAwO1xuICB3NiA9ICh3NiArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgYyA9IChjICsgaGkpIHwgMDtcbiAgYyA9IChjICsgKG1pZCA+Pj4gMTMpKSB8IDA7XG4gIGMgPSAoYyArICh3NiA+Pj4gMjYpKSB8IDA7XG4gIHc2ICY9IDB4M2ZmZmZmZjtcbiAgbG8gPSBNYXRoLmltdWwoYWwzLCBibDMpO1xuICBtaWQgPSBNYXRoLmltdWwoYWwzLCBiaDMpO1xuICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmwzKSkgfCAwO1xuICBoaSA9IE1hdGguaW11bChhaDMsIGJoMyk7XG4gIHc2ID0gKHc2ICsgbG8pIHwgMDtcbiAgdzYgPSAodzYgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gIGMgPSAoYyArIGhpKSB8IDA7XG4gIGMgPSAoYyArIChtaWQgPj4+IDEzKSkgfCAwO1xuICBjID0gKGMgKyAodzYgPj4+IDI2KSkgfCAwO1xuICB3NiAmPSAweDNmZmZmZmY7XG4gIGxvID0gTWF0aC5pbXVsKGFsMiwgYmw0KTtcbiAgbWlkID0gTWF0aC5pbXVsKGFsMiwgYmg0KTtcbiAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsNCkpIHwgMDtcbiAgaGkgPSBNYXRoLmltdWwoYWgyLCBiaDQpO1xuICB3NiA9ICh3NiArIGxvKSB8IDA7XG4gIHc2ID0gKHc2ICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICBjID0gKGMgKyBoaSkgfCAwO1xuICBjID0gKGMgKyAobWlkID4+PiAxMykpIHwgMDtcbiAgYyA9IChjICsgKHc2ID4+PiAyNikpIHwgMDtcbiAgdzYgJj0gMHgzZmZmZmZmO1xuICBsbyA9IE1hdGguaW11bChhbDEsIGJsNSk7XG4gIG1pZCA9IE1hdGguaW11bChhbDEsIGJoNSk7XG4gIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDUpKSB8IDA7XG4gIGhpID0gTWF0aC5pbXVsKGFoMSwgYmg1KTtcbiAgdzYgPSAodzYgKyBsbykgfCAwO1xuICB3NiA9ICh3NiArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgYyA9IChjICsgaGkpIHwgMDtcbiAgYyA9IChjICsgKG1pZCA+Pj4gMTMpKSB8IDA7XG4gIGMgPSAoYyArICh3NiA+Pj4gMjYpKSB8IDA7XG4gIHc2ICY9IDB4M2ZmZmZmZjtcbiAgbG8gPSBNYXRoLmltdWwoYWwwLCBibDYpO1xuICBtaWQgPSBNYXRoLmltdWwoYWwwLCBiaDYpO1xuICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw2KSkgfCAwO1xuICBoaSA9IE1hdGguaW11bChhaDAsIGJoNik7XG4gIHc2ID0gKHc2ICsgbG8pIHwgMDtcbiAgdzYgPSAodzYgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gIGMgPSAoYyArIGhpKSB8IDA7XG4gIGMgPSAoYyArIChtaWQgPj4+IDEzKSkgfCAwO1xuICBjID0gKGMgKyAodzYgPj4+IDI2KSkgfCAwO1xuICB3NiAmPSAweDNmZmZmZmY7XG4gIC8qIGsgPSA3ICovXG4gIHZhciB3NyA9IGM7XG4gIGMgPSAwO1xuICBsbyA9IE1hdGguaW11bChhbDcsIGJsMCk7XG4gIG1pZCA9IE1hdGguaW11bChhbDcsIGJoMCk7XG4gIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDApKSB8IDA7XG4gIGhpID0gTWF0aC5pbXVsKGFoNywgYmgwKTtcbiAgdzcgPSAodzcgKyBsbykgfCAwO1xuICB3NyA9ICh3NyArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgYyA9IChjICsgaGkpIHwgMDtcbiAgYyA9IChjICsgKG1pZCA+Pj4gMTMpKSB8IDA7XG4gIGMgPSAoYyArICh3NyA+Pj4gMjYpKSB8IDA7XG4gIHc3ICY9IDB4M2ZmZmZmZjtcbiAgbG8gPSBNYXRoLmltdWwoYWw2LCBibDEpO1xuICBtaWQgPSBNYXRoLmltdWwoYWw2LCBiaDEpO1xuICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmwxKSkgfCAwO1xuICBoaSA9IE1hdGguaW11bChhaDYsIGJoMSk7XG4gIHc3ID0gKHc3ICsgbG8pIHwgMDtcbiAgdzcgPSAodzcgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gIGMgPSAoYyArIGhpKSB8IDA7XG4gIGMgPSAoYyArIChtaWQgPj4+IDEzKSkgfCAwO1xuICBjID0gKGMgKyAodzcgPj4+IDI2KSkgfCAwO1xuICB3NyAmPSAweDNmZmZmZmY7XG4gIGxvID0gTWF0aC5pbXVsKGFsNSwgYmwyKTtcbiAgbWlkID0gTWF0aC5pbXVsKGFsNSwgYmgyKTtcbiAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsMikpIHwgMDtcbiAgaGkgPSBNYXRoLmltdWwoYWg1LCBiaDIpO1xuICB3NyA9ICh3NyArIGxvKSB8IDA7XG4gIHc3ID0gKHc3ICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICBjID0gKGMgKyBoaSkgfCAwO1xuICBjID0gKGMgKyAobWlkID4+PiAxMykpIHwgMDtcbiAgYyA9IChjICsgKHc3ID4+PiAyNikpIHwgMDtcbiAgdzcgJj0gMHgzZmZmZmZmO1xuICBsbyA9IE1hdGguaW11bChhbDQsIGJsMyk7XG4gIG1pZCA9IE1hdGguaW11bChhbDQsIGJoMyk7XG4gIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDMpKSB8IDA7XG4gIGhpID0gTWF0aC5pbXVsKGFoNCwgYmgzKTtcbiAgdzcgPSAodzcgKyBsbykgfCAwO1xuICB3NyA9ICh3NyArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgYyA9IChjICsgaGkpIHwgMDtcbiAgYyA9IChjICsgKG1pZCA+Pj4gMTMpKSB8IDA7XG4gIGMgPSAoYyArICh3NyA+Pj4gMjYpKSB8IDA7XG4gIHc3ICY9IDB4M2ZmZmZmZjtcbiAgbG8gPSBNYXRoLmltdWwoYWwzLCBibDQpO1xuICBtaWQgPSBNYXRoLmltdWwoYWwzLCBiaDQpO1xuICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw0KSkgfCAwO1xuICBoaSA9IE1hdGguaW11bChhaDMsIGJoNCk7XG4gIHc3ID0gKHc3ICsgbG8pIHwgMDtcbiAgdzcgPSAodzcgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gIGMgPSAoYyArIGhpKSB8IDA7XG4gIGMgPSAoYyArIChtaWQgPj4+IDEzKSkgfCAwO1xuICBjID0gKGMgKyAodzcgPj4+IDI2KSkgfCAwO1xuICB3NyAmPSAweDNmZmZmZmY7XG4gIGxvID0gTWF0aC5pbXVsKGFsMiwgYmw1KTtcbiAgbWlkID0gTWF0aC5pbXVsKGFsMiwgYmg1KTtcbiAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsNSkpIHwgMDtcbiAgaGkgPSBNYXRoLmltdWwoYWgyLCBiaDUpO1xuICB3NyA9ICh3NyArIGxvKSB8IDA7XG4gIHc3ID0gKHc3ICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICBjID0gKGMgKyBoaSkgfCAwO1xuICBjID0gKGMgKyAobWlkID4+PiAxMykpIHwgMDtcbiAgYyA9IChjICsgKHc3ID4+PiAyNikpIHwgMDtcbiAgdzcgJj0gMHgzZmZmZmZmO1xuICBsbyA9IE1hdGguaW11bChhbDEsIGJsNik7XG4gIG1pZCA9IE1hdGguaW11bChhbDEsIGJoNik7XG4gIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDYpKSB8IDA7XG4gIGhpID0gTWF0aC5pbXVsKGFoMSwgYmg2KTtcbiAgdzcgPSAodzcgKyBsbykgfCAwO1xuICB3NyA9ICh3NyArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgYyA9IChjICsgaGkpIHwgMDtcbiAgYyA9IChjICsgKG1pZCA+Pj4gMTMpKSB8IDA7XG4gIGMgPSAoYyArICh3NyA+Pj4gMjYpKSB8IDA7XG4gIHc3ICY9IDB4M2ZmZmZmZjtcbiAgbG8gPSBNYXRoLmltdWwoYWwwLCBibDcpO1xuICBtaWQgPSBNYXRoLmltdWwoYWwwLCBiaDcpO1xuICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw3KSkgfCAwO1xuICBoaSA9IE1hdGguaW11bChhaDAsIGJoNyk7XG4gIHc3ID0gKHc3ICsgbG8pIHwgMDtcbiAgdzcgPSAodzcgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gIGMgPSAoYyArIGhpKSB8IDA7XG4gIGMgPSAoYyArIChtaWQgPj4+IDEzKSkgfCAwO1xuICBjID0gKGMgKyAodzcgPj4+IDI2KSkgfCAwO1xuICB3NyAmPSAweDNmZmZmZmY7XG4gIC8qIGsgPSA4ICovXG4gIHZhciB3OCA9IGM7XG4gIGMgPSAwO1xuICBsbyA9IE1hdGguaW11bChhbDgsIGJsMCk7XG4gIG1pZCA9IE1hdGguaW11bChhbDgsIGJoMCk7XG4gIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDApKSB8IDA7XG4gIGhpID0gTWF0aC5pbXVsKGFoOCwgYmgwKTtcbiAgdzggPSAodzggKyBsbykgfCAwO1xuICB3OCA9ICh3OCArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgYyA9IChjICsgaGkpIHwgMDtcbiAgYyA9IChjICsgKG1pZCA+Pj4gMTMpKSB8IDA7XG4gIGMgPSAoYyArICh3OCA+Pj4gMjYpKSB8IDA7XG4gIHc4ICY9IDB4M2ZmZmZmZjtcbiAgbG8gPSBNYXRoLmltdWwoYWw3LCBibDEpO1xuICBtaWQgPSBNYXRoLmltdWwoYWw3LCBiaDEpO1xuICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmwxKSkgfCAwO1xuICBoaSA9IE1hdGguaW11bChhaDcsIGJoMSk7XG4gIHc4ID0gKHc4ICsgbG8pIHwgMDtcbiAgdzggPSAodzggKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gIGMgPSAoYyArIGhpKSB8IDA7XG4gIGMgPSAoYyArIChtaWQgPj4+IDEzKSkgfCAwO1xuICBjID0gKGMgKyAodzggPj4+IDI2KSkgfCAwO1xuICB3OCAmPSAweDNmZmZmZmY7XG4gIGxvID0gTWF0aC5pbXVsKGFsNiwgYmwyKTtcbiAgbWlkID0gTWF0aC5pbXVsKGFsNiwgYmgyKTtcbiAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsMikpIHwgMDtcbiAgaGkgPSBNYXRoLmltdWwoYWg2LCBiaDIpO1xuICB3OCA9ICh3OCArIGxvKSB8IDA7XG4gIHc4ID0gKHc4ICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICBjID0gKGMgKyBoaSkgfCAwO1xuICBjID0gKGMgKyAobWlkID4+PiAxMykpIHwgMDtcbiAgYyA9IChjICsgKHc4ID4+PiAyNikpIHwgMDtcbiAgdzggJj0gMHgzZmZmZmZmO1xuICBsbyA9IE1hdGguaW11bChhbDUsIGJsMyk7XG4gIG1pZCA9IE1hdGguaW11bChhbDUsIGJoMyk7XG4gIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDMpKSB8IDA7XG4gIGhpID0gTWF0aC5pbXVsKGFoNSwgYmgzKTtcbiAgdzggPSAodzggKyBsbykgfCAwO1xuICB3OCA9ICh3OCArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgYyA9IChjICsgaGkpIHwgMDtcbiAgYyA9IChjICsgKG1pZCA+Pj4gMTMpKSB8IDA7XG4gIGMgPSAoYyArICh3OCA+Pj4gMjYpKSB8IDA7XG4gIHc4ICY9IDB4M2ZmZmZmZjtcbiAgbG8gPSBNYXRoLmltdWwoYWw0LCBibDQpO1xuICBtaWQgPSBNYXRoLmltdWwoYWw0LCBiaDQpO1xuICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmw0KSkgfCAwO1xuICBoaSA9IE1hdGguaW11bChhaDQsIGJoNCk7XG4gIHc4ID0gKHc4ICsgbG8pIHwgMDtcbiAgdzggPSAodzggKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gIGMgPSAoYyArIGhpKSB8IDA7XG4gIGMgPSAoYyArIChtaWQgPj4+IDEzKSkgfCAwO1xuICBjID0gKGMgKyAodzggPj4+IDI2KSkgfCAwO1xuICB3OCAmPSAweDNmZmZmZmY7XG4gIGxvID0gTWF0aC5pbXVsKGFsMywgYmw1KTtcbiAgbWlkID0gTWF0aC5pbXVsKGFsMywgYmg1KTtcbiAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsNSkpIHwgMDtcbiAgaGkgPSBNYXRoLmltdWwoYWgzLCBiaDUpO1xuICB3OCA9ICh3OCArIGxvKSB8IDA7XG4gIHc4ID0gKHc4ICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICBjID0gKGMgKyBoaSkgfCAwO1xuICBjID0gKGMgKyAobWlkID4+PiAxMykpIHwgMDtcbiAgYyA9IChjICsgKHc4ID4+PiAyNikpIHwgMDtcbiAgdzggJj0gMHgzZmZmZmZmO1xuICBsbyA9IE1hdGguaW11bChhbDIsIGJsNik7XG4gIG1pZCA9IE1hdGguaW11bChhbDIsIGJoNik7XG4gIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDYpKSB8IDA7XG4gIGhpID0gTWF0aC5pbXVsKGFoMiwgYmg2KTtcbiAgdzggPSAodzggKyBsbykgfCAwO1xuICB3OCA9ICh3OCArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgYyA9IChjICsgaGkpIHwgMDtcbiAgYyA9IChjICsgKG1pZCA+Pj4gMTMpKSB8IDA7XG4gIGMgPSAoYyArICh3OCA+Pj4gMjYpKSB8IDA7XG4gIHc4ICY9IDB4M2ZmZmZmZjtcbiAgbG8gPSBNYXRoLmltdWwoYWwxLCBibDcpO1xuICBtaWQgPSBNYXRoLmltdWwoYWwxLCBiaDcpO1xuICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmw3KSkgfCAwO1xuICBoaSA9IE1hdGguaW11bChhaDEsIGJoNyk7XG4gIHc4ID0gKHc4ICsgbG8pIHwgMDtcbiAgdzggPSAodzggKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gIGMgPSAoYyArIGhpKSB8IDA7XG4gIGMgPSAoYyArIChtaWQgPj4+IDEzKSkgfCAwO1xuICBjID0gKGMgKyAodzggPj4+IDI2KSkgfCAwO1xuICB3OCAmPSAweDNmZmZmZmY7XG4gIGxvID0gTWF0aC5pbXVsKGFsMCwgYmw4KTtcbiAgbWlkID0gTWF0aC5pbXVsKGFsMCwgYmg4KTtcbiAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsOCkpIHwgMDtcbiAgaGkgPSBNYXRoLmltdWwoYWgwLCBiaDgpO1xuICB3OCA9ICh3OCArIGxvKSB8IDA7XG4gIHc4ID0gKHc4ICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICBjID0gKGMgKyBoaSkgfCAwO1xuICBjID0gKGMgKyAobWlkID4+PiAxMykpIHwgMDtcbiAgYyA9IChjICsgKHc4ID4+PiAyNikpIHwgMDtcbiAgdzggJj0gMHgzZmZmZmZmO1xuICAvKiBrID0gOSAqL1xuICB2YXIgdzkgPSBjO1xuICBjID0gMDtcbiAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDApO1xuICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDApO1xuICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmwwKSkgfCAwO1xuICBoaSA9IE1hdGguaW11bChhaDksIGJoMCk7XG4gIHc5ID0gKHc5ICsgbG8pIHwgMDtcbiAgdzkgPSAodzkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gIGMgPSAoYyArIGhpKSB8IDA7XG4gIGMgPSAoYyArIChtaWQgPj4+IDEzKSkgfCAwO1xuICBjID0gKGMgKyAodzkgPj4+IDI2KSkgfCAwO1xuICB3OSAmPSAweDNmZmZmZmY7XG4gIGxvID0gTWF0aC5pbXVsKGFsOCwgYmwxKTtcbiAgbWlkID0gTWF0aC5pbXVsKGFsOCwgYmgxKTtcbiAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsMSkpIHwgMDtcbiAgaGkgPSBNYXRoLmltdWwoYWg4LCBiaDEpO1xuICB3OSA9ICh3OSArIGxvKSB8IDA7XG4gIHc5ID0gKHc5ICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICBjID0gKGMgKyBoaSkgfCAwO1xuICBjID0gKGMgKyAobWlkID4+PiAxMykpIHwgMDtcbiAgYyA9IChjICsgKHc5ID4+PiAyNikpIHwgMDtcbiAgdzkgJj0gMHgzZmZmZmZmO1xuICBsbyA9IE1hdGguaW11bChhbDcsIGJsMik7XG4gIG1pZCA9IE1hdGguaW11bChhbDcsIGJoMik7XG4gIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDIpKSB8IDA7XG4gIGhpID0gTWF0aC5pbXVsKGFoNywgYmgyKTtcbiAgdzkgPSAodzkgKyBsbykgfCAwO1xuICB3OSA9ICh3OSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgYyA9IChjICsgaGkpIHwgMDtcbiAgYyA9IChjICsgKG1pZCA+Pj4gMTMpKSB8IDA7XG4gIGMgPSAoYyArICh3OSA+Pj4gMjYpKSB8IDA7XG4gIHc5ICY9IDB4M2ZmZmZmZjtcbiAgbG8gPSBNYXRoLmltdWwoYWw2LCBibDMpO1xuICBtaWQgPSBNYXRoLmltdWwoYWw2LCBiaDMpO1xuICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmwzKSkgfCAwO1xuICBoaSA9IE1hdGguaW11bChhaDYsIGJoMyk7XG4gIHc5ID0gKHc5ICsgbG8pIHwgMDtcbiAgdzkgPSAodzkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gIGMgPSAoYyArIGhpKSB8IDA7XG4gIGMgPSAoYyArIChtaWQgPj4+IDEzKSkgfCAwO1xuICBjID0gKGMgKyAodzkgPj4+IDI2KSkgfCAwO1xuICB3OSAmPSAweDNmZmZmZmY7XG4gIGxvID0gTWF0aC5pbXVsKGFsNSwgYmw0KTtcbiAgbWlkID0gTWF0aC5pbXVsKGFsNSwgYmg0KTtcbiAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsNCkpIHwgMDtcbiAgaGkgPSBNYXRoLmltdWwoYWg1LCBiaDQpO1xuICB3OSA9ICh3OSArIGxvKSB8IDA7XG4gIHc5ID0gKHc5ICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICBjID0gKGMgKyBoaSkgfCAwO1xuICBjID0gKGMgKyAobWlkID4+PiAxMykpIHwgMDtcbiAgYyA9IChjICsgKHc5ID4+PiAyNikpIHwgMDtcbiAgdzkgJj0gMHgzZmZmZmZmO1xuICBsbyA9IE1hdGguaW11bChhbDQsIGJsNSk7XG4gIG1pZCA9IE1hdGguaW11bChhbDQsIGJoNSk7XG4gIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDUpKSB8IDA7XG4gIGhpID0gTWF0aC5pbXVsKGFoNCwgYmg1KTtcbiAgdzkgPSAodzkgKyBsbykgfCAwO1xuICB3OSA9ICh3OSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgYyA9IChjICsgaGkpIHwgMDtcbiAgYyA9IChjICsgKG1pZCA+Pj4gMTMpKSB8IDA7XG4gIGMgPSAoYyArICh3OSA+Pj4gMjYpKSB8IDA7XG4gIHc5ICY9IDB4M2ZmZmZmZjtcbiAgbG8gPSBNYXRoLmltdWwoYWwzLCBibDYpO1xuICBtaWQgPSBNYXRoLmltdWwoYWwzLCBiaDYpO1xuICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw2KSkgfCAwO1xuICBoaSA9IE1hdGguaW11bChhaDMsIGJoNik7XG4gIHc5ID0gKHc5ICsgbG8pIHwgMDtcbiAgdzkgPSAodzkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gIGMgPSAoYyArIGhpKSB8IDA7XG4gIGMgPSAoYyArIChtaWQgPj4+IDEzKSkgfCAwO1xuICBjID0gKGMgKyAodzkgPj4+IDI2KSkgfCAwO1xuICB3OSAmPSAweDNmZmZmZmY7XG4gIGxvID0gTWF0aC5pbXVsKGFsMiwgYmw3KTtcbiAgbWlkID0gTWF0aC5pbXVsKGFsMiwgYmg3KTtcbiAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsNykpIHwgMDtcbiAgaGkgPSBNYXRoLmltdWwoYWgyLCBiaDcpO1xuICB3OSA9ICh3OSArIGxvKSB8IDA7XG4gIHc5ID0gKHc5ICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICBjID0gKGMgKyBoaSkgfCAwO1xuICBjID0gKGMgKyAobWlkID4+PiAxMykpIHwgMDtcbiAgYyA9IChjICsgKHc5ID4+PiAyNikpIHwgMDtcbiAgdzkgJj0gMHgzZmZmZmZmO1xuICBsbyA9IE1hdGguaW11bChhbDEsIGJsOCk7XG4gIG1pZCA9IE1hdGguaW11bChhbDEsIGJoOCk7XG4gIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDgpKSB8IDA7XG4gIGhpID0gTWF0aC5pbXVsKGFoMSwgYmg4KTtcbiAgdzkgPSAodzkgKyBsbykgfCAwO1xuICB3OSA9ICh3OSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgYyA9IChjICsgaGkpIHwgMDtcbiAgYyA9IChjICsgKG1pZCA+Pj4gMTMpKSB8IDA7XG4gIGMgPSAoYyArICh3OSA+Pj4gMjYpKSB8IDA7XG4gIHc5ICY9IDB4M2ZmZmZmZjtcbiAgbG8gPSBNYXRoLmltdWwoYWwwLCBibDkpO1xuICBtaWQgPSBNYXRoLmltdWwoYWwwLCBiaDkpO1xuICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw5KSkgfCAwO1xuICBoaSA9IE1hdGguaW11bChhaDAsIGJoOSk7XG4gIHc5ID0gKHc5ICsgbG8pIHwgMDtcbiAgdzkgPSAodzkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gIGMgPSAoYyArIGhpKSB8IDA7XG4gIGMgPSAoYyArIChtaWQgPj4+IDEzKSkgfCAwO1xuICBjID0gKGMgKyAodzkgPj4+IDI2KSkgfCAwO1xuICB3OSAmPSAweDNmZmZmZmY7XG4gIC8qIGsgPSAxMCAqL1xuICB2YXIgdzEwID0gYztcbiAgYyA9IDA7XG4gIGxvID0gTWF0aC5pbXVsKGFsOSwgYmwxKTtcbiAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmgxKTtcbiAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsMSkpIHwgMDtcbiAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDEpO1xuICB3MTAgPSAodzEwICsgbG8pIHwgMDtcbiAgdzEwID0gKHcxMCArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgYyA9IChjICsgaGkpIHwgMDtcbiAgYyA9IChjICsgKG1pZCA+Pj4gMTMpKSB8IDA7XG4gIGMgPSAoYyArICh3MTAgPj4+IDI2KSkgfCAwO1xuICB3MTAgJj0gMHgzZmZmZmZmO1xuICBsbyA9IE1hdGguaW11bChhbDgsIGJsMik7XG4gIG1pZCA9IE1hdGguaW11bChhbDgsIGJoMik7XG4gIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDIpKSB8IDA7XG4gIGhpID0gTWF0aC5pbXVsKGFoOCwgYmgyKTtcbiAgdzEwID0gKHcxMCArIGxvKSB8IDA7XG4gIHcxMCA9ICh3MTAgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gIGMgPSAoYyArIGhpKSB8IDA7XG4gIGMgPSAoYyArIChtaWQgPj4+IDEzKSkgfCAwO1xuICBjID0gKGMgKyAodzEwID4+PiAyNikpIHwgMDtcbiAgdzEwICY9IDB4M2ZmZmZmZjtcbiAgbG8gPSBNYXRoLmltdWwoYWw3LCBibDMpO1xuICBtaWQgPSBNYXRoLmltdWwoYWw3LCBiaDMpO1xuICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmwzKSkgfCAwO1xuICBoaSA9IE1hdGguaW11bChhaDcsIGJoMyk7XG4gIHcxMCA9ICh3MTAgKyBsbykgfCAwO1xuICB3MTAgPSAodzEwICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICBjID0gKGMgKyBoaSkgfCAwO1xuICBjID0gKGMgKyAobWlkID4+PiAxMykpIHwgMDtcbiAgYyA9IChjICsgKHcxMCA+Pj4gMjYpKSB8IDA7XG4gIHcxMCAmPSAweDNmZmZmZmY7XG4gIGxvID0gTWF0aC5pbXVsKGFsNiwgYmw0KTtcbiAgbWlkID0gTWF0aC5pbXVsKGFsNiwgYmg0KTtcbiAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsNCkpIHwgMDtcbiAgaGkgPSBNYXRoLmltdWwoYWg2LCBiaDQpO1xuICB3MTAgPSAodzEwICsgbG8pIHwgMDtcbiAgdzEwID0gKHcxMCArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgYyA9IChjICsgaGkpIHwgMDtcbiAgYyA9IChjICsgKG1pZCA+Pj4gMTMpKSB8IDA7XG4gIGMgPSAoYyArICh3MTAgPj4+IDI2KSkgfCAwO1xuICB3MTAgJj0gMHgzZmZmZmZmO1xuICBsbyA9IE1hdGguaW11bChhbDUsIGJsNSk7XG4gIG1pZCA9IE1hdGguaW11bChhbDUsIGJoNSk7XG4gIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDUpKSB8IDA7XG4gIGhpID0gTWF0aC5pbXVsKGFoNSwgYmg1KTtcbiAgdzEwID0gKHcxMCArIGxvKSB8IDA7XG4gIHcxMCA9ICh3MTAgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gIGMgPSAoYyArIGhpKSB8IDA7XG4gIGMgPSAoYyArIChtaWQgPj4+IDEzKSkgfCAwO1xuICBjID0gKGMgKyAodzEwID4+PiAyNikpIHwgMDtcbiAgdzEwICY9IDB4M2ZmZmZmZjtcbiAgbG8gPSBNYXRoLmltdWwoYWw0LCBibDYpO1xuICBtaWQgPSBNYXRoLmltdWwoYWw0LCBiaDYpO1xuICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmw2KSkgfCAwO1xuICBoaSA9IE1hdGguaW11bChhaDQsIGJoNik7XG4gIHcxMCA9ICh3MTAgKyBsbykgfCAwO1xuICB3MTAgPSAodzEwICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICBjID0gKGMgKyBoaSkgfCAwO1xuICBjID0gKGMgKyAobWlkID4+PiAxMykpIHwgMDtcbiAgYyA9IChjICsgKHcxMCA+Pj4gMjYpKSB8IDA7XG4gIHcxMCAmPSAweDNmZmZmZmY7XG4gIGxvID0gTWF0aC5pbXVsKGFsMywgYmw3KTtcbiAgbWlkID0gTWF0aC5pbXVsKGFsMywgYmg3KTtcbiAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsNykpIHwgMDtcbiAgaGkgPSBNYXRoLmltdWwoYWgzLCBiaDcpO1xuICB3MTAgPSAodzEwICsgbG8pIHwgMDtcbiAgdzEwID0gKHcxMCArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgYyA9IChjICsgaGkpIHwgMDtcbiAgYyA9IChjICsgKG1pZCA+Pj4gMTMpKSB8IDA7XG4gIGMgPSAoYyArICh3MTAgPj4+IDI2KSkgfCAwO1xuICB3MTAgJj0gMHgzZmZmZmZmO1xuICBsbyA9IE1hdGguaW11bChhbDIsIGJsOCk7XG4gIG1pZCA9IE1hdGguaW11bChhbDIsIGJoOCk7XG4gIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDgpKSB8IDA7XG4gIGhpID0gTWF0aC5pbXVsKGFoMiwgYmg4KTtcbiAgdzEwID0gKHcxMCArIGxvKSB8IDA7XG4gIHcxMCA9ICh3MTAgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gIGMgPSAoYyArIGhpKSB8IDA7XG4gIGMgPSAoYyArIChtaWQgPj4+IDEzKSkgfCAwO1xuICBjID0gKGMgKyAodzEwID4+PiAyNikpIHwgMDtcbiAgdzEwICY9IDB4M2ZmZmZmZjtcbiAgbG8gPSBNYXRoLmltdWwoYWwxLCBibDkpO1xuICBtaWQgPSBNYXRoLmltdWwoYWwxLCBiaDkpO1xuICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmw5KSkgfCAwO1xuICBoaSA9IE1hdGguaW11bChhaDEsIGJoOSk7XG4gIHcxMCA9ICh3MTAgKyBsbykgfCAwO1xuICB3MTAgPSAodzEwICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICBjID0gKGMgKyBoaSkgfCAwO1xuICBjID0gKGMgKyAobWlkID4+PiAxMykpIHwgMDtcbiAgYyA9IChjICsgKHcxMCA+Pj4gMjYpKSB8IDA7XG4gIHcxMCAmPSAweDNmZmZmZmY7XG4gIC8qIGsgPSAxMSAqL1xuICB2YXIgdzExID0gYztcbiAgYyA9IDA7XG4gIGxvID0gTWF0aC5pbXVsKGFsOSwgYmwyKTtcbiAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmgyKTtcbiAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsMikpIHwgMDtcbiAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDIpO1xuICB3MTEgPSAodzExICsgbG8pIHwgMDtcbiAgdzExID0gKHcxMSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgYyA9IChjICsgaGkpIHwgMDtcbiAgYyA9IChjICsgKG1pZCA+Pj4gMTMpKSB8IDA7XG4gIGMgPSAoYyArICh3MTEgPj4+IDI2KSkgfCAwO1xuICB3MTEgJj0gMHgzZmZmZmZmO1xuICBsbyA9IE1hdGguaW11bChhbDgsIGJsMyk7XG4gIG1pZCA9IE1hdGguaW11bChhbDgsIGJoMyk7XG4gIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDMpKSB8IDA7XG4gIGhpID0gTWF0aC5pbXVsKGFoOCwgYmgzKTtcbiAgdzExID0gKHcxMSArIGxvKSB8IDA7XG4gIHcxMSA9ICh3MTEgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gIGMgPSAoYyArIGhpKSB8IDA7XG4gIGMgPSAoYyArIChtaWQgPj4+IDEzKSkgfCAwO1xuICBjID0gKGMgKyAodzExID4+PiAyNikpIHwgMDtcbiAgdzExICY9IDB4M2ZmZmZmZjtcbiAgbG8gPSBNYXRoLmltdWwoYWw3LCBibDQpO1xuICBtaWQgPSBNYXRoLmltdWwoYWw3LCBiaDQpO1xuICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmw0KSkgfCAwO1xuICBoaSA9IE1hdGguaW11bChhaDcsIGJoNCk7XG4gIHcxMSA9ICh3MTEgKyBsbykgfCAwO1xuICB3MTEgPSAodzExICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICBjID0gKGMgKyBoaSkgfCAwO1xuICBjID0gKGMgKyAobWlkID4+PiAxMykpIHwgMDtcbiAgYyA9IChjICsgKHcxMSA+Pj4gMjYpKSB8IDA7XG4gIHcxMSAmPSAweDNmZmZmZmY7XG4gIGxvID0gTWF0aC5pbXVsKGFsNiwgYmw1KTtcbiAgbWlkID0gTWF0aC5pbXVsKGFsNiwgYmg1KTtcbiAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsNSkpIHwgMDtcbiAgaGkgPSBNYXRoLmltdWwoYWg2LCBiaDUpO1xuICB3MTEgPSAodzExICsgbG8pIHwgMDtcbiAgdzExID0gKHcxMSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgYyA9IChjICsgaGkpIHwgMDtcbiAgYyA9IChjICsgKG1pZCA+Pj4gMTMpKSB8IDA7XG4gIGMgPSAoYyArICh3MTEgPj4+IDI2KSkgfCAwO1xuICB3MTEgJj0gMHgzZmZmZmZmO1xuICBsbyA9IE1hdGguaW11bChhbDUsIGJsNik7XG4gIG1pZCA9IE1hdGguaW11bChhbDUsIGJoNik7XG4gIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDYpKSB8IDA7XG4gIGhpID0gTWF0aC5pbXVsKGFoNSwgYmg2KTtcbiAgdzExID0gKHcxMSArIGxvKSB8IDA7XG4gIHcxMSA9ICh3MTEgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gIGMgPSAoYyArIGhpKSB8IDA7XG4gIGMgPSAoYyArIChtaWQgPj4+IDEzKSkgfCAwO1xuICBjID0gKGMgKyAodzExID4+PiAyNikpIHwgMDtcbiAgdzExICY9IDB4M2ZmZmZmZjtcbiAgbG8gPSBNYXRoLmltdWwoYWw0LCBibDcpO1xuICBtaWQgPSBNYXRoLmltdWwoYWw0LCBiaDcpO1xuICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmw3KSkgfCAwO1xuICBoaSA9IE1hdGguaW11bChhaDQsIGJoNyk7XG4gIHcxMSA9ICh3MTEgKyBsbykgfCAwO1xuICB3MTEgPSAodzExICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICBjID0gKGMgKyBoaSkgfCAwO1xuICBjID0gKGMgKyAobWlkID4+PiAxMykpIHwgMDtcbiAgYyA9IChjICsgKHcxMSA+Pj4gMjYpKSB8IDA7XG4gIHcxMSAmPSAweDNmZmZmZmY7XG4gIGxvID0gTWF0aC5pbXVsKGFsMywgYmw4KTtcbiAgbWlkID0gTWF0aC5pbXVsKGFsMywgYmg4KTtcbiAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsOCkpIHwgMDtcbiAgaGkgPSBNYXRoLmltdWwoYWgzLCBiaDgpO1xuICB3MTEgPSAodzExICsgbG8pIHwgMDtcbiAgdzExID0gKHcxMSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgYyA9IChjICsgaGkpIHwgMDtcbiAgYyA9IChjICsgKG1pZCA+Pj4gMTMpKSB8IDA7XG4gIGMgPSAoYyArICh3MTEgPj4+IDI2KSkgfCAwO1xuICB3MTEgJj0gMHgzZmZmZmZmO1xuICBsbyA9IE1hdGguaW11bChhbDIsIGJsOSk7XG4gIG1pZCA9IE1hdGguaW11bChhbDIsIGJoOSk7XG4gIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDkpKSB8IDA7XG4gIGhpID0gTWF0aC5pbXVsKGFoMiwgYmg5KTtcbiAgdzExID0gKHcxMSArIGxvKSB8IDA7XG4gIHcxMSA9ICh3MTEgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gIGMgPSAoYyArIGhpKSB8IDA7XG4gIGMgPSAoYyArIChtaWQgPj4+IDEzKSkgfCAwO1xuICBjID0gKGMgKyAodzExID4+PiAyNikpIHwgMDtcbiAgdzExICY9IDB4M2ZmZmZmZjtcbiAgLyogayA9IDEyICovXG4gIHZhciB3MTIgPSBjO1xuICBjID0gMDtcbiAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDMpO1xuICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDMpO1xuICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmwzKSkgfCAwO1xuICBoaSA9IE1hdGguaW11bChhaDksIGJoMyk7XG4gIHcxMiA9ICh3MTIgKyBsbykgfCAwO1xuICB3MTIgPSAodzEyICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICBjID0gKGMgKyBoaSkgfCAwO1xuICBjID0gKGMgKyAobWlkID4+PiAxMykpIHwgMDtcbiAgYyA9IChjICsgKHcxMiA+Pj4gMjYpKSB8IDA7XG4gIHcxMiAmPSAweDNmZmZmZmY7XG4gIGxvID0gTWF0aC5pbXVsKGFsOCwgYmw0KTtcbiAgbWlkID0gTWF0aC5pbXVsKGFsOCwgYmg0KTtcbiAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsNCkpIHwgMDtcbiAgaGkgPSBNYXRoLmltdWwoYWg4LCBiaDQpO1xuICB3MTIgPSAodzEyICsgbG8pIHwgMDtcbiAgdzEyID0gKHcxMiArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgYyA9IChjICsgaGkpIHwgMDtcbiAgYyA9IChjICsgKG1pZCA+Pj4gMTMpKSB8IDA7XG4gIGMgPSAoYyArICh3MTIgPj4+IDI2KSkgfCAwO1xuICB3MTIgJj0gMHgzZmZmZmZmO1xuICBsbyA9IE1hdGguaW11bChhbDcsIGJsNSk7XG4gIG1pZCA9IE1hdGguaW11bChhbDcsIGJoNSk7XG4gIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDUpKSB8IDA7XG4gIGhpID0gTWF0aC5pbXVsKGFoNywgYmg1KTtcbiAgdzEyID0gKHcxMiArIGxvKSB8IDA7XG4gIHcxMiA9ICh3MTIgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gIGMgPSAoYyArIGhpKSB8IDA7XG4gIGMgPSAoYyArIChtaWQgPj4+IDEzKSkgfCAwO1xuICBjID0gKGMgKyAodzEyID4+PiAyNikpIHwgMDtcbiAgdzEyICY9IDB4M2ZmZmZmZjtcbiAgbG8gPSBNYXRoLmltdWwoYWw2LCBibDYpO1xuICBtaWQgPSBNYXRoLmltdWwoYWw2LCBiaDYpO1xuICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw2KSkgfCAwO1xuICBoaSA9IE1hdGguaW11bChhaDYsIGJoNik7XG4gIHcxMiA9ICh3MTIgKyBsbykgfCAwO1xuICB3MTIgPSAodzEyICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICBjID0gKGMgKyBoaSkgfCAwO1xuICBjID0gKGMgKyAobWlkID4+PiAxMykpIHwgMDtcbiAgYyA9IChjICsgKHcxMiA+Pj4gMjYpKSB8IDA7XG4gIHcxMiAmPSAweDNmZmZmZmY7XG4gIGxvID0gTWF0aC5pbXVsKGFsNSwgYmw3KTtcbiAgbWlkID0gTWF0aC5pbXVsKGFsNSwgYmg3KTtcbiAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsNykpIHwgMDtcbiAgaGkgPSBNYXRoLmltdWwoYWg1LCBiaDcpO1xuICB3MTIgPSAodzEyICsgbG8pIHwgMDtcbiAgdzEyID0gKHcxMiArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgYyA9IChjICsgaGkpIHwgMDtcbiAgYyA9IChjICsgKG1pZCA+Pj4gMTMpKSB8IDA7XG4gIGMgPSAoYyArICh3MTIgPj4+IDI2KSkgfCAwO1xuICB3MTIgJj0gMHgzZmZmZmZmO1xuICBsbyA9IE1hdGguaW11bChhbDQsIGJsOCk7XG4gIG1pZCA9IE1hdGguaW11bChhbDQsIGJoOCk7XG4gIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDgpKSB8IDA7XG4gIGhpID0gTWF0aC5pbXVsKGFoNCwgYmg4KTtcbiAgdzEyID0gKHcxMiArIGxvKSB8IDA7XG4gIHcxMiA9ICh3MTIgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gIGMgPSAoYyArIGhpKSB8IDA7XG4gIGMgPSAoYyArIChtaWQgPj4+IDEzKSkgfCAwO1xuICBjID0gKGMgKyAodzEyID4+PiAyNikpIHwgMDtcbiAgdzEyICY9IDB4M2ZmZmZmZjtcbiAgbG8gPSBNYXRoLmltdWwoYWwzLCBibDkpO1xuICBtaWQgPSBNYXRoLmltdWwoYWwzLCBiaDkpO1xuICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw5KSkgfCAwO1xuICBoaSA9IE1hdGguaW11bChhaDMsIGJoOSk7XG4gIHcxMiA9ICh3MTIgKyBsbykgfCAwO1xuICB3MTIgPSAodzEyICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICBjID0gKGMgKyBoaSkgfCAwO1xuICBjID0gKGMgKyAobWlkID4+PiAxMykpIHwgMDtcbiAgYyA9IChjICsgKHcxMiA+Pj4gMjYpKSB8IDA7XG4gIHcxMiAmPSAweDNmZmZmZmY7XG4gIC8qIGsgPSAxMyAqL1xuICB2YXIgdzEzID0gYztcbiAgYyA9IDA7XG4gIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw0KTtcbiAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg0KTtcbiAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsNCkpIHwgMDtcbiAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDQpO1xuICB3MTMgPSAodzEzICsgbG8pIHwgMDtcbiAgdzEzID0gKHcxMyArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgYyA9IChjICsgaGkpIHwgMDtcbiAgYyA9IChjICsgKG1pZCA+Pj4gMTMpKSB8IDA7XG4gIGMgPSAoYyArICh3MTMgPj4+IDI2KSkgfCAwO1xuICB3MTMgJj0gMHgzZmZmZmZmO1xuICBsbyA9IE1hdGguaW11bChhbDgsIGJsNSk7XG4gIG1pZCA9IE1hdGguaW11bChhbDgsIGJoNSk7XG4gIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDUpKSB8IDA7XG4gIGhpID0gTWF0aC5pbXVsKGFoOCwgYmg1KTtcbiAgdzEzID0gKHcxMyArIGxvKSB8IDA7XG4gIHcxMyA9ICh3MTMgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gIGMgPSAoYyArIGhpKSB8IDA7XG4gIGMgPSAoYyArIChtaWQgPj4+IDEzKSkgfCAwO1xuICBjID0gKGMgKyAodzEzID4+PiAyNikpIHwgMDtcbiAgdzEzICY9IDB4M2ZmZmZmZjtcbiAgbG8gPSBNYXRoLmltdWwoYWw3LCBibDYpO1xuICBtaWQgPSBNYXRoLmltdWwoYWw3LCBiaDYpO1xuICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmw2KSkgfCAwO1xuICBoaSA9IE1hdGguaW11bChhaDcsIGJoNik7XG4gIHcxMyA9ICh3MTMgKyBsbykgfCAwO1xuICB3MTMgPSAodzEzICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICBjID0gKGMgKyBoaSkgfCAwO1xuICBjID0gKGMgKyAobWlkID4+PiAxMykpIHwgMDtcbiAgYyA9IChjICsgKHcxMyA+Pj4gMjYpKSB8IDA7XG4gIHcxMyAmPSAweDNmZmZmZmY7XG4gIGxvID0gTWF0aC5pbXVsKGFsNiwgYmw3KTtcbiAgbWlkID0gTWF0aC5pbXVsKGFsNiwgYmg3KTtcbiAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsNykpIHwgMDtcbiAgaGkgPSBNYXRoLmltdWwoYWg2LCBiaDcpO1xuICB3MTMgPSAodzEzICsgbG8pIHwgMDtcbiAgdzEzID0gKHcxMyArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgYyA9IChjICsgaGkpIHwgMDtcbiAgYyA9IChjICsgKG1pZCA+Pj4gMTMpKSB8IDA7XG4gIGMgPSAoYyArICh3MTMgPj4+IDI2KSkgfCAwO1xuICB3MTMgJj0gMHgzZmZmZmZmO1xuICBsbyA9IE1hdGguaW11bChhbDUsIGJsOCk7XG4gIG1pZCA9IE1hdGguaW11bChhbDUsIGJoOCk7XG4gIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDgpKSB8IDA7XG4gIGhpID0gTWF0aC5pbXVsKGFoNSwgYmg4KTtcbiAgdzEzID0gKHcxMyArIGxvKSB8IDA7XG4gIHcxMyA9ICh3MTMgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gIGMgPSAoYyArIGhpKSB8IDA7XG4gIGMgPSAoYyArIChtaWQgPj4+IDEzKSkgfCAwO1xuICBjID0gKGMgKyAodzEzID4+PiAyNikpIHwgMDtcbiAgdzEzICY9IDB4M2ZmZmZmZjtcbiAgbG8gPSBNYXRoLmltdWwoYWw0LCBibDkpO1xuICBtaWQgPSBNYXRoLmltdWwoYWw0LCBiaDkpO1xuICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmw5KSkgfCAwO1xuICBoaSA9IE1hdGguaW11bChhaDQsIGJoOSk7XG4gIHcxMyA9ICh3MTMgKyBsbykgfCAwO1xuICB3MTMgPSAodzEzICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICBjID0gKGMgKyBoaSkgfCAwO1xuICBjID0gKGMgKyAobWlkID4+PiAxMykpIHwgMDtcbiAgYyA9IChjICsgKHcxMyA+Pj4gMjYpKSB8IDA7XG4gIHcxMyAmPSAweDNmZmZmZmY7XG4gIC8qIGsgPSAxNCAqL1xuICB2YXIgdzE0ID0gYztcbiAgYyA9IDA7XG4gIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw1KTtcbiAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg1KTtcbiAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsNSkpIHwgMDtcbiAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDUpO1xuICB3MTQgPSAodzE0ICsgbG8pIHwgMDtcbiAgdzE0ID0gKHcxNCArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgYyA9IChjICsgaGkpIHwgMDtcbiAgYyA9IChjICsgKG1pZCA+Pj4gMTMpKSB8IDA7XG4gIGMgPSAoYyArICh3MTQgPj4+IDI2KSkgfCAwO1xuICB3MTQgJj0gMHgzZmZmZmZmO1xuICBsbyA9IE1hdGguaW11bChhbDgsIGJsNik7XG4gIG1pZCA9IE1hdGguaW11bChhbDgsIGJoNik7XG4gIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDYpKSB8IDA7XG4gIGhpID0gTWF0aC5pbXVsKGFoOCwgYmg2KTtcbiAgdzE0ID0gKHcxNCArIGxvKSB8IDA7XG4gIHcxNCA9ICh3MTQgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gIGMgPSAoYyArIGhpKSB8IDA7XG4gIGMgPSAoYyArIChtaWQgPj4+IDEzKSkgfCAwO1xuICBjID0gKGMgKyAodzE0ID4+PiAyNikpIHwgMDtcbiAgdzE0ICY9IDB4M2ZmZmZmZjtcbiAgbG8gPSBNYXRoLmltdWwoYWw3LCBibDcpO1xuICBtaWQgPSBNYXRoLmltdWwoYWw3LCBiaDcpO1xuICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmw3KSkgfCAwO1xuICBoaSA9IE1hdGguaW11bChhaDcsIGJoNyk7XG4gIHcxNCA9ICh3MTQgKyBsbykgfCAwO1xuICB3MTQgPSAodzE0ICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICBjID0gKGMgKyBoaSkgfCAwO1xuICBjID0gKGMgKyAobWlkID4+PiAxMykpIHwgMDtcbiAgYyA9IChjICsgKHcxNCA+Pj4gMjYpKSB8IDA7XG4gIHcxNCAmPSAweDNmZmZmZmY7XG4gIGxvID0gTWF0aC5pbXVsKGFsNiwgYmw4KTtcbiAgbWlkID0gTWF0aC5pbXVsKGFsNiwgYmg4KTtcbiAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsOCkpIHwgMDtcbiAgaGkgPSBNYXRoLmltdWwoYWg2LCBiaDgpO1xuICB3MTQgPSAodzE0ICsgbG8pIHwgMDtcbiAgdzE0ID0gKHcxNCArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgYyA9IChjICsgaGkpIHwgMDtcbiAgYyA9IChjICsgKG1pZCA+Pj4gMTMpKSB8IDA7XG4gIGMgPSAoYyArICh3MTQgPj4+IDI2KSkgfCAwO1xuICB3MTQgJj0gMHgzZmZmZmZmO1xuICBsbyA9IE1hdGguaW11bChhbDUsIGJsOSk7XG4gIG1pZCA9IE1hdGguaW11bChhbDUsIGJoOSk7XG4gIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDkpKSB8IDA7XG4gIGhpID0gTWF0aC5pbXVsKGFoNSwgYmg5KTtcbiAgdzE0ID0gKHcxNCArIGxvKSB8IDA7XG4gIHcxNCA9ICh3MTQgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gIGMgPSAoYyArIGhpKSB8IDA7XG4gIGMgPSAoYyArIChtaWQgPj4+IDEzKSkgfCAwO1xuICBjID0gKGMgKyAodzE0ID4+PiAyNikpIHwgMDtcbiAgdzE0ICY9IDB4M2ZmZmZmZjtcbiAgLyogayA9IDE1ICovXG4gIHZhciB3MTUgPSBjO1xuICBjID0gMDtcbiAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDYpO1xuICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDYpO1xuICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmw2KSkgfCAwO1xuICBoaSA9IE1hdGguaW11bChhaDksIGJoNik7XG4gIHcxNSA9ICh3MTUgKyBsbykgfCAwO1xuICB3MTUgPSAodzE1ICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICBjID0gKGMgKyBoaSkgfCAwO1xuICBjID0gKGMgKyAobWlkID4+PiAxMykpIHwgMDtcbiAgYyA9IChjICsgKHcxNSA+Pj4gMjYpKSB8IDA7XG4gIHcxNSAmPSAweDNmZmZmZmY7XG4gIGxvID0gTWF0aC5pbXVsKGFsOCwgYmw3KTtcbiAgbWlkID0gTWF0aC5pbXVsKGFsOCwgYmg3KTtcbiAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsNykpIHwgMDtcbiAgaGkgPSBNYXRoLmltdWwoYWg4LCBiaDcpO1xuICB3MTUgPSAodzE1ICsgbG8pIHwgMDtcbiAgdzE1ID0gKHcxNSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgYyA9IChjICsgaGkpIHwgMDtcbiAgYyA9IChjICsgKG1pZCA+Pj4gMTMpKSB8IDA7XG4gIGMgPSAoYyArICh3MTUgPj4+IDI2KSkgfCAwO1xuICB3MTUgJj0gMHgzZmZmZmZmO1xuICBsbyA9IE1hdGguaW11bChhbDcsIGJsOCk7XG4gIG1pZCA9IE1hdGguaW11bChhbDcsIGJoOCk7XG4gIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDgpKSB8IDA7XG4gIGhpID0gTWF0aC5pbXVsKGFoNywgYmg4KTtcbiAgdzE1ID0gKHcxNSArIGxvKSB8IDA7XG4gIHcxNSA9ICh3MTUgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gIGMgPSAoYyArIGhpKSB8IDA7XG4gIGMgPSAoYyArIChtaWQgPj4+IDEzKSkgfCAwO1xuICBjID0gKGMgKyAodzE1ID4+PiAyNikpIHwgMDtcbiAgdzE1ICY9IDB4M2ZmZmZmZjtcbiAgbG8gPSBNYXRoLmltdWwoYWw2LCBibDkpO1xuICBtaWQgPSBNYXRoLmltdWwoYWw2LCBiaDkpO1xuICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw5KSkgfCAwO1xuICBoaSA9IE1hdGguaW11bChhaDYsIGJoOSk7XG4gIHcxNSA9ICh3MTUgKyBsbykgfCAwO1xuICB3MTUgPSAodzE1ICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICBjID0gKGMgKyBoaSkgfCAwO1xuICBjID0gKGMgKyAobWlkID4+PiAxMykpIHwgMDtcbiAgYyA9IChjICsgKHcxNSA+Pj4gMjYpKSB8IDA7XG4gIHcxNSAmPSAweDNmZmZmZmY7XG4gIC8qIGsgPSAxNiAqL1xuICB2YXIgdzE2ID0gYztcbiAgYyA9IDA7XG4gIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw3KTtcbiAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg3KTtcbiAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsNykpIHwgMDtcbiAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDcpO1xuICB3MTYgPSAodzE2ICsgbG8pIHwgMDtcbiAgdzE2ID0gKHcxNiArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgYyA9IChjICsgaGkpIHwgMDtcbiAgYyA9IChjICsgKG1pZCA+Pj4gMTMpKSB8IDA7XG4gIGMgPSAoYyArICh3MTYgPj4+IDI2KSkgfCAwO1xuICB3MTYgJj0gMHgzZmZmZmZmO1xuICBsbyA9IE1hdGguaW11bChhbDgsIGJsOCk7XG4gIG1pZCA9IE1hdGguaW11bChhbDgsIGJoOCk7XG4gIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDgpKSB8IDA7XG4gIGhpID0gTWF0aC5pbXVsKGFoOCwgYmg4KTtcbiAgdzE2ID0gKHcxNiArIGxvKSB8IDA7XG4gIHcxNiA9ICh3MTYgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gIGMgPSAoYyArIGhpKSB8IDA7XG4gIGMgPSAoYyArIChtaWQgPj4+IDEzKSkgfCAwO1xuICBjID0gKGMgKyAodzE2ID4+PiAyNikpIHwgMDtcbiAgdzE2ICY9IDB4M2ZmZmZmZjtcbiAgbG8gPSBNYXRoLmltdWwoYWw3LCBibDkpO1xuICBtaWQgPSBNYXRoLmltdWwoYWw3LCBiaDkpO1xuICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmw5KSkgfCAwO1xuICBoaSA9IE1hdGguaW11bChhaDcsIGJoOSk7XG4gIHcxNiA9ICh3MTYgKyBsbykgfCAwO1xuICB3MTYgPSAodzE2ICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICBjID0gKGMgKyBoaSkgfCAwO1xuICBjID0gKGMgKyAobWlkID4+PiAxMykpIHwgMDtcbiAgYyA9IChjICsgKHcxNiA+Pj4gMjYpKSB8IDA7XG4gIHcxNiAmPSAweDNmZmZmZmY7XG4gIC8qIGsgPSAxNyAqL1xuICB2YXIgdzE3ID0gYztcbiAgYyA9IDA7XG4gIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw4KTtcbiAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg4KTtcbiAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsOCkpIHwgMDtcbiAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDgpO1xuICB3MTcgPSAodzE3ICsgbG8pIHwgMDtcbiAgdzE3ID0gKHcxNyArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgYyA9IChjICsgaGkpIHwgMDtcbiAgYyA9IChjICsgKG1pZCA+Pj4gMTMpKSB8IDA7XG4gIGMgPSAoYyArICh3MTcgPj4+IDI2KSkgfCAwO1xuICB3MTcgJj0gMHgzZmZmZmZmO1xuICBsbyA9IE1hdGguaW11bChhbDgsIGJsOSk7XG4gIG1pZCA9IE1hdGguaW11bChhbDgsIGJoOSk7XG4gIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDkpKSB8IDA7XG4gIGhpID0gTWF0aC5pbXVsKGFoOCwgYmg5KTtcbiAgdzE3ID0gKHcxNyArIGxvKSB8IDA7XG4gIHcxNyA9ICh3MTcgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gIGMgPSAoYyArIGhpKSB8IDA7XG4gIGMgPSAoYyArIChtaWQgPj4+IDEzKSkgfCAwO1xuICBjID0gKGMgKyAodzE3ID4+PiAyNikpIHwgMDtcbiAgdzE3ICY9IDB4M2ZmZmZmZjtcbiAgLyogayA9IDE4ICovXG4gIHZhciB3MTggPSBjO1xuICBjID0gMDtcbiAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDkpO1xuICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDkpO1xuICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmw5KSkgfCAwO1xuICBoaSA9IE1hdGguaW11bChhaDksIGJoOSk7XG4gIHcxOCA9ICh3MTggKyBsbykgfCAwO1xuICB3MTggPSAodzE4ICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICBjID0gKGMgKyBoaSkgfCAwO1xuICBjID0gKGMgKyAobWlkID4+PiAxMykpIHwgMDtcbiAgYyA9IChjICsgKHcxOCA+Pj4gMjYpKSB8IDA7XG4gIHcxOCAmPSAweDNmZmZmZmY7XG4gIG9bMF0gPSB3MDtcbiAgb1sxXSA9IHcxO1xuICBvWzJdID0gdzI7XG4gIG9bM10gPSB3MztcbiAgb1s0XSA9IHc0O1xuICBvWzVdID0gdzU7XG4gIG9bNl0gPSB3NjtcbiAgb1s3XSA9IHc3O1xuICBvWzhdID0gdzg7XG4gIG9bOV0gPSB3OTtcbiAgb1sxMF0gPSB3MTA7XG4gIG9bMTFdID0gdzExO1xuICBvWzEyXSA9IHcxMjtcbiAgb1sxM10gPSB3MTM7XG4gIG9bMTRdID0gdzE0O1xuICBvWzE1XSA9IHcxNTtcbiAgb1sxNl0gPSB3MTY7XG4gIG9bMTddID0gdzE3O1xuICBvWzE4XSA9IHcxODtcbiAgaWYgKGMgIT09IDApIHtcbiAgICBvWzE5XSA9IGM7XG4gICAgb3V0Lmxlbmd0aCsrO1xuICB9XG4gIHJldHVybiBvdXQ7XG59O1xuXG4vLyBQb2x5ZmlsbCBjb21iXG5pZiAoIU1hdGguaW11bClcbiAgY29tYjEwTXVsVG8gPSBzbWFsbE11bFRvO1xuXG5mdW5jdGlvbiBiaWdNdWxUbyhzZWxmLCBudW0sIG91dCkge1xuICBvdXQubmVnYXRpdmUgPSBudW0ubmVnYXRpdmUgXiBzZWxmLm5lZ2F0aXZlO1xuICBvdXQubGVuZ3RoID0gc2VsZi5sZW5ndGggKyBudW0ubGVuZ3RoO1xuXG4gIHZhciBjYXJyeSA9IDA7XG4gIHZhciBobmNhcnJ5ID0gMDtcbiAgZm9yICh2YXIgayA9IDA7IGsgPCBvdXQubGVuZ3RoIC0gMTsgaysrKSB7XG4gICAgLy8gU3VtIGFsbCB3b3JkcyB3aXRoIHRoZSBzYW1lIGBpICsgaiA9IGtgIGFuZCBhY2N1bXVsYXRlIGBuY2FycnlgLFxuICAgIC8vIG5vdGUgdGhhdCBuY2FycnkgY291bGQgYmUgPj0gMHgzZmZmZmZmXG4gICAgdmFyIG5jYXJyeSA9IGhuY2Fycnk7XG4gICAgaG5jYXJyeSA9IDA7XG4gICAgdmFyIHJ3b3JkID0gY2FycnkgJiAweDNmZmZmZmY7XG4gICAgdmFyIG1heEogPSBNYXRoLm1pbihrLCBudW0ubGVuZ3RoIC0gMSk7XG4gICAgZm9yICh2YXIgaiA9IE1hdGgubWF4KDAsIGsgLSBzZWxmLmxlbmd0aCArIDEpOyBqIDw9IG1heEo7IGorKykge1xuICAgICAgdmFyIGkgPSBrIC0gajtcbiAgICAgIHZhciBhID0gc2VsZi53b3Jkc1tpXSB8IDA7XG4gICAgICB2YXIgYiA9IG51bS53b3Jkc1tqXSB8IDA7XG4gICAgICB2YXIgciA9IGEgKiBiO1xuXG4gICAgICB2YXIgbG8gPSByICYgMHgzZmZmZmZmO1xuICAgICAgbmNhcnJ5ID0gKG5jYXJyeSArICgociAvIDB4NDAwMDAwMCkgfCAwKSkgfCAwO1xuICAgICAgbG8gPSAobG8gKyByd29yZCkgfCAwO1xuICAgICAgcndvcmQgPSBsbyAmIDB4M2ZmZmZmZjtcbiAgICAgIG5jYXJyeSA9IChuY2FycnkgKyAobG8gPj4+IDI2KSkgfCAwO1xuXG4gICAgICBobmNhcnJ5ICs9IG5jYXJyeSA+Pj4gMjY7XG4gICAgICBuY2FycnkgJj0gMHgzZmZmZmZmO1xuICAgIH1cbiAgICBvdXQud29yZHNba10gPSByd29yZDtcbiAgICBjYXJyeSA9IG5jYXJyeTtcbiAgICBuY2FycnkgPSBobmNhcnJ5O1xuICB9XG4gIGlmIChjYXJyeSAhPT0gMCkge1xuICAgIG91dC53b3Jkc1trXSA9IGNhcnJ5O1xuICB9IGVsc2Uge1xuICAgIG91dC5sZW5ndGgtLTtcbiAgfVxuXG4gIHJldHVybiBvdXQuc3RyaXAoKTtcbn1cblxuZnVuY3Rpb24ganVtYm9NdWxUbyhzZWxmLCBudW0sIG91dCkge1xuICB2YXIgZmZ0bSA9IG5ldyBGRlRNKCk7XG4gIHJldHVybiBmZnRtLm11bHAoc2VsZiwgbnVtLCBvdXQpO1xufVxuXG5CTi5wcm90b3R5cGUubXVsVG8gPSBmdW5jdGlvbiBtdWxUbyhudW0sIG91dCkge1xuICB2YXIgcmVzO1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGggKyBudW0ubGVuZ3RoO1xuICBpZiAodGhpcy5sZW5ndGggPT09IDEwICYmIG51bS5sZW5ndGggPT09IDEwKVxuICAgIHJlcyA9IGNvbWIxME11bFRvKHRoaXMsIG51bSwgb3V0KTtcbiAgZWxzZSBpZiAobGVuIDwgNjMpXG4gICAgcmVzID0gc21hbGxNdWxUbyh0aGlzLCBudW0sIG91dCk7XG4gIGVsc2UgaWYgKGxlbiA8IDEwMjQpXG4gICAgcmVzID0gYmlnTXVsVG8odGhpcywgbnVtLCBvdXQpO1xuICBlbHNlXG4gICAgcmVzID0ganVtYm9NdWxUbyh0aGlzLCBudW0sIG91dCk7XG4gIHJldHVybiByZXM7XG59O1xuXG4vLyBDb29sZXktVHVrZXkgYWxnb3JpdGhtIGZvciBGRlRcbi8vIHNsaWdodGx5IHJldmlzaXRlZCB0byByZWx5IG9uIGxvb3BpbmcgaW5zdGVhZCBvZiByZWN1cnNpb25cblxuZnVuY3Rpb24gRkZUTSh4LCB5KSB7XG4gIHRoaXMueCA9IHg7XG4gIHRoaXMueSA9IHk7XG59XG5cbkZGVE0ucHJvdG90eXBlLm1ha2VSQlQgPSBmdW5jdGlvbiBtYWtlUkJUKE4pIHtcbiAgdmFyIHQgPSBuZXcgQXJyYXkoTik7XG4gIHZhciBsID0gQk4ucHJvdG90eXBlLl9jb3VudEJpdHMoTikgLSAxO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IE47IGkrKykge1xuICAgIHRbaV0gPSB0aGlzLnJldkJpbihpLCBsLCBOKTtcbiAgfVxuXG4gIHJldHVybiB0O1xufTtcblxuLy8gUmV0dXJucyBiaW5hcnktcmV2ZXJzZWQgcmVwcmVzZW50YXRpb24gb2YgYHhgXG5GRlRNLnByb3RvdHlwZS5yZXZCaW4gPSBmdW5jdGlvbiByZXZCaW4oeCwgbCwgTikge1xuICBpZiAoeCA9PT0gMCB8fCB4ID09PSBOIC0gMSlcbiAgICByZXR1cm4geDtcblxuICB2YXIgcmIgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgIHJiIHw9ICh4ICYgMSkgPDwgKGwgLSBpIC0gMSk7XG4gICAgeCA+Pj0gMTtcbiAgfVxuXG4gIHJldHVybiByYjtcbn07XG5cbi8vIFBlcmZvcm1zIFwidHdlZWRsaW5nXCIgcGhhc2UsIHRoZXJlZm9yZSAnZW11bGF0aW5nJ1xuLy8gYmVoYXZpb3VyIG9mIHRoZSByZWN1cnNpdmUgYWxnb3JpdGhtXG5GRlRNLnByb3RvdHlwZS5wZXJtdXRlID0gZnVuY3Rpb24gcGVybXV0ZShyYnQsIHJ3cywgaXdzLCBydHdzLCBpdHdzLCBOKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgTjsgaSsrKSB7XG4gICAgcnR3c1tpXSA9IHJ3c1tyYnRbaV1dO1xuICAgIGl0d3NbaV0gPSBpd3NbcmJ0W2ldXTtcbiAgfVxufTtcblxuRkZUTS5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24gdHJhbnNmb3JtKHJ3cywgaXdzLCBydHdzLCBpdHdzLCBOLCByYnQpIHtcbiAgdGhpcy5wZXJtdXRlKHJidCwgcndzLCBpd3MsIHJ0d3MsIGl0d3MsIE4pO1xuXG4gIGZvciAodmFyIHMgPSAxOyBzIDwgTjsgcyA8PD0gMSkge1xuICAgIHZhciBsID0gcyA8PCAxO1xuXG4gICAgdmFyIHJ0d2RmID0gTWF0aC5jb3MoMiAqIE1hdGguUEkgLyBsKTtcbiAgICB2YXIgaXR3ZGYgPSBNYXRoLnNpbigyICogTWF0aC5QSSAvIGwpO1xuXG4gICAgZm9yICh2YXIgcCA9IDA7IHAgPCBOOyBwICs9IGwpIHtcbiAgICAgIHZhciBydHdkZl8gPSBydHdkZjtcbiAgICAgIHZhciBpdHdkZl8gPSBpdHdkZjtcblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzOyBqKyspIHtcbiAgICAgICAgdmFyIHJlID0gcnR3c1twICsgal07XG4gICAgICAgIHZhciBpZSA9IGl0d3NbcCArIGpdO1xuXG4gICAgICAgIHZhciBybyA9IHJ0d3NbcCArIGogKyBzXTtcbiAgICAgICAgdmFyIGlvID0gaXR3c1twICsgaiArIHNdO1xuXG4gICAgICAgIHZhciByeCA9IHJ0d2RmXyAqIHJvIC0gaXR3ZGZfICogaW87XG5cbiAgICAgICAgaW8gPSBydHdkZl8gKiBpbyArIGl0d2RmXyAqIHJvO1xuICAgICAgICBybyA9IHJ4O1xuXG4gICAgICAgIHJ0d3NbcCArIGpdID0gcmUgKyBybztcbiAgICAgICAgaXR3c1twICsgal0gPSBpZSArIGlvO1xuXG4gICAgICAgIHJ0d3NbcCArIGogKyBzXSA9IHJlIC0gcm87XG4gICAgICAgIGl0d3NbcCArIGogKyBzXSA9IGllIC0gaW87XG5cbiAgICAgICAgLyoganNoaW50IG1heGRlcHRoIDogZmFsc2UgKi9cbiAgICAgICAgaWYgKGogIT09IGwpIHtcbiAgICAgICAgICByeCA9IHJ0d2RmICogcnR3ZGZfIC0gaXR3ZGYgKiBpdHdkZl87XG5cbiAgICAgICAgICBpdHdkZl8gPSBydHdkZiAqIGl0d2RmXyArIGl0d2RmICogcnR3ZGZfO1xuICAgICAgICAgIHJ0d2RmXyA9IHJ4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5GRlRNLnByb3RvdHlwZS5ndWVzc0xlbjEzYiA9IGZ1bmN0aW9uIGd1ZXNzTGVuMTNiKG4sIG0pIHtcbiAgdmFyIE4gPSBNYXRoLm1heChtLCBuKSB8IDE7XG4gIHZhciBvZGQgPSBOICYgMTtcbiAgdmFyIGkgPSAwO1xuICBmb3IgKE4gPSBOIC8gMiB8IDA7IE47IE4gPSBOID4+PiAxKSB7XG4gICAgaSsrO1xuICB9XG5cbiAgcmV0dXJuIDEgPDwgaSArIDEgKyBvZGQ7XG59O1xuXG5GRlRNLnByb3RvdHlwZS5jb25qdWdhdGUgPSBmdW5jdGlvbiBjb25qdWdhdGUocndzLCBpd3MsIE4pIHtcbiAgaWYgKE4gPD0gMSlcbiAgICByZXR1cm47XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBOIC8gMjsgaSsrKSB7XG4gICAgdmFyIHQgPSByd3NbaV07XG5cbiAgICByd3NbaV0gPSByd3NbTiAtIGkgLSAxXTtcbiAgICByd3NbTiAtIGkgLSAxXSA9IHQ7XG5cbiAgICB0ID0gaXdzW2ldO1xuXG4gICAgaXdzW2ldID0gLWl3c1tOIC0gaSAtIDFdO1xuICAgIGl3c1tOIC0gaSAtIDFdID0gLXQ7XG4gIH1cbn07XG5cbkZGVE0ucHJvdG90eXBlLm5vcm1hbGl6ZTEzYiA9IGZ1bmN0aW9uIG5vcm1hbGl6ZTEzYih3cywgTikge1xuICB2YXIgY2FycnkgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IE4gLyAyOyBpKyspIHtcbiAgICB2YXIgdyA9IE1hdGgucm91bmQod3NbMiAqIGkgKyAxXSAvIE4pICogMHgyMDAwICtcbiAgICAgICAgICAgIE1hdGgucm91bmQod3NbMiAqIGldIC8gTikgK1xuICAgICAgICAgICAgY2Fycnk7XG5cbiAgICB3c1tpXSA9IHcgJiAweDNmZmZmZmY7XG5cbiAgICBpZiAodyA8IDB4NDAwMDAwMCkge1xuICAgICAgY2FycnkgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYXJyeSA9IHcgLyAweDQwMDAwMDAgfCAwO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB3cztcbn07XG5cbkZGVE0ucHJvdG90eXBlLmNvbnZlcnQxM2IgPSBmdW5jdGlvbiBjb252ZXJ0MTNiKHdzLCBsZW4sIHJ3cywgTikge1xuICB2YXIgY2FycnkgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIGNhcnJ5ID0gY2FycnkgKyAod3NbaV0gfCAwKTtcblxuICAgIHJ3c1syICogaV0gICAgID0gY2FycnkgJiAweDFmZmY7IGNhcnJ5ID0gY2FycnkgPj4+IDEzO1xuICAgIHJ3c1syICogaSArIDFdID0gY2FycnkgJiAweDFmZmY7IGNhcnJ5ID0gY2FycnkgPj4+IDEzO1xuICB9XG5cbiAgLy8gUGFkIHdpdGggemVyb2VzXG4gIGZvciAodmFyIGkgPSAyICogbGVuOyBpIDwgTjsgKytpKVxuICAgIHJ3c1tpXSA9IDA7XG5cbiAgYXNzZXJ0KGNhcnJ5ID09PSAwKTtcbiAgYXNzZXJ0KChjYXJyeSAmIH4weDFmZmYpID09PSAwKTtcbn07XG5cbkZGVE0ucHJvdG90eXBlLnN0dWIgPSBmdW5jdGlvbiBzdHViKE4pIHtcbiAgdmFyIHBoID0gbmV3IEFycmF5KE4pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IE47IGkrKylcbiAgICBwaFtpXSA9IDA7XG5cbiAgcmV0dXJuIHBoO1xufTtcblxuRkZUTS5wcm90b3R5cGUubXVscCA9IGZ1bmN0aW9uIG11bHAoeCwgeSwgb3V0KSB7XG4gIHZhciBOID0gMiAqIHRoaXMuZ3Vlc3NMZW4xM2IoeC5sZW5ndGgsIHkubGVuZ3RoKTtcblxuICB2YXIgcmJ0ID0gdGhpcy5tYWtlUkJUKE4pO1xuXG4gIHZhciBfID0gdGhpcy5zdHViKE4pO1xuXG4gIHZhciByd3MgICA9IG5ldyBBcnJheShOKTtcbiAgdmFyIHJ3c3QgID0gbmV3IEFycmF5KE4pO1xuICB2YXIgaXdzdCAgPSBuZXcgQXJyYXkoTik7XG5cbiAgdmFyIG5yd3MgID0gbmV3IEFycmF5KE4pO1xuICB2YXIgbnJ3c3QgPSBuZXcgQXJyYXkoTik7XG4gIHZhciBuaXdzdCA9IG5ldyBBcnJheShOKTtcblxuICB2YXIgcm13cyA9IG91dC53b3JkcztcbiAgcm13cy5sZW5ndGggPSBOO1xuXG4gIHRoaXMuY29udmVydDEzYih4LndvcmRzLCB4Lmxlbmd0aCwgcndzLCBOKTtcbiAgdGhpcy5jb252ZXJ0MTNiKHkud29yZHMsIHkubGVuZ3RoLCBucndzLCBOKTtcblxuICB0aGlzLnRyYW5zZm9ybShyd3MsIF8sIHJ3c3QsIGl3c3QsIE4sIHJidCk7XG4gIHRoaXMudHJhbnNmb3JtKG5yd3MsIF8sIG5yd3N0LCBuaXdzdCwgTiwgcmJ0KTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IE47IGkrKykge1xuICAgIHZhciByeCA9IHJ3c3RbaV0gKiBucndzdFtpXSAtIGl3c3RbaV0gKiBuaXdzdFtpXTtcbiAgICBpd3N0W2ldID0gcndzdFtpXSAqIG5pd3N0W2ldICsgaXdzdFtpXSAqIG5yd3N0W2ldO1xuICAgIHJ3c3RbaV0gPSByeDtcbiAgfVxuXG4gIHRoaXMuY29uanVnYXRlKHJ3c3QsIGl3c3QsIE4pO1xuXG4gIHRoaXMudHJhbnNmb3JtKHJ3c3QsIGl3c3QsIHJtd3MsIF8sIE4sIHJidCk7XG5cbiAgdGhpcy5jb25qdWdhdGUocm13cywgXywgTik7XG5cbiAgdGhpcy5ub3JtYWxpemUxM2Iocm13cywgTik7XG5cbiAgb3V0Lm5lZ2F0aXZlID0geC5uZWdhdGl2ZSBeIHkubmVnYXRpdmU7XG4gIG91dC5sZW5ndGggPSB4Lmxlbmd0aCArIHkubGVuZ3RoO1xuICByZXR1cm4gb3V0LnN0cmlwKCk7XG59O1xuXG4vLyBNdWx0aXBseSBgdGhpc2AgYnkgYG51bWBcbkJOLnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiBtdWwobnVtKSB7XG4gIHZhciBvdXQgPSBuZXcgQk4obnVsbCk7XG4gIG91dC53b3JkcyA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCArIG51bS5sZW5ndGgpO1xuICByZXR1cm4gdGhpcy5tdWxUbyhudW0sIG91dCk7XG59O1xuXG4vLyBNdWx0aXBseSBlbXBsb3lpbmcgRkZUXG5CTi5wcm90b3R5cGUubXVsZiA9IGZ1bmN0aW9uIG11bGYobnVtKSB7XG4gIHZhciBvdXQgPSBuZXcgQk4obnVsbCk7XG4gIG91dC53b3JkcyA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCArIG51bS5sZW5ndGgpO1xuICByZXR1cm4ganVtYm9NdWxUbyh0aGlzLCBudW0sIG91dCk7XG59O1xuXG4vLyBJbi1wbGFjZSBNdWx0aXBsaWNhdGlvblxuQk4ucHJvdG90eXBlLmltdWwgPSBmdW5jdGlvbiBpbXVsKG51bSkge1xuICByZXR1cm4gdGhpcy5jbG9uZSgpLm11bFRvKG51bSwgdGhpcyk7XG59O1xuXG5CTi5wcm90b3R5cGUuaW11bG4gPSBmdW5jdGlvbiBpbXVsbihudW0pIHtcbiAgYXNzZXJ0KHR5cGVvZiBudW0gPT09ICdudW1iZXInKTtcblxuICAvLyBDYXJyeVxuICB2YXIgY2FycnkgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdyA9ICh0aGlzLndvcmRzW2ldIHwgMCkgKiBudW07XG4gICAgdmFyIGxvID0gKHcgJiAweDNmZmZmZmYpICsgKGNhcnJ5ICYgMHgzZmZmZmZmKTtcbiAgICBjYXJyeSA+Pj0gMjY7XG4gICAgY2FycnkgKz0gKHcgLyAweDQwMDAwMDApIHwgMDtcbiAgICAvLyBOT1RFOiBsbyBpcyAyN2JpdCBtYXhpbXVtXG4gICAgY2FycnkgKz0gbG8gPj4+IDI2O1xuICAgIHRoaXMud29yZHNbaV0gPSBsbyAmIDB4M2ZmZmZmZjtcbiAgfVxuXG4gIGlmIChjYXJyeSAhPT0gMCkge1xuICAgIHRoaXMud29yZHNbaV0gPSBjYXJyeTtcbiAgICB0aGlzLmxlbmd0aCsrO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5CTi5wcm90b3R5cGUubXVsbiA9IGZ1bmN0aW9uIG11bG4obnVtKSB7XG4gIHJldHVybiB0aGlzLmNsb25lKCkuaW11bG4obnVtKTtcbn07XG5cbi8vIGB0aGlzYCAqIGB0aGlzYFxuQk4ucHJvdG90eXBlLnNxciA9IGZ1bmN0aW9uIHNxcigpIHtcbiAgcmV0dXJuIHRoaXMubXVsKHRoaXMpO1xufTtcblxuLy8gYHRoaXNgICogYHRoaXNgIGluLXBsYWNlXG5CTi5wcm90b3R5cGUuaXNxciA9IGZ1bmN0aW9uIGlzcXIoKSB7XG4gIHJldHVybiB0aGlzLmltdWwodGhpcy5jbG9uZSgpKTtcbn07XG5cbi8vIE1hdGgucG93KGB0aGlzYCwgYG51bWApXG5CTi5wcm90b3R5cGUucG93ID0gZnVuY3Rpb24gcG93KG51bSkge1xuICB2YXIgdyA9IHRvQml0QXJyYXkobnVtKTtcbiAgaWYgKHcubGVuZ3RoID09PSAwKVxuICAgIHJldHVybiBuZXcgQk4oMSk7XG5cbiAgLy8gU2tpcCBsZWFkaW5nIHplcm9lc1xuICB2YXIgcmVzID0gdGhpcztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB3Lmxlbmd0aDsgaSsrLCByZXMgPSByZXMuc3FyKCkpXG4gICAgaWYgKHdbaV0gIT09IDApXG4gICAgICBicmVhaztcblxuICBpZiAoKytpIDwgdy5sZW5ndGgpIHtcbiAgICBmb3IgKHZhciBxID0gcmVzLnNxcigpOyBpIDwgdy5sZW5ndGg7IGkrKywgcSA9IHEuc3FyKCkpIHtcbiAgICAgIGlmICh3W2ldID09PSAwKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIHJlcyA9IHJlcy5tdWwocSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cbi8vIFNoaWZ0LWxlZnQgaW4tcGxhY2VcbkJOLnByb3RvdHlwZS5pdXNobG4gPSBmdW5jdGlvbiBpdXNobG4oYml0cykge1xuICBhc3NlcnQodHlwZW9mIGJpdHMgPT09ICdudW1iZXInICYmIGJpdHMgPj0gMCk7XG4gIHZhciByID0gYml0cyAlIDI2O1xuICB2YXIgcyA9IChiaXRzIC0gcikgLyAyNjtcbiAgdmFyIGNhcnJ5TWFzayA9ICgweDNmZmZmZmYgPj4+ICgyNiAtIHIpKSA8PCAoMjYgLSByKTtcblxuICBpZiAociAhPT0gMCkge1xuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbmV3Q2FycnkgPSB0aGlzLndvcmRzW2ldICYgY2FycnlNYXNrO1xuICAgICAgdmFyIGMgPSAoKHRoaXMud29yZHNbaV0gfCAwKSAtIG5ld0NhcnJ5KSA8PCByO1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IGMgfCBjYXJyeTtcbiAgICAgIGNhcnJ5ID0gbmV3Q2FycnkgPj4+ICgyNiAtIHIpO1xuICAgIH1cbiAgICBpZiAoY2FycnkpIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSBjYXJyeTtcbiAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgfVxuICB9XG5cbiAgaWYgKHMgIT09IDApIHtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgIHRoaXMud29yZHNbaSArIHNdID0gdGhpcy53b3Jkc1tpXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHM7IGkrKylcbiAgICAgIHRoaXMud29yZHNbaV0gPSAwO1xuICAgIHRoaXMubGVuZ3RoICs9IHM7XG4gIH1cblxuICByZXR1cm4gdGhpcy5zdHJpcCgpO1xufTtcblxuQk4ucHJvdG90eXBlLmlzaGxuID0gZnVuY3Rpb24gaXNobG4oYml0cykge1xuICAvLyBUT0RPKGluZHV0bnkpOiBpbXBsZW1lbnQgbWVcbiAgYXNzZXJ0KHRoaXMubmVnYXRpdmUgPT09IDApO1xuICByZXR1cm4gdGhpcy5pdXNobG4oYml0cyk7XG59O1xuXG4vLyBTaGlmdC1yaWdodCBpbi1wbGFjZVxuLy8gTk9URTogYGhpbnRgIGlzIGEgbG93ZXN0IGJpdCBiZWZvcmUgdHJhaWxpbmcgemVyb2VzXG4vLyBOT1RFOiBpZiBgZXh0ZW5kZWRgIGlzIHByZXNlbnQgLSBpdCB3aWxsIGJlIGZpbGxlZCB3aXRoIGRlc3Ryb3llZCBiaXRzXG5CTi5wcm90b3R5cGUuaXVzaHJuID0gZnVuY3Rpb24gaXVzaHJuKGJpdHMsIGhpbnQsIGV4dGVuZGVkKSB7XG4gIGFzc2VydCh0eXBlb2YgYml0cyA9PT0gJ251bWJlcicgJiYgYml0cyA+PSAwKTtcbiAgdmFyIGg7XG4gIGlmIChoaW50KVxuICAgIGggPSAoaGludCAtIChoaW50ICUgMjYpKSAvIDI2O1xuICBlbHNlXG4gICAgaCA9IDA7XG5cbiAgdmFyIHIgPSBiaXRzICUgMjY7XG4gIHZhciBzID0gTWF0aC5taW4oKGJpdHMgLSByKSAvIDI2LCB0aGlzLmxlbmd0aCk7XG4gIHZhciBtYXNrID0gMHgzZmZmZmZmIF4gKCgweDNmZmZmZmYgPj4+IHIpIDw8IHIpO1xuICB2YXIgbWFza2VkV29yZHMgPSBleHRlbmRlZDtcblxuICBoIC09IHM7XG4gIGggPSBNYXRoLm1heCgwLCBoKTtcblxuICAvLyBFeHRlbmRlZCBtb2RlLCBjb3B5IG1hc2tlZCBwYXJ0XG4gIGlmIChtYXNrZWRXb3Jkcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgczsgaSsrKVxuICAgICAgbWFza2VkV29yZHMud29yZHNbaV0gPSB0aGlzLndvcmRzW2ldO1xuICAgIG1hc2tlZFdvcmRzLmxlbmd0aCA9IHM7XG4gIH1cblxuICBpZiAocyA9PT0gMCkge1xuICAgIC8vIE5vLW9wLCB3ZSBzaG91bGQgbm90IG1vdmUgYW55dGhpbmcgYXQgYWxsXG4gIH0gZWxzZSBpZiAodGhpcy5sZW5ndGggPiBzKSB7XG4gICAgdGhpcy5sZW5ndGggLT0gcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspXG4gICAgICB0aGlzLndvcmRzW2ldID0gdGhpcy53b3Jkc1tpICsgc107XG4gIH0gZWxzZSB7XG4gICAgdGhpcy53b3Jkc1swXSA9IDA7XG4gICAgdGhpcy5sZW5ndGggPSAxO1xuICB9XG5cbiAgdmFyIGNhcnJ5ID0gMDtcbiAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwICYmIChjYXJyeSAhPT0gMCB8fCBpID49IGgpOyBpLS0pIHtcbiAgICB2YXIgd29yZCA9IHRoaXMud29yZHNbaV0gfCAwO1xuICAgIHRoaXMud29yZHNbaV0gPSAoY2FycnkgPDwgKDI2IC0gcikpIHwgKHdvcmQgPj4+IHIpO1xuICAgIGNhcnJ5ID0gd29yZCAmIG1hc2s7XG4gIH1cblxuICAvLyBQdXNoIGNhcnJpZWQgYml0cyBhcyBhIG1hc2tcbiAgaWYgKG1hc2tlZFdvcmRzICYmIGNhcnJ5ICE9PSAwKVxuICAgIG1hc2tlZFdvcmRzLndvcmRzW21hc2tlZFdvcmRzLmxlbmd0aCsrXSA9IGNhcnJ5O1xuXG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRoaXMud29yZHNbMF0gPSAwO1xuICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLnN0cmlwKCk7XG59O1xuXG5CTi5wcm90b3R5cGUuaXNocm4gPSBmdW5jdGlvbiBpc2hybihiaXRzLCBoaW50LCBleHRlbmRlZCkge1xuICAvLyBUT0RPKGluZHV0bnkpOiBpbXBsZW1lbnQgbWVcbiAgYXNzZXJ0KHRoaXMubmVnYXRpdmUgPT09IDApO1xuICByZXR1cm4gdGhpcy5pdXNocm4oYml0cywgaGludCwgZXh0ZW5kZWQpO1xufTtcblxuLy8gU2hpZnQtbGVmdFxuQk4ucHJvdG90eXBlLnNobG4gPSBmdW5jdGlvbiBzaGxuKGJpdHMpIHtcbiAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pc2hsbihiaXRzKTtcbn07XG5cbkJOLnByb3RvdHlwZS51c2hsbiA9IGZ1bmN0aW9uIHVzaGxuKGJpdHMpIHtcbiAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pdXNobG4oYml0cyk7XG59O1xuXG4vLyBTaGlmdC1yaWdodFxuQk4ucHJvdG90eXBlLnNocm4gPSBmdW5jdGlvbiBzaHJuKGJpdHMpIHtcbiAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pc2hybihiaXRzKTtcbn07XG5cbkJOLnByb3RvdHlwZS51c2hybiA9IGZ1bmN0aW9uIHVzaHJuKGJpdHMpIHtcbiAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pdXNocm4oYml0cyk7XG59O1xuXG4vLyBUZXN0IGlmIG4gYml0IGlzIHNldFxuQk4ucHJvdG90eXBlLnRlc3RuID0gZnVuY3Rpb24gdGVzdG4oYml0KSB7XG4gIGFzc2VydCh0eXBlb2YgYml0ID09PSAnbnVtYmVyJyAmJiBiaXQgPj0gMCk7XG4gIHZhciByID0gYml0ICUgMjY7XG4gIHZhciBzID0gKGJpdCAtIHIpIC8gMjY7XG4gIHZhciBxID0gMSA8PCByO1xuXG4gIC8vIEZhc3QgY2FzZTogYml0IGlzIG11Y2ggaGlnaGVyIHRoYW4gYWxsIGV4aXN0aW5nIHdvcmRzXG4gIGlmICh0aGlzLmxlbmd0aCA8PSBzKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gQ2hlY2sgYml0IGFuZCByZXR1cm5cbiAgdmFyIHcgPSB0aGlzLndvcmRzW3NdO1xuXG4gIHJldHVybiAhISh3ICYgcSk7XG59O1xuXG4vLyBSZXR1cm4gb25seSBsb3dlcnMgYml0cyBvZiBudW1iZXIgKGluLXBsYWNlKVxuQk4ucHJvdG90eXBlLmltYXNrbiA9IGZ1bmN0aW9uIGltYXNrbihiaXRzKSB7XG4gIGFzc2VydCh0eXBlb2YgYml0cyA9PT0gJ251bWJlcicgJiYgYml0cyA+PSAwKTtcbiAgdmFyIHIgPSBiaXRzICUgMjY7XG4gIHZhciBzID0gKGJpdHMgLSByKSAvIDI2O1xuXG4gIGFzc2VydCh0aGlzLm5lZ2F0aXZlID09PSAwLCAnaW1hc2tuIHdvcmtzIG9ubHkgd2l0aCBwb3NpdGl2ZSBudW1iZXJzJyk7XG5cbiAgaWYgKHIgIT09IDApXG4gICAgcysrO1xuICB0aGlzLmxlbmd0aCA9IE1hdGgubWluKHMsIHRoaXMubGVuZ3RoKTtcblxuICBpZiAociAhPT0gMCkge1xuICAgIHZhciBtYXNrID0gMHgzZmZmZmZmIF4gKCgweDNmZmZmZmYgPj4+IHIpIDw8IHIpO1xuICAgIHRoaXMud29yZHNbdGhpcy5sZW5ndGggLSAxXSAmPSBtYXNrO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbn07XG5cbi8vIFJldHVybiBvbmx5IGxvd2VycyBiaXRzIG9mIG51bWJlclxuQk4ucHJvdG90eXBlLm1hc2tuID0gZnVuY3Rpb24gbWFza24oYml0cykge1xuICByZXR1cm4gdGhpcy5jbG9uZSgpLmltYXNrbihiaXRzKTtcbn07XG5cbi8vIEFkZCBwbGFpbiBudW1iZXIgYG51bWAgdG8gYHRoaXNgXG5CTi5wcm90b3R5cGUuaWFkZG4gPSBmdW5jdGlvbiBpYWRkbihudW0pIHtcbiAgYXNzZXJ0KHR5cGVvZiBudW0gPT09ICdudW1iZXInKTtcbiAgaWYgKG51bSA8IDApXG4gICAgcmV0dXJuIHRoaXMuaXN1Ym4oLW51bSk7XG5cbiAgLy8gUG9zc2libGUgc2lnbiBjaGFuZ2VcbiAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEgJiYgKHRoaXMud29yZHNbMF0gfCAwKSA8IG51bSkge1xuICAgICAgdGhpcy53b3Jkc1swXSA9IG51bSAtICh0aGlzLndvcmRzWzBdIHwgMCk7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgIHRoaXMuaXN1Ym4obnVtKTtcbiAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIEFkZCB3aXRob3V0IGNoZWNrc1xuICByZXR1cm4gdGhpcy5faWFkZG4obnVtKTtcbn07XG5cbkJOLnByb3RvdHlwZS5faWFkZG4gPSBmdW5jdGlvbiBfaWFkZG4obnVtKSB7XG4gIHRoaXMud29yZHNbMF0gKz0gbnVtO1xuXG4gIC8vIENhcnJ5XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGggJiYgdGhpcy53b3Jkc1tpXSA+PSAweDQwMDAwMDA7IGkrKykge1xuICAgIHRoaXMud29yZHNbaV0gLT0gMHg0MDAwMDAwO1xuICAgIGlmIChpID09PSB0aGlzLmxlbmd0aCAtIDEpXG4gICAgICB0aGlzLndvcmRzW2kgKyAxXSA9IDE7XG4gICAgZWxzZVxuICAgICAgdGhpcy53b3Jkc1tpICsgMV0rKztcbiAgfVxuICB0aGlzLmxlbmd0aCA9IE1hdGgubWF4KHRoaXMubGVuZ3RoLCBpICsgMSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBTdWJ0cmFjdCBwbGFpbiBudW1iZXIgYG51bWAgZnJvbSBgdGhpc2BcbkJOLnByb3RvdHlwZS5pc3VibiA9IGZ1bmN0aW9uIGlzdWJuKG51bSkge1xuICBhc3NlcnQodHlwZW9mIG51bSA9PT0gJ251bWJlcicpO1xuICBpZiAobnVtIDwgMClcbiAgICByZXR1cm4gdGhpcy5pYWRkbigtbnVtKTtcblxuICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgIHRoaXMuaWFkZG4obnVtKTtcbiAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHRoaXMud29yZHNbMF0gLT0gbnVtO1xuXG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMSAmJiB0aGlzLndvcmRzWzBdIDwgMCkge1xuICAgIHRoaXMud29yZHNbMF0gPSAtdGhpcy53b3Jkc1swXTtcbiAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgfSBlbHNlIHtcbiAgICAvLyBDYXJyeVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGggJiYgdGhpcy53b3Jkc1tpXSA8IDA7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSArPSAweDQwMDAwMDA7XG4gICAgICB0aGlzLndvcmRzW2kgKyAxXSAtPSAxO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzLnN0cmlwKCk7XG59O1xuXG5CTi5wcm90b3R5cGUuYWRkbiA9IGZ1bmN0aW9uIGFkZG4obnVtKSB7XG4gIHJldHVybiB0aGlzLmNsb25lKCkuaWFkZG4obnVtKTtcbn07XG5cbkJOLnByb3RvdHlwZS5zdWJuID0gZnVuY3Rpb24gc3VibihudW0pIHtcbiAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pc3VibihudW0pO1xufTtcblxuQk4ucHJvdG90eXBlLmlhYnMgPSBmdW5jdGlvbiBpYWJzKCkge1xuICB0aGlzLm5lZ2F0aXZlID0gMDtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbkJOLnByb3RvdHlwZS5hYnMgPSBmdW5jdGlvbiBhYnMoKSB7XG4gIHJldHVybiB0aGlzLmNsb25lKCkuaWFicygpO1xufTtcblxuQk4ucHJvdG90eXBlLl9pc2hsbnN1Ym11bCA9IGZ1bmN0aW9uIF9pc2hsbnN1Ym11bChudW0sIG11bCwgc2hpZnQpIHtcbiAgLy8gQmlnZ2VyIHN0b3JhZ2UgaXMgbmVlZGVkXG4gIHZhciBsZW4gPSBudW0ubGVuZ3RoICsgc2hpZnQ7XG4gIHZhciBpO1xuICBpZiAodGhpcy53b3Jkcy5sZW5ndGggPCBsZW4pIHtcbiAgICB2YXIgdCA9IG5ldyBBcnJheShsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKylcbiAgICAgIHRbaV0gPSB0aGlzLndvcmRzW2ldO1xuICAgIHRoaXMud29yZHMgPSB0O1xuICB9IGVsc2Uge1xuICAgIGkgPSB0aGlzLmxlbmd0aDtcbiAgfVxuXG4gIC8vIFplcm9pZnkgcmVzdFxuICB0aGlzLmxlbmd0aCA9IE1hdGgubWF4KHRoaXMubGVuZ3RoLCBsZW4pO1xuICBmb3IgKDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspXG4gICAgdGhpcy53b3Jkc1tpXSA9IDA7XG5cbiAgdmFyIGNhcnJ5ID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW0ubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdyA9ICh0aGlzLndvcmRzW2kgKyBzaGlmdF0gfCAwKSArIGNhcnJ5O1xuICAgIHZhciByaWdodCA9IChudW0ud29yZHNbaV0gfCAwKSAqIG11bDtcbiAgICB3IC09IHJpZ2h0ICYgMHgzZmZmZmZmO1xuICAgIGNhcnJ5ID0gKHcgPj4gMjYpIC0gKChyaWdodCAvIDB4NDAwMDAwMCkgfCAwKTtcbiAgICB0aGlzLndvcmRzW2kgKyBzaGlmdF0gPSB3ICYgMHgzZmZmZmZmO1xuICB9XG4gIGZvciAoOyBpIDwgdGhpcy5sZW5ndGggLSBzaGlmdDsgaSsrKSB7XG4gICAgdmFyIHcgPSAodGhpcy53b3Jkc1tpICsgc2hpZnRdIHwgMCkgKyBjYXJyeTtcbiAgICBjYXJyeSA9IHcgPj4gMjY7XG4gICAgdGhpcy53b3Jkc1tpICsgc2hpZnRdID0gdyAmIDB4M2ZmZmZmZjtcbiAgfVxuXG4gIGlmIChjYXJyeSA9PT0gMClcbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuXG4gIC8vIFN1YnRyYWN0aW9uIG92ZXJmbG93XG4gIGFzc2VydChjYXJyeSA9PT0gLTEpO1xuICBjYXJyeSA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB3ID0gLSh0aGlzLndvcmRzW2ldIHwgMCkgKyBjYXJyeTtcbiAgICBjYXJyeSA9IHcgPj4gMjY7XG4gICAgdGhpcy53b3Jkc1tpXSA9IHcgJiAweDNmZmZmZmY7XG4gIH1cbiAgdGhpcy5uZWdhdGl2ZSA9IDE7XG5cbiAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbn07XG5cbkJOLnByb3RvdHlwZS5fd29yZERpdiA9IGZ1bmN0aW9uIF93b3JkRGl2KG51bSwgbW9kZSkge1xuICB2YXIgc2hpZnQgPSB0aGlzLmxlbmd0aCAtIG51bS5sZW5ndGg7XG5cbiAgdmFyIGEgPSB0aGlzLmNsb25lKCk7XG4gIHZhciBiID0gbnVtO1xuXG4gIC8vIE5vcm1hbGl6ZVxuICB2YXIgYmhpID0gYi53b3Jkc1tiLmxlbmd0aCAtIDFdIHwgMDtcbiAgdmFyIGJoaUJpdHMgPSB0aGlzLl9jb3VudEJpdHMoYmhpKTtcbiAgc2hpZnQgPSAyNiAtIGJoaUJpdHM7XG4gIGlmIChzaGlmdCAhPT0gMCkge1xuICAgIGIgPSBiLnVzaGxuKHNoaWZ0KTtcbiAgICBhLml1c2hsbihzaGlmdCk7XG4gICAgYmhpID0gYi53b3Jkc1tiLmxlbmd0aCAtIDFdIHwgMDtcbiAgfVxuXG4gIC8vIEluaXRpYWxpemUgcXVvdGllbnRcbiAgdmFyIG0gPSBhLmxlbmd0aCAtIGIubGVuZ3RoO1xuICB2YXIgcTtcblxuICBpZiAobW9kZSAhPT0gJ21vZCcpIHtcbiAgICBxID0gbmV3IEJOKG51bGwpO1xuICAgIHEubGVuZ3RoID0gbSArIDE7XG4gICAgcS53b3JkcyA9IG5ldyBBcnJheShxLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxLmxlbmd0aDsgaSsrKVxuICAgICAgcS53b3Jkc1tpXSA9IDA7XG4gIH1cblxuICB2YXIgZGlmZiA9IGEuY2xvbmUoKS5faXNobG5zdWJtdWwoYiwgMSwgbSk7XG4gIGlmIChkaWZmLm5lZ2F0aXZlID09PSAwKSB7XG4gICAgYSA9IGRpZmY7XG4gICAgaWYgKHEpXG4gICAgICBxLndvcmRzW21dID0gMTtcbiAgfVxuXG4gIGZvciAodmFyIGogPSBtIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICB2YXIgcWogPSAoYS53b3Jkc1tiLmxlbmd0aCArIGpdIHwgMCkgKiAweDQwMDAwMDAgK1xuICAgICAgICAgICAgIChhLndvcmRzW2IubGVuZ3RoICsgaiAtIDFdIHwgMCk7XG5cbiAgICAvLyBOT1RFOiAocWogLyBiaGkpIGlzICgweDNmZmZmZmYgKiAweDQwMDAwMDAgKyAweDNmZmZmZmYpIC8gMHgyMDAwMDAwIG1heFxuICAgIC8vICgweDdmZmZmZmYpXG4gICAgcWogPSBNYXRoLm1pbigocWogLyBiaGkpIHwgMCwgMHgzZmZmZmZmKTtcblxuICAgIGEuX2lzaGxuc3VibXVsKGIsIHFqLCBqKTtcbiAgICB3aGlsZSAoYS5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgcWotLTtcbiAgICAgIGEubmVnYXRpdmUgPSAwO1xuICAgICAgYS5faXNobG5zdWJtdWwoYiwgMSwgaik7XG4gICAgICBpZiAoYS5jbXBuKDApICE9PSAwKVxuICAgICAgICBhLm5lZ2F0aXZlIF49IDE7XG4gICAgfVxuICAgIGlmIChxKVxuICAgICAgcS53b3Jkc1tqXSA9IHFqO1xuICB9XG4gIGlmIChxKVxuICAgIHEuc3RyaXAoKTtcbiAgYS5zdHJpcCgpO1xuXG4gIC8vIERlbm9ybWFsaXplXG4gIGlmIChtb2RlICE9PSAnZGl2JyAmJiBzaGlmdCAhPT0gMClcbiAgICBhLml1c2hybihzaGlmdCk7XG4gIHJldHVybiB7IGRpdjogcSA/IHEgOiBudWxsLCBtb2Q6IGEgfTtcbn07XG5cbkJOLnByb3RvdHlwZS5kaXZtb2QgPSBmdW5jdGlvbiBkaXZtb2QobnVtLCBtb2RlLCBwb3NpdGl2ZSkge1xuICBhc3NlcnQobnVtLmNtcG4oMCkgIT09IDApO1xuXG4gIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwICYmIG51bS5uZWdhdGl2ZSA9PT0gMCkge1xuICAgIHZhciByZXMgPSB0aGlzLm5lZygpLmRpdm1vZChudW0sIG1vZGUpO1xuICAgIHZhciBkaXY7XG4gICAgdmFyIG1vZDtcbiAgICBpZiAobW9kZSAhPT0gJ21vZCcpXG4gICAgICBkaXYgPSByZXMuZGl2Lm5lZygpO1xuICAgIGlmIChtb2RlICE9PSAnZGl2Jykge1xuICAgICAgbW9kID0gcmVzLm1vZC5uZWcoKTtcbiAgICAgIGlmIChwb3NpdGl2ZSAmJiBtb2QubmVnKVxuICAgICAgICBtb2QgPSBtb2QuYWRkKG51bSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBkaXY6IGRpdixcbiAgICAgIG1vZDogbW9kXG4gICAgfTtcbiAgfSBlbHNlIGlmICh0aGlzLm5lZ2F0aXZlID09PSAwICYmIG51bS5uZWdhdGl2ZSAhPT0gMCkge1xuICAgIHZhciByZXMgPSB0aGlzLmRpdm1vZChudW0ubmVnKCksIG1vZGUpO1xuICAgIHZhciBkaXY7XG4gICAgaWYgKG1vZGUgIT09ICdtb2QnKVxuICAgICAgZGl2ID0gcmVzLmRpdi5uZWcoKTtcbiAgICByZXR1cm4geyBkaXY6IGRpdiwgbW9kOiByZXMubW9kIH07XG4gIH0gZWxzZSBpZiAoKHRoaXMubmVnYXRpdmUgJiBudW0ubmVnYXRpdmUpICE9PSAwKSB7XG4gICAgdmFyIHJlcyA9IHRoaXMubmVnKCkuZGl2bW9kKG51bS5uZWcoKSwgbW9kZSk7XG4gICAgdmFyIG1vZDtcbiAgICBpZiAobW9kZSAhPT0gJ2RpdicpIHtcbiAgICAgIG1vZCA9IHJlcy5tb2QubmVnKCk7XG4gICAgICBpZiAocG9zaXRpdmUgJiYgbW9kLm5lZylcbiAgICAgICAgbW9kID0gbW9kLmlzdWIobnVtKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGRpdjogcmVzLmRpdixcbiAgICAgIG1vZDogbW9kXG4gICAgfTtcbiAgfVxuXG4gIC8vIEJvdGggbnVtYmVycyBhcmUgcG9zaXRpdmUgYXQgdGhpcyBwb2ludFxuXG4gIC8vIFN0cmlwIGJvdGggbnVtYmVycyB0byBhcHByb3hpbWF0ZSBzaGlmdCB2YWx1ZVxuICBpZiAobnVtLmxlbmd0aCA+IHRoaXMubGVuZ3RoIHx8IHRoaXMuY21wKG51bSkgPCAwKVxuICAgIHJldHVybiB7IGRpdjogbmV3IEJOKDApLCBtb2Q6IHRoaXMgfTtcblxuICAvLyBWZXJ5IHNob3J0IHJlZHVjdGlvblxuICBpZiAobnVtLmxlbmd0aCA9PT0gMSkge1xuICAgIGlmIChtb2RlID09PSAnZGl2JylcbiAgICAgIHJldHVybiB7IGRpdjogdGhpcy5kaXZuKG51bS53b3Jkc1swXSksIG1vZDogbnVsbCB9O1xuICAgIGVsc2UgaWYgKG1vZGUgPT09ICdtb2QnKVxuICAgICAgcmV0dXJuIHsgZGl2OiBudWxsLCBtb2Q6IG5ldyBCTih0aGlzLm1vZG4obnVtLndvcmRzWzBdKSkgfTtcbiAgICByZXR1cm4ge1xuICAgICAgZGl2OiB0aGlzLmRpdm4obnVtLndvcmRzWzBdKSxcbiAgICAgIG1vZDogbmV3IEJOKHRoaXMubW9kbihudW0ud29yZHNbMF0pKVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gdGhpcy5fd29yZERpdihudW0sIG1vZGUpO1xufTtcblxuLy8gRmluZCBgdGhpc2AgLyBgbnVtYFxuQk4ucHJvdG90eXBlLmRpdiA9IGZ1bmN0aW9uIGRpdihudW0pIHtcbiAgcmV0dXJuIHRoaXMuZGl2bW9kKG51bSwgJ2RpdicsIGZhbHNlKS5kaXY7XG59O1xuXG4vLyBGaW5kIGB0aGlzYCAlIGBudW1gXG5CTi5wcm90b3R5cGUubW9kID0gZnVuY3Rpb24gbW9kKG51bSkge1xuICByZXR1cm4gdGhpcy5kaXZtb2QobnVtLCAnbW9kJywgZmFsc2UpLm1vZDtcbn07XG5cbkJOLnByb3RvdHlwZS51bW9kID0gZnVuY3Rpb24gdW1vZChudW0pIHtcbiAgcmV0dXJuIHRoaXMuZGl2bW9kKG51bSwgJ21vZCcsIHRydWUpLm1vZDtcbn07XG5cbi8vIEZpbmQgUm91bmQoYHRoaXNgIC8gYG51bWApXG5CTi5wcm90b3R5cGUuZGl2Um91bmQgPSBmdW5jdGlvbiBkaXZSb3VuZChudW0pIHtcbiAgdmFyIGRtID0gdGhpcy5kaXZtb2QobnVtKTtcblxuICAvLyBGYXN0IGNhc2UgLSBleGFjdCBkaXZpc2lvblxuICBpZiAoZG0ubW9kLmNtcG4oMCkgPT09IDApXG4gICAgcmV0dXJuIGRtLmRpdjtcblxuICB2YXIgbW9kID0gZG0uZGl2Lm5lZ2F0aXZlICE9PSAwID8gZG0ubW9kLmlzdWIobnVtKSA6IGRtLm1vZDtcblxuICB2YXIgaGFsZiA9IG51bS51c2hybigxKTtcbiAgdmFyIHIyID0gbnVtLmFuZGxuKDEpO1xuICB2YXIgY21wID0gbW9kLmNtcChoYWxmKTtcblxuICAvLyBSb3VuZCBkb3duXG4gIGlmIChjbXAgPCAwIHx8IHIyID09PSAxICYmIGNtcCA9PT0gMClcbiAgICByZXR1cm4gZG0uZGl2O1xuXG4gIC8vIFJvdW5kIHVwXG4gIHJldHVybiBkbS5kaXYubmVnYXRpdmUgIT09IDAgPyBkbS5kaXYuaXN1Ym4oMSkgOiBkbS5kaXYuaWFkZG4oMSk7XG59O1xuXG5CTi5wcm90b3R5cGUubW9kbiA9IGZ1bmN0aW9uIG1vZG4obnVtKSB7XG4gIGFzc2VydChudW0gPD0gMHgzZmZmZmZmKTtcbiAgdmFyIHAgPSAoMSA8PCAyNikgJSBudW07XG5cbiAgdmFyIGFjYyA9IDA7XG4gIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgIGFjYyA9IChwICogYWNjICsgKHRoaXMud29yZHNbaV0gfCAwKSkgJSBudW07XG5cbiAgcmV0dXJuIGFjYztcbn07XG5cbi8vIEluLXBsYWNlIGRpdmlzaW9uIGJ5IG51bWJlclxuQk4ucHJvdG90eXBlLmlkaXZuID0gZnVuY3Rpb24gaWRpdm4obnVtKSB7XG4gIGFzc2VydChudW0gPD0gMHgzZmZmZmZmKTtcblxuICB2YXIgY2FycnkgPSAwO1xuICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciB3ID0gKHRoaXMud29yZHNbaV0gfCAwKSArIGNhcnJ5ICogMHg0MDAwMDAwO1xuICAgIHRoaXMud29yZHNbaV0gPSAodyAvIG51bSkgfCAwO1xuICAgIGNhcnJ5ID0gdyAlIG51bTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLnN0cmlwKCk7XG59O1xuXG5CTi5wcm90b3R5cGUuZGl2biA9IGZ1bmN0aW9uIGRpdm4obnVtKSB7XG4gIHJldHVybiB0aGlzLmNsb25lKCkuaWRpdm4obnVtKTtcbn07XG5cbkJOLnByb3RvdHlwZS5lZ2NkID0gZnVuY3Rpb24gZWdjZChwKSB7XG4gIGFzc2VydChwLm5lZ2F0aXZlID09PSAwKTtcbiAgYXNzZXJ0KHAuY21wbigwKSAhPT0gMCk7XG5cbiAgdmFyIHggPSB0aGlzO1xuICB2YXIgeSA9IHAuY2xvbmUoKTtcblxuICBpZiAoeC5uZWdhdGl2ZSAhPT0gMClcbiAgICB4ID0geC51bW9kKHApO1xuICBlbHNlXG4gICAgeCA9IHguY2xvbmUoKTtcblxuICAvLyBBICogeCArIEIgKiB5ID0geFxuICB2YXIgQSA9IG5ldyBCTigxKTtcbiAgdmFyIEIgPSBuZXcgQk4oMCk7XG5cbiAgLy8gQyAqIHggKyBEICogeSA9IHlcbiAgdmFyIEMgPSBuZXcgQk4oMCk7XG4gIHZhciBEID0gbmV3IEJOKDEpO1xuXG4gIHZhciBnID0gMDtcblxuICB3aGlsZSAoeC5pc0V2ZW4oKSAmJiB5LmlzRXZlbigpKSB7XG4gICAgeC5pdXNocm4oMSk7XG4gICAgeS5pdXNocm4oMSk7XG4gICAgKytnO1xuICB9XG5cbiAgdmFyIHlwID0geS5jbG9uZSgpO1xuICB2YXIgeHAgPSB4LmNsb25lKCk7XG5cbiAgd2hpbGUgKHguY21wbigwKSAhPT0gMCkge1xuICAgIHdoaWxlICh4LmlzRXZlbigpKSB7XG4gICAgICB4Lml1c2hybigxKTtcbiAgICAgIGlmIChBLmlzRXZlbigpICYmIEIuaXNFdmVuKCkpIHtcbiAgICAgICAgQS5pdXNocm4oMSk7XG4gICAgICAgIEIuaXVzaHJuKDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgQS5pYWRkKHlwKS5pdXNocm4oMSk7XG4gICAgICAgIEIuaXN1Yih4cCkuaXVzaHJuKDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHdoaWxlICh5LmlzRXZlbigpKSB7XG4gICAgICB5Lml1c2hybigxKTtcbiAgICAgIGlmIChDLmlzRXZlbigpICYmIEQuaXNFdmVuKCkpIHtcbiAgICAgICAgQy5pdXNocm4oMSk7XG4gICAgICAgIEQuaXVzaHJuKDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgQy5pYWRkKHlwKS5pdXNocm4oMSk7XG4gICAgICAgIEQuaXN1Yih4cCkuaXVzaHJuKDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh4LmNtcCh5KSA+PSAwKSB7XG4gICAgICB4LmlzdWIoeSk7XG4gICAgICBBLmlzdWIoQyk7XG4gICAgICBCLmlzdWIoRCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHkuaXN1Yih4KTtcbiAgICAgIEMuaXN1YihBKTtcbiAgICAgIEQuaXN1YihCKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGE6IEMsXG4gICAgYjogRCxcbiAgICBnY2Q6IHkuaXVzaGxuKGcpXG4gIH07XG59O1xuXG4vLyBUaGlzIGlzIHJlZHVjZWQgaW5jYXJuYXRpb24gb2YgdGhlIGJpbmFyeSBFRUFcbi8vIGFib3ZlLCBkZXNpZ25hdGVkIHRvIGludmVydCBtZW1iZXJzIG9mIHRoZVxuLy8gX3ByaW1lXyBmaWVsZHMgRihwKSBhdCBhIG1heGltYWwgc3BlZWRcbkJOLnByb3RvdHlwZS5faW52bXAgPSBmdW5jdGlvbiBfaW52bXAocCkge1xuICBhc3NlcnQocC5uZWdhdGl2ZSA9PT0gMCk7XG4gIGFzc2VydChwLmNtcG4oMCkgIT09IDApO1xuXG4gIHZhciBhID0gdGhpcztcbiAgdmFyIGIgPSBwLmNsb25lKCk7XG5cbiAgaWYgKGEubmVnYXRpdmUgIT09IDApXG4gICAgYSA9IGEudW1vZChwKTtcbiAgZWxzZVxuICAgIGEgPSBhLmNsb25lKCk7XG5cbiAgdmFyIHgxID0gbmV3IEJOKDEpO1xuICB2YXIgeDIgPSBuZXcgQk4oMCk7XG5cbiAgdmFyIGRlbHRhID0gYi5jbG9uZSgpO1xuXG4gIHdoaWxlIChhLmNtcG4oMSkgPiAwICYmIGIuY21wbigxKSA+IDApIHtcbiAgICB3aGlsZSAoYS5pc0V2ZW4oKSkge1xuICAgICAgYS5pdXNocm4oMSk7XG4gICAgICBpZiAoeDEuaXNFdmVuKCkpXG4gICAgICAgIHgxLml1c2hybigxKTtcbiAgICAgIGVsc2VcbiAgICAgICAgeDEuaWFkZChkZWx0YSkuaXVzaHJuKDEpO1xuICAgIH1cbiAgICB3aGlsZSAoYi5pc0V2ZW4oKSkge1xuICAgICAgYi5pdXNocm4oMSk7XG4gICAgICBpZiAoeDIuaXNFdmVuKCkpXG4gICAgICAgIHgyLml1c2hybigxKTtcbiAgICAgIGVsc2VcbiAgICAgICAgeDIuaWFkZChkZWx0YSkuaXVzaHJuKDEpO1xuICAgIH1cbiAgICBpZiAoYS5jbXAoYikgPj0gMCkge1xuICAgICAgYS5pc3ViKGIpO1xuICAgICAgeDEuaXN1Yih4Mik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGIuaXN1YihhKTtcbiAgICAgIHgyLmlzdWIoeDEpO1xuICAgIH1cbiAgfVxuXG4gIHZhciByZXM7XG4gIGlmIChhLmNtcG4oMSkgPT09IDApXG4gICAgcmVzID0geDE7XG4gIGVsc2VcbiAgICByZXMgPSB4MjtcblxuICBpZiAocmVzLmNtcG4oMCkgPCAwKVxuICAgIHJlcy5pYWRkKHApO1xuXG4gIHJldHVybiByZXM7XG59O1xuXG5CTi5wcm90b3R5cGUuZ2NkID0gZnVuY3Rpb24gZ2NkKG51bSkge1xuICBpZiAodGhpcy5jbXBuKDApID09PSAwKVxuICAgIHJldHVybiBudW0uY2xvbmUoKTtcbiAgaWYgKG51bS5jbXBuKDApID09PSAwKVxuICAgIHJldHVybiB0aGlzLmNsb25lKCk7XG5cbiAgdmFyIGEgPSB0aGlzLmNsb25lKCk7XG4gIHZhciBiID0gbnVtLmNsb25lKCk7XG4gIGEubmVnYXRpdmUgPSAwO1xuICBiLm5lZ2F0aXZlID0gMDtcblxuICAvLyBSZW1vdmUgY29tbW9uIGZhY3RvciBvZiB0d29cbiAgZm9yICh2YXIgc2hpZnQgPSAwOyBhLmlzRXZlbigpICYmIGIuaXNFdmVuKCk7IHNoaWZ0KyspIHtcbiAgICBhLml1c2hybigxKTtcbiAgICBiLml1c2hybigxKTtcbiAgfVxuXG4gIGRvIHtcbiAgICB3aGlsZSAoYS5pc0V2ZW4oKSlcbiAgICAgIGEuaXVzaHJuKDEpO1xuICAgIHdoaWxlIChiLmlzRXZlbigpKVxuICAgICAgYi5pdXNocm4oMSk7XG5cbiAgICB2YXIgciA9IGEuY21wKGIpO1xuICAgIGlmIChyIDwgMCkge1xuICAgICAgLy8gU3dhcCBgYWAgYW5kIGBiYCB0byBtYWtlIGBhYCBhbHdheXMgYmlnZ2VyIHRoYW4gYGJgXG4gICAgICB2YXIgdCA9IGE7XG4gICAgICBhID0gYjtcbiAgICAgIGIgPSB0O1xuICAgIH0gZWxzZSBpZiAociA9PT0gMCB8fCBiLmNtcG4oMSkgPT09IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGEuaXN1YihiKTtcbiAgfSB3aGlsZSAodHJ1ZSk7XG5cbiAgcmV0dXJuIGIuaXVzaGxuKHNoaWZ0KTtcbn07XG5cbi8vIEludmVydCBudW1iZXIgaW4gdGhlIGZpZWxkIEYobnVtKVxuQk4ucHJvdG90eXBlLmludm0gPSBmdW5jdGlvbiBpbnZtKG51bSkge1xuICByZXR1cm4gdGhpcy5lZ2NkKG51bSkuYS51bW9kKG51bSk7XG59O1xuXG5CTi5wcm90b3R5cGUuaXNFdmVuID0gZnVuY3Rpb24gaXNFdmVuKCkge1xuICByZXR1cm4gKHRoaXMud29yZHNbMF0gJiAxKSA9PT0gMDtcbn07XG5cbkJOLnByb3RvdHlwZS5pc09kZCA9IGZ1bmN0aW9uIGlzT2RkKCkge1xuICByZXR1cm4gKHRoaXMud29yZHNbMF0gJiAxKSA9PT0gMTtcbn07XG5cbi8vIEFuZCBmaXJzdCB3b3JkIGFuZCBudW1cbkJOLnByb3RvdHlwZS5hbmRsbiA9IGZ1bmN0aW9uIGFuZGxuKG51bSkge1xuICByZXR1cm4gdGhpcy53b3Jkc1swXSAmIG51bTtcbn07XG5cbi8vIEluY3JlbWVudCBhdCB0aGUgYml0IHBvc2l0aW9uIGluLWxpbmVcbkJOLnByb3RvdHlwZS5iaW5jbiA9IGZ1bmN0aW9uIGJpbmNuKGJpdCkge1xuICBhc3NlcnQodHlwZW9mIGJpdCA9PT0gJ251bWJlcicpO1xuICB2YXIgciA9IGJpdCAlIDI2O1xuICB2YXIgcyA9IChiaXQgLSByKSAvIDI2O1xuICB2YXIgcSA9IDEgPDwgcjtcblxuICAvLyBGYXN0IGNhc2U6IGJpdCBpcyBtdWNoIGhpZ2hlciB0aGFuIGFsbCBleGlzdGluZyB3b3Jkc1xuICBpZiAodGhpcy5sZW5ndGggPD0gcykge1xuICAgIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aDsgaSA8IHMgKyAxOyBpKyspXG4gICAgICB0aGlzLndvcmRzW2ldID0gMDtcbiAgICB0aGlzLndvcmRzW3NdIHw9IHE7XG4gICAgdGhpcy5sZW5ndGggPSBzICsgMTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIEFkZCBiaXQgYW5kIHByb3BhZ2F0ZSwgaWYgbmVlZGVkXG4gIHZhciBjYXJyeSA9IHE7XG4gIGZvciAodmFyIGkgPSBzOyBjYXJyeSAhPT0gMCAmJiBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB3ID0gdGhpcy53b3Jkc1tpXSB8IDA7XG4gICAgdyArPSBjYXJyeTtcbiAgICBjYXJyeSA9IHcgPj4+IDI2O1xuICAgIHcgJj0gMHgzZmZmZmZmO1xuICAgIHRoaXMud29yZHNbaV0gPSB3O1xuICB9XG4gIGlmIChjYXJyeSAhPT0gMCkge1xuICAgIHRoaXMud29yZHNbaV0gPSBjYXJyeTtcbiAgICB0aGlzLmxlbmd0aCsrO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuQk4ucHJvdG90eXBlLmlzWmVybyA9IGZ1bmN0aW9uIGlzWmVybygpIHtcbiAgcmV0dXJuIHRoaXMubGVuZ3RoID09PSAxICYmIHRoaXMud29yZHNbMF0gPT09IDA7XG59O1xuXG5CTi5wcm90b3R5cGUuY21wbiA9IGZ1bmN0aW9uIGNtcG4obnVtKSB7XG4gIHZhciBuZWdhdGl2ZSA9IG51bSA8IDA7XG5cbiAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDAgJiYgIW5lZ2F0aXZlKVxuICAgIHJldHVybiAtMTtcbiAgZWxzZSBpZiAodGhpcy5uZWdhdGl2ZSA9PT0gMCAmJiBuZWdhdGl2ZSlcbiAgICByZXR1cm4gMTtcblxuICB0aGlzLnN0cmlwKCk7XG5cbiAgdmFyIHJlcztcbiAgaWYgKHRoaXMubGVuZ3RoID4gMSkge1xuICAgIHJlcyA9IDE7XG4gIH0gZWxzZSB7XG4gICAgaWYgKG5lZ2F0aXZlKVxuICAgICAgbnVtID0gLW51bTtcbiAgICBhc3NlcnQobnVtIDw9IDB4M2ZmZmZmZiwgJ051bWJlciBpcyB0b28gYmlnJyk7XG5cbiAgICB2YXIgdyA9IHRoaXMud29yZHNbMF0gfCAwO1xuICAgIHJlcyA9IHcgPT09IG51bSA/IDAgOiB3IDwgbnVtID8gLTEgOiAxO1xuICB9XG4gIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKVxuICAgIHJlcyA9IC1yZXM7XG4gIHJldHVybiByZXM7XG59O1xuXG4vLyBDb21wYXJlIHR3byBudW1iZXJzIGFuZCByZXR1cm46XG4vLyAxIC0gaWYgYHRoaXNgID4gYG51bWBcbi8vIDAgLSBpZiBgdGhpc2AgPT0gYG51bWBcbi8vIC0xIC0gaWYgYHRoaXNgIDwgYG51bWBcbkJOLnByb3RvdHlwZS5jbXAgPSBmdW5jdGlvbiBjbXAobnVtKSB7XG4gIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwICYmIG51bS5uZWdhdGl2ZSA9PT0gMClcbiAgICByZXR1cm4gLTE7XG4gIGVsc2UgaWYgKHRoaXMubmVnYXRpdmUgPT09IDAgJiYgbnVtLm5lZ2F0aXZlICE9PSAwKVxuICAgIHJldHVybiAxO1xuXG4gIHZhciByZXMgPSB0aGlzLnVjbXAobnVtKTtcbiAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApXG4gICAgcmV0dXJuIC1yZXM7XG4gIGVsc2VcbiAgICByZXR1cm4gcmVzO1xufTtcblxuLy8gVW5zaWduZWQgY29tcGFyaXNvblxuQk4ucHJvdG90eXBlLnVjbXAgPSBmdW5jdGlvbiB1Y21wKG51bSkge1xuICAvLyBBdCB0aGlzIHBvaW50IGJvdGggbnVtYmVycyBoYXZlIHRoZSBzYW1lIHNpZ25cbiAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aClcbiAgICByZXR1cm4gMTtcbiAgZWxzZSBpZiAodGhpcy5sZW5ndGggPCBudW0ubGVuZ3RoKVxuICAgIHJldHVybiAtMTtcblxuICB2YXIgcmVzID0gMDtcbiAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgYSA9IHRoaXMud29yZHNbaV0gfCAwO1xuICAgIHZhciBiID0gbnVtLndvcmRzW2ldIHwgMDtcblxuICAgIGlmIChhID09PSBiKVxuICAgICAgY29udGludWU7XG4gICAgaWYgKGEgPCBiKVxuICAgICAgcmVzID0gLTE7XG4gICAgZWxzZSBpZiAoYSA+IGIpXG4gICAgICByZXMgPSAxO1xuICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuXG4vL1xuLy8gQSByZWR1Y2UgY29udGV4dCwgY291bGQgYmUgdXNpbmcgbW9udGdvbWVyeSBvciBzb21ldGhpbmcgYmV0dGVyLCBkZXBlbmRpbmdcbi8vIG9uIHRoZSBgbWAgaXRzZWxmLlxuLy9cbkJOLnJlZCA9IGZ1bmN0aW9uIHJlZChudW0pIHtcbiAgcmV0dXJuIG5ldyBSZWQobnVtKTtcbn07XG5cbkJOLnByb3RvdHlwZS50b1JlZCA9IGZ1bmN0aW9uIHRvUmVkKGN0eCkge1xuICBhc3NlcnQoIXRoaXMucmVkLCAnQWxyZWFkeSBhIG51bWJlciBpbiByZWR1Y3Rpb24gY29udGV4dCcpO1xuICBhc3NlcnQodGhpcy5uZWdhdGl2ZSA9PT0gMCwgJ3JlZCB3b3JrcyBvbmx5IHdpdGggcG9zaXRpdmVzJyk7XG4gIHJldHVybiBjdHguY29udmVydFRvKHRoaXMpLl9mb3JjZVJlZChjdHgpO1xufTtcblxuQk4ucHJvdG90eXBlLmZyb21SZWQgPSBmdW5jdGlvbiBmcm9tUmVkKCkge1xuICBhc3NlcnQodGhpcy5yZWQsICdmcm9tUmVkIHdvcmtzIG9ubHkgd2l0aCBudW1iZXJzIGluIHJlZHVjdGlvbiBjb250ZXh0Jyk7XG4gIHJldHVybiB0aGlzLnJlZC5jb252ZXJ0RnJvbSh0aGlzKTtcbn07XG5cbkJOLnByb3RvdHlwZS5fZm9yY2VSZWQgPSBmdW5jdGlvbiBfZm9yY2VSZWQoY3R4KSB7XG4gIHRoaXMucmVkID0gY3R4O1xuICByZXR1cm4gdGhpcztcbn07XG5cbkJOLnByb3RvdHlwZS5mb3JjZVJlZCA9IGZ1bmN0aW9uIGZvcmNlUmVkKGN0eCkge1xuICBhc3NlcnQoIXRoaXMucmVkLCAnQWxyZWFkeSBhIG51bWJlciBpbiByZWR1Y3Rpb24gY29udGV4dCcpO1xuICByZXR1cm4gdGhpcy5fZm9yY2VSZWQoY3R4KTtcbn07XG5cbkJOLnByb3RvdHlwZS5yZWRBZGQgPSBmdW5jdGlvbiByZWRBZGQobnVtKSB7XG4gIGFzc2VydCh0aGlzLnJlZCwgJ3JlZEFkZCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgcmV0dXJuIHRoaXMucmVkLmFkZCh0aGlzLCBudW0pO1xufTtcblxuQk4ucHJvdG90eXBlLnJlZElBZGQgPSBmdW5jdGlvbiByZWRJQWRkKG51bSkge1xuICBhc3NlcnQodGhpcy5yZWQsICdyZWRJQWRkIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICByZXR1cm4gdGhpcy5yZWQuaWFkZCh0aGlzLCBudW0pO1xufTtcblxuQk4ucHJvdG90eXBlLnJlZFN1YiA9IGZ1bmN0aW9uIHJlZFN1YihudW0pIHtcbiAgYXNzZXJ0KHRoaXMucmVkLCAncmVkU3ViIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICByZXR1cm4gdGhpcy5yZWQuc3ViKHRoaXMsIG51bSk7XG59O1xuXG5CTi5wcm90b3R5cGUucmVkSVN1YiA9IGZ1bmN0aW9uIHJlZElTdWIobnVtKSB7XG4gIGFzc2VydCh0aGlzLnJlZCwgJ3JlZElTdWIgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gIHJldHVybiB0aGlzLnJlZC5pc3ViKHRoaXMsIG51bSk7XG59O1xuXG5CTi5wcm90b3R5cGUucmVkU2hsID0gZnVuY3Rpb24gcmVkU2hsKG51bSkge1xuICBhc3NlcnQodGhpcy5yZWQsICdyZWRTaGwgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gIHJldHVybiB0aGlzLnJlZC51c2hsKHRoaXMsIG51bSk7XG59O1xuXG5CTi5wcm90b3R5cGUucmVkTXVsID0gZnVuY3Rpb24gcmVkTXVsKG51bSkge1xuICBhc3NlcnQodGhpcy5yZWQsICdyZWRNdWwgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gIHRoaXMucmVkLl92ZXJpZnkyKHRoaXMsIG51bSk7XG4gIHJldHVybiB0aGlzLnJlZC5tdWwodGhpcywgbnVtKTtcbn07XG5cbkJOLnByb3RvdHlwZS5yZWRJTXVsID0gZnVuY3Rpb24gcmVkSU11bChudW0pIHtcbiAgYXNzZXJ0KHRoaXMucmVkLCAncmVkTXVsIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICB0aGlzLnJlZC5fdmVyaWZ5Mih0aGlzLCBudW0pO1xuICByZXR1cm4gdGhpcy5yZWQuaW11bCh0aGlzLCBudW0pO1xufTtcblxuQk4ucHJvdG90eXBlLnJlZFNxciA9IGZ1bmN0aW9uIHJlZFNxcigpIHtcbiAgYXNzZXJ0KHRoaXMucmVkLCAncmVkU3FyIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcbiAgcmV0dXJuIHRoaXMucmVkLnNxcih0aGlzKTtcbn07XG5cbkJOLnByb3RvdHlwZS5yZWRJU3FyID0gZnVuY3Rpb24gcmVkSVNxcigpIHtcbiAgYXNzZXJ0KHRoaXMucmVkLCAncmVkSVNxciB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gIHJldHVybiB0aGlzLnJlZC5pc3FyKHRoaXMpO1xufTtcblxuLy8gU3F1YXJlIHJvb3Qgb3ZlciBwXG5CTi5wcm90b3R5cGUucmVkU3FydCA9IGZ1bmN0aW9uIHJlZFNxcnQoKSB7XG4gIGFzc2VydCh0aGlzLnJlZCwgJ3JlZFNxcnQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuICByZXR1cm4gdGhpcy5yZWQuc3FydCh0aGlzKTtcbn07XG5cbkJOLnByb3RvdHlwZS5yZWRJbnZtID0gZnVuY3Rpb24gcmVkSW52bSgpIHtcbiAgYXNzZXJ0KHRoaXMucmVkLCAncmVkSW52bSB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gIHJldHVybiB0aGlzLnJlZC5pbnZtKHRoaXMpO1xufTtcblxuLy8gUmV0dXJuIG5lZ2F0aXZlIGNsb25lIG9mIGB0aGlzYCAlIGByZWQgbW9kdWxvYFxuQk4ucHJvdG90eXBlLnJlZE5lZyA9IGZ1bmN0aW9uIHJlZE5lZygpIHtcbiAgYXNzZXJ0KHRoaXMucmVkLCAncmVkTmVnIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcbiAgcmV0dXJuIHRoaXMucmVkLm5lZyh0aGlzKTtcbn07XG5cbkJOLnByb3RvdHlwZS5yZWRQb3cgPSBmdW5jdGlvbiByZWRQb3cobnVtKSB7XG4gIGFzc2VydCh0aGlzLnJlZCAmJiAhbnVtLnJlZCwgJ3JlZFBvdyhub3JtYWxOdW0pJyk7XG4gIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuICByZXR1cm4gdGhpcy5yZWQucG93KHRoaXMsIG51bSk7XG59O1xuXG4vLyBQcmltZSBudW1iZXJzIHdpdGggZWZmaWNpZW50IHJlZHVjdGlvblxudmFyIHByaW1lcyA9IHtcbiAgazI1NjogbnVsbCxcbiAgcDIyNDogbnVsbCxcbiAgcDE5MjogbnVsbCxcbiAgcDI1NTE5OiBudWxsXG59O1xuXG4vLyBQc2V1ZG8tTWVyc2VubmUgcHJpbWVcbmZ1bmN0aW9uIE1QcmltZShuYW1lLCBwKSB7XG4gIC8vIFAgPSAyIF4gTiAtIEtcbiAgdGhpcy5uYW1lID0gbmFtZTtcbiAgdGhpcy5wID0gbmV3IEJOKHAsIDE2KTtcbiAgdGhpcy5uID0gdGhpcy5wLmJpdExlbmd0aCgpO1xuICB0aGlzLmsgPSBuZXcgQk4oMSkuaXVzaGxuKHRoaXMubikuaXN1Yih0aGlzLnApO1xuXG4gIHRoaXMudG1wID0gdGhpcy5fdG1wKCk7XG59XG5cbk1QcmltZS5wcm90b3R5cGUuX3RtcCA9IGZ1bmN0aW9uIF90bXAoKSB7XG4gIHZhciB0bXAgPSBuZXcgQk4obnVsbCk7XG4gIHRtcC53b3JkcyA9IG5ldyBBcnJheShNYXRoLmNlaWwodGhpcy5uIC8gMTMpKTtcbiAgcmV0dXJuIHRtcDtcbn07XG5cbk1QcmltZS5wcm90b3R5cGUuaXJlZHVjZSA9IGZ1bmN0aW9uIGlyZWR1Y2UobnVtKSB7XG4gIC8vIEFzc3VtZXMgdGhhdCBgbnVtYCBpcyBsZXNzIHRoYW4gYFBeMmBcbiAgLy8gbnVtID0gSEkgKiAoMiBeIE4gLSBLKSArIEhJICogSyArIExPID0gSEkgKiBLICsgTE8gKG1vZCBQKVxuICB2YXIgciA9IG51bTtcbiAgdmFyIHJsZW47XG5cbiAgZG8ge1xuICAgIHRoaXMuc3BsaXQociwgdGhpcy50bXApO1xuICAgIHIgPSB0aGlzLmltdWxLKHIpO1xuICAgIHIgPSByLmlhZGQodGhpcy50bXApO1xuICAgIHJsZW4gPSByLmJpdExlbmd0aCgpO1xuICB9IHdoaWxlIChybGVuID4gdGhpcy5uKTtcblxuICB2YXIgY21wID0gcmxlbiA8IHRoaXMubiA/IC0xIDogci51Y21wKHRoaXMucCk7XG4gIGlmIChjbXAgPT09IDApIHtcbiAgICByLndvcmRzWzBdID0gMDtcbiAgICByLmxlbmd0aCA9IDE7XG4gIH0gZWxzZSBpZiAoY21wID4gMCkge1xuICAgIHIuaXN1Yih0aGlzLnApO1xuICB9IGVsc2Uge1xuICAgIHIuc3RyaXAoKTtcbiAgfVxuXG4gIHJldHVybiByO1xufTtcblxuTVByaW1lLnByb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uIHNwbGl0KGlucHV0LCBvdXQpIHtcbiAgaW5wdXQuaXVzaHJuKHRoaXMubiwgMCwgb3V0KTtcbn07XG5cbk1QcmltZS5wcm90b3R5cGUuaW11bEsgPSBmdW5jdGlvbiBpbXVsSyhudW0pIHtcbiAgcmV0dXJuIG51bS5pbXVsKHRoaXMuayk7XG59O1xuXG5mdW5jdGlvbiBLMjU2KCkge1xuICBNUHJpbWUuY2FsbChcbiAgICB0aGlzLFxuICAgICdrMjU2JyxcbiAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZjMmYnKTtcbn1cbmluaGVyaXRzKEsyNTYsIE1QcmltZSk7XG5cbksyNTYucHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24gc3BsaXQoaW5wdXQsIG91dHB1dCkge1xuICAvLyAyNTYgPSA5ICogMjYgKyAyMlxuICB2YXIgbWFzayA9IDB4M2ZmZmZmO1xuXG4gIHZhciBvdXRMZW4gPSBNYXRoLm1pbihpbnB1dC5sZW5ndGgsIDkpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG91dExlbjsgaSsrKVxuICAgIG91dHB1dC53b3Jkc1tpXSA9IGlucHV0LndvcmRzW2ldO1xuICBvdXRwdXQubGVuZ3RoID0gb3V0TGVuO1xuXG4gIGlmIChpbnB1dC5sZW5ndGggPD0gOSkge1xuICAgIGlucHV0LndvcmRzWzBdID0gMDtcbiAgICBpbnB1dC5sZW5ndGggPSAxO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFNoaWZ0IGJ5IDkgbGltYnNcbiAgdmFyIHByZXYgPSBpbnB1dC53b3Jkc1s5XTtcbiAgb3V0cHV0LndvcmRzW291dHB1dC5sZW5ndGgrK10gPSBwcmV2ICYgbWFzaztcblxuICBmb3IgKHZhciBpID0gMTA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBuZXh0ID0gaW5wdXQud29yZHNbaV0gfCAwO1xuICAgIGlucHV0LndvcmRzW2kgLSAxMF0gPSAoKG5leHQgJiBtYXNrKSA8PCA0KSB8IChwcmV2ID4+PiAyMik7XG4gICAgcHJldiA9IG5leHQ7XG4gIH1cbiAgaW5wdXQud29yZHNbaSAtIDEwXSA9IHByZXYgPj4+IDIyO1xuICBpbnB1dC5sZW5ndGggLT0gOTtcbn07XG5cbksyNTYucHJvdG90eXBlLmltdWxLID0gZnVuY3Rpb24gaW11bEsobnVtKSB7XG4gIC8vIEsgPSAweDEwMDAwMDNkMSA9IFsgMHg0MCwgMHgzZDEgXVxuICBudW0ud29yZHNbbnVtLmxlbmd0aF0gPSAwO1xuICBudW0ud29yZHNbbnVtLmxlbmd0aCArIDFdID0gMDtcbiAgbnVtLmxlbmd0aCArPSAyO1xuXG4gIC8vIGJvdW5kZWQgYXQ6IDB4NDAgKiAweDNmZmZmZmYgKyAweDNkMCA9IDB4MTAwMDAwMzkwXG4gIHZhciBoaTtcbiAgdmFyIGxvID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW0ubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdyA9IG51bS53b3Jkc1tpXSB8IDA7XG4gICAgaGkgPSB3ICogMHg0MDtcbiAgICBsbyArPSB3ICogMHgzZDE7XG4gICAgaGkgKz0gKGxvIC8gMHg0MDAwMDAwKSB8IDA7XG4gICAgbG8gJj0gMHgzZmZmZmZmO1xuXG4gICAgbnVtLndvcmRzW2ldID0gbG87XG5cbiAgICBsbyA9IGhpO1xuICB9XG5cbiAgLy8gRmFzdCBsZW5ndGggcmVkdWN0aW9uXG4gIGlmIChudW0ud29yZHNbbnVtLmxlbmd0aCAtIDFdID09PSAwKSB7XG4gICAgbnVtLmxlbmd0aC0tO1xuICAgIGlmIChudW0ud29yZHNbbnVtLmxlbmd0aCAtIDFdID09PSAwKVxuICAgICAgbnVtLmxlbmd0aC0tO1xuICB9XG4gIHJldHVybiBudW07XG59O1xuXG5mdW5jdGlvbiBQMjI0KCkge1xuICBNUHJpbWUuY2FsbChcbiAgICB0aGlzLFxuICAgICdwMjI0JyxcbiAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgMDAwMDAwMDAgMDAwMDAwMDAgMDAwMDAwMDEnKTtcbn1cbmluaGVyaXRzKFAyMjQsIE1QcmltZSk7XG5cbmZ1bmN0aW9uIFAxOTIoKSB7XG4gIE1QcmltZS5jYWxsKFxuICAgIHRoaXMsXG4gICAgJ3AxOTInLFxuICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmZmZiBmZmZmZmZmZicpO1xufVxuaW5oZXJpdHMoUDE5MiwgTVByaW1lKTtcblxuZnVuY3Rpb24gUDI1NTE5KCkge1xuICAvLyAyIF4gMjU1IC0gMTlcbiAgTVByaW1lLmNhbGwoXG4gICAgdGhpcyxcbiAgICAnMjU1MTknLFxuICAgICc3ZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmVkJyk7XG59XG5pbmhlcml0cyhQMjU1MTksIE1QcmltZSk7XG5cblAyNTUxOS5wcm90b3R5cGUuaW11bEsgPSBmdW5jdGlvbiBpbXVsSyhudW0pIHtcbiAgLy8gSyA9IDB4MTNcbiAgdmFyIGNhcnJ5ID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW0ubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaGkgPSAobnVtLndvcmRzW2ldIHwgMCkgKiAweDEzICsgY2Fycnk7XG4gICAgdmFyIGxvID0gaGkgJiAweDNmZmZmZmY7XG4gICAgaGkgPj4+PSAyNjtcblxuICAgIG51bS53b3Jkc1tpXSA9IGxvO1xuICAgIGNhcnJ5ID0gaGk7XG4gIH1cbiAgaWYgKGNhcnJ5ICE9PSAwKVxuICAgIG51bS53b3Jkc1tudW0ubGVuZ3RoKytdID0gY2Fycnk7XG4gIHJldHVybiBudW07XG59O1xuXG4vLyBFeHBvcnRlZCBtb3N0bHkgZm9yIHRlc3RpbmcgcHVycG9zZXMsIHVzZSBwbGFpbiBuYW1lIGluc3RlYWRcbkJOLl9wcmltZSA9IGZ1bmN0aW9uIHByaW1lKG5hbWUpIHtcbiAgLy8gQ2FjaGVkIHZlcnNpb24gb2YgcHJpbWVcbiAgaWYgKHByaW1lc1tuYW1lXSlcbiAgICByZXR1cm4gcHJpbWVzW25hbWVdO1xuXG4gIHZhciBwcmltZTtcbiAgaWYgKG5hbWUgPT09ICdrMjU2JylcbiAgICBwcmltZSA9IG5ldyBLMjU2KCk7XG4gIGVsc2UgaWYgKG5hbWUgPT09ICdwMjI0JylcbiAgICBwcmltZSA9IG5ldyBQMjI0KCk7XG4gIGVsc2UgaWYgKG5hbWUgPT09ICdwMTkyJylcbiAgICBwcmltZSA9IG5ldyBQMTkyKCk7XG4gIGVsc2UgaWYgKG5hbWUgPT09ICdwMjU1MTknKVxuICAgIHByaW1lID0gbmV3IFAyNTUxOSgpO1xuICBlbHNlXG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHByaW1lICcgKyBuYW1lKTtcbiAgcHJpbWVzW25hbWVdID0gcHJpbWU7XG5cbiAgcmV0dXJuIHByaW1lO1xufTtcblxuLy9cbi8vIEJhc2UgcmVkdWN0aW9uIGVuZ2luZVxuLy9cbmZ1bmN0aW9uIFJlZChtKSB7XG4gIGlmICh0eXBlb2YgbSA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgcHJpbWUgPSBCTi5fcHJpbWUobSk7XG4gICAgdGhpcy5tID0gcHJpbWUucDtcbiAgICB0aGlzLnByaW1lID0gcHJpbWU7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5tID0gbTtcbiAgICB0aGlzLnByaW1lID0gbnVsbDtcbiAgfVxufVxuXG5SZWQucHJvdG90eXBlLl92ZXJpZnkxID0gZnVuY3Rpb24gX3ZlcmlmeTEoYSkge1xuICBhc3NlcnQoYS5uZWdhdGl2ZSA9PT0gMCwgJ3JlZCB3b3JrcyBvbmx5IHdpdGggcG9zaXRpdmVzJyk7XG4gIGFzc2VydChhLnJlZCwgJ3JlZCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbn07XG5cblJlZC5wcm90b3R5cGUuX3ZlcmlmeTIgPSBmdW5jdGlvbiBfdmVyaWZ5MihhLCBiKSB7XG4gIGFzc2VydCgoYS5uZWdhdGl2ZSB8IGIubmVnYXRpdmUpID09PSAwLCAncmVkIHdvcmtzIG9ubHkgd2l0aCBwb3NpdGl2ZXMnKTtcbiAgYXNzZXJ0KGEucmVkICYmIGEucmVkID09PSBiLnJlZCxcbiAgICAgICAgICdyZWQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG59O1xuXG5SZWQucHJvdG90eXBlLmltb2QgPSBmdW5jdGlvbiBpbW9kKGEpIHtcbiAgaWYgKHRoaXMucHJpbWUpXG4gICAgcmV0dXJuIHRoaXMucHJpbWUuaXJlZHVjZShhKS5fZm9yY2VSZWQodGhpcyk7XG4gIHJldHVybiBhLnVtb2QodGhpcy5tKS5fZm9yY2VSZWQodGhpcyk7XG59O1xuXG5SZWQucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uIG5lZyhhKSB7XG4gIHZhciByID0gYS5jbG9uZSgpO1xuICByLm5lZ2F0aXZlIF49IDE7XG4gIHJldHVybiByLmlhZGQodGhpcy5tKS5fZm9yY2VSZWQodGhpcyk7XG59O1xuXG5SZWQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZChhLCBiKSB7XG4gIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG5cbiAgdmFyIHJlcyA9IGEuYWRkKGIpO1xuICBpZiAocmVzLmNtcCh0aGlzLm0pID49IDApXG4gICAgcmVzLmlzdWIodGhpcy5tKTtcbiAgcmV0dXJuIHJlcy5fZm9yY2VSZWQodGhpcyk7XG59O1xuXG5SZWQucHJvdG90eXBlLmlhZGQgPSBmdW5jdGlvbiBpYWRkKGEsIGIpIHtcbiAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcblxuICB2YXIgcmVzID0gYS5pYWRkKGIpO1xuICBpZiAocmVzLmNtcCh0aGlzLm0pID49IDApXG4gICAgcmVzLmlzdWIodGhpcy5tKTtcbiAgcmV0dXJuIHJlcztcbn07XG5cblJlZC5wcm90b3R5cGUuc3ViID0gZnVuY3Rpb24gc3ViKGEsIGIpIHtcbiAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcblxuICB2YXIgcmVzID0gYS5zdWIoYik7XG4gIGlmIChyZXMuY21wbigwKSA8IDApXG4gICAgcmVzLmlhZGQodGhpcy5tKTtcbiAgcmV0dXJuIHJlcy5fZm9yY2VSZWQodGhpcyk7XG59O1xuXG5SZWQucHJvdG90eXBlLmlzdWIgPSBmdW5jdGlvbiBpc3ViKGEsIGIpIHtcbiAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcblxuICB2YXIgcmVzID0gYS5pc3ViKGIpO1xuICBpZiAocmVzLmNtcG4oMCkgPCAwKVxuICAgIHJlcy5pYWRkKHRoaXMubSk7XG4gIHJldHVybiByZXM7XG59O1xuXG5SZWQucHJvdG90eXBlLnNobCA9IGZ1bmN0aW9uIHNobChhLCBudW0pIHtcbiAgdGhpcy5fdmVyaWZ5MShhKTtcbiAgcmV0dXJuIHRoaXMuaW1vZChhLnVzaGxuKG51bSkpO1xufTtcblxuUmVkLnByb3RvdHlwZS5pbXVsID0gZnVuY3Rpb24gaW11bChhLCBiKSB7XG4gIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG4gIHJldHVybiB0aGlzLmltb2QoYS5pbXVsKGIpKTtcbn07XG5cblJlZC5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gbXVsKGEsIGIpIHtcbiAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcbiAgcmV0dXJuIHRoaXMuaW1vZChhLm11bChiKSk7XG59O1xuXG5SZWQucHJvdG90eXBlLmlzcXIgPSBmdW5jdGlvbiBpc3FyKGEpIHtcbiAgcmV0dXJuIHRoaXMuaW11bChhLCBhKTtcbn07XG5cblJlZC5wcm90b3R5cGUuc3FyID0gZnVuY3Rpb24gc3FyKGEpIHtcbiAgcmV0dXJuIHRoaXMubXVsKGEsIGEpO1xufTtcblxuUmVkLnByb3RvdHlwZS5zcXJ0ID0gZnVuY3Rpb24gc3FydChhKSB7XG4gIGlmIChhLmNtcG4oMCkgPT09IDApXG4gICAgcmV0dXJuIGEuY2xvbmUoKTtcblxuICB2YXIgbW9kMyA9IHRoaXMubS5hbmRsbigzKTtcbiAgYXNzZXJ0KG1vZDMgJSAyID09PSAxKTtcblxuICAvLyBGYXN0IGNhc2VcbiAgaWYgKG1vZDMgPT09IDMpIHtcbiAgICB2YXIgcG93ID0gdGhpcy5tLmFkZChuZXcgQk4oMSkpLml1c2hybigyKTtcbiAgICB2YXIgciA9IHRoaXMucG93KGEsIHBvdyk7XG4gICAgcmV0dXJuIHI7XG4gIH1cblxuICAvLyBUb25lbGxpLVNoYW5rcyBhbGdvcml0aG0gKFRvdGFsbHkgdW5vcHRpbWl6ZWQgYW5kIHNsb3cpXG4gIC8vXG4gIC8vIEZpbmQgUSBhbmQgUywgdGhhdCBRICogMiBeIFMgPSAoUCAtIDEpXG4gIHZhciBxID0gdGhpcy5tLnN1Ym4oMSk7XG4gIHZhciBzID0gMDtcbiAgd2hpbGUgKHEuY21wbigwKSAhPT0gMCAmJiBxLmFuZGxuKDEpID09PSAwKSB7XG4gICAgcysrO1xuICAgIHEuaXVzaHJuKDEpO1xuICB9XG4gIGFzc2VydChxLmNtcG4oMCkgIT09IDApO1xuXG4gIHZhciBvbmUgPSBuZXcgQk4oMSkudG9SZWQodGhpcyk7XG4gIHZhciBuT25lID0gb25lLnJlZE5lZygpO1xuXG4gIC8vIEZpbmQgcXVhZHJhdGljIG5vbi1yZXNpZHVlXG4gIC8vIE5PVEU6IE1heCBpcyBzdWNoIGJlY2F1c2Ugb2YgZ2VuZXJhbGl6ZWQgUmllbWFubiBoeXBvdGhlc2lzLlxuICB2YXIgbHBvdyA9IHRoaXMubS5zdWJuKDEpLml1c2hybigxKTtcbiAgdmFyIHogPSB0aGlzLm0uYml0TGVuZ3RoKCk7XG4gIHogPSBuZXcgQk4oMiAqIHogKiB6KS50b1JlZCh0aGlzKTtcbiAgd2hpbGUgKHRoaXMucG93KHosIGxwb3cpLmNtcChuT25lKSAhPT0gMClcbiAgICB6LnJlZElBZGQobk9uZSk7XG5cbiAgdmFyIGMgPSB0aGlzLnBvdyh6LCBxKTtcbiAgdmFyIHIgPSB0aGlzLnBvdyhhLCBxLmFkZG4oMSkuaXVzaHJuKDEpKTtcbiAgdmFyIHQgPSB0aGlzLnBvdyhhLCBxKTtcbiAgdmFyIG0gPSBzO1xuICB3aGlsZSAodC5jbXAob25lKSAhPT0gMCkge1xuICAgIHZhciB0bXAgPSB0O1xuICAgIGZvciAodmFyIGkgPSAwOyB0bXAuY21wKG9uZSkgIT09IDA7IGkrKylcbiAgICAgIHRtcCA9IHRtcC5yZWRTcXIoKTtcbiAgICBhc3NlcnQoaSA8IG0pO1xuICAgIHZhciBiID0gdGhpcy5wb3coYywgbmV3IEJOKDEpLml1c2hsbihtIC0gaSAtIDEpKTtcblxuICAgIHIgPSByLnJlZE11bChiKTtcbiAgICBjID0gYi5yZWRTcXIoKTtcbiAgICB0ID0gdC5yZWRNdWwoYyk7XG4gICAgbSA9IGk7XG4gIH1cblxuICByZXR1cm4gcjtcbn07XG5cblJlZC5wcm90b3R5cGUuaW52bSA9IGZ1bmN0aW9uIGludm0oYSkge1xuICB2YXIgaW52ID0gYS5faW52bXAodGhpcy5tKTtcbiAgaWYgKGludi5uZWdhdGl2ZSAhPT0gMCkge1xuICAgIGludi5uZWdhdGl2ZSA9IDA7XG4gICAgcmV0dXJuIHRoaXMuaW1vZChpbnYpLnJlZE5lZygpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aGlzLmltb2QoaW52KTtcbiAgfVxufTtcblxuUmVkLnByb3RvdHlwZS5wb3cgPSBmdW5jdGlvbiBwb3coYSwgbnVtKSB7XG4gIGlmIChudW0uY21wbigwKSA9PT0gMClcbiAgICByZXR1cm4gbmV3IEJOKDEpO1xuICBpZiAobnVtLmNtcG4oMSkgPT09IDApXG4gICAgcmV0dXJuIGEuY2xvbmUoKTtcblxuICB2YXIgd2luZG93U2l6ZSA9IDQ7XG4gIHZhciB3bmQgPSBuZXcgQXJyYXkoMSA8PCB3aW5kb3dTaXplKTtcbiAgd25kWzBdID0gbmV3IEJOKDEpLnRvUmVkKHRoaXMpO1xuICB3bmRbMV0gPSBhO1xuICBmb3IgKHZhciBpID0gMjsgaSA8IHduZC5sZW5ndGg7IGkrKylcbiAgICB3bmRbaV0gPSB0aGlzLm11bCh3bmRbaSAtIDFdLCBhKTtcblxuICB2YXIgcmVzID0gd25kWzBdO1xuICB2YXIgY3VycmVudCA9IDA7XG4gIHZhciBjdXJyZW50TGVuID0gMDtcbiAgdmFyIHN0YXJ0ID0gbnVtLmJpdExlbmd0aCgpICUgMjY7XG4gIGlmIChzdGFydCA9PT0gMClcbiAgICBzdGFydCA9IDI2O1xuICBmb3IgKHZhciBpID0gbnVtLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIHdvcmQgPSBudW0ud29yZHNbaV07XG4gICAgZm9yICh2YXIgaiA9IHN0YXJ0IC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgIHZhciBiaXQgPSAod29yZCA+PiBqKSAmIDE7XG4gICAgICBpZiAocmVzICE9PSB3bmRbMF0pXG4gICAgICAgIHJlcyA9IHRoaXMuc3FyKHJlcyk7XG4gICAgICBpZiAoYml0ID09PSAwICYmIGN1cnJlbnQgPT09IDApIHtcbiAgICAgICAgY3VycmVudExlbiA9IDA7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjdXJyZW50IDw8PSAxO1xuICAgICAgY3VycmVudCB8PSBiaXQ7XG4gICAgICBjdXJyZW50TGVuKys7XG4gICAgICBpZiAoY3VycmVudExlbiAhPT0gd2luZG93U2l6ZSAmJiAoaSAhPT0gMCB8fCBqICE9PSAwKSlcbiAgICAgICAgY29udGludWU7XG5cbiAgICAgIHJlcyA9IHRoaXMubXVsKHJlcywgd25kW2N1cnJlbnRdKTtcbiAgICAgIGN1cnJlbnRMZW4gPSAwO1xuICAgICAgY3VycmVudCA9IDA7XG4gICAgfVxuICAgIHN0YXJ0ID0gMjY7XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblxuUmVkLnByb3RvdHlwZS5jb252ZXJ0VG8gPSBmdW5jdGlvbiBjb252ZXJ0VG8obnVtKSB7XG4gIHZhciByID0gbnVtLnVtb2QodGhpcy5tKTtcbiAgaWYgKHIgPT09IG51bSlcbiAgICByZXR1cm4gci5jbG9uZSgpO1xuICBlbHNlXG4gICAgcmV0dXJuIHI7XG59O1xuXG5SZWQucHJvdG90eXBlLmNvbnZlcnRGcm9tID0gZnVuY3Rpb24gY29udmVydEZyb20obnVtKSB7XG4gIHZhciByZXMgPSBudW0uY2xvbmUoKTtcbiAgcmVzLnJlZCA9IG51bGw7XG4gIHJldHVybiByZXM7XG59O1xuXG4vL1xuLy8gTW9udGdvbWVyeSBtZXRob2QgZW5naW5lXG4vL1xuXG5CTi5tb250ID0gZnVuY3Rpb24gbW9udChudW0pIHtcbiAgcmV0dXJuIG5ldyBNb250KG51bSk7XG59O1xuXG5mdW5jdGlvbiBNb250KG0pIHtcbiAgUmVkLmNhbGwodGhpcywgbSk7XG5cbiAgdGhpcy5zaGlmdCA9IHRoaXMubS5iaXRMZW5ndGgoKTtcbiAgaWYgKHRoaXMuc2hpZnQgJSAyNiAhPT0gMClcbiAgICB0aGlzLnNoaWZ0ICs9IDI2IC0gKHRoaXMuc2hpZnQgJSAyNik7XG4gIHRoaXMuciA9IG5ldyBCTigxKS5pdXNobG4odGhpcy5zaGlmdCk7XG4gIHRoaXMucjIgPSB0aGlzLmltb2QodGhpcy5yLnNxcigpKTtcbiAgdGhpcy5yaW52ID0gdGhpcy5yLl9pbnZtcCh0aGlzLm0pO1xuXG4gIHRoaXMubWludiA9IHRoaXMucmludi5tdWwodGhpcy5yKS5pc3VibigxKS5kaXYodGhpcy5tKTtcbiAgdGhpcy5taW52ID0gdGhpcy5taW52LnVtb2QodGhpcy5yKTtcbiAgdGhpcy5taW52ID0gdGhpcy5yLnN1Yih0aGlzLm1pbnYpO1xufVxuaW5oZXJpdHMoTW9udCwgUmVkKTtcblxuTW9udC5wcm90b3R5cGUuY29udmVydFRvID0gZnVuY3Rpb24gY29udmVydFRvKG51bSkge1xuICByZXR1cm4gdGhpcy5pbW9kKG51bS51c2hsbih0aGlzLnNoaWZ0KSk7XG59O1xuXG5Nb250LnByb3RvdHlwZS5jb252ZXJ0RnJvbSA9IGZ1bmN0aW9uIGNvbnZlcnRGcm9tKG51bSkge1xuICB2YXIgciA9IHRoaXMuaW1vZChudW0ubXVsKHRoaXMucmludikpO1xuICByLnJlZCA9IG51bGw7XG4gIHJldHVybiByO1xufTtcblxuTW9udC5wcm90b3R5cGUuaW11bCA9IGZ1bmN0aW9uIGltdWwoYSwgYikge1xuICBpZiAoYS5jbXBuKDApID09PSAwIHx8IGIuY21wbigwKSA9PT0gMCkge1xuICAgIGEud29yZHNbMF0gPSAwO1xuICAgIGEubGVuZ3RoID0gMTtcbiAgICByZXR1cm4gYTtcbiAgfVxuXG4gIHZhciB0ID0gYS5pbXVsKGIpO1xuICB2YXIgYyA9IHQubWFza24odGhpcy5zaGlmdCkubXVsKHRoaXMubWludikuaW1hc2tuKHRoaXMuc2hpZnQpLm11bCh0aGlzLm0pO1xuICB2YXIgdSA9IHQuaXN1YihjKS5pdXNocm4odGhpcy5zaGlmdCk7XG4gIHZhciByZXMgPSB1O1xuICBpZiAodS5jbXAodGhpcy5tKSA+PSAwKVxuICAgIHJlcyA9IHUuaXN1Yih0aGlzLm0pO1xuICBlbHNlIGlmICh1LmNtcG4oMCkgPCAwKVxuICAgIHJlcyA9IHUuaWFkZCh0aGlzLm0pO1xuXG4gIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xufTtcblxuTW9udC5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gbXVsKGEsIGIpIHtcbiAgaWYgKGEuY21wbigwKSA9PT0gMCB8fCBiLmNtcG4oMCkgPT09IDApXG4gICAgcmV0dXJuIG5ldyBCTigwKS5fZm9yY2VSZWQodGhpcyk7XG5cbiAgdmFyIHQgPSBhLm11bChiKTtcbiAgdmFyIGMgPSB0Lm1hc2tuKHRoaXMuc2hpZnQpLm11bCh0aGlzLm1pbnYpLmltYXNrbih0aGlzLnNoaWZ0KS5tdWwodGhpcy5tKTtcbiAgdmFyIHUgPSB0LmlzdWIoYykuaXVzaHJuKHRoaXMuc2hpZnQpO1xuICB2YXIgcmVzID0gdTtcbiAgaWYgKHUuY21wKHRoaXMubSkgPj0gMClcbiAgICByZXMgPSB1LmlzdWIodGhpcy5tKTtcbiAgZWxzZSBpZiAodS5jbXBuKDApIDwgMClcbiAgICByZXMgPSB1LmlhZGQodGhpcy5tKTtcblxuICByZXR1cm4gcmVzLl9mb3JjZVJlZCh0aGlzKTtcbn07XG5cbk1vbnQucHJvdG90eXBlLmludm0gPSBmdW5jdGlvbiBpbnZtKGEpIHtcbiAgLy8gKEFSKV4tMSAqIFJeMiA9IChBXi0xICogUl4tMSkgKiBSXjIgPSBBXi0xICogUlxuICB2YXIgcmVzID0gdGhpcy5pbW9kKGEuX2ludm1wKHRoaXMubSkubXVsKHRoaXMucjIpKTtcbiAgcmV0dXJuIHJlcy5fZm9yY2VSZWQodGhpcyk7XG59O1xuXG59KSh0eXBlb2YgbW9kdWxlID09PSAndW5kZWZpbmVkJyB8fCBtb2R1bGUsIHRoaXMpO1xuIiwidmFyIGJuID0gcmVxdWlyZSgnYm4uanMnKTtcbnZhciByYW5kb21CeXRlcyA9IHJlcXVpcmUoJ3JhbmRvbWJ5dGVzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGNydDtcbmZ1bmN0aW9uIGJsaW5kKHByaXYpIHtcbiAgdmFyIHIgPSBnZXRyKHByaXYpO1xuICB2YXIgYmxpbmRlciA9IHIudG9SZWQoYm4ubW9udChwcml2Lm1vZHVsdXMpKVxuICAucmVkUG93KG5ldyBibihwcml2LnB1YmxpY0V4cG9uZW50KSkuZnJvbVJlZCgpO1xuICByZXR1cm4ge1xuICAgIGJsaW5kZXI6IGJsaW5kZXIsXG4gICAgdW5ibGluZGVyOnIuaW52bShwcml2Lm1vZHVsdXMpXG4gIH07XG59XG5mdW5jdGlvbiBjcnQobXNnLCBwcml2KSB7XG4gIHZhciBibGluZHMgPSBibGluZChwcml2KTtcbiAgdmFyIGxlbiA9IHByaXYubW9kdWx1cy5ieXRlTGVuZ3RoKCk7XG4gIHZhciBtb2QgPSBibi5tb250KHByaXYubW9kdWx1cyk7XG4gIHZhciBibGluZGVkID0gbmV3IGJuKG1zZykubXVsKGJsaW5kcy5ibGluZGVyKS51bW9kKHByaXYubW9kdWx1cyk7XG4gIHZhciBjMSA9IGJsaW5kZWQudG9SZWQoYm4ubW9udChwcml2LnByaW1lMSkpO1xuICB2YXIgYzIgPSBibGluZGVkLnRvUmVkKGJuLm1vbnQocHJpdi5wcmltZTIpKTtcbiAgdmFyIHFpbnYgPSBwcml2LmNvZWZmaWNpZW50O1xuICB2YXIgcCA9IHByaXYucHJpbWUxO1xuICB2YXIgcSA9IHByaXYucHJpbWUyO1xuICB2YXIgbTEgPSBjMS5yZWRQb3cocHJpdi5leHBvbmVudDEpO1xuICB2YXIgbTIgPSBjMi5yZWRQb3cocHJpdi5leHBvbmVudDIpO1xuICBtMSA9IG0xLmZyb21SZWQoKTtcbiAgbTIgPSBtMi5mcm9tUmVkKCk7XG4gIHZhciBoID0gbTEuaXN1YihtMikuaW11bChxaW52KS51bW9kKHApO1xuICBoLmltdWwocSk7XG4gIG0yLmlhZGQoaCk7XG4gIHJldHVybiBuZXcgQnVmZmVyKG0yLmltdWwoYmxpbmRzLnVuYmxpbmRlcikudW1vZChwcml2Lm1vZHVsdXMpLnRvQXJyYXkoZmFsc2UsIGxlbikpO1xufVxuY3J0LmdldHIgPSBnZXRyO1xuZnVuY3Rpb24gZ2V0cihwcml2KSB7XG4gIHZhciBsZW4gPSBwcml2Lm1vZHVsdXMuYnl0ZUxlbmd0aCgpO1xuICB2YXIgciA9IG5ldyBibihyYW5kb21CeXRlcyhsZW4pKTtcbiAgd2hpbGUgKHIuY21wKHByaXYubW9kdWx1cykgPj0gIDAgfHwgIXIudW1vZChwcml2LnByaW1lMSkgfHwgIXIudW1vZChwcml2LnByaW1lMikpIHtcbiAgICByID0gbmV3IGJuKHJhbmRvbUJ5dGVzKGxlbikpO1xuICB9XG4gIHJldHVybiByO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZWxsaXB0aWMgPSBleHBvcnRzO1xuXG5lbGxpcHRpYy52ZXJzaW9uID0gcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJykudmVyc2lvbjtcbmVsbGlwdGljLnV0aWxzID0gcmVxdWlyZSgnLi9lbGxpcHRpYy91dGlscycpO1xuZWxsaXB0aWMucmFuZCA9IHJlcXVpcmUoJ2Jyb3JhbmQnKTtcbmVsbGlwdGljLmhtYWNEUkJHID0gcmVxdWlyZSgnLi9lbGxpcHRpYy9obWFjLWRyYmcnKTtcbmVsbGlwdGljLmN1cnZlID0gcmVxdWlyZSgnLi9lbGxpcHRpYy9jdXJ2ZScpO1xuZWxsaXB0aWMuY3VydmVzID0gcmVxdWlyZSgnLi9lbGxpcHRpYy9jdXJ2ZXMnKTtcblxuLy8gUHJvdG9jb2xzXG5lbGxpcHRpYy5lYyA9IHJlcXVpcmUoJy4vZWxsaXB0aWMvZWMnKTtcbmVsbGlwdGljLmVkZHNhID0gcmVxdWlyZSgnLi9lbGxpcHRpYy9lZGRzYScpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYm4gPSByZXF1aXJlKCdibi5qcycpO1xudmFyIGVsbGlwdGljID0gcmVxdWlyZSgnLi4vLi4vZWxsaXB0aWMnKTtcbnZhciB1dGlscyA9IGVsbGlwdGljLnV0aWxzO1xudmFyIGdldE5BRiA9IHV0aWxzLmdldE5BRjtcbnZhciBnZXRKU0YgPSB1dGlscy5nZXRKU0Y7XG52YXIgYXNzZXJ0ID0gdXRpbHMuYXNzZXJ0O1xuXG5mdW5jdGlvbiBCYXNlQ3VydmUodHlwZSwgY29uZikge1xuICB0aGlzLnR5cGUgPSB0eXBlO1xuICB0aGlzLnAgPSBuZXcgYm4oY29uZi5wLCAxNik7XG5cbiAgLy8gVXNlIE1vbnRnb21lcnksIHdoZW4gdGhlcmUgaXMgbm8gZmFzdCByZWR1Y3Rpb24gZm9yIHRoZSBwcmltZVxuICB0aGlzLnJlZCA9IGNvbmYucHJpbWUgPyBibi5yZWQoY29uZi5wcmltZSkgOiBibi5tb250KHRoaXMucCk7XG5cbiAgLy8gVXNlZnVsIGZvciBtYW55IGN1cnZlc1xuICB0aGlzLnplcm8gPSBuZXcgYm4oMCkudG9SZWQodGhpcy5yZWQpO1xuICB0aGlzLm9uZSA9IG5ldyBibigxKS50b1JlZCh0aGlzLnJlZCk7XG4gIHRoaXMudHdvID0gbmV3IGJuKDIpLnRvUmVkKHRoaXMucmVkKTtcblxuICAvLyBDdXJ2ZSBjb25maWd1cmF0aW9uLCBvcHRpb25hbFxuICB0aGlzLm4gPSBjb25mLm4gJiYgbmV3IGJuKGNvbmYubiwgMTYpO1xuICB0aGlzLmcgPSBjb25mLmcgJiYgdGhpcy5wb2ludEZyb21KU09OKGNvbmYuZywgY29uZi5nUmVkKTtcblxuICAvLyBUZW1wb3JhcnkgYXJyYXlzXG4gIHRoaXMuX3duYWZUMSA9IG5ldyBBcnJheSg0KTtcbiAgdGhpcy5fd25hZlQyID0gbmV3IEFycmF5KDQpO1xuICB0aGlzLl93bmFmVDMgPSBuZXcgQXJyYXkoNCk7XG4gIHRoaXMuX3duYWZUNCA9IG5ldyBBcnJheSg0KTtcbn1cbm1vZHVsZS5leHBvcnRzID0gQmFzZUN1cnZlO1xuXG5CYXNlQ3VydmUucHJvdG90eXBlLnBvaW50ID0gZnVuY3Rpb24gcG9pbnQoKSB7XG4gIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG59O1xuXG5CYXNlQ3VydmUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gdmFsaWRhdGUoKSB7XG4gIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG59O1xuXG5CYXNlQ3VydmUucHJvdG90eXBlLl9maXhlZE5hZk11bCA9IGZ1bmN0aW9uIF9maXhlZE5hZk11bChwLCBrKSB7XG4gIGFzc2VydChwLnByZWNvbXB1dGVkKTtcbiAgdmFyIGRvdWJsZXMgPSBwLl9nZXREb3VibGVzKCk7XG5cbiAgdmFyIG5hZiA9IGdldE5BRihrLCAxKTtcbiAgdmFyIEkgPSAoMSA8PCAoZG91Ymxlcy5zdGVwICsgMSkpIC0gKGRvdWJsZXMuc3RlcCAlIDIgPT09IDAgPyAyIDogMSk7XG4gIEkgLz0gMztcblxuICAvLyBUcmFuc2xhdGUgaW50byBtb3JlIHdpbmRvd2VkIGZvcm1cbiAgdmFyIHJlcHIgPSBbXTtcbiAgZm9yICh2YXIgaiA9IDA7IGogPCBuYWYubGVuZ3RoOyBqICs9IGRvdWJsZXMuc3RlcCkge1xuICAgIHZhciBuYWZXID0gMDtcbiAgICBmb3IgKHZhciBrID0gaiArIGRvdWJsZXMuc3RlcCAtIDE7IGsgPj0gajsgay0tKVxuICAgICAgbmFmVyA9IChuYWZXIDw8IDEpICsgbmFmW2tdO1xuICAgIHJlcHIucHVzaChuYWZXKTtcbiAgfVxuXG4gIHZhciBhID0gdGhpcy5qcG9pbnQobnVsbCwgbnVsbCwgbnVsbCk7XG4gIHZhciBiID0gdGhpcy5qcG9pbnQobnVsbCwgbnVsbCwgbnVsbCk7XG4gIGZvciAodmFyIGkgPSBJOyBpID4gMDsgaS0tKSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCByZXByLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgbmFmVyA9IHJlcHJbal07XG4gICAgICBpZiAobmFmVyA9PT0gaSlcbiAgICAgICAgYiA9IGIubWl4ZWRBZGQoZG91Ymxlcy5wb2ludHNbal0pO1xuICAgICAgZWxzZSBpZiAobmFmVyA9PT0gLWkpXG4gICAgICAgIGIgPSBiLm1peGVkQWRkKGRvdWJsZXMucG9pbnRzW2pdLm5lZygpKTtcbiAgICB9XG4gICAgYSA9IGEuYWRkKGIpO1xuICB9XG4gIHJldHVybiBhLnRvUCgpO1xufTtcblxuQmFzZUN1cnZlLnByb3RvdHlwZS5fd25hZk11bCA9IGZ1bmN0aW9uIF93bmFmTXVsKHAsIGspIHtcbiAgdmFyIHcgPSA0O1xuXG4gIC8vIFByZWNvbXB1dGUgd2luZG93XG4gIHZhciBuYWZQb2ludHMgPSBwLl9nZXROQUZQb2ludHModyk7XG4gIHcgPSBuYWZQb2ludHMud25kO1xuICB2YXIgd25kID0gbmFmUG9pbnRzLnBvaW50cztcblxuICAvLyBHZXQgTkFGIGZvcm1cbiAgdmFyIG5hZiA9IGdldE5BRihrLCB3KTtcblxuICAvLyBBZGQgYHRoaXNgKihOKzEpIGZvciBldmVyeSB3LU5BRiBpbmRleFxuICB2YXIgYWNjID0gdGhpcy5qcG9pbnQobnVsbCwgbnVsbCwgbnVsbCk7XG4gIGZvciAodmFyIGkgPSBuYWYubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAvLyBDb3VudCB6ZXJvZXNcbiAgICBmb3IgKHZhciBrID0gMDsgaSA+PSAwICYmIG5hZltpXSA9PT0gMDsgaS0tKVxuICAgICAgaysrO1xuICAgIGlmIChpID49IDApXG4gICAgICBrKys7XG4gICAgYWNjID0gYWNjLmRibHAoayk7XG5cbiAgICBpZiAoaSA8IDApXG4gICAgICBicmVhaztcbiAgICB2YXIgeiA9IG5hZltpXTtcbiAgICBhc3NlcnQoeiAhPT0gMCk7XG4gICAgaWYgKHAudHlwZSA9PT0gJ2FmZmluZScpIHtcbiAgICAgIC8vIEogKy0gUFxuICAgICAgaWYgKHogPiAwKVxuICAgICAgICBhY2MgPSBhY2MubWl4ZWRBZGQod25kWyh6IC0gMSkgPj4gMV0pO1xuICAgICAgZWxzZVxuICAgICAgICBhY2MgPSBhY2MubWl4ZWRBZGQod25kWygteiAtIDEpID4+IDFdLm5lZygpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSiArLSBKXG4gICAgICBpZiAoeiA+IDApXG4gICAgICAgIGFjYyA9IGFjYy5hZGQod25kWyh6IC0gMSkgPj4gMV0pO1xuICAgICAgZWxzZVxuICAgICAgICBhY2MgPSBhY2MuYWRkKHduZFsoLXogLSAxKSA+PiAxXS5uZWcoKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBwLnR5cGUgPT09ICdhZmZpbmUnID8gYWNjLnRvUCgpIDogYWNjO1xufTtcblxuQmFzZUN1cnZlLnByb3RvdHlwZS5fd25hZk11bEFkZCA9IGZ1bmN0aW9uIF93bmFmTXVsQWRkKGRlZlcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZWZmcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW4pIHtcbiAgdmFyIHduZFdpZHRoID0gdGhpcy5fd25hZlQxO1xuICB2YXIgd25kID0gdGhpcy5fd25hZlQyO1xuICB2YXIgbmFmID0gdGhpcy5fd25hZlQzO1xuXG4gIC8vIEZpbGwgYWxsIGFycmF5c1xuICB2YXIgbWF4ID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBwID0gcG9pbnRzW2ldO1xuICAgIHZhciBuYWZQb2ludHMgPSBwLl9nZXROQUZQb2ludHMoZGVmVyk7XG4gICAgd25kV2lkdGhbaV0gPSBuYWZQb2ludHMud25kO1xuICAgIHduZFtpXSA9IG5hZlBvaW50cy5wb2ludHM7XG4gIH1cblxuICAvLyBDb21iIHNtYWxsIHdpbmRvdyBOQUZzXG4gIGZvciAodmFyIGkgPSBsZW4gLSAxOyBpID49IDE7IGkgLT0gMikge1xuICAgIHZhciBhID0gaSAtIDE7XG4gICAgdmFyIGIgPSBpO1xuICAgIGlmICh3bmRXaWR0aFthXSAhPT0gMSB8fCB3bmRXaWR0aFtiXSAhPT0gMSkge1xuICAgICAgbmFmW2FdID0gZ2V0TkFGKGNvZWZmc1thXSwgd25kV2lkdGhbYV0pO1xuICAgICAgbmFmW2JdID0gZ2V0TkFGKGNvZWZmc1tiXSwgd25kV2lkdGhbYl0pO1xuICAgICAgbWF4ID0gTWF0aC5tYXgobmFmW2FdLmxlbmd0aCwgbWF4KTtcbiAgICAgIG1heCA9IE1hdGgubWF4KG5hZltiXS5sZW5ndGgsIG1heCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgY29tYiA9IFtcbiAgICAgIHBvaW50c1thXSwgLyogMSAqL1xuICAgICAgbnVsbCwgLyogMyAqL1xuICAgICAgbnVsbCwgLyogNSAqL1xuICAgICAgcG9pbnRzW2JdIC8qIDcgKi9cbiAgICBdO1xuXG4gICAgLy8gVHJ5IHRvIGF2b2lkIFByb2plY3RpdmUgcG9pbnRzLCBpZiBwb3NzaWJsZVxuICAgIGlmIChwb2ludHNbYV0ueS5jbXAocG9pbnRzW2JdLnkpID09PSAwKSB7XG4gICAgICBjb21iWzFdID0gcG9pbnRzW2FdLmFkZChwb2ludHNbYl0pO1xuICAgICAgY29tYlsyXSA9IHBvaW50c1thXS50b0ooKS5taXhlZEFkZChwb2ludHNbYl0ubmVnKCkpO1xuICAgIH0gZWxzZSBpZiAocG9pbnRzW2FdLnkuY21wKHBvaW50c1tiXS55LnJlZE5lZygpKSA9PT0gMCkge1xuICAgICAgY29tYlsxXSA9IHBvaW50c1thXS50b0ooKS5taXhlZEFkZChwb2ludHNbYl0pO1xuICAgICAgY29tYlsyXSA9IHBvaW50c1thXS5hZGQocG9pbnRzW2JdLm5lZygpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29tYlsxXSA9IHBvaW50c1thXS50b0ooKS5taXhlZEFkZChwb2ludHNbYl0pO1xuICAgICAgY29tYlsyXSA9IHBvaW50c1thXS50b0ooKS5taXhlZEFkZChwb2ludHNbYl0ubmVnKCkpO1xuICAgIH1cblxuICAgIHZhciBpbmRleCA9IFtcbiAgICAgIC0zLCAvKiAtMSAtMSAqL1xuICAgICAgLTEsIC8qIC0xIDAgKi9cbiAgICAgIC01LCAvKiAtMSAxICovXG4gICAgICAtNywgLyogMCAtMSAqL1xuICAgICAgMCwgLyogMCAwICovXG4gICAgICA3LCAvKiAwIDEgKi9cbiAgICAgIDUsIC8qIDEgLTEgKi9cbiAgICAgIDEsIC8qIDEgMCAqL1xuICAgICAgMyAgLyogMSAxICovXG4gICAgXTtcblxuICAgIHZhciBqc2YgPSBnZXRKU0YoY29lZmZzW2FdLCBjb2VmZnNbYl0pO1xuICAgIG1heCA9IE1hdGgubWF4KGpzZlswXS5sZW5ndGgsIG1heCk7XG4gICAgbmFmW2FdID0gbmV3IEFycmF5KG1heCk7XG4gICAgbmFmW2JdID0gbmV3IEFycmF5KG1heCk7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBtYXg7IGorKykge1xuICAgICAgdmFyIGphID0ganNmWzBdW2pdIHwgMDtcbiAgICAgIHZhciBqYiA9IGpzZlsxXVtqXSB8IDA7XG5cbiAgICAgIG5hZlthXVtqXSA9IGluZGV4WyhqYSArIDEpICogMyArIChqYiArIDEpXTtcbiAgICAgIG5hZltiXVtqXSA9IDA7XG4gICAgICB3bmRbYV0gPSBjb21iO1xuICAgIH1cbiAgfVxuXG4gIHZhciBhY2MgPSB0aGlzLmpwb2ludChudWxsLCBudWxsLCBudWxsKTtcbiAgdmFyIHRtcCA9IHRoaXMuX3duYWZUNDtcbiAgZm9yICh2YXIgaSA9IG1heDsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgayA9IDA7XG5cbiAgICB3aGlsZSAoaSA+PSAwKSB7XG4gICAgICB2YXIgemVybyA9IHRydWU7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgIHRtcFtqXSA9IG5hZltqXVtpXSB8IDA7XG4gICAgICAgIGlmICh0bXBbal0gIT09IDApXG4gICAgICAgICAgemVybyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKCF6ZXJvKVxuICAgICAgICBicmVhaztcbiAgICAgIGsrKztcbiAgICAgIGktLTtcbiAgICB9XG4gICAgaWYgKGkgPj0gMClcbiAgICAgIGsrKztcbiAgICBhY2MgPSBhY2MuZGJscChrKTtcbiAgICBpZiAoaSA8IDApXG4gICAgICBicmVhaztcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgIHZhciB6ID0gdG1wW2pdO1xuICAgICAgdmFyIHA7XG4gICAgICBpZiAoeiA9PT0gMClcbiAgICAgICAgY29udGludWU7XG4gICAgICBlbHNlIGlmICh6ID4gMClcbiAgICAgICAgcCA9IHduZFtqXVsoeiAtIDEpID4+IDFdO1xuICAgICAgZWxzZSBpZiAoeiA8IDApXG4gICAgICAgIHAgPSB3bmRbal1bKC16IC0gMSkgPj4gMV0ubmVnKCk7XG5cbiAgICAgIGlmIChwLnR5cGUgPT09ICdhZmZpbmUnKVxuICAgICAgICBhY2MgPSBhY2MubWl4ZWRBZGQocCk7XG4gICAgICBlbHNlXG4gICAgICAgIGFjYyA9IGFjYy5hZGQocCk7XG4gICAgfVxuICB9XG4gIC8vIFplcm9pZnkgcmVmZXJlbmNlc1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgIHduZFtpXSA9IG51bGw7XG4gIHJldHVybiBhY2MudG9QKCk7XG59O1xuXG5mdW5jdGlvbiBCYXNlUG9pbnQoY3VydmUsIHR5cGUpIHtcbiAgdGhpcy5jdXJ2ZSA9IGN1cnZlO1xuICB0aGlzLnR5cGUgPSB0eXBlO1xuICB0aGlzLnByZWNvbXB1dGVkID0gbnVsbDtcbn1cbkJhc2VDdXJ2ZS5CYXNlUG9pbnQgPSBCYXNlUG9pbnQ7XG5cbkJhc2VQb2ludC5wcm90b3R5cGUuZXEgPSBmdW5jdGlvbiBlcSgvKm90aGVyKi8pIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcbn07XG5cbkJhc2VQb2ludC5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiB2YWxpZGF0ZSgpIHtcbiAgcmV0dXJuIHRoaXMuY3VydmUudmFsaWRhdGUodGhpcyk7XG59O1xuXG5CYXNlQ3VydmUucHJvdG90eXBlLmRlY29kZVBvaW50ID0gZnVuY3Rpb24gZGVjb2RlUG9pbnQoYnl0ZXMsIGVuYykge1xuICBieXRlcyA9IHV0aWxzLnRvQXJyYXkoYnl0ZXMsIGVuYyk7XG5cbiAgdmFyIGxlbiA9IHRoaXMucC5ieXRlTGVuZ3RoKCk7XG4gIGlmIChieXRlc1swXSA9PT0gMHgwNCAmJiBieXRlcy5sZW5ndGggLSAxID09PSAyICogbGVuKSB7XG4gICAgcmV0dXJuIHRoaXMucG9pbnQoYnl0ZXMuc2xpY2UoMSwgMSArIGxlbiksXG4gICAgICAgICAgICAgICAgICAgICAgYnl0ZXMuc2xpY2UoMSArIGxlbiwgMSArIDIgKiBsZW4pKTtcbiAgfSBlbHNlIGlmICgoYnl0ZXNbMF0gPT09IDB4MDIgfHwgYnl0ZXNbMF0gPT09IDB4MDMpICYmXG4gICAgICAgICAgICAgIGJ5dGVzLmxlbmd0aCAtIDEgPT09IGxlbikge1xuICAgIHJldHVybiB0aGlzLnBvaW50RnJvbVgoYnl0ZXMuc2xpY2UoMSwgMSArIGxlbiksIGJ5dGVzWzBdID09PSAweDAzKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gcG9pbnQgZm9ybWF0Jyk7XG59O1xuXG5CYXNlUG9pbnQucHJvdG90eXBlLmVuY29kZUNvbXByZXNzZWQgPSBmdW5jdGlvbiBlbmNvZGVDb21wcmVzc2VkKGVuYykge1xuICByZXR1cm4gdGhpcy5lbmNvZGUoZW5jLCB0cnVlKTtcbn07XG5cbkJhc2VQb2ludC5wcm90b3R5cGUuX2VuY29kZSA9IGZ1bmN0aW9uIF9lbmNvZGUoY29tcGFjdCkge1xuICB2YXIgbGVuID0gdGhpcy5jdXJ2ZS5wLmJ5dGVMZW5ndGgoKTtcbiAgdmFyIHggPSB0aGlzLmdldFgoKS50b0FycmF5KCdiZScsIGxlbik7XG5cbiAgaWYgKGNvbXBhY3QpXG4gICAgcmV0dXJuIFsgdGhpcy5nZXRZKCkuaXNFdmVuKCkgPyAweDAyIDogMHgwMyBdLmNvbmNhdCh4KTtcblxuICByZXR1cm4gWyAweDA0IF0uY29uY2F0KHgsIHRoaXMuZ2V0WSgpLnRvQXJyYXkoJ2JlJywgbGVuKSkgO1xufTtcblxuQmFzZVBvaW50LnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUoZW5jLCBjb21wYWN0KSB7XG4gIHJldHVybiB1dGlscy5lbmNvZGUodGhpcy5fZW5jb2RlKGNvbXBhY3QpLCBlbmMpO1xufTtcblxuQmFzZVBvaW50LnByb3RvdHlwZS5wcmVjb21wdXRlID0gZnVuY3Rpb24gcHJlY29tcHV0ZShwb3dlcikge1xuICBpZiAodGhpcy5wcmVjb21wdXRlZClcbiAgICByZXR1cm4gdGhpcztcblxuICB2YXIgcHJlY29tcHV0ZWQgPSB7XG4gICAgZG91YmxlczogbnVsbCxcbiAgICBuYWY6IG51bGwsXG4gICAgYmV0YTogbnVsbFxuICB9O1xuICBwcmVjb21wdXRlZC5uYWYgPSB0aGlzLl9nZXROQUZQb2ludHMoOCk7XG4gIHByZWNvbXB1dGVkLmRvdWJsZXMgPSB0aGlzLl9nZXREb3VibGVzKDQsIHBvd2VyKTtcbiAgcHJlY29tcHV0ZWQuYmV0YSA9IHRoaXMuX2dldEJldGEoKTtcbiAgdGhpcy5wcmVjb21wdXRlZCA9IHByZWNvbXB1dGVkO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuQmFzZVBvaW50LnByb3RvdHlwZS5faGFzRG91YmxlcyA9IGZ1bmN0aW9uIF9oYXNEb3VibGVzKGspIHtcbiAgaWYgKCF0aGlzLnByZWNvbXB1dGVkKVxuICAgIHJldHVybiBmYWxzZTtcblxuICB2YXIgZG91YmxlcyA9IHRoaXMucHJlY29tcHV0ZWQuZG91YmxlcztcbiAgaWYgKCFkb3VibGVzKVxuICAgIHJldHVybiBmYWxzZTtcblxuICByZXR1cm4gZG91Ymxlcy5wb2ludHMubGVuZ3RoID49IE1hdGguY2VpbCgoay5iaXRMZW5ndGgoKSArIDEpIC8gZG91Ymxlcy5zdGVwKTtcbn07XG5cbkJhc2VQb2ludC5wcm90b3R5cGUuX2dldERvdWJsZXMgPSBmdW5jdGlvbiBfZ2V0RG91YmxlcyhzdGVwLCBwb3dlcikge1xuICBpZiAodGhpcy5wcmVjb21wdXRlZCAmJiB0aGlzLnByZWNvbXB1dGVkLmRvdWJsZXMpXG4gICAgcmV0dXJuIHRoaXMucHJlY29tcHV0ZWQuZG91YmxlcztcblxuICB2YXIgZG91YmxlcyA9IFsgdGhpcyBdO1xuICB2YXIgYWNjID0gdGhpcztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb3dlcjsgaSArPSBzdGVwKSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBzdGVwOyBqKyspXG4gICAgICBhY2MgPSBhY2MuZGJsKCk7XG4gICAgZG91Ymxlcy5wdXNoKGFjYyk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzdGVwOiBzdGVwLFxuICAgIHBvaW50czogZG91Ymxlc1xuICB9O1xufTtcblxuQmFzZVBvaW50LnByb3RvdHlwZS5fZ2V0TkFGUG9pbnRzID0gZnVuY3Rpb24gX2dldE5BRlBvaW50cyh3bmQpIHtcbiAgaWYgKHRoaXMucHJlY29tcHV0ZWQgJiYgdGhpcy5wcmVjb21wdXRlZC5uYWYpXG4gICAgcmV0dXJuIHRoaXMucHJlY29tcHV0ZWQubmFmO1xuXG4gIHZhciByZXMgPSBbIHRoaXMgXTtcbiAgdmFyIG1heCA9ICgxIDw8IHduZCkgLSAxO1xuICB2YXIgZGJsID0gbWF4ID09PSAxID8gbnVsbCA6IHRoaXMuZGJsKCk7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgbWF4OyBpKyspXG4gICAgcmVzW2ldID0gcmVzW2kgLSAxXS5hZGQoZGJsKTtcbiAgcmV0dXJuIHtcbiAgICB3bmQ6IHduZCxcbiAgICBwb2ludHM6IHJlc1xuICB9O1xufTtcblxuQmFzZVBvaW50LnByb3RvdHlwZS5fZ2V0QmV0YSA9IGZ1bmN0aW9uIF9nZXRCZXRhKCkge1xuICByZXR1cm4gbnVsbDtcbn07XG5cbkJhc2VQb2ludC5wcm90b3R5cGUuZGJscCA9IGZ1bmN0aW9uIGRibHAoaykge1xuICB2YXIgciA9IHRoaXM7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgazsgaSsrKVxuICAgIHIgPSByLmRibCgpO1xuICByZXR1cm4gcjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjdXJ2ZSA9IHJlcXVpcmUoJy4uL2N1cnZlJyk7XG52YXIgZWxsaXB0aWMgPSByZXF1aXJlKCcuLi8uLi9lbGxpcHRpYycpO1xudmFyIGJuID0gcmVxdWlyZSgnYm4uanMnKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG52YXIgQmFzZSA9IGN1cnZlLmJhc2U7XG5cbnZhciBhc3NlcnQgPSBlbGxpcHRpYy51dGlscy5hc3NlcnQ7XG5cbmZ1bmN0aW9uIEVkd2FyZHNDdXJ2ZShjb25mKSB7XG4gIC8vIE5PVEU6IEltcG9ydGFudCBhcyB3ZSBhcmUgY3JlYXRpbmcgcG9pbnQgaW4gQmFzZS5jYWxsKClcbiAgdGhpcy50d2lzdGVkID0gKGNvbmYuYSB8IDApICE9PSAxO1xuICB0aGlzLm1PbmVBID0gdGhpcy50d2lzdGVkICYmIChjb25mLmEgfCAwKSA9PT0gLTE7XG4gIHRoaXMuZXh0ZW5kZWQgPSB0aGlzLm1PbmVBO1xuXG4gIEJhc2UuY2FsbCh0aGlzLCAnZWR3YXJkcycsIGNvbmYpO1xuXG4gIHRoaXMuYSA9IG5ldyBibihjb25mLmEsIDE2KS51bW9kKHRoaXMucmVkLm0pO1xuICB0aGlzLmEgPSB0aGlzLmEudG9SZWQodGhpcy5yZWQpO1xuICB0aGlzLmMgPSBuZXcgYm4oY29uZi5jLCAxNikudG9SZWQodGhpcy5yZWQpO1xuICB0aGlzLmMyID0gdGhpcy5jLnJlZFNxcigpO1xuICB0aGlzLmQgPSBuZXcgYm4oY29uZi5kLCAxNikudG9SZWQodGhpcy5yZWQpO1xuICB0aGlzLmRkID0gdGhpcy5kLnJlZEFkZCh0aGlzLmQpO1xuXG4gIGFzc2VydCghdGhpcy50d2lzdGVkIHx8IHRoaXMuYy5mcm9tUmVkKCkuY21wbigxKSA9PT0gMCk7XG4gIHRoaXMub25lQyA9IChjb25mLmMgfCAwKSA9PT0gMTtcbn1cbmluaGVyaXRzKEVkd2FyZHNDdXJ2ZSwgQmFzZSk7XG5tb2R1bGUuZXhwb3J0cyA9IEVkd2FyZHNDdXJ2ZTtcblxuRWR3YXJkc0N1cnZlLnByb3RvdHlwZS5fbXVsQSA9IGZ1bmN0aW9uIF9tdWxBKG51bSkge1xuICBpZiAodGhpcy5tT25lQSlcbiAgICByZXR1cm4gbnVtLnJlZE5lZygpO1xuICBlbHNlXG4gICAgcmV0dXJuIHRoaXMuYS5yZWRNdWwobnVtKTtcbn07XG5cbkVkd2FyZHNDdXJ2ZS5wcm90b3R5cGUuX211bEMgPSBmdW5jdGlvbiBfbXVsQyhudW0pIHtcbiAgaWYgKHRoaXMub25lQylcbiAgICByZXR1cm4gbnVtO1xuICBlbHNlXG4gICAgcmV0dXJuIHRoaXMuYy5yZWRNdWwobnVtKTtcbn07XG5cbi8vIEp1c3QgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBTaG9ydCBjdXJ2ZVxuRWR3YXJkc0N1cnZlLnByb3RvdHlwZS5qcG9pbnQgPSBmdW5jdGlvbiBqcG9pbnQoeCwgeSwgeiwgdCkge1xuICByZXR1cm4gdGhpcy5wb2ludCh4LCB5LCB6LCB0KTtcbn07XG5cbkVkd2FyZHNDdXJ2ZS5wcm90b3R5cGUucG9pbnRGcm9tWCA9IGZ1bmN0aW9uIHBvaW50RnJvbVgoeCwgb2RkKSB7XG4gIHggPSBuZXcgYm4oeCwgMTYpO1xuICBpZiAoIXgucmVkKVxuICAgIHggPSB4LnRvUmVkKHRoaXMucmVkKTtcblxuICB2YXIgeDIgPSB4LnJlZFNxcigpO1xuICB2YXIgcmhzID0gdGhpcy5jMi5yZWRTdWIodGhpcy5hLnJlZE11bCh4MikpO1xuICB2YXIgbGhzID0gdGhpcy5vbmUucmVkU3ViKHRoaXMuYzIucmVkTXVsKHRoaXMuZCkucmVkTXVsKHgyKSk7XG5cbiAgdmFyIHkgPSByaHMucmVkTXVsKGxocy5yZWRJbnZtKCkpLnJlZFNxcnQoKTtcbiAgdmFyIGlzT2RkID0geS5mcm9tUmVkKCkuaXNPZGQoKTtcbiAgaWYgKG9kZCAmJiAhaXNPZGQgfHwgIW9kZCAmJiBpc09kZClcbiAgICB5ID0geS5yZWROZWcoKTtcblxuICByZXR1cm4gdGhpcy5wb2ludCh4LCB5KTtcbn07XG5cbkVkd2FyZHNDdXJ2ZS5wcm90b3R5cGUucG9pbnRGcm9tWSA9IGZ1bmN0aW9uIHBvaW50RnJvbVkoeSwgb2RkKSB7XG4gIHkgPSBuZXcgYm4oeSwgMTYpO1xuICBpZiAoIXkucmVkKVxuICAgIHkgPSB5LnRvUmVkKHRoaXMucmVkKTtcblxuICAvLyB4XjIgPSAoeV4yIC0gMSkgLyAoZCB5XjIgKyAxKVxuICB2YXIgeTIgPSB5LnJlZFNxcigpO1xuICB2YXIgbGhzID0geTIucmVkU3ViKHRoaXMub25lKTtcbiAgdmFyIHJocyA9IHkyLnJlZE11bCh0aGlzLmQpLnJlZEFkZCh0aGlzLm9uZSk7XG4gIHZhciB4MiA9IGxocy5yZWRNdWwocmhzLnJlZEludm0oKSk7XG5cbiAgaWYgKHgyLmNtcCh0aGlzLnplcm8pID09PSAwKSB7XG4gICAgaWYgKG9kZClcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwb2ludCcpO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiB0aGlzLnBvaW50KHRoaXMuemVybywgeSk7XG4gIH1cblxuICB2YXIgeCA9IHgyLnJlZFNxcnQoKTtcbiAgaWYgKHgucmVkU3FyKCkucmVkU3ViKHgyKS5jbXAodGhpcy56ZXJvKSAhPT0gMClcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcG9pbnQnKTtcblxuICBpZiAoeC5pc09kZCgpICE9PSBvZGQpXG4gICAgeCA9IHgucmVkTmVnKCk7XG5cbiAgcmV0dXJuIHRoaXMucG9pbnQoeCwgeSk7XG59O1xuXG5FZHdhcmRzQ3VydmUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gdmFsaWRhdGUocG9pbnQpIHtcbiAgaWYgKHBvaW50LmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gdHJ1ZTtcblxuICAvLyBDdXJ2ZTogQSAqIFheMiArIFleMiA9IENeMiAqICgxICsgRCAqIFheMiAqIFleMilcbiAgcG9pbnQubm9ybWFsaXplKCk7XG5cbiAgdmFyIHgyID0gcG9pbnQueC5yZWRTcXIoKTtcbiAgdmFyIHkyID0gcG9pbnQueS5yZWRTcXIoKTtcbiAgdmFyIGxocyA9IHgyLnJlZE11bCh0aGlzLmEpLnJlZEFkZCh5Mik7XG4gIHZhciByaHMgPSB0aGlzLmMyLnJlZE11bCh0aGlzLm9uZS5yZWRBZGQodGhpcy5kLnJlZE11bCh4MikucmVkTXVsKHkyKSkpO1xuXG4gIHJldHVybiBsaHMuY21wKHJocykgPT09IDA7XG59O1xuXG5mdW5jdGlvbiBQb2ludChjdXJ2ZSwgeCwgeSwgeiwgdCkge1xuICBCYXNlLkJhc2VQb2ludC5jYWxsKHRoaXMsIGN1cnZlLCAncHJvamVjdGl2ZScpO1xuICBpZiAoeCA9PT0gbnVsbCAmJiB5ID09PSBudWxsICYmIHogPT09IG51bGwpIHtcbiAgICB0aGlzLnggPSB0aGlzLmN1cnZlLnplcm87XG4gICAgdGhpcy55ID0gdGhpcy5jdXJ2ZS5vbmU7XG4gICAgdGhpcy56ID0gdGhpcy5jdXJ2ZS5vbmU7XG4gICAgdGhpcy50ID0gdGhpcy5jdXJ2ZS56ZXJvO1xuICAgIHRoaXMuek9uZSA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy54ID0gbmV3IGJuKHgsIDE2KTtcbiAgICB0aGlzLnkgPSBuZXcgYm4oeSwgMTYpO1xuICAgIHRoaXMueiA9IHogPyBuZXcgYm4oeiwgMTYpIDogdGhpcy5jdXJ2ZS5vbmU7XG4gICAgdGhpcy50ID0gdCAmJiBuZXcgYm4odCwgMTYpO1xuICAgIGlmICghdGhpcy54LnJlZClcbiAgICAgIHRoaXMueCA9IHRoaXMueC50b1JlZCh0aGlzLmN1cnZlLnJlZCk7XG4gICAgaWYgKCF0aGlzLnkucmVkKVxuICAgICAgdGhpcy55ID0gdGhpcy55LnRvUmVkKHRoaXMuY3VydmUucmVkKTtcbiAgICBpZiAoIXRoaXMuei5yZWQpXG4gICAgICB0aGlzLnogPSB0aGlzLnoudG9SZWQodGhpcy5jdXJ2ZS5yZWQpO1xuICAgIGlmICh0aGlzLnQgJiYgIXRoaXMudC5yZWQpXG4gICAgICB0aGlzLnQgPSB0aGlzLnQudG9SZWQodGhpcy5jdXJ2ZS5yZWQpO1xuICAgIHRoaXMuek9uZSA9IHRoaXMueiA9PT0gdGhpcy5jdXJ2ZS5vbmU7XG5cbiAgICAvLyBVc2UgZXh0ZW5kZWQgY29vcmRpbmF0ZXNcbiAgICBpZiAodGhpcy5jdXJ2ZS5leHRlbmRlZCAmJiAhdGhpcy50KSB7XG4gICAgICB0aGlzLnQgPSB0aGlzLngucmVkTXVsKHRoaXMueSk7XG4gICAgICBpZiAoIXRoaXMuek9uZSlcbiAgICAgICAgdGhpcy50ID0gdGhpcy50LnJlZE11bCh0aGlzLnoucmVkSW52bSgpKTtcbiAgICB9XG4gIH1cbn1cbmluaGVyaXRzKFBvaW50LCBCYXNlLkJhc2VQb2ludCk7XG5cbkVkd2FyZHNDdXJ2ZS5wcm90b3R5cGUucG9pbnRGcm9tSlNPTiA9IGZ1bmN0aW9uIHBvaW50RnJvbUpTT04ob2JqKSB7XG4gIHJldHVybiBQb2ludC5mcm9tSlNPTih0aGlzLCBvYmopO1xufTtcblxuRWR3YXJkc0N1cnZlLnByb3RvdHlwZS5wb2ludCA9IGZ1bmN0aW9uIHBvaW50KHgsIHksIHosIHQpIHtcbiAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLCB4LCB5LCB6LCB0KTtcbn07XG5cblBvaW50LmZyb21KU09OID0gZnVuY3Rpb24gZnJvbUpTT04oY3VydmUsIG9iaikge1xuICByZXR1cm4gbmV3IFBvaW50KGN1cnZlLCBvYmpbMF0sIG9ialsxXSwgb2JqWzJdKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCgpIHtcbiAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiAnPEVDIFBvaW50IEluZmluaXR5Pic7XG4gIHJldHVybiAnPEVDIFBvaW50IHg6ICcgKyB0aGlzLnguZnJvbVJlZCgpLnRvU3RyaW5nKDE2LCAyKSArXG4gICAgICAnIHk6ICcgKyB0aGlzLnkuZnJvbVJlZCgpLnRvU3RyaW5nKDE2LCAyKSArXG4gICAgICAnIHo6ICcgKyB0aGlzLnouZnJvbVJlZCgpLnRvU3RyaW5nKDE2LCAyKSArICc+Jztcbn07XG5cblBvaW50LnByb3RvdHlwZS5pc0luZmluaXR5ID0gZnVuY3Rpb24gaXNJbmZpbml0eSgpIHtcbiAgLy8gWFhYIFRoaXMgY29kZSBhc3N1bWVzIHRoYXQgemVybyBpcyBhbHdheXMgemVybyBpbiByZWRcbiAgcmV0dXJuIHRoaXMueC5jbXBuKDApID09PSAwICYmXG4gICAgICAgICB0aGlzLnkuY21wKHRoaXMueikgPT09IDA7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuX2V4dERibCA9IGZ1bmN0aW9uIF9leHREYmwoKSB7XG4gIC8vIGh5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by10d2lzdGVkLWV4dGVuZGVkLTEuaHRtbFxuICAvLyAgICAgI2RvdWJsaW5nLWRibC0yMDA4LWh3Y2RcbiAgLy8gNE0gKyA0U1xuXG4gIC8vIEEgPSBYMV4yXG4gIHZhciBhID0gdGhpcy54LnJlZFNxcigpO1xuICAvLyBCID0gWTFeMlxuICB2YXIgYiA9IHRoaXMueS5yZWRTcXIoKTtcbiAgLy8gQyA9IDIgKiBaMV4yXG4gIHZhciBjID0gdGhpcy56LnJlZFNxcigpO1xuICBjID0gYy5yZWRJQWRkKGMpO1xuICAvLyBEID0gYSAqIEFcbiAgdmFyIGQgPSB0aGlzLmN1cnZlLl9tdWxBKGEpO1xuICAvLyBFID0gKFgxICsgWTEpXjIgLSBBIC0gQlxuICB2YXIgZSA9IHRoaXMueC5yZWRBZGQodGhpcy55KS5yZWRTcXIoKS5yZWRJU3ViKGEpLnJlZElTdWIoYik7XG4gIC8vIEcgPSBEICsgQlxuICB2YXIgZyA9IGQucmVkQWRkKGIpO1xuICAvLyBGID0gRyAtIENcbiAgdmFyIGYgPSBnLnJlZFN1YihjKTtcbiAgLy8gSCA9IEQgLSBCXG4gIHZhciBoID0gZC5yZWRTdWIoYik7XG4gIC8vIFgzID0gRSAqIEZcbiAgdmFyIG54ID0gZS5yZWRNdWwoZik7XG4gIC8vIFkzID0gRyAqIEhcbiAgdmFyIG55ID0gZy5yZWRNdWwoaCk7XG4gIC8vIFQzID0gRSAqIEhcbiAgdmFyIG50ID0gZS5yZWRNdWwoaCk7XG4gIC8vIFozID0gRiAqIEdcbiAgdmFyIG56ID0gZi5yZWRNdWwoZyk7XG4gIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG54LCBueSwgbnosIG50KTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5fcHJvakRibCA9IGZ1bmN0aW9uIF9wcm9qRGJsKCkge1xuICAvLyBoeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tdHdpc3RlZC1wcm9qZWN0aXZlLmh0bWxcbiAgLy8gICAgICNkb3VibGluZy1kYmwtMjAwOC1iYmpscFxuICAvLyAgICAgI2RvdWJsaW5nLWRibC0yMDA3LWJsXG4gIC8vIGFuZCBvdGhlcnNcbiAgLy8gR2VuZXJhbGx5IDNNICsgNFMgb3IgMk0gKyA0U1xuXG4gIC8vIEIgPSAoWDEgKyBZMSleMlxuICB2YXIgYiA9IHRoaXMueC5yZWRBZGQodGhpcy55KS5yZWRTcXIoKTtcbiAgLy8gQyA9IFgxXjJcbiAgdmFyIGMgPSB0aGlzLngucmVkU3FyKCk7XG4gIC8vIEQgPSBZMV4yXG4gIHZhciBkID0gdGhpcy55LnJlZFNxcigpO1xuXG4gIHZhciBueDtcbiAgdmFyIG55O1xuICB2YXIgbno7XG4gIGlmICh0aGlzLmN1cnZlLnR3aXN0ZWQpIHtcbiAgICAvLyBFID0gYSAqIENcbiAgICB2YXIgZSA9IHRoaXMuY3VydmUuX211bEEoYyk7XG4gICAgLy8gRiA9IEUgKyBEXG4gICAgdmFyIGYgPSBlLnJlZEFkZChkKTtcbiAgICBpZiAodGhpcy56T25lKSB7XG4gICAgICAvLyBYMyA9IChCIC0gQyAtIEQpICogKEYgLSAyKVxuICAgICAgbnggPSBiLnJlZFN1YihjKS5yZWRTdWIoZCkucmVkTXVsKGYucmVkU3ViKHRoaXMuY3VydmUudHdvKSk7XG4gICAgICAvLyBZMyA9IEYgKiAoRSAtIEQpXG4gICAgICBueSA9IGYucmVkTXVsKGUucmVkU3ViKGQpKTtcbiAgICAgIC8vIFozID0gRl4yIC0gMiAqIEZcbiAgICAgIG56ID0gZi5yZWRTcXIoKS5yZWRTdWIoZikucmVkU3ViKGYpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBIID0gWjFeMlxuICAgICAgdmFyIGggPSB0aGlzLnoucmVkU3FyKCk7XG4gICAgICAvLyBKID0gRiAtIDIgKiBIXG4gICAgICB2YXIgaiA9IGYucmVkU3ViKGgpLnJlZElTdWIoaCk7XG4gICAgICAvLyBYMyA9IChCLUMtRCkqSlxuICAgICAgbnggPSBiLnJlZFN1YihjKS5yZWRJU3ViKGQpLnJlZE11bChqKTtcbiAgICAgIC8vIFkzID0gRiAqIChFIC0gRClcbiAgICAgIG55ID0gZi5yZWRNdWwoZS5yZWRTdWIoZCkpO1xuICAgICAgLy8gWjMgPSBGICogSlxuICAgICAgbnogPSBmLnJlZE11bChqKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gRSA9IEMgKyBEXG4gICAgdmFyIGUgPSBjLnJlZEFkZChkKTtcbiAgICAvLyBIID0gKGMgKiBaMSleMlxuICAgIHZhciBoID0gdGhpcy5jdXJ2ZS5fbXVsQyh0aGlzLmMucmVkTXVsKHRoaXMueikpLnJlZFNxcigpO1xuICAgIC8vIEogPSBFIC0gMiAqIEhcbiAgICB2YXIgaiA9IGUucmVkU3ViKGgpLnJlZFN1YihoKTtcbiAgICAvLyBYMyA9IGMgKiAoQiAtIEUpICogSlxuICAgIG54ID0gdGhpcy5jdXJ2ZS5fbXVsQyhiLnJlZElTdWIoZSkpLnJlZE11bChqKTtcbiAgICAvLyBZMyA9IGMgKiBFICogKEMgLSBEKVxuICAgIG55ID0gdGhpcy5jdXJ2ZS5fbXVsQyhlKS5yZWRNdWwoYy5yZWRJU3ViKGQpKTtcbiAgICAvLyBaMyA9IEUgKiBKXG4gICAgbnogPSBlLnJlZE11bChqKTtcbiAgfVxuICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChueCwgbnksIG56KTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5kYmwgPSBmdW5jdGlvbiBkYmwoKSB7XG4gIGlmICh0aGlzLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBEb3VibGUgaW4gZXh0ZW5kZWQgY29vcmRpbmF0ZXNcbiAgaWYgKHRoaXMuY3VydmUuZXh0ZW5kZWQpXG4gICAgcmV0dXJuIHRoaXMuX2V4dERibCgpO1xuICBlbHNlXG4gICAgcmV0dXJuIHRoaXMuX3Byb2pEYmwoKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5fZXh0QWRkID0gZnVuY3Rpb24gX2V4dEFkZChwKSB7XG4gIC8vIGh5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by10d2lzdGVkLWV4dGVuZGVkLTEuaHRtbFxuICAvLyAgICAgI2FkZGl0aW9uLWFkZC0yMDA4LWh3Y2QtM1xuICAvLyA4TVxuXG4gIC8vIEEgPSAoWTEgLSBYMSkgKiAoWTIgLSBYMilcbiAgdmFyIGEgPSB0aGlzLnkucmVkU3ViKHRoaXMueCkucmVkTXVsKHAueS5yZWRTdWIocC54KSk7XG4gIC8vIEIgPSAoWTEgKyBYMSkgKiAoWTIgKyBYMilcbiAgdmFyIGIgPSB0aGlzLnkucmVkQWRkKHRoaXMueCkucmVkTXVsKHAueS5yZWRBZGQocC54KSk7XG4gIC8vIEMgPSBUMSAqIGsgKiBUMlxuICB2YXIgYyA9IHRoaXMudC5yZWRNdWwodGhpcy5jdXJ2ZS5kZCkucmVkTXVsKHAudCk7XG4gIC8vIEQgPSBaMSAqIDIgKiBaMlxuICB2YXIgZCA9IHRoaXMuei5yZWRNdWwocC56LnJlZEFkZChwLnopKTtcbiAgLy8gRSA9IEIgLSBBXG4gIHZhciBlID0gYi5yZWRTdWIoYSk7XG4gIC8vIEYgPSBEIC0gQ1xuICB2YXIgZiA9IGQucmVkU3ViKGMpO1xuICAvLyBHID0gRCArIENcbiAgdmFyIGcgPSBkLnJlZEFkZChjKTtcbiAgLy8gSCA9IEIgKyBBXG4gIHZhciBoID0gYi5yZWRBZGQoYSk7XG4gIC8vIFgzID0gRSAqIEZcbiAgdmFyIG54ID0gZS5yZWRNdWwoZik7XG4gIC8vIFkzID0gRyAqIEhcbiAgdmFyIG55ID0gZy5yZWRNdWwoaCk7XG4gIC8vIFQzID0gRSAqIEhcbiAgdmFyIG50ID0gZS5yZWRNdWwoaCk7XG4gIC8vIFozID0gRiAqIEdcbiAgdmFyIG56ID0gZi5yZWRNdWwoZyk7XG4gIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG54LCBueSwgbnosIG50KTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5fcHJvakFkZCA9IGZ1bmN0aW9uIF9wcm9qQWRkKHApIHtcbiAgLy8gaHlwZXJlbGxpcHRpYy5vcmcvRUZEL2cxcC9hdXRvLXR3aXN0ZWQtcHJvamVjdGl2ZS5odG1sXG4gIC8vICAgICAjYWRkaXRpb24tYWRkLTIwMDgtYmJqbHBcbiAgLy8gICAgICNhZGRpdGlvbi1hZGQtMjAwNy1ibFxuICAvLyAxME0gKyAxU1xuXG4gIC8vIEEgPSBaMSAqIFoyXG4gIHZhciBhID0gdGhpcy56LnJlZE11bChwLnopO1xuICAvLyBCID0gQV4yXG4gIHZhciBiID0gYS5yZWRTcXIoKTtcbiAgLy8gQyA9IFgxICogWDJcbiAgdmFyIGMgPSB0aGlzLngucmVkTXVsKHAueCk7XG4gIC8vIEQgPSBZMSAqIFkyXG4gIHZhciBkID0gdGhpcy55LnJlZE11bChwLnkpO1xuICAvLyBFID0gZCAqIEMgKiBEXG4gIHZhciBlID0gdGhpcy5jdXJ2ZS5kLnJlZE11bChjKS5yZWRNdWwoZCk7XG4gIC8vIEYgPSBCIC0gRVxuICB2YXIgZiA9IGIucmVkU3ViKGUpO1xuICAvLyBHID0gQiArIEVcbiAgdmFyIGcgPSBiLnJlZEFkZChlKTtcbiAgLy8gWDMgPSBBICogRiAqICgoWDEgKyBZMSkgKiAoWDIgKyBZMikgLSBDIC0gRClcbiAgdmFyIHRtcCA9IHRoaXMueC5yZWRBZGQodGhpcy55KS5yZWRNdWwocC54LnJlZEFkZChwLnkpKS5yZWRJU3ViKGMpLnJlZElTdWIoZCk7XG4gIHZhciBueCA9IGEucmVkTXVsKGYpLnJlZE11bCh0bXApO1xuICB2YXIgbnk7XG4gIHZhciBuejtcbiAgaWYgKHRoaXMuY3VydmUudHdpc3RlZCkge1xuICAgIC8vIFkzID0gQSAqIEcgKiAoRCAtIGEgKiBDKVxuICAgIG55ID0gYS5yZWRNdWwoZykucmVkTXVsKGQucmVkU3ViKHRoaXMuY3VydmUuX211bEEoYykpKTtcbiAgICAvLyBaMyA9IEYgKiBHXG4gICAgbnogPSBmLnJlZE11bChnKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBZMyA9IEEgKiBHICogKEQgLSBDKVxuICAgIG55ID0gYS5yZWRNdWwoZykucmVkTXVsKGQucmVkU3ViKGMpKTtcbiAgICAvLyBaMyA9IGMgKiBGICogR1xuICAgIG56ID0gdGhpcy5jdXJ2ZS5fbXVsQyhmKS5yZWRNdWwoZyk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobngsIG55LCBueik7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKHApIHtcbiAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiBwO1xuICBpZiAocC5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgaWYgKHRoaXMuY3VydmUuZXh0ZW5kZWQpXG4gICAgcmV0dXJuIHRoaXMuX2V4dEFkZChwKTtcbiAgZWxzZVxuICAgIHJldHVybiB0aGlzLl9wcm9qQWRkKHApO1xufTtcblxuUG9pbnQucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uIG11bChrKSB7XG4gIGlmICh0aGlzLl9oYXNEb3VibGVzKGspKVxuICAgIHJldHVybiB0aGlzLmN1cnZlLl9maXhlZE5hZk11bCh0aGlzLCBrKTtcbiAgZWxzZVxuICAgIHJldHVybiB0aGlzLmN1cnZlLl93bmFmTXVsKHRoaXMsIGspO1xufTtcblxuUG9pbnQucHJvdG90eXBlLm11bEFkZCA9IGZ1bmN0aW9uIG11bEFkZChrMSwgcCwgazIpIHtcbiAgcmV0dXJuIHRoaXMuY3VydmUuX3duYWZNdWxBZGQoMSwgWyB0aGlzLCBwIF0sIFsgazEsIGsyIF0sIDIpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIG5vcm1hbGl6ZSgpIHtcbiAgaWYgKHRoaXMuek9uZSlcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBOb3JtYWxpemUgY29vcmRpbmF0ZXNcbiAgdmFyIHppID0gdGhpcy56LnJlZEludm0oKTtcbiAgdGhpcy54ID0gdGhpcy54LnJlZE11bCh6aSk7XG4gIHRoaXMueSA9IHRoaXMueS5yZWRNdWwoemkpO1xuICBpZiAodGhpcy50KVxuICAgIHRoaXMudCA9IHRoaXMudC5yZWRNdWwoemkpO1xuICB0aGlzLnogPSB0aGlzLmN1cnZlLm9uZTtcbiAgdGhpcy56T25lID0gdHJ1ZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUubmVnID0gZnVuY3Rpb24gbmVnKCkge1xuICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludCh0aGlzLngucmVkTmVnKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMueSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy56LFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnQgJiYgdGhpcy50LnJlZE5lZygpKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5nZXRYID0gZnVuY3Rpb24gZ2V0WCgpIHtcbiAgdGhpcy5ub3JtYWxpemUoKTtcbiAgcmV0dXJuIHRoaXMueC5mcm9tUmVkKCk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZ2V0WSA9IGZ1bmN0aW9uIGdldFkoKSB7XG4gIHRoaXMubm9ybWFsaXplKCk7XG4gIHJldHVybiB0aGlzLnkuZnJvbVJlZCgpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmVxID0gZnVuY3Rpb24gZXEob3RoZXIpIHtcbiAgcmV0dXJuIHRoaXMgPT09IG90aGVyIHx8XG4gICAgICAgICB0aGlzLmdldFgoKS5jbXAob3RoZXIuZ2V0WCgpKSA9PT0gMCAmJlxuICAgICAgICAgdGhpcy5nZXRZKCkuY21wKG90aGVyLmdldFkoKSkgPT09IDA7XG59O1xuXG4vLyBDb21wYXRpYmlsaXR5IHdpdGggQmFzZUN1cnZlXG5Qb2ludC5wcm90b3R5cGUudG9QID0gUG9pbnQucHJvdG90eXBlLm5vcm1hbGl6ZTtcblBvaW50LnByb3RvdHlwZS5taXhlZEFkZCA9IFBvaW50LnByb3RvdHlwZS5hZGQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjdXJ2ZSA9IGV4cG9ydHM7XG5cbmN1cnZlLmJhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcbmN1cnZlLnNob3J0ID0gcmVxdWlyZSgnLi9zaG9ydCcpO1xuY3VydmUubW9udCA9IHJlcXVpcmUoJy4vbW9udCcpO1xuY3VydmUuZWR3YXJkcyA9IHJlcXVpcmUoJy4vZWR3YXJkcycpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY3VydmUgPSByZXF1aXJlKCcuLi9jdXJ2ZScpO1xudmFyIGJuID0gcmVxdWlyZSgnYm4uanMnKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG52YXIgQmFzZSA9IGN1cnZlLmJhc2U7XG5cbnZhciBlbGxpcHRpYyA9IHJlcXVpcmUoJy4uLy4uL2VsbGlwdGljJyk7XG52YXIgdXRpbHMgPSBlbGxpcHRpYy51dGlscztcblxuZnVuY3Rpb24gTW9udEN1cnZlKGNvbmYpIHtcbiAgQmFzZS5jYWxsKHRoaXMsICdtb250JywgY29uZik7XG5cbiAgdGhpcy5hID0gbmV3IGJuKGNvbmYuYSwgMTYpLnRvUmVkKHRoaXMucmVkKTtcbiAgdGhpcy5iID0gbmV3IGJuKGNvbmYuYiwgMTYpLnRvUmVkKHRoaXMucmVkKTtcbiAgdGhpcy5pNCA9IG5ldyBibig0KS50b1JlZCh0aGlzLnJlZCkucmVkSW52bSgpO1xuICB0aGlzLnR3byA9IG5ldyBibigyKS50b1JlZCh0aGlzLnJlZCk7XG4gIHRoaXMuYTI0ID0gdGhpcy5pNC5yZWRNdWwodGhpcy5hLnJlZEFkZCh0aGlzLnR3bykpO1xufVxuaW5oZXJpdHMoTW9udEN1cnZlLCBCYXNlKTtcbm1vZHVsZS5leHBvcnRzID0gTW9udEN1cnZlO1xuXG5Nb250Q3VydmUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gdmFsaWRhdGUocG9pbnQpIHtcbiAgdmFyIHggPSBwb2ludC5ub3JtYWxpemUoKS54O1xuICB2YXIgeDIgPSB4LnJlZFNxcigpO1xuICB2YXIgcmhzID0geDIucmVkTXVsKHgpLnJlZEFkZCh4Mi5yZWRNdWwodGhpcy5hKSkucmVkQWRkKHgpO1xuICB2YXIgeSA9IHJocy5yZWRTcXJ0KCk7XG5cbiAgcmV0dXJuIHkucmVkU3FyKCkuY21wKHJocykgPT09IDA7XG59O1xuXG5mdW5jdGlvbiBQb2ludChjdXJ2ZSwgeCwgeikge1xuICBCYXNlLkJhc2VQb2ludC5jYWxsKHRoaXMsIGN1cnZlLCAncHJvamVjdGl2ZScpO1xuICBpZiAoeCA9PT0gbnVsbCAmJiB6ID09PSBudWxsKSB7XG4gICAgdGhpcy54ID0gdGhpcy5jdXJ2ZS5vbmU7XG4gICAgdGhpcy56ID0gdGhpcy5jdXJ2ZS56ZXJvO1xuICB9IGVsc2Uge1xuICAgIHRoaXMueCA9IG5ldyBibih4LCAxNik7XG4gICAgdGhpcy56ID0gbmV3IGJuKHosIDE2KTtcbiAgICBpZiAoIXRoaXMueC5yZWQpXG4gICAgICB0aGlzLnggPSB0aGlzLngudG9SZWQodGhpcy5jdXJ2ZS5yZWQpO1xuICAgIGlmICghdGhpcy56LnJlZClcbiAgICAgIHRoaXMueiA9IHRoaXMuei50b1JlZCh0aGlzLmN1cnZlLnJlZCk7XG4gIH1cbn1cbmluaGVyaXRzKFBvaW50LCBCYXNlLkJhc2VQb2ludCk7XG5cbk1vbnRDdXJ2ZS5wcm90b3R5cGUuZGVjb2RlUG9pbnQgPSBmdW5jdGlvbiBkZWNvZGVQb2ludChieXRlcywgZW5jKSB7XG4gIHJldHVybiB0aGlzLnBvaW50KHV0aWxzLnRvQXJyYXkoYnl0ZXMsIGVuYyksIDEpO1xufTtcblxuTW9udEN1cnZlLnByb3RvdHlwZS5wb2ludCA9IGZ1bmN0aW9uIHBvaW50KHgsIHopIHtcbiAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLCB4LCB6KTtcbn07XG5cbk1vbnRDdXJ2ZS5wcm90b3R5cGUucG9pbnRGcm9tSlNPTiA9IGZ1bmN0aW9uIHBvaW50RnJvbUpTT04ob2JqKSB7XG4gIHJldHVybiBQb2ludC5mcm9tSlNPTih0aGlzLCBvYmopO1xufTtcblxuUG9pbnQucHJvdG90eXBlLnByZWNvbXB1dGUgPSBmdW5jdGlvbiBwcmVjb21wdXRlKCkge1xuICAvLyBOby1vcFxufTtcblxuUG9pbnQucHJvdG90eXBlLl9lbmNvZGUgPSBmdW5jdGlvbiBfZW5jb2RlKCkge1xuICByZXR1cm4gdGhpcy5nZXRYKCkudG9BcnJheSgnYmUnLCB0aGlzLmN1cnZlLnAuYnl0ZUxlbmd0aCgpKTtcbn07XG5cblBvaW50LmZyb21KU09OID0gZnVuY3Rpb24gZnJvbUpTT04oY3VydmUsIG9iaikge1xuICByZXR1cm4gbmV3IFBvaW50KGN1cnZlLCBvYmpbMF0sIG9ialsxXSB8fCBjdXJ2ZS5vbmUpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0KCkge1xuICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuICc8RUMgUG9pbnQgSW5maW5pdHk+JztcbiAgcmV0dXJuICc8RUMgUG9pbnQgeDogJyArIHRoaXMueC5mcm9tUmVkKCkudG9TdHJpbmcoMTYsIDIpICtcbiAgICAgICcgejogJyArIHRoaXMuei5mcm9tUmVkKCkudG9TdHJpbmcoMTYsIDIpICsgJz4nO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmlzSW5maW5pdHkgPSBmdW5jdGlvbiBpc0luZmluaXR5KCkge1xuICAvLyBYWFggVGhpcyBjb2RlIGFzc3VtZXMgdGhhdCB6ZXJvIGlzIGFsd2F5cyB6ZXJvIGluIHJlZFxuICByZXR1cm4gdGhpcy56LmNtcG4oMCkgPT09IDA7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZGJsID0gZnVuY3Rpb24gZGJsKCkge1xuICAvLyBodHRwOi8vaHlwZXJlbGxpcHRpYy5vcmcvRUZEL2cxcC9hdXRvLW1vbnRnb20teHouaHRtbCNkb3VibGluZy1kYmwtMTk4Ny1tLTNcbiAgLy8gMk0gKyAyUyArIDRBXG5cbiAgLy8gQSA9IFgxICsgWjFcbiAgdmFyIGEgPSB0aGlzLngucmVkQWRkKHRoaXMueik7XG4gIC8vIEFBID0gQV4yXG4gIHZhciBhYSA9IGEucmVkU3FyKCk7XG4gIC8vIEIgPSBYMSAtIFoxXG4gIHZhciBiID0gdGhpcy54LnJlZFN1Yih0aGlzLnopO1xuICAvLyBCQiA9IEJeMlxuICB2YXIgYmIgPSBiLnJlZFNxcigpO1xuICAvLyBDID0gQUEgLSBCQlxuICB2YXIgYyA9IGFhLnJlZFN1YihiYik7XG4gIC8vIFgzID0gQUEgKiBCQlxuICB2YXIgbnggPSBhYS5yZWRNdWwoYmIpO1xuICAvLyBaMyA9IEMgKiAoQkIgKyBBMjQgKiBDKVxuICB2YXIgbnogPSBjLnJlZE11bChiYi5yZWRBZGQodGhpcy5jdXJ2ZS5hMjQucmVkTXVsKGMpKSk7XG4gIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG54LCBueik7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBzdXBwb3J0ZWQgb24gTW9udGdvbWVyeSBjdXJ2ZScpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmRpZmZBZGQgPSBmdW5jdGlvbiBkaWZmQWRkKHAsIGRpZmYpIHtcbiAgLy8gaHR0cDovL2h5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by1tb250Z29tLXh6Lmh0bWwjZGlmZmFkZC1kYWRkLTE5ODctbS0zXG4gIC8vIDRNICsgMlMgKyA2QVxuXG4gIC8vIEEgPSBYMiArIFoyXG4gIHZhciBhID0gdGhpcy54LnJlZEFkZCh0aGlzLnopO1xuICAvLyBCID0gWDIgLSBaMlxuICB2YXIgYiA9IHRoaXMueC5yZWRTdWIodGhpcy56KTtcbiAgLy8gQyA9IFgzICsgWjNcbiAgdmFyIGMgPSBwLngucmVkQWRkKHAueik7XG4gIC8vIEQgPSBYMyAtIFozXG4gIHZhciBkID0gcC54LnJlZFN1YihwLnopO1xuICAvLyBEQSA9IEQgKiBBXG4gIHZhciBkYSA9IGQucmVkTXVsKGEpO1xuICAvLyBDQiA9IEMgKiBCXG4gIHZhciBjYiA9IGMucmVkTXVsKGIpO1xuICAvLyBYNSA9IFoxICogKERBICsgQ0IpXjJcbiAgdmFyIG54ID0gZGlmZi56LnJlZE11bChkYS5yZWRBZGQoY2IpLnJlZFNxcigpKTtcbiAgLy8gWjUgPSBYMSAqIChEQSAtIENCKV4yXG4gIHZhciBueiA9IGRpZmYueC5yZWRNdWwoZGEucmVkSVN1YihjYikucmVkU3FyKCkpO1xuICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChueCwgbnopO1xufTtcblxuUG9pbnQucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uIG11bChrKSB7XG4gIHZhciB0ID0gay5jbG9uZSgpO1xuICB2YXIgYSA9IHRoaXM7IC8vIChOIC8gMikgKiBRICsgUVxuICB2YXIgYiA9IHRoaXMuY3VydmUucG9pbnQobnVsbCwgbnVsbCk7IC8vIChOIC8gMikgKiBRXG4gIHZhciBjID0gdGhpczsgLy8gUVxuXG4gIGZvciAodmFyIGJpdHMgPSBbXTsgdC5jbXBuKDApICE9PSAwOyB0Lml1c2hybigxKSlcbiAgICBiaXRzLnB1c2godC5hbmRsbigxKSk7XG5cbiAgZm9yICh2YXIgaSA9IGJpdHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAoYml0c1tpXSA9PT0gMCkge1xuICAgICAgLy8gTiAqIFEgKyBRID0gKChOIC8gMikgKiBRICsgUSkpICsgKE4gLyAyKSAqIFFcbiAgICAgIGEgPSBhLmRpZmZBZGQoYiwgYyk7XG4gICAgICAvLyBOICogUSA9IDIgKiAoKE4gLyAyKSAqIFEgKyBRKSlcbiAgICAgIGIgPSBiLmRibCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBOICogUSA9ICgoTiAvIDIpICogUSArIFEpICsgKChOIC8gMikgKiBRKVxuICAgICAgYiA9IGEuZGlmZkFkZChiLCBjKTtcbiAgICAgIC8vIE4gKiBRICsgUSA9IDIgKiAoKE4gLyAyKSAqIFEgKyBRKVxuICAgICAgYSA9IGEuZGJsKCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBiO1xufTtcblxuUG9pbnQucHJvdG90eXBlLm11bEFkZCA9IGZ1bmN0aW9uIG11bEFkZCgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdOb3Qgc3VwcG9ydGVkIG9uIE1vbnRnb21lcnkgY3VydmUnKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5lcSA9IGZ1bmN0aW9uIGVxKG90aGVyKSB7XG4gIHJldHVybiB0aGlzLmdldFgoKS5jbXAob3RoZXIuZ2V0WCgpKSA9PT0gMDtcbn07XG5cblBvaW50LnByb3RvdHlwZS5ub3JtYWxpemUgPSBmdW5jdGlvbiBub3JtYWxpemUoKSB7XG4gIHRoaXMueCA9IHRoaXMueC5yZWRNdWwodGhpcy56LnJlZEludm0oKSk7XG4gIHRoaXMueiA9IHRoaXMuY3VydmUub25lO1xuICByZXR1cm4gdGhpcztcbn07XG5cblBvaW50LnByb3RvdHlwZS5nZXRYID0gZnVuY3Rpb24gZ2V0WCgpIHtcbiAgLy8gTm9ybWFsaXplIGNvb3JkaW5hdGVzXG4gIHRoaXMubm9ybWFsaXplKCk7XG5cbiAgcmV0dXJuIHRoaXMueC5mcm9tUmVkKCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY3VydmUgPSByZXF1aXJlKCcuLi9jdXJ2ZScpO1xudmFyIGVsbGlwdGljID0gcmVxdWlyZSgnLi4vLi4vZWxsaXB0aWMnKTtcbnZhciBibiA9IHJlcXVpcmUoJ2JuLmpzJyk7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xudmFyIEJhc2UgPSBjdXJ2ZS5iYXNlO1xuXG52YXIgYXNzZXJ0ID0gZWxsaXB0aWMudXRpbHMuYXNzZXJ0O1xuXG5mdW5jdGlvbiBTaG9ydEN1cnZlKGNvbmYpIHtcbiAgQmFzZS5jYWxsKHRoaXMsICdzaG9ydCcsIGNvbmYpO1xuXG4gIHRoaXMuYSA9IG5ldyBibihjb25mLmEsIDE2KS50b1JlZCh0aGlzLnJlZCk7XG4gIHRoaXMuYiA9IG5ldyBibihjb25mLmIsIDE2KS50b1JlZCh0aGlzLnJlZCk7XG4gIHRoaXMudGludiA9IHRoaXMudHdvLnJlZEludm0oKTtcblxuICB0aGlzLnplcm9BID0gdGhpcy5hLmZyb21SZWQoKS5jbXBuKDApID09PSAwO1xuICB0aGlzLnRocmVlQSA9IHRoaXMuYS5mcm9tUmVkKCkuc3ViKHRoaXMucCkuY21wbigtMykgPT09IDA7XG5cbiAgLy8gSWYgdGhlIGN1cnZlIGlzIGVuZG9tb3JwaGljLCBwcmVjYWxjdWxhdGUgYmV0YSBhbmQgbGFtYmRhXG4gIHRoaXMuZW5kbyA9IHRoaXMuX2dldEVuZG9tb3JwaGlzbShjb25mKTtcbiAgdGhpcy5fZW5kb1duYWZUMSA9IG5ldyBBcnJheSg0KTtcbiAgdGhpcy5fZW5kb1duYWZUMiA9IG5ldyBBcnJheSg0KTtcbn1cbmluaGVyaXRzKFNob3J0Q3VydmUsIEJhc2UpO1xubW9kdWxlLmV4cG9ydHMgPSBTaG9ydEN1cnZlO1xuXG5TaG9ydEN1cnZlLnByb3RvdHlwZS5fZ2V0RW5kb21vcnBoaXNtID0gZnVuY3Rpb24gX2dldEVuZG9tb3JwaGlzbShjb25mKSB7XG4gIC8vIE5vIGVmZmljaWVudCBlbmRvbW9ycGhpc21cbiAgaWYgKCF0aGlzLnplcm9BIHx8ICF0aGlzLmcgfHwgIXRoaXMubiB8fCB0aGlzLnAubW9kbigzKSAhPT0gMSlcbiAgICByZXR1cm47XG5cbiAgLy8gQ29tcHV0ZSBiZXRhIGFuZCBsYW1iZGEsIHRoYXQgbGFtYmRhICogUCA9IChiZXRhICogUHg7IFB5KVxuICB2YXIgYmV0YTtcbiAgdmFyIGxhbWJkYTtcbiAgaWYgKGNvbmYuYmV0YSkge1xuICAgIGJldGEgPSBuZXcgYm4oY29uZi5iZXRhLCAxNikudG9SZWQodGhpcy5yZWQpO1xuICB9IGVsc2Uge1xuICAgIHZhciBiZXRhcyA9IHRoaXMuX2dldEVuZG9Sb290cyh0aGlzLnApO1xuICAgIC8vIENob29zZSB0aGUgc21hbGxlc3QgYmV0YVxuICAgIGJldGEgPSBiZXRhc1swXS5jbXAoYmV0YXNbMV0pIDwgMCA/IGJldGFzWzBdIDogYmV0YXNbMV07XG4gICAgYmV0YSA9IGJldGEudG9SZWQodGhpcy5yZWQpO1xuICB9XG4gIGlmIChjb25mLmxhbWJkYSkge1xuICAgIGxhbWJkYSA9IG5ldyBibihjb25mLmxhbWJkYSwgMTYpO1xuICB9IGVsc2Uge1xuICAgIC8vIENob29zZSB0aGUgbGFtYmRhIHRoYXQgaXMgbWF0Y2hpbmcgc2VsZWN0ZWQgYmV0YVxuICAgIHZhciBsYW1iZGFzID0gdGhpcy5fZ2V0RW5kb1Jvb3RzKHRoaXMubik7XG4gICAgaWYgKHRoaXMuZy5tdWwobGFtYmRhc1swXSkueC5jbXAodGhpcy5nLngucmVkTXVsKGJldGEpKSA9PT0gMCkge1xuICAgICAgbGFtYmRhID0gbGFtYmRhc1swXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGFtYmRhID0gbGFtYmRhc1sxXTtcbiAgICAgIGFzc2VydCh0aGlzLmcubXVsKGxhbWJkYSkueC5jbXAodGhpcy5nLngucmVkTXVsKGJldGEpKSA9PT0gMCk7XG4gICAgfVxuICB9XG5cbiAgLy8gR2V0IGJhc2lzIHZlY3RvcnMsIHVzZWQgZm9yIGJhbGFuY2VkIGxlbmd0aC10d28gcmVwcmVzZW50YXRpb25cbiAgdmFyIGJhc2lzO1xuICBpZiAoY29uZi5iYXNpcykge1xuICAgIGJhc2lzID0gY29uZi5iYXNpcy5tYXAoZnVuY3Rpb24odmVjKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhOiBuZXcgYm4odmVjLmEsIDE2KSxcbiAgICAgICAgYjogbmV3IGJuKHZlYy5iLCAxNilcbiAgICAgIH07XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgYmFzaXMgPSB0aGlzLl9nZXRFbmRvQmFzaXMobGFtYmRhKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYmV0YTogYmV0YSxcbiAgICBsYW1iZGE6IGxhbWJkYSxcbiAgICBiYXNpczogYmFzaXNcbiAgfTtcbn07XG5cblNob3J0Q3VydmUucHJvdG90eXBlLl9nZXRFbmRvUm9vdHMgPSBmdW5jdGlvbiBfZ2V0RW5kb1Jvb3RzKG51bSkge1xuICAvLyBGaW5kIHJvb3RzIG9mIGZvciB4XjIgKyB4ICsgMSBpbiBGXG4gIC8vIFJvb3QgPSAoLTEgKy0gU3FydCgtMykpIC8gMlxuICAvL1xuICB2YXIgcmVkID0gbnVtID09PSB0aGlzLnAgPyB0aGlzLnJlZCA6IGJuLm1vbnQobnVtKTtcbiAgdmFyIHRpbnYgPSBuZXcgYm4oMikudG9SZWQocmVkKS5yZWRJbnZtKCk7XG4gIHZhciBudGludiA9IHRpbnYucmVkTmVnKCk7XG5cbiAgdmFyIHMgPSBuZXcgYm4oMykudG9SZWQocmVkKS5yZWROZWcoKS5yZWRTcXJ0KCkucmVkTXVsKHRpbnYpO1xuXG4gIHZhciBsMSA9IG50aW52LnJlZEFkZChzKS5mcm9tUmVkKCk7XG4gIHZhciBsMiA9IG50aW52LnJlZFN1YihzKS5mcm9tUmVkKCk7XG4gIHJldHVybiBbIGwxLCBsMiBdO1xufTtcblxuU2hvcnRDdXJ2ZS5wcm90b3R5cGUuX2dldEVuZG9CYXNpcyA9IGZ1bmN0aW9uIF9nZXRFbmRvQmFzaXMobGFtYmRhKSB7XG4gIC8vIGFwcnhTcXJ0ID49IHNxcnQodGhpcy5uKVxuICB2YXIgYXByeFNxcnQgPSB0aGlzLm4udXNocm4oTWF0aC5mbG9vcih0aGlzLm4uYml0TGVuZ3RoKCkgLyAyKSk7XG5cbiAgLy8gMy43NFxuICAvLyBSdW4gRUdDRCwgdW50aWwgcihMICsgMSkgPCBhcHJ4U3FydFxuICB2YXIgdSA9IGxhbWJkYTtcbiAgdmFyIHYgPSB0aGlzLm4uY2xvbmUoKTtcbiAgdmFyIHgxID0gbmV3IGJuKDEpO1xuICB2YXIgeTEgPSBuZXcgYm4oMCk7XG4gIHZhciB4MiA9IG5ldyBibigwKTtcbiAgdmFyIHkyID0gbmV3IGJuKDEpO1xuXG4gIC8vIE5PVEU6IGFsbCB2ZWN0b3JzIGFyZSByb290cyBvZjogYSArIGIgKiBsYW1iZGEgPSAwIChtb2QgbilcbiAgdmFyIGEwO1xuICB2YXIgYjA7XG4gIC8vIEZpcnN0IHZlY3RvclxuICB2YXIgYTE7XG4gIHZhciBiMTtcbiAgLy8gU2Vjb25kIHZlY3RvclxuICB2YXIgYTI7XG4gIHZhciBiMjtcblxuICB2YXIgcHJldlI7XG4gIHZhciBpID0gMDtcbiAgdmFyIHI7XG4gIHZhciB4O1xuICB3aGlsZSAodS5jbXBuKDApICE9PSAwKSB7XG4gICAgdmFyIHEgPSB2LmRpdih1KTtcbiAgICByID0gdi5zdWIocS5tdWwodSkpO1xuICAgIHggPSB4Mi5zdWIocS5tdWwoeDEpKTtcbiAgICB2YXIgeSA9IHkyLnN1YihxLm11bCh5MSkpO1xuXG4gICAgaWYgKCFhMSAmJiByLmNtcChhcHJ4U3FydCkgPCAwKSB7XG4gICAgICBhMCA9IHByZXZSLm5lZygpO1xuICAgICAgYjAgPSB4MTtcbiAgICAgIGExID0gci5uZWcoKTtcbiAgICAgIGIxID0geDtcbiAgICB9IGVsc2UgaWYgKGExICYmICsraSA9PT0gMikge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHByZXZSID0gcjtcblxuICAgIHYgPSB1O1xuICAgIHUgPSByO1xuICAgIHgyID0geDE7XG4gICAgeDEgPSB4O1xuICAgIHkyID0geTE7XG4gICAgeTEgPSB5O1xuICB9XG4gIGEyID0gci5uZWcoKTtcbiAgYjIgPSB4O1xuXG4gIHZhciBsZW4xID0gYTEuc3FyKCkuYWRkKGIxLnNxcigpKTtcbiAgdmFyIGxlbjIgPSBhMi5zcXIoKS5hZGQoYjIuc3FyKCkpO1xuICBpZiAobGVuMi5jbXAobGVuMSkgPj0gMCkge1xuICAgIGEyID0gYTA7XG4gICAgYjIgPSBiMDtcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBzaWduc1xuICBpZiAoYTEubmVnYXRpdmUpIHtcbiAgICBhMSA9IGExLm5lZygpO1xuICAgIGIxID0gYjEubmVnKCk7XG4gIH1cbiAgaWYgKGEyLm5lZ2F0aXZlKSB7XG4gICAgYTIgPSBhMi5uZWcoKTtcbiAgICBiMiA9IGIyLm5lZygpO1xuICB9XG5cbiAgcmV0dXJuIFtcbiAgICB7IGE6IGExLCBiOiBiMSB9LFxuICAgIHsgYTogYTIsIGI6IGIyIH1cbiAgXTtcbn07XG5cblNob3J0Q3VydmUucHJvdG90eXBlLl9lbmRvU3BsaXQgPSBmdW5jdGlvbiBfZW5kb1NwbGl0KGspIHtcbiAgdmFyIGJhc2lzID0gdGhpcy5lbmRvLmJhc2lzO1xuICB2YXIgdjEgPSBiYXNpc1swXTtcbiAgdmFyIHYyID0gYmFzaXNbMV07XG5cbiAgdmFyIGMxID0gdjIuYi5tdWwoaykuZGl2Um91bmQodGhpcy5uKTtcbiAgdmFyIGMyID0gdjEuYi5uZWcoKS5tdWwoaykuZGl2Um91bmQodGhpcy5uKTtcblxuICB2YXIgcDEgPSBjMS5tdWwodjEuYSk7XG4gIHZhciBwMiA9IGMyLm11bCh2Mi5hKTtcbiAgdmFyIHExID0gYzEubXVsKHYxLmIpO1xuICB2YXIgcTIgPSBjMi5tdWwodjIuYik7XG5cbiAgLy8gQ2FsY3VsYXRlIGFuc3dlclxuICB2YXIgazEgPSBrLnN1YihwMSkuc3ViKHAyKTtcbiAgdmFyIGsyID0gcTEuYWRkKHEyKS5uZWcoKTtcbiAgcmV0dXJuIHsgazE6IGsxLCBrMjogazIgfTtcbn07XG5cblNob3J0Q3VydmUucHJvdG90eXBlLnBvaW50RnJvbVggPSBmdW5jdGlvbiBwb2ludEZyb21YKHgsIG9kZCkge1xuICB4ID0gbmV3IGJuKHgsIDE2KTtcbiAgaWYgKCF4LnJlZClcbiAgICB4ID0geC50b1JlZCh0aGlzLnJlZCk7XG5cbiAgdmFyIHkyID0geC5yZWRTcXIoKS5yZWRNdWwoeCkucmVkSUFkZCh4LnJlZE11bCh0aGlzLmEpKS5yZWRJQWRkKHRoaXMuYik7XG4gIHZhciB5ID0geTIucmVkU3FydCgpO1xuXG4gIC8vIFhYWCBJcyB0aGVyZSBhbnkgd2F5IHRvIHRlbGwgaWYgdGhlIG51bWJlciBpcyBvZGQgd2l0aG91dCBjb252ZXJ0aW5nIGl0XG4gIC8vIHRvIG5vbi1yZWQgZm9ybT9cbiAgdmFyIGlzT2RkID0geS5mcm9tUmVkKCkuaXNPZGQoKTtcbiAgaWYgKG9kZCAmJiAhaXNPZGQgfHwgIW9kZCAmJiBpc09kZClcbiAgICB5ID0geS5yZWROZWcoKTtcblxuICByZXR1cm4gdGhpcy5wb2ludCh4LCB5KTtcbn07XG5cblNob3J0Q3VydmUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gdmFsaWRhdGUocG9pbnQpIHtcbiAgaWYgKHBvaW50LmluZilcbiAgICByZXR1cm4gdHJ1ZTtcblxuICB2YXIgeCA9IHBvaW50Lng7XG4gIHZhciB5ID0gcG9pbnQueTtcblxuICB2YXIgYXggPSB0aGlzLmEucmVkTXVsKHgpO1xuICB2YXIgcmhzID0geC5yZWRTcXIoKS5yZWRNdWwoeCkucmVkSUFkZChheCkucmVkSUFkZCh0aGlzLmIpO1xuICByZXR1cm4geS5yZWRTcXIoKS5yZWRJU3ViKHJocykuY21wbigwKSA9PT0gMDtcbn07XG5cblNob3J0Q3VydmUucHJvdG90eXBlLl9lbmRvV25hZk11bEFkZCA9XG4gICAgZnVuY3Rpb24gX2VuZG9XbmFmTXVsQWRkKHBvaW50cywgY29lZmZzKSB7XG4gIHZhciBucG9pbnRzID0gdGhpcy5fZW5kb1duYWZUMTtcbiAgdmFyIG5jb2VmZnMgPSB0aGlzLl9lbmRvV25hZlQyO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzcGxpdCA9IHRoaXMuX2VuZG9TcGxpdChjb2VmZnNbaV0pO1xuICAgIHZhciBwID0gcG9pbnRzW2ldO1xuICAgIHZhciBiZXRhID0gcC5fZ2V0QmV0YSgpO1xuXG4gICAgaWYgKHNwbGl0LmsxLm5lZ2F0aXZlKSB7XG4gICAgICBzcGxpdC5rMS5pbmVnKCk7XG4gICAgICBwID0gcC5uZWcodHJ1ZSk7XG4gICAgfVxuICAgIGlmIChzcGxpdC5rMi5uZWdhdGl2ZSkge1xuICAgICAgc3BsaXQuazIuaW5lZygpO1xuICAgICAgYmV0YSA9IGJldGEubmVnKHRydWUpO1xuICAgIH1cblxuICAgIG5wb2ludHNbaSAqIDJdID0gcDtcbiAgICBucG9pbnRzW2kgKiAyICsgMV0gPSBiZXRhO1xuICAgIG5jb2VmZnNbaSAqIDJdID0gc3BsaXQuazE7XG4gICAgbmNvZWZmc1tpICogMiArIDFdID0gc3BsaXQuazI7XG4gIH1cbiAgdmFyIHJlcyA9IHRoaXMuX3duYWZNdWxBZGQoMSwgbnBvaW50cywgbmNvZWZmcywgaSAqIDIpO1xuXG4gIC8vIENsZWFuLXVwIHJlZmVyZW5jZXMgdG8gcG9pbnRzIGFuZCBjb2VmZmljaWVudHNcbiAgZm9yICh2YXIgaiA9IDA7IGogPCBpICogMjsgaisrKSB7XG4gICAgbnBvaW50c1tqXSA9IG51bGw7XG4gICAgbmNvZWZmc1tqXSA9IG51bGw7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG5cbmZ1bmN0aW9uIFBvaW50KGN1cnZlLCB4LCB5LCBpc1JlZCkge1xuICBCYXNlLkJhc2VQb2ludC5jYWxsKHRoaXMsIGN1cnZlLCAnYWZmaW5lJyk7XG4gIGlmICh4ID09PSBudWxsICYmIHkgPT09IG51bGwpIHtcbiAgICB0aGlzLnggPSBudWxsO1xuICAgIHRoaXMueSA9IG51bGw7XG4gICAgdGhpcy5pbmYgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHRoaXMueCA9IG5ldyBibih4LCAxNik7XG4gICAgdGhpcy55ID0gbmV3IGJuKHksIDE2KTtcbiAgICAvLyBGb3JjZSByZWRnb21lcnkgcmVwcmVzZW50YXRpb24gd2hlbiBsb2FkaW5nIGZyb20gSlNPTlxuICAgIGlmIChpc1JlZCkge1xuICAgICAgdGhpcy54LmZvcmNlUmVkKHRoaXMuY3VydmUucmVkKTtcbiAgICAgIHRoaXMueS5mb3JjZVJlZCh0aGlzLmN1cnZlLnJlZCk7XG4gICAgfVxuICAgIGlmICghdGhpcy54LnJlZClcbiAgICAgIHRoaXMueCA9IHRoaXMueC50b1JlZCh0aGlzLmN1cnZlLnJlZCk7XG4gICAgaWYgKCF0aGlzLnkucmVkKVxuICAgICAgdGhpcy55ID0gdGhpcy55LnRvUmVkKHRoaXMuY3VydmUucmVkKTtcbiAgICB0aGlzLmluZiA9IGZhbHNlO1xuICB9XG59XG5pbmhlcml0cyhQb2ludCwgQmFzZS5CYXNlUG9pbnQpO1xuXG5TaG9ydEN1cnZlLnByb3RvdHlwZS5wb2ludCA9IGZ1bmN0aW9uIHBvaW50KHgsIHksIGlzUmVkKSB7XG4gIHJldHVybiBuZXcgUG9pbnQodGhpcywgeCwgeSwgaXNSZWQpO1xufTtcblxuU2hvcnRDdXJ2ZS5wcm90b3R5cGUucG9pbnRGcm9tSlNPTiA9IGZ1bmN0aW9uIHBvaW50RnJvbUpTT04ob2JqLCByZWQpIHtcbiAgcmV0dXJuIFBvaW50LmZyb21KU09OKHRoaXMsIG9iaiwgcmVkKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5fZ2V0QmV0YSA9IGZ1bmN0aW9uIF9nZXRCZXRhKCkge1xuICBpZiAoIXRoaXMuY3VydmUuZW5kbylcbiAgICByZXR1cm47XG5cbiAgdmFyIHByZSA9IHRoaXMucHJlY29tcHV0ZWQ7XG4gIGlmIChwcmUgJiYgcHJlLmJldGEpXG4gICAgcmV0dXJuIHByZS5iZXRhO1xuXG4gIHZhciBiZXRhID0gdGhpcy5jdXJ2ZS5wb2ludCh0aGlzLngucmVkTXVsKHRoaXMuY3VydmUuZW5kby5iZXRhKSwgdGhpcy55KTtcbiAgaWYgKHByZSkge1xuICAgIHZhciBjdXJ2ZSA9IHRoaXMuY3VydmU7XG4gICAgdmFyIGVuZG9NdWwgPSBmdW5jdGlvbihwKSB7XG4gICAgICByZXR1cm4gY3VydmUucG9pbnQocC54LnJlZE11bChjdXJ2ZS5lbmRvLmJldGEpLCBwLnkpO1xuICAgIH07XG4gICAgcHJlLmJldGEgPSBiZXRhO1xuICAgIGJldGEucHJlY29tcHV0ZWQgPSB7XG4gICAgICBiZXRhOiBudWxsLFxuICAgICAgbmFmOiBwcmUubmFmICYmIHtcbiAgICAgICAgd25kOiBwcmUubmFmLnduZCxcbiAgICAgICAgcG9pbnRzOiBwcmUubmFmLnBvaW50cy5tYXAoZW5kb011bClcbiAgICAgIH0sXG4gICAgICBkb3VibGVzOiBwcmUuZG91YmxlcyAmJiB7XG4gICAgICAgIHN0ZXA6IHByZS5kb3VibGVzLnN0ZXAsXG4gICAgICAgIHBvaW50czogcHJlLmRvdWJsZXMucG9pbnRzLm1hcChlbmRvTXVsKVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIGJldGE7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICBpZiAoIXRoaXMucHJlY29tcHV0ZWQpXG4gICAgcmV0dXJuIFsgdGhpcy54LCB0aGlzLnkgXTtcblxuICByZXR1cm4gWyB0aGlzLngsIHRoaXMueSwgdGhpcy5wcmVjb21wdXRlZCAmJiB7XG4gICAgZG91YmxlczogdGhpcy5wcmVjb21wdXRlZC5kb3VibGVzICYmIHtcbiAgICAgIHN0ZXA6IHRoaXMucHJlY29tcHV0ZWQuZG91Ymxlcy5zdGVwLFxuICAgICAgcG9pbnRzOiB0aGlzLnByZWNvbXB1dGVkLmRvdWJsZXMucG9pbnRzLnNsaWNlKDEpXG4gICAgfSxcbiAgICBuYWY6IHRoaXMucHJlY29tcHV0ZWQubmFmICYmIHtcbiAgICAgIHduZDogdGhpcy5wcmVjb21wdXRlZC5uYWYud25kLFxuICAgICAgcG9pbnRzOiB0aGlzLnByZWNvbXB1dGVkLm5hZi5wb2ludHMuc2xpY2UoMSlcbiAgICB9XG4gIH0gXTtcbn07XG5cblBvaW50LmZyb21KU09OID0gZnVuY3Rpb24gZnJvbUpTT04oY3VydmUsIG9iaiwgcmVkKSB7XG4gIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJylcbiAgICBvYmogPSBKU09OLnBhcnNlKG9iaik7XG4gIHZhciByZXMgPSBjdXJ2ZS5wb2ludChvYmpbMF0sIG9ialsxXSwgcmVkKTtcbiAgaWYgKCFvYmpbMl0pXG4gICAgcmV0dXJuIHJlcztcblxuICBmdW5jdGlvbiBvYmoycG9pbnQob2JqKSB7XG4gICAgcmV0dXJuIGN1cnZlLnBvaW50KG9ialswXSwgb2JqWzFdLCByZWQpO1xuICB9XG5cbiAgdmFyIHByZSA9IG9ialsyXTtcbiAgcmVzLnByZWNvbXB1dGVkID0ge1xuICAgIGJldGE6IG51bGwsXG4gICAgZG91YmxlczogcHJlLmRvdWJsZXMgJiYge1xuICAgICAgc3RlcDogcHJlLmRvdWJsZXMuc3RlcCxcbiAgICAgIHBvaW50czogWyByZXMgXS5jb25jYXQocHJlLmRvdWJsZXMucG9pbnRzLm1hcChvYmoycG9pbnQpKVxuICAgIH0sXG4gICAgbmFmOiBwcmUubmFmICYmIHtcbiAgICAgIHduZDogcHJlLm5hZi53bmQsXG4gICAgICBwb2ludHM6IFsgcmVzIF0uY29uY2F0KHByZS5uYWYucG9pbnRzLm1hcChvYmoycG9pbnQpKVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHJlcztcbn07XG5cblBvaW50LnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCgpIHtcbiAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiAnPEVDIFBvaW50IEluZmluaXR5Pic7XG4gIHJldHVybiAnPEVDIFBvaW50IHg6ICcgKyB0aGlzLnguZnJvbVJlZCgpLnRvU3RyaW5nKDE2LCAyKSArXG4gICAgICAnIHk6ICcgKyB0aGlzLnkuZnJvbVJlZCgpLnRvU3RyaW5nKDE2LCAyKSArICc+Jztcbn07XG5cblBvaW50LnByb3RvdHlwZS5pc0luZmluaXR5ID0gZnVuY3Rpb24gaXNJbmZpbml0eSgpIHtcbiAgcmV0dXJuIHRoaXMuaW5mO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZChwKSB7XG4gIC8vIE8gKyBQID0gUFxuICBpZiAodGhpcy5pbmYpXG4gICAgcmV0dXJuIHA7XG5cbiAgLy8gUCArIE8gPSBQXG4gIGlmIChwLmluZilcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBQICsgUCA9IDJQXG4gIGlmICh0aGlzLmVxKHApKVxuICAgIHJldHVybiB0aGlzLmRibCgpO1xuXG4gIC8vIFAgKyAoLVApID0gT1xuICBpZiAodGhpcy5uZWcoKS5lcShwKSlcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChudWxsLCBudWxsKTtcblxuICAvLyBQICsgUSA9IE9cbiAgaWYgKHRoaXMueC5jbXAocC54KSA9PT0gMClcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChudWxsLCBudWxsKTtcblxuICB2YXIgYyA9IHRoaXMueS5yZWRTdWIocC55KTtcbiAgaWYgKGMuY21wbigwKSAhPT0gMClcbiAgICBjID0gYy5yZWRNdWwodGhpcy54LnJlZFN1YihwLngpLnJlZEludm0oKSk7XG4gIHZhciBueCA9IGMucmVkU3FyKCkucmVkSVN1Yih0aGlzLngpLnJlZElTdWIocC54KTtcbiAgdmFyIG55ID0gYy5yZWRNdWwodGhpcy54LnJlZFN1YihueCkpLnJlZElTdWIodGhpcy55KTtcbiAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobngsIG55KTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5kYmwgPSBmdW5jdGlvbiBkYmwoKSB7XG4gIGlmICh0aGlzLmluZilcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyAyUCA9IE9cbiAgdmFyIHlzMSA9IHRoaXMueS5yZWRBZGQodGhpcy55KTtcbiAgaWYgKHlzMS5jbXBuKDApID09PSAwKVxuICAgIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG51bGwsIG51bGwpO1xuXG4gIHZhciBhID0gdGhpcy5jdXJ2ZS5hO1xuXG4gIHZhciB4MiA9IHRoaXMueC5yZWRTcXIoKTtcbiAgdmFyIGR5aW52ID0geXMxLnJlZEludm0oKTtcbiAgdmFyIGMgPSB4Mi5yZWRBZGQoeDIpLnJlZElBZGQoeDIpLnJlZElBZGQoYSkucmVkTXVsKGR5aW52KTtcblxuICB2YXIgbnggPSBjLnJlZFNxcigpLnJlZElTdWIodGhpcy54LnJlZEFkZCh0aGlzLngpKTtcbiAgdmFyIG55ID0gYy5yZWRNdWwodGhpcy54LnJlZFN1YihueCkpLnJlZElTdWIodGhpcy55KTtcbiAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobngsIG55KTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5nZXRYID0gZnVuY3Rpb24gZ2V0WCgpIHtcbiAgcmV0dXJuIHRoaXMueC5mcm9tUmVkKCk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZ2V0WSA9IGZ1bmN0aW9uIGdldFkoKSB7XG4gIHJldHVybiB0aGlzLnkuZnJvbVJlZCgpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uIG11bChrKSB7XG4gIGsgPSBuZXcgYm4oaywgMTYpO1xuXG4gIGlmICh0aGlzLl9oYXNEb3VibGVzKGspKVxuICAgIHJldHVybiB0aGlzLmN1cnZlLl9maXhlZE5hZk11bCh0aGlzLCBrKTtcbiAgZWxzZSBpZiAodGhpcy5jdXJ2ZS5lbmRvKVxuICAgIHJldHVybiB0aGlzLmN1cnZlLl9lbmRvV25hZk11bEFkZChbIHRoaXMgXSwgWyBrIF0pO1xuICBlbHNlXG4gICAgcmV0dXJuIHRoaXMuY3VydmUuX3duYWZNdWwodGhpcywgayk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUubXVsQWRkID0gZnVuY3Rpb24gbXVsQWRkKGsxLCBwMiwgazIpIHtcbiAgdmFyIHBvaW50cyA9IFsgdGhpcywgcDIgXTtcbiAgdmFyIGNvZWZmcyA9IFsgazEsIGsyIF07XG4gIGlmICh0aGlzLmN1cnZlLmVuZG8pXG4gICAgcmV0dXJuIHRoaXMuY3VydmUuX2VuZG9XbmFmTXVsQWRkKHBvaW50cywgY29lZmZzKTtcbiAgZWxzZVxuICAgIHJldHVybiB0aGlzLmN1cnZlLl93bmFmTXVsQWRkKDEsIHBvaW50cywgY29lZmZzLCAyKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5lcSA9IGZ1bmN0aW9uIGVxKHApIHtcbiAgcmV0dXJuIHRoaXMgPT09IHAgfHxcbiAgICAgICAgIHRoaXMuaW5mID09PSBwLmluZiAmJlxuICAgICAgICAgICAgICh0aGlzLmluZiB8fCB0aGlzLnguY21wKHAueCkgPT09IDAgJiYgdGhpcy55LmNtcChwLnkpID09PSAwKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5uZWcgPSBmdW5jdGlvbiBuZWcoX3ByZWNvbXB1dGUpIHtcbiAgaWYgKHRoaXMuaW5mKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIHZhciByZXMgPSB0aGlzLmN1cnZlLnBvaW50KHRoaXMueCwgdGhpcy55LnJlZE5lZygpKTtcbiAgaWYgKF9wcmVjb21wdXRlICYmIHRoaXMucHJlY29tcHV0ZWQpIHtcbiAgICB2YXIgcHJlID0gdGhpcy5wcmVjb21wdXRlZDtcbiAgICB2YXIgbmVnYXRlID0gZnVuY3Rpb24ocCkge1xuICAgICAgcmV0dXJuIHAubmVnKCk7XG4gICAgfTtcbiAgICByZXMucHJlY29tcHV0ZWQgPSB7XG4gICAgICBuYWY6IHByZS5uYWYgJiYge1xuICAgICAgICB3bmQ6IHByZS5uYWYud25kLFxuICAgICAgICBwb2ludHM6IHByZS5uYWYucG9pbnRzLm1hcChuZWdhdGUpXG4gICAgICB9LFxuICAgICAgZG91YmxlczogcHJlLmRvdWJsZXMgJiYge1xuICAgICAgICBzdGVwOiBwcmUuZG91Ymxlcy5zdGVwLFxuICAgICAgICBwb2ludHM6IHByZS5kb3VibGVzLnBvaW50cy5tYXAobmVnYXRlKVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG5cblBvaW50LnByb3RvdHlwZS50b0ogPSBmdW5jdGlvbiB0b0ooKSB7XG4gIGlmICh0aGlzLmluZilcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobnVsbCwgbnVsbCwgbnVsbCk7XG5cbiAgdmFyIHJlcyA9IHRoaXMuY3VydmUuanBvaW50KHRoaXMueCwgdGhpcy55LCB0aGlzLmN1cnZlLm9uZSk7XG4gIHJldHVybiByZXM7XG59O1xuXG5mdW5jdGlvbiBKUG9pbnQoY3VydmUsIHgsIHksIHopIHtcbiAgQmFzZS5CYXNlUG9pbnQuY2FsbCh0aGlzLCBjdXJ2ZSwgJ2phY29iaWFuJyk7XG4gIGlmICh4ID09PSBudWxsICYmIHkgPT09IG51bGwgJiYgeiA9PT0gbnVsbCkge1xuICAgIHRoaXMueCA9IHRoaXMuY3VydmUub25lO1xuICAgIHRoaXMueSA9IHRoaXMuY3VydmUub25lO1xuICAgIHRoaXMueiA9IG5ldyBibigwKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnggPSBuZXcgYm4oeCwgMTYpO1xuICAgIHRoaXMueSA9IG5ldyBibih5LCAxNik7XG4gICAgdGhpcy56ID0gbmV3IGJuKHosIDE2KTtcbiAgfVxuICBpZiAoIXRoaXMueC5yZWQpXG4gICAgdGhpcy54ID0gdGhpcy54LnRvUmVkKHRoaXMuY3VydmUucmVkKTtcbiAgaWYgKCF0aGlzLnkucmVkKVxuICAgIHRoaXMueSA9IHRoaXMueS50b1JlZCh0aGlzLmN1cnZlLnJlZCk7XG4gIGlmICghdGhpcy56LnJlZClcbiAgICB0aGlzLnogPSB0aGlzLnoudG9SZWQodGhpcy5jdXJ2ZS5yZWQpO1xuXG4gIHRoaXMuek9uZSA9IHRoaXMueiA9PT0gdGhpcy5jdXJ2ZS5vbmU7XG59XG5pbmhlcml0cyhKUG9pbnQsIEJhc2UuQmFzZVBvaW50KTtcblxuU2hvcnRDdXJ2ZS5wcm90b3R5cGUuanBvaW50ID0gZnVuY3Rpb24ganBvaW50KHgsIHksIHopIHtcbiAgcmV0dXJuIG5ldyBKUG9pbnQodGhpcywgeCwgeSwgeik7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLnRvUCA9IGZ1bmN0aW9uIHRvUCgpIHtcbiAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG51bGwsIG51bGwpO1xuXG4gIHZhciB6aW52ID0gdGhpcy56LnJlZEludm0oKTtcbiAgdmFyIHppbnYyID0gemludi5yZWRTcXIoKTtcbiAgdmFyIGF4ID0gdGhpcy54LnJlZE11bCh6aW52Mik7XG4gIHZhciBheSA9IHRoaXMueS5yZWRNdWwoemludjIpLnJlZE11bCh6aW52KTtcblxuICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChheCwgYXkpO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS5uZWcgPSBmdW5jdGlvbiBuZWcoKSB7XG4gIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludCh0aGlzLngsIHRoaXMueS5yZWROZWcoKSwgdGhpcy56KTtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKHApIHtcbiAgLy8gTyArIFAgPSBQXG4gIGlmICh0aGlzLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gcDtcblxuICAvLyBQICsgTyA9IFBcbiAgaWYgKHAuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIDEyTSArIDRTICsgN0FcbiAgdmFyIHB6MiA9IHAuei5yZWRTcXIoKTtcbiAgdmFyIHoyID0gdGhpcy56LnJlZFNxcigpO1xuICB2YXIgdTEgPSB0aGlzLngucmVkTXVsKHB6Mik7XG4gIHZhciB1MiA9IHAueC5yZWRNdWwoejIpO1xuICB2YXIgczEgPSB0aGlzLnkucmVkTXVsKHB6Mi5yZWRNdWwocC56KSk7XG4gIHZhciBzMiA9IHAueS5yZWRNdWwoejIucmVkTXVsKHRoaXMueikpO1xuXG4gIHZhciBoID0gdTEucmVkU3ViKHUyKTtcbiAgdmFyIHIgPSBzMS5yZWRTdWIoczIpO1xuICBpZiAoaC5jbXBuKDApID09PSAwKSB7XG4gICAgaWYgKHIuY21wbigwKSAhPT0gMClcbiAgICAgIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludChudWxsLCBudWxsLCBudWxsKTtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gdGhpcy5kYmwoKTtcbiAgfVxuXG4gIHZhciBoMiA9IGgucmVkU3FyKCk7XG4gIHZhciBoMyA9IGgyLnJlZE11bChoKTtcbiAgdmFyIHYgPSB1MS5yZWRNdWwoaDIpO1xuXG4gIHZhciBueCA9IHIucmVkU3FyKCkucmVkSUFkZChoMykucmVkSVN1Yih2KS5yZWRJU3ViKHYpO1xuICB2YXIgbnkgPSByLnJlZE11bCh2LnJlZElTdWIobngpKS5yZWRJU3ViKHMxLnJlZE11bChoMykpO1xuICB2YXIgbnogPSB0aGlzLnoucmVkTXVsKHAueikucmVkTXVsKGgpO1xuXG4gIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludChueCwgbnksIG56KTtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUubWl4ZWRBZGQgPSBmdW5jdGlvbiBtaXhlZEFkZChwKSB7XG4gIC8vIE8gKyBQID0gUFxuICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHAudG9KKCk7XG5cbiAgLy8gUCArIE8gPSBQXG4gIGlmIChwLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyA4TSArIDNTICsgN0FcbiAgdmFyIHoyID0gdGhpcy56LnJlZFNxcigpO1xuICB2YXIgdTEgPSB0aGlzLng7XG4gIHZhciB1MiA9IHAueC5yZWRNdWwoejIpO1xuICB2YXIgczEgPSB0aGlzLnk7XG4gIHZhciBzMiA9IHAueS5yZWRNdWwoejIpLnJlZE11bCh0aGlzLnopO1xuXG4gIHZhciBoID0gdTEucmVkU3ViKHUyKTtcbiAgdmFyIHIgPSBzMS5yZWRTdWIoczIpO1xuICBpZiAoaC5jbXBuKDApID09PSAwKSB7XG4gICAgaWYgKHIuY21wbigwKSAhPT0gMClcbiAgICAgIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludChudWxsLCBudWxsLCBudWxsKTtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gdGhpcy5kYmwoKTtcbiAgfVxuXG4gIHZhciBoMiA9IGgucmVkU3FyKCk7XG4gIHZhciBoMyA9IGgyLnJlZE11bChoKTtcbiAgdmFyIHYgPSB1MS5yZWRNdWwoaDIpO1xuXG4gIHZhciBueCA9IHIucmVkU3FyKCkucmVkSUFkZChoMykucmVkSVN1Yih2KS5yZWRJU3ViKHYpO1xuICB2YXIgbnkgPSByLnJlZE11bCh2LnJlZElTdWIobngpKS5yZWRJU3ViKHMxLnJlZE11bChoMykpO1xuICB2YXIgbnogPSB0aGlzLnoucmVkTXVsKGgpO1xuXG4gIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludChueCwgbnksIG56KTtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUuZGJscCA9IGZ1bmN0aW9uIGRibHAocG93KSB7XG4gIGlmIChwb3cgPT09IDApXG4gICAgcmV0dXJuIHRoaXM7XG4gIGlmICh0aGlzLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gdGhpcztcbiAgaWYgKCFwb3cpXG4gICAgcmV0dXJuIHRoaXMuZGJsKCk7XG5cbiAgaWYgKHRoaXMuY3VydmUuemVyb0EgfHwgdGhpcy5jdXJ2ZS50aHJlZUEpIHtcbiAgICB2YXIgciA9IHRoaXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb3c7IGkrKylcbiAgICAgIHIgPSByLmRibCgpO1xuICAgIHJldHVybiByO1xuICB9XG5cbiAgLy8gMU0gKyAyUyArIDFBICsgTiAqICg0UyArIDVNICsgOEEpXG4gIC8vIE4gPSAxID0+IDZNICsgNlMgKyA5QVxuICB2YXIgYSA9IHRoaXMuY3VydmUuYTtcbiAgdmFyIHRpbnYgPSB0aGlzLmN1cnZlLnRpbnY7XG5cbiAgdmFyIGp4ID0gdGhpcy54O1xuICB2YXIgankgPSB0aGlzLnk7XG4gIHZhciBqeiA9IHRoaXMuejtcbiAgdmFyIGp6NCA9IGp6LnJlZFNxcigpLnJlZFNxcigpO1xuXG4gIC8vIFJldXNlIHJlc3VsdHNcbiAgdmFyIGp5ZCA9IGp5LnJlZEFkZChqeSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcG93OyBpKyspIHtcbiAgICB2YXIgangyID0gangucmVkU3FyKCk7XG4gICAgdmFyIGp5ZDIgPSBqeWQucmVkU3FyKCk7XG4gICAgdmFyIGp5ZDQgPSBqeWQyLnJlZFNxcigpO1xuICAgIHZhciBjID0gangyLnJlZEFkZChqeDIpLnJlZElBZGQoangyKS5yZWRJQWRkKGEucmVkTXVsKGp6NCkpO1xuXG4gICAgdmFyIHQxID0gangucmVkTXVsKGp5ZDIpO1xuICAgIHZhciBueCA9IGMucmVkU3FyKCkucmVkSVN1Yih0MS5yZWRBZGQodDEpKTtcbiAgICB2YXIgdDIgPSB0MS5yZWRJU3ViKG54KTtcbiAgICB2YXIgZG55ID0gYy5yZWRNdWwodDIpO1xuICAgIGRueSA9IGRueS5yZWRJQWRkKGRueSkucmVkSVN1YihqeWQ0KTtcbiAgICB2YXIgbnogPSBqeWQucmVkTXVsKGp6KTtcbiAgICBpZiAoaSArIDEgPCBwb3cpXG4gICAgICBqejQgPSBqejQucmVkTXVsKGp5ZDQpO1xuXG4gICAganggPSBueDtcbiAgICBqeiA9IG56O1xuICAgIGp5ZCA9IGRueTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludChqeCwganlkLnJlZE11bCh0aW52KSwganopO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS5kYmwgPSBmdW5jdGlvbiBkYmwoKSB7XG4gIGlmICh0aGlzLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gdGhpcztcblxuICBpZiAodGhpcy5jdXJ2ZS56ZXJvQSlcbiAgICByZXR1cm4gdGhpcy5femVyb0RibCgpO1xuICBlbHNlIGlmICh0aGlzLmN1cnZlLnRocmVlQSlcbiAgICByZXR1cm4gdGhpcy5fdGhyZWVEYmwoKTtcbiAgZWxzZVxuICAgIHJldHVybiB0aGlzLl9kYmwoKTtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUuX3plcm9EYmwgPSBmdW5jdGlvbiBfemVyb0RibCgpIHtcbiAgdmFyIG54O1xuICB2YXIgbnk7XG4gIHZhciBuejtcbiAgLy8gWiA9IDFcbiAgaWYgKHRoaXMuek9uZSkge1xuICAgIC8vIGh5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by1zaG9ydHctamFjb2JpYW4tMC5odG1sXG4gICAgLy8gICAgICNkb3VibGluZy1tZGJsLTIwMDctYmxcbiAgICAvLyAxTSArIDVTICsgMTRBXG5cbiAgICAvLyBYWCA9IFgxXjJcbiAgICB2YXIgeHggPSB0aGlzLngucmVkU3FyKCk7XG4gICAgLy8gWVkgPSBZMV4yXG4gICAgdmFyIHl5ID0gdGhpcy55LnJlZFNxcigpO1xuICAgIC8vIFlZWVkgPSBZWV4yXG4gICAgdmFyIHl5eXkgPSB5eS5yZWRTcXIoKTtcbiAgICAvLyBTID0gMiAqICgoWDEgKyBZWSleMiAtIFhYIC0gWVlZWSlcbiAgICB2YXIgcyA9IHRoaXMueC5yZWRBZGQoeXkpLnJlZFNxcigpLnJlZElTdWIoeHgpLnJlZElTdWIoeXl5eSk7XG4gICAgcyA9IHMucmVkSUFkZChzKTtcbiAgICAvLyBNID0gMyAqIFhYICsgYTsgYSA9IDBcbiAgICB2YXIgbSA9IHh4LnJlZEFkZCh4eCkucmVkSUFkZCh4eCk7XG4gICAgLy8gVCA9IE0gXiAyIC0gMipTXG4gICAgdmFyIHQgPSBtLnJlZFNxcigpLnJlZElTdWIocykucmVkSVN1YihzKTtcblxuICAgIC8vIDggKiBZWVlZXG4gICAgdmFyIHl5eXk4ID0geXl5eS5yZWRJQWRkKHl5eXkpO1xuICAgIHl5eXk4ID0geXl5eTgucmVkSUFkZCh5eXl5OCk7XG4gICAgeXl5eTggPSB5eXl5OC5yZWRJQWRkKHl5eXk4KTtcblxuICAgIC8vIFgzID0gVFxuICAgIG54ID0gdDtcbiAgICAvLyBZMyA9IE0gKiAoUyAtIFQpIC0gOCAqIFlZWVlcbiAgICBueSA9IG0ucmVkTXVsKHMucmVkSVN1Yih0KSkucmVkSVN1Yih5eXl5OCk7XG4gICAgLy8gWjMgPSAyKlkxXG4gICAgbnogPSB0aGlzLnkucmVkQWRkKHRoaXMueSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gaHlwZXJlbGxpcHRpYy5vcmcvRUZEL2cxcC9hdXRvLXNob3J0dy1qYWNvYmlhbi0wLmh0bWxcbiAgICAvLyAgICAgI2RvdWJsaW5nLWRibC0yMDA5LWxcbiAgICAvLyAyTSArIDVTICsgMTNBXG5cbiAgICAvLyBBID0gWDFeMlxuICAgIHZhciBhID0gdGhpcy54LnJlZFNxcigpO1xuICAgIC8vIEIgPSBZMV4yXG4gICAgdmFyIGIgPSB0aGlzLnkucmVkU3FyKCk7XG4gICAgLy8gQyA9IEJeMlxuICAgIHZhciBjID0gYi5yZWRTcXIoKTtcbiAgICAvLyBEID0gMiAqICgoWDEgKyBCKV4yIC0gQSAtIEMpXG4gICAgdmFyIGQgPSB0aGlzLngucmVkQWRkKGIpLnJlZFNxcigpLnJlZElTdWIoYSkucmVkSVN1YihjKTtcbiAgICBkID0gZC5yZWRJQWRkKGQpO1xuICAgIC8vIEUgPSAzICogQVxuICAgIHZhciBlID0gYS5yZWRBZGQoYSkucmVkSUFkZChhKTtcbiAgICAvLyBGID0gRV4yXG4gICAgdmFyIGYgPSBlLnJlZFNxcigpO1xuXG4gICAgLy8gOCAqIENcbiAgICB2YXIgYzggPSBjLnJlZElBZGQoYyk7XG4gICAgYzggPSBjOC5yZWRJQWRkKGM4KTtcbiAgICBjOCA9IGM4LnJlZElBZGQoYzgpO1xuXG4gICAgLy8gWDMgPSBGIC0gMiAqIERcbiAgICBueCA9IGYucmVkSVN1YihkKS5yZWRJU3ViKGQpO1xuICAgIC8vIFkzID0gRSAqIChEIC0gWDMpIC0gOCAqIENcbiAgICBueSA9IGUucmVkTXVsKGQucmVkSVN1YihueCkpLnJlZElTdWIoYzgpO1xuICAgIC8vIFozID0gMiAqIFkxICogWjFcbiAgICBueiA9IHRoaXMueS5yZWRNdWwodGhpcy56KTtcbiAgICBueiA9IG56LnJlZElBZGQobnopO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG54LCBueSwgbnopO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS5fdGhyZWVEYmwgPSBmdW5jdGlvbiBfdGhyZWVEYmwoKSB7XG4gIHZhciBueDtcbiAgdmFyIG55O1xuICB2YXIgbno7XG4gIC8vIFogPSAxXG4gIGlmICh0aGlzLnpPbmUpIHtcbiAgICAvLyBoeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tc2hvcnR3LWphY29iaWFuLTMuaHRtbFxuICAgIC8vICAgICAjZG91YmxpbmctbWRibC0yMDA3LWJsXG4gICAgLy8gMU0gKyA1UyArIDE1QVxuXG4gICAgLy8gWFggPSBYMV4yXG4gICAgdmFyIHh4ID0gdGhpcy54LnJlZFNxcigpO1xuICAgIC8vIFlZID0gWTFeMlxuICAgIHZhciB5eSA9IHRoaXMueS5yZWRTcXIoKTtcbiAgICAvLyBZWVlZID0gWVleMlxuICAgIHZhciB5eXl5ID0geXkucmVkU3FyKCk7XG4gICAgLy8gUyA9IDIgKiAoKFgxICsgWVkpXjIgLSBYWCAtIFlZWVkpXG4gICAgdmFyIHMgPSB0aGlzLngucmVkQWRkKHl5KS5yZWRTcXIoKS5yZWRJU3ViKHh4KS5yZWRJU3ViKHl5eXkpO1xuICAgIHMgPSBzLnJlZElBZGQocyk7XG4gICAgLy8gTSA9IDMgKiBYWCArIGFcbiAgICB2YXIgbSA9IHh4LnJlZEFkZCh4eCkucmVkSUFkZCh4eCkucmVkSUFkZCh0aGlzLmN1cnZlLmEpO1xuICAgIC8vIFQgPSBNXjIgLSAyICogU1xuICAgIHZhciB0ID0gbS5yZWRTcXIoKS5yZWRJU3ViKHMpLnJlZElTdWIocyk7XG4gICAgLy8gWDMgPSBUXG4gICAgbnggPSB0O1xuICAgIC8vIFkzID0gTSAqIChTIC0gVCkgLSA4ICogWVlZWVxuICAgIHZhciB5eXl5OCA9IHl5eXkucmVkSUFkZCh5eXl5KTtcbiAgICB5eXl5OCA9IHl5eXk4LnJlZElBZGQoeXl5eTgpO1xuICAgIHl5eXk4ID0geXl5eTgucmVkSUFkZCh5eXl5OCk7XG4gICAgbnkgPSBtLnJlZE11bChzLnJlZElTdWIodCkpLnJlZElTdWIoeXl5eTgpO1xuICAgIC8vIFozID0gMiAqIFkxXG4gICAgbnogPSB0aGlzLnkucmVkQWRkKHRoaXMueSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gaHlwZXJlbGxpcHRpYy5vcmcvRUZEL2cxcC9hdXRvLXNob3J0dy1qYWNvYmlhbi0zLmh0bWwjZG91YmxpbmctZGJsLTIwMDEtYlxuICAgIC8vIDNNICsgNVNcblxuICAgIC8vIGRlbHRhID0gWjFeMlxuICAgIHZhciBkZWx0YSA9IHRoaXMuei5yZWRTcXIoKTtcbiAgICAvLyBnYW1tYSA9IFkxXjJcbiAgICB2YXIgZ2FtbWEgPSB0aGlzLnkucmVkU3FyKCk7XG4gICAgLy8gYmV0YSA9IFgxICogZ2FtbWFcbiAgICB2YXIgYmV0YSA9IHRoaXMueC5yZWRNdWwoZ2FtbWEpO1xuICAgIC8vIGFscGhhID0gMyAqIChYMSAtIGRlbHRhKSAqIChYMSArIGRlbHRhKVxuICAgIHZhciBhbHBoYSA9IHRoaXMueC5yZWRTdWIoZGVsdGEpLnJlZE11bCh0aGlzLngucmVkQWRkKGRlbHRhKSk7XG4gICAgYWxwaGEgPSBhbHBoYS5yZWRBZGQoYWxwaGEpLnJlZElBZGQoYWxwaGEpO1xuICAgIC8vIFgzID0gYWxwaGFeMiAtIDggKiBiZXRhXG4gICAgdmFyIGJldGE0ID0gYmV0YS5yZWRJQWRkKGJldGEpO1xuICAgIGJldGE0ID0gYmV0YTQucmVkSUFkZChiZXRhNCk7XG4gICAgdmFyIGJldGE4ID0gYmV0YTQucmVkQWRkKGJldGE0KTtcbiAgICBueCA9IGFscGhhLnJlZFNxcigpLnJlZElTdWIoYmV0YTgpO1xuICAgIC8vIFozID0gKFkxICsgWjEpXjIgLSBnYW1tYSAtIGRlbHRhXG4gICAgbnogPSB0aGlzLnkucmVkQWRkKHRoaXMueikucmVkU3FyKCkucmVkSVN1YihnYW1tYSkucmVkSVN1YihkZWx0YSk7XG4gICAgLy8gWTMgPSBhbHBoYSAqICg0ICogYmV0YSAtIFgzKSAtIDggKiBnYW1tYV4yXG4gICAgdmFyIGdnYW1tYTggPSBnYW1tYS5yZWRTcXIoKTtcbiAgICBnZ2FtbWE4ID0gZ2dhbW1hOC5yZWRJQWRkKGdnYW1tYTgpO1xuICAgIGdnYW1tYTggPSBnZ2FtbWE4LnJlZElBZGQoZ2dhbW1hOCk7XG4gICAgZ2dhbW1hOCA9IGdnYW1tYTgucmVkSUFkZChnZ2FtbWE4KTtcbiAgICBueSA9IGFscGhhLnJlZE11bChiZXRhNC5yZWRJU3ViKG54KSkucmVkSVN1YihnZ2FtbWE4KTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludChueCwgbnksIG56KTtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUuX2RibCA9IGZ1bmN0aW9uIF9kYmwoKSB7XG4gIHZhciBhID0gdGhpcy5jdXJ2ZS5hO1xuXG4gIC8vIDRNICsgNlMgKyAxMEFcbiAgdmFyIGp4ID0gdGhpcy54O1xuICB2YXIgankgPSB0aGlzLnk7XG4gIHZhciBqeiA9IHRoaXMuejtcbiAgdmFyIGp6NCA9IGp6LnJlZFNxcigpLnJlZFNxcigpO1xuXG4gIHZhciBqeDIgPSBqeC5yZWRTcXIoKTtcbiAgdmFyIGp5MiA9IGp5LnJlZFNxcigpO1xuXG4gIHZhciBjID0gangyLnJlZEFkZChqeDIpLnJlZElBZGQoangyKS5yZWRJQWRkKGEucmVkTXVsKGp6NCkpO1xuXG4gIHZhciBqeGQ0ID0gangucmVkQWRkKGp4KTtcbiAganhkNCA9IGp4ZDQucmVkSUFkZChqeGQ0KTtcbiAgdmFyIHQxID0ganhkNC5yZWRNdWwoankyKTtcbiAgdmFyIG54ID0gYy5yZWRTcXIoKS5yZWRJU3ViKHQxLnJlZEFkZCh0MSkpO1xuICB2YXIgdDIgPSB0MS5yZWRJU3ViKG54KTtcblxuICB2YXIganlkOCA9IGp5Mi5yZWRTcXIoKTtcbiAganlkOCA9IGp5ZDgucmVkSUFkZChqeWQ4KTtcbiAganlkOCA9IGp5ZDgucmVkSUFkZChqeWQ4KTtcbiAganlkOCA9IGp5ZDgucmVkSUFkZChqeWQ4KTtcbiAgdmFyIG55ID0gYy5yZWRNdWwodDIpLnJlZElTdWIoanlkOCk7XG4gIHZhciBueiA9IGp5LnJlZEFkZChqeSkucmVkTXVsKGp6KTtcblxuICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobngsIG55LCBueik7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLnRycGwgPSBmdW5jdGlvbiB0cnBsKCkge1xuICBpZiAoIXRoaXMuY3VydmUuemVyb0EpXG4gICAgcmV0dXJuIHRoaXMuZGJsKCkuYWRkKHRoaXMpO1xuXG4gIC8vIGh5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by1zaG9ydHctamFjb2JpYW4tMC5odG1sI3RyaXBsaW5nLXRwbC0yMDA3LWJsXG4gIC8vIDVNICsgMTBTICsgLi4uXG5cbiAgLy8gWFggPSBYMV4yXG4gIHZhciB4eCA9IHRoaXMueC5yZWRTcXIoKTtcbiAgLy8gWVkgPSBZMV4yXG4gIHZhciB5eSA9IHRoaXMueS5yZWRTcXIoKTtcbiAgLy8gWlogPSBaMV4yXG4gIHZhciB6eiA9IHRoaXMuei5yZWRTcXIoKTtcbiAgLy8gWVlZWSA9IFlZXjJcbiAgdmFyIHl5eXkgPSB5eS5yZWRTcXIoKTtcbiAgLy8gTSA9IDMgKiBYWCArIGEgKiBaWjI7IGEgPSAwXG4gIHZhciBtID0geHgucmVkQWRkKHh4KS5yZWRJQWRkKHh4KTtcbiAgLy8gTU0gPSBNXjJcbiAgdmFyIG1tID0gbS5yZWRTcXIoKTtcbiAgLy8gRSA9IDYgKiAoKFgxICsgWVkpXjIgLSBYWCAtIFlZWVkpIC0gTU1cbiAgdmFyIGUgPSB0aGlzLngucmVkQWRkKHl5KS5yZWRTcXIoKS5yZWRJU3ViKHh4KS5yZWRJU3ViKHl5eXkpO1xuICBlID0gZS5yZWRJQWRkKGUpO1xuICBlID0gZS5yZWRBZGQoZSkucmVkSUFkZChlKTtcbiAgZSA9IGUucmVkSVN1YihtbSk7XG4gIC8vIEVFID0gRV4yXG4gIHZhciBlZSA9IGUucmVkU3FyKCk7XG4gIC8vIFQgPSAxNipZWVlZXG4gIHZhciB0ID0geXl5eS5yZWRJQWRkKHl5eXkpO1xuICB0ID0gdC5yZWRJQWRkKHQpO1xuICB0ID0gdC5yZWRJQWRkKHQpO1xuICB0ID0gdC5yZWRJQWRkKHQpO1xuICAvLyBVID0gKE0gKyBFKV4yIC0gTU0gLSBFRSAtIFRcbiAgdmFyIHUgPSBtLnJlZElBZGQoZSkucmVkU3FyKCkucmVkSVN1YihtbSkucmVkSVN1YihlZSkucmVkSVN1Yih0KTtcbiAgLy8gWDMgPSA0ICogKFgxICogRUUgLSA0ICogWVkgKiBVKVxuICB2YXIgeXl1NCA9IHl5LnJlZE11bCh1KTtcbiAgeXl1NCA9IHl5dTQucmVkSUFkZCh5eXU0KTtcbiAgeXl1NCA9IHl5dTQucmVkSUFkZCh5eXU0KTtcbiAgdmFyIG54ID0gdGhpcy54LnJlZE11bChlZSkucmVkSVN1Yih5eXU0KTtcbiAgbnggPSBueC5yZWRJQWRkKG54KTtcbiAgbnggPSBueC5yZWRJQWRkKG54KTtcbiAgLy8gWTMgPSA4ICogWTEgKiAoVSAqIChUIC0gVSkgLSBFICogRUUpXG4gIHZhciBueSA9IHRoaXMueS5yZWRNdWwodS5yZWRNdWwodC5yZWRJU3ViKHUpKS5yZWRJU3ViKGUucmVkTXVsKGVlKSkpO1xuICBueSA9IG55LnJlZElBZGQobnkpO1xuICBueSA9IG55LnJlZElBZGQobnkpO1xuICBueSA9IG55LnJlZElBZGQobnkpO1xuICAvLyBaMyA9IChaMSArIEUpXjIgLSBaWiAtIEVFXG4gIHZhciBueiA9IHRoaXMuei5yZWRBZGQoZSkucmVkU3FyKCkucmVkSVN1Yih6eikucmVkSVN1YihlZSk7XG5cbiAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG54LCBueSwgbnopO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiBtdWwoaywga2Jhc2UpIHtcbiAgayA9IG5ldyBibihrLCBrYmFzZSk7XG5cbiAgcmV0dXJuIHRoaXMuY3VydmUuX3duYWZNdWwodGhpcywgayk7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLmVxID0gZnVuY3Rpb24gZXEocCkge1xuICBpZiAocC50eXBlID09PSAnYWZmaW5lJylcbiAgICByZXR1cm4gdGhpcy5lcShwLnRvSigpKTtcblxuICBpZiAodGhpcyA9PT0gcClcbiAgICByZXR1cm4gdHJ1ZTtcblxuICAvLyB4MSAqIHoyXjIgPT0geDIgKiB6MV4yXG4gIHZhciB6MiA9IHRoaXMuei5yZWRTcXIoKTtcbiAgdmFyIHB6MiA9IHAuei5yZWRTcXIoKTtcbiAgaWYgKHRoaXMueC5yZWRNdWwocHoyKS5yZWRJU3ViKHAueC5yZWRNdWwoejIpKS5jbXBuKDApICE9PSAwKVxuICAgIHJldHVybiBmYWxzZTtcblxuICAvLyB5MSAqIHoyXjMgPT0geTIgKiB6MV4zXG4gIHZhciB6MyA9IHoyLnJlZE11bCh0aGlzLnopO1xuICB2YXIgcHozID0gcHoyLnJlZE11bChwLnopO1xuICByZXR1cm4gdGhpcy55LnJlZE11bChwejMpLnJlZElTdWIocC55LnJlZE11bCh6MykpLmNtcG4oMCkgPT09IDA7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0KCkge1xuICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuICc8RUMgSlBvaW50IEluZmluaXR5Pic7XG4gIHJldHVybiAnPEVDIEpQb2ludCB4OiAnICsgdGhpcy54LnRvU3RyaW5nKDE2LCAyKSArXG4gICAgICAnIHk6ICcgKyB0aGlzLnkudG9TdHJpbmcoMTYsIDIpICtcbiAgICAgICcgejogJyArIHRoaXMuei50b1N0cmluZygxNiwgMikgKyAnPic7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLmlzSW5maW5pdHkgPSBmdW5jdGlvbiBpc0luZmluaXR5KCkge1xuICAvLyBYWFggVGhpcyBjb2RlIGFzc3VtZXMgdGhhdCB6ZXJvIGlzIGFsd2F5cyB6ZXJvIGluIHJlZFxuICByZXR1cm4gdGhpcy56LmNtcG4oMCkgPT09IDA7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY3VydmVzID0gZXhwb3J0cztcblxudmFyIGhhc2ggPSByZXF1aXJlKCdoYXNoLmpzJyk7XG52YXIgZWxsaXB0aWMgPSByZXF1aXJlKCcuLi9lbGxpcHRpYycpO1xuXG52YXIgYXNzZXJ0ID0gZWxsaXB0aWMudXRpbHMuYXNzZXJ0O1xuXG5mdW5jdGlvbiBQcmVzZXRDdXJ2ZShvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLnR5cGUgPT09ICdzaG9ydCcpXG4gICAgdGhpcy5jdXJ2ZSA9IG5ldyBlbGxpcHRpYy5jdXJ2ZS5zaG9ydChvcHRpb25zKTtcbiAgZWxzZSBpZiAob3B0aW9ucy50eXBlID09PSAnZWR3YXJkcycpXG4gICAgdGhpcy5jdXJ2ZSA9IG5ldyBlbGxpcHRpYy5jdXJ2ZS5lZHdhcmRzKG9wdGlvbnMpO1xuICBlbHNlXG4gICAgdGhpcy5jdXJ2ZSA9IG5ldyBlbGxpcHRpYy5jdXJ2ZS5tb250KG9wdGlvbnMpO1xuICB0aGlzLmcgPSB0aGlzLmN1cnZlLmc7XG4gIHRoaXMubiA9IHRoaXMuY3VydmUubjtcbiAgdGhpcy5oYXNoID0gb3B0aW9ucy5oYXNoO1xuXG4gIGFzc2VydCh0aGlzLmcudmFsaWRhdGUoKSwgJ0ludmFsaWQgY3VydmUnKTtcbiAgYXNzZXJ0KHRoaXMuZy5tdWwodGhpcy5uKS5pc0luZmluaXR5KCksICdJbnZhbGlkIGN1cnZlLCBHKk4gIT0gTycpO1xufVxuY3VydmVzLlByZXNldEN1cnZlID0gUHJlc2V0Q3VydmU7XG5cbmZ1bmN0aW9uIGRlZmluZUN1cnZlKG5hbWUsIG9wdGlvbnMpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1cnZlcywgbmFtZSwge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY3VydmUgPSBuZXcgUHJlc2V0Q3VydmUob3B0aW9ucyk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VydmVzLCBuYW1lLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGN1cnZlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjdXJ2ZTtcbiAgICB9XG4gIH0pO1xufVxuXG5kZWZpbmVDdXJ2ZSgncDE5MicsIHtcbiAgdHlwZTogJ3Nob3J0JyxcbiAgcHJpbWU6ICdwMTkyJyxcbiAgcDogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGZmZmZmZmZmIGZmZmZmZmZmJyxcbiAgYTogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGZmZmZmZmZmIGZmZmZmZmZjJyxcbiAgYjogJzY0MjEwNTE5IGU1OWM4MGU3IDBmYTdlOWFiIDcyMjQzMDQ5IGZlYjhkZWVjIGMxNDZiOWIxJyxcbiAgbjogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIDk5ZGVmODM2IDE0NmJjOWIxIGI0ZDIyODMxJyxcbiAgaGFzaDogaGFzaC5zaGEyNTYsXG4gIGdSZWQ6IGZhbHNlLFxuICBnOiBbXG4gICAgJzE4OGRhODBlIGIwMzA5MGY2IDdjYmYyMGViIDQzYTE4ODAwIGY0ZmYwYWZkIDgyZmYxMDEyJyxcbiAgICAnMDcxOTJiOTUgZmZjOGRhNzggNjMxMDExZWQgNmIyNGNkZDUgNzNmOTc3YTEgMWU3OTQ4MTEnXG4gIF1cbn0pO1xuXG5kZWZpbmVDdXJ2ZSgncDIyNCcsIHtcbiAgdHlwZTogJ3Nob3J0JyxcbiAgcHJpbWU6ICdwMjI0JyxcbiAgcDogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIDAwMDAwMDAwIDAwMDAwMDAwIDAwMDAwMDAxJyxcbiAgYTogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlJyxcbiAgYjogJ2I0MDUwYTg1IDBjMDRiM2FiIGY1NDEzMjU2IDUwNDRiMGI3IGQ3YmZkOGJhIDI3MGIzOTQzIDIzNTVmZmI0JyxcbiAgbjogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmYxNmEyIGUwYjhmMDNlIDEzZGQyOTQ1IDVjNWMyYTNkJyxcbiAgaGFzaDogaGFzaC5zaGEyNTYsXG4gIGdSZWQ6IGZhbHNlLFxuICBnOiBbXG4gICAgJ2I3MGUwY2JkIDZiYjRiZjdmIDMyMTM5MGI5IDRhMDNjMWQzIDU2YzIxMTIyIDM0MzI4MGQ2IDExNWMxZDIxJyxcbiAgICAnYmQzNzYzODggYjVmNzIzZmIgNGMyMmRmZTYgY2Q0Mzc1YTAgNWEwNzQ3NjQgNDRkNTgxOTkgODUwMDdlMzQnXG4gIF1cbn0pO1xuXG5kZWZpbmVDdXJ2ZSgncDI1NicsIHtcbiAgdHlwZTogJ3Nob3J0JyxcbiAgcHJpbWU6IG51bGwsXG4gIHA6ICdmZmZmZmZmZiAwMDAwMDAwMSAwMDAwMDAwMCAwMDAwMDAwMCAwMDAwMDAwMCBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZicsXG4gIGE6ICdmZmZmZmZmZiAwMDAwMDAwMSAwMDAwMDAwMCAwMDAwMDAwMCAwMDAwMDAwMCBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmYycsXG4gIGI6ICc1YWM2MzVkOCBhYTNhOTNlNyBiM2ViYmQ1NSA3Njk4ODZiYyA2NTFkMDZiMCBjYzUzYjBmNiAzYmNlM2MzZSAyN2QyNjA0YicsXG4gIG46ICdmZmZmZmZmZiAwMDAwMDAwMCBmZmZmZmZmZiBmZmZmZmZmZiBiY2U2ZmFhZCBhNzE3OWU4NCBmM2I5Y2FjMiBmYzYzMjU1MScsXG4gIGhhc2g6IGhhc2guc2hhMjU2LFxuICBnUmVkOiBmYWxzZSxcbiAgZzogW1xuICAgICc2YjE3ZDFmMiBlMTJjNDI0NyBmOGJjZTZlNSA2M2E0NDBmMiA3NzAzN2Q4MSAyZGViMzNhMCBmNGExMzk0NSBkODk4YzI5NicsXG4gICAgJzRmZTM0MmUyIGZlMWE3ZjliIDhlZTdlYjRhIDdjMGY5ZTE2IDJiY2UzMzU3IDZiMzE1ZWNlIGNiYjY0MDY4IDM3YmY1MWY1J1xuICBdXG59KTtcblxuZGVmaW5lQ3VydmUoJ3AzODQnLCB7XG4gIHR5cGU6ICdzaG9ydCcsXG4gIHByaW1lOiBudWxsLFxuICBwOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgJyArXG4gICAgICdmZmZmZmZmZSBmZmZmZmZmZiAwMDAwMDAwMCAwMDAwMDAwMCBmZmZmZmZmZicsXG4gIGE6ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAnICtcbiAgICAgJ2ZmZmZmZmZlIGZmZmZmZmZmIDAwMDAwMDAwIDAwMDAwMDAwIGZmZmZmZmZjJyxcbiAgYjogJ2IzMzEyZmE3IGUyM2VlN2U0IDk4OGUwNTZiIGUzZjgyZDE5IDE4MWQ5YzZlIGZlODE0MTEyIDAzMTQwODhmICcgK1xuICAgICAnNTAxMzg3NWEgYzY1NjM5OGQgOGEyZWQxOWQgMmE4NWM4ZWQgZDNlYzJhZWYnLFxuICBuOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgYzc2MzRkODEgJyArXG4gICAgICdmNDM3MmRkZiA1ODFhMGRiMiA0OGIwYTc3YSBlY2VjMTk2YSBjY2M1Mjk3MycsXG4gIGhhc2g6IGhhc2guc2hhMzg0LFxuICBnUmVkOiBmYWxzZSxcbiAgZzogW1xuICAgICdhYTg3Y2EyMiBiZThiMDUzNyA4ZWIxYzcxZSBmMzIwYWQ3NCA2ZTFkM2I2MiA4YmE3OWI5OCA1OWY3NDFlMCA4MjU0MmEzOCAnICtcbiAgICAnNTUwMmYyNWQgYmY1NTI5NmMgM2E1NDVlMzggNzI3NjBhYjcnLFxuICAgICczNjE3ZGU0YSA5NjI2MmM2ZiA1ZDllOThiZiA5MjkyZGMyOSBmOGY0MWRiZCAyODlhMTQ3YyBlOWRhMzExMyBiNWYwYjhjMCAnICtcbiAgICAnMGE2MGIxY2UgMWQ3ZTgxOWQgN2E0MzFkN2MgOTBlYTBlNWYnXG4gIF1cbn0pO1xuXG5kZWZpbmVDdXJ2ZSgncDUyMScsIHtcbiAgdHlwZTogJ3Nob3J0JyxcbiAgcHJpbWU6IG51bGwsXG4gIHA6ICcwMDAwMDFmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAnICtcbiAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmICcgK1xuICAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYnLFxuICBhOiAnMDAwMDAxZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgJyArXG4gICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAnICtcbiAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZjJyxcbiAgYjogJzAwMDAwMDUxIDk1M2ViOTYxIDhlMWM5YTFmIDkyOWEyMWEwIGI2ODU0MGVlIGEyZGE3MjViICcgK1xuICAgICAnOTliMzE1ZjMgYjhiNDg5OTEgOGVmMTA5ZTEgNTYxOTM5NTEgZWM3ZTkzN2IgMTY1MmMwYmQgJyArXG4gICAgICczYmIxYmYwNyAzNTczZGY4OCAzZDJjMzRmMSBlZjQ1MWZkNCA2YjUwM2YwMCcsXG4gIG46ICcwMDAwMDFmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAnICtcbiAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZhIDUxODY4NzgzIGJmMmY5NjZiIDdmY2MwMTQ4ICcgK1xuICAgICAnZjcwOWE1ZDAgM2JiNWM5YjggODk5YzQ3YWUgYmI2ZmI3MWUgOTEzODY0MDknLFxuICBoYXNoOiBoYXNoLnNoYTUxMixcbiAgZ1JlZDogZmFsc2UsXG4gIGc6IFtcbiAgICAnMDAwMDAwYzYgODU4ZTA2YjcgMDQwNGU5Y2QgOWUzZWNiNjYgMjM5NWI0NDIgOWM2NDgxMzkgJyArXG4gICAgJzA1M2ZiNTIxIGY4MjhhZjYwIDZiNGQzZGJhIGExNGI1ZTc3IGVmZTc1OTI4IGZlMWRjMTI3ICcgK1xuICAgICdhMmZmYThkZSAzMzQ4YjNjMSA4NTZhNDI5YiBmOTdlN2UzMSBjMmU1YmQ2NicsXG4gICAgJzAwMDAwMTE4IDM5Mjk2YTc4IDlhM2JjMDA0IDVjOGE1ZmI0IDJjN2QxYmQ5IDk4ZjU0NDQ5ICcgK1xuICAgICc1NzliNDQ2OCAxN2FmYmQxNyAyNzNlNjYyYyA5N2VlNzI5OSA1ZWY0MjY0MCBjNTUwYjkwMSAnICtcbiAgICAnM2ZhZDA3NjEgMzUzYzcwODYgYTI3MmMyNDAgODhiZTk0NzYgOWZkMTY2NTAnXG4gIF1cbn0pO1xuXG5kZWZpbmVDdXJ2ZSgnY3VydmUyNTUxOScsIHtcbiAgdHlwZTogJ21vbnQnLFxuICBwcmltZTogJ3AyNTUxOScsXG4gIHA6ICc3ZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmVkJyxcbiAgYTogJzc2ZDA2JyxcbiAgYjogJzAnLFxuICBuOiAnMTAwMDAwMDAwMDAwMDAwMCAwMDAwMDAwMDAwMDAwMDAwIDE0ZGVmOWRlYTJmNzljZDYgNTgxMjYzMWE1Y2Y1ZDNlZCcsXG4gIGhhc2g6IGhhc2guc2hhMjU2LFxuICBnUmVkOiBmYWxzZSxcbiAgZzogW1xuICAgICc5J1xuICBdXG59KTtcblxuZGVmaW5lQ3VydmUoJ2VkMjU1MTknLCB7XG4gIHR5cGU6ICdlZHdhcmRzJyxcbiAgcHJpbWU6ICdwMjU1MTknLFxuICBwOiAnN2ZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZlZCcsXG4gIGE6ICctMScsXG4gIGM6ICcxJyxcbiAgLy8gLTEyMTY2NSAqICgxMjE2NjZeKC0xKSkgKG1vZCBQKVxuICBkOiAnNTIwMzZjZWUyYjZmZmU3MyA4Y2M3NDA3OTc3NzllODk4IDAwNzAwYTRkNDE0MWQ4YWIgNzVlYjRkY2ExMzU5NzhhMycsXG4gIG46ICcxMDAwMDAwMDAwMDAwMDAwIDAwMDAwMDAwMDAwMDAwMDAgMTRkZWY5ZGVhMmY3OWNkNiA1ODEyNjMxYTVjZjVkM2VkJyxcbiAgaGFzaDogaGFzaC5zaGEyNTYsXG4gIGdSZWQ6IGZhbHNlLFxuICBnOiBbXG4gICAgJzIxNjkzNmQzY2Q2ZTUzZmVjMGE0ZTIzMWZkZDZkYzVjNjkyY2M3NjA5NTI1YTdiMmM5NTYyZDYwOGYyNWQ1MWEnLFxuXG4gICAgLy8gNC81XG4gICAgJzY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NTgnXG4gIF1cbn0pO1xuXG52YXIgcHJlO1xudHJ5IHtcbiAgcHJlID0gcmVxdWlyZSgnLi9wcmVjb21wdXRlZC9zZWNwMjU2azEnKTtcbn0gY2F0Y2ggKGUpIHtcbiAgcHJlID0gdW5kZWZpbmVkO1xufVxuXG5kZWZpbmVDdXJ2ZSgnc2VjcDI1NmsxJywge1xuICB0eXBlOiAnc2hvcnQnLFxuICBwcmltZTogJ2syNTYnLFxuICBwOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZjMmYnLFxuICBhOiAnMCcsXG4gIGI6ICc3JyxcbiAgbjogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGJhYWVkY2U2IGFmNDhhMDNiIGJmZDI1ZThjIGQwMzY0MTQxJyxcbiAgaDogJzEnLFxuICBoYXNoOiBoYXNoLnNoYTI1NixcblxuICAvLyBQcmVjb21wdXRlZCBlbmRvbW9ycGhpc21cbiAgYmV0YTogJzdhZTk2YTJiNjU3YzA3MTA2ZTY0NDc5ZWFjMzQzNGU5OWNmMDQ5NzUxMmY1ODk5NWMxMzk2YzI4NzE5NTAxZWUnLFxuICBsYW1iZGE6ICc1MzYzYWQ0Y2MwNWMzMGUwYTUyNjFjMDI4ODEyNjQ1YTEyMmUyMmVhMjA4MTY2NzhkZjAyOTY3YzFiMjNiZDcyJyxcbiAgYmFzaXM6IFtcbiAgICB7XG4gICAgICBhOiAnMzA4NmQyMjFhN2Q0NmJjZGU4NmM5MGU0OTI4NGViMTUnLFxuICAgICAgYjogJy1lNDQzN2VkNjAxMGU4ODI4NmY1NDdmYTkwYWJmZTRjMydcbiAgICB9LFxuICAgIHtcbiAgICAgIGE6ICcxMTRjYTUwZjdhOGUyZjNmNjU3YzExMDhkOWQ0NGNmZDgnLFxuICAgICAgYjogJzMwODZkMjIxYTdkNDZiY2RlODZjOTBlNDkyODRlYjE1J1xuICAgIH1cbiAgXSxcblxuICBnUmVkOiBmYWxzZSxcbiAgZzogW1xuICAgICc3OWJlNjY3ZWY5ZGNiYmFjNTVhMDYyOTVjZTg3MGIwNzAyOWJmY2RiMmRjZTI4ZDk1OWYyODE1YjE2ZjgxNzk4JyxcbiAgICAnNDgzYWRhNzcyNmEzYzQ2NTVkYTRmYmZjMGUxMTA4YThmZDE3YjQ0OGE2ODU1NDE5OWM0N2QwOGZmYjEwZDRiOCcsXG4gICAgcHJlXG4gIF1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYm4gPSByZXF1aXJlKCdibi5qcycpO1xudmFyIGVsbGlwdGljID0gcmVxdWlyZSgnLi4vLi4vZWxsaXB0aWMnKTtcbnZhciB1dGlscyA9IGVsbGlwdGljLnV0aWxzO1xudmFyIGFzc2VydCA9IHV0aWxzLmFzc2VydDtcblxudmFyIEtleVBhaXIgPSByZXF1aXJlKCcuL2tleScpO1xudmFyIFNpZ25hdHVyZSA9IHJlcXVpcmUoJy4vc2lnbmF0dXJlJyk7XG5cbmZ1bmN0aW9uIEVDKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEVDKSlcbiAgICByZXR1cm4gbmV3IEVDKG9wdGlvbnMpO1xuXG4gIC8vIFNob3J0Y3V0IGBlbGxpcHRpYy5lYyhjdXJ2ZS1uYW1lKWBcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgIGFzc2VydChlbGxpcHRpYy5jdXJ2ZXMuaGFzT3duUHJvcGVydHkob3B0aW9ucyksICdVbmtub3duIGN1cnZlICcgKyBvcHRpb25zKTtcblxuICAgIG9wdGlvbnMgPSBlbGxpcHRpYy5jdXJ2ZXNbb3B0aW9uc107XG4gIH1cblxuICAvLyBTaG9ydGN1dCBmb3IgYGVsbGlwdGljLmVjKGVsbGlwdGljLmN1cnZlcy5jdXJ2ZU5hbWUpYFxuICBpZiAob3B0aW9ucyBpbnN0YW5jZW9mIGVsbGlwdGljLmN1cnZlcy5QcmVzZXRDdXJ2ZSlcbiAgICBvcHRpb25zID0geyBjdXJ2ZTogb3B0aW9ucyB9O1xuXG4gIHRoaXMuY3VydmUgPSBvcHRpb25zLmN1cnZlLmN1cnZlO1xuICB0aGlzLm4gPSB0aGlzLmN1cnZlLm47XG4gIHRoaXMubmggPSB0aGlzLm4udXNocm4oMSk7XG4gIHRoaXMuZyA9IHRoaXMuY3VydmUuZztcblxuICAvLyBQb2ludCBvbiBjdXJ2ZVxuICB0aGlzLmcgPSBvcHRpb25zLmN1cnZlLmc7XG4gIHRoaXMuZy5wcmVjb21wdXRlKG9wdGlvbnMuY3VydmUubi5iaXRMZW5ndGgoKSArIDEpO1xuXG4gIC8vIEhhc2ggZm9yIGZ1bmN0aW9uIGZvciBEUkJHXG4gIHRoaXMuaGFzaCA9IG9wdGlvbnMuaGFzaCB8fCBvcHRpb25zLmN1cnZlLmhhc2g7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEVDO1xuXG5FQy5wcm90b3R5cGUua2V5UGFpciA9IGZ1bmN0aW9uIGtleVBhaXIob3B0aW9ucykge1xuICByZXR1cm4gbmV3IEtleVBhaXIodGhpcywgb3B0aW9ucyk7XG59O1xuXG5FQy5wcm90b3R5cGUua2V5RnJvbVByaXZhdGUgPSBmdW5jdGlvbiBrZXlGcm9tUHJpdmF0ZShwcml2LCBlbmMpIHtcbiAgcmV0dXJuIEtleVBhaXIuZnJvbVByaXZhdGUodGhpcywgcHJpdiwgZW5jKTtcbn07XG5cbkVDLnByb3RvdHlwZS5rZXlGcm9tUHVibGljID0gZnVuY3Rpb24ga2V5RnJvbVB1YmxpYyhwdWIsIGVuYykge1xuICByZXR1cm4gS2V5UGFpci5mcm9tUHVibGljKHRoaXMsIHB1YiwgZW5jKTtcbn07XG5cbkVDLnByb3RvdHlwZS5nZW5LZXlQYWlyID0gZnVuY3Rpb24gZ2VuS2V5UGFpcihvcHRpb25zKSB7XG4gIGlmICghb3B0aW9ucylcbiAgICBvcHRpb25zID0ge307XG5cbiAgLy8gSW5zdGFudGlhdGUgSG1hY19EUkJHXG4gIHZhciBkcmJnID0gbmV3IGVsbGlwdGljLmhtYWNEUkJHKHtcbiAgICBoYXNoOiB0aGlzLmhhc2gsXG4gICAgcGVyczogb3B0aW9ucy5wZXJzLFxuICAgIGVudHJvcHk6IG9wdGlvbnMuZW50cm9weSB8fCBlbGxpcHRpYy5yYW5kKHRoaXMuaGFzaC5obWFjU3RyZW5ndGgpLFxuICAgIG5vbmNlOiB0aGlzLm4udG9BcnJheSgpXG4gIH0pO1xuXG4gIHZhciBieXRlcyA9IHRoaXMubi5ieXRlTGVuZ3RoKCk7XG4gIHZhciBuczIgPSB0aGlzLm4uc3ViKG5ldyBibigyKSk7XG4gIGRvIHtcbiAgICB2YXIgcHJpdiA9IG5ldyBibihkcmJnLmdlbmVyYXRlKGJ5dGVzKSk7XG4gICAgaWYgKHByaXYuY21wKG5zMikgPiAwKVxuICAgICAgY29udGludWU7XG5cbiAgICBwcml2LmlhZGRuKDEpO1xuICAgIHJldHVybiB0aGlzLmtleUZyb21Qcml2YXRlKHByaXYpO1xuICB9IHdoaWxlICh0cnVlKTtcbn07XG5cbkVDLnByb3RvdHlwZS5fdHJ1bmNhdGVUb04gPSBmdW5jdGlvbiB0cnVuY2F0ZVRvTihtc2csIHRydW5jT25seSkge1xuICB2YXIgZGVsdGEgPSBtc2cuYnl0ZUxlbmd0aCgpICogOCAtIHRoaXMubi5iaXRMZW5ndGgoKTtcbiAgaWYgKGRlbHRhID4gMClcbiAgICBtc2cgPSBtc2cudXNocm4oZGVsdGEpO1xuICBpZiAoIXRydW5jT25seSAmJiBtc2cuY21wKHRoaXMubikgPj0gMClcbiAgICByZXR1cm4gbXNnLnN1Yih0aGlzLm4pO1xuICBlbHNlXG4gICAgcmV0dXJuIG1zZztcbn07XG5cbkVDLnByb3RvdHlwZS5zaWduID0gZnVuY3Rpb24gc2lnbihtc2csIGtleSwgZW5jLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgZW5jID09PSAnb2JqZWN0Jykge1xuICAgIG9wdGlvbnMgPSBlbmM7XG4gICAgZW5jID0gbnVsbDtcbiAgfVxuICBpZiAoIW9wdGlvbnMpXG4gICAgb3B0aW9ucyA9IHt9O1xuXG4gIGtleSA9IHRoaXMua2V5RnJvbVByaXZhdGUoa2V5LCBlbmMpO1xuICBtc2cgPSB0aGlzLl90cnVuY2F0ZVRvTihuZXcgYm4obXNnLCAxNikpO1xuXG4gIC8vIFplcm8tZXh0ZW5kIGtleSB0byBwcm92aWRlIGVub3VnaCBlbnRyb3B5XG4gIHZhciBieXRlcyA9IHRoaXMubi5ieXRlTGVuZ3RoKCk7XG4gIHZhciBia2V5ID0ga2V5LmdldFByaXZhdGUoKS50b0FycmF5KCk7XG4gIGZvciAodmFyIGkgPSBia2V5Lmxlbmd0aDsgaSA8IGJ5dGVzOyBpKyspXG4gICAgYmtleS51bnNoaWZ0KDApO1xuXG4gIC8vIFplcm8tZXh0ZW5kIG5vbmNlIHRvIGhhdmUgdGhlIHNhbWUgYnl0ZSBzaXplIGFzIE5cbiAgdmFyIG5vbmNlID0gbXNnLnRvQXJyYXkoKTtcbiAgZm9yICh2YXIgaSA9IG5vbmNlLmxlbmd0aDsgaSA8IGJ5dGVzOyBpKyspXG4gICAgbm9uY2UudW5zaGlmdCgwKTtcblxuICAvLyBJbnN0YW50aWF0ZSBIbWFjX0RSQkdcbiAgdmFyIGRyYmcgPSBuZXcgZWxsaXB0aWMuaG1hY0RSQkcoe1xuICAgIGhhc2g6IHRoaXMuaGFzaCxcbiAgICBlbnRyb3B5OiBia2V5LFxuICAgIG5vbmNlOiBub25jZVxuICB9KTtcblxuICAvLyBOdW1iZXIgb2YgYnl0ZXMgdG8gZ2VuZXJhdGVcbiAgdmFyIG5zMSA9IHRoaXMubi5zdWIobmV3IGJuKDEpKTtcbiAgZG8ge1xuICAgIHZhciBrID0gbmV3IGJuKGRyYmcuZ2VuZXJhdGUodGhpcy5uLmJ5dGVMZW5ndGgoKSkpO1xuICAgIGsgPSB0aGlzLl90cnVuY2F0ZVRvTihrLCB0cnVlKTtcbiAgICBpZiAoay5jbXBuKDEpIDw9IDAgfHwgay5jbXAobnMxKSA+PSAwKVxuICAgICAgY29udGludWU7XG5cbiAgICB2YXIga3AgPSB0aGlzLmcubXVsKGspO1xuICAgIGlmIChrcC5pc0luZmluaXR5KCkpXG4gICAgICBjb250aW51ZTtcblxuICAgIHZhciBrcFggPSBrcC5nZXRYKCk7XG4gICAgdmFyIHIgPSBrcFgudW1vZCh0aGlzLm4pO1xuICAgIGlmIChyLmNtcG4oMCkgPT09IDApXG4gICAgICBjb250aW51ZTtcblxuICAgIHZhciBzID0gay5pbnZtKHRoaXMubikubXVsKHIubXVsKGtleS5nZXRQcml2YXRlKCkpLmlhZGQobXNnKSk7XG4gICAgcyA9IHMudW1vZCh0aGlzLm4pO1xuICAgIGlmIChzLmNtcG4oMCkgPT09IDApXG4gICAgICBjb250aW51ZTtcblxuICAgIHZhciByZWNvdmVyeVBhcmFtID0gKGtwLmdldFkoKS5pc09kZCgpID8gMSA6IDApIHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChrcFguY21wKHIpICE9PSAwID8gMiA6IDApO1xuXG4gICAgLy8gVXNlIGNvbXBsZW1lbnQgb2YgYHNgLCBpZiBpdCBpcyA+IGBuIC8gMmBcbiAgICBpZiAob3B0aW9ucy5jYW5vbmljYWwgJiYgcy5jbXAodGhpcy5uaCkgPiAwKSB7XG4gICAgICBzID0gdGhpcy5uLnN1YihzKTtcbiAgICAgIHJlY292ZXJ5UGFyYW0gXj0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFNpZ25hdHVyZSh7IHI6IHIsIHM6IHMsIHJlY292ZXJ5UGFyYW06IHJlY292ZXJ5UGFyYW0gfSk7XG4gIH0gd2hpbGUgKHRydWUpO1xufTtcblxuRUMucHJvdG90eXBlLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtc2csIHNpZ25hdHVyZSwga2V5LCBlbmMpIHtcbiAgbXNnID0gdGhpcy5fdHJ1bmNhdGVUb04obmV3IGJuKG1zZywgMTYpKTtcbiAga2V5ID0gdGhpcy5rZXlGcm9tUHVibGljKGtleSwgZW5jKTtcbiAgc2lnbmF0dXJlID0gbmV3IFNpZ25hdHVyZShzaWduYXR1cmUsICdoZXgnKTtcblxuICAvLyBQZXJmb3JtIHByaW1pdGl2ZSB2YWx1ZXMgdmFsaWRhdGlvblxuICB2YXIgciA9IHNpZ25hdHVyZS5yO1xuICB2YXIgcyA9IHNpZ25hdHVyZS5zO1xuICBpZiAoci5jbXBuKDEpIDwgMCB8fCByLmNtcCh0aGlzLm4pID49IDApXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAocy5jbXBuKDEpIDwgMCB8fCBzLmNtcCh0aGlzLm4pID49IDApXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIFZhbGlkYXRlIHNpZ25hdHVyZVxuICB2YXIgc2ludiA9IHMuaW52bSh0aGlzLm4pO1xuICB2YXIgdTEgPSBzaW52Lm11bChtc2cpLnVtb2QodGhpcy5uKTtcbiAgdmFyIHUyID0gc2ludi5tdWwocikudW1vZCh0aGlzLm4pO1xuXG4gIHZhciBwID0gdGhpcy5nLm11bEFkZCh1MSwga2V5LmdldFB1YmxpYygpLCB1Mik7XG4gIGlmIChwLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgcmV0dXJuIHAuZ2V0WCgpLnVtb2QodGhpcy5uKS5jbXAocikgPT09IDA7XG59O1xuXG5FQy5wcm90b3R5cGUucmVjb3ZlclB1YktleSA9IGZ1bmN0aW9uKG1zZywgc2lnbmF0dXJlLCBqLCBlbmMpIHtcbiAgYXNzZXJ0KCgzICYgaikgPT09IGosICdUaGUgcmVjb3ZlcnkgcGFyYW0gaXMgbW9yZSB0aGFuIHR3byBiaXRzJyk7XG4gIHNpZ25hdHVyZSA9IG5ldyBTaWduYXR1cmUoc2lnbmF0dXJlLCBlbmMpO1xuXG4gIHZhciBuID0gdGhpcy5uO1xuICB2YXIgZSA9IG5ldyBibihtc2cpO1xuICB2YXIgciA9IHNpZ25hdHVyZS5yO1xuICB2YXIgcyA9IHNpZ25hdHVyZS5zO1xuXG4gIC8vIEEgc2V0IExTQiBzaWduaWZpZXMgdGhhdCB0aGUgeS1jb29yZGluYXRlIGlzIG9kZFxuICB2YXIgaXNZT2RkID0gaiAmIDE7XG4gIHZhciBpc1NlY29uZEtleSA9IGogPj4gMTtcbiAgaWYgKHIuY21wKHRoaXMuY3VydmUucC51bW9kKHRoaXMuY3VydmUubikpID49IDAgJiYgaXNTZWNvbmRLZXkpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZmluZCBzZW5jb25kIGtleSBjYW5kaW5hdGUnKTtcblxuICAvLyAxLjEuIExldCB4ID0gciArIGpuLlxuICBpZiAoaXNTZWNvbmRLZXkpXG4gICAgciA9IHRoaXMuY3VydmUucG9pbnRGcm9tWChyLmFkZCh0aGlzLmN1cnZlLm4pLCBpc1lPZGQpO1xuICBlbHNlXG4gICAgciA9IHRoaXMuY3VydmUucG9pbnRGcm9tWChyLCBpc1lPZGQpO1xuXG4gIHZhciBlTmVnID0gbi5zdWIoZSk7XG5cbiAgLy8gMS42LjEgQ29tcHV0ZSBRID0gcl4tMSAoc1IgLSAgZUcpXG4gIC8vICAgICAgICAgICAgICAgUSA9IHJeLTEgKHNSICsgLWVHKVxuICB2YXIgckludiA9IHNpZ25hdHVyZS5yLmludm0obik7XG4gIHJldHVybiByLm11bChzKS5hZGQodGhpcy5nLm11bChlTmVnKSkubXVsKHJJbnYpO1xufTtcblxuRUMucHJvdG90eXBlLmdldEtleVJlY292ZXJ5UGFyYW0gPSBmdW5jdGlvbihlLCBzaWduYXR1cmUsIFEsIGVuYykge1xuICBzaWduYXR1cmUgPSBuZXcgU2lnbmF0dXJlKHNpZ25hdHVyZSwgZW5jKTtcbiAgaWYgKHNpZ25hdHVyZS5yZWNvdmVyeVBhcmFtICE9PSBudWxsKVxuICAgIHJldHVybiBzaWduYXR1cmUucmVjb3ZlcnlQYXJhbTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgIHZhciBRcHJpbWUgPSB0aGlzLnJlY292ZXJQdWJLZXkoZSwgc2lnbmF0dXJlLCBpKTtcblxuICAgIGlmIChRcHJpbWUuZXEoUSkpXG4gICAgICByZXR1cm4gaTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBmaW5kIHZhbGlkIHJlY292ZXJ5IGZhY3RvcicpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGJuID0gcmVxdWlyZSgnYm4uanMnKTtcblxuZnVuY3Rpb24gS2V5UGFpcihlYywgb3B0aW9ucykge1xuICB0aGlzLmVjID0gZWM7XG4gIHRoaXMucHJpdiA9IG51bGw7XG4gIHRoaXMucHViID0gbnVsbDtcblxuICAvLyBLZXlQYWlyKGVjLCB7IHByaXY6IC4uLiwgcHViOiAuLi4gfSlcbiAgaWYgKG9wdGlvbnMucHJpdilcbiAgICB0aGlzLl9pbXBvcnRQcml2YXRlKG9wdGlvbnMucHJpdiwgb3B0aW9ucy5wcml2RW5jKTtcbiAgaWYgKG9wdGlvbnMucHViKVxuICAgIHRoaXMuX2ltcG9ydFB1YmxpYyhvcHRpb25zLnB1Yiwgb3B0aW9ucy5wdWJFbmMpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBLZXlQYWlyO1xuXG5LZXlQYWlyLmZyb21QdWJsaWMgPSBmdW5jdGlvbiBmcm9tUHVibGljKGVjLCBwdWIsIGVuYykge1xuICBpZiAocHViIGluc3RhbmNlb2YgS2V5UGFpcilcbiAgICByZXR1cm4gcHViO1xuXG4gIHJldHVybiBuZXcgS2V5UGFpcihlYywge1xuICAgIHB1YjogcHViLFxuICAgIHB1YkVuYzogZW5jXG4gIH0pO1xufTtcblxuS2V5UGFpci5mcm9tUHJpdmF0ZSA9IGZ1bmN0aW9uIGZyb21Qcml2YXRlKGVjLCBwcml2LCBlbmMpIHtcbiAgaWYgKHByaXYgaW5zdGFuY2VvZiBLZXlQYWlyKVxuICAgIHJldHVybiBwcml2O1xuXG4gIHJldHVybiBuZXcgS2V5UGFpcihlYywge1xuICAgIHByaXY6IHByaXYsXG4gICAgcHJpdkVuYzogZW5jXG4gIH0pO1xufTtcblxuS2V5UGFpci5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiB2YWxpZGF0ZSgpIHtcbiAgdmFyIHB1YiA9IHRoaXMuZ2V0UHVibGljKCk7XG5cbiAgaWYgKHB1Yi5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHsgcmVzdWx0OiBmYWxzZSwgcmVhc29uOiAnSW52YWxpZCBwdWJsaWMga2V5JyB9O1xuICBpZiAoIXB1Yi52YWxpZGF0ZSgpKVxuICAgIHJldHVybiB7IHJlc3VsdDogZmFsc2UsIHJlYXNvbjogJ1B1YmxpYyBrZXkgaXMgbm90IGEgcG9pbnQnIH07XG4gIGlmICghcHViLm11bCh0aGlzLmVjLmN1cnZlLm4pLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4geyByZXN1bHQ6IGZhbHNlLCByZWFzb246ICdQdWJsaWMga2V5ICogTiAhPSBPJyB9O1xuXG4gIHJldHVybiB7IHJlc3VsdDogdHJ1ZSwgcmVhc29uOiBudWxsIH07XG59O1xuXG5LZXlQYWlyLnByb3RvdHlwZS5nZXRQdWJsaWMgPSBmdW5jdGlvbiBnZXRQdWJsaWMoY29tcGFjdCwgZW5jKSB7XG4gIC8vIGNvbXBhY3QgaXMgb3B0aW9uYWwgYXJndW1lbnRcbiAgaWYgKHR5cGVvZiBjb21wYWN0ID09PSAnc3RyaW5nJykge1xuICAgIGVuYyA9IGNvbXBhY3Q7XG4gICAgY29tcGFjdCA9IG51bGw7XG4gIH1cblxuICBpZiAoIXRoaXMucHViKVxuICAgIHRoaXMucHViID0gdGhpcy5lYy5nLm11bCh0aGlzLnByaXYpO1xuXG4gIGlmICghZW5jKVxuICAgIHJldHVybiB0aGlzLnB1YjtcblxuICByZXR1cm4gdGhpcy5wdWIuZW5jb2RlKGVuYywgY29tcGFjdCk7XG59O1xuXG5LZXlQYWlyLnByb3RvdHlwZS5nZXRQcml2YXRlID0gZnVuY3Rpb24gZ2V0UHJpdmF0ZShlbmMpIHtcbiAgaWYgKGVuYyA9PT0gJ2hleCcpXG4gICAgcmV0dXJuIHRoaXMucHJpdi50b1N0cmluZygxNiwgMik7XG4gIGVsc2VcbiAgICByZXR1cm4gdGhpcy5wcml2O1xufTtcblxuS2V5UGFpci5wcm90b3R5cGUuX2ltcG9ydFByaXZhdGUgPSBmdW5jdGlvbiBfaW1wb3J0UHJpdmF0ZShrZXksIGVuYykge1xuICB0aGlzLnByaXYgPSBuZXcgYm4oa2V5LCBlbmMgfHwgMTYpO1xuXG4gIC8vIEVuc3VyZSB0aGF0IHRoZSBwcml2IHdvbid0IGJlIGJpZ2dlciB0aGFuIG4sIG90aGVyd2lzZSB3ZSBtYXkgZmFpbFxuICAvLyBpbiBmaXhlZCBtdWx0aXBsaWNhdGlvbiBtZXRob2RcbiAgdGhpcy5wcml2ID0gdGhpcy5wcml2LnVtb2QodGhpcy5lYy5jdXJ2ZS5uKTtcbn07XG5cbktleVBhaXIucHJvdG90eXBlLl9pbXBvcnRQdWJsaWMgPSBmdW5jdGlvbiBfaW1wb3J0UHVibGljKGtleSwgZW5jKSB7XG4gIGlmIChrZXkueCB8fCBrZXkueSkge1xuICAgIHRoaXMucHViID0gdGhpcy5lYy5jdXJ2ZS5wb2ludChrZXkueCwga2V5LnkpO1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLnB1YiA9IHRoaXMuZWMuY3VydmUuZGVjb2RlUG9pbnQoa2V5LCBlbmMpO1xufTtcblxuLy8gRUNESFxuS2V5UGFpci5wcm90b3R5cGUuZGVyaXZlID0gZnVuY3Rpb24gZGVyaXZlKHB1Yikge1xuICByZXR1cm4gcHViLm11bCh0aGlzLnByaXYpLmdldFgoKTtcbn07XG5cbi8vIEVDRFNBXG5LZXlQYWlyLnByb3RvdHlwZS5zaWduID0gZnVuY3Rpb24gc2lnbihtc2csIGVuYywgb3B0aW9ucykge1xuICByZXR1cm4gdGhpcy5lYy5zaWduKG1zZywgdGhpcywgZW5jLCBvcHRpb25zKTtcbn07XG5cbktleVBhaXIucHJvdG90eXBlLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtc2csIHNpZ25hdHVyZSkge1xuICByZXR1cm4gdGhpcy5lYy52ZXJpZnkobXNnLCBzaWduYXR1cmUsIHRoaXMpO1xufTtcblxuS2V5UGFpci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QoKSB7XG4gIHJldHVybiAnPEtleSBwcml2OiAnICsgKHRoaXMucHJpdiAmJiB0aGlzLnByaXYudG9TdHJpbmcoMTYsIDIpKSArXG4gICAgICAgICAnIHB1YjogJyArICh0aGlzLnB1YiAmJiB0aGlzLnB1Yi5pbnNwZWN0KCkpICsgJyA+Jztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBibiA9IHJlcXVpcmUoJ2JuLmpzJyk7XG5cbnZhciBlbGxpcHRpYyA9IHJlcXVpcmUoJy4uLy4uL2VsbGlwdGljJyk7XG52YXIgdXRpbHMgPSBlbGxpcHRpYy51dGlscztcbnZhciBhc3NlcnQgPSB1dGlscy5hc3NlcnQ7XG5cbmZ1bmN0aW9uIFNpZ25hdHVyZShvcHRpb25zLCBlbmMpIHtcbiAgaWYgKG9wdGlvbnMgaW5zdGFuY2VvZiBTaWduYXR1cmUpXG4gICAgcmV0dXJuIG9wdGlvbnM7XG5cbiAgaWYgKHRoaXMuX2ltcG9ydERFUihvcHRpb25zLCBlbmMpKVxuICAgIHJldHVybjtcblxuICBhc3NlcnQob3B0aW9ucy5yICYmIG9wdGlvbnMucywgJ1NpZ25hdHVyZSB3aXRob3V0IHIgb3IgcycpO1xuICB0aGlzLnIgPSBuZXcgYm4ob3B0aW9ucy5yLCAxNik7XG4gIHRoaXMucyA9IG5ldyBibihvcHRpb25zLnMsIDE2KTtcbiAgaWYgKG9wdGlvbnMucmVjb3ZlcnlQYXJhbSAhPT0gbnVsbClcbiAgICB0aGlzLnJlY292ZXJ5UGFyYW0gPSBvcHRpb25zLnJlY292ZXJ5UGFyYW07XG4gIGVsc2VcbiAgICB0aGlzLnJlY292ZXJ5UGFyYW0gPSBudWxsO1xufVxubW9kdWxlLmV4cG9ydHMgPSBTaWduYXR1cmU7XG5cbmZ1bmN0aW9uIFBvc2l0aW9uKCkge1xuICB0aGlzLnBsYWNlID0gMDtcbn1cblxuZnVuY3Rpb24gZ2V0TGVuZ3RoKGJ1ZiwgcCkge1xuICB2YXIgaW5pdGlhbCA9IGJ1ZltwLnBsYWNlKytdO1xuICBpZiAoIShpbml0aWFsICYgMHg4MCkpIHtcbiAgICByZXR1cm4gaW5pdGlhbDtcbiAgfVxuICB2YXIgb2N0ZXRMZW4gPSBpbml0aWFsICYgMHhmO1xuICB2YXIgdmFsID0gMDtcbiAgZm9yICh2YXIgaSA9IDAsIG9mZiA9IHAucGxhY2U7IGkgPCBvY3RldExlbjsgaSsrLCBvZmYrKykge1xuICAgIHZhbCA8PD0gODtcbiAgICB2YWwgfD0gYnVmW29mZl07XG4gIH1cbiAgcC5wbGFjZSA9IG9mZjtcbiAgcmV0dXJuIHZhbDtcbn1cblxuZnVuY3Rpb24gcm1QYWRkaW5nKGJ1Zikge1xuICB2YXIgaSA9IDA7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoIC0gMTtcbiAgd2hpbGUgKCFidWZbaV0gJiYgIShidWZbaSArIDFdICYgMHg4MCkgJiYgaSA8IGxlbikge1xuICAgIGkrKztcbiAgfVxuICBpZiAoaSA9PT0gMCkge1xuICAgIHJldHVybiBidWY7XG4gIH1cbiAgcmV0dXJuIGJ1Zi5zbGljZShpKTtcbn1cblxuU2lnbmF0dXJlLnByb3RvdHlwZS5faW1wb3J0REVSID0gZnVuY3Rpb24gX2ltcG9ydERFUihkYXRhLCBlbmMpIHtcbiAgZGF0YSA9IHV0aWxzLnRvQXJyYXkoZGF0YSwgZW5jKTtcbiAgdmFyIHAgPSBuZXcgUG9zaXRpb24oKTtcbiAgaWYgKGRhdGFbcC5wbGFjZSsrXSAhPT0gMHgzMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbGVuID0gZ2V0TGVuZ3RoKGRhdGEsIHApO1xuICBpZiAoKGxlbiArIHAucGxhY2UpICE9PSBkYXRhLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZGF0YVtwLnBsYWNlKytdICE9PSAweDAyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBybGVuID0gZ2V0TGVuZ3RoKGRhdGEsIHApO1xuICB2YXIgciA9IGRhdGEuc2xpY2UocC5wbGFjZSwgcmxlbiArIHAucGxhY2UpO1xuICBwLnBsYWNlICs9IHJsZW47XG4gIGlmIChkYXRhW3AucGxhY2UrK10gIT09IDB4MDIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHNsZW4gPSBnZXRMZW5ndGgoZGF0YSwgcCk7XG4gIGlmIChkYXRhLmxlbmd0aCAhPT0gc2xlbiArIHAucGxhY2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHMgPSBkYXRhLnNsaWNlKHAucGxhY2UsIHNsZW4gKyBwLnBsYWNlKTtcbiAgaWYgKHJbMF0gPT09IDAgJiYgKHJbMV0gJiAweDgwKSkge1xuICAgIHIgPSByLnNsaWNlKDEpO1xuICB9XG4gIGlmIChzWzBdID09PSAwICYmIChzWzFdICYgMHg4MCkpIHtcbiAgICBzID0gcy5zbGljZSgxKTtcbiAgfVxuXG4gIHRoaXMuciA9IG5ldyBibihyKTtcbiAgdGhpcy5zID0gbmV3IGJuKHMpO1xuICB0aGlzLnJlY292ZXJ5UGFyYW0gPSBudWxsO1xuXG4gIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gY29uc3RydWN0TGVuZ3RoKGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPCAweDgwKSB7XG4gICAgYXJyLnB1c2gobGVuKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG9jdGV0cyA9IDEgKyAoTWF0aC5sb2cobGVuKSAvIE1hdGguTE4yID4+PiAzKTtcbiAgYXJyLnB1c2gob2N0ZXRzIHwgMHg4MCk7XG4gIHdoaWxlICgtLW9jdGV0cykge1xuICAgIGFyci5wdXNoKChsZW4gPj4+IChvY3RldHMgPDwgMykpICYgMHhmZik7XG4gIH1cbiAgYXJyLnB1c2gobGVuKTtcbn1cblxuU2lnbmF0dXJlLnByb3RvdHlwZS50b0RFUiA9IGZ1bmN0aW9uIHRvREVSKGVuYykge1xuICB2YXIgciA9IHRoaXMuci50b0FycmF5KCk7XG4gIHZhciBzID0gdGhpcy5zLnRvQXJyYXkoKTtcblxuICAvLyBQYWQgdmFsdWVzXG4gIGlmIChyWzBdICYgMHg4MClcbiAgICByID0gWyAwIF0uY29uY2F0KHIpO1xuICAvLyBQYWQgdmFsdWVzXG4gIGlmIChzWzBdICYgMHg4MClcbiAgICBzID0gWyAwIF0uY29uY2F0KHMpO1xuXG4gIHIgPSBybVBhZGRpbmcocik7XG4gIHMgPSBybVBhZGRpbmcocyk7XG5cbiAgd2hpbGUgKCFzWzBdICYmICEoc1sxXSAmIDB4ODApKSB7XG4gICAgcyA9IHMuc2xpY2UoMSk7XG4gIH1cbiAgdmFyIGFyciA9IFsgMHgwMiBdO1xuICBjb25zdHJ1Y3RMZW5ndGgoYXJyLCByLmxlbmd0aCk7XG4gIGFyciA9IGFyci5jb25jYXQocik7XG4gIGFyci5wdXNoKDB4MDIpO1xuICBjb25zdHJ1Y3RMZW5ndGgoYXJyLCBzLmxlbmd0aCk7XG4gIHZhciBiYWNrSGFsZiA9IGFyci5jb25jYXQocyk7XG4gIHZhciByZXMgPSBbIDB4MzAgXTtcbiAgY29uc3RydWN0TGVuZ3RoKHJlcywgYmFja0hhbGYubGVuZ3RoKTtcbiAgcmVzID0gcmVzLmNvbmNhdChiYWNrSGFsZik7XG4gIHJldHVybiB1dGlscy5lbmNvZGUocmVzLCBlbmMpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGhhc2ggPSByZXF1aXJlKCdoYXNoLmpzJyk7XG52YXIgZWxsaXB0aWMgPSByZXF1aXJlKCcuLi8uLi9lbGxpcHRpYycpO1xudmFyIHV0aWxzID0gZWxsaXB0aWMudXRpbHM7XG52YXIgYXNzZXJ0ID0gdXRpbHMuYXNzZXJ0O1xudmFyIHBhcnNlQnl0ZXMgPSB1dGlscy5wYXJzZUJ5dGVzO1xudmFyIEtleVBhaXIgPSByZXF1aXJlKCcuL2tleScpO1xudmFyIFNpZ25hdHVyZSA9IHJlcXVpcmUoJy4vc2lnbmF0dXJlJyk7XG5cbmZ1bmN0aW9uIEVERFNBKGN1cnZlKSB7XG4gIGFzc2VydChjdXJ2ZSA9PT0gJ2VkMjU1MTknLCAnb25seSB0ZXN0ZWQgd2l0aCBlZDI1NTE5IHNvIGZhcicpO1xuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBFRERTQSkpXG4gICAgcmV0dXJuIG5ldyBFRERTQShjdXJ2ZSk7XG5cbiAgdmFyIGN1cnZlID0gZWxsaXB0aWMuY3VydmVzW2N1cnZlXS5jdXJ2ZTtcbiAgdGhpcy5jdXJ2ZSA9IGN1cnZlO1xuICB0aGlzLmcgPSBjdXJ2ZS5nO1xuICB0aGlzLmcucHJlY29tcHV0ZShjdXJ2ZS5uLmJpdExlbmd0aCgpICsgMSk7XG5cbiAgdGhpcy5wb2ludENsYXNzID0gY3VydmUucG9pbnQoKS5jb25zdHJ1Y3RvcjtcbiAgdGhpcy5lbmNvZGluZ0xlbmd0aCA9IE1hdGguY2VpbChjdXJ2ZS5uLmJpdExlbmd0aCgpIC8gOCk7XG4gIHRoaXMuaGFzaCA9IGhhc2guc2hhNTEyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEVERFNBO1xuXG4vKipcbiogQHBhcmFtIHtBcnJheXxTdHJpbmd9IG1lc3NhZ2UgLSBtZXNzYWdlIGJ5dGVzXG4qIEBwYXJhbSB7QXJyYXl8U3RyaW5nfEtleVBhaXJ9IHNlY3JldCAtIHNlY3JldCBieXRlcyBvciBhIGtleXBhaXJcbiogQHJldHVybnMge1NpZ25hdHVyZX0gLSBzaWduYXR1cmVcbiovXG5FRERTQS5wcm90b3R5cGUuc2lnbiA9IGZ1bmN0aW9uIHNpZ24obWVzc2FnZSwgc2VjcmV0KSB7XG4gIG1lc3NhZ2UgPSBwYXJzZUJ5dGVzKG1lc3NhZ2UpO1xuICB2YXIga2V5ID0gdGhpcy5rZXlGcm9tU2VjcmV0KHNlY3JldCk7XG4gIHZhciByID0gdGhpcy5oYXNoSW50KGtleS5tZXNzYWdlUHJlZml4KCksIG1lc3NhZ2UpO1xuICB2YXIgUiA9IHRoaXMuZy5tdWwocik7XG4gIHZhciBSZW5jb2RlZCA9IHRoaXMuZW5jb2RlUG9pbnQoUik7XG4gIHZhciBzXyA9IHRoaXMuaGFzaEludChSZW5jb2RlZCwga2V5LnB1YkJ5dGVzKCksIG1lc3NhZ2UpXG4gICAgICAgICAgICAgICAubXVsKGtleS5wcml2KCkpO1xuICB2YXIgUyA9IHIuYWRkKHNfKS51bW9kKHRoaXMuY3VydmUubik7XG4gIHJldHVybiB0aGlzLm1ha2VTaWduYXR1cmUoeyBSOiBSLCBTOiBTLCBSZW5jb2RlZDogUmVuY29kZWQgfSk7XG59O1xuXG4vKipcbiogQHBhcmFtIHtBcnJheX0gbWVzc2FnZSAtIG1lc3NhZ2UgYnl0ZXNcbiogQHBhcmFtIHtBcnJheXxTdHJpbmd8U2lnbmF0dXJlfSBzaWcgLSBzaWcgYnl0ZXNcbiogQHBhcmFtIHtBcnJheXxTdHJpbmd8UG9pbnR8S2V5UGFpcn0gcHViIC0gcHVibGljIGtleVxuKiBAcmV0dXJucyB7Qm9vbGVhbn0gLSB0cnVlIGlmIHB1YmxpYyBrZXkgbWF0Y2hlcyBzaWcgb2YgbWVzc2FnZVxuKi9cbkVERFNBLnByb3RvdHlwZS52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSwgc2lnLCBwdWIpIHtcbiAgbWVzc2FnZSA9IHBhcnNlQnl0ZXMobWVzc2FnZSk7XG4gIHNpZyA9IHRoaXMubWFrZVNpZ25hdHVyZShzaWcpO1xuICB2YXIga2V5ID0gdGhpcy5rZXlGcm9tUHVibGljKHB1Yik7XG4gIHZhciBoID0gdGhpcy5oYXNoSW50KHNpZy5SZW5jb2RlZCgpLCBrZXkucHViQnl0ZXMoKSwgbWVzc2FnZSk7XG4gIHZhciBTRyA9IHRoaXMuZy5tdWwoc2lnLlMoKSk7XG4gIHZhciBScGx1c0FoID0gc2lnLlIoKS5hZGQoa2V5LnB1YigpLm11bChoKSk7XG4gIHJldHVybiBScGx1c0FoLmVxKFNHKTtcbn07XG5cbkVERFNBLnByb3RvdHlwZS5oYXNoSW50ID0gZnVuY3Rpb24gaGFzaEludCgpIHtcbiAgdmFyIGhhc2ggPSB0aGlzLmhhc2goKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXG4gICAgaGFzaC51cGRhdGUoYXJndW1lbnRzW2ldKTtcbiAgcmV0dXJuIHV0aWxzLmludEZyb21MRShoYXNoLmRpZ2VzdCgpKS51bW9kKHRoaXMuY3VydmUubik7XG59O1xuXG5FRERTQS5wcm90b3R5cGUua2V5RnJvbVB1YmxpYyA9IGZ1bmN0aW9uIGtleUZyb21QdWJsaWMocHViKSB7XG4gIHJldHVybiBLZXlQYWlyLmZyb21QdWJsaWModGhpcywgcHViKTtcbn07XG5cbkVERFNBLnByb3RvdHlwZS5rZXlGcm9tU2VjcmV0ID0gZnVuY3Rpb24ga2V5RnJvbVNlY3JldChzZWNyZXQpIHtcbiAgcmV0dXJuIEtleVBhaXIuZnJvbVNlY3JldCh0aGlzLCBzZWNyZXQpO1xufTtcblxuRUREU0EucHJvdG90eXBlLm1ha2VTaWduYXR1cmUgPSBmdW5jdGlvbiBtYWtlU2lnbmF0dXJlKHNpZykge1xuICBpZiAoc2lnIGluc3RhbmNlb2YgU2lnbmF0dXJlKVxuICAgIHJldHVybiBzaWc7XG4gIHJldHVybiBuZXcgU2lnbmF0dXJlKHRoaXMsIHNpZyk7XG59O1xuXG4vKipcbiogKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtam9zZWZzc29uLWVkZHNhLWVkMjU1MTktMDMjc2VjdGlvbi01LjJcbipcbiogRUREU0EgZGVmaW5lcyBtZXRob2RzIGZvciBlbmNvZGluZyBhbmQgZGVjb2RpbmcgcG9pbnRzIGFuZCBpbnRlZ2Vycy4gVGhlc2UgYXJlXG4qIGhlbHBlciBjb252ZW5pZW5jZSBtZXRob2RzLCB0aGF0IHBhc3MgYWxvbmcgdG8gdXRpbGl0eSBmdW5jdGlvbnMgaW1wbGllZFxuKiBwYXJhbWV0ZXJzLlxuKlxuKi9cbkVERFNBLnByb3RvdHlwZS5lbmNvZGVQb2ludCA9IGZ1bmN0aW9uIGVuY29kZVBvaW50KHBvaW50KSB7XG4gIHZhciBlbmMgPSBwb2ludC5nZXRZKCkudG9BcnJheSgnbGUnLCB0aGlzLmVuY29kaW5nTGVuZ3RoKTtcbiAgZW5jW3RoaXMuZW5jb2RpbmdMZW5ndGggLSAxXSB8PSBwb2ludC5nZXRYKCkuaXNPZGQoKSA/IDB4ODAgOiAwO1xuICByZXR1cm4gZW5jO1xufTtcblxuRUREU0EucHJvdG90eXBlLmRlY29kZVBvaW50ID0gZnVuY3Rpb24gZGVjb2RlUG9pbnQoYnl0ZXMpIHtcbiAgYnl0ZXMgPSB1dGlscy5wYXJzZUJ5dGVzKGJ5dGVzKTtcblxuICB2YXIgbGFzdEl4ID0gYnl0ZXMubGVuZ3RoIC0gMTtcbiAgdmFyIG5vcm1lZCA9IGJ5dGVzLnNsaWNlKDAsIGxhc3RJeCkuY29uY2F0KGJ5dGVzW2xhc3RJeF0gJiB+MHg4MCk7XG4gIHZhciB4SXNPZGQgPSAoYnl0ZXNbbGFzdEl4XSAmIDB4ODApICE9PSAwO1xuXG4gIHZhciB5ID0gdXRpbHMuaW50RnJvbUxFKG5vcm1lZCk7XG4gIHJldHVybiB0aGlzLmN1cnZlLnBvaW50RnJvbVkoeSwgeElzT2RkKTtcbn07XG5cbkVERFNBLnByb3RvdHlwZS5lbmNvZGVJbnQgPSBmdW5jdGlvbiBlbmNvZGVJbnQobnVtKSB7XG4gIHJldHVybiBudW0udG9BcnJheSgnbGUnLCB0aGlzLmVuY29kaW5nTGVuZ3RoKTtcbn07XG5cbkVERFNBLnByb3RvdHlwZS5kZWNvZGVJbnQgPSBmdW5jdGlvbiBkZWNvZGVJbnQoYnl0ZXMpIHtcbiAgcmV0dXJuIHV0aWxzLmludEZyb21MRShieXRlcyk7XG59O1xuXG5FRERTQS5wcm90b3R5cGUuaXNQb2ludCA9IGZ1bmN0aW9uIGlzUG9pbnQodmFsKSB7XG4gIHJldHVybiB2YWwgaW5zdGFuY2VvZiB0aGlzLnBvaW50Q2xhc3M7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZWxsaXB0aWMgPSByZXF1aXJlKCcuLi8uLi9lbGxpcHRpYycpO1xudmFyIHV0aWxzID0gZWxsaXB0aWMudXRpbHM7XG52YXIgYXNzZXJ0ID0gdXRpbHMuYXNzZXJ0O1xudmFyIHBhcnNlQnl0ZXMgPSB1dGlscy5wYXJzZUJ5dGVzO1xudmFyIGNhY2hlZFByb3BlcnR5ID0gdXRpbHMuY2FjaGVkUHJvcGVydHk7XG5cbi8qKlxuKiBAcGFyYW0ge0VERFNBfSBlZGRzYSAtIGluc3RhbmNlXG4qIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBwdWJsaWMvcHJpdmF0ZSBrZXkgcGFyYW1ldGVyc1xuKlxuKiBAcGFyYW0ge0FycmF5PEJ5dGU+fSBbcGFyYW1zLnNlY3JldF0gLSBzZWNyZXQgc2VlZCBieXRlc1xuKiBAcGFyYW0ge1BvaW50fSBbcGFyYW1zLnB1Yl0gLSBwdWJsaWMga2V5IHBvaW50IChha2EgYEFgIGluIGVkZHNhIHRlcm1zKVxuKiBAcGFyYW0ge0FycmF5PEJ5dGU+fSBbcGFyYW1zLnB1Yl0gLSBwdWJsaWMga2V5IHBvaW50IGVuY29kZWQgYXMgYnl0ZXNcbipcbiovXG5mdW5jdGlvbiBLZXlQYWlyKGVkZHNhLCBwYXJhbXMpIHtcbiAgdGhpcy5lZGRzYSA9IGVkZHNhO1xuICB0aGlzLl9zZWNyZXQgPSBwYXJzZUJ5dGVzKHBhcmFtcy5zZWNyZXQpO1xuICBpZiAoZWRkc2EuaXNQb2ludChwYXJhbXMucHViKSlcbiAgICB0aGlzLl9wdWIgPSBwYXJhbXMucHViO1xuICBlbHNlXG4gICAgdGhpcy5fcHViQnl0ZXMgPSBwYXJzZUJ5dGVzKHBhcmFtcy5wdWIpO1xufVxuXG5LZXlQYWlyLmZyb21QdWJsaWMgPSBmdW5jdGlvbiBmcm9tUHVibGljKGVkZHNhLCBwdWIpIHtcbiAgaWYgKHB1YiBpbnN0YW5jZW9mIEtleVBhaXIpXG4gICAgcmV0dXJuIHB1YjtcbiAgcmV0dXJuIG5ldyBLZXlQYWlyKGVkZHNhLCB7IHB1YjogcHViIH0pO1xufTtcblxuS2V5UGFpci5mcm9tU2VjcmV0ID0gZnVuY3Rpb24gZnJvbVNlY3JldChlZGRzYSwgc2VjcmV0KSB7XG4gIGlmIChzZWNyZXQgaW5zdGFuY2VvZiBLZXlQYWlyKVxuICAgIHJldHVybiBzZWNyZXQ7XG4gIHJldHVybiBuZXcgS2V5UGFpcihlZGRzYSwgeyBzZWNyZXQ6IHNlY3JldCB9KTtcbn07XG5cbktleVBhaXIucHJvdG90eXBlLnNlY3JldCA9IGZ1bmN0aW9uIHNlY3JldCgpIHtcbiAgcmV0dXJuIHRoaXMuX3NlY3JldDtcbn07XG5cbmNhY2hlZFByb3BlcnR5KEtleVBhaXIsIGZ1bmN0aW9uIHB1YkJ5dGVzKCkge1xuICByZXR1cm4gdGhpcy5lZGRzYS5lbmNvZGVQb2ludCh0aGlzLnB1YigpKTtcbn0pO1xuXG5jYWNoZWRQcm9wZXJ0eShLZXlQYWlyLCBmdW5jdGlvbiBwdWIoKSB7XG4gIGlmICh0aGlzLl9wdWJCeXRlcylcbiAgICByZXR1cm4gdGhpcy5lZGRzYS5kZWNvZGVQb2ludCh0aGlzLl9wdWJCeXRlcyk7XG4gIHJldHVybiB0aGlzLmVkZHNhLmcubXVsKHRoaXMucHJpdigpKTtcbn0pO1xuXG5jYWNoZWRQcm9wZXJ0eShLZXlQYWlyLCBmdW5jdGlvbiBwcml2Qnl0ZXMoKSB7XG4gIHZhciBlZGRzYSA9IHRoaXMuZWRkc2E7XG4gIHZhciBoYXNoID0gdGhpcy5oYXNoKCk7XG4gIHZhciBsYXN0SXggPSBlZGRzYS5lbmNvZGluZ0xlbmd0aCAtIDE7XG5cbiAgdmFyIGEgPSBoYXNoLnNsaWNlKDAsIGVkZHNhLmVuY29kaW5nTGVuZ3RoKTtcbiAgYVswXSAmPSAyNDg7XG4gIGFbbGFzdEl4XSAmPSAxMjc7XG4gIGFbbGFzdEl4XSB8PSA2NDtcblxuICByZXR1cm4gYTtcbn0pO1xuXG5jYWNoZWRQcm9wZXJ0eShLZXlQYWlyLCBmdW5jdGlvbiBwcml2KCkge1xuICByZXR1cm4gdGhpcy5lZGRzYS5kZWNvZGVJbnQodGhpcy5wcml2Qnl0ZXMoKSk7XG59KTtcblxuY2FjaGVkUHJvcGVydHkoS2V5UGFpciwgZnVuY3Rpb24gaGFzaCgpIHtcbiAgcmV0dXJuIHRoaXMuZWRkc2EuaGFzaCgpLnVwZGF0ZSh0aGlzLnNlY3JldCgpKS5kaWdlc3QoKTtcbn0pO1xuXG5jYWNoZWRQcm9wZXJ0eShLZXlQYWlyLCBmdW5jdGlvbiBtZXNzYWdlUHJlZml4KCkge1xuICByZXR1cm4gdGhpcy5oYXNoKCkuc2xpY2UodGhpcy5lZGRzYS5lbmNvZGluZ0xlbmd0aCk7XG59KTtcblxuS2V5UGFpci5wcm90b3R5cGUuc2lnbiA9IGZ1bmN0aW9uIHNpZ24obWVzc2FnZSkge1xuICBhc3NlcnQodGhpcy5fc2VjcmV0LCAnS2V5UGFpciBjYW4gb25seSB2ZXJpZnknKTtcbiAgcmV0dXJuIHRoaXMuZWRkc2Euc2lnbihtZXNzYWdlLCB0aGlzKTtcbn07XG5cbktleVBhaXIucHJvdG90eXBlLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlLCBzaWcpIHtcbiAgcmV0dXJuIHRoaXMuZWRkc2EudmVyaWZ5KG1lc3NhZ2UsIHNpZywgdGhpcyk7XG59O1xuXG5LZXlQYWlyLnByb3RvdHlwZS5nZXRTZWNyZXQgPSBmdW5jdGlvbiBnZXRTZWNyZXQoZW5jKSB7XG4gIGFzc2VydCh0aGlzLl9zZWNyZXQsICdLZXlQYWlyIGlzIHB1YmxpYyBvbmx5Jyk7XG4gIHJldHVybiB1dGlscy5lbmNvZGUodGhpcy5zZWNyZXQoKSwgZW5jKTtcbn07XG5cbktleVBhaXIucHJvdG90eXBlLmdldFB1YmxpYyA9IGZ1bmN0aW9uIGdldFB1YmxpYyhlbmMpIHtcbiAgcmV0dXJuIHV0aWxzLmVuY29kZSh0aGlzLnB1YkJ5dGVzKCksIGVuYyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEtleVBhaXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBibiA9IHJlcXVpcmUoJ2JuLmpzJyk7XG52YXIgZWxsaXB0aWMgPSByZXF1aXJlKCcuLi8uLi9lbGxpcHRpYycpO1xudmFyIHV0aWxzID0gZWxsaXB0aWMudXRpbHM7XG52YXIgYXNzZXJ0ID0gdXRpbHMuYXNzZXJ0O1xudmFyIGNhY2hlZFByb3BlcnR5ID0gdXRpbHMuY2FjaGVkUHJvcGVydHk7XG52YXIgcGFyc2VCeXRlcyA9IHV0aWxzLnBhcnNlQnl0ZXM7XG5cbi8qKlxuKiBAcGFyYW0ge0VERFNBfSBlZGRzYSAtIGVkZHNhIGluc3RhbmNlXG4qIEBwYXJhbSB7QXJyYXk8Qnl0ZXM+fE9iamVjdH0gc2lnIC1cbiogQHBhcmFtIHtBcnJheTxCeXRlcz58UG9pbnR9IFtzaWcuUl0gLSBSIHBvaW50IGFzIFBvaW50IG9yIGJ5dGVzXG4qIEBwYXJhbSB7QXJyYXk8Qnl0ZXM+fGJufSBbc2lnLlNdIC0gUyBzY2FsYXIgYXMgYm4gb3IgYnl0ZXNcbiogQHBhcmFtIHtBcnJheTxCeXRlcz59IFtzaWcuUmVuY29kZWRdIC0gUiBwb2ludCBlbmNvZGVkXG4qIEBwYXJhbSB7QXJyYXk8Qnl0ZXM+fSBbc2lnLlNlbmNvZGVkXSAtIFMgc2NhbGFyIGVuY29kZWRcbiovXG5mdW5jdGlvbiBTaWduYXR1cmUoZWRkc2EsIHNpZykge1xuICB0aGlzLmVkZHNhID0gZWRkc2E7XG5cbiAgaWYgKHR5cGVvZiBzaWcgIT09ICdvYmplY3QnKVxuICAgIHNpZyA9IHBhcnNlQnl0ZXMoc2lnKTtcblxuICBpZiAoQXJyYXkuaXNBcnJheShzaWcpKSB7XG4gICAgc2lnID0ge1xuICAgICAgUjogc2lnLnNsaWNlKDAsIGVkZHNhLmVuY29kaW5nTGVuZ3RoKSxcbiAgICAgIFM6IHNpZy5zbGljZShlZGRzYS5lbmNvZGluZ0xlbmd0aClcbiAgICB9O1xuICB9XG5cbiAgYXNzZXJ0KHNpZy5SICYmIHNpZy5TLCAnU2lnbmF0dXJlIHdpdGhvdXQgUiBvciBTJyk7XG5cbiAgaWYgKGVkZHNhLmlzUG9pbnQoc2lnLlIpKVxuICAgIHRoaXMuX1IgPSBzaWcuUjtcbiAgaWYgKHNpZy5TIGluc3RhbmNlb2YgYm4pXG4gICAgdGhpcy5fUyA9IHNpZy5TO1xuXG4gIHRoaXMuX1JlbmNvZGVkID0gQXJyYXkuaXNBcnJheShzaWcuUikgPyBzaWcuUiA6IHNpZy5SZW5jb2RlZDtcbiAgdGhpcy5fU2VuY29kZWQgPSBBcnJheS5pc0FycmF5KHNpZy5TKSA/IHNpZy5TIDogc2lnLlNlbmNvZGVkO1xufVxuXG5jYWNoZWRQcm9wZXJ0eShTaWduYXR1cmUsIGZ1bmN0aW9uIFMoKSB7XG4gIHJldHVybiB0aGlzLmVkZHNhLmRlY29kZUludCh0aGlzLlNlbmNvZGVkKCkpO1xufSk7XG5cbmNhY2hlZFByb3BlcnR5KFNpZ25hdHVyZSwgZnVuY3Rpb24gUigpIHtcbiAgcmV0dXJuIHRoaXMuZWRkc2EuZGVjb2RlUG9pbnQodGhpcy5SZW5jb2RlZCgpKTtcbn0pO1xuXG5jYWNoZWRQcm9wZXJ0eShTaWduYXR1cmUsIGZ1bmN0aW9uIFJlbmNvZGVkKCkge1xuICByZXR1cm4gdGhpcy5lZGRzYS5lbmNvZGVQb2ludCh0aGlzLlIoKSk7XG59KTtcblxuY2FjaGVkUHJvcGVydHkoU2lnbmF0dXJlLCBmdW5jdGlvbiBTZW5jb2RlZCgpIHtcbiAgcmV0dXJuIHRoaXMuZWRkc2EuZW5jb2RlSW50KHRoaXMuUygpKTtcbn0pO1xuXG5TaWduYXR1cmUucHJvdG90eXBlLnRvQnl0ZXMgPSBmdW5jdGlvbiB0b0J5dGVzKCkge1xuICByZXR1cm4gdGhpcy5SZW5jb2RlZCgpLmNvbmNhdCh0aGlzLlNlbmNvZGVkKCkpO1xufTtcblxuU2lnbmF0dXJlLnByb3RvdHlwZS50b0hleCA9IGZ1bmN0aW9uIHRvSGV4KCkge1xuICByZXR1cm4gdXRpbHMuZW5jb2RlKHRoaXMudG9CeXRlcygpLCAnaGV4JykudG9VcHBlckNhc2UoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU2lnbmF0dXJlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzaCA9IHJlcXVpcmUoJ2hhc2guanMnKTtcbnZhciBlbGxpcHRpYyA9IHJlcXVpcmUoJy4uL2VsbGlwdGljJyk7XG52YXIgdXRpbHMgPSBlbGxpcHRpYy51dGlscztcbnZhciBhc3NlcnQgPSB1dGlscy5hc3NlcnQ7XG5cbmZ1bmN0aW9uIEhtYWNEUkJHKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEhtYWNEUkJHKSlcbiAgICByZXR1cm4gbmV3IEhtYWNEUkJHKG9wdGlvbnMpO1xuICB0aGlzLmhhc2ggPSBvcHRpb25zLmhhc2g7XG4gIHRoaXMucHJlZFJlc2lzdCA9ICEhb3B0aW9ucy5wcmVkUmVzaXN0O1xuXG4gIHRoaXMub3V0TGVuID0gdGhpcy5oYXNoLm91dFNpemU7XG4gIHRoaXMubWluRW50cm9weSA9IG9wdGlvbnMubWluRW50cm9weSB8fCB0aGlzLmhhc2guaG1hY1N0cmVuZ3RoO1xuXG4gIHRoaXMucmVzZWVkID0gbnVsbDtcbiAgdGhpcy5yZXNlZWRJbnRlcnZhbCA9IG51bGw7XG4gIHRoaXMuSyA9IG51bGw7XG4gIHRoaXMuViA9IG51bGw7XG5cbiAgdmFyIGVudHJvcHkgPSB1dGlscy50b0FycmF5KG9wdGlvbnMuZW50cm9weSwgb3B0aW9ucy5lbnRyb3B5RW5jKTtcbiAgdmFyIG5vbmNlID0gdXRpbHMudG9BcnJheShvcHRpb25zLm5vbmNlLCBvcHRpb25zLm5vbmNlRW5jKTtcbiAgdmFyIHBlcnMgPSB1dGlscy50b0FycmF5KG9wdGlvbnMucGVycywgb3B0aW9ucy5wZXJzRW5jKTtcbiAgYXNzZXJ0KGVudHJvcHkubGVuZ3RoID49ICh0aGlzLm1pbkVudHJvcHkgLyA4KSxcbiAgICAgICAgICdOb3QgZW5vdWdoIGVudHJvcHkuIE1pbmltdW0gaXM6ICcgKyB0aGlzLm1pbkVudHJvcHkgKyAnIGJpdHMnKTtcbiAgdGhpcy5faW5pdChlbnRyb3B5LCBub25jZSwgcGVycyk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEhtYWNEUkJHO1xuXG5IbWFjRFJCRy5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiBpbml0KGVudHJvcHksIG5vbmNlLCBwZXJzKSB7XG4gIHZhciBzZWVkID0gZW50cm9weS5jb25jYXQobm9uY2UpLmNvbmNhdChwZXJzKTtcblxuICB0aGlzLksgPSBuZXcgQXJyYXkodGhpcy5vdXRMZW4gLyA4KTtcbiAgdGhpcy5WID0gbmV3IEFycmF5KHRoaXMub3V0TGVuIC8gOCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5WLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5LW2ldID0gMHgwMDtcbiAgICB0aGlzLlZbaV0gPSAweDAxO1xuICB9XG5cbiAgdGhpcy5fdXBkYXRlKHNlZWQpO1xuICB0aGlzLnJlc2VlZCA9IDE7XG4gIHRoaXMucmVzZWVkSW50ZXJ2YWwgPSAweDEwMDAwMDAwMDAwMDA7ICAvLyAyXjQ4XG59O1xuXG5IbWFjRFJCRy5wcm90b3R5cGUuX2htYWMgPSBmdW5jdGlvbiBobWFjKCkge1xuICByZXR1cm4gbmV3IGhhc2guaG1hYyh0aGlzLmhhc2gsIHRoaXMuSyk7XG59O1xuXG5IbWFjRFJCRy5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShzZWVkKSB7XG4gIHZhciBrbWFjID0gdGhpcy5faG1hYygpXG4gICAgICAgICAgICAgICAgIC51cGRhdGUodGhpcy5WKVxuICAgICAgICAgICAgICAgICAudXBkYXRlKFsgMHgwMCBdKTtcbiAgaWYgKHNlZWQpXG4gICAga21hYyA9IGttYWMudXBkYXRlKHNlZWQpO1xuICB0aGlzLksgPSBrbWFjLmRpZ2VzdCgpO1xuICB0aGlzLlYgPSB0aGlzLl9obWFjKCkudXBkYXRlKHRoaXMuVikuZGlnZXN0KCk7XG4gIGlmICghc2VlZClcbiAgICByZXR1cm47XG5cbiAgdGhpcy5LID0gdGhpcy5faG1hYygpXG4gICAgICAgICAgICAgICAudXBkYXRlKHRoaXMuVilcbiAgICAgICAgICAgICAgIC51cGRhdGUoWyAweDAxIF0pXG4gICAgICAgICAgICAgICAudXBkYXRlKHNlZWQpXG4gICAgICAgICAgICAgICAuZGlnZXN0KCk7XG4gIHRoaXMuViA9IHRoaXMuX2htYWMoKS51cGRhdGUodGhpcy5WKS5kaWdlc3QoKTtcbn07XG5cbkhtYWNEUkJHLnByb3RvdHlwZS5yZXNlZWQgPSBmdW5jdGlvbiByZXNlZWQoZW50cm9weSwgZW50cm9weUVuYywgYWRkLCBhZGRFbmMpIHtcbiAgLy8gT3B0aW9uYWwgZW50cm9weSBlbmNcbiAgaWYgKHR5cGVvZiBlbnRyb3B5RW5jICE9PSAnc3RyaW5nJykge1xuICAgIGFkZEVuYyA9IGFkZDtcbiAgICBhZGQgPSBlbnRyb3B5RW5jO1xuICAgIGVudHJvcHlFbmMgPSBudWxsO1xuICB9XG5cbiAgZW50cm9weSA9IHV0aWxzLnRvQnVmZmVyKGVudHJvcHksIGVudHJvcHlFbmMpO1xuICBhZGQgPSB1dGlscy50b0J1ZmZlcihhZGQsIGFkZEVuYyk7XG5cbiAgYXNzZXJ0KGVudHJvcHkubGVuZ3RoID49ICh0aGlzLm1pbkVudHJvcHkgLyA4KSxcbiAgICAgICAgICdOb3QgZW5vdWdoIGVudHJvcHkuIE1pbmltdW0gaXM6ICcgKyB0aGlzLm1pbkVudHJvcHkgKyAnIGJpdHMnKTtcblxuICB0aGlzLl91cGRhdGUoZW50cm9weS5jb25jYXQoYWRkIHx8IFtdKSk7XG4gIHRoaXMucmVzZWVkID0gMTtcbn07XG5cbkhtYWNEUkJHLnByb3RvdHlwZS5nZW5lcmF0ZSA9IGZ1bmN0aW9uIGdlbmVyYXRlKGxlbiwgZW5jLCBhZGQsIGFkZEVuYykge1xuICBpZiAodGhpcy5yZXNlZWQgPiB0aGlzLnJlc2VlZEludGVydmFsKVxuICAgIHRocm93IG5ldyBFcnJvcignUmVzZWVkIGlzIHJlcXVpcmVkJyk7XG5cbiAgLy8gT3B0aW9uYWwgZW5jb2RpbmdcbiAgaWYgKHR5cGVvZiBlbmMgIT09ICdzdHJpbmcnKSB7XG4gICAgYWRkRW5jID0gYWRkO1xuICAgIGFkZCA9IGVuYztcbiAgICBlbmMgPSBudWxsO1xuICB9XG5cbiAgLy8gT3B0aW9uYWwgYWRkaXRpb25hbCBkYXRhXG4gIGlmIChhZGQpIHtcbiAgICBhZGQgPSB1dGlscy50b0FycmF5KGFkZCwgYWRkRW5jKTtcbiAgICB0aGlzLl91cGRhdGUoYWRkKTtcbiAgfVxuXG4gIHZhciB0ZW1wID0gW107XG4gIHdoaWxlICh0ZW1wLmxlbmd0aCA8IGxlbikge1xuICAgIHRoaXMuViA9IHRoaXMuX2htYWMoKS51cGRhdGUodGhpcy5WKS5kaWdlc3QoKTtcbiAgICB0ZW1wID0gdGVtcC5jb25jYXQodGhpcy5WKTtcbiAgfVxuXG4gIHZhciByZXMgPSB0ZW1wLnNsaWNlKDAsIGxlbik7XG4gIHRoaXMuX3VwZGF0ZShhZGQpO1xuICB0aGlzLnJlc2VlZCsrO1xuICByZXR1cm4gdXRpbHMuZW5jb2RlKHJlcywgZW5jKTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgZG91Ymxlczoge1xuICAgIHN0ZXA6IDQsXG4gICAgcG9pbnRzOiBbXG4gICAgICBbXG4gICAgICAgICdlNjBmY2U5M2I1OWU5ZWM1MzAxMWFhYmMyMWMyM2U5N2IyYTMxMzY5Yjg3YTVhZTljNDRlZTg5ZTJhNmRlYzBhJyxcbiAgICAgICAgJ2Y3ZTM1MDczOTllNTk1OTI5ZGI5OWYzNGY1NzkzNzEwMTI5Njg5MWU0NGQyM2YwYmUxZjMyY2NlNjk2MTY4MjEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnODI4MjI2MzIxMmM2MDlkOWVhMmE2ZTNlMTcyZGUyMzhkOGMzOWNhYmQ1YWMxY2ExMDY0NmUyM2ZkNWY1MTUwOCcsXG4gICAgICAgICcxMWY4YTgwOTg1NTdkZmU0NWU4MjU2ZTgzMGI2MGFjZTYyZDYxM2FjMmY3YjE3YmVkMzFiNmVhZmY2ZTI2Y2FmJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzE3NWUxNTlmNzI4Yjg2NWE3MmY5OWNjNmM2ZmM4NDZkZTBiOTM4MzNmZDIyMjJlZDczZmNlNWI1NTFlNWI3MzknLFxuICAgICAgICAnZDM1MDZlMGQ5ZTNjNzllYmE0ZWY5N2E1MWZmNzFmNWVhY2I1OTU1YWRkMjQzNDVjNmVmYTZmZmVlOWZlZDY5NSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICczNjNkOTBkNDQ3YjAwYzljOTljZWFjMDViNjI2MmVlMDUzNDQxYzdlNTU1NTJmZmU1MjZiYWQ4ZjgzZmY0NjQwJyxcbiAgICAgICAgJzRlMjczYWRmYzczMjIyMTk1M2I0NDUzOTdmMzM2MzE0NWI5YTg5MDA4MTk5ZWNiNjIwMDNjN2YzYmVlOWRlOSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc4YjRiNWYxNjVkZjNjMmJlOGM2MjQ0YjViNzQ1NjM4ODQzZTRhNzgxYTE1YmNkMWI2OWY3OWE1NWRmZmRmODBjJyxcbiAgICAgICAgJzRhYWQwYTZmNjhkMzA4YjRiM2ZiZDc4MTNhYjBkYTA0ZjllMzM2NTQ2MTYyZWU1NmIzZWZmMGM2NWZkNGZkMzYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNzIzY2JhYTZlNWRiOTk2ZDZiZjc3MWMwMGJkNTQ4YzdiNzAwZGJmZmE2YzBlNzdiY2I2MTE1OTI1MjMyZmNkYScsXG4gICAgICAgICc5NmU4NjdiNTU5NWNjNDk4YTkyMTEzNzQ4ODgyNGQ2ZTI2NjBhMDY1Mzc3OTQ5NDgwMWRjMDY5ZDllYjM5ZjVmJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2VlYmZhNGQ0OTNiZWJmOThiYTVmZWVjODEyYzJkM2I1MDk0Nzk2MTIzN2E5MTk4MzlhNTMzZWNhMGU3ZGQ3ZmEnLFxuICAgICAgICAnNWQ5YThjYTM5NzBlZjBmMjY5ZWU3ZWRhZjE3ODA4OWQ5YWU0Y2RjM2E3MTFmNzEyZGRmZDRmZGFlMWRlODk5OSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcxMDBmNDRkYTY5NmU3MTY3Mjc5MWQwYTA5YjdiZGU0NTlmMTIxNWEyOWIzYzAzYmZlZmQ3ODM1YjM5YTQ4ZGIwJyxcbiAgICAgICAgJ2NkZDllMTMxOTJhMDBiNzcyZWM4ZjMzMDBjMDkwNjY2YjdmZjRhMThmZjUxOTVhYzBmYmQ1Y2Q2MmJjNjVhMDknXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZTEwMzFiZTI2MmM3ZWQxYjFkYzkyMjdhNGEwNGMwMTdhNzdmOGQ0NDY0ZjNiMzg1MmM4YWNkZTZlNTM0ZmQyZCcsXG4gICAgICAgICc5ZDcwNjE5Mjg5NDA0MDVlNmJiNmE0MTc2NTk3NTM1YWYyOTJkZDQxOWUxY2VkNzlhNDRmMThmMjk0NTZhMDBkJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2ZlZWE2Y2FlNDZkNTViNTMwYWMyODM5ZjE0M2JkN2VjNWNmOGIyNjZhNDFkNmFmNTJkNWU2ODhkOTA5NDY5NmQnLFxuICAgICAgICAnZTU3YzZiNmM5N2RjZTFiYWIwNmU0ZTEyYmYzZWNkNWM5ODFjODk1N2NjNDE0NDJkMzE1NWRlYmYxODA5MDA4OCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkYTY3YTkxZDkxMDQ5Y2RjYjM2N2JlNGJlNmZmY2EzY2ZlZWQ2NTdkODA4NTgzZGUzM2ZhOTc4YmMxZWM2Y2IxJyxcbiAgICAgICAgJzliYWNhYTM1NDgxNjQyYmM0MWY0NjNmN2VjOTc4MGU1ZGVjN2FkYzUwOGY3NDBhMTdlOWVhOGUyN2E2OGJlMWQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNTM5MDRmYWEwYjMzNGNkZGE2ZTAwMDkzNWVmMjIxNTFlYzA4ZDBmN2JiMTEwNjlmNTc1NDVjY2MxYTM3YjdjMCcsXG4gICAgICAgICc1YmMwODdkMGJjODAxMDZkODhjOWVjY2FjMjBkM2MxYzEzOTk5OTgxZTE0NDM0Njk5ZGNiMDk2YjAyMjc3MWM4J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzhlN2JjZDBiZDM1OTgzYTc3MTljY2E3NzY0Y2E5MDY3NzliNTNhMDQzYTliOGJjYWVmZjk1OWY0M2FkODYwNDcnLFxuICAgICAgICAnMTBiNzc3MGIyYTNkYTRiMzk0MDMxMDQyMGNhOTUxNDU3OWU4OGUyZTQ3ZmQ2OGIzZWExMDA0N2U4NDYwMzcyYSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICczODVlZWQzNGMxY2RmZjIxZTZkMDgxODY4OWI4MWJkZTcxYTdmNGYxODM5N2U2NjkwYTg0MWUxNTk5YzQzODYyJyxcbiAgICAgICAgJzI4M2JlYmMzZThlYTIzZjU2NzAxZGUxOWU5ZWJmNDU3NmIzMDRlZWMyMDg2ZGM4Y2MwNDU4ZmU1NTQyZTU0NTMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNmY5ZDliODAzZWNmMTkxNjM3YzczYTQ0MTNkZmExODBmZGRmODRhNTk0N2ZiYzljNjA2ZWQ4NmMzZmFjM2E3JyxcbiAgICAgICAgJzdjODBjNjhlNjAzMDU5YmE2OWI4ZTJhMzBlNDVjNGQ0N2VhNGRkMmY1YzI4MTAwMmQ4Njg5MDYwM2E4NDIxNjAnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMzMyMmQ0MDEyNDNjNGUyNTgyYTIxNDdjMTA0ZDZlY2JmNzc0ZDE2M2RiMGY1ZTUzMTNiN2UwZTc0MmQwZTZiZCcsXG4gICAgICAgICc1NmU3MDc5N2U5NjY0ZWY1YmZiMDE5YmM0ZGRhZjliNzI4MDVmNjNlYTI4NzNhZjYyNGYzYTJlOTZjMjhiMmEwJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzg1NjcyYzdkMmRlMGI3ZGEyYmQxNzcwZDg5NjY1ODY4NzQxYjNmOWFmNzY0MzM5NzcyMWQ3NGQyODEzNGFiODMnLFxuICAgICAgICAnN2M0ODFiOWI1YjQzYjJlYjYzNzQwNDliZmE2MmMyZTVlNzdmMTdmY2M1Mjk4ZjQ0YzhlMzA5NGY3OTAzMTNhNidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc5NDhiZjgwOWIxOTg4YTQ2YjA2YzlmMTkxOTQxM2IxMGY5MjI2YzYwZjY2ODgzMmZmZDk1OWFmNjBjODJhMGEnLFxuICAgICAgICAnNTNhNTYyODU2ZGNiNjY0NmRjNmI3NGM1ZDFjMzQxOGM2ZDRkZmYwOGM5N2NkMmJlZDRjYjdmODhkOGM4ZTU4OSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc2MjYwY2U3ZjQ2MTgwMWMzNGYwNjdjZTBmMDI4NzNhOGYxYjBlNDRkZmM2OTc1MmFjY2VjZDgxOWYzOGZkOGU4JyxcbiAgICAgICAgJ2JjMmRhODJiNmZhNWI1NzFhN2YwOTA0OTc3NmExZWY3ZWNkMjkyMjM4MDUxYzE5OGMxYTg0ZTk1YjJiNGFlMTcnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZTUwMzdkZTBhZmMxZDhkNDNkODM0ODQxNGJiZjQxMDMwNDNlYzhmNTc1YmZkYzQzMjk1M2NjOGQyMDM3ZmEyZCcsXG4gICAgICAgICc0NTcxNTM0YmFhOTRkM2I1ZjlmOThkMDlmYjk5MGJkZGJkNWY1YjAzZWM0ODFmMTBlMGU1ZGM4NDFkNzU1YmRhJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2UwNjM3MmIwZjRhMjA3YWRmNWVhOTA1ZThmMTc3MWI0ZTdlOGRiZDFjNmE2YzViNzI1ODY2YTBhZTRmY2U3MjUnLFxuICAgICAgICAnN2E5MDg5NzRiY2UxOGNmZTEyYTI3YmIyYWQ1YTQ4OGNkNzQ4NGE3Nzg3MTA0ODcwYjI3MDM0Zjk0ZWVlMzFkZCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcyMTNjN2E3MTVjZDVkNDUzNThkMGJiZjlkYzBjZTAyMjA0YjEwYmRkZTJhM2Y1ODU0MGFkNjkwOGQwNTU5NzU0JyxcbiAgICAgICAgJzRiNmRhZDBiNWFlNDYyNTA3MDEzYWQwNjI0NWJhMTkwYmI0ODUwZjVmMzZhN2VlZGRmZjJjMjc1MzRiNDU4ZjInXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNGU3YzI3MmE3YWY0YjM0ZThkYmI5MzUyYTU0MTlhODdlMjgzOGM3MGFkYzYyY2RkZjBjYzNhM2IwOGZiZDUzYycsXG4gICAgICAgICcxNzc0OWM3NjZjOWQwYjE4ZTE2ZmQwOWY2ZGVmNjgxYjUzMGI5NjE0YmZmN2RkMzNlMGIzOTQxODE3ZGNhYWU2J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2ZlYTc0ZTNkYmU3NzhiMWIxMGYyMzhhZDYxNjg2YWE1Yzc2ZTNkYjJiZTQzMDU3NjMyNDI3ZTI4NDBmYjI3YjYnLFxuICAgICAgICAnNmUwNTY4ZGI5YjBiMTMyOTdjZjY3NGRlY2NiNmFmOTMxMjZiNTk2Yjk3M2Y3Yjc3NzAxZDNkYjdmMjNjYjk2ZidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc3NmU2NDExM2Y2NzdjZjBlMTBhMjU3MGQ1OTk5NjhkMzE1NDRlMTc5Yjc2MDQzMjk1MmMwMmE0NDE3YmRkZTM5JyxcbiAgICAgICAgJ2M5MGRkZjhkZWU0ZTk1Y2Y1NzcwNjZkNzA2ODFmMGQzNWUyYTMzZDJiNTZkMjAzMmI0YjE3NTJkMTkwMWFjMDEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYzczOGM1NmIwM2IyYWJlMWU4MjgxYmFhNzQzZjhmOWE4ZjdjYzY0M2RmMjZjYmVlM2FiMTUwMjQyYmNiYjg5MScsXG4gICAgICAgICc4OTNmYjU3ODk1MWFkMjUzN2Y3MThmMmVhY2JmYmJiYjgyMzE0ZWVmNzg4MGNmZTkxN2U3MzVkOTY5OWE4NGMzJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2Q4OTU2MjY1NDhiNjViODFlMjY0Yzc2MzdjOTcyODc3ZDFkNzJlNWYzYTkyNTAxNDM3MmU5ZjY1ODhmNmMxNGInLFxuICAgICAgICAnZmViZmFhMzhmMmJjN2VhZTcyOGVjNjA4MThjMzQwZWIwMzQyOGQ2MzJiYjA2N2UxNzkzNjNlZDc1ZDdkOTkxZidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdiOGRhOTQwMzJhOTU3NTE4ZWIwZjY0MzM1NzFlODc2MWNlZmZjNzM2OTNlODRlZGQ0OTE1MGE1NjRmNjc2ZTAzJyxcbiAgICAgICAgJzI4MDRkZmE0NDgwNWExZTRkN2M5OWNjOTc2MjgwOGIwOTJjYzU4NGQ5NWZmM2I1MTE0ODhlNGU3NGVmZGY2ZTcnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZTgwZmVhMTQ0NDFmYjMzYTdkOGFkYWI5NDc1ZDdmYWIyMDE5ZWZmYjUxNTZhNzkyZjFhMTE3NzhlM2MwZGY1ZCcsXG4gICAgICAgICdlZWQxZGU3ZjYzOGUwMDc3MWU4OTc2OGNhM2NhOTQ0NzJkMTU1ZTgwYWYzMjJlYTlmY2I0MjkxYjZhYzllYzc4J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2EzMDE2OTdiZGZjZDcwNDMxM2JhNDhlNTFkNTY3NTQzZjJhMTgyMDMxZWZkNjkxNWRkYzA3YmJjYzRlMTYwNzAnLFxuICAgICAgICAnNzM3MGY5MWNmYjY3ZTRmNTA4MTgwOWZhMjVkNDBmOWIxNzM1ZGJmN2MwYTExYTEzMGMwZDFhMDQxZTE3N2VhMSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc5MGFkODViMzg5ZDZiOTM2NDYzZjlkMDUxMjY3OGRlMjA4Y2MzMzBiMTEzMDdmZmZhYjdhYzYzZTNmYjA0ZWQ0JyxcbiAgICAgICAgJ2U1MDdhMzYyMGEzODI2MWFmZmRjYmQ5NDI3MjIyYjgzOWFlZmFiZTE1ODI4OTRkOTkxZDRkNDhjYjZlZjE1MCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc4ZjY4YjlkMmY2M2I1ZjMzOTIzOWMxYWQ5ODFmMTYyZWU4OGM1Njc4NzIzZWEzMzUxYjdiNDQ0YzllYzRjMGRhJyxcbiAgICAgICAgJzY2MmE5ZjJkYmEwNjM5ODZkZTFkOTBjMmI2YmUyMTVkYmJlYTJjZmU5NTUxMGJmZGYyM2NiZjc5NTAxZmZmODInXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZTRmM2ZiMDE3NmFmODVkNjVmZjk5ZmY5MTk4YzM2MDkxZjQ4ZTg2NTAzNjgxZTNlNjY4NmZkNTA1MzIzMWUxMScsXG4gICAgICAgICcxZTYzNjMzYWQwZWY0ZjFjMTY2MWE2ZDBlYTAyYjcyODZjYzdlNzRlYzk1MWQxYzk4MjJjMzg1NzZmZWI3M2JjJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzhjMDBmYTliMThlYmYzMzFlYjk2MTUzN2E0NWE0MjY2YzcwMzRmMmYwZDRlMWQwNzE2ZmI2ZWFlMjBlYWUyOWUnLFxuICAgICAgICAnZWZhNDcyNjdmZWE1MjFhMWE5ZGMzNDNhMzczNmM5NzRjMmZhZGFmYTgxZTM2YzU0ZTdkMmE0YzY2NzAyNDE0YidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlN2EyNmNlNjlkZDQ4MjlmM2UxMGNlYzBhOWU5OGVkMzE0M2QwODRmMzA4YjkyYzA5OTdmZGRmYzYwY2IzZTQxJyxcbiAgICAgICAgJzJhNzU4ZTMwMGZhNzk4NGI0NzFiMDA2YTFhYWZiYjE4ZDBhNmIyYzA0MjBlODNlMjBlOGE5NDIxY2YyY2ZkNTEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYjY0NTllMGVlMzY2MmVjOGQyMzU0MGMyMjNiY2JkYzU3MWNiY2I5NjdkNzk0MjRmM2NmMjllYjNkZTZiODBlZicsXG4gICAgICAgICc2N2M4NzZkMDZmM2UwNmRlMWRhZGYxNmU1NjYxZGIzYzRiM2FlNmQ0OGUzNWIyZmYzMGJmMGI2MWE3MWJhNDUnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZDY4YTgwYzgyODBiYjg0MDc5MzIzNGFhMTE4ZjA2MjMxZDZmMWZjNjdlNzNjNWE1ZGVkYTBmNWI0OTY5NDNlOCcsXG4gICAgICAgICdkYjhiYTlmZmY0YjU4NmQwMGM0YjFmOTE3N2IwZTI4YjViMGU3YjhmNzg0NTI5NWEyOTRjODQyNjZiMTMzMTIwJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzMyNGFlZDdkZjY1YzgwNDI1MmRjMDI3MDkwN2EzMGIwOTYxMmFlYjk3MzQ0OWNlYTQwOTU5ODBmYzI4ZDNkNWQnLFxuICAgICAgICAnNjQ4YTM2NTc3NGI2MWYyZmYxMzBjMGMzNWFlYzFmNGYxOTIxM2IwYzdlMzMyODQzOTY3MjI0YWY5NmFiN2M4NCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc0ZGY5YzE0OTE5Y2RlNjFmNmQ1MWRmZGJlNWZlZTVkY2VlYzQxNDNiYThkMWNhODg4ZThiZDM3M2ZkMDU0Yzk2JyxcbiAgICAgICAgJzM1ZWM1MTA5MmQ4NzI4MDUwOTc0YzIzYTFkODVkNGI1ZDUwNmNkYzI4ODQ5MDE5MmViYWMwNmNhZDEwZDVkJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzljMzkxOWE4NGE0NzQ4NzBmYWVkOGE5YzFjYzY2MDIxNTIzNDg5MDU0ZDdmMDMwOGNiZmM5OWM4YWMxZjk4Y2QnLFxuICAgICAgICAnZGRiODRmMGY0YTRkZGQ1NzU4NGYwNDRiZjI2MGU2NDE5MDUzMjZmNzZjNjRjOGU2YmU3ZTVlMDNkNGZjNTk5ZCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc2MDU3MTcwYjFkZDEyZmRmOGRlMDVmMjgxZDhlMDZiYjkxZTE0OTNhOGI5MWQ0Y2M1YTIxMzgyMTIwYTk1OWU1JyxcbiAgICAgICAgJzlhMWFmMGIyNmE2YTQ4MDdhZGQ5YTJkYWY3MWRmMjYyNDY1MTUyYmMzZWUyNGM2NWU4OTliZTkzMjM4NWEyYTgnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYTU3NmRmOGUyM2EwODQxMTQyMTQzOWE0NTE4ZGEzMTg4MGNlZjBmYmE3ZDRkZjEyYjFhNjk3M2VlY2I5NDI2NicsXG4gICAgICAgICc0MGE2YmYyMGU3NjY0MGIyYzkyYjk3YWZlNThjZDgyYzQzMmUxMGE3ZjUxNGQ5ZjNlZThiZTExYWUxYjI4ZWM4J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzc3NzhhNzhjMjhkZWMzZTMwYTA1ZmU5NjI5ZGU4YzM4YmIzMGQxZjVjZjlhM2EyMDhmNzYzODg5YmU1OGFkNzEnLFxuICAgICAgICAnMzQ2MjZkOWFiNWE1YjIyZmY3MDk4ZTEyZjJmZjU4MDA4N2IzODQxMWZmMjRhYzU2M2I1MTNmYzFmZDlmNDNhYydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc5Mjg5NTVlZTYzN2E4NDQ2MzcyOWZkMzBlN2FmZDJlZDVmOTYyNzRlNWFkN2U1Y2IwOWVkYTljMDZkOTAzYWMnLFxuICAgICAgICAnYzI1NjIxMDAzZDNmNDJhODI3Yjc4YTEzMDkzYTk1ZWVhYzNkMjZlZmE4YThkODNmYzUxODBlOTM1YmNkMDkxZidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc4NWQwZmVmM2VjNmRiMTA5Mzk5MDY0ZjNhMGUzYjI4NTU2NDViNGE5MDdhZDM1NDUyN2FhZTc1MTYzZDgyNzUxJyxcbiAgICAgICAgJzFmMDM2NDg0MTNhMzhjMGJlMjlkNDk2ZTU4MmNmNTY2M2U4NzUxZTk2ODc3MzMxNTgyYzIzN2EyNGViMWY5NjInXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZmYyYjBkY2U5N2VlY2U5N2MxYzliNjA0MTc5OGI4NWRmZGZiNmQ4ODgyZGEyMDMwOGY1NDA0ODI0NTI2MDg3ZScsXG4gICAgICAgICc0OTNkMTNmZWY1MjRiYTE4OGFmNGM0ZGM1NGQwNzkzNmM3YjdlZDZmYjkwZTJjZWIyYzk1MWUwMWYwYzI5OTA3J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzgyN2ZiYmU0YjFlODgwZWE5ZWQyYjJlNjMwMWIyMTJiNTdmMWVlMTQ4Y2Q2ZGQyODc4MGU1ZTJjZjg1NmUyNDEnLFxuICAgICAgICAnYzYwZjljOTIzYzcyN2IwYjcxYmVmMmM2N2QxZDEyNjg3ZmY3YTYzMTg2OTAzMTY2ZDYwNWI2OGJhZWMyOTNlYydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlYWE2NDlmMjFmNTFiZGJhZTdiZTRhZTM0Y2U2ZTUyMTdhNThmZGNlN2Y0N2Y5YWE3ZjNiNThmYTIxMjBlMmIzJyxcbiAgICAgICAgJ2JlMzI3OWVkNWJiYmIwM2FjNjlhODBmODk4NzlhYTVhMDFhNmI5NjVmMTNmN2U1OWQ0N2E1MzA1YmE1YWQ5M2QnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZTRhNDJkNDNjNWNmMTY5ZDkzOTFkZjZkZWNmNDJlZTU0MWI2ZDhmMGM5YTEzNzQwMWUyMzYzMmRkYTM0ZDI0ZicsXG4gICAgICAgICc0ZDlmOTJlNzE2ZDFjNzM1MjZmYzk5Y2NmYjhhZDM0Y2U4ODZlZWRmYThkOGU0ZjEzYTdmNzEzMWRlYmE5NDE0J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzFlYzgwZmVmMzYwY2JkZDk1NDE2MGZhZGFiMzUyYjZiOTJiNTM1NzZhODhmZWE0OTQ3MTczYjlkNDMwMGJmMTknLFxuICAgICAgICAnYWVlZmU5Mzc1NmI1MzQwZDJmM2E0OTU4YTdhYmJmNWUwMTQ2ZTc3ZjYyOTVhMDdiNjcxY2RjMWNjMTA3Y2VmZCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcxNDZhNzc4YzA0NjcwYzJmOTFiMDBhZjQ2ODBkZmE4YmNlMzQ5MDcxN2Q1OGJhODg5ZGRiNTkyODM2NjY0MmJlJyxcbiAgICAgICAgJ2IzMThlMGVjMzM1NDAyOGFkZDY2OTgyN2Y5ZDRiMjg3MGFhYTk3MWQyZjdlNWVkMWQwYjI5NzQ4M2Q4M2VmZDAnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZmE1MGMwZjYxZDIyZTVmMDdlM2FjZWJiMWFhMDdiMTI4ZDAwMTIyMDlhMjhiOTc3NmQ3NmE4NzkzMTgwZWVmOScsXG4gICAgICAgICc2Yjg0YzY5MjIzOTdlYmE5YjcyY2QyODcyMjgxYTY4YTVlNjgzMjkzYTU3YTIxM2IzOGNkOGQ3ZDNmNGYyODExJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2RhMWQ2MWQwY2E3MjFhMTFiMWE1YmY2YjdkODhlODQyMWEyODhhYjVkNWJiYTUyMjBlNTNkMzJiNWYwNjdlYzInLFxuICAgICAgICAnODE1N2Y1NWE3Yzk5MzA2Yzc5YzA3NjYxNjFjOTFlMjk2NmE3Mzg5OWQyNzliNDhhNjU1ZmJhMGYxYWQ4MzZmMSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdhOGUyODJmZjBjOTcwNjkwNzIxNWZmOThlOGZkNDE2NjE1MzExZGUwNDQ2ZjFlMDYyYTczYjA2MTBkMDY0ZTEzJyxcbiAgICAgICAgJzdmOTczNTViOGRiODFjMDlhYmZiN2YzYzViMjUxNTg4OGI2NzlhM2U1MGRkNmJkNmNlZjdjNzMxMTFmNGNjMGMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMTc0YTUzYjljOWEyODU4NzJkMzllNTZlNjkxM2NhYjE1ZDU5YjFmYTUxMjUwOGMwMjJmMzgyZGU4MzE5NDk3YycsXG4gICAgICAgICdjY2M5ZGMzN2FiZmM5YzE2NTdiNDE1NWYyYzQ3ZjllNjY0NmIzYTFkOGNiOTg1NDM4M2RhMTNhYzA3OWFmYTczJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzk1OTM5Njk4MTk0Mzc4NWMzZDNlNTdlZGY1MDE4Y2RiZTAzOWU3MzBlNDkxOGIzZDg4NGZkZmYwOTQ3NWI3YmEnLFxuICAgICAgICAnMmU3ZTU1Mjg4OGMzMzFkZDhiYTAzODZhNGI5Y2Q2ODQ5YzY1M2Y2NGM4NzA5Mzg1ZTliOGFiZjg3NTI0ZjJmZCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkMmE2M2E1MGFlNDAxZTU2ZDY0NWExMTUzYjEwOWE4ZmNjYTBhNDNkNTYxZmJhMmRiYjUxMzQwYzlkODJiMTUxJyxcbiAgICAgICAgJ2U4MmQ4NmZiNjQ0M2ZjYjc1NjVhZWU1OGIyOTQ4MjIwYTcwZjc1MGFmNDg0Y2E1MmQ0MTQyMTc0ZGNmODk0MDUnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNjQ1ODdlMjMzNTQ3MWViODkwZWU3ODk2ZDdjZmRjODY2YmFjYmRiZDM4MzkzMTdiMzQzNmY5YjQ1NjE3ZTA3MycsXG4gICAgICAgICdkOTlmY2RkNWJmNjkwMmUyYWU5NmRkNjQ0N2MyOTlhMTg1YjkwYTM5MTMzYWVhYjM1ODI5OWU1ZTlmYWY2NTg5J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzg0ODFiZGUwZTRlNGQ4ODViM2E1NDZkM2U1NDlkZTA0MmYwYWE2Y2VhMjUwZTdmZDM1OGQ2Yzg2ZGQ0NWU0NTgnLFxuICAgICAgICAnMzhlZTdiOGNiYTU0MDRkZDg0YTI1YmYzOWNlY2IyY2E5MDBhNzljNDJiMjYyZTU1NmQ2NGIxYjU5Nzc5MDU3ZSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcxMzQ2NGE1N2E3ODEwMmFhNjJiNjk3OWFlODE3ZjQ2MzdmZmNmZWQzYzRiMWNlMzBiY2Q2MzAzZjZjYWY2NjZiJyxcbiAgICAgICAgJzY5YmUxNTkwMDQ2MTQ1ODBlZjdlNDMzNDUzY2NiMGNhNDhmMzAwYTgxZDA5NDJlMTNmNDk1YTkwN2Y2ZWNjMjcnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYmM0YTlkZjViNzEzZmUyZTlhZWY0MzBiY2MxZGM5N2EwY2Q5Y2NlZGUyZjI4NTg4Y2FkYTNhMGQyZDgzZjM2NicsXG4gICAgICAgICdkM2E4MWNhNmU3ODVjMDYzODM5MzdhZGY0Yjc5OGNhYTZlOGE5ZmJmYTU0N2IxNmQ3NThkNjY2NTgxZjMzYzEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnOGMyOGE5N2JmODI5OGJjMGQyM2Q4Yzc0OTQ1MmEzMmU2OTRiNjVlMzBhOTQ3MmEzOTU0YWIzMGZlNTMyNGNhYScsXG4gICAgICAgICc0MGEzMDQ2M2EzMzA1MTkzMzc4ZmVkZjMxZjdjYzBlYjdhZTc4NGYwNDUxY2I5NDU5ZTcxZGM3M2NiZWY5NDgyJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzhlYTk2NjYxMzk1MjdhOGMxZGQ5NGNlNGYwNzFmZDIzYzhiMzUwYzVhNGJiMzM3NDhjNGJhMTExZmFjY2FlMCcsXG4gICAgICAgICc2MjBlZmFiYmM4ZWUyNzgyZTI0ZTdjMGNmYjk1YzVkNzM1Yjc4M2JlOWNmMGY4ZTk1NWFmMzRhMzBlNjJiOTQ1J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2RkMzYyNWZhZWY1YmEwNjA3NDY2OTcxNmJiZDM3ODhkODliZGRlODE1OTU5OTY4MDkyZjc2Y2M0ZWI5YTk3ODcnLFxuICAgICAgICAnN2ExODhmYTM1MjBlMzBkNDYxZGEyNTAxMDQ1NzMxY2E5NDE0NjE5ODI4ODMzOTU5MzdmNjhkMDBjNjQ0YTU3MydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdmNzEwZDc5ZDllYjk2MjI5N2U0ZjYyMzJiNDBlOGY3ZmViMmJjNjM4MTQ2MTRkNjkyYzEyZGU3NTI0MDgyMjFlJyxcbiAgICAgICAgJ2VhOThlNjcyMzJkM2IzMjk1ZDNiNTM1NTMyMTE1Y2NhYzg2MTJjNzIxODUxNjE3NTI2YWU0N2E5Yzc3YmZjODInXG4gICAgICBdXG4gICAgXVxuICB9LFxuICBuYWY6IHtcbiAgICB3bmQ6IDcsXG4gICAgcG9pbnRzOiBbXG4gICAgICBbXG4gICAgICAgICdmOTMwOGEwMTkyNThjMzEwNDkzNDRmODVmODlkNTIyOWI1MzFjODQ1ODM2Zjk5YjA4NjAxZjExM2JjZTAzNmY5JyxcbiAgICAgICAgJzM4OGY3YjBmNjMyZGU4MTQwZmUzMzdlNjJhMzdmMzU2NjUwMGE5OTkzNGMyMjMxYjZjYjlmZDc1ODRiOGU2NzInXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMmY4YmRlNGQxYTA3MjA5MzU1YjRhNzI1MGE1YzUxMjhlODhiODRiZGRjNjE5YWI3Y2JhOGQ1NjliMjQwZWZlNCcsXG4gICAgICAgICdkOGFjMjIyNjM2ZTVlM2Q2ZDRkYmE5ZGRhNmM5YzQyNmY3ODgyNzFiYWIwZDY4NDBkY2E4N2QzYWE2YWM2MmQ2J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzVjYmRmMDY0NmU1ZGI0ZWFhMzk4ZjM2NWYyZWE3YTBlM2Q0MTliN2UwMzMwZTM5Y2U5MmJkZGVkY2FjNGY5YmMnLFxuICAgICAgICAnNmFlYmNhNDBiYTI1NTk2MGEzMTc4ZDZkODYxYTU0ZGJhODEzZDBiODEzZmRlN2I1YTUwODI2MjgwODcyNjRkYSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdhY2Q0ODRlMmYwYzdmNjUzMDlhZDE3OGE5ZjU1OWFiZGUwOTc5Njk3NGM1N2U3MTRjMzVmMTEwZGZjMjdjY2JlJyxcbiAgICAgICAgJ2NjMzM4OTIxYjBhN2Q5ZmQ2NDM4MDk3MTc2M2I2MWU5YWRkODg4YTQzNzVmOGUwZjA1Y2MyNjJhYzY0ZjljMzcnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNzc0YWU3Zjg1OGE5NDExZTVlZjQyNDZiNzBjNjVhYWM1NjQ5OTgwYmU1YzE3ODkxYmJlYzE3ODk1ZGEwMDhjYicsXG4gICAgICAgICdkOTg0YTAzMmViNmI1ZTE5MDI0M2RkNTZkN2I3YjM2NTM3MmRiMWUyZGZmOWQ2YTgzMDFkNzRjOWM5NTNjNjFiJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2YyODc3M2MyZDk3NTI4OGJjN2QxZDIwNWMzNzQ4NjUxYjA3NWZiYzY2MTBlNThjZGRlZWRkZjhmMTk0MDVhYTgnLFxuICAgICAgICAnYWIwOTAyZThkODgwYTg5NzU4MjEyZWI2NWNkYWY0NzNhMWEwNmRhNTIxZmE5MWYyOWI1Y2I1MmRiMDNlZDgxJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2Q3OTI0ZDRmN2Q0M2VhOTY1YTQ2NWFlMzA5NWZmNDExMzFlNTk0NmYzYzg1Zjc5ZTQ0YWRiY2Y4ZTI3ZTA4MGUnLFxuICAgICAgICAnNTgxZTI4NzJhODZjNzJhNjgzODQyZWMyMjhjYzZkZWZlYTQwYWYyYmQ4OTZkM2E1YzUwNGRjOWZmNmEyNmI1OCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkZWZkZWE0Y2RiNjc3NzUwYTQyMGZlZTgwN2VhY2YyMWViOTg5OGFlNzliOTc2ODc2NmU0ZmFhMDRhMmQ0YTM0JyxcbiAgICAgICAgJzQyMTFhYjA2OTQ2MzUxNjhlOTk3YjBlYWQyYTkzZGFlY2VkMWY0YTA0YTk1YzBmNmNmYjE5OWY2OWU1NmViNzcnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMmI0ZWEwYTc5N2E0NDNkMjkzZWY1Y2ZmNDQ0ZjQ5NzlmMDZhY2ZlYmQ3ZTg2ZDI3NzQ3NTY1NjEzODM4NWI2YycsXG4gICAgICAgICc4NWU4OWJjMDM3OTQ1ZDkzYjM0MzA4M2I1YTFjODYxMzFhMDFmNjBjNTAyNjk3NjNiNTcwYzg1NGU1YzA5YjdhJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzM1MmJiZjRhNGNkZDEyNTY0ZjkzZmEzMzJjZTMzMzMwMWQ5YWQ0MDI3MWY4MTA3MTgxMzQwYWVmMjViZTU5ZDUnLFxuICAgICAgICAnMzIxZWI0MDc1MzQ4ZjUzNGQ1OWMxODI1OWRkYTNlMWY0YTFiM2IyZTcxYjEwMzljNjdiZDNkOGJjZjgxOTk4YydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcyZmEyMTA0ZDZiMzhkMTFiMDIzMDAxMDU1OTg3OTEyNGU0MmFiOGRmZWZmNWZmMjlkYzljZGFkZDRlY2FjYzNmJyxcbiAgICAgICAgJzJkZTEwNjgyOTVkZDg2NWI2NDU2OTMzNWJkNWRkODAxODFkNzBlY2ZjODgyNjQ4NDIzYmE3NmI1MzJiN2Q2NydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc5MjQ4Mjc5YjA5YjRkNjhkYWIyMWE5YjA2NmVkZGE4MzI2M2MzZDg0ZTA5NTcyZTI2OWNhMGNkN2Y1NDUzNzE0JyxcbiAgICAgICAgJzczMDE2ZjdiZjIzNGFhZGU1ZDFhYTcxYmRlYTJiMWZmM2ZjMGRlMmE4ODc5MTJmZmU1NGEzMmNlOTdjYjM0MDInXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZGFlZDRmMmJlM2E4YmYyNzhlNzAxMzJmYjBiZWI3NTIyZjU3MGUxNDRiZjYxNWMwN2U5OTZkNDQzZGVlODcyOScsXG4gICAgICAgICdhNjlkY2U0YTdkNmM5OGU4ZDRhMWFjYTg3ZWY4ZDcwMDNmODNjMjMwZjNhZmE3MjZhYjQwZTUyMjkwYmUxYzU1J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2M0NGQxMmM3MDY1ZDgxMmU4YWNmMjhkN2NiYjE5ZjkwMTFlY2Q5ZTlmZGYyODFiMGU2YTNiNWU4N2QyMmU3ZGInLFxuICAgICAgICAnMjExOWE0NjBjZTMyNmNkYzc2YzQ1OTI2Yzk4MmZkYWMwZTEwNmU4NjFlZGY2MWM1YTAzOTA2M2YwZTBlNjQ4MidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc2YTI0NWJmNmRjNjk4NTA0Yzg5YTIwY2ZkZWQ2MDg1MzE1MmI2OTUzMzZjMjgwNjNiNjFjNjVjYmQyNjllNmI0JyxcbiAgICAgICAgJ2UwMjJjZjQyYzJiZDRhNzA4YjNmNTEyNmYxNmEyNGFkOGIzM2JhNDhkMDQyM2I2ZWZkNWU2MzQ4MTAwZDhhODInXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMTY5N2ZmYTZmZDlkZTYyN2MwNzdlM2QyZmU1NDEwODRjZTEzMzAwYjBiZWMxMTQ2Zjk1YWU1N2YwZDBiZDZhNScsXG4gICAgICAgICdiOWMzOThmMTg2ODA2ZjVkMjc1NjE1MDZlNDU1NzQzM2EyY2YxNTAwOWU0OThhZTdhZGVlOWQ2M2QwMWIyMzk2J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzYwNWJkYjAxOTk4MTcxOGI5ODZkMGYwN2U4MzRjYjBkOWRlYjgzNjBmZmI3ZjYxZGY5ODIzNDVlZjI3YTc0NzknLFxuICAgICAgICAnMjk3MmQyZGU0ZjhkMjA2ODFhNzhkOTNlYzk2ZmUyM2MyNmJmYWU4NGZiMTRkYjQzYjAxZTFlOTA1NmI4YzQ5J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzYyZDE0ZGFiNDE1MGJmNDk3NDAyZmRjNDVhMjE1ZTEwZGNiMDFjMzU0OTU5YjEwY2ZlMzFjN2U5ZDg3ZmYzM2QnLFxuICAgICAgICAnODBmYzA2YmQ4Y2M1YjAxMDk4MDg4YTE5NTBlZWQwZGIwMWFhMTMyOTY3YWI0NzIyMzVmNTY0MjQ4M2IyNWVhZidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc4MGM2MGFkMDA0MGYyN2RhZGU1YjRiMDZjNDA4ZTU2YjJjNTBlOWY1NmI5YjhiNDI1ZTU1NWMyZjg2MzA4YjZmJyxcbiAgICAgICAgJzFjMzgzMDNmMWNjNWMzMGYyNmU2NmJhZDdmZTcyZjcwYTY1ZWVkNGNiZTcwMjRlYjFhYTAxZjU2NDMwYmQ1N2EnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnN2E5Mzc1YWQ2MTY3YWQ1NGFhNzRjNjM0OGNjNTRkMzQ0Y2M1ZGM5NDg3ZDg0NzA0OWQ1ZWFiYjBmYTAzYzhmYicsXG4gICAgICAgICdkMGUzZmE5ZWNhODcyNjkwOTU1OWUwZDc5MjY5MDQ2YmRjNTllYTEwYzcwY2UyYjAyZDQ5OWVjMjI0ZGM3ZjcnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZDUyOGVjZDliNjk2YjU0YzkwN2E5ZWQwNDU0NDdhNzliYjQwOGVjMzliNjhkZjUwNGJiNTFmNDU5YmMzZmZjOScsXG4gICAgICAgICdlZWNmNDEyNTMxMzZlNWY5OTk2NmYyMTg4MWZkNjU2ZWJjNDM0NTQwNWM1MjBkYmMwNjM0NjViNTIxNDA5OTMzJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzQ5MzcwYTRiNWY0MzQxMmVhMjVmNTE0ZThlY2RhZDA1MjY2MTE1ZTRhN2VjYjEzODcyMzE4MDhmOGI0NTk2MycsXG4gICAgICAgICc3NThmM2Y0MWFmZDZlZDQyOGIzMDgxYjA1MTJmZDYyYTU0YzNmM2FmYmI1YjY3NjRiNjUzMDUyYTEyOTQ5YzlhJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzc3ZjIzMDkzNmVlODhjYmJkNzNkZjkzMGQ2NDcwMmVmODgxZDgxMWUwZTE0OThlMmYxYzEzZWIxZmMzNDVkNzQnLFxuICAgICAgICAnOTU4ZWY0MmE3ODg2YjY0MDBhMDgyNjZlOWJhMWIzNzg5NmM5NTMzMGQ5NzA3N2NiYmU4ZWIzYzc2NzFjNjBkNidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdmMmRhYzk5MWNjNGNlNGI5ZWE0NDg4N2U1YzdjMGJjZTU4YzgwMDc0YWI5ZDRkYmFlYjI4NTMxYjc3MzlmNTMwJyxcbiAgICAgICAgJ2UwZGVkYzliM2IyZjhkYWQ0ZGExZjMyZGVjMjUzMWRmOWViNWZiZWIwNTk4ZTRmZDFhMTE3ZGJhNzAzYTNjMzcnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNDYzYjNkOWY2NjI2MjFmYjFiNGJlOGZiYmUyNTIwMTI1YTIxNmNkZmM5ZGFlM2RlYmNiYTQ4NTBjNjkwZDQ1YicsXG4gICAgICAgICc1ZWQ0MzBkNzhjMjk2YzM1NDMxMTQzMDZkZDg2MjJkN2M2MjJlMjdjOTcwYTFkZTMxY2IzNzdiMDFhZjczMDdlJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2YxNmY4MDQyNDRlNDZlMmEwOTIzMmQ0YWZmM2I1OTk3NmI5OGZhYzE0MzI4YTJkMWEzMjQ5NmI0OTk5OGYyNDcnLFxuICAgICAgICAnY2VkYWJkOWI4MjIwM2Y3ZTEzZDIwNmZjZGY0ZTMzZDkyYTZjNTNjMjZlNWNjZTI2ZDY1Nzk5NjJjNGUzMWRmNidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdjYWY3NTQyNzJkYzg0NTYzYjAzNTJiN2ExNDMxMWFmNTVkMjQ1MzE1YWNlMjdjNjUzNjllMTVmNzE1MWQ0MWQxJyxcbiAgICAgICAgJ2NiNDc0NjYwZWYzNWY1ZjJhNDFiNjQzZmE1ZTQ2MDU3NWY0ZmE5Yjc5NjIyMzJhNWMzMmY5MDgzMThhMDQ0NzYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMjYwMGNhNGIyODJjYjk4NmY4NWQwZjE3MDk5NzlkOGI0NGEwOWMwN2NiODZkN2MxMjQ0OTdiYzg2ZjA4MjEyMCcsXG4gICAgICAgICc0MTE5Yjg4NzUzYzE1YmQ2YTY5M2IwM2ZjZGRiYjQ1ZDVhYzZiZTc0YWI1ZjBlZjQ0YjBiZTk0NzVhN2U0YjQwJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzc2MzVjYTcyZDdlODQzMmMzMzhlYzUzY2QxMjIyMGJjMDFjNDg2ODVlMjRmN2RjOGM2MDJhNzc0Njk5OGU0MzUnLFxuICAgICAgICAnOTFiNjQ5NjA5NDg5ZDYxM2QxZDVlNTkwZjc4ZTZkNzRlY2ZjMDYxZDU3MDQ4YmFkOWU3NmYzMDJjNWI5YzYxJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzc1NGUzMjM5ZjMyNTU3MGNkYmJmNGE4N2RlZWU4YTY2YjdmMmIzMzQ3OWQ0NjhmYmMxYTUwNzQzYmY1NmNjMTgnLFxuICAgICAgICAnNjczZmI4NmU1YmRhMzBmYjNjZDBlZDMwNGVhNDlhMDIzZWUzM2QwMTk3YTY5NWQwYzVkOTgwOTNjNTM2NjgzJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2UzZTZiZDEwNzFhMWU5NmFmZjU3ODU5YzgyZDU3MGYwMzMwODAwNjYxZDFjOTUyZjlmZTI2OTQ2OTFkOWI5ZTgnLFxuICAgICAgICAnNTljOWUwYmJhMzk0ZTc2ZjQwYzBhYTU4Mzc5YTNjYjZhNWEyMjgzOTkzZTkwYzQxNjcwMDJhZjQ5MjBlMzdmNSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcxODZiNDgzZDA1NmEwMzM4MjZhZTczZDg4ZjczMjk4NWM0Y2NiMWYzMmJhMzVmNGI0Y2M0N2ZkY2YwNGFhNmViJyxcbiAgICAgICAgJzNiOTUyZDMyYzY3Y2Y3N2UyZTE3NDQ2ZTIwNDE4MGFiMjFmYjgwOTA4OTUxMzhiNGE0YTc5N2Y4NmU4MDg4OGInXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZGY5ZDcwYTZiOTg3NmNlNTQ0Yzk4NTYxZjRiZTRmNzI1NDQyZTZkMmI3MzdkOWM5MWE4MzIxNzI0Y2UwOTYzZicsXG4gICAgICAgICc1NWViMmRhZmQ4NGQ2Y2NkNWY4NjJiNzg1ZGMzOWQ0YWIxNTcyMjI3MjBlZjlkYTIxN2I4YzQ1Y2YyYmEyNDE3J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzVlZGQ1Y2MyM2M1MWU4N2E0OTdjYTgxNWQ1ZGNlMGY4YWI1MjU1NGY4NDllZDg5OTVkZTY0YzVmMzRjZTcxNDMnLFxuICAgICAgICAnZWZhZTljOGRiYzE0MTMwNjYxZThjZWMwMzBjODlhZDBjMTNjNjZjMGQxN2EyOTA1Y2RjNzA2YWI3Mzk5YTg2OCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcyOTA3OThjMmI2NDc2ODMwZGExMmZlMDIyODdlOWU3NzdhYTNmYmExYzM1NWIxN2E3MjJkMzYyZjg0NjE0ZmJhJyxcbiAgICAgICAgJ2UzOGRhNzZkY2Q0NDA2MjE5ODhkMDBiY2Y3OWFmMjVkNWIyOWMwOTRkYjJhMjMxNDZkMDAzYWZkNDE5NDNlN2EnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYWYzYzQyM2E5NWQ5ZjViMzA1NDc1NGVmYTE1MGFjMzljZDI5NTUyZmUzNjAyNTczNjJkZmRlY2VmNDA1M2I0NScsXG4gICAgICAgICdmOThhM2ZkODMxZWIyYjc0OWE5M2IwZTZmMzVjZmI0MGM4Y2Q1YWE2NjdhMTU1ODFiYzJmZWRlZDQ5OGZkOWM2J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzc2NmRiYjI0ZDEzNGU3NDVjY2NhYTI4Yzk5YmYyNzQ5MDZiYjY2YjI2ZGNmOThkZjhkMmZlZDUwZDg4NDI0OWEnLFxuICAgICAgICAnNzQ0YjExNTJlYWNiZTVlMzhkY2M4ODc5ODBkYTM4Yjg5NzU4NGE2NWZhMDZjZWRkMmM5MjRmOTdjYmFjNTk5NidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc1OWRiZjQ2ZjhjOTQ3NTliYTIxMjc3YzMzNzg0ZjQxNjQ1ZjdiNDRmNmM1OTZhNThjZTkyZTY2NjE5MWFiZTNlJyxcbiAgICAgICAgJ2M1MzRhZDQ0MTc1ZmJjMzAwZjRlYTZjZTY0ODMwOWEwNDJjZTczOWE3OTE5Nzk4Y2Q4NWUyMTZjNGEzMDdmNmUnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZjEzYWRhOTUxMDNjNDUzNzMwNWU2OTFlNzRlOWE0YThkZDY0N2U3MTFhOTVlNzNjYjYyZGM2MDE4Y2ZkODdiOCcsXG4gICAgICAgICdlMTM4MTdiNDRlZTE0ZGU2NjNiZjRiYzgwODM0MWYzMjY5NDllMjFhNmE3NWMyNTcwNzc4NDE5YmRhZjU3MzNkJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzc3NTRiNGZhMGU4YWNlZDA2ZDQxNjdhMmM1OWNjYTRjZGExODY5YzA2ZWJhZGZiNjQ4ODU1MDAxNWE4ODUyMmMnLFxuICAgICAgICAnMzBlOTNlODY0ZTY2OWQ4MjIyNGI5NjdjMzAyMGI4ZmE4ZDFlNGUzNTBiNmNiY2M1MzdhNDhiNTc4NDExNjNhMidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc5NDhkY2FkZjU5OTBlMDQ4YWEzODc0ZDQ2YWJlZjlkNzAxODU4Zjk1ZGU4MDQxZDJhNjgyOGM5OWUyMjYyNTE5JyxcbiAgICAgICAgJ2U0OTFhNDI1MzdmNmU1OTdkNWQyOGEzMjI0YjFiYzI1ZGY5MTU0ZWZiZDJlZjFkMmNiYmEyY2FlNTM0N2Q1N2UnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNzk2MjQxNDQ1MGM3NmMxNjg5YzdiNDhmODIwMmVjMzdmYjIyNGNmNWFjMGJmYTE1NzAzMjhhOGEzZDdjNzdhYicsXG4gICAgICAgICcxMDBiNjEwZWM0ZmZiNDc2MGQ1YzFmYzEzM2VmNmY2YjEyNTA3YTA1MWYwNGFjNTc2MGFmYTViMjlkYjgzNDM3J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzM1MTQwODc4MzQ5NjRiNTRiMTViMTYwNjQ0ZDkxNTQ4NWExNjk3NzIyNWI4ODQ3YmIwZGQwODUxMzdlYzQ3Y2EnLFxuICAgICAgICAnZWYwYWZiYjIwNTYyMDU0NDhlMTY1MmM0OGU4MTI3ZmM2MDM5ZTc3YzE1YzIzNzhiN2U3ZDE1YTBkZTI5MzMxMSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkM2NjMzBhZDZiNDgzZTRiYzc5Y2UyYzlkZDhiYzU0OTkzZTk0N2ViOGRmNzg3YjQ0Mjk0M2QzZjdiNTI3ZWFmJyxcbiAgICAgICAgJzhiMzc4YTIyZDgyNzI3OGQ4OWM1ZTliZThmOTUwOGFlM2MyYWQ0NjI5MDM1ODYzMGFmYjM0ZGIwNGVlZGUwYTQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMTYyNGQ4NDc4MDczMjg2MGNlMWM3OGZjYmZlZmUwOGIyYjI5ODIzZGI5MTNmNjQ5Mzk3NWJhMGZmNDg0NzYxMCcsXG4gICAgICAgICc2ODY1MWNmOWI2ZGE5MDNlMDkxNDQ0OGM2Y2Q5ZDRjYTg5Njg3OGY1MjgyYmU0YzhjYzA2ZTJhNDA0MDc4NTc1J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzczM2NlODBkYTk1NWE4YTI2OTAyYzk1NjMzZTYyYTk4NTE5MjQ3NGI1YWYyMDdkYTZkZjdiNGZkNWZjNjFjZDQnLFxuICAgICAgICAnZjU0MzVhMmJkMmJhZGY3ZDQ4NWE0ZDhiOGRiOWZjY2UzZTFlZjhlMDIwMWU0NTc4YzU0NjczYmMxZGM1ZWExZCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcxNWQ5NDQxMjU0OTQ1MDY0Y2YxYTFjMzNiYmQzYjQ5Zjg5NjZjNTA5MjE3MWU2OTllZjI1OGRmYWI4MWMwNDVjJyxcbiAgICAgICAgJ2Q1NmViMzBiNjk0NjNlNzIzNGY1MTM3YjczYjg0MTc3NDM0ODAwYmFjZWJmYzY4NWZjMzdiYmU5ZWZlNDA3MGQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYTFkMGZjZjJlYzlkZTY3NWI2MTIxMzZlNWNlNzBkMjcxYzIxNDE3YzlkMmI4YWFhYWMxMzg1OTlkMDcxNzk0MCcsXG4gICAgICAgICdlZGQ3N2Y1MGJjYjVhM2NhYjJlOTA3MzczMDk2NjdmMjY0MTQ2MmE1NDA3MGYzZDUxOTIxMmQzOWMxOTdhNjI5J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2UyMmZiZTE1YzBhZjhjY2M1NzgwYzA3MzVmODRkYmU5YTc5MGJhZGVlODI0NWMwNmM3Y2EzNzMzMWNiMzY5ODAnLFxuICAgICAgICAnYTg1NWJhYmFkNWNkNjBjODhiNDMwYTY5ZjUzYTFhN2EzODI4OTE1NDk2NDc5OWJlNDNkMDZkNzdkMzFkYTA2J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzMxMTA5MWRkOTg2MGU4ZTIwZWUxMzQ3M2MxMTU1ZjVmNjk2MzVlMzk0NzA0ZWFhNzQwMDk0NTIyNDZjZmE5YjMnLFxuICAgICAgICAnNjZkYjY1NmY4N2QxZjA0ZmZmZDFmMDQ3ODhjMDY4MzA4NzFlYzVhNjRmZWVlNjg1YmQ4MGYwYjEyODZkODM3NCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICczNGMxZmQwNGQzMDFiZTg5YjMxYzA0NDJkM2U2YWMyNDg4MzkyOGI0NWE5MzQwNzgxODY3ZDQyMzJlYzJkYmRmJyxcbiAgICAgICAgJzk0MTQ2ODVlOTdiMWI1OTU0YmQ0NmY3MzAxNzQxMzZkNTdmMWNlZWI0ODc0NDNkYzUzMjE4NTdiYTczYWJlZSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdmMjE5ZWE1ZDZiNTQ3MDFjMWMxNGRlNWI1NTdlYjQyYThkMTNmM2FiYmNkMDhhZmZjYzJhNWU2YjA0OWI4ZDYzJyxcbiAgICAgICAgJzRjYjk1OTU3ZTgzZDQwYjBmNzNhZjQ1NDRjY2NmNmIxZjRiMDhkM2MwN2IyN2ZiOGQ4YzI5NjJhNDAwNzY2ZDEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZDdiODc0MGY3NGE4ZmJhYWIxZjY4M2RiOGY0NWRlMjY1NDNhNTQ5MGJjYTYyNzA4NzIzNjkxMjQ2OWEwYjQ0OCcsXG4gICAgICAgICdmYTc3OTY4MTI4ZDljOTJlZTEwMTBmMzM3YWQ0NzE3ZWZmMTVkYjVlZDNjMDQ5YjM0MTFlMDMxNWVhYTQ1OTNiJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzMyZDMxYzIyMmY4ZjZmMGVmODZmN2M5OGQzYTMzMzVlYWQ1YmNkMzJhYmRkOTQyODlmZTRkMzA5MWFhODI0YmYnLFxuICAgICAgICAnNWYzMDMyZjU4OTIxNTZlMzljY2QzZDc5MTViOWUxZGEyZTZkYWM5ZTZmMjZlOTYxMTE4ZDE0Yjg0NjJlMTY2MSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc3NDYxZjM3MTkxNGFiMzI2NzEwNDVhMTU1ZDk4MzFlYTg3OTNkNzdjZDU5NTkyYzQzNDBmODZjYmMxODM0N2I1JyxcbiAgICAgICAgJzhlYzBiYTIzOGI5NmJlYzBjYmRkZGNhZTBhYTQ0MjU0MmVlZTFmZjUwYzk4NmVhNmIzOTg0N2IzY2MwOTJmZjYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZWUwNzlhZGIxZGYxODYwMDc0MzU2YTI1YWEzODIwNmE2ZDcxNmIyYzNlNjc0NTNkMjg3Njk4YmFkN2IyYjJkNicsXG4gICAgICAgICc4ZGMyNDEyYWFmZTNiZTVjNGM1ZjM3ZTBlY2M1ZjlmNmE0NDY5ODlhZjA0YzRlMjVlYmFhYzQ3OWVjMWM4YzFlJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzE2ZWM5M2U0NDdlYzgzZjA0NjdiMTgzMDJlZTYyMGY3ZTY1ZGUzMzE4NzRjOWRjNzJiZmQ4NjE2YmE5ZGE2YjUnLFxuICAgICAgICAnNWU0NjMxMTUwZTYyZmI0MGQwZThjMmE3Y2E1ODA0YTM5ZDU4MTg2YTUwZTQ5NzEzOTYyNjc3OGUyNWIwNjc0ZCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlYWE1Zjk4MGMyNDVmNmYwMzg5NzgyOTBhZmE3MGI2YmQ4ODU1ODk3Zjk4YjZhYTQ4NWI5NjA2NWQ1MzdiZDk5JyxcbiAgICAgICAgJ2Y2NWY1ZDNlMjkyYzJlMDgxOWE1MjgzOTFjOTk0NjI0ZDc4NDg2OWQ3ZTZlYTY3ZmIxODA0MTAyNGVkYzA3ZGMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNzhjOTQwNzU0NGFjMTMyNjkyZWUxOTEwYTAyNDM5OTU4YWUwNDg3NzE1MTM0MmVhOTZjNGI2YjM1YTQ5ZjUxJyxcbiAgICAgICAgJ2YzZTAzMTkxNjllYjliODVkNTQwNDc5NTUzOWE1ZTY4ZmExZmJkNTgzYzA2NGQyNDYyYjY3NWYxOTRhM2RkYjQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNDk0ZjRiZTIxOWExYTc3MDE2ZGNkODM4NDMxYWVhMDAwMWNkYzhhZTdhNmZjNjg4NzI2NTc4ZDk3MDI4NTdhNScsXG4gICAgICAgICc0MjI0MmE5NjkyODNhNWYzMzliYTdmMDc1ZTM2YmEyYWY5MjVjZTMwZDc2N2VkNmU1NWY0YjAzMTg4MGQ1NjJjJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2E1OThhODAzMGRhNmQ4NmM2YmM3ZjJmNTE0NGVhNTQ5ZDI4MjExZWE1OGZhYTcwZWJmNGMxZTY2NWMxZmU5YjUnLFxuICAgICAgICAnMjA0YjVkNmY4NDgyMmMzMDdlNGI0YTcxNDA3MzdhZWMyM2ZjNjNiNjViMzVmODZhMTAwMjZkYmQyZDg2NGU2YidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdjNDE5MTYzNjVhYmIyYjVkMDkxOTJmNWYyZGJlYWZlYzIwOGYwMjBmMTI1NzBhMTg0ZGJhZGMzZTU4NTk1OTk3JyxcbiAgICAgICAgJzRmMTQzNTFkMDA4N2VmYTQ5ZDI0NWIzMjg5ODQ5ODlkNWNhZjk0NTBmMzRiZmMwZWQxNmU5NmI1OGZhOTkxMydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc4NDFkNjA2M2E1ODZmYTQ3NWE3MjQ2MDRkYTAzYmM1YjkyYTJlMGQyZTBhMzZhY2ZlNGM3M2E1NTE0NzQyODgxJyxcbiAgICAgICAgJzczODY3ZjU5YzA2NTllODE5MDRmOWExYzc1NDM2OThlNjI1NjJkNjc0NGMxNjljZTdhMzZkZTAxYThkNjE1NCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc1ZTk1YmIzOTlhNjk3MWQzNzYwMjY5NDdmODliZGUyZjI4MmIzMzgxMDkyOGJlNGRlZDExMmFjNGQ3MGUyMGQ1JyxcbiAgICAgICAgJzM5ZjIzZjM2NjgwOTA4NWJlZWJmYzcxMTgxMzEzNzc1YTk5YzlhZWQ3ZDhiYTM4YjE2MTM4NGM3NDYwMTI4NjUnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMzZlNDY0MWE1Mzk0OGZkNDc2YzM5ZjhhOTlmZDk3NGU1ZWMwNzU2NGI1MzE1ZDhiZjk5NDcxYmNhMGVmMmY2NicsXG4gICAgICAgICdkMjQyNGIxYjFhYmU0ZWI4MTY0MjI3YjA4NWM5YWE5NDU2ZWExMzQ5M2ZkNTYzZTA2ZmQ1MWNmNTY5NGM3OGZjJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzMzNjU4MWVhN2JmYmJiMjkwYzE5MWEyZjUwN2E0MWNmNTY0Mzg0MjE3MGU5MTRmYWVhYjI3YzJjNTc5ZjcyNicsXG4gICAgICAgICdlYWQxMjE2ODU5NWZlMWJlOTkyNTIxMjliNmU1NmIzMzkxZjdhYjE0MTBjZDFlMGVmM2RjZGNhYmQyZmRhMjI0J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzhhYjg5ODE2ZGFkZmQ2YjZhMWYyNjM0ZmNmMDBlYzg0MDM3ODEwMjVlZDY4OTBjNDg0OTc0MjcwNmJkNDNlZGUnLFxuICAgICAgICAnNmZkY2VmMDlmMmY2ZDBhMDQ0ZTY1NGFlZjYyNDEzNmY1MDNkNDU5YzNlODk4NDU4NThhNDdhOTEyOWNkZDI0ZSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcxZTMzZjFhNzQ2YzljNTc3ODEzMzM0NGQ5Mjk5ZmNhYTIwYjA5MzhlOGFjZmYyNTQ0YmI0MDI4NGI4YzVmYjk0JyxcbiAgICAgICAgJzYwNjYwMjU3ZGQxMWIzYWE5YzhlZDYxOGQyNGVkZmYyMzA2ZDMyMGYxZDAzMDEwZTMzYTdkMjA1N2YzYjNiNidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc4NWI3YzFkY2IzY2VjMWI3ZWU3ZjMwZGVkNzlkZDIwYTBlZDFmNGNjMThjYmNmY2ZhNDEwMzYxZmQ4ZjA4ZjMxJyxcbiAgICAgICAgJzNkOThhOWNkZDAyNmRkNDNmMzkwNDhmMjVhODg0N2Y0ZmNhZmFkMTg5NWQ3YTYzM2M2ZmVkM2MzNWU5OTk1MTEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMjlkZjlmYmQ4ZDllNDY1MDkyNzVmNGIxMjVkNmQ0NWQ3ZmJlOWEzYjg3OGE3YWY4NzJhMjgwMDY2MWFjNWY1MScsXG4gICAgICAgICdiNGM0ZmU5OWM3NzVhNjA2ZTJkODg2MjE3OTEzOWZmZGE2MWRjODYxYzAxOWU1NWNkMjg3NmViMmEyN2Q4NGInXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYTBiMWNhZTA2YjBhODQ3YTNmZWE2ZTY3MWFhZjhhZGZkZmU1OGNhMmY3NjgxMDVjODA4MmIyZTQ0OWZjZTI1MicsXG4gICAgICAgICdhZTQzNDEwMmVkZGUwOTU4ZWM0YjE5ZDkxN2E2YTI4ZTZiNzJkYTE4MzRhZmYwZTY1MGYwNDk1MDNhMjk2Y2YyJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzRlOGNlYWZiOWIzZTlhMTM2ZGM3ZmY2N2U4NDAyOTViNDk5ZGZiM2IyMTMzZTRiYTExM2YyZTRjMGUxMjFlNScsXG4gICAgICAgICdjZjIxNzQxMThjOGI2ZDdhNGI0OGY2ZDUzNGNlNWM3OTQyMmMwODZhNjM0NjA1MDJiODI3Y2U2MmEzMjY2ODNjJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2QyNGE0NGUwNDdlMTliNmY1YWZiODFjN2NhMmY2OTA4MGE1MDc2Njg5YTAxMDkxOWY0MjcyNWMyYjc4OWEzM2InLFxuICAgICAgICAnNmZiOGQ1NTkxYjQ2NmY4ZmM2M2RiNTBmMWMwZjFjNjkwMTNmOTk2ODg3YjgyNDRkMmNkZWM0MTdhZmVhOGZhMydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlYTAxNjA2YTdhNmM5Y2RkMjQ5ZmRmY2ZhY2I5OTU4NDAwMWVkZDI4YWJiYWI3N2I1MTA0ZTk4ZThlM2IzNWQ0JyxcbiAgICAgICAgJzMyMmFmNDkwOGM3MzEyYjBjZmJmZTM2OWY3YTdiM2NkYjdkNDQ5NGJjMjgyMzcwMGNmZDY1MjE4OGEzZWE5OGQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYWY4YWRkYmYyYjY2MWM4YTZjNjMyODY1NWViOTY2NTEyNTIwMDdkOGM1ZWEzMWJlNGFkMTk2ZGU4Y2UyMTMxZicsXG4gICAgICAgICc2NzQ5ZTY3YzAyOWI4NWY1MmEwMzRlYWZkMDk2ODM2YjI1MjA4MTg2ODBlMjZhYzhmM2RmYmNkYjcxNzQ5NzAwJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2UzYWUxOTc0NTY2Y2EwNmNjNTE2ZDQ3ZTBmYjE2NWE2NzRhM2RhYmNmY2ExNWU3MjJmMGUzNDUwZjQ1ODg5JyxcbiAgICAgICAgJzJhZWFiZTdlNDUzMTUxMDExNjIxN2YwN2JmNGQwNzMwMGRlOTdlNDg3NGY4MWY1MzM0MjBhNzJlZWIwYmQ2YTQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNTkxZWUzNTUzMTNkOTk3MjFjZjY5OTNmZmVkMWUzZTMwMTk5M2ZmM2VkMjU4ODAyMDc1ZWE4Y2VkMzk3ZTI0NicsXG4gICAgICAgICdiMGVhNTU4YTExM2MzMGJlYTYwZmM0Nzc1NDYwYzc5MDFmZjBiMDUzZDI1Y2EyYmRlZWU5OGYxYTRiZTVkMTk2J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzExMzk2ZDU1ZmRhNTRjNDlmMTlhYTk3MzE4ZDhkYTYxZmE4NTg0ZTQ3YjA4NDk0NTA3N2NmMDMyNTViNTI5ODQnLFxuICAgICAgICAnOTk4Yzc0YThjZDQ1YWMwMTI4OWQ1ODMzYTdiZWI0NzQ0ZmY1MzZiMDFiMjU3YmU0YzU3NjdiZWE5M2VhNTdhNCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICczYzVkMmExYmEzOWM1YTE3OTAwMDA3MzhjOWUwYzQwYjhkY2RmZDU0Njg3NTRiNjQwNTU0MDE1N2UwMTdhYTdhJyxcbiAgICAgICAgJ2IyMjg0Mjc5OTk1YTM0ZTJmOWQ0ZGU3Mzk2ZmMxOGI4MGY5YjhiOWZkZDI3MGY2NjYxZjc5Y2E0YzgxYmQyNTcnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnY2M4NzA0YjhhNjBhMGRlZmEzYTk5YTcyOTlmMmU5YzNmYmMzOTVhZmIwNGFjMDc4NDI1ZWY4YTE3OTNjYzAzMCcsXG4gICAgICAgICdiZGQ0NjAzOWZlZWQxNzg4MWQxZTA4NjJkYjM0N2Y4Y2YzOTViNzRmYzRiY2RjNGU5NDBiNzRlM2FjMWYxYjEzJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2M1MzNlNGY3ZWE4NTU1YWFjZDk3NzdhYzVjYWQyOWI5N2RkNGRlZmNjYzUzZWU3ZWEyMDQxMTliMjg4OWIxOTcnLFxuICAgICAgICAnNmYwYTI1NmJjNWVmZGY0MjlhMmZiNjI0MmYxYTQzYTJkOWI5MjViYjRhNGIzYTI2YmI4ZTBmNDVlYjU5NjA5NidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdjMTRmOGYyY2NiMjdkNmYxMDlmNmQwOGQwM2NjOTZhNjliYThjMzRlZWMwN2JiY2Y1NjZkNDhlMzNkYTY1OTMnLFxuICAgICAgICAnYzM1OWQ2OTIzYmIzOThmN2ZkNDQ3M2UxNmZlMWMyODQ3NWI3NDBkZDA5ODA3NWU2YzBlODY0OTExM2RjM2EzOCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdhNmNiYzMwNDZiYzZhNDUwYmFjMjQ3ODlmYTE3MTE1YTRjOTczOWVkNzVmOGYyMWNlNDQxZjcyZTBiOTBlNmVmJyxcbiAgICAgICAgJzIxYWU3ZjQ2ODBlODg5YmIxMzA2MTllMmMwZjk1YTM2MGNlYjU3M2M3MDYwMzEzOTg2MmFmZDYxN2ZhOWI5ZidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICczNDdkNmQ5YTAyYzQ4OTI3ZWJmYjg2YzEzNTliMWNhZjEzMGEzYzAyNjdkMTFjZTYzNDRiMzlmOTlkNDNjYzM4JyxcbiAgICAgICAgJzYwZWE3ZjYxYTM1MzUyNGQxYzk4N2Y2ZWNlYzkyZjA4NmQ1NjVhYjY4Nzg3MGNiMTI2ODlmZjFlMzFjNzQ0NDgnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZGE2NTQ1ZDIxODFkYjhkOTgzZjdkY2IzNzVlZjU4NjZkNDdjNjdiMWJmMzFjOGNmODU1ZWY3NDM3YjcyNjU2YScsXG4gICAgICAgICc0OWI5NjcxNWFiNjg3OGE3OWU3OGYwN2NlNTY4MGM1ZDY2NzMwNTFiNDkzNWJkODk3ZmVhODI0Yjc3ZGMyMDhhJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2M0MDc0N2NjOWQwMTJjYjFhMTNiODE0ODMwOWM2ZGU3ZWMyNWQ2OTQ1ZDY1NzE0NmI5ZDU5OTRiOGZlYjExMTEnLFxuICAgICAgICAnNWNhNTYwNzUzYmUyYTEyZmM2ZGU2Y2FmMmNiNDg5NTY1ZGI5MzYxNTZiOTUxNGUxYmI1ZTgzMDM3ZTBmYTJkNCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc0ZTQyYzhlYzgyYzk5Nzk4Y2NmM2E2MTBiZTg3MGU3ODMzOGM3ZjcxMzM0OGJkMzRjODIwM2VmNDAzN2YzNTAyJyxcbiAgICAgICAgJzc1NzFkNzRlZTVlMGZiOTJhN2E4YjMzYTA3NzgzMzQxYTU0OTIxNDRjYzU0YmNjNDBhOTQ0NzM2OTM2MDY0MzcnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMzc3NWFiNzA4OWJjNmFmODIzYWJhMmUxYWY3MGIyMzZkMjUxY2FkYjBjODY3NDMyODc1MjJhMWIzYjBkZWRlYScsXG4gICAgICAgICdiZTUyZDEwN2JjZmEwOWQ4YmNiOTczNmE4MjhjZmE3ZmFjOGRiMTdiZjdhNzZhMmM0MmFkOTYxNDA5MDE4Y2Y3J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2NlZTMxY2JmN2UzNGVjMzc5ZDk0ZmI4MTRkM2Q3NzVhZDk1NDU5NWQxMzE0YmE4ODQ2OTU5ZTNlODJmNzRlMjYnLFxuICAgICAgICAnOGZkNjRhMTRjMDZiNTg5YzI2Yjk0N2FlMmJjZjZiZmEwMTQ5ZWYwYmUxNGVkNGQ4MGY0NDhhMDFjNDNiMWM2ZCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdiNGY5ZWFlYTA5YjY5MTc2MTlmNmVhNmE0ZWI1NDY0ZWZkZGI1OGZkNDViMWViZWZjZGMxYTAxZDA4YjQ3OTg2JyxcbiAgICAgICAgJzM5ZTVjOTkyNWI1YTU0YjA3NDMzYTRmMThjNjE3MjZmOGJiMTMxYzAxMmNhNTQyZWIyNGE4YWMwNzIwMDY4MmEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZDQyNjNkZmMzZDJkZjkyM2EwMTc5YTQ4OTY2ZDMwY2U4NGUyNTE1YWZjM2RjY2MxYjc3OTA3NzkyZWJjYzYwZScsXG4gICAgICAgICc2MmRmYWYwN2EwZjc4ZmViMzBlMzBkNjI5NTg1M2NlMTg5ZTEyNzc2MGFkNmNmN2ZhZTE2NGUxMjJhMjA4ZDU0J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzQ4NDU3NTI0ODIwZmE2NWE0ZjhkMzVlYjY5MzA4NTdjMDAzMmFjYzBhNGEyZGU0MjIyMzNlZWRhODk3NjEyYzQnLFxuICAgICAgICAnMjVhNzQ4YWIzNjc5NzlkOTg3MzNjMzhhMWZhMWMyZTdkYzZjYzA3ZGIyZDYwYTlhZTdhNzZhYWE0OWJkMGY3NydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkZmVlZWYxODgxMTAxZjJjYjExNjQ0ZjNhMmFmZGZjMjA0NWUxOTkxOTE1MjkyM2YzNjdhMTc2N2MxMWNjZWRhJyxcbiAgICAgICAgJ2VjZmI3MDU2Y2YxZGUwNDJmOTQyMGJhYjM5Njc5M2MwYzM5MGJkZTc0YjRiYmRmZjE2YTgzYWUwOWE5YTc1MTcnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNmQ3ZWY2YjE3NTQzZjgzNzNjNTczZjQ0ZTFmMzg5ODM1ZDg5YmNiYzYwNjJjZWQzNmM4MmRmODNiOGZhZTg1OScsXG4gICAgICAgICdjZDQ1MGVjMzM1NDM4OTg2ZGZlZmExMGM1N2ZlYTliY2M1MjFhMDk1OWIyZDgwYmJmNzRiMTkwZGNhNzEyZDEwJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2U3NTYwNWQ1OTEwMmE1YTI2ODQ1MDBkM2I5OTFmMmUzZjNjODhiOTMyMjU1NDcwMzVhZjI1YWY2NmUwNDU0MWYnLFxuICAgICAgICAnZjVjNTQ3NTRhOGY3MWVlNTQwYjliNDg3Mjg0NzNlMzE0ZjcyOWFjNTMwOGIwNjkzODM2MDk5MGUyYmZhZDEyNSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlYjk4NjYwZjRjNGRmYWEwNmEyYmU0NTNkNTAyMGJjOTlhMGMyZTYwYWJlMzg4NDU3ZGQ0M2ZlZmIxZWQ2MjBjJyxcbiAgICAgICAgJzZjYjlhODg3NmQ5Y2I4NTIwNjA5YWYzYWRkMjZjZDIwYTBhN2NkOGE5NDExMTMxY2U4NWY0NDEwMDA5OTIyM2UnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMTNlODdiMDI3ZDg1MTRkMzU5MzlmMmU2ODkyYjE5OTIyMTU0NTk2OTQxODg4MzM2ZGMzNTYzZTNiOGRiYTk0MicsXG4gICAgICAgICdmZWY1YTNjNjgwNTlhNmRlYzVkNjI0MTE0YmYxZTkxYWFjMmI5ZGE1NjhkNmFiZWIyNTcwZDU1NjQ2YjhhZGYxJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2VlMTYzMDI2ZTlmZDZmZTAxN2MzOGYwNmE1YmU2ZmMxMjU0MjRiMzcxY2UyNzA4ZTdiZjQ0OTE2OTFlNTc2NGEnLFxuICAgICAgICAnMWFjYjI1MGYyNTVkZDYxYzQzZDk0Y2NjNjcwZDBmNThmNDlhZTNmYTE1Yjk2NjIzZTU0MzBkYTBhZDZjNjJiMidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdiMjY4ZjVlZjlhZDUxZTRkNzhkZTNhNzUwYzJkYzg5YjFlNjI2ZDQzNTA1ODY3OTk5OTMyZTVkYjMzYWYzZDgwJyxcbiAgICAgICAgJzVmMzEwZDRiM2M5OWI5ZWJiMTlmNzdkNDFjMWRlZTAxOGNmMGQzNGZkNDE5MTYxNDAwM2U5NDVhMTIxNmU0MjMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZmYwN2YzMTE4YTlkZjAzNWU5ZmFkODVlYjZjN2JmZTQyYjAyZjAxY2E5OWNlZWEzYmY3ZmZkYmE5M2M0NzUwZCcsXG4gICAgICAgICc0MzgxMzZkNjAzZTg1OGEzYTVjNDQwYzM4ZWNjYmFkZGMxZDI5NDIxMTRlMmVkZGQ0NzQwZDA5OGNlZDFmMGQ4J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzhkOGI5ODU1YzdjMDUyYTM0MTQ2ZmQyMGZmYjY1OGJlYTRiOWY2OWUwZDgyNWViZWMxNmU4YzNjZTJiNTI2YTEnLFxuICAgICAgICAnY2RiNTU5ZWVkYzJkNzlmOTI2YmFmNDRmYjg0ZWE0ZDQ0YmNmNTBmZWU1MWQ3Y2ViMzBlMmU3ZjQ2MzAzNjc1OCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc1MmRiMGI1Mzg0ZGZiZjA1YmZhOWQ0NzJkN2FlMjZkZmU0Yjg1MWNlY2E5MWIxZWJhNTQyNjMxODBkYTMyYjYzJyxcbiAgICAgICAgJ2MzYjk5N2QwNTBlZTVkNDIzZWJhZjY2YTZkYjlmNTdiMzE4MGM5MDI4NzU2NzlkZTkyNGI2OWQ4NGE3YjM3NSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlNjJmOTQ5MGQzZDUxZGE2Mzk1ZWZkMjRlODA5MTljYzdkMGYyOWMzZjNmYTQ4YzZmZmY1NDNiZWNiZDQzMzUyJyxcbiAgICAgICAgJzZkODlhZDdiYTQ4NzZiMGIyMmMyY2EyODBjNjgyODYyZjM0MmM4NTkxZjFkYWY1MTcwZTA3YmZkOWNjYWZhN2QnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnN2YzMGVhMjQ3NmIzOTliNDk1NzUwOWM4OGY3N2QwMTkxYWZhMmZmNWNiN2IxNGZkNmQ4ZTdkNjVhYWFiMTE5MycsXG4gICAgICAgICdjYTVlZjdkNGIyMzFjOTRjM2IxNTM4OWE1ZjYzMTFlOWRhZmY3YmI2N2IxMDNlOTg4MGVmNGJmZjYzN2FjYWVjJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzUwOThmZjFlMWQ5ZjE0ZmI0NmEyMTBmYWRhNmM5MDNmZWYwZmI3YjRhMWRkMWQ5YWM2MGEwMzYxODAwYjdhMDAnLFxuICAgICAgICAnOTczMTE0MWQ4MWZjOGY4MDg0ZDM3YzZlNzU0MjAwNmIzZWUxYjQwZDYwZGZlNTM2MmE1YjEzMmZkMTdkZGMwJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzMyYjc4YzdkZTllZTUxMmE3Mjg5NWJlNmI5Y2JlZmE2ZTJmM2M0Y2NjZTQ0NWM5NmI5ZjJjODFlMjc3OGFkNTgnLFxuICAgICAgICAnZWUxODQ5ZjUxM2RmNzFlMzJlZmMzODk2ZWUyODI2MGM3M2JiODA1NDdhZTIyNzViYTQ5NzIzNzc5NGM4NzUzYydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlMmNiNzRmZGRjOGU5ZmJjZDA3NmVlZjJhN2M3MmIwY2UzN2Q1MGYwODI2OWRmYzA3NGI1ODE1NTA1NDdhNGY3JyxcbiAgICAgICAgJ2QzYWEyZWQ3MWM5ZGQyMjQ3YTYyZGYwNjI3MzZlYjBiYWRkZWE5ZTM2MTIyZDJiZTg2NDFhYmNiMDA1Y2M0YTQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnODQzODQ0NzU2NmQ0ZDdiZWRhZGMyOTk0OTZhYjM1NzQyNjAwOWEzNWYyMzVjYjE0MWJlMGQ5OWNkMTBhZTNhOCcsXG4gICAgICAgICdjNGUxMDIwOTE2OTgwYTRkYTVkMDFhYzVlNmFkMzMwNzM0ZWYwZDc5MDY2MzFjNGYyMzkwNDI2YjJlZGQ3OTFmJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzQxNjJkNDg4Yjg5NDAyMDM5YjU4NGM2ZmM2YzMwODg3MDU4N2Q5YzQ2ZjY2MGI4NzhhYjY1YzgyYzcxMWQ2N2UnLFxuICAgICAgICAnNjcxNjNlOTAzMjM2Mjg5Zjc3NmYyMmMyNWZiOGEzYWZjMTczMmYyYjg0YjRlOTVkYmRhNDdhZTVhMDg1MjY0OSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICczZmFkM2ZhODRjYWYwZjM0ZjBmODliZmQyZGNmNTRmYzE3NWQ3NjdhZWMzZTUwNjg0ZjNiYTRhNGJmNWY2ODNkJyxcbiAgICAgICAgJ2NkMWJjN2NiNmNjNDA3YmIyZjBjYTY0N2M3MThhNzMwY2Y3MTg3MmU3ZDBkMmE1M2ZhMjBlZmNkZmU2MTgyNidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc2NzRmMjYwMGEzMDA3YTAwNTY4YzFhN2NlMDVkMDgxNmMxZmI4NGJmMTM3MDc5OGYxYzY5NTMyZmFlYjFhODZiJyxcbiAgICAgICAgJzI5OWQyMWY5NDEzZjMzYjNlZGY0M2IyNTcwMDQ1ODBiNzBkYjU3ZGEwYjE4MjI1OWUwOWVlY2M2OWUwZDM4YTUnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZDMyZjRkYTU0YWRlNzRhYmI4MWI4MTVhZDFmYjNiMjYzZDgyZDZjNjkyNzE0YmNmZjg3ZDI5YmQ1ZWU5ZjA4ZicsXG4gICAgICAgICdmOTQyOWU3MzhiOGU1M2I5NjhlOTkwMTZjMDU5NzA3NzgyZTE0ZjQ1MzUzNTlkNTgyZmM0MTY5MTBiM2VlYTg3J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzMwZTRlNjcwNDM1Mzg1NTU2ZTU5MzY1NzEzNTg0NWQzNmZiYjY5MzFmNzJiMDhjYjFlZDk1NGYxZTNjZTNmZjYnLFxuICAgICAgICAnNDYyZjliY2U2MTk4OTg2Mzg0OTkzNTAxMTNiYmM5YjEwYTg3OGQzNWRhNzA3NDBkYzY5NWE1NTllYjg4ZGI3YidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdiZTIwNjIwMDNjNTFjYzMwMDQ2ODI5MDQzMzBlNGRlZTdmM2RjZDEwYjAxZTU4MGJmMTk3MWIwNGQ0Y2FkMjk3JyxcbiAgICAgICAgJzYyMTg4YmM0OWQ2MWU1NDI4NTczZDQ4YTc0ZTFjNjU1YjFjNjEwOTA5MDU2ODJhMGQ1NTU4ZWQ3MmRjY2I5YmMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnOTMxNDQ0MjNhY2UzNDUxZWQyOWUwZmI5YWMyYWYyMTFjYjZlODRhNjAxZGY1OTkzYzQxOTg1OWZmZjVkZjA0YScsXG4gICAgICAgICc3YzEwZGZiMTY0YzM0MjVmNWM3MWEzZjlkNzk5MjAzOGYxMDY1MjI0ZjcyYmI5ZDFkOTAyYTZkMTMwMzdiNDdjJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2IwMTVmODA0NGY1ZmNiZGNmMjFjYTI2ZDZjMzRmYjgxOTc4MjkyMDVjN2I3ZDJhN2NiNjY0MThjMTU3YjExMmMnLFxuICAgICAgICAnYWI4YzFlMDg2ZDA0ZTgxMzc0NGE2NTViMmRmOGQ1ZjgzYjNjZGM2ZmFhMzA4OGMxZDNhZWExNDU0ZTNhMWQ1ZidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkNWU5ZTFkYTY0OWQ5N2Q4OWU0ODY4MTE3YTQ2NWEzYTRmOGExOGRlNTdhMTQwZDM2YjNmMmFmMzQxYTIxYjUyJyxcbiAgICAgICAgJzRjYjA0NDM3ZjM5MWVkNzMxMTFhMTNjYzFkNGRkMGRiMTY5MzQ2NWMyMjQwNDgwZDg5NTVlODU5MmYyNzQ0N2EnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZDNhZTQxMDQ3ZGQ3Y2EwNjVkYmY4ZWQ3N2I5OTI0Mzk5ODMwMDVjZDcyZTE2ZDZmOTk2YTUzMTZkMzY5NjZiYicsXG4gICAgICAgICdiZDFhZWIyMWFkMjJlYmIyMmExMGYwMzAzNDE3YzZkOTY0ZjhjZGQ3ZGYwYWNhNjE0YjEwZGMxNGQxMjVhYzQ2J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzQ2M2UyNzYzZDg4NWY5NThmYzY2Y2RkMjI4MDBmMGE0ODcxOTdkMGE4MmUzNzdiNDlmODBhZjg3Yzg5N2IwNjUnLFxuICAgICAgICAnYmZlZmFjZGIwZTVkMGZkN2RmM2EzMTFhOTRkZTA2MmIyNmI4MGM2MWZiYzk3NTA4Yjc5OTkyNjcxZWY3Y2E3ZidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc3OTg1ZmRmZDEyN2MwNTY3YzZmNTNlYzFiYjYzZWMzMTU4ZTU5N2M0MGJmZTc0N2M4M2NkZGZjOTEwNjQxOTE3JyxcbiAgICAgICAgJzYwM2MxMmRhZjNkOTg2MmVmMmIyNWZlMWRlMjg5YWVkMjRlZDI5MWUwZWM2NzA4NzAzYTViZDU2N2YzMmVkMDMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNzRhMWFkNmI1Zjc2ZTM5ZGIyZGQyNDk0MTBlYWM3Zjk5ZTc0YzU5Y2I4M2QyZDBlZDVmZjE1NDNkYTc3MDNlOScsXG4gICAgICAgICdjYzYxNTdlZjE4YzljNjNjZDYxOTNkODM2MzFiYmVhMDA5M2UwOTY4OTQyZThjMzNkNTczN2ZkNzkwZTBkYjA4J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzMwNjgyYTUwNzAzMzc1ZjYwMmQ0MTY2NjRiYTE5YjdmYzliYWI0MmM3Mjc0NzQ2M2E3MWQwODk2YjIyZjZkYTMnLFxuICAgICAgICAnNTUzZTA0ZjZiMDE4YjRmYTZjOGYzOWU3ZjMxMWQzMTc2MjkwZDBlMGYxOWNhNzNmMTc3MTRkOTk3N2EyMmZmOCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc5ZTIxNThmMGQ3YzBkNWYyNmMzNzkxZWZlZmE3OTU5NzY1NGU3YTJiMjQ2NGY1MmIxZWU2YzEzNDc3NjllZjU3JyxcbiAgICAgICAgJzcxMmZjZGQxYjkwNTNmMDkwMDNhMzQ4MWZhNzc2MmU5ZmZkN2M4ZWYzNWEzODUwOWUyZmJmMjYyOTAwODM3MydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcxNzZlMjY5ODlhNDNjOWNmZWJhNDAyOWMyMDI1MzhjMjgxNzJlNTY2ZTNjNGZjZTczMjI4NTdmM2JlMzI3ZDY2JyxcbiAgICAgICAgJ2VkOGNjOWQwNGIyOWViODc3ZDI3MGI0ODc4ZGM0M2MxOWFlZmQzMWY0ZWVlMDllZTdiNDc4MzRjMWZhNGIxYzMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNzVkNDZlZmVhMzc3MWU2ZTY4YWJiODlhMTNhZDc0N2VjZjE4OTIzOTNkZmM0ZjFiNzAwNDc4OGM1MDM3NGRhOCcsXG4gICAgICAgICc5ODUyMzkwYTk5NTA3Njc5ZmQwYjg2ZmQyYjM5YTg2OGQ3ZWZjMjIxNTEzNDZlMWEzY2E0NzI2NTg2YTZiZWQ4J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzgwOWEyMGM2N2Q2NDkwMGZmYjY5OGM0YzgyNWY2ZDVmMjMxMGZiMDQ1MWM4NjkzNDViNzMxOWY2NDU2MDU3MjEnLFxuICAgICAgICAnOWU5OTQ5ODBkOTkxN2UyMmI3NmIwNjE5MjdmYTA0MTQzZDA5NmNjYzU0OTYzZTZhNWViZmE1ZjNmOGUyODZjMSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcxYjM4OTAzYTQzZjdmMTE0ZWQ0NTAwYjRlYWM3MDgzZmRlZmVjZTFjZjI5YzYzNTI4ZDU2MzQ0NmY5NzJjMTgwJyxcbiAgICAgICAgJzQwMzZlZGM5MzFhNjBhZTg4OTM1M2Y3N2ZkNTNkZTRhMjcwOGIyNmI2ZjVkYTcyYWQzMzk0MTE5ZGFmNDA4ZjknXG4gICAgICBdXG4gICAgXVxuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSBleHBvcnRzO1xudmFyIGJuID0gcmVxdWlyZSgnYm4uanMnKTtcblxudXRpbHMuYXNzZXJ0ID0gZnVuY3Rpb24gYXNzZXJ0KHZhbCwgbXNnKSB7XG4gIGlmICghdmFsKVxuICAgIHRocm93IG5ldyBFcnJvcihtc2cgfHwgJ0Fzc2VydGlvbiBmYWlsZWQnKTtcbn07XG5cbmZ1bmN0aW9uIHRvQXJyYXkobXNnLCBlbmMpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkobXNnKSlcbiAgICByZXR1cm4gbXNnLnNsaWNlKCk7XG4gIGlmICghbXNnKVxuICAgIHJldHVybiBbXTtcbiAgdmFyIHJlcyA9IFtdO1xuICBpZiAodHlwZW9mIG1zZyAhPT0gJ3N0cmluZycpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKylcbiAgICAgIHJlc1tpXSA9IG1zZ1tpXSB8IDA7XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICBpZiAoIWVuYykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYyA9IG1zZy5jaGFyQ29kZUF0KGkpO1xuICAgICAgdmFyIGhpID0gYyA+PiA4O1xuICAgICAgdmFyIGxvID0gYyAmIDB4ZmY7XG4gICAgICBpZiAoaGkpXG4gICAgICAgIHJlcy5wdXNoKGhpLCBsbyk7XG4gICAgICBlbHNlXG4gICAgICAgIHJlcy5wdXNoKGxvKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZW5jID09PSAnaGV4Jykge1xuICAgIG1zZyA9IG1zZy5yZXBsYWNlKC9bXmEtejAtOV0rL2lnLCAnJyk7XG4gICAgaWYgKG1zZy5sZW5ndGggJSAyICE9PSAwKVxuICAgICAgbXNnID0gJzAnICsgbXNnO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSArPSAyKVxuICAgICAgcmVzLnB1c2gocGFyc2VJbnQobXNnW2ldICsgbXNnW2kgKyAxXSwgMTYpKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxudXRpbHMudG9BcnJheSA9IHRvQXJyYXk7XG5cbmZ1bmN0aW9uIHplcm8yKHdvcmQpIHtcbiAgaWYgKHdvcmQubGVuZ3RoID09PSAxKVxuICAgIHJldHVybiAnMCcgKyB3b3JkO1xuICBlbHNlXG4gICAgcmV0dXJuIHdvcmQ7XG59XG51dGlscy56ZXJvMiA9IHplcm8yO1xuXG5mdW5jdGlvbiB0b0hleChtc2cpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKylcbiAgICByZXMgKz0gemVybzIobXNnW2ldLnRvU3RyaW5nKDE2KSk7XG4gIHJldHVybiByZXM7XG59XG51dGlscy50b0hleCA9IHRvSGV4O1xuXG51dGlscy5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUoYXJyLCBlbmMpIHtcbiAgaWYgKGVuYyA9PT0gJ2hleCcpXG4gICAgcmV0dXJuIHRvSGV4KGFycik7XG4gIGVsc2VcbiAgICByZXR1cm4gYXJyO1xufTtcblxuLy8gUmVwcmVzZW50IG51bSBpbiBhIHctTkFGIGZvcm1cbmZ1bmN0aW9uIGdldE5BRihudW0sIHcpIHtcbiAgdmFyIG5hZiA9IFtdO1xuICB2YXIgd3MgPSAxIDw8ICh3ICsgMSk7XG4gIHZhciBrID0gbnVtLmNsb25lKCk7XG4gIHdoaWxlIChrLmNtcG4oMSkgPj0gMCkge1xuICAgIHZhciB6O1xuICAgIGlmIChrLmlzT2RkKCkpIHtcbiAgICAgIHZhciBtb2QgPSBrLmFuZGxuKHdzIC0gMSk7XG4gICAgICBpZiAobW9kID4gKHdzID4+IDEpIC0gMSlcbiAgICAgICAgeiA9ICh3cyA+PiAxKSAtIG1vZDtcbiAgICAgIGVsc2VcbiAgICAgICAgeiA9IG1vZDtcbiAgICAgIGsuaXN1Ym4oeik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHogPSAwO1xuICAgIH1cbiAgICBuYWYucHVzaCh6KTtcblxuICAgIC8vIE9wdGltaXphdGlvbiwgc2hpZnQgYnkgd29yZCBpZiBwb3NzaWJsZVxuICAgIHZhciBzaGlmdCA9IChrLmNtcG4oMCkgIT09IDAgJiYgay5hbmRsbih3cyAtIDEpID09PSAwKSA/ICh3ICsgMSkgOiAxO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgc2hpZnQ7IGkrKylcbiAgICAgIG5hZi5wdXNoKDApO1xuICAgIGsuaXVzaHJuKHNoaWZ0KTtcbiAgfVxuXG4gIHJldHVybiBuYWY7XG59XG51dGlscy5nZXROQUYgPSBnZXROQUY7XG5cbi8vIFJlcHJlc2VudCBrMSwgazIgaW4gYSBKb2ludCBTcGFyc2UgRm9ybVxuZnVuY3Rpb24gZ2V0SlNGKGsxLCBrMikge1xuICB2YXIganNmID0gW1xuICAgIFtdLFxuICAgIFtdXG4gIF07XG5cbiAgazEgPSBrMS5jbG9uZSgpO1xuICBrMiA9IGsyLmNsb25lKCk7XG4gIHZhciBkMSA9IDA7XG4gIHZhciBkMiA9IDA7XG4gIHdoaWxlIChrMS5jbXBuKC1kMSkgPiAwIHx8IGsyLmNtcG4oLWQyKSA+IDApIHtcblxuICAgIC8vIEZpcnN0IHBoYXNlXG4gICAgdmFyIG0xNCA9IChrMS5hbmRsbigzKSArIGQxKSAmIDM7XG4gICAgdmFyIG0yNCA9IChrMi5hbmRsbigzKSArIGQyKSAmIDM7XG4gICAgaWYgKG0xNCA9PT0gMylcbiAgICAgIG0xNCA9IC0xO1xuICAgIGlmIChtMjQgPT09IDMpXG4gICAgICBtMjQgPSAtMTtcbiAgICB2YXIgdTE7XG4gICAgaWYgKChtMTQgJiAxKSA9PT0gMCkge1xuICAgICAgdTEgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbTggPSAoazEuYW5kbG4oNykgKyBkMSkgJiA3O1xuICAgICAgaWYgKChtOCA9PT0gMyB8fCBtOCA9PT0gNSkgJiYgbTI0ID09PSAyKVxuICAgICAgICB1MSA9IC1tMTQ7XG4gICAgICBlbHNlXG4gICAgICAgIHUxID0gbTE0O1xuICAgIH1cbiAgICBqc2ZbMF0ucHVzaCh1MSk7XG5cbiAgICB2YXIgdTI7XG4gICAgaWYgKChtMjQgJiAxKSA9PT0gMCkge1xuICAgICAgdTIgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbTggPSAoazIuYW5kbG4oNykgKyBkMikgJiA3O1xuICAgICAgaWYgKChtOCA9PT0gMyB8fCBtOCA9PT0gNSkgJiYgbTE0ID09PSAyKVxuICAgICAgICB1MiA9IC1tMjQ7XG4gICAgICBlbHNlXG4gICAgICAgIHUyID0gbTI0O1xuICAgIH1cbiAgICBqc2ZbMV0ucHVzaCh1Mik7XG5cbiAgICAvLyBTZWNvbmQgcGhhc2VcbiAgICBpZiAoMiAqIGQxID09PSB1MSArIDEpXG4gICAgICBkMSA9IDEgLSBkMTtcbiAgICBpZiAoMiAqIGQyID09PSB1MiArIDEpXG4gICAgICBkMiA9IDEgLSBkMjtcbiAgICBrMS5pdXNocm4oMSk7XG4gICAgazIuaXVzaHJuKDEpO1xuICB9XG5cbiAgcmV0dXJuIGpzZjtcbn1cbnV0aWxzLmdldEpTRiA9IGdldEpTRjtcblxuZnVuY3Rpb24gY2FjaGVkUHJvcGVydHkob2JqLCBjb21wdXRlcikge1xuICB2YXIgbmFtZSA9IGNvbXB1dGVyLm5hbWU7XG4gIHZhciBrZXkgPSAnXycgKyBuYW1lO1xuICBvYmoucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24gY2FjaGVkUHJvcGVydHkoKSB7XG4gICAgcmV0dXJuIHRoaXNba2V5XSAhPT0gdW5kZWZpbmVkID8gdGhpc1trZXldIDpcbiAgICAgICAgICAgdGhpc1trZXldID0gY29tcHV0ZXIuY2FsbCh0aGlzKTtcbiAgfTtcbn1cbnV0aWxzLmNhY2hlZFByb3BlcnR5ID0gY2FjaGVkUHJvcGVydHk7XG5cbmZ1bmN0aW9uIHBhcnNlQnl0ZXMoYnl0ZXMpIHtcbiAgcmV0dXJuIHR5cGVvZiBieXRlcyA9PT0gJ3N0cmluZycgPyB1dGlscy50b0FycmF5KGJ5dGVzLCAnaGV4JykgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVzO1xufVxudXRpbHMucGFyc2VCeXRlcyA9IHBhcnNlQnl0ZXM7XG5cbmZ1bmN0aW9uIGludEZyb21MRShieXRlcykge1xuICByZXR1cm4gbmV3IGJuKGJ5dGVzLCAnaGV4JywgJ2xlJyk7XG59XG51dGlscy5pbnRGcm9tTEUgPSBpbnRGcm9tTEU7XG5cbiIsInZhciByO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJhbmQobGVuKSB7XG4gIGlmICghcilcbiAgICByID0gbmV3IFJhbmQobnVsbCk7XG5cbiAgcmV0dXJuIHIuZ2VuZXJhdGUobGVuKTtcbn07XG5cbmZ1bmN0aW9uIFJhbmQocmFuZCkge1xuICB0aGlzLnJhbmQgPSByYW5kO1xufVxubW9kdWxlLmV4cG9ydHMuUmFuZCA9IFJhbmQ7XG5cblJhbmQucHJvdG90eXBlLmdlbmVyYXRlID0gZnVuY3Rpb24gZ2VuZXJhdGUobGVuKSB7XG4gIHJldHVybiB0aGlzLl9yYW5kKGxlbik7XG59O1xuXG5pZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcpIHtcbiAgaWYgKHdpbmRvdy5jcnlwdG8gJiYgd2luZG93LmNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgICAvLyBNb2Rlcm4gYnJvd3NlcnNcbiAgICBSYW5kLnByb3RvdHlwZS5fcmFuZCA9IGZ1bmN0aW9uIF9yYW5kKG4pIHtcbiAgICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheShuKTtcbiAgICAgIHdpbmRvdy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGFycik7XG4gICAgICByZXR1cm4gYXJyO1xuICAgIH07XG4gIH0gZWxzZSBpZiAod2luZG93Lm1zQ3J5cHRvICYmIHdpbmRvdy5tc0NyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgICAvLyBJRVxuICAgIFJhbmQucHJvdG90eXBlLl9yYW5kID0gZnVuY3Rpb24gX3JhbmQobikge1xuICAgICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KG4pO1xuICAgICAgd2luZG93Lm1zQ3J5cHRvLmdldFJhbmRvbVZhbHVlcyhhcnIpO1xuICAgICAgcmV0dXJuIGFycjtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8vIE9sZCBqdW5rXG4gICAgUmFuZC5wcm90b3R5cGUuX3JhbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkIHlldCcpO1xuICAgIH07XG4gIH1cbn0gZWxzZSB7XG4gIC8vIE5vZGUuanMgb3IgV2ViIHdvcmtlclxuICB0cnkge1xuICAgIHZhciBjcnlwdG8gPSByZXF1aXJlKCdjcnknICsgJ3B0bycpO1xuXG4gICAgUmFuZC5wcm90b3R5cGUuX3JhbmQgPSBmdW5jdGlvbiBfcmFuZChuKSB7XG4gICAgICByZXR1cm4gY3J5cHRvLnJhbmRvbUJ5dGVzKG4pO1xuICAgIH07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBFbXVsYXRlIGNyeXB0byBBUEkgdXNpbmcgcmFuZHlcbiAgICBSYW5kLnByb3RvdHlwZS5fcmFuZCA9IGZ1bmN0aW9uIF9yYW5kKG4pIHtcbiAgICAgIHZhciByZXMgPSBuZXcgVWludDhBcnJheShuKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzLmxlbmd0aDsgaSsrKVxuICAgICAgICByZXNbaV0gPSB0aGlzLnJhbmQuZ2V0Qnl0ZSgpO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICB9XG59XG4iLCJ2YXIgaGFzaCA9IGV4cG9ydHM7XG5cbmhhc2gudXRpbHMgPSByZXF1aXJlKCcuL2hhc2gvdXRpbHMnKTtcbmhhc2guY29tbW9uID0gcmVxdWlyZSgnLi9oYXNoL2NvbW1vbicpO1xuaGFzaC5zaGEgPSByZXF1aXJlKCcuL2hhc2gvc2hhJyk7XG5oYXNoLnJpcGVtZCA9IHJlcXVpcmUoJy4vaGFzaC9yaXBlbWQnKTtcbmhhc2guaG1hYyA9IHJlcXVpcmUoJy4vaGFzaC9obWFjJyk7XG5cbi8vIFByb3h5IGhhc2ggZnVuY3Rpb25zIHRvIHRoZSBtYWluIG9iamVjdFxuaGFzaC5zaGExID0gaGFzaC5zaGEuc2hhMTtcbmhhc2guc2hhMjU2ID0gaGFzaC5zaGEuc2hhMjU2O1xuaGFzaC5zaGEyMjQgPSBoYXNoLnNoYS5zaGEyMjQ7XG5oYXNoLnNoYTM4NCA9IGhhc2guc2hhLnNoYTM4NDtcbmhhc2guc2hhNTEyID0gaGFzaC5zaGEuc2hhNTEyO1xuaGFzaC5yaXBlbWQxNjAgPSBoYXNoLnJpcGVtZC5yaXBlbWQxNjA7XG4iLCJ2YXIgaGFzaCA9IHJlcXVpcmUoJy4uL2hhc2gnKTtcbnZhciB1dGlscyA9IGhhc2gudXRpbHM7XG52YXIgYXNzZXJ0ID0gdXRpbHMuYXNzZXJ0O1xuXG5mdW5jdGlvbiBCbG9ja0hhc2goKSB7XG4gIHRoaXMucGVuZGluZyA9IG51bGw7XG4gIHRoaXMucGVuZGluZ1RvdGFsID0gMDtcbiAgdGhpcy5ibG9ja1NpemUgPSB0aGlzLmNvbnN0cnVjdG9yLmJsb2NrU2l6ZTtcbiAgdGhpcy5vdXRTaXplID0gdGhpcy5jb25zdHJ1Y3Rvci5vdXRTaXplO1xuICB0aGlzLmhtYWNTdHJlbmd0aCA9IHRoaXMuY29uc3RydWN0b3IuaG1hY1N0cmVuZ3RoO1xuICB0aGlzLnBhZExlbmd0aCA9IHRoaXMuY29uc3RydWN0b3IucGFkTGVuZ3RoIC8gODtcbiAgdGhpcy5lbmRpYW4gPSAnYmlnJztcblxuICB0aGlzLl9kZWx0YTggPSB0aGlzLmJsb2NrU2l6ZSAvIDg7XG4gIHRoaXMuX2RlbHRhMzIgPSB0aGlzLmJsb2NrU2l6ZSAvIDMyO1xufVxuZXhwb3J0cy5CbG9ja0hhc2ggPSBCbG9ja0hhc2g7XG5cbkJsb2NrSGFzaC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKG1zZywgZW5jKSB7XG4gIC8vIENvbnZlcnQgbWVzc2FnZSB0byBhcnJheSwgcGFkIGl0LCBhbmQgam9pbiBpbnRvIDMyYml0IGJsb2Nrc1xuICBtc2cgPSB1dGlscy50b0FycmF5KG1zZywgZW5jKTtcbiAgaWYgKCF0aGlzLnBlbmRpbmcpXG4gICAgdGhpcy5wZW5kaW5nID0gbXNnO1xuICBlbHNlXG4gICAgdGhpcy5wZW5kaW5nID0gdGhpcy5wZW5kaW5nLmNvbmNhdChtc2cpO1xuICB0aGlzLnBlbmRpbmdUb3RhbCArPSBtc2cubGVuZ3RoO1xuXG4gIC8vIEVub3VnaCBkYXRhLCB0cnkgdXBkYXRpbmdcbiAgaWYgKHRoaXMucGVuZGluZy5sZW5ndGggPj0gdGhpcy5fZGVsdGE4KSB7XG4gICAgbXNnID0gdGhpcy5wZW5kaW5nO1xuXG4gICAgLy8gUHJvY2VzcyBwZW5kaW5nIGRhdGEgaW4gYmxvY2tzXG4gICAgdmFyIHIgPSBtc2cubGVuZ3RoICUgdGhpcy5fZGVsdGE4O1xuICAgIHRoaXMucGVuZGluZyA9IG1zZy5zbGljZShtc2cubGVuZ3RoIC0gciwgbXNnLmxlbmd0aCk7XG4gICAgaWYgKHRoaXMucGVuZGluZy5sZW5ndGggPT09IDApXG4gICAgICB0aGlzLnBlbmRpbmcgPSBudWxsO1xuXG4gICAgbXNnID0gdXRpbHMuam9pbjMyKG1zZywgMCwgbXNnLmxlbmd0aCAtIHIsIHRoaXMuZW5kaWFuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkgKz0gdGhpcy5fZGVsdGEzMilcbiAgICAgIHRoaXMuX3VwZGF0ZShtc2csIGksIGkgKyB0aGlzLl9kZWx0YTMyKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuQmxvY2tIYXNoLnByb3RvdHlwZS5kaWdlc3QgPSBmdW5jdGlvbiBkaWdlc3QoZW5jKSB7XG4gIHRoaXMudXBkYXRlKHRoaXMuX3BhZCgpKTtcbiAgYXNzZXJ0KHRoaXMucGVuZGluZyA9PT0gbnVsbCk7XG5cbiAgcmV0dXJuIHRoaXMuX2RpZ2VzdChlbmMpO1xufTtcblxuQmxvY2tIYXNoLnByb3RvdHlwZS5fcGFkID0gZnVuY3Rpb24gcGFkKCkge1xuICB2YXIgbGVuID0gdGhpcy5wZW5kaW5nVG90YWw7XG4gIHZhciBieXRlcyA9IHRoaXMuX2RlbHRhODtcbiAgdmFyIGsgPSBieXRlcyAtICgobGVuICsgdGhpcy5wYWRMZW5ndGgpICUgYnl0ZXMpO1xuICB2YXIgcmVzID0gbmV3IEFycmF5KGsgKyB0aGlzLnBhZExlbmd0aCk7XG4gIHJlc1swXSA9IDB4ODA7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgazsgaSsrKVxuICAgIHJlc1tpXSA9IDA7XG5cbiAgLy8gQXBwZW5kIGxlbmd0aFxuICBsZW4gPDw9IDM7XG4gIGlmICh0aGlzLmVuZGlhbiA9PT0gJ2JpZycpIHtcbiAgICBmb3IgKHZhciB0ID0gODsgdCA8IHRoaXMucGFkTGVuZ3RoOyB0KyspXG4gICAgICByZXNbaSsrXSA9IDA7XG5cbiAgICByZXNbaSsrXSA9IDA7XG4gICAgcmVzW2krK10gPSAwO1xuICAgIHJlc1tpKytdID0gMDtcbiAgICByZXNbaSsrXSA9IDA7XG4gICAgcmVzW2krK10gPSAobGVuID4+PiAyNCkgJiAweGZmO1xuICAgIHJlc1tpKytdID0gKGxlbiA+Pj4gMTYpICYgMHhmZjtcbiAgICByZXNbaSsrXSA9IChsZW4gPj4+IDgpICYgMHhmZjtcbiAgICByZXNbaSsrXSA9IGxlbiAmIDB4ZmY7XG4gIH0gZWxzZSB7XG4gICAgcmVzW2krK10gPSBsZW4gJiAweGZmO1xuICAgIHJlc1tpKytdID0gKGxlbiA+Pj4gOCkgJiAweGZmO1xuICAgIHJlc1tpKytdID0gKGxlbiA+Pj4gMTYpICYgMHhmZjtcbiAgICByZXNbaSsrXSA9IChsZW4gPj4+IDI0KSAmIDB4ZmY7XG4gICAgcmVzW2krK10gPSAwO1xuICAgIHJlc1tpKytdID0gMDtcbiAgICByZXNbaSsrXSA9IDA7XG4gICAgcmVzW2krK10gPSAwO1xuXG4gICAgZm9yICh2YXIgdCA9IDg7IHQgPCB0aGlzLnBhZExlbmd0aDsgdCsrKVxuICAgICAgcmVzW2krK10gPSAwO1xuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG4iLCJ2YXIgaG1hYyA9IGV4cG9ydHM7XG5cbnZhciBoYXNoID0gcmVxdWlyZSgnLi4vaGFzaCcpO1xudmFyIHV0aWxzID0gaGFzaC51dGlscztcbnZhciBhc3NlcnQgPSB1dGlscy5hc3NlcnQ7XG5cbmZ1bmN0aW9uIEhtYWMoaGFzaCwga2V5LCBlbmMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEhtYWMpKVxuICAgIHJldHVybiBuZXcgSG1hYyhoYXNoLCBrZXksIGVuYyk7XG4gIHRoaXMuSGFzaCA9IGhhc2g7XG4gIHRoaXMuYmxvY2tTaXplID0gaGFzaC5ibG9ja1NpemUgLyA4O1xuICB0aGlzLm91dFNpemUgPSBoYXNoLm91dFNpemUgLyA4O1xuICB0aGlzLmlubmVyID0gbnVsbDtcbiAgdGhpcy5vdXRlciA9IG51bGw7XG5cbiAgdGhpcy5faW5pdCh1dGlscy50b0FycmF5KGtleSwgZW5jKSk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEhtYWM7XG5cbkhtYWMucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gaW5pdChrZXkpIHtcbiAgLy8gU2hvcnRlbiBrZXksIGlmIG5lZWRlZFxuICBpZiAoa2V5Lmxlbmd0aCA+IHRoaXMuYmxvY2tTaXplKVxuICAgIGtleSA9IG5ldyB0aGlzLkhhc2goKS51cGRhdGUoa2V5KS5kaWdlc3QoKTtcbiAgYXNzZXJ0KGtleS5sZW5ndGggPD0gdGhpcy5ibG9ja1NpemUpO1xuXG4gIC8vIEFkZCBwYWRkaW5nIHRvIGtleVxuICBmb3IgKHZhciBpID0ga2V5Lmxlbmd0aDsgaSA8IHRoaXMuYmxvY2tTaXplOyBpKyspXG4gICAga2V5LnB1c2goMCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXkubGVuZ3RoOyBpKyspXG4gICAga2V5W2ldIF49IDB4MzY7XG4gIHRoaXMuaW5uZXIgPSBuZXcgdGhpcy5IYXNoKCkudXBkYXRlKGtleSk7XG5cbiAgLy8gMHgzNiBeIDB4NWMgPSAweDZhXG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5Lmxlbmd0aDsgaSsrKVxuICAgIGtleVtpXSBePSAweDZhO1xuICB0aGlzLm91dGVyID0gbmV3IHRoaXMuSGFzaCgpLnVwZGF0ZShrZXkpO1xufTtcblxuSG1hYy5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKG1zZywgZW5jKSB7XG4gIHRoaXMuaW5uZXIudXBkYXRlKG1zZywgZW5jKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5IbWFjLnByb3RvdHlwZS5kaWdlc3QgPSBmdW5jdGlvbiBkaWdlc3QoZW5jKSB7XG4gIHRoaXMub3V0ZXIudXBkYXRlKHRoaXMuaW5uZXIuZGlnZXN0KCkpO1xuICByZXR1cm4gdGhpcy5vdXRlci5kaWdlc3QoZW5jKTtcbn07XG4iLCJ2YXIgaGFzaCA9IHJlcXVpcmUoJy4uL2hhc2gnKTtcbnZhciB1dGlscyA9IGhhc2gudXRpbHM7XG5cbnZhciByb3RsMzIgPSB1dGlscy5yb3RsMzI7XG52YXIgc3VtMzIgPSB1dGlscy5zdW0zMjtcbnZhciBzdW0zMl8zID0gdXRpbHMuc3VtMzJfMztcbnZhciBzdW0zMl80ID0gdXRpbHMuc3VtMzJfNDtcbnZhciBCbG9ja0hhc2ggPSBoYXNoLmNvbW1vbi5CbG9ja0hhc2g7XG5cbmZ1bmN0aW9uIFJJUEVNRDE2MCgpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJJUEVNRDE2MCkpXG4gICAgcmV0dXJuIG5ldyBSSVBFTUQxNjAoKTtcblxuICBCbG9ja0hhc2guY2FsbCh0aGlzKTtcblxuICB0aGlzLmggPSBbIDB4Njc0NTIzMDEsIDB4ZWZjZGFiODksIDB4OThiYWRjZmUsIDB4MTAzMjU0NzYsIDB4YzNkMmUxZjAgXTtcbiAgdGhpcy5lbmRpYW4gPSAnbGl0dGxlJztcbn1cbnV0aWxzLmluaGVyaXRzKFJJUEVNRDE2MCwgQmxvY2tIYXNoKTtcbmV4cG9ydHMucmlwZW1kMTYwID0gUklQRU1EMTYwO1xuXG5SSVBFTUQxNjAuYmxvY2tTaXplID0gNTEyO1xuUklQRU1EMTYwLm91dFNpemUgPSAxNjA7XG5SSVBFTUQxNjAuaG1hY1N0cmVuZ3RoID0gMTkyO1xuUklQRU1EMTYwLnBhZExlbmd0aCA9IDY0O1xuXG5SSVBFTUQxNjAucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUobXNnLCBzdGFydCkge1xuICB2YXIgQSA9IHRoaXMuaFswXTtcbiAgdmFyIEIgPSB0aGlzLmhbMV07XG4gIHZhciBDID0gdGhpcy5oWzJdO1xuICB2YXIgRCA9IHRoaXMuaFszXTtcbiAgdmFyIEUgPSB0aGlzLmhbNF07XG4gIHZhciBBaCA9IEE7XG4gIHZhciBCaCA9IEI7XG4gIHZhciBDaCA9IEM7XG4gIHZhciBEaCA9IEQ7XG4gIHZhciBFaCA9IEU7XG4gIGZvciAodmFyIGogPSAwOyBqIDwgODA7IGorKykge1xuICAgIHZhciBUID0gc3VtMzIoXG4gICAgICByb3RsMzIoXG4gICAgICAgIHN1bTMyXzQoQSwgZihqLCBCLCBDLCBEKSwgbXNnW3Jbal0gKyBzdGFydF0sIEsoaikpLFxuICAgICAgICBzW2pdKSxcbiAgICAgIEUpO1xuICAgIEEgPSBFO1xuICAgIEUgPSBEO1xuICAgIEQgPSByb3RsMzIoQywgMTApO1xuICAgIEMgPSBCO1xuICAgIEIgPSBUO1xuICAgIFQgPSBzdW0zMihcbiAgICAgIHJvdGwzMihcbiAgICAgICAgc3VtMzJfNChBaCwgZig3OSAtIGosIEJoLCBDaCwgRGgpLCBtc2dbcmhbal0gKyBzdGFydF0sIEtoKGopKSxcbiAgICAgICAgc2hbal0pLFxuICAgICAgRWgpO1xuICAgIEFoID0gRWg7XG4gICAgRWggPSBEaDtcbiAgICBEaCA9IHJvdGwzMihDaCwgMTApO1xuICAgIENoID0gQmg7XG4gICAgQmggPSBUO1xuICB9XG4gIFQgPSBzdW0zMl8zKHRoaXMuaFsxXSwgQywgRGgpO1xuICB0aGlzLmhbMV0gPSBzdW0zMl8zKHRoaXMuaFsyXSwgRCwgRWgpO1xuICB0aGlzLmhbMl0gPSBzdW0zMl8zKHRoaXMuaFszXSwgRSwgQWgpO1xuICB0aGlzLmhbM10gPSBzdW0zMl8zKHRoaXMuaFs0XSwgQSwgQmgpO1xuICB0aGlzLmhbNF0gPSBzdW0zMl8zKHRoaXMuaFswXSwgQiwgQ2gpO1xuICB0aGlzLmhbMF0gPSBUO1xufTtcblxuUklQRU1EMTYwLnByb3RvdHlwZS5fZGlnZXN0ID0gZnVuY3Rpb24gZGlnZXN0KGVuYykge1xuICBpZiAoZW5jID09PSAnaGV4JylcbiAgICByZXR1cm4gdXRpbHMudG9IZXgzMih0aGlzLmgsICdsaXR0bGUnKTtcbiAgZWxzZVxuICAgIHJldHVybiB1dGlscy5zcGxpdDMyKHRoaXMuaCwgJ2xpdHRsZScpO1xufTtcblxuZnVuY3Rpb24gZihqLCB4LCB5LCB6KSB7XG4gIGlmIChqIDw9IDE1KVxuICAgIHJldHVybiB4IF4geSBeIHo7XG4gIGVsc2UgaWYgKGogPD0gMzEpXG4gICAgcmV0dXJuICh4ICYgeSkgfCAoKH54KSAmIHopO1xuICBlbHNlIGlmIChqIDw9IDQ3KVxuICAgIHJldHVybiAoeCB8ICh+eSkpIF4gejtcbiAgZWxzZSBpZiAoaiA8PSA2MylcbiAgICByZXR1cm4gKHggJiB6KSB8ICh5ICYgKH56KSk7XG4gIGVsc2VcbiAgICByZXR1cm4geCBeICh5IHwgKH56KSk7XG59XG5cbmZ1bmN0aW9uIEsoaikge1xuICBpZiAoaiA8PSAxNSlcbiAgICByZXR1cm4gMHgwMDAwMDAwMDtcbiAgZWxzZSBpZiAoaiA8PSAzMSlcbiAgICByZXR1cm4gMHg1YTgyNzk5OTtcbiAgZWxzZSBpZiAoaiA8PSA0NylcbiAgICByZXR1cm4gMHg2ZWQ5ZWJhMTtcbiAgZWxzZSBpZiAoaiA8PSA2MylcbiAgICByZXR1cm4gMHg4ZjFiYmNkYztcbiAgZWxzZVxuICAgIHJldHVybiAweGE5NTNmZDRlO1xufVxuXG5mdW5jdGlvbiBLaChqKSB7XG4gIGlmIChqIDw9IDE1KVxuICAgIHJldHVybiAweDUwYTI4YmU2O1xuICBlbHNlIGlmIChqIDw9IDMxKVxuICAgIHJldHVybiAweDVjNGRkMTI0O1xuICBlbHNlIGlmIChqIDw9IDQ3KVxuICAgIHJldHVybiAweDZkNzAzZWYzO1xuICBlbHNlIGlmIChqIDw9IDYzKVxuICAgIHJldHVybiAweDdhNmQ3NmU5O1xuICBlbHNlXG4gICAgcmV0dXJuIDB4MDAwMDAwMDA7XG59XG5cbnZhciByID0gW1xuICAwLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgMTEsIDEyLCAxMywgMTQsIDE1LFxuICA3LCA0LCAxMywgMSwgMTAsIDYsIDE1LCAzLCAxMiwgMCwgOSwgNSwgMiwgMTQsIDExLCA4LFxuICAzLCAxMCwgMTQsIDQsIDksIDE1LCA4LCAxLCAyLCA3LCAwLCA2LCAxMywgMTEsIDUsIDEyLFxuICAxLCA5LCAxMSwgMTAsIDAsIDgsIDEyLCA0LCAxMywgMywgNywgMTUsIDE0LCA1LCA2LCAyLFxuICA0LCAwLCA1LCA5LCA3LCAxMiwgMiwgMTAsIDE0LCAxLCAzLCA4LCAxMSwgNiwgMTUsIDEzXG5dO1xuXG52YXIgcmggPSBbXG4gIDUsIDE0LCA3LCAwLCA5LCAyLCAxMSwgNCwgMTMsIDYsIDE1LCA4LCAxLCAxMCwgMywgMTIsXG4gIDYsIDExLCAzLCA3LCAwLCAxMywgNSwgMTAsIDE0LCAxNSwgOCwgMTIsIDQsIDksIDEsIDIsXG4gIDE1LCA1LCAxLCAzLCA3LCAxNCwgNiwgOSwgMTEsIDgsIDEyLCAyLCAxMCwgMCwgNCwgMTMsXG4gIDgsIDYsIDQsIDEsIDMsIDExLCAxNSwgMCwgNSwgMTIsIDIsIDEzLCA5LCA3LCAxMCwgMTQsXG4gIDEyLCAxNSwgMTAsIDQsIDEsIDUsIDgsIDcsIDYsIDIsIDEzLCAxNCwgMCwgMywgOSwgMTFcbl07XG5cbnZhciBzID0gW1xuICAxMSwgMTQsIDE1LCAxMiwgNSwgOCwgNywgOSwgMTEsIDEzLCAxNCwgMTUsIDYsIDcsIDksIDgsXG4gIDcsIDYsIDgsIDEzLCAxMSwgOSwgNywgMTUsIDcsIDEyLCAxNSwgOSwgMTEsIDcsIDEzLCAxMixcbiAgMTEsIDEzLCA2LCA3LCAxNCwgOSwgMTMsIDE1LCAxNCwgOCwgMTMsIDYsIDUsIDEyLCA3LCA1LFxuICAxMSwgMTIsIDE0LCAxNSwgMTQsIDE1LCA5LCA4LCA5LCAxNCwgNSwgNiwgOCwgNiwgNSwgMTIsXG4gIDksIDE1LCA1LCAxMSwgNiwgOCwgMTMsIDEyLCA1LCAxMiwgMTMsIDE0LCAxMSwgOCwgNSwgNlxuXTtcblxudmFyIHNoID0gW1xuICA4LCA5LCA5LCAxMSwgMTMsIDE1LCAxNSwgNSwgNywgNywgOCwgMTEsIDE0LCAxNCwgMTIsIDYsXG4gIDksIDEzLCAxNSwgNywgMTIsIDgsIDksIDExLCA3LCA3LCAxMiwgNywgNiwgMTUsIDEzLCAxMSxcbiAgOSwgNywgMTUsIDExLCA4LCA2LCA2LCAxNCwgMTIsIDEzLCA1LCAxNCwgMTMsIDEzLCA3LCA1LFxuICAxNSwgNSwgOCwgMTEsIDE0LCAxNCwgNiwgMTQsIDYsIDksIDEyLCA5LCAxMiwgNSwgMTUsIDgsXG4gIDgsIDUsIDEyLCA5LCAxMiwgNSwgMTQsIDYsIDgsIDEzLCA2LCA1LCAxNSwgMTMsIDExLCAxMVxuXTtcbiIsInZhciBoYXNoID0gcmVxdWlyZSgnLi4vaGFzaCcpO1xudmFyIHV0aWxzID0gaGFzaC51dGlscztcbnZhciBhc3NlcnQgPSB1dGlscy5hc3NlcnQ7XG5cbnZhciByb3RyMzIgPSB1dGlscy5yb3RyMzI7XG52YXIgcm90bDMyID0gdXRpbHMucm90bDMyO1xudmFyIHN1bTMyID0gdXRpbHMuc3VtMzI7XG52YXIgc3VtMzJfNCA9IHV0aWxzLnN1bTMyXzQ7XG52YXIgc3VtMzJfNSA9IHV0aWxzLnN1bTMyXzU7XG52YXIgcm90cjY0X2hpID0gdXRpbHMucm90cjY0X2hpO1xudmFyIHJvdHI2NF9sbyA9IHV0aWxzLnJvdHI2NF9sbztcbnZhciBzaHI2NF9oaSA9IHV0aWxzLnNocjY0X2hpO1xudmFyIHNocjY0X2xvID0gdXRpbHMuc2hyNjRfbG87XG52YXIgc3VtNjQgPSB1dGlscy5zdW02NDtcbnZhciBzdW02NF9oaSA9IHV0aWxzLnN1bTY0X2hpO1xudmFyIHN1bTY0X2xvID0gdXRpbHMuc3VtNjRfbG87XG52YXIgc3VtNjRfNF9oaSA9IHV0aWxzLnN1bTY0XzRfaGk7XG52YXIgc3VtNjRfNF9sbyA9IHV0aWxzLnN1bTY0XzRfbG87XG52YXIgc3VtNjRfNV9oaSA9IHV0aWxzLnN1bTY0XzVfaGk7XG52YXIgc3VtNjRfNV9sbyA9IHV0aWxzLnN1bTY0XzVfbG87XG52YXIgQmxvY2tIYXNoID0gaGFzaC5jb21tb24uQmxvY2tIYXNoO1xuXG52YXIgc2hhMjU2X0sgPSBbXG4gIDB4NDI4YTJmOTgsIDB4NzEzNzQ0OTEsIDB4YjVjMGZiY2YsIDB4ZTliNWRiYTUsXG4gIDB4Mzk1NmMyNWIsIDB4NTlmMTExZjEsIDB4OTIzZjgyYTQsIDB4YWIxYzVlZDUsXG4gIDB4ZDgwN2FhOTgsIDB4MTI4MzViMDEsIDB4MjQzMTg1YmUsIDB4NTUwYzdkYzMsXG4gIDB4NzJiZTVkNzQsIDB4ODBkZWIxZmUsIDB4OWJkYzA2YTcsIDB4YzE5YmYxNzQsXG4gIDB4ZTQ5YjY5YzEsIDB4ZWZiZTQ3ODYsIDB4MGZjMTlkYzYsIDB4MjQwY2ExY2MsXG4gIDB4MmRlOTJjNmYsIDB4NGE3NDg0YWEsIDB4NWNiMGE5ZGMsIDB4NzZmOTg4ZGEsXG4gIDB4OTgzZTUxNTIsIDB4YTgzMWM2NmQsIDB4YjAwMzI3YzgsIDB4YmY1OTdmYzcsXG4gIDB4YzZlMDBiZjMsIDB4ZDVhNzkxNDcsIDB4MDZjYTYzNTEsIDB4MTQyOTI5NjcsXG4gIDB4MjdiNzBhODUsIDB4MmUxYjIxMzgsIDB4NGQyYzZkZmMsIDB4NTMzODBkMTMsXG4gIDB4NjUwYTczNTQsIDB4NzY2YTBhYmIsIDB4ODFjMmM5MmUsIDB4OTI3MjJjODUsXG4gIDB4YTJiZmU4YTEsIDB4YTgxYTY2NGIsIDB4YzI0YjhiNzAsIDB4Yzc2YzUxYTMsXG4gIDB4ZDE5MmU4MTksIDB4ZDY5OTA2MjQsIDB4ZjQwZTM1ODUsIDB4MTA2YWEwNzAsXG4gIDB4MTlhNGMxMTYsIDB4MWUzNzZjMDgsIDB4Mjc0ODc3NGMsIDB4MzRiMGJjYjUsXG4gIDB4MzkxYzBjYjMsIDB4NGVkOGFhNGEsIDB4NWI5Y2NhNGYsIDB4NjgyZTZmZjMsXG4gIDB4NzQ4ZjgyZWUsIDB4NzhhNTYzNmYsIDB4ODRjODc4MTQsIDB4OGNjNzAyMDgsXG4gIDB4OTBiZWZmZmEsIDB4YTQ1MDZjZWIsIDB4YmVmOWEzZjcsIDB4YzY3MTc4ZjJcbl07XG5cbnZhciBzaGE1MTJfSyA9IFtcbiAgMHg0MjhhMmY5OCwgMHhkNzI4YWUyMiwgMHg3MTM3NDQ5MSwgMHgyM2VmNjVjZCxcbiAgMHhiNWMwZmJjZiwgMHhlYzRkM2IyZiwgMHhlOWI1ZGJhNSwgMHg4MTg5ZGJiYyxcbiAgMHgzOTU2YzI1YiwgMHhmMzQ4YjUzOCwgMHg1OWYxMTFmMSwgMHhiNjA1ZDAxOSxcbiAgMHg5MjNmODJhNCwgMHhhZjE5NGY5YiwgMHhhYjFjNWVkNSwgMHhkYTZkODExOCxcbiAgMHhkODA3YWE5OCwgMHhhMzAzMDI0MiwgMHgxMjgzNWIwMSwgMHg0NTcwNmZiZSxcbiAgMHgyNDMxODViZSwgMHg0ZWU0YjI4YywgMHg1NTBjN2RjMywgMHhkNWZmYjRlMixcbiAgMHg3MmJlNWQ3NCwgMHhmMjdiODk2ZiwgMHg4MGRlYjFmZSwgMHgzYjE2OTZiMSxcbiAgMHg5YmRjMDZhNywgMHgyNWM3MTIzNSwgMHhjMTliZjE3NCwgMHhjZjY5MjY5NCxcbiAgMHhlNDliNjljMSwgMHg5ZWYxNGFkMiwgMHhlZmJlNDc4NiwgMHgzODRmMjVlMyxcbiAgMHgwZmMxOWRjNiwgMHg4YjhjZDViNSwgMHgyNDBjYTFjYywgMHg3N2FjOWM2NSxcbiAgMHgyZGU5MmM2ZiwgMHg1OTJiMDI3NSwgMHg0YTc0ODRhYSwgMHg2ZWE2ZTQ4MyxcbiAgMHg1Y2IwYTlkYywgMHhiZDQxZmJkNCwgMHg3NmY5ODhkYSwgMHg4MzExNTNiNSxcbiAgMHg5ODNlNTE1MiwgMHhlZTY2ZGZhYiwgMHhhODMxYzY2ZCwgMHgyZGI0MzIxMCxcbiAgMHhiMDAzMjdjOCwgMHg5OGZiMjEzZiwgMHhiZjU5N2ZjNywgMHhiZWVmMGVlNCxcbiAgMHhjNmUwMGJmMywgMHgzZGE4OGZjMiwgMHhkNWE3OTE0NywgMHg5MzBhYTcyNSxcbiAgMHgwNmNhNjM1MSwgMHhlMDAzODI2ZiwgMHgxNDI5Mjk2NywgMHgwYTBlNmU3MCxcbiAgMHgyN2I3MGE4NSwgMHg0NmQyMmZmYywgMHgyZTFiMjEzOCwgMHg1YzI2YzkyNixcbiAgMHg0ZDJjNmRmYywgMHg1YWM0MmFlZCwgMHg1MzM4MGQxMywgMHg5ZDk1YjNkZixcbiAgMHg2NTBhNzM1NCwgMHg4YmFmNjNkZSwgMHg3NjZhMGFiYiwgMHgzYzc3YjJhOCxcbiAgMHg4MWMyYzkyZSwgMHg0N2VkYWVlNiwgMHg5MjcyMmM4NSwgMHgxNDgyMzUzYixcbiAgMHhhMmJmZThhMSwgMHg0Y2YxMDM2NCwgMHhhODFhNjY0YiwgMHhiYzQyMzAwMSxcbiAgMHhjMjRiOGI3MCwgMHhkMGY4OTc5MSwgMHhjNzZjNTFhMywgMHgwNjU0YmUzMCxcbiAgMHhkMTkyZTgxOSwgMHhkNmVmNTIxOCwgMHhkNjk5MDYyNCwgMHg1NTY1YTkxMCxcbiAgMHhmNDBlMzU4NSwgMHg1NzcxMjAyYSwgMHgxMDZhYTA3MCwgMHgzMmJiZDFiOCxcbiAgMHgxOWE0YzExNiwgMHhiOGQyZDBjOCwgMHgxZTM3NmMwOCwgMHg1MTQxYWI1MyxcbiAgMHgyNzQ4Nzc0YywgMHhkZjhlZWI5OSwgMHgzNGIwYmNiNSwgMHhlMTliNDhhOCxcbiAgMHgzOTFjMGNiMywgMHhjNWM5NWE2MywgMHg0ZWQ4YWE0YSwgMHhlMzQxOGFjYixcbiAgMHg1YjljY2E0ZiwgMHg3NzYzZTM3MywgMHg2ODJlNmZmMywgMHhkNmIyYjhhMyxcbiAgMHg3NDhmODJlZSwgMHg1ZGVmYjJmYywgMHg3OGE1NjM2ZiwgMHg0MzE3MmY2MCxcbiAgMHg4NGM4NzgxNCwgMHhhMWYwYWI3MiwgMHg4Y2M3MDIwOCwgMHgxYTY0MzllYyxcbiAgMHg5MGJlZmZmYSwgMHgyMzYzMWUyOCwgMHhhNDUwNmNlYiwgMHhkZTgyYmRlOSxcbiAgMHhiZWY5YTNmNywgMHhiMmM2NzkxNSwgMHhjNjcxNzhmMiwgMHhlMzcyNTMyYixcbiAgMHhjYTI3M2VjZSwgMHhlYTI2NjE5YywgMHhkMTg2YjhjNywgMHgyMWMwYzIwNyxcbiAgMHhlYWRhN2RkNiwgMHhjZGUwZWIxZSwgMHhmNTdkNGY3ZiwgMHhlZTZlZDE3OCxcbiAgMHgwNmYwNjdhYSwgMHg3MjE3NmZiYSwgMHgwYTYzN2RjNSwgMHhhMmM4OThhNixcbiAgMHgxMTNmOTgwNCwgMHhiZWY5MGRhZSwgMHgxYjcxMGIzNSwgMHgxMzFjNDcxYixcbiAgMHgyOGRiNzdmNSwgMHgyMzA0N2Q4NCwgMHgzMmNhYWI3YiwgMHg0MGM3MjQ5MyxcbiAgMHgzYzllYmUwYSwgMHgxNWM5YmViYywgMHg0MzFkNjdjNCwgMHg5YzEwMGQ0YyxcbiAgMHg0Y2M1ZDRiZSwgMHhjYjNlNDJiNiwgMHg1OTdmMjk5YywgMHhmYzY1N2UyYSxcbiAgMHg1ZmNiNmZhYiwgMHgzYWQ2ZmFlYywgMHg2YzQ0MTk4YywgMHg0YTQ3NTgxN1xuXTtcblxudmFyIHNoYTFfSyA9IFtcbiAgMHg1QTgyNzk5OSwgMHg2RUQ5RUJBMSxcbiAgMHg4RjFCQkNEQywgMHhDQTYyQzFENlxuXTtcblxuZnVuY3Rpb24gU0hBMjU2KCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU0hBMjU2KSlcbiAgICByZXR1cm4gbmV3IFNIQTI1NigpO1xuXG4gIEJsb2NrSGFzaC5jYWxsKHRoaXMpO1xuICB0aGlzLmggPSBbIDB4NmEwOWU2NjcsIDB4YmI2N2FlODUsIDB4M2M2ZWYzNzIsIDB4YTU0ZmY1M2EsXG4gICAgICAgICAgICAgMHg1MTBlNTI3ZiwgMHg5YjA1Njg4YywgMHgxZjgzZDlhYiwgMHg1YmUwY2QxOSBdO1xuICB0aGlzLmsgPSBzaGEyNTZfSztcbiAgdGhpcy5XID0gbmV3IEFycmF5KDY0KTtcbn1cbnV0aWxzLmluaGVyaXRzKFNIQTI1NiwgQmxvY2tIYXNoKTtcbmV4cG9ydHMuc2hhMjU2ID0gU0hBMjU2O1xuXG5TSEEyNTYuYmxvY2tTaXplID0gNTEyO1xuU0hBMjU2Lm91dFNpemUgPSAyNTY7XG5TSEEyNTYuaG1hY1N0cmVuZ3RoID0gMTkyO1xuU0hBMjU2LnBhZExlbmd0aCA9IDY0O1xuXG5TSEEyNTYucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiBfdXBkYXRlKG1zZywgc3RhcnQpIHtcbiAgdmFyIFcgPSB0aGlzLlc7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgaSsrKVxuICAgIFdbaV0gPSBtc2dbc3RhcnQgKyBpXTtcbiAgZm9yICg7IGkgPCBXLmxlbmd0aDsgaSsrKVxuICAgIFdbaV0gPSBzdW0zMl80KGcxXzI1NihXW2kgLSAyXSksIFdbaSAtIDddLCBnMF8yNTYoV1tpIC0gMTVdKSwgV1tpIC0gMTZdKTtcblxuICB2YXIgYSA9IHRoaXMuaFswXTtcbiAgdmFyIGIgPSB0aGlzLmhbMV07XG4gIHZhciBjID0gdGhpcy5oWzJdO1xuICB2YXIgZCA9IHRoaXMuaFszXTtcbiAgdmFyIGUgPSB0aGlzLmhbNF07XG4gIHZhciBmID0gdGhpcy5oWzVdO1xuICB2YXIgZyA9IHRoaXMuaFs2XTtcbiAgdmFyIGggPSB0aGlzLmhbN107XG5cbiAgYXNzZXJ0KHRoaXMuay5sZW5ndGggPT09IFcubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBXLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIFQxID0gc3VtMzJfNShoLCBzMV8yNTYoZSksIGNoMzIoZSwgZiwgZyksIHRoaXMua1tpXSwgV1tpXSk7XG4gICAgdmFyIFQyID0gc3VtMzIoczBfMjU2KGEpLCBtYWozMihhLCBiLCBjKSk7XG4gICAgaCA9IGc7XG4gICAgZyA9IGY7XG4gICAgZiA9IGU7XG4gICAgZSA9IHN1bTMyKGQsIFQxKTtcbiAgICBkID0gYztcbiAgICBjID0gYjtcbiAgICBiID0gYTtcbiAgICBhID0gc3VtMzIoVDEsIFQyKTtcbiAgfVxuXG4gIHRoaXMuaFswXSA9IHN1bTMyKHRoaXMuaFswXSwgYSk7XG4gIHRoaXMuaFsxXSA9IHN1bTMyKHRoaXMuaFsxXSwgYik7XG4gIHRoaXMuaFsyXSA9IHN1bTMyKHRoaXMuaFsyXSwgYyk7XG4gIHRoaXMuaFszXSA9IHN1bTMyKHRoaXMuaFszXSwgZCk7XG4gIHRoaXMuaFs0XSA9IHN1bTMyKHRoaXMuaFs0XSwgZSk7XG4gIHRoaXMuaFs1XSA9IHN1bTMyKHRoaXMuaFs1XSwgZik7XG4gIHRoaXMuaFs2XSA9IHN1bTMyKHRoaXMuaFs2XSwgZyk7XG4gIHRoaXMuaFs3XSA9IHN1bTMyKHRoaXMuaFs3XSwgaCk7XG59O1xuXG5TSEEyNTYucHJvdG90eXBlLl9kaWdlc3QgPSBmdW5jdGlvbiBkaWdlc3QoZW5jKSB7XG4gIGlmIChlbmMgPT09ICdoZXgnKVxuICAgIHJldHVybiB1dGlscy50b0hleDMyKHRoaXMuaCwgJ2JpZycpO1xuICBlbHNlXG4gICAgcmV0dXJuIHV0aWxzLnNwbGl0MzIodGhpcy5oLCAnYmlnJyk7XG59O1xuXG5mdW5jdGlvbiBTSEEyMjQoKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTSEEyMjQpKVxuICAgIHJldHVybiBuZXcgU0hBMjI0KCk7XG5cbiAgU0hBMjU2LmNhbGwodGhpcyk7XG4gIHRoaXMuaCA9IFsgMHhjMTA1OWVkOCwgMHgzNjdjZDUwNywgMHgzMDcwZGQxNywgMHhmNzBlNTkzOSxcbiAgICAgICAgICAgICAweGZmYzAwYjMxLCAweDY4NTgxNTExLCAweDY0Zjk4ZmE3LCAweGJlZmE0ZmE0IF07XG59XG51dGlscy5pbmhlcml0cyhTSEEyMjQsIFNIQTI1Nik7XG5leHBvcnRzLnNoYTIyNCA9IFNIQTIyNDtcblxuU0hBMjI0LmJsb2NrU2l6ZSA9IDUxMjtcblNIQTIyNC5vdXRTaXplID0gMjI0O1xuU0hBMjI0LmhtYWNTdHJlbmd0aCA9IDE5MjtcblNIQTIyNC5wYWRMZW5ndGggPSA2NDtcblxuU0hBMjI0LnByb3RvdHlwZS5fZGlnZXN0ID0gZnVuY3Rpb24gZGlnZXN0KGVuYykge1xuICAvLyBKdXN0IHRydW5jYXRlIG91dHB1dFxuICBpZiAoZW5jID09PSAnaGV4JylcbiAgICByZXR1cm4gdXRpbHMudG9IZXgzMih0aGlzLmguc2xpY2UoMCwgNyksICdiaWcnKTtcbiAgZWxzZVxuICAgIHJldHVybiB1dGlscy5zcGxpdDMyKHRoaXMuaC5zbGljZSgwLCA3KSwgJ2JpZycpO1xufTtcblxuZnVuY3Rpb24gU0hBNTEyKCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU0hBNTEyKSlcbiAgICByZXR1cm4gbmV3IFNIQTUxMigpO1xuXG4gIEJsb2NrSGFzaC5jYWxsKHRoaXMpO1xuICB0aGlzLmggPSBbIDB4NmEwOWU2NjcsIDB4ZjNiY2M5MDgsXG4gICAgICAgICAgICAgMHhiYjY3YWU4NSwgMHg4NGNhYTczYixcbiAgICAgICAgICAgICAweDNjNmVmMzcyLCAweGZlOTRmODJiLFxuICAgICAgICAgICAgIDB4YTU0ZmY1M2EsIDB4NWYxZDM2ZjEsXG4gICAgICAgICAgICAgMHg1MTBlNTI3ZiwgMHhhZGU2ODJkMSxcbiAgICAgICAgICAgICAweDliMDU2ODhjLCAweDJiM2U2YzFmLFxuICAgICAgICAgICAgIDB4MWY4M2Q5YWIsIDB4ZmI0MWJkNmIsXG4gICAgICAgICAgICAgMHg1YmUwY2QxOSwgMHgxMzdlMjE3OSBdO1xuICB0aGlzLmsgPSBzaGE1MTJfSztcbiAgdGhpcy5XID0gbmV3IEFycmF5KDE2MCk7XG59XG51dGlscy5pbmhlcml0cyhTSEE1MTIsIEJsb2NrSGFzaCk7XG5leHBvcnRzLnNoYTUxMiA9IFNIQTUxMjtcblxuU0hBNTEyLmJsb2NrU2l6ZSA9IDEwMjQ7XG5TSEE1MTIub3V0U2l6ZSA9IDUxMjtcblNIQTUxMi5obWFjU3RyZW5ndGggPSAxOTI7XG5TSEE1MTIucGFkTGVuZ3RoID0gMTI4O1xuXG5TSEE1MTIucHJvdG90eXBlLl9wcmVwYXJlQmxvY2sgPSBmdW5jdGlvbiBfcHJlcGFyZUJsb2NrKG1zZywgc3RhcnQpIHtcbiAgdmFyIFcgPSB0aGlzLlc7XG5cbiAgLy8gMzIgeCAzMmJpdCB3b3Jkc1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDMyOyBpKyspXG4gICAgV1tpXSA9IG1zZ1tzdGFydCArIGldO1xuICBmb3IgKDsgaSA8IFcubGVuZ3RoOyBpICs9IDIpIHtcbiAgICB2YXIgYzBfaGkgPSBnMV81MTJfaGkoV1tpIC0gNF0sIFdbaSAtIDNdKTsgIC8vIGkgLSAyXG4gICAgdmFyIGMwX2xvID0gZzFfNTEyX2xvKFdbaSAtIDRdLCBXW2kgLSAzXSk7XG4gICAgdmFyIGMxX2hpID0gV1tpIC0gMTRdOyAgLy8gaSAtIDdcbiAgICB2YXIgYzFfbG8gPSBXW2kgLSAxM107XG4gICAgdmFyIGMyX2hpID0gZzBfNTEyX2hpKFdbaSAtIDMwXSwgV1tpIC0gMjldKTsgIC8vIGkgLSAxNVxuICAgIHZhciBjMl9sbyA9IGcwXzUxMl9sbyhXW2kgLSAzMF0sIFdbaSAtIDI5XSk7XG4gICAgdmFyIGMzX2hpID0gV1tpIC0gMzJdOyAgLy8gaSAtIDE2XG4gICAgdmFyIGMzX2xvID0gV1tpIC0gMzFdO1xuXG4gICAgV1tpXSA9IHN1bTY0XzRfaGkoYzBfaGksIGMwX2xvLFxuICAgICAgICAgICAgICAgICAgICAgIGMxX2hpLCBjMV9sbyxcbiAgICAgICAgICAgICAgICAgICAgICBjMl9oaSwgYzJfbG8sXG4gICAgICAgICAgICAgICAgICAgICAgYzNfaGksIGMzX2xvKTtcbiAgICBXW2kgKyAxXSA9IHN1bTY0XzRfbG8oYzBfaGksIGMwX2xvLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBjMV9oaSwgYzFfbG8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGMyX2hpLCBjMl9sbyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYzNfaGksIGMzX2xvKTtcbiAgfVxufTtcblxuU0hBNTEyLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gX3VwZGF0ZShtc2csIHN0YXJ0KSB7XG4gIHRoaXMuX3ByZXBhcmVCbG9jayhtc2csIHN0YXJ0KTtcblxuICB2YXIgVyA9IHRoaXMuVztcblxuICB2YXIgYWggPSB0aGlzLmhbMF07XG4gIHZhciBhbCA9IHRoaXMuaFsxXTtcbiAgdmFyIGJoID0gdGhpcy5oWzJdO1xuICB2YXIgYmwgPSB0aGlzLmhbM107XG4gIHZhciBjaCA9IHRoaXMuaFs0XTtcbiAgdmFyIGNsID0gdGhpcy5oWzVdO1xuICB2YXIgZGggPSB0aGlzLmhbNl07XG4gIHZhciBkbCA9IHRoaXMuaFs3XTtcbiAgdmFyIGVoID0gdGhpcy5oWzhdO1xuICB2YXIgZWwgPSB0aGlzLmhbOV07XG4gIHZhciBmaCA9IHRoaXMuaFsxMF07XG4gIHZhciBmbCA9IHRoaXMuaFsxMV07XG4gIHZhciBnaCA9IHRoaXMuaFsxMl07XG4gIHZhciBnbCA9IHRoaXMuaFsxM107XG4gIHZhciBoaCA9IHRoaXMuaFsxNF07XG4gIHZhciBobCA9IHRoaXMuaFsxNV07XG5cbiAgYXNzZXJ0KHRoaXMuay5sZW5ndGggPT09IFcubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBXLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgdmFyIGMwX2hpID0gaGg7XG4gICAgdmFyIGMwX2xvID0gaGw7XG4gICAgdmFyIGMxX2hpID0gczFfNTEyX2hpKGVoLCBlbCk7XG4gICAgdmFyIGMxX2xvID0gczFfNTEyX2xvKGVoLCBlbCk7XG4gICAgdmFyIGMyX2hpID0gY2g2NF9oaShlaCwgZWwsIGZoLCBmbCwgZ2gsIGdsKTtcbiAgICB2YXIgYzJfbG8gPSBjaDY0X2xvKGVoLCBlbCwgZmgsIGZsLCBnaCwgZ2wpO1xuICAgIHZhciBjM19oaSA9IHRoaXMua1tpXTtcbiAgICB2YXIgYzNfbG8gPSB0aGlzLmtbaSArIDFdO1xuICAgIHZhciBjNF9oaSA9IFdbaV07XG4gICAgdmFyIGM0X2xvID0gV1tpICsgMV07XG5cbiAgICB2YXIgVDFfaGkgPSBzdW02NF81X2hpKGMwX2hpLCBjMF9sbyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGMxX2hpLCBjMV9sbyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGMyX2hpLCBjMl9sbyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGMzX2hpLCBjM19sbyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGM0X2hpLCBjNF9sbyk7XG4gICAgdmFyIFQxX2xvID0gc3VtNjRfNV9sbyhjMF9oaSwgYzBfbG8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjMV9oaSwgYzFfbG8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjMl9oaSwgYzJfbG8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjM19oaSwgYzNfbG8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjNF9oaSwgYzRfbG8pO1xuXG4gICAgdmFyIGMwX2hpID0gczBfNTEyX2hpKGFoLCBhbCk7XG4gICAgdmFyIGMwX2xvID0gczBfNTEyX2xvKGFoLCBhbCk7XG4gICAgdmFyIGMxX2hpID0gbWFqNjRfaGkoYWgsIGFsLCBiaCwgYmwsIGNoLCBjbCk7XG4gICAgdmFyIGMxX2xvID0gbWFqNjRfbG8oYWgsIGFsLCBiaCwgYmwsIGNoLCBjbCk7XG5cbiAgICB2YXIgVDJfaGkgPSBzdW02NF9oaShjMF9oaSwgYzBfbG8sIGMxX2hpLCBjMV9sbyk7XG4gICAgdmFyIFQyX2xvID0gc3VtNjRfbG8oYzBfaGksIGMwX2xvLCBjMV9oaSwgYzFfbG8pO1xuXG4gICAgaGggPSBnaDtcbiAgICBobCA9IGdsO1xuXG4gICAgZ2ggPSBmaDtcbiAgICBnbCA9IGZsO1xuXG4gICAgZmggPSBlaDtcbiAgICBmbCA9IGVsO1xuXG4gICAgZWggPSBzdW02NF9oaShkaCwgZGwsIFQxX2hpLCBUMV9sbyk7XG4gICAgZWwgPSBzdW02NF9sbyhkbCwgZGwsIFQxX2hpLCBUMV9sbyk7XG5cbiAgICBkaCA9IGNoO1xuICAgIGRsID0gY2w7XG5cbiAgICBjaCA9IGJoO1xuICAgIGNsID0gYmw7XG5cbiAgICBiaCA9IGFoO1xuICAgIGJsID0gYWw7XG5cbiAgICBhaCA9IHN1bTY0X2hpKFQxX2hpLCBUMV9sbywgVDJfaGksIFQyX2xvKTtcbiAgICBhbCA9IHN1bTY0X2xvKFQxX2hpLCBUMV9sbywgVDJfaGksIFQyX2xvKTtcbiAgfVxuXG4gIHN1bTY0KHRoaXMuaCwgMCwgYWgsIGFsKTtcbiAgc3VtNjQodGhpcy5oLCAyLCBiaCwgYmwpO1xuICBzdW02NCh0aGlzLmgsIDQsIGNoLCBjbCk7XG4gIHN1bTY0KHRoaXMuaCwgNiwgZGgsIGRsKTtcbiAgc3VtNjQodGhpcy5oLCA4LCBlaCwgZWwpO1xuICBzdW02NCh0aGlzLmgsIDEwLCBmaCwgZmwpO1xuICBzdW02NCh0aGlzLmgsIDEyLCBnaCwgZ2wpO1xuICBzdW02NCh0aGlzLmgsIDE0LCBoaCwgaGwpO1xufTtcblxuU0hBNTEyLnByb3RvdHlwZS5fZGlnZXN0ID0gZnVuY3Rpb24gZGlnZXN0KGVuYykge1xuICBpZiAoZW5jID09PSAnaGV4JylcbiAgICByZXR1cm4gdXRpbHMudG9IZXgzMih0aGlzLmgsICdiaWcnKTtcbiAgZWxzZVxuICAgIHJldHVybiB1dGlscy5zcGxpdDMyKHRoaXMuaCwgJ2JpZycpO1xufTtcblxuZnVuY3Rpb24gU0hBMzg0KCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU0hBMzg0KSlcbiAgICByZXR1cm4gbmV3IFNIQTM4NCgpO1xuXG4gIFNIQTUxMi5jYWxsKHRoaXMpO1xuICB0aGlzLmggPSBbIDB4Y2JiYjlkNWQsIDB4YzEwNTllZDgsXG4gICAgICAgICAgICAgMHg2MjlhMjkyYSwgMHgzNjdjZDUwNyxcbiAgICAgICAgICAgICAweDkxNTkwMTVhLCAweDMwNzBkZDE3LFxuICAgICAgICAgICAgIDB4MTUyZmVjZDgsIDB4ZjcwZTU5MzksXG4gICAgICAgICAgICAgMHg2NzMzMjY2NywgMHhmZmMwMGIzMSxcbiAgICAgICAgICAgICAweDhlYjQ0YTg3LCAweDY4NTgxNTExLFxuICAgICAgICAgICAgIDB4ZGIwYzJlMGQsIDB4NjRmOThmYTcsXG4gICAgICAgICAgICAgMHg0N2I1NDgxZCwgMHhiZWZhNGZhNCBdO1xufVxudXRpbHMuaW5oZXJpdHMoU0hBMzg0LCBTSEE1MTIpO1xuZXhwb3J0cy5zaGEzODQgPSBTSEEzODQ7XG5cblNIQTM4NC5ibG9ja1NpemUgPSAxMDI0O1xuU0hBMzg0Lm91dFNpemUgPSAzODQ7XG5TSEEzODQuaG1hY1N0cmVuZ3RoID0gMTkyO1xuU0hBMzg0LnBhZExlbmd0aCA9IDEyODtcblxuU0hBMzg0LnByb3RvdHlwZS5fZGlnZXN0ID0gZnVuY3Rpb24gZGlnZXN0KGVuYykge1xuICBpZiAoZW5jID09PSAnaGV4JylcbiAgICByZXR1cm4gdXRpbHMudG9IZXgzMih0aGlzLmguc2xpY2UoMCwgMTIpLCAnYmlnJyk7XG4gIGVsc2VcbiAgICByZXR1cm4gdXRpbHMuc3BsaXQzMih0aGlzLmguc2xpY2UoMCwgMTIpLCAnYmlnJyk7XG59O1xuXG5mdW5jdGlvbiBTSEExKCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU0hBMSkpXG4gICAgcmV0dXJuIG5ldyBTSEExKCk7XG5cbiAgQmxvY2tIYXNoLmNhbGwodGhpcyk7XG4gIHRoaXMuaCA9IFsgMHg2NzQ1MjMwMSwgMHhlZmNkYWI4OSwgMHg5OGJhZGNmZSxcbiAgICAgICAgICAgICAweDEwMzI1NDc2LCAweGMzZDJlMWYwIF07XG4gIHRoaXMuVyA9IG5ldyBBcnJheSg4MCk7XG59XG5cbnV0aWxzLmluaGVyaXRzKFNIQTEsIEJsb2NrSGFzaCk7XG5leHBvcnRzLnNoYTEgPSBTSEExO1xuXG5TSEExLmJsb2NrU2l6ZSA9IDUxMjtcblNIQTEub3V0U2l6ZSA9IDE2MDtcblNIQTEuaG1hY1N0cmVuZ3RoID0gODA7XG5TSEExLnBhZExlbmd0aCA9IDY0O1xuXG5TSEExLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gX3VwZGF0ZShtc2csIHN0YXJ0KSB7XG4gIHZhciBXID0gdGhpcy5XO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7IGkrKylcbiAgICBXW2ldID0gbXNnW3N0YXJ0ICsgaV07XG5cbiAgZm9yKDsgaSA8IFcubGVuZ3RoOyBpKyspXG4gICAgV1tpXSA9IHJvdGwzMihXW2kgLSAzXSBeIFdbaSAtIDhdIF4gV1tpIC0gMTRdIF4gV1tpIC0gMTZdLCAxKTtcblxuICB2YXIgYSA9IHRoaXMuaFswXTtcbiAgdmFyIGIgPSB0aGlzLmhbMV07XG4gIHZhciBjID0gdGhpcy5oWzJdO1xuICB2YXIgZCA9IHRoaXMuaFszXTtcbiAgdmFyIGUgPSB0aGlzLmhbNF07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBXLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHMgPSB+fihpIC8gMjApO1xuICAgIHZhciB0ID0gc3VtMzJfNShyb3RsMzIoYSwgNSksIGZ0XzEocywgYiwgYywgZCksIGUsIFdbaV0sIHNoYTFfS1tzXSk7XG4gICAgZSA9IGQ7XG4gICAgZCA9IGM7XG4gICAgYyA9IHJvdGwzMihiLCAzMCk7XG4gICAgYiA9IGE7XG4gICAgYSA9IHQ7XG4gIH1cblxuICB0aGlzLmhbMF0gPSBzdW0zMih0aGlzLmhbMF0sIGEpO1xuICB0aGlzLmhbMV0gPSBzdW0zMih0aGlzLmhbMV0sIGIpO1xuICB0aGlzLmhbMl0gPSBzdW0zMih0aGlzLmhbMl0sIGMpO1xuICB0aGlzLmhbM10gPSBzdW0zMih0aGlzLmhbM10sIGQpO1xuICB0aGlzLmhbNF0gPSBzdW0zMih0aGlzLmhbNF0sIGUpO1xufTtcblxuU0hBMS5wcm90b3R5cGUuX2RpZ2VzdCA9IGZ1bmN0aW9uIGRpZ2VzdChlbmMpIHtcbiAgaWYgKGVuYyA9PT0gJ2hleCcpXG4gICAgcmV0dXJuIHV0aWxzLnRvSGV4MzIodGhpcy5oLCAnYmlnJyk7XG4gIGVsc2VcbiAgICByZXR1cm4gdXRpbHMuc3BsaXQzMih0aGlzLmgsICdiaWcnKTtcbn07XG5cbmZ1bmN0aW9uIGNoMzIoeCwgeSwgeikge1xuICByZXR1cm4gKHggJiB5KSBeICgofngpICYgeik7XG59XG5cbmZ1bmN0aW9uIG1hajMyKHgsIHksIHopIHtcbiAgcmV0dXJuICh4ICYgeSkgXiAoeCAmIHopIF4gKHkgJiB6KTtcbn1cblxuZnVuY3Rpb24gcDMyKHgsIHksIHopIHtcbiAgcmV0dXJuIHggXiB5IF4gejtcbn1cblxuZnVuY3Rpb24gczBfMjU2KHgpIHtcbiAgcmV0dXJuIHJvdHIzMih4LCAyKSBeIHJvdHIzMih4LCAxMykgXiByb3RyMzIoeCwgMjIpO1xufVxuXG5mdW5jdGlvbiBzMV8yNTYoeCkge1xuICByZXR1cm4gcm90cjMyKHgsIDYpIF4gcm90cjMyKHgsIDExKSBeIHJvdHIzMih4LCAyNSk7XG59XG5cbmZ1bmN0aW9uIGcwXzI1Nih4KSB7XG4gIHJldHVybiByb3RyMzIoeCwgNykgXiByb3RyMzIoeCwgMTgpIF4gKHggPj4+IDMpO1xufVxuXG5mdW5jdGlvbiBnMV8yNTYoeCkge1xuICByZXR1cm4gcm90cjMyKHgsIDE3KSBeIHJvdHIzMih4LCAxOSkgXiAoeCA+Pj4gMTApO1xufVxuXG5mdW5jdGlvbiBmdF8xKHMsIHgsIHksIHopIHtcbiAgaWYgKHMgPT09IDApXG4gICAgcmV0dXJuIGNoMzIoeCwgeSwgeik7XG4gIGlmIChzID09PSAxIHx8IHMgPT09IDMpXG4gICAgcmV0dXJuIHAzMih4LCB5LCB6KTtcbiAgaWYgKHMgPT09IDIpXG4gICAgcmV0dXJuIG1hajMyKHgsIHksIHopO1xufVxuXG5mdW5jdGlvbiBjaDY0X2hpKHhoLCB4bCwgeWgsIHlsLCB6aCwgemwpIHtcbiAgdmFyIHIgPSAoeGggJiB5aCkgXiAoKH54aCkgJiB6aCk7XG4gIGlmIChyIDwgMClcbiAgICByICs9IDB4MTAwMDAwMDAwO1xuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gY2g2NF9sbyh4aCwgeGwsIHloLCB5bCwgemgsIHpsKSB7XG4gIHZhciByID0gKHhsICYgeWwpIF4gKCh+eGwpICYgemwpO1xuICBpZiAociA8IDApXG4gICAgciArPSAweDEwMDAwMDAwMDtcbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIG1hajY0X2hpKHhoLCB4bCwgeWgsIHlsLCB6aCwgemwpIHtcbiAgdmFyIHIgPSAoeGggJiB5aCkgXiAoeGggJiB6aCkgXiAoeWggJiB6aCk7XG4gIGlmIChyIDwgMClcbiAgICByICs9IDB4MTAwMDAwMDAwO1xuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gbWFqNjRfbG8oeGgsIHhsLCB5aCwgeWwsIHpoLCB6bCkge1xuICB2YXIgciA9ICh4bCAmIHlsKSBeICh4bCAmIHpsKSBeICh5bCAmIHpsKTtcbiAgaWYgKHIgPCAwKVxuICAgIHIgKz0gMHgxMDAwMDAwMDA7XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBzMF81MTJfaGkoeGgsIHhsKSB7XG4gIHZhciBjMF9oaSA9IHJvdHI2NF9oaSh4aCwgeGwsIDI4KTtcbiAgdmFyIGMxX2hpID0gcm90cjY0X2hpKHhsLCB4aCwgMik7ICAvLyAzNFxuICB2YXIgYzJfaGkgPSByb3RyNjRfaGkoeGwsIHhoLCA3KTsgIC8vIDM5XG5cbiAgdmFyIHIgPSBjMF9oaSBeIGMxX2hpIF4gYzJfaGk7XG4gIGlmIChyIDwgMClcbiAgICByICs9IDB4MTAwMDAwMDAwO1xuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gczBfNTEyX2xvKHhoLCB4bCkge1xuICB2YXIgYzBfbG8gPSByb3RyNjRfbG8oeGgsIHhsLCAyOCk7XG4gIHZhciBjMV9sbyA9IHJvdHI2NF9sbyh4bCwgeGgsIDIpOyAgLy8gMzRcbiAgdmFyIGMyX2xvID0gcm90cjY0X2xvKHhsLCB4aCwgNyk7ICAvLyAzOVxuXG4gIHZhciByID0gYzBfbG8gXiBjMV9sbyBeIGMyX2xvO1xuICBpZiAociA8IDApXG4gICAgciArPSAweDEwMDAwMDAwMDtcbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIHMxXzUxMl9oaSh4aCwgeGwpIHtcbiAgdmFyIGMwX2hpID0gcm90cjY0X2hpKHhoLCB4bCwgMTQpO1xuICB2YXIgYzFfaGkgPSByb3RyNjRfaGkoeGgsIHhsLCAxOCk7XG4gIHZhciBjMl9oaSA9IHJvdHI2NF9oaSh4bCwgeGgsIDkpOyAgLy8gNDFcblxuICB2YXIgciA9IGMwX2hpIF4gYzFfaGkgXiBjMl9oaTtcbiAgaWYgKHIgPCAwKVxuICAgIHIgKz0gMHgxMDAwMDAwMDA7XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBzMV81MTJfbG8oeGgsIHhsKSB7XG4gIHZhciBjMF9sbyA9IHJvdHI2NF9sbyh4aCwgeGwsIDE0KTtcbiAgdmFyIGMxX2xvID0gcm90cjY0X2xvKHhoLCB4bCwgMTgpO1xuICB2YXIgYzJfbG8gPSByb3RyNjRfbG8oeGwsIHhoLCA5KTsgIC8vIDQxXG5cbiAgdmFyIHIgPSBjMF9sbyBeIGMxX2xvIF4gYzJfbG87XG4gIGlmIChyIDwgMClcbiAgICByICs9IDB4MTAwMDAwMDAwO1xuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gZzBfNTEyX2hpKHhoLCB4bCkge1xuICB2YXIgYzBfaGkgPSByb3RyNjRfaGkoeGgsIHhsLCAxKTtcbiAgdmFyIGMxX2hpID0gcm90cjY0X2hpKHhoLCB4bCwgOCk7XG4gIHZhciBjMl9oaSA9IHNocjY0X2hpKHhoLCB4bCwgNyk7XG5cbiAgdmFyIHIgPSBjMF9oaSBeIGMxX2hpIF4gYzJfaGk7XG4gIGlmIChyIDwgMClcbiAgICByICs9IDB4MTAwMDAwMDAwO1xuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gZzBfNTEyX2xvKHhoLCB4bCkge1xuICB2YXIgYzBfbG8gPSByb3RyNjRfbG8oeGgsIHhsLCAxKTtcbiAgdmFyIGMxX2xvID0gcm90cjY0X2xvKHhoLCB4bCwgOCk7XG4gIHZhciBjMl9sbyA9IHNocjY0X2xvKHhoLCB4bCwgNyk7XG5cbiAgdmFyIHIgPSBjMF9sbyBeIGMxX2xvIF4gYzJfbG87XG4gIGlmIChyIDwgMClcbiAgICByICs9IDB4MTAwMDAwMDAwO1xuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gZzFfNTEyX2hpKHhoLCB4bCkge1xuICB2YXIgYzBfaGkgPSByb3RyNjRfaGkoeGgsIHhsLCAxOSk7XG4gIHZhciBjMV9oaSA9IHJvdHI2NF9oaSh4bCwgeGgsIDI5KTsgIC8vIDYxXG4gIHZhciBjMl9oaSA9IHNocjY0X2hpKHhoLCB4bCwgNik7XG5cbiAgdmFyIHIgPSBjMF9oaSBeIGMxX2hpIF4gYzJfaGk7XG4gIGlmIChyIDwgMClcbiAgICByICs9IDB4MTAwMDAwMDAwO1xuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gZzFfNTEyX2xvKHhoLCB4bCkge1xuICB2YXIgYzBfbG8gPSByb3RyNjRfbG8oeGgsIHhsLCAxOSk7XG4gIHZhciBjMV9sbyA9IHJvdHI2NF9sbyh4bCwgeGgsIDI5KTsgIC8vIDYxXG4gIHZhciBjMl9sbyA9IHNocjY0X2xvKHhoLCB4bCwgNik7XG5cbiAgdmFyIHIgPSBjMF9sbyBeIGMxX2xvIF4gYzJfbG87XG4gIGlmIChyIDwgMClcbiAgICByICs9IDB4MTAwMDAwMDAwO1xuICByZXR1cm4gcjtcbn1cbiIsInZhciB1dGlscyA9IGV4cG9ydHM7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5mdW5jdGlvbiB0b0FycmF5KG1zZywgZW5jKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KG1zZykpXG4gICAgcmV0dXJuIG1zZy5zbGljZSgpO1xuICBpZiAoIW1zZylcbiAgICByZXR1cm4gW107XG4gIHZhciByZXMgPSBbXTtcbiAgaWYgKHR5cGVvZiBtc2cgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKCFlbmMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjID0gbXNnLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIHZhciBoaSA9IGMgPj4gODtcbiAgICAgICAgdmFyIGxvID0gYyAmIDB4ZmY7XG4gICAgICAgIGlmIChoaSlcbiAgICAgICAgICByZXMucHVzaChoaSwgbG8pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgcmVzLnB1c2gobG8pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZW5jID09PSAnaGV4Jykge1xuICAgICAgbXNnID0gbXNnLnJlcGxhY2UoL1teYS16MC05XSsvaWcsICcnKTtcbiAgICAgIGlmIChtc2cubGVuZ3RoICUgMiAhPT0gMClcbiAgICAgICAgbXNnID0gJzAnICsgbXNnO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpICs9IDIpXG4gICAgICAgIHJlcy5wdXNoKHBhcnNlSW50KG1zZ1tpXSArIG1zZ1tpICsgMV0sIDE2KSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrKVxuICAgICAgcmVzW2ldID0gbXNnW2ldIHwgMDtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxudXRpbHMudG9BcnJheSA9IHRvQXJyYXk7XG5cbmZ1bmN0aW9uIHRvSGV4KG1zZykge1xuICB2YXIgcmVzID0gJyc7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrKVxuICAgIHJlcyArPSB6ZXJvMihtc2dbaV0udG9TdHJpbmcoMTYpKTtcbiAgcmV0dXJuIHJlcztcbn1cbnV0aWxzLnRvSGV4ID0gdG9IZXg7XG5cbmZ1bmN0aW9uIGh0b25sKHcpIHtcbiAgdmFyIHJlcyA9ICh3ID4+PiAyNCkgfFxuICAgICAgICAgICAgKCh3ID4+PiA4KSAmIDB4ZmYwMCkgfFxuICAgICAgICAgICAgKCh3IDw8IDgpICYgMHhmZjAwMDApIHxcbiAgICAgICAgICAgICgodyAmIDB4ZmYpIDw8IDI0KTtcbiAgcmV0dXJuIHJlcyA+Pj4gMDtcbn1cbnV0aWxzLmh0b25sID0gaHRvbmw7XG5cbmZ1bmN0aW9uIHRvSGV4MzIobXNnLCBlbmRpYW4pIHtcbiAgdmFyIHJlcyA9ICcnO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB3ID0gbXNnW2ldO1xuICAgIGlmIChlbmRpYW4gPT09ICdsaXR0bGUnKVxuICAgICAgdyA9IGh0b25sKHcpO1xuICAgIHJlcyArPSB6ZXJvOCh3LnRvU3RyaW5nKDE2KSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cbnV0aWxzLnRvSGV4MzIgPSB0b0hleDMyO1xuXG5mdW5jdGlvbiB6ZXJvMih3b3JkKSB7XG4gIGlmICh3b3JkLmxlbmd0aCA9PT0gMSlcbiAgICByZXR1cm4gJzAnICsgd29yZDtcbiAgZWxzZVxuICAgIHJldHVybiB3b3JkO1xufVxudXRpbHMuemVybzIgPSB6ZXJvMjtcblxuZnVuY3Rpb24gemVybzgod29yZCkge1xuICBpZiAod29yZC5sZW5ndGggPT09IDcpXG4gICAgcmV0dXJuICcwJyArIHdvcmQ7XG4gIGVsc2UgaWYgKHdvcmQubGVuZ3RoID09PSA2KVxuICAgIHJldHVybiAnMDAnICsgd29yZDtcbiAgZWxzZSBpZiAod29yZC5sZW5ndGggPT09IDUpXG4gICAgcmV0dXJuICcwMDAnICsgd29yZDtcbiAgZWxzZSBpZiAod29yZC5sZW5ndGggPT09IDQpXG4gICAgcmV0dXJuICcwMDAwJyArIHdvcmQ7XG4gIGVsc2UgaWYgKHdvcmQubGVuZ3RoID09PSAzKVxuICAgIHJldHVybiAnMDAwMDAnICsgd29yZDtcbiAgZWxzZSBpZiAod29yZC5sZW5ndGggPT09IDIpXG4gICAgcmV0dXJuICcwMDAwMDAnICsgd29yZDtcbiAgZWxzZSBpZiAod29yZC5sZW5ndGggPT09IDEpXG4gICAgcmV0dXJuICcwMDAwMDAwJyArIHdvcmQ7XG4gIGVsc2VcbiAgICByZXR1cm4gd29yZDtcbn1cbnV0aWxzLnplcm84ID0gemVybzg7XG5cbmZ1bmN0aW9uIGpvaW4zMihtc2csIHN0YXJ0LCBlbmQsIGVuZGlhbikge1xuICB2YXIgbGVuID0gZW5kIC0gc3RhcnQ7XG4gIGFzc2VydChsZW4gJSA0ID09PSAwKTtcbiAgdmFyIHJlcyA9IG5ldyBBcnJheShsZW4gLyA0KTtcbiAgZm9yICh2YXIgaSA9IDAsIGsgPSBzdGFydDsgaSA8IHJlcy5sZW5ndGg7IGkrKywgayArPSA0KSB7XG4gICAgdmFyIHc7XG4gICAgaWYgKGVuZGlhbiA9PT0gJ2JpZycpXG4gICAgICB3ID0gKG1zZ1trXSA8PCAyNCkgfCAobXNnW2sgKyAxXSA8PCAxNikgfCAobXNnW2sgKyAyXSA8PCA4KSB8IG1zZ1trICsgM107XG4gICAgZWxzZVxuICAgICAgdyA9IChtc2dbayArIDNdIDw8IDI0KSB8IChtc2dbayArIDJdIDw8IDE2KSB8IChtc2dbayArIDFdIDw8IDgpIHwgbXNnW2tdO1xuICAgIHJlc1tpXSA9IHcgPj4+IDA7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cbnV0aWxzLmpvaW4zMiA9IGpvaW4zMjtcblxuZnVuY3Rpb24gc3BsaXQzMihtc2csIGVuZGlhbikge1xuICB2YXIgcmVzID0gbmV3IEFycmF5KG1zZy5sZW5ndGggKiA0KTtcbiAgZm9yICh2YXIgaSA9IDAsIGsgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrLCBrICs9IDQpIHtcbiAgICB2YXIgbSA9IG1zZ1tpXTtcbiAgICBpZiAoZW5kaWFuID09PSAnYmlnJykge1xuICAgICAgcmVzW2tdID0gbSA+Pj4gMjQ7XG4gICAgICByZXNbayArIDFdID0gKG0gPj4+IDE2KSAmIDB4ZmY7XG4gICAgICByZXNbayArIDJdID0gKG0gPj4+IDgpICYgMHhmZjtcbiAgICAgIHJlc1trICsgM10gPSBtICYgMHhmZjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzW2sgKyAzXSA9IG0gPj4+IDI0O1xuICAgICAgcmVzW2sgKyAyXSA9IChtID4+PiAxNikgJiAweGZmO1xuICAgICAgcmVzW2sgKyAxXSA9IChtID4+PiA4KSAmIDB4ZmY7XG4gICAgICByZXNba10gPSBtICYgMHhmZjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cbnV0aWxzLnNwbGl0MzIgPSBzcGxpdDMyO1xuXG5mdW5jdGlvbiByb3RyMzIodywgYikge1xuICByZXR1cm4gKHcgPj4+IGIpIHwgKHcgPDwgKDMyIC0gYikpO1xufVxudXRpbHMucm90cjMyID0gcm90cjMyO1xuXG5mdW5jdGlvbiByb3RsMzIodywgYikge1xuICByZXR1cm4gKHcgPDwgYikgfCAodyA+Pj4gKDMyIC0gYikpO1xufVxudXRpbHMucm90bDMyID0gcm90bDMyO1xuXG5mdW5jdGlvbiBzdW0zMihhLCBiKSB7XG4gIHJldHVybiAoYSArIGIpID4+PiAwO1xufVxudXRpbHMuc3VtMzIgPSBzdW0zMjtcblxuZnVuY3Rpb24gc3VtMzJfMyhhLCBiLCBjKSB7XG4gIHJldHVybiAoYSArIGIgKyBjKSA+Pj4gMDtcbn1cbnV0aWxzLnN1bTMyXzMgPSBzdW0zMl8zO1xuXG5mdW5jdGlvbiBzdW0zMl80KGEsIGIsIGMsIGQpIHtcbiAgcmV0dXJuIChhICsgYiArIGMgKyBkKSA+Pj4gMDtcbn1cbnV0aWxzLnN1bTMyXzQgPSBzdW0zMl80O1xuXG5mdW5jdGlvbiBzdW0zMl81KGEsIGIsIGMsIGQsIGUpIHtcbiAgcmV0dXJuIChhICsgYiArIGMgKyBkICsgZSkgPj4+IDA7XG59XG51dGlscy5zdW0zMl81ID0gc3VtMzJfNTtcblxuZnVuY3Rpb24gYXNzZXJ0KGNvbmQsIG1zZykge1xuICBpZiAoIWNvbmQpXG4gICAgdGhyb3cgbmV3IEVycm9yKG1zZyB8fCAnQXNzZXJ0aW9uIGZhaWxlZCcpO1xufVxudXRpbHMuYXNzZXJ0ID0gYXNzZXJ0O1xuXG51dGlscy5pbmhlcml0cyA9IGluaGVyaXRzO1xuXG5mdW5jdGlvbiBzdW02NChidWYsIHBvcywgYWgsIGFsKSB7XG4gIHZhciBiaCA9IGJ1Zltwb3NdO1xuICB2YXIgYmwgPSBidWZbcG9zICsgMV07XG5cbiAgdmFyIGxvID0gKGFsICsgYmwpID4+PiAwO1xuICB2YXIgaGkgPSAobG8gPCBhbCA/IDEgOiAwKSArIGFoICsgYmg7XG4gIGJ1Zltwb3NdID0gaGkgPj4+IDA7XG4gIGJ1Zltwb3MgKyAxXSA9IGxvO1xufVxuZXhwb3J0cy5zdW02NCA9IHN1bTY0O1xuXG5mdW5jdGlvbiBzdW02NF9oaShhaCwgYWwsIGJoLCBibCkge1xuICB2YXIgbG8gPSAoYWwgKyBibCkgPj4+IDA7XG4gIHZhciBoaSA9IChsbyA8IGFsID8gMSA6IDApICsgYWggKyBiaDtcbiAgcmV0dXJuIGhpID4+PiAwO1xufTtcbmV4cG9ydHMuc3VtNjRfaGkgPSBzdW02NF9oaTtcblxuZnVuY3Rpb24gc3VtNjRfbG8oYWgsIGFsLCBiaCwgYmwpIHtcbiAgdmFyIGxvID0gYWwgKyBibDtcbiAgcmV0dXJuIGxvID4+PiAwO1xufTtcbmV4cG9ydHMuc3VtNjRfbG8gPSBzdW02NF9sbztcblxuZnVuY3Rpb24gc3VtNjRfNF9oaShhaCwgYWwsIGJoLCBibCwgY2gsIGNsLCBkaCwgZGwpIHtcbiAgdmFyIGNhcnJ5ID0gMDtcbiAgdmFyIGxvID0gYWw7XG4gIGxvID0gKGxvICsgYmwpID4+PiAwO1xuICBjYXJyeSArPSBsbyA8IGFsID8gMSA6IDA7XG4gIGxvID0gKGxvICsgY2wpID4+PiAwO1xuICBjYXJyeSArPSBsbyA8IGNsID8gMSA6IDA7XG4gIGxvID0gKGxvICsgZGwpID4+PiAwO1xuICBjYXJyeSArPSBsbyA8IGRsID8gMSA6IDA7XG5cbiAgdmFyIGhpID0gYWggKyBiaCArIGNoICsgZGggKyBjYXJyeTtcbiAgcmV0dXJuIGhpID4+PiAwO1xufTtcbmV4cG9ydHMuc3VtNjRfNF9oaSA9IHN1bTY0XzRfaGk7XG5cbmZ1bmN0aW9uIHN1bTY0XzRfbG8oYWgsIGFsLCBiaCwgYmwsIGNoLCBjbCwgZGgsIGRsKSB7XG4gIHZhciBsbyA9IGFsICsgYmwgKyBjbCArIGRsO1xuICByZXR1cm4gbG8gPj4+IDA7XG59O1xuZXhwb3J0cy5zdW02NF80X2xvID0gc3VtNjRfNF9sbztcblxuZnVuY3Rpb24gc3VtNjRfNV9oaShhaCwgYWwsIGJoLCBibCwgY2gsIGNsLCBkaCwgZGwsIGVoLCBlbCkge1xuICB2YXIgY2FycnkgPSAwO1xuICB2YXIgbG8gPSBhbDtcbiAgbG8gPSAobG8gKyBibCkgPj4+IDA7XG4gIGNhcnJ5ICs9IGxvIDwgYWwgPyAxIDogMDtcbiAgbG8gPSAobG8gKyBjbCkgPj4+IDA7XG4gIGNhcnJ5ICs9IGxvIDwgY2wgPyAxIDogMDtcbiAgbG8gPSAobG8gKyBkbCkgPj4+IDA7XG4gIGNhcnJ5ICs9IGxvIDwgZGwgPyAxIDogMDtcbiAgbG8gPSAobG8gKyBlbCkgPj4+IDA7XG4gIGNhcnJ5ICs9IGxvIDwgZWwgPyAxIDogMDtcblxuICB2YXIgaGkgPSBhaCArIGJoICsgY2ggKyBkaCArIGVoICsgY2Fycnk7XG4gIHJldHVybiBoaSA+Pj4gMDtcbn07XG5leHBvcnRzLnN1bTY0XzVfaGkgPSBzdW02NF81X2hpO1xuXG5mdW5jdGlvbiBzdW02NF81X2xvKGFoLCBhbCwgYmgsIGJsLCBjaCwgY2wsIGRoLCBkbCwgZWgsIGVsKSB7XG4gIHZhciBsbyA9IGFsICsgYmwgKyBjbCArIGRsICsgZWw7XG5cbiAgcmV0dXJuIGxvID4+PiAwO1xufTtcbmV4cG9ydHMuc3VtNjRfNV9sbyA9IHN1bTY0XzVfbG87XG5cbmZ1bmN0aW9uIHJvdHI2NF9oaShhaCwgYWwsIG51bSkge1xuICB2YXIgciA9IChhbCA8PCAoMzIgLSBudW0pKSB8IChhaCA+Pj4gbnVtKTtcbiAgcmV0dXJuIHIgPj4+IDA7XG59O1xuZXhwb3J0cy5yb3RyNjRfaGkgPSByb3RyNjRfaGk7XG5cbmZ1bmN0aW9uIHJvdHI2NF9sbyhhaCwgYWwsIG51bSkge1xuICB2YXIgciA9IChhaCA8PCAoMzIgLSBudW0pKSB8IChhbCA+Pj4gbnVtKTtcbiAgcmV0dXJuIHIgPj4+IDA7XG59O1xuZXhwb3J0cy5yb3RyNjRfbG8gPSByb3RyNjRfbG87XG5cbmZ1bmN0aW9uIHNocjY0X2hpKGFoLCBhbCwgbnVtKSB7XG4gIHJldHVybiBhaCA+Pj4gbnVtO1xufTtcbmV4cG9ydHMuc2hyNjRfaGkgPSBzaHI2NF9oaTtcblxuZnVuY3Rpb24gc2hyNjRfbG8oYWgsIGFsLCBudW0pIHtcbiAgdmFyIHIgPSAoYWggPDwgKDMyIC0gbnVtKSkgfCAoYWwgPj4+IG51bSk7XG4gIHJldHVybiByID4+PiAwO1xufTtcbmV4cG9ydHMuc2hyNjRfbG8gPSBzaHI2NF9sbztcbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJuYW1lXCI6IFwiZWxsaXB0aWNcIixcbiAgXCJ2ZXJzaW9uXCI6IFwiNi4wLjJcIixcbiAgXCJkZXNjcmlwdGlvblwiOiBcIkVDIGNyeXB0b2dyYXBoeVwiLFxuICBcIm1haW5cIjogXCJsaWIvZWxsaXB0aWMuanNcIixcbiAgXCJmaWxlc1wiOiBbXG4gICAgXCJsaWJcIlxuICBdLFxuICBcInNjcmlwdHNcIjoge1xuICAgIFwidGVzdFwiOiBcIm1ha2UgbGludCAmJiBpc3RhbmJ1bCB0ZXN0IF9tb2NoYSAtLXJlcG9ydGVyPXNwZWMgdGVzdC8qLXRlc3QuanNcIixcbiAgICBcImNvdmVyYWxsc1wiOiBcImNhdCAuL2NvdmVyYWdlL2xjb3YuaW5mbyB8IGNvdmVyYWxsc1wiXG4gIH0sXG4gIFwicmVwb3NpdG9yeVwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiZ2l0XCIsXG4gICAgXCJ1cmxcIjogXCJnaXQrc3NoOi8vZ2l0QGdpdGh1Yi5jb20vaW5kdXRueS9lbGxpcHRpYy5naXRcIlxuICB9LFxuICBcImtleXdvcmRzXCI6IFtcbiAgICBcIkVDXCIsXG4gICAgXCJFbGxpcHRpY1wiLFxuICAgIFwiY3VydmVcIixcbiAgICBcIkNyeXB0b2dyYXBoeVwiXG4gIF0sXG4gIFwiYXV0aG9yXCI6IHtcbiAgICBcIm5hbWVcIjogXCJGZWRvciBJbmR1dG55XCIsXG4gICAgXCJlbWFpbFwiOiBcImZlZG9yQGluZHV0bnkuY29tXCJcbiAgfSxcbiAgXCJsaWNlbnNlXCI6IFwiTUlUXCIsXG4gIFwiYnVnc1wiOiB7XG4gICAgXCJ1cmxcIjogXCJodHRwczovL2dpdGh1Yi5jb20vaW5kdXRueS9lbGxpcHRpYy9pc3N1ZXNcIlxuICB9LFxuICBcImhvbWVwYWdlXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvZWxsaXB0aWNcIixcbiAgXCJkZXZEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiYnJvd3NlcmlmeVwiOiBcIl4zLjQ0LjJcIixcbiAgICBcImNvdmVyYWxsc1wiOiBcIl4yLjExLjNcIixcbiAgICBcImlzdGFuYnVsXCI6IFwiXjAuMy4xN1wiLFxuICAgIFwianNjc1wiOiBcIl4xLjExLjNcIixcbiAgICBcImpzaGludFwiOiBcIl4yLjYuMFwiLFxuICAgIFwibW9jaGFcIjogXCJeMi4xLjBcIixcbiAgICBcInVnbGlmeS1qc1wiOiBcIl4yLjQuMTNcIlxuICB9LFxuICBcImRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJibi5qc1wiOiBcIl40LjAuMFwiLFxuICAgIFwiYnJvcmFuZFwiOiBcIl4xLjAuMVwiLFxuICAgIFwiaGFzaC5qc1wiOiBcIl4xLjAuMFwiLFxuICAgIFwiaW5oZXJpdHNcIjogXCJeMi4wLjFcIlxuICB9LFxuICBcImdpdEhlYWRcIjogXCIzMzAxMDZkYTE4NjcxMmQyMjhkNzliYzcxYWU4ZTdlNjg1NjVmYTlkXCIsXG4gIFwiX2lkXCI6IFwiZWxsaXB0aWNANi4wLjJcIixcbiAgXCJfc2hhc3VtXCI6IFwiMjE5Yjk2Y2Q5MmFhOTg4NWQ5MWQzMWMxZmQ0MmVhYTVlYjQ0ODNhOVwiLFxuICBcIl9mcm9tXCI6IFwiZWxsaXB0aWNAPj02LjAuMCA8Ny4wLjBcIixcbiAgXCJfbnBtVmVyc2lvblwiOiBcIjMuMy42XCIsXG4gIFwiX25vZGVWZXJzaW9uXCI6IFwiNS4wLjBcIixcbiAgXCJfbnBtVXNlclwiOiB7XG4gICAgXCJuYW1lXCI6IFwiaW5kdXRueVwiLFxuICAgIFwiZW1haWxcIjogXCJmZWRvckBpbmR1dG55LmNvbVwiXG4gIH0sXG4gIFwiZGlzdFwiOiB7XG4gICAgXCJzaGFzdW1cIjogXCIyMTliOTZjZDkyYWE5ODg1ZDkxZDMxYzFmZDQyZWFhNWViNDQ4M2E5XCIsXG4gICAgXCJ0YXJiYWxsXCI6IFwiaHR0cDovL3JlZ2lzdHJ5Lm5wbWpzLm9yZy9lbGxpcHRpYy8tL2VsbGlwdGljLTYuMC4yLnRnelwiXG4gIH0sXG4gIFwibWFpbnRhaW5lcnNcIjogW1xuICAgIHtcbiAgICAgIFwibmFtZVwiOiBcImluZHV0bnlcIixcbiAgICAgIFwiZW1haWxcIjogXCJmZWRvckBpbmR1dG55LmNvbVwiXG4gICAgfVxuICBdLFxuICBcImRpcmVjdG9yaWVzXCI6IHt9LFxuICBcIl9yZXNvbHZlZFwiOiBcImh0dHBzOi8vcmVnaXN0cnkubnBtanMub3JnL2VsbGlwdGljLy0vZWxsaXB0aWMtNi4wLjIudGd6XCIsXG4gIFwicmVhZG1lXCI6IFwiRVJST1I6IE5vIFJFQURNRSBkYXRhIGZvdW5kIVwiXG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XCIyLjE2Ljg0MC4xLjEwMS4zLjQuMS4xXCI6IFwiYWVzLTEyOC1lY2JcIixcblwiMi4xNi44NDAuMS4xMDEuMy40LjEuMlwiOiBcImFlcy0xMjgtY2JjXCIsXG5cIjIuMTYuODQwLjEuMTAxLjMuNC4xLjNcIjogXCJhZXMtMTI4LW9mYlwiLFxuXCIyLjE2Ljg0MC4xLjEwMS4zLjQuMS40XCI6IFwiYWVzLTEyOC1jZmJcIixcblwiMi4xNi44NDAuMS4xMDEuMy40LjEuMjFcIjogXCJhZXMtMTkyLWVjYlwiLFxuXCIyLjE2Ljg0MC4xLjEwMS4zLjQuMS4yMlwiOiBcImFlcy0xOTItY2JjXCIsXG5cIjIuMTYuODQwLjEuMTAxLjMuNC4xLjIzXCI6IFwiYWVzLTE5Mi1vZmJcIixcblwiMi4xNi44NDAuMS4xMDEuMy40LjEuMjRcIjogXCJhZXMtMTkyLWNmYlwiLFxuXCIyLjE2Ljg0MC4xLjEwMS4zLjQuMS40MVwiOiBcImFlcy0yNTYtZWNiXCIsXG5cIjIuMTYuODQwLjEuMTAxLjMuNC4xLjQyXCI6IFwiYWVzLTI1Ni1jYmNcIixcblwiMi4xNi44NDAuMS4xMDEuMy40LjEuNDNcIjogXCJhZXMtMjU2LW9mYlwiLFxuXCIyLjE2Ljg0MC4xLjEwMS4zLjQuMS40NFwiOiBcImFlcy0yNTYtY2ZiXCJcbn0iLCIvLyBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9pbmR1dG55L3NlbGYtc2lnbmVkL2Jsb2IvZ2gtcGFnZXMvbGliL2FzbjEuanNcbi8vIEZlZG9yLCB5b3UgYXJlIGFtYXppbmcuXG5cbnZhciBhc24xID0gcmVxdWlyZSgnYXNuMS5qcycpXG5cbnZhciBSU0FQcml2YXRlS2V5ID0gYXNuMS5kZWZpbmUoJ1JTQVByaXZhdGVLZXknLCBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc2VxKCkub2JqKFxuICAgIHRoaXMua2V5KCd2ZXJzaW9uJykuaW50KCksXG4gICAgdGhpcy5rZXkoJ21vZHVsdXMnKS5pbnQoKSxcbiAgICB0aGlzLmtleSgncHVibGljRXhwb25lbnQnKS5pbnQoKSxcbiAgICB0aGlzLmtleSgncHJpdmF0ZUV4cG9uZW50JykuaW50KCksXG4gICAgdGhpcy5rZXkoJ3ByaW1lMScpLmludCgpLFxuICAgIHRoaXMua2V5KCdwcmltZTInKS5pbnQoKSxcbiAgICB0aGlzLmtleSgnZXhwb25lbnQxJykuaW50KCksXG4gICAgdGhpcy5rZXkoJ2V4cG9uZW50MicpLmludCgpLFxuICAgIHRoaXMua2V5KCdjb2VmZmljaWVudCcpLmludCgpXG4gIClcbn0pXG5leHBvcnRzLlJTQVByaXZhdGVLZXkgPSBSU0FQcml2YXRlS2V5XG5cbnZhciBSU0FQdWJsaWNLZXkgPSBhc24xLmRlZmluZSgnUlNBUHVibGljS2V5JywgZnVuY3Rpb24gKCkge1xuICB0aGlzLnNlcSgpLm9iaihcbiAgICB0aGlzLmtleSgnbW9kdWx1cycpLmludCgpLFxuICAgIHRoaXMua2V5KCdwdWJsaWNFeHBvbmVudCcpLmludCgpXG4gIClcbn0pXG5leHBvcnRzLlJTQVB1YmxpY0tleSA9IFJTQVB1YmxpY0tleVxuXG52YXIgUHVibGljS2V5ID0gYXNuMS5kZWZpbmUoJ1N1YmplY3RQdWJsaWNLZXlJbmZvJywgZnVuY3Rpb24gKCkge1xuICB0aGlzLnNlcSgpLm9iaihcbiAgICB0aGlzLmtleSgnYWxnb3JpdGhtJykudXNlKEFsZ29yaXRobUlkZW50aWZpZXIpLFxuICAgIHRoaXMua2V5KCdzdWJqZWN0UHVibGljS2V5JykuYml0c3RyKClcbiAgKVxufSlcbmV4cG9ydHMuUHVibGljS2V5ID0gUHVibGljS2V5XG5cbnZhciBBbGdvcml0aG1JZGVudGlmaWVyID0gYXNuMS5kZWZpbmUoJ0FsZ29yaXRobUlkZW50aWZpZXInLCBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc2VxKCkub2JqKFxuICAgIHRoaXMua2V5KCdhbGdvcml0aG0nKS5vYmppZCgpLFxuICAgIHRoaXMua2V5KCdub25lJykubnVsbF8oKS5vcHRpb25hbCgpLFxuICAgIHRoaXMua2V5KCdjdXJ2ZScpLm9iamlkKCkub3B0aW9uYWwoKSxcbiAgICB0aGlzLmtleSgncGFyYW1zJykuc2VxKCkub2JqKFxuICAgICAgdGhpcy5rZXkoJ3AnKS5pbnQoKSxcbiAgICAgIHRoaXMua2V5KCdxJykuaW50KCksXG4gICAgICB0aGlzLmtleSgnZycpLmludCgpXG4gICAgKS5vcHRpb25hbCgpXG4gIClcbn0pXG5cbnZhciBQcml2YXRlS2V5SW5mbyA9IGFzbjEuZGVmaW5lKCdQcml2YXRlS2V5SW5mbycsIGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zZXEoKS5vYmooXG4gICAgdGhpcy5rZXkoJ3ZlcnNpb24nKS5pbnQoKSxcbiAgICB0aGlzLmtleSgnYWxnb3JpdGhtJykudXNlKEFsZ29yaXRobUlkZW50aWZpZXIpLFxuICAgIHRoaXMua2V5KCdzdWJqZWN0UHJpdmF0ZUtleScpLm9jdHN0cigpXG4gIClcbn0pXG5leHBvcnRzLlByaXZhdGVLZXkgPSBQcml2YXRlS2V5SW5mb1xudmFyIEVuY3J5cHRlZFByaXZhdGVLZXlJbmZvID0gYXNuMS5kZWZpbmUoJ0VuY3J5cHRlZFByaXZhdGVLZXlJbmZvJywgZnVuY3Rpb24gKCkge1xuICB0aGlzLnNlcSgpLm9iaihcbiAgICB0aGlzLmtleSgnYWxnb3JpdGhtJykuc2VxKCkub2JqKFxuICAgICAgdGhpcy5rZXkoJ2lkJykub2JqaWQoKSxcbiAgICAgIHRoaXMua2V5KCdkZWNyeXB0Jykuc2VxKCkub2JqKFxuICAgICAgICB0aGlzLmtleSgna2RlJykuc2VxKCkub2JqKFxuICAgICAgICAgIHRoaXMua2V5KCdpZCcpLm9iamlkKCksXG4gICAgICAgICAgdGhpcy5rZXkoJ2tkZXBhcmFtcycpLnNlcSgpLm9iaihcbiAgICAgICAgICAgIHRoaXMua2V5KCdzYWx0Jykub2N0c3RyKCksXG4gICAgICAgICAgICB0aGlzLmtleSgnaXRlcnMnKS5pbnQoKVxuICAgICAgICAgIClcbiAgICAgICAgKSxcbiAgICAgICAgdGhpcy5rZXkoJ2NpcGhlcicpLnNlcSgpLm9iaihcbiAgICAgICAgICB0aGlzLmtleSgnYWxnbycpLm9iamlkKCksXG4gICAgICAgICAgdGhpcy5rZXkoJ2l2Jykub2N0c3RyKClcbiAgICAgICAgKVxuICAgICAgKVxuICAgICksXG4gICAgdGhpcy5rZXkoJ3N1YmplY3RQcml2YXRlS2V5Jykub2N0c3RyKClcbiAgKVxufSlcblxuZXhwb3J0cy5FbmNyeXB0ZWRQcml2YXRlS2V5ID0gRW5jcnlwdGVkUHJpdmF0ZUtleUluZm9cblxudmFyIERTQVByaXZhdGVLZXkgPSBhc24xLmRlZmluZSgnRFNBUHJpdmF0ZUtleScsIGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zZXEoKS5vYmooXG4gICAgdGhpcy5rZXkoJ3ZlcnNpb24nKS5pbnQoKSxcbiAgICB0aGlzLmtleSgncCcpLmludCgpLFxuICAgIHRoaXMua2V5KCdxJykuaW50KCksXG4gICAgdGhpcy5rZXkoJ2cnKS5pbnQoKSxcbiAgICB0aGlzLmtleSgncHViX2tleScpLmludCgpLFxuICAgIHRoaXMua2V5KCdwcml2X2tleScpLmludCgpXG4gIClcbn0pXG5leHBvcnRzLkRTQVByaXZhdGVLZXkgPSBEU0FQcml2YXRlS2V5XG5cbmV4cG9ydHMuRFNBcGFyYW0gPSBhc24xLmRlZmluZSgnRFNBcGFyYW0nLCBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuaW50KClcbn0pXG52YXIgRUNQcml2YXRlS2V5ID0gYXNuMS5kZWZpbmUoJ0VDUHJpdmF0ZUtleScsIGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zZXEoKS5vYmooXG4gICAgdGhpcy5rZXkoJ3ZlcnNpb24nKS5pbnQoKSxcbiAgICB0aGlzLmtleSgncHJpdmF0ZUtleScpLm9jdHN0cigpLFxuICAgIHRoaXMua2V5KCdwYXJhbWV0ZXJzJykub3B0aW9uYWwoKS5leHBsaWNpdCgwKS51c2UoRUNQYXJhbWV0ZXJzKSxcbiAgICB0aGlzLmtleSgncHVibGljS2V5Jykub3B0aW9uYWwoKS5leHBsaWNpdCgxKS5iaXRzdHIoKVxuICApXG59KVxuZXhwb3J0cy5FQ1ByaXZhdGVLZXkgPSBFQ1ByaXZhdGVLZXlcbnZhciBFQ1BhcmFtZXRlcnMgPSBhc24xLmRlZmluZSgnRUNQYXJhbWV0ZXJzJywgZnVuY3Rpb24gKCkge1xuICB0aGlzLmNob2ljZSh7XG4gICAgbmFtZWRDdXJ2ZTogdGhpcy5vYmppZCgpXG4gIH0pXG59KVxuXG5leHBvcnRzLnNpZ25hdHVyZSA9IGFzbjEuZGVmaW5lKCdzaWduYXR1cmUnLCBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc2VxKCkub2JqKFxuICAgIHRoaXMua2V5KCdyJykuaW50KCksXG4gICAgdGhpcy5rZXkoJ3MnKS5pbnQoKVxuICApXG59KVxuIiwiLy8gYWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9hcGF0aWwvcGVtc3RyaXBcbnZhciBmaW5kUHJvYyA9IC9Qcm9jLVR5cGU6IDQsRU5DUllQVEVEXFxyP1xcbkRFSy1JbmZvOiBBRVMtKCg/OjEyOCl8KD86MTkyKXwoPzoyNTYpKS1DQkMsKFswLTlBLUhdKylcXHI/XFxuXFxyP1xcbihbMC05QS16XFxuXFxyXFwrXFwvXFw9XSspXFxyP1xcbi9tXG52YXIgc3RhcnRSZWdleCA9IC9eLS0tLS1CRUdJTiAoLiopIEtFWS0tLS0tXFxyP1xcbi9tXG52YXIgZnVsbFJlZ2V4ID0gL14tLS0tLUJFR0lOICguKikgS0VZLS0tLS1cXHI/XFxuKFswLTlBLXpcXG5cXHJcXCtcXC9cXD1dKylcXHI/XFxuLS0tLS1FTkQgXFwxIEtFWS0tLS0tJC9tXG52YXIgZXZwID0gcmVxdWlyZSgnZXZwX2J5dGVzdG9rZXknKVxudmFyIGNpcGhlcnMgPSByZXF1aXJlKCdicm93c2VyaWZ5LWFlcycpXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChva2V5LCBwYXNzd29yZCkge1xuICB2YXIga2V5ID0gb2tleS50b1N0cmluZygpXG4gIHZhciBtYXRjaCA9IGtleS5tYXRjaChmaW5kUHJvYylcbiAgdmFyIGRlY3J5cHRlZFxuICBpZiAoIW1hdGNoKSB7XG4gICAgdmFyIG1hdGNoMiA9IGtleS5tYXRjaChmdWxsUmVnZXgpXG4gICAgZGVjcnlwdGVkID0gbmV3IEJ1ZmZlcihtYXRjaDJbMl0ucmVwbGFjZSgvXFxyP1xcbi9nLCAnJyksICdiYXNlNjQnKVxuICB9IGVsc2Uge1xuICAgIHZhciBzdWl0ZSA9ICdhZXMnICsgbWF0Y2hbMV1cbiAgICB2YXIgaXYgPSBuZXcgQnVmZmVyKG1hdGNoWzJdLCAnaGV4JylcbiAgICB2YXIgY2lwaGVyVGV4dCA9IG5ldyBCdWZmZXIobWF0Y2hbM10ucmVwbGFjZSgvXFxyP1xcbi9nLCAnJyksICdiYXNlNjQnKVxuICAgIHZhciBjaXBoZXJLZXkgPSBldnAocGFzc3dvcmQsIGl2LnNsaWNlKDAsIDgpLCBwYXJzZUludChtYXRjaFsxXSwgMTApKS5rZXlcbiAgICB2YXIgb3V0ID0gW11cbiAgICB2YXIgY2lwaGVyID0gY2lwaGVycy5jcmVhdGVEZWNpcGhlcml2KHN1aXRlLCBjaXBoZXJLZXksIGl2KVxuICAgIG91dC5wdXNoKGNpcGhlci51cGRhdGUoY2lwaGVyVGV4dCkpXG4gICAgb3V0LnB1c2goY2lwaGVyLmZpbmFsKCkpXG4gICAgZGVjcnlwdGVkID0gQnVmZmVyLmNvbmNhdChvdXQpXG4gIH1cbiAgdmFyIHRhZyA9IGtleS5tYXRjaChzdGFydFJlZ2V4KVsxXSArICcgS0VZJ1xuICByZXR1cm4ge1xuICAgIHRhZzogdGFnLFxuICAgIGRhdGE6IGRlY3J5cHRlZFxuICB9XG59XG4iLCJ2YXIgYXNuMSA9IHJlcXVpcmUoJy4vYXNuMScpXG52YXIgYWVzaWQgPSByZXF1aXJlKCcuL2Flc2lkLmpzb24nKVxudmFyIGZpeFByb2MgPSByZXF1aXJlKCcuL2ZpeFByb2MnKVxudmFyIGNpcGhlcnMgPSByZXF1aXJlKCdicm93c2VyaWZ5LWFlcycpXG52YXIgY29tcGF0ID0gcmVxdWlyZSgncGJrZGYyJylcbm1vZHVsZS5leHBvcnRzID0gcGFyc2VLZXlzXG5cbmZ1bmN0aW9uIHBhcnNlS2V5cyAoYnVmZmVyKSB7XG4gIHZhciBwYXNzd29yZFxuICBpZiAodHlwZW9mIGJ1ZmZlciA9PT0gJ29iamVjdCcgJiYgIUJ1ZmZlci5pc0J1ZmZlcihidWZmZXIpKSB7XG4gICAgcGFzc3dvcmQgPSBidWZmZXIucGFzc3BocmFzZVxuICAgIGJ1ZmZlciA9IGJ1ZmZlci5rZXlcbiAgfVxuICBpZiAodHlwZW9mIGJ1ZmZlciA9PT0gJ3N0cmluZycpIHtcbiAgICBidWZmZXIgPSBuZXcgQnVmZmVyKGJ1ZmZlcilcbiAgfVxuXG4gIHZhciBzdHJpcHBlZCA9IGZpeFByb2MoYnVmZmVyLCBwYXNzd29yZClcblxuICB2YXIgdHlwZSA9IHN0cmlwcGVkLnRhZ1xuICB2YXIgZGF0YSA9IHN0cmlwcGVkLmRhdGFcbiAgdmFyIHN1YnR5cGUsIG5kYXRhXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ1BVQkxJQyBLRVknOlxuICAgICAgbmRhdGEgPSBhc24xLlB1YmxpY0tleS5kZWNvZGUoZGF0YSwgJ2RlcicpXG4gICAgICBzdWJ0eXBlID0gbmRhdGEuYWxnb3JpdGhtLmFsZ29yaXRobS5qb2luKCcuJylcbiAgICAgIHN3aXRjaCAoc3VidHlwZSkge1xuICAgICAgICBjYXNlICcxLjIuODQwLjExMzU0OS4xLjEuMSc6XG4gICAgICAgICAgcmV0dXJuIGFzbjEuUlNBUHVibGljS2V5LmRlY29kZShuZGF0YS5zdWJqZWN0UHVibGljS2V5LmRhdGEsICdkZXInKVxuICAgICAgICBjYXNlICcxLjIuODQwLjEwMDQ1LjIuMSc6XG4gICAgICAgICAgbmRhdGEuc3ViamVjdFByaXZhdGVLZXkgPSBuZGF0YS5zdWJqZWN0UHVibGljS2V5XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdlYycsXG4gICAgICAgICAgICBkYXRhOiBuZGF0YVxuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAnMS4yLjg0MC4xMDA0MC40LjEnOlxuICAgICAgICAgIG5kYXRhLmFsZ29yaXRobS5wYXJhbXMucHViX2tleSA9IGFzbjEuRFNBcGFyYW0uZGVjb2RlKG5kYXRhLnN1YmplY3RQdWJsaWNLZXkuZGF0YSwgJ2RlcicpXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdkc2EnLFxuICAgICAgICAgICAgZGF0YTogbmRhdGEuYWxnb3JpdGhtLnBhcmFtc1xuICAgICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGtleSBpZCAnICsgc3VidHlwZSlcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biBrZXkgdHlwZSAnICsgdHlwZSlcbiAgICBjYXNlICdFTkNSWVBURUQgUFJJVkFURSBLRVknOlxuICAgICAgZGF0YSA9IGFzbjEuRW5jcnlwdGVkUHJpdmF0ZUtleS5kZWNvZGUoZGF0YSwgJ2RlcicpXG4gICAgICBkYXRhID0gZGVjcnlwdChkYXRhLCBwYXNzd29yZClcbiAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICBjYXNlICdQUklWQVRFIEtFWSc6XG4gICAgICBuZGF0YSA9IGFzbjEuUHJpdmF0ZUtleS5kZWNvZGUoZGF0YSwgJ2RlcicpXG4gICAgICBzdWJ0eXBlID0gbmRhdGEuYWxnb3JpdGhtLmFsZ29yaXRobS5qb2luKCcuJylcbiAgICAgIHN3aXRjaCAoc3VidHlwZSkge1xuICAgICAgICBjYXNlICcxLjIuODQwLjExMzU0OS4xLjEuMSc6XG4gICAgICAgICAgcmV0dXJuIGFzbjEuUlNBUHJpdmF0ZUtleS5kZWNvZGUobmRhdGEuc3ViamVjdFByaXZhdGVLZXksICdkZXInKVxuICAgICAgICBjYXNlICcxLjIuODQwLjEwMDQ1LjIuMSc6XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGN1cnZlOiBuZGF0YS5hbGdvcml0aG0uY3VydmUsXG4gICAgICAgICAgICBwcml2YXRlS2V5OiBhc24xLkVDUHJpdmF0ZUtleS5kZWNvZGUobmRhdGEuc3ViamVjdFByaXZhdGVLZXksICdkZXInKS5wcml2YXRlS2V5XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlICcxLjIuODQwLjEwMDQwLjQuMSc6XG4gICAgICAgICAgbmRhdGEuYWxnb3JpdGhtLnBhcmFtcy5wcml2X2tleSA9IGFzbjEuRFNBcGFyYW0uZGVjb2RlKG5kYXRhLnN1YmplY3RQcml2YXRlS2V5LCAnZGVyJylcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ2RzYScsXG4gICAgICAgICAgICBwYXJhbXM6IG5kYXRhLmFsZ29yaXRobS5wYXJhbXNcbiAgICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcigndW5rbm93biBrZXkgaWQgJyArIHN1YnR5cGUpXG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24ga2V5IHR5cGUgJyArIHR5cGUpXG4gICAgY2FzZSAnUlNBIFBVQkxJQyBLRVknOlxuICAgICAgcmV0dXJuIGFzbjEuUlNBUHVibGljS2V5LmRlY29kZShkYXRhLCAnZGVyJylcbiAgICBjYXNlICdSU0EgUFJJVkFURSBLRVknOlxuICAgICAgcmV0dXJuIGFzbjEuUlNBUHJpdmF0ZUtleS5kZWNvZGUoZGF0YSwgJ2RlcicpXG4gICAgY2FzZSAnRFNBIFBSSVZBVEUgS0VZJzpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdkc2EnLFxuICAgICAgICBwYXJhbXM6IGFzbjEuRFNBUHJpdmF0ZUtleS5kZWNvZGUoZGF0YSwgJ2RlcicpXG4gICAgICB9XG4gICAgY2FzZSAnRUMgUFJJVkFURSBLRVknOlxuICAgICAgZGF0YSA9IGFzbjEuRUNQcml2YXRlS2V5LmRlY29kZShkYXRhLCAnZGVyJylcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGN1cnZlOiBkYXRhLnBhcmFtZXRlcnMudmFsdWUsXG4gICAgICAgIHByaXZhdGVLZXk6IGRhdGEucHJpdmF0ZUtleVxuICAgICAgfVxuICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcigndW5rbm93biBrZXkgdHlwZSAnICsgdHlwZSlcbiAgfVxufVxucGFyc2VLZXlzLnNpZ25hdHVyZSA9IGFzbjEuc2lnbmF0dXJlXG5mdW5jdGlvbiBkZWNyeXB0IChkYXRhLCBwYXNzd29yZCkge1xuICB2YXIgc2FsdCA9IGRhdGEuYWxnb3JpdGhtLmRlY3J5cHQua2RlLmtkZXBhcmFtcy5zYWx0XG4gIHZhciBpdGVycyA9IHBhcnNlSW50KGRhdGEuYWxnb3JpdGhtLmRlY3J5cHQua2RlLmtkZXBhcmFtcy5pdGVycy50b1N0cmluZygpLCAxMClcbiAgdmFyIGFsZ28gPSBhZXNpZFtkYXRhLmFsZ29yaXRobS5kZWNyeXB0LmNpcGhlci5hbGdvLmpvaW4oJy4nKV1cbiAgdmFyIGl2ID0gZGF0YS5hbGdvcml0aG0uZGVjcnlwdC5jaXBoZXIuaXZcbiAgdmFyIGNpcGhlclRleHQgPSBkYXRhLnN1YmplY3RQcml2YXRlS2V5XG4gIHZhciBrZXlsZW4gPSBwYXJzZUludChhbGdvLnNwbGl0KCctJylbMV0sIDEwKSAvIDhcbiAgdmFyIGtleSA9IGNvbXBhdC5wYmtkZjJTeW5jKHBhc3N3b3JkLCBzYWx0LCBpdGVycywga2V5bGVuKVxuICB2YXIgY2lwaGVyID0gY2lwaGVycy5jcmVhdGVEZWNpcGhlcml2KGFsZ28sIGtleSwgaXYpXG4gIHZhciBvdXQgPSBbXVxuICBvdXQucHVzaChjaXBoZXIudXBkYXRlKGNpcGhlclRleHQpKVxuICBvdXQucHVzaChjaXBoZXIuZmluYWwoKSlcbiAgcmV0dXJuIEJ1ZmZlci5jb25jYXQob3V0KVxufVxuIiwidmFyIGFzbjEgPSBleHBvcnRzO1xuXG5hc24xLmJpZ251bSA9IHJlcXVpcmUoJ2JuLmpzJyk7XG5cbmFzbjEuZGVmaW5lID0gcmVxdWlyZSgnLi9hc24xL2FwaScpLmRlZmluZTtcbmFzbjEuYmFzZSA9IHJlcXVpcmUoJy4vYXNuMS9iYXNlJyk7XG5hc24xLmNvbnN0YW50cyA9IHJlcXVpcmUoJy4vYXNuMS9jb25zdGFudHMnKTtcbmFzbjEuZGVjb2RlcnMgPSByZXF1aXJlKCcuL2FzbjEvZGVjb2RlcnMnKTtcbmFzbjEuZW5jb2RlcnMgPSByZXF1aXJlKCcuL2FzbjEvZW5jb2RlcnMnKTtcbiIsInZhciBhc24xID0gcmVxdWlyZSgnLi4vYXNuMScpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxudmFyIGFwaSA9IGV4cG9ydHM7XG5cbmFwaS5kZWZpbmUgPSBmdW5jdGlvbiBkZWZpbmUobmFtZSwgYm9keSkge1xuICByZXR1cm4gbmV3IEVudGl0eShuYW1lLCBib2R5KTtcbn07XG5cbmZ1bmN0aW9uIEVudGl0eShuYW1lLCBib2R5KSB7XG4gIHRoaXMubmFtZSA9IG5hbWU7XG4gIHRoaXMuYm9keSA9IGJvZHk7XG5cbiAgdGhpcy5kZWNvZGVycyA9IHt9O1xuICB0aGlzLmVuY29kZXJzID0ge307XG59O1xuXG5FbnRpdHkucHJvdG90eXBlLl9jcmVhdGVOYW1lZCA9IGZ1bmN0aW9uIGNyZWF0ZU5hbWVkKGJhc2UpIHtcbiAgdmFyIG5hbWVkO1xuICB0cnkge1xuICAgIG5hbWVkID0gcmVxdWlyZSgndm0nKS5ydW5JblRoaXNDb250ZXh0KFxuICAgICAgJyhmdW5jdGlvbiAnICsgdGhpcy5uYW1lICsgJyhlbnRpdHkpIHtcXG4nICtcbiAgICAgICcgIHRoaXMuX2luaXROYW1lZChlbnRpdHkpO1xcbicgK1xuICAgICAgJ30pJ1xuICAgICk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBuYW1lZCA9IGZ1bmN0aW9uIChlbnRpdHkpIHtcbiAgICAgIHRoaXMuX2luaXROYW1lZChlbnRpdHkpO1xuICAgIH07XG4gIH1cbiAgaW5oZXJpdHMobmFtZWQsIGJhc2UpO1xuICBuYW1lZC5wcm90b3R5cGUuX2luaXROYW1lZCA9IGZ1bmN0aW9uIGluaXRuYW1lZChlbnRpdHkpIHtcbiAgICBiYXNlLmNhbGwodGhpcywgZW50aXR5KTtcbiAgfTtcblxuICByZXR1cm4gbmV3IG5hbWVkKHRoaXMpO1xufTtcblxuRW50aXR5LnByb3RvdHlwZS5fZ2V0RGVjb2RlciA9IGZ1bmN0aW9uIF9nZXREZWNvZGVyKGVuYykge1xuICAvLyBMYXppbHkgY3JlYXRlIGRlY29kZXJcbiAgaWYgKCF0aGlzLmRlY29kZXJzLmhhc093blByb3BlcnR5KGVuYykpXG4gICAgdGhpcy5kZWNvZGVyc1tlbmNdID0gdGhpcy5fY3JlYXRlTmFtZWQoYXNuMS5kZWNvZGVyc1tlbmNdKTtcbiAgcmV0dXJuIHRoaXMuZGVjb2RlcnNbZW5jXTtcbn07XG5cbkVudGl0eS5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKGRhdGEsIGVuYywgb3B0aW9ucykge1xuICByZXR1cm4gdGhpcy5fZ2V0RGVjb2RlcihlbmMpLmRlY29kZShkYXRhLCBvcHRpb25zKTtcbn07XG5cbkVudGl0eS5wcm90b3R5cGUuX2dldEVuY29kZXIgPSBmdW5jdGlvbiBfZ2V0RW5jb2RlcihlbmMpIHtcbiAgLy8gTGF6aWx5IGNyZWF0ZSBlbmNvZGVyXG4gIGlmICghdGhpcy5lbmNvZGVycy5oYXNPd25Qcm9wZXJ0eShlbmMpKVxuICAgIHRoaXMuZW5jb2RlcnNbZW5jXSA9IHRoaXMuX2NyZWF0ZU5hbWVkKGFzbjEuZW5jb2RlcnNbZW5jXSk7XG4gIHJldHVybiB0aGlzLmVuY29kZXJzW2VuY107XG59O1xuXG5FbnRpdHkucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShkYXRhLCBlbmMsIC8qIGludGVybmFsICovIHJlcG9ydGVyKSB7XG4gIHJldHVybiB0aGlzLl9nZXRFbmNvZGVyKGVuYykuZW5jb2RlKGRhdGEsIHJlcG9ydGVyKTtcbn07XG4iLCJ2YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xudmFyIFJlcG9ydGVyID0gcmVxdWlyZSgnLi4vYmFzZScpLlJlcG9ydGVyO1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcblxuZnVuY3Rpb24gRGVjb2RlckJ1ZmZlcihiYXNlLCBvcHRpb25zKSB7XG4gIFJlcG9ydGVyLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJhc2UpKSB7XG4gICAgdGhpcy5lcnJvcignSW5wdXQgbm90IEJ1ZmZlcicpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuYmFzZSA9IGJhc2U7XG4gIHRoaXMub2Zmc2V0ID0gMDtcbiAgdGhpcy5sZW5ndGggPSBiYXNlLmxlbmd0aDtcbn1cbmluaGVyaXRzKERlY29kZXJCdWZmZXIsIFJlcG9ydGVyKTtcbmV4cG9ydHMuRGVjb2RlckJ1ZmZlciA9IERlY29kZXJCdWZmZXI7XG5cbkRlY29kZXJCdWZmZXIucHJvdG90eXBlLnNhdmUgPSBmdW5jdGlvbiBzYXZlKCkge1xuICByZXR1cm4geyBvZmZzZXQ6IHRoaXMub2Zmc2V0LCByZXBvcnRlcjogUmVwb3J0ZXIucHJvdG90eXBlLnNhdmUuY2FsbCh0aGlzKSB9O1xufTtcblxuRGVjb2RlckJ1ZmZlci5wcm90b3R5cGUucmVzdG9yZSA9IGZ1bmN0aW9uIHJlc3RvcmUoc2F2ZSkge1xuICAvLyBSZXR1cm4gc2tpcHBlZCBkYXRhXG4gIHZhciByZXMgPSBuZXcgRGVjb2RlckJ1ZmZlcih0aGlzLmJhc2UpO1xuICByZXMub2Zmc2V0ID0gc2F2ZS5vZmZzZXQ7XG4gIHJlcy5sZW5ndGggPSB0aGlzLm9mZnNldDtcblxuICB0aGlzLm9mZnNldCA9IHNhdmUub2Zmc2V0O1xuICBSZXBvcnRlci5wcm90b3R5cGUucmVzdG9yZS5jYWxsKHRoaXMsIHNhdmUucmVwb3J0ZXIpO1xuXG4gIHJldHVybiByZXM7XG59O1xuXG5EZWNvZGVyQnVmZmVyLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gaXNFbXB0eSgpIHtcbiAgcmV0dXJuIHRoaXMub2Zmc2V0ID09PSB0aGlzLmxlbmd0aDtcbn07XG5cbkRlY29kZXJCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OChmYWlsKSB7XG4gIGlmICh0aGlzLm9mZnNldCArIDEgPD0gdGhpcy5sZW5ndGgpXG4gICAgcmV0dXJuIHRoaXMuYmFzZS5yZWFkVUludDgodGhpcy5vZmZzZXQrKywgdHJ1ZSk7XG4gIGVsc2VcbiAgICByZXR1cm4gdGhpcy5lcnJvcihmYWlsIHx8ICdEZWNvZGVyQnVmZmVyIG92ZXJydW4nKTtcbn1cblxuRGVjb2RlckJ1ZmZlci5wcm90b3R5cGUuc2tpcCA9IGZ1bmN0aW9uIHNraXAoYnl0ZXMsIGZhaWwpIHtcbiAgaWYgKCEodGhpcy5vZmZzZXQgKyBieXRlcyA8PSB0aGlzLmxlbmd0aCkpXG4gICAgcmV0dXJuIHRoaXMuZXJyb3IoZmFpbCB8fCAnRGVjb2RlckJ1ZmZlciBvdmVycnVuJyk7XG5cbiAgdmFyIHJlcyA9IG5ldyBEZWNvZGVyQnVmZmVyKHRoaXMuYmFzZSk7XG5cbiAgLy8gU2hhcmUgcmVwb3J0ZXIgc3RhdGVcbiAgcmVzLl9yZXBvcnRlclN0YXRlID0gdGhpcy5fcmVwb3J0ZXJTdGF0ZTtcblxuICByZXMub2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gIHJlcy5sZW5ndGggPSB0aGlzLm9mZnNldCArIGJ5dGVzO1xuICB0aGlzLm9mZnNldCArPSBieXRlcztcbiAgcmV0dXJuIHJlcztcbn1cblxuRGVjb2RlckJ1ZmZlci5wcm90b3R5cGUucmF3ID0gZnVuY3Rpb24gcmF3KHNhdmUpIHtcbiAgcmV0dXJuIHRoaXMuYmFzZS5zbGljZShzYXZlID8gc2F2ZS5vZmZzZXQgOiB0aGlzLm9mZnNldCwgdGhpcy5sZW5ndGgpO1xufVxuXG5mdW5jdGlvbiBFbmNvZGVyQnVmZmVyKHZhbHVlLCByZXBvcnRlcikge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlLm1hcChmdW5jdGlvbihpdGVtKSB7XG4gICAgICBpZiAoIShpdGVtIGluc3RhbmNlb2YgRW5jb2RlckJ1ZmZlcikpXG4gICAgICAgIGl0ZW0gPSBuZXcgRW5jb2RlckJ1ZmZlcihpdGVtLCByZXBvcnRlcik7XG4gICAgICB0aGlzLmxlbmd0aCArPSBpdGVtLmxlbmd0aDtcbiAgICAgIHJldHVybiBpdGVtO1xuICAgIH0sIHRoaXMpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAoISgwIDw9IHZhbHVlICYmIHZhbHVlIDw9IDB4ZmYpKVxuICAgICAgcmV0dXJuIHJlcG9ydGVyLmVycm9yKCdub24tYnl0ZSBFbmNvZGVyQnVmZmVyIHZhbHVlJyk7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMubGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsdWUpO1xuICB9IGVsc2UgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5sZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHJlcG9ydGVyLmVycm9yKCdVbnN1cHBvcnRlZCB0eXBlOiAnICsgdHlwZW9mIHZhbHVlKTtcbiAgfVxufVxuZXhwb3J0cy5FbmNvZGVyQnVmZmVyID0gRW5jb2RlckJ1ZmZlcjtcblxuRW5jb2RlckJ1ZmZlci5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uIGpvaW4ob3V0LCBvZmZzZXQpIHtcbiAgaWYgKCFvdXQpXG4gICAgb3V0ID0gbmV3IEJ1ZmZlcih0aGlzLmxlbmd0aCk7XG4gIGlmICghb2Zmc2V0KVxuICAgIG9mZnNldCA9IDA7XG5cbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKVxuICAgIHJldHVybiBvdXQ7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy52YWx1ZSkpIHtcbiAgICB0aGlzLnZhbHVlLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xuICAgICAgaXRlbS5qb2luKG91dCwgb2Zmc2V0KTtcbiAgICAgIG9mZnNldCArPSBpdGVtLmxlbmd0aDtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIHRoaXMudmFsdWUgPT09ICdudW1iZXInKVxuICAgICAgb3V0W29mZnNldF0gPSB0aGlzLnZhbHVlO1xuICAgIGVsc2UgaWYgKHR5cGVvZiB0aGlzLnZhbHVlID09PSAnc3RyaW5nJylcbiAgICAgIG91dC53cml0ZSh0aGlzLnZhbHVlLCBvZmZzZXQpO1xuICAgIGVsc2UgaWYgKEJ1ZmZlci5pc0J1ZmZlcih0aGlzLnZhbHVlKSlcbiAgICAgIHRoaXMudmFsdWUuY29weShvdXQsIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IHRoaXMubGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn07XG4iLCJ2YXIgYmFzZSA9IGV4cG9ydHM7XG5cbmJhc2UuUmVwb3J0ZXIgPSByZXF1aXJlKCcuL3JlcG9ydGVyJykuUmVwb3J0ZXI7XG5iYXNlLkRlY29kZXJCdWZmZXIgPSByZXF1aXJlKCcuL2J1ZmZlcicpLkRlY29kZXJCdWZmZXI7XG5iYXNlLkVuY29kZXJCdWZmZXIgPSByZXF1aXJlKCcuL2J1ZmZlcicpLkVuY29kZXJCdWZmZXI7XG5iYXNlLk5vZGUgPSByZXF1aXJlKCcuL25vZGUnKTtcbiIsInZhciBSZXBvcnRlciA9IHJlcXVpcmUoJy4uL2Jhc2UnKS5SZXBvcnRlcjtcbnZhciBFbmNvZGVyQnVmZmVyID0gcmVxdWlyZSgnLi4vYmFzZScpLkVuY29kZXJCdWZmZXI7XG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnbWluaW1hbGlzdGljLWFzc2VydCcpO1xuXG4vLyBTdXBwb3J0ZWQgdGFnc1xudmFyIHRhZ3MgPSBbXG4gICdzZXEnLCAnc2Vxb2YnLCAnc2V0JywgJ3NldG9mJywgJ29jdHN0cicsICdiaXRzdHInLCAnb2JqaWQnLCAnYm9vbCcsXG4gICdnZW50aW1lJywgJ3V0Y3RpbWUnLCAnbnVsbF8nLCAnZW51bScsICdpbnQnLCAnaWE1c3RyJywgJ3V0ZjhzdHInLCAnYm1wc3RyJyxcbiAgJ251bXN0cicsICdwcmludHN0cidcbl07XG5cbi8vIFB1YmxpYyBtZXRob2RzIGxpc3RcbnZhciBtZXRob2RzID0gW1xuICAna2V5JywgJ29iaicsICd1c2UnLCAnb3B0aW9uYWwnLCAnZXhwbGljaXQnLCAnaW1wbGljaXQnLCAnZGVmJywgJ2Nob2ljZScsXG4gICdhbnknXG5dLmNvbmNhdCh0YWdzKTtcblxuLy8gT3ZlcnJpZGVkIG1ldGhvZHMgbGlzdFxudmFyIG92ZXJyaWRlZCA9IFtcbiAgJ19wZWVrVGFnJywgJ19kZWNvZGVUYWcnLCAnX3VzZScsXG4gICdfZGVjb2RlU3RyJywgJ19kZWNvZGVPYmppZCcsICdfZGVjb2RlVGltZScsXG4gICdfZGVjb2RlTnVsbCcsICdfZGVjb2RlSW50JywgJ19kZWNvZGVCb29sJywgJ19kZWNvZGVMaXN0JyxcblxuICAnX2VuY29kZUNvbXBvc2l0ZScsICdfZW5jb2RlU3RyJywgJ19lbmNvZGVPYmppZCcsICdfZW5jb2RlVGltZScsXG4gICdfZW5jb2RlTnVsbCcsICdfZW5jb2RlSW50JywgJ19lbmNvZGVCb29sJ1xuXTtcblxuZnVuY3Rpb24gTm9kZShlbmMsIHBhcmVudCkge1xuICB2YXIgc3RhdGUgPSB7fTtcbiAgdGhpcy5fYmFzZVN0YXRlID0gc3RhdGU7XG5cbiAgc3RhdGUuZW5jID0gZW5jO1xuXG4gIHN0YXRlLnBhcmVudCA9IHBhcmVudCB8fCBudWxsO1xuICBzdGF0ZS5jaGlsZHJlbiA9IG51bGw7XG5cbiAgLy8gU3RhdGVcbiAgc3RhdGUudGFnID0gbnVsbDtcbiAgc3RhdGUuYXJncyA9IG51bGw7XG4gIHN0YXRlLnJldmVyc2VBcmdzID0gbnVsbDtcbiAgc3RhdGUuY2hvaWNlID0gbnVsbDtcbiAgc3RhdGUub3B0aW9uYWwgPSBmYWxzZTtcbiAgc3RhdGUuYW55ID0gZmFsc2U7XG4gIHN0YXRlLm9iaiA9IGZhbHNlO1xuICBzdGF0ZS51c2UgPSBudWxsO1xuICBzdGF0ZS51c2VEZWNvZGVyID0gbnVsbDtcbiAgc3RhdGUua2V5ID0gbnVsbDtcbiAgc3RhdGVbJ2RlZmF1bHQnXSA9IG51bGw7XG4gIHN0YXRlLmV4cGxpY2l0ID0gbnVsbDtcbiAgc3RhdGUuaW1wbGljaXQgPSBudWxsO1xuXG4gIC8vIFNob3VsZCBjcmVhdGUgbmV3IGluc3RhbmNlIG9uIGVhY2ggbWV0aG9kXG4gIGlmICghc3RhdGUucGFyZW50KSB7XG4gICAgc3RhdGUuY2hpbGRyZW4gPSBbXTtcbiAgICB0aGlzLl93cmFwKCk7XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gTm9kZTtcblxudmFyIHN0YXRlUHJvcHMgPSBbXG4gICdlbmMnLCAncGFyZW50JywgJ2NoaWxkcmVuJywgJ3RhZycsICdhcmdzJywgJ3JldmVyc2VBcmdzJywgJ2Nob2ljZScsXG4gICdvcHRpb25hbCcsICdhbnknLCAnb2JqJywgJ3VzZScsICdhbHRlcmVkVXNlJywgJ2tleScsICdkZWZhdWx0JywgJ2V4cGxpY2l0JyxcbiAgJ2ltcGxpY2l0J1xuXTtcblxuTm9kZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuICB2YXIgY3N0YXRlID0ge307XG4gIHN0YXRlUHJvcHMuZm9yRWFjaChmdW5jdGlvbihwcm9wKSB7XG4gICAgY3N0YXRlW3Byb3BdID0gc3RhdGVbcHJvcF07XG4gIH0pO1xuICB2YXIgcmVzID0gbmV3IHRoaXMuY29uc3RydWN0b3IoY3N0YXRlLnBhcmVudCk7XG4gIHJlcy5fYmFzZVN0YXRlID0gY3N0YXRlO1xuICByZXR1cm4gcmVzO1xufTtcblxuTm9kZS5wcm90b3R5cGUuX3dyYXAgPSBmdW5jdGlvbiB3cmFwKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG4gIG1ldGhvZHMuZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICB0aGlzW21ldGhvZF0gPSBmdW5jdGlvbiBfd3JhcHBlZE1ldGhvZCgpIHtcbiAgICAgIHZhciBjbG9uZSA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMpO1xuICAgICAgc3RhdGUuY2hpbGRyZW4ucHVzaChjbG9uZSk7XG4gICAgICByZXR1cm4gY2xvbmVbbWV0aG9kXS5hcHBseShjbG9uZSwgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9LCB0aGlzKTtcbn07XG5cbk5vZGUucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gaW5pdChib2R5KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcblxuICBhc3NlcnQoc3RhdGUucGFyZW50ID09PSBudWxsKTtcbiAgYm9keS5jYWxsKHRoaXMpO1xuXG4gIC8vIEZpbHRlciBjaGlsZHJlblxuICBzdGF0ZS5jaGlsZHJlbiA9IHN0YXRlLmNoaWxkcmVuLmZpbHRlcihmdW5jdGlvbihjaGlsZCkge1xuICAgIHJldHVybiBjaGlsZC5fYmFzZVN0YXRlLnBhcmVudCA9PT0gdGhpcztcbiAgfSwgdGhpcyk7XG4gIGFzc2VydC5lcXVhbChzdGF0ZS5jaGlsZHJlbi5sZW5ndGgsIDEsICdSb290IG5vZGUgY2FuIGhhdmUgb25seSBvbmUgY2hpbGQnKTtcbn07XG5cbk5vZGUucHJvdG90eXBlLl91c2VBcmdzID0gZnVuY3Rpb24gdXNlQXJncyhhcmdzKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcblxuICAvLyBGaWx0ZXIgY2hpbGRyZW4gYW5kIGFyZ3NcbiAgdmFyIGNoaWxkcmVuID0gYXJncy5maWx0ZXIoZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGFyZyBpbnN0YW5jZW9mIHRoaXMuY29uc3RydWN0b3I7XG4gIH0sIHRoaXMpO1xuICBhcmdzID0gYXJncy5maWx0ZXIoZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuICEoYXJnIGluc3RhbmNlb2YgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gIH0sIHRoaXMpO1xuXG4gIGlmIChjaGlsZHJlbi5sZW5ndGggIT09IDApIHtcbiAgICBhc3NlcnQoc3RhdGUuY2hpbGRyZW4gPT09IG51bGwpO1xuICAgIHN0YXRlLmNoaWxkcmVuID0gY2hpbGRyZW47XG5cbiAgICAvLyBSZXBsYWNlIHBhcmVudCB0byBtYWludGFpbiBiYWNrd2FyZCBsaW5rXG4gICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgY2hpbGQuX2Jhc2VTdGF0ZS5wYXJlbnQgPSB0aGlzO1xuICAgIH0sIHRoaXMpO1xuICB9XG4gIGlmIChhcmdzLmxlbmd0aCAhPT0gMCkge1xuICAgIGFzc2VydChzdGF0ZS5hcmdzID09PSBudWxsKTtcbiAgICBzdGF0ZS5hcmdzID0gYXJncztcbiAgICBzdGF0ZS5yZXZlcnNlQXJncyA9IGFyZ3MubWFwKGZ1bmN0aW9uKGFyZykge1xuICAgICAgaWYgKHR5cGVvZiBhcmcgIT09ICdvYmplY3QnIHx8IGFyZy5jb25zdHJ1Y3RvciAhPT0gT2JqZWN0KVxuICAgICAgICByZXR1cm4gYXJnO1xuXG4gICAgICB2YXIgcmVzID0ge307XG4gICAgICBPYmplY3Qua2V5cyhhcmcpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIGlmIChrZXkgPT0gKGtleSB8IDApKVxuICAgICAgICAgIGtleSB8PSAwO1xuICAgICAgICB2YXIgdmFsdWUgPSBhcmdba2V5XTtcbiAgICAgICAgcmVzW3ZhbHVlXSA9IGtleTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9KTtcbiAgfVxufTtcblxuLy9cbi8vIE92ZXJyaWRlZCBtZXRob2RzXG4vL1xuXG5vdmVycmlkZWQuZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgTm9kZS5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uIF9vdmVycmlkZWQoKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuICAgIHRocm93IG5ldyBFcnJvcihtZXRob2QgKyAnIG5vdCBpbXBsZW1lbnRlZCBmb3IgZW5jb2Rpbmc6ICcgKyBzdGF0ZS5lbmMpO1xuICB9O1xufSk7XG5cbi8vXG4vLyBQdWJsaWMgbWV0aG9kc1xuLy9cblxudGFncy5mb3JFYWNoKGZ1bmN0aW9uKHRhZykge1xuICBOb2RlLnByb3RvdHlwZVt0YWddID0gZnVuY3Rpb24gX3RhZ01ldGhvZCgpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXG4gICAgYXNzZXJ0KHN0YXRlLnRhZyA9PT0gbnVsbCk7XG4gICAgc3RhdGUudGFnID0gdGFnO1xuXG4gICAgdGhpcy5fdXNlQXJncyhhcmdzKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xufSk7XG5cbk5vZGUucHJvdG90eXBlLnVzZSA9IGZ1bmN0aW9uIHVzZShpdGVtKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcblxuICBhc3NlcnQoc3RhdGUudXNlID09PSBudWxsKTtcbiAgc3RhdGUudXNlID0gaXRlbTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbk5vZGUucHJvdG90eXBlLm9wdGlvbmFsID0gZnVuY3Rpb24gb3B0aW9uYWwoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcblxuICBzdGF0ZS5vcHRpb25hbCA9IHRydWU7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5kZWYgPSBmdW5jdGlvbiBkZWYodmFsKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcblxuICBhc3NlcnQoc3RhdGVbJ2RlZmF1bHQnXSA9PT0gbnVsbCk7XG4gIHN0YXRlWydkZWZhdWx0J10gPSB2YWw7XG4gIHN0YXRlLm9wdGlvbmFsID0gdHJ1ZTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbk5vZGUucHJvdG90eXBlLmV4cGxpY2l0ID0gZnVuY3Rpb24gZXhwbGljaXQobnVtKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcblxuICBhc3NlcnQoc3RhdGUuZXhwbGljaXQgPT09IG51bGwgJiYgc3RhdGUuaW1wbGljaXQgPT09IG51bGwpO1xuICBzdGF0ZS5leHBsaWNpdCA9IG51bTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbk5vZGUucHJvdG90eXBlLmltcGxpY2l0ID0gZnVuY3Rpb24gaW1wbGljaXQobnVtKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcblxuICBhc3NlcnQoc3RhdGUuZXhwbGljaXQgPT09IG51bGwgJiYgc3RhdGUuaW1wbGljaXQgPT09IG51bGwpO1xuICBzdGF0ZS5pbXBsaWNpdCA9IG51bTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbk5vZGUucHJvdG90eXBlLm9iaiA9IGZ1bmN0aW9uIG9iaigpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cbiAgc3RhdGUub2JqID0gdHJ1ZTtcblxuICBpZiAoYXJncy5sZW5ndGggIT09IDApXG4gICAgdGhpcy5fdXNlQXJncyhhcmdzKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbk5vZGUucHJvdG90eXBlLmtleSA9IGZ1bmN0aW9uIGtleShuZXdLZXkpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuXG4gIGFzc2VydChzdGF0ZS5rZXkgPT09IG51bGwpO1xuICBzdGF0ZS5rZXkgPSBuZXdLZXk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5hbnkgPSBmdW5jdGlvbiBhbnkoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcblxuICBzdGF0ZS5hbnkgPSB0cnVlO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuTm9kZS5wcm90b3R5cGUuY2hvaWNlID0gZnVuY3Rpb24gY2hvaWNlKG9iaikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG5cbiAgYXNzZXJ0KHN0YXRlLmNob2ljZSA9PT0gbnVsbCk7XG4gIHN0YXRlLmNob2ljZSA9IG9iajtcbiAgdGhpcy5fdXNlQXJncyhPYmplY3Qua2V5cyhvYmopLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gb2JqW2tleV07XG4gIH0pKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vXG4vLyBEZWNvZGluZ1xuLy9cblxuTm9kZS5wcm90b3R5cGUuX2RlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShpbnB1dCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG5cbiAgLy8gRGVjb2RlIHJvb3Qgbm9kZVxuICBpZiAoc3RhdGUucGFyZW50ID09PSBudWxsKVxuICAgIHJldHVybiBpbnB1dC53cmFwUmVzdWx0KHN0YXRlLmNoaWxkcmVuWzBdLl9kZWNvZGUoaW5wdXQpKTtcblxuICB2YXIgcmVzdWx0ID0gc3RhdGVbJ2RlZmF1bHQnXTtcbiAgdmFyIHByZXNlbnQgPSB0cnVlO1xuXG4gIHZhciBwcmV2S2V5O1xuICBpZiAoc3RhdGUua2V5ICE9PSBudWxsKVxuICAgIHByZXZLZXkgPSBpbnB1dC5lbnRlcktleShzdGF0ZS5rZXkpO1xuXG4gIC8vIENoZWNrIGlmIHRhZyBpcyB0aGVyZVxuICBpZiAoc3RhdGUub3B0aW9uYWwpIHtcbiAgICB2YXIgdGFnID0gbnVsbDtcbiAgICBpZiAoc3RhdGUuZXhwbGljaXQgIT09IG51bGwpXG4gICAgICB0YWcgPSBzdGF0ZS5leHBsaWNpdDtcbiAgICBlbHNlIGlmIChzdGF0ZS5pbXBsaWNpdCAhPT0gbnVsbClcbiAgICAgIHRhZyA9IHN0YXRlLmltcGxpY2l0O1xuICAgIGVsc2UgaWYgKHN0YXRlLnRhZyAhPT0gbnVsbClcbiAgICAgIHRhZyA9IHN0YXRlLnRhZztcblxuICAgIGlmICh0YWcgPT09IG51bGwgJiYgIXN0YXRlLmFueSkge1xuICAgICAgLy8gVHJpYWwgYW5kIEVycm9yXG4gICAgICB2YXIgc2F2ZSA9IGlucHV0LnNhdmUoKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChzdGF0ZS5jaG9pY2UgPT09IG51bGwpXG4gICAgICAgICAgdGhpcy5fZGVjb2RlR2VuZXJpYyhzdGF0ZS50YWcsIGlucHV0KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHRoaXMuX2RlY29kZUNob2ljZShpbnB1dCk7XG4gICAgICAgIHByZXNlbnQgPSB0cnVlO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBwcmVzZW50ID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpbnB1dC5yZXN0b3JlKHNhdmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcmVzZW50ID0gdGhpcy5fcGVla1RhZyhpbnB1dCwgdGFnLCBzdGF0ZS5hbnkpO1xuXG4gICAgICBpZiAoaW5wdXQuaXNFcnJvcihwcmVzZW50KSlcbiAgICAgICAgcmV0dXJuIHByZXNlbnQ7XG4gICAgfVxuICB9XG5cbiAgLy8gUHVzaCBvYmplY3Qgb24gc3RhY2tcbiAgdmFyIHByZXZPYmo7XG4gIGlmIChzdGF0ZS5vYmogJiYgcHJlc2VudClcbiAgICBwcmV2T2JqID0gaW5wdXQuZW50ZXJPYmplY3QoKTtcblxuICBpZiAocHJlc2VudCkge1xuICAgIC8vIFVud3JhcCBleHBsaWNpdCB2YWx1ZXNcbiAgICBpZiAoc3RhdGUuZXhwbGljaXQgIT09IG51bGwpIHtcbiAgICAgIHZhciBleHBsaWNpdCA9IHRoaXMuX2RlY29kZVRhZyhpbnB1dCwgc3RhdGUuZXhwbGljaXQpO1xuICAgICAgaWYgKGlucHV0LmlzRXJyb3IoZXhwbGljaXQpKVxuICAgICAgICByZXR1cm4gZXhwbGljaXQ7XG4gICAgICBpbnB1dCA9IGV4cGxpY2l0O1xuICAgIH1cblxuICAgIC8vIFVud3JhcCBpbXBsaWNpdCBhbmQgbm9ybWFsIHZhbHVlc1xuICAgIGlmIChzdGF0ZS51c2UgPT09IG51bGwgJiYgc3RhdGUuY2hvaWNlID09PSBudWxsKSB7XG4gICAgICBpZiAoc3RhdGUuYW55KVxuICAgICAgICB2YXIgc2F2ZSA9IGlucHV0LnNhdmUoKTtcbiAgICAgIHZhciBib2R5ID0gdGhpcy5fZGVjb2RlVGFnKFxuICAgICAgICBpbnB1dCxcbiAgICAgICAgc3RhdGUuaW1wbGljaXQgIT09IG51bGwgPyBzdGF0ZS5pbXBsaWNpdCA6IHN0YXRlLnRhZyxcbiAgICAgICAgc3RhdGUuYW55XG4gICAgICApO1xuICAgICAgaWYgKGlucHV0LmlzRXJyb3IoYm9keSkpXG4gICAgICAgIHJldHVybiBib2R5O1xuXG4gICAgICBpZiAoc3RhdGUuYW55KVxuICAgICAgICByZXN1bHQgPSBpbnB1dC5yYXcoc2F2ZSk7XG4gICAgICBlbHNlXG4gICAgICAgIGlucHV0ID0gYm9keTtcbiAgICB9XG5cbiAgICAvLyBTZWxlY3QgcHJvcGVyIG1ldGhvZCBmb3IgdGFnXG4gICAgaWYgKHN0YXRlLmFueSlcbiAgICAgIHJlc3VsdCA9IHJlc3VsdDtcbiAgICBlbHNlIGlmIChzdGF0ZS5jaG9pY2UgPT09IG51bGwpXG4gICAgICByZXN1bHQgPSB0aGlzLl9kZWNvZGVHZW5lcmljKHN0YXRlLnRhZywgaW5wdXQpO1xuICAgIGVsc2VcbiAgICAgIHJlc3VsdCA9IHRoaXMuX2RlY29kZUNob2ljZShpbnB1dCk7XG5cbiAgICBpZiAoaW5wdXQuaXNFcnJvcihyZXN1bHQpKVxuICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgIC8vIERlY29kZSBjaGlsZHJlblxuICAgIGlmICghc3RhdGUuYW55ICYmIHN0YXRlLmNob2ljZSA9PT0gbnVsbCAmJiBzdGF0ZS5jaGlsZHJlbiAhPT0gbnVsbCkge1xuICAgICAgdmFyIGZhaWwgPSBzdGF0ZS5jaGlsZHJlbi5zb21lKGZ1bmN0aW9uIGRlY29kZUNoaWxkcmVuKGNoaWxkKSB7XG4gICAgICAgIC8vIE5PVEU6IFdlIGFyZSBpZ25vcmluZyBlcnJvcnMgaGVyZSwgdG8gbGV0IHBhcnNlciBjb250aW51ZSB3aXRoIG90aGVyXG4gICAgICAgIC8vIHBhcnRzIG9mIGVuY29kZWQgZGF0YVxuICAgICAgICBjaGlsZC5fZGVjb2RlKGlucHV0KTtcbiAgICAgIH0pO1xuICAgICAgaWYgKGZhaWwpXG4gICAgICAgIHJldHVybiBlcnI7XG4gICAgfVxuICB9XG5cbiAgLy8gUG9wIG9iamVjdFxuICBpZiAoc3RhdGUub2JqICYmIHByZXNlbnQpXG4gICAgcmVzdWx0ID0gaW5wdXQubGVhdmVPYmplY3QocHJldk9iaik7XG5cbiAgLy8gU2V0IGtleVxuICBpZiAoc3RhdGUua2V5ICE9PSBudWxsICYmIChyZXN1bHQgIT09IG51bGwgfHwgcHJlc2VudCA9PT0gdHJ1ZSkpXG4gICAgaW5wdXQubGVhdmVLZXkocHJldktleSwgc3RhdGUua2V5LCByZXN1bHQpO1xuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5fZGVjb2RlR2VuZXJpYyA9IGZ1bmN0aW9uIGRlY29kZUdlbmVyaWModGFnLCBpbnB1dCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG5cbiAgaWYgKHRhZyA9PT0gJ3NlcScgfHwgdGFnID09PSAnc2V0JylcbiAgICByZXR1cm4gbnVsbDtcbiAgaWYgKHRhZyA9PT0gJ3NlcW9mJyB8fCB0YWcgPT09ICdzZXRvZicpXG4gICAgcmV0dXJuIHRoaXMuX2RlY29kZUxpc3QoaW5wdXQsIHRhZywgc3RhdGUuYXJnc1swXSk7XG4gIGVsc2UgaWYgKHRhZyA9PT0gJ29jdHN0cicgfHwgdGFnID09PSAnYml0c3RyJylcbiAgICByZXR1cm4gdGhpcy5fZGVjb2RlU3RyKGlucHV0LCB0YWcpO1xuICBlbHNlIGlmICh0YWcgPT09ICdpYTVzdHInIHx8IHRhZyA9PT0gJ3V0ZjhzdHInIHx8IHRhZyA9PT0gJ2JtcHN0cicpXG4gICAgcmV0dXJuIHRoaXMuX2RlY29kZVN0cihpbnB1dCwgdGFnKTtcbiAgZWxzZSBpZiAodGFnID09PSAnbnVtc3RyJyB8fCB0YWcgPT09ICdwcmludHN0cicpXG4gICAgcmV0dXJuIHRoaXMuX2RlY29kZVN0cihpbnB1dCwgdGFnKTtcbiAgZWxzZSBpZiAodGFnID09PSAnb2JqaWQnICYmIHN0YXRlLmFyZ3MpXG4gICAgcmV0dXJuIHRoaXMuX2RlY29kZU9iamlkKGlucHV0LCBzdGF0ZS5hcmdzWzBdLCBzdGF0ZS5hcmdzWzFdKTtcbiAgZWxzZSBpZiAodGFnID09PSAnb2JqaWQnKVxuICAgIHJldHVybiB0aGlzLl9kZWNvZGVPYmppZChpbnB1dCwgbnVsbCwgbnVsbCk7XG4gIGVsc2UgaWYgKHRhZyA9PT0gJ2dlbnRpbWUnIHx8IHRhZyA9PT0gJ3V0Y3RpbWUnKVxuICAgIHJldHVybiB0aGlzLl9kZWNvZGVUaW1lKGlucHV0LCB0YWcpO1xuICBlbHNlIGlmICh0YWcgPT09ICdudWxsXycpXG4gICAgcmV0dXJuIHRoaXMuX2RlY29kZU51bGwoaW5wdXQpO1xuICBlbHNlIGlmICh0YWcgPT09ICdib29sJylcbiAgICByZXR1cm4gdGhpcy5fZGVjb2RlQm9vbChpbnB1dCk7XG4gIGVsc2UgaWYgKHRhZyA9PT0gJ2ludCcgfHwgdGFnID09PSAnZW51bScpXG4gICAgcmV0dXJuIHRoaXMuX2RlY29kZUludChpbnB1dCwgc3RhdGUuYXJncyAmJiBzdGF0ZS5hcmdzWzBdKTtcbiAgZWxzZSBpZiAoc3RhdGUudXNlICE9PSBudWxsKVxuICAgIHJldHVybiB0aGlzLl9nZXRVc2Uoc3RhdGUudXNlLCBpbnB1dC5fcmVwb3J0ZXJTdGF0ZS5vYmopLl9kZWNvZGUoaW5wdXQpO1xuICBlbHNlXG4gICAgcmV0dXJuIGlucHV0LmVycm9yKCd1bmtub3duIHRhZzogJyArIHRhZyk7XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5fZ2V0VXNlID0gZnVuY3Rpb24gX2dldFVzZShlbnRpdHksIG9iaikge1xuXG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcbiAgLy8gQ3JlYXRlIGFsdGVyZWQgdXNlIGRlY29kZXIgaWYgaW1wbGljaXQgaXMgc2V0XG4gIHN0YXRlLnVzZURlY29kZXIgPSB0aGlzLl91c2UoZW50aXR5LCBvYmopO1xuICBhc3NlcnQoc3RhdGUudXNlRGVjb2Rlci5fYmFzZVN0YXRlLnBhcmVudCA9PT0gbnVsbCk7XG4gIHN0YXRlLnVzZURlY29kZXIgPSBzdGF0ZS51c2VEZWNvZGVyLl9iYXNlU3RhdGUuY2hpbGRyZW5bMF07XG4gIGlmIChzdGF0ZS5pbXBsaWNpdCAhPT0gc3RhdGUudXNlRGVjb2Rlci5fYmFzZVN0YXRlLmltcGxpY2l0KSB7XG4gICAgc3RhdGUudXNlRGVjb2RlciA9IHN0YXRlLnVzZURlY29kZXIuY2xvbmUoKTtcbiAgICBzdGF0ZS51c2VEZWNvZGVyLl9iYXNlU3RhdGUuaW1wbGljaXQgPSBzdGF0ZS5pbXBsaWNpdDtcbiAgfVxuICByZXR1cm4gc3RhdGUudXNlRGVjb2Rlcjtcbn07XG5cbk5vZGUucHJvdG90eXBlLl9kZWNvZGVDaG9pY2UgPSBmdW5jdGlvbiBkZWNvZGVDaG9pY2UoaW5wdXQpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgdmFyIG1hdGNoID0gZmFsc2U7XG5cbiAgT2JqZWN0LmtleXMoc3RhdGUuY2hvaWNlKS5zb21lKGZ1bmN0aW9uKGtleSkge1xuICAgIHZhciBzYXZlID0gaW5wdXQuc2F2ZSgpO1xuICAgIHZhciBub2RlID0gc3RhdGUuY2hvaWNlW2tleV07XG4gICAgdHJ5IHtcbiAgICAgIHZhciB2YWx1ZSA9IG5vZGUuX2RlY29kZShpbnB1dCk7XG4gICAgICBpZiAoaW5wdXQuaXNFcnJvcih2YWx1ZSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgcmVzdWx0ID0geyB0eXBlOiBrZXksIHZhbHVlOiB2YWx1ZSB9O1xuICAgICAgbWF0Y2ggPSB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlucHV0LnJlc3RvcmUoc2F2ZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9LCB0aGlzKTtcblxuICBpZiAoIW1hdGNoKVxuICAgIHJldHVybiBpbnB1dC5lcnJvcignQ2hvaWNlIG5vdCBtYXRjaGVkJyk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vXG4vLyBFbmNvZGluZ1xuLy9cblxuTm9kZS5wcm90b3R5cGUuX2NyZWF0ZUVuY29kZXJCdWZmZXIgPSBmdW5jdGlvbiBjcmVhdGVFbmNvZGVyQnVmZmVyKGRhdGEpIHtcbiAgcmV0dXJuIG5ldyBFbmNvZGVyQnVmZmVyKGRhdGEsIHRoaXMucmVwb3J0ZXIpO1xufTtcblxuTm9kZS5wcm90b3R5cGUuX2VuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShkYXRhLCByZXBvcnRlciwgcGFyZW50KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcbiAgaWYgKHN0YXRlWydkZWZhdWx0J10gIT09IG51bGwgJiYgc3RhdGVbJ2RlZmF1bHQnXSA9PT0gZGF0YSlcbiAgICByZXR1cm47XG5cbiAgdmFyIHJlc3VsdCA9IHRoaXMuX2VuY29kZVZhbHVlKGRhdGEsIHJlcG9ydGVyLCBwYXJlbnQpO1xuICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuO1xuXG4gIGlmICh0aGlzLl9za2lwRGVmYXVsdChyZXN1bHQsIHJlcG9ydGVyLCBwYXJlbnQpKVxuICAgIHJldHVybjtcblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuTm9kZS5wcm90b3R5cGUuX2VuY29kZVZhbHVlID0gZnVuY3Rpb24gZW5jb2RlKGRhdGEsIHJlcG9ydGVyLCBwYXJlbnQpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuXG4gIC8vIERlY29kZSByb290IG5vZGVcbiAgaWYgKHN0YXRlLnBhcmVudCA9PT0gbnVsbClcbiAgICByZXR1cm4gc3RhdGUuY2hpbGRyZW5bMF0uX2VuY29kZShkYXRhLCByZXBvcnRlciB8fCBuZXcgUmVwb3J0ZXIoKSk7XG5cbiAgdmFyIHJlc3VsdCA9IG51bGw7XG4gIHZhciBwcmVzZW50ID0gdHJ1ZTtcblxuICAvLyBTZXQgcmVwb3J0ZXIgdG8gc2hhcmUgaXQgd2l0aCBhIGNoaWxkIGNsYXNzXG4gIHRoaXMucmVwb3J0ZXIgPSByZXBvcnRlcjtcblxuICAvLyBDaGVjayBpZiBkYXRhIGlzIHRoZXJlXG4gIGlmIChzdGF0ZS5vcHRpb25hbCAmJiBkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoc3RhdGVbJ2RlZmF1bHQnXSAhPT0gbnVsbClcbiAgICAgIGRhdGEgPSBzdGF0ZVsnZGVmYXVsdCddXG4gICAgZWxzZVxuICAgICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRm9yIGVycm9yIHJlcG9ydGluZ1xuICB2YXIgcHJldktleTtcblxuICAvLyBFbmNvZGUgY2hpbGRyZW4gZmlyc3RcbiAgdmFyIGNvbnRlbnQgPSBudWxsO1xuICB2YXIgcHJpbWl0aXZlID0gZmFsc2U7XG4gIGlmIChzdGF0ZS5hbnkpIHtcbiAgICAvLyBBbnl0aGluZyB0aGF0IHdhcyBnaXZlbiBpcyB0cmFuc2xhdGVkIHRvIGJ1ZmZlclxuICAgIHJlc3VsdCA9IHRoaXMuX2NyZWF0ZUVuY29kZXJCdWZmZXIoZGF0YSk7XG4gIH0gZWxzZSBpZiAoc3RhdGUuY2hvaWNlKSB7XG4gICAgcmVzdWx0ID0gdGhpcy5fZW5jb2RlQ2hvaWNlKGRhdGEsIHJlcG9ydGVyKTtcbiAgfSBlbHNlIGlmIChzdGF0ZS5jaGlsZHJlbikge1xuICAgIGNvbnRlbnQgPSBzdGF0ZS5jaGlsZHJlbi5tYXAoZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgIGlmIChjaGlsZC5fYmFzZVN0YXRlLnRhZyA9PT0gJ251bGxfJylcbiAgICAgICAgcmV0dXJuIGNoaWxkLl9lbmNvZGUobnVsbCwgcmVwb3J0ZXIsIGRhdGEpO1xuXG4gICAgICBpZiAoY2hpbGQuX2Jhc2VTdGF0ZS5rZXkgPT09IG51bGwpXG4gICAgICAgIHJldHVybiByZXBvcnRlci5lcnJvcignQ2hpbGQgc2hvdWxkIGhhdmUgYSBrZXknKTtcbiAgICAgIHZhciBwcmV2S2V5ID0gcmVwb3J0ZXIuZW50ZXJLZXkoY2hpbGQuX2Jhc2VTdGF0ZS5rZXkpO1xuXG4gICAgICBpZiAodHlwZW9mIGRhdGEgIT09ICdvYmplY3QnKVxuICAgICAgICByZXR1cm4gcmVwb3J0ZXIuZXJyb3IoJ0NoaWxkIGV4cGVjdGVkLCBidXQgaW5wdXQgaXMgbm90IG9iamVjdCcpO1xuXG4gICAgICB2YXIgcmVzID0gY2hpbGQuX2VuY29kZShkYXRhW2NoaWxkLl9iYXNlU3RhdGUua2V5XSwgcmVwb3J0ZXIsIGRhdGEpO1xuICAgICAgcmVwb3J0ZXIubGVhdmVLZXkocHJldktleSk7XG5cbiAgICAgIHJldHVybiByZXM7XG4gICAgfSwgdGhpcykuZmlsdGVyKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfSk7XG5cbiAgICBjb250ZW50ID0gdGhpcy5fY3JlYXRlRW5jb2RlckJ1ZmZlcihjb250ZW50KTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoc3RhdGUudGFnID09PSAnc2Vxb2YnIHx8IHN0YXRlLnRhZyA9PT0gJ3NldG9mJykge1xuICAgICAgLy8gVE9ETyhpbmR1dG55KTogdGhpcyBzaG91bGQgYmUgdGhyb3duIG9uIERTTCBsZXZlbFxuICAgICAgaWYgKCEoc3RhdGUuYXJncyAmJiBzdGF0ZS5hcmdzLmxlbmd0aCA9PT0gMSkpXG4gICAgICAgIHJldHVybiByZXBvcnRlci5lcnJvcignVG9vIG1hbnkgYXJncyBmb3IgOiAnICsgc3RhdGUudGFnKTtcblxuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEpKVxuICAgICAgICByZXR1cm4gcmVwb3J0ZXIuZXJyb3IoJ3NlcW9mL3NldG9mLCBidXQgZGF0YSBpcyBub3QgQXJyYXknKTtcblxuICAgICAgdmFyIGNoaWxkID0gdGhpcy5jbG9uZSgpO1xuICAgICAgY2hpbGQuX2Jhc2VTdGF0ZS5pbXBsaWNpdCA9IG51bGw7XG4gICAgICBjb250ZW50ID0gdGhpcy5fY3JlYXRlRW5jb2RlckJ1ZmZlcihkYXRhLm1hcChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0VXNlKHN0YXRlLmFyZ3NbMF0sIGRhdGEpLl9lbmNvZGUoaXRlbSwgcmVwb3J0ZXIpO1xuICAgICAgfSwgY2hpbGQpKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLnVzZSAhPT0gbnVsbCkge1xuICAgICAgcmVzdWx0ID0gdGhpcy5fZ2V0VXNlKHN0YXRlLnVzZSwgcGFyZW50KS5fZW5jb2RlKGRhdGEsIHJlcG9ydGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGVudCA9IHRoaXMuX2VuY29kZVByaW1pdGl2ZShzdGF0ZS50YWcsIGRhdGEpO1xuICAgICAgcHJpbWl0aXZlID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvLyBFbmNvZGUgZGF0YSBpdHNlbGZcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKCFzdGF0ZS5hbnkgJiYgc3RhdGUuY2hvaWNlID09PSBudWxsKSB7XG4gICAgdmFyIHRhZyA9IHN0YXRlLmltcGxpY2l0ICE9PSBudWxsID8gc3RhdGUuaW1wbGljaXQgOiBzdGF0ZS50YWc7XG4gICAgdmFyIGNscyA9IHN0YXRlLmltcGxpY2l0ID09PSBudWxsID8gJ3VuaXZlcnNhbCcgOiAnY29udGV4dCc7XG5cbiAgICBpZiAodGFnID09PSBudWxsKSB7XG4gICAgICBpZiAoc3RhdGUudXNlID09PSBudWxsKVxuICAgICAgICByZXBvcnRlci5lcnJvcignVGFnIGNvdWxkIGJlIG9tbWl0ZWQgb25seSBmb3IgLnVzZSgpJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzdGF0ZS51c2UgPT09IG51bGwpXG4gICAgICAgIHJlc3VsdCA9IHRoaXMuX2VuY29kZUNvbXBvc2l0ZSh0YWcsIHByaW1pdGl2ZSwgY2xzLCBjb250ZW50KTtcbiAgICB9XG4gIH1cblxuICAvLyBXcmFwIGluIGV4cGxpY2l0XG4gIGlmIChzdGF0ZS5leHBsaWNpdCAhPT0gbnVsbClcbiAgICByZXN1bHQgPSB0aGlzLl9lbmNvZGVDb21wb3NpdGUoc3RhdGUuZXhwbGljaXQsIGZhbHNlLCAnY29udGV4dCcsIHJlc3VsdCk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbk5vZGUucHJvdG90eXBlLl9lbmNvZGVDaG9pY2UgPSBmdW5jdGlvbiBlbmNvZGVDaG9pY2UoZGF0YSwgcmVwb3J0ZXIpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuXG4gIHZhciBub2RlID0gc3RhdGUuY2hvaWNlW2RhdGEudHlwZV07XG4gIGlmICghbm9kZSkge1xuICAgIGFzc2VydChcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIGRhdGEudHlwZSArICcgbm90IGZvdW5kIGluICcgK1xuICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoT2JqZWN0LmtleXMoc3RhdGUuY2hvaWNlKSkpO1xuICB9XG4gIHJldHVybiBub2RlLl9lbmNvZGUoZGF0YS52YWx1ZSwgcmVwb3J0ZXIpO1xufTtcblxuTm9kZS5wcm90b3R5cGUuX2VuY29kZVByaW1pdGl2ZSA9IGZ1bmN0aW9uIGVuY29kZVByaW1pdGl2ZSh0YWcsIGRhdGEpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuXG4gIGlmICh0YWcgPT09ICdvY3RzdHInIHx8IHRhZyA9PT0gJ2JpdHN0cicgfHwgdGFnID09PSAnaWE1c3RyJylcbiAgICByZXR1cm4gdGhpcy5fZW5jb2RlU3RyKGRhdGEsIHRhZyk7XG4gIGVsc2UgaWYgKHRhZyA9PT0gJ3V0ZjhzdHInIHx8IHRhZyA9PT0gJ2JtcHN0cicpXG4gICAgcmV0dXJuIHRoaXMuX2VuY29kZVN0cihkYXRhLCB0YWcpO1xuICBlbHNlIGlmICh0YWcgPT09ICdudW1zdHInIHx8IHRhZyA9PT0gJ3ByaW50c3RyJylcbiAgICByZXR1cm4gdGhpcy5fZW5jb2RlU3RyKGRhdGEsIHRhZyk7XG4gIGVsc2UgaWYgKHRhZyA9PT0gJ29iamlkJyAmJiBzdGF0ZS5hcmdzKVxuICAgIHJldHVybiB0aGlzLl9lbmNvZGVPYmppZChkYXRhLCBzdGF0ZS5yZXZlcnNlQXJnc1swXSwgc3RhdGUuYXJnc1sxXSk7XG4gIGVsc2UgaWYgKHRhZyA9PT0gJ29iamlkJylcbiAgICByZXR1cm4gdGhpcy5fZW5jb2RlT2JqaWQoZGF0YSwgbnVsbCwgbnVsbCk7XG4gIGVsc2UgaWYgKHRhZyA9PT0gJ2dlbnRpbWUnIHx8IHRhZyA9PT0gJ3V0Y3RpbWUnKVxuICAgIHJldHVybiB0aGlzLl9lbmNvZGVUaW1lKGRhdGEsIHRhZyk7XG4gIGVsc2UgaWYgKHRhZyA9PT0gJ251bGxfJylcbiAgICByZXR1cm4gdGhpcy5fZW5jb2RlTnVsbCgpO1xuICBlbHNlIGlmICh0YWcgPT09ICdpbnQnIHx8IHRhZyA9PT0gJ2VudW0nKVxuICAgIHJldHVybiB0aGlzLl9lbmNvZGVJbnQoZGF0YSwgc3RhdGUuYXJncyAmJiBzdGF0ZS5yZXZlcnNlQXJnc1swXSk7XG4gIGVsc2UgaWYgKHRhZyA9PT0gJ2Jvb2wnKVxuICAgIHJldHVybiB0aGlzLl9lbmNvZGVCb29sKGRhdGEpO1xuICBlbHNlXG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCB0YWc6ICcgKyB0YWcpO1xufTtcblxuTm9kZS5wcm90b3R5cGUuX2lzTnVtc3RyID0gZnVuY3Rpb24gaXNOdW1zdHIoc3RyKSB7XG4gIHJldHVybiAvXlswLTkgXSokLy50ZXN0KHN0cik7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5faXNQcmludHN0ciA9IGZ1bmN0aW9uIGlzUHJpbnRzdHIoc3RyKSB7XG4gIHJldHVybiAvXltBLVphLXowLTkgJ1xcKFxcKVxcKyxcXC1cXC5cXC86PVxcP10qJC8udGVzdChzdHIpO1xufTsiLCJ2YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5mdW5jdGlvbiBSZXBvcnRlcihvcHRpb25zKSB7XG4gIHRoaXMuX3JlcG9ydGVyU3RhdGUgPSB7XG4gICAgb2JqOiBudWxsLFxuICAgIHBhdGg6IFtdLFxuICAgIG9wdGlvbnM6IG9wdGlvbnMgfHwge30sXG4gICAgZXJyb3JzOiBbXVxuICB9O1xufVxuZXhwb3J0cy5SZXBvcnRlciA9IFJlcG9ydGVyO1xuXG5SZXBvcnRlci5wcm90b3R5cGUuaXNFcnJvciA9IGZ1bmN0aW9uIGlzRXJyb3Iob2JqKSB7XG4gIHJldHVybiBvYmogaW5zdGFuY2VvZiBSZXBvcnRlckVycm9yO1xufTtcblxuUmVwb3J0ZXIucHJvdG90eXBlLnNhdmUgPSBmdW5jdGlvbiBzYXZlKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZXBvcnRlclN0YXRlO1xuXG4gIHJldHVybiB7IG9iajogc3RhdGUub2JqLCBwYXRoTGVuOiBzdGF0ZS5wYXRoLmxlbmd0aCB9O1xufTtcblxuUmVwb3J0ZXIucHJvdG90eXBlLnJlc3RvcmUgPSBmdW5jdGlvbiByZXN0b3JlKGRhdGEpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVwb3J0ZXJTdGF0ZTtcblxuICBzdGF0ZS5vYmogPSBkYXRhLm9iajtcbiAgc3RhdGUucGF0aCA9IHN0YXRlLnBhdGguc2xpY2UoMCwgZGF0YS5wYXRoTGVuKTtcbn07XG5cblJlcG9ydGVyLnByb3RvdHlwZS5lbnRlcktleSA9IGZ1bmN0aW9uIGVudGVyS2V5KGtleSkge1xuICByZXR1cm4gdGhpcy5fcmVwb3J0ZXJTdGF0ZS5wYXRoLnB1c2goa2V5KTtcbn07XG5cblJlcG9ydGVyLnByb3RvdHlwZS5sZWF2ZUtleSA9IGZ1bmN0aW9uIGxlYXZlS2V5KGluZGV4LCBrZXksIHZhbHVlKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlcG9ydGVyU3RhdGU7XG5cbiAgc3RhdGUucGF0aCA9IHN0YXRlLnBhdGguc2xpY2UoMCwgaW5kZXggLSAxKTtcbiAgaWYgKHN0YXRlLm9iaiAhPT0gbnVsbClcbiAgICBzdGF0ZS5vYmpba2V5XSA9IHZhbHVlO1xufTtcblxuUmVwb3J0ZXIucHJvdG90eXBlLmVudGVyT2JqZWN0ID0gZnVuY3Rpb24gZW50ZXJPYmplY3QoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlcG9ydGVyU3RhdGU7XG5cbiAgdmFyIHByZXYgPSBzdGF0ZS5vYmo7XG4gIHN0YXRlLm9iaiA9IHt9O1xuICByZXR1cm4gcHJldjtcbn07XG5cblJlcG9ydGVyLnByb3RvdHlwZS5sZWF2ZU9iamVjdCA9IGZ1bmN0aW9uIGxlYXZlT2JqZWN0KHByZXYpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVwb3J0ZXJTdGF0ZTtcblxuICB2YXIgbm93ID0gc3RhdGUub2JqO1xuICBzdGF0ZS5vYmogPSBwcmV2O1xuICByZXR1cm4gbm93O1xufTtcblxuUmVwb3J0ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gZXJyb3IobXNnKSB7XG4gIHZhciBlcnI7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlcG9ydGVyU3RhdGU7XG5cbiAgdmFyIGluaGVyaXRlZCA9IG1zZyBpbnN0YW5jZW9mIFJlcG9ydGVyRXJyb3I7XG4gIGlmIChpbmhlcml0ZWQpIHtcbiAgICBlcnIgPSBtc2c7XG4gIH0gZWxzZSB7XG4gICAgZXJyID0gbmV3IFJlcG9ydGVyRXJyb3Ioc3RhdGUucGF0aC5tYXAoZnVuY3Rpb24oZWxlbSkge1xuICAgICAgcmV0dXJuICdbJyArIEpTT04uc3RyaW5naWZ5KGVsZW0pICsgJ10nO1xuICAgIH0pLmpvaW4oJycpLCBtc2cubWVzc2FnZSB8fCBtc2csIG1zZy5zdGFjayk7XG4gIH1cblxuICBpZiAoIXN0YXRlLm9wdGlvbnMucGFydGlhbClcbiAgICB0aHJvdyBlcnI7XG5cbiAgaWYgKCFpbmhlcml0ZWQpXG4gICAgc3RhdGUuZXJyb3JzLnB1c2goZXJyKTtcblxuICByZXR1cm4gZXJyO1xufTtcblxuUmVwb3J0ZXIucHJvdG90eXBlLndyYXBSZXN1bHQgPSBmdW5jdGlvbiB3cmFwUmVzdWx0KHJlc3VsdCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZXBvcnRlclN0YXRlO1xuICBpZiAoIXN0YXRlLm9wdGlvbnMucGFydGlhbClcbiAgICByZXR1cm4gcmVzdWx0O1xuXG4gIHJldHVybiB7XG4gICAgcmVzdWx0OiB0aGlzLmlzRXJyb3IocmVzdWx0KSA/IG51bGwgOiByZXN1bHQsXG4gICAgZXJyb3JzOiBzdGF0ZS5lcnJvcnNcbiAgfTtcbn07XG5cbmZ1bmN0aW9uIFJlcG9ydGVyRXJyb3IocGF0aCwgbXNnKSB7XG4gIHRoaXMucGF0aCA9IHBhdGg7XG4gIHRoaXMucmV0aHJvdyhtc2cpO1xufTtcbmluaGVyaXRzKFJlcG9ydGVyRXJyb3IsIEVycm9yKTtcblxuUmVwb3J0ZXJFcnJvci5wcm90b3R5cGUucmV0aHJvdyA9IGZ1bmN0aW9uIHJldGhyb3cobXNnKSB7XG4gIHRoaXMubWVzc2FnZSA9IG1zZyArICcgYXQ6ICcgKyAodGhpcy5wYXRoIHx8ICcoc2hhbGxvdyknKTtcbiAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgUmVwb3J0ZXJFcnJvcik7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuIiwidmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cycpO1xuXG5leHBvcnRzLnRhZ0NsYXNzID0ge1xuICAwOiAndW5pdmVyc2FsJyxcbiAgMTogJ2FwcGxpY2F0aW9uJyxcbiAgMjogJ2NvbnRleHQnLFxuICAzOiAncHJpdmF0ZSdcbn07XG5leHBvcnRzLnRhZ0NsYXNzQnlOYW1lID0gY29uc3RhbnRzLl9yZXZlcnNlKGV4cG9ydHMudGFnQ2xhc3MpO1xuXG5leHBvcnRzLnRhZyA9IHtcbiAgMHgwMDogJ2VuZCcsXG4gIDB4MDE6ICdib29sJyxcbiAgMHgwMjogJ2ludCcsXG4gIDB4MDM6ICdiaXRzdHInLFxuICAweDA0OiAnb2N0c3RyJyxcbiAgMHgwNTogJ251bGxfJyxcbiAgMHgwNjogJ29iamlkJyxcbiAgMHgwNzogJ29iakRlc2MnLFxuICAweDA4OiAnZXh0ZXJuYWwnLFxuICAweDA5OiAncmVhbCcsXG4gIDB4MGE6ICdlbnVtJyxcbiAgMHgwYjogJ2VtYmVkJyxcbiAgMHgwYzogJ3V0ZjhzdHInLFxuICAweDBkOiAncmVsYXRpdmVPaWQnLFxuICAweDEwOiAnc2VxJyxcbiAgMHgxMTogJ3NldCcsXG4gIDB4MTI6ICdudW1zdHInLFxuICAweDEzOiAncHJpbnRzdHInLFxuICAweDE0OiAndDYxc3RyJyxcbiAgMHgxNTogJ3ZpZGVvc3RyJyxcbiAgMHgxNjogJ2lhNXN0cicsXG4gIDB4MTc6ICd1dGN0aW1lJyxcbiAgMHgxODogJ2dlbnRpbWUnLFxuICAweDE5OiAnZ3JhcGhzdHInLFxuICAweDFhOiAnaXNvNjQ2c3RyJyxcbiAgMHgxYjogJ2dlbnN0cicsXG4gIDB4MWM6ICd1bmlzdHInLFxuICAweDFkOiAnY2hhcnN0cicsXG4gIDB4MWU6ICdibXBzdHInXG59O1xuZXhwb3J0cy50YWdCeU5hbWUgPSBjb25zdGFudHMuX3JldmVyc2UoZXhwb3J0cy50YWcpO1xuIiwidmFyIGNvbnN0YW50cyA9IGV4cG9ydHM7XG5cbi8vIEhlbHBlclxuY29uc3RhbnRzLl9yZXZlcnNlID0gZnVuY3Rpb24gcmV2ZXJzZShtYXApIHtcbiAgdmFyIHJlcyA9IHt9O1xuXG4gIE9iamVjdC5rZXlzKG1hcCkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAvLyBDb252ZXJ0IGtleSB0byBpbnRlZ2VyIGlmIGl0IGlzIHN0cmluZ2lmaWVkXG4gICAgaWYgKChrZXkgfCAwKSA9PSBrZXkpXG4gICAgICBrZXkgPSBrZXkgfCAwO1xuXG4gICAgdmFyIHZhbHVlID0gbWFwW2tleV07XG4gICAgcmVzW3ZhbHVlXSA9IGtleTtcbiAgfSk7XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cbmNvbnN0YW50cy5kZXIgPSByZXF1aXJlKCcuL2RlcicpO1xuIiwidmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxudmFyIGFzbjEgPSByZXF1aXJlKCcuLi8uLi9hc24xJyk7XG52YXIgYmFzZSA9IGFzbjEuYmFzZTtcbnZhciBiaWdudW0gPSBhc24xLmJpZ251bTtcblxuLy8gSW1wb3J0IERFUiBjb25zdGFudHNcbnZhciBkZXIgPSBhc24xLmNvbnN0YW50cy5kZXI7XG5cbmZ1bmN0aW9uIERFUkRlY29kZXIoZW50aXR5KSB7XG4gIHRoaXMuZW5jID0gJ2Rlcic7XG4gIHRoaXMubmFtZSA9IGVudGl0eS5uYW1lO1xuICB0aGlzLmVudGl0eSA9IGVudGl0eTtcblxuICAvLyBDb25zdHJ1Y3QgYmFzZSB0cmVlXG4gIHRoaXMudHJlZSA9IG5ldyBERVJOb2RlKCk7XG4gIHRoaXMudHJlZS5faW5pdChlbnRpdHkuYm9keSk7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBERVJEZWNvZGVyO1xuXG5ERVJEZWNvZGVyLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUoZGF0YSwgb3B0aW9ucykge1xuICBpZiAoIShkYXRhIGluc3RhbmNlb2YgYmFzZS5EZWNvZGVyQnVmZmVyKSlcbiAgICBkYXRhID0gbmV3IGJhc2UuRGVjb2RlckJ1ZmZlcihkYXRhLCBvcHRpb25zKTtcblxuICByZXR1cm4gdGhpcy50cmVlLl9kZWNvZGUoZGF0YSwgb3B0aW9ucyk7XG59O1xuXG4vLyBUcmVlIG1ldGhvZHNcblxuZnVuY3Rpb24gREVSTm9kZShwYXJlbnQpIHtcbiAgYmFzZS5Ob2RlLmNhbGwodGhpcywgJ2RlcicsIHBhcmVudCk7XG59XG5pbmhlcml0cyhERVJOb2RlLCBiYXNlLk5vZGUpO1xuXG5ERVJOb2RlLnByb3RvdHlwZS5fcGVla1RhZyA9IGZ1bmN0aW9uIHBlZWtUYWcoYnVmZmVyLCB0YWcsIGFueSkge1xuICBpZiAoYnVmZmVyLmlzRW1wdHkoKSlcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIHN0YXRlID0gYnVmZmVyLnNhdmUoKTtcbiAgdmFyIGRlY29kZWRUYWcgPSBkZXJEZWNvZGVUYWcoYnVmZmVyLCAnRmFpbGVkIHRvIHBlZWsgdGFnOiBcIicgKyB0YWcgKyAnXCInKTtcbiAgaWYgKGJ1ZmZlci5pc0Vycm9yKGRlY29kZWRUYWcpKVxuICAgIHJldHVybiBkZWNvZGVkVGFnO1xuXG4gIGJ1ZmZlci5yZXN0b3JlKHN0YXRlKTtcblxuICByZXR1cm4gZGVjb2RlZFRhZy50YWcgPT09IHRhZyB8fCBkZWNvZGVkVGFnLnRhZ1N0ciA9PT0gdGFnIHx8IGFueTtcbn07XG5cbkRFUk5vZGUucHJvdG90eXBlLl9kZWNvZGVUYWcgPSBmdW5jdGlvbiBkZWNvZGVUYWcoYnVmZmVyLCB0YWcsIGFueSkge1xuICB2YXIgZGVjb2RlZFRhZyA9IGRlckRlY29kZVRhZyhidWZmZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdGYWlsZWQgdG8gZGVjb2RlIHRhZyBvZiBcIicgKyB0YWcgKyAnXCInKTtcbiAgaWYgKGJ1ZmZlci5pc0Vycm9yKGRlY29kZWRUYWcpKVxuICAgIHJldHVybiBkZWNvZGVkVGFnO1xuXG4gIHZhciBsZW4gPSBkZXJEZWNvZGVMZW4oYnVmZmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRUYWcucHJpbWl0aXZlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICdGYWlsZWQgdG8gZ2V0IGxlbmd0aCBvZiBcIicgKyB0YWcgKyAnXCInKTtcblxuICAvLyBGYWlsdXJlXG4gIGlmIChidWZmZXIuaXNFcnJvcihsZW4pKVxuICAgIHJldHVybiBsZW47XG5cbiAgaWYgKCFhbnkgJiZcbiAgICAgIGRlY29kZWRUYWcudGFnICE9PSB0YWcgJiZcbiAgICAgIGRlY29kZWRUYWcudGFnU3RyICE9PSB0YWcgJiZcbiAgICAgIGRlY29kZWRUYWcudGFnU3RyICsgJ29mJyAhPT0gdGFnKSB7XG4gICAgcmV0dXJuIGJ1ZmZlci5lcnJvcignRmFpbGVkIHRvIG1hdGNoIHRhZzogXCInICsgdGFnICsgJ1wiJyk7XG4gIH1cblxuICBpZiAoZGVjb2RlZFRhZy5wcmltaXRpdmUgfHwgbGVuICE9PSBudWxsKVxuICAgIHJldHVybiBidWZmZXIuc2tpcChsZW4sICdGYWlsZWQgdG8gbWF0Y2ggYm9keSBvZjogXCInICsgdGFnICsgJ1wiJyk7XG5cbiAgLy8gSW5kZWZpbml0ZSBsZW5ndGguLi4gZmluZCBFTkQgdGFnXG4gIHZhciBzdGF0ZSA9IGJ1ZmZlci5zYXZlKCk7XG4gIHZhciByZXMgPSB0aGlzLl9za2lwVW50aWxFbmQoXG4gICAgICBidWZmZXIsXG4gICAgICAnRmFpbGVkIHRvIHNraXAgaW5kZWZpbml0ZSBsZW5ndGggYm9keTogXCInICsgdGhpcy50YWcgKyAnXCInKTtcbiAgaWYgKGJ1ZmZlci5pc0Vycm9yKHJlcykpXG4gICAgcmV0dXJuIHJlcztcblxuICBsZW4gPSBidWZmZXIub2Zmc2V0IC0gc3RhdGUub2Zmc2V0O1xuICBidWZmZXIucmVzdG9yZShzdGF0ZSk7XG4gIHJldHVybiBidWZmZXIuc2tpcChsZW4sICdGYWlsZWQgdG8gbWF0Y2ggYm9keSBvZjogXCInICsgdGFnICsgJ1wiJyk7XG59O1xuXG5ERVJOb2RlLnByb3RvdHlwZS5fc2tpcFVudGlsRW5kID0gZnVuY3Rpb24gc2tpcFVudGlsRW5kKGJ1ZmZlciwgZmFpbCkge1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIHZhciB0YWcgPSBkZXJEZWNvZGVUYWcoYnVmZmVyLCBmYWlsKTtcbiAgICBpZiAoYnVmZmVyLmlzRXJyb3IodGFnKSlcbiAgICAgIHJldHVybiB0YWc7XG4gICAgdmFyIGxlbiA9IGRlckRlY29kZUxlbihidWZmZXIsIHRhZy5wcmltaXRpdmUsIGZhaWwpO1xuICAgIGlmIChidWZmZXIuaXNFcnJvcihsZW4pKVxuICAgICAgcmV0dXJuIGxlbjtcblxuICAgIHZhciByZXM7XG4gICAgaWYgKHRhZy5wcmltaXRpdmUgfHwgbGVuICE9PSBudWxsKVxuICAgICAgcmVzID0gYnVmZmVyLnNraXAobGVuKVxuICAgIGVsc2VcbiAgICAgIHJlcyA9IHRoaXMuX3NraXBVbnRpbEVuZChidWZmZXIsIGZhaWwpO1xuXG4gICAgLy8gRmFpbHVyZVxuICAgIGlmIChidWZmZXIuaXNFcnJvcihyZXMpKVxuICAgICAgcmV0dXJuIHJlcztcblxuICAgIGlmICh0YWcudGFnU3RyID09PSAnZW5kJylcbiAgICAgIGJyZWFrO1xuICB9XG59O1xuXG5ERVJOb2RlLnByb3RvdHlwZS5fZGVjb2RlTGlzdCA9IGZ1bmN0aW9uIGRlY29kZUxpc3QoYnVmZmVyLCB0YWcsIGRlY29kZXIpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB3aGlsZSAoIWJ1ZmZlci5pc0VtcHR5KCkpIHtcbiAgICB2YXIgcG9zc2libGVFbmQgPSB0aGlzLl9wZWVrVGFnKGJ1ZmZlciwgJ2VuZCcpO1xuICAgIGlmIChidWZmZXIuaXNFcnJvcihwb3NzaWJsZUVuZCkpXG4gICAgICByZXR1cm4gcG9zc2libGVFbmQ7XG5cbiAgICB2YXIgcmVzID0gZGVjb2Rlci5kZWNvZGUoYnVmZmVyLCAnZGVyJyk7XG4gICAgaWYgKGJ1ZmZlci5pc0Vycm9yKHJlcykgJiYgcG9zc2libGVFbmQpXG4gICAgICBicmVhaztcbiAgICByZXN1bHQucHVzaChyZXMpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5ERVJOb2RlLnByb3RvdHlwZS5fZGVjb2RlU3RyID0gZnVuY3Rpb24gZGVjb2RlU3RyKGJ1ZmZlciwgdGFnKSB7XG4gIGlmICh0YWcgPT09ICdvY3RzdHInKSB7XG4gICAgcmV0dXJuIGJ1ZmZlci5yYXcoKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdiaXRzdHInKSB7XG4gICAgdmFyIHVudXNlZCA9IGJ1ZmZlci5yZWFkVUludDgoKTtcbiAgICBpZiAoYnVmZmVyLmlzRXJyb3IodW51c2VkKSlcbiAgICAgIHJldHVybiB1bnVzZWQ7XG5cbiAgICByZXR1cm4geyB1bnVzZWQ6IHVudXNlZCwgZGF0YTogYnVmZmVyLnJhdygpIH07XG4gIH0gZWxzZSBpZiAodGFnID09PSAnaWE1c3RyJyB8fCB0YWcgPT09ICd1dGY4c3RyJykge1xuICAgIHJldHVybiBidWZmZXIucmF3KCkudG9TdHJpbmcoKTtcbiAgfSBlbHNlIGlmKHRhZyA9PT0gJ251bXN0cicpIHtcbiAgICB2YXIgbnVtc3RyID0gYnVmZmVyLnJhdygpLnRvU3RyaW5nKCdhc2NpaScpO1xuICAgIGlmICghdGhpcy5faXNOdW1zdHIobnVtc3RyKSkge1xuICAgICAgcmV0dXJuIGJ1ZmZlci5lcnJvcignRGVjb2Rpbmcgb2Ygc3RyaW5nIHR5cGU6ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnbnVtc3RyIHVuc3VwcG9ydGVkIGNoYXJhY3RlcnMnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVtc3RyO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ3ByaW50c3RyJykge1xuICAgIHZhciBwcmludHN0ciA9IGJ1ZmZlci5yYXcoKS50b1N0cmluZygnYXNjaWknKTtcbiAgICBpZiAoIXRoaXMuX2lzUHJpbnRzdHIocHJpbnRzdHIpKSB7XG4gICAgICByZXR1cm4gYnVmZmVyLmVycm9yKCdEZWNvZGluZyBvZiBzdHJpbmcgdHlwZTogJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdwcmludHN0ciB1bnN1cHBvcnRlZCBjaGFyYWN0ZXJzJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByaW50c3RyO1xuICB9IGVsc2UgaWYodGFnID09PSAnYm1wc3RyJykge1xuICAgIHZhciByYXcgPSBidWZmZXIucmF3KCk7XG4gICAgaWYgKHJhdy5sZW5ndGggJSAyID09PSAxKVxuICAgICAgcmV0dXJuIGJ1ZmZlci5lcnJvcignRGVjb2Rpbmcgb2Ygc3RyaW5nIHR5cGU6IGJtcHN0ciBsZW5ndGggbWlzbWF0Y2gnKTtcblxuICAgIHZhciBzdHIgPSAnJztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhdy5sZW5ndGggLyAyOyBpKyspIHtcbiAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHJhdy5yZWFkVUludDE2QkUoaSAqIDIpKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYnVmZmVyLmVycm9yKCdEZWNvZGluZyBvZiBzdHJpbmcgdHlwZTogJyArIHRhZyArICcgdW5zdXBwb3J0ZWQnKTtcbiAgfVxufTtcblxuREVSTm9kZS5wcm90b3R5cGUuX2RlY29kZU9iamlkID0gZnVuY3Rpb24gZGVjb2RlT2JqaWQoYnVmZmVyLCB2YWx1ZXMsIHJlbGF0aXZlKSB7XG4gIHZhciBpZGVudGlmaWVycyA9IFtdO1xuICB2YXIgaWRlbnQgPSAwO1xuICB3aGlsZSAoIWJ1ZmZlci5pc0VtcHR5KCkpIHtcbiAgICB2YXIgc3ViaWRlbnQgPSBidWZmZXIucmVhZFVJbnQ4KCk7XG4gICAgaWRlbnQgPDw9IDc7XG4gICAgaWRlbnQgfD0gc3ViaWRlbnQgJiAweDdmO1xuICAgIGlmICgoc3ViaWRlbnQgJiAweDgwKSA9PT0gMCkge1xuICAgICAgaWRlbnRpZmllcnMucHVzaChpZGVudCk7XG4gICAgICBpZGVudCA9IDA7XG4gICAgfVxuICB9XG4gIGlmIChzdWJpZGVudCAmIDB4ODApXG4gICAgaWRlbnRpZmllcnMucHVzaChpZGVudCk7XG5cbiAgdmFyIGZpcnN0ID0gKGlkZW50aWZpZXJzWzBdIC8gNDApIHwgMDtcbiAgdmFyIHNlY29uZCA9IGlkZW50aWZpZXJzWzBdICUgNDA7XG5cbiAgaWYgKHJlbGF0aXZlKVxuICAgIHJlc3VsdCA9IGlkZW50aWZpZXJzO1xuICBlbHNlXG4gICAgcmVzdWx0ID0gW2ZpcnN0LCBzZWNvbmRdLmNvbmNhdChpZGVudGlmaWVycy5zbGljZSgxKSk7XG5cbiAgaWYgKHZhbHVlcylcbiAgICByZXN1bHQgPSB2YWx1ZXNbcmVzdWx0LmpvaW4oJyAnKV07XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbkRFUk5vZGUucHJvdG90eXBlLl9kZWNvZGVUaW1lID0gZnVuY3Rpb24gZGVjb2RlVGltZShidWZmZXIsIHRhZykge1xuICB2YXIgc3RyID0gYnVmZmVyLnJhdygpLnRvU3RyaW5nKCk7XG4gIGlmICh0YWcgPT09ICdnZW50aW1lJykge1xuICAgIHZhciB5ZWFyID0gc3RyLnNsaWNlKDAsIDQpIHwgMDtcbiAgICB2YXIgbW9uID0gc3RyLnNsaWNlKDQsIDYpIHwgMDtcbiAgICB2YXIgZGF5ID0gc3RyLnNsaWNlKDYsIDgpIHwgMDtcbiAgICB2YXIgaG91ciA9IHN0ci5zbGljZSg4LCAxMCkgfCAwO1xuICAgIHZhciBtaW4gPSBzdHIuc2xpY2UoMTAsIDEyKSB8IDA7XG4gICAgdmFyIHNlYyA9IHN0ci5zbGljZSgxMiwgMTQpIHwgMDtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICd1dGN0aW1lJykge1xuICAgIHZhciB5ZWFyID0gc3RyLnNsaWNlKDAsIDIpIHwgMDtcbiAgICB2YXIgbW9uID0gc3RyLnNsaWNlKDIsIDQpIHwgMDtcbiAgICB2YXIgZGF5ID0gc3RyLnNsaWNlKDQsIDYpIHwgMDtcbiAgICB2YXIgaG91ciA9IHN0ci5zbGljZSg2LCA4KSB8IDA7XG4gICAgdmFyIG1pbiA9IHN0ci5zbGljZSg4LCAxMCkgfCAwO1xuICAgIHZhciBzZWMgPSBzdHIuc2xpY2UoMTAsIDEyKSB8IDA7XG4gICAgaWYgKHllYXIgPCA3MClcbiAgICAgIHllYXIgPSAyMDAwICsgeWVhcjtcbiAgICBlbHNlXG4gICAgICB5ZWFyID0gMTkwMCArIHllYXI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJ1ZmZlci5lcnJvcignRGVjb2RpbmcgJyArIHRhZyArICcgdGltZSBpcyBub3Qgc3VwcG9ydGVkIHlldCcpO1xuICB9XG5cbiAgcmV0dXJuIERhdGUuVVRDKHllYXIsIG1vbiAtIDEsIGRheSwgaG91ciwgbWluLCBzZWMsIDApO1xufTtcblxuREVSTm9kZS5wcm90b3R5cGUuX2RlY29kZU51bGwgPSBmdW5jdGlvbiBkZWNvZGVOdWxsKGJ1ZmZlcikge1xuICByZXR1cm4gbnVsbDtcbn07XG5cbkRFUk5vZGUucHJvdG90eXBlLl9kZWNvZGVCb29sID0gZnVuY3Rpb24gZGVjb2RlQm9vbChidWZmZXIpIHtcbiAgdmFyIHJlcyA9IGJ1ZmZlci5yZWFkVUludDgoKTtcbiAgaWYgKGJ1ZmZlci5pc0Vycm9yKHJlcykpXG4gICAgcmV0dXJuIHJlcztcbiAgZWxzZVxuICAgIHJldHVybiByZXMgIT09IDA7XG59O1xuXG5ERVJOb2RlLnByb3RvdHlwZS5fZGVjb2RlSW50ID0gZnVuY3Rpb24gZGVjb2RlSW50KGJ1ZmZlciwgdmFsdWVzKSB7XG4gIC8vIEJpZ2ludCwgcmV0dXJuIGFzIGl0IGlzIChhc3N1bWUgYmlnIGVuZGlhbilcbiAgdmFyIHJhdyA9IGJ1ZmZlci5yYXcoKTtcbiAgdmFyIHJlcyA9IG5ldyBiaWdudW0ocmF3KTtcblxuICBpZiAodmFsdWVzKVxuICAgIHJlcyA9IHZhbHVlc1tyZXMudG9TdHJpbmcoMTApXSB8fCByZXM7XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cbkRFUk5vZGUucHJvdG90eXBlLl91c2UgPSBmdW5jdGlvbiB1c2UoZW50aXR5LCBvYmopIHtcbiAgaWYgKHR5cGVvZiBlbnRpdHkgPT09ICdmdW5jdGlvbicpXG4gICAgZW50aXR5ID0gZW50aXR5KG9iaik7XG4gIHJldHVybiBlbnRpdHkuX2dldERlY29kZXIoJ2RlcicpLnRyZWU7XG59O1xuXG4vLyBVdGlsaXR5IG1ldGhvZHNcblxuZnVuY3Rpb24gZGVyRGVjb2RlVGFnKGJ1ZiwgZmFpbCkge1xuICB2YXIgdGFnID0gYnVmLnJlYWRVSW50OChmYWlsKTtcbiAgaWYgKGJ1Zi5pc0Vycm9yKHRhZykpXG4gICAgcmV0dXJuIHRhZztcblxuICB2YXIgY2xzID0gZGVyLnRhZ0NsYXNzW3RhZyA+PiA2XTtcbiAgdmFyIHByaW1pdGl2ZSA9ICh0YWcgJiAweDIwKSA9PT0gMDtcblxuICAvLyBNdWx0aS1vY3RldCB0YWcgLSBsb2FkXG4gIGlmICgodGFnICYgMHgxZikgPT09IDB4MWYpIHtcbiAgICB2YXIgb2N0ID0gdGFnO1xuICAgIHRhZyA9IDA7XG4gICAgd2hpbGUgKChvY3QgJiAweDgwKSA9PT0gMHg4MCkge1xuICAgICAgb2N0ID0gYnVmLnJlYWRVSW50OChmYWlsKTtcbiAgICAgIGlmIChidWYuaXNFcnJvcihvY3QpKVxuICAgICAgICByZXR1cm4gb2N0O1xuXG4gICAgICB0YWcgPDw9IDc7XG4gICAgICB0YWcgfD0gb2N0ICYgMHg3ZjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGFnICY9IDB4MWY7XG4gIH1cbiAgdmFyIHRhZ1N0ciA9IGRlci50YWdbdGFnXTtcblxuICByZXR1cm4ge1xuICAgIGNsczogY2xzLFxuICAgIHByaW1pdGl2ZTogcHJpbWl0aXZlLFxuICAgIHRhZzogdGFnLFxuICAgIHRhZ1N0cjogdGFnU3RyXG4gIH07XG59XG5cbmZ1bmN0aW9uIGRlckRlY29kZUxlbihidWYsIHByaW1pdGl2ZSwgZmFpbCkge1xuICB2YXIgbGVuID0gYnVmLnJlYWRVSW50OChmYWlsKTtcbiAgaWYgKGJ1Zi5pc0Vycm9yKGxlbikpXG4gICAgcmV0dXJuIGxlbjtcblxuICAvLyBJbmRlZmluaXRlIGZvcm1cbiAgaWYgKCFwcmltaXRpdmUgJiYgbGVuID09PSAweDgwKVxuICAgIHJldHVybiBudWxsO1xuXG4gIC8vIERlZmluaXRlIGZvcm1cbiAgaWYgKChsZW4gJiAweDgwKSA9PT0gMCkge1xuICAgIC8vIFNob3J0IGZvcm1cbiAgICByZXR1cm4gbGVuO1xuICB9XG5cbiAgLy8gTG9uZyBmb3JtXG4gIHZhciBudW0gPSBsZW4gJiAweDdmO1xuICBpZiAobnVtID49IDQpXG4gICAgcmV0dXJuIGJ1Zi5lcnJvcignbGVuZ3RoIG9jdGVjdCBpcyB0b28gbG9uZycpO1xuXG4gIGxlbiA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtOyBpKyspIHtcbiAgICBsZW4gPDw9IDg7XG4gICAgdmFyIGogPSBidWYucmVhZFVJbnQ4KGZhaWwpO1xuICAgIGlmIChidWYuaXNFcnJvcihqKSlcbiAgICAgIHJldHVybiBqO1xuICAgIGxlbiB8PSBqO1xuICB9XG5cbiAgcmV0dXJuIGxlbjtcbn1cbiIsInZhciBkZWNvZGVycyA9IGV4cG9ydHM7XG5cbmRlY29kZXJzLmRlciA9IHJlcXVpcmUoJy4vZGVyJyk7XG5kZWNvZGVycy5wZW0gPSByZXF1aXJlKCcuL3BlbScpO1xuIiwidmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG5cbnZhciBhc24xID0gcmVxdWlyZSgnLi4vLi4vYXNuMScpO1xudmFyIERFUkRlY29kZXIgPSByZXF1aXJlKCcuL2RlcicpO1xuXG5mdW5jdGlvbiBQRU1EZWNvZGVyKGVudGl0eSkge1xuICBERVJEZWNvZGVyLmNhbGwodGhpcywgZW50aXR5KTtcbiAgdGhpcy5lbmMgPSAncGVtJztcbn07XG5pbmhlcml0cyhQRU1EZWNvZGVyLCBERVJEZWNvZGVyKTtcbm1vZHVsZS5leHBvcnRzID0gUEVNRGVjb2RlcjtcblxuUEVNRGVjb2Rlci5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKGRhdGEsIG9wdGlvbnMpIHtcbiAgdmFyIGxpbmVzID0gZGF0YS50b1N0cmluZygpLnNwbGl0KC9bXFxyXFxuXSsvZyk7XG5cbiAgdmFyIGxhYmVsID0gb3B0aW9ucy5sYWJlbC50b1VwcGVyQ2FzZSgpO1xuXG4gIHZhciByZSA9IC9eLS0tLS0oQkVHSU58RU5EKSAoW14tXSspLS0tLS0kLztcbiAgdmFyIHN0YXJ0ID0gLTE7XG4gIHZhciBlbmQgPSAtMTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBtYXRjaCA9IGxpbmVzW2ldLm1hdGNoKHJlKTtcbiAgICBpZiAobWF0Y2ggPT09IG51bGwpXG4gICAgICBjb250aW51ZTtcblxuICAgIGlmIChtYXRjaFsyXSAhPT0gbGFiZWwpXG4gICAgICBjb250aW51ZTtcblxuICAgIGlmIChzdGFydCA9PT0gLTEpIHtcbiAgICAgIGlmIChtYXRjaFsxXSAhPT0gJ0JFR0lOJylcbiAgICAgICAgYnJlYWs7XG4gICAgICBzdGFydCA9IGk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChtYXRjaFsxXSAhPT0gJ0VORCcpXG4gICAgICAgIGJyZWFrO1xuICAgICAgZW5kID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZiAoc3RhcnQgPT09IC0xIHx8IGVuZCA9PT0gLTEpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdQRU0gc2VjdGlvbiBub3QgZm91bmQgZm9yOiAnICsgbGFiZWwpO1xuXG4gIHZhciBiYXNlNjQgPSBsaW5lcy5zbGljZShzdGFydCArIDEsIGVuZCkuam9pbignJyk7XG4gIC8vIFJlbW92ZSBleGNlc3NpdmUgc3ltYm9sc1xuICBiYXNlNjQucmVwbGFjZSgvW15hLXowLTlcXCtcXC89XSsvZ2ksICcnKTtcblxuICB2YXIgaW5wdXQgPSBuZXcgQnVmZmVyKGJhc2U2NCwgJ2Jhc2U2NCcpO1xuICByZXR1cm4gREVSRGVjb2Rlci5wcm90b3R5cGUuZGVjb2RlLmNhbGwodGhpcywgaW5wdXQsIG9wdGlvbnMpO1xufTtcbiIsInZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuXG52YXIgYXNuMSA9IHJlcXVpcmUoJy4uLy4uL2FzbjEnKTtcbnZhciBiYXNlID0gYXNuMS5iYXNlO1xudmFyIGJpZ251bSA9IGFzbjEuYmlnbnVtO1xuXG4vLyBJbXBvcnQgREVSIGNvbnN0YW50c1xudmFyIGRlciA9IGFzbjEuY29uc3RhbnRzLmRlcjtcblxuZnVuY3Rpb24gREVSRW5jb2RlcihlbnRpdHkpIHtcbiAgdGhpcy5lbmMgPSAnZGVyJztcbiAgdGhpcy5uYW1lID0gZW50aXR5Lm5hbWU7XG4gIHRoaXMuZW50aXR5ID0gZW50aXR5O1xuXG4gIC8vIENvbnN0cnVjdCBiYXNlIHRyZWVcbiAgdGhpcy50cmVlID0gbmV3IERFUk5vZGUoKTtcbiAgdGhpcy50cmVlLl9pbml0KGVudGl0eS5ib2R5KTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IERFUkVuY29kZXI7XG5cbkRFUkVuY29kZXIucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShkYXRhLCByZXBvcnRlcikge1xuICByZXR1cm4gdGhpcy50cmVlLl9lbmNvZGUoZGF0YSwgcmVwb3J0ZXIpLmpvaW4oKTtcbn07XG5cbi8vIFRyZWUgbWV0aG9kc1xuXG5mdW5jdGlvbiBERVJOb2RlKHBhcmVudCkge1xuICBiYXNlLk5vZGUuY2FsbCh0aGlzLCAnZGVyJywgcGFyZW50KTtcbn1cbmluaGVyaXRzKERFUk5vZGUsIGJhc2UuTm9kZSk7XG5cbkRFUk5vZGUucHJvdG90eXBlLl9lbmNvZGVDb21wb3NpdGUgPSBmdW5jdGlvbiBlbmNvZGVDb21wb3NpdGUodGFnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmltaXRpdmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNscyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudCkge1xuICB2YXIgZW5jb2RlZFRhZyA9IGVuY29kZVRhZyh0YWcsIHByaW1pdGl2ZSwgY2xzLCB0aGlzLnJlcG9ydGVyKTtcblxuICAvLyBTaG9ydCBmb3JtXG4gIGlmIChjb250ZW50Lmxlbmd0aCA8IDB4ODApIHtcbiAgICB2YXIgaGVhZGVyID0gbmV3IEJ1ZmZlcigyKTtcbiAgICBoZWFkZXJbMF0gPSBlbmNvZGVkVGFnO1xuICAgIGhlYWRlclsxXSA9IGNvbnRlbnQubGVuZ3RoO1xuICAgIHJldHVybiB0aGlzLl9jcmVhdGVFbmNvZGVyQnVmZmVyKFsgaGVhZGVyLCBjb250ZW50IF0pO1xuICB9XG5cbiAgLy8gTG9uZyBmb3JtXG4gIC8vIENvdW50IG9jdGV0cyByZXF1aXJlZCB0byBzdG9yZSBsZW5ndGhcbiAgdmFyIGxlbk9jdGV0cyA9IDE7XG4gIGZvciAodmFyIGkgPSBjb250ZW50Lmxlbmd0aDsgaSA+PSAweDEwMDsgaSA+Pj0gOClcbiAgICBsZW5PY3RldHMrKztcblxuICB2YXIgaGVhZGVyID0gbmV3IEJ1ZmZlcigxICsgMSArIGxlbk9jdGV0cyk7XG4gIGhlYWRlclswXSA9IGVuY29kZWRUYWc7XG4gIGhlYWRlclsxXSA9IDB4ODAgfCBsZW5PY3RldHM7XG5cbiAgZm9yICh2YXIgaSA9IDEgKyBsZW5PY3RldHMsIGogPSBjb250ZW50Lmxlbmd0aDsgaiA+IDA7IGktLSwgaiA+Pj0gOClcbiAgICBoZWFkZXJbaV0gPSBqICYgMHhmZjtcblxuICByZXR1cm4gdGhpcy5fY3JlYXRlRW5jb2RlckJ1ZmZlcihbIGhlYWRlciwgY29udGVudCBdKTtcbn07XG5cbkRFUk5vZGUucHJvdG90eXBlLl9lbmNvZGVTdHIgPSBmdW5jdGlvbiBlbmNvZGVTdHIoc3RyLCB0YWcpIHtcbiAgaWYgKHRhZyA9PT0gJ29jdHN0cicpIHtcbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlRW5jb2RlckJ1ZmZlcihzdHIpO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2JpdHN0cicpIHtcbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlRW5jb2RlckJ1ZmZlcihbIHN0ci51bnVzZWQgfCAwLCBzdHIuZGF0YSBdKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdpYTVzdHInIHx8IHRhZyA9PT0gJ3V0ZjhzdHInKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZUVuY29kZXJCdWZmZXIoc3RyKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdibXBzdHInKSB7XG4gICAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIoc3RyLmxlbmd0aCAqIDIpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBidWYud3JpdGVVSW50MTZCRShzdHIuY2hhckNvZGVBdChpKSwgaSAqIDIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlRW5jb2RlckJ1ZmZlcihidWYpO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ251bXN0cicpIHtcbiAgICBpZiAoIXRoaXMuX2lzTnVtc3RyKHN0cikpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlcG9ydGVyLmVycm9yKCdFbmNvZGluZyBvZiBzdHJpbmcgdHlwZTogbnVtc3RyIHN1cHBvcnRzICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29ubHkgZGlnaXRzIGFuZCBzcGFjZScpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9jcmVhdGVFbmNvZGVyQnVmZmVyKHN0cik7XG4gIH0gZWxzZSBpZiAodGFnID09PSAncHJpbnRzdHInKSB7XG4gICAgaWYgKCF0aGlzLl9pc1ByaW50c3RyKHN0cikpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlcG9ydGVyLmVycm9yKCdFbmNvZGluZyBvZiBzdHJpbmcgdHlwZTogcHJpbnRzdHIgc3VwcG9ydHMgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnb25seSBsYXRpbiB1cHBlciBhbmQgbG93ZXIgY2FzZSBsZXR0ZXJzLCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdkaWdpdHMsIHNwYWNlLCBhcG9zdHJvcGhlLCBsZWZ0IGFuZCByaWd0aCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdwYXJlbnRoZXNpcywgcGx1cyBzaWduLCBjb21tYSwgaHlwaGVuLCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdkb3QsIHNsYXNoLCBjb2xvbiwgZXF1YWwgc2lnbiwgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAncXVlc3Rpb24gbWFyaycpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9jcmVhdGVFbmNvZGVyQnVmZmVyKHN0cik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRoaXMucmVwb3J0ZXIuZXJyb3IoJ0VuY29kaW5nIG9mIHN0cmluZyB0eXBlOiAnICsgdGFnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIHVuc3VwcG9ydGVkJyk7XG4gIH1cbn07XG5cbkRFUk5vZGUucHJvdG90eXBlLl9lbmNvZGVPYmppZCA9IGZ1bmN0aW9uIGVuY29kZU9iamlkKGlkLCB2YWx1ZXMsIHJlbGF0aXZlKSB7XG4gIGlmICh0eXBlb2YgaWQgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKCF2YWx1ZXMpXG4gICAgICByZXR1cm4gdGhpcy5yZXBvcnRlci5lcnJvcignc3RyaW5nIG9iamlkIGdpdmVuLCBidXQgbm8gdmFsdWVzIG1hcCBmb3VuZCcpO1xuICAgIGlmICghdmFsdWVzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgIHJldHVybiB0aGlzLnJlcG9ydGVyLmVycm9yKCdvYmppZCBub3QgZm91bmQgaW4gdmFsdWVzIG1hcCcpO1xuICAgIGlkID0gdmFsdWVzW2lkXS5zcGxpdCgvW1xcc1xcLl0rL2cpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWQubGVuZ3RoOyBpKyspXG4gICAgICBpZFtpXSB8PSAwO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaWQpKSB7XG4gICAgaWQgPSBpZC5zbGljZSgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWQubGVuZ3RoOyBpKyspXG4gICAgICBpZFtpXSB8PSAwO1xuICB9XG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KGlkKSkge1xuICAgIHJldHVybiB0aGlzLnJlcG9ydGVyLmVycm9yKCdvYmppZCgpIHNob3VsZCBiZSBlaXRoZXIgYXJyYXkgb3Igc3RyaW5nLCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZ290OiAnICsgSlNPTi5zdHJpbmdpZnkoaWQpKTtcbiAgfVxuXG4gIGlmICghcmVsYXRpdmUpIHtcbiAgICBpZiAoaWRbMV0gPj0gNDApXG4gICAgICByZXR1cm4gdGhpcy5yZXBvcnRlci5lcnJvcignU2Vjb25kIG9iamlkIGlkZW50aWZpZXIgT09CJyk7XG4gICAgaWQuc3BsaWNlKDAsIDIsIGlkWzBdICogNDAgKyBpZFsxXSk7XG4gIH1cblxuICAvLyBDb3VudCBudW1iZXIgb2Ygb2N0ZXRzXG4gIHZhciBzaXplID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpZGVudCA9IGlkW2ldO1xuICAgIGZvciAoc2l6ZSsrOyBpZGVudCA+PSAweDgwOyBpZGVudCA+Pj0gNylcbiAgICAgIHNpemUrKztcbiAgfVxuXG4gIHZhciBvYmppZCA9IG5ldyBCdWZmZXIoc2l6ZSk7XG4gIHZhciBvZmZzZXQgPSBvYmppZC5sZW5ndGggLSAxO1xuICBmb3IgKHZhciBpID0gaWQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgaWRlbnQgPSBpZFtpXTtcbiAgICBvYmppZFtvZmZzZXQtLV0gPSBpZGVudCAmIDB4N2Y7XG4gICAgd2hpbGUgKChpZGVudCA+Pj0gNykgPiAwKVxuICAgICAgb2JqaWRbb2Zmc2V0LS1dID0gMHg4MCB8IChpZGVudCAmIDB4N2YpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuX2NyZWF0ZUVuY29kZXJCdWZmZXIob2JqaWQpO1xufTtcblxuZnVuY3Rpb24gdHdvKG51bSkge1xuICBpZiAobnVtIDwgMTApXG4gICAgcmV0dXJuICcwJyArIG51bTtcbiAgZWxzZVxuICAgIHJldHVybiBudW07XG59XG5cbkRFUk5vZGUucHJvdG90eXBlLl9lbmNvZGVUaW1lID0gZnVuY3Rpb24gZW5jb2RlVGltZSh0aW1lLCB0YWcpIHtcbiAgdmFyIHN0cjtcbiAgdmFyIGRhdGUgPSBuZXcgRGF0ZSh0aW1lKTtcblxuICBpZiAodGFnID09PSAnZ2VudGltZScpIHtcbiAgICBzdHIgPSBbXG4gICAgICB0d28oZGF0ZS5nZXRGdWxsWWVhcigpKSxcbiAgICAgIHR3byhkYXRlLmdldFVUQ01vbnRoKCkgKyAxKSxcbiAgICAgIHR3byhkYXRlLmdldFVUQ0RhdGUoKSksXG4gICAgICB0d28oZGF0ZS5nZXRVVENIb3VycygpKSxcbiAgICAgIHR3byhkYXRlLmdldFVUQ01pbnV0ZXMoKSksXG4gICAgICB0d28oZGF0ZS5nZXRVVENTZWNvbmRzKCkpLFxuICAgICAgJ1onXG4gICAgXS5qb2luKCcnKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICd1dGN0aW1lJykge1xuICAgIHN0ciA9IFtcbiAgICAgIHR3byhkYXRlLmdldEZ1bGxZZWFyKCkgJSAxMDApLFxuICAgICAgdHdvKGRhdGUuZ2V0VVRDTW9udGgoKSArIDEpLFxuICAgICAgdHdvKGRhdGUuZ2V0VVRDRGF0ZSgpKSxcbiAgICAgIHR3byhkYXRlLmdldFVUQ0hvdXJzKCkpLFxuICAgICAgdHdvKGRhdGUuZ2V0VVRDTWludXRlcygpKSxcbiAgICAgIHR3byhkYXRlLmdldFVUQ1NlY29uZHMoKSksXG4gICAgICAnWidcbiAgICBdLmpvaW4oJycpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMucmVwb3J0ZXIuZXJyb3IoJ0VuY29kaW5nICcgKyB0YWcgKyAnIHRpbWUgaXMgbm90IHN1cHBvcnRlZCB5ZXQnKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLl9lbmNvZGVTdHIoc3RyLCAnb2N0c3RyJyk7XG59O1xuXG5ERVJOb2RlLnByb3RvdHlwZS5fZW5jb2RlTnVsbCA9IGZ1bmN0aW9uIGVuY29kZU51bGwoKSB7XG4gIHJldHVybiB0aGlzLl9jcmVhdGVFbmNvZGVyQnVmZmVyKCcnKTtcbn07XG5cbkRFUk5vZGUucHJvdG90eXBlLl9lbmNvZGVJbnQgPSBmdW5jdGlvbiBlbmNvZGVJbnQobnVtLCB2YWx1ZXMpIHtcbiAgaWYgKHR5cGVvZiBudW0gPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKCF2YWx1ZXMpXG4gICAgICByZXR1cm4gdGhpcy5yZXBvcnRlci5lcnJvcignU3RyaW5nIGludCBvciBlbnVtIGdpdmVuLCBidXQgbm8gdmFsdWVzIG1hcCcpO1xuICAgIGlmICghdmFsdWVzLmhhc093blByb3BlcnR5KG51bSkpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlcG9ydGVyLmVycm9yKCdWYWx1ZXMgbWFwIGRvZXNuXFwndCBjb250YWluOiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KG51bSkpO1xuICAgIH1cbiAgICBudW0gPSB2YWx1ZXNbbnVtXTtcbiAgfVxuXG4gIC8vIEJpZ251bSwgYXNzdW1lIGJpZyBlbmRpYW5cbiAgaWYgKHR5cGVvZiBudW0gIT09ICdudW1iZXInICYmICFCdWZmZXIuaXNCdWZmZXIobnVtKSkge1xuICAgIHZhciBudW1BcnJheSA9IG51bS50b0FycmF5KCk7XG4gICAgaWYgKCFudW0uc2lnbiAmJiBudW1BcnJheVswXSAmIDB4ODApIHtcbiAgICAgIG51bUFycmF5LnVuc2hpZnQoMCk7XG4gICAgfVxuICAgIG51bSA9IG5ldyBCdWZmZXIobnVtQXJyYXkpO1xuICB9XG5cbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihudW0pKSB7XG4gICAgdmFyIHNpemUgPSBudW0ubGVuZ3RoO1xuICAgIGlmIChudW0ubGVuZ3RoID09PSAwKVxuICAgICAgc2l6ZSsrO1xuXG4gICAgdmFyIG91dCA9IG5ldyBCdWZmZXIoc2l6ZSk7XG4gICAgbnVtLmNvcHkob3V0KTtcbiAgICBpZiAobnVtLmxlbmd0aCA9PT0gMClcbiAgICAgIG91dFswXSA9IDBcbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlRW5jb2RlckJ1ZmZlcihvdXQpO1xuICB9XG5cbiAgaWYgKG51bSA8IDB4ODApXG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZUVuY29kZXJCdWZmZXIobnVtKTtcblxuICBpZiAobnVtIDwgMHgxMDApXG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZUVuY29kZXJCdWZmZXIoWzAsIG51bV0pO1xuXG4gIHZhciBzaXplID0gMTtcbiAgZm9yICh2YXIgaSA9IG51bTsgaSA+PSAweDEwMDsgaSA+Pj0gOClcbiAgICBzaXplKys7XG5cbiAgdmFyIG91dCA9IG5ldyBBcnJheShzaXplKTtcbiAgZm9yICh2YXIgaSA9IG91dC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIG91dFtpXSA9IG51bSAmIDB4ZmY7XG4gICAgbnVtID4+PSA4O1xuICB9XG4gIGlmKG91dFswXSAmIDB4ODApIHtcbiAgICBvdXQudW5zaGlmdCgwKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLl9jcmVhdGVFbmNvZGVyQnVmZmVyKG5ldyBCdWZmZXIob3V0KSk7XG59O1xuXG5ERVJOb2RlLnByb3RvdHlwZS5fZW5jb2RlQm9vbCA9IGZ1bmN0aW9uIGVuY29kZUJvb2wodmFsdWUpIHtcbiAgcmV0dXJuIHRoaXMuX2NyZWF0ZUVuY29kZXJCdWZmZXIodmFsdWUgPyAweGZmIDogMCk7XG59O1xuXG5ERVJOb2RlLnByb3RvdHlwZS5fdXNlID0gZnVuY3Rpb24gdXNlKGVudGl0eSwgb2JqKSB7XG4gIGlmICh0eXBlb2YgZW50aXR5ID09PSAnZnVuY3Rpb24nKVxuICAgIGVudGl0eSA9IGVudGl0eShvYmopO1xuICByZXR1cm4gZW50aXR5Ll9nZXRFbmNvZGVyKCdkZXInKS50cmVlO1xufTtcblxuREVSTm9kZS5wcm90b3R5cGUuX3NraXBEZWZhdWx0ID0gZnVuY3Rpb24gc2tpcERlZmF1bHQoZGF0YUJ1ZmZlciwgcmVwb3J0ZXIsIHBhcmVudCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG4gIHZhciBpO1xuICBpZiAoc3RhdGVbJ2RlZmF1bHQnXSA9PT0gbnVsbClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIGRhdGEgPSBkYXRhQnVmZmVyLmpvaW4oKTtcbiAgaWYgKHN0YXRlLmRlZmF1bHRCdWZmZXIgPT09IHVuZGVmaW5lZClcbiAgICBzdGF0ZS5kZWZhdWx0QnVmZmVyID0gdGhpcy5fZW5jb2RlVmFsdWUoc3RhdGVbJ2RlZmF1bHQnXSwgcmVwb3J0ZXIsIHBhcmVudCkuam9pbigpO1xuXG4gIGlmIChkYXRhLmxlbmd0aCAhPT0gc3RhdGUuZGVmYXVsdEJ1ZmZlci5sZW5ndGgpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGZvciAoaT0wOyBpIDwgZGF0YS5sZW5ndGg7IGkrKylcbiAgICBpZiAoZGF0YVtpXSAhPT0gc3RhdGUuZGVmYXVsdEJ1ZmZlcltpXSlcbiAgICAgIHJldHVybiBmYWxzZTtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIFV0aWxpdHkgbWV0aG9kc1xuXG5mdW5jdGlvbiBlbmNvZGVUYWcodGFnLCBwcmltaXRpdmUsIGNscywgcmVwb3J0ZXIpIHtcbiAgdmFyIHJlcztcblxuICBpZiAodGFnID09PSAnc2Vxb2YnKVxuICAgIHRhZyA9ICdzZXEnO1xuICBlbHNlIGlmICh0YWcgPT09ICdzZXRvZicpXG4gICAgdGFnID0gJ3NldCc7XG5cbiAgaWYgKGRlci50YWdCeU5hbWUuaGFzT3duUHJvcGVydHkodGFnKSlcbiAgICByZXMgPSBkZXIudGFnQnlOYW1lW3RhZ107XG4gIGVsc2UgaWYgKHR5cGVvZiB0YWcgPT09ICdudW1iZXInICYmICh0YWcgfCAwKSA9PT0gdGFnKVxuICAgIHJlcyA9IHRhZztcbiAgZWxzZVxuICAgIHJldHVybiByZXBvcnRlci5lcnJvcignVW5rbm93biB0YWc6ICcgKyB0YWcpO1xuXG4gIGlmIChyZXMgPj0gMHgxZilcbiAgICByZXR1cm4gcmVwb3J0ZXIuZXJyb3IoJ011bHRpLW9jdGV0IHRhZyBlbmNvZGluZyB1bnN1cHBvcnRlZCcpO1xuXG4gIGlmICghcHJpbWl0aXZlKVxuICAgIHJlcyB8PSAweDIwO1xuXG4gIHJlcyB8PSAoZGVyLnRhZ0NsYXNzQnlOYW1lW2NscyB8fCAndW5pdmVyc2FsJ10gPDwgNik7XG5cbiAgcmV0dXJuIHJlcztcbn1cbiIsInZhciBlbmNvZGVycyA9IGV4cG9ydHM7XG5cbmVuY29kZXJzLmRlciA9IHJlcXVpcmUoJy4vZGVyJyk7XG5lbmNvZGVycy5wZW0gPSByZXF1aXJlKCcuL3BlbScpO1xuIiwidmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG5cbnZhciBhc24xID0gcmVxdWlyZSgnLi4vLi4vYXNuMScpO1xudmFyIERFUkVuY29kZXIgPSByZXF1aXJlKCcuL2RlcicpO1xuXG5mdW5jdGlvbiBQRU1FbmNvZGVyKGVudGl0eSkge1xuICBERVJFbmNvZGVyLmNhbGwodGhpcywgZW50aXR5KTtcbiAgdGhpcy5lbmMgPSAncGVtJztcbn07XG5pbmhlcml0cyhQRU1FbmNvZGVyLCBERVJFbmNvZGVyKTtcbm1vZHVsZS5leHBvcnRzID0gUEVNRW5jb2RlcjtcblxuUEVNRW5jb2Rlci5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKGRhdGEsIG9wdGlvbnMpIHtcbiAgdmFyIGJ1ZiA9IERFUkVuY29kZXIucHJvdG90eXBlLmVuY29kZS5jYWxsKHRoaXMsIGRhdGEpO1xuXG4gIHZhciBwID0gYnVmLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgdmFyIG91dCA9IFsgJy0tLS0tQkVHSU4gJyArIG9wdGlvbnMubGFiZWwgKyAnLS0tLS0nIF07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcC5sZW5ndGg7IGkgKz0gNjQpXG4gICAgb3V0LnB1c2gocC5zbGljZShpLCBpICsgNjQpKTtcbiAgb3V0LnB1c2goJy0tLS0tRU5EICcgKyBvcHRpb25zLmxhYmVsICsgJy0tLS0tJyk7XG4gIHJldHVybiBvdXQuam9pbignXFxuJyk7XG59O1xuIiwiLy8gYmFzZWQgb24gdGhlIGFlcyBpbXBsaW1lbnRhdGlvbiBpbiB0cmlwbGUgc2VjXG4vLyBodHRwczovL2dpdGh1Yi5jb20va2V5YmFzZS90cmlwbGVzZWNcblxuLy8gd2hpY2ggaXMgaW4gdHVybiBiYXNlZCBvbiB0aGUgb25lIGZyb20gY3J5cHRvLWpzXG4vLyBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2NyeXB0by1qcy9cblxudmFyIHVpbnRfbWF4ID0gTWF0aC5wb3coMiwgMzIpXG5mdW5jdGlvbiBmaXh1cF91aW50MzIgKHgpIHtcbiAgdmFyIHJldCwgeF9wb3NcbiAgcmV0ID0geCA+IHVpbnRfbWF4IHx8IHggPCAwID8gKHhfcG9zID0gTWF0aC5hYnMoeCkgJSB1aW50X21heCwgeCA8IDAgPyB1aW50X21heCAtIHhfcG9zIDogeF9wb3MpIDogeFxuICByZXR1cm4gcmV0XG59XG5mdW5jdGlvbiBzY3J1Yl92ZWMgKHYpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2Lmxlbmd0aDsgdisrKSB7XG4gICAgdltpXSA9IDBcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gR2xvYmFsICgpIHtcbiAgdGhpcy5TQk9YID0gW11cbiAgdGhpcy5JTlZfU0JPWCA9IFtdXG4gIHRoaXMuU1VCX01JWCA9IFtbXSwgW10sIFtdLCBbXV1cbiAgdGhpcy5JTlZfU1VCX01JWCA9IFtbXSwgW10sIFtdLCBbXV1cbiAgdGhpcy5pbml0KClcbiAgdGhpcy5SQ09OID0gWzB4MDAsIDB4MDEsIDB4MDIsIDB4MDQsIDB4MDgsIDB4MTAsIDB4MjAsIDB4NDAsIDB4ODAsIDB4MWIsIDB4MzZdXG59XG5cbkdsb2JhbC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGQsIGksIHN4LCB0LCB4LCB4MiwgeDQsIHg4LCB4aSwgX2lcbiAgZCA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9pLCBfcmVzdWx0c1xuICAgIF9yZXN1bHRzID0gW11cbiAgICBmb3IgKGkgPSBfaSA9IDA7IF9pIDwgMjU2OyBpID0gKytfaSkge1xuICAgICAgaWYgKGkgPCAxMjgpIHtcbiAgICAgICAgX3Jlc3VsdHMucHVzaChpIDw8IDEpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfcmVzdWx0cy5wdXNoKChpIDw8IDEpIF4gMHgxMWIpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBfcmVzdWx0c1xuICB9KSgpXG4gIHggPSAwXG4gIHhpID0gMFxuICBmb3IgKGkgPSBfaSA9IDA7IF9pIDwgMjU2OyBpID0gKytfaSkge1xuICAgIHN4ID0geGkgXiAoeGkgPDwgMSkgXiAoeGkgPDwgMikgXiAoeGkgPDwgMykgXiAoeGkgPDwgNClcbiAgICBzeCA9IChzeCA+Pj4gOCkgXiAoc3ggJiAweGZmKSBeIDB4NjNcbiAgICB0aGlzLlNCT1hbeF0gPSBzeFxuICAgIHRoaXMuSU5WX1NCT1hbc3hdID0geFxuICAgIHgyID0gZFt4XVxuICAgIHg0ID0gZFt4Ml1cbiAgICB4OCA9IGRbeDRdXG4gICAgdCA9IChkW3N4XSAqIDB4MTAxKSBeIChzeCAqIDB4MTAxMDEwMClcbiAgICB0aGlzLlNVQl9NSVhbMF1beF0gPSAodCA8PCAyNCkgfCAodCA+Pj4gOClcbiAgICB0aGlzLlNVQl9NSVhbMV1beF0gPSAodCA8PCAxNikgfCAodCA+Pj4gMTYpXG4gICAgdGhpcy5TVUJfTUlYWzJdW3hdID0gKHQgPDwgOCkgfCAodCA+Pj4gMjQpXG4gICAgdGhpcy5TVUJfTUlYWzNdW3hdID0gdFxuICAgIHQgPSAoeDggKiAweDEwMTAxMDEpIF4gKHg0ICogMHgxMDAwMSkgXiAoeDIgKiAweDEwMSkgXiAoeCAqIDB4MTAxMDEwMClcbiAgICB0aGlzLklOVl9TVUJfTUlYWzBdW3N4XSA9ICh0IDw8IDI0KSB8ICh0ID4+PiA4KVxuICAgIHRoaXMuSU5WX1NVQl9NSVhbMV1bc3hdID0gKHQgPDwgMTYpIHwgKHQgPj4+IDE2KVxuICAgIHRoaXMuSU5WX1NVQl9NSVhbMl1bc3hdID0gKHQgPDwgOCkgfCAodCA+Pj4gMjQpXG4gICAgdGhpcy5JTlZfU1VCX01JWFszXVtzeF0gPSB0XG4gICAgaWYgKHggPT09IDApIHtcbiAgICAgIHggPSB4aSA9IDFcbiAgICB9IGVsc2Uge1xuICAgICAgeCA9IHgyIF4gZFtkW2RbeDggXiB4Ml1dXVxuICAgICAgeGkgXj0gZFtkW3hpXV1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxudmFyIEcgPSBuZXcgR2xvYmFsKClcblxuQUVTLmJsb2NrU2l6ZSA9IDQgKiA0XG5cbkFFUy5wcm90b3R5cGUuYmxvY2tTaXplID0gQUVTLmJsb2NrU2l6ZVxuXG5BRVMua2V5U2l6ZSA9IDI1NiAvIDhcblxuQUVTLnByb3RvdHlwZS5rZXlTaXplID0gQUVTLmtleVNpemVcblxuZnVuY3Rpb24gYnVmZmVyVG9BcnJheSAoYnVmKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoIC8gNFxuICB2YXIgb3V0ID0gbmV3IEFycmF5KGxlbilcbiAgdmFyIGkgPSAtMVxuICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgb3V0W2ldID0gYnVmLnJlYWRVSW50MzJCRShpICogNClcbiAgfVxuICByZXR1cm4gb3V0XG59XG5mdW5jdGlvbiBBRVMgKGtleSkge1xuICB0aGlzLl9rZXkgPSBidWZmZXJUb0FycmF5KGtleSlcbiAgdGhpcy5fZG9SZXNldCgpXG59XG5cbkFFUy5wcm90b3R5cGUuX2RvUmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBpbnZLc1Jvdywga2V5U2l6ZSwga2V5V29yZHMsIGtzUm93LCBrc1Jvd3MsIHRcbiAga2V5V29yZHMgPSB0aGlzLl9rZXlcbiAga2V5U2l6ZSA9IGtleVdvcmRzLmxlbmd0aFxuICB0aGlzLl9uUm91bmRzID0ga2V5U2l6ZSArIDZcbiAga3NSb3dzID0gKHRoaXMuX25Sb3VuZHMgKyAxKSAqIDRcbiAgdGhpcy5fa2V5U2NoZWR1bGUgPSBbXVxuICBmb3IgKGtzUm93ID0gMDsga3NSb3cgPCBrc1Jvd3M7IGtzUm93KyspIHtcbiAgICB0aGlzLl9rZXlTY2hlZHVsZVtrc1Jvd10gPSBrc1JvdyA8IGtleVNpemUgPyBrZXlXb3Jkc1trc1Jvd10gOiAodCA9IHRoaXMuX2tleVNjaGVkdWxlW2tzUm93IC0gMV0sIChrc1JvdyAlIGtleVNpemUpID09PSAwID8gKHQgPSAodCA8PCA4KSB8ICh0ID4+PiAyNCksIHQgPSAoRy5TQk9YW3QgPj4+IDI0XSA8PCAyNCkgfCAoRy5TQk9YWyh0ID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoRy5TQk9YWyh0ID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgRy5TQk9YW3QgJiAweGZmXSwgdCBePSBHLlJDT05bKGtzUm93IC8ga2V5U2l6ZSkgfCAwXSA8PCAyNCkgOiBrZXlTaXplID4gNiAmJiBrc1JvdyAlIGtleVNpemUgPT09IDQgPyB0ID0gKEcuU0JPWFt0ID4+PiAyNF0gPDwgMjQpIHwgKEcuU0JPWFsodCA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKEcuU0JPWFsodCA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IEcuU0JPWFt0ICYgMHhmZl0gOiB2b2lkIDAsIHRoaXMuX2tleVNjaGVkdWxlW2tzUm93IC0ga2V5U2l6ZV0gXiB0KVxuICB9XG4gIHRoaXMuX2ludktleVNjaGVkdWxlID0gW11cbiAgZm9yIChpbnZLc1JvdyA9IDA7IGludktzUm93IDwga3NSb3dzOyBpbnZLc1JvdysrKSB7XG4gICAga3NSb3cgPSBrc1Jvd3MgLSBpbnZLc1Jvd1xuICAgIHQgPSB0aGlzLl9rZXlTY2hlZHVsZVtrc1JvdyAtIChpbnZLc1JvdyAlIDQgPyAwIDogNCldXG4gICAgdGhpcy5faW52S2V5U2NoZWR1bGVbaW52S3NSb3ddID0gaW52S3NSb3cgPCA0IHx8IGtzUm93IDw9IDQgPyB0IDogRy5JTlZfU1VCX01JWFswXVtHLlNCT1hbdCA+Pj4gMjRdXSBeIEcuSU5WX1NVQl9NSVhbMV1bRy5TQk9YWyh0ID4+PiAxNikgJiAweGZmXV0gXiBHLklOVl9TVUJfTUlYWzJdW0cuU0JPWFsodCA+Pj4gOCkgJiAweGZmXV0gXiBHLklOVl9TVUJfTUlYWzNdW0cuU0JPWFt0ICYgMHhmZl1dXG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuQUVTLnByb3RvdHlwZS5lbmNyeXB0QmxvY2sgPSBmdW5jdGlvbiAoTSkge1xuICBNID0gYnVmZmVyVG9BcnJheShuZXcgQnVmZmVyKE0pKVxuICB2YXIgb3V0ID0gdGhpcy5fZG9DcnlwdEJsb2NrKE0sIHRoaXMuX2tleVNjaGVkdWxlLCBHLlNVQl9NSVgsIEcuU0JPWClcbiAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIoMTYpXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKG91dFswXSwgMClcbiAgYnVmLndyaXRlVUludDMyQkUob3V0WzFdLCA0KVxuICBidWYud3JpdGVVSW50MzJCRShvdXRbMl0sIDgpXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKG91dFszXSwgMTIpXG4gIHJldHVybiBidWZcbn1cblxuQUVTLnByb3RvdHlwZS5kZWNyeXB0QmxvY2sgPSBmdW5jdGlvbiAoTSkge1xuICBNID0gYnVmZmVyVG9BcnJheShuZXcgQnVmZmVyKE0pKVxuICB2YXIgdGVtcCA9IFtNWzNdLCBNWzFdXVxuICBNWzFdID0gdGVtcFswXVxuICBNWzNdID0gdGVtcFsxXVxuICB2YXIgb3V0ID0gdGhpcy5fZG9DcnlwdEJsb2NrKE0sIHRoaXMuX2ludktleVNjaGVkdWxlLCBHLklOVl9TVUJfTUlYLCBHLklOVl9TQk9YKVxuICB2YXIgYnVmID0gbmV3IEJ1ZmZlcigxNilcbiAgYnVmLndyaXRlVUludDMyQkUob3V0WzBdLCAwKVxuICBidWYud3JpdGVVSW50MzJCRShvdXRbM10sIDQpXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKG91dFsyXSwgOClcbiAgYnVmLndyaXRlVUludDMyQkUob3V0WzFdLCAxMilcbiAgcmV0dXJuIGJ1ZlxufVxuXG5BRVMucHJvdG90eXBlLnNjcnViID0gZnVuY3Rpb24gKCkge1xuICBzY3J1Yl92ZWModGhpcy5fa2V5U2NoZWR1bGUpXG4gIHNjcnViX3ZlYyh0aGlzLl9pbnZLZXlTY2hlZHVsZSlcbiAgc2NydWJfdmVjKHRoaXMuX2tleSlcbn1cblxuQUVTLnByb3RvdHlwZS5fZG9DcnlwdEJsb2NrID0gZnVuY3Rpb24gKE0sIGtleVNjaGVkdWxlLCBTVUJfTUlYLCBTQk9YKSB7XG4gIHZhciBrc1JvdywgczAsIHMxLCBzMiwgczMsIHQwLCB0MSwgdDIsIHQzXG5cbiAgczAgPSBNWzBdIF4ga2V5U2NoZWR1bGVbMF1cbiAgczEgPSBNWzFdIF4ga2V5U2NoZWR1bGVbMV1cbiAgczIgPSBNWzJdIF4ga2V5U2NoZWR1bGVbMl1cbiAgczMgPSBNWzNdIF4ga2V5U2NoZWR1bGVbM11cbiAga3NSb3cgPSA0XG4gIGZvciAodmFyIHJvdW5kID0gMTsgcm91bmQgPCB0aGlzLl9uUm91bmRzOyByb3VuZCsrKSB7XG4gICAgdDAgPSBTVUJfTUlYWzBdW3MwID4+PiAyNF0gXiBTVUJfTUlYWzFdWyhzMSA+Pj4gMTYpICYgMHhmZl0gXiBTVUJfTUlYWzJdWyhzMiA+Pj4gOCkgJiAweGZmXSBeIFNVQl9NSVhbM11bczMgJiAweGZmXSBeIGtleVNjaGVkdWxlW2tzUm93KytdXG4gICAgdDEgPSBTVUJfTUlYWzBdW3MxID4+PiAyNF0gXiBTVUJfTUlYWzFdWyhzMiA+Pj4gMTYpICYgMHhmZl0gXiBTVUJfTUlYWzJdWyhzMyA+Pj4gOCkgJiAweGZmXSBeIFNVQl9NSVhbM11bczAgJiAweGZmXSBeIGtleVNjaGVkdWxlW2tzUm93KytdXG4gICAgdDIgPSBTVUJfTUlYWzBdW3MyID4+PiAyNF0gXiBTVUJfTUlYWzFdWyhzMyA+Pj4gMTYpICYgMHhmZl0gXiBTVUJfTUlYWzJdWyhzMCA+Pj4gOCkgJiAweGZmXSBeIFNVQl9NSVhbM11bczEgJiAweGZmXSBeIGtleVNjaGVkdWxlW2tzUm93KytdXG4gICAgdDMgPSBTVUJfTUlYWzBdW3MzID4+PiAyNF0gXiBTVUJfTUlYWzFdWyhzMCA+Pj4gMTYpICYgMHhmZl0gXiBTVUJfTUlYWzJdWyhzMSA+Pj4gOCkgJiAweGZmXSBeIFNVQl9NSVhbM11bczIgJiAweGZmXSBeIGtleVNjaGVkdWxlW2tzUm93KytdXG4gICAgczAgPSB0MFxuICAgIHMxID0gdDFcbiAgICBzMiA9IHQyXG4gICAgczMgPSB0M1xuICB9XG4gIHQwID0gKChTQk9YW3MwID4+PiAyNF0gPDwgMjQpIHwgKFNCT1hbKHMxID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoU0JPWFsoczIgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBTQk9YW3MzICYgMHhmZl0pIF4ga2V5U2NoZWR1bGVba3NSb3crK11cbiAgdDEgPSAoKFNCT1hbczEgPj4+IDI0XSA8PCAyNCkgfCAoU0JPWFsoczIgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChTQk9YWyhzMyA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IFNCT1hbczAgJiAweGZmXSkgXiBrZXlTY2hlZHVsZVtrc1JvdysrXVxuICB0MiA9ICgoU0JPWFtzMiA+Pj4gMjRdIDw8IDI0KSB8IChTQk9YWyhzMyA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKFNCT1hbKHMwID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgU0JPWFtzMSAmIDB4ZmZdKSBeIGtleVNjaGVkdWxlW2tzUm93KytdXG4gIHQzID0gKChTQk9YW3MzID4+PiAyNF0gPDwgMjQpIHwgKFNCT1hbKHMwID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoU0JPWFsoczEgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBTQk9YW3MyICYgMHhmZl0pIF4ga2V5U2NoZWR1bGVba3NSb3crK11cbiAgcmV0dXJuIFtcbiAgICBmaXh1cF91aW50MzIodDApLFxuICAgIGZpeHVwX3VpbnQzMih0MSksXG4gICAgZml4dXBfdWludDMyKHQyKSxcbiAgICBmaXh1cF91aW50MzIodDMpXG4gIF1cbn1cblxuZXhwb3J0cy5BRVMgPSBBRVNcbiIsInZhciBhZXMgPSByZXF1aXJlKCcuL2FlcycpXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnY2lwaGVyLWJhc2UnKVxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIEdIQVNIID0gcmVxdWlyZSgnLi9naGFzaCcpXG52YXIgeG9yID0gcmVxdWlyZSgnYnVmZmVyLXhvcicpXG5pbmhlcml0cyhTdHJlYW1DaXBoZXIsIFRyYW5zZm9ybSlcbm1vZHVsZS5leHBvcnRzID0gU3RyZWFtQ2lwaGVyXG5cbmZ1bmN0aW9uIFN0cmVhbUNpcGhlciAobW9kZSwga2V5LCBpdiwgZGVjcnlwdCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU3RyZWFtQ2lwaGVyKSkge1xuICAgIHJldHVybiBuZXcgU3RyZWFtQ2lwaGVyKG1vZGUsIGtleSwgaXYpXG4gIH1cbiAgVHJhbnNmb3JtLmNhbGwodGhpcylcbiAgdGhpcy5fZmluSUQgPSBCdWZmZXIuY29uY2F0KFtpdiwgbmV3IEJ1ZmZlcihbMCwgMCwgMCwgMV0pXSlcbiAgaXYgPSBCdWZmZXIuY29uY2F0KFtpdiwgbmV3IEJ1ZmZlcihbMCwgMCwgMCwgMl0pXSlcbiAgdGhpcy5fY2lwaGVyID0gbmV3IGFlcy5BRVMoa2V5KVxuICB0aGlzLl9wcmV2ID0gbmV3IEJ1ZmZlcihpdi5sZW5ndGgpXG4gIHRoaXMuX2NhY2hlID0gbmV3IEJ1ZmZlcignJylcbiAgdGhpcy5fc2VjQ2FjaGUgPSBuZXcgQnVmZmVyKCcnKVxuICB0aGlzLl9kZWNyeXB0ID0gZGVjcnlwdFxuICB0aGlzLl9hbGVuID0gMFxuICB0aGlzLl9sZW4gPSAwXG4gIGl2LmNvcHkodGhpcy5fcHJldilcbiAgdGhpcy5fbW9kZSA9IG1vZGVcbiAgdmFyIGggPSBuZXcgQnVmZmVyKDQpXG4gIGguZmlsbCgwKVxuICB0aGlzLl9naGFzaCA9IG5ldyBHSEFTSCh0aGlzLl9jaXBoZXIuZW5jcnlwdEJsb2NrKGgpKVxuICB0aGlzLl9hdXRoVGFnID0gbnVsbFxuICB0aGlzLl9jYWxsZWQgPSBmYWxzZVxufVxuU3RyZWFtQ2lwaGVyLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIGlmICghdGhpcy5fY2FsbGVkICYmIHRoaXMuX2FsZW4pIHtcbiAgICB2YXIgcnVtcCA9IDE2IC0gKHRoaXMuX2FsZW4gJSAxNilcbiAgICBpZiAocnVtcCA8IDE2KSB7XG4gICAgICBydW1wID0gbmV3IEJ1ZmZlcihydW1wKVxuICAgICAgcnVtcC5maWxsKDApXG4gICAgICB0aGlzLl9naGFzaC51cGRhdGUocnVtcClcbiAgICB9XG4gIH1cbiAgdGhpcy5fY2FsbGVkID0gdHJ1ZVxuICB2YXIgb3V0ID0gdGhpcy5fbW9kZS5lbmNyeXB0KHRoaXMsIGNodW5rKVxuICBpZiAodGhpcy5fZGVjcnlwdCkge1xuICAgIHRoaXMuX2doYXNoLnVwZGF0ZShjaHVuaylcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9naGFzaC51cGRhdGUob3V0KVxuICB9XG4gIHRoaXMuX2xlbiArPSBjaHVuay5sZW5ndGhcbiAgcmV0dXJuIG91dFxufVxuU3RyZWFtQ2lwaGVyLnByb3RvdHlwZS5fZmluYWwgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLl9kZWNyeXB0ICYmICF0aGlzLl9hdXRoVGFnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBzdGF0ZSBvciB1bmFibGUgdG8gYXV0aGVudGljYXRlIGRhdGEnKVxuICB9XG4gIHZhciB0YWcgPSB4b3IodGhpcy5fZ2hhc2guZmluYWwodGhpcy5fYWxlbiAqIDgsIHRoaXMuX2xlbiAqIDgpLCB0aGlzLl9jaXBoZXIuZW5jcnlwdEJsb2NrKHRoaXMuX2ZpbklEKSlcbiAgaWYgKHRoaXMuX2RlY3J5cHQpIHtcbiAgICBpZiAoeG9yVGVzdCh0YWcsIHRoaXMuX2F1dGhUYWcpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHN0YXRlIG9yIHVuYWJsZSB0byBhdXRoZW50aWNhdGUgZGF0YScpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRoaXMuX2F1dGhUYWcgPSB0YWdcbiAgfVxuICB0aGlzLl9jaXBoZXIuc2NydWIoKVxufVxuU3RyZWFtQ2lwaGVyLnByb3RvdHlwZS5nZXRBdXRoVGFnID0gZnVuY3Rpb24gZ2V0QXV0aFRhZyAoKSB7XG4gIGlmICghdGhpcy5fZGVjcnlwdCAmJiBCdWZmZXIuaXNCdWZmZXIodGhpcy5fYXV0aFRhZykpIHtcbiAgICByZXR1cm4gdGhpcy5fYXV0aFRhZ1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignQXR0ZW1wdGluZyB0byBnZXQgYXV0aCB0YWcgaW4gdW5zdXBwb3J0ZWQgc3RhdGUnKVxuICB9XG59XG5TdHJlYW1DaXBoZXIucHJvdG90eXBlLnNldEF1dGhUYWcgPSBmdW5jdGlvbiBzZXRBdXRoVGFnICh0YWcpIHtcbiAgaWYgKHRoaXMuX2RlY3J5cHQpIHtcbiAgICB0aGlzLl9hdXRoVGFnID0gdGFnXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdBdHRlbXB0aW5nIHRvIHNldCBhdXRoIHRhZyBpbiB1bnN1cHBvcnRlZCBzdGF0ZScpXG4gIH1cbn1cblN0cmVhbUNpcGhlci5wcm90b3R5cGUuc2V0QUFEID0gZnVuY3Rpb24gc2V0QUFEIChidWYpIHtcbiAgaWYgKCF0aGlzLl9jYWxsZWQpIHtcbiAgICB0aGlzLl9naGFzaC51cGRhdGUoYnVmKVxuICAgIHRoaXMuX2FsZW4gKz0gYnVmLmxlbmd0aFxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignQXR0ZW1wdGluZyB0byBzZXQgQUFEIGluIHVuc3VwcG9ydGVkIHN0YXRlJylcbiAgfVxufVxuZnVuY3Rpb24geG9yVGVzdCAoYSwgYikge1xuICB2YXIgb3V0ID0gMFxuICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgb3V0KytcbiAgfVxuICB2YXIgbGVuID0gTWF0aC5taW4oYS5sZW5ndGgsIGIubGVuZ3RoKVxuICB2YXIgaSA9IC0xXG4gIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICBvdXQgKz0gKGFbaV0gXiBiW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cbiIsInZhciBhZXMgPSByZXF1aXJlKCcuL2FlcycpXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnY2lwaGVyLWJhc2UnKVxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIG1vZGVzID0gcmVxdWlyZSgnLi9tb2RlcycpXG52YXIgU3RyZWFtQ2lwaGVyID0gcmVxdWlyZSgnLi9zdHJlYW1DaXBoZXInKVxudmFyIEF1dGhDaXBoZXIgPSByZXF1aXJlKCcuL2F1dGhDaXBoZXInKVxudmFyIGVidGsgPSByZXF1aXJlKCdldnBfYnl0ZXN0b2tleScpXG5cbmluaGVyaXRzKERlY2lwaGVyLCBUcmFuc2Zvcm0pXG5mdW5jdGlvbiBEZWNpcGhlciAobW9kZSwga2V5LCBpdikge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRGVjaXBoZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBEZWNpcGhlcihtb2RlLCBrZXksIGl2KVxuICB9XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMpXG4gIHRoaXMuX2NhY2hlID0gbmV3IFNwbGl0dGVyKClcbiAgdGhpcy5fbGFzdCA9IHZvaWQgMFxuICB0aGlzLl9jaXBoZXIgPSBuZXcgYWVzLkFFUyhrZXkpXG4gIHRoaXMuX3ByZXYgPSBuZXcgQnVmZmVyKGl2Lmxlbmd0aClcbiAgaXYuY29weSh0aGlzLl9wcmV2KVxuICB0aGlzLl9tb2RlID0gbW9kZVxuICB0aGlzLl9hdXRvcGFkZGluZyA9IHRydWVcbn1cbkRlY2lwaGVyLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgdGhpcy5fY2FjaGUuYWRkKGRhdGEpXG4gIHZhciBjaHVua1xuICB2YXIgdGhpbmdcbiAgdmFyIG91dCA9IFtdXG4gIHdoaWxlICgoY2h1bmsgPSB0aGlzLl9jYWNoZS5nZXQodGhpcy5fYXV0b3BhZGRpbmcpKSkge1xuICAgIHRoaW5nID0gdGhpcy5fbW9kZS5kZWNyeXB0KHRoaXMsIGNodW5rKVxuICAgIG91dC5wdXNoKHRoaW5nKVxuICB9XG4gIHJldHVybiBCdWZmZXIuY29uY2F0KG91dClcbn1cbkRlY2lwaGVyLnByb3RvdHlwZS5fZmluYWwgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBjaHVuayA9IHRoaXMuX2NhY2hlLmZsdXNoKClcbiAgaWYgKHRoaXMuX2F1dG9wYWRkaW5nKSB7XG4gICAgcmV0dXJuIHVucGFkKHRoaXMuX21vZGUuZGVjcnlwdCh0aGlzLCBjaHVuaykpXG4gIH0gZWxzZSBpZiAoY2h1bmspIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2RhdGEgbm90IG11bHRpcGxlIG9mIGJsb2NrIGxlbmd0aCcpXG4gIH1cbn1cbkRlY2lwaGVyLnByb3RvdHlwZS5zZXRBdXRvUGFkZGluZyA9IGZ1bmN0aW9uIChzZXRUbykge1xuICB0aGlzLl9hdXRvcGFkZGluZyA9ICEhc2V0VG9cbn1cbmZ1bmN0aW9uIFNwbGl0dGVyICgpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNwbGl0dGVyKSkge1xuICAgIHJldHVybiBuZXcgU3BsaXR0ZXIoKVxuICB9XG4gIHRoaXMuY2FjaGUgPSBuZXcgQnVmZmVyKCcnKVxufVxuU3BsaXR0ZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHRoaXMuY2FjaGUgPSBCdWZmZXIuY29uY2F0KFt0aGlzLmNhY2hlLCBkYXRhXSlcbn1cblxuU3BsaXR0ZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChhdXRvUGFkZGluZykge1xuICB2YXIgb3V0XG4gIGlmIChhdXRvUGFkZGluZykge1xuICAgIGlmICh0aGlzLmNhY2hlLmxlbmd0aCA+IDE2KSB7XG4gICAgICBvdXQgPSB0aGlzLmNhY2hlLnNsaWNlKDAsIDE2KVxuICAgICAgdGhpcy5jYWNoZSA9IHRoaXMuY2FjaGUuc2xpY2UoMTYpXG4gICAgICByZXR1cm4gb3V0XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh0aGlzLmNhY2hlLmxlbmd0aCA+PSAxNikge1xuICAgICAgb3V0ID0gdGhpcy5jYWNoZS5zbGljZSgwLCAxNilcbiAgICAgIHRoaXMuY2FjaGUgPSB0aGlzLmNhY2hlLnNsaWNlKDE2KVxuICAgICAgcmV0dXJuIG91dFxuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbFxufVxuU3BsaXR0ZXIucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5jYWNoZS5sZW5ndGgpIHtcbiAgICByZXR1cm4gdGhpcy5jYWNoZVxuICB9XG59XG5mdW5jdGlvbiB1bnBhZCAobGFzdCkge1xuICB2YXIgcGFkZGVkID0gbGFzdFsxNV1cbiAgdmFyIGkgPSAtMVxuICB3aGlsZSAoKytpIDwgcGFkZGVkKSB7XG4gICAgaWYgKGxhc3RbKGkgKyAoMTYgLSBwYWRkZWQpKV0gIT09IHBhZGRlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmFibGUgdG8gZGVjcnlwdCBkYXRhJylcbiAgICB9XG4gIH1cbiAgaWYgKHBhZGRlZCA9PT0gMTYpIHtcbiAgICByZXR1cm5cbiAgfVxuICByZXR1cm4gbGFzdC5zbGljZSgwLCAxNiAtIHBhZGRlZClcbn1cblxudmFyIG1vZGVsaXN0ID0ge1xuICBFQ0I6IHJlcXVpcmUoJy4vbW9kZXMvZWNiJyksXG4gIENCQzogcmVxdWlyZSgnLi9tb2Rlcy9jYmMnKSxcbiAgQ0ZCOiByZXF1aXJlKCcuL21vZGVzL2NmYicpLFxuICBDRkI4OiByZXF1aXJlKCcuL21vZGVzL2NmYjgnKSxcbiAgQ0ZCMTogcmVxdWlyZSgnLi9tb2Rlcy9jZmIxJyksXG4gIE9GQjogcmVxdWlyZSgnLi9tb2Rlcy9vZmInKSxcbiAgQ1RSOiByZXF1aXJlKCcuL21vZGVzL2N0cicpLFxuICBHQ006IHJlcXVpcmUoJy4vbW9kZXMvY3RyJylcbn1cblxuZnVuY3Rpb24gY3JlYXRlRGVjaXBoZXJpdiAoc3VpdGUsIHBhc3N3b3JkLCBpdikge1xuICB2YXIgY29uZmlnID0gbW9kZXNbc3VpdGUudG9Mb3dlckNhc2UoKV1cbiAgaWYgKCFjb25maWcpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHN1aXRlIHR5cGUnKVxuICB9XG4gIGlmICh0eXBlb2YgaXYgPT09ICdzdHJpbmcnKSB7XG4gICAgaXYgPSBuZXcgQnVmZmVyKGl2KVxuICB9XG4gIGlmICh0eXBlb2YgcGFzc3dvcmQgPT09ICdzdHJpbmcnKSB7XG4gICAgcGFzc3dvcmQgPSBuZXcgQnVmZmVyKHBhc3N3b3JkKVxuICB9XG4gIGlmIChwYXNzd29yZC5sZW5ndGggIT09IGNvbmZpZy5rZXkgLyA4KSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBrZXkgbGVuZ3RoICcgKyBwYXNzd29yZC5sZW5ndGgpXG4gIH1cbiAgaWYgKGl2Lmxlbmd0aCAhPT0gY29uZmlnLml2KSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBpdiBsZW5ndGggJyArIGl2Lmxlbmd0aClcbiAgfVxuICBpZiAoY29uZmlnLnR5cGUgPT09ICdzdHJlYW0nKSB7XG4gICAgcmV0dXJuIG5ldyBTdHJlYW1DaXBoZXIobW9kZWxpc3RbY29uZmlnLm1vZGVdLCBwYXNzd29yZCwgaXYsIHRydWUpXG4gIH0gZWxzZSBpZiAoY29uZmlnLnR5cGUgPT09ICdhdXRoJykge1xuICAgIHJldHVybiBuZXcgQXV0aENpcGhlcihtb2RlbGlzdFtjb25maWcubW9kZV0sIHBhc3N3b3JkLCBpdiwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gbmV3IERlY2lwaGVyKG1vZGVsaXN0W2NvbmZpZy5tb2RlXSwgcGFzc3dvcmQsIGl2KVxufVxuXG5mdW5jdGlvbiBjcmVhdGVEZWNpcGhlciAoc3VpdGUsIHBhc3N3b3JkKSB7XG4gIHZhciBjb25maWcgPSBtb2Rlc1tzdWl0ZS50b0xvd2VyQ2FzZSgpXVxuICBpZiAoIWNvbmZpZykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgc3VpdGUgdHlwZScpXG4gIH1cbiAgdmFyIGtleXMgPSBlYnRrKHBhc3N3b3JkLCBmYWxzZSwgY29uZmlnLmtleSwgY29uZmlnLml2KVxuICByZXR1cm4gY3JlYXRlRGVjaXBoZXJpdihzdWl0ZSwga2V5cy5rZXksIGtleXMuaXYpXG59XG5leHBvcnRzLmNyZWF0ZURlY2lwaGVyID0gY3JlYXRlRGVjaXBoZXJcbmV4cG9ydHMuY3JlYXRlRGVjaXBoZXJpdiA9IGNyZWF0ZURlY2lwaGVyaXZcbiIsInZhciBhZXMgPSByZXF1aXJlKCcuL2FlcycpXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnY2lwaGVyLWJhc2UnKVxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIG1vZGVzID0gcmVxdWlyZSgnLi9tb2RlcycpXG52YXIgZWJ0ayA9IHJlcXVpcmUoJ2V2cF9ieXRlc3Rva2V5JylcbnZhciBTdHJlYW1DaXBoZXIgPSByZXF1aXJlKCcuL3N0cmVhbUNpcGhlcicpXG52YXIgQXV0aENpcGhlciA9IHJlcXVpcmUoJy4vYXV0aENpcGhlcicpXG5pbmhlcml0cyhDaXBoZXIsIFRyYW5zZm9ybSlcbmZ1bmN0aW9uIENpcGhlciAobW9kZSwga2V5LCBpdikge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQ2lwaGVyKSkge1xuICAgIHJldHVybiBuZXcgQ2lwaGVyKG1vZGUsIGtleSwgaXYpXG4gIH1cbiAgVHJhbnNmb3JtLmNhbGwodGhpcylcbiAgdGhpcy5fY2FjaGUgPSBuZXcgU3BsaXR0ZXIoKVxuICB0aGlzLl9jaXBoZXIgPSBuZXcgYWVzLkFFUyhrZXkpXG4gIHRoaXMuX3ByZXYgPSBuZXcgQnVmZmVyKGl2Lmxlbmd0aClcbiAgaXYuY29weSh0aGlzLl9wcmV2KVxuICB0aGlzLl9tb2RlID0gbW9kZVxuICB0aGlzLl9hdXRvcGFkZGluZyA9IHRydWVcbn1cbkNpcGhlci5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHRoaXMuX2NhY2hlLmFkZChkYXRhKVxuICB2YXIgY2h1bmtcbiAgdmFyIHRoaW5nXG4gIHZhciBvdXQgPSBbXVxuICB3aGlsZSAoKGNodW5rID0gdGhpcy5fY2FjaGUuZ2V0KCkpKSB7XG4gICAgdGhpbmcgPSB0aGlzLl9tb2RlLmVuY3J5cHQodGhpcywgY2h1bmspXG4gICAgb3V0LnB1c2godGhpbmcpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5jb25jYXQob3V0KVxufVxuQ2lwaGVyLnByb3RvdHlwZS5fZmluYWwgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBjaHVuayA9IHRoaXMuX2NhY2hlLmZsdXNoKClcbiAgaWYgKHRoaXMuX2F1dG9wYWRkaW5nKSB7XG4gICAgY2h1bmsgPSB0aGlzLl9tb2RlLmVuY3J5cHQodGhpcywgY2h1bmspXG4gICAgdGhpcy5fY2lwaGVyLnNjcnViKClcbiAgICByZXR1cm4gY2h1bmtcbiAgfSBlbHNlIGlmIChjaHVuay50b1N0cmluZygnaGV4JykgIT09ICcxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMCcpIHtcbiAgICB0aGlzLl9jaXBoZXIuc2NydWIoKVxuICAgIHRocm93IG5ldyBFcnJvcignZGF0YSBub3QgbXVsdGlwbGUgb2YgYmxvY2sgbGVuZ3RoJylcbiAgfVxufVxuQ2lwaGVyLnByb3RvdHlwZS5zZXRBdXRvUGFkZGluZyA9IGZ1bmN0aW9uIChzZXRUbykge1xuICB0aGlzLl9hdXRvcGFkZGluZyA9ICEhc2V0VG9cbn1cblxuZnVuY3Rpb24gU3BsaXR0ZXIgKCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU3BsaXR0ZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBTcGxpdHRlcigpXG4gIH1cbiAgdGhpcy5jYWNoZSA9IG5ldyBCdWZmZXIoJycpXG59XG5TcGxpdHRlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgdGhpcy5jYWNoZSA9IEJ1ZmZlci5jb25jYXQoW3RoaXMuY2FjaGUsIGRhdGFdKVxufVxuXG5TcGxpdHRlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5jYWNoZS5sZW5ndGggPiAxNSkge1xuICAgIHZhciBvdXQgPSB0aGlzLmNhY2hlLnNsaWNlKDAsIDE2KVxuICAgIHRoaXMuY2FjaGUgPSB0aGlzLmNhY2hlLnNsaWNlKDE2KVxuICAgIHJldHVybiBvdXRcbiAgfVxuICByZXR1cm4gbnVsbFxufVxuU3BsaXR0ZXIucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbGVuID0gMTYgLSB0aGlzLmNhY2hlLmxlbmd0aFxuICB2YXIgcGFkQnVmZiA9IG5ldyBCdWZmZXIobGVuKVxuXG4gIHZhciBpID0gLTFcbiAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgIHBhZEJ1ZmYud3JpdGVVSW50OChsZW4sIGkpXG4gIH1cbiAgdmFyIG91dCA9IEJ1ZmZlci5jb25jYXQoW3RoaXMuY2FjaGUsIHBhZEJ1ZmZdKVxuICByZXR1cm4gb3V0XG59XG52YXIgbW9kZWxpc3QgPSB7XG4gIEVDQjogcmVxdWlyZSgnLi9tb2Rlcy9lY2InKSxcbiAgQ0JDOiByZXF1aXJlKCcuL21vZGVzL2NiYycpLFxuICBDRkI6IHJlcXVpcmUoJy4vbW9kZXMvY2ZiJyksXG4gIENGQjg6IHJlcXVpcmUoJy4vbW9kZXMvY2ZiOCcpLFxuICBDRkIxOiByZXF1aXJlKCcuL21vZGVzL2NmYjEnKSxcbiAgT0ZCOiByZXF1aXJlKCcuL21vZGVzL29mYicpLFxuICBDVFI6IHJlcXVpcmUoJy4vbW9kZXMvY3RyJyksXG4gIEdDTTogcmVxdWlyZSgnLi9tb2Rlcy9jdHInKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDaXBoZXJpdiAoc3VpdGUsIHBhc3N3b3JkLCBpdikge1xuICB2YXIgY29uZmlnID0gbW9kZXNbc3VpdGUudG9Mb3dlckNhc2UoKV1cbiAgaWYgKCFjb25maWcpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHN1aXRlIHR5cGUnKVxuICB9XG4gIGlmICh0eXBlb2YgaXYgPT09ICdzdHJpbmcnKSB7XG4gICAgaXYgPSBuZXcgQnVmZmVyKGl2KVxuICB9XG4gIGlmICh0eXBlb2YgcGFzc3dvcmQgPT09ICdzdHJpbmcnKSB7XG4gICAgcGFzc3dvcmQgPSBuZXcgQnVmZmVyKHBhc3N3b3JkKVxuICB9XG4gIGlmIChwYXNzd29yZC5sZW5ndGggIT09IGNvbmZpZy5rZXkgLyA4KSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBrZXkgbGVuZ3RoICcgKyBwYXNzd29yZC5sZW5ndGgpXG4gIH1cbiAgaWYgKGl2Lmxlbmd0aCAhPT0gY29uZmlnLml2KSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBpdiBsZW5ndGggJyArIGl2Lmxlbmd0aClcbiAgfVxuICBpZiAoY29uZmlnLnR5cGUgPT09ICdzdHJlYW0nKSB7XG4gICAgcmV0dXJuIG5ldyBTdHJlYW1DaXBoZXIobW9kZWxpc3RbY29uZmlnLm1vZGVdLCBwYXNzd29yZCwgaXYpXG4gIH0gZWxzZSBpZiAoY29uZmlnLnR5cGUgPT09ICdhdXRoJykge1xuICAgIHJldHVybiBuZXcgQXV0aENpcGhlcihtb2RlbGlzdFtjb25maWcubW9kZV0sIHBhc3N3b3JkLCBpdilcbiAgfVxuICByZXR1cm4gbmV3IENpcGhlcihtb2RlbGlzdFtjb25maWcubW9kZV0sIHBhc3N3b3JkLCBpdilcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNpcGhlciAoc3VpdGUsIHBhc3N3b3JkKSB7XG4gIHZhciBjb25maWcgPSBtb2Rlc1tzdWl0ZS50b0xvd2VyQ2FzZSgpXVxuICBpZiAoIWNvbmZpZykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgc3VpdGUgdHlwZScpXG4gIH1cbiAgdmFyIGtleXMgPSBlYnRrKHBhc3N3b3JkLCBmYWxzZSwgY29uZmlnLmtleSwgY29uZmlnLml2KVxuICByZXR1cm4gY3JlYXRlQ2lwaGVyaXYoc3VpdGUsIGtleXMua2V5LCBrZXlzLml2KVxufVxuXG5leHBvcnRzLmNyZWF0ZUNpcGhlcml2ID0gY3JlYXRlQ2lwaGVyaXZcbmV4cG9ydHMuY3JlYXRlQ2lwaGVyID0gY3JlYXRlQ2lwaGVyXG4iLCJ2YXIgemVyb3MgPSBuZXcgQnVmZmVyKDE2KVxuemVyb3MuZmlsbCgwKVxubW9kdWxlLmV4cG9ydHMgPSBHSEFTSFxuZnVuY3Rpb24gR0hBU0ggKGtleSkge1xuICB0aGlzLmggPSBrZXlcbiAgdGhpcy5zdGF0ZSA9IG5ldyBCdWZmZXIoMTYpXG4gIHRoaXMuc3RhdGUuZmlsbCgwKVxuICB0aGlzLmNhY2hlID0gbmV3IEJ1ZmZlcignJylcbn1cbi8vIGZyb20gaHR0cDovL2JpdHdpc2VzaGlmdGxlZnQuZ2l0aHViLmlvL3NqY2wvZG9jL3N5bWJvbHMvc3JjL2NvcmVfZ2NtLmpzLmh0bWxcbi8vIGJ5IEp1aG8gVsOkaMOkLUhlcnR0dWFcbkdIQVNILnByb3RvdHlwZS5naGFzaCA9IGZ1bmN0aW9uIChibG9jaykge1xuICB2YXIgaSA9IC0xXG4gIHdoaWxlICgrK2kgPCBibG9jay5sZW5ndGgpIHtcbiAgICB0aGlzLnN0YXRlW2ldIF49IGJsb2NrW2ldXG4gIH1cbiAgdGhpcy5fbXVsdGlwbHkoKVxufVxuXG5HSEFTSC5wcm90b3R5cGUuX211bHRpcGx5ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgVmkgPSB0b0FycmF5KHRoaXMuaClcbiAgdmFyIFppID0gWzAsIDAsIDAsIDBdXG4gIHZhciBqLCB4aSwgbHNiX1ZpXG4gIHZhciBpID0gLTFcbiAgd2hpbGUgKCsraSA8IDEyOCkge1xuICAgIHhpID0gKHRoaXMuc3RhdGVbfn4oaSAvIDgpXSAmICgxIDw8ICg3IC0gaSAlIDgpKSkgIT09IDBcbiAgICBpZiAoeGkpIHtcbiAgICAgIC8vIFpfaSsxID0gWl9pIF4gVl9pXG4gICAgICBaaSA9IHhvcihaaSwgVmkpXG4gICAgfVxuXG4gICAgLy8gU3RvcmUgdGhlIHZhbHVlIG9mIExTQihWX2kpXG4gICAgbHNiX1ZpID0gKFZpWzNdICYgMSkgIT09IDBcblxuICAgIC8vIFZfaSsxID0gVl9pID4+IDFcbiAgICBmb3IgKGogPSAzOyBqID4gMDsgai0tKSB7XG4gICAgICBWaVtqXSA9IChWaVtqXSA+Pj4gMSkgfCAoKFZpW2ogLSAxXSAmIDEpIDw8IDMxKVxuICAgIH1cbiAgICBWaVswXSA9IFZpWzBdID4+PiAxXG5cbiAgICAvLyBJZiBMU0IoVl9pKSBpcyAxLCBWX2krMSA9IChWX2kgPj4gMSkgXiBSXG4gICAgaWYgKGxzYl9WaSkge1xuICAgICAgVmlbMF0gPSBWaVswXSBeICgweGUxIDw8IDI0KVxuICAgIH1cbiAgfVxuICB0aGlzLnN0YXRlID0gZnJvbUFycmF5KFppKVxufVxuR0hBU0gucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChidWYpIHtcbiAgdGhpcy5jYWNoZSA9IEJ1ZmZlci5jb25jYXQoW3RoaXMuY2FjaGUsIGJ1Zl0pXG4gIHZhciBjaHVua1xuICB3aGlsZSAodGhpcy5jYWNoZS5sZW5ndGggPj0gMTYpIHtcbiAgICBjaHVuayA9IHRoaXMuY2FjaGUuc2xpY2UoMCwgMTYpXG4gICAgdGhpcy5jYWNoZSA9IHRoaXMuY2FjaGUuc2xpY2UoMTYpXG4gICAgdGhpcy5naGFzaChjaHVuaylcbiAgfVxufVxuR0hBU0gucHJvdG90eXBlLmZpbmFsID0gZnVuY3Rpb24gKGFibCwgYmwpIHtcbiAgaWYgKHRoaXMuY2FjaGUubGVuZ3RoKSB7XG4gICAgdGhpcy5naGFzaChCdWZmZXIuY29uY2F0KFt0aGlzLmNhY2hlLCB6ZXJvc10sIDE2KSlcbiAgfVxuICB0aGlzLmdoYXNoKGZyb21BcnJheShbXG4gICAgMCwgYWJsLFxuICAgIDAsIGJsXG4gIF0pKVxuICByZXR1cm4gdGhpcy5zdGF0ZVxufVxuXG5mdW5jdGlvbiB0b0FycmF5IChidWYpIHtcbiAgcmV0dXJuIFtcbiAgICBidWYucmVhZFVJbnQzMkJFKDApLFxuICAgIGJ1Zi5yZWFkVUludDMyQkUoNCksXG4gICAgYnVmLnJlYWRVSW50MzJCRSg4KSxcbiAgICBidWYucmVhZFVJbnQzMkJFKDEyKVxuICBdXG59XG5mdW5jdGlvbiBmcm9tQXJyYXkgKG91dCkge1xuICBvdXQgPSBvdXQubWFwKGZpeHVwX3VpbnQzMilcbiAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIoMTYpXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKG91dFswXSwgMClcbiAgYnVmLndyaXRlVUludDMyQkUob3V0WzFdLCA0KVxuICBidWYud3JpdGVVSW50MzJCRShvdXRbMl0sIDgpXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKG91dFszXSwgMTIpXG4gIHJldHVybiBidWZcbn1cbnZhciB1aW50X21heCA9IE1hdGgucG93KDIsIDMyKVxuZnVuY3Rpb24gZml4dXBfdWludDMyICh4KSB7XG4gIHZhciByZXQsIHhfcG9zXG4gIHJldCA9IHggPiB1aW50X21heCB8fCB4IDwgMCA/ICh4X3BvcyA9IE1hdGguYWJzKHgpICUgdWludF9tYXgsIHggPCAwID8gdWludF9tYXggLSB4X3BvcyA6IHhfcG9zKSA6IHhcbiAgcmV0dXJuIHJldFxufVxuZnVuY3Rpb24geG9yIChhLCBiKSB7XG4gIHJldHVybiBbXG4gICAgYVswXSBeIGJbMF0sXG4gICAgYVsxXSBeIGJbMV0sXG4gICAgYVsyXSBeIGJbMl0sXG4gICAgYVszXSBeIGJbM11cbiAgXVxufVxuIiwidmFyIHhvciA9IHJlcXVpcmUoJ2J1ZmZlci14b3InKVxuXG5leHBvcnRzLmVuY3J5cHQgPSBmdW5jdGlvbiAoc2VsZiwgZGF0YSwgZGVjcnlwdCkge1xuICB2YXIgb3V0ID0gbmV3IEJ1ZmZlcignJylcbiAgdmFyIGxlblxuXG4gIHdoaWxlIChkYXRhLmxlbmd0aCkge1xuICAgIGlmIChzZWxmLl9jYWNoZS5sZW5ndGggPT09IDApIHtcbiAgICAgIHNlbGYuX2NhY2hlID0gc2VsZi5fY2lwaGVyLmVuY3J5cHRCbG9jayhzZWxmLl9wcmV2KVxuICAgICAgc2VsZi5fcHJldiA9IG5ldyBCdWZmZXIoJycpXG4gICAgfVxuXG4gICAgaWYgKHNlbGYuX2NhY2hlLmxlbmd0aCA8PSBkYXRhLmxlbmd0aCkge1xuICAgICAgbGVuID0gc2VsZi5fY2FjaGUubGVuZ3RoXG4gICAgICBvdXQgPSBCdWZmZXIuY29uY2F0KFtvdXQsIGVuY3J5cHRTdGFydChzZWxmLCBkYXRhLnNsaWNlKDAsIGxlbiksIGRlY3J5cHQpXSlcbiAgICAgIGRhdGEgPSBkYXRhLnNsaWNlKGxlbilcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ID0gQnVmZmVyLmNvbmNhdChbb3V0LCBlbmNyeXB0U3RhcnQoc2VsZiwgZGF0YSwgZGVjcnlwdCldKVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb3V0XG59XG5mdW5jdGlvbiBlbmNyeXB0U3RhcnQgKHNlbGYsIGRhdGEsIGRlY3J5cHQpIHtcbiAgdmFyIGxlbiA9IGRhdGEubGVuZ3RoXG4gIHZhciBvdXQgPSB4b3IoZGF0YSwgc2VsZi5fY2FjaGUpXG4gIHNlbGYuX2NhY2hlID0gc2VsZi5fY2FjaGUuc2xpY2UobGVuKVxuICBzZWxmLl9wcmV2ID0gQnVmZmVyLmNvbmNhdChbc2VsZi5fcHJldiwgZGVjcnlwdCA/IGRhdGEgOiBvdXRdKVxuICByZXR1cm4gb3V0XG59XG4iLCJmdW5jdGlvbiBlbmNyeXB0Qnl0ZSAoc2VsZiwgYnl0ZVBhcmFtLCBkZWNyeXB0KSB7XG4gIHZhciBwYWRcbiAgdmFyIGkgPSAtMVxuICB2YXIgbGVuID0gOFxuICB2YXIgb3V0ID0gMFxuICB2YXIgYml0LCB2YWx1ZVxuICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgcGFkID0gc2VsZi5fY2lwaGVyLmVuY3J5cHRCbG9jayhzZWxmLl9wcmV2KVxuICAgIGJpdCA9IChieXRlUGFyYW0gJiAoMSA8PCAoNyAtIGkpKSkgPyAweDgwIDogMFxuICAgIHZhbHVlID0gcGFkWzBdIF4gYml0XG4gICAgb3V0ICs9ICgodmFsdWUgJiAweDgwKSA+PiAoaSAlIDgpKVxuICAgIHNlbGYuX3ByZXYgPSBzaGlmdEluKHNlbGYuX3ByZXYsIGRlY3J5cHQgPyBiaXQgOiB2YWx1ZSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5leHBvcnRzLmVuY3J5cHQgPSBmdW5jdGlvbiAoc2VsZiwgY2h1bmssIGRlY3J5cHQpIHtcbiAgdmFyIGxlbiA9IGNodW5rLmxlbmd0aFxuICB2YXIgb3V0ID0gbmV3IEJ1ZmZlcihsZW4pXG4gIHZhciBpID0gLTFcbiAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgIG91dFtpXSA9IGVuY3J5cHRCeXRlKHNlbGYsIGNodW5rW2ldLCBkZWNyeXB0KVxuICB9XG4gIHJldHVybiBvdXRcbn1cbmZ1bmN0aW9uIHNoaWZ0SW4gKGJ1ZmZlciwgdmFsdWUpIHtcbiAgdmFyIGxlbiA9IGJ1ZmZlci5sZW5ndGhcbiAgdmFyIGkgPSAtMVxuICB2YXIgb3V0ID0gbmV3IEJ1ZmZlcihidWZmZXIubGVuZ3RoKVxuICBidWZmZXIgPSBCdWZmZXIuY29uY2F0KFtidWZmZXIsIG5ldyBCdWZmZXIoW3ZhbHVlXSldKVxuICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgb3V0W2ldID0gYnVmZmVyW2ldIDw8IDEgfCBidWZmZXJbaSArIDFdID4+ICg3KVxuICB9XG4gIHJldHVybiBvdXRcbn1cbiIsImZ1bmN0aW9uIGVuY3J5cHRCeXRlIChzZWxmLCBieXRlUGFyYW0sIGRlY3J5cHQpIHtcbiAgdmFyIHBhZCA9IHNlbGYuX2NpcGhlci5lbmNyeXB0QmxvY2soc2VsZi5fcHJldilcbiAgdmFyIG91dCA9IHBhZFswXSBeIGJ5dGVQYXJhbVxuICBzZWxmLl9wcmV2ID0gQnVmZmVyLmNvbmNhdChbc2VsZi5fcHJldi5zbGljZSgxKSwgbmV3IEJ1ZmZlcihbZGVjcnlwdCA/IGJ5dGVQYXJhbSA6IG91dF0pXSlcbiAgcmV0dXJuIG91dFxufVxuZXhwb3J0cy5lbmNyeXB0ID0gZnVuY3Rpb24gKHNlbGYsIGNodW5rLCBkZWNyeXB0KSB7XG4gIHZhciBsZW4gPSBjaHVuay5sZW5ndGhcbiAgdmFyIG91dCA9IG5ldyBCdWZmZXIobGVuKVxuICB2YXIgaSA9IC0xXG4gIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICBvdXRbaV0gPSBlbmNyeXB0Qnl0ZShzZWxmLCBjaHVua1tpXSwgZGVjcnlwdClcbiAgfVxuICByZXR1cm4gb3V0XG59XG4iLCJ2YXIgeG9yID0gcmVxdWlyZSgnYnVmZmVyLXhvcicpXG5cbmZ1bmN0aW9uIGluY3IzMiAoaXYpIHtcbiAgdmFyIGxlbiA9IGl2Lmxlbmd0aFxuICB2YXIgaXRlbVxuICB3aGlsZSAobGVuLS0pIHtcbiAgICBpdGVtID0gaXYucmVhZFVJbnQ4KGxlbilcbiAgICBpZiAoaXRlbSA9PT0gMjU1KSB7XG4gICAgICBpdi53cml0ZVVJbnQ4KDAsIGxlbilcbiAgICB9IGVsc2Uge1xuICAgICAgaXRlbSsrXG4gICAgICBpdi53cml0ZVVJbnQ4KGl0ZW0sIGxlbilcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldEJsb2NrIChzZWxmKSB7XG4gIHZhciBvdXQgPSBzZWxmLl9jaXBoZXIuZW5jcnlwdEJsb2NrKHNlbGYuX3ByZXYpXG4gIGluY3IzMihzZWxmLl9wcmV2KVxuICByZXR1cm4gb3V0XG59XG5cbmV4cG9ydHMuZW5jcnlwdCA9IGZ1bmN0aW9uIChzZWxmLCBjaHVuaykge1xuICB3aGlsZSAoc2VsZi5fY2FjaGUubGVuZ3RoIDwgY2h1bmsubGVuZ3RoKSB7XG4gICAgc2VsZi5fY2FjaGUgPSBCdWZmZXIuY29uY2F0KFtzZWxmLl9jYWNoZSwgZ2V0QmxvY2soc2VsZildKVxuICB9XG4gIHZhciBwYWQgPSBzZWxmLl9jYWNoZS5zbGljZSgwLCBjaHVuay5sZW5ndGgpXG4gIHNlbGYuX2NhY2hlID0gc2VsZi5fY2FjaGUuc2xpY2UoY2h1bmsubGVuZ3RoKVxuICByZXR1cm4geG9yKGNodW5rLCBwYWQpXG59XG4iLCJ2YXIgeG9yID0gcmVxdWlyZSgnYnVmZmVyLXhvcicpXG5cbmZ1bmN0aW9uIGdldEJsb2NrIChzZWxmKSB7XG4gIHNlbGYuX3ByZXYgPSBzZWxmLl9jaXBoZXIuZW5jcnlwdEJsb2NrKHNlbGYuX3ByZXYpXG4gIHJldHVybiBzZWxmLl9wcmV2XG59XG5cbmV4cG9ydHMuZW5jcnlwdCA9IGZ1bmN0aW9uIChzZWxmLCBjaHVuaykge1xuICB3aGlsZSAoc2VsZi5fY2FjaGUubGVuZ3RoIDwgY2h1bmsubGVuZ3RoKSB7XG4gICAgc2VsZi5fY2FjaGUgPSBCdWZmZXIuY29uY2F0KFtzZWxmLl9jYWNoZSwgZ2V0QmxvY2soc2VsZildKVxuICB9XG5cbiAgdmFyIHBhZCA9IHNlbGYuX2NhY2hlLnNsaWNlKDAsIGNodW5rLmxlbmd0aClcbiAgc2VsZi5fY2FjaGUgPSBzZWxmLl9jYWNoZS5zbGljZShjaHVuay5sZW5ndGgpXG4gIHJldHVybiB4b3IoY2h1bmssIHBhZClcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24geG9yIChhLCBiKSB7XG4gIHZhciBsZW5ndGggPSBNYXRoLm1pbihhLmxlbmd0aCwgYi5sZW5ndGgpXG4gIHZhciBidWZmZXIgPSBuZXcgQnVmZmVyKGxlbmd0aClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgYnVmZmVyW2ldID0gYVtpXSBeIGJbaV1cbiAgfVxuXG4gIHJldHVybiBidWZmZXJcbn1cbiIsInZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCdzdHJlYW0nKS5UcmFuc2Zvcm1cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXInKS5TdHJpbmdEZWNvZGVyXG5tb2R1bGUuZXhwb3J0cyA9IENpcGhlckJhc2VcbmluaGVyaXRzKENpcGhlckJhc2UsIFRyYW5zZm9ybSlcbmZ1bmN0aW9uIENpcGhlckJhc2UgKGhhc2hNb2RlKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMpXG4gIHRoaXMuaGFzaE1vZGUgPSB0eXBlb2YgaGFzaE1vZGUgPT09ICdzdHJpbmcnXG4gIGlmICh0aGlzLmhhc2hNb2RlKSB7XG4gICAgdGhpc1toYXNoTW9kZV0gPSB0aGlzLl9maW5hbE9yRGlnZXN0XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5maW5hbCA9IHRoaXMuX2ZpbmFsT3JEaWdlc3RcbiAgfVxuICB0aGlzLl9kZWNvZGVyID0gbnVsbFxuICB0aGlzLl9lbmNvZGluZyA9IG51bGxcbn1cbkNpcGhlckJhc2UucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhLCBpbnB1dEVuYywgb3V0cHV0RW5jKSB7XG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICBkYXRhID0gbmV3IEJ1ZmZlcihkYXRhLCBpbnB1dEVuYylcbiAgfVxuICB2YXIgb3V0RGF0YSA9IHRoaXMuX3VwZGF0ZShkYXRhKVxuICBpZiAodGhpcy5oYXNoTW9kZSkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cbiAgaWYgKG91dHB1dEVuYykge1xuICAgIG91dERhdGEgPSB0aGlzLl90b1N0cmluZyhvdXREYXRhLCBvdXRwdXRFbmMpXG4gIH1cbiAgcmV0dXJuIG91dERhdGFcbn1cblxuQ2lwaGVyQmFzZS5wcm90b3R5cGUuc2V0QXV0b1BhZGRpbmcgPSBmdW5jdGlvbiAoKSB7fVxuXG5DaXBoZXJCYXNlLnByb3RvdHlwZS5nZXRBdXRoVGFnID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ3RyeWluZyB0byBnZXQgYXV0aCB0YWcgaW4gdW5zdXBwb3J0ZWQgc3RhdGUnKVxufVxuXG5DaXBoZXJCYXNlLnByb3RvdHlwZS5zZXRBdXRoVGFnID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ3RyeWluZyB0byBzZXQgYXV0aCB0YWcgaW4gdW5zdXBwb3J0ZWQgc3RhdGUnKVxufVxuXG5DaXBoZXJCYXNlLnByb3RvdHlwZS5zZXRBQUQgPSBmdW5jdGlvbiAoKSB7XG4gIHRocm93IG5ldyBFcnJvcigndHJ5aW5nIHRvIHNldCBhYWQgaW4gdW5zdXBwb3J0ZWQgc3RhdGUnKVxufVxuXG5DaXBoZXJCYXNlLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGRhdGEsIF8sIG5leHQpIHtcbiAgdmFyIGVyclxuICB0cnkge1xuICAgIGlmICh0aGlzLmhhc2hNb2RlKSB7XG4gICAgICB0aGlzLl91cGRhdGUoZGF0YSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wdXNoKHRoaXMuX3VwZGF0ZShkYXRhKSlcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBlcnIgPSBlXG4gIH0gZmluYWxseSB7XG4gICAgbmV4dChlcnIpXG4gIH1cbn1cbkNpcGhlckJhc2UucHJvdG90eXBlLl9mbHVzaCA9IGZ1bmN0aW9uIChkb25lKSB7XG4gIHZhciBlcnJcbiAgdHJ5IHtcbiAgICB0aGlzLnB1c2godGhpcy5fZmluYWwoKSlcbiAgfSBjYXRjaCAoZSkge1xuICAgIGVyciA9IGVcbiAgfSBmaW5hbGx5IHtcbiAgICBkb25lKGVycilcbiAgfVxufVxuQ2lwaGVyQmFzZS5wcm90b3R5cGUuX2ZpbmFsT3JEaWdlc3QgPSBmdW5jdGlvbiAob3V0cHV0RW5jKSB7XG4gIHZhciBvdXREYXRhID0gdGhpcy5fZmluYWwoKSB8fCBuZXcgQnVmZmVyKCcnKVxuICBpZiAob3V0cHV0RW5jKSB7XG4gICAgb3V0RGF0YSA9IHRoaXMuX3RvU3RyaW5nKG91dERhdGEsIG91dHB1dEVuYywgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb3V0RGF0YVxufVxuXG5DaXBoZXJCYXNlLnByb3RvdHlwZS5fdG9TdHJpbmcgPSBmdW5jdGlvbiAodmFsdWUsIGVuYywgZmluYWwpIHtcbiAgaWYgKCF0aGlzLl9kZWNvZGVyKSB7XG4gICAgdGhpcy5fZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKGVuYylcbiAgICB0aGlzLl9lbmNvZGluZyA9IGVuY1xuICB9XG4gIGlmICh0aGlzLl9lbmNvZGluZyAhPT0gZW5jKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjYW5cXCd0IHN3aXRjaCBlbmNvZGluZ3MnKVxuICB9XG4gIHZhciBvdXQgPSB0aGlzLl9kZWNvZGVyLndyaXRlKHZhbHVlKVxuICBpZiAoZmluYWwpIHtcbiAgICBvdXQgKz0gdGhpcy5fZGVjb2Rlci5lbmQoKVxuICB9XG4gIHJldHVybiBvdXRcbn1cbiIsInZhciBhZXMgPSByZXF1aXJlKCcuL2FlcycpXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnY2lwaGVyLWJhc2UnKVxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuXG5pbmhlcml0cyhTdHJlYW1DaXBoZXIsIFRyYW5zZm9ybSlcbm1vZHVsZS5leHBvcnRzID0gU3RyZWFtQ2lwaGVyXG5mdW5jdGlvbiBTdHJlYW1DaXBoZXIgKG1vZGUsIGtleSwgaXYsIGRlY3J5cHQpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFN0cmVhbUNpcGhlcikpIHtcbiAgICByZXR1cm4gbmV3IFN0cmVhbUNpcGhlcihtb2RlLCBrZXksIGl2KVxuICB9XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMpXG4gIHRoaXMuX2NpcGhlciA9IG5ldyBhZXMuQUVTKGtleSlcbiAgdGhpcy5fcHJldiA9IG5ldyBCdWZmZXIoaXYubGVuZ3RoKVxuICB0aGlzLl9jYWNoZSA9IG5ldyBCdWZmZXIoJycpXG4gIHRoaXMuX3NlY0NhY2hlID0gbmV3IEJ1ZmZlcignJylcbiAgdGhpcy5fZGVjcnlwdCA9IGRlY3J5cHRcbiAgaXYuY29weSh0aGlzLl9wcmV2KVxuICB0aGlzLl9tb2RlID0gbW9kZVxufVxuU3RyZWFtQ2lwaGVyLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHJldHVybiB0aGlzLl9tb2RlLmVuY3J5cHQodGhpcywgY2h1bmssIHRoaXMuX2RlY3J5cHQpXG59XG5TdHJlYW1DaXBoZXIucHJvdG90eXBlLl9maW5hbCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fY2lwaGVyLnNjcnViKClcbn1cbiIsInZhciBtZDUgPSByZXF1aXJlKCdjcmVhdGUtaGFzaC9tZDUnKVxubW9kdWxlLmV4cG9ydHMgPSBFVlBfQnl0ZXNUb0tleVxuZnVuY3Rpb24gRVZQX0J5dGVzVG9LZXkgKHBhc3N3b3JkLCBzYWx0LCBrZXlMZW4sIGl2TGVuKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHBhc3N3b3JkKSkge1xuICAgIHBhc3N3b3JkID0gbmV3IEJ1ZmZlcihwYXNzd29yZCwgJ2JpbmFyeScpXG4gIH1cbiAgaWYgKHNhbHQgJiYgIUJ1ZmZlci5pc0J1ZmZlcihzYWx0KSkge1xuICAgIHNhbHQgPSBuZXcgQnVmZmVyKHNhbHQsICdiaW5hcnknKVxuICB9XG4gIGtleUxlbiA9IGtleUxlbiAvIDhcbiAgaXZMZW4gPSBpdkxlbiB8fCAwXG4gIHZhciBraSA9IDBcbiAgdmFyIGlpID0gMFxuICB2YXIga2V5ID0gbmV3IEJ1ZmZlcihrZXlMZW4pXG4gIHZhciBpdiA9IG5ldyBCdWZmZXIoaXZMZW4pXG4gIHZhciBhZGRtZCA9IDBcbiAgdmFyIG1kX2J1ZlxuICB2YXIgaVxuICB2YXIgYnVmcyA9IFtdXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKGFkZG1kKysgPiAwKSB7XG4gICAgICBidWZzLnB1c2gobWRfYnVmKVxuICAgIH1cbiAgICBidWZzLnB1c2gocGFzc3dvcmQpXG4gICAgaWYgKHNhbHQpIHtcbiAgICAgIGJ1ZnMucHVzaChzYWx0KVxuICAgIH1cbiAgICBtZF9idWYgPSBtZDUoQnVmZmVyLmNvbmNhdChidWZzKSlcbiAgICBidWZzID0gW11cbiAgICBpID0gMFxuICAgIGlmIChrZXlMZW4gPiAwKSB7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBpZiAoa2V5TGVuID09PSAwKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA9PT0gbWRfYnVmLmxlbmd0aCkge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAga2V5W2tpKytdID0gbWRfYnVmW2ldXG4gICAgICAgIGtleUxlbi0tXG4gICAgICAgIGkrK1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXZMZW4gPiAwICYmIGkgIT09IG1kX2J1Zi5sZW5ndGgpIHtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGlmIChpdkxlbiA9PT0gMCkge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPT09IG1kX2J1Zi5sZW5ndGgpIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGl2W2lpKytdID0gbWRfYnVmW2ldXG4gICAgICAgIGl2TGVuLS1cbiAgICAgICAgaSsrXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChrZXlMZW4gPT09IDAgJiYgaXZMZW4gPT09IDApIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG4gIGZvciAoaSA9IDA7IGkgPCBtZF9idWYubGVuZ3RoOyBpKyspIHtcbiAgICBtZF9idWZbaV0gPSAwXG4gIH1cbiAgcmV0dXJuIHtcbiAgICBrZXk6IGtleSxcbiAgICBpdjogaXZcbiAgfVxufVxuIiwiLy8gbXVjaCBvZiB0aGlzIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9pbmR1dG55L3NlbGYtc2lnbmVkL2Jsb2IvZ2gtcGFnZXMvbGliL3JzYS5qc1xudmFyIGNyZWF0ZUhtYWMgPSByZXF1aXJlKCdjcmVhdGUtaG1hYycpXG52YXIgY3J0ID0gcmVxdWlyZSgnYnJvd3NlcmlmeS1yc2EnKVxudmFyIGN1cnZlcyA9IHJlcXVpcmUoJy4vY3VydmVzJylcbnZhciBlbGxpcHRpYyA9IHJlcXVpcmUoJ2VsbGlwdGljJylcbnZhciBwYXJzZUtleXMgPSByZXF1aXJlKCdwYXJzZS1hc24xJylcblxudmFyIEJOID0gcmVxdWlyZSgnYm4uanMnKVxudmFyIEVDID0gZWxsaXB0aWMuZWNcblxuZnVuY3Rpb24gc2lnbiAoaGFzaCwga2V5LCBoYXNoVHlwZSwgc2lnblR5cGUpIHtcbiAgdmFyIHByaXYgPSBwYXJzZUtleXMoa2V5KVxuICBpZiAocHJpdi5jdXJ2ZSkge1xuICAgIGlmIChzaWduVHlwZSAhPT0gJ2VjZHNhJykgdGhyb3cgbmV3IEVycm9yKCd3cm9uZyBwcml2YXRlIGtleSB0eXBlJylcblxuICAgIHJldHVybiBlY1NpZ24oaGFzaCwgcHJpdilcbiAgfSBlbHNlIGlmIChwcml2LnR5cGUgPT09ICdkc2EnKSB7XG4gICAgaWYgKHNpZ25UeXBlICE9PSAnZHNhJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd3cm9uZyBwcml2YXRlIGtleSB0eXBlJylcbiAgICB9XG4gICAgcmV0dXJuIGRzYVNpZ24oaGFzaCwgcHJpdiwgaGFzaFR5cGUpXG4gIH0gZWxzZSB7XG4gICAgaWYgKHNpZ25UeXBlICE9PSAncnNhJykgdGhyb3cgbmV3IEVycm9yKCd3cm9uZyBwcml2YXRlIGtleSB0eXBlJylcbiAgfVxuXG4gIHZhciBsZW4gPSBwcml2Lm1vZHVsdXMuYnl0ZUxlbmd0aCgpXG4gIHZhciBwYWQgPSBbIDAsIDEgXVxuICB3aGlsZSAoaGFzaC5sZW5ndGggKyBwYWQubGVuZ3RoICsgMSA8IGxlbikge1xuICAgIHBhZC5wdXNoKDB4ZmYpXG4gIH1cbiAgcGFkLnB1c2goMHgwMClcbiAgdmFyIGkgPSAtMVxuICB3aGlsZSAoKytpIDwgaGFzaC5sZW5ndGgpIHtcbiAgICBwYWQucHVzaChoYXNoW2ldKVxuICB9XG5cbiAgdmFyIG91dCA9IGNydChwYWQsIHByaXYpXG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gZWNTaWduIChoYXNoLCBwcml2KSB7XG4gIHZhciBjdXJ2ZUlkID0gY3VydmVzW3ByaXYuY3VydmUuam9pbignLicpXVxuICBpZiAoIWN1cnZlSWQpIHRocm93IG5ldyBFcnJvcigndW5rbm93biBjdXJ2ZSAnICsgcHJpdi5jdXJ2ZS5qb2luKCcuJykpXG5cbiAgdmFyIGN1cnZlID0gbmV3IEVDKGN1cnZlSWQpXG4gIHZhciBrZXkgPSBjdXJ2ZS5nZW5LZXlQYWlyKClcblxuICBrZXkuX2ltcG9ydFByaXZhdGUocHJpdi5wcml2YXRlS2V5KVxuICB2YXIgb3V0ID0ga2V5LnNpZ24oaGFzaClcblxuICByZXR1cm4gbmV3IEJ1ZmZlcihvdXQudG9ERVIoKSlcbn1cblxuZnVuY3Rpb24gZHNhU2lnbiAoaGFzaCwgcHJpdiwgYWxnbykge1xuICB2YXIgeCA9IHByaXYucGFyYW1zLnByaXZfa2V5XG4gIHZhciBwID0gcHJpdi5wYXJhbXMucFxuICB2YXIgcSA9IHByaXYucGFyYW1zLnFcbiAgdmFyIGcgPSBwcml2LnBhcmFtcy5nXG4gIHZhciByID0gbmV3IEJOKDApXG4gIHZhciBrXG4gIHZhciBIID0gYml0czJpbnQoaGFzaCwgcSkubW9kKHEpXG4gIHZhciBzID0gZmFsc2VcbiAgdmFyIGt2ID0gZ2V0S2V5KHgsIHEsIGhhc2gsIGFsZ28pXG4gIHdoaWxlIChzID09PSBmYWxzZSkge1xuICAgIGsgPSBtYWtlS2V5KHEsIGt2LCBhbGdvKVxuICAgIHIgPSBtYWtlUihnLCBrLCBwLCBxKVxuICAgIHMgPSBrLmludm0ocSkuaW11bChILmFkZCh4Lm11bChyKSkpLm1vZChxKVxuICAgIGlmICghcy5jbXBuKDApKSB7XG4gICAgICBzID0gZmFsc2VcbiAgICAgIHIgPSBuZXcgQk4oMClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRvREVSKHIsIHMpXG59XG5cbmZ1bmN0aW9uIHRvREVSIChyLCBzKSB7XG4gIHIgPSByLnRvQXJyYXkoKVxuICBzID0gcy50b0FycmF5KClcblxuICAvLyBQYWQgdmFsdWVzXG4gIGlmIChyWzBdICYgMHg4MCkge1xuICAgIHIgPSBbIDAgXS5jb25jYXQocilcbiAgfVxuICAvLyBQYWQgdmFsdWVzXG4gIGlmIChzWzBdICYgMHg4MCkge1xuICAgIHMgPSBbMF0uY29uY2F0KHMpXG4gIH1cblxuICB2YXIgdG90YWwgPSByLmxlbmd0aCArIHMubGVuZ3RoICsgNFxuICB2YXIgcmVzID0gWyAweDMwLCB0b3RhbCwgMHgwMiwgci5sZW5ndGggXVxuICByZXMgPSByZXMuY29uY2F0KHIsIFsgMHgwMiwgcy5sZW5ndGggXSwgcylcbiAgcmV0dXJuIG5ldyBCdWZmZXIocmVzKVxufVxuXG5mdW5jdGlvbiBnZXRLZXkgKHgsIHEsIGhhc2gsIGFsZ28pIHtcbiAgeCA9IG5ldyBCdWZmZXIoeC50b0FycmF5KCkpXG4gIGlmICh4Lmxlbmd0aCA8IHEuYnl0ZUxlbmd0aCgpKSB7XG4gICAgdmFyIHplcm9zID0gbmV3IEJ1ZmZlcihxLmJ5dGVMZW5ndGgoKSAtIHgubGVuZ3RoKVxuICAgIHplcm9zLmZpbGwoMClcbiAgICB4ID0gQnVmZmVyLmNvbmNhdChbemVyb3MsIHhdKVxuICB9XG4gIHZhciBobGVuID0gaGFzaC5sZW5ndGhcbiAgdmFyIGhiaXRzID0gYml0czJvY3RldHMoaGFzaCwgcSlcbiAgdmFyIHYgPSBuZXcgQnVmZmVyKGhsZW4pXG4gIHYuZmlsbCgxKVxuICB2YXIgayA9IG5ldyBCdWZmZXIoaGxlbilcbiAgay5maWxsKDApXG4gIGsgPSBjcmVhdGVIbWFjKGFsZ28sIGspXG4gICAgLnVwZGF0ZSh2KVxuICAgIC51cGRhdGUobmV3IEJ1ZmZlcihbMF0pKVxuICAgIC51cGRhdGUoeClcbiAgICAudXBkYXRlKGhiaXRzKVxuICAgIC5kaWdlc3QoKVxuICB2ID0gY3JlYXRlSG1hYyhhbGdvLCBrKVxuICAgIC51cGRhdGUodilcbiAgICAuZGlnZXN0KClcbiAgayA9IGNyZWF0ZUhtYWMoYWxnbywgaylcbiAgICAudXBkYXRlKHYpXG4gICAgLnVwZGF0ZShuZXcgQnVmZmVyKFsxXSkpXG4gICAgLnVwZGF0ZSh4KVxuICAgIC51cGRhdGUoaGJpdHMpXG4gICAgLmRpZ2VzdCgpXG4gIHYgPSBjcmVhdGVIbWFjKGFsZ28sIGspXG4gICAgLnVwZGF0ZSh2KVxuICAgIC5kaWdlc3QoKVxuICByZXR1cm4ge1xuICAgIGs6IGssXG4gICAgdjogdlxuICB9XG59XG5cbmZ1bmN0aW9uIGJpdHMyaW50IChvYml0cywgcSkge1xuICB2YXIgYml0cyA9IG5ldyBCTihvYml0cylcbiAgdmFyIHNoaWZ0ID0gKG9iaXRzLmxlbmd0aCA8PCAzKSAtIHEuYml0TGVuZ3RoKClcbiAgaWYgKHNoaWZ0ID4gMCkge1xuICAgIGJpdHMuaXNocm4oc2hpZnQpXG4gIH1cbiAgcmV0dXJuIGJpdHNcbn1cblxuZnVuY3Rpb24gYml0czJvY3RldHMgKGJpdHMsIHEpIHtcbiAgYml0cyA9IGJpdHMyaW50KGJpdHMsIHEpXG4gIGJpdHMgPSBiaXRzLm1vZChxKVxuICB2YXIgb3V0ID0gbmV3IEJ1ZmZlcihiaXRzLnRvQXJyYXkoKSlcbiAgaWYgKG91dC5sZW5ndGggPCBxLmJ5dGVMZW5ndGgoKSkge1xuICAgIHZhciB6ZXJvcyA9IG5ldyBCdWZmZXIocS5ieXRlTGVuZ3RoKCkgLSBvdXQubGVuZ3RoKVxuICAgIHplcm9zLmZpbGwoMClcbiAgICBvdXQgPSBCdWZmZXIuY29uY2F0KFt6ZXJvcywgb3V0XSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIG1ha2VLZXkgKHEsIGt2LCBhbGdvKSB7XG4gIHZhciB0LCBrXG5cbiAgZG8ge1xuICAgIHQgPSBuZXcgQnVmZmVyKCcnKVxuXG4gICAgd2hpbGUgKHQubGVuZ3RoICogOCA8IHEuYml0TGVuZ3RoKCkpIHtcbiAgICAgIGt2LnYgPSBjcmVhdGVIbWFjKGFsZ28sIGt2LmspXG4gICAgICAgIC51cGRhdGUoa3YudilcbiAgICAgICAgLmRpZ2VzdCgpXG4gICAgICB0ID0gQnVmZmVyLmNvbmNhdChbdCwga3Yudl0pXG4gICAgfVxuXG4gICAgayA9IGJpdHMyaW50KHQsIHEpXG4gICAga3YuayA9IGNyZWF0ZUhtYWMoYWxnbywga3YuaylcbiAgICAgIC51cGRhdGUoa3YudilcbiAgICAgIC51cGRhdGUobmV3IEJ1ZmZlcihbMF0pKVxuICAgICAgLmRpZ2VzdCgpXG4gICAga3YudiA9IGNyZWF0ZUhtYWMoYWxnbywga3YuaylcbiAgICAgIC51cGRhdGUoa3YudilcbiAgICAgIC5kaWdlc3QoKVxuICB9IHdoaWxlIChrLmNtcChxKSAhPT0gLTEpXG5cbiAgcmV0dXJuIGtcbn1cblxuZnVuY3Rpb24gbWFrZVIgKGcsIGssIHAsIHEpIHtcbiAgcmV0dXJuIGcudG9SZWQoQk4ubW9udChwKSkucmVkUG93KGspLmZyb21SZWQoKS5tb2QocSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaWduXG5tb2R1bGUuZXhwb3J0cy5nZXRLZXkgPSBnZXRLZXlcbm1vZHVsZS5leHBvcnRzLm1ha2VLZXkgPSBtYWtlS2V5XG4iLCIvLyBtdWNoIG9mIHRoaXMgYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvc2VsZi1zaWduZWQvYmxvYi9naC1wYWdlcy9saWIvcnNhLmpzXG52YXIgY3VydmVzID0gcmVxdWlyZSgnLi9jdXJ2ZXMnKVxudmFyIGVsbGlwdGljID0gcmVxdWlyZSgnZWxsaXB0aWMnKVxudmFyIHBhcnNlS2V5cyA9IHJlcXVpcmUoJ3BhcnNlLWFzbjEnKVxuXG52YXIgQk4gPSByZXF1aXJlKCdibi5qcycpXG52YXIgRUMgPSBlbGxpcHRpYy5lY1xuXG5mdW5jdGlvbiB2ZXJpZnkgKHNpZywgaGFzaCwga2V5LCBzaWduVHlwZSkge1xuICB2YXIgcHViID0gcGFyc2VLZXlzKGtleSlcbiAgaWYgKHB1Yi50eXBlID09PSAnZWMnKSB7XG4gICAgaWYgKHNpZ25UeXBlICE9PSAnZWNkc2EnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3dyb25nIHB1YmxpYyBrZXkgdHlwZScpXG4gICAgfVxuICAgIHJldHVybiBlY1ZlcmlmeShzaWcsIGhhc2gsIHB1YilcbiAgfSBlbHNlIGlmIChwdWIudHlwZSA9PT0gJ2RzYScpIHtcbiAgICBpZiAoc2lnblR5cGUgIT09ICdkc2EnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3dyb25nIHB1YmxpYyBrZXkgdHlwZScpXG4gICAgfVxuICAgIHJldHVybiBkc2FWZXJpZnkoc2lnLCBoYXNoLCBwdWIpXG4gIH0gZWxzZSB7XG4gICAgaWYgKHNpZ25UeXBlICE9PSAncnNhJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd3cm9uZyBwdWJsaWMga2V5IHR5cGUnKVxuICAgIH1cbiAgfVxuICB2YXIgbGVuID0gcHViLm1vZHVsdXMuYnl0ZUxlbmd0aCgpXG4gIHZhciBwYWQgPSBbIDEgXVxuICB2YXIgcGFkTnVtID0gMFxuICB3aGlsZSAoaGFzaC5sZW5ndGggKyBwYWQubGVuZ3RoICsgMiA8IGxlbikge1xuICAgIHBhZC5wdXNoKDB4ZmYpXG4gICAgcGFkTnVtKytcbiAgfVxuICBwYWQucHVzaCgweDAwKVxuICB2YXIgaSA9IC0xXG4gIHdoaWxlICgrK2kgPCBoYXNoLmxlbmd0aCkge1xuICAgIHBhZC5wdXNoKGhhc2hbaV0pXG4gIH1cbiAgcGFkID0gbmV3IEJ1ZmZlcihwYWQpXG4gIHZhciByZWQgPSBCTi5tb250KHB1Yi5tb2R1bHVzKVxuICBzaWcgPSBuZXcgQk4oc2lnKS50b1JlZChyZWQpXG5cbiAgc2lnID0gc2lnLnJlZFBvdyhuZXcgQk4ocHViLnB1YmxpY0V4cG9uZW50KSlcblxuICBzaWcgPSBuZXcgQnVmZmVyKHNpZy5mcm9tUmVkKCkudG9BcnJheSgpKVxuICB2YXIgb3V0ID0gMFxuICBpZiAocGFkTnVtIDwgOCkge1xuICAgIG91dCA9IDFcbiAgfVxuICBsZW4gPSBNYXRoLm1pbihzaWcubGVuZ3RoLCBwYWQubGVuZ3RoKVxuICBpZiAoc2lnLmxlbmd0aCAhPT0gcGFkLmxlbmd0aCkge1xuICAgIG91dCA9IDFcbiAgfVxuXG4gIGkgPSAtMVxuICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgb3V0IHw9IChzaWdbaV0gXiBwYWRbaV0pXG4gIH1cbiAgcmV0dXJuIG91dCA9PT0gMFxufVxuXG5mdW5jdGlvbiBlY1ZlcmlmeSAoc2lnLCBoYXNoLCBwdWIpIHtcbiAgdmFyIGN1cnZlSWQgPSBjdXJ2ZXNbcHViLmRhdGEuYWxnb3JpdGhtLmN1cnZlLmpvaW4oJy4nKV1cbiAgaWYgKCFjdXJ2ZUlkKSB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gY3VydmUgJyArIHB1Yi5kYXRhLmFsZ29yaXRobS5jdXJ2ZS5qb2luKCcuJykpXG5cbiAgdmFyIGN1cnZlID0gbmV3IEVDKGN1cnZlSWQpXG4gIHZhciBwdWJrZXkgPSBwdWIuZGF0YS5zdWJqZWN0UHJpdmF0ZUtleS5kYXRhXG5cbiAgcmV0dXJuIGN1cnZlLnZlcmlmeShoYXNoLCBzaWcsIHB1YmtleSlcbn1cblxuZnVuY3Rpb24gZHNhVmVyaWZ5IChzaWcsIGhhc2gsIHB1Yikge1xuICB2YXIgcCA9IHB1Yi5kYXRhLnBcbiAgdmFyIHEgPSBwdWIuZGF0YS5xXG4gIHZhciBnID0gcHViLmRhdGEuZ1xuICB2YXIgeSA9IHB1Yi5kYXRhLnB1Yl9rZXlcbiAgdmFyIHVucGFja2VkID0gcGFyc2VLZXlzLnNpZ25hdHVyZS5kZWNvZGUoc2lnLCAnZGVyJylcbiAgdmFyIHMgPSB1bnBhY2tlZC5zXG4gIHZhciByID0gdW5wYWNrZWQuclxuICBjaGVja1ZhbHVlKHMsIHEpXG4gIGNoZWNrVmFsdWUociwgcSlcbiAgdmFyIG1vbnRwID0gQk4ubW9udChwKVxuICB2YXIgdyA9IHMuaW52bShxKVxuICB2YXIgdiA9IGcudG9SZWQobW9udHApXG4gICAgLnJlZFBvdyhuZXcgQk4oaGFzaCkubXVsKHcpLm1vZChxKSlcbiAgICAuZnJvbVJlZCgpXG4gICAgLm11bChcbiAgICAgIHkudG9SZWQobW9udHApXG4gICAgICAgIC5yZWRQb3coci5tdWwodykubW9kKHEpKVxuICAgICAgICAuZnJvbVJlZCgpXG4gICkubW9kKHApLm1vZChxKVxuICByZXR1cm4gIXYuY21wKHIpXG59XG5cbmZ1bmN0aW9uIGNoZWNrVmFsdWUgKGIsIHEpIHtcbiAgaWYgKGIuY21wbigwKSA8PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHNpZycpXG4gIH1cbiAgaWYgKGIuY21wKHEpID49IHEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc2lnJylcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHZlcmlmeVxuIiwidmFyIGVsbGlwdGljID0gcmVxdWlyZSgnZWxsaXB0aWMnKTtcbnZhciBCTiA9IHJlcXVpcmUoJ2JuLmpzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlRUNESChjdXJ2ZSkge1xuXHRyZXR1cm4gbmV3IEVDREgoY3VydmUpO1xufTtcblxudmFyIGFsaWFzZXMgPSB7XG5cdHNlY3AyNTZrMToge1xuXHRcdG5hbWU6ICdzZWNwMjU2azEnLFxuXHRcdGJ5dGVMZW5ndGg6IDMyXG5cdH0sXG5cdHNlY3AyMjRyMToge1xuXHRcdG5hbWU6ICdwMjI0Jyxcblx0XHRieXRlTGVuZ3RoOiAyOFxuXHR9LFxuXHRwcmltZTI1NnYxOiB7XG5cdFx0bmFtZTogJ3AyNTYnLFxuXHRcdGJ5dGVMZW5ndGg6IDMyXG5cdH0sXG5cdHByaW1lMTkydjE6IHtcblx0XHRuYW1lOiAncDE5MicsXG5cdFx0Ynl0ZUxlbmd0aDogMjRcblx0fSxcblx0ZWQyNTUxOToge1xuXHRcdG5hbWU6ICdlZDI1NTE5Jyxcblx0XHRieXRlTGVuZ3RoOiAzMlxuXHR9LFxuXHRzZWNwMzg0cjE6IHtcblx0XHRuYW1lOiAncDM4NCcsXG5cdFx0Ynl0ZUxlbmd0aDogNDhcblx0fSxcblx0c2VjcDUyMXIxOiB7XG5cdFx0bmFtZTogJ3A1MjEnLFxuXHRcdGJ5dGVMZW5ndGg6IDY2XG5cdH1cbn07XG5cbmFsaWFzZXMucDIyNCA9IGFsaWFzZXMuc2VjcDIyNHIxO1xuYWxpYXNlcy5wMjU2ID0gYWxpYXNlcy5zZWNwMjU2cjEgPSBhbGlhc2VzLnByaW1lMjU2djE7XG5hbGlhc2VzLnAxOTIgPSBhbGlhc2VzLnNlY3AxOTJyMSA9IGFsaWFzZXMucHJpbWUxOTJ2MTtcbmFsaWFzZXMucDM4NCA9IGFsaWFzZXMuc2VjcDM4NHIxO1xuYWxpYXNlcy5wNTIxID0gYWxpYXNlcy5zZWNwNTIxcjE7XG5cbmZ1bmN0aW9uIEVDREgoY3VydmUpIHtcblx0dGhpcy5jdXJ2ZVR5cGUgPSBhbGlhc2VzW2N1cnZlXTtcblx0aWYgKCF0aGlzLmN1cnZlVHlwZSApIHtcblx0XHR0aGlzLmN1cnZlVHlwZSA9IHtcblx0XHRcdG5hbWU6IGN1cnZlXG5cdFx0fTtcblx0fVxuXHR0aGlzLmN1cnZlID0gbmV3IGVsbGlwdGljLmVjKHRoaXMuY3VydmVUeXBlLm5hbWUpO1xuXHR0aGlzLmtleXMgPSB2b2lkIDA7XG59XG5cbkVDREgucHJvdG90eXBlLmdlbmVyYXRlS2V5cyA9IGZ1bmN0aW9uIChlbmMsIGZvcm1hdCkge1xuXHR0aGlzLmtleXMgPSB0aGlzLmN1cnZlLmdlbktleVBhaXIoKTtcblx0cmV0dXJuIHRoaXMuZ2V0UHVibGljS2V5KGVuYywgZm9ybWF0KTtcbn07XG5cbkVDREgucHJvdG90eXBlLmNvbXB1dGVTZWNyZXQgPSBmdW5jdGlvbiAob3RoZXIsIGluZW5jLCBlbmMpIHtcblx0aW5lbmMgPSBpbmVuYyB8fCAndXRmOCc7XG5cdGlmICghQnVmZmVyLmlzQnVmZmVyKG90aGVyKSkge1xuXHRcdG90aGVyID0gbmV3IEJ1ZmZlcihvdGhlciwgaW5lbmMpO1xuXHR9XG5cdHZhciBvdGhlclB1YiA9IHRoaXMuY3VydmUua2V5RnJvbVB1YmxpYyhvdGhlcikuZ2V0UHVibGljKCk7XG5cdHZhciBvdXQgPSBvdGhlclB1Yi5tdWwodGhpcy5rZXlzLmdldFByaXZhdGUoKSkuZ2V0WCgpO1xuXHRyZXR1cm4gZm9ybWF0UmV0dXJuVmFsdWUob3V0LCBlbmMsIHRoaXMuY3VydmVUeXBlLmJ5dGVMZW5ndGgpO1xufTtcblxuRUNESC5wcm90b3R5cGUuZ2V0UHVibGljS2V5ID0gZnVuY3Rpb24gKGVuYywgZm9ybWF0KSB7XG5cdHZhciBrZXkgPSB0aGlzLmtleXMuZ2V0UHVibGljKGZvcm1hdCA9PT0gJ2NvbXByZXNzZWQnLCB0cnVlKTtcblx0aWYgKGZvcm1hdCA9PT0gJ2h5YnJpZCcpIHtcblx0XHRpZiAoa2V5W2tleS5sZW5ndGggLSAxXSAlIDIpIHtcblx0XHRcdGtleVswXSA9IDc7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGtleSBbMF0gPSA2O1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gZm9ybWF0UmV0dXJuVmFsdWUoa2V5LCBlbmMpO1xufTtcblxuRUNESC5wcm90b3R5cGUuZ2V0UHJpdmF0ZUtleSA9IGZ1bmN0aW9uIChlbmMpIHtcblx0cmV0dXJuIGZvcm1hdFJldHVyblZhbHVlKHRoaXMua2V5cy5nZXRQcml2YXRlKCksIGVuYyk7XG59O1xuXG5FQ0RILnByb3RvdHlwZS5zZXRQdWJsaWNLZXkgPSBmdW5jdGlvbiAocHViLCBlbmMpIHtcblx0ZW5jID0gZW5jIHx8ICd1dGY4Jztcblx0aWYgKCFCdWZmZXIuaXNCdWZmZXIocHViKSkge1xuXHRcdHB1YiA9IG5ldyBCdWZmZXIocHViLCBlbmMpO1xuXHR9XG5cdHRoaXMua2V5cy5faW1wb3J0UHVibGljKHB1Yik7XG5cdHJldHVybiB0aGlzO1xufTtcblxuRUNESC5wcm90b3R5cGUuc2V0UHJpdmF0ZUtleSA9IGZ1bmN0aW9uIChwcml2LCBlbmMpIHtcblx0ZW5jID0gZW5jIHx8ICd1dGY4Jztcblx0aWYgKCFCdWZmZXIuaXNCdWZmZXIocHJpdikpIHtcblx0XHRwcml2ID0gbmV3IEJ1ZmZlcihwcml2LCBlbmMpO1xuXHR9XG5cdHZhciBfcHJpdiA9IG5ldyBCTihwcml2KTtcblx0X3ByaXYgPSBfcHJpdi50b1N0cmluZygxNik7XG5cdHRoaXMua2V5cy5faW1wb3J0UHJpdmF0ZShfcHJpdik7XG5cdHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gZm9ybWF0UmV0dXJuVmFsdWUoYm4sIGVuYywgbGVuKSB7XG5cdGlmICghQXJyYXkuaXNBcnJheShibikpIHtcblx0XHRibiA9IGJuLnRvQXJyYXkoKTtcblx0fVxuXHR2YXIgYnVmID0gbmV3IEJ1ZmZlcihibik7XG5cdGlmIChsZW4gJiYgYnVmLmxlbmd0aCA8IGxlbikge1xuXHRcdHZhciB6ZXJvcyA9IG5ldyBCdWZmZXIobGVuIC0gYnVmLmxlbmd0aCk7XG5cdFx0emVyb3MuZmlsbCgwKTtcblx0XHRidWYgPSBCdWZmZXIuY29uY2F0KFt6ZXJvcywgYnVmXSk7XG5cdH1cblx0aWYgKCFlbmMpIHtcblx0XHRyZXR1cm4gYnVmO1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBidWYudG9TdHJpbmcoZW5jKTtcblx0fVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIG1kNSA9IHJlcXVpcmUoJy4vbWQ1JylcbnZhciBybWQxNjAgPSByZXF1aXJlKCdyaXBlbWQxNjAnKVxudmFyIHNoYSA9IHJlcXVpcmUoJ3NoYS5qcycpXG5cbnZhciBCYXNlID0gcmVxdWlyZSgnY2lwaGVyLWJhc2UnKVxuXG5mdW5jdGlvbiBIYXNoTm9Db25zdHJ1Y3RvcihoYXNoKSB7XG4gIEJhc2UuY2FsbCh0aGlzLCAnZGlnZXN0JylcblxuICB0aGlzLl9oYXNoID0gaGFzaFxuICB0aGlzLmJ1ZmZlcnMgPSBbXVxufVxuXG5pbmhlcml0cyhIYXNoTm9Db25zdHJ1Y3RvciwgQmFzZSlcblxuSGFzaE5vQ29uc3RydWN0b3IucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB0aGlzLmJ1ZmZlcnMucHVzaChkYXRhKVxufVxuXG5IYXNoTm9Db25zdHJ1Y3Rvci5wcm90b3R5cGUuX2ZpbmFsID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYnVmID0gQnVmZmVyLmNvbmNhdCh0aGlzLmJ1ZmZlcnMpXG4gIHZhciByID0gdGhpcy5faGFzaChidWYpXG4gIHRoaXMuYnVmZmVycyA9IG51bGxcblxuICByZXR1cm4gclxufVxuXG5mdW5jdGlvbiBIYXNoKGhhc2gpIHtcbiAgQmFzZS5jYWxsKHRoaXMsICdkaWdlc3QnKVxuXG4gIHRoaXMuX2hhc2ggPSBoYXNoXG59XG5cbmluaGVyaXRzKEhhc2gsIEJhc2UpXG5cbkhhc2gucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB0aGlzLl9oYXNoLnVwZGF0ZShkYXRhKVxufVxuXG5IYXNoLnByb3RvdHlwZS5fZmluYWwgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9oYXNoLmRpZ2VzdCgpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlSGFzaCAoYWxnKSB7XG4gIGFsZyA9IGFsZy50b0xvd2VyQ2FzZSgpXG4gIGlmICgnbWQ1JyA9PT0gYWxnKSByZXR1cm4gbmV3IEhhc2hOb0NvbnN0cnVjdG9yKG1kNSlcbiAgaWYgKCdybWQxNjAnID09PSBhbGcgfHwgJ3JpcGVtZDE2MCcgPT09IGFsZykgcmV0dXJuIG5ldyBIYXNoTm9Db25zdHJ1Y3RvcihybWQxNjApXG5cbiAgcmV0dXJuIG5ldyBIYXNoKHNoYShhbGcpKVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGludFNpemUgPSA0O1xudmFyIHplcm9CdWZmZXIgPSBuZXcgQnVmZmVyKGludFNpemUpOyB6ZXJvQnVmZmVyLmZpbGwoMCk7XG52YXIgY2hyc3ogPSA4O1xuXG5mdW5jdGlvbiB0b0FycmF5KGJ1ZiwgYmlnRW5kaWFuKSB7XG4gIGlmICgoYnVmLmxlbmd0aCAlIGludFNpemUpICE9PSAwKSB7XG4gICAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGggKyAoaW50U2l6ZSAtIChidWYubGVuZ3RoICUgaW50U2l6ZSkpO1xuICAgIGJ1ZiA9IEJ1ZmZlci5jb25jYXQoW2J1ZiwgemVyb0J1ZmZlcl0sIGxlbik7XG4gIH1cblxuICB2YXIgYXJyID0gW107XG4gIHZhciBmbiA9IGJpZ0VuZGlhbiA/IGJ1Zi5yZWFkSW50MzJCRSA6IGJ1Zi5yZWFkSW50MzJMRTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWYubGVuZ3RoOyBpICs9IGludFNpemUpIHtcbiAgICBhcnIucHVzaChmbi5jYWxsKGJ1ZiwgaSkpO1xuICB9XG4gIHJldHVybiBhcnI7XG59XG5cbmZ1bmN0aW9uIHRvQnVmZmVyKGFyciwgc2l6ZSwgYmlnRW5kaWFuKSB7XG4gIHZhciBidWYgPSBuZXcgQnVmZmVyKHNpemUpO1xuICB2YXIgZm4gPSBiaWdFbmRpYW4gPyBidWYud3JpdGVJbnQzMkJFIDogYnVmLndyaXRlSW50MzJMRTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBmbi5jYWxsKGJ1ZiwgYXJyW2ldLCBpICogNCwgdHJ1ZSk7XG4gIH1cbiAgcmV0dXJuIGJ1Zjtcbn1cblxuZnVuY3Rpb24gaGFzaChidWYsIGZuLCBoYXNoU2l6ZSwgYmlnRW5kaWFuKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIGJ1ZiA9IG5ldyBCdWZmZXIoYnVmKTtcbiAgdmFyIGFyciA9IGZuKHRvQXJyYXkoYnVmLCBiaWdFbmRpYW4pLCBidWYubGVuZ3RoICogY2hyc3opO1xuICByZXR1cm4gdG9CdWZmZXIoYXJyLCBoYXNoU2l6ZSwgYmlnRW5kaWFuKTtcbn1cbmV4cG9ydHMuaGFzaCA9IGhhc2g7IiwiJ3VzZSBzdHJpY3QnO1xuLypcbiAqIEEgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgUlNBIERhdGEgU2VjdXJpdHksIEluYy4gTUQ1IE1lc3NhZ2VcbiAqIERpZ2VzdCBBbGdvcml0aG0sIGFzIGRlZmluZWQgaW4gUkZDIDEzMjEuXG4gKiBWZXJzaW9uIDIuMSBDb3B5cmlnaHQgKEMpIFBhdWwgSm9obnN0b24gMTk5OSAtIDIwMDIuXG4gKiBPdGhlciBjb250cmlidXRvcnM6IEdyZWcgSG9sdCwgQW5kcmV3IEtlcGVydCwgWWRuYXIsIExvc3RpbmV0XG4gKiBEaXN0cmlidXRlZCB1bmRlciB0aGUgQlNEIExpY2Vuc2VcbiAqIFNlZSBodHRwOi8vcGFqaG9tZS5vcmcudWsvY3J5cHQvbWQ1IGZvciBtb3JlIGluZm8uXG4gKi9cblxudmFyIGhlbHBlcnMgPSByZXF1aXJlKCcuL2hlbHBlcnMnKTtcblxuLypcbiAqIENhbGN1bGF0ZSB0aGUgTUQ1IG9mIGFuIGFycmF5IG9mIGxpdHRsZS1lbmRpYW4gd29yZHMsIGFuZCBhIGJpdCBsZW5ndGhcbiAqL1xuZnVuY3Rpb24gY29yZV9tZDUoeCwgbGVuKVxue1xuICAvKiBhcHBlbmQgcGFkZGluZyAqL1xuICB4W2xlbiA+PiA1XSB8PSAweDgwIDw8ICgobGVuKSAlIDMyKTtcbiAgeFsoKChsZW4gKyA2NCkgPj4+IDkpIDw8IDQpICsgMTRdID0gbGVuO1xuXG4gIHZhciBhID0gIDE3MzI1ODQxOTM7XG4gIHZhciBiID0gLTI3MTczMzg3OTtcbiAgdmFyIGMgPSAtMTczMjU4NDE5NDtcbiAgdmFyIGQgPSAgMjcxNzMzODc4O1xuXG4gIGZvcih2YXIgaSA9IDA7IGkgPCB4Lmxlbmd0aDsgaSArPSAxNilcbiAge1xuICAgIHZhciBvbGRhID0gYTtcbiAgICB2YXIgb2xkYiA9IGI7XG4gICAgdmFyIG9sZGMgPSBjO1xuICAgIHZhciBvbGRkID0gZDtcblxuICAgIGEgPSBtZDVfZmYoYSwgYiwgYywgZCwgeFtpKyAwXSwgNyAsIC02ODA4NzY5MzYpO1xuICAgIGQgPSBtZDVfZmYoZCwgYSwgYiwgYywgeFtpKyAxXSwgMTIsIC0zODk1NjQ1ODYpO1xuICAgIGMgPSBtZDVfZmYoYywgZCwgYSwgYiwgeFtpKyAyXSwgMTcsICA2MDYxMDU4MTkpO1xuICAgIGIgPSBtZDVfZmYoYiwgYywgZCwgYSwgeFtpKyAzXSwgMjIsIC0xMDQ0NTI1MzMwKTtcbiAgICBhID0gbWQ1X2ZmKGEsIGIsIGMsIGQsIHhbaSsgNF0sIDcgLCAtMTc2NDE4ODk3KTtcbiAgICBkID0gbWQ1X2ZmKGQsIGEsIGIsIGMsIHhbaSsgNV0sIDEyLCAgMTIwMDA4MDQyNik7XG4gICAgYyA9IG1kNV9mZihjLCBkLCBhLCBiLCB4W2krIDZdLCAxNywgLTE0NzMyMzEzNDEpO1xuICAgIGIgPSBtZDVfZmYoYiwgYywgZCwgYSwgeFtpKyA3XSwgMjIsIC00NTcwNTk4Myk7XG4gICAgYSA9IG1kNV9mZihhLCBiLCBjLCBkLCB4W2krIDhdLCA3ICwgIDE3NzAwMzU0MTYpO1xuICAgIGQgPSBtZDVfZmYoZCwgYSwgYiwgYywgeFtpKyA5XSwgMTIsIC0xOTU4NDE0NDE3KTtcbiAgICBjID0gbWQ1X2ZmKGMsIGQsIGEsIGIsIHhbaSsxMF0sIDE3LCAtNDIwNjMpO1xuICAgIGIgPSBtZDVfZmYoYiwgYywgZCwgYSwgeFtpKzExXSwgMjIsIC0xOTkwNDA0MTYyKTtcbiAgICBhID0gbWQ1X2ZmKGEsIGIsIGMsIGQsIHhbaSsxMl0sIDcgLCAgMTgwNDYwMzY4Mik7XG4gICAgZCA9IG1kNV9mZihkLCBhLCBiLCBjLCB4W2krMTNdLCAxMiwgLTQwMzQxMTAxKTtcbiAgICBjID0gbWQ1X2ZmKGMsIGQsIGEsIGIsIHhbaSsxNF0sIDE3LCAtMTUwMjAwMjI5MCk7XG4gICAgYiA9IG1kNV9mZihiLCBjLCBkLCBhLCB4W2krMTVdLCAyMiwgIDEyMzY1MzUzMjkpO1xuXG4gICAgYSA9IG1kNV9nZyhhLCBiLCBjLCBkLCB4W2krIDFdLCA1ICwgLTE2NTc5NjUxMCk7XG4gICAgZCA9IG1kNV9nZyhkLCBhLCBiLCBjLCB4W2krIDZdLCA5ICwgLTEwNjk1MDE2MzIpO1xuICAgIGMgPSBtZDVfZ2coYywgZCwgYSwgYiwgeFtpKzExXSwgMTQsICA2NDM3MTc3MTMpO1xuICAgIGIgPSBtZDVfZ2coYiwgYywgZCwgYSwgeFtpKyAwXSwgMjAsIC0zNzM4OTczMDIpO1xuICAgIGEgPSBtZDVfZ2coYSwgYiwgYywgZCwgeFtpKyA1XSwgNSAsIC03MDE1NTg2OTEpO1xuICAgIGQgPSBtZDVfZ2coZCwgYSwgYiwgYywgeFtpKzEwXSwgOSAsICAzODAxNjA4Myk7XG4gICAgYyA9IG1kNV9nZyhjLCBkLCBhLCBiLCB4W2krMTVdLCAxNCwgLTY2MDQ3ODMzNSk7XG4gICAgYiA9IG1kNV9nZyhiLCBjLCBkLCBhLCB4W2krIDRdLCAyMCwgLTQwNTUzNzg0OCk7XG4gICAgYSA9IG1kNV9nZyhhLCBiLCBjLCBkLCB4W2krIDldLCA1ICwgIDU2ODQ0NjQzOCk7XG4gICAgZCA9IG1kNV9nZyhkLCBhLCBiLCBjLCB4W2krMTRdLCA5ICwgLTEwMTk4MDM2OTApO1xuICAgIGMgPSBtZDVfZ2coYywgZCwgYSwgYiwgeFtpKyAzXSwgMTQsIC0xODczNjM5NjEpO1xuICAgIGIgPSBtZDVfZ2coYiwgYywgZCwgYSwgeFtpKyA4XSwgMjAsICAxMTYzNTMxNTAxKTtcbiAgICBhID0gbWQ1X2dnKGEsIGIsIGMsIGQsIHhbaSsxM10sIDUgLCAtMTQ0NDY4MTQ2Nyk7XG4gICAgZCA9IG1kNV9nZyhkLCBhLCBiLCBjLCB4W2krIDJdLCA5ICwgLTUxNDAzNzg0KTtcbiAgICBjID0gbWQ1X2dnKGMsIGQsIGEsIGIsIHhbaSsgN10sIDE0LCAgMTczNTMyODQ3Myk7XG4gICAgYiA9IG1kNV9nZyhiLCBjLCBkLCBhLCB4W2krMTJdLCAyMCwgLTE5MjY2MDc3MzQpO1xuXG4gICAgYSA9IG1kNV9oaChhLCBiLCBjLCBkLCB4W2krIDVdLCA0ICwgLTM3ODU1OCk7XG4gICAgZCA9IG1kNV9oaChkLCBhLCBiLCBjLCB4W2krIDhdLCAxMSwgLTIwMjI1NzQ0NjMpO1xuICAgIGMgPSBtZDVfaGgoYywgZCwgYSwgYiwgeFtpKzExXSwgMTYsICAxODM5MDMwNTYyKTtcbiAgICBiID0gbWQ1X2hoKGIsIGMsIGQsIGEsIHhbaSsxNF0sIDIzLCAtMzUzMDk1NTYpO1xuICAgIGEgPSBtZDVfaGgoYSwgYiwgYywgZCwgeFtpKyAxXSwgNCAsIC0xNTMwOTkyMDYwKTtcbiAgICBkID0gbWQ1X2hoKGQsIGEsIGIsIGMsIHhbaSsgNF0sIDExLCAgMTI3Mjg5MzM1Myk7XG4gICAgYyA9IG1kNV9oaChjLCBkLCBhLCBiLCB4W2krIDddLCAxNiwgLTE1NTQ5NzYzMik7XG4gICAgYiA9IG1kNV9oaChiLCBjLCBkLCBhLCB4W2krMTBdLCAyMywgLTEwOTQ3MzA2NDApO1xuICAgIGEgPSBtZDVfaGgoYSwgYiwgYywgZCwgeFtpKzEzXSwgNCAsICA2ODEyNzkxNzQpO1xuICAgIGQgPSBtZDVfaGgoZCwgYSwgYiwgYywgeFtpKyAwXSwgMTEsIC0zNTg1MzcyMjIpO1xuICAgIGMgPSBtZDVfaGgoYywgZCwgYSwgYiwgeFtpKyAzXSwgMTYsIC03MjI1MjE5NzkpO1xuICAgIGIgPSBtZDVfaGgoYiwgYywgZCwgYSwgeFtpKyA2XSwgMjMsICA3NjAyOTE4OSk7XG4gICAgYSA9IG1kNV9oaChhLCBiLCBjLCBkLCB4W2krIDldLCA0ICwgLTY0MDM2NDQ4Nyk7XG4gICAgZCA9IG1kNV9oaChkLCBhLCBiLCBjLCB4W2krMTJdLCAxMSwgLTQyMTgxNTgzNSk7XG4gICAgYyA9IG1kNV9oaChjLCBkLCBhLCBiLCB4W2krMTVdLCAxNiwgIDUzMDc0MjUyMCk7XG4gICAgYiA9IG1kNV9oaChiLCBjLCBkLCBhLCB4W2krIDJdLCAyMywgLTk5NTMzODY1MSk7XG5cbiAgICBhID0gbWQ1X2lpKGEsIGIsIGMsIGQsIHhbaSsgMF0sIDYgLCAtMTk4NjMwODQ0KTtcbiAgICBkID0gbWQ1X2lpKGQsIGEsIGIsIGMsIHhbaSsgN10sIDEwLCAgMTEyNjg5MTQxNSk7XG4gICAgYyA9IG1kNV9paShjLCBkLCBhLCBiLCB4W2krMTRdLCAxNSwgLTE0MTYzNTQ5MDUpO1xuICAgIGIgPSBtZDVfaWkoYiwgYywgZCwgYSwgeFtpKyA1XSwgMjEsIC01NzQzNDA1NSk7XG4gICAgYSA9IG1kNV9paShhLCBiLCBjLCBkLCB4W2krMTJdLCA2ICwgIDE3MDA0ODU1NzEpO1xuICAgIGQgPSBtZDVfaWkoZCwgYSwgYiwgYywgeFtpKyAzXSwgMTAsIC0xODk0OTg2NjA2KTtcbiAgICBjID0gbWQ1X2lpKGMsIGQsIGEsIGIsIHhbaSsxMF0sIDE1LCAtMTA1MTUyMyk7XG4gICAgYiA9IG1kNV9paShiLCBjLCBkLCBhLCB4W2krIDFdLCAyMSwgLTIwNTQ5MjI3OTkpO1xuICAgIGEgPSBtZDVfaWkoYSwgYiwgYywgZCwgeFtpKyA4XSwgNiAsICAxODczMzEzMzU5KTtcbiAgICBkID0gbWQ1X2lpKGQsIGEsIGIsIGMsIHhbaSsxNV0sIDEwLCAtMzA2MTE3NDQpO1xuICAgIGMgPSBtZDVfaWkoYywgZCwgYSwgYiwgeFtpKyA2XSwgMTUsIC0xNTYwMTk4MzgwKTtcbiAgICBiID0gbWQ1X2lpKGIsIGMsIGQsIGEsIHhbaSsxM10sIDIxLCAgMTMwOTE1MTY0OSk7XG4gICAgYSA9IG1kNV9paShhLCBiLCBjLCBkLCB4W2krIDRdLCA2ICwgLTE0NTUyMzA3MCk7XG4gICAgZCA9IG1kNV9paShkLCBhLCBiLCBjLCB4W2krMTFdLCAxMCwgLTExMjAyMTAzNzkpO1xuICAgIGMgPSBtZDVfaWkoYywgZCwgYSwgYiwgeFtpKyAyXSwgMTUsICA3MTg3ODcyNTkpO1xuICAgIGIgPSBtZDVfaWkoYiwgYywgZCwgYSwgeFtpKyA5XSwgMjEsIC0zNDM0ODU1NTEpO1xuXG4gICAgYSA9IHNhZmVfYWRkKGEsIG9sZGEpO1xuICAgIGIgPSBzYWZlX2FkZChiLCBvbGRiKTtcbiAgICBjID0gc2FmZV9hZGQoYywgb2xkYyk7XG4gICAgZCA9IHNhZmVfYWRkKGQsIG9sZGQpO1xuICB9XG4gIHJldHVybiBBcnJheShhLCBiLCBjLCBkKTtcblxufVxuXG4vKlxuICogVGhlc2UgZnVuY3Rpb25zIGltcGxlbWVudCB0aGUgZm91ciBiYXNpYyBvcGVyYXRpb25zIHRoZSBhbGdvcml0aG0gdXNlcy5cbiAqL1xuZnVuY3Rpb24gbWQ1X2NtbihxLCBhLCBiLCB4LCBzLCB0KVxue1xuICByZXR1cm4gc2FmZV9hZGQoYml0X3JvbChzYWZlX2FkZChzYWZlX2FkZChhLCBxKSwgc2FmZV9hZGQoeCwgdCkpLCBzKSxiKTtcbn1cbmZ1bmN0aW9uIG1kNV9mZihhLCBiLCBjLCBkLCB4LCBzLCB0KVxue1xuICByZXR1cm4gbWQ1X2NtbigoYiAmIGMpIHwgKCh+YikgJiBkKSwgYSwgYiwgeCwgcywgdCk7XG59XG5mdW5jdGlvbiBtZDVfZ2coYSwgYiwgYywgZCwgeCwgcywgdClcbntcbiAgcmV0dXJuIG1kNV9jbW4oKGIgJiBkKSB8IChjICYgKH5kKSksIGEsIGIsIHgsIHMsIHQpO1xufVxuZnVuY3Rpb24gbWQ1X2hoKGEsIGIsIGMsIGQsIHgsIHMsIHQpXG57XG4gIHJldHVybiBtZDVfY21uKGIgXiBjIF4gZCwgYSwgYiwgeCwgcywgdCk7XG59XG5mdW5jdGlvbiBtZDVfaWkoYSwgYiwgYywgZCwgeCwgcywgdClcbntcbiAgcmV0dXJuIG1kNV9jbW4oYyBeIChiIHwgKH5kKSksIGEsIGIsIHgsIHMsIHQpO1xufVxuXG4vKlxuICogQWRkIGludGVnZXJzLCB3cmFwcGluZyBhdCAyXjMyLiBUaGlzIHVzZXMgMTYtYml0IG9wZXJhdGlvbnMgaW50ZXJuYWxseVxuICogdG8gd29yayBhcm91bmQgYnVncyBpbiBzb21lIEpTIGludGVycHJldGVycy5cbiAqL1xuZnVuY3Rpb24gc2FmZV9hZGQoeCwgeSlcbntcbiAgdmFyIGxzdyA9ICh4ICYgMHhGRkZGKSArICh5ICYgMHhGRkZGKTtcbiAgdmFyIG1zdyA9ICh4ID4+IDE2KSArICh5ID4+IDE2KSArIChsc3cgPj4gMTYpO1xuICByZXR1cm4gKG1zdyA8PCAxNikgfCAobHN3ICYgMHhGRkZGKTtcbn1cblxuLypcbiAqIEJpdHdpc2Ugcm90YXRlIGEgMzItYml0IG51bWJlciB0byB0aGUgbGVmdC5cbiAqL1xuZnVuY3Rpb24gYml0X3JvbChudW0sIGNudClcbntcbiAgcmV0dXJuIChudW0gPDwgY250KSB8IChudW0gPj4+ICgzMiAtIGNudCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG1kNShidWYpIHtcbiAgcmV0dXJuIGhlbHBlcnMuaGFzaChidWYsIGNvcmVfbWQ1LCAxNik7XG59OyIsInZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCdzdHJlYW0nKS5UcmFuc2Zvcm1cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXInKS5TdHJpbmdEZWNvZGVyXG5tb2R1bGUuZXhwb3J0cyA9IENpcGhlckJhc2VcbmluaGVyaXRzKENpcGhlckJhc2UsIFRyYW5zZm9ybSlcbmZ1bmN0aW9uIENpcGhlckJhc2UgKGhhc2hNb2RlKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMpXG4gIHRoaXMuaGFzaE1vZGUgPSB0eXBlb2YgaGFzaE1vZGUgPT09ICdzdHJpbmcnXG4gIGlmICh0aGlzLmhhc2hNb2RlKSB7XG4gICAgdGhpc1toYXNoTW9kZV0gPSB0aGlzLl9maW5hbE9yRGlnZXN0XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5maW5hbCA9IHRoaXMuX2ZpbmFsT3JEaWdlc3RcbiAgfVxuICB0aGlzLl9kZWNvZGVyID0gbnVsbFxuICB0aGlzLl9lbmNvZGluZyA9IG51bGxcbn1cbkNpcGhlckJhc2UucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhLCBpbnB1dEVuYywgb3V0cHV0RW5jKSB7XG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICBkYXRhID0gbmV3IEJ1ZmZlcihkYXRhLCBpbnB1dEVuYylcbiAgfVxuICB2YXIgb3V0RGF0YSA9IHRoaXMuX3VwZGF0ZShkYXRhKVxuICBpZiAodGhpcy5oYXNoTW9kZSkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cbiAgaWYgKG91dHB1dEVuYykge1xuICAgIG91dERhdGEgPSB0aGlzLl90b1N0cmluZyhvdXREYXRhLCBvdXRwdXRFbmMpXG4gIH1cbiAgcmV0dXJuIG91dERhdGFcbn1cblxuQ2lwaGVyQmFzZS5wcm90b3R5cGUuc2V0QXV0b1BhZGRpbmcgPSBmdW5jdGlvbiAoKSB7fVxuXG5DaXBoZXJCYXNlLnByb3RvdHlwZS5nZXRBdXRoVGFnID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ3RyeWluZyB0byBnZXQgYXV0aCB0YWcgaW4gdW5zdXBwb3J0ZWQgc3RhdGUnKVxufVxuXG5DaXBoZXJCYXNlLnByb3RvdHlwZS5zZXRBdXRoVGFnID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ3RyeWluZyB0byBzZXQgYXV0aCB0YWcgaW4gdW5zdXBwb3J0ZWQgc3RhdGUnKVxufVxuXG5DaXBoZXJCYXNlLnByb3RvdHlwZS5zZXRBQUQgPSBmdW5jdGlvbiAoKSB7XG4gIHRocm93IG5ldyBFcnJvcigndHJ5aW5nIHRvIHNldCBhYWQgaW4gdW5zdXBwb3J0ZWQgc3RhdGUnKVxufVxuXG5DaXBoZXJCYXNlLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGRhdGEsIF8sIG5leHQpIHtcbiAgdmFyIGVyclxuICB0cnkge1xuICAgIGlmICh0aGlzLmhhc2hNb2RlKSB7XG4gICAgICB0aGlzLl91cGRhdGUoZGF0YSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wdXNoKHRoaXMuX3VwZGF0ZShkYXRhKSlcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBlcnIgPSBlXG4gIH0gZmluYWxseSB7XG4gICAgbmV4dChlcnIpXG4gIH1cbn1cbkNpcGhlckJhc2UucHJvdG90eXBlLl9mbHVzaCA9IGZ1bmN0aW9uIChkb25lKSB7XG4gIHZhciBlcnJcbiAgdHJ5IHtcbiAgICB0aGlzLnB1c2godGhpcy5fZmluYWwoKSlcbiAgfSBjYXRjaCAoZSkge1xuICAgIGVyciA9IGVcbiAgfSBmaW5hbGx5IHtcbiAgICBkb25lKGVycilcbiAgfVxufVxuQ2lwaGVyQmFzZS5wcm90b3R5cGUuX2ZpbmFsT3JEaWdlc3QgPSBmdW5jdGlvbiAob3V0cHV0RW5jKSB7XG4gIHZhciBvdXREYXRhID0gdGhpcy5fZmluYWwoKSB8fCBuZXcgQnVmZmVyKCcnKVxuICBpZiAob3V0cHV0RW5jKSB7XG4gICAgb3V0RGF0YSA9IHRoaXMuX3RvU3RyaW5nKG91dERhdGEsIG91dHB1dEVuYywgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb3V0RGF0YVxufVxuXG5DaXBoZXJCYXNlLnByb3RvdHlwZS5fdG9TdHJpbmcgPSBmdW5jdGlvbiAodmFsdWUsIGVuYywgZmluYWwpIHtcbiAgaWYgKCF0aGlzLl9kZWNvZGVyKSB7XG4gICAgdGhpcy5fZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKGVuYylcbiAgICB0aGlzLl9lbmNvZGluZyA9IGVuY1xuICB9XG4gIGlmICh0aGlzLl9lbmNvZGluZyAhPT0gZW5jKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjYW5cXCd0IHN3aXRjaCBlbmNvZGluZ3MnKVxuICB9XG4gIHZhciBvdXQgPSB0aGlzLl9kZWNvZGVyLndyaXRlKHZhbHVlKVxuICBpZiAoZmluYWwpIHtcbiAgICBvdXQgKz0gdGhpcy5fZGVjb2Rlci5lbmQoKVxuICB9XG4gIHJldHVybiBvdXRcbn1cbiIsIi8qXG5DcnlwdG9KUyB2My4xLjJcbmNvZGUuZ29vZ2xlLmNvbS9wL2NyeXB0by1qc1xuKGMpIDIwMDktMjAxMyBieSBKZWZmIE1vdHQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5jb2RlLmdvb2dsZS5jb20vcC9jcnlwdG8tanMvd2lraS9MaWNlbnNlXG4qL1xuLyoqIEBwcmVzZXJ2ZVxuKGMpIDIwMTIgYnkgQ8OpZHJpYyBNZXNuaWwuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cblJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuICAgIC0gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICAgIC0gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG5USElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4qL1xuXG4vLyBjb25zdGFudHMgdGFibGVcbnZhciB6bCA9IFtcbiAgMCwgMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMiwgMTMsIDE0LCAxNSxcbiAgNywgNCwgMTMsIDEsIDEwLCA2LCAxNSwgMywgMTIsIDAsIDksIDUsIDIsIDE0LCAxMSwgOCxcbiAgMywgMTAsIDE0LCA0LCA5LCAxNSwgOCwgMSwgMiwgNywgMCwgNiwgMTMsIDExLCA1LCAxMixcbiAgMSwgOSwgMTEsIDEwLCAwLCA4LCAxMiwgNCwgMTMsIDMsIDcsIDE1LCAxNCwgNSwgNiwgMixcbiAgNCwgMCwgNSwgOSwgNywgMTIsIDIsIDEwLCAxNCwgMSwgMywgOCwgMTEsIDYsIDE1LCAxM1xuXVxuXG52YXIgenIgPSBbXG4gIDUsIDE0LCA3LCAwLCA5LCAyLCAxMSwgNCwgMTMsIDYsIDE1LCA4LCAxLCAxMCwgMywgMTIsXG4gIDYsIDExLCAzLCA3LCAwLCAxMywgNSwgMTAsIDE0LCAxNSwgOCwgMTIsIDQsIDksIDEsIDIsXG4gIDE1LCA1LCAxLCAzLCA3LCAxNCwgNiwgOSwgMTEsIDgsIDEyLCAyLCAxMCwgMCwgNCwgMTMsXG4gIDgsIDYsIDQsIDEsIDMsIDExLCAxNSwgMCwgNSwgMTIsIDIsIDEzLCA5LCA3LCAxMCwgMTQsXG4gIDEyLCAxNSwgMTAsIDQsIDEsIDUsIDgsIDcsIDYsIDIsIDEzLCAxNCwgMCwgMywgOSwgMTFcbl1cblxudmFyIHNsID0gW1xuICAxMSwgMTQsIDE1LCAxMiwgNSwgOCwgNywgOSwgMTEsIDEzLCAxNCwgMTUsIDYsIDcsIDksIDgsXG4gIDcsIDYsIDgsIDEzLCAxMSwgOSwgNywgMTUsIDcsIDEyLCAxNSwgOSwgMTEsIDcsIDEzLCAxMixcbiAgMTEsIDEzLCA2LCA3LCAxNCwgOSwgMTMsIDE1LCAxNCwgOCwgMTMsIDYsIDUsIDEyLCA3LCA1LFxuICAxMSwgMTIsIDE0LCAxNSwgMTQsIDE1LCA5LCA4LCA5LCAxNCwgNSwgNiwgOCwgNiwgNSwgMTIsXG4gIDksIDE1LCA1LCAxMSwgNiwgOCwgMTMsIDEyLCA1LCAxMiwgMTMsIDE0LCAxMSwgOCwgNSwgNlxuXVxuXG52YXIgc3IgPSBbXG4gIDgsIDksIDksIDExLCAxMywgMTUsIDE1LCA1LCA3LCA3LCA4LCAxMSwgMTQsIDE0LCAxMiwgNixcbiAgOSwgMTMsIDE1LCA3LCAxMiwgOCwgOSwgMTEsIDcsIDcsIDEyLCA3LCA2LCAxNSwgMTMsIDExLFxuICA5LCA3LCAxNSwgMTEsIDgsIDYsIDYsIDE0LCAxMiwgMTMsIDUsIDE0LCAxMywgMTMsIDcsIDUsXG4gIDE1LCA1LCA4LCAxMSwgMTQsIDE0LCA2LCAxNCwgNiwgOSwgMTIsIDksIDEyLCA1LCAxNSwgOCxcbiAgOCwgNSwgMTIsIDksIDEyLCA1LCAxNCwgNiwgOCwgMTMsIDYsIDUsIDE1LCAxMywgMTEsIDExXG5dXG5cbnZhciBobCA9IFsweDAwMDAwMDAwLCAweDVBODI3OTk5LCAweDZFRDlFQkExLCAweDhGMUJCQ0RDLCAweEE5NTNGRDRFXVxudmFyIGhyID0gWzB4NTBBMjhCRTYsIDB4NUM0REQxMjQsIDB4NkQ3MDNFRjMsIDB4N0E2RDc2RTksIDB4MDAwMDAwMDBdXG5cbmZ1bmN0aW9uIGJ5dGVzVG9Xb3JkcyAoYnl0ZXMpIHtcbiAgdmFyIHdvcmRzID0gW11cbiAgZm9yICh2YXIgaSA9IDAsIGIgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyssIGIgKz0gOCkge1xuICAgIHdvcmRzW2IgPj4+IDVdIHw9IGJ5dGVzW2ldIDw8ICgyNCAtIGIgJSAzMilcbiAgfVxuICByZXR1cm4gd29yZHNcbn1cblxuZnVuY3Rpb24gd29yZHNUb0J5dGVzICh3b3Jkcykge1xuICB2YXIgYnl0ZXMgPSBbXVxuICBmb3IgKHZhciBiID0gMDsgYiA8IHdvcmRzLmxlbmd0aCAqIDMyOyBiICs9IDgpIHtcbiAgICBieXRlcy5wdXNoKCh3b3Jkc1tiID4+PiA1XSA+Pj4gKDI0IC0gYiAlIDMyKSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzQmxvY2sgKEgsIE0sIG9mZnNldCkge1xuICAvLyBzd2FwIGVuZGlhblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICB2YXIgb2Zmc2V0X2kgPSBvZmZzZXQgKyBpXG4gICAgdmFyIE1fb2Zmc2V0X2kgPSBNW29mZnNldF9pXVxuXG4gICAgLy8gU3dhcFxuICAgIE1bb2Zmc2V0X2ldID0gKFxuICAgICAgKCgoTV9vZmZzZXRfaSA8PCA4KSB8IChNX29mZnNldF9pID4+PiAyNCkpICYgMHgwMGZmMDBmZikgfFxuICAgICAgKCgoTV9vZmZzZXRfaSA8PCAyNCkgfCAoTV9vZmZzZXRfaSA+Pj4gOCkpICYgMHhmZjAwZmYwMClcbiAgICApXG4gIH1cblxuICAvLyBXb3JraW5nIHZhcmlhYmxlc1xuICB2YXIgYWwsIGJsLCBjbCwgZGwsIGVsXG4gIHZhciBhciwgYnIsIGNyLCBkciwgZXJcblxuICBhciA9IGFsID0gSFswXVxuICBiciA9IGJsID0gSFsxXVxuICBjciA9IGNsID0gSFsyXVxuICBkciA9IGRsID0gSFszXVxuICBlciA9IGVsID0gSFs0XVxuXG4gIC8vIGNvbXB1dGF0aW9uXG4gIHZhciB0XG4gIGZvciAoaSA9IDA7IGkgPCA4MDsgaSArPSAxKSB7XG4gICAgdCA9IChhbCArIE1bb2Zmc2V0ICsgemxbaV1dKSB8IDBcbiAgICBpZiAoaSA8IDE2KSB7XG4gICAgICB0ICs9IGYxKGJsLCBjbCwgZGwpICsgaGxbMF1cbiAgICB9IGVsc2UgaWYgKGkgPCAzMikge1xuICAgICAgdCArPSBmMihibCwgY2wsIGRsKSArIGhsWzFdXG4gICAgfSBlbHNlIGlmIChpIDwgNDgpIHtcbiAgICAgIHQgKz0gZjMoYmwsIGNsLCBkbCkgKyBobFsyXVxuICAgIH0gZWxzZSBpZiAoaSA8IDY0KSB7XG4gICAgICB0ICs9IGY0KGJsLCBjbCwgZGwpICsgaGxbM11cbiAgICB9IGVsc2Ugey8vIGlmIChpPDgwKSB7XG4gICAgICB0ICs9IGY1KGJsLCBjbCwgZGwpICsgaGxbNF1cbiAgICB9XG4gICAgdCA9IHQgfCAwXG4gICAgdCA9IHJvdGwodCwgc2xbaV0pXG4gICAgdCA9ICh0ICsgZWwpIHwgMFxuICAgIGFsID0gZWxcbiAgICBlbCA9IGRsXG4gICAgZGwgPSByb3RsKGNsLCAxMClcbiAgICBjbCA9IGJsXG4gICAgYmwgPSB0XG5cbiAgICB0ID0gKGFyICsgTVtvZmZzZXQgKyB6cltpXV0pIHwgMFxuICAgIGlmIChpIDwgMTYpIHtcbiAgICAgIHQgKz0gZjUoYnIsIGNyLCBkcikgKyBoclswXVxuICAgIH0gZWxzZSBpZiAoaSA8IDMyKSB7XG4gICAgICB0ICs9IGY0KGJyLCBjciwgZHIpICsgaHJbMV1cbiAgICB9IGVsc2UgaWYgKGkgPCA0OCkge1xuICAgICAgdCArPSBmMyhiciwgY3IsIGRyKSArIGhyWzJdXG4gICAgfSBlbHNlIGlmIChpIDwgNjQpIHtcbiAgICAgIHQgKz0gZjIoYnIsIGNyLCBkcikgKyBoclszXVxuICAgIH0gZWxzZSB7Ly8gaWYgKGk8ODApIHtcbiAgICAgIHQgKz0gZjEoYnIsIGNyLCBkcikgKyBocls0XVxuICAgIH1cblxuICAgIHQgPSB0IHwgMFxuICAgIHQgPSByb3RsKHQsIHNyW2ldKVxuICAgIHQgPSAodCArIGVyKSB8IDBcbiAgICBhciA9IGVyXG4gICAgZXIgPSBkclxuICAgIGRyID0gcm90bChjciwgMTApXG4gICAgY3IgPSBiclxuICAgIGJyID0gdFxuICB9XG5cbiAgLy8gaW50ZXJtZWRpYXRlIGhhc2ggdmFsdWVcbiAgdCA9IChIWzFdICsgY2wgKyBkcikgfCAwXG4gIEhbMV0gPSAoSFsyXSArIGRsICsgZXIpIHwgMFxuICBIWzJdID0gKEhbM10gKyBlbCArIGFyKSB8IDBcbiAgSFszXSA9IChIWzRdICsgYWwgKyBicikgfCAwXG4gIEhbNF0gPSAoSFswXSArIGJsICsgY3IpIHwgMFxuICBIWzBdID0gdFxufVxuXG5mdW5jdGlvbiBmMSAoeCwgeSwgeikge1xuICByZXR1cm4gKCh4KSBeICh5KSBeICh6KSlcbn1cblxuZnVuY3Rpb24gZjIgKHgsIHksIHopIHtcbiAgcmV0dXJuICgoKHgpICYgKHkpKSB8ICgofngpICYgKHopKSlcbn1cblxuZnVuY3Rpb24gZjMgKHgsIHksIHopIHtcbiAgcmV0dXJuICgoKHgpIHwgKH4oeSkpKSBeICh6KSlcbn1cblxuZnVuY3Rpb24gZjQgKHgsIHksIHopIHtcbiAgcmV0dXJuICgoKHgpICYgKHopKSB8ICgoeSkgJiAofih6KSkpKVxufVxuXG5mdW5jdGlvbiBmNSAoeCwgeSwgeikge1xuICByZXR1cm4gKCh4KSBeICgoeSkgfCAofih6KSkpKVxufVxuXG5mdW5jdGlvbiByb3RsICh4LCBuKSB7XG4gIHJldHVybiAoeCA8PCBuKSB8ICh4ID4+PiAoMzIgLSBuKSlcbn1cblxuZnVuY3Rpb24gcmlwZW1kMTYwIChtZXNzYWdlKSB7XG4gIHZhciBIID0gWzB4Njc0NTIzMDEsIDB4RUZDREFCODksIDB4OThCQURDRkUsIDB4MTAzMjU0NzYsIDB4QzNEMkUxRjBdXG5cbiAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgIG1lc3NhZ2UgPSBuZXcgQnVmZmVyKG1lc3NhZ2UsICd1dGY4JylcbiAgfVxuXG4gIHZhciBtID0gYnl0ZXNUb1dvcmRzKG1lc3NhZ2UpXG5cbiAgdmFyIG5CaXRzTGVmdCA9IG1lc3NhZ2UubGVuZ3RoICogOFxuICB2YXIgbkJpdHNUb3RhbCA9IG1lc3NhZ2UubGVuZ3RoICogOFxuXG4gIC8vIEFkZCBwYWRkaW5nXG4gIG1bbkJpdHNMZWZ0ID4+PiA1XSB8PSAweDgwIDw8ICgyNCAtIG5CaXRzTGVmdCAlIDMyKVxuICBtWygoKG5CaXRzTGVmdCArIDY0KSA+Pj4gOSkgPDwgNCkgKyAxNF0gPSAoXG4gICAgKCgobkJpdHNUb3RhbCA8PCA4KSB8IChuQml0c1RvdGFsID4+PiAyNCkpICYgMHgwMGZmMDBmZikgfFxuICAgICgoKG5CaXRzVG90YWwgPDwgMjQpIHwgKG5CaXRzVG90YWwgPj4+IDgpKSAmIDB4ZmYwMGZmMDApXG4gIClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG0ubGVuZ3RoOyBpICs9IDE2KSB7XG4gICAgcHJvY2Vzc0Jsb2NrKEgsIG0sIGkpXG4gIH1cblxuICAvLyBzd2FwIGVuZGlhblxuICBmb3IgKGkgPSAwOyBpIDwgNTsgaSsrKSB7XG4gICAgLy8gc2hvcnRjdXRcbiAgICB2YXIgSF9pID0gSFtpXVxuXG4gICAgLy8gU3dhcFxuICAgIEhbaV0gPSAoKChIX2kgPDwgOCkgfCAoSF9pID4+PiAyNCkpICYgMHgwMGZmMDBmZikgfFxuICAgICAgKCgoSF9pIDw8IDI0KSB8IChIX2kgPj4+IDgpKSAmIDB4ZmYwMGZmMDApXG4gIH1cblxuICB2YXIgZGlnZXN0Ynl0ZXMgPSB3b3Jkc1RvQnl0ZXMoSClcbiAgcmV0dXJuIG5ldyBCdWZmZXIoZGlnZXN0Ynl0ZXMpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmlwZW1kMTYwXG4iLCIvLyBwcm90b3R5cGUgY2xhc3MgZm9yIGhhc2ggZnVuY3Rpb25zXG5mdW5jdGlvbiBIYXNoIChibG9ja1NpemUsIGZpbmFsU2l6ZSkge1xuICB0aGlzLl9ibG9jayA9IG5ldyBCdWZmZXIoYmxvY2tTaXplKVxuICB0aGlzLl9maW5hbFNpemUgPSBmaW5hbFNpemVcbiAgdGhpcy5fYmxvY2tTaXplID0gYmxvY2tTaXplXG4gIHRoaXMuX2xlbiA9IDBcbiAgdGhpcy5fcyA9IDBcbn1cblxuSGFzaC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRhdGEsIGVuYykge1xuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jID0gZW5jIHx8ICd1dGY4J1xuICAgIGRhdGEgPSBuZXcgQnVmZmVyKGRhdGEsIGVuYylcbiAgfVxuXG4gIHZhciBsID0gdGhpcy5fbGVuICs9IGRhdGEubGVuZ3RoXG4gIHZhciBzID0gdGhpcy5fcyB8fCAwXG4gIHZhciBmID0gMFxuICB2YXIgYnVmZmVyID0gdGhpcy5fYmxvY2tcblxuICB3aGlsZSAocyA8IGwpIHtcbiAgICB2YXIgdCA9IE1hdGgubWluKGRhdGEubGVuZ3RoLCBmICsgdGhpcy5fYmxvY2tTaXplIC0gKHMgJSB0aGlzLl9ibG9ja1NpemUpKVxuICAgIHZhciBjaCA9ICh0IC0gZilcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2g7IGkrKykge1xuICAgICAgYnVmZmVyWyhzICUgdGhpcy5fYmxvY2tTaXplKSArIGldID0gZGF0YVtpICsgZl1cbiAgICB9XG5cbiAgICBzICs9IGNoXG4gICAgZiArPSBjaFxuXG4gICAgaWYgKChzICUgdGhpcy5fYmxvY2tTaXplKSA9PT0gMCkge1xuICAgICAgdGhpcy5fdXBkYXRlKGJ1ZmZlcilcbiAgICB9XG4gIH1cbiAgdGhpcy5fcyA9IHNcblxuICByZXR1cm4gdGhpc1xufVxuXG5IYXNoLnByb3RvdHlwZS5kaWdlc3QgPSBmdW5jdGlvbiAoZW5jKSB7XG4gIC8vIFN1cHBvc2UgdGhlIGxlbmd0aCBvZiB0aGUgbWVzc2FnZSBNLCBpbiBiaXRzLCBpcyBsXG4gIHZhciBsID0gdGhpcy5fbGVuICogOFxuXG4gIC8vIEFwcGVuZCB0aGUgYml0IDEgdG8gdGhlIGVuZCBvZiB0aGUgbWVzc2FnZVxuICB0aGlzLl9ibG9ja1t0aGlzLl9sZW4gJSB0aGlzLl9ibG9ja1NpemVdID0gMHg4MFxuXG4gIC8vIGFuZCB0aGVuIGsgemVybyBiaXRzLCB3aGVyZSBrIGlzIHRoZSBzbWFsbGVzdCBub24tbmVnYXRpdmUgc29sdXRpb24gdG8gdGhlIGVxdWF0aW9uIChsICsgMSArIGspID09PSBmaW5hbFNpemUgbW9kIGJsb2NrU2l6ZVxuICB0aGlzLl9ibG9jay5maWxsKDAsIHRoaXMuX2xlbiAlIHRoaXMuX2Jsb2NrU2l6ZSArIDEpXG5cbiAgaWYgKGwgJSAodGhpcy5fYmxvY2tTaXplICogOCkgPj0gdGhpcy5fZmluYWxTaXplICogOCkge1xuICAgIHRoaXMuX3VwZGF0ZSh0aGlzLl9ibG9jaylcbiAgICB0aGlzLl9ibG9jay5maWxsKDApXG4gIH1cblxuICAvLyB0byB0aGlzIGFwcGVuZCB0aGUgYmxvY2sgd2hpY2ggaXMgZXF1YWwgdG8gdGhlIG51bWJlciBsIHdyaXR0ZW4gaW4gYmluYXJ5XG4gIC8vIFRPRE86IGhhbmRsZSBjYXNlIHdoZXJlIGwgaXMgPiBNYXRoLnBvdygyLCAyOSlcbiAgdGhpcy5fYmxvY2sud3JpdGVJbnQzMkJFKGwsIHRoaXMuX2Jsb2NrU2l6ZSAtIDQpXG5cbiAgdmFyIGhhc2ggPSB0aGlzLl91cGRhdGUodGhpcy5fYmxvY2spIHx8IHRoaXMuX2hhc2goKVxuXG4gIHJldHVybiBlbmMgPyBoYXNoLnRvU3RyaW5nKGVuYykgOiBoYXNoXG59XG5cbkhhc2gucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIHRocm93IG5ldyBFcnJvcignX3VwZGF0ZSBtdXN0IGJlIGltcGxlbWVudGVkIGJ5IHN1YmNsYXNzJylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBIYXNoXG4iLCJ2YXIgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gU0hBIChhbGdvcml0aG0pIHtcbiAgYWxnb3JpdGhtID0gYWxnb3JpdGhtLnRvTG93ZXJDYXNlKClcblxuICB2YXIgQWxnb3JpdGhtID0gZXhwb3J0c1thbGdvcml0aG1dXG4gIGlmICghQWxnb3JpdGhtKSB0aHJvdyBuZXcgRXJyb3IoYWxnb3JpdGhtICsgJyBpcyBub3Qgc3VwcG9ydGVkICh3ZSBhY2NlcHQgcHVsbCByZXF1ZXN0cyknKVxuXG4gIHJldHVybiBuZXcgQWxnb3JpdGhtKClcbn1cblxuZXhwb3J0cy5zaGEgPSByZXF1aXJlKCcuL3NoYScpXG5leHBvcnRzLnNoYTEgPSByZXF1aXJlKCcuL3NoYTEnKVxuZXhwb3J0cy5zaGEyMjQgPSByZXF1aXJlKCcuL3NoYTIyNCcpXG5leHBvcnRzLnNoYTI1NiA9IHJlcXVpcmUoJy4vc2hhMjU2JylcbmV4cG9ydHMuc2hhMzg0ID0gcmVxdWlyZSgnLi9zaGEzODQnKVxuZXhwb3J0cy5zaGE1MTIgPSByZXF1aXJlKCcuL3NoYTUxMicpXG4iLCIvKlxuICogQSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBTZWN1cmUgSGFzaCBBbGdvcml0aG0sIFNIQS0wLCBhcyBkZWZpbmVkXG4gKiBpbiBGSVBTIFBVQiAxODAtMVxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBkZXJpdmVkIGZyb20gc2hhMS5qcyBvZiB0aGUgc2FtZSByZXBvc2l0b3J5LlxuICogVGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBTSEEtMCBhbmQgU0hBLTEgaXMganVzdCBhIGJpdHdpc2Ugcm90YXRlIGxlZnRcbiAqIG9wZXJhdGlvbiB3YXMgYWRkZWQuXG4gKi9cblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIEhhc2ggPSByZXF1aXJlKCcuL2hhc2gnKVxuXG52YXIgVyA9IG5ldyBBcnJheSg4MClcblxuZnVuY3Rpb24gU2hhICgpIHtcbiAgdGhpcy5pbml0KClcbiAgdGhpcy5fdyA9IFdcblxuICBIYXNoLmNhbGwodGhpcywgNjQsIDU2KVxufVxuXG5pbmhlcml0cyhTaGEsIEhhc2gpXG5cblNoYS5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fYSA9IDB4Njc0NTIzMDEgfCAwXG4gIHRoaXMuX2IgPSAweGVmY2RhYjg5IHwgMFxuICB0aGlzLl9jID0gMHg5OGJhZGNmZSB8IDBcbiAgdGhpcy5fZCA9IDB4MTAzMjU0NzYgfCAwXG4gIHRoaXMuX2UgPSAweGMzZDJlMWYwIHwgMFxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8qXG4gKiBCaXR3aXNlIHJvdGF0ZSBhIDMyLWJpdCBudW1iZXIgdG8gdGhlIGxlZnQuXG4gKi9cbmZ1bmN0aW9uIHJvbCAobnVtLCBjbnQpIHtcbiAgcmV0dXJuIChudW0gPDwgY250KSB8IChudW0gPj4+ICgzMiAtIGNudCkpXG59XG5cblNoYS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChNKSB7XG4gIHZhciBXID0gdGhpcy5fd1xuXG4gIHZhciBhID0gdGhpcy5fYVxuICB2YXIgYiA9IHRoaXMuX2JcbiAgdmFyIGMgPSB0aGlzLl9jXG4gIHZhciBkID0gdGhpcy5fZFxuICB2YXIgZSA9IHRoaXMuX2VcblxuICB2YXIgaiA9IDBcbiAgdmFyIGtcblxuICAvKlxuICAgKiBTSEEtMSBoYXMgYSBiaXR3aXNlIHJvdGF0ZSBsZWZ0IG9wZXJhdGlvbi4gQnV0LCBTSEEgaXMgbm90XG4gICAqIGZ1bmN0aW9uIGNhbGNXKCkgeyByZXR1cm4gcm9sKFdbaiAtIDNdIF4gV1tqIC0gIDhdIF4gV1tqIC0gMTRdIF4gV1tqIC0gMTZdLCAxKSB9XG4gICAqL1xuICBmdW5jdGlvbiBjYWxjVyAoKSB7IHJldHVybiBXW2ogLSAzXSBeIFdbaiAtIDhdIF4gV1tqIC0gMTRdIF4gV1tqIC0gMTZdIH1cbiAgZnVuY3Rpb24gbG9vcCAodywgZikge1xuICAgIFdbal0gPSB3XG5cbiAgICB2YXIgdCA9IHJvbChhLCA1KSArIGYgKyBlICsgdyArIGtcblxuICAgIGUgPSBkXG4gICAgZCA9IGNcbiAgICBjID0gcm9sKGIsIDMwKVxuICAgIGIgPSBhXG4gICAgYSA9IHRcbiAgICBqKytcbiAgfVxuXG4gIGsgPSAxNTE4NTAwMjQ5XG4gIHdoaWxlIChqIDwgMTYpIGxvb3AoTS5yZWFkSW50MzJCRShqICogNCksIChiICYgYykgfCAoKH5iKSAmIGQpKVxuICB3aGlsZSAoaiA8IDIwKSBsb29wKGNhbGNXKCksIChiICYgYykgfCAoKH5iKSAmIGQpKVxuICBrID0gMTg1OTc3NTM5M1xuICB3aGlsZSAoaiA8IDQwKSBsb29wKGNhbGNXKCksIGIgXiBjIF4gZClcbiAgayA9IC0xODk0MDA3NTg4XG4gIHdoaWxlIChqIDwgNjApIGxvb3AoY2FsY1coKSwgKGIgJiBjKSB8IChiICYgZCkgfCAoYyAmIGQpKVxuICBrID0gLTg5OTQ5NzUxNFxuICB3aGlsZSAoaiA8IDgwKSBsb29wKGNhbGNXKCksIGIgXiBjIF4gZClcblxuICB0aGlzLl9hID0gKGEgKyB0aGlzLl9hKSB8IDBcbiAgdGhpcy5fYiA9IChiICsgdGhpcy5fYikgfCAwXG4gIHRoaXMuX2MgPSAoYyArIHRoaXMuX2MpIHwgMFxuICB0aGlzLl9kID0gKGQgKyB0aGlzLl9kKSB8IDBcbiAgdGhpcy5fZSA9IChlICsgdGhpcy5fZSkgfCAwXG59XG5cblNoYS5wcm90b3R5cGUuX2hhc2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBIID0gbmV3IEJ1ZmZlcigyMClcblxuICBILndyaXRlSW50MzJCRSh0aGlzLl9hIHwgMCwgMClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fYiB8IDAsIDQpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2MgfCAwLCA4KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9kIHwgMCwgMTIpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2UgfCAwLCAxNilcblxuICByZXR1cm4gSFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNoYVxuXG4iLCIvKlxuICogQSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBTZWN1cmUgSGFzaCBBbGdvcml0aG0sIFNIQS0xLCBhcyBkZWZpbmVkXG4gKiBpbiBGSVBTIFBVQiAxODAtMVxuICogVmVyc2lvbiAyLjFhIENvcHlyaWdodCBQYXVsIEpvaG5zdG9uIDIwMDAgLSAyMDAyLlxuICogT3RoZXIgY29udHJpYnV0b3JzOiBHcmVnIEhvbHQsIEFuZHJldyBLZXBlcnQsIFlkbmFyLCBMb3N0aW5ldFxuICogRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIEJTRCBMaWNlbnNlXG4gKiBTZWUgaHR0cDovL3BhamhvbWUub3JnLnVrL2NyeXB0L21kNSBmb3IgZGV0YWlscy5cbiAqL1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgSGFzaCA9IHJlcXVpcmUoJy4vaGFzaCcpXG5cbnZhciBXID0gbmV3IEFycmF5KDgwKVxuXG5mdW5jdGlvbiBTaGExICgpIHtcbiAgdGhpcy5pbml0KClcbiAgdGhpcy5fdyA9IFdcblxuICBIYXNoLmNhbGwodGhpcywgNjQsIDU2KVxufVxuXG5pbmhlcml0cyhTaGExLCBIYXNoKVxuXG5TaGExLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9hID0gMHg2NzQ1MjMwMSB8IDBcbiAgdGhpcy5fYiA9IDB4ZWZjZGFiODkgfCAwXG4gIHRoaXMuX2MgPSAweDk4YmFkY2ZlIHwgMFxuICB0aGlzLl9kID0gMHgxMDMyNTQ3NiB8IDBcbiAgdGhpcy5fZSA9IDB4YzNkMmUxZjAgfCAwXG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLypcbiAqIEJpdHdpc2Ugcm90YXRlIGEgMzItYml0IG51bWJlciB0byB0aGUgbGVmdC5cbiAqL1xuZnVuY3Rpb24gcm9sIChudW0sIGNudCkge1xuICByZXR1cm4gKG51bSA8PCBjbnQpIHwgKG51bSA+Pj4gKDMyIC0gY250KSlcbn1cblxuU2hhMS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChNKSB7XG4gIHZhciBXID0gdGhpcy5fd1xuXG4gIHZhciBhID0gdGhpcy5fYVxuICB2YXIgYiA9IHRoaXMuX2JcbiAgdmFyIGMgPSB0aGlzLl9jXG4gIHZhciBkID0gdGhpcy5fZFxuICB2YXIgZSA9IHRoaXMuX2VcblxuICB2YXIgaiA9IDBcbiAgdmFyIGtcblxuICBmdW5jdGlvbiBjYWxjVyAoKSB7IHJldHVybiByb2woV1tqIC0gM10gXiBXW2ogLSA4XSBeIFdbaiAtIDE0XSBeIFdbaiAtIDE2XSwgMSkgfVxuICBmdW5jdGlvbiBsb29wICh3LCBmKSB7XG4gICAgV1tqXSA9IHdcblxuICAgIHZhciB0ID0gcm9sKGEsIDUpICsgZiArIGUgKyB3ICsga1xuXG4gICAgZSA9IGRcbiAgICBkID0gY1xuICAgIGMgPSByb2woYiwgMzApXG4gICAgYiA9IGFcbiAgICBhID0gdFxuICAgIGorK1xuICB9XG5cbiAgayA9IDE1MTg1MDAyNDlcbiAgd2hpbGUgKGogPCAxNikgbG9vcChNLnJlYWRJbnQzMkJFKGogKiA0KSwgKGIgJiBjKSB8ICgofmIpICYgZCkpXG4gIHdoaWxlIChqIDwgMjApIGxvb3AoY2FsY1coKSwgKGIgJiBjKSB8ICgofmIpICYgZCkpXG4gIGsgPSAxODU5Nzc1MzkzXG4gIHdoaWxlIChqIDwgNDApIGxvb3AoY2FsY1coKSwgYiBeIGMgXiBkKVxuICBrID0gLTE4OTQwMDc1ODhcbiAgd2hpbGUgKGogPCA2MCkgbG9vcChjYWxjVygpLCAoYiAmIGMpIHwgKGIgJiBkKSB8IChjICYgZCkpXG4gIGsgPSAtODk5NDk3NTE0XG4gIHdoaWxlIChqIDwgODApIGxvb3AoY2FsY1coKSwgYiBeIGMgXiBkKVxuXG4gIHRoaXMuX2EgPSAoYSArIHRoaXMuX2EpIHwgMFxuICB0aGlzLl9iID0gKGIgKyB0aGlzLl9iKSB8IDBcbiAgdGhpcy5fYyA9IChjICsgdGhpcy5fYykgfCAwXG4gIHRoaXMuX2QgPSAoZCArIHRoaXMuX2QpIHwgMFxuICB0aGlzLl9lID0gKGUgKyB0aGlzLl9lKSB8IDBcbn1cblxuU2hhMS5wcm90b3R5cGUuX2hhc2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBIID0gbmV3IEJ1ZmZlcigyMClcblxuICBILndyaXRlSW50MzJCRSh0aGlzLl9hIHwgMCwgMClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fYiB8IDAsIDQpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2MgfCAwLCA4KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9kIHwgMCwgMTIpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2UgfCAwLCAxNilcblxuICByZXR1cm4gSFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNoYTFcbiIsIi8qKlxuICogQSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBTZWN1cmUgSGFzaCBBbGdvcml0aG0sIFNIQS0yNTYsIGFzIGRlZmluZWRcbiAqIGluIEZJUFMgMTgwLTJcbiAqIFZlcnNpb24gMi4yLWJldGEgQ29weXJpZ2h0IEFuZ2VsIE1hcmluLCBQYXVsIEpvaG5zdG9uIDIwMDAgLSAyMDA5LlxuICogT3RoZXIgY29udHJpYnV0b3JzOiBHcmVnIEhvbHQsIEFuZHJldyBLZXBlcnQsIFlkbmFyLCBMb3N0aW5ldFxuICpcbiAqL1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgU2hhMjU2ID0gcmVxdWlyZSgnLi9zaGEyNTYnKVxudmFyIEhhc2ggPSByZXF1aXJlKCcuL2hhc2gnKVxuXG52YXIgVyA9IG5ldyBBcnJheSg2NClcblxuZnVuY3Rpb24gU2hhMjI0ICgpIHtcbiAgdGhpcy5pbml0KClcblxuICB0aGlzLl93ID0gVyAvLyBuZXcgQXJyYXkoNjQpXG5cbiAgSGFzaC5jYWxsKHRoaXMsIDY0LCA1Nilcbn1cblxuaW5oZXJpdHMoU2hhMjI0LCBTaGEyNTYpXG5cblNoYTIyNC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fYSA9IDB4YzEwNTllZDggfCAwXG4gIHRoaXMuX2IgPSAweDM2N2NkNTA3IHwgMFxuICB0aGlzLl9jID0gMHgzMDcwZGQxNyB8IDBcbiAgdGhpcy5fZCA9IDB4ZjcwZTU5MzkgfCAwXG4gIHRoaXMuX2UgPSAweGZmYzAwYjMxIHwgMFxuICB0aGlzLl9mID0gMHg2ODU4MTUxMSB8IDBcbiAgdGhpcy5fZyA9IDB4NjRmOThmYTcgfCAwXG4gIHRoaXMuX2ggPSAweGJlZmE0ZmE0IHwgMFxuXG4gIHJldHVybiB0aGlzXG59XG5cblNoYTIyNC5wcm90b3R5cGUuX2hhc2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBIID0gbmV3IEJ1ZmZlcigyOClcblxuICBILndyaXRlSW50MzJCRSh0aGlzLl9hLCAwKVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9iLCA0KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9jLCA4KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9kLCAxMilcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZSwgMTYpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2YsIDIwKVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9nLCAyNClcblxuICByZXR1cm4gSFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNoYTIyNFxuIiwiLyoqXG4gKiBBIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIFNlY3VyZSBIYXNoIEFsZ29yaXRobSwgU0hBLTI1NiwgYXMgZGVmaW5lZFxuICogaW4gRklQUyAxODAtMlxuICogVmVyc2lvbiAyLjItYmV0YSBDb3B5cmlnaHQgQW5nZWwgTWFyaW4sIFBhdWwgSm9obnN0b24gMjAwMCAtIDIwMDkuXG4gKiBPdGhlciBjb250cmlidXRvcnM6IEdyZWcgSG9sdCwgQW5kcmV3IEtlcGVydCwgWWRuYXIsIExvc3RpbmV0XG4gKlxuICovXG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBIYXNoID0gcmVxdWlyZSgnLi9oYXNoJylcblxudmFyIEsgPSBbXG4gIDB4NDI4QTJGOTgsIDB4NzEzNzQ0OTEsIDB4QjVDMEZCQ0YsIDB4RTlCNURCQTUsXG4gIDB4Mzk1NkMyNUIsIDB4NTlGMTExRjEsIDB4OTIzRjgyQTQsIDB4QUIxQzVFRDUsXG4gIDB4RDgwN0FBOTgsIDB4MTI4MzVCMDEsIDB4MjQzMTg1QkUsIDB4NTUwQzdEQzMsXG4gIDB4NzJCRTVENzQsIDB4ODBERUIxRkUsIDB4OUJEQzA2QTcsIDB4QzE5QkYxNzQsXG4gIDB4RTQ5QjY5QzEsIDB4RUZCRTQ3ODYsIDB4MEZDMTlEQzYsIDB4MjQwQ0ExQ0MsXG4gIDB4MkRFOTJDNkYsIDB4NEE3NDg0QUEsIDB4NUNCMEE5REMsIDB4NzZGOTg4REEsXG4gIDB4OTgzRTUxNTIsIDB4QTgzMUM2NkQsIDB4QjAwMzI3QzgsIDB4QkY1OTdGQzcsXG4gIDB4QzZFMDBCRjMsIDB4RDVBNzkxNDcsIDB4MDZDQTYzNTEsIDB4MTQyOTI5NjcsXG4gIDB4MjdCNzBBODUsIDB4MkUxQjIxMzgsIDB4NEQyQzZERkMsIDB4NTMzODBEMTMsXG4gIDB4NjUwQTczNTQsIDB4NzY2QTBBQkIsIDB4ODFDMkM5MkUsIDB4OTI3MjJDODUsXG4gIDB4QTJCRkU4QTEsIDB4QTgxQTY2NEIsIDB4QzI0QjhCNzAsIDB4Qzc2QzUxQTMsXG4gIDB4RDE5MkU4MTksIDB4RDY5OTA2MjQsIDB4RjQwRTM1ODUsIDB4MTA2QUEwNzAsXG4gIDB4MTlBNEMxMTYsIDB4MUUzNzZDMDgsIDB4Mjc0ODc3NEMsIDB4MzRCMEJDQjUsXG4gIDB4MzkxQzBDQjMsIDB4NEVEOEFBNEEsIDB4NUI5Q0NBNEYsIDB4NjgyRTZGRjMsXG4gIDB4NzQ4RjgyRUUsIDB4NzhBNTYzNkYsIDB4ODRDODc4MTQsIDB4OENDNzAyMDgsXG4gIDB4OTBCRUZGRkEsIDB4QTQ1MDZDRUIsIDB4QkVGOUEzRjcsIDB4QzY3MTc4RjJcbl1cblxudmFyIFcgPSBuZXcgQXJyYXkoNjQpXG5cbmZ1bmN0aW9uIFNoYTI1NiAoKSB7XG4gIHRoaXMuaW5pdCgpXG5cbiAgdGhpcy5fdyA9IFcgLy8gbmV3IEFycmF5KDY0KVxuXG4gIEhhc2guY2FsbCh0aGlzLCA2NCwgNTYpXG59XG5cbmluaGVyaXRzKFNoYTI1NiwgSGFzaClcblxuU2hhMjU2LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9hID0gMHg2YTA5ZTY2NyB8IDBcbiAgdGhpcy5fYiA9IDB4YmI2N2FlODUgfCAwXG4gIHRoaXMuX2MgPSAweDNjNmVmMzcyIHwgMFxuICB0aGlzLl9kID0gMHhhNTRmZjUzYSB8IDBcbiAgdGhpcy5fZSA9IDB4NTEwZTUyN2YgfCAwXG4gIHRoaXMuX2YgPSAweDliMDU2ODhjIHwgMFxuICB0aGlzLl9nID0gMHgxZjgzZDlhYiB8IDBcbiAgdGhpcy5faCA9IDB4NWJlMGNkMTkgfCAwXG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuZnVuY3Rpb24gQ2ggKHgsIHksIHopIHtcbiAgcmV0dXJuIHogXiAoeCAmICh5IF4geikpXG59XG5cbmZ1bmN0aW9uIE1haiAoeCwgeSwgeikge1xuICByZXR1cm4gKHggJiB5KSB8ICh6ICYgKHggfCB5KSlcbn1cblxuZnVuY3Rpb24gU2lnbWEwICh4KSB7XG4gIHJldHVybiAoeCA+Pj4gMiB8IHggPDwgMzApIF4gKHggPj4+IDEzIHwgeCA8PCAxOSkgXiAoeCA+Pj4gMjIgfCB4IDw8IDEwKVxufVxuXG5mdW5jdGlvbiBTaWdtYTEgKHgpIHtcbiAgcmV0dXJuICh4ID4+PiA2IHwgeCA8PCAyNikgXiAoeCA+Pj4gMTEgfCB4IDw8IDIxKSBeICh4ID4+PiAyNSB8IHggPDwgNylcbn1cblxuZnVuY3Rpb24gR2FtbWEwICh4KSB7XG4gIHJldHVybiAoeCA+Pj4gNyB8IHggPDwgMjUpIF4gKHggPj4+IDE4IHwgeCA8PCAxNCkgXiAoeCA+Pj4gMylcbn1cblxuZnVuY3Rpb24gR2FtbWExICh4KSB7XG4gIHJldHVybiAoeCA+Pj4gMTcgfCB4IDw8IDE1KSBeICh4ID4+PiAxOSB8IHggPDwgMTMpIF4gKHggPj4+IDEwKVxufVxuXG5TaGEyNTYucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoTSkge1xuICB2YXIgVyA9IHRoaXMuX3dcblxuICB2YXIgYSA9IHRoaXMuX2EgfCAwXG4gIHZhciBiID0gdGhpcy5fYiB8IDBcbiAgdmFyIGMgPSB0aGlzLl9jIHwgMFxuICB2YXIgZCA9IHRoaXMuX2QgfCAwXG4gIHZhciBlID0gdGhpcy5fZSB8IDBcbiAgdmFyIGYgPSB0aGlzLl9mIHwgMFxuICB2YXIgZyA9IHRoaXMuX2cgfCAwXG4gIHZhciBoID0gdGhpcy5faCB8IDBcblxuICB2YXIgaiA9IDBcblxuICBmdW5jdGlvbiBjYWxjVyAoKSB7IHJldHVybiBHYW1tYTEoV1tqIC0gMl0pICsgV1tqIC0gN10gKyBHYW1tYTAoV1tqIC0gMTVdKSArIFdbaiAtIDE2XSB9XG4gIGZ1bmN0aW9uIGxvb3AgKHcpIHtcbiAgICBXW2pdID0gd1xuXG4gICAgdmFyIFQxID0gaCArIFNpZ21hMShlKSArIENoKGUsIGYsIGcpICsgS1tqXSArIHdcbiAgICB2YXIgVDIgPSBTaWdtYTAoYSkgKyBNYWooYSwgYiwgYylcblxuICAgIGggPSBnXG4gICAgZyA9IGZcbiAgICBmID0gZVxuICAgIGUgPSBkICsgVDFcbiAgICBkID0gY1xuICAgIGMgPSBiXG4gICAgYiA9IGFcbiAgICBhID0gVDEgKyBUMlxuXG4gICAgaisrXG4gIH1cblxuICB3aGlsZSAoaiA8IDE2KSBsb29wKE0ucmVhZEludDMyQkUoaiAqIDQpKVxuICB3aGlsZSAoaiA8IDY0KSBsb29wKGNhbGNXKCkpXG5cbiAgdGhpcy5fYSA9IChhICsgdGhpcy5fYSkgfCAwXG4gIHRoaXMuX2IgPSAoYiArIHRoaXMuX2IpIHwgMFxuICB0aGlzLl9jID0gKGMgKyB0aGlzLl9jKSB8IDBcbiAgdGhpcy5fZCA9IChkICsgdGhpcy5fZCkgfCAwXG4gIHRoaXMuX2UgPSAoZSArIHRoaXMuX2UpIHwgMFxuICB0aGlzLl9mID0gKGYgKyB0aGlzLl9mKSB8IDBcbiAgdGhpcy5fZyA9IChnICsgdGhpcy5fZykgfCAwXG4gIHRoaXMuX2ggPSAoaCArIHRoaXMuX2gpIHwgMFxufVxuXG5TaGEyNTYucHJvdG90eXBlLl9oYXNoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgSCA9IG5ldyBCdWZmZXIoMzIpXG5cbiAgSC53cml0ZUludDMyQkUodGhpcy5fYSwgMClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fYiwgNClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fYywgOClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZCwgMTIpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2UsIDE2KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9mLCAyMClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZywgMjQpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2gsIDI4KVxuXG4gIHJldHVybiBIXG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2hhMjU2XG4iLCJ2YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgU0hBNTEyID0gcmVxdWlyZSgnLi9zaGE1MTInKVxudmFyIEhhc2ggPSByZXF1aXJlKCcuL2hhc2gnKVxuXG52YXIgVyA9IG5ldyBBcnJheSgxNjApXG5cbmZ1bmN0aW9uIFNoYTM4NCAoKSB7XG4gIHRoaXMuaW5pdCgpXG4gIHRoaXMuX3cgPSBXXG5cbiAgSGFzaC5jYWxsKHRoaXMsIDEyOCwgMTEyKVxufVxuXG5pbmhlcml0cyhTaGEzODQsIFNIQTUxMilcblxuU2hhMzg0LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9hID0gMHhjYmJiOWQ1ZCB8IDBcbiAgdGhpcy5fYiA9IDB4NjI5YTI5MmEgfCAwXG4gIHRoaXMuX2MgPSAweDkxNTkwMTVhIHwgMFxuICB0aGlzLl9kID0gMHgxNTJmZWNkOCB8IDBcbiAgdGhpcy5fZSA9IDB4NjczMzI2NjcgfCAwXG4gIHRoaXMuX2YgPSAweDhlYjQ0YTg3IHwgMFxuICB0aGlzLl9nID0gMHhkYjBjMmUwZCB8IDBcbiAgdGhpcy5faCA9IDB4NDdiNTQ4MWQgfCAwXG5cbiAgdGhpcy5fYWwgPSAweGMxMDU5ZWQ4IHwgMFxuICB0aGlzLl9ibCA9IDB4MzY3Y2Q1MDcgfCAwXG4gIHRoaXMuX2NsID0gMHgzMDcwZGQxNyB8IDBcbiAgdGhpcy5fZGwgPSAweGY3MGU1OTM5IHwgMFxuICB0aGlzLl9lbCA9IDB4ZmZjMDBiMzEgfCAwXG4gIHRoaXMuX2ZsID0gMHg2ODU4MTUxMSB8IDBcbiAgdGhpcy5fZ2wgPSAweDY0Zjk4ZmE3IHwgMFxuICB0aGlzLl9obCA9IDB4YmVmYTRmYTQgfCAwXG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuU2hhMzg0LnByb3RvdHlwZS5faGFzaCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIEggPSBuZXcgQnVmZmVyKDQ4KVxuXG4gIGZ1bmN0aW9uIHdyaXRlSW50NjRCRSAoaCwgbCwgb2Zmc2V0KSB7XG4gICAgSC53cml0ZUludDMyQkUoaCwgb2Zmc2V0KVxuICAgIEgud3JpdGVJbnQzMkJFKGwsIG9mZnNldCArIDQpXG4gIH1cblxuICB3cml0ZUludDY0QkUodGhpcy5fYSwgdGhpcy5fYWwsIDApXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9iLCB0aGlzLl9ibCwgOClcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2MsIHRoaXMuX2NsLCAxNilcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2QsIHRoaXMuX2RsLCAyNClcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2UsIHRoaXMuX2VsLCAzMilcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2YsIHRoaXMuX2ZsLCA0MClcblxuICByZXR1cm4gSFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNoYTM4NFxuIiwidmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIEhhc2ggPSByZXF1aXJlKCcuL2hhc2gnKVxuXG52YXIgSyA9IFtcbiAgMHg0MjhhMmY5OCwgMHhkNzI4YWUyMiwgMHg3MTM3NDQ5MSwgMHgyM2VmNjVjZCxcbiAgMHhiNWMwZmJjZiwgMHhlYzRkM2IyZiwgMHhlOWI1ZGJhNSwgMHg4MTg5ZGJiYyxcbiAgMHgzOTU2YzI1YiwgMHhmMzQ4YjUzOCwgMHg1OWYxMTFmMSwgMHhiNjA1ZDAxOSxcbiAgMHg5MjNmODJhNCwgMHhhZjE5NGY5YiwgMHhhYjFjNWVkNSwgMHhkYTZkODExOCxcbiAgMHhkODA3YWE5OCwgMHhhMzAzMDI0MiwgMHgxMjgzNWIwMSwgMHg0NTcwNmZiZSxcbiAgMHgyNDMxODViZSwgMHg0ZWU0YjI4YywgMHg1NTBjN2RjMywgMHhkNWZmYjRlMixcbiAgMHg3MmJlNWQ3NCwgMHhmMjdiODk2ZiwgMHg4MGRlYjFmZSwgMHgzYjE2OTZiMSxcbiAgMHg5YmRjMDZhNywgMHgyNWM3MTIzNSwgMHhjMTliZjE3NCwgMHhjZjY5MjY5NCxcbiAgMHhlNDliNjljMSwgMHg5ZWYxNGFkMiwgMHhlZmJlNDc4NiwgMHgzODRmMjVlMyxcbiAgMHgwZmMxOWRjNiwgMHg4YjhjZDViNSwgMHgyNDBjYTFjYywgMHg3N2FjOWM2NSxcbiAgMHgyZGU5MmM2ZiwgMHg1OTJiMDI3NSwgMHg0YTc0ODRhYSwgMHg2ZWE2ZTQ4MyxcbiAgMHg1Y2IwYTlkYywgMHhiZDQxZmJkNCwgMHg3NmY5ODhkYSwgMHg4MzExNTNiNSxcbiAgMHg5ODNlNTE1MiwgMHhlZTY2ZGZhYiwgMHhhODMxYzY2ZCwgMHgyZGI0MzIxMCxcbiAgMHhiMDAzMjdjOCwgMHg5OGZiMjEzZiwgMHhiZjU5N2ZjNywgMHhiZWVmMGVlNCxcbiAgMHhjNmUwMGJmMywgMHgzZGE4OGZjMiwgMHhkNWE3OTE0NywgMHg5MzBhYTcyNSxcbiAgMHgwNmNhNjM1MSwgMHhlMDAzODI2ZiwgMHgxNDI5Mjk2NywgMHgwYTBlNmU3MCxcbiAgMHgyN2I3MGE4NSwgMHg0NmQyMmZmYywgMHgyZTFiMjEzOCwgMHg1YzI2YzkyNixcbiAgMHg0ZDJjNmRmYywgMHg1YWM0MmFlZCwgMHg1MzM4MGQxMywgMHg5ZDk1YjNkZixcbiAgMHg2NTBhNzM1NCwgMHg4YmFmNjNkZSwgMHg3NjZhMGFiYiwgMHgzYzc3YjJhOCxcbiAgMHg4MWMyYzkyZSwgMHg0N2VkYWVlNiwgMHg5MjcyMmM4NSwgMHgxNDgyMzUzYixcbiAgMHhhMmJmZThhMSwgMHg0Y2YxMDM2NCwgMHhhODFhNjY0YiwgMHhiYzQyMzAwMSxcbiAgMHhjMjRiOGI3MCwgMHhkMGY4OTc5MSwgMHhjNzZjNTFhMywgMHgwNjU0YmUzMCxcbiAgMHhkMTkyZTgxOSwgMHhkNmVmNTIxOCwgMHhkNjk5MDYyNCwgMHg1NTY1YTkxMCxcbiAgMHhmNDBlMzU4NSwgMHg1NzcxMjAyYSwgMHgxMDZhYTA3MCwgMHgzMmJiZDFiOCxcbiAgMHgxOWE0YzExNiwgMHhiOGQyZDBjOCwgMHgxZTM3NmMwOCwgMHg1MTQxYWI1MyxcbiAgMHgyNzQ4Nzc0YywgMHhkZjhlZWI5OSwgMHgzNGIwYmNiNSwgMHhlMTliNDhhOCxcbiAgMHgzOTFjMGNiMywgMHhjNWM5NWE2MywgMHg0ZWQ4YWE0YSwgMHhlMzQxOGFjYixcbiAgMHg1YjljY2E0ZiwgMHg3NzYzZTM3MywgMHg2ODJlNmZmMywgMHhkNmIyYjhhMyxcbiAgMHg3NDhmODJlZSwgMHg1ZGVmYjJmYywgMHg3OGE1NjM2ZiwgMHg0MzE3MmY2MCxcbiAgMHg4NGM4NzgxNCwgMHhhMWYwYWI3MiwgMHg4Y2M3MDIwOCwgMHgxYTY0MzllYyxcbiAgMHg5MGJlZmZmYSwgMHgyMzYzMWUyOCwgMHhhNDUwNmNlYiwgMHhkZTgyYmRlOSxcbiAgMHhiZWY5YTNmNywgMHhiMmM2NzkxNSwgMHhjNjcxNzhmMiwgMHhlMzcyNTMyYixcbiAgMHhjYTI3M2VjZSwgMHhlYTI2NjE5YywgMHhkMTg2YjhjNywgMHgyMWMwYzIwNyxcbiAgMHhlYWRhN2RkNiwgMHhjZGUwZWIxZSwgMHhmNTdkNGY3ZiwgMHhlZTZlZDE3OCxcbiAgMHgwNmYwNjdhYSwgMHg3MjE3NmZiYSwgMHgwYTYzN2RjNSwgMHhhMmM4OThhNixcbiAgMHgxMTNmOTgwNCwgMHhiZWY5MGRhZSwgMHgxYjcxMGIzNSwgMHgxMzFjNDcxYixcbiAgMHgyOGRiNzdmNSwgMHgyMzA0N2Q4NCwgMHgzMmNhYWI3YiwgMHg0MGM3MjQ5MyxcbiAgMHgzYzllYmUwYSwgMHgxNWM5YmViYywgMHg0MzFkNjdjNCwgMHg5YzEwMGQ0YyxcbiAgMHg0Y2M1ZDRiZSwgMHhjYjNlNDJiNiwgMHg1OTdmMjk5YywgMHhmYzY1N2UyYSxcbiAgMHg1ZmNiNmZhYiwgMHgzYWQ2ZmFlYywgMHg2YzQ0MTk4YywgMHg0YTQ3NTgxN1xuXVxuXG52YXIgVyA9IG5ldyBBcnJheSgxNjApXG5cbmZ1bmN0aW9uIFNoYTUxMiAoKSB7XG4gIHRoaXMuaW5pdCgpXG4gIHRoaXMuX3cgPSBXXG5cbiAgSGFzaC5jYWxsKHRoaXMsIDEyOCwgMTEyKVxufVxuXG5pbmhlcml0cyhTaGE1MTIsIEhhc2gpXG5cblNoYTUxMi5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fYSA9IDB4NmEwOWU2NjcgfCAwXG4gIHRoaXMuX2IgPSAweGJiNjdhZTg1IHwgMFxuICB0aGlzLl9jID0gMHgzYzZlZjM3MiB8IDBcbiAgdGhpcy5fZCA9IDB4YTU0ZmY1M2EgfCAwXG4gIHRoaXMuX2UgPSAweDUxMGU1MjdmIHwgMFxuICB0aGlzLl9mID0gMHg5YjA1Njg4YyB8IDBcbiAgdGhpcy5fZyA9IDB4MWY4M2Q5YWIgfCAwXG4gIHRoaXMuX2ggPSAweDViZTBjZDE5IHwgMFxuXG4gIHRoaXMuX2FsID0gMHhmM2JjYzkwOCB8IDBcbiAgdGhpcy5fYmwgPSAweDg0Y2FhNzNiIHwgMFxuICB0aGlzLl9jbCA9IDB4ZmU5NGY4MmIgfCAwXG4gIHRoaXMuX2RsID0gMHg1ZjFkMzZmMSB8IDBcbiAgdGhpcy5fZWwgPSAweGFkZTY4MmQxIHwgMFxuICB0aGlzLl9mbCA9IDB4MmIzZTZjMWYgfCAwXG4gIHRoaXMuX2dsID0gMHhmYjQxYmQ2YiB8IDBcbiAgdGhpcy5faGwgPSAweDEzN2UyMTc5IHwgMFxuXG4gIHJldHVybiB0aGlzXG59XG5cbmZ1bmN0aW9uIENoICh4LCB5LCB6KSB7XG4gIHJldHVybiB6IF4gKHggJiAoeSBeIHopKVxufVxuXG5mdW5jdGlvbiBNYWogKHgsIHksIHopIHtcbiAgcmV0dXJuICh4ICYgeSkgfCAoeiAmICh4IHwgeSkpXG59XG5cbmZ1bmN0aW9uIFNpZ21hMCAoeCwgeGwpIHtcbiAgcmV0dXJuICh4ID4+PiAyOCB8IHhsIDw8IDQpIF4gKHhsID4+PiAyIHwgeCA8PCAzMCkgXiAoeGwgPj4+IDcgfCB4IDw8IDI1KVxufVxuXG5mdW5jdGlvbiBTaWdtYTEgKHgsIHhsKSB7XG4gIHJldHVybiAoeCA+Pj4gMTQgfCB4bCA8PCAxOCkgXiAoeCA+Pj4gMTggfCB4bCA8PCAxNCkgXiAoeGwgPj4+IDkgfCB4IDw8IDIzKVxufVxuXG5mdW5jdGlvbiBHYW1tYTAgKHgsIHhsKSB7XG4gIHJldHVybiAoeCA+Pj4gMSB8IHhsIDw8IDMxKSBeICh4ID4+PiA4IHwgeGwgPDwgMjQpIF4gKHggPj4+IDcpXG59XG5cbmZ1bmN0aW9uIEdhbW1hMGwgKHgsIHhsKSB7XG4gIHJldHVybiAoeCA+Pj4gMSB8IHhsIDw8IDMxKSBeICh4ID4+PiA4IHwgeGwgPDwgMjQpIF4gKHggPj4+IDcgfCB4bCA8PCAyNSlcbn1cblxuZnVuY3Rpb24gR2FtbWExICh4LCB4bCkge1xuICByZXR1cm4gKHggPj4+IDE5IHwgeGwgPDwgMTMpIF4gKHhsID4+PiAyOSB8IHggPDwgMykgXiAoeCA+Pj4gNilcbn1cblxuZnVuY3Rpb24gR2FtbWExbCAoeCwgeGwpIHtcbiAgcmV0dXJuICh4ID4+PiAxOSB8IHhsIDw8IDEzKSBeICh4bCA+Pj4gMjkgfCB4IDw8IDMpIF4gKHggPj4+IDYgfCB4bCA8PCAyNilcbn1cblxuU2hhNTEyLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKE0pIHtcbiAgdmFyIFcgPSB0aGlzLl93XG5cbiAgdmFyIGEgPSB0aGlzLl9hIHwgMFxuICB2YXIgYiA9IHRoaXMuX2IgfCAwXG4gIHZhciBjID0gdGhpcy5fYyB8IDBcbiAgdmFyIGQgPSB0aGlzLl9kIHwgMFxuICB2YXIgZSA9IHRoaXMuX2UgfCAwXG4gIHZhciBmID0gdGhpcy5fZiB8IDBcbiAgdmFyIGcgPSB0aGlzLl9nIHwgMFxuICB2YXIgaCA9IHRoaXMuX2ggfCAwXG5cbiAgdmFyIGFsID0gdGhpcy5fYWwgfCAwXG4gIHZhciBibCA9IHRoaXMuX2JsIHwgMFxuICB2YXIgY2wgPSB0aGlzLl9jbCB8IDBcbiAgdmFyIGRsID0gdGhpcy5fZGwgfCAwXG4gIHZhciBlbCA9IHRoaXMuX2VsIHwgMFxuICB2YXIgZmwgPSB0aGlzLl9mbCB8IDBcbiAgdmFyIGdsID0gdGhpcy5fZ2wgfCAwXG4gIHZhciBobCA9IHRoaXMuX2hsIHwgMFxuXG4gIHZhciBpID0gMFxuICB2YXIgaiA9IDBcbiAgdmFyIFdpLCBXaWxcbiAgZnVuY3Rpb24gY2FsY1cgKCkge1xuICAgIHZhciB4ID0gV1tqIC0gMTUgKiAyXVxuICAgIHZhciB4bCA9IFdbaiAtIDE1ICogMiArIDFdXG4gICAgdmFyIGdhbW1hMCA9IEdhbW1hMCh4LCB4bClcbiAgICB2YXIgZ2FtbWEwbCA9IEdhbW1hMGwoeGwsIHgpXG5cbiAgICB4ID0gV1tqIC0gMiAqIDJdXG4gICAgeGwgPSBXW2ogLSAyICogMiArIDFdXG4gICAgdmFyIGdhbW1hMSA9IEdhbW1hMSh4LCB4bClcbiAgICB2YXIgZ2FtbWExbCA9IEdhbW1hMWwoeGwsIHgpXG5cbiAgICAvLyBXW2ldID0gZ2FtbWEwICsgV1tpIC0gN10gKyBnYW1tYTEgKyBXW2kgLSAxNl1cbiAgICB2YXIgV2k3ID0gV1tqIC0gNyAqIDJdXG4gICAgdmFyIFdpN2wgPSBXW2ogLSA3ICogMiArIDFdXG5cbiAgICB2YXIgV2kxNiA9IFdbaiAtIDE2ICogMl1cbiAgICB2YXIgV2kxNmwgPSBXW2ogLSAxNiAqIDIgKyAxXVxuXG4gICAgV2lsID0gZ2FtbWEwbCArIFdpN2xcbiAgICBXaSA9IGdhbW1hMCArIFdpNyArICgoV2lsID4+PiAwKSA8IChnYW1tYTBsID4+PiAwKSA/IDEgOiAwKVxuICAgIFdpbCA9IFdpbCArIGdhbW1hMWxcbiAgICBXaSA9IFdpICsgZ2FtbWExICsgKChXaWwgPj4+IDApIDwgKGdhbW1hMWwgPj4+IDApID8gMSA6IDApXG4gICAgV2lsID0gV2lsICsgV2kxNmxcbiAgICBXaSA9IFdpICsgV2kxNiArICgoV2lsID4+PiAwKSA8IChXaTE2bCA+Pj4gMCkgPyAxIDogMClcbiAgfVxuXG4gIGZ1bmN0aW9uIGxvb3AgKCkge1xuICAgIFdbal0gPSBXaVxuICAgIFdbaiArIDFdID0gV2lsXG5cbiAgICB2YXIgbWFqID0gTWFqKGEsIGIsIGMpXG4gICAgdmFyIG1hamwgPSBNYWooYWwsIGJsLCBjbClcblxuICAgIHZhciBzaWdtYTBoID0gU2lnbWEwKGEsIGFsKVxuICAgIHZhciBzaWdtYTBsID0gU2lnbWEwKGFsLCBhKVxuICAgIHZhciBzaWdtYTFoID0gU2lnbWExKGUsIGVsKVxuICAgIHZhciBzaWdtYTFsID0gU2lnbWExKGVsLCBlKVxuXG4gICAgLy8gdDEgPSBoICsgc2lnbWExICsgY2ggKyBLW2ldICsgV1tpXVxuICAgIHZhciBLaSA9IEtbal1cbiAgICB2YXIgS2lsID0gS1tqICsgMV1cblxuICAgIHZhciBjaCA9IENoKGUsIGYsIGcpXG4gICAgdmFyIGNobCA9IENoKGVsLCBmbCwgZ2wpXG5cbiAgICB2YXIgdDFsID0gaGwgKyBzaWdtYTFsXG4gICAgdmFyIHQxID0gaCArIHNpZ21hMWggKyAoKHQxbCA+Pj4gMCkgPCAoaGwgPj4+IDApID8gMSA6IDApXG4gICAgdDFsID0gdDFsICsgY2hsXG4gICAgdDEgPSB0MSArIGNoICsgKCh0MWwgPj4+IDApIDwgKGNobCA+Pj4gMCkgPyAxIDogMClcbiAgICB0MWwgPSB0MWwgKyBLaWxcbiAgICB0MSA9IHQxICsgS2kgKyAoKHQxbCA+Pj4gMCkgPCAoS2lsID4+PiAwKSA/IDEgOiAwKVxuICAgIHQxbCA9IHQxbCArIFdpbFxuICAgIHQxID0gdDEgKyBXaSArICgodDFsID4+PiAwKSA8IChXaWwgPj4+IDApID8gMSA6IDApXG5cbiAgICAvLyB0MiA9IHNpZ21hMCArIG1halxuICAgIHZhciB0MmwgPSBzaWdtYTBsICsgbWFqbFxuICAgIHZhciB0MiA9IHNpZ21hMGggKyBtYWogKyAoKHQybCA+Pj4gMCkgPCAoc2lnbWEwbCA+Pj4gMCkgPyAxIDogMClcblxuICAgIGggPSBnXG4gICAgaGwgPSBnbFxuICAgIGcgPSBmXG4gICAgZ2wgPSBmbFxuICAgIGYgPSBlXG4gICAgZmwgPSBlbFxuICAgIGVsID0gKGRsICsgdDFsKSB8IDBcbiAgICBlID0gKGQgKyB0MSArICgoZWwgPj4+IDApIDwgKGRsID4+PiAwKSA/IDEgOiAwKSkgfCAwXG4gICAgZCA9IGNcbiAgICBkbCA9IGNsXG4gICAgYyA9IGJcbiAgICBjbCA9IGJsXG4gICAgYiA9IGFcbiAgICBibCA9IGFsXG4gICAgYWwgPSAodDFsICsgdDJsKSB8IDBcbiAgICBhID0gKHQxICsgdDIgKyAoKGFsID4+PiAwKSA8ICh0MWwgPj4+IDApID8gMSA6IDApKSB8IDBcblxuICAgIGkrK1xuICAgIGogKz0gMlxuICB9XG5cbiAgd2hpbGUgKGkgPCAxNikge1xuICAgIFdpID0gTS5yZWFkSW50MzJCRShqICogNClcbiAgICBXaWwgPSBNLnJlYWRJbnQzMkJFKGogKiA0ICsgNClcblxuICAgIGxvb3AoKVxuICB9XG5cbiAgd2hpbGUgKGkgPCA4MCkge1xuICAgIGNhbGNXKClcbiAgICBsb29wKClcbiAgfVxuXG4gIHRoaXMuX2FsID0gKHRoaXMuX2FsICsgYWwpIHwgMFxuICB0aGlzLl9ibCA9ICh0aGlzLl9ibCArIGJsKSB8IDBcbiAgdGhpcy5fY2wgPSAodGhpcy5fY2wgKyBjbCkgfCAwXG4gIHRoaXMuX2RsID0gKHRoaXMuX2RsICsgZGwpIHwgMFxuICB0aGlzLl9lbCA9ICh0aGlzLl9lbCArIGVsKSB8IDBcbiAgdGhpcy5fZmwgPSAodGhpcy5fZmwgKyBmbCkgfCAwXG4gIHRoaXMuX2dsID0gKHRoaXMuX2dsICsgZ2wpIHwgMFxuICB0aGlzLl9obCA9ICh0aGlzLl9obCArIGhsKSB8IDBcblxuICB0aGlzLl9hID0gKHRoaXMuX2EgKyBhICsgKCh0aGlzLl9hbCA+Pj4gMCkgPCAoYWwgPj4+IDApID8gMSA6IDApKSB8IDBcbiAgdGhpcy5fYiA9ICh0aGlzLl9iICsgYiArICgodGhpcy5fYmwgPj4+IDApIDwgKGJsID4+PiAwKSA/IDEgOiAwKSkgfCAwXG4gIHRoaXMuX2MgPSAodGhpcy5fYyArIGMgKyAoKHRoaXMuX2NsID4+PiAwKSA8IChjbCA+Pj4gMCkgPyAxIDogMCkpIHwgMFxuICB0aGlzLl9kID0gKHRoaXMuX2QgKyBkICsgKCh0aGlzLl9kbCA+Pj4gMCkgPCAoZGwgPj4+IDApID8gMSA6IDApKSB8IDBcbiAgdGhpcy5fZSA9ICh0aGlzLl9lICsgZSArICgodGhpcy5fZWwgPj4+IDApIDwgKGVsID4+PiAwKSA/IDEgOiAwKSkgfCAwXG4gIHRoaXMuX2YgPSAodGhpcy5fZiArIGYgKyAoKHRoaXMuX2ZsID4+PiAwKSA8IChmbCA+Pj4gMCkgPyAxIDogMCkpIHwgMFxuICB0aGlzLl9nID0gKHRoaXMuX2cgKyBnICsgKCh0aGlzLl9nbCA+Pj4gMCkgPCAoZ2wgPj4+IDApID8gMSA6IDApKSB8IDBcbiAgdGhpcy5faCA9ICh0aGlzLl9oICsgaCArICgodGhpcy5faGwgPj4+IDApIDwgKGhsID4+PiAwKSA/IDEgOiAwKSkgfCAwXG59XG5cblNoYTUxMi5wcm90b3R5cGUuX2hhc2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBIID0gbmV3IEJ1ZmZlcig2NClcblxuICBmdW5jdGlvbiB3cml0ZUludDY0QkUgKGgsIGwsIG9mZnNldCkge1xuICAgIEgud3JpdGVJbnQzMkJFKGgsIG9mZnNldClcbiAgICBILndyaXRlSW50MzJCRShsLCBvZmZzZXQgKyA0KVxuICB9XG5cbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2EsIHRoaXMuX2FsLCAwKVxuICB3cml0ZUludDY0QkUodGhpcy5fYiwgdGhpcy5fYmwsIDgpXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9jLCB0aGlzLl9jbCwgMTYpXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9kLCB0aGlzLl9kbCwgMjQpXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9lLCB0aGlzLl9lbCwgMzIpXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9mLCB0aGlzLl9mbCwgNDApXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9nLCB0aGlzLl9nbCwgNDgpXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9oLCB0aGlzLl9obCwgNTYpXG5cbiAgcmV0dXJuIEhcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTaGE1MTJcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBjcmVhdGVIYXNoID0gcmVxdWlyZSgnY3JlYXRlLWhhc2gvYnJvd3NlcicpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnc3RyZWFtJykuVHJhbnNmb3JtXG5cbnZhciBaRVJPUyA9IG5ldyBCdWZmZXIoMTI4KVxuWkVST1MuZmlsbCgwKVxuXG5mdW5jdGlvbiBIbWFjKGFsZywga2V5KSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMpXG4gIGFsZyA9IGFsZy50b0xvd2VyQ2FzZSgpXG4gIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykge1xuICAgIGtleSA9IG5ldyBCdWZmZXIoa2V5KVxuICB9XG5cbiAgdmFyIGJsb2Nrc2l6ZSA9IChhbGcgPT09ICdzaGE1MTInIHx8IGFsZyA9PT0gJ3NoYTM4NCcpID8gMTI4IDogNjRcblxuICB0aGlzLl9hbGcgPSBhbGdcbiAgdGhpcy5fa2V5ID0ga2V5XG5cbiAgaWYgKGtleS5sZW5ndGggPiBibG9ja3NpemUpIHtcbiAgICBrZXkgPSBjcmVhdGVIYXNoKGFsZykudXBkYXRlKGtleSkuZGlnZXN0KClcblxuICB9IGVsc2UgaWYgKGtleS5sZW5ndGggPCBibG9ja3NpemUpIHtcbiAgICBrZXkgPSBCdWZmZXIuY29uY2F0KFtrZXksIFpFUk9TXSwgYmxvY2tzaXplKVxuICB9XG5cbiAgdmFyIGlwYWQgPSB0aGlzLl9pcGFkID0gbmV3IEJ1ZmZlcihibG9ja3NpemUpXG4gIHZhciBvcGFkID0gdGhpcy5fb3BhZCA9IG5ldyBCdWZmZXIoYmxvY2tzaXplKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYmxvY2tzaXplOyBpKyspIHtcbiAgICBpcGFkW2ldID0ga2V5W2ldIF4gMHgzNlxuICAgIG9wYWRbaV0gPSBrZXlbaV0gXiAweDVDXG4gIH1cblxuICB0aGlzLl9oYXNoID0gY3JlYXRlSGFzaChhbGcpLnVwZGF0ZShpcGFkKVxufVxuXG5pbmhlcml0cyhIbWFjLCBUcmFuc2Zvcm0pXG5cbkhtYWMucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhLCBlbmMpIHtcbiAgdGhpcy5faGFzaC51cGRhdGUoZGF0YSwgZW5jKVxuXG4gIHJldHVybiB0aGlzXG59XG5cbkhtYWMucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoZGF0YSwgXywgbmV4dCkge1xuICB0aGlzLl9oYXNoLnVwZGF0ZShkYXRhKVxuXG4gIG5leHQoKVxufVxuXG5IbWFjLnByb3RvdHlwZS5fZmx1c2ggPSBmdW5jdGlvbiAobmV4dCkge1xuICB0aGlzLnB1c2godGhpcy5kaWdlc3QoKSlcblxuICBuZXh0KClcbn1cblxuSG1hYy5wcm90b3R5cGUuZGlnZXN0ID0gZnVuY3Rpb24gKGVuYykge1xuICB2YXIgaCA9IHRoaXMuX2hhc2guZGlnZXN0KClcblxuICByZXR1cm4gY3JlYXRlSGFzaCh0aGlzLl9hbGcpLnVwZGF0ZSh0aGlzLl9vcGFkKS51cGRhdGUoaCkuZGlnZXN0KGVuYylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGVIbWFjKGFsZywga2V5KSB7XG4gIHJldHVybiBuZXcgSG1hYyhhbGcsIGtleSlcbn1cbiIsInZhciBnZW5lcmF0ZVByaW1lID0gcmVxdWlyZSgnLi9saWIvZ2VuZXJhdGVQcmltZScpO1xudmFyIHByaW1lcyA9IHJlcXVpcmUoJy4vbGliL3ByaW1lcycpO1xuXG52YXIgREggPSByZXF1aXJlKCcuL2xpYi9kaCcpO1xuXG5mdW5jdGlvbiBnZXREaWZmaWVIZWxsbWFuKG1vZCkge1xuICB2YXIgcHJpbWUgPSBuZXcgQnVmZmVyKHByaW1lc1ttb2RdLnByaW1lLCAnaGV4Jyk7XG4gIHZhciBnZW4gPSBuZXcgQnVmZmVyKHByaW1lc1ttb2RdLmdlbiwgJ2hleCcpO1xuXG4gIHJldHVybiBuZXcgREgocHJpbWUsIGdlbik7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZURpZmZpZUhlbGxtYW4ocHJpbWUsIGVuYywgZ2VuZXJhdG9yLCBnZW5jKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoZW5jKSB8fCAodHlwZW9mIGVuYyA9PT0gJ3N0cmluZycgJiYgWydoZXgnLCAnYmluYXJ5JywgJ2Jhc2U2NCddLmluZGV4T2YoZW5jKSA9PT0gLTEpKSB7XG4gICAgZ2VuYyA9IGdlbmVyYXRvcjtcbiAgICBnZW5lcmF0b3IgPSBlbmM7XG4gICAgZW5jID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgZW5jID0gZW5jIHx8ICdiaW5hcnknO1xuICBnZW5jID0gZ2VuYyB8fCAnYmluYXJ5JztcbiAgZ2VuZXJhdG9yID0gZ2VuZXJhdG9yIHx8IG5ldyBCdWZmZXIoWzJdKTtcblxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihnZW5lcmF0b3IpKSB7XG4gICAgZ2VuZXJhdG9yID0gbmV3IEJ1ZmZlcihnZW5lcmF0b3IsIGdlbmMpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBwcmltZSA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gbmV3IERIKGdlbmVyYXRlUHJpbWUocHJpbWUsIGdlbmVyYXRvciksIGdlbmVyYXRvciwgdHJ1ZSk7XG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihwcmltZSkpIHtcbiAgICBwcmltZSA9IG5ldyBCdWZmZXIocHJpbWUsIGVuYyk7XG4gIH1cblxuICByZXR1cm4gbmV3IERIKHByaW1lLCBnZW5lcmF0b3IsIHRydWUpO1xufVxuXG5leHBvcnRzLkRpZmZpZUhlbGxtYW5Hcm91cCA9IGV4cG9ydHMuY3JlYXRlRGlmZmllSGVsbG1hbkdyb3VwID0gZXhwb3J0cy5nZXREaWZmaWVIZWxsbWFuID0gZ2V0RGlmZmllSGVsbG1hbjtcbmV4cG9ydHMuY3JlYXRlRGlmZmllSGVsbG1hbiA9IGV4cG9ydHMuRGlmZmllSGVsbG1hbiA9IGNyZWF0ZURpZmZpZUhlbGxtYW47XG4iLCJ2YXIgQk4gPSByZXF1aXJlKCdibi5qcycpO1xudmFyIE1pbGxlclJhYmluID0gcmVxdWlyZSgnbWlsbGVyLXJhYmluJyk7XG52YXIgbWlsbGVyUmFiaW4gPSBuZXcgTWlsbGVyUmFiaW4oKTtcbnZhciBUV0VOVFlGT1VSID0gbmV3IEJOKDI0KTtcbnZhciBFTEVWRU4gPSBuZXcgQk4oMTEpO1xudmFyIFRFTiA9IG5ldyBCTigxMCk7XG52YXIgVEhSRUUgPSBuZXcgQk4oMyk7XG52YXIgU0VWRU4gPSBuZXcgQk4oNyk7XG52YXIgcHJpbWVzID0gcmVxdWlyZSgnLi9nZW5lcmF0ZVByaW1lJyk7XG52YXIgcmFuZG9tQnl0ZXMgPSByZXF1aXJlKCdyYW5kb21ieXRlcycpO1xubW9kdWxlLmV4cG9ydHMgPSBESDtcblxuZnVuY3Rpb24gc2V0UHVibGljS2V5KHB1YiwgZW5jKSB7XG4gIGVuYyA9IGVuYyB8fCAndXRmOCc7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHB1YikpIHtcbiAgICBwdWIgPSBuZXcgQnVmZmVyKHB1YiwgZW5jKTtcbiAgfVxuICB0aGlzLl9wdWIgPSBuZXcgQk4ocHViKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIHNldFByaXZhdGVLZXkocHJpdiwgZW5jKSB7XG4gIGVuYyA9IGVuYyB8fCAndXRmOCc7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHByaXYpKSB7XG4gICAgcHJpdiA9IG5ldyBCdWZmZXIocHJpdiwgZW5jKTtcbiAgfVxuICB0aGlzLl9wcml2ID0gbmV3IEJOKHByaXYpO1xuICByZXR1cm4gdGhpcztcbn1cblxudmFyIHByaW1lQ2FjaGUgPSB7fTtcbmZ1bmN0aW9uIGNoZWNrUHJpbWUocHJpbWUsIGdlbmVyYXRvcikge1xuICB2YXIgZ2VuID0gZ2VuZXJhdG9yLnRvU3RyaW5nKCdoZXgnKTtcbiAgdmFyIGhleCA9IFtnZW4sIHByaW1lLnRvU3RyaW5nKDE2KV0uam9pbignXycpO1xuICBpZiAoaGV4IGluIHByaW1lQ2FjaGUpIHtcbiAgICByZXR1cm4gcHJpbWVDYWNoZVtoZXhdO1xuICB9XG4gIHZhciBlcnJvciA9IDA7XG5cbiAgaWYgKHByaW1lLmlzRXZlbigpIHx8XG4gICAgIXByaW1lcy5zaW1wbGVTaWV2ZSB8fFxuICAgICFwcmltZXMuZmVybWF0VGVzdChwcmltZSkgfHxcbiAgICAhbWlsbGVyUmFiaW4udGVzdChwcmltZSkpIHtcbiAgICAvL25vdCBhIHByaW1lIHNvICsxXG4gICAgZXJyb3IgKz0gMTtcblxuICAgIGlmIChnZW4gPT09ICcwMicgfHwgZ2VuID09PSAnMDUnKSB7XG4gICAgICAvLyB3ZSdkIGJlIGFibGUgdG8gY2hlY2sgdGhlIGdlbmVyYXRvclxuICAgICAgLy8gaXQgd291bGQgZmFpbCBzbyArOFxuICAgICAgZXJyb3IgKz0gODtcbiAgICB9IGVsc2Uge1xuICAgICAgLy93ZSB3b3VsZG4ndCBiZSBhYmxlIHRvIHRlc3QgdGhlIGdlbmVyYXRvclxuICAgICAgLy8gc28gKzRcbiAgICAgIGVycm9yICs9IDQ7XG4gICAgfVxuICAgIHByaW1lQ2FjaGVbaGV4XSA9IGVycm9yO1xuICAgIHJldHVybiBlcnJvcjtcbiAgfVxuICBpZiAoIW1pbGxlclJhYmluLnRlc3QocHJpbWUuc2hybigxKSkpIHtcbiAgICAvL25vdCBhIHNhZmUgcHJpbWVcbiAgICBlcnJvciArPSAyO1xuICB9XG4gIHZhciByZW07XG4gIHN3aXRjaCAoZ2VuKSB7XG4gICAgY2FzZSAnMDInOlxuICAgICAgaWYgKHByaW1lLm1vZChUV0VOVFlGT1VSKS5jbXAoRUxFVkVOKSkge1xuICAgICAgICAvLyB1bnN1aWRhYmxlIGdlbmVyYXRvclxuICAgICAgICBlcnJvciArPSA4O1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnMDUnOlxuICAgICAgcmVtID0gcHJpbWUubW9kKFRFTik7XG4gICAgICBpZiAocmVtLmNtcChUSFJFRSkgJiYgcmVtLmNtcChTRVZFTikpIHtcbiAgICAgICAgLy8gcHJpbWUgbW9kIDEwIG5lZWRzIHRvIGVxdWFsIDMgb3IgN1xuICAgICAgICBlcnJvciArPSA4O1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGVycm9yICs9IDQ7XG4gIH1cbiAgcHJpbWVDYWNoZVtoZXhdID0gZXJyb3I7XG4gIHJldHVybiBlcnJvcjtcbn1cblxuZnVuY3Rpb24gREgocHJpbWUsIGdlbmVyYXRvciwgbWFsbGVhYmxlKSB7XG4gIHRoaXMuc2V0R2VuZXJhdG9yKGdlbmVyYXRvcik7XG4gIHRoaXMuX19wcmltZSA9IG5ldyBCTihwcmltZSk7XG4gIHRoaXMuX3ByaW1lID0gQk4ubW9udCh0aGlzLl9fcHJpbWUpO1xuICB0aGlzLl9wcmltZUxlbiA9IHByaW1lLmxlbmd0aDtcbiAgdGhpcy5fcHViID0gdW5kZWZpbmVkO1xuICB0aGlzLl9wcml2ID0gdW5kZWZpbmVkO1xuICB0aGlzLl9wcmltZUNvZGUgPSB1bmRlZmluZWQ7XG4gIGlmIChtYWxsZWFibGUpIHtcbiAgICB0aGlzLnNldFB1YmxpY0tleSA9IHNldFB1YmxpY0tleTtcbiAgICB0aGlzLnNldFByaXZhdGVLZXkgPSBzZXRQcml2YXRlS2V5O1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX3ByaW1lQ29kZSA9IDg7XG4gIH1cbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShESC5wcm90b3R5cGUsICd2ZXJpZnlFcnJvcicsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLl9wcmltZUNvZGUgIT09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLl9wcmltZUNvZGUgPSBjaGVja1ByaW1lKHRoaXMuX19wcmltZSwgdGhpcy5fX2dlbik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9wcmltZUNvZGU7XG4gIH1cbn0pO1xuREgucHJvdG90eXBlLmdlbmVyYXRlS2V5cyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLl9wcml2KSB7XG4gICAgdGhpcy5fcHJpdiA9IG5ldyBCTihyYW5kb21CeXRlcyh0aGlzLl9wcmltZUxlbikpO1xuICB9XG4gIHRoaXMuX3B1YiA9IHRoaXMuX2dlbi50b1JlZCh0aGlzLl9wcmltZSkucmVkUG93KHRoaXMuX3ByaXYpLmZyb21SZWQoKTtcbiAgcmV0dXJuIHRoaXMuZ2V0UHVibGljS2V5KCk7XG59O1xuXG5ESC5wcm90b3R5cGUuY29tcHV0ZVNlY3JldCA9IGZ1bmN0aW9uIChvdGhlcikge1xuICBvdGhlciA9IG5ldyBCTihvdGhlcik7XG4gIG90aGVyID0gb3RoZXIudG9SZWQodGhpcy5fcHJpbWUpO1xuICB2YXIgc2VjcmV0ID0gb3RoZXIucmVkUG93KHRoaXMuX3ByaXYpLmZyb21SZWQoKTtcbiAgdmFyIG91dCA9IG5ldyBCdWZmZXIoc2VjcmV0LnRvQXJyYXkoKSk7XG4gIHZhciBwcmltZSA9IHRoaXMuZ2V0UHJpbWUoKTtcbiAgaWYgKG91dC5sZW5ndGggPCBwcmltZS5sZW5ndGgpIHtcbiAgICB2YXIgZnJvbnQgPSBuZXcgQnVmZmVyKHByaW1lLmxlbmd0aCAtIG91dC5sZW5ndGgpO1xuICAgIGZyb250LmZpbGwoMCk7XG4gICAgb3V0ID0gQnVmZmVyLmNvbmNhdChbZnJvbnQsIG91dF0pO1xuICB9XG4gIHJldHVybiBvdXQ7XG59O1xuXG5ESC5wcm90b3R5cGUuZ2V0UHVibGljS2V5ID0gZnVuY3Rpb24gZ2V0UHVibGljS2V5KGVuYykge1xuICByZXR1cm4gZm9ybWF0UmV0dXJuVmFsdWUodGhpcy5fcHViLCBlbmMpO1xufTtcblxuREgucHJvdG90eXBlLmdldFByaXZhdGVLZXkgPSBmdW5jdGlvbiBnZXRQcml2YXRlS2V5KGVuYykge1xuICByZXR1cm4gZm9ybWF0UmV0dXJuVmFsdWUodGhpcy5fcHJpdiwgZW5jKTtcbn07XG5cbkRILnByb3RvdHlwZS5nZXRQcmltZSA9IGZ1bmN0aW9uIChlbmMpIHtcbiAgcmV0dXJuIGZvcm1hdFJldHVyblZhbHVlKHRoaXMuX19wcmltZSwgZW5jKTtcbn07XG5cbkRILnByb3RvdHlwZS5nZXRHZW5lcmF0b3IgPSBmdW5jdGlvbiAoZW5jKSB7XG4gIHJldHVybiBmb3JtYXRSZXR1cm5WYWx1ZSh0aGlzLl9nZW4sIGVuYyk7XG59O1xuXG5ESC5wcm90b3R5cGUuc2V0R2VuZXJhdG9yID0gZnVuY3Rpb24gKGdlbiwgZW5jKSB7XG4gIGVuYyA9IGVuYyB8fCAndXRmOCc7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGdlbikpIHtcbiAgICBnZW4gPSBuZXcgQnVmZmVyKGdlbiwgZW5jKTtcbiAgfVxuICB0aGlzLl9fZ2VuID0gZ2VuO1xuICB0aGlzLl9nZW4gPSBuZXcgQk4oZ2VuKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBmb3JtYXRSZXR1cm5WYWx1ZShibiwgZW5jKSB7XG4gIHZhciBidWYgPSBuZXcgQnVmZmVyKGJuLnRvQXJyYXkoKSk7XG4gIGlmICghZW5jKSB7XG4gICAgcmV0dXJuIGJ1ZjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYnVmLnRvU3RyaW5nKGVuYyk7XG4gIH1cbn1cbiIsInZhciByYW5kb21CeXRlcyA9IHJlcXVpcmUoJ3JhbmRvbWJ5dGVzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZpbmRQcmltZTtcbmZpbmRQcmltZS5zaW1wbGVTaWV2ZSA9IHNpbXBsZVNpZXZlO1xuZmluZFByaW1lLmZlcm1hdFRlc3QgPSBmZXJtYXRUZXN0O1xudmFyIEJOID0gcmVxdWlyZSgnYm4uanMnKTtcbnZhciBUV0VOVFlGT1VSID0gbmV3IEJOKDI0KTtcbnZhciBNaWxsZXJSYWJpbiA9IHJlcXVpcmUoJ21pbGxlci1yYWJpbicpO1xudmFyIG1pbGxlclJhYmluID0gbmV3IE1pbGxlclJhYmluKCk7XG52YXIgT05FID0gbmV3IEJOKDEpO1xudmFyIFRXTyA9IG5ldyBCTigyKTtcbnZhciBGSVZFID0gbmV3IEJOKDUpO1xudmFyIFNJWFRFRU4gPSBuZXcgQk4oMTYpO1xudmFyIEVJR0hUID0gbmV3IEJOKDgpO1xudmFyIFRFTiA9IG5ldyBCTigxMCk7XG52YXIgVEhSRUUgPSBuZXcgQk4oMyk7XG52YXIgU0VWRU4gPSBuZXcgQk4oNyk7XG52YXIgRUxFVkVOID0gbmV3IEJOKDExKTtcbnZhciBGT1VSID0gbmV3IEJOKDQpO1xudmFyIFRXRUxWRSA9IG5ldyBCTigxMik7XG52YXIgcHJpbWVzID0gbnVsbDtcblxuZnVuY3Rpb24gX2dldFByaW1lcygpIHtcbiAgaWYgKHByaW1lcyAhPT0gbnVsbClcbiAgICByZXR1cm4gcHJpbWVzO1xuXG4gIHZhciBsaW1pdCA9IDB4MTAwMDAwO1xuICB2YXIgcmVzID0gW107XG4gIHJlc1swXSA9IDI7XG4gIGZvciAodmFyIGkgPSAxLCBrID0gMzsgayA8IGxpbWl0OyBrICs9IDIpIHtcbiAgICB2YXIgc3FydCA9IE1hdGguY2VpbChNYXRoLnNxcnQoaykpO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgaSAmJiByZXNbal0gPD0gc3FydDsgaisrKVxuICAgICAgaWYgKGsgJSByZXNbal0gPT09IDApXG4gICAgICAgIGJyZWFrO1xuXG4gICAgaWYgKGkgIT09IGogJiYgcmVzW2pdIDw9IHNxcnQpXG4gICAgICBjb250aW51ZTtcblxuICAgIHJlc1tpKytdID0gaztcbiAgfVxuICBwcmltZXMgPSByZXM7XG4gIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIHNpbXBsZVNpZXZlKHApIHtcbiAgdmFyIHByaW1lcyA9IF9nZXRQcmltZXMoKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHByaW1lcy5sZW5ndGg7IGkrKylcbiAgICBpZiAocC5tb2RuKHByaW1lc1tpXSkgPT09IDApIHtcbiAgICAgIGlmIChwLmNtcG4ocHJpbWVzW2ldKSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGZlcm1hdFRlc3QocCkge1xuICB2YXIgcmVkID0gQk4ubW9udChwKTtcbiAgcmV0dXJuIFRXTy50b1JlZChyZWQpLnJlZFBvdyhwLnN1Ym4oMSkpLmZyb21SZWQoKS5jbXBuKDEpID09PSAwO1xufVxuXG5mdW5jdGlvbiBmaW5kUHJpbWUoYml0cywgZ2VuKSB7XG4gIGlmIChiaXRzIDwgMTYpIHtcbiAgICAvLyB0aGlzIGlzIHdoYXQgb3BlbnNzbCBkb2VzXG4gICAgaWYgKGdlbiA9PT0gMiB8fCBnZW4gPT09IDUpIHtcbiAgICAgIHJldHVybiBuZXcgQk4oWzB4OGMsIDB4N2JdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBCTihbMHg4YywgMHgyN10pO1xuICAgIH1cbiAgfVxuICBnZW4gPSBuZXcgQk4oZ2VuKTtcblxuICB2YXIgbnVtLCBuMjtcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIG51bSA9IG5ldyBCTihyYW5kb21CeXRlcyhNYXRoLmNlaWwoYml0cyAvIDgpKSk7XG4gICAgd2hpbGUgKG51bS5iaXRMZW5ndGgoKSA+IGJpdHMpIHtcbiAgICAgIG51bS5pc2hybigxKTtcbiAgICB9XG4gICAgaWYgKG51bS5pc0V2ZW4oKSkge1xuICAgICAgbnVtLmlhZGQoT05FKTtcbiAgICB9XG4gICAgaWYgKCFudW0udGVzdG4oMSkpIHtcbiAgICAgIG51bS5pYWRkKFRXTyk7XG4gICAgfVxuICAgIGlmICghZ2VuLmNtcChUV08pKSB7XG4gICAgICB3aGlsZSAobnVtLm1vZChUV0VOVFlGT1VSKS5jbXAoRUxFVkVOKSkge1xuICAgICAgICBudW0uaWFkZChGT1VSKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFnZW4uY21wKEZJVkUpKSB7XG4gICAgICB3aGlsZSAobnVtLm1vZChURU4pLmNtcChUSFJFRSkpIHtcbiAgICAgICAgbnVtLmlhZGQoRk9VUik7XG4gICAgICB9XG4gICAgfVxuICAgIG4yID0gbnVtLnNocm4oMSk7XG4gICAgaWYgKHNpbXBsZVNpZXZlKG4yKSAmJiBzaW1wbGVTaWV2ZShudW0pICYmXG4gICAgICBmZXJtYXRUZXN0KG4yKSAmJiBmZXJtYXRUZXN0KG51bSkgJiZcbiAgICAgIG1pbGxlclJhYmluLnRlc3QobjIpICYmIG1pbGxlclJhYmluLnRlc3QobnVtKSkge1xuICAgICAgcmV0dXJuIG51bTtcbiAgICB9XG4gIH1cblxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICAgIFwibW9kcDFcIjoge1xuICAgICAgICBcImdlblwiOiBcIjAyXCIsXG4gICAgICAgIFwicHJpbWVcIjogXCJmZmZmZmZmZmZmZmZmZmZmYzkwZmRhYTIyMTY4YzIzNGM0YzY2MjhiODBkYzFjZDEyOTAyNGUwODhhNjdjYzc0MDIwYmJlYTYzYjEzOWIyMjUxNGEwODc5OGUzNDA0ZGRlZjk1MTliM2NkM2E0MzFiMzAyYjBhNmRmMjVmMTQzNzRmZTEzNTZkNmQ1MWMyNDVlNDg1YjU3NjYyNWU3ZWM2ZjQ0YzQyZTlhNjNhMzYyMGZmZmZmZmZmZmZmZmZmZmZcIlxuICAgIH0sXG4gICAgXCJtb2RwMlwiOiB7XG4gICAgICAgIFwiZ2VuXCI6IFwiMDJcIixcbiAgICAgICAgXCJwcmltZVwiOiBcImZmZmZmZmZmZmZmZmZmZmZjOTBmZGFhMjIxNjhjMjM0YzRjNjYyOGI4MGRjMWNkMTI5MDI0ZTA4OGE2N2NjNzQwMjBiYmVhNjNiMTM5YjIyNTE0YTA4Nzk4ZTM0MDRkZGVmOTUxOWIzY2QzYTQzMWIzMDJiMGE2ZGYyNWYxNDM3NGZlMTM1NmQ2ZDUxYzI0NWU0ODViNTc2NjI1ZTdlYzZmNDRjNDJlOWE2MzdlZDZiMGJmZjVjYjZmNDA2YjdlZGVlMzg2YmZiNWE4OTlmYTVhZTlmMjQxMTdjNGIxZmU2NDkyODY2NTFlY2U2NTM4MWZmZmZmZmZmZmZmZmZmZmZcIlxuICAgIH0sXG4gICAgXCJtb2RwNVwiOiB7XG4gICAgICAgIFwiZ2VuXCI6IFwiMDJcIixcbiAgICAgICAgXCJwcmltZVwiOiBcImZmZmZmZmZmZmZmZmZmZmZjOTBmZGFhMjIxNjhjMjM0YzRjNjYyOGI4MGRjMWNkMTI5MDI0ZTA4OGE2N2NjNzQwMjBiYmVhNjNiMTM5YjIyNTE0YTA4Nzk4ZTM0MDRkZGVmOTUxOWIzY2QzYTQzMWIzMDJiMGE2ZGYyNWYxNDM3NGZlMTM1NmQ2ZDUxYzI0NWU0ODViNTc2NjI1ZTdlYzZmNDRjNDJlOWE2MzdlZDZiMGJmZjVjYjZmNDA2YjdlZGVlMzg2YmZiNWE4OTlmYTVhZTlmMjQxMTdjNGIxZmU2NDkyODY2NTFlY2U0NWIzZGMyMDA3Y2I4YTE2M2JmMDU5OGRhNDgzNjFjNTVkMzlhNjkxNjNmYThmZDI0Y2Y1ZjgzNjU1ZDIzZGNhM2FkOTYxYzYyZjM1NjIwODU1MmJiOWVkNTI5MDc3MDk2OTY2ZDY3MGMzNTRlNGFiYzk4MDRmMTc0NmMwOGNhMjM3MzI3ZmZmZmZmZmZmZmZmZmZmZlwiXG4gICAgfSxcbiAgICBcIm1vZHAxNFwiOiB7XG4gICAgICAgIFwiZ2VuXCI6IFwiMDJcIixcbiAgICAgICAgXCJwcmltZVwiOiBcImZmZmZmZmZmZmZmZmZmZmZjOTBmZGFhMjIxNjhjMjM0YzRjNjYyOGI4MGRjMWNkMTI5MDI0ZTA4OGE2N2NjNzQwMjBiYmVhNjNiMTM5YjIyNTE0YTA4Nzk4ZTM0MDRkZGVmOTUxOWIzY2QzYTQzMWIzMDJiMGE2ZGYyNWYxNDM3NGZlMTM1NmQ2ZDUxYzI0NWU0ODViNTc2NjI1ZTdlYzZmNDRjNDJlOWE2MzdlZDZiMGJmZjVjYjZmNDA2YjdlZGVlMzg2YmZiNWE4OTlmYTVhZTlmMjQxMTdjNGIxZmU2NDkyODY2NTFlY2U0NWIzZGMyMDA3Y2I4YTE2M2JmMDU5OGRhNDgzNjFjNTVkMzlhNjkxNjNmYThmZDI0Y2Y1ZjgzNjU1ZDIzZGNhM2FkOTYxYzYyZjM1NjIwODU1MmJiOWVkNTI5MDc3MDk2OTY2ZDY3MGMzNTRlNGFiYzk4MDRmMTc0NmMwOGNhMTgyMTdjMzI5MDVlNDYyZTM2Y2UzYmUzOWU3NzJjMTgwZTg2MDM5YjI3ODNhMmVjMDdhMjhmYjVjNTVkZjA2ZjRjNTJjOWRlMmJjYmY2OTU1ODE3MTgzOTk1NDk3Y2VhOTU2YWU1MTVkMjI2MTg5OGZhMDUxMDE1NzI4ZTVhOGFhY2FhNjhmZmZmZmZmZmZmZmZmZmZmXCJcbiAgICB9LFxuICAgIFwibW9kcDE1XCI6IHtcbiAgICAgICAgXCJnZW5cIjogXCIwMlwiLFxuICAgICAgICBcInByaW1lXCI6IFwiZmZmZmZmZmZmZmZmZmZmZmM5MGZkYWEyMjE2OGMyMzRjNGM2NjI4YjgwZGMxY2QxMjkwMjRlMDg4YTY3Y2M3NDAyMGJiZWE2M2IxMzliMjI1MTRhMDg3OThlMzQwNGRkZWY5NTE5YjNjZDNhNDMxYjMwMmIwYTZkZjI1ZjE0Mzc0ZmUxMzU2ZDZkNTFjMjQ1ZTQ4NWI1NzY2MjVlN2VjNmY0NGM0MmU5YTYzN2VkNmIwYmZmNWNiNmY0MDZiN2VkZWUzODZiZmI1YTg5OWZhNWFlOWYyNDExN2M0YjFmZTY0OTI4NjY1MWVjZTQ1YjNkYzIwMDdjYjhhMTYzYmYwNTk4ZGE0ODM2MWM1NWQzOWE2OTE2M2ZhOGZkMjRjZjVmODM2NTVkMjNkY2EzYWQ5NjFjNjJmMzU2MjA4NTUyYmI5ZWQ1MjkwNzcwOTY5NjZkNjcwYzM1NGU0YWJjOTgwNGYxNzQ2YzA4Y2ExODIxN2MzMjkwNWU0NjJlMzZjZTNiZTM5ZTc3MmMxODBlODYwMzliMjc4M2EyZWMwN2EyOGZiNWM1NWRmMDZmNGM1MmM5ZGUyYmNiZjY5NTU4MTcxODM5OTU0OTdjZWE5NTZhZTUxNWQyMjYxODk4ZmEwNTEwMTU3MjhlNWE4YWFhYzQyZGFkMzMxNzBkMDQ1MDdhMzNhODU1MjFhYmRmMWNiYTY0ZWNmYjg1MDQ1OGRiZWYwYThhZWE3MTU3NWQwNjBjN2RiMzk3MGY4NWE2ZTFlNGM3YWJmNWFlOGNkYjA5MzNkNzFlOGM5NGUwNGEyNTYxOWRjZWUzZDIyNjFhZDJlZTZiZjEyZmZhMDZkOThhMDg2NGQ4NzYwMjczM2VjODZhNjQ1MjFmMmIxODE3N2IyMDBjYmJlMTE3NTc3YTYxNWQ2Yzc3MDk4OGMwYmFkOTQ2ZTIwOGUyNGZhMDc0ZTVhYjMxNDNkYjViZmNlMGZkMTA4ZTRiODJkMTIwYTkzYWQyY2FmZmZmZmZmZmZmZmZmZmZmXCJcbiAgICB9LFxuICAgIFwibW9kcDE2XCI6IHtcbiAgICAgICAgXCJnZW5cIjogXCIwMlwiLFxuICAgICAgICBcInByaW1lXCI6IFwiZmZmZmZmZmZmZmZmZmZmZmM5MGZkYWEyMjE2OGMyMzRjNGM2NjI4YjgwZGMxY2QxMjkwMjRlMDg4YTY3Y2M3NDAyMGJiZWE2M2IxMzliMjI1MTRhMDg3OThlMzQwNGRkZWY5NTE5YjNjZDNhNDMxYjMwMmIwYTZkZjI1ZjE0Mzc0ZmUxMzU2ZDZkNTFjMjQ1ZTQ4NWI1NzY2MjVlN2VjNmY0NGM0MmU5YTYzN2VkNmIwYmZmNWNiNmY0MDZiN2VkZWUzODZiZmI1YTg5OWZhNWFlOWYyNDExN2M0YjFmZTY0OTI4NjY1MWVjZTQ1YjNkYzIwMDdjYjhhMTYzYmYwNTk4ZGE0ODM2MWM1NWQzOWE2OTE2M2ZhOGZkMjRjZjVmODM2NTVkMjNkY2EzYWQ5NjFjNjJmMzU2MjA4NTUyYmI5ZWQ1MjkwNzcwOTY5NjZkNjcwYzM1NGU0YWJjOTgwNGYxNzQ2YzA4Y2ExODIxN2MzMjkwNWU0NjJlMzZjZTNiZTM5ZTc3MmMxODBlODYwMzliMjc4M2EyZWMwN2EyOGZiNWM1NWRmMDZmNGM1MmM5ZGUyYmNiZjY5NTU4MTcxODM5OTU0OTdjZWE5NTZhZTUxNWQyMjYxODk4ZmEwNTEwMTU3MjhlNWE4YWFhYzQyZGFkMzMxNzBkMDQ1MDdhMzNhODU1MjFhYmRmMWNiYTY0ZWNmYjg1MDQ1OGRiZWYwYThhZWE3MTU3NWQwNjBjN2RiMzk3MGY4NWE2ZTFlNGM3YWJmNWFlOGNkYjA5MzNkNzFlOGM5NGUwNGEyNTYxOWRjZWUzZDIyNjFhZDJlZTZiZjEyZmZhMDZkOThhMDg2NGQ4NzYwMjczM2VjODZhNjQ1MjFmMmIxODE3N2IyMDBjYmJlMTE3NTc3YTYxNWQ2Yzc3MDk4OGMwYmFkOTQ2ZTIwOGUyNGZhMDc0ZTVhYjMxNDNkYjViZmNlMGZkMTA4ZTRiODJkMTIwYTkyMTA4MDExYTcyM2MxMmE3ODdlNmQ3ODg3MTlhMTBiZGJhNWIyNjk5YzMyNzE4NmFmNGUyM2MxYTk0NjgzNGI2MTUwYmRhMjU4M2U5Y2EyYWQ0NGNlOGRiYmJjMmRiMDRkZThlZjkyZThlZmMxNDFmYmVjYWE2Mjg3YzU5NDc0ZTZiYzA1ZDk5YjI5NjRmYTA5MGMzYTIyMzNiYTE4NjUxNWJlN2VkMWY2MTI5NzBjZWUyZDdhZmI4MWJkZDc2MjE3MDQ4MWNkMDA2OTEyN2Q1YjA1YWE5OTNiNGVhOTg4ZDhmZGRjMTg2ZmZiN2RjOTBhNmMwOGY0ZGY0MzVjOTM0MDYzMTk5ZmZmZmZmZmZmZmZmZmZmZlwiXG4gICAgfSxcbiAgICBcIm1vZHAxN1wiOiB7XG4gICAgICAgIFwiZ2VuXCI6IFwiMDJcIixcbiAgICAgICAgXCJwcmltZVwiOiBcImZmZmZmZmZmZmZmZmZmZmZjOTBmZGFhMjIxNjhjMjM0YzRjNjYyOGI4MGRjMWNkMTI5MDI0ZTA4OGE2N2NjNzQwMjBiYmVhNjNiMTM5YjIyNTE0YTA4Nzk4ZTM0MDRkZGVmOTUxOWIzY2QzYTQzMWIzMDJiMGE2ZGYyNWYxNDM3NGZlMTM1NmQ2ZDUxYzI0NWU0ODViNTc2NjI1ZTdlYzZmNDRjNDJlOWE2MzdlZDZiMGJmZjVjYjZmNDA2YjdlZGVlMzg2YmZiNWE4OTlmYTVhZTlmMjQxMTdjNGIxZmU2NDkyODY2NTFlY2U0NWIzZGMyMDA3Y2I4YTE2M2JmMDU5OGRhNDgzNjFjNTVkMzlhNjkxNjNmYThmZDI0Y2Y1ZjgzNjU1ZDIzZGNhM2FkOTYxYzYyZjM1NjIwODU1MmJiOWVkNTI5MDc3MDk2OTY2ZDY3MGMzNTRlNGFiYzk4MDRmMTc0NmMwOGNhMTgyMTdjMzI5MDVlNDYyZTM2Y2UzYmUzOWU3NzJjMTgwZTg2MDM5YjI3ODNhMmVjMDdhMjhmYjVjNTVkZjA2ZjRjNTJjOWRlMmJjYmY2OTU1ODE3MTgzOTk1NDk3Y2VhOTU2YWU1MTVkMjI2MTg5OGZhMDUxMDE1NzI4ZTVhOGFhYWM0MmRhZDMzMTcwZDA0NTA3YTMzYTg1NTIxYWJkZjFjYmE2NGVjZmI4NTA0NThkYmVmMGE4YWVhNzE1NzVkMDYwYzdkYjM5NzBmODVhNmUxZTRjN2FiZjVhZThjZGIwOTMzZDcxZThjOTRlMDRhMjU2MTlkY2VlM2QyMjYxYWQyZWU2YmYxMmZmYTA2ZDk4YTA4NjRkODc2MDI3MzNlYzg2YTY0NTIxZjJiMTgxNzdiMjAwY2JiZTExNzU3N2E2MTVkNmM3NzA5ODhjMGJhZDk0NmUyMDhlMjRmYTA3NGU1YWIzMTQzZGI1YmZjZTBmZDEwOGU0YjgyZDEyMGE5MjEwODAxMWE3MjNjMTJhNzg3ZTZkNzg4NzE5YTEwYmRiYTViMjY5OWMzMjcxODZhZjRlMjNjMWE5NDY4MzRiNjE1MGJkYTI1ODNlOWNhMmFkNDRjZThkYmJiYzJkYjA0ZGU4ZWY5MmU4ZWZjMTQxZmJlY2FhNjI4N2M1OTQ3NGU2YmMwNWQ5OWIyOTY0ZmEwOTBjM2EyMjMzYmExODY1MTViZTdlZDFmNjEyOTcwY2VlMmQ3YWZiODFiZGQ3NjIxNzA0ODFjZDAwNjkxMjdkNWIwNWFhOTkzYjRlYTk4OGQ4ZmRkYzE4NmZmYjdkYzkwYTZjMDhmNGRmNDM1YzkzNDAyODQ5MjM2YzNmYWI0ZDI3YzcwMjZjMWQ0ZGNiMjYwMjY0NmRlYzk3NTFlNzYzZGJhMzdiZGY4ZmY5NDA2YWQ5ZTUzMGVlNWRiMzgyZjQxMzAwMWFlYjA2YTUzZWQ5MDI3ZDgzMTE3OTcyN2IwODY1YTg5MThkYTNlZGJlYmNmOWIxNGVkNDRjZTZjYmFjZWQ0YmIxYmRiN2YxNDQ3ZTZjYzI1NGIzMzIwNTE1MTJiZDdhZjQyNmZiOGY0MDEzNzhjZDJiZjU5ODNjYTAxYzY0YjkyZWNmMDMyZWExNWQxNzIxZDAzZjQ4MmQ3Y2U2ZTc0ZmVmNmQ1NWU3MDJmNDY5ODBjODJiNWE4NDAzMTkwMGIxYzllNTllN2M5N2ZiZWM3ZThmMzIzYTk3YTdlMzZjYzg4YmUwZjFkNDViN2ZmNTg1YWM1NGJkNDA3YjIyYjQxNTRhYWNjOGY2ZDdlYmY0OGUxZDgxNGNjNWVkMjBmODAzN2UwYTc5NzE1ZWVmMjliZTMyODA2YTFkNThiYjdjNWRhNzZmNTUwYWEzZDhhMWZiZmYwZWIxOWNjYjFhMzEzZDU1Y2RhNTZjOWVjMmVmMjk2MzIzODdmZThkNzZlM2MwNDY4MDQzZThmNjYzZjQ4NjBlZTEyYmYyZDViMGI3NDc0ZDZlNjk0ZjkxZTZkY2M0MDI0ZmZmZmZmZmZmZmZmZmZmZlwiXG4gICAgfSxcbiAgICBcIm1vZHAxOFwiOiB7XG4gICAgICAgIFwiZ2VuXCI6IFwiMDJcIixcbiAgICAgICAgXCJwcmltZVwiOiBcImZmZmZmZmZmZmZmZmZmZmZjOTBmZGFhMjIxNjhjMjM0YzRjNjYyOGI4MGRjMWNkMTI5MDI0ZTA4OGE2N2NjNzQwMjBiYmVhNjNiMTM5YjIyNTE0YTA4Nzk4ZTM0MDRkZGVmOTUxOWIzY2QzYTQzMWIzMDJiMGE2ZGYyNWYxNDM3NGZlMTM1NmQ2ZDUxYzI0NWU0ODViNTc2NjI1ZTdlYzZmNDRjNDJlOWE2MzdlZDZiMGJmZjVjYjZmNDA2YjdlZGVlMzg2YmZiNWE4OTlmYTVhZTlmMjQxMTdjNGIxZmU2NDkyODY2NTFlY2U0NWIzZGMyMDA3Y2I4YTE2M2JmMDU5OGRhNDgzNjFjNTVkMzlhNjkxNjNmYThmZDI0Y2Y1ZjgzNjU1ZDIzZGNhM2FkOTYxYzYyZjM1NjIwODU1MmJiOWVkNTI5MDc3MDk2OTY2ZDY3MGMzNTRlNGFiYzk4MDRmMTc0NmMwOGNhMTgyMTdjMzI5MDVlNDYyZTM2Y2UzYmUzOWU3NzJjMTgwZTg2MDM5YjI3ODNhMmVjMDdhMjhmYjVjNTVkZjA2ZjRjNTJjOWRlMmJjYmY2OTU1ODE3MTgzOTk1NDk3Y2VhOTU2YWU1MTVkMjI2MTg5OGZhMDUxMDE1NzI4ZTVhOGFhYWM0MmRhZDMzMTcwZDA0NTA3YTMzYTg1NTIxYWJkZjFjYmE2NGVjZmI4NTA0NThkYmVmMGE4YWVhNzE1NzVkMDYwYzdkYjM5NzBmODVhNmUxZTRjN2FiZjVhZThjZGIwOTMzZDcxZThjOTRlMDRhMjU2MTlkY2VlM2QyMjYxYWQyZWU2YmYxMmZmYTA2ZDk4YTA4NjRkODc2MDI3MzNlYzg2YTY0NTIxZjJiMTgxNzdiMjAwY2JiZTExNzU3N2E2MTVkNmM3NzA5ODhjMGJhZDk0NmUyMDhlMjRmYTA3NGU1YWIzMTQzZGI1YmZjZTBmZDEwOGU0YjgyZDEyMGE5MjEwODAxMWE3MjNjMTJhNzg3ZTZkNzg4NzE5YTEwYmRiYTViMjY5OWMzMjcxODZhZjRlMjNjMWE5NDY4MzRiNjE1MGJkYTI1ODNlOWNhMmFkNDRjZThkYmJiYzJkYjA0ZGU4ZWY5MmU4ZWZjMTQxZmJlY2FhNjI4N2M1OTQ3NGU2YmMwNWQ5OWIyOTY0ZmEwOTBjM2EyMjMzYmExODY1MTViZTdlZDFmNjEyOTcwY2VlMmQ3YWZiODFiZGQ3NjIxNzA0ODFjZDAwNjkxMjdkNWIwNWFhOTkzYjRlYTk4OGQ4ZmRkYzE4NmZmYjdkYzkwYTZjMDhmNGRmNDM1YzkzNDAyODQ5MjM2YzNmYWI0ZDI3YzcwMjZjMWQ0ZGNiMjYwMjY0NmRlYzk3NTFlNzYzZGJhMzdiZGY4ZmY5NDA2YWQ5ZTUzMGVlNWRiMzgyZjQxMzAwMWFlYjA2YTUzZWQ5MDI3ZDgzMTE3OTcyN2IwODY1YTg5MThkYTNlZGJlYmNmOWIxNGVkNDRjZTZjYmFjZWQ0YmIxYmRiN2YxNDQ3ZTZjYzI1NGIzMzIwNTE1MTJiZDdhZjQyNmZiOGY0MDEzNzhjZDJiZjU5ODNjYTAxYzY0YjkyZWNmMDMyZWExNWQxNzIxZDAzZjQ4MmQ3Y2U2ZTc0ZmVmNmQ1NWU3MDJmNDY5ODBjODJiNWE4NDAzMTkwMGIxYzllNTllN2M5N2ZiZWM3ZThmMzIzYTk3YTdlMzZjYzg4YmUwZjFkNDViN2ZmNTg1YWM1NGJkNDA3YjIyYjQxNTRhYWNjOGY2ZDdlYmY0OGUxZDgxNGNjNWVkMjBmODAzN2UwYTc5NzE1ZWVmMjliZTMyODA2YTFkNThiYjdjNWRhNzZmNTUwYWEzZDhhMWZiZmYwZWIxOWNjYjFhMzEzZDU1Y2RhNTZjOWVjMmVmMjk2MzIzODdmZThkNzZlM2MwNDY4MDQzZThmNjYzZjQ4NjBlZTEyYmYyZDViMGI3NDc0ZDZlNjk0ZjkxZTZkYmUxMTU5NzRhMzkyNmYxMmZlZTVlNDM4Nzc3Y2I2YTkzMmRmOGNkOGJlYzRkMDczYjkzMWJhM2JjODMyYjY4ZDlkZDMwMDc0MWZhN2JmOGFmYzQ3ZWQyNTc2ZjY5MzZiYTQyNDY2M2FhYjYzOWM1YWU0ZjU2ODM0MjNiNDc0MmJmMWM5NzgyMzhmMTZjYmUzOWQ2NTJkZTNmZGI4YmVmYzg0OGFkOTIyMjIyZTA0YTQwMzdjMDcxM2ViNTdhODFhMjNmMGM3MzQ3M2ZjNjQ2Y2VhMzA2YjRiY2JjODg2MmY4Mzg1ZGRmYTlkNGI3ZmEyYzA4N2U4Nzk2ODMzMDNlZDViZGQzYTA2MmIzY2Y1YjNhMjc4YTY2ZDJhMTNmODNmNDRmODJkZGYzMTBlZTA3NGFiNmEzNjQ1OTdlODk5YTAyNTVkYzE2NGYzMWNjNTA4NDY4NTFkZjlhYjQ4MTk1ZGVkN2VhMWIxZDUxMGJkN2VlNzRkNzNmYWYzNmJjMzFlY2ZhMjY4MzU5MDQ2ZjRlYjg3OWY5MjQwMDk0MzhiNDgxYzZjZDc4ODlhMDAyZWQ1ZWUzODJiYzkxOTBkYTZmYzAyNmU0Nzk1NThlNDQ3NTY3N2U5YWE5ZTMwNTBlMjc2NTY5NGRmYzgxZjU2ZTg4MGI5NmU3MTYwYzk4MGRkOThlZGQzZGZmZmZmZmZmZmZmZmZmZmZmXCJcbiAgICB9XG59IiwidmFyIGJuID0gcmVxdWlyZSgnYm4uanMnKTtcbnZhciBicm9yYW5kID0gcmVxdWlyZSgnYnJvcmFuZCcpO1xuXG5mdW5jdGlvbiBNaWxsZXJSYWJpbihyYW5kKSB7XG4gIHRoaXMucmFuZCA9IHJhbmQgfHwgbmV3IGJyb3JhbmQuUmFuZCgpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBNaWxsZXJSYWJpbjtcblxuTWlsbGVyUmFiaW4uY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHJhbmQpIHtcbiAgcmV0dXJuIG5ldyBNaWxsZXJSYWJpbihyYW5kKTtcbn07XG5cbk1pbGxlclJhYmluLnByb3RvdHlwZS5fcmFuZCA9IGZ1bmN0aW9uIF9yYW5kKG4pIHtcbiAgdmFyIGxlbiA9IG4uYml0TGVuZ3RoKCk7XG4gIHZhciBidWYgPSB0aGlzLnJhbmQuZ2VuZXJhdGUoTWF0aC5jZWlsKGxlbiAvIDgpKTtcblxuICAvLyBTZXQgbG93IGJpdHNcbiAgYnVmWzBdIHw9IDM7XG5cbiAgLy8gTWFzayBoaWdoIGJpdHNcbiAgdmFyIG1hc2sgPSBsZW4gJiAweDc7XG4gIGlmIChtYXNrICE9PSAwKVxuICAgIGJ1ZltidWYubGVuZ3RoIC0gMV0gPj49IDcgLSBtYXNrO1xuXG4gIHJldHVybiBuZXcgYm4oYnVmKTtcbn1cblxuTWlsbGVyUmFiaW4ucHJvdG90eXBlLnRlc3QgPSBmdW5jdGlvbiB0ZXN0KG4sIGssIGNiKSB7XG4gIHZhciBsZW4gPSBuLmJpdExlbmd0aCgpO1xuICB2YXIgcmVkID0gYm4ubW9udChuKTtcbiAgdmFyIHJvbmUgPSBuZXcgYm4oMSkudG9SZWQocmVkKTtcblxuICBpZiAoIWspXG4gICAgayA9IE1hdGgubWF4KDEsIChsZW4gLyA0OCkgfCAwKTtcblxuICAvLyBGaW5kIGQgYW5kIHMsIChuIC0gMSkgPSAoMiBeIHMpICogZDtcbiAgdmFyIG4xID0gbi5zdWJuKDEpO1xuICB2YXIgbjIgPSBuMS5zdWJuKDEpO1xuICBmb3IgKHZhciBzID0gMDsgIW4xLnRlc3RuKHMpOyBzKyspIHt9XG4gIHZhciBkID0gbi5zaHJuKHMpO1xuXG4gIHZhciBybjEgPSBuMS50b1JlZChyZWQpO1xuXG4gIHZhciBwcmltZSA9IHRydWU7XG4gIGZvciAoOyBrID4gMDsgay0tKSB7XG4gICAgdmFyIGEgPSB0aGlzLl9yYW5kKG4yKTtcbiAgICBpZiAoY2IpXG4gICAgICBjYihhKTtcblxuICAgIHZhciB4ID0gYS50b1JlZChyZWQpLnJlZFBvdyhkKTtcbiAgICBpZiAoeC5jbXAocm9uZSkgPT09IDAgfHwgeC5jbXAocm4xKSA9PT0gMClcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBzOyBpKyspIHtcbiAgICAgIHggPSB4LnJlZFNxcigpO1xuXG4gICAgICBpZiAoeC5jbXAocm9uZSkgPT09IDApXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIGlmICh4LmNtcChybjEpID09PSAwKVxuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoaSA9PT0gcylcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBwcmltZTtcbn07XG5cbk1pbGxlclJhYmluLnByb3RvdHlwZS5nZXREaXZpc29yID0gZnVuY3Rpb24gZ2V0RGl2aXNvcihuLCBrKSB7XG4gIHZhciBsZW4gPSBuLmJpdExlbmd0aCgpO1xuICB2YXIgcmVkID0gYm4ubW9udChuKTtcbiAgdmFyIHJvbmUgPSBuZXcgYm4oMSkudG9SZWQocmVkKTtcblxuICBpZiAoIWspXG4gICAgayA9IE1hdGgubWF4KDEsIChsZW4gLyA0OCkgfCAwKTtcblxuICAvLyBGaW5kIGQgYW5kIHMsIChuIC0gMSkgPSAoMiBeIHMpICogZDtcbiAgdmFyIG4xID0gbi5zdWJuKDEpO1xuICB2YXIgbjIgPSBuMS5zdWJuKDEpO1xuICBmb3IgKHZhciBzID0gMDsgIW4xLnRlc3RuKHMpOyBzKyspIHt9XG4gIHZhciBkID0gbi5zaHJuKHMpO1xuXG4gIHZhciBybjEgPSBuMS50b1JlZChyZWQpO1xuXG4gIGZvciAoOyBrID4gMDsgay0tKSB7XG4gICAgdmFyIGEgPSB0aGlzLl9yYW5kKG4yKTtcblxuICAgIHZhciBnID0gbi5nY2QoYSk7XG4gICAgaWYgKGcuY21wbigxKSAhPT0gMClcbiAgICAgIHJldHVybiBnO1xuXG4gICAgdmFyIHggPSBhLnRvUmVkKHJlZCkucmVkUG93KGQpO1xuICAgIGlmICh4LmNtcChyb25lKSA9PT0gMCB8fCB4LmNtcChybjEpID09PSAwKVxuICAgICAgY29udGludWU7XG5cbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHM7IGkrKykge1xuICAgICAgeCA9IHgucmVkU3FyKCk7XG5cbiAgICAgIGlmICh4LmNtcChyb25lKSA9PT0gMClcbiAgICAgICAgcmV0dXJuIHguZnJvbVJlZCgpLnN1Ym4oMSkuZ2NkKG4pO1xuICAgICAgaWYgKHguY21wKHJuMSkgPT09IDApXG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChpID09PSBzKSB7XG4gICAgICB4ID0geC5yZWRTcXIoKTtcbiAgICAgIHJldHVybiB4LmZyb21SZWQoKS5zdWJuKDEpLmdjZChuKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuIiwidmFyIGNyZWF0ZUhtYWMgPSByZXF1aXJlKCdjcmVhdGUtaG1hYycpXG52YXIgTUFYX0FMTE9DID0gTWF0aC5wb3coMiwgMzApIC0gMSAvLyBkZWZhdWx0IGluIGlvanNcblxuZXhwb3J0cy5wYmtkZjIgPSBwYmtkZjJcbmZ1bmN0aW9uIHBia2RmMiAocGFzc3dvcmQsIHNhbHQsIGl0ZXJhdGlvbnMsIGtleWxlbiwgZGlnZXN0LCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGRpZ2VzdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gZGlnZXN0XG4gICAgZGlnZXN0ID0gdW5kZWZpbmVkXG4gIH1cblxuICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBjYWxsYmFjayBwcm92aWRlZCB0byBwYmtkZjInKVxuICB9XG5cbiAgdmFyIHJlc3VsdCA9IHBia2RmMlN5bmMocGFzc3dvcmQsIHNhbHQsIGl0ZXJhdGlvbnMsIGtleWxlbiwgZGlnZXN0KVxuICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBjYWxsYmFjayh1bmRlZmluZWQsIHJlc3VsdClcbiAgfSlcbn1cblxuZXhwb3J0cy5wYmtkZjJTeW5jID0gcGJrZGYyU3luY1xuZnVuY3Rpb24gcGJrZGYyU3luYyAocGFzc3dvcmQsIHNhbHQsIGl0ZXJhdGlvbnMsIGtleWxlbiwgZGlnZXN0KSB7XG4gIGlmICh0eXBlb2YgaXRlcmF0aW9ucyAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJdGVyYXRpb25zIG5vdCBhIG51bWJlcicpXG4gIH1cblxuICBpZiAoaXRlcmF0aW9ucyA8IDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCYWQgaXRlcmF0aW9ucycpXG4gIH1cblxuICBpZiAodHlwZW9mIGtleWxlbiAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdLZXkgbGVuZ3RoIG5vdCBhIG51bWJlcicpXG4gIH1cblxuICBpZiAoa2V5bGVuIDwgMCB8fCBrZXlsZW4gPiBNQVhfQUxMT0MpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCYWQga2V5IGxlbmd0aCcpXG4gIH1cblxuICBkaWdlc3QgPSBkaWdlc3QgfHwgJ3NoYTEnXG5cbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIocGFzc3dvcmQpKSBwYXNzd29yZCA9IG5ldyBCdWZmZXIocGFzc3dvcmQsICdiaW5hcnknKVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihzYWx0KSkgc2FsdCA9IG5ldyBCdWZmZXIoc2FsdCwgJ2JpbmFyeScpXG5cbiAgdmFyIGhMZW5cbiAgdmFyIGwgPSAxXG4gIHZhciBESyA9IG5ldyBCdWZmZXIoa2V5bGVuKVxuICB2YXIgYmxvY2sxID0gbmV3IEJ1ZmZlcihzYWx0Lmxlbmd0aCArIDQpXG4gIHNhbHQuY29weShibG9jazEsIDAsIDAsIHNhbHQubGVuZ3RoKVxuXG4gIHZhciByXG4gIHZhciBUXG5cbiAgZm9yICh2YXIgaSA9IDE7IGkgPD0gbDsgaSsrKSB7XG4gICAgYmxvY2sxLndyaXRlVUludDMyQkUoaSwgc2FsdC5sZW5ndGgpXG4gICAgdmFyIFUgPSBjcmVhdGVIbWFjKGRpZ2VzdCwgcGFzc3dvcmQpLnVwZGF0ZShibG9jazEpLmRpZ2VzdCgpXG5cbiAgICBpZiAoIWhMZW4pIHtcbiAgICAgIGhMZW4gPSBVLmxlbmd0aFxuICAgICAgVCA9IG5ldyBCdWZmZXIoaExlbilcbiAgICAgIGwgPSBNYXRoLmNlaWwoa2V5bGVuIC8gaExlbilcbiAgICAgIHIgPSBrZXlsZW4gLSAobCAtIDEpICogaExlblxuICAgIH1cblxuICAgIFUuY29weShULCAwLCAwLCBoTGVuKVxuXG4gICAgZm9yICh2YXIgaiA9IDE7IGogPCBpdGVyYXRpb25zOyBqKyspIHtcbiAgICAgIFUgPSBjcmVhdGVIbWFjKGRpZ2VzdCwgcGFzc3dvcmQpLnVwZGF0ZShVKS5kaWdlc3QoKVxuXG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IGhMZW47IGsrKykge1xuICAgICAgICBUW2tdIF49IFVba11cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZGVzdFBvcyA9IChpIC0gMSkgKiBoTGVuXG4gICAgdmFyIGxlbiA9IChpID09PSBsID8gciA6IGhMZW4pXG4gICAgVC5jb3B5KERLLCBkZXN0UG9zLCAwLCBsZW4pXG4gIH1cblxuICByZXR1cm4gREtcbn1cbiIsImV4cG9ydHMucHVibGljRW5jcnlwdCA9IHJlcXVpcmUoJy4vcHVibGljRW5jcnlwdCcpO1xuZXhwb3J0cy5wcml2YXRlRGVjcnlwdCA9IHJlcXVpcmUoJy4vcHJpdmF0ZURlY3J5cHQnKTtcblxuZXhwb3J0cy5wcml2YXRlRW5jcnlwdCA9IGZ1bmN0aW9uIHByaXZhdGVFbmNyeXB0KGtleSwgYnVmKSB7XG4gIHJldHVybiBleHBvcnRzLnB1YmxpY0VuY3J5cHQoa2V5LCBidWYsIHRydWUpO1xufTtcblxuZXhwb3J0cy5wdWJsaWNEZWNyeXB0ID0gZnVuY3Rpb24gcHVibGljRGVjcnlwdChrZXksIGJ1Zikge1xuICByZXR1cm4gZXhwb3J0cy5wcml2YXRlRGVjcnlwdChrZXksIGJ1ZiwgdHJ1ZSk7XG59OyIsInZhciBjcmVhdGVIYXNoID0gcmVxdWlyZSgnY3JlYXRlLWhhc2gnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHNlZWQsIGxlbikge1xuICB2YXIgdCA9IG5ldyBCdWZmZXIoJycpO1xuICB2YXIgIGkgPSAwLCBjO1xuICB3aGlsZSAodC5sZW5ndGggPCBsZW4pIHtcbiAgICBjID0gaTJvcHMoaSsrKTtcbiAgICB0ID0gQnVmZmVyLmNvbmNhdChbdCwgY3JlYXRlSGFzaCgnc2hhMScpLnVwZGF0ZShzZWVkKS51cGRhdGUoYykuZGlnZXN0KCldKTtcbiAgfVxuICByZXR1cm4gdC5zbGljZSgwLCBsZW4pO1xufTtcblxuZnVuY3Rpb24gaTJvcHMoYykge1xuICB2YXIgb3V0ID0gbmV3IEJ1ZmZlcig0KTtcbiAgb3V0LndyaXRlVUludDMyQkUoYywwKTtcbiAgcmV0dXJuIG91dDtcbn0iLCJ2YXIgYm4gPSByZXF1aXJlKCdibi5qcycpO1xudmFyIHJhbmRvbUJ5dGVzID0gcmVxdWlyZSgncmFuZG9tYnl0ZXMnKTtcbm1vZHVsZS5leHBvcnRzID0gY3J0O1xuZnVuY3Rpb24gYmxpbmQocHJpdikge1xuICB2YXIgciA9IGdldHIocHJpdik7XG4gIHZhciBibGluZGVyID0gci50b1JlZChibi5tb250KHByaXYubW9kdWx1cykpXG4gIC5yZWRQb3cobmV3IGJuKHByaXYucHVibGljRXhwb25lbnQpKS5mcm9tUmVkKCk7XG4gIHJldHVybiB7XG4gICAgYmxpbmRlcjogYmxpbmRlcixcbiAgICB1bmJsaW5kZXI6ci5pbnZtKHByaXYubW9kdWx1cylcbiAgfTtcbn1cbmZ1bmN0aW9uIGNydChtc2csIHByaXYpIHtcbiAgdmFyIGJsaW5kcyA9IGJsaW5kKHByaXYpO1xuICB2YXIgbGVuID0gcHJpdi5tb2R1bHVzLmJ5dGVMZW5ndGgoKTtcbiAgdmFyIG1vZCA9IGJuLm1vbnQocHJpdi5tb2R1bHVzKTtcbiAgdmFyIGJsaW5kZWQgPSBuZXcgYm4obXNnKS5tdWwoYmxpbmRzLmJsaW5kZXIpLnVtb2QocHJpdi5tb2R1bHVzKTtcbiAgdmFyIGMxID0gYmxpbmRlZC50b1JlZChibi5tb250KHByaXYucHJpbWUxKSk7XG4gIHZhciBjMiA9IGJsaW5kZWQudG9SZWQoYm4ubW9udChwcml2LnByaW1lMikpO1xuICB2YXIgcWludiA9IHByaXYuY29lZmZpY2llbnQ7XG4gIHZhciBwID0gcHJpdi5wcmltZTE7XG4gIHZhciBxID0gcHJpdi5wcmltZTI7XG4gIHZhciBtMSA9IGMxLnJlZFBvdyhwcml2LmV4cG9uZW50MSk7XG4gIHZhciBtMiA9IGMyLnJlZFBvdyhwcml2LmV4cG9uZW50Mik7XG4gIG0xID0gbTEuZnJvbVJlZCgpO1xuICBtMiA9IG0yLmZyb21SZWQoKTtcbiAgdmFyIGggPSBtMS5pc3ViKG0yKS5pbXVsKHFpbnYpLnVtb2QocCk7XG4gIGguaW11bChxKTtcbiAgbTIuaWFkZChoKTtcbiAgcmV0dXJuIG5ldyBCdWZmZXIobTIuaW11bChibGluZHMudW5ibGluZGVyKS51bW9kKHByaXYubW9kdWx1cykudG9BcnJheShmYWxzZSwgbGVuKSk7XG59XG5jcnQuZ2V0ciA9IGdldHI7XG5mdW5jdGlvbiBnZXRyKHByaXYpIHtcbiAgdmFyIGxlbiA9IHByaXYubW9kdWx1cy5ieXRlTGVuZ3RoKCk7XG4gIHZhciByID0gbmV3IGJuKHJhbmRvbUJ5dGVzKGxlbikpO1xuICB3aGlsZSAoci5jbXAocHJpdi5tb2R1bHVzKSA+PSAgMCB8fCAhci51bW9kKHByaXYucHJpbWUxKSB8fCAhci51bW9kKHByaXYucHJpbWUyKSkge1xuICAgIHIgPSBuZXcgYm4ocmFuZG9tQnl0ZXMobGVuKSk7XG4gIH1cbiAgcmV0dXJuIHI7XG59XG4iLCIvLyBhZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2FwYXRpbC9wZW1zdHJpcFxudmFyIGZpbmRQcm9jID0gL1Byb2MtVHlwZTogNCxFTkNSWVBURURcXHI/XFxuREVLLUluZm86IEFFUy0oKD86MTI4KXwoPzoxOTIpfCg/OjI1NikpLUNCQywoWzAtOUEtSF0rKVxccj9cXG5cXHI/XFxuKFswLTlBLXpcXG5cXHJcXCtcXC9cXD1dKylcXHI/XFxuL21cbnZhciBzdGFydFJlZ2V4ID0gL14tLS0tLUJFR0lOICguKikgS0VZLS0tLS1cXHI/XFxuL21cbnZhciBmdWxsUmVnZXggPSAvXi0tLS0tQkVHSU4gKC4qKSBLRVktLS0tLVxccj9cXG4oWzAtOUEtelxcblxcclxcK1xcL1xcPV0rKVxccj9cXG4tLS0tLUVORCBcXDEgS0VZLS0tLS0kL21cbnZhciBldnAgPSByZXF1aXJlKCdldnBfYnl0ZXN0b2tleScpXG52YXIgY2lwaGVycyA9IHJlcXVpcmUoJ2Jyb3dzZXJpZnktYWVzJylcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9rZXksIHBhc3N3b3JkKSB7XG4gIHZhciBrZXkgPSBva2V5LnRvU3RyaW5nKClcbiAgdmFyIG1hdGNoID0ga2V5Lm1hdGNoKGZpbmRQcm9jKVxuICB2YXIgZGVjcnlwdGVkXG4gIGlmICghbWF0Y2gpIHtcbiAgICB2YXIgbWF0Y2gyID0ga2V5Lm1hdGNoKGZ1bGxSZWdleClcbiAgICBkZWNyeXB0ZWQgPSBuZXcgQnVmZmVyKG1hdGNoMlsyXS5yZXBsYWNlKC9cXHI/XFxuL2csICcnKSwgJ2Jhc2U2NCcpXG4gIH0gZWxzZSB7XG4gICAgdmFyIHN1aXRlID0gJ2FlcycgKyBtYXRjaFsxXVxuICAgIHZhciBpdiA9IG5ldyBCdWZmZXIobWF0Y2hbMl0sICdoZXgnKVxuICAgIHZhciBjaXBoZXJUZXh0ID0gbmV3IEJ1ZmZlcihtYXRjaFszXS5yZXBsYWNlKC9cXHI/XFxuL2csICcnKSwgJ2Jhc2U2NCcpXG4gICAgdmFyIGNpcGhlcktleSA9IGV2cChwYXNzd29yZCwgaXYuc2xpY2UoMCwgOCksIHBhcnNlSW50KG1hdGNoWzFdLCAxMCkpLmtleVxuICAgIHZhciBvdXQgPSBbXVxuICAgIHZhciBjaXBoZXIgPSBjaXBoZXJzLmNyZWF0ZURlY2lwaGVyaXYoc3VpdGUsIGNpcGhlcktleSwgaXYpXG4gICAgb3V0LnB1c2goY2lwaGVyLnVwZGF0ZShjaXBoZXJUZXh0KSlcbiAgICBvdXQucHVzaChjaXBoZXIuZmluYWwoKSlcbiAgICBkZWNyeXB0ZWQgPSBCdWZmZXIuY29uY2F0KG91dClcbiAgfVxuICB2YXIgdGFnID0ga2V5Lm1hdGNoKHN0YXJ0UmVnZXgpWzFdICsgJyBLRVknXG4gIHJldHVybiB7XG4gICAgdGFnOiB0YWcsXG4gICAgZGF0YTogZGVjcnlwdGVkXG4gIH1cbn1cbiIsInZhciBhc24xID0gcmVxdWlyZSgnLi9hc24xJylcbnZhciBhZXNpZCA9IHJlcXVpcmUoJy4vYWVzaWQuanNvbicpXG52YXIgZml4UHJvYyA9IHJlcXVpcmUoJy4vZml4UHJvYycpXG52YXIgY2lwaGVycyA9IHJlcXVpcmUoJ2Jyb3dzZXJpZnktYWVzJylcbnZhciBjb21wYXQgPSByZXF1aXJlKCdwYmtkZjInKVxubW9kdWxlLmV4cG9ydHMgPSBwYXJzZUtleXNcblxuZnVuY3Rpb24gcGFyc2VLZXlzIChidWZmZXIpIHtcbiAgdmFyIHBhc3N3b3JkXG4gIGlmICh0eXBlb2YgYnVmZmVyID09PSAnb2JqZWN0JyAmJiAhQnVmZmVyLmlzQnVmZmVyKGJ1ZmZlcikpIHtcbiAgICBwYXNzd29yZCA9IGJ1ZmZlci5wYXNzcGhyYXNlXG4gICAgYnVmZmVyID0gYnVmZmVyLmtleVxuICB9XG4gIGlmICh0eXBlb2YgYnVmZmVyID09PSAnc3RyaW5nJykge1xuICAgIGJ1ZmZlciA9IG5ldyBCdWZmZXIoYnVmZmVyKVxuICB9XG5cbiAgdmFyIHN0cmlwcGVkID0gZml4UHJvYyhidWZmZXIsIHBhc3N3b3JkKVxuXG4gIHZhciB0eXBlID0gc3RyaXBwZWQudGFnXG4gIHZhciBkYXRhID0gc3RyaXBwZWQuZGF0YVxuICB2YXIgc3VidHlwZSwgbmRhdGFcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnUFVCTElDIEtFWSc6XG4gICAgICBuZGF0YSA9IGFzbjEuUHVibGljS2V5LmRlY29kZShkYXRhLCAnZGVyJylcbiAgICAgIHN1YnR5cGUgPSBuZGF0YS5hbGdvcml0aG0uYWxnb3JpdGhtLmpvaW4oJy4nKVxuICAgICAgc3dpdGNoIChzdWJ0eXBlKSB7XG4gICAgICAgIGNhc2UgJzEuMi44NDAuMTEzNTQ5LjEuMS4xJzpcbiAgICAgICAgICByZXR1cm4gYXNuMS5SU0FQdWJsaWNLZXkuZGVjb2RlKG5kYXRhLnN1YmplY3RQdWJsaWNLZXkuZGF0YSwgJ2RlcicpXG4gICAgICAgIGNhc2UgJzEuMi44NDAuMTAwNDUuMi4xJzpcbiAgICAgICAgICBuZGF0YS5zdWJqZWN0UHJpdmF0ZUtleSA9IG5kYXRhLnN1YmplY3RQdWJsaWNLZXlcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ2VjJyxcbiAgICAgICAgICAgIGRhdGE6IG5kYXRhXG4gICAgICAgICAgfVxuICAgICAgICBjYXNlICcxLjIuODQwLjEwMDQwLjQuMSc6XG4gICAgICAgICAgbmRhdGEuYWxnb3JpdGhtLnBhcmFtcy5wdWJfa2V5ID0gYXNuMS5EU0FwYXJhbS5kZWNvZGUobmRhdGEuc3ViamVjdFB1YmxpY0tleS5kYXRhLCAnZGVyJylcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ2RzYScsXG4gICAgICAgICAgICBkYXRhOiBuZGF0YS5hbGdvcml0aG0ucGFyYW1zXG4gICAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24ga2V5IGlkICcgKyBzdWJ0eXBlKVxuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGtleSB0eXBlICcgKyB0eXBlKVxuICAgIGNhc2UgJ0VOQ1JZUFRFRCBQUklWQVRFIEtFWSc6XG4gICAgICBkYXRhID0gYXNuMS5FbmNyeXB0ZWRQcml2YXRlS2V5LmRlY29kZShkYXRhLCAnZGVyJylcbiAgICAgIGRhdGEgPSBkZWNyeXB0KGRhdGEsIHBhc3N3b3JkKVxuICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgIGNhc2UgJ1BSSVZBVEUgS0VZJzpcbiAgICAgIG5kYXRhID0gYXNuMS5Qcml2YXRlS2V5LmRlY29kZShkYXRhLCAnZGVyJylcbiAgICAgIHN1YnR5cGUgPSBuZGF0YS5hbGdvcml0aG0uYWxnb3JpdGhtLmpvaW4oJy4nKVxuICAgICAgc3dpdGNoIChzdWJ0eXBlKSB7XG4gICAgICAgIGNhc2UgJzEuMi44NDAuMTEzNTQ5LjEuMS4xJzpcbiAgICAgICAgICByZXR1cm4gYXNuMS5SU0FQcml2YXRlS2V5LmRlY29kZShuZGF0YS5zdWJqZWN0UHJpdmF0ZUtleSwgJ2RlcicpXG4gICAgICAgIGNhc2UgJzEuMi44NDAuMTAwNDUuMi4xJzpcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY3VydmU6IG5kYXRhLmFsZ29yaXRobS5jdXJ2ZSxcbiAgICAgICAgICAgIHByaXZhdGVLZXk6IGFzbjEuRUNQcml2YXRlS2V5LmRlY29kZShuZGF0YS5zdWJqZWN0UHJpdmF0ZUtleSwgJ2RlcicpLnByaXZhdGVLZXlcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJzEuMi44NDAuMTAwNDAuNC4xJzpcbiAgICAgICAgICBuZGF0YS5hbGdvcml0aG0ucGFyYW1zLnByaXZfa2V5ID0gYXNuMS5EU0FwYXJhbS5kZWNvZGUobmRhdGEuc3ViamVjdFByaXZhdGVLZXksICdkZXInKVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnZHNhJyxcbiAgICAgICAgICAgIHBhcmFtczogbmRhdGEuYWxnb3JpdGhtLnBhcmFtc1xuICAgICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGtleSBpZCAnICsgc3VidHlwZSlcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biBrZXkgdHlwZSAnICsgdHlwZSlcbiAgICBjYXNlICdSU0EgUFVCTElDIEtFWSc6XG4gICAgICByZXR1cm4gYXNuMS5SU0FQdWJsaWNLZXkuZGVjb2RlKGRhdGEsICdkZXInKVxuICAgIGNhc2UgJ1JTQSBQUklWQVRFIEtFWSc6XG4gICAgICByZXR1cm4gYXNuMS5SU0FQcml2YXRlS2V5LmRlY29kZShkYXRhLCAnZGVyJylcbiAgICBjYXNlICdEU0EgUFJJVkFURSBLRVknOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ2RzYScsXG4gICAgICAgIHBhcmFtczogYXNuMS5EU0FQcml2YXRlS2V5LmRlY29kZShkYXRhLCAnZGVyJylcbiAgICAgIH1cbiAgICBjYXNlICdFQyBQUklWQVRFIEtFWSc6XG4gICAgICBkYXRhID0gYXNuMS5FQ1ByaXZhdGVLZXkuZGVjb2RlKGRhdGEsICdkZXInKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY3VydmU6IGRhdGEucGFyYW1ldGVycy52YWx1ZSxcbiAgICAgICAgcHJpdmF0ZUtleTogZGF0YS5wcml2YXRlS2V5XG4gICAgICB9XG4gICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGtleSB0eXBlICcgKyB0eXBlKVxuICB9XG59XG5wYXJzZUtleXMuc2lnbmF0dXJlID0gYXNuMS5zaWduYXR1cmVcbmZ1bmN0aW9uIGRlY3J5cHQgKGRhdGEsIHBhc3N3b3JkKSB7XG4gIHZhciBzYWx0ID0gZGF0YS5hbGdvcml0aG0uZGVjcnlwdC5rZGUua2RlcGFyYW1zLnNhbHRcbiAgdmFyIGl0ZXJzID0gcGFyc2VJbnQoZGF0YS5hbGdvcml0aG0uZGVjcnlwdC5rZGUua2RlcGFyYW1zLml0ZXJzLnRvU3RyaW5nKCksIDEwKVxuICB2YXIgYWxnbyA9IGFlc2lkW2RhdGEuYWxnb3JpdGhtLmRlY3J5cHQuY2lwaGVyLmFsZ28uam9pbignLicpXVxuICB2YXIgaXYgPSBkYXRhLmFsZ29yaXRobS5kZWNyeXB0LmNpcGhlci5pdlxuICB2YXIgY2lwaGVyVGV4dCA9IGRhdGEuc3ViamVjdFByaXZhdGVLZXlcbiAgdmFyIGtleWxlbiA9IHBhcnNlSW50KGFsZ28uc3BsaXQoJy0nKVsxXSwgMTApIC8gOFxuICB2YXIga2V5ID0gY29tcGF0LnBia2RmMlN5bmMocGFzc3dvcmQsIHNhbHQsIGl0ZXJzLCBrZXlsZW4pXG4gIHZhciBjaXBoZXIgPSBjaXBoZXJzLmNyZWF0ZURlY2lwaGVyaXYoYWxnbywga2V5LCBpdilcbiAgdmFyIG91dCA9IFtdXG4gIG91dC5wdXNoKGNpcGhlci51cGRhdGUoY2lwaGVyVGV4dCkpXG4gIG91dC5wdXNoKGNpcGhlci5maW5hbCgpKVxuICByZXR1cm4gQnVmZmVyLmNvbmNhdChvdXQpXG59XG4iLCIvLyBiYXNlZCBvbiB0aGUgYWVzIGltcGxpbWVudGF0aW9uIGluIHRyaXBsZSBzZWNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9rZXliYXNlL3RyaXBsZXNlY1xuXG4vLyB3aGljaCBpcyBpbiB0dXJuIGJhc2VkIG9uIHRoZSBvbmUgZnJvbSBjcnlwdG8tanNcbi8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY3J5cHRvLWpzL1xuXG52YXIgdWludF9tYXggPSBNYXRoLnBvdygyLCAzMilcbmZ1bmN0aW9uIGZpeHVwX3VpbnQzMiAoeCkge1xuICB2YXIgcmV0LCB4X3Bvc1xuICByZXQgPSB4ID4gdWludF9tYXggfHwgeCA8IDAgPyAoeF9wb3MgPSBNYXRoLmFicyh4KSAlIHVpbnRfbWF4LCB4IDwgMCA/IHVpbnRfbWF4IC0geF9wb3MgOiB4X3BvcykgOiB4XG4gIHJldHVybiByZXRcbn1cbmZ1bmN0aW9uIHNjcnViX3ZlYyAodikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHYubGVuZ3RoOyB2KyspIHtcbiAgICB2W2ldID0gMFxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBHbG9iYWwgKCkge1xuICB0aGlzLlNCT1ggPSBbXVxuICB0aGlzLklOVl9TQk9YID0gW11cbiAgdGhpcy5TVUJfTUlYID0gW1tdLCBbXSwgW10sIFtdXVxuICB0aGlzLklOVl9TVUJfTUlYID0gW1tdLCBbXSwgW10sIFtdXVxuICB0aGlzLmluaXQoKVxuICB0aGlzLlJDT04gPSBbMHgwMCwgMHgwMSwgMHgwMiwgMHgwNCwgMHgwOCwgMHgxMCwgMHgyMCwgMHg0MCwgMHg4MCwgMHgxYiwgMHgzNl1cbn1cblxuR2xvYmFsLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZCwgaSwgc3gsIHQsIHgsIHgyLCB4NCwgeDgsIHhpLCBfaVxuICBkID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX2ksIF9yZXN1bHRzXG4gICAgX3Jlc3VsdHMgPSBbXVxuICAgIGZvciAoaSA9IF9pID0gMDsgX2kgPCAyNTY7IGkgPSArK19pKSB7XG4gICAgICBpZiAoaSA8IDEyOCkge1xuICAgICAgICBfcmVzdWx0cy5wdXNoKGkgPDwgMSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9yZXN1bHRzLnB1c2goKGkgPDwgMSkgXiAweDExYilcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIF9yZXN1bHRzXG4gIH0pKClcbiAgeCA9IDBcbiAgeGkgPSAwXG4gIGZvciAoaSA9IF9pID0gMDsgX2kgPCAyNTY7IGkgPSArK19pKSB7XG4gICAgc3ggPSB4aSBeICh4aSA8PCAxKSBeICh4aSA8PCAyKSBeICh4aSA8PCAzKSBeICh4aSA8PCA0KVxuICAgIHN4ID0gKHN4ID4+PiA4KSBeIChzeCAmIDB4ZmYpIF4gMHg2M1xuICAgIHRoaXMuU0JPWFt4XSA9IHN4XG4gICAgdGhpcy5JTlZfU0JPWFtzeF0gPSB4XG4gICAgeDIgPSBkW3hdXG4gICAgeDQgPSBkW3gyXVxuICAgIHg4ID0gZFt4NF1cbiAgICB0ID0gKGRbc3hdICogMHgxMDEpIF4gKHN4ICogMHgxMDEwMTAwKVxuICAgIHRoaXMuU1VCX01JWFswXVt4XSA9ICh0IDw8IDI0KSB8ICh0ID4+PiA4KVxuICAgIHRoaXMuU1VCX01JWFsxXVt4XSA9ICh0IDw8IDE2KSB8ICh0ID4+PiAxNilcbiAgICB0aGlzLlNVQl9NSVhbMl1beF0gPSAodCA8PCA4KSB8ICh0ID4+PiAyNClcbiAgICB0aGlzLlNVQl9NSVhbM11beF0gPSB0XG4gICAgdCA9ICh4OCAqIDB4MTAxMDEwMSkgXiAoeDQgKiAweDEwMDAxKSBeICh4MiAqIDB4MTAxKSBeICh4ICogMHgxMDEwMTAwKVxuICAgIHRoaXMuSU5WX1NVQl9NSVhbMF1bc3hdID0gKHQgPDwgMjQpIHwgKHQgPj4+IDgpXG4gICAgdGhpcy5JTlZfU1VCX01JWFsxXVtzeF0gPSAodCA8PCAxNikgfCAodCA+Pj4gMTYpXG4gICAgdGhpcy5JTlZfU1VCX01JWFsyXVtzeF0gPSAodCA8PCA4KSB8ICh0ID4+PiAyNClcbiAgICB0aGlzLklOVl9TVUJfTUlYWzNdW3N4XSA9IHRcbiAgICBpZiAoeCA9PT0gMCkge1xuICAgICAgeCA9IHhpID0gMVxuICAgIH0gZWxzZSB7XG4gICAgICB4ID0geDIgXiBkW2RbZFt4OCBeIHgyXV1dXG4gICAgICB4aSBePSBkW2RbeGldXVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG52YXIgRyA9IG5ldyBHbG9iYWwoKVxuXG5BRVMuYmxvY2tTaXplID0gNCAqIDRcblxuQUVTLnByb3RvdHlwZS5ibG9ja1NpemUgPSBBRVMuYmxvY2tTaXplXG5cbkFFUy5rZXlTaXplID0gMjU2IC8gOFxuXG5BRVMucHJvdG90eXBlLmtleVNpemUgPSBBRVMua2V5U2l6ZVxuXG5mdW5jdGlvbiBidWZmZXJUb0FycmF5IChidWYpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGggLyA0XG4gIHZhciBvdXQgPSBuZXcgQXJyYXkobGVuKVxuICB2YXIgaSA9IC0xXG4gIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICBvdXRbaV0gPSBidWYucmVhZFVJbnQzMkJFKGkgKiA0KVxuICB9XG4gIHJldHVybiBvdXRcbn1cbmZ1bmN0aW9uIEFFUyAoa2V5KSB7XG4gIHRoaXMuX2tleSA9IGJ1ZmZlclRvQXJyYXkoa2V5KVxuICB0aGlzLl9kb1Jlc2V0KClcbn1cblxuQUVTLnByb3RvdHlwZS5fZG9SZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGludktzUm93LCBrZXlTaXplLCBrZXlXb3Jkcywga3NSb3csIGtzUm93cywgdFxuICBrZXlXb3JkcyA9IHRoaXMuX2tleVxuICBrZXlTaXplID0ga2V5V29yZHMubGVuZ3RoXG4gIHRoaXMuX25Sb3VuZHMgPSBrZXlTaXplICsgNlxuICBrc1Jvd3MgPSAodGhpcy5fblJvdW5kcyArIDEpICogNFxuICB0aGlzLl9rZXlTY2hlZHVsZSA9IFtdXG4gIGZvciAoa3NSb3cgPSAwOyBrc1JvdyA8IGtzUm93czsga3NSb3crKykge1xuICAgIHRoaXMuX2tleVNjaGVkdWxlW2tzUm93XSA9IGtzUm93IDwga2V5U2l6ZSA/IGtleVdvcmRzW2tzUm93XSA6ICh0ID0gdGhpcy5fa2V5U2NoZWR1bGVba3NSb3cgLSAxXSwgKGtzUm93ICUga2V5U2l6ZSkgPT09IDAgPyAodCA9ICh0IDw8IDgpIHwgKHQgPj4+IDI0KSwgdCA9IChHLlNCT1hbdCA+Pj4gMjRdIDw8IDI0KSB8IChHLlNCT1hbKHQgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChHLlNCT1hbKHQgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBHLlNCT1hbdCAmIDB4ZmZdLCB0IF49IEcuUkNPTlsoa3NSb3cgLyBrZXlTaXplKSB8IDBdIDw8IDI0KSA6IGtleVNpemUgPiA2ICYmIGtzUm93ICUga2V5U2l6ZSA9PT0gNCA/IHQgPSAoRy5TQk9YW3QgPj4+IDI0XSA8PCAyNCkgfCAoRy5TQk9YWyh0ID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoRy5TQk9YWyh0ID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgRy5TQk9YW3QgJiAweGZmXSA6IHZvaWQgMCwgdGhpcy5fa2V5U2NoZWR1bGVba3NSb3cgLSBrZXlTaXplXSBeIHQpXG4gIH1cbiAgdGhpcy5faW52S2V5U2NoZWR1bGUgPSBbXVxuICBmb3IgKGludktzUm93ID0gMDsgaW52S3NSb3cgPCBrc1Jvd3M7IGludktzUm93KyspIHtcbiAgICBrc1JvdyA9IGtzUm93cyAtIGludktzUm93XG4gICAgdCA9IHRoaXMuX2tleVNjaGVkdWxlW2tzUm93IC0gKGludktzUm93ICUgNCA/IDAgOiA0KV1cbiAgICB0aGlzLl9pbnZLZXlTY2hlZHVsZVtpbnZLc1Jvd10gPSBpbnZLc1JvdyA8IDQgfHwga3NSb3cgPD0gNCA/IHQgOiBHLklOVl9TVUJfTUlYWzBdW0cuU0JPWFt0ID4+PiAyNF1dIF4gRy5JTlZfU1VCX01JWFsxXVtHLlNCT1hbKHQgPj4+IDE2KSAmIDB4ZmZdXSBeIEcuSU5WX1NVQl9NSVhbMl1bRy5TQk9YWyh0ID4+PiA4KSAmIDB4ZmZdXSBeIEcuSU5WX1NVQl9NSVhbM11bRy5TQk9YW3QgJiAweGZmXV1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5BRVMucHJvdG90eXBlLmVuY3J5cHRCbG9jayA9IGZ1bmN0aW9uIChNKSB7XG4gIE0gPSBidWZmZXJUb0FycmF5KG5ldyBCdWZmZXIoTSkpXG4gIHZhciBvdXQgPSB0aGlzLl9kb0NyeXB0QmxvY2soTSwgdGhpcy5fa2V5U2NoZWR1bGUsIEcuU1VCX01JWCwgRy5TQk9YKVxuICB2YXIgYnVmID0gbmV3IEJ1ZmZlcigxNilcbiAgYnVmLndyaXRlVUludDMyQkUob3V0WzBdLCAwKVxuICBidWYud3JpdGVVSW50MzJCRShvdXRbMV0sIDQpXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKG91dFsyXSwgOClcbiAgYnVmLndyaXRlVUludDMyQkUob3V0WzNdLCAxMilcbiAgcmV0dXJuIGJ1ZlxufVxuXG5BRVMucHJvdG90eXBlLmRlY3J5cHRCbG9jayA9IGZ1bmN0aW9uIChNKSB7XG4gIE0gPSBidWZmZXJUb0FycmF5KG5ldyBCdWZmZXIoTSkpXG4gIHZhciB0ZW1wID0gW01bM10sIE1bMV1dXG4gIE1bMV0gPSB0ZW1wWzBdXG4gIE1bM10gPSB0ZW1wWzFdXG4gIHZhciBvdXQgPSB0aGlzLl9kb0NyeXB0QmxvY2soTSwgdGhpcy5faW52S2V5U2NoZWR1bGUsIEcuSU5WX1NVQl9NSVgsIEcuSU5WX1NCT1gpXG4gIHZhciBidWYgPSBuZXcgQnVmZmVyKDE2KVxuICBidWYud3JpdGVVSW50MzJCRShvdXRbMF0sIDApXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKG91dFszXSwgNClcbiAgYnVmLndyaXRlVUludDMyQkUob3V0WzJdLCA4KVxuICBidWYud3JpdGVVSW50MzJCRShvdXRbMV0sIDEyKVxuICByZXR1cm4gYnVmXG59XG5cbkFFUy5wcm90b3R5cGUuc2NydWIgPSBmdW5jdGlvbiAoKSB7XG4gIHNjcnViX3ZlYyh0aGlzLl9rZXlTY2hlZHVsZSlcbiAgc2NydWJfdmVjKHRoaXMuX2ludktleVNjaGVkdWxlKVxuICBzY3J1Yl92ZWModGhpcy5fa2V5KVxufVxuXG5BRVMucHJvdG90eXBlLl9kb0NyeXB0QmxvY2sgPSBmdW5jdGlvbiAoTSwga2V5U2NoZWR1bGUsIFNVQl9NSVgsIFNCT1gpIHtcbiAgdmFyIGtzUm93LCBzMCwgczEsIHMyLCBzMywgdDAsIHQxLCB0MiwgdDNcblxuICBzMCA9IE1bMF0gXiBrZXlTY2hlZHVsZVswXVxuICBzMSA9IE1bMV0gXiBrZXlTY2hlZHVsZVsxXVxuICBzMiA9IE1bMl0gXiBrZXlTY2hlZHVsZVsyXVxuICBzMyA9IE1bM10gXiBrZXlTY2hlZHVsZVszXVxuICBrc1JvdyA9IDRcbiAgZm9yICh2YXIgcm91bmQgPSAxOyByb3VuZCA8IHRoaXMuX25Sb3VuZHM7IHJvdW5kKyspIHtcbiAgICB0MCA9IFNVQl9NSVhbMF1bczAgPj4+IDI0XSBeIFNVQl9NSVhbMV1bKHMxID4+PiAxNikgJiAweGZmXSBeIFNVQl9NSVhbMl1bKHMyID4+PiA4KSAmIDB4ZmZdIF4gU1VCX01JWFszXVtzMyAmIDB4ZmZdIF4ga2V5U2NoZWR1bGVba3NSb3crK11cbiAgICB0MSA9IFNVQl9NSVhbMF1bczEgPj4+IDI0XSBeIFNVQl9NSVhbMV1bKHMyID4+PiAxNikgJiAweGZmXSBeIFNVQl9NSVhbMl1bKHMzID4+PiA4KSAmIDB4ZmZdIF4gU1VCX01JWFszXVtzMCAmIDB4ZmZdIF4ga2V5U2NoZWR1bGVba3NSb3crK11cbiAgICB0MiA9IFNVQl9NSVhbMF1bczIgPj4+IDI0XSBeIFNVQl9NSVhbMV1bKHMzID4+PiAxNikgJiAweGZmXSBeIFNVQl9NSVhbMl1bKHMwID4+PiA4KSAmIDB4ZmZdIF4gU1VCX01JWFszXVtzMSAmIDB4ZmZdIF4ga2V5U2NoZWR1bGVba3NSb3crK11cbiAgICB0MyA9IFNVQl9NSVhbMF1bczMgPj4+IDI0XSBeIFNVQl9NSVhbMV1bKHMwID4+PiAxNikgJiAweGZmXSBeIFNVQl9NSVhbMl1bKHMxID4+PiA4KSAmIDB4ZmZdIF4gU1VCX01JWFszXVtzMiAmIDB4ZmZdIF4ga2V5U2NoZWR1bGVba3NSb3crK11cbiAgICBzMCA9IHQwXG4gICAgczEgPSB0MVxuICAgIHMyID0gdDJcbiAgICBzMyA9IHQzXG4gIH1cbiAgdDAgPSAoKFNCT1hbczAgPj4+IDI0XSA8PCAyNCkgfCAoU0JPWFsoczEgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChTQk9YWyhzMiA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IFNCT1hbczMgJiAweGZmXSkgXiBrZXlTY2hlZHVsZVtrc1JvdysrXVxuICB0MSA9ICgoU0JPWFtzMSA+Pj4gMjRdIDw8IDI0KSB8IChTQk9YWyhzMiA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKFNCT1hbKHMzID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgU0JPWFtzMCAmIDB4ZmZdKSBeIGtleVNjaGVkdWxlW2tzUm93KytdXG4gIHQyID0gKChTQk9YW3MyID4+PiAyNF0gPDwgMjQpIHwgKFNCT1hbKHMzID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoU0JPWFsoczAgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBTQk9YW3MxICYgMHhmZl0pIF4ga2V5U2NoZWR1bGVba3NSb3crK11cbiAgdDMgPSAoKFNCT1hbczMgPj4+IDI0XSA8PCAyNCkgfCAoU0JPWFsoczAgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChTQk9YWyhzMSA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IFNCT1hbczIgJiAweGZmXSkgXiBrZXlTY2hlZHVsZVtrc1JvdysrXVxuICByZXR1cm4gW1xuICAgIGZpeHVwX3VpbnQzMih0MCksXG4gICAgZml4dXBfdWludDMyKHQxKSxcbiAgICBmaXh1cF91aW50MzIodDIpLFxuICAgIGZpeHVwX3VpbnQzMih0MylcbiAgXVxufVxuXG5leHBvcnRzLkFFUyA9IEFFU1xuIiwidmFyIGFlcyA9IHJlcXVpcmUoJy4vYWVzJylcbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCdjaXBoZXItYmFzZScpXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgR0hBU0ggPSByZXF1aXJlKCcuL2doYXNoJylcbnZhciB4b3IgPSByZXF1aXJlKCdidWZmZXIteG9yJylcbmluaGVyaXRzKFN0cmVhbUNpcGhlciwgVHJhbnNmb3JtKVxubW9kdWxlLmV4cG9ydHMgPSBTdHJlYW1DaXBoZXJcblxuZnVuY3Rpb24gU3RyZWFtQ2lwaGVyIChtb2RlLCBrZXksIGl2LCBkZWNyeXB0KSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTdHJlYW1DaXBoZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBTdHJlYW1DaXBoZXIobW9kZSwga2V5LCBpdilcbiAgfVxuICBUcmFuc2Zvcm0uY2FsbCh0aGlzKVxuICB0aGlzLl9maW5JRCA9IEJ1ZmZlci5jb25jYXQoW2l2LCBuZXcgQnVmZmVyKFswLCAwLCAwLCAxXSldKVxuICBpdiA9IEJ1ZmZlci5jb25jYXQoW2l2LCBuZXcgQnVmZmVyKFswLCAwLCAwLCAyXSldKVxuICB0aGlzLl9jaXBoZXIgPSBuZXcgYWVzLkFFUyhrZXkpXG4gIHRoaXMuX3ByZXYgPSBuZXcgQnVmZmVyKGl2Lmxlbmd0aClcbiAgdGhpcy5fY2FjaGUgPSBuZXcgQnVmZmVyKCcnKVxuICB0aGlzLl9zZWNDYWNoZSA9IG5ldyBCdWZmZXIoJycpXG4gIHRoaXMuX2RlY3J5cHQgPSBkZWNyeXB0XG4gIHRoaXMuX2FsZW4gPSAwXG4gIHRoaXMuX2xlbiA9IDBcbiAgaXYuY29weSh0aGlzLl9wcmV2KVxuICB0aGlzLl9tb2RlID0gbW9kZVxuICB2YXIgaCA9IG5ldyBCdWZmZXIoNClcbiAgaC5maWxsKDApXG4gIHRoaXMuX2doYXNoID0gbmV3IEdIQVNIKHRoaXMuX2NpcGhlci5lbmNyeXB0QmxvY2soaCkpXG4gIHRoaXMuX2F1dGhUYWcgPSBudWxsXG4gIHRoaXMuX2NhbGxlZCA9IGZhbHNlXG59XG5TdHJlYW1DaXBoZXIucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgaWYgKCF0aGlzLl9jYWxsZWQgJiYgdGhpcy5fYWxlbikge1xuICAgIHZhciBydW1wID0gMTYgLSAodGhpcy5fYWxlbiAlIDE2KVxuICAgIGlmIChydW1wIDwgMTYpIHtcbiAgICAgIHJ1bXAgPSBuZXcgQnVmZmVyKHJ1bXApXG4gICAgICBydW1wLmZpbGwoMClcbiAgICAgIHRoaXMuX2doYXNoLnVwZGF0ZShydW1wKVxuICAgIH1cbiAgfVxuICB0aGlzLl9jYWxsZWQgPSB0cnVlXG4gIHZhciBvdXQgPSB0aGlzLl9tb2RlLmVuY3J5cHQodGhpcywgY2h1bmspXG4gIGlmICh0aGlzLl9kZWNyeXB0KSB7XG4gICAgdGhpcy5fZ2hhc2gudXBkYXRlKGNodW5rKVxuICB9IGVsc2Uge1xuICAgIHRoaXMuX2doYXNoLnVwZGF0ZShvdXQpXG4gIH1cbiAgdGhpcy5fbGVuICs9IGNodW5rLmxlbmd0aFxuICByZXR1cm4gb3V0XG59XG5TdHJlYW1DaXBoZXIucHJvdG90eXBlLl9maW5hbCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuX2RlY3J5cHQgJiYgIXRoaXMuX2F1dGhUYWcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHN0YXRlIG9yIHVuYWJsZSB0byBhdXRoZW50aWNhdGUgZGF0YScpXG4gIH1cbiAgdmFyIHRhZyA9IHhvcih0aGlzLl9naGFzaC5maW5hbCh0aGlzLl9hbGVuICogOCwgdGhpcy5fbGVuICogOCksIHRoaXMuX2NpcGhlci5lbmNyeXB0QmxvY2sodGhpcy5fZmluSUQpKVxuICBpZiAodGhpcy5fZGVjcnlwdCkge1xuICAgIGlmICh4b3JUZXN0KHRhZywgdGhpcy5fYXV0aFRhZykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgc3RhdGUgb3IgdW5hYmxlIHRvIGF1dGhlbnRpY2F0ZSBkYXRhJylcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fYXV0aFRhZyA9IHRhZ1xuICB9XG4gIHRoaXMuX2NpcGhlci5zY3J1YigpXG59XG5TdHJlYW1DaXBoZXIucHJvdG90eXBlLmdldEF1dGhUYWcgPSBmdW5jdGlvbiBnZXRBdXRoVGFnICgpIHtcbiAgaWYgKCF0aGlzLl9kZWNyeXB0ICYmIEJ1ZmZlci5pc0J1ZmZlcih0aGlzLl9hdXRoVGFnKSkge1xuICAgIHJldHVybiB0aGlzLl9hdXRoVGFnXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdBdHRlbXB0aW5nIHRvIGdldCBhdXRoIHRhZyBpbiB1bnN1cHBvcnRlZCBzdGF0ZScpXG4gIH1cbn1cblN0cmVhbUNpcGhlci5wcm90b3R5cGUuc2V0QXV0aFRhZyA9IGZ1bmN0aW9uIHNldEF1dGhUYWcgKHRhZykge1xuICBpZiAodGhpcy5fZGVjcnlwdCkge1xuICAgIHRoaXMuX2F1dGhUYWcgPSB0YWdcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0F0dGVtcHRpbmcgdG8gc2V0IGF1dGggdGFnIGluIHVuc3VwcG9ydGVkIHN0YXRlJylcbiAgfVxufVxuU3RyZWFtQ2lwaGVyLnByb3RvdHlwZS5zZXRBQUQgPSBmdW5jdGlvbiBzZXRBQUQgKGJ1Zikge1xuICBpZiAoIXRoaXMuX2NhbGxlZCkge1xuICAgIHRoaXMuX2doYXNoLnVwZGF0ZShidWYpXG4gICAgdGhpcy5fYWxlbiArPSBidWYubGVuZ3RoXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdBdHRlbXB0aW5nIHRvIHNldCBBQUQgaW4gdW5zdXBwb3J0ZWQgc3RhdGUnKVxuICB9XG59XG5mdW5jdGlvbiB4b3JUZXN0IChhLCBiKSB7XG4gIHZhciBvdXQgPSAwXG4gIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICBvdXQrK1xuICB9XG4gIHZhciBsZW4gPSBNYXRoLm1pbihhLmxlbmd0aCwgYi5sZW5ndGgpXG4gIHZhciBpID0gLTFcbiAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgIG91dCArPSAoYVtpXSBeIGJbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuIiwidmFyIGFlcyA9IHJlcXVpcmUoJy4vYWVzJylcbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCdjaXBoZXItYmFzZScpXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgbW9kZXMgPSByZXF1aXJlKCcuL21vZGVzJylcbnZhciBTdHJlYW1DaXBoZXIgPSByZXF1aXJlKCcuL3N0cmVhbUNpcGhlcicpXG52YXIgQXV0aENpcGhlciA9IHJlcXVpcmUoJy4vYXV0aENpcGhlcicpXG52YXIgZWJ0ayA9IHJlcXVpcmUoJ2V2cF9ieXRlc3Rva2V5JylcblxuaW5oZXJpdHMoRGVjaXBoZXIsIFRyYW5zZm9ybSlcbmZ1bmN0aW9uIERlY2lwaGVyIChtb2RlLCBrZXksIGl2KSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEZWNpcGhlcikpIHtcbiAgICByZXR1cm4gbmV3IERlY2lwaGVyKG1vZGUsIGtleSwgaXYpXG4gIH1cbiAgVHJhbnNmb3JtLmNhbGwodGhpcylcbiAgdGhpcy5fY2FjaGUgPSBuZXcgU3BsaXR0ZXIoKVxuICB0aGlzLl9sYXN0ID0gdm9pZCAwXG4gIHRoaXMuX2NpcGhlciA9IG5ldyBhZXMuQUVTKGtleSlcbiAgdGhpcy5fcHJldiA9IG5ldyBCdWZmZXIoaXYubGVuZ3RoKVxuICBpdi5jb3B5KHRoaXMuX3ByZXYpXG4gIHRoaXMuX21vZGUgPSBtb2RlXG4gIHRoaXMuX2F1dG9wYWRkaW5nID0gdHJ1ZVxufVxuRGVjaXBoZXIucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB0aGlzLl9jYWNoZS5hZGQoZGF0YSlcbiAgdmFyIGNodW5rXG4gIHZhciB0aGluZ1xuICB2YXIgb3V0ID0gW11cbiAgd2hpbGUgKChjaHVuayA9IHRoaXMuX2NhY2hlLmdldCh0aGlzLl9hdXRvcGFkZGluZykpKSB7XG4gICAgdGhpbmcgPSB0aGlzLl9tb2RlLmRlY3J5cHQodGhpcywgY2h1bmspXG4gICAgb3V0LnB1c2godGhpbmcpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5jb25jYXQob3V0KVxufVxuRGVjaXBoZXIucHJvdG90eXBlLl9maW5hbCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGNodW5rID0gdGhpcy5fY2FjaGUuZmx1c2goKVxuICBpZiAodGhpcy5fYXV0b3BhZGRpbmcpIHtcbiAgICByZXR1cm4gdW5wYWQodGhpcy5fbW9kZS5kZWNyeXB0KHRoaXMsIGNodW5rKSlcbiAgfSBlbHNlIGlmIChjaHVuaykge1xuICAgIHRocm93IG5ldyBFcnJvcignZGF0YSBub3QgbXVsdGlwbGUgb2YgYmxvY2sgbGVuZ3RoJylcbiAgfVxufVxuRGVjaXBoZXIucHJvdG90eXBlLnNldEF1dG9QYWRkaW5nID0gZnVuY3Rpb24gKHNldFRvKSB7XG4gIHRoaXMuX2F1dG9wYWRkaW5nID0gISFzZXRUb1xufVxuZnVuY3Rpb24gU3BsaXR0ZXIgKCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU3BsaXR0ZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBTcGxpdHRlcigpXG4gIH1cbiAgdGhpcy5jYWNoZSA9IG5ldyBCdWZmZXIoJycpXG59XG5TcGxpdHRlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgdGhpcy5jYWNoZSA9IEJ1ZmZlci5jb25jYXQoW3RoaXMuY2FjaGUsIGRhdGFdKVxufVxuXG5TcGxpdHRlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGF1dG9QYWRkaW5nKSB7XG4gIHZhciBvdXRcbiAgaWYgKGF1dG9QYWRkaW5nKSB7XG4gICAgaWYgKHRoaXMuY2FjaGUubGVuZ3RoID4gMTYpIHtcbiAgICAgIG91dCA9IHRoaXMuY2FjaGUuc2xpY2UoMCwgMTYpXG4gICAgICB0aGlzLmNhY2hlID0gdGhpcy5jYWNoZS5zbGljZSgxNilcbiAgICAgIHJldHVybiBvdXRcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHRoaXMuY2FjaGUubGVuZ3RoID49IDE2KSB7XG4gICAgICBvdXQgPSB0aGlzLmNhY2hlLnNsaWNlKDAsIDE2KVxuICAgICAgdGhpcy5jYWNoZSA9IHRoaXMuY2FjaGUuc2xpY2UoMTYpXG4gICAgICByZXR1cm4gb3V0XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsXG59XG5TcGxpdHRlci5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmNhY2hlLmxlbmd0aCkge1xuICAgIHJldHVybiB0aGlzLmNhY2hlXG4gIH1cbn1cbmZ1bmN0aW9uIHVucGFkIChsYXN0KSB7XG4gIHZhciBwYWRkZWQgPSBsYXN0WzE1XVxuICB2YXIgaSA9IC0xXG4gIHdoaWxlICgrK2kgPCBwYWRkZWQpIHtcbiAgICBpZiAobGFzdFsoaSArICgxNiAtIHBhZGRlZCkpXSAhPT0gcGFkZGVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuYWJsZSB0byBkZWNyeXB0IGRhdGEnKVxuICAgIH1cbiAgfVxuICBpZiAocGFkZGVkID09PSAxNikge1xuICAgIHJldHVyblxuICB9XG4gIHJldHVybiBsYXN0LnNsaWNlKDAsIDE2IC0gcGFkZGVkKVxufVxuXG52YXIgbW9kZWxpc3QgPSB7XG4gIEVDQjogcmVxdWlyZSgnLi9tb2Rlcy9lY2InKSxcbiAgQ0JDOiByZXF1aXJlKCcuL21vZGVzL2NiYycpLFxuICBDRkI6IHJlcXVpcmUoJy4vbW9kZXMvY2ZiJyksXG4gIENGQjg6IHJlcXVpcmUoJy4vbW9kZXMvY2ZiOCcpLFxuICBDRkIxOiByZXF1aXJlKCcuL21vZGVzL2NmYjEnKSxcbiAgT0ZCOiByZXF1aXJlKCcuL21vZGVzL29mYicpLFxuICBDVFI6IHJlcXVpcmUoJy4vbW9kZXMvY3RyJyksXG4gIEdDTTogcmVxdWlyZSgnLi9tb2Rlcy9jdHInKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVEZWNpcGhlcml2IChzdWl0ZSwgcGFzc3dvcmQsIGl2KSB7XG4gIHZhciBjb25maWcgPSBtb2Rlc1tzdWl0ZS50b0xvd2VyQ2FzZSgpXVxuICBpZiAoIWNvbmZpZykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgc3VpdGUgdHlwZScpXG4gIH1cbiAgaWYgKHR5cGVvZiBpdiA9PT0gJ3N0cmluZycpIHtcbiAgICBpdiA9IG5ldyBCdWZmZXIoaXYpXG4gIH1cbiAgaWYgKHR5cGVvZiBwYXNzd29yZCA9PT0gJ3N0cmluZycpIHtcbiAgICBwYXNzd29yZCA9IG5ldyBCdWZmZXIocGFzc3dvcmQpXG4gIH1cbiAgaWYgKHBhc3N3b3JkLmxlbmd0aCAhPT0gY29uZmlnLmtleSAvIDgpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGtleSBsZW5ndGggJyArIHBhc3N3b3JkLmxlbmd0aClcbiAgfVxuICBpZiAoaXYubGVuZ3RoICE9PSBjb25maWcuaXYpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGl2IGxlbmd0aCAnICsgaXYubGVuZ3RoKVxuICB9XG4gIGlmIChjb25maWcudHlwZSA9PT0gJ3N0cmVhbScpIHtcbiAgICByZXR1cm4gbmV3IFN0cmVhbUNpcGhlcihtb2RlbGlzdFtjb25maWcubW9kZV0sIHBhc3N3b3JkLCBpdiwgdHJ1ZSlcbiAgfSBlbHNlIGlmIChjb25maWcudHlwZSA9PT0gJ2F1dGgnKSB7XG4gICAgcmV0dXJuIG5ldyBBdXRoQ2lwaGVyKG1vZGVsaXN0W2NvbmZpZy5tb2RlXSwgcGFzc3dvcmQsIGl2LCB0cnVlKVxuICB9XG4gIHJldHVybiBuZXcgRGVjaXBoZXIobW9kZWxpc3RbY29uZmlnLm1vZGVdLCBwYXNzd29yZCwgaXYpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZURlY2lwaGVyIChzdWl0ZSwgcGFzc3dvcmQpIHtcbiAgdmFyIGNvbmZpZyA9IG1vZGVzW3N1aXRlLnRvTG93ZXJDYXNlKCldXG4gIGlmICghY29uZmlnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBzdWl0ZSB0eXBlJylcbiAgfVxuICB2YXIga2V5cyA9IGVidGsocGFzc3dvcmQsIGZhbHNlLCBjb25maWcua2V5LCBjb25maWcuaXYpXG4gIHJldHVybiBjcmVhdGVEZWNpcGhlcml2KHN1aXRlLCBrZXlzLmtleSwga2V5cy5pdilcbn1cbmV4cG9ydHMuY3JlYXRlRGVjaXBoZXIgPSBjcmVhdGVEZWNpcGhlclxuZXhwb3J0cy5jcmVhdGVEZWNpcGhlcml2ID0gY3JlYXRlRGVjaXBoZXJpdlxuIiwidmFyIGFlcyA9IHJlcXVpcmUoJy4vYWVzJylcbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCdjaXBoZXItYmFzZScpXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgbW9kZXMgPSByZXF1aXJlKCcuL21vZGVzJylcbnZhciBlYnRrID0gcmVxdWlyZSgnZXZwX2J5dGVzdG9rZXknKVxudmFyIFN0cmVhbUNpcGhlciA9IHJlcXVpcmUoJy4vc3RyZWFtQ2lwaGVyJylcbnZhciBBdXRoQ2lwaGVyID0gcmVxdWlyZSgnLi9hdXRoQ2lwaGVyJylcbmluaGVyaXRzKENpcGhlciwgVHJhbnNmb3JtKVxuZnVuY3Rpb24gQ2lwaGVyIChtb2RlLCBrZXksIGl2KSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBDaXBoZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBDaXBoZXIobW9kZSwga2V5LCBpdilcbiAgfVxuICBUcmFuc2Zvcm0uY2FsbCh0aGlzKVxuICB0aGlzLl9jYWNoZSA9IG5ldyBTcGxpdHRlcigpXG4gIHRoaXMuX2NpcGhlciA9IG5ldyBhZXMuQUVTKGtleSlcbiAgdGhpcy5fcHJldiA9IG5ldyBCdWZmZXIoaXYubGVuZ3RoKVxuICBpdi5jb3B5KHRoaXMuX3ByZXYpXG4gIHRoaXMuX21vZGUgPSBtb2RlXG4gIHRoaXMuX2F1dG9wYWRkaW5nID0gdHJ1ZVxufVxuQ2lwaGVyLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgdGhpcy5fY2FjaGUuYWRkKGRhdGEpXG4gIHZhciBjaHVua1xuICB2YXIgdGhpbmdcbiAgdmFyIG91dCA9IFtdXG4gIHdoaWxlICgoY2h1bmsgPSB0aGlzLl9jYWNoZS5nZXQoKSkpIHtcbiAgICB0aGluZyA9IHRoaXMuX21vZGUuZW5jcnlwdCh0aGlzLCBjaHVuaylcbiAgICBvdXQucHVzaCh0aGluZylcbiAgfVxuICByZXR1cm4gQnVmZmVyLmNvbmNhdChvdXQpXG59XG5DaXBoZXIucHJvdG90eXBlLl9maW5hbCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGNodW5rID0gdGhpcy5fY2FjaGUuZmx1c2goKVxuICBpZiAodGhpcy5fYXV0b3BhZGRpbmcpIHtcbiAgICBjaHVuayA9IHRoaXMuX21vZGUuZW5jcnlwdCh0aGlzLCBjaHVuaylcbiAgICB0aGlzLl9jaXBoZXIuc2NydWIoKVxuICAgIHJldHVybiBjaHVua1xuICB9IGVsc2UgaWYgKGNodW5rLnRvU3RyaW5nKCdoZXgnKSAhPT0gJzEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwJykge1xuICAgIHRoaXMuX2NpcGhlci5zY3J1YigpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdkYXRhIG5vdCBtdWx0aXBsZSBvZiBibG9jayBsZW5ndGgnKVxuICB9XG59XG5DaXBoZXIucHJvdG90eXBlLnNldEF1dG9QYWRkaW5nID0gZnVuY3Rpb24gKHNldFRvKSB7XG4gIHRoaXMuX2F1dG9wYWRkaW5nID0gISFzZXRUb1xufVxuXG5mdW5jdGlvbiBTcGxpdHRlciAoKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTcGxpdHRlcikpIHtcbiAgICByZXR1cm4gbmV3IFNwbGl0dGVyKClcbiAgfVxuICB0aGlzLmNhY2hlID0gbmV3IEJ1ZmZlcignJylcbn1cblNwbGl0dGVyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB0aGlzLmNhY2hlID0gQnVmZmVyLmNvbmNhdChbdGhpcy5jYWNoZSwgZGF0YV0pXG59XG5cblNwbGl0dGVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmNhY2hlLmxlbmd0aCA+IDE1KSB7XG4gICAgdmFyIG91dCA9IHRoaXMuY2FjaGUuc2xpY2UoMCwgMTYpXG4gICAgdGhpcy5jYWNoZSA9IHRoaXMuY2FjaGUuc2xpY2UoMTYpXG4gICAgcmV0dXJuIG91dFxuICB9XG4gIHJldHVybiBudWxsXG59XG5TcGxpdHRlci5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBsZW4gPSAxNiAtIHRoaXMuY2FjaGUubGVuZ3RoXG4gIHZhciBwYWRCdWZmID0gbmV3IEJ1ZmZlcihsZW4pXG5cbiAgdmFyIGkgPSAtMVxuICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgcGFkQnVmZi53cml0ZVVJbnQ4KGxlbiwgaSlcbiAgfVxuICB2YXIgb3V0ID0gQnVmZmVyLmNvbmNhdChbdGhpcy5jYWNoZSwgcGFkQnVmZl0pXG4gIHJldHVybiBvdXRcbn1cbnZhciBtb2RlbGlzdCA9IHtcbiAgRUNCOiByZXF1aXJlKCcuL21vZGVzL2VjYicpLFxuICBDQkM6IHJlcXVpcmUoJy4vbW9kZXMvY2JjJyksXG4gIENGQjogcmVxdWlyZSgnLi9tb2Rlcy9jZmInKSxcbiAgQ0ZCODogcmVxdWlyZSgnLi9tb2Rlcy9jZmI4JyksXG4gIENGQjE6IHJlcXVpcmUoJy4vbW9kZXMvY2ZiMScpLFxuICBPRkI6IHJlcXVpcmUoJy4vbW9kZXMvb2ZiJyksXG4gIENUUjogcmVxdWlyZSgnLi9tb2Rlcy9jdHInKSxcbiAgR0NNOiByZXF1aXJlKCcuL21vZGVzL2N0cicpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNpcGhlcml2IChzdWl0ZSwgcGFzc3dvcmQsIGl2KSB7XG4gIHZhciBjb25maWcgPSBtb2Rlc1tzdWl0ZS50b0xvd2VyQ2FzZSgpXVxuICBpZiAoIWNvbmZpZykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgc3VpdGUgdHlwZScpXG4gIH1cbiAgaWYgKHR5cGVvZiBpdiA9PT0gJ3N0cmluZycpIHtcbiAgICBpdiA9IG5ldyBCdWZmZXIoaXYpXG4gIH1cbiAgaWYgKHR5cGVvZiBwYXNzd29yZCA9PT0gJ3N0cmluZycpIHtcbiAgICBwYXNzd29yZCA9IG5ldyBCdWZmZXIocGFzc3dvcmQpXG4gIH1cbiAgaWYgKHBhc3N3b3JkLmxlbmd0aCAhPT0gY29uZmlnLmtleSAvIDgpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGtleSBsZW5ndGggJyArIHBhc3N3b3JkLmxlbmd0aClcbiAgfVxuICBpZiAoaXYubGVuZ3RoICE9PSBjb25maWcuaXYpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGl2IGxlbmd0aCAnICsgaXYubGVuZ3RoKVxuICB9XG4gIGlmIChjb25maWcudHlwZSA9PT0gJ3N0cmVhbScpIHtcbiAgICByZXR1cm4gbmV3IFN0cmVhbUNpcGhlcihtb2RlbGlzdFtjb25maWcubW9kZV0sIHBhc3N3b3JkLCBpdilcbiAgfSBlbHNlIGlmIChjb25maWcudHlwZSA9PT0gJ2F1dGgnKSB7XG4gICAgcmV0dXJuIG5ldyBBdXRoQ2lwaGVyKG1vZGVsaXN0W2NvbmZpZy5tb2RlXSwgcGFzc3dvcmQsIGl2KVxuICB9XG4gIHJldHVybiBuZXcgQ2lwaGVyKG1vZGVsaXN0W2NvbmZpZy5tb2RlXSwgcGFzc3dvcmQsIGl2KVxufVxuZnVuY3Rpb24gY3JlYXRlQ2lwaGVyIChzdWl0ZSwgcGFzc3dvcmQpIHtcbiAgdmFyIGNvbmZpZyA9IG1vZGVzW3N1aXRlLnRvTG93ZXJDYXNlKCldXG4gIGlmICghY29uZmlnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBzdWl0ZSB0eXBlJylcbiAgfVxuICB2YXIga2V5cyA9IGVidGsocGFzc3dvcmQsIGZhbHNlLCBjb25maWcua2V5LCBjb25maWcuaXYpXG4gIHJldHVybiBjcmVhdGVDaXBoZXJpdihzdWl0ZSwga2V5cy5rZXksIGtleXMuaXYpXG59XG5cbmV4cG9ydHMuY3JlYXRlQ2lwaGVyaXYgPSBjcmVhdGVDaXBoZXJpdlxuZXhwb3J0cy5jcmVhdGVDaXBoZXIgPSBjcmVhdGVDaXBoZXJcbiIsInZhciB6ZXJvcyA9IG5ldyBCdWZmZXIoMTYpXG56ZXJvcy5maWxsKDApXG5tb2R1bGUuZXhwb3J0cyA9IEdIQVNIXG5mdW5jdGlvbiBHSEFTSCAoa2V5KSB7XG4gIHRoaXMuaCA9IGtleVxuICB0aGlzLnN0YXRlID0gbmV3IEJ1ZmZlcigxNilcbiAgdGhpcy5zdGF0ZS5maWxsKDApXG4gIHRoaXMuY2FjaGUgPSBuZXcgQnVmZmVyKCcnKVxufVxuLy8gZnJvbSBodHRwOi8vYml0d2lzZXNoaWZ0bGVmdC5naXRodWIuaW8vc2pjbC9kb2Mvc3ltYm9scy9zcmMvY29yZV9nY20uanMuaHRtbFxuLy8gYnkgSnVobyBWw6Row6QtSGVydHR1YVxuR0hBU0gucHJvdG90eXBlLmdoYXNoID0gZnVuY3Rpb24gKGJsb2NrKSB7XG4gIHZhciBpID0gLTFcbiAgd2hpbGUgKCsraSA8IGJsb2NrLmxlbmd0aCkge1xuICAgIHRoaXMuc3RhdGVbaV0gXj0gYmxvY2tbaV1cbiAgfVxuICB0aGlzLl9tdWx0aXBseSgpXG59XG5cbkdIQVNILnByb3RvdHlwZS5fbXVsdGlwbHkgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBWaSA9IHRvQXJyYXkodGhpcy5oKVxuICB2YXIgWmkgPSBbMCwgMCwgMCwgMF1cbiAgdmFyIGosIHhpLCBsc2JfVmlcbiAgdmFyIGkgPSAtMVxuICB3aGlsZSAoKytpIDwgMTI4KSB7XG4gICAgeGkgPSAodGhpcy5zdGF0ZVt+fihpIC8gOCldICYgKDEgPDwgKDcgLSBpICUgOCkpKSAhPT0gMFxuICAgIGlmICh4aSkge1xuICAgICAgLy8gWl9pKzEgPSBaX2kgXiBWX2lcbiAgICAgIFppID0geG9yKFppLCBWaSlcbiAgICB9XG5cbiAgICAvLyBTdG9yZSB0aGUgdmFsdWUgb2YgTFNCKFZfaSlcbiAgICBsc2JfVmkgPSAoVmlbM10gJiAxKSAhPT0gMFxuXG4gICAgLy8gVl9pKzEgPSBWX2kgPj4gMVxuICAgIGZvciAoaiA9IDM7IGogPiAwOyBqLS0pIHtcbiAgICAgIFZpW2pdID0gKFZpW2pdID4+PiAxKSB8ICgoVmlbaiAtIDFdICYgMSkgPDwgMzEpXG4gICAgfVxuICAgIFZpWzBdID0gVmlbMF0gPj4+IDFcblxuICAgIC8vIElmIExTQihWX2kpIGlzIDEsIFZfaSsxID0gKFZfaSA+PiAxKSBeIFJcbiAgICBpZiAobHNiX1ZpKSB7XG4gICAgICBWaVswXSA9IFZpWzBdIF4gKDB4ZTEgPDwgMjQpXG4gICAgfVxuICB9XG4gIHRoaXMuc3RhdGUgPSBmcm9tQXJyYXkoWmkpXG59XG5HSEFTSC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGJ1Zikge1xuICB0aGlzLmNhY2hlID0gQnVmZmVyLmNvbmNhdChbdGhpcy5jYWNoZSwgYnVmXSlcbiAgdmFyIGNodW5rXG4gIHdoaWxlICh0aGlzLmNhY2hlLmxlbmd0aCA+PSAxNikge1xuICAgIGNodW5rID0gdGhpcy5jYWNoZS5zbGljZSgwLCAxNilcbiAgICB0aGlzLmNhY2hlID0gdGhpcy5jYWNoZS5zbGljZSgxNilcbiAgICB0aGlzLmdoYXNoKGNodW5rKVxuICB9XG59XG5HSEFTSC5wcm90b3R5cGUuZmluYWwgPSBmdW5jdGlvbiAoYWJsLCBibCkge1xuICBpZiAodGhpcy5jYWNoZS5sZW5ndGgpIHtcbiAgICB0aGlzLmdoYXNoKEJ1ZmZlci5jb25jYXQoW3RoaXMuY2FjaGUsIHplcm9zXSwgMTYpKVxuICB9XG4gIHRoaXMuZ2hhc2goZnJvbUFycmF5KFtcbiAgICAwLCBhYmwsXG4gICAgMCwgYmxcbiAgXSkpXG4gIHJldHVybiB0aGlzLnN0YXRlXG59XG5cbmZ1bmN0aW9uIHRvQXJyYXkgKGJ1Zikge1xuICByZXR1cm4gW1xuICAgIGJ1Zi5yZWFkVUludDMyQkUoMCksXG4gICAgYnVmLnJlYWRVSW50MzJCRSg0KSxcbiAgICBidWYucmVhZFVJbnQzMkJFKDgpLFxuICAgIGJ1Zi5yZWFkVUludDMyQkUoMTIpXG4gIF1cbn1cbmZ1bmN0aW9uIGZyb21BcnJheSAob3V0KSB7XG4gIG91dCA9IG91dC5tYXAoZml4dXBfdWludDMyKVxuICB2YXIgYnVmID0gbmV3IEJ1ZmZlcigxNilcbiAgYnVmLndyaXRlVUludDMyQkUob3V0WzBdLCAwKVxuICBidWYud3JpdGVVSW50MzJCRShvdXRbMV0sIDQpXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKG91dFsyXSwgOClcbiAgYnVmLndyaXRlVUludDMyQkUob3V0WzNdLCAxMilcbiAgcmV0dXJuIGJ1ZlxufVxudmFyIHVpbnRfbWF4ID0gTWF0aC5wb3coMiwgMzIpXG5mdW5jdGlvbiBmaXh1cF91aW50MzIgKHgpIHtcbiAgdmFyIHJldCwgeF9wb3NcbiAgcmV0ID0geCA+IHVpbnRfbWF4IHx8IHggPCAwID8gKHhfcG9zID0gTWF0aC5hYnMoeCkgJSB1aW50X21heCwgeCA8IDAgPyB1aW50X21heCAtIHhfcG9zIDogeF9wb3MpIDogeFxuICByZXR1cm4gcmV0XG59XG5mdW5jdGlvbiB4b3IgKGEsIGIpIHtcbiAgcmV0dXJuIFtcbiAgICBhWzBdIF4gYlswXSxcbiAgICBhWzFdIF4gYlsxXSxcbiAgICBhWzJdIF4gYlsyXSxcbiAgICBhWzNdIF4gYlszXVxuICBdXG59XG4iLCJ2YXIgeG9yID0gcmVxdWlyZSgnYnVmZmVyLXhvcicpXG5cbmV4cG9ydHMuZW5jcnlwdCA9IGZ1bmN0aW9uIChzZWxmLCBkYXRhLCBkZWNyeXB0KSB7XG4gIHZhciBvdXQgPSBuZXcgQnVmZmVyKCcnKVxuICB2YXIgbGVuXG5cbiAgd2hpbGUgKGRhdGEubGVuZ3RoKSB7XG4gICAgaWYgKHNlbGYuX2NhY2hlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgc2VsZi5fY2FjaGUgPSBzZWxmLl9jaXBoZXIuZW5jcnlwdEJsb2NrKHNlbGYuX3ByZXYpXG4gICAgICBzZWxmLl9wcmV2ID0gbmV3IEJ1ZmZlcignJylcbiAgICB9XG5cbiAgICBpZiAoc2VsZi5fY2FjaGUubGVuZ3RoIDw9IGRhdGEubGVuZ3RoKSB7XG4gICAgICBsZW4gPSBzZWxmLl9jYWNoZS5sZW5ndGhcbiAgICAgIG91dCA9IEJ1ZmZlci5jb25jYXQoW291dCwgZW5jcnlwdFN0YXJ0KHNlbGYsIGRhdGEuc2xpY2UoMCwgbGVuKSwgZGVjcnlwdCldKVxuICAgICAgZGF0YSA9IGRhdGEuc2xpY2UobGVuKVxuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgPSBCdWZmZXIuY29uY2F0KFtvdXQsIGVuY3J5cHRTdGFydChzZWxmLCBkYXRhLCBkZWNyeXB0KV0pXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvdXRcbn1cbmZ1bmN0aW9uIGVuY3J5cHRTdGFydCAoc2VsZiwgZGF0YSwgZGVjcnlwdCkge1xuICB2YXIgbGVuID0gZGF0YS5sZW5ndGhcbiAgdmFyIG91dCA9IHhvcihkYXRhLCBzZWxmLl9jYWNoZSlcbiAgc2VsZi5fY2FjaGUgPSBzZWxmLl9jYWNoZS5zbGljZShsZW4pXG4gIHNlbGYuX3ByZXYgPSBCdWZmZXIuY29uY2F0KFtzZWxmLl9wcmV2LCBkZWNyeXB0ID8gZGF0YSA6IG91dF0pXG4gIHJldHVybiBvdXRcbn1cbiIsImZ1bmN0aW9uIGVuY3J5cHRCeXRlIChzZWxmLCBieXRlUGFyYW0sIGRlY3J5cHQpIHtcbiAgdmFyIHBhZFxuICB2YXIgaSA9IC0xXG4gIHZhciBsZW4gPSA4XG4gIHZhciBvdXQgPSAwXG4gIHZhciBiaXQsIHZhbHVlXG4gIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICBwYWQgPSBzZWxmLl9jaXBoZXIuZW5jcnlwdEJsb2NrKHNlbGYuX3ByZXYpXG4gICAgYml0ID0gKGJ5dGVQYXJhbSAmICgxIDw8ICg3IC0gaSkpKSA/IDB4ODAgOiAwXG4gICAgdmFsdWUgPSBwYWRbMF0gXiBiaXRcbiAgICBvdXQgKz0gKCh2YWx1ZSAmIDB4ODApID4+IChpICUgOCkpXG4gICAgc2VsZi5fcHJldiA9IHNoaWZ0SW4oc2VsZi5fcHJldiwgZGVjcnlwdCA/IGJpdCA6IHZhbHVlKVxuICB9XG4gIHJldHVybiBvdXRcbn1cbmV4cG9ydHMuZW5jcnlwdCA9IGZ1bmN0aW9uIChzZWxmLCBjaHVuaywgZGVjcnlwdCkge1xuICB2YXIgbGVuID0gY2h1bmsubGVuZ3RoXG4gIHZhciBvdXQgPSBuZXcgQnVmZmVyKGxlbilcbiAgdmFyIGkgPSAtMVxuICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgb3V0W2ldID0gZW5jcnlwdEJ5dGUoc2VsZiwgY2h1bmtbaV0sIGRlY3J5cHQpXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuZnVuY3Rpb24gc2hpZnRJbiAoYnVmZmVyLCB2YWx1ZSkge1xuICB2YXIgbGVuID0gYnVmZmVyLmxlbmd0aFxuICB2YXIgaSA9IC0xXG4gIHZhciBvdXQgPSBuZXcgQnVmZmVyKGJ1ZmZlci5sZW5ndGgpXG4gIGJ1ZmZlciA9IEJ1ZmZlci5jb25jYXQoW2J1ZmZlciwgbmV3IEJ1ZmZlcihbdmFsdWVdKV0pXG4gIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICBvdXRbaV0gPSBidWZmZXJbaV0gPDwgMSB8IGJ1ZmZlcltpICsgMV0gPj4gKDcpXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuIiwiZnVuY3Rpb24gZW5jcnlwdEJ5dGUgKHNlbGYsIGJ5dGVQYXJhbSwgZGVjcnlwdCkge1xuICB2YXIgcGFkID0gc2VsZi5fY2lwaGVyLmVuY3J5cHRCbG9jayhzZWxmLl9wcmV2KVxuICB2YXIgb3V0ID0gcGFkWzBdIF4gYnl0ZVBhcmFtXG4gIHNlbGYuX3ByZXYgPSBCdWZmZXIuY29uY2F0KFtzZWxmLl9wcmV2LnNsaWNlKDEpLCBuZXcgQnVmZmVyKFtkZWNyeXB0ID8gYnl0ZVBhcmFtIDogb3V0XSldKVxuICByZXR1cm4gb3V0XG59XG5leHBvcnRzLmVuY3J5cHQgPSBmdW5jdGlvbiAoc2VsZiwgY2h1bmssIGRlY3J5cHQpIHtcbiAgdmFyIGxlbiA9IGNodW5rLmxlbmd0aFxuICB2YXIgb3V0ID0gbmV3IEJ1ZmZlcihsZW4pXG4gIHZhciBpID0gLTFcbiAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgIG91dFtpXSA9IGVuY3J5cHRCeXRlKHNlbGYsIGNodW5rW2ldLCBkZWNyeXB0KVxuICB9XG4gIHJldHVybiBvdXRcbn1cbiIsInZhciB4b3IgPSByZXF1aXJlKCdidWZmZXIteG9yJylcblxuZnVuY3Rpb24gaW5jcjMyIChpdikge1xuICB2YXIgbGVuID0gaXYubGVuZ3RoXG4gIHZhciBpdGVtXG4gIHdoaWxlIChsZW4tLSkge1xuICAgIGl0ZW0gPSBpdi5yZWFkVUludDgobGVuKVxuICAgIGlmIChpdGVtID09PSAyNTUpIHtcbiAgICAgIGl2LndyaXRlVUludDgoMCwgbGVuKVxuICAgIH0gZWxzZSB7XG4gICAgICBpdGVtKytcbiAgICAgIGl2LndyaXRlVUludDgoaXRlbSwgbGVuKVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0QmxvY2sgKHNlbGYpIHtcbiAgdmFyIG91dCA9IHNlbGYuX2NpcGhlci5lbmNyeXB0QmxvY2soc2VsZi5fcHJldilcbiAgaW5jcjMyKHNlbGYuX3ByZXYpXG4gIHJldHVybiBvdXRcbn1cblxuZXhwb3J0cy5lbmNyeXB0ID0gZnVuY3Rpb24gKHNlbGYsIGNodW5rKSB7XG4gIHdoaWxlIChzZWxmLl9jYWNoZS5sZW5ndGggPCBjaHVuay5sZW5ndGgpIHtcbiAgICBzZWxmLl9jYWNoZSA9IEJ1ZmZlci5jb25jYXQoW3NlbGYuX2NhY2hlLCBnZXRCbG9jayhzZWxmKV0pXG4gIH1cbiAgdmFyIHBhZCA9IHNlbGYuX2NhY2hlLnNsaWNlKDAsIGNodW5rLmxlbmd0aClcbiAgc2VsZi5fY2FjaGUgPSBzZWxmLl9jYWNoZS5zbGljZShjaHVuay5sZW5ndGgpXG4gIHJldHVybiB4b3IoY2h1bmssIHBhZClcbn1cbiIsInZhciB4b3IgPSByZXF1aXJlKCdidWZmZXIteG9yJylcblxuZnVuY3Rpb24gZ2V0QmxvY2sgKHNlbGYpIHtcbiAgc2VsZi5fcHJldiA9IHNlbGYuX2NpcGhlci5lbmNyeXB0QmxvY2soc2VsZi5fcHJldilcbiAgcmV0dXJuIHNlbGYuX3ByZXZcbn1cblxuZXhwb3J0cy5lbmNyeXB0ID0gZnVuY3Rpb24gKHNlbGYsIGNodW5rKSB7XG4gIHdoaWxlIChzZWxmLl9jYWNoZS5sZW5ndGggPCBjaHVuay5sZW5ndGgpIHtcbiAgICBzZWxmLl9jYWNoZSA9IEJ1ZmZlci5jb25jYXQoW3NlbGYuX2NhY2hlLCBnZXRCbG9jayhzZWxmKV0pXG4gIH1cblxuICB2YXIgcGFkID0gc2VsZi5fY2FjaGUuc2xpY2UoMCwgY2h1bmsubGVuZ3RoKVxuICBzZWxmLl9jYWNoZSA9IHNlbGYuX2NhY2hlLnNsaWNlKGNodW5rLmxlbmd0aClcbiAgcmV0dXJuIHhvcihjaHVuaywgcGFkKVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB4b3IgKGEsIGIpIHtcbiAgdmFyIGxlbmd0aCA9IE1hdGgubWluKGEubGVuZ3RoLCBiLmxlbmd0aClcbiAgdmFyIGJ1ZmZlciA9IG5ldyBCdWZmZXIobGVuZ3RoKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBidWZmZXJbaV0gPSBhW2ldIF4gYltpXVxuICB9XG5cbiAgcmV0dXJuIGJ1ZmZlclxufVxuIiwidmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJ3N0cmVhbScpLlRyYW5zZm9ybVxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2RlcicpLlN0cmluZ0RlY29kZXJcbm1vZHVsZS5leHBvcnRzID0gQ2lwaGVyQmFzZVxuaW5oZXJpdHMoQ2lwaGVyQmFzZSwgVHJhbnNmb3JtKVxuZnVuY3Rpb24gQ2lwaGVyQmFzZSAoaGFzaE1vZGUpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcylcbiAgdGhpcy5oYXNoTW9kZSA9IHR5cGVvZiBoYXNoTW9kZSA9PT0gJ3N0cmluZydcbiAgaWYgKHRoaXMuaGFzaE1vZGUpIHtcbiAgICB0aGlzW2hhc2hNb2RlXSA9IHRoaXMuX2ZpbmFsT3JEaWdlc3RcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmZpbmFsID0gdGhpcy5fZmluYWxPckRpZ2VzdFxuICB9XG4gIHRoaXMuX2RlY29kZXIgPSBudWxsXG4gIHRoaXMuX2VuY29kaW5nID0gbnVsbFxufVxuQ2lwaGVyQmFzZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRhdGEsIGlucHV0RW5jLCBvdXRwdXRFbmMpIHtcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgIGRhdGEgPSBuZXcgQnVmZmVyKGRhdGEsIGlucHV0RW5jKVxuICB9XG4gIHZhciBvdXREYXRhID0gdGhpcy5fdXBkYXRlKGRhdGEpXG4gIGlmICh0aGlzLmhhc2hNb2RlKSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuICBpZiAob3V0cHV0RW5jKSB7XG4gICAgb3V0RGF0YSA9IHRoaXMuX3RvU3RyaW5nKG91dERhdGEsIG91dHB1dEVuYylcbiAgfVxuICByZXR1cm4gb3V0RGF0YVxufVxuXG5DaXBoZXJCYXNlLnByb3RvdHlwZS5zZXRBdXRvUGFkZGluZyA9IGZ1bmN0aW9uICgpIHt9XG5cbkNpcGhlckJhc2UucHJvdG90eXBlLmdldEF1dGhUYWcgPSBmdW5jdGlvbiAoKSB7XG4gIHRocm93IG5ldyBFcnJvcigndHJ5aW5nIHRvIGdldCBhdXRoIHRhZyBpbiB1bnN1cHBvcnRlZCBzdGF0ZScpXG59XG5cbkNpcGhlckJhc2UucHJvdG90eXBlLnNldEF1dGhUYWcgPSBmdW5jdGlvbiAoKSB7XG4gIHRocm93IG5ldyBFcnJvcigndHJ5aW5nIHRvIHNldCBhdXRoIHRhZyBpbiB1bnN1cHBvcnRlZCBzdGF0ZScpXG59XG5cbkNpcGhlckJhc2UucHJvdG90eXBlLnNldEFBRCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCd0cnlpbmcgdG8gc2V0IGFhZCBpbiB1bnN1cHBvcnRlZCBzdGF0ZScpXG59XG5cbkNpcGhlckJhc2UucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoZGF0YSwgXywgbmV4dCkge1xuICB2YXIgZXJyXG4gIHRyeSB7XG4gICAgaWYgKHRoaXMuaGFzaE1vZGUpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZShkYXRhKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnB1c2godGhpcy5fdXBkYXRlKGRhdGEpKVxuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIGVyciA9IGVcbiAgfSBmaW5hbGx5IHtcbiAgICBuZXh0KGVycilcbiAgfVxufVxuQ2lwaGVyQmFzZS5wcm90b3R5cGUuX2ZsdXNoID0gZnVuY3Rpb24gKGRvbmUpIHtcbiAgdmFyIGVyclxuICB0cnkge1xuICAgIHRoaXMucHVzaCh0aGlzLl9maW5hbCgpKVxuICB9IGNhdGNoIChlKSB7XG4gICAgZXJyID0gZVxuICB9IGZpbmFsbHkge1xuICAgIGRvbmUoZXJyKVxuICB9XG59XG5DaXBoZXJCYXNlLnByb3RvdHlwZS5fZmluYWxPckRpZ2VzdCA9IGZ1bmN0aW9uIChvdXRwdXRFbmMpIHtcbiAgdmFyIG91dERhdGEgPSB0aGlzLl9maW5hbCgpIHx8IG5ldyBCdWZmZXIoJycpXG4gIGlmIChvdXRwdXRFbmMpIHtcbiAgICBvdXREYXRhID0gdGhpcy5fdG9TdHJpbmcob3V0RGF0YSwgb3V0cHV0RW5jLCB0cnVlKVxuICB9XG4gIHJldHVybiBvdXREYXRhXG59XG5cbkNpcGhlckJhc2UucHJvdG90eXBlLl90b1N0cmluZyA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jLCBmaW5hbCkge1xuICBpZiAoIXRoaXMuX2RlY29kZXIpIHtcbiAgICB0aGlzLl9kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoZW5jKVxuICAgIHRoaXMuX2VuY29kaW5nID0gZW5jXG4gIH1cbiAgaWYgKHRoaXMuX2VuY29kaW5nICE9PSBlbmMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NhblxcJ3Qgc3dpdGNoIGVuY29kaW5ncycpXG4gIH1cbiAgdmFyIG91dCA9IHRoaXMuX2RlY29kZXIud3JpdGUodmFsdWUpXG4gIGlmIChmaW5hbCkge1xuICAgIG91dCArPSB0aGlzLl9kZWNvZGVyLmVuZCgpXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuIiwidmFyIGFlcyA9IHJlcXVpcmUoJy4vYWVzJylcbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCdjaXBoZXItYmFzZScpXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG5cbmluaGVyaXRzKFN0cmVhbUNpcGhlciwgVHJhbnNmb3JtKVxubW9kdWxlLmV4cG9ydHMgPSBTdHJlYW1DaXBoZXJcbmZ1bmN0aW9uIFN0cmVhbUNpcGhlciAobW9kZSwga2V5LCBpdiwgZGVjcnlwdCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU3RyZWFtQ2lwaGVyKSkge1xuICAgIHJldHVybiBuZXcgU3RyZWFtQ2lwaGVyKG1vZGUsIGtleSwgaXYpXG4gIH1cbiAgVHJhbnNmb3JtLmNhbGwodGhpcylcbiAgdGhpcy5fY2lwaGVyID0gbmV3IGFlcy5BRVMoa2V5KVxuICB0aGlzLl9wcmV2ID0gbmV3IEJ1ZmZlcihpdi5sZW5ndGgpXG4gIHRoaXMuX2NhY2hlID0gbmV3IEJ1ZmZlcignJylcbiAgdGhpcy5fc2VjQ2FjaGUgPSBuZXcgQnVmZmVyKCcnKVxuICB0aGlzLl9kZWNyeXB0ID0gZGVjcnlwdFxuICBpdi5jb3B5KHRoaXMuX3ByZXYpXG4gIHRoaXMuX21vZGUgPSBtb2RlXG59XG5TdHJlYW1DaXBoZXIucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgcmV0dXJuIHRoaXMuX21vZGUuZW5jcnlwdCh0aGlzLCBjaHVuaywgdGhpcy5fZGVjcnlwdClcbn1cblN0cmVhbUNpcGhlci5wcm90b3R5cGUuX2ZpbmFsID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9jaXBoZXIuc2NydWIoKVxufVxuIiwidmFyIG1kNSA9IHJlcXVpcmUoJ2NyZWF0ZS1oYXNoL21kNScpXG5tb2R1bGUuZXhwb3J0cyA9IEVWUF9CeXRlc1RvS2V5XG5mdW5jdGlvbiBFVlBfQnl0ZXNUb0tleSAocGFzc3dvcmQsIHNhbHQsIGtleUxlbiwgaXZMZW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIocGFzc3dvcmQpKSB7XG4gICAgcGFzc3dvcmQgPSBuZXcgQnVmZmVyKHBhc3N3b3JkLCAnYmluYXJ5JylcbiAgfVxuICBpZiAoc2FsdCAmJiAhQnVmZmVyLmlzQnVmZmVyKHNhbHQpKSB7XG4gICAgc2FsdCA9IG5ldyBCdWZmZXIoc2FsdCwgJ2JpbmFyeScpXG4gIH1cbiAga2V5TGVuID0ga2V5TGVuIC8gOFxuICBpdkxlbiA9IGl2TGVuIHx8IDBcbiAgdmFyIGtpID0gMFxuICB2YXIgaWkgPSAwXG4gIHZhciBrZXkgPSBuZXcgQnVmZmVyKGtleUxlbilcbiAgdmFyIGl2ID0gbmV3IEJ1ZmZlcihpdkxlbilcbiAgdmFyIGFkZG1kID0gMFxuICB2YXIgbWRfYnVmXG4gIHZhciBpXG4gIHZhciBidWZzID0gW11cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAoYWRkbWQrKyA+IDApIHtcbiAgICAgIGJ1ZnMucHVzaChtZF9idWYpXG4gICAgfVxuICAgIGJ1ZnMucHVzaChwYXNzd29yZClcbiAgICBpZiAoc2FsdCkge1xuICAgICAgYnVmcy5wdXNoKHNhbHQpXG4gICAgfVxuICAgIG1kX2J1ZiA9IG1kNShCdWZmZXIuY29uY2F0KGJ1ZnMpKVxuICAgIGJ1ZnMgPSBbXVxuICAgIGkgPSAwXG4gICAgaWYgKGtleUxlbiA+IDApIHtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGlmIChrZXlMZW4gPT09IDApIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGlmIChpID09PSBtZF9idWYubGVuZ3RoKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBrZXlba2krK10gPSBtZF9idWZbaV1cbiAgICAgICAga2V5TGVuLS1cbiAgICAgICAgaSsrXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpdkxlbiA+IDAgJiYgaSAhPT0gbWRfYnVmLmxlbmd0aCkge1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgaWYgKGl2TGVuID09PSAwKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA9PT0gbWRfYnVmLmxlbmd0aCkge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgaXZbaWkrK10gPSBtZF9idWZbaV1cbiAgICAgICAgaXZMZW4tLVxuICAgICAgICBpKytcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGtleUxlbiA9PT0gMCAmJiBpdkxlbiA9PT0gMCkge1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbiAgZm9yIChpID0gMDsgaSA8IG1kX2J1Zi5sZW5ndGg7IGkrKykge1xuICAgIG1kX2J1ZltpXSA9IDBcbiAgfVxuICByZXR1cm4ge1xuICAgIGtleToga2V5LFxuICAgIGl2OiBpdlxuICB9XG59XG4iLCJ2YXIgcGFyc2VLZXlzID0gcmVxdWlyZSgncGFyc2UtYXNuMScpO1xudmFyIG1nZiA9IHJlcXVpcmUoJy4vbWdmJyk7XG52YXIgeG9yID0gcmVxdWlyZSgnLi94b3InKTtcbnZhciBibiA9IHJlcXVpcmUoJ2JuLmpzJyk7XG52YXIgY3J0ID0gcmVxdWlyZSgnYnJvd3NlcmlmeS1yc2EnKTtcbnZhciBjcmVhdGVIYXNoID0gcmVxdWlyZSgnY3JlYXRlLWhhc2gnKTtcbnZhciB3aXRoUHVibGljID0gcmVxdWlyZSgnLi93aXRoUHVibGljJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHByaXZhdGVEZWNyeXB0KHByaXZhdGVfa2V5LCBlbmMsIHJldmVyc2UpIHtcbiAgdmFyIHBhZGRpbmc7XG4gIGlmIChwcml2YXRlX2tleS5wYWRkaW5nKSB7XG4gICAgcGFkZGluZyA9IHByaXZhdGVfa2V5LnBhZGRpbmc7XG4gIH0gZWxzZSBpZiAocmV2ZXJzZSkge1xuICAgIHBhZGRpbmcgPSAxO1xuICB9IGVsc2Uge1xuICAgIHBhZGRpbmcgPSA0O1xuICB9XG4gIFxuICB2YXIga2V5ID0gcGFyc2VLZXlzKHByaXZhdGVfa2V5KTtcbiAgdmFyIGsgPSBrZXkubW9kdWx1cy5ieXRlTGVuZ3RoKCk7XG4gIGlmIChlbmMubGVuZ3RoID4gayB8fCBuZXcgYm4oZW5jKS5jbXAoa2V5Lm1vZHVsdXMpID49IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2RlY3J5cHRpb24gZXJyb3InKTtcbiAgfVxuICB2YXIgbXNnO1xuICBpZiAocmV2ZXJzZSkge1xuICAgIG1zZyA9IHdpdGhQdWJsaWMobmV3IGJuKGVuYyksIGtleSk7XG4gIH0gZWxzZSB7XG4gICAgbXNnID0gY3J0KGVuYywga2V5KTtcbiAgfVxuICB2YXIgekJ1ZmZlciA9IG5ldyBCdWZmZXIoayAtIG1zZy5sZW5ndGgpO1xuICB6QnVmZmVyLmZpbGwoMCk7XG4gIG1zZyA9IEJ1ZmZlci5jb25jYXQoW3pCdWZmZXIsIG1zZ10sIGspO1xuICBpZiAocGFkZGluZyA9PT0gNCkge1xuICAgIHJldHVybiBvYWVwKGtleSwgbXNnKTtcbiAgfSBlbHNlIGlmIChwYWRkaW5nID09PSAxKSB7XG4gICAgcmV0dXJuIHBrY3MxKGtleSwgbXNnLCByZXZlcnNlKTtcbiAgfSBlbHNlIGlmIChwYWRkaW5nID09PSAzKSB7XG4gICAgcmV0dXJuIG1zZztcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gcGFkZGluZycpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBvYWVwKGtleSwgbXNnKXtcbiAgdmFyIG4gPSBrZXkubW9kdWx1cztcbiAgdmFyIGsgPSBrZXkubW9kdWx1cy5ieXRlTGVuZ3RoKCk7XG4gIHZhciBtTGVuID0gbXNnLmxlbmd0aDtcbiAgdmFyIGlIYXNoID0gY3JlYXRlSGFzaCgnc2hhMScpLnVwZGF0ZShuZXcgQnVmZmVyKCcnKSkuZGlnZXN0KCk7XG4gIHZhciBoTGVuID0gaUhhc2gubGVuZ3RoO1xuICB2YXIgaExlbjIgPSAyICogaExlbjtcbiAgaWYgKG1zZ1swXSAhPT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignZGVjcnlwdGlvbiBlcnJvcicpO1xuICB9XG4gIHZhciBtYXNrZWRTZWVkID0gbXNnLnNsaWNlKDEsIGhMZW4gKyAxKTtcbiAgdmFyIG1hc2tlZERiID0gIG1zZy5zbGljZShoTGVuICsgMSk7XG4gIHZhciBzZWVkID0geG9yKG1hc2tlZFNlZWQsIG1nZihtYXNrZWREYiwgaExlbikpO1xuICB2YXIgZGIgPSB4b3IobWFza2VkRGIsIG1nZihzZWVkLCBrIC0gaExlbiAtIDEpKTtcbiAgaWYgKGNvbXBhcmUoaUhhc2gsIGRiLnNsaWNlKDAsIGhMZW4pKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignZGVjcnlwdGlvbiBlcnJvcicpO1xuICB9XG4gIHZhciBpID0gaExlbjtcbiAgd2hpbGUgKGRiW2ldID09PSAwKSB7XG4gICAgaSsrO1xuICB9XG4gIGlmIChkYltpKytdICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdkZWNyeXB0aW9uIGVycm9yJyk7XG4gIH1cbiAgcmV0dXJuIGRiLnNsaWNlKGkpO1xufVxuXG5mdW5jdGlvbiBwa2NzMShrZXksIG1zZywgcmV2ZXJzZSl7XG4gIHZhciBwMSA9IG1zZy5zbGljZSgwLCAyKTtcbiAgdmFyIGkgPSAyO1xuICB2YXIgc3RhdHVzID0gMDtcbiAgd2hpbGUgKG1zZ1tpKytdICE9PSAwKSB7XG4gICAgaWYgKGkgPj0gbXNnLmxlbmd0aCkge1xuICAgICAgc3RhdHVzKys7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgdmFyIHBzID0gbXNnLnNsaWNlKDIsIGkgLSAxKTtcbiAgdmFyIHAyID0gbXNnLnNsaWNlKGkgLSAxLCBpKTtcblxuICBpZiAoKHAxLnRvU3RyaW5nKCdoZXgnKSAhPT0gJzAwMDInICYmICFyZXZlcnNlKSB8fCAocDEudG9TdHJpbmcoJ2hleCcpICE9PSAnMDAwMScgJiYgcmV2ZXJzZSkpe1xuICAgIHN0YXR1cysrO1xuICB9XG4gIGlmIChwcy5sZW5ndGggPCA4KSB7XG4gICAgc3RhdHVzKys7XG4gIH1cbiAgaWYgKHN0YXR1cykge1xuICAgIHRocm93IG5ldyBFcnJvcignZGVjcnlwdGlvbiBlcnJvcicpO1xuICB9XG4gIHJldHVybiAgbXNnLnNsaWNlKGkpO1xufVxuZnVuY3Rpb24gY29tcGFyZShhLCBiKXtcbiAgYSA9IG5ldyBCdWZmZXIoYSk7XG4gIGIgPSBuZXcgQnVmZmVyKGIpO1xuICB2YXIgZGlmID0gMDtcbiAgdmFyIGxlbiA9IGEubGVuZ3RoO1xuICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgZGlmKys7XG4gICAgbGVuID0gTWF0aC5taW4oYS5sZW5ndGgsIGIubGVuZ3RoKTtcbiAgfVxuICB2YXIgaSA9IC0xO1xuICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgZGlmICs9IChhW2ldIF4gYltpXSk7XG4gIH1cbiAgcmV0dXJuIGRpZjtcbn0iLCJ2YXIgcGFyc2VLZXlzID0gcmVxdWlyZSgncGFyc2UtYXNuMScpO1xudmFyIHJhbmRvbUJ5dGVzID0gcmVxdWlyZSgncmFuZG9tYnl0ZXMnKTtcbnZhciBjcmVhdGVIYXNoID0gcmVxdWlyZSgnY3JlYXRlLWhhc2gnKTtcbnZhciBtZ2YgPSByZXF1aXJlKCcuL21nZicpO1xudmFyIHhvciA9IHJlcXVpcmUoJy4veG9yJyk7XG52YXIgYm4gPSByZXF1aXJlKCdibi5qcycpO1xudmFyIHdpdGhQdWJsaWMgPSByZXF1aXJlKCcuL3dpdGhQdWJsaWMnKTtcbnZhciBjcnQgPSByZXF1aXJlKCdicm93c2VyaWZ5LXJzYScpO1xuXG52YXIgY29uc3RhbnRzID0ge1xuICBSU0FfUEtDUzFfT0FFUF9QQURESU5HOiA0LFxuICBSU0FfUEtDUzFfUEFERElOOiAxLFxuICBSU0FfTk9fUEFERElORzogM1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwdWJsaWNFbmNyeXB0KHB1YmxpY19rZXksIG1zZywgcmV2ZXJzZSkge1xuICB2YXIgcGFkZGluZztcbiAgaWYgKHB1YmxpY19rZXkucGFkZGluZykge1xuICAgIHBhZGRpbmcgPSBwdWJsaWNfa2V5LnBhZGRpbmc7XG4gIH0gZWxzZSBpZiAocmV2ZXJzZSkge1xuICAgIHBhZGRpbmcgPSAxO1xuICB9IGVsc2Uge1xuICAgIHBhZGRpbmcgPSA0O1xuICB9XG4gIHZhciBrZXkgPSBwYXJzZUtleXMocHVibGljX2tleSk7XG4gIHZhciBwYWRkZWRNc2c7XG4gIGlmIChwYWRkaW5nID09PSA0KSB7XG4gICAgcGFkZGVkTXNnID0gb2FlcChrZXksIG1zZyk7XG4gIH0gZWxzZSBpZiAocGFkZGluZyA9PT0gMSkge1xuICAgIHBhZGRlZE1zZyA9IHBrY3MxKGtleSwgbXNnLCByZXZlcnNlKTtcbiAgfSBlbHNlIGlmIChwYWRkaW5nID09PSAzKSB7XG4gICAgcGFkZGVkTXNnID0gbmV3IGJuKG1zZyk7XG4gICAgaWYgKHBhZGRlZE1zZy5jbXAoa2V5Lm1vZHVsdXMpID49IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZGF0YSB0b28gbG9uZyBmb3IgbW9kdWx1cycpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gcGFkZGluZycpO1xuICB9XG4gIGlmIChyZXZlcnNlKSB7XG4gICAgcmV0dXJuIGNydChwYWRkZWRNc2csIGtleSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHdpdGhQdWJsaWMocGFkZGVkTXNnLCBrZXkpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBvYWVwKGtleSwgbXNnKXtcbiAgdmFyIGsgPSBrZXkubW9kdWx1cy5ieXRlTGVuZ3RoKCk7XG4gIHZhciBtTGVuID0gbXNnLmxlbmd0aDtcbiAgdmFyIGlIYXNoID0gY3JlYXRlSGFzaCgnc2hhMScpLnVwZGF0ZShuZXcgQnVmZmVyKCcnKSkuZGlnZXN0KCk7XG4gIHZhciBoTGVuID0gaUhhc2gubGVuZ3RoO1xuICB2YXIgaExlbjIgPSAyICogaExlbjtcbiAgaWYgKG1MZW4gPiBrIC0gaExlbjIgLSAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtZXNzYWdlIHRvbyBsb25nJyk7XG4gIH1cbiAgdmFyIHBzID0gbmV3IEJ1ZmZlcihrIC0gbUxlbiAtIGhMZW4yIC0gMik7XG4gIHBzLmZpbGwoMCk7XG4gIHZhciBkYmxlbiA9IGsgLSBoTGVuIC0gMTtcbiAgdmFyIHNlZWQgPSByYW5kb21CeXRlcyhoTGVuKTtcbiAgdmFyIG1hc2tlZERiID0geG9yKEJ1ZmZlci5jb25jYXQoW2lIYXNoLCBwcywgbmV3IEJ1ZmZlcihbMV0pLCBtc2ddLCBkYmxlbiksIG1nZihzZWVkLCBkYmxlbikpO1xuICB2YXIgbWFza2VkU2VlZCA9IHhvcihzZWVkLCBtZ2YobWFza2VkRGIsIGhMZW4pKTtcbiAgcmV0dXJuIG5ldyBibihCdWZmZXIuY29uY2F0KFtuZXcgQnVmZmVyKFswXSksIG1hc2tlZFNlZWQsIG1hc2tlZERiXSwgaykpO1xufVxuZnVuY3Rpb24gcGtjczEoa2V5LCBtc2csIHJldmVyc2Upe1xuICB2YXIgbUxlbiA9IG1zZy5sZW5ndGg7XG4gIHZhciBrID0ga2V5Lm1vZHVsdXMuYnl0ZUxlbmd0aCgpO1xuICBpZiAobUxlbiA+IGsgLSAxMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignbWVzc2FnZSB0b28gbG9uZycpO1xuICB9XG4gIHZhciBwcztcbiAgaWYgKHJldmVyc2UpIHtcbiAgICBwcyA9IG5ldyBCdWZmZXIoayAtIG1MZW4gLSAzKTtcbiAgICBwcy5maWxsKDB4ZmYpO1xuICB9IGVsc2Uge1xuICAgIHBzID0gbm9uWmVybyhrIC0gbUxlbiAtIDMpO1xuICB9XG4gIHJldHVybiBuZXcgYm4oQnVmZmVyLmNvbmNhdChbbmV3IEJ1ZmZlcihbMCwgcmV2ZXJzZT8xOjJdKSwgcHMsIG5ldyBCdWZmZXIoWzBdKSwgbXNnXSwgaykpO1xufVxuZnVuY3Rpb24gbm9uWmVybyhsZW4sIGNyeXB0bykge1xuICB2YXIgb3V0ID0gbmV3IEJ1ZmZlcihsZW4pO1xuICB2YXIgaSA9IDA7XG4gIHZhciBjYWNoZSA9IHJhbmRvbUJ5dGVzKGxlbioyKTtcbiAgdmFyIGN1ciA9IDA7XG4gIHZhciBudW07XG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgaWYgKGN1ciA9PT0gY2FjaGUubGVuZ3RoKSB7XG4gICAgICBjYWNoZSA9IHJhbmRvbUJ5dGVzKGxlbioyKTtcbiAgICAgIGN1ciA9IDA7XG4gICAgfVxuICAgIG51bSA9IGNhY2hlW2N1cisrXTtcbiAgICBpZiAobnVtKSB7XG4gICAgICBvdXRbaSsrXSA9IG51bTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dDtcbn0iLCJ2YXIgYm4gPSByZXF1aXJlKCdibi5qcycpO1xuZnVuY3Rpb24gd2l0aFB1YmxpYyhwYWRkZWRNc2csIGtleSkge1xuICByZXR1cm4gbmV3IEJ1ZmZlcihwYWRkZWRNc2dcbiAgICAudG9SZWQoYm4ubW9udChrZXkubW9kdWx1cykpXG4gICAgLnJlZFBvdyhuZXcgYm4oa2V5LnB1YmxpY0V4cG9uZW50KSlcbiAgICAuZnJvbVJlZCgpXG4gICAgLnRvQXJyYXkoKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gd2l0aFB1YmxpYzsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHhvcihhLCBiKSB7XG4gIHZhciBsZW4gPSBhLmxlbmd0aDtcbiAgdmFyIGkgPSAtMTtcbiAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgIGFbaV0gXj0gYltpXTtcbiAgfVxuICByZXR1cm4gYVxufTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBjcnlwdG8gPSBnbG9iYWwuY3J5cHRvIHx8IGdsb2JhbC5tc0NyeXB0b1xuaWYoY3J5cHRvICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByYW5kb21CeXRlcztcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gb2xkQnJvd3Nlcjtcbn1cbmZ1bmN0aW9uIHJhbmRvbUJ5dGVzKHNpemUsIGNiKSB7XG4gIHZhciBieXRlcyA9IG5ldyBCdWZmZXIoc2l6ZSk7IC8vaW4gYnJvd3NlcmlmeSwgdGhpcyBpcyBhbiBleHRlbmRlZCBVaW50OEFycmF5XG4gICAgLyogVGhpcyB3aWxsIG5vdCB3b3JrIGluIG9sZGVyIGJyb3dzZXJzLlxuICAgICAqIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvd2luZG93LmNyeXB0by5nZXRSYW5kb21WYWx1ZXNcbiAgICAgKi9cblxuICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGJ5dGVzKTtcbiAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNiKG51bGwsIGJ5dGVzKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gYnl0ZXM7XG59XG5mdW5jdGlvbiBvbGRCcm93c2VyKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnc2VjdXJlIHJhbmRvbSBudW1iZXIgZ2VuZXJhdGlvbiBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgYnJvd3NlclxcbicrXG4gICAgICAndXNlIGNocm9tZSwgRmlyZUZveCBvciBJbnRlcm5ldCBFeHBsb3JlciAxMSdcbiAgICApXG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbkV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uKG4pIHtcbiAgaWYgKCFpc051bWJlcihuKSB8fCBuIDwgMCB8fCBpc05hTihuKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ24gbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGVyLCBoYW5kbGVyLCBsZW4sIGFyZ3MsIGksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmICh0eXBlID09PSAnZXJyb3InKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHMuZXJyb3IgfHxcbiAgICAgICAgKGlzT2JqZWN0KHRoaXMuX2V2ZW50cy5lcnJvcikgJiYgIXRoaXMuX2V2ZW50cy5lcnJvci5sZW5ndGgpKSB7XG4gICAgICBlciA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgICAgfVxuICAgICAgdGhyb3cgVHlwZUVycm9yKCdVbmNhdWdodCwgdW5zcGVjaWZpZWQgXCJlcnJvclwiIGV2ZW50LicpO1xuICAgIH1cbiAgfVxuXG4gIGhhbmRsZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzVW5kZWZpbmVkKGhhbmRsZXIpKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgLy8gZmFzdCBjYXNlc1xuICAgICAgY2FzZSAxOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gc2xvd2VyXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbGVuOyBpKyspXG4gICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIGhhbmRsZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGhhbmRsZXIpKSB7XG4gICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xuICAgIGZvciAoaSA9IDE7IGkgPCBsZW47IGkrKylcbiAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuXG4gICAgbGlzdGVuZXJzID0gaGFuZGxlci5zbGljZSgpO1xuICAgIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIG07XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgaWYgKHRoaXMuX2V2ZW50cy5uZXdMaXN0ZW5lcilcbiAgICB0aGlzLmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgaXNGdW5jdGlvbihsaXN0ZW5lci5saXN0ZW5lcikgP1xuICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgZWxzZSBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuICBlbHNlXG4gICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gW3RoaXMuX2V2ZW50c1t0eXBlXSwgbGlzdGVuZXJdO1xuXG4gIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pICYmICF0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkKSB7XG4gICAgdmFyIG07XG4gICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLl9tYXhMaXN0ZW5lcnMpKSB7XG4gICAgICBtID0gdGhpcy5fbWF4TGlzdGVuZXJzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gICAgfVxuXG4gICAgaWYgKG0gJiYgbSA+IDAgJiYgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCA+IG0pIHtcbiAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQgPSB0cnVlO1xuICAgICAgY29uc29sZS5lcnJvcignKG5vZGUpIHdhcm5pbmc6IHBvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgJyArXG4gICAgICAgICAgICAgICAgICAgICdsZWFrIGRldGVjdGVkLiAlZCBsaXN0ZW5lcnMgYWRkZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAnVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gaW5jcmVhc2UgbGltaXQuJyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCk7XG4gICAgICBpZiAodHlwZW9mIGNvbnNvbGUudHJhY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gbm90IHN1cHBvcnRlZCBpbiBJRSAxMFxuICAgICAgICBjb25zb2xlLnRyYWNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIHZhciBmaXJlZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGcoKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBnKTtcblxuICAgIGlmICghZmlyZWQpIHtcbiAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG5cbiAgZy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICB0aGlzLm9uKHR5cGUsIGcpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWRcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbGlzdCwgcG9zaXRpb24sIGxlbmd0aCwgaTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXR1cm4gdGhpcztcblxuICBsaXN0ID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuICBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgcG9zaXRpb24gPSAtMTtcblxuICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHxcbiAgICAgIChpc0Z1bmN0aW9uKGxpc3QubGlzdGVuZXIpICYmIGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG5cbiAgfSBlbHNlIGlmIChpc09iamVjdChsaXN0KSkge1xuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tID4gMDspIHtcbiAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fFxuICAgICAgICAgIChsaXN0W2ldLmxpc3RlbmVyICYmIGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgbGlzdC5sZW5ndGggPSAwO1xuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGlzdC5zcGxpY2UocG9zaXRpb24sIDEpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGtleSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgaWYgKCF0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIGVsc2UgaWYgKHRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBmb3IgKGtleSBpbiB0aGlzLl9ldmVudHMpIHtcbiAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICB9XG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzRnVuY3Rpb24obGlzdGVuZXJzKSkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBMSUZPIG9yZGVyXG4gICAgd2hpbGUgKGxpc3RlbmVycy5sZW5ndGgpXG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tsaXN0ZW5lcnMubGVuZ3RoIC0gMV0pO1xuICB9XG4gIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIHJldDtcbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXQgPSBbXTtcbiAgZWxzZSBpZiAoaXNGdW5jdGlvbih0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIHJldCA9IFt0aGlzLl9ldmVudHNbdHlwZV1dO1xuICBlbHNlXG4gICAgcmV0ID0gdGhpcy5fZXZlbnRzW3R5cGVdLnNsaWNlKCk7XG4gIHJldHVybiByZXQ7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgdmFyIHJldDtcbiAgaWYgKCFlbWl0dGVyLl9ldmVudHMgfHwgIWVtaXR0ZXIuX2V2ZW50c1t0eXBlXSlcbiAgICByZXQgPSAwO1xuICBlbHNlIGlmIChpc0Z1bmN0aW9uKGVtaXR0ZXIuX2V2ZW50c1t0eXBlXSkpXG4gICAgcmV0ID0gMTtcbiAgZWxzZVxuICAgIHJldCA9IGVtaXR0ZXIuX2V2ZW50c1t0eXBlXS5sZW5ndGg7XG4gIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG4iLCJpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gIH1cbn1cbiIsIi8qKlxuICogRGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBpcyBCdWZmZXJcbiAqXG4gKiBBdXRob3I6ICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIExpY2Vuc2U6ICBNSVRcbiAqXG4gKiBgbnBtIGluc3RhbGwgaXMtYnVmZmVyYFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gISEob2JqICE9IG51bGwgJiZcbiAgICAob2JqLl9pc0J1ZmZlciB8fCAvLyBGb3IgU2FmYXJpIDUtNyAobWlzc2luZyBPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yKVxuICAgICAgKG9iai5jb25zdHJ1Y3RvciAmJlxuICAgICAgdHlwZW9mIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyKG9iaikpXG4gICAgKSlcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBzZXRUaW1lb3V0KGRyYWluUXVldWUsIDApO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9saWIvX3N0cmVhbV9kdXBsZXguanNcIilcbiIsIi8vIGEgZHVwbGV4IHN0cmVhbSBpcyBqdXN0IGEgc3RyZWFtIHRoYXQgaXMgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUuXG4vLyBTaW5jZSBKUyBkb2Vzbid0IGhhdmUgbXVsdGlwbGUgcHJvdG90eXBhbCBpbmhlcml0YW5jZSwgdGhpcyBjbGFzc1xuLy8gcHJvdG90eXBhbGx5IGluaGVyaXRzIGZyb20gUmVhZGFibGUsIGFuZCB0aGVuIHBhcmFzaXRpY2FsbHkgZnJvbVxuLy8gV3JpdGFibGUuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSBrZXlzLnB1c2goa2V5KTtcbiAgcmV0dXJuIGtleXM7XG59XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuXG5tb2R1bGUuZXhwb3J0cyA9IER1cGxleDtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBwcm9jZXNzTmV4dFRpY2sgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblxuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBSZWFkYWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV9yZWFkYWJsZScpO1xudmFyIFdyaXRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3dyaXRhYmxlJyk7XG5cbnV0aWwuaW5oZXJpdHMoRHVwbGV4LCBSZWFkYWJsZSk7XG5cbnZhciBrZXlzID0gb2JqZWN0S2V5cyhXcml0YWJsZS5wcm90b3R5cGUpO1xuZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XG4gIHZhciBtZXRob2QgPSBrZXlzW3ZdO1xuICBpZiAoIUR1cGxleC5wcm90b3R5cGVbbWV0aG9kXSlcbiAgICBEdXBsZXgucHJvdG90eXBlW21ldGhvZF0gPSBXcml0YWJsZS5wcm90b3R5cGVbbWV0aG9kXTtcbn1cblxuZnVuY3Rpb24gRHVwbGV4KG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpXG4gICAgcmV0dXJuIG5ldyBEdXBsZXgob3B0aW9ucyk7XG5cbiAgUmVhZGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgV3JpdGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlYWRhYmxlID09PSBmYWxzZSlcbiAgICB0aGlzLnJlYWRhYmxlID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy53cml0YWJsZSA9PT0gZmFsc2UpXG4gICAgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuXG4gIHRoaXMuYWxsb3dIYWxmT3BlbiA9IHRydWU7XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuYWxsb3dIYWxmT3BlbiA9PT0gZmFsc2UpXG4gICAgdGhpcy5hbGxvd0hhbGZPcGVuID0gZmFsc2U7XG5cbiAgdGhpcy5vbmNlKCdlbmQnLCBvbmVuZCk7XG59XG5cbi8vIHRoZSBuby1oYWxmLW9wZW4gZW5mb3JjZXJcbmZ1bmN0aW9uIG9uZW5kKCkge1xuICAvLyBpZiB3ZSBhbGxvdyBoYWxmLW9wZW4gc3RhdGUsIG9yIGlmIHRoZSB3cml0YWJsZSBzaWRlIGVuZGVkLFxuICAvLyB0aGVuIHdlJ3JlIG9rLlxuICBpZiAodGhpcy5hbGxvd0hhbGZPcGVuIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQpXG4gICAgcmV0dXJuO1xuXG4gIC8vIG5vIG1vcmUgZGF0YSBjYW4gYmUgd3JpdHRlbi5cbiAgLy8gQnV0IGFsbG93IG1vcmUgd3JpdGVzIHRvIGhhcHBlbiBpbiB0aGlzIHRpY2suXG4gIHByb2Nlc3NOZXh0VGljayhvbkVuZE5ULCB0aGlzKTtcbn1cblxuZnVuY3Rpb24gb25FbmROVChzZWxmKSB7XG4gIHNlbGYuZW5kKCk7XG59XG5cbmZ1bmN0aW9uIGZvckVhY2ggKHhzLCBmKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZih4c1tpXSwgaSk7XG4gIH1cbn1cbiIsIi8vIGEgcGFzc3Rocm91Z2ggc3RyZWFtLlxuLy8gYmFzaWNhbGx5IGp1c3QgdGhlIG1vc3QgbWluaW1hbCBzb3J0IG9mIFRyYW5zZm9ybSBzdHJlYW0uXG4vLyBFdmVyeSB3cml0dGVuIGNodW5rIGdldHMgb3V0cHV0IGFzLWlzLlxuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUGFzc1Rocm91Z2g7XG5cbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL19zdHJlYW1fdHJhbnNmb3JtJyk7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudXRpbC5pbmhlcml0cyhQYXNzVGhyb3VnaCwgVHJhbnNmb3JtKTtcblxuZnVuY3Rpb24gUGFzc1Rocm91Z2gob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUGFzc1Rocm91Z2gpKVxuICAgIHJldHVybiBuZXcgUGFzc1Rocm91Z2gob3B0aW9ucyk7XG5cbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0aW9ucyk7XG59XG5cblBhc3NUaHJvdWdoLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihudWxsLCBjaHVuayk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWRhYmxlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHByb2Nlc3NOZXh0VGljayA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5SZWFkYWJsZS5SZWFkYWJsZVN0YXRlID0gUmVhZGFibGVTdGF0ZTtcblxudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJyk7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRUVsaXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lcnModHlwZSkubGVuZ3RoO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBTdHJlYW07XG4oZnVuY3Rpb24gKCl7dHJ5e1xuICBTdHJlYW0gPSByZXF1aXJlKCdzdCcgKyAncmVhbScpO1xufWNhdGNoKF8pe31maW5hbGx5e1xuICBpZiAoIVN0cmVhbSlcbiAgICBTdHJlYW0gPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG59fSgpKVxuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgZGVidWdVdGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIGRlYnVnO1xuaWYgKGRlYnVnVXRpbCAmJiBkZWJ1Z1V0aWwuZGVidWdsb2cpIHtcbiAgZGVidWcgPSBkZWJ1Z1V0aWwuZGVidWdsb2coJ3N0cmVhbScpO1xufSBlbHNlIHtcbiAgZGVidWcgPSBmdW5jdGlvbiAoKSB7fTtcbn1cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgU3RyaW5nRGVjb2RlcjtcblxudXRpbC5pbmhlcml0cyhSZWFkYWJsZSwgU3RyZWFtKTtcblxudmFyIER1cGxleDtcbmZ1bmN0aW9uIFJlYWRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnLiBVc2VkIHRvIG1ha2UgcmVhZChuKSBpZ25vcmUgbiBhbmQgdG9cbiAgLy8gbWFrZSBhbGwgdGhlIGJ1ZmZlciBtZXJnaW5nIGFuZCBsZW5ndGggY2hlY2tzIGdvIGF3YXlcbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG5cbiAgaWYgKHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleClcbiAgICB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLnJlYWRhYmxlT2JqZWN0TW9kZTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggaXQgc3RvcHMgY2FsbGluZyBfcmVhZCgpIHRvIGZpbGwgdGhlIGJ1ZmZlclxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIFwiZG9uJ3QgY2FsbCBfcmVhZCBwcmVlbXB0aXZlbHkgZXZlclwiXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIHZhciBkZWZhdWx0SHdtID0gdGhpcy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IChod20gfHwgaHdtID09PSAwKSA/IGh3bSA6IGRlZmF1bHRId207XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSB+fnRoaXMuaGlnaFdhdGVyTWFyaztcblxuICB0aGlzLmJ1ZmZlciA9IFtdO1xuICB0aGlzLmxlbmd0aCA9IDA7XG4gIHRoaXMucGlwZXMgPSBudWxsO1xuICB0aGlzLnBpcGVzQ291bnQgPSAwO1xuICB0aGlzLmZsb3dpbmcgPSBudWxsO1xuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIHRoaXMuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB0aGlzLnJlYWRpbmcgPSBmYWxzZTtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSxcbiAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZSBhbnlcbiAgLy8gYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3Qgd3JpdGUgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyB3aGVuZXZlciB3ZSByZXR1cm4gbnVsbCwgdGhlbiB3ZSBzZXQgYSBmbGFnIHRvIHNheVxuICAvLyB0aGF0IHdlJ3JlIGF3YWl0aW5nIGEgJ3JlYWRhYmxlJyBldmVudCBlbWlzc2lvbi5cbiAgdGhpcy5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5yZWFkYWJsZUxpc3RlbmluZyA9IGZhbHNlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIHdoZW4gcGlwaW5nLCB3ZSBvbmx5IGNhcmUgYWJvdXQgJ3JlYWRhYmxlJyBldmVudHMgdGhhdCBoYXBwZW5cbiAgLy8gYWZ0ZXIgcmVhZCgpaW5nIGFsbCB0aGUgYnl0ZXMgYW5kIG5vdCBnZXR0aW5nIGFueSBwdXNoYmFjay5cbiAgdGhpcy5yYW5PdXQgPSBmYWxzZTtcblxuICAvLyB0aGUgbnVtYmVyIG9mIHdyaXRlcnMgdGhhdCBhcmUgYXdhaXRpbmcgYSBkcmFpbiBldmVudCBpbiAucGlwZSgpc1xuICB0aGlzLmF3YWl0RHJhaW4gPSAwO1xuXG4gIC8vIGlmIHRydWUsIGEgbWF5YmVSZWFkTW9yZSBoYXMgYmVlbiBzY2hlZHVsZWRcbiAgdGhpcy5yZWFkaW5nTW9yZSA9IGZhbHNlO1xuXG4gIHRoaXMuZGVjb2RlciA9IG51bGw7XG4gIHRoaXMuZW5jb2RpbmcgPSBudWxsO1xuICBpZiAob3B0aW9ucy5lbmNvZGluZykge1xuICAgIGlmICghU3RyaW5nRGVjb2RlcilcbiAgICAgIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICAgIHRoaXMuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKG9wdGlvbnMuZW5jb2RpbmcpO1xuICAgIHRoaXMuZW5jb2RpbmcgPSBvcHRpb25zLmVuY29kaW5nO1xuICB9XG59XG5cbnZhciBEdXBsZXg7XG5mdW5jdGlvbiBSZWFkYWJsZShvcHRpb25zKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRhYmxlKSlcbiAgICByZXR1cm4gbmV3IFJlYWRhYmxlKG9wdGlvbnMpO1xuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUgPSBuZXcgUmVhZGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyBsZWdhY3lcbiAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMucmVhZCA9PT0gJ2Z1bmN0aW9uJylcbiAgICB0aGlzLl9yZWFkID0gb3B0aW9ucy5yZWFkO1xuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG4vLyBNYW51YWxseSBzaG92ZSBzb21ldGhpbmcgaW50byB0aGUgcmVhZCgpIGJ1ZmZlci5cbi8vIFRoaXMgcmV0dXJucyB0cnVlIGlmIHRoZSBoaWdoV2F0ZXJNYXJrIGhhcyBub3QgYmVlbiBoaXQgeWV0LFxuLy8gc2ltaWxhciB0byBob3cgV3JpdGFibGUud3JpdGUoKSByZXR1cm5zIHRydWUgaWYgeW91IHNob3VsZFxuLy8gd3JpdGUoKSBzb21lIG1vcmUuXG5SZWFkYWJsZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiB0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG4gICAgaWYgKGVuY29kaW5nICE9PSBzdGF0ZS5lbmNvZGluZykge1xuICAgICAgY2h1bmsgPSBuZXcgQnVmZmVyKGNodW5rLCBlbmNvZGluZyk7XG4gICAgICBlbmNvZGluZyA9ICcnO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGZhbHNlKTtcbn07XG5cbi8vIFVuc2hpZnQgc2hvdWxkICphbHdheXMqIGJlIHNvbWV0aGluZyBkaXJlY3RseSBvdXQgb2YgcmVhZCgpXG5SZWFkYWJsZS5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uKGNodW5rKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgJycsIHRydWUpO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLmlzUGF1c2VkID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPT09IGZhbHNlO1xufTtcblxuZnVuY3Rpb24gcmVhZGFibGVBZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGFkZFRvRnJvbnQpIHtcbiAgdmFyIGVyID0gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuayk7XG4gIGlmIChlcikge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgfSBlbHNlIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpO1xuICB9IGVsc2UgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsgJiYgY2h1bmsubGVuZ3RoID4gMCkge1xuICAgIGlmIChzdGF0ZS5lbmRlZCAmJiAhYWRkVG9Gcm9udCkge1xuICAgICAgdmFyIGUgPSBuZXcgRXJyb3IoJ3N0cmVhbS5wdXNoKCkgYWZ0ZXIgRU9GJyk7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLmVuZEVtaXR0ZWQgJiYgYWRkVG9Gcm9udCkge1xuICAgICAgdmFyIGUgPSBuZXcgRXJyb3IoJ3N0cmVhbS51bnNoaWZ0KCkgYWZ0ZXIgZW5kIGV2ZW50Jyk7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIWFkZFRvRnJvbnQgJiYgIWVuY29kaW5nKVxuICAgICAgICBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuXG4gICAgICBpZiAoIWFkZFRvRnJvbnQpXG4gICAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcblxuICAgICAgLy8gaWYgd2Ugd2FudCB0aGUgZGF0YSBub3csIGp1c3QgZW1pdCBpdC5cbiAgICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiAhc3RhdGUuc3luYykge1xuICAgICAgICBzdHJlYW0uZW1pdCgnZGF0YScsIGNodW5rKTtcbiAgICAgICAgc3RyZWFtLnJlYWQoMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB1cGRhdGUgdGhlIGJ1ZmZlciBpbmZvLlxuICAgICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgICAgIGlmIChhZGRUb0Zyb250KVxuICAgICAgICAgIHN0YXRlLmJ1ZmZlci51bnNoaWZ0KGNodW5rKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcblxuICAgICAgICBpZiAoc3RhdGUubmVlZFJlYWRhYmxlKVxuICAgICAgICAgIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xuICAgICAgfVxuXG4gICAgICBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cbiAgfSBlbHNlIGlmICghYWRkVG9Gcm9udCkge1xuICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBuZWVkTW9yZURhdGEoc3RhdGUpO1xufVxuXG5cbi8vIGlmIGl0J3MgcGFzdCB0aGUgaGlnaCB3YXRlciBtYXJrLCB3ZSBjYW4gcHVzaCBpbiBzb21lIG1vcmUuXG4vLyBBbHNvLCBpZiB3ZSBoYXZlIG5vIGRhdGEgeWV0LCB3ZSBjYW4gc3RhbmQgc29tZVxuLy8gbW9yZSBieXRlcy4gIFRoaXMgaXMgdG8gd29yayBhcm91bmQgY2FzZXMgd2hlcmUgaHdtPTAsXG4vLyBzdWNoIGFzIHRoZSByZXBsLiAgQWxzbywgaWYgdGhlIHB1c2goKSB0cmlnZ2VyZWQgYVxuLy8gcmVhZGFibGUgZXZlbnQsIGFuZCB0aGUgdXNlciBjYWxsZWQgcmVhZChsYXJnZU51bWJlcikgc3VjaCB0aGF0XG4vLyBuZWVkUmVhZGFibGUgd2FzIHNldCwgdGhlbiB3ZSBvdWdodCB0byBwdXNoIG1vcmUsIHNvIHRoYXQgYW5vdGhlclxuLy8gJ3JlYWRhYmxlJyBldmVudCB3aWxsIGJlIHRyaWdnZXJlZC5cbmZ1bmN0aW9uIG5lZWRNb3JlRGF0YShzdGF0ZSkge1xuICByZXR1cm4gIXN0YXRlLmVuZGVkICYmXG4gICAgICAgICAoc3RhdGUubmVlZFJlYWRhYmxlIHx8XG4gICAgICAgICAgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fFxuICAgICAgICAgIHN0YXRlLmxlbmd0aCA9PT0gMCk7XG59XG5cbi8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuUmVhZGFibGUucHJvdG90eXBlLnNldEVuY29kaW5nID0gZnVuY3Rpb24oZW5jKSB7XG4gIGlmICghU3RyaW5nRGVjb2RlcilcbiAgICBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoZW5jKTtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmNvZGluZyA9IGVuYztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBEb24ndCByYWlzZSB0aGUgaHdtID4gOE1CXG52YXIgTUFYX0hXTSA9IDB4ODAwMDAwO1xuZnVuY3Rpb24gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobikge1xuICBpZiAobiA+PSBNQVhfSFdNKSB7XG4gICAgbiA9IE1BWF9IV007XG4gIH0gZWxzZSB7XG4gICAgLy8gR2V0IHRoZSBuZXh0IGhpZ2hlc3QgcG93ZXIgb2YgMlxuICAgIG4tLTtcbiAgICBuIHw9IG4gPj4+IDE7XG4gICAgbiB8PSBuID4+PiAyO1xuICAgIG4gfD0gbiA+Pj4gNDtcbiAgICBuIHw9IG4gPj4+IDg7XG4gICAgbiB8PSBuID4+PiAxNjtcbiAgICBuKys7XG4gIH1cbiAgcmV0dXJuIG47XG59XG5cbmZ1bmN0aW9uIGhvd011Y2hUb1JlYWQobiwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZClcbiAgICByZXR1cm4gMDtcblxuICBpZiAoc3RhdGUub2JqZWN0TW9kZSlcbiAgICByZXR1cm4gbiA9PT0gMCA/IDAgOiAxO1xuXG4gIGlmIChuID09PSBudWxsIHx8IGlzTmFOKG4pKSB7XG4gICAgLy8gb25seSBmbG93IG9uZSBidWZmZXIgYXQgYSB0aW1lXG4gICAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUuYnVmZmVyLmxlbmd0aClcbiAgICAgIHJldHVybiBzdGF0ZS5idWZmZXJbMF0ubGVuZ3RoO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiBzdGF0ZS5sZW5ndGg7XG4gIH1cblxuICBpZiAobiA8PSAwKVxuICAgIHJldHVybiAwO1xuXG4gIC8vIElmIHdlJ3JlIGFza2luZyBmb3IgbW9yZSB0aGFuIHRoZSB0YXJnZXQgYnVmZmVyIGxldmVsLFxuICAvLyB0aGVuIHJhaXNlIHRoZSB3YXRlciBtYXJrLiAgQnVtcCB1cCB0byB0aGUgbmV4dCBoaWdoZXN0XG4gIC8vIHBvd2VyIG9mIDIsIHRvIHByZXZlbnQgaW5jcmVhc2luZyBpdCBleGNlc3NpdmVseSBpbiB0aW55XG4gIC8vIGFtb3VudHMuXG4gIGlmIChuID4gc3RhdGUuaGlnaFdhdGVyTWFyaylcbiAgICBzdGF0ZS5oaWdoV2F0ZXJNYXJrID0gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobik7XG5cbiAgLy8gZG9uJ3QgaGF2ZSB0aGF0IG11Y2guICByZXR1cm4gbnVsbCwgdW5sZXNzIHdlJ3ZlIGVuZGVkLlxuICBpZiAobiA+IHN0YXRlLmxlbmd0aCkge1xuICAgIGlmICghc3RhdGUuZW5kZWQpIHtcbiAgICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbjtcbn1cblxuLy8geW91IGNhbiBvdmVycmlkZSBlaXRoZXIgdGhpcyBtZXRob2QsIG9yIHRoZSBhc3luYyBfcmVhZChuKSBiZWxvdy5cblJlYWRhYmxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24obikge1xuICBkZWJ1ZygncmVhZCcsIG4pO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgbk9yaWcgPSBuO1xuXG4gIGlmICh0eXBlb2YgbiAhPT0gJ251bWJlcicgfHwgbiA+IDApXG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG5cbiAgLy8gaWYgd2UncmUgZG9pbmcgcmVhZCgwKSB0byB0cmlnZ2VyIGEgcmVhZGFibGUgZXZlbnQsIGJ1dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYSBidW5jaCBvZiBkYXRhIGluIHRoZSBidWZmZXIsIHRoZW4ganVzdCB0cmlnZ2VyXG4gIC8vIHRoZSAncmVhZGFibGUnIGV2ZW50IGFuZCBtb3ZlIG9uLlxuICBpZiAobiA9PT0gMCAmJlxuICAgICAgc3RhdGUubmVlZFJlYWRhYmxlICYmXG4gICAgICAoc3RhdGUubGVuZ3RoID49IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUuZW5kZWQpKSB7XG4gICAgZGVidWcoJ3JlYWQ6IGVtaXRSZWFkYWJsZScsIHN0YXRlLmxlbmd0aCwgc3RhdGUuZW5kZWQpO1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpXG4gICAgICBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgICBlbHNlXG4gICAgICBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBuID0gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSk7XG5cbiAgLy8gaWYgd2UndmUgZW5kZWQsIGFuZCB3ZSdyZSBub3cgY2xlYXIsIHRoZW4gZmluaXNoIGl0IHVwLlxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkge1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApXG4gICAgICBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIEFsbCB0aGUgYWN0dWFsIGNodW5rIGdlbmVyYXRpb24gbG9naWMgbmVlZHMgdG8gYmVcbiAgLy8gKmJlbG93KiB0aGUgY2FsbCB0byBfcmVhZC4gIFRoZSByZWFzb24gaXMgdGhhdCBpbiBjZXJ0YWluXG4gIC8vIHN5bnRoZXRpYyBzdHJlYW0gY2FzZXMsIHN1Y2ggYXMgcGFzc3Rocm91Z2ggc3RyZWFtcywgX3JlYWRcbiAgLy8gbWF5IGJlIGEgY29tcGxldGVseSBzeW5jaHJvbm91cyBvcGVyYXRpb24gd2hpY2ggbWF5IGNoYW5nZVxuICAvLyB0aGUgc3RhdGUgb2YgdGhlIHJlYWQgYnVmZmVyLCBwcm92aWRpbmcgZW5vdWdoIGRhdGEgd2hlblxuICAvLyBiZWZvcmUgdGhlcmUgd2FzICpub3QqIGVub3VnaC5cbiAgLy9cbiAgLy8gU28sIHRoZSBzdGVwcyBhcmU6XG4gIC8vIDEuIEZpZ3VyZSBvdXQgd2hhdCB0aGUgc3RhdGUgb2YgdGhpbmdzIHdpbGwgYmUgYWZ0ZXIgd2UgZG9cbiAgLy8gYSByZWFkIGZyb20gdGhlIGJ1ZmZlci5cbiAgLy9cbiAgLy8gMi4gSWYgdGhhdCByZXN1bHRpbmcgc3RhdGUgd2lsbCB0cmlnZ2VyIGEgX3JlYWQsIHRoZW4gY2FsbCBfcmVhZC5cbiAgLy8gTm90ZSB0aGF0IHRoaXMgbWF5IGJlIGFzeW5jaHJvbm91cywgb3Igc3luY2hyb25vdXMuICBZZXMsIGl0IGlzXG4gIC8vIGRlZXBseSB1Z2x5IHRvIHdyaXRlIEFQSXMgdGhpcyB3YXksIGJ1dCB0aGF0IHN0aWxsIGRvZXNuJ3QgbWVhblxuICAvLyB0aGF0IHRoZSBSZWFkYWJsZSBjbGFzcyBzaG91bGQgYmVoYXZlIGltcHJvcGVybHksIGFzIHN0cmVhbXMgYXJlXG4gIC8vIGRlc2lnbmVkIHRvIGJlIHN5bmMvYXN5bmMgYWdub3N0aWMuXG4gIC8vIFRha2Ugbm90ZSBpZiB0aGUgX3JlYWQgY2FsbCBpcyBzeW5jIG9yIGFzeW5jIChpZSwgaWYgdGhlIHJlYWQgY2FsbFxuICAvLyBoYXMgcmV0dXJuZWQgeWV0KSwgc28gdGhhdCB3ZSBrbm93IHdoZXRoZXIgb3Igbm90IGl0J3Mgc2FmZSB0byBlbWl0XG4gIC8vICdyZWFkYWJsZScgZXRjLlxuICAvL1xuICAvLyAzLiBBY3R1YWxseSBwdWxsIHRoZSByZXF1ZXN0ZWQgY2h1bmtzIG91dCBvZiB0aGUgYnVmZmVyIGFuZCByZXR1cm4uXG5cbiAgLy8gaWYgd2UgbmVlZCBhIHJlYWRhYmxlIGV2ZW50LCB0aGVuIHdlIG5lZWQgdG8gZG8gc29tZSByZWFkaW5nLlxuICB2YXIgZG9SZWFkID0gc3RhdGUubmVlZFJlYWRhYmxlO1xuICBkZWJ1ZygnbmVlZCByZWFkYWJsZScsIGRvUmVhZCk7XG5cbiAgLy8gaWYgd2UgY3VycmVudGx5IGhhdmUgbGVzcyB0aGFuIHRoZSBoaWdoV2F0ZXJNYXJrLCB0aGVuIGFsc28gcmVhZCBzb21lXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgfHwgc3RhdGUubGVuZ3RoIC0gbiA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkb1JlYWQgPSB0cnVlO1xuICAgIGRlYnVnKCdsZW5ndGggbGVzcyB0aGFuIHdhdGVybWFyaycsIGRvUmVhZCk7XG4gIH1cblxuICAvLyBob3dldmVyLCBpZiB3ZSd2ZSBlbmRlZCwgdGhlbiB0aGVyZSdzIG5vIHBvaW50LCBhbmQgaWYgd2UncmUgYWxyZWFkeVxuICAvLyByZWFkaW5nLCB0aGVuIGl0J3MgdW5uZWNlc3NhcnkuXG4gIGlmIChzdGF0ZS5lbmRlZCB8fCBzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZG9SZWFkID0gZmFsc2U7XG4gICAgZGVidWcoJ3JlYWRpbmcgb3IgZW5kZWQnLCBkb1JlYWQpO1xuICB9XG5cbiAgaWYgKGRvUmVhZCkge1xuICAgIGRlYnVnKCdkbyByZWFkJyk7XG4gICAgc3RhdGUucmVhZGluZyA9IHRydWU7XG4gICAgc3RhdGUuc3luYyA9IHRydWU7XG4gICAgLy8gaWYgdGhlIGxlbmd0aCBpcyBjdXJyZW50bHkgemVybywgdGhlbiB3ZSAqbmVlZCogYSByZWFkYWJsZSBldmVudC5cbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKVxuICAgICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAvLyBjYWxsIGludGVybmFsIHJlYWQgbWV0aG9kXG4gICAgdGhpcy5fcmVhZChzdGF0ZS5oaWdoV2F0ZXJNYXJrKTtcbiAgICBzdGF0ZS5zeW5jID0gZmFsc2U7XG4gIH1cblxuICAvLyBJZiBfcmVhZCBwdXNoZWQgZGF0YSBzeW5jaHJvbm91c2x5LCB0aGVuIGByZWFkaW5nYCB3aWxsIGJlIGZhbHNlLFxuICAvLyBhbmQgd2UgbmVlZCB0byByZS1ldmFsdWF0ZSBob3cgbXVjaCBkYXRhIHdlIGNhbiByZXR1cm4gdG8gdGhlIHVzZXIuXG4gIGlmIChkb1JlYWQgJiYgIXN0YXRlLnJlYWRpbmcpXG4gICAgbiA9IGhvd011Y2hUb1JlYWQobk9yaWcsIHN0YXRlKTtcblxuICB2YXIgcmV0O1xuICBpZiAobiA+IDApXG4gICAgcmV0ID0gZnJvbUxpc3Qobiwgc3RhdGUpO1xuICBlbHNlXG4gICAgcmV0ID0gbnVsbDtcblxuICBpZiAocmV0ID09PSBudWxsKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBuID0gMDtcbiAgfVxuXG4gIHN0YXRlLmxlbmd0aCAtPSBuO1xuXG4gIC8vIElmIHdlIGhhdmUgbm90aGluZyBpbiB0aGUgYnVmZmVyLCB0aGVuIHdlIHdhbnQgdG8ga25vd1xuICAvLyBhcyBzb29uIGFzIHdlICpkbyogZ2V0IHNvbWV0aGluZyBpbnRvIHRoZSBidWZmZXIuXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgIXN0YXRlLmVuZGVkKVxuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgLy8gSWYgd2UgdHJpZWQgdG8gcmVhZCgpIHBhc3QgdGhlIEVPRiwgdGhlbiBlbWl0IGVuZCBvbiB0aGUgbmV4dCB0aWNrLlxuICBpZiAobk9yaWcgIT09IG4gJiYgc3RhdGUuZW5kZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKVxuICAgIGVuZFJlYWRhYmxlKHRoaXMpO1xuXG4gIGlmIChyZXQgIT09IG51bGwpXG4gICAgdGhpcy5lbWl0KCdkYXRhJywgcmV0KTtcblxuICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuaykge1xuICB2YXIgZXIgPSBudWxsO1xuICBpZiAoIShCdWZmZXIuaXNCdWZmZXIoY2h1bmspKSAmJlxuICAgICAgdHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJlxuICAgICAgY2h1bmsgIT09IG51bGwgJiZcbiAgICAgIGNodW5rICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gIH1cbiAgcmV0dXJuIGVyO1xufVxuXG5cbmZ1bmN0aW9uIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUuZW5kZWQpIHJldHVybjtcbiAgaWYgKHN0YXRlLmRlY29kZXIpIHtcbiAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHtcbiAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICB9XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuXG4gIC8vIGVtaXQgJ3JlYWRhYmxlJyBub3cgdG8gbWFrZSBzdXJlIGl0IGdldHMgcGlja2VkIHVwLlxuICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbn1cblxuLy8gRG9uJ3QgZW1pdCByZWFkYWJsZSByaWdodCBhd2F5IGluIHN5bmMgbW9kZSwgYmVjYXVzZSB0aGlzIGNhbiB0cmlnZ2VyXG4vLyBhbm90aGVyIHJlYWQoKSBjYWxsID0+IHN0YWNrIG92ZXJmbG93LiAgVGhpcyB3YXksIGl0IG1pZ2h0IHRyaWdnZXJcbi8vIGEgbmV4dFRpY2sgcmVjdXJzaW9uIHdhcm5pbmcsIGJ1dCB0aGF0J3Mgbm90IHNvIGJhZC5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgaWYgKCFzdGF0ZS5lbWl0dGVkUmVhZGFibGUpIHtcbiAgICBkZWJ1ZygnZW1pdFJlYWRhYmxlJywgc3RhdGUuZmxvd2luZyk7XG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBpZiAoc3RhdGUuc3luYylcbiAgICAgIHByb2Nlc3NOZXh0VGljayhlbWl0UmVhZGFibGVfLCBzdHJlYW0pO1xuICAgIGVsc2VcbiAgICAgIGVtaXRSZWFkYWJsZV8oc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGVfKHN0cmVhbSkge1xuICBkZWJ1ZygnZW1pdCByZWFkYWJsZScpO1xuICBzdHJlYW0uZW1pdCgncmVhZGFibGUnKTtcbiAgZmxvdyhzdHJlYW0pO1xufVxuXG5cbi8vIGF0IHRoaXMgcG9pbnQsIHRoZSB1c2VyIGhhcyBwcmVzdW1hYmx5IHNlZW4gdGhlICdyZWFkYWJsZScgZXZlbnQsXG4vLyBhbmQgY2FsbGVkIHJlYWQoKSB0byBjb25zdW1lIHNvbWUgZGF0YS4gIHRoYXQgbWF5IGhhdmUgdHJpZ2dlcmVkXG4vLyBpbiB0dXJuIGFub3RoZXIgX3JlYWQobikgY2FsbCwgaW4gd2hpY2ggY2FzZSByZWFkaW5nID0gdHJ1ZSBpZlxuLy8gaXQncyBpbiBwcm9ncmVzcy5cbi8vIEhvd2V2ZXIsIGlmIHdlJ3JlIG5vdCBlbmRlZCwgb3IgcmVhZGluZywgYW5kIHRoZSBsZW5ndGggPCBod20sXG4vLyB0aGVuIGdvIGFoZWFkIGFuZCB0cnkgdG8gcmVhZCBzb21lIG1vcmUgcHJlZW1wdGl2ZWx5LlxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVhZGluZ01vcmUpIHtcbiAgICBzdGF0ZS5yZWFkaW5nTW9yZSA9IHRydWU7XG4gICAgcHJvY2Vzc05leHRUaWNrKG1heWJlUmVhZE1vcmVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlXyhzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIHdoaWxlICghc3RhdGUucmVhZGluZyAmJiAhc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUuZW5kZWQgJiZcbiAgICAgICAgIHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkZWJ1ZygnbWF5YmVSZWFkTW9yZSByZWFkIDAnKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgICBpZiAobGVuID09PSBzdGF0ZS5sZW5ndGgpXG4gICAgICAvLyBkaWRuJ3QgZ2V0IGFueSBkYXRhLCBzdG9wIHNwaW5uaW5nLlxuICAgICAgYnJlYWs7XG4gICAgZWxzZVxuICAgICAgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB9XG4gIHN0YXRlLnJlYWRpbmdNb3JlID0gZmFsc2U7XG59XG5cbi8vIGFic3RyYWN0IG1ldGhvZC4gIHRvIGJlIG92ZXJyaWRkZW4gaW4gc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vIGNhbGwgY2IoZXIsIGRhdGEpIHdoZXJlIGRhdGEgaXMgPD0gbiBpbiBsZW5ndGguXG4vLyBmb3IgdmlydHVhbCAobm9uLXN0cmluZywgbm9uLWJ1ZmZlcikgc3RyZWFtcywgXCJsZW5ndGhcIiBpcyBzb21ld2hhdFxuLy8gYXJiaXRyYXJ5LCBhbmQgcGVyaGFwcyBub3QgdmVyeSBtZWFuaW5nZnVsLlxuUmVhZGFibGUucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24obikge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKGRlc3QsIHBpcGVPcHRzKSB7XG4gIHZhciBzcmMgPSB0aGlzO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIHN3aXRjaCAoc3RhdGUucGlwZXNDb3VudCkge1xuICAgIGNhc2UgMDpcbiAgICAgIHN0YXRlLnBpcGVzID0gZGVzdDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTpcbiAgICAgIHN0YXRlLnBpcGVzID0gW3N0YXRlLnBpcGVzLCBkZXN0XTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBzdGF0ZS5waXBlcy5wdXNoKGRlc3QpO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgc3RhdGUucGlwZXNDb3VudCArPSAxO1xuICBkZWJ1ZygncGlwZSBjb3VudD0lZCBvcHRzPSVqJywgc3RhdGUucGlwZXNDb3VudCwgcGlwZU9wdHMpO1xuXG4gIHZhciBkb0VuZCA9ICghcGlwZU9wdHMgfHwgcGlwZU9wdHMuZW5kICE9PSBmYWxzZSkgJiZcbiAgICAgICAgICAgICAgZGVzdCAhPT0gcHJvY2Vzcy5zdGRvdXQgJiZcbiAgICAgICAgICAgICAgZGVzdCAhPT0gcHJvY2Vzcy5zdGRlcnI7XG5cbiAgdmFyIGVuZEZuID0gZG9FbmQgPyBvbmVuZCA6IGNsZWFudXA7XG4gIGlmIChzdGF0ZS5lbmRFbWl0dGVkKVxuICAgIHByb2Nlc3NOZXh0VGljayhlbmRGbik7XG4gIGVsc2VcbiAgICBzcmMub25jZSgnZW5kJywgZW5kRm4pO1xuXG4gIGRlc3Qub24oJ3VucGlwZScsIG9udW5waXBlKTtcbiAgZnVuY3Rpb24gb251bnBpcGUocmVhZGFibGUpIHtcbiAgICBkZWJ1Zygnb251bnBpcGUnKTtcbiAgICBpZiAocmVhZGFibGUgPT09IHNyYykge1xuICAgICAgY2xlYW51cCgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGRlYnVnKCdvbmVuZCcpO1xuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuICAvLyB3aGVuIHRoZSBkZXN0IGRyYWlucywgaXQgcmVkdWNlcyB0aGUgYXdhaXREcmFpbiBjb3VudGVyXG4gIC8vIG9uIHRoZSBzb3VyY2UuICBUaGlzIHdvdWxkIGJlIG1vcmUgZWxlZ2FudCB3aXRoIGEgLm9uY2UoKVxuICAvLyBoYW5kbGVyIGluIGZsb3coKSwgYnV0IGFkZGluZyBhbmQgcmVtb3ZpbmcgcmVwZWF0ZWRseSBpc1xuICAvLyB0b28gc2xvdy5cbiAgdmFyIG9uZHJhaW4gPSBwaXBlT25EcmFpbihzcmMpO1xuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIHZhciBjbGVhbmVkVXAgPSBmYWxzZTtcbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBkZWJ1ZygnY2xlYW51cCcpO1xuICAgIC8vIGNsZWFudXAgZXZlbnQgaGFuZGxlcnMgb25jZSB0aGUgcGlwZSBpcyBicm9rZW5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcigndW5waXBlJywgb251bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgY2xlYW51cCk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcblxuICAgIGNsZWFuZWRVcCA9IHRydWU7XG5cbiAgICAvLyBpZiB0aGUgcmVhZGVyIGlzIHdhaXRpbmcgZm9yIGEgZHJhaW4gZXZlbnQgZnJvbSB0aGlzXG4gICAgLy8gc3BlY2lmaWMgd3JpdGVyLCB0aGVuIGl0IHdvdWxkIGNhdXNlIGl0IHRvIG5ldmVyIHN0YXJ0XG4gICAgLy8gZmxvd2luZyBhZ2Fpbi5cbiAgICAvLyBTbywgaWYgdGhpcyBpcyBhd2FpdGluZyBhIGRyYWluLCB0aGVuIHdlIGp1c3QgY2FsbCBpdCBub3cuXG4gICAgLy8gSWYgd2UgZG9uJ3Qga25vdywgdGhlbiBhc3N1bWUgdGhhdCB3ZSBhcmUgd2FpdGluZyBmb3Igb25lLlxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluICYmXG4gICAgICAgICghZGVzdC5fd3JpdGFibGVTdGF0ZSB8fCBkZXN0Ll93cml0YWJsZVN0YXRlLm5lZWREcmFpbikpXG4gICAgICBvbmRyYWluKCk7XG4gIH1cblxuICBzcmMub24oJ2RhdGEnLCBvbmRhdGEpO1xuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcbiAgICBkZWJ1Zygnb25kYXRhJyk7XG4gICAgdmFyIHJldCA9IGRlc3Qud3JpdGUoY2h1bmspO1xuICAgIGlmIChmYWxzZSA9PT0gcmV0KSB7XG4gICAgICAvLyBJZiB0aGUgdXNlciB1bnBpcGVkIGR1cmluZyBgZGVzdC53cml0ZSgpYCwgaXQgaXMgcG9zc2libGVcbiAgICAgIC8vIHRvIGdldCBzdHVjayBpbiBhIHBlcm1hbmVudGx5IHBhdXNlZCBzdGF0ZSBpZiB0aGF0IHdyaXRlXG4gICAgICAvLyBhbHNvIHJldHVybmVkIGZhbHNlLlxuICAgICAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEgJiZcbiAgICAgICAgICBzdGF0ZS5waXBlc1swXSA9PT0gZGVzdCAmJlxuICAgICAgICAgIHNyYy5saXN0ZW5lckNvdW50KCdkYXRhJykgPT09IDEgJiZcbiAgICAgICAgICAhY2xlYW5lZFVwKSB7XG4gICAgICAgIGRlYnVnKCdmYWxzZSB3cml0ZSByZXNwb25zZSwgcGF1c2UnLCBzcmMuX3JlYWRhYmxlU3RhdGUuYXdhaXREcmFpbik7XG4gICAgICAgIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKys7XG4gICAgICB9XG4gICAgICBzcmMucGF1c2UoKTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgZGVzdCBoYXMgYW4gZXJyb3IsIHRoZW4gc3RvcCBwaXBpbmcgaW50byBpdC5cbiAgLy8gaG93ZXZlciwgZG9uJ3Qgc3VwcHJlc3MgdGhlIHRocm93aW5nIGJlaGF2aW9yIGZvciB0aGlzLlxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgZGVidWcoJ29uZXJyb3InLCBlcik7XG4gICAgdW5waXBlKCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBpZiAoRUVsaXN0ZW5lckNvdW50KGRlc3QsICdlcnJvcicpID09PSAwKVxuICAgICAgZGVzdC5lbWl0KCdlcnJvcicsIGVyKTtcbiAgfVxuICAvLyBUaGlzIGlzIGEgYnJ1dGFsbHkgdWdseSBoYWNrIHRvIG1ha2Ugc3VyZSB0aGF0IG91ciBlcnJvciBoYW5kbGVyXG4gIC8vIGlzIGF0dGFjaGVkIGJlZm9yZSBhbnkgdXNlcmxhbmQgb25lcy4gIE5FVkVSIERPIFRISVMuXG4gIGlmICghZGVzdC5fZXZlbnRzIHx8ICFkZXN0Ll9ldmVudHMuZXJyb3IpXG4gICAgZGVzdC5vbignZXJyb3InLCBvbmVycm9yKTtcbiAgZWxzZSBpZiAoaXNBcnJheShkZXN0Ll9ldmVudHMuZXJyb3IpKVxuICAgIGRlc3QuX2V2ZW50cy5lcnJvci51bnNoaWZ0KG9uZXJyb3IpO1xuICBlbHNlXG4gICAgZGVzdC5fZXZlbnRzLmVycm9yID0gW29uZXJyb3IsIGRlc3QuX2V2ZW50cy5lcnJvcl07XG5cblxuICAvLyBCb3RoIGNsb3NlIGFuZCBmaW5pc2ggc2hvdWxkIHRyaWdnZXIgdW5waXBlLCBidXQgb25seSBvbmNlLlxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7XG4gIGZ1bmN0aW9uIG9uZmluaXNoKCkge1xuICAgIGRlYnVnKCdvbmZpbmlzaCcpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG5cbiAgZnVuY3Rpb24gdW5waXBlKCkge1xuICAgIGRlYnVnKCd1bnBpcGUnKTtcbiAgICBzcmMudW5waXBlKGRlc3QpO1xuICB9XG5cbiAgLy8gdGVsbCB0aGUgZGVzdCB0aGF0IGl0J3MgYmVpbmcgcGlwZWQgdG9cbiAgZGVzdC5lbWl0KCdwaXBlJywgc3JjKTtcblxuICAvLyBzdGFydCB0aGUgZmxvdyBpZiBpdCBoYXNuJ3QgYmVlbiBzdGFydGVkIGFscmVhZHkuXG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwaXBlIHJlc3VtZScpO1xuICAgIHNyYy5yZXN1bWUoKTtcbiAgfVxuXG4gIHJldHVybiBkZXN0O1xufTtcblxuZnVuY3Rpb24gcGlwZU9uRHJhaW4oc3JjKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RhdGUgPSBzcmMuX3JlYWRhYmxlU3RhdGU7XG4gICAgZGVidWcoJ3BpcGVPbkRyYWluJywgc3RhdGUuYXdhaXREcmFpbik7XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4pXG4gICAgICBzdGF0ZS5hd2FpdERyYWluLS07XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gPT09IDAgJiYgRUVsaXN0ZW5lckNvdW50KHNyYywgJ2RhdGEnKSkge1xuICAgICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgICBmbG93KHNyYyk7XG4gICAgfVxuICB9O1xufVxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS51bnBpcGUgPSBmdW5jdGlvbihkZXN0KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgLy8gaWYgd2UncmUgbm90IHBpcGluZyBhbnl3aGVyZSwgdGhlbiBkbyBub3RoaW5nLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMClcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBqdXN0IG9uZSBkZXN0aW5hdGlvbi4gIG1vc3QgY29tbW9uIGNhc2UuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSB7XG4gICAgLy8gcGFzc2VkIGluIG9uZSwgYnV0IGl0J3Mgbm90IHRoZSByaWdodCBvbmUuXG4gICAgaWYgKGRlc3QgJiYgZGVzdCAhPT0gc3RhdGUucGlwZXMpXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIGlmICghZGVzdClcbiAgICAgIGRlc3QgPSBzdGF0ZS5waXBlcztcblxuICAgIC8vIGdvdCBhIG1hdGNoLlxuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgaWYgKGRlc3QpXG4gICAgICBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gc2xvdyBjYXNlLiBtdWx0aXBsZSBwaXBlIGRlc3RpbmF0aW9ucy5cblxuICBpZiAoIWRlc3QpIHtcbiAgICAvLyByZW1vdmUgYWxsLlxuICAgIHZhciBkZXN0cyA9IHN0YXRlLnBpcGVzO1xuICAgIHZhciBsZW4gPSBzdGF0ZS5waXBlc0NvdW50O1xuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgZGVzdHNbaV0uZW1pdCgndW5waXBlJywgdGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyB0cnkgdG8gZmluZCB0aGUgcmlnaHQgb25lLlxuICB2YXIgaSA9IGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpO1xuICBpZiAoaSA9PT0gLTEpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgc3RhdGUucGlwZXMuc3BsaWNlKGksIDEpO1xuICBzdGF0ZS5waXBlc0NvdW50IC09IDE7XG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKVxuICAgIHN0YXRlLnBpcGVzID0gc3RhdGUucGlwZXNbMF07XG5cbiAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIHNldCB1cCBkYXRhIGV2ZW50cyBpZiB0aGV5IGFyZSBhc2tlZCBmb3Jcbi8vIEVuc3VyZSByZWFkYWJsZSBsaXN0ZW5lcnMgZXZlbnR1YWxseSBnZXQgc29tZXRoaW5nXG5SZWFkYWJsZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbihldiwgZm4pIHtcbiAgdmFyIHJlcyA9IFN0cmVhbS5wcm90b3R5cGUub24uY2FsbCh0aGlzLCBldiwgZm4pO1xuXG4gIC8vIElmIGxpc3RlbmluZyB0byBkYXRhLCBhbmQgaXQgaGFzIG5vdCBleHBsaWNpdGx5IGJlZW4gcGF1c2VkLFxuICAvLyB0aGVuIGNhbGwgcmVzdW1lIHRvIHN0YXJ0IHRoZSBmbG93IG9mIGRhdGEgb24gdGhlIG5leHQgdGljay5cbiAgaWYgKGV2ID09PSAnZGF0YScgJiYgZmFsc2UgIT09IHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZykge1xuICAgIHRoaXMucmVzdW1lKCk7XG4gIH1cblxuICBpZiAoZXYgPT09ICdyZWFkYWJsZScgJiYgdGhpcy5yZWFkYWJsZSkge1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKCFzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZykge1xuICAgICAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSB0cnVlO1xuICAgICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gICAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgICAgIHByb2Nlc3NOZXh0VGljayhuUmVhZGluZ05leHRUaWNrLCB0aGlzKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUubGVuZ3RoKSB7XG4gICAgICAgIGVtaXRSZWFkYWJsZSh0aGlzLCBzdGF0ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5SZWFkYWJsZS5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBSZWFkYWJsZS5wcm90b3R5cGUub247XG5cbmZ1bmN0aW9uIG5SZWFkaW5nTmV4dFRpY2soc2VsZikge1xuICBkZWJ1ZygncmVhZGFibGUgbmV4dHRpY2sgcmVhZCAwJyk7XG4gIHNlbGYucmVhZCgwKTtcbn1cblxuLy8gcGF1c2UoKSBhbmQgcmVzdW1lKCkgYXJlIHJlbW5hbnRzIG9mIHRoZSBsZWdhY3kgcmVhZGFibGUgc3RyZWFtIEFQSVxuLy8gSWYgdGhlIHVzZXIgdXNlcyB0aGVtLCB0aGVuIHN3aXRjaCBpbnRvIG9sZCBtb2RlLlxuUmVhZGFibGUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncmVzdW1lJyk7XG4gICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgcmVzdW1lKHRoaXMsIHN0YXRlKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIHJlc3VtZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVzdW1lU2NoZWR1bGVkKSB7XG4gICAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICBwcm9jZXNzTmV4dFRpY2socmVzdW1lXywgc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdW1lXyhzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVhZGluZykge1xuICAgIGRlYnVnKCdyZXN1bWUgcmVhZCAwJyk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gIH1cblxuICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgc3RyZWFtLmVtaXQoJ3Jlc3VtZScpO1xuICBmbG93KHN0cmVhbSk7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5yZWFkaW5nKVxuICAgIHN0cmVhbS5yZWFkKDApO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2NhbGwgcGF1c2UgZmxvd2luZz0laicsIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyk7XG4gIGlmIChmYWxzZSAhPT0gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3BhdXNlJyk7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KCdwYXVzZScpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gZmxvdyhzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZmxvdycsIHN0YXRlLmZsb3dpbmcpO1xuICBpZiAoc3RhdGUuZmxvd2luZykge1xuICAgIGRvIHtcbiAgICAgIHZhciBjaHVuayA9IHN0cmVhbS5yZWFkKCk7XG4gICAgfSB3aGlsZSAobnVsbCAhPT0gY2h1bmsgJiYgc3RhdGUuZmxvd2luZyk7XG4gIH1cbn1cblxuLy8gd3JhcCBhbiBvbGQtc3R5bGUgc3RyZWFtIGFzIHRoZSBhc3luYyBkYXRhIHNvdXJjZS5cbi8vIFRoaXMgaXMgKm5vdCogcGFydCBvZiB0aGUgcmVhZGFibGUgc3RyZWFtIGludGVyZmFjZS5cbi8vIEl0IGlzIGFuIHVnbHkgdW5mb3J0dW5hdGUgbWVzcyBvZiBoaXN0b3J5LlxuUmVhZGFibGUucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbihzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHBhdXNlZCA9IGZhbHNlO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgc3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbigpIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBlbmQnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHtcbiAgICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKVxuICAgICAgICBzZWxmLnB1c2goY2h1bmspO1xuICAgIH1cblxuICAgIHNlbGYucHVzaChudWxsKTtcbiAgfSk7XG5cbiAgc3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24oY2h1bmspIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBkYXRhJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpXG4gICAgICBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuXG4gICAgLy8gZG9uJ3Qgc2tpcCBvdmVyIGZhbHN5IHZhbHVlcyBpbiBvYmplY3RNb2RlXG4gICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgJiYgKGNodW5rID09PSBudWxsIHx8IGNodW5rID09PSB1bmRlZmluZWQpKVxuICAgICAgcmV0dXJuO1xuICAgIGVsc2UgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmICghY2h1bmsgfHwgIWNodW5rLmxlbmd0aCkpXG4gICAgICByZXR1cm47XG5cbiAgICB2YXIgcmV0ID0gc2VsZi5wdXNoKGNodW5rKTtcbiAgICBpZiAoIXJldCkge1xuICAgICAgcGF1c2VkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5wYXVzZSgpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gcHJveHkgYWxsIHRoZSBvdGhlciBtZXRob2RzLlxuICAvLyBpbXBvcnRhbnQgd2hlbiB3cmFwcGluZyBmaWx0ZXJzIGFuZCBkdXBsZXhlcy5cbiAgZm9yICh2YXIgaSBpbiBzdHJlYW0pIHtcbiAgICBpZiAodGhpc1tpXSA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBzdHJlYW1baV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXNbaV0gPSBmdW5jdGlvbihtZXRob2QpIHsgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gc3RyZWFtW21ldGhvZF0uYXBwbHkoc3RyZWFtLCBhcmd1bWVudHMpO1xuICAgICAgfTsgfShpKTtcbiAgICB9XG4gIH1cblxuICAvLyBwcm94eSBjZXJ0YWluIGltcG9ydGFudCBldmVudHMuXG4gIHZhciBldmVudHMgPSBbJ2Vycm9yJywgJ2Nsb3NlJywgJ2Rlc3Ryb3knLCAncGF1c2UnLCAncmVzdW1lJ107XG4gIGZvckVhY2goZXZlbnRzLCBmdW5jdGlvbihldikge1xuICAgIHN0cmVhbS5vbihldiwgc2VsZi5lbWl0LmJpbmQoc2VsZiwgZXYpKTtcbiAgfSk7XG5cbiAgLy8gd2hlbiB3ZSB0cnkgdG8gY29uc3VtZSBzb21lIG1vcmUgYnl0ZXMsIHNpbXBseSB1bnBhdXNlIHRoZVxuICAvLyB1bmRlcmx5aW5nIHN0cmVhbS5cbiAgc2VsZi5fcmVhZCA9IGZ1bmN0aW9uKG4pIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBfcmVhZCcsIG4pO1xuICAgIGlmIChwYXVzZWQpIHtcbiAgICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgICAgc3RyZWFtLnJlc3VtZSgpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gc2VsZjtcbn07XG5cblxuLy8gZXhwb3NlZCBmb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5LlxuUmVhZGFibGUuX2Zyb21MaXN0ID0gZnJvbUxpc3Q7XG5cbi8vIFBsdWNrIG9mZiBuIGJ5dGVzIGZyb20gYW4gYXJyYXkgb2YgYnVmZmVycy5cbi8vIExlbmd0aCBpcyB0aGUgY29tYmluZWQgbGVuZ3RocyBvZiBhbGwgdGhlIGJ1ZmZlcnMgaW4gdGhlIGxpc3QuXG5mdW5jdGlvbiBmcm9tTGlzdChuLCBzdGF0ZSkge1xuICB2YXIgbGlzdCA9IHN0YXRlLmJ1ZmZlcjtcbiAgdmFyIGxlbmd0aCA9IHN0YXRlLmxlbmd0aDtcbiAgdmFyIHN0cmluZ01vZGUgPSAhIXN0YXRlLmRlY29kZXI7XG4gIHZhciBvYmplY3RNb2RlID0gISFzdGF0ZS5vYmplY3RNb2RlO1xuICB2YXIgcmV0O1xuXG4gIC8vIG5vdGhpbmcgaW4gdGhlIGxpc3QsIGRlZmluaXRlbHkgZW1wdHkuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm4gbnVsbDtcblxuICBpZiAobGVuZ3RoID09PSAwKVxuICAgIHJldCA9IG51bGw7XG4gIGVsc2UgaWYgKG9iamVjdE1vZGUpXG4gICAgcmV0ID0gbGlzdC5zaGlmdCgpO1xuICBlbHNlIGlmICghbiB8fCBuID49IGxlbmd0aCkge1xuICAgIC8vIHJlYWQgaXQgYWxsLCB0cnVuY2F0ZSB0aGUgYXJyYXkuXG4gICAgaWYgKHN0cmluZ01vZGUpXG4gICAgICByZXQgPSBsaXN0LmpvaW4oJycpO1xuICAgIGVsc2UgaWYgKGxpc3QubGVuZ3RoID09PSAxKVxuICAgICAgcmV0ID0gbGlzdFswXTtcbiAgICBlbHNlXG4gICAgICByZXQgPSBCdWZmZXIuY29uY2F0KGxpc3QsIGxlbmd0aCk7XG4gICAgbGlzdC5sZW5ndGggPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlYWQganVzdCBzb21lIG9mIGl0LlxuICAgIGlmIChuIDwgbGlzdFswXS5sZW5ndGgpIHtcbiAgICAgIC8vIGp1c3QgdGFrZSBhIHBhcnQgb2YgdGhlIGZpcnN0IGxpc3QgaXRlbS5cbiAgICAgIC8vIHNsaWNlIGlzIHRoZSBzYW1lIGZvciBidWZmZXJzIGFuZCBzdHJpbmdzLlxuICAgICAgdmFyIGJ1ZiA9IGxpc3RbMF07XG4gICAgICByZXQgPSBidWYuc2xpY2UoMCwgbik7XG4gICAgICBsaXN0WzBdID0gYnVmLnNsaWNlKG4pO1xuICAgIH0gZWxzZSBpZiAobiA9PT0gbGlzdFswXS5sZW5ndGgpIHtcbiAgICAgIC8vIGZpcnN0IGxpc3QgaXMgYSBwZXJmZWN0IG1hdGNoXG4gICAgICByZXQgPSBsaXN0LnNoaWZ0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGNvbXBsZXggY2FzZS5cbiAgICAgIC8vIHdlIGhhdmUgZW5vdWdoIHRvIGNvdmVyIGl0LCBidXQgaXQgc3BhbnMgcGFzdCB0aGUgZmlyc3QgYnVmZmVyLlxuICAgICAgaWYgKHN0cmluZ01vZGUpXG4gICAgICAgIHJldCA9ICcnO1xuICAgICAgZWxzZVxuICAgICAgICByZXQgPSBuZXcgQnVmZmVyKG4pO1xuXG4gICAgICB2YXIgYyA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbCAmJiBjIDwgbjsgaSsrKSB7XG4gICAgICAgIHZhciBidWYgPSBsaXN0WzBdO1xuICAgICAgICB2YXIgY3B5ID0gTWF0aC5taW4obiAtIGMsIGJ1Zi5sZW5ndGgpO1xuXG4gICAgICAgIGlmIChzdHJpbmdNb2RlKVxuICAgICAgICAgIHJldCArPSBidWYuc2xpY2UoMCwgY3B5KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGJ1Zi5jb3B5KHJldCwgYywgMCwgY3B5KTtcblxuICAgICAgICBpZiAoY3B5IDwgYnVmLmxlbmd0aClcbiAgICAgICAgICBsaXN0WzBdID0gYnVmLnNsaWNlKGNweSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBsaXN0LnNoaWZ0KCk7XG5cbiAgICAgICAgYyArPSBjcHk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcblxuICAvLyBJZiB3ZSBnZXQgaGVyZSBiZWZvcmUgY29uc3VtaW5nIGFsbCB0aGUgYnl0ZXMsIHRoZW4gdGhhdCBpcyBhXG4gIC8vIGJ1ZyBpbiBub2RlLiAgU2hvdWxkIG5ldmVyIGhhcHBlbi5cbiAgaWYgKHN0YXRlLmxlbmd0aCA+IDApXG4gICAgdGhyb3cgbmV3IEVycm9yKCdlbmRSZWFkYWJsZSBjYWxsZWQgb24gbm9uLWVtcHR5IHN0cmVhbScpO1xuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCkge1xuICAgIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgICBwcm9jZXNzTmV4dFRpY2soZW5kUmVhZGFibGVOVCwgc3RhdGUsIHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGVOVChzdGF0ZSwgc3RyZWFtKSB7XG4gIC8vIENoZWNrIHRoYXQgd2UgZGlkbid0IGdldCBvbmUgbGFzdCB1bnNoaWZ0LlxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgc3RhdGUuZW5kRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2VuZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZvckVhY2ggKHhzLCBmKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZih4c1tpXSwgaSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5kZXhPZiAoeHMsIHgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoeHNbaV0gPT09IHgpIHJldHVybiBpO1xuICB9XG4gIHJldHVybiAtMTtcbn1cbiIsIi8vIGEgdHJhbnNmb3JtIHN0cmVhbSBpcyBhIHJlYWRhYmxlL3dyaXRhYmxlIHN0cmVhbSB3aGVyZSB5b3UgZG9cbi8vIHNvbWV0aGluZyB3aXRoIHRoZSBkYXRhLiAgU29tZXRpbWVzIGl0J3MgY2FsbGVkIGEgXCJmaWx0ZXJcIixcbi8vIGJ1dCB0aGF0J3Mgbm90IGEgZ3JlYXQgbmFtZSBmb3IgaXQsIHNpbmNlIHRoYXQgaW1wbGllcyBhIHRoaW5nIHdoZXJlXG4vLyBzb21lIGJpdHMgcGFzcyB0aHJvdWdoLCBhbmQgb3RoZXJzIGFyZSBzaW1wbHkgaWdub3JlZC4gIChUaGF0IHdvdWxkXG4vLyBiZSBhIHZhbGlkIGV4YW1wbGUgb2YgYSB0cmFuc2Zvcm0sIG9mIGNvdXJzZS4pXG4vL1xuLy8gV2hpbGUgdGhlIG91dHB1dCBpcyBjYXVzYWxseSByZWxhdGVkIHRvIHRoZSBpbnB1dCwgaXQncyBub3QgYVxuLy8gbmVjZXNzYXJpbHkgc3ltbWV0cmljIG9yIHN5bmNocm9ub3VzIHRyYW5zZm9ybWF0aW9uLiAgRm9yIGV4YW1wbGUsXG4vLyBhIHpsaWIgc3RyZWFtIG1pZ2h0IHRha2UgbXVsdGlwbGUgcGxhaW4tdGV4dCB3cml0ZXMoKSwgYW5kIHRoZW5cbi8vIGVtaXQgYSBzaW5nbGUgY29tcHJlc3NlZCBjaHVuayBzb21lIHRpbWUgaW4gdGhlIGZ1dHVyZS5cbi8vXG4vLyBIZXJlJ3MgaG93IHRoaXMgd29ya3M6XG4vL1xuLy8gVGhlIFRyYW5zZm9ybSBzdHJlYW0gaGFzIGFsbCB0aGUgYXNwZWN0cyBvZiB0aGUgcmVhZGFibGUgYW5kIHdyaXRhYmxlXG4vLyBzdHJlYW0gY2xhc3Nlcy4gIFdoZW4geW91IHdyaXRlKGNodW5rKSwgdGhhdCBjYWxscyBfd3JpdGUoY2h1bmssY2IpXG4vLyBpbnRlcm5hbGx5LCBhbmQgcmV0dXJucyBmYWxzZSBpZiB0aGVyZSdzIGEgbG90IG9mIHBlbmRpbmcgd3JpdGVzXG4vLyBidWZmZXJlZCB1cC4gIFdoZW4geW91IGNhbGwgcmVhZCgpLCB0aGF0IGNhbGxzIF9yZWFkKG4pIHVudGlsXG4vLyB0aGVyZSdzIGVub3VnaCBwZW5kaW5nIHJlYWRhYmxlIGRhdGEgYnVmZmVyZWQgdXAuXG4vL1xuLy8gSW4gYSB0cmFuc2Zvcm0gc3RyZWFtLCB0aGUgd3JpdHRlbiBkYXRhIGlzIHBsYWNlZCBpbiBhIGJ1ZmZlci4gIFdoZW5cbi8vIF9yZWFkKG4pIGlzIGNhbGxlZCwgaXQgdHJhbnNmb3JtcyB0aGUgcXVldWVkIHVwIGRhdGEsIGNhbGxpbmcgdGhlXG4vLyBidWZmZXJlZCBfd3JpdGUgY2IncyBhcyBpdCBjb25zdW1lcyBjaHVua3MuICBJZiBjb25zdW1pbmcgYSBzaW5nbGVcbi8vIHdyaXR0ZW4gY2h1bmsgd291bGQgcmVzdWx0IGluIG11bHRpcGxlIG91dHB1dCBjaHVua3MsIHRoZW4gdGhlIGZpcnN0XG4vLyBvdXRwdXR0ZWQgYml0IGNhbGxzIHRoZSByZWFkY2IsIGFuZCBzdWJzZXF1ZW50IGNodW5rcyBqdXN0IGdvIGludG9cbi8vIHRoZSByZWFkIGJ1ZmZlciwgYW5kIHdpbGwgY2F1c2UgaXQgdG8gZW1pdCAncmVhZGFibGUnIGlmIG5lY2Vzc2FyeS5cbi8vXG4vLyBUaGlzIHdheSwgYmFjay1wcmVzc3VyZSBpcyBhY3R1YWxseSBkZXRlcm1pbmVkIGJ5IHRoZSByZWFkaW5nIHNpZGUsXG4vLyBzaW5jZSBfcmVhZCBoYXMgdG8gYmUgY2FsbGVkIHRvIHN0YXJ0IHByb2Nlc3NpbmcgYSBuZXcgY2h1bmsuICBIb3dldmVyLFxuLy8gYSBwYXRob2xvZ2ljYWwgaW5mbGF0ZSB0eXBlIG9mIHRyYW5zZm9ybSBjYW4gY2F1c2UgZXhjZXNzaXZlIGJ1ZmZlcmluZ1xuLy8gaGVyZS4gIEZvciBleGFtcGxlLCBpbWFnaW5lIGEgc3RyZWFtIHdoZXJlIGV2ZXJ5IGJ5dGUgb2YgaW5wdXQgaXNcbi8vIGludGVycHJldGVkIGFzIGFuIGludGVnZXIgZnJvbSAwLTI1NSwgYW5kIHRoZW4gcmVzdWx0cyBpbiB0aGF0IG1hbnlcbi8vIGJ5dGVzIG9mIG91dHB1dC4gIFdyaXRpbmcgdGhlIDQgYnl0ZXMge2ZmLGZmLGZmLGZmfSB3b3VsZCByZXN1bHQgaW5cbi8vIDFrYiBvZiBkYXRhIGJlaW5nIG91dHB1dC4gIEluIHRoaXMgY2FzZSwgeW91IGNvdWxkIHdyaXRlIGEgdmVyeSBzbWFsbFxuLy8gYW1vdW50IG9mIGlucHV0LCBhbmQgZW5kIHVwIHdpdGggYSB2ZXJ5IGxhcmdlIGFtb3VudCBvZiBvdXRwdXQuICBJblxuLy8gc3VjaCBhIHBhdGhvbG9naWNhbCBpbmZsYXRpbmcgbWVjaGFuaXNtLCB0aGVyZSdkIGJlIG5vIHdheSB0byB0ZWxsXG4vLyB0aGUgc3lzdGVtIHRvIHN0b3AgZG9pbmcgdGhlIHRyYW5zZm9ybS4gIEEgc2luZ2xlIDRNQiB3cml0ZSBjb3VsZFxuLy8gY2F1c2UgdGhlIHN5c3RlbSB0byBydW4gb3V0IG9mIG1lbW9yeS5cbi8vXG4vLyBIb3dldmVyLCBldmVuIGluIHN1Y2ggYSBwYXRob2xvZ2ljYWwgY2FzZSwgb25seSBhIHNpbmdsZSB3cml0dGVuIGNodW5rXG4vLyB3b3VsZCBiZSBjb25zdW1lZCwgYW5kIHRoZW4gdGhlIHJlc3Qgd291bGQgd2FpdCAodW4tdHJhbnNmb3JtZWQpIHVudGlsXG4vLyB0aGUgcmVzdWx0cyBvZiB0aGUgcHJldmlvdXMgdHJhbnNmb3JtZWQgY2h1bmsgd2VyZSBjb25zdW1lZC5cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybTtcblxudmFyIER1cGxleCA9IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG51dGlsLmluaGVyaXRzKFRyYW5zZm9ybSwgRHVwbGV4KTtcblxuXG5mdW5jdGlvbiBUcmFuc2Zvcm1TdGF0ZShzdHJlYW0pIHtcbiAgdGhpcy5hZnRlclRyYW5zZm9ybSA9IGZ1bmN0aW9uKGVyLCBkYXRhKSB7XG4gICAgcmV0dXJuIGFmdGVyVHJhbnNmb3JtKHN0cmVhbSwgZXIsIGRhdGEpO1xuICB9O1xuXG4gIHRoaXMubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xuICB0aGlzLnRyYW5zZm9ybWluZyA9IGZhbHNlO1xuICB0aGlzLndyaXRlY2IgPSBudWxsO1xuICB0aGlzLndyaXRlY2h1bmsgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBhZnRlclRyYW5zZm9ybShzdHJlYW0sIGVyLCBkYXRhKSB7XG4gIHZhciB0cyA9IHN0cmVhbS5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLnRyYW5zZm9ybWluZyA9IGZhbHNlO1xuXG4gIHZhciBjYiA9IHRzLndyaXRlY2I7XG5cbiAgaWYgKCFjYilcbiAgICByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdubyB3cml0ZWNiIGluIFRyYW5zZm9ybSBjbGFzcycpKTtcblxuICB0cy53cml0ZWNodW5rID0gbnVsbDtcbiAgdHMud3JpdGVjYiA9IG51bGw7XG5cbiAgaWYgKGRhdGEgIT09IG51bGwgJiYgZGF0YSAhPT0gdW5kZWZpbmVkKVxuICAgIHN0cmVhbS5wdXNoKGRhdGEpO1xuXG4gIGlmIChjYilcbiAgICBjYihlcik7XG5cbiAgdmFyIHJzID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBycy5yZWFkaW5nID0gZmFsc2U7XG4gIGlmIChycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykge1xuICAgIHN0cmVhbS5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIFRyYW5zZm9ybShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUcmFuc2Zvcm0pKVxuICAgIHJldHVybiBuZXcgVHJhbnNmb3JtKG9wdGlvbnMpO1xuXG4gIER1cGxleC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlID0gbmV3IFRyYW5zZm9ybVN0YXRlKHRoaXMpO1xuXG4gIC8vIHdoZW4gdGhlIHdyaXRhYmxlIHNpZGUgZmluaXNoZXMsIHRoZW4gZmx1c2ggb3V0IGFueXRoaW5nIHJlbWFpbmluZy5cbiAgdmFyIHN0cmVhbSA9IHRoaXM7XG5cbiAgLy8gc3RhcnQgb3V0IGFza2luZyBmb3IgYSByZWFkYWJsZSBldmVudCBvbmNlIGRhdGEgaXMgdHJhbnNmb3JtZWQuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAvLyB3ZSBoYXZlIGltcGxlbWVudGVkIHRoZSBfcmVhZCBtZXRob2QsIGFuZCBkb25lIHRoZSBvdGhlciB0aGluZ3NcbiAgLy8gdGhhdCBSZWFkYWJsZSB3YW50cyBiZWZvcmUgdGhlIGZpcnN0IF9yZWFkIGNhbGwsIHNvIHVuc2V0IHRoZVxuICAvLyBzeW5jIGd1YXJkIGZsYWcuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuc3luYyA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgIHRoaXMuX3RyYW5zZm9ybSA9IG9wdGlvbnMudHJhbnNmb3JtO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZsdXNoID09PSAnZnVuY3Rpb24nKVxuICAgICAgdGhpcy5fZmx1c2ggPSBvcHRpb25zLmZsdXNoO1xuICB9XG5cbiAgdGhpcy5vbmNlKCdwcmVmaW5pc2gnLCBmdW5jdGlvbigpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuX2ZsdXNoID09PSAnZnVuY3Rpb24nKVxuICAgICAgdGhpcy5fZmx1c2goZnVuY3Rpb24oZXIpIHtcbiAgICAgICAgZG9uZShzdHJlYW0sIGVyKTtcbiAgICAgIH0pO1xuICAgIGVsc2VcbiAgICAgIGRvbmUoc3RyZWFtKTtcbiAgfSk7XG59XG5cblRyYW5zZm9ybS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZykge1xuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZS5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XG4gIHJldHVybiBEdXBsZXgucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCBjaHVuaywgZW5jb2RpbmcpO1xufTtcblxuLy8gVGhpcyBpcyB0aGUgcGFydCB3aGVyZSB5b3UgZG8gc3R1ZmYhXG4vLyBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uIGluIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyAnY2h1bmsnIGlzIGFuIGlucHV0IGNodW5rLlxuLy9cbi8vIENhbGwgYHB1c2gobmV3Q2h1bmspYCB0byBwYXNzIGFsb25nIHRyYW5zZm9ybWVkIG91dHB1dFxuLy8gdG8gdGhlIHJlYWRhYmxlIHNpZGUuICBZb3UgbWF5IGNhbGwgJ3B1c2gnIHplcm8gb3IgbW9yZSB0aW1lcy5cbi8vXG4vLyBDYWxsIGBjYihlcnIpYCB3aGVuIHlvdSBhcmUgZG9uZSB3aXRoIHRoaXMgY2h1bmsuICBJZiB5b3UgcGFzc1xuLy8gYW4gZXJyb3IsIHRoZW4gdGhhdCdsbCBwdXQgdGhlIGh1cnQgb24gdGhlIHdob2xlIG9wZXJhdGlvbi4gIElmIHlvdVxuLy8gbmV2ZXIgY2FsbCBjYigpLCB0aGVuIHlvdSdsbCBuZXZlciBnZXQgYW5vdGhlciBjaHVuay5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKTtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMud3JpdGVjYiA9IGNiO1xuICB0cy53cml0ZWNodW5rID0gY2h1bms7XG4gIHRzLndyaXRlZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgaWYgKCF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB2YXIgcnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICh0cy5uZWVkVHJhbnNmb3JtIHx8XG4gICAgICAgIHJzLm5lZWRSZWFkYWJsZSB8fFxuICAgICAgICBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKVxuICAgICAgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufTtcblxuLy8gRG9lc24ndCBtYXR0ZXIgd2hhdCB0aGUgYXJncyBhcmUgaGVyZS5cbi8vIF90cmFuc2Zvcm0gZG9lcyBhbGwgdGhlIHdvcmsuXG4vLyBUaGF0IHdlIGdvdCBoZXJlIG1lYW5zIHRoYXQgdGhlIHJlYWRhYmxlIHNpZGUgd2FudHMgbW9yZSBkYXRhLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uKG4pIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG5cbiAgaWYgKHRzLndyaXRlY2h1bmsgIT09IG51bGwgJiYgdHMud3JpdGVjYiAmJiAhdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdHMudHJhbnNmb3JtaW5nID0gdHJ1ZTtcbiAgICB0aGlzLl90cmFuc2Zvcm0odHMud3JpdGVjaHVuaywgdHMud3JpdGVlbmNvZGluZywgdHMuYWZ0ZXJUcmFuc2Zvcm0pO1xuICB9IGVsc2Uge1xuICAgIC8vIG1hcmsgdGhhdCB3ZSBuZWVkIGEgdHJhbnNmb3JtLCBzbyB0aGF0IGFueSBkYXRhIHRoYXQgY29tZXMgaW5cbiAgICAvLyB3aWxsIGdldCBwcm9jZXNzZWQsIG5vdyB0aGF0IHdlJ3ZlIGFza2VkIGZvciBpdC5cbiAgICB0cy5uZWVkVHJhbnNmb3JtID0gdHJ1ZTtcbiAgfVxufTtcblxuXG5mdW5jdGlvbiBkb25lKHN0cmVhbSwgZXIpIHtcbiAgaWYgKGVyKVxuICAgIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG5cbiAgLy8gaWYgdGhlcmUncyBub3RoaW5nIGluIHRoZSB3cml0ZSBidWZmZXIsIHRoZW4gdGhhdCBtZWFuc1xuICAvLyB0aGF0IG5vdGhpbmcgbW9yZSB3aWxsIGV2ZXIgYmUgcHJvdmlkZWRcbiAgdmFyIHdzID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgdHMgPSBzdHJlYW0uX3RyYW5zZm9ybVN0YXRlO1xuXG4gIGlmICh3cy5sZW5ndGgpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdjYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gd3MubGVuZ3RoICE9IDAnKTtcblxuICBpZiAodHMudHJhbnNmb3JtaW5nKVxuICAgIHRocm93IG5ldyBFcnJvcignY2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHN0aWxsIHRyYW5zZm9ybWluZycpO1xuXG4gIHJldHVybiBzdHJlYW0ucHVzaChudWxsKTtcbn1cbiIsIi8vIEEgYml0IHNpbXBsZXIgdGhhbiByZWFkYWJsZSBzdHJlYW1zLlxuLy8gSW1wbGVtZW50IGFuIGFzeW5jIC5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYiksIGFuZCBpdCdsbCBoYW5kbGUgYWxsXG4vLyB0aGUgZHJhaW4gZXZlbnQgZW1pc3Npb24gYW5kIGJ1ZmZlcmluZy5cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRhYmxlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHByb2Nlc3NOZXh0VGljayA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5Xcml0YWJsZS5Xcml0YWJsZVN0YXRlID0gV3JpdGFibGVTdGF0ZTtcblxuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBpbnRlcm5hbFV0aWwgPSB7XG4gIGRlcHJlY2F0ZTogcmVxdWlyZSgndXRpbC1kZXByZWNhdGUnKVxufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBTdHJlYW07XG4oZnVuY3Rpb24gKCl7dHJ5e1xuICBTdHJlYW0gPSByZXF1aXJlKCdzdCcgKyAncmVhbScpO1xufWNhdGNoKF8pe31maW5hbGx5e1xuICBpZiAoIVN0cmVhbSlcbiAgICBTdHJlYW0gPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG59fSgpKVxuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG5cbnV0aWwuaW5oZXJpdHMoV3JpdGFibGUsIFN0cmVhbSk7XG5cbmZ1bmN0aW9uIG5vcCgpIHt9XG5cbmZ1bmN0aW9uIFdyaXRlUmVxKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhpcy5jaHVuayA9IGNodW5rO1xuICB0aGlzLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHRoaXMuY2FsbGJhY2sgPSBjYjtcbiAgdGhpcy5uZXh0ID0gbnVsbDtcbn1cblxudmFyIER1cGxleDtcbmZ1bmN0aW9uIFdyaXRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnIHRvIGluZGljYXRlIHdoZXRoZXIgb3Igbm90IHRoaXMgc3RyZWFtXG4gIC8vIGNvbnRhaW5zIGJ1ZmZlcnMgb3Igb2JqZWN0cy5cbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG5cbiAgaWYgKHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleClcbiAgICB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLndyaXRhYmxlT2JqZWN0TW9kZTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggd3JpdGUoKSBzdGFydHMgcmV0dXJuaW5nIGZhbHNlXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgdGhhdCB3ZSBhbHdheXMgcmV0dXJuIGZhbHNlIGlmXG4gIC8vIHRoZSBlbnRpcmUgYnVmZmVyIGlzIG5vdCBmbHVzaGVkIGltbWVkaWF0ZWx5IG9uIHdyaXRlKClcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdmFyIGRlZmF1bHRId20gPSB0aGlzLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDtcbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gKGh3bSB8fCBod20gPT09IDApID8gaHdtIDogZGVmYXVsdEh3bTtcblxuICAvLyBjYXN0IHRvIGludHMuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IH5+dGhpcy5oaWdoV2F0ZXJNYXJrO1xuXG4gIHRoaXMubmVlZERyYWluID0gZmFsc2U7XG4gIC8vIGF0IHRoZSBzdGFydCBvZiBjYWxsaW5nIGVuZCgpXG4gIHRoaXMuZW5kaW5nID0gZmFsc2U7XG4gIC8vIHdoZW4gZW5kKCkgaGFzIGJlZW4gY2FsbGVkLCBhbmQgcmV0dXJuZWRcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICAvLyB3aGVuICdmaW5pc2gnIGlzIGVtaXR0ZWRcbiAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuXG4gIC8vIHNob3VsZCB3ZSBkZWNvZGUgc3RyaW5ncyBpbnRvIGJ1ZmZlcnMgYmVmb3JlIHBhc3NpbmcgdG8gX3dyaXRlP1xuICAvLyB0aGlzIGlzIGhlcmUgc28gdGhhdCBzb21lIG5vZGUtY29yZSBzdHJlYW1zIGNhbiBvcHRpbWl6ZSBzdHJpbmdcbiAgLy8gaGFuZGxpbmcgYXQgYSBsb3dlciBsZXZlbC5cbiAgdmFyIG5vRGVjb2RlID0gb3B0aW9ucy5kZWNvZGVTdHJpbmdzID09PSBmYWxzZTtcbiAgdGhpcy5kZWNvZGVTdHJpbmdzID0gIW5vRGVjb2RlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIG5vdCBhbiBhY3R1YWwgYnVmZmVyIHdlIGtlZXAgdHJhY2sgb2YsIGJ1dCBhIG1lYXN1cmVtZW50XG4gIC8vIG9mIGhvdyBtdWNoIHdlJ3JlIHdhaXRpbmcgdG8gZ2V0IHB1c2hlZCB0byBzb21lIHVuZGVybHlpbmdcbiAgLy8gc29ja2V0IG9yIGZpbGUuXG4gIHRoaXMubGVuZ3RoID0gMDtcblxuICAvLyBhIGZsYWcgdG8gc2VlIHdoZW4gd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBhIHdyaXRlLlxuICB0aGlzLndyaXRpbmcgPSBmYWxzZTtcblxuICAvLyB3aGVuIHRydWUgYWxsIHdyaXRlcyB3aWxsIGJlIGJ1ZmZlcmVkIHVudGlsIC51bmNvcmsoKSBjYWxsXG4gIHRoaXMuY29ya2VkID0gMDtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSxcbiAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZSBhbnlcbiAgLy8gYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3Qgd3JpdGUgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyBhIGZsYWcgdG8ga25vdyBpZiB3ZSdyZSBwcm9jZXNzaW5nIHByZXZpb3VzbHkgYnVmZmVyZWQgaXRlbXMsIHdoaWNoXG4gIC8vIG1heSBjYWxsIHRoZSBfd3JpdGUoKSBjYWxsYmFjayBpbiB0aGUgc2FtZSB0aWNrLCBzbyB0aGF0IHdlIGRvbid0XG4gIC8vIGVuZCB1cCBpbiBhbiBvdmVybGFwcGVkIG9ud3JpdGUgc2l0dWF0aW9uLlxuICB0aGlzLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcblxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCdzIHBhc3NlZCB0byBfd3JpdGUoY2h1bmssY2IpXG4gIHRoaXMub253cml0ZSA9IGZ1bmN0aW9uKGVyKSB7XG4gICAgb253cml0ZShzdHJlYW0sIGVyKTtcbiAgfTtcblxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCB0aGUgdXNlciBzdXBwbGllcyB0byB3cml0ZShjaHVuayxlbmNvZGluZyxjYilcbiAgdGhpcy53cml0ZWNiID0gbnVsbDtcblxuICAvLyB0aGUgYW1vdW50IHRoYXQgaXMgYmVpbmcgd3JpdHRlbiB3aGVuIF93cml0ZSBpcyBjYWxsZWQuXG4gIHRoaXMud3JpdGVsZW4gPSAwO1xuXG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgdGhpcy5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcblxuICAvLyBudW1iZXIgb2YgcGVuZGluZyB1c2VyLXN1cHBsaWVkIHdyaXRlIGNhbGxiYWNrc1xuICAvLyB0aGlzIG11c3QgYmUgMCBiZWZvcmUgJ2ZpbmlzaCcgY2FuIGJlIGVtaXR0ZWRcbiAgdGhpcy5wZW5kaW5nY2IgPSAwO1xuXG4gIC8vIGVtaXQgcHJlZmluaXNoIGlmIHRoZSBvbmx5IHRoaW5nIHdlJ3JlIHdhaXRpbmcgZm9yIGlzIF93cml0ZSBjYnNcbiAgLy8gVGhpcyBpcyByZWxldmFudCBmb3Igc3luY2hyb25vdXMgVHJhbnNmb3JtIHN0cmVhbXNcbiAgdGhpcy5wcmVmaW5pc2hlZCA9IGZhbHNlO1xuXG4gIC8vIFRydWUgaWYgdGhlIGVycm9yIHdhcyBhbHJlYWR5IGVtaXR0ZWQgYW5kIHNob3VsZCBub3QgYmUgdGhyb3duIGFnYWluXG4gIHRoaXMuZXJyb3JFbWl0dGVkID0gZmFsc2U7XG59XG5cbldyaXRhYmxlU3RhdGUucHJvdG90eXBlLmdldEJ1ZmZlciA9IGZ1bmN0aW9uIHdyaXRhYmxlU3RhdGVHZXRCdWZmZXIoKSB7XG4gIHZhciBjdXJyZW50ID0gdGhpcy5idWZmZXJlZFJlcXVlc3Q7XG4gIHZhciBvdXQgPSBbXTtcbiAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICBvdXQucHVzaChjdXJyZW50KTtcbiAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICB9XG4gIHJldHVybiBvdXQ7XG59O1xuXG4oZnVuY3Rpb24gKCl7dHJ5IHtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZVN0YXRlLnByb3RvdHlwZSwgJ2J1ZmZlcicsIHtcbiAgZ2V0OiBpbnRlcm5hbFV0aWwuZGVwcmVjYXRlKGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmdldEJ1ZmZlcigpO1xuICB9LCAnX3dyaXRhYmxlU3RhdGUuYnVmZmVyIGlzIGRlcHJlY2F0ZWQuIFVzZSBfd3JpdGFibGVTdGF0ZS5nZXRCdWZmZXIgJyArXG4gICAgICdpbnN0ZWFkLicpXG59KTtcbn1jYXRjaChfKXt9fSgpKTtcblxuXG52YXIgRHVwbGV4O1xuZnVuY3Rpb24gV3JpdGFibGUob3B0aW9ucykge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIC8vIFdyaXRhYmxlIGN0b3IgaXMgYXBwbGllZCB0byBEdXBsZXhlcywgdGhvdWdoIHRoZXkncmUgbm90XG4gIC8vIGluc3RhbmNlb2YgV3JpdGFibGUsIHRoZXkncmUgaW5zdGFuY2VvZiBSZWFkYWJsZS5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFdyaXRhYmxlKSAmJiAhKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKVxuICAgIHJldHVybiBuZXcgV3JpdGFibGUob3B0aW9ucyk7XG5cbiAgdGhpcy5fd3JpdGFibGVTdGF0ZSA9IG5ldyBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIGxlZ2FjeS5cbiAgdGhpcy53cml0YWJsZSA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGUgPT09ICdmdW5jdGlvbicpXG4gICAgICB0aGlzLl93cml0ZSA9IG9wdGlvbnMud3JpdGU7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGV2ID09PSAnZnVuY3Rpb24nKVxuICAgICAgdGhpcy5fd3JpdGV2ID0gb3B0aW9ucy53cml0ZXY7XG4gIH1cblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuLy8gT3RoZXJ3aXNlIHBlb3BsZSBjYW4gcGlwZSBXcml0YWJsZSBzdHJlYW1zLCB3aGljaCBpcyBqdXN0IHdyb25nLlxuV3JpdGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignQ2Fubm90IHBpcGUuIE5vdCByZWFkYWJsZS4nKSk7XG59O1xuXG5cbmZ1bmN0aW9uIHdyaXRlQWZ0ZXJFbmQoc3RyZWFtLCBjYikge1xuICB2YXIgZXIgPSBuZXcgRXJyb3IoJ3dyaXRlIGFmdGVyIGVuZCcpO1xuICAvLyBUT0RPOiBkZWZlciBlcnJvciBldmVudHMgY29uc2lzdGVudGx5IGV2ZXJ5d2hlcmUsIG5vdCBqdXN0IHRoZSBjYlxuICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIHByb2Nlc3NOZXh0VGljayhjYiwgZXIpO1xufVxuXG4vLyBJZiB3ZSBnZXQgc29tZXRoaW5nIHRoYXQgaXMgbm90IGEgYnVmZmVyLCBzdHJpbmcsIG51bGwsIG9yIHVuZGVmaW5lZCxcbi8vIGFuZCB3ZSdyZSBub3QgaW4gb2JqZWN0TW9kZSwgdGhlbiB0aGF0J3MgYW4gZXJyb3IuXG4vLyBPdGhlcndpc2Ugc3RyZWFtIGNodW5rcyBhcmUgYWxsIGNvbnNpZGVyZWQgdG8gYmUgb2YgbGVuZ3RoPTEsIGFuZCB0aGVcbi8vIHdhdGVybWFya3MgZGV0ZXJtaW5lIGhvdyBtYW55IG9iamVjdHMgdG8ga2VlcCBpbiB0aGUgYnVmZmVyLCByYXRoZXIgdGhhblxuLy8gaG93IG1hbnkgYnl0ZXMgb3IgY2hhcmFjdGVycy5cbmZ1bmN0aW9uIHZhbGlkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGNiKSB7XG4gIHZhciB2YWxpZCA9IHRydWU7XG5cbiAgaWYgKCEoQnVmZmVyLmlzQnVmZmVyKGNodW5rKSkgJiZcbiAgICAgIHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiZcbiAgICAgIGNodW5rICE9PSBudWxsICYmXG4gICAgICBjaHVuayAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIHZhciBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gICAgcHJvY2Vzc05leHRUaWNrKGNiLCBlcik7XG4gICAgdmFsaWQgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gdmFsaWQ7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHJldCA9IGZhbHNlO1xuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoY2h1bmspKVxuICAgIGVuY29kaW5nID0gJ2J1ZmZlcic7XG4gIGVsc2UgaWYgKCFlbmNvZGluZylcbiAgICBlbmNvZGluZyA9IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcblxuICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKVxuICAgIGNiID0gbm9wO1xuXG4gIGlmIChzdGF0ZS5lbmRlZClcbiAgICB3cml0ZUFmdGVyRW5kKHRoaXMsIGNiKTtcbiAgZWxzZSBpZiAodmFsaWRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGNiKSkge1xuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHJldCA9IHdyaXRlT3JCdWZmZXIodGhpcywgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5jb3JrID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgc3RhdGUuY29ya2VkKys7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUudW5jb3JrID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZC0tO1xuXG4gICAgaWYgKCFzdGF0ZS53cml0aW5nICYmXG4gICAgICAgICFzdGF0ZS5jb3JrZWQgJiZcbiAgICAgICAgIXN0YXRlLmZpbmlzaGVkICYmXG4gICAgICAgICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmXG4gICAgICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdClcbiAgICAgIGNsZWFyQnVmZmVyKHRoaXMsIHN0YXRlKTtcbiAgfVxufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnNldERlZmF1bHRFbmNvZGluZyA9IGZ1bmN0aW9uIHNldERlZmF1bHRFbmNvZGluZyhlbmNvZGluZykge1xuICAvLyBub2RlOjpQYXJzZUVuY29kaW5nKCkgcmVxdWlyZXMgbG93ZXIgY2FzZS5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpXG4gICAgZW5jb2RpbmcgPSBlbmNvZGluZy50b0xvd2VyQ2FzZSgpO1xuICBpZiAoIShbJ2hleCcsICd1dGY4JywgJ3V0Zi04JywgJ2FzY2lpJywgJ2JpbmFyeScsICdiYXNlNjQnLFxuJ3VjczInLCAndWNzLTInLCd1dGYxNmxlJywgJ3V0Zi0xNmxlJywgJ3JhdyddXG4uaW5kZXhPZigoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKSkgPiAtMSkpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKTtcbiAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZWZhdWx0RW5jb2RpbmcgPSBlbmNvZGluZztcbn07XG5cbmZ1bmN0aW9uIGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpIHtcbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmXG4gICAgICBzdGF0ZS5kZWNvZGVTdHJpbmdzICE9PSBmYWxzZSAmJlxuICAgICAgdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgIGNodW5rID0gbmV3IEJ1ZmZlcihjaHVuaywgZW5jb2RpbmcpO1xuICB9XG4gIHJldHVybiBjaHVuaztcbn1cblxuLy8gaWYgd2UncmUgYWxyZWFkeSB3cml0aW5nIHNvbWV0aGluZywgdGhlbiBqdXN0IHB1dCB0aGlzXG4vLyBpbiB0aGUgcXVldWUsIGFuZCB3YWl0IG91ciB0dXJuLiAgT3RoZXJ3aXNlLCBjYWxsIF93cml0ZVxuLy8gSWYgd2UgcmV0dXJuIGZhbHNlLCB0aGVuIHdlIG5lZWQgYSBkcmFpbiBldmVudCwgc28gc2V0IHRoYXQgZmxhZy5cbmZ1bmN0aW9uIHdyaXRlT3JCdWZmZXIoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjaHVuayA9IGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpO1xuXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoY2h1bmspKVxuICAgIGVuY29kaW5nID0gJ2J1ZmZlcic7XG4gIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcblxuICBzdGF0ZS5sZW5ndGggKz0gbGVuO1xuXG4gIHZhciByZXQgPSBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICAvLyB3ZSBtdXN0IGVuc3VyZSB0aGF0IHByZXZpb3VzIG5lZWREcmFpbiB3aWxsIG5vdCBiZSByZXNldCB0byBmYWxzZS5cbiAgaWYgKCFyZXQpXG4gICAgc3RhdGUubmVlZERyYWluID0gdHJ1ZTtcblxuICBpZiAoc3RhdGUud3JpdGluZyB8fCBzdGF0ZS5jb3JrZWQpIHtcbiAgICB2YXIgbGFzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG5ldyBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgICBpZiAobGFzdCkge1xuICAgICAgbGFzdC5uZXh0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgd3JpdGV2LCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgc3RhdGUud3JpdGVsZW4gPSBsZW47XG4gIHN0YXRlLndyaXRlY2IgPSBjYjtcbiAgc3RhdGUud3JpdGluZyA9IHRydWU7XG4gIHN0YXRlLnN5bmMgPSB0cnVlO1xuICBpZiAod3JpdGV2KVxuICAgIHN0cmVhbS5fd3JpdGV2KGNodW5rLCBzdGF0ZS5vbndyaXRlKTtcbiAgZWxzZVxuICAgIHN0cmVhbS5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBzdGF0ZS5vbndyaXRlKTtcbiAgc3RhdGUuc3luYyA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKSB7XG4gIC0tc3RhdGUucGVuZGluZ2NiO1xuICBpZiAoc3luYylcbiAgICBwcm9jZXNzTmV4dFRpY2soY2IsIGVyKTtcbiAgZWxzZVxuICAgIGNiKGVyKTtcblxuICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpIHtcbiAgc3RhdGUud3JpdGluZyA9IGZhbHNlO1xuICBzdGF0ZS53cml0ZWNiID0gbnVsbDtcbiAgc3RhdGUubGVuZ3RoIC09IHN0YXRlLndyaXRlbGVuO1xuICBzdGF0ZS53cml0ZWxlbiA9IDA7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGUoc3RyZWFtLCBlcikge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIHZhciBzeW5jID0gc3RhdGUuc3luYztcbiAgdmFyIGNiID0gc3RhdGUud3JpdGVjYjtcblxuICBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpO1xuXG4gIGlmIChlcilcbiAgICBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKTtcbiAgZWxzZSB7XG4gICAgLy8gQ2hlY2sgaWYgd2UncmUgYWN0dWFsbHkgcmVhZHkgdG8gZmluaXNoLCBidXQgZG9uJ3QgZW1pdCB5ZXRcbiAgICB2YXIgZmluaXNoZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcblxuICAgIGlmICghZmluaXNoZWQgJiZcbiAgICAgICAgIXN0YXRlLmNvcmtlZCAmJlxuICAgICAgICAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJlxuICAgICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIHtcbiAgICAgIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChzeW5jKSB7XG4gICAgICBwcm9jZXNzTmV4dFRpY2soYWZ0ZXJXcml0ZSwgc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYikge1xuICBpZiAoIWZpbmlzaGVkKVxuICAgIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKTtcbiAgc3RhdGUucGVuZGluZ2NiLS07XG4gIGNiKCk7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG4vLyBNdXN0IGZvcmNlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBvbiBuZXh0VGljaywgc28gdGhhdCB3ZSBkb24ndFxuLy8gZW1pdCAnZHJhaW4nIGJlZm9yZSB0aGUgd3JpdGUoKSBjb25zdW1lciBnZXRzIHRoZSAnZmFsc2UnIHJldHVyblxuLy8gdmFsdWUsIGFuZCBoYXMgYSBjaGFuY2UgdG8gYXR0YWNoIGEgJ2RyYWluJyBsaXN0ZW5lci5cbmZ1bmN0aW9uIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUubmVlZERyYWluKSB7XG4gICAgc3RhdGUubmVlZERyYWluID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2RyYWluJyk7XG4gIH1cbn1cblxuXG4vLyBpZiB0aGVyZSdzIHNvbWV0aGluZyBpbiB0aGUgYnVmZmVyIHdhaXRpbmcsIHRoZW4gcHJvY2VzcyBpdFxuZnVuY3Rpb24gY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSkge1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gdHJ1ZTtcbiAgdmFyIGVudHJ5ID0gc3RhdGUuYnVmZmVyZWRSZXF1ZXN0O1xuXG4gIGlmIChzdHJlYW0uX3dyaXRldiAmJiBlbnRyeSAmJiBlbnRyeS5uZXh0KSB7XG4gICAgLy8gRmFzdCBjYXNlLCB3cml0ZSBldmVyeXRoaW5nIHVzaW5nIF93cml0ZXYoKVxuICAgIHZhciBidWZmZXIgPSBbXTtcbiAgICB2YXIgY2JzID0gW107XG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICBjYnMucHVzaChlbnRyeS5jYWxsYmFjayk7XG4gICAgICBidWZmZXIucHVzaChlbnRyeSk7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgfVxuXG4gICAgLy8gY291bnQgdGhlIG9uZSB3ZSBhcmUgYWRkaW5nLCBhcyB3ZWxsLlxuICAgIC8vIFRPRE8oaXNhYWNzKSBjbGVhbiB0aGlzIHVwXG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB0cnVlLCBzdGF0ZS5sZW5ndGgsIGJ1ZmZlciwgJycsIGZ1bmN0aW9uKGVycikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgICAgIGNic1tpXShlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gQ2xlYXIgYnVmZmVyXG4gIH0gZWxzZSB7XG4gICAgLy8gU2xvdyBjYXNlLCB3cml0ZSBjaHVua3Mgb25lLWJ5LW9uZVxuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgdmFyIGNodW5rID0gZW50cnkuY2h1bms7XG4gICAgICB2YXIgZW5jb2RpbmcgPSBlbnRyeS5lbmNvZGluZztcbiAgICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgICAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gICAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgLy8gaWYgd2UgZGlkbid0IGNhbGwgdGhlIG9ud3JpdGUgaW1tZWRpYXRlbHksIHRoZW5cbiAgICAgIC8vIGl0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byB3YWl0IHVudGlsIGl0IGRvZXMuXG4gICAgICAvLyBhbHNvLCB0aGF0IG1lYW5zIHRoYXQgdGhlIGNodW5rIGFuZCBjYiBhcmUgY3VycmVudGx5XG4gICAgICAvLyBiZWluZyBwcm9jZXNzZWQsIHNvIG1vdmUgdGhlIGJ1ZmZlciBjb3VudGVyIHBhc3QgdGhlbS5cbiAgICAgIGlmIChzdGF0ZS53cml0aW5nKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlbnRyeSA9PT0gbnVsbClcbiAgICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB9XG4gIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IGVudHJ5O1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZXYgPSBudWxsO1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmICh0eXBlb2YgY2h1bmsgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGNodW5rO1xuICAgIGNodW5rID0gbnVsbDtcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoY2h1bmsgIT09IG51bGwgJiYgY2h1bmsgIT09IHVuZGVmaW5lZClcbiAgICB0aGlzLndyaXRlKGNodW5rLCBlbmNvZGluZyk7XG5cbiAgLy8gLmVuZCgpIGZ1bGx5IHVuY29ya3NcbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZCA9IDE7XG4gICAgdGhpcy51bmNvcmsoKTtcbiAgfVxuXG4gIC8vIGlnbm9yZSB1bm5lY2Vzc2FyeSBlbmQoKSBjYWxscy5cbiAgaWYgKCFzdGF0ZS5lbmRpbmcgJiYgIXN0YXRlLmZpbmlzaGVkKVxuICAgIGVuZFdyaXRhYmxlKHRoaXMsIHN0YXRlLCBjYik7XG59O1xuXG5cbmZ1bmN0aW9uIG5lZWRGaW5pc2goc3RhdGUpIHtcbiAgcmV0dXJuIChzdGF0ZS5lbmRpbmcgJiZcbiAgICAgICAgICBzdGF0ZS5sZW5ndGggPT09IDAgJiZcbiAgICAgICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPT09IG51bGwgJiZcbiAgICAgICAgICAhc3RhdGUuZmluaXNoZWQgJiZcbiAgICAgICAgICAhc3RhdGUud3JpdGluZyk7XG59XG5cbmZ1bmN0aW9uIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucHJlZmluaXNoZWQpIHtcbiAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIG5lZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcbiAgaWYgKG5lZWQpIHtcbiAgICBpZiAoc3RhdGUucGVuZGluZ2NiID09PSAwKSB7XG4gICAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG4gICAgICBzdGF0ZS5maW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgnZmluaXNoJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5lZWQ7XG59XG5cbmZ1bmN0aW9uIGVuZFdyaXRhYmxlKHN0cmVhbSwgc3RhdGUsIGNiKSB7XG4gIHN0YXRlLmVuZGluZyA9IHRydWU7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICBpZiAoY2IpIHtcbiAgICBpZiAoc3RhdGUuZmluaXNoZWQpXG4gICAgICBwcm9jZXNzTmV4dFRpY2soY2IpO1xuICAgIGVsc2VcbiAgICAgIHN0cmVhbS5vbmNlKCdmaW5pc2gnLCBjYik7XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYXJnKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXJnKTtcbiAgfVxuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoYXJnKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IEJ1ZmZlci5pc0J1ZmZlcjtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAoIXByb2Nlc3MudmVyc2lvbiB8fFxuICAgIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MC4nKSA9PT0gMCB8fFxuICAgIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MS4nKSA9PT0gMCAmJiBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjEuOC4nKSAhPT0gMCkge1xuICBtb2R1bGUuZXhwb3J0cyA9IG5leHRUaWNrO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBwcm9jZXNzLm5leHRUaWNrO1xufVxuXG5mdW5jdGlvbiBuZXh0VGljayhmbikge1xuICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gIHZhciBpID0gMDtcbiAgd2hpbGUgKGkgPCBhcmdzLmxlbmd0aCkge1xuICAgIGFyZ3NbaSsrXSA9IGFyZ3VtZW50c1tpXTtcbiAgfVxuICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGljaygpIHtcbiAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgfSk7XG59XG4iLCJcbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBkZXByZWNhdGU7XG5cbi8qKlxuICogTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbiAqIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS5ub0RlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS50aHJvd0RlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGRlcHJlY2F0ZWQgZnVuY3Rpb25zXG4gKiB3aWxsIHRocm93IGFuIEVycm9yIHdoZW4gaW52b2tlZC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLnRyYWNlRGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gZGVwcmVjYXRlZCBmdW5jdGlvbnNcbiAqIHdpbGwgaW52b2tlIGBjb25zb2xlLnRyYWNlKClgIGluc3RlYWQgb2YgYGNvbnNvbGUuZXJyb3IoKWAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSB0aGUgZnVuY3Rpb24gdG8gZGVwcmVjYXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gbXNnIC0gdGhlIHN0cmluZyB0byBwcmludCB0byB0aGUgY29uc29sZSB3aGVuIGBmbmAgaXMgaW52b2tlZFxuICogQHJldHVybnMge0Z1bmN0aW9ufSBhIG5ldyBcImRlcHJlY2F0ZWRcIiB2ZXJzaW9uIG9mIGBmbmBcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGVwcmVjYXRlIChmbiwgbXNnKSB7XG4gIGlmIChjb25maWcoJ25vRGVwcmVjYXRpb24nKSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKGNvbmZpZygndGhyb3dEZXByZWNhdGlvbicpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChjb25maWcoJ3RyYWNlRGVwcmVjYXRpb24nKSkge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4obXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGBsb2NhbFN0b3JhZ2VgIGZvciBib29sZWFuIHZhbHVlcyBmb3IgdGhlIGdpdmVuIGBuYW1lYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjb25maWcgKG5hbWUpIHtcbiAgLy8gYWNjZXNzaW5nIGdsb2JhbC5sb2NhbFN0b3JhZ2UgY2FuIHRyaWdnZXIgYSBET01FeGNlcHRpb24gaW4gc2FuZGJveGVkIGlmcmFtZXNcbiAgdHJ5IHtcbiAgICBpZiAoIWdsb2JhbC5sb2NhbFN0b3JhZ2UpIHJldHVybiBmYWxzZTtcbiAgfSBjYXRjaCAoXykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdmFsID0gZ2xvYmFsLmxvY2FsU3RvcmFnZVtuYW1lXTtcbiAgaWYgKG51bGwgPT0gdmFsKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBTdHJpbmcodmFsKS50b0xvd2VyQ2FzZSgpID09PSAndHJ1ZSc7XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzXCIpXG4iLCJ2YXIgU3RyZWFtID0gKGZ1bmN0aW9uICgpe1xuICB0cnkge1xuICAgIHJldHVybiByZXF1aXJlKCdzdCcgKyAncmVhbScpOyAvLyBoYWNrIHRvIGZpeCBhIGNpcmN1bGFyIGRlcGVuZGVuY3kgaXNzdWUgd2hlbiB1c2VkIHdpdGggYnJvd3NlcmlmeVxuICB9IGNhdGNoKF8pe31cbn0oKSk7XG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzJyk7XG5leHBvcnRzLlN0cmVhbSA9IFN0cmVhbSB8fCBleHBvcnRzO1xuZXhwb3J0cy5SZWFkYWJsZSA9IGV4cG9ydHM7XG5leHBvcnRzLldyaXRhYmxlID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV93cml0YWJsZS5qcycpO1xuZXhwb3J0cy5EdXBsZXggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX2R1cGxleC5qcycpO1xuZXhwb3J0cy5UcmFuc2Zvcm0gPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcycpO1xuZXhwb3J0cy5QYXNzVGhyb3VnaCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMnKTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzXCIpXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzXCIpXG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxubW9kdWxlLmV4cG9ydHMgPSBTdHJlYW07XG5cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmluaGVyaXRzKFN0cmVhbSwgRUUpO1xuU3RyZWFtLlJlYWRhYmxlID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLmpzJyk7XG5TdHJlYW0uV3JpdGFibGUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vd3JpdGFibGUuanMnKTtcblN0cmVhbS5EdXBsZXggPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vZHVwbGV4LmpzJyk7XG5TdHJlYW0uVHJhbnNmb3JtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qcycpO1xuU3RyZWFtLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzJyk7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuNC54XG5TdHJlYW0uU3RyZWFtID0gU3RyZWFtO1xuXG5cblxuLy8gb2xkLXN0eWxlIHN0cmVhbXMuICBOb3RlIHRoYXQgdGhlIHBpcGUgbWV0aG9kICh0aGUgb25seSByZWxldmFudFxuLy8gcGFydCBvZiB0aGlzIGNsYXNzKSBpcyBvdmVycmlkZGVuIGluIHRoZSBSZWFkYWJsZSBjbGFzcy5cblxuZnVuY3Rpb24gU3RyZWFtKCkge1xuICBFRS5jYWxsKHRoaXMpO1xufVxuXG5TdHJlYW0ucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbihkZXN0LCBvcHRpb25zKSB7XG4gIHZhciBzb3VyY2UgPSB0aGlzO1xuXG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGlmIChkZXN0LndyaXRhYmxlKSB7XG4gICAgICBpZiAoZmFsc2UgPT09IGRlc3Qud3JpdGUoY2h1bmspICYmIHNvdXJjZS5wYXVzZSkge1xuICAgICAgICBzb3VyY2UucGF1c2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzb3VyY2Uub24oJ2RhdGEnLCBvbmRhdGEpO1xuXG4gIGZ1bmN0aW9uIG9uZHJhaW4oKSB7XG4gICAgaWYgKHNvdXJjZS5yZWFkYWJsZSAmJiBzb3VyY2UucmVzdW1lKSB7XG4gICAgICBzb3VyY2UucmVzdW1lKCk7XG4gICAgfVxuICB9XG5cbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICAvLyBJZiB0aGUgJ2VuZCcgb3B0aW9uIGlzIG5vdCBzdXBwbGllZCwgZGVzdC5lbmQoKSB3aWxsIGJlIGNhbGxlZCB3aGVuXG4gIC8vIHNvdXJjZSBnZXRzIHRoZSAnZW5kJyBvciAnY2xvc2UnIGV2ZW50cy4gIE9ubHkgZGVzdC5lbmQoKSBvbmNlLlxuICBpZiAoIWRlc3QuX2lzU3RkaW8gJiYgKCFvcHRpb25zIHx8IG9wdGlvbnMuZW5kICE9PSBmYWxzZSkpIHtcbiAgICBzb3VyY2Uub24oJ2VuZCcsIG9uZW5kKTtcbiAgICBzb3VyY2Uub24oJ2Nsb3NlJywgb25jbG9zZSk7XG4gIH1cblxuICB2YXIgZGlkT25FbmQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgaWYgKGRpZE9uRW5kKSByZXR1cm47XG4gICAgZGlkT25FbmQgPSB0cnVlO1xuXG4gICAgZGVzdC5lbmQoKTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBpZiAoZGlkT25FbmQpIHJldHVybjtcbiAgICBkaWRPbkVuZCA9IHRydWU7XG5cbiAgICBpZiAodHlwZW9mIGRlc3QuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgZGVzdC5kZXN0cm95KCk7XG4gIH1cblxuICAvLyBkb24ndCBsZWF2ZSBkYW5nbGluZyBwaXBlcyB3aGVuIHRoZXJlIGFyZSBlcnJvcnMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBjbGVhbnVwKCk7XG4gICAgaWYgKEVFLmxpc3RlbmVyQ291bnQodGhpcywgJ2Vycm9yJykgPT09IDApIHtcbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgc3RyZWFtIGVycm9yIGluIHBpcGUuXG4gICAgfVxuICB9XG5cbiAgc291cmNlLm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuICBkZXN0Lm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuXG4gIC8vIHJlbW92ZSBhbGwgdGhlIGV2ZW50IGxpc3RlbmVycyB0aGF0IHdlcmUgYWRkZWQuXG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIGNsZWFudXApO1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKTtcblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cCk7XG4gIH1cblxuICBzb3VyY2Uub24oJ2VuZCcsIGNsZWFudXApO1xuICBzb3VyY2Uub24oJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgZGVzdC5vbignY2xvc2UnLCBjbGVhbnVwKTtcblxuICBkZXN0LmVtaXQoJ3BpcGUnLCBzb3VyY2UpO1xuXG4gIC8vIEFsbG93IGZvciB1bml4LWxpa2UgdXNhZ2U6IEEucGlwZShCKS5waXBlKEMpXG4gIHJldHVybiBkZXN0O1xufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuXG52YXIgaXNCdWZmZXJFbmNvZGluZyA9IEJ1ZmZlci5pc0VuY29kaW5nXG4gIHx8IGZ1bmN0aW9uKGVuY29kaW5nKSB7XG4gICAgICAgc3dpdGNoIChlbmNvZGluZyAmJiBlbmNvZGluZy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICBjYXNlICdoZXgnOiBjYXNlICd1dGY4JzogY2FzZSAndXRmLTgnOiBjYXNlICdhc2NpaSc6IGNhc2UgJ2JpbmFyeSc6IGNhc2UgJ2Jhc2U2NCc6IGNhc2UgJ3VjczInOiBjYXNlICd1Y3MtMic6IGNhc2UgJ3V0ZjE2bGUnOiBjYXNlICd1dGYtMTZsZSc6IGNhc2UgJ3Jhdyc6IHJldHVybiB0cnVlO1xuICAgICAgICAgZGVmYXVsdDogcmV0dXJuIGZhbHNlO1xuICAgICAgIH1cbiAgICAgfVxuXG5cbmZ1bmN0aW9uIGFzc2VydEVuY29kaW5nKGVuY29kaW5nKSB7XG4gIGlmIChlbmNvZGluZyAmJiAhaXNCdWZmZXJFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZyk7XG4gIH1cbn1cblxuLy8gU3RyaW5nRGVjb2RlciBwcm92aWRlcyBhbiBpbnRlcmZhY2UgZm9yIGVmZmljaWVudGx5IHNwbGl0dGluZyBhIHNlcmllcyBvZlxuLy8gYnVmZmVycyBpbnRvIGEgc2VyaWVzIG9mIEpTIHN0cmluZ3Mgd2l0aG91dCBicmVha2luZyBhcGFydCBtdWx0aS1ieXRlXG4vLyBjaGFyYWN0ZXJzLiBDRVNVLTggaXMgaGFuZGxlZCBhcyBwYXJ0IG9mIHRoZSBVVEYtOCBlbmNvZGluZy5cbi8vXG4vLyBAVE9ETyBIYW5kbGluZyBhbGwgZW5jb2RpbmdzIGluc2lkZSBhIHNpbmdsZSBvYmplY3QgbWFrZXMgaXQgdmVyeSBkaWZmaWN1bHRcbi8vIHRvIHJlYXNvbiBhYm91dCB0aGlzIGNvZGUsIHNvIGl0IHNob3VsZCBiZSBzcGxpdCB1cCBpbiB0aGUgZnV0dXJlLlxuLy8gQFRPRE8gVGhlcmUgc2hvdWxkIGJlIGEgdXRmOC1zdHJpY3QgZW5jb2RpbmcgdGhhdCByZWplY3RzIGludmFsaWQgVVRGLTggY29kZVxuLy8gcG9pbnRzIGFzIHVzZWQgYnkgQ0VTVS04LlxudmFyIFN0cmluZ0RlY29kZXIgPSBleHBvcnRzLlN0cmluZ0RlY29kZXIgPSBmdW5jdGlvbihlbmNvZGluZykge1xuICB0aGlzLmVuY29kaW5nID0gKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9bLV9dLywgJycpO1xuICBhc3NlcnRFbmNvZGluZyhlbmNvZGluZyk7XG4gIHN3aXRjaCAodGhpcy5lbmNvZGluZykge1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgLy8gQ0VTVS04IHJlcHJlc2VudHMgZWFjaCBvZiBTdXJyb2dhdGUgUGFpciBieSAzLWJ5dGVzXG4gICAgICB0aGlzLnN1cnJvZ2F0ZVNpemUgPSAzO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICAvLyBVVEYtMTYgcmVwcmVzZW50cyBlYWNoIG9mIFN1cnJvZ2F0ZSBQYWlyIGJ5IDItYnl0ZXNcbiAgICAgIHRoaXMuc3Vycm9nYXRlU2l6ZSA9IDI7XG4gICAgICB0aGlzLmRldGVjdEluY29tcGxldGVDaGFyID0gdXRmMTZEZXRlY3RJbmNvbXBsZXRlQ2hhcjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAvLyBCYXNlLTY0IHN0b3JlcyAzIGJ5dGVzIGluIDQgY2hhcnMsIGFuZCBwYWRzIHRoZSByZW1haW5kZXIuXG4gICAgICB0aGlzLnN1cnJvZ2F0ZVNpemUgPSAzO1xuICAgICAgdGhpcy5kZXRlY3RJbmNvbXBsZXRlQ2hhciA9IGJhc2U2NERldGVjdEluY29tcGxldGVDaGFyO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRoaXMud3JpdGUgPSBwYXNzVGhyb3VnaFdyaXRlO1xuICAgICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRW5vdWdoIHNwYWNlIHRvIHN0b3JlIGFsbCBieXRlcyBvZiBhIHNpbmdsZSBjaGFyYWN0ZXIuIFVURi04IG5lZWRzIDRcbiAgLy8gYnl0ZXMsIGJ1dCBDRVNVLTggbWF5IHJlcXVpcmUgdXAgdG8gNiAoMyBieXRlcyBwZXIgc3Vycm9nYXRlKS5cbiAgdGhpcy5jaGFyQnVmZmVyID0gbmV3IEJ1ZmZlcig2KTtcbiAgLy8gTnVtYmVyIG9mIGJ5dGVzIHJlY2VpdmVkIGZvciB0aGUgY3VycmVudCBpbmNvbXBsZXRlIG11bHRpLWJ5dGUgY2hhcmFjdGVyLlxuICB0aGlzLmNoYXJSZWNlaXZlZCA9IDA7XG4gIC8vIE51bWJlciBvZiBieXRlcyBleHBlY3RlZCBmb3IgdGhlIGN1cnJlbnQgaW5jb21wbGV0ZSBtdWx0aS1ieXRlIGNoYXJhY3Rlci5cbiAgdGhpcy5jaGFyTGVuZ3RoID0gMDtcbn07XG5cblxuLy8gd3JpdGUgZGVjb2RlcyB0aGUgZ2l2ZW4gYnVmZmVyIGFuZCByZXR1cm5zIGl0IGFzIEpTIHN0cmluZyB0aGF0IGlzXG4vLyBndWFyYW50ZWVkIHRvIG5vdCBjb250YWluIGFueSBwYXJ0aWFsIG11bHRpLWJ5dGUgY2hhcmFjdGVycy4gQW55IHBhcnRpYWxcbi8vIGNoYXJhY3RlciBmb3VuZCBhdCB0aGUgZW5kIG9mIHRoZSBidWZmZXIgaXMgYnVmZmVyZWQgdXAsIGFuZCB3aWxsIGJlXG4vLyByZXR1cm5lZCB3aGVuIGNhbGxpbmcgd3JpdGUgYWdhaW4gd2l0aCB0aGUgcmVtYWluaW5nIGJ5dGVzLlxuLy9cbi8vIE5vdGU6IENvbnZlcnRpbmcgYSBCdWZmZXIgY29udGFpbmluZyBhbiBvcnBoYW4gc3Vycm9nYXRlIHRvIGEgU3RyaW5nXG4vLyBjdXJyZW50bHkgd29ya3MsIGJ1dCBjb252ZXJ0aW5nIGEgU3RyaW5nIHRvIGEgQnVmZmVyICh2aWEgYG5ldyBCdWZmZXJgLCBvclxuLy8gQnVmZmVyI3dyaXRlKSB3aWxsIHJlcGxhY2UgaW5jb21wbGV0ZSBzdXJyb2dhdGVzIHdpdGggdGhlIHVuaWNvZGVcbi8vIHJlcGxhY2VtZW50IGNoYXJhY3Rlci4gU2VlIGh0dHBzOi8vY29kZXJldmlldy5jaHJvbWl1bS5vcmcvMTIxMTczMDA5LyAuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICB2YXIgY2hhclN0ciA9ICcnO1xuICAvLyBpZiBvdXIgbGFzdCB3cml0ZSBlbmRlZCB3aXRoIGFuIGluY29tcGxldGUgbXVsdGlieXRlIGNoYXJhY3RlclxuICB3aGlsZSAodGhpcy5jaGFyTGVuZ3RoKSB7XG4gICAgLy8gZGV0ZXJtaW5lIGhvdyBtYW55IHJlbWFpbmluZyBieXRlcyB0aGlzIGJ1ZmZlciBoYXMgdG8gb2ZmZXIgZm9yIHRoaXMgY2hhclxuICAgIHZhciBhdmFpbGFibGUgPSAoYnVmZmVyLmxlbmd0aCA+PSB0aGlzLmNoYXJMZW5ndGggLSB0aGlzLmNoYXJSZWNlaXZlZCkgP1xuICAgICAgICB0aGlzLmNoYXJMZW5ndGggLSB0aGlzLmNoYXJSZWNlaXZlZCA6XG4gICAgICAgIGJ1ZmZlci5sZW5ndGg7XG5cbiAgICAvLyBhZGQgdGhlIG5ldyBieXRlcyB0byB0aGUgY2hhciBidWZmZXJcbiAgICBidWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIHRoaXMuY2hhclJlY2VpdmVkLCAwLCBhdmFpbGFibGUpO1xuICAgIHRoaXMuY2hhclJlY2VpdmVkICs9IGF2YWlsYWJsZTtcblxuICAgIGlmICh0aGlzLmNoYXJSZWNlaXZlZCA8IHRoaXMuY2hhckxlbmd0aCkge1xuICAgICAgLy8gc3RpbGwgbm90IGVub3VnaCBjaGFycyBpbiB0aGlzIGJ1ZmZlcj8gd2FpdCBmb3IgbW9yZSAuLi5cbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICAvLyByZW1vdmUgYnl0ZXMgYmVsb25naW5nIHRvIHRoZSBjdXJyZW50IGNoYXJhY3RlciBmcm9tIHRoZSBidWZmZXJcbiAgICBidWZmZXIgPSBidWZmZXIuc2xpY2UoYXZhaWxhYmxlLCBidWZmZXIubGVuZ3RoKTtcblxuICAgIC8vIGdldCB0aGUgY2hhcmFjdGVyIHRoYXQgd2FzIHNwbGl0XG4gICAgY2hhclN0ciA9IHRoaXMuY2hhckJ1ZmZlci5zbGljZSgwLCB0aGlzLmNoYXJMZW5ndGgpLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpO1xuXG4gICAgLy8gQ0VTVS04OiBsZWFkIHN1cnJvZ2F0ZSAoRDgwMC1EQkZGKSBpcyBhbHNvIHRoZSBpbmNvbXBsZXRlIGNoYXJhY3RlclxuICAgIHZhciBjaGFyQ29kZSA9IGNoYXJTdHIuY2hhckNvZGVBdChjaGFyU3RyLmxlbmd0aCAtIDEpO1xuICAgIGlmIChjaGFyQ29kZSA+PSAweEQ4MDAgJiYgY2hhckNvZGUgPD0gMHhEQkZGKSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggKz0gdGhpcy5zdXJyb2dhdGVTaXplO1xuICAgICAgY2hhclN0ciA9ICcnO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHRoaXMuY2hhclJlY2VpdmVkID0gdGhpcy5jaGFyTGVuZ3RoID0gMDtcblxuICAgIC8vIGlmIHRoZXJlIGFyZSBubyBtb3JlIGJ5dGVzIGluIHRoaXMgYnVmZmVyLCBqdXN0IGVtaXQgb3VyIGNoYXJcbiAgICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGNoYXJTdHI7XG4gICAgfVxuICAgIGJyZWFrO1xuICB9XG5cbiAgLy8gZGV0ZXJtaW5lIGFuZCBzZXQgY2hhckxlbmd0aCAvIGNoYXJSZWNlaXZlZFxuICB0aGlzLmRldGVjdEluY29tcGxldGVDaGFyKGJ1ZmZlcik7XG5cbiAgdmFyIGVuZCA9IGJ1ZmZlci5sZW5ndGg7XG4gIGlmICh0aGlzLmNoYXJMZW5ndGgpIHtcbiAgICAvLyBidWZmZXIgdGhlIGluY29tcGxldGUgY2hhcmFjdGVyIGJ5dGVzIHdlIGdvdFxuICAgIGJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgMCwgYnVmZmVyLmxlbmd0aCAtIHRoaXMuY2hhclJlY2VpdmVkLCBlbmQpO1xuICAgIGVuZCAtPSB0aGlzLmNoYXJSZWNlaXZlZDtcbiAgfVxuXG4gIGNoYXJTdHIgKz0gYnVmZmVyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIGVuZCk7XG5cbiAgdmFyIGVuZCA9IGNoYXJTdHIubGVuZ3RoIC0gMTtcbiAgdmFyIGNoYXJDb2RlID0gY2hhclN0ci5jaGFyQ29kZUF0KGVuZCk7XG4gIC8vIENFU1UtODogbGVhZCBzdXJyb2dhdGUgKEQ4MDAtREJGRikgaXMgYWxzbyB0aGUgaW5jb21wbGV0ZSBjaGFyYWN0ZXJcbiAgaWYgKGNoYXJDb2RlID49IDB4RDgwMCAmJiBjaGFyQ29kZSA8PSAweERCRkYpIHtcbiAgICB2YXIgc2l6ZSA9IHRoaXMuc3Vycm9nYXRlU2l6ZTtcbiAgICB0aGlzLmNoYXJMZW5ndGggKz0gc2l6ZTtcbiAgICB0aGlzLmNoYXJSZWNlaXZlZCArPSBzaXplO1xuICAgIHRoaXMuY2hhckJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgc2l6ZSwgMCwgc2l6ZSk7XG4gICAgYnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCAwLCAwLCBzaXplKTtcbiAgICByZXR1cm4gY2hhclN0ci5zdWJzdHJpbmcoMCwgZW5kKTtcbiAgfVxuXG4gIC8vIG9yIGp1c3QgZW1pdCB0aGUgY2hhclN0clxuICByZXR1cm4gY2hhclN0cjtcbn07XG5cbi8vIGRldGVjdEluY29tcGxldGVDaGFyIGRldGVybWluZXMgaWYgdGhlcmUgaXMgYW4gaW5jb21wbGV0ZSBVVEYtOCBjaGFyYWN0ZXIgYXRcbi8vIHRoZSBlbmQgb2YgdGhlIGdpdmVuIGJ1ZmZlci4gSWYgc28sIGl0IHNldHMgdGhpcy5jaGFyTGVuZ3RoIHRvIHRoZSBieXRlXG4vLyBsZW5ndGggdGhhdCBjaGFyYWN0ZXIsIGFuZCBzZXRzIHRoaXMuY2hhclJlY2VpdmVkIHRvIHRoZSBudW1iZXIgb2YgYnl0ZXNcbi8vIHRoYXQgYXJlIGF2YWlsYWJsZSBmb3IgdGhpcyBjaGFyYWN0ZXIuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5kZXRlY3RJbmNvbXBsZXRlQ2hhciA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICAvLyBkZXRlcm1pbmUgaG93IG1hbnkgYnl0ZXMgd2UgaGF2ZSB0byBjaGVjayBhdCB0aGUgZW5kIG9mIHRoaXMgYnVmZmVyXG4gIHZhciBpID0gKGJ1ZmZlci5sZW5ndGggPj0gMykgPyAzIDogYnVmZmVyLmxlbmd0aDtcblxuICAvLyBGaWd1cmUgb3V0IGlmIG9uZSBvZiB0aGUgbGFzdCBpIGJ5dGVzIG9mIG91ciBidWZmZXIgYW5ub3VuY2VzIGFuXG4gIC8vIGluY29tcGxldGUgY2hhci5cbiAgZm9yICg7IGkgPiAwOyBpLS0pIHtcbiAgICB2YXIgYyA9IGJ1ZmZlcltidWZmZXIubGVuZ3RoIC0gaV07XG5cbiAgICAvLyBTZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9VVEYtOCNEZXNjcmlwdGlvblxuXG4gICAgLy8gMTEwWFhYWFhcbiAgICBpZiAoaSA9PSAxICYmIGMgPj4gNSA9PSAweDA2KSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggPSAyO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gMTExMFhYWFhcbiAgICBpZiAoaSA8PSAyICYmIGMgPj4gNCA9PSAweDBFKSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggPSAzO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gMTExMTBYWFhcbiAgICBpZiAoaSA8PSAzICYmIGMgPj4gMyA9PSAweDFFKSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggPSA0O1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHRoaXMuY2hhclJlY2VpdmVkID0gaTtcbn07XG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICB2YXIgcmVzID0gJyc7XG4gIGlmIChidWZmZXIgJiYgYnVmZmVyLmxlbmd0aClcbiAgICByZXMgPSB0aGlzLndyaXRlKGJ1ZmZlcik7XG5cbiAgaWYgKHRoaXMuY2hhclJlY2VpdmVkKSB7XG4gICAgdmFyIGNyID0gdGhpcy5jaGFyUmVjZWl2ZWQ7XG4gICAgdmFyIGJ1ZiA9IHRoaXMuY2hhckJ1ZmZlcjtcbiAgICB2YXIgZW5jID0gdGhpcy5lbmNvZGluZztcbiAgICByZXMgKz0gYnVmLnNsaWNlKDAsIGNyKS50b1N0cmluZyhlbmMpO1xuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cbmZ1bmN0aW9uIHBhc3NUaHJvdWdoV3JpdGUoYnVmZmVyKSB7XG4gIHJldHVybiBidWZmZXIudG9TdHJpbmcodGhpcy5lbmNvZGluZyk7XG59XG5cbmZ1bmN0aW9uIHV0ZjE2RGV0ZWN0SW5jb21wbGV0ZUNoYXIoYnVmZmVyKSB7XG4gIHRoaXMuY2hhclJlY2VpdmVkID0gYnVmZmVyLmxlbmd0aCAlIDI7XG4gIHRoaXMuY2hhckxlbmd0aCA9IHRoaXMuY2hhclJlY2VpdmVkID8gMiA6IDA7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NERldGVjdEluY29tcGxldGVDaGFyKGJ1ZmZlcikge1xuICB0aGlzLmNoYXJSZWNlaXZlZCA9IGJ1ZmZlci5sZW5ndGggJSAzO1xuICB0aGlzLmNoYXJMZW5ndGggPSB0aGlzLmNoYXJSZWNlaXZlZCA/IDMgOiAwO1xufVxuIiwidmFyIGluZGV4T2YgPSByZXF1aXJlKCdpbmRleG9mJyk7XG5cbnZhciBPYmplY3Rfa2V5cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICBpZiAoT2JqZWN0LmtleXMpIHJldHVybiBPYmplY3Qua2V5cyhvYmopXG4gICAgZWxzZSB7XG4gICAgICAgIHZhciByZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9iaikgcmVzLnB1c2goa2V5KVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbn07XG5cbnZhciBmb3JFYWNoID0gZnVuY3Rpb24gKHhzLCBmbikge1xuICAgIGlmICh4cy5mb3JFYWNoKSByZXR1cm4geHMuZm9yRWFjaChmbilcbiAgICBlbHNlIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZm4oeHNbaV0sIGksIHhzKTtcbiAgICB9XG59O1xuXG52YXIgZGVmaW5lUHJvcCA9IChmdW5jdGlvbigpIHtcbiAgICB0cnkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdfJywge30pO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24ob2JqLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgbmFtZSwge1xuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgfSBjYXRjaChlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihvYmosIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgICBvYmpbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfTtcbiAgICB9XG59KCkpO1xuXG52YXIgZ2xvYmFscyA9IFsnQXJyYXknLCAnQm9vbGVhbicsICdEYXRlJywgJ0Vycm9yJywgJ0V2YWxFcnJvcicsICdGdW5jdGlvbicsXG4nSW5maW5pdHknLCAnSlNPTicsICdNYXRoJywgJ05hTicsICdOdW1iZXInLCAnT2JqZWN0JywgJ1JhbmdlRXJyb3InLFxuJ1JlZmVyZW5jZUVycm9yJywgJ1JlZ0V4cCcsICdTdHJpbmcnLCAnU3ludGF4RXJyb3InLCAnVHlwZUVycm9yJywgJ1VSSUVycm9yJyxcbidkZWNvZGVVUkknLCAnZGVjb2RlVVJJQ29tcG9uZW50JywgJ2VuY29kZVVSSScsICdlbmNvZGVVUklDb21wb25lbnQnLCAnZXNjYXBlJyxcbidldmFsJywgJ2lzRmluaXRlJywgJ2lzTmFOJywgJ3BhcnNlRmxvYXQnLCAncGFyc2VJbnQnLCAndW5kZWZpbmVkJywgJ3VuZXNjYXBlJ107XG5cbmZ1bmN0aW9uIENvbnRleHQoKSB7fVxuQ29udGV4dC5wcm90b3R5cGUgPSB7fTtcblxudmFyIFNjcmlwdCA9IGV4cG9ydHMuU2NyaXB0ID0gZnVuY3Rpb24gTm9kZVNjcmlwdCAoY29kZSkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTY3JpcHQpKSByZXR1cm4gbmV3IFNjcmlwdChjb2RlKTtcbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xufTtcblxuU2NyaXB0LnByb3RvdHlwZS5ydW5JbkNvbnRleHQgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIGlmICghKGNvbnRleHQgaW5zdGFuY2VvZiBDb250ZXh0KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwibmVlZHMgYSAnY29udGV4dCcgYXJndW1lbnQuXCIpO1xuICAgIH1cbiAgICBcbiAgICB2YXIgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgaWYgKCFpZnJhbWUuc3R5bGUpIGlmcmFtZS5zdHlsZSA9IHt9O1xuICAgIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIFxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgICBcbiAgICB2YXIgd2luID0gaWZyYW1lLmNvbnRlbnRXaW5kb3c7XG4gICAgdmFyIHdFdmFsID0gd2luLmV2YWwsIHdFeGVjU2NyaXB0ID0gd2luLmV4ZWNTY3JpcHQ7XG5cbiAgICBpZiAoIXdFdmFsICYmIHdFeGVjU2NyaXB0KSB7XG4gICAgICAgIC8vIHdpbi5ldmFsKCkgbWFnaWNhbGx5IGFwcGVhcnMgd2hlbiB0aGlzIGlzIGNhbGxlZCBpbiBJRTpcbiAgICAgICAgd0V4ZWNTY3JpcHQuY2FsbCh3aW4sICdudWxsJyk7XG4gICAgICAgIHdFdmFsID0gd2luLmV2YWw7XG4gICAgfVxuICAgIFxuICAgIGZvckVhY2goT2JqZWN0X2tleXMoY29udGV4dCksIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgd2luW2tleV0gPSBjb250ZXh0W2tleV07XG4gICAgfSk7XG4gICAgZm9yRWFjaChnbG9iYWxzLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmIChjb250ZXh0W2tleV0pIHtcbiAgICAgICAgICAgIHdpbltrZXldID0gY29udGV4dFtrZXldO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgdmFyIHdpbktleXMgPSBPYmplY3Rfa2V5cyh3aW4pO1xuXG4gICAgdmFyIHJlcyA9IHdFdmFsLmNhbGwod2luLCB0aGlzLmNvZGUpO1xuICAgIFxuICAgIGZvckVhY2goT2JqZWN0X2tleXMod2luKSwgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAvLyBBdm9pZCBjb3B5aW5nIGNpcmN1bGFyIG9iamVjdHMgbGlrZSBgdG9wYCBhbmQgYHdpbmRvd2AgYnkgb25seVxuICAgICAgICAvLyB1cGRhdGluZyBleGlzdGluZyBjb250ZXh0IHByb3BlcnRpZXMgb3IgbmV3IHByb3BlcnRpZXMgaW4gdGhlIGB3aW5gXG4gICAgICAgIC8vIHRoYXQgd2FzIG9ubHkgaW50cm9kdWNlZCBhZnRlciB0aGUgZXZhbC5cbiAgICAgICAgaWYgKGtleSBpbiBjb250ZXh0IHx8IGluZGV4T2Yod2luS2V5cywga2V5KSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnRleHRba2V5XSA9IHdpbltrZXldO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBmb3JFYWNoKGdsb2JhbHMsIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKCEoa2V5IGluIGNvbnRleHQpKSB7XG4gICAgICAgICAgICBkZWZpbmVQcm9wKGNvbnRleHQsIGtleSwgd2luW2tleV0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICAgIFxuICAgIHJldHVybiByZXM7XG59O1xuXG5TY3JpcHQucHJvdG90eXBlLnJ1bkluVGhpc0NvbnRleHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGV2YWwodGhpcy5jb2RlKTsgLy8gbWF5YmUuLi5cbn07XG5cblNjcmlwdC5wcm90b3R5cGUucnVuSW5OZXdDb250ZXh0ID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICB2YXIgY3R4ID0gU2NyaXB0LmNyZWF0ZUNvbnRleHQoY29udGV4dCk7XG4gICAgdmFyIHJlcyA9IHRoaXMucnVuSW5Db250ZXh0KGN0eCk7XG5cbiAgICBmb3JFYWNoKE9iamVjdF9rZXlzKGN0eCksIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgY29udGV4dFtrZXldID0gY3R4W2tleV07XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzO1xufTtcblxuZm9yRWFjaChPYmplY3Rfa2V5cyhTY3JpcHQucHJvdG90eXBlKSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBleHBvcnRzW25hbWVdID0gU2NyaXB0W25hbWVdID0gZnVuY3Rpb24gKGNvZGUpIHtcbiAgICAgICAgdmFyIHMgPSBTY3JpcHQoY29kZSk7XG4gICAgICAgIHJldHVybiBzW25hbWVdLmFwcGx5KHMsIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gICAgfTtcbn0pO1xuXG5leHBvcnRzLmNyZWF0ZVNjcmlwdCA9IGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuU2NyaXB0KGNvZGUpO1xufTtcblxuZXhwb3J0cy5jcmVhdGVDb250ZXh0ID0gU2NyaXB0LmNyZWF0ZUNvbnRleHQgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHZhciBjb3B5ID0gbmV3IENvbnRleHQoKTtcbiAgICBpZih0eXBlb2YgY29udGV4dCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgZm9yRWFjaChPYmplY3Rfa2V5cyhjb250ZXh0KSwgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgY29weVtrZXldID0gY29udGV4dFtrZXldO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvcHk7XG59O1xuIiwiXG52YXIgaW5kZXhPZiA9IFtdLmluZGV4T2Y7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXJyLCBvYmope1xuICBpZiAoaW5kZXhPZikgcmV0dXJuIGFyci5pbmRleE9mKG9iaik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGFycltpXSA9PT0gb2JqKSByZXR1cm4gaTtcbiAgfVxuICByZXR1cm4gLTE7XG59OyIsIi8qIVxuICogWFJlZ0V4cC1BbGwgMy4wLjBcbiAqIDxodHRwOi8veHJlZ2V4cC5jb20vPlxuICogU3RldmVuIExldml0aGFuIChjKSAyMDEyLTIwMTUgTUlUIExpY2Vuc2VcbiAqL1xuXG4vLyBNb2R1bGUgc3lzdGVtcyBtYWdpYyBkYW5jZS4gRG9uJ3QgdXNlIHN0cmljdCBtb2RlIGZvciB0aGlzIGZ1bmN0aW9uLCBzbyBpdCBjYW4gYXNzaWduIHRvIGdsb2JhbC5cbjsoZnVuY3Rpb24ocm9vdCwgZGVmaW5pdGlvbikge1xuICAgIHZhciBzZWxmO1xuXG4gICAgLy8gUmVxdWlyZUpTXG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZGVmaW5lKGRlZmluaXRpb24pO1xuICAgIC8vIENvbW1vbkpTXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgc2VsZiA9IGRlZmluaXRpb24oKTtcbiAgICAgICAgLy8gVXNlIE5vZGUuanMncyBgbW9kdWxlLmV4cG9ydHNgLiBUaGlzIHN1cHBvcnRzIGJvdGggYHJlcXVpcmUoJ3hyZWdleHAnKWAgYW5kXG4gICAgICAgIC8vIGByZXF1aXJlKCd4cmVnZXhwJykuWFJlZ0V4cGBcbiAgICAgICAgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnID8gKG1vZHVsZS5leHBvcnRzID0gc2VsZikgOiBleHBvcnRzKS5YUmVnRXhwID0gc2VsZjtcbiAgICAvLyA8c2NyaXB0PlxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIENyZWF0ZSBnbG9iYWxcbiAgICAgICAgcm9vdC5YUmVnRXhwID0gZGVmaW5pdGlvbigpO1xuICAgIH1cbn0odGhpcywgZnVuY3Rpb24oKSB7XG5cbi8qIVxuICogWFJlZ0V4cCAzLjAuMFxuICogPGh0dHA6Ly94cmVnZXhwLmNvbS8+XG4gKiBTdGV2ZW4gTGV2aXRoYW4gKGMpIDIwMDctMjAxNSBNSVQgTGljZW5zZVxuICovXG5cbi8qKlxuICogWFJlZ0V4cCBwcm92aWRlcyBhdWdtZW50ZWQsIGV4dGVuc2libGUgcmVndWxhciBleHByZXNzaW9ucy4gWW91IGdldCBhZGRpdGlvbmFsIHJlZ2V4IHN5bnRheCBhbmRcbiAqIGZsYWdzLCBiZXlvbmQgd2hhdCBicm93c2VycyBzdXBwb3J0IG5hdGl2ZWx5LiBYUmVnRXhwIGlzIGFsc28gYSByZWdleCB1dGlsaXR5IGJlbHQgd2l0aCB0b29scyB0b1xuICogbWFrZSB5b3VyIGNsaWVudC1zaWRlIGdyZXBwaW5nIHNpbXBsZXIgYW5kIG1vcmUgcG93ZXJmdWwsIHdoaWxlIGZyZWVpbmcgeW91IGZyb20gcmVsYXRlZFxuICogY3Jvc3MtYnJvd3NlciBpbmNvbnNpc3RlbmNpZXMuXG4gKi9cbnZhciBYUmVnRXhwID0gKGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBQcml2YXRlIHZhcmlhYmxlc1xuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cbiAgICB2YXIgLy8gSW50ZXJuYWwgcmVmZXJlbmNlIHRvIHRoZSBgWFJlZ0V4cGAgb2JqZWN0XG4gICAgICAgIHNlbGYsXG4gICAgICAgIC8vIFByb3BlcnR5IG5hbWUgdXNlZCBmb3IgZXh0ZW5kZWQgcmVnZXggaW5zdGFuY2UgZGF0YVxuICAgICAgICBSRUdFWF9EQVRBID0gJ3hyZWdleHAnLFxuICAgICAgICAvLyBPcHRpb25hbCBmZWF0dXJlcyB0aGF0IGNhbiBiZSBpbnN0YWxsZWQgYW5kIHVuaW5zdGFsbGVkXG4gICAgICAgIGZlYXR1cmVzID0ge1xuICAgICAgICAgICAgYXN0cmFsOiBmYWxzZSxcbiAgICAgICAgICAgIG5hdGl2ZXM6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIC8vIE5hdGl2ZSBtZXRob2RzIHRvIHVzZSBhbmQgcmVzdG9yZSAoJ25hdGl2ZScgaXMgYW4gRVMzIHJlc2VydmVkIGtleXdvcmQpXG4gICAgICAgIG5hdGl2ID0ge1xuICAgICAgICAgICAgZXhlYzogUmVnRXhwLnByb3RvdHlwZS5leGVjLFxuICAgICAgICAgICAgdGVzdDogUmVnRXhwLnByb3RvdHlwZS50ZXN0LFxuICAgICAgICAgICAgbWF0Y2g6IFN0cmluZy5wcm90b3R5cGUubWF0Y2gsXG4gICAgICAgICAgICByZXBsYWNlOiBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2UsXG4gICAgICAgICAgICBzcGxpdDogU3RyaW5nLnByb3RvdHlwZS5zcGxpdFxuICAgICAgICB9LFxuICAgICAgICAvLyBTdG9yYWdlIGZvciBmaXhlZC9leHRlbmRlZCBuYXRpdmUgbWV0aG9kc1xuICAgICAgICBmaXhlZCA9IHt9LFxuICAgICAgICAvLyBTdG9yYWdlIGZvciByZWdleGVzIGNhY2hlZCBieSBgWFJlZ0V4cC5jYWNoZWBcbiAgICAgICAgcmVnZXhDYWNoZSA9IHt9LFxuICAgICAgICAvLyBTdG9yYWdlIGZvciBwYXR0ZXJuIGRldGFpbHMgY2FjaGVkIGJ5IHRoZSBgWFJlZ0V4cGAgY29uc3RydWN0b3JcbiAgICAgICAgcGF0dGVybkNhY2hlID0ge30sXG4gICAgICAgIC8vIFN0b3JhZ2UgZm9yIHJlZ2V4IHN5bnRheCB0b2tlbnMgYWRkZWQgaW50ZXJuYWxseSBvciBieSBgWFJlZ0V4cC5hZGRUb2tlbmBcbiAgICAgICAgdG9rZW5zID0gW10sXG4gICAgICAgIC8vIFRva2VuIHNjb3Blc1xuICAgICAgICBkZWZhdWx0U2NvcGUgPSAnZGVmYXVsdCcsXG4gICAgICAgIGNsYXNzU2NvcGUgPSAnY2xhc3MnLFxuICAgICAgICAvLyBSZWdleGVzIHRoYXQgbWF0Y2ggbmF0aXZlIHJlZ2V4IHN5bnRheCwgaW5jbHVkaW5nIG9jdGFsc1xuICAgICAgICBuYXRpdmVUb2tlbnMgPSB7XG4gICAgICAgICAgICAvLyBBbnkgbmF0aXZlIG11bHRpY2hhcmFjdGVyIHRva2VuIGluIGRlZmF1bHQgc2NvcGUsIG9yIGFueSBzaW5nbGUgY2hhcmFjdGVyXG4gICAgICAgICAgICAnZGVmYXVsdCc6IC9cXFxcKD86MCg/OlswLTNdWzAtN117MCwyfXxbNC03XVswLTddPyk/fFsxLTldXFxkKnx4W1xcZEEtRmEtZl17Mn18dSg/OltcXGRBLUZhLWZdezR9fHtbXFxkQS1GYS1mXSt9KXxjW0EtWmEtel18W1xcc1xcU10pfFxcKFxcP1s6PSFdfFs/KitdXFw/fHtcXGQrKD86LFxcZCopP31cXD8/fFtcXHNcXFNdLyxcbiAgICAgICAgICAgIC8vIEFueSBuYXRpdmUgbXVsdGljaGFyYWN0ZXIgdG9rZW4gaW4gY2hhcmFjdGVyIGNsYXNzIHNjb3BlLCBvciBhbnkgc2luZ2xlIGNoYXJhY3RlclxuICAgICAgICAgICAgJ2NsYXNzJzogL1xcXFwoPzpbMC0zXVswLTddezAsMn18WzQtN11bMC03XT98eFtcXGRBLUZhLWZdezJ9fHUoPzpbXFxkQS1GYS1mXXs0fXx7W1xcZEEtRmEtZl0rfSl8Y1tBLVphLXpdfFtcXHNcXFNdKXxbXFxzXFxTXS9cbiAgICAgICAgfSxcbiAgICAgICAgLy8gQW55IGJhY2tyZWZlcmVuY2Ugb3IgZG9sbGFyLXByZWZpeGVkIGNoYXJhY3RlciBpbiByZXBsYWNlbWVudCBzdHJpbmdzXG4gICAgICAgIHJlcGxhY2VtZW50VG9rZW4gPSAvXFwkKD86eyhbXFx3JF0rKX18KFxcZFxcZD98W1xcc1xcU10pKS9nLFxuICAgICAgICAvLyBDaGVjayBmb3IgY29ycmVjdCBgZXhlY2AgaGFuZGxpbmcgb2Ygbm9ucGFydGljaXBhdGluZyBjYXB0dXJpbmcgZ3JvdXBzXG4gICAgICAgIGNvcnJlY3RFeGVjTnBjZyA9IG5hdGl2LmV4ZWMuY2FsbCgvKCk/Py8sICcnKVsxXSA9PT0gdW5kZWZpbmVkLFxuICAgICAgICAvLyBDaGVjayBmb3IgRVM2IGB1YCBmbGFnIHN1cHBvcnRcbiAgICAgICAgaGFzTmF0aXZlVSA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpc1N1cHBvcnRlZCA9IHRydWU7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG5ldyBSZWdFeHAoJycsICd1Jyk7XG4gICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgICBpc1N1cHBvcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGlzU3VwcG9ydGVkO1xuICAgICAgICB9KCkpLFxuICAgICAgICAvLyBDaGVjayBmb3IgRVM2IGB5YCBmbGFnIHN1cHBvcnRcbiAgICAgICAgaGFzTmF0aXZlWSA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpc1N1cHBvcnRlZCA9IHRydWU7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG5ldyBSZWdFeHAoJycsICd5Jyk7XG4gICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgICBpc1N1cHBvcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGlzU3VwcG9ydGVkO1xuICAgICAgICB9KCkpLFxuICAgICAgICAvLyBDaGVjayBmb3IgRVM2IGBmbGFnc2AgcHJvcCBzdXBwb3J0XG4gICAgICAgIGhhc0ZsYWdzUHJvcCA9IC9hLy5mbGFncyAhPT0gdW5kZWZpbmVkLFxuICAgICAgICAvLyBUcmFja2VyIGZvciBrbm93biBmbGFncywgaW5jbHVkaW5nIGFkZG9uIGZsYWdzXG4gICAgICAgIHJlZ2lzdGVyZWRGbGFncyA9IHtcbiAgICAgICAgICAgIGc6IHRydWUsXG4gICAgICAgICAgICBpOiB0cnVlLFxuICAgICAgICAgICAgbTogdHJ1ZSxcbiAgICAgICAgICAgIHU6IGhhc05hdGl2ZVUsXG4gICAgICAgICAgICB5OiBoYXNOYXRpdmVZXG4gICAgICAgIH0sXG4gICAgICAgIC8vIFNob3J0Y3V0IHRvIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYFxuICAgICAgICB0b1N0cmluZyA9IHt9LnRvU3RyaW5nLFxuICAgICAgICAvLyBTaG9ydGN1dCB0byBgWFJlZ0V4cC5hZGRUb2tlbmBcbiAgICAgICAgYWRkO1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFByaXZhdGUgZnVuY3Rpb25zXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuLyoqXG4gKiBBdHRhY2hlcyBleHRlbmRlZCBkYXRhIGFuZCBgWFJlZ0V4cC5wcm90b3R5cGVgIHByb3BlcnRpZXMgdG8gYSByZWdleCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7UmVnRXhwfSByZWdleCBSZWdleCB0byBhdWdtZW50LlxuICogQHBhcmFtIHtBcnJheX0gY2FwdHVyZU5hbWVzIEFycmF5IHdpdGggY2FwdHVyZSBuYW1lcywgb3IgYG51bGxgLlxuICogQHBhcmFtIHtTdHJpbmd9IHhTb3VyY2UgWFJlZ0V4cCBwYXR0ZXJuIHVzZWQgdG8gZ2VuZXJhdGUgYHJlZ2V4YCwgb3IgYG51bGxgIGlmIE4vQS5cbiAqIEBwYXJhbSB7U3RyaW5nfSB4RmxhZ3MgWFJlZ0V4cCBmbGFncyB1c2VkIHRvIGdlbmVyYXRlIGByZWdleGAsIG9yIGBudWxsYCBpZiBOL0EuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtpc0ludGVybmFsT25seT1mYWxzZV0gV2hldGhlciB0aGUgcmVnZXggd2lsbCBiZSB1c2VkIG9ubHkgZm9yIGludGVybmFsXG4gKiAgIG9wZXJhdGlvbnMsIGFuZCBuZXZlciBleHBvc2VkIHRvIHVzZXJzLiBGb3IgaW50ZXJuYWwtb25seSByZWdleGVzLCB3ZSBjYW4gaW1wcm92ZSBwZXJmIGJ5XG4gKiAgIHNraXBwaW5nIHNvbWUgb3BlcmF0aW9ucyBsaWtlIGF0dGFjaGluZyBgWFJlZ0V4cC5wcm90b3R5cGVgIHByb3BlcnRpZXMuXG4gKiBAcmV0dXJucyB7UmVnRXhwfSBBdWdtZW50ZWQgcmVnZXguXG4gKi9cbiAgICBmdW5jdGlvbiBhdWdtZW50KHJlZ2V4LCBjYXB0dXJlTmFtZXMsIHhTb3VyY2UsIHhGbGFncywgaXNJbnRlcm5hbE9ubHkpIHtcbiAgICAgICAgdmFyIHA7XG5cbiAgICAgICAgcmVnZXhbUkVHRVhfREFUQV0gPSB7XG4gICAgICAgICAgICBjYXB0dXJlTmFtZXM6IGNhcHR1cmVOYW1lc1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChpc0ludGVybmFsT25seSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlZ2V4O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2FuJ3QgYXV0by1pbmhlcml0IHRoZXNlIHNpbmNlIHRoZSBYUmVnRXhwIGNvbnN0cnVjdG9yIHJldHVybnMgYSBub25wcmltaXRpdmUgdmFsdWVcbiAgICAgICAgaWYgKHJlZ2V4Ll9fcHJvdG9fXykge1xuICAgICAgICAgICAgcmVnZXguX19wcm90b19fID0gc2VsZi5wcm90b3R5cGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHAgaW4gc2VsZi5wcm90b3R5cGUpIHtcbiAgICAgICAgICAgICAgICAvLyBBIGBzZWxmLnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eShwKWAgY2hlY2sgd291bGRuJ3QgYmUgd29ydGggaXQgaGVyZSwgc2luY2UgdGhpc1xuICAgICAgICAgICAgICAgIC8vIGlzIHBlcmZvcm1hbmNlIHNlbnNpdGl2ZSwgYW5kIGVudW1lcmFibGUgYE9iamVjdC5wcm90b3R5cGVgIG9yIGBSZWdFeHAucHJvdG90eXBlYFxuICAgICAgICAgICAgICAgIC8vIGV4dGVuc2lvbnMgZXhpc3Qgb24gYHJlZ2V4LnByb3RvdHlwZWAgYW55d2F5XG4gICAgICAgICAgICAgICAgcmVnZXhbcF0gPSBzZWxmLnByb3RvdHlwZVtwXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJlZ2V4W1JFR0VYX0RBVEFdLnNvdXJjZSA9IHhTb3VyY2U7XG4gICAgICAgIC8vIEVtdWxhdGUgdGhlIEVTNiBgZmxhZ3NgIHByb3AgYnkgZW5zdXJpbmcgZmxhZ3MgYXJlIGluIGFscGhhYmV0aWNhbCBvcmRlclxuICAgICAgICByZWdleFtSRUdFWF9EQVRBXS5mbGFncyA9IHhGbGFncyA/IHhGbGFncy5zcGxpdCgnJykuc29ydCgpLmpvaW4oJycpIDogeEZsYWdzO1xuXG4gICAgICAgIHJldHVybiByZWdleDtcbiAgICB9XG5cbi8qKlxuICogUmVtb3ZlcyBhbnkgZHVwbGljYXRlIGNoYXJhY3RlcnMgZnJvbSB0aGUgcHJvdmlkZWQgc3RyaW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFN0cmluZyB0byByZW1vdmUgZHVwbGljYXRlIGNoYXJhY3RlcnMgZnJvbS5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFN0cmluZyB3aXRoIGFueSBkdXBsaWNhdGUgY2hhcmFjdGVycyByZW1vdmVkLlxuICovXG4gICAgZnVuY3Rpb24gY2xpcER1cGxpY2F0ZXMoc3RyKSB7XG4gICAgICAgIHJldHVybiBuYXRpdi5yZXBsYWNlLmNhbGwoc3RyLCAvKFtcXHNcXFNdKSg/PVtcXHNcXFNdKlxcMSkvZywgJycpO1xuICAgIH1cblxuLyoqXG4gKiBDb3BpZXMgYSByZWdleCBvYmplY3Qgd2hpbGUgcHJlc2VydmluZyBleHRlbmRlZCBkYXRhIGFuZCBhdWdtZW50aW5nIHdpdGggYFhSZWdFeHAucHJvdG90eXBlYFxuICogcHJvcGVydGllcy4gVGhlIGNvcHkgaGFzIGEgZnJlc2ggYGxhc3RJbmRleGAgcHJvcGVydHkgKHNldCB0byB6ZXJvKS4gQWxsb3dzIGFkZGluZyBhbmQgcmVtb3ZpbmdcbiAqIGZsYWdzIGcgYW5kIHkgd2hpbGUgY29weWluZyB0aGUgcmVnZXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7UmVnRXhwfSByZWdleCBSZWdleCB0byBjb3B5LlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdCB3aXRoIG9wdGlvbmFsIHByb3BlcnRpZXM6XG4gKiAgIDxsaT5gYWRkR2Age0Jvb2xlYW59IEFkZCBmbGFnIGcgd2hpbGUgY29weWluZyB0aGUgcmVnZXguXG4gKiAgIDxsaT5gYWRkWWAge0Jvb2xlYW59IEFkZCBmbGFnIHkgd2hpbGUgY29weWluZyB0aGUgcmVnZXguXG4gKiAgIDxsaT5gcmVtb3ZlR2Age0Jvb2xlYW59IFJlbW92ZSBmbGFnIGcgd2hpbGUgY29weWluZyB0aGUgcmVnZXguXG4gKiAgIDxsaT5gcmVtb3ZlWWAge0Jvb2xlYW59IFJlbW92ZSBmbGFnIHkgd2hpbGUgY29weWluZyB0aGUgcmVnZXguXG4gKiAgIDxsaT5gaXNJbnRlcm5hbE9ubHlgIHtCb29sZWFufSBXaGV0aGVyIHRoZSBjb3BpZWQgcmVnZXggd2lsbCBiZSB1c2VkIG9ubHkgZm9yIGludGVybmFsXG4gKiAgICAgb3BlcmF0aW9ucywgYW5kIG5ldmVyIGV4cG9zZWQgdG8gdXNlcnMuIEZvciBpbnRlcm5hbC1vbmx5IHJlZ2V4ZXMsIHdlIGNhbiBpbXByb3ZlIHBlcmYgYnlcbiAqICAgICBza2lwcGluZyBzb21lIG9wZXJhdGlvbnMgbGlrZSBhdHRhY2hpbmcgYFhSZWdFeHAucHJvdG90eXBlYCBwcm9wZXJ0aWVzLlxuICogQHJldHVybnMge1JlZ0V4cH0gQ29weSBvZiB0aGUgcHJvdmlkZWQgcmVnZXgsIHBvc3NpYmx5IHdpdGggbW9kaWZpZWQgZmxhZ3MuXG4gKi9cbiAgICBmdW5jdGlvbiBjb3B5UmVnZXgocmVnZXgsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFzZWxmLmlzUmVnRXhwKHJlZ2V4KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVHlwZSBSZWdFeHAgZXhwZWN0ZWQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB4RGF0YSA9IHJlZ2V4W1JFR0VYX0RBVEFdIHx8IHt9LFxuICAgICAgICAgICAgZmxhZ3MgPSBnZXROYXRpdmVGbGFncyhyZWdleCksXG4gICAgICAgICAgICBmbGFnc1RvQWRkID0gJycsXG4gICAgICAgICAgICBmbGFnc1RvUmVtb3ZlID0gJycsXG4gICAgICAgICAgICB4cmVnZXhwU291cmNlID0gbnVsbCxcbiAgICAgICAgICAgIHhyZWdleHBGbGFncyA9IG51bGw7XG5cbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgaWYgKG9wdGlvbnMucmVtb3ZlRykge2ZsYWdzVG9SZW1vdmUgKz0gJ2cnO31cbiAgICAgICAgaWYgKG9wdGlvbnMucmVtb3ZlWSkge2ZsYWdzVG9SZW1vdmUgKz0gJ3knO31cbiAgICAgICAgaWYgKGZsYWdzVG9SZW1vdmUpIHtcbiAgICAgICAgICAgIGZsYWdzID0gbmF0aXYucmVwbGFjZS5jYWxsKGZsYWdzLCBuZXcgUmVnRXhwKCdbJyArIGZsYWdzVG9SZW1vdmUgKyAnXSsnLCAnZycpLCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5hZGRHKSB7ZmxhZ3NUb0FkZCArPSAnZyc7fVxuICAgICAgICBpZiAob3B0aW9ucy5hZGRZKSB7ZmxhZ3NUb0FkZCArPSAneSc7fVxuICAgICAgICBpZiAoZmxhZ3NUb0FkZCkge1xuICAgICAgICAgICAgZmxhZ3MgPSBjbGlwRHVwbGljYXRlcyhmbGFncyArIGZsYWdzVG9BZGQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFvcHRpb25zLmlzSW50ZXJuYWxPbmx5KSB7XG4gICAgICAgICAgICBpZiAoeERhdGEuc291cmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB4cmVnZXhwU291cmNlID0geERhdGEuc291cmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbnVsbCBvciB1bmRlZmluZWQ7IGRvbid0IHdhbnQgdG8gYWRkIHRvIGBmbGFnc2AgaWYgdGhlIHByZXZpb3VzIHZhbHVlIHdhcyBudWxsLCBzaW5jZVxuICAgICAgICAgICAgLy8gdGhhdCBpbmRpY2F0ZXMgd2UncmUgbm90IHRyYWNraW5nIG9yaWdpbmFsIHByZWNvbXBpbGF0aW9uIGZsYWdzXG4gICAgICAgICAgICBpZiAoeERhdGEuZmxhZ3MgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIEZsYWdzIGFyZSBvbmx5IGFkZGVkIGZvciBub24taW50ZXJuYWwgcmVnZXhlcyBieSBgWFJlZ0V4cC5nbG9iYWxpemVgLiBGbGFncyBhcmVcbiAgICAgICAgICAgICAgICAvLyBuZXZlciByZW1vdmVkIGZvciBub24taW50ZXJuYWwgcmVnZXhlcywgc28gZG9uJ3QgbmVlZCB0byBoYW5kbGUgaXRcbiAgICAgICAgICAgICAgICB4cmVnZXhwRmxhZ3MgPSBmbGFnc1RvQWRkID8gY2xpcER1cGxpY2F0ZXMoeERhdGEuZmxhZ3MgKyBmbGFnc1RvQWRkKSA6IHhEYXRhLmZsYWdzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXVnbWVudCB3aXRoIGBYUmVnRXhwLnByb3RvdHlwZWAgcHJvcGVydGllcywgYnV0IHVzZSB0aGUgbmF0aXZlIGBSZWdFeHBgIGNvbnN0cnVjdG9yIHRvXG4gICAgICAgIC8vIGF2b2lkIHNlYXJjaGluZyBmb3Igc3BlY2lhbCB0b2tlbnMuIFRoYXQgd291bGQgYmUgd3JvbmcgZm9yIHJlZ2V4ZXMgY29uc3RydWN0ZWQgYnlcbiAgICAgICAgLy8gYFJlZ0V4cGAsIGFuZCB1bm5lY2Vzc2FyeSBmb3IgcmVnZXhlcyBjb25zdHJ1Y3RlZCBieSBgWFJlZ0V4cGAgYmVjYXVzZSB0aGUgcmVnZXggaGFzXG4gICAgICAgIC8vIGFscmVhZHkgdW5kZXJnb25lIHRoZSB0cmFuc2xhdGlvbiB0byBuYXRpdmUgcmVnZXggc3ludGF4XG4gICAgICAgIHJlZ2V4ID0gYXVnbWVudChcbiAgICAgICAgICAgIG5ldyBSZWdFeHAocmVnZXguc291cmNlLCBmbGFncyksXG4gICAgICAgICAgICBoYXNOYW1lZENhcHR1cmUocmVnZXgpID8geERhdGEuY2FwdHVyZU5hbWVzLnNsaWNlKDApIDogbnVsbCxcbiAgICAgICAgICAgIHhyZWdleHBTb3VyY2UsXG4gICAgICAgICAgICB4cmVnZXhwRmxhZ3MsXG4gICAgICAgICAgICBvcHRpb25zLmlzSW50ZXJuYWxPbmx5XG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIHJlZ2V4O1xuICAgIH1cblxuLyoqXG4gKiBDb252ZXJ0cyBoZXhhZGVjaW1hbCB0byBkZWNpbWFsLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gaGV4XG4gKiBAcmV0dXJucyB7TnVtYmVyfVxuICovXG4gICAgZnVuY3Rpb24gZGVjKGhleCkge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQoaGV4LCAxNik7XG4gICAgfVxuXG4vKipcbiAqIFJldHVybnMgbmF0aXZlIGBSZWdFeHBgIGZsYWdzIHVzZWQgYnkgYSByZWdleCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7UmVnRXhwfSByZWdleCBSZWdleCB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IE5hdGl2ZSBmbGFncyBpbiB1c2UuXG4gKi9cbiAgICBmdW5jdGlvbiBnZXROYXRpdmVGbGFncyhyZWdleCkge1xuICAgICAgICByZXR1cm4gaGFzRmxhZ3NQcm9wID9cbiAgICAgICAgICAgIHJlZ2V4LmZsYWdzIDpcbiAgICAgICAgICAgIC8vIEV4cGxpY2l0bHkgdXNpbmcgYFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmdgIChyYXRoZXIgdGhhbiBlLmcuIGBTdHJpbmdgIG9yXG4gICAgICAgICAgICAvLyBjb25jYXRlbmF0aW9uIHdpdGggYW4gZW1wdHkgc3RyaW5nKSBhbGxvd3MgdGhpcyB0byBjb250aW51ZSB3b3JraW5nIHByZWRpY3RhYmx5IHdoZW5cbiAgICAgICAgICAgIC8vIGBYUmVnRXhwLnByb3B0b3R5cGUudG9TdHJpbmdgIGlzIG92ZXJyaWRlblxuICAgICAgICAgICAgbmF0aXYuZXhlYy5jYWxsKC9cXC8oW2Etel0qKSQvaSwgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHJlZ2V4KSlbMV07XG4gICAgfVxuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciBhIHJlZ2V4IGhhcyBleHRlbmRlZCBpbnN0YW5jZSBkYXRhIHVzZWQgdG8gdHJhY2sgY2FwdHVyZSBuYW1lcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtSZWdFeHB9IHJlZ2V4IFJlZ2V4IHRvIGNoZWNrLlxuICogQHJldHVybnMge0Jvb2xlYW59IFdoZXRoZXIgdGhlIHJlZ2V4IHVzZXMgbmFtZWQgY2FwdHVyZS5cbiAqL1xuICAgIGZ1bmN0aW9uIGhhc05hbWVkQ2FwdHVyZShyZWdleCkge1xuICAgICAgICByZXR1cm4gISEocmVnZXhbUkVHRVhfREFUQV0gJiYgcmVnZXhbUkVHRVhfREFUQV0uY2FwdHVyZU5hbWVzKTtcbiAgICB9XG5cbi8qKlxuICogQ29udmVydHMgZGVjaW1hbCB0byBoZXhhZGVjaW1hbC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBkZWNcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbiAgICBmdW5jdGlvbiBoZXgoZGVjKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUludChkZWMsIDEwKS50b1N0cmluZygxNik7XG4gICAgfVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGZpcnN0IGluZGV4IGF0IHdoaWNoIGEgZ2l2ZW4gdmFsdWUgY2FuIGJlIGZvdW5kIGluIGFuIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBBcnJheSB0byBzZWFyY2guXG4gKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIGxvY2F0ZSBpbiB0aGUgYXJyYXkuXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBaZXJvLWJhc2VkIGluZGV4IGF0IHdoaWNoIHRoZSBpdGVtIGlzIGZvdW5kLCBvciAtMS5cbiAqL1xuICAgIGZ1bmN0aW9uIGluZGV4T2YoYXJyYXksIHZhbHVlKSB7XG4gICAgICAgIHZhciBsZW4gPSBhcnJheS5sZW5ndGgsIGk7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICBpZiAoYXJyYXlbaV0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciBhIHZhbHVlIGlzIG9mIHRoZSBzcGVjaWZpZWQgdHlwZSwgYnkgcmVzb2x2aW5nIGl0cyBpbnRlcm5hbCBbW0NsYXNzXV0uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgT2JqZWN0IHRvIGNoZWNrLlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVHlwZSB0byBjaGVjayBmb3IsIGluIFRpdGxlQ2FzZS5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBXaGV0aGVyIHRoZSBvYmplY3QgbWF0Y2hlcyB0aGUgdHlwZS5cbiAqL1xuICAgIGZ1bmN0aW9uIGlzVHlwZSh2YWx1ZSwgdHlwZSkge1xuICAgICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0ICcgKyB0eXBlICsgJ10nO1xuICAgIH1cblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgbmV4dCBub25pZ25vcmFibGUgdG9rZW4gYWZ0ZXIgdGhlIHNwZWNpZmllZCBwb3NpdGlvbiBpcyBhIHF1YW50aWZpZXIuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXR0ZXJuIFBhdHRlcm4gdG8gc2VhcmNoIHdpdGhpbi5cbiAqIEBwYXJhbSB7TnVtYmVyfSBwb3MgSW5kZXggaW4gYHBhdHRlcm5gIHRvIHNlYXJjaCBhdC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBmbGFncyBGbGFncyB1c2VkIGJ5IHRoZSBwYXR0ZXJuLlxuICogQHJldHVybnMge0Jvb2xlYW59IFdoZXRoZXIgdGhlIG5leHQgdG9rZW4gaXMgYSBxdWFudGlmaWVyLlxuICovXG4gICAgZnVuY3Rpb24gaXNRdWFudGlmaWVyTmV4dChwYXR0ZXJuLCBwb3MsIGZsYWdzKSB7XG4gICAgICAgIHJldHVybiBuYXRpdi50ZXN0LmNhbGwoXG4gICAgICAgICAgICBmbGFncy5pbmRleE9mKCd4JykgPiAtMSA/XG4gICAgICAgICAgICAgICAgLy8gSWdub3JlIGFueSBsZWFkaW5nIHdoaXRlc3BhY2UsIGxpbmUgY29tbWVudHMsIGFuZCBpbmxpbmUgY29tbWVudHNcbiAgICAgICAgICAgICAgICAvXig/Olxccyt8Iy4qfFxcKFxcPyNbXildKlxcKSkqKD86Wz8qK118e1xcZCsoPzosXFxkKik/fSkvIDpcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgYW55IGxlYWRpbmcgaW5saW5lIGNvbW1lbnRzXG4gICAgICAgICAgICAgICAgL14oPzpcXChcXD8jW14pXSpcXCkpKig/Ols/KitdfHtcXGQrKD86LFxcZCopP30pLyxcbiAgICAgICAgICAgIHBhdHRlcm4uc2xpY2UocG9zKVxuICAgICAgICApO1xuICAgIH1cblxuLyoqXG4gKiBQYWRzIHRoZSBwcm92aWRlZCBzdHJpbmcgd2l0aCBhcyBtYW55IGxlYWRpbmcgemVyb3MgYXMgbmVlZGVkIHRvIGdldCB0byBsZW5ndGggNC4gVXNlZCB0byBwcm9kdWNlXG4gKiBmaXhlZC1sZW5ndGggaGV4YWRlY2ltYWwgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG4gICAgZnVuY3Rpb24gcGFkNChzdHIpIHtcbiAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCA0KSB7XG4gICAgICAgICAgICBzdHIgPSAnMCcgKyBzdHI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG5cbi8qKlxuICogQ2hlY2tzIGZvciBmbGFnLXJlbGF0ZWQgZXJyb3JzLCBhbmQgc3RyaXBzL2FwcGxpZXMgZmxhZ3MgaW4gYSBsZWFkaW5nIG1vZGUgbW9kaWZpZXIuIE9mZmxvYWRzXG4gKiB0aGUgZmxhZyBwcmVwYXJhdGlvbiBsb2dpYyBmcm9tIHRoZSBgWFJlZ0V4cGAgY29uc3RydWN0b3IuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXR0ZXJuIFJlZ2V4IHBhdHRlcm4sIHBvc3NpYmx5IHdpdGggYSBsZWFkaW5nIG1vZGUgbW9kaWZpZXIuXG4gKiBAcGFyYW0ge1N0cmluZ30gZmxhZ3MgQW55IGNvbWJpbmF0aW9uIG9mIGZsYWdzLlxuICogQHJldHVybnMge09iamVjdH0gT2JqZWN0IHdpdGggcHJvcGVydGllcyBgcGF0dGVybmAgYW5kIGBmbGFnc2AuXG4gKi9cbiAgICBmdW5jdGlvbiBwcmVwYXJlRmxhZ3MocGF0dGVybiwgZmxhZ3MpIHtcbiAgICAgICAgdmFyIGk7XG5cbiAgICAgICAgLy8gUmVjZW50IGJyb3dzZXJzIHRocm93IG9uIGR1cGxpY2F0ZSBmbGFncywgc28gY29weSB0aGlzIGJlaGF2aW9yIGZvciBub25uYXRpdmUgZmxhZ3NcbiAgICAgICAgaWYgKGNsaXBEdXBsaWNhdGVzKGZsYWdzKSAhPT0gZmxhZ3MpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignSW52YWxpZCBkdXBsaWNhdGUgcmVnZXggZmxhZyAnICsgZmxhZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3RyaXAgYW5kIGFwcGx5IGEgbGVhZGluZyBtb2RlIG1vZGlmaWVyIHdpdGggYW55IGNvbWJpbmF0aW9uIG9mIGZsYWdzIGV4Y2VwdCBnIG9yIHlcbiAgICAgICAgcGF0dGVybiA9IG5hdGl2LnJlcGxhY2UuY2FsbChwYXR0ZXJuLCAvXlxcKFxcPyhbXFx3JF0rKVxcKS8sIGZ1bmN0aW9uKCQwLCAkMSkge1xuICAgICAgICAgICAgaWYgKG5hdGl2LnRlc3QuY2FsbCgvW2d5XS8sICQxKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQ2Fubm90IHVzZSBmbGFnIGcgb3IgeSBpbiBtb2RlIG1vZGlmaWVyICcgKyAkMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBbGxvdyBkdXBsaWNhdGUgZmxhZ3Mgd2l0aGluIHRoZSBtb2RlIG1vZGlmaWVyXG4gICAgICAgICAgICBmbGFncyA9IGNsaXBEdXBsaWNhdGVzKGZsYWdzICsgJDEpO1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBUaHJvdyBvbiB1bmtub3duIG5hdGl2ZSBvciBub25uYXRpdmUgZmxhZ3NcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGZsYWdzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoIXJlZ2lzdGVyZWRGbGFnc1tmbGFncy5jaGFyQXQoaSldKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdVbmtub3duIHJlZ2V4IGZsYWcgJyArIGZsYWdzLmNoYXJBdChpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcGF0dGVybjogcGF0dGVybixcbiAgICAgICAgICAgIGZsYWdzOiBmbGFnc1xuICAgICAgICB9O1xuICAgIH1cblxuLyoqXG4gKiBQcmVwYXJlcyBhbiBvcHRpb25zIG9iamVjdCBmcm9tIHRoZSBnaXZlbiB2YWx1ZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSB2YWx1ZSBWYWx1ZSB0byBjb252ZXJ0IHRvIGFuIG9wdGlvbnMgb2JqZWN0LlxuICogQHJldHVybnMge09iamVjdH0gT3B0aW9ucyBvYmplY3QuXG4gKi9cbiAgICBmdW5jdGlvbiBwcmVwYXJlT3B0aW9ucyh2YWx1ZSkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHt9O1xuXG4gICAgICAgIGlmIChpc1R5cGUodmFsdWUsICdTdHJpbmcnKSkge1xuICAgICAgICAgICAgc2VsZi5mb3JFYWNoKHZhbHVlLCAvW15cXHMsXSsvLCBmdW5jdGlvbihtYXRjaCkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnNbbWF0Y2hdID0gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbi8qKlxuICogUmVnaXN0ZXJzIGEgZmxhZyBzbyBpdCBkb2Vzbid0IHRocm93IGFuICd1bmtub3duIGZsYWcnIGVycm9yLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gZmxhZyBTaW5nbGUtY2hhcmFjdGVyIGZsYWcgdG8gcmVnaXN0ZXIuXG4gKi9cbiAgICBmdW5jdGlvbiByZWdpc3RlckZsYWcoZmxhZykge1xuICAgICAgICBpZiAoIS9eW1xcdyRdJC8udGVzdChmbGFnKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGbGFnIG11c3QgYmUgYSBzaW5nbGUgY2hhcmFjdGVyIEEtWmEtejAtOV8kJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZWdpc3RlcmVkRmxhZ3NbZmxhZ10gPSB0cnVlO1xuICAgIH1cblxuLyoqXG4gKiBSdW5zIGJ1aWx0LWluIGFuZCBjdXN0b20gcmVnZXggc3ludGF4IHRva2VucyBpbiByZXZlcnNlIGluc2VydGlvbiBvcmRlciBhdCB0aGUgc3BlY2lmaWVkXG4gKiBwb3NpdGlvbiwgdW50aWwgYSBtYXRjaCBpcyBmb3VuZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtTdHJpbmd9IHBhdHRlcm4gT3JpZ2luYWwgcGF0dGVybiBmcm9tIHdoaWNoIGFuIFhSZWdFeHAgb2JqZWN0IGlzIGJlaW5nIGJ1aWx0LlxuICogQHBhcmFtIHtTdHJpbmd9IGZsYWdzIEZsYWdzIGJlaW5nIHVzZWQgdG8gY29uc3RydWN0IHRoZSByZWdleC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBwb3MgUG9zaXRpb24gdG8gc2VhcmNoIGZvciB0b2tlbnMgd2l0aGluIGBwYXR0ZXJuYC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBzY29wZSBSZWdleCBzY29wZSB0byBhcHBseTogJ2RlZmF1bHQnIG9yICdjbGFzcycuXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dCBDb250ZXh0IG9iamVjdCB0byB1c2UgZm9yIHRva2VuIGhhbmRsZXIgZnVuY3Rpb25zLlxuICogQHJldHVybnMge09iamVjdH0gT2JqZWN0IHdpdGggcHJvcGVydGllcyBgbWF0Y2hMZW5ndGhgLCBgb3V0cHV0YCwgYW5kIGByZXBhcnNlYDsgb3IgYG51bGxgLlxuICovXG4gICAgZnVuY3Rpb24gcnVuVG9rZW5zKHBhdHRlcm4sIGZsYWdzLCBwb3MsIHNjb3BlLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBpID0gdG9rZW5zLmxlbmd0aCxcbiAgICAgICAgICAgIGxlYWRDaGFyID0gcGF0dGVybi5jaGFyQXQocG9zKSxcbiAgICAgICAgICAgIHJlc3VsdCA9IG51bGwsXG4gICAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICAgIHQ7XG5cbiAgICAgICAgLy8gUnVuIGluIHJldmVyc2UgaW5zZXJ0aW9uIG9yZGVyXG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIHQgPSB0b2tlbnNbaV07XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgKHQubGVhZENoYXIgJiYgdC5sZWFkQ2hhciAhPT0gbGVhZENoYXIpIHx8XG4gICAgICAgICAgICAgICAgKHQuc2NvcGUgIT09IHNjb3BlICYmIHQuc2NvcGUgIT09ICdhbGwnKSB8fFxuICAgICAgICAgICAgICAgICh0LmZsYWcgJiYgZmxhZ3MuaW5kZXhPZih0LmZsYWcpID09PSAtMSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtYXRjaCA9IHNlbGYuZXhlYyhwYXR0ZXJuLCB0LnJlZ2V4LCBwb3MsICdzdGlja3knKTtcbiAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hMZW5ndGg6IG1hdGNoWzBdLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiB0LmhhbmRsZXIuY2FsbChjb250ZXh0LCBtYXRjaCwgc2NvcGUsIGZsYWdzKSxcbiAgICAgICAgICAgICAgICAgICAgcmVwYXJzZTogdC5yZXBhcnNlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvLyBGaW5pc2hlZCB3aXRoIHRva2VuIHRlc3RzXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuLyoqXG4gKiBFbmFibGVzIG9yIGRpc2FibGVzIGltcGxpY2l0IGFzdHJhbCBtb2RlIG9wdC1pbi4gV2hlbiBlbmFibGVkLCBmbGFnIEEgaXMgYXV0b21hdGljYWxseSBhZGRlZCB0b1xuICogYWxsIG5ldyByZWdleGVzIGNyZWF0ZWQgYnkgWFJlZ0V4cC4gVGhpcyBjYXVzZXMgYW4gZXJyb3IgdG8gYmUgdGhyb3duIHdoZW4gY3JlYXRpbmcgcmVnZXhlcyBpZlxuICogdGhlIFVuaWNvZGUgQmFzZSBhZGRvbiBpcyBub3QgYXZhaWxhYmxlLCBzaW5jZSBmbGFnIEEgaXMgcmVnaXN0ZXJlZCBieSB0aGF0IGFkZG9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9uIGB0cnVlYCB0byBlbmFibGU7IGBmYWxzZWAgdG8gZGlzYWJsZS5cbiAqL1xuICAgIGZ1bmN0aW9uIHNldEFzdHJhbChvbikge1xuICAgICAgICBmZWF0dXJlcy5hc3RyYWwgPSBvbjtcbiAgICB9XG5cbi8qKlxuICogRW5hYmxlcyBvciBkaXNhYmxlcyBuYXRpdmUgbWV0aG9kIG92ZXJyaWRlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtCb29sZWFufSBvbiBgdHJ1ZWAgdG8gZW5hYmxlOyBgZmFsc2VgIHRvIGRpc2FibGUuXG4gKi9cbiAgICBmdW5jdGlvbiBzZXROYXRpdmVzKG9uKSB7XG4gICAgICAgIFJlZ0V4cC5wcm90b3R5cGUuZXhlYyA9IChvbiA/IGZpeGVkIDogbmF0aXYpLmV4ZWM7XG4gICAgICAgIFJlZ0V4cC5wcm90b3R5cGUudGVzdCA9IChvbiA/IGZpeGVkIDogbmF0aXYpLnRlc3Q7XG4gICAgICAgIFN0cmluZy5wcm90b3R5cGUubWF0Y2ggPSAob24gPyBmaXhlZCA6IG5hdGl2KS5tYXRjaDtcbiAgICAgICAgU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlID0gKG9uID8gZml4ZWQgOiBuYXRpdikucmVwbGFjZTtcbiAgICAgICAgU3RyaW5nLnByb3RvdHlwZS5zcGxpdCA9IChvbiA/IGZpeGVkIDogbmF0aXYpLnNwbGl0O1xuXG4gICAgICAgIGZlYXR1cmVzLm5hdGl2ZXMgPSBvbjtcbiAgICB9XG5cbi8qKlxuICogUmV0dXJucyB0aGUgb2JqZWN0LCBvciB0aHJvd3MgYW4gZXJyb3IgaWYgaXQgaXMgYG51bGxgIG9yIGB1bmRlZmluZWRgLiBUaGlzIGlzIHVzZWQgdG8gZm9sbG93XG4gKiB0aGUgRVM1IGFic3RyYWN0IG9wZXJhdGlvbiBgVG9PYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIE9iamVjdCB0byBjaGVjayBhbmQgcmV0dXJuLlxuICogQHJldHVybnMgeyp9IFRoZSBwcm92aWRlZCBvYmplY3QuXG4gKi9cbiAgICBmdW5jdGlvbiB0b09iamVjdCh2YWx1ZSkge1xuICAgICAgICAvLyBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgbnVsbCBvciB1bmRlZmluZWQgdG8gb2JqZWN0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbnN0cnVjdG9yXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGV4dGVuZGVkIHJlZ3VsYXIgZXhwcmVzc2lvbiBvYmplY3QgZm9yIG1hdGNoaW5nIHRleHQgd2l0aCBhIHBhdHRlcm4uIERpZmZlcnMgZnJvbSBhXG4gKiBuYXRpdmUgcmVndWxhciBleHByZXNzaW9uIGluIHRoYXQgYWRkaXRpb25hbCBzeW50YXggYW5kIGZsYWdzIGFyZSBzdXBwb3J0ZWQuIFRoZSByZXR1cm5lZCBvYmplY3RcbiAqIGlzIGluIGZhY3QgYSBuYXRpdmUgYFJlZ0V4cGAgYW5kIHdvcmtzIHdpdGggYWxsIG5hdGl2ZSBtZXRob2RzLlxuICpcbiAqIEBjbGFzcyBYUmVnRXhwXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfFJlZ0V4cH0gcGF0dGVybiBSZWdleCBwYXR0ZXJuIHN0cmluZywgb3IgYW4gZXhpc3RpbmcgcmVnZXggb2JqZWN0IHRvIGNvcHkuXG4gKiBAcGFyYW0ge1N0cmluZ30gW2ZsYWdzXSBBbnkgY29tYmluYXRpb24gb2YgZmxhZ3MuXG4gKiAgIE5hdGl2ZSBmbGFnczpcbiAqICAgICA8bGk+YGdgIC0gZ2xvYmFsXG4gKiAgICAgPGxpPmBpYCAtIGlnbm9yZSBjYXNlXG4gKiAgICAgPGxpPmBtYCAtIG11bHRpbGluZSBhbmNob3JzXG4gKiAgICAgPGxpPmB1YCAtIHVuaWNvZGUgKEVTNilcbiAqICAgICA8bGk+YHlgIC0gc3RpY2t5IChGaXJlZm94IDMrLCBFUzYpXG4gKiAgIEFkZGl0aW9uYWwgWFJlZ0V4cCBmbGFnczpcbiAqICAgICA8bGk+YG5gIC0gZXhwbGljaXQgY2FwdHVyZVxuICogICAgIDxsaT5gc2AgLSBkb3QgbWF0Y2hlcyBhbGwgKGFrYSBzaW5nbGVsaW5lKVxuICogICAgIDxsaT5geGAgLSBmcmVlLXNwYWNpbmcgYW5kIGxpbmUgY29tbWVudHMgKGFrYSBleHRlbmRlZClcbiAqICAgICA8bGk+YEFgIC0gYXN0cmFsIChyZXF1aXJlcyB0aGUgVW5pY29kZSBCYXNlIGFkZG9uKVxuICogICBGbGFncyBjYW5ub3QgYmUgcHJvdmlkZWQgd2hlbiBjb25zdHJ1Y3Rpbmcgb25lIGBSZWdFeHBgIGZyb20gYW5vdGhlci5cbiAqIEByZXR1cm5zIHtSZWdFeHB9IEV4dGVuZGVkIHJlZ3VsYXIgZXhwcmVzc2lvbiBvYmplY3QuXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIFdpdGggbmFtZWQgY2FwdHVyZSBhbmQgZmxhZyB4XG4gKiBYUmVnRXhwKCcoPzx5ZWFyPiAgWzAtOV17NH0gKSAtPyAgIyB5ZWFyICBcXG5cXFxuICogICAgICAgICAgKD88bW9udGg+IFswLTldezJ9ICkgLT8gICMgbW9udGggXFxuXFxcbiAqICAgICAgICAgICg/PGRheT4gICBbMC05XXsyfSApICAgICAjIGRheSAgICcsICd4Jyk7XG4gKlxuICogLy8gUHJvdmlkaW5nIGEgcmVnZXggb2JqZWN0IGNvcGllcyBpdC4gTmF0aXZlIHJlZ2V4ZXMgYXJlIHJlY29tcGlsZWQgdXNpbmcgbmF0aXZlIChub3QgWFJlZ0V4cClcbiAqIC8vIHN5bnRheC4gQ29waWVzIG1haW50YWluIGV4dGVuZGVkIGRhdGEsIGFyZSBhdWdtZW50ZWQgd2l0aCBgWFJlZ0V4cC5wcm90b3R5cGVgIHByb3BlcnRpZXMsIGFuZFxuICogLy8gaGF2ZSBmcmVzaCBgbGFzdEluZGV4YCBwcm9wZXJ0aWVzIChzZXQgdG8gemVybykuXG4gKiBYUmVnRXhwKC9yZWdleC8pO1xuICovXG4gICAgc2VsZiA9IGZ1bmN0aW9uKHBhdHRlcm4sIGZsYWdzKSB7XG4gICAgICAgIHZhciBjb250ZXh0ID0ge1xuICAgICAgICAgICAgICAgIGhhc05hbWVkQ2FwdHVyZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgY2FwdHVyZU5hbWVzOiBbXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNjb3BlID0gZGVmYXVsdFNjb3BlLFxuICAgICAgICAgICAgb3V0cHV0ID0gJycsXG4gICAgICAgICAgICBwb3MgPSAwLFxuICAgICAgICAgICAgcmVzdWx0LFxuICAgICAgICAgICAgdG9rZW4sXG4gICAgICAgICAgICBnZW5lcmF0ZWQsXG4gICAgICAgICAgICBhcHBsaWVkUGF0dGVybixcbiAgICAgICAgICAgIGFwcGxpZWRGbGFncztcblxuICAgICAgICBpZiAoc2VsZi5pc1JlZ0V4cChwYXR0ZXJuKSkge1xuICAgICAgICAgICAgaWYgKGZsYWdzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3Qgc3VwcGx5IGZsYWdzIHdoZW4gY29weWluZyBhIFJlZ0V4cCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvcHlSZWdleChwYXR0ZXJuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvcHkgdGhlIGFyZ3VtZW50IGJlaGF2aW9yIG9mIGBSZWdFeHBgXG4gICAgICAgIHBhdHRlcm4gPSBwYXR0ZXJuID09PSB1bmRlZmluZWQgPyAnJyA6IFN0cmluZyhwYXR0ZXJuKTtcbiAgICAgICAgZmxhZ3MgPSBmbGFncyA9PT0gdW5kZWZpbmVkID8gJycgOiBTdHJpbmcoZmxhZ3MpO1xuXG4gICAgICAgIGlmIChzZWxmLmlzSW5zdGFsbGVkKCdhc3RyYWwnKSAmJiBmbGFncy5pbmRleE9mKCdBJykgPT09IC0xKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGNhdXNlcyBhbiBlcnJvciB0byBiZSB0aHJvd24gaWYgdGhlIFVuaWNvZGUgQmFzZSBhZGRvbiBpcyBub3QgYXZhaWxhYmxlXG4gICAgICAgICAgICBmbGFncyArPSAnQSc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXBhdHRlcm5DYWNoZVtwYXR0ZXJuXSkge1xuICAgICAgICAgICAgcGF0dGVybkNhY2hlW3BhdHRlcm5dID0ge307XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXBhdHRlcm5DYWNoZVtwYXR0ZXJuXVtmbGFnc10pIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBmbGFnLXJlbGF0ZWQgZXJyb3JzLCBhbmQgc3RyaXAvYXBwbHkgZmxhZ3MgaW4gYSBsZWFkaW5nIG1vZGUgbW9kaWZpZXJcbiAgICAgICAgICAgIHJlc3VsdCA9IHByZXBhcmVGbGFncyhwYXR0ZXJuLCBmbGFncyk7XG4gICAgICAgICAgICBhcHBsaWVkUGF0dGVybiA9IHJlc3VsdC5wYXR0ZXJuO1xuICAgICAgICAgICAgYXBwbGllZEZsYWdzID0gcmVzdWx0LmZsYWdzO1xuXG4gICAgICAgICAgICAvLyBVc2UgWFJlZ0V4cCdzIHRva2VucyB0byB0cmFuc2xhdGUgdGhlIHBhdHRlcm4gdG8gYSBuYXRpdmUgcmVnZXggcGF0dGVybi5cbiAgICAgICAgICAgIC8vIGBhcHBsaWVkUGF0dGVybi5sZW5ndGhgIG1heSBjaGFuZ2Ugb24gZWFjaCBpdGVyYXRpb24gaWYgdG9rZW5zIHVzZSBgcmVwYXJzZWBcbiAgICAgICAgICAgIHdoaWxlIChwb3MgPCBhcHBsaWVkUGF0dGVybi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGZvciBjdXN0b20gdG9rZW5zIGF0IHRoZSBjdXJyZW50IHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJ1blRva2VucyhhcHBsaWVkUGF0dGVybiwgYXBwbGllZEZsYWdzLCBwb3MsIHNjb3BlLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIG1hdGNoZWQgdG9rZW4gdXNlZCB0aGUgYHJlcGFyc2VgIG9wdGlvbiwgc3BsaWNlIGl0cyBvdXRwdXQgaW50byB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gcGF0dGVybiBiZWZvcmUgcnVubmluZyB0b2tlbnMgYWdhaW4gYXQgdGhlIHNhbWUgcG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCAmJiByZXN1bHQucmVwYXJzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXBwbGllZFBhdHRlcm4gPSBhcHBsaWVkUGF0dGVybi5zbGljZSgwLCBwb3MpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQub3V0cHV0ICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHBsaWVkUGF0dGVybi5zbGljZShwb3MgKyByZXN1bHQubWF0Y2hMZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAocmVzdWx0ICYmIHJlc3VsdC5yZXBhcnNlKTtcblxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0ICs9IHJlc3VsdC5vdXRwdXQ7XG4gICAgICAgICAgICAgICAgICAgIHBvcyArPSAocmVzdWx0Lm1hdGNoTGVuZ3RoIHx8IDEpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgbmF0aXZlIHRva2VuIGF0IHRoZSBjdXJyZW50IHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gc2VsZi5leGVjKGFwcGxpZWRQYXR0ZXJuLCBuYXRpdmVUb2tlbnNbc2NvcGVdLCBwb3MsICdzdGlja3knKVswXTtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0ICs9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBwb3MgKz0gdG9rZW4ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4gPT09ICdbJyAmJiBzY29wZSA9PT0gZGVmYXVsdFNjb3BlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZSA9IGNsYXNzU2NvcGU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodG9rZW4gPT09ICddJyAmJiBzY29wZSA9PT0gY2xhc3NTY29wZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUgPSBkZWZhdWx0U2NvcGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBhdHRlcm5DYWNoZVtwYXR0ZXJuXVtmbGFnc10gPSB7XG4gICAgICAgICAgICAgICAgLy8gQ2xlYW51cCB0b2tlbiBjcnVmdDogcmVwZWF0ZWQgYCg/OikoPzopYCBhbmQgbGVhZGluZy90cmFpbGluZyBgKD86KWBcbiAgICAgICAgICAgICAgICBwYXR0ZXJuOiBuYXRpdi5yZXBsYWNlLmNhbGwob3V0cHV0LCAvXFwoXFw/OlxcKSg/PVxcKFxcPzpcXCkpfF5cXChcXD86XFwpfFxcKFxcPzpcXCkkL2csICcnKSxcbiAgICAgICAgICAgICAgICAvLyBTdHJpcCBhbGwgYnV0IG5hdGl2ZSBmbGFnc1xuICAgICAgICAgICAgICAgIGZsYWdzOiBuYXRpdi5yZXBsYWNlLmNhbGwoYXBwbGllZEZsYWdzLCAvW15naW11eV0rL2csICcnKSxcbiAgICAgICAgICAgICAgICAvLyBgY29udGV4dC5jYXB0dXJlTmFtZXNgIGhhcyBhbiBpdGVtIGZvciBlYWNoIGNhcHR1cmluZyBncm91cCwgZXZlbiBpZiB1bm5hbWVkXG4gICAgICAgICAgICAgICAgY2FwdHVyZXM6IGNvbnRleHQuaGFzTmFtZWRDYXB0dXJlID8gY29udGV4dC5jYXB0dXJlTmFtZXMgOiBudWxsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgZ2VuZXJhdGVkID0gcGF0dGVybkNhY2hlW3BhdHRlcm5dW2ZsYWdzXTtcbiAgICAgICAgcmV0dXJuIGF1Z21lbnQoXG4gICAgICAgICAgICBuZXcgUmVnRXhwKGdlbmVyYXRlZC5wYXR0ZXJuLCBnZW5lcmF0ZWQuZmxhZ3MpLFxuICAgICAgICAgICAgZ2VuZXJhdGVkLmNhcHR1cmVzLFxuICAgICAgICAgICAgcGF0dGVybixcbiAgICAgICAgICAgIGZsYWdzXG4gICAgICAgICk7XG4gICAgfTtcblxuLy8gQWRkIGBSZWdFeHAucHJvdG90eXBlYCB0byB0aGUgcHJvdG90eXBlIGNoYWluXG4gICAgc2VsZi5wcm90b3R5cGUgPSBuZXcgUmVnRXhwKCk7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogUHVibGljIHByb3BlcnRpZXNcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG4vKipcbiAqIFRoZSBYUmVnRXhwIHZlcnNpb24gbnVtYmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBYUmVnRXhwXG4gKiBAdHlwZSBTdHJpbmdcbiAqL1xuICAgIHNlbGYudmVyc2lvbiA9ICczLjAuMCc7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogUHVibGljIG1ldGhvZHNcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG4vKipcbiAqIEV4dGVuZHMgWFJlZ0V4cCBzeW50YXggYW5kIGFsbG93cyBjdXN0b20gZmxhZ3MuIFRoaXMgaXMgdXNlZCBpbnRlcm5hbGx5IGFuZCBjYW4gYmUgdXNlZCB0b1xuICogY3JlYXRlIFhSZWdFeHAgYWRkb25zLiBJZiBtb3JlIHRoYW4gb25lIHRva2VuIGNhbiBtYXRjaCB0aGUgc2FtZSBzdHJpbmcsIHRoZSBsYXN0IGFkZGVkIHdpbnMuXG4gKlxuICogQG1lbWJlck9mIFhSZWdFeHBcbiAqIEBwYXJhbSB7UmVnRXhwfSByZWdleCBSZWdleCBvYmplY3QgdGhhdCBtYXRjaGVzIHRoZSBuZXcgdG9rZW4uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIEZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIG5ldyBwYXR0ZXJuIHN0cmluZyAodXNpbmcgbmF0aXZlIHJlZ2V4IHN5bnRheClcbiAqICAgdG8gcmVwbGFjZSB0aGUgbWF0Y2hlZCB0b2tlbiB3aXRoaW4gYWxsIGZ1dHVyZSBYUmVnRXhwIHJlZ2V4ZXMuIEhhcyBhY2Nlc3MgdG8gcGVyc2lzdGVudFxuICogICBwcm9wZXJ0aWVzIG9mIHRoZSByZWdleCBiZWluZyBidWlsdCwgdGhyb3VnaCBgdGhpc2AuIEludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gKiAgIDxsaT5UaGUgbWF0Y2ggYXJyYXksIHdpdGggbmFtZWQgYmFja3JlZmVyZW5jZSBwcm9wZXJ0aWVzLlxuICogICA8bGk+VGhlIHJlZ2V4IHNjb3BlIHdoZXJlIHRoZSBtYXRjaCB3YXMgZm91bmQ6ICdkZWZhdWx0JyBvciAnY2xhc3MnLlxuICogICA8bGk+VGhlIGZsYWdzIHVzZWQgYnkgdGhlIHJlZ2V4LCBpbmNsdWRpbmcgYW55IGZsYWdzIGluIGEgbGVhZGluZyBtb2RlIG1vZGlmaWVyLlxuICogICBUaGUgaGFuZGxlciBmdW5jdGlvbiBiZWNvbWVzIHBhcnQgb2YgdGhlIFhSZWdFeHAgY29uc3RydWN0aW9uIHByb2Nlc3MsIHNvIGJlIGNhcmVmdWwgbm90IHRvXG4gKiAgIGNvbnN0cnVjdCBYUmVnRXhwcyB3aXRoaW4gdGhlIGZ1bmN0aW9uIG9yIHlvdSB3aWxsIHRyaWdnZXIgaW5maW5pdGUgcmVjdXJzaW9uLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdCB3aXRoIG9wdGlvbmFsIHByb3BlcnRpZXM6XG4gKiAgIDxsaT5gc2NvcGVgIHtTdHJpbmd9IFNjb3BlIHdoZXJlIHRoZSB0b2tlbiBhcHBsaWVzOiAnZGVmYXVsdCcsICdjbGFzcycsIG9yICdhbGwnLlxuICogICA8bGk+YGZsYWdgIHtTdHJpbmd9IFNpbmdsZS1jaGFyYWN0ZXIgZmxhZyB0aGF0IHRyaWdnZXJzIHRoZSB0b2tlbi4gVGhpcyBhbHNvIHJlZ2lzdGVycyB0aGVcbiAqICAgICBmbGFnLCB3aGljaCBwcmV2ZW50cyBYUmVnRXhwIGZyb20gdGhyb3dpbmcgYW4gJ3Vua25vd24gZmxhZycgZXJyb3Igd2hlbiB0aGUgZmxhZyBpcyB1c2VkLlxuICogICA8bGk+YG9wdGlvbmFsRmxhZ3NgIHtTdHJpbmd9IEFueSBjdXN0b20gZmxhZ3MgY2hlY2tlZCBmb3Igd2l0aGluIHRoZSB0b2tlbiBgaGFuZGxlcmAgdGhhdCBhcmVcbiAqICAgICBub3QgcmVxdWlyZWQgdG8gdHJpZ2dlciB0aGUgdG9rZW4uIFRoaXMgcmVnaXN0ZXJzIHRoZSBmbGFncywgdG8gcHJldmVudCBYUmVnRXhwIGZyb21cbiAqICAgICB0aHJvd2luZyBhbiAndW5rbm93biBmbGFnJyBlcnJvciB3aGVuIGFueSBvZiB0aGUgZmxhZ3MgYXJlIHVzZWQuXG4gKiAgIDxsaT5gcmVwYXJzZWAge0Jvb2xlYW59IFdoZXRoZXIgdGhlIGBoYW5kbGVyYCBmdW5jdGlvbidzIG91dHB1dCBzaG91bGQgbm90IGJlIHRyZWF0ZWQgYXNcbiAqICAgICBmaW5hbCwgYW5kIGluc3RlYWQgYmUgcmVwYXJzZWFibGUgYnkgb3RoZXIgdG9rZW5zIChpbmNsdWRpbmcgdGhlIGN1cnJlbnQgdG9rZW4pLiBBbGxvd3NcbiAqICAgICB0b2tlbiBjaGFpbmluZyBvciBkZWZlcnJpbmcuXG4gKiAgIDxsaT5gbGVhZENoYXJgIHtTdHJpbmd9IFNpbmdsZSBjaGFyYWN0ZXIgdGhhdCBvY2N1cnMgYXQgdGhlIGJlZ2lubmluZyBvZiBhbnkgc3VjY2Vzc2Z1bCBtYXRjaFxuICogICAgIG9mIHRoZSB0b2tlbiAobm90IGFsd2F5cyBhcHBsaWNhYmxlKS4gVGhpcyBkb2Vzbid0IGNoYW5nZSB0aGUgYmVoYXZpb3Igb2YgdGhlIHRva2VuIHVubGVzc1xuICogICAgIHlvdSBwcm92aWRlIGFuIGVycm9uZW91cyB2YWx1ZS4gSG93ZXZlciwgcHJvdmlkaW5nIGl0IGNhbiBpbmNyZWFzZSB0aGUgdG9rZW4ncyBwZXJmb3JtYW5jZS5cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gQmFzaWMgdXNhZ2U6IEFkZCBcXGEgZm9yIHRoZSBBTEVSVCBjb250cm9sIGNvZGVcbiAqIFhSZWdFeHAuYWRkVG9rZW4oXG4gKiAgIC9cXFxcYS8sXG4gKiAgIGZ1bmN0aW9uKCkge3JldHVybiAnXFxcXHgwNyc7fSxcbiAqICAge3Njb3BlOiAnYWxsJ31cbiAqICk7XG4gKiBYUmVnRXhwKCdcXFxcYVtcXFxcYS1cXFxcbl0rJykudGVzdCgnXFx4MDdcXG5cXHgwNycpOyAvLyAtPiB0cnVlXG4gKlxuICogLy8gQWRkIHRoZSBVICh1bmdyZWVkeSkgZmxhZyBmcm9tIFBDUkUgYW5kIFJFMiwgd2hpY2ggcmV2ZXJzZXMgZ3JlZWR5IGFuZCBsYXp5IHF1YW50aWZpZXJzXG4gKiBYUmVnRXhwLmFkZFRva2VuKFxuICogICAvKFs/KitdfHtcXGQrKD86LFxcZCopP30pKFxcPz8pLyxcbiAqICAgZnVuY3Rpb24obWF0Y2gpIHtyZXR1cm4gbWF0Y2hbMV0gKyAobWF0Y2hbMl0gPyAnJyA6ICc/Jyk7fSxcbiAqICAge2ZsYWc6ICdVJ31cbiAqICk7XG4gKiBYUmVnRXhwKCdhKycsICdVJykuZXhlYygnYWFhJylbMF07IC8vIC0+ICdhJ1xuICogWFJlZ0V4cCgnYSs/JywgJ1UnKS5leGVjKCdhYWEnKVswXTsgLy8gLT4gJ2FhYSdcbiAqL1xuICAgIHNlbGYuYWRkVG9rZW4gPSBmdW5jdGlvbihyZWdleCwgaGFuZGxlciwgb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgdmFyIG9wdGlvbmFsRmxhZ3MgPSBvcHRpb25zLm9wdGlvbmFsRmxhZ3MsIGk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuZmxhZykge1xuICAgICAgICAgICAgcmVnaXN0ZXJGbGFnKG9wdGlvbnMuZmxhZyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9uYWxGbGFncykge1xuICAgICAgICAgICAgb3B0aW9uYWxGbGFncyA9IG5hdGl2LnNwbGl0LmNhbGwob3B0aW9uYWxGbGFncywgJycpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG9wdGlvbmFsRmxhZ3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICByZWdpc3RlckZsYWcob3B0aW9uYWxGbGFnc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgdG8gdGhlIHByaXZhdGUgbGlzdCBvZiBzeW50YXggdG9rZW5zXG4gICAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgICAgIHJlZ2V4OiBjb3B5UmVnZXgocmVnZXgsIHtcbiAgICAgICAgICAgICAgICBhZGRHOiB0cnVlLFxuICAgICAgICAgICAgICAgIGFkZFk6IGhhc05hdGl2ZVksXG4gICAgICAgICAgICAgICAgaXNJbnRlcm5hbE9ubHk6IHRydWVcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgaGFuZGxlcjogaGFuZGxlcixcbiAgICAgICAgICAgIHNjb3BlOiBvcHRpb25zLnNjb3BlIHx8IGRlZmF1bHRTY29wZSxcbiAgICAgICAgICAgIGZsYWc6IG9wdGlvbnMuZmxhZyxcbiAgICAgICAgICAgIHJlcGFyc2U6IG9wdGlvbnMucmVwYXJzZSxcbiAgICAgICAgICAgIGxlYWRDaGFyOiBvcHRpb25zLmxlYWRDaGFyXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFJlc2V0IHRoZSBwYXR0ZXJuIGNhY2hlIHVzZWQgYnkgdGhlIGBYUmVnRXhwYCBjb25zdHJ1Y3Rvciwgc2luY2UgdGhlIHNhbWUgcGF0dGVybiBhbmRcbiAgICAgICAgLy8gZmxhZ3MgbWlnaHQgbm93IHByb2R1Y2UgZGlmZmVyZW50IHJlc3VsdHNcbiAgICAgICAgc2VsZi5jYWNoZS5mbHVzaCgncGF0dGVybnMnKTtcbiAgICB9O1xuXG4vKipcbiAqIENhY2hlcyBhbmQgcmV0dXJucyB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYFhSZWdFeHAocGF0dGVybiwgZmxhZ3MpYC4gT24gYW55IHN1YnNlcXVlbnQgY2FsbCB3aXRoXG4gKiB0aGUgc2FtZSBwYXR0ZXJuIGFuZCBmbGFnIGNvbWJpbmF0aW9uLCB0aGUgY2FjaGVkIGNvcHkgb2YgdGhlIHJlZ2V4IGlzIHJldHVybmVkLlxuICpcbiAqIEBtZW1iZXJPZiBYUmVnRXhwXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0dGVybiBSZWdleCBwYXR0ZXJuIHN0cmluZy5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbZmxhZ3NdIEFueSBjb21iaW5hdGlvbiBvZiBYUmVnRXhwIGZsYWdzLlxuICogQHJldHVybnMge1JlZ0V4cH0gQ2FjaGVkIFhSZWdFeHAgb2JqZWN0LlxuICogQGV4YW1wbGVcbiAqXG4gKiB3aGlsZSAobWF0Y2ggPSBYUmVnRXhwLmNhY2hlKCcuJywgJ2dzJykuZXhlYyhzdHIpKSB7XG4gKiAgIC8vIFRoZSByZWdleCBpcyBjb21waWxlZCBvbmNlIG9ubHlcbiAqIH1cbiAqL1xuICAgIHNlbGYuY2FjaGUgPSBmdW5jdGlvbihwYXR0ZXJuLCBmbGFncykge1xuICAgICAgICBpZiAoIXJlZ2V4Q2FjaGVbcGF0dGVybl0pIHtcbiAgICAgICAgICAgIHJlZ2V4Q2FjaGVbcGF0dGVybl0gPSB7fTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVnZXhDYWNoZVtwYXR0ZXJuXVtmbGFnc10gfHwgKFxuICAgICAgICAgICAgcmVnZXhDYWNoZVtwYXR0ZXJuXVtmbGFnc10gPSBzZWxmKHBhdHRlcm4sIGZsYWdzKVxuICAgICAgICApO1xuICAgIH07XG5cbi8vIEludGVudGlvbmFsbHkgdW5kb2N1bWVudGVkXG4gICAgc2VsZi5jYWNoZS5mbHVzaCA9IGZ1bmN0aW9uKGNhY2hlTmFtZSkge1xuICAgICAgICBpZiAoY2FjaGVOYW1lID09PSAncGF0dGVybnMnKSB7XG4gICAgICAgICAgICAvLyBGbHVzaCB0aGUgcGF0dGVybiBjYWNoZSB1c2VkIGJ5IHRoZSBgWFJlZ0V4cGAgY29uc3RydWN0b3JcbiAgICAgICAgICAgIHBhdHRlcm5DYWNoZSA9IHt9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRmx1c2ggdGhlIHJlZ2V4IGNhY2hlIHBvcHVsYXRlZCBieSBgWFJlZ0V4cC5jYWNoZWBcbiAgICAgICAgICAgIHJlZ2V4Q2FjaGUgPSB7fTtcbiAgICAgICAgfVxuICAgIH07XG5cbi8qKlxuICogRXNjYXBlcyBhbnkgcmVndWxhciBleHByZXNzaW9uIG1ldGFjaGFyYWN0ZXJzLCBmb3IgdXNlIHdoZW4gbWF0Y2hpbmcgbGl0ZXJhbCBzdHJpbmdzLiBUaGUgcmVzdWx0XG4gKiBjYW4gc2FmZWx5IGJlIHVzZWQgYXQgYW55IHBvaW50IHdpdGhpbiBhIHJlZ2V4IHRoYXQgdXNlcyBhbnkgZmxhZ3MuXG4gKlxuICogQG1lbWJlck9mIFhSZWdFeHBcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgU3RyaW5nIHRvIGVzY2FwZS5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFN0cmluZyB3aXRoIHJlZ2V4IG1ldGFjaGFyYWN0ZXJzIGVzY2FwZWQuXG4gKiBAZXhhbXBsZVxuICpcbiAqIFhSZWdFeHAuZXNjYXBlKCdFc2NhcGVkPyA8Lj4nKTtcbiAqIC8vIC0+ICdFc2NhcGVkXFw/XFwgPFxcLj4nXG4gKi9cbiAgICBzZWxmLmVzY2FwZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICByZXR1cm4gbmF0aXYucmVwbGFjZS5jYWxsKHRvT2JqZWN0KHN0ciksIC9bLVtcXF17fSgpKis/LixcXFxcXiR8I1xcc10vZywgJ1xcXFwkJicpO1xuICAgIH07XG5cbi8qKlxuICogRXhlY3V0ZXMgYSByZWdleCBzZWFyY2ggaW4gYSBzcGVjaWZpZWQgc3RyaW5nLiBSZXR1cm5zIGEgbWF0Y2ggYXJyYXkgb3IgYG51bGxgLiBJZiB0aGUgcHJvdmlkZWRcbiAqIHJlZ2V4IHVzZXMgbmFtZWQgY2FwdHVyZSwgbmFtZWQgYmFja3JlZmVyZW5jZSBwcm9wZXJ0aWVzIGFyZSBpbmNsdWRlZCBvbiB0aGUgbWF0Y2ggYXJyYXkuXG4gKiBPcHRpb25hbCBgcG9zYCBhbmQgYHN0aWNreWAgYXJndW1lbnRzIHNwZWNpZnkgdGhlIHNlYXJjaCBzdGFydCBwb3NpdGlvbiwgYW5kIHdoZXRoZXIgdGhlIG1hdGNoXG4gKiBtdXN0IHN0YXJ0IGF0IHRoZSBzcGVjaWZpZWQgcG9zaXRpb24gb25seS4gVGhlIGBsYXN0SW5kZXhgIHByb3BlcnR5IG9mIHRoZSBwcm92aWRlZCByZWdleCBpcyBub3RcbiAqIHVzZWQsIGJ1dCBpcyB1cGRhdGVkIGZvciBjb21wYXRpYmlsaXR5LiBBbHNvIGZpeGVzIGJyb3dzZXIgYnVncyBjb21wYXJlZCB0byB0aGUgbmF0aXZlXG4gKiBgUmVnRXhwLnByb3RvdHlwZS5leGVjYCBhbmQgY2FuIGJlIHVzZWQgcmVsaWFibHkgY3Jvc3MtYnJvd3Nlci5cbiAqXG4gKiBAbWVtYmVyT2YgWFJlZ0V4cFxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBTdHJpbmcgdG8gc2VhcmNoLlxuICogQHBhcmFtIHtSZWdFeHB9IHJlZ2V4IFJlZ2V4IHRvIHNlYXJjaCB3aXRoLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtwb3M9MF0gWmVyby1iYXNlZCBpbmRleCBhdCB3aGljaCB0byBzdGFydCB0aGUgc2VhcmNoLlxuICogQHBhcmFtIHtCb29sZWFufFN0cmluZ30gW3N0aWNreT1mYWxzZV0gV2hldGhlciB0aGUgbWF0Y2ggbXVzdCBzdGFydCBhdCB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uXG4gKiAgIG9ubHkuIFRoZSBzdHJpbmcgYCdzdGlja3knYCBpcyBhY2NlcHRlZCBhcyBhbiBhbHRlcm5hdGl2ZSB0byBgdHJ1ZWAuXG4gKiBAcmV0dXJucyB7QXJyYXl9IE1hdGNoIGFycmF5IHdpdGggbmFtZWQgYmFja3JlZmVyZW5jZSBwcm9wZXJ0aWVzLCBvciBgbnVsbGAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIEJhc2ljIHVzZSwgd2l0aCBuYW1lZCBiYWNrcmVmZXJlbmNlXG4gKiB2YXIgbWF0Y2ggPSBYUmVnRXhwLmV4ZWMoJ1UrMjYyMCcsIFhSZWdFeHAoJ1VcXFxcKyg/PGhleD5bMC05QS1GXXs0fSknKSk7XG4gKiBtYXRjaC5oZXg7IC8vIC0+ICcyNjIwJ1xuICpcbiAqIC8vIFdpdGggcG9zIGFuZCBzdGlja3ksIGluIGEgbG9vcFxuICogdmFyIHBvcyA9IDIsIHJlc3VsdCA9IFtdLCBtYXRjaDtcbiAqIHdoaWxlIChtYXRjaCA9IFhSZWdFeHAuZXhlYygnPDE+PDI+PDM+PDQ+NTw2PicsIC88KFxcZCk+LywgcG9zLCAnc3RpY2t5JykpIHtcbiAqICAgcmVzdWx0LnB1c2gobWF0Y2hbMV0pO1xuICogICBwb3MgPSBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcbiAqIH1cbiAqIC8vIHJlc3VsdCAtPiBbJzInLCAnMycsICc0J11cbiAqL1xuICAgIHNlbGYuZXhlYyA9IGZ1bmN0aW9uKHN0ciwgcmVnZXgsIHBvcywgc3RpY2t5KSB7XG4gICAgICAgIHZhciBjYWNoZUtleSA9ICdnJyxcbiAgICAgICAgICAgIGFkZFkgPSBmYWxzZSxcbiAgICAgICAgICAgIG1hdGNoLFxuICAgICAgICAgICAgcjI7XG5cbiAgICAgICAgYWRkWSA9IGhhc05hdGl2ZVkgJiYgISEoc3RpY2t5IHx8IChyZWdleC5zdGlja3kgJiYgc3RpY2t5ICE9PSBmYWxzZSkpO1xuICAgICAgICBpZiAoYWRkWSkge1xuICAgICAgICAgICAgY2FjaGVLZXkgKz0gJ3knO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVnZXhbUkVHRVhfREFUQV0gPSByZWdleFtSRUdFWF9EQVRBXSB8fCB7fTtcblxuICAgICAgICAvLyBTaGFyZXMgY2FjaGVkIGNvcGllcyB3aXRoIGBYUmVnRXhwLm1hdGNoYC9gcmVwbGFjZWBcbiAgICAgICAgcjIgPSByZWdleFtSRUdFWF9EQVRBXVtjYWNoZUtleV0gfHwgKFxuICAgICAgICAgICAgcmVnZXhbUkVHRVhfREFUQV1bY2FjaGVLZXldID0gY29weVJlZ2V4KHJlZ2V4LCB7XG4gICAgICAgICAgICAgICAgYWRkRzogdHJ1ZSxcbiAgICAgICAgICAgICAgICBhZGRZOiBhZGRZLFxuICAgICAgICAgICAgICAgIHJlbW92ZVk6IHN0aWNreSA9PT0gZmFsc2UsXG4gICAgICAgICAgICAgICAgaXNJbnRlcm5hbE9ubHk6IHRydWVcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG5cbiAgICAgICAgcjIubGFzdEluZGV4ID0gcG9zID0gcG9zIHx8IDA7XG5cbiAgICAgICAgLy8gRml4ZWQgYGV4ZWNgIHJlcXVpcmVkIGZvciBgbGFzdEluZGV4YCBmaXgsIG5hbWVkIGJhY2tyZWZlcmVuY2VzLCBldGMuXG4gICAgICAgIG1hdGNoID0gZml4ZWQuZXhlYy5jYWxsKHIyLCBzdHIpO1xuXG4gICAgICAgIGlmIChzdGlja3kgJiYgbWF0Y2ggJiYgbWF0Y2guaW5kZXggIT09IHBvcykge1xuICAgICAgICAgICAgbWF0Y2ggPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlZ2V4Lmdsb2JhbCkge1xuICAgICAgICAgICAgcmVnZXgubGFzdEluZGV4ID0gbWF0Y2ggPyByMi5sYXN0SW5kZXggOiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH07XG5cbi8qKlxuICogRXhlY3V0ZXMgYSBwcm92aWRlZCBmdW5jdGlvbiBvbmNlIHBlciByZWdleCBtYXRjaC5cbiAqXG4gKiBAbWVtYmVyT2YgWFJlZ0V4cFxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBTdHJpbmcgdG8gc2VhcmNoLlxuICogQHBhcmFtIHtSZWdFeHB9IHJlZ2V4IFJlZ2V4IHRvIHNlYXJjaCB3aXRoLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgRnVuY3Rpb24gdG8gZXhlY3V0ZSBmb3IgZWFjaCBtYXRjaC4gSW52b2tlZCB3aXRoIGZvdXIgYXJndW1lbnRzOlxuICogICA8bGk+VGhlIG1hdGNoIGFycmF5LCB3aXRoIG5hbWVkIGJhY2tyZWZlcmVuY2UgcHJvcGVydGllcy5cbiAqICAgPGxpPlRoZSB6ZXJvLWJhc2VkIG1hdGNoIGluZGV4LlxuICogICA8bGk+VGhlIHN0cmluZyBiZWluZyB0cmF2ZXJzZWQuXG4gKiAgIDxsaT5UaGUgcmVnZXggb2JqZWN0IGJlaW5nIHVzZWQgdG8gdHJhdmVyc2UgdGhlIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gRXh0cmFjdHMgZXZlcnkgb3RoZXIgZGlnaXQgZnJvbSBhIHN0cmluZ1xuICogWFJlZ0V4cC5mb3JFYWNoKCcxYTIzNDUnLCAvXFxkLywgZnVuY3Rpb24obWF0Y2gsIGkpIHtcbiAqICAgaWYgKGkgJSAyKSB0aGlzLnB1c2goK21hdGNoWzBdKTtcbiAqIH0sIFtdKTtcbiAqIC8vIC0+IFsyLCA0XVxuICovXG4gICAgc2VsZi5mb3JFYWNoID0gZnVuY3Rpb24oc3RyLCByZWdleCwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHBvcyA9IDAsXG4gICAgICAgICAgICBpID0gLTEsXG4gICAgICAgICAgICBtYXRjaDtcblxuICAgICAgICB3aGlsZSAoKG1hdGNoID0gc2VsZi5leGVjKHN0ciwgcmVnZXgsIHBvcykpKSB7XG4gICAgICAgICAgICAvLyBCZWNhdXNlIGByZWdleGAgaXMgcHJvdmlkZWQgdG8gYGNhbGxiYWNrYCwgdGhlIGZ1bmN0aW9uIGNvdWxkIHVzZSB0aGUgZGVwcmVjYXRlZC9cbiAgICAgICAgICAgIC8vIG5vbnN0YW5kYXJkIGBSZWdFeHAucHJvdG90eXBlLmNvbXBpbGVgIHRvIG11dGF0ZSB0aGUgcmVnZXguIEhvd2V2ZXIsIHNpbmNlXG4gICAgICAgICAgICAvLyBgWFJlZ0V4cC5leGVjYCBkb2Vzbid0IHVzZSBgbGFzdEluZGV4YCB0byBzZXQgdGhlIHNlYXJjaCBwb3NpdGlvbiwgdGhpcyBjYW4ndCBsZWFkXG4gICAgICAgICAgICAvLyB0byBhbiBpbmZpbml0ZSBsb29wLCBhdCBsZWFzdC4gQWN0dWFsbHksIGJlY2F1c2Ugb2YgdGhlIHdheSBgWFJlZ0V4cC5leGVjYCBjYWNoZXNcbiAgICAgICAgICAgIC8vIGdsb2JhbGl6ZWQgdmVyc2lvbnMgb2YgcmVnZXhlcywgbXV0YXRpbmcgdGhlIHJlZ2V4IHdpbGwgbm90IGhhdmUgYW55IGVmZmVjdCBvbiB0aGVcbiAgICAgICAgICAgIC8vIGl0ZXJhdGlvbiBvciBtYXRjaGVkIHN0cmluZ3MsIHdoaWNoIGlzIGEgbmljZSBzaWRlIGVmZmVjdCB0aGF0IGJyaW5ncyBleHRyYSBzYWZldHlcbiAgICAgICAgICAgIGNhbGxiYWNrKG1hdGNoLCArK2ksIHN0ciwgcmVnZXgpO1xuXG4gICAgICAgICAgICBwb3MgPSBtYXRjaC5pbmRleCArIChtYXRjaFswXS5sZW5ndGggfHwgMSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4vKipcbiAqIENvcGllcyBhIHJlZ2V4IG9iamVjdCBhbmQgYWRkcyBmbGFnIGBnYC4gVGhlIGNvcHkgbWFpbnRhaW5zIGV4dGVuZGVkIGRhdGEsIGlzIGF1Z21lbnRlZCB3aXRoXG4gKiBgWFJlZ0V4cC5wcm90b3R5cGVgIHByb3BlcnRpZXMsIGFuZCBoYXMgYSBmcmVzaCBgbGFzdEluZGV4YCBwcm9wZXJ0eSAoc2V0IHRvIHplcm8pLiBOYXRpdmVcbiAqIHJlZ2V4ZXMgYXJlIG5vdCByZWNvbXBpbGVkIHVzaW5nIFhSZWdFeHAgc3ludGF4LlxuICpcbiAqIEBtZW1iZXJPZiBYUmVnRXhwXG4gKiBAcGFyYW0ge1JlZ0V4cH0gcmVnZXggUmVnZXggdG8gZ2xvYmFsaXplLlxuICogQHJldHVybnMge1JlZ0V4cH0gQ29weSBvZiB0aGUgcHJvdmlkZWQgcmVnZXggd2l0aCBmbGFnIGBnYCBhZGRlZC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIGdsb2JhbENvcHkgPSBYUmVnRXhwLmdsb2JhbGl6ZSgvcmVnZXgvKTtcbiAqIGdsb2JhbENvcHkuZ2xvYmFsOyAvLyAtPiB0cnVlXG4gKi9cbiAgICBzZWxmLmdsb2JhbGl6ZSA9IGZ1bmN0aW9uKHJlZ2V4KSB7XG4gICAgICAgIHJldHVybiBjb3B5UmVnZXgocmVnZXgsIHthZGRHOiB0cnVlfSk7XG4gICAgfTtcblxuLyoqXG4gKiBJbnN0YWxscyBvcHRpb25hbCBmZWF0dXJlcyBhY2NvcmRpbmcgdG8gdGhlIHNwZWNpZmllZCBvcHRpb25zLiBDYW4gYmUgdW5kb25lIHVzaW5nXG4gKiB7QGxpbmsgI1hSZWdFeHAudW5pbnN0YWxsfS5cbiAqXG4gKiBAbWVtYmVyT2YgWFJlZ0V4cFxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0IG9yIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gV2l0aCBhbiBvcHRpb25zIG9iamVjdFxuICogWFJlZ0V4cC5pbnN0YWxsKHtcbiAqICAgLy8gRW5hYmxlcyBzdXBwb3J0IGZvciBhc3RyYWwgY29kZSBwb2ludHMgaW4gVW5pY29kZSBhZGRvbnMgKGltcGxpY2l0bHkgc2V0cyBmbGFnIEEpXG4gKiAgIGFzdHJhbDogdHJ1ZSxcbiAqXG4gKiAgIC8vIE92ZXJyaWRlcyBuYXRpdmUgcmVnZXggbWV0aG9kcyB3aXRoIGZpeGVkL2V4dGVuZGVkIHZlcnNpb25zIHRoYXQgc3VwcG9ydCBuYW1lZFxuICogICAvLyBiYWNrcmVmZXJlbmNlcyBhbmQgZml4IG51bWVyb3VzIGNyb3NzLWJyb3dzZXIgYnVnc1xuICogICBuYXRpdmVzOiB0cnVlXG4gKiB9KTtcbiAqXG4gKiAvLyBXaXRoIGFuIG9wdGlvbnMgc3RyaW5nXG4gKiBYUmVnRXhwLmluc3RhbGwoJ2FzdHJhbCBuYXRpdmVzJyk7XG4gKi9cbiAgICBzZWxmLmluc3RhbGwgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBwcmVwYXJlT3B0aW9ucyhvcHRpb25zKTtcblxuICAgICAgICBpZiAoIWZlYXR1cmVzLmFzdHJhbCAmJiBvcHRpb25zLmFzdHJhbCkge1xuICAgICAgICAgICAgc2V0QXN0cmFsKHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFmZWF0dXJlcy5uYXRpdmVzICYmIG9wdGlvbnMubmF0aXZlcykge1xuICAgICAgICAgICAgc2V0TmF0aXZlcyh0cnVlKTtcbiAgICAgICAgfVxuICAgIH07XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgYW4gaW5kaXZpZHVhbCBvcHRpb25hbCBmZWF0dXJlIGlzIGluc3RhbGxlZC5cbiAqXG4gKiBAbWVtYmVyT2YgWFJlZ0V4cFxuICogQHBhcmFtIHtTdHJpbmd9IGZlYXR1cmUgTmFtZSBvZiB0aGUgZmVhdHVyZSB0byBjaGVjay4gT25lIG9mOlxuICogICA8bGk+YG5hdGl2ZXNgXG4gKiAgIDxsaT5gYXN0cmFsYFxuICogQHJldHVybnMge0Jvb2xlYW59IFdoZXRoZXIgdGhlIGZlYXR1cmUgaXMgaW5zdGFsbGVkLlxuICogQGV4YW1wbGVcbiAqXG4gKiBYUmVnRXhwLmlzSW5zdGFsbGVkKCduYXRpdmVzJyk7XG4gKi9cbiAgICBzZWxmLmlzSW5zdGFsbGVkID0gZnVuY3Rpb24oZmVhdHVyZSkge1xuICAgICAgICByZXR1cm4gISEoZmVhdHVyZXNbZmVhdHVyZV0pO1xuICAgIH07XG5cbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgYW4gb2JqZWN0IGlzIGEgcmVnZXg7IGBmYWxzZWAgaWYgaXQgaXNuJ3QuIFRoaXMgd29ya3MgY29ycmVjdGx5IGZvciByZWdleGVzXG4gKiBjcmVhdGVkIGluIGFub3RoZXIgZnJhbWUsIHdoZW4gYGluc3RhbmNlb2ZgIGFuZCBgY29uc3RydWN0b3JgIGNoZWNrcyB3b3VsZCBmYWlsLlxuICpcbiAqIEBtZW1iZXJPZiBYUmVnRXhwXG4gKiBAcGFyYW0geyp9IHZhbHVlIE9iamVjdCB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBXaGV0aGVyIHRoZSBvYmplY3QgaXMgYSBgUmVnRXhwYCBvYmplY3QuXG4gKiBAZXhhbXBsZVxuICpcbiAqIFhSZWdFeHAuaXNSZWdFeHAoJ3N0cmluZycpOyAvLyAtPiBmYWxzZVxuICogWFJlZ0V4cC5pc1JlZ0V4cCgvcmVnZXgvaSk7IC8vIC0+IHRydWVcbiAqIFhSZWdFeHAuaXNSZWdFeHAoUmVnRXhwKCdeJywgJ20nKSk7IC8vIC0+IHRydWVcbiAqIFhSZWdFeHAuaXNSZWdFeHAoWFJlZ0V4cCgnKD9zKS4nKSk7IC8vIC0+IHRydWVcbiAqL1xuICAgIHNlbGYuaXNSZWdFeHAgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xuICAgICAgICAvL3JldHVybiBpc1R5cGUodmFsdWUsICdSZWdFeHAnKTtcbiAgICB9O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGZpcnN0IG1hdGNoZWQgc3RyaW5nLCBvciBpbiBnbG9iYWwgbW9kZSwgYW4gYXJyYXkgY29udGFpbmluZyBhbGwgbWF0Y2hlZCBzdHJpbmdzLlxuICogVGhpcyBpcyBlc3NlbnRpYWxseSBhIG1vcmUgY29udmVuaWVudCByZS1pbXBsZW1lbnRhdGlvbiBvZiBgU3RyaW5nLnByb3RvdHlwZS5tYXRjaGAgdGhhdCBnaXZlc1xuICogdGhlIHJlc3VsdCB0eXBlcyB5b3UgYWN0dWFsbHkgd2FudCAoc3RyaW5nIGluc3RlYWQgb2YgYGV4ZWNgLXN0eWxlIGFycmF5IGluIG1hdGNoLWZpcnN0IG1vZGUsXG4gKiBhbmQgYW4gZW1wdHkgYXJyYXkgaW5zdGVhZCBvZiBgbnVsbGAgd2hlbiBubyBtYXRjaGVzIGFyZSBmb3VuZCBpbiBtYXRjaC1hbGwgbW9kZSkuIEl0IGFsc28gbGV0c1xuICogeW91IG92ZXJyaWRlIGZsYWcgZyBhbmQgaWdub3JlIGBsYXN0SW5kZXhgLCBhbmQgZml4ZXMgYnJvd3NlciBidWdzLlxuICpcbiAqIEBtZW1iZXJPZiBYUmVnRXhwXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFN0cmluZyB0byBzZWFyY2guXG4gKiBAcGFyYW0ge1JlZ0V4cH0gcmVnZXggUmVnZXggdG8gc2VhcmNoIHdpdGguXG4gKiBAcGFyYW0ge1N0cmluZ30gW3Njb3BlPSdvbmUnXSBVc2UgJ29uZScgdG8gcmV0dXJuIHRoZSBmaXJzdCBtYXRjaCBhcyBhIHN0cmluZy4gVXNlICdhbGwnIHRvXG4gKiAgIHJldHVybiBhbiBhcnJheSBvZiBhbGwgbWF0Y2hlZCBzdHJpbmdzLiBJZiBub3QgZXhwbGljaXRseSBzcGVjaWZpZWQgYW5kIGByZWdleGAgdXNlcyBmbGFnIGcsXG4gKiAgIGBzY29wZWAgaXMgJ2FsbCcuXG4gKiBAcmV0dXJucyB7U3RyaW5nfEFycmF5fSBJbiBtYXRjaC1maXJzdCBtb2RlOiBGaXJzdCBtYXRjaCBhcyBhIHN0cmluZywgb3IgYG51bGxgLiBJbiBtYXRjaC1hbGxcbiAqICAgbW9kZTogQXJyYXkgb2YgYWxsIG1hdGNoZWQgc3RyaW5ncywgb3IgYW4gZW1wdHkgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIE1hdGNoIGZpcnN0XG4gKiBYUmVnRXhwLm1hdGNoKCdhYmMnLCAvXFx3Lyk7IC8vIC0+ICdhJ1xuICogWFJlZ0V4cC5tYXRjaCgnYWJjJywgL1xcdy9nLCAnb25lJyk7IC8vIC0+ICdhJ1xuICogWFJlZ0V4cC5tYXRjaCgnYWJjJywgL3gvZywgJ29uZScpOyAvLyAtPiBudWxsXG4gKlxuICogLy8gTWF0Y2ggYWxsXG4gKiBYUmVnRXhwLm1hdGNoKCdhYmMnLCAvXFx3L2cpOyAvLyAtPiBbJ2EnLCAnYicsICdjJ11cbiAqIFhSZWdFeHAubWF0Y2goJ2FiYycsIC9cXHcvLCAnYWxsJyk7IC8vIC0+IFsnYScsICdiJywgJ2MnXVxuICogWFJlZ0V4cC5tYXRjaCgnYWJjJywgL3gvLCAnYWxsJyk7IC8vIC0+IFtdXG4gKi9cbiAgICBzZWxmLm1hdGNoID0gZnVuY3Rpb24oc3RyLCByZWdleCwgc2NvcGUpIHtcbiAgICAgICAgdmFyIGdsb2JhbCA9IChyZWdleC5nbG9iYWwgJiYgc2NvcGUgIT09ICdvbmUnKSB8fCBzY29wZSA9PT0gJ2FsbCcsXG4gICAgICAgICAgICBjYWNoZUtleSA9ICgoZ2xvYmFsID8gJ2cnIDogJycpICsgKHJlZ2V4LnN0aWNreSA/ICd5JyA6ICcnKSkgfHwgJ25vR1knLFxuICAgICAgICAgICAgcmVzdWx0LFxuICAgICAgICAgICAgcjI7XG5cbiAgICAgICAgcmVnZXhbUkVHRVhfREFUQV0gPSByZWdleFtSRUdFWF9EQVRBXSB8fCB7fTtcblxuICAgICAgICAvLyBTaGFyZXMgY2FjaGVkIGNvcGllcyB3aXRoIGBYUmVnRXhwLmV4ZWNgL2ByZXBsYWNlYFxuICAgICAgICByMiA9IHJlZ2V4W1JFR0VYX0RBVEFdW2NhY2hlS2V5XSB8fCAoXG4gICAgICAgICAgICByZWdleFtSRUdFWF9EQVRBXVtjYWNoZUtleV0gPSBjb3B5UmVnZXgocmVnZXgsIHtcbiAgICAgICAgICAgICAgICBhZGRHOiAhIWdsb2JhbCxcbiAgICAgICAgICAgICAgICBhZGRZOiAhIXJlZ2V4LnN0aWNreSxcbiAgICAgICAgICAgICAgICByZW1vdmVHOiBzY29wZSA9PT0gJ29uZScsXG4gICAgICAgICAgICAgICAgaXNJbnRlcm5hbE9ubHk6IHRydWVcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG5cbiAgICAgICAgcmVzdWx0ID0gbmF0aXYubWF0Y2guY2FsbCh0b09iamVjdChzdHIpLCByMik7XG5cbiAgICAgICAgaWYgKHJlZ2V4Lmdsb2JhbCkge1xuICAgICAgICAgICAgcmVnZXgubGFzdEluZGV4ID0gKFxuICAgICAgICAgICAgICAgIChzY29wZSA9PT0gJ29uZScgJiYgcmVzdWx0KSA/XG4gICAgICAgICAgICAgICAgICAgIC8vIENhbid0IHVzZSBgcjIubGFzdEluZGV4YCBzaW5jZSBgcjJgIGlzIG5vbmdsb2JhbCBpbiB0aGlzIGNhc2VcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VsdC5pbmRleCArIHJlc3VsdFswXS5sZW5ndGgpIDogMFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBnbG9iYWwgPyAocmVzdWx0IHx8IFtdKSA6IChyZXN1bHQgJiYgcmVzdWx0WzBdKTtcbiAgICB9O1xuXG4vKipcbiAqIFJldHJpZXZlcyB0aGUgbWF0Y2hlcyBmcm9tIHNlYXJjaGluZyBhIHN0cmluZyB1c2luZyBhIGNoYWluIG9mIHJlZ2V4ZXMgdGhhdCBzdWNjZXNzaXZlbHkgc2VhcmNoXG4gKiB3aXRoaW4gcHJldmlvdXMgbWF0Y2hlcy4gVGhlIHByb3ZpZGVkIGBjaGFpbmAgYXJyYXkgY2FuIGNvbnRhaW4gcmVnZXhlcyBhbmQgb2JqZWN0cyB3aXRoIGByZWdleGBcbiAqIGFuZCBgYmFja3JlZmAgcHJvcGVydGllcy4gV2hlbiBhIGJhY2tyZWZlcmVuY2UgaXMgc3BlY2lmaWVkLCB0aGUgbmFtZWQgb3IgbnVtYmVyZWQgYmFja3JlZmVyZW5jZVxuICogaXMgcGFzc2VkIGZvcndhcmQgdG8gdGhlIG5leHQgcmVnZXggb3IgcmV0dXJuZWQuXG4gKlxuICogQG1lbWJlck9mIFhSZWdFeHBcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgU3RyaW5nIHRvIHNlYXJjaC5cbiAqIEBwYXJhbSB7QXJyYXl9IGNoYWluIFJlZ2V4ZXMgdGhhdCBlYWNoIHNlYXJjaCBmb3IgbWF0Y2hlcyB3aXRoaW4gcHJlY2VkaW5nIHJlc3VsdHMuXG4gKiBAcmV0dXJucyB7QXJyYXl9IE1hdGNoZXMgYnkgdGhlIGxhc3QgcmVnZXggaW4gdGhlIGNoYWluLCBvciBhbiBlbXB0eSBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gQmFzaWMgdXNhZ2U7IG1hdGNoZXMgbnVtYmVycyB3aXRoaW4gPGI+IHRhZ3NcbiAqIFhSZWdFeHAubWF0Y2hDaGFpbignMSA8Yj4yPC9iPiAzIDxiPjQgYSA1NjwvYj4nLCBbXG4gKiAgIFhSZWdFeHAoJyg/aXMpPGI+Lio/PC9iPicpLFxuICogICAvXFxkKy9cbiAqIF0pO1xuICogLy8gLT4gWycyJywgJzQnLCAnNTYnXVxuICpcbiAqIC8vIFBhc3NpbmcgZm9yd2FyZCBhbmQgcmV0dXJuaW5nIHNwZWNpZmljIGJhY2tyZWZlcmVuY2VzXG4gKiBodG1sID0gJzxhIGhyZWY9XCJodHRwOi8veHJlZ2V4cC5jb20vYXBpL1wiPlhSZWdFeHA8L2E+XFxcbiAqICAgICAgICAgPGEgaHJlZj1cImh0dHA6Ly93d3cuZ29vZ2xlLmNvbS9cIj5Hb29nbGU8L2E+JztcbiAqIFhSZWdFeHAubWF0Y2hDaGFpbihodG1sLCBbXG4gKiAgIHtyZWdleDogLzxhIGhyZWY9XCIoW15cIl0rKVwiPi9pLCBiYWNrcmVmOiAxfSxcbiAqICAge3JlZ2V4OiBYUmVnRXhwKCcoP2kpXmh0dHBzPzovLyg/PGRvbWFpbj5bXi8/I10rKScpLCBiYWNrcmVmOiAnZG9tYWluJ31cbiAqIF0pO1xuICogLy8gLT4gWyd4cmVnZXhwLmNvbScsICd3d3cuZ29vZ2xlLmNvbSddXG4gKi9cbiAgICBzZWxmLm1hdGNoQ2hhaW4gPSBmdW5jdGlvbihzdHIsIGNoYWluKSB7XG4gICAgICAgIHJldHVybiAoZnVuY3Rpb24gcmVjdXJzZUNoYWluKHZhbHVlcywgbGV2ZWwpIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gY2hhaW5bbGV2ZWxdLnJlZ2V4ID8gY2hhaW5bbGV2ZWxdIDoge3JlZ2V4OiBjaGFpbltsZXZlbF19LFxuICAgICAgICAgICAgICAgIG1hdGNoZXMgPSBbXSxcbiAgICAgICAgICAgICAgICBhZGRNYXRjaCA9IGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLmJhY2tyZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIFNhZmFyaSA0LjAuNSAoYnV0IG5vdCA1LjAuNSspIGluYXBwcm9wcmlhdGVseSB1c2VzIHNwYXJzZSBhcnJheXMgdG8gaG9sZFxuICAgICAgICAgICAgICAgICAgICAgICAgICogdGhlIGB1bmRlZmluZWRgcyBmb3IgYmFja3JlZmVyZW5jZXMgdG8gbm9ucGFydGljaXBhdGluZyBjYXB0dXJpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIGdyb3Vwcy4gSW4gc3VjaCBjYXNlcywgYSBgaGFzT3duUHJvcGVydHlgIG9yIGBpbmAgY2hlY2sgb24gaXRzIG93biB3b3VsZFxuICAgICAgICAgICAgICAgICAgICAgICAgICogaW5hcHByb3ByaWF0ZWx5IHRocm93IHRoZSBleGNlcHRpb24sIHNvIGFsc28gY2hlY2sgaWYgdGhlIGJhY2tyZWZlcmVuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIGlzIGEgbnVtYmVyIHRoYXQgaXMgd2l0aGluIHRoZSBib3VuZHMgb2YgdGhlIGFycmF5LlxuICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShtYXRjaC5oYXNPd25Qcm9wZXJ0eShpdGVtLmJhY2tyZWYpIHx8ICtpdGVtLmJhY2tyZWYgPCBtYXRjaC5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKCdCYWNrcmVmZXJlbmNlIHRvIHVuZGVmaW5lZCBncm91cDogJyArIGl0ZW0uYmFja3JlZik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXMucHVzaChtYXRjaFtpdGVtLmJhY2tyZWZdIHx8ICcnKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXMucHVzaChtYXRjaFswXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGk7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmZvckVhY2godmFsdWVzW2ldLCBpdGVtLnJlZ2V4LCBhZGRNYXRjaCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAoKGxldmVsID09PSBjaGFpbi5sZW5ndGggLSAxKSB8fCAhbWF0Y2hlcy5sZW5ndGgpID9cbiAgICAgICAgICAgICAgICBtYXRjaGVzIDpcbiAgICAgICAgICAgICAgICByZWN1cnNlQ2hhaW4obWF0Y2hlcywgbGV2ZWwgKyAxKTtcbiAgICAgICAgfShbc3RyXSwgMCkpO1xuICAgIH07XG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBzdHJpbmcgd2l0aCBvbmUgb3IgYWxsIG1hdGNoZXMgb2YgYSBwYXR0ZXJuIHJlcGxhY2VkLiBUaGUgcGF0dGVybiBjYW4gYmUgYSBzdHJpbmdcbiAqIG9yIHJlZ2V4LCBhbmQgdGhlIHJlcGxhY2VtZW50IGNhbiBiZSBhIHN0cmluZyBvciBhIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBmb3IgZWFjaCBtYXRjaC4gVG9cbiAqIHBlcmZvcm0gYSBnbG9iYWwgc2VhcmNoIGFuZCByZXBsYWNlLCB1c2UgdGhlIG9wdGlvbmFsIGBzY29wZWAgYXJndW1lbnQgb3IgaW5jbHVkZSBmbGFnIGcgaWYgdXNpbmdcbiAqIGEgcmVnZXguIFJlcGxhY2VtZW50IHN0cmluZ3MgY2FuIHVzZSBgJHtufWAgZm9yIG5hbWVkIGFuZCBudW1iZXJlZCBiYWNrcmVmZXJlbmNlcy4gUmVwbGFjZW1lbnRcbiAqIGZ1bmN0aW9ucyBjYW4gdXNlIG5hbWVkIGJhY2tyZWZlcmVuY2VzIHZpYSBgYXJndW1lbnRzWzBdLm5hbWVgLiBBbHNvIGZpeGVzIGJyb3dzZXIgYnVncyBjb21wYXJlZFxuICogdG8gdGhlIG5hdGl2ZSBgU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlYCBhbmQgY2FuIGJlIHVzZWQgcmVsaWFibHkgY3Jvc3MtYnJvd3Nlci5cbiAqXG4gKiBAbWVtYmVyT2YgWFJlZ0V4cFxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBTdHJpbmcgdG8gc2VhcmNoLlxuICogQHBhcmFtIHtSZWdFeHB8U3RyaW5nfSBzZWFyY2ggU2VhcmNoIHBhdHRlcm4gdG8gYmUgcmVwbGFjZWQuXG4gKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gcmVwbGFjZW1lbnQgUmVwbGFjZW1lbnQgc3RyaW5nIG9yIGEgZnVuY3Rpb24gaW52b2tlZCB0byBjcmVhdGUgaXQuXG4gKiAgIFJlcGxhY2VtZW50IHN0cmluZ3MgY2FuIGluY2x1ZGUgc3BlY2lhbCByZXBsYWNlbWVudCBzeW50YXg6XG4gKiAgICAgPGxpPiQkIC0gSW5zZXJ0cyBhIGxpdGVyYWwgJCBjaGFyYWN0ZXIuXG4gKiAgICAgPGxpPiQmLCAkMCAtIEluc2VydHMgdGhlIG1hdGNoZWQgc3Vic3RyaW5nLlxuICogICAgIDxsaT4kYCAtIEluc2VydHMgdGhlIHN0cmluZyB0aGF0IHByZWNlZGVzIHRoZSBtYXRjaGVkIHN1YnN0cmluZyAobGVmdCBjb250ZXh0KS5cbiAqICAgICA8bGk+JCcgLSBJbnNlcnRzIHRoZSBzdHJpbmcgdGhhdCBmb2xsb3dzIHRoZSBtYXRjaGVkIHN1YnN0cmluZyAocmlnaHQgY29udGV4dCkuXG4gKiAgICAgPGxpPiRuLCAkbm4gLSBXaGVyZSBuL25uIGFyZSBkaWdpdHMgcmVmZXJlbmNpbmcgYW4gZXhpc3RlbnQgY2FwdHVyaW5nIGdyb3VwLCBpbnNlcnRzXG4gKiAgICAgICBiYWNrcmVmZXJlbmNlIG4vbm4uXG4gKiAgICAgPGxpPiR7bn0gLSBXaGVyZSBuIGlzIGEgbmFtZSBvciBhbnkgbnVtYmVyIG9mIGRpZ2l0cyB0aGF0IHJlZmVyZW5jZSBhbiBleGlzdGVudCBjYXB0dXJpbmdcbiAqICAgICAgIGdyb3VwLCBpbnNlcnRzIGJhY2tyZWZlcmVuY2Ugbi5cbiAqICAgUmVwbGFjZW1lbnQgZnVuY3Rpb25zIGFyZSBpbnZva2VkIHdpdGggdGhyZWUgb3IgbW9yZSBhcmd1bWVudHM6XG4gKiAgICAgPGxpPlRoZSBtYXRjaGVkIHN1YnN0cmluZyAoY29ycmVzcG9uZHMgdG8gJCYgYWJvdmUpLiBOYW1lZCBiYWNrcmVmZXJlbmNlcyBhcmUgYWNjZXNzaWJsZSBhc1xuICogICAgICAgcHJvcGVydGllcyBvZiB0aGlzIGZpcnN0IGFyZ3VtZW50LlxuICogICAgIDxsaT4wLi5uIGFyZ3VtZW50cywgb25lIGZvciBlYWNoIGJhY2tyZWZlcmVuY2UgKGNvcnJlc3BvbmRpbmcgdG8gJDEsICQyLCBldGMuIGFib3ZlKS5cbiAqICAgICA8bGk+VGhlIHplcm8tYmFzZWQgaW5kZXggb2YgdGhlIG1hdGNoIHdpdGhpbiB0aGUgdG90YWwgc2VhcmNoIHN0cmluZy5cbiAqICAgICA8bGk+VGhlIHRvdGFsIHN0cmluZyBiZWluZyBzZWFyY2hlZC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbc2NvcGU9J29uZSddIFVzZSAnb25lJyB0byByZXBsYWNlIHRoZSBmaXJzdCBtYXRjaCBvbmx5LCBvciAnYWxsJy4gSWYgbm90XG4gKiAgIGV4cGxpY2l0bHkgc3BlY2lmaWVkIGFuZCB1c2luZyBhIHJlZ2V4IHdpdGggZmxhZyBnLCBgc2NvcGVgIGlzICdhbGwnLlxuICogQHJldHVybnMge1N0cmluZ30gTmV3IHN0cmluZyB3aXRoIG9uZSBvciBhbGwgbWF0Y2hlcyByZXBsYWNlZC5cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gUmVnZXggc2VhcmNoLCB1c2luZyBuYW1lZCBiYWNrcmVmZXJlbmNlcyBpbiByZXBsYWNlbWVudCBzdHJpbmdcbiAqIHZhciBuYW1lID0gWFJlZ0V4cCgnKD88Zmlyc3Q+XFxcXHcrKSAoPzxsYXN0PlxcXFx3KyknKTtcbiAqIFhSZWdFeHAucmVwbGFjZSgnSm9obiBTbWl0aCcsIG5hbWUsICcke2xhc3R9LCAke2ZpcnN0fScpO1xuICogLy8gLT4gJ1NtaXRoLCBKb2huJ1xuICpcbiAqIC8vIFJlZ2V4IHNlYXJjaCwgdXNpbmcgbmFtZWQgYmFja3JlZmVyZW5jZXMgaW4gcmVwbGFjZW1lbnQgZnVuY3Rpb25cbiAqIFhSZWdFeHAucmVwbGFjZSgnSm9obiBTbWl0aCcsIG5hbWUsIGZ1bmN0aW9uKG1hdGNoKSB7XG4gKiAgIHJldHVybiBtYXRjaC5sYXN0ICsgJywgJyArIG1hdGNoLmZpcnN0O1xuICogfSk7XG4gKiAvLyAtPiAnU21pdGgsIEpvaG4nXG4gKlxuICogLy8gU3RyaW5nIHNlYXJjaCwgd2l0aCByZXBsYWNlLWFsbFxuICogWFJlZ0V4cC5yZXBsYWNlKCdSZWdFeHAgYnVpbGRzIFJlZ0V4cHMnLCAnUmVnRXhwJywgJ1hSZWdFeHAnLCAnYWxsJyk7XG4gKiAvLyAtPiAnWFJlZ0V4cCBidWlsZHMgWFJlZ0V4cHMnXG4gKi9cbiAgICBzZWxmLnJlcGxhY2UgPSBmdW5jdGlvbihzdHIsIHNlYXJjaCwgcmVwbGFjZW1lbnQsIHNjb3BlKSB7XG4gICAgICAgIHZhciBpc1JlZ2V4ID0gc2VsZi5pc1JlZ0V4cChzZWFyY2gpLFxuICAgICAgICAgICAgZ2xvYmFsID0gKHNlYXJjaC5nbG9iYWwgJiYgc2NvcGUgIT09ICdvbmUnKSB8fCBzY29wZSA9PT0gJ2FsbCcsXG4gICAgICAgICAgICBjYWNoZUtleSA9ICgoZ2xvYmFsID8gJ2cnIDogJycpICsgKHNlYXJjaC5zdGlja3kgPyAneScgOiAnJykpIHx8ICdub0dZJyxcbiAgICAgICAgICAgIHMyID0gc2VhcmNoLFxuICAgICAgICAgICAgcmVzdWx0O1xuXG4gICAgICAgIGlmIChpc1JlZ2V4KSB7XG4gICAgICAgICAgICBzZWFyY2hbUkVHRVhfREFUQV0gPSBzZWFyY2hbUkVHRVhfREFUQV0gfHwge307XG5cbiAgICAgICAgICAgIC8vIFNoYXJlcyBjYWNoZWQgY29waWVzIHdpdGggYFhSZWdFeHAuZXhlY2AvYG1hdGNoYC4gU2luY2UgYSBjb3B5IGlzIHVzZWQsIGBzZWFyY2hgJ3NcbiAgICAgICAgICAgIC8vIGBsYXN0SW5kZXhgIGlzbid0IHVwZGF0ZWQgKmR1cmluZyogcmVwbGFjZW1lbnQgaXRlcmF0aW9uc1xuICAgICAgICAgICAgczIgPSBzZWFyY2hbUkVHRVhfREFUQV1bY2FjaGVLZXldIHx8IChcbiAgICAgICAgICAgICAgICBzZWFyY2hbUkVHRVhfREFUQV1bY2FjaGVLZXldID0gY29weVJlZ2V4KHNlYXJjaCwge1xuICAgICAgICAgICAgICAgICAgICBhZGRHOiAhIWdsb2JhbCxcbiAgICAgICAgICAgICAgICAgICAgYWRkWTogISFzZWFyY2guc3RpY2t5LFxuICAgICAgICAgICAgICAgICAgICByZW1vdmVHOiBzY29wZSA9PT0gJ29uZScsXG4gICAgICAgICAgICAgICAgICAgIGlzSW50ZXJuYWxPbmx5OiB0cnVlXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAoZ2xvYmFsKSB7XG4gICAgICAgICAgICBzMiA9IG5ldyBSZWdFeHAoc2VsZi5lc2NhcGUoU3RyaW5nKHNlYXJjaCkpLCAnZycpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRml4ZWQgYHJlcGxhY2VgIHJlcXVpcmVkIGZvciBuYW1lZCBiYWNrcmVmZXJlbmNlcywgZXRjLlxuICAgICAgICByZXN1bHQgPSBmaXhlZC5yZXBsYWNlLmNhbGwodG9PYmplY3Qoc3RyKSwgczIsIHJlcGxhY2VtZW50KTtcblxuICAgICAgICBpZiAoaXNSZWdleCAmJiBzZWFyY2guZ2xvYmFsKSB7XG4gICAgICAgICAgICAvLyBGaXhlcyBJRSwgU2FmYXJpIGJ1ZyAobGFzdCB0ZXN0ZWQgSUUgOSwgU2FmYXJpIDUuMSlcbiAgICAgICAgICAgIHNlYXJjaC5sYXN0SW5kZXggPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4vKipcbiAqIFBlcmZvcm1zIGJhdGNoIHByb2Nlc3Npbmcgb2Ygc3RyaW5nIHJlcGxhY2VtZW50cy4gVXNlZCBsaWtlIHtAbGluayAjWFJlZ0V4cC5yZXBsYWNlfSwgYnV0XG4gKiBhY2NlcHRzIGFuIGFycmF5IG9mIHJlcGxhY2VtZW50IGRldGFpbHMuIExhdGVyIHJlcGxhY2VtZW50cyBvcGVyYXRlIG9uIHRoZSBvdXRwdXQgb2YgZWFybGllclxuICogcmVwbGFjZW1lbnRzLiBSZXBsYWNlbWVudCBkZXRhaWxzIGFyZSBhY2NlcHRlZCBhcyBhbiBhcnJheSB3aXRoIGEgcmVnZXggb3Igc3RyaW5nIHRvIHNlYXJjaCBmb3IsXG4gKiB0aGUgcmVwbGFjZW1lbnQgc3RyaW5nIG9yIGZ1bmN0aW9uLCBhbmQgYW4gb3B0aW9uYWwgc2NvcGUgb2YgJ29uZScgb3IgJ2FsbCcuIFVzZXMgdGhlIFhSZWdFeHBcbiAqIHJlcGxhY2VtZW50IHRleHQgc3ludGF4LCB3aGljaCBzdXBwb3J0cyBuYW1lZCBiYWNrcmVmZXJlbmNlIHByb3BlcnRpZXMgdmlhIGAke25hbWV9YC5cbiAqXG4gKiBAbWVtYmVyT2YgWFJlZ0V4cFxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBTdHJpbmcgdG8gc2VhcmNoLlxuICogQHBhcmFtIHtBcnJheX0gcmVwbGFjZW1lbnRzIEFycmF5IG9mIHJlcGxhY2VtZW50IGRldGFpbCBhcnJheXMuXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBOZXcgc3RyaW5nIHdpdGggYWxsIHJlcGxhY2VtZW50cy5cbiAqIEBleGFtcGxlXG4gKlxuICogc3RyID0gWFJlZ0V4cC5yZXBsYWNlRWFjaChzdHIsIFtcbiAqICAgW1hSZWdFeHAoJyg/PG5hbWU+YSknKSwgJ3oke25hbWV9J10sXG4gKiAgIFsvYi9naSwgJ3knXSxcbiAqICAgWy9jL2csICd4JywgJ29uZSddLCAvLyBzY29wZSAnb25lJyBvdmVycmlkZXMgL2dcbiAqICAgWy9kLywgJ3cnLCAnYWxsJ10sICAvLyBzY29wZSAnYWxsJyBvdmVycmlkZXMgbGFjayBvZiAvZ1xuICogICBbJ2UnLCAndicsICdhbGwnXSwgIC8vIHNjb3BlICdhbGwnIGFsbG93cyByZXBsYWNlLWFsbCBmb3Igc3RyaW5nc1xuICogICBbL2YvZywgZnVuY3Rpb24oJDApIHtcbiAqICAgICByZXR1cm4gJDAudG9VcHBlckNhc2UoKTtcbiAqICAgfV1cbiAqIF0pO1xuICovXG4gICAgc2VsZi5yZXBsYWNlRWFjaCA9IGZ1bmN0aW9uKHN0ciwgcmVwbGFjZW1lbnRzKSB7XG4gICAgICAgIHZhciBpLCByO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCByZXBsYWNlbWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHIgPSByZXBsYWNlbWVudHNbaV07XG4gICAgICAgICAgICBzdHIgPSBzZWxmLnJlcGxhY2Uoc3RyLCByWzBdLCByWzFdLCByWzJdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfTtcblxuLyoqXG4gKiBTcGxpdHMgYSBzdHJpbmcgaW50byBhbiBhcnJheSBvZiBzdHJpbmdzIHVzaW5nIGEgcmVnZXggb3Igc3RyaW5nIHNlcGFyYXRvci4gTWF0Y2hlcyBvZiB0aGVcbiAqIHNlcGFyYXRvciBhcmUgbm90IGluY2x1ZGVkIGluIHRoZSByZXN1bHQgYXJyYXkuIEhvd2V2ZXIsIGlmIGBzZXBhcmF0b3JgIGlzIGEgcmVnZXggdGhhdCBjb250YWluc1xuICogY2FwdHVyaW5nIGdyb3VwcywgYmFja3JlZmVyZW5jZXMgYXJlIHNwbGljZWQgaW50byB0aGUgcmVzdWx0IGVhY2ggdGltZSBgc2VwYXJhdG9yYCBpcyBtYXRjaGVkLlxuICogRml4ZXMgYnJvd3NlciBidWdzIGNvbXBhcmVkIHRvIHRoZSBuYXRpdmUgYFN0cmluZy5wcm90b3R5cGUuc3BsaXRgIGFuZCBjYW4gYmUgdXNlZCByZWxpYWJseVxuICogY3Jvc3MtYnJvd3Nlci5cbiAqXG4gKiBAbWVtYmVyT2YgWFJlZ0V4cFxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBTdHJpbmcgdG8gc3BsaXQuXG4gKiBAcGFyYW0ge1JlZ0V4cHxTdHJpbmd9IHNlcGFyYXRvciBSZWdleCBvciBzdHJpbmcgdG8gdXNlIGZvciBzZXBhcmF0aW5nIHRoZSBzdHJpbmcuXG4gKiBAcGFyYW0ge051bWJlcn0gW2xpbWl0XSBNYXhpbXVtIG51bWJlciBvZiBpdGVtcyB0byBpbmNsdWRlIGluIHRoZSByZXN1bHQgYXJyYXkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IEFycmF5IG9mIHN1YnN0cmluZ3MuXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIEJhc2ljIHVzZVxuICogWFJlZ0V4cC5zcGxpdCgnYSBiIGMnLCAnICcpO1xuICogLy8gLT4gWydhJywgJ2InLCAnYyddXG4gKlxuICogLy8gV2l0aCBsaW1pdFxuICogWFJlZ0V4cC5zcGxpdCgnYSBiIGMnLCAnICcsIDIpO1xuICogLy8gLT4gWydhJywgJ2InXVxuICpcbiAqIC8vIEJhY2tyZWZlcmVuY2VzIGluIHJlc3VsdCBhcnJheVxuICogWFJlZ0V4cC5zcGxpdCgnLi53b3JkMS4uJywgLyhbYS16XSspKFxcZCspL2kpO1xuICogLy8gLT4gWycuLicsICd3b3JkJywgJzEnLCAnLi4nXVxuICovXG4gICAgc2VsZi5zcGxpdCA9IGZ1bmN0aW9uKHN0ciwgc2VwYXJhdG9yLCBsaW1pdCkge1xuICAgICAgICByZXR1cm4gZml4ZWQuc3BsaXQuY2FsbCh0b09iamVjdChzdHIpLCBzZXBhcmF0b3IsIGxpbWl0KTtcbiAgICB9O1xuXG4vKipcbiAqIEV4ZWN1dGVzIGEgcmVnZXggc2VhcmNoIGluIGEgc3BlY2lmaWVkIHN0cmluZy4gUmV0dXJucyBgdHJ1ZWAgb3IgYGZhbHNlYC4gT3B0aW9uYWwgYHBvc2AgYW5kXG4gKiBgc3RpY2t5YCBhcmd1bWVudHMgc3BlY2lmeSB0aGUgc2VhcmNoIHN0YXJ0IHBvc2l0aW9uLCBhbmQgd2hldGhlciB0aGUgbWF0Y2ggbXVzdCBzdGFydCBhdCB0aGVcbiAqIHNwZWNpZmllZCBwb3NpdGlvbiBvbmx5LiBUaGUgYGxhc3RJbmRleGAgcHJvcGVydHkgb2YgdGhlIHByb3ZpZGVkIHJlZ2V4IGlzIG5vdCB1c2VkLCBidXQgaXNcbiAqIHVwZGF0ZWQgZm9yIGNvbXBhdGliaWxpdHkuIEFsc28gZml4ZXMgYnJvd3NlciBidWdzIGNvbXBhcmVkIHRvIHRoZSBuYXRpdmVcbiAqIGBSZWdFeHAucHJvdG90eXBlLnRlc3RgIGFuZCBjYW4gYmUgdXNlZCByZWxpYWJseSBjcm9zcy1icm93c2VyLlxuICpcbiAqIEBtZW1iZXJPZiBYUmVnRXhwXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFN0cmluZyB0byBzZWFyY2guXG4gKiBAcGFyYW0ge1JlZ0V4cH0gcmVnZXggUmVnZXggdG8gc2VhcmNoIHdpdGguXG4gKiBAcGFyYW0ge051bWJlcn0gW3Bvcz0wXSBaZXJvLWJhc2VkIGluZGV4IGF0IHdoaWNoIHRvIHN0YXJ0IHRoZSBzZWFyY2guXG4gKiBAcGFyYW0ge0Jvb2xlYW58U3RyaW5nfSBbc3RpY2t5PWZhbHNlXSBXaGV0aGVyIHRoZSBtYXRjaCBtdXN0IHN0YXJ0IGF0IHRoZSBzcGVjaWZpZWQgcG9zaXRpb25cbiAqICAgb25seS4gVGhlIHN0cmluZyBgJ3N0aWNreSdgIGlzIGFjY2VwdGVkIGFzIGFuIGFsdGVybmF0aXZlIHRvIGB0cnVlYC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBXaGV0aGVyIHRoZSByZWdleCBtYXRjaGVkIHRoZSBwcm92aWRlZCB2YWx1ZS5cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gQmFzaWMgdXNlXG4gKiBYUmVnRXhwLnRlc3QoJ2FiYycsIC9jLyk7IC8vIC0+IHRydWVcbiAqXG4gKiAvLyBXaXRoIHBvcyBhbmQgc3RpY2t5XG4gKiBYUmVnRXhwLnRlc3QoJ2FiYycsIC9jLywgMCwgJ3N0aWNreScpOyAvLyAtPiBmYWxzZVxuICovXG4gICAgc2VsZi50ZXN0ID0gZnVuY3Rpb24oc3RyLCByZWdleCwgcG9zLCBzdGlja3kpIHtcbiAgICAgICAgLy8gRG8gdGhpcyB0aGUgZWFzeSB3YXkgOi0pXG4gICAgICAgIHJldHVybiAhIXNlbGYuZXhlYyhzdHIsIHJlZ2V4LCBwb3MsIHN0aWNreSk7XG4gICAgfTtcblxuLyoqXG4gKiBVbmluc3RhbGxzIG9wdGlvbmFsIGZlYXR1cmVzIGFjY29yZGluZyB0byB0aGUgc3BlY2lmaWVkIG9wdGlvbnMuIEFsbCBvcHRpb25hbCBmZWF0dXJlcyBzdGFydCBvdXRcbiAqIHVuaW5zdGFsbGVkLCBzbyB0aGlzIGlzIHVzZWQgdG8gdW5kbyB0aGUgYWN0aW9ucyBvZiB7QGxpbmsgI1hSZWdFeHAuaW5zdGFsbH0uXG4gKlxuICogQG1lbWJlck9mIFhSZWdFeHBcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gb3B0aW9ucyBPcHRpb25zIG9iamVjdCBvciBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIFdpdGggYW4gb3B0aW9ucyBvYmplY3RcbiAqIFhSZWdFeHAudW5pbnN0YWxsKHtcbiAqICAgLy8gRGlzYWJsZXMgc3VwcG9ydCBmb3IgYXN0cmFsIGNvZGUgcG9pbnRzIGluIFVuaWNvZGUgYWRkb25zXG4gKiAgIGFzdHJhbDogdHJ1ZSxcbiAqXG4gKiAgIC8vIFJlc3RvcmVzIG5hdGl2ZSByZWdleCBtZXRob2RzXG4gKiAgIG5hdGl2ZXM6IHRydWVcbiAqIH0pO1xuICpcbiAqIC8vIFdpdGggYW4gb3B0aW9ucyBzdHJpbmdcbiAqIFhSZWdFeHAudW5pbnN0YWxsKCdhc3RyYWwgbmF0aXZlcycpO1xuICovXG4gICAgc2VsZi51bmluc3RhbGwgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBwcmVwYXJlT3B0aW9ucyhvcHRpb25zKTtcblxuICAgICAgICBpZiAoZmVhdHVyZXMuYXN0cmFsICYmIG9wdGlvbnMuYXN0cmFsKSB7XG4gICAgICAgICAgICBzZXRBc3RyYWwoZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZlYXR1cmVzLm5hdGl2ZXMgJiYgb3B0aW9ucy5uYXRpdmVzKSB7XG4gICAgICAgICAgICBzZXROYXRpdmVzKGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH07XG5cbi8qKlxuICogUmV0dXJucyBhbiBYUmVnRXhwIG9iamVjdCB0aGF0IGlzIHRoZSB1bmlvbiBvZiB0aGUgZ2l2ZW4gcGF0dGVybnMuIFBhdHRlcm5zIGNhbiBiZSBwcm92aWRlZCBhc1xuICogcmVnZXggb2JqZWN0cyBvciBzdHJpbmdzLiBNZXRhY2hhcmFjdGVycyBhcmUgZXNjYXBlZCBpbiBwYXR0ZXJucyBwcm92aWRlZCBhcyBzdHJpbmdzLlxuICogQmFja3JlZmVyZW5jZXMgaW4gcHJvdmlkZWQgcmVnZXggb2JqZWN0cyBhcmUgYXV0b21hdGljYWxseSByZW51bWJlcmVkIHRvIHdvcmsgY29ycmVjdGx5IHdpdGhpblxuICogdGhlIGxhcmdlciBjb21iaW5lZCBwYXR0ZXJuLiBOYXRpdmUgZmxhZ3MgdXNlZCBieSBwcm92aWRlZCByZWdleGVzIGFyZSBpZ25vcmVkIGluIGZhdm9yIG9mIHRoZVxuICogYGZsYWdzYCBhcmd1bWVudC5cbiAqXG4gKiBAbWVtYmVyT2YgWFJlZ0V4cFxuICogQHBhcmFtIHtBcnJheX0gcGF0dGVybnMgUmVnZXhlcyBhbmQgc3RyaW5ncyB0byBjb21iaW5lLlxuICogQHBhcmFtIHtTdHJpbmd9IFtmbGFnc10gQW55IGNvbWJpbmF0aW9uIG9mIFhSZWdFeHAgZmxhZ3MuXG4gKiBAcmV0dXJucyB7UmVnRXhwfSBVbmlvbiBvZiB0aGUgcHJvdmlkZWQgcmVnZXhlcyBhbmQgc3RyaW5ncy5cbiAqIEBleGFtcGxlXG4gKlxuICogWFJlZ0V4cC51bmlvbihbJ2ErYipjJywgLyhkb2dzKVxcMS8sIC8oY2F0cylcXDEvXSwgJ2knKTtcbiAqIC8vIC0+IC9hXFwrYlxcKmN8KGRvZ3MpXFwxfChjYXRzKVxcMi9pXG4gKi9cbiAgICBzZWxmLnVuaW9uID0gZnVuY3Rpb24ocGF0dGVybnMsIGZsYWdzKSB7XG4gICAgICAgIHZhciBwYXJ0cyA9IC8oXFwoKSg/IVxcPyl8XFxcXChbMS05XVxcZCopfFxcXFxbXFxzXFxTXXxcXFsoPzpbXlxcXFxcXF1dfFxcXFxbXFxzXFxTXSkqXS9nLFxuICAgICAgICAgICAgb3V0cHV0ID0gW10sXG4gICAgICAgICAgICBudW1DYXB0dXJlcyA9IDAsXG4gICAgICAgICAgICBudW1QcmlvckNhcHR1cmVzLFxuICAgICAgICAgICAgY2FwdHVyZU5hbWVzLFxuICAgICAgICAgICAgcGF0dGVybixcbiAgICAgICAgICAgIHJld3JpdGUgPSBmdW5jdGlvbihtYXRjaCwgcGFyZW4sIGJhY2tyZWYpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IGNhcHR1cmVOYW1lc1tudW1DYXB0dXJlcyAtIG51bVByaW9yQ2FwdHVyZXNdO1xuXG4gICAgICAgICAgICAgICAgLy8gQ2FwdHVyaW5nIGdyb3VwXG4gICAgICAgICAgICAgICAgaWYgKHBhcmVuKSB7XG4gICAgICAgICAgICAgICAgICAgICsrbnVtQ2FwdHVyZXM7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBjdXJyZW50IGNhcHR1cmUgaGFzIGEgbmFtZSwgcHJlc2VydmUgdGhlIG5hbWVcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnKD88JyArIG5hbWUgKyAnPic7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBCYWNrcmVmZXJlbmNlXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChiYWNrcmVmKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJld3JpdGUgdGhlIGJhY2tyZWZlcmVuY2VcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdcXFxcJyArICgrYmFja3JlZiArIG51bVByaW9yQ2FwdHVyZXMpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpO1xuXG4gICAgICAgIGlmICghKGlzVHlwZShwYXR0ZXJucywgJ0FycmF5JykgJiYgcGF0dGVybnMubGVuZ3RoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTXVzdCBwcm92aWRlIGEgbm9uZW1wdHkgYXJyYXkgb2YgcGF0dGVybnMgdG8gbWVyZ2UnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBwYXR0ZXJucy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcGF0dGVybiA9IHBhdHRlcm5zW2ldO1xuXG4gICAgICAgICAgICBpZiAoc2VsZi5pc1JlZ0V4cChwYXR0ZXJuKSkge1xuICAgICAgICAgICAgICAgIG51bVByaW9yQ2FwdHVyZXMgPSBudW1DYXB0dXJlcztcbiAgICAgICAgICAgICAgICBjYXB0dXJlTmFtZXMgPSAocGF0dGVybltSRUdFWF9EQVRBXSAmJiBwYXR0ZXJuW1JFR0VYX0RBVEFdLmNhcHR1cmVOYW1lcykgfHwgW107XG5cbiAgICAgICAgICAgICAgICAvLyBSZXdyaXRlIGJhY2tyZWZlcmVuY2VzLiBQYXNzaW5nIHRvIFhSZWdFeHAgZGllcyBvbiBvY3RhbHMgYW5kIGVuc3VyZXMgcGF0dGVybnNcbiAgICAgICAgICAgICAgICAvLyBhcmUgaW5kZXBlbmRlbnRseSB2YWxpZDsgaGVscHMga2VlcCB0aGlzIHNpbXBsZS4gTmFtZWQgY2FwdHVyZXMgYXJlIHB1dCBiYWNrXG4gICAgICAgICAgICAgICAgb3V0cHV0LnB1c2gobmF0aXYucmVwbGFjZS5jYWxsKHNlbGYocGF0dGVybi5zb3VyY2UpLnNvdXJjZSwgcGFydHMsIHJld3JpdGUpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goc2VsZi5lc2NhcGUocGF0dGVybikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNlbGYob3V0cHV0LmpvaW4oJ3wnKSwgZmxhZ3MpO1xuICAgIH07XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRml4ZWQvZXh0ZW5kZWQgbmF0aXZlIG1ldGhvZHNcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG4vKipcbiAqIEFkZHMgbmFtZWQgY2FwdHVyZSBzdXBwb3J0ICh3aXRoIGJhY2tyZWZlcmVuY2VzIHJldHVybmVkIGFzIGByZXN1bHQubmFtZWApLCBhbmQgZml4ZXMgYnJvd3NlclxuICogYnVncyBpbiB0aGUgbmF0aXZlIGBSZWdFeHAucHJvdG90eXBlLmV4ZWNgLiBDYWxsaW5nIGBYUmVnRXhwLmluc3RhbGwoJ25hdGl2ZXMnKWAgdXNlcyB0aGlzIHRvXG4gKiBvdmVycmlkZSB0aGUgbmF0aXZlIG1ldGhvZC4gVXNlIHZpYSBgWFJlZ0V4cC5leGVjYCB3aXRob3V0IG92ZXJyaWRpbmcgbmF0aXZlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBTdHJpbmcgdG8gc2VhcmNoLlxuICogQHJldHVybnMge0FycmF5fSBNYXRjaCBhcnJheSB3aXRoIG5hbWVkIGJhY2tyZWZlcmVuY2UgcHJvcGVydGllcywgb3IgYG51bGxgLlxuICovXG4gICAgZml4ZWQuZXhlYyA9IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICB2YXIgb3JpZ0xhc3RJbmRleCA9IHRoaXMubGFzdEluZGV4LFxuICAgICAgICAgICAgbWF0Y2ggPSBuYXRpdi5leGVjLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgcjIsXG4gICAgICAgICAgICBpO1xuXG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgLy8gRml4IGJyb3dzZXJzIHdob3NlIGBleGVjYCBtZXRob2RzIGRvbid0IHJldHVybiBgdW5kZWZpbmVkYCBmb3Igbm9ucGFydGljaXBhdGluZ1xuICAgICAgICAgICAgLy8gY2FwdHVyaW5nIGdyb3Vwcy4gVGhpcyBmaXhlcyBJRSA1LjUtOCwgYnV0IG5vdCBJRSA5J3MgcXVpcmtzIG1vZGUgb3IgZW11bGF0aW9uIG9mXG4gICAgICAgICAgICAvLyBvbGRlciBJRXMuIElFIDkgaW4gc3RhbmRhcmRzIG1vZGUgZm9sbG93cyB0aGUgc3BlY1xuICAgICAgICAgICAgaWYgKCFjb3JyZWN0RXhlY05wY2cgJiYgbWF0Y2gubGVuZ3RoID4gMSAmJiBpbmRleE9mKG1hdGNoLCAnJykgPiAtMSkge1xuICAgICAgICAgICAgICAgIHIyID0gY29weVJlZ2V4KHRoaXMsIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlRzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgaXNJbnRlcm5hbE9ubHk6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBVc2luZyBgc3RyLnNsaWNlKG1hdGNoLmluZGV4KWAgcmF0aGVyIHRoYW4gYG1hdGNoWzBdYCBpbiBjYXNlIGxvb2thaGVhZCBhbGxvd2VkXG4gICAgICAgICAgICAgICAgLy8gbWF0Y2hpbmcgZHVlIHRvIGNoYXJhY3RlcnMgb3V0c2lkZSB0aGUgbWF0Y2hcbiAgICAgICAgICAgICAgICBuYXRpdi5yZXBsYWNlLmNhbGwoU3RyaW5nKHN0cikuc2xpY2UobWF0Y2guaW5kZXgpLCByMiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBpO1xuICAgICAgICAgICAgICAgICAgICAvLyBTa2lwIGluZGV4IDAgYW5kIHRoZSBsYXN0IDJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMTsgaSA8IGxlbiAtIDI7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3VtZW50c1tpXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hbaV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQXR0YWNoIG5hbWVkIGNhcHR1cmUgcHJvcGVydGllc1xuICAgICAgICAgICAgaWYgKHRoaXNbUkVHRVhfREFUQV0gJiYgdGhpc1tSRUdFWF9EQVRBXS5jYXB0dXJlTmFtZXMpIHtcbiAgICAgICAgICAgICAgICAvLyBTa2lwIGluZGV4IDBcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbWF0Y2gubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IHRoaXNbUkVHRVhfREFUQV0uY2FwdHVyZU5hbWVzW2kgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoW25hbWVdID0gbWF0Y2hbaV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZpeCBicm93c2VycyB0aGF0IGluY3JlbWVudCBgbGFzdEluZGV4YCBhZnRlciB6ZXJvLWxlbmd0aCBtYXRjaGVzXG4gICAgICAgICAgICBpZiAodGhpcy5nbG9iYWwgJiYgIW1hdGNoWzBdLmxlbmd0aCAmJiAodGhpcy5sYXN0SW5kZXggPiBtYXRjaC5pbmRleCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RJbmRleCA9IG1hdGNoLmluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLmdsb2JhbCkge1xuICAgICAgICAgICAgLy8gRml4ZXMgSUUsIE9wZXJhIGJ1ZyAobGFzdCB0ZXN0ZWQgSUUgOSwgT3BlcmEgMTEuNilcbiAgICAgICAgICAgIHRoaXMubGFzdEluZGV4ID0gb3JpZ0xhc3RJbmRleDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9O1xuXG4vKipcbiAqIEZpeGVzIGJyb3dzZXIgYnVncyBpbiB0aGUgbmF0aXZlIGBSZWdFeHAucHJvdG90eXBlLnRlc3RgLiBDYWxsaW5nIGBYUmVnRXhwLmluc3RhbGwoJ25hdGl2ZXMnKWBcbiAqIHVzZXMgdGhpcyB0byBvdmVycmlkZSB0aGUgbmF0aXZlIG1ldGhvZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBTdHJpbmcgdG8gc2VhcmNoLlxuICogQHJldHVybnMge0Jvb2xlYW59IFdoZXRoZXIgdGhlIHJlZ2V4IG1hdGNoZWQgdGhlIHByb3ZpZGVkIHZhbHVlLlxuICovXG4gICAgZml4ZWQudGVzdCA9IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAvLyBEbyB0aGlzIHRoZSBlYXN5IHdheSA6LSlcbiAgICAgICAgcmV0dXJuICEhZml4ZWQuZXhlYy5jYWxsKHRoaXMsIHN0cik7XG4gICAgfTtcblxuLyoqXG4gKiBBZGRzIG5hbWVkIGNhcHR1cmUgc3VwcG9ydCAod2l0aCBiYWNrcmVmZXJlbmNlcyByZXR1cm5lZCBhcyBgcmVzdWx0Lm5hbWVgKSwgYW5kIGZpeGVzIGJyb3dzZXJcbiAqIGJ1Z3MgaW4gdGhlIG5hdGl2ZSBgU3RyaW5nLnByb3RvdHlwZS5tYXRjaGAuIENhbGxpbmcgYFhSZWdFeHAuaW5zdGFsbCgnbmF0aXZlcycpYCB1c2VzIHRoaXMgdG9cbiAqIG92ZXJyaWRlIHRoZSBuYXRpdmUgbWV0aG9kLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1JlZ0V4cHwqfSByZWdleCBSZWdleCB0byBzZWFyY2ggd2l0aC4gSWYgbm90IGEgcmVnZXggb2JqZWN0LCBpdCBpcyBwYXNzZWQgdG8gYFJlZ0V4cGAuXG4gKiBAcmV0dXJucyB7QXJyYXl9IElmIGByZWdleGAgdXNlcyBmbGFnIGcsIGFuIGFycmF5IG9mIG1hdGNoIHN0cmluZ3Mgb3IgYG51bGxgLiBXaXRob3V0IGZsYWcgZyxcbiAqICAgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGByZWdleC5leGVjKHRoaXMpYC5cbiAqL1xuICAgIGZpeGVkLm1hdGNoID0gZnVuY3Rpb24ocmVnZXgpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgICBpZiAoIXNlbGYuaXNSZWdFeHAocmVnZXgpKSB7XG4gICAgICAgICAgICAvLyBVc2UgdGhlIG5hdGl2ZSBgUmVnRXhwYCByYXRoZXIgdGhhbiBgWFJlZ0V4cGBcbiAgICAgICAgICAgIHJlZ2V4ID0gbmV3IFJlZ0V4cChyZWdleCk7XG4gICAgICAgIH0gZWxzZSBpZiAocmVnZXguZ2xvYmFsKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBuYXRpdi5tYXRjaC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgLy8gRml4ZXMgSUUgYnVnXG4gICAgICAgICAgICByZWdleC5sYXN0SW5kZXggPSAwO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZpeGVkLmV4ZWMuY2FsbChyZWdleCwgdG9PYmplY3QodGhpcykpO1xuICAgIH07XG5cbi8qKlxuICogQWRkcyBzdXBwb3J0IGZvciBgJHtufWAgdG9rZW5zIGZvciBuYW1lZCBhbmQgbnVtYmVyZWQgYmFja3JlZmVyZW5jZXMgaW4gcmVwbGFjZW1lbnQgdGV4dCwgYW5kXG4gKiBwcm92aWRlcyBuYW1lZCBiYWNrcmVmZXJlbmNlcyB0byByZXBsYWNlbWVudCBmdW5jdGlvbnMgYXMgYGFyZ3VtZW50c1swXS5uYW1lYC4gQWxzbyBmaXhlcyBicm93c2VyXG4gKiBidWdzIGluIHJlcGxhY2VtZW50IHRleHQgc3ludGF4IHdoZW4gcGVyZm9ybWluZyBhIHJlcGxhY2VtZW50IHVzaW5nIGEgbm9ucmVnZXggc2VhcmNoIHZhbHVlLCBhbmRcbiAqIHRoZSB2YWx1ZSBvZiBhIHJlcGxhY2VtZW50IHJlZ2V4J3MgYGxhc3RJbmRleGAgcHJvcGVydHkgZHVyaW5nIHJlcGxhY2VtZW50IGl0ZXJhdGlvbnMgYW5kIHVwb25cbiAqIGNvbXBsZXRpb24uIENhbGxpbmcgYFhSZWdFeHAuaW5zdGFsbCgnbmF0aXZlcycpYCB1c2VzIHRoaXMgdG8gb3ZlcnJpZGUgdGhlIG5hdGl2ZSBtZXRob2QuIE5vdGVcbiAqIHRoYXQgdGhpcyBkb2Vzbid0IHN1cHBvcnQgU3BpZGVyTW9ua2V5J3MgcHJvcHJpZXRhcnkgdGhpcmQgKGBmbGFnc2ApIGFyZ3VtZW50LiBVc2UgdmlhXG4gKiBgWFJlZ0V4cC5yZXBsYWNlYCB3aXRob3V0IG92ZXJyaWRpbmcgbmF0aXZlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtSZWdFeHB8U3RyaW5nfSBzZWFyY2ggU2VhcmNoIHBhdHRlcm4gdG8gYmUgcmVwbGFjZWQuXG4gKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gcmVwbGFjZW1lbnQgUmVwbGFjZW1lbnQgc3RyaW5nIG9yIGEgZnVuY3Rpb24gaW52b2tlZCB0byBjcmVhdGUgaXQuXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBOZXcgc3RyaW5nIHdpdGggb25lIG9yIGFsbCBtYXRjaGVzIHJlcGxhY2VkLlxuICovXG4gICAgZml4ZWQucmVwbGFjZSA9IGZ1bmN0aW9uKHNlYXJjaCwgcmVwbGFjZW1lbnQpIHtcbiAgICAgICAgdmFyIGlzUmVnZXggPSBzZWxmLmlzUmVnRXhwKHNlYXJjaCksXG4gICAgICAgICAgICBvcmlnTGFzdEluZGV4LFxuICAgICAgICAgICAgY2FwdHVyZU5hbWVzLFxuICAgICAgICAgICAgcmVzdWx0O1xuXG4gICAgICAgIGlmIChpc1JlZ2V4KSB7XG4gICAgICAgICAgICBpZiAoc2VhcmNoW1JFR0VYX0RBVEFdKSB7XG4gICAgICAgICAgICAgICAgY2FwdHVyZU5hbWVzID0gc2VhcmNoW1JFR0VYX0RBVEFdLmNhcHR1cmVOYW1lcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE9ubHkgbmVlZGVkIGlmIGBzZWFyY2hgIGlzIG5vbmdsb2JhbFxuICAgICAgICAgICAgb3JpZ0xhc3RJbmRleCA9IHNlYXJjaC5sYXN0SW5kZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWFyY2ggKz0gJyc7IC8vIFR5cGUtY29udmVydFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRG9uJ3QgdXNlIGB0eXBlb2ZgOyBzb21lIG9sZGVyIGJyb3dzZXJzIHJldHVybiAnZnVuY3Rpb24nIGZvciByZWdleCBvYmplY3RzXG4gICAgICAgIGlmIChpc1R5cGUocmVwbGFjZW1lbnQsICdGdW5jdGlvbicpKSB7XG4gICAgICAgICAgICAvLyBTdHJpbmdpZnlpbmcgYHRoaXNgIGZpeGVzIGEgYnVnIGluIElFIDwgOSB3aGVyZSB0aGUgbGFzdCBhcmd1bWVudCBpbiByZXBsYWNlbWVudFxuICAgICAgICAgICAgLy8gZnVuY3Rpb25zIGlzbid0IHR5cGUtY29udmVydGVkIHRvIGEgc3RyaW5nXG4gICAgICAgICAgICByZXN1bHQgPSBuYXRpdi5yZXBsYWNlLmNhbGwoU3RyaW5nKHRoaXMpLCBzZWFyY2gsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLCBpO1xuICAgICAgICAgICAgICAgIGlmIChjYXB0dXJlTmFtZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hhbmdlIHRoZSBgYXJndW1lbnRzWzBdYCBzdHJpbmcgcHJpbWl0aXZlIHRvIGEgYFN0cmluZ2Agb2JqZWN0IHRoYXQgY2FuXG4gICAgICAgICAgICAgICAgICAgIC8vIHN0b3JlIHByb3BlcnRpZXMuIFRoaXMgcmVhbGx5IGRvZXMgbmVlZCB0byB1c2UgYFN0cmluZ2AgYXMgYSBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgICAgICAgICBhcmdzWzBdID0gbmV3IFN0cmluZyhhcmdzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gU3RvcmUgbmFtZWQgYmFja3JlZmVyZW5jZXMgb24gdGhlIGZpcnN0IGFyZ3VtZW50XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjYXB0dXJlTmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYXB0dXJlTmFtZXNbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzWzBdW2NhcHR1cmVOYW1lc1tpXV0gPSBhcmdzW2kgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgYGxhc3RJbmRleGAgYmVmb3JlIGNhbGxpbmcgYHJlcGxhY2VtZW50YC4gRml4ZXMgSUUsIENocm9tZSwgRmlyZWZveCxcbiAgICAgICAgICAgICAgICAvLyBTYWZhcmkgYnVnIChsYXN0IHRlc3RlZCBJRSA5LCBDaHJvbWUgMTcsIEZpcmVmb3ggMTEsIFNhZmFyaSA1LjEpXG4gICAgICAgICAgICAgICAgaWYgKGlzUmVnZXggJiYgc2VhcmNoLmdsb2JhbCkge1xuICAgICAgICAgICAgICAgICAgICBzZWFyY2gubGFzdEluZGV4ID0gYXJnc1thcmdzLmxlbmd0aCAtIDJdICsgYXJnc1swXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEVTNiBzcGVjcyB0aGUgY29udGV4dCBmb3IgcmVwbGFjZW1lbnQgZnVuY3Rpb25zIGFzIGB1bmRlZmluZWRgXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcGxhY2VtZW50LmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEVuc3VyZSB0aGF0IHRoZSBsYXN0IHZhbHVlIG9mIGBhcmdzYCB3aWxsIGJlIGEgc3RyaW5nIHdoZW4gZ2l2ZW4gbm9uc3RyaW5nIGB0aGlzYCxcbiAgICAgICAgICAgIC8vIHdoaWxlIHN0aWxsIHRocm93aW5nIG9uIG51bGwgb3IgdW5kZWZpbmVkIGNvbnRleHRcbiAgICAgICAgICAgIHJlc3VsdCA9IG5hdGl2LnJlcGxhY2UuY2FsbCh0aGlzID09IG51bGwgPyB0aGlzIDogU3RyaW5nKHRoaXMpLCBzZWFyY2gsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIEtlZXAgdGhpcyBmdW5jdGlvbidzIGBhcmd1bWVudHNgIGF2YWlsYWJsZSB0aHJvdWdoIGNsb3N1cmVcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgICAgICByZXR1cm4gbmF0aXYucmVwbGFjZS5jYWxsKFN0cmluZyhyZXBsYWNlbWVudCksIHJlcGxhY2VtZW50VG9rZW4sIGZ1bmN0aW9uKCQwLCAkMSwgJDIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG47XG4gICAgICAgICAgICAgICAgICAgIC8vIE5hbWVkIG9yIG51bWJlcmVkIGJhY2tyZWZlcmVuY2Ugd2l0aCBjdXJseSBicmFjZXNcbiAgICAgICAgICAgICAgICAgICAgaWYgKCQxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBYUmVnRXhwIGJlaGF2aW9yIGZvciBgJHtufWA6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAxLiBCYWNrcmVmZXJlbmNlIHRvIG51bWJlcmVkIGNhcHR1cmUsIGlmIGBuYCBpcyBhbiBpbnRlZ2VyLiBVc2UgYDBgIGZvclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgZm9yIHRoZSBlbnRpcmUgbWF0Y2guIEFueSBudW1iZXIgb2YgbGVhZGluZyB6ZXJvcyBtYXkgYmUgdXNlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIDIuIEJhY2tyZWZlcmVuY2UgdG8gbmFtZWQgY2FwdHVyZSBgbmAsIGlmIGl0IGV4aXN0cyBhbmQgaXMgbm90IGFuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICBpbnRlZ2VyIG92ZXJyaWRkZW4gYnkgbnVtYmVyZWQgY2FwdHVyZS4gSW4gcHJhY3RpY2UsIHRoaXMgZG9lcyBub3RcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgIG92ZXJsYXAgd2l0aCBudW1iZXJlZCBjYXB0dXJlIHNpbmNlIFhSZWdFeHAgZG9lcyBub3QgYWxsb3cgbmFtZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgIGNhcHR1cmUgdG8gdXNlIGEgYmFyZSBpbnRlZ2VyIGFzIHRoZSBuYW1lLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gMy4gSWYgdGhlIG5hbWUgb3IgbnVtYmVyIGRvZXMgbm90IHJlZmVyIHRvIGFuIGV4aXN0aW5nIGNhcHR1cmluZyBncm91cCxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgIGl0J3MgYW4gZXJyb3IuXG4gICAgICAgICAgICAgICAgICAgICAgICBuID0gKyQxOyAvLyBUeXBlLWNvbnZlcnQ7IGRyb3AgbGVhZGluZyB6ZXJvc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG4gPD0gYXJncy5sZW5ndGggLSAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyZ3Nbbl0gfHwgJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBHcm91cHMgd2l0aCB0aGUgc2FtZSBuYW1lIGlzIGFuIGVycm9yLCBlbHNlIHdvdWxkIG5lZWQgYGxhc3RJbmRleE9mYFxuICAgICAgICAgICAgICAgICAgICAgICAgbiA9IGNhcHR1cmVOYW1lcyA/IGluZGV4T2YoY2FwdHVyZU5hbWVzLCAkMSkgOiAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQmFja3JlZmVyZW5jZSB0byB1bmRlZmluZWQgZ3JvdXAgJyArICQwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhcmdzW24gKyAxXSB8fCAnJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBFbHNlLCBzcGVjaWFsIHZhcmlhYmxlIG9yIG51bWJlcmVkIGJhY2tyZWZlcmVuY2Ugd2l0aG91dCBjdXJseSBicmFjZXNcbiAgICAgICAgICAgICAgICAgICAgaWYgKCQyID09PSAnJCcpIHsgLy8gJCRcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnJCc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCQyID09PSAnJicgfHwgKyQyID09PSAwKSB7IC8vICQmLCAkMCAobm90IGZvbGxvd2VkIGJ5IDEtOSksICQwMFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyZ3NbMF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCQyID09PSAnYCcpIHsgLy8gJGAgKGxlZnQgY29udGV4dClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0uc2xpY2UoMCwgYXJnc1thcmdzLmxlbmd0aCAtIDJdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoJDIgPT09IFwiJ1wiKSB7IC8vICQnIChyaWdodCBjb250ZXh0KVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyZ3NbYXJncy5sZW5ndGggLSAxXS5zbGljZShhcmdzW2FyZ3MubGVuZ3RoIC0gMl0gKyBhcmdzWzBdLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gRWxzZSwgbnVtYmVyZWQgYmFja3JlZmVyZW5jZSB3aXRob3V0IGN1cmx5IGJyYWNlc1xuICAgICAgICAgICAgICAgICAgICAkMiA9ICskMjsgLy8gVHlwZS1jb252ZXJ0OyBkcm9wIGxlYWRpbmcgemVyb1xuICAgICAgICAgICAgICAgICAgICAvLyBYUmVnRXhwIGJlaGF2aW9yIGZvciBgJG5gIGFuZCBgJG5uYDpcbiAgICAgICAgICAgICAgICAgICAgLy8gLSBCYWNrcmVmcyBlbmQgYWZ0ZXIgMSBvciAyIGRpZ2l0cy4gVXNlIGAkey4ufWAgZm9yIG1vcmUgZGlnaXRzLlxuICAgICAgICAgICAgICAgICAgICAvLyAtIGAkMWAgaXMgYW4gZXJyb3IgaWYgbm8gY2FwdHVyaW5nIGdyb3Vwcy5cbiAgICAgICAgICAgICAgICAgICAgLy8gLSBgJDEwYCBpcyBhbiBlcnJvciBpZiBsZXNzIHRoYW4gMTAgY2FwdHVyaW5nIGdyb3Vwcy4gVXNlIGAkezF9MGAgaW5zdGVhZC5cbiAgICAgICAgICAgICAgICAgICAgLy8gLSBgJDAxYCBpcyBgJDFgIGlmIGF0IGxlYXN0IG9uZSBjYXB0dXJpbmcgZ3JvdXAsIGVsc2UgaXQncyBhbiBlcnJvci5cbiAgICAgICAgICAgICAgICAgICAgLy8gLSBgJDBgIChub3QgZm9sbG93ZWQgYnkgMS05KSBhbmQgYCQwMGAgYXJlIHRoZSBlbnRpcmUgbWF0Y2guXG4gICAgICAgICAgICAgICAgICAgIC8vIE5hdGl2ZSBiZWhhdmlvciwgZm9yIGNvbXBhcmlzb246XG4gICAgICAgICAgICAgICAgICAgIC8vIC0gQmFja3JlZnMgZW5kIGFmdGVyIDEgb3IgMiBkaWdpdHMuIENhbm5vdCByZWZlcmVuY2UgY2FwdHVyaW5nIGdyb3VwIDEwMCsuXG4gICAgICAgICAgICAgICAgICAgIC8vIC0gYCQxYCBpcyBhIGxpdGVyYWwgYCQxYCBpZiBubyBjYXB0dXJpbmcgZ3JvdXBzLlxuICAgICAgICAgICAgICAgICAgICAvLyAtIGAkMTBgIGlzIGAkMWAgZm9sbG93ZWQgYnkgYSBsaXRlcmFsIGAwYCBpZiBsZXNzIHRoYW4gMTAgY2FwdHVyaW5nIGdyb3Vwcy5cbiAgICAgICAgICAgICAgICAgICAgLy8gLSBgJDAxYCBpcyBgJDFgIGlmIGF0IGxlYXN0IG9uZSBjYXB0dXJpbmcgZ3JvdXAsIGVsc2UgaXQncyBhIGxpdGVyYWwgYCQwMWAuXG4gICAgICAgICAgICAgICAgICAgIC8vIC0gYCQwYCBpcyBhIGxpdGVyYWwgYCQwYC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc05hTigkMikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkMiA+IGFyZ3MubGVuZ3RoIC0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQmFja3JlZmVyZW5jZSB0byB1bmRlZmluZWQgZ3JvdXAgJyArICQwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhcmdzWyQyXSB8fCAnJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBgJGAgZm9sbG93ZWQgYnkgYW4gdW5zdXBwb3J0ZWQgY2hhciBpcyBhbiBlcnJvciwgdW5saWtlIG5hdGl2ZSBKU1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0ludmFsaWQgdG9rZW4gJyArICQwKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzUmVnZXgpIHtcbiAgICAgICAgICAgIGlmIChzZWFyY2guZ2xvYmFsKSB7XG4gICAgICAgICAgICAgICAgLy8gRml4ZXMgSUUsIFNhZmFyaSBidWcgKGxhc3QgdGVzdGVkIElFIDksIFNhZmFyaSA1LjEpXG4gICAgICAgICAgICAgICAgc2VhcmNoLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEZpeGVzIElFLCBPcGVyYSBidWcgKGxhc3QgdGVzdGVkIElFIDksIE9wZXJhIDExLjYpXG4gICAgICAgICAgICAgICAgc2VhcmNoLmxhc3RJbmRleCA9IG9yaWdMYXN0SW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbi8qKlxuICogRml4ZXMgYnJvd3NlciBidWdzIGluIHRoZSBuYXRpdmUgYFN0cmluZy5wcm90b3R5cGUuc3BsaXRgLiBDYWxsaW5nIGBYUmVnRXhwLmluc3RhbGwoJ25hdGl2ZXMnKWBcbiAqIHVzZXMgdGhpcyB0byBvdmVycmlkZSB0aGUgbmF0aXZlIG1ldGhvZC4gVXNlIHZpYSBgWFJlZ0V4cC5zcGxpdGAgd2l0aG91dCBvdmVycmlkaW5nIG5hdGl2ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7UmVnRXhwfFN0cmluZ30gc2VwYXJhdG9yIFJlZ2V4IG9yIHN0cmluZyB0byB1c2UgZm9yIHNlcGFyYXRpbmcgdGhlIHN0cmluZy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbbGltaXRdIE1heGltdW0gbnVtYmVyIG9mIGl0ZW1zIHRvIGluY2x1ZGUgaW4gdGhlIHJlc3VsdCBhcnJheS5cbiAqIEByZXR1cm5zIHtBcnJheX0gQXJyYXkgb2Ygc3Vic3RyaW5ncy5cbiAqL1xuICAgIGZpeGVkLnNwbGl0ID0gZnVuY3Rpb24oc2VwYXJhdG9yLCBsaW1pdCkge1xuICAgICAgICBpZiAoIXNlbGYuaXNSZWdFeHAoc2VwYXJhdG9yKSkge1xuICAgICAgICAgICAgLy8gQnJvd3NlcnMgaGFuZGxlIG5vbnJlZ2V4IHNwbGl0IGNvcnJlY3RseSwgc28gdXNlIHRoZSBmYXN0ZXIgbmF0aXZlIG1ldGhvZFxuICAgICAgICAgICAgcmV0dXJuIG5hdGl2LnNwbGl0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3RyID0gU3RyaW5nKHRoaXMpLFxuICAgICAgICAgICAgb3V0cHV0ID0gW10sXG4gICAgICAgICAgICBvcmlnTGFzdEluZGV4ID0gc2VwYXJhdG9yLmxhc3RJbmRleCxcbiAgICAgICAgICAgIGxhc3RMYXN0SW5kZXggPSAwLFxuICAgICAgICAgICAgbGFzdExlbmd0aDtcblxuICAgICAgICAvLyBWYWx1ZXMgZm9yIGBsaW1pdGAsIHBlciB0aGUgc3BlYzpcbiAgICAgICAgLy8gSWYgdW5kZWZpbmVkOiBwb3coMiwzMikgLSAxXG4gICAgICAgIC8vIElmIDAsIEluZmluaXR5LCBvciBOYU46IDBcbiAgICAgICAgLy8gSWYgcG9zaXRpdmUgbnVtYmVyOiBsaW1pdCA9IGZsb29yKGxpbWl0KTsgaWYgKGxpbWl0ID49IHBvdygyLDMyKSkgbGltaXQgLT0gcG93KDIsMzIpO1xuICAgICAgICAvLyBJZiBuZWdhdGl2ZSBudW1iZXI6IHBvdygyLDMyKSAtIGZsb29yKGFicyhsaW1pdCkpXG4gICAgICAgIC8vIElmIG90aGVyOiBUeXBlLWNvbnZlcnQsIHRoZW4gdXNlIHRoZSBhYm92ZSBydWxlc1xuICAgICAgICAvLyBUaGlzIGxpbmUgZmFpbHMgaW4gdmVyeSBzdHJhbmdlIHdheXMgZm9yIHNvbWUgdmFsdWVzIG9mIGBsaW1pdGAgaW4gT3BlcmEgMTAuNS0xMC42MyxcbiAgICAgICAgLy8gdW5sZXNzIE9wZXJhIERyYWdvbmZseSBpcyBvcGVuIChnbyBmaWd1cmUpLiBJdCB3b3JrcyBpbiBhdCBsZWFzdCBPcGVyYSA5LjUtMTAuMSBhbmQgMTErXG4gICAgICAgIGxpbWl0ID0gKGxpbWl0ID09PSB1bmRlZmluZWQgPyAtMSA6IGxpbWl0KSA+Pj4gMDtcblxuICAgICAgICBzZWxmLmZvckVhY2goc3RyLCBzZXBhcmF0b3IsIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGNvbmRpdGlvbiBpcyBub3QgdGhlIHNhbWUgYXMgYGlmIChtYXRjaFswXS5sZW5ndGgpYFxuICAgICAgICAgICAgaWYgKChtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCkgPiBsYXN0TGFzdEluZGV4KSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goc3RyLnNsaWNlKGxhc3RMYXN0SW5kZXgsIG1hdGNoLmluZGV4KSk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoLmxlbmd0aCA+IDEgJiYgbWF0Y2guaW5kZXggPCBzdHIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KG91dHB1dCwgbWF0Y2guc2xpY2UoMSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsYXN0TGVuZ3RoID0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGxhc3RMYXN0SW5kZXggPSBtYXRjaC5pbmRleCArIGxhc3RMZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChsYXN0TGFzdEluZGV4ID09PSBzdHIubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoIW5hdGl2LnRlc3QuY2FsbChzZXBhcmF0b3IsICcnKSB8fCBsYXN0TGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3V0cHV0LnB1c2goc3RyLnNsaWNlKGxhc3RMYXN0SW5kZXgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlcGFyYXRvci5sYXN0SW5kZXggPSBvcmlnTGFzdEluZGV4O1xuICAgICAgICByZXR1cm4gb3V0cHV0Lmxlbmd0aCA+IGxpbWl0ID8gb3V0cHV0LnNsaWNlKDAsIGxpbWl0KSA6IG91dHB1dDtcbiAgICB9O1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEJ1aWx0LWluIHN5bnRheC9mbGFnIHRva2Vuc1xuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cbiAgICBhZGQgPSBzZWxmLmFkZFRva2VuO1xuXG4vKlxuICogTGV0dGVyIGVzY2FwZXMgdGhhdCBuYXRpdmVseSBtYXRjaCBsaXRlcmFsIGNoYXJhY3RlcnM6IGBcXGFgLCBgXFxBYCwgZXRjLiBUaGVzZSBzaG91bGQgYmVcbiAqIFN5bnRheEVycm9ycyBidXQgYXJlIGFsbG93ZWQgaW4gd2ViIHJlYWxpdHkuIFhSZWdFeHAgbWFrZXMgdGhlbSBlcnJvcnMgZm9yIGNyb3NzLWJyb3dzZXJcbiAqIGNvbnNpc3RlbmN5IGFuZCB0byByZXNlcnZlIHRoZWlyIHN5bnRheCwgYnV0IGxldHMgdGhlbSBiZSBzdXBlcnNlZGVkIGJ5IGFkZG9ucy5cbiAqL1xuICAgIGFkZChcbiAgICAgICAgL1xcXFwoW0FCQ0UtUlRVVlhZWmFlZy1tb3BxeXpdfGMoPyFbQS1aYS16XSl8dSg/IVtcXGRBLUZhLWZdezR9fHtbXFxkQS1GYS1mXSt9KXx4KD8hW1xcZEEtRmEtZl17Mn0pKS8sXG4gICAgICAgIGZ1bmN0aW9uKG1hdGNoLCBzY29wZSkge1xuICAgICAgICAgICAgLy8gXFxCIGlzIGFsbG93ZWQgaW4gZGVmYXVsdCBzY29wZSBvbmx5XG4gICAgICAgICAgICBpZiAobWF0Y2hbMV0gPT09ICdCJyAmJiBzY29wZSA9PT0gZGVmYXVsdFNjb3BlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdJbnZhbGlkIGVzY2FwZSAnICsgbWF0Y2hbMF0pO1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBzY29wZTogJ2FsbCcsXG4gICAgICAgICAgICBsZWFkQ2hhcjogJ1xcXFwnXG4gICAgICAgIH1cbiAgICApO1xuXG4vKlxuICogVW5pY29kZSBjb2RlIHBvaW50IGVzY2FwZSB3aXRoIGN1cmx5IGJyYWNlczogYFxcdXtOLi59YC4gYE4uLmAgaXMgYW55IG9uZSBvciBtb3JlIGRpZ2l0XG4gKiBoZXhhZGVjaW1hbCBudW1iZXIgZnJvbSAwLTEwRkZGRiwgYW5kIGNhbiBpbmNsdWRlIGxlYWRpbmcgemVyb3MuIFJlcXVpcmVzIHRoZSBuYXRpdmUgRVM2IGB1YCBmbGFnXG4gKiB0byBzdXBwb3J0IGNvZGUgcG9pbnRzIGdyZWF0ZXIgdGhhbiBVK0ZGRkYuIEF2b2lkcyBjb252ZXJ0aW5nIGNvZGUgcG9pbnRzIGFib3ZlIFUrRkZGRiB0b1xuICogc3Vycm9nYXRlIHBhaXJzICh3aGljaCBjb3VsZCBiZSBkb25lIHdpdGhvdXQgZmxhZyBgdWApLCBzaW5jZSB0aGF0IGNvdWxkIGxlYWQgdG8gYnJva2VuIGJlaGF2aW9yXG4gKiBpZiB5b3UgZm9sbG93IGEgYFxcdXtOLi59YCB0b2tlbiB0aGF0IHJlZmVyZW5jZXMgYSBjb2RlIHBvaW50IGFib3ZlIFUrRkZGRiB3aXRoIGEgcXVhbnRpZmllciwgb3JcbiAqIGlmIHlvdSB1c2UgdGhlIHNhbWUgaW4gYSBjaGFyYWN0ZXIgY2xhc3MuXG4gKi9cbiAgICBhZGQoXG4gICAgICAgIC9cXFxcdXsoW1xcZEEtRmEtZl0rKX0vLFxuICAgICAgICBmdW5jdGlvbihtYXRjaCwgc2NvcGUsIGZsYWdzKSB7XG4gICAgICAgICAgICB2YXIgY29kZSA9IGRlYyhtYXRjaFsxXSk7XG4gICAgICAgICAgICBpZiAoY29kZSA+IDB4MTBGRkZGKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdJbnZhbGlkIFVuaWNvZGUgY29kZSBwb2ludCAnICsgbWF0Y2hbMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvZGUgPD0gMHhGRkZGKSB7XG4gICAgICAgICAgICAgICAgLy8gQ29udmVydGluZyB0byBcXHVOTk5OIGF2b2lkcyBuZWVkaW5nIHRvIGVzY2FwZSB0aGUgbGl0ZXJhbCBjaGFyYWN0ZXIgYW5kIGtlZXAgaXRcbiAgICAgICAgICAgICAgICAvLyBzZXBhcmF0ZSBmcm9tIHByZWNlZGluZyB0b2tlbnNcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1xcXFx1JyArIHBhZDQoaGV4KGNvZGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIGBjb2RlYCBpcyBiZXR3ZWVuIDB4RkZGRiBhbmQgMHgxMEZGRkYsIHJlcXVpcmUgYW5kIGRlZmVyIHRvIG5hdGl2ZSBoYW5kbGluZ1xuICAgICAgICAgICAgaWYgKGhhc05hdGl2ZVUgJiYgZmxhZ3MuaW5kZXhPZigndScpID4gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2hbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0Nhbm5vdCB1c2UgVW5pY29kZSBjb2RlIHBvaW50IGFib3ZlIFxcXFx1e0ZGRkZ9IHdpdGhvdXQgZmxhZyB1Jyk7XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHNjb3BlOiAnYWxsJyxcbiAgICAgICAgICAgIGxlYWRDaGFyOiAnXFxcXCdcbiAgICAgICAgfVxuICAgICk7XG5cbi8qXG4gKiBFbXB0eSBjaGFyYWN0ZXIgY2xhc3M6IGBbXWAgb3IgYFteXWAuIFRoaXMgZml4ZXMgYSBjcml0aWNhbCBjcm9zcy1icm93c2VyIHN5bnRheCBpbmNvbnNpc3RlbmN5LlxuICogVW5sZXNzIHRoaXMgaXMgc3RhbmRhcmRpemVkIChwZXIgdGhlIEVTIHNwZWMpLCByZWdleCBzeW50YXggY2FuJ3QgYmUgYWNjdXJhdGVseSBwYXJzZWQgYmVjYXVzZVxuICogY2hhcmFjdGVyIGNsYXNzIGVuZGluZ3MgY2FuJ3QgYmUgZGV0ZXJtaW5lZC5cbiAqL1xuICAgIGFkZChcbiAgICAgICAgL1xcWyhcXF4/KV0vLFxuICAgICAgICBmdW5jdGlvbihtYXRjaCkge1xuICAgICAgICAgICAgLy8gRm9yIGNyb3NzLWJyb3dzZXIgY29tcGF0aWJpbGl0eSB3aXRoIEVTMywgY29udmVydCBbXSB0byBcXGJcXEIgYW5kIFteXSB0byBbXFxzXFxTXS5cbiAgICAgICAgICAgIC8vICg/ISkgc2hvdWxkIHdvcmsgbGlrZSBcXGJcXEIsIGJ1dCBpcyB1bnJlbGlhYmxlIGluIHNvbWUgdmVyc2lvbnMgb2YgRmlyZWZveFxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoWzFdID8gJ1tcXFxcc1xcXFxTXScgOiAnXFxcXGJcXFxcQic7XG4gICAgICAgIH0sXG4gICAgICAgIHtsZWFkQ2hhcjogJ1snfVxuICAgICk7XG5cbi8qXG4gKiBDb21tZW50IHBhdHRlcm46IGAoPyMgKWAuIElubGluZSBjb21tZW50cyBhcmUgYW4gYWx0ZXJuYXRpdmUgdG8gdGhlIGxpbmUgY29tbWVudHMgYWxsb3dlZCBpblxuICogZnJlZS1zcGFjaW5nIG1vZGUgKGZsYWcgeCkuXG4gKi9cbiAgICBhZGQoXG4gICAgICAgIC9cXChcXD8jW14pXSpcXCkvLFxuICAgICAgICBmdW5jdGlvbihtYXRjaCwgc2NvcGUsIGZsYWdzKSB7XG4gICAgICAgICAgICAvLyBLZWVwIHRva2VucyBzZXBhcmF0ZWQgdW5sZXNzIHRoZSBmb2xsb3dpbmcgdG9rZW4gaXMgYSBxdWFudGlmaWVyXG4gICAgICAgICAgICByZXR1cm4gaXNRdWFudGlmaWVyTmV4dChtYXRjaC5pbnB1dCwgbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGgsIGZsYWdzKSA/XG4gICAgICAgICAgICAgICAgJycgOiAnKD86KSc7XG4gICAgICAgIH0sXG4gICAgICAgIHtsZWFkQ2hhcjogJygnfVxuICAgICk7XG5cbi8qXG4gKiBXaGl0ZXNwYWNlIGFuZCBsaW5lIGNvbW1lbnRzLCBpbiBmcmVlLXNwYWNpbmcgbW9kZSAoYWthIGV4dGVuZGVkIG1vZGUsIGZsYWcgeCkgb25seS5cbiAqL1xuICAgIGFkZChcbiAgICAgICAgL1xccyt8Iy4qLyxcbiAgICAgICAgZnVuY3Rpb24obWF0Y2gsIHNjb3BlLCBmbGFncykge1xuICAgICAgICAgICAgLy8gS2VlcCB0b2tlbnMgc2VwYXJhdGVkIHVubGVzcyB0aGUgZm9sbG93aW5nIHRva2VuIGlzIGEgcXVhbnRpZmllclxuICAgICAgICAgICAgcmV0dXJuIGlzUXVhbnRpZmllck5leHQobWF0Y2guaW5wdXQsIG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoLCBmbGFncykgP1xuICAgICAgICAgICAgICAgICcnIDogJyg/OiknO1xuICAgICAgICB9LFxuICAgICAgICB7ZmxhZzogJ3gnfVxuICAgICk7XG5cbi8qXG4gKiBEb3QsIGluIGRvdGFsbCBtb2RlIChha2Egc2luZ2xlbGluZSBtb2RlLCBmbGFnIHMpIG9ubHkuXG4gKi9cbiAgICBhZGQoXG4gICAgICAgIC9cXC4vLFxuICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiAnW1xcXFxzXFxcXFNdJztcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgZmxhZzogJ3MnLFxuICAgICAgICAgICAgbGVhZENoYXI6ICcuJ1xuICAgICAgICB9XG4gICAgKTtcblxuLypcbiAqIE5hbWVkIGJhY2tyZWZlcmVuY2U6IGBcXGs8bmFtZT5gLiBCYWNrcmVmZXJlbmNlIG5hbWVzIGNhbiB1c2UgdGhlIGNoYXJhY3RlcnMgQS1aLCBhLXosIDAtOSwgXyxcbiAqIGFuZCAkIG9ubHkuIEFsc28gYWxsb3dzIG51bWJlcmVkIGJhY2tyZWZlcmVuY2VzIGFzIGBcXGs8bj5gLlxuICovXG4gICAgYWRkKFxuICAgICAgICAvXFxcXGs8KFtcXHckXSspPi8sXG4gICAgICAgIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgICAgICAgICAvLyBHcm91cHMgd2l0aCB0aGUgc2FtZSBuYW1lIGlzIGFuIGVycm9yLCBlbHNlIHdvdWxkIG5lZWQgYGxhc3RJbmRleE9mYFxuICAgICAgICAgICAgdmFyIGluZGV4ID0gaXNOYU4obWF0Y2hbMV0pID8gKGluZGV4T2YodGhpcy5jYXB0dXJlTmFtZXMsIG1hdGNoWzFdKSArIDEpIDogK21hdGNoWzFdLFxuICAgICAgICAgICAgICAgIGVuZEluZGV4ID0gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoIWluZGV4IHx8IGluZGV4ID4gdGhpcy5jYXB0dXJlTmFtZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdCYWNrcmVmZXJlbmNlIHRvIHVuZGVmaW5lZCBncm91cCAnICsgbWF0Y2hbMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gS2VlcCBiYWNrcmVmZXJlbmNlcyBzZXBhcmF0ZSBmcm9tIHN1YnNlcXVlbnQgbGl0ZXJhbCBudW1iZXJzXG4gICAgICAgICAgICByZXR1cm4gJ1xcXFwnICsgaW5kZXggKyAoXG4gICAgICAgICAgICAgICAgZW5kSW5kZXggPT09IG1hdGNoLmlucHV0Lmxlbmd0aCB8fCBpc05hTihtYXRjaC5pbnB1dC5jaGFyQXQoZW5kSW5kZXgpKSA/XG4gICAgICAgICAgICAgICAgICAgICcnIDogJyg/OiknXG4gICAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICB7bGVhZENoYXI6ICdcXFxcJ31cbiAgICApO1xuXG4vKlxuICogTnVtYmVyZWQgYmFja3JlZmVyZW5jZSBvciBvY3RhbCwgcGx1cyBhbnkgZm9sbG93aW5nIGRpZ2l0czogYFxcMGAsIGBcXDExYCwgZXRjLiBPY3RhbHMgZXhjZXB0IGBcXDBgXG4gKiBub3QgZm9sbG93ZWQgYnkgMC05IGFuZCBiYWNrcmVmZXJlbmNlcyB0byB1bm9wZW5lZCBjYXB0dXJlIGdyb3VwcyB0aHJvdyBhbiBlcnJvci4gT3RoZXIgbWF0Y2hlc1xuICogYXJlIHJldHVybmVkIHVuYWx0ZXJlZC4gSUUgPCA5IGRvZXNuJ3Qgc3VwcG9ydCBiYWNrcmVmZXJlbmNlcyBhYm92ZSBgXFw5OWAgaW4gcmVnZXggc3ludGF4LlxuICovXG4gICAgYWRkKFxuICAgICAgICAvXFxcXChcXGQrKS8sXG4gICAgICAgIGZ1bmN0aW9uKG1hdGNoLCBzY29wZSkge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICEoXG4gICAgICAgICAgICAgICAgICAgIHNjb3BlID09PSBkZWZhdWx0U2NvcGUgJiZcbiAgICAgICAgICAgICAgICAgICAgL15bMS05XS8udGVzdChtYXRjaFsxXSkgJiZcbiAgICAgICAgICAgICAgICAgICAgK21hdGNoWzFdIDw9IHRoaXMuY2FwdHVyZU5hbWVzLmxlbmd0aFxuICAgICAgICAgICAgICAgICkgJiZcbiAgICAgICAgICAgICAgICBtYXRjaFsxXSAhPT0gJzAnXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0Nhbm5vdCB1c2Ugb2N0YWwgZXNjYXBlIG9yIGJhY2tyZWZlcmVuY2UgdG8gdW5kZWZpbmVkIGdyb3VwICcgK1xuICAgICAgICAgICAgICAgICAgICBtYXRjaFswXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hbMF07XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHNjb3BlOiAnYWxsJyxcbiAgICAgICAgICAgIGxlYWRDaGFyOiAnXFxcXCdcbiAgICAgICAgfVxuICAgICk7XG5cbi8qXG4gKiBOYW1lZCBjYXB0dXJpbmcgZ3JvdXA7IG1hdGNoIHRoZSBvcGVuaW5nIGRlbGltaXRlciBvbmx5OiBgKD88bmFtZT5gLiBDYXB0dXJlIG5hbWVzIGNhbiB1c2UgdGhlXG4gKiBjaGFyYWN0ZXJzIEEtWiwgYS16LCAwLTksIF8sIGFuZCAkIG9ubHkuIE5hbWVzIGNhbid0IGJlIGludGVnZXJzLiBTdXBwb3J0cyBQeXRob24tc3R5bGVcbiAqIGAoP1A8bmFtZT5gIGFzIGFuIGFsdGVybmF0ZSBzeW50YXggdG8gYXZvaWQgaXNzdWVzIGluIHNvbWUgb2xkZXIgdmVyc2lvbnMgb2YgT3BlcmEgd2hpY2ggbmF0aXZlbHlcbiAqIHN1cHBvcnRlZCB0aGUgUHl0aG9uLXN0eWxlIHN5bnRheC4gT3RoZXJ3aXNlLCBYUmVnRXhwIG1pZ2h0IHRyZWF0IG51bWJlcmVkIGJhY2tyZWZlcmVuY2VzIHRvXG4gKiBQeXRob24tc3R5bGUgbmFtZWQgY2FwdHVyZSBhcyBvY3RhbHMuXG4gKi9cbiAgICBhZGQoXG4gICAgICAgIC9cXChcXD9QPzwoW1xcdyRdKyk+LyxcbiAgICAgICAgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICAgICAgICAgIC8vIERpc2FsbG93IGJhcmUgaW50ZWdlcnMgYXMgbmFtZXMgYmVjYXVzZSBuYW1lZCBiYWNrcmVmZXJlbmNlcyBhcmUgYWRkZWQgdG8gbWF0Y2hcbiAgICAgICAgICAgIC8vIGFycmF5cyBhbmQgdGhlcmVmb3JlIG51bWVyaWMgcHJvcGVydGllcyBtYXkgbGVhZCB0byBpbmNvcnJlY3QgbG9va3Vwc1xuICAgICAgICAgICAgaWYgKCFpc05hTihtYXRjaFsxXSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0Nhbm5vdCB1c2UgaW50ZWdlciBhcyBjYXB0dXJlIG5hbWUgJyArIG1hdGNoWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaFsxXSA9PT0gJ2xlbmd0aCcgfHwgbWF0Y2hbMV0gPT09ICdfX3Byb3RvX18nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdDYW5ub3QgdXNlIHJlc2VydmVkIHdvcmQgYXMgY2FwdHVyZSBuYW1lICcgKyBtYXRjaFswXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW5kZXhPZih0aGlzLmNhcHR1cmVOYW1lcywgbWF0Y2hbMV0pID4gLTEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0Nhbm5vdCB1c2Ugc2FtZSBuYW1lIGZvciBtdWx0aXBsZSBncm91cHMgJyArIG1hdGNoWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2FwdHVyZU5hbWVzLnB1c2gobWF0Y2hbMV0pO1xuICAgICAgICAgICAgdGhpcy5oYXNOYW1lZENhcHR1cmUgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuICcoJztcbiAgICAgICAgfSxcbiAgICAgICAge2xlYWRDaGFyOiAnKCd9XG4gICAgKTtcblxuLypcbiAqIENhcHR1cmluZyBncm91cDsgbWF0Y2ggdGhlIG9wZW5pbmcgcGFyZW50aGVzaXMgb25seS4gUmVxdWlyZWQgZm9yIHN1cHBvcnQgb2YgbmFtZWQgY2FwdHVyaW5nXG4gKiBncm91cHMuIEFsc28gYWRkcyBleHBsaWNpdCBjYXB0dXJlIG1vZGUgKGZsYWcgbikuXG4gKi9cbiAgICBhZGQoXG4gICAgICAgIC9cXCgoPyFcXD8pLyxcbiAgICAgICAgZnVuY3Rpb24obWF0Y2gsIHNjb3BlLCBmbGFncykge1xuICAgICAgICAgICAgaWYgKGZsYWdzLmluZGV4T2YoJ24nKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcoPzonO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jYXB0dXJlTmFtZXMucHVzaChudWxsKTtcbiAgICAgICAgICAgIHJldHVybiAnKCc7XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG9wdGlvbmFsRmxhZ3M6ICduJyxcbiAgICAgICAgICAgIGxlYWRDaGFyOiAnKCdcbiAgICAgICAgfVxuICAgICk7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRXhwb3NlIFhSZWdFeHBcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG4gICAgcmV0dXJuIHNlbGY7XG5cbn0oKSk7XG5cbi8qIVxuICogWFJlZ0V4cC5idWlsZCAzLjAuMFxuICogPGh0dHA6Ly94cmVnZXhwLmNvbS8+XG4gKiBTdGV2ZW4gTGV2aXRoYW4gKGMpIDIwMTItMjAxNSBNSVQgTGljZW5zZVxuICogSW5zcGlyZWQgYnkgTGVhIFZlcm91J3MgUmVnRXhwLmNyZWF0ZSA8aHR0cDovL2xlYS52ZXJvdS5tZS8+XG4gKi9cblxuKGZ1bmN0aW9uKFhSZWdFeHApIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgUkVHRVhfREFUQSA9ICd4cmVnZXhwJyxcbiAgICAgICAgc3ViUGFydHMgPSAvKFxcKCkoPyFcXD8pfFxcXFwoWzEtOV1cXGQqKXxcXFxcW1xcc1xcU118XFxbKD86W15cXFxcXFxdXXxcXFxcW1xcc1xcU10pKl0vZyxcbiAgICAgICAgcGFydHMgPSBYUmVnRXhwLnVuaW9uKFsvXFwoe3soW1xcdyRdKyl9fVxcKXx7eyhbXFx3JF0rKX19Lywgc3ViUGFydHNdLCAnZycpO1xuXG4vKipcbiAqIFN0cmlwcyBhIGxlYWRpbmcgYF5gIGFuZCB0cmFpbGluZyB1bmVzY2FwZWQgYCRgLCBpZiBib3RoIGFyZSBwcmVzZW50LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0dGVybiBQYXR0ZXJuIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBQYXR0ZXJuIHdpdGggZWRnZSBhbmNob3JzIHJlbW92ZWQuXG4gKi9cbiAgICBmdW5jdGlvbiBkZWFuY2hvcihwYXR0ZXJuKSB7XG4gICAgICAgIHZhciBsZWFkaW5nQW5jaG9yID0gL15cXF4vLFxuICAgICAgICAgICAgdHJhaWxpbmdBbmNob3IgPSAvXFwkJC87XG5cbiAgICAgICAgLy8gRW5zdXJlIHRoYXQgdGhlIHRyYWlsaW5nIGAkYCBpc24ndCBlc2NhcGVkXG4gICAgICAgIGlmIChsZWFkaW5nQW5jaG9yLnRlc3QocGF0dGVybikgJiYgdHJhaWxpbmdBbmNob3IudGVzdChwYXR0ZXJuLnJlcGxhY2UoL1xcXFxbXFxzXFxTXS9nLCAnJykpKSB7XG4gICAgICAgICAgICByZXR1cm4gcGF0dGVybi5yZXBsYWNlKGxlYWRpbmdBbmNob3IsICcnKS5yZXBsYWNlKHRyYWlsaW5nQW5jaG9yLCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGF0dGVybjtcbiAgICB9XG5cbi8qKlxuICogQ29udmVydHMgdGhlIHByb3ZpZGVkIHZhbHVlIHRvIGFuIFhSZWdFeHAuIE5hdGl2ZSBSZWdFeHAgZmxhZ3MgYXJlIG5vdCBwcmVzZXJ2ZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfFJlZ0V4cH0gdmFsdWUgVmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtSZWdFeHB9IFhSZWdFeHAgb2JqZWN0IHdpdGggWFJlZ0V4cCBzeW50YXggYXBwbGllZC5cbiAqL1xuICAgIGZ1bmN0aW9uIGFzWFJlZ0V4cCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gWFJlZ0V4cC5pc1JlZ0V4cCh2YWx1ZSkgP1xuICAgICAgICAgICAgKHZhbHVlW1JFR0VYX0RBVEFdICYmIHZhbHVlW1JFR0VYX0RBVEFdLmNhcHR1cmVOYW1lcyA/XG4gICAgICAgICAgICAgICAgLy8gRG9uJ3QgcmVjb21waWxlLCB0byBwcmVzZXJ2ZSBjYXB0dXJlIG5hbWVzXG4gICAgICAgICAgICAgICAgdmFsdWUgOlxuICAgICAgICAgICAgICAgIC8vIFJlY29tcGlsZSBhcyBYUmVnRXhwXG4gICAgICAgICAgICAgICAgWFJlZ0V4cCh2YWx1ZS5zb3VyY2UpXG4gICAgICAgICAgICApIDpcbiAgICAgICAgICAgIC8vIENvbXBpbGUgc3RyaW5nIGFzIFhSZWdFeHBcbiAgICAgICAgICAgIFhSZWdFeHAodmFsdWUpO1xuICAgIH1cblxuLyoqXG4gKiBCdWlsZHMgcmVnZXhlcyB1c2luZyBuYW1lZCBzdWJwYXR0ZXJucywgZm9yIHJlYWRhYmlsaXR5IGFuZCBwYXR0ZXJuIHJldXNlLiBCYWNrcmVmZXJlbmNlcyBpbiB0aGVcbiAqIG91dGVyIHBhdHRlcm4gYW5kIHByb3ZpZGVkIHN1YnBhdHRlcm5zIGFyZSBhdXRvbWF0aWNhbGx5IHJlbnVtYmVyZWQgdG8gd29yayBjb3JyZWN0bHkuIE5hdGl2ZVxuICogZmxhZ3MgdXNlZCBieSBwcm92aWRlZCBzdWJwYXR0ZXJucyBhcmUgaWdub3JlZCBpbiBmYXZvciBvZiB0aGUgYGZsYWdzYCBhcmd1bWVudC5cbiAqXG4gKiBAbWVtYmVyT2YgWFJlZ0V4cFxuICogQHBhcmFtIHtTdHJpbmd9IHBhdHRlcm4gWFJlZ0V4cCBwYXR0ZXJuIHVzaW5nIGB7e25hbWV9fWAgZm9yIGVtYmVkZGVkIHN1YnBhdHRlcm5zLiBBbGxvd3NcbiAqICAgYCh7e25hbWV9fSlgIGFzIHNob3J0aGFuZCBmb3IgYCg/PG5hbWU+e3tuYW1lfX0pYC4gUGF0dGVybnMgY2Fubm90IGJlIGVtYmVkZGVkIHdpdGhpblxuICogICBjaGFyYWN0ZXIgY2xhc3Nlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdWJzIExvb2t1cCBvYmplY3QgZm9yIG5hbWVkIHN1YnBhdHRlcm5zLiBWYWx1ZXMgY2FuIGJlIHN0cmluZ3Mgb3IgcmVnZXhlcy4gQVxuICogICBsZWFkaW5nIGBeYCBhbmQgdHJhaWxpbmcgdW5lc2NhcGVkIGAkYCBhcmUgc3RyaXBwZWQgZnJvbSBzdWJwYXR0ZXJucywgaWYgYm90aCBhcmUgcHJlc2VudC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbZmxhZ3NdIEFueSBjb21iaW5hdGlvbiBvZiBYUmVnRXhwIGZsYWdzLlxuICogQHJldHVybnMge1JlZ0V4cH0gUmVnZXggd2l0aCBpbnRlcnBvbGF0ZWQgc3VicGF0dGVybnMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciB0aW1lID0gWFJlZ0V4cC5idWlsZCgnKD94KV4ge3tob3Vyc319ICh7e21pbnV0ZXN9fSkgJCcsIHtcbiAqICAgaG91cnM6IFhSZWdFeHAuYnVpbGQoJ3t7aDEyfX0gOiB8IHt7aDI0fX0nLCB7XG4gKiAgICAgaDEyOiAvMVswLTJdfDA/WzEtOV0vLFxuICogICAgIGgyNDogLzJbMC0zXXxbMDFdWzAtOV0vXG4gKiAgIH0sICd4JyksXG4gKiAgIG1pbnV0ZXM6IC9eWzAtNV1bMC05XSQvXG4gKiB9KTtcbiAqIHRpbWUudGVzdCgnMTA6NTknKTsgLy8gLT4gdHJ1ZVxuICogWFJlZ0V4cC5leGVjKCcxMDo1OScsIHRpbWUpLm1pbnV0ZXM7IC8vIC0+ICc1OSdcbiAqL1xuICAgIFhSZWdFeHAuYnVpbGQgPSBmdW5jdGlvbihwYXR0ZXJuLCBzdWJzLCBmbGFncykge1xuICAgICAgICB2YXIgaW5saW5lRmxhZ3MgPSAvXlxcKFxcPyhbXFx3JF0rKVxcKS8uZXhlYyhwYXR0ZXJuKSxcbiAgICAgICAgICAgIGRhdGEgPSB7fSxcbiAgICAgICAgICAgIG51bUNhcHMgPSAwLCAvLyAnQ2FwcycgaXMgc2hvcnQgZm9yIGNhcHR1cmVzXG4gICAgICAgICAgICBudW1QcmlvckNhcHMsXG4gICAgICAgICAgICBudW1PdXRlckNhcHMgPSAwLFxuICAgICAgICAgICAgb3V0ZXJDYXBzTWFwID0gWzBdLFxuICAgICAgICAgICAgb3V0ZXJDYXBOYW1lcyxcbiAgICAgICAgICAgIHN1YixcbiAgICAgICAgICAgIHA7XG5cbiAgICAgICAgLy8gQWRkIGZsYWdzIHdpdGhpbiBhIGxlYWRpbmcgbW9kZSBtb2RpZmllciB0byB0aGUgb3ZlcmFsbCBwYXR0ZXJuJ3MgZmxhZ3NcbiAgICAgICAgaWYgKGlubGluZUZsYWdzKSB7XG4gICAgICAgICAgICBmbGFncyA9IGZsYWdzIHx8ICcnO1xuICAgICAgICAgICAgaW5saW5lRmxhZ3NbMV0ucmVwbGFjZSgvLi9nLCBmdW5jdGlvbihmbGFnKSB7XG4gICAgICAgICAgICAgICAgLy8gRG9uJ3QgYWRkIGR1cGxpY2F0ZXNcbiAgICAgICAgICAgICAgICBmbGFncyArPSAoZmxhZ3MuaW5kZXhPZihmbGFnKSA+IC0xID8gJycgOiBmbGFnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChwIGluIHN1YnMpIHtcbiAgICAgICAgICAgIGlmIChzdWJzLmhhc093blByb3BlcnR5KHApKSB7XG4gICAgICAgICAgICAgICAgLy8gUGFzc2luZyB0byBYUmVnRXhwIGVuYWJsZXMgZXh0ZW5kZWQgc3ludGF4IGFuZCBlbnN1cmVzIGluZGVwZW5kZW50IHZhbGlkaXR5LFxuICAgICAgICAgICAgICAgIC8vIGxlc3QgYW4gdW5lc2NhcGVkIGAoYCwgYClgLCBgW2AsIG9yIHRyYWlsaW5nIGBcXGAgYnJlYWtzIHRoZSBgKD86KWAgd3JhcHBlci4gRm9yXG4gICAgICAgICAgICAgICAgLy8gc3VicGF0dGVybnMgcHJvdmlkZWQgYXMgbmF0aXZlIHJlZ2V4ZXMsIGl0IGRpZXMgb24gb2N0YWxzIGFuZCBhZGRzIHRoZSBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgIC8vIHVzZWQgdG8gaG9sZCBleHRlbmRlZCByZWdleCBpbnN0YW5jZSBkYXRhLCBmb3Igc2ltcGxpY2l0eVxuICAgICAgICAgICAgICAgIHN1YiA9IGFzWFJlZ0V4cChzdWJzW3BdKTtcbiAgICAgICAgICAgICAgICBkYXRhW3BdID0ge1xuICAgICAgICAgICAgICAgICAgICAvLyBEZWFuY2hvcmluZyBhbGxvd3MgZW1iZWRkaW5nIGluZGVwZW5kZW50bHkgdXNlZnVsIGFuY2hvcmVkIHJlZ2V4ZXMuIElmIHlvdVxuICAgICAgICAgICAgICAgICAgICAvLyByZWFsbHkgbmVlZCB0byBrZWVwIHlvdXIgYW5jaG9ycywgZG91YmxlIHRoZW0gKGkuZS4sIGBeXi4uLiQkYClcbiAgICAgICAgICAgICAgICAgICAgcGF0dGVybjogZGVhbmNob3Ioc3ViLnNvdXJjZSksXG4gICAgICAgICAgICAgICAgICAgIG5hbWVzOiBzdWJbUkVHRVhfREFUQV0uY2FwdHVyZU5hbWVzIHx8IFtdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFBhc3NpbmcgdG8gWFJlZ0V4cCBkaWVzIG9uIG9jdGFscyBhbmQgZW5zdXJlcyB0aGUgb3V0ZXIgcGF0dGVybiBpcyBpbmRlcGVuZGVudGx5IHZhbGlkO1xuICAgICAgICAvLyBoZWxwcyBrZWVwIHRoaXMgc2ltcGxlLiBOYW1lZCBjYXB0dXJlcyB3aWxsIGJlIHB1dCBiYWNrXG4gICAgICAgIHBhdHRlcm4gPSBhc1hSZWdFeHAocGF0dGVybik7XG4gICAgICAgIG91dGVyQ2FwTmFtZXMgPSBwYXR0ZXJuW1JFR0VYX0RBVEFdLmNhcHR1cmVOYW1lcyB8fCBbXTtcbiAgICAgICAgcGF0dGVybiA9IHBhdHRlcm4uc291cmNlLnJlcGxhY2UocGFydHMsIGZ1bmN0aW9uKCQwLCAkMSwgJDIsICQzLCAkNCkge1xuICAgICAgICAgICAgdmFyIHN1Yk5hbWUgPSAkMSB8fCAkMiwgY2FwTmFtZSwgaW50cm87XG4gICAgICAgICAgICAvLyBOYW1lZCBzdWJwYXR0ZXJuXG4gICAgICAgICAgICBpZiAoc3ViTmFtZSkge1xuICAgICAgICAgICAgICAgIGlmICghZGF0YS5oYXNPd25Qcm9wZXJ0eShzdWJOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoJ1VuZGVmaW5lZCBwcm9wZXJ0eSAnICsgJDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBOYW1lZCBzdWJwYXR0ZXJuIHdhcyB3cmFwcGVkIGluIGEgY2FwdHVyaW5nIGdyb3VwXG4gICAgICAgICAgICAgICAgaWYgKCQxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhcE5hbWUgPSBvdXRlckNhcE5hbWVzW251bU91dGVyQ2Fwc107XG4gICAgICAgICAgICAgICAgICAgIG91dGVyQ2Fwc01hcFsrK251bU91dGVyQ2Fwc10gPSArK251bUNhcHM7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGl0J3MgYSBuYW1lZCBncm91cCwgcHJlc2VydmUgdGhlIG5hbWUuIE90aGVyd2lzZSwgdXNlIHRoZSBzdWJwYXR0ZXJuIG5hbWVcbiAgICAgICAgICAgICAgICAgICAgLy8gYXMgdGhlIGNhcHR1cmUgbmFtZVxuICAgICAgICAgICAgICAgICAgICBpbnRybyA9ICcoPzwnICsgKGNhcE5hbWUgfHwgc3ViTmFtZSkgKyAnPic7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW50cm8gPSAnKD86JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbnVtUHJpb3JDYXBzID0gbnVtQ2FwcztcbiAgICAgICAgICAgICAgICByZXR1cm4gaW50cm8gKyBkYXRhW3N1Yk5hbWVdLnBhdHRlcm4ucmVwbGFjZShzdWJQYXJ0cywgZnVuY3Rpb24obWF0Y2gsIHBhcmVuLCBiYWNrcmVmKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENhcHR1cmluZyBncm91cFxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhcE5hbWUgPSBkYXRhW3N1Yk5hbWVdLm5hbWVzW251bUNhcHMgLSBudW1QcmlvckNhcHNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgKytudW1DYXBzO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGN1cnJlbnQgY2FwdHVyZSBoYXMgYSBuYW1lLCBwcmVzZXJ2ZSB0aGUgbmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhcE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyg/PCcgKyBjYXBOYW1lICsgJz4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBCYWNrcmVmZXJlbmNlXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYmFja3JlZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV3cml0ZSB0aGUgYmFja3JlZmVyZW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdcXFxcJyArICgrYmFja3JlZiArIG51bVByaW9yQ2Fwcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgICAgICAgICAgIH0pICsgJyknO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2FwdHVyaW5nIGdyb3VwXG4gICAgICAgICAgICBpZiAoJDMpIHtcbiAgICAgICAgICAgICAgICBjYXBOYW1lID0gb3V0ZXJDYXBOYW1lc1tudW1PdXRlckNhcHNdO1xuICAgICAgICAgICAgICAgIG91dGVyQ2Fwc01hcFsrK251bU91dGVyQ2Fwc10gPSArK251bUNhcHM7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGN1cnJlbnQgY2FwdHVyZSBoYXMgYSBuYW1lLCBwcmVzZXJ2ZSB0aGUgbmFtZVxuICAgICAgICAgICAgICAgIGlmIChjYXBOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnKD88JyArIGNhcE5hbWUgKyAnPic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQmFja3JlZmVyZW5jZVxuICAgICAgICAgICAgfSBlbHNlIGlmICgkNCkge1xuICAgICAgICAgICAgICAgIC8vIFJld3JpdGUgdGhlIGJhY2tyZWZlcmVuY2VcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1xcXFwnICsgb3V0ZXJDYXBzTWFwWyskNF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJDA7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBYUmVnRXhwKHBhdHRlcm4sIGZsYWdzKTtcbiAgICB9O1xuXG59KFhSZWdFeHApKTtcblxuLyohXG4gKiBYUmVnRXhwLm1hdGNoUmVjdXJzaXZlIDMuMC4wXG4gKiA8aHR0cDovL3hyZWdleHAuY29tLz5cbiAqIFN0ZXZlbiBMZXZpdGhhbiAoYykgMjAwOS0yMDE1IE1JVCBMaWNlbnNlXG4gKi9cblxuKGZ1bmN0aW9uKFhSZWdFeHApIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbi8qKlxuICogUmV0dXJucyBhIG1hdGNoIGRldGFpbCBvYmplY3QgY29tcG9zZWQgb2YgdGhlIHByb3ZpZGVkIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG4gICAgZnVuY3Rpb24gcm93KG5hbWUsIHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBlbmRcbiAgICAgICAgfTtcbiAgICB9XG5cbi8qKlxuICogUmV0dXJucyBhbiBhcnJheSBvZiBtYXRjaCBzdHJpbmdzIGJldHdlZW4gb3V0ZXJtb3N0IGxlZnQgYW5kIHJpZ2h0IGRlbGltaXRlcnMsIG9yIGFuIGFycmF5IG9mXG4gKiBvYmplY3RzIHdpdGggZGV0YWlsZWQgbWF0Y2ggcGFydHMgYW5kIHBvc2l0aW9uIGRhdGEuIEFuIGVycm9yIGlzIHRocm93biBpZiBkZWxpbWl0ZXJzIGFyZVxuICogdW5iYWxhbmNlZCB3aXRoaW4gdGhlIGRhdGEuXG4gKlxuICogQG1lbWJlck9mIFhSZWdFeHBcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgU3RyaW5nIHRvIHNlYXJjaC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBsZWZ0IExlZnQgZGVsaW1pdGVyIGFzIGFuIFhSZWdFeHAgcGF0dGVybi5cbiAqIEBwYXJhbSB7U3RyaW5nfSByaWdodCBSaWdodCBkZWxpbWl0ZXIgYXMgYW4gWFJlZ0V4cCBwYXR0ZXJuLlxuICogQHBhcmFtIHtTdHJpbmd9IFtmbGFnc10gQW55IG5hdGl2ZSBvciBYUmVnRXhwIGZsYWdzLCB1c2VkIGZvciB0aGUgbGVmdCBhbmQgcmlnaHQgZGVsaW1pdGVycy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gTGV0cyB5b3Ugc3BlY2lmeSBgdmFsdWVOYW1lc2AgYW5kIGBlc2NhcGVDaGFyYCBvcHRpb25zLlxuICogQHJldHVybnMge0FycmF5fSBBcnJheSBvZiBtYXRjaGVzLCBvciBhbiBlbXB0eSBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gQmFzaWMgdXNhZ2VcbiAqIHZhciBzdHIgPSAnKHQoKGUpKXMpdCgpKGluZyknO1xuICogWFJlZ0V4cC5tYXRjaFJlY3Vyc2l2ZShzdHIsICdcXFxcKCcsICdcXFxcKScsICdnJyk7XG4gKiAvLyAtPiBbJ3QoKGUpKXMnLCAnJywgJ2luZyddXG4gKlxuICogLy8gRXh0ZW5kZWQgaW5mb3JtYXRpb24gbW9kZSB3aXRoIHZhbHVlTmFtZXNcbiAqIHN0ciA9ICdIZXJlIGlzIDxkaXY+IDxkaXY+YW48L2Rpdj48L2Rpdj4gZXhhbXBsZSc7XG4gKiBYUmVnRXhwLm1hdGNoUmVjdXJzaXZlKHN0ciwgJzxkaXZcXFxccyo+JywgJzwvZGl2PicsICdnaScsIHtcbiAqICAgdmFsdWVOYW1lczogWydiZXR3ZWVuJywgJ2xlZnQnLCAnbWF0Y2gnLCAncmlnaHQnXVxuICogfSk7XG4gKiAvLyAtPiBbXG4gKiAvLyB7bmFtZTogJ2JldHdlZW4nLCB2YWx1ZTogJ0hlcmUgaXMgJywgICAgICAgc3RhcnQ6IDAsICBlbmQ6IDh9LFxuICogLy8ge25hbWU6ICdsZWZ0JywgICAgdmFsdWU6ICc8ZGl2PicsICAgICAgICAgIHN0YXJ0OiA4LCAgZW5kOiAxM30sXG4gKiAvLyB7bmFtZTogJ21hdGNoJywgICB2YWx1ZTogJyA8ZGl2PmFuPC9kaXY+Jywgc3RhcnQ6IDEzLCBlbmQ6IDI3fSxcbiAqIC8vIHtuYW1lOiAncmlnaHQnLCAgIHZhbHVlOiAnPC9kaXY+JywgICAgICAgICBzdGFydDogMjcsIGVuZDogMzN9LFxuICogLy8ge25hbWU6ICdiZXR3ZWVuJywgdmFsdWU6ICcgZXhhbXBsZScsICAgICAgIHN0YXJ0OiAzMywgZW5kOiA0MX1cbiAqIC8vIF1cbiAqXG4gKiAvLyBPbWl0dGluZyB1bm5lZWRlZCBwYXJ0cyB3aXRoIG51bGwgdmFsdWVOYW1lcywgYW5kIHVzaW5nIGVzY2FwZUNoYXJcbiAqIHN0ciA9ICcuLi57MX1cXFxce3tmdW5jdGlvbih4LHkpe3JldHVybiB5K3g7fX0nO1xuICogWFJlZ0V4cC5tYXRjaFJlY3Vyc2l2ZShzdHIsICd7JywgJ30nLCAnZycsIHtcbiAqICAgdmFsdWVOYW1lczogWydsaXRlcmFsJywgbnVsbCwgJ3ZhbHVlJywgbnVsbF0sXG4gKiAgIGVzY2FwZUNoYXI6ICdcXFxcJ1xuICogfSk7XG4gKiAvLyAtPiBbXG4gKiAvLyB7bmFtZTogJ2xpdGVyYWwnLCB2YWx1ZTogJy4uLicsIHN0YXJ0OiAwLCBlbmQ6IDN9LFxuICogLy8ge25hbWU6ICd2YWx1ZScsICAgdmFsdWU6ICcxJywgICBzdGFydDogNCwgZW5kOiA1fSxcbiAqIC8vIHtuYW1lOiAnbGl0ZXJhbCcsIHZhbHVlOiAnXFxcXHsnLCBzdGFydDogNiwgZW5kOiA4fSxcbiAqIC8vIHtuYW1lOiAndmFsdWUnLCAgIHZhbHVlOiAnZnVuY3Rpb24oeCx5KXtyZXR1cm4geSt4O30nLCBzdGFydDogOSwgZW5kOiAzNX1cbiAqIC8vIF1cbiAqXG4gKiAvLyBTdGlja3kgbW9kZSB2aWEgZmxhZyB5XG4gKiBzdHIgPSAnPDE+PDw8Mj4+PjwzPjQ8NT4nO1xuICogWFJlZ0V4cC5tYXRjaFJlY3Vyc2l2ZShzdHIsICc8JywgJz4nLCAnZ3knKTtcbiAqIC8vIC0+IFsnMScsICc8PDI+PicsICczJ11cbiAqL1xuICAgIFhSZWdFeHAubWF0Y2hSZWN1cnNpdmUgPSBmdW5jdGlvbihzdHIsIGxlZnQsIHJpZ2h0LCBmbGFncywgb3B0aW9ucykge1xuICAgICAgICBmbGFncyA9IGZsYWdzIHx8ICcnO1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgdmFyIGdsb2JhbCA9IGZsYWdzLmluZGV4T2YoJ2cnKSA+IC0xLFxuICAgICAgICAgICAgc3RpY2t5ID0gZmxhZ3MuaW5kZXhPZigneScpID4gLTEsXG4gICAgICAgICAgICAvLyBGbGFnIGB5YCBpcyBjb250cm9sbGVkIGludGVybmFsbHlcbiAgICAgICAgICAgIGJhc2ljRmxhZ3MgPSBmbGFncy5yZXBsYWNlKC95L2csICcnKSxcbiAgICAgICAgICAgIGVzY2FwZUNoYXIgPSBvcHRpb25zLmVzY2FwZUNoYXIsXG4gICAgICAgICAgICB2TiA9IG9wdGlvbnMudmFsdWVOYW1lcyxcbiAgICAgICAgICAgIG91dHB1dCA9IFtdLFxuICAgICAgICAgICAgb3BlblRva2VucyA9IDAsXG4gICAgICAgICAgICBkZWxpbVN0YXJ0ID0gMCxcbiAgICAgICAgICAgIGRlbGltRW5kID0gMCxcbiAgICAgICAgICAgIGxhc3RPdXRlckVuZCA9IDAsXG4gICAgICAgICAgICBvdXRlclN0YXJ0LFxuICAgICAgICAgICAgaW5uZXJTdGFydCxcbiAgICAgICAgICAgIGxlZnRNYXRjaCxcbiAgICAgICAgICAgIHJpZ2h0TWF0Y2gsXG4gICAgICAgICAgICBlc2M7XG4gICAgICAgIGxlZnQgPSBYUmVnRXhwKGxlZnQsIGJhc2ljRmxhZ3MpO1xuICAgICAgICByaWdodCA9IFhSZWdFeHAocmlnaHQsIGJhc2ljRmxhZ3MpO1xuXG4gICAgICAgIGlmIChlc2NhcGVDaGFyKSB7XG4gICAgICAgICAgICBpZiAoZXNjYXBlQ2hhci5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgdXNlIG1vcmUgdGhhbiBvbmUgZXNjYXBlIGNoYXJhY3RlcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXNjYXBlQ2hhciA9IFhSZWdFeHAuZXNjYXBlKGVzY2FwZUNoYXIpO1xuICAgICAgICAgICAgLy8gVXNpbmcgYFhSZWdFeHAudW5pb25gIHNhZmVseSByZXdyaXRlcyBiYWNrcmVmZXJlbmNlcyBpbiBgbGVmdGAgYW5kIGByaWdodGBcbiAgICAgICAgICAgIGVzYyA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAgICAgJyg/OicgKyBlc2NhcGVDaGFyICsgJ1tcXFxcU1xcXFxzXXwoPzooPyEnICtcbiAgICAgICAgICAgICAgICAgICAgWFJlZ0V4cC51bmlvbihbbGVmdCwgcmlnaHRdKS5zb3VyY2UgK1xuICAgICAgICAgICAgICAgICAgICAnKVteJyArIGVzY2FwZUNoYXIgKyAnXSkrKSsnLFxuICAgICAgICAgICAgICAgIC8vIEZsYWdzIGBneWAgbm90IG5lZWRlZCBoZXJlXG4gICAgICAgICAgICAgICAgZmxhZ3MucmVwbGFjZSgvW15pbXVdKy9nLCAnJylcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgLy8gSWYgdXNpbmcgYW4gZXNjYXBlIGNoYXJhY3RlciwgYWR2YW5jZSB0byB0aGUgZGVsaW1pdGVyJ3MgbmV4dCBzdGFydGluZyBwb3NpdGlvbixcbiAgICAgICAgICAgIC8vIHNraXBwaW5nIGFueSBlc2NhcGVkIGNoYXJhY3RlcnMgaW4gYmV0d2VlblxuICAgICAgICAgICAgaWYgKGVzY2FwZUNoYXIpIHtcbiAgICAgICAgICAgICAgICBkZWxpbUVuZCArPSAoWFJlZ0V4cC5leGVjKHN0ciwgZXNjLCBkZWxpbUVuZCwgJ3N0aWNreScpIHx8IFsnJ10pWzBdLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxlZnRNYXRjaCA9IFhSZWdFeHAuZXhlYyhzdHIsIGxlZnQsIGRlbGltRW5kKTtcbiAgICAgICAgICAgIHJpZ2h0TWF0Y2ggPSBYUmVnRXhwLmV4ZWMoc3RyLCByaWdodCwgZGVsaW1FbmQpO1xuICAgICAgICAgICAgLy8gS2VlcCB0aGUgbGVmdG1vc3QgbWF0Y2ggb25seVxuICAgICAgICAgICAgaWYgKGxlZnRNYXRjaCAmJiByaWdodE1hdGNoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxlZnRNYXRjaC5pbmRleCA8PSByaWdodE1hdGNoLmluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0TWF0Y2ggPSBudWxsO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnRNYXRjaCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUGF0aHMgKExNOiBsZWZ0TWF0Y2gsIFJNOiByaWdodE1hdGNoLCBPVDogb3BlblRva2Vucyk6XG4gICAgICAgICAgICAvLyBMTSB8IFJNIHwgT1QgfCBSZXN1bHRcbiAgICAgICAgICAgIC8vIDEgIHwgMCAgfCAxICB8IGxvb3BcbiAgICAgICAgICAgIC8vIDEgIHwgMCAgfCAwICB8IGxvb3BcbiAgICAgICAgICAgIC8vIDAgIHwgMSAgfCAxICB8IGxvb3BcbiAgICAgICAgICAgIC8vIDAgIHwgMSAgfCAwICB8IHRocm93XG4gICAgICAgICAgICAvLyAwICB8IDAgIHwgMSAgfCB0aHJvd1xuICAgICAgICAgICAgLy8gMCAgfCAwICB8IDAgIHwgYnJlYWtcbiAgICAgICAgICAgIC8vIFRoZSBwYXRocyBhYm92ZSBkb24ndCBpbmNsdWRlIHRoZSBzdGlja3kgbW9kZSBzcGVjaWFsIGNhc2UuIFRoZSBsb29wIGVuZHMgYWZ0ZXIgdGhlXG4gICAgICAgICAgICAvLyBmaXJzdCBjb21wbGV0ZWQgbWF0Y2ggaWYgbm90IGBnbG9iYWxgLlxuICAgICAgICAgICAgaWYgKGxlZnRNYXRjaCB8fCByaWdodE1hdGNoKSB7XG4gICAgICAgICAgICAgICAgZGVsaW1TdGFydCA9IChsZWZ0TWF0Y2ggfHwgcmlnaHRNYXRjaCkuaW5kZXg7XG4gICAgICAgICAgICAgICAgZGVsaW1FbmQgPSBkZWxpbVN0YXJ0ICsgKGxlZnRNYXRjaCB8fCByaWdodE1hdGNoKVswXS5sZW5ndGg7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFvcGVuVG9rZW5zKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RpY2t5ICYmICFvcGVuVG9rZW5zICYmIGRlbGltU3RhcnQgPiBsYXN0T3V0ZXJFbmQpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsZWZ0TWF0Y2gpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW9wZW5Ub2tlbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0ZXJTdGFydCA9IGRlbGltU3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgIGlubmVyU3RhcnQgPSBkZWxpbUVuZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKytvcGVuVG9rZW5zO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChyaWdodE1hdGNoICYmIG9wZW5Ub2tlbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIS0tb3BlblRva2Vucykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodk4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2TlswXSAmJiBvdXRlclN0YXJ0ID4gbGFzdE91dGVyRW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2gocm93KHZOWzBdLCBzdHIuc2xpY2UobGFzdE91dGVyRW5kLCBvdXRlclN0YXJ0KSwgbGFzdE91dGVyRW5kLCBvdXRlclN0YXJ0KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodk5bMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChyb3codk5bMV0sIHN0ci5zbGljZShvdXRlclN0YXJ0LCBpbm5lclN0YXJ0KSwgb3V0ZXJTdGFydCwgaW5uZXJTdGFydCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZOWzJdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2gocm93KHZOWzJdLCBzdHIuc2xpY2UoaW5uZXJTdGFydCwgZGVsaW1TdGFydCksIGlubmVyU3RhcnQsIGRlbGltU3RhcnQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2TlszXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKHJvdyh2TlszXSwgc3RyLnNsaWNlKGRlbGltU3RhcnQsIGRlbGltRW5kKSwgZGVsaW1TdGFydCwgZGVsaW1FbmQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKHN0ci5zbGljZShpbm5lclN0YXJ0LCBkZWxpbVN0YXJ0KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGFzdE91dGVyRW5kID0gZGVsaW1FbmQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZ2xvYmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmJhbGFuY2VkIGRlbGltaXRlciBmb3VuZCBpbiBzdHJpbmcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoZSBkZWxpbWl0ZXIgbWF0Y2hlZCBhbiBlbXB0eSBzdHJpbmcsIGF2b2lkIGFuIGluZmluaXRlIGxvb3BcbiAgICAgICAgICAgIGlmIChkZWxpbVN0YXJ0ID09PSBkZWxpbUVuZCkge1xuICAgICAgICAgICAgICAgICsrZGVsaW1FbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZ2xvYmFsICYmICFzdGlja3kgJiYgdk4gJiYgdk5bMF0gJiYgc3RyLmxlbmd0aCA+IGxhc3RPdXRlckVuZCkge1xuICAgICAgICAgICAgb3V0cHV0LnB1c2gocm93KHZOWzBdLCBzdHIuc2xpY2UobGFzdE91dGVyRW5kKSwgbGFzdE91dGVyRW5kLCBzdHIubGVuZ3RoKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH07XG5cbn0oWFJlZ0V4cCkpO1xuXG4vKiFcbiAqIFhSZWdFeHAgVW5pY29kZSBCYXNlIDMuMC4wXG4gKiA8aHR0cDovL3hyZWdleHAuY29tLz5cbiAqIFN0ZXZlbiBMZXZpdGhhbiAoYykgMjAwOC0yMDE1IE1JVCBMaWNlbnNlXG4gKi9cblxuLyoqXG4gKiBBZGRzIGJhc2Ugc3VwcG9ydCBmb3IgVW5pY29kZSBtYXRjaGluZzpcbiAqIC0gQWRkcyBzeW50YXggYFxccHsuLn1gIGZvciBtYXRjaGluZyBVbmljb2RlIHRva2Vucy4gVG9rZW5zIGNhbiBiZSBpbnZlcnRlZCB1c2luZyBgXFxQey4ufWAgb3JcbiAqICAgYFxccHteLi59YC4gVG9rZW4gbmFtZXMgaWdub3JlIGNhc2UsIHNwYWNlcywgaHlwaGVucywgYW5kIHVuZGVyc2NvcmVzLiBZb3UgY2FuIG9taXQgdGhlIGJyYWNrZXRzXG4gKiAgIGZvciB0b2tlbiBuYW1lcyB0aGF0IGFyZSBhIHNpbmdsZSBsZXR0ZXIgKGUuZy4gYFxccExgIG9yIGBQTGApLlxuICogLSBBZGRzIGZsYWcgQSAoYXN0cmFsKSwgd2hpY2ggZW5hYmxlcyAyMS1iaXQgVW5pY29kZSBzdXBwb3J0LlxuICogLSBBZGRzIHRoZSBgWFJlZ0V4cC5hZGRVbmljb2RlRGF0YWAgbWV0aG9kIHVzZWQgYnkgb3RoZXIgYWRkb25zIHRvIHByb3ZpZGUgY2hhcmFjdGVyIGRhdGEuXG4gKlxuICogVW5pY29kZSBCYXNlIHJlbGllcyBvbiBleHRlcm5hbGx5IHByb3ZpZGVkIFVuaWNvZGUgY2hhcmFjdGVyIGRhdGEuIE9mZmljaWFsIGFkZG9ucyBhcmUgYXZhaWxhYmxlXG4gKiB0byBwcm92aWRlIGRhdGEgZm9yIFVuaWNvZGUgY2F0ZWdvcmllcywgc2NyaXB0cywgYmxvY2tzLCBhbmQgcHJvcGVydGllcy5cbiAqXG4gKiBAcmVxdWlyZXMgWFJlZ0V4cFxuICovXG4oZnVuY3Rpb24oWFJlZ0V4cCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuLy8gU3RvcmFnZSBmb3IgVW5pY29kZSBkYXRhXG4gICAgdmFyIHVuaWNvZGUgPSB7fTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBQcml2YXRlIGZ1bmN0aW9uc1xuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cbi8vIEdlbmVyYXRlcyBhIHRva2VuIGxvb2t1cCBuYW1lOiBsb3dlcmNhc2UsIHdpdGggaHlwaGVucywgc3BhY2VzLCBhbmQgdW5kZXJzY29yZXMgcmVtb3ZlZFxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZShuYW1lKSB7XG4gICAgICAgIHJldHVybiBuYW1lLnJlcGxhY2UoL1stIF9dKy9nLCAnJykudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbi8vIEFkZHMgbGVhZGluZyB6ZXJvcyBpZiBzaG9ydGVyIHRoYW4gZm91ciBjaGFyYWN0ZXJzXG4gICAgZnVuY3Rpb24gcGFkNChzdHIpIHtcbiAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCA0KSB7XG4gICAgICAgICAgICBzdHIgPSAnMCcgKyBzdHI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG5cbi8vIENvbnZlcnRzIGEgaGV4YWRlY2ltYWwgbnVtYmVyIHRvIGRlY2ltYWxcbiAgICBmdW5jdGlvbiBkZWMoaGV4KSB7XG4gICAgICAgIHJldHVybiBwYXJzZUludChoZXgsIDE2KTtcbiAgICB9XG5cbi8vIENvbnZlcnRzIGEgZGVjaW1hbCBudW1iZXIgdG8gaGV4YWRlY2ltYWxcbiAgICBmdW5jdGlvbiBoZXgoZGVjKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUludChkZWMsIDEwKS50b1N0cmluZygxNik7XG4gICAgfVxuXG4vLyBHZXRzIHRoZSBkZWNpbWFsIGNvZGUgb2YgYSBsaXRlcmFsIGNvZGUgdW5pdCwgXFx4SEgsIFxcdUhISEgsIG9yIGEgYmFja3NsYXNoLWVzY2FwZWQgbGl0ZXJhbFxuICAgIGZ1bmN0aW9uIGNoYXJDb2RlKGNocikge1xuICAgICAgICB2YXIgZXNjID0gL15cXFxcW3h1XSguKykvLmV4ZWMoY2hyKTtcbiAgICAgICAgcmV0dXJuIGVzYyA/XG4gICAgICAgICAgICBkZWMoZXNjWzFdKSA6XG4gICAgICAgICAgICBjaHIuY2hhckNvZGVBdChjaHIuY2hhckF0KDApID09PSAnXFxcXCcgPyAxIDogMCk7XG4gICAgfVxuXG4vLyBJbnZlcnRzIGEgbGlzdCBvZiBvcmRlcmVkIEJNUCBjaGFyYWN0ZXJzIGFuZCByYW5nZXNcbiAgICBmdW5jdGlvbiBpbnZlcnRCbXAocmFuZ2UpIHtcbiAgICAgICAgdmFyIG91dHB1dCA9ICcnLFxuICAgICAgICAgICAgbGFzdEVuZCA9IC0xLFxuICAgICAgICAgICAgc3RhcnQ7XG4gICAgICAgIFhSZWdFeHAuZm9yRWFjaChyYW5nZSwgLyhcXFxceC4ufFxcXFx1Li4uLnxcXFxcP1tcXHNcXFNdKSg/Oi0oXFxcXHguLnxcXFxcdS4uLi58XFxcXD9bXFxzXFxTXSkpPy8sIGZ1bmN0aW9uKG0pIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gY2hhckNvZGUobVsxXSk7XG4gICAgICAgICAgICBpZiAoc3RhcnQgPiAobGFzdEVuZCArIDEpKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ICs9ICdcXFxcdScgKyBwYWQ0KGhleChsYXN0RW5kICsgMSkpO1xuICAgICAgICAgICAgICAgIGlmIChzdGFydCA+IChsYXN0RW5kICsgMikpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0ICs9ICctXFxcXHUnICsgcGFkNChoZXgoc3RhcnQgLSAxKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdEVuZCA9IGNoYXJDb2RlKG1bMl0gfHwgbVsxXSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAobGFzdEVuZCA8IDB4RkZGRikge1xuICAgICAgICAgICAgb3V0cHV0ICs9ICdcXFxcdScgKyBwYWQ0KGhleChsYXN0RW5kICsgMSkpO1xuICAgICAgICAgICAgaWYgKGxhc3RFbmQgPCAweEZGRkUpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgKz0gJy1cXFxcdUZGRkYnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuXG4vLyBHZW5lcmF0ZXMgYW4gaW52ZXJ0ZWQgQk1QIHJhbmdlIG9uIGZpcnN0IHVzZVxuICAgIGZ1bmN0aW9uIGNhY2hlSW52ZXJ0ZWRCbXAoc2x1Zykge1xuICAgICAgICB2YXIgcHJvcCA9ICdiISc7XG4gICAgICAgIHJldHVybiB1bmljb2RlW3NsdWddW3Byb3BdIHx8IChcbiAgICAgICAgICAgIHVuaWNvZGVbc2x1Z11bcHJvcF0gPSBpbnZlcnRCbXAodW5pY29kZVtzbHVnXS5ibXApXG4gICAgICAgICk7XG4gICAgfVxuXG4vLyBDb21iaW5lcyBhbmQgb3B0aW9uYWxseSBuZWdhdGVzIEJNUCBhbmQgYXN0cmFsIGRhdGFcbiAgICBmdW5jdGlvbiBidWlsZEFzdHJhbChzbHVnLCBpc05lZ2F0ZWQpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSB1bmljb2RlW3NsdWddLFxuICAgICAgICAgICAgY29tYmluZWQgPSAnJztcbiAgICAgICAgaWYgKGl0ZW0uYm1wICYmICFpdGVtLmlzQm1wTGFzdCkge1xuICAgICAgICAgICAgY29tYmluZWQgPSAnWycgKyBpdGVtLmJtcCArICddJyArIChpdGVtLmFzdHJhbCA/ICd8JyA6ICcnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXRlbS5hc3RyYWwpIHtcbiAgICAgICAgICAgIGNvbWJpbmVkICs9IGl0ZW0uYXN0cmFsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpdGVtLmlzQm1wTGFzdCAmJiBpdGVtLmJtcCkge1xuICAgICAgICAgICAgY29tYmluZWQgKz0gKGl0ZW0uYXN0cmFsID8gJ3wnIDogJycpICsgJ1snICsgaXRlbS5ibXAgKyAnXSc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXN0cmFsIFVuaWNvZGUgdG9rZW5zIGFsd2F5cyBtYXRjaCBhIGNvZGUgcG9pbnQsIG5ldmVyIGEgY29kZSB1bml0XG4gICAgICAgIHJldHVybiBpc05lZ2F0ZWQgP1xuICAgICAgICAgICAgJyg/Oig/IScgKyBjb21iaW5lZCArICcpKD86W1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXXxbXFwwLVxcdUZGRkZdKSknIDpcbiAgICAgICAgICAgICcoPzonICsgY29tYmluZWQgKyAnKSc7XG4gICAgfVxuXG4vLyBCdWlsZHMgYSBjb21wbGV0ZSBhc3RyYWwgcGF0dGVybiBvbiBmaXJzdCB1c2VcbiAgICBmdW5jdGlvbiBjYWNoZUFzdHJhbChzbHVnLCBpc05lZ2F0ZWQpIHtcbiAgICAgICAgdmFyIHByb3AgPSBpc05lZ2F0ZWQgPyAnYSEnIDogJ2E9JztcbiAgICAgICAgcmV0dXJuIHVuaWNvZGVbc2x1Z11bcHJvcF0gfHwgKFxuICAgICAgICAgICAgdW5pY29kZVtzbHVnXVtwcm9wXSA9IGJ1aWxkQXN0cmFsKHNsdWcsIGlzTmVnYXRlZClcbiAgICAgICAgKTtcbiAgICB9XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29yZSBmdW5jdGlvbmFsaXR5XG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuLypcbiAqIEFkZCBVbmljb2RlIHRva2VuIHN5bnRheDogXFxwey4ufSwgXFxQey4ufSwgXFxwe14uLn0uIEFsc28gYWRkIGFzdHJhbCBtb2RlIChmbGFnIEEpLlxuICovXG4gICAgWFJlZ0V4cC5hZGRUb2tlbihcbiAgICAgICAgLy8gVXNlIGAqYCBpbnN0ZWFkIG9mIGArYCB0byBhdm9pZCBjYXB0dXJpbmcgYF5gIGFzIHRoZSB0b2tlbiBuYW1lIGluIGBcXHB7Xn1gXG4gICAgICAgIC9cXFxcKFtwUF0pKD86eyhcXF4/KShbXn1dKil9fChbQS1aYS16XSkpLyxcbiAgICAgICAgZnVuY3Rpb24obWF0Y2gsIHNjb3BlLCBmbGFncykge1xuICAgICAgICAgICAgdmFyIEVSUl9ET1VCTEVfTkVHID0gJ0ludmFsaWQgZG91YmxlIG5lZ2F0aW9uICcsXG4gICAgICAgICAgICAgICAgRVJSX1VOS05PV05fTkFNRSA9ICdVbmtub3duIFVuaWNvZGUgdG9rZW4gJyxcbiAgICAgICAgICAgICAgICBFUlJfVU5LTk9XTl9SRUYgPSAnVW5pY29kZSB0b2tlbiBtaXNzaW5nIGRhdGEgJyxcbiAgICAgICAgICAgICAgICBFUlJfQVNUUkFMX09OTFkgPSAnQXN0cmFsIG1vZGUgcmVxdWlyZWQgZm9yIFVuaWNvZGUgdG9rZW4gJyxcbiAgICAgICAgICAgICAgICBFUlJfQVNUUkFMX0lOX0NMQVNTID0gJ0FzdHJhbCBtb2RlIGRvZXMgbm90IHN1cHBvcnQgVW5pY29kZSB0b2tlbnMgd2l0aGluIGNoYXJhY3RlciBjbGFzc2VzJyxcbiAgICAgICAgICAgICAgICAvLyBOZWdhdGVkIHZpYSBcXFB7Li59IG9yIFxccHteLi59XG4gICAgICAgICAgICAgICAgaXNOZWdhdGVkID0gbWF0Y2hbMV0gPT09ICdQJyB8fCAhIW1hdGNoWzJdLFxuICAgICAgICAgICAgICAgIC8vIFN3aXRjaCBmcm9tIEJNUCAoMC1GRkZGKSB0byBhc3RyYWwgKDAtMTBGRkZGKSBtb2RlIHZpYSBmbGFnIEFcbiAgICAgICAgICAgICAgICBpc0FzdHJhbE1vZGUgPSBmbGFncy5pbmRleE9mKCdBJykgPiAtMSxcbiAgICAgICAgICAgICAgICAvLyBUb2tlbiBsb29rdXAgbmFtZS4gQ2hlY2sgYFs0XWAgZmlyc3QgdG8gYXZvaWQgcGFzc2luZyBgdW5kZWZpbmVkYCB2aWEgYFxccHt9YFxuICAgICAgICAgICAgICAgIHNsdWcgPSBub3JtYWxpemUobWF0Y2hbNF0gfHwgbWF0Y2hbM10pLFxuICAgICAgICAgICAgICAgIC8vIFRva2VuIGRhdGEgb2JqZWN0XG4gICAgICAgICAgICAgICAgaXRlbSA9IHVuaWNvZGVbc2x1Z107XG5cbiAgICAgICAgICAgIGlmIChtYXRjaFsxXSA9PT0gJ1AnICYmIG1hdGNoWzJdKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKEVSUl9ET1VCTEVfTkVHICsgbWF0Y2hbMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF1bmljb2RlLmhhc093blByb3BlcnR5KHNsdWcpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKEVSUl9VTktOT1dOX05BTUUgKyBtYXRjaFswXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFN3aXRjaCB0byB0aGUgbmVnYXRlZCBmb3JtIG9mIHRoZSByZWZlcmVuY2VkIFVuaWNvZGUgdG9rZW5cbiAgICAgICAgICAgIGlmIChpdGVtLmludmVyc2VPZikge1xuICAgICAgICAgICAgICAgIHNsdWcgPSBub3JtYWxpemUoaXRlbS5pbnZlcnNlT2YpO1xuICAgICAgICAgICAgICAgIGlmICghdW5pY29kZS5oYXNPd25Qcm9wZXJ0eShzbHVnKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoRVJSX1VOS05PV05fUkVGICsgbWF0Y2hbMF0gKyAnIC0+ICcgKyBpdGVtLmludmVyc2VPZik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGl0ZW0gPSB1bmljb2RlW3NsdWddO1xuICAgICAgICAgICAgICAgIGlzTmVnYXRlZCA9ICFpc05lZ2F0ZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghKGl0ZW0uYm1wIHx8IGlzQXN0cmFsTW9kZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoRVJSX0FTVFJBTF9PTkxZICsgbWF0Y2hbMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzQXN0cmFsTW9kZSkge1xuICAgICAgICAgICAgICAgIGlmIChzY29wZSA9PT0gJ2NsYXNzJykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoRVJSX0FTVFJBTF9JTl9DTEFTUyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlQXN0cmFsKHNsdWcsIGlzTmVnYXRlZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBzY29wZSA9PT0gJ2NsYXNzJyA/XG4gICAgICAgICAgICAgICAgKGlzTmVnYXRlZCA/IGNhY2hlSW52ZXJ0ZWRCbXAoc2x1ZykgOiBpdGVtLmJtcCkgOlxuICAgICAgICAgICAgICAgIChpc05lZ2F0ZWQgPyAnW14nIDogJ1snKSArIGl0ZW0uYm1wICsgJ10nO1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBzY29wZTogJ2FsbCcsXG4gICAgICAgICAgICBvcHRpb25hbEZsYWdzOiAnQScsXG4gICAgICAgICAgICBsZWFkQ2hhcjogJ1xcXFwnXG4gICAgICAgIH1cbiAgICApO1xuXG4vKipcbiAqIEFkZHMgdG8gdGhlIGxpc3Qgb2YgVW5pY29kZSB0b2tlbnMgdGhhdCBYUmVnRXhwIHJlZ2V4ZXMgY2FuIG1hdGNoIHZpYSBgXFxwYCBvciBgXFxQYC5cbiAqXG4gKiBAbWVtYmVyT2YgWFJlZ0V4cFxuICogQHBhcmFtIHtBcnJheX0gZGF0YSBPYmplY3RzIHdpdGggbmFtZWQgY2hhcmFjdGVyIHJhbmdlcy4gRWFjaCBvYmplY3QgbWF5IGhhdmUgcHJvcGVydGllcyBgbmFtZWAsXG4gKiAgIGBhbGlhc2AsIGBpc0JtcExhc3RgLCBgaW52ZXJzZU9mYCwgYGJtcGAsIGFuZCBgYXN0cmFsYC4gQWxsIGJ1dCBgbmFtZWAgYXJlIG9wdGlvbmFsLCBhbHRob3VnaFxuICogICBvbmUgb2YgYGJtcGAgb3IgYGFzdHJhbGAgaXMgcmVxdWlyZWQgKHVubGVzcyBgaW52ZXJzZU9mYCBpcyBzZXQpLiBJZiBgYXN0cmFsYCBpcyBhYnNlbnQsIHRoZVxuICogICBgYm1wYCBkYXRhIGlzIHVzZWQgZm9yIEJNUCBhbmQgYXN0cmFsIG1vZGVzLiBJZiBgYm1wYCBpcyBhYnNlbnQsIHRoZSBuYW1lIGVycm9ycyBpbiBCTVAgbW9kZVxuICogICBidXQgd29ya3MgaW4gYXN0cmFsIG1vZGUuIElmIGJvdGggYGJtcGAgYW5kIGBhc3RyYWxgIGFyZSBwcm92aWRlZCwgdGhlIGBibXBgIGRhdGEgb25seSBpcyB1c2VkXG4gKiAgIGluIEJNUCBtb2RlLCBhbmQgdGhlIGNvbWJpbmF0aW9uIG9mIGBibXBgIGFuZCBgYXN0cmFsYCBkYXRhIGlzIHVzZWQgaW4gYXN0cmFsIG1vZGUuXG4gKiAgIGBpc0JtcExhc3RgIGlzIG5lZWRlZCB3aGVuIGEgdG9rZW4gbWF0Y2hlcyBvcnBoYW4gaGlnaCBzdXJyb2dhdGVzICphbmQqIHVzZXMgc3Vycm9nYXRlIHBhaXJzXG4gKiAgIHRvIG1hdGNoIGFzdHJhbCBjb2RlIHBvaW50cy4gVGhlIGBibXBgIGFuZCBgYXN0cmFsYCBkYXRhIHNob3VsZCBiZSBhIGNvbWJpbmF0aW9uIG9mIGxpdGVyYWxcbiAqICAgY2hhcmFjdGVycyBhbmQgYFxceEhIYCBvciBgXFx1SEhISGAgZXNjYXBlIHNlcXVlbmNlcywgd2l0aCBoeXBoZW5zIHRvIGNyZWF0ZSByYW5nZXMuIEFueSByZWdleFxuICogICBtZXRhY2hhcmFjdGVycyBpbiB0aGUgZGF0YSBzaG91bGQgYmUgZXNjYXBlZCwgYXBhcnQgZnJvbSByYW5nZS1jcmVhdGluZyBoeXBoZW5zLiBUaGUgYGFzdHJhbGBcbiAqICAgZGF0YSBjYW4gYWRkaXRpb25hbGx5IHVzZSBjaGFyYWN0ZXIgY2xhc3NlcyBhbmQgYWx0ZXJuYXRpb24sIGFuZCBzaG91bGQgdXNlIHN1cnJvZ2F0ZSBwYWlycyB0b1xuICogICByZXByZXNlbnQgYXN0cmFsIGNvZGUgcG9pbnRzLiBgaW52ZXJzZU9mYCBjYW4gYmUgdXNlZCB0byBhdm9pZCBkdXBsaWNhdGluZyBjaGFyYWN0ZXIgZGF0YSBpZiBhXG4gKiAgIFVuaWNvZGUgdG9rZW4gaXMgZGVmaW5lZCBhcyB0aGUgZXhhY3QgaW52ZXJzZSBvZiBhbm90aGVyIHRva2VuLlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBCYXNpYyB1c2VcbiAqIFhSZWdFeHAuYWRkVW5pY29kZURhdGEoW3tcbiAqICAgbmFtZTogJ1hEaWdpdCcsXG4gKiAgIGFsaWFzOiAnSGV4YWRlY2ltYWwnLFxuICogICBibXA6ICcwLTlBLUZhLWYnXG4gKiB9XSk7XG4gKiBYUmVnRXhwKCdcXFxccHtYRGlnaXR9OlxcXFxwe0hleGFkZWNpbWFsfSsnKS50ZXN0KCcwOjNEJyk7IC8vIC0+IHRydWVcbiAqL1xuICAgIFhSZWdFeHAuYWRkVW5pY29kZURhdGEgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHZhciBFUlJfTk9fTkFNRSA9ICdVbmljb2RlIHRva2VuIHJlcXVpcmVzIG5hbWUnLFxuICAgICAgICAgICAgRVJSX05PX0RBVEEgPSAnVW5pY29kZSB0b2tlbiBoYXMgbm8gY2hhcmFjdGVyIGRhdGEgJyxcbiAgICAgICAgICAgIGl0ZW0sXG4gICAgICAgICAgICBpO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpdGVtID0gZGF0YVtpXTtcbiAgICAgICAgICAgIGlmICghaXRlbS5uYW1lKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKEVSUl9OT19OQU1FKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghKGl0ZW0uaW52ZXJzZU9mIHx8IGl0ZW0uYm1wIHx8IGl0ZW0uYXN0cmFsKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihFUlJfTk9fREFUQSArIGl0ZW0ubmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1bmljb2RlW25vcm1hbGl6ZShpdGVtLm5hbWUpXSA9IGl0ZW07XG4gICAgICAgICAgICBpZiAoaXRlbS5hbGlhcykge1xuICAgICAgICAgICAgICAgIHVuaWNvZGVbbm9ybWFsaXplKGl0ZW0uYWxpYXMpXSA9IGl0ZW07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXNldCB0aGUgcGF0dGVybiBjYWNoZSB1c2VkIGJ5IHRoZSBgWFJlZ0V4cGAgY29uc3RydWN0b3IsIHNpbmNlIHRoZSBzYW1lIHBhdHRlcm4gYW5kXG4gICAgICAgIC8vIGZsYWdzIG1pZ2h0IG5vdyBwcm9kdWNlIGRpZmZlcmVudCByZXN1bHRzXG4gICAgICAgIFhSZWdFeHAuY2FjaGUuZmx1c2goJ3BhdHRlcm5zJyk7XG4gICAgfTtcblxufShYUmVnRXhwKSk7XG5cbi8qIVxuICogWFJlZ0V4cCBVbmljb2RlIEJsb2NrcyAzLjAuMFxuICogPGh0dHA6Ly94cmVnZXhwLmNvbS8+XG4gKiBTdGV2ZW4gTGV2aXRoYW4gKGMpIDIwMTAtMjAxNSBNSVQgTGljZW5zZVxuICogVW5pY29kZSBkYXRhIHByb3ZpZGVkIGJ5IE1hdGhpYXMgQnluZW5zIDxodHRwOi8vbWF0aGlhc2J5bmVucy5iZS8+XG4gKi9cblxuLyoqXG4gKiBBZGRzIHN1cHBvcnQgZm9yIGFsbCBVbmljb2RlIGJsb2Nrcy4gQmxvY2sgbmFtZXMgdXNlIHRoZSBwcmVmaXggJ0luJy4gRS5nLiwgYFxccHtJbkJhc2ljTGF0aW59YC5cbiAqIFRva2VuIG5hbWVzIGFyZSBjYXNlIGluc2Vuc2l0aXZlLCBhbmQgYW55IHNwYWNlcywgaHlwaGVucywgYW5kIHVuZGVyc2NvcmVzIGFyZSBpZ25vcmVkLlxuICpcbiAqIFVzZXMgVW5pY29kZSA4LjAuMC5cbiAqXG4gKiBAcmVxdWlyZXMgWFJlZ0V4cCwgVW5pY29kZSBCYXNlXG4gKi9cbihmdW5jdGlvbihYUmVnRXhwKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgaWYgKCFYUmVnRXhwLmFkZFVuaWNvZGVEYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcignVW5pY29kZSBCYXNlIG11c3QgYmUgbG9hZGVkIGJlZm9yZSBVbmljb2RlIEJsb2NrcycpO1xuICAgIH1cblxuICAgIFhSZWdFeHAuYWRkVW5pY29kZURhdGEoW1xuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5BZWdlYW5fTnVtYmVycycsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAwW1xcdUREMDAtXFx1REQzRl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkFob20nLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwNVtcXHVERjAwLVxcdURGM0ZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5BbGNoZW1pY2FsX1N5bWJvbHMnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgzRFtcXHVERjAwLVxcdURGN0ZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5BbHBoYWJldGljX1ByZXNlbnRhdGlvbl9Gb3JtcycsXG4gICAgICAgICAgICBibXA6ICdcXHVGQjAwLVxcdUZCNEYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkFuYXRvbGlhbl9IaWVyb2dseXBocycsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODExW1xcdURDMDAtXFx1REU3Rl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkFuY2llbnRfR3JlZWtfTXVzaWNhbF9Ob3RhdGlvbicsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODM0W1xcdURFMDAtXFx1REU0Rl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkFuY2llbnRfR3JlZWtfTnVtYmVycycsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAwW1xcdURENDAtXFx1REQ4Rl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkFuY2llbnRfU3ltYm9scycsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAwW1xcdUREOTAtXFx1RERDRl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkFyYWJpYycsXG4gICAgICAgICAgICBibXA6ICdcXHUwNjAwLVxcdTA2RkYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkFyYWJpY19FeHRlbmRlZF9BJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTA4QTAtXFx1MDhGRidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luQXJhYmljX01hdGhlbWF0aWNhbF9BbHBoYWJldGljX1N5bWJvbHMnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgzQltcXHVERTAwLVxcdURFRkZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5BcmFiaWNfUHJlc2VudGF0aW9uX0Zvcm1zX0EnLFxuICAgICAgICAgICAgYm1wOiAnXFx1RkI1MC1cXHVGREZGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5BcmFiaWNfUHJlc2VudGF0aW9uX0Zvcm1zX0InLFxuICAgICAgICAgICAgYm1wOiAnXFx1RkU3MC1cXHVGRUZGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5BcmFiaWNfU3VwcGxlbWVudCcsXG4gICAgICAgICAgICBibXA6ICdcXHUwNzUwLVxcdTA3N0YnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkFybWVuaWFuJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTA1MzAtXFx1MDU4RidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luQXJyb3dzJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTIxOTAtXFx1MjFGRidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luQXZlc3RhbicsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAyW1xcdURGMDAtXFx1REYzRl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkJhbGluZXNlJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTFCMDAtXFx1MUI3RidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luQmFtdW0nLFxuICAgICAgICAgICAgYm1wOiAnXFx1QTZBMC1cXHVBNkZGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5CYW11bV9TdXBwbGVtZW50JyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MUFbXFx1REMwMC1cXHVERTNGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luQmFzaWNfTGF0aW4nLFxuICAgICAgICAgICAgYm1wOiAnXFwwLVxceDdGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5CYXNzYV9WYWgnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgxQVtcXHVERUQwLVxcdURFRkZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5CYXRhaycsXG4gICAgICAgICAgICBibXA6ICdcXHUxQkMwLVxcdTFCRkYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkJlbmdhbGknLFxuICAgICAgICAgICAgYm1wOiAnXFx1MDk4MC1cXHUwOUZGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5CbG9ja19FbGVtZW50cycsXG4gICAgICAgICAgICBibXA6ICdcXHUyNTgwLVxcdTI1OUYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkJvcG9tb2ZvJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTMxMDAtXFx1MzEyRidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luQm9wb21vZm9fRXh0ZW5kZWQnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MzFBMC1cXHUzMUJGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5Cb3hfRHJhd2luZycsXG4gICAgICAgICAgICBibXA6ICdcXHUyNTAwLVxcdTI1N0YnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkJyYWhtaScsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODA0W1xcdURDMDAtXFx1REM3Rl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkJyYWlsbGVfUGF0dGVybnMnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MjgwMC1cXHUyOEZGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5CdWdpbmVzZScsXG4gICAgICAgICAgICBibXA6ICdcXHUxQTAwLVxcdTFBMUYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkJ1aGlkJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTE3NDAtXFx1MTc1RidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luQnl6YW50aW5lX011c2ljYWxfU3ltYm9scycsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODM0W1xcdURDMDAtXFx1RENGRl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkNKS19Db21wYXRpYmlsaXR5JyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTMzMDAtXFx1MzNGRidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luQ0pLX0NvbXBhdGliaWxpdHlfRm9ybXMnLFxuICAgICAgICAgICAgYm1wOiAnXFx1RkUzMC1cXHVGRTRGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5DSktfQ29tcGF0aWJpbGl0eV9JZGVvZ3JhcGhzJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdUY5MDAtXFx1RkFGRidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luQ0pLX0NvbXBhdGliaWxpdHlfSWRlb2dyYXBoc19TdXBwbGVtZW50JyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4N0VbXFx1REMwMC1cXHVERTFGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luQ0pLX1JhZGljYWxzX1N1cHBsZW1lbnQnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MkU4MC1cXHUyRUZGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5DSktfU3Ryb2tlcycsXG4gICAgICAgICAgICBibXA6ICdcXHUzMUMwLVxcdTMxRUYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkNKS19TeW1ib2xzX2FuZF9QdW5jdHVhdGlvbicsXG4gICAgICAgICAgICBibXA6ICdcXHUzMDAwLVxcdTMwM0YnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkNKS19VbmlmaWVkX0lkZW9ncmFwaHMnLFxuICAgICAgICAgICAgYm1wOiAnXFx1NEUwMC1cXHU5RkZGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5DSktfVW5pZmllZF9JZGVvZ3JhcGhzX0V4dGVuc2lvbl9BJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTM0MDAtXFx1NERCRidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luQ0pLX1VuaWZpZWRfSWRlb2dyYXBoc19FeHRlbnNpb25fQicsXG4gICAgICAgICAgICBhc3RyYWw6ICdbXFx1RDg0MC1cXHVEODY4XVtcXHVEQzAwLVxcdURGRkZdfFxcdUQ4NjlbXFx1REMwMC1cXHVERURGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luQ0pLX1VuaWZpZWRfSWRlb2dyYXBoc19FeHRlbnNpb25fQycsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODZEW1xcdURDMDAtXFx1REYzRl18W1xcdUQ4NkEtXFx1RDg2Q11bXFx1REMwMC1cXHVERkZGXXxcXHVEODY5W1xcdURGMDAtXFx1REZGRl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkNKS19VbmlmaWVkX0lkZW9ncmFwaHNfRXh0ZW5zaW9uX0QnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDg2RFtcXHVERjQwLVxcdURGRkZdfFxcdUQ4NkVbXFx1REMwMC1cXHVEQzFGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luQ0pLX1VuaWZpZWRfSWRlb2dyYXBoc19FeHRlbnNpb25fRScsXG4gICAgICAgICAgICBhc3RyYWw6ICdbXFx1RDg2Ri1cXHVEODcyXVtcXHVEQzAwLVxcdURGRkZdfFxcdUQ4NzNbXFx1REMwMC1cXHVERUFGXXxcXHVEODZFW1xcdURDMjAtXFx1REZGRl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkNhcmlhbicsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAwW1xcdURFQTAtXFx1REVERl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkNhdWNhc2lhbl9BbGJhbmlhbicsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAxW1xcdUREMzAtXFx1REQ2Rl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkNoYWttYScsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODA0W1xcdUREMDAtXFx1REQ0Rl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkNoYW0nLFxuICAgICAgICAgICAgYm1wOiAnXFx1QUEwMC1cXHVBQTVGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5DaGVyb2tlZScsXG4gICAgICAgICAgICBibXA6ICdcXHUxM0EwLVxcdTEzRkYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkNoZXJva2VlX1N1cHBsZW1lbnQnLFxuICAgICAgICAgICAgYm1wOiAnXFx1QUI3MC1cXHVBQkJGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5Db21iaW5pbmdfRGlhY3JpdGljYWxfTWFya3MnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MDMwMC1cXHUwMzZGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5Db21iaW5pbmdfRGlhY3JpdGljYWxfTWFya3NfRXh0ZW5kZWQnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MUFCMC1cXHUxQUZGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5Db21iaW5pbmdfRGlhY3JpdGljYWxfTWFya3NfU3VwcGxlbWVudCcsXG4gICAgICAgICAgICBibXA6ICdcXHUxREMwLVxcdTFERkYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkNvbWJpbmluZ19EaWFjcml0aWNhbF9NYXJrc19mb3JfU3ltYm9scycsXG4gICAgICAgICAgICBibXA6ICdcXHUyMEQwLVxcdTIwRkYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkNvbWJpbmluZ19IYWxmX01hcmtzJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdUZFMjAtXFx1RkUyRidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luQ29tbW9uX0luZGljX051bWJlcl9Gb3JtcycsXG4gICAgICAgICAgICBibXA6ICdcXHVBODMwLVxcdUE4M0YnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkNvbnRyb2xfUGljdHVyZXMnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MjQwMC1cXHUyNDNGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5Db3B0aWMnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MkM4MC1cXHUyQ0ZGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5Db3B0aWNfRXBhY3RfTnVtYmVycycsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAwW1xcdURFRTAtXFx1REVGRl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkNvdW50aW5nX1JvZF9OdW1lcmFscycsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODM0W1xcdURGNjAtXFx1REY3Rl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkN1bmVpZm9ybScsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODA4W1xcdURDMDAtXFx1REZGRl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkN1bmVpZm9ybV9OdW1iZXJzX2FuZF9QdW5jdHVhdGlvbicsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODA5W1xcdURDMDAtXFx1REM3Rl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkN1cnJlbmN5X1N5bWJvbHMnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MjBBMC1cXHUyMENGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5DeXByaW90X1N5bGxhYmFyeScsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAyW1xcdURDMDAtXFx1REMzRl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkN5cmlsbGljJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTA0MDAtXFx1MDRGRidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luQ3lyaWxsaWNfRXh0ZW5kZWRfQScsXG4gICAgICAgICAgICBibXA6ICdcXHUyREUwLVxcdTJERkYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkN5cmlsbGljX0V4dGVuZGVkX0InLFxuICAgICAgICAgICAgYm1wOiAnXFx1QTY0MC1cXHVBNjlGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5DeXJpbGxpY19TdXBwbGVtZW50JyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTA1MDAtXFx1MDUyRidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luRGVzZXJldCcsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAxW1xcdURDMDAtXFx1REM0Rl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkRldmFuYWdhcmknLFxuICAgICAgICAgICAgYm1wOiAnXFx1MDkwMC1cXHUwOTdGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5EZXZhbmFnYXJpX0V4dGVuZGVkJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdUE4RTAtXFx1QThGRidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luRGluZ2JhdHMnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MjcwMC1cXHUyN0JGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5Eb21pbm9fVGlsZXMnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgzQ1tcXHVEQzMwLVxcdURDOUZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5EdXBsb3lhbicsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODJGW1xcdURDMDAtXFx1REM5Rl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkVhcmx5X0R5bmFzdGljX0N1bmVpZm9ybScsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODA5W1xcdURDODAtXFx1REQ0Rl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkVneXB0aWFuX0hpZXJvZ2x5cGhzJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MENbXFx1REMwMC1cXHVERkZGXXxcXHVEODBEW1xcdURDMDAtXFx1REMyRl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkVsYmFzYW4nLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMVtcXHVERDAwLVxcdUREMkZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5FbW90aWNvbnMnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgzRFtcXHVERTAwLVxcdURFNEZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5FbmNsb3NlZF9BbHBoYW51bWVyaWNfU3VwcGxlbWVudCcsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODNDW1xcdUREMDAtXFx1RERGRl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkVuY2xvc2VkX0FscGhhbnVtZXJpY3MnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MjQ2MC1cXHUyNEZGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5FbmNsb3NlZF9DSktfTGV0dGVyc19hbmRfTW9udGhzJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTMyMDAtXFx1MzJGRidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luRW5jbG9zZWRfSWRlb2dyYXBoaWNfU3VwcGxlbWVudCcsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODNDW1xcdURFMDAtXFx1REVGRl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkV0aGlvcGljJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTEyMDAtXFx1MTM3RidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luRXRoaW9waWNfRXh0ZW5kZWQnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MkQ4MC1cXHUyRERGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5FdGhpb3BpY19FeHRlbmRlZF9BJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdUFCMDAtXFx1QUIyRidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luRXRoaW9waWNfU3VwcGxlbWVudCcsXG4gICAgICAgICAgICBibXA6ICdcXHUxMzgwLVxcdTEzOUYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkdlbmVyYWxfUHVuY3R1YXRpb24nLFxuICAgICAgICAgICAgYm1wOiAnXFx1MjAwMC1cXHUyMDZGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5HZW9tZXRyaWNfU2hhcGVzJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTI1QTAtXFx1MjVGRidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luR2VvbWV0cmljX1NoYXBlc19FeHRlbmRlZCcsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODNEW1xcdURGODAtXFx1REZGRl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkdlb3JnaWFuJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTEwQTAtXFx1MTBGRidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luR2VvcmdpYW5fU3VwcGxlbWVudCcsXG4gICAgICAgICAgICBibXA6ICdcXHUyRDAwLVxcdTJEMkYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkdsYWdvbGl0aWMnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MkMwMC1cXHUyQzVGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5Hb3RoaWMnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMFtcXHVERjMwLVxcdURGNEZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5HcmFudGhhJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDRbXFx1REYwMC1cXHVERjdGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luR3JlZWtfRXh0ZW5kZWQnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MUYwMC1cXHUxRkZGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5HcmVla19hbmRfQ29wdGljJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTAzNzAtXFx1MDNGRidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luR3VqYXJhdGknLFxuICAgICAgICAgICAgYm1wOiAnXFx1MEE4MC1cXHUwQUZGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5HdXJtdWtoaScsXG4gICAgICAgICAgICBibXA6ICdcXHUwQTAwLVxcdTBBN0YnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkhhbGZ3aWR0aF9hbmRfRnVsbHdpZHRoX0Zvcm1zJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdUZGMDAtXFx1RkZFRidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luSGFuZ3VsX0NvbXBhdGliaWxpdHlfSmFtbycsXG4gICAgICAgICAgICBibXA6ICdcXHUzMTMwLVxcdTMxOEYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkhhbmd1bF9KYW1vJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTExMDAtXFx1MTFGRidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luSGFuZ3VsX0phbW9fRXh0ZW5kZWRfQScsXG4gICAgICAgICAgICBibXA6ICdcXHVBOTYwLVxcdUE5N0YnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkhhbmd1bF9KYW1vX0V4dGVuZGVkX0InLFxuICAgICAgICAgICAgYm1wOiAnXFx1RDdCMC1cXHVEN0ZGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5IYW5ndWxfU3lsbGFibGVzJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdUFDMDAtXFx1RDdBRidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luSGFudW5vbycsXG4gICAgICAgICAgICBibXA6ICdcXHUxNzIwLVxcdTE3M0YnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkhhdHJhbicsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAyW1xcdURDRTAtXFx1RENGRl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkhlYnJldycsXG4gICAgICAgICAgICBibXA6ICdcXHUwNTkwLVxcdTA1RkYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkhpZ2hfUHJpdmF0ZV9Vc2VfU3Vycm9nYXRlcycsXG4gICAgICAgICAgICBibXA6ICdcXHVEQjgwLVxcdURCRkYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkhpZ2hfU3Vycm9nYXRlcycsXG4gICAgICAgICAgICBibXA6ICdcXHVEODAwLVxcdURCN0YnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkhpcmFnYW5hJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTMwNDAtXFx1MzA5RidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luSVBBX0V4dGVuc2lvbnMnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MDI1MC1cXHUwMkFGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5JZGVvZ3JhcGhpY19EZXNjcmlwdGlvbl9DaGFyYWN0ZXJzJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTJGRjAtXFx1MkZGRidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luSW1wZXJpYWxfQXJhbWFpYycsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAyW1xcdURDNDAtXFx1REM1Rl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkluc2NyaXB0aW9uYWxfUGFobGF2aScsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAyW1xcdURGNjAtXFx1REY3Rl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkluc2NyaXB0aW9uYWxfUGFydGhpYW4nLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMltcXHVERjQwLVxcdURGNUZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5KYXZhbmVzZScsXG4gICAgICAgICAgICBibXA6ICdcXHVBOTgwLVxcdUE5REYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkthaXRoaScsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODA0W1xcdURDODAtXFx1RENDRl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkthbmFfU3VwcGxlbWVudCcsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODJDW1xcdURDMDAtXFx1RENGRl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkthbmJ1bicsXG4gICAgICAgICAgICBibXA6ICdcXHUzMTkwLVxcdTMxOUYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkthbmd4aV9SYWRpY2FscycsXG4gICAgICAgICAgICBibXA6ICdcXHUyRjAwLVxcdTJGREYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkthbm5hZGEnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MEM4MC1cXHUwQ0ZGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5LYXRha2FuYScsXG4gICAgICAgICAgICBibXA6ICdcXHUzMEEwLVxcdTMwRkYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkthdGFrYW5hX1Bob25ldGljX0V4dGVuc2lvbnMnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MzFGMC1cXHUzMUZGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5LYXlhaF9MaScsXG4gICAgICAgICAgICBibXA6ICdcXHVBOTAwLVxcdUE5MkYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbktoYXJvc2h0aGknLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMltcXHVERTAwLVxcdURFNUZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5LaG1lcicsXG4gICAgICAgICAgICBibXA6ICdcXHUxNzgwLVxcdTE3RkYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbktobWVyX1N5bWJvbHMnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MTlFMC1cXHUxOUZGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5LaG9qa2knLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwNFtcXHVERTAwLVxcdURFNEZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5LaHVkYXdhZGknLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwNFtcXHVERUIwLVxcdURFRkZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5MYW8nLFxuICAgICAgICAgICAgYm1wOiAnXFx1MEU4MC1cXHUwRUZGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5MYXRpbl9FeHRlbmRlZF9BZGRpdGlvbmFsJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTFFMDAtXFx1MUVGRidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luTGF0aW5fRXh0ZW5kZWRfQScsXG4gICAgICAgICAgICBibXA6ICdcXHUwMTAwLVxcdTAxN0YnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkxhdGluX0V4dGVuZGVkX0InLFxuICAgICAgICAgICAgYm1wOiAnXFx1MDE4MC1cXHUwMjRGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5MYXRpbl9FeHRlbmRlZF9DJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTJDNjAtXFx1MkM3RidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luTGF0aW5fRXh0ZW5kZWRfRCcsXG4gICAgICAgICAgICBibXA6ICdcXHVBNzIwLVxcdUE3RkYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkxhdGluX0V4dGVuZGVkX0UnLFxuICAgICAgICAgICAgYm1wOiAnXFx1QUIzMC1cXHVBQjZGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5MYXRpbl8xX1N1cHBsZW1lbnQnLFxuICAgICAgICAgICAgYm1wOiAnXFx4ODAtXFx4RkYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkxlcGNoYScsXG4gICAgICAgICAgICBibXA6ICdcXHUxQzAwLVxcdTFDNEYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkxldHRlcmxpa2VfU3ltYm9scycsXG4gICAgICAgICAgICBibXA6ICdcXHUyMTAwLVxcdTIxNEYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbkxpbWJ1JyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTE5MDAtXFx1MTk0RidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luTGluZWFyX0EnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMVtcXHVERTAwLVxcdURGN0ZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5MaW5lYXJfQl9JZGVvZ3JhbXMnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMFtcXHVEQzgwLVxcdURDRkZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5MaW5lYXJfQl9TeWxsYWJhcnknLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMFtcXHVEQzAwLVxcdURDN0ZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5MaXN1JyxcbiAgICAgICAgICAgIGJtcDogJ1xcdUE0RDAtXFx1QTRGRidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luTG93X1N1cnJvZ2F0ZXMnLFxuICAgICAgICAgICAgYm1wOiAnXFx1REMwMC1cXHVERkZGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5MeWNpYW4nLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMFtcXHVERTgwLVxcdURFOUZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5MeWRpYW4nLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMltcXHVERDIwLVxcdUREM0ZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5NYWhhamFuaScsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODA0W1xcdURENTAtXFx1REQ3Rl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbk1haGpvbmdfVGlsZXMnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgzQ1tcXHVEQzAwLVxcdURDMkZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5NYWxheWFsYW0nLFxuICAgICAgICAgICAgYm1wOiAnXFx1MEQwMC1cXHUwRDdGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5NYW5kYWljJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTA4NDAtXFx1MDg1RidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luTWFuaWNoYWVhbicsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAyW1xcdURFQzAtXFx1REVGRl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbk1hdGhlbWF0aWNhbF9BbHBoYW51bWVyaWNfU3ltYm9scycsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODM1W1xcdURDMDAtXFx1REZGRl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbk1hdGhlbWF0aWNhbF9PcGVyYXRvcnMnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MjIwMC1cXHUyMkZGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5NZWV0ZWlfTWF5ZWsnLFxuICAgICAgICAgICAgYm1wOiAnXFx1QUJDMC1cXHVBQkZGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5NZWV0ZWlfTWF5ZWtfRXh0ZW5zaW9ucycsXG4gICAgICAgICAgICBibXA6ICdcXHVBQUUwLVxcdUFBRkYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbk1lbmRlX0tpa2FrdWknLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgzQVtcXHVEQzAwLVxcdURDREZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5NZXJvaXRpY19DdXJzaXZlJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDJbXFx1RERBMC1cXHVEREZGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luTWVyb2l0aWNfSGllcm9nbHlwaHMnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMltcXHVERDgwLVxcdUREOUZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5NaWFvJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MUJbXFx1REYwMC1cXHVERjlGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luTWlzY2VsbGFuZW91c19NYXRoZW1hdGljYWxfU3ltYm9sc19BJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTI3QzAtXFx1MjdFRidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luTWlzY2VsbGFuZW91c19NYXRoZW1hdGljYWxfU3ltYm9sc19CJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTI5ODAtXFx1MjlGRidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luTWlzY2VsbGFuZW91c19TeW1ib2xzJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTI2MDAtXFx1MjZGRidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luTWlzY2VsbGFuZW91c19TeW1ib2xzX2FuZF9BcnJvd3MnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MkIwMC1cXHUyQkZGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5NaXNjZWxsYW5lb3VzX1N5bWJvbHNfYW5kX1BpY3RvZ3JhcGhzJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4M0RbXFx1REMwMC1cXHVEREZGXXxcXHVEODNDW1xcdURGMDAtXFx1REZGRl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbk1pc2NlbGxhbmVvdXNfVGVjaG5pY2FsJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTIzMDAtXFx1MjNGRidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luTW9kaScsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODA1W1xcdURFMDAtXFx1REU1Rl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbk1vZGlmaWVyX1RvbmVfTGV0dGVycycsXG4gICAgICAgICAgICBibXA6ICdcXHVBNzAwLVxcdUE3MUYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbk1vbmdvbGlhbicsXG4gICAgICAgICAgICBibXA6ICdcXHUxODAwLVxcdTE4QUYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbk1ybycsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODFBW1xcdURFNDAtXFx1REU2Rl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbk11bHRhbmknLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwNFtcXHVERTgwLVxcdURFQUZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5NdXNpY2FsX1N5bWJvbHMnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgzNFtcXHVERDAwLVxcdURERkZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5NeWFubWFyJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTEwMDAtXFx1MTA5RidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luTXlhbm1hcl9FeHRlbmRlZF9BJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdUFBNjAtXFx1QUE3RidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luTXlhbm1hcl9FeHRlbmRlZF9CJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdUE5RTAtXFx1QTlGRidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luTktvJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTA3QzAtXFx1MDdGRidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luTmFiYXRhZWFuJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDJbXFx1REM4MC1cXHVEQ0FGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luTmV3X1RhaV9MdWUnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MTk4MC1cXHUxOURGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5OdW1iZXJfRm9ybXMnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MjE1MC1cXHUyMThGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5PZ2hhbScsXG4gICAgICAgICAgICBibXA6ICdcXHUxNjgwLVxcdTE2OUYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbk9sX0NoaWtpJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTFDNTAtXFx1MUM3RidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luT2xkX0h1bmdhcmlhbicsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAzW1xcdURDODAtXFx1RENGRl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbk9sZF9JdGFsaWMnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMFtcXHVERjAwLVxcdURGMkZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5PbGRfTm9ydGhfQXJhYmlhbicsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAyW1xcdURFODAtXFx1REU5Rl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbk9sZF9QZXJtaWMnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMFtcXHVERjUwLVxcdURGN0ZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5PbGRfUGVyc2lhbicsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAwW1xcdURGQTAtXFx1REZERl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbk9sZF9Tb3V0aF9BcmFiaWFuJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDJbXFx1REU2MC1cXHVERTdGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luT2xkX1R1cmtpYycsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAzW1xcdURDMDAtXFx1REM0Rl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbk9wdGljYWxfQ2hhcmFjdGVyX1JlY29nbml0aW9uJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTI0NDAtXFx1MjQ1RidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luT3JpeWEnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MEIwMC1cXHUwQjdGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5Pcm5hbWVudGFsX0RpbmdiYXRzJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4M0RbXFx1REU1MC1cXHVERTdGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luT3NtYW55YScsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAxW1xcdURDODAtXFx1RENBRl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJblBhaGF3aF9IbW9uZycsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODFBW1xcdURGMDAtXFx1REY4Rl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJblBhbG15cmVuZScsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAyW1xcdURDNjAtXFx1REM3Rl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJblBhdV9DaW5fSGF1JyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDZbXFx1REVDMC1cXHVERUZGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luUGhhZ3NfcGEnLFxuICAgICAgICAgICAgYm1wOiAnXFx1QTg0MC1cXHVBODdGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5QaGFpc3Rvc19EaXNjJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDBbXFx1REREMC1cXHVEREZGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luUGhvZW5pY2lhbicsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAyW1xcdUREMDAtXFx1REQxRl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJblBob25ldGljX0V4dGVuc2lvbnMnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MUQwMC1cXHUxRDdGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5QaG9uZXRpY19FeHRlbnNpb25zX1N1cHBsZW1lbnQnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MUQ4MC1cXHUxREJGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5QbGF5aW5nX0NhcmRzJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4M0NbXFx1RENBMC1cXHVEQ0ZGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luUHJpdmF0ZV9Vc2VfQXJlYScsXG4gICAgICAgICAgICBibXA6ICdcXHVFMDAwLVxcdUY4RkYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJblBzYWx0ZXJfUGFobGF2aScsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAyW1xcdURGODAtXFx1REZBRl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJblJlamFuZycsXG4gICAgICAgICAgICBibXA6ICdcXHVBOTMwLVxcdUE5NUYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJblJ1bWlfTnVtZXJhbF9TeW1ib2xzJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDNbXFx1REU2MC1cXHVERTdGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luUnVuaWMnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MTZBMC1cXHUxNkZGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5TYW1hcml0YW4nLFxuICAgICAgICAgICAgYm1wOiAnXFx1MDgwMC1cXHUwODNGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5TYXVyYXNodHJhJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdUE4ODAtXFx1QThERidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luU2hhcmFkYScsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODA0W1xcdUREODAtXFx1RERERl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJblNoYXZpYW4nLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMVtcXHVEQzUwLVxcdURDN0ZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5TaG9ydGhhbmRfRm9ybWF0X0NvbnRyb2xzJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MkZbXFx1RENBMC1cXHVEQ0FGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luU2lkZGhhbScsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODA1W1xcdUREODAtXFx1RERGRl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJblNpbmhhbGEnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MEQ4MC1cXHUwREZGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5TaW5oYWxhX0FyY2hhaWNfTnVtYmVycycsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODA0W1xcdURERTAtXFx1RERGRl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJblNtYWxsX0Zvcm1fVmFyaWFudHMnLFxuICAgICAgICAgICAgYm1wOiAnXFx1RkU1MC1cXHVGRTZGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5Tb3JhX1NvbXBlbmcnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwNFtcXHVEQ0QwLVxcdURDRkZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5TcGFjaW5nX01vZGlmaWVyX0xldHRlcnMnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MDJCMC1cXHUwMkZGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5TcGVjaWFscycsXG4gICAgICAgICAgICBibXA6ICdcXHVGRkYwLVxcdUZGRkYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJblN1bmRhbmVzZScsXG4gICAgICAgICAgICBibXA6ICdcXHUxQjgwLVxcdTFCQkYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJblN1bmRhbmVzZV9TdXBwbGVtZW50JyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTFDQzAtXFx1MUNDRidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luU3VwZXJzY3JpcHRzX2FuZF9TdWJzY3JpcHRzJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTIwNzAtXFx1MjA5RidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luU3VwcGxlbWVudGFsX0Fycm93c19BJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTI3RjAtXFx1MjdGRidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luU3VwcGxlbWVudGFsX0Fycm93c19CJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTI5MDAtXFx1Mjk3RidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luU3VwcGxlbWVudGFsX0Fycm93c19DJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4M0VbXFx1REMwMC1cXHVEQ0ZGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luU3VwcGxlbWVudGFsX01hdGhlbWF0aWNhbF9PcGVyYXRvcnMnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MkEwMC1cXHUyQUZGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5TdXBwbGVtZW50YWxfUHVuY3R1YXRpb24nLFxuICAgICAgICAgICAgYm1wOiAnXFx1MkUwMC1cXHUyRTdGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5TdXBwbGVtZW50YWxfU3ltYm9sc19hbmRfUGljdG9ncmFwaHMnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgzRVtcXHVERDAwLVxcdURERkZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5TdXBwbGVtZW50YXJ5X1ByaXZhdGVfVXNlX0FyZWFfQScsXG4gICAgICAgICAgICBhc3RyYWw6ICdbXFx1REI4MC1cXHVEQkJGXVtcXHVEQzAwLVxcdURGRkZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5TdXBwbGVtZW50YXJ5X1ByaXZhdGVfVXNlX0FyZWFfQicsXG4gICAgICAgICAgICBhc3RyYWw6ICdbXFx1REJDMC1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5TdXR0b25fU2lnbldyaXRpbmcnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgzNltcXHVEQzAwLVxcdURFQUZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5TeWxvdGlfTmFncmknLFxuICAgICAgICAgICAgYm1wOiAnXFx1QTgwMC1cXHVBODJGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5TeXJpYWMnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MDcwMC1cXHUwNzRGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5UYWdhbG9nJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTE3MDAtXFx1MTcxRidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luVGFnYmFud2EnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MTc2MC1cXHUxNzdGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5UYWdzJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdURCNDBbXFx1REMwMC1cXHVEQzdGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luVGFpX0xlJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTE5NTAtXFx1MTk3RidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luVGFpX1RoYW0nLFxuICAgICAgICAgICAgYm1wOiAnXFx1MUEyMC1cXHUxQUFGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5UYWlfVmlldCcsXG4gICAgICAgICAgICBibXA6ICdcXHVBQTgwLVxcdUFBREYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJblRhaV9YdWFuX0ppbmdfU3ltYm9scycsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODM0W1xcdURGMDAtXFx1REY1Rl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJblRha3JpJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDVbXFx1REU4MC1cXHVERUNGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luVGFtaWwnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MEI4MC1cXHUwQkZGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5UZWx1Z3UnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MEMwMC1cXHUwQzdGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5UaGFhbmEnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MDc4MC1cXHUwN0JGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5UaGFpJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTBFMDAtXFx1MEU3RidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luVGliZXRhbicsXG4gICAgICAgICAgICBibXA6ICdcXHUwRjAwLVxcdTBGRkYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJblRpZmluYWdoJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTJEMzAtXFx1MkQ3RidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luVGlyaHV0YScsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODA1W1xcdURDODAtXFx1RENERl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJblRyYW5zcG9ydF9hbmRfTWFwX1N5bWJvbHMnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgzRFtcXHVERTgwLVxcdURFRkZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5VZ2FyaXRpYycsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAwW1xcdURGODAtXFx1REY5Rl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJblVuaWZpZWRfQ2FuYWRpYW5fQWJvcmlnaW5hbF9TeWxsYWJpY3MnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MTQwMC1cXHUxNjdGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5VbmlmaWVkX0NhbmFkaWFuX0Fib3JpZ2luYWxfU3lsbGFiaWNzX0V4dGVuZGVkJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTE4QjAtXFx1MThGRidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luVmFpJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdUE1MDAtXFx1QTYzRidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luVmFyaWF0aW9uX1NlbGVjdG9ycycsXG4gICAgICAgICAgICBibXA6ICdcXHVGRTAwLVxcdUZFMEYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJblZhcmlhdGlvbl9TZWxlY3RvcnNfU3VwcGxlbWVudCcsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEQjQwW1xcdUREMDAtXFx1RERFRl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJblZlZGljX0V4dGVuc2lvbnMnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MUNEMC1cXHUxQ0ZGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5WZXJ0aWNhbF9Gb3JtcycsXG4gICAgICAgICAgICBibXA6ICdcXHVGRTEwLVxcdUZFMUYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbldhcmFuZ19DaXRpJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDZbXFx1RENBMC1cXHVEQ0ZGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luWWlfUmFkaWNhbHMnLFxuICAgICAgICAgICAgYm1wOiAnXFx1QTQ5MC1cXHVBNENGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5ZaV9TeWxsYWJsZXMnLFxuICAgICAgICAgICAgYm1wOiAnXFx1QTAwMC1cXHVBNDhGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5ZaWppbmdfSGV4YWdyYW1fU3ltYm9scycsXG4gICAgICAgICAgICBibXA6ICdcXHU0REMwLVxcdTRERkYnXG4gICAgICAgIH1cbiAgICBdKTtcblxufShYUmVnRXhwKSk7XG5cbi8qIVxuICogWFJlZ0V4cCBVbmljb2RlIENhdGVnb3JpZXMgMy4wLjBcbiAqIDxodHRwOi8veHJlZ2V4cC5jb20vPlxuICogU3RldmVuIExldml0aGFuIChjKSAyMDEwLTIwMTUgTUlUIExpY2Vuc2VcbiAqIFVuaWNvZGUgZGF0YSBwcm92aWRlZCBieSBNYXRoaWFzIEJ5bmVucyA8aHR0cDovL21hdGhpYXNieW5lbnMuYmUvPlxuICovXG5cbi8qKlxuICogQWRkcyBzdXBwb3J0IGZvciBVbmljb2RlJ3MgZ2VuZXJhbCBjYXRlZ29yaWVzLiBFLmcuLCBgXFxwe0x1fWAgb3IgYFxccHtVcHBlcmNhc2UgTGV0dGVyfWAuIFNlZVxuICogY2F0ZWdvcnkgZGVzY3JpcHRpb25zIGluIFVBWCAjNDQgPGh0dHA6Ly91bmljb2RlLm9yZy9yZXBvcnRzL3RyNDQvI0dDX1ZhbHVlc19UYWJsZT4uIFRva2VuIG5hbWVzXG4gKiBhcmUgY2FzZSBpbnNlbnNpdGl2ZSwgYW5kIGFueSBzcGFjZXMsIGh5cGhlbnMsIGFuZCB1bmRlcnNjb3JlcyBhcmUgaWdub3JlZC5cbiAqXG4gKiBVc2VzIFVuaWNvZGUgOC4wLjAuXG4gKlxuICogQHJlcXVpcmVzIFhSZWdFeHAsIFVuaWNvZGUgQmFzZVxuICovXG4oZnVuY3Rpb24oWFJlZ0V4cCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGlmICghWFJlZ0V4cC5hZGRVbmljb2RlRGF0YSkge1xuICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoJ1VuaWNvZGUgQmFzZSBtdXN0IGJlIGxvYWRlZCBiZWZvcmUgVW5pY29kZSBDYXRlZ29yaWVzJyk7XG4gICAgfVxuXG4gICAgWFJlZ0V4cC5hZGRVbmljb2RlRGF0YShbXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdDJyxcbiAgICAgICAgICAgIGFsaWFzOiAnT3RoZXInLFxuICAgICAgICAgICAgaXNCbXBMYXN0OiB0cnVlLFxuICAgICAgICAgICAgYm1wOiAnXFwwLVxceDFGXFx4N0YtXFx4OUZcXHhBRFxcdTAzNzhcXHUwMzc5XFx1MDM4MC1cXHUwMzgzXFx1MDM4QlxcdTAzOERcXHUwM0EyXFx1MDUzMFxcdTA1NTdcXHUwNTU4XFx1MDU2MFxcdTA1ODhcXHUwNThCXFx1MDU4Q1xcdTA1OTBcXHUwNUM4LVxcdTA1Q0ZcXHUwNUVCLVxcdTA1RUZcXHUwNUY1LVxcdTA2MDVcXHUwNjFDXFx1MDYxRFxcdTA2RERcXHUwNzBFXFx1MDcwRlxcdTA3NEJcXHUwNzRDXFx1MDdCMi1cXHUwN0JGXFx1MDdGQi1cXHUwN0ZGXFx1MDgyRVxcdTA4MkZcXHUwODNGXFx1MDg1Q1xcdTA4NURcXHUwODVGLVxcdTA4OUZcXHUwOEI1LVxcdTA4RTJcXHUwOTg0XFx1MDk4RFxcdTA5OEVcXHUwOTkxXFx1MDk5MlxcdTA5QTlcXHUwOUIxXFx1MDlCMy1cXHUwOUI1XFx1MDlCQVxcdTA5QkJcXHUwOUM1XFx1MDlDNlxcdTA5QzlcXHUwOUNBXFx1MDlDRi1cXHUwOUQ2XFx1MDlEOC1cXHUwOURCXFx1MDlERVxcdTA5RTRcXHUwOUU1XFx1MDlGQy1cXHUwQTAwXFx1MEEwNFxcdTBBMEItXFx1MEEwRVxcdTBBMTFcXHUwQTEyXFx1MEEyOVxcdTBBMzFcXHUwQTM0XFx1MEEzN1xcdTBBM0FcXHUwQTNCXFx1MEEzRFxcdTBBNDMtXFx1MEE0NlxcdTBBNDlcXHUwQTRBXFx1MEE0RS1cXHUwQTUwXFx1MEE1Mi1cXHUwQTU4XFx1MEE1RFxcdTBBNUYtXFx1MEE2NVxcdTBBNzYtXFx1MEE4MFxcdTBBODRcXHUwQThFXFx1MEE5MlxcdTBBQTlcXHUwQUIxXFx1MEFCNFxcdTBBQkFcXHUwQUJCXFx1MEFDNlxcdTBBQ0FcXHUwQUNFXFx1MEFDRlxcdTBBRDEtXFx1MEFERlxcdTBBRTRcXHUwQUU1XFx1MEFGMi1cXHUwQUY4XFx1MEFGQS1cXHUwQjAwXFx1MEIwNFxcdTBCMERcXHUwQjBFXFx1MEIxMVxcdTBCMTJcXHUwQjI5XFx1MEIzMVxcdTBCMzRcXHUwQjNBXFx1MEIzQlxcdTBCNDVcXHUwQjQ2XFx1MEI0OVxcdTBCNEFcXHUwQjRFLVxcdTBCNTVcXHUwQjU4LVxcdTBCNUJcXHUwQjVFXFx1MEI2NFxcdTBCNjVcXHUwQjc4LVxcdTBCODFcXHUwQjg0XFx1MEI4Qi1cXHUwQjhEXFx1MEI5MVxcdTBCOTYtXFx1MEI5OFxcdTBCOUJcXHUwQjlEXFx1MEJBMC1cXHUwQkEyXFx1MEJBNS1cXHUwQkE3XFx1MEJBQi1cXHUwQkFEXFx1MEJCQS1cXHUwQkJEXFx1MEJDMy1cXHUwQkM1XFx1MEJDOVxcdTBCQ0VcXHUwQkNGXFx1MEJEMS1cXHUwQkQ2XFx1MEJEOC1cXHUwQkU1XFx1MEJGQi1cXHUwQkZGXFx1MEMwNFxcdTBDMERcXHUwQzExXFx1MEMyOVxcdTBDM0EtXFx1MEMzQ1xcdTBDNDVcXHUwQzQ5XFx1MEM0RS1cXHUwQzU0XFx1MEM1N1xcdTBDNUItXFx1MEM1RlxcdTBDNjRcXHUwQzY1XFx1MEM3MC1cXHUwQzc3XFx1MEM4MFxcdTBDODRcXHUwQzhEXFx1MEM5MVxcdTBDQTlcXHUwQ0I0XFx1MENCQVxcdTBDQkJcXHUwQ0M1XFx1MENDOVxcdTBDQ0UtXFx1MENENFxcdTBDRDctXFx1MENERFxcdTBDREZcXHUwQ0U0XFx1MENFNVxcdTBDRjBcXHUwQ0YzLVxcdTBEMDBcXHUwRDA0XFx1MEQwRFxcdTBEMTFcXHUwRDNCXFx1MEQzQ1xcdTBENDVcXHUwRDQ5XFx1MEQ0Ri1cXHUwRDU2XFx1MEQ1OC1cXHUwRDVFXFx1MEQ2NFxcdTBENjVcXHUwRDc2LVxcdTBENzhcXHUwRDgwXFx1MEQ4MVxcdTBEODRcXHUwRDk3LVxcdTBEOTlcXHUwREIyXFx1MERCQ1xcdTBEQkVcXHUwREJGXFx1MERDNy1cXHUwREM5XFx1MERDQi1cXHUwRENFXFx1MERENVxcdTBERDdcXHUwREUwLVxcdTBERTVcXHUwREYwXFx1MERGMVxcdTBERjUtXFx1MEUwMFxcdTBFM0ItXFx1MEUzRVxcdTBFNUMtXFx1MEU4MFxcdTBFODNcXHUwRTg1XFx1MEU4NlxcdTBFODlcXHUwRThCXFx1MEU4Q1xcdTBFOEUtXFx1MEU5M1xcdTBFOThcXHUwRUEwXFx1MEVBNFxcdTBFQTZcXHUwRUE4XFx1MEVBOVxcdTBFQUNcXHUwRUJBXFx1MEVCRVxcdTBFQkZcXHUwRUM1XFx1MEVDN1xcdTBFQ0VcXHUwRUNGXFx1MEVEQVxcdTBFREJcXHUwRUUwLVxcdTBFRkZcXHUwRjQ4XFx1MEY2RC1cXHUwRjcwXFx1MEY5OFxcdTBGQkRcXHUwRkNEXFx1MEZEQi1cXHUwRkZGXFx1MTBDNlxcdTEwQzgtXFx1MTBDQ1xcdTEwQ0VcXHUxMENGXFx1MTI0OVxcdTEyNEVcXHUxMjRGXFx1MTI1N1xcdTEyNTlcXHUxMjVFXFx1MTI1RlxcdTEyODlcXHUxMjhFXFx1MTI4RlxcdTEyQjFcXHUxMkI2XFx1MTJCN1xcdTEyQkZcXHUxMkMxXFx1MTJDNlxcdTEyQzdcXHUxMkQ3XFx1MTMxMVxcdTEzMTZcXHUxMzE3XFx1MTM1QlxcdTEzNUNcXHUxMzdELVxcdTEzN0ZcXHUxMzlBLVxcdTEzOUZcXHUxM0Y2XFx1MTNGN1xcdTEzRkVcXHUxM0ZGXFx1MTY5RC1cXHUxNjlGXFx1MTZGOS1cXHUxNkZGXFx1MTcwRFxcdTE3MTUtXFx1MTcxRlxcdTE3MzctXFx1MTczRlxcdTE3NTQtXFx1MTc1RlxcdTE3NkRcXHUxNzcxXFx1MTc3NC1cXHUxNzdGXFx1MTdERVxcdTE3REZcXHUxN0VBLVxcdTE3RUZcXHUxN0ZBLVxcdTE3RkZcXHUxODBFXFx1MTgwRlxcdTE4MUEtXFx1MTgxRlxcdTE4NzgtXFx1MTg3RlxcdTE4QUItXFx1MThBRlxcdTE4RjYtXFx1MThGRlxcdTE5MUZcXHUxOTJDLVxcdTE5MkZcXHUxOTNDLVxcdTE5M0ZcXHUxOTQxLVxcdTE5NDNcXHUxOTZFXFx1MTk2RlxcdTE5NzUtXFx1MTk3RlxcdTE5QUMtXFx1MTlBRlxcdTE5Q0EtXFx1MTlDRlxcdTE5REItXFx1MTlERFxcdTFBMUNcXHUxQTFEXFx1MUE1RlxcdTFBN0RcXHUxQTdFXFx1MUE4QS1cXHUxQThGXFx1MUE5QS1cXHUxQTlGXFx1MUFBRVxcdTFBQUZcXHUxQUJGLVxcdTFBRkZcXHUxQjRDLVxcdTFCNEZcXHUxQjdELVxcdTFCN0ZcXHUxQkY0LVxcdTFCRkJcXHUxQzM4LVxcdTFDM0FcXHUxQzRBLVxcdTFDNENcXHUxQzgwLVxcdTFDQkZcXHUxQ0M4LVxcdTFDQ0ZcXHUxQ0Y3XFx1MUNGQS1cXHUxQ0ZGXFx1MURGNi1cXHUxREZCXFx1MUYxNlxcdTFGMTdcXHUxRjFFXFx1MUYxRlxcdTFGNDZcXHUxRjQ3XFx1MUY0RVxcdTFGNEZcXHUxRjU4XFx1MUY1QVxcdTFGNUNcXHUxRjVFXFx1MUY3RVxcdTFGN0ZcXHUxRkI1XFx1MUZDNVxcdTFGRDRcXHUxRkQ1XFx1MUZEQ1xcdTFGRjBcXHUxRkYxXFx1MUZGNVxcdTFGRkZcXHUyMDBCLVxcdTIwMEZcXHUyMDJBLVxcdTIwMkVcXHUyMDYwLVxcdTIwNkZcXHUyMDcyXFx1MjA3M1xcdTIwOEZcXHUyMDlELVxcdTIwOUZcXHUyMEJGLVxcdTIwQ0ZcXHUyMEYxLVxcdTIwRkZcXHUyMThDLVxcdTIxOEZcXHUyM0ZCLVxcdTIzRkZcXHUyNDI3LVxcdTI0M0ZcXHUyNDRCLVxcdTI0NUZcXHUyQjc0XFx1MkI3NVxcdTJCOTZcXHUyQjk3XFx1MkJCQS1cXHUyQkJDXFx1MkJDOVxcdTJCRDItXFx1MkJFQlxcdTJCRjAtXFx1MkJGRlxcdTJDMkZcXHUyQzVGXFx1MkNGNC1cXHUyQ0Y4XFx1MkQyNlxcdTJEMjgtXFx1MkQyQ1xcdTJEMkVcXHUyRDJGXFx1MkQ2OC1cXHUyRDZFXFx1MkQ3MS1cXHUyRDdFXFx1MkQ5Ny1cXHUyRDlGXFx1MkRBN1xcdTJEQUZcXHUyREI3XFx1MkRCRlxcdTJEQzdcXHUyRENGXFx1MkREN1xcdTJEREZcXHUyRTQzLVxcdTJFN0ZcXHUyRTlBXFx1MkVGNC1cXHUyRUZGXFx1MkZENi1cXHUyRkVGXFx1MkZGQy1cXHUyRkZGXFx1MzA0MFxcdTMwOTdcXHUzMDk4XFx1MzEwMC1cXHUzMTA0XFx1MzEyRS1cXHUzMTMwXFx1MzE4RlxcdTMxQkItXFx1MzFCRlxcdTMxRTQtXFx1MzFFRlxcdTMyMUZcXHUzMkZGXFx1NERCNi1cXHU0REJGXFx1OUZENi1cXHU5RkZGXFx1QTQ4RC1cXHVBNDhGXFx1QTRDNy1cXHVBNENGXFx1QTYyQy1cXHVBNjNGXFx1QTZGOC1cXHVBNkZGXFx1QTdBRVxcdUE3QUZcXHVBN0I4LVxcdUE3RjZcXHVBODJDLVxcdUE4MkZcXHVBODNBLVxcdUE4M0ZcXHVBODc4LVxcdUE4N0ZcXHVBOEM1LVxcdUE4Q0RcXHVBOERBLVxcdUE4REZcXHVBOEZFXFx1QThGRlxcdUE5NTQtXFx1QTk1RVxcdUE5N0QtXFx1QTk3RlxcdUE5Q0VcXHVBOURBLVxcdUE5RERcXHVBOUZGXFx1QUEzNy1cXHVBQTNGXFx1QUE0RVxcdUFBNEZcXHVBQTVBXFx1QUE1QlxcdUFBQzMtXFx1QUFEQVxcdUFBRjctXFx1QUIwMFxcdUFCMDdcXHVBQjA4XFx1QUIwRlxcdUFCMTBcXHVBQjE3LVxcdUFCMUZcXHVBQjI3XFx1QUIyRlxcdUFCNjYtXFx1QUI2RlxcdUFCRUVcXHVBQkVGXFx1QUJGQS1cXHVBQkZGXFx1RDdBNC1cXHVEN0FGXFx1RDdDNy1cXHVEN0NBXFx1RDdGQy1cXHVGOEZGXFx1RkE2RVxcdUZBNkZcXHVGQURBLVxcdUZBRkZcXHVGQjA3LVxcdUZCMTJcXHVGQjE4LVxcdUZCMUNcXHVGQjM3XFx1RkIzRFxcdUZCM0ZcXHVGQjQyXFx1RkI0NVxcdUZCQzItXFx1RkJEMlxcdUZENDAtXFx1RkQ0RlxcdUZEOTBcXHVGRDkxXFx1RkRDOC1cXHVGREVGXFx1RkRGRVxcdUZERkZcXHVGRTFBLVxcdUZFMUZcXHVGRTUzXFx1RkU2N1xcdUZFNkMtXFx1RkU2RlxcdUZFNzVcXHVGRUZELVxcdUZGMDBcXHVGRkJGLVxcdUZGQzFcXHVGRkM4XFx1RkZDOVxcdUZGRDBcXHVGRkQxXFx1RkZEOFxcdUZGRDlcXHVGRkRELVxcdUZGREZcXHVGRkU3XFx1RkZFRi1cXHVGRkZCXFx1RkZGRVxcdUZGRkYnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgzNFtcXHVEQ0Y2LVxcdURDRkZcXHVERDI3XFx1REQyOFxcdURENzMtXFx1REQ3QVxcdURERTktXFx1RERGRlxcdURFNDYtXFx1REVGRlxcdURGNTctXFx1REY1RlxcdURGNzItXFx1REZGRl18XFx1RDgzNltcXHVERThDLVxcdURFOUFcXHVERUEwXFx1REVCMC1cXHVERkZGXXxcXHVEODNDW1xcdURDMkMtXFx1REMyRlxcdURDOTQtXFx1REM5RlxcdURDQUZcXHVEQ0IwXFx1RENDMFxcdURDRDBcXHVEQ0Y2LVxcdURDRkZcXHVERDBELVxcdUREMEZcXHVERDJGXFx1REQ2Qy1cXHVERDZGXFx1REQ5Qi1cXHVEREU1XFx1REUwMy1cXHVERTBGXFx1REUzQi1cXHVERTNGXFx1REU0OS1cXHVERTRGXFx1REU1Mi1cXHVERUZGXXxcXHVEODFBW1xcdURFMzktXFx1REUzRlxcdURFNUZcXHVERTZBLVxcdURFNkRcXHVERTcwLVxcdURFQ0ZcXHVERUVFXFx1REVFRlxcdURFRjYtXFx1REVGRlxcdURGNDYtXFx1REY0RlxcdURGNUFcXHVERjYyXFx1REY3OC1cXHVERjdDXFx1REY5MC1cXHVERkZGXXxcXHVEODA5W1xcdURDNkZcXHVEQzc1LVxcdURDN0ZcXHVERDQ0LVxcdURGRkZdfFxcdUQ4MUJbXFx1REMwMC1cXHVERUZGXFx1REY0NS1cXHVERjRGXFx1REY3Ri1cXHVERjhFXFx1REZBMC1cXHVERkZGXXxcXHVEODZFW1xcdURDMUVcXHVEQzFGXXxcXHVEODNEW1xcdUREN0FcXHVEREE0XFx1REVEMS1cXHVERURGXFx1REVFRC1cXHVERUVGXFx1REVGNC1cXHVERUZGXFx1REY3NC1cXHVERjdGXFx1REZENS1cXHVERkZGXXxcXHVEODAxW1xcdURDOUVcXHVEQzlGXFx1RENBQS1cXHVEQ0ZGXFx1REQyOC1cXHVERDJGXFx1REQ2NC1cXHVERDZFXFx1REQ3MC1cXHVEREZGXFx1REYzNy1cXHVERjNGXFx1REY1Ni1cXHVERjVGXFx1REY2OC1cXHVERkZGXXxcXHVEODAwW1xcdURDMENcXHVEQzI3XFx1REMzQlxcdURDM0VcXHVEQzRFXFx1REM0RlxcdURDNUUtXFx1REM3RlxcdURDRkItXFx1RENGRlxcdUREMDMtXFx1REQwNlxcdUREMzQtXFx1REQzNlxcdUREOEQtXFx1REQ4RlxcdUREOUMtXFx1REQ5RlxcdUREQTEtXFx1RERDRlxcdURERkUtXFx1REU3RlxcdURFOUQtXFx1REU5RlxcdURFRDEtXFx1REVERlxcdURFRkMtXFx1REVGRlxcdURGMjQtXFx1REYyRlxcdURGNEItXFx1REY0RlxcdURGN0ItXFx1REY3RlxcdURGOUVcXHVERkM0LVxcdURGQzdcXHVERkQ2LVxcdURGRkZdfFxcdUQ4NjlbXFx1REVENy1cXHVERUZGXXxcXHVEODNCW1xcdURDMDAtXFx1RERGRlxcdURFMDRcXHVERTIwXFx1REUyM1xcdURFMjVcXHVERTI2XFx1REUyOFxcdURFMzNcXHVERTM4XFx1REUzQVxcdURFM0MtXFx1REU0MVxcdURFNDMtXFx1REU0NlxcdURFNDhcXHVERTRBXFx1REU0Q1xcdURFNTBcXHVERTUzXFx1REU1NVxcdURFNTZcXHVERTU4XFx1REU1QVxcdURFNUNcXHVERTVFXFx1REU2MFxcdURFNjNcXHVERTY1XFx1REU2NlxcdURFNkJcXHVERTczXFx1REU3OFxcdURFN0RcXHVERTdGXFx1REU4QVxcdURFOUMtXFx1REVBMFxcdURFQTRcXHVERUFBXFx1REVCQy1cXHVERUVGXFx1REVGMi1cXHVERkZGXXxcXHVEODdFW1xcdURFMUUtXFx1REZGRl18XFx1REI0MFtcXHVEQzAwLVxcdURDRkZcXHVEREYwLVxcdURGRkZdfFxcdUQ4MDRbXFx1REM0RS1cXHVEQzUxXFx1REM3MC1cXHVEQzdFXFx1RENCRFxcdURDQzItXFx1RENDRlxcdURDRTktXFx1RENFRlxcdURDRkEtXFx1RENGRlxcdUREMzVcXHVERDQ0LVxcdURENEZcXHVERDc3LVxcdUREN0ZcXHVERENFXFx1RERDRlxcdURERTBcXHVEREY1LVxcdURERkZcXHVERTEyXFx1REUzRS1cXHVERTdGXFx1REU4N1xcdURFODlcXHVERThFXFx1REU5RVxcdURFQUEtXFx1REVBRlxcdURFRUItXFx1REVFRlxcdURFRkEtXFx1REVGRlxcdURGMDRcXHVERjBEXFx1REYwRVxcdURGMTFcXHVERjEyXFx1REYyOVxcdURGMzFcXHVERjM0XFx1REYzQVxcdURGM0JcXHVERjQ1XFx1REY0NlxcdURGNDlcXHVERjRBXFx1REY0RVxcdURGNEZcXHVERjUxLVxcdURGNTZcXHVERjU4LVxcdURGNUNcXHVERjY0XFx1REY2NVxcdURGNkQtXFx1REY2RlxcdURGNzUtXFx1REZGRl18XFx1RDgzQVtcXHVEQ0M1XFx1RENDNlxcdURDRDctXFx1REZGRl18XFx1RDgwRFtcXHVEQzJGLVxcdURGRkZdfFxcdUQ4NkRbXFx1REYzNS1cXHVERjNGXXxbXFx1RDgwN1xcdUQ4MEFcXHVEODBCXFx1RDgwRS1cXHVEODEwXFx1RDgxMi1cXHVEODE5XFx1RDgxQy1cXHVEODJCXFx1RDgyRFxcdUQ4MkVcXHVEODMwLVxcdUQ4MzNcXHVEODM3LVxcdUQ4MzlcXHVEODNGXFx1RDg3NC1cXHVEODdEXFx1RDg3Ri1cXHVEQjNGXFx1REI0MS1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZdfFxcdUQ4MDZbXFx1REMwMC1cXHVEQzlGXFx1RENGMy1cXHVEQ0ZFXFx1REQwMC1cXHVERUJGXFx1REVGOS1cXHVERkZGXXxcXHVEODAzW1xcdURDNDktXFx1REM3RlxcdURDQjMtXFx1RENCRlxcdURDRjMtXFx1RENGOVxcdUREMDAtXFx1REU1RlxcdURFN0YtXFx1REZGRl18XFx1RDgzNVtcXHVEQzU1XFx1REM5RFxcdURDQTBcXHVEQ0ExXFx1RENBM1xcdURDQTRcXHVEQ0E3XFx1RENBOFxcdURDQURcXHVEQ0JBXFx1RENCQ1xcdURDQzRcXHVERDA2XFx1REQwQlxcdUREMENcXHVERDE1XFx1REQxRFxcdUREM0FcXHVERDNGXFx1REQ0NVxcdURENDctXFx1REQ0OVxcdURENTFcXHVERUE2XFx1REVBN1xcdURGQ0NcXHVERkNEXXxcXHVEODA1W1xcdURDMDAtXFx1REM3RlxcdURDQzgtXFx1RENDRlxcdURDREEtXFx1REQ3RlxcdUREQjZcXHVEREI3XFx1RERERS1cXHVEREZGXFx1REU0NS1cXHVERTRGXFx1REU1QS1cXHVERTdGXFx1REVCOC1cXHVERUJGXFx1REVDQS1cXHVERUZGXFx1REYxQS1cXHVERjFDXFx1REYyQy1cXHVERjJGXFx1REY0MC1cXHVERkZGXXxcXHVEODAyW1xcdURDMDZcXHVEQzA3XFx1REMwOVxcdURDMzZcXHVEQzM5LVxcdURDM0JcXHVEQzNEXFx1REMzRVxcdURDNTZcXHVEQzlGLVxcdURDQTZcXHVEQ0IwLVxcdURDREZcXHVEQ0YzXFx1RENGNi1cXHVEQ0ZBXFx1REQxQy1cXHVERDFFXFx1REQzQS1cXHVERDNFXFx1REQ0MC1cXHVERDdGXFx1RERCOC1cXHVEREJCXFx1REREMFxcdURERDFcXHVERTA0XFx1REUwNy1cXHVERTBCXFx1REUxNFxcdURFMThcXHVERTM0LVxcdURFMzdcXHVERTNCLVxcdURFM0VcXHVERTQ4LVxcdURFNEZcXHVERTU5LVxcdURFNUZcXHVERUEwLVxcdURFQkZcXHVERUU3LVxcdURFRUFcXHVERUY3LVxcdURFRkZcXHVERjM2LVxcdURGMzhcXHVERjU2XFx1REY1N1xcdURGNzMtXFx1REY3N1xcdURGOTItXFx1REY5OFxcdURGOUQtXFx1REZBOFxcdURGQjAtXFx1REZGRl18XFx1RDgwOFtcXHVERjlBLVxcdURGRkZdfFxcdUQ4MkZbXFx1REM2Qi1cXHVEQzZGXFx1REM3RC1cXHVEQzdGXFx1REM4OS1cXHVEQzhGXFx1REM5QVxcdURDOUJcXHVEQ0EwLVxcdURGRkZdfFxcdUQ4MkNbXFx1REMwMi1cXHVERkZGXXxcXHVEODExW1xcdURFNDctXFx1REZGRl18XFx1RDgzRVtcXHVEQzBDLVxcdURDMEZcXHVEQzQ4LVxcdURDNEZcXHVEQzVBLVxcdURDNUZcXHVEQzg4LVxcdURDOEZcXHVEQ0FFLVxcdUREMEZcXHVERDE5LVxcdUREN0ZcXHVERDg1LVxcdUREQkZcXHVEREMxLVxcdURGRkZdfFxcdUQ4NzNbXFx1REVBMi1cXHVERkZGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0NjJyxcbiAgICAgICAgICAgIGFsaWFzOiAnQ29udHJvbCcsXG4gICAgICAgICAgICBibXA6ICdcXDAtXFx4MUZcXHg3Ri1cXHg5RidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0NmJyxcbiAgICAgICAgICAgIGFsaWFzOiAnRm9ybWF0JyxcbiAgICAgICAgICAgIGJtcDogJ1xceEFEXFx1MDYwMC1cXHUwNjA1XFx1MDYxQ1xcdTA2RERcXHUwNzBGXFx1MTgwRVxcdTIwMEItXFx1MjAwRlxcdTIwMkEtXFx1MjAyRVxcdTIwNjAtXFx1MjA2NFxcdTIwNjYtXFx1MjA2RlxcdUZFRkZcXHVGRkY5LVxcdUZGRkInLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1REI0MFtcXHVEQzAxXFx1REMyMC1cXHVEQzdGXXxcXHVEODJGW1xcdURDQTAtXFx1RENBM118XFx1RDgzNFtcXHVERDczLVxcdUREN0FdfFxcdUQ4MDRcXHVEQ0JEJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnQ24nLFxuICAgICAgICAgICAgYWxpYXM6ICdVbmFzc2lnbmVkJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTAzNzhcXHUwMzc5XFx1MDM4MC1cXHUwMzgzXFx1MDM4QlxcdTAzOERcXHUwM0EyXFx1MDUzMFxcdTA1NTdcXHUwNTU4XFx1MDU2MFxcdTA1ODhcXHUwNThCXFx1MDU4Q1xcdTA1OTBcXHUwNUM4LVxcdTA1Q0ZcXHUwNUVCLVxcdTA1RUZcXHUwNUY1LVxcdTA1RkZcXHUwNjFEXFx1MDcwRVxcdTA3NEJcXHUwNzRDXFx1MDdCMi1cXHUwN0JGXFx1MDdGQi1cXHUwN0ZGXFx1MDgyRVxcdTA4MkZcXHUwODNGXFx1MDg1Q1xcdTA4NURcXHUwODVGLVxcdTA4OUZcXHUwOEI1LVxcdTA4RTJcXHUwOTg0XFx1MDk4RFxcdTA5OEVcXHUwOTkxXFx1MDk5MlxcdTA5QTlcXHUwOUIxXFx1MDlCMy1cXHUwOUI1XFx1MDlCQVxcdTA5QkJcXHUwOUM1XFx1MDlDNlxcdTA5QzlcXHUwOUNBXFx1MDlDRi1cXHUwOUQ2XFx1MDlEOC1cXHUwOURCXFx1MDlERVxcdTA5RTRcXHUwOUU1XFx1MDlGQy1cXHUwQTAwXFx1MEEwNFxcdTBBMEItXFx1MEEwRVxcdTBBMTFcXHUwQTEyXFx1MEEyOVxcdTBBMzFcXHUwQTM0XFx1MEEzN1xcdTBBM0FcXHUwQTNCXFx1MEEzRFxcdTBBNDMtXFx1MEE0NlxcdTBBNDlcXHUwQTRBXFx1MEE0RS1cXHUwQTUwXFx1MEE1Mi1cXHUwQTU4XFx1MEE1RFxcdTBBNUYtXFx1MEE2NVxcdTBBNzYtXFx1MEE4MFxcdTBBODRcXHUwQThFXFx1MEE5MlxcdTBBQTlcXHUwQUIxXFx1MEFCNFxcdTBBQkFcXHUwQUJCXFx1MEFDNlxcdTBBQ0FcXHUwQUNFXFx1MEFDRlxcdTBBRDEtXFx1MEFERlxcdTBBRTRcXHUwQUU1XFx1MEFGMi1cXHUwQUY4XFx1MEFGQS1cXHUwQjAwXFx1MEIwNFxcdTBCMERcXHUwQjBFXFx1MEIxMVxcdTBCMTJcXHUwQjI5XFx1MEIzMVxcdTBCMzRcXHUwQjNBXFx1MEIzQlxcdTBCNDVcXHUwQjQ2XFx1MEI0OVxcdTBCNEFcXHUwQjRFLVxcdTBCNTVcXHUwQjU4LVxcdTBCNUJcXHUwQjVFXFx1MEI2NFxcdTBCNjVcXHUwQjc4LVxcdTBCODFcXHUwQjg0XFx1MEI4Qi1cXHUwQjhEXFx1MEI5MVxcdTBCOTYtXFx1MEI5OFxcdTBCOUJcXHUwQjlEXFx1MEJBMC1cXHUwQkEyXFx1MEJBNS1cXHUwQkE3XFx1MEJBQi1cXHUwQkFEXFx1MEJCQS1cXHUwQkJEXFx1MEJDMy1cXHUwQkM1XFx1MEJDOVxcdTBCQ0VcXHUwQkNGXFx1MEJEMS1cXHUwQkQ2XFx1MEJEOC1cXHUwQkU1XFx1MEJGQi1cXHUwQkZGXFx1MEMwNFxcdTBDMERcXHUwQzExXFx1MEMyOVxcdTBDM0EtXFx1MEMzQ1xcdTBDNDVcXHUwQzQ5XFx1MEM0RS1cXHUwQzU0XFx1MEM1N1xcdTBDNUItXFx1MEM1RlxcdTBDNjRcXHUwQzY1XFx1MEM3MC1cXHUwQzc3XFx1MEM4MFxcdTBDODRcXHUwQzhEXFx1MEM5MVxcdTBDQTlcXHUwQ0I0XFx1MENCQVxcdTBDQkJcXHUwQ0M1XFx1MENDOVxcdTBDQ0UtXFx1MENENFxcdTBDRDctXFx1MENERFxcdTBDREZcXHUwQ0U0XFx1MENFNVxcdTBDRjBcXHUwQ0YzLVxcdTBEMDBcXHUwRDA0XFx1MEQwRFxcdTBEMTFcXHUwRDNCXFx1MEQzQ1xcdTBENDVcXHUwRDQ5XFx1MEQ0Ri1cXHUwRDU2XFx1MEQ1OC1cXHUwRDVFXFx1MEQ2NFxcdTBENjVcXHUwRDc2LVxcdTBENzhcXHUwRDgwXFx1MEQ4MVxcdTBEODRcXHUwRDk3LVxcdTBEOTlcXHUwREIyXFx1MERCQ1xcdTBEQkVcXHUwREJGXFx1MERDNy1cXHUwREM5XFx1MERDQi1cXHUwRENFXFx1MERENVxcdTBERDdcXHUwREUwLVxcdTBERTVcXHUwREYwXFx1MERGMVxcdTBERjUtXFx1MEUwMFxcdTBFM0ItXFx1MEUzRVxcdTBFNUMtXFx1MEU4MFxcdTBFODNcXHUwRTg1XFx1MEU4NlxcdTBFODlcXHUwRThCXFx1MEU4Q1xcdTBFOEUtXFx1MEU5M1xcdTBFOThcXHUwRUEwXFx1MEVBNFxcdTBFQTZcXHUwRUE4XFx1MEVBOVxcdTBFQUNcXHUwRUJBXFx1MEVCRVxcdTBFQkZcXHUwRUM1XFx1MEVDN1xcdTBFQ0VcXHUwRUNGXFx1MEVEQVxcdTBFREJcXHUwRUUwLVxcdTBFRkZcXHUwRjQ4XFx1MEY2RC1cXHUwRjcwXFx1MEY5OFxcdTBGQkRcXHUwRkNEXFx1MEZEQi1cXHUwRkZGXFx1MTBDNlxcdTEwQzgtXFx1MTBDQ1xcdTEwQ0VcXHUxMENGXFx1MTI0OVxcdTEyNEVcXHUxMjRGXFx1MTI1N1xcdTEyNTlcXHUxMjVFXFx1MTI1RlxcdTEyODlcXHUxMjhFXFx1MTI4RlxcdTEyQjFcXHUxMkI2XFx1MTJCN1xcdTEyQkZcXHUxMkMxXFx1MTJDNlxcdTEyQzdcXHUxMkQ3XFx1MTMxMVxcdTEzMTZcXHUxMzE3XFx1MTM1QlxcdTEzNUNcXHUxMzdELVxcdTEzN0ZcXHUxMzlBLVxcdTEzOUZcXHUxM0Y2XFx1MTNGN1xcdTEzRkVcXHUxM0ZGXFx1MTY5RC1cXHUxNjlGXFx1MTZGOS1cXHUxNkZGXFx1MTcwRFxcdTE3MTUtXFx1MTcxRlxcdTE3MzctXFx1MTczRlxcdTE3NTQtXFx1MTc1RlxcdTE3NkRcXHUxNzcxXFx1MTc3NC1cXHUxNzdGXFx1MTdERVxcdTE3REZcXHUxN0VBLVxcdTE3RUZcXHUxN0ZBLVxcdTE3RkZcXHUxODBGXFx1MTgxQS1cXHUxODFGXFx1MTg3OC1cXHUxODdGXFx1MThBQi1cXHUxOEFGXFx1MThGNi1cXHUxOEZGXFx1MTkxRlxcdTE5MkMtXFx1MTkyRlxcdTE5M0MtXFx1MTkzRlxcdTE5NDEtXFx1MTk0M1xcdTE5NkVcXHUxOTZGXFx1MTk3NS1cXHUxOTdGXFx1MTlBQy1cXHUxOUFGXFx1MTlDQS1cXHUxOUNGXFx1MTlEQi1cXHUxOUREXFx1MUExQ1xcdTFBMURcXHUxQTVGXFx1MUE3RFxcdTFBN0VcXHUxQThBLVxcdTFBOEZcXHUxQTlBLVxcdTFBOUZcXHUxQUFFXFx1MUFBRlxcdTFBQkYtXFx1MUFGRlxcdTFCNEMtXFx1MUI0RlxcdTFCN0QtXFx1MUI3RlxcdTFCRjQtXFx1MUJGQlxcdTFDMzgtXFx1MUMzQVxcdTFDNEEtXFx1MUM0Q1xcdTFDODAtXFx1MUNCRlxcdTFDQzgtXFx1MUNDRlxcdTFDRjdcXHUxQ0ZBLVxcdTFDRkZcXHUxREY2LVxcdTFERkJcXHUxRjE2XFx1MUYxN1xcdTFGMUVcXHUxRjFGXFx1MUY0NlxcdTFGNDdcXHUxRjRFXFx1MUY0RlxcdTFGNThcXHUxRjVBXFx1MUY1Q1xcdTFGNUVcXHUxRjdFXFx1MUY3RlxcdTFGQjVcXHUxRkM1XFx1MUZENFxcdTFGRDVcXHUxRkRDXFx1MUZGMFxcdTFGRjFcXHUxRkY1XFx1MUZGRlxcdTIwNjVcXHUyMDcyXFx1MjA3M1xcdTIwOEZcXHUyMDlELVxcdTIwOUZcXHUyMEJGLVxcdTIwQ0ZcXHUyMEYxLVxcdTIwRkZcXHUyMThDLVxcdTIxOEZcXHUyM0ZCLVxcdTIzRkZcXHUyNDI3LVxcdTI0M0ZcXHUyNDRCLVxcdTI0NUZcXHUyQjc0XFx1MkI3NVxcdTJCOTZcXHUyQjk3XFx1MkJCQS1cXHUyQkJDXFx1MkJDOVxcdTJCRDItXFx1MkJFQlxcdTJCRjAtXFx1MkJGRlxcdTJDMkZcXHUyQzVGXFx1MkNGNC1cXHUyQ0Y4XFx1MkQyNlxcdTJEMjgtXFx1MkQyQ1xcdTJEMkVcXHUyRDJGXFx1MkQ2OC1cXHUyRDZFXFx1MkQ3MS1cXHUyRDdFXFx1MkQ5Ny1cXHUyRDlGXFx1MkRBN1xcdTJEQUZcXHUyREI3XFx1MkRCRlxcdTJEQzdcXHUyRENGXFx1MkREN1xcdTJEREZcXHUyRTQzLVxcdTJFN0ZcXHUyRTlBXFx1MkVGNC1cXHUyRUZGXFx1MkZENi1cXHUyRkVGXFx1MkZGQy1cXHUyRkZGXFx1MzA0MFxcdTMwOTdcXHUzMDk4XFx1MzEwMC1cXHUzMTA0XFx1MzEyRS1cXHUzMTMwXFx1MzE4RlxcdTMxQkItXFx1MzFCRlxcdTMxRTQtXFx1MzFFRlxcdTMyMUZcXHUzMkZGXFx1NERCNi1cXHU0REJGXFx1OUZENi1cXHU5RkZGXFx1QTQ4RC1cXHVBNDhGXFx1QTRDNy1cXHVBNENGXFx1QTYyQy1cXHVBNjNGXFx1QTZGOC1cXHVBNkZGXFx1QTdBRVxcdUE3QUZcXHVBN0I4LVxcdUE3RjZcXHVBODJDLVxcdUE4MkZcXHVBODNBLVxcdUE4M0ZcXHVBODc4LVxcdUE4N0ZcXHVBOEM1LVxcdUE4Q0RcXHVBOERBLVxcdUE4REZcXHVBOEZFXFx1QThGRlxcdUE5NTQtXFx1QTk1RVxcdUE5N0QtXFx1QTk3RlxcdUE5Q0VcXHVBOURBLVxcdUE5RERcXHVBOUZGXFx1QUEzNy1cXHVBQTNGXFx1QUE0RVxcdUFBNEZcXHVBQTVBXFx1QUE1QlxcdUFBQzMtXFx1QUFEQVxcdUFBRjctXFx1QUIwMFxcdUFCMDdcXHVBQjA4XFx1QUIwRlxcdUFCMTBcXHVBQjE3LVxcdUFCMUZcXHVBQjI3XFx1QUIyRlxcdUFCNjYtXFx1QUI2RlxcdUFCRUVcXHVBQkVGXFx1QUJGQS1cXHVBQkZGXFx1RDdBNC1cXHVEN0FGXFx1RDdDNy1cXHVEN0NBXFx1RDdGQy1cXHVEN0ZGXFx1RkE2RVxcdUZBNkZcXHVGQURBLVxcdUZBRkZcXHVGQjA3LVxcdUZCMTJcXHVGQjE4LVxcdUZCMUNcXHVGQjM3XFx1RkIzRFxcdUZCM0ZcXHVGQjQyXFx1RkI0NVxcdUZCQzItXFx1RkJEMlxcdUZENDAtXFx1RkQ0RlxcdUZEOTBcXHVGRDkxXFx1RkRDOC1cXHVGREVGXFx1RkRGRVxcdUZERkZcXHVGRTFBLVxcdUZFMUZcXHVGRTUzXFx1RkU2N1xcdUZFNkMtXFx1RkU2RlxcdUZFNzVcXHVGRUZEXFx1RkVGRVxcdUZGMDBcXHVGRkJGLVxcdUZGQzFcXHVGRkM4XFx1RkZDOVxcdUZGRDBcXHVGRkQxXFx1RkZEOFxcdUZGRDlcXHVGRkRELVxcdUZGREZcXHVGRkU3XFx1RkZFRi1cXHVGRkY4XFx1RkZGRVxcdUZGRkYnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1REI0MFtcXHVEQzAwXFx1REMwMi1cXHVEQzFGXFx1REM4MC1cXHVEQ0ZGXFx1RERGMC1cXHVERkZGXXxcXHVEODM0W1xcdURDRjYtXFx1RENGRlxcdUREMjdcXHVERDI4XFx1RERFOS1cXHVEREZGXFx1REU0Ni1cXHVERUZGXFx1REY1Ny1cXHVERjVGXFx1REY3Mi1cXHVERkZGXXxcXHVEODNDW1xcdURDMkMtXFx1REMyRlxcdURDOTQtXFx1REM5RlxcdURDQUZcXHVEQ0IwXFx1RENDMFxcdURDRDBcXHVEQ0Y2LVxcdURDRkZcXHVERDBELVxcdUREMEZcXHVERDJGXFx1REQ2Qy1cXHVERDZGXFx1REQ5Qi1cXHVEREU1XFx1REUwMy1cXHVERTBGXFx1REUzQi1cXHVERTNGXFx1REU0OS1cXHVERTRGXFx1REU1Mi1cXHVERUZGXXxcXHVEODFBW1xcdURFMzktXFx1REUzRlxcdURFNUZcXHVERTZBLVxcdURFNkRcXHVERTcwLVxcdURFQ0ZcXHVERUVFXFx1REVFRlxcdURFRjYtXFx1REVGRlxcdURGNDYtXFx1REY0RlxcdURGNUFcXHVERjYyXFx1REY3OC1cXHVERjdDXFx1REY5MC1cXHVERkZGXXxcXHVEODA5W1xcdURDNkZcXHVEQzc1LVxcdURDN0ZcXHVERDQ0LVxcdURGRkZdfFxcdUQ4MUJbXFx1REMwMC1cXHVERUZGXFx1REY0NS1cXHVERjRGXFx1REY3Ri1cXHVERjhFXFx1REZBMC1cXHVERkZGXXxcXHVEODZFW1xcdURDMUVcXHVEQzFGXXxcXHVEODNEW1xcdUREN0FcXHVEREE0XFx1REVEMS1cXHVERURGXFx1REVFRC1cXHVERUVGXFx1REVGNC1cXHVERUZGXFx1REY3NC1cXHVERjdGXFx1REZENS1cXHVERkZGXXxcXHVEODAxW1xcdURDOUVcXHVEQzlGXFx1RENBQS1cXHVEQ0ZGXFx1REQyOC1cXHVERDJGXFx1REQ2NC1cXHVERDZFXFx1REQ3MC1cXHVEREZGXFx1REYzNy1cXHVERjNGXFx1REY1Ni1cXHVERjVGXFx1REY2OC1cXHVERkZGXXxcXHVEODAwW1xcdURDMENcXHVEQzI3XFx1REMzQlxcdURDM0VcXHVEQzRFXFx1REM0RlxcdURDNUUtXFx1REM3RlxcdURDRkItXFx1RENGRlxcdUREMDMtXFx1REQwNlxcdUREMzQtXFx1REQzNlxcdUREOEQtXFx1REQ4RlxcdUREOUMtXFx1REQ5RlxcdUREQTEtXFx1RERDRlxcdURERkUtXFx1REU3RlxcdURFOUQtXFx1REU5RlxcdURFRDEtXFx1REVERlxcdURFRkMtXFx1REVGRlxcdURGMjQtXFx1REYyRlxcdURGNEItXFx1REY0RlxcdURGN0ItXFx1REY3RlxcdURGOUVcXHVERkM0LVxcdURGQzdcXHVERkQ2LVxcdURGRkZdfFxcdUQ4NjlbXFx1REVENy1cXHVERUZGXXxcXHVEODNCW1xcdURDMDAtXFx1RERGRlxcdURFMDRcXHVERTIwXFx1REUyM1xcdURFMjVcXHVERTI2XFx1REUyOFxcdURFMzNcXHVERTM4XFx1REUzQVxcdURFM0MtXFx1REU0MVxcdURFNDMtXFx1REU0NlxcdURFNDhcXHVERTRBXFx1REU0Q1xcdURFNTBcXHVERTUzXFx1REU1NVxcdURFNTZcXHVERTU4XFx1REU1QVxcdURFNUNcXHVERTVFXFx1REU2MFxcdURFNjNcXHVERTY1XFx1REU2NlxcdURFNkJcXHVERTczXFx1REU3OFxcdURFN0RcXHVERTdGXFx1REU4QVxcdURFOUMtXFx1REVBMFxcdURFQTRcXHVERUFBXFx1REVCQy1cXHVERUVGXFx1REVGMi1cXHVERkZGXXxbXFx1REJCRlxcdURCRkZdW1xcdURGRkVcXHVERkZGXXxcXHVEODdFW1xcdURFMUUtXFx1REZGRl18XFx1RDgyRltcXHVEQzZCLVxcdURDNkZcXHVEQzdELVxcdURDN0ZcXHVEQzg5LVxcdURDOEZcXHVEQzlBXFx1REM5QlxcdURDQTQtXFx1REZGRl18XFx1RDgzQVtcXHVEQ0M1XFx1RENDNlxcdURDRDctXFx1REZGRl18XFx1RDgwRFtcXHVEQzJGLVxcdURGRkZdfFxcdUQ4NkRbXFx1REYzNS1cXHVERjNGXXxbXFx1RDgwN1xcdUQ4MEFcXHVEODBCXFx1RDgwRS1cXHVEODEwXFx1RDgxMi1cXHVEODE5XFx1RDgxQy1cXHVEODJCXFx1RDgyRFxcdUQ4MkVcXHVEODMwLVxcdUQ4MzNcXHVEODM3LVxcdUQ4MzlcXHVEODNGXFx1RDg3NC1cXHVEODdEXFx1RDg3Ri1cXHVEQjNGXFx1REI0MS1cXHVEQjdGXVtcXHVEQzAwLVxcdURGRkZdfFxcdUQ4MDZbXFx1REMwMC1cXHVEQzlGXFx1RENGMy1cXHVEQ0ZFXFx1REQwMC1cXHVERUJGXFx1REVGOS1cXHVERkZGXXxcXHVEODAzW1xcdURDNDktXFx1REM3RlxcdURDQjMtXFx1RENCRlxcdURDRjMtXFx1RENGOVxcdUREMDAtXFx1REU1RlxcdURFN0YtXFx1REZGRl18XFx1RDgzNVtcXHVEQzU1XFx1REM5RFxcdURDQTBcXHVEQ0ExXFx1RENBM1xcdURDQTRcXHVEQ0E3XFx1RENBOFxcdURDQURcXHVEQ0JBXFx1RENCQ1xcdURDQzRcXHVERDA2XFx1REQwQlxcdUREMENcXHVERDE1XFx1REQxRFxcdUREM0FcXHVERDNGXFx1REQ0NVxcdURENDctXFx1REQ0OVxcdURENTFcXHVERUE2XFx1REVBN1xcdURGQ0NcXHVERkNEXXxcXHVEODM2W1xcdURFOEMtXFx1REU5QVxcdURFQTBcXHVERUIwLVxcdURGRkZdfFxcdUQ4MDVbXFx1REMwMC1cXHVEQzdGXFx1RENDOC1cXHVEQ0NGXFx1RENEQS1cXHVERDdGXFx1RERCNlxcdUREQjdcXHVERERFLVxcdURERkZcXHVERTQ1LVxcdURFNEZcXHVERTVBLVxcdURFN0ZcXHVERUI4LVxcdURFQkZcXHVERUNBLVxcdURFRkZcXHVERjFBLVxcdURGMUNcXHVERjJDLVxcdURGMkZcXHVERjQwLVxcdURGRkZdfFxcdUQ4MDJbXFx1REMwNlxcdURDMDdcXHVEQzA5XFx1REMzNlxcdURDMzktXFx1REMzQlxcdURDM0RcXHVEQzNFXFx1REM1NlxcdURDOUYtXFx1RENBNlxcdURDQjAtXFx1RENERlxcdURDRjNcXHVEQ0Y2LVxcdURDRkFcXHVERDFDLVxcdUREMUVcXHVERDNBLVxcdUREM0VcXHVERDQwLVxcdUREN0ZcXHVEREI4LVxcdUREQkJcXHVEREQwXFx1REREMVxcdURFMDRcXHVERTA3LVxcdURFMEJcXHVERTE0XFx1REUxOFxcdURFMzQtXFx1REUzN1xcdURFM0ItXFx1REUzRVxcdURFNDgtXFx1REU0RlxcdURFNTktXFx1REU1RlxcdURFQTAtXFx1REVCRlxcdURFRTctXFx1REVFQVxcdURFRjctXFx1REVGRlxcdURGMzYtXFx1REYzOFxcdURGNTZcXHVERjU3XFx1REY3My1cXHVERjc3XFx1REY5Mi1cXHVERjk4XFx1REY5RC1cXHVERkE4XFx1REZCMC1cXHVERkZGXXxcXHVEODA4W1xcdURGOUEtXFx1REZGRl18XFx1RDgwNFtcXHVEQzRFLVxcdURDNTFcXHVEQzcwLVxcdURDN0VcXHVEQ0MyLVxcdURDQ0ZcXHVEQ0U5LVxcdURDRUZcXHVEQ0ZBLVxcdURDRkZcXHVERDM1XFx1REQ0NC1cXHVERDRGXFx1REQ3Ny1cXHVERDdGXFx1RERDRVxcdUREQ0ZcXHVEREUwXFx1RERGNS1cXHVEREZGXFx1REUxMlxcdURFM0UtXFx1REU3RlxcdURFODdcXHVERTg5XFx1REU4RVxcdURFOUVcXHVERUFBLVxcdURFQUZcXHVERUVCLVxcdURFRUZcXHVERUZBLVxcdURFRkZcXHVERjA0XFx1REYwRFxcdURGMEVcXHVERjExXFx1REYxMlxcdURGMjlcXHVERjMxXFx1REYzNFxcdURGM0FcXHVERjNCXFx1REY0NVxcdURGNDZcXHVERjQ5XFx1REY0QVxcdURGNEVcXHVERjRGXFx1REY1MS1cXHVERjU2XFx1REY1OC1cXHVERjVDXFx1REY2NFxcdURGNjVcXHVERjZELVxcdURGNkZcXHVERjc1LVxcdURGRkZdfFxcdUQ4MkNbXFx1REMwMi1cXHVERkZGXXxcXHVEODExW1xcdURFNDctXFx1REZGRl18XFx1RDgzRVtcXHVEQzBDLVxcdURDMEZcXHVEQzQ4LVxcdURDNEZcXHVEQzVBLVxcdURDNUZcXHVEQzg4LVxcdURDOEZcXHVEQ0FFLVxcdUREMEZcXHVERDE5LVxcdUREN0ZcXHVERDg1LVxcdUREQkZcXHVEREMxLVxcdURGRkZdfFxcdUQ4NzNbXFx1REVBMi1cXHVERkZGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0NvJyxcbiAgICAgICAgICAgIGFsaWFzOiAnUHJpdmF0ZV9Vc2UnLFxuICAgICAgICAgICAgYm1wOiAnXFx1RTAwMC1cXHVGOEZGJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1tcXHVEQjgwLVxcdURCQkVcXHVEQkMwLVxcdURCRkVdW1xcdURDMDAtXFx1REZGRl18W1xcdURCQkZcXHVEQkZGXVtcXHVEQzAwLVxcdURGRkRdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnQ3MnLFxuICAgICAgICAgICAgYWxpYXM6ICdTdXJyb2dhdGUnLFxuICAgICAgICAgICAgYm1wOiAnXFx1RDgwMC1cXHVERkZGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnTCcsXG4gICAgICAgICAgICBhbGlhczogJ0xldHRlcicsXG4gICAgICAgICAgICBibXA6ICdBLVphLXpcXHhBQVxceEI1XFx4QkFcXHhDMC1cXHhENlxceEQ4LVxceEY2XFx4RjgtXFx1MDJDMVxcdTAyQzYtXFx1MDJEMVxcdTAyRTAtXFx1MDJFNFxcdTAyRUNcXHUwMkVFXFx1MDM3MC1cXHUwMzc0XFx1MDM3NlxcdTAzNzdcXHUwMzdBLVxcdTAzN0RcXHUwMzdGXFx1MDM4NlxcdTAzODgtXFx1MDM4QVxcdTAzOENcXHUwMzhFLVxcdTAzQTFcXHUwM0EzLVxcdTAzRjVcXHUwM0Y3LVxcdTA0ODFcXHUwNDhBLVxcdTA1MkZcXHUwNTMxLVxcdTA1NTZcXHUwNTU5XFx1MDU2MS1cXHUwNTg3XFx1MDVEMC1cXHUwNUVBXFx1MDVGMC1cXHUwNUYyXFx1MDYyMC1cXHUwNjRBXFx1MDY2RVxcdTA2NkZcXHUwNjcxLVxcdTA2RDNcXHUwNkQ1XFx1MDZFNVxcdTA2RTZcXHUwNkVFXFx1MDZFRlxcdTA2RkEtXFx1MDZGQ1xcdTA2RkZcXHUwNzEwXFx1MDcxMi1cXHUwNzJGXFx1MDc0RC1cXHUwN0E1XFx1MDdCMVxcdTA3Q0EtXFx1MDdFQVxcdTA3RjRcXHUwN0Y1XFx1MDdGQVxcdTA4MDAtXFx1MDgxNVxcdTA4MUFcXHUwODI0XFx1MDgyOFxcdTA4NDAtXFx1MDg1OFxcdTA4QTAtXFx1MDhCNFxcdTA5MDQtXFx1MDkzOVxcdTA5M0RcXHUwOTUwXFx1MDk1OC1cXHUwOTYxXFx1MDk3MS1cXHUwOTgwXFx1MDk4NS1cXHUwOThDXFx1MDk4RlxcdTA5OTBcXHUwOTkzLVxcdTA5QThcXHUwOUFBLVxcdTA5QjBcXHUwOUIyXFx1MDlCNi1cXHUwOUI5XFx1MDlCRFxcdTA5Q0VcXHUwOURDXFx1MDlERFxcdTA5REYtXFx1MDlFMVxcdTA5RjBcXHUwOUYxXFx1MEEwNS1cXHUwQTBBXFx1MEEwRlxcdTBBMTBcXHUwQTEzLVxcdTBBMjhcXHUwQTJBLVxcdTBBMzBcXHUwQTMyXFx1MEEzM1xcdTBBMzVcXHUwQTM2XFx1MEEzOFxcdTBBMzlcXHUwQTU5LVxcdTBBNUNcXHUwQTVFXFx1MEE3Mi1cXHUwQTc0XFx1MEE4NS1cXHUwQThEXFx1MEE4Ri1cXHUwQTkxXFx1MEE5My1cXHUwQUE4XFx1MEFBQS1cXHUwQUIwXFx1MEFCMlxcdTBBQjNcXHUwQUI1LVxcdTBBQjlcXHUwQUJEXFx1MEFEMFxcdTBBRTBcXHUwQUUxXFx1MEFGOVxcdTBCMDUtXFx1MEIwQ1xcdTBCMEZcXHUwQjEwXFx1MEIxMy1cXHUwQjI4XFx1MEIyQS1cXHUwQjMwXFx1MEIzMlxcdTBCMzNcXHUwQjM1LVxcdTBCMzlcXHUwQjNEXFx1MEI1Q1xcdTBCNURcXHUwQjVGLVxcdTBCNjFcXHUwQjcxXFx1MEI4M1xcdTBCODUtXFx1MEI4QVxcdTBCOEUtXFx1MEI5MFxcdTBCOTItXFx1MEI5NVxcdTBCOTlcXHUwQjlBXFx1MEI5Q1xcdTBCOUVcXHUwQjlGXFx1MEJBM1xcdTBCQTRcXHUwQkE4LVxcdTBCQUFcXHUwQkFFLVxcdTBCQjlcXHUwQkQwXFx1MEMwNS1cXHUwQzBDXFx1MEMwRS1cXHUwQzEwXFx1MEMxMi1cXHUwQzI4XFx1MEMyQS1cXHUwQzM5XFx1MEMzRFxcdTBDNTgtXFx1MEM1QVxcdTBDNjBcXHUwQzYxXFx1MEM4NS1cXHUwQzhDXFx1MEM4RS1cXHUwQzkwXFx1MEM5Mi1cXHUwQ0E4XFx1MENBQS1cXHUwQ0IzXFx1MENCNS1cXHUwQ0I5XFx1MENCRFxcdTBDREVcXHUwQ0UwXFx1MENFMVxcdTBDRjFcXHUwQ0YyXFx1MEQwNS1cXHUwRDBDXFx1MEQwRS1cXHUwRDEwXFx1MEQxMi1cXHUwRDNBXFx1MEQzRFxcdTBENEVcXHUwRDVGLVxcdTBENjFcXHUwRDdBLVxcdTBEN0ZcXHUwRDg1LVxcdTBEOTZcXHUwRDlBLVxcdTBEQjFcXHUwREIzLVxcdTBEQkJcXHUwREJEXFx1MERDMC1cXHUwREM2XFx1MEUwMS1cXHUwRTMwXFx1MEUzMlxcdTBFMzNcXHUwRTQwLVxcdTBFNDZcXHUwRTgxXFx1MEU4MlxcdTBFODRcXHUwRTg3XFx1MEU4OFxcdTBFOEFcXHUwRThEXFx1MEU5NC1cXHUwRTk3XFx1MEU5OS1cXHUwRTlGXFx1MEVBMS1cXHUwRUEzXFx1MEVBNVxcdTBFQTdcXHUwRUFBXFx1MEVBQlxcdTBFQUQtXFx1MEVCMFxcdTBFQjJcXHUwRUIzXFx1MEVCRFxcdTBFQzAtXFx1MEVDNFxcdTBFQzZcXHUwRURDLVxcdTBFREZcXHUwRjAwXFx1MEY0MC1cXHUwRjQ3XFx1MEY0OS1cXHUwRjZDXFx1MEY4OC1cXHUwRjhDXFx1MTAwMC1cXHUxMDJBXFx1MTAzRlxcdTEwNTAtXFx1MTA1NVxcdTEwNUEtXFx1MTA1RFxcdTEwNjFcXHUxMDY1XFx1MTA2NlxcdTEwNkUtXFx1MTA3MFxcdTEwNzUtXFx1MTA4MVxcdTEwOEVcXHUxMEEwLVxcdTEwQzVcXHUxMEM3XFx1MTBDRFxcdTEwRDAtXFx1MTBGQVxcdTEwRkMtXFx1MTI0OFxcdTEyNEEtXFx1MTI0RFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVBLVxcdTEyNURcXHUxMjYwLVxcdTEyODhcXHUxMjhBLVxcdTEyOERcXHUxMjkwLVxcdTEyQjBcXHUxMkIyLVxcdTEyQjVcXHUxMkI4LVxcdTEyQkVcXHUxMkMwXFx1MTJDMi1cXHUxMkM1XFx1MTJDOC1cXHUxMkQ2XFx1MTJEOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVBXFx1MTM4MC1cXHUxMzhGXFx1MTNBMC1cXHUxM0Y1XFx1MTNGOC1cXHUxM0ZEXFx1MTQwMS1cXHUxNjZDXFx1MTY2Ri1cXHUxNjdGXFx1MTY4MS1cXHUxNjlBXFx1MTZBMC1cXHUxNkVBXFx1MTZGMS1cXHUxNkY4XFx1MTcwMC1cXHUxNzBDXFx1MTcwRS1cXHUxNzExXFx1MTcyMC1cXHUxNzMxXFx1MTc0MC1cXHUxNzUxXFx1MTc2MC1cXHUxNzZDXFx1MTc2RS1cXHUxNzcwXFx1MTc4MC1cXHUxN0IzXFx1MTdEN1xcdTE3RENcXHUxODIwLVxcdTE4NzdcXHUxODgwLVxcdTE4QThcXHUxOEFBXFx1MThCMC1cXHUxOEY1XFx1MTkwMC1cXHUxOTFFXFx1MTk1MC1cXHUxOTZEXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOUFCXFx1MTlCMC1cXHUxOUM5XFx1MUEwMC1cXHUxQTE2XFx1MUEyMC1cXHUxQTU0XFx1MUFBN1xcdTFCMDUtXFx1MUIzM1xcdTFCNDUtXFx1MUI0QlxcdTFCODMtXFx1MUJBMFxcdTFCQUVcXHUxQkFGXFx1MUJCQS1cXHUxQkU1XFx1MUMwMC1cXHUxQzIzXFx1MUM0RC1cXHUxQzRGXFx1MUM1QS1cXHUxQzdEXFx1MUNFOS1cXHUxQ0VDXFx1MUNFRS1cXHUxQ0YxXFx1MUNGNVxcdTFDRjZcXHUxRDAwLVxcdTFEQkZcXHUxRTAwLVxcdTFGMTVcXHUxRjE4LVxcdTFGMURcXHUxRjIwLVxcdTFGNDVcXHUxRjQ4LVxcdTFGNERcXHUxRjUwLVxcdTFGNTdcXHUxRjU5XFx1MUY1QlxcdTFGNURcXHUxRjVGLVxcdTFGN0RcXHUxRjgwLVxcdTFGQjRcXHUxRkI2LVxcdTFGQkNcXHUxRkJFXFx1MUZDMi1cXHUxRkM0XFx1MUZDNi1cXHUxRkNDXFx1MUZEMC1cXHUxRkQzXFx1MUZENi1cXHUxRkRCXFx1MUZFMC1cXHUxRkVDXFx1MUZGMi1cXHUxRkY0XFx1MUZGNi1cXHUxRkZDXFx1MjA3MVxcdTIwN0ZcXHUyMDkwLVxcdTIwOUNcXHUyMTAyXFx1MjEwN1xcdTIxMEEtXFx1MjExM1xcdTIxMTVcXHUyMTE5LVxcdTIxMURcXHUyMTI0XFx1MjEyNlxcdTIxMjhcXHUyMTJBLVxcdTIxMkRcXHUyMTJGLVxcdTIxMzlcXHUyMTNDLVxcdTIxM0ZcXHUyMTQ1LVxcdTIxNDlcXHUyMTRFXFx1MjE4M1xcdTIxODRcXHUyQzAwLVxcdTJDMkVcXHUyQzMwLVxcdTJDNUVcXHUyQzYwLVxcdTJDRTRcXHUyQ0VCLVxcdTJDRUVcXHUyQ0YyXFx1MkNGM1xcdTJEMDAtXFx1MkQyNVxcdTJEMjdcXHUyRDJEXFx1MkQzMC1cXHUyRDY3XFx1MkQ2RlxcdTJEODAtXFx1MkQ5NlxcdTJEQTAtXFx1MkRBNlxcdTJEQTgtXFx1MkRBRVxcdTJEQjAtXFx1MkRCNlxcdTJEQjgtXFx1MkRCRVxcdTJEQzAtXFx1MkRDNlxcdTJEQzgtXFx1MkRDRVxcdTJERDAtXFx1MkRENlxcdTJERDgtXFx1MkRERVxcdTJFMkZcXHUzMDA1XFx1MzAwNlxcdTMwMzEtXFx1MzAzNVxcdTMwM0JcXHUzMDNDXFx1MzA0MS1cXHUzMDk2XFx1MzA5RC1cXHUzMDlGXFx1MzBBMS1cXHUzMEZBXFx1MzBGQy1cXHUzMEZGXFx1MzEwNS1cXHUzMTJEXFx1MzEzMS1cXHUzMThFXFx1MzFBMC1cXHUzMUJBXFx1MzFGMC1cXHUzMUZGXFx1MzQwMC1cXHU0REI1XFx1NEUwMC1cXHU5RkQ1XFx1QTAwMC1cXHVBNDhDXFx1QTREMC1cXHVBNEZEXFx1QTUwMC1cXHVBNjBDXFx1QTYxMC1cXHVBNjFGXFx1QTYyQVxcdUE2MkJcXHVBNjQwLVxcdUE2NkVcXHVBNjdGLVxcdUE2OURcXHVBNkEwLVxcdUE2RTVcXHVBNzE3LVxcdUE3MUZcXHVBNzIyLVxcdUE3ODhcXHVBNzhCLVxcdUE3QURcXHVBN0IwLVxcdUE3QjdcXHVBN0Y3LVxcdUE4MDFcXHVBODAzLVxcdUE4MDVcXHVBODA3LVxcdUE4MEFcXHVBODBDLVxcdUE4MjJcXHVBODQwLVxcdUE4NzNcXHVBODgyLVxcdUE4QjNcXHVBOEYyLVxcdUE4RjdcXHVBOEZCXFx1QThGRFxcdUE5MEEtXFx1QTkyNVxcdUE5MzAtXFx1QTk0NlxcdUE5NjAtXFx1QTk3Q1xcdUE5ODQtXFx1QTlCMlxcdUE5Q0ZcXHVBOUUwLVxcdUE5RTRcXHVBOUU2LVxcdUE5RUZcXHVBOUZBLVxcdUE5RkVcXHVBQTAwLVxcdUFBMjhcXHVBQTQwLVxcdUFBNDJcXHVBQTQ0LVxcdUFBNEJcXHVBQTYwLVxcdUFBNzZcXHVBQTdBXFx1QUE3RS1cXHVBQUFGXFx1QUFCMVxcdUFBQjVcXHVBQUI2XFx1QUFCOS1cXHVBQUJEXFx1QUFDMFxcdUFBQzJcXHVBQURCLVxcdUFBRERcXHVBQUUwLVxcdUFBRUFcXHVBQUYyLVxcdUFBRjRcXHVBQjAxLVxcdUFCMDZcXHVBQjA5LVxcdUFCMEVcXHVBQjExLVxcdUFCMTZcXHVBQjIwLVxcdUFCMjZcXHVBQjI4LVxcdUFCMkVcXHVBQjMwLVxcdUFCNUFcXHVBQjVDLVxcdUFCNjVcXHVBQjcwLVxcdUFCRTJcXHVBQzAwLVxcdUQ3QTNcXHVEN0IwLVxcdUQ3QzZcXHVEN0NCLVxcdUQ3RkJcXHVGOTAwLVxcdUZBNkRcXHVGQTcwLVxcdUZBRDlcXHVGQjAwLVxcdUZCMDZcXHVGQjEzLVxcdUZCMTdcXHVGQjFEXFx1RkIxRi1cXHVGQjI4XFx1RkIyQS1cXHVGQjM2XFx1RkIzOC1cXHVGQjNDXFx1RkIzRVxcdUZCNDBcXHVGQjQxXFx1RkI0M1xcdUZCNDRcXHVGQjQ2LVxcdUZCQjFcXHVGQkQzLVxcdUZEM0RcXHVGRDUwLVxcdUZEOEZcXHVGRDkyLVxcdUZEQzdcXHVGREYwLVxcdUZERkJcXHVGRTcwLVxcdUZFNzRcXHVGRTc2LVxcdUZFRkNcXHVGRjIxLVxcdUZGM0FcXHVGRjQxLVxcdUZGNUFcXHVGRjY2LVxcdUZGQkVcXHVGRkMyLVxcdUZGQzdcXHVGRkNBLVxcdUZGQ0ZcXHVGRkQyLVxcdUZGRDdcXHVGRkRBLVxcdUZGREMnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDg2RVtcXHVEQzAwLVxcdURDMURcXHVEQzIwLVxcdURGRkZdfFxcdUQ4NkRbXFx1REMwMC1cXHVERjM0XFx1REY0MC1cXHVERkZGXXxcXHVEODY5W1xcdURDMDAtXFx1REVENlxcdURGMDAtXFx1REZGRl18XFx1RDgwM1tcXHVEQzAwLVxcdURDNDhcXHVEQzgwLVxcdURDQjJcXHVEQ0MwLVxcdURDRjJdfFxcdUQ4M0FbXFx1REMwMC1cXHVEQ0M0XXxcXHVEODAxW1xcdURDMDAtXFx1REM5RFxcdUREMDAtXFx1REQyN1xcdUREMzAtXFx1REQ2M1xcdURFMDAtXFx1REYzNlxcdURGNDAtXFx1REY1NVxcdURGNjAtXFx1REY2N118XFx1RDgwMFtcXHVEQzAwLVxcdURDMEJcXHVEQzBELVxcdURDMjZcXHVEQzI4LVxcdURDM0FcXHVEQzNDXFx1REMzRFxcdURDM0YtXFx1REM0RFxcdURDNTAtXFx1REM1RFxcdURDODAtXFx1RENGQVxcdURFODAtXFx1REU5Q1xcdURFQTAtXFx1REVEMFxcdURGMDAtXFx1REYxRlxcdURGMzAtXFx1REY0MFxcdURGNDItXFx1REY0OVxcdURGNTAtXFx1REY3NVxcdURGODAtXFx1REY5RFxcdURGQTAtXFx1REZDM1xcdURGQzgtXFx1REZDRl18XFx1RDgwRFtcXHVEQzAwLVxcdURDMkVdfFxcdUQ4N0VbXFx1REMwMC1cXHVERTFEXXxcXHVEODFCW1xcdURGMDAtXFx1REY0NFxcdURGNTBcXHVERjkzLVxcdURGOUZdfFtcXHVEODBDXFx1RDg0MC1cXHVEODY4XFx1RDg2QS1cXHVEODZDXFx1RDg2Ri1cXHVEODcyXVtcXHVEQzAwLVxcdURGRkZdfFxcdUQ4MDVbXFx1REM4MC1cXHVEQ0FGXFx1RENDNFxcdURDQzVcXHVEQ0M3XFx1REQ4MC1cXHVEREFFXFx1REREOC1cXHVERERCXFx1REUwMC1cXHVERTJGXFx1REU0NFxcdURFODAtXFx1REVBQVxcdURGMDAtXFx1REYxOV18XFx1RDgxQVtcXHVEQzAwLVxcdURFMzhcXHVERTQwLVxcdURFNUVcXHVERUQwLVxcdURFRURcXHVERjAwLVxcdURGMkZcXHVERjQwLVxcdURGNDNcXHVERjYzLVxcdURGNzdcXHVERjdELVxcdURGOEZdfFxcdUQ4MDlbXFx1REM4MC1cXHVERDQzXXxcXHVEODAyW1xcdURDMDAtXFx1REMwNVxcdURDMDhcXHVEQzBBLVxcdURDMzVcXHVEQzM3XFx1REMzOFxcdURDM0NcXHVEQzNGLVxcdURDNTVcXHVEQzYwLVxcdURDNzZcXHVEQzgwLVxcdURDOUVcXHVEQ0UwLVxcdURDRjJcXHVEQ0Y0XFx1RENGNVxcdUREMDAtXFx1REQxNVxcdUREMjAtXFx1REQzOVxcdUREODAtXFx1RERCN1xcdUREQkVcXHVEREJGXFx1REUwMFxcdURFMTAtXFx1REUxM1xcdURFMTUtXFx1REUxN1xcdURFMTktXFx1REUzM1xcdURFNjAtXFx1REU3Q1xcdURFODAtXFx1REU5Q1xcdURFQzAtXFx1REVDN1xcdURFQzktXFx1REVFNFxcdURGMDAtXFx1REYzNVxcdURGNDAtXFx1REY1NVxcdURGNjAtXFx1REY3MlxcdURGODAtXFx1REY5MV18XFx1RDgzNVtcXHVEQzAwLVxcdURDNTRcXHVEQzU2LVxcdURDOUNcXHVEQzlFXFx1REM5RlxcdURDQTJcXHVEQ0E1XFx1RENBNlxcdURDQTktXFx1RENBQ1xcdURDQUUtXFx1RENCOVxcdURDQkJcXHVEQ0JELVxcdURDQzNcXHVEQ0M1LVxcdUREMDVcXHVERDA3LVxcdUREMEFcXHVERDBELVxcdUREMTRcXHVERDE2LVxcdUREMUNcXHVERDFFLVxcdUREMzlcXHVERDNCLVxcdUREM0VcXHVERDQwLVxcdURENDRcXHVERDQ2XFx1REQ0QS1cXHVERDUwXFx1REQ1Mi1cXHVERUE1XFx1REVBOC1cXHVERUMwXFx1REVDMi1cXHVERURBXFx1REVEQy1cXHVERUZBXFx1REVGQy1cXHVERjE0XFx1REYxNi1cXHVERjM0XFx1REYzNi1cXHVERjRFXFx1REY1MC1cXHVERjZFXFx1REY3MC1cXHVERjg4XFx1REY4QS1cXHVERkE4XFx1REZBQS1cXHVERkMyXFx1REZDNC1cXHVERkNCXXxcXHVEODA0W1xcdURDMDMtXFx1REMzN1xcdURDODMtXFx1RENBRlxcdURDRDAtXFx1RENFOFxcdUREMDMtXFx1REQyNlxcdURENTAtXFx1REQ3MlxcdURENzZcXHVERDgzLVxcdUREQjJcXHVEREMxLVxcdUREQzRcXHVERERBXFx1REREQ1xcdURFMDAtXFx1REUxMVxcdURFMTMtXFx1REUyQlxcdURFODAtXFx1REU4NlxcdURFODhcXHVERThBLVxcdURFOERcXHVERThGLVxcdURFOURcXHVERTlGLVxcdURFQThcXHVERUIwLVxcdURFREVcXHVERjA1LVxcdURGMENcXHVERjBGXFx1REYxMFxcdURGMTMtXFx1REYyOFxcdURGMkEtXFx1REYzMFxcdURGMzJcXHVERjMzXFx1REYzNS1cXHVERjM5XFx1REYzRFxcdURGNTBcXHVERjVELVxcdURGNjFdfFxcdUQ4MDhbXFx1REMwMC1cXHVERjk5XXxcXHVEODNCW1xcdURFMDAtXFx1REUwM1xcdURFMDUtXFx1REUxRlxcdURFMjFcXHVERTIyXFx1REUyNFxcdURFMjdcXHVERTI5LVxcdURFMzJcXHVERTM0LVxcdURFMzdcXHVERTM5XFx1REUzQlxcdURFNDJcXHVERTQ3XFx1REU0OVxcdURFNEJcXHVERTRELVxcdURFNEZcXHVERTUxXFx1REU1MlxcdURFNTRcXHVERTU3XFx1REU1OVxcdURFNUJcXHVERTVEXFx1REU1RlxcdURFNjFcXHVERTYyXFx1REU2NFxcdURFNjctXFx1REU2QVxcdURFNkMtXFx1REU3MlxcdURFNzQtXFx1REU3N1xcdURFNzktXFx1REU3Q1xcdURFN0VcXHVERTgwLVxcdURFODlcXHVERThCLVxcdURFOUJcXHVERUExLVxcdURFQTNcXHVERUE1LVxcdURFQTlcXHVERUFCLVxcdURFQkJdfFxcdUQ4MDZbXFx1RENBMC1cXHVEQ0RGXFx1RENGRlxcdURFQzAtXFx1REVGOF18XFx1RDgxMVtcXHVEQzAwLVxcdURFNDZdfFxcdUQ4MkZbXFx1REMwMC1cXHVEQzZBXFx1REM3MC1cXHVEQzdDXFx1REM4MC1cXHVEQzg4XFx1REM5MC1cXHVEQzk5XXxcXHVEODJDW1xcdURDMDBcXHVEQzAxXXxcXHVEODczW1xcdURDMDAtXFx1REVBMV0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdMbCcsXG4gICAgICAgICAgICBhbGlhczogJ0xvd2VyY2FzZV9MZXR0ZXInLFxuICAgICAgICAgICAgYm1wOiAnYS16XFx4QjVcXHhERi1cXHhGNlxceEY4LVxceEZGXFx1MDEwMVxcdTAxMDNcXHUwMTA1XFx1MDEwN1xcdTAxMDlcXHUwMTBCXFx1MDEwRFxcdTAxMEZcXHUwMTExXFx1MDExM1xcdTAxMTVcXHUwMTE3XFx1MDExOVxcdTAxMUJcXHUwMTFEXFx1MDExRlxcdTAxMjFcXHUwMTIzXFx1MDEyNVxcdTAxMjdcXHUwMTI5XFx1MDEyQlxcdTAxMkRcXHUwMTJGXFx1MDEzMVxcdTAxMzNcXHUwMTM1XFx1MDEzN1xcdTAxMzhcXHUwMTNBXFx1MDEzQ1xcdTAxM0VcXHUwMTQwXFx1MDE0MlxcdTAxNDRcXHUwMTQ2XFx1MDE0OFxcdTAxNDlcXHUwMTRCXFx1MDE0RFxcdTAxNEZcXHUwMTUxXFx1MDE1M1xcdTAxNTVcXHUwMTU3XFx1MDE1OVxcdTAxNUJcXHUwMTVEXFx1MDE1RlxcdTAxNjFcXHUwMTYzXFx1MDE2NVxcdTAxNjdcXHUwMTY5XFx1MDE2QlxcdTAxNkRcXHUwMTZGXFx1MDE3MVxcdTAxNzNcXHUwMTc1XFx1MDE3N1xcdTAxN0FcXHUwMTdDXFx1MDE3RS1cXHUwMTgwXFx1MDE4M1xcdTAxODVcXHUwMTg4XFx1MDE4Q1xcdTAxOERcXHUwMTkyXFx1MDE5NVxcdTAxOTktXFx1MDE5QlxcdTAxOUVcXHUwMUExXFx1MDFBM1xcdTAxQTVcXHUwMUE4XFx1MDFBQVxcdTAxQUJcXHUwMUFEXFx1MDFCMFxcdTAxQjRcXHUwMUI2XFx1MDFCOVxcdTAxQkFcXHUwMUJELVxcdTAxQkZcXHUwMUM2XFx1MDFDOVxcdTAxQ0NcXHUwMUNFXFx1MDFEMFxcdTAxRDJcXHUwMUQ0XFx1MDFENlxcdTAxRDhcXHUwMURBXFx1MDFEQ1xcdTAxRERcXHUwMURGXFx1MDFFMVxcdTAxRTNcXHUwMUU1XFx1MDFFN1xcdTAxRTlcXHUwMUVCXFx1MDFFRFxcdTAxRUZcXHUwMUYwXFx1MDFGM1xcdTAxRjVcXHUwMUY5XFx1MDFGQlxcdTAxRkRcXHUwMUZGXFx1MDIwMVxcdTAyMDNcXHUwMjA1XFx1MDIwN1xcdTAyMDlcXHUwMjBCXFx1MDIwRFxcdTAyMEZcXHUwMjExXFx1MDIxM1xcdTAyMTVcXHUwMjE3XFx1MDIxOVxcdTAyMUJcXHUwMjFEXFx1MDIxRlxcdTAyMjFcXHUwMjIzXFx1MDIyNVxcdTAyMjdcXHUwMjI5XFx1MDIyQlxcdTAyMkRcXHUwMjJGXFx1MDIzMVxcdTAyMzMtXFx1MDIzOVxcdTAyM0NcXHUwMjNGXFx1MDI0MFxcdTAyNDJcXHUwMjQ3XFx1MDI0OVxcdTAyNEJcXHUwMjREXFx1MDI0Ri1cXHUwMjkzXFx1MDI5NS1cXHUwMkFGXFx1MDM3MVxcdTAzNzNcXHUwMzc3XFx1MDM3Qi1cXHUwMzdEXFx1MDM5MFxcdTAzQUMtXFx1MDNDRVxcdTAzRDBcXHUwM0QxXFx1MDNENS1cXHUwM0Q3XFx1MDNEOVxcdTAzREJcXHUwM0REXFx1MDNERlxcdTAzRTFcXHUwM0UzXFx1MDNFNVxcdTAzRTdcXHUwM0U5XFx1MDNFQlxcdTAzRURcXHUwM0VGLVxcdTAzRjNcXHUwM0Y1XFx1MDNGOFxcdTAzRkJcXHUwM0ZDXFx1MDQzMC1cXHUwNDVGXFx1MDQ2MVxcdTA0NjNcXHUwNDY1XFx1MDQ2N1xcdTA0NjlcXHUwNDZCXFx1MDQ2RFxcdTA0NkZcXHUwNDcxXFx1MDQ3M1xcdTA0NzVcXHUwNDc3XFx1MDQ3OVxcdTA0N0JcXHUwNDdEXFx1MDQ3RlxcdTA0ODFcXHUwNDhCXFx1MDQ4RFxcdTA0OEZcXHUwNDkxXFx1MDQ5M1xcdTA0OTVcXHUwNDk3XFx1MDQ5OVxcdTA0OUJcXHUwNDlEXFx1MDQ5RlxcdTA0QTFcXHUwNEEzXFx1MDRBNVxcdTA0QTdcXHUwNEE5XFx1MDRBQlxcdTA0QURcXHUwNEFGXFx1MDRCMVxcdTA0QjNcXHUwNEI1XFx1MDRCN1xcdTA0QjlcXHUwNEJCXFx1MDRCRFxcdTA0QkZcXHUwNEMyXFx1MDRDNFxcdTA0QzZcXHUwNEM4XFx1MDRDQVxcdTA0Q0NcXHUwNENFXFx1MDRDRlxcdTA0RDFcXHUwNEQzXFx1MDRENVxcdTA0RDdcXHUwNEQ5XFx1MDREQlxcdTA0RERcXHUwNERGXFx1MDRFMVxcdTA0RTNcXHUwNEU1XFx1MDRFN1xcdTA0RTlcXHUwNEVCXFx1MDRFRFxcdTA0RUZcXHUwNEYxXFx1MDRGM1xcdTA0RjVcXHUwNEY3XFx1MDRGOVxcdTA0RkJcXHUwNEZEXFx1MDRGRlxcdTA1MDFcXHUwNTAzXFx1MDUwNVxcdTA1MDdcXHUwNTA5XFx1MDUwQlxcdTA1MERcXHUwNTBGXFx1MDUxMVxcdTA1MTNcXHUwNTE1XFx1MDUxN1xcdTA1MTlcXHUwNTFCXFx1MDUxRFxcdTA1MUZcXHUwNTIxXFx1MDUyM1xcdTA1MjVcXHUwNTI3XFx1MDUyOVxcdTA1MkJcXHUwNTJEXFx1MDUyRlxcdTA1NjEtXFx1MDU4N1xcdTEzRjgtXFx1MTNGRFxcdTFEMDAtXFx1MUQyQlxcdTFENkItXFx1MUQ3N1xcdTFENzktXFx1MUQ5QVxcdTFFMDFcXHUxRTAzXFx1MUUwNVxcdTFFMDdcXHUxRTA5XFx1MUUwQlxcdTFFMERcXHUxRTBGXFx1MUUxMVxcdTFFMTNcXHUxRTE1XFx1MUUxN1xcdTFFMTlcXHUxRTFCXFx1MUUxRFxcdTFFMUZcXHUxRTIxXFx1MUUyM1xcdTFFMjVcXHUxRTI3XFx1MUUyOVxcdTFFMkJcXHUxRTJEXFx1MUUyRlxcdTFFMzFcXHUxRTMzXFx1MUUzNVxcdTFFMzdcXHUxRTM5XFx1MUUzQlxcdTFFM0RcXHUxRTNGXFx1MUU0MVxcdTFFNDNcXHUxRTQ1XFx1MUU0N1xcdTFFNDlcXHUxRTRCXFx1MUU0RFxcdTFFNEZcXHUxRTUxXFx1MUU1M1xcdTFFNTVcXHUxRTU3XFx1MUU1OVxcdTFFNUJcXHUxRTVEXFx1MUU1RlxcdTFFNjFcXHUxRTYzXFx1MUU2NVxcdTFFNjdcXHUxRTY5XFx1MUU2QlxcdTFFNkRcXHUxRTZGXFx1MUU3MVxcdTFFNzNcXHUxRTc1XFx1MUU3N1xcdTFFNzlcXHUxRTdCXFx1MUU3RFxcdTFFN0ZcXHUxRTgxXFx1MUU4M1xcdTFFODVcXHUxRTg3XFx1MUU4OVxcdTFFOEJcXHUxRThEXFx1MUU4RlxcdTFFOTFcXHUxRTkzXFx1MUU5NS1cXHUxRTlEXFx1MUU5RlxcdTFFQTFcXHUxRUEzXFx1MUVBNVxcdTFFQTdcXHUxRUE5XFx1MUVBQlxcdTFFQURcXHUxRUFGXFx1MUVCMVxcdTFFQjNcXHUxRUI1XFx1MUVCN1xcdTFFQjlcXHUxRUJCXFx1MUVCRFxcdTFFQkZcXHUxRUMxXFx1MUVDM1xcdTFFQzVcXHUxRUM3XFx1MUVDOVxcdTFFQ0JcXHUxRUNEXFx1MUVDRlxcdTFFRDFcXHUxRUQzXFx1MUVENVxcdTFFRDdcXHUxRUQ5XFx1MUVEQlxcdTFFRERcXHUxRURGXFx1MUVFMVxcdTFFRTNcXHUxRUU1XFx1MUVFN1xcdTFFRTlcXHUxRUVCXFx1MUVFRFxcdTFFRUZcXHUxRUYxXFx1MUVGM1xcdTFFRjVcXHUxRUY3XFx1MUVGOVxcdTFFRkJcXHUxRUZEXFx1MUVGRi1cXHUxRjA3XFx1MUYxMC1cXHUxRjE1XFx1MUYyMC1cXHUxRjI3XFx1MUYzMC1cXHUxRjM3XFx1MUY0MC1cXHUxRjQ1XFx1MUY1MC1cXHUxRjU3XFx1MUY2MC1cXHUxRjY3XFx1MUY3MC1cXHUxRjdEXFx1MUY4MC1cXHUxRjg3XFx1MUY5MC1cXHUxRjk3XFx1MUZBMC1cXHUxRkE3XFx1MUZCMC1cXHUxRkI0XFx1MUZCNlxcdTFGQjdcXHUxRkJFXFx1MUZDMi1cXHUxRkM0XFx1MUZDNlxcdTFGQzdcXHUxRkQwLVxcdTFGRDNcXHUxRkQ2XFx1MUZEN1xcdTFGRTAtXFx1MUZFN1xcdTFGRjItXFx1MUZGNFxcdTFGRjZcXHUxRkY3XFx1MjEwQVxcdTIxMEVcXHUyMTBGXFx1MjExM1xcdTIxMkZcXHUyMTM0XFx1MjEzOVxcdTIxM0NcXHUyMTNEXFx1MjE0Ni1cXHUyMTQ5XFx1MjE0RVxcdTIxODRcXHUyQzMwLVxcdTJDNUVcXHUyQzYxXFx1MkM2NVxcdTJDNjZcXHUyQzY4XFx1MkM2QVxcdTJDNkNcXHUyQzcxXFx1MkM3M1xcdTJDNzRcXHUyQzc2LVxcdTJDN0JcXHUyQzgxXFx1MkM4M1xcdTJDODVcXHUyQzg3XFx1MkM4OVxcdTJDOEJcXHUyQzhEXFx1MkM4RlxcdTJDOTFcXHUyQzkzXFx1MkM5NVxcdTJDOTdcXHUyQzk5XFx1MkM5QlxcdTJDOURcXHUyQzlGXFx1MkNBMVxcdTJDQTNcXHUyQ0E1XFx1MkNBN1xcdTJDQTlcXHUyQ0FCXFx1MkNBRFxcdTJDQUZcXHUyQ0IxXFx1MkNCM1xcdTJDQjVcXHUyQ0I3XFx1MkNCOVxcdTJDQkJcXHUyQ0JEXFx1MkNCRlxcdTJDQzFcXHUyQ0MzXFx1MkNDNVxcdTJDQzdcXHUyQ0M5XFx1MkNDQlxcdTJDQ0RcXHUyQ0NGXFx1MkNEMVxcdTJDRDNcXHUyQ0Q1XFx1MkNEN1xcdTJDRDlcXHUyQ0RCXFx1MkNERFxcdTJDREZcXHUyQ0UxXFx1MkNFM1xcdTJDRTRcXHUyQ0VDXFx1MkNFRVxcdTJDRjNcXHUyRDAwLVxcdTJEMjVcXHUyRDI3XFx1MkQyRFxcdUE2NDFcXHVBNjQzXFx1QTY0NVxcdUE2NDdcXHVBNjQ5XFx1QTY0QlxcdUE2NERcXHVBNjRGXFx1QTY1MVxcdUE2NTNcXHVBNjU1XFx1QTY1N1xcdUE2NTlcXHVBNjVCXFx1QTY1RFxcdUE2NUZcXHVBNjYxXFx1QTY2M1xcdUE2NjVcXHVBNjY3XFx1QTY2OVxcdUE2NkJcXHVBNjZEXFx1QTY4MVxcdUE2ODNcXHVBNjg1XFx1QTY4N1xcdUE2ODlcXHVBNjhCXFx1QTY4RFxcdUE2OEZcXHVBNjkxXFx1QTY5M1xcdUE2OTVcXHVBNjk3XFx1QTY5OVxcdUE2OUJcXHVBNzIzXFx1QTcyNVxcdUE3MjdcXHVBNzI5XFx1QTcyQlxcdUE3MkRcXHVBNzJGLVxcdUE3MzFcXHVBNzMzXFx1QTczNVxcdUE3MzdcXHVBNzM5XFx1QTczQlxcdUE3M0RcXHVBNzNGXFx1QTc0MVxcdUE3NDNcXHVBNzQ1XFx1QTc0N1xcdUE3NDlcXHVBNzRCXFx1QTc0RFxcdUE3NEZcXHVBNzUxXFx1QTc1M1xcdUE3NTVcXHVBNzU3XFx1QTc1OVxcdUE3NUJcXHVBNzVEXFx1QTc1RlxcdUE3NjFcXHVBNzYzXFx1QTc2NVxcdUE3NjdcXHVBNzY5XFx1QTc2QlxcdUE3NkRcXHVBNzZGXFx1QTc3MS1cXHVBNzc4XFx1QTc3QVxcdUE3N0NcXHVBNzdGXFx1QTc4MVxcdUE3ODNcXHVBNzg1XFx1QTc4N1xcdUE3OENcXHVBNzhFXFx1QTc5MVxcdUE3OTMtXFx1QTc5NVxcdUE3OTdcXHVBNzk5XFx1QTc5QlxcdUE3OURcXHVBNzlGXFx1QTdBMVxcdUE3QTNcXHVBN0E1XFx1QTdBN1xcdUE3QTlcXHVBN0I1XFx1QTdCN1xcdUE3RkFcXHVBQjMwLVxcdUFCNUFcXHVBQjYwLVxcdUFCNjVcXHVBQjcwLVxcdUFCQkZcXHVGQjAwLVxcdUZCMDZcXHVGQjEzLVxcdUZCMTdcXHVGRjQxLVxcdUZGNUEnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwM1tcXHVEQ0MwLVxcdURDRjJdfFxcdUQ4MzVbXFx1REMxQS1cXHVEQzMzXFx1REM0RS1cXHVEQzU0XFx1REM1Ni1cXHVEQzY3XFx1REM4Mi1cXHVEQzlCXFx1RENCNi1cXHVEQ0I5XFx1RENCQlxcdURDQkQtXFx1RENDM1xcdURDQzUtXFx1RENDRlxcdURDRUEtXFx1REQwM1xcdUREMUUtXFx1REQzN1xcdURENTItXFx1REQ2QlxcdUREODYtXFx1REQ5RlxcdUREQkEtXFx1REREM1xcdURERUUtXFx1REUwN1xcdURFMjItXFx1REUzQlxcdURFNTYtXFx1REU2RlxcdURFOEEtXFx1REVBNVxcdURFQzItXFx1REVEQVxcdURFREMtXFx1REVFMVxcdURFRkMtXFx1REYxNFxcdURGMTYtXFx1REYxQlxcdURGMzYtXFx1REY0RVxcdURGNTAtXFx1REY1NVxcdURGNzAtXFx1REY4OFxcdURGOEEtXFx1REY4RlxcdURGQUEtXFx1REZDMlxcdURGQzQtXFx1REZDOVxcdURGQ0JdfFxcdUQ4MDFbXFx1REMyOC1cXHVEQzRGXXxcXHVEODA2W1xcdURDQzAtXFx1RENERl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdMbScsXG4gICAgICAgICAgICBhbGlhczogJ01vZGlmaWVyX0xldHRlcicsXG4gICAgICAgICAgICBibXA6ICdcXHUwMkIwLVxcdTAyQzFcXHUwMkM2LVxcdTAyRDFcXHUwMkUwLVxcdTAyRTRcXHUwMkVDXFx1MDJFRVxcdTAzNzRcXHUwMzdBXFx1MDU1OVxcdTA2NDBcXHUwNkU1XFx1MDZFNlxcdTA3RjRcXHUwN0Y1XFx1MDdGQVxcdTA4MUFcXHUwODI0XFx1MDgyOFxcdTA5NzFcXHUwRTQ2XFx1MEVDNlxcdTEwRkNcXHUxN0Q3XFx1MTg0M1xcdTFBQTdcXHUxQzc4LVxcdTFDN0RcXHUxRDJDLVxcdTFENkFcXHUxRDc4XFx1MUQ5Qi1cXHUxREJGXFx1MjA3MVxcdTIwN0ZcXHUyMDkwLVxcdTIwOUNcXHUyQzdDXFx1MkM3RFxcdTJENkZcXHUyRTJGXFx1MzAwNVxcdTMwMzEtXFx1MzAzNVxcdTMwM0JcXHUzMDlEXFx1MzA5RVxcdTMwRkMtXFx1MzBGRVxcdUEwMTVcXHVBNEY4LVxcdUE0RkRcXHVBNjBDXFx1QTY3RlxcdUE2OUNcXHVBNjlEXFx1QTcxNy1cXHVBNzFGXFx1QTc3MFxcdUE3ODhcXHVBN0Y4XFx1QTdGOVxcdUE5Q0ZcXHVBOUU2XFx1QUE3MFxcdUFBRERcXHVBQUYzXFx1QUFGNFxcdUFCNUMtXFx1QUI1RlxcdUZGNzBcXHVGRjlFXFx1RkY5RicsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODFBW1xcdURGNDAtXFx1REY0M118XFx1RDgxQltcXHVERjkzLVxcdURGOUZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnTG8nLFxuICAgICAgICAgICAgYWxpYXM6ICdPdGhlcl9MZXR0ZXInLFxuICAgICAgICAgICAgYm1wOiAnXFx4QUFcXHhCQVxcdTAxQkJcXHUwMUMwLVxcdTAxQzNcXHUwMjk0XFx1MDVEMC1cXHUwNUVBXFx1MDVGMC1cXHUwNUYyXFx1MDYyMC1cXHUwNjNGXFx1MDY0MS1cXHUwNjRBXFx1MDY2RVxcdTA2NkZcXHUwNjcxLVxcdTA2RDNcXHUwNkQ1XFx1MDZFRVxcdTA2RUZcXHUwNkZBLVxcdTA2RkNcXHUwNkZGXFx1MDcxMFxcdTA3MTItXFx1MDcyRlxcdTA3NEQtXFx1MDdBNVxcdTA3QjFcXHUwN0NBLVxcdTA3RUFcXHUwODAwLVxcdTA4MTVcXHUwODQwLVxcdTA4NThcXHUwOEEwLVxcdTA4QjRcXHUwOTA0LVxcdTA5MzlcXHUwOTNEXFx1MDk1MFxcdTA5NTgtXFx1MDk2MVxcdTA5NzItXFx1MDk4MFxcdTA5ODUtXFx1MDk4Q1xcdTA5OEZcXHUwOTkwXFx1MDk5My1cXHUwOUE4XFx1MDlBQS1cXHUwOUIwXFx1MDlCMlxcdTA5QjYtXFx1MDlCOVxcdTA5QkRcXHUwOUNFXFx1MDlEQ1xcdTA5RERcXHUwOURGLVxcdTA5RTFcXHUwOUYwXFx1MDlGMVxcdTBBMDUtXFx1MEEwQVxcdTBBMEZcXHUwQTEwXFx1MEExMy1cXHUwQTI4XFx1MEEyQS1cXHUwQTMwXFx1MEEzMlxcdTBBMzNcXHUwQTM1XFx1MEEzNlxcdTBBMzhcXHUwQTM5XFx1MEE1OS1cXHUwQTVDXFx1MEE1RVxcdTBBNzItXFx1MEE3NFxcdTBBODUtXFx1MEE4RFxcdTBBOEYtXFx1MEE5MVxcdTBBOTMtXFx1MEFBOFxcdTBBQUEtXFx1MEFCMFxcdTBBQjJcXHUwQUIzXFx1MEFCNS1cXHUwQUI5XFx1MEFCRFxcdTBBRDBcXHUwQUUwXFx1MEFFMVxcdTBBRjlcXHUwQjA1LVxcdTBCMENcXHUwQjBGXFx1MEIxMFxcdTBCMTMtXFx1MEIyOFxcdTBCMkEtXFx1MEIzMFxcdTBCMzJcXHUwQjMzXFx1MEIzNS1cXHUwQjM5XFx1MEIzRFxcdTBCNUNcXHUwQjVEXFx1MEI1Ri1cXHUwQjYxXFx1MEI3MVxcdTBCODNcXHUwQjg1LVxcdTBCOEFcXHUwQjhFLVxcdTBCOTBcXHUwQjkyLVxcdTBCOTVcXHUwQjk5XFx1MEI5QVxcdTBCOUNcXHUwQjlFXFx1MEI5RlxcdTBCQTNcXHUwQkE0XFx1MEJBOC1cXHUwQkFBXFx1MEJBRS1cXHUwQkI5XFx1MEJEMFxcdTBDMDUtXFx1MEMwQ1xcdTBDMEUtXFx1MEMxMFxcdTBDMTItXFx1MEMyOFxcdTBDMkEtXFx1MEMzOVxcdTBDM0RcXHUwQzU4LVxcdTBDNUFcXHUwQzYwXFx1MEM2MVxcdTBDODUtXFx1MEM4Q1xcdTBDOEUtXFx1MEM5MFxcdTBDOTItXFx1MENBOFxcdTBDQUEtXFx1MENCM1xcdTBDQjUtXFx1MENCOVxcdTBDQkRcXHUwQ0RFXFx1MENFMFxcdTBDRTFcXHUwQ0YxXFx1MENGMlxcdTBEMDUtXFx1MEQwQ1xcdTBEMEUtXFx1MEQxMFxcdTBEMTItXFx1MEQzQVxcdTBEM0RcXHUwRDRFXFx1MEQ1Ri1cXHUwRDYxXFx1MEQ3QS1cXHUwRDdGXFx1MEQ4NS1cXHUwRDk2XFx1MEQ5QS1cXHUwREIxXFx1MERCMy1cXHUwREJCXFx1MERCRFxcdTBEQzAtXFx1MERDNlxcdTBFMDEtXFx1MEUzMFxcdTBFMzJcXHUwRTMzXFx1MEU0MC1cXHUwRTQ1XFx1MEU4MVxcdTBFODJcXHUwRTg0XFx1MEU4N1xcdTBFODhcXHUwRThBXFx1MEU4RFxcdTBFOTQtXFx1MEU5N1xcdTBFOTktXFx1MEU5RlxcdTBFQTEtXFx1MEVBM1xcdTBFQTVcXHUwRUE3XFx1MEVBQVxcdTBFQUJcXHUwRUFELVxcdTBFQjBcXHUwRUIyXFx1MEVCM1xcdTBFQkRcXHUwRUMwLVxcdTBFQzRcXHUwRURDLVxcdTBFREZcXHUwRjAwXFx1MEY0MC1cXHUwRjQ3XFx1MEY0OS1cXHUwRjZDXFx1MEY4OC1cXHUwRjhDXFx1MTAwMC1cXHUxMDJBXFx1MTAzRlxcdTEwNTAtXFx1MTA1NVxcdTEwNUEtXFx1MTA1RFxcdTEwNjFcXHUxMDY1XFx1MTA2NlxcdTEwNkUtXFx1MTA3MFxcdTEwNzUtXFx1MTA4MVxcdTEwOEVcXHUxMEQwLVxcdTEwRkFcXHUxMEZELVxcdTEyNDhcXHUxMjRBLVxcdTEyNERcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1QS1cXHUxMjVEXFx1MTI2MC1cXHUxMjg4XFx1MTI4QS1cXHUxMjhEXFx1MTI5MC1cXHUxMkIwXFx1MTJCMi1cXHUxMkI1XFx1MTJCOC1cXHUxMkJFXFx1MTJDMFxcdTEyQzItXFx1MTJDNVxcdTEyQzgtXFx1MTJENlxcdTEyRDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1QVxcdTEzODAtXFx1MTM4RlxcdTE0MDEtXFx1MTY2Q1xcdTE2NkYtXFx1MTY3RlxcdTE2ODEtXFx1MTY5QVxcdTE2QTAtXFx1MTZFQVxcdTE2RjEtXFx1MTZGOFxcdTE3MDAtXFx1MTcwQ1xcdTE3MEUtXFx1MTcxMVxcdTE3MjAtXFx1MTczMVxcdTE3NDAtXFx1MTc1MVxcdTE3NjAtXFx1MTc2Q1xcdTE3NkUtXFx1MTc3MFxcdTE3ODAtXFx1MTdCM1xcdTE3RENcXHUxODIwLVxcdTE4NDJcXHUxODQ0LVxcdTE4NzdcXHUxODgwLVxcdTE4QThcXHUxOEFBXFx1MThCMC1cXHUxOEY1XFx1MTkwMC1cXHUxOTFFXFx1MTk1MC1cXHUxOTZEXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOUFCXFx1MTlCMC1cXHUxOUM5XFx1MUEwMC1cXHUxQTE2XFx1MUEyMC1cXHUxQTU0XFx1MUIwNS1cXHUxQjMzXFx1MUI0NS1cXHUxQjRCXFx1MUI4My1cXHUxQkEwXFx1MUJBRVxcdTFCQUZcXHUxQkJBLVxcdTFCRTVcXHUxQzAwLVxcdTFDMjNcXHUxQzRELVxcdTFDNEZcXHUxQzVBLVxcdTFDNzdcXHUxQ0U5LVxcdTFDRUNcXHUxQ0VFLVxcdTFDRjFcXHUxQ0Y1XFx1MUNGNlxcdTIxMzUtXFx1MjEzOFxcdTJEMzAtXFx1MkQ2N1xcdTJEODAtXFx1MkQ5NlxcdTJEQTAtXFx1MkRBNlxcdTJEQTgtXFx1MkRBRVxcdTJEQjAtXFx1MkRCNlxcdTJEQjgtXFx1MkRCRVxcdTJEQzAtXFx1MkRDNlxcdTJEQzgtXFx1MkRDRVxcdTJERDAtXFx1MkRENlxcdTJERDgtXFx1MkRERVxcdTMwMDZcXHUzMDNDXFx1MzA0MS1cXHUzMDk2XFx1MzA5RlxcdTMwQTEtXFx1MzBGQVxcdTMwRkZcXHUzMTA1LVxcdTMxMkRcXHUzMTMxLVxcdTMxOEVcXHUzMUEwLVxcdTMxQkFcXHUzMUYwLVxcdTMxRkZcXHUzNDAwLVxcdTREQjVcXHU0RTAwLVxcdTlGRDVcXHVBMDAwLVxcdUEwMTRcXHVBMDE2LVxcdUE0OENcXHVBNEQwLVxcdUE0RjdcXHVBNTAwLVxcdUE2MEJcXHVBNjEwLVxcdUE2MUZcXHVBNjJBXFx1QTYyQlxcdUE2NkVcXHVBNkEwLVxcdUE2RTVcXHVBNzhGXFx1QTdGN1xcdUE3RkItXFx1QTgwMVxcdUE4MDMtXFx1QTgwNVxcdUE4MDctXFx1QTgwQVxcdUE4MEMtXFx1QTgyMlxcdUE4NDAtXFx1QTg3M1xcdUE4ODItXFx1QThCM1xcdUE4RjItXFx1QThGN1xcdUE4RkJcXHVBOEZEXFx1QTkwQS1cXHVBOTI1XFx1QTkzMC1cXHVBOTQ2XFx1QTk2MC1cXHVBOTdDXFx1QTk4NC1cXHVBOUIyXFx1QTlFMC1cXHVBOUU0XFx1QTlFNy1cXHVBOUVGXFx1QTlGQS1cXHVBOUZFXFx1QUEwMC1cXHVBQTI4XFx1QUE0MC1cXHVBQTQyXFx1QUE0NC1cXHVBQTRCXFx1QUE2MC1cXHVBQTZGXFx1QUE3MS1cXHVBQTc2XFx1QUE3QVxcdUFBN0UtXFx1QUFBRlxcdUFBQjFcXHVBQUI1XFx1QUFCNlxcdUFBQjktXFx1QUFCRFxcdUFBQzBcXHVBQUMyXFx1QUFEQlxcdUFBRENcXHVBQUUwLVxcdUFBRUFcXHVBQUYyXFx1QUIwMS1cXHVBQjA2XFx1QUIwOS1cXHVBQjBFXFx1QUIxMS1cXHVBQjE2XFx1QUIyMC1cXHVBQjI2XFx1QUIyOC1cXHVBQjJFXFx1QUJDMC1cXHVBQkUyXFx1QUMwMC1cXHVEN0EzXFx1RDdCMC1cXHVEN0M2XFx1RDdDQi1cXHVEN0ZCXFx1RjkwMC1cXHVGQTZEXFx1RkE3MC1cXHVGQUQ5XFx1RkIxRFxcdUZCMUYtXFx1RkIyOFxcdUZCMkEtXFx1RkIzNlxcdUZCMzgtXFx1RkIzQ1xcdUZCM0VcXHVGQjQwXFx1RkI0MVxcdUZCNDNcXHVGQjQ0XFx1RkI0Ni1cXHVGQkIxXFx1RkJEMy1cXHVGRDNEXFx1RkQ1MC1cXHVGRDhGXFx1RkQ5Mi1cXHVGREM3XFx1RkRGMC1cXHVGREZCXFx1RkU3MC1cXHVGRTc0XFx1RkU3Ni1cXHVGRUZDXFx1RkY2Ni1cXHVGRjZGXFx1RkY3MS1cXHVGRjlEXFx1RkZBMC1cXHVGRkJFXFx1RkZDMi1cXHVGRkM3XFx1RkZDQS1cXHVGRkNGXFx1RkZEMi1cXHVGRkQ3XFx1RkZEQS1cXHVGRkRDJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4NkVbXFx1REMwMC1cXHVEQzFEXFx1REMyMC1cXHVERkZGXXxcXHVEODZEW1xcdURDMDAtXFx1REYzNFxcdURGNDAtXFx1REZGRl18XFx1RDg2OVtcXHVEQzAwLVxcdURFRDZcXHVERjAwLVxcdURGRkZdfFxcdUQ4M0FbXFx1REMwMC1cXHVEQ0M0XXxcXHVEODAzW1xcdURDMDAtXFx1REM0OF18XFx1RDgwMFtcXHVEQzAwLVxcdURDMEJcXHVEQzBELVxcdURDMjZcXHVEQzI4LVxcdURDM0FcXHVEQzNDXFx1REMzRFxcdURDM0YtXFx1REM0RFxcdURDNTAtXFx1REM1RFxcdURDODAtXFx1RENGQVxcdURFODAtXFx1REU5Q1xcdURFQTAtXFx1REVEMFxcdURGMDAtXFx1REYxRlxcdURGMzAtXFx1REY0MFxcdURGNDItXFx1REY0OVxcdURGNTAtXFx1REY3NVxcdURGODAtXFx1REY5RFxcdURGQTAtXFx1REZDM1xcdURGQzgtXFx1REZDRl18XFx1RDgwRFtcXHVEQzAwLVxcdURDMkVdfFxcdUQ4N0VbXFx1REMwMC1cXHVERTFEXXxcXHVEODFCW1xcdURGMDAtXFx1REY0NFxcdURGNTBdfFtcXHVEODBDXFx1RDg0MC1cXHVEODY4XFx1RDg2QS1cXHVEODZDXFx1RDg2Ri1cXHVEODcyXVtcXHVEQzAwLVxcdURGRkZdfFxcdUQ4MDVbXFx1REM4MC1cXHVEQ0FGXFx1RENDNFxcdURDQzVcXHVEQ0M3XFx1REQ4MC1cXHVEREFFXFx1REREOC1cXHVERERCXFx1REUwMC1cXHVERTJGXFx1REU0NFxcdURFODAtXFx1REVBQVxcdURGMDAtXFx1REYxOV18XFx1RDgwNltcXHVEQ0ZGXFx1REVDMC1cXHVERUY4XXxcXHVEODA5W1xcdURDODAtXFx1REQ0M118XFx1RDgwMltcXHVEQzAwLVxcdURDMDVcXHVEQzA4XFx1REMwQS1cXHVEQzM1XFx1REMzN1xcdURDMzhcXHVEQzNDXFx1REMzRi1cXHVEQzU1XFx1REM2MC1cXHVEQzc2XFx1REM4MC1cXHVEQzlFXFx1RENFMC1cXHVEQ0YyXFx1RENGNFxcdURDRjVcXHVERDAwLVxcdUREMTVcXHVERDIwLVxcdUREMzlcXHVERDgwLVxcdUREQjdcXHVEREJFXFx1RERCRlxcdURFMDBcXHVERTEwLVxcdURFMTNcXHVERTE1LVxcdURFMTdcXHVERTE5LVxcdURFMzNcXHVERTYwLVxcdURFN0NcXHVERTgwLVxcdURFOUNcXHVERUMwLVxcdURFQzdcXHVERUM5LVxcdURFRTRcXHVERjAwLVxcdURGMzVcXHVERjQwLVxcdURGNTVcXHVERjYwLVxcdURGNzJcXHVERjgwLVxcdURGOTFdfFxcdUQ4MDRbXFx1REMwMy1cXHVEQzM3XFx1REM4My1cXHVEQ0FGXFx1RENEMC1cXHVEQ0U4XFx1REQwMy1cXHVERDI2XFx1REQ1MC1cXHVERDcyXFx1REQ3NlxcdUREODMtXFx1RERCMlxcdUREQzEtXFx1RERDNFxcdUREREFcXHVERERDXFx1REUwMC1cXHVERTExXFx1REUxMy1cXHVERTJCXFx1REU4MC1cXHVERTg2XFx1REU4OFxcdURFOEEtXFx1REU4RFxcdURFOEYtXFx1REU5RFxcdURFOUYtXFx1REVBOFxcdURFQjAtXFx1REVERVxcdURGMDUtXFx1REYwQ1xcdURGMEZcXHVERjEwXFx1REYxMy1cXHVERjI4XFx1REYyQS1cXHVERjMwXFx1REYzMlxcdURGMzNcXHVERjM1LVxcdURGMzlcXHVERjNEXFx1REY1MFxcdURGNUQtXFx1REY2MV18XFx1RDgwOFtcXHVEQzAwLVxcdURGOTldfFxcdUQ4M0JbXFx1REUwMC1cXHVERTAzXFx1REUwNS1cXHVERTFGXFx1REUyMVxcdURFMjJcXHVERTI0XFx1REUyN1xcdURFMjktXFx1REUzMlxcdURFMzQtXFx1REUzN1xcdURFMzlcXHVERTNCXFx1REU0MlxcdURFNDdcXHVERTQ5XFx1REU0QlxcdURFNEQtXFx1REU0RlxcdURFNTFcXHVERTUyXFx1REU1NFxcdURFNTdcXHVERTU5XFx1REU1QlxcdURFNURcXHVERTVGXFx1REU2MVxcdURFNjJcXHVERTY0XFx1REU2Ny1cXHVERTZBXFx1REU2Qy1cXHVERTcyXFx1REU3NC1cXHVERTc3XFx1REU3OS1cXHVERTdDXFx1REU3RVxcdURFODAtXFx1REU4OVxcdURFOEItXFx1REU5QlxcdURFQTEtXFx1REVBM1xcdURFQTUtXFx1REVBOVxcdURFQUItXFx1REVCQl18XFx1RDgxQVtcXHVEQzAwLVxcdURFMzhcXHVERTQwLVxcdURFNUVcXHVERUQwLVxcdURFRURcXHVERjAwLVxcdURGMkZcXHVERjYzLVxcdURGNzdcXHVERjdELVxcdURGOEZdfFxcdUQ4MDFbXFx1REM1MC1cXHVEQzlEXFx1REQwMC1cXHVERDI3XFx1REQzMC1cXHVERDYzXFx1REUwMC1cXHVERjM2XFx1REY0MC1cXHVERjU1XFx1REY2MC1cXHVERjY3XXxcXHVEODExW1xcdURDMDAtXFx1REU0Nl18XFx1RDgyRltcXHVEQzAwLVxcdURDNkFcXHVEQzcwLVxcdURDN0NcXHVEQzgwLVxcdURDODhcXHVEQzkwLVxcdURDOTldfFxcdUQ4MkNbXFx1REMwMFxcdURDMDFdfFxcdUQ4NzNbXFx1REMwMC1cXHVERUExXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0x0JyxcbiAgICAgICAgICAgIGFsaWFzOiAnVGl0bGVjYXNlX0xldHRlcicsXG4gICAgICAgICAgICBibXA6ICdcXHUwMUM1XFx1MDFDOFxcdTAxQ0JcXHUwMUYyXFx1MUY4OC1cXHUxRjhGXFx1MUY5OC1cXHUxRjlGXFx1MUZBOC1cXHUxRkFGXFx1MUZCQ1xcdTFGQ0NcXHUxRkZDJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnTHUnLFxuICAgICAgICAgICAgYWxpYXM6ICdVcHBlcmNhc2VfTGV0dGVyJyxcbiAgICAgICAgICAgIGJtcDogJ0EtWlxceEMwLVxceEQ2XFx4RDgtXFx4REVcXHUwMTAwXFx1MDEwMlxcdTAxMDRcXHUwMTA2XFx1MDEwOFxcdTAxMEFcXHUwMTBDXFx1MDEwRVxcdTAxMTBcXHUwMTEyXFx1MDExNFxcdTAxMTZcXHUwMTE4XFx1MDExQVxcdTAxMUNcXHUwMTFFXFx1MDEyMFxcdTAxMjJcXHUwMTI0XFx1MDEyNlxcdTAxMjhcXHUwMTJBXFx1MDEyQ1xcdTAxMkVcXHUwMTMwXFx1MDEzMlxcdTAxMzRcXHUwMTM2XFx1MDEzOVxcdTAxM0JcXHUwMTNEXFx1MDEzRlxcdTAxNDFcXHUwMTQzXFx1MDE0NVxcdTAxNDdcXHUwMTRBXFx1MDE0Q1xcdTAxNEVcXHUwMTUwXFx1MDE1MlxcdTAxNTRcXHUwMTU2XFx1MDE1OFxcdTAxNUFcXHUwMTVDXFx1MDE1RVxcdTAxNjBcXHUwMTYyXFx1MDE2NFxcdTAxNjZcXHUwMTY4XFx1MDE2QVxcdTAxNkNcXHUwMTZFXFx1MDE3MFxcdTAxNzJcXHUwMTc0XFx1MDE3NlxcdTAxNzhcXHUwMTc5XFx1MDE3QlxcdTAxN0RcXHUwMTgxXFx1MDE4MlxcdTAxODRcXHUwMTg2XFx1MDE4N1xcdTAxODktXFx1MDE4QlxcdTAxOEUtXFx1MDE5MVxcdTAxOTNcXHUwMTk0XFx1MDE5Ni1cXHUwMTk4XFx1MDE5Q1xcdTAxOURcXHUwMTlGXFx1MDFBMFxcdTAxQTJcXHUwMUE0XFx1MDFBNlxcdTAxQTdcXHUwMUE5XFx1MDFBQ1xcdTAxQUVcXHUwMUFGXFx1MDFCMS1cXHUwMUIzXFx1MDFCNVxcdTAxQjdcXHUwMUI4XFx1MDFCQ1xcdTAxQzRcXHUwMUM3XFx1MDFDQVxcdTAxQ0RcXHUwMUNGXFx1MDFEMVxcdTAxRDNcXHUwMUQ1XFx1MDFEN1xcdTAxRDlcXHUwMURCXFx1MDFERVxcdTAxRTBcXHUwMUUyXFx1MDFFNFxcdTAxRTZcXHUwMUU4XFx1MDFFQVxcdTAxRUNcXHUwMUVFXFx1MDFGMVxcdTAxRjRcXHUwMUY2LVxcdTAxRjhcXHUwMUZBXFx1MDFGQ1xcdTAxRkVcXHUwMjAwXFx1MDIwMlxcdTAyMDRcXHUwMjA2XFx1MDIwOFxcdTAyMEFcXHUwMjBDXFx1MDIwRVxcdTAyMTBcXHUwMjEyXFx1MDIxNFxcdTAyMTZcXHUwMjE4XFx1MDIxQVxcdTAyMUNcXHUwMjFFXFx1MDIyMFxcdTAyMjJcXHUwMjI0XFx1MDIyNlxcdTAyMjhcXHUwMjJBXFx1MDIyQ1xcdTAyMkVcXHUwMjMwXFx1MDIzMlxcdTAyM0FcXHUwMjNCXFx1MDIzRFxcdTAyM0VcXHUwMjQxXFx1MDI0My1cXHUwMjQ2XFx1MDI0OFxcdTAyNEFcXHUwMjRDXFx1MDI0RVxcdTAzNzBcXHUwMzcyXFx1MDM3NlxcdTAzN0ZcXHUwMzg2XFx1MDM4OC1cXHUwMzhBXFx1MDM4Q1xcdTAzOEVcXHUwMzhGXFx1MDM5MS1cXHUwM0ExXFx1MDNBMy1cXHUwM0FCXFx1MDNDRlxcdTAzRDItXFx1MDNENFxcdTAzRDhcXHUwM0RBXFx1MDNEQ1xcdTAzREVcXHUwM0UwXFx1MDNFMlxcdTAzRTRcXHUwM0U2XFx1MDNFOFxcdTAzRUFcXHUwM0VDXFx1MDNFRVxcdTAzRjRcXHUwM0Y3XFx1MDNGOVxcdTAzRkFcXHUwM0ZELVxcdTA0MkZcXHUwNDYwXFx1MDQ2MlxcdTA0NjRcXHUwNDY2XFx1MDQ2OFxcdTA0NkFcXHUwNDZDXFx1MDQ2RVxcdTA0NzBcXHUwNDcyXFx1MDQ3NFxcdTA0NzZcXHUwNDc4XFx1MDQ3QVxcdTA0N0NcXHUwNDdFXFx1MDQ4MFxcdTA0OEFcXHUwNDhDXFx1MDQ4RVxcdTA0OTBcXHUwNDkyXFx1MDQ5NFxcdTA0OTZcXHUwNDk4XFx1MDQ5QVxcdTA0OUNcXHUwNDlFXFx1MDRBMFxcdTA0QTJcXHUwNEE0XFx1MDRBNlxcdTA0QThcXHUwNEFBXFx1MDRBQ1xcdTA0QUVcXHUwNEIwXFx1MDRCMlxcdTA0QjRcXHUwNEI2XFx1MDRCOFxcdTA0QkFcXHUwNEJDXFx1MDRCRVxcdTA0QzBcXHUwNEMxXFx1MDRDM1xcdTA0QzVcXHUwNEM3XFx1MDRDOVxcdTA0Q0JcXHUwNENEXFx1MDREMFxcdTA0RDJcXHUwNEQ0XFx1MDRENlxcdTA0RDhcXHUwNERBXFx1MDREQ1xcdTA0REVcXHUwNEUwXFx1MDRFMlxcdTA0RTRcXHUwNEU2XFx1MDRFOFxcdTA0RUFcXHUwNEVDXFx1MDRFRVxcdTA0RjBcXHUwNEYyXFx1MDRGNFxcdTA0RjZcXHUwNEY4XFx1MDRGQVxcdTA0RkNcXHUwNEZFXFx1MDUwMFxcdTA1MDJcXHUwNTA0XFx1MDUwNlxcdTA1MDhcXHUwNTBBXFx1MDUwQ1xcdTA1MEVcXHUwNTEwXFx1MDUxMlxcdTA1MTRcXHUwNTE2XFx1MDUxOFxcdTA1MUFcXHUwNTFDXFx1MDUxRVxcdTA1MjBcXHUwNTIyXFx1MDUyNFxcdTA1MjZcXHUwNTI4XFx1MDUyQVxcdTA1MkNcXHUwNTJFXFx1MDUzMS1cXHUwNTU2XFx1MTBBMC1cXHUxMEM1XFx1MTBDN1xcdTEwQ0RcXHUxM0EwLVxcdTEzRjVcXHUxRTAwXFx1MUUwMlxcdTFFMDRcXHUxRTA2XFx1MUUwOFxcdTFFMEFcXHUxRTBDXFx1MUUwRVxcdTFFMTBcXHUxRTEyXFx1MUUxNFxcdTFFMTZcXHUxRTE4XFx1MUUxQVxcdTFFMUNcXHUxRTFFXFx1MUUyMFxcdTFFMjJcXHUxRTI0XFx1MUUyNlxcdTFFMjhcXHUxRTJBXFx1MUUyQ1xcdTFFMkVcXHUxRTMwXFx1MUUzMlxcdTFFMzRcXHUxRTM2XFx1MUUzOFxcdTFFM0FcXHUxRTNDXFx1MUUzRVxcdTFFNDBcXHUxRTQyXFx1MUU0NFxcdTFFNDZcXHUxRTQ4XFx1MUU0QVxcdTFFNENcXHUxRTRFXFx1MUU1MFxcdTFFNTJcXHUxRTU0XFx1MUU1NlxcdTFFNThcXHUxRTVBXFx1MUU1Q1xcdTFFNUVcXHUxRTYwXFx1MUU2MlxcdTFFNjRcXHUxRTY2XFx1MUU2OFxcdTFFNkFcXHUxRTZDXFx1MUU2RVxcdTFFNzBcXHUxRTcyXFx1MUU3NFxcdTFFNzZcXHUxRTc4XFx1MUU3QVxcdTFFN0NcXHUxRTdFXFx1MUU4MFxcdTFFODJcXHUxRTg0XFx1MUU4NlxcdTFFODhcXHUxRThBXFx1MUU4Q1xcdTFFOEVcXHUxRTkwXFx1MUU5MlxcdTFFOTRcXHUxRTlFXFx1MUVBMFxcdTFFQTJcXHUxRUE0XFx1MUVBNlxcdTFFQThcXHUxRUFBXFx1MUVBQ1xcdTFFQUVcXHUxRUIwXFx1MUVCMlxcdTFFQjRcXHUxRUI2XFx1MUVCOFxcdTFFQkFcXHUxRUJDXFx1MUVCRVxcdTFFQzBcXHUxRUMyXFx1MUVDNFxcdTFFQzZcXHUxRUM4XFx1MUVDQVxcdTFFQ0NcXHUxRUNFXFx1MUVEMFxcdTFFRDJcXHUxRUQ0XFx1MUVENlxcdTFFRDhcXHUxRURBXFx1MUVEQ1xcdTFFREVcXHUxRUUwXFx1MUVFMlxcdTFFRTRcXHUxRUU2XFx1MUVFOFxcdTFFRUFcXHUxRUVDXFx1MUVFRVxcdTFFRjBcXHUxRUYyXFx1MUVGNFxcdTFFRjZcXHUxRUY4XFx1MUVGQVxcdTFFRkNcXHUxRUZFXFx1MUYwOC1cXHUxRjBGXFx1MUYxOC1cXHUxRjFEXFx1MUYyOC1cXHUxRjJGXFx1MUYzOC1cXHUxRjNGXFx1MUY0OC1cXHUxRjREXFx1MUY1OVxcdTFGNUJcXHUxRjVEXFx1MUY1RlxcdTFGNjgtXFx1MUY2RlxcdTFGQjgtXFx1MUZCQlxcdTFGQzgtXFx1MUZDQlxcdTFGRDgtXFx1MUZEQlxcdTFGRTgtXFx1MUZFQ1xcdTFGRjgtXFx1MUZGQlxcdTIxMDJcXHUyMTA3XFx1MjEwQi1cXHUyMTBEXFx1MjExMC1cXHUyMTEyXFx1MjExNVxcdTIxMTktXFx1MjExRFxcdTIxMjRcXHUyMTI2XFx1MjEyOFxcdTIxMkEtXFx1MjEyRFxcdTIxMzAtXFx1MjEzM1xcdTIxM0VcXHUyMTNGXFx1MjE0NVxcdTIxODNcXHUyQzAwLVxcdTJDMkVcXHUyQzYwXFx1MkM2Mi1cXHUyQzY0XFx1MkM2N1xcdTJDNjlcXHUyQzZCXFx1MkM2RC1cXHUyQzcwXFx1MkM3MlxcdTJDNzVcXHUyQzdFLVxcdTJDODBcXHUyQzgyXFx1MkM4NFxcdTJDODZcXHUyQzg4XFx1MkM4QVxcdTJDOENcXHUyQzhFXFx1MkM5MFxcdTJDOTJcXHUyQzk0XFx1MkM5NlxcdTJDOThcXHUyQzlBXFx1MkM5Q1xcdTJDOUVcXHUyQ0EwXFx1MkNBMlxcdTJDQTRcXHUyQ0E2XFx1MkNBOFxcdTJDQUFcXHUyQ0FDXFx1MkNBRVxcdTJDQjBcXHUyQ0IyXFx1MkNCNFxcdTJDQjZcXHUyQ0I4XFx1MkNCQVxcdTJDQkNcXHUyQ0JFXFx1MkNDMFxcdTJDQzJcXHUyQ0M0XFx1MkNDNlxcdTJDQzhcXHUyQ0NBXFx1MkNDQ1xcdTJDQ0VcXHUyQ0QwXFx1MkNEMlxcdTJDRDRcXHUyQ0Q2XFx1MkNEOFxcdTJDREFcXHUyQ0RDXFx1MkNERVxcdTJDRTBcXHUyQ0UyXFx1MkNFQlxcdTJDRURcXHUyQ0YyXFx1QTY0MFxcdUE2NDJcXHVBNjQ0XFx1QTY0NlxcdUE2NDhcXHVBNjRBXFx1QTY0Q1xcdUE2NEVcXHVBNjUwXFx1QTY1MlxcdUE2NTRcXHVBNjU2XFx1QTY1OFxcdUE2NUFcXHVBNjVDXFx1QTY1RVxcdUE2NjBcXHVBNjYyXFx1QTY2NFxcdUE2NjZcXHVBNjY4XFx1QTY2QVxcdUE2NkNcXHVBNjgwXFx1QTY4MlxcdUE2ODRcXHVBNjg2XFx1QTY4OFxcdUE2OEFcXHVBNjhDXFx1QTY4RVxcdUE2OTBcXHVBNjkyXFx1QTY5NFxcdUE2OTZcXHVBNjk4XFx1QTY5QVxcdUE3MjJcXHVBNzI0XFx1QTcyNlxcdUE3MjhcXHVBNzJBXFx1QTcyQ1xcdUE3MkVcXHVBNzMyXFx1QTczNFxcdUE3MzZcXHVBNzM4XFx1QTczQVxcdUE3M0NcXHVBNzNFXFx1QTc0MFxcdUE3NDJcXHVBNzQ0XFx1QTc0NlxcdUE3NDhcXHVBNzRBXFx1QTc0Q1xcdUE3NEVcXHVBNzUwXFx1QTc1MlxcdUE3NTRcXHVBNzU2XFx1QTc1OFxcdUE3NUFcXHVBNzVDXFx1QTc1RVxcdUE3NjBcXHVBNzYyXFx1QTc2NFxcdUE3NjZcXHVBNzY4XFx1QTc2QVxcdUE3NkNcXHVBNzZFXFx1QTc3OVxcdUE3N0JcXHVBNzdEXFx1QTc3RVxcdUE3ODBcXHVBNzgyXFx1QTc4NFxcdUE3ODZcXHVBNzhCXFx1QTc4RFxcdUE3OTBcXHVBNzkyXFx1QTc5NlxcdUE3OThcXHVBNzlBXFx1QTc5Q1xcdUE3OUVcXHVBN0EwXFx1QTdBMlxcdUE3QTRcXHVBN0E2XFx1QTdBOFxcdUE3QUEtXFx1QTdBRFxcdUE3QjAtXFx1QTdCNFxcdUE3QjZcXHVGRjIxLVxcdUZGM0EnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwNltcXHVEQ0EwLVxcdURDQkZdfFxcdUQ4MDNbXFx1REM4MC1cXHVEQ0IyXXxcXHVEODAxW1xcdURDMDAtXFx1REMyN118XFx1RDgzNVtcXHVEQzAwLVxcdURDMTlcXHVEQzM0LVxcdURDNERcXHVEQzY4LVxcdURDODFcXHVEQzlDXFx1REM5RVxcdURDOUZcXHVEQ0EyXFx1RENBNVxcdURDQTZcXHVEQ0E5LVxcdURDQUNcXHVEQ0FFLVxcdURDQjVcXHVEQ0QwLVxcdURDRTlcXHVERDA0XFx1REQwNVxcdUREMDctXFx1REQwQVxcdUREMEQtXFx1REQxNFxcdUREMTYtXFx1REQxQ1xcdUREMzhcXHVERDM5XFx1REQzQi1cXHVERDNFXFx1REQ0MC1cXHVERDQ0XFx1REQ0NlxcdURENEEtXFx1REQ1MFxcdURENkMtXFx1REQ4NVxcdUREQTAtXFx1RERCOVxcdURERDQtXFx1RERFRFxcdURFMDgtXFx1REUyMVxcdURFM0MtXFx1REU1NVxcdURFNzAtXFx1REU4OVxcdURFQTgtXFx1REVDMFxcdURFRTItXFx1REVGQVxcdURGMUMtXFx1REYzNFxcdURGNTYtXFx1REY2RVxcdURGOTAtXFx1REZBOFxcdURGQ0FdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnTScsXG4gICAgICAgICAgICBhbGlhczogJ01hcmsnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MDMwMC1cXHUwMzZGXFx1MDQ4My1cXHUwNDg5XFx1MDU5MS1cXHUwNUJEXFx1MDVCRlxcdTA1QzFcXHUwNUMyXFx1MDVDNFxcdTA1QzVcXHUwNUM3XFx1MDYxMC1cXHUwNjFBXFx1MDY0Qi1cXHUwNjVGXFx1MDY3MFxcdTA2RDYtXFx1MDZEQ1xcdTA2REYtXFx1MDZFNFxcdTA2RTdcXHUwNkU4XFx1MDZFQS1cXHUwNkVEXFx1MDcxMVxcdTA3MzAtXFx1MDc0QVxcdTA3QTYtXFx1MDdCMFxcdTA3RUItXFx1MDdGM1xcdTA4MTYtXFx1MDgxOVxcdTA4MUItXFx1MDgyM1xcdTA4MjUtXFx1MDgyN1xcdTA4MjktXFx1MDgyRFxcdTA4NTktXFx1MDg1QlxcdTA4RTMtXFx1MDkwM1xcdTA5M0EtXFx1MDkzQ1xcdTA5M0UtXFx1MDk0RlxcdTA5NTEtXFx1MDk1N1xcdTA5NjJcXHUwOTYzXFx1MDk4MS1cXHUwOTgzXFx1MDlCQ1xcdTA5QkUtXFx1MDlDNFxcdTA5QzdcXHUwOUM4XFx1MDlDQi1cXHUwOUNEXFx1MDlEN1xcdTA5RTJcXHUwOUUzXFx1MEEwMS1cXHUwQTAzXFx1MEEzQ1xcdTBBM0UtXFx1MEE0MlxcdTBBNDdcXHUwQTQ4XFx1MEE0Qi1cXHUwQTREXFx1MEE1MVxcdTBBNzBcXHUwQTcxXFx1MEE3NVxcdTBBODEtXFx1MEE4M1xcdTBBQkNcXHUwQUJFLVxcdTBBQzVcXHUwQUM3LVxcdTBBQzlcXHUwQUNCLVxcdTBBQ0RcXHUwQUUyXFx1MEFFM1xcdTBCMDEtXFx1MEIwM1xcdTBCM0NcXHUwQjNFLVxcdTBCNDRcXHUwQjQ3XFx1MEI0OFxcdTBCNEItXFx1MEI0RFxcdTBCNTZcXHUwQjU3XFx1MEI2MlxcdTBCNjNcXHUwQjgyXFx1MEJCRS1cXHUwQkMyXFx1MEJDNi1cXHUwQkM4XFx1MEJDQS1cXHUwQkNEXFx1MEJEN1xcdTBDMDAtXFx1MEMwM1xcdTBDM0UtXFx1MEM0NFxcdTBDNDYtXFx1MEM0OFxcdTBDNEEtXFx1MEM0RFxcdTBDNTVcXHUwQzU2XFx1MEM2MlxcdTBDNjNcXHUwQzgxLVxcdTBDODNcXHUwQ0JDXFx1MENCRS1cXHUwQ0M0XFx1MENDNi1cXHUwQ0M4XFx1MENDQS1cXHUwQ0NEXFx1MENENVxcdTBDRDZcXHUwQ0UyXFx1MENFM1xcdTBEMDEtXFx1MEQwM1xcdTBEM0UtXFx1MEQ0NFxcdTBENDYtXFx1MEQ0OFxcdTBENEEtXFx1MEQ0RFxcdTBENTdcXHUwRDYyXFx1MEQ2M1xcdTBEODJcXHUwRDgzXFx1MERDQVxcdTBEQ0YtXFx1MERENFxcdTBERDZcXHUwREQ4LVxcdTBEREZcXHUwREYyXFx1MERGM1xcdTBFMzFcXHUwRTM0LVxcdTBFM0FcXHUwRTQ3LVxcdTBFNEVcXHUwRUIxXFx1MEVCNC1cXHUwRUI5XFx1MEVCQlxcdTBFQkNcXHUwRUM4LVxcdTBFQ0RcXHUwRjE4XFx1MEYxOVxcdTBGMzVcXHUwRjM3XFx1MEYzOVxcdTBGM0VcXHUwRjNGXFx1MEY3MS1cXHUwRjg0XFx1MEY4NlxcdTBGODdcXHUwRjhELVxcdTBGOTdcXHUwRjk5LVxcdTBGQkNcXHUwRkM2XFx1MTAyQi1cXHUxMDNFXFx1MTA1Ni1cXHUxMDU5XFx1MTA1RS1cXHUxMDYwXFx1MTA2Mi1cXHUxMDY0XFx1MTA2Ny1cXHUxMDZEXFx1MTA3MS1cXHUxMDc0XFx1MTA4Mi1cXHUxMDhEXFx1MTA4RlxcdTEwOUEtXFx1MTA5RFxcdTEzNUQtXFx1MTM1RlxcdTE3MTItXFx1MTcxNFxcdTE3MzItXFx1MTczNFxcdTE3NTJcXHUxNzUzXFx1MTc3MlxcdTE3NzNcXHUxN0I0LVxcdTE3RDNcXHUxN0REXFx1MTgwQi1cXHUxODBEXFx1MThBOVxcdTE5MjAtXFx1MTkyQlxcdTE5MzAtXFx1MTkzQlxcdTFBMTctXFx1MUExQlxcdTFBNTUtXFx1MUE1RVxcdTFBNjAtXFx1MUE3Q1xcdTFBN0ZcXHUxQUIwLVxcdTFBQkVcXHUxQjAwLVxcdTFCMDRcXHUxQjM0LVxcdTFCNDRcXHUxQjZCLVxcdTFCNzNcXHUxQjgwLVxcdTFCODJcXHUxQkExLVxcdTFCQURcXHUxQkU2LVxcdTFCRjNcXHUxQzI0LVxcdTFDMzdcXHUxQ0QwLVxcdTFDRDJcXHUxQ0Q0LVxcdTFDRThcXHUxQ0VEXFx1MUNGMi1cXHUxQ0Y0XFx1MUNGOFxcdTFDRjlcXHUxREMwLVxcdTFERjVcXHUxREZDLVxcdTFERkZcXHUyMEQwLVxcdTIwRjBcXHUyQ0VGLVxcdTJDRjFcXHUyRDdGXFx1MkRFMC1cXHUyREZGXFx1MzAyQS1cXHUzMDJGXFx1MzA5OVxcdTMwOUFcXHVBNjZGLVxcdUE2NzJcXHVBNjc0LVxcdUE2N0RcXHVBNjlFXFx1QTY5RlxcdUE2RjBcXHVBNkYxXFx1QTgwMlxcdUE4MDZcXHVBODBCXFx1QTgyMy1cXHVBODI3XFx1QTg4MFxcdUE4ODFcXHVBOEI0LVxcdUE4QzRcXHVBOEUwLVxcdUE4RjFcXHVBOTI2LVxcdUE5MkRcXHVBOTQ3LVxcdUE5NTNcXHVBOTgwLVxcdUE5ODNcXHVBOUIzLVxcdUE5QzBcXHVBOUU1XFx1QUEyOS1cXHVBQTM2XFx1QUE0M1xcdUFBNENcXHVBQTREXFx1QUE3Qi1cXHVBQTdEXFx1QUFCMFxcdUFBQjItXFx1QUFCNFxcdUFBQjdcXHVBQUI4XFx1QUFCRVxcdUFBQkZcXHVBQUMxXFx1QUFFQi1cXHVBQUVGXFx1QUFGNVxcdUFBRjZcXHVBQkUzLVxcdUFCRUFcXHVBQkVDXFx1QUJFRFxcdUZCMUVcXHVGRTAwLVxcdUZFMEZcXHVGRTIwLVxcdUZFMkYnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwNVtcXHVEQ0IwLVxcdURDQzNcXHVEREFGLVxcdUREQjVcXHVEREI4LVxcdUREQzBcXHVERERDXFx1RERERFxcdURFMzAtXFx1REU0MFxcdURFQUItXFx1REVCN1xcdURGMUQtXFx1REYyQl18XFx1RDgzNFtcXHVERDY1LVxcdURENjlcXHVERDZELVxcdURENzJcXHVERDdCLVxcdUREODJcXHVERDg1LVxcdUREOEJcXHVEREFBLVxcdUREQURcXHVERTQyLVxcdURFNDRdfFxcdUQ4MDRbXFx1REMwMC1cXHVEQzAyXFx1REMzOC1cXHVEQzQ2XFx1REM3Ri1cXHVEQzgyXFx1RENCMC1cXHVEQ0JBXFx1REQwMC1cXHVERDAyXFx1REQyNy1cXHVERDM0XFx1REQ3M1xcdUREODAtXFx1REQ4MlxcdUREQjMtXFx1RERDMFxcdUREQ0EtXFx1RERDQ1xcdURFMkMtXFx1REUzN1xcdURFREYtXFx1REVFQVxcdURGMDAtXFx1REYwM1xcdURGM0NcXHVERjNFLVxcdURGNDRcXHVERjQ3XFx1REY0OFxcdURGNEItXFx1REY0RFxcdURGNTdcXHVERjYyXFx1REY2M1xcdURGNjYtXFx1REY2Q1xcdURGNzAtXFx1REY3NF18XFx1RDgxQltcXHVERjUxLVxcdURGN0VcXHVERjhGLVxcdURGOTJdfFxcdUQ4MUFbXFx1REVGMC1cXHVERUY0XFx1REYzMC1cXHVERjM2XXxcXHVEODJGW1xcdURDOURcXHVEQzlFXXxcXHVEODAwW1xcdURERkRcXHVERUUwXFx1REY3Ni1cXHVERjdBXXxcXHVEODM2W1xcdURFMDAtXFx1REUzNlxcdURFM0ItXFx1REU2Q1xcdURFNzVcXHVERTg0XFx1REU5Qi1cXHVERTlGXFx1REVBMS1cXHVERUFGXXxcXHVEODAyW1xcdURFMDEtXFx1REUwM1xcdURFMDVcXHVERTA2XFx1REUwQy1cXHVERTBGXFx1REUzOC1cXHVERTNBXFx1REUzRlxcdURFRTVcXHVERUU2XXxcXHVEODNBW1xcdURDRDAtXFx1RENENl18XFx1REI0MFtcXHVERDAwLVxcdURERUZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnTWMnLFxuICAgICAgICAgICAgYWxpYXM6ICdTcGFjaW5nX01hcmsnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MDkwM1xcdTA5M0JcXHUwOTNFLVxcdTA5NDBcXHUwOTQ5LVxcdTA5NENcXHUwOTRFXFx1MDk0RlxcdTA5ODJcXHUwOTgzXFx1MDlCRS1cXHUwOUMwXFx1MDlDN1xcdTA5QzhcXHUwOUNCXFx1MDlDQ1xcdTA5RDdcXHUwQTAzXFx1MEEzRS1cXHUwQTQwXFx1MEE4M1xcdTBBQkUtXFx1MEFDMFxcdTBBQzlcXHUwQUNCXFx1MEFDQ1xcdTBCMDJcXHUwQjAzXFx1MEIzRVxcdTBCNDBcXHUwQjQ3XFx1MEI0OFxcdTBCNEJcXHUwQjRDXFx1MEI1N1xcdTBCQkVcXHUwQkJGXFx1MEJDMVxcdTBCQzJcXHUwQkM2LVxcdTBCQzhcXHUwQkNBLVxcdTBCQ0NcXHUwQkQ3XFx1MEMwMS1cXHUwQzAzXFx1MEM0MS1cXHUwQzQ0XFx1MEM4MlxcdTBDODNcXHUwQ0JFXFx1MENDMC1cXHUwQ0M0XFx1MENDN1xcdTBDQzhcXHUwQ0NBXFx1MENDQlxcdTBDRDVcXHUwQ0Q2XFx1MEQwMlxcdTBEMDNcXHUwRDNFLVxcdTBENDBcXHUwRDQ2LVxcdTBENDhcXHUwRDRBLVxcdTBENENcXHUwRDU3XFx1MEQ4MlxcdTBEODNcXHUwRENGLVxcdTBERDFcXHUwREQ4LVxcdTBEREZcXHUwREYyXFx1MERGM1xcdTBGM0VcXHUwRjNGXFx1MEY3RlxcdTEwMkJcXHUxMDJDXFx1MTAzMVxcdTEwMzhcXHUxMDNCXFx1MTAzQ1xcdTEwNTZcXHUxMDU3XFx1MTA2Mi1cXHUxMDY0XFx1MTA2Ny1cXHUxMDZEXFx1MTA4M1xcdTEwODRcXHUxMDg3LVxcdTEwOENcXHUxMDhGXFx1MTA5QS1cXHUxMDlDXFx1MTdCNlxcdTE3QkUtXFx1MTdDNVxcdTE3QzdcXHUxN0M4XFx1MTkyMy1cXHUxOTI2XFx1MTkyOS1cXHUxOTJCXFx1MTkzMFxcdTE5MzFcXHUxOTMzLVxcdTE5MzhcXHUxQTE5XFx1MUExQVxcdTFBNTVcXHUxQTU3XFx1MUE2MVxcdTFBNjNcXHUxQTY0XFx1MUE2RC1cXHUxQTcyXFx1MUIwNFxcdTFCMzVcXHUxQjNCXFx1MUIzRC1cXHUxQjQxXFx1MUI0M1xcdTFCNDRcXHUxQjgyXFx1MUJBMVxcdTFCQTZcXHUxQkE3XFx1MUJBQVxcdTFCRTdcXHUxQkVBLVxcdTFCRUNcXHUxQkVFXFx1MUJGMlxcdTFCRjNcXHUxQzI0LVxcdTFDMkJcXHUxQzM0XFx1MUMzNVxcdTFDRTFcXHUxQ0YyXFx1MUNGM1xcdTMwMkVcXHUzMDJGXFx1QTgyM1xcdUE4MjRcXHVBODI3XFx1QTg4MFxcdUE4ODFcXHVBOEI0LVxcdUE4QzNcXHVBOTUyXFx1QTk1M1xcdUE5ODNcXHVBOUI0XFx1QTlCNVxcdUE5QkFcXHVBOUJCXFx1QTlCRC1cXHVBOUMwXFx1QUEyRlxcdUFBMzBcXHVBQTMzXFx1QUEzNFxcdUFBNERcXHVBQTdCXFx1QUE3RFxcdUFBRUJcXHVBQUVFXFx1QUFFRlxcdUFBRjVcXHVBQkUzXFx1QUJFNFxcdUFCRTZcXHVBQkU3XFx1QUJFOVxcdUFCRUFcXHVBQkVDJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MzRbXFx1REQ2NVxcdURENjZcXHVERDZELVxcdURENzJdfFxcdUQ4MDRbXFx1REMwMFxcdURDMDJcXHVEQzgyXFx1RENCMC1cXHVEQ0IyXFx1RENCN1xcdURDQjhcXHVERDJDXFx1REQ4MlxcdUREQjMtXFx1RERCNVxcdUREQkZcXHVEREMwXFx1REUyQy1cXHVERTJFXFx1REUzMlxcdURFMzNcXHVERTM1XFx1REVFMC1cXHVERUUyXFx1REYwMlxcdURGMDNcXHVERjNFXFx1REYzRlxcdURGNDEtXFx1REY0NFxcdURGNDdcXHVERjQ4XFx1REY0Qi1cXHVERjREXFx1REY1N1xcdURGNjJcXHVERjYzXXxcXHVEODA1W1xcdURDQjAtXFx1RENCMlxcdURDQjlcXHVEQ0JCLVxcdURDQkVcXHVEQ0MxXFx1RERBRi1cXHVEREIxXFx1RERCOC1cXHVEREJCXFx1RERCRVxcdURFMzAtXFx1REUzMlxcdURFM0JcXHVERTNDXFx1REUzRVxcdURFQUNcXHVERUFFXFx1REVBRlxcdURFQjZcXHVERjIwXFx1REYyMVxcdURGMjZdfFxcdUQ4MUJbXFx1REY1MS1cXHVERjdFXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ01lJyxcbiAgICAgICAgICAgIGFsaWFzOiAnRW5jbG9zaW5nX01hcmsnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MDQ4OFxcdTA0ODlcXHUxQUJFXFx1MjBERC1cXHUyMEUwXFx1MjBFMi1cXHUyMEU0XFx1QTY3MC1cXHVBNjcyJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnTW4nLFxuICAgICAgICAgICAgYWxpYXM6ICdOb25zcGFjaW5nX01hcmsnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MDMwMC1cXHUwMzZGXFx1MDQ4My1cXHUwNDg3XFx1MDU5MS1cXHUwNUJEXFx1MDVCRlxcdTA1QzFcXHUwNUMyXFx1MDVDNFxcdTA1QzVcXHUwNUM3XFx1MDYxMC1cXHUwNjFBXFx1MDY0Qi1cXHUwNjVGXFx1MDY3MFxcdTA2RDYtXFx1MDZEQ1xcdTA2REYtXFx1MDZFNFxcdTA2RTdcXHUwNkU4XFx1MDZFQS1cXHUwNkVEXFx1MDcxMVxcdTA3MzAtXFx1MDc0QVxcdTA3QTYtXFx1MDdCMFxcdTA3RUItXFx1MDdGM1xcdTA4MTYtXFx1MDgxOVxcdTA4MUItXFx1MDgyM1xcdTA4MjUtXFx1MDgyN1xcdTA4MjktXFx1MDgyRFxcdTA4NTktXFx1MDg1QlxcdTA4RTMtXFx1MDkwMlxcdTA5M0FcXHUwOTNDXFx1MDk0MS1cXHUwOTQ4XFx1MDk0RFxcdTA5NTEtXFx1MDk1N1xcdTA5NjJcXHUwOTYzXFx1MDk4MVxcdTA5QkNcXHUwOUMxLVxcdTA5QzRcXHUwOUNEXFx1MDlFMlxcdTA5RTNcXHUwQTAxXFx1MEEwMlxcdTBBM0NcXHUwQTQxXFx1MEE0MlxcdTBBNDdcXHUwQTQ4XFx1MEE0Qi1cXHUwQTREXFx1MEE1MVxcdTBBNzBcXHUwQTcxXFx1MEE3NVxcdTBBODFcXHUwQTgyXFx1MEFCQ1xcdTBBQzEtXFx1MEFDNVxcdTBBQzdcXHUwQUM4XFx1MEFDRFxcdTBBRTJcXHUwQUUzXFx1MEIwMVxcdTBCM0NcXHUwQjNGXFx1MEI0MS1cXHUwQjQ0XFx1MEI0RFxcdTBCNTZcXHUwQjYyXFx1MEI2M1xcdTBCODJcXHUwQkMwXFx1MEJDRFxcdTBDMDBcXHUwQzNFLVxcdTBDNDBcXHUwQzQ2LVxcdTBDNDhcXHUwQzRBLVxcdTBDNERcXHUwQzU1XFx1MEM1NlxcdTBDNjJcXHUwQzYzXFx1MEM4MVxcdTBDQkNcXHUwQ0JGXFx1MENDNlxcdTBDQ0NcXHUwQ0NEXFx1MENFMlxcdTBDRTNcXHUwRDAxXFx1MEQ0MS1cXHUwRDQ0XFx1MEQ0RFxcdTBENjJcXHUwRDYzXFx1MERDQVxcdTBERDItXFx1MERENFxcdTBERDZcXHUwRTMxXFx1MEUzNC1cXHUwRTNBXFx1MEU0Ny1cXHUwRTRFXFx1MEVCMVxcdTBFQjQtXFx1MEVCOVxcdTBFQkJcXHUwRUJDXFx1MEVDOC1cXHUwRUNEXFx1MEYxOFxcdTBGMTlcXHUwRjM1XFx1MEYzN1xcdTBGMzlcXHUwRjcxLVxcdTBGN0VcXHUwRjgwLVxcdTBGODRcXHUwRjg2XFx1MEY4N1xcdTBGOEQtXFx1MEY5N1xcdTBGOTktXFx1MEZCQ1xcdTBGQzZcXHUxMDJELVxcdTEwMzBcXHUxMDMyLVxcdTEwMzdcXHUxMDM5XFx1MTAzQVxcdTEwM0RcXHUxMDNFXFx1MTA1OFxcdTEwNTlcXHUxMDVFLVxcdTEwNjBcXHUxMDcxLVxcdTEwNzRcXHUxMDgyXFx1MTA4NVxcdTEwODZcXHUxMDhEXFx1MTA5RFxcdTEzNUQtXFx1MTM1RlxcdTE3MTItXFx1MTcxNFxcdTE3MzItXFx1MTczNFxcdTE3NTJcXHUxNzUzXFx1MTc3MlxcdTE3NzNcXHUxN0I0XFx1MTdCNVxcdTE3QjctXFx1MTdCRFxcdTE3QzZcXHUxN0M5LVxcdTE3RDNcXHUxN0REXFx1MTgwQi1cXHUxODBEXFx1MThBOVxcdTE5MjAtXFx1MTkyMlxcdTE5MjdcXHUxOTI4XFx1MTkzMlxcdTE5MzktXFx1MTkzQlxcdTFBMTdcXHUxQTE4XFx1MUExQlxcdTFBNTZcXHUxQTU4LVxcdTFBNUVcXHUxQTYwXFx1MUE2MlxcdTFBNjUtXFx1MUE2Q1xcdTFBNzMtXFx1MUE3Q1xcdTFBN0ZcXHUxQUIwLVxcdTFBQkRcXHUxQjAwLVxcdTFCMDNcXHUxQjM0XFx1MUIzNi1cXHUxQjNBXFx1MUIzQ1xcdTFCNDJcXHUxQjZCLVxcdTFCNzNcXHUxQjgwXFx1MUI4MVxcdTFCQTItXFx1MUJBNVxcdTFCQThcXHUxQkE5XFx1MUJBQi1cXHUxQkFEXFx1MUJFNlxcdTFCRThcXHUxQkU5XFx1MUJFRFxcdTFCRUYtXFx1MUJGMVxcdTFDMkMtXFx1MUMzM1xcdTFDMzZcXHUxQzM3XFx1MUNEMC1cXHUxQ0QyXFx1MUNENC1cXHUxQ0UwXFx1MUNFMi1cXHUxQ0U4XFx1MUNFRFxcdTFDRjRcXHUxQ0Y4XFx1MUNGOVxcdTFEQzAtXFx1MURGNVxcdTFERkMtXFx1MURGRlxcdTIwRDAtXFx1MjBEQ1xcdTIwRTFcXHUyMEU1LVxcdTIwRjBcXHUyQ0VGLVxcdTJDRjFcXHUyRDdGXFx1MkRFMC1cXHUyREZGXFx1MzAyQS1cXHUzMDJEXFx1MzA5OVxcdTMwOUFcXHVBNjZGXFx1QTY3NC1cXHVBNjdEXFx1QTY5RVxcdUE2OUZcXHVBNkYwXFx1QTZGMVxcdUE4MDJcXHVBODA2XFx1QTgwQlxcdUE4MjVcXHVBODI2XFx1QThDNFxcdUE4RTAtXFx1QThGMVxcdUE5MjYtXFx1QTkyRFxcdUE5NDctXFx1QTk1MVxcdUE5ODAtXFx1QTk4MlxcdUE5QjNcXHVBOUI2LVxcdUE5QjlcXHVBOUJDXFx1QTlFNVxcdUFBMjktXFx1QUEyRVxcdUFBMzFcXHVBQTMyXFx1QUEzNVxcdUFBMzZcXHVBQTQzXFx1QUE0Q1xcdUFBN0NcXHVBQUIwXFx1QUFCMi1cXHVBQUI0XFx1QUFCN1xcdUFBQjhcXHVBQUJFXFx1QUFCRlxcdUFBQzFcXHVBQUVDXFx1QUFFRFxcdUFBRjZcXHVBQkU1XFx1QUJFOFxcdUFCRURcXHVGQjFFXFx1RkUwMC1cXHVGRTBGXFx1RkUyMC1cXHVGRTJGJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDVbXFx1RENCMy1cXHVEQ0I4XFx1RENCQVxcdURDQkZcXHVEQ0MwXFx1RENDMlxcdURDQzNcXHVEREIyLVxcdUREQjVcXHVEREJDXFx1RERCRFxcdUREQkZcXHVEREMwXFx1REREQ1xcdURERERcXHVERTMzLVxcdURFM0FcXHVERTNEXFx1REUzRlxcdURFNDBcXHVERUFCXFx1REVBRFxcdURFQjAtXFx1REVCNVxcdURFQjdcXHVERjFELVxcdURGMUZcXHVERjIyLVxcdURGMjVcXHVERjI3LVxcdURGMkJdfFxcdUQ4MzRbXFx1REQ2Ny1cXHVERDY5XFx1REQ3Qi1cXHVERDgyXFx1REQ4NS1cXHVERDhCXFx1RERBQS1cXHVEREFEXFx1REU0Mi1cXHVERTQ0XXxcXHVEODFBW1xcdURFRjAtXFx1REVGNFxcdURGMzAtXFx1REYzNl18XFx1RDgxQltcXHVERjhGLVxcdURGOTJdfFxcdUQ4MkZbXFx1REM5RFxcdURDOUVdfFxcdUQ4MDBbXFx1RERGRFxcdURFRTBcXHVERjc2LVxcdURGN0FdfFxcdUQ4MzZbXFx1REUwMC1cXHVERTM2XFx1REUzQi1cXHVERTZDXFx1REU3NVxcdURFODRcXHVERTlCLVxcdURFOUZcXHVERUExLVxcdURFQUZdfFxcdUQ4MDJbXFx1REUwMS1cXHVERTAzXFx1REUwNVxcdURFMDZcXHVERTBDLVxcdURFMEZcXHVERTM4LVxcdURFM0FcXHVERTNGXFx1REVFNVxcdURFRTZdfFxcdUQ4MDRbXFx1REMwMVxcdURDMzgtXFx1REM0NlxcdURDN0YtXFx1REM4MVxcdURDQjMtXFx1RENCNlxcdURDQjlcXHVEQ0JBXFx1REQwMC1cXHVERDAyXFx1REQyNy1cXHVERDJCXFx1REQyRC1cXHVERDM0XFx1REQ3M1xcdUREODBcXHVERDgxXFx1RERCNi1cXHVEREJFXFx1RERDQS1cXHVERENDXFx1REUyRi1cXHVERTMxXFx1REUzNFxcdURFMzZcXHVERTM3XFx1REVERlxcdURFRTMtXFx1REVFQVxcdURGMDBcXHVERjAxXFx1REYzQ1xcdURGNDBcXHVERjY2LVxcdURGNkNcXHVERjcwLVxcdURGNzRdfFxcdUQ4M0FbXFx1RENEMC1cXHVEQ0Q2XXxcXHVEQjQwW1xcdUREMDAtXFx1RERFRl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdOJyxcbiAgICAgICAgICAgIGFsaWFzOiAnTnVtYmVyJyxcbiAgICAgICAgICAgIGJtcDogJzAtOVxceEIyXFx4QjNcXHhCOVxceEJDLVxceEJFXFx1MDY2MC1cXHUwNjY5XFx1MDZGMC1cXHUwNkY5XFx1MDdDMC1cXHUwN0M5XFx1MDk2Ni1cXHUwOTZGXFx1MDlFNi1cXHUwOUVGXFx1MDlGNC1cXHUwOUY5XFx1MEE2Ni1cXHUwQTZGXFx1MEFFNi1cXHUwQUVGXFx1MEI2Ni1cXHUwQjZGXFx1MEI3Mi1cXHUwQjc3XFx1MEJFNi1cXHUwQkYyXFx1MEM2Ni1cXHUwQzZGXFx1MEM3OC1cXHUwQzdFXFx1MENFNi1cXHUwQ0VGXFx1MEQ2Ni1cXHUwRDc1XFx1MERFNi1cXHUwREVGXFx1MEU1MC1cXHUwRTU5XFx1MEVEMC1cXHUwRUQ5XFx1MEYyMC1cXHUwRjMzXFx1MTA0MC1cXHUxMDQ5XFx1MTA5MC1cXHUxMDk5XFx1MTM2OS1cXHUxMzdDXFx1MTZFRS1cXHUxNkYwXFx1MTdFMC1cXHUxN0U5XFx1MTdGMC1cXHUxN0Y5XFx1MTgxMC1cXHUxODE5XFx1MTk0Ni1cXHUxOTRGXFx1MTlEMC1cXHUxOURBXFx1MUE4MC1cXHUxQTg5XFx1MUE5MC1cXHUxQTk5XFx1MUI1MC1cXHUxQjU5XFx1MUJCMC1cXHUxQkI5XFx1MUM0MC1cXHUxQzQ5XFx1MUM1MC1cXHUxQzU5XFx1MjA3MFxcdTIwNzQtXFx1MjA3OVxcdTIwODAtXFx1MjA4OVxcdTIxNTAtXFx1MjE4MlxcdTIxODUtXFx1MjE4OVxcdTI0NjAtXFx1MjQ5QlxcdTI0RUEtXFx1MjRGRlxcdTI3NzYtXFx1Mjc5M1xcdTJDRkRcXHUzMDA3XFx1MzAyMS1cXHUzMDI5XFx1MzAzOC1cXHUzMDNBXFx1MzE5Mi1cXHUzMTk1XFx1MzIyMC1cXHUzMjI5XFx1MzI0OC1cXHUzMjRGXFx1MzI1MS1cXHUzMjVGXFx1MzI4MC1cXHUzMjg5XFx1MzJCMS1cXHUzMkJGXFx1QTYyMC1cXHVBNjI5XFx1QTZFNi1cXHVBNkVGXFx1QTgzMC1cXHVBODM1XFx1QThEMC1cXHVBOEQ5XFx1QTkwMC1cXHVBOTA5XFx1QTlEMC1cXHVBOUQ5XFx1QTlGMC1cXHVBOUY5XFx1QUE1MC1cXHVBQTU5XFx1QUJGMC1cXHVBQkY5XFx1RkYxMC1cXHVGRjE5JyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDBbXFx1REQwNy1cXHVERDMzXFx1REQ0MC1cXHVERDc4XFx1REQ4QVxcdUREOEJcXHVERUUxLVxcdURFRkJcXHVERjIwLVxcdURGMjNcXHVERjQxXFx1REY0QVxcdURGRDEtXFx1REZENV18XFx1RDgwMVtcXHVEQ0EwLVxcdURDQTldfFxcdUQ4MDNbXFx1RENGQS1cXHVEQ0ZGXFx1REU2MC1cXHVERTdFXXxcXHVEODM1W1xcdURGQ0UtXFx1REZGRl18XFx1RDgzQVtcXHVEQ0M3LVxcdURDQ0ZdfFxcdUQ4MUFbXFx1REU2MC1cXHVERTY5XFx1REY1MC1cXHVERjU5XFx1REY1Qi1cXHVERjYxXXxcXHVEODA2W1xcdURDRTAtXFx1RENGMl18XFx1RDgwNFtcXHVEQzUyLVxcdURDNkZcXHVEQ0YwLVxcdURDRjlcXHVERDM2LVxcdUREM0ZcXHVEREQwLVxcdURERDlcXHVEREUxLVxcdURERjRcXHVERUYwLVxcdURFRjldfFxcdUQ4MzRbXFx1REY2MC1cXHVERjcxXXxcXHVEODNDW1xcdUREMDAtXFx1REQwQ118XFx1RDgwOVtcXHVEQzAwLVxcdURDNkVdfFxcdUQ4MDJbXFx1REM1OC1cXHVEQzVGXFx1REM3OS1cXHVEQzdGXFx1RENBNy1cXHVEQ0FGXFx1RENGQi1cXHVEQ0ZGXFx1REQxNi1cXHVERDFCXFx1RERCQ1xcdUREQkRcXHVEREMwLVxcdUREQ0ZcXHVEREQyLVxcdURERkZcXHVERTQwLVxcdURFNDdcXHVERTdEXFx1REU3RVxcdURFOUQtXFx1REU5RlxcdURFRUItXFx1REVFRlxcdURGNTgtXFx1REY1RlxcdURGNzgtXFx1REY3RlxcdURGQTktXFx1REZBRl18XFx1RDgwNVtcXHVEQ0QwLVxcdURDRDlcXHVERTUwLVxcdURFNTlcXHVERUMwLVxcdURFQzlcXHVERjMwLVxcdURGM0JdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnTmQnLFxuICAgICAgICAgICAgYWxpYXM6ICdEZWNpbWFsX051bWJlcicsXG4gICAgICAgICAgICBibXA6ICcwLTlcXHUwNjYwLVxcdTA2NjlcXHUwNkYwLVxcdTA2RjlcXHUwN0MwLVxcdTA3QzlcXHUwOTY2LVxcdTA5NkZcXHUwOUU2LVxcdTA5RUZcXHUwQTY2LVxcdTBBNkZcXHUwQUU2LVxcdTBBRUZcXHUwQjY2LVxcdTBCNkZcXHUwQkU2LVxcdTBCRUZcXHUwQzY2LVxcdTBDNkZcXHUwQ0U2LVxcdTBDRUZcXHUwRDY2LVxcdTBENkZcXHUwREU2LVxcdTBERUZcXHUwRTUwLVxcdTBFNTlcXHUwRUQwLVxcdTBFRDlcXHUwRjIwLVxcdTBGMjlcXHUxMDQwLVxcdTEwNDlcXHUxMDkwLVxcdTEwOTlcXHUxN0UwLVxcdTE3RTlcXHUxODEwLVxcdTE4MTlcXHUxOTQ2LVxcdTE5NEZcXHUxOUQwLVxcdTE5RDlcXHUxQTgwLVxcdTFBODlcXHUxQTkwLVxcdTFBOTlcXHUxQjUwLVxcdTFCNTlcXHUxQkIwLVxcdTFCQjlcXHUxQzQwLVxcdTFDNDlcXHUxQzUwLVxcdTFDNTlcXHVBNjIwLVxcdUE2MjlcXHVBOEQwLVxcdUE4RDlcXHVBOTAwLVxcdUE5MDlcXHVBOUQwLVxcdUE5RDlcXHVBOUYwLVxcdUE5RjlcXHVBQTUwLVxcdUFBNTlcXHVBQkYwLVxcdUFCRjlcXHVGRjEwLVxcdUZGMTknLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMVtcXHVEQ0EwLVxcdURDQTldfFxcdUQ4MzVbXFx1REZDRS1cXHVERkZGXXxcXHVEODA1W1xcdURDRDAtXFx1RENEOVxcdURFNTAtXFx1REU1OVxcdURFQzAtXFx1REVDOVxcdURGMzAtXFx1REYzOV18XFx1RDgwNltcXHVEQ0UwLVxcdURDRTldfFxcdUQ4MDRbXFx1REM2Ni1cXHVEQzZGXFx1RENGMC1cXHVEQ0Y5XFx1REQzNi1cXHVERDNGXFx1REREMC1cXHVEREQ5XFx1REVGMC1cXHVERUY5XXxcXHVEODFBW1xcdURFNjAtXFx1REU2OVxcdURGNTAtXFx1REY1OV0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdObCcsXG4gICAgICAgICAgICBhbGlhczogJ0xldHRlcl9OdW1iZXInLFxuICAgICAgICAgICAgYm1wOiAnXFx1MTZFRS1cXHUxNkYwXFx1MjE2MC1cXHUyMTgyXFx1MjE4NS1cXHUyMTg4XFx1MzAwN1xcdTMwMjEtXFx1MzAyOVxcdTMwMzgtXFx1MzAzQVxcdUE2RTYtXFx1QTZFRicsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODA5W1xcdURDMDAtXFx1REM2RV18XFx1RDgwMFtcXHVERDQwLVxcdURENzRcXHVERjQxXFx1REY0QVxcdURGRDEtXFx1REZENV0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdObycsXG4gICAgICAgICAgICBhbGlhczogJ090aGVyX051bWJlcicsXG4gICAgICAgICAgICBibXA6ICdcXHhCMlxceEIzXFx4QjlcXHhCQy1cXHhCRVxcdTA5RjQtXFx1MDlGOVxcdTBCNzItXFx1MEI3N1xcdTBCRjAtXFx1MEJGMlxcdTBDNzgtXFx1MEM3RVxcdTBENzAtXFx1MEQ3NVxcdTBGMkEtXFx1MEYzM1xcdTEzNjktXFx1MTM3Q1xcdTE3RjAtXFx1MTdGOVxcdTE5REFcXHUyMDcwXFx1MjA3NC1cXHUyMDc5XFx1MjA4MC1cXHUyMDg5XFx1MjE1MC1cXHUyMTVGXFx1MjE4OVxcdTI0NjAtXFx1MjQ5QlxcdTI0RUEtXFx1MjRGRlxcdTI3NzYtXFx1Mjc5M1xcdTJDRkRcXHUzMTkyLVxcdTMxOTVcXHUzMjIwLVxcdTMyMjlcXHUzMjQ4LVxcdTMyNEZcXHUzMjUxLVxcdTMyNUZcXHUzMjgwLVxcdTMyODlcXHUzMkIxLVxcdTMyQkZcXHVBODMwLVxcdUE4MzUnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwNFtcXHVEQzUyLVxcdURDNjVcXHVEREUxLVxcdURERjRdfFxcdUQ4MDNbXFx1RENGQS1cXHVEQ0ZGXFx1REU2MC1cXHVERTdFXXxcXHVEODNDW1xcdUREMDAtXFx1REQwQ118XFx1RDgwNltcXHVEQ0VBLVxcdURDRjJdfFxcdUQ4M0FbXFx1RENDNy1cXHVEQ0NGXXxcXHVEODAyW1xcdURDNTgtXFx1REM1RlxcdURDNzktXFx1REM3RlxcdURDQTctXFx1RENBRlxcdURDRkItXFx1RENGRlxcdUREMTYtXFx1REQxQlxcdUREQkNcXHVEREJEXFx1RERDMC1cXHVERENGXFx1REREMi1cXHVEREZGXFx1REU0MC1cXHVERTQ3XFx1REU3RFxcdURFN0VcXHVERTlELVxcdURFOUZcXHVERUVCLVxcdURFRUZcXHVERjU4LVxcdURGNUZcXHVERjc4LVxcdURGN0ZcXHVERkE5LVxcdURGQUZdfFxcdUQ4MDVbXFx1REYzQVxcdURGM0JdfFxcdUQ4MUFbXFx1REY1Qi1cXHVERjYxXXxcXHVEODM0W1xcdURGNjAtXFx1REY3MV18XFx1RDgwMFtcXHVERDA3LVxcdUREMzNcXHVERDc1LVxcdURENzhcXHVERDhBXFx1REQ4QlxcdURFRTEtXFx1REVGQlxcdURGMjAtXFx1REYyM10nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdQJyxcbiAgICAgICAgICAgIGFsaWFzOiAnUHVuY3R1YXRpb24nLFxuICAgICAgICAgICAgYm1wOiAnXFx4MjEtXFx4MjNcXHgyNS1cXFxceDJBXFx4MkMtXFx4MkZcXHgzQVxceDNCXFxcXHgzRlxceDQwXFxcXHg1Qi1cXFxceDVEXFx4NUZcXFxceDdCXFx4N0RcXHhBMVxceEE3XFx4QUJcXHhCNlxceEI3XFx4QkJcXHhCRlxcdTAzN0VcXHUwMzg3XFx1MDU1QS1cXHUwNTVGXFx1MDU4OVxcdTA1OEFcXHUwNUJFXFx1MDVDMFxcdTA1QzNcXHUwNUM2XFx1MDVGM1xcdTA1RjRcXHUwNjA5XFx1MDYwQVxcdTA2MENcXHUwNjBEXFx1MDYxQlxcdTA2MUVcXHUwNjFGXFx1MDY2QS1cXHUwNjZEXFx1MDZENFxcdTA3MDAtXFx1MDcwRFxcdTA3RjctXFx1MDdGOVxcdTA4MzAtXFx1MDgzRVxcdTA4NUVcXHUwOTY0XFx1MDk2NVxcdTA5NzBcXHUwQUYwXFx1MERGNFxcdTBFNEZcXHUwRTVBXFx1MEU1QlxcdTBGMDQtXFx1MEYxMlxcdTBGMTRcXHUwRjNBLVxcdTBGM0RcXHUwRjg1XFx1MEZEMC1cXHUwRkQ0XFx1MEZEOVxcdTBGREFcXHUxMDRBLVxcdTEwNEZcXHUxMEZCXFx1MTM2MC1cXHUxMzY4XFx1MTQwMFxcdTE2NkRcXHUxNjZFXFx1MTY5QlxcdTE2OUNcXHUxNkVCLVxcdTE2RURcXHUxNzM1XFx1MTczNlxcdTE3RDQtXFx1MTdENlxcdTE3RDgtXFx1MTdEQVxcdTE4MDAtXFx1MTgwQVxcdTE5NDRcXHUxOTQ1XFx1MUExRVxcdTFBMUZcXHUxQUEwLVxcdTFBQTZcXHUxQUE4LVxcdTFBQURcXHUxQjVBLVxcdTFCNjBcXHUxQkZDLVxcdTFCRkZcXHUxQzNCLVxcdTFDM0ZcXHUxQzdFXFx1MUM3RlxcdTFDQzAtXFx1MUNDN1xcdTFDRDNcXHUyMDEwLVxcdTIwMjdcXHUyMDMwLVxcdTIwNDNcXHUyMDQ1LVxcdTIwNTFcXHUyMDUzLVxcdTIwNUVcXHUyMDdEXFx1MjA3RVxcdTIwOERcXHUyMDhFXFx1MjMwOC1cXHUyMzBCXFx1MjMyOVxcdTIzMkFcXHUyNzY4LVxcdTI3NzVcXHUyN0M1XFx1MjdDNlxcdTI3RTYtXFx1MjdFRlxcdTI5ODMtXFx1Mjk5OFxcdTI5RDgtXFx1MjlEQlxcdTI5RkNcXHUyOUZEXFx1MkNGOS1cXHUyQ0ZDXFx1MkNGRVxcdTJDRkZcXHUyRDcwXFx1MkUwMC1cXHUyRTJFXFx1MkUzMC1cXHUyRTQyXFx1MzAwMS1cXHUzMDAzXFx1MzAwOC1cXHUzMDExXFx1MzAxNC1cXHUzMDFGXFx1MzAzMFxcdTMwM0RcXHUzMEEwXFx1MzBGQlxcdUE0RkVcXHVBNEZGXFx1QTYwRC1cXHVBNjBGXFx1QTY3M1xcdUE2N0VcXHVBNkYyLVxcdUE2RjdcXHVBODc0LVxcdUE4NzdcXHVBOENFXFx1QThDRlxcdUE4RjgtXFx1QThGQVxcdUE4RkNcXHVBOTJFXFx1QTkyRlxcdUE5NUZcXHVBOUMxLVxcdUE5Q0RcXHVBOURFXFx1QTlERlxcdUFBNUMtXFx1QUE1RlxcdUFBREVcXHVBQURGXFx1QUFGMFxcdUFBRjFcXHVBQkVCXFx1RkQzRVxcdUZEM0ZcXHVGRTEwLVxcdUZFMTlcXHVGRTMwLVxcdUZFNTJcXHVGRTU0LVxcdUZFNjFcXHVGRTYzXFx1RkU2OFxcdUZFNkFcXHVGRTZCXFx1RkYwMS1cXHVGRjAzXFx1RkYwNS1cXHVGRjBBXFx1RkYwQy1cXHVGRjBGXFx1RkYxQVxcdUZGMUJcXHVGRjFGXFx1RkYyMFxcdUZGM0ItXFx1RkYzRFxcdUZGM0ZcXHVGRjVCXFx1RkY1RFxcdUZGNUYtXFx1RkY2NScsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAyW1xcdURDNTdcXHVERDFGXFx1REQzRlxcdURFNTAtXFx1REU1OFxcdURFN0ZcXHVERUYwLVxcdURFRjZcXHVERjM5LVxcdURGM0ZcXHVERjk5LVxcdURGOUNdfFxcdUQ4MDlbXFx1REM3MC1cXHVEQzc0XXxcXHVEODA1W1xcdURDQzZcXHVEREMxLVxcdURERDdcXHVERTQxLVxcdURFNDNcXHVERjNDLVxcdURGM0VdfFxcdUQ4MzZbXFx1REU4Ny1cXHVERThCXXxcXHVEODAxXFx1REQ2RnxcXHVEODJGXFx1REM5RnxcXHVEODA0W1xcdURDNDctXFx1REM0RFxcdURDQkJcXHVEQ0JDXFx1RENCRS1cXHVEQ0MxXFx1REQ0MC1cXHVERDQzXFx1REQ3NFxcdURENzVcXHVEREM1LVxcdUREQzlcXHVERENEXFx1REREQlxcdUREREQtXFx1RERERlxcdURFMzgtXFx1REUzRFxcdURFQTldfFxcdUQ4MDBbXFx1REQwMC1cXHVERDAyXFx1REY5RlxcdURGRDBdfFxcdUQ4MUFbXFx1REU2RVxcdURFNkZcXHVERUY1XFx1REYzNy1cXHVERjNCXFx1REY0NF0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdQYycsXG4gICAgICAgICAgICBhbGlhczogJ0Nvbm5lY3Rvcl9QdW5jdHVhdGlvbicsXG4gICAgICAgICAgICBibXA6ICdcXHg1RlxcdTIwM0ZcXHUyMDQwXFx1MjA1NFxcdUZFMzNcXHVGRTM0XFx1RkU0RC1cXHVGRTRGXFx1RkYzRidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ1BkJyxcbiAgICAgICAgICAgIGFsaWFzOiAnRGFzaF9QdW5jdHVhdGlvbicsXG4gICAgICAgICAgICBibXA6ICdcXFxceDJEXFx1MDU4QVxcdTA1QkVcXHUxNDAwXFx1MTgwNlxcdTIwMTAtXFx1MjAxNVxcdTJFMTdcXHUyRTFBXFx1MkUzQVxcdTJFM0JcXHUyRTQwXFx1MzAxQ1xcdTMwMzBcXHUzMEEwXFx1RkUzMVxcdUZFMzJcXHVGRTU4XFx1RkU2M1xcdUZGMEQnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdQZScsXG4gICAgICAgICAgICBhbGlhczogJ0Nsb3NlX1B1bmN0dWF0aW9uJyxcbiAgICAgICAgICAgIGJtcDogJ1xcXFx4MjlcXFxceDVEXFx4N0RcXHUwRjNCXFx1MEYzRFxcdTE2OUNcXHUyMDQ2XFx1MjA3RVxcdTIwOEVcXHUyMzA5XFx1MjMwQlxcdTIzMkFcXHUyNzY5XFx1Mjc2QlxcdTI3NkRcXHUyNzZGXFx1Mjc3MVxcdTI3NzNcXHUyNzc1XFx1MjdDNlxcdTI3RTdcXHUyN0U5XFx1MjdFQlxcdTI3RURcXHUyN0VGXFx1Mjk4NFxcdTI5ODZcXHUyOTg4XFx1Mjk4QVxcdTI5OENcXHUyOThFXFx1Mjk5MFxcdTI5OTJcXHUyOTk0XFx1Mjk5NlxcdTI5OThcXHUyOUQ5XFx1MjlEQlxcdTI5RkRcXHUyRTIzXFx1MkUyNVxcdTJFMjdcXHUyRTI5XFx1MzAwOVxcdTMwMEJcXHUzMDBEXFx1MzAwRlxcdTMwMTFcXHUzMDE1XFx1MzAxN1xcdTMwMTlcXHUzMDFCXFx1MzAxRVxcdTMwMUZcXHVGRDNFXFx1RkUxOFxcdUZFMzZcXHVGRTM4XFx1RkUzQVxcdUZFM0NcXHVGRTNFXFx1RkU0MFxcdUZFNDJcXHVGRTQ0XFx1RkU0OFxcdUZFNUFcXHVGRTVDXFx1RkU1RVxcdUZGMDlcXHVGRjNEXFx1RkY1RFxcdUZGNjBcXHVGRjYzJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnUGYnLFxuICAgICAgICAgICAgYWxpYXM6ICdGaW5hbF9QdW5jdHVhdGlvbicsXG4gICAgICAgICAgICBibXA6ICdcXHhCQlxcdTIwMTlcXHUyMDFEXFx1MjAzQVxcdTJFMDNcXHUyRTA1XFx1MkUwQVxcdTJFMERcXHUyRTFEXFx1MkUyMSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ1BpJyxcbiAgICAgICAgICAgIGFsaWFzOiAnSW5pdGlhbF9QdW5jdHVhdGlvbicsXG4gICAgICAgICAgICBibXA6ICdcXHhBQlxcdTIwMThcXHUyMDFCXFx1MjAxQ1xcdTIwMUZcXHUyMDM5XFx1MkUwMlxcdTJFMDRcXHUyRTA5XFx1MkUwQ1xcdTJFMUNcXHUyRTIwJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnUG8nLFxuICAgICAgICAgICAgYWxpYXM6ICdPdGhlcl9QdW5jdHVhdGlvbicsXG4gICAgICAgICAgICBibXA6ICdcXHgyMS1cXHgyM1xceDI1LVxceDI3XFxcXHgyQVxceDJDXFxcXHgyRVxceDJGXFx4M0FcXHgzQlxcXFx4M0ZcXHg0MFxcXFx4NUNcXHhBMVxceEE3XFx4QjZcXHhCN1xceEJGXFx1MDM3RVxcdTAzODdcXHUwNTVBLVxcdTA1NUZcXHUwNTg5XFx1MDVDMFxcdTA1QzNcXHUwNUM2XFx1MDVGM1xcdTA1RjRcXHUwNjA5XFx1MDYwQVxcdTA2MENcXHUwNjBEXFx1MDYxQlxcdTA2MUVcXHUwNjFGXFx1MDY2QS1cXHUwNjZEXFx1MDZENFxcdTA3MDAtXFx1MDcwRFxcdTA3RjctXFx1MDdGOVxcdTA4MzAtXFx1MDgzRVxcdTA4NUVcXHUwOTY0XFx1MDk2NVxcdTA5NzBcXHUwQUYwXFx1MERGNFxcdTBFNEZcXHUwRTVBXFx1MEU1QlxcdTBGMDQtXFx1MEYxMlxcdTBGMTRcXHUwRjg1XFx1MEZEMC1cXHUwRkQ0XFx1MEZEOVxcdTBGREFcXHUxMDRBLVxcdTEwNEZcXHUxMEZCXFx1MTM2MC1cXHUxMzY4XFx1MTY2RFxcdTE2NkVcXHUxNkVCLVxcdTE2RURcXHUxNzM1XFx1MTczNlxcdTE3RDQtXFx1MTdENlxcdTE3RDgtXFx1MTdEQVxcdTE4MDAtXFx1MTgwNVxcdTE4MDctXFx1MTgwQVxcdTE5NDRcXHUxOTQ1XFx1MUExRVxcdTFBMUZcXHUxQUEwLVxcdTFBQTZcXHUxQUE4LVxcdTFBQURcXHUxQjVBLVxcdTFCNjBcXHUxQkZDLVxcdTFCRkZcXHUxQzNCLVxcdTFDM0ZcXHUxQzdFXFx1MUM3RlxcdTFDQzAtXFx1MUNDN1xcdTFDRDNcXHUyMDE2XFx1MjAxN1xcdTIwMjAtXFx1MjAyN1xcdTIwMzAtXFx1MjAzOFxcdTIwM0ItXFx1MjAzRVxcdTIwNDEtXFx1MjA0M1xcdTIwNDctXFx1MjA1MVxcdTIwNTNcXHUyMDU1LVxcdTIwNUVcXHUyQ0Y5LVxcdTJDRkNcXHUyQ0ZFXFx1MkNGRlxcdTJENzBcXHUyRTAwXFx1MkUwMVxcdTJFMDYtXFx1MkUwOFxcdTJFMEJcXHUyRTBFLVxcdTJFMTZcXHUyRTE4XFx1MkUxOVxcdTJFMUJcXHUyRTFFXFx1MkUxRlxcdTJFMkEtXFx1MkUyRVxcdTJFMzAtXFx1MkUzOVxcdTJFM0MtXFx1MkUzRlxcdTJFNDFcXHUzMDAxLVxcdTMwMDNcXHUzMDNEXFx1MzBGQlxcdUE0RkVcXHVBNEZGXFx1QTYwRC1cXHVBNjBGXFx1QTY3M1xcdUE2N0VcXHVBNkYyLVxcdUE2RjdcXHVBODc0LVxcdUE4NzdcXHVBOENFXFx1QThDRlxcdUE4RjgtXFx1QThGQVxcdUE4RkNcXHVBOTJFXFx1QTkyRlxcdUE5NUZcXHVBOUMxLVxcdUE5Q0RcXHVBOURFXFx1QTlERlxcdUFBNUMtXFx1QUE1RlxcdUFBREVcXHVBQURGXFx1QUFGMFxcdUFBRjFcXHVBQkVCXFx1RkUxMC1cXHVGRTE2XFx1RkUxOVxcdUZFMzBcXHVGRTQ1XFx1RkU0NlxcdUZFNDktXFx1RkU0Q1xcdUZFNTAtXFx1RkU1MlxcdUZFNTQtXFx1RkU1N1xcdUZFNUYtXFx1RkU2MVxcdUZFNjhcXHVGRTZBXFx1RkU2QlxcdUZGMDEtXFx1RkYwM1xcdUZGMDUtXFx1RkYwN1xcdUZGMEFcXHVGRjBDXFx1RkYwRVxcdUZGMEZcXHVGRjFBXFx1RkYxQlxcdUZGMUZcXHVGRjIwXFx1RkYzQ1xcdUZGNjFcXHVGRjY0XFx1RkY2NScsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAyW1xcdURDNTdcXHVERDFGXFx1REQzRlxcdURFNTAtXFx1REU1OFxcdURFN0ZcXHVERUYwLVxcdURFRjZcXHVERjM5LVxcdURGM0ZcXHVERjk5LVxcdURGOUNdfFxcdUQ4MDlbXFx1REM3MC1cXHVEQzc0XXxcXHVEODA1W1xcdURDQzZcXHVEREMxLVxcdURERDdcXHVERTQxLVxcdURFNDNcXHVERjNDLVxcdURGM0VdfFxcdUQ4MzZbXFx1REU4Ny1cXHVERThCXXxcXHVEODAxXFx1REQ2RnxcXHVEODJGXFx1REM5RnxcXHVEODA0W1xcdURDNDctXFx1REM0RFxcdURDQkJcXHVEQ0JDXFx1RENCRS1cXHVEQ0MxXFx1REQ0MC1cXHVERDQzXFx1REQ3NFxcdURENzVcXHVEREM1LVxcdUREQzlcXHVERENEXFx1REREQlxcdUREREQtXFx1RERERlxcdURFMzgtXFx1REUzRFxcdURFQTldfFxcdUQ4MDBbXFx1REQwMC1cXHVERDAyXFx1REY5RlxcdURGRDBdfFxcdUQ4MUFbXFx1REU2RVxcdURFNkZcXHVERUY1XFx1REYzNy1cXHVERjNCXFx1REY0NF0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdQcycsXG4gICAgICAgICAgICBhbGlhczogJ09wZW5fUHVuY3R1YXRpb24nLFxuICAgICAgICAgICAgYm1wOiAnXFxcXHgyOFxcXFx4NUJcXFxceDdCXFx1MEYzQVxcdTBGM0NcXHUxNjlCXFx1MjAxQVxcdTIwMUVcXHUyMDQ1XFx1MjA3RFxcdTIwOERcXHUyMzA4XFx1MjMwQVxcdTIzMjlcXHUyNzY4XFx1Mjc2QVxcdTI3NkNcXHUyNzZFXFx1Mjc3MFxcdTI3NzJcXHUyNzc0XFx1MjdDNVxcdTI3RTZcXHUyN0U4XFx1MjdFQVxcdTI3RUNcXHUyN0VFXFx1Mjk4M1xcdTI5ODVcXHUyOTg3XFx1Mjk4OVxcdTI5OEJcXHUyOThEXFx1Mjk4RlxcdTI5OTFcXHUyOTkzXFx1Mjk5NVxcdTI5OTdcXHUyOUQ4XFx1MjlEQVxcdTI5RkNcXHUyRTIyXFx1MkUyNFxcdTJFMjZcXHUyRTI4XFx1MkU0MlxcdTMwMDhcXHUzMDBBXFx1MzAwQ1xcdTMwMEVcXHUzMDEwXFx1MzAxNFxcdTMwMTZcXHUzMDE4XFx1MzAxQVxcdTMwMURcXHVGRDNGXFx1RkUxN1xcdUZFMzVcXHVGRTM3XFx1RkUzOVxcdUZFM0JcXHVGRTNEXFx1RkUzRlxcdUZFNDFcXHVGRTQzXFx1RkU0N1xcdUZFNTlcXHVGRTVCXFx1RkU1RFxcdUZGMDhcXHVGRjNCXFx1RkY1QlxcdUZGNUZcXHVGRjYyJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnUycsXG4gICAgICAgICAgICBhbGlhczogJ1N5bWJvbCcsXG4gICAgICAgICAgICBibXA6ICdcXFxceDI0XFxcXHgyQlxceDNDLVxceDNFXFxcXHg1RVxceDYwXFxcXHg3Q1xceDdFXFx4QTItXFx4QTZcXHhBOFxceEE5XFx4QUNcXHhBRS1cXHhCMVxceEI0XFx4QjhcXHhEN1xceEY3XFx1MDJDMi1cXHUwMkM1XFx1MDJEMi1cXHUwMkRGXFx1MDJFNS1cXHUwMkVCXFx1MDJFRFxcdTAyRUYtXFx1MDJGRlxcdTAzNzVcXHUwMzg0XFx1MDM4NVxcdTAzRjZcXHUwNDgyXFx1MDU4RC1cXHUwNThGXFx1MDYwNi1cXHUwNjA4XFx1MDYwQlxcdTA2MEVcXHUwNjBGXFx1MDZERVxcdTA2RTlcXHUwNkZEXFx1MDZGRVxcdTA3RjZcXHUwOUYyXFx1MDlGM1xcdTA5RkFcXHUwOUZCXFx1MEFGMVxcdTBCNzBcXHUwQkYzLVxcdTBCRkFcXHUwQzdGXFx1MEQ3OVxcdTBFM0ZcXHUwRjAxLVxcdTBGMDNcXHUwRjEzXFx1MEYxNS1cXHUwRjE3XFx1MEYxQS1cXHUwRjFGXFx1MEYzNFxcdTBGMzZcXHUwRjM4XFx1MEZCRS1cXHUwRkM1XFx1MEZDNy1cXHUwRkNDXFx1MEZDRVxcdTBGQ0ZcXHUwRkQ1LVxcdTBGRDhcXHUxMDlFXFx1MTA5RlxcdTEzOTAtXFx1MTM5OVxcdTE3REJcXHUxOTQwXFx1MTlERS1cXHUxOUZGXFx1MUI2MS1cXHUxQjZBXFx1MUI3NC1cXHUxQjdDXFx1MUZCRFxcdTFGQkYtXFx1MUZDMVxcdTFGQ0QtXFx1MUZDRlxcdTFGREQtXFx1MUZERlxcdTFGRUQtXFx1MUZFRlxcdTFGRkRcXHUxRkZFXFx1MjA0NFxcdTIwNTJcXHUyMDdBLVxcdTIwN0NcXHUyMDhBLVxcdTIwOENcXHUyMEEwLVxcdTIwQkVcXHUyMTAwXFx1MjEwMVxcdTIxMDMtXFx1MjEwNlxcdTIxMDhcXHUyMTA5XFx1MjExNFxcdTIxMTYtXFx1MjExOFxcdTIxMUUtXFx1MjEyM1xcdTIxMjVcXHUyMTI3XFx1MjEyOVxcdTIxMkVcXHUyMTNBXFx1MjEzQlxcdTIxNDAtXFx1MjE0NFxcdTIxNEEtXFx1MjE0RFxcdTIxNEZcXHUyMThBXFx1MjE4QlxcdTIxOTAtXFx1MjMwN1xcdTIzMEMtXFx1MjMyOFxcdTIzMkItXFx1MjNGQVxcdTI0MDAtXFx1MjQyNlxcdTI0NDAtXFx1MjQ0QVxcdTI0OUMtXFx1MjRFOVxcdTI1MDAtXFx1Mjc2N1xcdTI3OTQtXFx1MjdDNFxcdTI3QzctXFx1MjdFNVxcdTI3RjAtXFx1Mjk4MlxcdTI5OTktXFx1MjlEN1xcdTI5REMtXFx1MjlGQlxcdTI5RkUtXFx1MkI3M1xcdTJCNzYtXFx1MkI5NVxcdTJCOTgtXFx1MkJCOVxcdTJCQkQtXFx1MkJDOFxcdTJCQ0EtXFx1MkJEMVxcdTJCRUMtXFx1MkJFRlxcdTJDRTUtXFx1MkNFQVxcdTJFODAtXFx1MkU5OVxcdTJFOUItXFx1MkVGM1xcdTJGMDAtXFx1MkZENVxcdTJGRjAtXFx1MkZGQlxcdTMwMDRcXHUzMDEyXFx1MzAxM1xcdTMwMjBcXHUzMDM2XFx1MzAzN1xcdTMwM0VcXHUzMDNGXFx1MzA5QlxcdTMwOUNcXHUzMTkwXFx1MzE5MVxcdTMxOTYtXFx1MzE5RlxcdTMxQzAtXFx1MzFFM1xcdTMyMDAtXFx1MzIxRVxcdTMyMkEtXFx1MzI0N1xcdTMyNTBcXHUzMjYwLVxcdTMyN0ZcXHUzMjhBLVxcdTMyQjBcXHUzMkMwLVxcdTMyRkVcXHUzMzAwLVxcdTMzRkZcXHU0REMwLVxcdTRERkZcXHVBNDkwLVxcdUE0QzZcXHVBNzAwLVxcdUE3MTZcXHVBNzIwXFx1QTcyMVxcdUE3ODlcXHVBNzhBXFx1QTgyOC1cXHVBODJCXFx1QTgzNi1cXHVBODM5XFx1QUE3Ny1cXHVBQTc5XFx1QUI1QlxcdUZCMjlcXHVGQkIyLVxcdUZCQzFcXHVGREZDXFx1RkRGRFxcdUZFNjJcXHVGRTY0LVxcdUZFNjZcXHVGRTY5XFx1RkYwNFxcdUZGMEJcXHVGRjFDLVxcdUZGMUVcXHVGRjNFXFx1RkY0MFxcdUZGNUNcXHVGRjVFXFx1RkZFMC1cXHVGRkU2XFx1RkZFOC1cXHVGRkVFXFx1RkZGQ1xcdUZGRkQnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgzRVtcXHVEQzAwLVxcdURDMEJcXHVEQzEwLVxcdURDNDdcXHVEQzUwLVxcdURDNTlcXHVEQzYwLVxcdURDODdcXHVEQzkwLVxcdURDQURcXHVERDEwLVxcdUREMThcXHVERDgwLVxcdUREODRcXHVEREMwXXxcXHVEODNDW1xcdURDMDAtXFx1REMyQlxcdURDMzAtXFx1REM5M1xcdURDQTAtXFx1RENBRVxcdURDQjEtXFx1RENCRlxcdURDQzEtXFx1RENDRlxcdURDRDEtXFx1RENGNVxcdUREMTAtXFx1REQyRVxcdUREMzAtXFx1REQ2QlxcdURENzAtXFx1REQ5QVxcdURERTYtXFx1REUwMlxcdURFMTAtXFx1REUzQVxcdURFNDAtXFx1REU0OFxcdURFNTBcXHVERTUxXFx1REYwMC1cXHVERkZGXXxcXHVEODNEW1xcdURDMDAtXFx1REQ3OVxcdUREN0ItXFx1RERBM1xcdUREQTUtXFx1REVEMFxcdURFRTAtXFx1REVFQ1xcdURFRjAtXFx1REVGM1xcdURGMDAtXFx1REY3M1xcdURGODAtXFx1REZENF18XFx1RDgzNVtcXHVERUMxXFx1REVEQlxcdURFRkJcXHVERjE1XFx1REYzNVxcdURGNEZcXHVERjZGXFx1REY4OVxcdURGQTlcXHVERkMzXXxcXHVEODAwW1xcdUREMzctXFx1REQzRlxcdURENzktXFx1REQ4OVxcdUREOENcXHVERDkwLVxcdUREOUJcXHVEREEwXFx1REREMC1cXHVEREZDXXxcXHVEODJGXFx1REM5Q3xcXHVEODA1XFx1REYzRnxcXHVEODAyW1xcdURDNzdcXHVEQzc4XFx1REVDOF18XFx1RDgxQVtcXHVERjNDLVxcdURGM0ZcXHVERjQ1XXxcXHVEODM2W1xcdURDMDAtXFx1RERGRlxcdURFMzctXFx1REUzQVxcdURFNkQtXFx1REU3NFxcdURFNzYtXFx1REU4M1xcdURFODVcXHVERTg2XXxcXHVEODM0W1xcdURDMDAtXFx1RENGNVxcdUREMDAtXFx1REQyNlxcdUREMjktXFx1REQ2NFxcdURENkEtXFx1REQ2Q1xcdUREODNcXHVERDg0XFx1REQ4Qy1cXHVEREE5XFx1RERBRS1cXHVEREU4XFx1REUwMC1cXHVERTQxXFx1REU0NVxcdURGMDAtXFx1REY1Nl18XFx1RDgzQltcXHVERUYwXFx1REVGMV0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdTYycsXG4gICAgICAgICAgICBhbGlhczogJ0N1cnJlbmN5X1N5bWJvbCcsXG4gICAgICAgICAgICBibXA6ICdcXFxceDI0XFx4QTItXFx4QTVcXHUwNThGXFx1MDYwQlxcdTA5RjJcXHUwOUYzXFx1MDlGQlxcdTBBRjFcXHUwQkY5XFx1MEUzRlxcdTE3REJcXHUyMEEwLVxcdTIwQkVcXHVBODM4XFx1RkRGQ1xcdUZFNjlcXHVGRjA0XFx1RkZFMFxcdUZGRTFcXHVGRkU1XFx1RkZFNidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ1NrJyxcbiAgICAgICAgICAgIGFsaWFzOiAnTW9kaWZpZXJfU3ltYm9sJyxcbiAgICAgICAgICAgIGJtcDogJ1xcXFx4NUVcXHg2MFxceEE4XFx4QUZcXHhCNFxceEI4XFx1MDJDMi1cXHUwMkM1XFx1MDJEMi1cXHUwMkRGXFx1MDJFNS1cXHUwMkVCXFx1MDJFRFxcdTAyRUYtXFx1MDJGRlxcdTAzNzVcXHUwMzg0XFx1MDM4NVxcdTFGQkRcXHUxRkJGLVxcdTFGQzFcXHUxRkNELVxcdTFGQ0ZcXHUxRkRELVxcdTFGREZcXHUxRkVELVxcdTFGRUZcXHUxRkZEXFx1MUZGRVxcdTMwOUJcXHUzMDlDXFx1QTcwMC1cXHVBNzE2XFx1QTcyMFxcdUE3MjFcXHVBNzg5XFx1QTc4QVxcdUFCNUJcXHVGQkIyLVxcdUZCQzFcXHVGRjNFXFx1RkY0MFxcdUZGRTMnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnU20nLFxuICAgICAgICAgICAgYWxpYXM6ICdNYXRoX1N5bWJvbCcsXG4gICAgICAgICAgICBibXA6ICdcXFxceDJCXFx4M0MtXFx4M0VcXFxceDdDXFx4N0VcXHhBQ1xceEIxXFx4RDdcXHhGN1xcdTAzRjZcXHUwNjA2LVxcdTA2MDhcXHUyMDQ0XFx1MjA1MlxcdTIwN0EtXFx1MjA3Q1xcdTIwOEEtXFx1MjA4Q1xcdTIxMThcXHUyMTQwLVxcdTIxNDRcXHUyMTRCXFx1MjE5MC1cXHUyMTk0XFx1MjE5QVxcdTIxOUJcXHUyMUEwXFx1MjFBM1xcdTIxQTZcXHUyMUFFXFx1MjFDRVxcdTIxQ0ZcXHUyMUQyXFx1MjFENFxcdTIxRjQtXFx1MjJGRlxcdTIzMjBcXHUyMzIxXFx1MjM3Q1xcdTIzOUItXFx1MjNCM1xcdTIzREMtXFx1MjNFMVxcdTI1QjdcXHUyNUMxXFx1MjVGOC1cXHUyNUZGXFx1MjY2RlxcdTI3QzAtXFx1MjdDNFxcdTI3QzctXFx1MjdFNVxcdTI3RjAtXFx1MjdGRlxcdTI5MDAtXFx1Mjk4MlxcdTI5OTktXFx1MjlEN1xcdTI5REMtXFx1MjlGQlxcdTI5RkUtXFx1MkFGRlxcdTJCMzAtXFx1MkI0NFxcdTJCNDctXFx1MkI0Q1xcdUZCMjlcXHVGRTYyXFx1RkU2NC1cXHVGRTY2XFx1RkYwQlxcdUZGMUMtXFx1RkYxRVxcdUZGNUNcXHVGRjVFXFx1RkZFMlxcdUZGRTktXFx1RkZFQycsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODNCW1xcdURFRjBcXHVERUYxXXxcXHVEODM1W1xcdURFQzFcXHVERURCXFx1REVGQlxcdURGMTVcXHVERjM1XFx1REY0RlxcdURGNkZcXHVERjg5XFx1REZBOVxcdURGQzNdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnU28nLFxuICAgICAgICAgICAgYWxpYXM6ICdPdGhlcl9TeW1ib2wnLFxuICAgICAgICAgICAgYm1wOiAnXFx4QTZcXHhBOVxceEFFXFx4QjBcXHUwNDgyXFx1MDU4RFxcdTA1OEVcXHUwNjBFXFx1MDYwRlxcdTA2REVcXHUwNkU5XFx1MDZGRFxcdTA2RkVcXHUwN0Y2XFx1MDlGQVxcdTBCNzBcXHUwQkYzLVxcdTBCRjhcXHUwQkZBXFx1MEM3RlxcdTBENzlcXHUwRjAxLVxcdTBGMDNcXHUwRjEzXFx1MEYxNS1cXHUwRjE3XFx1MEYxQS1cXHUwRjFGXFx1MEYzNFxcdTBGMzZcXHUwRjM4XFx1MEZCRS1cXHUwRkM1XFx1MEZDNy1cXHUwRkNDXFx1MEZDRVxcdTBGQ0ZcXHUwRkQ1LVxcdTBGRDhcXHUxMDlFXFx1MTA5RlxcdTEzOTAtXFx1MTM5OVxcdTE5NDBcXHUxOURFLVxcdTE5RkZcXHUxQjYxLVxcdTFCNkFcXHUxQjc0LVxcdTFCN0NcXHUyMTAwXFx1MjEwMVxcdTIxMDMtXFx1MjEwNlxcdTIxMDhcXHUyMTA5XFx1MjExNFxcdTIxMTZcXHUyMTE3XFx1MjExRS1cXHUyMTIzXFx1MjEyNVxcdTIxMjdcXHUyMTI5XFx1MjEyRVxcdTIxM0FcXHUyMTNCXFx1MjE0QVxcdTIxNENcXHUyMTREXFx1MjE0RlxcdTIxOEFcXHUyMThCXFx1MjE5NS1cXHUyMTk5XFx1MjE5Qy1cXHUyMTlGXFx1MjFBMVxcdTIxQTJcXHUyMUE0XFx1MjFBNVxcdTIxQTctXFx1MjFBRFxcdTIxQUYtXFx1MjFDRFxcdTIxRDBcXHUyMUQxXFx1MjFEM1xcdTIxRDUtXFx1MjFGM1xcdTIzMDAtXFx1MjMwN1xcdTIzMEMtXFx1MjMxRlxcdTIzMjItXFx1MjMyOFxcdTIzMkItXFx1MjM3QlxcdTIzN0QtXFx1MjM5QVxcdTIzQjQtXFx1MjNEQlxcdTIzRTItXFx1MjNGQVxcdTI0MDAtXFx1MjQyNlxcdTI0NDAtXFx1MjQ0QVxcdTI0OUMtXFx1MjRFOVxcdTI1MDAtXFx1MjVCNlxcdTI1QjgtXFx1MjVDMFxcdTI1QzItXFx1MjVGN1xcdTI2MDAtXFx1MjY2RVxcdTI2NzAtXFx1Mjc2N1xcdTI3OTQtXFx1MjdCRlxcdTI4MDAtXFx1MjhGRlxcdTJCMDAtXFx1MkIyRlxcdTJCNDVcXHUyQjQ2XFx1MkI0RC1cXHUyQjczXFx1MkI3Ni1cXHUyQjk1XFx1MkI5OC1cXHUyQkI5XFx1MkJCRC1cXHUyQkM4XFx1MkJDQS1cXHUyQkQxXFx1MkJFQy1cXHUyQkVGXFx1MkNFNS1cXHUyQ0VBXFx1MkU4MC1cXHUyRTk5XFx1MkU5Qi1cXHUyRUYzXFx1MkYwMC1cXHUyRkQ1XFx1MkZGMC1cXHUyRkZCXFx1MzAwNFxcdTMwMTJcXHUzMDEzXFx1MzAyMFxcdTMwMzZcXHUzMDM3XFx1MzAzRVxcdTMwM0ZcXHUzMTkwXFx1MzE5MVxcdTMxOTYtXFx1MzE5RlxcdTMxQzAtXFx1MzFFM1xcdTMyMDAtXFx1MzIxRVxcdTMyMkEtXFx1MzI0N1xcdTMyNTBcXHUzMjYwLVxcdTMyN0ZcXHUzMjhBLVxcdTMyQjBcXHUzMkMwLVxcdTMyRkVcXHUzMzAwLVxcdTMzRkZcXHU0REMwLVxcdTRERkZcXHVBNDkwLVxcdUE0QzZcXHVBODI4LVxcdUE4MkJcXHVBODM2XFx1QTgzN1xcdUE4MzlcXHVBQTc3LVxcdUFBNzlcXHVGREZEXFx1RkZFNFxcdUZGRThcXHVGRkVEXFx1RkZFRVxcdUZGRkNcXHVGRkZEJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4M0VbXFx1REMwMC1cXHVEQzBCXFx1REMxMC1cXHVEQzQ3XFx1REM1MC1cXHVEQzU5XFx1REM2MC1cXHVEQzg3XFx1REM5MC1cXHVEQ0FEXFx1REQxMC1cXHVERDE4XFx1REQ4MC1cXHVERDg0XFx1RERDMF18XFx1RDgzRFtcXHVEQzAwLVxcdURENzlcXHVERDdCLVxcdUREQTNcXHVEREE1LVxcdURFRDBcXHVERUUwLVxcdURFRUNcXHVERUYwLVxcdURFRjNcXHVERjAwLVxcdURGNzNcXHVERjgwLVxcdURGRDRdfFxcdUQ4M0NbXFx1REMwMC1cXHVEQzJCXFx1REMzMC1cXHVEQzkzXFx1RENBMC1cXHVEQ0FFXFx1RENCMS1cXHVEQ0JGXFx1RENDMS1cXHVEQ0NGXFx1RENEMS1cXHVEQ0Y1XFx1REQxMC1cXHVERDJFXFx1REQzMC1cXHVERDZCXFx1REQ3MC1cXHVERDlBXFx1RERFNi1cXHVERTAyXFx1REUxMC1cXHVERTNBXFx1REU0MC1cXHVERTQ4XFx1REU1MFxcdURFNTFcXHVERjAwLVxcdURGRkFdfFxcdUQ4MDBbXFx1REQzNy1cXHVERDNGXFx1REQ3OS1cXHVERDg5XFx1REQ4Q1xcdUREOTAtXFx1REQ5QlxcdUREQTBcXHVEREQwLVxcdURERkNdfFxcdUQ4MkZcXHVEQzlDfFxcdUQ4MDVcXHVERjNGfFxcdUQ4MDJbXFx1REM3N1xcdURDNzhcXHVERUM4XXxcXHVEODFBW1xcdURGM0MtXFx1REYzRlxcdURGNDVdfFxcdUQ4MzZbXFx1REMwMC1cXHVEREZGXFx1REUzNy1cXHVERTNBXFx1REU2RC1cXHVERTc0XFx1REU3Ni1cXHVERTgzXFx1REU4NVxcdURFODZdfFxcdUQ4MzRbXFx1REMwMC1cXHVEQ0Y1XFx1REQwMC1cXHVERDI2XFx1REQyOS1cXHVERDY0XFx1REQ2QS1cXHVERDZDXFx1REQ4M1xcdUREODRcXHVERDhDLVxcdUREQTlcXHVEREFFLVxcdURERThcXHVERTAwLVxcdURFNDFcXHVERTQ1XFx1REYwMC1cXHVERjU2XSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ1onLFxuICAgICAgICAgICAgYWxpYXM6ICdTZXBhcmF0b3InLFxuICAgICAgICAgICAgYm1wOiAnXFx4MjBcXHhBMFxcdTE2ODBcXHUyMDAwLVxcdTIwMEFcXHUyMDI4XFx1MjAyOVxcdTIwMkZcXHUyMDVGXFx1MzAwMCdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ1psJyxcbiAgICAgICAgICAgIGFsaWFzOiAnTGluZV9TZXBhcmF0b3InLFxuICAgICAgICAgICAgYm1wOiAnXFx1MjAyOCdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ1pwJyxcbiAgICAgICAgICAgIGFsaWFzOiAnUGFyYWdyYXBoX1NlcGFyYXRvcicsXG4gICAgICAgICAgICBibXA6ICdcXHUyMDI5J1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnWnMnLFxuICAgICAgICAgICAgYWxpYXM6ICdTcGFjZV9TZXBhcmF0b3InLFxuICAgICAgICAgICAgYm1wOiAnXFx4MjBcXHhBMFxcdTE2ODBcXHUyMDAwLVxcdTIwMEFcXHUyMDJGXFx1MjA1RlxcdTMwMDAnXG4gICAgICAgIH1cbiAgICBdKTtcblxufShYUmVnRXhwKSk7XG5cbi8qIVxuICogWFJlZ0V4cCBVbmljb2RlIFByb3BlcnRpZXMgMy4wLjBcbiAqIDxodHRwOi8veHJlZ2V4cC5jb20vPlxuICogU3RldmVuIExldml0aGFuIChjKSAyMDEyLTIwMTUgTUlUIExpY2Vuc2VcbiAqIFVuaWNvZGUgZGF0YSBwcm92aWRlZCBieSBNYXRoaWFzIEJ5bmVucyA8aHR0cDovL21hdGhpYXNieW5lbnMuYmUvPlxuICovXG5cbi8qKlxuICogQWRkcyBwcm9wZXJ0aWVzIHRvIG1lZXQgdGhlIFVUUyAjMTggTGV2ZWwgMSBSTDEuMiByZXF1aXJlbWVudHMgZm9yIFVuaWNvZGUgcmVnZXggc3VwcG9ydC4gU2VlXG4gKiA8aHR0cDovL3VuaWNvZGUub3JnL3JlcG9ydHMvdHIxOC8jUkwxLjI+LiBGb2xsb3dpbmcgYXJlIGRlZmluaXRpb25zIG9mIHRoZXNlIHByb3BlcnRpZXMgZnJvbSBVQVhcbiAqICM0NCA8aHR0cDovL3VuaWNvZGUub3JnL3JlcG9ydHMvdHI0NC8+OlxuICpcbiAqIC0gQWxwaGFiZXRpY1xuICogICBDaGFyYWN0ZXJzIHdpdGggdGhlIEFscGhhYmV0aWMgcHJvcGVydHkuIEdlbmVyYXRlZCBmcm9tOiBMb3dlcmNhc2UgKyBVcHBlcmNhc2UgKyBMdCArIExtICsgTG8gK1xuICogICBObCArIE90aGVyX0FscGhhYmV0aWMuXG4gKlxuICogLSBEZWZhdWx0X0lnbm9yYWJsZV9Db2RlX1BvaW50XG4gKiAgIEZvciBwcm9ncmFtbWF0aWMgZGV0ZXJtaW5hdGlvbiBvZiBkZWZhdWx0IGlnbm9yYWJsZSBjb2RlIHBvaW50cy4gTmV3IGNoYXJhY3RlcnMgdGhhdCBzaG91bGQgYmVcbiAqICAgaWdub3JlZCBpbiByZW5kZXJpbmcgKHVubGVzcyBleHBsaWNpdGx5IHN1cHBvcnRlZCkgd2lsbCBiZSBhc3NpZ25lZCBpbiB0aGVzZSByYW5nZXMsIHBlcm1pdHRpbmdcbiAqICAgcHJvZ3JhbXMgdG8gY29ycmVjdGx5IGhhbmRsZSB0aGUgZGVmYXVsdCByZW5kZXJpbmcgb2Ygc3VjaCBjaGFyYWN0ZXJzIHdoZW4gbm90IG90aGVyd2lzZVxuICogICBzdXBwb3J0ZWQuXG4gKlxuICogLSBMb3dlcmNhc2VcbiAqICAgQ2hhcmFjdGVycyB3aXRoIHRoZSBMb3dlcmNhc2UgcHJvcGVydHkuIEdlbmVyYXRlZCBmcm9tOiBMbCArIE90aGVyX0xvd2VyY2FzZS5cbiAqXG4gKiAtIE5vbmNoYXJhY3Rlcl9Db2RlX1BvaW50XG4gKiAgIENvZGUgcG9pbnRzIHBlcm1hbmVudGx5IHJlc2VydmVkIGZvciBpbnRlcm5hbCB1c2UuXG4gKlxuICogLSBVcHBlcmNhc2VcbiAqICAgQ2hhcmFjdGVycyB3aXRoIHRoZSBVcHBlcmNhc2UgcHJvcGVydHkuIEdlbmVyYXRlZCBmcm9tOiBMdSArIE90aGVyX1VwcGVyY2FzZS5cbiAqXG4gKiAtIFdoaXRlX1NwYWNlXG4gKiAgIFNwYWNlcywgc2VwYXJhdG9yIGNoYXJhY3RlcnMgYW5kIG90aGVyIGNvbnRyb2wgY2hhcmFjdGVycyB3aGljaCBzaG91bGQgYmUgdHJlYXRlZCBieVxuICogICBwcm9ncmFtbWluZyBsYW5ndWFnZXMgYXMgXCJ3aGl0ZSBzcGFjZVwiIGZvciB0aGUgcHVycG9zZSBvZiBwYXJzaW5nIGVsZW1lbnRzLlxuICpcbiAqIFRoZSBwcm9wZXJ0aWVzIEFTQ0lJLCBBbnksIGFuZCBBc3NpZ25lZCBhcmUgYWxzbyBpbmNsdWRlZCBidXQgYXJlIG5vdCBkZWZpbmVkIGluIFVBWCAjNDQuIFVUUyAjMThcbiAqIFJMMS4yIGFkZGl0aW9uYWxseSByZXF1aXJlcyBzdXBwb3J0IGZvciBVbmljb2RlIHNjcmlwdHMgYW5kIGdlbmVyYWwgY2F0ZWdvcmllcy4gVGhlc2UgYXJlXG4gKiBpbmNsdWRlZCBpbiBYUmVnRXhwJ3MgVW5pY29kZSBDYXRlZ29yaWVzIGFuZCBVbmljb2RlIFNjcmlwdHMgYWRkb25zLlxuICpcbiAqIFRva2VuIG5hbWVzIGFyZSBjYXNlIGluc2Vuc2l0aXZlLCBhbmQgYW55IHNwYWNlcywgaHlwaGVucywgYW5kIHVuZGVyc2NvcmVzIGFyZSBpZ25vcmVkLlxuICpcbiAqIFVzZXMgVW5pY29kZSA4LjAuMC5cbiAqXG4gKiBAcmVxdWlyZXMgWFJlZ0V4cCwgVW5pY29kZSBCYXNlXG4gKi9cbihmdW5jdGlvbihYUmVnRXhwKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgaWYgKCFYUmVnRXhwLmFkZFVuaWNvZGVEYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcignVW5pY29kZSBCYXNlIG11c3QgYmUgbG9hZGVkIGJlZm9yZSBVbmljb2RlIFByb3BlcnRpZXMnKTtcbiAgICB9XG5cbiAgICB2YXIgdW5pY29kZURhdGEgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdBU0NJSScsXG4gICAgICAgICAgICBibXA6ICdcXDAtXFx4N0YnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdBbHBoYWJldGljJyxcbiAgICAgICAgICAgIGJtcDogJ0EtWmEtelxceEFBXFx4QjVcXHhCQVxceEMwLVxceEQ2XFx4RDgtXFx4RjZcXHhGOC1cXHUwMkMxXFx1MDJDNi1cXHUwMkQxXFx1MDJFMC1cXHUwMkU0XFx1MDJFQ1xcdTAyRUVcXHUwMzQ1XFx1MDM3MC1cXHUwMzc0XFx1MDM3NlxcdTAzNzdcXHUwMzdBLVxcdTAzN0RcXHUwMzdGXFx1MDM4NlxcdTAzODgtXFx1MDM4QVxcdTAzOENcXHUwMzhFLVxcdTAzQTFcXHUwM0EzLVxcdTAzRjVcXHUwM0Y3LVxcdTA0ODFcXHUwNDhBLVxcdTA1MkZcXHUwNTMxLVxcdTA1NTZcXHUwNTU5XFx1MDU2MS1cXHUwNTg3XFx1MDVCMC1cXHUwNUJEXFx1MDVCRlxcdTA1QzFcXHUwNUMyXFx1MDVDNFxcdTA1QzVcXHUwNUM3XFx1MDVEMC1cXHUwNUVBXFx1MDVGMC1cXHUwNUYyXFx1MDYxMC1cXHUwNjFBXFx1MDYyMC1cXHUwNjU3XFx1MDY1OS1cXHUwNjVGXFx1MDY2RS1cXHUwNkQzXFx1MDZENS1cXHUwNkRDXFx1MDZFMS1cXHUwNkU4XFx1MDZFRC1cXHUwNkVGXFx1MDZGQS1cXHUwNkZDXFx1MDZGRlxcdTA3MTAtXFx1MDczRlxcdTA3NEQtXFx1MDdCMVxcdTA3Q0EtXFx1MDdFQVxcdTA3RjRcXHUwN0Y1XFx1MDdGQVxcdTA4MDAtXFx1MDgxN1xcdTA4MUEtXFx1MDgyQ1xcdTA4NDAtXFx1MDg1OFxcdTA4QTAtXFx1MDhCNFxcdTA4RTMtXFx1MDhFOVxcdTA4RjAtXFx1MDkzQlxcdTA5M0QtXFx1MDk0Q1xcdTA5NEUtXFx1MDk1MFxcdTA5NTUtXFx1MDk2M1xcdTA5NzEtXFx1MDk4M1xcdTA5ODUtXFx1MDk4Q1xcdTA5OEZcXHUwOTkwXFx1MDk5My1cXHUwOUE4XFx1MDlBQS1cXHUwOUIwXFx1MDlCMlxcdTA5QjYtXFx1MDlCOVxcdTA5QkQtXFx1MDlDNFxcdTA5QzdcXHUwOUM4XFx1MDlDQlxcdTA5Q0NcXHUwOUNFXFx1MDlEN1xcdTA5RENcXHUwOUREXFx1MDlERi1cXHUwOUUzXFx1MDlGMFxcdTA5RjFcXHUwQTAxLVxcdTBBMDNcXHUwQTA1LVxcdTBBMEFcXHUwQTBGXFx1MEExMFxcdTBBMTMtXFx1MEEyOFxcdTBBMkEtXFx1MEEzMFxcdTBBMzJcXHUwQTMzXFx1MEEzNVxcdTBBMzZcXHUwQTM4XFx1MEEzOVxcdTBBM0UtXFx1MEE0MlxcdTBBNDdcXHUwQTQ4XFx1MEE0QlxcdTBBNENcXHUwQTUxXFx1MEE1OS1cXHUwQTVDXFx1MEE1RVxcdTBBNzAtXFx1MEE3NVxcdTBBODEtXFx1MEE4M1xcdTBBODUtXFx1MEE4RFxcdTBBOEYtXFx1MEE5MVxcdTBBOTMtXFx1MEFBOFxcdTBBQUEtXFx1MEFCMFxcdTBBQjJcXHUwQUIzXFx1MEFCNS1cXHUwQUI5XFx1MEFCRC1cXHUwQUM1XFx1MEFDNy1cXHUwQUM5XFx1MEFDQlxcdTBBQ0NcXHUwQUQwXFx1MEFFMC1cXHUwQUUzXFx1MEFGOVxcdTBCMDEtXFx1MEIwM1xcdTBCMDUtXFx1MEIwQ1xcdTBCMEZcXHUwQjEwXFx1MEIxMy1cXHUwQjI4XFx1MEIyQS1cXHUwQjMwXFx1MEIzMlxcdTBCMzNcXHUwQjM1LVxcdTBCMzlcXHUwQjNELVxcdTBCNDRcXHUwQjQ3XFx1MEI0OFxcdTBCNEJcXHUwQjRDXFx1MEI1NlxcdTBCNTdcXHUwQjVDXFx1MEI1RFxcdTBCNUYtXFx1MEI2M1xcdTBCNzFcXHUwQjgyXFx1MEI4M1xcdTBCODUtXFx1MEI4QVxcdTBCOEUtXFx1MEI5MFxcdTBCOTItXFx1MEI5NVxcdTBCOTlcXHUwQjlBXFx1MEI5Q1xcdTBCOUVcXHUwQjlGXFx1MEJBM1xcdTBCQTRcXHUwQkE4LVxcdTBCQUFcXHUwQkFFLVxcdTBCQjlcXHUwQkJFLVxcdTBCQzJcXHUwQkM2LVxcdTBCQzhcXHUwQkNBLVxcdTBCQ0NcXHUwQkQwXFx1MEJEN1xcdTBDMDAtXFx1MEMwM1xcdTBDMDUtXFx1MEMwQ1xcdTBDMEUtXFx1MEMxMFxcdTBDMTItXFx1MEMyOFxcdTBDMkEtXFx1MEMzOVxcdTBDM0QtXFx1MEM0NFxcdTBDNDYtXFx1MEM0OFxcdTBDNEEtXFx1MEM0Q1xcdTBDNTVcXHUwQzU2XFx1MEM1OC1cXHUwQzVBXFx1MEM2MC1cXHUwQzYzXFx1MEM4MS1cXHUwQzgzXFx1MEM4NS1cXHUwQzhDXFx1MEM4RS1cXHUwQzkwXFx1MEM5Mi1cXHUwQ0E4XFx1MENBQS1cXHUwQ0IzXFx1MENCNS1cXHUwQ0I5XFx1MENCRC1cXHUwQ0M0XFx1MENDNi1cXHUwQ0M4XFx1MENDQS1cXHUwQ0NDXFx1MENENVxcdTBDRDZcXHUwQ0RFXFx1MENFMC1cXHUwQ0UzXFx1MENGMVxcdTBDRjJcXHUwRDAxLVxcdTBEMDNcXHUwRDA1LVxcdTBEMENcXHUwRDBFLVxcdTBEMTBcXHUwRDEyLVxcdTBEM0FcXHUwRDNELVxcdTBENDRcXHUwRDQ2LVxcdTBENDhcXHUwRDRBLVxcdTBENENcXHUwRDRFXFx1MEQ1N1xcdTBENUYtXFx1MEQ2M1xcdTBEN0EtXFx1MEQ3RlxcdTBEODJcXHUwRDgzXFx1MEQ4NS1cXHUwRDk2XFx1MEQ5QS1cXHUwREIxXFx1MERCMy1cXHUwREJCXFx1MERCRFxcdTBEQzAtXFx1MERDNlxcdTBEQ0YtXFx1MERENFxcdTBERDZcXHUwREQ4LVxcdTBEREZcXHUwREYyXFx1MERGM1xcdTBFMDEtXFx1MEUzQVxcdTBFNDAtXFx1MEU0NlxcdTBFNERcXHUwRTgxXFx1MEU4MlxcdTBFODRcXHUwRTg3XFx1MEU4OFxcdTBFOEFcXHUwRThEXFx1MEU5NC1cXHUwRTk3XFx1MEU5OS1cXHUwRTlGXFx1MEVBMS1cXHUwRUEzXFx1MEVBNVxcdTBFQTdcXHUwRUFBXFx1MEVBQlxcdTBFQUQtXFx1MEVCOVxcdTBFQkItXFx1MEVCRFxcdTBFQzAtXFx1MEVDNFxcdTBFQzZcXHUwRUNEXFx1MEVEQy1cXHUwRURGXFx1MEYwMFxcdTBGNDAtXFx1MEY0N1xcdTBGNDktXFx1MEY2Q1xcdTBGNzEtXFx1MEY4MVxcdTBGODgtXFx1MEY5N1xcdTBGOTktXFx1MEZCQ1xcdTEwMDAtXFx1MTAzNlxcdTEwMzhcXHUxMDNCLVxcdTEwM0ZcXHUxMDUwLVxcdTEwNjJcXHUxMDY1LVxcdTEwNjhcXHUxMDZFLVxcdTEwODZcXHUxMDhFXFx1MTA5Q1xcdTEwOURcXHUxMEEwLVxcdTEwQzVcXHUxMEM3XFx1MTBDRFxcdTEwRDAtXFx1MTBGQVxcdTEwRkMtXFx1MTI0OFxcdTEyNEEtXFx1MTI0RFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVBLVxcdTEyNURcXHUxMjYwLVxcdTEyODhcXHUxMjhBLVxcdTEyOERcXHUxMjkwLVxcdTEyQjBcXHUxMkIyLVxcdTEyQjVcXHUxMkI4LVxcdTEyQkVcXHUxMkMwXFx1MTJDMi1cXHUxMkM1XFx1MTJDOC1cXHUxMkQ2XFx1MTJEOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVBXFx1MTM1RlxcdTEzODAtXFx1MTM4RlxcdTEzQTAtXFx1MTNGNVxcdTEzRjgtXFx1MTNGRFxcdTE0MDEtXFx1MTY2Q1xcdTE2NkYtXFx1MTY3RlxcdTE2ODEtXFx1MTY5QVxcdTE2QTAtXFx1MTZFQVxcdTE2RUUtXFx1MTZGOFxcdTE3MDAtXFx1MTcwQ1xcdTE3MEUtXFx1MTcxM1xcdTE3MjAtXFx1MTczM1xcdTE3NDAtXFx1MTc1M1xcdTE3NjAtXFx1MTc2Q1xcdTE3NkUtXFx1MTc3MFxcdTE3NzJcXHUxNzczXFx1MTc4MC1cXHUxN0IzXFx1MTdCNi1cXHUxN0M4XFx1MTdEN1xcdTE3RENcXHUxODIwLVxcdTE4NzdcXHUxODgwLVxcdTE4QUFcXHUxOEIwLVxcdTE4RjVcXHUxOTAwLVxcdTE5MUVcXHUxOTIwLVxcdTE5MkJcXHUxOTMwLVxcdTE5MzhcXHUxOTUwLVxcdTE5NkRcXHUxOTcwLVxcdTE5NzRcXHUxOTgwLVxcdTE5QUJcXHUxOUIwLVxcdTE5QzlcXHUxQTAwLVxcdTFBMUJcXHUxQTIwLVxcdTFBNUVcXHUxQTYxLVxcdTFBNzRcXHUxQUE3XFx1MUIwMC1cXHUxQjMzXFx1MUIzNS1cXHUxQjQzXFx1MUI0NS1cXHUxQjRCXFx1MUI4MC1cXHUxQkE5XFx1MUJBQy1cXHUxQkFGXFx1MUJCQS1cXHUxQkU1XFx1MUJFNy1cXHUxQkYxXFx1MUMwMC1cXHUxQzM1XFx1MUM0RC1cXHUxQzRGXFx1MUM1QS1cXHUxQzdEXFx1MUNFOS1cXHUxQ0VDXFx1MUNFRS1cXHUxQ0YzXFx1MUNGNVxcdTFDRjZcXHUxRDAwLVxcdTFEQkZcXHUxREU3LVxcdTFERjRcXHUxRTAwLVxcdTFGMTVcXHUxRjE4LVxcdTFGMURcXHUxRjIwLVxcdTFGNDVcXHUxRjQ4LVxcdTFGNERcXHUxRjUwLVxcdTFGNTdcXHUxRjU5XFx1MUY1QlxcdTFGNURcXHUxRjVGLVxcdTFGN0RcXHUxRjgwLVxcdTFGQjRcXHUxRkI2LVxcdTFGQkNcXHUxRkJFXFx1MUZDMi1cXHUxRkM0XFx1MUZDNi1cXHUxRkNDXFx1MUZEMC1cXHUxRkQzXFx1MUZENi1cXHUxRkRCXFx1MUZFMC1cXHUxRkVDXFx1MUZGMi1cXHUxRkY0XFx1MUZGNi1cXHUxRkZDXFx1MjA3MVxcdTIwN0ZcXHUyMDkwLVxcdTIwOUNcXHUyMTAyXFx1MjEwN1xcdTIxMEEtXFx1MjExM1xcdTIxMTVcXHUyMTE5LVxcdTIxMURcXHUyMTI0XFx1MjEyNlxcdTIxMjhcXHUyMTJBLVxcdTIxMkRcXHUyMTJGLVxcdTIxMzlcXHUyMTNDLVxcdTIxM0ZcXHUyMTQ1LVxcdTIxNDlcXHUyMTRFXFx1MjE2MC1cXHUyMTg4XFx1MjRCNi1cXHUyNEU5XFx1MkMwMC1cXHUyQzJFXFx1MkMzMC1cXHUyQzVFXFx1MkM2MC1cXHUyQ0U0XFx1MkNFQi1cXHUyQ0VFXFx1MkNGMlxcdTJDRjNcXHUyRDAwLVxcdTJEMjVcXHUyRDI3XFx1MkQyRFxcdTJEMzAtXFx1MkQ2N1xcdTJENkZcXHUyRDgwLVxcdTJEOTZcXHUyREEwLVxcdTJEQTZcXHUyREE4LVxcdTJEQUVcXHUyREIwLVxcdTJEQjZcXHUyREI4LVxcdTJEQkVcXHUyREMwLVxcdTJEQzZcXHUyREM4LVxcdTJEQ0VcXHUyREQwLVxcdTJERDZcXHUyREQ4LVxcdTJEREVcXHUyREUwLVxcdTJERkZcXHUyRTJGXFx1MzAwNS1cXHUzMDA3XFx1MzAyMS1cXHUzMDI5XFx1MzAzMS1cXHUzMDM1XFx1MzAzOC1cXHUzMDNDXFx1MzA0MS1cXHUzMDk2XFx1MzA5RC1cXHUzMDlGXFx1MzBBMS1cXHUzMEZBXFx1MzBGQy1cXHUzMEZGXFx1MzEwNS1cXHUzMTJEXFx1MzEzMS1cXHUzMThFXFx1MzFBMC1cXHUzMUJBXFx1MzFGMC1cXHUzMUZGXFx1MzQwMC1cXHU0REI1XFx1NEUwMC1cXHU5RkQ1XFx1QTAwMC1cXHVBNDhDXFx1QTREMC1cXHVBNEZEXFx1QTUwMC1cXHVBNjBDXFx1QTYxMC1cXHVBNjFGXFx1QTYyQVxcdUE2MkJcXHVBNjQwLVxcdUE2NkVcXHVBNjc0LVxcdUE2N0JcXHVBNjdGLVxcdUE2RUZcXHVBNzE3LVxcdUE3MUZcXHVBNzIyLVxcdUE3ODhcXHVBNzhCLVxcdUE3QURcXHVBN0IwLVxcdUE3QjdcXHVBN0Y3LVxcdUE4MDFcXHVBODAzLVxcdUE4MDVcXHVBODA3LVxcdUE4MEFcXHVBODBDLVxcdUE4MjdcXHVBODQwLVxcdUE4NzNcXHVBODgwLVxcdUE4QzNcXHVBOEYyLVxcdUE4RjdcXHVBOEZCXFx1QThGRFxcdUE5MEEtXFx1QTkyQVxcdUE5MzAtXFx1QTk1MlxcdUE5NjAtXFx1QTk3Q1xcdUE5ODAtXFx1QTlCMlxcdUE5QjQtXFx1QTlCRlxcdUE5Q0ZcXHVBOUUwLVxcdUE5RTRcXHVBOUU2LVxcdUE5RUZcXHVBOUZBLVxcdUE5RkVcXHVBQTAwLVxcdUFBMzZcXHVBQTQwLVxcdUFBNERcXHVBQTYwLVxcdUFBNzZcXHVBQTdBXFx1QUE3RS1cXHVBQUJFXFx1QUFDMFxcdUFBQzJcXHVBQURCLVxcdUFBRERcXHVBQUUwLVxcdUFBRUZcXHVBQUYyLVxcdUFBRjVcXHVBQjAxLVxcdUFCMDZcXHVBQjA5LVxcdUFCMEVcXHVBQjExLVxcdUFCMTZcXHVBQjIwLVxcdUFCMjZcXHVBQjI4LVxcdUFCMkVcXHVBQjMwLVxcdUFCNUFcXHVBQjVDLVxcdUFCNjVcXHVBQjcwLVxcdUFCRUFcXHVBQzAwLVxcdUQ3QTNcXHVEN0IwLVxcdUQ3QzZcXHVEN0NCLVxcdUQ3RkJcXHVGOTAwLVxcdUZBNkRcXHVGQTcwLVxcdUZBRDlcXHVGQjAwLVxcdUZCMDZcXHVGQjEzLVxcdUZCMTdcXHVGQjFELVxcdUZCMjhcXHVGQjJBLVxcdUZCMzZcXHVGQjM4LVxcdUZCM0NcXHVGQjNFXFx1RkI0MFxcdUZCNDFcXHVGQjQzXFx1RkI0NFxcdUZCNDYtXFx1RkJCMVxcdUZCRDMtXFx1RkQzRFxcdUZENTAtXFx1RkQ4RlxcdUZEOTItXFx1RkRDN1xcdUZERjAtXFx1RkRGQlxcdUZFNzAtXFx1RkU3NFxcdUZFNzYtXFx1RkVGQ1xcdUZGMjEtXFx1RkYzQVxcdUZGNDEtXFx1RkY1QVxcdUZGNjYtXFx1RkZCRVxcdUZGQzItXFx1RkZDN1xcdUZGQ0EtXFx1RkZDRlxcdUZGRDItXFx1RkZEN1xcdUZGREEtXFx1RkZEQycsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODZFW1xcdURDMDAtXFx1REMxRFxcdURDMjAtXFx1REZGRl18XFx1RDgwNFtcXHVEQzAwLVxcdURDNDVcXHVEQzgyLVxcdURDQjhcXHVEQ0QwLVxcdURDRThcXHVERDAwLVxcdUREMzJcXHVERDUwLVxcdURENzJcXHVERDc2XFx1REQ4MC1cXHVEREJGXFx1RERDMS1cXHVEREM0XFx1REREQVxcdURERENcXHVERTAwLVxcdURFMTFcXHVERTEzLVxcdURFMzRcXHVERTM3XFx1REU4MC1cXHVERTg2XFx1REU4OFxcdURFOEEtXFx1REU4RFxcdURFOEYtXFx1REU5RFxcdURFOUYtXFx1REVBOFxcdURFQjAtXFx1REVFOFxcdURGMDAtXFx1REYwM1xcdURGMDUtXFx1REYwQ1xcdURGMEZcXHVERjEwXFx1REYxMy1cXHVERjI4XFx1REYyQS1cXHVERjMwXFx1REYzMlxcdURGMzNcXHVERjM1LVxcdURGMzlcXHVERjNELVxcdURGNDRcXHVERjQ3XFx1REY0OFxcdURGNEJcXHVERjRDXFx1REY1MFxcdURGNTdcXHVERjVELVxcdURGNjNdfFxcdUQ4NkRbXFx1REMwMC1cXHVERjM0XFx1REY0MC1cXHVERkZGXXxcXHVEODY5W1xcdURDMDAtXFx1REVENlxcdURGMDAtXFx1REZGRl18XFx1RDgwM1tcXHVEQzAwLVxcdURDNDhcXHVEQzgwLVxcdURDQjJcXHVEQ0MwLVxcdURDRjJdfFxcdUQ4M0FbXFx1REMwMC1cXHVEQ0M0XXxcXHVEODFBW1xcdURDMDAtXFx1REUzOFxcdURFNDAtXFx1REU1RVxcdURFRDAtXFx1REVFRFxcdURGMDAtXFx1REYzNlxcdURGNDAtXFx1REY0M1xcdURGNjMtXFx1REY3N1xcdURGN0QtXFx1REY4Rl18XFx1RDgwMVtcXHVEQzAwLVxcdURDOURcXHVERDAwLVxcdUREMjdcXHVERDMwLVxcdURENjNcXHVERTAwLVxcdURGMzZcXHVERjQwLVxcdURGNTVcXHVERjYwLVxcdURGNjddfFxcdUQ4M0NbXFx1REQzMC1cXHVERDQ5XFx1REQ1MC1cXHVERDY5XFx1REQ3MC1cXHVERDg5XXxcXHVEODBEW1xcdURDMDAtXFx1REMyRV18XFx1RDg3RVtcXHVEQzAwLVxcdURFMURdfFtcXHVEODBDXFx1RDg0MC1cXHVEODY4XFx1RDg2QS1cXHVEODZDXFx1RDg2Ri1cXHVEODcyXVtcXHVEQzAwLVxcdURGRkZdfFxcdUQ4MzVbXFx1REMwMC1cXHVEQzU0XFx1REM1Ni1cXHVEQzlDXFx1REM5RVxcdURDOUZcXHVEQ0EyXFx1RENBNVxcdURDQTZcXHVEQ0E5LVxcdURDQUNcXHVEQ0FFLVxcdURDQjlcXHVEQ0JCXFx1RENCRC1cXHVEQ0MzXFx1RENDNS1cXHVERDA1XFx1REQwNy1cXHVERDBBXFx1REQwRC1cXHVERDE0XFx1REQxNi1cXHVERDFDXFx1REQxRS1cXHVERDM5XFx1REQzQi1cXHVERDNFXFx1REQ0MC1cXHVERDQ0XFx1REQ0NlxcdURENEEtXFx1REQ1MFxcdURENTItXFx1REVBNVxcdURFQTgtXFx1REVDMFxcdURFQzItXFx1REVEQVxcdURFREMtXFx1REVGQVxcdURFRkMtXFx1REYxNFxcdURGMTYtXFx1REYzNFxcdURGMzYtXFx1REY0RVxcdURGNTAtXFx1REY2RVxcdURGNzAtXFx1REY4OFxcdURGOEEtXFx1REZBOFxcdURGQUEtXFx1REZDMlxcdURGQzQtXFx1REZDQl18XFx1RDgyRltcXHVEQzAwLVxcdURDNkFcXHVEQzcwLVxcdURDN0NcXHVEQzgwLVxcdURDODhcXHVEQzkwLVxcdURDOTlcXHVEQzlFXXxcXHVEODA4W1xcdURDMDAtXFx1REY5OV18XFx1RDgzQltcXHVERTAwLVxcdURFMDNcXHVERTA1LVxcdURFMUZcXHVERTIxXFx1REUyMlxcdURFMjRcXHVERTI3XFx1REUyOS1cXHVERTMyXFx1REUzNC1cXHVERTM3XFx1REUzOVxcdURFM0JcXHVERTQyXFx1REU0N1xcdURFNDlcXHVERTRCXFx1REU0RC1cXHVERTRGXFx1REU1MVxcdURFNTJcXHVERTU0XFx1REU1N1xcdURFNTlcXHVERTVCXFx1REU1RFxcdURFNUZcXHVERTYxXFx1REU2MlxcdURFNjRcXHVERTY3LVxcdURFNkFcXHVERTZDLVxcdURFNzJcXHVERTc0LVxcdURFNzdcXHVERTc5LVxcdURFN0NcXHVERTdFXFx1REU4MC1cXHVERTg5XFx1REU4Qi1cXHVERTlCXFx1REVBMS1cXHVERUEzXFx1REVBNS1cXHVERUE5XFx1REVBQi1cXHVERUJCXXxcXHVEODA1W1xcdURDODAtXFx1RENDMVxcdURDQzRcXHVEQ0M1XFx1RENDN1xcdUREODAtXFx1RERCNVxcdUREQjgtXFx1RERCRVxcdURERDgtXFx1RERERFxcdURFMDAtXFx1REUzRVxcdURFNDBcXHVERTQ0XFx1REU4MC1cXHVERUI1XFx1REYwMC1cXHVERjE5XFx1REYxRC1cXHVERjJBXXxcXHVEODA5W1xcdURDMDAtXFx1REM2RVxcdURDODAtXFx1REQ0M118XFx1RDgwNltcXHVEQ0EwLVxcdURDREZcXHVEQ0ZGXFx1REVDMC1cXHVERUY4XXxcXHVEODAwW1xcdURDMDAtXFx1REMwQlxcdURDMEQtXFx1REMyNlxcdURDMjgtXFx1REMzQVxcdURDM0NcXHVEQzNEXFx1REMzRi1cXHVEQzREXFx1REM1MC1cXHVEQzVEXFx1REM4MC1cXHVEQ0ZBXFx1REQ0MC1cXHVERDc0XFx1REU4MC1cXHVERTlDXFx1REVBMC1cXHVERUQwXFx1REYwMC1cXHVERjFGXFx1REYzMC1cXHVERjRBXFx1REY1MC1cXHVERjdBXFx1REY4MC1cXHVERjlEXFx1REZBMC1cXHVERkMzXFx1REZDOC1cXHVERkNGXFx1REZEMS1cXHVERkQ1XXxcXHVEODAyW1xcdURDMDAtXFx1REMwNVxcdURDMDhcXHVEQzBBLVxcdURDMzVcXHVEQzM3XFx1REMzOFxcdURDM0NcXHVEQzNGLVxcdURDNTVcXHVEQzYwLVxcdURDNzZcXHVEQzgwLVxcdURDOUVcXHVEQ0UwLVxcdURDRjJcXHVEQ0Y0XFx1RENGNVxcdUREMDAtXFx1REQxNVxcdUREMjAtXFx1REQzOVxcdUREODAtXFx1RERCN1xcdUREQkVcXHVEREJGXFx1REUwMC1cXHVERTAzXFx1REUwNVxcdURFMDZcXHVERTBDLVxcdURFMTNcXHVERTE1LVxcdURFMTdcXHVERTE5LVxcdURFMzNcXHVERTYwLVxcdURFN0NcXHVERTgwLVxcdURFOUNcXHVERUMwLVxcdURFQzdcXHVERUM5LVxcdURFRTRcXHVERjAwLVxcdURGMzVcXHVERjQwLVxcdURGNTVcXHVERjYwLVxcdURGNzJcXHVERjgwLVxcdURGOTFdfFxcdUQ4MTFbXFx1REMwMC1cXHVERTQ2XXxcXHVEODJDW1xcdURDMDBcXHVEQzAxXXxcXHVEODFCW1xcdURGMDAtXFx1REY0NFxcdURGNTAtXFx1REY3RVxcdURGOTMtXFx1REY5Rl18XFx1RDg3M1tcXHVEQzAwLVxcdURFQTFdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnQW55JyxcbiAgICAgICAgICAgIGlzQm1wTGFzdDogdHJ1ZSxcbiAgICAgICAgICAgIGJtcDogJ1xcMC1cXHVGRkZGJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1tcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdEZWZhdWx0X0lnbm9yYWJsZV9Db2RlX1BvaW50JyxcbiAgICAgICAgICAgIGJtcDogJ1xceEFEXFx1MDM0RlxcdTA2MUNcXHUxMTVGXFx1MTE2MFxcdTE3QjRcXHUxN0I1XFx1MTgwQi1cXHUxODBFXFx1MjAwQi1cXHUyMDBGXFx1MjAyQS1cXHUyMDJFXFx1MjA2MC1cXHUyMDZGXFx1MzE2NFxcdUZFMDAtXFx1RkUwRlxcdUZFRkZcXHVGRkEwXFx1RkZGMC1cXHVGRkY4JyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1tcXHVEQjQwLVxcdURCNDNdW1xcdURDMDAtXFx1REZGRl18XFx1RDgzNFtcXHVERDczLVxcdUREN0FdfFxcdUQ4MkZbXFx1RENBMC1cXHVEQ0EzXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0xvd2VyY2FzZScsXG4gICAgICAgICAgICBibXA6ICdhLXpcXHhBQVxceEI1XFx4QkFcXHhERi1cXHhGNlxceEY4LVxceEZGXFx1MDEwMVxcdTAxMDNcXHUwMTA1XFx1MDEwN1xcdTAxMDlcXHUwMTBCXFx1MDEwRFxcdTAxMEZcXHUwMTExXFx1MDExM1xcdTAxMTVcXHUwMTE3XFx1MDExOVxcdTAxMUJcXHUwMTFEXFx1MDExRlxcdTAxMjFcXHUwMTIzXFx1MDEyNVxcdTAxMjdcXHUwMTI5XFx1MDEyQlxcdTAxMkRcXHUwMTJGXFx1MDEzMVxcdTAxMzNcXHUwMTM1XFx1MDEzN1xcdTAxMzhcXHUwMTNBXFx1MDEzQ1xcdTAxM0VcXHUwMTQwXFx1MDE0MlxcdTAxNDRcXHUwMTQ2XFx1MDE0OFxcdTAxNDlcXHUwMTRCXFx1MDE0RFxcdTAxNEZcXHUwMTUxXFx1MDE1M1xcdTAxNTVcXHUwMTU3XFx1MDE1OVxcdTAxNUJcXHUwMTVEXFx1MDE1RlxcdTAxNjFcXHUwMTYzXFx1MDE2NVxcdTAxNjdcXHUwMTY5XFx1MDE2QlxcdTAxNkRcXHUwMTZGXFx1MDE3MVxcdTAxNzNcXHUwMTc1XFx1MDE3N1xcdTAxN0FcXHUwMTdDXFx1MDE3RS1cXHUwMTgwXFx1MDE4M1xcdTAxODVcXHUwMTg4XFx1MDE4Q1xcdTAxOERcXHUwMTkyXFx1MDE5NVxcdTAxOTktXFx1MDE5QlxcdTAxOUVcXHUwMUExXFx1MDFBM1xcdTAxQTVcXHUwMUE4XFx1MDFBQVxcdTAxQUJcXHUwMUFEXFx1MDFCMFxcdTAxQjRcXHUwMUI2XFx1MDFCOVxcdTAxQkFcXHUwMUJELVxcdTAxQkZcXHUwMUM2XFx1MDFDOVxcdTAxQ0NcXHUwMUNFXFx1MDFEMFxcdTAxRDJcXHUwMUQ0XFx1MDFENlxcdTAxRDhcXHUwMURBXFx1MDFEQ1xcdTAxRERcXHUwMURGXFx1MDFFMVxcdTAxRTNcXHUwMUU1XFx1MDFFN1xcdTAxRTlcXHUwMUVCXFx1MDFFRFxcdTAxRUZcXHUwMUYwXFx1MDFGM1xcdTAxRjVcXHUwMUY5XFx1MDFGQlxcdTAxRkRcXHUwMUZGXFx1MDIwMVxcdTAyMDNcXHUwMjA1XFx1MDIwN1xcdTAyMDlcXHUwMjBCXFx1MDIwRFxcdTAyMEZcXHUwMjExXFx1MDIxM1xcdTAyMTVcXHUwMjE3XFx1MDIxOVxcdTAyMUJcXHUwMjFEXFx1MDIxRlxcdTAyMjFcXHUwMjIzXFx1MDIyNVxcdTAyMjdcXHUwMjI5XFx1MDIyQlxcdTAyMkRcXHUwMjJGXFx1MDIzMVxcdTAyMzMtXFx1MDIzOVxcdTAyM0NcXHUwMjNGXFx1MDI0MFxcdTAyNDJcXHUwMjQ3XFx1MDI0OVxcdTAyNEJcXHUwMjREXFx1MDI0Ri1cXHUwMjkzXFx1MDI5NS1cXHUwMkI4XFx1MDJDMFxcdTAyQzFcXHUwMkUwLVxcdTAyRTRcXHUwMzQ1XFx1MDM3MVxcdTAzNzNcXHUwMzc3XFx1MDM3QS1cXHUwMzdEXFx1MDM5MFxcdTAzQUMtXFx1MDNDRVxcdTAzRDBcXHUwM0QxXFx1MDNENS1cXHUwM0Q3XFx1MDNEOVxcdTAzREJcXHUwM0REXFx1MDNERlxcdTAzRTFcXHUwM0UzXFx1MDNFNVxcdTAzRTdcXHUwM0U5XFx1MDNFQlxcdTAzRURcXHUwM0VGLVxcdTAzRjNcXHUwM0Y1XFx1MDNGOFxcdTAzRkJcXHUwM0ZDXFx1MDQzMC1cXHUwNDVGXFx1MDQ2MVxcdTA0NjNcXHUwNDY1XFx1MDQ2N1xcdTA0NjlcXHUwNDZCXFx1MDQ2RFxcdTA0NkZcXHUwNDcxXFx1MDQ3M1xcdTA0NzVcXHUwNDc3XFx1MDQ3OVxcdTA0N0JcXHUwNDdEXFx1MDQ3RlxcdTA0ODFcXHUwNDhCXFx1MDQ4RFxcdTA0OEZcXHUwNDkxXFx1MDQ5M1xcdTA0OTVcXHUwNDk3XFx1MDQ5OVxcdTA0OUJcXHUwNDlEXFx1MDQ5RlxcdTA0QTFcXHUwNEEzXFx1MDRBNVxcdTA0QTdcXHUwNEE5XFx1MDRBQlxcdTA0QURcXHUwNEFGXFx1MDRCMVxcdTA0QjNcXHUwNEI1XFx1MDRCN1xcdTA0QjlcXHUwNEJCXFx1MDRCRFxcdTA0QkZcXHUwNEMyXFx1MDRDNFxcdTA0QzZcXHUwNEM4XFx1MDRDQVxcdTA0Q0NcXHUwNENFXFx1MDRDRlxcdTA0RDFcXHUwNEQzXFx1MDRENVxcdTA0RDdcXHUwNEQ5XFx1MDREQlxcdTA0RERcXHUwNERGXFx1MDRFMVxcdTA0RTNcXHUwNEU1XFx1MDRFN1xcdTA0RTlcXHUwNEVCXFx1MDRFRFxcdTA0RUZcXHUwNEYxXFx1MDRGM1xcdTA0RjVcXHUwNEY3XFx1MDRGOVxcdTA0RkJcXHUwNEZEXFx1MDRGRlxcdTA1MDFcXHUwNTAzXFx1MDUwNVxcdTA1MDdcXHUwNTA5XFx1MDUwQlxcdTA1MERcXHUwNTBGXFx1MDUxMVxcdTA1MTNcXHUwNTE1XFx1MDUxN1xcdTA1MTlcXHUwNTFCXFx1MDUxRFxcdTA1MUZcXHUwNTIxXFx1MDUyM1xcdTA1MjVcXHUwNTI3XFx1MDUyOVxcdTA1MkJcXHUwNTJEXFx1MDUyRlxcdTA1NjEtXFx1MDU4N1xcdTEzRjgtXFx1MTNGRFxcdTFEMDAtXFx1MURCRlxcdTFFMDFcXHUxRTAzXFx1MUUwNVxcdTFFMDdcXHUxRTA5XFx1MUUwQlxcdTFFMERcXHUxRTBGXFx1MUUxMVxcdTFFMTNcXHUxRTE1XFx1MUUxN1xcdTFFMTlcXHUxRTFCXFx1MUUxRFxcdTFFMUZcXHUxRTIxXFx1MUUyM1xcdTFFMjVcXHUxRTI3XFx1MUUyOVxcdTFFMkJcXHUxRTJEXFx1MUUyRlxcdTFFMzFcXHUxRTMzXFx1MUUzNVxcdTFFMzdcXHUxRTM5XFx1MUUzQlxcdTFFM0RcXHUxRTNGXFx1MUU0MVxcdTFFNDNcXHUxRTQ1XFx1MUU0N1xcdTFFNDlcXHUxRTRCXFx1MUU0RFxcdTFFNEZcXHUxRTUxXFx1MUU1M1xcdTFFNTVcXHUxRTU3XFx1MUU1OVxcdTFFNUJcXHUxRTVEXFx1MUU1RlxcdTFFNjFcXHUxRTYzXFx1MUU2NVxcdTFFNjdcXHUxRTY5XFx1MUU2QlxcdTFFNkRcXHUxRTZGXFx1MUU3MVxcdTFFNzNcXHUxRTc1XFx1MUU3N1xcdTFFNzlcXHUxRTdCXFx1MUU3RFxcdTFFN0ZcXHUxRTgxXFx1MUU4M1xcdTFFODVcXHUxRTg3XFx1MUU4OVxcdTFFOEJcXHUxRThEXFx1MUU4RlxcdTFFOTFcXHUxRTkzXFx1MUU5NS1cXHUxRTlEXFx1MUU5RlxcdTFFQTFcXHUxRUEzXFx1MUVBNVxcdTFFQTdcXHUxRUE5XFx1MUVBQlxcdTFFQURcXHUxRUFGXFx1MUVCMVxcdTFFQjNcXHUxRUI1XFx1MUVCN1xcdTFFQjlcXHUxRUJCXFx1MUVCRFxcdTFFQkZcXHUxRUMxXFx1MUVDM1xcdTFFQzVcXHUxRUM3XFx1MUVDOVxcdTFFQ0JcXHUxRUNEXFx1MUVDRlxcdTFFRDFcXHUxRUQzXFx1MUVENVxcdTFFRDdcXHUxRUQ5XFx1MUVEQlxcdTFFRERcXHUxRURGXFx1MUVFMVxcdTFFRTNcXHUxRUU1XFx1MUVFN1xcdTFFRTlcXHUxRUVCXFx1MUVFRFxcdTFFRUZcXHUxRUYxXFx1MUVGM1xcdTFFRjVcXHUxRUY3XFx1MUVGOVxcdTFFRkJcXHUxRUZEXFx1MUVGRi1cXHUxRjA3XFx1MUYxMC1cXHUxRjE1XFx1MUYyMC1cXHUxRjI3XFx1MUYzMC1cXHUxRjM3XFx1MUY0MC1cXHUxRjQ1XFx1MUY1MC1cXHUxRjU3XFx1MUY2MC1cXHUxRjY3XFx1MUY3MC1cXHUxRjdEXFx1MUY4MC1cXHUxRjg3XFx1MUY5MC1cXHUxRjk3XFx1MUZBMC1cXHUxRkE3XFx1MUZCMC1cXHUxRkI0XFx1MUZCNlxcdTFGQjdcXHUxRkJFXFx1MUZDMi1cXHUxRkM0XFx1MUZDNlxcdTFGQzdcXHUxRkQwLVxcdTFGRDNcXHUxRkQ2XFx1MUZEN1xcdTFGRTAtXFx1MUZFN1xcdTFGRjItXFx1MUZGNFxcdTFGRjZcXHUxRkY3XFx1MjA3MVxcdTIwN0ZcXHUyMDkwLVxcdTIwOUNcXHUyMTBBXFx1MjEwRVxcdTIxMEZcXHUyMTEzXFx1MjEyRlxcdTIxMzRcXHUyMTM5XFx1MjEzQ1xcdTIxM0RcXHUyMTQ2LVxcdTIxNDlcXHUyMTRFXFx1MjE3MC1cXHUyMTdGXFx1MjE4NFxcdTI0RDAtXFx1MjRFOVxcdTJDMzAtXFx1MkM1RVxcdTJDNjFcXHUyQzY1XFx1MkM2NlxcdTJDNjhcXHUyQzZBXFx1MkM2Q1xcdTJDNzFcXHUyQzczXFx1MkM3NFxcdTJDNzYtXFx1MkM3RFxcdTJDODFcXHUyQzgzXFx1MkM4NVxcdTJDODdcXHUyQzg5XFx1MkM4QlxcdTJDOERcXHUyQzhGXFx1MkM5MVxcdTJDOTNcXHUyQzk1XFx1MkM5N1xcdTJDOTlcXHUyQzlCXFx1MkM5RFxcdTJDOUZcXHUyQ0ExXFx1MkNBM1xcdTJDQTVcXHUyQ0E3XFx1MkNBOVxcdTJDQUJcXHUyQ0FEXFx1MkNBRlxcdTJDQjFcXHUyQ0IzXFx1MkNCNVxcdTJDQjdcXHUyQ0I5XFx1MkNCQlxcdTJDQkRcXHUyQ0JGXFx1MkNDMVxcdTJDQzNcXHUyQ0M1XFx1MkNDN1xcdTJDQzlcXHUyQ0NCXFx1MkNDRFxcdTJDQ0ZcXHUyQ0QxXFx1MkNEM1xcdTJDRDVcXHUyQ0Q3XFx1MkNEOVxcdTJDREJcXHUyQ0REXFx1MkNERlxcdTJDRTFcXHUyQ0UzXFx1MkNFNFxcdTJDRUNcXHUyQ0VFXFx1MkNGM1xcdTJEMDAtXFx1MkQyNVxcdTJEMjdcXHUyRDJEXFx1QTY0MVxcdUE2NDNcXHVBNjQ1XFx1QTY0N1xcdUE2NDlcXHVBNjRCXFx1QTY0RFxcdUE2NEZcXHVBNjUxXFx1QTY1M1xcdUE2NTVcXHVBNjU3XFx1QTY1OVxcdUE2NUJcXHVBNjVEXFx1QTY1RlxcdUE2NjFcXHVBNjYzXFx1QTY2NVxcdUE2NjdcXHVBNjY5XFx1QTY2QlxcdUE2NkRcXHVBNjgxXFx1QTY4M1xcdUE2ODVcXHVBNjg3XFx1QTY4OVxcdUE2OEJcXHVBNjhEXFx1QTY4RlxcdUE2OTFcXHVBNjkzXFx1QTY5NVxcdUE2OTdcXHVBNjk5XFx1QTY5Qi1cXHVBNjlEXFx1QTcyM1xcdUE3MjVcXHVBNzI3XFx1QTcyOVxcdUE3MkJcXHVBNzJEXFx1QTcyRi1cXHVBNzMxXFx1QTczM1xcdUE3MzVcXHVBNzM3XFx1QTczOVxcdUE3M0JcXHVBNzNEXFx1QTczRlxcdUE3NDFcXHVBNzQzXFx1QTc0NVxcdUE3NDdcXHVBNzQ5XFx1QTc0QlxcdUE3NERcXHVBNzRGXFx1QTc1MVxcdUE3NTNcXHVBNzU1XFx1QTc1N1xcdUE3NTlcXHVBNzVCXFx1QTc1RFxcdUE3NUZcXHVBNzYxXFx1QTc2M1xcdUE3NjVcXHVBNzY3XFx1QTc2OVxcdUE3NkJcXHVBNzZEXFx1QTc2Ri1cXHVBNzc4XFx1QTc3QVxcdUE3N0NcXHVBNzdGXFx1QTc4MVxcdUE3ODNcXHVBNzg1XFx1QTc4N1xcdUE3OENcXHVBNzhFXFx1QTc5MVxcdUE3OTMtXFx1QTc5NVxcdUE3OTdcXHVBNzk5XFx1QTc5QlxcdUE3OURcXHVBNzlGXFx1QTdBMVxcdUE3QTNcXHVBN0E1XFx1QTdBN1xcdUE3QTlcXHVBN0I1XFx1QTdCN1xcdUE3RjgtXFx1QTdGQVxcdUFCMzAtXFx1QUI1QVxcdUFCNUMtXFx1QUI2NVxcdUFCNzAtXFx1QUJCRlxcdUZCMDAtXFx1RkIwNlxcdUZCMTMtXFx1RkIxN1xcdUZGNDEtXFx1RkY1QScsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAzW1xcdURDQzAtXFx1RENGMl18XFx1RDgzNVtcXHVEQzFBLVxcdURDMzNcXHVEQzRFLVxcdURDNTRcXHVEQzU2LVxcdURDNjdcXHVEQzgyLVxcdURDOUJcXHVEQ0I2LVxcdURDQjlcXHVEQ0JCXFx1RENCRC1cXHVEQ0MzXFx1RENDNS1cXHVEQ0NGXFx1RENFQS1cXHVERDAzXFx1REQxRS1cXHVERDM3XFx1REQ1Mi1cXHVERDZCXFx1REQ4Ni1cXHVERDlGXFx1RERCQS1cXHVEREQzXFx1RERFRS1cXHVERTA3XFx1REUyMi1cXHVERTNCXFx1REU1Ni1cXHVERTZGXFx1REU4QS1cXHVERUE1XFx1REVDMi1cXHVERURBXFx1REVEQy1cXHVERUUxXFx1REVGQy1cXHVERjE0XFx1REYxNi1cXHVERjFCXFx1REYzNi1cXHVERjRFXFx1REY1MC1cXHVERjU1XFx1REY3MC1cXHVERjg4XFx1REY4QS1cXHVERjhGXFx1REZBQS1cXHVERkMyXFx1REZDNC1cXHVERkM5XFx1REZDQl18XFx1RDgwMVtcXHVEQzI4LVxcdURDNEZdfFxcdUQ4MDZbXFx1RENDMC1cXHVEQ0RGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ05vbmNoYXJhY3Rlcl9Db2RlX1BvaW50JyxcbiAgICAgICAgICAgIGJtcDogJ1xcdUZERDAtXFx1RkRFRlxcdUZGRkVcXHVGRkZGJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1tcXHVEQjNGXFx1REI3RlxcdURCQkZcXHVEQkZGXFx1RDgzRlxcdUQ4N0ZcXHVEOEJGXFx1REFGRlxcdUQ5N0ZcXHVEOUJGXFx1RDlGRlxcdURBM0ZcXHVEOEZGXFx1REFCRlxcdURBN0ZcXHVEOTNGXVtcXHVERkZFXFx1REZGRl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdVcHBlcmNhc2UnLFxuICAgICAgICAgICAgYm1wOiAnQS1aXFx4QzAtXFx4RDZcXHhEOC1cXHhERVxcdTAxMDBcXHUwMTAyXFx1MDEwNFxcdTAxMDZcXHUwMTA4XFx1MDEwQVxcdTAxMENcXHUwMTBFXFx1MDExMFxcdTAxMTJcXHUwMTE0XFx1MDExNlxcdTAxMThcXHUwMTFBXFx1MDExQ1xcdTAxMUVcXHUwMTIwXFx1MDEyMlxcdTAxMjRcXHUwMTI2XFx1MDEyOFxcdTAxMkFcXHUwMTJDXFx1MDEyRVxcdTAxMzBcXHUwMTMyXFx1MDEzNFxcdTAxMzZcXHUwMTM5XFx1MDEzQlxcdTAxM0RcXHUwMTNGXFx1MDE0MVxcdTAxNDNcXHUwMTQ1XFx1MDE0N1xcdTAxNEFcXHUwMTRDXFx1MDE0RVxcdTAxNTBcXHUwMTUyXFx1MDE1NFxcdTAxNTZcXHUwMTU4XFx1MDE1QVxcdTAxNUNcXHUwMTVFXFx1MDE2MFxcdTAxNjJcXHUwMTY0XFx1MDE2NlxcdTAxNjhcXHUwMTZBXFx1MDE2Q1xcdTAxNkVcXHUwMTcwXFx1MDE3MlxcdTAxNzRcXHUwMTc2XFx1MDE3OFxcdTAxNzlcXHUwMTdCXFx1MDE3RFxcdTAxODFcXHUwMTgyXFx1MDE4NFxcdTAxODZcXHUwMTg3XFx1MDE4OS1cXHUwMThCXFx1MDE4RS1cXHUwMTkxXFx1MDE5M1xcdTAxOTRcXHUwMTk2LVxcdTAxOThcXHUwMTlDXFx1MDE5RFxcdTAxOUZcXHUwMUEwXFx1MDFBMlxcdTAxQTRcXHUwMUE2XFx1MDFBN1xcdTAxQTlcXHUwMUFDXFx1MDFBRVxcdTAxQUZcXHUwMUIxLVxcdTAxQjNcXHUwMUI1XFx1MDFCN1xcdTAxQjhcXHUwMUJDXFx1MDFDNFxcdTAxQzdcXHUwMUNBXFx1MDFDRFxcdTAxQ0ZcXHUwMUQxXFx1MDFEM1xcdTAxRDVcXHUwMUQ3XFx1MDFEOVxcdTAxREJcXHUwMURFXFx1MDFFMFxcdTAxRTJcXHUwMUU0XFx1MDFFNlxcdTAxRThcXHUwMUVBXFx1MDFFQ1xcdTAxRUVcXHUwMUYxXFx1MDFGNFxcdTAxRjYtXFx1MDFGOFxcdTAxRkFcXHUwMUZDXFx1MDFGRVxcdTAyMDBcXHUwMjAyXFx1MDIwNFxcdTAyMDZcXHUwMjA4XFx1MDIwQVxcdTAyMENcXHUwMjBFXFx1MDIxMFxcdTAyMTJcXHUwMjE0XFx1MDIxNlxcdTAyMThcXHUwMjFBXFx1MDIxQ1xcdTAyMUVcXHUwMjIwXFx1MDIyMlxcdTAyMjRcXHUwMjI2XFx1MDIyOFxcdTAyMkFcXHUwMjJDXFx1MDIyRVxcdTAyMzBcXHUwMjMyXFx1MDIzQVxcdTAyM0JcXHUwMjNEXFx1MDIzRVxcdTAyNDFcXHUwMjQzLVxcdTAyNDZcXHUwMjQ4XFx1MDI0QVxcdTAyNENcXHUwMjRFXFx1MDM3MFxcdTAzNzJcXHUwMzc2XFx1MDM3RlxcdTAzODZcXHUwMzg4LVxcdTAzOEFcXHUwMzhDXFx1MDM4RVxcdTAzOEZcXHUwMzkxLVxcdTAzQTFcXHUwM0EzLVxcdTAzQUJcXHUwM0NGXFx1MDNEMi1cXHUwM0Q0XFx1MDNEOFxcdTAzREFcXHUwM0RDXFx1MDNERVxcdTAzRTBcXHUwM0UyXFx1MDNFNFxcdTAzRTZcXHUwM0U4XFx1MDNFQVxcdTAzRUNcXHUwM0VFXFx1MDNGNFxcdTAzRjdcXHUwM0Y5XFx1MDNGQVxcdTAzRkQtXFx1MDQyRlxcdTA0NjBcXHUwNDYyXFx1MDQ2NFxcdTA0NjZcXHUwNDY4XFx1MDQ2QVxcdTA0NkNcXHUwNDZFXFx1MDQ3MFxcdTA0NzJcXHUwNDc0XFx1MDQ3NlxcdTA0NzhcXHUwNDdBXFx1MDQ3Q1xcdTA0N0VcXHUwNDgwXFx1MDQ4QVxcdTA0OENcXHUwNDhFXFx1MDQ5MFxcdTA0OTJcXHUwNDk0XFx1MDQ5NlxcdTA0OThcXHUwNDlBXFx1MDQ5Q1xcdTA0OUVcXHUwNEEwXFx1MDRBMlxcdTA0QTRcXHUwNEE2XFx1MDRBOFxcdTA0QUFcXHUwNEFDXFx1MDRBRVxcdTA0QjBcXHUwNEIyXFx1MDRCNFxcdTA0QjZcXHUwNEI4XFx1MDRCQVxcdTA0QkNcXHUwNEJFXFx1MDRDMFxcdTA0QzFcXHUwNEMzXFx1MDRDNVxcdTA0QzdcXHUwNEM5XFx1MDRDQlxcdTA0Q0RcXHUwNEQwXFx1MDREMlxcdTA0RDRcXHUwNEQ2XFx1MDREOFxcdTA0REFcXHUwNERDXFx1MDRERVxcdTA0RTBcXHUwNEUyXFx1MDRFNFxcdTA0RTZcXHUwNEU4XFx1MDRFQVxcdTA0RUNcXHUwNEVFXFx1MDRGMFxcdTA0RjJcXHUwNEY0XFx1MDRGNlxcdTA0RjhcXHUwNEZBXFx1MDRGQ1xcdTA0RkVcXHUwNTAwXFx1MDUwMlxcdTA1MDRcXHUwNTA2XFx1MDUwOFxcdTA1MEFcXHUwNTBDXFx1MDUwRVxcdTA1MTBcXHUwNTEyXFx1MDUxNFxcdTA1MTZcXHUwNTE4XFx1MDUxQVxcdTA1MUNcXHUwNTFFXFx1MDUyMFxcdTA1MjJcXHUwNTI0XFx1MDUyNlxcdTA1MjhcXHUwNTJBXFx1MDUyQ1xcdTA1MkVcXHUwNTMxLVxcdTA1NTZcXHUxMEEwLVxcdTEwQzVcXHUxMEM3XFx1MTBDRFxcdTEzQTAtXFx1MTNGNVxcdTFFMDBcXHUxRTAyXFx1MUUwNFxcdTFFMDZcXHUxRTA4XFx1MUUwQVxcdTFFMENcXHUxRTBFXFx1MUUxMFxcdTFFMTJcXHUxRTE0XFx1MUUxNlxcdTFFMThcXHUxRTFBXFx1MUUxQ1xcdTFFMUVcXHUxRTIwXFx1MUUyMlxcdTFFMjRcXHUxRTI2XFx1MUUyOFxcdTFFMkFcXHUxRTJDXFx1MUUyRVxcdTFFMzBcXHUxRTMyXFx1MUUzNFxcdTFFMzZcXHUxRTM4XFx1MUUzQVxcdTFFM0NcXHUxRTNFXFx1MUU0MFxcdTFFNDJcXHUxRTQ0XFx1MUU0NlxcdTFFNDhcXHUxRTRBXFx1MUU0Q1xcdTFFNEVcXHUxRTUwXFx1MUU1MlxcdTFFNTRcXHUxRTU2XFx1MUU1OFxcdTFFNUFcXHUxRTVDXFx1MUU1RVxcdTFFNjBcXHUxRTYyXFx1MUU2NFxcdTFFNjZcXHUxRTY4XFx1MUU2QVxcdTFFNkNcXHUxRTZFXFx1MUU3MFxcdTFFNzJcXHUxRTc0XFx1MUU3NlxcdTFFNzhcXHUxRTdBXFx1MUU3Q1xcdTFFN0VcXHUxRTgwXFx1MUU4MlxcdTFFODRcXHUxRTg2XFx1MUU4OFxcdTFFOEFcXHUxRThDXFx1MUU4RVxcdTFFOTBcXHUxRTkyXFx1MUU5NFxcdTFFOUVcXHUxRUEwXFx1MUVBMlxcdTFFQTRcXHUxRUE2XFx1MUVBOFxcdTFFQUFcXHUxRUFDXFx1MUVBRVxcdTFFQjBcXHUxRUIyXFx1MUVCNFxcdTFFQjZcXHUxRUI4XFx1MUVCQVxcdTFFQkNcXHUxRUJFXFx1MUVDMFxcdTFFQzJcXHUxRUM0XFx1MUVDNlxcdTFFQzhcXHUxRUNBXFx1MUVDQ1xcdTFFQ0VcXHUxRUQwXFx1MUVEMlxcdTFFRDRcXHUxRUQ2XFx1MUVEOFxcdTFFREFcXHUxRURDXFx1MUVERVxcdTFFRTBcXHUxRUUyXFx1MUVFNFxcdTFFRTZcXHUxRUU4XFx1MUVFQVxcdTFFRUNcXHUxRUVFXFx1MUVGMFxcdTFFRjJcXHUxRUY0XFx1MUVGNlxcdTFFRjhcXHUxRUZBXFx1MUVGQ1xcdTFFRkVcXHUxRjA4LVxcdTFGMEZcXHUxRjE4LVxcdTFGMURcXHUxRjI4LVxcdTFGMkZcXHUxRjM4LVxcdTFGM0ZcXHUxRjQ4LVxcdTFGNERcXHUxRjU5XFx1MUY1QlxcdTFGNURcXHUxRjVGXFx1MUY2OC1cXHUxRjZGXFx1MUZCOC1cXHUxRkJCXFx1MUZDOC1cXHUxRkNCXFx1MUZEOC1cXHUxRkRCXFx1MUZFOC1cXHUxRkVDXFx1MUZGOC1cXHUxRkZCXFx1MjEwMlxcdTIxMDdcXHUyMTBCLVxcdTIxMERcXHUyMTEwLVxcdTIxMTJcXHUyMTE1XFx1MjExOS1cXHUyMTFEXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyQS1cXHUyMTJEXFx1MjEzMC1cXHUyMTMzXFx1MjEzRVxcdTIxM0ZcXHUyMTQ1XFx1MjE2MC1cXHUyMTZGXFx1MjE4M1xcdTI0QjYtXFx1MjRDRlxcdTJDMDAtXFx1MkMyRVxcdTJDNjBcXHUyQzYyLVxcdTJDNjRcXHUyQzY3XFx1MkM2OVxcdTJDNkJcXHUyQzZELVxcdTJDNzBcXHUyQzcyXFx1MkM3NVxcdTJDN0UtXFx1MkM4MFxcdTJDODJcXHUyQzg0XFx1MkM4NlxcdTJDODhcXHUyQzhBXFx1MkM4Q1xcdTJDOEVcXHUyQzkwXFx1MkM5MlxcdTJDOTRcXHUyQzk2XFx1MkM5OFxcdTJDOUFcXHUyQzlDXFx1MkM5RVxcdTJDQTBcXHUyQ0EyXFx1MkNBNFxcdTJDQTZcXHUyQ0E4XFx1MkNBQVxcdTJDQUNcXHUyQ0FFXFx1MkNCMFxcdTJDQjJcXHUyQ0I0XFx1MkNCNlxcdTJDQjhcXHUyQ0JBXFx1MkNCQ1xcdTJDQkVcXHUyQ0MwXFx1MkNDMlxcdTJDQzRcXHUyQ0M2XFx1MkNDOFxcdTJDQ0FcXHUyQ0NDXFx1MkNDRVxcdTJDRDBcXHUyQ0QyXFx1MkNENFxcdTJDRDZcXHUyQ0Q4XFx1MkNEQVxcdTJDRENcXHUyQ0RFXFx1MkNFMFxcdTJDRTJcXHUyQ0VCXFx1MkNFRFxcdTJDRjJcXHVBNjQwXFx1QTY0MlxcdUE2NDRcXHVBNjQ2XFx1QTY0OFxcdUE2NEFcXHVBNjRDXFx1QTY0RVxcdUE2NTBcXHVBNjUyXFx1QTY1NFxcdUE2NTZcXHVBNjU4XFx1QTY1QVxcdUE2NUNcXHVBNjVFXFx1QTY2MFxcdUE2NjJcXHVBNjY0XFx1QTY2NlxcdUE2NjhcXHVBNjZBXFx1QTY2Q1xcdUE2ODBcXHVBNjgyXFx1QTY4NFxcdUE2ODZcXHVBNjg4XFx1QTY4QVxcdUE2OENcXHVBNjhFXFx1QTY5MFxcdUE2OTJcXHVBNjk0XFx1QTY5NlxcdUE2OThcXHVBNjlBXFx1QTcyMlxcdUE3MjRcXHVBNzI2XFx1QTcyOFxcdUE3MkFcXHVBNzJDXFx1QTcyRVxcdUE3MzJcXHVBNzM0XFx1QTczNlxcdUE3MzhcXHVBNzNBXFx1QTczQ1xcdUE3M0VcXHVBNzQwXFx1QTc0MlxcdUE3NDRcXHVBNzQ2XFx1QTc0OFxcdUE3NEFcXHVBNzRDXFx1QTc0RVxcdUE3NTBcXHVBNzUyXFx1QTc1NFxcdUE3NTZcXHVBNzU4XFx1QTc1QVxcdUE3NUNcXHVBNzVFXFx1QTc2MFxcdUE3NjJcXHVBNzY0XFx1QTc2NlxcdUE3NjhcXHVBNzZBXFx1QTc2Q1xcdUE3NkVcXHVBNzc5XFx1QTc3QlxcdUE3N0RcXHVBNzdFXFx1QTc4MFxcdUE3ODJcXHVBNzg0XFx1QTc4NlxcdUE3OEJcXHVBNzhEXFx1QTc5MFxcdUE3OTJcXHVBNzk2XFx1QTc5OFxcdUE3OUFcXHVBNzlDXFx1QTc5RVxcdUE3QTBcXHVBN0EyXFx1QTdBNFxcdUE3QTZcXHVBN0E4XFx1QTdBQS1cXHVBN0FEXFx1QTdCMC1cXHVBN0I0XFx1QTdCNlxcdUZGMjEtXFx1RkYzQScsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODA2W1xcdURDQTAtXFx1RENCRl18XFx1RDgwM1tcXHVEQzgwLVxcdURDQjJdfFxcdUQ4MzVbXFx1REMwMC1cXHVEQzE5XFx1REMzNC1cXHVEQzREXFx1REM2OC1cXHVEQzgxXFx1REM5Q1xcdURDOUVcXHVEQzlGXFx1RENBMlxcdURDQTVcXHVEQ0E2XFx1RENBOS1cXHVEQ0FDXFx1RENBRS1cXHVEQ0I1XFx1RENEMC1cXHVEQ0U5XFx1REQwNFxcdUREMDVcXHVERDA3LVxcdUREMEFcXHVERDBELVxcdUREMTRcXHVERDE2LVxcdUREMUNcXHVERDM4XFx1REQzOVxcdUREM0ItXFx1REQzRVxcdURENDAtXFx1REQ0NFxcdURENDZcXHVERDRBLVxcdURENTBcXHVERDZDLVxcdUREODVcXHVEREEwLVxcdUREQjlcXHVEREQ0LVxcdURERURcXHVERTA4LVxcdURFMjFcXHVERTNDLVxcdURFNTVcXHVERTcwLVxcdURFODlcXHVERUE4LVxcdURFQzBcXHVERUUyLVxcdURFRkFcXHVERjFDLVxcdURGMzRcXHVERjU2LVxcdURGNkVcXHVERjkwLVxcdURGQThcXHVERkNBXXxcXHVEODAxW1xcdURDMDAtXFx1REMyN118XFx1RDgzQ1tcXHVERDMwLVxcdURENDlcXHVERDUwLVxcdURENjlcXHVERDcwLVxcdUREODldJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnV2hpdGVfU3BhY2UnLFxuICAgICAgICAgICAgYm1wOiAnXFx4MDktXFx4MERcXHgyMFxceDg1XFx4QTBcXHUxNjgwXFx1MjAwMC1cXHUyMDBBXFx1MjAyOFxcdTIwMjlcXHUyMDJGXFx1MjA1RlxcdTMwMDAnXG4gICAgICAgIH1cbiAgICBdO1xuXG4gICAgLy8gQWRkIG5vbi1nZW5lcmF0ZWQgZGF0YVxuICAgIHVuaWNvZGVEYXRhLnB1c2goe1xuICAgICAgICBuYW1lOiAnQXNzaWduZWQnLFxuICAgICAgICAvLyBTaW5jZSB0aGlzIGlzIGRlZmluZWQgYXMgdGhlIGludmVyc2Ugb2YgVW5pY29kZSBjYXRlZ29yeSBDbiAoVW5hc3NpZ25lZCksIHRoZSBVbmljb2RlXG4gICAgICAgIC8vIENhdGVnb3JpZXMgYWRkb24gaXMgcmVxdWlyZWQgdG8gdXNlIHRoaXMgcHJvcGVydHlcbiAgICAgICAgaW52ZXJzZU9mOiAnQ24nXG4gICAgfSk7XG5cbiAgICBYUmVnRXhwLmFkZFVuaWNvZGVEYXRhKHVuaWNvZGVEYXRhKTtcblxufShYUmVnRXhwKSk7XG5cbi8qIVxuICogWFJlZ0V4cCBVbmljb2RlIFNjcmlwdHMgMy4wLjBcbiAqIDxodHRwOi8veHJlZ2V4cC5jb20vPlxuICogU3RldmVuIExldml0aGFuIChjKSAyMDEwLTIwMTUgTUlUIExpY2Vuc2VcbiAqIFVuaWNvZGUgZGF0YSBwcm92aWRlZCBieSBNYXRoaWFzIEJ5bmVucyA8aHR0cDovL21hdGhpYXNieW5lbnMuYmUvPlxuICovXG5cbi8qKlxuICogQWRkcyBzdXBwb3J0IGZvciBhbGwgVW5pY29kZSBzY3JpcHRzLiBFLmcuLCBgXFxwe0xhdGlufWAuIFRva2VuIG5hbWVzIGFyZSBjYXNlIGluc2Vuc2l0aXZlLCBhbmRcbiAqIGFueSBzcGFjZXMsIGh5cGhlbnMsIGFuZCB1bmRlcnNjb3JlcyBhcmUgaWdub3JlZC5cbiAqXG4gKiBVc2VzIFVuaWNvZGUgOC4wLjAuXG4gKlxuICogQHJlcXVpcmVzIFhSZWdFeHAsIFVuaWNvZGUgQmFzZVxuICovXG4oZnVuY3Rpb24oWFJlZ0V4cCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGlmICghWFJlZ0V4cC5hZGRVbmljb2RlRGF0YSkge1xuICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoJ1VuaWNvZGUgQmFzZSBtdXN0IGJlIGxvYWRlZCBiZWZvcmUgVW5pY29kZSBTY3JpcHRzJyk7XG4gICAgfVxuXG4gICAgWFJlZ0V4cC5hZGRVbmljb2RlRGF0YShbXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdBaG9tJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDVbXFx1REYwMC1cXHVERjE5XFx1REYxRC1cXHVERjJCXFx1REYzMC1cXHVERjNGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0FuYXRvbGlhbl9IaWVyb2dseXBocycsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODExW1xcdURDMDAtXFx1REU0Nl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdBcmFiaWMnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MDYwMC1cXHUwNjA0XFx1MDYwNi1cXHUwNjBCXFx1MDYwRC1cXHUwNjFBXFx1MDYxRVxcdTA2MjAtXFx1MDYzRlxcdTA2NDEtXFx1MDY0QVxcdTA2NTYtXFx1MDY2RlxcdTA2NzEtXFx1MDZEQ1xcdTA2REUtXFx1MDZGRlxcdTA3NTAtXFx1MDc3RlxcdTA4QTAtXFx1MDhCNFxcdTA4RTMtXFx1MDhGRlxcdUZCNTAtXFx1RkJDMVxcdUZCRDMtXFx1RkQzRFxcdUZENTAtXFx1RkQ4RlxcdUZEOTItXFx1RkRDN1xcdUZERjAtXFx1RkRGRFxcdUZFNzAtXFx1RkU3NFxcdUZFNzYtXFx1RkVGQycsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAzW1xcdURFNjAtXFx1REU3RV18XFx1RDgzQltcXHVERTAwLVxcdURFMDNcXHVERTA1LVxcdURFMUZcXHVERTIxXFx1REUyMlxcdURFMjRcXHVERTI3XFx1REUyOS1cXHVERTMyXFx1REUzNC1cXHVERTM3XFx1REUzOVxcdURFM0JcXHVERTQyXFx1REU0N1xcdURFNDlcXHVERTRCXFx1REU0RC1cXHVERTRGXFx1REU1MVxcdURFNTJcXHVERTU0XFx1REU1N1xcdURFNTlcXHVERTVCXFx1REU1RFxcdURFNUZcXHVERTYxXFx1REU2MlxcdURFNjRcXHVERTY3LVxcdURFNkFcXHVERTZDLVxcdURFNzJcXHVERTc0LVxcdURFNzdcXHVERTc5LVxcdURFN0NcXHVERTdFXFx1REU4MC1cXHVERTg5XFx1REU4Qi1cXHVERTlCXFx1REVBMS1cXHVERUEzXFx1REVBNS1cXHVERUE5XFx1REVBQi1cXHVERUJCXFx1REVGMFxcdURFRjFdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnQXJtZW5pYW4nLFxuICAgICAgICAgICAgYm1wOiAnXFx1MDUzMS1cXHUwNTU2XFx1MDU1OS1cXHUwNTVGXFx1MDU2MS1cXHUwNTg3XFx1MDU4QVxcdTA1OEQtXFx1MDU4RlxcdUZCMTMtXFx1RkIxNydcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0F2ZXN0YW4nLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMltcXHVERjAwLVxcdURGMzVcXHVERjM5LVxcdURGM0ZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnQmFsaW5lc2UnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MUIwMC1cXHUxQjRCXFx1MUI1MC1cXHUxQjdDJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnQmFtdW0nLFxuICAgICAgICAgICAgYm1wOiAnXFx1QTZBMC1cXHVBNkY3JyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MUFbXFx1REMwMC1cXHVERTM4XSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0Jhc3NhX1ZhaCcsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODFBW1xcdURFRDAtXFx1REVFRFxcdURFRjAtXFx1REVGNV0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdCYXRhaycsXG4gICAgICAgICAgICBibXA6ICdcXHUxQkMwLVxcdTFCRjNcXHUxQkZDLVxcdTFCRkYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdCZW5nYWxpJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTA5ODAtXFx1MDk4M1xcdTA5ODUtXFx1MDk4Q1xcdTA5OEZcXHUwOTkwXFx1MDk5My1cXHUwOUE4XFx1MDlBQS1cXHUwOUIwXFx1MDlCMlxcdTA5QjYtXFx1MDlCOVxcdTA5QkMtXFx1MDlDNFxcdTA5QzdcXHUwOUM4XFx1MDlDQi1cXHUwOUNFXFx1MDlEN1xcdTA5RENcXHUwOUREXFx1MDlERi1cXHUwOUUzXFx1MDlFNi1cXHUwOUZCJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnQm9wb21vZm8nLFxuICAgICAgICAgICAgYm1wOiAnXFx1MDJFQVxcdTAyRUJcXHUzMTA1LVxcdTMxMkRcXHUzMUEwLVxcdTMxQkEnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdCcmFobWknLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwNFtcXHVEQzAwLVxcdURDNERcXHVEQzUyLVxcdURDNkZcXHVEQzdGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0JyYWlsbGUnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MjgwMC1cXHUyOEZGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnQnVnaW5lc2UnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MUEwMC1cXHUxQTFCXFx1MUExRVxcdTFBMUYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdCdWhpZCcsXG4gICAgICAgICAgICBibXA6ICdcXHUxNzQwLVxcdTE3NTMnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdDYW5hZGlhbl9BYm9yaWdpbmFsJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTE0MDAtXFx1MTY3RlxcdTE4QjAtXFx1MThGNSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0NhcmlhbicsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAwW1xcdURFQTAtXFx1REVEMF0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdDYXVjYXNpYW5fQWxiYW5pYW4nLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMVtcXHVERDMwLVxcdURENjNcXHVERDZGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0NoYWttYScsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODA0W1xcdUREMDAtXFx1REQzNFxcdUREMzYtXFx1REQ0M10nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdDaGFtJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdUFBMDAtXFx1QUEzNlxcdUFBNDAtXFx1QUE0RFxcdUFBNTAtXFx1QUE1OVxcdUFBNUMtXFx1QUE1RidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0NoZXJva2VlJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTEzQTAtXFx1MTNGNVxcdTEzRjgtXFx1MTNGRFxcdUFCNzAtXFx1QUJCRidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0NvbW1vbicsXG4gICAgICAgICAgICBibXA6ICdcXDAtXFx4NDBcXFxceDVCLVxceDYwXFxcXHg3Qi1cXHhBOVxceEFCLVxceEI5XFx4QkItXFx4QkZcXHhEN1xceEY3XFx1MDJCOS1cXHUwMkRGXFx1MDJFNS1cXHUwMkU5XFx1MDJFQy1cXHUwMkZGXFx1MDM3NFxcdTAzN0VcXHUwMzg1XFx1MDM4N1xcdTA1ODlcXHUwNjA1XFx1MDYwQ1xcdTA2MUJcXHUwNjFDXFx1MDYxRlxcdTA2NDBcXHUwNkREXFx1MDk2NFxcdTA5NjVcXHUwRTNGXFx1MEZENS1cXHUwRkQ4XFx1MTBGQlxcdTE2RUItXFx1MTZFRFxcdTE3MzVcXHUxNzM2XFx1MTgwMlxcdTE4MDNcXHUxODA1XFx1MUNEM1xcdTFDRTFcXHUxQ0U5LVxcdTFDRUNcXHUxQ0VFLVxcdTFDRjNcXHUxQ0Y1XFx1MUNGNlxcdTIwMDAtXFx1MjAwQlxcdTIwMEUtXFx1MjA2NFxcdTIwNjYtXFx1MjA3MFxcdTIwNzQtXFx1MjA3RVxcdTIwODAtXFx1MjA4RVxcdTIwQTAtXFx1MjBCRVxcdTIxMDAtXFx1MjEyNVxcdTIxMjctXFx1MjEyOVxcdTIxMkMtXFx1MjEzMVxcdTIxMzMtXFx1MjE0RFxcdTIxNEYtXFx1MjE1RlxcdTIxODktXFx1MjE4QlxcdTIxOTAtXFx1MjNGQVxcdTI0MDAtXFx1MjQyNlxcdTI0NDAtXFx1MjQ0QVxcdTI0NjAtXFx1MjdGRlxcdTI5MDAtXFx1MkI3M1xcdTJCNzYtXFx1MkI5NVxcdTJCOTgtXFx1MkJCOVxcdTJCQkQtXFx1MkJDOFxcdTJCQ0EtXFx1MkJEMVxcdTJCRUMtXFx1MkJFRlxcdTJFMDAtXFx1MkU0MlxcdTJGRjAtXFx1MkZGQlxcdTMwMDAtXFx1MzAwNFxcdTMwMDZcXHUzMDA4LVxcdTMwMjBcXHUzMDMwLVxcdTMwMzdcXHUzMDNDLVxcdTMwM0ZcXHUzMDlCXFx1MzA5Q1xcdTMwQTBcXHUzMEZCXFx1MzBGQ1xcdTMxOTAtXFx1MzE5RlxcdTMxQzAtXFx1MzFFM1xcdTMyMjAtXFx1MzI1RlxcdTMyN0YtXFx1MzJDRlxcdTMzNTgtXFx1MzNGRlxcdTREQzAtXFx1NERGRlxcdUE3MDAtXFx1QTcyMVxcdUE3ODgtXFx1QTc4QVxcdUE4MzAtXFx1QTgzOVxcdUE5MkVcXHVBOUNGXFx1QUI1QlxcdUZEM0VcXHVGRDNGXFx1RkUxMC1cXHVGRTE5XFx1RkUzMC1cXHVGRTUyXFx1RkU1NC1cXHVGRTY2XFx1RkU2OC1cXHVGRTZCXFx1RkVGRlxcdUZGMDEtXFx1RkYyMFxcdUZGM0ItXFx1RkY0MFxcdUZGNUItXFx1RkY2NVxcdUZGNzBcXHVGRjlFXFx1RkY5RlxcdUZGRTAtXFx1RkZFNlxcdUZGRTgtXFx1RkZFRVxcdUZGRjktXFx1RkZGRCcsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODNFW1xcdURDMDAtXFx1REMwQlxcdURDMTAtXFx1REM0N1xcdURDNTAtXFx1REM1OVxcdURDNjAtXFx1REM4N1xcdURDOTAtXFx1RENBRFxcdUREMTAtXFx1REQxOFxcdUREODAtXFx1REQ4NFxcdUREQzBdfFxcdUQ4MkZbXFx1RENBMC1cXHVEQ0EzXXxcXHVEODM1W1xcdURDMDAtXFx1REM1NFxcdURDNTYtXFx1REM5Q1xcdURDOUVcXHVEQzlGXFx1RENBMlxcdURDQTVcXHVEQ0E2XFx1RENBOS1cXHVEQ0FDXFx1RENBRS1cXHVEQ0I5XFx1RENCQlxcdURDQkQtXFx1RENDM1xcdURDQzUtXFx1REQwNVxcdUREMDctXFx1REQwQVxcdUREMEQtXFx1REQxNFxcdUREMTYtXFx1REQxQ1xcdUREMUUtXFx1REQzOVxcdUREM0ItXFx1REQzRVxcdURENDAtXFx1REQ0NFxcdURENDZcXHVERDRBLVxcdURENTBcXHVERDUyLVxcdURFQTVcXHVERUE4LVxcdURGQ0JcXHVERkNFLVxcdURGRkZdfFxcdURCNDBbXFx1REMwMVxcdURDMjAtXFx1REM3Rl18XFx1RDgzRFtcXHVEQzAwLVxcdURENzlcXHVERDdCLVxcdUREQTNcXHVEREE1LVxcdURFRDBcXHVERUUwLVxcdURFRUNcXHVERUYwLVxcdURFRjNcXHVERjAwLVxcdURGNzNcXHVERjgwLVxcdURGRDRdfFxcdUQ4MDBbXFx1REQwMC1cXHVERDAyXFx1REQwNy1cXHVERDMzXFx1REQzNy1cXHVERDNGXFx1REQ5MC1cXHVERDlCXFx1REREMC1cXHVEREZDXFx1REVFMS1cXHVERUZCXXxcXHVEODM0W1xcdURDMDAtXFx1RENGNVxcdUREMDAtXFx1REQyNlxcdUREMjktXFx1REQ2NlxcdURENkEtXFx1REQ3QVxcdUREODNcXHVERDg0XFx1REQ4Qy1cXHVEREE5XFx1RERBRS1cXHVEREU4XFx1REYwMC1cXHVERjU2XFx1REY2MC1cXHVERjcxXXxcXHVEODNDW1xcdURDMDAtXFx1REMyQlxcdURDMzAtXFx1REM5M1xcdURDQTAtXFx1RENBRVxcdURDQjEtXFx1RENCRlxcdURDQzEtXFx1RENDRlxcdURDRDEtXFx1RENGNVxcdUREMDAtXFx1REQwQ1xcdUREMTAtXFx1REQyRVxcdUREMzAtXFx1REQ2QlxcdURENzAtXFx1REQ5QVxcdURERTYtXFx1RERGRlxcdURFMDFcXHVERTAyXFx1REUxMC1cXHVERTNBXFx1REU0MC1cXHVERTQ4XFx1REU1MFxcdURFNTFcXHVERjAwLVxcdURGRkZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnQ29wdGljJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTAzRTItXFx1MDNFRlxcdTJDODAtXFx1MkNGM1xcdTJDRjktXFx1MkNGRidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0N1bmVpZm9ybScsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODA5W1xcdURDMDAtXFx1REM2RVxcdURDNzAtXFx1REM3NFxcdURDODAtXFx1REQ0M118XFx1RDgwOFtcXHVEQzAwLVxcdURGOTldJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnQ3lwcmlvdCcsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAyW1xcdURDMDAtXFx1REMwNVxcdURDMDhcXHVEQzBBLVxcdURDMzVcXHVEQzM3XFx1REMzOFxcdURDM0NcXHVEQzNGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0N5cmlsbGljJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTA0MDAtXFx1MDQ4NFxcdTA0ODctXFx1MDUyRlxcdTFEMkJcXHUxRDc4XFx1MkRFMC1cXHUyREZGXFx1QTY0MC1cXHVBNjlGXFx1RkUyRVxcdUZFMkYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdEZXNlcmV0JyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDFbXFx1REMwMC1cXHVEQzRGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0RldmFuYWdhcmknLFxuICAgICAgICAgICAgYm1wOiAnXFx1MDkwMC1cXHUwOTUwXFx1MDk1My1cXHUwOTYzXFx1MDk2Ni1cXHUwOTdGXFx1QThFMC1cXHVBOEZEJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnRHVwbG95YW4nLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgyRltcXHVEQzAwLVxcdURDNkFcXHVEQzcwLVxcdURDN0NcXHVEQzgwLVxcdURDODhcXHVEQzkwLVxcdURDOTlcXHVEQzlDLVxcdURDOUZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnRWd5cHRpYW5fSGllcm9nbHlwaHMnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwQ1tcXHVEQzAwLVxcdURGRkZdfFxcdUQ4MERbXFx1REMwMC1cXHVEQzJFXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0VsYmFzYW4nLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMVtcXHVERDAwLVxcdUREMjddJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnRXRoaW9waWMnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MTIwMC1cXHUxMjQ4XFx1MTI0QS1cXHUxMjREXFx1MTI1MC1cXHUxMjU2XFx1MTI1OFxcdTEyNUEtXFx1MTI1RFxcdTEyNjAtXFx1MTI4OFxcdTEyOEEtXFx1MTI4RFxcdTEyOTAtXFx1MTJCMFxcdTEyQjItXFx1MTJCNVxcdTEyQjgtXFx1MTJCRVxcdTEyQzBcXHUxMkMyLVxcdTEyQzVcXHUxMkM4LVxcdTEyRDZcXHUxMkQ4LVxcdTEzMTBcXHUxMzEyLVxcdTEzMTVcXHUxMzE4LVxcdTEzNUFcXHUxMzVELVxcdTEzN0NcXHUxMzgwLVxcdTEzOTlcXHUyRDgwLVxcdTJEOTZcXHUyREEwLVxcdTJEQTZcXHUyREE4LVxcdTJEQUVcXHUyREIwLVxcdTJEQjZcXHUyREI4LVxcdTJEQkVcXHUyREMwLVxcdTJEQzZcXHUyREM4LVxcdTJEQ0VcXHUyREQwLVxcdTJERDZcXHUyREQ4LVxcdTJEREVcXHVBQjAxLVxcdUFCMDZcXHVBQjA5LVxcdUFCMEVcXHVBQjExLVxcdUFCMTZcXHVBQjIwLVxcdUFCMjZcXHVBQjI4LVxcdUFCMkUnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdHZW9yZ2lhbicsXG4gICAgICAgICAgICBibXA6ICdcXHUxMEEwLVxcdTEwQzVcXHUxMEM3XFx1MTBDRFxcdTEwRDAtXFx1MTBGQVxcdTEwRkMtXFx1MTBGRlxcdTJEMDAtXFx1MkQyNVxcdTJEMjdcXHUyRDJEJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnR2xhZ29saXRpYycsXG4gICAgICAgICAgICBibXA6ICdcXHUyQzAwLVxcdTJDMkVcXHUyQzMwLVxcdTJDNUUnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdHb3RoaWMnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMFtcXHVERjMwLVxcdURGNEFdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnR3JhbnRoYScsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODA0W1xcdURGMDAtXFx1REYwM1xcdURGMDUtXFx1REYwQ1xcdURGMEZcXHVERjEwXFx1REYxMy1cXHVERjI4XFx1REYyQS1cXHVERjMwXFx1REYzMlxcdURGMzNcXHVERjM1LVxcdURGMzlcXHVERjNDLVxcdURGNDRcXHVERjQ3XFx1REY0OFxcdURGNEItXFx1REY0RFxcdURGNTBcXHVERjU3XFx1REY1RC1cXHVERjYzXFx1REY2Ni1cXHVERjZDXFx1REY3MC1cXHVERjc0XSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0dyZWVrJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTAzNzAtXFx1MDM3M1xcdTAzNzUtXFx1MDM3N1xcdTAzN0EtXFx1MDM3RFxcdTAzN0ZcXHUwMzg0XFx1MDM4NlxcdTAzODgtXFx1MDM4QVxcdTAzOENcXHUwMzhFLVxcdTAzQTFcXHUwM0EzLVxcdTAzRTFcXHUwM0YwLVxcdTAzRkZcXHUxRDI2LVxcdTFEMkFcXHUxRDVELVxcdTFENjFcXHUxRDY2LVxcdTFENkFcXHUxREJGXFx1MUYwMC1cXHUxRjE1XFx1MUYxOC1cXHUxRjFEXFx1MUYyMC1cXHUxRjQ1XFx1MUY0OC1cXHUxRjREXFx1MUY1MC1cXHUxRjU3XFx1MUY1OVxcdTFGNUJcXHUxRjVEXFx1MUY1Ri1cXHUxRjdEXFx1MUY4MC1cXHUxRkI0XFx1MUZCNi1cXHUxRkM0XFx1MUZDNi1cXHUxRkQzXFx1MUZENi1cXHUxRkRCXFx1MUZERC1cXHUxRkVGXFx1MUZGMi1cXHUxRkY0XFx1MUZGNi1cXHUxRkZFXFx1MjEyNlxcdUFCNjUnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMFtcXHVERDQwLVxcdUREOENcXHVEREEwXXxcXHVEODM0W1xcdURFMDAtXFx1REU0NV0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdHdWphcmF0aScsXG4gICAgICAgICAgICBibXA6ICdcXHUwQTgxLVxcdTBBODNcXHUwQTg1LVxcdTBBOERcXHUwQThGLVxcdTBBOTFcXHUwQTkzLVxcdTBBQThcXHUwQUFBLVxcdTBBQjBcXHUwQUIyXFx1MEFCM1xcdTBBQjUtXFx1MEFCOVxcdTBBQkMtXFx1MEFDNVxcdTBBQzctXFx1MEFDOVxcdTBBQ0ItXFx1MEFDRFxcdTBBRDBcXHUwQUUwLVxcdTBBRTNcXHUwQUU2LVxcdTBBRjFcXHUwQUY5J1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnR3VybXVraGknLFxuICAgICAgICAgICAgYm1wOiAnXFx1MEEwMS1cXHUwQTAzXFx1MEEwNS1cXHUwQTBBXFx1MEEwRlxcdTBBMTBcXHUwQTEzLVxcdTBBMjhcXHUwQTJBLVxcdTBBMzBcXHUwQTMyXFx1MEEzM1xcdTBBMzVcXHUwQTM2XFx1MEEzOFxcdTBBMzlcXHUwQTNDXFx1MEEzRS1cXHUwQTQyXFx1MEE0N1xcdTBBNDhcXHUwQTRCLVxcdTBBNERcXHUwQTUxXFx1MEE1OS1cXHUwQTVDXFx1MEE1RVxcdTBBNjYtXFx1MEE3NSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0hhbicsXG4gICAgICAgICAgICBibXA6ICdcXHUyRTgwLVxcdTJFOTlcXHUyRTlCLVxcdTJFRjNcXHUyRjAwLVxcdTJGRDVcXHUzMDA1XFx1MzAwN1xcdTMwMjEtXFx1MzAyOVxcdTMwMzgtXFx1MzAzQlxcdTM0MDAtXFx1NERCNVxcdTRFMDAtXFx1OUZENVxcdUY5MDAtXFx1RkE2RFxcdUZBNzAtXFx1RkFEOScsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODZFW1xcdURDMDAtXFx1REMxRFxcdURDMjAtXFx1REZGRl18W1xcdUQ4NDAtXFx1RDg2OFxcdUQ4NkEtXFx1RDg2Q1xcdUQ4NkYtXFx1RDg3Ml1bXFx1REMwMC1cXHVERkZGXXxcXHVEODZEW1xcdURDMDAtXFx1REYzNFxcdURGNDAtXFx1REZGRl18XFx1RDg3RVtcXHVEQzAwLVxcdURFMURdfFxcdUQ4NjlbXFx1REMwMC1cXHVERUQ2XFx1REYwMC1cXHVERkZGXXxcXHVEODczW1xcdURDMDAtXFx1REVBMV0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdIYW5ndWwnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MTEwMC1cXHUxMUZGXFx1MzAyRVxcdTMwMkZcXHUzMTMxLVxcdTMxOEVcXHUzMjAwLVxcdTMyMUVcXHUzMjYwLVxcdTMyN0VcXHVBOTYwLVxcdUE5N0NcXHVBQzAwLVxcdUQ3QTNcXHVEN0IwLVxcdUQ3QzZcXHVEN0NCLVxcdUQ3RkJcXHVGRkEwLVxcdUZGQkVcXHVGRkMyLVxcdUZGQzdcXHVGRkNBLVxcdUZGQ0ZcXHVGRkQyLVxcdUZGRDdcXHVGRkRBLVxcdUZGREMnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdIYW51bm9vJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTE3MjAtXFx1MTczNCdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0hhdHJhbicsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAyW1xcdURDRTAtXFx1RENGMlxcdURDRjRcXHVEQ0Y1XFx1RENGQi1cXHVEQ0ZGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0hlYnJldycsXG4gICAgICAgICAgICBibXA6ICdcXHUwNTkxLVxcdTA1QzdcXHUwNUQwLVxcdTA1RUFcXHUwNUYwLVxcdTA1RjRcXHVGQjFELVxcdUZCMzZcXHVGQjM4LVxcdUZCM0NcXHVGQjNFXFx1RkI0MFxcdUZCNDFcXHVGQjQzXFx1RkI0NFxcdUZCNDYtXFx1RkI0RidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0hpcmFnYW5hJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTMwNDEtXFx1MzA5NlxcdTMwOUQtXFx1MzA5RicsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODJDXFx1REMwMXxcXHVEODNDXFx1REUwMCdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0ltcGVyaWFsX0FyYW1haWMnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMltcXHVEQzQwLVxcdURDNTVcXHVEQzU3LVxcdURDNUZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5oZXJpdGVkJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTAzMDAtXFx1MDM2RlxcdTA0ODVcXHUwNDg2XFx1MDY0Qi1cXHUwNjU1XFx1MDY3MFxcdTA5NTFcXHUwOTUyXFx1MUFCMC1cXHUxQUJFXFx1MUNEMC1cXHUxQ0QyXFx1MUNENC1cXHUxQ0UwXFx1MUNFMi1cXHUxQ0U4XFx1MUNFRFxcdTFDRjRcXHUxQ0Y4XFx1MUNGOVxcdTFEQzAtXFx1MURGNVxcdTFERkMtXFx1MURGRlxcdTIwMENcXHUyMDBEXFx1MjBEMC1cXHUyMEYwXFx1MzAyQS1cXHUzMDJEXFx1MzA5OVxcdTMwOUFcXHVGRTAwLVxcdUZFMEZcXHVGRTIwLVxcdUZFMkQnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgzNFtcXHVERDY3LVxcdURENjlcXHVERDdCLVxcdUREODJcXHVERDg1LVxcdUREOEJcXHVEREFBLVxcdUREQURdfFxcdUQ4MDBbXFx1RERGRFxcdURFRTBdfFxcdURCNDBbXFx1REQwMC1cXHVEREVGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luc2NyaXB0aW9uYWxfUGFobGF2aScsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAyW1xcdURGNjAtXFx1REY3MlxcdURGNzgtXFx1REY3Rl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbnNjcmlwdGlvbmFsX1BhcnRoaWFuJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDJbXFx1REY0MC1cXHVERjU1XFx1REY1OC1cXHVERjVGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0phdmFuZXNlJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdUE5ODAtXFx1QTlDRFxcdUE5RDAtXFx1QTlEOVxcdUE5REVcXHVBOURGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnS2FpdGhpJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDRbXFx1REM4MC1cXHVEQ0MxXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0thbm5hZGEnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MEM4MS1cXHUwQzgzXFx1MEM4NS1cXHUwQzhDXFx1MEM4RS1cXHUwQzkwXFx1MEM5Mi1cXHUwQ0E4XFx1MENBQS1cXHUwQ0IzXFx1MENCNS1cXHUwQ0I5XFx1MENCQy1cXHUwQ0M0XFx1MENDNi1cXHUwQ0M4XFx1MENDQS1cXHUwQ0NEXFx1MENENVxcdTBDRDZcXHUwQ0RFXFx1MENFMC1cXHUwQ0UzXFx1MENFNi1cXHUwQ0VGXFx1MENGMVxcdTBDRjInXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdLYXRha2FuYScsXG4gICAgICAgICAgICBibXA6ICdcXHUzMEExLVxcdTMwRkFcXHUzMEZELVxcdTMwRkZcXHUzMUYwLVxcdTMxRkZcXHUzMkQwLVxcdTMyRkVcXHUzMzAwLVxcdTMzNTdcXHVGRjY2LVxcdUZGNkZcXHVGRjcxLVxcdUZGOUQnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgyQ1xcdURDMDAnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdLYXlhaF9MaScsXG4gICAgICAgICAgICBibXA6ICdcXHVBOTAwLVxcdUE5MkRcXHVBOTJGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnS2hhcm9zaHRoaScsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAyW1xcdURFMDAtXFx1REUwM1xcdURFMDVcXHVERTA2XFx1REUwQy1cXHVERTEzXFx1REUxNS1cXHVERTE3XFx1REUxOS1cXHVERTMzXFx1REUzOC1cXHVERTNBXFx1REUzRi1cXHVERTQ3XFx1REU1MC1cXHVERTU4XSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0tobWVyJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTE3ODAtXFx1MTdERFxcdTE3RTAtXFx1MTdFOVxcdTE3RjAtXFx1MTdGOVxcdTE5RTAtXFx1MTlGRidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0tob2praScsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODA0W1xcdURFMDAtXFx1REUxMVxcdURFMTMtXFx1REUzRF0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdLaHVkYXdhZGknLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwNFtcXHVERUIwLVxcdURFRUFcXHVERUYwLVxcdURFRjldJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnTGFvJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTBFODFcXHUwRTgyXFx1MEU4NFxcdTBFODdcXHUwRTg4XFx1MEU4QVxcdTBFOERcXHUwRTk0LVxcdTBFOTdcXHUwRTk5LVxcdTBFOUZcXHUwRUExLVxcdTBFQTNcXHUwRUE1XFx1MEVBN1xcdTBFQUFcXHUwRUFCXFx1MEVBRC1cXHUwRUI5XFx1MEVCQi1cXHUwRUJEXFx1MEVDMC1cXHUwRUM0XFx1MEVDNlxcdTBFQzgtXFx1MEVDRFxcdTBFRDAtXFx1MEVEOVxcdTBFREMtXFx1MEVERidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0xhdGluJyxcbiAgICAgICAgICAgIGJtcDogJ0EtWmEtelxceEFBXFx4QkFcXHhDMC1cXHhENlxceEQ4LVxceEY2XFx4RjgtXFx1MDJCOFxcdTAyRTAtXFx1MDJFNFxcdTFEMDAtXFx1MUQyNVxcdTFEMkMtXFx1MUQ1Q1xcdTFENjItXFx1MUQ2NVxcdTFENkItXFx1MUQ3N1xcdTFENzktXFx1MURCRVxcdTFFMDAtXFx1MUVGRlxcdTIwNzFcXHUyMDdGXFx1MjA5MC1cXHUyMDlDXFx1MjEyQVxcdTIxMkJcXHUyMTMyXFx1MjE0RVxcdTIxNjAtXFx1MjE4OFxcdTJDNjAtXFx1MkM3RlxcdUE3MjItXFx1QTc4N1xcdUE3OEItXFx1QTdBRFxcdUE3QjAtXFx1QTdCN1xcdUE3RjctXFx1QTdGRlxcdUFCMzAtXFx1QUI1QVxcdUFCNUMtXFx1QUI2NFxcdUZCMDAtXFx1RkIwNlxcdUZGMjEtXFx1RkYzQVxcdUZGNDEtXFx1RkY1QSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0xlcGNoYScsXG4gICAgICAgICAgICBibXA6ICdcXHUxQzAwLVxcdTFDMzdcXHUxQzNCLVxcdTFDNDlcXHUxQzRELVxcdTFDNEYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdMaW1idScsXG4gICAgICAgICAgICBibXA6ICdcXHUxOTAwLVxcdTE5MUVcXHUxOTIwLVxcdTE5MkJcXHUxOTMwLVxcdTE5M0JcXHUxOTQwXFx1MTk0NC1cXHUxOTRGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnTGluZWFyX0EnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMVtcXHVERTAwLVxcdURGMzZcXHVERjQwLVxcdURGNTVcXHVERjYwLVxcdURGNjddJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnTGluZWFyX0InLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMFtcXHVEQzAwLVxcdURDMEJcXHVEQzBELVxcdURDMjZcXHVEQzI4LVxcdURDM0FcXHVEQzNDXFx1REMzRFxcdURDM0YtXFx1REM0RFxcdURDNTAtXFx1REM1RFxcdURDODAtXFx1RENGQV0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdMaXN1JyxcbiAgICAgICAgICAgIGJtcDogJ1xcdUE0RDAtXFx1QTRGRidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0x5Y2lhbicsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAwW1xcdURFODAtXFx1REU5Q10nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdMeWRpYW4nLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMltcXHVERDIwLVxcdUREMzlcXHVERDNGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ01haGFqYW5pJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDRbXFx1REQ1MC1cXHVERDc2XSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ01hbGF5YWxhbScsXG4gICAgICAgICAgICBibXA6ICdcXHUwRDAxLVxcdTBEMDNcXHUwRDA1LVxcdTBEMENcXHUwRDBFLVxcdTBEMTBcXHUwRDEyLVxcdTBEM0FcXHUwRDNELVxcdTBENDRcXHUwRDQ2LVxcdTBENDhcXHUwRDRBLVxcdTBENEVcXHUwRDU3XFx1MEQ1Ri1cXHUwRDYzXFx1MEQ2Ni1cXHUwRDc1XFx1MEQ3OS1cXHUwRDdGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnTWFuZGFpYycsXG4gICAgICAgICAgICBibXA6ICdcXHUwODQwLVxcdTA4NUJcXHUwODVFJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnTWFuaWNoYWVhbicsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAyW1xcdURFQzAtXFx1REVFNlxcdURFRUItXFx1REVGNl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdNZWV0ZWlfTWF5ZWsnLFxuICAgICAgICAgICAgYm1wOiAnXFx1QUFFMC1cXHVBQUY2XFx1QUJDMC1cXHVBQkVEXFx1QUJGMC1cXHVBQkY5J1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnTWVuZGVfS2lrYWt1aScsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODNBW1xcdURDMDAtXFx1RENDNFxcdURDQzctXFx1RENENl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdNZXJvaXRpY19DdXJzaXZlJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDJbXFx1RERBMC1cXHVEREI3XFx1RERCQy1cXHVERENGXFx1REREMi1cXHVEREZGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ01lcm9pdGljX0hpZXJvZ2x5cGhzJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDJbXFx1REQ4MC1cXHVERDlGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ01pYW8nLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgxQltcXHVERjAwLVxcdURGNDRcXHVERjUwLVxcdURGN0VcXHVERjhGLVxcdURGOUZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnTW9kaScsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODA1W1xcdURFMDAtXFx1REU0NFxcdURFNTAtXFx1REU1OV0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdNb25nb2xpYW4nLFxuICAgICAgICAgICAgYm1wOiAnXFx1MTgwMFxcdTE4MDFcXHUxODA0XFx1MTgwNi1cXHUxODBFXFx1MTgxMC1cXHUxODE5XFx1MTgyMC1cXHUxODc3XFx1MTg4MC1cXHUxOEFBJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnTXJvJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MUFbXFx1REU0MC1cXHVERTVFXFx1REU2MC1cXHVERTY5XFx1REU2RVxcdURFNkZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnTXVsdGFuaScsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODA0W1xcdURFODAtXFx1REU4NlxcdURFODhcXHVERThBLVxcdURFOERcXHVERThGLVxcdURFOURcXHVERTlGLVxcdURFQTldJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnTXlhbm1hcicsXG4gICAgICAgICAgICBibXA6ICdcXHUxMDAwLVxcdTEwOUZcXHVBOUUwLVxcdUE5RkVcXHVBQTYwLVxcdUFBN0YnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdOYWJhdGFlYW4nLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMltcXHVEQzgwLVxcdURDOUVcXHVEQ0E3LVxcdURDQUZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnTmV3X1RhaV9MdWUnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MTk4MC1cXHUxOUFCXFx1MTlCMC1cXHUxOUM5XFx1MTlEMC1cXHUxOURBXFx1MTlERVxcdTE5REYnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdOa28nLFxuICAgICAgICAgICAgYm1wOiAnXFx1MDdDMC1cXHUwN0ZBJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnT2doYW0nLFxuICAgICAgICAgICAgYm1wOiAnXFx1MTY4MC1cXHUxNjlDJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnT2xfQ2hpa2knLFxuICAgICAgICAgICAgYm1wOiAnXFx1MUM1MC1cXHUxQzdGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnT2xkX0h1bmdhcmlhbicsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAzW1xcdURDODAtXFx1RENCMlxcdURDQzAtXFx1RENGMlxcdURDRkEtXFx1RENGRl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdPbGRfSXRhbGljJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDBbXFx1REYwMC1cXHVERjIzXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ09sZF9Ob3J0aF9BcmFiaWFuJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDJbXFx1REU4MC1cXHVERTlGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ09sZF9QZXJtaWMnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMFtcXHVERjUwLVxcdURGN0FdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnT2xkX1BlcnNpYW4nLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMFtcXHVERkEwLVxcdURGQzNcXHVERkM4LVxcdURGRDVdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnT2xkX1NvdXRoX0FyYWJpYW4nLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMltcXHVERTYwLVxcdURFN0ZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnT2xkX1R1cmtpYycsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAzW1xcdURDMDAtXFx1REM0OF0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdPcml5YScsXG4gICAgICAgICAgICBibXA6ICdcXHUwQjAxLVxcdTBCMDNcXHUwQjA1LVxcdTBCMENcXHUwQjBGXFx1MEIxMFxcdTBCMTMtXFx1MEIyOFxcdTBCMkEtXFx1MEIzMFxcdTBCMzJcXHUwQjMzXFx1MEIzNS1cXHUwQjM5XFx1MEIzQy1cXHUwQjQ0XFx1MEI0N1xcdTBCNDhcXHUwQjRCLVxcdTBCNERcXHUwQjU2XFx1MEI1N1xcdTBCNUNcXHUwQjVEXFx1MEI1Ri1cXHUwQjYzXFx1MEI2Ni1cXHUwQjc3J1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnT3NtYW55YScsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAxW1xcdURDODAtXFx1REM5RFxcdURDQTAtXFx1RENBOV0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdQYWhhd2hfSG1vbmcnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgxQVtcXHVERjAwLVxcdURGNDVcXHVERjUwLVxcdURGNTlcXHVERjVCLVxcdURGNjFcXHVERjYzLVxcdURGNzdcXHVERjdELVxcdURGOEZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnUGFsbXlyZW5lJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDJbXFx1REM2MC1cXHVEQzdGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ1BhdV9DaW5fSGF1JyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDZbXFx1REVDMC1cXHVERUY4XSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ1BoYWdzX1BhJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdUE4NDAtXFx1QTg3NydcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ1Bob2VuaWNpYW4nLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMltcXHVERDAwLVxcdUREMUJcXHVERDFGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ1BzYWx0ZXJfUGFobGF2aScsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAyW1xcdURGODAtXFx1REY5MVxcdURGOTktXFx1REY5Q1xcdURGQTktXFx1REZBRl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdSZWphbmcnLFxuICAgICAgICAgICAgYm1wOiAnXFx1QTkzMC1cXHVBOTUzXFx1QTk1RidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ1J1bmljJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTE2QTAtXFx1MTZFQVxcdTE2RUUtXFx1MTZGOCdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ1NhbWFyaXRhbicsXG4gICAgICAgICAgICBibXA6ICdcXHUwODAwLVxcdTA4MkRcXHUwODMwLVxcdTA4M0UnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdTYXVyYXNodHJhJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdUE4ODAtXFx1QThDNFxcdUE4Q0UtXFx1QThEOSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ1NoYXJhZGEnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwNFtcXHVERDgwLVxcdUREQ0RcXHVEREQwLVxcdUREREZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnU2hhdmlhbicsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAxW1xcdURDNTAtXFx1REM3Rl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdTaWRkaGFtJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDVbXFx1REQ4MC1cXHVEREI1XFx1RERCOC1cXHVEREREXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ1NpZ25Xcml0aW5nJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MzZbXFx1REMwMC1cXHVERThCXFx1REU5Qi1cXHVERTlGXFx1REVBMS1cXHVERUFGXSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ1NpbmhhbGEnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MEQ4MlxcdTBEODNcXHUwRDg1LVxcdTBEOTZcXHUwRDlBLVxcdTBEQjFcXHUwREIzLVxcdTBEQkJcXHUwREJEXFx1MERDMC1cXHUwREM2XFx1MERDQVxcdTBEQ0YtXFx1MERENFxcdTBERDZcXHUwREQ4LVxcdTBEREZcXHUwREU2LVxcdTBERUZcXHUwREYyLVxcdTBERjQnLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwNFtcXHVEREUxLVxcdURERjRdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnU29yYV9Tb21wZW5nJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDRbXFx1RENEMC1cXHVEQ0U4XFx1RENGMC1cXHVEQ0Y5XSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ1N1bmRhbmVzZScsXG4gICAgICAgICAgICBibXA6ICdcXHUxQjgwLVxcdTFCQkZcXHUxQ0MwLVxcdTFDQzcnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdTeWxvdGlfTmFncmknLFxuICAgICAgICAgICAgYm1wOiAnXFx1QTgwMC1cXHVBODJCJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnU3lyaWFjJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTA3MDAtXFx1MDcwRFxcdTA3MEYtXFx1MDc0QVxcdTA3NEQtXFx1MDc0RidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ1RhZ2Fsb2cnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MTcwMC1cXHUxNzBDXFx1MTcwRS1cXHUxNzE0J1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnVGFnYmFud2EnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MTc2MC1cXHUxNzZDXFx1MTc2RS1cXHUxNzcwXFx1MTc3MlxcdTE3NzMnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdUYWlfTGUnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MTk1MC1cXHUxOTZEXFx1MTk3MC1cXHUxOTc0J1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnVGFpX1RoYW0nLFxuICAgICAgICAgICAgYm1wOiAnXFx1MUEyMC1cXHUxQTVFXFx1MUE2MC1cXHUxQTdDXFx1MUE3Ri1cXHUxQTg5XFx1MUE5MC1cXHUxQTk5XFx1MUFBMC1cXHUxQUFEJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnVGFpX1ZpZXQnLFxuICAgICAgICAgICAgYm1wOiAnXFx1QUE4MC1cXHVBQUMyXFx1QUFEQi1cXHVBQURGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnVGFrcmknLFxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwNVtcXHVERTgwLVxcdURFQjdcXHVERUMwLVxcdURFQzldJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnVGFtaWwnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MEI4MlxcdTBCODNcXHUwQjg1LVxcdTBCOEFcXHUwQjhFLVxcdTBCOTBcXHUwQjkyLVxcdTBCOTVcXHUwQjk5XFx1MEI5QVxcdTBCOUNcXHUwQjlFXFx1MEI5RlxcdTBCQTNcXHUwQkE0XFx1MEJBOC1cXHUwQkFBXFx1MEJBRS1cXHUwQkI5XFx1MEJCRS1cXHUwQkMyXFx1MEJDNi1cXHUwQkM4XFx1MEJDQS1cXHUwQkNEXFx1MEJEMFxcdTBCRDdcXHUwQkU2LVxcdTBCRkEnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdUZWx1Z3UnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MEMwMC1cXHUwQzAzXFx1MEMwNS1cXHUwQzBDXFx1MEMwRS1cXHUwQzEwXFx1MEMxMi1cXHUwQzI4XFx1MEMyQS1cXHUwQzM5XFx1MEMzRC1cXHUwQzQ0XFx1MEM0Ni1cXHUwQzQ4XFx1MEM0QS1cXHUwQzREXFx1MEM1NVxcdTBDNTZcXHUwQzU4LVxcdTBDNUFcXHUwQzYwLVxcdTBDNjNcXHUwQzY2LVxcdTBDNkZcXHUwQzc4LVxcdTBDN0YnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdUaGFhbmEnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MDc4MC1cXHUwN0IxJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnVGhhaScsXG4gICAgICAgICAgICBibXA6ICdcXHUwRTAxLVxcdTBFM0FcXHUwRTQwLVxcdTBFNUInXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdUaWJldGFuJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdTBGMDAtXFx1MEY0N1xcdTBGNDktXFx1MEY2Q1xcdTBGNzEtXFx1MEY5N1xcdTBGOTktXFx1MEZCQ1xcdTBGQkUtXFx1MEZDQ1xcdTBGQ0UtXFx1MEZENFxcdTBGRDlcXHUwRkRBJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnVGlmaW5hZ2gnLFxuICAgICAgICAgICAgYm1wOiAnXFx1MkQzMC1cXHUyRDY3XFx1MkQ2RlxcdTJENzBcXHUyRDdGJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnVGlyaHV0YScsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODA1W1xcdURDODAtXFx1RENDN1xcdURDRDAtXFx1RENEOV0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdVZ2FyaXRpYycsXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAwW1xcdURGODAtXFx1REY5RFxcdURGOUZdJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnVmFpJyxcbiAgICAgICAgICAgIGJtcDogJ1xcdUE1MDAtXFx1QTYyQidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ1dhcmFuZ19DaXRpJyxcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDZbXFx1RENBMC1cXHVEQ0YyXFx1RENGRl0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdZaScsXG4gICAgICAgICAgICBibXA6ICdcXHVBMDAwLVxcdUE0OENcXHVBNDkwLVxcdUE0QzYnXG4gICAgICAgIH1cbiAgICBdKTtcblxufShYUmVnRXhwKSk7XG5cbnJldHVybiBYUmVnRXhwO1xuXG59KSk7XG5cbiIsIi8vIGltcG9ydCBcImJhYmVsLXBvbHlmaWxsXCI7XHJcbi8vXHJcbi8vIGltcG9ydCB7WFJlZ0V4cH0gZnJvbSBcInhyZWdleHBcIjtcclxuLy8gaW1wb3J0IFB1YlN1YiBmcm9tIFwicHVic3ViLWpzXCI7XHJcbi8vIGltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcclxuLy8gaW1wb3J0IFJlYWN0RE9NIGZyb20gXCJyZWFjdC1kb21cIjtcclxuLy8gaW1wb3J0IENTU1RyYW5zaXRpb24gZnJvbSBcInJlYWN0LWFkZG9ucy1jc3MtdHJhbnNpdGlvbi1ncm91cFwiO1xyXG4vLyBpbXBvcnQgKiBhcyBSZWFjdFJvdXRlciBmcm9tIFwicmVhY3Qtcm91dGVyXCI7XHJcbi8vIGltcG9ydCB7Y3JlYXRlSGFzaEhpc3Rvcnl9IGZyb20gXCJoaXN0b3J5XCI7XHJcblxyXG5cclxuLy8gaW1wb3J0IFwibGliLXNvdXJjZS92Mi9nZXN0dXJlXCI7XHJcbmltcG9ydCBjaHJvbm8gZnJvbSBcImxpYi1zb3VyY2UvdjIvY2hyb25vXCI7XHJcbmltcG9ydCBhamF4IGZyb20gXCJsaWItc291cmNlL3YyL2FqYXhcIjtcclxuXHJcbmltcG9ydCBJY29uIGZyb20gJ2xpYi1zb3VyY2UvdWl2Mi9pY29uJztcclxuaW1wb3J0IFJpcHBsZSBmcm9tICdsaWItc291cmNlL3VpdjIvcmlwcGxlJztcclxuaW1wb3J0IEJ1dHRvbiBmcm9tICdsaWItc291cmNlL3VpdjIvYnV0dG9uJztcclxuaW1wb3J0IEljb25CdXR0b24gZnJvbSAnbGliLXNvdXJjZS91aXYyL2ljb25idXR0b24nO1xyXG5pbXBvcnQgQ2FyZCBmcm9tICdsaWItc291cmNlL3VpdjIvQ2FyZCc7XHJcbmltcG9ydCBJbWFnZSBmcm9tICdsaWItc291cmNlL3VpdjIvSW1hZ2UnO1xyXG5pbXBvcnQgQ2VudGVyQ29udGVudCBmcm9tICdsaWItc291cmNlL3VpdjIvQ2VudGVyQ29udGVudCc7XHJcbmltcG9ydCBDaGVja2JveCBmcm9tICdsaWItc291cmNlL3VpdjIvQ2hlY2tib3gnO1xyXG5pbXBvcnQgVG9nZ2xlIGZyb20gJ2xpYi1zb3VyY2UvdWl2Mi9Ub2dnbGUnO1xyXG5pbXBvcnQgVG91Y2hhYmxlIGZyb20gJ2xpYi1zb3VyY2UvdWl2Mi9Ub3VjaGFibGUnO1xyXG5pbXBvcnQgQ29tYm9ib3ggZnJvbSAnbGliLXNvdXJjZS91aXYyL0NvbWJvYm94JztcclxuaW1wb3J0IE9wdGlvbiBmcm9tICdsaWItc291cmNlL3VpdjIvT3B0aW9uJztcclxuaW1wb3J0IFNwaW5uZXIgZnJvbSAnbGliLXNvdXJjZS91aXYyL1NwaW5uZXInO1xyXG5pbXBvcnQgUmFkaW8gZnJvbSAnbGliLXNvdXJjZS91aXYyL1JhZGlvJztcclxuaW1wb3J0IENhbGVuZGFyIGZyb20gJ2xpYi1zb3VyY2UvdWl2Mi9DYWxlbmRhcic7XHJcbmltcG9ydCBJbnB1dCBmcm9tICdsaWItc291cmNlL3VpdjIvSW5wdXQnO1xyXG5cclxuaW1wb3J0IEZsZXhib3ggZnJvbSAnbGliLXNvdXJjZS91aXYyL2xheW91dC9GbGV4Ym94JztcclxuaW1wb3J0IEdyaWQgZnJvbSAnbGliLXNvdXJjZS91aXYyL2xheW91dC9HcmlkJztcclxuaW1wb3J0IFBpbmJvYXJkIGZyb20gJ2xpYi1zb3VyY2UvdWl2Mi9sYXlvdXQvUGluYm9hcmQnO1xyXG5cclxuaW1wb3J0IEZvcm0gZnJvbSAnbGliLXNvdXJjZS91aXYyL0Zvcm0nO1xyXG5cclxuaW1wb3J0IERpYWxvZ0NvbXBvbmVudCBmcm9tIFwibGliLXNvdXJjZS91aXYyL2RpYWxvZ1wiO1xyXG5pbXBvcnQge2RlZmluZUNvbXBvbmVudFN0eWxlLCBUaGVtZSBhcyBfVGhlbWUsIF9fc2V0dXAgYXMgY3JlYXRlU3R5bGVzLCBkZWZpbmVTdHlsZUZvckNvbXBvbmVudCwgZ2VuRm9udENTU30gZnJvbSBcImxpYi1zb3VyY2UvdjIvc3R5bGVcIjtcclxuXHJcbmltcG9ydCB7d2FybmluZ0Z1bmN9IGZyb20gXCJsaWItc291cmNlL3YyL3V0aWxzXCI7XHJcbmltcG9ydCB7c2hhcmVkUmVmZXJlbmNlLCBTaGFyZWRPYmplY3REaXNwbGF5fSBmcm9tIFwibGliLXNvdXJjZS92Mi9zaGFyZWRcIjtcclxuXHJcbmltcG9ydCBzZWN1cmUgZnJvbSAnbGliLXNvdXJjZS92Mi9jcnlwdG8nO1xyXG5pbXBvcnQgemlwIGZyb20gJ2xpYi1zb3VyY2UvdjIvemlwJztcclxuXHJcbmltcG9ydCBSb2JvdG9VUkkgZnJvbSBcImxpYi1zb3VyY2UvZGF0YS11cmkvcm9ib3RvLWxpZ2h0LndvZmYuc291cmNlXCI7XHJcbmltcG9ydCBJb25pY1VSSSBmcm9tIFwibGliLXNvdXJjZS9kYXRhLXVyaS9pb25pY29ucy53b2ZmLnNvdXJjZVwiO1xyXG5cclxud2luZG93LmNocm9ubyA9IGNocm9ubztcclxuXHJcbmNvbnN0IHJhbmdlID0gZnVuY3Rpb24qIChhcmdzKSB7XHJcbiAgbGV0IHtzdGFydCA9IDAsIGVuZCA9IG51bGwsIGNvdW50ID0gbnVsbCwgc3RlcCA9IDEsIG1hcCA9IGkgPT4gaX0gPSBhcmdzO1xyXG5cclxuICBpZiAoZW5kID09PSBudWxsKSB7XHJcbiAgICBpZiAoY291bnQgPT09IG51bGwpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBnaXZlIHRoZSBzaXplIG9mIHRoZSByYW5nZVwiKVxyXG4gICAgfVxyXG4gICAgZW5kID0gc3RhcnQgKyBjb3VudDtcclxuICB9XHJcblxyXG4gIHdoaWxlICh0cnVlKSB7XHJcbiAgICBpZiAoc3RhcnQgPj0gZW5kKSB7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gICAgeWllbGQgbWFwKHN0YXJ0KTtcclxuICAgIHN0YXJ0ICs9IHN0ZXA7XHJcbiAgfVxyXG59O1xyXG5cclxud2luZG93LmZyYW5nZSA9IGZ1bmN0aW9uKiAoY291bnQsIG1hcCA9IGkgPT4gaSkge1xyXG4gICAgbGV0IGN1cnJlbnQgPSAwO1xyXG4gICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICBpZiAoY3VycmVudCA9PT0gY291bnQpIHtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHlpZWxkIG1hcChjdXJyZW50KTtcclxuICAgICAgICBjdXJyZW50ICs9IDE7XHJcbiAgICB9XHJcbn07XHJcbndpbmRvdy5hcmFuZ2UgPSAoY291bnQsIG1hcCkgPT4gQXJyYXkuZnJvbShmcmFuZ2UoY291bnQsIG1hcCkpO1xyXG5cclxuY29uc3Qge1JvdXRlfSA9IFJlYWN0Um91dGVyO1xyXG5cclxuY29uc3QgY29vbEJsdWUgPSBcIiMyRkIxREZcIjtcclxuXHJcblRoZW1lLmRlZmluZSh7XHJcbiAgICBhcHA6IHtcclxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICd3aGl0ZScsXHJcbiAgICAgICAgdGV4dENvbG9yOiAnIzc0NzQ3NCdcclxuICAgIH0sXHJcbiAgICBidXR0b246IHtcclxuICAgICAgICBob3ZlckNvbG9yOiAncmdiYSgwLCAwLCAwLCAwLjExKScsXHJcbiAgICAgICAgYWN0aXZlQ29sb3I6ICdyZ2JhKDAsIDAsIDAsIDAuMiknLFxyXG4gICAgICAgIHJhaXNlZDoge1xyXG4gICAgICAgICAgICBjb2xvcjogY29vbEJsdWUsXHJcbiAgICAgICAgICAgIHRleHRDb2xvcjogJ3doaXRlJ1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBjYXJkOiB7XHJcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnd2hpdGUnXHJcbiAgICB9LFxyXG4gICAgcHJvZ3Jlc3NiYXI6IHtcclxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjQjNDRUVEJyxcclxuICAgICAgICBjb2xvcjogJyMzQjhBRjMnXHJcbiAgICB9LFxyXG4gICAgcmFkaW86IHtcclxuICAgICAgICBncmlkOiB7XHJcbiAgICAgICAgICAgIHNlbGVjdGVkQ29sb3I6IGNvb2xCbHVlXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHJhbmdlSW5wdXQ6IHtcclxuICAgICAgICB0cmFjazoge1xyXG4gICAgICAgICAgICBjb2xvcjogY29vbEJsdWVcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgc3dpdGNoOiB7XHJcbiAgICAgICAgdHJhY2s6IHtcclxuICAgICAgICAgICAgY29sb3I6IGNvb2xCbHVlXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHRpdGxlOiB7XHJcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBjb29sQmx1ZSxcclxuICAgICAgICB0ZXh0Q29sb3I6ICd3aGl0ZSdcclxuICAgIH0sXHJcbiAgICB1c2VySW5wdXQ6IHtcclxuICAgICAgICBhY3RpdmVDb2xvcjogJyMyRkIxREYnLFxyXG4gICAgICAgIHRleHRDb2xvcjogJ2JsYWNrJ1xyXG4gICAgfVxyXG59KTtcclxuXHJcbmNvbnN0IFNjcmVlblRyYW5zaXRpb24gPSBSZWFjdC5jcmVhdGVDbGFzcyh7XHJcbiAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIDxkaXYgc3R5bGU9e3twb3NpdGlvbjogJ2Fic29sdXRlJywgd2lkdGg6ICcxMDAlJywgaGVpZ2h0OiAnMTAwJSd9fT57dGhpcy5wcm9wcy5jaGlsZHJlbn08L2Rpdj5cclxuICAgIH1cclxufSk7XHJcblxyXG5TdHlsZS5fX3Jhd0NTUyhcclxuICAgIFwidGVzdFwiLFxyXG4gICAge1xyXG4gICAgICAgIHNlbGVjdG9yOiBcIi50ZXN0LWVudGVyXCIsXHJcbiAgICAgICAgcnVsZXM6IHtcclxuICAgICAgICAgICAgJ3RyYW5zaXRpb24nOiAnbGVmdCAyNTBtcyBlYXNlLW91dCcsXHJcbiAgICAgICAgICAgIGxlZnQ6ICcxMDAlJ1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgICAgc2VsZWN0b3I6IFwiLnRlc3QtZW50ZXIudGVzdC1lbnRlci1hY3RpdmVcIixcclxuICAgICAgICBydWxlczoge1xyXG4gICAgICAgICAgICBsZWZ0OiAwXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgICBzZWxlY3RvcjogXCIudGVzdC1sZWF2ZVwiLFxyXG4gICAgICAgIHJ1bGVzOiB7XHJcbiAgICAgICAgICAgICd0cmFuc2l0aW9uJzogJ2xlZnQgMjUwbXMgZWFzZS1vdXQnLFxyXG4gICAgICAgICAgICBsZWZ0OiAwXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgICBzZWxlY3RvcjogXCIudGVzdC1sZWF2ZS50ZXN0LWxlYXZlLWFjdGl2ZVwiLFxyXG4gICAgICAgIHJ1bGVzOiB7XHJcbiAgICAgICAgICAgIGxlZnQ6ICctMTAwJSdcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICAgIHNlbGVjdG9yOiBcIi50ZXN0LWFwcGVhclwiLFxyXG4gICAgICAgIHJ1bGVzOiB7XHJcbiAgICAgICAgICAgICd0cmFuc2l0aW9uJzogJ3RvcCAyNTBtcyBlYXNlLW91dCcsXHJcbiAgICAgICAgICAgIHRvcDogJzEwMCUnLFxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgICAgc2VsZWN0b3I6IFwiLnRlc3QtYXBwZWFyLnRlc3QtYXBwZWFyLWFjdGl2ZVwiLFxyXG4gICAgICAgIHJ1bGVzOiB7XHJcbiAgICAgICAgICAgIHRvcDogMFxyXG4gICAgICAgIH1cclxuICAgIH1cclxuKTtcclxuXHJcbmNvbnN0IFdyYXBwZXIgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XHJcbiAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPENTU1RyYW5zaXRpb24gY29tcG9uZW50PVwiZGl2XCIgdHJhbnNpdGlvbk5hbWU9XCJ0ZXN0XCIgdHJhbnNpdGlvbkVudGVyVGltZW91dD17MjUwfSB0cmFuc2l0aW9uTGVhdmVUaW1lb3V0PXsyNTB9PlxyXG4gICAgICAgICAgICAgICAgPFNjcmVlblRyYW5zaXRpb24ga2V5PXtEYXRlLm5vdygpfT5cclxuICAgICAgICAgICAgICAgICAgICB7dGhpcy5wcm9wcy5jaGlsZHJlbn1cclxuICAgICAgICAgICAgICAgIDwvU2NyZWVuVHJhbnNpdGlvbj5cclxuICAgICAgICAgICAgPC9DU1NUcmFuc2l0aW9uPlxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxuLy8gd2luZG93LmJlbmNobWFyayA9IChpdGVyYXRpb25zLCBmaXJzdCwgc2Vjb25kKSA9PiB7XHJcbi8vICAgICBjb25zdCByID0gW107XHJcbi8vICAgICBmb3IgKGNvbnN0IHRlc3ROdW0gb2YgcmFuZ2Uoe2NvdW50OiAzMH0pKSB7XHJcbi8vICAgICAgICAgbGV0IGEgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuLy8gICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJhdGlvbnM7IGkgKz0gMSkge1xyXG4vLyAgICAgICAgICAgICBmaXJzdChpKTtcclxuLy8gICAgICAgICB9XHJcbi8vICAgICAgICAgYSA9IHBlcmZvcm1hbmNlLm5vdygpIC0gYTtcclxuLy9cclxuLy8gICAgICAgICBsZXQgYiA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG4vLyAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlcmF0aW9uczsgaSArPSAxKSB7XHJcbi8vICAgICAgICAgICAgIHNlY29uZChpKTtcclxuLy8gICAgICAgICB9XHJcbi8vICAgICAgICAgYiA9IHBlcmZvcm1hbmNlLm5vdygpIC0gYjtcclxuLy8gICAgICAgICByLnB1c2goW2EudG9GaXhlZCgzKSwgYi50b0ZpeGVkKDMpXSk7XHJcbi8vICAgICB9XHJcbi8vICAgICByZXR1cm4gcjtcclxuLy8gfTtcclxuLy9cclxuLy8gY29uc3QgY2hlY2tQcm9wID0gKG9iaiwgcHJvcCwgdmFsdWUpID0+IG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSA9PT0gdHJ1ZSAmJiBvYmpbcHJvcF0gPT09IHZhbHVlO1xyXG4vLyBjb25zdCB4ID0ge2E6IDEwLCBiOiAxMn07XHJcbi8vXHJcbi8vIGNvbnN0IHJlcyA9IGJlbmNobWFyaygxZTYsIChpKSA9PiAoaSAlIDIgPT09IDApID8gaSA+PiAxIDogMCwgKGkpID0+IChpICUgMiA9PT0gMCkgPyBpIC8gMiA6IDApO1xyXG4vLyBjb25zb2xlLmxvZyhyZXMubWFwKGkgPT4gaS5qb2luKCdcXHQnKSkuam9pbignXFxuJykpO1xyXG5cclxuLypcclxuY29uc3QgdXJsID0gXCJodHRwOi8vdmlnbmV0dGUxLndpa2lhLm5vY29va2llLm5ldC9iYXlvbmV0dGEvaW1hZ2VzL2UvZTMvQ2VyZXphX0JheW9uZXR0YV8yX3JlbmRlci5wbmcvcmV2aXNpb24vbGF0ZXN0P2NiPTIwMTQwNjE1MjEwMDI1XCI7XHJcbiovXHJcbmNvbnN0IHVybCA9IFwiaHR0cDovL2Fzc2V0czEuaWduaW1ncy5jb20vdGh1bWJzL3VzZXJVcGxvYWRlZC8yMDE0LzEwLzEyL0JheW9uZXR0YTJfMTI4MC0xNDEzMTQyNDUxMTAwLmpwZ1wiO1xyXG5cclxuLypcclxuZGVmaW5lU3R5bGVGb3JDb21wb25lbnQoXHJcbiAgICBCdXR0b24sXHJcbiAgICAnc3BlY2lhbCcsXHJcbiAgICB7XHJcbiAgICB9XHJcbik7XHJcbi4uLlxyXG48QnV0dG9uLlNwZWNpYWwgLz5cclxuKi9cclxuXHJcbmRlZmluZVN0eWxlRm9yQ29tcG9uZW50KFxyXG4gICAgQ2hlY2tib3gsICdhd2Vzb21lJyxcclxuICAgIHtcclxuICAgICAgICBub3JtYWw6IHtcclxuICAgICAgICAgICAgaWNvbkNvbG9yOiAnY3lhbidcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNoZWNrZWQ6IHtcclxuICAgICAgICAgICAgaWNvbkNvbG9yOiAnYmx1ZSdcclxuICAgICAgICB9XHJcbiAgICB9XHJcbik7XHJcbmRlZmluZVN0eWxlRm9yQ29tcG9uZW50KFxyXG4gICAgVG9nZ2xlLCAnYXdlc29tZScsXHJcbiAgICB7XHJcbiAgICAgICAgb246IHtcclxuICAgICAgICAgICAgdGh1bWJDb2xvcjogJ2JsdWUnLFxyXG4gICAgICAgICAgICB0cmFja0NvbG9yOiAnY3lhbidcclxuICAgICAgICB9XHJcbiAgICB9XHJcbik7XHJcblxyXG5kZWZpbmVDb21wb25lbnRTdHlsZShcclxuICAgICdhcHAnLFxyXG4gICAgJ2NvcmUnLFxyXG4gICAge1xyXG4gICAgICAgIFwiJGh0bWxcIjoge1xyXG4gICAgICAgICAgICB3aWR0aDogJzEwMCUnLFxyXG4gICAgICAgICAgICBoZWlnaHQ6ICcxMDAlJyxcclxuICAgICAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcIiRib2R5XCI6IHtcclxuICAgICAgICAgICAgZm9udEZhbWlseTogXCJSb2JvdG9cIixcclxuICAgICAgICAgICAgcGFkZGluZzogMCxcclxuICAgICAgICAgICAgbWFyZ2luOiAwLFxyXG4gICAgICAgICAgICB3aWR0aDogJzEwMCUnXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4pO1xyXG5kZWZpbmVDb21wb25lbnRTdHlsZShcclxuICAgICdyb2JvdG8nLFxyXG4gICAgJ2ZvbnQnLFxyXG4gICAge1wiJEBmb250LWZhY2VcIjogZ2VuRm9udENTUyhcIlJvYm90b1wiLCBSb2JvdG9VUkkpfVxyXG4pO1xyXG5kZWZpbmVDb21wb25lbnRTdHlsZShcclxuICAgICdpb25pYycsXHJcbiAgICAnZm9udCcsXHJcbiAgICB7XCIkQGZvbnQtZmFjZVwiOiBnZW5Gb250Q1NTKFwiSW9uaWNcIiwgSW9uaWNVUkkpfVxyXG4pO1xyXG5cclxuY2xhc3MgU2NyZWVuIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XHJcbiAgICAgICAgc3VwZXIocHJvcHMpO1xyXG4gICAgfVxyXG5cclxuICAgIHJlbmRlciA9ICgpID0+IHtcclxuICAgICAgICByZXR1cm4gPGRpdj57dGhpcy5wcm9wcy5jaGlsZHJlbn08L2Rpdj47XHJcbiAgICB9XHJcbn1cclxuXHJcbmNvbnN0IE1haW4gPSBSZWFjdC5jcmVhdGVDbGFzcyh7XHJcbiAgICBhc3luYyBkZW1vKCkge1xyXG4gICAgICAgIGlmIChhd2FpdCBEaWFsb2cuY29uZmlybShcIlJlYWxseT9cIikgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJOb3BlIVwiKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgZ2V0SW5pdGlhbFN0YXRlKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGNoZWNrZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgICBvbjogZmFsc2UsXHJcbiAgICAgICAgICAgIGRpc2FibGVkOiBmYWxzZSxcclxuICAgICAgICAgICAgYnV0dG9uOiB7XHJcbiAgICAgICAgICAgICAgICBpbWFnZTogZmFsc2VcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaW5kZXg6IC0xLFxyXG4gICAgICAgICAgICB0ZXh0OiBcIlwiLFxyXG4gICAgICAgICAgICBwYXNzd29yZDogXCJcIixcclxuICAgICAgICAgICAgdmFsdWU6IG51bGwsXHJcbiAgICAgICAgICAgIGRhdGU6IGNocm9ubygpLFxyXG4gICAgICAgICAgICByYW5nZVZhbHVlOiAxMDBcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxuICAgIHJlbmRlcigpIHtcclxuICAgICAgICBjb25zdCB7ZGlzYWJsZWR9ID0gdGhpcy5zdGF0ZTtcclxuICAgICAgICBjb25zdCB0ZXh0SGFuZGxlciA9ICh0ZXh0LCB2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygndmFsdWUnLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe3RleHQsIHZhbHVlfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICA8U2NyZWVuIHRpdGxlPVwiVGVzdFwiIGJhY2tUZXh0PXtcInRlc3RcIn0gd2lkdGg9ezYwMH0gb25CYWNrPXt0aGlzLmRlbW99PlxyXG4gICAgICAgICAgICAgICAgey8qPEltYWdlIHNvdXJjZT17dXJsfSBoZWlnaHQ9ezE1MH0gY29sb3I9XCJjeWFuXCIgLz4qL31cclxuICAgICAgICAgICAgICAgIHsvKjxUb2dnbGUuQXdlc29tZSBvbj17dGhpcy5zdGF0ZS5vbn0gb25DaGFuZ2U9e29uID0+IHRoaXMuc2V0U3RhdGUoe29ufSl9IGxhYmVsPXtcIlRlc3RcIn0gc3ViVGl0bGU9XCJtb3JlIHRleHQ/XCIgLz4qL31cclxuICAgICAgICAgICAgICAgIHsvKjxCdXR0b24gdGV4dD17PHNwYW4+e2Rpc2FibGVkID8gPFNwaW5uZXIgc2l6ZT17MjB9IC8+IDogbnVsbH1CdXR0b24gVGV4dDwvc3Bhbj59IGRpc2FibGVkPXtkaXNhYmxlZH0gb25UYXA9eygpID0+IHRoaXMuc2V0U3RhdGUoe2Rpc2FibGVkOiB0cnVlfSl9IC8+Ki99XHJcbiAgICAgICAgICAgICAgICB7Lyo8SWNvbiBuYW1lPVwiaW9uLWNhbGVuZGFyXCIgc2l6ZT17MjB9IC8+Ki99XHJcbiAgICAgICAgICAgICAgICB7Lyo8UmFkaW8gc2VsZWN0ZWRJbmRleD17dGhpcy5zdGF0ZS5pbmRleH0gb25DaGFuZ2U9e2luZGV4ID0+IHRoaXMuc2V0U3RhdGUoe2luZGV4fSl9IHRpdGxlPVwiVGVzdFwiPlxyXG4gICAgICAgICAgICAgICAgICAgIHtBcnJheS5mcm9tKHJhbmdlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY291bnQ6IDEwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXA6IG4gPT4gPE9wdGlvbiB2YWx1ZT17biAqKiBufT57bn08L09wdGlvbj5cclxuICAgICAgICAgICAgICAgICAgICB9KSl9XHJcbiAgICAgICAgICAgICAgICAgICAgPE9wdGlvbj48SW1hZ2Ugc291cmNlPXt1cmx9IGhlaWdodD17MzB9IC8+PC9PcHRpb24+XHJcbiAgICAgICAgICAgICAgICA8L1JhZGlvPiovfVxyXG4gICAgICAgICAgICAgICAgey8qPEJ1dHRvbiB0ZXh0PVwiVGVzdFwiIC8+Ki99XHJcbiAgICAgICAgICAgICAgICB7Lyo8ZGl2IHN0eWxlPXt7d2lkdGg6ICc3NSUnLCBtYXhXaWR0aDogNDgwfX0+XHJcbiAgICAgICAgICAgICAgICAgICAgPENhbGVuZGFyIHNlbGVjdGVkRGF0ZT17bmV3IERhdGUoKX0gLz5cclxuICAgICAgICAgICAgICAgIDwvZGl2PiovfVxyXG4gICAgICAgICAgICAgICAgey8qPElucHV0LkRhdGUgb25DaGFuZ2U9e2RhdGUgPT4gdGhpcy5zZXRTdGF0ZSh7ZGF0ZX0pfSBkYXRlPXt0aGlzLnN0YXRlLmRhdGV9IGxhYmVsPVwiTXkgQmlydGhkYXk/XCIgaWNvbk5hbWU9XCJpb24tY2FsZW5kYXJcIiBmb3JtYXQ9e1wiRXhwaXJhdGlvbiBEYXRlOiB7bW9udGh9L3tkYXl9L3t5ZWFyfVwifSAvPiovfVxyXG4gICAgICAgICAgICAgICAgey8qPEJ1dHRvbiB0ZXh0PVwiV2F0XCIgb25UYXA9eygpID0+IGRpYWxvZy5zaG93KHtjb250ZW50OiA8Q2FsZW5kYXIgc2VsZWN0ZWREYXRlPXtuZXcgRGF0ZSgpfSBvbkRhdGVTZWxlY3RlZD17Y2Jsb2d9IC8+LCB0aXRsZTogXCJTZWxlY3QgRGF0ZVwiLCBidXR0b25zOiBbe3RleHQ6IFwiQ2FuY2VsXCJ9XX0pfSAvPiovfVxyXG4gICAgICAgICAgICAgICAgey8qPGlucHV0IHR5cGU9XCJkYXRldGltZVwiIC8+Ki99XHJcbiAgICAgICAgICAgICAgICB7Lyo8aW5wdXQgdHlwZT1cInRpbWVcIiBvbkNoYW5nZT17ZXZ0ID0+IGNibG9nKGV2dC50YXJnZXQudmFsdWUpfSByZWY9XCJ0ZXN0XCIgLz4qL31cclxuICAgICAgICAgICAgICAgIHsvKjxUaW1lSW5wdXQgLz4qL31cclxuICAgICAgICAgICAgICAgIHsvKjxDYXJkPlxyXG4gICAgICAgICAgICAgICAgICAgIDxSYW5nZUlucHV0IHZhbHVlPXt0aGlzLnN0YXRlLnJhbmdlVmFsdWV9IG1heD17MjU1fSBvbkNoYW5nZT17cmFuZ2VWYWx1ZSA9PiB0aGlzLnNldFN0YXRlKHtyYW5nZVZhbHVlfSl9IC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJyYW5nZVwiIHZhbHVlPXt0aGlzLnN0YXRlLnJhbmdlVmFsdWV9IG1heD17MjU1fSBvbkNoYW5nZT17ZXZ0ID0+IHRoaXMuc2V0U3RhdGUoe3JhbmdlVmFsdWU6IGV2dC50YXJnZXQudmFsdWV9KX0gLz5cclxuICAgICAgICAgICAgICAgIDwvQ2FyZD4qL31cclxuICAgICAgICAgICAgICAgIHsvKjxJbnB1dC5VUkwgbGFiZWw9XCJVUkxcIiB2YWx1ZT17dGhpcy5zdGF0ZS50ZXh0fSBvbkNoYW5nZT17KHRleHQsIHZhbGlkKSA9PiB7Y29uc29sZS5sb2codGV4dCwgdmFsaWQpOyB0aGlzLnNldFN0YXRlKHt0ZXh0fSk7fX0gLz5cclxuICAgICAgICAgICAgICAgIDxJbnB1dC5FbWFpbCBsYWJlbD1cIkVtYWlsXCIgdmFsdWU9e3RoaXMuc3RhdGUudGV4dH0gb25DaGFuZ2U9eyh0ZXh0LCB2YWxpZCkgPT4ge2NvbnNvbGUubG9nKHRleHQsIHZhbGlkKTsgdGhpcy5zZXRTdGF0ZSh7dGV4dH0pO319IC8+XHJcbiAgICAgICAgICAgICAgICA8SW5wdXQuUGFzc3dvcmQgbGFiZWw9XCJQYXNzd29yZFwiIHZhbHVlPXt0aGlzLnN0YXRlLnBhc3N3b3JkfSBvbkNoYW5nZT17cGFzc3dvcmQgPT4gdGhpcy5zZXRTdGF0ZSh7cGFzc3dvcmR9KX0gLz5cclxuICAgICAgICAgICAgICAgIDxJbnB1dC5SYW5nZSB2YWx1ZT17dGhpcy5zdGF0ZS5yYW5nZVZhbHVlfSBtYXg9ezI1NX0gb25DaGFuZ2U9e3JhbmdlVmFsdWUgPT4gdGhpcy5zZXRTdGF0ZSh7cmFuZ2VWYWx1ZX0pfSAvPlxyXG4gICAgICAgICAgICAgICAgPEZpbGVJbnB1dCB0ZXh0PVwiVGVzdFwiIG9uQ2hhbmdlPXtmaWxlcyA9PiBjb25zb2xlLmxvZyhmaWxlcyl9IG11bHRpcGxlIC8+Ki99XHJcbiAgICAgICAgICAgICAgICB7Lyo8VGltZVNlbGVjdG9yIHZhbHVlPXt0aGlzLnN0YXRlLmRhdGV9IG9uQ2hhbmdlPXtkYXRlID0+IHRoaXMuc2V0U3RhdGUoe2RhdGV9KX0gLz4qL31cclxuICAgICAgICAgICAgICAgIHsvKjxJbnB1dC5UaW1lIHZhbHVlPXt0aGlzLnN0YXRlLmRhdGV9IG9uQ2hhbmdlPXtkYXRlID0+IHRoaXMuc2V0U3RhdGUoe2RhdGV9KX0gLz5cclxuICAgICAgICAgICAgICAgIDxJbnB1dC5EYXRlIHZhbHVlPXt0aGlzLnN0YXRlLmRhdGV9IG9uQ2hhbmdlPXtkYXRlID0+IHRoaXMuc2V0U3RhdGUoe2RhdGV9KX0gLz4qL31cclxuICAgICAgICAgICAgICAgIHsvKjxJbnB1dC5GaWxlIG9uQ2hhbmdlPXtjYmxvZ30gdGV4dD1cIlNlbGVjdCBGaWxlXCIgLz4qL31cclxuICAgICAgICAgICAgICAgIHsvKjxGbGV4Ym94IGNvbENvdW50PXszfSBwYWRFbmQgbWF4SXRlbVdpZHRoPXsxMDB9IGFsaWduPVwic3BhY2UtYXJvdW5kXCI+XHJcbiAgICAgICAgICAgICAgICAgICAge2FyYW5nZSgxMSwgbiA9PiA8QnV0dG9uIHRleHQ9e259IGJsb2NrIGZsdXNoIC8+KX1cclxuICAgICAgICAgICAgICAgIDwvRmxleGJveD4qL31cclxuICAgICAgICAgICAgICAgIHsvKjxHcmlkIGNvbENvdW50PXszfSByb3dDb3VudD17NH0+XHJcbiAgICAgICAgICAgICAgICAgICAge2FyYW5nZSgxMSwgbiA9PiA8QnV0dG9uIHRleHQ9e259IGZsdXNoIGZpbGwgLz4pfVxyXG4gICAgICAgICAgICAgICAgPC9HcmlkPiovfVxyXG4gICAgICAgICAgICAgICAgey8qPFBpbmJvYXJkIGhlaWdodD17MjAwfT5cclxuICAgICAgICAgICAgICAgICAgICB7YXJhbmdlKDEyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFuZ2xlID0gKG4gLyA2KSAqIE1hdGguUEk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB4ID0gTWF0aC5jb3MoYW5nbGUpICogNzAgKyAxNDU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB5ID0gTWF0aC5zaW4oYW5nbGUpICogNzAgKyA4NTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvcyA9IHt0b3A6IHksIGxlZnQ6IHgsIHdpZHRoOiAzMCwgaGVpZ2h0OiAzMH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDxkaXYgcGluSW5mbz17cG9zfSBzdHlsZT17e3dpZHRoOiAnMTAwJScsIGhlaWdodDogJzEwMCUnLCBiYWNrZ3JvdW5kQ29sb3I6ICdjeWFuJ319PntufTwvZGl2PjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICl9XHJcbiAgICAgICAgICAgICAgICA8L1BpbmJvYXJkPiovfVxyXG4gICAgICAgICAgICAgICAgey8qPElucHV0LlNlYXJjaCBpY29uTmFtZT1cImlvbi1zZWFyY2hcIiBwbGFjZWhvbGRlcj1cIlNlYXJjaCBTdHVmZnNcIiAvPiovfVxyXG4gICAgICAgICAgICAgICAgey8qPENoZWNrYm94LkF3ZXNvbWUgY2hlY2tlZD17dGhpcy5zdGF0ZS5jaGVja2VkfSBvbkNoYW5nZT17Y2hlY2tlZCA9PiB0aGlzLnNldFN0YXRlKHtjaGVja2VkfSl9IGxhYmVsPXtcIlRlc3RcIn0gc3ViVGl0bGU9XCJtb3JlIHRleHQ/XCIgLz4qL31cclxuICAgICAgICAgICAgICAgIHsvKjxCdXR0b24gdGV4dD1cIk5vcm1hbFwiIC8+XHJcbiAgICAgICAgICAgICAgICA8QnV0dG9uIHRleHQ9XCJEaXNhYmxlZFwiIGRpc2FibGVkIC8+XHJcbiAgICAgICAgICAgICAgICA8QnV0dG9uLkNhbmNlbCB0ZXh0PVwiQ2FuY2VsXCIgLz5cclxuICAgICAgICAgICAgICAgIDxCdXR0b24uQ29uZmlybSB0ZXh0PVwiQ29uZmlybVwiIC8+XHJcbiAgICAgICAgICAgICAgICA8SW5wdXQuUmFuZ2UgdmFsdWU9e3RoaXMuc3RhdGUucmFuZ2VWYWx1ZX0gbWF4PXsyNTV9IG9uQ2hhbmdlPXtyYW5nZVZhbHVlID0+IHRoaXMuc2V0U3RhdGUoe3JhbmdlVmFsdWV9KX0gLz4qL31cclxuICAgICAgICAgICAgICAgIDxGb3JtIGxhYmVsPVwiRm9ybVwiPlxyXG4gICAgICAgICAgICAgICAgICAgIHsvKjxSYWRpbyBsYXlvdXQ9e1BpbmJvYXJkfSBsYXlvdXQtaGVpZ2h0PXsyMDB9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7YXJhbmdlKDEyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbiA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYW5nbGUgPSAobiAvIDYpICogTWF0aC5QSTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB4ID0gTWF0aC5jb3MoYW5nbGUpICogNzAgKyAxNDU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeSA9IE1hdGguc2luKGFuZ2xlKSAqIDcwICsgODU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9zID0ge3RvcDogeSwgbGVmdDogeCwgd2lkdGg6IDMwLCBoZWlnaHQ6IDMwfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDxkaXYgcGluSW5mbz17cG9zfSBzdHlsZT17e3dpZHRoOiAnMTAwJScsIGhlaWdodDogJzEwMCUnfX0+e259PC9kaXY+O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICApfVxyXG4gICAgICAgICAgICAgICAgICAgIDwvUmFkaW8+Ki99XHJcbiAgICAgICAgICAgICAgICAgICAgPFJhZGlvIHRpdGxlPVwiVGVzdFwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7QXJyYXkuZnJvbShyYW5nZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudDogMTAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXA6IG4gPT4gPE9wdGlvbiB2YWx1ZT17biAqKiBufT57bn08L09wdGlvbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8T3B0aW9uPjxJbWFnZSBzb3VyY2U9e3VybH0gaGVpZ2h0PXszMH0gLz48L09wdGlvbj5cclxuICAgICAgICAgICAgICAgICAgICA8L1JhZGlvPlxyXG4gICAgICAgICAgICAgICAgICAgIHsvKjxJbnB1dC5UZXh0IGZvcm1OYW1lPVwiVGV4dFwiIHBsYWNlaG9sZGVyPVwiVGV4dFwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPElucHV0LlBhc3N3b3JkIGZvcm1OYW1lPVwiUGFzc3dvcmRcIiBwbGFjZWhvbGRlcj1cIlBhc3N3b3JkXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICA8SW5wdXQuU2VhcmNoIGZvcm1OYW1lPVwiU2VhcmNoXCIgcGxhY2Vob2xkZXI9XCJTZWFyY2hcIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDxJbnB1dC5VUkwgZm9ybU5hbWU9XCJVUkxcIiBwbGFjZWhvbGRlcj1cIlVSTFwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPElucHV0LkVtYWlsIGZvcm1OYW1lPVwiRW1haWxcIiBwbGFjZWhvbGRlcj1cIkVtYWlsXCIgLz5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgPElucHV0LkRhdGUgZm9ybU5hbWU9XCJkYXRlXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICA8SW5wdXQuVGltZSBmb3JtTmFtZT1cInRpbWVcIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDxJbnB1dC5GaWxlIGZvcm1OYW1lPVwiZmlsZVwiIG11bHRpcGxlIHZhbHVlRm9ybWF0PXtsaXN0ID0+IGBGaWxlcyBTZWxlY3RlZDogJHtsaXN0Lmxlbmd0aH1gfSAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDxJbnB1dC5SYW5nZSBmb3JtTmFtZT1cInJhbmdlXCIgbWluPXswfSBtYXg9ezI1NX0gLz4qL31cclxuICAgICAgICAgICAgICAgIDwvRm9ybT5cclxuICAgICAgICAgICAgICAgIHsvKjxkaXYgc3R5bGU9e3twb3NpdGlvbjogJ2Fic29sdXRlJywgYm90dG9tOiAwLCBoZWlnaHQ6IDUwLCB3aWR0aDogNTAsIGJhY2tncm91bmRDb2xvcjogJ2N5YW4nfX0gLz4qL31cclxuICAgICAgICAgICAgICAgIHsvKjxJbnB1dC5GaWxlKi99XHJcbiAgICAgICAgICAgICAgICB7Lyo8Q2FyZD5cclxuICAgICAgICAgICAgICAgICAgICA8UGluYm9hcmQgaGVpZ2h0PXs1MH0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxJY29uIG5hbWU9XCJpb24taGFwcHlcIiBzaXplPXs0MH0gcGluSW5mbz17e3RvcDogMCwgbGVmdDogMTAsIHdpZHRoOiA0MCwgaGVpZ2h0OiA1MH19IC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgcGluSW5mbz17e3RvcDogMCwgbGVmdDogNTV9fT5Vc2VyIE5hbWUgVGhpbmc/PC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgcGluSW5mbz17e3RvcDogMzAsIGxlZnQ6IDU1LCBmb250U2l6ZTogMTF9fT5Vc2VyIGluZm9ybWF0aW9uIGFib3V0IHBvc2l0aW9uZCBhbmQgc3R1ZmY8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBwaW5JbmZvPXt7dG9wOiA1LCBsZWZ0OiA1LCB3aWR0aDogMTAsIGhlaWdodDogMTAsIGJhY2tncm91bmRDb2xvcjogJ2N5YW4nfX0gLz5cclxuICAgICAgICAgICAgICAgICAgICA8L1BpbmJvYXJkPlxyXG4gICAgICAgICAgICAgICAgPC9DYXJkPiovfVxyXG4gICAgICAgICAgICAgICAgPERpYWxvZ0NvbXBvbmVudCAvPlxyXG4gICAgICAgICAgICA8L1NjcmVlbj5cclxuICAgICAgICApO1xyXG4gICAgfVxyXG59KTtcclxuXHJcbi8vIEFwcC5zdGFydChcclxuLy8gICAgIDxSb3V0ZSBjb21wb25lbnQ9e1dyYXBwZXJ9PlxyXG4vLyAgICAgICAgIDxSb3V0ZSBwYXRoPVwiL1wiIGNvbXBvbmVudD17TWFpbn0gLz5cclxuLy8gICAgICAgICA8Um91dGUgcGF0aD1cIi90ZXN0XCIgY29tcG9uZW50PXtNYWlufSAvPlxyXG4vLyAgICAgPC9Sb3V0ZT5cclxuLy8gKTtcclxud2luZG93LnFzZWwgPSAoLi4uYXJncykgPT4gZG9jdW1lbnQucXVlcnlTZWxlY3RvciguLi5hcmdzKTtcclxuY3JlYXRlU3R5bGVzKCk7XHJcbihhc3luYyAoKSA9PiB7XHJcbiAgICBhd2FpdCBkZXZpY2VSZWFkeTtcclxuICAgIFJlYWN0RE9NLnJlbmRlcihcclxuICAgICAgICA8TWFpbiAvPixcclxuICAgICAgICBxc2VsKFwiI2FwcC1jb250YWluZXJcIilcclxuICAgICk7XHJcbn0pKCk7XHJcblxyXG4vLyBjb25zdCB0b2tlbiA9IGFqYXguY2FuY2VsVG9rZW4oKTtcclxuLy8gKGFzeW5jICgpID0+IHtcclxuLy8gICAgIGNvbnNvbGUubG9nKGF3YWl0IGFqYXgoXCJodHRwOi8vYXhlbDY2OS5uZXQvZWNoby9pbmRleDIucGhwXCIsIHtwb3N0OiBbMSwgMiwgMywgNF0sIHRva2VufSkpO1xyXG4vLyB9KSgpO1xyXG4vLyBjaHJvbm8udHJpZ2dlcigyMDAwLCB0b2tlbi5jYW5jZWwpO1xyXG5cclxuLy8gY29uc3QgaXNQb3cyID0gbiA9PiAobiAmIC1uKSA9PT0gbjtcclxuLy8gd2luZG93LmNvbGxhdHogPSBuID0+IChuICUgMiA9PT0gMCkgPyBuIC8gMiA6IDMgKiBuICsgMTtcclxuLy8gd2luZG93LmNoZWNrID0gc3RhcnQgPT4ge1xyXG4vLyAgICAgd2hpbGUgKHRydWUpIHtcclxuLy8gICAgICAgICBpZiAoc3RhcnQgPT09IDEpIHtcclxuLy8gICAgICAgICAgICAgYnJlYWs7XHJcbi8vICAgICAgICAgfVxyXG4vLyAgICAgICAgIGNvbnNvbGUubG9nKHN0YXJ0KTtcclxuLy8gICAgICAgICBzdGFydCA9IGNvbGxhdHooc3RhcnQpO1xyXG4vLyAgICAgfVxyXG4vLyB9O1xyXG4vL1xyXG4vLyBjb25zdCBmID0gbiA9PiAobiAmIC1uKTtcclxuLy8gZm9yIChjb25zdCBpIG9mIGZyYW5nZSgxMDApKSB7XHJcbi8vICAgICBjb25zb2xlLmxvZyhpLCBmKGkpKTtcclxuLy8gfVxyXG4iXX0=
